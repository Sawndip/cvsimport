head	1.783;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.745.2.8
	gdb_7_6-2013-04-26-release:1.745.2.5
	gdb_7_6-branch:1.745.0.2
	gdb_7_6-2013-03-12-branchpoint:1.745
	gdb_7_5_1-2012-11-29-release:1.690.2.1
	gdb_7_5-2012-08-17-release:1.690.2.1
	gdb_7_5-branch:1.690.0.2
	gdb_7_5-2012-07-18-branchpoint:1.690
	gdb_7_4_1-2012-04-26-release:1.633.2.5
	gdb_7_4-2012-01-24-release:1.633.2.4
	gdb_7_4-branch:1.633.0.2
	gdb_7_4-2011-12-13-branchpoint:1.633
	gdb_7_3_1-2011-09-04-release:1.561.2.4
	gdb_7_3-2011-07-26-release:1.561.2.4
	gdb_7_3-branch:1.561.0.2
	gdb_7_3-2011-04-01-branchpoint:1.561
	gdb_7_2-2010-09-02-release:1.501.2.1
	gdb_7_2-branch:1.501.0.2
	gdb_7_2-2010-07-07-branchpoint:1.501
	gdb_7_1-2010-03-18-release:1.455
	gdb_7_1-branch:1.455.0.2
	gdb_7_1-2010-02-18-branchpoint:1.455
	gdb_7_0_1-2009-12-22-release:1.419
	gdb_7_0-2009-10-06-release:1.419
	gdb_7_0-branch:1.419.0.2
	gdb_7_0-2009-09-16-branchpoint:1.419
	arc-sim-20090309:1.303
	msnyder-checkpoint-072509-branch:1.413.0.2
	msnyder-checkpoint-072509-branchpoint:1.413
	arc-insight_6_8-branch:1.303.0.6
	arc-insight_6_8-branchpoint:1.303
	insight_6_8-branch:1.303.0.4
	insight_6_8-branchpoint:1.303
	reverse-20081226-branch:1.368.0.2
	reverse-20081226-branchpoint:1.368
	multiprocess-20081120-branch:1.361.0.2
	multiprocess-20081120-branchpoint:1.361
	reverse-20080930-branch:1.352.0.2
	reverse-20080930-branchpoint:1.352
	reverse-20080717-branch:1.336.0.2
	reverse-20080717-branchpoint:1.336
	msnyder-reverse-20080609-branch:1.324.0.2
	msnyder-reverse-20080609-branchpoint:1.324
	drow-reverse-20070409-branch:1.243.0.2
	drow-reverse-20070409-branchpoint:1.243
	gdb_6_8-2008-03-27-release:1.303
	gdb_6_8-branch:1.303.0.2
	gdb_6_8-2008-02-26-branchpoint:1.303
	gdb_6_7_1-2007-10-29-release:1.263
	gdb_6_7-2007-10-10-release:1.263
	gdb_6_7-branch:1.263.0.2
	gdb_6_7-2007-09-07-branchpoint:1.263
	insight_6_6-20070208-release:1.231
	gdb_6_6-2006-12-18-release:1.231
	gdb_6_6-branch:1.231.0.2
	gdb_6_6-2006-11-15-branchpoint:1.231
	insight_6_5-20061003-release:1.226
	gdb-csl-symbian-6_4_50_20060226-12:1.223.2.1.2.1
	gdb-csl-sourcerygxx-3_4_4-25:1.217
	nickrob-async-20060828-mergepoint:1.229
	gdb-csl-symbian-6_4_50_20060226-11:1.223.2.1.2.1
	gdb-csl-sourcerygxx-4_1-17:1.223.2.3
	gdb-csl-20060226-branch-local-2:1.223.2.3
	gdb-csl-sourcerygxx-4_1-14:1.223.2.3
	gdb-csl-sourcerygxx-4_1-13:1.223.2.3
	gdb-csl-sourcerygxx-4_1-12:1.223.2.3
	gdb-csl-sourcerygxx-3_4_4-21:1.223.2.3
	gdb_6_5-20060621-release:1.226
	gdb-csl-sourcerygxx-4_1-9:1.223.2.3
	gdb-csl-sourcerygxx-4_1-8:1.223.2.3
	gdb-csl-sourcerygxx-4_1-7:1.223.2.3
	gdb-csl-arm-2006q1-6:1.223.2.3
	gdb-csl-sourcerygxx-4_1-6:1.223.2.3
	gdb-csl-symbian-6_4_50_20060226-10:1.223.2.1.2.1
	gdb-csl-symbian-6_4_50_20060226-9:1.223.2.1.2.1
	gdb-csl-symbian-6_4_50_20060226-8:1.223.2.1.2.1
	gdb-csl-coldfire-4_1-11:1.223.2.1
	gdb-csl-sourcerygxx-3_4_4-19:1.223.2.1
	gdb-csl-coldfire-4_1-10:1.223.2.1
	gdb_6_5-branch:1.226.0.6
	gdb_6_5-2006-05-14-branchpoint:1.226
	gdb-csl-sourcerygxx-4_1-5:1.223.2.1
	nickrob-async-20060513-branch:1.226.0.4
	nickrob-async-20060513-branchpoint:1.226
	gdb-csl-sourcerygxx-4_1-4:1.223.2.1
	msnyder-reverse-20060502-branch:1.226.0.2
	msnyder-reverse-20060502-branchpoint:1.226
	gdb-csl-morpho-4_1-4:1.223.2.1
	gdb-csl-sourcerygxx-3_4_4-17:1.223.2.1
	readline_5_1-import-branch:1.225.0.2
	readline_5_1-import-branchpoint:1.225
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.223.2.1
	gdb-csl-symbian-20060226-branch:1.223.2.1.0.2
	gdb-csl-symbian-20060226-branchpoint:1.223.2.1
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.223.2.1
	msnyder-reverse-20060331-branch:1.223.0.6
	msnyder-reverse-20060331-branchpoint:1.223
	gdb-csl-available-20060303-branch:1.223.0.4
	gdb-csl-available-20060303-branchpoint:1.223
	gdb-csl-20060226-branch:1.223.0.2
	gdb-csl-20060226-branchpoint:1.223
	gdb_6_4-20051202-release:1.217
	msnyder-fork-checkpoint-branch:1.217.0.10
	msnyder-fork-checkpoint-branchpoint:1.217
	gdb-csl-gxxpro-6_3-branch:1.217.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.217
	gdb_6_4-branch:1.217.0.6
	gdb_6_4-2005-11-01-branchpoint:1.217
	gdb-csl-arm-20051020-branch:1.217.0.4
	gdb-csl-arm-20051020-branchpoint:1.217
	msnyder-tracepoint-checkpoint-branch:1.217.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.217
	gdb-csl-arm-20050325-2005-q1b:1.212
	gdb-csl-arm-20050325-2005-q1a:1.212
	csl-arm-20050325-branch:1.212.0.2
	csl-arm-20050325-branchpoint:1.212
	gdb-post-i18n-errorwarning-20050211:1.203
	gdb-pre-i18n-errorwarning-20050211:1.202
	gdb_6_3-20041109-release:1.183
	gdb_6_3-branch:1.183.0.2
	gdb_6_3-20041019-branchpoint:1.183
	drow_intercu-merge-20040921:1.182
	drow_intercu-merge-20040915:1.182
	jimb-gdb_6_2-e500-branch:1.176.0.6
	jimb-gdb_6_2-e500-branchpoint:1.176
	gdb_6_2-20040730-release:1.176
	gdb_6_2-branch:1.176.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.176
	gdb_6_1_1-20040616-release:1.162.2.1
	gdb_6_1-2004-04-05-release:1.162
	drow_intercu-merge-20040402:1.165
	drow_intercu-merge-20040327:1.165
	ezannoni_pie-20040323-branch:1.165.0.2
	ezannoni_pie-20040323-branchpoint:1.165
	cagney_tramp-20040321-mergepoint:1.164
	cagney_tramp-20040309-branch:1.162.0.4
	cagney_tramp-20040309-branchpoint:1.162
	gdb_6_1-branch:1.162.0.2
	gdb_6_1-2004-03-01-gmt-branchpoint:1.162
	drow_intercu-20040221-branch:1.158.0.4
	drow_intercu-20040221-branchpoint:1.158
	cagney_bfdfile-20040213-branch:1.158.0.2
	cagney_bfdfile-20040213-branchpoint:1.158
	drow-cplus-merge-20040208:1.158
	carlton_dictionary-20040126-merge:1.149
	cagney_bigcore-20040122-branch:1.149.0.2
	cagney_bigcore-20040122-branchpoint:1.149
	drow-cplus-merge-20040113:1.148
	drow-cplus-merge-20031224:1.148
	drow-cplus-merge-20031220:1.147
	carlton_dictionary-20031215-merge:1.146
	drow-cplus-merge-20031214:1.146
	carlton-dictionary-20031111-merge:1.143
	gdb_6_0-2003-10-04-release:1.124.2.1
	kettenis_sparc-20030918-branch:1.129.0.4
	kettenis_sparc-20030918-branchpoint:1.129
	carlton_dictionary-20030917-merge:1.129
	ezannoni_pie-20030916-branchpoint:1.129
	ezannoni_pie-20030916-branch:1.129.0.2
	cagney_x86i386-20030821-branch:1.126.0.2
	cagney_x86i386-20030821-branchpoint:1.126
	carlton_dictionary-20030805-merge:1.125
	carlton_dictionary-20030627-merge:1.124
	gdb_6_0-branch:1.124.0.2
	gdb_6_0-2003-06-23-branchpoint:1.124
	jimb-ppc64-linux-20030613-branch:1.122.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.122
	cagney_convert-20030606-branch:1.121.0.2
	cagney_convert-20030606-branchpoint:1.121
	cagney_writestrings-20030508-branch:1.120.0.8
	cagney_writestrings-20030508-branchpoint:1.120
	jimb-ppc64-linux-20030528-branch:1.120.0.6
	jimb-ppc64-linux-20030528-branchpoint:1.120
	carlton_dictionary-20030523-merge:1.120
	cagney_fileio-20030521-branch:1.120.0.4
	cagney_fileio-20030521-branchpoint:1.120
	kettenis_i386newframe-20030517-mergepoint:1.120
	jimb-ppc64-linux-20030509-branch:1.120.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.120
	kettenis_i386newframe-20030504-mergepoint:1.119
	carlton_dictionary-20030430-merge:1.119
	kettenis_i386newframe-20030419-branch:1.118.0.2
	kettenis_i386newframe-20030419-branchpoint:1.118
	carlton_dictionary-20030416-merge:1.118
	cagney_frameaddr-20030409-mergepoint:1.118
	kettenis_i386newframe-20030406-branch:1.117.0.4
	kettenis_i386newframe-20030406-branchpoint:1.117
	cagney_frameaddr-20030403-branchpoint:1.117
	cagney_frameaddr-20030403-branch:1.117.0.2
	cagney_framebase-20030330-mergepoint:1.116
	cagney_framebase-20030326-branch:1.116.0.2
	cagney_framebase-20030326-branchpoint:1.116
	cagney_lazyid-20030317-branch:1.115.0.2
	cagney_lazyid-20030317-branchpoint:1.115
	kettenis-i386newframe-20030316-mergepoint:1.115
	offbyone-20030313-branch:1.114.0.2
	offbyone-20030313-branchpoint:1.114
	kettenis-i386newframe-20030308-branch:1.112.0.4
	kettenis-i386newframe-20030308-branchpoint:1.112
	carlton_dictionary-20030305-merge:1.112
	cagney_offbyone-20030303-branch:1.112.0.2
	cagney_offbyone-20030303-branchpoint:1.112
	carlton_dictionary-20030207-merge:1.109
	interps-20030203-mergepoint:1.108
	interps-20030202-branch:1.107.0.2
	interps-20030202-branchpoint:1.107
	cagney-unwind-20030108-branch:1.105.0.2
	cagney-unwind-20030108-branchpoint:1.105
	carlton_dictionary-20021223-merge:1.104
	gdb_5_3-2002-12-12-release:1.85
	carlton_dictionary-20021115-merge:1.93
	kseitz_interps-20021105-merge:1.92
	kseitz_interps-20021103-merge:1.92
	drow-cplus-merge-20021020:1.91
	drow-cplus-merge-20021025:1.92
	carlton_dictionary-20021025-merge:1.92
	carlton_dictionary-20021011-merge:1.90
	drow-cplus-branch:1.90.0.2
	drow-cplus-branchpoint:1.90
	kseitz_interps-20020930-merge:1.90
	carlton_dictionary-20020927-merge:1.90
	carlton_dictionary-branch:1.89.0.2
	carlton_dictionary-20020920-branchpoint:1.89
	gdb_5_3-branch:1.85.0.2
	gdb_5_3-2002-09-04-branchpoint:1.85
	kseitz_interps-20020829-merge:1.84
	cagney_sysregs-20020825-branch:1.82.0.4
	cagney_sysregs-20020825-branchpoint:1.82
	readline_4_3-import-branch:1.82.0.2
	readline_4_3-import-branchpoint:1.82
	gdb_5_2_1-2002-07-23-release:1.66
	kseitz_interps-20020528-branch:1.75.0.6
	kseitz_interps-20020528-branchpoint:1.75
	cagney_regbuf-20020515-branch:1.75.0.4
	cagney_regbuf-20020515-branchpoint:1.75
	jimb-macro-020506-branch:1.75.0.2
	jimb-macro-020506-branchpoint:1.75
	gdb_5_2-2002-04-29-release:1.66
	gdb_5_2-branch:1.66.0.2
	gdb_5_2-2002-03-03-branchpoint:1.66
	gdb_5_1_1-2002-01-24-release:1.51.2.2
	gdb_5_1_0_1-2002-01-03-release:1.51.2.2
	cygnus_cvs_20020108_pre:1.57
	gdb_5_1_0_1-2002-01-03-branchpoint:1.51.2.2
	gdb_5_1_0_1-2002-01-03-branch:1.51.2.2.0.2
	gdb_5_1-2001-11-21-release:1.51.2.2
	gdb_s390-2001-09-26-branch:1.51.2.1.0.2
	gdb_s390-2001-09-26-branchpoint:1.51.2.1
	gdb_5_1-2001-07-29-branch:1.51.0.2
	gdb_5_1-2001-07-29-branchpoint:1.51
	dberlin-typesystem-branch:1.49.0.2
	dberlin-typesystem-branchpoint:1.49
	gdb-post-ptid_t-2001-05-03:1.32
	gdb-pre-ptid_t-2001-05-03:1.31
	insight-precleanup-2001-01-01:1.22
	gdb-post-protoization-2000-07-29:1.15
	gdb-pre-protoization-2000-07-29:1.14
	gdb-premipsmulti-2000-06-06-branch:1.12.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.12
	gdb-post-params-removal-2000-06-04:1.12
	gdb-pre-params-removal-2000-06-04:1.11
	gdb-post-params-removal-2000-05-28:1.11
	gdb-pre-params-removal-2000-05-28:1.10
	gdb_5_0-2000-05-19-release:1.8
	gdb_4_18_2-2000-05-18-release:1.8
	gdb_4_95_1-2000-05-11-snapshot:1.8
	gdb_4_95_0-2000-04-27-snapshot:1.8
	gdb_5_0-2000-04-10-branch:1.8.0.2
	gdb_5_0-2000-04-10-branchpoint:1.8
	repo-unification-2000-02-06:1.1.1.24
	insight-2000-02-04:1.1.1.24
	gdb-2000-02-04:1.1.1.24
	gdb-2000-02-02:1.1.1.24
	gdb-2000-02-01:1.1.1.23
	gdb-2000-01-31:1.1.1.23
	gdb-2000-01-26:1.1.1.23
	gdb-2000-01-24:1.1.1.23
	gdb-2000-01-17:1.1.1.23
	gdb-2000-01-10:1.1.1.23
	gdb-2000-01-05:1.1.1.22
	gdb-1999-12-21:1.1.1.21
	gdb-1999-12-13:1.1.1.20
	gdb-1999-12-07:1.1.1.19
	gdb-1999-12-06:1.1.1.19
	gdb-1999-11-16:1.1.1.18
	gdb-1999-11-08:1.1.1.17
	gdb-1999-11-01:1.1.1.16
	gdb-1999-10-25:1.1.1.15
	gdb-1999-10-18:1.1.1.14
	gdb-1999-10-11:1.1.1.13
	gdb-1999-10-04:1.1.1.13
	gdb-1999-09-28:1.1.1.12
	gdb-1999-09-21:1.1.1.11
	gdb-1999-09-13:1.1.1.10
	gdb-1999-09-08:1.1.1.10
	gdb-1999-08-30:1.1.1.9
	gdb-1999-08-23:1.1.1.8
	gdb-1999-08-16:1.1.1.7
	gdb-1999-08-09:1.1.1.7
	gdb-1999-08-02:1.1.1.7
	gdb-1999-07-26:1.1.1.7
	gdb-1999-07-19:1.1.1.7
	gdb-1999-07-12:1.1.1.7
	gdb-post-reformat-19990707:1.1.1.7
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.7
	gdb-pre-reformat-19990707:1.1.1.6
	gdb-1999-07-07:1.1.1.6
	gdb-1999-07-05:1.1.1.6
	gdb-1999-06-28:1.1.1.5
	gdb-1999-06-21:1.1.1.5
	gdb-1999-06-14:1.1.1.5
	gdb-1999-06-07:1.1.1.5
	gdb-1999-06-01:1.1.1.5
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.4
	gdb-1999-05-19:1.1.1.3
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.783
date	2013.10.18.16.25.14;	author aburgess;	state Exp;
branches;
next	1.782;

1.782
date	2013.10.11.13.48.19;	author brobecke;	state Exp;
branches;
next	1.781;

1.781
date	2013.10.09.17.00.00;	author palves;	state Exp;
branches;
next	1.780;

1.780
date	2013.10.07.11.00.23;	author palves;	state Exp;
branches;
next	1.779;

1.779
date	2013.09.30.11.50.10;	author luisgpm;	state Exp;
branches;
next	1.778;

1.778
date	2013.09.19.14.45.33;	author palves;	state Exp;
branches;
next	1.777;

1.777
date	2013.09.17.19.32.46;	author palves;	state Exp;
branches;
next	1.776;

1.776
date	2013.08.23.06.22.09;	author mwaqas;	state Exp;
branches;
next	1.775;

1.775
date	2013.08.09.15.33.09;	author palves;	state Exp;
branches;
next	1.774;

1.774
date	2013.08.02.16.41.08;	author tromey;	state Exp;
branches;
next	1.773;

1.773
date	2013.07.24.19.50.32;	author sergiodj;	state Exp;
branches;
next	1.772;

1.772
date	2013.07.06.07.14.54;	author qiyao;	state Exp;
branches;
next	1.771;

1.771
date	2013.06.26.08.01.55;	author qiyao;	state Exp;
branches;
next	1.770;

1.770
date	2013.06.25.11.37.48;	author teawater;	state Exp;
branches;
next	1.769;

1.769
date	2013.06.20.06.49.06;	author qiyao;	state Exp;
branches;
next	1.768;

1.768
date	2013.06.20.06.46.11;	author qiyao;	state Exp;
branches;
next	1.767;

1.767
date	2013.06.19.19.07.16;	author tromey;	state Exp;
branches;
next	1.766;

1.766
date	2013.06.18.19.57.48;	author tromey;	state Exp;
branches;
next	1.765;

1.765
date	2013.06.04.13.17.06;	author gary;	state Exp;
branches;
next	1.764;

1.764
date	2013.05.30.17.09.02;	author tromey;	state Exp;
branches;
next	1.763;

1.763
date	2013.05.21.18.47.05;	author philippe;	state Exp;
branches;
next	1.762;

1.762
date	2013.05.21.04.18.54;	author teawater;	state Exp;
branches;
next	1.761;

1.761
date	2013.05.07.17.04.28;	author sergiodj;	state Exp;
branches;
next	1.760;

1.760
date	2013.05.06.14.15.49;	author brobecke;	state Exp;
branches;
next	1.759;

1.759
date	2013.04.24.23.09.31;	author teawater;	state Exp;
branches;
next	1.758;

1.758
date	2013.04.23.03.20.20;	author teawater;	state Exp;
branches;
next	1.757;

1.757
date	2013.04.23.02.42.43;	author teawater;	state Exp;
branches;
next	1.756;

1.756
date	2013.04.15.18.04.53;	author tromey;	state Exp;
branches;
next	1.755;

1.755
date	2013.04.15.17.36.13;	author tromey;	state Exp;
branches;
next	1.754;

1.754
date	2013.04.15.17.27.43;	author tromey;	state Exp;
branches;
next	1.753;

1.753
date	2013.04.10.04.35.20;	author teawater;	state Exp;
branches;
next	1.752;

1.752
date	2013.04.08.20.18.11;	author tromey;	state Exp;
branches;
next	1.751;

1.751
date	2013.04.08.19.59.08;	author tromey;	state Exp;
branches;
next	1.750;

1.750
date	2013.04.08.14.09.29;	author palves;	state Exp;
branches;
next	1.749;

1.749
date	2013.04.04.19.22.38;	author palves;	state Exp;
branches;
next	1.748;

1.748
date	2013.04.01.12.48.03;	author aristovski;	state Exp;
branches;
next	1.747;

1.747
date	2013.03.20.22.17.18;	author kseitz;	state Exp;
branches;
next	1.746;

1.746
date	2013.03.13.18.34.53;	author palves;	state Exp;
branches;
next	1.745;

1.745
date	2013.03.12.17.39.43;	author kseitz;	state Exp;
branches
	1.745.2.1;
next	1.744;

1.744
date	2013.03.07.21.57.29;	author kseitz;	state Exp;
branches;
next	1.743;

1.743
date	2013.03.07.18.50.53;	author palves;	state Exp;
branches;
next	1.742;

1.742
date	2013.02.05.20.23.19;	author jkratoch;	state Exp;
branches;
next	1.741;

1.741
date	2013.02.03.16.13.28;	author jkratoch;	state Exp;
branches;
next	1.740;

1.740
date	2013.02.03.16.00.35;	author jkratoch;	state Exp;
branches;
next	1.739;

1.739
date	2013.02.03.15.57.06;	author jkratoch;	state Exp;
branches;
next	1.738;

1.738
date	2013.01.22.20.19.38;	author palves;	state Exp;
branches;
next	1.737;

1.737
date	2013.01.22.20.08.28;	author palves;	state Exp;
branches;
next	1.736;

1.736
date	2013.01.21.23.57.59;	author marckhouzam;	state Exp;
branches;
next	1.735;

1.735
date	2013.01.16.17.31.37;	author tromey;	state Exp;
branches;
next	1.734;

1.734
date	2013.01.16.17.27.51;	author tromey;	state Exp;
branches;
next	1.733;

1.733
date	2013.01.11.00.41.08;	author qiyao;	state Exp;
branches;
next	1.732;

1.732
date	2013.01.03.07.13.27;	author qiyao;	state Exp;
branches;
next	1.731;

1.731
date	2013.01.01.06.32.39;	author brobecke;	state Exp;
branches;
next	1.730;

1.730
date	2012.12.25.08.03.30;	author jkratoch;	state Exp;
branches;
next	1.729;

1.729
date	2012.12.24.19.40.03;	author jkratoch;	state Exp;
branches;
next	1.728;

1.728
date	2012.12.18.19.27.00;	author tromey;	state Exp;
branches;
next	1.727;

1.727
date	2012.12.16.18.57.16;	author jkratoch;	state Exp;
branches;
next	1.726;

1.726
date	2012.12.15.02.19.18;	author qiyao;	state Exp;
branches;
next	1.725;

1.725
date	2012.12.15.01.37.03;	author qiyao;	state Exp;
branches;
next	1.724;

1.724
date	2012.12.12.21.20.12;	author mgherzan;	state Exp;
branches;
next	1.723;

1.723
date	2012.12.03.19.59.13;	author tromey;	state Exp;
branches;
next	1.722;

1.722
date	2012.12.01.02.16.28;	author qiyao;	state Exp;
branches;
next	1.721;

1.721
date	2012.11.30.14.46.39;	author qiyao;	state Exp;
branches;
next	1.720;

1.720
date	2012.11.28.11.56.15;	author qiyao;	state Exp;
branches;
next	1.719;

1.719
date	2012.11.20.22.51.04;	author muller;	state Exp;
branches;
next	1.718;

1.718
date	2012.11.20.17.49.02;	author palves;	state Exp;
branches;
next	1.717;

1.717
date	2012.11.10.20.25.56;	author kseitz;	state Exp;
branches;
next	1.716;

1.716
date	2012.11.09.19.57.58;	author tromey;	state Exp;
branches;
next	1.715;

1.715
date	2012.11.09.07.21.01;	author qiyao;	state Exp;
branches;
next	1.714;

1.714
date	2012.11.07.00.42.14;	author qiyao;	state Exp;
branches;
next	1.713;

1.713
date	2012.11.06.15.25.03;	author palves;	state Exp;
branches;
next	1.712;

1.712
date	2012.11.03.12.14.45;	author qiyao;	state Exp;
branches;
next	1.711;

1.711
date	2012.11.02.19.05.12;	author tromey;	state Exp;
branches;
next	1.710;

1.710
date	2012.10.18.20.14.44;	author tromey;	state Exp;
branches;
next	1.709;

1.709
date	2012.10.18.20.12.21;	author tromey;	state Exp;
branches;
next	1.708;

1.708
date	2012.10.17.00.53.21;	author qiyao;	state Exp;
branches;
next	1.707;

1.707
date	2012.09.26.16.35.59;	author aburgess;	state Exp;
branches;
next	1.706;

1.706
date	2012.09.26.02.06.54;	author siddhesh;	state Exp;
branches;
next	1.705;

1.705
date	2012.09.25.12.48.52;	author siddhesh;	state Exp;
branches;
next	1.704;

1.704
date	2012.09.17.07.03.14;	author jkratoch;	state Exp;
branches;
next	1.703;

1.703
date	2012.09.12.20.01.10;	author wrighton;	state Exp;
branches;
next	1.702;

1.702
date	2012.08.27.16.55.35;	author jkratoch;	state Exp;
branches;
next	1.701;

1.701
date	2012.08.22.15.17.20;	author tromey;	state Exp;
branches;
next	1.700;

1.700
date	2012.08.16.23.54.50;	author brobecke;	state Exp;
branches;
next	1.699;

1.699
date	2012.08.13.01.02.07;	author qiyao;	state Exp;
branches;
next	1.698;

1.698
date	2012.08.13.00.54.04;	author qiyao;	state Exp;
branches;
next	1.697;

1.697
date	2012.08.09.06.48.21;	author qiyao;	state Exp;
branches;
next	1.696;

1.696
date	2012.08.08.20.39.34;	author kseitz;	state Exp;
branches;
next	1.695;

1.695
date	2012.07.24.17.37.56;	author marckhouzam;	state Exp;
branches;
next	1.694;

1.694
date	2012.07.19.15.38.16;	author tromey;	state Exp;
branches;
next	1.693;

1.693
date	2012.07.19.15.33.24;	author tromey;	state Exp;
branches;
next	1.692;

1.692
date	2012.07.18.20.20.51;	author kseitz;	state Exp;
branches;
next	1.691;

1.691
date	2012.07.18.19.30.20;	author kseitz;	state Exp;
branches;
next	1.690;

1.690
date	2012.07.05.01.00.32;	author teawater;	state Exp;
branches
	1.690.2.1;
next	1.689;

1.689
date	2012.07.02.15.29.33;	author shebs;	state Exp;
branches;
next	1.688;

1.688
date	2012.07.02.03.36.04;	author sergiodj;	state Exp;
branches;
next	1.687;

1.687
date	2012.07.01.10.37.03;	author qiyao;	state Exp;
branches;
next	1.686;

1.686
date	2012.06.29.22.46.44;	author devans;	state Exp;
branches;
next	1.685;

1.685
date	2012.06.27.18.08.39;	author tromey;	state Exp;
branches;
next	1.684;

1.684
date	2012.06.18.17.28.36;	author jkratoch;	state Exp;
branches;
next	1.683;

1.683
date	2012.06.13.15.50.19;	author tromey;	state Exp;
branches;
next	1.682;

1.682
date	2012.06.13.15.47.14;	author tromey;	state Exp;
branches;
next	1.681;

1.681
date	2012.06.13.15.41.21;	author tromey;	state Exp;
branches;
next	1.680;

1.680
date	2012.06.11.19.16.23;	author jkratoch;	state Exp;
branches;
next	1.679;

1.679
date	2012.06.05.19.50.50;	author palves;	state Exp;
branches;
next	1.678;

1.678
date	2012.06.05.13.50.11;	author brobecke;	state Exp;
branches;
next	1.677;

1.677
date	2012.05.24.16.51.34;	author palves;	state Exp;
branches;
next	1.676;

1.676
date	2012.05.18.21.02.47;	author sergiodj;	state Exp;
branches;
next	1.675;

1.675
date	2012.05.16.14.35.03;	author macro;	state Exp;
branches;
next	1.674;

1.674
date	2012.05.15.16.42.43;	author brobecke;	state Exp;
branches;
next	1.673;

1.673
date	2012.05.15.14.48.19;	author brobecke;	state Exp;
branches;
next	1.672;

1.672
date	2012.05.15.14.33.31;	author brobecke;	state Exp;
branches;
next	1.671;

1.671
date	2012.05.14.15.38.36;	author shebs;	state Exp;
branches;
next	1.670;

1.670
date	2012.04.27.20.48.55;	author sergiodj;	state Exp;
branches;
next	1.669;

1.669
date	2012.04.27.20.47.51;	author sergiodj;	state Exp;
branches;
next	1.668;

1.668
date	2012.04.24.14.33.12;	author qiyao;	state Exp;
branches;
next	1.667;

1.667
date	2012.04.24.13.20.16;	author qiyao;	state Exp;
branches;
next	1.666;

1.666
date	2012.03.27.19.08.35;	author palves;	state Exp;
branches;
next	1.665;

1.665
date	2012.03.15.18.33.45;	author brobecke;	state Exp;
branches;
next	1.664;

1.664
date	2012.03.13.13.30.41;	author palves;	state Exp;
branches;
next	1.663;

1.663
date	2012.03.13.01.16.06;	author qiyao;	state Exp;
branches;
next	1.662;

1.662
date	2012.03.08.16.50.21;	author brobecke;	state Exp;
branches;
next	1.661;

1.661
date	2012.03.03.14.21.03;	author jkratoch;	state Exp;
branches;
next	1.660;

1.660
date	2012.03.02.19.26.10;	author palves;	state Exp;
branches;
next	1.659;

1.659
date	2012.03.01.21.13.57;	author palves;	state Exp;
branches;
next	1.658;

1.658
date	2012.02.29.14.52.43;	author jkratoch;	state Exp;
branches;
next	1.657;

1.657
date	2012.02.24.16.26.36;	author palves;	state Exp;
branches;
next	1.656;

1.656
date	2012.02.24.15.10.58;	author luisgpm;	state Exp;
branches;
next	1.655;

1.655
date	2012.02.24.14.59.35;	author luisgpm;	state Exp;
branches;
next	1.654;

1.654
date	2012.02.22.18.20.36;	author sterling;	state Exp;
branches;
next	1.653;

1.653
date	2012.02.18.17.10.32;	author brobecke;	state Exp;
branches;
next	1.652;

1.652
date	2012.02.14.23.28.14;	author shebs;	state Exp;
branches;
next	1.651;

1.651
date	2012.02.09.08.20.03;	author jkratoch;	state Exp;
branches;
next	1.650;

1.650
date	2012.02.02.20.19.12;	author devans;	state Exp;
branches;
next	1.649;

1.649
date	2012.01.28.18.08.17;	author jkratoch;	state Exp;
branches;
next	1.648;

1.648
date	2012.01.25.15.57.04;	author tromey;	state Exp;
branches;
next	1.647;

1.647
date	2012.01.24.21.39.15;	author tromey;	state Exp;
branches;
next	1.646;

1.646
date	2012.01.24.21.32.56;	author tromey;	state Exp;
branches;
next	1.645;

1.645
date	2012.01.24.21.31.24;	author tromey;	state Exp;
branches;
next	1.644;

1.644
date	2012.01.24.19.12.32;	author palves;	state Exp;
branches;
next	1.643;

1.643
date	2012.01.24.13.49.55;	author jkratoch;	state Exp;
branches;
next	1.642;

1.642
date	2012.01.16.20.40.50;	author tromey;	state Exp;
branches;
next	1.641;

1.641
date	2012.01.16.17.44.35;	author sergiodj;	state Exp;
branches;
next	1.640;

1.640
date	2012.01.11.18.30.19;	author tromey;	state Exp;
branches;
next	1.639;

1.639
date	2012.01.09.20.47.47;	author kseitz;	state Exp;
branches;
next	1.638;

1.638
date	2012.01.06.03.34.45;	author sergiodj;	state Exp;
branches;
next	1.637;

1.637
date	2012.01.04.12.31.49;	author uweigand;	state Exp;
branches;
next	1.636;

1.636
date	2012.01.04.08.16.59;	author brobecke;	state Exp;
branches;
next	1.635;

1.635
date	2011.12.23.17.06.11;	author kpouget;	state Exp;
branches;
next	1.634;

1.634
date	2011.12.14.07.56.58;	author qiyao;	state Exp;
branches;
next	1.633;

1.633
date	2011.12.11.03.04.45;	author ndreys;	state Exp;
branches
	1.633.2.1;
next	1.632;

1.632
date	2011.12.11.02.53.28;	author ndreys;	state Exp;
branches;
next	1.631;

1.631
date	2011.12.10.00.22.56;	author ndreys;	state Exp;
branches;
next	1.630;

1.630
date	2011.12.10.00.15.54;	author ndreys;	state Exp;
branches;
next	1.629;

1.629
date	2011.12.09.18.40.46;	author tromey;	state Exp;
branches;
next	1.628;

1.628
date	2011.12.06.20.03.12;	author palves;	state Exp;
branches;
next	1.627;

1.627
date	2011.12.06.18.54.38;	author tromey;	state Exp;
branches;
next	1.626;

1.626
date	2011.12.05.16.57.30;	author palves;	state Exp;
branches;
next	1.625;

1.625
date	2011.12.05.04.10.47;	author ndreys;	state Exp;
branches;
next	1.624;

1.624
date	2011.11.22.21.25.17;	author tromey;	state Exp;
branches;
next	1.623;

1.623
date	2011.11.20.23.59.47;	author shebs;	state Exp;
branches;
next	1.622;

1.622
date	2011.11.18.01.21.34;	author qiyao;	state Exp;
branches;
next	1.621;

1.621
date	2011.11.18.01.03.51;	author qiyao;	state Exp;
branches;
next	1.620;

1.620
date	2011.11.14.15.18.53;	author qiyao;	state Exp;
branches;
next	1.619;

1.619
date	2011.11.14.03.01.01;	author qiyao;	state Exp;
branches;
next	1.618;

1.618
date	2011.11.10.20.21.27;	author devans;	state Exp;
branches;
next	1.617;

1.617
date	2011.11.01.14.51.20;	author jlebar;	state Exp;
branches;
next	1.616;

1.616
date	2011.10.12.15.43.48;	author gary;	state Exp;
branches;
next	1.615;

1.615
date	2011.10.02.02.13.12;	author brobecke;	state Exp;
branches;
next	1.614;

1.614
date	2011.09.15.12.18.29;	author kpouget;	state Exp;
branches;
next	1.613;

1.613
date	2011.09.13.16.37.13;	author palves;	state Exp;
branches;
next	1.612;

1.612
date	2011.08.26.21.45.22;	author jkratoch;	state Exp;
branches;
next	1.611;

1.611
date	2011.08.26.09.28.27;	author jkratoch;	state Exp;
branches;
next	1.610;

1.610
date	2011.08.21.14.33.07;	author jkratoch;	state Exp;
branches;
next	1.609;

1.609
date	2011.08.08.15.51.45;	author tromey;	state Exp;
branches;
next	1.608;

1.608
date	2011.08.04.19.10.11;	author palves;	state Exp;
branches;
next	1.607;

1.607
date	2011.08.03.21.17.08;	author philippe;	state Exp;
branches;
next	1.606;

1.606
date	2011.08.01.18.45.49;	author bauermann;	state Exp;
branches;
next	1.605;

1.605
date	2011.07.31.20.31.16;	author bauermann;	state Exp;
branches;
next	1.604;

1.604
date	2011.07.31.20.29.33;	author bauermann;	state Exp;
branches;
next	1.603;

1.603
date	2011.07.26.19.39.58;	author palves;	state Exp;
branches;
next	1.602;

1.602
date	2011.07.25.15.51.19;	author tromey;	state Exp;
branches;
next	1.601;

1.601
date	2011.07.25.11.24.44;	author palves;	state Exp;
branches;
next	1.600;

1.600
date	2011.07.25.11.23.02;	author palves;	state Exp;
branches;
next	1.599;

1.599
date	2011.07.25.11.21.08;	author palves;	state Exp;
branches;
next	1.598;

1.598
date	2011.07.25.11.20.08;	author palves;	state Exp;
branches;
next	1.597;

1.597
date	2011.07.25.11.19.26;	author palves;	state Exp;
branches;
next	1.596;

1.596
date	2011.07.25.11.16.47;	author palves;	state Exp;
branches;
next	1.595;

1.595
date	2011.07.05.04.34.55;	author bauermann;	state Exp;
branches;
next	1.594;

1.594
date	2011.07.04.18.31.25;	author bauermann;	state Exp;
branches;
next	1.593;

1.593
date	2011.06.29.15.20.34;	author gary;	state Exp;
branches;
next	1.592;

1.592
date	2011.06.22.17.53.44;	author palves;	state Exp;
branches;
next	1.591;

1.591
date	2011.06.22.17.52.37;	author palves;	state Exp;
branches;
next	1.590;

1.590
date	2011.06.22.17.16.42;	author palves;	state Exp;
branches;
next	1.589;

1.589
date	2011.06.22.17.16.00;	author palves;	state Exp;
branches;
next	1.588;

1.588
date	2011.06.22.17.15.06;	author palves;	state Exp;
branches;
next	1.587;

1.587
date	2011.06.22.17.14.29;	author palves;	state Exp;
branches;
next	1.586;

1.586
date	2011.06.22.17.12.32;	author palves;	state Exp;
branches;
next	1.585;

1.585
date	2011.06.22.17.11.30;	author palves;	state Exp;
branches;
next	1.584;

1.584
date	2011.06.03.23.47.45;	author brobecke;	state Exp;
branches;
next	1.583;

1.583
date	2011.05.30.18.04.32;	author palves;	state Exp;
branches;
next	1.582;

1.582
date	2011.05.27.18.26.18;	author palves;	state Exp;
branches;
next	1.581;

1.581
date	2011.05.26.14.59.17;	author palves;	state Exp;
branches;
next	1.580;

1.580
date	2011.05.26.14.21.24;	author palves;	state Exp;
branches;
next	1.579;

1.579
date	2011.05.24.15.03.29;	author palves;	state Exp;
branches;
next	1.578;

1.578
date	2011.05.24.03.03.55;	author bauermann;	state Exp;
branches;
next	1.577;

1.577
date	2011.05.19.18.31.24;	author tromey;	state Exp;
branches;
next	1.576;

1.576
date	2011.05.12.12.09.14;	author kcy;	state Exp;
branches;
next	1.575;

1.575
date	2011.05.06.18.46.31;	author bauermann;	state Exp;
branches;
next	1.574;

1.574
date	2011.05.05.22.52.10;	author bauermann;	state Exp;
branches;
next	1.573;

1.573
date	2011.05.03.07.29.17;	author jkratoch;	state Exp;
branches;
next	1.572;

1.572
date	2011.05.03.05.02.54;	author bauermann;	state Exp;
branches;
next	1.571;

1.571
date	2011.04.29.18.44.14;	author tromey;	state Exp;
branches;
next	1.570;

1.570
date	2011.04.27.12.44.26;	author palves;	state Exp;
branches;
next	1.569;

1.569
date	2011.04.27.10.17.36;	author vprus;	state Exp;
branches;
next	1.568;

1.568
date	2011.04.19.18.04.06;	author tromey;	state Exp;
branches;
next	1.567;

1.567
date	2011.04.14.02.20.21;	author bauermann;	state Exp;
branches;
next	1.566;

1.566
date	2011.04.13.18.32.24;	author bauermann;	state Exp;
branches;
next	1.565;

1.565
date	2011.04.13.18.28.27;	author bauermann;	state Exp;
branches;
next	1.564;

1.564
date	2011.04.04.17.41.06;	author tromey;	state Exp;
branches;
next	1.563;

1.563
date	2011.04.04.15.22.51;	author tromey;	state Exp;
branches;
next	1.562;

1.562
date	2011.04.01.16.59.57;	author brobecke;	state Exp;
branches;
next	1.561;

1.561
date	2011.03.31.15.01.24;	author bauermann;	state Exp;
branches
	1.561.2.1;
next	1.560;

1.560
date	2011.03.31.14.32.48;	author bauermann;	state Exp;
branches;
next	1.559;

1.559
date	2011.03.31.11.19.54;	author uweigand;	state Exp;
branches;
next	1.558;

1.558
date	2011.03.30.20.59.08;	author bauermann;	state Exp;
branches;
next	1.557;

1.557
date	2011.03.28.20.29.51;	author jkratoch;	state Exp;
branches;
next	1.556;

1.556
date	2011.03.28.20.19.00;	author jkratoch;	state Exp;
branches;
next	1.555;

1.555
date	2011.03.24.19.47.17;	author tromey;	state Exp;
branches;
next	1.554;

1.554
date	2011.03.24.19.39.48;	author tromey;	state Exp;
branches;
next	1.553;

1.553
date	2011.03.23.18.23.53;	author ktietz;	state Exp;
branches;
next	1.552;

1.552
date	2011.03.14.16.09.52;	author pmuldoon;	state Exp;
branches;
next	1.551;

1.551
date	2011.03.14.15.43.50;	author muller;	state Exp;
branches;
next	1.550;

1.550
date	2011.03.10.18.33.59;	author tromey;	state Exp;
branches;
next	1.549;

1.549
date	2011.03.04.20.00.34;	author bauermann;	state Exp;
branches;
next	1.548;

1.548
date	2011.03.04.19.57.31;	author msnyder;	state Exp;
branches;
next	1.547;

1.547
date	2011.03.04.18.58.22;	author msnyder;	state Exp;
branches;
next	1.546;

1.546
date	2011.03.01.02.16.56;	author msnyder;	state Exp;
branches;
next	1.545;

1.545
date	2011.02.28.18.48.18;	author msnyder;	state Exp;
branches;
next	1.544;

1.544
date	2011.02.28.16.20.21;	author uweigand;	state Exp;
branches;
next	1.543;

1.543
date	2011.02.28.15.21.21;	author uweigand;	state Exp;
branches;
next	1.542;

1.542
date	2011.02.27.01.54.30;	author msnyder;	state Exp;
branches;
next	1.541;

1.541
date	2011.02.23.19.20.37;	author msnyder;	state Exp;
branches;
next	1.540;

1.540
date	2011.02.21.18.40.08;	author tromey;	state Exp;
branches;
next	1.539;

1.539
date	2011.02.21.18.13.17;	author tromey;	state Exp;
branches;
next	1.538;

1.538
date	2011.02.21.14.59.34;	author uweigand;	state Exp;
branches;
next	1.537;

1.537
date	2011.02.18.16.43.53;	author palves;	state Exp;
branches;
next	1.536;

1.536
date	2011.02.15.21.43.25;	author ppluzhnikov;	state Exp;
branches;
next	1.535;

1.535
date	2011.02.15.21.23.34;	author ppluzhnikov;	state Exp;
branches;
next	1.534;

1.534
date	2011.02.07.13.30.33;	author bauermann;	state Exp;
branches;
next	1.533;

1.533
date	2011.02.04.17.27.18;	author bauermann;	state Exp;
branches;
next	1.532;

1.532
date	2011.01.31.21.37.01;	author ppluzhnikov;	state Exp;
branches;
next	1.531;

1.531
date	2011.01.31.15.16.58;	author tromey;	state Exp;
branches;
next	1.530;

1.530
date	2011.01.31.15.07.49;	author tromey;	state Exp;
branches;
next	1.529;

1.529
date	2011.01.11.19.39.35;	author bauermann;	state Exp;
branches;
next	1.528;

1.528
date	2011.01.11.19.23.02;	author bauermann;	state Exp;
branches;
next	1.527;

1.527
date	2011.01.11.19.18.31;	author bauermann;	state Exp;
branches;
next	1.526;

1.526
date	2011.01.11.19.16.19;	author bauermann;	state Exp;
branches;
next	1.525;

1.525
date	2011.01.07.17.35.27;	author msnyder;	state Exp;
branches;
next	1.524;

1.524
date	2011.01.05.22.22.47;	author msnyder;	state Exp;
branches;
next	1.523;

1.523
date	2011.01.01.15.32.57;	author brobecke;	state Exp;
branches;
next	1.522;

1.522
date	2010.12.29.21.44.26;	author msnyder;	state Exp;
branches;
next	1.521;

1.521
date	2010.12.27.19.37.04;	author palves;	state Exp;
branches;
next	1.520;

1.520
date	2010.12.27.13.49.45;	author bauermann;	state Exp;
branches;
next	1.519;

1.519
date	2010.12.09.16.09.51;	author tromey;	state Exp;
branches;
next	1.518;

1.518
date	2010.11.28.04.31.23;	author jkratoch;	state Exp;
branches;
next	1.517;

1.517
date	2010.11.25.23.17.30;	author marckhouzam;	state Exp;
branches;
next	1.516;

1.516
date	2010.11.11.14.11.51;	author pmuldoon;	state Exp;
branches;
next	1.515;

1.515
date	2010.11.09.18.23.51;	author palves;	state Exp;
branches;
next	1.514;

1.514
date	2010.09.08.18.05.42;	author tromey;	state Exp;
branches;
next	1.513;

1.513
date	2010.09.04.15.30.05;	author drow;	state Exp;
branches;
next	1.512;

1.512
date	2010.09.03.15.42.02;	author jkratoch;	state Exp;
branches;
next	1.511;

1.511
date	2010.08.30.09.49.12;	author jkratoch;	state Exp;
branches;
next	1.510;

1.510
date	2010.08.17.21.12.32;	author palves;	state Exp;
branches;
next	1.509;

1.509
date	2010.08.17.20.59.03;	author palves;	state Exp;
branches;
next	1.508;

1.508
date	2010.08.16.19.53.05;	author jkratoch;	state Exp;
branches;
next	1.507;

1.507
date	2010.08.16.19.19.21;	author tromey;	state Exp;
branches;
next	1.506;

1.506
date	2010.08.03.22.35.41;	author devans;	state Exp;
branches;
next	1.505;

1.505
date	2010.07.28.17.57.54;	author brobecke;	state Exp;
branches;
next	1.504;

1.504
date	2010.07.21.11.25.53;	author palves;	state Exp;
branches;
next	1.503;

1.503
date	2010.07.19.07.55.43;	author teawater;	state Exp;
branches;
next	1.502;

1.502
date	2010.07.13.20.51.33;	author tromey;	state Exp;
branches;
next	1.501;

1.501
date	2010.07.07.16.15.14;	author bauermann;	state Exp;
branches
	1.501.2.1;
next	1.500;

1.500
date	2010.07.06.16.17.44;	author schwab;	state Exp;
branches;
next	1.499;

1.499
date	2010.07.02.19.45.49;	author bauermann;	state Exp;
branches;
next	1.498;

1.498
date	2010.07.01.18.03.48;	author palves;	state Exp;
branches;
next	1.497;

1.497
date	2010.07.01.17.42.40;	author palves;	state Exp;
branches;
next	1.496;

1.496
date	2010.07.01.15.36.15;	author palves;	state Exp;
branches;
next	1.495;

1.495
date	2010.07.01.10.36.08;	author palves;	state Exp;
branches;
next	1.494;

1.494
date	2010.06.28.18.56.38;	author devans;	state Exp;
branches;
next	1.493;

1.493
date	2010.06.24.15.17.28;	author jkratoch;	state Exp;
branches;
next	1.492;

1.492
date	2010.06.23.12.46.35;	author uweigand;	state Exp;
branches;
next	1.491;

1.491
date	2010.06.21.17.38.35;	author msnyder;	state Exp;
branches;
next	1.490;

1.490
date	2010.06.16.18.30.30;	author sergiodj;	state Exp;
branches;
next	1.489;

1.489
date	2010.06.11.12.58.53;	author jkratoch;	state Exp;
branches;
next	1.488;

1.488
date	2010.06.07.13.38.25;	author jkratoch;	state Exp;
branches;
next	1.487;

1.487
date	2010.06.04.16.48.02;	author jkratoch;	state Exp;
branches;
next	1.486;

1.486
date	2010.05.13.22.44.02;	author msnyder;	state Exp;
branches;
next	1.485;

1.485
date	2010.05.06.00.41.41;	author msnyder;	state Exp;
branches;
next	1.484;

1.484
date	2010.04.19.00.48.43;	author palves;	state Exp;
branches;
next	1.483;

1.483
date	2010.04.17.18.42.46;	author palves;	state Exp;
branches;
next	1.482;

1.482
date	2010.04.09.13.56.08;	author palves;	state Exp;
branches;
next	1.481;

1.481
date	2010.04.09.09.41.42;	author pmuldoon;	state Exp;
branches;
next	1.480;

1.480
date	2010.04.08.23.13.46;	author shebs;	state Exp;
branches;
next	1.479;

1.479
date	2010.04.06.17.47.39;	author shebs;	state Exp;
branches;
next	1.478;

1.478
date	2010.04.05.10.07.30;	author jkratoch;	state Exp;
branches;
next	1.477;

1.477
date	2010.04.04.23.47.15;	author shebs;	state Exp;
branches;
next	1.476;

1.476
date	2010.04.04.13.54.51;	author jkratoch;	state Exp;
branches;
next	1.475;

1.475
date	2010.04.02.01.18.35;	author palves;	state Exp;
branches;
next	1.474;

1.474
date	2010.04.01.14.11.22;	author palves;	state Exp;
branches;
next	1.473;

1.473
date	2010.03.31.17.59.48;	author shebs;	state Exp;
branches;
next	1.472;

1.472
date	2010.03.29.23.45.05;	author shebs;	state Exp;
branches;
next	1.471;

1.471
date	2010.03.26.23.49.31;	author shebs;	state Exp;
branches;
next	1.470;

1.470
date	2010.03.26.19.41.50;	author uweigand;	state Exp;
branches;
next	1.469;

1.469
date	2010.03.26.16.41.54;	author uweigand;	state Exp;
branches;
next	1.468;

1.468
date	2010.03.25.20.48.52;	author tromey;	state Exp;
branches;
next	1.467;

1.467
date	2010.03.24.21.24.07;	author tromey;	state Exp;
branches;
next	1.466;

1.466
date	2010.03.24.21.12.18;	author tromey;	state Exp;
branches;
next	1.465;

1.465
date	2010.03.23.21.36.05;	author vprus;	state Exp;
branches;
next	1.464;

1.464
date	2010.03.23.21.32.26;	author vprus;	state Exp;
branches;
next	1.463;

1.463
date	2010.03.22.17.36.28;	author tromey;	state Exp;
branches;
next	1.462;

1.462
date	2010.03.16.08.42.20;	author vprus;	state Exp;
branches;
next	1.461;

1.461
date	2010.03.10.13.25.39;	author palves;	state Exp;
branches;
next	1.460;

1.460
date	2010.03.08.20.21.48;	author tromey;	state Exp;
branches;
next	1.459;

1.459
date	2010.03.04.15.37.25;	author palves;	state Exp;
branches;
next	1.458;

1.458
date	2010.02.24.07.51.44;	author vprus;	state Exp;
branches;
next	1.457;

1.457
date	2010.02.24.00.29.01;	author palves;	state Exp;
branches;
next	1.456;

1.456
date	2010.02.22.23.35.16;	author palves;	state Exp;
branches;
next	1.455;

1.455
date	2010.02.12.01.24.09;	author palves;	state Exp;
branches;
next	1.454;

1.454
date	2010.02.12.00.47.53;	author palves;	state Exp;
branches;
next	1.453;

1.453
date	2010.02.11.22.25.27;	author jkratoch;	state Exp;
branches;
next	1.452;

1.452
date	2010.01.26.23.56.53;	author devans;	state Exp;
branches;
next	1.451;

1.451
date	2010.01.19.20.31.34;	author jkratoch;	state Exp;
branches;
next	1.450;

1.450
date	2010.01.19.09.39.11;	author brobecke;	state Exp;
branches;
next	1.449;

1.449
date	2010.01.15.22.37.17;	author shebs;	state Exp;
branches;
next	1.448;

1.448
date	2010.01.06.20.31.28;	author shebs;	state Exp;
branches;
next	1.447;

1.447
date	2010.01.06.04.20.26;	author shebs;	state Exp;
branches;
next	1.446;

1.446
date	2010.01.01.07.31.30;	author brobecke;	state Exp;
branches;
next	1.445;

1.445
date	2009.12.30.20.11.49;	author bauermann;	state Exp;
branches;
next	1.444;

1.444
date	2009.12.30.19.16.30;	author brobecke;	state Exp;
branches;
next	1.443;

1.443
date	2009.12.30.17.33.33;	author bauermann;	state Exp;
branches;
next	1.442;

1.442
date	2009.12.28.21.12.24;	author drow;	state Exp;
branches;
next	1.441;

1.441
date	2009.12.23.23.18.08;	author jkratoch;	state Exp;
branches;
next	1.440;

1.440
date	2009.12.23.22.24.50;	author jkratoch;	state Exp;
branches;
next	1.439;

1.439
date	2009.12.18.00.36.47;	author shebs;	state Exp;
branches;
next	1.438;

1.438
date	2009.12.03.17.47.07;	author ppluzhnikov;	state Exp;
branches;
next	1.437;

1.437
date	2009.11.25.20.43.29;	author drow;	state Exp;
branches;
next	1.436;

1.436
date	2009.11.24.21.37.52;	author brobecke;	state Exp;
branches;
next	1.435;

1.435
date	2009.11.22.15.38.58;	author palves;	state Exp;
branches;
next	1.434;

1.434
date	2009.11.21.21.37.21;	author palves;	state Exp;
branches;
next	1.433;

1.433
date	2009.11.21.21.17.17;	author palves;	state Exp;
branches;
next	1.432;

1.432
date	2009.11.20.20.01.08;	author jkratoch;	state Exp;
branches;
next	1.431;

1.431
date	2009.11.20.19.57.28;	author jkratoch;	state Exp;
branches;
next	1.430;

1.430
date	2009.11.20.17.23.38;	author msnyder;	state Exp;
branches;
next	1.429;

1.429
date	2009.11.20.14.51.47;	author palves;	state Exp;
branches;
next	1.428;

1.428
date	2009.11.20.13.08.16;	author palves;	state Exp;
branches;
next	1.427;

1.427
date	2009.11.19.17.02.46;	author palves;	state Exp;
branches;
next	1.426;

1.426
date	2009.11.15.20.10.34;	author palves;	state Exp;
branches;
next	1.425;

1.425
date	2009.11.15.20.08.02;	author palves;	state Exp;
branches;
next	1.424;

1.424
date	2009.11.13.22.05.06;	author drow;	state Exp;
branches;
next	1.423;

1.423
date	2009.10.31.18.30.40;	author msnyder;	state Exp;
branches;
next	1.422;

1.422
date	2009.10.31.06.00.11;	author sergiodj;	state Exp;
branches;
next	1.421;

1.421
date	2009.10.25.19.35.26;	author jkratoch;	state Exp;
branches;
next	1.420;

1.420
date	2009.10.19.09.51.40;	author palves;	state Exp;
branches;
next	1.419;

1.419
date	2009.09.15.03.30.04;	author sergiodj;	state Exp;
branches;
next	1.418;

1.418
date	2009.08.21.18.54.44;	author devans;	state Exp;
branches;
next	1.417;

1.417
date	2009.08.20.18.02.47;	author devans;	state Exp;
branches;
next	1.416;

1.416
date	2009.08.03.12.39.00;	author vprus;	state Exp;
branches;
next	1.415;

1.415
date	2009.07.31.14.33.45;	author uweigand;	state Exp;
branches;
next	1.414;

1.414
date	2009.07.31.14.31.16;	author uweigand;	state Exp;
branches;
next	1.413;

1.413
date	2009.07.07.22.21.09;	author muller;	state Exp;
branches;
next	1.412;

1.412
date	2009.07.02.17.21.05;	author uweigand;	state Exp;
branches;
next	1.411;

1.411
date	2009.07.02.17.12.24;	author uweigand;	state Exp;
branches;
next	1.410;

1.410
date	2009.06.28.00.20.22;	author drow;	state Exp;
branches;
next	1.409;

1.409
date	2009.06.24.16.41.29;	author uweigand;	state Exp;
branches;
next	1.408;

1.408
date	2009.06.23.16.28.44;	author ppluzhnikov;	state Exp;
branches;
next	1.407;

1.407
date	2009.06.19.15.14.11;	author guitton;	state Exp;
branches;
next	1.406;

1.406
date	2009.06.17.18.43.24;	author uweigand;	state Exp;
branches;
next	1.405;

1.405
date	2009.06.11.18.51.42;	author palves;	state Exp;
branches;
next	1.404;

1.404
date	2009.06.10.04.32.08;	author muller;	state Exp;
branches;
next	1.403;

1.403
date	2009.06.08.16.05.14;	author muller;	state Exp;
branches;
next	1.402;

1.402
date	2009.06.07.16.46.48;	author palves;	state Exp;
branches;
next	1.401;

1.401
date	2009.06.03.18.16.43;	author uweigand;	state Exp;
branches;
next	1.400;

1.400
date	2009.05.28.00.53.51;	author tromey;	state Exp;
branches;
next	1.399;

1.399
date	2009.05.24.18.00.08;	author palves;	state Exp;
branches;
next	1.398;

1.398
date	2009.05.23.16.17.13;	author jkratoch;	state Exp;
branches;
next	1.397;

1.397
date	2009.05.19.00.23.49;	author palves;	state Exp;
branches;
next	1.396;

1.396
date	2009.05.14.23.33.08;	author ppluzhnikov;	state Exp;
branches;
next	1.395;

1.395
date	2009.05.11.15.05.55;	author jkratoch;	state Exp;
branches;
next	1.394;

1.394
date	2009.05.11.11.13.08;	author muller;	state Exp;
branches;
next	1.393;

1.393
date	2009.05.05.13.24.48;	author uweigand;	state Exp;
branches;
next	1.392;

1.392
date	2009.04.29.19.31.58;	author palves;	state Exp;
branches;
next	1.391;

1.391
date	2009.04.23.22.38.24;	author jkratoch;	state Exp;
branches;
next	1.390;

1.390
date	2009.03.31.16.44.17;	author brobecke;	state Exp;
branches;
next	1.389;

1.389
date	2009.03.31.05.08.31;	author shebs;	state Exp;
branches;
next	1.388;

1.388
date	2009.03.26.23.30.10;	author tromey;	state Exp;
branches;
next	1.387;

1.387
date	2009.03.25.22.08.29;	author brobecke;	state Exp;
branches;
next	1.386;

1.386
date	2009.03.23.18.34.03;	author ppluzhnikov;	state Exp;
branches;
next	1.385;

1.385
date	2009.03.22.18.06.06;	author palves;	state Exp;
branches;
next	1.384;

1.384
date	2009.03.18.01.13.19;	author palves;	state Exp;
branches;
next	1.383;

1.383
date	2009.03.11.20.26.02;	author drow;	state Exp;
branches;
next	1.382;

1.382
date	2009.03.06.18.51.05;	author ppluzhnikov;	state Exp;
branches;
next	1.381;

1.381
date	2009.03.05.22.37.10;	author palves;	state Exp;
branches;
next	1.380;

1.380
date	2009.02.26.01.14.03;	author devans;	state Exp;
branches;
next	1.379;

1.379
date	2009.02.25.21.43.04;	author devans;	state Exp;
branches;
next	1.378;

1.378
date	2009.02.21.16.14.47;	author palves;	state Exp;
branches;
next	1.377;

1.377
date	2009.02.18.07.28.32;	author vprus;	state Exp;
branches;
next	1.376;

1.376
date	2009.02.05.00.13.43;	author tromey;	state Exp;
branches;
next	1.375;

1.375
date	2009.02.03.01.09.35;	author brobecke;	state Exp;
branches;
next	1.374;

1.374
date	2009.01.30.18.27.59;	author vprus;	state Exp;
branches;
next	1.373;

1.373
date	2009.01.08.16.32.29;	author tromey;	state Exp;
branches;
next	1.372;

1.372
date	2009.01.08.03.58.06;	author esuzuki;	state Exp;
branches;
next	1.371;

1.371
date	2009.01.07.21.42.49;	author palves;	state Exp;
branches;
next	1.370;

1.370
date	2009.01.03.05.57.50;	author brobecke;	state Exp;
branches;
next	1.369;

1.369
date	2009.01.01.22.02.02;	author palves;	state Exp;
branches;
next	1.368;

1.368
date	2008.12.26.19.11.53;	author sandra;	state Exp;
branches;
next	1.367;

1.367
date	2008.12.22.04.37.37;	author brobecke;	state Exp;
branches;
next	1.366;

1.366
date	2008.12.21.15.01.31;	author jkratoch;	state Exp;
branches;
next	1.365;

1.365
date	2008.12.08.13.27.38;	author jkratoch;	state Exp;
branches;
next	1.364;

1.364
date	2008.12.07.15.59.51;	author jkratoch;	state Exp;
branches;
next	1.363;

1.363
date	2008.11.26.05.27.48;	author jkratoch;	state Exp;
branches;
next	1.362;

1.362
date	2008.11.22.04.41.45;	author brobecke;	state Exp;
branches;
next	1.361;

1.361
date	2008.11.16.18.05.26;	author brobecke;	state Exp;
branches
	1.361.2.1;
next	1.360;

1.360
date	2008.11.16.18.01.46;	author brobecke;	state Exp;
branches;
next	1.359;

1.359
date	2008.11.03.14.01.26;	author palves;	state Exp;
branches;
next	1.358;

1.358
date	2008.10.30.05.16.23;	author brobecke;	state Exp;
branches;
next	1.357;

1.357
date	2008.10.28.17.19.56;	author tromey;	state Exp;
branches;
next	1.356;

1.356
date	2008.10.17.19.43.46;	author msnyder;	state Exp;
branches;
next	1.355;

1.355
date	2008.10.16.16.25.04;	author brobecke;	state Exp;
branches;
next	1.354;

1.354
date	2008.10.15.19.15.33;	author palves;	state Exp;
branches;
next	1.353;

1.353
date	2008.10.14.20.49.02;	author palves;	state Exp;
branches;
next	1.352;

1.352
date	2008.09.16.18.55.01;	author daney;	state Exp;
branches
	1.352.2.1;
next	1.351;

1.351
date	2008.09.11.14.21.49;	author uweigand;	state Exp;
branches;
next	1.350;

1.350
date	2008.09.08.21.57.42;	author palves;	state Exp;
branches;
next	1.349;

1.349
date	2008.09.08.21.46.21;	author palves;	state Exp;
branches;
next	1.348;

1.348
date	2008.09.05.11.37.17;	author uweigand;	state Exp;
branches;
next	1.347;

1.347
date	2008.09.03.13.39.56;	author aristovski;	state Exp;
branches;
next	1.346;

1.346
date	2008.09.02.15.14.52;	author palves;	state Exp;
branches;
next	1.345;

1.345
date	2008.08.26.17.36.44;	author uweigand;	state Exp;
branches;
next	1.344;

1.344
date	2008.08.22.15.50.44;	author uweigand;	state Exp;
branches;
next	1.343;

1.343
date	2008.08.17.16.58.17;	author tromey;	state Exp;
branches;
next	1.342;

1.342
date	2008.08.16.20.36.29;	author bauermann;	state Exp;
branches;
next	1.341;

1.341
date	2008.08.13.13.58.44;	author palves;	state Exp;
branches;
next	1.340;

1.340
date	2008.08.06.10.12.34;	author pmuldoon;	state Exp;
branches;
next	1.339;

1.339
date	2008.08.06.04.25.11;	author msnyder;	state Exp;
branches;
next	1.338;

1.338
date	2008.07.28.17.53.52;	author tromey;	state Exp;
branches;
next	1.337;

1.337
date	2008.07.25.16.12.03;	author tromey;	state Exp;
branches;
next	1.336;

1.336
date	2008.07.15.19.11.34;	author drow;	state Exp;
branches
	1.336.2.1;
next	1.335;

1.335
date	2008.07.12.19.25.42;	author palves;	state Exp;
branches;
next	1.334;

1.334
date	2008.07.12.19.07.37;	author palves;	state Exp;
branches;
next	1.333;

1.333
date	2008.07.09.22.30.45;	author palves;	state Exp;
branches;
next	1.332;

1.332
date	2008.07.09.22.23.05;	author palves;	state Exp;
branches;
next	1.331;

1.331
date	2008.07.09.22.16.14;	author palves;	state Exp;
branches;
next	1.330;

1.330
date	2008.07.08.11.09.40;	author palves;	state Exp;
branches;
next	1.329;

1.329
date	2008.07.08.10.59.57;	author palves;	state Exp;
branches;
next	1.328;

1.328
date	2008.07.07.22.39.58;	author jkratoch;	state Exp;
branches;
next	1.327;

1.327
date	2008.06.28.09.42.15;	author vprus;	state Exp;
branches;
next	1.326;

1.326
date	2008.06.26.15.51.27;	author drow;	state Exp;
branches;
next	1.325;

1.325
date	2008.06.10.09.29.15;	author vprus;	state Exp;
branches;
next	1.324;

1.324
date	2008.06.06.20.58.08;	author tromey;	state Exp;
branches
	1.324.2.1;
next	1.323;

1.323
date	2008.06.05.18.31.53;	author aristovski;	state Exp;
branches;
next	1.322;

1.322
date	2008.05.28.14.04.21;	author aristovski;	state Exp;
branches;
next	1.321;

1.321
date	2008.05.04.19.38.59;	author palves;	state Exp;
branches;
next	1.320;

1.320
date	2008.05.03.22.20.13;	author drow;	state Exp;
branches;
next	1.319;

1.319
date	2008.05.03.06.13.21;	author bauermann;	state Exp;
branches;
next	1.318;

1.318
date	2008.05.02.11.07.25;	author schwab;	state Exp;
branches;
next	1.317;

1.317
date	2008.05.01.20.35.33;	author aristovski;	state Exp;
branches;
next	1.316;

1.316
date	2008.04.26.05.43.45;	author brobecke;	state Exp;
branches;
next	1.315;

1.315
date	2008.04.25.14.50.10;	author palves;	state Exp;
branches;
next	1.314;

1.314
date	2008.04.24.12.56.45;	author vprus;	state Exp;
branches;
next	1.313;

1.313
date	2008.04.24.11.13.44;	author vprus;	state Exp;
branches;
next	1.312;

1.312
date	2008.04.24.10.21.44;	author vprus;	state Exp;
branches;
next	1.311;

1.311
date	2008.04.24.08.46.18;	author vprus;	state Exp;
branches;
next	1.310;

1.310
date	2008.04.18.00.41.28;	author marckhouzam;	state Exp;
branches;
next	1.309;

1.309
date	2008.04.17.22.43.17;	author brobecke;	state Exp;
branches;
next	1.308;

1.308
date	2008.04.15.14.32.12;	author aristovski;	state Exp;
branches;
next	1.307;

1.307
date	2008.03.14.18.57.43;	author vprus;	state Exp;
branches;
next	1.306;

1.306
date	2008.03.13.12.22.11;	author drow;	state Exp;
branches;
next	1.305;

1.305
date	2008.03.03.13.24.12;	author drow;	state Exp;
branches;
next	1.304;

1.304
date	2008.02.27.20.27.49;	author brobecke;	state Exp;
branches;
next	1.303;

1.303
date	2008.02.26.08.14.11;	author vprus;	state Exp;
branches
	1.303.2.1
	1.303.6.1;
next	1.302;

1.302
date	2008.02.08.00.42.07;	author devans;	state Exp;
branches;
next	1.301;

1.301
date	2008.02.01.16.24.46;	author vprus;	state Exp;
branches;
next	1.300;

1.300
date	2008.02.01.06.47.19;	author vprus;	state Exp;
branches;
next	1.299;

1.299
date	2008.01.29.17.52.47;	author vprus;	state Exp;
branches;
next	1.298;

1.298
date	2008.01.29.16.47.47;	author vprus;	state Exp;
branches;
next	1.297;

1.297
date	2008.01.22.19.43.10;	author vprus;	state Exp;
branches;
next	1.296;

1.296
date	2008.01.11.13.34.14;	author deuling;	state Exp;
branches;
next	1.295;

1.295
date	2008.01.01.22.53.09;	author drow;	state Exp;
branches;
next	1.294;

1.294
date	2007.12.17.12.32.22;	author luisgpm;	state Exp;
branches;
next	1.293;

1.293
date	2007.12.17.11.34.45;	author luisgpm;	state Exp;
branches;
next	1.292;

1.292
date	2007.12.16.19.15.48;	author vprus;	state Exp;
branches;
next	1.291;

1.291
date	2007.12.14.18.15.46;	author vprus;	state Exp;
branches;
next	1.290;

1.290
date	2007.12.14.17.54.48;	author vprus;	state Exp;
branches;
next	1.289;

1.289
date	2007.12.13.02.00.06;	author jimb;	state Exp;
branches;
next	1.288;

1.288
date	2007.12.04.23.43.57;	author jimb;	state Exp;
branches;
next	1.287;

1.287
date	2007.11.30.10.00.26;	author vprus;	state Exp;
branches;
next	1.286;

1.286
date	2007.11.29.07.48.21;	author vprus;	state Exp;
branches;
next	1.285;

1.285
date	2007.11.28.18.21.30;	author jimb;	state Exp;
branches;
next	1.284;

1.284
date	2007.11.23.16.54.34;	author vprus;	state Exp;
branches;
next	1.283;

1.283
date	2007.11.20.17.37.34;	author vprus;	state Exp;
branches;
next	1.282;

1.282
date	2007.11.20.08.16.15;	author vprus;	state Exp;
branches;
next	1.281;

1.281
date	2007.11.15.06.52.53;	author vprus;	state Exp;
branches;
next	1.280;

1.280
date	2007.11.15.06.46.21;	author vprus;	state Exp;
branches;
next	1.279;

1.279
date	2007.11.15.06.28.19;	author vprus;	state Exp;
branches;
next	1.278;

1.278
date	2007.11.08.16.43.39;	author vprus;	state Exp;
branches;
next	1.277;

1.277
date	2007.11.05.18.24.29;	author brobecke;	state Exp;
branches;
next	1.276;

1.276
date	2007.11.05.18.18.47;	author brobecke;	state Exp;
branches;
next	1.275;

1.275
date	2007.11.05.18.09.18;	author brobecke;	state Exp;
branches;
next	1.274;

1.274
date	2007.10.12.16.11.11;	author uweigand;	state Exp;
branches;
next	1.273;

1.273
date	2007.10.11.20.19.37;	author kazu;	state Exp;
branches;
next	1.272;

1.272
date	2007.10.08.15.23.42;	author muller;	state Exp;
branches;
next	1.271;

1.271
date	2007.10.01.00.17.57;	author drow;	state Exp;
branches;
next	1.270;

1.270
date	2007.09.26.18.44.55;	author vprus;	state Exp;
branches;
next	1.269;

1.269
date	2007.09.24.07.40.32;	author vprus;	state Exp;
branches;
next	1.268;

1.268
date	2007.09.23.07.56.22;	author vprus;	state Exp;
branches;
next	1.267;

1.267
date	2007.09.22.19.33.31;	author vprus;	state Exp;
branches;
next	1.266;

1.266
date	2007.09.22.19.10.05;	author vprus;	state Exp;
branches;
next	1.265;

1.265
date	2007.09.22.19.06.59;	author vprus;	state Exp;
branches;
next	1.264;

1.264
date	2007.09.22.17.49.40;	author vprus;	state Exp;
branches;
next	1.263;

1.263
date	2007.08.29.22.07.47;	author jimb;	state Exp;
branches;
next	1.262;

1.262
date	2007.08.23.18.08.26;	author brobecke;	state Exp;
branches;
next	1.261;

1.261
date	2007.08.17.17.06.02;	author vprus;	state Exp;
branches;
next	1.260;

1.260
date	2007.08.14.11.09.45;	author vprus;	state Exp;
branches;
next	1.259;

1.259
date	2007.08.14.08.11.45;	author vprus;	state Exp;
branches;
next	1.258;

1.258
date	2007.08.05.00.43.34;	author msnyder;	state Exp;
branches;
next	1.257;

1.257
date	2007.07.31.23.08.22;	author msnyder;	state Exp;
branches;
next	1.256;

1.256
date	2007.07.10.22.59.42;	author nickrob;	state Exp;
branches;
next	1.255;

1.255
date	2007.07.02.18.30.19;	author uweigand;	state Exp;
branches;
next	1.254;

1.254
date	2007.07.02.16.14.01;	author drow;	state Exp;
branches;
next	1.253;

1.253
date	2007.06.13.17.59.50;	author uweigand;	state Exp;
branches;
next	1.252;

1.252
date	2007.06.13.17.38.43;	author uweigand;	state Exp;
branches;
next	1.251;

1.251
date	2007.06.06.15.15.34;	author uweigand;	state Exp;
branches;
next	1.250;

1.250
date	2007.06.05.22.47.50;	author uweigand;	state Exp;
branches;
next	1.249;

1.249
date	2007.05.11.20.01.31;	author uweigand;	state Exp;
branches;
next	1.248;

1.248
date	2007.05.11.12.44.34;	author uweigand;	state Exp;
branches;
next	1.247;

1.247
date	2007.05.03.17.42.25;	author kevinb;	state Exp;
branches;
next	1.246;

1.246
date	2007.04.13.13.50.32;	author drow;	state Exp;
branches;
next	1.245;

1.245
date	2007.04.13.13.33.10;	author drow;	state Exp;
branches;
next	1.244;

1.244
date	2007.04.10.14.53.46;	author drow;	state Exp;
branches;
next	1.243;

1.243
date	2007.03.27.23.01.00;	author palves;	state Exp;
branches
	1.243.2.1;
next	1.242;

1.242
date	2007.03.09.16.20.42;	author uweigand;	state Exp;
branches;
next	1.241;

1.241
date	2007.02.27.19.46.04;	author drow;	state Exp;
branches;
next	1.240;

1.240
date	2007.01.27.12.30.46;	author eliz;	state Exp;
branches;
next	1.239;

1.239
date	2007.01.21.17.43.12;	author drow;	state Exp;
branches;
next	1.238;

1.238
date	2007.01.09.17.58.49;	author drow;	state Exp;
branches;
next	1.237;

1.237
date	2007.01.04.05.27.31;	author brobecke;	state Exp;
branches;
next	1.236;

1.236
date	2007.01.03.19.01.25;	author drow;	state Exp;
branches;
next	1.235;

1.235
date	2007.01.01.14.10.39;	author brobecke;	state Exp;
branches;
next	1.234;

1.234
date	2006.12.18.22.10.13;	author drow;	state Exp;
branches;
next	1.233;

1.233
date	2006.12.15.15.22.22;	author drow;	state Exp;
branches;
next	1.232;

1.232
date	2006.11.22.10.43.34;	author vprus;	state Exp;
branches;
next	1.231;

1.231
date	2006.10.19.15.58.25;	author ams;	state Exp;
branches;
next	1.230;

1.230
date	2006.10.17.21.53.26;	author brobecke;	state Exp;
branches;
next	1.229;

1.229
date	2006.08.08.21.32.37;	author brobecke;	state Exp;
branches;
next	1.228;

1.228
date	2006.08.08.16.05.13;	author ths;	state Exp;
branches;
next	1.227;

1.227
date	2006.06.02.03.43.18;	author nickrob;	state Exp;
branches;
next	1.226;

1.226
date	2006.05.01.16.38.08;	author kettenis;	state Exp;
branches
	1.226.2.1
	1.226.4.1;
next	1.225;

1.225
date	2006.04.18.19.20.06;	author drow;	state Exp;
branches;
next	1.224;

1.224
date	2006.04.06.18.33.05;	author brobecke;	state Exp;
branches;
next	1.223;

1.223
date	2006.02.09.11.24.46;	author nickrob;	state Exp;
branches
	1.223.2.1
	1.223.4.1
	1.223.6.1;
next	1.222;

1.222
date	2006.02.08.06.43.00;	author woodzltc;	state Exp;
branches;
next	1.221;

1.221
date	2006.02.06.21.55.05;	author drow;	state Exp;
branches;
next	1.220;

1.220
date	2006.01.16.12.55.18;	author ams;	state Exp;
branches;
next	1.219;

1.219
date	2005.12.17.22.33.59;	author eliz;	state Exp;
branches;
next	1.218;

1.218
date	2005.12.02.14.58.16;	author ams;	state Exp;
branches;
next	1.217;

1.217
date	2005.05.29.03.13.17;	author bobbybrasko;	state Exp;
branches
	1.217.2.1;
next	1.216;

1.216
date	2005.05.26.20.48.56;	author cagney;	state Exp;
branches;
next	1.215;

1.215
date	2005.05.22.14.53.33;	author cagney;	state Exp;
branches;
next	1.214;

1.214
date	2005.05.12.20.21.16;	author kettenis;	state Exp;
branches;
next	1.213;

1.213
date	2005.04.26.05.03.35;	author cagney;	state Exp;
branches;
next	1.212;

1.212
date	2005.02.24.13.51.30;	author cagney;	state Exp;
branches;
next	1.211;

1.211
date	2005.02.18.18.58.55;	author cagney;	state Exp;
branches;
next	1.210;

1.210
date	2005.02.17.13.49.48;	author cagney;	state Exp;
branches;
next	1.209;

1.209
date	2005.02.15.15.49.07;	author cagney;	state Exp;
branches;
next	1.208;

1.208
date	2005.02.14.18.10.07;	author cagney;	state Exp;
branches;
next	1.207;

1.207
date	2005.02.14.16.18.38;	author cagney;	state Exp;
branches;
next	1.206;

1.206
date	2005.02.14.14.37.37;	author cagney;	state Exp;
branches;
next	1.205;

1.205
date	2005.02.12.00.39.18;	author cagney;	state Exp;
branches;
next	1.204;

1.204
date	2005.02.11.18.13.47;	author cagney;	state Exp;
branches;
next	1.203;

1.203
date	2005.02.11.04.05.43;	author cagney;	state Exp;
branches;
next	1.202;

1.202
date	2005.02.10.17.32.47;	author cagney;	state Exp;
branches;
next	1.201;

1.201
date	2005.02.08.04.15.39;	author cagney;	state Exp;
branches;
next	1.200;

1.200
date	2005.02.08.01.59.38;	author cagney;	state Exp;
branches;
next	1.199;

1.199
date	2005.02.08.00.25.31;	author cagney;	state Exp;
branches;
next	1.198;

1.198
date	2005.02.07.00.09.53;	author cagney;	state Exp;
branches;
next	1.197;

1.197
date	2005.02.02.22.34.31;	author cagney;	state Exp;
branches;
next	1.196;

1.196
date	2005.01.19.21.15.43;	author cagney;	state Exp;
branches;
next	1.195;

1.195
date	2005.01.18.17.04.27;	author cagney;	state Exp;
branches;
next	1.194;

1.194
date	2005.01.14.23.27.11;	author cagney;	state Exp;
branches;
next	1.193;

1.193
date	2005.01.14.22.59.33;	author cagney;	state Exp;
branches;
next	1.192;

1.192
date	2005.01.14.20.24.19;	author cagney;	state Exp;
branches;
next	1.191;

1.191
date	2005.01.13.23.35.54;	author msnyder;	state Exp;
branches;
next	1.190;

1.190
date	2005.01.13.22.08.26;	author cagney;	state Exp;
branches;
next	1.189;

1.189
date	2005.01.13.00.12.48;	author cagney;	state Exp;
branches;
next	1.188;

1.188
date	2005.01.12.18.31.30;	author cagney;	state Exp;
branches;
next	1.187;

1.187
date	2005.01.04.13.31.46;	author schwab;	state Exp;
branches;
next	1.186;

1.186
date	2004.12.01.06.54.56;	author tausq;	state Exp;
branches;
next	1.185;

1.185
date	2004.11.12.21.45.05;	author cagney;	state Exp;
branches;
next	1.184;

1.184
date	2004.10.29.20.23.04;	author cagney;	state Exp;
branches;
next	1.183;

1.183
date	2004.10.08.17.30.46;	author jjohnstn;	state Exp;
branches;
next	1.182;

1.182
date	2004.09.13.18.26.28;	author cagney;	state Exp;
branches;
next	1.181;

1.181
date	2004.09.11.10.24.44;	author hilfingr;	state Exp;
branches;
next	1.180;

1.180
date	2004.09.01.18.00.28;	author jjohnstn;	state Exp;
branches;
next	1.179;

1.179
date	2004.07.28.17.26.26;	author cagney;	state Exp;
branches;
next	1.178;

1.178
date	2004.07.26.14.52.59;	author cagney;	state Exp;
branches;
next	1.177;

1.177
date	2004.07.20.19.45.04;	author cagney;	state Exp;
branches;
next	1.176;

1.176
date	2004.06.28.23.59.27;	author cagney;	state Exp;
branches;
next	1.175;

1.175
date	2004.06.22.19.46.40;	author jjohnstn;	state Exp;
branches;
next	1.174;

1.174
date	2004.06.07.17.58.32;	author cagney;	state Exp;
branches;
next	1.173;

1.173
date	2004.05.13.16.39.10;	author uweigand;	state Exp;
branches;
next	1.172;

1.172
date	2004.05.08.18.47.20;	author cagney;	state Exp;
branches;
next	1.171;

1.171
date	2004.05.05.21.18.10;	author jingham;	state Exp;
branches;
next	1.170;

1.170
date	2004.05.02.00.21.41;	author cagney;	state Exp;
branches;
next	1.169;

1.169
date	2004.05.01.16.52.29;	author cagney;	state Exp;
branches;
next	1.168;

1.168
date	2004.04.26.09.02.41;	author orjanf;	state Exp;
branches;
next	1.167;

1.167
date	2004.04.21.23.52.19;	author cagney;	state Exp;
branches;
next	1.166;

1.166
date	2004.04.08.21.18.12;	author cagney;	state Exp;
branches;
next	1.165;

1.165
date	2004.03.23.14.47.55;	author cagney;	state Exp;
branches
	1.165.2.1;
next	1.164;

1.164
date	2004.03.19.20.49.43;	author kevinb;	state Exp;
branches;
next	1.163;

1.163
date	2004.03.15.21.58.31;	author kevinb;	state Exp;
branches;
next	1.162;

1.162
date	2004.02.28.16.56.12;	author cagney;	state Exp;
branches
	1.162.2.1
	1.162.4.1;
next	1.161;

1.161
date	2004.02.26.23.46.47;	author jjohnstn;	state Exp;
branches;
next	1.160;

1.160
date	2004.02.23.20.30.16;	author jjohnstn;	state Exp;
branches;
next	1.159;

1.159
date	2004.02.23.19.26.14;	author jjohnstn;	state Exp;
branches;
next	1.158;

1.158
date	2004.02.03.22.47.40;	author jjohnstn;	state Exp;
branches
	1.158.4.1;
next	1.157;

1.157
date	2004.02.02.21.10.49;	author jjohnstn;	state Exp;
branches;
next	1.156;

1.156
date	2004.02.01.18.05.09;	author drow;	state Exp;
branches;
next	1.155;

1.155
date	2004.01.31.19.59.06;	author drow;	state Exp;
branches;
next	1.154;

1.154
date	2004.01.31.19.18.13;	author drow;	state Exp;
branches;
next	1.153;

1.153
date	2004.01.31.18.14.08;	author drow;	state Exp;
branches;
next	1.152;

1.152
date	2004.01.28.01.39.51;	author cagney;	state Exp;
branches;
next	1.151;

1.151
date	2004.01.27.03.13.34;	author cagney;	state Exp;
branches;
next	1.150;

1.150
date	2004.01.27.00.11.39;	author cagney;	state Exp;
branches;
next	1.149;

1.149
date	2004.01.17.21.56.12;	author drow;	state Exp;
branches;
next	1.148;

1.148
date	2003.12.22.03.43.19;	author jimb;	state Exp;
branches;
next	1.147;

1.147
date	2003.12.17.21.47.47;	author jjohnstn;	state Exp;
branches;
next	1.146;

1.146
date	2003.12.12.19.04.46;	author jjohnstn;	state Exp;
branches;
next	1.145;

1.145
date	2003.11.17.00.55.49;	author drow;	state Exp;
branches;
next	1.144;

1.144
date	2003.11.12.17.00.42;	author drow;	state Exp;
branches;
next	1.143;

1.143
date	2003.11.08.00.13.02;	author cagney;	state Exp;
branches;
next	1.142;

1.142
date	2003.11.06.18.35.05;	author drow;	state Exp;
branches;
next	1.141;

1.141
date	2003.11.06.18.28.33;	author drow;	state Exp;
branches;
next	1.140;

1.140
date	2003.11.06.18.27.34;	author drow;	state Exp;
branches;
next	1.139;

1.139
date	2003.11.06.18.26.17;	author drow;	state Exp;
branches;
next	1.138;

1.138
date	2003.11.06.18.24.55;	author drow;	state Exp;
branches;
next	1.137;

1.137
date	2003.11.06.18.22.45;	author drow;	state Exp;
branches;
next	1.136;

1.136
date	2003.11.06.18.20.52;	author drow;	state Exp;
branches;
next	1.135;

1.135
date	2003.11.06.17.26.18;	author drow;	state Exp;
branches;
next	1.134;

1.134
date	2003.11.06.17.24.38;	author drow;	state Exp;
branches;
next	1.133;

1.133
date	2003.10.21.22.56.38;	author ezannoni;	state Exp;
branches;
next	1.132;

1.132
date	2003.10.13.23.53.20;	author kevinb;	state Exp;
branches;
next	1.131;

1.131
date	2003.10.06.19.27.12;	author cagney;	state Exp;
branches;
next	1.130;

1.130
date	2003.09.21.01.26.44;	author cagney;	state Exp;
branches;
next	1.129;

1.129
date	2003.09.14.16.32.12;	author cagney;	state Exp;
branches;
next	1.128;

1.128
date	2003.09.04.17.41.48;	author corinna;	state Exp;
branches;
next	1.127;

1.127
date	2003.09.04.17.24.53;	author corinna;	state Exp;
branches;
next	1.126;

1.126
date	2003.08.09.14.57.30;	author cagney;	state Exp;
branches;
next	1.125;

1.125
date	2003.07.02.16.24.00;	author drow;	state Exp;
branches;
next	1.124;

1.124
date	2003.06.19.20.02.41;	author drow;	state Exp;
branches
	1.124.2.1;
next	1.123;

1.123
date	2003.06.17.19.17.59;	author drow;	state Exp;
branches;
next	1.122;

1.122
date	2003.06.08.18.27.12;	author cagney;	state Exp;
branches;
next	1.121;

1.121
date	2003.06.02.04.16.23;	author cagney;	state Exp;
branches;
next	1.120;

1.120
date	2003.05.05.17.56.54;	author cagney;	state Exp;
branches
	1.120.8.1;
next	1.119;

1.119
date	2003.04.27.01.11.10;	author drow;	state Exp;
branches;
next	1.118;

1.118
date	2003.04.10.03.30.36;	author cagney;	state Exp;
branches
	1.118.2.1;
next	1.117;

1.117
date	2003.03.31.19.01.18;	author cagney;	state Exp;
branches
	1.117.2.1;
next	1.116;

1.116
date	2003.03.26.20.19.12;	author drow;	state Exp;
branches;
next	1.115;

1.115
date	2003.03.14.17.07.00;	author cagney;	state Exp;
branches;
next	1.114;

1.114
date	2003.03.11.19.07.01;	author brobecke;	state Exp;
branches;
next	1.113;

1.113
date	2003.03.10.23.37.29;	author drow;	state Exp;
branches;
next	1.112;

1.112
date	2003.02.25.21.36.16;	author carlton;	state Exp;
branches
	1.112.4.1;
next	1.111;

1.111
date	2003.02.20.17.17.23;	author carlton;	state Exp;
branches;
next	1.110;

1.110
date	2003.02.20.00.01.05;	author carlton;	state Exp;
branches;
next	1.109;

1.109
date	2003.02.04.22.49.19;	author cagney;	state Exp;
branches;
next	1.108;

1.108
date	2003.02.03.01.18.37;	author ezannoni;	state Exp;
branches;
next	1.107;

1.107
date	2003.01.18.15.55.51;	author cagney;	state Exp;
branches
	1.107.2.1;
next	1.106;

1.106
date	2003.01.15.00.48.37;	author ezannoni;	state Exp;
branches;
next	1.105;

1.105
date	2003.01.04.23.07.24;	author drow;	state Exp;
branches;
next	1.104;

1.104
date	2002.12.17.17.27.44;	author cagney;	state Exp;
branches;
next	1.103;

1.103
date	2002.12.11.22.34.47;	author cagney;	state Exp;
branches;
next	1.102;

1.102
date	2002.12.09.03.30.44;	author cagney;	state Exp;
branches;
next	1.101;

1.101
date	2002.12.09.01.40.25;	author cagney;	state Exp;
branches;
next	1.100;

1.100
date	2002.12.04.04.53.13;	author drow;	state Exp;
branches;
next	1.99;

1.99
date	2002.12.04.00.05.53;	author cagney;	state Exp;
branches;
next	1.98;

1.98
date	2002.12.01.19.07.14;	author cagney;	state Exp;
branches;
next	1.97;

1.97
date	2002.11.29.19.15.14;	author cagney;	state Exp;
branches;
next	1.96;

1.96
date	2002.11.28.21.38.43;	author cagney;	state Exp;
branches;
next	1.95;

1.95
date	2002.11.24.03.20.09;	author cagney;	state Exp;
branches;
next	1.94;

1.94
date	2002.11.16.19.22.58;	author drow;	state Exp;
branches;
next	1.93;

1.93
date	2002.11.10.15.36.26;	author cagney;	state Exp;
branches;
next	1.92;

1.92
date	2002.10.24.21.02.53;	author ezannoni;	state Exp;
branches;
next	1.91;

1.91
date	2002.10.16.23.25.32;	author fedor;	state Exp;
branches;
next	1.90;

1.90
date	2002.09.22.20.29.52;	author fnasser;	state Exp;
branches
	1.90.2.1;
next	1.89;

1.89
date	2002.09.20.14.58.58;	author fnasser;	state Exp;
branches
	1.89.2.1;
next	1.88;

1.88
date	2002.09.19.03.58.40;	author cagney;	state Exp;
branches;
next	1.87;

1.87
date	2002.09.19.01.34.51;	author msnyder;	state Exp;
branches;
next	1.86;

1.86
date	2002.09.05.01.28.14;	author msnyder;	state Exp;
branches;
next	1.85;

1.85
date	2002.08.30.07.14.19;	author muller;	state Exp;
branches;
next	1.84;

1.84
date	2002.08.27.19.06.35;	author ezannoni;	state Exp;
branches;
next	1.83;

1.83
date	2002.08.27.01.09.08;	author msnyder;	state Exp;
branches;
next	1.82;

1.82
date	2002.08.23.20.49.38;	author graces;	state Exp;
branches;
next	1.81;

1.81
date	2002.08.20.20.03.35;	author kseitz;	state Exp;
branches;
next	1.80;

1.80
date	2002.08.17.06.12.52;	author brobecke;	state Exp;
branches;
next	1.79;

1.79
date	2002.08.16.15.37.54;	author cagney;	state Exp;
branches;
next	1.78;

1.78
date	2002.06.26.05.20.04;	author tromey;	state Exp;
branches;
next	1.77;

1.77
date	2002.06.18.21.58.55;	author kseitz;	state Exp;
branches;
next	1.76;

1.76
date	2002.06.10.23.25.50;	author cagney;	state Exp;
branches;
next	1.75;

1.75
date	2002.05.05.01.15.12;	author cagney;	state Exp;
branches
	1.75.4.1
	1.75.6.1;
next	1.74;

1.74
date	2002.04.24.16.28.15;	author cagney;	state Exp;
branches;
next	1.73;

1.73
date	2002.04.21.20.23.32;	author cagney;	state Exp;
branches;
next	1.72;

1.72
date	2002.04.09.22.33.25;	author msnyder;	state Exp;
branches;
next	1.71;

1.71
date	2002.04.05.22.04.41;	author jimb;	state Exp;
branches;
next	1.70;

1.70
date	2002.04.05.19.16.15;	author msnyder;	state Exp;
branches;
next	1.69;

1.69
date	2002.04.05.02.35.26;	author msnyder;	state Exp;
branches;
next	1.68;

1.68
date	2002.03.28.01.35.55;	author msnyder;	state Exp;
branches;
next	1.67;

1.67
date	2002.03.06.06.28.33;	author cagney;	state Exp;
branches;
next	1.66;

1.66
date	2002.02.18.13.35.29;	author rearnsha;	state Exp;
branches;
next	1.65;

1.65
date	2002.02.06.18.31.06;	author msnyder;	state Exp;
branches;
next	1.64;

1.64
date	2002.02.03.11.43.19;	author schauer;	state Exp;
branches;
next	1.63;

1.63
date	2002.02.02.02.49.07;	author msnyder;	state Exp;
branches;
next	1.62;

1.62
date	2002.02.02.01.25.28;	author msnyder;	state Exp;
branches;
next	1.61;

1.61
date	2002.02.01.23.44.39;	author msnyder;	state Exp;
branches;
next	1.60;

1.60
date	2002.02.01.02.05.12;	author msnyder;	state Exp;
branches;
next	1.59;

1.59
date	2002.02.01.01.08.05;	author msnyder;	state Exp;
branches;
next	1.58;

1.58
date	2002.01.17.22.15.16;	author cagney;	state Exp;
branches;
next	1.57;

1.57
date	2001.11.11.16.39.59;	author cagney;	state Exp;
branches;
next	1.56;

1.56
date	2001.11.06.11.02.12;	author corinna;	state Exp;
branches;
next	1.55;

1.55
date	2001.10.20.23.54.29;	author cagney;	state Exp;
branches;
next	1.54;

1.54
date	2001.10.12.23.51.28;	author drow;	state Exp;
branches;
next	1.53;

1.53
date	2001.09.18.05.00.48;	author cagney;	state Exp;
branches;
next	1.52;

1.52
date	2001.08.02.11.58.28;	author eliz;	state Exp;
branches;
next	1.51;

1.51
date	2001.07.28.19.48.15;	author cagney;	state Exp;
branches
	1.51.2.1;
next	1.50;

1.50
date	2001.07.14.18.59.07;	author ciceron;	state Exp;
branches;
next	1.49;

1.49
date	2001.07.06.03.53.11;	author cagney;	state Exp;
branches
	1.49.2.1;
next	1.48;

1.48
date	2001.06.28.21.34.03;	author msnyder;	state Exp;
branches;
next	1.47;

1.47
date	2001.06.27.00.09.01;	author cagney;	state Exp;
branches;
next	1.46;

1.46
date	2001.06.21.15.39.52;	author cagney;	state Exp;
branches;
next	1.45;

1.45
date	2001.06.19.20.30.11;	author cagney;	state Exp;
branches;
next	1.44;

1.44
date	2001.06.19.16.19.15;	author cagney;	state Exp;
branches;
next	1.43;

1.43
date	2001.06.18.18.48.06;	author cagney;	state Exp;
branches;
next	1.42;

1.42
date	2001.06.18.17.57.37;	author cagney;	state Exp;
branches;
next	1.41;

1.41
date	2001.06.11.16.05.24;	author eliz;	state Exp;
branches;
next	1.40;

1.40
date	2001.06.09.01.55.43;	author msnyder;	state Exp;
branches;
next	1.39;

1.39
date	2001.06.02.00.36.20;	author msnyder;	state Exp;
branches;
next	1.38;

1.38
date	2001.05.23.00.52.44;	author kevinb;	state Exp;
branches;
next	1.37;

1.37
date	2001.05.12.04.08.23;	author cagney;	state Exp;
branches;
next	1.36;

1.36
date	2001.05.11.19.46.35;	author kevinb;	state Exp;
branches;
next	1.35;

1.35
date	2001.05.06.22.22.02;	author kevinb;	state Exp;
branches;
next	1.34;

1.34
date	2001.05.06.01.35.57;	author jimb;	state Exp;
branches;
next	1.33;

1.33
date	2001.05.06.00.52.07;	author jimb;	state Exp;
branches;
next	1.32;

1.32
date	2001.05.04.04.15.24;	author kevinb;	state Exp;
branches;
next	1.31;

1.31
date	2001.04.17.20.16.30;	author msnyder;	state Exp;
branches;
next	1.30;

1.30
date	2001.03.27.20.36.23;	author jtc;	state Exp;
branches;
next	1.29;

1.29
date	2001.03.20.18.16.10;	author cagney;	state Exp;
branches;
next	1.28;

1.28
date	2001.03.20.09.46.00;	author eliz;	state Exp;
branches;
next	1.27;

1.27
date	2001.03.06.08.21.05;	author kevinb;	state Exp;
branches;
next	1.26;

1.26
date	2001.03.01.03.50.17;	author msnyder;	state Exp;
branches;
next	1.25;

1.25
date	2001.02.08.06.03.52;	author cagney;	state Exp;
branches;
next	1.24;

1.24
date	2001.01.31.01.24.00;	author cagney;	state Exp;
branches;
next	1.23;

1.23
date	2001.01.18.15.42.23;	author cagney;	state Exp;
branches;
next	1.22;

1.22
date	2000.12.15.01.01.45;	author kevinb;	state Exp;
branches;
next	1.21;

1.21
date	2000.12.01.00.41.27;	author fnasser;	state Exp;
branches;
next	1.20;

1.20
date	2000.11.27.02.18.44;	author cagney;	state Exp;
branches;
next	1.19;

1.19
date	2000.10.30.15.32.51;	author taylor;	state Exp;
branches;
next	1.18;

1.18
date	2000.10.27.15.02.42;	author davea;	state Exp;
branches;
next	1.17;

1.17
date	2000.08.30.00.58.58;	author msnyder;	state Exp;
branches;
next	1.16;

1.16
date	2000.08.03.18.17.58;	author kevinb;	state Exp;
branches;
next	1.15;

1.15
date	2000.07.30.01.48.24;	author kevinb;	state Exp;
branches;
next	1.14;

1.14
date	2000.07.07.00.20.29;	author kettenis;	state Exp;
branches;
next	1.13;

1.13
date	2000.06.12.21.17.21;	author msnyder;	state Exp;
branches;
next	1.12;

1.12
date	2000.06.04.00.41.09;	author kevinb;	state Exp;
branches;
next	1.11;

1.11
date	2000.05.28.01.12.26;	author kevinb;	state Exp;
branches;
next	1.10;

1.10
date	2000.05.15.05.54.02;	author cagney;	state Exp;
branches;
next	1.9;

1.9
date	2000.05.15.03.16.14;	author cagney;	state Exp;
branches;
next	1.8;

1.8
date	2000.03.30.18.54.28;	author msnyder;	state Exp;
branches;
next	1.7;

1.7
date	2000.03.29.00.51.17;	author cagney;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.28.22.30.19;	author msnyder;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.28.19.29.56;	author msnyder;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.21.20.41.39;	author msnyder;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.21.01.27.34;	author msnyder;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.23.00.25.42;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.33.58;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.745.2.1
date	2013.04.04.19.15.54;	author palves;	state Exp;
branches;
next	1.745.2.2;

1.745.2.2
date	2013.04.12.02.27.18;	author teawater;	state Exp;
branches;
next	1.745.2.3;

1.745.2.3
date	2013.04.24.06.20.28;	author teawater;	state Exp;
branches;
next	1.745.2.4;

1.745.2.4
date	2013.04.25.01.26.35;	author teawater;	state Exp;
branches;
next	1.745.2.5;

1.745.2.5
date	2013.04.25.08.15.34;	author teawater;	state Exp;
branches;
next	1.745.2.6;

1.745.2.6
date	2013.05.07.17.04.57;	author sergiodj;	state Exp;
branches;
next	1.745.2.7;

1.745.2.7
date	2013.06.26.02.31.58;	author teawater;	state Exp;
branches;
next	1.745.2.8;

1.745.2.8
date	2013.08.30.15.58.54;	author tromey;	state Exp;
branches;
next	;

1.690.2.1
date	2012.07.24.17.41.31;	author marckhouzam;	state Exp;
branches;
next	;

1.633.2.1
date	2011.12.14.08.12.19;	author qiyao;	state Exp;
branches;
next	1.633.2.2;

1.633.2.2
date	2011.12.23.17.55.20;	author kpouget;	state Exp;
branches;
next	1.633.2.3;

1.633.2.3
date	2012.01.04.12.35.11;	author uweigand;	state Exp;
branches;
next	1.633.2.4;

1.633.2.4
date	2012.01.06.04.43.05;	author brobecke;	state Exp;
branches;
next	1.633.2.5;

1.633.2.5
date	2012.03.13.22.18.19;	author palves;	state Exp;
branches;
next	;

1.561.2.1
date	2011.04.15.04.16.42;	author bauermann;	state Exp;
branches;
next	1.561.2.2;

1.561.2.2
date	2011.04.15.04.18.34;	author bauermann;	state Exp;
branches;
next	1.561.2.3;

1.561.2.3
date	2011.05.17.21.25.56;	author brobecke;	state Exp;
branches;
next	1.561.2.4;

1.561.2.4
date	2011.07.02.19.33.09;	author jkratoch;	state Exp;
branches;
next	;

1.501.2.1
date	2010.07.28.18.00.02;	author brobecke;	state Exp;
branches;
next	1.501.2.2;

1.501.2.2
date	2010.11.25.23.25.32;	author marckhouzam;	state Exp;
branches;
next	1.501.2.3;

1.501.2.3
date	2010.12.27.19.53.55;	author palves;	state Exp;
branches;
next	;

1.361.2.1
date	2008.11.21.02.31.57;	author shebs;	state Exp;
branches;
next	;

1.352.2.1
date	2008.09.30.23.56.56;	author msnyder;	state Exp;
branches;
next	1.352.2.2;

1.352.2.2
date	2008.10.07.00.30.00;	author msnyder;	state Exp;
branches;
next	;

1.336.2.1
date	2008.07.18.04.23.49;	author msnyder;	state Exp;
branches;
next	1.336.2.2;

1.336.2.2
date	2008.10.07.00.30.20;	author msnyder;	state Exp;
branches;
next	;

1.324.2.1
date	2008.06.10.02.11.17;	author msnyder;	state Exp;
branches;
next	;

1.303.2.1
date	2008.04.19.01.25.36;	author brobecke;	state Exp;
branches;
next	1.303.2.2;

1.303.2.2
date	2008.04.22.20.26.00;	author brobecke;	state Exp;
branches;
next	;

1.303.6.1
date	2009.09.11.04.45.44;	author amylaar;	state Exp;
branches;
next	;

1.243.2.1
date	2008.06.10.00.13.14;	author msnyder;	state Exp;
branches;
next	;

1.226.2.1
date	2006.05.03.00.36.00;	author msnyder;	state Exp;
branches;
next	;

1.226.4.1
date	2006.08.28.07.48.50;	author nickrob;	state Exp;
branches;
next	;

1.223.2.1
date	2006.04.03.00.47.37;	author drow;	state Exp;
branches
	1.223.2.1.2.1;
next	1.223.2.2;

1.223.2.2
date	2006.06.01.13.00.47;	author nathan;	state Exp;
branches;
next	1.223.2.3;

1.223.2.3
date	2006.06.05.17.31.50;	author nathan;	state Exp;
branches;
next	;

1.223.2.1.2.1
date	2006.04.11.21.58.22;	author drow;	state Exp;
branches;
next	;

1.223.4.1
date	2006.04.02.21.52.39;	author drow;	state Exp;
branches;
next	;

1.223.6.1
date	2006.03.31.21.00.12;	author msnyder;	state Exp;
branches;
next	;

1.217.2.1
date	2005.05.30.22.33.44;	author msnyder;	state Exp;
branches;
next	;

1.165.2.1
date	2004.03.24.04.10.00;	author ezannoni;	state Exp;
branches;
next	;

1.162.2.1
date	2004.06.12.17.58.23;	author cagney;	state Exp;
branches;
next	;

1.162.4.1
date	2004.03.21.23.57.33;	author cagney;	state Exp;
branches;
next	;

1.158.4.1
date	2004.03.27.17.37.44;	author drow;	state Exp;
branches;
next	1.158.4.2;

1.158.4.2
date	2004.09.16.17.00.54;	author drow;	state Exp;
branches;
next	;

1.124.2.1
date	2003.07.02.16.24.30;	author drow;	state Exp;
branches;
next	;

1.120.8.1
date	2003.06.03.20.54.33;	author cagney;	state Exp;
branches;
next	;

1.118.2.1
date	2003.05.04.11.37.40;	author kettenis;	state Exp;
branches;
next	1.118.2.2;

1.118.2.2
date	2003.05.18.09.43.59;	author kettenis;	state Exp;
branches;
next	;

1.117.2.1
date	2003.04.03.17.01.47;	author cagney;	state Exp;
branches;
next	;

1.112.4.1
date	2003.03.16.14.01.47;	author kettenis;	state Exp;
branches;
next	;

1.107.2.1
date	2003.02.03.06.02.44;	author cagney;	state Exp;
branches;
next	1.107.2.2;

1.107.2.2
date	2003.02.04.01.26.54;	author cagney;	state Exp;
branches;
next	;

1.90.2.1
date	2002.10.26.17.12.04;	author drow;	state Exp;
branches;
next	1.90.2.2;

1.90.2.2
date	2003.12.14.20.27.07;	author drow;	state Exp;
branches;
next	1.90.2.3;

1.90.2.3
date	2003.12.20.18.16.48;	author drow;	state Exp;
branches;
next	1.90.2.4;

1.90.2.4
date	2003.12.24.22.08.38;	author drow;	state Exp;
branches;
next	1.90.2.5;

1.90.2.5
date	2004.02.09.19.43.31;	author drow;	state Exp;
branches;
next	;

1.89.2.1
date	2002.09.24.00.04.49;	author carlton;	state Exp;
branches;
next	1.89.2.2;

1.89.2.2
date	2002.09.27.20.03.05;	author carlton;	state Exp;
branches;
next	1.89.2.3;

1.89.2.3
date	2002.10.18.23.42.57;	author carlton;	state Exp;
branches;
next	1.89.2.4;

1.89.2.4
date	2002.10.25.23.49.52;	author carlton;	state Exp;
branches;
next	1.89.2.5;

1.89.2.5
date	2002.11.15.19.18.36;	author carlton;	state Exp;
branches;
next	1.89.2.6;

1.89.2.6
date	2002.11.28.00.53.21;	author carlton;	state Exp;
branches;
next	1.89.2.7;

1.89.2.7
date	2002.12.21.00.17.42;	author carlton;	state Exp;
branches;
next	1.89.2.8;

1.89.2.8
date	2002.12.23.19.38.12;	author carlton;	state Exp;
branches;
next	1.89.2.9;

1.89.2.9
date	2003.02.07.19.17.44;	author carlton;	state Exp;
branches;
next	1.89.2.10;

1.89.2.10
date	2003.03.06.00.56.23;	author carlton;	state Exp;
branches;
next	1.89.2.11;

1.89.2.11
date	2003.04.16.19.56.51;	author carlton;	state Exp;
branches;
next	1.89.2.12;

1.89.2.12
date	2003.05.01.00.46.46;	author carlton;	state Exp;
branches;
next	1.89.2.13;

1.89.2.13
date	2003.05.23.18.40.35;	author carlton;	state Exp;
branches;
next	1.89.2.14;

1.89.2.14
date	2003.06.27.21.49.46;	author carlton;	state Exp;
branches;
next	1.89.2.15;

1.89.2.15
date	2003.08.05.17.13.04;	author carlton;	state Exp;
branches;
next	1.89.2.16;

1.89.2.16
date	2003.09.17.21.28.06;	author carlton;	state Exp;
branches;
next	1.89.2.17;

1.89.2.17
date	2003.11.11.23.50.38;	author carlton;	state Exp;
branches;
next	1.89.2.18;

1.89.2.18
date	2003.12.16.00.00.13;	author carlton;	state Exp;
branches;
next	1.89.2.19;

1.89.2.19
date	2004.01.26.19.11.15;	author carlton;	state Exp;
branches;
next	;

1.75.4.1
date	2002.06.15.16.42.50;	author cagney;	state Exp;
branches;
next	1.75.4.2;

1.75.4.2
date	2002.06.21.16.19.18;	author cagney;	state Exp;
branches;
next	1.75.4.3;

1.75.4.3
date	2002.06.28.23.19.25;	author cagney;	state Exp;
branches;
next	;

1.75.6.1
date	2002.06.19.19.01.15;	author kseitz;	state Exp;
branches;
next	1.75.6.2;

1.75.6.2
date	2002.06.20.01.32.13;	author kseitz;	state Exp;
branches;
next	1.75.6.3;

1.75.6.3
date	2002.07.22.21.46.55;	author kseitz;	state Exp;
branches;
next	1.75.6.4;

1.75.6.4
date	2002.08.22.16.24.32;	author kseitz;	state Exp;
branches;
next	1.75.6.5;

1.75.6.5
date	2002.08.30.22.52.42;	author kseitz;	state Exp;
branches;
next	1.75.6.6;

1.75.6.6
date	2002.10.01.00.46.02;	author kseitz;	state Exp;
branches;
next	1.75.6.7;

1.75.6.7
date	2002.11.04.00.17.29;	author ezannoni;	state Exp;
branches;
next	;

1.51.2.1
date	2001.08.02.12.05.56;	author eliz;	state Exp;
branches;
next	1.51.2.2;

1.51.2.2
date	2001.11.11.16.39.14;	author cagney;	state Exp;
branches;
next	;

1.49.2.1
date	2001.07.06.19.16.57;	author dberlin;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.33.58;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.23.42;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.05.19.19.51.49;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.05.25.18.01.01;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.06.01.15.39.41;	author jsm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.07.05.17.52.12;	author jsm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	99.07.07.20.04.27;	author jsm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	99.08.23.22.34.46;	author jsm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	99.08.31.01.04.30;	author jsm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	99.09.08.23.59.01;	author shebs;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	99.09.22.03.24.16;	author jsm;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	99.09.28.21.51.58;	author jsm;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	99.10.05.23.08.00;	author jsm;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	99.10.19.02.46.34;	author jsm;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	99.10.26.03.43.09;	author jsm;	state Exp;
branches;
next	1.1.1.16;

1.1.1.16
date	99.11.02.04.44.13;	author jsm;	state Exp;
branches;
next	1.1.1.17;

1.1.1.17
date	99.11.09.01.23.01;	author jsm;	state Exp;
branches;
next	1.1.1.18;

1.1.1.18
date	99.11.17.02.30.21;	author jsm;	state Exp;
branches;
next	1.1.1.19;

1.1.1.19
date	99.12.07.03.55.58;	author jsm;	state Exp;
branches;
next	1.1.1.20;

1.1.1.20
date	99.12.14.01.05.28;	author jsm;	state Exp;
branches;
next	1.1.1.21;

1.1.1.21
date	99.12.22.21.45.02;	author jsm;	state Exp;
branches;
next	1.1.1.22;

1.1.1.22
date	2000.01.06.03.06.34;	author jsm;	state Exp;
branches;
next	1.1.1.23;

1.1.1.23
date	2000.01.11.03.07.17;	author jsm;	state Exp;
branches;
next	1.1.1.24;

1.1.1.24
date	2000.02.03.04.14.25;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.783
log
@Hardware watchpoints turned off, inferior not yet started.

  https://sourceware.org/ml/gdb-patches/2013-10/msg00477.html

gdb/ChangeLog

	* breakpoint.c (update_watchpoint): If hardware watchpoints are
	forced off, downgrade them to software watchpoints if possible,
	and error out if not possible.
	(watch_command_1): Move watchpoint type selection closer to
	watchpoint creation, and extend the comments.

gdb/testsuite/ChangeLog

	* gdb.base/watchpoints.exp: Add test for setting software
	watchpoints of different types before starting the inferior.
@
text
@/* Everything about breakpoints, for GDB.

   Copyright (C) 1986-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "arch-utils.h"
#include <ctype.h>
#include "hashtab.h"
#include "symtab.h"
#include "frame.h"
#include "breakpoint.h"
#include "tracepoint.h"
#include "gdbtypes.h"
#include "expression.h"
#include "gdbcore.h"
#include "gdbcmd.h"
#include "value.h"
#include "command.h"
#include "inferior.h"
#include "gdbthread.h"
#include "target.h"
#include "language.h"
#include "gdb_string.h"
#include "gdb-demangle.h"
#include "filenames.h"
#include "annotate.h"
#include "symfile.h"
#include "objfiles.h"
#include "source.h"
#include "linespec.h"
#include "completer.h"
#include "gdb.h"
#include "ui-out.h"
#include "cli/cli-script.h"
#include "gdb_assert.h"
#include "block.h"
#include "solib.h"
#include "solist.h"
#include "observer.h"
#include "exceptions.h"
#include "memattr.h"
#include "ada-lang.h"
#include "top.h"
#include "valprint.h"
#include "jit.h"
#include "xml-syscall.h"
#include "parser-defs.h"
#include "gdb_regex.h"
#include "probe.h"
#include "cli/cli-utils.h"
#include "continuations.h"
#include "stack.h"
#include "skip.h"
#include "gdb_regex.h"
#include "ax-gdb.h"
#include "dummy-frame.h"

#include "format.h"

/* readline include files */
#include "readline/readline.h"
#include "readline/history.h"

/* readline defines this.  */
#undef savestring

#include "mi/mi-common.h"
#include "python/python.h"

/* Enums for exception-handling support.  */
enum exception_event_kind
{
  EX_EVENT_THROW,
  EX_EVENT_RETHROW,
  EX_EVENT_CATCH
};

/* Prototypes for local functions.  */

static void enable_delete_command (char *, int);

static void enable_once_command (char *, int);

static void enable_count_command (char *, int);

static void disable_command (char *, int);

static void enable_command (char *, int);

static void map_breakpoint_numbers (char *, void (*) (struct breakpoint *,
						      void *),
				    void *);

static void ignore_command (char *, int);

static int breakpoint_re_set_one (void *);

static void breakpoint_re_set_default (struct breakpoint *);

static void create_sals_from_address_default (char **,
					      struct linespec_result *,
					      enum bptype, char *,
					      char **);

static void create_breakpoints_sal_default (struct gdbarch *,
					    struct linespec_result *,
					    char *, char *, enum bptype,
					    enum bpdisp, int, int,
					    int,
					    const struct breakpoint_ops *,
					    int, int, int, unsigned);

static void decode_linespec_default (struct breakpoint *, char **,
				     struct symtabs_and_lines *);

static void clear_command (char *, int);

static void catch_command (char *, int);

static int can_use_hardware_watchpoint (struct value *);

static void break_command_1 (char *, int, int);

static void mention (struct breakpoint *);

static struct breakpoint *set_raw_breakpoint_without_location (struct gdbarch *,
							       enum bptype,
							       const struct breakpoint_ops *);
static struct bp_location *add_location_to_breakpoint (struct breakpoint *,
						       const struct symtab_and_line *);

/* This function is used in gdbtk sources and thus can not be made
   static.  */
struct breakpoint *set_raw_breakpoint (struct gdbarch *gdbarch,
				       struct symtab_and_line,
				       enum bptype,
				       const struct breakpoint_ops *);

static struct breakpoint *
  momentary_breakpoint_from_master (struct breakpoint *orig,
				    enum bptype type,
				    const struct breakpoint_ops *ops);

static void breakpoint_adjustment_warning (CORE_ADDR, CORE_ADDR, int, int);

static CORE_ADDR adjust_breakpoint_address (struct gdbarch *gdbarch,
					    CORE_ADDR bpaddr,
                                            enum bptype bptype);

static void describe_other_breakpoints (struct gdbarch *,
					struct program_space *, CORE_ADDR,
					struct obj_section *, int);

static int breakpoint_address_match (struct address_space *aspace1,
				     CORE_ADDR addr1,
				     struct address_space *aspace2,
				     CORE_ADDR addr2);

static int watchpoint_locations_match (struct bp_location *loc1,
				       struct bp_location *loc2);

static int breakpoint_location_address_match (struct bp_location *bl,
					      struct address_space *aspace,
					      CORE_ADDR addr);

static void breakpoints_info (char *, int);

static void watchpoints_info (char *, int);

static int breakpoint_1 (char *, int, 
			 int (*) (const struct breakpoint *));

static int breakpoint_cond_eval (void *);

static void cleanup_executing_breakpoints (void *);

static void commands_command (char *, int);

static void condition_command (char *, int);

typedef enum
  {
    mark_inserted,
    mark_uninserted
  }
insertion_state_t;

static int remove_breakpoint (struct bp_location *, insertion_state_t);
static int remove_breakpoint_1 (struct bp_location *, insertion_state_t);

static enum print_stop_action print_bp_stop_message (bpstat bs);

static int watchpoint_check (void *);

static void maintenance_info_breakpoints (char *, int);

static int hw_breakpoint_used_count (void);

static int hw_watchpoint_use_count (struct breakpoint *);

static int hw_watchpoint_used_count_others (struct breakpoint *except,
					    enum bptype type,
					    int *other_type_used);

static void hbreak_command (char *, int);

static void thbreak_command (char *, int);

static void enable_breakpoint_disp (struct breakpoint *, enum bpdisp,
				    int count);

static void stop_command (char *arg, int from_tty);

static void stopin_command (char *arg, int from_tty);

static void stopat_command (char *arg, int from_tty);

static void tcatch_command (char *arg, int from_tty);

static void detach_single_step_breakpoints (void);

static int single_step_breakpoint_inserted_here_p (struct address_space *,
						   CORE_ADDR pc);

static void free_bp_location (struct bp_location *loc);
static void incref_bp_location (struct bp_location *loc);
static void decref_bp_location (struct bp_location **loc);

static struct bp_location *allocate_bp_location (struct breakpoint *bpt);

static void update_global_location_list (int);

static void update_global_location_list_nothrow (int);

static int is_hardware_watchpoint (const struct breakpoint *bpt);

static void insert_breakpoint_locations (void);

static int syscall_catchpoint_p (struct breakpoint *b);

static void tracepoints_info (char *, int);

static void delete_trace_command (char *, int);

static void enable_trace_command (char *, int);

static void disable_trace_command (char *, int);

static void trace_pass_command (char *, int);

static void set_tracepoint_count (int num);

static int is_masked_watchpoint (const struct breakpoint *b);

static struct bp_location **get_first_locp_gte_addr (CORE_ADDR address);

/* Return 1 if B refers to a static tracepoint set by marker ("-m"), zero
   otherwise.  */

static int strace_marker_p (struct breakpoint *b);

/* The abstract base class all breakpoint_ops structures inherit
   from.  */
struct breakpoint_ops base_breakpoint_ops;

/* The breakpoint_ops structure to be inherited by all breakpoint_ops
   that are implemented on top of software or hardware breakpoints
   (user breakpoints, internal and momentary breakpoints, etc.).  */
static struct breakpoint_ops bkpt_base_breakpoint_ops;

/* Internal breakpoints class type.  */
static struct breakpoint_ops internal_breakpoint_ops;

/* Momentary breakpoints class type.  */
static struct breakpoint_ops momentary_breakpoint_ops;

/* Momentary breakpoints for bp_longjmp and bp_exception class type.  */
static struct breakpoint_ops longjmp_breakpoint_ops;

/* The breakpoint_ops structure to be used in regular user created
   breakpoints.  */
struct breakpoint_ops bkpt_breakpoint_ops;

/* Breakpoints set on probes.  */
static struct breakpoint_ops bkpt_probe_breakpoint_ops;

/* Dynamic printf class type.  */
struct breakpoint_ops dprintf_breakpoint_ops;

/* The style in which to perform a dynamic printf.  This is a user
   option because different output options have different tradeoffs;
   if GDB does the printing, there is better error handling if there
   is a problem with any of the arguments, but using an inferior
   function lets you have special-purpose printers and sending of
   output to the same place as compiled-in print functions.  */

static const char dprintf_style_gdb[] = "gdb";
static const char dprintf_style_call[] = "call";
static const char dprintf_style_agent[] = "agent";
static const char *const dprintf_style_enums[] = {
  dprintf_style_gdb,
  dprintf_style_call,
  dprintf_style_agent,
  NULL
};
static const char *dprintf_style = dprintf_style_gdb;

/* The function to use for dynamic printf if the preferred style is to
   call into the inferior.  The value is simply a string that is
   copied into the command, so it can be anything that GDB can
   evaluate to a callable address, not necessarily a function name.  */

static char *dprintf_function = "";

/* The channel to use for dynamic printf if the preferred style is to
   call into the inferior; if a nonempty string, it will be passed to
   the call as the first argument, with the format string as the
   second.  As with the dprintf function, this can be anything that
   GDB knows how to evaluate, so in addition to common choices like
   "stderr", this could be an app-specific expression like
   "mystreams[curlogger]".  */

static char *dprintf_channel = "";

/* True if dprintf commands should continue to operate even if GDB
   has disconnected.  */
static int disconnected_dprintf = 1;

/* A reference-counted struct command_line.  This lets multiple
   breakpoints share a single command list.  */
struct counted_command_line
{
  /* The reference count.  */
  int refc;

  /* The command list.  */
  struct command_line *commands;
};

struct command_line *
breakpoint_commands (struct breakpoint *b)
{
  return b->commands ? b->commands->commands : NULL;
}

/* Flag indicating that a command has proceeded the inferior past the
   current breakpoint.  */

static int breakpoint_proceeded;

const char *
bpdisp_text (enum bpdisp disp)
{
  /* NOTE: the following values are a part of MI protocol and
     represent values of 'disp' field returned when inferior stops at
     a breakpoint.  */
  static const char * const bpdisps[] = {"del", "dstp", "dis", "keep"};

  return bpdisps[(int) disp];
}

/* Prototypes for exported functions.  */
/* If FALSE, gdb will not use hardware support for watchpoints, even
   if such is available.  */
static int can_use_hw_watchpoints;

static void
show_can_use_hw_watchpoints (struct ui_file *file, int from_tty,
			     struct cmd_list_element *c,
			     const char *value)
{
  fprintf_filtered (file,
		    _("Debugger's willingness to use "
		      "watchpoint hardware is %s.\n"),
		    value);
}

/* If AUTO_BOOLEAN_FALSE, gdb will not attempt to create pending breakpoints.
   If AUTO_BOOLEAN_TRUE, gdb will automatically create pending breakpoints
   for unrecognized breakpoint locations.
   If AUTO_BOOLEAN_AUTO, gdb will query when breakpoints are unrecognized.  */
static enum auto_boolean pending_break_support;
static void
show_pending_break_support (struct ui_file *file, int from_tty,
			    struct cmd_list_element *c,
			    const char *value)
{
  fprintf_filtered (file,
		    _("Debugger's behavior regarding "
		      "pending breakpoints is %s.\n"),
		    value);
}

/* If 1, gdb will automatically use hardware breakpoints for breakpoints
   set with "break" but falling in read-only memory.
   If 0, gdb will warn about such breakpoints, but won't automatically
   use hardware breakpoints.  */
static int automatic_hardware_breakpoints;
static void
show_automatic_hardware_breakpoints (struct ui_file *file, int from_tty,
				     struct cmd_list_element *c,
				     const char *value)
{
  fprintf_filtered (file,
		    _("Automatic usage of hardware breakpoints is %s.\n"),
		    value);
}

/* If on, gdb will keep breakpoints inserted even as inferior is
   stopped, and immediately insert any new breakpoints.  If off, gdb
   will insert breakpoints into inferior only when resuming it, and
   will remove breakpoints upon stop.  If auto, GDB will behave as ON
   if in non-stop mode, and as OFF if all-stop mode.*/

static enum auto_boolean always_inserted_mode = AUTO_BOOLEAN_AUTO;

static void
show_always_inserted_mode (struct ui_file *file, int from_tty,
		     struct cmd_list_element *c, const char *value)
{
  if (always_inserted_mode == AUTO_BOOLEAN_AUTO)
    fprintf_filtered (file,
		      _("Always inserted breakpoint "
			"mode is %s (currently %s).\n"),
		      value,
		      breakpoints_always_inserted_mode () ? "on" : "off");
  else
    fprintf_filtered (file, _("Always inserted breakpoint mode is %s.\n"),
		      value);
}

int
breakpoints_always_inserted_mode (void)
{
  return (always_inserted_mode == AUTO_BOOLEAN_TRUE
	  || (always_inserted_mode == AUTO_BOOLEAN_AUTO && non_stop));
}

static const char condition_evaluation_both[] = "host or target";

/* Modes for breakpoint condition evaluation.  */
static const char condition_evaluation_auto[] = "auto";
static const char condition_evaluation_host[] = "host";
static const char condition_evaluation_target[] = "target";
static const char *const condition_evaluation_enums[] = {
  condition_evaluation_auto,
  condition_evaluation_host,
  condition_evaluation_target,
  NULL
};

/* Global that holds the current mode for breakpoint condition evaluation.  */
static const char *condition_evaluation_mode_1 = condition_evaluation_auto;

/* Global that we use to display information to the user (gets its value from
   condition_evaluation_mode_1.  */
static const char *condition_evaluation_mode = condition_evaluation_auto;

/* Translate a condition evaluation mode MODE into either "host"
   or "target".  This is used mostly to translate from "auto" to the
   real setting that is being used.  It returns the translated
   evaluation mode.  */

static const char *
translate_condition_evaluation_mode (const char *mode)
{
  if (mode == condition_evaluation_auto)
    {
      if (target_supports_evaluation_of_breakpoint_conditions ())
	return condition_evaluation_target;
      else
	return condition_evaluation_host;
    }
  else
    return mode;
}

/* Discovers what condition_evaluation_auto translates to.  */

static const char *
breakpoint_condition_evaluation_mode (void)
{
  return translate_condition_evaluation_mode (condition_evaluation_mode);
}

/* Return true if GDB should evaluate breakpoint conditions or false
   otherwise.  */

static int
gdb_evaluates_breakpoint_condition_p (void)
{
  const char *mode = breakpoint_condition_evaluation_mode ();

  return (mode == condition_evaluation_host);
}

void _initialize_breakpoint (void);

/* Are we executing breakpoint commands?  */
static int executing_breakpoint_commands;

/* Are overlay event breakpoints enabled? */
static int overlay_events_enabled;

/* See description in breakpoint.h. */
int target_exact_watchpoints = 0;

/* Walk the following statement or block through all breakpoints.
   ALL_BREAKPOINTS_SAFE does so even if the statement deletes the
   current breakpoint.  */

#define ALL_BREAKPOINTS(B)  for (B = breakpoint_chain; B; B = B->next)

#define ALL_BREAKPOINTS_SAFE(B,TMP)	\
	for (B = breakpoint_chain;	\
	     B ? (TMP=B->next, 1): 0;	\
	     B = TMP)

/* Similar iterator for the low-level breakpoints.  SAFE variant is
   not provided so update_global_location_list must not be called
   while executing the block of ALL_BP_LOCATIONS.  */

#define ALL_BP_LOCATIONS(B,BP_TMP)					\
	for (BP_TMP = bp_location;					\
	     BP_TMP < bp_location + bp_location_count && (B = *BP_TMP);	\
	     BP_TMP++)

/* Iterates through locations with address ADDRESS for the currently selected
   program space.  BP_LOCP_TMP points to each object.  BP_LOCP_START points
   to where the loop should start from.
   If BP_LOCP_START is a NULL pointer, the macro automatically seeks the
   appropriate location to start with.  */

#define ALL_BP_LOCATIONS_AT_ADDR(BP_LOCP_TMP, BP_LOCP_START, ADDRESS)	\
	for (BP_LOCP_START = BP_LOCP_START == NULL ? get_first_locp_gte_addr (ADDRESS) : BP_LOCP_START, \
	     BP_LOCP_TMP = BP_LOCP_START;				\
	     BP_LOCP_START						\
	     && (BP_LOCP_TMP < bp_location + bp_location_count		\
	     && (*BP_LOCP_TMP)->address == ADDRESS);			\
	     BP_LOCP_TMP++)

/* Iterator for tracepoints only.  */

#define ALL_TRACEPOINTS(B)  \
  for (B = breakpoint_chain; B; B = B->next)  \
    if (is_tracepoint (B))

/* Chains of all breakpoints defined.  */

struct breakpoint *breakpoint_chain;

/* Array is sorted by bp_location_compare - primarily by the ADDRESS.  */

static struct bp_location **bp_location;

/* Number of elements of BP_LOCATION.  */

static unsigned bp_location_count;

/* Maximum alignment offset between bp_target_info.PLACED_ADDRESS and
   ADDRESS for the current elements of BP_LOCATION which get a valid
   result from bp_location_has_shadow.  You can use it for roughly
   limiting the subrange of BP_LOCATION to scan for shadow bytes for
   an address you need to read.  */

static CORE_ADDR bp_location_placed_address_before_address_max;

/* Maximum offset plus alignment between bp_target_info.PLACED_ADDRESS
   + bp_target_info.SHADOW_LEN and ADDRESS for the current elements of
   BP_LOCATION which get a valid result from bp_location_has_shadow.
   You can use it for roughly limiting the subrange of BP_LOCATION to
   scan for shadow bytes for an address you need to read.  */

static CORE_ADDR bp_location_shadow_len_after_address_max;

/* The locations that no longer correspond to any breakpoint, unlinked
   from bp_location array, but for which a hit may still be reported
   by a target.  */
VEC(bp_location_p) *moribund_locations = NULL;

/* Number of last breakpoint made.  */

static int breakpoint_count;

/* The value of `breakpoint_count' before the last command that
   created breakpoints.  If the last (break-like) command created more
   than one breakpoint, then the difference between BREAKPOINT_COUNT
   and PREV_BREAKPOINT_COUNT is more than one.  */
static int prev_breakpoint_count;

/* Number of last tracepoint made.  */

static int tracepoint_count;

static struct cmd_list_element *breakpoint_set_cmdlist;
static struct cmd_list_element *breakpoint_show_cmdlist;
struct cmd_list_element *save_cmdlist;

/* Return whether a breakpoint is an active enabled breakpoint.  */
static int
breakpoint_enabled (struct breakpoint *b)
{
  return (b->enable_state == bp_enabled);
}

/* Set breakpoint count to NUM.  */

static void
set_breakpoint_count (int num)
{
  prev_breakpoint_count = breakpoint_count;
  breakpoint_count = num;
  set_internalvar_integer (lookup_internalvar ("bpnum"), num);
}

/* Used by `start_rbreak_breakpoints' below, to record the current
   breakpoint count before "rbreak" creates any breakpoint.  */
static int rbreak_start_breakpoint_count;

/* Called at the start an "rbreak" command to record the first
   breakpoint made.  */

void
start_rbreak_breakpoints (void)
{
  rbreak_start_breakpoint_count = breakpoint_count;
}

/* Called at the end of an "rbreak" command to record the last
   breakpoint made.  */

void
end_rbreak_breakpoints (void)
{
  prev_breakpoint_count = rbreak_start_breakpoint_count;
}

/* Used in run_command to zero the hit count when a new run starts.  */

void
clear_breakpoint_hit_counts (void)
{
  struct breakpoint *b;

  ALL_BREAKPOINTS (b)
    b->hit_count = 0;
}

/* Allocate a new counted_command_line with reference count of 1.
   The new structure owns COMMANDS.  */

static struct counted_command_line *
alloc_counted_command_line (struct command_line *commands)
{
  struct counted_command_line *result
    = xmalloc (sizeof (struct counted_command_line));

  result->refc = 1;
  result->commands = commands;
  return result;
}

/* Increment reference count.  This does nothing if CMD is NULL.  */

static void
incref_counted_command_line (struct counted_command_line *cmd)
{
  if (cmd)
    ++cmd->refc;
}

/* Decrement reference count.  If the reference count reaches 0,
   destroy the counted_command_line.  Sets *CMDP to NULL.  This does
   nothing if *CMDP is NULL.  */

static void
decref_counted_command_line (struct counted_command_line **cmdp)
{
  if (*cmdp)
    {
      if (--(*cmdp)->refc == 0)
	{
	  free_command_lines (&(*cmdp)->commands);
	  xfree (*cmdp);
	}
      *cmdp = NULL;
    }
}

/* A cleanup function that calls decref_counted_command_line.  */

static void
do_cleanup_counted_command_line (void *arg)
{
  decref_counted_command_line (arg);
}

/* Create a cleanup that calls decref_counted_command_line on the
   argument.  */

static struct cleanup *
make_cleanup_decref_counted_command_line (struct counted_command_line **cmdp)
{
  return make_cleanup (do_cleanup_counted_command_line, cmdp);
}


/* Return the breakpoint with the specified number, or NULL
   if the number does not refer to an existing breakpoint.  */

struct breakpoint *
get_breakpoint (int num)
{
  struct breakpoint *b;

  ALL_BREAKPOINTS (b)
    if (b->number == num)
      return b;
  
  return NULL;
}



/* Mark locations as "conditions have changed" in case the target supports
   evaluating conditions on its side.  */

static void
mark_breakpoint_modified (struct breakpoint *b)
{
  struct bp_location *loc;

  /* This is only meaningful if the target is
     evaluating conditions and if the user has
     opted for condition evaluation on the target's
     side.  */
  if (gdb_evaluates_breakpoint_condition_p ()
      || !target_supports_evaluation_of_breakpoint_conditions ())
    return;

  if (!is_breakpoint (b))
    return;

  for (loc = b->loc; loc; loc = loc->next)
    loc->condition_changed = condition_modified;
}

/* Mark location as "conditions have changed" in case the target supports
   evaluating conditions on its side.  */

static void
mark_breakpoint_location_modified (struct bp_location *loc)
{
  /* This is only meaningful if the target is
     evaluating conditions and if the user has
     opted for condition evaluation on the target's
     side.  */
  if (gdb_evaluates_breakpoint_condition_p ()
      || !target_supports_evaluation_of_breakpoint_conditions ())

    return;

  if (!is_breakpoint (loc->owner))
    return;

  loc->condition_changed = condition_modified;
}

/* Sets the condition-evaluation mode using the static global
   condition_evaluation_mode.  */

static void
set_condition_evaluation_mode (char *args, int from_tty,
			       struct cmd_list_element *c)
{
  const char *old_mode, *new_mode;

  if ((condition_evaluation_mode_1 == condition_evaluation_target)
      && !target_supports_evaluation_of_breakpoint_conditions ())
    {
      condition_evaluation_mode_1 = condition_evaluation_mode;
      warning (_("Target does not support breakpoint condition evaluation.\n"
		 "Using host evaluation mode instead."));
      return;
    }

  new_mode = translate_condition_evaluation_mode (condition_evaluation_mode_1);
  old_mode = translate_condition_evaluation_mode (condition_evaluation_mode);

  /* Flip the switch.  Flip it even if OLD_MODE == NEW_MODE as one of the
     settings was "auto".  */
  condition_evaluation_mode = condition_evaluation_mode_1;

  /* Only update the mode if the user picked a different one.  */
  if (new_mode != old_mode)
    {
      struct bp_location *loc, **loc_tmp;
      /* If the user switched to a different evaluation mode, we
	 need to synch the changes with the target as follows:

	 "host" -> "target": Send all (valid) conditions to the target.
	 "target" -> "host": Remove all the conditions from the target.
      */

      if (new_mode == condition_evaluation_target)
	{
	  /* Mark everything modified and synch conditions with the
	     target.  */
	  ALL_BP_LOCATIONS (loc, loc_tmp)
	    mark_breakpoint_location_modified (loc);
  	}
      else
	{
	  /* Manually mark non-duplicate locations to synch conditions
	     with the target.  We do this to remove all the conditions the
	     target knows about.  */
	  ALL_BP_LOCATIONS (loc, loc_tmp)
	    if (is_breakpoint (loc->owner) && loc->inserted)
	      loc->needs_update = 1;
	}

      /* Do the update.  */
      update_global_location_list (1);
    }

  return;
}

/* Shows the current mode of breakpoint condition evaluation.  Explicitly shows
   what "auto" is translating to.  */

static void
show_condition_evaluation_mode (struct ui_file *file, int from_tty,
				struct cmd_list_element *c, const char *value)
{
  if (condition_evaluation_mode == condition_evaluation_auto)
    fprintf_filtered (file,
		      _("Breakpoint condition evaluation "
			"mode is %s (currently %s).\n"),
		      value,
		      breakpoint_condition_evaluation_mode ());
  else
    fprintf_filtered (file, _("Breakpoint condition evaluation mode is %s.\n"),
		      value);
}

/* A comparison function for bp_location AP and BP that is used by
   bsearch.  This comparison function only cares about addresses, unlike
   the more general bp_location_compare function.  */

static int
bp_location_compare_addrs (const void *ap, const void *bp)
{
  struct bp_location *a = *(void **) ap;
  struct bp_location *b = *(void **) bp;

  if (a->address == b->address)
    return 0;
  else
    return ((a->address > b->address) - (a->address < b->address));
}

/* Helper function to skip all bp_locations with addresses
   less than ADDRESS.  It returns the first bp_location that
   is greater than or equal to ADDRESS.  If none is found, just
   return NULL.  */

static struct bp_location **
get_first_locp_gte_addr (CORE_ADDR address)
{
  struct bp_location dummy_loc;
  struct bp_location *dummy_locp = &dummy_loc;
  struct bp_location **locp_found = NULL;

  /* Initialize the dummy location's address field.  */
  memset (&dummy_loc, 0, sizeof (struct bp_location));
  dummy_loc.address = address;

  /* Find a close match to the first location at ADDRESS.  */
  locp_found = bsearch (&dummy_locp, bp_location, bp_location_count,
			sizeof (struct bp_location **),
			bp_location_compare_addrs);

  /* Nothing was found, nothing left to do.  */
  if (locp_found == NULL)
    return NULL;

  /* We may have found a location that is at ADDRESS but is not the first in the
     location's list.  Go backwards (if possible) and locate the first one.  */
  while ((locp_found - 1) >= bp_location
	 && (*(locp_found - 1))->address == address)
    locp_found--;

  return locp_found;
}

void
set_breakpoint_condition (struct breakpoint *b, char *exp,
			  int from_tty)
{
  xfree (b->cond_string);
  b->cond_string = NULL;

  if (is_watchpoint (b))
    {
      struct watchpoint *w = (struct watchpoint *) b;

      xfree (w->cond_exp);
      w->cond_exp = NULL;
    }
  else
    {
      struct bp_location *loc;

      for (loc = b->loc; loc; loc = loc->next)
	{
	  xfree (loc->cond);
	  loc->cond = NULL;

	  /* No need to free the condition agent expression
	     bytecode (if we have one).  We will handle this
	     when we go through update_global_location_list.  */
	}
    }

  if (*exp == 0)
    {
      if (from_tty)
	printf_filtered (_("Breakpoint %d now unconditional.\n"), b->number);
    }
  else
    {
      const char *arg = exp;

      /* I don't know if it matters whether this is the string the user
	 typed in or the decompiled expression.  */
      b->cond_string = xstrdup (arg);
      b->condition_not_parsed = 0;

      if (is_watchpoint (b))
	{
	  struct watchpoint *w = (struct watchpoint *) b;

	  innermost_block = NULL;
	  arg = exp;
	  w->cond_exp = parse_exp_1 (&arg, 0, 0, 0);
	  if (*arg)
	    error (_("Junk at end of expression"));
	  w->cond_exp_valid_block = innermost_block;
	}
      else
	{
	  struct bp_location *loc;

	  for (loc = b->loc; loc; loc = loc->next)
	    {
	      arg = exp;
	      loc->cond =
		parse_exp_1 (&arg, loc->address,
			     block_for_pc (loc->address), 0);
	      if (*arg)
		error (_("Junk at end of expression"));
	    }
	}
    }
  mark_breakpoint_modified (b);

  observer_notify_breakpoint_modified (b);
}

/* Completion for the "condition" command.  */

static VEC (char_ptr) *
condition_completer (struct cmd_list_element *cmd,
		     const char *text, const char *word)
{
  const char *space;

  text = skip_spaces_const (text);
  space = skip_to_space_const (text);
  if (*space == '\0')
    {
      int len;
      struct breakpoint *b;
      VEC (char_ptr) *result = NULL;

      if (text[0] == '$')
	{
	  /* We don't support completion of history indices.  */
	  if (isdigit (text[1]))
	    return NULL;
	  return complete_internalvar (&text[1]);
	}

      /* We're completing the breakpoint number.  */
      len = strlen (text);

      ALL_BREAKPOINTS (b)
	{
	  char number[50];

	  xsnprintf (number, sizeof (number), "%d", b->number);

	  if (strncmp (number, text, len) == 0)
	    VEC_safe_push (char_ptr, result, xstrdup (number));
	}

      return result;
    }

  /* We're completing the expression part.  */
  text = skip_spaces_const (space);
  return expression_completer (cmd, text, word);
}

/* condition N EXP -- set break condition of breakpoint N to EXP.  */

static void
condition_command (char *arg, int from_tty)
{
  struct breakpoint *b;
  char *p;
  int bnum;

  if (arg == 0)
    error_no_arg (_("breakpoint number"));

  p = arg;
  bnum = get_number (&p);
  if (bnum == 0)
    error (_("Bad breakpoint argument: '%s'"), arg);

  ALL_BREAKPOINTS (b)
    if (b->number == bnum)
      {
	/* Check if this breakpoint has a Python object assigned to
	   it, and if it has a definition of the "stop"
	   method.  This method and conditions entered into GDB from
	   the CLI are mutually exclusive.  */
	if (b->py_bp_object
	    && gdbpy_breakpoint_has_py_cond (b->py_bp_object))
	  error (_("Cannot set a condition where a Python 'stop' "
		   "method has been defined in the breakpoint."));
	set_breakpoint_condition (b, p, from_tty);

	if (is_breakpoint (b))
	  update_global_location_list (1);

	return;
      }

  error (_("No breakpoint number %d."), bnum);
}

/* Check that COMMAND do not contain commands that are suitable
   only for tracepoints and not suitable for ordinary breakpoints.
   Throw if any such commands is found.  */

static void
check_no_tracepoint_commands (struct command_line *commands)
{
  struct command_line *c;

  for (c = commands; c; c = c->next)
    {
      int i;

      if (c->control_type == while_stepping_control)
	error (_("The 'while-stepping' command can "
		 "only be used for tracepoints"));

      for (i = 0; i < c->body_count; ++i)
	check_no_tracepoint_commands ((c->body_list)[i]);

      /* Not that command parsing removes leading whitespace and comment
	 lines and also empty lines.  So, we only need to check for
	 command directly.  */
      if (strstr (c->line, "collect ") == c->line)
	error (_("The 'collect' command can only be used for tracepoints"));

      if (strstr (c->line, "teval ") == c->line)
	error (_("The 'teval' command can only be used for tracepoints"));
    }
}

/* Encapsulate tests for different types of tracepoints.  */

static int
is_tracepoint_type (enum bptype type)
{
  return (type == bp_tracepoint
	  || type == bp_fast_tracepoint
	  || type == bp_static_tracepoint);
}

int
is_tracepoint (const struct breakpoint *b)
{
  return is_tracepoint_type (b->type);
}

/* A helper function that validates that COMMANDS are valid for a
   breakpoint.  This function will throw an exception if a problem is
   found.  */

static void
validate_commands_for_breakpoint (struct breakpoint *b,
				  struct command_line *commands)
{
  if (is_tracepoint (b))
    {
      struct tracepoint *t = (struct tracepoint *) b;
      struct command_line *c;
      struct command_line *while_stepping = 0;

      /* Reset the while-stepping step count.  The previous commands
         might have included a while-stepping action, while the new
         ones might not.  */
      t->step_count = 0;

      /* We need to verify that each top-level element of commands is
	 valid for tracepoints, that there's at most one
	 while-stepping element, and that the while-stepping's body
	 has valid tracing commands excluding nested while-stepping.
	 We also need to validate the tracepoint action line in the
	 context of the tracepoint --- validate_actionline actually
	 has side effects, like setting the tracepoint's
	 while-stepping STEP_COUNT, in addition to checking if the
	 collect/teval actions parse and make sense in the
	 tracepoint's context.  */
      for (c = commands; c; c = c->next)
	{
	  if (c->control_type == while_stepping_control)
	    {
	      if (b->type == bp_fast_tracepoint)
		error (_("The 'while-stepping' command "
			 "cannot be used for fast tracepoint"));
	      else if (b->type == bp_static_tracepoint)
		error (_("The 'while-stepping' command "
			 "cannot be used for static tracepoint"));

	      if (while_stepping)
		error (_("The 'while-stepping' command "
			 "can be used only once"));
	      else
		while_stepping = c;
	    }

	  validate_actionline (c->line, b);
	}
      if (while_stepping)
	{
	  struct command_line *c2;

	  gdb_assert (while_stepping->body_count == 1);
	  c2 = while_stepping->body_list[0];
	  for (; c2; c2 = c2->next)
	    {
	      if (c2->control_type == while_stepping_control)
		error (_("The 'while-stepping' command cannot be nested"));
	    }
	}
    }
  else
    {
      check_no_tracepoint_commands (commands);
    }
}

/* Return a vector of all the static tracepoints set at ADDR.  The
   caller is responsible for releasing the vector.  */

VEC(breakpoint_p) *
static_tracepoints_here (CORE_ADDR addr)
{
  struct breakpoint *b;
  VEC(breakpoint_p) *found = 0;
  struct bp_location *loc;

  ALL_BREAKPOINTS (b)
    if (b->type == bp_static_tracepoint)
      {
	for (loc = b->loc; loc; loc = loc->next)
	  if (loc->address == addr)
	    VEC_safe_push(breakpoint_p, found, b);
      }

  return found;
}

/* Set the command list of B to COMMANDS.  If breakpoint is tracepoint,
   validate that only allowed commands are included.  */

void
breakpoint_set_commands (struct breakpoint *b, 
			 struct command_line *commands)
{
  validate_commands_for_breakpoint (b, commands);

  decref_counted_command_line (&b->commands);
  b->commands = alloc_counted_command_line (commands);
  observer_notify_breakpoint_modified (b);
}

/* Set the internal `silent' flag on the breakpoint.  Note that this
   is not the same as the "silent" that may appear in the breakpoint's
   commands.  */

void
breakpoint_set_silent (struct breakpoint *b, int silent)
{
  int old_silent = b->silent;

  b->silent = silent;
  if (old_silent != silent)
    observer_notify_breakpoint_modified (b);
}

/* Set the thread for this breakpoint.  If THREAD is -1, make the
   breakpoint work for any thread.  */

void
breakpoint_set_thread (struct breakpoint *b, int thread)
{
  int old_thread = b->thread;

  b->thread = thread;
  if (old_thread != thread)
    observer_notify_breakpoint_modified (b);
}

/* Set the task for this breakpoint.  If TASK is 0, make the
   breakpoint work for any task.  */

void
breakpoint_set_task (struct breakpoint *b, int task)
{
  int old_task = b->task;

  b->task = task;
  if (old_task != task)
    observer_notify_breakpoint_modified (b);
}

void
check_tracepoint_command (char *line, void *closure)
{
  struct breakpoint *b = closure;

  validate_actionline (line, b);
}

/* A structure used to pass information through
   map_breakpoint_numbers.  */

struct commands_info
{
  /* True if the command was typed at a tty.  */
  int from_tty;

  /* The breakpoint range spec.  */
  char *arg;

  /* Non-NULL if the body of the commands are being read from this
     already-parsed command.  */
  struct command_line *control;

  /* The command lines read from the user, or NULL if they have not
     yet been read.  */
  struct counted_command_line *cmd;
};

/* A callback for map_breakpoint_numbers that sets the commands for
   commands_command.  */

static void
do_map_commands_command (struct breakpoint *b, void *data)
{
  struct commands_info *info = data;

  if (info->cmd == NULL)
    {
      struct command_line *l;

      if (info->control != NULL)
	l = copy_command_lines (info->control->body_list[0]);
      else
	{
	  struct cleanup *old_chain;
	  char *str;

	  str = xstrprintf (_("Type commands for breakpoint(s) "
			      "%s, one per line."),
			    info->arg);

	  old_chain = make_cleanup (xfree, str);

	  l = read_command_lines (str,
				  info->from_tty, 1,
				  (is_tracepoint (b)
				   ? check_tracepoint_command : 0),
				  b);

	  do_cleanups (old_chain);
	}

      info->cmd = alloc_counted_command_line (l);
    }

  /* If a breakpoint was on the list more than once, we don't need to
     do anything.  */
  if (b->commands != info->cmd)
    {
      validate_commands_for_breakpoint (b, info->cmd->commands);
      incref_counted_command_line (info->cmd);
      decref_counted_command_line (&b->commands);
      b->commands = info->cmd;
      observer_notify_breakpoint_modified (b);
    }
}

static void
commands_command_1 (char *arg, int from_tty, 
		    struct command_line *control)
{
  struct cleanup *cleanups;
  struct commands_info info;

  info.from_tty = from_tty;
  info.control = control;
  info.cmd = NULL;
  /* If we read command lines from the user, then `info' will hold an
     extra reference to the commands that we must clean up.  */
  cleanups = make_cleanup_decref_counted_command_line (&info.cmd);

  if (arg == NULL || !*arg)
    {
      if (breakpoint_count - prev_breakpoint_count > 1)
	arg = xstrprintf ("%d-%d", prev_breakpoint_count + 1, 
			  breakpoint_count);
      else if (breakpoint_count > 0)
	arg = xstrprintf ("%d", breakpoint_count);
      else
	{
	  /* So that we don't try to free the incoming non-NULL
	     argument in the cleanup below.  Mapping breakpoint
	     numbers will fail in this case.  */
	  arg = NULL;
	}
    }
  else
    /* The command loop has some static state, so we need to preserve
       our argument.  */
    arg = xstrdup (arg);

  if (arg != NULL)
    make_cleanup (xfree, arg);

  info.arg = arg;

  map_breakpoint_numbers (arg, do_map_commands_command, &info);

  if (info.cmd == NULL)
    error (_("No breakpoints specified."));

  do_cleanups (cleanups);
}

static void
commands_command (char *arg, int from_tty)
{
  commands_command_1 (arg, from_tty, NULL);
}

/* Like commands_command, but instead of reading the commands from
   input stream, takes them from an already parsed command structure.

   This is used by cli-script.c to DTRT with breakpoint commands
   that are part of if and while bodies.  */
enum command_control_type
commands_from_control_command (char *arg, struct command_line *cmd)
{
  commands_command_1 (arg, 0, cmd);
  return simple_control;
}

/* Return non-zero if BL->TARGET_INFO contains valid information.  */

static int
bp_location_has_shadow (struct bp_location *bl)
{
  if (bl->loc_type != bp_loc_software_breakpoint)
    return 0;
  if (!bl->inserted)
    return 0;
  if (bl->target_info.shadow_len == 0)
    /* BL isn't valid, or doesn't shadow memory.  */
    return 0;
  return 1;
}

/* Update BUF, which is LEN bytes read from the target address MEMADDR,
   by replacing any memory breakpoints with their shadowed contents.

   If READBUF is not NULL, this buffer must not overlap with any of
   the breakpoint location's shadow_contents buffers.  Otherwise,
   a failed assertion internal error will be raised.

   The range of shadowed area by each bp_location is:
     bl->address - bp_location_placed_address_before_address_max
     up to bl->address + bp_location_shadow_len_after_address_max
   The range we were requested to resolve shadows for is:
     memaddr ... memaddr + len
   Thus the safe cutoff boundaries for performance optimization are
     memaddr + len <= (bl->address
		       - bp_location_placed_address_before_address_max)
   and:
     bl->address + bp_location_shadow_len_after_address_max <= memaddr  */

void
breakpoint_xfer_memory (gdb_byte *readbuf, gdb_byte *writebuf,
			const gdb_byte *writebuf_org,
			ULONGEST memaddr, LONGEST len)
{
  /* Left boundary, right boundary and median element of our binary
     search.  */
  unsigned bc_l, bc_r, bc;

  /* Find BC_L which is a leftmost element which may affect BUF
     content.  It is safe to report lower value but a failure to
     report higher one.  */

  bc_l = 0;
  bc_r = bp_location_count;
  while (bc_l + 1 < bc_r)
    {
      struct bp_location *bl;

      bc = (bc_l + bc_r) / 2;
      bl = bp_location[bc];

      /* Check first BL->ADDRESS will not overflow due to the added
	 constant.  Then advance the left boundary only if we are sure
	 the BC element can in no way affect the BUF content (MEMADDR
	 to MEMADDR + LEN range).

	 Use the BP_LOCATION_SHADOW_LEN_AFTER_ADDRESS_MAX safety
	 offset so that we cannot miss a breakpoint with its shadow
	 range tail still reaching MEMADDR.  */

      if ((bl->address + bp_location_shadow_len_after_address_max
	   >= bl->address)
	  && (bl->address + bp_location_shadow_len_after_address_max
	      <= memaddr))
	bc_l = bc;
      else
	bc_r = bc;
    }

  /* Due to the binary search above, we need to make sure we pick the
     first location that's at BC_L's address.  E.g., if there are
     multiple locations at the same address, BC_L may end up pointing
     at a duplicate location, and miss the "master"/"inserted"
     location.  Say, given locations L1, L2 and L3 at addresses A and
     B:

      L1@@A, L2@@A, L3@@B, ...

     BC_L could end up pointing at location L2, while the "master"
     location could be L1.  Since the `loc->inserted' flag is only set
     on "master" locations, we'd forget to restore the shadow of L1
     and L2.  */
  while (bc_l > 0
	 && bp_location[bc_l]->address == bp_location[bc_l - 1]->address)
    bc_l--;

  /* Now do full processing of the found relevant range of elements.  */

  for (bc = bc_l; bc < bp_location_count; bc++)
  {
    struct bp_location *bl = bp_location[bc];
    CORE_ADDR bp_addr = 0;
    int bp_size = 0;
    int bptoffset = 0;

    /* bp_location array has BL->OWNER always non-NULL.  */
    if (bl->owner->type == bp_none)
      warning (_("reading through apparently deleted breakpoint #%d?"),
	       bl->owner->number);

    /* Performance optimization: any further element can no longer affect BUF
       content.  */

    if (bl->address >= bp_location_placed_address_before_address_max
        && memaddr + len <= (bl->address
			     - bp_location_placed_address_before_address_max))
      break;

    if (!bp_location_has_shadow (bl))
      continue;
    if (!breakpoint_address_match (bl->target_info.placed_address_space, 0,
				   current_program_space->aspace, 0))
      continue;

    /* Addresses and length of the part of the breakpoint that
       we need to copy.  */
    bp_addr = bl->target_info.placed_address;
    bp_size = bl->target_info.shadow_len;

    if (bp_addr + bp_size <= memaddr)
      /* The breakpoint is entirely before the chunk of memory we
         are reading.  */
      continue;

    if (bp_addr >= memaddr + len)
      /* The breakpoint is entirely after the chunk of memory we are
         reading.  */
      continue;

    /* Offset within shadow_contents.  */
    if (bp_addr < memaddr)
      {
	/* Only copy the second part of the breakpoint.  */
	bp_size -= memaddr - bp_addr;
	bptoffset = memaddr - bp_addr;
	bp_addr = memaddr;
      }

    if (bp_addr + bp_size > memaddr + len)
      {
	/* Only copy the first part of the breakpoint.  */
	bp_size -= (bp_addr + bp_size) - (memaddr + len);
      }

    if (readbuf != NULL)
      {
	/* Verify that the readbuf buffer does not overlap with
	   the shadow_contents buffer.  */
	gdb_assert (bl->target_info.shadow_contents >= readbuf + len
		    || readbuf >= (bl->target_info.shadow_contents
				   + bl->target_info.shadow_len));

	/* Update the read buffer with this inserted breakpoint's
	   shadow.  */
	memcpy (readbuf + bp_addr - memaddr,
		bl->target_info.shadow_contents + bptoffset, bp_size);
      }
    else
      {
	struct gdbarch *gdbarch = bl->gdbarch;
	const unsigned char *bp;
	CORE_ADDR placed_address = bl->target_info.placed_address;
	int placed_size = bl->target_info.placed_size;

	/* Update the shadow with what we want to write to memory.  */
	memcpy (bl->target_info.shadow_contents + bptoffset,
		writebuf_org + bp_addr - memaddr, bp_size);

	/* Determine appropriate breakpoint contents and size for this
	   address.  */
	bp = gdbarch_breakpoint_from_pc (gdbarch, &placed_address, &placed_size);

	/* Update the final write buffer with this inserted
	   breakpoint's INSN.  */
	memcpy (writebuf + bp_addr - memaddr, bp + bptoffset, bp_size);
      }
  }
}


/* Return true if BPT is either a software breakpoint or a hardware
   breakpoint.  */

int
is_breakpoint (const struct breakpoint *bpt)
{
  return (bpt->type == bp_breakpoint
	  || bpt->type == bp_hardware_breakpoint
	  || bpt->type == bp_dprintf);
}

/* Return true if BPT is of any hardware watchpoint kind.  */

static int
is_hardware_watchpoint (const struct breakpoint *bpt)
{
  return (bpt->type == bp_hardware_watchpoint
	  || bpt->type == bp_read_watchpoint
	  || bpt->type == bp_access_watchpoint);
}

/* Return true if BPT is of any watchpoint kind, hardware or
   software.  */

int
is_watchpoint (const struct breakpoint *bpt)
{
  return (is_hardware_watchpoint (bpt)
	  || bpt->type == bp_watchpoint);
}

/* Returns true if the current thread and its running state are safe
   to evaluate or update watchpoint B.  Watchpoints on local
   expressions need to be evaluated in the context of the thread that
   was current when the watchpoint was created, and, that thread needs
   to be stopped to be able to select the correct frame context.
   Watchpoints on global expressions can be evaluated on any thread,
   and in any state.  It is presently left to the target allowing
   memory accesses when threads are running.  */

static int
watchpoint_in_thread_scope (struct watchpoint *b)
{
  return (b->base.pspace == current_program_space
	  && (ptid_equal (b->watchpoint_thread, null_ptid)
	      || (ptid_equal (inferior_ptid, b->watchpoint_thread)
		  && !is_executing (inferior_ptid))));
}

/* Set watchpoint B to disp_del_at_next_stop, even including its possible
   associated bp_watchpoint_scope breakpoint.  */

static void
watchpoint_del_at_next_stop (struct watchpoint *w)
{
  struct breakpoint *b = &w->base;

  if (b->related_breakpoint != b)
    {
      gdb_assert (b->related_breakpoint->type == bp_watchpoint_scope);
      gdb_assert (b->related_breakpoint->related_breakpoint == b);
      b->related_breakpoint->disposition = disp_del_at_next_stop;
      b->related_breakpoint->related_breakpoint = b->related_breakpoint;
      b->related_breakpoint = b;
    }
  b->disposition = disp_del_at_next_stop;
}

/* Assuming that B is a watchpoint:
   - Reparse watchpoint expression, if REPARSE is non-zero
   - Evaluate expression and store the result in B->val
   - Evaluate the condition if there is one, and store the result
     in b->loc->cond.
   - Update the list of values that must be watched in B->loc.

   If the watchpoint disposition is disp_del_at_next_stop, then do
   nothing.  If this is local watchpoint that is out of scope, delete
   it.

   Even with `set breakpoint always-inserted on' the watchpoints are
   removed + inserted on each stop here.  Normal breakpoints must
   never be removed because they might be missed by a running thread
   when debugging in non-stop mode.  On the other hand, hardware
   watchpoints (is_hardware_watchpoint; processed here) are specific
   to each LWP since they are stored in each LWP's hardware debug
   registers.  Therefore, such LWP must be stopped first in order to
   be able to modify its hardware watchpoints.

   Hardware watchpoints must be reset exactly once after being
   presented to the user.  It cannot be done sooner, because it would
   reset the data used to present the watchpoint hit to the user.  And
   it must not be done later because it could display the same single
   watchpoint hit during multiple GDB stops.  Note that the latter is
   relevant only to the hardware watchpoint types bp_read_watchpoint
   and bp_access_watchpoint.  False hit by bp_hardware_watchpoint is
   not user-visible - its hit is suppressed if the memory content has
   not changed.

   The following constraints influence the location where we can reset
   hardware watchpoints:

   * target_stopped_by_watchpoint and target_stopped_data_address are
     called several times when GDB stops.

   [linux] 
   * Multiple hardware watchpoints can be hit at the same time,
     causing GDB to stop.  GDB only presents one hardware watchpoint
     hit at a time as the reason for stopping, and all the other hits
     are presented later, one after the other, each time the user
     requests the execution to be resumed.  Execution is not resumed
     for the threads still having pending hit event stored in
     LWP_INFO->STATUS.  While the watchpoint is already removed from
     the inferior on the first stop the thread hit event is kept being
     reported from its cached value by linux_nat_stopped_data_address
     until the real thread resume happens after the watchpoint gets
     presented and thus its LWP_INFO->STATUS gets reset.

   Therefore the hardware watchpoint hit can get safely reset on the
   watchpoint removal from inferior.  */

static void
update_watchpoint (struct watchpoint *b, int reparse)
{
  int within_current_scope;
  struct frame_id saved_frame_id;
  int frame_saved;

  /* If this is a local watchpoint, we only want to check if the
     watchpoint frame is in scope if the current thread is the thread
     that was used to create the watchpoint.  */
  if (!watchpoint_in_thread_scope (b))
    return;

  if (b->base.disposition == disp_del_at_next_stop)
    return;
 
  frame_saved = 0;

  /* Determine if the watchpoint is within scope.  */
  if (b->exp_valid_block == NULL)
    within_current_scope = 1;
  else
    {
      struct frame_info *fi = get_current_frame ();
      struct gdbarch *frame_arch = get_frame_arch (fi);
      CORE_ADDR frame_pc = get_frame_pc (fi);

      /* If we're in a function epilogue, unwinding may not work
	 properly, so do not attempt to recreate locations at this
	 point.  See similar comments in watchpoint_check.  */
      if (gdbarch_in_function_epilogue_p (frame_arch, frame_pc))
	return;

      /* Save the current frame's ID so we can restore it after
         evaluating the watchpoint expression on its own frame.  */
      /* FIXME drow/2003-09-09: It would be nice if evaluate_expression
         took a frame parameter, so that we didn't have to change the
         selected frame.  */
      frame_saved = 1;
      saved_frame_id = get_frame_id (get_selected_frame (NULL));

      fi = frame_find_by_id (b->watchpoint_frame);
      within_current_scope = (fi != NULL);
      if (within_current_scope)
	select_frame (fi);
    }

  /* We don't free locations.  They are stored in the bp_location array
     and update_global_location_list will eventually delete them and
     remove breakpoints if needed.  */
  b->base.loc = NULL;

  if (within_current_scope && reparse)
    {
      const char *s;

      if (b->exp)
	{
	  xfree (b->exp);
	  b->exp = NULL;
	}
      s = b->exp_string_reparse ? b->exp_string_reparse : b->exp_string;
      b->exp = parse_exp_1 (&s, 0, b->exp_valid_block, 0);
      /* If the meaning of expression itself changed, the old value is
	 no longer relevant.  We don't want to report a watchpoint hit
	 to the user when the old value and the new value may actually
	 be completely different objects.  */
      value_free (b->val);
      b->val = NULL;
      b->val_valid = 0;

      /* Note that unlike with breakpoints, the watchpoint's condition
	 expression is stored in the breakpoint object, not in the
	 locations (re)created below.  */
      if (b->base.cond_string != NULL)
	{
	  if (b->cond_exp != NULL)
	    {
	      xfree (b->cond_exp);
	      b->cond_exp = NULL;
	    }

	  s = b->base.cond_string;
	  b->cond_exp = parse_exp_1 (&s, 0, b->cond_exp_valid_block, 0);
	}
    }

  /* If we failed to parse the expression, for example because
     it refers to a global variable in a not-yet-loaded shared library,
     don't try to insert watchpoint.  We don't automatically delete
     such watchpoint, though, since failure to parse expression
     is different from out-of-scope watchpoint.  */
  if (!target_has_execution)
    {
      /* Without execution, memory can't change.  No use to try and
	 set watchpoint locations.  The watchpoint will be reset when
	 the target gains execution, through breakpoint_re_set.  */
      if (!can_use_hw_watchpoints)
	{
	  if (b->base.ops->works_in_software_mode (&b->base))
	    b->base.type = bp_watchpoint;
	  else
	    error (_("Software read/access watchpoints not supported."));
	}
    }
  else if (within_current_scope && b->exp)
    {
      int pc = 0;
      struct value *val_chain, *v, *result, *next;
      struct program_space *frame_pspace;

      fetch_subexp_value (b->exp, &pc, &v, &result, &val_chain, 0);

      /* Avoid setting b->val if it's already set.  The meaning of
	 b->val is 'the last value' user saw, and we should update
	 it only if we reported that last value to user.  As it
	 happens, the code that reports it updates b->val directly.
	 We don't keep track of the memory value for masked
	 watchpoints.  */
      if (!b->val_valid && !is_masked_watchpoint (&b->base))
	{
	  b->val = v;
	  b->val_valid = 1;
	}

      frame_pspace = get_frame_program_space (get_selected_frame (NULL));

      /* Look at each value on the value chain.  */
      for (v = val_chain; v; v = value_next (v))
	{
	  /* If it's a memory location, and GDB actually needed
	     its contents to evaluate the expression, then we
	     must watch it.  If the first value returned is
	     still lazy, that means an error occurred reading it;
	     watch it anyway in case it becomes readable.  */
	  if (VALUE_LVAL (v) == lval_memory
	      && (v == val_chain || ! value_lazy (v)))
	    {
	      struct type *vtype = check_typedef (value_type (v));

	      /* We only watch structs and arrays if user asked
		 for it explicitly, never if they just happen to
		 appear in the middle of some value chain.  */
	      if (v == result
		  || (TYPE_CODE (vtype) != TYPE_CODE_STRUCT
		      && TYPE_CODE (vtype) != TYPE_CODE_ARRAY))
		{
		  CORE_ADDR addr;
		  int type;
		  struct bp_location *loc, **tmp;

		  addr = value_address (v);
		  type = hw_write;
		  if (b->base.type == bp_read_watchpoint)
		    type = hw_read;
		  else if (b->base.type == bp_access_watchpoint)
		    type = hw_access;

		  loc = allocate_bp_location (&b->base);
		  for (tmp = &(b->base.loc); *tmp != NULL; tmp = &((*tmp)->next))
		    ;
		  *tmp = loc;
		  loc->gdbarch = get_type_arch (value_type (v));

		  loc->pspace = frame_pspace;
		  loc->address = addr;
		  loc->length = TYPE_LENGTH (value_type (v));
		  loc->watchpoint_type = type;
		}
	    }
	}

      /* Change the type of breakpoint between hardware assisted or
	 an ordinary watchpoint depending on the hardware support
	 and free hardware slots.  REPARSE is set when the inferior
	 is started.  */
      if (reparse)
	{
	  int reg_cnt;
	  enum bp_loc_type loc_type;
	  struct bp_location *bl;

	  reg_cnt = can_use_hardware_watchpoint (val_chain);

	  if (reg_cnt)
	    {
	      int i, target_resources_ok, other_type_used;
	      enum bptype type;

	      /* Use an exact watchpoint when there's only one memory region to be
		 watched, and only one debug register is needed to watch it.  */
	      b->exact = target_exact_watchpoints && reg_cnt == 1;

	      /* We need to determine how many resources are already
		 used for all other hardware watchpoints plus this one
		 to see if we still have enough resources to also fit
		 this watchpoint in as well.  */

	      /* If this is a software watchpoint, we try to turn it
		 to a hardware one -- count resources as if B was of
		 hardware watchpoint type.  */
	      type = b->base.type;
	      if (type == bp_watchpoint)
		type = bp_hardware_watchpoint;

	      /* This watchpoint may or may not have been placed on
		 the list yet at this point (it won't be in the list
		 if we're trying to create it for the first time,
		 through watch_command), so always account for it
		 manually.  */

	      /* Count resources used by all watchpoints except B.  */
	      i = hw_watchpoint_used_count_others (&b->base, type, &other_type_used);

	      /* Add in the resources needed for B.  */
	      i += hw_watchpoint_use_count (&b->base);

	      target_resources_ok
		= target_can_use_hardware_watchpoint (type, i, other_type_used);
	      if (target_resources_ok <= 0)
		{
		  int sw_mode = b->base.ops->works_in_software_mode (&b->base);

		  if (target_resources_ok == 0 && !sw_mode)
		    error (_("Target does not support this type of "
			     "hardware watchpoint."));
		  else if (target_resources_ok < 0 && !sw_mode)
		    error (_("There are not enough available hardware "
			     "resources for this watchpoint."));

		  /* Downgrade to software watchpoint.  */
		  b->base.type = bp_watchpoint;
		}
	      else
		{
		  /* If this was a software watchpoint, we've just
		     found we have enough resources to turn it to a
		     hardware watchpoint.  Otherwise, this is a
		     nop.  */
		  b->base.type = type;
		}
	    }
	  else if (!b->base.ops->works_in_software_mode (&b->base))
	    error (_("Expression cannot be implemented with "
		     "read/access watchpoint."));
	  else
	    b->base.type = bp_watchpoint;

	  loc_type = (b->base.type == bp_watchpoint? bp_loc_other
		      : bp_loc_hardware_watchpoint);
	  for (bl = b->base.loc; bl; bl = bl->next)
	    bl->loc_type = loc_type;
	}

      for (v = val_chain; v; v = next)
	{
	  next = value_next (v);
	  if (v != b->val)
	    value_free (v);
	}

      /* If a software watchpoint is not watching any memory, then the
	 above left it without any location set up.  But,
	 bpstat_stop_status requires a location to be able to report
	 stops, so make sure there's at least a dummy one.  */
      if (b->base.type == bp_watchpoint && b->base.loc == NULL)
	{
	  struct breakpoint *base = &b->base;
	  base->loc = allocate_bp_location (base);
	  base->loc->pspace = frame_pspace;
	  base->loc->address = -1;
	  base->loc->length = -1;
	  base->loc->watchpoint_type = -1;
	}
    }
  else if (!within_current_scope)
    {
      printf_filtered (_("\
Watchpoint %d deleted because the program has left the block\n\
in which its expression is valid.\n"),
		       b->base.number);
      watchpoint_del_at_next_stop (b);
    }

  /* Restore the selected frame.  */
  if (frame_saved)
    select_frame (frame_find_by_id (saved_frame_id));
}


/* Returns 1 iff breakpoint location should be
   inserted in the inferior.  We don't differentiate the type of BL's owner
   (breakpoint vs. tracepoint), although insert_location in tracepoint's
   breakpoint_ops is not defined, because in insert_bp_location,
   tracepoint's insert_location will not be called.  */
static int
should_be_inserted (struct bp_location *bl)
{
  if (bl->owner == NULL || !breakpoint_enabled (bl->owner))
    return 0;

  if (bl->owner->disposition == disp_del_at_next_stop)
    return 0;

  if (!bl->enabled || bl->shlib_disabled || bl->duplicate)
    return 0;

  if (user_breakpoint_p (bl->owner) && bl->pspace->executing_startup)
    return 0;

  /* This is set for example, when we're attached to the parent of a
     vfork, and have detached from the child.  The child is running
     free, and we expect it to do an exec or exit, at which point the
     OS makes the parent schedulable again (and the target reports
     that the vfork is done).  Until the child is done with the shared
     memory region, do not insert breakpoints in the parent, otherwise
     the child could still trip on the parent's breakpoints.  Since
     the parent is blocked anyway, it won't miss any breakpoint.  */
  if (bl->pspace->breakpoints_not_allowed)
    return 0;

  return 1;
}

/* Same as should_be_inserted but does the check assuming
   that the location is not duplicated.  */

static int
unduplicated_should_be_inserted (struct bp_location *bl)
{
  int result;
  const int save_duplicate = bl->duplicate;

  bl->duplicate = 0;
  result = should_be_inserted (bl);
  bl->duplicate = save_duplicate;
  return result;
}

/* Parses a conditional described by an expression COND into an
   agent expression bytecode suitable for evaluation
   by the bytecode interpreter.  Return NULL if there was
   any error during parsing.  */

static struct agent_expr *
parse_cond_to_aexpr (CORE_ADDR scope, struct expression *cond)
{
  struct agent_expr *aexpr = NULL;
  volatile struct gdb_exception ex;

  if (!cond)
    return NULL;

  /* We don't want to stop processing, so catch any errors
     that may show up.  */
  TRY_CATCH (ex, RETURN_MASK_ERROR)
    {
      aexpr = gen_eval_for_expr (scope, cond);
    }

  if (ex.reason < 0)
    {
      /* If we got here, it means the condition could not be parsed to a valid
	 bytecode expression and thus can't be evaluated on the target's side.
	 It's no use iterating through the conditions.  */
      return NULL;
    }

  /* We have a valid agent expression.  */
  return aexpr;
}

/* Based on location BL, create a list of breakpoint conditions to be
   passed on to the target.  If we have duplicated locations with different
   conditions, we will add such conditions to the list.  The idea is that the
   target will evaluate the list of conditions and will only notify GDB when
   one of them is true.  */

static void
build_target_condition_list (struct bp_location *bl)
{
  struct bp_location **locp = NULL, **loc2p;
  int null_condition_or_parse_error = 0;
  int modified = bl->needs_update;
  struct bp_location *loc;

  /* This is only meaningful if the target is
     evaluating conditions and if the user has
     opted for condition evaluation on the target's
     side.  */
  if (gdb_evaluates_breakpoint_condition_p ()
      || !target_supports_evaluation_of_breakpoint_conditions ())
    return;

  /* Do a first pass to check for locations with no assigned
     conditions or conditions that fail to parse to a valid agent expression
     bytecode.  If any of these happen, then it's no use to send conditions
     to the target since this location will always trigger and generate a
     response back to GDB.  */
  ALL_BP_LOCATIONS_AT_ADDR (loc2p, locp, bl->address)
    {
      loc = (*loc2p);
      if (is_breakpoint (loc->owner) && loc->pspace->num == bl->pspace->num)
	{
	  if (modified)
	    {
	      struct agent_expr *aexpr;

	      /* Re-parse the conditions since something changed.  In that
		 case we already freed the condition bytecodes (see
		 force_breakpoint_reinsertion).  We just
		 need to parse the condition to bytecodes again.  */
	      aexpr = parse_cond_to_aexpr (bl->address, loc->cond);
	      loc->cond_bytecode = aexpr;

	      /* Check if we managed to parse the conditional expression
		 correctly.  If not, we will not send this condition
		 to the target.  */
	      if (aexpr)
		continue;
	    }

	  /* If we have a NULL bytecode expression, it means something
	     went wrong or we have a null condition expression.  */
	  if (!loc->cond_bytecode)
	    {
	      null_condition_or_parse_error = 1;
	      break;
	    }
	}
    }

  /* If any of these happened, it means we will have to evaluate the conditions
     for the location's address on gdb's side.  It is no use keeping bytecodes
     for all the other duplicate locations, thus we free all of them here.

     This is so we have a finer control over which locations' conditions are
     being evaluated by GDB or the remote stub.  */
  if (null_condition_or_parse_error)
    {
      ALL_BP_LOCATIONS_AT_ADDR (loc2p, locp, bl->address)
	{
	  loc = (*loc2p);
	  if (is_breakpoint (loc->owner) && loc->pspace->num == bl->pspace->num)
	    {
	      /* Only go as far as the first NULL bytecode is
		 located.  */
	      if (!loc->cond_bytecode)
		return;

	      free_agent_expr (loc->cond_bytecode);
	      loc->cond_bytecode = NULL;
	    }
	}
    }

  /* No NULL conditions or failed bytecode generation.  Build a condition list
     for this location's address.  */
  ALL_BP_LOCATIONS_AT_ADDR (loc2p, locp, bl->address)
    {
      loc = (*loc2p);
      if (loc->cond
	  && is_breakpoint (loc->owner)
	  && loc->pspace->num == bl->pspace->num
	  && loc->owner->enable_state == bp_enabled
	  && loc->enabled)
	/* Add the condition to the vector.  This will be used later to send the
	   conditions to the target.  */
	VEC_safe_push (agent_expr_p, bl->target_info.conditions,
		       loc->cond_bytecode);
    }

  return;
}

/* Parses a command described by string CMD into an agent expression
   bytecode suitable for evaluation by the bytecode interpreter.
   Return NULL if there was any error during parsing.  */

static struct agent_expr *
parse_cmd_to_aexpr (CORE_ADDR scope, char *cmd)
{
  struct cleanup *old_cleanups = 0;
  struct expression *expr, **argvec;
  struct agent_expr *aexpr = NULL;
  volatile struct gdb_exception ex;
  const char *cmdrest;
  const char *format_start, *format_end;
  struct format_piece *fpieces;
  int nargs;
  struct gdbarch *gdbarch = get_current_arch ();

  if (!cmd)
    return NULL;

  cmdrest = cmd;

  if (*cmdrest == ',')
    ++cmdrest;
  cmdrest = skip_spaces_const (cmdrest);

  if (*cmdrest++ != '"')
    error (_("No format string following the location"));

  format_start = cmdrest;

  fpieces = parse_format_string (&cmdrest);

  old_cleanups = make_cleanup (free_format_pieces_cleanup, &fpieces);

  format_end = cmdrest;

  if (*cmdrest++ != '"')
    error (_("Bad format string, non-terminated '\"'."));
  
  cmdrest = skip_spaces_const (cmdrest);

  if (!(*cmdrest == ',' || *cmdrest == '\0'))
    error (_("Invalid argument syntax"));

  if (*cmdrest == ',')
    cmdrest++;
  cmdrest = skip_spaces_const (cmdrest);

  /* For each argument, make an expression.  */

  argvec = (struct expression **) alloca (strlen (cmd)
					 * sizeof (struct expression *));

  nargs = 0;
  while (*cmdrest != '\0')
    {
      const char *cmd1;

      cmd1 = cmdrest;
      expr = parse_exp_1 (&cmd1, scope, block_for_pc (scope), 1);
      argvec[nargs++] = expr;
      cmdrest = cmd1;
      if (*cmdrest == ',')
	++cmdrest;
    }

  /* We don't want to stop processing, so catch any errors
     that may show up.  */
  TRY_CATCH (ex, RETURN_MASK_ERROR)
    {
      aexpr = gen_printf (scope, gdbarch, 0, 0,
			  format_start, format_end - format_start,
			  fpieces, nargs, argvec);
    }

  do_cleanups (old_cleanups);

  if (ex.reason < 0)
    {
      /* If we got here, it means the command could not be parsed to a valid
	 bytecode expression and thus can't be evaluated on the target's side.
	 It's no use iterating through the other commands.  */
      return NULL;
    }

  /* We have a valid agent expression, return it.  */
  return aexpr;
}

/* Based on location BL, create a list of breakpoint commands to be
   passed on to the target.  If we have duplicated locations with
   different commands, we will add any such to the list.  */

static void
build_target_command_list (struct bp_location *bl)
{
  struct bp_location **locp = NULL, **loc2p;
  int null_command_or_parse_error = 0;
  int modified = bl->needs_update;
  struct bp_location *loc;

  /* For now, limit to agent-style dprintf breakpoints.  */
  if (bl->owner->type != bp_dprintf
      || strcmp (dprintf_style, dprintf_style_agent) != 0)
    return;

  if (!target_can_run_breakpoint_commands ())
    return;

  /* Do a first pass to check for locations with no assigned
     conditions or conditions that fail to parse to a valid agent expression
     bytecode.  If any of these happen, then it's no use to send conditions
     to the target since this location will always trigger and generate a
     response back to GDB.  */
  ALL_BP_LOCATIONS_AT_ADDR (loc2p, locp, bl->address)
    {
      loc = (*loc2p);
      if (is_breakpoint (loc->owner) && loc->pspace->num == bl->pspace->num)
	{
	  if (modified)
	    {
	      struct agent_expr *aexpr;

	      /* Re-parse the commands since something changed.  In that
		 case we already freed the command bytecodes (see
		 force_breakpoint_reinsertion).  We just
		 need to parse the command to bytecodes again.  */
	      aexpr = parse_cmd_to_aexpr (bl->address,
					  loc->owner->extra_string);
	      loc->cmd_bytecode = aexpr;

	      if (!aexpr)
		continue;
	    }

	  /* If we have a NULL bytecode expression, it means something
	     went wrong or we have a null command expression.  */
	  if (!loc->cmd_bytecode)
	    {
	      null_command_or_parse_error = 1;
	      break;
	    }
	}
    }

  /* If anything failed, then we're not doing target-side commands,
     and so clean up.  */
  if (null_command_or_parse_error)
    {
      ALL_BP_LOCATIONS_AT_ADDR (loc2p, locp, bl->address)
	{
	  loc = (*loc2p);
	  if (is_breakpoint (loc->owner)
	      && loc->pspace->num == bl->pspace->num)
	    {
	      /* Only go as far as the first NULL bytecode is
		 located.  */
	      if (loc->cmd_bytecode == NULL)
		return;

	      free_agent_expr (loc->cmd_bytecode);
	      loc->cmd_bytecode = NULL;
	    }
	}
    }

  /* No NULL commands or failed bytecode generation.  Build a command list
     for this location's address.  */
  ALL_BP_LOCATIONS_AT_ADDR (loc2p, locp, bl->address)
    {
      loc = (*loc2p);
      if (loc->owner->extra_string
	  && is_breakpoint (loc->owner)
	  && loc->pspace->num == bl->pspace->num
	  && loc->owner->enable_state == bp_enabled
	  && loc->enabled)
	/* Add the command to the vector.  This will be used later
	   to send the commands to the target.  */
	VEC_safe_push (agent_expr_p, bl->target_info.tcommands,
		       loc->cmd_bytecode);
    }

  bl->target_info.persist = 0;
  /* Maybe flag this location as persistent.  */
  if (bl->owner->type == bp_dprintf && disconnected_dprintf)
    bl->target_info.persist = 1;
}

/* Insert a low-level "breakpoint" of some type.  BL is the breakpoint
   location.  Any error messages are printed to TMP_ERROR_STREAM; and
   DISABLED_BREAKS, and HW_BREAKPOINT_ERROR are used to report problems.
   Returns 0 for success, 1 if the bp_location type is not supported or
   -1 for failure.

   NOTE drow/2003-09-09: This routine could be broken down to an
   object-style method for each breakpoint or catchpoint type.  */
static int
insert_bp_location (struct bp_location *bl,
		    struct ui_file *tmp_error_stream,
		    int *disabled_breaks,
		    int *hw_breakpoint_error,
		    int *hw_bp_error_explained_already)
{
  int val = 0;
  char *hw_bp_err_string = NULL;
  struct gdb_exception e;

  if (!should_be_inserted (bl) || (bl->inserted && !bl->needs_update))
    return 0;

  /* Note we don't initialize bl->target_info, as that wipes out
     the breakpoint location's shadow_contents if the breakpoint
     is still inserted at that location.  This in turn breaks
     target_read_memory which depends on these buffers when
     a memory read is requested at the breakpoint location:
     Once the target_info has been wiped, we fail to see that
     we have a breakpoint inserted at that address and thus
     read the breakpoint instead of returning the data saved in
     the breakpoint location's shadow contents.  */
  bl->target_info.placed_address = bl->address;
  bl->target_info.placed_address_space = bl->pspace->aspace;
  bl->target_info.length = bl->length;

  /* When working with target-side conditions, we must pass all the conditions
     for the same breakpoint address down to the target since GDB will not
     insert those locations.  With a list of breakpoint conditions, the target
     can decide when to stop and notify GDB.  */

  if (is_breakpoint (bl->owner))
    {
      build_target_condition_list (bl);
      build_target_command_list (bl);
      /* Reset the modification marker.  */
      bl->needs_update = 0;
    }

  if (bl->loc_type == bp_loc_software_breakpoint
      || bl->loc_type == bp_loc_hardware_breakpoint)
    {
      if (bl->owner->type != bp_hardware_breakpoint)
	{
	  /* If the explicitly specified breakpoint type
	     is not hardware breakpoint, check the memory map to see
	     if the breakpoint address is in read only memory or not.

	     Two important cases are:
	     - location type is not hardware breakpoint, memory
	     is readonly.  We change the type of the location to
	     hardware breakpoint.
	     - location type is hardware breakpoint, memory is
	     read-write.  This means we've previously made the
	     location hardware one, but then the memory map changed,
	     so we undo.
	     
	     When breakpoints are removed, remove_breakpoints will use
	     location types we've just set here, the only possible
	     problem is that memory map has changed during running
	     program, but it's not going to work anyway with current
	     gdb.  */
	  struct mem_region *mr 
	    = lookup_mem_region (bl->target_info.placed_address);
	  
	  if (mr)
	    {
	      if (automatic_hardware_breakpoints)
		{
		  enum bp_loc_type new_type;
		  
		  if (mr->attrib.mode != MEM_RW)
		    new_type = bp_loc_hardware_breakpoint;
		  else 
		    new_type = bp_loc_software_breakpoint;
		  
		  if (new_type != bl->loc_type)
		    {
		      static int said = 0;

		      bl->loc_type = new_type;
		      if (!said)
			{
			  fprintf_filtered (gdb_stdout,
					    _("Note: automatically using "
					      "hardware breakpoints for "
					      "read-only addresses.\n"));
			  said = 1;
			}
		    }
		}
	      else if (bl->loc_type == bp_loc_software_breakpoint
		       && mr->attrib.mode != MEM_RW)	    
		warning (_("cannot set software breakpoint "
			   "at readonly address %s"),
			 paddress (bl->gdbarch, bl->address));
	    }
	}
        
      /* First check to see if we have to handle an overlay.  */
      if (overlay_debugging == ovly_off
	  || bl->section == NULL
	  || !(section_is_overlay (bl->section)))
	{
	  /* No overlay handling: just set the breakpoint.  */
	  TRY_CATCH (e, RETURN_MASK_ALL)
	    {
	      val = bl->owner->ops->insert_location (bl);
	    }
	  if (e.reason < 0)
	    {
	      val = 1;
	      hw_bp_err_string = (char *) e.message;
	    }
	}
      else
	{
	  /* This breakpoint is in an overlay section.
	     Shall we set a breakpoint at the LMA?  */
	  if (!overlay_events_enabled)
	    {
	      /* Yes -- overlay event support is not active, 
		 so we must try to set a breakpoint at the LMA.
		 This will not work for a hardware breakpoint.  */
	      if (bl->loc_type == bp_loc_hardware_breakpoint)
		warning (_("hardware breakpoint %d not supported in overlay!"),
			 bl->owner->number);
	      else
		{
		  CORE_ADDR addr = overlay_unmapped_address (bl->address,
							     bl->section);
		  /* Set a software (trap) breakpoint at the LMA.  */
		  bl->overlay_target_info = bl->target_info;
		  bl->overlay_target_info.placed_address = addr;
		  val = target_insert_breakpoint (bl->gdbarch,
						  &bl->overlay_target_info);
		  if (val != 0)
		    fprintf_unfiltered (tmp_error_stream,
					"Overlay breakpoint %d "
					"failed: in ROM?\n",
					bl->owner->number);
		}
	    }
	  /* Shall we set a breakpoint at the VMA? */
	  if (section_is_mapped (bl->section))
	    {
	      /* Yes.  This overlay section is mapped into memory.  */
	      TRY_CATCH (e, RETURN_MASK_ALL)
	        {
	          val = bl->owner->ops->insert_location (bl);
	        }
	      if (e.reason < 0)
	        {
	          val = 1;
	          hw_bp_err_string = (char *) e.message;
	        }
	    }
	  else
	    {
	      /* No.  This breakpoint will not be inserted.  
		 No error, but do not mark the bp as 'inserted'.  */
	      return 0;
	    }
	}

      if (val)
	{
	  /* Can't set the breakpoint.  */
	  if (solib_name_from_address (bl->pspace, bl->address))
	    {
	      /* See also: disable_breakpoints_in_shlibs.  */
	      val = 0;
	      bl->shlib_disabled = 1;
	      observer_notify_breakpoint_modified (bl->owner);
	      if (!*disabled_breaks)
		{
		  fprintf_unfiltered (tmp_error_stream, 
				      "Cannot insert breakpoint %d.\n", 
				      bl->owner->number);
		  fprintf_unfiltered (tmp_error_stream, 
				      "Temporarily disabling shared "
				      "library breakpoints:\n");
		}
	      *disabled_breaks = 1;
	      fprintf_unfiltered (tmp_error_stream,
				  "breakpoint #%d\n", bl->owner->number);
	    }
	  else
	    {
	      if (bl->loc_type == bp_loc_hardware_breakpoint)
		{
                  *hw_breakpoint_error = 1;
                  *hw_bp_error_explained_already = hw_bp_err_string != NULL;
                  fprintf_unfiltered (tmp_error_stream,
                                      "Cannot insert hardware breakpoint %d%s",
                                      bl->owner->number, hw_bp_err_string ? ":" : ".\n");
                  if (hw_bp_err_string)
                    fprintf_unfiltered (tmp_error_stream, "%s.\n", hw_bp_err_string);
		}
	      else
		{
		  char *message = memory_error_message (TARGET_XFER_E_IO,
							bl->gdbarch, bl->address);
		  struct cleanup *old_chain = make_cleanup (xfree, message);

		  fprintf_unfiltered (tmp_error_stream, 
				      "Cannot insert breakpoint %d.\n"
				      "%s\n",
				      bl->owner->number, message);

		  do_cleanups (old_chain);
		}

	    }
	}
      else
	bl->inserted = 1;

      return val;
    }

  else if (bl->loc_type == bp_loc_hardware_watchpoint
	   /* NOTE drow/2003-09-08: This state only exists for removing
	      watchpoints.  It's not clear that it's necessary...  */
	   && bl->owner->disposition != disp_del_at_next_stop)
    {
      gdb_assert (bl->owner->ops != NULL
		  && bl->owner->ops->insert_location != NULL);

      val = bl->owner->ops->insert_location (bl);

      /* If trying to set a read-watchpoint, and it turns out it's not
	 supported, try emulating one with an access watchpoint.  */
      if (val == 1 && bl->watchpoint_type == hw_read)
	{
	  struct bp_location *loc, **loc_temp;

	  /* But don't try to insert it, if there's already another
	     hw_access location that would be considered a duplicate
	     of this one.  */
	  ALL_BP_LOCATIONS (loc, loc_temp)
	    if (loc != bl
		&& loc->watchpoint_type == hw_access
		&& watchpoint_locations_match (bl, loc))
	      {
		bl->duplicate = 1;
		bl->inserted = 1;
		bl->target_info = loc->target_info;
		bl->watchpoint_type = hw_access;
		val = 0;
		break;
	      }

	  if (val == 1)
	    {
	      bl->watchpoint_type = hw_access;
	      val = bl->owner->ops->insert_location (bl);

	      if (val)
		/* Back to the original value.  */
		bl->watchpoint_type = hw_read;
	    }
	}

      bl->inserted = (val == 0);
    }

  else if (bl->owner->type == bp_catchpoint)
    {
      gdb_assert (bl->owner->ops != NULL
		  && bl->owner->ops->insert_location != NULL);

      val = bl->owner->ops->insert_location (bl);
      if (val)
	{
	  bl->owner->enable_state = bp_disabled;

	  if (val == 1)
	    warning (_("\
Error inserting catchpoint %d: Your system does not support this type\n\
of catchpoint."), bl->owner->number);
	  else
	    warning (_("Error inserting catchpoint %d."), bl->owner->number);
	}

      bl->inserted = (val == 0);

      /* We've already printed an error message if there was a problem
	 inserting this catchpoint, and we've disabled the catchpoint,
	 so just return success.  */
      return 0;
    }

  return 0;
}

/* This function is called when program space PSPACE is about to be
   deleted.  It takes care of updating breakpoints to not reference
   PSPACE anymore.  */

void
breakpoint_program_space_exit (struct program_space *pspace)
{
  struct breakpoint *b, *b_temp;
  struct bp_location *loc, **loc_temp;

  /* Remove any breakpoint that was set through this program space.  */
  ALL_BREAKPOINTS_SAFE (b, b_temp)
    {
      if (b->pspace == pspace)
	delete_breakpoint (b);
    }

  /* Breakpoints set through other program spaces could have locations
     bound to PSPACE as well.  Remove those.  */
  ALL_BP_LOCATIONS (loc, loc_temp)
    {
      struct bp_location *tmp;

      if (loc->pspace == pspace)
	{
	  /* ALL_BP_LOCATIONS bp_location has LOC->OWNER always non-NULL.  */
	  if (loc->owner->loc == loc)
	    loc->owner->loc = loc->next;
	  else
	    for (tmp = loc->owner->loc; tmp->next != NULL; tmp = tmp->next)
	      if (tmp->next == loc)
		{
		  tmp->next = loc->next;
		  break;
		}
	}
    }

  /* Now update the global location list to permanently delete the
     removed locations above.  */
  update_global_location_list (0);
}

/* Make sure all breakpoints are inserted in inferior.
   Throws exception on any error.
   A breakpoint that is already inserted won't be inserted
   again, so calling this function twice is safe.  */
void
insert_breakpoints (void)
{
  struct breakpoint *bpt;

  ALL_BREAKPOINTS (bpt)
    if (is_hardware_watchpoint (bpt))
      {
	struct watchpoint *w = (struct watchpoint *) bpt;

	update_watchpoint (w, 0 /* don't reparse.  */);
      }

  update_global_location_list (1);

  /* update_global_location_list does not insert breakpoints when
     always_inserted_mode is not enabled.  Explicitly insert them
     now.  */
  if (!breakpoints_always_inserted_mode ())
    insert_breakpoint_locations ();
}

/* Invoke CALLBACK for each of bp_location.  */

void
iterate_over_bp_locations (walk_bp_location_callback callback)
{
  struct bp_location *loc, **loc_tmp;

  ALL_BP_LOCATIONS (loc, loc_tmp)
    {
      callback (loc, NULL);
    }
}

/* This is used when we need to synch breakpoint conditions between GDB and the
   target.  It is the case with deleting and disabling of breakpoints when using
   always-inserted mode.  */

static void
update_inserted_breakpoint_locations (void)
{
  struct bp_location *bl, **blp_tmp;
  int error_flag = 0;
  int val = 0;
  int disabled_breaks = 0;
  int hw_breakpoint_error = 0;
  int hw_bp_details_reported = 0;

  struct ui_file *tmp_error_stream = mem_fileopen ();
  struct cleanup *cleanups = make_cleanup_ui_file_delete (tmp_error_stream);

  /* Explicitly mark the warning -- this will only be printed if
     there was an error.  */
  fprintf_unfiltered (tmp_error_stream, "Warning:\n");

  save_current_space_and_thread ();

  ALL_BP_LOCATIONS (bl, blp_tmp)
    {
      /* We only want to update software breakpoints and hardware
	 breakpoints.  */
      if (!is_breakpoint (bl->owner))
	continue;

      /* We only want to update locations that are already inserted
	 and need updating.  This is to avoid unwanted insertion during
	 deletion of breakpoints.  */
      if (!bl->inserted || (bl->inserted && !bl->needs_update))
	continue;

      switch_to_program_space_and_thread (bl->pspace);

      /* For targets that support global breakpoints, there's no need
	 to select an inferior to insert breakpoint to.  In fact, even
	 if we aren't attached to any process yet, we should still
	 insert breakpoints.  */
      if (!gdbarch_has_global_breakpoints (target_gdbarch ())
	  && ptid_equal (inferior_ptid, null_ptid))
	continue;

      val = insert_bp_location (bl, tmp_error_stream, &disabled_breaks,
				    &hw_breakpoint_error, &hw_bp_details_reported);
      if (val)
	error_flag = val;
    }

  if (error_flag)
    {
      target_terminal_ours_for_output ();
      error_stream (tmp_error_stream);
    }

  do_cleanups (cleanups);
}

/* Used when starting or continuing the program.  */

static void
insert_breakpoint_locations (void)
{
  struct breakpoint *bpt;
  struct bp_location *bl, **blp_tmp;
  int error_flag = 0;
  int val = 0;
  int disabled_breaks = 0;
  int hw_breakpoint_error = 0;
  int hw_bp_error_explained_already = 0;

  struct ui_file *tmp_error_stream = mem_fileopen ();
  struct cleanup *cleanups = make_cleanup_ui_file_delete (tmp_error_stream);
  
  /* Explicitly mark the warning -- this will only be printed if
     there was an error.  */
  fprintf_unfiltered (tmp_error_stream, "Warning:\n");

  save_current_space_and_thread ();

  ALL_BP_LOCATIONS (bl, blp_tmp)
    {
      if (!should_be_inserted (bl) || (bl->inserted && !bl->needs_update))
	continue;

      /* There is no point inserting thread-specific breakpoints if
	 the thread no longer exists.  ALL_BP_LOCATIONS bp_location
	 has BL->OWNER always non-NULL.  */
      if (bl->owner->thread != -1
	  && !valid_thread_id (bl->owner->thread))
	continue;

      switch_to_program_space_and_thread (bl->pspace);

      /* For targets that support global breakpoints, there's no need
	 to select an inferior to insert breakpoint to.  In fact, even
	 if we aren't attached to any process yet, we should still
	 insert breakpoints.  */
      if (!gdbarch_has_global_breakpoints (target_gdbarch ())
	  && ptid_equal (inferior_ptid, null_ptid))
	continue;

      val = insert_bp_location (bl, tmp_error_stream, &disabled_breaks,
				    &hw_breakpoint_error, &hw_bp_error_explained_already);
      if (val)
	error_flag = val;
    }

  /* If we failed to insert all locations of a watchpoint, remove
     them, as half-inserted watchpoint is of limited use.  */
  ALL_BREAKPOINTS (bpt)  
    {
      int some_failed = 0;
      struct bp_location *loc;

      if (!is_hardware_watchpoint (bpt))
	continue;

      if (!breakpoint_enabled (bpt))
	continue;

      if (bpt->disposition == disp_del_at_next_stop)
	continue;
      
      for (loc = bpt->loc; loc; loc = loc->next)
	if (!loc->inserted && should_be_inserted (loc))
	  {
	    some_failed = 1;
	    break;
	  }
      if (some_failed)
	{
	  for (loc = bpt->loc; loc; loc = loc->next)
	    if (loc->inserted)
	      remove_breakpoint (loc, mark_uninserted);

	  hw_breakpoint_error = 1;
	  fprintf_unfiltered (tmp_error_stream,
			      "Could not insert hardware watchpoint %d.\n", 
			      bpt->number);
	  error_flag = -1;
	}
    }

  if (error_flag)
    {
      /* If a hardware breakpoint or watchpoint was inserted, add a
         message about possibly exhausted resources.  */
      if (hw_breakpoint_error && !hw_bp_error_explained_already)
	{
	  fprintf_unfiltered (tmp_error_stream, 
			      "Could not insert hardware breakpoints:\n\
You may have requested too many hardware breakpoints/watchpoints.\n");
	}
      target_terminal_ours_for_output ();
      error_stream (tmp_error_stream);
    }

  do_cleanups (cleanups);
}

/* Used when the program stops.
   Returns zero if successful, or non-zero if there was a problem
   removing a breakpoint location.  */

int
remove_breakpoints (void)
{
  struct bp_location *bl, **blp_tmp;
  int val = 0;

  ALL_BP_LOCATIONS (bl, blp_tmp)
  {
    if (bl->inserted && !is_tracepoint (bl->owner))
      val |= remove_breakpoint (bl, mark_uninserted);
  }
  return val;
}

/* When a thread exits, remove breakpoints that are related to
   that thread.  */

static void
remove_threaded_breakpoints (struct thread_info *tp, int silent)
{
  struct breakpoint *b, *b_tmp;

  ALL_BREAKPOINTS_SAFE (b, b_tmp)
    {
      if (b->thread == tp->num && user_breakpoint_p (b))
	{
	  b->disposition = disp_del_at_next_stop;

	  printf_filtered (_("\
Thread-specific breakpoint %d deleted - thread %d no longer in the thread list.\n"),
			  b->number, tp->num);

	  /* Hide it from the user.  */
	  b->number = 0;
       }
    }
}

/* Remove breakpoints of process PID.  */

int
remove_breakpoints_pid (int pid)
{
  struct bp_location *bl, **blp_tmp;
  int val;
  struct inferior *inf = find_inferior_pid (pid);

  ALL_BP_LOCATIONS (bl, blp_tmp)
  {
    if (bl->pspace != inf->pspace)
      continue;

    if (bl->owner->type == bp_dprintf)
      continue;

    if (bl->inserted)
      {
	val = remove_breakpoint (bl, mark_uninserted);
	if (val != 0)
	  return val;
      }
  }
  return 0;
}

int
reattach_breakpoints (int pid)
{
  struct cleanup *old_chain;
  struct bp_location *bl, **blp_tmp;
  int val;
  struct ui_file *tmp_error_stream;
  int dummy1 = 0, dummy2 = 0, dummy3 = 0;
  struct inferior *inf;
  struct thread_info *tp;

  tp = any_live_thread_of_process (pid);
  if (tp == NULL)
    return 1;

  inf = find_inferior_pid (pid);
  old_chain = save_inferior_ptid ();

  inferior_ptid = tp->ptid;

  tmp_error_stream = mem_fileopen ();
  make_cleanup_ui_file_delete (tmp_error_stream);

  ALL_BP_LOCATIONS (bl, blp_tmp)
  {
    if (bl->pspace != inf->pspace)
      continue;

    if (bl->inserted)
      {
	bl->inserted = 0;
	val = insert_bp_location (bl, tmp_error_stream, &dummy1, &dummy2, &dummy3);
	if (val != 0)
	  {
	    do_cleanups (old_chain);
	    return val;
	  }
      }
  }
  do_cleanups (old_chain);
  return 0;
}

static int internal_breakpoint_number = -1;

/* Set the breakpoint number of B, depending on the value of INTERNAL.
   If INTERNAL is non-zero, the breakpoint number will be populated
   from internal_breakpoint_number and that variable decremented.
   Otherwise the breakpoint number will be populated from
   breakpoint_count and that value incremented.  Internal breakpoints
   do not set the internal var bpnum.  */
static void
set_breakpoint_number (int internal, struct breakpoint *b)
{
  if (internal)
    b->number = internal_breakpoint_number--;
  else
    {
      set_breakpoint_count (breakpoint_count + 1);
      b->number = breakpoint_count;
    }
}

static struct breakpoint *
create_internal_breakpoint (struct gdbarch *gdbarch,
			    CORE_ADDR address, enum bptype type,
			    const struct breakpoint_ops *ops)
{
  struct symtab_and_line sal;
  struct breakpoint *b;

  init_sal (&sal);		/* Initialize to zeroes.  */

  sal.pc = address;
  sal.section = find_pc_overlay (sal.pc);
  sal.pspace = current_program_space;

  b = set_raw_breakpoint (gdbarch, sal, type, ops);
  b->number = internal_breakpoint_number--;
  b->disposition = disp_donttouch;

  return b;
}

static const char *const longjmp_names[] =
  {
    "longjmp", "_longjmp", "siglongjmp", "_siglongjmp"
  };
#define NUM_LONGJMP_NAMES ARRAY_SIZE(longjmp_names)

/* Per-objfile data private to breakpoint.c.  */
struct breakpoint_objfile_data
{
  /* Minimal symbol for "_ovly_debug_event" (if any).  */
  struct minimal_symbol *overlay_msym;

  /* Minimal symbol(s) for "longjmp", "siglongjmp", etc. (if any).  */
  struct minimal_symbol *longjmp_msym[NUM_LONGJMP_NAMES];

  /* True if we have looked for longjmp probes.  */
  int longjmp_searched;

  /* SystemTap probe points for longjmp (if any).  */
  VEC (probe_p) *longjmp_probes;

  /* Minimal symbol for "std::terminate()" (if any).  */
  struct minimal_symbol *terminate_msym;

  /* Minimal symbol for "_Unwind_DebugHook" (if any).  */
  struct minimal_symbol *exception_msym;

  /* True if we have looked for exception probes.  */
  int exception_searched;

  /* SystemTap probe points for unwinding (if any).  */
  VEC (probe_p) *exception_probes;
};

static const struct objfile_data *breakpoint_objfile_key;

/* Minimal symbol not found sentinel.  */
static struct minimal_symbol msym_not_found;

/* Returns TRUE if MSYM point to the "not found" sentinel.  */

static int
msym_not_found_p (const struct minimal_symbol *msym)
{
  return msym == &msym_not_found;
}

/* Return per-objfile data needed by breakpoint.c.
   Allocate the data if necessary.  */

static struct breakpoint_objfile_data *
get_breakpoint_objfile_data (struct objfile *objfile)
{
  struct breakpoint_objfile_data *bp_objfile_data;

  bp_objfile_data = objfile_data (objfile, breakpoint_objfile_key);
  if (bp_objfile_data == NULL)
    {
      bp_objfile_data = obstack_alloc (&objfile->objfile_obstack,
				       sizeof (*bp_objfile_data));

      memset (bp_objfile_data, 0, sizeof (*bp_objfile_data));
      set_objfile_data (objfile, breakpoint_objfile_key, bp_objfile_data);
    }
  return bp_objfile_data;
}

static void
free_breakpoint_probes (struct objfile *obj, void *data)
{
  struct breakpoint_objfile_data *bp_objfile_data = data;

  VEC_free (probe_p, bp_objfile_data->longjmp_probes);
  VEC_free (probe_p, bp_objfile_data->exception_probes);
}

static void
create_overlay_event_breakpoint (void)
{
  struct objfile *objfile;
  const char *const func_name = "_ovly_debug_event";

  ALL_OBJFILES (objfile)
    {
      struct breakpoint *b;
      struct breakpoint_objfile_data *bp_objfile_data;
      CORE_ADDR addr;

      bp_objfile_data = get_breakpoint_objfile_data (objfile);

      if (msym_not_found_p (bp_objfile_data->overlay_msym))
	continue;

      if (bp_objfile_data->overlay_msym == NULL)
	{
	  struct minimal_symbol *m;

	  m = lookup_minimal_symbol_text (func_name, objfile);
	  if (m == NULL)
	    {
	      /* Avoid future lookups in this objfile.  */
	      bp_objfile_data->overlay_msym = &msym_not_found;
	      continue;
	    }
	  bp_objfile_data->overlay_msym = m;
	}

      addr = SYMBOL_VALUE_ADDRESS (bp_objfile_data->overlay_msym);
      b = create_internal_breakpoint (get_objfile_arch (objfile), addr,
                                      bp_overlay_event,
				      &internal_breakpoint_ops);
      b->addr_string = xstrdup (func_name);

      if (overlay_debugging == ovly_auto)
        {
          b->enable_state = bp_enabled;
          overlay_events_enabled = 1;
        }
      else
       {
         b->enable_state = bp_disabled;
         overlay_events_enabled = 0;
       }
    }
  update_global_location_list (1);
}

static void
create_longjmp_master_breakpoint (void)
{
  struct program_space *pspace;
  struct cleanup *old_chain;

  old_chain = save_current_program_space ();

  ALL_PSPACES (pspace)
  {
    struct objfile *objfile;

    set_current_program_space (pspace);

    ALL_OBJFILES (objfile)
    {
      int i;
      struct gdbarch *gdbarch;
      struct breakpoint_objfile_data *bp_objfile_data;

      gdbarch = get_objfile_arch (objfile);
      if (!gdbarch_get_longjmp_target_p (gdbarch))
	continue;

      bp_objfile_data = get_breakpoint_objfile_data (objfile);

      if (!bp_objfile_data->longjmp_searched)
	{
	  VEC (probe_p) *ret;

	  ret = find_probes_in_objfile (objfile, "libc", "longjmp");
	  if (ret != NULL)
	    {
	      /* We are only interested in checking one element.  */
	      struct probe *p = VEC_index (probe_p, ret, 0);

	      if (!can_evaluate_probe_arguments (p))
		{
		  /* We cannot use the probe interface here, because it does
		     not know how to evaluate arguments.  */
		  VEC_free (probe_p, ret);
		  ret = NULL;
		}
	    }
	  bp_objfile_data->longjmp_probes = ret;
	  bp_objfile_data->longjmp_searched = 1;
	}

      if (bp_objfile_data->longjmp_probes != NULL)
	{
	  int i;
	  struct probe *probe;
	  struct gdbarch *gdbarch = get_objfile_arch (objfile);

	  for (i = 0;
	       VEC_iterate (probe_p,
			    bp_objfile_data->longjmp_probes,
			    i, probe);
	       ++i)
	    {
	      struct breakpoint *b;

	      b = create_internal_breakpoint (gdbarch, probe->address,
					      bp_longjmp_master,
					      &internal_breakpoint_ops);
	      b->addr_string = xstrdup ("-probe-stap libc:longjmp");
	      b->enable_state = bp_disabled;
	    }

	  continue;
	}

      for (i = 0; i < NUM_LONGJMP_NAMES; i++)
	{
	  struct breakpoint *b;
	  const char *func_name;
	  CORE_ADDR addr;

	  if (msym_not_found_p (bp_objfile_data->longjmp_msym[i]))
	    continue;

	  func_name = longjmp_names[i];
	  if (bp_objfile_data->longjmp_msym[i] == NULL)
	    {
	      struct minimal_symbol *m;

	      m = lookup_minimal_symbol_text (func_name, objfile);
	      if (m == NULL)
		{
		  /* Prevent future lookups in this objfile.  */
		  bp_objfile_data->longjmp_msym[i] = &msym_not_found;
		  continue;
		}
	      bp_objfile_data->longjmp_msym[i] = m;
	    }

	  addr = SYMBOL_VALUE_ADDRESS (bp_objfile_data->longjmp_msym[i]);
	  b = create_internal_breakpoint (gdbarch, addr, bp_longjmp_master,
					  &internal_breakpoint_ops);
	  b->addr_string = xstrdup (func_name);
	  b->enable_state = bp_disabled;
	}
    }
  }
  update_global_location_list (1);

  do_cleanups (old_chain);
}

/* Create a master std::terminate breakpoint.  */
static void
create_std_terminate_master_breakpoint (void)
{
  struct program_space *pspace;
  struct cleanup *old_chain;
  const char *const func_name = "std::terminate()";

  old_chain = save_current_program_space ();

  ALL_PSPACES (pspace)
  {
    struct objfile *objfile;
    CORE_ADDR addr;

    set_current_program_space (pspace);

    ALL_OBJFILES (objfile)
    {
      struct breakpoint *b;
      struct breakpoint_objfile_data *bp_objfile_data;

      bp_objfile_data = get_breakpoint_objfile_data (objfile);

      if (msym_not_found_p (bp_objfile_data->terminate_msym))
	continue;

      if (bp_objfile_data->terminate_msym == NULL)
	{
	  struct minimal_symbol *m;

	  m = lookup_minimal_symbol (func_name, NULL, objfile);
	  if (m == NULL || (MSYMBOL_TYPE (m) != mst_text
			    && MSYMBOL_TYPE (m) != mst_file_text))
	    {
	      /* Prevent future lookups in this objfile.  */
	      bp_objfile_data->terminate_msym = &msym_not_found;
	      continue;
	    }
	  bp_objfile_data->terminate_msym = m;
	}

      addr = SYMBOL_VALUE_ADDRESS (bp_objfile_data->terminate_msym);
      b = create_internal_breakpoint (get_objfile_arch (objfile), addr,
                                      bp_std_terminate_master,
				      &internal_breakpoint_ops);
      b->addr_string = xstrdup (func_name);
      b->enable_state = bp_disabled;
    }
  }

  update_global_location_list (1);

  do_cleanups (old_chain);
}

/* Install a master breakpoint on the unwinder's debug hook.  */

static void
create_exception_master_breakpoint (void)
{
  struct objfile *objfile;
  const char *const func_name = "_Unwind_DebugHook";

  ALL_OBJFILES (objfile)
    {
      struct breakpoint *b;
      struct gdbarch *gdbarch;
      struct breakpoint_objfile_data *bp_objfile_data;
      CORE_ADDR addr;

      bp_objfile_data = get_breakpoint_objfile_data (objfile);

      /* We prefer the SystemTap probe point if it exists.  */
      if (!bp_objfile_data->exception_searched)
	{
	  VEC (probe_p) *ret;

	  ret = find_probes_in_objfile (objfile, "libgcc", "unwind");

	  if (ret != NULL)
	    {
	      /* We are only interested in checking one element.  */
	      struct probe *p = VEC_index (probe_p, ret, 0);

	      if (!can_evaluate_probe_arguments (p))
		{
		  /* We cannot use the probe interface here, because it does
		     not know how to evaluate arguments.  */
		  VEC_free (probe_p, ret);
		  ret = NULL;
		}
	    }
	  bp_objfile_data->exception_probes = ret;
	  bp_objfile_data->exception_searched = 1;
	}

      if (bp_objfile_data->exception_probes != NULL)
	{
	  struct gdbarch *gdbarch = get_objfile_arch (objfile);
	  int i;
	  struct probe *probe;

	  for (i = 0;
	       VEC_iterate (probe_p,
			    bp_objfile_data->exception_probes,
			    i, probe);
	       ++i)
	    {
	      struct breakpoint *b;

	      b = create_internal_breakpoint (gdbarch, probe->address,
					      bp_exception_master,
					      &internal_breakpoint_ops);
	      b->addr_string = xstrdup ("-probe-stap libgcc:unwind");
	      b->enable_state = bp_disabled;
	    }

	  continue;
	}

      /* Otherwise, try the hook function.  */

      if (msym_not_found_p (bp_objfile_data->exception_msym))
	continue;

      gdbarch = get_objfile_arch (objfile);

      if (bp_objfile_data->exception_msym == NULL)
	{
	  struct minimal_symbol *debug_hook;

	  debug_hook = lookup_minimal_symbol (func_name, NULL, objfile);
	  if (debug_hook == NULL)
	    {
	      bp_objfile_data->exception_msym = &msym_not_found;
	      continue;
	    }

	  bp_objfile_data->exception_msym = debug_hook;
	}

      addr = SYMBOL_VALUE_ADDRESS (bp_objfile_data->exception_msym);
      addr = gdbarch_convert_from_func_ptr_addr (gdbarch, addr,
						 &current_target);
      b = create_internal_breakpoint (gdbarch, addr, bp_exception_master,
				      &internal_breakpoint_ops);
      b->addr_string = xstrdup (func_name);
      b->enable_state = bp_disabled;
    }

  update_global_location_list (1);
}

void
update_breakpoints_after_exec (void)
{
  struct breakpoint *b, *b_tmp;
  struct bp_location *bploc, **bplocp_tmp;

  /* We're about to delete breakpoints from GDB's lists.  If the
     INSERTED flag is true, GDB will try to lift the breakpoints by
     writing the breakpoints' "shadow contents" back into memory.  The
     "shadow contents" are NOT valid after an exec, so GDB should not
     do that.  Instead, the target is responsible from marking
     breakpoints out as soon as it detects an exec.  We don't do that
     here instead, because there may be other attempts to delete
     breakpoints after detecting an exec and before reaching here.  */
  ALL_BP_LOCATIONS (bploc, bplocp_tmp)
    if (bploc->pspace == current_program_space)
      gdb_assert (!bploc->inserted);

  ALL_BREAKPOINTS_SAFE (b, b_tmp)
  {
    if (b->pspace != current_program_space)
      continue;

    /* Solib breakpoints must be explicitly reset after an exec().  */
    if (b->type == bp_shlib_event)
      {
	delete_breakpoint (b);
	continue;
      }

    /* JIT breakpoints must be explicitly reset after an exec().  */
    if (b->type == bp_jit_event)
      {
	delete_breakpoint (b);
	continue;
      }

    /* Thread event breakpoints must be set anew after an exec(),
       as must overlay event and longjmp master breakpoints.  */
    if (b->type == bp_thread_event || b->type == bp_overlay_event
	|| b->type == bp_longjmp_master || b->type == bp_std_terminate_master
	|| b->type == bp_exception_master)
      {
	delete_breakpoint (b);
	continue;
      }

    /* Step-resume breakpoints are meaningless after an exec().  */
    if (b->type == bp_step_resume || b->type == bp_hp_step_resume)
      {
	delete_breakpoint (b);
	continue;
      }

    /* Longjmp and longjmp-resume breakpoints are also meaningless
       after an exec.  */
    if (b->type == bp_longjmp || b->type == bp_longjmp_resume
	|| b->type == bp_longjmp_call_dummy
	|| b->type == bp_exception || b->type == bp_exception_resume)
      {
	delete_breakpoint (b);
	continue;
      }

    if (b->type == bp_catchpoint)
      {
        /* For now, none of the bp_catchpoint breakpoints need to
           do anything at this point.  In the future, if some of
           the catchpoints need to something, we will need to add
           a new method, and call this method from here.  */
        continue;
      }

    /* bp_finish is a special case.  The only way we ought to be able
       to see one of these when an exec() has happened, is if the user
       caught a vfork, and then said "finish".  Ordinarily a finish just
       carries them to the call-site of the current callee, by setting
       a temporary bp there and resuming.  But in this case, the finish
       will carry them entirely through the vfork & exec.

       We don't want to allow a bp_finish to remain inserted now.  But
       we can't safely delete it, 'cause finish_command has a handle to
       the bp on a bpstat, and will later want to delete it.  There's a
       chance (and I've seen it happen) that if we delete the bp_finish
       here, that its storage will get reused by the time finish_command
       gets 'round to deleting the "use to be a bp_finish" breakpoint.
       We really must allow finish_command to delete a bp_finish.

       In the absence of a general solution for the "how do we know
       it's safe to delete something others may have handles to?"
       problem, what we'll do here is just uninsert the bp_finish, and
       let finish_command delete it.

       (We know the bp_finish is "doomed" in the sense that it's
       momentary, and will be deleted as soon as finish_command sees
       the inferior stopped.  So it doesn't matter that the bp's
       address is probably bogus in the new a.out, unlike e.g., the
       solib breakpoints.)  */

    if (b->type == bp_finish)
      {
	continue;
      }

    /* Without a symbolic address, we have little hope of the
       pre-exec() address meaning the same thing in the post-exec()
       a.out.  */
    if (b->addr_string == NULL)
      {
	delete_breakpoint (b);
	continue;
      }
  }
  /* FIXME what about longjmp breakpoints?  Re-create them here?  */
  create_overlay_event_breakpoint ();
  create_longjmp_master_breakpoint ();
  create_std_terminate_master_breakpoint ();
  create_exception_master_breakpoint ();
}

int
detach_breakpoints (ptid_t ptid)
{
  struct bp_location *bl, **blp_tmp;
  int val = 0;
  struct cleanup *old_chain = save_inferior_ptid ();
  struct inferior *inf = current_inferior ();

  if (ptid_get_pid (ptid) == ptid_get_pid (inferior_ptid))
    error (_("Cannot detach breakpoints of inferior_ptid"));

  /* Set inferior_ptid; remove_breakpoint_1 uses this global.  */
  inferior_ptid = ptid;
  ALL_BP_LOCATIONS (bl, blp_tmp)
  {
    if (bl->pspace != inf->pspace)
      continue;

    /* This function must physically remove breakpoints locations
       from the specified ptid, without modifying the breakpoint
       package's state.  Locations of type bp_loc_other are only
       maintained at GDB side.  So, there is no need to remove
       these bp_loc_other locations.  Moreover, removing these
       would modify the breakpoint package's state.  */
    if (bl->loc_type == bp_loc_other)
      continue;

    if (bl->inserted)
      val |= remove_breakpoint_1 (bl, mark_inserted);
  }

  /* Detach single-step breakpoints as well.  */
  detach_single_step_breakpoints ();

  do_cleanups (old_chain);
  return val;
}

/* Remove the breakpoint location BL from the current address space.
   Note that this is used to detach breakpoints from a child fork.
   When we get here, the child isn't in the inferior list, and neither
   do we have objects to represent its address space --- we should
   *not* look at bl->pspace->aspace here.  */

static int
remove_breakpoint_1 (struct bp_location *bl, insertion_state_t is)
{
  int val;

  /* BL is never in moribund_locations by our callers.  */
  gdb_assert (bl->owner != NULL);

  if (bl->owner->enable_state == bp_permanent)
    /* Permanent breakpoints cannot be inserted or removed.  */
    return 0;

  /* The type of none suggests that owner is actually deleted.
     This should not ever happen.  */
  gdb_assert (bl->owner->type != bp_none);

  if (bl->loc_type == bp_loc_software_breakpoint
      || bl->loc_type == bp_loc_hardware_breakpoint)
    {
      /* "Normal" instruction breakpoint: either the standard
	 trap-instruction bp (bp_breakpoint), or a
	 bp_hardware_breakpoint.  */

      /* First check to see if we have to handle an overlay.  */
      if (overlay_debugging == ovly_off
	  || bl->section == NULL
	  || !(section_is_overlay (bl->section)))
	{
	  /* No overlay handling: just remove the breakpoint.  */
	  val = bl->owner->ops->remove_location (bl);
	}
      else
	{
	  /* This breakpoint is in an overlay section.
	     Did we set a breakpoint at the LMA?  */
	  if (!overlay_events_enabled)
	      {
		/* Yes -- overlay event support is not active, so we
		   should have set a breakpoint at the LMA.  Remove it.  
		*/
		/* Ignore any failures: if the LMA is in ROM, we will
		   have already warned when we failed to insert it.  */
		if (bl->loc_type == bp_loc_hardware_breakpoint)
		  target_remove_hw_breakpoint (bl->gdbarch,
					       &bl->overlay_target_info);
		else
		  target_remove_breakpoint (bl->gdbarch,
					    &bl->overlay_target_info);
	      }
	  /* Did we set a breakpoint at the VMA? 
	     If so, we will have marked the breakpoint 'inserted'.  */
	  if (bl->inserted)
	    {
	      /* Yes -- remove it.  Previously we did not bother to
		 remove the breakpoint if the section had been
		 unmapped, but let's not rely on that being safe.  We
		 don't know what the overlay manager might do.  */

	      /* However, we should remove *software* breakpoints only
		 if the section is still mapped, or else we overwrite
		 wrong code with the saved shadow contents.  */
	      if (bl->loc_type == bp_loc_hardware_breakpoint
		  || section_is_mapped (bl->section))
		val = bl->owner->ops->remove_location (bl);
	      else
		val = 0;
	    }
	  else
	    {
	      /* No -- not inserted, so no need to remove.  No error.  */
	      val = 0;
	    }
	}

      /* In some cases, we might not be able to remove a breakpoint
	 in a shared library that has already been removed, but we
	 have not yet processed the shlib unload event.  */
      if (val && solib_name_from_address (bl->pspace, bl->address))
	val = 0;

      if (val)
	return val;
      bl->inserted = (is == mark_inserted);
    }
  else if (bl->loc_type == bp_loc_hardware_watchpoint)
    {
      gdb_assert (bl->owner->ops != NULL
		  && bl->owner->ops->remove_location != NULL);

      bl->inserted = (is == mark_inserted);
      bl->owner->ops->remove_location (bl);

      /* Failure to remove any of the hardware watchpoints comes here.  */
      if ((is == mark_uninserted) && (bl->inserted))
	warning (_("Could not remove hardware watchpoint %d."),
		 bl->owner->number);
    }
  else if (bl->owner->type == bp_catchpoint
           && breakpoint_enabled (bl->owner)
           && !bl->duplicate)
    {
      gdb_assert (bl->owner->ops != NULL
		  && bl->owner->ops->remove_location != NULL);

      val = bl->owner->ops->remove_location (bl);
      if (val)
	return val;

      bl->inserted = (is == mark_inserted);
    }

  return 0;
}

static int
remove_breakpoint (struct bp_location *bl, insertion_state_t is)
{
  int ret;
  struct cleanup *old_chain;

  /* BL is never in moribund_locations by our callers.  */
  gdb_assert (bl->owner != NULL);

  if (bl->owner->enable_state == bp_permanent)
    /* Permanent breakpoints cannot be inserted or removed.  */
    return 0;

  /* The type of none suggests that owner is actually deleted.
     This should not ever happen.  */
  gdb_assert (bl->owner->type != bp_none);

  old_chain = save_current_space_and_thread ();

  switch_to_program_space_and_thread (bl->pspace);

  ret = remove_breakpoint_1 (bl, is);

  do_cleanups (old_chain);
  return ret;
}

/* Clear the "inserted" flag in all breakpoints.  */

void
mark_breakpoints_out (void)
{
  struct bp_location *bl, **blp_tmp;

  ALL_BP_LOCATIONS (bl, blp_tmp)
    if (bl->pspace == current_program_space)
      bl->inserted = 0;
}

/* Clear the "inserted" flag in all breakpoints and delete any
   breakpoints which should go away between runs of the program.

   Plus other such housekeeping that has to be done for breakpoints
   between runs.

   Note: this function gets called at the end of a run (by
   generic_mourn_inferior) and when a run begins (by
   init_wait_for_inferior).  */



void
breakpoint_init_inferior (enum inf_context context)
{
  struct breakpoint *b, *b_tmp;
  struct bp_location *bl, **blp_tmp;
  int ix;
  struct program_space *pspace = current_program_space;

  /* If breakpoint locations are shared across processes, then there's
     nothing to do.  */
  if (gdbarch_has_global_breakpoints (target_gdbarch ()))
    return;

  ALL_BP_LOCATIONS (bl, blp_tmp)
  {
    /* ALL_BP_LOCATIONS bp_location has BL->OWNER always non-NULL.  */
    if (bl->pspace == pspace
	&& bl->owner->enable_state != bp_permanent)
      bl->inserted = 0;
  }

  ALL_BREAKPOINTS_SAFE (b, b_tmp)
  {
    if (b->loc && b->loc->pspace != pspace)
      continue;

    switch (b->type)
      {
      case bp_call_dummy:
      case bp_longjmp_call_dummy:

	/* If the call dummy breakpoint is at the entry point it will
	   cause problems when the inferior is rerun, so we better get
	   rid of it.  */

      case bp_watchpoint_scope:

	/* Also get rid of scope breakpoints.  */

      case bp_shlib_event:

	/* Also remove solib event breakpoints.  Their addresses may
	   have changed since the last time we ran the program.
	   Actually we may now be debugging against different target;
	   and so the solib backend that installed this breakpoint may
	   not be used in by the target.  E.g.,

	   (gdb) file prog-linux
	   (gdb) run               # native linux target
	   ...
	   (gdb) kill
	   (gdb) file prog-win.exe
	   (gdb) tar rem :9999     # remote Windows gdbserver.
	*/

      case bp_step_resume:

	/* Also remove step-resume breakpoints.  */

	delete_breakpoint (b);
	break;

      case bp_watchpoint:
      case bp_hardware_watchpoint:
      case bp_read_watchpoint:
      case bp_access_watchpoint:
	{
	  struct watchpoint *w = (struct watchpoint *) b;

	  /* Likewise for watchpoints on local expressions.  */
	  if (w->exp_valid_block != NULL)
	    delete_breakpoint (b);
	  else if (context == inf_starting)
	    {
	      /* Reset val field to force reread of starting value in
		 insert_breakpoints.  */
	      if (w->val)
		value_free (w->val);
	      w->val = NULL;
	      w->val_valid = 0;
	  }
	}
	break;
      default:
	break;
      }
  }

  /* Get rid of the moribund locations.  */
  for (ix = 0; VEC_iterate (bp_location_p, moribund_locations, ix, bl); ++ix)
    decref_bp_location (&bl);
  VEC_free (bp_location_p, moribund_locations);
}

/* These functions concern about actual breakpoints inserted in the
   target --- to e.g. check if we need to do decr_pc adjustment or if
   we need to hop over the bkpt --- so we check for address space
   match, not program space.  */

/* breakpoint_here_p (PC) returns non-zero if an enabled breakpoint
   exists at PC.  It returns ordinary_breakpoint_here if it's an
   ordinary breakpoint, or permanent_breakpoint_here if it's a
   permanent breakpoint.
   - When continuing from a location with an ordinary breakpoint, we
     actually single step once before calling insert_breakpoints.
   - When continuing from a location with a permanent breakpoint, we
     need to use the `SKIP_PERMANENT_BREAKPOINT' macro, provided by
     the target, to advance the PC past the breakpoint.  */

enum breakpoint_here
breakpoint_here_p (struct address_space *aspace, CORE_ADDR pc)
{
  struct bp_location *bl, **blp_tmp;
  int any_breakpoint_here = 0;

  ALL_BP_LOCATIONS (bl, blp_tmp)
    {
      if (bl->loc_type != bp_loc_software_breakpoint
	  && bl->loc_type != bp_loc_hardware_breakpoint)
	continue;

      /* ALL_BP_LOCATIONS bp_location has BL->OWNER always non-NULL.  */
      if ((breakpoint_enabled (bl->owner)
	   || bl->owner->enable_state == bp_permanent)
	  && breakpoint_location_address_match (bl, aspace, pc))
	{
	  if (overlay_debugging 
	      && section_is_overlay (bl->section)
	      && !section_is_mapped (bl->section))
	    continue;		/* unmapped overlay -- can't be a match */
	  else if (bl->owner->enable_state == bp_permanent)
	    return permanent_breakpoint_here;
	  else
	    any_breakpoint_here = 1;
	}
    }

  return any_breakpoint_here ? ordinary_breakpoint_here : 0;
}

/* Return true if there's a moribund breakpoint at PC.  */

int
moribund_breakpoint_here_p (struct address_space *aspace, CORE_ADDR pc)
{
  struct bp_location *loc;
  int ix;

  for (ix = 0; VEC_iterate (bp_location_p, moribund_locations, ix, loc); ++ix)
    if (breakpoint_location_address_match (loc, aspace, pc))
      return 1;

  return 0;
}

/* Returns non-zero if there's a breakpoint inserted at PC, which is
   inserted using regular breakpoint_chain / bp_location array
   mechanism.  This does not check for single-step breakpoints, which
   are inserted and removed using direct target manipulation.  */

int
regular_breakpoint_inserted_here_p (struct address_space *aspace, 
				    CORE_ADDR pc)
{
  struct bp_location *bl, **blp_tmp;

  ALL_BP_LOCATIONS (bl, blp_tmp)
    {
      if (bl->loc_type != bp_loc_software_breakpoint
	  && bl->loc_type != bp_loc_hardware_breakpoint)
	continue;

      if (bl->inserted
	  && breakpoint_location_address_match (bl, aspace, pc))
	{
	  if (overlay_debugging 
	      && section_is_overlay (bl->section)
	      && !section_is_mapped (bl->section))
	    continue;		/* unmapped overlay -- can't be a match */
	  else
	    return 1;
	}
    }
  return 0;
}

/* Returns non-zero iff there's either regular breakpoint
   or a single step breakpoint inserted at PC.  */

int
breakpoint_inserted_here_p (struct address_space *aspace, CORE_ADDR pc)
{
  if (regular_breakpoint_inserted_here_p (aspace, pc))
    return 1;

  if (single_step_breakpoint_inserted_here_p (aspace, pc))
    return 1;

  return 0;
}

/* This function returns non-zero iff there is a software breakpoint
   inserted at PC.  */

int
software_breakpoint_inserted_here_p (struct address_space *aspace,
				     CORE_ADDR pc)
{
  struct bp_location *bl, **blp_tmp;

  ALL_BP_LOCATIONS (bl, blp_tmp)
    {
      if (bl->loc_type != bp_loc_software_breakpoint)
	continue;

      if (bl->inserted
	  && breakpoint_address_match (bl->pspace->aspace, bl->address,
				       aspace, pc))
	{
	  if (overlay_debugging 
	      && section_is_overlay (bl->section)
	      && !section_is_mapped (bl->section))
	    continue;		/* unmapped overlay -- can't be a match */
	  else
	    return 1;
	}
    }

  /* Also check for software single-step breakpoints.  */
  if (single_step_breakpoint_inserted_here_p (aspace, pc))
    return 1;

  return 0;
}

int
hardware_watchpoint_inserted_in_range (struct address_space *aspace,
				       CORE_ADDR addr, ULONGEST len)
{
  struct breakpoint *bpt;

  ALL_BREAKPOINTS (bpt)
    {
      struct bp_location *loc;

      if (bpt->type != bp_hardware_watchpoint
	  && bpt->type != bp_access_watchpoint)
	continue;

      if (!breakpoint_enabled (bpt))
	continue;

      for (loc = bpt->loc; loc; loc = loc->next)
	if (loc->pspace->aspace == aspace && loc->inserted)
	  {
	    CORE_ADDR l, h;

	    /* Check for intersection.  */
	    l = max (loc->address, addr);
	    h = min (loc->address + loc->length, addr + len);
	    if (l < h)
	      return 1;
	  }
    }
  return 0;
}

/* breakpoint_thread_match (PC, PTID) returns true if the breakpoint at
   PC is valid for process/thread PTID.  */

int
breakpoint_thread_match (struct address_space *aspace, CORE_ADDR pc,
			 ptid_t ptid)
{
  struct bp_location *bl, **blp_tmp;
  /* The thread and task IDs associated to PTID, computed lazily.  */
  int thread = -1;
  int task = 0;
  
  ALL_BP_LOCATIONS (bl, blp_tmp)
    {
      if (bl->loc_type != bp_loc_software_breakpoint
	  && bl->loc_type != bp_loc_hardware_breakpoint)
	continue;

      /* ALL_BP_LOCATIONS bp_location has bl->OWNER always non-NULL.  */
      if (!breakpoint_enabled (bl->owner)
	  && bl->owner->enable_state != bp_permanent)
	continue;

      if (!breakpoint_location_address_match (bl, aspace, pc))
	continue;

      if (bl->owner->thread != -1)
	{
	  /* This is a thread-specific breakpoint.  Check that ptid
	     matches that thread.  If thread hasn't been computed yet,
	     it is now time to do so.  */
	  if (thread == -1)
	    thread = pid_to_thread_id (ptid);
	  if (bl->owner->thread != thread)
	    continue;
	}

      if (bl->owner->task != 0)
        {
	  /* This is a task-specific breakpoint.  Check that ptid
	     matches that task.  If task hasn't been computed yet,
	     it is now time to do so.  */
	  if (task == 0)
	    task = ada_get_task_number (ptid);
	  if (bl->owner->task != task)
	    continue;
        }

      if (overlay_debugging 
	  && section_is_overlay (bl->section)
	  && !section_is_mapped (bl->section))
	continue;	    /* unmapped overlay -- can't be a match */

      return 1;
    }

  return 0;
}


/* bpstat stuff.  External routines' interfaces are documented
   in breakpoint.h.  */

int
is_catchpoint (struct breakpoint *ep)
{
  return (ep->type == bp_catchpoint);
}

/* Frees any storage that is part of a bpstat.  Does not walk the
   'next' chain.  */

static void
bpstat_free (bpstat bs)
{
  if (bs->old_val != NULL)
    value_free (bs->old_val);
  decref_counted_command_line (&bs->commands);
  decref_bp_location (&bs->bp_location_at);
  xfree (bs);
}

/* Clear a bpstat so that it says we are not at any breakpoint.
   Also free any storage that is part of a bpstat.  */

void
bpstat_clear (bpstat *bsp)
{
  bpstat p;
  bpstat q;

  if (bsp == 0)
    return;
  p = *bsp;
  while (p != NULL)
    {
      q = p->next;
      bpstat_free (p);
      p = q;
    }
  *bsp = NULL;
}

/* Return a copy of a bpstat.  Like "bs1 = bs2" but all storage that
   is part of the bpstat is copied as well.  */

bpstat
bpstat_copy (bpstat bs)
{
  bpstat p = NULL;
  bpstat tmp;
  bpstat retval = NULL;

  if (bs == NULL)
    return bs;

  for (; bs != NULL; bs = bs->next)
    {
      tmp = (bpstat) xmalloc (sizeof (*tmp));
      memcpy (tmp, bs, sizeof (*tmp));
      incref_counted_command_line (tmp->commands);
      incref_bp_location (tmp->bp_location_at);
      if (bs->old_val != NULL)
	{
	  tmp->old_val = value_copy (bs->old_val);
	  release_value (tmp->old_val);
	}

      if (p == NULL)
	/* This is the first thing in the chain.  */
	retval = tmp;
      else
	p->next = tmp;
      p = tmp;
    }
  p->next = NULL;
  return retval;
}

/* Find the bpstat associated with this breakpoint.  */

bpstat
bpstat_find_breakpoint (bpstat bsp, struct breakpoint *breakpoint)
{
  if (bsp == NULL)
    return NULL;

  for (; bsp != NULL; bsp = bsp->next)
    {
      if (bsp->breakpoint_at == breakpoint)
	return bsp;
    }
  return NULL;
}

/* See breakpoint.h.  */

enum bpstat_signal_value
bpstat_explains_signal (bpstat bsp, enum gdb_signal sig)
{
  enum bpstat_signal_value result = BPSTAT_SIGNAL_NO;

  for (; bsp != NULL; bsp = bsp->next)
    {
      /* Ensure that, if we ever entered this loop, then we at least
	 return BPSTAT_SIGNAL_HIDE.  */
      enum bpstat_signal_value newval;

      if (bsp->breakpoint_at == NULL)
	{
	  /* A moribund location can never explain a signal other than
	     GDB_SIGNAL_TRAP.  */
	  if (sig == GDB_SIGNAL_TRAP)
	    newval = BPSTAT_SIGNAL_HIDE;
	  else
	    newval = BPSTAT_SIGNAL_NO;
	}
      else
	newval = bsp->breakpoint_at->ops->explains_signal (bsp->breakpoint_at,
							   sig);

      if (newval > result)
	result = newval;
    }

  return result;
}

/* Put in *NUM the breakpoint number of the first breakpoint we are
   stopped at.  *BSP upon return is a bpstat which points to the
   remaining breakpoints stopped at (but which is not guaranteed to be
   good for anything but further calls to bpstat_num).

   Return 0 if passed a bpstat which does not indicate any breakpoints.
   Return -1 if stopped at a breakpoint that has been deleted since
   we set it.
   Return 1 otherwise.  */

int
bpstat_num (bpstat *bsp, int *num)
{
  struct breakpoint *b;

  if ((*bsp) == NULL)
    return 0;			/* No more breakpoint values */

  /* We assume we'll never have several bpstats that correspond to a
     single breakpoint -- otherwise, this function might return the
     same number more than once and this will look ugly.  */
  b = (*bsp)->breakpoint_at;
  *bsp = (*bsp)->next;
  if (b == NULL)
    return -1;			/* breakpoint that's been deleted since */

  *num = b->number;		/* We have its number */
  return 1;
}

/* See breakpoint.h.  */

void
bpstat_clear_actions (void)
{
  struct thread_info *tp;
  bpstat bs;

  if (ptid_equal (inferior_ptid, null_ptid))
    return;

  tp = find_thread_ptid (inferior_ptid);
  if (tp == NULL)
    return;

  for (bs = tp->control.stop_bpstat; bs != NULL; bs = bs->next)
    {
      decref_counted_command_line (&bs->commands);

      if (bs->old_val != NULL)
	{
	  value_free (bs->old_val);
	  bs->old_val = NULL;
	}
    }
}

/* Called when a command is about to proceed the inferior.  */

static void
breakpoint_about_to_proceed (void)
{
  if (!ptid_equal (inferior_ptid, null_ptid))
    {
      struct thread_info *tp = inferior_thread ();

      /* Allow inferior function calls in breakpoint commands to not
	 interrupt the command list.  When the call finishes
	 successfully, the inferior will be standing at the same
	 breakpoint as if nothing happened.  */
      if (tp->control.in_infcall)
	return;
    }

  breakpoint_proceeded = 1;
}

/* Stub for cleaning up our state if we error-out of a breakpoint
   command.  */
static void
cleanup_executing_breakpoints (void *ignore)
{
  executing_breakpoint_commands = 0;
}

/* Return non-zero iff CMD as the first line of a command sequence is `silent'
   or its equivalent.  */

static int
command_line_is_silent (struct command_line *cmd)
{
  return cmd && (strcmp ("silent", cmd->line) == 0
		 || (xdb_commands && strcmp ("Q", cmd->line) == 0));
}

/* Execute all the commands associated with all the breakpoints at
   this location.  Any of these commands could cause the process to
   proceed beyond this point, etc.  We look out for such changes by
   checking the global "breakpoint_proceeded" after each command.

   Returns true if a breakpoint command resumed the inferior.  In that
   case, it is the caller's responsibility to recall it again with the
   bpstat of the current thread.  */

static int
bpstat_do_actions_1 (bpstat *bsp)
{
  bpstat bs;
  struct cleanup *old_chain;
  int again = 0;

  /* Avoid endless recursion if a `source' command is contained
     in bs->commands.  */
  if (executing_breakpoint_commands)
    return 0;

  executing_breakpoint_commands = 1;
  old_chain = make_cleanup (cleanup_executing_breakpoints, 0);

  prevent_dont_repeat ();

  /* This pointer will iterate over the list of bpstat's.  */
  bs = *bsp;

  breakpoint_proceeded = 0;
  for (; bs != NULL; bs = bs->next)
    {
      struct counted_command_line *ccmd;
      struct command_line *cmd;
      struct cleanup *this_cmd_tree_chain;

      /* Take ownership of the BSP's command tree, if it has one.

         The command tree could legitimately contain commands like
         'step' and 'next', which call clear_proceed_status, which
         frees stop_bpstat's command tree.  To make sure this doesn't
         free the tree we're executing out from under us, we need to
         take ownership of the tree ourselves.  Since a given bpstat's
         commands are only executed once, we don't need to copy it; we
         can clear the pointer in the bpstat, and make sure we free
         the tree when we're done.  */
      ccmd = bs->commands;
      bs->commands = NULL;
      this_cmd_tree_chain = make_cleanup_decref_counted_command_line (&ccmd);
      cmd = ccmd ? ccmd->commands : NULL;
      if (command_line_is_silent (cmd))
	{
	  /* The action has been already done by bpstat_stop_status.  */
	  cmd = cmd->next;
	}

      while (cmd != NULL)
	{
	  execute_control_command (cmd);

	  if (breakpoint_proceeded)
	    break;
	  else
	    cmd = cmd->next;
	}

      /* We can free this command tree now.  */
      do_cleanups (this_cmd_tree_chain);

      if (breakpoint_proceeded)
	{
	  if (target_can_async_p ())
	    /* If we are in async mode, then the target might be still
	       running, not stopped at any breakpoint, so nothing for
	       us to do here -- just return to the event loop.  */
	    ;
	  else
	    /* In sync mode, when execute_control_command returns
	       we're already standing on the next breakpoint.
	       Breakpoint commands for that stop were not run, since
	       execute_command does not run breakpoint commands --
	       only command_line_handler does, but that one is not
	       involved in execution of breakpoint commands.  So, we
	       can now execute breakpoint commands.  It should be
	       noted that making execute_command do bpstat actions is
	       not an option -- in this case we'll have recursive
	       invocation of bpstat for each breakpoint with a
	       command, and can easily blow up GDB stack.  Instead, we
	       return true, which will trigger the caller to recall us
	       with the new stop_bpstat.  */
	    again = 1;
	  break;
	}
    }
  do_cleanups (old_chain);
  return again;
}

void
bpstat_do_actions (void)
{
  struct cleanup *cleanup_if_error = make_bpstat_clear_actions_cleanup ();

  /* Do any commands attached to breakpoint we are stopped at.  */
  while (!ptid_equal (inferior_ptid, null_ptid)
	 && target_has_execution
	 && !is_exited (inferior_ptid)
	 && !is_executing (inferior_ptid))
    /* Since in sync mode, bpstat_do_actions may resume the inferior,
       and only return when it is stopped at the next breakpoint, we
       keep doing breakpoint actions until it returns false to
       indicate the inferior was not resumed.  */
    if (!bpstat_do_actions_1 (&inferior_thread ()->control.stop_bpstat))
      break;

  discard_cleanups (cleanup_if_error);
}

/* Print out the (old or new) value associated with a watchpoint.  */

static void
watchpoint_value_print (struct value *val, struct ui_file *stream)
{
  if (val == NULL)
    fprintf_unfiltered (stream, _("<unreadable>"));
  else
    {
      struct value_print_options opts;
      get_user_print_options (&opts);
      value_print (val, stream, &opts);
    }
}

/* Generic routine for printing messages indicating why we
   stopped.  The behavior of this function depends on the value
   'print_it' in the bpstat structure.  Under some circumstances we
   may decide not to print anything here and delegate the task to
   normal_stop().  */

static enum print_stop_action
print_bp_stop_message (bpstat bs)
{
  switch (bs->print_it)
    {
    case print_it_noop:
      /* Nothing should be printed for this bpstat entry.  */
      return PRINT_UNKNOWN;
      break;

    case print_it_done:
      /* We still want to print the frame, but we already printed the
         relevant messages.  */
      return PRINT_SRC_AND_LOC;
      break;

    case print_it_normal:
      {
	struct breakpoint *b = bs->breakpoint_at;

	/* bs->breakpoint_at can be NULL if it was a momentary breakpoint
	   which has since been deleted.  */
	if (b == NULL)
	  return PRINT_UNKNOWN;

	/* Normal case.  Call the breakpoint's print_it method.  */
	return b->ops->print_it (bs);
      }
      break;

    default:
      internal_error (__FILE__, __LINE__,
		      _("print_bp_stop_message: unrecognized enum value"));
      break;
    }
}

/* A helper function that prints a shared library stopped event.  */

static void
print_solib_event (int is_catchpoint)
{
  int any_deleted
    = !VEC_empty (char_ptr, current_program_space->deleted_solibs);
  int any_added
    = !VEC_empty (so_list_ptr, current_program_space->added_solibs);

  if (!is_catchpoint)
    {
      if (any_added || any_deleted)
	ui_out_text (current_uiout,
		     _("Stopped due to shared library event:\n"));
      else
	ui_out_text (current_uiout,
		     _("Stopped due to shared library event (no "
		       "libraries added or removed)\n"));
    }

  if (ui_out_is_mi_like_p (current_uiout))
    ui_out_field_string (current_uiout, "reason",
			 async_reason_lookup (EXEC_ASYNC_SOLIB_EVENT));

  if (any_deleted)
    {
      struct cleanup *cleanup;
      char *name;
      int ix;

      ui_out_text (current_uiout, _("  Inferior unloaded "));
      cleanup = make_cleanup_ui_out_list_begin_end (current_uiout,
						    "removed");
      for (ix = 0;
	   VEC_iterate (char_ptr, current_program_space->deleted_solibs,
			ix, name);
	   ++ix)
	{
	  if (ix > 0)
	    ui_out_text (current_uiout, "    ");
	  ui_out_field_string (current_uiout, "library", name);
	  ui_out_text (current_uiout, "\n");
	}

      do_cleanups (cleanup);
    }

  if (any_added)
    {
      struct so_list *iter;
      int ix;
      struct cleanup *cleanup;

      ui_out_text (current_uiout, _("  Inferior loaded "));
      cleanup = make_cleanup_ui_out_list_begin_end (current_uiout,
						    "added");
      for (ix = 0;
	   VEC_iterate (so_list_ptr, current_program_space->added_solibs,
			ix, iter);
	   ++ix)
	{
	  if (ix > 0)
	    ui_out_text (current_uiout, "    ");
	  ui_out_field_string (current_uiout, "library", iter->so_name);
	  ui_out_text (current_uiout, "\n");
	}

      do_cleanups (cleanup);
    }
}

/* Print a message indicating what happened.  This is called from
   normal_stop().  The input to this routine is the head of the bpstat
   list - a list of the eventpoints that caused this stop.  KIND is
   the target_waitkind for the stopping event.  This
   routine calls the generic print routine for printing a message
   about reasons for stopping.  This will print (for example) the
   "Breakpoint n," part of the output.  The return value of this
   routine is one of:

   PRINT_UNKNOWN: Means we printed nothing.
   PRINT_SRC_AND_LOC: Means we printed something, and expect subsequent
   code to print the location.  An example is 
   "Breakpoint 1, " which should be followed by
   the location.
   PRINT_SRC_ONLY: Means we printed something, but there is no need
   to also print the location part of the message.
   An example is the catch/throw messages, which
   don't require a location appended to the end.
   PRINT_NOTHING: We have done some printing and we don't need any 
   further info to be printed.  */

enum print_stop_action
bpstat_print (bpstat bs, int kind)
{
  int val;

  /* Maybe another breakpoint in the chain caused us to stop.
     (Currently all watchpoints go on the bpstat whether hit or not.
     That probably could (should) be changed, provided care is taken
     with respect to bpstat_explains_signal).  */
  for (; bs; bs = bs->next)
    {
      val = print_bp_stop_message (bs);
      if (val == PRINT_SRC_ONLY 
	  || val == PRINT_SRC_AND_LOC 
	  || val == PRINT_NOTHING)
	return val;
    }

  /* If we had hit a shared library event breakpoint,
     print_bp_stop_message would print out this message.  If we hit an
     OS-level shared library event, do the same thing.  */
  if (kind == TARGET_WAITKIND_LOADED)
    {
      print_solib_event (0);
      return PRINT_NOTHING;
    }

  /* We reached the end of the chain, or we got a null BS to start
     with and nothing was printed.  */
  return PRINT_UNKNOWN;
}

/* Evaluate the expression EXP and return 1 if value is zero.  This is
   used inside a catch_errors to evaluate the breakpoint condition.
   The argument is a "struct expression *" that has been cast to a
   "char *" to make it pass through catch_errors.  */

static int
breakpoint_cond_eval (void *exp)
{
  struct value *mark = value_mark ();
  int i = !value_true (evaluate_expression ((struct expression *) exp));

  value_free_to_mark (mark);
  return i;
}

/* Allocate a new bpstat.  Link it to the FIFO list by BS_LINK_POINTER.  */

static bpstat
bpstat_alloc (struct bp_location *bl, bpstat **bs_link_pointer)
{
  bpstat bs;

  bs = (bpstat) xmalloc (sizeof (*bs));
  bs->next = NULL;
  **bs_link_pointer = bs;
  *bs_link_pointer = &bs->next;
  bs->breakpoint_at = bl->owner;
  bs->bp_location_at = bl;
  incref_bp_location (bl);
  /* If the condition is false, etc., don't do the commands.  */
  bs->commands = NULL;
  bs->old_val = NULL;
  bs->print_it = print_it_normal;
  return bs;
}

/* The target has stopped with waitstatus WS.  Check if any hardware
   watchpoints have triggered, according to the target.  */

int
watchpoints_triggered (struct target_waitstatus *ws)
{
  int stopped_by_watchpoint = target_stopped_by_watchpoint ();
  CORE_ADDR addr;
  struct breakpoint *b;

  if (!stopped_by_watchpoint)
    {
      /* We were not stopped by a watchpoint.  Mark all watchpoints
	 as not triggered.  */
      ALL_BREAKPOINTS (b)
	if (is_hardware_watchpoint (b))
	  {
	    struct watchpoint *w = (struct watchpoint *) b;

	    w->watchpoint_triggered = watch_triggered_no;
	  }

      return 0;
    }

  if (!target_stopped_data_address (&current_target, &addr))
    {
      /* We were stopped by a watchpoint, but we don't know where.
	 Mark all watchpoints as unknown.  */
      ALL_BREAKPOINTS (b)
	if (is_hardware_watchpoint (b))
	  {
	    struct watchpoint *w = (struct watchpoint *) b;

	    w->watchpoint_triggered = watch_triggered_unknown;
	  }

      return stopped_by_watchpoint;
    }

  /* The target could report the data address.  Mark watchpoints
     affected by this data address as triggered, and all others as not
     triggered.  */

  ALL_BREAKPOINTS (b)
    if (is_hardware_watchpoint (b))
      {
	struct watchpoint *w = (struct watchpoint *) b;
	struct bp_location *loc;

	w->watchpoint_triggered = watch_triggered_no;
	for (loc = b->loc; loc; loc = loc->next)
	  {
	    if (is_masked_watchpoint (b))
	      {
		CORE_ADDR newaddr = addr & w->hw_wp_mask;
		CORE_ADDR start = loc->address & w->hw_wp_mask;

		if (newaddr == start)
		  {
		    w->watchpoint_triggered = watch_triggered_yes;
		    break;
		  }
	      }
	    /* Exact match not required.  Within range is sufficient.  */
	    else if (target_watchpoint_addr_within_range (&current_target,
							 addr, loc->address,
							 loc->length))
	      {
		w->watchpoint_triggered = watch_triggered_yes;
		break;
	      }
	  }
      }

  return 1;
}

/* Possible return values for watchpoint_check (this can't be an enum
   because of check_errors).  */
/* The watchpoint has been deleted.  */
#define WP_DELETED 1
/* The value has changed.  */
#define WP_VALUE_CHANGED 2
/* The value has not changed.  */
#define WP_VALUE_NOT_CHANGED 3
/* Ignore this watchpoint, no matter if the value changed or not.  */
#define WP_IGNORE 4

#define BP_TEMPFLAG 1
#define BP_HARDWAREFLAG 2

/* Evaluate watchpoint condition expression and check if its value
   changed.

   P should be a pointer to struct bpstat, but is defined as a void *
   in order for this function to be usable with catch_errors.  */

static int
watchpoint_check (void *p)
{
  bpstat bs = (bpstat) p;
  struct watchpoint *b;
  struct frame_info *fr;
  int within_current_scope;

  /* BS is built from an existing struct breakpoint.  */
  gdb_assert (bs->breakpoint_at != NULL);
  b = (struct watchpoint *) bs->breakpoint_at;

  /* If this is a local watchpoint, we only want to check if the
     watchpoint frame is in scope if the current thread is the thread
     that was used to create the watchpoint.  */
  if (!watchpoint_in_thread_scope (b))
    return WP_IGNORE;

  if (b->exp_valid_block == NULL)
    within_current_scope = 1;
  else
    {
      struct frame_info *frame = get_current_frame ();
      struct gdbarch *frame_arch = get_frame_arch (frame);
      CORE_ADDR frame_pc = get_frame_pc (frame);

      /* in_function_epilogue_p() returns a non-zero value if we're
	 still in the function but the stack frame has already been
	 invalidated.  Since we can't rely on the values of local
	 variables after the stack has been destroyed, we are treating
	 the watchpoint in that state as `not changed' without further
	 checking.  Don't mark watchpoints as changed if the current
	 frame is in an epilogue - even if they are in some other
	 frame, our view of the stack is likely to be wrong and
	 frame_find_by_id could error out.  */
      if (gdbarch_in_function_epilogue_p (frame_arch, frame_pc))
	return WP_IGNORE;

      fr = frame_find_by_id (b->watchpoint_frame);
      within_current_scope = (fr != NULL);

      /* If we've gotten confused in the unwinder, we might have
	 returned a frame that can't describe this variable.  */
      if (within_current_scope)
	{
	  struct symbol *function;

	  function = get_frame_function (fr);
	  if (function == NULL
	      || !contained_in (b->exp_valid_block,
				SYMBOL_BLOCK_VALUE (function)))
	    within_current_scope = 0;
	}

      if (within_current_scope)
	/* If we end up stopping, the current frame will get selected
	   in normal_stop.  So this call to select_frame won't affect
	   the user.  */
	select_frame (fr);
    }

  if (within_current_scope)
    {
      /* We use value_{,free_to_}mark because it could be a *long*
         time before we return to the command level and call
         free_all_values.  We can't call free_all_values because we
         might be in the middle of evaluating a function call.  */

      int pc = 0;
      struct value *mark;
      struct value *new_val;

      if (is_masked_watchpoint (&b->base))
	/* Since we don't know the exact trigger address (from
	   stopped_data_address), just tell the user we've triggered
	   a mask watchpoint.  */
	return WP_VALUE_CHANGED;

      mark = value_mark ();
      fetch_subexp_value (b->exp, &pc, &new_val, NULL, NULL, 0);

      /* We use value_equal_contents instead of value_equal because
	 the latter coerces an array to a pointer, thus comparing just
	 the address of the array instead of its contents.  This is
	 not what we want.  */
      if ((b->val != NULL) != (new_val != NULL)
	  || (b->val != NULL && !value_equal_contents (b->val, new_val)))
	{
	  if (new_val != NULL)
	    {
	      release_value (new_val);
	      value_free_to_mark (mark);
	    }
	  bs->old_val = b->val;
	  b->val = new_val;
	  b->val_valid = 1;
	  return WP_VALUE_CHANGED;
	}
      else
	{
	  /* Nothing changed.  */
	  value_free_to_mark (mark);
	  return WP_VALUE_NOT_CHANGED;
	}
    }
  else
    {
      struct ui_out *uiout = current_uiout;

      /* This seems like the only logical thing to do because
         if we temporarily ignored the watchpoint, then when
         we reenter the block in which it is valid it contains
         garbage (in the case of a function, it may have two
         garbage values, one before and one after the prologue).
         So we can't even detect the first assignment to it and
         watch after that (since the garbage may or may not equal
         the first value assigned).  */
      /* We print all the stop information in
	 breakpoint_ops->print_it, but in this case, by the time we
	 call breakpoint_ops->print_it this bp will be deleted
	 already.  So we have no choice but print the information
	 here.  */
      if (ui_out_is_mi_like_p (uiout))
	ui_out_field_string
	  (uiout, "reason", async_reason_lookup (EXEC_ASYNC_WATCHPOINT_SCOPE));
      ui_out_text (uiout, "\nWatchpoint ");
      ui_out_field_int (uiout, "wpnum", b->base.number);
      ui_out_text (uiout,
		   " deleted because the program has left the block in\n\
which its expression is valid.\n");     

      /* Make sure the watchpoint's commands aren't executed.  */
      decref_counted_command_line (&b->base.commands);
      watchpoint_del_at_next_stop (b);

      return WP_DELETED;
    }
}

/* Return true if it looks like target has stopped due to hitting
   breakpoint location BL.  This function does not check if we should
   stop, only if BL explains the stop.  */

static int
bpstat_check_location (const struct bp_location *bl,
		       struct address_space *aspace, CORE_ADDR bp_addr,
		       const struct target_waitstatus *ws)
{
  struct breakpoint *b = bl->owner;

  /* BL is from an existing breakpoint.  */
  gdb_assert (b != NULL);

  return b->ops->breakpoint_hit (bl, aspace, bp_addr, ws);
}

/* Determine if the watched values have actually changed, and we
   should stop.  If not, set BS->stop to 0.  */

static void
bpstat_check_watchpoint (bpstat bs)
{
  const struct bp_location *bl;
  struct watchpoint *b;

  /* BS is built for existing struct breakpoint.  */
  bl = bs->bp_location_at;
  gdb_assert (bl != NULL);
  b = (struct watchpoint *) bs->breakpoint_at;
  gdb_assert (b != NULL);

    {
      int must_check_value = 0;
      
      if (b->base.type == bp_watchpoint)
	/* For a software watchpoint, we must always check the
	   watched value.  */
	must_check_value = 1;
      else if (b->watchpoint_triggered == watch_triggered_yes)
	/* We have a hardware watchpoint (read, write, or access)
	   and the target earlier reported an address watched by
	   this watchpoint.  */
	must_check_value = 1;
      else if (b->watchpoint_triggered == watch_triggered_unknown
	       && b->base.type == bp_hardware_watchpoint)
	/* We were stopped by a hardware watchpoint, but the target could
	   not report the data address.  We must check the watchpoint's
	   value.  Access and read watchpoints are out of luck; without
	   a data address, we can't figure it out.  */
	must_check_value = 1;

      if (must_check_value)
	{
	  char *message
	    = xstrprintf ("Error evaluating expression for watchpoint %d\n",
			  b->base.number);
	  struct cleanup *cleanups = make_cleanup (xfree, message);
	  int e = catch_errors (watchpoint_check, bs, message,
				RETURN_MASK_ALL);
	  do_cleanups (cleanups);
	  switch (e)
	    {
	    case WP_DELETED:
	      /* We've already printed what needs to be printed.  */
	      bs->print_it = print_it_done;
	      /* Stop.  */
	      break;
	    case WP_IGNORE:
	      bs->print_it = print_it_noop;
	      bs->stop = 0;
	      break;
	    case WP_VALUE_CHANGED:
	      if (b->base.type == bp_read_watchpoint)
		{
		  /* There are two cases to consider here:

		     1. We're watching the triggered memory for reads.
		     In that case, trust the target, and always report
		     the watchpoint hit to the user.  Even though
		     reads don't cause value changes, the value may
		     have changed since the last time it was read, and
		     since we're not trapping writes, we will not see
		     those, and as such we should ignore our notion of
		     old value.

		     2. We're watching the triggered memory for both
		     reads and writes.  There are two ways this may
		     happen:

		     2.1. This is a target that can't break on data
		     reads only, but can break on accesses (reads or
		     writes), such as e.g., x86.  We detect this case
		     at the time we try to insert read watchpoints.

		     2.2. Otherwise, the target supports read
		     watchpoints, but, the user set an access or write
		     watchpoint watching the same memory as this read
		     watchpoint.

		     If we're watching memory writes as well as reads,
		     ignore watchpoint hits when we find that the
		     value hasn't changed, as reads don't cause
		     changes.  This still gives false positives when
		     the program writes the same value to memory as
		     what there was already in memory (we will confuse
		     it for a read), but it's much better than
		     nothing.  */

		  int other_write_watchpoint = 0;

		  if (bl->watchpoint_type == hw_read)
		    {
		      struct breakpoint *other_b;

		      ALL_BREAKPOINTS (other_b)
			if (other_b->type == bp_hardware_watchpoint
			    || other_b->type == bp_access_watchpoint)
			  {
			    struct watchpoint *other_w =
			      (struct watchpoint *) other_b;

			    if (other_w->watchpoint_triggered
				== watch_triggered_yes)
			      {
				other_write_watchpoint = 1;
				break;
			      }
			  }
		    }

		  if (other_write_watchpoint
		      || bl->watchpoint_type == hw_access)
		    {
		      /* We're watching the same memory for writes,
			 and the value changed since the last time we
			 updated it, so this trap must be for a write.
			 Ignore it.  */
		      bs->print_it = print_it_noop;
		      bs->stop = 0;
		    }
		}
	      break;
	    case WP_VALUE_NOT_CHANGED:
	      if (b->base.type == bp_hardware_watchpoint
		  || b->base.type == bp_watchpoint)
		{
		  /* Don't stop: write watchpoints shouldn't fire if
		     the value hasn't changed.  */
		  bs->print_it = print_it_noop;
		  bs->stop = 0;
		}
	      /* Stop.  */
	      break;
	    default:
	      /* Can't happen.  */
	    case 0:
	      /* Error from catch_errors.  */
	      printf_filtered (_("Watchpoint %d deleted.\n"), b->base.number);
	      watchpoint_del_at_next_stop (b);
	      /* We've already printed what needs to be printed.  */
	      bs->print_it = print_it_done;
	      break;
	    }
	}
      else	/* must_check_value == 0 */
	{
	  /* This is a case where some watchpoint(s) triggered, but
	     not at the address of this watchpoint, or else no
	     watchpoint triggered after all.  So don't print
	     anything for this watchpoint.  */
	  bs->print_it = print_it_noop;
	  bs->stop = 0;
	}
    }
}


/* Check conditions (condition proper, frame, thread and ignore count)
   of breakpoint referred to by BS.  If we should not stop for this
   breakpoint, set BS->stop to 0.  */

static void
bpstat_check_breakpoint_conditions (bpstat bs, ptid_t ptid)
{
  int thread_id = pid_to_thread_id (ptid);
  const struct bp_location *bl;
  struct breakpoint *b;

  /* BS is built for existing struct breakpoint.  */
  bl = bs->bp_location_at;
  gdb_assert (bl != NULL);
  b = bs->breakpoint_at;
  gdb_assert (b != NULL);

  /* Even if the target evaluated the condition on its end and notified GDB, we
     need to do so again since GDB does not know if we stopped due to a
     breakpoint or a single step breakpoint.  */

  if (frame_id_p (b->frame_id)
      && !frame_id_eq (b->frame_id, get_stack_frame_id (get_current_frame ())))
    bs->stop = 0;
  else if (bs->stop)
    {
      int value_is_zero = 0;
      struct expression *cond;

      /* Evaluate Python breakpoints that have a "stop"
	 method implemented.  */
      if (b->py_bp_object)
	bs->stop = gdbpy_should_stop (b->py_bp_object);

      if (is_watchpoint (b))
	{
	  struct watchpoint *w = (struct watchpoint *) b;

	  cond = w->cond_exp;
	}
      else
	cond = bl->cond;

      if (cond && b->disposition != disp_del_at_next_stop)
	{
	  int within_current_scope = 1;
	  struct watchpoint * w;

	  /* We use value_mark and value_free_to_mark because it could
	     be a long time before we return to the command level and
	     call free_all_values.  We can't call free_all_values
	     because we might be in the middle of evaluating a
	     function call.  */
	  struct value *mark = value_mark ();

	  if (is_watchpoint (b))
	    w = (struct watchpoint *) b;
	  else
	    w = NULL;

	  /* Need to select the frame, with all that implies so that
	     the conditions will have the right context.  Because we
	     use the frame, we will not see an inlined function's
	     variables when we arrive at a breakpoint at the start
	     of the inlined function; the current frame will be the
	     call site.  */
	  if (w == NULL || w->cond_exp_valid_block == NULL)
	    select_frame (get_current_frame ());
	  else
	    {
	      struct frame_info *frame;

	      /* For local watchpoint expressions, which particular
		 instance of a local is being watched matters, so we
		 keep track of the frame to evaluate the expression
		 in.  To evaluate the condition however, it doesn't
		 really matter which instantiation of the function
		 where the condition makes sense triggers the
		 watchpoint.  This allows an expression like "watch
		 global if q > 10" set in `func', catch writes to
		 global on all threads that call `func', or catch
		 writes on all recursive calls of `func' by a single
		 thread.  We simply always evaluate the condition in
		 the innermost frame that's executing where it makes
		 sense to evaluate the condition.  It seems
		 intuitive.  */
	      frame = block_innermost_frame (w->cond_exp_valid_block);
	      if (frame != NULL)
		select_frame (frame);
	      else
		within_current_scope = 0;
	    }
	  if (within_current_scope)
	    value_is_zero
	      = catch_errors (breakpoint_cond_eval, cond,
			      "Error in testing breakpoint condition:\n",
			      RETURN_MASK_ALL);
	  else
	    {
	      warning (_("Watchpoint condition cannot be tested "
			 "in the current scope"));
	      /* If we failed to set the right context for this
		 watchpoint, unconditionally report it.  */
	      value_is_zero = 0;
	    }
	  /* FIXME-someday, should give breakpoint #.  */
	  value_free_to_mark (mark);
	}

      if (cond && value_is_zero)
	{
	  bs->stop = 0;
	}
      else if (b->thread != -1 && b->thread != thread_id)
	{
	  bs->stop = 0;
	}
      else if (b->ignore_count > 0)
	{
	  b->ignore_count--;
	  bs->stop = 0;
	  /* Increase the hit count even though we don't stop.  */
	  ++(b->hit_count);
	  observer_notify_breakpoint_modified (b);
	}	
    }
}


/* Get a bpstat associated with having just stopped at address
   BP_ADDR in thread PTID.

   Determine whether we stopped at a breakpoint, etc, or whether we
   don't understand this stop.  Result is a chain of bpstat's such
   that:

   if we don't understand the stop, the result is a null pointer.

   if we understand why we stopped, the result is not null.

   Each element of the chain refers to a particular breakpoint or
   watchpoint at which we have stopped.  (We may have stopped for
   several reasons concurrently.)

   Each element of the chain has valid next, breakpoint_at,
   commands, FIXME??? fields.  */

bpstat
bpstat_stop_status (struct address_space *aspace,
		    CORE_ADDR bp_addr, ptid_t ptid,
		    const struct target_waitstatus *ws)
{
  struct breakpoint *b = NULL;
  struct bp_location *bl;
  struct bp_location *loc;
  /* First item of allocated bpstat's.  */
  bpstat bs_head = NULL, *bs_link = &bs_head;
  /* Pointer to the last thing in the chain currently.  */
  bpstat bs;
  int ix;
  int need_remove_insert;
  int removed_any;

  /* First, build the bpstat chain with locations that explain a
     target stop, while being careful to not set the target running,
     as that may invalidate locations (in particular watchpoint
     locations are recreated).  Resuming will happen here with
     breakpoint conditions or watchpoint expressions that include
     inferior function calls.  */

  ALL_BREAKPOINTS (b)
    {
      if (!breakpoint_enabled (b) && b->enable_state != bp_permanent)
	continue;

      for (bl = b->loc; bl != NULL; bl = bl->next)
	{
	  /* For hardware watchpoints, we look only at the first
	     location.  The watchpoint_check function will work on the
	     entire expression, not the individual locations.  For
	     read watchpoints, the watchpoints_triggered function has
	     checked all locations already.  */
	  if (b->type == bp_hardware_watchpoint && bl != b->loc)
	    break;

	  if (!bl->enabled || bl->shlib_disabled)
	    continue;

	  if (!bpstat_check_location (bl, aspace, bp_addr, ws))
	    continue;

	  /* Come here if it's a watchpoint, or if the break address
	     matches.  */

	  bs = bpstat_alloc (bl, &bs_link);	/* Alloc a bpstat to
						   explain stop.  */

	  /* Assume we stop.  Should we find a watchpoint that is not
	     actually triggered, or if the condition of the breakpoint
	     evaluates as false, we'll reset 'stop' to 0.  */
	  bs->stop = 1;
	  bs->print = 1;

	  /* If this is a scope breakpoint, mark the associated
	     watchpoint as triggered so that we will handle the
	     out-of-scope event.  We'll get to the watchpoint next
	     iteration.  */
	  if (b->type == bp_watchpoint_scope && b->related_breakpoint != b)
	    {
	      struct watchpoint *w = (struct watchpoint *) b->related_breakpoint;

	      w->watchpoint_triggered = watch_triggered_yes;
	    }
	}
    }

  for (ix = 0; VEC_iterate (bp_location_p, moribund_locations, ix, loc); ++ix)
    {
      if (breakpoint_location_address_match (loc, aspace, bp_addr))
	{
	  bs = bpstat_alloc (loc, &bs_link);
	  /* For hits of moribund locations, we should just proceed.  */
	  bs->stop = 0;
	  bs->print = 0;
	  bs->print_it = print_it_noop;
	}
    }

  /* A bit of special processing for shlib breakpoints.  We need to
     process solib loading here, so that the lists of loaded and
     unloaded libraries are correct before we handle "catch load" and
     "catch unload".  */
  for (bs = bs_head; bs != NULL; bs = bs->next)
    {
      if (bs->breakpoint_at && bs->breakpoint_at->type == bp_shlib_event)
	{
	  handle_solib_event ();
	  break;
	}
    }

  /* Now go through the locations that caused the target to stop, and
     check whether we're interested in reporting this stop to higher
     layers, or whether we should resume the target transparently.  */

  removed_any = 0;

  for (bs = bs_head; bs != NULL; bs = bs->next)
    {
      if (!bs->stop)
	continue;

      b = bs->breakpoint_at;
      b->ops->check_status (bs);
      if (bs->stop)
	{
	  bpstat_check_breakpoint_conditions (bs, ptid);

	  if (bs->stop)
	    {
	      ++(b->hit_count);
	      observer_notify_breakpoint_modified (b);

	      /* We will stop here.  */
	      if (b->disposition == disp_disable)
		{
		  --(b->enable_count);
		  if (b->enable_count <= 0
		      && b->enable_state != bp_permanent)
		    b->enable_state = bp_disabled;
		  removed_any = 1;
		}
	      if (b->silent)
		bs->print = 0;
	      bs->commands = b->commands;
	      incref_counted_command_line (bs->commands);
	      if (command_line_is_silent (bs->commands
					  ? bs->commands->commands : NULL))
		bs->print = 0;

	      b->ops->after_condition_true (bs);
	    }

	}

      /* Print nothing for this entry if we don't stop or don't
	 print.  */
      if (!bs->stop || !bs->print)
	bs->print_it = print_it_noop;
    }

  /* If we aren't stopping, the value of some hardware watchpoint may
     not have changed, but the intermediate memory locations we are
     watching may have.  Don't bother if we're stopping; this will get
     done later.  */
  need_remove_insert = 0;
  if (! bpstat_causes_stop (bs_head))
    for (bs = bs_head; bs != NULL; bs = bs->next)
      if (!bs->stop
	  && bs->breakpoint_at
	  && is_hardware_watchpoint (bs->breakpoint_at))
	{
	  struct watchpoint *w = (struct watchpoint *) bs->breakpoint_at;

	  update_watchpoint (w, 0 /* don't reparse.  */);
	  need_remove_insert = 1;
	}

  if (need_remove_insert)
    update_global_location_list (1);
  else if (removed_any)
    update_global_location_list (0);

  return bs_head;
}

static void
handle_jit_event (void)
{
  struct frame_info *frame;
  struct gdbarch *gdbarch;

  /* Switch terminal for any messages produced by
     breakpoint_re_set.  */
  target_terminal_ours_for_output ();

  frame = get_current_frame ();
  gdbarch = get_frame_arch (frame);

  jit_event_handler (gdbarch);

  target_terminal_inferior ();
}

/* Prepare WHAT final decision for infrun.  */

/* Decide what infrun needs to do with this bpstat.  */

struct bpstat_what
bpstat_what (bpstat bs_head)
{
  struct bpstat_what retval;
  int jit_event = 0;
  bpstat bs;

  retval.main_action = BPSTAT_WHAT_KEEP_CHECKING;
  retval.call_dummy = STOP_NONE;
  retval.is_longjmp = 0;

  for (bs = bs_head; bs != NULL; bs = bs->next)
    {
      /* Extract this BS's action.  After processing each BS, we check
	 if its action overrides all we've seem so far.  */
      enum bpstat_what_main_action this_action = BPSTAT_WHAT_KEEP_CHECKING;
      enum bptype bptype;

      if (bs->breakpoint_at == NULL)
	{
	  /* I suspect this can happen if it was a momentary
	     breakpoint which has since been deleted.  */
	  bptype = bp_none;
	}
      else
	bptype = bs->breakpoint_at->type;

      switch (bptype)
	{
	case bp_none:
	  break;
	case bp_breakpoint:
	case bp_hardware_breakpoint:
	case bp_until:
	case bp_finish:
	case bp_shlib_event:
	  if (bs->stop)
	    {
	      if (bs->print)
		this_action = BPSTAT_WHAT_STOP_NOISY;
	      else
		this_action = BPSTAT_WHAT_STOP_SILENT;
	    }
	  else
	    this_action = BPSTAT_WHAT_SINGLE;
	  break;
	case bp_watchpoint:
	case bp_hardware_watchpoint:
	case bp_read_watchpoint:
	case bp_access_watchpoint:
	  if (bs->stop)
	    {
	      if (bs->print)
		this_action = BPSTAT_WHAT_STOP_NOISY;
	      else
		this_action = BPSTAT_WHAT_STOP_SILENT;
	    }
	  else
	    {
	      /* There was a watchpoint, but we're not stopping.
		 This requires no further action.  */
	    }
	  break;
	case bp_longjmp:
	case bp_longjmp_call_dummy:
	case bp_exception:
	  this_action = BPSTAT_WHAT_SET_LONGJMP_RESUME;
	  retval.is_longjmp = bptype != bp_exception;
	  break;
	case bp_longjmp_resume:
	case bp_exception_resume:
	  this_action = BPSTAT_WHAT_CLEAR_LONGJMP_RESUME;
	  retval.is_longjmp = bptype == bp_longjmp_resume;
	  break;
	case bp_step_resume:
	  if (bs->stop)
	    this_action = BPSTAT_WHAT_STEP_RESUME;
	  else
	    {
	      /* It is for the wrong frame.  */
	      this_action = BPSTAT_WHAT_SINGLE;
	    }
	  break;
	case bp_hp_step_resume:
	  if (bs->stop)
	    this_action = BPSTAT_WHAT_HP_STEP_RESUME;
	  else
	    {
	      /* It is for the wrong frame.  */
	      this_action = BPSTAT_WHAT_SINGLE;
	    }
	  break;
	case bp_watchpoint_scope:
	case bp_thread_event:
	case bp_overlay_event:
	case bp_longjmp_master:
	case bp_std_terminate_master:
	case bp_exception_master:
	  this_action = BPSTAT_WHAT_SINGLE;
	  break;
	case bp_catchpoint:
	  if (bs->stop)
	    {
	      if (bs->print)
		this_action = BPSTAT_WHAT_STOP_NOISY;
	      else
		this_action = BPSTAT_WHAT_STOP_SILENT;
	    }
	  else
	    {
	      /* There was a catchpoint, but we're not stopping.
		 This requires no further action.  */
	    }
	  break;
	case bp_jit_event:
	  jit_event = 1;
	  this_action = BPSTAT_WHAT_SINGLE;
	  break;
	case bp_call_dummy:
	  /* Make sure the action is stop (silent or noisy),
	     so infrun.c pops the dummy frame.  */
	  retval.call_dummy = STOP_STACK_DUMMY;
	  this_action = BPSTAT_WHAT_STOP_SILENT;
	  break;
	case bp_std_terminate:
	  /* Make sure the action is stop (silent or noisy),
	     so infrun.c pops the dummy frame.  */
	  retval.call_dummy = STOP_STD_TERMINATE;
	  this_action = BPSTAT_WHAT_STOP_SILENT;
	  break;
	case bp_tracepoint:
	case bp_fast_tracepoint:
	case bp_static_tracepoint:
	  /* Tracepoint hits should not be reported back to GDB, and
	     if one got through somehow, it should have been filtered
	     out already.  */
	  internal_error (__FILE__, __LINE__,
			  _("bpstat_what: tracepoint encountered"));
	  break;
	case bp_gnu_ifunc_resolver:
	  /* Step over it (and insert bp_gnu_ifunc_resolver_return).  */
	  this_action = BPSTAT_WHAT_SINGLE;
	  break;
	case bp_gnu_ifunc_resolver_return:
	  /* The breakpoint will be removed, execution will restart from the
	     PC of the former breakpoint.  */
	  this_action = BPSTAT_WHAT_KEEP_CHECKING;
	  break;

	case bp_dprintf:
	  if (bs->stop)
	    this_action = BPSTAT_WHAT_STOP_SILENT;
	  else
	    this_action = BPSTAT_WHAT_SINGLE;
	  break;

	default:
	  internal_error (__FILE__, __LINE__,
			  _("bpstat_what: unhandled bptype %d"), (int) bptype);
	}

      retval.main_action = max (retval.main_action, this_action);
    }

  /* These operations may affect the bs->breakpoint_at state so they are
     delayed after MAIN_ACTION is decided above.  */

  if (jit_event)
    {
      if (debug_infrun)
	fprintf_unfiltered (gdb_stdlog, "bpstat_what: bp_jit_event\n");

      handle_jit_event ();
    }

  for (bs = bs_head; bs != NULL; bs = bs->next)
    {
      struct breakpoint *b = bs->breakpoint_at;

      if (b == NULL)
	continue;
      switch (b->type)
	{
	case bp_gnu_ifunc_resolver:
	  gnu_ifunc_resolver_stop (b);
	  break;
	case bp_gnu_ifunc_resolver_return:
	  gnu_ifunc_resolver_return_stop (b);
	  break;
	}
    }

  return retval;
}

/* Nonzero if we should step constantly (e.g. watchpoints on machines
   without hardware support).  This isn't related to a specific bpstat,
   just to things like whether watchpoints are set.  */

int
bpstat_should_step (void)
{
  struct breakpoint *b;

  ALL_BREAKPOINTS (b)
    if (breakpoint_enabled (b) && b->type == bp_watchpoint && b->loc != NULL)
      return 1;
  return 0;
}

int
bpstat_causes_stop (bpstat bs)
{
  for (; bs != NULL; bs = bs->next)
    if (bs->stop)
      return 1;

  return 0;
}



/* Compute a string of spaces suitable to indent the next line
   so it starts at the position corresponding to the table column
   named COL_NAME in the currently active table of UIOUT.  */

static char *
wrap_indent_at_field (struct ui_out *uiout, const char *col_name)
{
  static char wrap_indent[80];
  int i, total_width, width, align;
  char *text;

  total_width = 0;
  for (i = 1; ui_out_query_field (uiout, i, &width, &align, &text); i++)
    {
      if (strcmp (text, col_name) == 0)
	{
	  gdb_assert (total_width < sizeof wrap_indent);
	  memset (wrap_indent, ' ', total_width);
	  wrap_indent[total_width] = 0;

	  return wrap_indent;
	}

      total_width += width + 1;
    }

  return NULL;
}

/* Determine if the locations of this breakpoint will have their conditions
   evaluated by the target, host or a mix of both.  Returns the following:

    "host": Host evals condition.
    "host or target": Host or Target evals condition.
    "target": Target evals condition.
*/

static const char *
bp_condition_evaluator (struct breakpoint *b)
{
  struct bp_location *bl;
  char host_evals = 0;
  char target_evals = 0;

  if (!b)
    return NULL;

  if (!is_breakpoint (b))
    return NULL;

  if (gdb_evaluates_breakpoint_condition_p ()
      || !target_supports_evaluation_of_breakpoint_conditions ())
    return condition_evaluation_host;

  for (bl = b->loc; bl; bl = bl->next)
    {
      if (bl->cond_bytecode)
	target_evals++;
      else
	host_evals++;
    }

  if (host_evals && target_evals)
    return condition_evaluation_both;
  else if (target_evals)
    return condition_evaluation_target;
  else
    return condition_evaluation_host;
}

/* Determine the breakpoint location's condition evaluator.  This is
   similar to bp_condition_evaluator, but for locations.  */

static const char *
bp_location_condition_evaluator (struct bp_location *bl)
{
  if (bl && !is_breakpoint (bl->owner))
    return NULL;

  if (gdb_evaluates_breakpoint_condition_p ()
      || !target_supports_evaluation_of_breakpoint_conditions ())
    return condition_evaluation_host;

  if (bl && bl->cond_bytecode)
    return condition_evaluation_target;
  else
    return condition_evaluation_host;
}

/* Print the LOC location out of the list of B->LOC locations.  */

static void
print_breakpoint_location (struct breakpoint *b,
			   struct bp_location *loc)
{
  struct ui_out *uiout = current_uiout;
  struct cleanup *old_chain = save_current_program_space ();

  if (loc != NULL && loc->shlib_disabled)
    loc = NULL;

  if (loc != NULL)
    set_current_program_space (loc->pspace);

  if (b->display_canonical)
    ui_out_field_string (uiout, "what", b->addr_string);
  else if (loc && loc->symtab)
    {
      struct symbol *sym 
	= find_pc_sect_function (loc->address, loc->section);
      if (sym)
	{
	  ui_out_text (uiout, "in ");
	  ui_out_field_string (uiout, "func",
			       SYMBOL_PRINT_NAME (sym));
	  ui_out_text (uiout, " ");
	  ui_out_wrap_hint (uiout, wrap_indent_at_field (uiout, "what"));
	  ui_out_text (uiout, "at ");
	}
      ui_out_field_string (uiout, "file",
			   symtab_to_filename_for_display (loc->symtab));
      ui_out_text (uiout, ":");

      if (ui_out_is_mi_like_p (uiout))
	ui_out_field_string (uiout, "fullname",
			     symtab_to_fullname (loc->symtab));
      
      ui_out_field_int (uiout, "line", loc->line_number);
    }
  else if (loc)
    {
      struct ui_file *stb = mem_fileopen ();
      struct cleanup *stb_chain = make_cleanup_ui_file_delete (stb);

      print_address_symbolic (loc->gdbarch, loc->address, stb,
			      demangle, "");
      ui_out_field_stream (uiout, "at", stb);

      do_cleanups (stb_chain);
    }
  else
    ui_out_field_string (uiout, "pending", b->addr_string);

  if (loc && is_breakpoint (b)
      && breakpoint_condition_evaluation_mode () == condition_evaluation_target
      && bp_condition_evaluator (b) == condition_evaluation_both)
    {
      ui_out_text (uiout, " (");
      ui_out_field_string (uiout, "evaluated-by",
			   bp_location_condition_evaluator (loc));
      ui_out_text (uiout, ")");
    }

  do_cleanups (old_chain);
}

static const char *
bptype_string (enum bptype type)
{
  struct ep_type_description
    {
      enum bptype type;
      char *description;
    };
  static struct ep_type_description bptypes[] =
  {
    {bp_none, "?deleted?"},
    {bp_breakpoint, "breakpoint"},
    {bp_hardware_breakpoint, "hw breakpoint"},
    {bp_until, "until"},
    {bp_finish, "finish"},
    {bp_watchpoint, "watchpoint"},
    {bp_hardware_watchpoint, "hw watchpoint"},
    {bp_read_watchpoint, "read watchpoint"},
    {bp_access_watchpoint, "acc watchpoint"},
    {bp_longjmp, "longjmp"},
    {bp_longjmp_resume, "longjmp resume"},
    {bp_longjmp_call_dummy, "longjmp for call dummy"},
    {bp_exception, "exception"},
    {bp_exception_resume, "exception resume"},
    {bp_step_resume, "step resume"},
    {bp_hp_step_resume, "high-priority step resume"},
    {bp_watchpoint_scope, "watchpoint scope"},
    {bp_call_dummy, "call dummy"},
    {bp_std_terminate, "std::terminate"},
    {bp_shlib_event, "shlib events"},
    {bp_thread_event, "thread events"},
    {bp_overlay_event, "overlay events"},
    {bp_longjmp_master, "longjmp master"},
    {bp_std_terminate_master, "std::terminate master"},
    {bp_exception_master, "exception master"},
    {bp_catchpoint, "catchpoint"},
    {bp_tracepoint, "tracepoint"},
    {bp_fast_tracepoint, "fast tracepoint"},
    {bp_static_tracepoint, "static tracepoint"},
    {bp_dprintf, "dprintf"},
    {bp_jit_event, "jit events"},
    {bp_gnu_ifunc_resolver, "STT_GNU_IFUNC resolver"},
    {bp_gnu_ifunc_resolver_return, "STT_GNU_IFUNC resolver return"},
  };

  if (((int) type >= (sizeof (bptypes) / sizeof (bptypes[0])))
      || ((int) type != bptypes[(int) type].type))
    internal_error (__FILE__, __LINE__,
		    _("bptypes table does not describe type #%d."),
		    (int) type);

  return bptypes[(int) type].description;
}

/* For MI, output a field named 'thread-groups' with a list as the value.
   For CLI, prefix the list with the string 'inf'. */

static void
output_thread_groups (struct ui_out *uiout,
		      const char *field_name,
		      VEC(int) *inf_num,
		      int mi_only)
{
  struct cleanup *back_to;
  int is_mi = ui_out_is_mi_like_p (uiout);
  int inf;
  int i;

  /* For backward compatibility, don't display inferiors in CLI unless
     there are several.  Always display them for MI. */
  if (!is_mi && mi_only)
    return;

  back_to = make_cleanup_ui_out_list_begin_end (uiout, field_name);

  for (i = 0; VEC_iterate (int, inf_num, i, inf); ++i)
    {
      if (is_mi)
	{
	  char mi_group[10];

	  xsnprintf (mi_group, sizeof (mi_group), "i%d", inf);
	  ui_out_field_string (uiout, NULL, mi_group);
	}
      else
	{
	  if (i == 0)
	    ui_out_text (uiout, " inf ");
	  else
	    ui_out_text (uiout, ", ");
	
	  ui_out_text (uiout, plongest (inf));
	}
    }

  do_cleanups (back_to);
}

/* Print B to gdb_stdout.  */

static void
print_one_breakpoint_location (struct breakpoint *b,
			       struct bp_location *loc,
			       int loc_number,
			       struct bp_location **last_loc,
			       int allflag)
{
  struct command_line *l;
  static char bpenables[] = "nynny";

  struct ui_out *uiout = current_uiout;
  int header_of_multiple = 0;
  int part_of_multiple = (loc != NULL);
  struct value_print_options opts;

  get_user_print_options (&opts);

  gdb_assert (!loc || loc_number != 0);
  /* See comment in print_one_breakpoint concerning treatment of
     breakpoints with single disabled location.  */
  if (loc == NULL 
      && (b->loc != NULL 
	  && (b->loc->next != NULL || !b->loc->enabled)))
    header_of_multiple = 1;
  if (loc == NULL)
    loc = b->loc;

  annotate_record ();

  /* 1 */
  annotate_field (0);
  if (part_of_multiple)
    {
      char *formatted;
      formatted = xstrprintf ("%d.%d", b->number, loc_number);
      ui_out_field_string (uiout, "number", formatted);
      xfree (formatted);
    }
  else
    {
      ui_out_field_int (uiout, "number", b->number);
    }

  /* 2 */
  annotate_field (1);
  if (part_of_multiple)
    ui_out_field_skip (uiout, "type");
  else
    ui_out_field_string (uiout, "type", bptype_string (b->type));

  /* 3 */
  annotate_field (2);
  if (part_of_multiple)
    ui_out_field_skip (uiout, "disp");
  else
    ui_out_field_string (uiout, "disp", bpdisp_text (b->disposition));


  /* 4 */
  annotate_field (3);
  if (part_of_multiple)
    ui_out_field_string (uiout, "enabled", loc->enabled ? "y" : "n");
  else
    ui_out_field_fmt (uiout, "enabled", "%c", 
		      bpenables[(int) b->enable_state]);
  ui_out_spaces (uiout, 2);

  
  /* 5 and 6 */
  if (b->ops != NULL && b->ops->print_one != NULL)
    {
      /* Although the print_one can possibly print all locations,
	 calling it here is not likely to get any nice result.  So,
	 make sure there's just one location.  */
      gdb_assert (b->loc == NULL || b->loc->next == NULL);
      b->ops->print_one (b, last_loc);
    }
  else
    switch (b->type)
      {
      case bp_none:
	internal_error (__FILE__, __LINE__,
			_("print_one_breakpoint: bp_none encountered\n"));
	break;

      case bp_watchpoint:
      case bp_hardware_watchpoint:
      case bp_read_watchpoint:
      case bp_access_watchpoint:
	{
	  struct watchpoint *w = (struct watchpoint *) b;

	  /* Field 4, the address, is omitted (which makes the columns
	     not line up too nicely with the headers, but the effect
	     is relatively readable).  */
	  if (opts.addressprint)
	    ui_out_field_skip (uiout, "addr");
	  annotate_field (5);
	  ui_out_field_string (uiout, "what", w->exp_string);
	}
	break;

      case bp_breakpoint:
      case bp_hardware_breakpoint:
      case bp_until:
      case bp_finish:
      case bp_longjmp:
      case bp_longjmp_resume:
      case bp_longjmp_call_dummy:
      case bp_exception:
      case bp_exception_resume:
      case bp_step_resume:
      case bp_hp_step_resume:
      case bp_watchpoint_scope:
      case bp_call_dummy:
      case bp_std_terminate:
      case bp_shlib_event:
      case bp_thread_event:
      case bp_overlay_event:
      case bp_longjmp_master:
      case bp_std_terminate_master:
      case bp_exception_master:
      case bp_tracepoint:
      case bp_fast_tracepoint:
      case bp_static_tracepoint:
      case bp_dprintf:
      case bp_jit_event:
      case bp_gnu_ifunc_resolver:
      case bp_gnu_ifunc_resolver_return:
	if (opts.addressprint)
	  {
	    annotate_field (4);
	    if (header_of_multiple)
	      ui_out_field_string (uiout, "addr", "<MULTIPLE>");
	    else if (b->loc == NULL || loc->shlib_disabled)
	      ui_out_field_string (uiout, "addr", "<PENDING>");
	    else
	      ui_out_field_core_addr (uiout, "addr",
				      loc->gdbarch, loc->address);
	  }
	annotate_field (5);
	if (!header_of_multiple)
	  print_breakpoint_location (b, loc);
	if (b->loc)
	  *last_loc = b->loc;
	break;
      }


  if (loc != NULL && !header_of_multiple)
    {
      struct inferior *inf;
      VEC(int) *inf_num = NULL;
      int mi_only = 1;

      ALL_INFERIORS (inf)
	{
	  if (inf->pspace == loc->pspace)
	    VEC_safe_push (int, inf_num, inf->num);
	}

        /* For backward compatibility, don't display inferiors in CLI unless
	   there are several.  Always display for MI. */
	if (allflag
	    || (!gdbarch_has_global_breakpoints (target_gdbarch ())
		&& (number_of_program_spaces () > 1
		    || number_of_inferiors () > 1)
		/* LOC is for existing B, it cannot be in
		   moribund_locations and thus having NULL OWNER.  */
		&& loc->owner->type != bp_catchpoint))
	mi_only = 0;
      output_thread_groups (uiout, "thread-groups", inf_num, mi_only);
      VEC_free (int, inf_num);
    }

  if (!part_of_multiple)
    {
      if (b->thread != -1)
	{
	  /* FIXME: This seems to be redundant and lost here; see the
	     "stop only in" line a little further down.  */
	  ui_out_text (uiout, " thread ");
	  ui_out_field_int (uiout, "thread", b->thread);
	}
      else if (b->task != 0)
	{
	  ui_out_text (uiout, " task ");
	  ui_out_field_int (uiout, "task", b->task);
	}
    }

  ui_out_text (uiout, "\n");

  if (!part_of_multiple)
    b->ops->print_one_detail (b, uiout);

  if (part_of_multiple && frame_id_p (b->frame_id))
    {
      annotate_field (6);
      ui_out_text (uiout, "\tstop only in stack frame at ");
      /* FIXME: cagney/2002-12-01: Shouldn't be poking around inside
         the frame ID.  */
      ui_out_field_core_addr (uiout, "frame",
			      b->gdbarch, b->frame_id.stack_addr);
      ui_out_text (uiout, "\n");
    }
  
  if (!part_of_multiple && b->cond_string)
    {
      annotate_field (7);
      if (is_tracepoint (b))
	ui_out_text (uiout, "\ttrace only if ");
      else
	ui_out_text (uiout, "\tstop only if ");
      ui_out_field_string (uiout, "cond", b->cond_string);

      /* Print whether the target is doing the breakpoint's condition
	 evaluation.  If GDB is doing the evaluation, don't print anything.  */
      if (is_breakpoint (b)
	  && breakpoint_condition_evaluation_mode ()
	  == condition_evaluation_target)
	{
	  ui_out_text (uiout, " (");
	  ui_out_field_string (uiout, "evaluated-by",
			       bp_condition_evaluator (b));
	  ui_out_text (uiout, " evals)");
	}
      ui_out_text (uiout, "\n");
    }

  if (!part_of_multiple && b->thread != -1)
    {
      /* FIXME should make an annotation for this.  */
      ui_out_text (uiout, "\tstop only in thread ");
      ui_out_field_int (uiout, "thread", b->thread);
      ui_out_text (uiout, "\n");
    }
  
  if (!part_of_multiple)
    {
      if (b->hit_count)
	{
	  /* FIXME should make an annotation for this.  */
	  if (is_catchpoint (b))
	    ui_out_text (uiout, "\tcatchpoint");
	  else if (is_tracepoint (b))
	    ui_out_text (uiout, "\ttracepoint");
	  else
	    ui_out_text (uiout, "\tbreakpoint");
	  ui_out_text (uiout, " already hit ");
	  ui_out_field_int (uiout, "times", b->hit_count);
	  if (b->hit_count == 1)
	    ui_out_text (uiout, " time\n");
	  else
	    ui_out_text (uiout, " times\n");
	}
      else
	{
	  /* Output the count also if it is zero, but only if this is mi.  */
	  if (ui_out_is_mi_like_p (uiout))
	    ui_out_field_int (uiout, "times", b->hit_count);
	}
    }

  if (!part_of_multiple && b->ignore_count)
    {
      annotate_field (8);
      ui_out_text (uiout, "\tignore next ");
      ui_out_field_int (uiout, "ignore", b->ignore_count);
      ui_out_text (uiout, " hits\n");
    }

  /* Note that an enable count of 1 corresponds to "enable once"
     behavior, which is reported by the combination of enablement and
     disposition, so we don't need to mention it here.  */
  if (!part_of_multiple && b->enable_count > 1)
    {
      annotate_field (8);
      ui_out_text (uiout, "\tdisable after ");
      /* Tweak the wording to clarify that ignore and enable counts
	 are distinct, and have additive effect.  */
      if (b->ignore_count)
	ui_out_text (uiout, "additional ");
      else
	ui_out_text (uiout, "next ");
      ui_out_field_int (uiout, "enable", b->enable_count);
      ui_out_text (uiout, " hits\n");
    }

  if (!part_of_multiple && is_tracepoint (b))
    {
      struct tracepoint *tp = (struct tracepoint *) b;

      if (tp->traceframe_usage)
	{
	  ui_out_text (uiout, "\ttrace buffer usage ");
	  ui_out_field_int (uiout, "traceframe-usage", tp->traceframe_usage);
	  ui_out_text (uiout, " bytes\n");
	}
    }

  l = b->commands ? b->commands->commands : NULL;
  if (!part_of_multiple && l)
    {
      struct cleanup *script_chain;

      annotate_field (9);
      script_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "script");
      print_command_lines (uiout, l, 4);
      do_cleanups (script_chain);
    }

  if (is_tracepoint (b))
    {
      struct tracepoint *t = (struct tracepoint *) b;

      if (!part_of_multiple && t->pass_count)
	{
	  annotate_field (10);
	  ui_out_text (uiout, "\tpass count ");
	  ui_out_field_int (uiout, "pass", t->pass_count);
	  ui_out_text (uiout, " \n");
	}

      /* Don't display it when tracepoint or tracepoint location is
	 pending.   */
      if (!header_of_multiple && loc != NULL && !loc->shlib_disabled)
	{
	  annotate_field (11);

	  if (ui_out_is_mi_like_p (uiout))
	    ui_out_field_string (uiout, "installed",
				 loc->inserted ? "y" : "n");
	  else
	    {
	      if (loc->inserted)
		ui_out_text (uiout, "\t");
	      else
		ui_out_text (uiout, "\tnot ");
	      ui_out_text (uiout, "installed on target\n");
	    }
	}
    }

  if (ui_out_is_mi_like_p (uiout) && !part_of_multiple)
    {
      if (is_watchpoint (b))
	{
	  struct watchpoint *w = (struct watchpoint *) b;

	  ui_out_field_string (uiout, "original-location", w->exp_string);
	}
      else if (b->addr_string)
	ui_out_field_string (uiout, "original-location", b->addr_string);
    }
}

static void
print_one_breakpoint (struct breakpoint *b,
		      struct bp_location **last_loc, 
		      int allflag)
{
  struct cleanup *bkpt_chain;
  struct ui_out *uiout = current_uiout;

  bkpt_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "bkpt");

  print_one_breakpoint_location (b, NULL, 0, last_loc, allflag);
  do_cleanups (bkpt_chain);

  /* If this breakpoint has custom print function,
     it's already printed.  Otherwise, print individual
     locations, if any.  */
  if (b->ops == NULL || b->ops->print_one == NULL)
    {
      /* If breakpoint has a single location that is disabled, we
	 print it as if it had several locations, since otherwise it's
	 hard to represent "breakpoint enabled, location disabled"
	 situation.

	 Note that while hardware watchpoints have several locations
	 internally, that's not a property exposed to user.  */
      if (b->loc 
	  && !is_hardware_watchpoint (b)
	  && (b->loc->next || !b->loc->enabled))
	{
	  struct bp_location *loc;
	  int n = 1;

	  for (loc = b->loc; loc; loc = loc->next, ++n)
	    {
	      struct cleanup *inner2 =
		make_cleanup_ui_out_tuple_begin_end (uiout, NULL);
	      print_one_breakpoint_location (b, loc, n, last_loc, allflag);
	      do_cleanups (inner2);
	    }
	}
    }
}

static int
breakpoint_address_bits (struct breakpoint *b)
{
  int print_address_bits = 0;
  struct bp_location *loc;

  for (loc = b->loc; loc; loc = loc->next)
    {
      int addr_bit;

      /* Software watchpoints that aren't watching memory don't have
	 an address to print.  */
      if (b->type == bp_watchpoint && loc->watchpoint_type == -1)
	continue;

      addr_bit = gdbarch_addr_bit (loc->gdbarch);
      if (addr_bit > print_address_bits)
	print_address_bits = addr_bit;
    }

  return print_address_bits;
}

struct captured_breakpoint_query_args
  {
    int bnum;
  };

static int
do_captured_breakpoint_query (struct ui_out *uiout, void *data)
{
  struct captured_breakpoint_query_args *args = data;
  struct breakpoint *b;
  struct bp_location *dummy_loc = NULL;

  ALL_BREAKPOINTS (b)
    {
      if (args->bnum == b->number)
	{
	  print_one_breakpoint (b, &dummy_loc, 0);
	  return GDB_RC_OK;
	}
    }
  return GDB_RC_NONE;
}

enum gdb_rc
gdb_breakpoint_query (struct ui_out *uiout, int bnum, 
		      char **error_message)
{
  struct captured_breakpoint_query_args args;

  args.bnum = bnum;
  /* For the moment we don't trust print_one_breakpoint() to not throw
     an error.  */
  if (catch_exceptions_with_msg (uiout, do_captured_breakpoint_query, &args,
				 error_message, RETURN_MASK_ALL) < 0)
    return GDB_RC_FAIL;
  else
    return GDB_RC_OK;
}

/* Return true if this breakpoint was set by the user, false if it is
   internal or momentary.  */

int
user_breakpoint_p (struct breakpoint *b)
{
  return b->number > 0;
}

/* Print information on user settable breakpoint (watchpoint, etc)
   number BNUM.  If BNUM is -1 print all user-settable breakpoints.
   If ALLFLAG is non-zero, include non-user-settable breakpoints.  If
   FILTER is non-NULL, call it on each breakpoint and only include the
   ones for which it returns non-zero.  Return the total number of
   breakpoints listed.  */

static int
breakpoint_1 (char *args, int allflag, 
	      int (*filter) (const struct breakpoint *))
{
  struct breakpoint *b;
  struct bp_location *last_loc = NULL;
  int nr_printable_breakpoints;
  struct cleanup *bkpttbl_chain;
  struct value_print_options opts;
  int print_address_bits = 0;
  int print_type_col_width = 14;
  struct ui_out *uiout = current_uiout;

  get_user_print_options (&opts);

  /* Compute the number of rows in the table, as well as the size
     required for address fields.  */
  nr_printable_breakpoints = 0;
  ALL_BREAKPOINTS (b)
    {
      /* If we have a filter, only list the breakpoints it accepts.  */
      if (filter && !filter (b))
	continue;

      /* If we have an "args" string, it is a list of breakpoints to 
	 accept.  Skip the others.  */
      if (args != NULL && *args != '\0')
	{
	  if (allflag && parse_and_eval_long (args) != b->number)
	    continue;
	  if (!allflag && !number_is_in_list (args, b->number))
	    continue;
	}

      if (allflag || user_breakpoint_p (b))
	{
	  int addr_bit, type_len;

	  addr_bit = breakpoint_address_bits (b);
	  if (addr_bit > print_address_bits)
	    print_address_bits = addr_bit;

	  type_len = strlen (bptype_string (b->type));
	  if (type_len > print_type_col_width)
	    print_type_col_width = type_len;

	  nr_printable_breakpoints++;
	}
    }

  if (opts.addressprint)
    bkpttbl_chain 
      = make_cleanup_ui_out_table_begin_end (uiout, 6,
					     nr_printable_breakpoints,
                                             "BreakpointTable");
  else
    bkpttbl_chain 
      = make_cleanup_ui_out_table_begin_end (uiout, 5,
					     nr_printable_breakpoints,
                                             "BreakpointTable");

  if (nr_printable_breakpoints > 0)
    annotate_breakpoints_headers ();
  if (nr_printable_breakpoints > 0)
    annotate_field (0);
  ui_out_table_header (uiout, 7, ui_left, "number", "Num");	/* 1 */
  if (nr_printable_breakpoints > 0)
    annotate_field (1);
  ui_out_table_header (uiout, print_type_col_width, ui_left,
		       "type", "Type");				/* 2 */
  if (nr_printable_breakpoints > 0)
    annotate_field (2);
  ui_out_table_header (uiout, 4, ui_left, "disp", "Disp");	/* 3 */
  if (nr_printable_breakpoints > 0)
    annotate_field (3);
  ui_out_table_header (uiout, 3, ui_left, "enabled", "Enb");	/* 4 */
  if (opts.addressprint)
    {
      if (nr_printable_breakpoints > 0)
	annotate_field (4);
      if (print_address_bits <= 32)
	ui_out_table_header (uiout, 10, ui_left, 
			     "addr", "Address");		/* 5 */
      else
	ui_out_table_header (uiout, 18, ui_left, 
			     "addr", "Address");		/* 5 */
    }
  if (nr_printable_breakpoints > 0)
    annotate_field (5);
  ui_out_table_header (uiout, 40, ui_noalign, "what", "What");	/* 6 */
  ui_out_table_body (uiout);
  if (nr_printable_breakpoints > 0)
    annotate_breakpoints_table ();

  ALL_BREAKPOINTS (b)
    {
      QUIT;
      /* If we have a filter, only list the breakpoints it accepts.  */
      if (filter && !filter (b))
	continue;

      /* If we have an "args" string, it is a list of breakpoints to 
	 accept.  Skip the others.  */

      if (args != NULL && *args != '\0')
	{
	  if (allflag)	/* maintenance info breakpoint */
	    {
	      if (parse_and_eval_long (args) != b->number)
		continue;
	    }
	  else		/* all others */
	    {
	      if (!number_is_in_list (args, b->number))
		continue;
	    }
	}
      /* We only print out user settable breakpoints unless the
	 allflag is set.  */
      if (allflag || user_breakpoint_p (b))
	print_one_breakpoint (b, &last_loc, allflag);
    }

  do_cleanups (bkpttbl_chain);

  if (nr_printable_breakpoints == 0)
    {
      /* If there's a filter, let the caller decide how to report
	 empty list.  */
      if (!filter)
	{
	  if (args == NULL || *args == '\0')
	    ui_out_message (uiout, 0, "No breakpoints or watchpoints.\n");
	  else
	    ui_out_message (uiout, 0, 
			    "No breakpoint or watchpoint matching '%s'.\n",
			    args);
	}
    }
  else
    {
      if (last_loc && !server_command)
	set_next_address (last_loc->gdbarch, last_loc->address);
    }

  /* FIXME?  Should this be moved up so that it is only called when
     there have been breakpoints? */
  annotate_breakpoints_table_end ();

  return nr_printable_breakpoints;
}

/* Display the value of default-collect in a way that is generally
   compatible with the breakpoint list.  */

static void
default_collect_info (void)
{
  struct ui_out *uiout = current_uiout;

  /* If it has no value (which is frequently the case), say nothing; a
     message like "No default-collect." gets in user's face when it's
     not wanted.  */
  if (!*default_collect)
    return;

  /* The following phrase lines up nicely with per-tracepoint collect
     actions.  */
  ui_out_text (uiout, "default collect ");
  ui_out_field_string (uiout, "default-collect", default_collect);
  ui_out_text (uiout, " \n");
}
  
static void
breakpoints_info (char *args, int from_tty)
{
  breakpoint_1 (args, 0, NULL);

  default_collect_info ();
}

static void
watchpoints_info (char *args, int from_tty)
{
  int num_printed = breakpoint_1 (args, 0, is_watchpoint);
  struct ui_out *uiout = current_uiout;

  if (num_printed == 0)
    {
      if (args == NULL || *args == '\0')
	ui_out_message (uiout, 0, "No watchpoints.\n");
      else
	ui_out_message (uiout, 0, "No watchpoint matching '%s'.\n", args);
    }
}

static void
maintenance_info_breakpoints (char *args, int from_tty)
{
  breakpoint_1 (args, 1, NULL);

  default_collect_info ();
}

static int
breakpoint_has_pc (struct breakpoint *b,
		   struct program_space *pspace,
		   CORE_ADDR pc, struct obj_section *section)
{
  struct bp_location *bl = b->loc;

  for (; bl; bl = bl->next)
    {
      if (bl->pspace == pspace
	  && bl->address == pc
	  && (!overlay_debugging || bl->section == section))
	return 1;	  
    }
  return 0;
}

/* Print a message describing any user-breakpoints set at PC.  This
   concerns with logical breakpoints, so we match program spaces, not
   address spaces.  */

static void
describe_other_breakpoints (struct gdbarch *gdbarch,
			    struct program_space *pspace, CORE_ADDR pc,
			    struct obj_section *section, int thread)
{
  int others = 0;
  struct breakpoint *b;

  ALL_BREAKPOINTS (b)
    others += (user_breakpoint_p (b)
               && breakpoint_has_pc (b, pspace, pc, section));
  if (others > 0)
    {
      if (others == 1)
	printf_filtered (_("Note: breakpoint "));
      else /* if (others == ???) */
	printf_filtered (_("Note: breakpoints "));
      ALL_BREAKPOINTS (b)
	if (user_breakpoint_p (b) && breakpoint_has_pc (b, pspace, pc, section))
	  {
	    others--;
	    printf_filtered ("%d", b->number);
	    if (b->thread == -1 && thread != -1)
	      printf_filtered (" (all threads)");
	    else if (b->thread != -1)
	      printf_filtered (" (thread %d)", b->thread);
	    printf_filtered ("%s%s ",
			     ((b->enable_state == bp_disabled
			       || b->enable_state == bp_call_disabled)
			      ? " (disabled)"
			      : b->enable_state == bp_permanent 
			      ? " (permanent)"
			      : ""),
			     (others > 1) ? "," 
			     : ((others == 1) ? " and" : ""));
	  }
      printf_filtered (_("also set at pc "));
      fputs_filtered (paddress (gdbarch, pc), gdb_stdout);
      printf_filtered (".\n");
    }
}


/* Return true iff it is meaningful to use the address member of
   BPT.  For some breakpoint types, the address member is irrelevant
   and it makes no sense to attempt to compare it to other addresses
   (or use it for any other purpose either).

   More specifically, each of the following breakpoint types will
   always have a zero valued address and we don't want to mark
   breakpoints of any of these types to be a duplicate of an actual
   breakpoint at address zero:

      bp_watchpoint
      bp_catchpoint

*/

static int
breakpoint_address_is_meaningful (struct breakpoint *bpt)
{
  enum bptype type = bpt->type;

  return (type != bp_watchpoint && type != bp_catchpoint);
}

/* Assuming LOC1 and LOC2's owners are hardware watchpoints, returns
   true if LOC1 and LOC2 represent the same watchpoint location.  */

static int
watchpoint_locations_match (struct bp_location *loc1, 
			    struct bp_location *loc2)
{
  struct watchpoint *w1 = (struct watchpoint *) loc1->owner;
  struct watchpoint *w2 = (struct watchpoint *) loc2->owner;

  /* Both of them must exist.  */
  gdb_assert (w1 != NULL);
  gdb_assert (w2 != NULL);

  /* If the target can evaluate the condition expression in hardware,
     then we we need to insert both watchpoints even if they are at
     the same place.  Otherwise the watchpoint will only trigger when
     the condition of whichever watchpoint was inserted evaluates to
     true, not giving a chance for GDB to check the condition of the
     other watchpoint.  */
  if ((w1->cond_exp
       && target_can_accel_watchpoint_condition (loc1->address, 
						 loc1->length,
						 loc1->watchpoint_type,
						 w1->cond_exp))
      || (w2->cond_exp
	  && target_can_accel_watchpoint_condition (loc2->address, 
						    loc2->length,
						    loc2->watchpoint_type,
						    w2->cond_exp)))
    return 0;

  /* Note that this checks the owner's type, not the location's.  In
     case the target does not support read watchpoints, but does
     support access watchpoints, we'll have bp_read_watchpoint
     watchpoints with hw_access locations.  Those should be considered
     duplicates of hw_read locations.  The hw_read locations will
     become hw_access locations later.  */
  return (loc1->owner->type == loc2->owner->type
	  && loc1->pspace->aspace == loc2->pspace->aspace
	  && loc1->address == loc2->address
	  && loc1->length == loc2->length);
}

/* Returns true if {ASPACE1,ADDR1} and {ASPACE2,ADDR2} represent the
   same breakpoint location.  In most targets, this can only be true
   if ASPACE1 matches ASPACE2.  On targets that have global
   breakpoints, the address space doesn't really matter.  */

static int
breakpoint_address_match (struct address_space *aspace1, CORE_ADDR addr1,
			  struct address_space *aspace2, CORE_ADDR addr2)
{
  return ((gdbarch_has_global_breakpoints (target_gdbarch ())
	   || aspace1 == aspace2)
	  && addr1 == addr2);
}

/* Returns true if {ASPACE2,ADDR2} falls within the range determined by
   {ASPACE1,ADDR1,LEN1}.  In most targets, this can only be true if ASPACE1
   matches ASPACE2.  On targets that have global breakpoints, the address
   space doesn't really matter.  */

static int
breakpoint_address_match_range (struct address_space *aspace1, CORE_ADDR addr1,
				int len1, struct address_space *aspace2,
				CORE_ADDR addr2)
{
  return ((gdbarch_has_global_breakpoints (target_gdbarch ())
	   || aspace1 == aspace2)
	  && addr2 >= addr1 && addr2 < addr1 + len1);
}

/* Returns true if {ASPACE,ADDR} matches the breakpoint BL.  BL may be
   a ranged breakpoint.  In most targets, a match happens only if ASPACE
   matches the breakpoint's address space.  On targets that have global
   breakpoints, the address space doesn't really matter.  */

static int
breakpoint_location_address_match (struct bp_location *bl,
				   struct address_space *aspace,
				   CORE_ADDR addr)
{
  return (breakpoint_address_match (bl->pspace->aspace, bl->address,
				    aspace, addr)
	  || (bl->length
	      && breakpoint_address_match_range (bl->pspace->aspace,
						 bl->address, bl->length,
						 aspace, addr)));
}

/* If LOC1 and LOC2's owners are not tracepoints, returns false directly.
   Then, if LOC1 and LOC2 represent the same tracepoint location, returns
   true, otherwise returns false.  */

static int
tracepoint_locations_match (struct bp_location *loc1,
			    struct bp_location *loc2)
{
  if (is_tracepoint (loc1->owner) && is_tracepoint (loc2->owner))
    /* Since tracepoint locations are never duplicated with others', tracepoint
       locations at the same address of different tracepoints are regarded as
       different locations.  */
    return (loc1->address == loc2->address && loc1->owner == loc2->owner);
  else
    return 0;
}

/* Assuming LOC1 and LOC2's types' have meaningful target addresses
   (breakpoint_address_is_meaningful), returns true if LOC1 and LOC2
   represent the same location.  */

static int
breakpoint_locations_match (struct bp_location *loc1, 
			    struct bp_location *loc2)
{
  int hw_point1, hw_point2;

  /* Both of them must not be in moribund_locations.  */
  gdb_assert (loc1->owner != NULL);
  gdb_assert (loc2->owner != NULL);

  hw_point1 = is_hardware_watchpoint (loc1->owner);
  hw_point2 = is_hardware_watchpoint (loc2->owner);

  if (hw_point1 != hw_point2)
    return 0;
  else if (hw_point1)
    return watchpoint_locations_match (loc1, loc2);
  else if (is_tracepoint (loc1->owner) || is_tracepoint (loc2->owner))
    return tracepoint_locations_match (loc1, loc2);
  else
    /* We compare bp_location.length in order to cover ranged breakpoints.  */
    return (breakpoint_address_match (loc1->pspace->aspace, loc1->address,
				     loc2->pspace->aspace, loc2->address)
	    && loc1->length == loc2->length);
}

static void
breakpoint_adjustment_warning (CORE_ADDR from_addr, CORE_ADDR to_addr,
                               int bnum, int have_bnum)
{
  /* The longest string possibly returned by hex_string_custom
     is 50 chars.  These must be at least that big for safety.  */
  char astr1[64];
  char astr2[64];

  strcpy (astr1, hex_string_custom ((unsigned long) from_addr, 8));
  strcpy (astr2, hex_string_custom ((unsigned long) to_addr, 8));
  if (have_bnum)
    warning (_("Breakpoint %d address previously adjusted from %s to %s."),
             bnum, astr1, astr2);
  else
    warning (_("Breakpoint address adjusted from %s to %s."), astr1, astr2);
}

/* Adjust a breakpoint's address to account for architectural
   constraints on breakpoint placement.  Return the adjusted address.
   Note: Very few targets require this kind of adjustment.  For most
   targets, this function is simply the identity function.  */

static CORE_ADDR
adjust_breakpoint_address (struct gdbarch *gdbarch,
			   CORE_ADDR bpaddr, enum bptype bptype)
{
  if (!gdbarch_adjust_breakpoint_address_p (gdbarch))
    {
      /* Very few targets need any kind of breakpoint adjustment.  */
      return bpaddr;
    }
  else if (bptype == bp_watchpoint
           || bptype == bp_hardware_watchpoint
           || bptype == bp_read_watchpoint
           || bptype == bp_access_watchpoint
           || bptype == bp_catchpoint)
    {
      /* Watchpoints and the various bp_catch_* eventpoints should not
         have their addresses modified.  */
      return bpaddr;
    }
  else
    {
      CORE_ADDR adjusted_bpaddr;

      /* Some targets have architectural constraints on the placement
         of breakpoint instructions.  Obtain the adjusted address.  */
      adjusted_bpaddr = gdbarch_adjust_breakpoint_address (gdbarch, bpaddr);

      /* An adjusted breakpoint address can significantly alter
         a user's expectations.  Print a warning if an adjustment
	 is required.  */
      if (adjusted_bpaddr != bpaddr)
	breakpoint_adjustment_warning (bpaddr, adjusted_bpaddr, 0, 0);

      return adjusted_bpaddr;
    }
}

void
init_bp_location (struct bp_location *loc, const struct bp_location_ops *ops,
		  struct breakpoint *owner)
{
  memset (loc, 0, sizeof (*loc));

  gdb_assert (ops != NULL);

  loc->ops = ops;
  loc->owner = owner;
  loc->cond = NULL;
  loc->cond_bytecode = NULL;
  loc->shlib_disabled = 0;
  loc->enabled = 1;

  switch (owner->type)
    {
    case bp_breakpoint:
    case bp_until:
    case bp_finish:
    case bp_longjmp:
    case bp_longjmp_resume:
    case bp_longjmp_call_dummy:
    case bp_exception:
    case bp_exception_resume:
    case bp_step_resume:
    case bp_hp_step_resume:
    case bp_watchpoint_scope:
    case bp_call_dummy:
    case bp_std_terminate:
    case bp_shlib_event:
    case bp_thread_event:
    case bp_overlay_event:
    case bp_jit_event:
    case bp_longjmp_master:
    case bp_std_terminate_master:
    case bp_exception_master:
    case bp_gnu_ifunc_resolver:
    case bp_gnu_ifunc_resolver_return:
    case bp_dprintf:
      loc->loc_type = bp_loc_software_breakpoint;
      mark_breakpoint_location_modified (loc);
      break;
    case bp_hardware_breakpoint:
      loc->loc_type = bp_loc_hardware_breakpoint;
      mark_breakpoint_location_modified (loc);
      break;
    case bp_hardware_watchpoint:
    case bp_read_watchpoint:
    case bp_access_watchpoint:
      loc->loc_type = bp_loc_hardware_watchpoint;
      break;
    case bp_watchpoint:
    case bp_catchpoint:
    case bp_tracepoint:
    case bp_fast_tracepoint:
    case bp_static_tracepoint:
      loc->loc_type = bp_loc_other;
      break;
    default:
      internal_error (__FILE__, __LINE__, _("unknown breakpoint type"));
    }

  loc->refc = 1;
}

/* Allocate a struct bp_location.  */

static struct bp_location *
allocate_bp_location (struct breakpoint *bpt)
{
  return bpt->ops->allocate_location (bpt);
}

static void
free_bp_location (struct bp_location *loc)
{
  loc->ops->dtor (loc);
  xfree (loc);
}

/* Increment reference count.  */

static void
incref_bp_location (struct bp_location *bl)
{
  ++bl->refc;
}

/* Decrement reference count.  If the reference count reaches 0,
   destroy the bp_location.  Sets *BLP to NULL.  */

static void
decref_bp_location (struct bp_location **blp)
{
  gdb_assert ((*blp)->refc > 0);

  if (--(*blp)->refc == 0)
    free_bp_location (*blp);
  *blp = NULL;
}

/* Add breakpoint B at the end of the global breakpoint chain.  */

static void
add_to_breakpoint_chain (struct breakpoint *b)
{
  struct breakpoint *b1;

  /* Add this breakpoint to the end of the chain so that a list of
     breakpoints will come out in order of increasing numbers.  */

  b1 = breakpoint_chain;
  if (b1 == 0)
    breakpoint_chain = b;
  else
    {
      while (b1->next)
	b1 = b1->next;
      b1->next = b;
    }
}

/* Initializes breakpoint B with type BPTYPE and no locations yet.  */

static void
init_raw_breakpoint_without_location (struct breakpoint *b,
				      struct gdbarch *gdbarch,
				      enum bptype bptype,
				      const struct breakpoint_ops *ops)
{
  memset (b, 0, sizeof (*b));

  gdb_assert (ops != NULL);

  b->ops = ops;
  b->type = bptype;
  b->gdbarch = gdbarch;
  b->language = current_language->la_language;
  b->input_radix = input_radix;
  b->thread = -1;
  b->enable_state = bp_enabled;
  b->next = 0;
  b->silent = 0;
  b->ignore_count = 0;
  b->commands = NULL;
  b->frame_id = null_frame_id;
  b->condition_not_parsed = 0;
  b->py_bp_object = NULL;
  b->related_breakpoint = b;
}

/* Helper to set_raw_breakpoint below.  Creates a breakpoint
   that has type BPTYPE and has no locations as yet.  */

static struct breakpoint *
set_raw_breakpoint_without_location (struct gdbarch *gdbarch,
				     enum bptype bptype,
				     const struct breakpoint_ops *ops)
{
  struct breakpoint *b = XNEW (struct breakpoint);

  init_raw_breakpoint_without_location (b, gdbarch, bptype, ops);
  add_to_breakpoint_chain (b);
  return b;
}

/* Initialize loc->function_name.  EXPLICIT_LOC says no indirect function
   resolutions should be made as the user specified the location explicitly
   enough.  */

static void
set_breakpoint_location_function (struct bp_location *loc, int explicit_loc)
{
  gdb_assert (loc->owner != NULL);

  if (loc->owner->type == bp_breakpoint
      || loc->owner->type == bp_hardware_breakpoint
      || is_tracepoint (loc->owner))
    {
      int is_gnu_ifunc;
      const char *function_name;
      CORE_ADDR func_addr;

      find_pc_partial_function_gnu_ifunc (loc->address, &function_name,
					  &func_addr, NULL, &is_gnu_ifunc);

      if (is_gnu_ifunc && !explicit_loc)
	{
	  struct breakpoint *b = loc->owner;

	  gdb_assert (loc->pspace == current_program_space);
	  if (gnu_ifunc_resolve_name (function_name,
				      &loc->requested_address))
	    {
	      /* Recalculate ADDRESS based on new REQUESTED_ADDRESS.  */
	      loc->address = adjust_breakpoint_address (loc->gdbarch,
							loc->requested_address,
							b->type);
	    }
	  else if (b->type == bp_breakpoint && b->loc == loc
	           && loc->next == NULL && b->related_breakpoint == b)
	    {
	      /* Create only the whole new breakpoint of this type but do not
		 mess more complicated breakpoints with multiple locations.  */
	      b->type = bp_gnu_ifunc_resolver;
	      /* Remember the resolver's address for use by the return
	         breakpoint.  */
	      loc->related_address = func_addr;
	    }
	}

      if (function_name)
	loc->function_name = xstrdup (function_name);
    }
}

/* Attempt to determine architecture of location identified by SAL.  */
struct gdbarch *
get_sal_arch (struct symtab_and_line sal)
{
  if (sal.section)
    return get_objfile_arch (sal.section->objfile);
  if (sal.symtab)
    return get_objfile_arch (sal.symtab->objfile);

  return NULL;
}

/* Low level routine for partially initializing a breakpoint of type
   BPTYPE.  The newly created breakpoint's address, section, source
   file name, and line number are provided by SAL.

   It is expected that the caller will complete the initialization of
   the newly created breakpoint struct as well as output any status
   information regarding the creation of a new breakpoint.  */

static void
init_raw_breakpoint (struct breakpoint *b, struct gdbarch *gdbarch,
		     struct symtab_and_line sal, enum bptype bptype,
		     const struct breakpoint_ops *ops)
{
  init_raw_breakpoint_without_location (b, gdbarch, bptype, ops);

  add_location_to_breakpoint (b, &sal);

  if (bptype != bp_catchpoint)
    gdb_assert (sal.pspace != NULL);

  /* Store the program space that was used to set the breakpoint,
     except for ordinary breakpoints, which are independent of the
     program space.  */
  if (bptype != bp_breakpoint && bptype != bp_hardware_breakpoint)
    b->pspace = sal.pspace;
}

/* set_raw_breakpoint is a low level routine for allocating and
   partially initializing a breakpoint of type BPTYPE.  The newly
   created breakpoint's address, section, source file name, and line
   number are provided by SAL.  The newly created and partially
   initialized breakpoint is added to the breakpoint chain and
   is also returned as the value of this function.

   It is expected that the caller will complete the initialization of
   the newly created breakpoint struct as well as output any status
   information regarding the creation of a new breakpoint.  In
   particular, set_raw_breakpoint does NOT set the breakpoint
   number!  Care should be taken to not allow an error to occur
   prior to completing the initialization of the breakpoint.  If this
   should happen, a bogus breakpoint will be left on the chain.  */

struct breakpoint *
set_raw_breakpoint (struct gdbarch *gdbarch,
		    struct symtab_and_line sal, enum bptype bptype,
		    const struct breakpoint_ops *ops)
{
  struct breakpoint *b = XNEW (struct breakpoint);

  init_raw_breakpoint (b, gdbarch, sal, bptype, ops);
  add_to_breakpoint_chain (b);
  return b;
}


/* Note that the breakpoint object B describes a permanent breakpoint
   instruction, hard-wired into the inferior's code.  */
void
make_breakpoint_permanent (struct breakpoint *b)
{
  struct bp_location *bl;

  b->enable_state = bp_permanent;

  /* By definition, permanent breakpoints are already present in the
     code.  Mark all locations as inserted.  For now,
     make_breakpoint_permanent is called in just one place, so it's
     hard to say if it's reasonable to have permanent breakpoint with
     multiple locations or not, but it's easy to implement.  */
  for (bl = b->loc; bl; bl = bl->next)
    bl->inserted = 1;
}

/* Call this routine when stepping and nexting to enable a breakpoint
   if we do a longjmp() or 'throw' in TP.  FRAME is the frame which
   initiated the operation.  */

void
set_longjmp_breakpoint (struct thread_info *tp, struct frame_id frame)
{
  struct breakpoint *b, *b_tmp;
  int thread = tp->num;

  /* To avoid having to rescan all objfile symbols at every step,
     we maintain a list of continually-inserted but always disabled
     longjmp "master" breakpoints.  Here, we simply create momentary
     clones of those and enable them for the requested thread.  */
  ALL_BREAKPOINTS_SAFE (b, b_tmp)
    if (b->pspace == current_program_space
	&& (b->type == bp_longjmp_master
	    || b->type == bp_exception_master))
      {
	enum bptype type = b->type == bp_longjmp_master ? bp_longjmp : bp_exception;
	struct breakpoint *clone;

	/* longjmp_breakpoint_ops ensures INITIATING_FRAME is cleared again
	   after their removal.  */
	clone = momentary_breakpoint_from_master (b, type,
						  &longjmp_breakpoint_ops);
	clone->thread = thread;
      }

  tp->initiating_frame = frame;
}

/* Delete all longjmp breakpoints from THREAD.  */
void
delete_longjmp_breakpoint (int thread)
{
  struct breakpoint *b, *b_tmp;

  ALL_BREAKPOINTS_SAFE (b, b_tmp)
    if (b->type == bp_longjmp || b->type == bp_exception)
      {
	if (b->thread == thread)
	  delete_breakpoint (b);
      }
}

void
delete_longjmp_breakpoint_at_next_stop (int thread)
{
  struct breakpoint *b, *b_tmp;

  ALL_BREAKPOINTS_SAFE (b, b_tmp)
    if (b->type == bp_longjmp || b->type == bp_exception)
      {
	if (b->thread == thread)
	  b->disposition = disp_del_at_next_stop;
      }
}

/* Place breakpoints of type bp_longjmp_call_dummy to catch longjmp for
   INFERIOR_PTID thread.  Chain them all by RELATED_BREAKPOINT and return
   pointer to any of them.  Return NULL if this system cannot place longjmp
   breakpoints.  */

struct breakpoint *
set_longjmp_breakpoint_for_call_dummy (void)
{
  struct breakpoint *b, *retval = NULL;

  ALL_BREAKPOINTS (b)
    if (b->pspace == current_program_space && b->type == bp_longjmp_master)
      {
	struct breakpoint *new_b;

	new_b = momentary_breakpoint_from_master (b, bp_longjmp_call_dummy,
						  &momentary_breakpoint_ops);
	new_b->thread = pid_to_thread_id (inferior_ptid);

	/* Link NEW_B into the chain of RETVAL breakpoints.  */

	gdb_assert (new_b->related_breakpoint == new_b);
	if (retval == NULL)
	  retval = new_b;
	new_b->related_breakpoint = retval;
	while (retval->related_breakpoint != new_b->related_breakpoint)
	  retval = retval->related_breakpoint;
	retval->related_breakpoint = new_b;
      }

  return retval;
}

/* Verify all existing dummy frames and their associated breakpoints for
   THREAD.  Remove those which can no longer be found in the current frame
   stack.

   You should call this function only at places where it is safe to currently
   unwind the whole stack.  Failed stack unwind would discard live dummy
   frames.  */

void
check_longjmp_breakpoint_for_call_dummy (int thread)
{
  struct breakpoint *b, *b_tmp;

  ALL_BREAKPOINTS_SAFE (b, b_tmp)
    if (b->type == bp_longjmp_call_dummy && b->thread == thread)
      {
	struct breakpoint *dummy_b = b->related_breakpoint;

	while (dummy_b != b && dummy_b->type != bp_call_dummy)
	  dummy_b = dummy_b->related_breakpoint;
	if (dummy_b->type != bp_call_dummy
	    || frame_find_by_id (dummy_b->frame_id) != NULL)
	  continue;
	
	dummy_frame_discard (dummy_b->frame_id);

	while (b->related_breakpoint != b)
	  {
	    if (b_tmp == b->related_breakpoint)
	      b_tmp = b->related_breakpoint->next;
	    delete_breakpoint (b->related_breakpoint);
	  }
	delete_breakpoint (b);
      }
}

void
enable_overlay_breakpoints (void)
{
  struct breakpoint *b;

  ALL_BREAKPOINTS (b)
    if (b->type == bp_overlay_event)
    {
      b->enable_state = bp_enabled;
      update_global_location_list (1);
      overlay_events_enabled = 1;
    }
}

void
disable_overlay_breakpoints (void)
{
  struct breakpoint *b;

  ALL_BREAKPOINTS (b)
    if (b->type == bp_overlay_event)
    {
      b->enable_state = bp_disabled;
      update_global_location_list (0);
      overlay_events_enabled = 0;
    }
}

/* Set an active std::terminate breakpoint for each std::terminate
   master breakpoint.  */
void
set_std_terminate_breakpoint (void)
{
  struct breakpoint *b, *b_tmp;

  ALL_BREAKPOINTS_SAFE (b, b_tmp)
    if (b->pspace == current_program_space
	&& b->type == bp_std_terminate_master)
      {
	momentary_breakpoint_from_master (b, bp_std_terminate,
					  &momentary_breakpoint_ops);
      }
}

/* Delete all the std::terminate breakpoints.  */
void
delete_std_terminate_breakpoint (void)
{
  struct breakpoint *b, *b_tmp;

  ALL_BREAKPOINTS_SAFE (b, b_tmp)
    if (b->type == bp_std_terminate)
      delete_breakpoint (b);
}

struct breakpoint *
create_thread_event_breakpoint (struct gdbarch *gdbarch, CORE_ADDR address)
{
  struct breakpoint *b;

  b = create_internal_breakpoint (gdbarch, address, bp_thread_event,
				  &internal_breakpoint_ops);

  b->enable_state = bp_enabled;
  /* addr_string has to be used or breakpoint_re_set will delete me.  */
  b->addr_string
    = xstrprintf ("*%s", paddress (b->loc->gdbarch, b->loc->address));

  update_global_location_list_nothrow (1);

  return b;
}

void
remove_thread_event_breakpoints (void)
{
  struct breakpoint *b, *b_tmp;

  ALL_BREAKPOINTS_SAFE (b, b_tmp)
    if (b->type == bp_thread_event
	&& b->loc->pspace == current_program_space)
      delete_breakpoint (b);
}

struct lang_and_radix
  {
    enum language lang;
    int radix;
  };

/* Create a breakpoint for JIT code registration and unregistration.  */

struct breakpoint *
create_jit_event_breakpoint (struct gdbarch *gdbarch, CORE_ADDR address)
{
  struct breakpoint *b;

  b = create_internal_breakpoint (gdbarch, address, bp_jit_event,
				  &internal_breakpoint_ops);
  update_global_location_list_nothrow (1);
  return b;
}

/* Remove JIT code registration and unregistration breakpoint(s).  */

void
remove_jit_event_breakpoints (void)
{
  struct breakpoint *b, *b_tmp;

  ALL_BREAKPOINTS_SAFE (b, b_tmp)
    if (b->type == bp_jit_event
	&& b->loc->pspace == current_program_space)
      delete_breakpoint (b);
}

void
remove_solib_event_breakpoints (void)
{
  struct breakpoint *b, *b_tmp;

  ALL_BREAKPOINTS_SAFE (b, b_tmp)
    if (b->type == bp_shlib_event
	&& b->loc->pspace == current_program_space)
      delete_breakpoint (b);
}

struct breakpoint *
create_solib_event_breakpoint (struct gdbarch *gdbarch, CORE_ADDR address)
{
  struct breakpoint *b;

  b = create_internal_breakpoint (gdbarch, address, bp_shlib_event,
				  &internal_breakpoint_ops);
  update_global_location_list_nothrow (1);
  return b;
}

/* Disable any breakpoints that are on code in shared libraries.  Only
   apply to enabled breakpoints, disabled ones can just stay disabled.  */

void
disable_breakpoints_in_shlibs (void)
{
  struct bp_location *loc, **locp_tmp;

  ALL_BP_LOCATIONS (loc, locp_tmp)
  {
    /* ALL_BP_LOCATIONS bp_location has LOC->OWNER always non-NULL.  */
    struct breakpoint *b = loc->owner;

    /* We apply the check to all breakpoints, including disabled for
       those with loc->duplicate set.  This is so that when breakpoint
       becomes enabled, or the duplicate is removed, gdb will try to
       insert all breakpoints.  If we don't set shlib_disabled here,
       we'll try to insert those breakpoints and fail.  */
    if (((b->type == bp_breakpoint)
	 || (b->type == bp_jit_event)
	 || (b->type == bp_hardware_breakpoint)
	 || (is_tracepoint (b)))
	&& loc->pspace == current_program_space
	&& !loc->shlib_disabled
	&& solib_name_from_address (loc->pspace, loc->address)
	)
      {
	loc->shlib_disabled = 1;
      }
  }
}

/* Disable any breakpoints and tracepoints that are in an unloaded shared
   library.  Only apply to enabled breakpoints, disabled ones can just stay
   disabled.  */

static void
disable_breakpoints_in_unloaded_shlib (struct so_list *solib)
{
  struct bp_location *loc, **locp_tmp;
  int disabled_shlib_breaks = 0;

  /* SunOS a.out shared libraries are always mapped, so do not
     disable breakpoints; they will only be reported as unloaded
     through clear_solib when GDB discards its shared library
     list.  See clear_solib for more information.  */
  if (exec_bfd != NULL
      && bfd_get_flavour (exec_bfd) == bfd_target_aout_flavour)
    return;

  ALL_BP_LOCATIONS (loc, locp_tmp)
  {
    /* ALL_BP_LOCATIONS bp_location has LOC->OWNER always non-NULL.  */
    struct breakpoint *b = loc->owner;

    if (solib->pspace == loc->pspace
	&& !loc->shlib_disabled
	&& (((b->type == bp_breakpoint
	      || b->type == bp_jit_event
	      || b->type == bp_hardware_breakpoint)
	     && (loc->loc_type == bp_loc_hardware_breakpoint
		 || loc->loc_type == bp_loc_software_breakpoint))
	    || is_tracepoint (b))
	&& solib_contains_address_p (solib, loc->address))
      {
	loc->shlib_disabled = 1;
	/* At this point, we cannot rely on remove_breakpoint
	   succeeding so we must mark the breakpoint as not inserted
	   to prevent future errors occurring in remove_breakpoints.  */
	loc->inserted = 0;

	/* This may cause duplicate notifications for the same breakpoint.  */
	observer_notify_breakpoint_modified (b);

	if (!disabled_shlib_breaks)
	  {
	    target_terminal_ours_for_output ();
	    warning (_("Temporarily disabling breakpoints "
		       "for unloaded shared library \"%s\""),
		     solib->so_name);
	  }
	disabled_shlib_breaks = 1;
      }
  }
}

/* FORK & VFORK catchpoints.  */

/* An instance of this type is used to represent a fork or vfork
   catchpoint.  It includes a "struct breakpoint" as a kind of base
   class; users downcast to "struct breakpoint *" when needed.  A
   breakpoint is really of this type iff its ops pointer points to
   CATCH_FORK_BREAKPOINT_OPS.  */

struct fork_catchpoint
{
  /* The base class.  */
  struct breakpoint base;

  /* Process id of a child process whose forking triggered this
     catchpoint.  This field is only valid immediately after this
     catchpoint has triggered.  */
  ptid_t forked_inferior_pid;
};

/* Implement the "insert" breakpoint_ops method for fork
   catchpoints.  */

static int
insert_catch_fork (struct bp_location *bl)
{
  return target_insert_fork_catchpoint (ptid_get_pid (inferior_ptid));
}

/* Implement the "remove" breakpoint_ops method for fork
   catchpoints.  */

static int
remove_catch_fork (struct bp_location *bl)
{
  return target_remove_fork_catchpoint (ptid_get_pid (inferior_ptid));
}

/* Implement the "breakpoint_hit" breakpoint_ops method for fork
   catchpoints.  */

static int
breakpoint_hit_catch_fork (const struct bp_location *bl,
			   struct address_space *aspace, CORE_ADDR bp_addr,
			   const struct target_waitstatus *ws)
{
  struct fork_catchpoint *c = (struct fork_catchpoint *) bl->owner;

  if (ws->kind != TARGET_WAITKIND_FORKED)
    return 0;

  c->forked_inferior_pid = ws->value.related_pid;
  return 1;
}

/* Implement the "print_it" breakpoint_ops method for fork
   catchpoints.  */

static enum print_stop_action
print_it_catch_fork (bpstat bs)
{
  struct ui_out *uiout = current_uiout;
  struct breakpoint *b = bs->breakpoint_at;
  struct fork_catchpoint *c = (struct fork_catchpoint *) bs->breakpoint_at;

  annotate_catchpoint (b->number);
  if (b->disposition == disp_del)
    ui_out_text (uiout, "\nTemporary catchpoint ");
  else
    ui_out_text (uiout, "\nCatchpoint ");
  if (ui_out_is_mi_like_p (uiout))
    {
      ui_out_field_string (uiout, "reason",
			   async_reason_lookup (EXEC_ASYNC_FORK));
      ui_out_field_string (uiout, "disp", bpdisp_text (b->disposition));
    }
  ui_out_field_int (uiout, "bkptno", b->number);
  ui_out_text (uiout, " (forked process ");
  ui_out_field_int (uiout, "newpid", ptid_get_pid (c->forked_inferior_pid));
  ui_out_text (uiout, "), ");
  return PRINT_SRC_AND_LOC;
}

/* Implement the "print_one" breakpoint_ops method for fork
   catchpoints.  */

static void
print_one_catch_fork (struct breakpoint *b, struct bp_location **last_loc)
{
  struct fork_catchpoint *c = (struct fork_catchpoint *) b;
  struct value_print_options opts;
  struct ui_out *uiout = current_uiout;

  get_user_print_options (&opts);

  /* Field 4, the address, is omitted (which makes the columns not
     line up too nicely with the headers, but the effect is relatively
     readable).  */
  if (opts.addressprint)
    ui_out_field_skip (uiout, "addr");
  annotate_field (5);
  ui_out_text (uiout, "fork");
  if (!ptid_equal (c->forked_inferior_pid, null_ptid))
    {
      ui_out_text (uiout, ", process ");
      ui_out_field_int (uiout, "what",
                        ptid_get_pid (c->forked_inferior_pid));
      ui_out_spaces (uiout, 1);
    }

  if (ui_out_is_mi_like_p (uiout))
    ui_out_field_string (uiout, "catch-type", "fork");
}

/* Implement the "print_mention" breakpoint_ops method for fork
   catchpoints.  */

static void
print_mention_catch_fork (struct breakpoint *b)
{
  printf_filtered (_("Catchpoint %d (fork)"), b->number);
}

/* Implement the "print_recreate" breakpoint_ops method for fork
   catchpoints.  */

static void
print_recreate_catch_fork (struct breakpoint *b, struct ui_file *fp)
{
  fprintf_unfiltered (fp, "catch fork");
  print_recreate_thread (b, fp);
}

/* The breakpoint_ops structure to be used in fork catchpoints.  */

static struct breakpoint_ops catch_fork_breakpoint_ops;

/* Implement the "insert" breakpoint_ops method for vfork
   catchpoints.  */

static int
insert_catch_vfork (struct bp_location *bl)
{
  return target_insert_vfork_catchpoint (ptid_get_pid (inferior_ptid));
}

/* Implement the "remove" breakpoint_ops method for vfork
   catchpoints.  */

static int
remove_catch_vfork (struct bp_location *bl)
{
  return target_remove_vfork_catchpoint (ptid_get_pid (inferior_ptid));
}

/* Implement the "breakpoint_hit" breakpoint_ops method for vfork
   catchpoints.  */

static int
breakpoint_hit_catch_vfork (const struct bp_location *bl,
			    struct address_space *aspace, CORE_ADDR bp_addr,
			    const struct target_waitstatus *ws)
{
  struct fork_catchpoint *c = (struct fork_catchpoint *) bl->owner;

  if (ws->kind != TARGET_WAITKIND_VFORKED)
    return 0;

  c->forked_inferior_pid = ws->value.related_pid;
  return 1;
}

/* Implement the "print_it" breakpoint_ops method for vfork
   catchpoints.  */

static enum print_stop_action
print_it_catch_vfork (bpstat bs)
{
  struct ui_out *uiout = current_uiout;
  struct breakpoint *b = bs->breakpoint_at;
  struct fork_catchpoint *c = (struct fork_catchpoint *) b;

  annotate_catchpoint (b->number);
  if (b->disposition == disp_del)
    ui_out_text (uiout, "\nTemporary catchpoint ");
  else
    ui_out_text (uiout, "\nCatchpoint ");
  if (ui_out_is_mi_like_p (uiout))
    {
      ui_out_field_string (uiout, "reason",
			   async_reason_lookup (EXEC_ASYNC_VFORK));
      ui_out_field_string (uiout, "disp", bpdisp_text (b->disposition));
    }
  ui_out_field_int (uiout, "bkptno", b->number);
  ui_out_text (uiout, " (vforked process ");
  ui_out_field_int (uiout, "newpid", ptid_get_pid (c->forked_inferior_pid));
  ui_out_text (uiout, "), ");
  return PRINT_SRC_AND_LOC;
}

/* Implement the "print_one" breakpoint_ops method for vfork
   catchpoints.  */

static void
print_one_catch_vfork (struct breakpoint *b, struct bp_location **last_loc)
{
  struct fork_catchpoint *c = (struct fork_catchpoint *) b;
  struct value_print_options opts;
  struct ui_out *uiout = current_uiout;

  get_user_print_options (&opts);
  /* Field 4, the address, is omitted (which makes the columns not
     line up too nicely with the headers, but the effect is relatively
     readable).  */
  if (opts.addressprint)
    ui_out_field_skip (uiout, "addr");
  annotate_field (5);
  ui_out_text (uiout, "vfork");
  if (!ptid_equal (c->forked_inferior_pid, null_ptid))
    {
      ui_out_text (uiout, ", process ");
      ui_out_field_int (uiout, "what",
                        ptid_get_pid (c->forked_inferior_pid));
      ui_out_spaces (uiout, 1);
    }

  if (ui_out_is_mi_like_p (uiout))
    ui_out_field_string (uiout, "catch-type", "vfork");
}

/* Implement the "print_mention" breakpoint_ops method for vfork
   catchpoints.  */

static void
print_mention_catch_vfork (struct breakpoint *b)
{
  printf_filtered (_("Catchpoint %d (vfork)"), b->number);
}

/* Implement the "print_recreate" breakpoint_ops method for vfork
   catchpoints.  */

static void
print_recreate_catch_vfork (struct breakpoint *b, struct ui_file *fp)
{
  fprintf_unfiltered (fp, "catch vfork");
  print_recreate_thread (b, fp);
}

/* The breakpoint_ops structure to be used in vfork catchpoints.  */

static struct breakpoint_ops catch_vfork_breakpoint_ops;

/* An instance of this type is used to represent an solib catchpoint.
   It includes a "struct breakpoint" as a kind of base class; users
   downcast to "struct breakpoint *" when needed.  A breakpoint is
   really of this type iff its ops pointer points to
   CATCH_SOLIB_BREAKPOINT_OPS.  */

struct solib_catchpoint
{
  /* The base class.  */
  struct breakpoint base;

  /* True for "catch load", false for "catch unload".  */
  unsigned char is_load;

  /* Regular expression to match, if any.  COMPILED is only valid when
     REGEX is non-NULL.  */
  char *regex;
  regex_t compiled;
};

static void
dtor_catch_solib (struct breakpoint *b)
{
  struct solib_catchpoint *self = (struct solib_catchpoint *) b;

  if (self->regex)
    regfree (&self->compiled);
  xfree (self->regex);

  base_breakpoint_ops.dtor (b);
}

static int
insert_catch_solib (struct bp_location *ignore)
{
  return 0;
}

static int
remove_catch_solib (struct bp_location *ignore)
{
  return 0;
}

static int
breakpoint_hit_catch_solib (const struct bp_location *bl,
			    struct address_space *aspace,
			    CORE_ADDR bp_addr,
			    const struct target_waitstatus *ws)
{
  struct solib_catchpoint *self = (struct solib_catchpoint *) bl->owner;
  struct breakpoint *other;

  if (ws->kind == TARGET_WAITKIND_LOADED)
    return 1;

  ALL_BREAKPOINTS (other)
  {
    struct bp_location *other_bl;

    if (other == bl->owner)
      continue;

    if (other->type != bp_shlib_event)
      continue;

    if (self->base.pspace != NULL && other->pspace != self->base.pspace)
      continue;

    for (other_bl = other->loc; other_bl != NULL; other_bl = other_bl->next)
      {
	if (other->ops->breakpoint_hit (other_bl, aspace, bp_addr, ws))
	  return 1;
      }
  }

  return 0;
}

static void
check_status_catch_solib (struct bpstats *bs)
{
  struct solib_catchpoint *self
    = (struct solib_catchpoint *) bs->breakpoint_at;
  int ix;

  if (self->is_load)
    {
      struct so_list *iter;

      for (ix = 0;
	   VEC_iterate (so_list_ptr, current_program_space->added_solibs,
			ix, iter);
	   ++ix)
	{
	  if (!self->regex
	      || regexec (&self->compiled, iter->so_name, 0, NULL, 0) == 0)
	    return;
	}
    }
  else
    {
      char *iter;

      for (ix = 0;
	   VEC_iterate (char_ptr, current_program_space->deleted_solibs,
			ix, iter);
	   ++ix)
	{
	  if (!self->regex
	      || regexec (&self->compiled, iter, 0, NULL, 0) == 0)
	    return;
	}
    }

  bs->stop = 0;
  bs->print_it = print_it_noop;
}

static enum print_stop_action
print_it_catch_solib (bpstat bs)
{
  struct breakpoint *b = bs->breakpoint_at;
  struct ui_out *uiout = current_uiout;

  annotate_catchpoint (b->number);
  if (b->disposition == disp_del)
    ui_out_text (uiout, "\nTemporary catchpoint ");
  else
    ui_out_text (uiout, "\nCatchpoint ");
  ui_out_field_int (uiout, "bkptno", b->number);
  ui_out_text (uiout, "\n");
  if (ui_out_is_mi_like_p (uiout))
    ui_out_field_string (uiout, "disp", bpdisp_text (b->disposition));
  print_solib_event (1);
  return PRINT_SRC_AND_LOC;
}

static void
print_one_catch_solib (struct breakpoint *b, struct bp_location **locs)
{
  struct solib_catchpoint *self = (struct solib_catchpoint *) b;
  struct value_print_options opts;
  struct ui_out *uiout = current_uiout;
  char *msg;

  get_user_print_options (&opts);
  /* Field 4, the address, is omitted (which makes the columns not
     line up too nicely with the headers, but the effect is relatively
     readable).  */
  if (opts.addressprint)
    {
      annotate_field (4);
      ui_out_field_skip (uiout, "addr");
    }

  annotate_field (5);
  if (self->is_load)
    {
      if (self->regex)
	msg = xstrprintf (_("load of library matching %s"), self->regex);
      else
	msg = xstrdup (_("load of library"));
    }
  else
    {
      if (self->regex)
	msg = xstrprintf (_("unload of library matching %s"), self->regex);
      else
	msg = xstrdup (_("unload of library"));
    }
  ui_out_field_string (uiout, "what", msg);
  xfree (msg);

  if (ui_out_is_mi_like_p (uiout))
    ui_out_field_string (uiout, "catch-type",
			 self->is_load ? "load" : "unload");
}

static void
print_mention_catch_solib (struct breakpoint *b)
{
  struct solib_catchpoint *self = (struct solib_catchpoint *) b;

  printf_filtered (_("Catchpoint %d (%s)"), b->number,
		   self->is_load ? "load" : "unload");
}

static void
print_recreate_catch_solib (struct breakpoint *b, struct ui_file *fp)
{
  struct solib_catchpoint *self = (struct solib_catchpoint *) b;

  fprintf_unfiltered (fp, "%s %s",
		      b->disposition == disp_del ? "tcatch" : "catch",
		      self->is_load ? "load" : "unload");
  if (self->regex)
    fprintf_unfiltered (fp, " %s", self->regex);
  fprintf_unfiltered (fp, "\n");
}

static struct breakpoint_ops catch_solib_breakpoint_ops;

/* Shared helper function (MI and CLI) for creating and installing
   a shared object event catchpoint.  If IS_LOAD is non-zero then
   the events to be caught are load events, otherwise they are
   unload events.  If IS_TEMP is non-zero the catchpoint is a
   temporary one.  If ENABLED is non-zero the catchpoint is
   created in an enabled state.  */

void
add_solib_catchpoint (char *arg, int is_load, int is_temp, int enabled)
{
  struct solib_catchpoint *c;
  struct gdbarch *gdbarch = get_current_arch ();
  struct cleanup *cleanup;

  if (!arg)
    arg = "";
  arg = skip_spaces (arg);

  c = XCNEW (struct solib_catchpoint);
  cleanup = make_cleanup (xfree, c);

  if (*arg != '\0')
    {
      int errcode;

      errcode = regcomp (&c->compiled, arg, REG_NOSUB);
      if (errcode != 0)
	{
	  char *err = get_regcomp_error (errcode, &c->compiled);

	  make_cleanup (xfree, err);
	  error (_("Invalid regexp (%s): %s"), err, arg);
	}
      c->regex = xstrdup (arg);
    }

  c->is_load = is_load;
  init_catchpoint (&c->base, gdbarch, is_temp, NULL,
		   &catch_solib_breakpoint_ops);

  c->base.enable_state = enabled ? bp_enabled : bp_disabled;

  discard_cleanups (cleanup);
  install_breakpoint (0, &c->base, 1);
}

/* A helper function that does all the work for "catch load" and
   "catch unload".  */

static void
catch_load_or_unload (char *arg, int from_tty, int is_load,
		      struct cmd_list_element *command)
{
  int tempflag;
  const int enabled = 1;

  tempflag = get_cmd_context (command) == CATCH_TEMPORARY;

  add_solib_catchpoint (arg, is_load, tempflag, enabled);
}

static void
catch_load_command_1 (char *arg, int from_tty,
		      struct cmd_list_element *command)
{
  catch_load_or_unload (arg, from_tty, 1, command);
}

static void
catch_unload_command_1 (char *arg, int from_tty,
			struct cmd_list_element *command)
{
  catch_load_or_unload (arg, from_tty, 0, command);
}

/* An instance of this type is used to represent a syscall catchpoint.
   It includes a "struct breakpoint" as a kind of base class; users
   downcast to "struct breakpoint *" when needed.  A breakpoint is
   really of this type iff its ops pointer points to
   CATCH_SYSCALL_BREAKPOINT_OPS.  */

struct syscall_catchpoint
{
  /* The base class.  */
  struct breakpoint base;

  /* Syscall numbers used for the 'catch syscall' feature.  If no
     syscall has been specified for filtering, its value is NULL.
     Otherwise, it holds a list of all syscalls to be caught.  The
     list elements are allocated with xmalloc.  */
  VEC(int) *syscalls_to_be_caught;
};

/* Implement the "dtor" breakpoint_ops method for syscall
   catchpoints.  */

static void
dtor_catch_syscall (struct breakpoint *b)
{
  struct syscall_catchpoint *c = (struct syscall_catchpoint *) b;

  VEC_free (int, c->syscalls_to_be_caught);

  base_breakpoint_ops.dtor (b);
}

static const struct inferior_data *catch_syscall_inferior_data = NULL;

struct catch_syscall_inferior_data
{
  /* We keep a count of the number of times the user has requested a
     particular syscall to be tracked, and pass this information to the
     target.  This lets capable targets implement filtering directly.  */

  /* Number of times that "any" syscall is requested.  */
  int any_syscall_count;

  /* Count of each system call.  */
  VEC(int) *syscalls_counts;

  /* This counts all syscall catch requests, so we can readily determine
     if any catching is necessary.  */
  int total_syscalls_count;
};

static struct catch_syscall_inferior_data*
get_catch_syscall_inferior_data (struct inferior *inf)
{
  struct catch_syscall_inferior_data *inf_data;

  inf_data = inferior_data (inf, catch_syscall_inferior_data);
  if (inf_data == NULL)
    {
      inf_data = XZALLOC (struct catch_syscall_inferior_data);
      set_inferior_data (inf, catch_syscall_inferior_data, inf_data);
    }

  return inf_data;
}

static void
catch_syscall_inferior_data_cleanup (struct inferior *inf, void *arg)
{
  xfree (arg);
}


/* Implement the "insert" breakpoint_ops method for syscall
   catchpoints.  */

static int
insert_catch_syscall (struct bp_location *bl)
{
  struct syscall_catchpoint *c = (struct syscall_catchpoint *) bl->owner;
  struct inferior *inf = current_inferior ();
  struct catch_syscall_inferior_data *inf_data
    = get_catch_syscall_inferior_data (inf);

  ++inf_data->total_syscalls_count;
  if (!c->syscalls_to_be_caught)
    ++inf_data->any_syscall_count;
  else
    {
      int i, iter;

      for (i = 0;
           VEC_iterate (int, c->syscalls_to_be_caught, i, iter);
           i++)
	{
          int elem;

	  if (iter >= VEC_length (int, inf_data->syscalls_counts))
	    {
              int old_size = VEC_length (int, inf_data->syscalls_counts);
              uintptr_t vec_addr_offset
		= old_size * ((uintptr_t) sizeof (int));
              uintptr_t vec_addr;
              VEC_safe_grow (int, inf_data->syscalls_counts, iter + 1);
              vec_addr = ((uintptr_t) VEC_address (int,
						  inf_data->syscalls_counts)
			  + vec_addr_offset);
              memset ((void *) vec_addr, 0,
                      (iter + 1 - old_size) * sizeof (int));
	    }
          elem = VEC_index (int, inf_data->syscalls_counts, iter);
          VEC_replace (int, inf_data->syscalls_counts, iter, ++elem);
	}
    }

  return target_set_syscall_catchpoint (ptid_get_pid (inferior_ptid),
					inf_data->total_syscalls_count != 0,
					inf_data->any_syscall_count,
					VEC_length (int,
						    inf_data->syscalls_counts),
					VEC_address (int,
						     inf_data->syscalls_counts));
}

/* Implement the "remove" breakpoint_ops method for syscall
   catchpoints.  */

static int
remove_catch_syscall (struct bp_location *bl)
{
  struct syscall_catchpoint *c = (struct syscall_catchpoint *) bl->owner;
  struct inferior *inf = current_inferior ();
  struct catch_syscall_inferior_data *inf_data
    = get_catch_syscall_inferior_data (inf);

  --inf_data->total_syscalls_count;
  if (!c->syscalls_to_be_caught)
    --inf_data->any_syscall_count;
  else
    {
      int i, iter;

      for (i = 0;
           VEC_iterate (int, c->syscalls_to_be_caught, i, iter);
           i++)
	{
          int elem;
	  if (iter >= VEC_length (int, inf_data->syscalls_counts))
	    /* Shouldn't happen.  */
	    continue;
          elem = VEC_index (int, inf_data->syscalls_counts, iter);
          VEC_replace (int, inf_data->syscalls_counts, iter, --elem);
        }
    }

  return target_set_syscall_catchpoint (ptid_get_pid (inferior_ptid),
					inf_data->total_syscalls_count != 0,
					inf_data->any_syscall_count,
					VEC_length (int,
						    inf_data->syscalls_counts),
					VEC_address (int,
						     inf_data->syscalls_counts));
}

/* Implement the "breakpoint_hit" breakpoint_ops method for syscall
   catchpoints.  */

static int
breakpoint_hit_catch_syscall (const struct bp_location *bl,
			      struct address_space *aspace, CORE_ADDR bp_addr,
			      const struct target_waitstatus *ws)
{
  /* We must check if we are catching specific syscalls in this
     breakpoint.  If we are, then we must guarantee that the called
     syscall is the same syscall we are catching.  */
  int syscall_number = 0;
  const struct syscall_catchpoint *c
    = (const struct syscall_catchpoint *) bl->owner;

  if (ws->kind != TARGET_WAITKIND_SYSCALL_ENTRY
      && ws->kind != TARGET_WAITKIND_SYSCALL_RETURN)
    return 0;

  syscall_number = ws->value.syscall_number;

  /* Now, checking if the syscall is the same.  */
  if (c->syscalls_to_be_caught)
    {
      int i, iter;

      for (i = 0;
           VEC_iterate (int, c->syscalls_to_be_caught, i, iter);
           i++)
	if (syscall_number == iter)
	  break;
      /* Not the same.  */
      if (!iter)
	return 0;
    }

  return 1;
}

/* Implement the "print_it" breakpoint_ops method for syscall
   catchpoints.  */

static enum print_stop_action
print_it_catch_syscall (bpstat bs)
{
  struct ui_out *uiout = current_uiout;
  struct breakpoint *b = bs->breakpoint_at;
  /* These are needed because we want to know in which state a
     syscall is.  It can be in the TARGET_WAITKIND_SYSCALL_ENTRY
     or TARGET_WAITKIND_SYSCALL_RETURN, and depending on it we
     must print "called syscall" or "returned from syscall".  */
  ptid_t ptid;
  struct target_waitstatus last;
  struct syscall s;

  get_last_target_status (&ptid, &last);

  get_syscall_by_number (last.value.syscall_number, &s);

  annotate_catchpoint (b->number);

  if (b->disposition == disp_del)
    ui_out_text (uiout, "\nTemporary catchpoint ");
  else
    ui_out_text (uiout, "\nCatchpoint ");
  if (ui_out_is_mi_like_p (uiout))
    {
      ui_out_field_string (uiout, "reason",
			   async_reason_lookup (last.kind == TARGET_WAITKIND_SYSCALL_ENTRY
						? EXEC_ASYNC_SYSCALL_ENTRY
						: EXEC_ASYNC_SYSCALL_RETURN));
      ui_out_field_string (uiout, "disp", bpdisp_text (b->disposition));
    }
  ui_out_field_int (uiout, "bkptno", b->number);

  if (last.kind == TARGET_WAITKIND_SYSCALL_ENTRY)
    ui_out_text (uiout, " (call to syscall ");
  else
    ui_out_text (uiout, " (returned from syscall ");

  if (s.name == NULL || ui_out_is_mi_like_p (uiout))
    ui_out_field_int (uiout, "syscall-number", last.value.syscall_number);
  if (s.name != NULL)
    ui_out_field_string (uiout, "syscall-name", s.name);

  ui_out_text (uiout, "), ");

  return PRINT_SRC_AND_LOC;
}

/* Implement the "print_one" breakpoint_ops method for syscall
   catchpoints.  */

static void
print_one_catch_syscall (struct breakpoint *b,
			 struct bp_location **last_loc)
{
  struct syscall_catchpoint *c = (struct syscall_catchpoint *) b;
  struct value_print_options opts;
  struct ui_out *uiout = current_uiout;

  get_user_print_options (&opts);
  /* Field 4, the address, is omitted (which makes the columns not
     line up too nicely with the headers, but the effect is relatively
     readable).  */
  if (opts.addressprint)
    ui_out_field_skip (uiout, "addr");
  annotate_field (5);

  if (c->syscalls_to_be_caught
      && VEC_length (int, c->syscalls_to_be_caught) > 1)
    ui_out_text (uiout, "syscalls \"");
  else
    ui_out_text (uiout, "syscall \"");

  if (c->syscalls_to_be_caught)
    {
      int i, iter;
      char *text = xstrprintf ("%s", "");

      for (i = 0;
           VEC_iterate (int, c->syscalls_to_be_caught, i, iter);
           i++)
        {
          char *x = text;
          struct syscall s;
          get_syscall_by_number (iter, &s);

          if (s.name != NULL)
            text = xstrprintf ("%s%s, ", text, s.name);
          else
            text = xstrprintf ("%s%d, ", text, iter);

          /* We have to xfree the last 'text' (now stored at 'x')
             because xstrprintf dynamically allocates new space for it
             on every call.  */
	  xfree (x);
        }
      /* Remove the last comma.  */
      text[strlen (text) - 2] = '\0';
      ui_out_field_string (uiout, "what", text);
    }
  else
    ui_out_field_string (uiout, "what", "<any syscall>");
  ui_out_text (uiout, "\" ");

  if (ui_out_is_mi_like_p (uiout))
    ui_out_field_string (uiout, "catch-type", "syscall");
}

/* Implement the "print_mention" breakpoint_ops method for syscall
   catchpoints.  */

static void
print_mention_catch_syscall (struct breakpoint *b)
{
  struct syscall_catchpoint *c = (struct syscall_catchpoint *) b;

  if (c->syscalls_to_be_caught)
    {
      int i, iter;

      if (VEC_length (int, c->syscalls_to_be_caught) > 1)
        printf_filtered (_("Catchpoint %d (syscalls"), b->number);
      else
        printf_filtered (_("Catchpoint %d (syscall"), b->number);

      for (i = 0;
           VEC_iterate (int, c->syscalls_to_be_caught, i, iter);
           i++)
        {
          struct syscall s;
          get_syscall_by_number (iter, &s);

          if (s.name)
            printf_filtered (" '%s' [%d]", s.name, s.number);
          else
            printf_filtered (" %d", s.number);
        }
      printf_filtered (")");
    }
  else
    printf_filtered (_("Catchpoint %d (any syscall)"),
                     b->number);
}

/* Implement the "print_recreate" breakpoint_ops method for syscall
   catchpoints.  */

static void
print_recreate_catch_syscall (struct breakpoint *b, struct ui_file *fp)
{
  struct syscall_catchpoint *c = (struct syscall_catchpoint *) b;

  fprintf_unfiltered (fp, "catch syscall");

  if (c->syscalls_to_be_caught)
    {
      int i, iter;

      for (i = 0;
           VEC_iterate (int, c->syscalls_to_be_caught, i, iter);
           i++)
        {
          struct syscall s;

          get_syscall_by_number (iter, &s);
          if (s.name)
            fprintf_unfiltered (fp, " %s", s.name);
          else
            fprintf_unfiltered (fp, " %d", s.number);
        }
    }
  print_recreate_thread (b, fp);
}

/* The breakpoint_ops structure to be used in syscall catchpoints.  */

static struct breakpoint_ops catch_syscall_breakpoint_ops;

/* Returns non-zero if 'b' is a syscall catchpoint.  */

static int
syscall_catchpoint_p (struct breakpoint *b)
{
  return (b->ops == &catch_syscall_breakpoint_ops);
}

/* Initialize a new breakpoint of the bp_catchpoint kind.  If TEMPFLAG
   is non-zero, then make the breakpoint temporary.  If COND_STRING is
   not NULL, then store it in the breakpoint.  OPS, if not NULL, is
   the breakpoint_ops structure associated to the catchpoint.  */

void
init_catchpoint (struct breakpoint *b,
		 struct gdbarch *gdbarch, int tempflag,
		 char *cond_string,
		 const struct breakpoint_ops *ops)
{
  struct symtab_and_line sal;

  init_sal (&sal);
  sal.pspace = current_program_space;

  init_raw_breakpoint (b, gdbarch, sal, bp_catchpoint, ops);

  b->cond_string = (cond_string == NULL) ? NULL : xstrdup (cond_string);
  b->disposition = tempflag ? disp_del : disp_donttouch;
}

void
install_breakpoint (int internal, struct breakpoint *b, int update_gll)
{
  add_to_breakpoint_chain (b);
  set_breakpoint_number (internal, b);
  if (is_tracepoint (b))
    set_tracepoint_count (breakpoint_count);
  if (!internal)
    mention (b);
  observer_notify_breakpoint_created (b);

  if (update_gll)
    update_global_location_list (1);
}

static void
create_fork_vfork_event_catchpoint (struct gdbarch *gdbarch,
				    int tempflag, char *cond_string,
                                    const struct breakpoint_ops *ops)
{
  struct fork_catchpoint *c = XNEW (struct fork_catchpoint);

  init_catchpoint (&c->base, gdbarch, tempflag, cond_string, ops);

  c->forked_inferior_pid = null_ptid;

  install_breakpoint (0, &c->base, 1);
}

/* Exec catchpoints.  */

/* An instance of this type is used to represent an exec catchpoint.
   It includes a "struct breakpoint" as a kind of base class; users
   downcast to "struct breakpoint *" when needed.  A breakpoint is
   really of this type iff its ops pointer points to
   CATCH_EXEC_BREAKPOINT_OPS.  */

struct exec_catchpoint
{
  /* The base class.  */
  struct breakpoint base;

  /* Filename of a program whose exec triggered this catchpoint.
     This field is only valid immediately after this catchpoint has
     triggered.  */
  char *exec_pathname;
};

/* Implement the "dtor" breakpoint_ops method for exec
   catchpoints.  */

static void
dtor_catch_exec (struct breakpoint *b)
{
  struct exec_catchpoint *c = (struct exec_catchpoint *) b;

  xfree (c->exec_pathname);

  base_breakpoint_ops.dtor (b);
}

static int
insert_catch_exec (struct bp_location *bl)
{
  return target_insert_exec_catchpoint (ptid_get_pid (inferior_ptid));
}

static int
remove_catch_exec (struct bp_location *bl)
{
  return target_remove_exec_catchpoint (ptid_get_pid (inferior_ptid));
}

static int
breakpoint_hit_catch_exec (const struct bp_location *bl,
			   struct address_space *aspace, CORE_ADDR bp_addr,
			   const struct target_waitstatus *ws)
{
  struct exec_catchpoint *c = (struct exec_catchpoint *) bl->owner;

  if (ws->kind != TARGET_WAITKIND_EXECD)
    return 0;

  c->exec_pathname = xstrdup (ws->value.execd_pathname);
  return 1;
}

static enum print_stop_action
print_it_catch_exec (bpstat bs)
{
  struct ui_out *uiout = current_uiout;
  struct breakpoint *b = bs->breakpoint_at;
  struct exec_catchpoint *c = (struct exec_catchpoint *) b;

  annotate_catchpoint (b->number);
  if (b->disposition == disp_del)
    ui_out_text (uiout, "\nTemporary catchpoint ");
  else
    ui_out_text (uiout, "\nCatchpoint ");
  if (ui_out_is_mi_like_p (uiout))
    {
      ui_out_field_string (uiout, "reason",
			   async_reason_lookup (EXEC_ASYNC_EXEC));
      ui_out_field_string (uiout, "disp", bpdisp_text (b->disposition));
    }
  ui_out_field_int (uiout, "bkptno", b->number);
  ui_out_text (uiout, " (exec'd ");
  ui_out_field_string (uiout, "new-exec", c->exec_pathname);
  ui_out_text (uiout, "), ");

  return PRINT_SRC_AND_LOC;
}

static void
print_one_catch_exec (struct breakpoint *b, struct bp_location **last_loc)
{
  struct exec_catchpoint *c = (struct exec_catchpoint *) b;
  struct value_print_options opts;
  struct ui_out *uiout = current_uiout;

  get_user_print_options (&opts);

  /* Field 4, the address, is omitted (which makes the columns
     not line up too nicely with the headers, but the effect
     is relatively readable).  */
  if (opts.addressprint)
    ui_out_field_skip (uiout, "addr");
  annotate_field (5);
  ui_out_text (uiout, "exec");
  if (c->exec_pathname != NULL)
    {
      ui_out_text (uiout, ", program \"");
      ui_out_field_string (uiout, "what", c->exec_pathname);
      ui_out_text (uiout, "\" ");
    }

  if (ui_out_is_mi_like_p (uiout))
    ui_out_field_string (uiout, "catch-type", "exec");
}

static void
print_mention_catch_exec (struct breakpoint *b)
{
  printf_filtered (_("Catchpoint %d (exec)"), b->number);
}

/* Implement the "print_recreate" breakpoint_ops method for exec
   catchpoints.  */

static void
print_recreate_catch_exec (struct breakpoint *b, struct ui_file *fp)
{
  fprintf_unfiltered (fp, "catch exec");
  print_recreate_thread (b, fp);
}

static struct breakpoint_ops catch_exec_breakpoint_ops;

static void
create_syscall_event_catchpoint (int tempflag, VEC(int) *filter,
                                 const struct breakpoint_ops *ops)
{
  struct syscall_catchpoint *c;
  struct gdbarch *gdbarch = get_current_arch ();

  c = XNEW (struct syscall_catchpoint);
  init_catchpoint (&c->base, gdbarch, tempflag, NULL, ops);
  c->syscalls_to_be_caught = filter;

  install_breakpoint (0, &c->base, 1);
}

static int
hw_breakpoint_used_count (void)
{
  int i = 0;
  struct breakpoint *b;
  struct bp_location *bl;

  ALL_BREAKPOINTS (b)
  {
    if (b->type == bp_hardware_breakpoint && breakpoint_enabled (b))
      for (bl = b->loc; bl; bl = bl->next)
	{
	  /* Special types of hardware breakpoints may use more than
	     one register.  */
	  i += b->ops->resources_needed (bl);
	}
  }

  return i;
}

/* Returns the resources B would use if it were a hardware
   watchpoint.  */

static int
hw_watchpoint_use_count (struct breakpoint *b)
{
  int i = 0;
  struct bp_location *bl;

  if (!breakpoint_enabled (b))
    return 0;

  for (bl = b->loc; bl; bl = bl->next)
    {
      /* Special types of hardware watchpoints may use more than
	 one register.  */
      i += b->ops->resources_needed (bl);
    }

  return i;
}

/* Returns the sum the used resources of all hardware watchpoints of
   type TYPE in the breakpoints list.  Also returns in OTHER_TYPE_USED
   the sum of the used resources of all hardware watchpoints of other
   types _not_ TYPE.  */

static int
hw_watchpoint_used_count_others (struct breakpoint *except,
				 enum bptype type, int *other_type_used)
{
  int i = 0;
  struct breakpoint *b;

  *other_type_used = 0;
  ALL_BREAKPOINTS (b)
    {
      if (b == except)
	continue;
      if (!breakpoint_enabled (b))
	continue;

      if (b->type == type)
	i += hw_watchpoint_use_count (b);
      else if (is_hardware_watchpoint (b))
	*other_type_used = 1;
    }

  return i;
}

void
disable_watchpoints_before_interactive_call_start (void)
{
  struct breakpoint *b;

  ALL_BREAKPOINTS (b)
  {
    if (is_watchpoint (b) && breakpoint_enabled (b))
      {
	b->enable_state = bp_call_disabled;
	update_global_location_list (0);
      }
  }
}

void
enable_watchpoints_after_interactive_call_stop (void)
{
  struct breakpoint *b;

  ALL_BREAKPOINTS (b)
  {
    if (is_watchpoint (b) && b->enable_state == bp_call_disabled)
      {
	b->enable_state = bp_enabled;
	update_global_location_list (1);
      }
  }
}

void
disable_breakpoints_before_startup (void)
{
  current_program_space->executing_startup = 1;
  update_global_location_list (0);
}

void
enable_breakpoints_after_startup (void)
{
  current_program_space->executing_startup = 0;
  breakpoint_re_set ();
}


/* Set a breakpoint that will evaporate an end of command
   at address specified by SAL.
   Restrict it to frame FRAME if FRAME is nonzero.  */

struct breakpoint *
set_momentary_breakpoint (struct gdbarch *gdbarch, struct symtab_and_line sal,
			  struct frame_id frame_id, enum bptype type)
{
  struct breakpoint *b;

  /* If FRAME_ID is valid, it should be a real frame, not an inlined or
     tail-called one.  */
  gdb_assert (!frame_id_artificial_p (frame_id));

  b = set_raw_breakpoint (gdbarch, sal, type, &momentary_breakpoint_ops);
  b->enable_state = bp_enabled;
  b->disposition = disp_donttouch;
  b->frame_id = frame_id;

  /* If we're debugging a multi-threaded program, then we want
     momentary breakpoints to be active in only a single thread of
     control.  */
  if (in_thread_list (inferior_ptid))
    b->thread = pid_to_thread_id (inferior_ptid);

  update_global_location_list_nothrow (1);

  return b;
}

/* Make a momentary breakpoint based on the master breakpoint ORIG.
   The new breakpoint will have type TYPE, and use OPS as it
   breakpoint_ops.  */

static struct breakpoint *
momentary_breakpoint_from_master (struct breakpoint *orig,
				  enum bptype type,
				  const struct breakpoint_ops *ops)
{
  struct breakpoint *copy;

  copy = set_raw_breakpoint_without_location (orig->gdbarch, type, ops);
  copy->loc = allocate_bp_location (copy);
  set_breakpoint_location_function (copy->loc, 1);

  copy->loc->gdbarch = orig->loc->gdbarch;
  copy->loc->requested_address = orig->loc->requested_address;
  copy->loc->address = orig->loc->address;
  copy->loc->section = orig->loc->section;
  copy->loc->pspace = orig->loc->pspace;
  copy->loc->probe = orig->loc->probe;
  copy->loc->line_number = orig->loc->line_number;
  copy->loc->symtab = orig->loc->symtab;
  copy->frame_id = orig->frame_id;
  copy->thread = orig->thread;
  copy->pspace = orig->pspace;

  copy->enable_state = bp_enabled;
  copy->disposition = disp_donttouch;
  copy->number = internal_breakpoint_number--;

  update_global_location_list_nothrow (0);
  return copy;
}

/* Make a deep copy of momentary breakpoint ORIG.  Returns NULL if
   ORIG is NULL.  */

struct breakpoint *
clone_momentary_breakpoint (struct breakpoint *orig)
{
  /* If there's nothing to clone, then return nothing.  */
  if (orig == NULL)
    return NULL;

  return momentary_breakpoint_from_master (orig, orig->type, orig->ops);
}

struct breakpoint *
set_momentary_breakpoint_at_pc (struct gdbarch *gdbarch, CORE_ADDR pc,
				enum bptype type)
{
  struct symtab_and_line sal;

  sal = find_pc_line (pc, 0);
  sal.pc = pc;
  sal.section = find_pc_overlay (pc);
  sal.explicit_pc = 1;

  return set_momentary_breakpoint (gdbarch, sal, null_frame_id, type);
}


/* Tell the user we have just set a breakpoint B.  */

static void
mention (struct breakpoint *b)
{
  b->ops->print_mention (b);
  if (ui_out_is_mi_like_p (current_uiout))
    return;
  printf_filtered ("\n");
}


static struct bp_location *
add_location_to_breakpoint (struct breakpoint *b,
			    const struct symtab_and_line *sal)
{
  struct bp_location *loc, **tmp;
  CORE_ADDR adjusted_address;
  struct gdbarch *loc_gdbarch = get_sal_arch (*sal);

  if (loc_gdbarch == NULL)
    loc_gdbarch = b->gdbarch;

  /* Adjust the breakpoint's address prior to allocating a location.
     Once we call allocate_bp_location(), that mostly uninitialized
     location will be placed on the location chain.  Adjustment of the
     breakpoint may cause target_read_memory() to be called and we do
     not want its scan of the location chain to find a breakpoint and
     location that's only been partially initialized.  */
  adjusted_address = adjust_breakpoint_address (loc_gdbarch,
						sal->pc, b->type);

  /* Sort the locations by their ADDRESS.  */
  loc = allocate_bp_location (b);
  for (tmp = &(b->loc); *tmp != NULL && (*tmp)->address <= adjusted_address;
       tmp = &((*tmp)->next))
    ;
  loc->next = *tmp;
  *tmp = loc;

  loc->requested_address = sal->pc;
  loc->address = adjusted_address;
  loc->pspace = sal->pspace;
  loc->probe = sal->probe;
  gdb_assert (loc->pspace != NULL);
  loc->section = sal->section;
  loc->gdbarch = loc_gdbarch;
  loc->line_number = sal->line;
  loc->symtab = sal->symtab;

  set_breakpoint_location_function (loc,
				    sal->explicit_pc || sal->explicit_line);
  return loc;
}


/* Return 1 if LOC is pointing to a permanent breakpoint, 
   return 0 otherwise.  */

static int
bp_loc_is_permanent (struct bp_location *loc)
{
  int len;
  CORE_ADDR addr;
  const gdb_byte *bpoint;
  gdb_byte *target_mem;
  struct cleanup *cleanup;
  int retval = 0;

  gdb_assert (loc != NULL);

  addr = loc->address;
  bpoint = gdbarch_breakpoint_from_pc (loc->gdbarch, &addr, &len);

  /* Software breakpoints unsupported?  */
  if (bpoint == NULL)
    return 0;

  target_mem = alloca (len);

  /* Enable the automatic memory restoration from breakpoints while
     we read the memory.  Otherwise we could say about our temporary
     breakpoints they are permanent.  */
  cleanup = save_current_space_and_thread ();

  switch_to_program_space_and_thread (loc->pspace);
  make_show_memory_breakpoints_cleanup (0);

  if (target_read_memory (loc->address, target_mem, len) == 0
      && memcmp (target_mem, bpoint, len) == 0)
    retval = 1;

  do_cleanups (cleanup);

  return retval;
}

/* Build a command list for the dprintf corresponding to the current
   settings of the dprintf style options.  */

static void
update_dprintf_command_list (struct breakpoint *b)
{
  char *dprintf_args = b->extra_string;
  char *printf_line = NULL;

  if (!dprintf_args)
    return;

  dprintf_args = skip_spaces (dprintf_args);

  /* Allow a comma, as it may have terminated a location, but don't
     insist on it.  */
  if (*dprintf_args == ',')
    ++dprintf_args;
  dprintf_args = skip_spaces (dprintf_args);

  if (*dprintf_args != '"')
    error (_("Bad format string, missing '\"'."));

  if (strcmp (dprintf_style, dprintf_style_gdb) == 0)
    printf_line = xstrprintf ("printf %s", dprintf_args);
  else if (strcmp (dprintf_style, dprintf_style_call) == 0)
    {
      if (!dprintf_function)
	error (_("No function supplied for dprintf call"));

      if (dprintf_channel && strlen (dprintf_channel) > 0)
	printf_line = xstrprintf ("call (void) %s (%s,%s)",
				  dprintf_function,
				  dprintf_channel,
				  dprintf_args);
      else
	printf_line = xstrprintf ("call (void) %s (%s)",
				  dprintf_function,
				  dprintf_args);
    }
  else if (strcmp (dprintf_style, dprintf_style_agent) == 0)
    {
      if (target_can_run_breakpoint_commands ())
	printf_line = xstrprintf ("agent-printf %s", dprintf_args);
      else
	{
	  warning (_("Target cannot run dprintf commands, falling back to GDB printf"));
	  printf_line = xstrprintf ("printf %s", dprintf_args);
	}
    }
  else
    internal_error (__FILE__, __LINE__,
		    _("Invalid dprintf style."));

  gdb_assert (printf_line != NULL);
  /* Manufacture a printf sequence.  */
  {
    struct command_line *printf_cmd_line
      = xmalloc (sizeof (struct command_line));

    printf_cmd_line = xmalloc (sizeof (struct command_line));
    printf_cmd_line->control_type = simple_control;
    printf_cmd_line->body_count = 0;
    printf_cmd_line->body_list = NULL;
    printf_cmd_line->next = NULL;
    printf_cmd_line->line = printf_line;

    breakpoint_set_commands (b, printf_cmd_line);
  }
}

/* Update all dprintf commands, making their command lists reflect
   current style settings.  */

static void
update_dprintf_commands (char *args, int from_tty,
			 struct cmd_list_element *c)
{
  struct breakpoint *b;

  ALL_BREAKPOINTS (b)
    {
      if (b->type == bp_dprintf)
	update_dprintf_command_list (b);
    }
}

/* Create a breakpoint with SAL as location.  Use ADDR_STRING
   as textual description of the location, and COND_STRING
   as condition expression.  */

static void
init_breakpoint_sal (struct breakpoint *b, struct gdbarch *gdbarch,
		     struct symtabs_and_lines sals, char *addr_string,
		     char *filter, char *cond_string,
		     char *extra_string,
		     enum bptype type, enum bpdisp disposition,
		     int thread, int task, int ignore_count,
		     const struct breakpoint_ops *ops, int from_tty,
		     int enabled, int internal, unsigned flags,
		     int display_canonical)
{
  int i;

  if (type == bp_hardware_breakpoint)
    {
      int target_resources_ok;

      i = hw_breakpoint_used_count ();
      target_resources_ok =
	target_can_use_hardware_watchpoint (bp_hardware_breakpoint,
					    i + 1, 0);
      if (target_resources_ok == 0)
	error (_("No hardware breakpoint support in the target."));
      else if (target_resources_ok < 0)
	error (_("Hardware breakpoints used exceeds limit."));
    }

  gdb_assert (sals.nelts > 0);

  for (i = 0; i < sals.nelts; ++i)
    {
      struct symtab_and_line sal = sals.sals[i];
      struct bp_location *loc;

      if (from_tty)
	{
	  struct gdbarch *loc_gdbarch = get_sal_arch (sal);
	  if (!loc_gdbarch)
	    loc_gdbarch = gdbarch;

	  describe_other_breakpoints (loc_gdbarch,
				      sal.pspace, sal.pc, sal.section, thread);
	}

      if (i == 0)
	{
	  init_raw_breakpoint (b, gdbarch, sal, type, ops);
	  b->thread = thread;
	  b->task = task;

	  b->cond_string = cond_string;
	  b->extra_string = extra_string;
	  b->ignore_count = ignore_count;
	  b->enable_state = enabled ? bp_enabled : bp_disabled;
	  b->disposition = disposition;

	  if ((flags & CREATE_BREAKPOINT_FLAGS_INSERTED) != 0)
	    b->loc->inserted = 1;

	  if (type == bp_static_tracepoint)
	    {
	      struct tracepoint *t = (struct tracepoint *) b;
	      struct static_tracepoint_marker marker;

	      if (strace_marker_p (b))
		{
		  /* We already know the marker exists, otherwise, we
		     wouldn't see a sal for it.  */
		  char *p = &addr_string[3];
		  char *endp;
		  char *marker_str;

		  p = skip_spaces (p);

		  endp = skip_to_space (p);

		  marker_str = savestring (p, endp - p);
		  t->static_trace_marker_id = marker_str;

		  printf_filtered (_("Probed static tracepoint "
				     "marker \"%s\"\n"),
				   t->static_trace_marker_id);
		}
	      else if (target_static_tracepoint_marker_at (sal.pc, &marker))
		{
		  t->static_trace_marker_id = xstrdup (marker.str_id);
		  release_static_tracepoint_marker (&marker);

		  printf_filtered (_("Probed static tracepoint "
				     "marker \"%s\"\n"),
				   t->static_trace_marker_id);
		}
	      else
		warning (_("Couldn't determine the static "
			   "tracepoint marker to probe"));
	    }

	  loc = b->loc;
	}
      else
	{
	  loc = add_location_to_breakpoint (b, &sal);
	  if ((flags & CREATE_BREAKPOINT_FLAGS_INSERTED) != 0)
	    loc->inserted = 1;
	}

      if (bp_loc_is_permanent (loc))
	make_breakpoint_permanent (b);

      if (b->cond_string)
	{
	  const char *arg = b->cond_string;

	  loc->cond = parse_exp_1 (&arg, loc->address,
				   block_for_pc (loc->address), 0);
	  if (*arg)
              error (_("Garbage '%s' follows condition"), arg);
	}

      /* Dynamic printf requires and uses additional arguments on the
	 command line, otherwise it's an error.  */
      if (type == bp_dprintf)
	{
	  if (b->extra_string)
	    update_dprintf_command_list (b);
	  else
	    error (_("Format string required"));
	}
      else if (b->extra_string)
	error (_("Garbage '%s' at end of command"), b->extra_string);
    }

  b->display_canonical = display_canonical;
  if (addr_string)
    b->addr_string = addr_string;
  else
    /* addr_string has to be used or breakpoint_re_set will delete
       me.  */
    b->addr_string
      = xstrprintf ("*%s", paddress (b->loc->gdbarch, b->loc->address));
  b->filter = filter;
}

static void
create_breakpoint_sal (struct gdbarch *gdbarch,
		       struct symtabs_and_lines sals, char *addr_string,
		       char *filter, char *cond_string,
		       char *extra_string,
		       enum bptype type, enum bpdisp disposition,
		       int thread, int task, int ignore_count,
		       const struct breakpoint_ops *ops, int from_tty,
		       int enabled, int internal, unsigned flags,
		       int display_canonical)
{
  struct breakpoint *b;
  struct cleanup *old_chain;

  if (is_tracepoint_type (type))
    {
      struct tracepoint *t;

      t = XCNEW (struct tracepoint);
      b = &t->base;
    }
  else
    b = XNEW (struct breakpoint);

  old_chain = make_cleanup (xfree, b);

  init_breakpoint_sal (b, gdbarch,
		       sals, addr_string,
		       filter, cond_string, extra_string,
		       type, disposition,
		       thread, task, ignore_count,
		       ops, from_tty,
		       enabled, internal, flags,
		       display_canonical);
  discard_cleanups (old_chain);

  install_breakpoint (internal, b, 0);
}

/* Add SALS.nelts breakpoints to the breakpoint table.  For each
   SALS.sal[i] breakpoint, include the corresponding ADDR_STRING[i]
   value.  COND_STRING, if not NULL, specified the condition to be
   used for all breakpoints.  Essentially the only case where
   SALS.nelts is not 1 is when we set a breakpoint on an overloaded
   function.  In that case, it's still not possible to specify
   separate conditions for different overloaded functions, so
   we take just a single condition string.
   
   NOTE: If the function succeeds, the caller is expected to cleanup
   the arrays ADDR_STRING, COND_STRING, and SALS (but not the
   array contents).  If the function fails (error() is called), the
   caller is expected to cleanups both the ADDR_STRING, COND_STRING,
   COND and SALS arrays and each of those arrays contents.  */

static void
create_breakpoints_sal (struct gdbarch *gdbarch,
			struct linespec_result *canonical,
			char *cond_string, char *extra_string,
			enum bptype type, enum bpdisp disposition,
			int thread, int task, int ignore_count,
			const struct breakpoint_ops *ops, int from_tty,
			int enabled, int internal, unsigned flags)
{
  int i;
  struct linespec_sals *lsal;

  if (canonical->pre_expanded)
    gdb_assert (VEC_length (linespec_sals, canonical->sals) == 1);

  for (i = 0; VEC_iterate (linespec_sals, canonical->sals, i, lsal); ++i)
    {
      /* Note that 'addr_string' can be NULL in the case of a plain
	 'break', without arguments.  */
      char *addr_string = (canonical->addr_string
			   ? xstrdup (canonical->addr_string)
			   : NULL);
      char *filter_string = lsal->canonical ? xstrdup (lsal->canonical) : NULL;
      struct cleanup *inner = make_cleanup (xfree, addr_string);

      make_cleanup (xfree, filter_string);
      create_breakpoint_sal (gdbarch, lsal->sals,
			     addr_string,
			     filter_string,
			     cond_string, extra_string,
			     type, disposition,
			     thread, task, ignore_count, ops,
			     from_tty, enabled, internal, flags,
			     canonical->special_display);
      discard_cleanups (inner);
    }
}

/* Parse ADDRESS which is assumed to be a SAL specification possibly
   followed by conditionals.  On return, SALS contains an array of SAL
   addresses found.  ADDR_STRING contains a vector of (canonical)
   address strings.  ADDRESS points to the end of the SAL.

   The array and the line spec strings are allocated on the heap, it is
   the caller's responsibility to free them.  */

static void
parse_breakpoint_sals (char **address,
		       struct linespec_result *canonical)
{
  /* If no arg given, or if first arg is 'if ', use the default
     breakpoint.  */
  if ((*address) == NULL
      || (strncmp ((*address), "if", 2) == 0 && isspace ((*address)[2])))
    {
      /* The last displayed codepoint, if it's valid, is our default breakpoint
         address.  */
      if (last_displayed_sal_is_valid ())
	{
	  struct linespec_sals lsal;
	  struct symtab_and_line sal;
	  CORE_ADDR pc;

	  init_sal (&sal);		/* Initialize to zeroes.  */
	  lsal.sals.sals = (struct symtab_and_line *)
	    xmalloc (sizeof (struct symtab_and_line));

	  /* Set sal's pspace, pc, symtab, and line to the values
	     corresponding to the last call to print_frame_info.
	     Be sure to reinitialize LINE with NOTCURRENT == 0
	     as the breakpoint line number is inappropriate otherwise.
	     find_pc_line would adjust PC, re-set it back.  */
	  get_last_displayed_sal (&sal);
	  pc = sal.pc;
	  sal = find_pc_line (pc, 0);

	  /* "break" without arguments is equivalent to "break *PC"
	     where PC is the last displayed codepoint's address.  So
	     make sure to set sal.explicit_pc to prevent GDB from
	     trying to expand the list of sals to include all other
	     instances with the same symtab and line.  */
	  sal.pc = pc;
	  sal.explicit_pc = 1;

	  lsal.sals.sals[0] = sal;
	  lsal.sals.nelts = 1;
	  lsal.canonical = NULL;

	  VEC_safe_push (linespec_sals, canonical->sals, &lsal);
	}
      else
	error (_("No default breakpoint address now."));
    }
  else
    {
      struct symtab_and_line cursal = get_current_source_symtab_and_line ();

      /* Force almost all breakpoints to be in terms of the
         current_source_symtab (which is decode_line_1's default).
         This should produce the results we want almost all of the
         time while leaving default_breakpoint_* alone.

	 ObjC: However, don't match an Objective-C method name which
	 may have a '+' or '-' succeeded by a '['.  */
      if (last_displayed_sal_is_valid ()
	  && (!cursal.symtab
	      || ((strchr ("+-", (*address)[0]) != NULL)
		  && ((*address)[1] != '['))))
	decode_line_full (address, DECODE_LINE_FUNFIRSTLINE,
			  get_last_displayed_symtab (),
			  get_last_displayed_line (),
			  canonical, NULL, NULL);
      else
	decode_line_full (address, DECODE_LINE_FUNFIRSTLINE,
			  cursal.symtab, cursal.line, canonical, NULL, NULL);
    }
}


/* Convert each SAL into a real PC.  Verify that the PC can be
   inserted as a breakpoint.  If it can't throw an error.  */

static void
breakpoint_sals_to_pc (struct symtabs_and_lines *sals)
{    
  int i;

  for (i = 0; i < sals->nelts; i++)
    resolve_sal_pc (&sals->sals[i]);
}

/* Fast tracepoints may have restrictions on valid locations.  For
   instance, a fast tracepoint using a jump instead of a trap will
   likely have to overwrite more bytes than a trap would, and so can
   only be placed where the instruction is longer than the jump, or a
   multi-instruction sequence does not have a jump into the middle of
   it, etc.  */

static void
check_fast_tracepoint_sals (struct gdbarch *gdbarch,
			    struct symtabs_and_lines *sals)
{
  int i, rslt;
  struct symtab_and_line *sal;
  char *msg;
  struct cleanup *old_chain;

  for (i = 0; i < sals->nelts; i++)
    {
      struct gdbarch *sarch;

      sal = &sals->sals[i];

      sarch = get_sal_arch (*sal);
      /* We fall back to GDBARCH if there is no architecture
	 associated with SAL.  */
      if (sarch == NULL)
	sarch = gdbarch;
      rslt = gdbarch_fast_tracepoint_valid_at (sarch, sal->pc,
					       NULL, &msg);
      old_chain = make_cleanup (xfree, msg);

      if (!rslt)
	error (_("May not have a fast tracepoint at 0x%s%s"),
	       paddress (sarch, sal->pc), (msg ? msg : ""));

      do_cleanups (old_chain);
    }
}

/* Issue an invalid thread ID error.  */

static void ATTRIBUTE_NORETURN
invalid_thread_id_error (int id)
{
  error (_("Unknown thread %d."), id);
}

/* Given TOK, a string specification of condition and thread, as
   accepted by the 'break' command, extract the condition
   string and thread number and set *COND_STRING and *THREAD.
   PC identifies the context at which the condition should be parsed.
   If no condition is found, *COND_STRING is set to NULL.
   If no thread is found, *THREAD is set to -1.  */

static void
find_condition_and_thread (const char *tok, CORE_ADDR pc,
			   char **cond_string, int *thread, int *task,
			   char **rest)
{
  *cond_string = NULL;
  *thread = -1;
  *task = 0;
  *rest = NULL;

  while (tok && *tok)
    {
      const char *end_tok;
      int toklen;
      const char *cond_start = NULL;
      const char *cond_end = NULL;

      tok = skip_spaces_const (tok);

      if ((*tok == '"' || *tok == ',') && rest)
	{
	  *rest = savestring (tok, strlen (tok));
	  return;
	}

      end_tok = skip_to_space_const (tok);

      toklen = end_tok - tok;

      if (toklen >= 1 && strncmp (tok, "if", toklen) == 0)
	{
	  struct expression *expr;

	  tok = cond_start = end_tok + 1;
	  expr = parse_exp_1 (&tok, pc, block_for_pc (pc), 0);
	  xfree (expr);
	  cond_end = tok;
	  *cond_string = savestring (cond_start, cond_end - cond_start);
	}
      else if (toklen >= 1 && strncmp (tok, "thread", toklen) == 0)
	{
	  char *tmptok;

	  tok = end_tok + 1;
	  *thread = strtol (tok, &tmptok, 0);
	  if (tok == tmptok)
	    error (_("Junk after thread keyword."));
	  if (!valid_thread_id (*thread))
	    invalid_thread_id_error (*thread);
	  tok = tmptok;
	}
      else if (toklen >= 1 && strncmp (tok, "task", toklen) == 0)
	{
	  char *tmptok;

	  tok = end_tok + 1;
	  *task = strtol (tok, &tmptok, 0);
	  if (tok == tmptok)
	    error (_("Junk after task keyword."));
	  if (!valid_task_id (*task))
	    error (_("Unknown task %d."), *task);
	  tok = tmptok;
	}
      else if (rest)
	{
	  *rest = savestring (tok, strlen (tok));
	  return;
	}
      else
	error (_("Junk at end of arguments."));
    }
}

/* Decode a static tracepoint marker spec.  */

static struct symtabs_and_lines
decode_static_tracepoint_spec (char **arg_p)
{
  VEC(static_tracepoint_marker_p) *markers = NULL;
  struct symtabs_and_lines sals;
  struct cleanup *old_chain;
  char *p = &(*arg_p)[3];
  char *endp;
  char *marker_str;
  int i;

  p = skip_spaces (p);

  endp = skip_to_space (p);

  marker_str = savestring (p, endp - p);
  old_chain = make_cleanup (xfree, marker_str);

  markers = target_static_tracepoint_markers_by_strid (marker_str);
  if (VEC_empty(static_tracepoint_marker_p, markers))
    error (_("No known static tracepoint marker named %s"), marker_str);

  sals.nelts = VEC_length(static_tracepoint_marker_p, markers);
  sals.sals = xmalloc (sizeof *sals.sals * sals.nelts);

  for (i = 0; i < sals.nelts; i++)
    {
      struct static_tracepoint_marker *marker;

      marker = VEC_index (static_tracepoint_marker_p, markers, i);

      init_sal (&sals.sals[i]);

      sals.sals[i] = find_pc_line (marker->address, 0);
      sals.sals[i].pc = marker->address;

      release_static_tracepoint_marker (marker);
    }

  do_cleanups (old_chain);

  *arg_p = endp;
  return sals;
}

/* Set a breakpoint.  This function is shared between CLI and MI
   functions for setting a breakpoint.  This function has two major
   modes of operations, selected by the PARSE_ARG parameter.  If
   non-zero, the function will parse ARG, extracting location,
   condition, thread and extra string.  Otherwise, ARG is just the
   breakpoint's location, with condition, thread, and extra string
   specified by the COND_STRING, THREAD and EXTRA_STRING parameters.
   If INTERNAL is non-zero, the breakpoint number will be allocated
   from the internal breakpoint count.  Returns true if any breakpoint
   was created; false otherwise.  */

int
create_breakpoint (struct gdbarch *gdbarch,
		   char *arg, char *cond_string,
		   int thread, char *extra_string,
		   int parse_arg,
		   int tempflag, enum bptype type_wanted,
		   int ignore_count,
		   enum auto_boolean pending_break_support,
		   const struct breakpoint_ops *ops,
		   int from_tty, int enabled, int internal,
		   unsigned flags)
{
  volatile struct gdb_exception e;
  char *copy_arg = NULL;
  char *addr_start = arg;
  struct linespec_result canonical;
  struct cleanup *old_chain;
  struct cleanup *bkpt_chain = NULL;
  int pending = 0;
  int task = 0;
  int prev_bkpt_count = breakpoint_count;

  gdb_assert (ops != NULL);

  init_linespec_result (&canonical);

  TRY_CATCH (e, RETURN_MASK_ALL)
    {
      ops->create_sals_from_address (&arg, &canonical, type_wanted,
				     addr_start, &copy_arg);
    }

  /* If caller is interested in rc value from parse, set value.  */
  switch (e.reason)
    {
    case GDB_NO_ERROR:
      if (VEC_empty (linespec_sals, canonical.sals))
	return 0;
      break;
    case RETURN_ERROR:
      switch (e.error)
	{
	case NOT_FOUND_ERROR:

	  /* If pending breakpoint support is turned off, throw
	     error.  */

	  if (pending_break_support == AUTO_BOOLEAN_FALSE)
	    throw_exception (e);

	  exception_print (gdb_stderr, e);

          /* If pending breakpoint support is auto query and the user
	     selects no, then simply return the error code.  */
	  if (pending_break_support == AUTO_BOOLEAN_AUTO
	      && !nquery (_("Make %s pending on future shared library load? "),
			  bptype_string (type_wanted)))
	    return 0;

	  /* At this point, either the user was queried about setting
	     a pending breakpoint and selected yes, or pending
	     breakpoint behavior is on and thus a pending breakpoint
	     is defaulted on behalf of the user.  */
	  {
	    struct linespec_sals lsal;

	    copy_arg = xstrdup (addr_start);
	    lsal.canonical = xstrdup (copy_arg);
	    lsal.sals.nelts = 1;
	    lsal.sals.sals = XNEW (struct symtab_and_line);
	    init_sal (&lsal.sals.sals[0]);
	    pending = 1;
	    VEC_safe_push (linespec_sals, canonical.sals, &lsal);
	  }
	  break;
	default:
	  throw_exception (e);
	}
      break;
    default:
      throw_exception (e);
    }

  /* Create a chain of things that always need to be cleaned up.  */
  old_chain = make_cleanup_destroy_linespec_result (&canonical);

  /* ----------------------------- SNIP -----------------------------
     Anything added to the cleanup chain beyond this point is assumed
     to be part of a breakpoint.  If the breakpoint create succeeds
     then the memory is not reclaimed.  */
  bkpt_chain = make_cleanup (null_cleanup, 0);

  /* Resolve all line numbers to PC's and verify that the addresses
     are ok for the target.  */
  if (!pending)
    {
      int ix;
      struct linespec_sals *iter;

      for (ix = 0; VEC_iterate (linespec_sals, canonical.sals, ix, iter); ++ix)
	breakpoint_sals_to_pc (&iter->sals);
    }

  /* Fast tracepoints may have additional restrictions on location.  */
  if (!pending && type_wanted == bp_fast_tracepoint)
    {
      int ix;
      struct linespec_sals *iter;

      for (ix = 0; VEC_iterate (linespec_sals, canonical.sals, ix, iter); ++ix)
	check_fast_tracepoint_sals (gdbarch, &iter->sals);
    }

  /* Verify that condition can be parsed, before setting any
     breakpoints.  Allocate a separate condition expression for each
     breakpoint.  */
  if (!pending)
    {
      if (parse_arg)
        {
	  char *rest;
	  struct linespec_sals *lsal;

	  lsal = VEC_index (linespec_sals, canonical.sals, 0);

	  /* Here we only parse 'arg' to separate condition
	     from thread number, so parsing in context of first
	     sal is OK.  When setting the breakpoint we'll
	     re-parse it in context of each sal.  */

	  find_condition_and_thread (arg, lsal->sals.sals[0].pc, &cond_string,
				     &thread, &task, &rest);
	  if (cond_string)
	    make_cleanup (xfree, cond_string);
	  if (rest)
	    make_cleanup (xfree, rest);
	  if (rest)
	    extra_string = rest;
        }
      else
        {
	  if (*arg != '\0')
	    error (_("Garbage '%s' at end of location"), arg);

	  /* Create a private copy of condition string.  */
	  if (cond_string)
	    {
	      cond_string = xstrdup (cond_string);
	      make_cleanup (xfree, cond_string);
	    }
	  /* Create a private copy of any extra string.  */
	  if (extra_string)
	    {
	      extra_string = xstrdup (extra_string);
	      make_cleanup (xfree, extra_string);
	    }
        }

      ops->create_breakpoints_sal (gdbarch, &canonical,
				   cond_string, extra_string, type_wanted,
				   tempflag ? disp_del : disp_donttouch,
				   thread, task, ignore_count, ops,
				   from_tty, enabled, internal, flags);
    }
  else
    {
      struct breakpoint *b;

      make_cleanup (xfree, copy_arg);

      if (is_tracepoint_type (type_wanted))
	{
	  struct tracepoint *t;

	  t = XCNEW (struct tracepoint);
	  b = &t->base;
	}
      else
	b = XNEW (struct breakpoint);

      init_raw_breakpoint_without_location (b, gdbarch, type_wanted, ops);

      b->addr_string = copy_arg;
      if (parse_arg)
	b->cond_string = NULL;
      else
	{
	  /* Create a private copy of condition string.  */
	  if (cond_string)
	    {
	      cond_string = xstrdup (cond_string);
	      make_cleanup (xfree, cond_string);
	    }
	  b->cond_string = cond_string;
	}
      b->extra_string = NULL;
      b->ignore_count = ignore_count;
      b->disposition = tempflag ? disp_del : disp_donttouch;
      b->condition_not_parsed = 1;
      b->enable_state = enabled ? bp_enabled : bp_disabled;
      if ((type_wanted != bp_breakpoint
           && type_wanted != bp_hardware_breakpoint) || thread != -1)
	b->pspace = current_program_space;

      install_breakpoint (internal, b, 0);
    }
  
  if (VEC_length (linespec_sals, canonical.sals) > 1)
    {
      warning (_("Multiple breakpoints were set.\nUse the "
		 "\"delete\" command to delete unwanted breakpoints."));
      prev_breakpoint_count = prev_bkpt_count;
    }

  /* That's it.  Discard the cleanups for data inserted into the
     breakpoint.  */
  discard_cleanups (bkpt_chain);
  /* But cleanup everything else.  */
  do_cleanups (old_chain);

  /* error call may happen here - have BKPT_CHAIN already discarded.  */
  update_global_location_list (1);

  return 1;
}

/* Set a breakpoint.
   ARG is a string describing breakpoint address,
   condition, and thread.
   FLAG specifies if a breakpoint is hardware on,
   and if breakpoint is temporary, using BP_HARDWARE_FLAG
   and BP_TEMPFLAG.  */

static void
break_command_1 (char *arg, int flag, int from_tty)
{
  int tempflag = flag & BP_TEMPFLAG;
  enum bptype type_wanted = (flag & BP_HARDWAREFLAG
			     ? bp_hardware_breakpoint
			     : bp_breakpoint);
  struct breakpoint_ops *ops;
  const char *arg_cp = arg;

  /* Matching breakpoints on probes.  */
  if (arg && probe_linespec_to_ops (&arg_cp) != NULL)
    ops = &bkpt_probe_breakpoint_ops;
  else
    ops = &bkpt_breakpoint_ops;

  create_breakpoint (get_current_arch (),
		     arg,
		     NULL, 0, NULL, 1 /* parse arg */,
		     tempflag, type_wanted,
		     0 /* Ignore count */,
		     pending_break_support,
		     ops,
		     from_tty,
		     1 /* enabled */,
		     0 /* internal */,
		     0);
}

/* Helper function for break_command_1 and disassemble_command.  */

void
resolve_sal_pc (struct symtab_and_line *sal)
{
  CORE_ADDR pc;

  if (sal->pc == 0 && sal->symtab != NULL)
    {
      if (!find_line_pc (sal->symtab, sal->line, &pc))
	error (_("No line %d in file \"%s\"."),
	       sal->line, symtab_to_filename_for_display (sal->symtab));
      sal->pc = pc;

      /* If this SAL corresponds to a breakpoint inserted using a line
         number, then skip the function prologue if necessary.  */
      if (sal->explicit_line)
	skip_prologue_sal (sal);
    }

  if (sal->section == 0 && sal->symtab != NULL)
    {
      struct blockvector *bv;
      struct block *b;
      struct symbol *sym;

      bv = blockvector_for_pc_sect (sal->pc, 0, &b, sal->symtab);
      if (bv != NULL)
	{
	  sym = block_linkage_function (b);
	  if (sym != NULL)
	    {
	      fixup_symbol_section (sym, sal->symtab->objfile);
	      sal->section = SYMBOL_OBJ_SECTION (sal->symtab->objfile, sym);
	    }
	  else
	    {
	      /* It really is worthwhile to have the section, so we'll
	         just have to look harder. This case can be executed
	         if we have line numbers but no functions (as can
	         happen in assembly source).  */

	      struct bound_minimal_symbol msym;
	      struct cleanup *old_chain = save_current_space_and_thread ();

	      switch_to_program_space_and_thread (sal->pspace);

	      msym = lookup_minimal_symbol_by_pc (sal->pc);
	      if (msym.minsym)
		sal->section = SYMBOL_OBJ_SECTION (msym.objfile, msym.minsym);

	      do_cleanups (old_chain);
	    }
	}
    }
}

void
break_command (char *arg, int from_tty)
{
  break_command_1 (arg, 0, from_tty);
}

void
tbreak_command (char *arg, int from_tty)
{
  break_command_1 (arg, BP_TEMPFLAG, from_tty);
}

static void
hbreak_command (char *arg, int from_tty)
{
  break_command_1 (arg, BP_HARDWAREFLAG, from_tty);
}

static void
thbreak_command (char *arg, int from_tty)
{
  break_command_1 (arg, (BP_TEMPFLAG | BP_HARDWAREFLAG), from_tty);
}

static void
stop_command (char *arg, int from_tty)
{
  printf_filtered (_("Specify the type of breakpoint to set.\n\
Usage: stop in <function | address>\n\
       stop at <line>\n"));
}

static void
stopin_command (char *arg, int from_tty)
{
  int badInput = 0;

  if (arg == (char *) NULL)
    badInput = 1;
  else if (*arg != '*')
    {
      char *argptr = arg;
      int hasColon = 0;

      /* Look for a ':'.  If this is a line number specification, then
         say it is bad, otherwise, it should be an address or
         function/method name.  */
      while (*argptr && !hasColon)
	{
	  hasColon = (*argptr == ':');
	  argptr++;
	}

      if (hasColon)
	badInput = (*argptr != ':');	/* Not a class::method */
      else
	badInput = isdigit (*arg);	/* a simple line number */
    }

  if (badInput)
    printf_filtered (_("Usage: stop in <function | address>\n"));
  else
    break_command_1 (arg, 0, from_tty);
}

static void
stopat_command (char *arg, int from_tty)
{
  int badInput = 0;

  if (arg == (char *) NULL || *arg == '*')	/* no line number */
    badInput = 1;
  else
    {
      char *argptr = arg;
      int hasColon = 0;

      /* Look for a ':'.  If there is a '::' then get out, otherwise
         it is probably a line number.  */
      while (*argptr && !hasColon)
	{
	  hasColon = (*argptr == ':');
	  argptr++;
	}

      if (hasColon)
	badInput = (*argptr == ':');	/* we have class::method */
      else
	badInput = !isdigit (*arg);	/* not a line number */
    }

  if (badInput)
    printf_filtered (_("Usage: stop at <line>\n"));
  else
    break_command_1 (arg, 0, from_tty);
}

/* The dynamic printf command is mostly like a regular breakpoint, but
   with a prewired command list consisting of a single output command,
   built from extra arguments supplied on the dprintf command
   line.  */

static void
dprintf_command (char *arg, int from_tty)
{
  create_breakpoint (get_current_arch (),
		     arg,
		     NULL, 0, NULL, 1 /* parse arg */,
		     0, bp_dprintf,
		     0 /* Ignore count */,
		     pending_break_support,
		     &dprintf_breakpoint_ops,
		     from_tty,
		     1 /* enabled */,
		     0 /* internal */,
		     0);
}

static void
agent_printf_command (char *arg, int from_tty)
{
  error (_("May only run agent-printf on the target"));
}

/* Implement the "breakpoint_hit" breakpoint_ops method for
   ranged breakpoints.  */

static int
breakpoint_hit_ranged_breakpoint (const struct bp_location *bl,
				  struct address_space *aspace,
				  CORE_ADDR bp_addr,
				  const struct target_waitstatus *ws)
{
  if (ws->kind != TARGET_WAITKIND_STOPPED
      || ws->value.sig != GDB_SIGNAL_TRAP)
    return 0;

  return breakpoint_address_match_range (bl->pspace->aspace, bl->address,
					 bl->length, aspace, bp_addr);
}

/* Implement the "resources_needed" breakpoint_ops method for
   ranged breakpoints.  */

static int
resources_needed_ranged_breakpoint (const struct bp_location *bl)
{
  return target_ranged_break_num_registers ();
}

/* Implement the "print_it" breakpoint_ops method for
   ranged breakpoints.  */

static enum print_stop_action
print_it_ranged_breakpoint (bpstat bs)
{
  struct breakpoint *b = bs->breakpoint_at;
  struct bp_location *bl = b->loc;
  struct ui_out *uiout = current_uiout;

  gdb_assert (b->type == bp_hardware_breakpoint);

  /* Ranged breakpoints have only one location.  */
  gdb_assert (bl && bl->next == NULL);

  annotate_breakpoint (b->number);
  if (b->disposition == disp_del)
    ui_out_text (uiout, "\nTemporary ranged breakpoint ");
  else
    ui_out_text (uiout, "\nRanged breakpoint ");
  if (ui_out_is_mi_like_p (uiout))
    {
      ui_out_field_string (uiout, "reason",
		      async_reason_lookup (EXEC_ASYNC_BREAKPOINT_HIT));
      ui_out_field_string (uiout, "disp", bpdisp_text (b->disposition));
    }
  ui_out_field_int (uiout, "bkptno", b->number);
  ui_out_text (uiout, ", ");

  return PRINT_SRC_AND_LOC;
}

/* Implement the "print_one" breakpoint_ops method for
   ranged breakpoints.  */

static void
print_one_ranged_breakpoint (struct breakpoint *b,
			     struct bp_location **last_loc)
{
  struct bp_location *bl = b->loc;
  struct value_print_options opts;
  struct ui_out *uiout = current_uiout;

  /* Ranged breakpoints have only one location.  */
  gdb_assert (bl && bl->next == NULL);

  get_user_print_options (&opts);

  if (opts.addressprint)
    /* We don't print the address range here, it will be printed later
       by print_one_detail_ranged_breakpoint.  */
    ui_out_field_skip (uiout, "addr");
  annotate_field (5);
  print_breakpoint_location (b, bl);
  *last_loc = bl;
}

/* Implement the "print_one_detail" breakpoint_ops method for
   ranged breakpoints.  */

static void
print_one_detail_ranged_breakpoint (const struct breakpoint *b,
				    struct ui_out *uiout)
{
  CORE_ADDR address_start, address_end;
  struct bp_location *bl = b->loc;
  struct ui_file *stb = mem_fileopen ();
  struct cleanup *cleanup = make_cleanup_ui_file_delete (stb);

  gdb_assert (bl);

  address_start = bl->address;
  address_end = address_start + bl->length - 1;

  ui_out_text (uiout, "\taddress range: ");
  fprintf_unfiltered (stb, "[%s, %s]",
		      print_core_address (bl->gdbarch, address_start),
		      print_core_address (bl->gdbarch, address_end));
  ui_out_field_stream (uiout, "addr", stb);
  ui_out_text (uiout, "\n");

  do_cleanups (cleanup);
}

/* Implement the "print_mention" breakpoint_ops method for
   ranged breakpoints.  */

static void
print_mention_ranged_breakpoint (struct breakpoint *b)
{
  struct bp_location *bl = b->loc;
  struct ui_out *uiout = current_uiout;

  gdb_assert (bl);
  gdb_assert (b->type == bp_hardware_breakpoint);

  if (ui_out_is_mi_like_p (uiout))
    return;

  printf_filtered (_("Hardware assisted ranged breakpoint %d from %s to %s."),
		   b->number, paddress (bl->gdbarch, bl->address),
		   paddress (bl->gdbarch, bl->address + bl->length - 1));
}

/* Implement the "print_recreate" breakpoint_ops method for
   ranged breakpoints.  */

static void
print_recreate_ranged_breakpoint (struct breakpoint *b, struct ui_file *fp)
{
  fprintf_unfiltered (fp, "break-range %s, %s", b->addr_string,
		      b->addr_string_range_end);
  print_recreate_thread (b, fp);
}

/* The breakpoint_ops structure to be used in ranged breakpoints.  */

static struct breakpoint_ops ranged_breakpoint_ops;

/* Find the address where the end of the breakpoint range should be
   placed, given the SAL of the end of the range.  This is so that if
   the user provides a line number, the end of the range is set to the
   last instruction of the given line.  */

static CORE_ADDR
find_breakpoint_range_end (struct symtab_and_line sal)
{
  CORE_ADDR end;

  /* If the user provided a PC value, use it.  Otherwise,
     find the address of the end of the given location.  */
  if (sal.explicit_pc)
    end = sal.pc;
  else
    {
      int ret;
      CORE_ADDR start;

      ret = find_line_pc_range (sal, &start, &end);
      if (!ret)
	error (_("Could not find location of the end of the range."));

      /* find_line_pc_range returns the start of the next line.  */
      end--;
    }

  return end;
}

/* Implement the "break-range" CLI command.  */

static void
break_range_command (char *arg, int from_tty)
{
  char *arg_start, *addr_string_start, *addr_string_end;
  struct linespec_result canonical_start, canonical_end;
  int bp_count, can_use_bp, length;
  CORE_ADDR end;
  struct breakpoint *b;
  struct symtab_and_line sal_start, sal_end;
  struct cleanup *cleanup_bkpt;
  struct linespec_sals *lsal_start, *lsal_end;

  /* We don't support software ranged breakpoints.  */
  if (target_ranged_break_num_registers () < 0)
    error (_("This target does not support hardware ranged breakpoints."));

  bp_count = hw_breakpoint_used_count ();
  bp_count += target_ranged_break_num_registers ();
  can_use_bp = target_can_use_hardware_watchpoint (bp_hardware_breakpoint,
						   bp_count, 0);
  if (can_use_bp < 0)
    error (_("Hardware breakpoints used exceeds limit."));

  arg = skip_spaces (arg);
  if (arg == NULL || arg[0] == '\0')
    error(_("No address range specified."));

  init_linespec_result (&canonical_start);

  arg_start = arg;
  parse_breakpoint_sals (&arg, &canonical_start);

  cleanup_bkpt = make_cleanup_destroy_linespec_result (&canonical_start);

  if (arg[0] != ',')
    error (_("Too few arguments."));
  else if (VEC_empty (linespec_sals, canonical_start.sals))
    error (_("Could not find location of the beginning of the range."));

  lsal_start = VEC_index (linespec_sals, canonical_start.sals, 0);

  if (VEC_length (linespec_sals, canonical_start.sals) > 1
      || lsal_start->sals.nelts != 1)
    error (_("Cannot create a ranged breakpoint with multiple locations."));

  sal_start = lsal_start->sals.sals[0];
  addr_string_start = savestring (arg_start, arg - arg_start);
  make_cleanup (xfree, addr_string_start);

  arg++;	/* Skip the comma.  */
  arg = skip_spaces (arg);

  /* Parse the end location.  */

  init_linespec_result (&canonical_end);
  arg_start = arg;

  /* We call decode_line_full directly here instead of using
     parse_breakpoint_sals because we need to specify the start location's
     symtab and line as the default symtab and line for the end of the
     range.  This makes it possible to have ranges like "foo.c:27, +14",
     where +14 means 14 lines from the start location.  */
  decode_line_full (&arg, DECODE_LINE_FUNFIRSTLINE,
		    sal_start.symtab, sal_start.line,
		    &canonical_end, NULL, NULL);

  make_cleanup_destroy_linespec_result (&canonical_end);

  if (VEC_empty (linespec_sals, canonical_end.sals))
    error (_("Could not find location of the end of the range."));

  lsal_end = VEC_index (linespec_sals, canonical_end.sals, 0);
  if (VEC_length (linespec_sals, canonical_end.sals) > 1
      || lsal_end->sals.nelts != 1)
    error (_("Cannot create a ranged breakpoint with multiple locations."));

  sal_end = lsal_end->sals.sals[0];
  addr_string_end = savestring (arg_start, arg - arg_start);
  make_cleanup (xfree, addr_string_end);

  end = find_breakpoint_range_end (sal_end);
  if (sal_start.pc > end)
    error (_("Invalid address range, end precedes start."));

  length = end - sal_start.pc + 1;
  if (length < 0)
    /* Length overflowed.  */
    error (_("Address range too large."));
  else if (length == 1)
    {
      /* This range is simple enough to be handled by
	 the `hbreak' command.  */
      hbreak_command (addr_string_start, 1);

      do_cleanups (cleanup_bkpt);

      return;
    }

  /* Now set up the breakpoint.  */
  b = set_raw_breakpoint (get_current_arch (), sal_start,
			  bp_hardware_breakpoint, &ranged_breakpoint_ops);
  set_breakpoint_count (breakpoint_count + 1);
  b->number = breakpoint_count;
  b->disposition = disp_donttouch;
  b->addr_string = xstrdup (addr_string_start);
  b->addr_string_range_end = xstrdup (addr_string_end);
  b->loc->length = length;

  do_cleanups (cleanup_bkpt);

  mention (b);
  observer_notify_breakpoint_created (b);
  update_global_location_list (1);
}

/*  Return non-zero if EXP is verified as constant.  Returned zero
    means EXP is variable.  Also the constant detection may fail for
    some constant expressions and in such case still falsely return
    zero.  */

static int
watchpoint_exp_is_const (const struct expression *exp)
{
  int i = exp->nelts;

  while (i > 0)
    {
      int oplenp, argsp;

      /* We are only interested in the descriptor of each element.  */
      operator_length (exp, i, &oplenp, &argsp);
      i -= oplenp;

      switch (exp->elts[i].opcode)
	{
	case BINOP_ADD:
	case BINOP_SUB:
	case BINOP_MUL:
	case BINOP_DIV:
	case BINOP_REM:
	case BINOP_MOD:
	case BINOP_LSH:
	case BINOP_RSH:
	case BINOP_LOGICAL_AND:
	case BINOP_LOGICAL_OR:
	case BINOP_BITWISE_AND:
	case BINOP_BITWISE_IOR:
	case BINOP_BITWISE_XOR:
	case BINOP_EQUAL:
	case BINOP_NOTEQUAL:
	case BINOP_LESS:
	case BINOP_GTR:
	case BINOP_LEQ:
	case BINOP_GEQ:
	case BINOP_REPEAT:
	case BINOP_COMMA:
	case BINOP_EXP:
	case BINOP_MIN:
	case BINOP_MAX:
	case BINOP_INTDIV:
	case BINOP_CONCAT:
	case BINOP_IN:
	case BINOP_RANGE:
	case TERNOP_COND:
	case TERNOP_SLICE:

	case OP_LONG:
	case OP_DOUBLE:
	case OP_DECFLOAT:
	case OP_LAST:
	case OP_COMPLEX:
	case OP_STRING:
	case OP_ARRAY:
	case OP_TYPE:
	case OP_TYPEOF:
	case OP_DECLTYPE:
	case OP_TYPEID:
	case OP_NAME:
	case OP_OBJC_NSSTRING:

	case UNOP_NEG:
	case UNOP_LOGICAL_NOT:
	case UNOP_COMPLEMENT:
	case UNOP_ADDR:
	case UNOP_HIGH:
	case UNOP_CAST:

	case UNOP_CAST_TYPE:
	case UNOP_REINTERPRET_CAST:
	case UNOP_DYNAMIC_CAST:
	  /* Unary, binary and ternary operators: We have to check
	     their operands.  If they are constant, then so is the
	     result of that operation.  For instance, if A and B are
	     determined to be constants, then so is "A + B".

	     UNOP_IND is one exception to the rule above, because the
	     value of *ADDR is not necessarily a constant, even when
	     ADDR is.  */
	  break;

	case OP_VAR_VALUE:
	  /* Check whether the associated symbol is a constant.

	     We use SYMBOL_CLASS rather than TYPE_CONST because it's
	     possible that a buggy compiler could mark a variable as
	     constant even when it is not, and TYPE_CONST would return
	     true in this case, while SYMBOL_CLASS wouldn't.

	     We also have to check for function symbols because they
	     are always constant.  */
	  {
	    struct symbol *s = exp->elts[i + 2].symbol;

	    if (SYMBOL_CLASS (s) != LOC_BLOCK
		&& SYMBOL_CLASS (s) != LOC_CONST
		&& SYMBOL_CLASS (s) != LOC_CONST_BYTES)
	      return 0;
	    break;
	  }

	/* The default action is to return 0 because we are using
	   the optimistic approach here: If we don't know something,
	   then it is not a constant.  */
	default:
	  return 0;
	}
    }

  return 1;
}

/* Implement the "dtor" breakpoint_ops method for watchpoints.  */

static void
dtor_watchpoint (struct breakpoint *self)
{
  struct watchpoint *w = (struct watchpoint *) self;

  xfree (w->cond_exp);
  xfree (w->exp);
  xfree (w->exp_string);
  xfree (w->exp_string_reparse);
  value_free (w->val);

  base_breakpoint_ops.dtor (self);
}

/* Implement the "re_set" breakpoint_ops method for watchpoints.  */

static void
re_set_watchpoint (struct breakpoint *b)
{
  struct watchpoint *w = (struct watchpoint *) b;

  /* Watchpoint can be either on expression using entirely global
     variables, or it can be on local variables.

     Watchpoints of the first kind are never auto-deleted, and even
     persist across program restarts.  Since they can use variables
     from shared libraries, we need to reparse expression as libraries
     are loaded and unloaded.

     Watchpoints on local variables can also change meaning as result
     of solib event.  For example, if a watchpoint uses both a local
     and a global variables in expression, it's a local watchpoint,
     but unloading of a shared library will make the expression
     invalid.  This is not a very common use case, but we still
     re-evaluate expression, to avoid surprises to the user.

     Note that for local watchpoints, we re-evaluate it only if
     watchpoints frame id is still valid.  If it's not, it means the
     watchpoint is out of scope and will be deleted soon.  In fact,
     I'm not sure we'll ever be called in this case.

     If a local watchpoint's frame id is still valid, then
     w->exp_valid_block is likewise valid, and we can safely use it.

     Don't do anything about disabled watchpoints, since they will be
     reevaluated again when enabled.  */
  update_watchpoint (w, 1 /* reparse */);
}

/* Implement the "insert" breakpoint_ops method for hardware watchpoints.  */

static int
insert_watchpoint (struct bp_location *bl)
{
  struct watchpoint *w = (struct watchpoint *) bl->owner;
  int length = w->exact ? 1 : bl->length;

  return target_insert_watchpoint (bl->address, length, bl->watchpoint_type,
				   w->cond_exp);
}

/* Implement the "remove" breakpoint_ops method for hardware watchpoints.  */

static int
remove_watchpoint (struct bp_location *bl)
{
  struct watchpoint *w = (struct watchpoint *) bl->owner;
  int length = w->exact ? 1 : bl->length;

  return target_remove_watchpoint (bl->address, length, bl->watchpoint_type,
				   w->cond_exp);
}

static int
breakpoint_hit_watchpoint (const struct bp_location *bl,
			   struct address_space *aspace, CORE_ADDR bp_addr,
			   const struct target_waitstatus *ws)
{
  struct breakpoint *b = bl->owner;
  struct watchpoint *w = (struct watchpoint *) b;

  /* Continuable hardware watchpoints are treated as non-existent if the
     reason we stopped wasn't a hardware watchpoint (we didn't stop on
     some data address).  Otherwise gdb won't stop on a break instruction
     in the code (not from a breakpoint) when a hardware watchpoint has
     been defined.  Also skip watchpoints which we know did not trigger
     (did not match the data address).  */
  if (is_hardware_watchpoint (b)
      && w->watchpoint_triggered == watch_triggered_no)
    return 0;

  return 1;
}

static void
check_status_watchpoint (bpstat bs)
{
  gdb_assert (is_watchpoint (bs->breakpoint_at));

  bpstat_check_watchpoint (bs);
}

/* Implement the "resources_needed" breakpoint_ops method for
   hardware watchpoints.  */

static int
resources_needed_watchpoint (const struct bp_location *bl)
{
  struct watchpoint *w = (struct watchpoint *) bl->owner;
  int length = w->exact? 1 : bl->length;

  return target_region_ok_for_hw_watchpoint (bl->address, length);
}

/* Implement the "works_in_software_mode" breakpoint_ops method for
   hardware watchpoints.  */

static int
works_in_software_mode_watchpoint (const struct breakpoint *b)
{
  /* Read and access watchpoints only work with hardware support.  */
  return b->type == bp_watchpoint || b->type == bp_hardware_watchpoint;
}

static enum print_stop_action
print_it_watchpoint (bpstat bs)
{
  struct cleanup *old_chain;
  struct breakpoint *b;
  struct ui_file *stb;
  enum print_stop_action result;
  struct watchpoint *w;
  struct ui_out *uiout = current_uiout;

  gdb_assert (bs->bp_location_at != NULL);

  b = bs->breakpoint_at;
  w = (struct watchpoint *) b;

  stb = mem_fileopen ();
  old_chain = make_cleanup_ui_file_delete (stb);

  switch (b->type)
    {
    case bp_watchpoint:
    case bp_hardware_watchpoint:
      annotate_watchpoint (b->number);
      if (ui_out_is_mi_like_p (uiout))
	ui_out_field_string
	  (uiout, "reason",
	   async_reason_lookup (EXEC_ASYNC_WATCHPOINT_TRIGGER));
      mention (b);
      make_cleanup_ui_out_tuple_begin_end (uiout, "value");
      ui_out_text (uiout, "\nOld value = ");
      watchpoint_value_print (bs->old_val, stb);
      ui_out_field_stream (uiout, "old", stb);
      ui_out_text (uiout, "\nNew value = ");
      watchpoint_value_print (w->val, stb);
      ui_out_field_stream (uiout, "new", stb);
      ui_out_text (uiout, "\n");
      /* More than one watchpoint may have been triggered.  */
      result = PRINT_UNKNOWN;
      break;

    case bp_read_watchpoint:
      if (ui_out_is_mi_like_p (uiout))
	ui_out_field_string
	  (uiout, "reason",
	   async_reason_lookup (EXEC_ASYNC_READ_WATCHPOINT_TRIGGER));
      mention (b);
      make_cleanup_ui_out_tuple_begin_end (uiout, "value");
      ui_out_text (uiout, "\nValue = ");
      watchpoint_value_print (w->val, stb);
      ui_out_field_stream (uiout, "value", stb);
      ui_out_text (uiout, "\n");
      result = PRINT_UNKNOWN;
      break;

    case bp_access_watchpoint:
      if (bs->old_val != NULL)
	{
	  annotate_watchpoint (b->number);
	  if (ui_out_is_mi_like_p (uiout))
	    ui_out_field_string
	      (uiout, "reason",
	       async_reason_lookup (EXEC_ASYNC_ACCESS_WATCHPOINT_TRIGGER));
	  mention (b);
	  make_cleanup_ui_out_tuple_begin_end (uiout, "value");
	  ui_out_text (uiout, "\nOld value = ");
	  watchpoint_value_print (bs->old_val, stb);
	  ui_out_field_stream (uiout, "old", stb);
	  ui_out_text (uiout, "\nNew value = ");
	}
      else
	{
	  mention (b);
	  if (ui_out_is_mi_like_p (uiout))
	    ui_out_field_string
	      (uiout, "reason",
	       async_reason_lookup (EXEC_ASYNC_ACCESS_WATCHPOINT_TRIGGER));
	  make_cleanup_ui_out_tuple_begin_end (uiout, "value");
	  ui_out_text (uiout, "\nValue = ");
	}
      watchpoint_value_print (w->val, stb);
      ui_out_field_stream (uiout, "new", stb);
      ui_out_text (uiout, "\n");
      result = PRINT_UNKNOWN;
      break;
    default:
      result = PRINT_UNKNOWN;
    }

  do_cleanups (old_chain);
  return result;
}

/* Implement the "print_mention" breakpoint_ops method for hardware
   watchpoints.  */

static void
print_mention_watchpoint (struct breakpoint *b)
{
  struct cleanup *ui_out_chain;
  struct watchpoint *w = (struct watchpoint *) b;
  struct ui_out *uiout = current_uiout;

  switch (b->type)
    {
    case bp_watchpoint:
      ui_out_text (uiout, "Watchpoint ");
      ui_out_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "wpt");
      break;
    case bp_hardware_watchpoint:
      ui_out_text (uiout, "Hardware watchpoint ");
      ui_out_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "wpt");
      break;
    case bp_read_watchpoint:
      ui_out_text (uiout, "Hardware read watchpoint ");
      ui_out_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "hw-rwpt");
      break;
    case bp_access_watchpoint:
      ui_out_text (uiout, "Hardware access (read/write) watchpoint ");
      ui_out_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "hw-awpt");
      break;
    default:
      internal_error (__FILE__, __LINE__,
		      _("Invalid hardware watchpoint type."));
    }

  ui_out_field_int (uiout, "number", b->number);
  ui_out_text (uiout, ": ");
  ui_out_field_string (uiout, "exp", w->exp_string);
  do_cleanups (ui_out_chain);
}

/* Implement the "print_recreate" breakpoint_ops method for
   watchpoints.  */

static void
print_recreate_watchpoint (struct breakpoint *b, struct ui_file *fp)
{
  struct watchpoint *w = (struct watchpoint *) b;

  switch (b->type)
    {
    case bp_watchpoint:
    case bp_hardware_watchpoint:
      fprintf_unfiltered (fp, "watch");
      break;
    case bp_read_watchpoint:
      fprintf_unfiltered (fp, "rwatch");
      break;
    case bp_access_watchpoint:
      fprintf_unfiltered (fp, "awatch");
      break;
    default:
      internal_error (__FILE__, __LINE__,
		      _("Invalid watchpoint type."));
    }

  fprintf_unfiltered (fp, " %s", w->exp_string);
  print_recreate_thread (b, fp);
}

/* Implement the "explains_signal" breakpoint_ops method for
   watchpoints.  */

static enum bpstat_signal_value
explains_signal_watchpoint (struct breakpoint *b, enum gdb_signal sig)
{
  /* A software watchpoint cannot cause a signal other than
     GDB_SIGNAL_TRAP.  */
  if (b->type == bp_watchpoint && sig != GDB_SIGNAL_TRAP)
    return BPSTAT_SIGNAL_NO;

  return BPSTAT_SIGNAL_HIDE;
}

/* The breakpoint_ops structure to be used in hardware watchpoints.  */

static struct breakpoint_ops watchpoint_breakpoint_ops;

/* Implement the "insert" breakpoint_ops method for
   masked hardware watchpoints.  */

static int
insert_masked_watchpoint (struct bp_location *bl)
{
  struct watchpoint *w = (struct watchpoint *) bl->owner;

  return target_insert_mask_watchpoint (bl->address, w->hw_wp_mask,
					bl->watchpoint_type);
}

/* Implement the "remove" breakpoint_ops method for
   masked hardware watchpoints.  */

static int
remove_masked_watchpoint (struct bp_location *bl)
{
  struct watchpoint *w = (struct watchpoint *) bl->owner;

  return target_remove_mask_watchpoint (bl->address, w->hw_wp_mask,
				        bl->watchpoint_type);
}

/* Implement the "resources_needed" breakpoint_ops method for
   masked hardware watchpoints.  */

static int
resources_needed_masked_watchpoint (const struct bp_location *bl)
{
  struct watchpoint *w = (struct watchpoint *) bl->owner;

  return target_masked_watch_num_registers (bl->address, w->hw_wp_mask);
}

/* Implement the "works_in_software_mode" breakpoint_ops method for
   masked hardware watchpoints.  */

static int
works_in_software_mode_masked_watchpoint (const struct breakpoint *b)
{
  return 0;
}

/* Implement the "print_it" breakpoint_ops method for
   masked hardware watchpoints.  */

static enum print_stop_action
print_it_masked_watchpoint (bpstat bs)
{
  struct breakpoint *b = bs->breakpoint_at;
  struct ui_out *uiout = current_uiout;

  /* Masked watchpoints have only one location.  */
  gdb_assert (b->loc && b->loc->next == NULL);

  switch (b->type)
    {
    case bp_hardware_watchpoint:
      annotate_watchpoint (b->number);
      if (ui_out_is_mi_like_p (uiout))
	ui_out_field_string
	  (uiout, "reason",
	   async_reason_lookup (EXEC_ASYNC_WATCHPOINT_TRIGGER));
      break;

    case bp_read_watchpoint:
      if (ui_out_is_mi_like_p (uiout))
	ui_out_field_string
	  (uiout, "reason",
	   async_reason_lookup (EXEC_ASYNC_READ_WATCHPOINT_TRIGGER));
      break;

    case bp_access_watchpoint:
      if (ui_out_is_mi_like_p (uiout))
	ui_out_field_string
	  (uiout, "reason",
	   async_reason_lookup (EXEC_ASYNC_ACCESS_WATCHPOINT_TRIGGER));
      break;
    default:
      internal_error (__FILE__, __LINE__,
		      _("Invalid hardware watchpoint type."));
    }

  mention (b);
  ui_out_text (uiout, _("\n\
Check the underlying instruction at PC for the memory\n\
address and value which triggered this watchpoint.\n"));
  ui_out_text (uiout, "\n");

  /* More than one watchpoint may have been triggered.  */
  return PRINT_UNKNOWN;
}

/* Implement the "print_one_detail" breakpoint_ops method for
   masked hardware watchpoints.  */

static void
print_one_detail_masked_watchpoint (const struct breakpoint *b,
				    struct ui_out *uiout)
{
  struct watchpoint *w = (struct watchpoint *) b;

  /* Masked watchpoints have only one location.  */
  gdb_assert (b->loc && b->loc->next == NULL);

  ui_out_text (uiout, "\tmask ");
  ui_out_field_core_addr (uiout, "mask", b->loc->gdbarch, w->hw_wp_mask);
  ui_out_text (uiout, "\n");
}

/* Implement the "print_mention" breakpoint_ops method for
   masked hardware watchpoints.  */

static void
print_mention_masked_watchpoint (struct breakpoint *b)
{
  struct watchpoint *w = (struct watchpoint *) b;
  struct ui_out *uiout = current_uiout;
  struct cleanup *ui_out_chain;

  switch (b->type)
    {
    case bp_hardware_watchpoint:
      ui_out_text (uiout, "Masked hardware watchpoint ");
      ui_out_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "wpt");
      break;
    case bp_read_watchpoint:
      ui_out_text (uiout, "Masked hardware read watchpoint ");
      ui_out_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "hw-rwpt");
      break;
    case bp_access_watchpoint:
      ui_out_text (uiout, "Masked hardware access (read/write) watchpoint ");
      ui_out_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "hw-awpt");
      break;
    default:
      internal_error (__FILE__, __LINE__,
		      _("Invalid hardware watchpoint type."));
    }

  ui_out_field_int (uiout, "number", b->number);
  ui_out_text (uiout, ": ");
  ui_out_field_string (uiout, "exp", w->exp_string);
  do_cleanups (ui_out_chain);
}

/* Implement the "print_recreate" breakpoint_ops method for
   masked hardware watchpoints.  */

static void
print_recreate_masked_watchpoint (struct breakpoint *b, struct ui_file *fp)
{
  struct watchpoint *w = (struct watchpoint *) b;
  char tmp[40];

  switch (b->type)
    {
    case bp_hardware_watchpoint:
      fprintf_unfiltered (fp, "watch");
      break;
    case bp_read_watchpoint:
      fprintf_unfiltered (fp, "rwatch");
      break;
    case bp_access_watchpoint:
      fprintf_unfiltered (fp, "awatch");
      break;
    default:
      internal_error (__FILE__, __LINE__,
		      _("Invalid hardware watchpoint type."));
    }

  sprintf_vma (tmp, w->hw_wp_mask);
  fprintf_unfiltered (fp, " %s mask 0x%s", w->exp_string, tmp);
  print_recreate_thread (b, fp);
}

/* The breakpoint_ops structure to be used in masked hardware watchpoints.  */

static struct breakpoint_ops masked_watchpoint_breakpoint_ops;

/* Tell whether the given watchpoint is a masked hardware watchpoint.  */

static int
is_masked_watchpoint (const struct breakpoint *b)
{
  return b->ops == &masked_watchpoint_breakpoint_ops;
}

/* accessflag:  hw_write:  watch write, 
                hw_read:   watch read, 
		hw_access: watch access (read or write) */
static void
watch_command_1 (const char *arg, int accessflag, int from_tty,
		 int just_location, int internal)
{
  volatile struct gdb_exception e;
  struct breakpoint *b, *scope_breakpoint = NULL;
  struct expression *exp;
  const struct block *exp_valid_block = NULL, *cond_exp_valid_block = NULL;
  struct value *val, *mark, *result;
  struct frame_info *frame;
  const char *exp_start = NULL;
  const char *exp_end = NULL;
  const char *tok, *end_tok;
  int toklen = -1;
  const char *cond_start = NULL;
  const char *cond_end = NULL;
  enum bptype bp_type;
  int thread = -1;
  int pc = 0;
  /* Flag to indicate whether we are going to use masks for
     the hardware watchpoint.  */
  int use_mask = 0;
  CORE_ADDR mask = 0;
  struct watchpoint *w;
  char *expression;
  struct cleanup *back_to;

  /* Make sure that we actually have parameters to parse.  */
  if (arg != NULL && arg[0] != '\0')
    {
      const char *value_start;

      exp_end = arg + strlen (arg);

      /* Look for "parameter value" pairs at the end
	 of the arguments string.  */
      for (tok = exp_end - 1; tok > arg; tok--)
	{
	  /* Skip whitespace at the end of the argument list.  */
	  while (tok > arg && (*tok == ' ' || *tok == '\t'))
	    tok--;

	  /* Find the beginning of the last token.
	     This is the value of the parameter.  */
	  while (tok > arg && (*tok != ' ' && *tok != '\t'))
	    tok--;
	  value_start = tok + 1;

	  /* Skip whitespace.  */
	  while (tok > arg && (*tok == ' ' || *tok == '\t'))
	    tok--;

	  end_tok = tok;

	  /* Find the beginning of the second to last token.
	     This is the parameter itself.  */
	  while (tok > arg && (*tok != ' ' && *tok != '\t'))
	    tok--;
	  tok++;
	  toklen = end_tok - tok + 1;

	  if (toklen == 6 && !strncmp (tok, "thread", 6))
	    {
	      /* At this point we've found a "thread" token, which means
		 the user is trying to set a watchpoint that triggers
		 only in a specific thread.  */
	      char *endp;

	      if (thread != -1)
		error(_("You can specify only one thread."));

	      /* Extract the thread ID from the next token.  */
	      thread = strtol (value_start, &endp, 0);

	      /* Check if the user provided a valid numeric value for the
		 thread ID.  */
	      if (*endp != ' ' && *endp != '\t' && *endp != '\0')
		error (_("Invalid thread ID specification %s."), value_start);

	      /* Check if the thread actually exists.  */
	      if (!valid_thread_id (thread))
		invalid_thread_id_error (thread);
	    }
	  else if (toklen == 4 && !strncmp (tok, "mask", 4))
	    {
	      /* We've found a "mask" token, which means the user wants to
		 create a hardware watchpoint that is going to have the mask
		 facility.  */
	      struct value *mask_value, *mark;

	      if (use_mask)
		error(_("You can specify only one mask."));

	      use_mask = just_location = 1;

	      mark = value_mark ();
	      mask_value = parse_to_comma_and_eval (&value_start);
	      mask = value_as_address (mask_value);
	      value_free_to_mark (mark);
	    }
	  else
	    /* We didn't recognize what we found.  We should stop here.  */
	    break;

	  /* Truncate the string and get rid of the "parameter value" pair before
	     the arguments string is parsed by the parse_exp_1 function.  */
	  exp_end = tok;
	}
    }
  else
    exp_end = arg;

  /* Parse the rest of the arguments.  From here on out, everything
     is in terms of a newly allocated string instead of the original
     ARG.  */
  innermost_block = NULL;
  expression = savestring (arg, exp_end - arg);
  back_to = make_cleanup (xfree, expression);
  exp_start = arg = expression;
  exp = parse_exp_1 (&arg, 0, 0, 0);
  exp_end = arg;
  /* Remove trailing whitespace from the expression before saving it.
     This makes the eventual display of the expression string a bit
     prettier.  */
  while (exp_end > exp_start && (exp_end[-1] == ' ' || exp_end[-1] == '\t'))
    --exp_end;

  /* Checking if the expression is not constant.  */
  if (watchpoint_exp_is_const (exp))
    {
      int len;

      len = exp_end - exp_start;
      while (len > 0 && isspace (exp_start[len - 1]))
	len--;
      error (_("Cannot watch constant value `%.*s'."), len, exp_start);
    }

  exp_valid_block = innermost_block;
  mark = value_mark ();
  fetch_subexp_value (exp, &pc, &val, &result, NULL, just_location);

  if (just_location)
    {
      int ret;

      exp_valid_block = NULL;
      val = value_addr (result);
      release_value (val);
      value_free_to_mark (mark);

      if (use_mask)
	{
	  ret = target_masked_watch_num_registers (value_as_address (val),
						   mask);
	  if (ret == -1)
	    error (_("This target does not support masked watchpoints."));
	  else if (ret == -2)
	    error (_("Invalid mask or memory region."));
	}
    }
  else if (val != NULL)
    release_value (val);

  tok = skip_spaces_const (arg);
  end_tok = skip_to_space_const (tok);

  toklen = end_tok - tok;
  if (toklen >= 1 && strncmp (tok, "if", toklen) == 0)
    {
      struct expression *cond;

      innermost_block = NULL;
      tok = cond_start = end_tok + 1;
      cond = parse_exp_1 (&tok, 0, 0, 0);

      /* The watchpoint expression may not be local, but the condition
	 may still be.  E.g.: `watch global if local > 0'.  */
      cond_exp_valid_block = innermost_block;

      xfree (cond);
      cond_end = tok;
    }
  if (*tok)
    error (_("Junk at end of command."));

  frame = block_innermost_frame (exp_valid_block);

  /* If the expression is "local", then set up a "watchpoint scope"
     breakpoint at the point where we've left the scope of the watchpoint
     expression.  Create the scope breakpoint before the watchpoint, so
     that we will encounter it first in bpstat_stop_status.  */
  if (exp_valid_block && frame)
    {
      if (frame_id_p (frame_unwind_caller_id (frame)))
	{
 	  scope_breakpoint
	    = create_internal_breakpoint (frame_unwind_caller_arch (frame),
					  frame_unwind_caller_pc (frame),
					  bp_watchpoint_scope,
					  &momentary_breakpoint_ops);

	  scope_breakpoint->enable_state = bp_enabled;

	  /* Automatically delete the breakpoint when it hits.  */
	  scope_breakpoint->disposition = disp_del;

	  /* Only break in the proper frame (help with recursion).  */
	  scope_breakpoint->frame_id = frame_unwind_caller_id (frame);

	  /* Set the address at which we will stop.  */
	  scope_breakpoint->loc->gdbarch
	    = frame_unwind_caller_arch (frame);
	  scope_breakpoint->loc->requested_address
	    = frame_unwind_caller_pc (frame);
	  scope_breakpoint->loc->address
	    = adjust_breakpoint_address (scope_breakpoint->loc->gdbarch,
					 scope_breakpoint->loc->requested_address,
					 scope_breakpoint->type);
	}
    }

  /* Now set up the breakpoint.  We create all watchpoints as hardware
     watchpoints here even if hardware watchpoints are turned off, a call
     to update_watchpoint later in this function will cause the type to
     drop back to bp_watchpoint (software watchpoint) if required.  */

  if (accessflag == hw_read)
    bp_type = bp_read_watchpoint;
  else if (accessflag == hw_access)
    bp_type = bp_access_watchpoint;
  else
    bp_type = bp_hardware_watchpoint;

  w = XCNEW (struct watchpoint);
  b = &w->base;
  if (use_mask)
    init_raw_breakpoint_without_location (b, NULL, bp_type,
					  &masked_watchpoint_breakpoint_ops);
  else
    init_raw_breakpoint_without_location (b, NULL, bp_type,
					  &watchpoint_breakpoint_ops);
  b->thread = thread;
  b->disposition = disp_donttouch;
  b->pspace = current_program_space;
  w->exp = exp;
  w->exp_valid_block = exp_valid_block;
  w->cond_exp_valid_block = cond_exp_valid_block;
  if (just_location)
    {
      struct type *t = value_type (val);
      CORE_ADDR addr = value_as_address (val);
      char *name;

      t = check_typedef (TYPE_TARGET_TYPE (check_typedef (t)));
      name = type_to_string (t);

      w->exp_string_reparse = xstrprintf ("* (%s *) %s", name,
					  core_addr_to_string (addr));
      xfree (name);

      w->exp_string = xstrprintf ("-location %.*s",
				  (int) (exp_end - exp_start), exp_start);

      /* The above expression is in C.  */
      b->language = language_c;
    }
  else
    w->exp_string = savestring (exp_start, exp_end - exp_start);

  if (use_mask)
    {
      w->hw_wp_mask = mask;
    }
  else
    {
      w->val = val;
      w->val_valid = 1;
    }

  if (cond_start)
    b->cond_string = savestring (cond_start, cond_end - cond_start);
  else
    b->cond_string = 0;

  if (frame)
    {
      w->watchpoint_frame = get_frame_id (frame);
      w->watchpoint_thread = inferior_ptid;
    }
  else
    {
      w->watchpoint_frame = null_frame_id;
      w->watchpoint_thread = null_ptid;
    }

  if (scope_breakpoint != NULL)
    {
      /* The scope breakpoint is related to the watchpoint.  We will
	 need to act on them together.  */
      b->related_breakpoint = scope_breakpoint;
      scope_breakpoint->related_breakpoint = b;
    }

  if (!just_location)
    value_free_to_mark (mark);

  TRY_CATCH (e, RETURN_MASK_ALL)
    {
      /* Finally update the new watchpoint.  This creates the locations
	 that should be inserted.  */
      update_watchpoint (w, 1);
    }
  if (e.reason < 0)
    {
      delete_breakpoint (b);
      throw_exception (e);
    }

  install_breakpoint (internal, b, 1);
  do_cleanups (back_to);
}

/* Return count of debug registers needed to watch the given expression.
   If the watchpoint cannot be handled in hardware return zero.  */

static int
can_use_hardware_watchpoint (struct value *v)
{
  int found_memory_cnt = 0;
  struct value *head = v;

  /* Did the user specifically forbid us to use hardware watchpoints? */
  if (!can_use_hw_watchpoints)
    return 0;

  /* Make sure that the value of the expression depends only upon
     memory contents, and values computed from them within GDB.  If we
     find any register references or function calls, we can't use a
     hardware watchpoint.

     The idea here is that evaluating an expression generates a series
     of values, one holding the value of every subexpression.  (The
     expression a*b+c has five subexpressions: a, b, a*b, c, and
     a*b+c.)  GDB's values hold almost enough information to establish
     the criteria given above --- they identify memory lvalues,
     register lvalues, computed values, etcetera.  So we can evaluate
     the expression, and then scan the chain of values that leaves
     behind to decide whether we can detect any possible change to the
     expression's final value using only hardware watchpoints.

     However, I don't think that the values returned by inferior
     function calls are special in any way.  So this function may not
     notice that an expression involving an inferior function call
     can't be watched with hardware watchpoints.  FIXME.  */
  for (; v; v = value_next (v))
    {
      if (VALUE_LVAL (v) == lval_memory)
	{
	  if (v != head && value_lazy (v))
	    /* A lazy memory lvalue in the chain is one that GDB never
	       needed to fetch; we either just used its address (e.g.,
	       `a' in `a.b') or we never needed it at all (e.g., `a'
	       in `a,b').  This doesn't apply to HEAD; if that is
	       lazy then it was not readable, but watch it anyway.  */
	    ;
	  else
	    {
	      /* Ahh, memory we actually used!  Check if we can cover
                 it with hardware watchpoints.  */
	      struct type *vtype = check_typedef (value_type (v));

	      /* We only watch structs and arrays if user asked for it
		 explicitly, never if they just happen to appear in a
		 middle of some value chain.  */
	      if (v == head
		  || (TYPE_CODE (vtype) != TYPE_CODE_STRUCT
		      && TYPE_CODE (vtype) != TYPE_CODE_ARRAY))
		{
		  CORE_ADDR vaddr = value_address (v);
		  int len;
		  int num_regs;

		  len = (target_exact_watchpoints
			 && is_scalar_type_recursive (vtype))?
		    1 : TYPE_LENGTH (value_type (v));

		  num_regs = target_region_ok_for_hw_watchpoint (vaddr, len);
		  if (!num_regs)
		    return 0;
		  else
		    found_memory_cnt += num_regs;
		}
	    }
	}
      else if (VALUE_LVAL (v) != not_lval
	       && deprecated_value_modifiable (v) == 0)
	return 0;	/* These are values from the history (e.g., $1).  */
      else if (VALUE_LVAL (v) == lval_register)
	return 0;	/* Cannot watch a register with a HW watchpoint.  */
    }

  /* The expression itself looks suitable for using a hardware
     watchpoint, but give the target machine a chance to reject it.  */
  return found_memory_cnt;
}

void
watch_command_wrapper (char *arg, int from_tty, int internal)
{
  watch_command_1 (arg, hw_write, from_tty, 0, internal);
}

/* A helper function that looks for the "-location" argument and then
   calls watch_command_1.  */

static void
watch_maybe_just_location (char *arg, int accessflag, int from_tty)
{
  int just_location = 0;

  if (arg
      && (check_for_argument (&arg, "-location", sizeof ("-location") - 1)
	  || check_for_argument (&arg, "-l", sizeof ("-l") - 1)))
    {
      arg = skip_spaces (arg);
      just_location = 1;
    }

  watch_command_1 (arg, accessflag, from_tty, just_location, 0);
}

static void
watch_command (char *arg, int from_tty)
{
  watch_maybe_just_location (arg, hw_write, from_tty);
}

void
rwatch_command_wrapper (char *arg, int from_tty, int internal)
{
  watch_command_1 (arg, hw_read, from_tty, 0, internal);
}

static void
rwatch_command (char *arg, int from_tty)
{
  watch_maybe_just_location (arg, hw_read, from_tty);
}

void
awatch_command_wrapper (char *arg, int from_tty, int internal)
{
  watch_command_1 (arg, hw_access, from_tty, 0, internal);
}

static void
awatch_command (char *arg, int from_tty)
{
  watch_maybe_just_location (arg, hw_access, from_tty);
}


/* Helper routines for the until_command routine in infcmd.c.  Here
   because it uses the mechanisms of breakpoints.  */

struct until_break_command_continuation_args
{
  struct breakpoint *breakpoint;
  struct breakpoint *breakpoint2;
  int thread_num;
};

/* This function is called by fetch_inferior_event via the
   cmd_continuation pointer, to complete the until command.  It takes
   care of cleaning up the temporary breakpoints set up by the until
   command.  */
static void
until_break_command_continuation (void *arg, int err)
{
  struct until_break_command_continuation_args *a = arg;

  delete_breakpoint (a->breakpoint);
  if (a->breakpoint2)
    delete_breakpoint (a->breakpoint2);
  delete_longjmp_breakpoint (a->thread_num);
}

void
until_break_command (char *arg, int from_tty, int anywhere)
{
  struct symtabs_and_lines sals;
  struct symtab_and_line sal;
  struct frame_info *frame;
  struct gdbarch *frame_gdbarch;
  struct frame_id stack_frame_id;
  struct frame_id caller_frame_id;
  struct breakpoint *breakpoint;
  struct breakpoint *breakpoint2 = NULL;
  struct cleanup *old_chain;
  int thread;
  struct thread_info *tp;

  clear_proceed_status ();

  /* Set a breakpoint where the user wants it and at return from
     this function.  */

  if (last_displayed_sal_is_valid ())
    sals = decode_line_1 (&arg, DECODE_LINE_FUNFIRSTLINE,
			  get_last_displayed_symtab (),
			  get_last_displayed_line ());
  else
    sals = decode_line_1 (&arg, DECODE_LINE_FUNFIRSTLINE,
			  (struct symtab *) NULL, 0);

  if (sals.nelts != 1)
    error (_("Couldn't get information on specified line."));

  sal = sals.sals[0];
  xfree (sals.sals);	/* malloc'd, so freed.  */

  if (*arg)
    error (_("Junk at end of arguments."));

  resolve_sal_pc (&sal);

  tp = inferior_thread ();
  thread = tp->num;

  old_chain = make_cleanup (null_cleanup, NULL);

  /* Note linespec handling above invalidates the frame chain.
     Installing a breakpoint also invalidates the frame chain (as it
     may need to switch threads), so do any frame handling before
     that.  */

  frame = get_selected_frame (NULL);
  frame_gdbarch = get_frame_arch (frame);
  stack_frame_id = get_stack_frame_id (frame);
  caller_frame_id = frame_unwind_caller_id (frame);

  /* Keep within the current frame, or in frames called by the current
     one.  */

  if (frame_id_p (caller_frame_id))
    {
      struct symtab_and_line sal2;

      sal2 = find_pc_line (frame_unwind_caller_pc (frame), 0);
      sal2.pc = frame_unwind_caller_pc (frame);
      breakpoint2 = set_momentary_breakpoint (frame_unwind_caller_arch (frame),
					      sal2,
					      caller_frame_id,
					      bp_until);
      make_cleanup_delete_breakpoint (breakpoint2);

      set_longjmp_breakpoint (tp, caller_frame_id);
      make_cleanup (delete_longjmp_breakpoint_cleanup, &thread);
    }

  /* set_momentary_breakpoint could invalidate FRAME.  */
  frame = NULL;

  if (anywhere)
    /* If the user told us to continue until a specified location,
       we don't specify a frame at which we need to stop.  */
    breakpoint = set_momentary_breakpoint (frame_gdbarch, sal,
					   null_frame_id, bp_until);
  else
    /* Otherwise, specify the selected frame, because we want to stop
       only at the very same frame.  */
    breakpoint = set_momentary_breakpoint (frame_gdbarch, sal,
					   stack_frame_id, bp_until);
  make_cleanup_delete_breakpoint (breakpoint);

  proceed (-1, GDB_SIGNAL_DEFAULT, 0);

  /* If we are running asynchronously, and proceed call above has
     actually managed to start the target, arrange for breakpoints to
     be deleted when the target stops.  Otherwise, we're already
     stopped and delete breakpoints via cleanup chain.  */

  if (target_can_async_p () && is_running (inferior_ptid))
    {
      struct until_break_command_continuation_args *args;
      args = xmalloc (sizeof (*args));

      args->breakpoint = breakpoint;
      args->breakpoint2 = breakpoint2;
      args->thread_num = thread;

      discard_cleanups (old_chain);
      add_continuation (inferior_thread (),
			until_break_command_continuation, args,
			xfree);
    }
  else
    do_cleanups (old_chain);
}

/* This function attempts to parse an optional "if <cond>" clause
   from the arg string.  If one is not found, it returns NULL.

   Else, it returns a pointer to the condition string.  (It does not
   attempt to evaluate the string against a particular block.)  And,
   it updates arg to point to the first character following the parsed
   if clause in the arg string.  */

char *
ep_parse_optional_if_clause (char **arg)
{
  char *cond_string;

  if (((*arg)[0] != 'i') || ((*arg)[1] != 'f') || !isspace ((*arg)[2]))
    return NULL;

  /* Skip the "if" keyword.  */
  (*arg) += 2;

  /* Skip any extra leading whitespace, and record the start of the
     condition string.  */
  *arg = skip_spaces (*arg);
  cond_string = *arg;

  /* Assume that the condition occupies the remainder of the arg
     string.  */
  (*arg) += strlen (cond_string);

  return cond_string;
}

/* Commands to deal with catching events, such as signals, exceptions,
   process start/exit, etc.  */

typedef enum
{
  catch_fork_temporary, catch_vfork_temporary,
  catch_fork_permanent, catch_vfork_permanent
}
catch_fork_kind;

static void
catch_fork_command_1 (char *arg, int from_tty, 
		      struct cmd_list_element *command)
{
  struct gdbarch *gdbarch = get_current_arch ();
  char *cond_string = NULL;
  catch_fork_kind fork_kind;
  int tempflag;

  fork_kind = (catch_fork_kind) (uintptr_t) get_cmd_context (command);
  tempflag = (fork_kind == catch_fork_temporary
	      || fork_kind == catch_vfork_temporary);

  if (!arg)
    arg = "";
  arg = skip_spaces (arg);

  /* The allowed syntax is:
     catch [v]fork
     catch [v]fork if <cond>

     First, check if there's an if clause.  */
  cond_string = ep_parse_optional_if_clause (&arg);

  if ((*arg != '\0') && !isspace (*arg))
    error (_("Junk at end of arguments."));

  /* If this target supports it, create a fork or vfork catchpoint
     and enable reporting of such events.  */
  switch (fork_kind)
    {
    case catch_fork_temporary:
    case catch_fork_permanent:
      create_fork_vfork_event_catchpoint (gdbarch, tempflag, cond_string,
                                          &catch_fork_breakpoint_ops);
      break;
    case catch_vfork_temporary:
    case catch_vfork_permanent:
      create_fork_vfork_event_catchpoint (gdbarch, tempflag, cond_string,
                                          &catch_vfork_breakpoint_ops);
      break;
    default:
      error (_("unsupported or unknown fork kind; cannot catch it"));
      break;
    }
}

static void
catch_exec_command_1 (char *arg, int from_tty, 
		      struct cmd_list_element *command)
{
  struct exec_catchpoint *c;
  struct gdbarch *gdbarch = get_current_arch ();
  int tempflag;
  char *cond_string = NULL;

  tempflag = get_cmd_context (command) == CATCH_TEMPORARY;

  if (!arg)
    arg = "";
  arg = skip_spaces (arg);

  /* The allowed syntax is:
     catch exec
     catch exec if <cond>

     First, check if there's an if clause.  */
  cond_string = ep_parse_optional_if_clause (&arg);

  if ((*arg != '\0') && !isspace (*arg))
    error (_("Junk at end of arguments."));

  c = XNEW (struct exec_catchpoint);
  init_catchpoint (&c->base, gdbarch, tempflag, cond_string,
		   &catch_exec_breakpoint_ops);
  c->exec_pathname = NULL;

  install_breakpoint (0, &c->base, 1);
}

void
init_ada_exception_breakpoint (struct breakpoint *b,
			       struct gdbarch *gdbarch,
			       struct symtab_and_line sal,
			       char *addr_string,
			       const struct breakpoint_ops *ops,
			       int tempflag,
			       int enabled,
			       int from_tty)
{
  if (from_tty)
    {
      struct gdbarch *loc_gdbarch = get_sal_arch (sal);
      if (!loc_gdbarch)
	loc_gdbarch = gdbarch;

      describe_other_breakpoints (loc_gdbarch,
				  sal.pspace, sal.pc, sal.section, -1);
      /* FIXME: brobecker/2006-12-28: Actually, re-implement a special
         version for exception catchpoints, because two catchpoints
         used for different exception names will use the same address.
         In this case, a "breakpoint ... also set at..." warning is
         unproductive.  Besides, the warning phrasing is also a bit
         inappropriate, we should use the word catchpoint, and tell
         the user what type of catchpoint it is.  The above is good
         enough for now, though.  */
    }

  init_raw_breakpoint (b, gdbarch, sal, bp_breakpoint, ops);

  b->enable_state = enabled ? bp_enabled : bp_disabled;
  b->disposition = tempflag ? disp_del : disp_donttouch;
  b->addr_string = addr_string;
  b->language = language_ada;
}

/* Splits the argument using space as delimiter.  Returns an xmalloc'd
   filter list, or NULL if no filtering is required.  */
static VEC(int) *
catch_syscall_split_args (char *arg)
{
  VEC(int) *result = NULL;
  struct cleanup *cleanup = make_cleanup (VEC_cleanup (int), &result);

  while (*arg != '\0')
    {
      int i, syscall_number;
      char *endptr;
      char cur_name[128];
      struct syscall s;

      /* Skip whitespace.  */
      arg = skip_spaces (arg);

      for (i = 0; i < 127 && arg[i] && !isspace (arg[i]); ++i)
	cur_name[i] = arg[i];
      cur_name[i] = '\0';
      arg += i;

      /* Check if the user provided a syscall name or a number.  */
      syscall_number = (int) strtol (cur_name, &endptr, 0);
      if (*endptr == '\0')
	get_syscall_by_number (syscall_number, &s);
      else
	{
	  /* We have a name.  Let's check if it's valid and convert it
	     to a number.  */
	  get_syscall_by_name (cur_name, &s);

	  if (s.number == UNKNOWN_SYSCALL)
	    /* Here we have to issue an error instead of a warning,
	       because GDB cannot do anything useful if there's no
	       syscall number to be caught.  */
	    error (_("Unknown syscall name '%s'."), cur_name);
	}

      /* Ok, it's valid.  */
      VEC_safe_push (int, result, s.number);
    }

  discard_cleanups (cleanup);
  return result;
}

/* Implement the "catch syscall" command.  */

static void
catch_syscall_command_1 (char *arg, int from_tty, 
			 struct cmd_list_element *command)
{
  int tempflag;
  VEC(int) *filter;
  struct syscall s;
  struct gdbarch *gdbarch = get_current_arch ();

  /* Checking if the feature if supported.  */
  if (gdbarch_get_syscall_number_p (gdbarch) == 0)
    error (_("The feature 'catch syscall' is not supported on \
this architecture yet."));

  tempflag = get_cmd_context (command) == CATCH_TEMPORARY;

  arg = skip_spaces (arg);

  /* We need to do this first "dummy" translation in order
     to get the syscall XML file loaded or, most important,
     to display a warning to the user if there's no XML file
     for his/her architecture.  */
  get_syscall_by_number (0, &s);

  /* The allowed syntax is:
     catch syscall
     catch syscall <name | number> [<name | number> ... <name | number>]

     Let's check if there's a syscall name.  */

  if (arg != NULL)
    filter = catch_syscall_split_args (arg);
  else
    filter = NULL;

  create_syscall_event_catchpoint (tempflag, filter,
				   &catch_syscall_breakpoint_ops);
}

static void
catch_command (char *arg, int from_tty)
{
  error (_("Catch requires an event name."));
}


static void
tcatch_command (char *arg, int from_tty)
{
  error (_("Catch requires an event name."));
}

/* A qsort comparison function that sorts breakpoints in order.  */

static int
compare_breakpoints (const void *a, const void *b)
{
  const breakpoint_p *ba = a;
  uintptr_t ua = (uintptr_t) *ba;
  const breakpoint_p *bb = b;
  uintptr_t ub = (uintptr_t) *bb;

  if ((*ba)->number < (*bb)->number)
    return -1;
  else if ((*ba)->number > (*bb)->number)
    return 1;

  /* Now sort by address, in case we see, e..g, two breakpoints with
     the number 0.  */
  if (ua < ub)
    return -1;
  return ua > ub ? 1 : 0;
}

/* Delete breakpoints by address or line.  */

static void
clear_command (char *arg, int from_tty)
{
  struct breakpoint *b, *prev;
  VEC(breakpoint_p) *found = 0;
  int ix;
  int default_match;
  struct symtabs_and_lines sals;
  struct symtab_and_line sal;
  int i;
  struct cleanup *cleanups = make_cleanup (null_cleanup, NULL);

  if (arg)
    {
      sals = decode_line_with_current_source (arg,
					      (DECODE_LINE_FUNFIRSTLINE
					       | DECODE_LINE_LIST_MODE));
      make_cleanup (xfree, sals.sals);
      default_match = 0;
    }
  else
    {
      sals.sals = (struct symtab_and_line *)
	xmalloc (sizeof (struct symtab_and_line));
      make_cleanup (xfree, sals.sals);
      init_sal (&sal);		/* Initialize to zeroes.  */

      /* Set sal's line, symtab, pc, and pspace to the values
	 corresponding to the last call to print_frame_info.  If the
	 codepoint is not valid, this will set all the fields to 0.  */
      get_last_displayed_sal (&sal);
      if (sal.symtab == 0)
	error (_("No source file specified."));

      sals.sals[0] = sal;
      sals.nelts = 1;

      default_match = 1;
    }

  /* We don't call resolve_sal_pc here.  That's not as bad as it
     seems, because all existing breakpoints typically have both
     file/line and pc set.  So, if clear is given file/line, we can
     match this to existing breakpoint without obtaining pc at all.

     We only support clearing given the address explicitly 
     present in breakpoint table.  Say, we've set breakpoint 
     at file:line.  There were several PC values for that file:line,
     due to optimization, all in one block.

     We've picked one PC value.  If "clear" is issued with another
     PC corresponding to the same file:line, the breakpoint won't
     be cleared.  We probably can still clear the breakpoint, but 
     since the other PC value is never presented to user, user
     can only find it by guessing, and it does not seem important
     to support that.  */

  /* For each line spec given, delete bps which correspond to it.  Do
     it in two passes, solely to preserve the current behavior that
     from_tty is forced true if we delete more than one
     breakpoint.  */

  found = NULL;
  make_cleanup (VEC_cleanup (breakpoint_p), &found);
  for (i = 0; i < sals.nelts; i++)
    {
      const char *sal_fullname;

      /* If exact pc given, clear bpts at that pc.
         If line given (pc == 0), clear all bpts on specified line.
         If defaulting, clear all bpts on default line
         or at default pc.

         defaulting    sal.pc != 0    tests to do

         0              1             pc
         1              1             pc _and_ line
         0              0             line
         1              0             <can't happen> */

      sal = sals.sals[i];
      sal_fullname = (sal.symtab == NULL
		      ? NULL : symtab_to_fullname (sal.symtab));

      /* Find all matching breakpoints and add them to 'found'.  */
      ALL_BREAKPOINTS (b)
	{
	  int match = 0;
	  /* Are we going to delete b?  */
	  if (b->type != bp_none && !is_watchpoint (b))
	    {
	      struct bp_location *loc = b->loc;
	      for (; loc; loc = loc->next)
		{
		  /* If the user specified file:line, don't allow a PC
		     match.  This matches historical gdb behavior.  */
		  int pc_match = (!sal.explicit_line
				  && sal.pc
				  && (loc->pspace == sal.pspace)
				  && (loc->address == sal.pc)
				  && (!section_is_overlay (loc->section)
				      || loc->section == sal.section));
		  int line_match = 0;

		  if ((default_match || sal.explicit_line)
		      && loc->symtab != NULL
		      && sal_fullname != NULL
		      && sal.pspace == loc->pspace
		      && loc->line_number == sal.line
		      && filename_cmp (symtab_to_fullname (loc->symtab),
				       sal_fullname) == 0)
		    line_match = 1;

		  if (pc_match || line_match)
		    {
		      match = 1;
		      break;
		    }
		}
	    }

	  if (match)
	    VEC_safe_push(breakpoint_p, found, b);
	}
    }

  /* Now go thru the 'found' chain and delete them.  */
  if (VEC_empty(breakpoint_p, found))
    {
      if (arg)
	error (_("No breakpoint at %s."), arg);
      else
	error (_("No breakpoint at this line."));
    }

  /* Remove duplicates from the vec.  */
  qsort (VEC_address (breakpoint_p, found),
	 VEC_length (breakpoint_p, found),
	 sizeof (breakpoint_p),
	 compare_breakpoints);
  prev = VEC_index (breakpoint_p, found, 0);
  for (ix = 1; VEC_iterate (breakpoint_p, found, ix, b); ++ix)
    {
      if (b == prev)
	{
	  VEC_ordered_remove (breakpoint_p, found, ix);
	  --ix;
	}
    }

  if (VEC_length(breakpoint_p, found) > 1)
    from_tty = 1;	/* Always report if deleted more than one.  */
  if (from_tty)
    {
      if (VEC_length(breakpoint_p, found) == 1)
	printf_unfiltered (_("Deleted breakpoint "));
      else
	printf_unfiltered (_("Deleted breakpoints "));
    }

  for (ix = 0; VEC_iterate(breakpoint_p, found, ix, b); ix++)
    {
      if (from_tty)
	printf_unfiltered ("%d ", b->number);
      delete_breakpoint (b);
    }
  if (from_tty)
    putchar_unfiltered ('\n');

  do_cleanups (cleanups);
}

/* Delete breakpoint in BS if they are `delete' breakpoints and
   all breakpoints that are marked for deletion, whether hit or not.
   This is called after any breakpoint is hit, or after errors.  */

void
breakpoint_auto_delete (bpstat bs)
{
  struct breakpoint *b, *b_tmp;

  for (; bs; bs = bs->next)
    if (bs->breakpoint_at
	&& bs->breakpoint_at->disposition == disp_del
	&& bs->stop)
      delete_breakpoint (bs->breakpoint_at);

  ALL_BREAKPOINTS_SAFE (b, b_tmp)
  {
    if (b->disposition == disp_del_at_next_stop)
      delete_breakpoint (b);
  }
}

/* A comparison function for bp_location AP and BP being interfaced to
   qsort.  Sort elements primarily by their ADDRESS (no matter what
   does breakpoint_address_is_meaningful say for its OWNER),
   secondarily by ordering first bp_permanent OWNERed elements and
   terciarily just ensuring the array is sorted stable way despite
   qsort being an unstable algorithm.  */

static int
bp_location_compare (const void *ap, const void *bp)
{
  struct bp_location *a = *(void **) ap;
  struct bp_location *b = *(void **) bp;
  /* A and B come from existing breakpoints having non-NULL OWNER.  */
  int a_perm = a->owner->enable_state == bp_permanent;
  int b_perm = b->owner->enable_state == bp_permanent;

  if (a->address != b->address)
    return (a->address > b->address) - (a->address < b->address);

  /* Sort locations at the same address by their pspace number, keeping
     locations of the same inferior (in a multi-inferior environment)
     grouped.  */

  if (a->pspace->num != b->pspace->num)
    return ((a->pspace->num > b->pspace->num)
	    - (a->pspace->num < b->pspace->num));

  /* Sort permanent breakpoints first.  */
  if (a_perm != b_perm)
    return (a_perm < b_perm) - (a_perm > b_perm);

  /* Make the internal GDB representation stable across GDB runs
     where A and B memory inside GDB can differ.  Breakpoint locations of
     the same type at the same address can be sorted in arbitrary order.  */

  if (a->owner->number != b->owner->number)
    return ((a->owner->number > b->owner->number)
	    - (a->owner->number < b->owner->number));

  return (a > b) - (a < b);
}

/* Set bp_location_placed_address_before_address_max and
   bp_location_shadow_len_after_address_max according to the current
   content of the bp_location array.  */

static void
bp_location_target_extensions_update (void)
{
  struct bp_location *bl, **blp_tmp;

  bp_location_placed_address_before_address_max = 0;
  bp_location_shadow_len_after_address_max = 0;

  ALL_BP_LOCATIONS (bl, blp_tmp)
    {
      CORE_ADDR start, end, addr;

      if (!bp_location_has_shadow (bl))
	continue;

      start = bl->target_info.placed_address;
      end = start + bl->target_info.shadow_len;

      gdb_assert (bl->address >= start);
      addr = bl->address - start;
      if (addr > bp_location_placed_address_before_address_max)
	bp_location_placed_address_before_address_max = addr;

      /* Zero SHADOW_LEN would not pass bp_location_has_shadow.  */

      gdb_assert (bl->address < end);
      addr = end - bl->address;
      if (addr > bp_location_shadow_len_after_address_max)
	bp_location_shadow_len_after_address_max = addr;
    }
}

/* Download tracepoint locations if they haven't been.  */

static void
download_tracepoint_locations (void)
{
  struct breakpoint *b;
  struct cleanup *old_chain;

  if (!target_can_download_tracepoint ())
    return;

  old_chain = save_current_space_and_thread ();

  ALL_TRACEPOINTS (b)
    {
      struct bp_location *bl;
      struct tracepoint *t;
      int bp_location_downloaded = 0;

      if ((b->type == bp_fast_tracepoint
	   ? !may_insert_fast_tracepoints
	   : !may_insert_tracepoints))
	continue;

      for (bl = b->loc; bl; bl = bl->next)
	{
	  /* In tracepoint, locations are _never_ duplicated, so
	     should_be_inserted is equivalent to
	     unduplicated_should_be_inserted.  */
	  if (!should_be_inserted (bl) || bl->inserted)
	    continue;

	  switch_to_program_space_and_thread (bl->pspace);

	  target_download_tracepoint (bl);

	  bl->inserted = 1;
	  bp_location_downloaded = 1;
	}
      t = (struct tracepoint *) b;
      t->number_on_target = b->number;
      if (bp_location_downloaded)
	observer_notify_breakpoint_modified (b);
    }

  do_cleanups (old_chain);
}

/* Swap the insertion/duplication state between two locations.  */

static void
swap_insertion (struct bp_location *left, struct bp_location *right)
{
  const int left_inserted = left->inserted;
  const int left_duplicate = left->duplicate;
  const int left_needs_update = left->needs_update;
  const struct bp_target_info left_target_info = left->target_info;

  /* Locations of tracepoints can never be duplicated.  */
  if (is_tracepoint (left->owner))
    gdb_assert (!left->duplicate);
  if (is_tracepoint (right->owner))
    gdb_assert (!right->duplicate);

  left->inserted = right->inserted;
  left->duplicate = right->duplicate;
  left->needs_update = right->needs_update;
  left->target_info = right->target_info;
  right->inserted = left_inserted;
  right->duplicate = left_duplicate;
  right->needs_update = left_needs_update;
  right->target_info = left_target_info;
}

/* Force the re-insertion of the locations at ADDRESS.  This is called
   once a new/deleted/modified duplicate location is found and we are evaluating
   conditions on the target's side.  Such conditions need to be updated on
   the target.  */

static void
force_breakpoint_reinsertion (struct bp_location *bl)
{
  struct bp_location **locp = NULL, **loc2p;
  struct bp_location *loc;
  CORE_ADDR address = 0;
  int pspace_num;

  address = bl->address;
  pspace_num = bl->pspace->num;

  /* This is only meaningful if the target is
     evaluating conditions and if the user has
     opted for condition evaluation on the target's
     side.  */
  if (gdb_evaluates_breakpoint_condition_p ()
      || !target_supports_evaluation_of_breakpoint_conditions ())
    return;

  /* Flag all breakpoint locations with this address and
     the same program space as the location
     as "its condition has changed".  We need to
     update the conditions on the target's side.  */
  ALL_BP_LOCATIONS_AT_ADDR (loc2p, locp, address)
    {
      loc = *loc2p;

      if (!is_breakpoint (loc->owner)
	  || pspace_num != loc->pspace->num)
	continue;

      /* Flag the location appropriately.  We use a different state to
	 let everyone know that we already updated the set of locations
	 with addr bl->address and program space bl->pspace.  This is so
	 we don't have to keep calling these functions just to mark locations
	 that have already been marked.  */
      loc->condition_changed = condition_updated;

      /* Free the agent expression bytecode as well.  We will compute
	 it later on.  */
      if (loc->cond_bytecode)
	{
	  free_agent_expr (loc->cond_bytecode);
	  loc->cond_bytecode = NULL;
	}
    }
}

/* If SHOULD_INSERT is false, do not insert any breakpoint locations
   into the inferior, only remove already-inserted locations that no
   longer should be inserted.  Functions that delete a breakpoint or
   breakpoints should pass false, so that deleting a breakpoint
   doesn't have the side effect of inserting the locations of other
   breakpoints that are marked not-inserted, but should_be_inserted
   returns true on them.

   This behaviour is useful is situations close to tear-down -- e.g.,
   after an exec, while the target still has execution, but breakpoint
   shadows of the previous executable image should *NOT* be restored
   to the new image; or before detaching, where the target still has
   execution and wants to delete breakpoints from GDB's lists, and all
   breakpoints had already been removed from the inferior.  */

static void
update_global_location_list (int should_insert)
{
  struct breakpoint *b;
  struct bp_location **locp, *loc;
  struct cleanup *cleanups;
  /* Last breakpoint location address that was marked for update.  */
  CORE_ADDR last_addr = 0;
  /* Last breakpoint location program space that was marked for update.  */
  int last_pspace_num = -1;

  /* Used in the duplicates detection below.  When iterating over all
     bp_locations, points to the first bp_location of a given address.
     Breakpoints and watchpoints of different types are never
     duplicates of each other.  Keep one pointer for each type of
     breakpoint/watchpoint, so we only need to loop over all locations
     once.  */
  struct bp_location *bp_loc_first;  /* breakpoint */
  struct bp_location *wp_loc_first;  /* hardware watchpoint */
  struct bp_location *awp_loc_first; /* access watchpoint */
  struct bp_location *rwp_loc_first; /* read watchpoint */

  /* Saved former bp_location array which we compare against the newly
     built bp_location from the current state of ALL_BREAKPOINTS.  */
  struct bp_location **old_location, **old_locp;
  unsigned old_location_count;

  old_location = bp_location;
  old_location_count = bp_location_count;
  bp_location = NULL;
  bp_location_count = 0;
  cleanups = make_cleanup (xfree, old_location);

  ALL_BREAKPOINTS (b)
    for (loc = b->loc; loc; loc = loc->next)
      bp_location_count++;

  bp_location = xmalloc (sizeof (*bp_location) * bp_location_count);
  locp = bp_location;
  ALL_BREAKPOINTS (b)
    for (loc = b->loc; loc; loc = loc->next)
      *locp++ = loc;
  qsort (bp_location, bp_location_count, sizeof (*bp_location),
	 bp_location_compare);

  bp_location_target_extensions_update ();

  /* Identify bp_location instances that are no longer present in the
     new list, and therefore should be freed.  Note that it's not
     necessary that those locations should be removed from inferior --
     if there's another location at the same address (previously
     marked as duplicate), we don't need to remove/insert the
     location.
     
     LOCP is kept in sync with OLD_LOCP, each pointing to the current
     and former bp_location array state respectively.  */

  locp = bp_location;
  for (old_locp = old_location; old_locp < old_location + old_location_count;
       old_locp++)
    {
      struct bp_location *old_loc = *old_locp;
      struct bp_location **loc2p;

      /* Tells if 'old_loc' is found among the new locations.  If
	 not, we have to free it.  */
      int found_object = 0;
      /* Tells if the location should remain inserted in the target.  */
      int keep_in_target = 0;
      int removed = 0;

      /* Skip LOCP entries which will definitely never be needed.
	 Stop either at or being the one matching OLD_LOC.  */
      while (locp < bp_location + bp_location_count
	     && (*locp)->address < old_loc->address)
	locp++;

      for (loc2p = locp;
	   (loc2p < bp_location + bp_location_count
	    && (*loc2p)->address == old_loc->address);
	   loc2p++)
	{
	  /* Check if this is a new/duplicated location or a duplicated
	     location that had its condition modified.  If so, we want to send
	     its condition to the target if evaluation of conditions is taking
	     place there.  */
	  if ((*loc2p)->condition_changed == condition_modified
	      && (last_addr != old_loc->address
		  || last_pspace_num != old_loc->pspace->num))
	    {
	      force_breakpoint_reinsertion (*loc2p);
	      last_pspace_num = old_loc->pspace->num;
	    }

	  if (*loc2p == old_loc)
	    found_object = 1;
	}

      /* We have already handled this address, update it so that we don't
	 have to go through updates again.  */
      last_addr = old_loc->address;

      /* Target-side condition evaluation: Handle deleted locations.  */
      if (!found_object)
	force_breakpoint_reinsertion (old_loc);

      /* If this location is no longer present, and inserted, look if
	 there's maybe a new location at the same address.  If so,
	 mark that one inserted, and don't remove this one.  This is
	 needed so that we don't have a time window where a breakpoint
	 at certain location is not inserted.  */

      if (old_loc->inserted)
	{
	  /* If the location is inserted now, we might have to remove
	     it.  */

	  if (found_object && should_be_inserted (old_loc))
	    {
	      /* The location is still present in the location list,
		 and still should be inserted.  Don't do anything.  */
	      keep_in_target = 1;
	    }
	  else
	    {
	      /* This location still exists, but it won't be kept in the
		 target since it may have been disabled.  We proceed to
		 remove its target-side condition.  */

	      /* The location is either no longer present, or got
		 disabled.  See if there's another location at the
		 same address, in which case we don't need to remove
		 this one from the target.  */

	      /* OLD_LOC comes from existing struct breakpoint.  */
	      if (breakpoint_address_is_meaningful (old_loc->owner))
		{
		  for (loc2p = locp;
		       (loc2p < bp_location + bp_location_count
			&& (*loc2p)->address == old_loc->address);
		       loc2p++)
		    {
		      struct bp_location *loc2 = *loc2p;

		      if (breakpoint_locations_match (loc2, old_loc))
			{
			  /* Read watchpoint locations are switched to
			     access watchpoints, if the former are not
			     supported, but the latter are.  */
			  if (is_hardware_watchpoint (old_loc->owner))
			    {
			      gdb_assert (is_hardware_watchpoint (loc2->owner));
			      loc2->watchpoint_type = old_loc->watchpoint_type;
			    }

			  /* loc2 is a duplicated location. We need to check
			     if it should be inserted in case it will be
			     unduplicated.  */
			  if (loc2 != old_loc
			      && unduplicated_should_be_inserted (loc2))
			    {
			      swap_insertion (old_loc, loc2);
			      keep_in_target = 1;
			      break;
			    }
			}
		    }
		}
	    }

	  if (!keep_in_target)
	    {
	      if (remove_breakpoint (old_loc, mark_uninserted))
		{
		  /* This is just about all we can do.  We could keep
		     this location on the global list, and try to
		     remove it next time, but there's no particular
		     reason why we will succeed next time.
		     
		     Note that at this point, old_loc->owner is still
		     valid, as delete_breakpoint frees the breakpoint
		     only after calling us.  */
		  printf_filtered (_("warning: Error removing "
				     "breakpoint %d\n"), 
				   old_loc->owner->number);
		}
	      removed = 1;
	    }
	}

      if (!found_object)
	{
	  if (removed && non_stop
	      && breakpoint_address_is_meaningful (old_loc->owner)
	      && !is_hardware_watchpoint (old_loc->owner))
	    {
	      /* This location was removed from the target.  In
		 non-stop mode, a race condition is possible where
		 we've removed a breakpoint, but stop events for that
		 breakpoint are already queued and will arrive later.
		 We apply an heuristic to be able to distinguish such
		 SIGTRAPs from other random SIGTRAPs: we keep this
		 breakpoint location for a bit, and will retire it
		 after we see some number of events.  The theory here
		 is that reporting of events should, "on the average",
		 be fair, so after a while we'll see events from all
		 threads that have anything of interest, and no longer
		 need to keep this breakpoint location around.  We
		 don't hold locations forever so to reduce chances of
		 mistaking a non-breakpoint SIGTRAP for a breakpoint
		 SIGTRAP.

		 The heuristic failing can be disastrous on
		 decr_pc_after_break targets.

		 On decr_pc_after_break targets, like e.g., x86-linux,
		 if we fail to recognize a late breakpoint SIGTRAP,
		 because events_till_retirement has reached 0 too
		 soon, we'll fail to do the PC adjustment, and report
		 a random SIGTRAP to the user.  When the user resumes
		 the inferior, it will most likely immediately crash
		 with SIGILL/SIGBUS/SIGSEGV, or worse, get silently
		 corrupted, because of being resumed e.g., in the
		 middle of a multi-byte instruction, or skipped a
		 one-byte instruction.  This was actually seen happen
		 on native x86-linux, and should be less rare on
		 targets that do not support new thread events, like
		 remote, due to the heuristic depending on
		 thread_count.

		 Mistaking a random SIGTRAP for a breakpoint trap
		 causes similar symptoms (PC adjustment applied when
		 it shouldn't), but then again, playing with SIGTRAPs
		 behind the debugger's back is asking for trouble.

		 Since hardware watchpoint traps are always
		 distinguishable from other traps, so we don't need to
		 apply keep hardware watchpoint moribund locations
		 around.  We simply always ignore hardware watchpoint
		 traps we can no longer explain.  */

	      old_loc->events_till_retirement = 3 * (thread_count () + 1);
	      old_loc->owner = NULL;

	      VEC_safe_push (bp_location_p, moribund_locations, old_loc);
	    }
	  else
	    {
	      old_loc->owner = NULL;
	      decref_bp_location (&old_loc);
	    }
	}
    }

  /* Rescan breakpoints at the same address and section, marking the
     first one as "first" and any others as "duplicates".  This is so
     that the bpt instruction is only inserted once.  If we have a
     permanent breakpoint at the same place as BPT, make that one the
     official one, and the rest as duplicates.  Permanent breakpoints
     are sorted first for the same address.

     Do the same for hardware watchpoints, but also considering the
     watchpoint's type (regular/access/read) and length.  */

  bp_loc_first = NULL;
  wp_loc_first = NULL;
  awp_loc_first = NULL;
  rwp_loc_first = NULL;
  ALL_BP_LOCATIONS (loc, locp)
    {
      /* ALL_BP_LOCATIONS bp_location has LOC->OWNER always
	 non-NULL.  */
      struct bp_location **loc_first_p;
      b = loc->owner;

      if (!unduplicated_should_be_inserted (loc)
	  || !breakpoint_address_is_meaningful (b)
	  /* Don't detect duplicate for tracepoint locations because they are
	   never duplicated.  See the comments in field `duplicate' of
	   `struct bp_location'.  */
	  || is_tracepoint (b))
	{
	  /* Clear the condition modification flag.  */
	  loc->condition_changed = condition_unchanged;
	  continue;
	}

      /* Permanent breakpoint should always be inserted.  */
      if (b->enable_state == bp_permanent && ! loc->inserted)
	internal_error (__FILE__, __LINE__,
			_("allegedly permanent breakpoint is not "
			"actually inserted"));

      if (b->type == bp_hardware_watchpoint)
	loc_first_p = &wp_loc_first;
      else if (b->type == bp_read_watchpoint)
	loc_first_p = &rwp_loc_first;
      else if (b->type == bp_access_watchpoint)
	loc_first_p = &awp_loc_first;
      else
	loc_first_p = &bp_loc_first;

      if (*loc_first_p == NULL
	  || (overlay_debugging && loc->section != (*loc_first_p)->section)
	  || !breakpoint_locations_match (loc, *loc_first_p))
	{
	  *loc_first_p = loc;
	  loc->duplicate = 0;

	  if (is_breakpoint (loc->owner) && loc->condition_changed)
	    {
	      loc->needs_update = 1;
	      /* Clear the condition modification flag.  */
	      loc->condition_changed = condition_unchanged;
	    }
	  continue;
	}


      /* This and the above ensure the invariant that the first location
	 is not duplicated, and is the inserted one.
	 All following are marked as duplicated, and are not inserted.  */
      if (loc->inserted)
	swap_insertion (loc, *loc_first_p);
      loc->duplicate = 1;

      /* Clear the condition modification flag.  */
      loc->condition_changed = condition_unchanged;

      if ((*loc_first_p)->owner->enable_state == bp_permanent && loc->inserted
	  && b->enable_state != bp_permanent)
	internal_error (__FILE__, __LINE__,
			_("another breakpoint was inserted on top of "
			"a permanent breakpoint"));
    }

  if (breakpoints_always_inserted_mode ()
      && (have_live_inferiors ()
	  || (gdbarch_has_global_breakpoints (target_gdbarch ()))))
    {
      if (should_insert)
	insert_breakpoint_locations ();
      else
	{
	  /* Though should_insert is false, we may need to update conditions
	     on the target's side if it is evaluating such conditions.  We
	     only update conditions for locations that are marked
	     "needs_update".  */
	  update_inserted_breakpoint_locations ();
	}
    }

  if (should_insert)
    download_tracepoint_locations ();

  do_cleanups (cleanups);
}

void
breakpoint_retire_moribund (void)
{
  struct bp_location *loc;
  int ix;

  for (ix = 0; VEC_iterate (bp_location_p, moribund_locations, ix, loc); ++ix)
    if (--(loc->events_till_retirement) == 0)
      {
	decref_bp_location (&loc);
	VEC_unordered_remove (bp_location_p, moribund_locations, ix);
	--ix;
      }
}

static void
update_global_location_list_nothrow (int inserting)
{
  volatile struct gdb_exception e;

  TRY_CATCH (e, RETURN_MASK_ERROR)
    update_global_location_list (inserting);
}

/* Clear BKP from a BPS.  */

static void
bpstat_remove_bp_location (bpstat bps, struct breakpoint *bpt)
{
  bpstat bs;

  for (bs = bps; bs; bs = bs->next)
    if (bs->breakpoint_at == bpt)
      {
	bs->breakpoint_at = NULL;
	bs->old_val = NULL;
	/* bs->commands will be freed later.  */
      }
}

/* Callback for iterate_over_threads.  */
static int
bpstat_remove_breakpoint_callback (struct thread_info *th, void *data)
{
  struct breakpoint *bpt = data;

  bpstat_remove_bp_location (th->control.stop_bpstat, bpt);
  return 0;
}

/* Helper for breakpoint and tracepoint breakpoint_ops->mention
   callbacks.  */

static void
say_where (struct breakpoint *b)
{
  struct value_print_options opts;

  get_user_print_options (&opts);

  /* i18n: cagney/2005-02-11: Below needs to be merged into a
     single string.  */
  if (b->loc == NULL)
    {
      printf_filtered (_(" (%s) pending."), b->addr_string);
    }
  else
    {
      if (opts.addressprint || b->loc->symtab == NULL)
	{
	  printf_filtered (" at ");
	  fputs_filtered (paddress (b->loc->gdbarch, b->loc->address),
			  gdb_stdout);
	}
      if (b->loc->symtab != NULL)
	{
	  /* If there is a single location, we can print the location
	     more nicely.  */
	  if (b->loc->next == NULL)
	    printf_filtered (": file %s, line %d.",
			     symtab_to_filename_for_display (b->loc->symtab),
			     b->loc->line_number);
	  else
	    /* This is not ideal, but each location may have a
	       different file name, and this at least reflects the
	       real situation somewhat.  */
	    printf_filtered (": %s.", b->addr_string);
	}

      if (b->loc->next)
	{
	  struct bp_location *loc = b->loc;
	  int n = 0;
	  for (; loc; loc = loc->next)
	    ++n;
	  printf_filtered (" (%d locations)", n);
	}
    }
}

/* Default bp_location_ops methods.  */

static void
bp_location_dtor (struct bp_location *self)
{
  xfree (self->cond);
  if (self->cond_bytecode)
    free_agent_expr (self->cond_bytecode);
  xfree (self->function_name);
}

static const struct bp_location_ops bp_location_ops =
{
  bp_location_dtor
};

/* Default breakpoint_ops methods all breakpoint_ops ultimately
   inherit from.  */

static void
base_breakpoint_dtor (struct breakpoint *self)
{
  decref_counted_command_line (&self->commands);
  xfree (self->cond_string);
  xfree (self->extra_string);
  xfree (self->addr_string);
  xfree (self->filter);
  xfree (self->addr_string_range_end);
}

static struct bp_location *
base_breakpoint_allocate_location (struct breakpoint *self)
{
  struct bp_location *loc;

  loc = XNEW (struct bp_location);
  init_bp_location (loc, &bp_location_ops, self);
  return loc;
}

static void
base_breakpoint_re_set (struct breakpoint *b)
{
  /* Nothing to re-set. */
}

#define internal_error_pure_virtual_called() \
  gdb_assert_not_reached ("pure virtual function called")

static int
base_breakpoint_insert_location (struct bp_location *bl)
{
  internal_error_pure_virtual_called ();
}

static int
base_breakpoint_remove_location (struct bp_location *bl)
{
  internal_error_pure_virtual_called ();
}

static int
base_breakpoint_breakpoint_hit (const struct bp_location *bl,
				struct address_space *aspace,
				CORE_ADDR bp_addr,
				const struct target_waitstatus *ws)
{
  internal_error_pure_virtual_called ();
}

static void
base_breakpoint_check_status (bpstat bs)
{
  /* Always stop.   */
}

/* A "works_in_software_mode" breakpoint_ops method that just internal
   errors.  */

static int
base_breakpoint_works_in_software_mode (const struct breakpoint *b)
{
  internal_error_pure_virtual_called ();
}

/* A "resources_needed" breakpoint_ops method that just internal
   errors.  */

static int
base_breakpoint_resources_needed (const struct bp_location *bl)
{
  internal_error_pure_virtual_called ();
}

static enum print_stop_action
base_breakpoint_print_it (bpstat bs)
{
  internal_error_pure_virtual_called ();
}

static void
base_breakpoint_print_one_detail (const struct breakpoint *self,
				  struct ui_out *uiout)
{
  /* nothing */
}

static void
base_breakpoint_print_mention (struct breakpoint *b)
{
  internal_error_pure_virtual_called ();
}

static void
base_breakpoint_print_recreate (struct breakpoint *b, struct ui_file *fp)
{
  internal_error_pure_virtual_called ();
}

static void
base_breakpoint_create_sals_from_address (char **arg,
					  struct linespec_result *canonical,
					  enum bptype type_wanted,
					  char *addr_start,
					  char **copy_arg)
{
  internal_error_pure_virtual_called ();
}

static void
base_breakpoint_create_breakpoints_sal (struct gdbarch *gdbarch,
					struct linespec_result *c,
					char *cond_string,
					char *extra_string,
					enum bptype type_wanted,
					enum bpdisp disposition,
					int thread,
					int task, int ignore_count,
					const struct breakpoint_ops *o,
					int from_tty, int enabled,
					int internal, unsigned flags)
{
  internal_error_pure_virtual_called ();
}

static void
base_breakpoint_decode_linespec (struct breakpoint *b, char **s,
				 struct symtabs_and_lines *sals)
{
  internal_error_pure_virtual_called ();
}

/* The default 'explains_signal' method.  */

static enum bpstat_signal_value
base_breakpoint_explains_signal (struct breakpoint *b, enum gdb_signal sig)
{
  return BPSTAT_SIGNAL_HIDE;
}

/* The default "after_condition_true" method.  */

static void
base_breakpoint_after_condition_true (struct bpstats *bs)
{
  /* Nothing to do.   */
}

struct breakpoint_ops base_breakpoint_ops =
{
  base_breakpoint_dtor,
  base_breakpoint_allocate_location,
  base_breakpoint_re_set,
  base_breakpoint_insert_location,
  base_breakpoint_remove_location,
  base_breakpoint_breakpoint_hit,
  base_breakpoint_check_status,
  base_breakpoint_resources_needed,
  base_breakpoint_works_in_software_mode,
  base_breakpoint_print_it,
  NULL,
  base_breakpoint_print_one_detail,
  base_breakpoint_print_mention,
  base_breakpoint_print_recreate,
  base_breakpoint_create_sals_from_address,
  base_breakpoint_create_breakpoints_sal,
  base_breakpoint_decode_linespec,
  base_breakpoint_explains_signal,
  base_breakpoint_after_condition_true,
};

/* Default breakpoint_ops methods.  */

static void
bkpt_re_set (struct breakpoint *b)
{
  /* FIXME: is this still reachable?  */
  if (b->addr_string == NULL)
    {
      /* Anything without a string can't be re-set.  */
      delete_breakpoint (b);
      return;
    }

  breakpoint_re_set_default (b);
}

static int
bkpt_insert_location (struct bp_location *bl)
{
  if (bl->loc_type == bp_loc_hardware_breakpoint)
    return target_insert_hw_breakpoint (bl->gdbarch,
					&bl->target_info);
  else
    return target_insert_breakpoint (bl->gdbarch,
				     &bl->target_info);
}

static int
bkpt_remove_location (struct bp_location *bl)
{
  if (bl->loc_type == bp_loc_hardware_breakpoint)
    return target_remove_hw_breakpoint (bl->gdbarch, &bl->target_info);
  else
    return target_remove_breakpoint (bl->gdbarch, &bl->target_info);
}

static int
bkpt_breakpoint_hit (const struct bp_location *bl,
		     struct address_space *aspace, CORE_ADDR bp_addr,
		     const struct target_waitstatus *ws)
{
  if (ws->kind != TARGET_WAITKIND_STOPPED
      || ws->value.sig != GDB_SIGNAL_TRAP)
    return 0;

  if (!breakpoint_address_match (bl->pspace->aspace, bl->address,
				 aspace, bp_addr))
    return 0;

  if (overlay_debugging		/* unmapped overlay section */
      && section_is_overlay (bl->section)
      && !section_is_mapped (bl->section))
    return 0;

  return 1;
}

static int
bkpt_resources_needed (const struct bp_location *bl)
{
  gdb_assert (bl->owner->type == bp_hardware_breakpoint);

  return 1;
}

static enum print_stop_action
bkpt_print_it (bpstat bs)
{
  struct breakpoint *b;
  const struct bp_location *bl;
  int bp_temp;
  struct ui_out *uiout = current_uiout;

  gdb_assert (bs->bp_location_at != NULL);

  bl = bs->bp_location_at;
  b = bs->breakpoint_at;

  bp_temp = b->disposition == disp_del;
  if (bl->address != bl->requested_address)
    breakpoint_adjustment_warning (bl->requested_address,
				   bl->address,
				   b->number, 1);
  annotate_breakpoint (b->number);
  if (bp_temp)
    ui_out_text (uiout, "\nTemporary breakpoint ");
  else
    ui_out_text (uiout, "\nBreakpoint ");
  if (ui_out_is_mi_like_p (uiout))
    {
      ui_out_field_string (uiout, "reason",
			   async_reason_lookup (EXEC_ASYNC_BREAKPOINT_HIT));
      ui_out_field_string (uiout, "disp", bpdisp_text (b->disposition));
    }
  ui_out_field_int (uiout, "bkptno", b->number);
  ui_out_text (uiout, ", ");

  return PRINT_SRC_AND_LOC;
}

static void
bkpt_print_mention (struct breakpoint *b)
{
  if (ui_out_is_mi_like_p (current_uiout))
    return;

  switch (b->type)
    {
    case bp_breakpoint:
    case bp_gnu_ifunc_resolver:
      if (b->disposition == disp_del)
	printf_filtered (_("Temporary breakpoint"));
      else
	printf_filtered (_("Breakpoint"));
      printf_filtered (_(" %d"), b->number);
      if (b->type == bp_gnu_ifunc_resolver)
	printf_filtered (_(" at gnu-indirect-function resolver"));
      break;
    case bp_hardware_breakpoint:
      printf_filtered (_("Hardware assisted breakpoint %d"), b->number);
      break;
    case bp_dprintf:
      printf_filtered (_("Dprintf %d"), b->number);
      break;
    }

  say_where (b);
}

static void
bkpt_print_recreate (struct breakpoint *tp, struct ui_file *fp)
{
  if (tp->type == bp_breakpoint && tp->disposition == disp_del)
    fprintf_unfiltered (fp, "tbreak");
  else if (tp->type == bp_breakpoint)
    fprintf_unfiltered (fp, "break");
  else if (tp->type == bp_hardware_breakpoint
	   && tp->disposition == disp_del)
    fprintf_unfiltered (fp, "thbreak");
  else if (tp->type == bp_hardware_breakpoint)
    fprintf_unfiltered (fp, "hbreak");
  else
    internal_error (__FILE__, __LINE__,
		    _("unhandled breakpoint type %d"), (int) tp->type);

  fprintf_unfiltered (fp, " %s", tp->addr_string);
  print_recreate_thread (tp, fp);
}

static void
bkpt_create_sals_from_address (char **arg,
			       struct linespec_result *canonical,
			       enum bptype type_wanted,
			       char *addr_start, char **copy_arg)
{
  create_sals_from_address_default (arg, canonical, type_wanted,
				    addr_start, copy_arg);
}

static void
bkpt_create_breakpoints_sal (struct gdbarch *gdbarch,
			     struct linespec_result *canonical,
			     char *cond_string,
			     char *extra_string,
			     enum bptype type_wanted,
			     enum bpdisp disposition,
			     int thread,
			     int task, int ignore_count,
			     const struct breakpoint_ops *ops,
			     int from_tty, int enabled,
			     int internal, unsigned flags)
{
  create_breakpoints_sal_default (gdbarch, canonical,
				  cond_string, extra_string,
				  type_wanted,
				  disposition, thread, task,
				  ignore_count, ops, from_tty,
				  enabled, internal, flags);
}

static void
bkpt_decode_linespec (struct breakpoint *b, char **s,
		      struct symtabs_and_lines *sals)
{
  decode_linespec_default (b, s, sals);
}

/* Virtual table for internal breakpoints.  */

static void
internal_bkpt_re_set (struct breakpoint *b)
{
  switch (b->type)
    {
      /* Delete overlay event and longjmp master breakpoints; they
	 will be reset later by breakpoint_re_set.  */
    case bp_overlay_event:
    case bp_longjmp_master:
    case bp_std_terminate_master:
    case bp_exception_master:
      delete_breakpoint (b);
      break;

      /* This breakpoint is special, it's set up when the inferior
         starts and we really don't want to touch it.  */
    case bp_shlib_event:

      /* Like bp_shlib_event, this breakpoint type is special.  Once
	 it is set up, we do not want to touch it.  */
    case bp_thread_event:
      break;
    }
}

static void
internal_bkpt_check_status (bpstat bs)
{
  if (bs->breakpoint_at->type == bp_shlib_event)
    {
      /* If requested, stop when the dynamic linker notifies GDB of
	 events.  This allows the user to get control and place
	 breakpoints in initializer routines for dynamically loaded
	 objects (among other things).  */
      bs->stop = stop_on_solib_events;
      bs->print = stop_on_solib_events;
    }
  else
    bs->stop = 0;
}

static enum print_stop_action
internal_bkpt_print_it (bpstat bs)
{
  struct breakpoint *b;

  b = bs->breakpoint_at;

  switch (b->type)
    {
    case bp_shlib_event:
      /* Did we stop because the user set the stop_on_solib_events
	 variable?  (If so, we report this as a generic, "Stopped due
	 to shlib event" message.) */
      print_solib_event (0);
      break;

    case bp_thread_event:
      /* Not sure how we will get here.
	 GDB should not stop for these breakpoints.  */
      printf_filtered (_("Thread Event Breakpoint: gdb should not stop!\n"));
      break;

    case bp_overlay_event:
      /* By analogy with the thread event, GDB should not stop for these.  */
      printf_filtered (_("Overlay Event Breakpoint: gdb should not stop!\n"));
      break;

    case bp_longjmp_master:
      /* These should never be enabled.  */
      printf_filtered (_("Longjmp Master Breakpoint: gdb should not stop!\n"));
      break;

    case bp_std_terminate_master:
      /* These should never be enabled.  */
      printf_filtered (_("std::terminate Master Breakpoint: "
			 "gdb should not stop!\n"));
      break;

    case bp_exception_master:
      /* These should never be enabled.  */
      printf_filtered (_("Exception Master Breakpoint: "
			 "gdb should not stop!\n"));
      break;
    }

  return PRINT_NOTHING;
}

static void
internal_bkpt_print_mention (struct breakpoint *b)
{
  /* Nothing to mention.  These breakpoints are internal.  */
}

/* Virtual table for momentary breakpoints  */

static void
momentary_bkpt_re_set (struct breakpoint *b)
{
  /* Keep temporary breakpoints, which can be encountered when we step
     over a dlopen call and solib_add is resetting the breakpoints.
     Otherwise these should have been blown away via the cleanup chain
     or by breakpoint_init_inferior when we rerun the executable.  */
}

static void
momentary_bkpt_check_status (bpstat bs)
{
  /* Nothing.  The point of these breakpoints is causing a stop.  */
}

static enum print_stop_action
momentary_bkpt_print_it (bpstat bs)
{
  struct ui_out *uiout = current_uiout;

  if (ui_out_is_mi_like_p (uiout))
    {
      struct breakpoint *b = bs->breakpoint_at;

      switch (b->type)
	{
	case bp_finish:
	  ui_out_field_string
	    (uiout, "reason",
	     async_reason_lookup (EXEC_ASYNC_FUNCTION_FINISHED));
	  break;

	case bp_until:
	  ui_out_field_string
	    (uiout, "reason",
	     async_reason_lookup (EXEC_ASYNC_LOCATION_REACHED));
	  break;
	}
    }

  return PRINT_UNKNOWN;
}

static void
momentary_bkpt_print_mention (struct breakpoint *b)
{
  /* Nothing to mention.  These breakpoints are internal.  */
}

/* Ensure INITIATING_FRAME is cleared when no such breakpoint exists.

   It gets cleared already on the removal of the first one of such placed
   breakpoints.  This is OK as they get all removed altogether.  */

static void
longjmp_bkpt_dtor (struct breakpoint *self)
{
  struct thread_info *tp = find_thread_id (self->thread);

  if (tp)
    tp->initiating_frame = null_frame_id;

  momentary_breakpoint_ops.dtor (self);
}

/* Specific methods for probe breakpoints.  */

static int
bkpt_probe_insert_location (struct bp_location *bl)
{
  int v = bkpt_insert_location (bl);

  if (v == 0)
    {
      /* The insertion was successful, now let's set the probe's semaphore
	 if needed.  */
      bl->probe->pops->set_semaphore (bl->probe, bl->gdbarch);
    }

  return v;
}

static int
bkpt_probe_remove_location (struct bp_location *bl)
{
  /* Let's clear the semaphore before removing the location.  */
  bl->probe->pops->clear_semaphore (bl->probe, bl->gdbarch);

  return bkpt_remove_location (bl);
}

static void
bkpt_probe_create_sals_from_address (char **arg,
				     struct linespec_result *canonical,
				     enum bptype type_wanted,
				     char *addr_start, char **copy_arg)
{
  struct linespec_sals lsal;

  lsal.sals = parse_probes (arg, canonical);

  *copy_arg = xstrdup (canonical->addr_string);
  lsal.canonical = xstrdup (*copy_arg);

  VEC_safe_push (linespec_sals, canonical->sals, &lsal);
}

static void
bkpt_probe_decode_linespec (struct breakpoint *b, char **s,
			    struct symtabs_and_lines *sals)
{
  *sals = parse_probes (s, NULL);
  if (!sals->sals)
    error (_("probe not found"));
}

/* The breakpoint_ops structure to be used in tracepoints.  */

static void
tracepoint_re_set (struct breakpoint *b)
{
  breakpoint_re_set_default (b);
}

static int
tracepoint_breakpoint_hit (const struct bp_location *bl,
			   struct address_space *aspace, CORE_ADDR bp_addr,
			   const struct target_waitstatus *ws)
{
  /* By definition, the inferior does not report stops at
     tracepoints.  */
  return 0;
}

static void
tracepoint_print_one_detail (const struct breakpoint *self,
			     struct ui_out *uiout)
{
  struct tracepoint *tp = (struct tracepoint *) self;
  if (tp->static_trace_marker_id)
    {
      gdb_assert (self->type == bp_static_tracepoint);

      ui_out_text (uiout, "\tmarker id is ");
      ui_out_field_string (uiout, "static-tracepoint-marker-string-id",
			   tp->static_trace_marker_id);
      ui_out_text (uiout, "\n");
    }
}

static void
tracepoint_print_mention (struct breakpoint *b)
{
  if (ui_out_is_mi_like_p (current_uiout))
    return;

  switch (b->type)
    {
    case bp_tracepoint:
      printf_filtered (_("Tracepoint"));
      printf_filtered (_(" %d"), b->number);
      break;
    case bp_fast_tracepoint:
      printf_filtered (_("Fast tracepoint"));
      printf_filtered (_(" %d"), b->number);
      break;
    case bp_static_tracepoint:
      printf_filtered (_("Static tracepoint"));
      printf_filtered (_(" %d"), b->number);
      break;
    default:
      internal_error (__FILE__, __LINE__,
		      _("unhandled tracepoint type %d"), (int) b->type);
    }

  say_where (b);
}

static void
tracepoint_print_recreate (struct breakpoint *self, struct ui_file *fp)
{
  struct tracepoint *tp = (struct tracepoint *) self;

  if (self->type == bp_fast_tracepoint)
    fprintf_unfiltered (fp, "ftrace");
  if (self->type == bp_static_tracepoint)
    fprintf_unfiltered (fp, "strace");
  else if (self->type == bp_tracepoint)
    fprintf_unfiltered (fp, "trace");
  else
    internal_error (__FILE__, __LINE__,
		    _("unhandled tracepoint type %d"), (int) self->type);

  fprintf_unfiltered (fp, " %s", self->addr_string);
  print_recreate_thread (self, fp);

  if (tp->pass_count)
    fprintf_unfiltered (fp, "  passcount %d\n", tp->pass_count);
}

static void
tracepoint_create_sals_from_address (char **arg,
				     struct linespec_result *canonical,
				     enum bptype type_wanted,
				     char *addr_start, char **copy_arg)
{
  create_sals_from_address_default (arg, canonical, type_wanted,
				    addr_start, copy_arg);
}

static void
tracepoint_create_breakpoints_sal (struct gdbarch *gdbarch,
				   struct linespec_result *canonical,
				   char *cond_string,
				   char *extra_string,
				   enum bptype type_wanted,
				   enum bpdisp disposition,
				   int thread,
				   int task, int ignore_count,
				   const struct breakpoint_ops *ops,
				   int from_tty, int enabled,
				   int internal, unsigned flags)
{
  create_breakpoints_sal_default (gdbarch, canonical,
				  cond_string, extra_string,
				  type_wanted,
				  disposition, thread, task,
				  ignore_count, ops, from_tty,
				  enabled, internal, flags);
}

static void
tracepoint_decode_linespec (struct breakpoint *b, char **s,
			    struct symtabs_and_lines *sals)
{
  decode_linespec_default (b, s, sals);
}

struct breakpoint_ops tracepoint_breakpoint_ops;

/* The breakpoint_ops structure to be use on tracepoints placed in a
   static probe.  */

static void
tracepoint_probe_create_sals_from_address (char **arg,
					   struct linespec_result *canonical,
					   enum bptype type_wanted,
					   char *addr_start, char **copy_arg)
{
  /* We use the same method for breakpoint on probes.  */
  bkpt_probe_create_sals_from_address (arg, canonical, type_wanted,
				       addr_start, copy_arg);
}

static void
tracepoint_probe_decode_linespec (struct breakpoint *b, char **s,
				  struct symtabs_and_lines *sals)
{
  /* We use the same method for breakpoint on probes.  */
  bkpt_probe_decode_linespec (b, s, sals);
}

static struct breakpoint_ops tracepoint_probe_breakpoint_ops;

/* Dprintf breakpoint_ops methods.  */

static void
dprintf_re_set (struct breakpoint *b)
{
  breakpoint_re_set_default (b);

  /* This breakpoint could have been pending, and be resolved now, and
     if so, we should now have the extra string.  If we don't, the
     dprintf was malformed when created, but we couldn't tell because
     we can't extract the extra string until the location is
     resolved.  */
  if (b->loc != NULL && b->extra_string == NULL)
    error (_("Format string required"));

  /* 1 - connect to target 1, that can run breakpoint commands.
     2 - create a dprintf, which resolves fine.
     3 - disconnect from target 1
     4 - connect to target 2, that can NOT run breakpoint commands.

     After steps #3/#4, you'll want the dprintf command list to
     be updated, because target 1 and 2 may well return different
     answers for target_can_run_breakpoint_commands().
     Given absence of finer grained resetting, we get to do
     it all the time.  */
  if (b->extra_string != NULL)
    update_dprintf_command_list (b);
}

/* Implement the "print_recreate" breakpoint_ops method for dprintf.  */

static void
dprintf_print_recreate (struct breakpoint *tp, struct ui_file *fp)
{
  fprintf_unfiltered (fp, "dprintf %s%s", tp->addr_string,
		      tp->extra_string);
  print_recreate_thread (tp, fp);
}

/* Implement the "after_condition_true" breakpoint_ops method for
   dprintf.

   dprintf's are implemented with regular commands in their command
   list, but we run the commands here instead of before presenting the
   stop to the user, as dprintf's don't actually cause a stop.  This
   also makes it so that the commands of multiple dprintfs at the same
   address are all handled.  */

static void
dprintf_after_condition_true (struct bpstats *bs)
{
  struct cleanup *old_chain;
  struct bpstats tmp_bs = { NULL };
  struct bpstats *tmp_bs_p = &tmp_bs;

  /* dprintf's never cause a stop.  This wasn't set in the
     check_status hook instead because that would make the dprintf's
     condition not be evaluated.  */
  bs->stop = 0;

  /* Run the command list here.  Take ownership of it instead of
     copying.  We never want these commands to run later in
     bpstat_do_actions, if a breakpoint that causes a stop happens to
     be set at same address as this dprintf, or even if running the
     commands here throws.  */
  tmp_bs.commands = bs->commands;
  bs->commands = NULL;
  old_chain = make_cleanup_decref_counted_command_line (&tmp_bs.commands);

  bpstat_do_actions_1 (&tmp_bs_p);

  /* 'tmp_bs.commands' will usually be NULL by now, but
     bpstat_do_actions_1 may return early without processing the whole
     list.  */
  do_cleanups (old_chain);
}

/* The breakpoint_ops structure to be used on static tracepoints with
   markers (`-m').  */

static void
strace_marker_create_sals_from_address (char **arg,
					struct linespec_result *canonical,
					enum bptype type_wanted,
					char *addr_start, char **copy_arg)
{
  struct linespec_sals lsal;

  lsal.sals = decode_static_tracepoint_spec (arg);

  *copy_arg = savestring (addr_start, *arg - addr_start);

  canonical->addr_string = xstrdup (*copy_arg);
  lsal.canonical = xstrdup (*copy_arg);
  VEC_safe_push (linespec_sals, canonical->sals, &lsal);
}

static void
strace_marker_create_breakpoints_sal (struct gdbarch *gdbarch,
				      struct linespec_result *canonical,
				      char *cond_string,
				      char *extra_string,
				      enum bptype type_wanted,
				      enum bpdisp disposition,
				      int thread,
				      int task, int ignore_count,
				      const struct breakpoint_ops *ops,
				      int from_tty, int enabled,
				      int internal, unsigned flags)
{
  int i;
  struct linespec_sals *lsal = VEC_index (linespec_sals,
					  canonical->sals, 0);

  /* If the user is creating a static tracepoint by marker id
     (strace -m MARKER_ID), then store the sals index, so that
     breakpoint_re_set can try to match up which of the newly
     found markers corresponds to this one, and, don't try to
     expand multiple locations for each sal, given than SALS
     already should contain all sals for MARKER_ID.  */

  for (i = 0; i < lsal->sals.nelts; ++i)
    {
      struct symtabs_and_lines expanded;
      struct tracepoint *tp;
      struct cleanup *old_chain;
      char *addr_string;

      expanded.nelts = 1;
      expanded.sals = &lsal->sals.sals[i];

      addr_string = xstrdup (canonical->addr_string);
      old_chain = make_cleanup (xfree, addr_string);

      tp = XCNEW (struct tracepoint);
      init_breakpoint_sal (&tp->base, gdbarch, expanded,
			   addr_string, NULL,
			   cond_string, extra_string,
			   type_wanted, disposition,
			   thread, task, ignore_count, ops,
			   from_tty, enabled, internal, flags,
			   canonical->special_display);
      /* Given that its possible to have multiple markers with
	 the same string id, if the user is creating a static
	 tracepoint by marker id ("strace -m MARKER_ID"), then
	 store the sals index, so that breakpoint_re_set can
	 try to match up which of the newly found markers
	 corresponds to this one  */
      tp->static_trace_marker_id_idx = i;

      install_breakpoint (internal, &tp->base, 0);

      discard_cleanups (old_chain);
    }
}

static void
strace_marker_decode_linespec (struct breakpoint *b, char **s,
			       struct symtabs_and_lines *sals)
{
  struct tracepoint *tp = (struct tracepoint *) b;

  *sals = decode_static_tracepoint_spec (s);
  if (sals->nelts > tp->static_trace_marker_id_idx)
    {
      sals->sals[0] = sals->sals[tp->static_trace_marker_id_idx];
      sals->nelts = 1;
    }
  else
    error (_("marker %s not found"), tp->static_trace_marker_id);
}

static struct breakpoint_ops strace_marker_breakpoint_ops;

static int
strace_marker_p (struct breakpoint *b)
{
  return b->ops == &strace_marker_breakpoint_ops;
}

/* Delete a breakpoint and clean up all traces of it in the data
   structures.  */

void
delete_breakpoint (struct breakpoint *bpt)
{
  struct breakpoint *b;

  gdb_assert (bpt != NULL);

  /* Has this bp already been deleted?  This can happen because
     multiple lists can hold pointers to bp's.  bpstat lists are
     especial culprits.

     One example of this happening is a watchpoint's scope bp.  When
     the scope bp triggers, we notice that the watchpoint is out of
     scope, and delete it.  We also delete its scope bp.  But the
     scope bp is marked "auto-deleting", and is already on a bpstat.
     That bpstat is then checked for auto-deleting bp's, which are
     deleted.

     A real solution to this problem might involve reference counts in
     bp's, and/or giving them pointers back to their referencing
     bpstat's, and teaching delete_breakpoint to only free a bp's
     storage when no more references were extent.  A cheaper bandaid
     was chosen.  */
  if (bpt->type == bp_none)
    return;

  /* At least avoid this stale reference until the reference counting
     of breakpoints gets resolved.  */
  if (bpt->related_breakpoint != bpt)
    {
      struct breakpoint *related;
      struct watchpoint *w;

      if (bpt->type == bp_watchpoint_scope)
	w = (struct watchpoint *) bpt->related_breakpoint;
      else if (bpt->related_breakpoint->type == bp_watchpoint_scope)
	w = (struct watchpoint *) bpt;
      else
	w = NULL;
      if (w != NULL)
	watchpoint_del_at_next_stop (w);

      /* Unlink bpt from the bpt->related_breakpoint ring.  */
      for (related = bpt; related->related_breakpoint != bpt;
	   related = related->related_breakpoint);
      related->related_breakpoint = bpt->related_breakpoint;
      bpt->related_breakpoint = bpt;
    }

  /* watch_command_1 creates a watchpoint but only sets its number if
     update_watchpoint succeeds in creating its bp_locations.  If there's
     a problem in that process, we'll be asked to delete the half-created
     watchpoint.  In that case, don't announce the deletion.  */
  if (bpt->number)
    observer_notify_breakpoint_deleted (bpt);

  if (breakpoint_chain == bpt)
    breakpoint_chain = bpt->next;

  ALL_BREAKPOINTS (b)
    if (b->next == bpt)
    {
      b->next = bpt->next;
      break;
    }

  /* Be sure no bpstat's are pointing at the breakpoint after it's
     been freed.  */
  /* FIXME, how can we find all bpstat's?  We just check stop_bpstat
     in all threads for now.  Note that we cannot just remove bpstats
     pointing at bpt from the stop_bpstat list entirely, as breakpoint
     commands are associated with the bpstat; if we remove it here,
     then the later call to bpstat_do_actions (&stop_bpstat); in
     event-top.c won't do anything, and temporary breakpoints with
     commands won't work.  */

  iterate_over_threads (bpstat_remove_breakpoint_callback, bpt);

  /* Now that breakpoint is removed from breakpoint list, update the
     global location list.  This will remove locations that used to
     belong to this breakpoint.  Do this before freeing the breakpoint
     itself, since remove_breakpoint looks at location's owner.  It
     might be better design to have location completely
     self-contained, but it's not the case now.  */
  update_global_location_list (0);

  bpt->ops->dtor (bpt);
  /* On the chance that someone will soon try again to delete this
     same bp, we mark it as deleted before freeing its storage.  */
  bpt->type = bp_none;
  xfree (bpt);
}

static void
do_delete_breakpoint_cleanup (void *b)
{
  delete_breakpoint (b);
}

struct cleanup *
make_cleanup_delete_breakpoint (struct breakpoint *b)
{
  return make_cleanup (do_delete_breakpoint_cleanup, b);
}

/* Iterator function to call a user-provided callback function once
   for each of B and its related breakpoints.  */

static void
iterate_over_related_breakpoints (struct breakpoint *b,
				  void (*function) (struct breakpoint *,
						    void *),
				  void *data)
{
  struct breakpoint *related;

  related = b;
  do
    {
      struct breakpoint *next;

      /* FUNCTION may delete RELATED.  */
      next = related->related_breakpoint;

      if (next == related)
	{
	  /* RELATED is the last ring entry.  */
	  function (related, data);

	  /* FUNCTION may have deleted it, so we'd never reach back to
	     B.  There's nothing left to do anyway, so just break
	     out.  */
	  break;
	}
      else
	function (related, data);

      related = next;
    }
  while (related != b);
}

static void
do_delete_breakpoint (struct breakpoint *b, void *ignore)
{
  delete_breakpoint (b);
}

/* A callback for map_breakpoint_numbers that calls
   delete_breakpoint.  */

static void
do_map_delete_breakpoint (struct breakpoint *b, void *ignore)
{
  iterate_over_related_breakpoints (b, do_delete_breakpoint, NULL);
}

void
delete_command (char *arg, int from_tty)
{
  struct breakpoint *b, *b_tmp;

  dont_repeat ();

  if (arg == 0)
    {
      int breaks_to_delete = 0;

      /* Delete all breakpoints if no argument.  Do not delete
         internal breakpoints, these have to be deleted with an
         explicit breakpoint number argument.  */
      ALL_BREAKPOINTS (b)
	if (user_breakpoint_p (b))
	  {
	    breaks_to_delete = 1;
	    break;
	  }

      /* Ask user only if there are some breakpoints to delete.  */
      if (!from_tty
	  || (breaks_to_delete && query (_("Delete all breakpoints? "))))
	{
	  ALL_BREAKPOINTS_SAFE (b, b_tmp)
	    if (user_breakpoint_p (b))
	      delete_breakpoint (b);
	}
    }
  else
    map_breakpoint_numbers (arg, do_map_delete_breakpoint, NULL);
}

static int
all_locations_are_pending (struct bp_location *loc)
{
  for (; loc; loc = loc->next)
    if (!loc->shlib_disabled
	&& !loc->pspace->executing_startup)
      return 0;
  return 1;
}

/* Subroutine of update_breakpoint_locations to simplify it.
   Return non-zero if multiple fns in list LOC have the same name.
   Null names are ignored.  */

static int
ambiguous_names_p (struct bp_location *loc)
{
  struct bp_location *l;
  htab_t htab = htab_create_alloc (13, htab_hash_string,
				   (int (*) (const void *, 
					     const void *)) streq,
				   NULL, xcalloc, xfree);

  for (l = loc; l != NULL; l = l->next)
    {
      const char **slot;
      const char *name = l->function_name;

      /* Allow for some names to be NULL, ignore them.  */
      if (name == NULL)
	continue;

      slot = (const char **) htab_find_slot (htab, (const void *) name,
					     INSERT);
      /* NOTE: We can assume slot != NULL here because xcalloc never
	 returns NULL.  */
      if (*slot != NULL)
	{
	  htab_delete (htab);
	  return 1;
	}
      *slot = name;
    }

  htab_delete (htab);
  return 0;
}

/* When symbols change, it probably means the sources changed as well,
   and it might mean the static tracepoint markers are no longer at
   the same address or line numbers they used to be at last we
   checked.  Losing your static tracepoints whenever you rebuild is
   undesirable.  This function tries to resync/rematch gdb static
   tracepoints with the markers on the target, for static tracepoints
   that have not been set by marker id.  Static tracepoint that have
   been set by marker id are reset by marker id in breakpoint_re_set.
   The heuristic is:

   1) For a tracepoint set at a specific address, look for a marker at
   the old PC.  If one is found there, assume to be the same marker.
   If the name / string id of the marker found is different from the
   previous known name, assume that means the user renamed the marker
   in the sources, and output a warning.

   2) For a tracepoint set at a given line number, look for a marker
   at the new address of the old line number.  If one is found there,
   assume to be the same marker.  If the name / string id of the
   marker found is different from the previous known name, assume that
   means the user renamed the marker in the sources, and output a
   warning.

   3) If a marker is no longer found at the same address or line, it
   may mean the marker no longer exists.  But it may also just mean
   the code changed a bit.  Maybe the user added a few lines of code
   that made the marker move up or down (in line number terms).  Ask
   the target for info about the marker with the string id as we knew
   it.  If found, update line number and address in the matching
   static tracepoint.  This will get confused if there's more than one
   marker with the same ID (possible in UST, although unadvised
   precisely because it confuses tools).  */

static struct symtab_and_line
update_static_tracepoint (struct breakpoint *b, struct symtab_and_line sal)
{
  struct tracepoint *tp = (struct tracepoint *) b;
  struct static_tracepoint_marker marker;
  CORE_ADDR pc;

  pc = sal.pc;
  if (sal.line)
    find_line_pc (sal.symtab, sal.line, &pc);

  if (target_static_tracepoint_marker_at (pc, &marker))
    {
      if (strcmp (tp->static_trace_marker_id, marker.str_id) != 0)
	warning (_("static tracepoint %d changed probed marker from %s to %s"),
		 b->number,
		 tp->static_trace_marker_id, marker.str_id);

      xfree (tp->static_trace_marker_id);
      tp->static_trace_marker_id = xstrdup (marker.str_id);
      release_static_tracepoint_marker (&marker);

      return sal;
    }

  /* Old marker wasn't found on target at lineno.  Try looking it up
     by string ID.  */
  if (!sal.explicit_pc
      && sal.line != 0
      && sal.symtab != NULL
      && tp->static_trace_marker_id != NULL)
    {
      VEC(static_tracepoint_marker_p) *markers;

      markers
	= target_static_tracepoint_markers_by_strid (tp->static_trace_marker_id);

      if (!VEC_empty(static_tracepoint_marker_p, markers))
	{
	  struct symtab_and_line sal2;
	  struct symbol *sym;
	  struct static_tracepoint_marker *tpmarker;
	  struct ui_out *uiout = current_uiout;

	  tpmarker = VEC_index (static_tracepoint_marker_p, markers, 0);

	  xfree (tp->static_trace_marker_id);
	  tp->static_trace_marker_id = xstrdup (tpmarker->str_id);

	  warning (_("marker for static tracepoint %d (%s) not "
		     "found at previous line number"),
		   b->number, tp->static_trace_marker_id);

	  init_sal (&sal2);

	  sal2.pc = tpmarker->address;

	  sal2 = find_pc_line (tpmarker->address, 0);
	  sym = find_pc_sect_function (tpmarker->address, NULL);
	  ui_out_text (uiout, "Now in ");
	  if (sym)
	    {
	      ui_out_field_string (uiout, "func",
				   SYMBOL_PRINT_NAME (sym));
	      ui_out_text (uiout, " at ");
	    }
	  ui_out_field_string (uiout, "file",
			       symtab_to_filename_for_display (sal2.symtab));
	  ui_out_text (uiout, ":");

	  if (ui_out_is_mi_like_p (uiout))
	    {
	      const char *fullname = symtab_to_fullname (sal2.symtab);

	      ui_out_field_string (uiout, "fullname", fullname);
	    }

	  ui_out_field_int (uiout, "line", sal2.line);
	  ui_out_text (uiout, "\n");

	  b->loc->line_number = sal2.line;
	  b->loc->symtab = sym != NULL ? sal2.symtab : NULL;

	  xfree (b->addr_string);
	  b->addr_string = xstrprintf ("%s:%d",
				   symtab_to_filename_for_display (sal2.symtab),
				       b->loc->line_number);

	  /* Might be nice to check if function changed, and warn if
	     so.  */

	  release_static_tracepoint_marker (tpmarker);
	}
    }
  return sal;
}

/* Returns 1 iff locations A and B are sufficiently same that
   we don't need to report breakpoint as changed.  */

static int
locations_are_equal (struct bp_location *a, struct bp_location *b)
{
  while (a && b)
    {
      if (a->address != b->address)
	return 0;

      if (a->shlib_disabled != b->shlib_disabled)
	return 0;

      if (a->enabled != b->enabled)
	return 0;

      a = a->next;
      b = b->next;
    }

  if ((a == NULL) != (b == NULL))
    return 0;

  return 1;
}

/* Create new breakpoint locations for B (a hardware or software breakpoint)
   based on SALS and SALS_END.  If SALS_END.NELTS is not zero, then B is
   a ranged breakpoint.  */

void
update_breakpoint_locations (struct breakpoint *b,
			     struct symtabs_and_lines sals,
			     struct symtabs_and_lines sals_end)
{
  int i;
  struct bp_location *existing_locations = b->loc;

  if (sals_end.nelts != 0 && (sals.nelts != 1 || sals_end.nelts != 1))
    {
      /* Ranged breakpoints have only one start location and one end
	 location.  */
      b->enable_state = bp_disabled;
      update_global_location_list (1);
      printf_unfiltered (_("Could not reset ranged breakpoint %d: "
			   "multiple locations found\n"),
			 b->number);
      return;
    }

  /* If there's no new locations, and all existing locations are
     pending, don't do anything.  This optimizes the common case where
     all locations are in the same shared library, that was unloaded.
     We'd like to retain the location, so that when the library is
     loaded again, we don't loose the enabled/disabled status of the
     individual locations.  */
  if (all_locations_are_pending (existing_locations) && sals.nelts == 0)
    return;

  b->loc = NULL;

  for (i = 0; i < sals.nelts; ++i)
    {
      struct bp_location *new_loc;

      switch_to_program_space_and_thread (sals.sals[i].pspace);

      new_loc = add_location_to_breakpoint (b, &(sals.sals[i]));

      /* Reparse conditions, they might contain references to the
	 old symtab.  */
      if (b->cond_string != NULL)
	{
	  const char *s;
	  volatile struct gdb_exception e;

	  s = b->cond_string;
	  TRY_CATCH (e, RETURN_MASK_ERROR)
	    {
	      new_loc->cond = parse_exp_1 (&s, sals.sals[i].pc,
					   block_for_pc (sals.sals[i].pc), 
					   0);
	    }
	  if (e.reason < 0)
	    {
	      warning (_("failed to reevaluate condition "
			 "for breakpoint %d: %s"), 
		       b->number, e.message);
	      new_loc->enabled = 0;
	    }
	}

      if (sals_end.nelts)
	{
	  CORE_ADDR end = find_breakpoint_range_end (sals_end.sals[0]);

	  new_loc->length = end - sals.sals[0].pc + 1;
	}
    }

  /* Update locations of permanent breakpoints.  */
  if (b->enable_state == bp_permanent)
    make_breakpoint_permanent (b);

  /* If possible, carry over 'disable' status from existing
     breakpoints.  */
  {
    struct bp_location *e = existing_locations;
    /* If there are multiple breakpoints with the same function name,
       e.g. for inline functions, comparing function names won't work.
       Instead compare pc addresses; this is just a heuristic as things
       may have moved, but in practice it gives the correct answer
       often enough until a better solution is found.  */
    int have_ambiguous_names = ambiguous_names_p (b->loc);

    for (; e; e = e->next)
      {
	if (!e->enabled && e->function_name)
	  {
	    struct bp_location *l = b->loc;
	    if (have_ambiguous_names)
	      {
		for (; l; l = l->next)
		  if (breakpoint_locations_match (e, l))
		    {
		      l->enabled = 0;
		      break;
		    }
	      }
	    else
	      {
		for (; l; l = l->next)
		  if (l->function_name
		      && strcmp (e->function_name, l->function_name) == 0)
		    {
		      l->enabled = 0;
		      break;
		    }
	      }
	  }
      }
  }

  if (!locations_are_equal (existing_locations, b->loc))
    observer_notify_breakpoint_modified (b);

  update_global_location_list (1);
}

/* Find the SaL locations corresponding to the given ADDR_STRING.
   On return, FOUND will be 1 if any SaL was found, zero otherwise.  */

static struct symtabs_and_lines
addr_string_to_sals (struct breakpoint *b, char *addr_string, int *found)
{
  char *s;
  struct symtabs_and_lines sals = {0};
  volatile struct gdb_exception e;

  gdb_assert (b->ops != NULL);
  s = addr_string;

  TRY_CATCH (e, RETURN_MASK_ERROR)
    {
      b->ops->decode_linespec (b, &s, &sals);
    }
  if (e.reason < 0)
    {
      int not_found_and_ok = 0;
      /* For pending breakpoints, it's expected that parsing will
	 fail until the right shared library is loaded.  User has
	 already told to create pending breakpoints and don't need
	 extra messages.  If breakpoint is in bp_shlib_disabled
	 state, then user already saw the message about that
	 breakpoint being disabled, and don't want to see more
	 errors.  */
      if (e.error == NOT_FOUND_ERROR
	  && (b->condition_not_parsed 
	      || (b->loc && b->loc->shlib_disabled)
	      || (b->loc && b->loc->pspace->executing_startup)
	      || b->enable_state == bp_disabled))
	not_found_and_ok = 1;

      if (!not_found_and_ok)
	{
	  /* We surely don't want to warn about the same breakpoint
	     10 times.  One solution, implemented here, is disable
	     the breakpoint on error.  Another solution would be to
	     have separate 'warning emitted' flag.  Since this
	     happens only when a binary has changed, I don't know
	     which approach is better.  */
	  b->enable_state = bp_disabled;
	  throw_exception (e);
	}
    }

  if (e.reason == 0 || e.error != NOT_FOUND_ERROR)
    {
      int i;

      for (i = 0; i < sals.nelts; ++i)
	resolve_sal_pc (&sals.sals[i]);
      if (b->condition_not_parsed && s && s[0])
	{
	  char *cond_string, *extra_string;
	  int thread, task;

	  find_condition_and_thread (s, sals.sals[0].pc,
				     &cond_string, &thread, &task,
				     &extra_string);
	  if (cond_string)
	    b->cond_string = cond_string;
	  b->thread = thread;
	  b->task = task;
	  if (extra_string)
	    b->extra_string = extra_string;
	  b->condition_not_parsed = 0;
	}

      if (b->type == bp_static_tracepoint && !strace_marker_p (b))
	sals.sals[0] = update_static_tracepoint (b, sals.sals[0]);

      *found = 1;
    }
  else
    *found = 0;

  return sals;
}

/* The default re_set method, for typical hardware or software
   breakpoints.  Reevaluate the breakpoint and recreate its
   locations.  */

static void
breakpoint_re_set_default (struct breakpoint *b)
{
  int found;
  struct symtabs_and_lines sals, sals_end;
  struct symtabs_and_lines expanded = {0};
  struct symtabs_and_lines expanded_end = {0};

  sals = addr_string_to_sals (b, b->addr_string, &found);
  if (found)
    {
      make_cleanup (xfree, sals.sals);
      expanded = sals;
    }

  if (b->addr_string_range_end)
    {
      sals_end = addr_string_to_sals (b, b->addr_string_range_end, &found);
      if (found)
	{
	  make_cleanup (xfree, sals_end.sals);
	  expanded_end = sals_end;
	}
    }

  update_breakpoint_locations (b, expanded, expanded_end);
}

/* Default method for creating SALs from an address string.  It basically
   calls parse_breakpoint_sals.  Return 1 for success, zero for failure.  */

static void
create_sals_from_address_default (char **arg,
				  struct linespec_result *canonical,
				  enum bptype type_wanted,
				  char *addr_start, char **copy_arg)
{
  parse_breakpoint_sals (arg, canonical);
}

/* Call create_breakpoints_sal for the given arguments.  This is the default
   function for the `create_breakpoints_sal' method of
   breakpoint_ops.  */

static void
create_breakpoints_sal_default (struct gdbarch *gdbarch,
				struct linespec_result *canonical,
				char *cond_string,
				char *extra_string,
				enum bptype type_wanted,
				enum bpdisp disposition,
				int thread,
				int task, int ignore_count,
				const struct breakpoint_ops *ops,
				int from_tty, int enabled,
				int internal, unsigned flags)
{
  create_breakpoints_sal (gdbarch, canonical, cond_string,
			  extra_string,
			  type_wanted, disposition,
			  thread, task, ignore_count, ops, from_tty,
			  enabled, internal, flags);
}

/* Decode the line represented by S by calling decode_line_full.  This is the
   default function for the `decode_linespec' method of breakpoint_ops.  */

static void
decode_linespec_default (struct breakpoint *b, char **s,
			 struct symtabs_and_lines *sals)
{
  struct linespec_result canonical;

  init_linespec_result (&canonical);
  decode_line_full (s, DECODE_LINE_FUNFIRSTLINE,
		    (struct symtab *) NULL, 0,
		    &canonical, multiple_symbols_all,
		    b->filter);

  /* We should get 0 or 1 resulting SALs.  */
  gdb_assert (VEC_length (linespec_sals, canonical.sals) < 2);

  if (VEC_length (linespec_sals, canonical.sals) > 0)
    {
      struct linespec_sals *lsal;

      lsal = VEC_index (linespec_sals, canonical.sals, 0);
      *sals = lsal->sals;
      /* Arrange it so the destructor does not free the
	 contents.  */
      lsal->sals.sals = NULL;
    }

  destroy_linespec_result (&canonical);
}

/* Prepare the global context for a re-set of breakpoint B.  */

static struct cleanup *
prepare_re_set_context (struct breakpoint *b)
{
  struct cleanup *cleanups;

  input_radix = b->input_radix;
  cleanups = save_current_space_and_thread ();
  if (b->pspace != NULL)
    switch_to_program_space_and_thread (b->pspace);
  set_language (b->language);

  return cleanups;
}

/* Reset a breakpoint given it's struct breakpoint * BINT.
   The value we return ends up being the return value from catch_errors.
   Unused in this case.  */

static int
breakpoint_re_set_one (void *bint)
{
  /* Get past catch_errs.  */
  struct breakpoint *b = (struct breakpoint *) bint;
  struct cleanup *cleanups;

  cleanups = prepare_re_set_context (b);
  b->ops->re_set (b);
  do_cleanups (cleanups);
  return 0;
}

/* Re-set all breakpoints after symbols have been re-loaded.  */
void
breakpoint_re_set (void)
{
  struct breakpoint *b, *b_tmp;
  enum language save_language;
  int save_input_radix;
  struct cleanup *old_chain;

  save_language = current_language->la_language;
  save_input_radix = input_radix;
  old_chain = save_current_program_space ();

  ALL_BREAKPOINTS_SAFE (b, b_tmp)
  {
    /* Format possible error msg.  */
    char *message = xstrprintf ("Error in re-setting breakpoint %d: ",
				b->number);
    struct cleanup *cleanups = make_cleanup (xfree, message);
    catch_errors (breakpoint_re_set_one, b, message, RETURN_MASK_ALL);
    do_cleanups (cleanups);
  }
  set_language (save_language);
  input_radix = save_input_radix;

  jit_breakpoint_re_set ();

  do_cleanups (old_chain);

  create_overlay_event_breakpoint ();
  create_longjmp_master_breakpoint ();
  create_std_terminate_master_breakpoint ();
  create_exception_master_breakpoint ();
}

/* Reset the thread number of this breakpoint:

   - If the breakpoint is for all threads, leave it as-is.
   - Else, reset it to the current thread for inferior_ptid.  */
void
breakpoint_re_set_thread (struct breakpoint *b)
{
  if (b->thread != -1)
    {
      if (in_thread_list (inferior_ptid))
	b->thread = pid_to_thread_id (inferior_ptid);

      /* We're being called after following a fork.  The new fork is
	 selected as current, and unless this was a vfork will have a
	 different program space from the original thread.  Reset that
	 as well.  */
      b->loc->pspace = current_program_space;
    }
}

/* Set ignore-count of breakpoint number BPTNUM to COUNT.
   If from_tty is nonzero, it prints a message to that effect,
   which ends with a period (no newline).  */

void
set_ignore_count (int bptnum, int count, int from_tty)
{
  struct breakpoint *b;

  if (count < 0)
    count = 0;

  ALL_BREAKPOINTS (b)
    if (b->number == bptnum)
    {
      if (is_tracepoint (b))
	{
	  if (from_tty && count != 0)
	    printf_filtered (_("Ignore count ignored for tracepoint %d."),
			     bptnum);
	  return;
	}
      
      b->ignore_count = count;
      if (from_tty)
	{
	  if (count == 0)
	    printf_filtered (_("Will stop next time "
			       "breakpoint %d is reached."),
			     bptnum);
	  else if (count == 1)
	    printf_filtered (_("Will ignore next crossing of breakpoint %d."),
			     bptnum);
	  else
	    printf_filtered (_("Will ignore next %d "
			       "crossings of breakpoint %d."),
			     count, bptnum);
	}
      observer_notify_breakpoint_modified (b);
      return;
    }

  error (_("No breakpoint number %d."), bptnum);
}

/* Command to set ignore-count of breakpoint N to COUNT.  */

static void
ignore_command (char *args, int from_tty)
{
  char *p = args;
  int num;

  if (p == 0)
    error_no_arg (_("a breakpoint number"));

  num = get_number (&p);
  if (num == 0)
    error (_("bad breakpoint number: '%s'"), args);
  if (*p == 0)
    error (_("Second argument (specified ignore-count) is missing."));

  set_ignore_count (num,
		    longest_to_int (value_as_long (parse_and_eval (p))),
		    from_tty);
  if (from_tty)
    printf_filtered ("\n");
}

/* Call FUNCTION on each of the breakpoints
   whose numbers are given in ARGS.  */

static void
map_breakpoint_numbers (char *args, void (*function) (struct breakpoint *,
						      void *),
			void *data)
{
  int num;
  struct breakpoint *b, *tmp;
  int match;
  struct get_number_or_range_state state;

  if (args == 0)
    error_no_arg (_("one or more breakpoint numbers"));

  init_number_or_range (&state, args);

  while (!state.finished)
    {
      char *p = state.string;

      match = 0;

      num = get_number_or_range (&state);
      if (num == 0)
	{
	  warning (_("bad breakpoint number at or near '%s'"), p);
	}
      else
	{
	  ALL_BREAKPOINTS_SAFE (b, tmp)
	    if (b->number == num)
	      {
		match = 1;
		function (b, data);
		break;
	      }
	  if (match == 0)
	    printf_unfiltered (_("No breakpoint number %d.\n"), num);
	}
    }
}

static struct bp_location *
find_location_by_number (char *number)
{
  char *dot = strchr (number, '.');
  char *p1;
  int bp_num;
  int loc_num;
  struct breakpoint *b;
  struct bp_location *loc;  

  *dot = '\0';

  p1 = number;
  bp_num = get_number (&p1);
  if (bp_num == 0)
    error (_("Bad breakpoint number '%s'"), number);

  ALL_BREAKPOINTS (b)
    if (b->number == bp_num)
      {
	break;
      }

  if (!b || b->number != bp_num)
    error (_("Bad breakpoint number '%s'"), number);
  
  p1 = dot+1;
  loc_num = get_number (&p1);
  if (loc_num == 0)
    error (_("Bad breakpoint location number '%s'"), number);

  --loc_num;
  loc = b->loc;
  for (;loc_num && loc; --loc_num, loc = loc->next)
    ;
  if (!loc)
    error (_("Bad breakpoint location number '%s'"), dot+1);
    
  return loc;  
}


/* Set ignore-count of breakpoint number BPTNUM to COUNT.
   If from_tty is nonzero, it prints a message to that effect,
   which ends with a period (no newline).  */

void
disable_breakpoint (struct breakpoint *bpt)
{
  /* Never disable a watchpoint scope breakpoint; we want to
     hit them when we leave scope so we can delete both the
     watchpoint and its scope breakpoint at that time.  */
  if (bpt->type == bp_watchpoint_scope)
    return;

  /* You can't disable permanent breakpoints.  */
  if (bpt->enable_state == bp_permanent)
    return;

  bpt->enable_state = bp_disabled;

  /* Mark breakpoint locations modified.  */
  mark_breakpoint_modified (bpt);

  if (target_supports_enable_disable_tracepoint ()
      && current_trace_status ()->running && is_tracepoint (bpt))
    {
      struct bp_location *location;
     
      for (location = bpt->loc; location; location = location->next)
	target_disable_tracepoint (location);
    }

  update_global_location_list (0);

  observer_notify_breakpoint_modified (bpt);
}

/* A callback for iterate_over_related_breakpoints.  */

static void
do_disable_breakpoint (struct breakpoint *b, void *ignore)
{
  disable_breakpoint (b);
}

/* A callback for map_breakpoint_numbers that calls
   disable_breakpoint.  */

static void
do_map_disable_breakpoint (struct breakpoint *b, void *ignore)
{
  iterate_over_related_breakpoints (b, do_disable_breakpoint, NULL);
}

static void
disable_command (char *args, int from_tty)
{
  if (args == 0)
    {
      struct breakpoint *bpt;

      ALL_BREAKPOINTS (bpt)
	if (user_breakpoint_p (bpt))
	  disable_breakpoint (bpt);
    }
  else
    {
      char *num = extract_arg (&args);

      while (num)
	{
	  if (strchr (num, '.'))
	    {
	      struct bp_location *loc = find_location_by_number (num);

	      if (loc)
		{
		  if (loc->enabled)
		    {
		      loc->enabled = 0;
		      mark_breakpoint_location_modified (loc);
		    }
		  if (target_supports_enable_disable_tracepoint ()
		      && current_trace_status ()->running && loc->owner
		      && is_tracepoint (loc->owner))
		    target_disable_tracepoint (loc);
		}
	      update_global_location_list (0);
	    }
	  else
	    map_breakpoint_numbers (num, do_map_disable_breakpoint, NULL);
	  num = extract_arg (&args);
	}
    }
}

static void
enable_breakpoint_disp (struct breakpoint *bpt, enum bpdisp disposition,
			int count)
{
  int target_resources_ok;

  if (bpt->type == bp_hardware_breakpoint)
    {
      int i;
      i = hw_breakpoint_used_count ();
      target_resources_ok = 
	target_can_use_hardware_watchpoint (bp_hardware_breakpoint, 
					    i + 1, 0);
      if (target_resources_ok == 0)
	error (_("No hardware breakpoint support in the target."));
      else if (target_resources_ok < 0)
	error (_("Hardware breakpoints used exceeds limit."));
    }

  if (is_watchpoint (bpt))
    {
      /* Initialize it just to avoid a GCC false warning.  */
      enum enable_state orig_enable_state = 0;
      volatile struct gdb_exception e;

      TRY_CATCH (e, RETURN_MASK_ALL)
	{
	  struct watchpoint *w = (struct watchpoint *) bpt;

	  orig_enable_state = bpt->enable_state;
	  bpt->enable_state = bp_enabled;
	  update_watchpoint (w, 1 /* reparse */);
	}
      if (e.reason < 0)
	{
	  bpt->enable_state = orig_enable_state;
	  exception_fprintf (gdb_stderr, e, _("Cannot enable watchpoint %d: "),
			     bpt->number);
	  return;
	}
    }

  if (bpt->enable_state != bp_permanent)
    bpt->enable_state = bp_enabled;

  bpt->enable_state = bp_enabled;

  /* Mark breakpoint locations modified.  */
  mark_breakpoint_modified (bpt);

  if (target_supports_enable_disable_tracepoint ()
      && current_trace_status ()->running && is_tracepoint (bpt))
    {
      struct bp_location *location;

      for (location = bpt->loc; location; location = location->next)
	target_enable_tracepoint (location);
    }

  bpt->disposition = disposition;
  bpt->enable_count = count;
  update_global_location_list (1);

  observer_notify_breakpoint_modified (bpt);
}


void
enable_breakpoint (struct breakpoint *bpt)
{
  enable_breakpoint_disp (bpt, bpt->disposition, 0);
}

static void
do_enable_breakpoint (struct breakpoint *bpt, void *arg)
{
  enable_breakpoint (bpt);
}

/* A callback for map_breakpoint_numbers that calls
   enable_breakpoint.  */

static void
do_map_enable_breakpoint (struct breakpoint *b, void *ignore)
{
  iterate_over_related_breakpoints (b, do_enable_breakpoint, NULL);
}

/* The enable command enables the specified breakpoints (or all defined
   breakpoints) so they once again become (or continue to be) effective
   in stopping the inferior.  */

static void
enable_command (char *args, int from_tty)
{
  if (args == 0)
    {
      struct breakpoint *bpt;

      ALL_BREAKPOINTS (bpt)
	if (user_breakpoint_p (bpt))
	  enable_breakpoint (bpt);
    }
  else
    {
      char *num = extract_arg (&args);

      while (num)
	{
	  if (strchr (num, '.'))
	    {
	      struct bp_location *loc = find_location_by_number (num);

	      if (loc)
		{
		  if (!loc->enabled)
		    {
		      loc->enabled = 1;
		      mark_breakpoint_location_modified (loc);
		    }
		  if (target_supports_enable_disable_tracepoint ()
		      && current_trace_status ()->running && loc->owner
		      && is_tracepoint (loc->owner))
		    target_enable_tracepoint (loc);
		}
	      update_global_location_list (1);
	    }
	  else
	    map_breakpoint_numbers (num, do_map_enable_breakpoint, NULL);
	  num = extract_arg (&args);
	}
    }
}

/* This struct packages up disposition data for application to multiple
   breakpoints.  */

struct disp_data
{
  enum bpdisp disp;
  int count;
};

static void
do_enable_breakpoint_disp (struct breakpoint *bpt, void *arg)
{
  struct disp_data disp_data = *(struct disp_data *) arg;

  enable_breakpoint_disp (bpt, disp_data.disp, disp_data.count);
}

static void
do_map_enable_once_breakpoint (struct breakpoint *bpt, void *ignore)
{
  struct disp_data disp = { disp_disable, 1 };

  iterate_over_related_breakpoints (bpt, do_enable_breakpoint_disp, &disp);
}

static void
enable_once_command (char *args, int from_tty)
{
  map_breakpoint_numbers (args, do_map_enable_once_breakpoint, NULL);
}

static void
do_map_enable_count_breakpoint (struct breakpoint *bpt, void *countptr)
{
  struct disp_data disp = { disp_disable, *(int *) countptr };

  iterate_over_related_breakpoints (bpt, do_enable_breakpoint_disp, &disp);
}

static void
enable_count_command (char *args, int from_tty)
{
  int count = get_number (&args);

  map_breakpoint_numbers (args, do_map_enable_count_breakpoint, &count);
}

static void
do_map_enable_delete_breakpoint (struct breakpoint *bpt, void *ignore)
{
  struct disp_data disp = { disp_del, 1 };

  iterate_over_related_breakpoints (bpt, do_enable_breakpoint_disp, &disp);
}

static void
enable_delete_command (char *args, int from_tty)
{
  map_breakpoint_numbers (args, do_map_enable_delete_breakpoint, NULL);
}

static void
set_breakpoint_cmd (char *args, int from_tty)
{
}

static void
show_breakpoint_cmd (char *args, int from_tty)
{
}

/* Invalidate last known value of any hardware watchpoint if
   the memory which that value represents has been written to by
   GDB itself.  */

static void
invalidate_bp_value_on_memory_change (struct inferior *inferior,
				      CORE_ADDR addr, ssize_t len,
				      const bfd_byte *data)
{
  struct breakpoint *bp;

  ALL_BREAKPOINTS (bp)
    if (bp->enable_state == bp_enabled
	&& bp->type == bp_hardware_watchpoint)
      {
	struct watchpoint *wp = (struct watchpoint *) bp;

	if (wp->val_valid && wp->val)
	  {
	    struct bp_location *loc;

	    for (loc = bp->loc; loc != NULL; loc = loc->next)
	      if (loc->loc_type == bp_loc_hardware_watchpoint
		  && loc->address + loc->length > addr
		  && addr + len > loc->address)
		{
		  value_free (wp->val);
		  wp->val = NULL;
		  wp->val_valid = 0;
		}
	  }
      }
}

/* Create and insert a raw software breakpoint at PC.  Return an
   identifier, which should be used to remove the breakpoint later.
   In general, places which call this should be using something on the
   breakpoint chain instead; this function should be eliminated
   someday.  */

void *
deprecated_insert_raw_breakpoint (struct gdbarch *gdbarch,
				  struct address_space *aspace, CORE_ADDR pc)
{
  struct bp_target_info *bp_tgt;

  bp_tgt = XZALLOC (struct bp_target_info);

  bp_tgt->placed_address_space = aspace;
  bp_tgt->placed_address = pc;

  if (target_insert_breakpoint (gdbarch, bp_tgt) != 0)
    {
      /* Could not insert the breakpoint.  */
      xfree (bp_tgt);
      return NULL;
    }

  return bp_tgt;
}

/* Remove a breakpoint BP inserted by
   deprecated_insert_raw_breakpoint.  */

int
deprecated_remove_raw_breakpoint (struct gdbarch *gdbarch, void *bp)
{
  struct bp_target_info *bp_tgt = bp;
  int ret;

  ret = target_remove_breakpoint (gdbarch, bp_tgt);
  xfree (bp_tgt);

  return ret;
}

/* One (or perhaps two) breakpoints used for software single
   stepping.  */

static void *single_step_breakpoints[2];
static struct gdbarch *single_step_gdbarch[2];

/* Create and insert a breakpoint for software single step.  */

void
insert_single_step_breakpoint (struct gdbarch *gdbarch,
			       struct address_space *aspace, 
			       CORE_ADDR next_pc)
{
  void **bpt_p;

  if (single_step_breakpoints[0] == NULL)
    {
      bpt_p = &single_step_breakpoints[0];
      single_step_gdbarch[0] = gdbarch;
    }
  else
    {
      gdb_assert (single_step_breakpoints[1] == NULL);
      bpt_p = &single_step_breakpoints[1];
      single_step_gdbarch[1] = gdbarch;
    }

  /* NOTE drow/2006-04-11: A future improvement to this function would
     be to only create the breakpoints once, and actually put them on
     the breakpoint chain.  That would let us use set_raw_breakpoint.
     We could adjust the addresses each time they were needed.  Doing
     this requires corresponding changes elsewhere where single step
     breakpoints are handled, however.  So, for now, we use this.  */

  *bpt_p = deprecated_insert_raw_breakpoint (gdbarch, aspace, next_pc);
  if (*bpt_p == NULL)
    error (_("Could not insert single-step breakpoint at %s"),
	     paddress (gdbarch, next_pc));
}

/* Check if the breakpoints used for software single stepping
   were inserted or not.  */

int
single_step_breakpoints_inserted (void)
{
  return (single_step_breakpoints[0] != NULL
          || single_step_breakpoints[1] != NULL);
}

/* Remove and delete any breakpoints used for software single step.  */

void
remove_single_step_breakpoints (void)
{
  gdb_assert (single_step_breakpoints[0] != NULL);

  /* See insert_single_step_breakpoint for more about this deprecated
     call.  */
  deprecated_remove_raw_breakpoint (single_step_gdbarch[0],
				    single_step_breakpoints[0]);
  single_step_gdbarch[0] = NULL;
  single_step_breakpoints[0] = NULL;

  if (single_step_breakpoints[1] != NULL)
    {
      deprecated_remove_raw_breakpoint (single_step_gdbarch[1],
					single_step_breakpoints[1]);
      single_step_gdbarch[1] = NULL;
      single_step_breakpoints[1] = NULL;
    }
}

/* Delete software single step breakpoints without removing them from
   the inferior.  This is intended to be used if the inferior's address
   space where they were inserted is already gone, e.g. after exit or
   exec.  */

void
cancel_single_step_breakpoints (void)
{
  int i;

  for (i = 0; i < 2; i++)
    if (single_step_breakpoints[i])
      {
	xfree (single_step_breakpoints[i]);
	single_step_breakpoints[i] = NULL;
	single_step_gdbarch[i] = NULL;
      }
}

/* Detach software single-step breakpoints from INFERIOR_PTID without
   removing them.  */

static void
detach_single_step_breakpoints (void)
{
  int i;

  for (i = 0; i < 2; i++)
    if (single_step_breakpoints[i])
      target_remove_breakpoint (single_step_gdbarch[i],
				single_step_breakpoints[i]);
}

/* Check whether a software single-step breakpoint is inserted at
   PC.  */

static int
single_step_breakpoint_inserted_here_p (struct address_space *aspace, 
					CORE_ADDR pc)
{
  int i;

  for (i = 0; i < 2; i++)
    {
      struct bp_target_info *bp_tgt = single_step_breakpoints[i];
      if (bp_tgt
	  && breakpoint_address_match (bp_tgt->placed_address_space,
				       bp_tgt->placed_address,
				       aspace, pc))
	return 1;
    }

  return 0;
}

/* Returns 0 if 'bp' is NOT a syscall catchpoint,
   non-zero otherwise.  */
static int
is_syscall_catchpoint_enabled (struct breakpoint *bp)
{
  if (syscall_catchpoint_p (bp)
      && bp->enable_state != bp_disabled
      && bp->enable_state != bp_call_disabled)
    return 1;
  else
    return 0;
}

int
catch_syscall_enabled (void)
{
  struct catch_syscall_inferior_data *inf_data
    = get_catch_syscall_inferior_data (current_inferior ());

  return inf_data->total_syscalls_count != 0;
}

int
catching_syscall_number (int syscall_number)
{
  struct breakpoint *bp;

  ALL_BREAKPOINTS (bp)
    if (is_syscall_catchpoint_enabled (bp))
      {
	struct syscall_catchpoint *c = (struct syscall_catchpoint *) bp;

	if (c->syscalls_to_be_caught)
	  {
            int i, iter;
            for (i = 0;
                 VEC_iterate (int, c->syscalls_to_be_caught, i, iter);
                 i++)
	      if (syscall_number == iter)
		return 1;
	  }
	else
	  return 1;
      }

  return 0;
}

/* Complete syscall names.  Used by "catch syscall".  */
static VEC (char_ptr) *
catch_syscall_completer (struct cmd_list_element *cmd,
                         const char *text, const char *word)
{
  const char **list = get_syscall_names ();
  VEC (char_ptr) *retlist
    = (list == NULL) ? NULL : complete_on_enum (list, word, word);

  xfree (list);
  return retlist;
}

/* Tracepoint-specific operations.  */

/* Set tracepoint count to NUM.  */
static void
set_tracepoint_count (int num)
{
  tracepoint_count = num;
  set_internalvar_integer (lookup_internalvar ("tpnum"), num);
}

static void
trace_command (char *arg, int from_tty)
{
  struct breakpoint_ops *ops;
  const char *arg_cp = arg;

  if (arg && probe_linespec_to_ops (&arg_cp))
    ops = &tracepoint_probe_breakpoint_ops;
  else
    ops = &tracepoint_breakpoint_ops;

  create_breakpoint (get_current_arch (),
		     arg,
		     NULL, 0, NULL, 1 /* parse arg */,
		     0 /* tempflag */,
		     bp_tracepoint /* type_wanted */,
		     0 /* Ignore count */,
		     pending_break_support,
		     ops,
		     from_tty,
		     1 /* enabled */,
		     0 /* internal */, 0);
}

static void
ftrace_command (char *arg, int from_tty)
{
  create_breakpoint (get_current_arch (),
		     arg,
		     NULL, 0, NULL, 1 /* parse arg */,
		     0 /* tempflag */,
		     bp_fast_tracepoint /* type_wanted */,
		     0 /* Ignore count */,
		     pending_break_support,
		     &tracepoint_breakpoint_ops,
		     from_tty,
		     1 /* enabled */,
		     0 /* internal */, 0);
}

/* strace command implementation.  Creates a static tracepoint.  */

static void
strace_command (char *arg, int from_tty)
{
  struct breakpoint_ops *ops;

  /* Decide if we are dealing with a static tracepoint marker (`-m'),
     or with a normal static tracepoint.  */
  if (arg && strncmp (arg, "-m", 2) == 0 && isspace (arg[2]))
    ops = &strace_marker_breakpoint_ops;
  else
    ops = &tracepoint_breakpoint_ops;

  create_breakpoint (get_current_arch (),
		     arg,
		     NULL, 0, NULL, 1 /* parse arg */,
		     0 /* tempflag */,
		     bp_static_tracepoint /* type_wanted */,
		     0 /* Ignore count */,
		     pending_break_support,
		     ops,
		     from_tty,
		     1 /* enabled */,
		     0 /* internal */, 0);
}

/* Set up a fake reader function that gets command lines from a linked
   list that was acquired during tracepoint uploading.  */

static struct uploaded_tp *this_utp;
static int next_cmd;

static char *
read_uploaded_action (void)
{
  char *rslt;

  VEC_iterate (char_ptr, this_utp->cmd_strings, next_cmd, rslt);

  next_cmd++;

  return rslt;
}

/* Given information about a tracepoint as recorded on a target (which
   can be either a live system or a trace file), attempt to create an
   equivalent GDB tracepoint.  This is not a reliable process, since
   the target does not necessarily have all the information used when
   the tracepoint was originally defined.  */
  
struct tracepoint *
create_tracepoint_from_upload (struct uploaded_tp *utp)
{
  char *addr_str, small_buf[100];
  struct tracepoint *tp;

  if (utp->at_string)
    addr_str = utp->at_string;
  else
    {
      /* In the absence of a source location, fall back to raw
	 address.  Since there is no way to confirm that the address
	 means the same thing as when the trace was started, warn the
	 user.  */
      warning (_("Uploaded tracepoint %d has no "
		 "source location, using raw address"),
	       utp->number);
      xsnprintf (small_buf, sizeof (small_buf), "*%s", hex_string (utp->addr));
      addr_str = small_buf;
    }

  /* There's not much we can do with a sequence of bytecodes.  */
  if (utp->cond && !utp->cond_string)
    warning (_("Uploaded tracepoint %d condition "
	       "has no source form, ignoring it"),
	     utp->number);

  if (!create_breakpoint (get_current_arch (),
			  addr_str,
			  utp->cond_string, -1, NULL,
			  0 /* parse cond/thread */,
			  0 /* tempflag */,
			  utp->type /* type_wanted */,
			  0 /* Ignore count */,
			  pending_break_support,
			  &tracepoint_breakpoint_ops,
			  0 /* from_tty */,
			  utp->enabled /* enabled */,
			  0 /* internal */,
			  CREATE_BREAKPOINT_FLAGS_INSERTED))
    return NULL;

  /* Get the tracepoint we just created.  */
  tp = get_tracepoint (tracepoint_count);
  gdb_assert (tp != NULL);

  if (utp->pass > 0)
    {
      xsnprintf (small_buf, sizeof (small_buf), "%d %d", utp->pass,
		 tp->base.number);

      trace_pass_command (small_buf, 0);
    }

  /* If we have uploaded versions of the original commands, set up a
     special-purpose "reader" function and call the usual command line
     reader, then pass the result to the breakpoint command-setting
     function.  */
  if (!VEC_empty (char_ptr, utp->cmd_strings))
    {
      struct command_line *cmd_list;

      this_utp = utp;
      next_cmd = 0;

      cmd_list = read_command_lines_1 (read_uploaded_action, 1, NULL, NULL);

      breakpoint_set_commands (&tp->base, cmd_list);
    }
  else if (!VEC_empty (char_ptr, utp->actions)
	   || !VEC_empty (char_ptr, utp->step_actions))
    warning (_("Uploaded tracepoint %d actions "
	       "have no source form, ignoring them"),
	     utp->number);

  /* Copy any status information that might be available.  */
  tp->base.hit_count = utp->hit_count;
  tp->traceframe_usage = utp->traceframe_usage;

  return tp;
}
  
/* Print information on tracepoint number TPNUM_EXP, or all if
   omitted.  */

static void
tracepoints_info (char *args, int from_tty)
{
  struct ui_out *uiout = current_uiout;
  int num_printed;

  num_printed = breakpoint_1 (args, 0, is_tracepoint);

  if (num_printed == 0)
    {
      if (args == NULL || *args == '\0')
	ui_out_message (uiout, 0, "No tracepoints.\n");
      else
	ui_out_message (uiout, 0, "No tracepoint matching '%s'.\n", args);
    }

  default_collect_info ();
}

/* The 'enable trace' command enables tracepoints.
   Not supported by all targets.  */
static void
enable_trace_command (char *args, int from_tty)
{
  enable_command (args, from_tty);
}

/* The 'disable trace' command disables tracepoints.
   Not supported by all targets.  */
static void
disable_trace_command (char *args, int from_tty)
{
  disable_command (args, from_tty);
}

/* Remove a tracepoint (or all if no argument).  */
static void
delete_trace_command (char *arg, int from_tty)
{
  struct breakpoint *b, *b_tmp;

  dont_repeat ();

  if (arg == 0)
    {
      int breaks_to_delete = 0;

      /* Delete all breakpoints if no argument.
         Do not delete internal or call-dummy breakpoints, these
         have to be deleted with an explicit breakpoint number 
	 argument.  */
      ALL_TRACEPOINTS (b)
	if (is_tracepoint (b) && user_breakpoint_p (b))
	  {
	    breaks_to_delete = 1;
	    break;
	  }

      /* Ask user only if there are some breakpoints to delete.  */
      if (!from_tty
	  || (breaks_to_delete && query (_("Delete all tracepoints? "))))
	{
	  ALL_BREAKPOINTS_SAFE (b, b_tmp)
	    if (is_tracepoint (b) && user_breakpoint_p (b))
	      delete_breakpoint (b);
	}
    }
  else
    map_breakpoint_numbers (arg, do_map_delete_breakpoint, NULL);
}

/* Helper function for trace_pass_command.  */

static void
trace_pass_set_count (struct tracepoint *tp, int count, int from_tty)
{
  tp->pass_count = count;
  observer_notify_breakpoint_modified (&tp->base);
  if (from_tty)
    printf_filtered (_("Setting tracepoint %d's passcount to %d\n"),
		     tp->base.number, count);
}

/* Set passcount for tracepoint.

   First command argument is passcount, second is tracepoint number.
   If tracepoint number omitted, apply to most recently defined.
   Also accepts special argument "all".  */

static void
trace_pass_command (char *args, int from_tty)
{
  struct tracepoint *t1;
  unsigned int count;

  if (args == 0 || *args == 0)
    error (_("passcount command requires an "
	     "argument (count + optional TP num)"));

  count = strtoul (args, &args, 10);	/* Count comes first, then TP num.  */

  args = skip_spaces (args);
  if (*args && strncasecmp (args, "all", 3) == 0)
    {
      struct breakpoint *b;

      args += 3;			/* Skip special argument "all".  */
      if (*args)
	error (_("Junk at end of arguments."));

      ALL_TRACEPOINTS (b)
      {
	t1 = (struct tracepoint *) b;
	trace_pass_set_count (t1, count, from_tty);
      }
    }
  else if (*args == '\0')
    {
      t1 = get_tracepoint_by_number (&args, NULL, 1);
      if (t1)
	trace_pass_set_count (t1, count, from_tty);
    }
  else
    {
      struct get_number_or_range_state state;

      init_number_or_range (&state, args);
      while (!state.finished)
	{
	  t1 = get_tracepoint_by_number (&args, &state, 1);
	  if (t1)
	    trace_pass_set_count (t1, count, from_tty);
	}
    }
}

struct tracepoint *
get_tracepoint (int num)
{
  struct breakpoint *t;

  ALL_TRACEPOINTS (t)
    if (t->number == num)
      return (struct tracepoint *) t;

  return NULL;
}

/* Find the tracepoint with the given target-side number (which may be
   different from the tracepoint number after disconnecting and
   reconnecting).  */

struct tracepoint *
get_tracepoint_by_number_on_target (int num)
{
  struct breakpoint *b;

  ALL_TRACEPOINTS (b)
    {
      struct tracepoint *t = (struct tracepoint *) b;

      if (t->number_on_target == num)
	return t;
    }

  return NULL;
}

/* Utility: parse a tracepoint number and look it up in the list.
   If STATE is not NULL, use, get_number_or_range_state and ignore ARG.
   If OPTIONAL_P is true, then if the argument is missing, the most
   recent tracepoint (tracepoint_count) is returned.  */
struct tracepoint *
get_tracepoint_by_number (char **arg,
			  struct get_number_or_range_state *state,
			  int optional_p)
{
  struct breakpoint *t;
  int tpnum;
  char *instring = arg == NULL ? NULL : *arg;

  if (state)
    {
      gdb_assert (!state->finished);
      tpnum = get_number_or_range (state);
    }
  else if (arg == NULL || *arg == NULL || ! **arg)
    {
      if (optional_p)
	tpnum = tracepoint_count;
      else
	error_no_arg (_("tracepoint number"));
    }
  else
    tpnum = get_number (arg);

  if (tpnum <= 0)
    {
      if (instring && *instring)
	printf_filtered (_("bad tracepoint number at or near '%s'\n"), 
			 instring);
      else
	printf_filtered (_("Tracepoint argument missing "
			   "and no previous tracepoint\n"));
      return NULL;
    }

  ALL_TRACEPOINTS (t)
    if (t->number == tpnum)
    {
      return (struct tracepoint *) t;
    }

  printf_unfiltered ("No tracepoint number %d.\n", tpnum);
  return NULL;
}

void
print_recreate_thread (struct breakpoint *b, struct ui_file *fp)
{
  if (b->thread != -1)
    fprintf_unfiltered (fp, " thread %d", b->thread);

  if (b->task != 0)
    fprintf_unfiltered (fp, " task %d", b->task);

  fprintf_unfiltered (fp, "\n");
}

/* Save information on user settable breakpoints (watchpoints, etc) to
   a new script file named FILENAME.  If FILTER is non-NULL, call it
   on each breakpoint and only include the ones for which it returns
   non-zero.  */

static void
save_breakpoints (char *filename, int from_tty,
		  int (*filter) (const struct breakpoint *))
{
  struct breakpoint *tp;
  int any = 0;
  struct cleanup *cleanup;
  struct ui_file *fp;
  int extra_trace_bits = 0;

  if (filename == 0 || *filename == 0)
    error (_("Argument required (file name in which to save)"));

  /* See if we have anything to save.  */
  ALL_BREAKPOINTS (tp)
  {
    /* Skip internal and momentary breakpoints.  */
    if (!user_breakpoint_p (tp))
      continue;

    /* If we have a filter, only save the breakpoints it accepts.  */
    if (filter && !filter (tp))
      continue;

    any = 1;

    if (is_tracepoint (tp))
      {
	extra_trace_bits = 1;

	/* We can stop searching.  */
	break;
      }
  }

  if (!any)
    {
      warning (_("Nothing to save."));
      return;
    }

  filename = tilde_expand (filename);
  cleanup = make_cleanup (xfree, filename);
  fp = gdb_fopen (filename, "w");
  if (!fp)
    error (_("Unable to open file '%s' for saving (%s)"),
	   filename, safe_strerror (errno));
  make_cleanup_ui_file_delete (fp);

  if (extra_trace_bits)
    save_trace_state_variables (fp);

  ALL_BREAKPOINTS (tp)
  {
    /* Skip internal and momentary breakpoints.  */
    if (!user_breakpoint_p (tp))
      continue;

    /* If we have a filter, only save the breakpoints it accepts.  */
    if (filter && !filter (tp))
      continue;

    tp->ops->print_recreate (tp, fp);

    /* Note, we can't rely on tp->number for anything, as we can't
       assume the recreated breakpoint numbers will match.  Use $bpnum
       instead.  */

    if (tp->cond_string)
      fprintf_unfiltered (fp, "  condition $bpnum %s\n", tp->cond_string);

    if (tp->ignore_count)
      fprintf_unfiltered (fp, "  ignore $bpnum %d\n", tp->ignore_count);

    if (tp->type != bp_dprintf && tp->commands)
      {
	volatile struct gdb_exception ex;	

	fprintf_unfiltered (fp, "  commands\n");
	
	ui_out_redirect (current_uiout, fp);
	TRY_CATCH (ex, RETURN_MASK_ALL)
	  {
	    print_command_lines (current_uiout, tp->commands->commands, 2);
	  }
	ui_out_redirect (current_uiout, NULL);

	if (ex.reason < 0)
	  throw_exception (ex);

	fprintf_unfiltered (fp, "  end\n");
      }

    if (tp->enable_state == bp_disabled)
      fprintf_unfiltered (fp, "disable\n");

    /* If this is a multi-location breakpoint, check if the locations
       should be individually disabled.  Watchpoint locations are
       special, and not user visible.  */
    if (!is_watchpoint (tp) && tp->loc && tp->loc->next)
      {
	struct bp_location *loc;
	int n = 1;

	for (loc = tp->loc; loc != NULL; loc = loc->next, n++)
	  if (!loc->enabled)
	    fprintf_unfiltered (fp, "disable $bpnum.%d\n", n);
      }
  }

  if (extra_trace_bits && *default_collect)
    fprintf_unfiltered (fp, "set default-collect %s\n", default_collect);

  if (from_tty)
    printf_filtered (_("Saved to file '%s'.\n"), filename);
  do_cleanups (cleanup);
}

/* The `save breakpoints' command.  */

static void
save_breakpoints_command (char *args, int from_tty)
{
  save_breakpoints (args, from_tty, NULL);
}

/* The `save tracepoints' command.  */

static void
save_tracepoints_command (char *args, int from_tty)
{
  save_breakpoints (args, from_tty, is_tracepoint);
}

/* Create a vector of all tracepoints.  */

VEC(breakpoint_p) *
all_tracepoints (void)
{
  VEC(breakpoint_p) *tp_vec = 0;
  struct breakpoint *tp;

  ALL_TRACEPOINTS (tp)
  {
    VEC_safe_push (breakpoint_p, tp_vec, tp);
  }

  return tp_vec;
}


/* This help string is used for the break, hbreak, tbreak and thbreak
   commands.  It is defined as a macro to prevent duplication.
   COMMAND should be a string constant containing the name of the
   command.  */
#define BREAK_ARGS_HELP(command) \
command" [PROBE_MODIFIER] [LOCATION] [thread THREADNUM] [if CONDITION]\n\
PROBE_MODIFIER shall be present if the command is to be placed in a\n\
probe point.  Accepted values are `-probe' (for a generic, automatically\n\
guessed probe type) or `-probe-stap' (for a SystemTap probe).\n\
LOCATION may be a line number, function name, or \"*\" and an address.\n\
If a line number is specified, break at start of code for that line.\n\
If a function is specified, break at start of code for that function.\n\
If an address is specified, break at that exact address.\n\
With no LOCATION, uses current execution address of the selected\n\
stack frame.  This is useful for breaking on return to a stack frame.\n\
\n\
THREADNUM is the number from \"info threads\".\n\
CONDITION is a boolean expression.\n\
\n\
Multiple breakpoints at one place are permitted, and useful if their\n\
conditions are different.\n\
\n\
Do \"help breakpoints\" for info on other commands dealing with breakpoints."

/* List of subcommands for "catch".  */
static struct cmd_list_element *catch_cmdlist;

/* List of subcommands for "tcatch".  */
static struct cmd_list_element *tcatch_cmdlist;

void
add_catch_command (char *name, char *docstring,
		   void (*sfunc) (char *args, int from_tty,
				  struct cmd_list_element *command),
		   completer_ftype *completer,
		   void *user_data_catch,
		   void *user_data_tcatch)
{
  struct cmd_list_element *command;

  command = add_cmd (name, class_breakpoint, NULL, docstring,
		     &catch_cmdlist);
  set_cmd_sfunc (command, sfunc);
  set_cmd_context (command, user_data_catch);
  set_cmd_completer (command, completer);

  command = add_cmd (name, class_breakpoint, NULL, docstring,
		     &tcatch_cmdlist);
  set_cmd_sfunc (command, sfunc);
  set_cmd_context (command, user_data_tcatch);
  set_cmd_completer (command, completer);
}

static void
clear_syscall_counts (struct inferior *inf)
{
  struct catch_syscall_inferior_data *inf_data
    = get_catch_syscall_inferior_data (inf);

  inf_data->total_syscalls_count = 0;
  inf_data->any_syscall_count = 0;
  VEC_free (int, inf_data->syscalls_counts);
}

static void
save_command (char *arg, int from_tty)
{
  printf_unfiltered (_("\"save\" must be followed by "
		       "the name of a save subcommand.\n"));
  help_list (save_cmdlist, "save ", -1, gdb_stdout);
}

struct breakpoint *
iterate_over_breakpoints (int (*callback) (struct breakpoint *, void *),
			  void *data)
{
  struct breakpoint *b, *b_tmp;

  ALL_BREAKPOINTS_SAFE (b, b_tmp)
    {
      if ((*callback) (b, data))
	return b;
    }

  return NULL;
}

/* Zero if any of the breakpoint's locations could be a location where
   functions have been inlined, nonzero otherwise.  */

static int
is_non_inline_function (struct breakpoint *b)
{
  /* The shared library event breakpoint is set on the address of a
     non-inline function.  */
  if (b->type == bp_shlib_event)
    return 1;

  return 0;
}

/* Nonzero if the specified PC cannot be a location where functions
   have been inlined.  */

int
pc_at_non_inline_function (struct address_space *aspace, CORE_ADDR pc,
			   const struct target_waitstatus *ws)
{
  struct breakpoint *b;
  struct bp_location *bl;

  ALL_BREAKPOINTS (b)
    {
      if (!is_non_inline_function (b))
	continue;

      for (bl = b->loc; bl != NULL; bl = bl->next)
	{
	  if (!bl->shlib_disabled
	      && bpstat_check_location (bl, aspace, pc, ws))
	    return 1;
	}
    }

  return 0;
}

/* Remove any references to OBJFILE which is going to be freed.  */

void
breakpoint_free_objfile (struct objfile *objfile)
{
  struct bp_location **locp, *loc;

  ALL_BP_LOCATIONS (loc, locp)
    if (loc->symtab != NULL && loc->symtab->objfile == objfile)
      loc->symtab = NULL;
}

void
initialize_breakpoint_ops (void)
{
  static int initialized = 0;

  struct breakpoint_ops *ops;

  if (initialized)
    return;
  initialized = 1;

  /* The breakpoint_ops structure to be inherit by all kinds of
     breakpoints (real breakpoints, i.e., user "break" breakpoints,
     internal and momentary breakpoints, etc.).  */
  ops = &bkpt_base_breakpoint_ops;
  *ops = base_breakpoint_ops;
  ops->re_set = bkpt_re_set;
  ops->insert_location = bkpt_insert_location;
  ops->remove_location = bkpt_remove_location;
  ops->breakpoint_hit = bkpt_breakpoint_hit;
  ops->create_sals_from_address = bkpt_create_sals_from_address;
  ops->create_breakpoints_sal = bkpt_create_breakpoints_sal;
  ops->decode_linespec = bkpt_decode_linespec;

  /* The breakpoint_ops structure to be used in regular breakpoints.  */
  ops = &bkpt_breakpoint_ops;
  *ops = bkpt_base_breakpoint_ops;
  ops->re_set = bkpt_re_set;
  ops->resources_needed = bkpt_resources_needed;
  ops->print_it = bkpt_print_it;
  ops->print_mention = bkpt_print_mention;
  ops->print_recreate = bkpt_print_recreate;

  /* Ranged breakpoints.  */
  ops = &ranged_breakpoint_ops;
  *ops = bkpt_breakpoint_ops;
  ops->breakpoint_hit = breakpoint_hit_ranged_breakpoint;
  ops->resources_needed = resources_needed_ranged_breakpoint;
  ops->print_it = print_it_ranged_breakpoint;
  ops->print_one = print_one_ranged_breakpoint;
  ops->print_one_detail = print_one_detail_ranged_breakpoint;
  ops->print_mention = print_mention_ranged_breakpoint;
  ops->print_recreate = print_recreate_ranged_breakpoint;

  /* Internal breakpoints.  */
  ops = &internal_breakpoint_ops;
  *ops = bkpt_base_breakpoint_ops;
  ops->re_set = internal_bkpt_re_set;
  ops->check_status = internal_bkpt_check_status;
  ops->print_it = internal_bkpt_print_it;
  ops->print_mention = internal_bkpt_print_mention;

  /* Momentary breakpoints.  */
  ops = &momentary_breakpoint_ops;
  *ops = bkpt_base_breakpoint_ops;
  ops->re_set = momentary_bkpt_re_set;
  ops->check_status = momentary_bkpt_check_status;
  ops->print_it = momentary_bkpt_print_it;
  ops->print_mention = momentary_bkpt_print_mention;

  /* Momentary breakpoints for bp_longjmp and bp_exception.  */
  ops = &longjmp_breakpoint_ops;
  *ops = momentary_breakpoint_ops;
  ops->dtor = longjmp_bkpt_dtor;

  /* Probe breakpoints.  */
  ops = &bkpt_probe_breakpoint_ops;
  *ops = bkpt_breakpoint_ops;
  ops->insert_location = bkpt_probe_insert_location;
  ops->remove_location = bkpt_probe_remove_location;
  ops->create_sals_from_address = bkpt_probe_create_sals_from_address;
  ops->decode_linespec = bkpt_probe_decode_linespec;

  /* Watchpoints.  */
  ops = &watchpoint_breakpoint_ops;
  *ops = base_breakpoint_ops;
  ops->dtor = dtor_watchpoint;
  ops->re_set = re_set_watchpoint;
  ops->insert_location = insert_watchpoint;
  ops->remove_location = remove_watchpoint;
  ops->breakpoint_hit = breakpoint_hit_watchpoint;
  ops->check_status = check_status_watchpoint;
  ops->resources_needed = resources_needed_watchpoint;
  ops->works_in_software_mode = works_in_software_mode_watchpoint;
  ops->print_it = print_it_watchpoint;
  ops->print_mention = print_mention_watchpoint;
  ops->print_recreate = print_recreate_watchpoint;
  ops->explains_signal = explains_signal_watchpoint;

  /* Masked watchpoints.  */
  ops = &masked_watchpoint_breakpoint_ops;
  *ops = watchpoint_breakpoint_ops;
  ops->insert_location = insert_masked_watchpoint;
  ops->remove_location = remove_masked_watchpoint;
  ops->resources_needed = resources_needed_masked_watchpoint;
  ops->works_in_software_mode = works_in_software_mode_masked_watchpoint;
  ops->print_it = print_it_masked_watchpoint;
  ops->print_one_detail = print_one_detail_masked_watchpoint;
  ops->print_mention = print_mention_masked_watchpoint;
  ops->print_recreate = print_recreate_masked_watchpoint;

  /* Tracepoints.  */
  ops = &tracepoint_breakpoint_ops;
  *ops = base_breakpoint_ops;
  ops->re_set = tracepoint_re_set;
  ops->breakpoint_hit = tracepoint_breakpoint_hit;
  ops->print_one_detail = tracepoint_print_one_detail;
  ops->print_mention = tracepoint_print_mention;
  ops->print_recreate = tracepoint_print_recreate;
  ops->create_sals_from_address = tracepoint_create_sals_from_address;
  ops->create_breakpoints_sal = tracepoint_create_breakpoints_sal;
  ops->decode_linespec = tracepoint_decode_linespec;

  /* Probe tracepoints.  */
  ops = &tracepoint_probe_breakpoint_ops;
  *ops = tracepoint_breakpoint_ops;
  ops->create_sals_from_address = tracepoint_probe_create_sals_from_address;
  ops->decode_linespec = tracepoint_probe_decode_linespec;

  /* Static tracepoints with marker (`-m').  */
  ops = &strace_marker_breakpoint_ops;
  *ops = tracepoint_breakpoint_ops;
  ops->create_sals_from_address = strace_marker_create_sals_from_address;
  ops->create_breakpoints_sal = strace_marker_create_breakpoints_sal;
  ops->decode_linespec = strace_marker_decode_linespec;

  /* Fork catchpoints.  */
  ops = &catch_fork_breakpoint_ops;
  *ops = base_breakpoint_ops;
  ops->insert_location = insert_catch_fork;
  ops->remove_location = remove_catch_fork;
  ops->breakpoint_hit = breakpoint_hit_catch_fork;
  ops->print_it = print_it_catch_fork;
  ops->print_one = print_one_catch_fork;
  ops->print_mention = print_mention_catch_fork;
  ops->print_recreate = print_recreate_catch_fork;

  /* Vfork catchpoints.  */
  ops = &catch_vfork_breakpoint_ops;
  *ops = base_breakpoint_ops;
  ops->insert_location = insert_catch_vfork;
  ops->remove_location = remove_catch_vfork;
  ops->breakpoint_hit = breakpoint_hit_catch_vfork;
  ops->print_it = print_it_catch_vfork;
  ops->print_one = print_one_catch_vfork;
  ops->print_mention = print_mention_catch_vfork;
  ops->print_recreate = print_recreate_catch_vfork;

  /* Exec catchpoints.  */
  ops = &catch_exec_breakpoint_ops;
  *ops = base_breakpoint_ops;
  ops->dtor = dtor_catch_exec;
  ops->insert_location = insert_catch_exec;
  ops->remove_location = remove_catch_exec;
  ops->breakpoint_hit = breakpoint_hit_catch_exec;
  ops->print_it = print_it_catch_exec;
  ops->print_one = print_one_catch_exec;
  ops->print_mention = print_mention_catch_exec;
  ops->print_recreate = print_recreate_catch_exec;

  /* Syscall catchpoints.  */
  ops = &catch_syscall_breakpoint_ops;
  *ops = base_breakpoint_ops;
  ops->dtor = dtor_catch_syscall;
  ops->insert_location = insert_catch_syscall;
  ops->remove_location = remove_catch_syscall;
  ops->breakpoint_hit = breakpoint_hit_catch_syscall;
  ops->print_it = print_it_catch_syscall;
  ops->print_one = print_one_catch_syscall;
  ops->print_mention = print_mention_catch_syscall;
  ops->print_recreate = print_recreate_catch_syscall;

  /* Solib-related catchpoints.  */
  ops = &catch_solib_breakpoint_ops;
  *ops = base_breakpoint_ops;
  ops->dtor = dtor_catch_solib;
  ops->insert_location = insert_catch_solib;
  ops->remove_location = remove_catch_solib;
  ops->breakpoint_hit = breakpoint_hit_catch_solib;
  ops->check_status = check_status_catch_solib;
  ops->print_it = print_it_catch_solib;
  ops->print_one = print_one_catch_solib;
  ops->print_mention = print_mention_catch_solib;
  ops->print_recreate = print_recreate_catch_solib;

  ops = &dprintf_breakpoint_ops;
  *ops = bkpt_base_breakpoint_ops;
  ops->re_set = dprintf_re_set;
  ops->resources_needed = bkpt_resources_needed;
  ops->print_it = bkpt_print_it;
  ops->print_mention = bkpt_print_mention;
  ops->print_recreate = dprintf_print_recreate;
  ops->after_condition_true = dprintf_after_condition_true;
}

/* Chain containing all defined "enable breakpoint" subcommands.  */

static struct cmd_list_element *enablebreaklist = NULL;

void
_initialize_breakpoint (void)
{
  struct cmd_list_element *c;

  initialize_breakpoint_ops ();

  observer_attach_solib_unloaded (disable_breakpoints_in_unloaded_shlib);
  observer_attach_inferior_exit (clear_syscall_counts);
  observer_attach_memory_changed (invalidate_bp_value_on_memory_change);

  breakpoint_objfile_key
    = register_objfile_data_with_cleanup (NULL, free_breakpoint_probes);

  catch_syscall_inferior_data
    = register_inferior_data_with_cleanup (NULL,
					   catch_syscall_inferior_data_cleanup);

  breakpoint_chain = 0;
  /* Don't bother to call set_breakpoint_count.  $bpnum isn't useful
     before a breakpoint is set.  */
  breakpoint_count = 0;

  tracepoint_count = 0;

  add_com ("ignore", class_breakpoint, ignore_command, _("\
Set ignore-count of breakpoint number N to COUNT.\n\
Usage is `ignore N COUNT'."));
  if (xdb_commands)
    add_com_alias ("bc", "ignore", class_breakpoint, 1);

  add_com ("commands", class_breakpoint, commands_command, _("\
Set commands to be executed when a breakpoint is hit.\n\
Give breakpoint number as argument after \"commands\".\n\
With no argument, the targeted breakpoint is the last one set.\n\
The commands themselves follow starting on the next line.\n\
Type a line containing \"end\" to indicate the end of them.\n\
Give \"silent\" as the first line to make the breakpoint silent;\n\
then no output is printed when it is hit, except what the commands print."));

  c = add_com ("condition", class_breakpoint, condition_command, _("\
Specify breakpoint number N to break only if COND is true.\n\
Usage is `condition N COND', where N is an integer and COND is an\n\
expression to be evaluated whenever breakpoint N is reached."));
  set_cmd_completer (c, condition_completer);

  c = add_com ("tbreak", class_breakpoint, tbreak_command, _("\
Set a temporary breakpoint.\n\
Like \"break\" except the breakpoint is only temporary,\n\
so it will be deleted when hit.  Equivalent to \"break\" followed\n\
by using \"enable delete\" on the breakpoint number.\n\
\n"
BREAK_ARGS_HELP ("tbreak")));
  set_cmd_completer (c, location_completer);

  c = add_com ("hbreak", class_breakpoint, hbreak_command, _("\
Set a hardware assisted breakpoint.\n\
Like \"break\" except the breakpoint requires hardware support,\n\
some target hardware may not have this support.\n\
\n"
BREAK_ARGS_HELP ("hbreak")));
  set_cmd_completer (c, location_completer);

  c = add_com ("thbreak", class_breakpoint, thbreak_command, _("\
Set a temporary hardware assisted breakpoint.\n\
Like \"hbreak\" except the breakpoint is only temporary,\n\
so it will be deleted when hit.\n\
\n"
BREAK_ARGS_HELP ("thbreak")));
  set_cmd_completer (c, location_completer);

  add_prefix_cmd ("enable", class_breakpoint, enable_command, _("\
Enable some breakpoints.\n\
Give breakpoint numbers (separated by spaces) as arguments.\n\
With no subcommand, breakpoints are enabled until you command otherwise.\n\
This is used to cancel the effect of the \"disable\" command.\n\
With a subcommand you can enable temporarily."),
		  &enablelist, "enable ", 1, &cmdlist);
  if (xdb_commands)
    add_com ("ab", class_breakpoint, enable_command, _("\
Enable some breakpoints.\n\
Give breakpoint numbers (separated by spaces) as arguments.\n\
With no subcommand, breakpoints are enabled until you command otherwise.\n\
This is used to cancel the effect of the \"disable\" command.\n\
With a subcommand you can enable temporarily."));

  add_com_alias ("en", "enable", class_breakpoint, 1);

  add_prefix_cmd ("breakpoints", class_breakpoint, enable_command, _("\
Enable some breakpoints.\n\
Give breakpoint numbers (separated by spaces) as arguments.\n\
This is used to cancel the effect of the \"disable\" command.\n\
May be abbreviated to simply \"enable\".\n"),
		   &enablebreaklist, "enable breakpoints ", 1, &enablelist);

  add_cmd ("once", no_class, enable_once_command, _("\
Enable breakpoints for one hit.  Give breakpoint numbers.\n\
If a breakpoint is hit while enabled in this fashion, it becomes disabled."),
	   &enablebreaklist);

  add_cmd ("delete", no_class, enable_delete_command, _("\
Enable breakpoints and delete when hit.  Give breakpoint numbers.\n\
If a breakpoint is hit while enabled in this fashion, it is deleted."),
	   &enablebreaklist);

  add_cmd ("count", no_class, enable_count_command, _("\
Enable breakpoints for COUNT hits.  Give count and then breakpoint numbers.\n\
If a breakpoint is hit while enabled in this fashion,\n\
the count is decremented; when it reaches zero, the breakpoint is disabled."),
	   &enablebreaklist);

  add_cmd ("delete", no_class, enable_delete_command, _("\
Enable breakpoints and delete when hit.  Give breakpoint numbers.\n\
If a breakpoint is hit while enabled in this fashion, it is deleted."),
	   &enablelist);

  add_cmd ("once", no_class, enable_once_command, _("\
Enable breakpoints for one hit.  Give breakpoint numbers.\n\
If a breakpoint is hit while enabled in this fashion, it becomes disabled."),
	   &enablelist);

  add_cmd ("count", no_class, enable_count_command, _("\
Enable breakpoints for COUNT hits.  Give count and then breakpoint numbers.\n\
If a breakpoint is hit while enabled in this fashion,\n\
the count is decremented; when it reaches zero, the breakpoint is disabled."),
	   &enablelist);

  add_prefix_cmd ("disable", class_breakpoint, disable_command, _("\
Disable some breakpoints.\n\
Arguments are breakpoint numbers with spaces in between.\n\
To disable all breakpoints, give no argument.\n\
A disabled breakpoint is not forgotten, but has no effect until re-enabled."),
		  &disablelist, "disable ", 1, &cmdlist);
  add_com_alias ("dis", "disable", class_breakpoint, 1);
  add_com_alias ("disa", "disable", class_breakpoint, 1);
  if (xdb_commands)
    add_com ("sb", class_breakpoint, disable_command, _("\
Disable some breakpoints.\n\
Arguments are breakpoint numbers with spaces in between.\n\
To disable all breakpoints, give no argument.\n\
A disabled breakpoint is not forgotten, but has no effect until re-enabled."));

  add_cmd ("breakpoints", class_alias, disable_command, _("\
Disable some breakpoints.\n\
Arguments are breakpoint numbers with spaces in between.\n\
To disable all breakpoints, give no argument.\n\
A disabled breakpoint is not forgotten, but has no effect until re-enabled.\n\
This command may be abbreviated \"disable\"."),
	   &disablelist);

  add_prefix_cmd ("delete", class_breakpoint, delete_command, _("\
Delete some breakpoints or auto-display expressions.\n\
Arguments are breakpoint numbers with spaces in between.\n\
To delete all breakpoints, give no argument.\n\
\n\
Also a prefix command for deletion of other GDB objects.\n\
The \"unset\" command is also an alias for \"delete\"."),
		  &deletelist, "delete ", 1, &cmdlist);
  add_com_alias ("d", "delete", class_breakpoint, 1);
  add_com_alias ("del", "delete", class_breakpoint, 1);
  if (xdb_commands)
    add_com ("db", class_breakpoint, delete_command, _("\
Delete some breakpoints.\n\
Arguments are breakpoint numbers with spaces in between.\n\
To delete all breakpoints, give no argument.\n"));

  add_cmd ("breakpoints", class_alias, delete_command, _("\
Delete some breakpoints or auto-display expressions.\n\
Arguments are breakpoint numbers with spaces in between.\n\
To delete all breakpoints, give no argument.\n\
This command may be abbreviated \"delete\"."),
	   &deletelist);

  add_com ("clear", class_breakpoint, clear_command, _("\
Clear breakpoint at specified line or function.\n\
Argument may be line number, function name, or \"*\" and an address.\n\
If line number is specified, all breakpoints in that line are cleared.\n\
If function is specified, breakpoints at beginning of function are cleared.\n\
If an address is specified, breakpoints at that address are cleared.\n\
\n\
With no argument, clears all breakpoints in the line that the selected frame\n\
is executing in.\n\
\n\
See also the \"delete\" command which clears breakpoints by number."));
  add_com_alias ("cl", "clear", class_breakpoint, 1);

  c = add_com ("break", class_breakpoint, break_command, _("\
Set breakpoint at specified line or function.\n"
BREAK_ARGS_HELP ("break")));
  set_cmd_completer (c, location_completer);

  add_com_alias ("b", "break", class_run, 1);
  add_com_alias ("br", "break", class_run, 1);
  add_com_alias ("bre", "break", class_run, 1);
  add_com_alias ("brea", "break", class_run, 1);

  if (xdb_commands)
   add_com_alias ("ba", "break", class_breakpoint, 1);

  if (dbx_commands)
    {
      add_abbrev_prefix_cmd ("stop", class_breakpoint, stop_command, _("\
Break in function/address or break at a line in the current file."),
			     &stoplist, "stop ", 1, &cmdlist);
      add_cmd ("in", class_breakpoint, stopin_command,
	       _("Break in function or address."), &stoplist);
      add_cmd ("at", class_breakpoint, stopat_command,
	       _("Break at a line in the current file."), &stoplist);
      add_com ("status", class_info, breakpoints_info, _("\
Status of user-settable breakpoints, or breakpoint number NUMBER.\n\
The \"Type\" column indicates one of:\n\
\tbreakpoint     - normal breakpoint\n\
\twatchpoint     - watchpoint\n\
The \"Disp\" column contains one of \"keep\", \"del\", or \"dis\" to indicate\n\
the disposition of the breakpoint after it gets hit.  \"dis\" means that the\n\
breakpoint will be disabled.  The \"Address\" and \"What\" columns indicate the\n\
address and file/line number respectively.\n\
\n\
Convenience variable \"$_\" and default examine address for \"x\"\n\
are set to the address of the last breakpoint listed unless the command\n\
is prefixed with \"server \".\n\n\
Convenience variable \"$bpnum\" contains the number of the last\n\
breakpoint set."));
    }

  add_info ("breakpoints", breakpoints_info, _("\
Status of specified breakpoints (all user-settable breakpoints if no argument).\n\
The \"Type\" column indicates one of:\n\
\tbreakpoint     - normal breakpoint\n\
\twatchpoint     - watchpoint\n\
The \"Disp\" column contains one of \"keep\", \"del\", or \"dis\" to indicate\n\
the disposition of the breakpoint after it gets hit.  \"dis\" means that the\n\
breakpoint will be disabled.  The \"Address\" and \"What\" columns indicate the\n\
address and file/line number respectively.\n\
\n\
Convenience variable \"$_\" and default examine address for \"x\"\n\
are set to the address of the last breakpoint listed unless the command\n\
is prefixed with \"server \".\n\n\
Convenience variable \"$bpnum\" contains the number of the last\n\
breakpoint set."));

  add_info_alias ("b", "breakpoints", 1);

  if (xdb_commands)
    add_com ("lb", class_breakpoint, breakpoints_info, _("\
Status of user-settable breakpoints, or breakpoint number NUMBER.\n\
The \"Type\" column indicates one of:\n\
\tbreakpoint     - normal breakpoint\n\
\twatchpoint     - watchpoint\n\
The \"Disp\" column contains one of \"keep\", \"del\", or \"dis\" to indicate\n\
the disposition of the breakpoint after it gets hit.  \"dis\" means that the\n\
breakpoint will be disabled.  The \"Address\" and \"What\" columns indicate the\n\
address and file/line number respectively.\n\
\n\
Convenience variable \"$_\" and default examine address for \"x\"\n\
are set to the address of the last breakpoint listed unless the command\n\
is prefixed with \"server \".\n\n\
Convenience variable \"$bpnum\" contains the number of the last\n\
breakpoint set."));

  add_cmd ("breakpoints", class_maintenance, maintenance_info_breakpoints, _("\
Status of all breakpoints, or breakpoint number NUMBER.\n\
The \"Type\" column indicates one of:\n\
\tbreakpoint     - normal breakpoint\n\
\twatchpoint     - watchpoint\n\
\tlongjmp        - internal breakpoint used to step through longjmp()\n\
\tlongjmp resume - internal breakpoint at the target of longjmp()\n\
\tuntil          - internal breakpoint used by the \"until\" command\n\
\tfinish         - internal breakpoint used by the \"finish\" command\n\
The \"Disp\" column contains one of \"keep\", \"del\", or \"dis\" to indicate\n\
the disposition of the breakpoint after it gets hit.  \"dis\" means that the\n\
breakpoint will be disabled.  The \"Address\" and \"What\" columns indicate the\n\
address and file/line number respectively.\n\
\n\
Convenience variable \"$_\" and default examine address for \"x\"\n\
are set to the address of the last breakpoint listed unless the command\n\
is prefixed with \"server \".\n\n\
Convenience variable \"$bpnum\" contains the number of the last\n\
breakpoint set."),
	   &maintenanceinfolist);

  add_prefix_cmd ("catch", class_breakpoint, catch_command, _("\
Set catchpoints to catch events."),
		  &catch_cmdlist, "catch ",
		  0/*allow-unknown*/, &cmdlist);

  add_prefix_cmd ("tcatch", class_breakpoint, tcatch_command, _("\
Set temporary catchpoints to catch events."),
		  &tcatch_cmdlist, "tcatch ",
		  0/*allow-unknown*/, &cmdlist);

  add_catch_command ("fork", _("Catch calls to fork."),
		     catch_fork_command_1,
                     NULL,
		     (void *) (uintptr_t) catch_fork_permanent,
		     (void *) (uintptr_t) catch_fork_temporary);
  add_catch_command ("vfork", _("Catch calls to vfork."),
		     catch_fork_command_1,
                     NULL,
		     (void *) (uintptr_t) catch_vfork_permanent,
		     (void *) (uintptr_t) catch_vfork_temporary);
  add_catch_command ("exec", _("Catch calls to exec."),
		     catch_exec_command_1,
                     NULL,
		     CATCH_PERMANENT,
		     CATCH_TEMPORARY);
  add_catch_command ("load", _("Catch loads of shared libraries.\n\
Usage: catch load [REGEX]\n\
If REGEX is given, only stop for libraries matching the regular expression."),
		     catch_load_command_1,
		     NULL,
		     CATCH_PERMANENT,
		     CATCH_TEMPORARY);
  add_catch_command ("unload", _("Catch unloads of shared libraries.\n\
Usage: catch unload [REGEX]\n\
If REGEX is given, only stop for libraries matching the regular expression."),
		     catch_unload_command_1,
		     NULL,
		     CATCH_PERMANENT,
		     CATCH_TEMPORARY);
  add_catch_command ("syscall", _("\
Catch system calls by their names and/or numbers.\n\
Arguments say which system calls to catch.  If no arguments\n\
are given, every system call will be caught.\n\
Arguments, if given, should be one or more system call names\n\
(if your system supports that), or system call numbers."),
		     catch_syscall_command_1,
		     catch_syscall_completer,
		     CATCH_PERMANENT,
		     CATCH_TEMPORARY);

  c = add_com ("watch", class_breakpoint, watch_command, _("\
Set a watchpoint for an expression.\n\
Usage: watch [-l|-location] EXPRESSION\n\
A watchpoint stops execution of your program whenever the value of\n\
an expression changes.\n\
If -l or -location is given, this evaluates EXPRESSION and watches\n\
the memory to which it refers."));
  set_cmd_completer (c, expression_completer);

  c = add_com ("rwatch", class_breakpoint, rwatch_command, _("\
Set a read watchpoint for an expression.\n\
Usage: rwatch [-l|-location] EXPRESSION\n\
A watchpoint stops execution of your program whenever the value of\n\
an expression is read.\n\
If -l or -location is given, this evaluates EXPRESSION and watches\n\
the memory to which it refers."));
  set_cmd_completer (c, expression_completer);

  c = add_com ("awatch", class_breakpoint, awatch_command, _("\
Set a watchpoint for an expression.\n\
Usage: awatch [-l|-location] EXPRESSION\n\
A watchpoint stops execution of your program whenever the value of\n\
an expression is either read or written.\n\
If -l or -location is given, this evaluates EXPRESSION and watches\n\
the memory to which it refers."));
  set_cmd_completer (c, expression_completer);

  add_info ("watchpoints", watchpoints_info, _("\
Status of specified watchpoints (all watchpoints if no argument)."));

  /* XXX: cagney/2005-02-23: This should be a boolean, and should
     respond to changes - contrary to the description.  */
  add_setshow_zinteger_cmd ("can-use-hw-watchpoints", class_support,
			    &can_use_hw_watchpoints, _("\
Set debugger's willingness to use watchpoint hardware."), _("\
Show debugger's willingness to use watchpoint hardware."), _("\
If zero, gdb will not use hardware for new watchpoints, even if\n\
such is available.  (However, any hardware watchpoints that were\n\
created before setting this to nonzero, will continue to use watchpoint\n\
hardware.)"),
			    NULL,
			    show_can_use_hw_watchpoints,
			    &setlist, &showlist);

  can_use_hw_watchpoints = 1;

  /* Tracepoint manipulation commands.  */

  c = add_com ("trace", class_breakpoint, trace_command, _("\
Set a tracepoint at specified line or function.\n\
\n"
BREAK_ARGS_HELP ("trace") "\n\
Do \"help tracepoints\" for info on other tracepoint commands."));
  set_cmd_completer (c, location_completer);

  add_com_alias ("tp", "trace", class_alias, 0);
  add_com_alias ("tr", "trace", class_alias, 1);
  add_com_alias ("tra", "trace", class_alias, 1);
  add_com_alias ("trac", "trace", class_alias, 1);

  c = add_com ("ftrace", class_breakpoint, ftrace_command, _("\
Set a fast tracepoint at specified line or function.\n\
\n"
BREAK_ARGS_HELP ("ftrace") "\n\
Do \"help tracepoints\" for info on other tracepoint commands."));
  set_cmd_completer (c, location_completer);

  c = add_com ("strace", class_breakpoint, strace_command, _("\
Set a static tracepoint at specified line, function or marker.\n\
\n\
strace [LOCATION] [if CONDITION]\n\
LOCATION may be a line number, function name, \"*\" and an address,\n\
or -m MARKER_ID.\n\
If a line number is specified, probe the marker at start of code\n\
for that line.  If a function is specified, probe the marker at start\n\
of code for that function.  If an address is specified, probe the marker\n\
at that exact address.  If a marker id is specified, probe the marker\n\
with that name.  With no LOCATION, uses current execution address of\n\
the selected stack frame.\n\
Static tracepoints accept an extra collect action -- ``collect $_sdata''.\n\
This collects arbitrary user data passed in the probe point call to the\n\
tracing library.  You can inspect it when analyzing the trace buffer,\n\
by printing the $_sdata variable like any other convenience variable.\n\
\n\
CONDITION is a boolean expression.\n\
\n\
Multiple tracepoints at one place are permitted, and useful if their\n\
conditions are different.\n\
\n\
Do \"help breakpoints\" for info on other commands dealing with breakpoints.\n\
Do \"help tracepoints\" for info on other tracepoint commands."));
  set_cmd_completer (c, location_completer);

  add_info ("tracepoints", tracepoints_info, _("\
Status of specified tracepoints (all tracepoints if no argument).\n\
Convenience variable \"$tpnum\" contains the number of the\n\
last tracepoint set."));

  add_info_alias ("tp", "tracepoints", 1);

  add_cmd ("tracepoints", class_trace, delete_trace_command, _("\
Delete specified tracepoints.\n\
Arguments are tracepoint numbers, separated by spaces.\n\
No argument means delete all tracepoints."),
	   &deletelist);
  add_alias_cmd ("tr", "tracepoints", class_trace, 1, &deletelist);

  c = add_cmd ("tracepoints", class_trace, disable_trace_command, _("\
Disable specified tracepoints.\n\
Arguments are tracepoint numbers, separated by spaces.\n\
No argument means disable all tracepoints."),
	   &disablelist);
  deprecate_cmd (c, "disable");

  c = add_cmd ("tracepoints", class_trace, enable_trace_command, _("\
Enable specified tracepoints.\n\
Arguments are tracepoint numbers, separated by spaces.\n\
No argument means enable all tracepoints."),
	   &enablelist);
  deprecate_cmd (c, "enable");

  add_com ("passcount", class_trace, trace_pass_command, _("\
Set the passcount for a tracepoint.\n\
The trace will end when the tracepoint has been passed 'count' times.\n\
Usage: passcount COUNT TPNUM, where TPNUM may also be \"all\";\n\
if TPNUM is omitted, passcount refers to the last tracepoint defined."));

  add_prefix_cmd ("save", class_breakpoint, save_command,
		  _("Save breakpoint definitions as a script."),
		  &save_cmdlist, "save ",
		  0/*allow-unknown*/, &cmdlist);

  c = add_cmd ("breakpoints", class_breakpoint, save_breakpoints_command, _("\
Save current breakpoint definitions as a script.\n\
This includes all types of breakpoints (breakpoints, watchpoints,\n\
catchpoints, tracepoints).  Use the 'source' command in another debug\n\
session to restore them."),
	       &save_cmdlist);
  set_cmd_completer (c, filename_completer);

  c = add_cmd ("tracepoints", class_trace, save_tracepoints_command, _("\
Save current tracepoint definitions as a script.\n\
Use the 'source' command in another debug session to restore them."),
	       &save_cmdlist);
  set_cmd_completer (c, filename_completer);

  c = add_com_alias ("save-tracepoints", "save tracepoints", class_trace, 0);
  deprecate_cmd (c, "save tracepoints");

  add_prefix_cmd ("breakpoint", class_maintenance, set_breakpoint_cmd, _("\
Breakpoint specific settings\n\
Configure various breakpoint-specific variables such as\n\
pending breakpoint behavior"),
		  &breakpoint_set_cmdlist, "set breakpoint ",
		  0/*allow-unknown*/, &setlist);
  add_prefix_cmd ("breakpoint", class_maintenance, show_breakpoint_cmd, _("\
Breakpoint specific settings\n\
Configure various breakpoint-specific variables such as\n\
pending breakpoint behavior"),
		  &breakpoint_show_cmdlist, "show breakpoint ",
		  0/*allow-unknown*/, &showlist);

  add_setshow_auto_boolean_cmd ("pending", no_class,
				&pending_break_support, _("\
Set debugger's behavior regarding pending breakpoints."), _("\
Show debugger's behavior regarding pending breakpoints."), _("\
If on, an unrecognized breakpoint location will cause gdb to create a\n\
pending breakpoint.  If off, an unrecognized breakpoint location results in\n\
an error.  If auto, an unrecognized breakpoint location results in a\n\
user-query to see if a pending breakpoint should be created."),
				NULL,
				show_pending_break_support,
				&breakpoint_set_cmdlist,
				&breakpoint_show_cmdlist);

  pending_break_support = AUTO_BOOLEAN_AUTO;

  add_setshow_boolean_cmd ("auto-hw", no_class,
			   &automatic_hardware_breakpoints, _("\
Set automatic usage of hardware breakpoints."), _("\
Show automatic usage of hardware breakpoints."), _("\
If set, the debugger will automatically use hardware breakpoints for\n\
breakpoints set with \"break\" but falling in read-only memory.  If not set,\n\
a warning will be emitted for such breakpoints."),
			   NULL,
			   show_automatic_hardware_breakpoints,
			   &breakpoint_set_cmdlist,
			   &breakpoint_show_cmdlist);

  add_setshow_auto_boolean_cmd ("always-inserted", class_support,
				&always_inserted_mode, _("\
Set mode for inserting breakpoints."), _("\
Show mode for inserting breakpoints."), _("\
When this mode is off, breakpoints are inserted in inferior when it is\n\
resumed, and removed when execution stops.  When this mode is on,\n\
breakpoints are inserted immediately and removed only when the user\n\
deletes the breakpoint.  When this mode is auto (which is the default),\n\
the behaviour depends on the non-stop setting (see help set non-stop).\n\
In this case, if gdb is controlling the inferior in non-stop mode, gdb\n\
behaves as if always-inserted mode is on; if gdb is controlling the\n\
inferior in all-stop mode, gdb behaves as if always-inserted mode is off."),
				NULL,
				&show_always_inserted_mode,
				&breakpoint_set_cmdlist,
				&breakpoint_show_cmdlist);

  add_setshow_enum_cmd ("condition-evaluation", class_breakpoint,
			condition_evaluation_enums,
			&condition_evaluation_mode_1, _("\
Set mode of breakpoint condition evaluation."), _("\
Show mode of breakpoint condition evaluation."), _("\
When this is set to \"host\", breakpoint conditions will be\n\
evaluated on the host's side by GDB.  When it is set to \"target\",\n\
breakpoint conditions will be downloaded to the target (if the target\n\
supports such feature) and conditions will be evaluated on the target's side.\n\
If this is set to \"auto\" (default), this will be automatically set to\n\
\"target\" if it supports condition evaluation, otherwise it will\n\
be set to \"gdb\""),
			   &set_condition_evaluation_mode,
			   &show_condition_evaluation_mode,
			   &breakpoint_set_cmdlist,
			   &breakpoint_show_cmdlist);

  add_com ("break-range", class_breakpoint, break_range_command, _("\
Set a breakpoint for an address range.\n\
break-range START-LOCATION, END-LOCATION\n\
where START-LOCATION and END-LOCATION can be one of the following:\n\
  LINENUM, for that line in the current file,\n\
  FILE:LINENUM, for that line in that file,\n\
  +OFFSET, for that number of lines after the current line\n\
           or the start of the range\n\
  FUNCTION, for the first line in that function,\n\
  FILE:FUNCTION, to distinguish among like-named static functions.\n\
  *ADDRESS, for the instruction at that address.\n\
\n\
The breakpoint will stop execution of the inferior whenever it executes\n\
an instruction at any address within the [START-LOCATION, END-LOCATION]\n\
range (including START-LOCATION and END-LOCATION)."));

  c = add_com ("dprintf", class_breakpoint, dprintf_command, _("\
Set a dynamic printf at specified line or function.\n\
dprintf location,format string,arg1,arg2,...\n\
location may be a line number, function name, or \"*\" and an address.\n\
If a line number is specified, break at start of code for that line.\n\
If a function is specified, break at start of code for that function."));
  set_cmd_completer (c, location_completer);

  add_setshow_enum_cmd ("dprintf-style", class_support,
			dprintf_style_enums, &dprintf_style, _("\
Set the style of usage for dynamic printf."), _("\
Show the style of usage for dynamic printf."), _("\
This setting chooses how GDB will do a dynamic printf.\n\
If the value is \"gdb\", then the printing is done by GDB to its own\n\
console, as with the \"printf\" command.\n\
If the value is \"call\", the print is done by calling a function in your\n\
program; by default printf(), but you can choose a different function or\n\
output stream by setting dprintf-function and dprintf-channel."),
			update_dprintf_commands, NULL,
			&setlist, &showlist);

  dprintf_function = xstrdup ("printf");
  add_setshow_string_cmd ("dprintf-function", class_support,
			  &dprintf_function, _("\
Set the function to use for dynamic printf"), _("\
Show the function to use for dynamic printf"), NULL,
			  update_dprintf_commands, NULL,
			  &setlist, &showlist);

  dprintf_channel = xstrdup ("");
  add_setshow_string_cmd ("dprintf-channel", class_support,
			  &dprintf_channel, _("\
Set the channel to use for dynamic printf"), _("\
Show the channel to use for dynamic printf"), NULL,
			  update_dprintf_commands, NULL,
			  &setlist, &showlist);

  add_setshow_boolean_cmd ("disconnected-dprintf", no_class,
			   &disconnected_dprintf, _("\
Set whether dprintf continues after GDB disconnects."), _("\
Show whether dprintf continues after GDB disconnects."), _("\
Use this to let dprintf commands continue to hit and produce output\n\
even if GDB disconnects or detaches from the target."),
			   NULL,
			   NULL,
			   &setlist, &showlist);

  add_com ("agent-printf", class_vars, agent_printf_command, _("\
agent-printf \"printf format string\", arg1, arg2, arg3, ..., argn\n\
(target agent only) This is useful for formatted output in user-defined commands."));

  automatic_hardware_breakpoints = 1;

  observer_attach_about_to_proceed (breakpoint_about_to_proceed);
  observer_attach_thread_exit (remove_threaded_breakpoints);
}
@


1.782
log
@New GDB/MI commands to catch Ada exceptions

This patch introduces two new GDB/MI commands implementing the equivalent
of the "catch exception" and  "catch assert" GDB/CLI commands.

gdb/ChangeLog:

        * breakpoint.h (init_ada_exception_breakpoint): Add parameter
        "enabled".
        * breakpoint.c (init_ada_exception_breakpoint): Add parameter
        "enabled".  Set B->ENABLE_STATE accordingly.
        * ada-lang.h (ada_exception_catchpoint_kind): Move here from
        ada-lang.c.
        (create_ada_exception_catchpoint): Add declaration.
        * ada-lang.c (ada_exception_catchpoint_kind): Move to ada-lang.h.
        (create_ada_exception_catchpoint): Make non-static. Add new
        parameter "disabled". Use it in call to
        init_ada_exception_breakpoint.
        (catch_ada_exception_command): Add parameter "enabled" in call
        to create_ada_exception_catchpoint.
        (catch_assert_command): Likewise.

        * mi/mi-cmds.h (mi_cmd_catch_assert, mi_cmd_catch_exception):
        Add declarations.
        * mi/mi-cmds.c (mi_cmds): Add the "catch-assert" and
        "catch-exception" commands.
        * mi/mi-cmd-catch.c: Add #include "ada-lang.h".
        (mi_cmd_catch_assert, mi_cmd_catch_exception): New functions.
@
text
@d1798 1
a1798 1
  if ( !target_has_execution)
d1803 7
a11090 7
  if (accessflag == hw_read)
    bp_type = bp_read_watchpoint;
  else if (accessflag == hw_access)
    bp_type = bp_access_watchpoint;
  else
    bp_type = bp_hardware_watchpoint;

d11127 11
a11137 1
  /* Now set up the breakpoint.  */
@


1.781
log
@Stop using errno values around target_xfer interfaces and memory errors.

target_read_memory & friends build on top of target_read (thus on top
of the target_xfer machinery), but turn all errors to EIO, an errno
value.  I think we'd better convert all these to return a
target_xfer_error too, like target_xfer_partial in a previous patch.
The patch starts by doing that.

(The patch does not add a enum target_xfer_error value for '0'/no
error, and likewise does not change the return type of several of
these functions to enum target_xfer_error, because different functions
return '0' with different semantics.)

I audited the tree for memory_error calls, EIO checks, places where
GDB hardcodes 'errno = EIO', and also for strerror calls.  What I
found is that nowadays there's really no need to handle random errno
values, other than the EIOs gdb itself hardcodes.  No doubt errno
values would appear in common code back in the day when
target_xfer_memory was the main interface to access memory, but
nowadays, any errno value that deprecated interface could return is
just absorved by default_xfer_partial:

      else if (xfered == 0 && errno == 0)
	/* "deprecated_xfer_memory" uses 0, cross checked against
           ERRNO as one indication of an error.  */
	return 0;
      else
	return -1;

There are two places in the code that check for EIO and print "out of
bounds", and defer to strerror for other errors.  That's
c-lang.c:c_get_string, and valprint.c.:val_print_string.  AFAICT, the
strerror branch can never be reached nowadays, as the only error
possible to get at those points is EIO, given that it's GDB itself
that set that errno value (in target_read_memory, etc.).

breakpoint.c:insert_bp_location always prints the error val as if an
errno, returned by target_insert_breakpoint, with strerr.  Now the
error here is either always EIO for mem-break.c targets (again
hardcoded by the target_read_memory/target_write_memory functions), so
this always prints "Input/output error" or similar (depending on
host), or, for remote targets (and probably others), this gem:

  Error accessing memory address 0x80200400: Unknown error -1.

This patch makes these 3 places print the exact same error
memory_error prints.  This changes output, but I think this is better,
for making memory error output consistent with other commands, and, it
means we have a central place to tweak for memory errors.

E.g., this changes:

 Cannot insert breakpoint 1.
 Error accessing memory address 0x5fc660: Input/output error.

to:

 Cannot insert breakpoint 1.
 Cannot access memory at address 0x5fc660

Which I find pretty much acceptable.

Surprisingly, only py-prettyprint.exp had a regression, for needing an
adjustment.  I also grepped the testsuite for the old errors, and
found no other hits.

Now that errno values aren't used anywhere in any of these memory
access related routines, I made memory_error itself take a
target_xfer_error instead of an errno.  The new
target_xfer_memory_error function added recently is no longer
necessary, and is thus removed.

Tested on x86_64 Fedora 17, native and gdbserver.

gdb/
2013-10-09  Pedro Alves  <palves@@redhat.com>

	* breakpoint.c (insert_bp_location): Use memory_error_message to
	build the memory error string.
	* c-lang.c: Include "gdbcore.h".
	(c_get_string): Use memory_error to throw error.
	(target_xfer_memory_error): Delete.
	(memory_error_message): New, factored out from
	target_xfer_memory_error.
	(memory_error): Change parameter type to target_xfer_error.
	Rewrite.
	(read_memory): Use memory_error instead of
	target_xfer_memory_error.
	* gdbcore.h: Include "target.h".
	(memory_error): Change parameter type to target_xfer_error.
	(memory_error_message): Declare function.
	* target.c (target_read_memory, target_read_stack)
	(target_write_memory, target_write_raw_memory): Return
	TARGET_XFER_E_IO on error.  Adjust comments.
	(get_target_memory): Pass TARGET_XFER_E_IO to memory_error,
	instead of EIO.
	* target.h (target_read, target_insert_breakpoint)
	(target_remove_breakpoint): Adjust comments.
	* valprint.c (partial_memory_read): Rename parameter, and adjust
	comment.
	(val_print_string): Use memory_error_message to build the memory
	error string.

gdb/testsuite/
2013-10-09  Pedro Alves  <palves@@redhat.com>

	* gdb.python/py-prettyprint.exp (run_lang_tests): Adjust expected
	output.
@
text
@d11624 1
d11647 1
a11647 1
  b->enable_state = bp_enabled;
@


1.780
log
@Thread-specific breakpoints: say "no longer in the thread list" instead of "gone".

It seems "gone" may confuse people, while that was exactly what it was
trying to avoid.  Switch to saying "no longer in the thread list",
which is really the predicate GDB uses.

gdb/
2013-10-07  Pedro Alves  <palves@@redhat.com>

	PR breakpoints/11568
	* breakpoint.c (remove_threaded_breakpoints): Say "no longer in
	the thread list" instead of "gone".
@
text
@d2573 4
d2578 5
a2582 8
				      "Cannot insert breakpoint %d.\n", 
				      bl->owner->number);
		  fprintf_filtered (tmp_error_stream, 
				    "Error accessing memory address ");
		  fputs_filtered (paddress (bl->gdbarch, bl->address),
				  tmp_error_stream);
		  fprintf_filtered (tmp_error_stream, ": %s.\n",
				    safe_strerror (val));
@


1.779
log
@	* aarch64-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	Replace GET_LWP with ptid_get_lwp.
	* aix-thread.c (BUILD_THREAD, BUILD_LWP): Remove.
	Replace BUILD_THREAD with ptid_build.
	Replace BUILD_LWP with ptid_build.
	Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	* alphabsd-nat.c: Replace PIDGET with ptid_get_pid.
	* amd64-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	* amd64bsd-nat.c: Replace PIDGET with ptid_get_pid.
	* arm-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	Replace GET_LWP with ptid_get_lwp.
	* armnbsd-nat.c: Replace PIDGET with ptid_get_pid.
	* auxv.c: Likewise.
	* breakpoint.c: Likewise.
	* common/ptid.c (ptid_is_pid): Condense check for
	null_ptid and minus_one_ptid.
	(ptid_lwp_p): New function.
	(ptid_tid_p): New function.
	* common/ptid.h: Update comments for accessors.
	(ptid_lwp_p): New prototype.
	(ptid_tid_p): New prototype.
	* defs.h (PIDGET, TIDGET, MERGEPID): Do not define.
	* gcore.c: Replace PIDGET with ptid_get_pid.
	* gdbthread.h: Likewise.
	* gnu-nat.c: Likewise.
	* hppa-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	* hppabsd-nat.c: Replace PIDGET with ptid_get_pid.
	* hppanbsd-nat.c: Likewise.
	* i386-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	* i386bsd-nat.c: Replace PIDGET with ptid_get_pid.
	* ia64-linux-nat.c: Replace PIDGET with ptid_get_pid.
	* infcmd.c: Likewise.
	* inferior.h: Likewise.
	* inflow.c: Likewise.
	* infrun.c: Likewise.
	* linux-fork.c: Likewise.
	* linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace GET_PID with ptid_get_pid.
	Replace is_lwp with ptid_lwp_p.
	Replace GET_LWP with ptid_get_lwp.
	Replace BUILD_LWP with ptid_build.
@
text
@d2946 1
a2946 1
Thread-specific breakpoint %d deleted - thread %d is gone.\n"),
@


1.778
log
@Fix regressions caused by thread-specific breakpoint deletion.

The recent change to make GDB auto-delete thread-specific breakpoints
when the corresponding thread is deleted
(https://sourceware.org/ml/gdb-patches/2013-09/msg00038.html) caused
gdb.base/nextoverexit.exp to regress.

    Breakpoint 1, main () at .../gdb/testsuite/gdb.base/nextoverexit.c:21
    21        exit (0);
    (gdb) next
    [Inferior 1 (process 25208) exited normally]
    Thread-specific breakpoint -5 deleted - thread 1 is gone.
    Thread-specific breakpoint -6 deleted - thread 1 is gone.
    Thread-specific breakpoint -7 deleted - thread 1 is gone.
    Thread-specific breakpoint 0 deleted - thread 1 is gone.
    (gdb) FAIL: gdb.base/nextoverexit.exp: next over exit (the program exited)

We shouldn't be seeing this for internal or momentary breakpoints.  In
fact, we shouldn't even be trying to delete them, as whatever created
them will take care or it, and therefore it's dangerous to delete them
behind the creator's back.

I thought it'd still be good to tag thread-specific internal/momentary
breakpoints such that we'll no longer try to keep them insert in the
target, as they'll cause stops and thread hops in other threads, so I
tried disabling them instead.  That caused a problem when following a
child fork, and detaching from the parent, as we try to reset the
step-resume etc. breakpoints to the new child's thread
(breakpoint_re_set_thread), after the parent thread is already gone
(and the breakpoints are marked disabled).  I fixed that by
re-enabling internal/momentary breakpoints there, but, that didn't
feel super safe either (maybe we'd need a new flag in struct
breakpoint instead, to tag the thread-specific breakpoint as "not to
be inserted").  It felt like I was heading down a design rat hole,
and, other things will usually delete internal/momentary breakpoints
soon enough, so I left that little optimization for some other day.

So, internal/momentary breakpoints are no longer deleted/disabled at
all, and we end up with a one-liner fix.

Tested on x86_64 Fedora 17.

gdb/
2013-09-19  Pedro Alves  <palves@@redhat.com>

	* breakpoint.c (remove_threaded_breakpoints): Skip non-user
	breakpoints.
@
text
@d3584 1
a3584 1
  if (PIDGET (ptid) == PIDGET (inferior_ptid))
d7549 1
a7549 1
  return target_insert_fork_catchpoint (PIDGET (inferior_ptid));
d7558 1
a7558 1
  return target_remove_fork_catchpoint (PIDGET (inferior_ptid));
d7666 1
a7666 1
  return target_insert_vfork_catchpoint (PIDGET (inferior_ptid));
d7675 1
a7675 1
  return target_remove_vfork_catchpoint (PIDGET (inferior_ptid));
d8168 1
a8168 1
  return target_set_syscall_catchpoint (PIDGET (inferior_ptid),
d8208 1
a8208 1
  return target_set_syscall_catchpoint (PIDGET (inferior_ptid),
d8531 1
a8531 1
  return target_insert_exec_catchpoint (PIDGET (inferior_ptid));
d8537 1
a8537 1
  return target_remove_exec_catchpoint (PIDGET (inferior_ptid));
@


1.777
log
@PR gdb/11568 - delete thread-specific breakpoints on thread exit

PR gdb/11568 is about thread-specific breakpoints being left behind
when the corresponding thread exits.

Currently:

 (gdb) b start thread 2
 Breakpoint 3 at 0x400614: file thread-specific-bp.c, line 23.
 (gdb) b end
 Breakpoint 4 at 0x40061f: file thread-specific-bp.c, line 29.
 (gdb) c
 Continuing.
 [Thread 0x7ffff7fcb700 (LWP 14925) exited]
 [Switching to Thread 0x7ffff7fcc740 (LWP 14921)]

 Breakpoint 4, end () at thread-specific-bp.c:29
 29      }
 (gdb) info threads
   Id   Target Id         Frame
 * 1    Thread 0x7ffff7fcc740 (LWP 14921) "thread-specific" end () at thread-specific-bp.c:29
 (gdb) info breakpoints
 Num     Type           Disp Enb Address            What
 2       breakpoint     keep y   0x0000000000400614 in start at thread-specific-bp.c:23
         breakpoint already hit 1 time
 3       breakpoint     keep y   0x0000000000400614 in start at thread-specific-bp.c:23 thread 2
         stop only in thread 2
 4       breakpoint     keep y   0x000000000040061f in end at thread-specific-bp.c:29
         breakpoint already hit 1 time

Note that the thread-specific breakpoint 3 stayed around, even though
thread 2 is gone.

There's no way that breakpoint can trigger again (*), so the PR argues
that the breakpoint should just be removed, like local watchpoints.
I'm ambivalent on this -- it could be reasonable to disable the
breakpoint (kind of like breakpoint in shared library code when the
DSO is unloaded), so the user could still use it as visual template
for creating other breakpoints (copy/paste command lists, etc.), or we
could have a way to change to which thread a breakpoint applies.  But,
several people pushed this direction, and I don't plan on arguing...

(*) - actually, there is ...  thread numbers are reset on "run", so
the user could do "break foo thread 2", "run", and expect the
breakpoint to hit again on the second thread.  But given gdb's thread
numbering can't really be stable, that'd only work sufficiently well
for thread 1, so we'd better call it unsupported.

So with the patch, whenever a thread is deleted from GDB's list, GDB
goes through the thread-specific breakpoints and deletes corresponding
breakpoints.  Since this is user-visible, GDB prints out:

  Thread-specific breakpoint 3 deleted - thread 2 is gone.

And of course, we end up with:

 (gdb) info breakpoints
 Num     Type           Disp Enb Address            What
 2       breakpoint     keep y   0x0000000000400614 in start at thread-specific-bp.c:23
         breakpoint already hit 1 time
 4       breakpoint     keep y   0x000000000040061f in end at thread-specific-bp.c:29
         breakpoint already hit 1 time

2013-09-17  Muhammad Waqas <mwaqas@@codesourcery.com>
	    Pedro Alves  <palves@@redhat.com>

	PR gdb/11568
	* breakpoint.c (remove_threaded_breakpoints): New function.
	(_initialize_breakpoint): Attach remove_threaded_breakpoints
	as thread_exit observer.

2013-09-17  Muhammad Waqas  <mwaqas@@codesourccery.com>
	    Jan Kratochvil  <jan.kartochvil@@redhat.com>
	    Pedro Alves  <palves@@redhat.com>

	PR gdb/11568
	* gdb.thread/thread-specific-bp.c: New file.
	* gdb.thread/thread-specific-bp.exp: New file.
@
text
@d2941 1
a2941 1
      if (b->thread == tp->num)
@


1.776
log
@2013-08-12  Muhammad Waqas  <mwaqas@@codesourcery.com>

	PR gdb/15501
	* breakpoint.c (enable_command, disable_command): Iterate over
	all specified breakpoint locations.
2013-07-12  Muhammad Waqas  <mwaqas@@codesourccery.com>

	PR gdb/15501
	* gdb.base/ena-dis-br.exp: Add test to verify
 	enable/disable commands work correctly with
	multiple arguments that include multiple locations.
@
text
@d2931 24
d16614 1
@


1.775
log
@save breakpoints: Make tilde-expanded filename visible.

Most commands in GDB show the tilde-expanded filename in user visible
output.  This makes "save breakpoints" behave the same.

Before:

  (gdb) save breakpoints ~/a/b
  Unable to open file '~/a/b' for saving (No such file or directory)

After:

  (gdb) save breakpoints ~/a/b
  Unable to open file '/home/pedro/a/b' for saving (No such file or directory)

Tested on x86_64 Fedora 17.

gdb/
2013-08-09  Pedro Alves  <palves@@redhat.com>

        * breakpoint.c (save_breakpoints): Show tilde-expanded filename in
	error message.
@
text
@d14556 1
a14556 1
  else if (strchr (args, '.'))
d14558 3
a14560 2
      struct bp_location *loc = find_location_by_number (args);
      if (loc)
d14562 1
a14562 1
	  if (loc->enabled)
d14564 15
a14578 2
	      loc->enabled = 0;
	      mark_breakpoint_location_modified (loc);
d14580 3
a14582 4
	  if (target_supports_enable_disable_tracepoint ()
	      && current_trace_status ()->running && loc->owner
	      && is_tracepoint (loc->owner))
	    target_disable_tracepoint (loc);
a14583 1
      update_global_location_list (0);
a14584 2
  else
    map_breakpoint_numbers (args, do_map_disable_breakpoint, NULL);
d14690 1
a14690 1
  else if (strchr (args, '.'))
d14692 3
a14694 2
      struct bp_location *loc = find_location_by_number (args);
      if (loc)
d14696 1
a14696 1
	  if (!loc->enabled)
d14698 15
a14712 2
	      loc->enabled = 1;
	      mark_breakpoint_location_modified (loc);
d14714 3
a14716 4
	  if (target_supports_enable_disable_tracepoint ()
	      && current_trace_status ()->running && loc->owner
	      && is_tracepoint (loc->owner))
	    target_enable_tracepoint (loc);
a14717 1
      update_global_location_list (1);
a14718 2
  else
    map_breakpoint_numbers (args, do_map_enable_breakpoint, NULL);
@


1.774
log
@fix PR symtab/15719

This patch fixes PR symtab/15719.

The bug is that "watch -location" crashes on a certain expression.

The problem is that fetch_subexp_value is catching an exception.
For ordinary watchpoints this is ok; but for location watchpoints,
it is better for the exception to propagate.

Built and regtested on x86-64 Fedora 18.
New test case included.

	PR symtab/15719:
	* breakpoint.c (update_watchpoint, watchpoint_check)
	(watch_command_1): Update.
	* eval.c (fetch_subexp_value): Add "preserve_errors"
	parameter.
	* ppc-linux-nat.c (check_condition): Update.
	* value.h (fetch_subexp_value): Update.

	* gdb.base/watchpoint.c (struct foo5): New.
	(nullptr): New global.
	* gdb.base/watchpoint.exp (test_watch_location): Add test.
@
text
@a15462 1
  char *pathname;
d15498 3
a15500 3
  pathname = tilde_expand (filename);
  cleanup = make_cleanup (xfree, pathname);
  fp = gdb_fopen (pathname, "w");
a15569 1
  do_cleanups (cleanup);
d15572 1
@


1.773
log
@2013-07-24  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* breakpoint.c (create_longjmp_master_breakpoint): Check if probe
	interface can evaluate arguments.  Fallback to the old mode if it
	cannot.
	(create_exception_master_breakpoint): Likewise.
	* elfread.c (elf_can_evaluate_probe_arguments): New function.
	(struct sym_probe_fns elf_probe_fns): Export function above to the
	probe interface.
	* probe.c (can_evaluate_probe_arguments): New function.
	* probe.h (struct probe_ops) <can_evaluate_probe_arguments>: New
	function pointer.
	(can_evaluate_probe_arguments): New function prototype.
	* solib-svr4.c (svr4_create_solib_event_breakpoints): Check if
	probe interface can evaluate arguments.  Fallback to the old mode
	if it cannot.
	* stap-probe.c (stap_get_probe_argument_count): Check if probe
	interface can evaluate arguments.  Warning the user if it cannot.
	(stap_can_evaluate_probe_arguments): New function.
	(struct probe_ops stap_probe_ops): Export function above to the
	probe interface.
	* symfile.h (struct sym_probe_fns) <can_evaluate_probe_arguments>:
	New function pointer.
@
text
@d1810 1
a1810 1
      fetch_subexp_value (b->exp, &pc, &v, &result, &val_chain);
d4825 1
a4825 1
      fetch_subexp_value (b->exp, &pc, &new_val, NULL, NULL);
d11013 1
a11013 1
  fetch_subexp_value (exp, &pc, &val, &result, NULL);
@


1.772
log
@gdb/

	* breakpoint.h (struct breakpoint_ops) <create_breakpoints_sal>:
	Remove parameter 'lsal'.
	* breakpoint.c (create_breakpoint): Move local variable 'lsal'
	to inner block.  Caller update.
	(base_breakpoint_create_breakpoints_sal): Update.
	(bkpt_create_breakpoints_sal): Likewise.
	(tracepoint_create_breakpoints_sal): Likewise.
	(strace_marker_create_breakpoints_sal): Get 'lsal' from the
	element 0 of vector 'canonical->sals'.
@
text
@d3197 17
a3213 2
	  bp_objfile_data->longjmp_probes
	    = find_probes_in_objfile (objfile, "libc", "longjmp");
d3354 18
a3371 2
	  bp_objfile_data->exception_probes
	    = find_probes_in_objfile (objfile, "libgcc", "unwind");
@


1.771
log
@gdb/

2013-06-26  Pedro Alves  <pedro@@codesourcery.com>
	    Yao Qi  <yao@@codesourcery.com>

	* ctf.c (ctf_traceframe_info): Push trace state variables
	present in the trace data into the traceframe info object.
	* breakpoint.c (DEF_VEC_I): Remove.
	* common/filestuff.c (DEF_VEC_I): Likewise.
	* dwarf2loc.c (DEF_VEC_I): Likewise.
	* mi/mi-main.c (DEF_VEC_I): Likewise.
	* common/gdb_vecs.h (DEF_VEC_I): Define vector for int.
	* features/traceframe-info.dtd: Add tvar element and its
	attributes.
	* tracepoint.c (free_traceframe_info): Free vector 'tvars'.
	(build_traceframe_info): Push trace state variables present in the
	trace data into the traceframe info object.
	(traceframe_info_start_tvar): New function.
	(tvar_attributes): New.
	(traceframe_info_children): Add "tvar" element.
	* tracepoint.h (struct traceframe_info) <tvars>: New field.

	* NEWS: Mention the change in GDB and GDBserver.

gdb/doc:

2013-06-26  Pedro Alves  <pedro@@codesourcery.com>

	* gdb.texinfo (Traceframe Info Format): Document tvar element and
	its attributes.

gdb/gdbserver:

2013-06-26  Pedro Alves  <pedro@@codesourcery.com>

	* tracepoint.c (build_traceframe_info_xml): Output trace state
	variables present in the trace buffer.
@
text
@a9612 4
      struct linespec_sals *lsal;

      lsal = VEC_index (linespec_sals, canonical.sals, 0);

d9616 4
d9653 1
a9653 1
      ops->create_breakpoints_sal (gdbarch, &canonical, lsal,
a12725 1
					struct linespec_sals *lsal,
a12946 1
			     struct linespec_sals *lsal,
a13283 1
				   struct linespec_sals *lsal,
a13434 1
				      struct linespec_sals *lsal,
d13446 2
@


1.770
log
@2013-06-25  Yao Qi  <yao@@codesourcery.com>
	    Hui Zhu  <hui@@codesourcery.com>
	    Pedro Alves  <palves@@redhat.com>

	PR breakpoints/15075
	PR breakpoints/15434
	* breakpoint.c (bpstat_stop_status): Call
	b->ops->after_condition_true.
	(update_dprintf_command_list): Don't append "continue" command
	to the command list of dprintf breakpoint.
	(base_breakpoint_after_condition_true): New function.
	(base_breakpoint_ops): Add base_breakpoint_after_condition_true.
	(dprintf_after_condition_true): New function.
	(initialize_breakpoint_ops): Set dprintf_after_condition_true.
	* breakpoint.h (breakpoint_ops): Add after_condition_true.

2013-06-25  Yao Qi  <yao@@codesourcery.com>
	    Hui Zhu  <hui@@codesourcery.com>
	    Pedro Alves  <palves@@redhat.com>

	PR breakpoints/15075
	PR breakpoints/15434
	* gdb.base/dprintf-next.c: New file.
	* gdb.base/dprintf-next.exp: New file.
	* gdb.base/dprintf-non-stop.c: New file.
	* gdb.base/dprintf-non-stop.exp: New file.
	* gdb.base/dprintf.exp: Don't check "continue" in the output
	of "info breakpoints".
	* gdb.mi/mi-breakpoint-changed.exp (test_insert_delete_modify):
	Don't check "continue" in script field.
@
text
@a5801 2
DEF_VEC_I(int);

@


1.769
log
@gdb/

	* breakpoint.c (create_breakpoint): Fix code indentation.
@
text
@d5311 2
d8948 1
a8948 1
  /* Manufacture a printf/continue sequence.  */
d8950 2
a8951 11
    struct command_line *printf_cmd_line, *cont_cmd_line = NULL;

    if (strcmp (dprintf_style, dprintf_style_agent) != 0)
      {
	cont_cmd_line = xmalloc (sizeof (struct command_line));
	cont_cmd_line->control_type = simple_control;
	cont_cmd_line->body_count = 0;
	cont_cmd_line->body_list = NULL;
	cont_cmd_line->next = NULL;
	cont_cmd_line->line = xstrdup ("continue");
      }
d8957 1
a8957 1
    printf_cmd_line->next = cont_cmd_line;
d12757 8
d12784 2
a12785 1
  base_breakpoint_explains_signal
d13379 38
d15913 1
@


1.768
log
@gdb/

	* breakpoint.c (create_breakpoints_sal_default): Remove
	parameter 'lsal'.  Update declaration.
	(bkpt_create_breakpoints_sal): Caller update.
	(tracepoint_create_breakpoints_sal): Likewise.
@
text
@d9628 14
a9641 14
	    char *rest;
            /* Here we only parse 'arg' to separate condition
               from thread number, so parsing in context of first
               sal is OK.  When setting the breakpoint we'll 
               re-parse it in context of each sal.  */

            find_condition_and_thread (arg, lsal->sals.sals[0].pc, &cond_string,
                                       &thread, &task, &rest);
            if (cond_string)
                make_cleanup (xfree, cond_string);
	    if (rest)
	      make_cleanup (xfree, rest);
	    if (rest)
	      extra_string = rest;
d9645 2
a9646 2
	    if (*arg != '\0')
	      error (_("Garbage '%s' at end of location"), arg);
d9648 12
a9659 12
            /* Create a private copy of condition string.  */
            if (cond_string)
            {
                cond_string = xstrdup (cond_string);
                make_cleanup (xfree, cond_string);
            }
            /* Create a private copy of any extra string.  */
            if (extra_string)
	      {
                extra_string = xstrdup (extra_string);
                make_cleanup (xfree, extra_string);
	      }
@


1.767
log
@	* breakpoint.c (_initialize_breakpoint): Remove trailing \n from
	"dprintf" help.
@
text
@a121 1
					    struct linespec_sals *,
d12959 1
a12959 1
  create_breakpoints_sal_default (gdbarch, canonical, lsal,
d13297 1
a13297 1
  create_breakpoints_sal_default (gdbarch, canonical, lsal,
a14132 1
				struct linespec_sals *lsal,
@


1.766
log
@Fix PR cli/15603

This fixes PR cli/15603.

The bug here is that when a software watchpoint is being used, gdb
will stop responding to C-c.  This is a regression caused by the
"catch signal" patch.

The problem is that software watchpoints always end up on the bpstat
list.  However, this makes bpstat_explains_signal return
BPSTAT_SIGNAL_HIDE, causing infrun to think that the signal is not a
"random signal".

The fix is to change bpstat_explains_signal to handle this better.  I
chose to do it in a "clean API" way, by passing the signal value to
bpstat_explains_signal and then adding an explains_signal method for
watchpoints, which handles the specifics.

Built and regtested on x86-64 Fedora 18.
New test case included.

	* break-catch-sig.c (signal_catchpoint_explains_signal): Add 'sig'
	argument.
	* breakpoint.c (bpstat_explains_signal): Add 'sig' argument.
	Special case signals other than GDB_SIGNAL_TRAP.
	(explains_signal_watchpoint): New function.
	(base_breakpoint_explains_signal): Add 'sig' argument.
	(initialize_breakpoint_ops): Set 'explains_signal' method for
	watchpoints.
	* breakpoint.h (struct breakpoint_ops) <explains_signal>: Add
	signal argument.
	(bpstat_explains_signal): Likewise.
	* infrun.c (handle_syscall_event, handle_inferior_event): Update.

	* gdb.base/random-signal.c: New file.
	* gdb.base/random-signal.exp: New file.
@
text
@d16456 1
a16456 2
If a function is specified, break at start of code for that function.\n\
"));
@


1.765
log
@2013-06-04  Gary Benson  <gbenson@@redhat.com>

	* breakpoint.h (handle_solib_event): Moved function declaration
	to solib.h.
	* breakpoint.c (handle_solib_event): Moved function to solib.c.
	(bpstat_stop_status): Pass new argument to handle_solib_event.
	* solib.h (update_solib_breakpoints): New function declaration.
	(handle_solib_event): Moved function declaration from
	breakpoint.h.
	* solib.c (update_solib_breakpoints): New function.
	(handle_solib_event): Moved function from breakpoint.c.
	Updated to call solib_ops->handle_event if not NULL.
	* solist.h (target_so_ops): New fields "update_breakpoints" and
	"handle_event".
	* infrun.c (set_stop_on_solib_events): New function.
	(_initialize_infrun): Use the above for "set
	stop-on-solib-events".
	(handle_inferior_event): Pass new argument to handle_solib_event.
	* solib-svr4.c (probe.h): New include.
	(svr4_free_library_list): New forward declaration.
	(probe_action): New enum.
	(probe_info): New struct.
	(probe_info): New static variable.
	(NUM_PROBES): New definition.
	(svr4_info): New fields "using_xfer", "probes_table" and
	"solib_list".
	(free_probes_table): New function.
	(free_solib_list): New function.
	(svr4_pspace_data_cleanup): Free probes table and solib list.
	(svr4_copy_library_list): New function.
	(svr4_current_sos_via_xfer_libraries): New parameter "annex".
	(svr4_read_so_list): New parameter "prev_lm".
	(svr4_current_sos_direct): Renamed from "svr4_current_sos".
	(svr4_current_sos): New function.
	(probe_and_action): New struct.
	(hash_probe_and_action): New function.
	(equal_probe_and_action): Likewise.
	(register_solib_event_probe): Likewise.
	(solib_event_probe_at): Likewise.
	(solib_event_probe_action): Likewise.
	(solist_update_full): Likewise.
	(solist_update_incremental): Likewise.
	(disable_probes_interface_cleanup): Likewise.
	(svr4_handle_solib_event): Likewise.
	(svr4_update_solib_event_breakpoint): Likewise.
	(svr4_update_solib_event_breakpoints): Likewise.
	(svr4_create_solib_event_breakpoints): Likewise.
	(enable_break): Free probes table before creating breakpoints.
	Use svr4_create_solib_event_breakpoints to create breakpoints.
	(svr4_solib_create_inferior_hook): Free the solib list.
	(_initialize_svr4_solib): Initialise
	svr4_so_ops.handle_solib_event and svr4_so_ops.update_breakpoints.
@
text
@d4156 1
a4156 1
bpstat_explains_signal (bpstat bsp)
d4164 1
a4164 1
      enum bpstat_signal_value newval = BPSTAT_SIGNAL_HIDE;
d4166 12
a4177 2
      if (bsp->breakpoint_at != NULL)
	newval = bsp->breakpoint_at->ops->explains_signal (bsp->breakpoint_at);
d10643 14
d12760 1
a12760 1
base_breakpoint_explains_signal (struct breakpoint *b)
d15770 1
@


1.764
log
@fix two buglets in breakpoint.c

First, output_thread_groups leaks a cleanup along one return path.

Second, parse_cmd_to_aexpr could return without running its cleanups,
if there was an exception in a TRY_CATCH.

	* breakpoint.c (output_thread_groups, parse_cmd_to_aexpr): Call
	do_cleanups earlier.
@
text
@a5354 15
/* Handle an solib event by calling solib_add.  */

void
handle_solib_event (void)
{
  clear_program_space_solib_cache (current_inferior ()->pspace);

  /* Check for any newly added shared libraries if we're supposed to
     be adding them automatically.  Switch terminal for any messages
     produced by breakpoint_re_set.  */
  target_terminal_ours_for_output ();
  solib_add (NULL, 0, &current_target, auto_solib_add);
  target_terminal_inferior ();
}

@


1.763
log
@Fix internal error caused by interaction between catch signal and fork
@
text
@d2251 2
a2260 2
  do_cleanups (old_cleanups);

d5817 1
a5817 2
  struct cleanup *back_to = make_cleanup_ui_out_list_begin_end (uiout,
								field_name);
d5827 2
@


1.762
log
@2013-05-21  Hui Zhu  <hui@@codesourcery.com>

	* breakpoint.c (dprintf_breakpoint_ops): Remove its static.
	* breakpoint.h (dprintf_breakpoint_ops): Add extern.
	* mi/mi-cmd-break.c (ctype.h): New include.
	(gdb_obstack.h): New include.
	(mi_argv_to_format, mi_cmd_break_insert_1): New.
	(mi_cmd_break_insert): Call mi_cmd_break_insert_1.
	(mi_cmd_dprintf_insert): New.
	* mi/mi-cmds.c (mi_cmds): Add "dprintf-insert".
	* mi/mi-cmds.h (mi_cmd_dprintf_insert): New extern.

2013-05-21  Hui Zhu  <hui@@codesourcery.com>

	* gdb.texinfo (GDB/MI Breakpoint Commands): Describe the
	"-dprintf-insert" command.

2013-05-21  Hui Zhu  <hui@@codesourcery.com>

	* gdb.mi/Makefile.in (PROGS): Add "mi-dprintf".
	* gdb.mi/mi-dprintf.exp, gdb.mi/mi-dprintf.c: New.
@
text
@d3540 9
@


1.761
log
@gdb/
2013-05-07  Sergio Durigan Junior  <sergiodj@@redhat.com>

	PR breakpoints/15413:
	* breakpoint.c (condition_completer): Simplify the code to
	disconsider multiple locations of breakpoints when completing the
	"condition" command.

gdb/testsuite/
2013-05-07  Sergio Durigan Junior  <sergiodj@@redhat.com>

	PR breakpoints/15413:
	* gdb.base/pending.exp: Add test for completion of the "condition"
	command for pending breakpoints.
	* gdb.linespec/linespec.ex: Add test for completion of the
	"condition" command when dealing with multiple locations.
@
text
@d304 1
a304 1
static struct breakpoint_ops dprintf_breakpoint_ops;
@


1.760
log
@Reimplement shared library support on ppc-aix...

... using the target_so_ops framework.

gdb/ChangeLog:

        * target.h (TARGET_OBJECT_AIX_LIBRARIES): New target_object enum.
        * features/library-list-aix.dtd: New file.
        * solib-aix.h, solib-aix.c: New file.
        * rs6000-aix-tdep.c: #include "solib.h" and "solib-aix.h".
        (rs6000_find_toc_address_hook): Delete.
        (rs6000_push_dummy_call): Rewrite code setting the TOC value.
        (rs6000_aix_init_osabi): Register solib_aix_so_ops.
        * rs6000-nat.c: Remove "xcoffsolib.h" include.  Include
        "xml-utils.h".
        (map_vmap, vmap_exec, vmap_ldinfo, add_vmap, objfile_symbol_add)
        (vmap_symtab, fixup_breakpoints): Delete.
        (rs6000_xfer_shared_libraries): New function.
        (rs6000_xfer_partial): Add TARGET_OBJECT_AIX_LIBRARIES handling.
        (vmap_secs, bss_data_overlap, vmap_add_symbols): Delete.
        (xcoff_relocate_symtab, xcoff_relocate_core): Delete.
        (rs6000_ptrace_ldinfo, rs6000_core_ldinfo)
        (rs6000_xfer_shared_library): New function.
        (find_toc_address): Delete.
        (_initialize_rs6000_nat): Do not set rs6000_find_toc_address_hook.
        * rs6000-tdep.h (rs6000_find_toc_address_hook): Remove.
        * xcoffread.c (record_minimal_symbol): Reloate symbol address
        before creating minimal symbol.  Adjust function description
        accordingly.
        (scan_xcoff_symtab): Replace call to
        prim_record_minimal_symbol_and_info by call to
        record_minimal_symbol.
        (xcoff_symfile_offsets): Reimplement mostly as a wrapper
        around default_symfile_offsets.
        * configure.tgt: Add solib-aix.o to gdb_target_obs for
        powerpc-aix targets.
        * config/rs6000/nm-rs6000.h: Delete.
        * config/powerpc/aix.mh (NAT_FILE): Delete.
        (NATDEPFILES): Remove xcoffsolib.o.
        * Makefile.in (XMLFILES): Add library-list-aix.dtd.
        (ALL_TARGET_OBS): Add solib-aix.o.
        (HFILES_NO_SRCDIR): Remove xcoffsolib.h and
        config/rs6000/nm-rs6000.h.  Add solib-aix.h.
        (ALLDEPFILES): Add solib-aix.c.  Remove xcoffsolib.c.
        * xcoffsolib.h, xcoffsolib.c: Delete.

        * solib.c (reload_shared_libraries): Remove reference to
        SOLIB_CREATE_INFERIOR_HOOK.
        * breakpoint.c (handle_solib_event): Remove reference to SOLIB_ADD.
        (disable_breakpoints_in_shlibs): Remove reference to PC_SOLIB.
        (momentary_bkpt_re_set): Replace SOLIB_ADD by solib_add in
        comment.
        * corelow.c (deprecated_core_resize_section_table): Delete.
        * exec.c: Remove include of xcoffsolib.h".
        (map_vmap, vmap): Delete.
        (exec_close_1): Remove references to vmap.
        (exec_file_attach): Remove vmap handling code, and reference
        to DEPRECATED_IBM6000_TARGET.
        (bfdsec_to_vmap): Delete.
        (exec_files_info): Remove block of code handling VMAP.
        * infcmd.c (post_create_inferior): Remove reference to
        SOLIB_CREATE_INFERIOR_HOOK and SOLIB_ADD.
        * infrun.c (follow_exec): Remove reference to
        SOLIB_CREATE_INFERIOR_HOOK.
        * stack.c (print_frame): Remove reference to PC_SOLIB.
        * solib-dsbt.c (dsbt_current_sos): Adjust comment.
        (dsbt_relocate_main_executable): Likewise.
        * solib-frv.c (frv_current_sos): Likewise.

gdb/doc/ChangeLog:

        * gdbint.texinfo (Algorithms): Remove entries documenting
        DEPRECATED_IBM6000_TARGET, SOLIB_ADD, and
        SOLIB_CREATE_INFERIOR_HOOK.
@
text
@d1015 2
a1016 4
      {
	int single = b->loc->next == NULL;
	struct bp_location *loc;
	int count = 1;
d1018 1
a1018 3
	for (loc = b->loc; loc; loc = loc->next)
	  {
	    char location[50];
d1020 3
a1022 12
	    if (single)
	      xsnprintf (location, sizeof (location), "%d", b->number);
	    else
	      xsnprintf (location, sizeof (location),  "%d.%d", b->number,
			 count);

	    if (strncmp (location, text, len) == 0)
	      VEC_safe_push (char_ptr, result, xstrdup (location));

	    ++count;
	  }
      }
@


1.759
log
@2013-04-25  Hui Zhu  <hui@@codesourcery.com>

	* breakpoint.c (build_target_command_list): Change loc->cond_bytecode
	to loc->cmd_bytecode.
@
text
@a5369 3
#ifdef SOLIB_ADD
  SOLIB_ADD (NULL, 0, &current_target, auto_solib_add);
#else
a5370 1
#endif
a7415 3
#ifdef PC_SOLIB
	&& PC_SOLIB (loc->address)
#else
a7416 1
#endif
d13072 1
a13072 1
     over a dlopen call and SOLIB_ADD is resetting the breakpoints.
@


1.758
log
@2013-04-23  Hui Zhu  <hui@@codesourcery.com>

	PR gdb/15293

	* breakpoint.c (bpstat_what): Add BPSTAT_WHAT_SINGLE to bp_dprintf.

2013-04-23  Hui Zhu  <hui@@codesourcery.com>

	PR gdb/15293

	* gdb.base/dprintf.exp: Add ignore command.
@
text
@d2346 1
a2346 1
	      if (!loc->cond_bytecode)
d2349 2
a2350 2
	      free_agent_expr (loc->cond_bytecode);
	      loc->cond_bytecode = NULL;
@


1.757
log
@2013-04-23  Hui Zhu  <hui@@codesourcery.com>

	PR gdb/15165

	* breakpoint.c (dprintf_print_recreate): New.
	(save_breakpoints): Let it not save dprintf commands.
	(initialize_breakpoint_ops): Set dprintf_print_recreate.

2013-04-23  Hui Zhu  <hui@@codesourcery.com>

	PR gdb/15165

	* gdb.base/save-bp.exp: Add test for dprintf.
@
text
@d5532 4
a5535 1
	  this_action = BPSTAT_WHAT_STOP_SILENT;
@


1.756
log
@	* Makefile.in (SFILES): Add break-catch-throw.c
	(COMMON_OBS): Add break-catch-throw.o.
	* break-catch-throw.c: New file.
	* breakpoint.c: Move exception-catching code to new file.
	(ep_parse_optional_if_clause): No longer static.
	* breakpoint.h (ep_parse_optional_if_clause): Declare.
@
text
@d13367 10
d15466 1
a15466 1
    if (tp->commands)
d15872 1
a15872 1
  ops->print_recreate = bkpt_print_recreate;
@


1.755
log
@	PR c++/9065:
	* NEWS: Update.
	* breakpoint.c (watchpoint_exp_is_const): Add OP_TYPEID.
	* c-exp.y (TYPEID): New token.
	(exp): Add new TYPEID productions.
	(ident_tokens): Add "typeid".
	* cp-abi.c (cplus_typeid, cplus_typeid_type): New functions.
	* cp-abi.h (cplus_typeid, cplus_typeid_type): Declare.
	(struct cp_abi_ops) <get_typeid, get_typeid_type>: New fields.
	* eval.c (evaluate_subexp_standard) <OP_TYPEID>: New case.
	* expprint.c (dump_subexp_body_standard) <OP_TYPEID>: New
	case.
	* gnu-v3-abi.c (std_type_info_gdbarch_data): New global.
	(build_std_type_info_type, gnuv3_get_typeid_type)
	(gnuv3_get_typeid): New functions.
	(init_gnuv3_ops): Initialize std_type_info_gdbarch_data.  Set
	new fields on ABI object.
	* parse.c (operator_length_standard) <OP_TYPEID>: New case.
	* std-operator.def (OP_TYPEID): New.
gdb/testsuite
	* gdb.cp/typeid.cc: New file.
	* gdb.cp/typeid.exp: New file.
@
text
@a233 5
static char *ep_parse_optional_if_clause (char **arg);

static void catch_exception_command_1 (enum exception_event_kind ex_event, 
				       char *arg, int tempflag, int from_tty);

d11457 1
a11457 1
static char *
a11569 226
/* A helper function that returns a value indicating the kind of the
   exception catchpoint B.  */

static enum exception_event_kind
classify_exception_breakpoint (struct breakpoint *b)
{
  if (strstr (b->addr_string, "catch") != NULL)
    return EX_EVENT_CATCH;
  else if (strstr (b->addr_string, "rethrow") != NULL)
    return EX_EVENT_RETHROW;
  else
    return EX_EVENT_THROW;
}

static enum print_stop_action
print_it_exception_catchpoint (bpstat bs)
{
  struct ui_out *uiout = current_uiout;
  struct breakpoint *b = bs->breakpoint_at;
  int bp_temp;
  enum exception_event_kind kind = classify_exception_breakpoint (b);

  annotate_catchpoint (b->number);

  if (b->loc->address != b->loc->requested_address)
    breakpoint_adjustment_warning (b->loc->requested_address,
	                           b->loc->address,
				   b->number, 1);
  bp_temp = b->disposition == disp_del;
  ui_out_text (uiout, 
	       bp_temp ? "Temporary catchpoint "
		       : "Catchpoint ");
  if (!ui_out_is_mi_like_p (uiout))
    ui_out_field_int (uiout, "bkptno", b->number);
  ui_out_text (uiout,
	       (kind == EX_EVENT_THROW ? " (exception thrown), "
		: (kind == EX_EVENT_CATCH ? " (exception caught), "
		   : " (exception rethrown), ")));
  if (ui_out_is_mi_like_p (uiout))
    {
      ui_out_field_string (uiout, "reason", 
			   async_reason_lookup (EXEC_ASYNC_BREAKPOINT_HIT));
      ui_out_field_string (uiout, "disp", bpdisp_text (b->disposition));
      ui_out_field_int (uiout, "bkptno", b->number);
    }
  return PRINT_SRC_AND_LOC;
}

static void
print_one_exception_catchpoint (struct breakpoint *b, 
				struct bp_location **last_loc)
{
  struct value_print_options opts;
  struct ui_out *uiout = current_uiout;
  enum exception_event_kind kind = classify_exception_breakpoint (b);

  get_user_print_options (&opts);
  if (opts.addressprint)
    {
      annotate_field (4);
      if (b->loc == NULL || b->loc->shlib_disabled)
	ui_out_field_string (uiout, "addr", "<PENDING>");
      else
	ui_out_field_core_addr (uiout, "addr",
				b->loc->gdbarch, b->loc->address);
    }
  annotate_field (5);
  if (b->loc)
    *last_loc = b->loc;

  switch (kind)
    {
    case EX_EVENT_THROW:
      ui_out_field_string (uiout, "what", "exception throw");
      if (ui_out_is_mi_like_p (uiout))
	ui_out_field_string (uiout, "catch-type", "throw");
      break;

    case EX_EVENT_RETHROW:
      ui_out_field_string (uiout, "what", "exception rethrow");
      if (ui_out_is_mi_like_p (uiout))
	ui_out_field_string (uiout, "catch-type", "rethrow");
      break;

    case EX_EVENT_CATCH:
      ui_out_field_string (uiout, "what", "exception catch");
      if (ui_out_is_mi_like_p (uiout))
	ui_out_field_string (uiout, "catch-type", "catch");
      break;
    }
}

static void
print_mention_exception_catchpoint (struct breakpoint *b)
{
  struct ui_out *uiout = current_uiout;
  int bp_temp;
  enum exception_event_kind kind = classify_exception_breakpoint (b);

  bp_temp = b->disposition == disp_del;
  ui_out_text (uiout, bp_temp ? _("Temporary catchpoint ")
			      : _("Catchpoint "));
  ui_out_field_int (uiout, "bkptno", b->number);
  ui_out_text (uiout, (kind == EX_EVENT_THROW ? _(" (throw)")
		       : (kind == EX_EVENT_CATCH ? _(" (catch)")
			  : _(" (rethrow)"))));
}

/* Implement the "print_recreate" breakpoint_ops method for throw and
   catch catchpoints.  */

static void
print_recreate_exception_catchpoint (struct breakpoint *b, 
				     struct ui_file *fp)
{
  int bp_temp;
  enum exception_event_kind kind = classify_exception_breakpoint (b);

  bp_temp = b->disposition == disp_del;
  fprintf_unfiltered (fp, bp_temp ? "tcatch " : "catch ");
  switch (kind)
    {
    case EX_EVENT_THROW:
      fprintf_unfiltered (fp, "throw");
      break;
    case EX_EVENT_CATCH:
      fprintf_unfiltered (fp, "catch");
      break;
    case EX_EVENT_RETHROW:
      fprintf_unfiltered (fp, "rethrow");
      break;
    }
  print_recreate_thread (b, fp);
}

static struct breakpoint_ops gnu_v3_exception_catchpoint_ops;

static int
handle_gnu_v3_exceptions (int tempflag, char *cond_string,
			  enum exception_event_kind ex_event, int from_tty)
{
  char *trigger_func_name;
 
  if (ex_event == EX_EVENT_CATCH)
    trigger_func_name = "__cxa_begin_catch";
  else if (ex_event == EX_EVENT_RETHROW)
    trigger_func_name = "__cxa_rethrow";
  else
    {
      gdb_assert (ex_event == EX_EVENT_THROW);
      trigger_func_name = "__cxa_throw";
    }

  create_breakpoint (get_current_arch (),
		     trigger_func_name, cond_string, -1, NULL,
		     0 /* condition and thread are valid.  */,
		     tempflag, bp_breakpoint,
		     0,
		     AUTO_BOOLEAN_TRUE /* pending */,
		     &gnu_v3_exception_catchpoint_ops, from_tty,
		     1 /* enabled */,
		     0 /* internal */,
		     0);

  return 1;
}

/* Deal with "catch catch" and "catch throw" commands.  */

static void
catch_exception_command_1 (enum exception_event_kind ex_event, char *arg,
			   int tempflag, int from_tty)
{
  char *cond_string = NULL;

  if (!arg)
    arg = "";
  arg = skip_spaces (arg);

  cond_string = ep_parse_optional_if_clause (&arg);

  if ((*arg != '\0') && !isspace (*arg))
    error (_("Junk at end of arguments."));

  if (ex_event != EX_EVENT_THROW
      && ex_event != EX_EVENT_CATCH
      && ex_event != EX_EVENT_RETHROW)
    error (_("Unsupported or unknown exception event; cannot catch it"));

  if (handle_gnu_v3_exceptions (tempflag, cond_string, ex_event, from_tty))
    return;

  warning (_("Unsupported with this platform/compiler combination."));
}

/* Implementation of "catch catch" command.  */

static void
catch_catch_command (char *arg, int from_tty, struct cmd_list_element *command)
{
  int tempflag = get_cmd_context (command) == CATCH_TEMPORARY;

  catch_exception_command_1 (EX_EVENT_CATCH, arg, tempflag, from_tty);
}

/* Implementation of "catch throw" command.  */

static void
catch_throw_command (char *arg, int from_tty, struct cmd_list_element *command)
{
  int tempflag = get_cmd_context (command) == CATCH_TEMPORARY;

  catch_exception_command_1 (EX_EVENT_THROW, arg, tempflag, from_tty);
}

/* Implementation of "catch rethrow" command.  */

static void
catch_rethrow_command (char *arg, int from_tty,
		       struct cmd_list_element *command)
{
  int tempflag = get_cmd_context (command) == CATCH_TEMPORARY;

  catch_exception_command_1 (EX_EVENT_RETHROW, arg, tempflag, from_tty);
}

a15744 8
  /* GNU v3 exception catchpoints.  */
  ops = &gnu_v3_exception_catchpoint_ops;
  *ops = bkpt_breakpoint_ops;
  ops->print_it = print_it_exception_catchpoint;
  ops->print_one = print_one_exception_catchpoint;
  ops->print_mention = print_mention_exception_catchpoint;
  ops->print_recreate = print_recreate_exception_catchpoint;

a16159 19
  /* Add catch and tcatch sub-commands.  */
  add_catch_command ("catch", _("\
Catch an exception, when caught."),
		     catch_catch_command,
                     NULL,
		     CATCH_PERMANENT,
		     CATCH_TEMPORARY);
  add_catch_command ("throw", _("\
Catch an exception, when thrown."),
		     catch_throw_command,
                     NULL,
		     CATCH_PERMANENT,
		     CATCH_TEMPORARY);
  add_catch_command ("rethrow", _("\
Catch an exception, when rethrown."),
		     catch_rethrow_command,
                     NULL,
		     CATCH_PERMANENT,
		     CATCH_TEMPORARY);
@


1.754
log
@	PR c++/12824:
	* NEWS: Update.
	* breakpoint.c (enum exception_event_kind) <EX_EVENT_RETHROW>:
	New constant.
	(classify_exception_breakpoint): New function.
	(print_it_exception_catchpoint, print_one_exception_catchpoint)
	(print_mention_exception_catchpoint)
	(print_recreate_exception_catchpoint, handle_gnu_v3_exceptions)
	(catch_exception_command_1): Handle "rethrow" catchpoint.
	(catch_rethrow_command): New function.
	(_initialize_breakpoint): Add "catch rethrow" command.
gdb/doc
	* gdb.texinfo (Set Catchpoints): Reorganize exception
	catchpoints.  Document "catch rethrow".
	(Debugging C Plus Plus): Mention "catch rethrow".
gdb/testsuite
	* gdb.cp/exception.exp: Add "catch rethrow" tests.
@
text
@d10320 1
@


1.753
log
@2013-04-10  Pedro Alves  <palves@@redhat.com>
	    Hui Zhu  <hui@@codesourcery.com>

	* breakpoint.c (dprintf_re_set): New.
	(initialize_breakpoint_ops): Set dprintf_breakpoint_ops re_set
	to dprintf_re_set.

2013-04-10  Hui Zhu  <hui@@codesourcery.com>

	* gdb.base/Makefile.in (EXECUTABLES): Add dprintf-pending.
	(MISCELLANEOUS): Add dprintf-pendshr.sl.
	* gdb.base/dprintf-pending.c, gdb.base/dprintf-pending.exp: New.
@
text
@d89 1
d11574 14
d11593 2
a11594 1
  int bp_temp, bp_throw;
a11597 1
  bp_throw = strstr (b->addr_string, "throw") != NULL;
d11609 3
a11611 2
	       bp_throw ? " (exception thrown), "
		        : " (exception caught), ");
d11628 1
d11643 2
a11644 1
  if (strstr (b->addr_string, "throw") != NULL)
d11646 1
d11650 9
a11658 3
    }
  else
    {
d11662 1
d11671 1
a11671 1
  int bp_throw;
a11673 1
  bp_throw = strstr (b->addr_string, "throw") != NULL;
d11677 3
a11679 2
  ui_out_text (uiout, bp_throw ? _(" (throw)")
			       : _(" (catch)"));
d11690 1
a11690 1
  int bp_throw;
a11692 1
  bp_throw = strstr (b->addr_string, "throw") != NULL;
d11694 12
a11705 1
  fprintf_unfiltered (fp, bp_throw ? "throw" : "catch");
d11719 2
d11722 4
a11725 1
    trigger_func_name = "__cxa_throw";
d11759 2
a11760 1
      && ex_event != EX_EVENT_CATCH)
d11789 11
d16411 6
@


1.752
log
@	PR symtab/8424:
	* blockframe.c (find_pc_partial_function_gnu_ifunc): Check
	SYMBOL_SECTION, not SYMBOL_OBJ_SECTION.
	* breakpoint.c (resolve_sal_pc): Update.
	* elfread.c (elf_gnu_ifunc_record_cache): Update.
	* findvar.c (struct minsym_lookup_data) <objfile>: New field.
	(minsym_lookup_iterator_cb): Use it.
	(default_read_var_value): Update.
	* hppa-hpux-tdep.c (hppa64_hpux_in_solib_call_trampoline):
	Update.
	* infcmd.c (jump_command): Update.
	* linespec.c (minsym_found): Update.
	* maint.c (maintenance_translate_address): Update.
	* minsyms.c (lookup_minimal_symbol_by_pc_section_1): Update.
	(prim_record_minimal_symbol_full): Don't set SYMBOL_OBJ_SECTION.
	* parse.c (write_exp_msymbol): Update.
	* printcmd.c (address_info): Update.
	* psymtab.c (find_pc_sect_psymbol): Update.
	(fixup_psymbol_section): Check SYMBOL_SECTION, not
	SYMBOL_OBJ_SECTION.
	(add_psymbol_to_bcache): Correctly initialize SYMBOL_SECTION.
	Don't initialize SYMBOL_OBJ_SECTION.
	* spu-tdep.c (spu_catch_start): Update.
	* stabsread.c (define_symbol): Don't set SYMBOL_SECTION.
	* symmisc.c (dump_msymbols, print_symbol): Update.
	* symtab.c (fixup_section): Don't set 'obj_section'.  Change
	how fallback section is computed.
	(fixup_symbol_section): Update.
	(find_pc_sect_symtab, find_function_start_sal, skip_prologue_sal):
	Update.
	(allocate_symbol, initialize_symbol, allocate_template_symbol):
	Initialize SYMBOL_SECTION.
	* symtab.h (struct general_symbol_info) <section>: Update comment.
	<obj_section>: Remove.
	(SYMBOL_OBJ_SECTION): Add 'objfile' argument.  Rewrite.
	(SYMBOL_OBJFILE): New macro.
@
text
@d13515 29
d16043 1
a16043 1
  ops->re_set = bkpt_re_set;
@


1.751
log
@	* minsyms.h (struct bound_minimal_symbol): New.
	(lookup_minimal_symbol_and_objfile): Return bound_minimal_symbol.
	Remove objfile argument.
	(lookup_minimal_symbol_by_pc_section, lookup_minimal_symbol_by_pc):
	Return bound_minimal_symbol.
	* minsyms.c (lookup_minimal_symbol_by_pc_1)
	(lookup_minimal_symbol_by_pc_section, lookup_minimal_symbol_by_pc):
	Return bound_minimal_symbol.
	(in_gnu_ifunc_stub): Update.
	(lookup_minimal_symbol_and_objfile): Return bound_minimal_symbol.
	Remove 'objfile_p' argument.
	(lookup_solib_trampoline_symbol_by_pc): Update.
	* ada-tasks.c, amd64-windows-tdep.c, arm-tdep.c,
	arm-wince-tdep.c, block.c, blockframe.c, breakpoint.c, btrace.c,
	c-valprint.c, dwarf2loc.c, elfread.c, frame.c, frv-tdep.c,
	glibc-tdep.c, gnu-v2-abi.c, gnu-v3-abi.c, hppa-hpux-tdep.c,
	i386-tdep.c, ia64-tdep.c, infcall.c, infcmd.c, jit.c,
	linux-fork.c, m32c-tdep.c, m68hc11-tdep.c, maint.c,
	mips-tdep.c, p-valprint.c, parse.c, ppc-linux-tdep.c,
	ppc-sysv-tdep.c, printcmd.c, rs6000-tdep.c, sh64-tdep.c,
	stack.c, symtab.c, tui/tui-disasm.c: Update.
@
text
@d9817 1
a9817 1
	      sal->section = SYMBOL_OBJ_SECTION (sym);
d9833 1
a9833 1
		sal->section = SYMBOL_OBJ_SECTION (msym.minsym);
@


1.750
log
@create_breapoint / explicit mode: Error out if there's garbage after the breakpoint location.

If !PARSE_CONDITION_AND_THREAD, then ARG is just the location, nothing
else.  The fact that the describing comment of create_breakpoint
doesn't mention this just looks like an oversight of when extra_string
was added.  "parse_condition_and_thread" has been a misnomer ever
since extra_string was added -- better rename it avoid more confusion.
This makes it "parse_arg", as that'll remain stable even if/when more
explicit parameters are added.

gdb/
2013-04-08  Pedro Alves  <palves@@redhat.com>
	    Keith Seitz  <keiths@@redhat.com>

	* breakpoint.c (create_breakpoint): Rename
	"parse_condition_and_thread" parameter to "parse_arg".  Update
	describing comment.  If !PARSE_ARG, then error out if ARG is not
	the empty string after extracting the location.
	* breakpoint.h (create_breakpoint): Rename
	"parse_condition_and_thread" parameter to "parse_arg".

gdb/testsuite/
2013-04-08  Pedro Alves  <palves@@redhat.com>

	* gdb.mi/mi-break.exp (test_error): Add tests with garbage after
	the location.
@
text
@d9826 1
a9826 1
	      struct minimal_symbol *msym;
d9832 2
a9833 2
	      if (msym)
		sal->section = SYMBOL_OBJ_SECTION (msym);
@


1.749
log
@tracepoint->step_count fixes

If a tracepoint's actions list includes a while-stepping action, and
then the actions are changed to a list without any while-stepping
action, the tracepoint's step_count will be left with a stale value.
For example:

 (gdb) trace subr
 Tracepoint 1 at 0x4004d9: file ../../../src/gdb/testsuite//actions-changed.c, line 31.
 (gdb) actions
 Enter actions for tracepoint 1, one per line.
 End with a line saying just "end".
 >collect $reg
 >end
 (gdb) set debug remote 1
 (gdb) tstart
 Sending packet: $QTinit#59...Packet received: OK
 Sending packet: $QTDP:1:00000000004004d9:E:0:0-#a3...Packet received: OK
 Sending packet: $QTDP:-1:00000000004004d9:R03FFFFFFFFFFFFFFFFFF#2b...Packet received: OK
 (gdb) tstop
 Sending packet: $QTStop#4b...Packet received: OK
 Sending packet: $QTNotes:#e8...Packet received: OK
 (gdb) actions
 Enter actions for tracepoint 1, one per line.
 End with a line saying just "end".
 >collect $reg
 >while-stepping 1
   >collect $reg
   >end
 >end
 (gdb) tstart
 Sending packet: $QTinit#59...Packet received: OK
 Sending packet: $QTDP:1:00000000004004d9:E:1:0-#a4...Packet received: OK
 Sending packet: $QTDP:-1:00000000004004d9:R03FFFFFFFFFFFFFFFFFF-#58...Packet received: OK
 Sending packet: $QTDP:-1:00000000004004d9:SR03FFFFFFFFFFFFFFFFFF#7e...Packet received: OK
 (gdb) tstop
 Sending packet: $QTStop#4b...Packet received: OK
 Sending packet: $QTNotes:#e8...Packet received: OK
 (gdb) actions
 Enter actions for tracepoint 1, one per line.
 End with a line saying just "end".
 >collect $regs
 >end
 (gdb) tstart
 Sending packet: $QTinit#59...Packet received: OK
 Sending packet: $QTDP:1:00000000004004d9:E:1:0-#a4...Packet received: OK
 Sending packet: $QTDP:-1:00000000004004d9:R03FFFFFFFFFFFFFFFFFF#2b...Packet received: OK

The last "$QTDP:1:00000000004004d9:E:1:0-#a4" should be "$QTDP:1:00000000004004d9:E:0:0-#a3".
In pseudo-diff:

  -$QTDP:1:00000000004004d9:E:1:0-#a4
  +$QTDP:1:00000000004004d9:E:0:0-#a3

A related issue is that the "commands" command actually supports
setting commands to a range of breakpoints/tracepoints at once.  But,
hacking "maint info breakpoints" to print t->step_count, reveals:

 (gdb) trace main
 Tracepoint 5 at 0x45a2ab: file ../../src/gdb/gdb.c, line 29.
 (gdb) trace main
 Note: breakpoint 5 also set at pc 0x45a2ab.
 Tracepoint 6 at 0x45a2ab: file ../../src/gdb/gdb.c, line 29.
 (gdb) commands 5-6
 Type commands for breakpoint(s) 5-6, one per line.
 End with a line saying just "end".
 > while-stepping 5
  >end
 > end
 (gdb) maint info breakpoints 5
 Num     Type           Disp Enb Address            What
 5       tracepoint     keep y   0x000000000045a2ab in main at ../../src/gdb/gdb.c:29 inf 1
         step_count=5
         ^^^^^^^^^^^^
         while-stepping 5
         end
         not installed on target
 (gdb) maint info breakpoints 6
 Num     Type           Disp Enb Address            What
 6       tracepoint     keep y   0x000000000045a2ab in main at ../../src/gdb/gdb.c:29 inf 1
         step_count=0
         ^^^^^^^^^^^^
         while-stepping 5
         end
         not installed on target
 (gdb)

that tracepoint 6 doesn't end up with the correct step_count.

The issue is that here:

 static void
 do_map_commands_command (struct breakpoint *b, void *data)
 {
  struct commands_info *info = data;

  if (info->cmd == NULL)
    {
      struct command_line *l;

      if (info->control != NULL)
	l = copy_command_lines (info->control->body_list[0]);
      else
	{
	  struct cleanup *old_chain;
	  char *str;

	  str = xstrprintf (_("Type commands for breakpoint(s) "
			      "%s, one per line."),
			    info->arg);

	  old_chain = make_cleanup (xfree, str);

	  l = read_command_lines (str,
				  info->from_tty, 1,
				  (is_tracepoint (b)
				   ? check_tracepoint_command : 0),
				  b);

	  do_cleanups (old_chain);
	}

      info->cmd = alloc_counted_command_line (l);
    }

validate_actionline is never called for tracepoints other than the
first (the copy_command_lines path).  Right below, we have:

  /* If a breakpoint was on the list more than once, we don't need to
     do anything.  */
  if (b->commands != info->cmd)
    {
      validate_commands_for_breakpoint (b, info->cmd->commands);
      incref_counted_command_line (info->cmd);
      decref_counted_command_line (&b->commands);
      b->commands = info->cmd;
      observer_notify_breakpoint_modified (b);
    }

And validate_commands_for_breakpoint looks like the right place to put
a call; if we reset step_count there too, we have a nice central fix
for the first issue as well, because trace_actions_command calls
breakpoint_set_commands that also calls
validate_commands_for_breakpoint.

We end up calling validate_actionline twice for the first tracepoint,
since read_command_lines calls it too, through
check_tracepoint_command, but that should be harmless.

2013-04-04  Pedro Alves  <palves@@redhat.com>
	    Hui Zhu  <hui@@codesourcery.com>

	* breakpoint.c (validate_commands_for_breakpoint): If validating a
	tracepoint, reset its STEP_COUNT and call validate_actionline.

2013-04-04  Stan Shebs  <stan@@codesourcery.com>
	    Pedro Alves  <palves@@redhat.com>

	* gdb.trace/Makefile.in (PROGS): Add actions-changed.
	* gdb.trace/actions-changed.c: New file.
	* gdb.trace/actions-changed.exp: New file.
	* lib/trace-support.exp (gdb_trace_setactions): Rename to ...
	(gdb_trace_setactions_command): ... this.  Add "actions_command"
	parameter, and handle it.
	(gdb_trace_setactions, gdb_trace_setcommands): New procedures.
@
text
@d9513 8
a9520 8
   modes of operations, selected by the PARSE_CONDITION_AND_THREAD
   parameter.  If non-zero, the function will parse arg, extracting
   breakpoint location, address and thread.  Otherwise, ARG is just
   the location of breakpoint, with condition and thread specified by
   the COND_STRING and THREAD parameters.  If INTERNAL is non-zero,
   the breakpoint number will be allocated from the internal
   breakpoint count.  Returns true if any breakpoint was created;
   false otherwise.  */
d9526 1
a9526 1
		   int parse_condition_and_thread,
d9644 1
a9644 1
      if (parse_condition_and_thread)
d9663 3
d9705 1
a9705 1
      if (parse_condition_and_thread)
@


1.748
log
@	Cleanup: remove unused - breakpoint, buildsym

	* breakpoint.c (parse_cond_to_aexpr): Remove unused 'old_chain'.
	(print_it_watchpoint): Remove unused 'bl'.
	(say_where): Remove unused 'uiout'.
	(bpstat_remove_breakpoint_callback): Remove unused 'uiout'.
	(bkpt_breakpoint_hit): Remove unused 'b'.
	(internal_bkpt_print_it): Remove unused 'uiout'.
	* buildsym.c (augment_type_symtab): Remove unused 'i'.

	Reference: http://sourceware.org/ml/gdb-patches/2013-03/msg01080.html
@
text
@d1145 9
d1156 8
a1163 4
	 while-stepping element, and that while-stepping's body has
	 valid tracing commands excluding nested while-stepping.  */
      struct command_line *c;
      struct command_line *while_stepping = 0;
d1181 2
@


1.747
log
@	* breakpoint.h (struct breakpoint): Add comment to
	extra_string indicating that this member is mallod'd.
	* breakpoint.c (base_breakpoint_dtor): Free extra_string.
@
text
@a2049 1
  struct cleanup *old_chain = NULL;
a2186 1
  struct cleanup *old_chain = NULL;
a10485 1
  const struct bp_location *bl;
a10492 1
  bl = bs->bp_location_at;
a12717 1
  struct ui_out *uiout = current_uiout;
a12985 2
  struct breakpoint *b = bl->owner;

a13178 1
  struct ui_out *uiout = current_uiout;
@


1.746
log
@Constify strings in tracepoint.c, lookup_cmd and the completers.

This is sort of a continuation of Keith's parse_exp_1 constification
patch.  It started out by undoing these bits:

  @@@@ -754,9 +754,12 @@@@ validate_actionline (char **line, struct
   	  tmp_p = p;
   	  for (loc = t->base.loc; loc; loc = loc->next)
   	    {
  -	      p = tmp_p;
  -	      exp = parse_exp_1 (&p, loc->address,
  +	      const char *q;
  +
  +	      q = tmp_p;
  +	      exp = parse_exp_1 (&q, loc->address,
   				 block_for_pc (loc->address), 1);
  +	      p = (char *) q;

and progressively making more things const upwards, fixing fallout,
rinse repeat, until GDB built again (--enable-targets=all).

That ended up constifying lookup_cmd/add_cmd and (lots of) friends,
and the completers.

I didn't try to constify the command hooks themselves, because I know
upfront there are commands that write to the command string argument,
and I think I managed to stop at a nice non-hacky split point already.

I think the only non-really-super-obvious changes are
tracepoint.c:validate_actionline, and tracepoint.c:trace_dump_actions.

The rest is just mostly about 'char *' => 'const char *', 'char **'=>
'const char **', and the occasional (e.g., deprecated_cmd_warning)
case of 'char **'=> 'const char *', where/when I noticed that nothing
actually cares about the pointer to pointer output.

Tested on x86_64 Fedora 17, native and gdbserver.

gdb/
2013-03-13  Pedro Alves  <palves@@redhat.com>

	* ada-lang.c (struct add_partial_datum) <text, text0, word>: Make
	fields const.
	(ada_make_symbol_completion_list): Make "text0" parameter const.
	* ax-gdb.c (agent_eval_command_one): Make "exp" parameter const.
	* breakpoint.c (condition_completer): Make "text" and "word"
	parameters const.  Adjust.
	(check_tracepoint_command): Adjust to validate_actionline
	prototype change.
	(catch_syscall_completer): Make "text" and "word" parameters
	const.
	* cli/cli-cmds.c (show_user): Make "comname" local const.
	(valid_command_p): Make "command" parameter const.
	(alias_command): Make "alias_prefix" and "command_prefix" locals
	const.
	* cli/cli-decode.c (add_cmd): Make "name" parameter const.
	(add_alias_cmd): Make "name" and "oldname" parameters const.
	Adjust.  No longer make copy of OLDNAME.
	(add_prefix_cmd, add_abbrev_prefix_cmd, add_set_or_show_cmd)
	(add_setshow_cmd_full, add_setshow_enum_cmd)
	(add_setshow_auto_boolean_cmd, add_setshow_boolean_cmd)
	(add_setshow_filename_cmd, add_setshow_string_cmd)
	(add_setshow_string_noescape_cmd)
	(add_setshow_optional_filename_cmd, add_setshow_integer_cmd)
	(add_setshow_uinteger_cmd, add_setshow_zinteger_cmd)
	(add_setshow_zuinteger_unlimited_cmd, add_setshow_zuinteger_cmd)
	(delete_cmd, add_info, add_info_alias, add_com, add_com_alias):
	Make "name" parameter const.
	(help_cmd): Rename "command" parameter to "arg".  New const local
	"command".
	(find_cmd): Make "command" parameter const.
	(lookup_cmd_1): Make "text" parameter pointer to const.  Adjust to
	deprecated_cmd_warning prototype change.
	(undef_cmd_error): Make "cmdtype" parameter const.
	(lookup_cmd): Make "line" parameter const.
	(deprecated_cmd_warning): Change type of "text" parameter to
	pointer to const char, from pointer to pointer to char.  Adjust.
	(lookup_cmd_composition): Make "text" parameter const.
	(complete_on_cmdlist, complete_on_enum): Make "text" and "word"
	parameters const.
	* cli/cli-decode.h (struct cmd_list_element) <name>: Make field
	const.
	* cli/cli-script.c (validate_comname): Make "tem" local const.
	(define_command): New const local "tem_c".  Use it in calls to
	lookup_cmd.
	(document_command): Make "tem" and "comfull" locals const.
	(show_user_1): Make "prefix" and "name" parameters const.
	* cli-script.h (show_user_1): Make "prefix" and "name" parameters
	const.
	* command.h (add_cmd, add_alias_cmd, add_prefix_cmd)
	(add_abbrev_prefix_cmd, completer_ftype, lookup_cmd, lookup_cmd_1)
	(deprecated_cmd_warning, lookup_cmd_composition, add_com)
	(add_com_alias, add_info, add_info_alias, complete_on_cmdlist)
	(complete_on_enum, add_setshow_enum_cmd)
	(add_setshow_auto_boolean_cmd, add_setshow_boolean_cmd)
	(add_setshow_filename_cmd, add_setshow_string_cmd)
	(add_setshow_string_noescape_cmd)
	(add_setshow_optional_filename_cmd, add_setshow_integer_cmd)
	(add_setshow_uinteger_cmd, add_setshow_zinteger_cmd)
	(add_setshow_zuinteger_cmd, add_setshow_zuinteger_unlimited_cmd):
	Change prototypes, constifying strings.
	* completer.c (noop_completer, filename_completer): Make "text"
	and "prefix" parameters const.
	(location_completer, expression_completer)
	(complete_line_internal): Make "text" and "prefix" parameters
	const and adjust.
	(command_completer, signal_completer): Make "text" and "prefix"
	parameters const.
	* completer.h (noop_completer, filename_completer)
	(expression_completer, location_completer, command_completer)
	(signal_completer): Change prototypes.
	* corefile.c (complete_set_gnutarget): Make "text" and "word"
	parameters const.
	* cp-abi.c (cp_abi_completer): Likewise.
	* expression.h (parse_expression_for_completion): Change
	prototype.
	* f-lang.c (f_make_symbol_completion_list): Make "text" and "word"
	parameters const.
	* infcmd.c (_initialize_infcmd): Make "cmd_name" local const.
	* infrun.c (handle_completer): Make "text" and "word" parameters
	const.
	* interps.c (interpreter_completer): Make "text" and "word"
	parameters const.
	* language.h (struct language_defn)
	<la_make_symbol_completion_list>: Make "text" and "word"
	parameters const.
	* parse.c (parse_exp_1): Move const hack to parse_exp_in_context.
	(parse_exp_in_context): Rename to ...
	(parse_exp_in_context_1): ... this.
	(parse_exp_in_context): Reimplement, with const hack from
	parse_exp_1.
	(parse_expression_for_completion): Make "string" parameter const.
	* printcmd.c (decode_format): Make "string_ptr" parameter pointer
	to pointer to const char.  Adjust.
	(print_command_1): Make "exp" parameter const.
	(output_command): Rename to ...
	(output_command_const): ... this.  Make "exp" parameter const.
	(output_command): Reimplement.
	(x_command): Adjust.
	(display_command): Rename "exp" parameter to "arg".  New "exp"
	local, const version of "arg".
	* python/py-auto-load.c (gdbpy_initialize_auto_load): Make
	"cmd_name" local const.
	* python/py-cmd.c (cmdpy_destroyer): Cast const away in xfree
	call.
	(cmdpy_completer): Make "text" and "word" parameters const.
	(gdbpy_parse_command_name): Make "prefix_text2" local const.
	* python/py-param.c (add_setshow_generic): Make "tmp_name" local
	const.
	* remote.c (_initialize_remote): Make "cmd_name" local const.
	* symtab.c (language_search_unquoted_string): Make "text" and "p"
	parameters const.  Adjust.
	(completion_list_add_fields): Make "sym_text", "text" and "word"
	parameters const.
	(struct add_name_data) <sym_text, text, word>: Make fields const.
	(default_make_symbol_completion_list_break_on): Make "text" and
	"word" parameters const.  Adjust locals.
	(default_make_symbol_completion_list)
	(make_symbol_completion_list, make_symbol_completion_type)
	(make_symbol_completion_list_fn): Make "text" and "word"
	parameters const.
	(make_file_symbol_completion_list): Make "text", "word" and
	"srcfile" parameters const.  Adjust locals.
	(add_filename_to_list): Make "text" and "word" parameters const.
	(struct add_partial_filename_data) <text, word>: Make fields
	const.
	(make_source_files_completion_list): Make "text" and "word"
	parameters const.
	* symtab.h (default_make_symbol_completion_list_break_on)
	(default_make_symbol_completion_list, make_symbol_completion_list)
	(make_symbol_completion_type enum type_code)
	(make_symbol_completion_list_fn make_file_symbol_completion_list)
	(make_source_files_completion_list): Change prototype.
	* top.c (execute_command): Adjust to pass pointer to pointer to
	const char to lookup_cmd, and to deprecated_cmd_warning prototype
	change.
	(set_verbose): Make "cmdname" local const.
	* tracepoint.c (decode_agent_options): Make "exp" parameter const,
	and adjust.
	(validate_actionline): Make "line" parameter a pointer to const
	char, and adjust.
	(encode_actions_1): Make "action_exp" local const, and adjust.
	(encode_actions): Adjust.
	(replace_comma): Delete.
	(trace_dump_actions): Make "action_exp" and "next_comma" locals
	const, and adjust.  Don't frob the action string while splitting
	it at commas.  Instead, make a copy of each split substring in
	turn.
	(trace_dump_command): Adjust to validate_actionline prototype
	change.
	* tracepoint.h (decode_agent_options, decode_agent_options)
	(encode_actions, validate_actionline): Change prototypes.
	* valprint.h (output_command): Delete declaration.
	(output_command_const): Declare.
	* value.c (function_destroyer): Cast const away in xfree call.
@
text
@d12791 1
@


1.745
log
@	* ada-lang.c (ada_read_renaming_var_value): Pass const
	pointer to expression string to parse_exp_1.
	(create_excep_cond_exprs): Likewise.
	* ax-gdb.c (agent_eval_command_one): Likewise.
	(maint_agent_printf_command): Likewise.
	Constify much of the string handling/parsing.
	* breakpoint.c (set_breakpoint_condition): Pass const
	pointer to expression string to parse_exp_1.
	(update_watchpoint): Likewise.
	(parse_cmd_to_aexpr): Constify string handling.
	Pass const pointer to parse_exp_1.
	(init_breakpoint_sal): Pass const pointer to parse_exp_1.
	(find_condition_and_thread): Likewise.
	Make TOK const.
	(watch_command_1): Make "arg" const.
	Constify string handling.
	Copy the expression string instead of changing the input
	string.
	(update_breakpoint_location): Pass const pointer to
	parse_exp_1.
	* eval.c (parse_and_eval_address): Make "exp" const.
	(parse_to_comma_and_eval): Make "expp" const.
	(parse_and_eval): Make "exp" const.
	* expression.h (parse_expression): Make argument const.
	(parse_exp_1): Make first argument const.
	* findcmd.c (parse_find_args): Treat "args" as const.
	* linespec.c (parse_linespec): Pass const pointer to
	linespec_expression_to_pc.
	(linespec_expression_to_pc): Make "exp_ptr" const.
	* parse.c (parse_exp_1): Make "stringptr" const.
	Make a copy of the expression to pass to parse_exp_in_context until
	this whole interface can be constified.
	(parse_expression): Make "string" const.
	* printcmd.c (ui_printf): Treat "arg" as const.
	Handle const strings.
	* tracepoint.c (validate_actionline): Pass const pointer to
	all calls to parse_exp_1.
	(encode_actions_1): Likewise.
	* value.h (parse_to_comma_and_eval): Make argument const.
	(parse_and_eval_address): Likewise.
	(parse_and_eval): Likewise.
	* varobj.c (varobj_create): Pass const pointer to parse_exp_1.
	(varobj_set_value): Likewise.
	* cli/cli-cmds.c (disassemble_command): Treat "arg" as const and
	constify string handling.
	Pass const pointers to parse_and_eval_address and
	parse_to_comman_and_eval.
	* cli/cli-utils.c (skip_to_space): Rename to ...
	(skip_to_space_const): ... this. Handle const strings.
	* cli/cli-utils.h (skip_to_space): Turn into macro which invokes
	skip_to_space_const.
	(skip_to_space_const): Declare.
	* common/format.c (parse_format_string): Make "arg" const.
	Handle const strings.
	* common/format.h (parse_format_string): Make "arg" const.
	* gdbserver/ax.c (ax_printf): Make "format" const.
	* python/python.c (gdbpy_parse_and_eval): Do not make a copy
	of the expression string.
@
text
@d994 2
a995 1
condition_completer (struct cmd_list_element *cmd, char *text, char *word)
d997 1
a997 1
  char *space;
d999 2
a1000 2
  text = skip_spaces (text);
  space = skip_to_space (text);
d1045 1
a1045 1
  text = skip_spaces (space);
d1268 1
a1268 1
  validate_actionline (&line, b);
d15088 1
a15088 1
                         char *text, char *word)
@


1.745.2.1
log
@tracepoint->step_count fixes

If a tracepoint's actions list includes a while-stepping action, and
then the actions are changed to a list without any while-stepping
action, the tracepoint's step_count will be left with a stale value.
For example:

 (gdb) trace subr
 Tracepoint 1 at 0x4004d9: file ../../../src/gdb/testsuite//actions-changed.c, line 31.
 (gdb) actions
 Enter actions for tracepoint 1, one per line.
 End with a line saying just "end".
 >collect $reg
 >end
 (gdb) set debug remote 1
 (gdb) tstart
 Sending packet: $QTinit#59...Packet received: OK
 Sending packet: $QTDP:1:00000000004004d9:E:0:0-#a3...Packet received: OK
 Sending packet: $QTDP:-1:00000000004004d9:R03FFFFFFFFFFFFFFFFFF#2b...Packet received: OK
 (gdb) tstop
 Sending packet: $QTStop#4b...Packet received: OK
 Sending packet: $QTNotes:#e8...Packet received: OK
 (gdb) actions
 Enter actions for tracepoint 1, one per line.
 End with a line saying just "end".
 >collect $reg
 >while-stepping 1
   >collect $reg
   >end
 >end
 (gdb) tstart
 Sending packet: $QTinit#59...Packet received: OK
 Sending packet: $QTDP:1:00000000004004d9:E:1:0-#a4...Packet received: OK
 Sending packet: $QTDP:-1:00000000004004d9:R03FFFFFFFFFFFFFFFFFF-#58...Packet received: OK
 Sending packet: $QTDP:-1:00000000004004d9:SR03FFFFFFFFFFFFFFFFFF#7e...Packet received: OK
 (gdb) tstop
 Sending packet: $QTStop#4b...Packet received: OK
 Sending packet: $QTNotes:#e8...Packet received: OK
 (gdb) actions
 Enter actions for tracepoint 1, one per line.
 End with a line saying just "end".
 >collect $regs
 >end
 (gdb) tstart
 Sending packet: $QTinit#59...Packet received: OK
 Sending packet: $QTDP:1:00000000004004d9:E:1:0-#a4...Packet received: OK
 Sending packet: $QTDP:-1:00000000004004d9:R03FFFFFFFFFFFFFFFFFF#2b...Packet received: OK

The last "$QTDP:1:00000000004004d9:E:1:0-#a4" should be "$QTDP:1:00000000004004d9:E:0:0-#a3".
In pseudo-diff:

  -$QTDP:1:00000000004004d9:E:1:0-#a4
  +$QTDP:1:00000000004004d9:E:0:0-#a3

A related issue is that the "commands" command actually supports
setting commands to a range of breakpoints/tracepoints at once.  But,
hacking "maint info breakpoints" to print t->step_count, reveals:

 (gdb) trace main
 Tracepoint 5 at 0x45a2ab: file ../../src/gdb/gdb.c, line 29.
 (gdb) trace main
 Note: breakpoint 5 also set at pc 0x45a2ab.
 Tracepoint 6 at 0x45a2ab: file ../../src/gdb/gdb.c, line 29.
 (gdb) commands 5-6
 Type commands for breakpoint(s) 5-6, one per line.
 End with a line saying just "end".
 > while-stepping 5
  >end
 > end
 (gdb) maint info breakpoints 5
 Num     Type           Disp Enb Address            What
 5       tracepoint     keep y   0x000000000045a2ab in main at ../../src/gdb/gdb.c:29 inf 1
         step_count=5
         ^^^^^^^^^^^^
         while-stepping 5
         end
         not installed on target
 (gdb) maint info breakpoints 6
 Num     Type           Disp Enb Address            What
 6       tracepoint     keep y   0x000000000045a2ab in main at ../../src/gdb/gdb.c:29 inf 1
         step_count=0
         ^^^^^^^^^^^^
         while-stepping 5
         end
         not installed on target
 (gdb)

that tracepoint 6 doesn't end up with the correct step_count.

The issue is that here:

 static void
 do_map_commands_command (struct breakpoint *b, void *data)
 {
  struct commands_info *info = data;

  if (info->cmd == NULL)
    {
      struct command_line *l;

      if (info->control != NULL)
	l = copy_command_lines (info->control->body_list[0]);
      else
	{
	  struct cleanup *old_chain;
	  char *str;

	  str = xstrprintf (_("Type commands for breakpoint(s) "
			      "%s, one per line."),
			    info->arg);

	  old_chain = make_cleanup (xfree, str);

	  l = read_command_lines (str,
				  info->from_tty, 1,
				  (is_tracepoint (b)
				   ? check_tracepoint_command : 0),
				  b);

	  do_cleanups (old_chain);
	}

      info->cmd = alloc_counted_command_line (l);
    }

validate_actionline is never called for tracepoints other than the
first (the copy_command_lines path).  Right below, we have:

  /* If a breakpoint was on the list more than once, we don't need to
     do anything.  */
  if (b->commands != info->cmd)
    {
      validate_commands_for_breakpoint (b, info->cmd->commands);
      incref_counted_command_line (info->cmd);
      decref_counted_command_line (&b->commands);
      b->commands = info->cmd;
      observer_notify_breakpoint_modified (b);
    }

And validate_commands_for_breakpoint looks like the right place to put
a call; if we reset step_count there too, we have a nice central fix
for the first issue as well, because trace_actions_command calls
breakpoint_set_commands that also calls
validate_commands_for_breakpoint.

We end up calling validate_actionline twice for the first tracepoint,
since read_command_lines calls it too, through
check_tracepoint_command, but that should be harmless.

2013-04-04  Pedro Alves  <palves@@redhat.com>
	    Hui Zhu  <hui@@codesourcery.com>

	* breakpoint.c (validate_commands_for_breakpoint): If validating a
	tracepoint, reset its STEP_COUNT and call validate_actionline.

2013-04-04  Stan Shebs  <stan@@codesourcery.com>
	    Pedro Alves  <palves@@redhat.com>

	* gdb.trace/Makefile.in (PROGS): Add actions-changed.
	* gdb.trace/actions-changed.c: New file.
	* gdb.trace/actions-changed.exp: New file.
	* lib/trace-support.exp (gdb_trace_setactions): Rename to ...
	(gdb_trace_setactions_command): ... this.  Add "actions_command"
	parameter, and handle it.
	(gdb_trace_setactions, gdb_trace_setcommands): New procedures.
@
text
@d1144 4
a1147 1
      struct tracepoint *t = (struct tracepoint *) b;
a1149 16

      /* Reset the while-stepping step count.  The previous commands
         might have included a while-stepping action, while the new
         ones might not.  */
      t->step_count = 0;

      /* We need to verify that each top-level element of commands is
	 valid for tracepoints, that there's at most one
	 while-stepping element, and that the while-stepping's body
	 has valid tracing commands excluding nested while-stepping.
	 We also need to validate the tracepoint action line in the
	 context of the tracepoint --- validate_actionline actually
	 has side effects, like setting the tracepoint's
	 while-stepping STEP_COUNT, in addition to checking if the
	 collect/teval actions parse and make sense in the
	 tracepoint's context.  */
a1166 2

	  validate_actionline (&c->line, b);
@


1.745.2.2
log
@2013-04-12  Pedro Alves  <palves@@redhat.com>
	    Hui Zhu  <hui@@codesourcery.com>

	* breakpoint.c (dprintf_re_set): New.
	(initialize_breakpoint_ops): Set dprintf_breakpoint_ops re_set
	to dprintf_re_set.

2013-04-12  Hui Zhu  <hui@@codesourcery.com>

	* gdb.base/Makefile.in (EXECUTABLES): Add dprintf-pending.
	(MISCELLANEOUS): Add dprintf-pendshr.sl.
	* gdb.base/dprintf-pending.c, gdb.base/dprintf-pending.exp: New.
@
text
@a13517 29
/* Dprintf breakpoint_ops methods.  */

static void
dprintf_re_set (struct breakpoint *b)
{
  breakpoint_re_set_default (b);

  /* This breakpoint could have been pending, and be resolved now, and
     if so, we should now have the extra string.  If we don't, the
     dprintf was malformed when created, but we couldn't tell because
     we can't extract the extra string until the location is
     resolved.  */
  if (b->loc != NULL && b->extra_string == NULL)
    error (_("Format string required"));

  /* 1 - connect to target 1, that can run breakpoint commands.
     2 - create a dprintf, which resolves fine.
     3 - disconnect from target 1
     4 - connect to target 2, that can NOT run breakpoint commands.

     After steps #3/#4, you'll want the dprintf command list to
     be updated, because target 1 and 2 may well return different
     answers for target_can_run_breakpoint_commands().
     Given absence of finer grained resetting, we get to do
     it all the time.  */
  if (b->extra_string != NULL)
    update_dprintf_command_list (b);
}

d16017 1
a16017 1
  ops->re_set = dprintf_re_set;
@


1.745.2.3
log
@2013-04-24  Hui Zhu  <hui@@codesourcery.com>

	PR gdb/15165

	* breakpoint.c (dprintf_print_recreate): New.
	(save_breakpoints): Let it not save dprintf commands.
	(initialize_breakpoint_ops): Set dprintf_print_recreate.

2013-04-24  Hui Zhu  <hui@@codesourcery.com>

	PR gdb/15165

	* gdb.base/save-bp.exp: Add test for dprintf.
@
text
@a13546 10
/* Implement the "print_recreate" breakpoint_ops method for dprintf.  */

static void
dprintf_print_recreate (struct breakpoint *tp, struct ui_file *fp)
{
  fprintf_unfiltered (fp, "dprintf %s%s", tp->addr_string,
		      tp->extra_string);
  print_recreate_thread (tp, fp);
}

d15636 1
a15636 1
    if (tp->type != bp_dprintf && tp->commands)
d16050 1
a16050 1
  ops->print_recreate = dprintf_print_recreate;
@


1.745.2.4
log
@2013-04-25  Hui Zhu  <hui@@codesourcery.com>

	PR gdb/15293

	* breakpoint.c (bpstat_what): Add BPSTAT_WHAT_SINGLE to bp_dprintf.

2013-04-25  Hui Zhu  <hui@@codesourcery.com>

	PR gdb/15293

	* gdb.base/dprintf.exp: Add ignore command.
@
text
@d5537 1
a5537 4
	  if (bs->stop)
	    this_action = BPSTAT_WHAT_STOP_SILENT;
	  else
	    this_action = BPSTAT_WHAT_SINGLE;
@


1.745.2.5
log
@2013-04-25  Hui Zhu  <hui@@codesourcery.com>

	* breakpoint.c (build_target_command_list): Change loc->cond_bytecode
	to loc->cmd_bytecode.
@
text
@d2351 1
a2351 1
	      if (loc->cmd_bytecode == NULL)
d2354 2
a2355 2
	      free_agent_expr (loc->cmd_bytecode);
	      loc->cmd_bytecode = NULL;
@


1.745.2.6
log
@gdb/
2013-05-07  Sergio Durigan Junior  <sergiodj@@redhat.com>

	PR breakpoints/15413:
	* breakpoint.c (condition_completer): Simplify the code to
	disconsider multiple locations of breakpoints when completing the
	"condition" command.

gdb/testsuite/
2013-05-07  Sergio Durigan Junior  <sergiodj@@redhat.com>

	PR breakpoints/15413:
	* gdb.base/pending.exp: Add test for completion of the "condition"
	command for pending breakpoints.
	* gdb.linespec/linespec.ex: Add test for completion of the
	"condition" command when dealing with multiple locations.
@
text
@d1018 14
a1031 2
	{
	  char number[50];
d1033 2
a1034 1
	  xsnprintf (number, sizeof (number), "%d", b->number);
d1036 3
a1038 3
	  if (strncmp (number, text, len) == 0)
	    VEC_safe_push (char_ptr, result, xstrdup (number));
	}
@


1.745.2.7
log
@2013-06-26  Yao Qi  <yao@@codesourcery.com>
	    Hui Zhu  <hui@@codesourcery.com>
	    Pedro Alves  <palves@@redhat.com>

	PR breakpoints/15075
	PR breakpoints/15434
	* breakpoint.c (bpstat_stop_status): Call
	b->ops->after_condition_true.
	(update_dprintf_command_list): Don't append "continue" command
	to the command list of dprintf breakpoint.
	(base_breakpoint_after_condition_true): New function.
	(base_breakpoint_ops): Add base_breakpoint_after_condition_true.
	(dprintf_after_condition_true): New function.
	(initialize_breakpoint_ops): Set dprintf_after_condition_true.
	* breakpoint.h (breakpoint_ops): Add after_condition_true.

2013-06-26  Yao Qi  <yao@@codesourcery.com>
	    Hui Zhu  <hui@@codesourcery.com>
	    Pedro Alves  <palves@@redhat.com>

	PR breakpoints/15075
	PR breakpoints/15434
	* gdb.base/dprintf-next.c: New file.
	* gdb.base/dprintf-next.exp: New file.
	* gdb.base/dprintf-non-stop.c: New file.
	* gdb.base/dprintf-non-stop.exp: New file.
	* gdb.base/dprintf.exp: Don't check "continue" in the output
	of "info breakpoints".
	* gdb.mi/mi-breakpoint-changed.exp (test_insert_delete_modify):
	Don't check "continue" in script field.
@
text
@a5297 2

	      b->ops->after_condition_true (bs);
d8955 1
a8955 1
  /* Manufacture a printf sequence.  */
d8957 11
a8967 2
    struct command_line *printf_cmd_line
      = xmalloc (sizeof (struct command_line));
d8973 1
a8973 1
    printf_cmd_line->next = NULL;
a12930 8
/* The default "after_condition_true" method.  */

static void
base_breakpoint_after_condition_true (struct bpstats *bs)
{
  /* Nothing to do.   */
}

d12950 1
a12950 2
  base_breakpoint_explains_signal,
  base_breakpoint_after_condition_true,
a13546 38
/* Implement the "after_condition_true" breakpoint_ops method for
   dprintf.

   dprintf's are implemented with regular commands in their command
   list, but we run the commands here instead of before presenting the
   stop to the user, as dprintf's don't actually cause a stop.  This
   also makes it so that the commands of multiple dprintfs at the same
   address are all handled.  */

static void
dprintf_after_condition_true (struct bpstats *bs)
{
  struct cleanup *old_chain;
  struct bpstats tmp_bs = { NULL };
  struct bpstats *tmp_bs_p = &tmp_bs;

  /* dprintf's never cause a stop.  This wasn't set in the
     check_status hook instead because that would make the dprintf's
     condition not be evaluated.  */
  bs->stop = 0;

  /* Run the command list here.  Take ownership of it instead of
     copying.  We never want these commands to run later in
     bpstat_do_actions, if a breakpoint that causes a stop happens to
     be set at same address as this dprintf, or even if running the
     commands here throws.  */
  tmp_bs.commands = bs->commands;
  bs->commands = NULL;
  old_chain = make_cleanup_decref_counted_command_line (&tmp_bs.commands);

  bpstat_do_actions_1 (&tmp_bs_p);

  /* 'tmp_bs.commands' will usually be NULL by now, but
     bpstat_do_actions_1 may return early without processing the whole
     list.  */
  do_cleanups (old_chain);
}

a16050 1
  ops->after_condition_true = dprintf_after_condition_true;
@


1.745.2.8
log
@This fixes PR cli/15603.

The bug here is that when a software watchpoint is being used, gdb
will stop responding to C-c.  This is a regression caused by the
"catch signal" patch.

The problem is that software watchpoints always end up on the bpstat
list.  However, this makes bpstat_explains_signal return
BPSTAT_SIGNAL_HIDE, causing infrun to think that the signal is not a
"random signal".

The fix is to change bpstat_explains_signal to handle this better.  I
chose to do it in a "clean API" way, by passing the signal value to
bpstat_explains_signal and then adding an explains_signal method for
watchpoints, which handles the specifics.

Built and regtested on x86-64 Fedora 18.
New test case included.

	* break-catch-sig.c (signal_catchpoint_explains_signal): Add 'sig'
	argument.
	* breakpoint.c (bpstat_explains_signal): Add 'sig' argument.
	Special case signals other than GDB_SIGNAL_TRAP.
	(explains_signal_watchpoint): New function.
	(base_breakpoint_explains_signal): Add 'sig' argument.
	(initialize_breakpoint_ops): Set 'explains_signal' method for
	watchpoints.
	* breakpoint.h (struct breakpoint_ops) <explains_signal>: Add
	signal argument.
	(bpstat_explains_signal): Likewise.
	* infrun.c (handle_syscall_event, handle_inferior_event): Update.

	* gdb.base/random-signal.c: New file.
	* gdb.base/random-signal.exp: New file.
@
text
@d4152 1
a4152 1
bpstat_explains_signal (bpstat bsp, enum gdb_signal sig)
d4160 1
a4160 1
      enum bpstat_signal_value newval;
d4162 2
a4163 12
      if (bsp->breakpoint_at == NULL)
	{
	  /* A moribund location can never explain a signal other than
	     GDB_SIGNAL_TRAP.  */
	  if (sig == GDB_SIGNAL_TRAP)
	    newval = BPSTAT_SIGNAL_HIDE;
	  else
	    newval = BPSTAT_SIGNAL_NO;
	}
      else
	newval = bsp->breakpoint_at->ops->explains_signal (bsp->breakpoint_at,
							   sig);
a10641 14
/* Implement the "explains_signal" breakpoint_ops method for
   watchpoints.  */

static enum bpstat_signal_value
explains_signal_watchpoint (struct breakpoint *b, enum gdb_signal sig)
{
  /* A software watchpoint cannot cause a signal other than
     GDB_SIGNAL_TRAP.  */
  if (b->type == bp_watchpoint && sig != GDB_SIGNAL_TRAP)
    return BPSTAT_SIGNAL_NO;

  return BPSTAT_SIGNAL_HIDE;
}

d12919 1
a12919 1
base_breakpoint_explains_signal (struct breakpoint *b, enum gdb_signal sig)
a15986 1
  ops->explains_signal = explains_signal_watchpoint;
@


1.744
log
@	* breakpoint.c (catch_syscall_split_args): Use skip_spaces.
	(trace_pass_command): Likewise.
	* cli/cli-cmds.c: Include cli/cli-utils.h.
	(source_command): Use skip-spaces.
	(disassemble_command): Likewise.
	* findcmd.c: Include cli/cli-utils.h.
	(parse_find_args): Use skip_spaces.
	* go32-nat.c: Include cli/cli-utils.h.
	(go32_sldt): Use skip_spaces.
	(go32_sgdt): Likewise.
	(go32_sidt): Likewise.
	(go32_pde): Likewise.
	(go32_pte): Likewise.
	(go32_pte_for_address): Likewise.
	* infcmd.c: Include cli/cli-utils.h.
	(registers_info): Use skip_spaces.
	* linux-tdep.c (read_mapping): Use skip_spaces_const.
	(linux_info_proc): Likewise.
	* linux-thread-db.c: Include cli/cli-utils.h.
	(info_auto_load_libthread_db): Use skip_spaces_const.
	* m32r-rom.c: Include cli/cli-utils.h.
	(m32r_upload_command): Use skip_spaces.
	* maint.c: Include cli/cli-utils.h.
	(maintenance_translate_address): Use skip_spaces.
	* mi/mi-parse.c: Include cli/cli-utils.h.
	(mi_parse_argv): Use skip_spaces.
	(mi_parse): Likewise.
	* minsyms.c: Include cli/cli-utils.h.
	(msymbol_hash_iw): Use skip_spaces_const.
	* objc-lang.c: Include cli/cli-utils.h.
	(parse_selector): Use skip_spaces.
	(parse_method): Likewise.
	* python/python.c: Include cli/cli-utils.h.
	(python_interactive_command)[HAVE_PYTHON]: Use skip_spaces.
	(python_command)[HAVE_PYTHON]: Likewise.
	(python_interactive_command)[!HAVE_PYTHON]: Likewise.
	* remote-m32r-sdi.c: Include cli/cli-utils.h.
	(m32r_load): Use skip_spaces.
	* serial.c: Include cli/cli-utils.h.
	(serial_open): Use skip_spaces_const.
	* stack.c: Include cli/cli-utils.h.
	(parse_frame_specification_1): Use skip_spaces_const.
	* symfile.c: Include cli/cli-utils.h.
	(set_ext_lang_command): Use skip_spaces.
	* symtab.c: Include cli/cli-utils.h.
	(rbreak_command): Use skip_spaces.
	* thread.c (thread_name_command): Use skip_spaces.
	* tracepoint.c (validate_actionline): Use skip_spaces.
	(encode_actions_1): Likewise.
	(trace_find_range_command): Likewise.
	(trace_find_outside_command): Likewise.
	(trace_dump_actions): Likewise.
@
text
@d953 1
a953 1
      char *arg = exp;
d1762 1
a1762 1
      char *s;
d2189 2
a2190 2
  char *cmdrest;
  char *format_start, *format_end;
d2202 1
a2202 1
  cmdrest = skip_spaces (cmdrest);
d2218 1
a2218 1
  cmdrest = skip_spaces (cmdrest);
d2225 1
a2225 1
  cmdrest = skip_spaces (cmdrest);
d2235 1
a2235 1
      char *cmd1;
d9106 2
a9107 1
	  char *arg = b->cond_string;
d9378 1
a9378 1
find_condition_and_thread (char *tok, CORE_ADDR pc,
d9389 1
a9389 1
      char *end_tok;
d9391 2
a9392 2
      char *cond_start = NULL;
      char *cond_end = NULL;
d9394 1
a9394 1
      tok = skip_spaces (tok);
d9402 1
a9402 1
      end_tok = skip_to_space (tok);
d9421 1
a9421 2
	  tmptok = tok;
	  *thread = strtol (tok, &tok, 0);
d9426 1
d9433 1
a9433 2
	  tmptok = tok;
	  *task = strtol (tok, &tok, 0);
d9438 1
d10840 1
a10840 1
watch_command_1 (char *arg, int accessflag, int from_tty,
d10849 3
a10851 3
  char *exp_start = NULL;
  char *exp_end = NULL;
  char *tok, *end_tok;
d10853 2
a10854 2
  char *cond_start = NULL;
  char *cond_end = NULL;
d10863 2
d10869 3
a10871 1
      char *value_start;
d10875 1
a10875 1
      for (tok = arg + strlen (arg) - 1; tok > arg; tok--)
d10945 1
a10945 1
	  *tok = '\0';
d10948 2
d10951 3
a10953 1
  /* Parse the rest of the arguments.  */
d10955 3
a10957 1
  exp_start = arg;
d11003 2
a11004 2
  tok = skip_spaces (arg);
  end_tok = skip_to_space (tok);
d11156 1
d14051 1
a14051 1
	  char *s;
@


1.743
log
@breakpoint.c: fix -Wpointer-sign

$ make WERROR_CFLAGS="-Wpointer-sign -Werror" breakpoint.o 2>&1 1>/dev/null
../../src/gdb/breakpoint.c: In function ‘breakpoint_xfer_memory’:
../../src/gdb/breakpoint.c:1578:2: error: pointer targets in passing argument 3 of ‘gdbarch_breakpoint_from_pc’ differ in signedness [-Werror=pointer-sign]
In file included from ../../src/gdb/defs.h:644:0,
                 from ../../src/gdb/breakpoint.c:20:
../../src/gdb/gdbarch.h:495:25: note: expected ‘int *’ but argument is of type ‘unsigned int *’

target_info.placed_size is an 'int', and gdbarch_breakpoint_from_pc
takes an int too.

gdb/
2013-03-07  Pedro Alves  <palves@@redhat.com>

	* breakpoint.c.c (breakpoint_xfer_memory): Change type of local to
	int.
@
text
@d11771 1
a11771 2
      while (isspace (*arg))
	arg++;
d15372 1
a15372 3
  while (*args && isspace ((int) *args))
    args++;

@


1.742
log
@gdb/
	* breakpoint.c (add_location_to_breakpoint): Insert the location with
	ADDRESS sorted.
@
text
@d1570 1
a1570 1
	unsigned placed_size = bl->target_info.placed_size;
@


1.741
log
@gdb/
	* ada-lang.c (user_select_syms): Replace symtab->filename refererences
	by symtab_to_filename_for_display calls.
	* breakpoint.c (print_breakpoint_location, resolve_sal_pc): Likewise.
	(clear_command): New variable sal_fullname, initialize it.  Replace
	compare_filenames_for_search by filename_cmp with sal_fullname.
	(say_where, update_static_tracepoint): Replace symtab->filename
	refererences by symtab_to_filename_for_display calls.
	* cli/cli-cmds.c (edit_command, list_command, ambiguous_line_spec):
	Likewise.
	* dwarf2read.c: Include source.h.
	(fixup_go_packaging): Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.
	* linespec.c (add_sal_to_sals): Rename variable filename to fullname.
	Replace symtab->filename refererences by symtab_to_filename_for_display
	calls.
	(create_sals_line_offset, convert_linespec_to_sals): New variable
	fullname, initialize it, replace symtab->filename reference by the
	variable.
	* linux-fork.c: Include source.h.
	(info_checkpoints_command): Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.
	* macroscope.c (sal_macro_scope): Replace symtab->filename refererences
	by symtab_to_filename_for_display calls.
	* mdebugread.c: Include source.h.
	(psymtab_to_symtab_1): Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.
	* mi/mi-cmd-file.c (mi_cmd_file_list_exec_source_file)
	(mi_cmd_file_list_exec_source_files): Likewise.
	* printcmd.c: Include source.h.
	(build_address_symbolic): Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.
	* psymtab.c (partial_map_symtabs_matching_filename)
	(read_psymtabs_with_fullname): Call compare_filenames_for_search also
	with psymtab_to_fullname.
	* python/py-symtab.c (stpy_str): Replace symtab->filename refererences
	by symtab_to_filename_for_display calls.
	(stpy_get_filename): New variable filename, initialize it, use instead
	of symtab->filename refererences.
	(salpy_str): Make variable filename const char *.  Replace
	symtab->filename refererences by symtab_to_filename_for_display calls.
	* skip.c: Include source.h and filenames.h.
	(skip_file_command): Remove const from the symtab variable.  Replace
	symtab->filename refererences by symtab_to_fullname call.
	(function_name_is_marked_for_skip): New variables searched_for_fullname
	and fullname.  Use them to search also with symtab's fullname.
	* source.c (find_source_lines): Replace symtab->filename refererences
	by symtab_to_filename_for_display calls.
	(print_source_lines_base): New variable filename, use it instead of
	symtab->filename.  Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.
	(line_info, forward_search_command): Replace symtab->filename
	refererences by symtab_to_filename_for_display calls.
	(reverse_search_command): Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.  New variable filename for it.
	* stack.c (frame_info): Likewise.
	* symmisc.c: Include source.h.
	(dump_objfile, dump_symtab_1, maintenance_print_symbols)
	(maintenance_info_symtabs): Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.
	* symtab.c (iterate_over_some_symtabs): Call
	compare_filenames_for_search also with symtab_to_fullname.
	(lookup_symbol_aux_quick, basic_lookup_transparent_type_quick): Replace
	symtab->filename refererences by symtab_to_filename_for_display calls.
	(find_line_symtab): Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.
	(file_matches): Replace filename_cmp by compare_filenames_for_search.
	(print_symbol_info): Make the last parameter const char *.  New
	variable s_filename.  Use it in the function.
	(symtab_symbol_info): Make the last_filename variable const char *.
	Replace symtab->filename refererences by symtab_to_filename_for_display
	calls.
	(rbreak_command): New variable fullname.  Use it.  Replace
	symtab->filename refererence by symtab_to_filename_for_display call.
	* tracepoint.c (set_traceframe_context, trace_find_line_command)
	(print_one_static_tracepoint_marker): Replace symtab->filename
	refererences by symtab_to_filename_for_display calls.
	* tui/tui-source.c (tui_set_source_content): New variables filename and
	s_filename.  Replace symtab->filename refererences by this variable.
	Replace other symtab->filename refererences by
	symtab_to_filename_for_display calls.
@
text
@d8830 1
d8832 2
a8833 1
  for (tmp = &(b->loc); *tmp != NULL; tmp = &((*tmp)->next))
d8835 1
@


1.740
log
@gdb/
	Code cleanup.
	* breakpoint.c (clear_command): Remove variable is_abs, unify the
	call of filename_cmp with compare_filenames_for_search.
	* dwarf2read.c (dw2_map_symtabs_matching_filename): Remove variable
	is_abs, unify the call of FILENAME_CMP with
	compare_filenames_for_search.  New gdb_asserts for real_path and name.
	Unify the call of compare_filenames_for_search with FILENAME_CMP.
	* psymtab.c (partial_map_symtabs_matching_filename): Likewise.
	* symfile.h (struct quick_symbol_functions): Extend the comment for
	map_symtabs_matching_filename.
	* symtab.c (compare_filenames_for_search): Remove the function comment
	relative path requirement.  Handle absolute filenames, with a comment.
	(iterate_over_some_symtabs): Remove variable is_abs, unify the call of
	FILENAME_CMP with compare_filenames_for_search.  New gdb_asserts for
	real_path and name.  Unify the call of compare_filenames_for_search
	with FILENAME_CMP.
	(iterate_over_symtabs): New gdb_assert on REAL_PATH.

gdb/testsuite/
	* gdb.mi/mi-fullname-deleted.exp: Use double last slash for $srcfileabs.
	(compare_filenames_for_search does not match)
	(compare_filenames_for_search does match): New tests.
@
text
@d5710 2
a5711 1
      ui_out_field_string (uiout, "file", loc->symtab->filename);
d5713 1
a5713 1
      
d9774 1
a9774 1
	       sal->line, sal->symtab->filename);
d11945 2
d11960 2
d11985 1
a11985 1
		      && sal.symtab != NULL
d11987 4
a11990 6
		      && loc->line_number == sal.line)
		    {
		      if (compare_filenames_for_search (loc->symtab->filename,
							sal.symtab->filename))
			line_match = 1;
		    }
d12732 2
a12733 1
			     b->loc->symtab->filename, b->loc->line_number);
d13932 2
a13933 1
	  ui_out_field_string (uiout, "file", sal2.symtab->filename);
d13951 1
a13951 1
				       sal2.symtab->filename,
@


1.739
log
@gdb/
	Code cleanup.
	* breakpoint.c (print_breakpoint_location): Replace bp_location field
	source_file references by symtab field references.  Remove variables
	sal and fullname.
	(momentary_breakpoint_from_master, add_location_to_breakpoint):
	(clear_command, say_where): Replace bp_location field source_file
	references by symtab field references.
	(bp_location_dtor): Remove the source_file reference.
	(update_static_tracepoint): Replace bp_location field source_file
	references by symtab field references.
	(breakpoint_free_objfile): New function.
	* breakpoint.h (struct bp_location): Extend the comment for line_number.
	Replace the field source_file by field symtab, extend its comment.
	(breakpoint_free_objfile): New declaration.
	* objfiles.c (free_objfile): Call breakpoint_free_objfile.
	* tui/tui-winsource.c (tui_update_breakpoint_info): Replace bp_location
	field source_file references by symtab field references.
@
text
@a11943 2
      int is_abs;

a11956 1
      is_abs = sal.symtab == NULL ? 1 : IS_ABSOLUTE_PATH (sal.symtab->filename);
d11984 2
a11985 6
		      if (filename_cmp (loc->symtab->filename,
					sal.symtab->filename) == 0)
			line_match = 1;
		      else if (!IS_ABSOLUTE_PATH (sal.symtab->filename)
			       && compare_filenames_for_search (loc->symtab->filename,
								sal.symtab->filename))
@


1.738
log
@All annotate_breakpoints_changed calls are along-side
observer_notify_breakpoints_changed calls.  All, except the
init_raw_breakpoint one.  But that one is actually wrong.  The
breakpoint is being constructed at that point, and hasn't been placed
on the breakpoint chain yet.  It would be better placed in
install_breakpoint, and I actually started out that way.  But once the
annotate_breakpoints_changed are parallel to the observer calls, we
can fully move annotations to observers too.

One issue is that this changes the order of annotations a bit.
Before, we'd emit the annotation, and after call "mention()" on the
breakpoint (which prints the breakpoint number, etc.).  But, we call
the observers _after_ mention is called, so the annotation output will
change a little:

void
install_breakpoint (int internal, struct breakpoint *b, int update_gll)
{
  add_to_breakpoint_chain (b);
  set_breakpoint_number (internal, b);
  if (is_tracepoint (b))
    set_tracepoint_count (breakpoint_count);
  if (!internal)
    mention (b);
  observer_notify_breakpoint_created (b);

  if (update_gll)
    update_global_location_list (1);
}

I believe this order doesn't really matter (the frontend needs to wait
for the prompt anyway), so I just adjust the expected output in the
tests.  Emacs in annotations mode doesn't seem to complain.  Couple
that with the previous patch that suppressed duplicated annotations,
and, the fact that some annotations calls were actually missing (were
we do have observer calls), more changes to the tests are needed
anyway.

Tested on x86_64 Fedora 17.

gdb/
2013-01-22  Pedro Alves  <palves@@redhat.com>

	* annotate.c (annotate_breakpoints_changed): Rename to ...
	(annotate_breakpoints_invalid): ... this.  Make static.
	(breakpoint_changed): Adjust.
	(_initialize_annotate): Always install the observers.  Install a
	"breakpoint_created" observer.
	* annotate.h (annotate_breakpoints_changed): Delete declaration.
	* breakpoint.c (set_breakpoint_condition)
	(breakpoint_set_commands, do_map_commands_command)
	(init_raw_breakpoint, clear_command, set_ignore_count)
	(enable_breakpoint_disp): No longer call
	annotate_breakpoints_changed.

gdb/testsuite/
2013-01-22  Pedro Alves  <palves@@redhat.com>

	* gdb.base/annota1.exp (breakpoints_invalid): New variable.
	Adjust tests to breakpoints-invalid changes.
	* gdb.cp/annota2.exp (breakpoints_invalid, frames_invalid): New
	variables.
	Adjust tests to breakpoints-invalid changes.
@
text
@d5697 1
a5697 1
  else if (loc && loc->source_file)
d5710 1
a5710 1
      ui_out_field_string (uiout, "file", loc->source_file);
d5714 2
a5715 6
	{
	  struct symtab_and_line sal = find_pc_line (loc->address, 0);
	  const char *fullname = symtab_to_fullname (sal.symtab);
	  
	  ui_out_field_string (uiout, "fullname", fullname);
	}
a8754 4

  if (orig->loc->source_file != NULL)
    copy->loc->source_file = xstrdup (orig->loc->source_file);

d8756 1
a8840 3

  if (sal->symtab != NULL)
    loc->source_file = xstrdup (sal->symtab->filename);
d8842 1
d11982 1
a11982 1
		      && loc->source_file != NULL
d11987 1
a11987 1
		      if (filename_cmp (loc->source_file,
d11991 1
a11991 1
			       && compare_filenames_for_search (loc->source_file,
d12724 1
a12724 1
      if (opts.addressprint || b->loc->source_file == NULL)
d12730 1
a12730 1
      if (b->loc->source_file)
d12736 1
a12736 1
			     b->loc->source_file, b->loc->line_number);
a12763 1
  xfree (self->source_file);
d13949 1
a13949 6

	  xfree (b->loc->source_file);
	  if (sym)
	    b->loc->source_file = xstrdup (sal2.symtab->filename);
	  else
	    b->loc->source_file = NULL;
d15786 12
@


1.737
log
@There's code in annotate.c and breakpoint.c that is supposed to
suppress multiple breakpoints-invalid annotations when the ignore
count of a breakpoint changes, up until the target actually stops.

But, the code is bogus:

void
annotate_breakpoints_changed (void)
{
  if (annotation_level == 2)
    {
      target_terminal_ours ();
      printf_unfiltered (("\n\032\032breakpoints-invalid\n"));
      if (ignore_count_changed)
	ignore_count_changed = 0;   /* Avoid multiple break annotations.  */
    }
}

The "ignore_count_changed" flag isn't actually guarding the output of
the annotation at all.  It would have been better written something
like:

void
annotate_breakpoints_changed (void)
{
  if (annotation_level == 2 && !ignore_count_changed)
    {
      target_terminal_ours ();
      printf_unfiltered (("\n\032\032breakpoints-invalid\n"));
      ignore_count_changed = 0;   /* Avoid multiple break annotations.  */
    }
}

but, it wasn't.  AFAICS, that goes all the way back to the original
patch'es submission and check in, at
<http://sourceware.org/ml/gdb-patches/1999-q4/msg00106.html>.  I
looked a tar of HP's wdb from 1999, and even though that contains
local changes in the annotate code, this suppression seems borked
there too to me.

The original patch added a test to supposedly exercise this
suppression, but, it actually doesn't.  It merely tests that
"breakpoints-invalid" is output after "stopped", but doesn't check
whether the duplicates supression actually works (IOW, check that only
_one_ annotation is seen).  I was going to simply delete the tests
too, but a following patch will eliminate the duplicates in a
different way (which I needed for a different reason), so instead, I'm
making the tests actually fail if a duplicate annotation is seen.

Worry not, the test doesn't actually fail!  The reason is that
breakpoint.c does:

      else if (b->ignore_count > 0)
	{
	  b->ignore_count--;
	  annotate_ignore_count_change ();
	  bs->stop = 0;
	  /* Increase the hit count even though we don't stop.  */
	  ++(b->hit_count);
	  observer_notify_breakpoint_modified (b);
	}

where the annotate_ignore_count_change call is meant to inform the
"breakpoint_modified" annotation observer to ignore the notification.
All sounds good.  But, the trouble is that nowadays annotate.c only
installs the observers if GDB is started with annotations enabled with
a command line option (gdb --annotate=2):

void
_initialize_annotate (void)
{
  if (annotation_level == 2)
    {
      observer_attach_breakpoint_deleted (breakpoint_changed);
      observer_attach_breakpoint_modified (breakpoint_changed);
    }
}

and annota1.exp, to enable annotations, starts GDB normally, and
afterwards does "set annotate 2", so the observers aren't installed
when annota1.exp is run, and therefore changing the ignore count isn't
triggering any annotation at all...

gdb/
2013-01-22  Pedro Alves  <palves@@redhat.com>

	* annotate.c (ignore_count_changed): Delete.
	(annotate_breakpoints_changed): Don't clear ignore_count_changed.
	(annotate_ignore_count_change): Delete.
	(annotate_stopped): Don't emit a delayed breakpoints-changed
	annotation.
	* annotate.h (annotate_ignore_count_change): Delete.
	* breakpoint.c (bpstat_check_breakpoint_conditions): Don't call
	annotate_ignore_count_change.

gdb/testsuite/
2013-01-22  Pedro Alves  <palves@@redhat.com>

	* gdb.base/annota1.exp (annotate ignore count change): Add
	expected output for failure case.
@
text
@a987 1
  annotate_breakpoints_changed ();
a1218 1
  annotate_breakpoints_changed ();
a1334 1
      annotate_breakpoints_changed ();
a7071 2

  annotate_breakpoints_changed ();
a12050 1
  annotate_breakpoints_changed ();
a14437 1
      annotate_breakpoints_changed ();
d14702 1
a14702 2
  annotate_breakpoints_changed ();
  
@


1.736
log
@2013-01-21  Marc Khouzam  <marc.khouzam@@ericsson.com>

        * breakpoint.c (print_one_breakpoint_location): Add MI
        field 'thread-groups' when printing a breakpoint.
        (output_thread_groups): New function.

2013-01-21  Marc Khouzam  <marc.khouzam@@ericsson.com>

        * gdb.texinfo (GDB/MI Breakpoint Commands): Document new
        'thread-groups' field when printing a breakpoint in MI.

2013-01-21  Marc Khouzam  <marc.khouzam@@ericsson.com>

        * gdb.mi/mi-break.exp: Expect new 'thread-groups' field.
        * gdb.mi/mi-nsmoribund.exp: Expect new 'thread-groups' field.
        Also handle 'thread' field.
        * gdb.mi/mi-simplerun.exp: Expect new 'thread-groups' field.
        * gdb.mi/mi-watch.exp: Ditto.
        * lib/mi-support.exp: Ditto.
@
text
@a5139 1
	  annotate_ignore_count_change ();
@


1.735
log
@2013-01-03  Pedro Alves  <palves@@redhat.com>
	    Tom Tromey  <tromey@@redhat.com>
	PR cli/7221:
	* NEWS: Add "catch signal".
	* breakpoint.c (base_breakpoint_ops): No longer static.
	(bpstat_explains_signal): New function.
	(init_catchpoint): No longer static.
	(base_breakpoint_explains_signal): New function.
	(base_breakpoint_ops): Initialize new field.
	* breakpoint.h (enum bpstat_signal_value): New.
	(struct breakpoint_ops) <explains_signal>: New field.
	(bpstat_explains_signal): Remove macro, declare as function.
	(base_breakpoint_ops, init_catchpoint): Declare.
	* break-catch-sig.c: New file.
	* inferior.h (signal_catch_update): Declare.
	* infrun.c (signal_catch): New global.
	(handle_syscall_event): Update for change to
	bpstat_explains_signal.
	(handle_inferior_event): Likewise.  Always handle random signals
	via bpstats.
	(signal_cache_update): Check signal_catch.
	(signal_catch_update): New function.
	(_initialize_infrun): Initialize signal_catch.
	* Makefile.in (SFILES): Add break-catch-sig.c.
	(COMMON_OBS): Add break-catch-sig.o.
gdb/doc
	* gdb.texinfo (Set Catchpoints): Document "catch signal".
	(Signals): Likewise.
gdb/testsuite
	* gdb.base/catch-signal.c: New file.
	* gdb.base/catch-signal.exp: New file.
@
text
@d5808 45
d6004 1
a6004 11
  /* For backward compatibility, don't display inferiors unless there
     are several.  */
  if (loc != NULL
      && !header_of_multiple
      && (allflag
	  || (!gdbarch_has_global_breakpoints (target_gdbarch ())
	      && (number_of_program_spaces () > 1
		  || number_of_inferiors () > 1)
	      /* LOC is for existing B, it cannot be in
		 moribund_locations and thus having NULL OWNER.  */
	      && loc->owner->type != bp_catchpoint)))
d6007 2
a6008 1
      int first = 1;
d6010 1
a6010 1
      for (inf = inferior_list; inf != NULL; inf = inf->next)
d6013 1
a6013 10
	    {
	      if (first)
		{
		  first = 0;
		  ui_out_text (uiout, " inf ");
		}
	      else
		ui_out_text (uiout, ", ");
	      ui_out_text (uiout, plongest (inf->num));
	    }
d6015 13
a8011 2
DEF_VEC_I(int);

@


1.734
log
@	* breakpoint.c (print_one_catch_fork, print_one_catch_vfork)
	(print_one_catch_solib, print_one_catch_syscall)
	(print_one_catch_exec, print_one_exception_catchpoint): Emit
	"catch-type".
gdb/doc
	* gdb.texinfo (GDB/MI Breakpoint Information): Document
	"catch-type" field.
	(GDB/MI Catchpoint Commands): Add "catch-type" to examples.
gdb/testsuite
	* gdb.mi/mi-catch-load.exp: Look for "catch-type".
@
text
@a281 5
static void init_catchpoint (struct breakpoint *b,
			     struct gdbarch *gdbarch, int tempflag,
			     char *cond_string,
			     const struct breakpoint_ops *ops);

d284 1
a284 1
static struct breakpoint_ops base_breakpoint_ops;
d4150 23
d8370 1
a8370 1
static void
d12886 9
a12894 1
static struct breakpoint_ops base_breakpoint_ops =
d12913 1
@


1.733
log
@gdb/

	* breakpoint.c (print_one_breakpoint_location): Remove dead code.
	(update_dprintf_command_list): Assert that 'printf_line' is
	non-null.  Remove condition check.
@
text
@d7532 3
d7648 3
d7849 4
d8264 3
d8504 3
d11555 5
a11559 1
    ui_out_field_string (uiout, "what", "exception throw");
d11561 5
a11565 1
    ui_out_field_string (uiout, "what", "exception catch");
@


1.732
log
@gdb/
	* symtab.h: Remove some out of date comments.
	 (enum exception_event_kind): Move it ...
	* breakpoint.c: ... here.
@
text
@a6096 9
  
  if (!part_of_multiple && b->extra_string
      && b->type == bp_dprintf && !b->commands)
    {
      annotate_field (7);
      ui_out_text (uiout, "\t(agent printf) ");
      ui_out_field_string (uiout, "printf", b->extra_string);
      ui_out_text (uiout, "\n");
    }
d8888 1
d8890 2
a8891 3
  if (printf_line)
    {
      struct command_line *printf_cmd_line, *cont_cmd_line = NULL;
d8893 9
a8901 9
      if (strcmp (dprintf_style, dprintf_style_agent) != 0)
	{
	  cont_cmd_line = xmalloc (sizeof (struct command_line));
	  cont_cmd_line->control_type = simple_control;
	  cont_cmd_line->body_count = 0;
	  cont_cmd_line->body_list = NULL;
	  cont_cmd_line->next = NULL;
	  cont_cmd_line->line = xstrdup ("continue");
	}
d8903 6
a8908 6
      printf_cmd_line = xmalloc (sizeof (struct command_line));
      printf_cmd_line->control_type = simple_control;
      printf_cmd_line->body_count = 0;
      printf_cmd_line->body_list = NULL;
      printf_cmd_line->next = cont_cmd_line;
      printf_cmd_line->line = printf_line;
d8910 2
a8911 2
      breakpoint_set_commands (b, printf_cmd_line);
    }
@


1.731
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d85 7
@


1.730
log
@gdb/
	* ada-lang.c (is_known_support_routine): New variable fullname.  Use
	access call to verify the symtab_to_fullname result.
	* breakpoint.c (print_breakpoint_location, update_static_tracepoint):
	Remove NULL check of symtab_to_fullname result.
	* cli/cli-cmds.c (edit_command): Likewise.
	* mi/mi-cmd-file.c (mi_cmd_file_list_exec_source_file)
	(mi_cmd_file_list_exec_source_files): Likewise.
	* python/py-symtab.c (stpy_fullname): Likewise.
	* source.c (symtab_to_fullname): Update function comment.  Rename
	variable r to fd, move it to inner block.  Always provide non-NULL
	result.
	(print_source_lines_base): Remove NULL check of symtab_to_fullname
	result.
	* stack.c (print_frame): Likewise.
	* symtab.c (iterate_over_some_symtabs, find_line_symtab, sources_info):
	Likewise.
	* tracepoint.c (print_one_static_tracepoint_marker): Likewise.

gdb/doc/
	* gdb.texinfo (GDB/MI Data Manipulation) (fullname): Make it always
	present.
	(GDB/MI File Commands) (-file-list-exec-source-files): Make the
	fullname output always present.

gdb/testsuite/
	* gdb.mi/mi-fullname-deleted.exp: New file.
@
text
@d3 1
a3 1
   Copyright (C) 1986-2012 Free Software Foundation, Inc.
@


1.729
log
@gdb/
	* breakpoint.c (breakpoint_re_set): Remove the skip_re_set call.
	* infrun.c (handle_inferior_event): Rename the called function to
	function_name_is_marked_for_skip, pass it TMP_SAL.
	* skip.c (struct skiplist_entry): Update function_name comment.  Remove
	fields pc, gdbarch and pending.
	(skip_function_pc): Rename this forward declaration to ...
	(skip_function): ... here.
	(skip_file_command): Remove variable pending and its use, remove
	initialization of E fields pending and gdbarch.  Do not use SYMTAB
	filename, use the specified one.
	(skip_function_command): Remove variable func_pc, do not set it.
	Update the caller of skip_function.  Replace decode_line_1 call by
	a lookup_symbol call.  Remove variables orig_arg, decode_exception and
	sals.  Update the caller of skip_function.
	(skip_info): Remove variable address_width and its use.  Do not print
	address (PC).  Renumber column 5 to 4.
	(skip_function_pc): Rename to ...
	(skip_function): ... here and remove its parameters pc, arch and
	pending.  Update the function comment and no longer use those
	parameters.
	(function_pc_is_marked_for_skip): Rename to ...
	(function_name_is_marked_for_skip): ... here, update function comment
	just to a skip.h reference, replace pc parameter by function_name and
	function_sal.  No longer use E field pending and pc.  Remove variables
	searched_for_sal, sal and filename.  Call compare_filenames_for_search
	instead of just strcmp.
	(skip_re_set): Remove the function.
	* skip.h (struct symtab_and_line): New declaration.
	(function_pc_is_marked_for_skip): Rename to ...
	(function_name_is_marked_for_skip): ... here, replace pc parameter by
	function_name and function_sal, update the function comment.

gdb/testsuite/
	* gdb.base/skip-solib.exp (info skip with pending file): Update the
	expected output.
	(info skip with pending file): Remove.
	(ignoring function in solib, info skip for function multiply): Update
	the expected output.
	* gdb.base/skip.ex (skip (main), skip function baz, info skip)
	(info skip (delete 1), info skip after disabling all)
	(info skip after enabling all, info skip after disabling 4 2-3)
	(info skip after enabling 2-3, info skip 2-3)
	(info skip after deleting 2 3): Update the expected output.
	* gdb.linespec/base/two/thefile.cc (n): New variable v, split the
	statement to its initialization and return.
	* gdb.linespec/skip-two.exp: New file.
@
text
@d5697 1
a5697 2
	  if (fullname)
	    ui_out_field_string (uiout, "fullname", fullname);
d13872 1
a13872 2
	      if (fullname)
		ui_out_field_string (uiout, "fullname", fullname);
@


1.728
log
@	* breakpoint.c (dprintf_command): Now static.
@
text
@a14299 3

  /* While we're at it, reset the skip list too.  */
  skip_re_set ();
@


1.727
log
@gdb/
	Code cleanup.
	* breakpoint.c (clear_command): Remove variable sal_name_len and its
	initialization, remove it from the compare_filenames_for_search call.
	* dwarf2read.c (dw2_map_symtabs_matching_filename): Remove variable
	name_len and its initialization, remove it from the
	compare_filenames_for_search calls.
	* psymtab.c (partial_map_symtabs_matching_filename): Likewise.
	* symtab.c (compare_filenames_for_search): Remove the search_len
	parameter, update the function comment, new variable search_len
	initialized from SEARCH_NAME.
	(iterate_over_some_symtabs): Remove variable name_len and its
	initialization, remove it from the compare_filenames_for_search calls.
	* symtab.h (compare_filenames_for_search): Remove the search_len
	parameter,
@
text
@a9861 2
void dprintf_command (char *arg, int from_tty);

d9867 1
a9867 1
void
@


1.726
log
@2012-12-15  Yao Qi  <yao@@codesourcery.com>

	* breakpoint.c (print_one_breakpoint_location): Display the
	state of 'installed' of each non-pending location of a tracepoint
	in both CLI and MI.
	(download_tracepoint_locations): Notify 'breakpoint-modified'
	observer if any tracepoint location is downloaded.
	* tracepoint.c (start_tracing): Likewise.
	(merge_uploaded_tracepoints): Record all modified
	tracepoints and notify 'breakpoint-modified' observer for them.

	* NEWS: Mention the change for CLI and MI.

gdb/doc:
2012-12-15  Yao Qi  <yao@@codesourcery.com>

	* gdb.texinfo (Listing Tracepoints): New item and example about
	'installed on target' output.
	Add more in the example about 'installed on target'.
	(GDB/MI Breakpoint Commands): Doc about 'installed field.

gdb/testsuite:
2012-12-15  Yao Qi  <yao@@codesourcery.com>

	* gdb.trace/mi-tracepoint-changed.exp (test_pending_resolved): Check
	'installed' field in '=breakpoint-modified'.
	(test_reconnect): Check 'installed' field in
	'=breakpoint-modified' and '=breakpoint-created'.

	* gdb.trace/actions.exp: Update test for 'installed' field.
	* gdb.trace/change-loc.exp (tracepoint_change_loc_1):
	(tracepoint_change_loc_2): Likewise.
	Check 'info tracepoint' display nothing else.
	* gdb.trace/deltrace.exp: Likewise.
	* gdb.trace/infotrace.exp: Likewise.
	* gdb.trace/mi-traceframe-changed.exp (test_tfind_remote):
	Likewise.
	* gdb.trace/passcount.exp: Likewise.
	* gdb.trace/tracecmd.exp: Likewise.
	* gdb.trace/while-stepping.exp: Likewise.
@
text
@d11884 1
a11884 1
      int is_abs, sal_name_len;
a11899 1
      sal_name_len = is_abs ? 0 : strlen (sal.symtab->filename);
d11932 1
a11932 2
								sal.symtab->filename,
								sal_name_len))
@


1.725
log
@gdb/
2012-12-15  Yao Qi  <yao@@codesourcery.com>

	* breakpoint.c (download_tracepoint_locations): Iterate over
	ALL_TRACEPOINTS first and then iterate over locations of
	each tracepoint.
@
text
@d6123 19
d12115 1
d12135 1
d12139 2
@


1.724
log
@MI: add the -catch-load and -catch-unload commands

They are equivalent to "catch load" and "catch unload" from CLI.

Rationale: GUIs might be interested in catching solib load or
unload events.

2012-11-16  Mircea Gherzan  <mircea.gherzan@@intel.com>

	* Makefile.in (SUBDIR_MI_OBS): Add mi-cmd-catch.o.
	(SUBDIR_MI_SRCS): Add mi/mi-cmd-catch.c.
	* breakpoint.c (add_solib_catchpoint): New function that
	can be used by both CLI and MI, factored out from
	catch_load_or_unload.
	(catch_load_or_unload): Strip it down and make it use the
	new add_solib_catchpoint.
	* breakpoint.h (add_solib_catchpoint): Declare it.
	* mi/mi-cmd-break.h: New file.
	* mi/mi-cmd-break.c: Include mi-cmd-break.h.
	(setup_breakpoint_reporting): New function used for both
	catchpoints and breakpoints.
	(mi_cmd_break_insert): Use setup_breakpoint_reporting.
	* mi/mi-cmd-catch.c: New file.
	* mi/mi-cmds.c (mi_cmds): Add the handlers for -catch-load
	and -catch-unload.
	* mi/mi-cmds.h: Declare the handlers for -catch-load and
	-catch-unload.
@
text
@d12084 1
a12084 1
  struct bp_location *bl, **blp_tmp;
d12092 1
a12092 1
  ALL_BP_LOCATIONS (bl, blp_tmp)
d12094 1
d12097 1
a12097 4
      if (!is_tracepoint (bl->owner))
	continue;

      if ((bl->owner->type == bp_fast_tracepoint
d12102 7
a12108 5
      /* In tracepoint, locations are _never_ duplicated, so
	 should_be_inserted is equivalent to
	 unduplicated_should_be_inserted.  */
      if (!should_be_inserted (bl) || bl->inserted)
	continue;
d12110 1
a12110 1
      switch_to_program_space_and_thread (bl->pspace);
d12112 1
a12112 1
      target_download_tracepoint (bl);
d12114 4
a12117 3
      bl->inserted = 1;
      t = (struct tracepoint *) bl->owner;
      t->number_on_target = bl->owner->number;
@


1.723
log
@	* ada-exp.y (write_object_renaming, write_var_or_type)
	(write_ambiguous_var, write_var_from_sym): Make blocks const.
	* ada-lang.c (replace_operator_with_call)
	(find_old_style_renaming_symbol): Make blocks const.
	* ada-lang.h (ada_find_renaming_symbol): Update.
	(struct ada_symbol_info) <block>: Now const.
	* breakpoint.c (watch_command_1): Update.
	* breakpoint.h (struct watchpoint) <exp_valid_block,
	cond_exp_valid_block>: Now const.
	* c-exp.y (classify_inner_name, classify_name): Make block
	argument const.
	* expprint.c (print_subexp_standard) <OP_VAR_VALUE>: Make 'b'
	const.
	* expression.h (innermost_block, parse_exp_1): Update.
	(union exp_element) <block>: Now const.
	* gdbtypes.c (lookup_template_type, lookup_enum, lookup_union)
	(lookup_struct): Make block argument const.
	* gdbtypes.h (lookup_template_type): Update.
	* go-exp.y (classify_name, classify_packaged_name)
	(package_name_p): Make block argument const.
	* objc-lang.c (lookup_struct_typedef): Make block argument const.
	* objc-lang.h (lookup_struct_typedef): Update.
	* parse.c (parse_exp_in_context, parse_exp_1)
	(write_exp_elt_block): Make block arguments const.
	(expression_context_block, innermost_block): Now const.
	* parser-defs.h (write_exp_elt_block): Update.
	(expression_context_block, innermost_block, block_found): Now
	const.
	* printcmd.c (struct display) <block>: Now const.
	* symtab.h (lookup_struct, lookup_union, lookup_enum): Update.
	* valops.c (address_of_variable): Make block argument const.
	* value.h (value_of_variable): Update.
	* varobj.c (struct varobj_root) <valid_block>: Now const.
@
text
@d7853 6
a7858 2
/* A helper function that does all the work for "catch load" and
   "catch unload".  */
d7860 2
a7861 3
static void
catch_load_or_unload (char *arg, int from_tty, int is_load,
		      struct cmd_list_element *command)
a7864 1
  int tempflag;
a7866 2
  tempflag = get_cmd_context (command) == CATCH_TEMPORARY;

d7890 1
a7890 1
  init_catchpoint (&c->base, gdbarch, tempflag, NULL,
d7893 2
d7899 15
@


1.722
log
@gdb/
2012-11-30  Yao Qi  <yao@@codesourcery.com>

	* breakpoint.c (print_one_breakpoint_location): Indent code.
@
text
@d10753 1
a10753 1
  struct block *exp_valid_block = NULL, *cond_exp_valid_block = NULL;
@


1.721
log
@gdb/
2012-11-30  Yao Qi  <yao@@codesourcery.com>

	* breakpoint.c (print_one_breakpoint_location): Combine two
	blocks handling 'hit count' together.
@
text
@d6032 15
a6046 15
    {
      /* FIXME should make an annotation for this.  */
      if (is_catchpoint (b))
	ui_out_text (uiout, "\tcatchpoint");
      else if (is_tracepoint (b))
	ui_out_text (uiout, "\ttracepoint");
      else
	ui_out_text (uiout, "\tbreakpoint");
      ui_out_text (uiout, " already hit ");
      ui_out_field_int (uiout, "times", b->hit_count);
      if (b->hit_count == 1)
	ui_out_text (uiout, " time\n");
      else
	ui_out_text (uiout, " times\n");
    }
d6049 3
a6051 3
  /* Output the count also if it is zero, but only if this is mi.  */
  if (ui_out_is_mi_like_p (uiout))
      ui_out_field_int (uiout, "times", b->hit_count);
@


1.720
log
@gdb/
2012-11-28  Yao Qi  <yao@@codesourcery.com>

	* breakpoint.c (_initialize_breakpoint): Call add_alias_cmd to
	abbreviate 'delete tracepoints' to 'delete tr'.
	* corefile.c (_initialize_core): Call add_alias_cmd to
	abbreviate 'set gnutarget' to 'set g'.
	* value.c (_initialize_values): Call add_alias_cmd to abbreviate
	'show convenience' to 'show conv'.
@
text
@d6029 3
a6031 1
  if (!part_of_multiple && b->hit_count)
d6047 3
a6049 3
  
  /* Output the count also if it is zero, but only if this is mi.
     FIXME: Should have a better test for this.  */
a6050 1
    if (!part_of_multiple && b->hit_count == 0)
d6052 2
@


1.719
log
@	ARI fixes: sprintf rule.
	Replace sprintf function calls for char arrays by
	calls to xsnprintf calls.
	* arm-tdep.c (arm_push_dummy_call): Replace sprintf by xsnprintf.
	(arm_dwarf_reg_to_regnum, arm_return_value): Ditto.
	(arm_neon_quad_read, arm_pseudo_read): Ditto.
	(arm_neon_quad_write, arm_pseudo_write): Ditto.
	* breakpoint.c (condition_completer): Ditto.
	(create_tracepoint_from_upload): Ditto.
	* dwarf2read.c (file_full_name): Ditto.
	* gcore.c (gcore_command): Ditto.
	* gnu-nat.c (proc_string, gnu_pid_to_str): Ditto.
	* go32-nat.c (go32_sysinfo): Ditto.
	* interps.c (interp_set): Ditto.
	* m32c-tdep.c (make_types): Ditto.
	* ppc-linux-nat.c (fetch_register, store_register): Ditto.
	* remote-m32r-sdi.c (m32r_open): Ditto.
	* sol-thread.c (td_err_string): Ditto.
	(td_state_string, solaris_pid_to_str): Ditto.
	* symtab.c (gdb_mangle_name): Ditto.
	* cli/cli-script.c (execute_control_command): Ditto.
	(define_command, document_command): Ditto.
	* tui/tui-io.c (tui_rl_display_match_list): Ditto.
	* tui/tui-stack.c (tui_make_status_line): Ditto.
	* tui/tui-win.c (tui_update_gdb_sizes): Ditto.
@
text
@d16342 1
@


1.718
log
@2012-11-20  Pedro Alves  <palves@@redhat.com>

	* annotate.c (breakpoints_changed): Rename to ...
	(annotate_breakpoints_changed): ... this.
	(annotate_stopped, breakpoint_changed): Adjust caller.
	* annotate.h (breakpoints_changed): Rename to ...
	(annotate_breakpoints_changed): ... this.
	* breakpoint.c (set_breakpoint_condition, breakpoint_set_commands)
	(do_map_commands_command, init_raw_breakpoint, clear_command)
	(set_ignore_count, enable_breakpoint_disp): Adjust callers.
@
text
@d1027 1
a1027 1
	      sprintf (location, "%d", b->number);
d1029 2
a1030 1
	      sprintf (location, "%d.%d", b->number, count);
d15105 1
a15105 1
      sprintf (small_buf, "*%s", hex_string (utp->addr));
d15136 2
a15137 1
      sprintf (small_buf, "%d %d", utp->pass, tp->base.number);
@


1.717
log
@	* breakpoint.c (clear_command): Add cleanup for
	sals.sals if an argument is given.

	* linespec.c (parse_linespec): Do cleanups after
	parsing a convenience variable.
@
text
@d986 1
a986 1
  breakpoints_changed ();
d1217 1
a1217 1
  breakpoints_changed ();
d1334 1
a1334 1
      breakpoints_changed ();
d6999 1
a6999 1
  breakpoints_changed ();
d11944 1
a11944 1
  breakpoints_changed ();
d14322 1
a14322 1
      breakpoints_changed ();
d14587 1
a14587 1
  breakpoints_changed ();
@


1.716
log
@	* gdbarch.sh (target_gdbarch): Remove macro.
	(get_target_gdbarch): Rename to target_gdbarch.
	* gdbarch.c, gdbarch.h: Rebuild.
	* ada-tasks.c, aix-thread.c, amd64-linux-nat.c, arch-utils.c,
	arm-tdep.c, auxv.c, breakpoint.c, bsd-uthread.c, corefile.c,
	darwin-nat-info.c, dcache.c, dsrec.c, exec.c, fbsd-nat.c,
	filesystem.c, gcore.c, gnu-nat.c, i386-darwin-nat.c, i386-nat.c,
	ia64-vms-tdep.c, inf-ptrace.c, infcmd.c, jit.c, linux-nat.c,
	linux-tdep.c, linux-thread-db.c, m32r-rom.c, memattr.c,
	mep-tdep.c, microblaze-tdep.c, mips-linux-nat.c,
	mips-linux-tdep.c, mips-tdep.c, monitor.c, moxie-tdep.c,
	nto-procfs.c, nto-tdep.c, ppc-linux-nat.c, proc-service.c,
	procfs.c, progspace.c, ravenscar-thread.c, record.c,
	remote-m32r-sdi.c, remote-mips.c, remote-sim.c, remote.c,
	rl78-tdep.c, rs6000-nat.c, rx-tdep.c, s390-nat.c, sol-thread.c,
	solib-darwin.c, solib-dsbt.c, solib-frv.c, solib-ia64-hpux.c,
	solib-irix.c, solib-pa64.c, solib-som.c, solib-spu.c,
	solib-sunos.c, solib-svr4.c, solib.c, spu-linux-nat.c,
	spu-multiarch.c, spu-tdep.c, symfile-mem.c, symfile.c, symtab.c,
	target-descriptions.c, target.c, target.h, tracepoint.c,
	windows-nat.c, windows-tdep.c, xcoffsolib.c, cli/cli-dump.c,
	common/agent.c, mi/mi-interp.c, python/py-finishbreakpoint.c,
	python/py-inferior.c, python/python.c: Update.
@
text
@d11795 1
@


1.715
log
@2012-11-09  Yao Qi  <yao@@codesourcery.com>

        * breakpoint.c: Declare set_tracepoint_count.
        (install_breakpoint): Call set_tracepoint_count if B is a
        tracepoint.
        (trace_command): Don't call set_tracepoint_count.  Re-indent.
        (strace_command, ftrace_command):
        (create_tracepoint_from_upload): Likewise.

gdb/testsuite:

2012-11-09  Yao Qi  <yao@@codesourcery.com>

        * gdb.mi/mi-break.exp (test_abreak_creation): New procedure.
        (top level): Call it
@
text
@d2795 1
a2795 1
      if (!gdbarch_has_global_breakpoints (target_gdbarch)
d2854 1
a2854 1
      if (!gdbarch_has_global_breakpoints (target_gdbarch)
d3735 1
a3735 1
  if (gdbarch_has_global_breakpoints (target_gdbarch))
d5939 1
a5939 1
	  || (!gdbarch_has_global_breakpoints (target_gdbarch)
d6599 1
a6599 1
  return ((gdbarch_has_global_breakpoints (target_gdbarch)
d6614 1
a6614 1
  return ((gdbarch_has_global_breakpoints (target_gdbarch)
d12532 1
a12532 1
	  || (gdbarch_has_global_breakpoints (target_gdbarch))))
@


1.714
log
@gdb:
	* breakpoint.c (get_tracepoint_by_number): Remove 'extern int
	tracepoint_count'.
@
text
@d264 2
d8324 2
d15006 11
a15016 12
  if (create_breakpoint (get_current_arch (),
			 arg,
			 NULL, 0, NULL, 1 /* parse arg */,
			 0 /* tempflag */,
			 bp_tracepoint /* type_wanted */,
			 0 /* Ignore count */,
			 pending_break_support,
			 ops,
			 from_tty,
			 1 /* enabled */,
			 0 /* internal */, 0))
    set_tracepoint_count (breakpoint_count);
d15022 11
a15032 12
  if (create_breakpoint (get_current_arch (),
			 arg,
			 NULL, 0, NULL, 1 /* parse arg */,
			 0 /* tempflag */,
			 bp_fast_tracepoint /* type_wanted */,
			 0 /* Ignore count */,
			 pending_break_support,
			 &tracepoint_breakpoint_ops,
			 from_tty,
			 1 /* enabled */,
			 0 /* internal */, 0))
    set_tracepoint_count (breakpoint_count);
d15049 11
a15059 12
  if (create_breakpoint (get_current_arch (),
			 arg,
			 NULL, 0, NULL, 1 /* parse arg */,
			 0 /* tempflag */,
			 bp_static_tracepoint /* type_wanted */,
			 0 /* Ignore count */,
			 pending_break_support,
			 ops,
			 from_tty,
			 1 /* enabled */,
			 0 /* internal */, 0))
    set_tracepoint_count (breakpoint_count);
a15127 2
  set_tracepoint_count (breakpoint_count);
  
@


1.713
log
@gdb/
2012-11-06  Pedro Alves  <palves@@redhat.com>

	PR gdb/14810

	* breakpoint.c (bpstat_stop_status): Skip disabled locations.

gdb/testsuite/
2012-11-06  Pedro Alves  <palves@@redhat.com>

	PR gdb/14810

	* gdb.base/disabled-location.c: New file.
	* gdb.base/disabled-location.exp: New file.
@
text
@a15349 1
  extern int tracepoint_count;
@


1.712
log
@gdb:

	Fix PR gdb/14617.
	* breakpoint.c (trace_pass_set_count): Call
	observer_notify_breakpoint_modified instead of
	observer_notify_tracepoint_modified.
	* mi/mi-cmd-break.c (mi_cmd_break_passcount): Likewise.

gdb/doc:

	* observer.texi (GDB Observers): Remove observer
	'tracepoint_modified', 'tracepoint_created' and
	'tracepoint_deleted'.

gdb/testsuite:

	Fix PR gdb/14617.
	* gdb.mi/mi-breakpoint-changed.exp (test_insert_delete_modify):
	Remove setup_kfail, and update test.
@
text
@d5178 1
a5178 1
	  if (bl->shlib_disabled)
@


1.711
log
@	* breakpoint.c (catch_syscall_completer): Pass 'word' as second
	argument to complete_on_enum.
testsuite
	* gdb.base/catch-syscall.exp (do_syscall_tests): Add completion
	test.
@
text
@d15248 1
a15248 1
  observer_notify_tracepoint_modified (tp->base.number);
@


1.710
log
@	* tracepoint.c (print_one_static_tracepoint_marker): Constify.
	* symtab.c (iterate_over_some_symtabs): Constify.
	* source.h (symtab_to_fullname): Return 'const char *'.
	* source.c (symtab_to_fullname): Return 'const char *'.
	* python/py-symtab.c (stpy_fullname): Constify.
	* cli/cli-cmds.c (edit_command): Constify.
	* breakpoint.c (print_breakpoint_location)
	(update_static_tracepoint): Constify.
@
text
@d14975 1
a14975 1
    = (list == NULL) ? NULL : complete_on_enum (list, text, word);
@


1.709
log
@	* breakpoint.c (compare_breakpoints): Fix comparison.
@
text
@d5692 1
a5692 1
	  char *fullname = symtab_to_fullname (sal.symtab);
d13825 1
a13825 1
	      char *fullname = symtab_to_fullname (sal2.symtab);
@


1.708
log
@gdb:
	* breakpoint.c (invalidate_bp_value_on_memory_change): Add one
	more parameter 'inferior'.
	* corefile.c (write_memory_with_notification): Caller update.

	* mi/mi-cmd-var.c: Include "mi-main.h".
	(mi_cmd_var_assign): Set mi_suppress_notification.data_write_memory
	to 1 and restore it later.
	* mi/mi-cmds.c (mi_cmd mi_cmds): Update for "data-write-memory"
	and "data-write-memory-bytes.
	* mi/mi-interp.c: Include objfiles.h.
	(mi_interpreter_init): Call observer_attach_memory_changed.
	(mi_memory_changed): New.
	* mi/mi-main.h (struct mi_suppress_notification) <memory>:
	New field.

	* NEWS: Mention new MI notification "memory-changed".

gdb/doc:

	* observer.texi (GDB Observers): Update observer
	'memory_changed'.
	* gdb.texinfo (GDB/MI Async Records): Document for
	"memory-changed" notification.

gdb/testsuite:

	* gdb.mi/mi-memory-changed.exp: New.
@
text
@d11769 1
a11769 1
  return ub > ub ? 1 : 0;
@


1.707
log
@http://sourceware.org/ml/gdb-patches/2012-09/msg00403.html

gdb/ChangeLog

        * breakpoint.c (update_global_location_list): Ignore previous
        duplicate status of a breakpoint when starting a new scan for
        duplicate breakpoints.

gdb/testsuite/ChangeLog

        * gdb.base/duplicate-bp.c: New file.
        * gdb.base/duplicate-bp.exp: New file.
@
text
@d14721 2
a14722 1
invalidate_bp_value_on_memory_change (CORE_ADDR addr, ssize_t len,
@


1.706
log
@gdb/ChangeLog:

	* breakpoint.c (invalidate_bp_value_on_memory_change): Expand
	parameter LEN to ssize_t.

gdb/doc/ChangeLog:

	observer.texi (memory_changed): Expand parameter LEN to ssize_t.
@
text
@d12465 1
a12465 1
      if (!should_be_inserted (loc)
@


1.705
log
@	* ada-valprint.c (ada_val_print_1): Eliminate single-use
	variable LEN.
	* alpha-tdep.c (alpha_extract_return_value): Use TYPE_LENGTH
	directly.
	(alpha_store_return_value): Likewise.
	* amd64-tdep.c (amd64_classify_aggregate): Likewise.
	(amd64_push_arguments): Likewise.
	* ax-gdb.c (gen_trace_static_fields): Likewise.
	(gen_traced_pop): Likewise.
	* bfin-tdep.c (bfin_push_dummy_call): Likewise.
	* breakpoint.c (update_watchpoint): Likewise.
	* findcmd.c (parse_find_args): Use local variable for type
	instead of length.
	* findvar.c (default_read_var_value): Use TYPE_LENGTH directly.
	* h8300-tdep.c (h8300h_extract_return_value): Likewise.
	(h8300_store_return_value): Likewise.
	* i386-darwin-tdep.c (i386_darwin_push_dummy_call): Likewise.
	Use i386_darwin_arg_type_alignment directly.
	* infcall.c (call_function_by_hand): Use TYPE_LENGTH directly.
	* lm32-tdep.c (lm32_push_dummy_call): Likewise.
	* m68hc11-tdep.c (m68hc11_push_dummy_call): Likewise.
	(m68hc11_extract_return_value): Likewise.
	* mep-tdep.c (mep_push_dummy_call): Likewise.
	* printcmd.c (float_type_from_length): Likewise.
	* s390-tdep.c (s390_value_from_register): Likewise.
	* stack.c (read_frame_arg): Likewise.
	* tracepoint.c (encode_actions_1): Likewise.
	* valops.c (value_fetch_lazy): Use local variable for type
	instead of length.  Use TYPE_LENGTH directly.
	* value.c (value_contents_equal): Use TYPE_LENGTH directly.
@
text
@d14721 1
a14721 1
invalidate_bp_value_on_memory_change (CORE_ADDR addr, int len,
@


1.704
log
@gdb/
	Code cleanup - rename 'inline' depth to 'artificial' depth.
	* breakpoint.c (set_momentary_breakpoint): Rename at a caller to
	frame_id_artificial_p, extend the comment.
	* dwarf2-frame-tailcall.c (tailcall_frame_this_id): Rename at a user.
	* frame.c (fprint_frame_id): Rename at a user, change debug output
	text to "artificial=".
	(skip_inlined_frames): Rename to ...
	(skip_artificial_frames): ... here.  Extend the comment.
	(get_stack_frame_id, frame_unwind_caller_id): Rename at a caller.
	(frame_id_inlined_p): Rename to ...
	(frame_id_artificial_p): ... here.  Rename at a user.
	(frame_id_eq, frame_id_inner, frame_unwind_caller_pc)
	(frame_unwind_caller_pc_if_available, frame_unwind_caller_arch): Rename
	at a user.
	* frame.h (struct frame_id): Rename inline_depth to artificial_depth.
	Extend the comment.
	(frame_id_inlined_p): Rename to ...
	(frame_id_artificial_p): ... here.
	* inline-frame.c (inline_frame_this_id): Rename at a user.
@
text
@d1847 1
a1847 1
		  int len, type;
a1850 1
		  len = TYPE_LENGTH (value_type (v));
d1865 1
a1865 1
		  loc->length = len;
@


1.703
log
@* gdb/remote.c (remote_insert_hw_breakpoint): Throw exception if
there is an error inserting hardware breakpoints and use the
error message from the target.

* gdb/breakpoint.c (insert_bp_location, insert_breakpoint_locations):
Catch this exception and print the error message contained within. Do not
print the default hardware error breakpoint message in this case.
@
text
@d8612 3
a8614 3
  /* If FRAME_ID is valid, it should be a real frame, not an inlined
     one.  */
  gdb_assert (!frame_id_inlined_p (frame_id));
@


1.702
log
@gdb/
	* breakpoint.c (parse_breakpoint_sals) <(*address) == NULL>: New
	variable pc.  Call find_pc_line instead of find_pc_overlay, restore
	original PC for it.

gdb/testsuite/
	* gdb.base/break-caller-line.c: New file.
	* gdb.base/break-caller-line.exp: New file.
@
text
@d2378 2
a2379 1
		    int *hw_breakpoint_error)
d2382 2
d2480 9
a2488 2

	  val = bl->owner->ops->insert_location (bl);
d2522 9
a2530 1
	      val = bl->owner->ops->insert_location (bl);
d2566 7
a2572 5
		  *hw_breakpoint_error = 1;
		  fprintf_unfiltered (tmp_error_stream,
				      "Cannot insert hardware "
				      "breakpoint %d.\n",
				      bl->owner->number);
d2764 1
d2799 1
a2799 1
				    &hw_breakpoint_error);
d2824 1
d2858 1
a2858 1
				    &hw_breakpoint_error);
d2903 1
a2903 1
      if (hw_breakpoint_error)
d2968 1
a2968 1
  int dummy1 = 0, dummy2 = 0;
d2992 1
a2992 1
	val = insert_bp_location (bl, tmp_error_stream, &dummy1, &dummy2);
@


1.701
log
@	* auto-load.c (_initialize_auto_load): Update.
	* solib-svr4.c (_initialize_svr4_solib): Update
	* solib-dsbt.c (_initialize_dsbt_solib): Update.
	* solib-darwin.c (_initialize_darwin_solib): Update.
	* registry.h: New file.
	* python/py-progspace.c (gdbpy_initialize_pspace): Update.
	* python/py-inferior.c (gdbpy_initialize_inferior): Update.
	* progspace.h: Include registry.h.  Use DECLARE_REGISTRY.
	(register_program_space_data_with_cleanup)
	(register_program_space_data, program_space_alloc_data)
	(clear_program_space_data, set_program_space_data)
	(program_space_data): Don't declare.
	* progspace.c: Use DEFINE_REGISTRY.
	(struct program_space_data, struct
	program_space_data_registration, struct
	program_space_data_registry, program_space_data_registry)
	(register_program_space_data_with_cleanup)
	(register_program_space_data, program_space_alloc_data)
	(program_space_free_data, clear_program_space_data)
	(set_program_space_data, program_space_data): Remove.
	* objfiles.h: Include registry.h.  Use DECLARE_REGISTRY.
	(struct objfile) <data, num_data>: Replace with REGISTRY_FIELDS.
	(register_objfile_data_with_cleanup, register_objfile_data)
	(clear_objfile_data, set_objfile_data, objfile_data): Don't
	declare.
	* objfiles.c: Use DEFINE_REGISTRY.
	(struct objfile_data, struct objfile_data_registration, struct
	objfile_data_registry, objfile_data_registry)
	(register_objfile_data_with_cleanup, register_objfile_data)
	(objfile_alloc_data, objfile_free_data, clear_objfile_data)
	(set_objfile_data, objfile_data): Remove.
	(_initialize_objfiles): Update.
	* jit.c (_initialize_jit): Update.
	* inflow.c (_initialize_inflow): Update.
	* inferior.h: Include registry.h.  Use DECLARE_REGISTRY.
	(struct inferior) <data, num_data>: Replace with REGISTRY_FIELDS.
	(register_inferior_data_with_cleanup, register_inferior_data)
	(clear_inferior_data, set_inferior_data, inferior_data): Don't
	declare.
	* inferior.c: Use DEFINE_REGISTRY.
	(struct inferior_data, struct inferior_data_registration, struct
	inferior_data_registry, inferior_data_registry)
	(register_inferior_data_with_cleanup, register_inferior_data)
	(inferior_alloc_data, inferior_free_data  clear_inferior_data)
	(set_inferior_data, inferior_data): Remove.
	* auxv.c (_initialize_auxv): Update.
	* ada-lang.c (_initialize_ada_language): Update.
	* breakpoint.c (_initialize_breakpoint): Update.
	* i386-nat.c (i386_use_watchpoints): Update.
@
text
@d9129 1
d9136 4
a9139 1
	     corresponding to the last call to print_frame_info.  */
d9141 2
a9142 1
          sal.section = find_pc_overlay (sal.pc);
d9149 1
@


1.700
log
@Change detach_breakpoints to take a ptid instead of a pid

Before this change, detach_breakpoints would take a pid, and then
set inferior_ptid to a ptid that it constructs using pid_to_ptid (pid).
Unfortunately, this ptid is not necessarily valid.  Consider for
instance the case of ia64-hpux, where ttrace refuses a register-read
operation if the LWP is not provided.

This problems shows up when GDB is trying to handle fork events.
Assuming GDB is configured to follow the parent, GDB will try to
detach from the child. But before doing so, it needs to remove
all breakpoints inside that child.  On ia64, this involves reading
inferior (the child's) memory. And on ia64-hpux, reading memory
requires us to read the bsp and bspstore registers, in order to
determine where that memory is relative to the value of those
registers, and thus to determine which ttrace operation to use in
order to fetch that memory (see ia64_hpux_xfer_memory).

This patch therefore changes detach_breakpoints to take a ptid instead
of a pid, and then updates all callers.

One of the consequences of this patch is that it trips an assert
on GNU/Linux targets.  But this assert appears to have not actual
purpose, and is thus removed.

gdb/ChangeLog:

        * breakpoint.h (detach_breakpoints): pid parameter is now a ptid.
        * breakpoint.c (detach_breakpoints): Change pid parameter into
        a ptid.  Adjust code accordingly.
        * infrun.c (handle_inferior_event): Delete variable child_pid.
        Update call to detach_breakpoints to pass the child ptid for
        fork events.
        * linux-nat.c (linux_nat_iterate_watchpoint_lwps): Remove
        assert that inferior_ptid's lwp is zero.
        (linux_handle_extended_wait): Update call to detach_breakpoints.
        * inf-ttrace.c (inf_ttrace_follow_fork): Update call to
        detach_breakpoints.
@
text
@d15879 2
a15880 1
    = register_inferior_data_with_cleanup (catch_syscall_inferior_data_cleanup);
@


1.699
log
@gdb/
	* std-operator.def: Remove TERNOP_SLICE_COUNT.
	* breakpoint.c (watchpoint_exp_is_const): Remove handling to
	TERNOP_SLICE_COUNT.
	* eval.c (evaluate_subexp_standard): Likewise.
	* expprint.c (print_subexp_standard): Likewise.
	(dump_subexp_body_standard): Likewise.
	* parse.c (operator_length_standard): Likewise.
@
text
@d3503 1
a3503 1
detach_breakpoints (int pid)
d3510 1
a3510 1
  if (pid == PIDGET (inferior_ptid))
d3514 1
a3514 1
  inferior_ptid = pid_to_ptid (pid);
@


1.698
log
@gdb/
	* std-operator.def: Remove OP_BITSTRING.
	* breakpoint.c (watchpoint_exp_is_const): Update.
	* eval.c (evaluate_subexp_standard): Remove handling to
	OP_BITSTRING.
	* expprint.c (print_subexp_standard): Likewise.
	(dump_subexp_body_standard): Likewise.
	* parse.c (operator_length_standard): Likewise.
	* valops.c (value_bitstring): Remove.
	* value.h: Remove the declaration of 'value_bitstring'.
@
text
@a10162 1
	case TERNOP_SLICE_COUNT:
@


1.697
log
@gdb/
	* cli/cli-cmds.c (enablebreaklist): Move it to breakpoint.c.
	(skiplist): Move it to skip.c.
	(init_cmd_lists): Remove code setting enablebreaklist and
	skiplist to NULL.
	* breakpoint.c (enablebreaklist): Moved from cli/cli-cmds.c.
	* cli/cli-cmds.h: Remove declaration of enablebreaklist and
	skiplist.
	* gdbcmd.h: Likewise.
	* skip.c (_initialize_step_skip): Move 'skiplist' from
	cli/cli-cmds.c.
@
text
@a10170 1
	case OP_BITSTRING:
@


1.696
log
@	* breakpoint.c (parse_breakpoint_sals): Remove unused variable
	addr_start.
@
text
@d15862 4
@


1.695
log
@2012-07-20  Marc Khouzam  <marc.khouzam@@ericsson.com>

	* breakpoint.c (create_breakpoint): Store condition for pending
	breakpoints.
@
text
@a9117 2
  char *addr_start = *address;

@


1.694
log
@	PR exp/13206:
	* ax-gdb.c (gen_expr) <OP_TYPEOF, OP_DECLTYPE>: New cases.
	* breakpoint.c (watchpoint_exp_is_const) <OP_TYPEOF,
	OP_DECLTYPE>: New cases.
	* c-exp.y (TYPEOF, DECLTYPE): New tokens.
	(type_exp): Add new productions.
	(ident_tokens): Add __typeof__, typeof, __typeof, __decltype,
	and decltype.
	* eval.c (evaluate_subexp_standard) <OP_TYPEOF, OP_DECLTYPE>:
	New case.
	* expprint.c (dump_subexp_body_standard) <OP_TYPEOF,
	OP_DECLTYPE>: New case.
	* parse.c (operator_length_standard) <OP_TYPEOF, OP_DECLTYPE>:
	New case.
	* std-operator.def (OP_TYPEOF, OP_DECLTYPE): New constants.
	* varobj.c (varobj_create): Handle OP_TYPEOF, OP_DECLTYPE.
gdb/testsuite
	* gdb.cp/casts.exp: Add tests for typeof and decltype.
	* gdb.cp/casts.cc (decltype): New function.
	(main): Use it.
@
text
@d9560 12
a9571 1
      b->cond_string = NULL;
@


1.693
log
@	* ax-gdb.c (gen_expr): Handle UNOP_CAST_TYPE, UNOP_MEMVAL_TYPE.
	* breakpoint.c (watchpoint_exp_is_const): Handle UNOP_CAST_TYPE,
	UNOP_REINTERPRET_CAST, UNOP_DYNAMIC_CAST.
	* c-exp.y (exp): Emit UNOP_MEMVAL_TYPE, UNOP_CAST_TYPE.  Update
	for changes to UNOP_REINTERPRET_CAST, UNOP_DYNAMIC_CAST.  Use
	type_exp production where appropriate.
	* eval.c (evaluate_subexp_standard) <UNOP_CAST_TYPE>: New case.
	<UNOP_DYNAMIC_CAST, UNOP_REINTERPRET_CAST>: Update.
	<UNOP_MEMVAL_TYPE>: New case.
	(evaluate_subexp_for_address) <UNOP_MEMVAL_TYPE>: New case.
	(evaluate_subexp_for_sizeof) <UNOP_MEMVAL_TYPE>: New case.
	* expprint.c (print_subexp_standard) <UNOP_CAST_TYPE>: New case.
	<UNOP_MEMVAL_TYPE>: New case.
	(dump_subexp_body_standard) <UNOP_DYNAMIC_CAST,
	UNOP_REINTERPRET_CAST>: Update.
	<UNOP_CAST_TYPE, UNOP_MEMVAL_TYPE>: New cases.
	* parse.c (operator_length_standard) <UNOP_DYNAMIC_CAST,
	UNOP_REINTERPRET_CAST>: Update.
	<UNOP_CAST_TYPE, UNOP_MEMVAL_TYPE>: New cases.
	* stack.c (return_command): Also check for UNOP_CAST_TYPE.
	* std-operator.def (UNOP_CAST_TYPE, UNOP_MEMVAL_TYPE): New
	constants.
@
text
@d10165 2
@


1.692
log
@	* breakpoint.c (invalid_thread_id_error): New function.
	(find_condition_and_thread): Use invalid_thread_id_error.
	(watch_command_1): Likewise.
@
text
@d10174 4
@


1.691
log
@	* breakpoint.c (find_condition_and_thread): Initialize
	TASK and REST.
	(create_breakpiont): find_condition_and_thread will now
	initialize COND_STRING, THREAD, and REST (and TASK).
	(addr_string_to_sals): Likewise.
@
text
@d9234 8
d9298 1
a9298 1
	    error (_("Unknown thread %d."), *thread);
d10775 1
a10775 1
		error (_("Unknown thread %d."), thread);
@


1.690
log
@2012-07-05  Hui Zhu  <hui_zhu@@mentor.com>

	* breakpoint.c (check_for_argument): Move to file cli/cli-utils.c.
	* cli/cli-utils.c (check_for_argument): New function.
	* cli/cli-utils.h (check_for_argument): Ditto.
@
text
@d9248 3
d9501 1
a9501 3
            cond_string = NULL;
            thread = -1;
	    rest = NULL;
d14013 2
a14014 4
	  char *cond_string = 0;
	  int thread = -1;
	  int task = 0;
	  char *extra_string = NULL;
@


1.690.2.1
log
@2012-07-24  Marc Khouzam  <marc.khouzam@@ericsson.com>

	* breakpoint.c (create_breakpoint): Store condition for pending
	breakpoints.
@
text
@d9551 1
a9551 12
      if (parse_condition_and_thread)
	b->cond_string = NULL;
      else
	{
	  /* Create a private copy of condition string.  */
	  if (cond_string)
	    {
	      cond_string = xstrdup (cond_string);
	      make_cleanup (xfree, cond_string);
	    }
	  b->cond_string = cond_string;
	}
@


1.689
log
@	Add target-side support for dynamic printf.
	* NEWS: Mention the additional style.
	* breakpoint.h (struct bp_target_info): New fields tcommands, persist.
	(struct bp_location): New field cmd_bytecode.
	* breakpoint.c: Include format.h.
	(disconnected_dprintf): New global.
	(parse_cmd_to_aexpr): New function.
	(build_target_command_list): New function.
	(insert_bp_location): Call it.
	(remove_breakpoints_pid): Skip dprintf breakpoints.
	(print_one_breakpoint_location): Ditto.
	(dprintf_style_agent): New global.
	(dprintf_style_enums): Add dprintf_style_agent.
	(update_dprintf_command_list): Add agent case.
	(agent_printf_command): New function.
	(_initialize_breakpoint): Add new commands.
	* common/ax.def (printf): New bytecode.
	* ax.h (ax_string): Declare.
	* ax-gdb.h (gen_printf): Declare.
	* ax-gdb.c: Include cli-utils.h, format.h.
	(gen_printf): New function.
	(maint_agent_print_command): New function.
	(_initialize_ax_gdb): Add maint agent-printf command.
	* ax-general.c (ax_string): New function.
	(ax_print): Add printf disassembly.
	* Makefile.in (SFILES): Add format.c
	(COMMON_OBS): Add format.o.
	* common/format.h: New file.
	* common/format.c: New file.
	* printcmd.c: Include format.h.
	(ui_printf): Call parse_format_string.
	* remote.c (remote_state): New field breakpoint_commands.
	(PACKET_BreakpointCommands): New enum.
	(remote_breakpoint_commands_feature): New function.
	(remote_protocol_features): Add new BreakpointCommands entry.
	(remote_can_run_breakpoint_commands): New function.
	(remote_add_target_side_commands): New function.
	(remote_insert_breakpoint): Call it.
	(remote_insert_hw_breakpoint): Ditto.
	(_initialize_remote): Add new packet configuration for
	target-side breakpoint commands.
	* target.h (struct target_ops): New field
	to_can_run_breakpoint_commands.
	(target_can_run_breakpoint_commands): New macro.
	* target.c (update_current_target): Handle
	to_can_run_breakpoint_commands.

	[gdbserver]
	* Makefile.in (WARN_CFLAGS_NO_FORMAT): Define.
	(ax.o): Add it to build rule.
	(ax-ipa.o): Ditto.
	(OBS): Add format.o.
	(IPA_OBS): Add format.o.
	* server.c (handle_query): Claim support for breakpoint commands.
	(process_point_options): Add command case.
	(process_serial_event): Leave running if there are printfs in
	effect.
	* mem-break.h (any_persistent_commands): Declare.
	(add_breakpoint_commands): Declare.
	(gdb_no_commands_at_breakpoint): Declare.
	(run_breakpoint_commands): Declare.
	* mem-break.c (struct point_command_list): New struct.
	(struct breakpoint): New field command_list.
	(any_persistent_commands): New function.
	(add_commands_to_breakpoint): New function.
	(add_breakpoint_commands): New function.
	(gdb_no_commands_at_breakpoint): New function.
	(run_breakpoint_commands): New function.
	* linux-low.c (linux_wait_1): Test for and run breakpoint commands
	locally.
	* ax.c: Include format.h.
	(ax_printf): New function.
	(gdb_eval_agent_expr): Add printf opcode.

	[doc]
	* gdb.texinfo (Dynamic Printf): Mention agent style and
	disconnected dprintf.
	(Maintenance Commands): Describe maint agent-printf.
	(General Query Packets): Mention BreakpointCommands feature.
	(Packets): Document commands extension to Z0 packet.
	* agentexpr.texi (Bytecode Descriptions): Document printf
	bytecode.

	[testsuite]
	* gdb.base/dprintf.exp: Add agent style tests.
@
text
@a11087 17
/* A helper function that looks for an argument at the start of a
   string.  The argument must also either be at the end of the string,
   or be followed by whitespace.  Returns 1 if it finds the argument,
   0 otherwise.  If the argument is found, it updates *STR.  */

static int
check_for_argument (char **str, char *arg, int arg_len)
{
  if (strncmp (*str, arg, arg_len) == 0
      && ((*str)[arg_len] == '\0' || isspace ((*str)[arg_len])))
    {
      *str += arg_len;
      return 1;
    }
  return 0;
}

@


1.688
log
@2012-07-02  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* breakpoint.c (BREAK_ARGS_HELP): Include help message for the new
	`-probe' and `-probe-stap' options.
@
text
@d73 2
d306 39
d2176 190
d2406 2
a2407 1
      /* Reset the condition modification marker.  */
d2926 3
d6065 9
a8771 34
/* The style in which to perform a dynamic printf.  This is a user
   option because different output options have different tradeoffs;
   if GDB does the printing, there is better error handling if there
   is a problem with any of the arguments, but using an inferior
   function lets you have special-purpose printers and sending of
   output to the same place as compiled-in print functions.  (Future
   styles may include the ability to do a target-side printf.)  */

static const char dprintf_style_gdb[] = "gdb";
static const char dprintf_style_call[] = "call";
static const char *const dprintf_style_enums[] = {
  dprintf_style_gdb,
  dprintf_style_call,
  NULL
};
static const char *dprintf_style = dprintf_style_gdb;

/* The function to use for dynamic printf if the preferred style is to
   call into the inferior.  The value is simply a string that is
   copied into the command, so it can be anything that GDB can
   evaluate to a callable address, not necessarily a function name.  */

static char *dprintf_function = "";

/* The channel to use for dynamic printf if the preferred style is to
   call into the inferior; if a nonempty string, it will be passed to
   the call as the first argument, with the format string as the
   second.  As with the dprintf function, this can be anything that
   GDB knows how to evaluate, so in addition to common choices like
   "stderr", this could be an app-specific expression like
   "mystreams[curlogger]".  */

static char *dprintf_channel = "";

d8795 1
a8795 1
  if (strcmp (dprintf_style, "gdb") == 0)
d8797 1
a8797 1
  else if (strcmp (dprintf_style, "call") == 0)
d8812 10
d8831 9
a8839 6
      cont_cmd_line = xmalloc (sizeof (struct command_line));
      cont_cmd_line->control_type = simple_control;
      cont_cmd_line->body_count = 0;
      cont_cmd_line->body_list = NULL;
      cont_cmd_line->next = NULL;
      cont_cmd_line->line = xstrdup ("continue");
d9796 6
d16476 14
@


1.687
log
@gdb:
	* breakpoint.c: Removed always_inserted_auto, always_inserted_on,
	always_inserted_off, and always_inserted_enums.
	Change always_inserted_mode's type to 'enum auto_boolean'.
	(show_always_inserted_mode, breakpoint_always_inserted_mode): Update
	callers.
	(_initialize_breakpoint): Call add_setshow_auto_boolean_cmd instead
	of add_setshow_enum_cmd.
	* infrun.c: Remove can_use_displaced_stepping_auto,
	can_use_displaced_stepping_on, can_use_displaced_stepping_off, and
	can_use_displaced_stepping_enum.
	Change can_use_displaced_stepping's type to 'enum auto_boolean'.
	(show_can_use_displaced_stepping, use_displaced_stepping): Update callers.
	(_initialize_infrun): Call add_setshow_auto_boolean_cmd instead of
	add_setshow_enum_cmd.
@
text
@d15305 4
a15308 1
command" [LOCATION] [thread THREADNUM] [if CONDITION]\n\
@


1.686
log
@	* linespec.c: #include "stack.h".
	(decode_line_with_current_source): Moved here from symtab.c and
	renamed from decode_line_spec.  All callers updated.
	(decode_line_with_last_displayed): Moved here from breakpoint.c and
	renamed from decode_line_spec_1.  All callers updated.
	* linespec.h (decode_line_with_current_source): Move declaration here
	from symtab.h and renamed from decode_line_spec.
	(decode_line_with_last_displayed): Move declaration here from symtab.h
	and renamed from decode_line_spec_1.
	* macrocmd.c: #include "linespec.h".
	* symtab.c: Remove #include "linespec.h".
@
text
@d390 2
a391 10
static const char always_inserted_auto[] = "auto";
static const char always_inserted_on[] = "on";
static const char always_inserted_off[] = "off";
static const char *const always_inserted_enums[] = {
  always_inserted_auto,
  always_inserted_off,
  always_inserted_on,
  NULL
};
static const char *always_inserted_mode = always_inserted_auto;
d396 1
a396 1
  if (always_inserted_mode == always_inserted_auto)
d410 2
a411 2
  return (always_inserted_mode == always_inserted_on
	  || (always_inserted_mode == always_inserted_auto && non_stop));
d16156 2
a16157 2
  add_setshow_enum_cmd ("always-inserted", class_support,
			always_inserted_enums, &always_inserted_mode, _("\
d16168 4
a16171 4
			   NULL,
			   &show_always_inserted_mode,
			   &breakpoint_set_cmdlist,
			   &breakpoint_show_cmdlist);
@


1.685
log
@	PR macros/7961:
	* varobj.c (varobj_create): Update.
	(varobj_set_value): Update.
	* tracepoint.c (validate_actionline): Update.
	(encode_actions_1): Update.
	* parse.c (parse_exp_1): Add 'pc' argument.
	(parse_exp_in_context): Add 'pc' argument.  Change how
	expression_context_pc is set.
	(parse_expression): Update.
	(parse_field_expression): Update.
	* expression.h (parse_exp_1): Update.
	* eval.c (parse_to_comma_and_eval): Update.
	* breakpoint.c (set_breakpoint_condition): Update.
	(update_watchpoint): Update.
	(init_breakpoint_sal): Update
	(find_condition_and_thread): Update.
	(watch_command_1): Update.
	(update_breakpoint_locations): Update.
	* ada-lang.c (ada_read_renaming_var_value): Update.
	(create_excep_cond_exprs): Update.
testsuite
	* gdb.base/macscp1.c (macscp_expr): Add breakpoint comment.
	* gdb.base/macscp.exp (maybe_kfail): Add test for macro scope.
@
text
@d11535 3
a11537 2
      sals = decode_line_spec (arg, (DECODE_LINE_FUNFIRSTLINE
				     | DECODE_LINE_LIST_MODE));
a14497 21
/* Use the last displayed codepoint's values, or nothing
   if they aren't valid.  */

struct symtabs_and_lines
decode_line_spec_1 (char *string, int flags)
{
  struct symtabs_and_lines sals;

  if (string == 0)
    error (_("Empty line specification."));
  if (last_displayed_sal_is_valid ())
    sals = decode_line_1 (&string, flags,
			  get_last_displayed_symtab (),
			  get_last_displayed_line ());
  else
    sals = decode_line_1 (&string, flags, (struct symtab *) NULL, 0);
  if (*string)
    error (_("Junk at end of line specification: %s"), string);
  return sals;
}

@


1.684
log
@gdb/
	Remove stale dummy frames.
	* breakpoint.c: Include dummy-frame.h.
	(longjmp_breakpoint_ops): New variable.
	(update_breakpoints_after_exec, breakpoint_init_inferior): Delete also
	bp_longjmp_call_dummy.
	(bpstat_what, bptype_string, print_one_breakpoint_location)
	(init_bp_location): Support bp_longjmp_call_dummy.
	(set_longjmp_breakpoint): Use longjmp_breakpoint_ops.  Comment why.
	(set_longjmp_breakpoint_for_call_dummy)
	(check_longjmp_breakpoint_for_call_dummy, longjmp_bkpt_dtor): New
	functions.
	(initialize_breakpoint_ops): Initialize longjmp_breakpoint_ops.
	* breakpoint.h (enum bptype): New item bp_longjmp_call_dummy.  Delete
	FIXME comment and extend the other comment for bp_call_dummy.
	(set_longjmp_breakpoint_for_call_dummy)
	(check_longjmp_breakpoint_for_call_dummy): New declarations.
	* dummy-frame.c: Include gdbthread.h.
	(pop_dummy_frame_bpt): New function.
	(pop_dummy_frame): Call pop_dummy_frame_bpt.
	(dummy_frame_discard): New function.
	(cleanup_dummy_frames): Update the comment about longjmps.
	* dummy-frame.h (dummy_frame_discard): New declaration.
	* gdbthread.h (struct thread_info): Extend initiating_frame comment.
	* infcall.c (call_function_by_hand): New variable longjmp_b.  Call
	set_longjmp_breakpoint_for_call_dummy.  Chain its breakpoints with BPT.
	* infrun.c (handle_inferior_event) <BPSTAT_WHAT_CLEAR_LONGJMP_RESUME>:
	Add case 4 comment.  Call check_longjmp_breakpoint_for_call_dummy and
	keep_going if IS_LONGJMP and there is no other reason to stop.

gdb/testsuite/
	Remove stale dummy frames.
	* gdb.base/call-signal-resume.exp (maintenance print dummy-frames)
	(maintenance info breakpoints): New tests.
	* gdb.base/stale-infcall.c: New file.
	* gdb.base/stale-infcall.exp: New file.
@
text
@d929 1
a929 1
	  w->cond_exp = parse_exp_1 (&arg, 0, 0);
d942 2
a943 1
		parse_exp_1 (&arg, block_for_pc (loc->address), 0);
d1735 1
a1735 1
      b->exp = parse_exp_1 (&s, b->exp_valid_block, 0);
d1756 1
a1756 1
	  b->cond_exp = parse_exp_1 (&s, b->cond_exp_valid_block, 0);
d8769 2
a8770 1
	  loc->cond = parse_exp_1 (&arg, block_for_pc (loc->address), 0);
d9057 1
a9057 1
	  expr = parse_exp_1 (&tok, block_for_pc (pc), 0);
d10577 1
a10577 1
  exp = parse_exp_1 (&arg, 0, 0);
d10632 1
a10632 1
      cond = parse_exp_1 (&tok, 0, 0);
d13682 2
a13683 1
	      new_loc->cond = parse_exp_1 (&s, block_for_pc (sals.sals[i].pc), 
@


1.683
log
@	* breakpoint.c (condition_completer): New function.
	(_initialize_breakpoint): Use it.
	* value.c (complete_internalvar): New function.
	* value.h (complete_internalvar): Declare.
testsuite
	* gdb.base/condbreak.exp: Add tests for "condition" completion.
@
text
@d71 1
d291 3
d3211 1
d3503 1
d5163 1
d5166 1
a5166 1
	  retval.is_longjmp = bptype == bp_longjmp;
d5499 1
d5642 1
d6506 1
d6810 2
d6813 1
a6813 1
						  &momentary_breakpoint_ops);
d6847 69
d12905 16
d15509 5
@


1.682
log
@	* ada-lang.c (ada_make_symbol_completion_list): Return a VEC.
	* breakpoint.c (catch_syscall_completer): Return a VEC.
	* cli/cli-cmds.c (complete_command): Update.
	* cli/cli-decode.c (complete_on_cmdlist): Return a VEC.
	(complete_on_enum): Likewise.
	* command.h: Include gdb_vecs.h.
	(completer_ftype): Change return type.
	(complete_on_cmdlist, complete_on_enum): Likewise.
	* completer.c (noop_completer, filename_completer)
	(location_completer): Return a VEC.
	(add_struct_fields): Remove 'nextp' argument.  Change 'output'
	to a VEC.
	(expression_completer, complete_line_internal, complete_line)
	(command_completer): Return a VEC.
	(gdb_completion_word_break_characters, line_completion_function):
	Update.
	* completer.h: Include gdb_vecs.h.
	(complete_line, noop_completer, filename_completer)
	(expression_completer, location_completer, command_completer):
	Update.
	* f-lang.c (f_word_break_characters): Return a VEC.
	* interps.c (interpreter_completer): Return a VEC.
	* language.h (struct language_defn)
	<la_make_symbol_completion_list>: Return a VEC.
	* python/py-cmd.c (cmdpy_completer): Return a VEC.
	* symtab.c (free_completion_list): Take a VEC.
	(return_val_size, return_val_index): Remove.
	(return_val): Now a VEC.
	(completion_list_add_name): Update.
	(default_make_symbol_completion_list_break_on)
	(default_make_symbol_completion_list, make_symbol_completion_list)
	(make_symbol_completion_list_fn, make_file_symbol_completion_list):
	Return a VEC.
	(add_filename_to_list): Update.
	(struct add_partial_filename_data) <list_used, list_alloced>: Remove.
	<list>: Now a VEC.
	(maybe_add_partial_symtab_filename): Update.
	(make_source_files_completion_list): Return a VEC.
	* symtab.h (default_make_symbol_completion_list_break_on)
	(default_make_symbol_completion_list, make_symbol_completion_list)
	(make_symbol_completion_list_fn, make_file_symbol_completion_list)
	(make_source_files_completion_list): Update.
@
text
@d950 56
d15587 1
a15587 1
  add_com ("condition", class_breakpoint, condition_command, _("\
d15591 1
@


1.681
log
@	* breakpoint.c (add_catch_command): Use completer_ftype.
	* breakpoint.h: Include command.h.
	(add_catch_command): Use completer_ftype.
	* cli/cli-decode.c (set_cmd_completer): Use completer_ftype.
	* cli/cli-decode.h (struct cmd_list_element) <completer>:
	Use completer_ftype.
	* command.h (completer_ftype): New typedef.
	(set_cmd_completer): Use it.
	* python/py-cmd.c (struct cmdpy_completer) <completer>: Use
	completer_ftype.
@
text
@d14581 1
a14581 1
static char **
d14586 1
a14586 1
  char **retlist
@


1.680
log
@gdb/
	Fix regression by the "ambiguous linespec" series.
	* breakpoint.c (parse_breakpoint_sals): New variable cursal.  Use
	get_last_displayed_symtab and get_last_displayed_line and depending
	on CURSAL.

gdb/testsuite/
	Fix regression by the "ambiguous linespec" series.
	* gdb.base/break.exp (list marker1, break lineno, delete $bpnum): New
	tests.
@
text
@d15203 1
a15203 2
                   char **(*completer) (struct cmd_list_element *cmd,
                                         char *text, char *word),
@


1.679
log
@2012-06-05  Pedro Alves  <palves@@redhat.com>

	PR backtrace/13866

	* breakpoint.c (until_break_command): Only fetch the selected
	frame after decode_line_1.
@
text
@d8805 2
d8810 8
a8817 2
         time while leaving default_breakpoint_* alone.  */
      if (last_displayed_sal_is_valid ())
d8824 1
a8824 2
			  (struct symtab *) NULL, 0,
			  canonical, NULL, NULL);
@


1.678
log
@stop parsing breakpoint command if invalid keyword found

With an Ada program, trying to break on a specific Ada task, but
with the wrong capitalization of the `task' keyword, we currently
get only pieces of the "garbage" that caused the error:

    (gdb) b *rendez_vous'address TASK 2
    Garbage 2 at end of command

Pushing this a little further:

    (gdb) b *rendez_vous'address TASK Task TaSK 2
    Garbage 2 at end of command

Another interesting failure mode:

    (gdb) b *rendez_vous'address TASK if
    Argument required (expression to compute).

The parser skipped `TASK', then found the `if' keyword, and thus
started looking for a condition.

This patch fixes the problem by aborting the parsing as soon as
an invalid keyword is found.  This makes it consistent with the
case where the REST parameter is passed as NULL (where an error
is raised immediately after seeing the first invalid keyword).

It also introduces a new testcase that reproduces all above scenarios.

gdb/ChangeLog:

        * breakpoint.c (find_condition_and_thread): Stop parsing
        as soon as the first invalid keyword is found.

gdb/testsuite/ChangeLog:

        * gdb.ada/bad-task-bp-keyword: New testcase.
@
text
@d10818 4
a10821 4
  struct frame_info *frame = get_selected_frame (NULL);
  struct gdbarch *frame_gdbarch = get_frame_arch (frame);
  struct frame_id stack_frame_id = get_stack_frame_id (frame);
  struct frame_id caller_frame_id = frame_unwind_caller_id (frame);
d10857 9
a10865 2
  /* Installing a breakpoint invalidates the frame chain (as it may
     need to switch threads), so do any frame handling first.  */
@


1.677
log
@gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

gdb/gdbserver/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

include/gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        * gdb/signals.def: Replace TARGET_SIGNAL_ with GDB_SIGNAL_
	throughout.

sim/arm/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/avr/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/common/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/cr16/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/d10v/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/erc32/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/m32c/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/ppc/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/rl78/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/rx/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.
@
text
@d8943 1
a8943 1
	  tok += toklen;
@


1.676
log
@2012-05-18  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c:
	* avr-tdep.c:
	* ax-gdb.c:
	* bfin-linux-tdep.c:
	* breakpoint.c:
	* c-valprint.c:
	* cli/cli-cmds.c:
	* coffread.c:
	* cp-support.c:
	* cris-tdep.c:
	* dwarf2-frame-tailcall.c:
	* dwarf2-frame.c:
	* dwarf2expr.c:
	* dwarf2loc.c:
	* dwarf2read.c:
	* elfread.c:
	* eval.c:
	* expprint.c:
	* f-valprint.c:
	* frv-tdep.c:
	* h8300-tdep.c:
	* hppa-hpux-tdep.c:
	* hppa-tdep.c:
	* hppanbsd-tdep.c:
	* i386-nto-tdep.c:
	* i386-tdep.c:
	* i387-tdep.c:
	* ia64-tdep.c:
	* jit.c:
	* linespec.c:
	* linux-tdep.c:
	* lm32-tdep.c:
	* m2-valprint.c:
	* m32c-tdep.c:
	* m32r-rom.c:
	* m32r-tdep.c:
	* m68k-tdep.c:
	* m68klinux-tdep.c:
	* mi/mi-main.c:
	* microblaze-tdep.c:
	* mips-linux-tdep.c:
	* mips-tdep.c:
	* mn10300-tdep.c:
	* p-valprint.c:
	* parse.c:
	* ppc-linux-tdep.c:
	* ppc-sysv-tdep.c:
	* printcmd.c:
	* python/py-finishbreakpoint.c:
	* python/py-inferior.c:
	* python/py-infthread.c:
	* python/py-type.c:
	* python/python.c:
	* remote-fileio.c:
	* remote-m32r-sdi.c:
	* remote-mips.c:
	* reverse.c:
	* rl78-tdep.c:
	* rs6000-aix-tdep.c:
	* rs6000-tdep.c:
	* s390-tdep.c:
	* score-tdep.c:
	* sh64-tdep.c:
	* skip.c:
	* solib-darwin.c:
	* solib-dsbt.c:
	* solib-frv.c:
	* sparc-tdep.c:
	* spu-multiarch.c:
	* spu-tdep.c:
	* stack.c:
	* symfile.c:
	* symtab.c:
	* tic6x-tdep.c:
	* tracepoint.c:
	* v850-tdep.c:
	* valarith.c:
	* valprint.c:
	* value.c:
	* xcoffread.c:
	* xtensa-tdep.c:
	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c: Delete unused variables.
@
text
@d9445 1
a9445 1
      || ws->value.sig != TARGET_SIGNAL_TRAP)
d10894 1
a10894 1
  proceed (-1, TARGET_SIGNAL_DEFAULT, 0);
d12459 1
a12459 1
      || ws->value.sig != TARGET_SIGNAL_TRAP)
@


1.675
log
@	gdb/
	* breakpoint.h (bp_location): Add related_address member.
	* inferior.h (get_return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	* value.h (using_struct_return): Likewise.
	* gdbarch.sh (return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	* breakpoint.c (set_breakpoint_location_function): Initialize
	related_address for bp_gnu_ifunc_resolver breakpoints.
	* elfread.c (elf_gnu_ifunc_resolver_return_stop): Pass the
	requested function's address to gdbarch_return_value.
	* eval.c (evaluate_subexp_standard): Pass the requested
	function's address to using_struct_return.
	* infcall.c (call_function_by_hand): Pass the requested
	function's address to using_struct_return and
	gdbarch_return_value.
	* infcmd.c (get_return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	(print_return_value): Update accordingly.
	(finish_command_continuation): Likewise.
	* stack.c (return_command): Pass the requested function's
	address to using_struct_return and gdbarch_return_value.
	* value.c (using_struct_return): Take a pointer to struct value
	instead of struct type for the function requested.  Pass the
	requested function's address to gdbarch_return_value.
	* python/py-finishbreakpoint.c (finish_breakpoint_object):
	New function_value member, replacing function_type.
	(bpfinishpy_dealloc): Update accordingly.
	(bpfinishpy_pre_stop_hook): Likewise.
	(bpfinishpy_init): Likewise.  Record the requested function's
	address.
	* mips-tdep.c (mips_fval_reg): New enum.
	(mips_o32_push_dummy_call): For MIPS16 FP doubles do not swap
	words put in GP registers.
	(mips_o64_push_dummy_call): Update a comment.
	(mips_o32_return_value): Take a pointer to struct value instead
	of struct type for the function requested and use it to check if
	using the MIPS16 calling convention.  Return the designated
	general purpose registers for floating-point values returned in
	MIPS16 mode.
	(mips_o64_return_value): Likewise.
	* ppc-tdep.h (ppc_sysv_abi_return_value): Update prototype.
	(ppc_sysv_abi_broken_return_value): Likewise.
	(ppc64_sysv_abi_return_value): Likewise.
	* alpha-tdep.c (alpha_return_value): Take a pointer to struct
	value instead of struct type for the function requested.
	* amd64-tdep.c (amd64_return_value): Likewise.
	* amd64-windows-tdep.c (amd64_windows_return_value): Likewise.
	* arm-tdep.c (arm_return_value): Likewise.
	* avr-tdep.c (avr_return_value): Likewise.
	* bfin-tdep.c (bfin_return_value): Likewise.
	* cris-tdep.c (cris_return_value): Likewise.
	* frv-tdep.c (frv_return_value): Likewise.
	* h8300-tdep.c (h8300_return_value): Likewise.
	(h8300h_return_value): Likewise.
	* hppa-tdep.c (hppa32_return_value): Likewise.
	(hppa64_return_value): Likewise.
	* i386-tdep.c (i386_return_value): Likewise.
	* ia64-tdep.c (ia64_return_value): Likewise.
	* iq2000-tdep.c (iq2000_return_value): Likewise.
	* lm32-tdep.c (lm32_return_value): Likewise.
	* m32c-tdep.c (m32c_return_value): Likewise.
	* m32r-tdep.c (m32r_return_value): Likewise.
	* m68hc11-tdep.c (m68hc11_return_value): Likewise.
	* m68k-tdep.c (m68k_return_value): Likewise.
	(m68k_svr4_return_value): Likewise.
	* m88k-tdep.c (m88k_return_value): Likewise.
	* mep-tdep.c (mep_return_value): Likewise.
	* microblaze-tdep.c (microblaze_return_value): Likewise.
	* mn10300-tdep.c (mn10300_return_value): Likewise.
	* moxie-tdep.c (moxie_return_value): Likewise.
	* mt-tdep.c (mt_return_value): Likewise.
	* ppc-linux-tdep.c (ppc_linux_return_value): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_return_value): Likewise.
	(ppc_sysv_abi_broken_return_value): Likewise.
	(ppc64_sysv_abi_return_value): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_return_value): Likewise.
	* rl78-tdep.c (rl78_return_value): Likewise.
	* rs6000-aix-tdep.c (rs6000_return_value): Likewise.
	* rx-tdep.c (rx_return_value): Likewise.
	* s390-tdep.c (s390_return_value): Likewise.
	* score-tdep.c (score_return_value): Likewise.
	* sh-tdep.c (sh_return_value_nofpu): Likewise.
	(sh_return_value_fpu): Likewise.
	* sh64-tdep.c (sh64_return_value): Likewise.
	* sparc-tdep.c (sparc32_return_value): Likewise.
	* sparc64-tdep.c (sparc64_return_value): Likewise.
	* spu-tdep.c (spu_return_value): Likewise.
	* tic6x-tdep.c (tic6x_return_value): Likewise.
	* v850-tdep.c (v850_return_value): Likewise.
	* vax-tdep.c (vax_return_value): Likewise.
	* xstormy16-tdep.c (xstormy16_return_value): Likewise.
	* xtensa-tdep.c (xtensa_return_value): Likewise.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.

	gdb/testsuite/
	* gdb.base/return-nodebug.exp: Also test float and double types.
@
text
@a754 1
  struct breakpoint *b;
a7461 1
  regex_t compiled;
a7728 1
  char *syscall_id;
a8956 2
  struct symtab_and_line sal;
  struct symbol *sym;
a9025 1
  int i;
a13336 1
  int i;
@


1.674
log
@init_breakpoint_sal: Add quotes around part of command in error message

gdb/ChangeLog:

        * breakpoint.c (init_breakpoint_sal): Add quotes around part
        of command in two error message.
@
text
@d6601 1
d6604 1
a6604 1
					  NULL, NULL, &is_gnu_ifunc);
d6625 3
@


1.673
log
@Remove trailing spaces in breakpoint.c:init_breakpoint_sal

gdb/ChangeLog:

        * breakpoint.c (init_breakpoint_sal): Remove trailing spaces.
@
text
@d8632 1
a8632 1
              error (_("Garbage %s follows condition"), arg);
d8645 1
a8645 1
	error (_("Garbage %s at end of command"), b->extra_string);
@


1.672
log
@Minor style fixes in breakpoint.c:find_condition_and_thread

Mostly removing trailing spaces at end of lines, and also adding
an empty line after the function's documentation.

gdb/ChangeLog:

        * breakpoint.c (find_condition_and_thread): Minor reformatting.
@
text
@d8567 1
a8567 1
  
d8646 1
a8646 1
    }   
@


1.671
log
@2012-05-14  Stan Shebs  <stan@@codesourcery.com>

	Add dynamic printf.
	* breakpoint.h (enum bptype): New type bp_dprintf.
	(struct breakpoint): New field extra_string.
	(struct breakpoint_ops): Add arg to create_breakpoints_sal.
	(create_breakpoint): Add extra_string arg.
	* breakpoint.c (dprintf_breakpoint_ops): New.
	(is_breakpoint): Add bp_dprintf.
	(bpstat_what): Add dprintf case.
	(bptype_string): Ditto.
	(print_one_breakpoint_location): Ditto.
	(init_bp_location): Ditto.
	(bkpt_print_mention): Ditto.
	(dprintf_style_enums): New array.
	(dprintf_style): New global.
	(dprintf_function): New global.
	(dprintf_channel): New global.
	(update_dprintf_command_list): New function.
	(update_dprintf_commands): New function.
	(init_breakpoint_sal): Add extra_string argument, handle it.
	(create_breakpoint_sal): Add extra_string argument.
	(create_breakpoints_sal): Add extra_string argument, update callers.
	(find_condition_and_thread): Add extra argument.
	(create_breakpoint): Add extra_string argument, record it.
	(dprintf_command): New function.
	(break_command_1): Add arg to create_breakpoint call.
	(handle_gnu_v3_exceptions): Ditto.
	(trace_command): Ditto.
	(ftrace_command): Ditto.
	(strace_command): Ditto.
	(bkpt_print_mention): Add dprintf case.
	(create_breakpoint_sal_default): Add extra_string argument.
	(_initialize_breakpoint): Add new commands.
	* mi/mi-cmd-break.c (mi_cmd_break_insert): Add arg to call.
	* python/py-breakpoint.c (bppy_init): Ditto.
	* python/py-finishbreakpoint.c (bpfinishpy_init): Ditto.

	* gdb.texinfo (Dynamic Printf): New subsection.

	* gdb.base/dprintf.c: New file.
	* gdb.base/dprintf.exp: New file.
@
text
@d8878 3
a8880 2
static void 
find_condition_and_thread (char *tok, CORE_ADDR pc, 
d8902 1
a8902 1
      
d8904 1
a8904 1
      
d8913 1
a8913 2
	  *cond_string = savestring (cond_start, 
				     cond_end - cond_start);
d8918 1
a8918 1
	  
@


1.670
log
@2012-04-27  Sergio Durigan Junior  <sergiodj@@redhat.com>
	    Tom Tromey  <tromey@@redhat.com>

	* breakpoint.c (struct breakpoint_objfile_data)
	<longjmp_searched>,<longjmp_probes>,<exception_searched>,
	<exception_probes>: New fields.
	(free_breakpoint_probes): New function.
	(create_longjmp_master_breakpoint): Prefer SystemTap probe over
	`_Unwind_DebugHook'.
	(create_exception_master_breakpoint): Likewise.
	(_initialize_breakpoint): Registering cleanup for SystemTap probes.
	* infrun.c: Including necessary header files for handling SystemTap
	probes.
	(handle_inferior_event): Handling longjmp breakpoint and exceptions
	via SystemTap probes.
	(check_exception_resume): Remove `func' argument.  Handle exception
	unwinding breakpoint set via a SystemTap probe.
	(insert_exception_resume_from_probe): New function.
@
text
@d112 1
a112 1
					    char *, enum bptype,
d297 3
d1500 2
a1501 1
	  || bpt->type == bp_hardware_breakpoint);
d5185 5
d5454 1
d5595 1
d6458 1
d8397 103
d8501 12
d8522 1
d8569 1
d8634 12
d8663 1
d8687 1
a8687 1
		       filter, cond_string,
d8716 1
a8716 1
			char *cond_string,
d8742 2
a8743 1
			     cond_string, type, disposition,
d8880 2
a8881 1
			   char **cond_string, int *thread, int *task)
d8893 7
a8899 1
      
d8939 5
d9011 2
a9012 1
		   char *arg, char *cond_string, int thread,
d9134 1
d9141 1
d9143 1
a9143 1
                                       &thread, &task);
d9146 4
d9159 6
d9168 1
a9168 1
				   cond_string, type_wanted,
d9193 1
d9249 1
a9249 1
		     NULL, 0, 1 /* parse arg */,
d9414 23
d11148 1
a11148 1
		     trigger_func_name, cond_string, -1,
d12377 1
d12540 3
d12583 1
d12593 2
a12594 1
				  cond_string, type_wanted,
d12906 1
d12916 2
a12917 1
				  cond_string, type_wanted,
d12981 1
d13015 2
a13016 1
			   cond_string, type_wanted, disposition,
d13643 1
d13646 2
a13647 1
				     &cond_string, &thread, &task);
d13652 2
d13721 1
d13731 1
d14605 1
a14605 1
			 NULL, 0, 1 /* parse arg */,
d14622 1
a14622 1
			 NULL, 0, 1 /* parse arg */,
d14650 1
a14650 1
			 NULL, 0, 1 /* parse arg */,
d14715 2
a14716 1
			  utp->cond_string, -1, 0 /* parse cond/thread */,
d15472 8
d16062 38
@


1.669
log
@2012-04-27  Sergio Durigan Junior  <sergiodj@@redhat.com>
	    Tom Tromey  <tromey@@redhat.com>
	    Jan Kratochvil  <jan.kratochvil@@redhat.com>

	* Makefile.in (SFILES): Add `probe' and `stap-probe'.
	(COMMON_OBS): Likewise.
	(HFILES_NO_SRCDIR): Add `probe'.
	* NEWS: Mention support for static and SystemTap probes.
	* amd64-tdep.c (amd64_init_abi): Initializing proper fields used by
	SystemTap probes' arguments parser.
	* arm-linux-tdep.c: Including headers needed to perform the parsing
	of SystemTap probes' arguments.
	(arm_stap_is_single_operand): New function.
	(arm_stap_parse_special_token): Likewise.
	(arm_linux_init_abi): Initializing proper fields used by SystemTap
	probes' arguments parser.
	* ax-gdb.c (require_rvalue): Removing static declaration.
	(gen_expr): Likewise.
	* ax-gdb.h (gen_expr): Declaring function.
	(require_rvalue): Likewise.
	* breakpoint.c: Include `gdb_regex.h' and `probe.h'.
	(bkpt_probe_breakpoint_ops): New variable.
	(momentary_breakpoint_from_master): Set the `probe' value.
	(add_location_to_breakpoint): Likewise.
	(break_command_1): Using proper breakpoint_ops according to the
	argument passed by the user in the command line.
	(bkpt_probe_insert_location): New function.
	(bkpt_probe_remove_location): Likewise.
	(bkpt_probe_create_sals_from_address): Likewise.
	(bkpt_probe_decode_linespec): Likewise.
	(tracepoint_probe_create_sals_from_address): Likewise.
	(tracepoint_probe_decode_linespec): Likewise.
	(tracepoint_probe_breakpoint_ops): New variable.
	(trace_command): Using proper breakpoint_ops according to the
	argument passed by the user in the command line.
	(initialize_breakpoint_ops): Initializing breakpoint_ops for
	static probes on breakpoints and tracepoints.
	* breakpoint.h (struct bp_location) <probe>: New field.
	* cli-utils.c (skip_spaces_const): New function.
	(extract_arg): Likewise.
	* cli-utils.h (skip_spaces_const): Likewise.
	(extract_arg): Likewise.
	* coffread.c (coff_sym_fns): Add `sym_probe_fns' value.
	* configure.ac: Append `stap-probe.o' to be generated when ELF
	support is present.
	* configure: Regenerate.
	* dbxread.c (aout_sym_fns): Add `sym_probe_fns' value.
	* elfread.c: Include `probe.h' and `arch-utils.h'.
	(probe_key): New variable.
	(elf_get_probes): New function.
	(elf_get_probe_argument_count): Likewise.
	(elf_evaluate_probe_argument): Likewise.
	(elf_compile_to_ax): Likewise.
	(elf_symfile_relocate_probe): Likewise.
	(stap_probe_key_free): Likewise.
	(elf_probe_fns): New variable.
	(elf_sym_fns): Add `sym_probe_fns' value.
	(elf_sym_fns_lazy_psyms): Likewise.
	(elf_sym_fns_gdb_index): Likewise.
	(_initialize_elfread): Initialize objfile cache for static
	probes.
	* gdb_vecs.h (struct probe): New forward declaration.
	(probe_p): New VEC declaration.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* gdbarch.sh (stap_integer_prefix): New variable.
	(stap_integer_suffix): Likewise.
	(stap_register_prefix): Likewise.
	(stap_register_suffix): Likewise.
	(stap_register_indirection_prefix): Likewise.
	(stap_register_indirection_suffix): Likewise.
	(stap_gdb_register_prefix): Likewise.
	(stap_gdb_register_suffix): Likewise.
	(stap_is_single_operand): New function.
	(stap_parse_special_token): Likewise.
	(struct stap_parse_info): Forward declaration.
	* i386-tdep.c: Including headers needed to perform the parsing
	of SystemTap probes' arguments.
	(i386_stap_is_single_operand): New function.
	(i386_stap_parse_special_token): Likewise.
	(i386_elf_init_abi): Initializing proper fields used by SystemTap
	probes' arguments parser.
	* i386-tdep.h (i386_stap_is_single_operand): New function.
	(i386_stap_parse_special_token): Likewise.
	* machoread.c (macho_sym_fns): Add `sym_probe_fns' value.
	* mipsread.c (ecoff_sym_fns): Likewise.
	* objfiles.c (objfile_relocate1): Support relocation for static
	probes.
	* parse.c (prefixify_expression): Remove static declaration.
	(initialize_expout): Likewise.
	(reallocate_expout): Likewise.
	* parser-defs.h (initialize_expout): Declare function.
	(reallocate_expout): Likewise.
	(prefixify_expression): Likewise.
	* ppc-linux-tdep.c: Including headers needed to perform the parsing
	of SystemTap probes' arguments.
	(ppc_stap_is_single_operand): New function.
	(ppc_stap_parse_special_token): Likewise.
	(ppc_linux_init_abi): Initializing proper fields used by SystemTap
	probes' arguments parser.
	* probe.c: New file, for generic statically defined probe support.
	* probe.h: Likewise.
	* s390-tdep.c: Including headers needed to perform the parsing of
	SystemTap probes' arguments.
	(s390_stap_is_single_operand): New function.
	(s390_gdbarch_init): Initializing proper fields used by SystemTap
	probes' arguments parser.
	* somread.c (som_sym_fns): Add `sym_probe_fns' value.
	* stap-probe.c: New file, for SystemTap probe support.
	* stap-probe.h: Likewise.
	* symfile.h: Include `gdb_vecs.h'.
	(struct sym_probe_fns): New struct.
	(struct sym_fns) <sym_probe_fns>: New field.
	* symtab.c (init_sal): Initialize `probe' field.
	* symtab.h (struct probe): Forward declaration.
	(struct symtab_and_line) <probe>: New field.
	* tracepoint.c (start_tracing): Adjust semaphore on breakpoints
	locations.
	(stop_tracing): Likewise.
	* xcoffread.c (xcoff_sym_fns): Add `sym_probe_fns' value.
@
text
@d2747 6
d2758 6
d2800 9
d2885 31
d3026 34
@


1.668
log
@gdb:
	Revert this patch to allow breakpoint always-inserted
	in record target.
	2011-12-05  Pedro Alves  <pedro@@codesourcery.com>
        * breakpoint.c: Include record.h.
        (breakpoints_always_inserted_mode): Return false when the record
        target is in use.

	* breakpoint.c (iterate_over_bp_locations): New.
	* breakpoint.h: Declare.
	New typedef walk_bp_location_callback.
	* record.c (record_open): Call record_init_record_breakpoints.
	(record_sync_record_breakpoints): New.
	(record_init_record_breakpoints): New.
	* NEWS: Mention supporting breakpoint always-inserted mode in
	record target.
@
text
@d63 2
d294 3
d8157 1
d8243 1
d8983 8
d8998 1
a8998 1
		     &bkpt_breakpoint_ops,
d12472 51
d12646 24
d14301 8
d14316 1
a14316 1
			 &tracepoint_breakpoint_ops,
d15051 8
d15106 6
d15190 2
a15191 1
  breakpoint_objfile_key = register_objfile_data ();
@


1.667
log
@gdb/
	* breakpoint.c (ep_is_catchpoint): Renamed to ...
	(is_catchpoint): ... it.
	(print_one_breakpoint_location): Caller update.
	* breakpoint.h: Update declaration.
@
text
@a66 1
#include "record.h"
d406 2
a407 3
  return ((always_inserted_mode == always_inserted_on
	   || (always_inserted_mode == always_inserted_auto && non_stop))
	  && !RECORD_IS_USED);
d2426 13
@


1.666
log
@2012-03-27  Pedro Alves  <palves@@redhat.com>

	Eliminate struct ui_stream.

	* ui-out.h (struct ui_stream): Delete.
	(ui_out_field_stream): Adjust prototype.
	(ui_out_stream_new, ui_out_stream_delete)
	(make_cleanup_ui_out_stream_delete): Delete declarations.
	* ui-out.c (ui_out_field_stream): Change prototype to take a
	ui_file instead of a ui_stream.  Adjust.
	(ui_out_stream_new, ui_out_stream_delete, do_stream_delete)
	(make_cleanup_ui_out_stream_delete): Delete.
	* breakpoint.c (print_breakpoint_location)
	(print_one_detail_ranged_breakpoint, print_it_watchpoint): Use
	ui_file/mem_fileopen instead of ui_stream/ui_out_stream_new.
	* disasm.c (dump_insns): Ditto.
	(do_mixed_source_and_assembly, do_assembly_only): Adjust
	prototype.
	(gdb_disassembly): Use ui_file/mem_fileopen instead of
	ui_stream/ui_out_stream_new.
	* infcmd.c (print_return_value): Ditto.
	* osdata.c (info_osdata_command): Don't allocate a local
	ui_stream.
	* stack.c (print_frame_arg, print_frame_args, print_frame): Use
	ui_file/mem_fileopen instead of ui_stream/ui_out_stream_new.
	* tracepoint.c (print_one_static_tracepoint_marker): Don't
	allocate a local ui_stream.
	* mi/mi-cmd-stack.c (list_arg_or_local): Use ui_file/mem_fileopen
	instead of ui_stream/ui_out_stream_new.
	(list_args_or_locals): Don't allocate a local ui_stream.
	* mi/mi-main.c (get_register, mi_cmd_data_evaluate_expression)
	(mi_cmd_data_read_memory): Use ui_file/mem_fileopen instead of
	ui_stream/ui_out_stream_new.
	* cli/cli-setshow.c (do_setshow_command): Ditto.
@
text
@d3638 1
a3638 1
ep_is_catchpoint (struct breakpoint *ep)
d5603 1
a5603 1
      if (ep_is_catchpoint (b))
@


1.665
log
@Problem after hitting breakpoint on Windows (with GDBserver)

When debugging on Windows with GDBserver, the debugger starts
failing after hitting a breakpoint.  For instance:

    (gdb) b foo
    Breakpoint 1 at 0x40177e: file foo.adb, line 5.
    (gdb) cont
    Continuing.

    Breakpoint 1, foo () at foo.adb:5
    5          Put_Line ("Hello World.");  -- STOP
    (gdb) n

    Program received signal SIGSEGV, Segmentation fault.
    0x00401782 in foo () at foo.adb:5
    5          Put_Line ("Hello World.");  -- STOP

There are two issues:

  1. While trying to re-insert a breakpoint that is still inserted
     in memory, insert_bp_location wipes out the breakpoint location's
     shadow_contents.  As a consequence, we cannot restore the proper
     instruction when removing the breakpoint anymore.  That's why
     the inferior's behavior changes when trying to resume after
     the breakpoint was hit.

  2. mem-break.c:default_memory_insert_breakpoint passes a breakpoint
     location's shadow_contents as the buffer for a memory read.
     This reveals a limitation of the various memory-read target
     functions.  This patch documents this limitation and adjust
     the two calls that seem to hit that limitation.

gdb/ChangeLog:

        * breakpoint.c (breakpoint_xfer_memory): Add assertion.
        Update function description.
        (insert_bp_location): Do not wipe bl->target_info out.
        * mem-break.c: #include "gdb_string.h".
        (default_memory_insert_breakpoint): Do not call target_read_memory
        with a pointer to the breakpoint's shadow_contents buffer.  Use
        a local buffer instead.
        * m32r-tdep.c (m32r_memory_insert_breakpoint): Ditto.
@
text
@d5280 2
a5281 2
      struct ui_stream *stb = ui_out_stream_new (uiout);
      struct cleanup *stb_chain = make_cleanup_ui_out_stream_delete (stb);
d5283 1
a5283 1
      print_address_symbolic (loc->gdbarch, loc->address, stb->stream,
d9225 2
a9226 2
  struct ui_stream *stb = ui_out_stream_new (uiout);
  struct cleanup *cleanup = make_cleanup_ui_out_stream_delete (stb);
d9234 1
a9234 1
  fprintf_unfiltered (stb->stream, "[%s, %s]",
d9669 1
a9669 1
  struct ui_stream *stb;
d9680 2
a9681 2
  stb = ui_out_stream_new (uiout);
  old_chain = make_cleanup_ui_out_stream_delete (stb);
d9695 1
a9695 1
      watchpoint_value_print (bs->old_val, stb->stream);
d9698 1
a9698 1
      watchpoint_value_print (w->val, stb->stream);
d9713 1
a9713 1
      watchpoint_value_print (w->val, stb->stream);
d9730 1
a9730 1
	  watchpoint_value_print (bs->old_val, stb->stream);
d9744 1
a9744 1
      watchpoint_value_print (w->val, stb->stream);
@


1.664
log
@2012-03-13  Hui Zhu  <teawater@@gmail.com>
	    Pedro Alves  <palves@@redhat.com>

	* breakpoint.c (init_breakpoint_sal): New flags parameter.  Handle
	CREATE_BREAKPOINT_FLAGS_INSERTED.
	(create_breakpoint_sal, create_breakpoints_sal)
	(base_breakpoint_create_breakpoints_sal)
	(tracepoint_create_breakpoints_sal)
	(strace_marker_create_breakpoints_sal): New flags parameter.  Pass
	down.
	(break_command_1, handle_gnu_v3_exceptions, trace_command)
	(ftrace_command, strace_command): Adjust.
	(create_tracepoint_from_upload): Pass
	CREATE_BREAKPOINT_FLAGS_INSERTED.
	* breakpoint.h (enum breakpoint_create_flags): New.
	(create_breakpoint): New flags parameter.
	* mi/mi-cmd-break.c (mi_cmd_break_insert): Adjust.
	* python/py-breakpoint.c (bppy_init): Adjust.
	* python/py-finishbreakpoint.c (bpfinishpy_init): Adjust.
	* spu-tdep.c (spu_catch_start): Adjust.
@
text
@d1321 4
d1453 6
d2095 9
a2103 2
  /* Initialize the target-specific information.  */
  memset (&bl->target_info, 0, sizeof (bl->target_info));
@


1.663
log
@gdb:

	* inferior.h (struct inferior): Remove fields any_syscall_count,
	syscalls_counts and total_syscalls_count.  Move them to new
	struct catch_syscall_inferior_data in breakpoint.c.
	* breakpoint.c: Call DEF_VEC_I(int).
	(struct catch_syscall_inferior_data): New.
	(get_catch_syscall_inferior_data): New.
	(catch_syscall_inferior_data_cleanup): New.
	(insert_catch_syscall): Update to access data in
	struct catch_syscall_inferior_data.
	(insert_catch_syscall): Likewise.
	(remove_catch_syscall): Likewise.
	(remove_catch_syscall): Likewise.
	(is_syscall_catchpoint_enabled): Likewise.
	(add_catch_command): Likewise.
	(_initialize_breakpoint): Register cleanup.
	* breakpoint.h: Removed DEF_VEC_I(int).
	* dwarf2loc.c: Call DEF_VEC_I(int).
	* mi/mi-main.c: Likewise.
@
text
@d115 1
a115 1
					    int, int, int);
d8277 2
a8278 1
		     int enabled, int internal, int display_canonical)
d8324 3
d8370 2
d8404 2
a8405 1
		       int enabled, int internal, int display_canonical)
d8428 2
a8429 1
		       enabled, internal, display_canonical);
d8457 1
a8457 1
			int enabled, int internal)
d8481 1
a8481 1
			     from_tty, enabled, internal,
d8741 2
a8742 1
		   int from_tty, int enabled, int internal)
d8882 1
a8882 1
				   from_tty, enabled, internal);
d8958 2
a8959 1
		     0 /* internal */);
d10834 2
a10835 1
		     0 /* internal */);
d12062 1
a12062 1
					int internal)
d12264 1
a12264 1
			     int internal)
d12270 1
a12270 1
				  enabled, internal);
d12534 1
a12534 1
				   int internal)
d12540 1
a12540 1
				  enabled, internal);
d12583 1
a12583 1
				      int internal)
d12612 1
a12612 1
			   from_tty, enabled, internal,
d13317 1
a13317 1
				int internal)
d13322 1
a13322 1
			  enabled, internal);
d14193 1
a14193 1
			 0 /* internal */))
d14210 1
a14210 1
			 0 /* internal */))
d14238 1
a14238 1
			 0 /* internal */))
d14303 2
a14304 1
			  0 /* internal */))
@


1.662
log
@Fix thinko in help of "set breakpoint condition-evaluation".

The 3 valid values for this setting are "auto", "host" and "target".
The help was advertising one of them to be "gdb" instead of "host".

gdb/ChangeLog:

        * breakpoint.c (_initialize_breakpoint): Fix error in help of
        "set breakpoint condition-evaluation" command.
@
text
@d7377 2
d7410 41
d7459 2
d7462 1
a7462 1
  ++inf->total_syscalls_count;
d7464 1
a7464 1
    ++inf->any_syscall_count;
d7475 1
a7475 1
	  if (iter >= VEC_length (int, inf->syscalls_counts))
d7477 1
a7477 1
              int old_size = VEC_length (int, inf->syscalls_counts);
d7481 4
a7484 3
              VEC_safe_grow (int, inf->syscalls_counts, iter + 1);
              vec_addr = (uintptr_t) VEC_address (int, inf->syscalls_counts) +
		vec_addr_offset;
d7488 2
a7489 2
          elem = VEC_index (int, inf->syscalls_counts, iter);
          VEC_replace (int, inf->syscalls_counts, iter, ++elem);
d7494 6
a7499 4
					inf->total_syscalls_count != 0,
					inf->any_syscall_count,
					VEC_length (int, inf->syscalls_counts),
					VEC_address (int, inf->syscalls_counts));
d7510 2
d7513 1
a7513 1
  --inf->total_syscalls_count;
d7515 1
a7515 1
    --inf->any_syscall_count;
d7525 1
a7525 1
	  if (iter >= VEC_length (int, inf->syscalls_counts))
d7528 2
a7529 2
          elem = VEC_index (int, inf->syscalls_counts, iter);
          VEC_replace (int, inf->syscalls_counts, iter, --elem);
d7534 4
a7537 3
					inf->total_syscalls_count != 0,
					inf->any_syscall_count,
					VEC_length (int, inf->syscalls_counts),
d7539 1
a7539 1
						     inf->syscalls_counts));
d14114 2
a14115 1
  struct inferior *inf = current_inferior ();
d14117 1
a14117 1
  return inf->total_syscalls_count != 0;
d14782 6
a14787 3
  inf->total_syscalls_count = 0;
  inf->any_syscall_count = 0;
  VEC_free (int, inf->syscalls_counts);
d15040 3
@


1.661
log
@gdb/
	* breakpoint.c (set_condition_evaluation_mode): Set
	CONDITION_EVALUATION_MODE unconditionally.

gdb/testsuite/
	Implement testsuite workaround for PR breakpoints/13781.
	* gdb.cp/mb-templates.exp: New loop with variable $workaround.
	(set breakpoint condition-evaluation host): New conditional command.
@
text
@d15520 1
a15520 1
When this is set to \"gdb\", breakpoint conditions will be\n\
@


1.660
log
@2012-03-02  Tom Tromey  <tromey@@redhat.com>
	    Pedro Alves  <palves@@redhat.com>

	PR breakpoints/13776:
	* breakpoint.c (breakpoint_init_inferior): Delete step-resume
	breakpoints.
	(delete_longjmp_breakpoint_at_next_stop): New.
	* breakpoint.h (delete_longjmp_breakpoint_at_next_stop): Declare.
	* target.c (generic_mourn_inferior): Call mark_breakpoints_out
	before deleting the inferior.  Add comments.
	* thread.c (clear_thread_inferior_resources): Don't delete lonjmp
	breakpoints immediately, but only on next stop.  Move that code
	next to where we mark other breakpoints for deletion.
@
text
@d764 4
a778 3
      /* Flip the switch.  */
      condition_evaluation_mode = condition_evaluation_mode_1;

@


1.659
log
@2012-03-01  Pedro Alves  <palves@@redhat.com>

	* amd64-linux-tdep.c (amd64_linux_record_signal): Make static.
	* breakpoint.c (create_exception_master_breakpoint, trace_command)
	(ftrace_command, strace_command): Make static.
	* d-lang.c (_initialize_d_language): Declare.
	* dwarf2expr.c (_initialize_dwarf2expr): Declare.
	* dwarf2loc.c (_initialize_dwarf2loc):
	* dwarf2read.c (process_psymtab_comp_unit): Make static.
	* exec.c (exec_get_section_table): Make static.
	* i386-linux-tdep.c (i386_linux_record_signal): Make static.
	* infcmd.c (ensure_valid_thread, ensure_not_tfind_mode): Make static.
	* inferior.c (remove_inferior_command, add_inferior_command)
	(clone_inferior_command): Make static.
	* linux-nat.c (linux_nat_thread_address_space)
	(linux_nat_core_of_thread): Make static.
	* linux-tdep.c (_initialize_linux_tdep): Declare.
	* objc-lang.c (_initialize_objc_lang): Declare.
	* opencl-lang.c (builtin_opencl_type, opencl_language_arch_info):
	Make static.
	(_initialize_opencl_language): Declare.
	* record.c (_initialize_record): Declare.
	* remote.c (demand_private_info, remote_get_tib_address)
	(remote_supports_cond_tracepoints)
	(remote_supports_fast_tracepoints, remote_get_tracepoint_status):
	Make static.
	* skip.c (_initialize_step_skip): Declare.
	* symtab.c (skip_prologue_using_lineinfo): Make static.
	* tracepoint.c (delete_trace_state_variable)
	(trace_variable_command, delete_trace_variable_command)
	(get_uploaded_tsv, find_matching_tracepoint_location)
	(find_matching_tsv, create_tsv_from_upload, get_traceframe_info):
	Make static.
	* value.c (pack_unsigned_long): Make static.
	* varobj.c (varobj_ensure_python_env): Make static.
	* windows-tdep.c (_initialize_windows_tdep): Declare.
	* xml-syscall.c (make_cleanup_free_syscalls_info): Make static.
@
text
@d3344 4
d6632 13
@


1.658
log
@gdb/
	* arm-linux-tdep.c (arm_linux_copy_svc): Reset stale FRAME.
	* breakpoint.c (until_break_command): Likewise.
	* elfread.c (elf_gnu_ifunc_resolver_stop): Likewise.
	* infcall.c (call_function_by_hand): Likewise.
	* infcmd.c (finish_forward): Likewise.
	* infrun.c (insert_exception_resume_breakpoint): Likewise.
@
text
@d2925 1
a2925 1
void
d14099 1
a14099 1
void
d14116 1
a14116 1
void
d14135 1
a14135 1
void
@


1.657
log
@2012-02-24  Jan Kratochvil  <jan.kratochvil@@redhat.com>
	    Pedro Alves  <palves@@redhat.com>

	* breakpoint.c (until_break_command): Install breakpoints after
	all frame manipulations.
@
text
@d10481 3
@


1.656
log
@2012-02-24  Luis Machado  <lgustavo@@codesourcery.com>

	* remote.c (remote_supports_cond_breakpoints): New forward
	declaration.
	(remote_add_target_side_condition): New function.
	(remote_insert_breakpoint): Add target-side breakpoint
	conditional if supported.
	(remote_insert_hw_breakpoint): Likewise.
	(init_remote_ops): Set to_supports_evaluation_of_breakpoint_conditions
	hook.

	* target.c (update_current_target): Inherit
	to_supports_evaluation_of_breakpoint_conditions.
	Default to_supports_evaluation_of_breakpoint_conditions to return_zero.

	* target.h (struct target_ops)
	<to_supports_evaluation_of_breakpoint_conditions>: New field.
	(target_supports_evaluation_of_breakpoint_conditions): New #define.

	* breakpoint.c (get_first_locp_gte_addr): New forward declaration.
	(condition_evaluation_both, condition_evaluation_auto,
	condition_evaluation_host, condition_evaluation_target,
	condition_evaluation_enums, condition_evaluation_mode_1,
	condition_evaluation_mode): New	static globals.
	(translate_condition_evaluation_mode): New function.
	(breakpoint_condition_evaluation_mode): New function.
	(gdb_evaluates_breakpoint_condition_p): New function.
	(ALL_BP_LOCATIONS_AT_ADDR): New helper macro.
	(mark_breakpoint_modified): New function.
	(mark_breakpoint_location_modified): New function.
	(set_condition_evaluation_mode): New function.
	(show_condition_evaluation_mode): New function.
	(bp_location_compare_addrs): New function.
	(get_first_location_gte_addr): New helper function.
	(set_breakpoint_condition): Free condition bytecode if locations
	has become unconditional.  Call mark_breakpoint_modified (...).
	(condition_command): Call update_global_location_list (1) for
	breakpoints.
	(breakpoint_xfer_memory): Use is_breakpoint (...).
	(is_breakpoint): New function.
	(parse_cond_to_aexpr): New function.
	(build_target_condition_list): New function.
	(insert_bp_location): Handle target-side conditional
	breakpoints and call build_target_condition_list (...).
	(update_inserted_breakpoint_locations): New function.
	(insert_breakpoint_locations): Handle target-side conditional
	breakpoints.
	(bpstat_check_breakpoint_conditions): Add comment.
	(bp_condition_evaluator): New function.
	(bp_location_condition_evaluator): New function.
	(print_breakpoint_location): Print information on where the condition
	will be evaluated.
	(print_one_breakpoint_location): Likewise.
	(init_bp_location): Call mark_breakpoint_location_modified (...) for
	breakpoint location.
	(force_breakpoint_reinsertion): New functions.
	(update_global_location_list): Handle target-side breakpoint
	conditions.
	Reinsert locations that are already inserted if conditions have
	changed.
	(bp_location_dtor): Free agent expression bytecode.
	(disable_breakpoint): Call mark_breakpoint_modified (...).
	Call update_global_location_list (...) with parameter 1 for breakpoints.
	(disable_command): Call mark_breakpoint_location_modified (...).
	Call update_global_location_list (...) with parameter 1 for breakpoints.
	(enable_breakpoint_disp): Call mark_breakpoint_modified (...).
	(enable_command): mark_breakpoint_location_modified (...).
	(_initialize_breakpoint): Update documentation and add
	condition-evaluation breakpoint subcommand.

	* breakpoint.h: Include ax.h.
	(condition_list): New data structure.
	(condition_status): New enum.
	(bp_target_info) <cond_list>: New field.
	(bp_location) <condition_changed, cond_bytecode>: New fields.
	(is_breakpoint): New prototype.
@
text
@d10421 3
d10454 2
a10455 11
  if (anywhere)
    /* If the user told us to continue until a specified location,
       we don't specify a frame at which we need to stop.  */
    breakpoint = set_momentary_breakpoint (get_frame_arch (frame), sal,
					   null_frame_id, bp_until);
  else
    /* Otherwise, specify the selected frame, because we want to stop
       only at the very same frame.  */
    breakpoint = set_momentary_breakpoint (get_frame_arch (frame), sal,
					   get_stack_frame_id (frame),
					   bp_until);
d10457 1
a10457 1
  old_chain = make_cleanup_delete_breakpoint (breakpoint);
d10459 2
a10460 2
  tp = inferior_thread ();
  thread = tp->num;
d10465 1
a10465 1
  if (frame_id_p (frame_unwind_caller_id (frame)))
d10467 4
a10470 2
      sal = find_pc_line (frame_unwind_caller_pc (frame), 0);
      sal.pc = frame_unwind_caller_pc (frame);
d10472 2
a10473 2
					      sal,
					      frame_unwind_caller_id (frame),
d10477 1
a10477 1
      set_longjmp_breakpoint (tp, frame_unwind_caller_id (frame));
d10481 12
@


1.655
log
@2012-02-24  Luis Machado  <lgustavo@@codesourcery.com>

	* breakpoint.c (bp_location_compare): Sort by pspace before sorting by
	number.
@
text
@d69 1
d262 2
d412 58
d501 14
d698 172
d892 4
d938 2
d973 4
d1476 10
d1928 137
d2081 1
a2081 1
  if (!should_be_inserted (bl) || bl->inserted)
d2090 12
d2410 60
d2493 1
a2493 1
      if (!should_be_inserted (bl) || bl->inserted)
d4571 4
d5152 60
d5270 10
d5555 12
d6296 1
d6324 1
d6328 1
d11286 1
d11297 1
d11301 1
d11305 53
d11379 4
d11455 7
a11461 1
	  if (*loc2p == old_loc)
d11463 2
a11464 2
	      found_object = 1;
	      break;
d11466 3
d11471 8
d11498 4
d11654 5
a11658 1
	continue;
d11681 7
d11699 3
d11709 1
a11709 1
  if (breakpoints_always_inserted_mode () && should_insert
d11712 12
a11723 1
    insert_breakpoint_locations ();
d11837 2
d13532 3
d13582 5
a13586 1
	  loc->enabled = 0;
d13643 5
d13707 5
a13711 1
	  loc->enabled = 1;
d15486 17
@


1.654
log
@ChangeLog
2012-02-22  Sterling Augustine  <saugustine@@google.com>

	PR 13689:
	* breakpoint.c (watchpoint_exp_is_constant): Add UNOP_CAST to switch.

testsuite/ChangeLog
2012-02-22  Sterling Augustine  <saugustine@@google.com>

	* gdb.base/watchpoint.exp (test_constant_watchpoint): Add test for
	constant with cast.
@
text
@d10612 8
@


1.653
log
@Minor reformatting in breakpoint.c (watchpoint_exp_is_const)

gdb/ChangeLog:

 	* breakpoint.c (watchpoint_exp_is_const): Add missing empty line
 	between function description and implementation.
@
text
@d8834 1
@


1.652
log
@2012-02-14  Stan Shebs  <stan@@codesourcery.com>

	* NEWS: Mention enable count command.
	* breakpoint.h (struct breakpoint): New field enable_count.
	* breakpoint.c (enable_breakpoint_disp): Add count argument.
	(enable_breakpoint): Add arg to call.
	(struct disp_data): New struct.
	(do_enable_breakpoint_disp): Interp arg as disp_data and unpack.
	(do_map_enable_once_breakpoint): Create a struct and pass it.
	(do_map_enable_delete_breakpoint): Ditto.
	(do_map_enable_count_breakpoint): New function.
	(enable_count_command): New function.
	(bpstat_stop_status): Decrement enable_count.
	(print_one_breakpoint_location): Report enable count.
	(_initialize_breakpoint): Add enable count command.

	* gdb.texinfo (Disabling Breakpoints): Document enable count.

	* gdb.base/ena-dis-br.exp: Add enable count test.
@
text
@d8769 1
@


1.651
log
@gdb/
	* breakpoint.c (bp_location_compare): Fix comment.  Reindent the code.
@
text
@d86 2
d212 2
a213 1
static void enable_breakpoint_disp (struct breakpoint *, enum bpdisp);
d4341 3
a4343 1
		  if (b->enable_state != bp_permanent)
d5047 17
d12909 2
a12910 1
enable_breakpoint_disp (struct breakpoint *bpt, enum bpdisp disposition)
d12963 1
d12974 1
a12974 1
  enable_breakpoint_disp (bpt, bpt->disposition);
d13024 9
d13036 1
a13036 1
  enum bpdisp disp = *(enum bpdisp *) arg;
d13038 1
a13038 1
  enable_breakpoint_disp (bpt, disp);
d13044 1
a13044 1
  enum bpdisp disp = disp_disable;
d13056 16
d13074 1
a13074 1
  enum bpdisp disp = disp_del;
d14343 6
d14359 6
@


1.650
log
@	* blockframe.c (find_pc_partial_function_gnu_ifunc): Change type of
	"name" parameter to const char ** from char **.  All callers updated.
	(find_pc_partial_function): Ditto.
	(cache_pc_function_name): Change type to const char * from char *.
	* symtab.h ((find_pc_partial_function_gnu_ifunc): Update.
	(find_pc_partial_function): Update.
	* alpha-tdep.h (struct gdbarch_tdep, member pc_in_sigtramp): Change
	type of "name" parameter to const char * from char *.
	All uses updated.
	* arch-utils.c (generic_in_solib_return_trampoline): Change
	type of "name" parameter to const char * from char *.
	* arch-utils.h (generic_in_solib_return_trampoline): Update.
	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp): Change
	type of "name" parameter to const char * from char *.
	* gdbarch.sh (in_solib_return_trampoline): Ditto.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* hppa-hpux-tdep.c (hppa_hpux_in_solib_return_trampoline): Update.
	* rs6000-tdep.c (rs6000_in_solib_return_trampoline): Update.
	* m32r-linux-tdep.c (m32r_linux_pc_in_sigtramp): Change
	type of "name" parameter to const char * from char *.
	* skip.c (skip_function_pc): Ditto.
	* sparc-sol2-tdep.c (sparc_sol2_pc_in_sigtramp): Ditto.
	* sparc-tdep.h (sparc_sol2_pc_in_sigtramp): Update.
	* sparc64fbsd-tdep.c (sparc64fbsd_pc_in_sigtramp): Ditto.
	* sparc64nbsd-tdep.c (sparc64nbsd_pc_in_sigtramp): Ditto.
	* sparc64obsd-tdep.c (sparc64obsd_pc_in_sigtramp): Ditto.
	* sparcnbsd-tdep.c (sparc32nbsd_pc_in_sigtramp): Ditto.
	* sparcobsd-tdep.c (sparc32obsd_pc_in_sigtramp): Ditto.
	* nbsd-tdep.c (nbsd_pc_in_sigtramp): Similary for "func_name".
	* nbsd-tdep.h (nbsd_pc_in_sigtramp): Update.
@
text
@d10592 3
a10594 2
  /* Make the user-visible order stable across GDB runs.  Locations of
     the same breakpoint can be sorted in arbitrary order.  */
d10597 2
a10598 2
    return (a->owner->number > b->owner->number)
           - (a->owner->number < b->owner->number);
@


1.649
log
@gdb/
	Code cleanup: Make 1440 bytes of data segment read-only.
	* arch-utils.c (endian_enum): Make it const char *const [].
	* arm-tdep.c (fp_model_strings, arm_abi_strings, arm_mode_strings):
	Likewise.
	* breakpoint.c (always_inserted_enums): Likewise.
	* cli/cli-cmds.c (script_ext_enums): Likewise.
	* cli/cli-decode.c (add_setshow_enum_cmd, complete_on_enum): Make the
	enumlist parameter const char *const *.
	* cli/cli-decode.h (struct cmd_list_element): Make the enums field
	const char *const *.
	* command.h (complete_on_enum, add_setshow_enum_cmd): Make the enumlist
	parameter const char *const *.
	* cris-tdep.c (cris_modes): Make it const char *const [].
	* filesystem.c (target_file_system_kinds): Likewise.
	* i386-tdep.c (valid_flavors, valid_conventions): Likewise.
	* infrun.c (follow_fork_mode_kind_names, follow_exec_mode_names)
	(can_use_displaced_stepping_enum, scheduler_enums)
	(exec_direction_names): Likewise.
	* language.c (_initialize_language): Make the type_or_range_names and
	case_sensitive_names variables const char *const [].
	* mips-tdep.c (mips_abi_strings): Make it const char *const [].
	* python/python.c (python_excp_enums): Likewise.
	* remote.c (interrupt_sequence_modes): Likewise.
	* rs6000-tdep.c (powerpc_vector_strings): Likewise.
	* serial.c (logbase_enums): Likewise.
	* sh-tdep.c (sh_cc_enum): Likewise.
	* stack.c (print_frame_arguments_choices, print_entry_values_choices):
	Likewise.
	* symtab.c (multiple_symbols_modes): Likewise.
	* tui/tui-win.c (tui_border_kind_enums, tui_border_mode_enums):
	Likewise.
	* utils.c (internal_problem_modes): Likewise.
@
text
@d5877 1
d5879 1
a5879 1
      find_pc_partial_function_gnu_ifunc (loc->address, &loc->function_name,
d5887 1
a5887 1
	  if (gnu_ifunc_resolve_name (loc->function_name,
d5904 2
a5905 2
      if (loc->function_name)
	loc->function_name = xstrdup (loc->function_name);
@


1.648
log
@	* breakpoint.c (bpstat_stop_status): Check 'breakpoint_at' before
	dereferencing.
@
text
@d376 1
a376 1
static const char *always_inserted_enums[] = {
@


1.647
log
@	PR symtab/12406:
	* solib.c (update_solib_list): Update the program space's
	added_solibs and deleted_solibs fields.
	* progspace.h (struct program_space) <added_solibs,
	deleted_solibs>: New fields.
	(clear_program_space_solib_cache): Declare.
	* progspace.c (release_program_space): Call
	clear_program_space_solib_cache.
	(clear_program_space_solib_cache): New function.
	* infrun.c (handle_inferior_event) <TARGET_WAITKIND_LOADED>: Call
	bpstat_stop_status.  Use handle_solib_event.
	* breakpoint.c: Include gdb_regex.h.
	(print_solib_event): New function.
	(bpstat_print): Use print_solib_event.
	(bpstat_stop_status): Add special case for bp_shlib_event.
	(handle_solib_event): New function.
	(bpstat_what): Use handle_solib_event.
	(struct solib_catchpoint): New.
	(dtor_catch_solib, insert_catch_solib, remove_catch_solib)
	(breakpoint_hit_catch_solib, check_status_catch_solib)
	(print_it_catch_solib, print_one_catch_solib)
	(print_mention_catch_solib, print_recreate_catch_solib): New
	functions.
	(catch_solib_breakpoint_ops): New global.
	(catch_load_or_unload, catch_load_command_1)
	(catch_unload_command_1): New functions.
	(internal_bkpt_check_status): Add special case for
	bp_shlib_event.
	(internal_bkpt_print_it): Use print_solib_event.
	(initialize_breakpoint_ops): Initialize
	catch_solib_breakpoint_ops.
	(_initialize_breakpoint): Register "catch load" and "catch
	unload".
	* breakpoint.h (handle_solib_event): Declare.
	* NEWS: Add entry for "catch load" and "catch unload".
gdb/doc
	* gdb.texinfo (Set Catchpoints): Document "catch load" and "catch
	unload".
	(Files): Mention new catch commands.
	(GDB/MI Async Records): Likewise.
gdb/testsuite
	* lib/mi-support.exp (mi_expect_stop): Add special case for
	solib-event.
	* gdb.base/catch-load-so.c: New file.
	* gdb.base/catch-load.exp: New file.
	* gdb.base/catch-load.c: New file.
	* gdb.base/break-interp.exp (reach_1): Update regexp.
@
text
@d4306 1
a4306 1
      if (bs->breakpoint_at->type == bp_shlib_event)
@


1.646
log
@2012-01-24  Pedro Alves  <pedro@@codesourcery.com>

	* breakpoint.c (breakpoint_hit_catch_fork)
	(breakpoint_hit_catch_vfork, breakpoint_hit_catch_syscall)
	(breakpoint_hit_catch_exec): Make use of the `ws' argument.
	* infrun.c (inferior_has_forked, inferior_has_vforked)
	(inferior_has_execd, inferior_has_called_syscall): Delete.
	(handle_syscall_event): Get syscall_number from the execution
	control state's wait status.
	(wait_for_inferior): Don't clear syscall_number.
@
text
@d68 1
d263 5
d3499 72
d3615 1
a3615 4
      ui_out_text (current_uiout, _("Stopped due to shared library event\n"));
      if (ui_out_is_mi_like_p (current_uiout))
	ui_out_field_string (current_uiout, "reason",
			     async_reason_lookup (EXEC_ASYNC_SOLIB_EVENT));
d4300 13
d4402 19
a4428 4
  /* We need to defer calling `solib_add', as adding new symbols
     resets breakpoints, which in turn deletes breakpoint locations,
     and hence may clear unprocessed entries in the BS chain.  */
  int shlib_event = 0;
a4451 3
      if (bptype == bp_shlib_event)
	shlib_event = 1;

a4582 21
  if (shlib_event)
    {
      if (debug_infrun)
	fprintf_unfiltered (gdb_stdlog, "bpstat_what: bp_shlib_event\n");

      /* Check for any newly added shared libraries if we're supposed
	 to be adding them automatically.  */

      /* Switch terminal for any messages produced by
	 breakpoint_re_set.  */
      target_terminal_ours_for_output ();

#ifdef SOLIB_ADD
      SOLIB_ADD (NULL, 0, &current_target, auto_solib_add);
#else
      solib_add (NULL, 0, &current_target, auto_solib_add);
#endif

      target_terminal_inferior ();
    }

d6513 258
d11539 1
a11539 4
      ui_out_text (uiout, _("Stopped due to shared library event\n"));
      if (ui_out_is_mi_like_p (uiout))
	ui_out_field_string (uiout, "reason",
			     async_reason_lookup (EXEC_ASYNC_SOLIB_EVENT));
d14178 13
d14494 14
@


1.645
log
@2012-01-24  Pedro Alves  <palves@@redhat.com>

	* breakpoint.c (bpstat_check_location, bpstat_stop_status,
	pc_at_non_inline_function): Add `ws' parameter, and pass it down.
	(breakpoint_hit_catch_fork, breakpoint_hit_catch_vfork)
	(breakpoint_hit_catch_syscall, breakpoint_hit_catch_exec): Add
	`ws' parameter.
	(breakpoint_hit_ranged_breakpoint): Add `ws' parameter.  Return
	false for events other than TARGET_SIGNAL_TRAP.
	(breakpoint_hit_watchpoint, base_breakpoint_breakpoint_hit):
	Add `ws' parameter.
	(bkpt_breakpoint_hit): Add `ws' parameter.  Return false for
	events other than TARGET_SIGNAL_TRAP.
	(tracepoint_breakpoint_hit): Add `ws' parameter.
	* breakpoint.h (struct breakpoint_ops) <breakpoint_hit>: Add `ws'
	parameter.
	(bpstat_stop_status): Same.
	(pc_at_non_inline_function): Same.
	* infrun.c (handle_syscall_event, handle_inferior_event): Adjust
	to pass the current event's waitstatus to bpstat_stop_status
	and pc_at_non_inline_function.
@
text
@d6235 5
a6239 1
  return inferior_has_forked (inferior_ptid, &c->forked_inferior_pid);
d6349 5
a6353 1
  return inferior_has_vforked (inferior_ptid, &c->forked_inferior_pid);
d6563 2
a6564 1
  if (!inferior_has_called_syscall (inferior_ptid, &syscall_number))
d6567 2
d6874 5
a6878 1
  return inferior_has_execd (inferior_ptid, &c->exec_pathname);
@


1.644
log
@2012-01-24  Pedro Alves  <palves@@redhat.com>

	* breakpoint.c (bpstat_stop_status): Moving clearing print_it
	outside `bs->stop' block.
	(bpstat_what): Rework bp_shlib_event handling.
	(internal_bkpt_check_status): If the breakpoint is a
	bp_shlib_event, then set bs->stop and bs->print if
	stop_on_solib_events is set.
@
text
@d3828 2
a3829 1
		       struct address_space *aspace, CORE_ADDR bp_addr)
d3836 1
a3836 1
  return b->ops->breakpoint_hit (bl, aspace, bp_addr);
d4146 2
a4147 1
		    CORE_ADDR bp_addr, ptid_t ptid)
d4185 1
a4185 1
	  if (!bpstat_check_location (bl, aspace, bp_addr))
d6230 2
a6231 1
			   struct address_space *aspace, CORE_ADDR bp_addr)
d6340 2
a6341 1
			    struct address_space *aspace, CORE_ADDR bp_addr)
d6545 2
a6546 1
			      struct address_space *aspace, CORE_ADDR bp_addr)
d6858 2
a6859 1
			   struct address_space *aspace, CORE_ADDR bp_addr)
d8103 2
a8104 1
				  CORE_ADDR bp_addr)
d8106 4
d8576 2
a8577 1
			   struct address_space *aspace, CORE_ADDR bp_addr)
d10836 2
a10837 1
				CORE_ADDR bp_addr)
d10983 2
a10984 1
		     struct address_space *aspace, CORE_ADDR bp_addr)
d10988 4
d11292 2
a11293 1
			   struct address_space *aspace, CORE_ADDR bp_addr)
d13648 2
a13649 1
pc_at_non_inline_function (struct address_space *aspace, CORE_ADDR pc)
d13662 1
a13662 1
	      && bpstat_check_location (bl, aspace, pc))
@


1.643
log
@gdb/
	Fix watchpoints to be specific for each inferior.
	* breakpoint.c (watchpoint_in_thread_scope): Verify also
	current_program_space.
	* i386-nat.c (i386_inferior_data_cleanup): New.
	(i386_inferior_data_get): Replace variable inf_data_local by an
	inferior_data call.
	(i386_use_watchpoints): Initialize i386_inferior_data.
	* linux-nat.c (linux_nat_iterate_watchpoint_lwps): Use INFERIOR_PTID
	specific iterate_over_lwps.

gdb/testsuite/
	Fix watchpoints to be specific for each inferior.
	* gdb.multi/watchpoint-multi.c: New file.
	* gdb.multi/watchpoint-multi.exp: New file.
@
text
@a4260 3
	  /* Print nothing for this entry if we don't stop or don't print.  */
	  if (bs->stop == 0 || bs->print == 0)
	    bs->print_it = print_it_noop;
d4262 5
d4347 3
d4358 1
a4435 12
	case bp_shlib_event:
	  shlib_event = 1;

	  /* If requested, stop when the dynamic linker notifies GDB
	     of events.  This allows the user to get control and place
	     breakpoints in initializer routines for dynamically
	     loaded objects (among other things).  */
	  if (stop_on_solib_events)
	    this_action = BPSTAT_WHAT_STOP_NOISY;
	  else
	    this_action = BPSTAT_WHAT_SINGLE;
	  break;
d11142 11
a11152 2
  /* We do not stop for these.  */
  bs->stop = 0;
@


1.642
log
@gdb
	* NEWS: Add item.
	* symtab.h (compare_filenames_for_search): Declare.
	* symtab.c (compare_filenames_for_search): New function.
	(iterate_over_some_symtabs): Use it.
	* symfile.h (struct quick_symbol_functions)
	<map_symtabs_matching_filename>: Change spec.
	* psymtab.c (partial_map_symtabs_matching_filename): Use
	compare_filenames_for_search.  Update for new spec.
	* dwarf2read.c (dw2_map_symtabs_matching_filename): Use
	compare_filenames_for_search.  Update for new spec.
	* breakpoint.c (clear_command): Use compare_filenames_for_search.
gdb/doc
	* gdb.texinfo (Specify Location): Document relative file name
	handling.
gdb/testsuite
	* gdb.linespec/linespec.exp: Change some tests to use $decimal.
	Add tests for relative directory.
@
text
@d1242 4
a1245 3
  return (ptid_equal (b->watchpoint_thread, null_ptid)
	  || (ptid_equal (inferior_ptid, b->watchpoint_thread)
	      && !is_executing (inferior_ptid)));
@


1.641
log
@2012-01-16  Sergio Durigan Junior  <sergiodj@@redhat.com>

* breakpoint.c (create_sals_from_address_default): New function.
(create_breakpoints_sal_default): Likewise.
(decode_linespec_default): Likewise.
(is_marker_spec): Removed.
(strace_marker_p): New function.
(init_breakpoint_sal): Using `strace_marker_p' instead of
`is_marker_spec'.
(create_breakpoint): Call method `create_sals_from_address' from
breakpoint_ops, replacing code that created SALs conditionally
on the type of the breakpoint.  Call method `create_breakpoints_sal',
replacing code that created breakpoints conditionally on the type
wanted.
(base_breakpoint_create_sals_from_address): New function.
(base_breakpoint_create_breakpoints_sal): Likewise.
(base_breakpoint_decode_linespec): Likewise.
(base_breakpoint_ops): Add methods
`base_breakpoint_create_sals_from_address',
`base_breakpoint_create_breakpoints_sal' and
`base_breakpoint_decode_linespec'.
(bkpt_create_sals_from_address): New function.
(bkpt_create_breakpoints_sal): Likewise.
(bkpt_decode_linespec): Likewise.
(tracepoint_create_sals_from_address): Likewise.
(tracepoint_create_breakpoints_sal): Likewise.
(tracepoint_decode_linespec): Likewise.
(strace_marker_create_sals_from_address): Likewise.
(strace_marker_create_breakpoints_sal): Likewise.
(strace_marker_decode_linespec): Likewise.
(strace_marker_breakpoint_ops): New variable.
(addr_string_to_sals): Remove `marker_spec'.  Call method
`decode_linespec' from breakpoint_ops, replacing code that decoded
an address string into a SAL.  Use `strace_marker_p' instead of
`marker_spec'.
(strace_command): Decide whether we are dealing with a static
tracepoint with marker or not.  Use the appropriate breakpoint_ops.
(initialize_breakpoint_ops): Initialize new fields of breakpoint_ops.
* breakpoint.h (linespec_result, linespec_sals): New forward
declarations.
(breakpoint_ops) <create_sals_from_address>,
<create_breakpoints_sal>, <decode_linespec>: New methods.
@
text
@d10073 2
d10088 2
d10109 18
a10126 7
		  int line_match = ((default_match || sal.explicit_line)
				    && loc->source_file != NULL
				    && sal.symtab != NULL
				    && sal.pspace == loc->pspace
				    && filename_cmp (loc->source_file,
						     sal.symtab->filename) == 0
				    && loc->line_number == sal.line);
@


1.640
log
@	PR gdb/9598:
	* breakpoint.c (_initialize_breakpoint): Fix help for "catch
	catch" and "catch throw".
@
text
@d99 17
d257 4
a260 4
/* Assuming we're creating a static tracepoint, does S look like a
   static tracepoint marker spec ("-m MARKER_ID")?  */
#define is_marker_spec(s)						\
  (s != NULL && strncmp (s, "-m", 2) == 0 && ((s)[2] == ' ' || (s)[2] == '\t'))
d7318 1
a7318 1
	      if (is_marker_spec (addr_string))
a7739 16
  if (type_wanted == bp_static_tracepoint && is_marker_spec (arg))
    {
      int i;
      struct linespec_sals lsal;

      lsal.sals = decode_static_tracepoint_spec (&arg);

      copy_arg = savestring (addr_start, arg - addr_start);

      canonical.addr_string = xstrdup (copy_arg);
      lsal.canonical = xstrdup (copy_arg);
      VEC_safe_push (linespec_sals, canonical.sals, &lsal);

      goto done;
    }

d7742 2
a7743 1
      parse_breakpoint_sals (&arg, &canonical);
d7749 4
a7752 2
    case RETURN_QUIT:
      throw_exception (e);
d7794 1
a7794 2
      if (VEC_empty (linespec_sals, canonical.sals))
	return 0;
a7796 2
  done:

d7859 1
a7859 27
      /* If the user is creating a static tracepoint by marker id
	 (strace -m MARKER_ID), then store the sals index, so that
	 breakpoint_re_set can try to match up which of the newly
	 found markers corresponds to this one, and, don't try to
	 expand multiple locations for each sal, given than SALS
	 already should contain all sals for MARKER_ID.  */
      if (type_wanted == bp_static_tracepoint
	  && is_marker_spec (copy_arg))
	{
	  int i;

	  for (i = 0; i < lsal->sals.nelts; ++i)
	    {
	      struct symtabs_and_lines expanded;
	      struct tracepoint *tp;
	      struct cleanup *old_chain;
	      char *addr_string;

	      expanded.nelts = 1;
	      expanded.sals = &lsal->sals.sals[i];

	      addr_string = xstrdup (canonical.addr_string);
	      old_chain = make_cleanup (xfree, addr_string);

	      tp = XCNEW (struct tracepoint);
	      init_breakpoint_sal (&tp->base, gdbarch, expanded,
				   addr_string, NULL,
d7863 1
a7863 21
				   from_tty, enabled, internal,
				   canonical.special_display);
	      /* Given that its possible to have multiple markers with
		 the same string id, if the user is creating a static
		 tracepoint by marker id ("strace -m MARKER_ID"), then
		 store the sals index, so that breakpoint_re_set can
		 try to match up which of the newly found markers
		 corresponds to this one  */
	      tp->static_trace_marker_id_idx = i;

	      install_breakpoint (internal, &tp->base, 0);

	      discard_cleanups (old_chain);
	    }
	}
      else
	create_breakpoints_sal (gdbarch, &canonical, cond_string,
				type_wanted,
				tempflag ? disp_del : disp_donttouch,
				thread, task, ignore_count, ops, from_tty,
				enabled, internal);
d10868 33
d10916 4
a10919 1
  base_breakpoint_print_recreate
d11065 37
d11328 37
d11367 100
a12000 1
  int marker_spec;
d12004 1
a12005 1
  marker_spec = b->type == bp_static_tracepoint && is_marker_spec (s);
d12009 1
a12009 39
      if (marker_spec)
	{
	  struct tracepoint *tp = (struct tracepoint *) b;

	  sals = decode_static_tracepoint_spec (&s);
	  if (sals.nelts > tp->static_trace_marker_id_idx)
	    {
	      sals.sals[0] = sals.sals[tp->static_trace_marker_id_idx];
	      sals.nelts = 1;
	    }
	  else
	    error (_("marker %s not found"), tp->static_trace_marker_id);
	}
      else
	{
	  struct linespec_result canonical;

	  init_linespec_result (&canonical);
	  decode_line_full (&s, DECODE_LINE_FUNFIRSTLINE,
			    (struct symtab *) NULL, 0,
			    &canonical, multiple_symbols_all,
			    b->filter);

	  /* We should get 0 or 1 resulting SALs.  */
	  gdb_assert (VEC_length (linespec_sals, canonical.sals) < 2);

	  if (VEC_length (linespec_sals, canonical.sals) > 0)
	    {
	      struct linespec_sals *lsal;

	      lsal = VEC_index (linespec_sals, canonical.sals, 0);
	      sals = lsal->sals;
	      /* Arrange it so the destructor does not free the
		 contents.  */
	      lsal->sals.sals = NULL;
	    }

	  destroy_linespec_result (&canonical);
	}
d12062 1
a12062 1
      if (b->type == bp_static_tracepoint && !marker_spec)
d12105 67
d12990 9
d13006 1
a13006 1
			 &tracepoint_breakpoint_ops,
d13651 3
d13734 10
@


1.639
log
@	* breakpoint.c (wrapper.h): Don't include.
@
text
@d13852 1
a13852 2
Catch an exception, when caught.\n\
With an argument, catch only exceptions with the given name."),
d13858 1
a13858 2
Catch an exception, when thrown.\n\
With an argument, catch only exceptions with the given name."),
@


1.638
log
@2012-01-06  Sergio Durigan Junior  <sergiodj@@redhat.com>
	    Thiago Jung Bauermann  <bauerman@@br.ibm.com>

	* ada-lang.c (ada_exception_name_addr): Add `volatile' keyword
	before `struct gdb_exception'.
	* breakpoint.c (update_global_location_list_nothrow)
	(update_breakpoint_locations, enable_breakpoint_disp): Likewise.
	* cp-abi.c (value_rtti_type): Likewise.
	* cp-support.c (cp_validate_operator): Likewise.
	* infrun.c (insert_exception_resume_breakpoint)
	(check_exception_resume, keep_going): Likewise.
	* mi-interp.c (mi_breakpoint_created)
	(mi_breakpoint_modified): Likewise.
	* rs6000-aix-tdep.c (rs6000_convert_from_func_ptr_addr): Likewise.
	* solib-ia64-hpux.c (ia64_hpux_at_dld_breakpoint_p)
	(ia64_hpux_handle_dld_breakpoint_1): Likewise.
@
text
@a58 1
#include "wrapper.h"
@


1.637
log
@	* breakpoint.c (all_locations_are_pending): Consider locations
	in program spaces executing during startup pending as well.
@
text
@d10716 1
a10716 1
  struct gdb_exception e;
d11756 1
a11756 1
	  struct gdb_exception e;
d12327 1
a12327 1
      struct gdb_exception e;
@


1.636
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d11501 2
a11502 1
    if (!loc->shlib_disabled)
@


1.635
log
@	Introduce gdb.FinishBreakpoint in Python

	* Makefile.in (SUBDIR_PYTHON_OBS): Add py-finishbreakpoint.o.
	(SUBDIR_PYTHON_SRCS): Add python/py-finishbreakpoint.c.
	Add build rule for this file.
	* infcmd.c (print_return_value): Split to create get_return_value.
	(get_return_value): New function based on print_return_value. Handle
	case where stop_registers are not set.
	* inferior.h (get_return_value): New prototype.
	* python/py-breakpoint.c (bppy_pending_object): Make non-static.
	(gdbpy_breakpoint_created): Set is_py_finish_bp is necessary.
	(struct breakpoint_object): Move to python-internal.h
	(BPPY_REQUIRE_VALID): Likewise.
	(BPPY_SET_REQUIRE_VALID): Likewise.
	(gdbpy_breakpoint_created): Initialize is_finish_bp.
	(gdbpy_should_stop): Add  pre/post hooks before/after calling stop
	method.
	* python/python-internal.h (breakpoint_object_type): Add as extern.
	(bppy_pending_object): Likewise.
	(typedef struct breakpoint_object) Removed.
	(struct breakpoint_object): Moved from py-breakpoint.c.
	Add field is_finish_bp.
	(BPPY_REQUIRE_VALID): Moved from py-breakpoint.c.
	(BPPY_SET_REQUIRE_VALID): Likewise.
	(frame_object_to_frame_info): New prototype.
	(gdbpy_initialize_finishbreakpoints): New prototype.
	(bpfinishpy_is_finish_bp): Likewise.
	(bpfinishpy_pre_stop_hook): Likewise.
	(bpfinishpy_post_stop_hook): Likewise.
	* python/py-finishbreakpoint.c: New file.
	* python/py-frame.c(frame_object_to_frame_info): Make non-static and
	accept PyObject instead of frame_object.
	(frapy_is_valid): Don't cast to frame_object.
	(frapy_name): Likewise.
	(frapy_type): Likewise.
	(frapy_unwind_stop_reason): Likewise.
	(frapy_pc): Likewise.
	(frapy_block): Likewise.
	(frapy_function): Likewise.
	(frapy_older): Likewise.
	(frapy_newer): Likewise.
	(frapy_find_sal): Likewise.
	(frapy_read_var): Likewise.
	(frapy_select): Likewise.
	* python/python.c (gdbpy_is_stopped_at_finish_bp): New noop function.
	(_initialize_python): Add gdbpy_initialize_finishbreakpoints.
	* python/python.h: Include breakpoint.h
	(gdbpy_is_stopped_at_finish_bp): New prototype.

doc/
	* gdb.texinfo (Finish Breakpoints in Python): New subsection.
	(Python API): Add menu entry for Finish Breakpoints.

testsuite/
	* Makefile.in (EXECUTABLES): Add py-finish-breakpoint and
	py-finish-breakpoint2
	(MISCALLANEOUS): Add py-events-shlib.so and py-events-shlib-nodebug.so
	* gdb.python/py-breakpoint.exp (mult_line): Define and use variable
	instead of line number.
	* gdb.python/py-finish-breakpoint.c: New file.
	* gdb.python/py-finish-breakpoint.exp: New file.
	* gdb.python/py-finish-breakpoint.py: New file.
	* gdb.python/py-finish-breakpoint2.cc: New file.
	* gdb.python/py-finish-breakpoint2.exp: New file.
	* gdb.python/py-finish-breakpoint2.py: New file.
@
text
@d3 1
a3 3
   Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
   2008, 2009, 2010, 2011 Free Software Foundation, Inc.
@


1.634
log
@gdb/
	* breakpoint.c (create_breakpoint): Set canonical.addr_string
	for static tracepoint.
@
text
@d7937 2
a7938 1
      if (type_wanted != bp_breakpoint && type_wanted != bp_hardware_breakpoint)
@


1.633
log
@* breakpoint.c (update_global_location_list): Remove nested
definition of `b'(-Wshadow).
@
text
@d7735 1
@


1.633.2.1
log
@gdb/
	* breakpoint.c (create_breakpoint): Set canonical.addr_string
	for static tracepoint.
@
text
@a7734 1
      canonical.addr_string = xstrdup (copy_arg);
@


1.633.2.2
log
@	Introduce gdb.FinishBreakpoint in Python

	* Makefile.in (SUBDIR_PYTHON_OBS): Add py-finishbreakpoint.o.
	(SUBDIR_PYTHON_SRCS): Add python/py-finishbreakpoint.c.
	Add build rule for this file.
	* infcmd.c (print_return_value): Split to create get_return_value.
	(get_return_value): New function based on print_return_value. Handle
	case where stop_registers are not set.
	* inferior.h (get_return_value): New prototype.
	* python/py-breakpoint.c (bppy_pending_object): Make non-static.
	(gdbpy_breakpoint_created): Set is_py_finish_bp is necessary.
	(struct breakpoint_object): Move to python-internal.h
	(BPPY_REQUIRE_VALID): Likewise.
	(BPPY_SET_REQUIRE_VALID): Likewise.
	(gdbpy_breakpoint_created): Initialize is_finish_bp.
	(gdbpy_should_stop): Add  pre/post hooks before/after calling stop
	method.
	* python/python-internal.h (breakpoint_object_type): Add as extern.
	(bppy_pending_object): Likewise.
	(typedef struct breakpoint_object) Removed.
	(struct breakpoint_object): Moved from py-breakpoint.c.
	Add field is_finish_bp.
	(BPPY_REQUIRE_VALID): Moved from py-breakpoint.c.
	(BPPY_SET_REQUIRE_VALID): Likewise.
	(frame_object_to_frame_info): New prototype.
	(gdbpy_initialize_finishbreakpoints): New prototype.
	(bpfinishpy_is_finish_bp): Likewise.
	(bpfinishpy_pre_stop_hook): Likewise.
	(bpfinishpy_post_stop_hook): Likewise.
	* python/py-finishbreakpoint.c: New file.
	* python/py-frame.c(frame_object_to_frame_info): Make non-static and
	accept PyObject instead of frame_object.
	(frapy_is_valid): Don't cast to frame_object.
	(frapy_name): Likewise.
	(frapy_type): Likewise.
	(frapy_unwind_stop_reason): Likewise.
	(frapy_pc): Likewise.
	(frapy_block): Likewise.
	(frapy_function): Likewise.
	(frapy_older): Likewise.
	(frapy_newer): Likewise.
	(frapy_find_sal): Likewise.
	(frapy_read_var): Likewise.
	(frapy_select): Likewise.
	* python/python.c (gdbpy_is_stopped_at_finish_bp): New noop function.
	(_initialize_python): Add gdbpy_initialize_finishbreakpoints.
	* python/python.h: Include breakpoint.h
	(gdbpy_is_stopped_at_finish_bp): New prototype.

doc/
	* gdb.texinfo (Finish Breakpoints in Python): New subsection.
	(Python API): Add menu entry for Finish Breakpoints.

testsuite/
	* Makefile.in (EXECUTABLES): Add py-finish-breakpoint and
	py-finish-breakpoint2
	(MISCALLANEOUS): Add py-events-shlib.so and py-events-shlib-nodebug.so
	* gdb.python/py-breakpoint.exp (mult_line): Define and use variable
	instead of line number.
	* gdb.python/py-finish-breakpoint.c: New file.
	* gdb.python/py-finish-breakpoint.exp: New file.
	* gdb.python/py-finish-breakpoint.py: New file.
	* gdb.python/py-finish-breakpoint2.cc: New file.
	* gdb.python/py-finish-breakpoint2.exp: New file.
	* gdb.python/py-finish-breakpoint2.py: New file.
@
text
@d7937 1
a7937 2
      if ((type_wanted != bp_breakpoint
           && type_wanted != bp_hardware_breakpoint) || thread != -1)
@


1.633.2.3
log
@	* breakpoint.c (all_locations_are_pending): Consider locations
	in program spaces executing during startup pending as well.
@
text
@d11503 1
a11503 2
    if (!loc->shlib_disabled
	&& !loc->pspace->executing_startup)
@


1.633.2.4
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 3
a5 1
   Copyright (C) 1986-2012 Free Software Foundation, Inc.
@


1.633.2.5
log
@2012-03-13  Hui Zhu  <teawater@@gmail.com>
	    Pedro Alves  <palves@@redhat.com>

	* breakpoint.c (init_breakpoint_sal): New flags parameter.  Handle
	CREATE_BREAKPOINT_FLAGS_INSERTED.
	(create_breakpoint_sal, create_breakpoints_sal)
	(create_breakpoint): New flags parameter.  Pass it down.
	(break_command_1, handle_gnu_v3_exceptions, trace_command)
	(ftrace_command, strace_command): Adjust.
	(create_tracepoint_from_upload): Pass
	CREATE_BREAKPOINT_FLAGS_INSERTED.
	* breakpoint.h (enum breakpoint_create_flags): New.
	(create_breakpoint): New flags parameter.
	* mi/mi-cmd-break.c (mi_cmd_break_insert): Adjust.
	* python/py-breakpoint.c (bppy_init): Adjust.
	* python/py-finishbreakpoint.c (bpfinishpy_init): Adjust.
	* spu-tdep.c (spu_catch_start): Adjust.
@
text
@d7251 1
a7251 2
		     int enabled, int internal,	unsigned flags,
		     int display_canonical)
a7296 3
	  if ((flags & CREATE_BREAKPOINT_FLAGS_INSERTED) != 0)
	    b->loc->inserted = 1;

a7339 2
	  if ((flags & CREATE_BREAKPOINT_FLAGS_INSERTED) != 0)
	    loc->inserted = 1;
d7372 1
a7372 2
		       int enabled, int internal, unsigned flags,
		       int display_canonical)
d7395 1
a7395 2
		       enabled, internal, flags,
		       display_canonical);
d7423 1
a7423 1
			int enabled, int internal, unsigned flags)
d7447 1
a7447 1
			     from_tty, enabled, internal, flags,
d7707 1
a7707 2
		   int from_tty, int enabled, int internal,
		   unsigned flags)
d7889 1
a7889 1
				   from_tty, enabled, internal, flags,
d7909 1
a7909 1
				enabled, internal, flags);
d7985 1
a7985 2
		     0 /* internal */,
		     0);
d9841 1
a9841 2
		     0 /* internal */,
		     0);
d12772 1
a12772 1
			 0 /* internal */, 0))
d12789 1
a12789 1
			 0 /* internal */, 0))
d12808 1
a12808 1
			 0 /* internal */, 0))
d12873 1
a12873 2
			  0 /* internal */,
			  CREATE_BREAKPOINT_FLAGS_INSERTED))
@


1.632
log
@* breakpoint.c (insert_breakpoint_locations): Rename `error' to
`error_flag'(-Wshadow).
@
text
@a10636 1
      struct breakpoint *b = loc->owner;
d10638 1
@


1.631
log
@* breakpoint.c (bp_loc_is_permanent): Rename `brk' to
`bpoint'(-Wshadow).
@
text
@d1977 1
a1977 1
  int error = 0;
d2016 1
a2016 1
	error = val;
d2051 1
a2051 1
	  error = -1;
d2055 1
a2055 1
  if (error)
@


1.630
log
@* breakpoint.c (update_static_tracepoint): Rename nested `sal' and
`marker' variables to `sal2' and `tpmarker' respectively
(-Wshadow).
@
text
@d7207 1
a7207 1
  const gdb_byte *brk;
d7215 1
a7215 1
  brk = gdbarch_breakpoint_from_pc (loc->gdbarch, &addr, &len);
d7218 1
a7218 1
  if (brk == NULL)
d7232 1
a7232 1
      && memcmp (target_mem, brk, len) == 0)
@


1.629
log
@	* breakpoint.c (compare_breakpoints): New function.
	(clear_command): Remove duplicate breakpoints.  Properly clean
	up.
@
text
@d11617 1
a11617 1
	  struct symtab_and_line sal;
d11619 1
a11619 1
	  struct static_tracepoint_marker *marker;
d11622 1
a11622 1
	  marker = VEC_index (static_tracepoint_marker_p, markers, 0);
d11625 1
a11625 1
	  tp->static_trace_marker_id = xstrdup (marker->str_id);
d11631 1
a11631 1
	  init_sal (&sal);
d11633 1
a11633 1
	  sal.pc = marker->address;
d11635 2
a11636 2
	  sal = find_pc_line (marker->address, 0);
	  sym = find_pc_sect_function (marker->address, NULL);
d11644 1
a11644 1
	  ui_out_field_string (uiout, "file", sal.symtab->filename);
d11649 1
a11649 1
	      char *fullname = symtab_to_fullname (sal.symtab);
d11655 1
a11655 1
	  ui_out_field_int (uiout, "line", sal.line);
d11658 1
a11658 1
	  b->loc->line_number = sal.line;
d11662 1
a11662 1
	    b->loc->source_file = xstrdup (sal.symtab->filename);
d11668 1
a11668 1
				       sal.symtab->filename,
d11674 1
a11674 1
	  release_static_tracepoint_marker (marker);
@


1.628
log
@2011-12-06  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* breakpoint.c (breakpoint_restore_shadows): Rename to ...
	(breakpoint_xfer_memory): ... this.  Change prototype.  Handle
	memory writes too.
	* breakpoint.h (breakpoint_restore_shadows): Delete.
	(breakpoint_xfer_memory): Declare.
	* mem-break.c (default_memory_insert_breakpoint)
	(default_memory_remove_breakpoint): Use target_write_raw_memory.
	(memory_xfer_partial): Rename to ...
	(memory_xfer_partial_1): ... this.  Don't mask out breakpoints
	here.
	(memory_xfer_partial): New.
	(target_write_raw_memory): New.
	* target.h (target_write_raw_memory): New.

	gdb/testsuite/
	* gdb.base/break-always.exp: Test changing memory at addresses
	with breakpoints inserted.
@
text
@d10031 22
d10058 1
a10058 1
  struct breakpoint *b;
d10065 1
d10116 1
d10170 1
d10180 15
d10214 2
@


1.627
log
@the "ambiguous linespec" series
gdb
2011-12-06  Joel Brobecker  <brobecker@@acacore.com>

        * language.h (struct language_defn): Add new component
        la_symbol_name_compare.
        * symfile.h (struct quick_symbol_functions): Update the profile
        of parameter "name_matcher" for the expand_symtabs_matching
        method.  Update the documentation accordingly.
        * ada-lang.h (ada_name_for_lookup): Add declaration.
        * ada-lang.c (ada_name_for_lookup): New function, extracted out
        from ada_iterate_over_symbols.
        (ada_iterate_over_symbols): Do not encode symbol name anymore.
        (ada_expand_partial_symbol_name): Adjust profile.
        (ada_language_defn): Add value for la_symbol_name_compare field.
        * linespec.c: #include "ada-lang.h".
        (iterate_name_matcher): Add language parameter. Replace call
        to strcmp_iw by call to language->la_symbol_name_compare.
        (decode_variable): Encode COPY if current language is Ada.
        * dwarf2read.c (dw2_expand_symtabs_matching): Adjust profile
        of name_matcher parameter.  Adjust call to name_matcher.
        * psymtab.c (expand_symtabs_matching_via_partial): Likewise.
        (expand_partial_symbol_names): Update profile of parameter "fun".
        * psymtab.h (expand_partial_symbol_names): Update profile of
        parameter "fun".
        * symtab.c (demangle_for_lookup): Update function documentation.
        (search_symbols_name_matches): Add language parameter.
        (expand_partial_symbol_name): Likewise.
        * c-lang.c (c_language_defn, cplus_language_defn)
        (asm_language_defn, minimal_language_defn): Add value for
        la_symbol_name_compare field.
        * d-lang.c (d_language_defn): Likewise.
        * f-lang.c (f_language_defn): Ditto.
        * jv-lang.c (java_language_defn): Ditto.
        * m2-lang.c (m2_language_defn): Ditto.
        * objc-lang.c (objc_language_defn): Ditto.
        * opencl-lang.c (opencl_language_defn): Ditto.
        * p-lang.c (pascal_language_defn): Ditto.
        * language.c (unknown_language_defn, auto_language_defn)
        (local_language_defn): Ditto.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* linespec.c (iterate_over_all_matching_symtabs): Use
	LA_ITERATE_OVER_SYMBOLS.
	(lookup_prefix_sym, add_matching_symbols_to_info): Likewise.
	(find_function_symbols, decode_variable): Remove Ada special
	case.
	* language.h (struct language_defn) <la_iterate_over_symbols>: New
	field.
	(LA_ITERATE_OVER_SYMBOLS): New macro.
	* language.c (unknown_language_defn, auto_language_defn)
	(local_language_defn): Update.
	* c-lang.c (c_language_defn, cplus_language_defn)
	(asm_language_defn, minimal_language_defn): Update.
	* d-lang.c (d_language_defn): Update.
	* f-lang.c (f_language_defn): Update.
	* jv-lang.c (java_language_defn): Update.
	* m2-lang.c (m2_language_defn): Update.
	* objc-lang.c (objc_language_defn): Update.
	* opencl-lang.c (opencl_language_defn): Update.
	* p-lang.c (pascal_language_defn): Update.
	* ada-lang.c (ada_iterate_over_symbols): New function.
	(ada_language_defn): Update.

2011-12-06  Tom Tromey  <tromey@@redhat.com>
	    Joel Brobecker  <brobecker@@acacore.com>

	PR breakpoints/13105, PR objc/8341, PR objc/8343, PR objc/8366,
	PR objc/8535, PR breakpoints/11657, PR breakpoints/11970,
	PR breakpoints/12023, PR breakpoints/12334, PR breakpoints/12856,
	PR shlibs/8929, PR shlibs/7393:
	* python/py-type.c (compare_maybe_null_strings): Rename from
	compare_strings.
	(check_types_equal): Update.
	* utils.c (compare_strings): New function.
	* tui/tui-winsource.c (tui_update_breakpoint_info): Update for
	location changes.
	* tracepoint.c (scope_info): Update.
	(trace_find_line_command): Use DECODE_LINE_FUNFIRSTLINE.
	* symtab.h (iterate_over_minimal_symbols)
	(iterate_over_some_symtabs, iterate_over_symtabs)
	(find_pcs_for_symtab_line, iterate_over_symbols)
	(demangle_for_lookup): Declare.
	(expand_line_sal): Remove.
	* symtab.c (iterate_over_some_symtabs, iterate_over_symtabs)
	(lookup_symtab_callback): New functions.
	(lookup_symtab): Rewrite.
	(demangle_for_lookup): New function, extract from
	lookup_symbol_in_language.
	(lookup_symbol_in_language): Use it.
	(iterate_over_symbols): New function.
	(find_line_symtab): Update.
	(find_pcs_for_symtab_line): New functions.
	(find_line_common): Add 'start' argument.
	(decode_line_spec): Update.  Change argument to 'flags', change
	interpretation.
	(append_expanded_sal): Remove.
	(append_exact_match_to_sals): Remove.
	(expand_line_sal): Remove.
	* symfile.h (struct quick_symbol_functions) <lookup_symtab>:
	Remove.
	<map_symtabs_matching_filename>: New field.
	* stack.c (func_command): Only look in the current program space.
	Use DECODE_LINE_FUNFIRSTLINE.
	* source.c (line_info): Set pspace on sal.  Check program space in
	the loop.  Use DECODE_LINE_LIST_MODE.
	(select_source_symtab): Use DECODE_LINE_FUNFIRSTLINE.
	* solib-target.c: Remove DEF_VEC_I(CORE_ADDR).
	* python/python.c (gdbpy_decode_line): Update.
	* psymtab.c (partial_map_expand_apply): New function.
	(partial_map_symtabs_matching_filename): Rename from
	lookup_partial_symbol.  Update arguments.
	(lookup_symtab_via_partial_symtab): Remove.
	(psym_functions): Update.
	* objc-lang.h (parse_selector, parse_method): Don't declare.
	(find_imps): Update.
	* objc-lang.c (parse_selector, parse_method): Now static.
	(find_methods): Change arguments.  Fill in a vector of symbol
	names.
	(uniquify_strings): New function.
	(find_imps): Change arguments.
	* minsyms.c (iterate_over_minimal_symbols): New function.
	* linespec.h (enum decode_line_flags): New.
	(struct linespec_sals): New.
	(struct linespec_result) <canonical>: Remove.
	<pre_expanded, addr_string, sals>: New fields.
	(destroy_linespec_result, make_cleanup_destroy_linespec_result)
	(decode_line_full): Declare.
	(decode_line_1): Update.
	* linespec.c (struct address_entry, struct linespec_state, struct
	collect_info): New types.
	(add_sal_to_sals_basic, add_sal_to_sals, hash_address_entry)
	(eq_address_entry, maybe_add_address): New functions.
	(total_number_of_methods): Remove.
	(iterate_name_matcher, iterate_over_all_matching_symtabs): New
	functions.
	(find_methods): Change arguments.  Don't canonicalize input.
	Simplify logic.
	(add_matching_methods, add_constructors)
	(build_canonical_line_spec): Remove.
	(filter_results, convert_results_to_lsals): New functions.
	(decode_line_2): Change arguments.  Rewrite for new data
	structures.
	(decode_line_internal): Rename from decode_line_1.  Change
	arguments.  Add cleanups.  Update for new data structures.
	(linespec_state_constructor, linespec_state_destructor)
	(decode_line_full, decode_line_1): New functions.
	(decode_indirect): Change arguments.  Update.
	(locate_first_half): Use skip_spaces.
	(decode_objc): Change arguments.  Update for new data structures.
	Simplify logic.
	(decode_compound): Change arguments.  Add cleanups.  Remove
	fallback code, replace with error.
	(struct decode_compound_collector): New type.
	(collect_one_symbol): New function.
	(lookup_prefix_sym): Change arguments.  Update.
	(compare_symbol_name, add_all_symbol_names_from_pspace)
	(find_superclass_methods ): New functions.
	(find_method): Rewrite.
	(struct symtab_collector): New type.
	(add_symtabs_to_list, collect_symtabs_from_filename): New
	functions.
	(symtabs_from_filename): Change API.  Rename from
	symtab_from_filename.
	(collect_function_symbols): New function.
	(find_function_symbols): Change API.  Rename from
	find_function_symbol.  Rewrite.
	(decode_all_digits): Change arguments.  Rewrite.
	(decode_dollar): Change arguments.  Use decode_variable.
	(decode_label): Change arguments.  Rewrite.
	(collect_symbols): New function.
	(minsym_found): Change arguments.  Rewrite.
	(check_minsym, search_minsyms_for_name)
	(add_matching_symbols_to_info): New function.
	(decode_variable): Change arguments.  Iterate over all symbols.
	(symbol_found): Remove.
	(symbol_to_sal): New function.
	(init_linespec_result, destroy_linespec_result)
	(cleanup_linespec_result, make_cleanup_destroy_linespec_result):
	New functions.
	(decode_digits_list_mode, decode_digits_ordinary): New functions.
	* dwarf2read.c (dw2_map_expand_apply): New function.
	(dw2_map_symtabs_matching_filename): Rename from
	dw2_lookup_symtab.  Change arguments.
	(dwarf2_gdb_index_functions): Update.
	* dwarf2loc.c: Remove DEF_VEC_I(CORE_ADDR).
	* defs.h (compare_strings): Declare.
	* cli/cli-cmds.c (compare_strings): Move to utils.c.
	(edit_command, list_command): Use DECODE_LINE_LIST_MODE.  Call
	filter_sals.
	(compare_symtabs, filter_sals): New functions.
	* breakpoint.h (struct bp_location) <line_number, source_file>:
	New fields.
	(struct breakpoint) <line_number, source_file>: Remove.
	<filter>: New field.
	* breakpoint.c (print_breakpoint_location, init_raw_breakpoint)
	(momentary_breakpoint_from_master, add_location_to_breakpoint):
	Update for changes to locations.
	(init_breakpoint_sal): Add 'filter' argument.  Set 'filter' on
	breakpoint.
	(create_breakpoint_sal): Add 'filter' argument.
	(remove_sal, expand_line_sal_maybe): Remove.
	(create_breakpoints_sal): Remove 'sals' argument.  Handle
	pre-expanded sals and the filter.
	(parse_breakpoint_sals): Use decode_line_full.
	(check_fast_tracepoint_sals): Use get_sal_arch.
	(create_breakpoint): Create a linespec_sals.  Update.
	(break_range_command): Use decode_line_full.  Update.
	(until_break_command): Update.
	(clear_command): Update match conditions for linespec.c changes.
	Use DECODE_LINE_LIST_MODE.
	(say_where): Update for changes to locations.
	(bp_location_dtor): Free 'source_file'.
	(base_breakpoint_dtor): Free 'filter'.  Don't free 'source_file'.
	(update_static_tracepoint): Update for changes to locations.
	(update_breakpoint_locations): Disable ranged breakpoint if too
	many locations match.  Update.
	(addr_string_to_sals): Use decode_line_full.  Resolve all sal
	PCs.
	(breakpoint_re_set_default): Don't call expand_line_sal_maybe.
	(decode_line_spec_1): Update.  Change argument name to 'flags',
	change interpretation.
	* block.h (block_containing_function): Declare.
	* block.c (block_containing_function): New function.
	* skip.c (skip_function_command): Update.
	(skip_re_set): Update.
	* infcmd.c (jump_command): Use DECODE_LINE_FUNFIRSTLINE.
	* mi/mi-main.c (mi_cmd_trace_find): Use DECODE_LINE_FUNFIRSTLINE.
	* NEWS: Add entry.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* elfread.c (elf_gnu_ifunc_resolver_return_stop): Allow
	breakpoint's pspace to be NULL.
	* breakpoint.h (struct breakpoint) <pspace>: Update comment.
	* breakpoint.c (init_raw_breakpoint): Conditionally set
	breakpoint's pspace.
	(init_breakpoint_sal): Don't set breakpoint's pspace.
	(prepare_re_set_context): Conditionally switch program space.
	(addr_string_to_sals): Check executing_startup on location's
	program space.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* breakpoint.h (enum enable_state) <bp_startup_disabled>: Remove.
	* breakpoint.c (should_be_inserted): Explicitly check if program
	space is executing startup.
	(describe_other_breakpoints): Update.
	(disable_breakpoints_before_startup): Change executing_startup
	earlier.  Remove loop.
	(enable_breakpoints_after_startup): Likewise.
	(init_breakpoint_sal): Don't use bp_startup_disabled.
	(create_breakpoint): Don't use bp_startup_disabled.
	(update_global_location_list): Use should_be_inserted.
	(bkpt_re_set): Update.
gdb/testsuite
2011-12-06  Joel Brobecker  <brobecker@@acacore.com>

        * gdb.ada/fullname_bp.exp: Add tests for other valid linespecs
        involving a fully qualified function name.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* gdb.ada/homonym.exp: Add three breakpoint tests.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* gdb.base/solib-weak.exp (do_test): Remove kfail.
	* gdb.trace/tracecmd.exp: Disable pending breakpoints earlier.
	* gdb.objc/objcdecode.exp: Update for output changes.
	* gdb.linespec/linespec.exp: New file.
	* gdb.linespec/lspec.cc: New file.
	* gdb.linespec/lspec.h: New file.
	* gdb.linespec/body.h: New file.
	* gdb.linespec/base/two/thefile.cc: New file.
	* gdb.linespec/base/one/thefile.cc: New file.
	* gdb.linespec/Makefile.in: New file.
	* gdb.cp/templates.exp (test_template_breakpoints): Update for
	output changes.
	* gdb.cp/re-set-overloaded.exp: Remove kfail.
	* gdb.cp/ovldbreak.exp: Update for output changes.  "all" test now
	makes one breakpoint.
	* gdb.cp/method2.exp (test_break): Update for output changes.
	* gdb.cp/mb-templates.exp: Update for output changes.
	* gdb.cp/mb-inline.exp: Update for output changes.
	* gdb.cp/mb-ctor.exp: Update for output changes.
	* gdb.cp/ovsrch.exp: Use fully-qualified names.
	* gdb.base/solib-symbol.exp: Run to main later.  Breakpoint now
	has multiple matches.
	* gdb.base/sepdebug.exp: Disable pending breakpoints.  Update for
	error message change.
	* gdb.base/list.exp (test_list_filename_and_number): Update for
	error message change.
	* gdb.base/break.exp: Disable pending breakpoints.  Update for
	output changes.
	* configure.ac: Add gdb.linespec.
	* configure: Rebuild.
	* Makefile.in (ALL_SUBDIRS): Add gdb.linespec.
gdb/doc
2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* gdb.texinfo (Set Breaks): Update for new behavior.
@
text
@d1052 3
a1054 1
breakpoint_restore_shadows (gdb_byte *buf, ULONGEST memaddr, LONGEST len)
d1166 26
a1191 2
    memcpy (buf + bp_addr - memaddr,
	    bl->target_info.shadow_contents + bptoffset, bp_size);
@


1.626
log
@	* breakpoint.c: Include record.h.
	(breakpoints_always_inserted_mode): Return false when the record
	target is in use.
@
text
@d1579 3
d4568 1
a4568 1
  else if (b->source_file && loc)
d4581 1
a4581 1
      ui_out_field_string (uiout, "file", b->source_file);
d4593 1
a4593 1
      ui_out_field_int (uiout, "line", b->line_number);
d5349 1
a5349 2
			       || b->enable_state == bp_call_disabled
			       || b->enable_state == bp_startup_disabled)
d5824 5
a5828 9
  /* Store the program space that was used to set the breakpoint, for
     breakpoint resetting.  */
  b->pspace = sal.pspace;

  if (sal.symtab == NULL)
    b->source_file = NULL;
  else
    b->source_file = xstrdup (sal.symtab->filename);
  b->line_number = sal.line;
a7011 20
  struct breakpoint *b;
  int found = 0;

  ALL_BREAKPOINTS (b)
    {
      if (b->pspace != current_program_space)
	continue;

      if ((b->type == bp_breakpoint
	   || b->type == bp_hardware_breakpoint)
	  && breakpoint_enabled (b))
	{
	  b->enable_state = bp_startup_disabled;
	  found = 1;
	}
    }

  if (found)
    update_global_location_list (0);

d7013 1
a7018 3
  struct breakpoint *b;
  int found = 0;

d7020 1
a7020 17

  ALL_BREAKPOINTS (b)
    {
      if (b->pspace != current_program_space)
	continue;

      if ((b->type == bp_breakpoint
	   || b->type == bp_hardware_breakpoint)
	  && b->enable_state == bp_startup_disabled)
	{
	  b->enable_state = bp_enabled;
	  found = 1;
	}
    }

  if (found)
    breakpoint_re_set ();
d7075 2
a7076 4
  if (orig->source_file == NULL)
    copy->source_file = NULL;
  else
    copy->source_file = xstrdup (orig->source_file);
d7078 1
a7078 1
  copy->line_number = orig->line_number;
d7162 5
d7223 1
a7223 1
		     char *cond_string,
a7271 1
	  b->pspace = sals.sals[0].pspace;
a7310 5
	  if (enabled && b->pspace->executing_startup
	      && (b->type == bp_breakpoint
		  || b->type == bp_hardware_breakpoint))
	    b->enable_state = bp_startup_disabled;

d7338 1
d7344 1
a7344 1
		       char *cond_string,
d7367 1
a7367 1
		       cond_string,
a7376 132
/* Remove element at INDEX_TO_REMOVE from SAL, shifting other
   elements to fill the void space.  */
static void
remove_sal (struct symtabs_and_lines *sal, int index_to_remove)
{
  int i = index_to_remove+1;
  int last_index = sal->nelts-1;

  for (;i <= last_index; ++i)
    sal->sals[i-1] = sal->sals[i];

  --(sal->nelts);
}

/* If appropriate, obtains all sals that correspond to the same file
   and line as SAL, in all program spaces.  Users debugging with IDEs,
   will want to set a breakpoint at foo.c:line, and not really care
   about program spaces.  This is done only if SAL does not have
   explicit PC and has line and file information.  If we got just a
   single expanded sal, return the original.

   Otherwise, if SAL.explicit_line is not set, filter out all sals for
   which the name of enclosing function is different from SAL.  This
   makes sure that if we have breakpoint originally set in template
   instantiation, say foo<int>(), we won't expand SAL to locations at
   the same line in all existing instantiations of 'foo'.  */

static struct symtabs_and_lines
expand_line_sal_maybe (struct symtab_and_line sal)
{
  struct symtabs_and_lines expanded;
  CORE_ADDR original_pc = sal.pc;
  char *original_function = NULL;
  int found;
  int i;
  struct cleanup *old_chain;

  /* If we have explicit pc, don't expand.
     If we have no line number, we can't expand.  */
  if (sal.explicit_pc || sal.line == 0 || sal.symtab == NULL)
    {
      expanded.nelts = 1;
      expanded.sals = xmalloc (sizeof (struct symtab_and_line));
      expanded.sals[0] = sal;
      return expanded;
    }

  sal.pc = 0;

  old_chain = save_current_space_and_thread ();

  switch_to_program_space_and_thread (sal.pspace);

  find_pc_partial_function (original_pc, &original_function, NULL, NULL);

  /* Note that expand_line_sal visits *all* program spaces.  */
  expanded = expand_line_sal (sal);

  if (expanded.nelts == 1)
    {
      /* We had one sal, we got one sal.  Return that sal, adjusting it
         past the function prologue if necessary.  */
      xfree (expanded.sals);
      expanded.nelts = 1;
      expanded.sals = xmalloc (sizeof (struct symtab_and_line));
      sal.pc = original_pc;
      expanded.sals[0] = sal;
      skip_prologue_sal (&expanded.sals[0]);
      do_cleanups (old_chain);
      return expanded;      
    }

  if (!sal.explicit_line)
    {
      CORE_ADDR func_addr, func_end;
      for (i = 0; i < expanded.nelts; ++i)
	{
	  CORE_ADDR pc = expanded.sals[i].pc;
	  char *this_function;

	  /* We need to switch threads as well since we're about to
	     read memory.  */
	  switch_to_program_space_and_thread (expanded.sals[i].pspace);

	  if (find_pc_partial_function (pc, &this_function, 
					&func_addr, &func_end))
	    {
	      if (this_function
		  && strcmp (this_function, original_function) != 0)
		{
		  remove_sal (&expanded, i);
		  --i;
		}
	    }
	}
    }

  /* Skip the function prologue if necessary.  */
  for (i = 0; i < expanded.nelts; ++i)
    skip_prologue_sal (&expanded.sals[i]);

  do_cleanups (old_chain);

  if (expanded.nelts <= 1)
    {
      /* This is an ugly workaround.  If we get zero expanded sals
         then something is really wrong.  Fix that by returning the
         original sal.  */

      xfree (expanded.sals);
      expanded.nelts = 1;
      expanded.sals = xmalloc (sizeof (struct symtab_and_line));
      sal.pc = original_pc;
      expanded.sals[0] = sal;
      return expanded;      
    }

  if (original_pc)
    {
      found = 0;
      for (i = 0; i < expanded.nelts; ++i)
	if (expanded.sals[i].pc == original_pc)
	  {
	    found = 1;
	    break;
	  }
      gdb_assert (found);
    }

  return expanded;
}

a7393 1
			struct symtabs_and_lines sals,
d7402 4
d7407 1
a7407 1
  for (i = 0; i < sals.nelts; ++i)
d7409 12
a7420 4
      struct symtabs_and_lines expanded = 
	expand_line_sal_maybe (sals.sals[i]);

      create_breakpoint_sal (gdbarch, expanded, canonical->canonical[i],
d7425 1
a7438 1
		       struct symtabs_and_lines *sals,
d7452 1
d7456 1
a7456 1
	  sals->sals = (struct symtab_and_line *)
d7471 5
a7475 2
	  sals->sals[0] = sal;
	  sals->nelts = 1;
d7485 6
a7490 16
	 time while leaving the last displayed codepoint pointers
	 alone.

         ObjC: However, don't match an Objective-C method name which
         may have a '+' or '-' succeeded by a '[' */
	 
      struct symtab_and_line cursal = get_current_source_symtab_and_line ();
			
      if (last_displayed_sal_is_valid ()
	  && (!cursal.symtab
 	      || ((strchr ("+-", (*address)[0]) != NULL)
 		  && ((*address)[1] != '['))))
	*sals = decode_line_1 (address, 1,
			       get_last_displayed_symtab (),
			       get_last_displayed_line (),
			       canonical);
d7492 3
a7494 17
	*sals = decode_line_1 (address, 1, (struct symtab *) NULL, 0,
		               canonical);
    }
  /* For any SAL that didn't have a canonical string, fill one in.  */
  if (sals->nelts > 0 && canonical->canonical == NULL)
    canonical->canonical = xcalloc (sals->nelts, sizeof (char *));
  if (addr_start != (*address))
    {
      int i;

      for (i = 0; i < sals->nelts; i++)
	{
	  /* Add the string if not present.  */
	  if (canonical->canonical[i] == NULL)
	    canonical->canonical[i] = savestring (addr_start, 
						  (*address) - addr_start);
	}
d7529 2
d7533 6
a7538 1
      rslt = gdbarch_fast_tracepoint_valid_at (gdbarch, sal->pc,
d7544 1
a7544 1
	       paddress (gdbarch, sal->pc), (msg ? msg : ""));
d7686 1
a7686 3
  struct symtabs_and_lines sals;
  struct symtab_and_line pending_sal;
  char *copy_arg;
a7697 2
  sals.sals = NULL;
  sals.nelts = 0;
d7703 1
d7705 1
a7705 1
      sals = decode_static_tracepoint_spec (&arg);
d7708 4
a7711 3
      canonical.canonical = xcalloc (sals.nelts, sizeof (char *));
      for (i = 0; i < sals.nelts; i++)
	canonical.canonical[i] = xstrdup (copy_arg);
d7717 1
a7717 1
      parse_breakpoint_sals (&arg, &sals, &canonical);
d7749 11
a7759 6
	  copy_arg = xstrdup (addr_start);
	  canonical.canonical = &copy_arg;
	  sals.nelts = 1;
	  sals.sals = &pending_sal;
	  pending_sal.pc = 0;
	  pending = 1;
d7766 1
a7766 1
      if (!sals.nelts)
d7773 1
a7773 10
  old_chain = make_cleanup (null_cleanup, 0);

  if (!pending)
    {
      /* Make sure that all storage allocated to SALS gets freed.  */
      make_cleanup (xfree, sals.sals);
      
      /* Cleanup the canonical array but not its contents.  */
      make_cleanup (xfree, canonical.canonical);
    }
a7780 8
  /* Mark the contents of the canonical for cleanup.  These go on
     the bkpt_chain and only occur if the breakpoint create fails.  */
  for (i = 0; i < sals.nelts; i++)
    {
      if (canonical.canonical[i] != NULL)
	make_cleanup (xfree, canonical.canonical[i]);
    }

d7784 7
a7790 1
    breakpoint_sals_to_pc (&sals);
d7794 7
a7800 1
    check_fast_tracepoint_sals (gdbarch, &sals);
d7807 4
d7819 1
a7819 1
            find_condition_and_thread (arg, sals.sals[0].pc, &cond_string,
d7841 1
a7841 1
	  && is_marker_spec (canonical.canonical[0]))
d7845 1
a7845 1
	  for (i = 0; i < sals.nelts; ++i)
d7850 1
d7853 4
a7856 3
	      expanded.sals = xmalloc (sizeof (struct symtab_and_line));
	      expanded.sals[0] = sals.sals[i];
	      old_chain = make_cleanup (xfree, expanded.sals);
d7860 1
a7860 1
				   canonical.canonical[i],
d7876 1
a7876 1
	      do_cleanups (old_chain);
d7880 1
a7880 1
	create_breakpoints_sal (gdbarch, sals, &canonical, cond_string,
d7904 1
a7904 1
      b->addr_string = canonical.canonical[0];
d7910 2
a7911 6
      b->pspace = current_program_space;

      if (enabled && b->pspace->executing_startup
	  && (b->type == bp_breakpoint
	      || b->type == bp_hardware_breakpoint))
	b->enable_state = bp_startup_disabled;
d7916 1
a7916 1
  if (sals.nelts > 1)
a8296 1
  struct symtabs_and_lines sals_start, sals_end;
d8298 1
d8311 1
a8314 2
  sals_start.sals = NULL;
  sals_start.nelts = 0;
d8317 2
a8318 2
  while (*arg == ' ' || *arg == '\t')
    arg++;
d8320 1
a8320 7
  parse_breakpoint_sals (&arg, &sals_start, &canonical_start);

  sal_start = sals_start.sals[0];
  addr_string_start = canonical_start.canonical[0];
  cleanup_bkpt = make_cleanup (xfree, addr_string_start);
  xfree (sals_start.sals);
  xfree (canonical_start.canonical);
d8324 1
a8324 1
  else if (sals_start.nelts == 0)
d8326 5
a8330 1
  else if (sals_start.nelts != 1)
d8333 3
a8335 1
  resolve_sal_pc (&sal_start);
d8338 1
a8338 2
  while (*arg == ' ' || *arg == '\t')
    arg++;
a8341 2
  sals_end.sals = NULL;
  sals_end.nelts = 0;
d8345 1
a8345 1
  /* We call decode_line_1 directly here instead of using
d8350 3
a8352 2
  sals_end = decode_line_1 (&arg, 1, sal_start.symtab, sal_start.line,
			    &canonical_end);
d8354 1
a8354 6
  /* canonical_end can be NULL if it was of the form "*0xdeadbeef".  */
  if (canonical_end.canonical == NULL)
    canonical_end.canonical = xcalloc (1, sizeof (char *));
  /* Add the string if not present.  */
  if (arg_start != arg && canonical_end.canonical[0] == NULL)
    canonical_end.canonical[0] = savestring (arg_start, arg - arg_start);
d8356 2
a8357 5
  sal_end = sals_end.sals[0];
  addr_string_end = canonical_end.canonical[0];
  make_cleanup (xfree, addr_string_end);
  xfree (sals_end.sals);
  xfree (canonical_end.canonical);
d8359 3
a8361 3
  if (sals_end.nelts == 0)
    error (_("Could not find location of the end of the range."));
  else if (sals_end.nelts != 1)
d8364 3
a8366 1
  resolve_sal_pc (&sal_end);
d8393 2
a8394 2
  b->addr_string = addr_string_start;
  b->addr_string_range_end = addr_string_end;
d8397 1
a8397 1
  discard_cleanups (cleanup_bkpt);
d9504 1
a9504 1
    sals = decode_line_1 (&arg, 1,
d9506 1
a9506 2
			  get_last_displayed_line (),
			  NULL);
d9508 2
a9509 1
    sals = decode_line_1 (&arg, 1, (struct symtab *) NULL, 0, NULL);
d10020 2
a10021 1
      sals = decode_line_spec (arg, 1);
d10093 10
a10102 7
		  int pc_match = sal.pc
		    && (loc->pspace == sal.pspace)
		    && (loc->address == sal.pc)
		    && (!section_is_overlay (loc->section)
			|| loc->section == sal.section);
		  int line_match = ((default_match || (0 == sal.pc))
				    && b->source_file != NULL
d10105 1
a10105 1
				    && filename_cmp (b->source_file,
d10107 1
a10107 1
				    && b->line_number == sal.line);
d10572 1
a10572 5
      if (b->enable_state == bp_disabled
	  || b->enable_state == bp_call_disabled
	  || b->enable_state == bp_startup_disabled
	  || !loc->enabled
	  || loc->shlib_disabled
d10699 1
a10699 1
      if (opts.addressprint || b->source_file == NULL)
d10705 13
a10717 3
      if (b->source_file)
	printf_filtered (": file %s, line %d.",
			 b->source_file, b->line_number);
d10737 1
d10754 1
a10755 1
  xfree (self->source_file);
a10868 4
  /* Do not attempt to re-set breakpoints disabled during startup.  */
  if (b->enable_state == bp_startup_disabled)
    return;

d11590 1
a11590 1
	  b->line_number = sal.line;
d11592 1
a11592 1
	  xfree (b->source_file);
d11594 1
a11594 1
	    b->source_file = xstrdup (sal.symtab->filename);
d11596 1
a11596 1
	    b->source_file = NULL;
d11600 2
a11601 1
				       sal.symtab->filename, b->line_number);
d11651 11
a11661 2
  /* Ranged breakpoints have only one start location and one end location.  */
  gdb_assert (sals_end.nelts == 0 || (sals.nelts == 1 && sals_end.nelts == 1));
d11676 5
a11680 2
      struct bp_location *new_loc = 
	add_location_to_breakpoint (b, &(sals.sals[i]));
a11703 10
      if (b->source_file != NULL)
	xfree (b->source_file);
      if (sals.sals[i].symtab == NULL)
	b->source_file = NULL;
      else
	b->source_file = xstrdup (sals.sals[i].symtab->filename);

      if (b->line_number == 0)
	b->line_number = sals.sals[i].line;

d11770 1
a11770 1
  struct gdb_exception e;
d11791 25
a11815 1
	sals = decode_line_1 (&s, 1, (struct symtab *) NULL, 0, NULL);
d11830 1
d11849 1
a11849 1
      gdb_assert (sals.nelts == 1);
d11851 2
a11852 1
      resolve_sal_pc (&sals.sals[0]);
d11895 1
a11895 1
      expanded = expand_line_sal_maybe (sals.sals[0]);
d11904 1
a11904 1
	  expanded_end = expand_line_sal_maybe (sals_end.sals[0]);
d11920 2
a11921 1
  switch_to_program_space_and_thread (b->pspace);
d12433 1
a12433 1
decode_line_spec_1 (char *string, int funfirstline)
d12440 1
a12440 1
    sals = decode_line_1 (&string, funfirstline,
d12442 1
a12442 2
			  get_last_displayed_line (),
			  NULL);
d12444 1
a12444 2
    sals = decode_line_1 (&string, funfirstline,
			  (struct symtab *) NULL, 0, NULL);
@


1.625
log
@* breakpoint.c (init_breakpoint_sal): Remove nested definitions of
  `i'(-Wshadow).
@
text
@d70 1
d381 3
a383 2
  return (always_inserted_mode == always_inserted_on
	  || (always_inserted_mode == always_inserted_auto && non_stop));
@


1.624
log
@gdb
	PR mi/8444:
	* mi/mi-common.h (EXEC_ASYNC_SOLIB_EVENT, EXEC_ASYNC_FORK)
	(EXEC_ASYNC_VFORK, EXEC_ASYNC_SYSCALL_ENTRY)
	(EXEC_ASYNC_SYSCALL_RETURN, EXEC_ASYNC_EXEC): New constants.
	* mi/mi-common.c (async_reason_string_lookup): Add new reasons.
	* breakpoint.c (print_it_catch_fork, print_it_catch_vfork)
	(print_it_catch_syscall, print_it_catch_exec)
	(internal_bkpt_print_it): Use ui_out.  Emit stop reason.
	(bpstat_print): Add 'kind' argument.  Handle
	TARGET_WAITKIND_LOADED.
	* infrun.c (normal_stop): Update for bpstat_print change.  Don't
	handle TARGET_WAITKIND_LOADED here.
	* breakpoint.h (bpstat_print): Update.
gdb/testsuite
	* lib/mi-support.exp (mi_run_cmd_full): Rename from mi_run_cmd.
	Add "use_mi_command" argument.
	(mi_run_cmd, mi_run_with_cli): New procs.
	* gdb.mi/solib-lib.c: New file.
	* gdb.mi/solib-main.c: New file.
	* gdb.mi/mi-solib.exp: New file.
gdb/doc
	* gdb.texinfo (GDB/MI Async Records): Document new *stopped
	reasons.
@
text
@d7268 5
a7272 3
      int i = hw_breakpoint_used_count ();
      int target_resources_ok = 
	target_can_use_hardware_watchpoint (bp_hardware_breakpoint, 
a7320 1
		  int i;
@


1.623
log
@	* NEWS: Mention tracepoint additions.
	* breakpoint.h (struct tracepoint): New field traceframe_usage.
	* breakpoint.c (print_one_breakpoint_location): Identify
	tracepoints as such when reporting hit counts, report
	trace buffer usage.
	(create_tracepoint_from_upload): Copy status info.
	* tracepoint.h (struct trace_status): Rename error_desc to stop_desc,
	add fields user_name, notes, start_time, stop_time.
	(struct uploaded_tp): Add fields hit_count, traceframe_usage.
	* tracepoint.c (trace_user): New global.
	(trace_notes): New global.
	(trace_stop_notes): New global.
	(start_tracing): Add argument and trace note handling.
	(stop_tracing): Ditto.
	(trace_start_command): Add notes argument.
	(trace_stop_command): Ditto.
	(trace_status_command): Report additional status info.
	(trace_status_mi): Similarly.
	(trace_save): Update, record tracepoint status.
	(set_disconnected_tracing): Call target method directly.
	(send_disconnected_tracing_value): Remove.
	(set_trace_user): New function.
	(set_trace_notes): New function.
	(set_trace_stop_notes): New function.
	(parse_trace_status): Handle additional status.
	(parse_tracepoint_status): New function.
	(parse_tracepoint_definition): Call it.
	(tfile_get_tracepoint_status): New function.
	(init_tfile_ops): Use it.
	(_initialize_tracepoint): Add new setshows.
	* target.h (struct target_ops): New methods to_get_tracepoint_status
	and to_set_trace_notes.
	(target_get_tracepoint_status): New macro.
	(target_set_trace_notes): New macro.
	* target.c (update_current_target): Add new methods.
	* remote.c (remote_get_tracepoint_status): New function.
	(remote_set_trace_notes): New function.
	(init_remote_ops): Add them.
	* mi/mi-main.c (mi_cmd_trace_start): Add argument to call.
	(mi_cmd_trace_stop): Ditto.

	* tracepoint.c (struct tracepoint): New field traceframe_usage.
	(tracing_start_time): New global.
	(tracing_stop_time): New global.
	(tracing_user_name): New global.
	(tracing_notes): New global.
	(tracing_stop_note): New global.
	(cmd_qtstart): Set traceframe_usage, start_time.
	(stop_tracing): Set stop_time.
	(cmd_qtstatus): Report additional status.
	(cmd_qtp): New function.
	(handle_tracepoint_query): Call it.
	(cmd_qtnotes): New function.
	(handle_tracepoint_general_set): Call it.
	(get_timestamp): Rename from tsv_get_timestamp.

	* gdb.texinfo (Starting and Stopping Trace Experiments): Document
	note-related options and variables.
	(Tracepoint Packets): Document packet changes.

	* gdb.trace/tstatus.exp: New.
	* gdb.trace/actions.c: Include string.h.
@
text
@d3449 2
a3450 1
   list - a list of the eventpoints that caused this stop.  This
d3469 1
a3469 1
bpstat_print (bpstat bs)
d3486 12
d6206 1
d6211 14
a6224 2
  printf_filtered (_("\nCatchpoint %d (forked process %d), "),
		   b->number, ptid_get_pid (c->forked_inferior_pid));
d6315 1
d6320 14
a6333 2
  printf_filtered (_("\nCatchpoint %d (vforked process %d), "),
		   b->number, ptid_get_pid (c->forked_inferior_pid));
d6542 1
a6550 1
  struct cleanup *old_chain;
d6559 2
a6560 2
  if (s.name == NULL)
    syscall_id = xstrprintf ("%d", last.value.syscall_number);
d6562 10
a6571 1
    syscall_id = xstrprintf ("'%s'", s.name);
d6573 4
a6576 1
  old_chain = make_cleanup (xfree, syscall_id);
d6578 4
a6581 6
  if (last.kind == TARGET_WAITKIND_SYSCALL_ENTRY)
    printf_filtered (_("\nCatchpoint %d (call to syscall %s), "),
                     b->number, syscall_id);
  else if (last.kind == TARGET_WAITKIND_SYSCALL_RETURN)
    printf_filtered (_("\nCatchpoint %d (returned from syscall %s), "),
                     b->number, syscall_id);
d6583 1
a6583 1
  do_cleanups (old_chain);
d6828 1
d6833 15
a6847 2
  printf_filtered (_("\nCatchpoint %d (exec'd %s), "), b->number,
		   c->exec_pathname);
d11219 1
d11230 4
a11233 1
      printf_filtered (_("Stopped due to shared library event\n"));
@


1.622
log
@gdb/
	* breakpoint.c (create_breakpoint): Produce query message according to
	breakpoint's type.
	Allocate tracepoint per correct type.
	Don't check SALs for pending fast tracepoints.
	* tracepoint.c (process_tracepoint_on_disconnect): New.
	(disconnect_tracing): Call process_tracepoint_on_disconnect.

gdb/doc/
	* gdb.texinfo (Create and Delete Tracepoints): Mention pending
	tracepoint.

gdb/testsuite/
	* gdb.trace/pending.exp: New.
	* gdb.trace/pending.c: New.
	* gdb.trace/pendshr1.c: New.
	* gdb.trace/pendshr2.c: New.
	* gdb.trace/change-loc.exp (tracepoint_change_loc_1): Check one
	tracepoint location becomes pending.
	(tracepoint_change_loc_2): New.
@
text
@d4882 2
d4908 12
d12921 4
@


1.621
log
@	* breakpoint.c (install_breakpoint):  Add one more parameter so that
	update_global_location_list is called conditionally.
	(create_fork_vfork_event_catchpoint): Update.
	(create_syscall_event_catchpoint): Update.
	(create_breakpoint_sal): Update.
	(create_breakpoint_sal): Update. Call do_cleanups before
	install_breakpoint.
	* ada-lang.c (create_ada_exception_catchpoint): Update.
	* breakpoint.h (install_breakpoint): Update declaration.
@
text
@d7839 2
a7840 2
	      && !nquery (_("Make breakpoint pending on "
			    "future shared library load? ")))
d7897 1
a7897 1
  if (type_wanted == bp_fast_tracepoint)
d7984 12
a7995 3
      b = set_raw_breakpoint_without_location (gdbarch, type_wanted, ops);
      set_breakpoint_number (internal, b);
      b->thread = -1;
a8002 1
      b->py_bp_object = NULL;
d8009 1
a8009 5
      if (!internal)
        /* Do not mention breakpoints with a negative number, 
	   but do notify observers.  */
	mention (b);
      observer_notify_breakpoint_created (b);
@


1.620
log
@gdb/
	* remote.c (struct remote_state): <install_in_trace> new field.
	(PACKET_InstallInTrace): New enum value.
	(remote_install_in_trace_feature): Support InstallInTrace.
	(remote_supports_install_in_trace): Likewise.
	(remote_protocol_features): Likewise.
	(_initialize_remote): Likewise.
	(remote_can_download_tracepoint): New.
	* target.h (struct target): New field
	`to_can_download_tracepoint'.
	(target_can_download_tracepoint): New macro.
	* target.c (update_current_target): Update.
	* breakpoint.h (struct bp_location): Add comment on field
	`duplicate'.
	(should_be_inserted): Don't differentiate breakpoint and tracepoint.
	(remove_breakpoints): Don't remove tracepoints.
	(tracepoint_locations_match ): New.
	(breakpoint_locations_match): Call it.
	(disable_breakpoints_in_unloaded_shlib): Handle tracepoint.
	(download_tracepoint_locations): New.
	(update_global_location_list): Call it.
	* tracepoint.c (find_matching_tracepoint): Delete.
	(find_matching_tracepoint_location): Renamed from
	find_matching_tracepoint.  Return bp_location rather than
	tracepoint.
	(merge_uploaded_tracepoints): Set `inserted' field to 1 if
	tracepoint is found.

gdb/doc/
	* gdb.texinfo (Create and Delete Tracepoints): Describe changed
	behavior of tracepoint.
	(General Query Packets): New feature InstallInTrace.
	(Remote Configuration): Document "set remote
	install-in-trace-packet".

gdb/gdbserver/
	* server.c (handle_query): Handle InstallInTrace for qSupported.
	* tracepoint.c (add_tracepoint): Sort list.
	(install_tracepoint, download_tracepoint): New.
	(cmd_qtdp): Call them to install and download tracepoints.
	(sort_tracepoints): Removed.
	(cmd_qtstart): Update.

gdb/testsuite/
	* gdb.trace/change-loc-1.c: New.
	* gdb.trace/change-loc-2.c: New.
	* gdb.trace/change-loc.c: New.
	* gdb.trace/change-loc.exp:  New.
	* gdb.trace/change-loc.h:  New.
	* gdb.trace/trace-break.c (marker): Define new symbol.
	* gdb.trace/trace-break.exp (break_trace_same_addr_5):
        New.
	(break_trace_same_addr_6): New.
@
text
@d6683 1
a6683 1
install_breakpoint (int internal, struct breakpoint *b)
d6690 3
a6692 1
  update_global_location_list (1);
d6706 1
a6706 1
  install_breakpoint (0, &c->base);
d6827 1
a6827 1
  install_breakpoint (0, &c->base);
d7336 1
a7336 1
  install_breakpoint (internal, b);
d7966 1
a7966 1
	      install_breakpoint (internal, &tp->base);
d9402 1
a9402 1
  install_breakpoint (internal, b);
d9800 1
a9800 1
  install_breakpoint (0, &c->base);
@


1.619
log
@	* breakpoint.c (init_raw_breakpoint): Call
	add_location_to_breakpoint to replace duplicated code.
	(add_location_to_breakpoint): Adjust the breakpoint's
	address prior to allocating a location.
@
text
@d1561 4
a1564 1
   inserted in the inferior.  */
a1587 5
  /* Tracepoints are inserted by the target at a time of its choosing,
     not by us.  */
  if (is_tracepoint (bl->owner))
    return 0;

d2053 1
a2053 1
    if (bl->inserted)
d5447 17
d5485 2
d6070 2
a6071 2
/* Disable any breakpoints that are in an unloaded shared library.
   Only apply to enabled breakpoints, disabled ones can just stay
d6093 1
a6093 3
    if ((loc->loc_type == bp_loc_hardware_breakpoint
	 || loc->loc_type == bp_loc_software_breakpoint)
	&& solib->pspace == loc->pspace
d6095 6
a6100 3
	&& (b->type == bp_breakpoint
	    || b->type == bp_jit_event
	    || b->type == bp_hardware_breakpoint)
d10336 43
d10388 6
d10673 3
d10723 3
@


1.618
log
@	* defs.h (is_cplus_marker, set_demangling_style): Moved to ...
	* gdb-demangle.h: ... here.  New file.
	* demangle.c: #include "gdb-demangle.h".
	(_initialize_demangler): Use initialize_file_ftype for prototype.
	Move "set demangle" and "set asm-demangle" parameters here from utils.c
	(demangle, show_demangle, asm_demangle, show_asm_demangle): Move here
	from utils.c
	* utils.c: Update. #include "gdb-demangle.h".
	* symtab.h (asm_demangle): Delete.
	(demangle): Move declaration next to use.
	* breakpoint.c: #include "gdb-demangle.h" instead of "demangle.h".
	* dwarf2read.c: #include "gdb-demangle.h".
	* gnu-v2-abi.c: Ditto.
	* jv-typeprint.c: Ditto.
	* mdebugread.c: Ditto.
	* p-typeprint.c: Ditto.
	* stabsread.c: Ditto.
	* printcmd.c: Ditto.
	(asm_demangle): Delete declaration.
	* tui/tui-stack.c: #include "gdb-demangle.h".
@
text
@d114 3
a5768 3
  CORE_ADDR adjusted_address;
  struct gdbarch *loc_gdbarch;

d5771 1
a5771 3
  loc_gdbarch = get_sal_arch (sal);
  if (!loc_gdbarch)
    loc_gdbarch = b->gdbarch;
a5775 15
  /* Adjust the breakpoint's address prior to allocating a location.
     Once we call allocate_bp_location(), that mostly uninitialized
     location will be placed on the location chain.  Adjustment of the
     breakpoint may cause target_read_memory() to be called and we do
     not want its scan of the location chain to find a breakpoint and
     location that's only been partially initialized.  */
  adjusted_address = adjust_breakpoint_address (loc_gdbarch, 
						sal.pc, b->type);

  b->loc = allocate_bp_location (b);
  b->loc->gdbarch = loc_gdbarch;
  b->loc->requested_address = sal.pc;
  b->loc->address = adjusted_address;
  b->loc->pspace = sal.pspace;

a5783 1
  b->loc->section = sal.section;
a5785 3
  set_breakpoint_location_function (b->loc,
				    sal.explicit_pc || sal.explicit_line);

d7079 14
d7098 1
a7098 3
  loc->gdbarch = get_sal_arch (*sal);
  if (!loc->gdbarch)
    loc->gdbarch = b->gdbarch;
d7100 1
a7100 2
  loc->address = adjust_breakpoint_address (loc->gdbarch,
					    loc->requested_address, b->type);
d7104 1
a7104 1

@


1.617
log
@2011-10-06  Justin Lebar  <justin.lebar@@gmail.com>

	* Makefile.in: (SFILES): Add skip.c.
	(HFILES_NO_SRCDIR): Add skip.h.
	(COMMON_OBS): Add skip.o.
	* skip.h, skip.c: New.
	* breakpoint.h (set_default_breakpoint): Remove.
	(get_sal_arch): Declare.
	* breakpoint.c: Remove default_breakpoint_valid,
	default_breakpoint_address, default_breakpoint_symtab,
	default_breakpoint_line, default_breakpoint_pspace variables.
	(get_sal_arch): Make public.
	(set_default_breakpoint): Remove.
	(parse_breakpoint_sals, create_breakpoint, clear_command,
	decode_line_spec_1): Remove uses of default_breakpoint variables;
	replaced with function calls into stack.c.
	* cli/cli-cmds.h: Add cmd_list_element *skiplist.
	* cli/cli-cmds.c: Add skiplist.
	(init_cmd_lists): Initialize skiplist.
	(init_cli_cmds): Fix comment (classes of commands appear in
	alphabetical order).
	* infrun.c (handle_inferior_event): Add check that we don't step into
	a function whose pc is marked for skip.
	* stack.c: Declare last_displayed_sal_valid, last_displayed_pspace,
	last_displayed_addr, last_displayed_symtab, last_displayed_line
	variables.
	(set_last_displayed_sal): New static function.
	(print_frame_info): Switch call to set_default_breakpoint to call to
	set_last_displayed_sal.
	(clear_last_displayed_sal, last_displayed_sal_is_valid,
	get_last_displayed_pspace, get_last_displayed_addr,
	get_last_displayed_symtab, get_last_displayed_line,
	get_last_displayed_sal): New public functions.
	* stack.h (clear_last_displayed_sal, last_displayed_sal_is_valid,
	get_last_displayed_pspace, get_last_displayed_addr,
	get_last_displayed_symtab, get_last_displayed_line,
	get_last_displayed_sal): Declare.

2011-10-06  Justin Lebar <justin.lebar@@gmail.com>

	Add tests for skip command.
	* testsuite/gdb.base/skip-solib-lib.c: New
	* testsuite/gdb.base/skip-solib-main.c: New
	* testsuite/gdb.base/skip-solib.exp: New
	* testsuite/gdb.base/skip.c: New
	* testsuite/gdb.base/skip.exp: New
	* testsuite/gdb.base/skip1.c: New
	* testsuite/gdb.base/Makefile.in: Adding new files.
@
text
@d41 1
a41 1
#include "demangle.h"
@


1.616
log
@2011-10-12  Gary Benson  <gbenson@@redhat.com>

	* breakpoint.h (pc_at_non_inline_function): Declare.
	* breakpoint.c (is_non_inline_function,
	pc_at_non_inline_function): New functions.
	* infrun.c (handle_inferior_event): Don't call skip_inline_frames
	if the stop is at a location where functions cannot be inlined.
@
text
@d68 2
a576 13
/* Default address, symtab and line to put a breakpoint at
   for "break" command with no arg.
   If default_breakpoint_valid is zero, the other three are
   not valid, and "break" with no arg is an error.

   This set by print_stack_frame, which calls set_default_breakpoint.  */

int default_breakpoint_valid;
CORE_ADDR default_breakpoint_address;
struct symtab *default_breakpoint_symtab;
int default_breakpoint_line;
struct program_space *default_breakpoint_pspace;

a5330 14
/* Set the default place to put a breakpoint
   for the `break' command with no arguments.  */

void
set_default_breakpoint (int valid, struct program_space *pspace,
			CORE_ADDR addr, struct symtab *symtab,
			int line)
{
  default_breakpoint_valid = valid;
  default_breakpoint_pspace = pspace;
  default_breakpoint_address = addr;
  default_breakpoint_symtab = symtab;
  default_breakpoint_line = line;
}
d5742 1
a5742 1
static struct gdbarch *
d7521 3
a7523 1
      if (default_breakpoint_valid)
d7530 5
a7534 5
	  sal.pc = default_breakpoint_address;
	  sal.line = default_breakpoint_line;
	  sal.symtab = default_breakpoint_symtab;
	  sal.pspace = default_breakpoint_pspace;
	  sal.section = find_pc_overlay (sal.pc);
d7537 4
a7540 4
	     where PC is the default_breakpoint_address.  So make sure
	     to set sal.explicit_pc to prevent GDB from trying to
	     expand the list of sals to include all other instances
	     with the same symtab and line.  */
d7554 2
a7555 1
         time while leaving default_breakpoint_* alone.
d7562 1
a7562 1
      if (default_breakpoint_valid
d7566 4
a7569 2
	*sals = decode_line_1 (address, 1, default_breakpoint_symtab,
			       default_breakpoint_line, canonical);
d9594 5
a9598 3
  if (default_breakpoint_valid)
    sals = decode_line_1 (&arg, 1, default_breakpoint_symtab,
			  default_breakpoint_line, NULL);
d10120 5
a10124 4
      sal.line = default_breakpoint_line;
      sal.symtab = default_breakpoint_symtab;
      sal.pc = default_breakpoint_address;
      sal.pspace = default_breakpoint_pspace;
d11972 3
d12424 2
a12425 1
/* Use default_breakpoint_'s, or nothing if they aren't valid.  */
d12434 1
a12434 1
  if (default_breakpoint_valid)
d12436 2
a12437 2
			  default_breakpoint_symtab,
			  default_breakpoint_line,
@


1.615
log
@thread-specific breakpoints not saved properly by save-breakpoint

Initially, I noticed that the save command was often missing
new lines in the file that it generated.  For instance, consider:

        % gdb save-bp
        (gdb) b break_me
        (gdb) b save-bp.c:27
        (gdb) save breakpoints bps

The contents of the bps file would be:

        % cat bps
        break break_mebreak save-bp.c:27

Looking further into the problem, I realized that the missing newlines
are just a consequence of a missing call to print_recreate_thread.
After having generated the breakpoint location in the break command,
we cannot put a new line until we have looked at whether we need to
add a 'thread NUM' argument.

gdb/ChangeLog:

        * breakpoint.c (bkpt_print_recreate): Add call to
        print_recreate_thread.

gdb/testsuite/ChangeLog:

        * gdb.base/save-bp.exp, gdb.base/save-bp.c: New files.
@
text
@d13328 39
@


1.614
log
@2011-09-15  Kevin Pouget  <kevin.pouget@@st.com>

	* breakpoint.c (describe_other_breakpoints): Do not write 'duplicate'
	note if the breakpoint is internal.
@
text
@d11050 1
@


1.613
log
@2011-09-13  Pedro Alves  <pedro@@codesourcery.com>

	* breakpoint.c (update_watchpoint): Handle the case of the
	watchpoint to update not being in the breakpoint list yet.
	(hw_watchpoint_use_count): New, factored out from
	hw_watchpoint_used_count.
	(hw_watchpoint_used_count): Rename to ...
	(hw_watchpoint_used_count_others): ... this.  Add `except'
	parameter.  Don't count resources of `except'.  Use
	hw_watchpoint_use_count.
@
text
@d5295 1
a5295 1
/* Print a message describing any breakpoints set at PC.  This
d5308 2
a5309 1
    others += breakpoint_has_pc (b, pspace, pc, section);
d5317 1
a5317 1
	if (breakpoint_has_pc (b, pspace, pc, section))
@


1.612
log
@gdb/
	* breakpoint.c (bpstat_do_actions): New variable cleanup_if_error, call
	make_bpstat_clear_actions_cleanup and discard_cleanups for it.
	* defs.h (make_bpstat_clear_actions_cleanup): New declaration.
	* exceptions.c (throw_exception): Remove the bpstat_clear_actions call.
	* inf-loop.c (inferior_event_handler): New variable cleanup_if_error,
	call make_bpstat_clear_actions_cleanup and discard_cleanups for it.
	Call bpstat_clear_actions for failed fetch_inferior_event_wrapper.
	* infrun.c (fetch_inferior_event): Call
	make_bpstat_clear_actions_cleanup.
	* top.c (execute_command): New variable cleanup_if_error, call
	make_bpstat_clear_actions_cleanup and discard_cleanups for it.
	* utils.c (do_bpstat_clear_actions_cleanup)
	(make_bpstat_clear_actions_cleanup): New functions.

gdb/testsuite/
	* gdb.base/commands.exp (error_clears_commands_left): New function.
	(): Call it.
@
text
@d179 5
a183 1
static int hw_watchpoint_used_count (enum bptype, int *);
d1465 1
d1474 23
a1496 10
		 this watchpoint in as well.  To guarantee the
		 hw_watchpoint_used_count call below counts this
		 watchpoint, make sure that it is marked as a hardware
		 watchpoint.  */
	      if (b->base.type == bp_watchpoint)
		b->base.type = bp_hardware_watchpoint;

	      i = hw_watchpoint_used_count (b->base.type, &other_type_used);
	      target_resources_ok = target_can_use_hardware_watchpoint
		    (b->base.type, i, other_type_used);
d1507 11
a1517 2
		  else
		    b->base.type = bp_watchpoint;
d6876 27
d6904 2
a6905 1
hw_watchpoint_used_count (enum bptype type, int *other_type_used)
a6908 1
  struct bp_location *bl;
d6913 2
d6918 4
a6921 9
	if (b->type == type)
	  for (bl = b->loc; bl; bl = bl->next)
	    {
	      /* Special types of hardware watchpoints may use more than
		 one register.  */
	      i += b->ops->resources_needed (bl);
	    }
	else if (is_hardware_watchpoint (b))
	  *other_type_used = 1;
@


1.611
log
@gdb/
	No functionality change.
	* breakpoint.c (bpstat_clear_actions): Remove the BS parameter, make
	function comment a reference, new variables tp and bs, move here code
	from throw_exception.
	* breakpoint.h (bpstat_clear_actions): Remove the BS parameter,
	describe it in the comment.
	* exceptions.c (throw_exception): Remove variable tp, move the code for
	bpstat_clear_actions to bpstat_clear_actions.
@
text
@d3355 2
d3368 2
@


1.610
log
@gdb/
	Code cleanup.
	* breakpoint.c (bpstat_clear_actions): Remove clearing of commands_left.
	(command_line_is_silent): New function.
	(bpstat_do_actions_1): No longer use commands_left, use
	command_line_is_silent for commands.
	(bpstat_alloc): Remove clearing of commands_left.
	(bpstat_stop_status): Remove initialization of commands_left, use
	command_line_is_silent.
	* breakpoint.h (struct bpstats): Remove commands_left.
@
text
@d3189 1
a3189 1
/* Modify BS so that the actions will not be performed.  */
d3192 1
a3192 1
bpstat_clear_actions (bpstat bs)
d3194 11
a3204 1
  for (; bs != NULL; bs = bs->next)
@


1.609
log
@	* breakpoint.c (clean_up_filters): Remove.
	(catch_syscall_split_args): Use VEC_cleanup.
@
text
@d3197 1
a3197 1
      bs->commands_left = NULL;
d3234 10
d3292 7
a3298 4
      this_cmd_tree_chain
	= make_cleanup_decref_counted_command_line (&ccmd);
      cmd = bs->commands_left;
      bs->commands_left = NULL;
a3489 1
  bs->commands_left = NULL;
d4166 3
a4168 10
	      bs->commands_left = bs->commands ? bs->commands->commands : NULL;
	      if (bs->commands_left
		  && (strcmp ("silent", bs->commands_left->line) == 0
		      || (xdb_commands
			  && strcmp ("Q",
				     bs->commands_left->line) == 0)))
		{
		  bs->commands_left = bs->commands_left->next;
		  bs->print = 0;
		}
@


1.608
log
@2011-08-04  Pedro Alves  <pedro@@codesourcery.com>

	* ui-out.h (uiout): Rename to ...
	(current_uiout): ... this.
	* ui-out.c (uiout): Rename to ...
	(current_uiout): ... this.
	* ada-lang.c (print_it_exception, print_one_exception)
	(print_mention_exception): Adjust.
	* breakpoint.c (watchpoint_check): Adjust.
	(print_breakpoint_location, print_one_breakpoint, breakpoint_1)
	(default_collect_info, watchpoints_info, print_one_catch_fork)
	(print_one_catch_vfork, print_one_catch_syscall)
	(print_one_catch_exec, mention, print_it_ranged_breakpoint)
	(print_one_ranged_breakpoint, print_mention_ranged_breakpoint)
	(print_it_watchpoint, print_mention_watchpoint)
	(print_it_masked_watchpoint, print_mention_masked_watchpoint)
	(print_it_exception_catchpoint, print_one_exception_catchpoint)
	(print_mention_exception_catchpoint, say_where, bkpt_print_it)
	(bkpt_print_mention, momentary_bkpt_print_it)
	(tracepoint_print_mention, update_static_tracepoint)
	(tracepoints_info, save_breakpoints): Adjust.
	* cli-out.c (field_separator): Adjust.
	* cp-abi.c (list_cp_abis, show_cp_abi_cmd): Adjust.
	* exceptions.c (catch_exceptions_with_msg, catch_errors): Adjust.
	* frame.c (get_current_frame): Adjust.
	* infcmd.c (run_command_1, print_return_value): Adjust.
	* inferior.c (inferior_command, info_inferiors_command): Adjust.
	* infrun.c (print_end_stepping_range_reason): Adjust.
	(print_signal_exited_reason, print_exited_reason): Adjust.
	(print_signal_received_reason, print_no_history_reason): Adjust.
	* interps.c (interp_set): Adjust.
	* osdata.c (info_osdata_command): Adjust.
	* progspace.c (maintenance_info_program_spaces_command): Adjust.
	* remote-fileio.c (remote_fileio_request): Adjust.
	* remote.c (show_remote_cmd): Adjust.
	* solib.c (info_sharedlibrary_command): Adjust.
	* source.c (print_source_lines_base): Adjust.
	* stack.c (print_stack_frame): Adjust.
	(do_gdb_disassembly, print_frame_info, print_frame): Adjust.
	* symfile-mem.c (add_vsyscall_page): Adjust.
	* symfile.c (load_progress, generic_load)
	(print_transfer_performance): Adjust.
	* thread.c (info_threads_command, restore_selected_frame)
	(thread_command): Adjust.
	* top.c (make_cleanup_restore_ui_file): Adjust.
	* tracepoint.c (tvariables_info_1, trace_status_mi, tfind_1)
	(print_one_static_tracepoint_marker): Adjust.
	* cli/cli-cmds.c (print_disassembly): Adjust.
	* cli/cli-decode.c (print_doc_line): Adjust.
	* cli/cli-interp.c (safe_execute_command): Adjust.
	* cli/cli-logging.c (set_logging_redirect, pop_output_files)
	(handle_redirections): Adjust.
	* cli/cli-script.c (show_user_1): Adjust.
	* cli/cli-setshow.c (do_setshow_command, cmd_show_list): Adjust.
	* mi/mi-cmd-break.c (breakpoint_notify): Adjust.
	* mi/mi-cmd-disas.c (mi_cmd_disassemble): Adjust.
	* mi/mi-cmd-env.c (mi_cmd_env_pwd, mi_cmd_env_path)
	(mi_cmd_env_dir): Adjust.
	* mi/mi-cmd-file.c (mi_cmd_file_list_exec_source_file)
	(print_partial_file_name, mi_cmd_file_list_exec_source_files): Adjust.
	* mi/mi-cmd-stack.c (mi_cmd_stack_list_frames)
	(mi_cmd_stack_info_depth, mi_cmd_stack_list_args)
	(list_args_or_locals): Adjust.
	* mi/mi-cmd-var.c (print_varobj, mi_cmd_var_create)
	(mi_cmd_var_delete, mi_cmd_var_set_format, mi_cmd_var_set_frozen)
	(mi_cmd_var_show_format, mi_cmd_var_info_num_children)
	(mi_cmd_var_list_children, mi_cmd_var_info_type)
	(mi_cmd_var_info_path_expression, mi_cmd_var_info_expression)
	(mi_cmd_var_show_attributes, mi_cmd_var_evaluate_expression)
	(mi_cmd_var_assign, mi_cmd_var_update, varobj_update_one): Adjust.
	* mi/mi-interp.c (mi_on_normal_stop): Adjust.
	* mi/mi-main.c (mi_cmd_gdb_exit, mi_cmd_thread_select)
	(mi_cmd_thread_list_ids, mi_cmd_thread_info, print_one_inferior)
	(list_available_thread_groups, mi_cmd_list_thread_groups)
	(mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers)
	(mi_cmd_data_list_register_values, get_register)
	(mi_cmd_data_evaluate_expression, mi_cmd_data_read_memory)
	(mi_cmd_data_read_memory_bytes, mi_cmd_list_features)
	(mi_cmd_list_target_features, mi_cmd_add_inferior)
	(mi_execute_command, mi_load_progress): Adjust.
	* mi/mi-symbol-cmds.c (mi_cmd_symbol_list_lines): Adjust.
	* python/py-auto-load.c (print_script, info_auto_load_scripts):
	Adjust.
	* python/py-breakpoint.c (bppy_get_commands): Adjust.
	* tui/tui-interp.c (tui_command_loop): Adjust.
	* tui/tui-io.c (tui_setup_io, tui_initialize_io): Adjust.
@
text
@a9939 8
/* Cleanup function for a syscall filter list.  */
static void
clean_up_filters (void *arg)
{
  VEC(int) *iter = *(VEC(int) **) arg;
  VEC_free (int, iter);
}

d9946 1
a9946 1
  struct cleanup *cleanup = make_cleanup (clean_up_filters, &result);
@


1.607
log
@2011-08-03  Philippe Waroquiers  <philippe.waroquiers@@skynet.be>

	* breakpoint.c (update_global_location_list): Ensure
	invariant 'first loc marked not duplicated and inserted,
	following locs marked duplicated/not inserted' is respected
	for multiple locations at the same address.
	(unduplicated_should_be_inserted) New function.
	(swap_insertion) New function.

2011-08-03  Philippe Waroquiers  <philippe.waroquiers@@skynet.be>

	* gdb.base/break-always.exp: Complete the test
	with duplicated breakpoints and enabling/disabling them.
@
text
@d3688 2
d4503 1
d4622 1
d4913 1
d5039 1
d5186 2
d5213 1
d6177 1
d6273 1
d6515 1
d6758 1
d7043 1
a7043 1
  if (ui_out_is_mi_like_p (uiout))
d8176 1
d8209 1
d8259 1
d8687 1
d8780 1
d8895 1
d8962 1
d9743 1
d9778 1
d9802 1
d10676 1
d10915 1
d10947 1
a10947 1
  if (ui_out_is_mi_like_p (uiout))
d11097 2
d11164 1
a11164 1
  if (ui_out_is_mi_like_p (uiout))
d11530 1
d12796 1
d13111 1
a13111 1
	ui_out_redirect (uiout, fp);
d13114 1
a13114 1
	    print_command_lines (uiout, tp->commands->commands, 2);
d13116 1
a13116 1
	ui_out_redirect (uiout, NULL);
@


1.606
log
@	Revert:
	2011-07-31  Thiago Jung Bauermann  <bauerman@@br.ibm.com>
	* breakpoint.c (insert_bp_location): Remove disabled_breaks
	argument.  Update callers.
@
text
@d1574 15
d10259 17
a10411 5
			  /* For the sake of should_be_inserted.
			     Duplicates check below will fix up this
			     later.  */
			  loc2->duplicate = 0;

d10421 5
a10425 1
			  if (loc2 != old_loc && should_be_inserted (loc2))
d10427 1
a10427 2
			      loc2->inserted = 1;
			      loc2->target_info = old_loc->target_info;
d10574 6
@


1.605
log
@	* breakpoint.c (insert_bp_location): Document return value.
	(insert_breakpoint_locations): Fix documentation.
	(remove_breakpoints): Add documentation.
@
text
@d1576 1
a1576 1
   HW_BREAKPOINT_ERROR is used to report problems.
d1585 1
d1719 10
a1728 6
	      fprintf_unfiltered (tmp_error_stream, 
			          "Cannot insert breakpoint %d.\n", 
				  bl->owner->number);
	      fprintf_unfiltered (tmp_error_stream, 
				  "Temporarily disabling shared "
				  "library breakpoints:\n");
d1916 1
d1950 2
a1951 2
      val = insert_bp_location (bl, tmp_error_stream,
				&hw_breakpoint_error);
d2058 1
a2058 1
  int dummy = 0;
d2082 1
a2082 1
	val = insert_bp_location (bl, tmp_error_stream, &dummy);
@


1.604
log
@	* breakpoint.c (insert_bp_location): Remove disabled_breaks
	argument.  Update callers.
@
text
@d1577 2
d1902 1
a1902 4
/* insert_breakpoints is used when starting or continuing the program.
   remove_breakpoints is used when the program stops.
   Both return zero if successful,
   or an `errno' value if could not write the inferior.  */
d2003 4
@


1.603
log
@2011-07-26  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* breakpoint.c (works_in_software_mode_watchpoint): Also return
	true for software watchpoints.

	gdb/testsuite/
	* gdb.base/watchpoint.exp
	(test_disable_enable_software_watchpoint): New procedure.
	(top level): Run it.
@
text
@d1576 1
a1576 1
   DISABLED_BREAKS, and HW_BREAKPOINT_ERROR are used to report problems.
a1582 1
		    int *disabled_breaks,
d1716 6
a1721 10
	      if (!*disabled_breaks)
		{
		  fprintf_unfiltered (tmp_error_stream, 
				      "Cannot insert breakpoint %d.\n", 
				      bl->owner->number);
		  fprintf_unfiltered (tmp_error_stream, 
				      "Temporarily disabling shared "
				      "library breakpoints:\n");
		}
	      *disabled_breaks = 1;
a1911 1
  int disabled_breaks = 0;
d1945 2
a1946 2
      val = insert_bp_location (bl, tmp_error_stream, &disabled_breaks,
				    &hw_breakpoint_error);
d2049 1
a2049 1
  int dummy1 = 0, dummy2 = 0;
d2073 1
a2073 1
	val = insert_bp_location (bl, tmp_error_stream, &dummy1, &dummy2);
@


1.602
log
@	* ada-lang.c (ada_exception_breakpoint_ops): Make return type
	const.
	(ada_exception_sal): Make 'ops' const.
	(ada_decode_exception_location): Likewise.
	(ada_decode_assert_location): Likewise.
	(catch_assert_command): Update.
	(catch_ada_exception_command): Update.
	(create_ada_exception_catchpoint): Make 'ops' const.
	* breakpoint.c (set_raw_breakpoint_without_location)
	(set_raw_breakpoint, momentary_breakpoint_from_master): Make 'ops'
	const.
	(create_internal_breakpoint): Update.
	(init_raw_breakpoint_without_location): Make 'ops' const.
	(init_raw_breakpoint, init_catchpoint)
	(create_fork_vfork_event_catchpoint)
	(create_syscall_event_catchpoint, init_breakpoint_sal)
	(create_breakpoint_sal, create_breakpoints_sal)
	(create_breakpoint, init_ada_exception_breakpoint): Likewise.
	* breakpoint.h (struct breakpoint) <ops>: Now const.
	(init_ada_exception_breakpoint, create_breakpoint): Make 'ops'
	const.
@
text
@d8640 2
a8641 1
  return b->type == bp_hardware_watchpoint;
@


1.601
log
@2011-07-25  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* breakpoint.h (print_recreate_thread): Declare.
	(struct breakpoint): Move step_count, pass_count,
	number_on_target, static_trace_marker_id,
	static_trace_marker_id_idx ...
	(struct tracepoint): ... to this new struct.
	(get_tracepoint, get_tracepoint_by_number_on_target)
	(get_tracepoint_by_number): Change return type to struct
	tracepoint pointer.
	* breakpoint.c (is_tracepoint_type): New, factored out from
	is_tracepoint.
	(is_tracepoint): Adjust.
	(print_one_breakpoint_location): Cast to struct tracepoint as
	necessary, and adjust.
	(print_recreate_catch_fork, print_recreate_catch_vfork)
	(print_recreate_catch_syscall, print_recreate_catch_exec): Call
	print_recreate_thread.
	(init_breakpoint_sal): New, factored out from
	create_breakpoint_sal.
	(create_breakpoint_sal): Reimplement.
	(create_breakpoint): Allocate a struct tracecepoint if the caller
	wanted a tracepoint.  Use init_breakpoint_sal and
	install_breakpoint.
	(print_recreate_ranged_breakpoint, print_recreate_watchpoint)
	(print_recreate_masked_watchpoint)
	(print_recreate_exception_catchpoint): Call print_recreate_thread.
	(tracepoint_print_one_detail): Adjust.
	(tracepoint_print_recreate): Adjust.  Call print_recreate_thread.
	Dump the pass count here.
	(update_static_tracepoint): Adjust.
	(addr_string_to_sals): Adjust.
	(create_tracepoint_from_upload): Adjust.  Change return type to
	struct tracepoint pointer.
	(trace_pass_set_count): Change parameter type to struct tracepoint
	pointer, and adjust.
	(trace_pass_command): Adjust.
	(get_tracepoint, get_tracepoint_by_number_on_target)
	(get_tracepoint_by_number): Change return type to struct
	tracepoint pointer, and adjust.
	(print_recreate_thread): New, factored out from save_breakpoints.
	(save_breakpoints): Don't print thread and task and passcount
	recreation here.
	* remote.c (remote_download_tracepoint): Adjust.
	* tracepoint.c (trace_actions_command, validate_actionline)
	(start_tracing, tfind_1, trace_find_tracepoint_command)
	(trace_dump_command): Adjust.
	(find_matching_tracepoint): Change return type to struct
	tracepoint pointer, and adjust.
	(merge_uploaded_tracepoints, tfile_get_traceframe_address)
	(tfile_trace_find, tfile_fetch_registers): Adjust.
	* tracepoint.h (create_tracepoint_from_upload): Change return type
	to struct tracepoint pointer.
	* ada-lang.c (print_recreate_exception): Call
	print_recreate_thread.
	* mi/mi-cmd-break.c (mi_cmd_break_passcount): Adjust.
@
text
@d111 1
a111 1
							       struct breakpoint_ops *);
d116 2
a117 1
				       enum bptype, struct breakpoint_ops *);
d122 1
a122 1
				    struct breakpoint_ops *ops);
d2114 1
a2114 1
			    struct breakpoint_ops *ops)
d5609 1
a5609 1
				      struct breakpoint_ops *ops)
d5638 1
a5638 1
				     struct breakpoint_ops *ops)
d5715 1
a5715 1
		     struct breakpoint_ops *ops)
d5779 1
a5779 1
		    struct breakpoint_ops *ops)
d6620 1
a6620 1
		 struct breakpoint_ops *ops)
d6647 1
a6647 1
                                    struct breakpoint_ops *ops)
d6766 1
a6766 1
                                 struct breakpoint_ops *ops)
d6946 1
a6946 1
				  struct breakpoint_ops *ops)
d7097 1
a7097 1
		     struct breakpoint_ops *ops, int from_tty,
d7222 1
a7222 1
		       struct breakpoint_ops *ops, int from_tty,
d7406 1
a7406 1
			struct breakpoint_ops *ops, int from_tty,
d7686 1
a7686 1
		   struct breakpoint_ops *ops,
d9868 1
a9868 1
			       struct breakpoint_ops *ops,
@


1.600
log
@2011-07-25  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* breakpoint.h (struct breakpoint): Move ops as first field.  Move
	exp_string, exp_string_reparse, exp, exp_valid_block, cond_exp,
	cond_exp_valid_block, val, val_valid, watchpoint_frame,
	watchpoint_thread, watchpoint_triggered ...
	(struct watchpoint): ... to this new struct.
	(is_watchpoint): Declare.
	(install_breakpoint): Add new `internal' parameter.
	* breakpoint.c (is_watchpoint): Delete declaration.
	(set_breakpoint_condition): Handle watchpoints.
	(is_watchpoint): Make public.
	(watchpoint_in_thread_scope): Change parameter type to struct
	watchpoint.
	(watchpoint_del_at_next_stop): Change parameter type to struct
	watchpoint.  Remove assertion.  Adjust.
	(update_watchpoint): Ditto.
	(insert_breakpoints, breakpoint_init_inferior)
	(watchpoints_triggered, watchpoint_check)
	(bpstat_check_watchpoint, bpstat_check_breakpoint_conditions)
	(bpstat_stop_status, print_one_breakpoint_location)
	(print_one_breakpoint_location, watchpoint_locations_match): Cast
	to struct watchpoint as necessary, and adjust.
	(install_breakpoint): Add `internal' argument.  If true, don't
	mention the new breakpoint.  Use set_breakpoint_number.
	(create_fork_vfork_event_catchpoint)
	(create_syscall_event_catchpoint): Adjust.
	(dtor_watchpoint): New.
	(re_set_watchpoint, insert_watchpoint, remove_watchpoint)
	(breakpoint_hit_watchpoint, resources_needed_watchpoint)
	(print_it_watchpoint, print_mention_watchpoint)
	(print_recreate_watchpoint, insert_masked_watchpoint)
	(remove_masked_watchpoint, resources_needed_masked_watchpoint)
	(print_one_detail_masked_watchpoint)
	(print_mention_masked_watchpoint)
	(print_recreate_masked_watchpoint): Cast to struct watchpoint as
	necessary, and adjust.
	(watch_command_1): Allocate and initialize a struct watchpoint
	instead of a struct breakpoint.  Use install_breakpoint.
	(catch_exec_command_1): Adjust.
	(base_breakpoint_dtor): Delete accesses to watchpoint specific
	fields.
	(delete_breakpoint, enable_breakpoint_disp)
	(invalidate_bp_value_on_memory_change): Cast to struct watchpoint
	as necessary, and adjust.
	(initialize_breakpoint_ops): Install dtor_watchpoint as
	watchpoints' dtor method.
	* ada-lang.c (create_ada_exception_catchpoint): Adjust.
	* python/py-breakpoint.c (bppy_get_expression): Use is_watchpoint.
	to struct watchpoint as necessary, and adjust.
@
text
@d737 8
d748 1
a748 3
  return (b->type == bp_tracepoint
	  || b->type == bp_fast_tracepoint
	  || b->type == bp_static_tracepoint);
d750 1
a750 1
  
d4858 1
a4858 1
  if (!part_of_multiple && b->pass_count)
d4860 9
a4868 4
      annotate_field (10);
      ui_out_text (uiout, "\tpass count ");
      ui_out_field_int (uiout, "pass", b->pass_count);
      ui_out_text (uiout, " \n");
d6184 1
d6278 1
d6595 1
d6758 1
d7091 7
a7097 7
create_breakpoint_sal (struct gdbarch *gdbarch,
		       struct symtabs_and_lines sals, char *addr_string,
		       char *cond_string,
		       enum bptype type, enum bpdisp disposition,
		       int thread, int task, int ignore_count,
		       struct breakpoint_ops *ops, int from_tty,
		       int enabled, int internal, int display_canonical)
a7098 1
  struct breakpoint *b = NULL;
d7132 1
a7132 2
	  b = set_raw_breakpoint (gdbarch, sal, type, ops);
	  set_breakpoint_number (internal, b);
d7144 1
d7161 1
a7161 1
		  b->static_trace_marker_id = marker_str;
d7165 1
a7165 1
				   b->static_trace_marker_id);
d7169 1
a7169 1
		  b->static_trace_marker_id = xstrdup (marker.str_id);
d7174 1
a7174 1
				   b->static_trace_marker_id);
d7213 1
d7215 34
a7248 5
  /* Do not mention breakpoints with a negative number, but do
     notify observers.  */
  if (!internal)
    mention (b);
  observer_notify_breakpoint_created (b);
d7849 1
a7849 1
	      struct breakpoint *tp;
d7857 8
a7864 16
	      create_breakpoint_sal (gdbarch, expanded, canonical.canonical[i],
				     cond_string, type_wanted,
				     tempflag ? disp_del : disp_donttouch,
				     thread, task, ignore_count, ops,
				     from_tty, enabled, internal,
				     canonical.special_display);

	      do_cleanups (old_chain);

	      /* Get the tracepoint we just created.  */
	      if (internal)
		tp = get_breakpoint (internal_breakpoint_number);
	      else
		tp = get_breakpoint (breakpoint_count);
	      gdb_assert (tp != NULL);

d7872 4
d8245 1
d8799 1
d8977 1
d9786 1
d11081 2
a11082 1
  if (self->static_trace_marker_id)
d11088 1
a11088 1
			   self->static_trace_marker_id);
d11122 1
a11122 1
tracepoint_print_recreate (struct breakpoint *tp, struct ui_file *fp)
d11124 3
a11126 1
  if (tp->type == bp_fast_tracepoint)
d11128 1
a11128 1
  if (tp->type == bp_static_tracepoint)
d11130 1
a11130 1
  else if (tp->type == bp_tracepoint)
d11134 1
a11134 1
		    _("unhandled tracepoint type %d"), (int) tp->type);
d11136 5
a11140 1
  fprintf_unfiltered (fp, " %s", tp->addr_string);
d11422 1
d11433 1
a11433 1
      if (strcmp (b->static_trace_marker_id, marker.str_id) != 0)
d11436 1
a11436 1
		 b->static_trace_marker_id, marker.str_id);
d11438 2
a11439 2
      xfree (b->static_trace_marker_id);
      b->static_trace_marker_id = xstrdup (marker.str_id);
d11450 1
a11450 1
      && b->static_trace_marker_id != NULL)
d11455 1
a11455 1
	= target_static_tracepoint_markers_by_strid (b->static_trace_marker_id);
d11465 2
a11466 2
	  xfree (b->static_trace_marker_id);
	  b->static_trace_marker_id = xstrdup (marker->str_id);
d11470 1
a11470 1
		   b->number, b->static_trace_marker_id);
d11685 2
d11688 1
a11688 1
	  if (sals.nelts > b->static_trace_marker_id_idx)
d11690 1
a11690 1
	      sals.sals[0] = sals.sals[b->static_trace_marker_id_idx];
d11694 1
a11694 1
	    error (_("marker %s not found"), b->static_trace_marker_id);
d12644 1
a12644 1
struct breakpoint *
d12648 1
a12648 1
  struct breakpoint *tp;
d12692 1
a12692 1
      sprintf (small_buf, "%d %d", utp->pass, tp->number);
d12710 1
a12710 1
      breakpoint_set_commands (tp, cmd_list);
d12719 1
a12719 1
  }
d12797 1
a12797 1
trace_pass_set_count (struct breakpoint *bp, int count, int from_tty)
d12799 2
a12800 2
  bp->pass_count = count;
  observer_notify_tracepoint_modified (bp->number);
d12803 1
a12803 1
		     bp->number, count);
d12815 1
a12815 1
  struct breakpoint *t1;
d12829 2
d12835 1
a12835 1
      ALL_TRACEPOINTS (t1)
d12837 1
d12861 1
a12861 1
struct breakpoint *
d12868 1
a12868 1
      return t;
d12877 1
a12877 1
struct breakpoint *
d12880 5
a12884 1
  struct breakpoint *t;
d12886 3
a12888 3
  ALL_TRACEPOINTS (t)
    if (t->number_on_target == num)
      return t;
d12897 1
a12897 1
struct breakpoint *
d12936 1
a12936 1
      return t;
d12943 12
a13024 8
    if (tp->thread != -1)
      fprintf_unfiltered (fp, " thread %d", tp->thread);

    if (tp->task != 0)
      fprintf_unfiltered (fp, " task %d", tp->task);

    fprintf_unfiltered (fp, "\n");

a13034 3
    if (tp->pass_count)
      fprintf_unfiltered (fp, "  passcount %d\n", tp->pass_count);

@


1.599
log
@2011-07-25  Pedro Alves  <pedro@@codesourcery.com>

	* ada-lang.c (dtor_exception, re_set_exception): Indirect through
	the the base class ops table.
	(catch_exception_breakpoint_ops)
	(catch_exception_unhandled_breakpoint_ops)
	(catch_assert_breakpoint_ops): Don't statically initialize.
	(initialize_ada_catchpoint_ops): New.
	(_initialize_ada_language): Call it.
	* breakpoint.c (base_breakpoint_ops, bkpt_base_breakpoint_ops)
	(bkpt_breakpoint_ops): Forward declare.
	(catch_fork_breakpoint_ops, catch_vfork_breakpoint_ops)
	(catch_syscall_breakpoint_ops, catch_exec_breakpoint_ops)
	(ranged_breakpoint_ops, watchpoint_breakpoint_ops)
	(masked_watchpoint_breakpoint_ops)
	(gnu_v3_exception_catchpoint_ops): Don't statically initialize.
	(dtor_catch_syscall, dtor_catch_exec): Indirect through the the
	base class ops table.
	(null_re_set, null_check_status, null_works_in_software_mode)
	(null_resources_needed, null_print_one_detail): Delete.
	(bkpt_dtor): Rename to ...
	(base_breakpoint_dtor): ... this.  Make static.
	(bkpt_allocate_location): Rename to ...
	(base_breakpoint_allocate_location): ... this.  Make static.
	(base_breakpoint_re_set): New.
	(internal_error_pure_virtual_called): New.
	(base_breakpoint_insert_location, base_breakpoint_remove_location)
	(base_breakpoint_breakpoint_hit, base_breakpoint_check_status)
	(base_breakpoint_works_in_software_mode)
	(base_breakpoint_resources_needed, base_breakpoint_print_it)
	(base_breakpoint_print_one_detail, base_breakpoint_print_mention)
	(base_breakpoint_print_recreate): New functions.
	(base_breakpoint_ops): New global.
	(bkpt_re_set, bkpt_insert_location, bkpt_remove_location)
	(bkpt_breakpoint_hit): Make static.
	(bkpt_check_status): Delete.
	(bkpt_resources_needed): Make static.
	(bkpt_works_in_software_mode): Delete.
	(bkpt_print_it, bkpt_print_mention, bkpt_print_recreate): Make
	static.
	(bkpt_breakpoint_ops, internal_breakpoint_ops)
	(momentary_breakpoint_ops): Don't statically initialize.
	(internal_bkpt_print_recreate, momentary_bkpt_print_recreate):
	Delete.
	(tracepoint_insert_location, tracepoint_remove_location)
	(tracepoint_check_status, tracepoint_works_in_software_mode)
	(tracepoint_print_it): Delete.
	(tracepoint_breakpoint_ops): Don't statically initialize.
	(initialize_breakpoint_ops): New.
	(_initialize_breakpoint): Call it.
	* breakpoint.h (null_re_set, null_works_in_software_mode)
	(null_resources_needed, null_check_status, null_print_one_detail):
	(bkpt_dtor, bkpt_allocate_location, bkpt_re_set)
	(bkpt_insert_location, bkpt_remove_location, bkpt_breakpoint_hit)
	(bkpt_check_status, bkpt_resources_needed)
	(bkpt_works_in_software_mode, bkpt_print_it)
	(null_print_one_detail, bkpt_print_mention, bkpt_print_recreate):
	Delete declarations.
	(initialize_breakpoint_ops): Declare.
@
text
@a215 2
static int is_watchpoint (const struct breakpoint *bpt);

d605 2
a606 1
  struct bp_location *loc = b->loc;
d608 8
a615 1
  for (; loc; loc = loc->next)
d617 7
a623 2
      xfree (loc->cond);
      loc->cond = NULL;
a624 4
  xfree (b->cond_string);
  b->cond_string = NULL;
  xfree (b->cond_exp);
  b->cond_exp = NULL;
d642 2
d646 1
a646 1
	  b->cond_exp = parse_exp_1 (&arg, 0, 0);
d649 1
a649 1
	  b->cond_exp_valid_block = innermost_block;
d653 2
d1178 1
a1178 1
static int
d1185 8
a1192 9
/* Assuming that B is a watchpoint: returns true if the current thread
   and its running state are safe to evaluate or update watchpoint B.
   Watchpoints on local expressions need to be evaluated in the
   context of the thread that was current when the watchpoint was
   created, and, that thread needs to be stopped to be able to select
   the correct frame context.  Watchpoints on global expressions can
   be evaluated on any thread, and in any state.  It is presently left
   to the target allowing memory accesses when threads are
   running.  */
d1195 1
a1195 1
watchpoint_in_thread_scope (struct breakpoint *b)
d1206 1
a1206 1
watchpoint_del_at_next_stop (struct breakpoint *b)
d1208 1
a1208 1
  gdb_assert (is_watchpoint (b));
d1274 1
a1274 1
update_watchpoint (struct breakpoint *b, int reparse)
a1279 2
  gdb_assert (is_watchpoint (b));

d1286 1
a1286 1
  if (b->disposition == disp_del_at_next_stop)
d1323 1
a1323 1
  b->loc = NULL;
d1347 1
a1347 1
      if (b->cond_string != NULL)
d1355 1
a1355 1
	  s = b->cond_string;
d1385 1
a1385 1
      if (!b->val_valid && !is_masked_watchpoint (b))
d1420 1
a1420 1
		  if (b->type == bp_read_watchpoint)
d1422 1
a1422 1
		  else if (b->type == bp_access_watchpoint)
d1424 3
a1426 3
		  
		  loc = allocate_bp_location (b);
		  for (tmp = &(b->loc); *tmp != NULL; tmp = &((*tmp)->next))
d1466 2
a1467 2
	      if (b->type == bp_watchpoint)
		b->type = bp_hardware_watchpoint;
d1469 1
a1469 1
	      i = hw_watchpoint_used_count (b->type, &other_type_used);
d1471 1
a1471 1
		    (b->type, i, other_type_used);
d1474 1
a1474 1
		  int sw_mode = b->ops->works_in_software_mode (b);
d1483 1
a1483 1
		    b->type = bp_watchpoint;
d1486 1
a1486 1
	  else if (!b->ops->works_in_software_mode (b))
d1490 1
a1490 1
	    b->type = bp_watchpoint;
d1492 1
a1492 1
	  loc_type = (b->type == bp_watchpoint? bp_loc_other
d1494 1
a1494 1
	  for (bl = b->loc; bl; bl = bl->next)
d1509 1
a1509 1
      if (b->type == bp_watchpoint && b->loc == NULL)
d1511 6
a1516 5
	  b->loc = allocate_bp_location (b);
	  b->loc->pspace = frame_pspace;
	  b->loc->address = -1;
	  b->loc->length = -1;
	  b->loc->watchpoint_type = -1;
d1524 1
a1524 1
		       b->number);
d1883 5
a1887 1
      update_watchpoint (bpt, 0 /* don't reparse.  */);
d2778 2
d2781 11
a2791 11
	/* Likewise for watchpoints on local expressions.  */
	if (b->exp_valid_block != NULL)
	  delete_breakpoint (b);
	else if (context == inf_starting) 
	  {
	    /* Reset val field to force reread of starting value in
	       insert_breakpoints.  */
	    if (b->val)
	      value_free (b->val);
	    b->val = NULL;
	    b->val_valid = 0;
d2793 1
d3474 5
a3478 1
	  b->watchpoint_triggered = watch_triggered_no;
d3489 5
a3493 1
	  b->watchpoint_triggered = watch_triggered_unknown;
d3505 1
d3508 1
a3508 1
	b->watchpoint_triggered = watch_triggered_no;
d3511 1
a3511 1
	    if (is_masked_watchpoint (loc->owner))
d3513 2
a3514 2
		CORE_ADDR newaddr = addr & loc->owner->hw_wp_mask;
		CORE_ADDR start = loc->address & loc->owner->hw_wp_mask;
d3518 1
a3518 1
		    b->watchpoint_triggered = watch_triggered_yes;
d3527 1
a3527 1
		b->watchpoint_triggered = watch_triggered_yes;
d3560 1
a3560 1
  struct breakpoint *b;
d3566 1
a3566 3
  b = bs->breakpoint_at;

  gdb_assert (is_watchpoint (b));
d3628 1
a3628 1
      if (is_masked_watchpoint (b))
d3680 1
a3680 1
      ui_out_field_int (uiout, "wpnum", b->number);
d3686 1
a3686 1
      decref_counted_command_line (&b->commands);
d3709 3
a3711 3
/* If BS refers to a watchpoint, determine if the watched values
   has actually changed, and we should stop.  If not, set BS->stop
   to 0.  */
d3716 1
a3716 1
  struct breakpoint *b;
d3721 1
a3721 1
  b = bs->breakpoint_at;
a3723 1
  if (is_watchpoint (b))
d3727 1
a3727 1
      if (b->type == bp_watchpoint)
d3737 1
a3737 1
	       && b->type == bp_hardware_watchpoint)
d3743 1
a3743 1
      
d3748 1
a3748 1
			  b->number);
d3765 1
a3765 1
	      if (b->type == bp_read_watchpoint)
d3808 2
a3809 4
			if ((other_b->type == bp_hardware_watchpoint
			     || other_b->type == bp_access_watchpoint)
			    && (other_b->watchpoint_triggered
				== watch_triggered_yes))
d3811 9
a3819 2
			    other_write_watchpoint = 1;
			    break;
d3836 2
a3837 2
	      if (b->type == bp_hardware_watchpoint
		  || b->type == bp_watchpoint)
d3850 1
a3850 1
	      printf_filtered (_("Watchpoint %d deleted.\n"), b->number);
d3901 5
a3905 1
	cond = b->cond_exp;
d3912 1
d3921 5
d3932 1
a3932 1
	  if (!is_watchpoint (b) || b->cond_exp_valid_block == NULL)
d3952 1
a3952 1
	      frame = block_innermost_frame (b->cond_exp_valid_block);
d4074 5
a4078 1
	    b->related_breakpoint->watchpoint_triggered = watch_triggered_yes;
d4156 3
a4158 1
	  update_watchpoint (bs->breakpoint_at, 0 /* don't reparse.  */);
d4672 11
a4682 7
	/* Field 4, the address, is omitted (which makes the columns
	   not line up too nicely with the headers, but the effect
	   is relatively readable).  */
	if (opts.addressprint)
	  ui_out_field_skip (uiout, "addr");
	annotate_field (5);
	ui_out_field_string (uiout, "what", b->exp_string);
d4862 7
a4868 1
      if (b->addr_string)
a4869 2
      else if (b->exp_string)
	ui_out_field_string (uiout, "original-location", b->exp_string);
d5301 6
a5306 3
  /* Both of them must not be in moribund_locations.  */
  gdb_assert (loc1->owner != NULL);
  gdb_assert (loc2->owner != NULL);
d5314 1
a5314 1
  if ((loc1->owner->cond_exp
d5318 2
a5319 2
						 loc1->owner->cond_exp))
      || (loc2->owner->cond_exp
d5323 1
a5323 1
						    loc2->owner->cond_exp)))
d6619 1
a6619 1
install_breakpoint (struct breakpoint *b)
d6622 3
a6624 3
  set_breakpoint_count (breakpoint_count + 1);
  b->number = breakpoint_count;
  mention (b);
d6640 1
a6640 1
  install_breakpoint (&c->base);
d6759 1
a6759 1
  install_breakpoint (&c->base);
d8477 16
d8498 2
d8521 1
a8521 1
     b->exp_valid_block is likewise valid, and we can safely use it.
d8523 3
a8525 3
     Don't do anything about disabled watchpoints, since they will
     be reevaluated again when enabled.  */
  update_watchpoint (b, 1 /* reparse */);
d8533 2
a8534 1
  int length = bl->owner->exact? 1 : bl->length;
d8537 1
a8537 1
				   bl->owner->cond_exp);
d8545 2
a8546 1
  int length = bl->owner->exact? 1 : bl->length;
d8549 1
a8549 1
				   bl->owner->cond_exp);
d8557 1
d8566 1
a8566 1
      && b->watchpoint_triggered == watch_triggered_no)
d8586 2
a8587 1
  int length = bl->owner->exact? 1 : bl->length;
d8609 1
d8615 1
d8635 1
a8635 1
      watchpoint_value_print (b->val, stb->stream);
d8650 1
a8650 1
      watchpoint_value_print (b->val, stb->stream);
d8681 1
a8681 1
      watchpoint_value_print (b->val, stb->stream);
d8701 1
d8728 1
a8728 1
  ui_out_field_string (uiout, "exp", b->exp_string);
d8738 2
d8757 1
a8757 1
  fprintf_unfiltered (fp, " %s", b->exp_string);
d8770 3
a8772 1
  return target_insert_mask_watchpoint (bl->address, bl->owner->hw_wp_mask,
d8782 3
a8784 1
  return target_remove_mask_watchpoint (bl->address, bl->owner->hw_wp_mask,
d8794 3
a8796 2
  return target_masked_watch_num_registers (bl->address,
					    bl->owner->hw_wp_mask);
d8864 2
d8870 1
a8870 1
  ui_out_field_core_addr (uiout, "mask", b->loc->gdbarch, b->hw_wp_mask);
d8880 1
d8904 1
a8904 1
  ui_out_field_string (uiout, "exp", b->exp_string);
d8914 1
d8933 2
a8934 2
  sprintf_vma (tmp, b->hw_wp_mask);
  fprintf_unfiltered (fp, " %s mask 0x%s", b->exp_string, tmp);
d8975 1
d9172 3
d9176 2
a9177 2
    b = set_raw_breakpoint_without_location (NULL, bp_type,
					     &masked_watchpoint_breakpoint_ops);
d9179 2
a9180 2
    b = set_raw_breakpoint_without_location (NULL, bp_type,
					     &watchpoint_breakpoint_ops);
a9182 3
  b->exp = exp;
  b->exp_valid_block = exp_valid_block;
  b->cond_exp_valid_block = cond_exp_valid_block;
d9184 3
d9196 1
a9196 1
      b->exp_string_reparse = xstrprintf ("* (%s *) %s", name,
d9200 1
a9200 1
      b->exp_string = xstrprintf ("-location %.*s",
d9207 1
a9207 1
    b->exp_string = savestring (exp_start, exp_end - exp_start);
d9211 1
a9211 1
      b->hw_wp_mask = mask;
d9215 2
a9216 2
      b->val = val;
      b->val_valid = 1;
d9226 2
a9227 2
      b->watchpoint_frame = get_frame_id (frame);
      b->watchpoint_thread = inferior_ptid;
d9231 2
a9232 2
      b->watchpoint_frame = null_frame_id;
      b->watchpoint_thread = null_ptid;
d9250 1
a9250 1
      update_watchpoint (b, 1);
d9258 1
a9258 9
  set_breakpoint_number (internal, b);

  /* Do not mention breakpoints with a negative number, but do
     notify observers.  */
  if (!internal)
    mention (b);
  observer_notify_breakpoint_created (b);

  update_global_location_list (1);
d9654 1
a9654 1
  install_breakpoint (&c->base);
a10622 1
  xfree (self->cond_exp);
a10624 4
  xfree (self->exp);
  xfree (self->exp_string);
  xfree (self->exp_string_reparse);
  value_free (self->val);
d11128 1
d11131 1
a11131 1
	watchpoint_del_at_next_stop (bpt->related_breakpoint);
d11133 5
a11137 1
	watchpoint_del_at_next_stop (bpt);
d12084 2
d12088 1
a12088 1
	  update_watchpoint (bpt, 1 /* reparse */);
d12230 1
a12230 2
	&& bp->type == bp_hardware_watchpoint
	&& bp->val_valid && bp->val)
d12232 5
a12236 1
	struct bp_location *loc;
d12238 10
a12247 9
	for (loc = bp->loc; loc != NULL; loc = loc->next)
	  if (loc->loc_type == bp_loc_hardware_watchpoint
	      && loc->address + loc->length > addr
	      && addr + len > loc->address)
	    {
	      value_free (bp->val);
	      bp->val = NULL;
	      bp->val_valid = 0;
	    }
d13200 1
@


1.598
log
@2011-07-25  Pedro Alves  <pedro@@codesourcery.com>

	* breakpoint.c (bkpt_print_it, internal_bkpt_print_it)
	(momentary_bkpt_print_it): Simplify.
@
text
@d239 10
a248 1
/* Forward declarations.  */
d250 2
d254 4
d6123 1
a6123 17
static struct breakpoint_ops catch_fork_breakpoint_ops =
{
  bkpt_dtor,
  bkpt_allocate_location,
  null_re_set,
  insert_catch_fork,
  remove_catch_fork,
  breakpoint_hit_catch_fork,
  null_check_status,
  null_resources_needed,
  null_works_in_software_mode,
  print_it_catch_fork,
  print_one_catch_fork,
  null_print_one_detail,
  print_mention_catch_fork,
  print_recreate_catch_fork
};
d6216 1
a6216 17
static struct breakpoint_ops catch_vfork_breakpoint_ops =
{
  bkpt_dtor,
  bkpt_allocate_location,
  null_re_set,
  insert_catch_vfork,
  remove_catch_vfork,
  breakpoint_hit_catch_vfork,
  null_check_status,
  null_resources_needed,
  null_works_in_software_mode,
  print_it_catch_vfork,
  print_one_catch_vfork,
  null_print_one_detail,
  print_mention_catch_vfork,
  print_recreate_catch_vfork
};
d6246 1
a6246 1
  bkpt_dtor (b);
d6532 1
a6532 17
static struct breakpoint_ops catch_syscall_breakpoint_ops =
{
  dtor_catch_syscall,
  bkpt_allocate_location,
  null_re_set,
  insert_catch_syscall,
  remove_catch_syscall,
  breakpoint_hit_catch_syscall,
  null_check_status,
  null_resources_needed,
  null_works_in_software_mode,
  print_it_catch_syscall,
  print_one_catch_syscall,
  null_print_one_detail,
  print_mention_catch_syscall,
  print_recreate_catch_syscall
};
d6618 1
a6618 1
  bkpt_dtor (b);
d6692 1
a6692 17
static struct breakpoint_ops catch_exec_breakpoint_ops =
{
  dtor_catch_exec,
  bkpt_allocate_location,
  null_re_set,
  insert_catch_exec,
  remove_catch_exec,
  breakpoint_hit_catch_exec,
  null_check_status,
  null_resources_needed,
  null_works_in_software_mode,
  print_it_catch_exec,
  print_one_catch_exec,
  null_print_one_detail,
  print_mention_catch_exec,
  print_recreate_catch_exec
};
d8155 1
a8155 17
static struct breakpoint_ops ranged_breakpoint_ops =
{
  bkpt_dtor,
  bkpt_allocate_location,
  bkpt_re_set,
  bkpt_insert_location,
  bkpt_remove_location,
  breakpoint_hit_ranged_breakpoint,
  null_check_status,
  resources_needed_ranged_breakpoint,
  null_works_in_software_mode,
  print_it_ranged_breakpoint,
  print_one_ranged_breakpoint,
  print_one_detail_ranged_breakpoint,
  print_mention_ranged_breakpoint,
  print_recreate_ranged_breakpoint
};
d8681 1
a8681 17
static struct breakpoint_ops watchpoint_breakpoint_ops =
{
  bkpt_dtor,
  bkpt_allocate_location,
  re_set_watchpoint,
  insert_watchpoint,
  remove_watchpoint,
  breakpoint_hit_watchpoint,
  check_status_watchpoint,
  resources_needed_watchpoint,
  works_in_software_mode_watchpoint,
  print_it_watchpoint,
  NULL, /* print_one */
  null_print_one_detail,
  print_mention_watchpoint,
  print_recreate_watchpoint
};
d8849 1
a8849 17
static struct breakpoint_ops masked_watchpoint_breakpoint_ops =
{
  bkpt_dtor,
  bkpt_allocate_location,
  re_set_watchpoint,
  insert_masked_watchpoint,
  remove_masked_watchpoint,
  breakpoint_hit_watchpoint,
  check_status_watchpoint,
  resources_needed_masked_watchpoint,
  works_in_software_mode_masked_watchpoint,
  print_it_masked_watchpoint,
  NULL, /* print_one */
  print_one_detail_masked_watchpoint,
  print_mention_masked_watchpoint,
  print_recreate_masked_watchpoint
};
d9659 1
a9659 16
static struct breakpoint_ops gnu_v3_exception_catchpoint_ops = {
  bkpt_dtor,
  bkpt_allocate_location,
  bkpt_re_set,
  bkpt_insert_location,
  bkpt_remove_location,
  bkpt_breakpoint_hit,
  bkpt_check_status,
  bkpt_resources_needed,
  null_works_in_software_mode,
  print_it_exception_catchpoint,
  print_one_exception_catchpoint,
  null_print_one_detail,
  print_mention_exception_catchpoint,
  print_recreate_exception_catchpoint
};
a10514 39
/* Default breakpoint_ops methods that do nothing.  */

void
null_re_set (struct breakpoint *b)
{
  /* Nothing to re-set. */
}

void
null_check_status (bpstat bs)
{
  /* nothing */
}

/* A "works_in_software_mode" breakpoint_ops method that just internal
   errors.  */

int
null_works_in_software_mode (const struct breakpoint *b)
{
  gdb_assert_not_reached ("null_works_in_software_mode called");
}

/* A "resources_needed" breakpoint_ops method that just internal
   errors.  */

int
null_resources_needed (const struct bp_location *bl)
{
  gdb_assert_not_reached ("null_resources_needed");
}

void
null_print_one_detail (const struct breakpoint *self,
		       struct ui_out *uiout)
{
  /* nothing */
}

d10529 2
a10530 1
/* Default breakpoint_ops methods.  */
d10532 2
a10533 2
void
bkpt_dtor (struct breakpoint *self)
d10547 2
a10548 2
struct bp_location *
bkpt_allocate_location (struct breakpoint *self)
d10557 99
a10655 1
void
d10673 1
a10673 1
int
d10684 1
a10684 1
int
d10693 1
a10693 1
int
d10711 1
a10711 7
void
bkpt_check_status (bpstat bs)
{
  /* nothing, always stop */
}

int
d10719 1
a10719 7
int
bkpt_works_in_software_mode (const struct breakpoint *b)
{
  gdb_assert_not_reached ("bkpt_works_in_software_mode called");
}

enum print_stop_action
d10753 1
a10753 1
void
d10779 1
a10779 1
void
d10795 1
a10795 11
  if (tp->exp_string)
    fprintf_unfiltered (fp, " %s", tp->exp_string);
  else if (tp->addr_string)
    fprintf_unfiltered (fp, " %s", tp->addr_string);
  else
    {
      char tmp[40];

      sprintf_vma (tmp, tp->loc->address);
      fprintf_unfiltered (fp, " *0x%s", tmp);
    }
a10797 20
/* The breakpoint_ops structure to be used in regular breakpoints.  */

struct breakpoint_ops bkpt_breakpoint_ops =
{
  bkpt_dtor,
  bkpt_allocate_location,
  bkpt_re_set,
  bkpt_insert_location,
  bkpt_remove_location,
  bkpt_breakpoint_hit,
  bkpt_check_status,
  bkpt_resources_needed,
  null_works_in_software_mode,
  bkpt_print_it,
  NULL, /* print_one */
  null_print_one_detail,
  bkpt_print_mention,
  bkpt_print_recreate
};

a10885 27
static void
internal_bkpt_print_recreate (struct breakpoint *tp, struct ui_file *fp)
{
  gdb_assert_not_reached ("internal_bkpt_print_recreate called");
}

/* The breakpoint_ops structure to be used with internal
   breakpoints.  */

static struct breakpoint_ops internal_breakpoint_ops =
{
  bkpt_dtor,
  bkpt_allocate_location,
  internal_bkpt_re_set,
  bkpt_insert_location,
  bkpt_remove_location,
  bkpt_breakpoint_hit,
  internal_bkpt_check_status,
  bkpt_resources_needed,
  null_works_in_software_mode,
  internal_bkpt_print_it,
  NULL, /* print_one */
  null_print_one_detail,
  internal_bkpt_print_mention,
  internal_bkpt_print_recreate
};

a10934 27
static void
momentary_bkpt_print_recreate (struct breakpoint *tp, struct ui_file *fp)
{
  gdb_assert_not_reached ("momentary_bkpt_print_recreate called");
}

/* The breakpoint_ops structure to be used with momentary
   breakpoints.  */

static struct breakpoint_ops momentary_breakpoint_ops =
{
  bkpt_dtor,
  bkpt_allocate_location,
  momentary_bkpt_re_set,
  bkpt_insert_location,
  bkpt_remove_location,
  bkpt_breakpoint_hit,
  momentary_bkpt_check_status,
  bkpt_resources_needed,
  null_works_in_software_mode,
  momentary_bkpt_print_it,
  NULL, /* print_one */
  null_print_one_detail,
  momentary_bkpt_print_mention,
  momentary_bkpt_print_recreate
};

a10943 12
tracepoint_insert_location (struct bp_location *bl)
{
  gdb_assert_not_reached ("tracepoint_insert_location called");
}

static int
tracepoint_remove_location (struct bp_location *bl)
{
  gdb_assert_not_reached ("tracepoint_remove_location called");
}

static int
a10952 18
tracepoint_check_status (bpstat bs)
{
  gdb_assert_not_reached ("tracepoint_check_status called");
}

static int
tracepoint_works_in_software_mode (const struct breakpoint *b)
{
  gdb_assert_not_reached ("tracepoint_works_in_software_mode called");
}

static enum print_stop_action
tracepoint_print_it (bpstat bs)
{
  gdb_assert_not_reached ("tracepoint_print_it called");
}

static void
d11011 1
a11011 17
struct breakpoint_ops tracepoint_breakpoint_ops =
{
  bkpt_dtor,
  bkpt_allocate_location,
  tracepoint_re_set,
  tracepoint_insert_location,
  tracepoint_remove_location,
  tracepoint_breakpoint_hit,
  tracepoint_check_status,
  null_resources_needed,
  tracepoint_works_in_software_mode,
  tracepoint_print_it,
  NULL, /* print_one */
  tracepoint_print_one_detail,
  tracepoint_print_mention,
  tracepoint_print_recreate
};
d13041 147
d13192 2
@


1.597
log
@2011-07-25  Pedro Alves  <pedro@@codesourcery.com>

	Split internal, momentary and user breakpoints breakpoint_ops
	tables.

	gdb/
	* breakpoint.c (internal_breakpoint_ops)
	(momentary_breakpoint_ops): Forward declare.
	(create_internal_breakpoint): Add new breakpoint_ops parameter.
	Pass it down, rather than hardcoding bkpt_breakpoint_ops.
	(create_overlay_event_breakpoint)
	(create_std_terminate_master_breakpoint)
	(create_exception_master_breakpoint): Create breakpoints with
	internal_breakpoint_ops vtable.
	(set_longjmp_breakpoint): Create momentary breakpoints with
	momentary_breakpoint_ops vtable, using
	momentary_breakpoint_from_master.
	(create_thread_event_breakpoint, create_jit_event_breakpoint)
	(create_solib_event_breakpoint): Create breakpoints with
	internal_breakpoint_ops vtable.
	(set_momentary_breakpoint): Create breakpoints with
	momentary_breakpoint_ops vtable.
	(momentary_breakpoint_from_master): New, factored out from
	clone_momentary_breakpoint.
	(clone_momentary_breakpoint): Adjust.
	(watch_command_1): Create scope breakpoints with
	momentary_breakpoint_ops vtable.
	(bkpt_re_set): Remove handling of internal and momentary
	breakpoints.
	(bkpt_print_mention, bkpt_print_recreate): New.
	(bkpt_breakpoint_ops): Adjust.
	(internal_bkpt_re_set, internal_bkpt_check_status)
	(internal_bkpt_print_it, internal_bkpt_print_mention)
	(internal_bkpt_print_recreate, internal_breakpoint_ops): New.
	(momentary_bkpt_re_set, momentary_bkpt_check_status)
	(momentary_bkpt_print_it, momentary_bkpt_print_mention)
	(momentary_bkpt_print_recreate): New.
	(momentary_breakpoint_ops): New.
@
text
@a10785 1
  struct cleanup *old_chain;
d10788 1
a10788 3
  struct ui_stream *stb;
  int bp_temp = 0;
  enum print_stop_action result;
d10795 11
a10805 4
  stb = ui_out_stream_new (uiout);
  old_chain = make_cleanup_ui_out_stream_delete (stb);

  switch (b->type)
d10807 3
a10809 26
    case bp_breakpoint:
    case bp_hardware_breakpoint:
      bp_temp = b->disposition == disp_del;
      if (bl->address != bl->requested_address)
	breakpoint_adjustment_warning (bl->requested_address,
	                               bl->address,
				       b->number, 1);
      annotate_breakpoint (b->number);
      if (bp_temp)
	ui_out_text (uiout, "\nTemporary breakpoint ");
      else
	ui_out_text (uiout, "\nBreakpoint ");
      if (ui_out_is_mi_like_p (uiout))
	{
	  ui_out_field_string (uiout, "reason",
			  async_reason_lookup (EXEC_ASYNC_BREAKPOINT_HIT));
	  ui_out_field_string (uiout, "disp", bpdisp_text (b->disposition));
	}
      ui_out_field_int (uiout, "bkptno", b->number);
      ui_out_text (uiout, ", ");
      result = PRINT_SRC_AND_LOC;
      break;

    default:
      result = PRINT_UNKNOWN;
      break;
d10811 2
d10814 1
a10814 2
  do_cleanups (old_chain);
  return result;
a10928 1
  struct cleanup *old_chain;
a10929 6
  const struct bp_location *bl;
  struct ui_stream *stb;
  int bp_temp = 0;
  enum print_stop_action result;

  gdb_assert (bs->bp_location_at != NULL);
a10930 1
  bl = bs->bp_location_at;
a10932 3
  stb = ui_out_stream_new (uiout);
  old_chain = make_cleanup_ui_out_stream_delete (stb);

a10939 1
      result = PRINT_NOTHING;
a10945 1
      result = PRINT_NOTHING;
a10950 1
      result = PRINT_NOTHING;
a10955 1
      result = PRINT_NOTHING;
a10961 1
      result = PRINT_NOTHING;
a10967 5
      result = PRINT_NOTHING;
      break;

    default:
      result = PRINT_UNKNOWN;
d10971 1
a10971 2
  do_cleanups (old_chain);
  return result;
d11027 1
a11027 16
  struct cleanup *old_chain;
  struct breakpoint *b;
  const struct bp_location *bl;
  struct ui_stream *stb;
  int bp_temp = 0;
  enum print_stop_action result;

  gdb_assert (bs->bp_location_at != NULL);

  bl = bs->bp_location_at;
  b = bs->breakpoint_at;

  stb = ui_out_stream_new (uiout);
  old_chain = make_cleanup_ui_out_stream_delete (stb);

  switch (b->type)
d11029 1
a11029 7
    case bp_finish:
      if (ui_out_is_mi_like_p (uiout))
	ui_out_field_string
	  (uiout, "reason",
	   async_reason_lookup (EXEC_ASYNC_FUNCTION_FINISHED));
      result = PRINT_UNKNOWN;
      break;
d11031 7
a11037 7
    case bp_until:
      if (ui_out_is_mi_like_p (uiout))
	ui_out_field_string
	  (uiout, "reason",
	   async_reason_lookup (EXEC_ASYNC_LOCATION_REACHED));
      result = PRINT_UNKNOWN;
      break;
d11039 6
a11044 3
    default:
      result = PRINT_UNKNOWN;
      break;
d11047 1
a11047 2
  do_cleanups (old_chain);
  return result;
@


1.596
log
@2011-07-25  Pedro Alves  <pedro@@codesourcery.com>

	Implement most breakpoint_ops methods for all breakpoint types,
	and move the default handlings to the proper callbacks.

	gdb/
	* breakpoint.c (update_watchpoint): Always call the breakpoint's
	works_in_software_mode method.
	(insert_bp_location): Go through breakpoint_ops->insert_location
	for software and hardware watchpoints.
	(create_internal_breakpoint): Pass bkpt_breakpoint_ops as
	breakpoint_ops.
	(remove_breakpoint_1): Go through breakpoint_ops->remove_location
	for software and hardware watchpoints.
	(print_it_typical): Delete.
	(print_bp_stop_message): Always call the breakpoint_ops->print_it
	method.
	(watchpoint_check): Adjust comment.
	(bpstat_check_location): Simply always call the breakpoint's
	breakpoint_hit method.
	(bpstat_stop_status): Always call the breakpoint's check_status
	method.  Remove special cases for watchpoints and internal event
	breakpoints from here (moved to the check_status implementations).
	(print_one_breakpoint_location): Assume b->ops is never NULL.
	Remove static tracepoint marker id printing from here (moved to
	the print_one_detail callback implementation of tracepoints).
	(init_bp_location): Assert OPS is never NULL.
	(allocate_bp_location): Always call the breakpoint's
	allocate_location method, and remove the default code from here.
	(free_bp_location): Always call the location's dtor method, and
	remove the default code from here.
	(init_raw_breakpoint_without_location): Assert OPS is never NULL.
	(set_raw_breakpoint_without_location): Add new breakpoint_ops
	parameter.  Pass it down.
	(set_raw_breakpoint): Ditto.
	(print_it_catch_fork): Adjust to take a bpstat as argument.
	(catch_fork_breakpoint_ops): Install methods.
	(print_it_catch_vfork): Adjust to take a bpstat as argument.
	(catch_vfork_breakpoint_ops): Install methods.
	(dtor_catch_syscall): Call the base dtor.
	(print_it_catch_syscall): Adjust to take a bpstat as argument.
	(catch_syscall_breakpoint_ops): Install methods.
	(dtor_catch_exec): Call the base dtor.
	(print_it_catch_exec): Adjust to take a bpstat as argument.
	(catch_exec_breakpoint_ops): Install methods.
	(hw_breakpoint_used_count, hw_watchpoint_used_count): Always call
	the breakpoint's resources_needed method, and remove the default
	code from here.
	(set_momentary_breakpoint): Pass bkpt_breakpoint_ops as
	breakpoint_ops.
	(clone_momentary_breakpoint): Clone the original's ops.
	(mention): Always call the breakpoint's print_mention method, and
	remove the default code from here.
	(create_breakpoint_sal): Adjust to pass the ops to
	set_raw_breakpoint rather than setting it manually.
	(create_breakpoint): Assert ops is never NULL.  Adjust to pass the
	ops to set_raw_breakpoint_without_location rather than setting it
	manually.
	(break_command_1): Pass bkpt_breakpoint_ops as breakpoint_ops.
	(print_it_ranged_breakpoint): Adjust to take a bpstat as argument.
	(ranged_breakpoint_ops): Install methods.
	(break_range_command): Adjust to pass the ops to
	set_raw_breakpoint rather than setting it manually.
	(re_set_watchpoint, breakpoint_hit_watchpoint)
	(check_status_watchpoint, resources_needed_watchpoint)
	(works_in_software_mode_watchpoint, print_it_watchpoint)
	(print_mention_watchpoint, print_recreate_watchpoint): New
	functions.
	(watchpoint_breakpoint_ops): Install new methods.
	(print_it_masked_watchpoint): New function.
	(masked_watchpoint_breakpoint_ops): Install new methods.
	(watch_command_1): Adjust to pass the right breakpoint_ops to
	set_raw_breakpoint_without_location rather than setting it
	manually later.  Record the current pspace.
	(print_it_exception_catchpoint): Adjust to take a bpstat as
	argument.
	(gnu_v3_exception_catchpoint_ops): Install new methods.
	(say_where): New function.
	(null_re_set, null_check_status, null_works_in_software_mode)
	(null_resources_needed, null_print_one_detail, bp_location_dtor):
	New functions.
	(bp_location_ops): New global.
	(bkpt_dtor, bkpt_allocate_location, bkpt_re_set)
	(bkpt_insert_location, bkpt_remove_location, bkpt_breakpoint_hit)
	(bkpt_check_status, bkpt_resources_needed)
	(bkpt_works_in_software_mode, bkpt_print_it, bkpt_print_mention)
	(bkpt_print_recreate): New functions.
	(bkpt_breakpoint_ops): New global.
	(tracepoint_re_set, tracepoint_insert_location)
	(tracepoint_remove_location, tracepoint_breakpoint_hit)
	(tracepoint_check_status, tracepoint_works_in_software_mode)
	(tracepoint_print_it, tracepoint_print_one_detail)
	(tracepoint_print_mention, tracepoint_print_recreate): New
	functions.
	(tracepoint_breakpoint_ops): New global.
	(delete_breakpoint): Always call the breakpoint's dtor method, and
	remove the default handling from here.
	(breakpoint_re_set_default): Make static.
	(breakpoint_re_set_one): Always call the breakpoints re_set
	method, and remove the default handling from here.
	(trace_command, ftrace_command, strace_command)
	(create_tracepoint_from_upload): Pass appropriate breakpoints_ops
	to create_breakpoint.
	(save_breakpoints): Always call the breakpoint's print_recreate
	method, and remove the default handling from here.

	* ada-lang.c (dtor_exception): Call the base dtor.
	(re_set_exception): Call the base method.
	(print_it_exception, print_it_catch_exception): Adjust to take a
	bpstat as argument.
	(catch_exception_breakpoint_ops): Install methods.
	(print_it_catch_exception_unhandled): Adjust to take a bpstat as
	argument.
	(catch_exception_unhandled_breakpoint_ops): Install methods.
	(print_it_catch_assert): Adjust to take a bpstat as argument.
	(catch_assert_breakpoint_ops): Install methods.

	* breakpoint.h (struct breakpoint_ops): Adjust the print_it method
	to take a bpstat as argument.
	(enum print_stop_action): Add describing comments to each enum
	value.
	(breakpoint_re_set_default): Delete declaration.
	(null_re_set, null_works_in_software_mode, null_resources_needed)
	(null_check_status, null_print_one_detail): Declare.
	(bkpt_breakpoint_ops): Declare.
	(bkpt_dtor, bkpt_allocate_location, bkpt_re_set)
	(bkpt_insert_location, bkpt_remove_location, bkpt_breakpoint_hit)
	(bkpt_check_status, bkpt_resources_needed)
	(bkpt_works_in_software_mode, bkpt_print_it)
	(null_print_one_detail, bkpt_print_mention, bkpt_print_recreate):
	Declare.

	* mi/mi-cmd-break.c (mi_cmd_break_insert): Adjust to pass
	bkpt_breakpoint_ops.
	* python/py-breakpoint.c (bppy_init): Ditto.
@
text
@d118 5
d239 4
d2078 2
a2079 1
			    CORE_ADDR address, enum bptype type)
d2090 1
a2090 1
  b = set_raw_breakpoint (gdbarch, sal, type, &bkpt_breakpoint_ops);
d2185 2
a2186 1
                                      bp_overlay_event);
d2254 2
a2255 1
	  b = create_internal_breakpoint (gdbarch, addr, bp_longjmp_master);
d2310 2
a2311 1
                                      bp_std_terminate_master);
d2361 2
a2362 1
      b = create_internal_breakpoint (gdbarch, addr, bp_exception_master);
d5745 2
a5746 1
	struct breakpoint *clone = clone_momentary_breakpoint (b);
d5748 2
a5749 1
	clone->type = b->type == bp_longjmp_master ? bp_longjmp : bp_exception;
d5809 2
a5810 2
	struct breakpoint *clone = clone_momentary_breakpoint (b);
	clone->type = bp_std_terminate;
d5830 3
a5832 2
  b = create_internal_breakpoint (gdbarch, address, bp_thread_event);
  
d5867 2
a5868 1
  b = create_internal_breakpoint (gdbarch, address, bp_jit_event);
d5902 2
a5903 1
  b = create_internal_breakpoint (gdbarch, address, bp_shlib_event);
d6902 1
a6902 1
  b = set_raw_breakpoint (gdbarch, sal, type, &bkpt_breakpoint_ops);
d6918 3
a6920 2
/* Make a deep copy of momentary breakpoint ORIG.  Returns NULL if
   ORIG is NULL.  */
d6922 4
a6925 2
struct breakpoint *
clone_momentary_breakpoint (struct breakpoint *orig)
d6929 1
a6929 6
  /* If there's nothing to clone, then return nothing.  */
  if (orig == NULL)
    return NULL;

  copy = set_raw_breakpoint_without_location (orig->gdbarch,
					      orig->type, orig->ops);
d6957 13
d9154 2
a9155 1
					  bp_watchpoint_scope);
d10710 6
a10715 1
  switch (b->type)
d10717 1
a10717 27
    case bp_breakpoint:
    case bp_hardware_breakpoint:
    case bp_gnu_ifunc_resolver:
      /* Do not attempt to re-set breakpoints disabled during
	 startup.  */
      if (b->enable_state == bp_startup_disabled)
	return;

      if (b->addr_string == NULL)
	{
	  /* Anything without a string can't be re-set.  */
	  delete_breakpoint (b);
	  return;
	}

      breakpoint_re_set_default (b);
      break;

    default:
      printf_filtered (_("Deleting unknown breakpoint type %d\n"), b->type);
      /* fall through */
      /* Delete overlay event and longjmp master breakpoints; they
	 will be reset later by breakpoint_re_set.  */
    case bp_overlay_event:
    case bp_longjmp_master:
    case bp_std_terminate_master:
    case bp_exception_master:
d10719 2
a10720 1
      break;
d10722 1
a10722 28
      /* This breakpoint is special, it's set up when the inferior
         starts and we really don't want to touch it.  */
    case bp_shlib_event:

      /* Like bp_shlib_event, this breakpoint type is special.  Once
	 it is set up, we do not want to touch it.  */
    case bp_thread_event:

      /* Keep temporary breakpoints, which can be encountered when we
         step over a dlopen call and SOLIB_ADD is resetting the
         breakpoints.  Otherwise these should have been blown away via
         the cleanup chain or by breakpoint_init_inferior when we
         rerun the executable.  */
    case bp_until:
    case bp_finish:
    case bp_watchpoint_scope:
    case bp_call_dummy:
    case bp_std_terminate:
    case bp_step_resume:
    case bp_hp_step_resume:
    case bp_longjmp:
    case bp_longjmp_resume:
    case bp_exception:
    case bp_exception_resume:
    case bp_jit_event:
    case bp_gnu_ifunc_resolver_return:
      break;
    }
d10766 1
a10766 9
  struct breakpoint *b = bs->breakpoint_at;

  if (b->type == bp_thread_event
      || b->type == bp_overlay_event
      || b->type == bp_longjmp_master
      || b->type == bp_std_terminate_master
      || b->type == bp_exception_master)
    /* We do not stop for these.  */
    bs->stop = 0;
d10826 138
d11005 8
a11012 2
    /* Fall through, we don't deal with these types of breakpoints
       here.  */
d11014 70
a11099 13
    case bp_none:
    case bp_longjmp:
    case bp_longjmp_resume:
    case bp_exception:
    case bp_exception_resume:
    case bp_step_resume:
    case bp_hp_step_resume:
    case bp_watchpoint_scope:
    case bp_call_dummy:
    case bp_std_terminate:
    case bp_jit_event:
    case bp_gnu_ifunc_resolver:
    case bp_gnu_ifunc_resolver_return:
d11109 2
a11110 2
void
bkpt_print_mention (struct breakpoint *b)
d11112 1
a11112 41
  if (ui_out_is_mi_like_p (uiout))
    return;

  switch (b->type)
    {
    case bp_breakpoint:
    case bp_gnu_ifunc_resolver:
      if (b->disposition == disp_del)
	printf_filtered (_("Temporary breakpoint"));
      else
	printf_filtered (_("Breakpoint"));
      printf_filtered (_(" %d"), b->number);
      if (b->type == bp_gnu_ifunc_resolver)
	printf_filtered (_(" at gnu-indirect-function resolver"));
      say_where (b);
      break;
    case bp_hardware_breakpoint:
      printf_filtered (_("Hardware assisted breakpoint %d"), b->number);
      say_where (b);
      break;
    case bp_until:
    case bp_finish:
    case bp_longjmp:
    case bp_longjmp_resume:
    case bp_exception:
    case bp_exception_resume:
    case bp_step_resume:
    case bp_hp_step_resume:
    case bp_call_dummy:
    case bp_std_terminate:
    case bp_watchpoint_scope:
    case bp_shlib_event:
    case bp_thread_event:
    case bp_overlay_event:
    case bp_jit_event:
    case bp_longjmp_master:
    case bp_std_terminate_master:
    case bp_exception_master:
    case bp_gnu_ifunc_resolver_return:
      break;
    }
d11115 2
a11116 2
void
bkpt_print_recreate (struct breakpoint *tp, struct ui_file *fp)
d11118 1
a11118 24
  if (tp->type == bp_breakpoint && tp->disposition == disp_del)
    fprintf_unfiltered (fp, "tbreak");
  else if (tp->type == bp_breakpoint)
    fprintf_unfiltered (fp, "break");
  else if (tp->type == bp_hardware_breakpoint
	   && tp->disposition == disp_del)
    fprintf_unfiltered (fp, "thbreak");
  else if (tp->type == bp_hardware_breakpoint)
    fprintf_unfiltered (fp, "hbreak");
  else
    internal_error (__FILE__, __LINE__,
		    _("unhandled breakpoint type %d"), (int) tp->type);

  if (tp->exp_string)
    fprintf_unfiltered (fp, " %s", tp->exp_string);
  else if (tp->addr_string)
    fprintf_unfiltered (fp, " %s", tp->addr_string);
  else
    {
      char tmp[40];

      sprintf_vma (tmp, tp->loc->address);
      fprintf_unfiltered (fp, " *0x%s", tmp);
    }
d11121 2
a11122 1
/* The breakpoint_ops structure to be used in regular breakpoints.  */
d11124 1
a11124 1
struct breakpoint_ops bkpt_breakpoint_ops =
d11128 1
a11128 1
  bkpt_re_set,
d11132 1
a11132 1
  bkpt_check_status,
d11135 1
a11135 1
  bkpt_print_it,
d11138 2
a11139 2
  bkpt_print_mention,
  bkpt_print_recreate
@


1.595
log
@gdb/
	* ada-lang.c: Fix typos.
	* amd64-tdep.c: Likewise.
	* breakpoint.c: Likewise.
	* cli/cli-decode.c: Likewise.
	* findcmd.c: Likewise.
	* inline-frame.c: Likewise.
	* mi/mi-main.c: Likewise.
	* minsyms.c: Likewise.
	* monitor.c: Likewise.
	* monitor.h: Likewise.
	* prologue-value.c: Likewise.
	* reverse.c: Likewise.
	* s390-tdep.c: Likewise.

gdb/testsuite/
	* gdb.base/call-sc.c: Likewise.
	* gdb.base/ifelse.exp: Likewise.
	* gdb.base/structs.c: Likewise.

gdb/doc/
	* gdb.texinfo: Likewise.
@
text
@d97 2
d109 3
d115 2
a116 2
					      struct symtab_and_line,
					      enum bptype);
a164 2
static enum print_stop_action print_it_typical (bpstat);

d1442 1
a1442 4
		  /* If there's no works_in_software_mode method, we
		     assume that the watchpoint works in software mode.  */
		  int sw_mode = (!b->ops || !b->ops->works_in_software_mode
				 || b->ops->works_in_software_mode (b));
d1454 1
a1454 2
	  else if (b->ops && b->ops->works_in_software_mode
		   && !b->ops->works_in_software_mode (b))
d1624 1
a1624 6
	  if (bl->loc_type == bp_loc_hardware_breakpoint)
	    val = target_insert_hw_breakpoint (bl->gdbarch,
					       &bl->target_info);
	  else
	    val = target_insert_breakpoint (bl->gdbarch,
					    &bl->target_info);
d1658 1
a1658 6
	      if (bl->loc_type == bp_loc_hardware_breakpoint)
		val = target_insert_hw_breakpoint (bl->gdbarch,
						   &bl->target_info);
	      else
		val = target_insert_breakpoint (bl->gdbarch,
						&bl->target_info);
d2080 1
a2080 1
  b = set_raw_breakpoint (gdbarch, sal, type);
d2539 1
a2539 5

	  if (bl->loc_type == bp_loc_hardware_breakpoint)
	    val = target_remove_hw_breakpoint (bl->gdbarch, &bl->target_info);
	  else
	    val = target_remove_breakpoint (bl->gdbarch, &bl->target_info);
a2566 3
	      if (bl->loc_type == bp_loc_hardware_breakpoint)
		val = target_remove_hw_breakpoint (bl->gdbarch,
						   &bl->target_info);
d2571 3
a2573 3
	      else if (section_is_mapped (bl->section))
		val = target_remove_breakpoint (bl->gdbarch,
						&bl->target_info);
a3289 213
/* This is the normal print function for a bpstat.  In the future,
   much of this logic could (should?) be moved to bpstat_stop_status,
   by having it set different print_it values.

   Current scheme: When we stop, bpstat_print() is called.  It loops
   through the bpstat list of things causing this stop, calling the
   print_bp_stop_message function on each one.  The behavior of the
   print_bp_stop_message function depends on the print_it field of
   bpstat.  If such field so indicates, call this function here.

   Return values from this routine (ultimately used by bpstat_print()
   and normal_stop() to decide what to do): 
   PRINT_NOTHING: Means we already printed all we needed to print,
   don't print anything else.
   PRINT_SRC_ONLY: Means we printed something, and we do *not* desire
   that something to be followed by a location.
   PRINT_SCR_AND_LOC: Means we printed something, and we *do* desire
   that something to be followed by a location.
   PRINT_UNKNOWN: Means we printed nothing or we need to do some more
   analysis.  */

static enum print_stop_action
print_it_typical (bpstat bs)
{
  struct cleanup *old_chain;
  struct breakpoint *b;
  const struct bp_location *bl;
  struct ui_stream *stb;
  int bp_temp = 0;
  enum print_stop_action result;

  gdb_assert (bs->bp_location_at != NULL);

  bl = bs->bp_location_at;
  b = bs->breakpoint_at;

  stb = ui_out_stream_new (uiout);
  old_chain = make_cleanup_ui_out_stream_delete (stb);

  switch (b->type)
    {
    case bp_breakpoint:
    case bp_hardware_breakpoint:
      bp_temp = b->disposition == disp_del;
      if (bl->address != bl->requested_address)
	breakpoint_adjustment_warning (bl->requested_address,
	                               bl->address,
				       b->number, 1);
      annotate_breakpoint (b->number);
      if (bp_temp) 
	ui_out_text (uiout, "\nTemporary breakpoint ");
      else
	ui_out_text (uiout, "\nBreakpoint ");
      if (ui_out_is_mi_like_p (uiout))
	{
	  ui_out_field_string (uiout, "reason", 
			  async_reason_lookup (EXEC_ASYNC_BREAKPOINT_HIT));
	  ui_out_field_string (uiout, "disp", bpdisp_text (b->disposition));
	}
      ui_out_field_int (uiout, "bkptno", b->number);
      ui_out_text (uiout, ", ");
      result = PRINT_SRC_AND_LOC;
      break;

    case bp_shlib_event:
      /* Did we stop because the user set the stop_on_solib_events
	 variable?  (If so, we report this as a generic, "Stopped due
	 to shlib event" message.) */
      printf_filtered (_("Stopped due to shared library event\n"));
      result = PRINT_NOTHING;
      break;

    case bp_thread_event:
      /* Not sure how we will get here.
	 GDB should not stop for these breakpoints.  */
      printf_filtered (_("Thread Event Breakpoint: gdb should not stop!\n"));
      result = PRINT_NOTHING;
      break;

    case bp_overlay_event:
      /* By analogy with the thread event, GDB should not stop for these.  */
      printf_filtered (_("Overlay Event Breakpoint: gdb should not stop!\n"));
      result = PRINT_NOTHING;
      break;

    case bp_longjmp_master:
      /* These should never be enabled.  */
      printf_filtered (_("Longjmp Master Breakpoint: gdb should not stop!\n"));
      result = PRINT_NOTHING;
      break;

    case bp_std_terminate_master:
      /* These should never be enabled.  */
      printf_filtered (_("std::terminate Master Breakpoint: "
			 "gdb should not stop!\n"));
      result = PRINT_NOTHING;
      break;

    case bp_exception_master:
      /* These should never be enabled.  */
      printf_filtered (_("Exception Master Breakpoint: "
			 "gdb should not stop!\n"));
      result = PRINT_NOTHING;
      break;

    case bp_watchpoint:
    case bp_hardware_watchpoint:
      annotate_watchpoint (b->number);
      if (ui_out_is_mi_like_p (uiout))
	ui_out_field_string
	  (uiout, "reason",
	   async_reason_lookup (EXEC_ASYNC_WATCHPOINT_TRIGGER));
      mention (b);
      make_cleanup_ui_out_tuple_begin_end (uiout, "value");
      ui_out_text (uiout, "\nOld value = ");
      watchpoint_value_print (bs->old_val, stb->stream);
      ui_out_field_stream (uiout, "old", stb);
      ui_out_text (uiout, "\nNew value = ");
      watchpoint_value_print (b->val, stb->stream);
      ui_out_field_stream (uiout, "new", stb);
      ui_out_text (uiout, "\n");
      /* More than one watchpoint may have been triggered.  */
      result = PRINT_UNKNOWN;
      break;

    case bp_read_watchpoint:
      if (ui_out_is_mi_like_p (uiout))
	ui_out_field_string
	  (uiout, "reason",
	   async_reason_lookup (EXEC_ASYNC_READ_WATCHPOINT_TRIGGER));
      mention (b);
      make_cleanup_ui_out_tuple_begin_end (uiout, "value");
      ui_out_text (uiout, "\nValue = ");
      watchpoint_value_print (b->val, stb->stream);
      ui_out_field_stream (uiout, "value", stb);
      ui_out_text (uiout, "\n");
      result = PRINT_UNKNOWN;
      break;

    case bp_access_watchpoint:
      if (bs->old_val != NULL)
	{
	  annotate_watchpoint (b->number);
	  if (ui_out_is_mi_like_p (uiout))
	    ui_out_field_string
	      (uiout, "reason",
	       async_reason_lookup (EXEC_ASYNC_ACCESS_WATCHPOINT_TRIGGER));
	  mention (b);
	  make_cleanup_ui_out_tuple_begin_end (uiout, "value");
	  ui_out_text (uiout, "\nOld value = ");
	  watchpoint_value_print (bs->old_val, stb->stream);
	  ui_out_field_stream (uiout, "old", stb);
	  ui_out_text (uiout, "\nNew value = ");
	}
      else 
	{
	  mention (b);
	  if (ui_out_is_mi_like_p (uiout))
	    ui_out_field_string
	      (uiout, "reason",
	       async_reason_lookup (EXEC_ASYNC_ACCESS_WATCHPOINT_TRIGGER));
	  make_cleanup_ui_out_tuple_begin_end (uiout, "value");
	  ui_out_text (uiout, "\nValue = ");
	}
      watchpoint_value_print (b->val, stb->stream);
      ui_out_field_stream (uiout, "new", stb);
      ui_out_text (uiout, "\n");
      result = PRINT_UNKNOWN;
      break;

    /* Fall through, we don't deal with these types of breakpoints
       here.  */

    case bp_finish:
      if (ui_out_is_mi_like_p (uiout))
	ui_out_field_string
	  (uiout, "reason",
	   async_reason_lookup (EXEC_ASYNC_FUNCTION_FINISHED));
      result = PRINT_UNKNOWN;
      break;

    case bp_until:
      if (ui_out_is_mi_like_p (uiout))
	ui_out_field_string
	  (uiout, "reason",
	   async_reason_lookup (EXEC_ASYNC_LOCATION_REACHED));
      result = PRINT_UNKNOWN;
      break;

    case bp_none:
    case bp_longjmp:
    case bp_longjmp_resume:
    case bp_exception:
    case bp_exception_resume:
    case bp_step_resume:
    case bp_hp_step_resume:
    case bp_watchpoint_scope:
    case bp_call_dummy:
    case bp_std_terminate:
    case bp_tracepoint:
    case bp_fast_tracepoint:
    case bp_jit_event:
    case bp_gnu_ifunc_resolver:
    case bp_gnu_ifunc_resolver_return:
    default:
      result = PRINT_UNKNOWN;
      break;
    }

  do_cleanups (old_chain);
  return result;
}

d3321 2
a3322 6
	/* Normal case.  Call the breakpoint's print_it method, or
	   print_it_typical.  */
	if (b->ops != NULL && b->ops->print_it != NULL)
	  return b->ops->print_it (b);
	else
	  return print_it_typical (bs);
d3324 1
a3324 1
	break;
d3619 5
a3623 4
      /* We print all the stop information in print_it_typical(), but
	 in this case, by the time we call print_it_typical() this bp
	 will be deleted already.  So we have no choice but print the
	 information here.  */
d3642 3
a3644 2
   breakpoint location BL.  This function does not check if we
   should stop, only if BL explains the stop.   */
d3651 1
a3651 1
  /* BL is from existing struct breakpoint.  */
d3654 1
a3654 43
  if (b->ops && b->ops->breakpoint_hit)
    return b->ops->breakpoint_hit (bl, aspace, bp_addr);

  /* By definition, the inferior does not report stops at
     tracepoints.  */
  if (is_tracepoint (b))
    return 0;

  if (!is_watchpoint (b)
      && b->type != bp_hardware_breakpoint
      && b->type != bp_catchpoint)	/* a non-watchpoint bp */
    {
      if (!breakpoint_address_match (bl->pspace->aspace, bl->address,
				     aspace, bp_addr))
	return 0;
      if (overlay_debugging		/* unmapped overlay section */
	  && section_is_overlay (bl->section)
	  && !section_is_mapped (bl->section))
	return 0;
    }

  /* Continuable hardware watchpoints are treated as non-existent if the
     reason we stopped wasn't a hardware watchpoint (we didn't stop on
     some data address).  Otherwise gdb won't stop on a break instruction
     in the code (not from a breakpoint) when a hardware watchpoint has
     been defined.  Also skip watchpoints which we know did not trigger
     (did not match the data address).  */

  if (is_hardware_watchpoint (b)
      && b->watchpoint_triggered == watch_triggered_no)
    return 0;

  if (b->type == bp_hardware_breakpoint)
    {
      if (bl->address != bp_addr)
	return 0;
      if (overlay_debugging		/* unmapped overlay section */
	  && section_is_overlay (bl->section)
	  && !section_is_mapped (bl->section))
	return 0;
    }

  return 1;
a4034 4
      bpstat_check_watchpoint (bs);
      if (!bs->stop)
	continue;

d4036 2
a4037 2

      if (b->ops != NULL && b->ops->check_status != NULL)
d4039 1
a4039 13
	  b->ops->check_status (bs);
	  if (!bs->stop)
	    continue;
	}

	  if (b->type == bp_thread_event || b->type == bp_overlay_event
	      || b->type == bp_longjmp_master
	      || b->type == bp_std_terminate_master
	      || b->type == bp_exception_master)
	    /* We do not stop for these.  */
	    bs->stop = 0;
	  else
	    bpstat_check_breakpoint_conditions (bs, ptid);
d4072 1
d4703 1
a4703 1
  if (!part_of_multiple && b->ops && b->ops->print_one_detail)
a4705 10
  if (!part_of_multiple && b->static_trace_marker_id)
    {
      gdb_assert (b->type == bp_static_tracepoint);

      ui_out_text (uiout, "\tmarker id is ");
      ui_out_field_string (uiout, "static-tracepoint-marker-string-id",
			   b->static_trace_marker_id);
      ui_out_text (uiout, "\n");
    }

d5396 2
d5456 1
a5456 8
  struct bp_location *loc;

  if (bpt->ops && bpt->ops->allocate_location)
    return bpt->ops->allocate_location (bpt);

  loc = xmalloc (sizeof (struct bp_location));
  init_bp_location (loc, NULL, bpt);
  return loc;
d5462 1
a5462 9
  if (loc->ops && loc->ops->dtor)
    loc->ops->dtor (loc);

  if (loc->cond)
    xfree (loc->cond);

  if (loc->function_name)
    xfree (loc->function_name);

d5518 2
a5538 2
/* This function is used in gdbtk sources and thus can not be made
   static.  */
d5542 2
a5543 1
				     enum bptype bptype)
d5547 1
a5547 1
  init_raw_breakpoint_without_location (b, gdbarch, bptype, NULL);
d5683 2
a5684 1
		    struct symtab_and_line sal, enum bptype bptype)
d5688 1
a5688 1
  init_raw_breakpoint (b, gdbarch, sal, bptype, NULL);
d6031 1
a6031 1
print_it_catch_fork (struct breakpoint *b)
d6033 2
a6034 1
  struct fork_catchpoint *c = (struct fork_catchpoint *) b;
d6091 3
a6093 3
  NULL, /* dtor */
  NULL, /* allocate_location */
  NULL, /* re_set */
d6097 3
a6099 3
  NULL, /* check_status */
  NULL, /* resources_needed */
  NULL, /* works_in_software_mode */
d6102 1
a6102 1
  NULL, /* print_one_detail */
d6141 1
a6141 1
print_it_catch_vfork (struct breakpoint *b)
d6143 1
d6200 3
a6202 3
  NULL, /* dtor */
  NULL, /* allocate_location */
  NULL, /* re_set */
d6206 3
a6208 3
  NULL, /* check_status */
  NULL, /* resources_needed */
  NULL, /* works_in_software_mode */
d6211 1
a6211 1
  NULL, /* print_one_detail */
d6243 2
d6369 1
a6369 1
print_it_catch_syscall (struct breakpoint *b)
d6371 1
d6533 2
a6534 2
  NULL, /* allocate_location */
  NULL, /* re_set */
d6538 3
a6540 3
  NULL, /* check_status */
  NULL, /* resources_needed */
  NULL, /* works_in_software_mode */
d6543 1
a6543 1
  NULL, /* print_one_detail */
d6631 2
d6657 1
a6657 1
print_it_catch_exec (struct breakpoint *b)
d6659 1
d6709 2
a6710 2
  NULL, /* allocate_location */
  NULL, /* re_set */
d6714 3
a6716 3
  NULL, /* check_status */
  NULL, /* resources_needed */
  NULL, /* works_in_software_mode */
d6719 1
a6719 1
  NULL, /* print_one_detail */
d6752 1
a6752 4
	  if (b->ops && b->ops->resources_needed)
	    i += b->ops->resources_needed (bl);
	  else
	    i++;
d6777 1
a6777 4
	      if (b->ops && b->ops->resources_needed)
		i += b->ops->resources_needed (bl);
	      else
		i++;
d6883 1
a6883 1
  b = set_raw_breakpoint (gdbarch, sal, type);
d6911 2
a6912 1
  copy = set_raw_breakpoint_without_location (orig->gdbarch, orig->type);
d6960 1
a6960 156
  int say_where = 0;
  struct cleanup *ui_out_chain;
  struct value_print_options opts;

  get_user_print_options (&opts);

  if (b->ops != NULL && b->ops->print_mention != NULL)
    b->ops->print_mention (b);
  else
    switch (b->type)
      {
      case bp_none:
	printf_filtered (_("(apparently deleted?) Eventpoint %d: "),
			 b->number);
	break;
      case bp_watchpoint:
	ui_out_text (uiout, "Watchpoint ");
	ui_out_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "wpt");
	ui_out_field_int (uiout, "number", b->number);
	ui_out_text (uiout, ": ");
	ui_out_field_string (uiout, "exp", b->exp_string);
	do_cleanups (ui_out_chain);
	break;
      case bp_hardware_watchpoint:
	ui_out_text (uiout, "Hardware watchpoint ");
	ui_out_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "wpt");
	ui_out_field_int (uiout, "number", b->number);
	ui_out_text (uiout, ": ");
	ui_out_field_string (uiout, "exp", b->exp_string);
	do_cleanups (ui_out_chain);
	break;
      case bp_read_watchpoint:
	ui_out_text (uiout, "Hardware read watchpoint ");
	ui_out_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "hw-rwpt");
	ui_out_field_int (uiout, "number", b->number);
	ui_out_text (uiout, ": ");
	ui_out_field_string (uiout, "exp", b->exp_string);
	do_cleanups (ui_out_chain);
	break;
      case bp_access_watchpoint:
	ui_out_text (uiout, "Hardware access (read/write) watchpoint ");
	ui_out_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "hw-awpt");
	ui_out_field_int (uiout, "number", b->number);
	ui_out_text (uiout, ": ");
	ui_out_field_string (uiout, "exp", b->exp_string);
	do_cleanups (ui_out_chain);
	break;
      case bp_breakpoint:
      case bp_gnu_ifunc_resolver:
	if (ui_out_is_mi_like_p (uiout))
	  {
	    say_where = 0;
	    break;
	  }
	if (b->disposition == disp_del)
	  printf_filtered (_("Temporary breakpoint"));
	else
	  printf_filtered (_("Breakpoint"));
	printf_filtered (_(" %d"), b->number);
	if (b->type == bp_gnu_ifunc_resolver)
	  printf_filtered (_(" at gnu-indirect-function resolver"));
	say_where = 1;
	break;
      case bp_hardware_breakpoint:
	if (ui_out_is_mi_like_p (uiout))
	  {
	    say_where = 0;
	    break;
	  }
	printf_filtered (_("Hardware assisted breakpoint %d"), b->number);
	say_where = 1;
	break;
      case bp_tracepoint:
	if (ui_out_is_mi_like_p (uiout))
	  {
	    say_where = 0;
	    break;
	  }
	printf_filtered (_("Tracepoint"));
	printf_filtered (_(" %d"), b->number);
	say_where = 1;
	break;
      case bp_fast_tracepoint:
	if (ui_out_is_mi_like_p (uiout))
	  {
	    say_where = 0;
	    break;
	  }
	printf_filtered (_("Fast tracepoint"));
	printf_filtered (_(" %d"), b->number);
	say_where = 1;
	break;
      case bp_static_tracepoint:
	if (ui_out_is_mi_like_p (uiout))
	  {
	    say_where = 0;
	    break;
	  }
	printf_filtered (_("Static tracepoint"));
	printf_filtered (_(" %d"), b->number);
	say_where = 1;
	break;

      case bp_until:
      case bp_finish:
      case bp_longjmp:
      case bp_longjmp_resume:
      case bp_exception:
      case bp_exception_resume:
      case bp_step_resume:
      case bp_hp_step_resume:
      case bp_call_dummy:
      case bp_std_terminate:
      case bp_watchpoint_scope:
      case bp_shlib_event:
      case bp_thread_event:
      case bp_overlay_event:
      case bp_jit_event:
      case bp_longjmp_master:
      case bp_std_terminate_master:
      case bp_exception_master:
      case bp_gnu_ifunc_resolver_return:
	break;
      }

  if (say_where)
    {
      /* i18n: cagney/2005-02-11: Below needs to be merged into a
	 single string.  */
      if (b->loc == NULL)
	{
	  printf_filtered (_(" (%s) pending."), b->addr_string);
	}
      else
	{
	  if (opts.addressprint || b->source_file == NULL)
	    {
	      printf_filtered (" at ");
	      fputs_filtered (paddress (b->loc->gdbarch, b->loc->address),
			      gdb_stdout);
	    }
	  if (b->source_file)
	    printf_filtered (": file %s, line %d.",
			     b->source_file, b->line_number);
	  
	  if (b->loc->next)
	    {
	      struct bp_location *loc = b->loc;
	      int n = 0;
	      for (; loc; loc = loc->next)
		++n;
	      printf_filtered (" (%d locations)", n);		
	    }

	}
    }
d7083 1
a7083 1
	  b = set_raw_breakpoint (gdbarch, sal, type);
a7164 1
  b->ops = ops;
d7622 2
d7816 1
a7816 1
      b = set_raw_breakpoint_without_location (gdbarch, type_wanted);
a7823 1
      b->ops = ops;
d7859 1
a7859 1
/* Set a breakpoint. 
d7865 1
a7865 1
   
d7880 1
a7880 1
		     NULL /* breakpoint_ops */,
a7885 1

d8065 1
a8065 1
print_it_ranged_breakpoint (struct breakpoint *b)
d8067 1
d8176 5
a8180 5
  NULL, /* dtor */
  NULL, /* allocate_location */
  NULL, /* re_set */
  NULL, /* insert */
  NULL, /* remove */
d8182 1
a8182 1
  NULL, /* check_status */
d8184 1
a8184 1
  NULL, /* works_in_software_mode */
d8334 1
a8334 1
			  bp_hardware_breakpoint);
a8339 1
  b->ops = &ranged_breakpoint_ops;
d8458 33
a8512 3
/* Implement the "resources_needed" breakpoint_ops method for
   hardware watchpoints.  */

d8514 2
a8515 1
resources_needed_watchpoint (const struct bp_location *bl)
d8517 1
a8517 1
  int length = bl->owner->exact? 1 : bl->length;
d8519 9
a8527 2
  return target_region_ok_for_hw_watchpoint (bl->address, length);
}
d8529 1
a8529 7
/* Implement the "works_in_software_mode" breakpoint_ops method for
   hardware watchpoints.  */

int
works_in_software_mode_watchpoint (const struct breakpoint *b)
{
  return b->type == bp_hardware_watchpoint;
d8532 2
a8533 3
/* The breakpoint_ops structure to be used in hardware watchpoints.  */

static struct breakpoint_ops watchpoint_breakpoint_ops =
d8535 1
a8535 18
  NULL, /* dtor */
  NULL, /* allocate_location */
  NULL, /* re_set */
  insert_watchpoint,
  remove_watchpoint,
  NULL, /* breakpoint_hit */
  NULL, /* check_status */
  resources_needed_watchpoint,
  works_in_software_mode_watchpoint,
  NULL, /* print_it */
  NULL, /* print_one */
  NULL, /* print_one_detail */
  NULL, /* print_mention */
  NULL  /* print_recreate */
};

/* Implement the "insert" breakpoint_ops method for
   masked hardware watchpoints.  */
d8537 1
a8537 5
static int
insert_masked_watchpoint (struct bp_location *bl)
{
  return target_insert_mask_watchpoint (bl->address, bl->owner->hw_wp_mask,
					bl->watchpoint_type);
d8540 2
a8541 2
/* Implement the "remove" breakpoint_ops method for
   masked hardware watchpoints.  */
d8544 1
a8544 1
remove_masked_watchpoint (struct bp_location *bl)
d8546 1
a8546 3
  return target_remove_mask_watchpoint (bl->address, bl->owner->hw_wp_mask,
				        bl->watchpoint_type);
}
d8548 1
a8548 8
/* Implement the "resources_needed" breakpoint_ops method for
   masked hardware watchpoints.  */

static int
resources_needed_masked_watchpoint (const struct bp_location *bl)
{
  return target_masked_watch_num_registers (bl->address,
					    bl->owner->hw_wp_mask);
d8552 1
a8552 1
   masked hardware watchpoints.  */
d8555 1
a8555 1
works_in_software_mode_masked_watchpoint (const struct breakpoint *b)
d8557 1
a8557 1
  return 0;
a8559 3
/* Implement the "print_it" breakpoint_ops method for
   masked hardware watchpoints.  */

d8561 1
a8561 1
print_it_masked_watchpoint (struct breakpoint *b)
d8563 13
a8575 2
  /* Masked watchpoints have only one location.  */
  gdb_assert (b->loc && b->loc->next == NULL);
d8579 1
d8586 11
d8604 7
d8614 28
a8641 4
      if (ui_out_is_mi_like_p (uiout))
	ui_out_field_string
	  (uiout, "reason",
	   async_reason_lookup (EXEC_ASYNC_ACCESS_WATCHPOINT_TRIGGER));
d8644 166
a8809 2
      internal_error (__FILE__, __LINE__,
		      _("Invalid hardware watchpoint type."));
d8902 3
a8904 3
  NULL, /* dtor */
  NULL, /* allocate_location */
  NULL, /* re_set */
d8907 2
a8908 2
  NULL, /* breakpoint_hit */
  NULL, /* check_status */
d9147 6
a9152 1
  b = set_raw_breakpoint_without_location (NULL, bp_type);
d9158 1
a9183 1
      b->ops = &masked_watchpoint_breakpoint_ops;
a9188 1
      b->ops = &watchpoint_breakpoint_ops;
d9638 1
a9638 1
print_it_exception_catchpoint (struct breakpoint *b)
d9640 1
d9726 9
a9734 9
  NULL, /* dtor */
  NULL, /* allocate_location */
  NULL, /* re_set */
  NULL, /* insert */
  NULL, /* remove */
  NULL, /* breakpoint_hit */
  NULL, /* check_status */
  NULL, /* resources_needed */
  NULL, /* works_in_software_mode */
d9737 1
a9737 1
  NULL, /* print_one_detail */
d10426 549
a10974 8
	      VEC_safe_push (bp_location_p, moribund_locations, old_loc);
	    }
	  else
	    {
	      old_loc->owner = NULL;
	      decref_bp_location (&old_loc);
	    }
	}
d10976 1
d10978 15
a10992 6
  /* Rescan breakpoints at the same address and section, marking the
     first one as "first" and any others as "duplicates".  This is so
     that the bpt instruction is only inserted once.  If we have a
     permanent breakpoint at the same place as BPT, make that one the
     official one, and the rest as duplicates.  Permanent breakpoints
     are sorted first for the same address.
d10994 7
a11000 2
     Do the same for hardware watchpoints, but also considering the
     watchpoint's type (regular/access/read) and length.  */
d11002 4
a11005 10
  bp_loc_first = NULL;
  wp_loc_first = NULL;
  awp_loc_first = NULL;
  rwp_loc_first = NULL;
  ALL_BP_LOCATIONS (loc, locp)
    {
      /* ALL_BP_LOCATIONS bp_location has LOC->OWNER always
	 non-NULL.  */
      struct breakpoint *b = loc->owner;
      struct bp_location **loc_first_p;
d11007 1
a11007 8
      if (b->enable_state == bp_disabled
	  || b->enable_state == bp_call_disabled
	  || b->enable_state == bp_startup_disabled
	  || !loc->enabled
	  || loc->shlib_disabled
	  || !breakpoint_address_is_meaningful (b)
	  || is_tracepoint (b))
	continue;
d11009 17
a11025 5
      /* Permanent breakpoint should always be inserted.  */
      if (b->enable_state == bp_permanent && ! loc->inserted)
	internal_error (__FILE__, __LINE__,
			_("allegedly permanent breakpoint is not "
			"actually inserted"));
d11027 1
a11027 8
      if (b->type == bp_hardware_watchpoint)
	loc_first_p = &wp_loc_first;
      else if (b->type == bp_read_watchpoint)
	loc_first_p = &rwp_loc_first;
      else if (b->type == bp_access_watchpoint)
	loc_first_p = &awp_loc_first;
      else
	loc_first_p = &bp_loc_first;
d11029 5
a11033 8
      if (*loc_first_p == NULL
	  || (overlay_debugging && loc->section != (*loc_first_p)->section)
	  || !breakpoint_locations_match (loc, *loc_first_p))
	{
	  *loc_first_p = loc;
	  loc->duplicate = 0;
	  continue;
	}
d11035 5
a11039 1
      loc->duplicate = 1;
d11041 5
a11045 6
      if ((*loc_first_p)->owner->enable_state == bp_permanent && loc->inserted
	  && b->enable_state != bp_permanent)
	internal_error (__FILE__, __LINE__,
			_("another breakpoint was inserted on top of "
			"a permanent breakpoint"));
    }
d11047 8
a11054 4
  if (breakpoints_always_inserted_mode () && should_insert
      && (have_live_inferiors ()
	  || (gdbarch_has_global_breakpoints (target_gdbarch))))
    insert_breakpoint_locations ();
d11056 4
a11059 1
  do_cleanups (cleanups);
d11062 2
a11063 2
void
breakpoint_retire_moribund (void)
d11065 2
a11066 2
  struct bp_location *loc;
  int ix;
d11068 4
a11071 7
  for (ix = 0; VEC_iterate (bp_location_p, moribund_locations, ix, loc); ++ix)
    if (--(loc->events_till_retirement) == 0)
      {
	decref_bp_location (&loc);
	VEC_unordered_remove (bp_location_p, moribund_locations, ix);
	--ix;
      }
d11075 2
a11076 1
update_global_location_list_nothrow (int inserting)
d11078 3
a11080 1
  struct gdb_exception e;
d11082 5
a11086 2
  TRY_CATCH (e, RETURN_MASK_ERROR)
    update_global_location_list (inserting);
a11088 2
/* Clear BKP from a BPS.  */

d11090 1
a11090 1
bpstat_remove_bp_location (bpstat bps, struct breakpoint *bpt)
d11092 21
a11112 1
  bpstat bs;
d11114 1
a11114 7
  for (bs = bps; bs; bs = bs->next)
    if (bs->breakpoint_at == bpt)
      {
	bs->breakpoint_at = NULL;
	bs->old_val = NULL;
	/* bs->commands will be freed later.  */
      }
d11117 2
a11118 3
/* Callback for iterate_over_threads.  */
static int
bpstat_remove_breakpoint_callback (struct thread_info *th, void *data)
d11120 9
a11128 1
  struct breakpoint *bpt = data;
d11130 1
a11130 2
  bpstat_remove_bp_location (th->control.stop_bpstat, bpt);
  return 0;
d11133 18
a11214 15
  if (bpt->ops != NULL && bpt->ops->dtor != NULL)
    bpt->ops->dtor (bpt);

  decref_counted_command_line (&bpt->commands);
  xfree (bpt->cond_string);
  xfree (bpt->cond_exp);
  xfree (bpt->addr_string);
  xfree (bpt->addr_string_range_end);
  xfree (bpt->exp);
  xfree (bpt->exp_string);
  xfree (bpt->exp_string_reparse);
  value_free (bpt->val);
  xfree (bpt->source_file);


d11235 1
a11235 1

a11238 1

d11757 5
a11761 1
void
d11813 1
d11815 3
a11817 122
  if (b->ops != NULL && b->ops->re_set != NULL)
    {
      struct cleanup *cleanups;

      cleanups = prepare_re_set_context (b);
      b->ops->re_set (b);
      do_cleanups (cleanups);

      return 0;
    }

  switch (b->type)
    {
    case bp_none:
      warning (_("attempted to reset apparently deleted breakpoint #%d?"),
	       b->number);
      return 0;
    case bp_breakpoint:
    case bp_hardware_breakpoint:
    case bp_tracepoint:
    case bp_fast_tracepoint:
    case bp_static_tracepoint:
    case bp_gnu_ifunc_resolver:
      /* Do not attempt to re-set breakpoints disabled during startup.  */
      if (b->enable_state == bp_startup_disabled)
	return 0;

      if (b->addr_string == NULL)
	{
	  /* Anything without a string can't be re-set.  */
	  delete_breakpoint (b);
	  return 0;
	}

      {
	struct cleanup *cleanups;

	cleanups = prepare_re_set_context (b);
	breakpoint_re_set_default (b);
	do_cleanups (cleanups);
      }
      break;

    case bp_watchpoint:
    case bp_hardware_watchpoint:
    case bp_read_watchpoint:
    case bp_access_watchpoint:
      /* Watchpoint can be either on expression using entirely global
	 variables, or it can be on local variables.

	 Watchpoints of the first kind are never auto-deleted, and
	 even persist across program restarts. Since they can use
	 variables from shared libraries, we need to reparse
	 expression as libraries are loaded and unloaded.

	 Watchpoints on local variables can also change meaning as
	 result of solib event.  For example, if a watchpoint uses
	 both a local and a global variables in expression, it's a
	 local watchpoint, but unloading of a shared library will make
	 the expression invalid.  This is not a very common use case,
	 but we still re-evaluate expression, to avoid surprises to
	 the user.

	 Note that for local watchpoints, we re-evaluate it only if
	 watchpoints frame id is still valid.  If it's not, it means
	 the watchpoint is out of scope and will be deleted soon.  In
	 fact, I'm not sure we'll ever be called in this case.

	 If a local watchpoint's frame id is still valid, then
	 b->exp_valid_block is likewise valid, and we can safely use it.
	 
	 Don't do anything about disabled watchpoints, since they will
	 be reevaluated again when enabled.  */
      update_watchpoint (b, 1 /* reparse */);
      break;
      /* We needn't really do anything to reset these, since the mask
         that requests them is unaffected by e.g., new libraries being
         loaded.  */
    case bp_catchpoint:
      break;

    default:
      printf_filtered (_("Deleting unknown breakpoint type %d\n"), b->type);
      /* fall through */
      /* Delete overlay event and longjmp master breakpoints; they will be
	 reset later by breakpoint_re_set.  */
    case bp_overlay_event:
    case bp_longjmp_master:
    case bp_std_terminate_master:
    case bp_exception_master:
      delete_breakpoint (b);
      break;

      /* This breakpoint is special, it's set up when the inferior
         starts and we really don't want to touch it.  */
    case bp_shlib_event:

      /* Like bp_shlib_event, this breakpoint type is special.
	 Once it is set up, we do not want to touch it.  */
    case bp_thread_event:

      /* Keep temporary breakpoints, which can be encountered when we
         step over a dlopen call and SOLIB_ADD is resetting the
         breakpoints.  Otherwise these should have been blown away via
         the cleanup chain or by breakpoint_init_inferior when we
         rerun the executable.  */
    case bp_until:
    case bp_finish:
    case bp_watchpoint_scope:
    case bp_call_dummy:
    case bp_std_terminate:
    case bp_step_resume:
    case bp_hp_step_resume:
    case bp_longjmp:
    case bp_longjmp_resume:
    case bp_exception:
    case bp_exception_resume:
    case bp_jit_event:
    case bp_gnu_ifunc_resolver_return:
      break;
    }

d12569 1
a12569 1
			 NULL,
d12586 1
a12586 1
			 NULL,
d12605 1
a12605 1
			 NULL,
d12670 1
a12670 1
			  NULL,
d12996 1
a12996 43
    if (tp->ops != NULL && tp->ops->print_recreate != NULL)
      (tp->ops->print_recreate) (tp, fp);
    else
      {
	if (tp->type == bp_fast_tracepoint)
	  fprintf_unfiltered (fp, "ftrace");
	if (tp->type == bp_static_tracepoint)
	  fprintf_unfiltered (fp, "strace");
	else if (tp->type == bp_tracepoint)
	  fprintf_unfiltered (fp, "trace");
	else if (tp->type == bp_breakpoint && tp->disposition == disp_del)
	  fprintf_unfiltered (fp, "tbreak");
	else if (tp->type == bp_breakpoint)
	  fprintf_unfiltered (fp, "break");
	else if (tp->type == bp_hardware_breakpoint
		 && tp->disposition == disp_del)
	  fprintf_unfiltered (fp, "thbreak");
	else if (tp->type == bp_hardware_breakpoint)
	  fprintf_unfiltered (fp, "hbreak");
	else if (tp->type == bp_watchpoint)
	  fprintf_unfiltered (fp, "watch");
	else if (tp->type == bp_hardware_watchpoint)
	  fprintf_unfiltered (fp, "watch");
	else if (tp->type == bp_read_watchpoint)
	  fprintf_unfiltered (fp, "rwatch");
	else if (tp->type == bp_access_watchpoint)
	  fprintf_unfiltered (fp, "awatch");
	else
	  internal_error (__FILE__, __LINE__,
			  _("unhandled breakpoint type %d"), (int) tp->type);

	if (tp->exp_string)
	  fprintf_unfiltered (fp, " %s", tp->exp_string);
	else if (tp->addr_string)
	  fprintf_unfiltered (fp, " %s", tp->addr_string);
	else
	  {
	    char tmp[40];

	    sprintf_vma (tmp, tp->loc->address);
	    fprintf_unfiltered (fp, " *0x%s", tmp);
	  }
      }
@


1.594
log
@	* breakpoint.c: Fix typos in comments.
	* linespec.c: Likewise.
	* symtab.c: Likewise.
@
text
@d8778 1
a8778 1
    error (_("Invalid address range, end preceeds start."));
@


1.593
log
@gdb/
	* breakpoint.c (bpstat_what): Removed duplicated case.
@
text
@d361 1
a361 1
   ALL_BREAKPOINTS_SAFE does so even if the statment deletes the
d707 1
a707 1
/* A helper function that validsates that COMMANDS are valid for a
d989 1
a989 1
    /* bp isn't valid, or doesn't shadow memory.  */
d1077 1
a1077 1
    /* Performance optimization: any futher element can no longer affect BUF
d2063 1
a2063 1
   Otherwis the breakpoint number will be populated from
d2454 1
a2454 1
       In the absense of a general solution for the "how do we know
d2790 1
a2790 1
   - When continuing from a localion with a permanent breakpoint, we
d4360 1
a4360 1
	  /* Print nothing for this entry if we dont stop or dont print.  */
d5010 1
a5010 1
      /* FIXME: cagney/2002-12-01: Shouldn't be poeking around inside
d6018 1
a6018 1
     multiple locations or not, but it's easy to implmement.  */
d6756 1
a6756 1
             because xstrprintf dinamically allocates new space for it
d7741 1
a7741 1
      /* This is un ugly workaround.  If we get zero expanded sals
d10078 1
a10078 1
         inapropriate, we should use the word catchpoint, and tell
d10369 1
a10369 1
   qsort being an instable algorithm.  */
d10508 1
a10508 1
      /* Tells if 'old_loc' is found amoung the new locations.  If
d10882 1
a10882 1
     in all threeds for now.  Note that we cannot just remove bpstats
@


1.592
log
@2011-06-22  Pedro Alves  <pedro@@codesourcery.com>

	* breakpoint.c (bpstat_stop_status): Call the check_status
	breakpoint_ops method.
	(print_one_breakpoint_location): Also print the condition for Ada
	exception catchpoints.
	(allocate_bp_location): New, factored out from
	allocate_bp_location.
	(allocate_bp_location): Adjust.  Call the owner breakpoint's
	allocate_location method, if there is one.
	(free_bp_location): Call the locations's dtor method, if there is
	one.
	(init_raw_breakpoint_without_location): New breakpoint_ops
	parameter.  Use it.
	(set_raw_breakpoint_without_location): Adjust.
	(init_raw_breakpoint): New breakpoint_ops parameter.  Pass it down.
	(set_raw_breakpoint): Adjust.
	(catch_fork_breakpoint_ops, catch_vfork_breakpoint_ops)
	(catch_syscall_breakpoint_ops): Install NULL allocate_location,
	re_set and check_status methods.
	(init_catchpoint): Don't memset, initialize thread, addr_string
	and enable_state.  Pass the ops down to init_raw_breakpoint.
	(install_catchpoint): Rename to ...
	(install_breakpoint): ... this, and make extern.
	(create_fork_vfork_event_catchpoint): Adjust.
	(catch_exec_breakpoint_ops): Install NULL allocate_location,
	re_set and check_status methods.
	(create_syscall_event_catchpoint): Adjust.
	(ranged_breakpoint_ops, watchpoint_breakpoint_ops)
	(masked_watchpoint_breakpoint_ops): Install NULL
	allocate_location, re_set and check_status methods.
	(catch_exec_command_1): Adjust.
	(gnu_v3_exception_catchpoint_ops): Install NULL allocate_location,
	re_set and check_status methods.
	(create_ada_exception_breakpoint): Rename to ...
	(init_ada_exception_breakpoint): ... this.  Add a struct
	breakpoint parameter, and delete the exp_string, cond_string and
	cond parameters.  Use init_raw_breakpoint, and don't install or
	mention the breakpoint yet.  Don't clear breakpoint fields that
	init_raw_breakpoint already clears.
	(re_set_breakpoint): Delete, split into ...
	(breakpoint_re_set_default, prepare_re_set_context): ... these new
	functions.
	(breakpoint_re_set_one): Call the breakpoint's
	breakpoint_ops->re_set implementation, if there's one.  Adjust.
	* breakpoint.h: Forward declare struct bpstats and struct bp_location.
	(struct bp_location_ops): New type.
	(struct bp_location): New field `ops'.
	(struct breakpoint_ops): New `allocate_location', `re_set' and
	`check_status' fields.  Make `breakpoint_hit''s description match
	reality.
	(init_bp_location): Declare.
	(breakpoint_re_set_default): Declare.
	(create_ada_exception_breakpoint): Rename to ...
	(init_ada_exception_breakpoint): ... this.  Add a struct
	breakpoint parameter, and delete the exp_string, cond_string and
	cond parameters.
	(install_breakpoint): Declare.
	* ada-lang.c: Include exceptions.h.
	<Ada exceptions description>: Update.
	(struct ada_catchpoint_location): New type.
	(ada_catchpoint_location_dtor): New function.
	(ada_catchpoint_location_ops): New global.
	(ada_catchpoint): New type.
	(create_excep_cond_exprs): New function.
	(dtor_exception, allocate_location_exception, re_set_exception)
	(should_stop_exception, check_status_exception): New functions.
	(print_one_exception, print_mention_exception)
	(print_recreate_exception): Adjust.
	(dtor_catch_exception, allocate_location_catch_exception)
	(re_set_catch_exception, check_status_catch_exception): New
	functions.
	(catch_exception_breakpoint_ops): Install them.
	(dtor_catch_exception_unhandled)
	(allocate_location_catch_exception_unhandled)
	(re_set_catch_exception_unhandled)
	(check_status_catch_exception_unhandled): New functions.
	(catch_exception_unhandled_breakpoint_ops): Install them.
	(dtor_catch_assert, allocate_location_catch_assert)
	(re_set_catch_assert, check_status_catch_assert): New functions.
	(catch_assert_breakpoint_ops): Install them.
	(ada_exception_catchpoint_p): Delete.
	(catch_ada_exception_command_split)
	(ada_exception_catchpoint_cond_string): Rename exp_string
	parameter to excep_string.  Adjust.
	(ada_parse_catchpoint_condition): Delete.
	(ada_exception_sal): Rename the exp_string parameter to
	excep_string.  Delete the cond_string and cond parameters.
	Adjust.
	(ada_decode_exception_location): Rename the exp_string parameter
	to excep_string.  Delete the cond_string and cond parameters.
	Adjust.
	(create_ada_exception_catchpoint): New function.
	(catch_ada_exception_command, ada_decode_assert_location)
	(catch_assert_command): Adjust.
	* ada-lang.h (ada_exception_catchpoint_p): Delete declaration.
@
text
@a4437 2
      else if (bs->breakpoint_at == NULL)
	bptype = bp_none;
@


1.591
log
@2011-06-22  Pedro Alves  <pedro@@codesourcery.com>

	* ada-lang.c: Include arch-utils.h.
	(ada_decode_exception_location): Make static.
	(catch_ada_exception_command): Moved here from breakpoint.c.
	(ada_decode_assert_location): Make static.
	(catch_assert_command): Moved here from breakpoint.c.
	(_initialize_ada_lang): Install the exception and assert
	catchpoint commands here.
	* ada-lang.h (ada_decode_exception_location)
	(ada_decode_assert_location): Delete declarations.
	* breakpoint.c (CATCH_PERMANENT, CATCH_TEMPORARY): Moved to
	breakpoint.h.
	(create_ada_exception_breakpoint): Make extern.
	(catch_ada_exception_command, catch_assert_command): Moved to
	ada-lang.c.
	(add_catch_command): Make extern.
	(_initilize_breakpoint): Don't install the exception and assert
	catchpoint commands here.
	* breakpoint.h (CATCH_PERMANENT, CATCH_TEMPORARY): Moved from
	breakpoint.c
	(add_catch_command, create_ada_exception_breakpoint): Declare.
@
text
@d4316 7
d5019 1
a5019 1
  if (!part_of_multiple && b->cond_string && !ada_exception_catchpoint_p (b))
a5020 3
      /* We do not print the condition for Ada exception catchpoints
         because the condition is an internal implementation detail
         that we do not want to expose to the user.  */
d5692 3
a5694 4
/* Allocate a struct bp_location.  */

static struct bp_location *
allocate_bp_location (struct breakpoint *bpt)
a5695 3
  struct bp_location *loc;

  loc = xmalloc (sizeof (struct bp_location));
d5698 2
a5699 1
  loc->owner = bpt;
d5704 1
a5704 1
  switch (bpt->type)
d5749 14
d5769 3
d5828 2
a5829 1
				      enum bptype bptype)
d5833 1
a5844 1
  b->ops = NULL;
d5861 1
a5861 1
  init_raw_breakpoint_without_location (b, gdbarch, bptype);
d5933 2
a5934 1
		     struct symtab_and_line sal, enum bptype bptype)
d5939 1
a5939 1
  init_raw_breakpoint_without_location (b, gdbarch, bptype);
d6001 1
a6001 1
  init_raw_breakpoint (b, gdbarch, sal, bptype);
d6404 2
d6409 1
d6512 2
d6517 1
d6841 2
d6846 1
a6876 2
  memset (b, 0, sizeof (*b));

d6880 1
a6880 1
  init_raw_breakpoint (b, gdbarch, sal, bp_catchpoint);
a6882 3
  b->thread = -1;
  b->addr_string = NULL;
  b->enable_state = bp_enabled;
a6883 1
  b->ops = ops;
d6886 2
a6887 5
/* Add breakpoint B on the breakpoint list, and notify the user, the
   target and breakpoint_created observers of its existence.  */

static void
install_catchpoint (struct breakpoint *b)
d6908 1
a6908 1
  install_catchpoint (&c->base);
d7014 2
d7019 1
d7040 1
a7040 1
  install_catchpoint (&c->base);
d8642 2
d8647 1
d8971 2
d8976 1
d9153 2
d9158 1
d9880 1
a9880 1
  install_catchpoint (&c->base);
d9972 2
d9977 1
d10059 7
a10065 9
create_ada_exception_breakpoint (struct gdbarch *gdbarch,
				 struct symtab_and_line sal,
                                 char *addr_string,
                                 char *exp_string,
                                 char *cond_string,
                                 struct expression *cond,
                                 struct breakpoint_ops *ops,
                                 int tempflag,
                                 int from_tty)
a10066 2
  struct breakpoint *b;

d10085 1
a10085 2
  b = set_raw_breakpoint (gdbarch, sal, bp_breakpoint);
  set_breakpoint_count (breakpoint_count + 1);
a10088 3
  b->number = breakpoint_count;
  b->ignore_count = 0;
  b->loc->cond = cond;
a10090 8
  b->cond_string = cond_string;
  b->exp_string = exp_string;
  b->thread = -1;
  b->ops = ops;

  mention (b);
  observer_notify_breakpoint_created (b);
  update_global_location_list (1);
d11424 2
a11425 6
/* Reevaluate a hardware or software breakpoint and recreate its locations.
   This is necessary after symbols are read (e.g., an executable or DSO
   was loaded, or the inferior just started).  */

static void
re_set_breakpoint (struct breakpoint *b)
a11430 6
  struct cleanup *cleanups = make_cleanup (null_cleanup, NULL);

  input_radix = b->input_radix;
  save_current_space_and_thread ();
  switch_to_program_space_and_thread (b->pspace);
  set_language (b->language);
d11450 15
a11464 1
  do_cleanups (cleanups);
d11477 11
d11511 7
a11517 1
      re_set_breakpoint (b);
@


1.590
log
@2011-06-22  Pedro Alves  <pedro@@codesourcery.com>

	* breakpoint.c (init_raw_breakpoint_without_location): Don't add
	the breakpoint to the breakpoint chain here.
	(set_raw_breakpoint_without_location): Add the breakpoint to the
	breakpoint chain here.
	(init_raw_breakpoint): Adjust comments.
	(set_raw_breakpoint): Add the breakpoint to the breakpoint chain
	here.
	(init_catchpoint): Don't set the catchpoint's breakpoint number
	here.
	(install_catchpoint): New function.
	(create_fork_vfork_event_catchpoint)
	(create_syscall_event_catchpoint, catch_exec_command_1): Adjust to
	use install_catchpoint.
@
text
@a78 4
/* Arguments to pass as context to some catch command handlers.  */
#define CATCH_PERMANENT ((void *) (uintptr_t) 0)
#define CATCH_TEMPORARY ((void *) (uintptr_t) 1)

d10023 1
a10023 3
/* Create a breakpoint struct for Ada exception catchpoints.  */

static void
a10073 26
/* Implement the "catch exception" command.  */

static void
catch_ada_exception_command (char *arg, int from_tty,
			     struct cmd_list_element *command)
{
  struct gdbarch *gdbarch = get_current_arch ();
  int tempflag;
  struct symtab_and_line sal;
  char *addr_string = NULL;
  char *exp_string = NULL;
  char *cond_string = NULL;
  struct expression *cond = NULL;
  struct breakpoint_ops *ops = NULL;

  tempflag = get_cmd_context (command) == CATCH_TEMPORARY;

  if (!arg)
    arg = "";
  sal = ada_decode_exception_location (arg, &addr_string, &exp_string,
                                       &cond_string, &cond, &ops);
  create_ada_exception_breakpoint (gdbarch, sal, addr_string, exp_string,
                                   cond_string, cond, ops, tempflag,
                                   from_tty);
}

a10171 21
/* Implement the "catch assert" command.  */

static void
catch_assert_command (char *arg, int from_tty,
		      struct cmd_list_element *command)
{
  struct gdbarch *gdbarch = get_current_arch ();
  int tempflag;
  struct symtab_and_line sal;
  char *addr_string = NULL;
  struct breakpoint_ops *ops = NULL;

  tempflag = get_cmd_context (command) == CATCH_TEMPORARY;

  if (!arg)
    arg = "";
  sal = ada_decode_assert_location (arg, &addr_string, &ops);
  create_ada_exception_breakpoint (gdbarch, sal, addr_string, NULL, NULL, NULL,
				   ops, tempflag, from_tty);
}

d12906 1
a12906 3
/* Like add_cmd, but add the command to both the "catch" and "tcatch"
   lists, and pass some additional user data to the command function.  */
static void
a13271 14
  add_catch_command ("exception", _("\
Catch Ada exceptions, when raised.\n\
With an argument, catch only exceptions with the given name."),
		     catch_ada_exception_command,
                     NULL,
		     CATCH_PERMANENT,
		     CATCH_TEMPORARY);
  add_catch_command ("assert", _("\
Catch failed Ada assertions, when raised.\n\
With an argument, catch only exceptions with the given name."),
		     catch_assert_command,
                     NULL,
		     CATCH_PERMANENT,
		     CATCH_TEMPORARY);
@


1.589
log
@2011-06-22  Pedro Alves  <pedro@@codesourcery.com>

	* breakpoint.c (create_catchpoint_without_mention)
	(create_catchpoint): Delete.
@
text
@a5832 2

  add_to_breakpoint_chain (b);
d5847 1
a5847 1

d5910 1
a5910 3
   file name, and line number are provided by SAL.  The newly created
   and partially initialized breakpoint is added to the breakpoint
   chain.
d5914 1
a5914 5
   information regarding the creation of a new breakpoint.  In
   particular, init_raw_breakpoint does NOT set the breakpoint number!
   Care should be taken to not allow an error to occur prior to
   completing the initialization of the breakpoint.  If this should
   happen, a bogus breakpoint will be left on the chain.  */
d5986 1
a6857 2
  set_breakpoint_count (breakpoint_count + 1);
  b->number = breakpoint_count;
d6867 14
d6892 1
a6892 3
  mention (&c->base);
  observer_notify_breakpoint_created (&c->base);
  update_global_location_list (1);
d7021 1
a7021 5
  /* Now, we have to mention the breakpoint and update the global
     location list.  */
  mention (&c->base);
  observer_notify_breakpoint_created (&c->base);
  update_global_location_list (1);
d9852 1
a9852 5
  /* Now, we have to mention the breakpoint and update the global
     location list.  */
  mention (&c->base);
  observer_notify_breakpoint_created (&c->base);
  update_global_location_list (1);
@


1.588
log
@2011-06-22  Pedro Alves  <pedro@@codesourcery.com>

	* breakpoint.h (struct breakpoint): Delete field `exec_pathname'.
	* breakpoint.c (init_raw_breakpoint_without_location): Remove
	reference to exec_pathname.
	(struct exec_catchpoint): New type.
	(dtor_catch_exec): New function.
	(insert_catch_exec, print_it_catch_exec, print_one_catch_exec): Adjust.
	(catch_exec_breakpoint_ops): Install dtor_catch_syscall.
	(catch_exec_command_1): Adjust to use init_catchpoint.
	(delete_breakpoint): Remove reference to exec_pathname.
@
text
@a6875 42
/* Create a new breakpoint of the bp_catchpoint kind and return it,
   but does NOT mention it nor update the global location list.
   This is useful if you need to fill more fields in the
   struct breakpoint before calling mention.

   If TEMPFLAG is non-zero, then make the breakpoint temporary.
   If COND_STRING is not NULL, then store it in the breakpoint.
   OPS, if not NULL, is the breakpoint_ops structure associated
   to the catchpoint.  */

static struct breakpoint *
create_catchpoint_without_mention (struct gdbarch *gdbarch, int tempflag,
				   char *cond_string,
				   struct breakpoint_ops *ops)
{
  struct breakpoint *b = XNEW (struct breakpoint);

  init_catchpoint (b, gdbarch, tempflag, cond_string, ops);
  return b;
}

/* Create a new breakpoint of the bp_catchpoint kind and return it.
 
   If TEMPFLAG is non-zero, then make the breakpoint temporary.
   If COND_STRING is not NULL, then store it in the breakpoint.
   OPS, if not NULL, is the breakpoint_ops structure associated
   to the catchpoint.  */

static struct breakpoint *
create_catchpoint (struct gdbarch *gdbarch, int tempflag,
		   char *cond_string, struct breakpoint_ops *ops)
{
  struct breakpoint *b =
    create_catchpoint_without_mention (gdbarch, tempflag, cond_string, ops);

  mention (b);
  observer_notify_breakpoint_created (b);
  update_global_location_list (1);

  return b;
}

@


1.587
log
@2011-06-22  Pedro Alves  <pedro@@codesourcery.com>

	* breakpoint.h (struct breakpoint_ops): New field `dtor'.
	(struct breakpoint): Delete field `syscalls_to_be_caught'.
	* breakpoint.c (init_raw_breakpoint_without_location): Remove
	reference to syscalls_to_be_caught.
	(catch_fork_breakpoint_ops, catch_vfork_breakpoint_ops): Install a
	NULL `dtor'.
	(struct syscall_catchpoint): New type.
	(dtor_catch_syscall): New function.
	(insert_catch_syscall, remove_catch_syscall)
	(breakpoint_hit_catch_syscall, print_one_catch_syscall)
	(print_recreate_catch_syscall): Adjust.
	(catch_syscall_breakpoint_ops): Install dtor_catch_syscall.
	(catch_exec_breakpoint_ops): Install a NULL `dtor'.
	(create_syscall_event_catchpoint): Adjust to use init_catchpoint.
	(ranged_breakpoint_ops, watchpoint_breakpoint_ops)
	(masked_watchpoint_breakpoint_ops)
	(gnu_v3_exception_catchpoint_ops): Install a NULL `dtor'.
	(delete_breakpoint): Call the `dtor' breakpoint_ops method, if
	there is one.  Remove references to syscalls_to_be_caught.
	(catching_syscall_number): Adjust.
	* ada-lang.c (catch_exception_breakpoint_ops)
	(catch_exception_unhandled_breakpoint_ops)
	(catch_assert_breakpoint_ops): Install a NULL `dtor'.
@
text
@a5828 1
  b->exec_pathname = NULL;
d6936 28
d6980 3
a6982 1
  return inferior_has_execd (inferior_ptid, &bl->owner->exec_pathname);
d6988 2
d6992 1
a6992 1
		   b->exec_pathname);
d6999 1
d7011 1
a7011 1
  if (b->exec_pathname != NULL)
d7014 1
a7014 1
      ui_out_field_string (uiout, "what", b->exec_pathname);
d7036 1
a7036 1
  NULL, /* dtor */
d9869 1
d9890 10
a9899 4
  /* If this target supports it, create an exec catchpoint
     and enable reporting of such events.  */
  create_catchpoint (gdbarch, tempflag, cond_string,
		     &catch_exec_breakpoint_ops);
a10959 1
  xfree (bpt->exec_pathname);
@


1.586
log
@2011-06-22  Pedro Alves  <pedro@@codesourcery.com>

	* breakpoint.h (struct breakpoint): Delete forked_inferior_pid
	field.
	* breakpoint.c (init_raw_breakpoint_without_location): Remove
	reference to forked_inferior_pid.
	(struct fork_catchpoint): New type.
	(breakpoint_hit_catch_fork, print_it_catch_fork)
	(print_one_catch_fork, breakpoint_hit_catch_vfork)
	(print_it_catch_vfork, print_one_catch_vfork): Adjust.
	(create_fork_vfork_event_catchpoint): Adjust to use
	init_catchpoint.
@
text
@a5829 1
  b->syscalls_to_be_caught = NULL;
d6395 1
d6500 1
d6513 29
d6548 1
d6552 1
a6552 1
  if (!bl->owner->syscalls_to_be_caught)
d6559 1
a6559 1
           VEC_iterate (int, bl->owner->syscalls_to_be_caught, i, iter);
d6594 1
d6598 1
a6598 1
  if (!bl->owner->syscalls_to_be_caught)
d6605 1
a6605 1
           VEC_iterate (int, bl->owner->syscalls_to_be_caught, i, iter);
d6636 2
a6637 1
  const struct breakpoint *b = bl->owner;
d6643 1
a6643 1
  if (b->syscalls_to_be_caught)
d6648 1
a6648 1
           VEC_iterate (int, b->syscalls_to_be_caught, i, iter);
d6708 1
d6719 2
a6720 2
  if (b->syscalls_to_be_caught
      && VEC_length (int, b->syscalls_to_be_caught) > 1)
d6725 1
a6725 1
  if (b->syscalls_to_be_caught)
d6731 1
a6731 1
           VEC_iterate (int, b->syscalls_to_be_caught, i, iter);
d6763 3
a6765 1
  if (b->syscalls_to_be_caught)
d6769 1
a6769 1
      if (VEC_length (int, b->syscalls_to_be_caught) > 1)
d6775 1
a6775 1
           VEC_iterate (int, b->syscalls_to_be_caught, i, iter);
d6799 2
d6803 1
a6803 1
  if (b->syscalls_to_be_caught)
d6808 1
a6808 1
           VEC_iterate (int, b->syscalls_to_be_caught, i, iter);
d6826 1
d7004 1
d7021 1
a7022 2
  struct breakpoint *b =
    create_catchpoint_without_mention (gdbarch, tempflag, NULL, ops);
d7024 3
a7026 1
  b->syscalls_to_be_caught = filter;
d7030 2
a7031 2
  mention (b);
  observer_notify_breakpoint_created (b);
d8633 1
d8959 1
d9138 1
d9951 1
d10908 3
a10921 1
  clean_up_filters (&bpt->syscalls_to_be_caught);
d12321 3
a12323 1
	if (bp->syscalls_to_be_caught)
d12327 1
a12327 1
                 VEC_iterate (int, bp->syscalls_to_be_caught, i, iter);
@


1.585
log
@2011-06-22  Pedro Alves  <pedro@@codesourcery.com>

	* breakpoint.c (add_to_breakpoint_chain)
	(init_raw_breakpoint_without_location): New functions, factored
	out from ...
	(set_raw_breakpoint_without_location): ... this one.
	(init_raw_breakpoint): New function, factored out from
	set_raw_breakpoint and adjusted to use
	init_raw_breakpoint_without_location.
	(set_raw_breakpoint): Adjust.
	(init_catchpoint): New function, factored out from
	create_catchpoint_without_mention and adjusted to use
	init_raw_breakpoint.
	(create_catchpoint_without_mention): Adjust.
@
text
@a5828 1
  b->forked_inferior_pid = null_ptid;
d6286 17
d6328 3
a6330 1
  return inferior_has_forked (inferior_ptid, &bl->owner->forked_inferior_pid);
d6339 2
d6343 1
a6343 1
		   b->number, ptid_get_pid (b->forked_inferior_pid));
d6353 1
d6365 1
a6365 1
  if (!ptid_equal (b->forked_inferior_pid, null_ptid))
d6369 1
a6369 1
                        ptid_get_pid (b->forked_inferior_pid));
d6433 3
a6435 1
  return inferior_has_vforked (inferior_ptid, &bl->owner->forked_inferior_pid);
d6444 2
d6448 1
a6448 1
		   b->number, ptid_get_pid (b->forked_inferior_pid));
d6458 1
d6469 1
a6469 1
  if (!ptid_equal (b->forked_inferior_pid, null_ptid))
d6473 1
a6473 1
                        ptid_get_pid (b->forked_inferior_pid));
d6885 3
a6887 2
  struct breakpoint *b
    = create_catchpoint (gdbarch, tempflag, cond_string, ops);
d6889 5
a6893 3
  /* FIXME: We should put this information in a breakpoint private data
     area.  */
  b->forked_inferior_pid = null_ptid;
@


1.584
log
@Various spelling fixes.

gdb/ChangeLog:

        From Stephen Kitt  <steve@@sk2.org>
        * breakpoint.c, breakpoint.h, cli/cli-dump.c, dwarf2expr.c,
        gdbarch.c, gdbarch.sh, remote.c: Various spelling fixes.

gdb/testsuite/ChangeLog:

        From Stephen Kitt  <steve@@sk2.org>
        * gdb.base/help.exp: Adjust following some spelling corrections
        in GDB.
@
text
@d5788 1
a5788 4
/* Helper to set_raw_breakpoint below.  Creates a breakpoint that has
   type BPTYPE and has no locations as yet.  */
/* This function is used in gdbtk sources and thus can not be made
   static.  */
d5790 2
a5791 3
static struct breakpoint *
set_raw_breakpoint_without_location (struct gdbarch *gdbarch,
				     enum bptype bptype)
d5793 1
a5793 1
  struct breakpoint *b, *b1;
d5795 21
a5815 1
  b = (struct breakpoint *) xmalloc (sizeof (struct breakpoint));
d5837 15
a5851 2
  /* Add this breakpoint to the end of the chain so that a list of
     breakpoints will come out in order of increasing numbers.  */
a5852 9
  b1 = breakpoint_chain;
  if (b1 == 0)
    breakpoint_chain = b;
  else
    {
      while (b1->next)
	b1 = b1->next;
      b1->next = b;
    }
d5913 5
a5917 6
/* set_raw_breakpoint is a low level routine for allocating and
   partially initializing a breakpoint of type BPTYPE.  The newly
   created breakpoint's address, section, source file name, and line
   number are provided by SAL.  The newly created and partially
   initialized breakpoint is added to the breakpoint chain and
   is also returned as the value of this function.
d5922 4
a5925 4
   particular, set_raw_breakpoint does NOT set the breakpoint
   number!  Care should be taken to not allow an error to occur
   prior to completing the initialization of the breakpoint.  If this
   should happen, a bogus breakpoint will be left on the chain.  */
d5927 3
a5929 3
struct breakpoint *
set_raw_breakpoint (struct gdbarch *gdbarch,
		    struct symtab_and_line sal, enum bptype bptype)
a5930 2
  struct breakpoint *b = set_raw_breakpoint_without_location (gdbarch, 
							      bptype);
d5934 2
d5973 1
d5975 22
d6782 4
a6785 9
/* Create a new breakpoint of the bp_catchpoint kind and return it,
   but does NOT mention it nor update the global location list.
   This is useful if you need to fill more fields in the
   struct breakpoint before calling mention.
 
   If TEMPFLAG is non-zero, then make the breakpoint temporary.
   If COND_STRING is not NULL, then store it in the breakpoint.
   OPS, if not NULL, is the breakpoint_ops structure associated
   to the catchpoint.  */
d6787 5
a6791 4
static struct breakpoint *
create_catchpoint_without_mention (struct gdbarch *gdbarch, int tempflag,
				   char *cond_string,
				   struct breakpoint_ops *ops)
d6794 2
a6795 1
  struct breakpoint *b;
d6800 1
a6800 1
  b = set_raw_breakpoint (gdbarch, sal, bp_catchpoint);
d6810 18
d6829 1
@


1.583
log
@2011-05-30  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* continuations.h (continuation_ftype): Add `err' parameter.
	Document parameters.
	(do_all_continuations, do_all_continuations_thread)
	(do_all_intermediate_continuations)
	(do_all_intermediate_continuations_thread)
	(do_all_inferior_continuations): Add `err' parameter.
	* continuations.c (do_my_continuations_1, do_my_continuations)
	(do_all_inferior_continuations, do_all_continuations_ptid)
	(do_all_continuations_thread_callback)
	(do_all_continuations_thread, do_all_continuations)
	(do_all_intermediate_continuations_thread_callback)
	(do_all_intermediate_continuations_thread)
	(do_all_intermediate_continuations): Add `err' parameter, and pass
	it down all the way to the continuations proper.
	* inf-loop.c (inferior_event_handler): If fetching an inferior
	event throws an error, don't pop the target, and still call the
	continuations, but with `err' set.  Adjust all other continuation
	calls.
	* breakpoint.c (until_break_command_continuation): Add `err'
	parameter.
	* infcmd.c (step_1_continuation): Add `err' parameter.  Don't
	issue another step if `err' is set.
	(struct until_next_continuation_args): New.
	(until_next_continuation): Add `err' parameter.  Adjust.
	(until_next_command): Adjust.
	(struct finish_command_continuation_args): Add `thread' field.
	(finish_command_continuation): Add `err' parameter.  Handle it.
	(finish_forward): Adjust.
	(attach_command_continuation): Add `err' parameter.  Handle it.
	* infrun.c (infrun_thread_stop_requested_callback): Adjust to
	cancel the continuations.
	* interps.c (interp_set): Adjust to cancel the continuations.
	* thread.c (clear_thread_inferior_resources): Adjust to cancel the
	continuations rather than discarding.
	(free_thread): Don't clear thread inferior resources here.
	(delete_thread_1): Do it here instead.  And do it before removing
	the thread from the threads list.  Tag the thread as exited before
	clearing thread inferior resources.
@
text
@d13000 1
a13000 1
A disabled breakpoint is not forgotten, but has no effect until reenabled."),
d13009 1
a13009 1
A disabled breakpoint is not forgotten, but has no effect until reenabled."));
d13015 1
a13015 1
A disabled breakpoint is not forgotten, but has no effect until reenabled.\n\
@


1.582
log
@2011-05-27  Pedro Alves  <pedro@@codesourcery.com>

	* defs.h (struct continuation, continuation_ftype)
	(continuation_free_arg_ftype, add_continuation)
	(do_all_continuations, do_all_continuations_thread)
	(discard_all_continuations, discard_all_continuations_thread)
	(add_intermediate_continuation, do_all_intermediate_continuations)
	(do_all_intermediate_continuations_thread)
	(discard_all_intermediate_continuations)
	(discard_all_intermediate_continuations_thread)
	(add_inferior_continuation, do_all_inferior_continuations)
	(discard_all_inferior_continuations): Move to ...
	* continuations.h: ... this new file.
	* breakpoint.c, continuations.c, event-top.c, inf-loop.c,
	infcmd.c, inferior.c, infrun.c, interps.c: Include
	continuations.h.
@
text
@d9511 1
a9511 1
until_break_command_continuation (void *arg)
@


1.581
log
@2011-05-26  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* breakpoint.h (enum bptype) <bp_hp_step_resume>: New.
	(enum bpstat_what_main_action): Move BPSTAT_WHAT_STEP_RESUME
	before BPSTAT_WHAT_STOP_SILENT.  Add BPSTAT_WHAT_HP_STEP_RESUME
	at the end.
	* breakpoint.c (update_breakpoints_after_exec): Also delete hp
	step-resume breakpoints.
	(print_it_typical): Handle bp_hp_step_resume.
	(bpstat_what): Ditto.
	(bptype_string): Ditto.
	(print_one_breakpoint_location): Ditto.
	(allocate_bp_location): Ditto.
	(mention): Ditto.
	(breakpoint_re_set_one): Ditto.
	* infrun.c (handle_inferior_event): Adjust.  Split
	BPSTAT_WHAT_STEP_RESUME handling in BPSTAT_WHAT_STEP_RESUME and
	BPSTAT_WHAT_HP_STEP_RESUME.
	(insert_step_resume_breakpoint_at_sal): Rename to ...
	(insert_step_resume_breakpoint_at_sal_1): ... this.  Add bptype
	parameter.  Handle it.
	(insert_step_resume_breakpoint_at_sal): Reimplement on top of
	insert_step_resume_breakpoint_at_sal_1.
	(insert_step_resume_breakpoint_at_frame): Rename to ...
	(insert_hp_step_resume_breakpoint_at_frame): ... this.  Adjust to
	set a high-priority step-resume breakpoint.
	(insert_step_resume_breakpoint_at_frame): Adjust comment.
	(insert_step_resume_breakpoint_at_caller): Ditto.

	gdb/testsuite/
	* gdb.reverse/next-reverse-bkpt-over-sr.exp: New test.
@
text
@d67 1
@


1.580
log
@2011-05-26  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* breakpoint.c (iterate_over_related_breakpoints): New.
	(do_map_delete_breakpoint): New.
	(delete_command): Pass do_map_delete_breakpoint to
	map_breakpoint_numbers.
	(do_disable_breakpoint): New.
	(do_map_disable_breakpoint): Iterate over the breakpoint's related
	breakpoints.
	(do_enable_breakpoint): Rename to ...
	(enable_breakpoint_disp): ... this.
	(enable_breakpoint): Adjust.
	(do_enable_breakpoint): New.
	(enable_once_breakpoint): Delete.
	(do_map_enable_breakpoint): New.
	(do_map_enable_once_breakpoint): New.
	(enable_once_command, enable_delete_command)
	(delete_trace_command): Iterate over the breakpoint's related
	breakpoints.
@
text
@d2418 1
a2418 1
    if (b->type == bp_step_resume)
d3506 1
d4493 9
d4770 1
d4906 1
d5716 1
d7243 1
d11476 1
@


1.579
log
@2011-05-24  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* breakpoint.c (watchpoint_check): If the watchpoint went out of
	scope, clear its command list.
	(map_breakpoint_numbers): Don't walk the related breakpoints list
	of each breakpoint.

	gdb/testsuite/
	* gdb.base/commands.exp (watchpoint_command_test): Check that the
	watchpoint's command list didn't execute when the watchpoint went
	out of scope.
@
text
@d179 1
a179 1
static void do_enable_breakpoint (struct breakpoint *, enum bpdisp);
d10815 43
d10862 1
a10862 1
do_delete_breakpoint (struct breakpoint *b, void *ignore)
d10864 1
a10864 1
  delete_breakpoint (b);
d10898 1
a10898 1
    map_breakpoint_numbers (arg, do_delete_breakpoint, NULL);
d11718 8
d11732 1
a11732 1
  disable_breakpoint (b);
d11764 1
a11764 1
do_enable_breakpoint (struct breakpoint *bpt, enum bpdisp disposition)
d11825 7
a11831 1
  do_enable_breakpoint (bpt, bpt->disposition);
d11840 1
a11840 1
  enable_breakpoint (b);
d11876 9
a11884 1
enable_once_breakpoint (struct breakpoint *bpt, void *ignore)
d11886 3
a11888 1
  do_enable_breakpoint (bpt, disp_disable);
d11894 1
a11894 1
  map_breakpoint_numbers (args, enable_once_breakpoint, NULL);
d11898 1
a11898 1
enable_delete_breakpoint (struct breakpoint *bpt, void *ignore)
d11900 3
a11902 1
  do_enable_breakpoint (bpt, disp_del);
d11908 1
a11908 1
  map_breakpoint_numbers (args, enable_delete_breakpoint, NULL);
d12434 1
a12434 1
    map_breakpoint_numbers (arg, do_delete_breakpoint, NULL);
@


1.578
log
@	* breakpont.c (remove_hw_watchpoints): Remove unused function.
	* breakpoint.h remove_hw_watchpoints(): Remove prototype.
@
text
@d3869 2
a11589 2
		struct breakpoint *related_breakpoint;

d11591 1
a11591 16
		related_breakpoint = b;
		do
		  {
		    struct breakpoint *next_related_b;

		    /* FUNCTION can be also delete_breakpoint.  */
		    next_related_b = related_breakpoint->related_breakpoint;
		    function (related_breakpoint, data);

		    /* For delete_breakpoint of the last entry of the ring we
		       were traversing we would never get back to B.  */
		    if (next_related_b == related_breakpoint)
		      break;
		    related_breakpoint = next_related_b;
		  }
		while (related_breakpoint != b);
@


1.577
log
@2011-05-19  Matt Rice  <ratmice@@gmail.com>

        * breakpoint.c (bpstat_do_actions_1): Call prevent_dont_repeat.
@
text
@a2018 14
remove_hw_watchpoints (void)
{
  struct bp_location *bl, **blp_tmp;
  int val = 0;

  ALL_BP_LOCATIONS (bl, blp_tmp)
  {
    if (bl->inserted && bl->loc_type == bp_loc_hardware_watchpoint)
      val |= remove_breakpoint (bl, mark_uninserted);
  }
  return val;
}

int
@


1.576
log
@Add support for enabling and disabling tracepoints while a trace
experiment is still running.

gdb/
	* breakpoint.c (disable_breakpoint): Disable all locations
	associated with a tracepoint on target if a trace experiment is
	running.
	(disable_command): Disable a specific tracepoint location on target if
	a trace	experiment is running.
	(do_enable_breakpoint): Enable all locations associated with a
	tracepoint on target if a trace experiment is running.
	(enable_command) Enable a specific tracepoint location on target if a
	trace experiment is running.
	* target.c (update_current_target): Add INHERIT and de_fault clauses for
	to_supports_enable_disable_tracepoint, to_enable_tracepoint and
	to_disable_tracepoint.
	* target.h: Add declaration of struct bp_location.
	(struct target_ops): Add new functions
	to_supports_enable_disable_tracepoint, to_enable_tracepoint and
	to_disable_tracepoint to target operations.
	(target_supports_enable_disable_tracepoint): New macro.
	(target_enable_tracepoint): New macro.
	(target_disable_tracepoint): New macro.
	* remote.c (struct remote_state): Add new field.
	(remote_enable_disable_tracepoint_feature): New.
	(remote_protocol_features): Add new entry.
	(remote_supports_enable_disable_tracepoint): New.
	(remote_enable_tracepoint): New.
	(remote_disable_tracepoint): New.
	(init_remote_ops): Add remote_enable_tracepoint,
	remote_disable_tracepoint and remote_supports_enable_disable_tracepoint
	to remote operations.
	* tracepoint.c (start_tracing): Allow tracing to start without any
	tracepoints enabled with just a warning if they can be re-enabled
	later.
	* NEWS: Add news item for the new behaviour of the enable and disable
	GDB commands when applied to tracepoints.
	Add news items for the new remote packets QTEnable and QTDisable.

gdb/doc/
	* gdb.texinfo: Document change in the behaviour of the enable and
	disable GDB commands when applied to tracepoints.
	Document the EnableDisableTracepoints remote stub feature.
	Document QTEnable and QTDisable in the list of tracepoint packets.

gdb/gdbserver/
	* server.c (handle_query): Add EnableDisableTracepoints to the list
	of supported features.
	* tracepoint.c (clear_installed_tracepoints): Uninstall	disabled
	tracepoints.
	(cmd_qtenable_disable): New.
	(cmd_qtstart): Install tracepoints even if disabled.
	(handle_tracepoint_general_set): Add call to cmd_qtenable_disable on
	receiving a QTEnable or QTDisable packet.
	(gdb_collect): Skip data collection if fast tracepoint is disabled.
	(ust_marker_to_static_tracepoint): Do not ignore disabled static
	tracepoints.
	(gdb_probe): Skip data collection if static tracepoint is disabled.
@
text
@d3223 2
@


1.575
log
@2011-05-06  Sergio Durigan Junior  <sergiodj@@linux.vnet.ibm.com>
	    Thiago Jung Bauermann  <bauerman@@br.ibm.com>

	Implement support for PowerPC BookE masked watchpoints.

gdb/
	* NEWS: Mention masked watchpoint support.  Create "Changed commands"
	section.
	* breakpoint.h (struct breakpoint_ops) <works_in_software_mode>: New
	method.  Initialize to NULL in all existing breakpoint_ops instances.
	(struct breakpoint) <hw_wp_mask>: New field.
	* breakpoint.c (is_masked_watchpoint): Add prototype.
	(update_watchpoint): Don't set b->val for masked watchpoints.  Call
	breakpoint's breakpoint_ops.works_in_software_mode if available.
	(watchpoints_triggered): Handle the case of a hardware masked
	watchpoint trigger.
	(watchpoint_check): Likewise.
	(works_in_software_mode_watchpoint): New function.
	(insert_masked_watchpoint, remove_masked_watchpoint)
	(resources_needed_masked_watchpoint)
	(works_in_software_mode_masked_watchpoint, print_it_masked_watchpoint)
	(print_one_detail_masked_watchpoint, print_mention_masked_watchpoint)
	(print_recreate_masked_watchpoint, is_masked_watchpoint): New
	functions.
	(masked_watchpoint_breakpoint_ops): New structure.
	(watch_command_1): Check for the existence of the `mask' parameter.
	Set b->ops according to the type of hardware watchpoint being created.
	* ppc-linux-nat.c (ppc_linux_insert_mask_watchpoint)
	(ppc_linux_remove_mask_watchpoint)
	(ppc_linux_masked_watch_num_registers): New functions.
	(_initialize_ppc_linux_nat): Initialize to_insert_mask_watchpoint,
	to_remove_mask_watchpoint and to_masked_watch_num_registers.
	* target.c (update_current_target): Mention to_insert_mask_watchpoint,
	to_remove_mask_watchpoint, and to_masked_watch_num_registers.
	(target_insert_mask_watchpoint, target_remove_mask_watchpoint)
	(target_masked_watch_num_registers): New functions.
	* target.h (struct target_ops) <to_insert_mask_watchpoint>,
	<to_remove_mask_watchpoint>, <to_masked_watch_num_registers>: New
	methods.
	(target_insert_mask_watchpoint, target_remove_mask_watchpoint)
	(target_masked_watch_num_registers): Add prototypes.

gdb/doc/
	* gdb.texinfo (Set Watchpoints): Document mask parameter.
	(PowerPC Embedded): Mention support of masked watchpoints.
@
text
@d11688 9
d11726 7
a11732 1
	loc->enabled = 0;
d11780 10
d11832 7
a11838 1
	loc->enabled = 1;
@


1.574
log
@	Demote to sw watchpoint only in update_watchpoint.
	* breakpoint.c (update_watchpoint): Change between software and
	hardware watchpoint for all kinds of watchpoints, not just
	read/write ones.  Determine b->exact value here instead of
	in watch_command_1.  Error out if there are not enough resources
	for a read or access hardware watchpoint.
	(watch_command_1): Remove logic of checking whether there are
	enough resources available, since update_watchpoint will do that
	work now.  Don't set b->exact here.  Catch exceptions thrown by
	update_watchpoint and delete the watchpoint.
	(can_use_hardware_watchpoint): Remove exact_watchpoints argument.
	Use target_exact_watchpoints instead.
	(delete_breakpoint): Notify observers only if deleted watchpoint
	has a breakpoint number assigned to it.
@
text
@d227 2
d1350 4
a1353 2
	 happens, the code that reports it updates b->val directly.  */
      if (!b->val_valid)
d1442 6
a1447 2
		  if (target_resources_ok == 0
		      && b->type != bp_hardware_watchpoint)
d1450 3
a1452 4
		  else if (target_resources_ok < 0
		      && b->type != bp_hardware_watchpoint)
		    error (_("Target can only support one kind "
			     "of HW watchpoint at a time."));
d1457 2
a1458 1
	  else if (b->type != bp_hardware_watchpoint)
d3705 21
a3725 9
	  /* Exact match not required.  Within range is
	     sufficient.  */
	  if (target_watchpoint_addr_within_range (&current_target,
						   addr, loc->address,
						   loc->length))
	    {
	      b->watchpoint_triggered = watch_triggered_yes;
	      break;
	    }
d3822 1
a3822 1
      struct value *mark = value_mark ();
d3825 7
d6333 1
d6432 1
d6720 1
d6878 1
d8504 1
d8812 9
d8829 1
d8837 186
d9038 2
a9039 2
  char *tok, *id_tok_start, *end_tok;
  int toklen;
d9045 4
d9053 9
a9061 1
      toklen = strlen (arg); /* Size of argument list.  */
d9063 47
a9109 2
      /* Points tok to the end of the argument list.  */
      tok = arg + toklen - 1;
d9111 13
a9123 26
      /* Go backwards in the parameters list.  Skip the last
         parameter.  If we're expecting a 'thread <thread_num>'
         parameter, this should be the thread identifier.  */
      while (tok > arg && (*tok == ' ' || *tok == '\t'))
        tok--;
      while (tok > arg && (*tok != ' ' && *tok != '\t'))
        tok--;

      /* Points end_tok to the beginning of the last token.  */
      id_tok_start = tok + 1;

      /* Go backwards in the parameters list.  Skip one more
         parameter.  If we're expecting a 'thread <thread_num>'
         parameter, we should reach a "thread" token.  */
      while (tok > arg && (*tok == ' ' || *tok == '\t'))
        tok--;

      end_tok = tok;

      while (tok > arg && (*tok != ' ' && *tok != '\t'))
        tok--;

      /* Move the pointer forward to skip the whitespace and
         calculate the length of the token.  */
      tok++;
      toklen = end_tok - tok;
d9125 4
a9128 24
      if (toklen >= 1 && strncmp (tok, "thread", toklen) == 0)
        {
          /* At this point we've found a "thread" token, which means
             the user is trying to set a watchpoint that triggers
             only in a specific thread.  */
          char *endp;

          /* Extract the thread ID from the next token.  */
          thread = strtol (id_tok_start, &endp, 0);

          /* Check if the user provided a valid numeric value for the
             thread ID.  */
          if (*endp != ' ' && *endp != '\t' && *endp != '\0')
            error (_("Invalid thread ID specification %s."), id_tok_start);

          /* Check if the thread actually exists.  */
          if (!valid_thread_id (thread))
            error (_("Unknown thread %d."), thread);

          /* Truncate the string and get rid of the thread <thread_num>
             parameter before the parameter list is parsed by the
             evaluate_expression() function.  */
          *tok = '\0';
        }
d9159 2
d9165 10
d9271 12
a9282 3
  b->val = val;
  b->val_valid = 1;
  b->ops = &watchpoint_breakpoint_ops;
d9819 1
@


1.573
log
@gdb/
	Fix false GCC warning.
	* breakpoint.c (do_enable_breakpoint): Initialize orig_enable_state.
@
text
@d104 1
a104 1
static int can_use_hardware_watchpoint (struct value *, int);
d1407 1
a1407 2
      if ((b->type == bp_watchpoint || b->type == bp_hardware_watchpoint)
	  && reparse)
d1413 1
a1413 1
	  reg_cnt = can_use_hardware_watchpoint (val_chain, b->exact);
d1419 4
d1430 2
a1431 4
	      b->type = bp_hardware_watchpoint;

	      i = hw_watchpoint_used_count (bp_hardware_watchpoint,
					    &other_type_used);
d1433 1
d1435 1
a1435 1
		    (bp_hardware_watchpoint, i, other_type_used);
d1437 12
a1448 1
		b->type = bp_watchpoint;
d1450 3
d8802 1
a8813 1
  int i, other_type_used, target_resources_ok = 0;
a8814 1
  int reg_cnt = 0;
a8943 22
  reg_cnt = can_use_hardware_watchpoint (val, target_exact_watchpoints);
  if (reg_cnt == 0 && bp_type != bp_hardware_watchpoint)
    error (_("Expression cannot be implemented with read/access watchpoint."));
  if (reg_cnt != 0)
    {
      i = hw_watchpoint_used_count (bp_type, &other_type_used);
      target_resources_ok = 
	target_can_use_hardware_watchpoint (bp_type, i + reg_cnt,
					    other_type_used);
      if (target_resources_ok == 0 && bp_type != bp_hardware_watchpoint)
	error (_("Target does not support this type of hardware watchpoint."));

      if (target_resources_ok < 0 && bp_type != bp_hardware_watchpoint)
	error (_("Target can only support one kind "
		 "of HW watchpoint at a time."));
    }

  /* Change the type of breakpoint to an ordinary watchpoint if a
     hardware watchpoint could not be set.  */
  if (!reg_cnt || target_resources_ok <= 0)
    bp_type = bp_watchpoint;

a8980 1
  set_breakpoint_number (internal, b);
a9010 4
  /* Use an exact watchpoint when there's only one memory region to be
     watched, and only one debug register is needed to watch it.  */
  b->exact = target_exact_watchpoints && reg_cnt == 1;

d9038 13
a9050 3
  /* Finally update the new watchpoint.  This creates the locations
     that should be inserted.  */
  update_watchpoint (b, 1);
d9053 1
a9053 1
       notify observers.  */
a9061 4
   If EXACT_WATCHPOINTS is 1, then consider that only the address of
   the start of the watched region will be monitored (i.e., all accesses
   will be aligned).  This uses less debug registers on some targets.

d9065 1
a9065 1
can_use_hardware_watchpoint (struct value *v, int exact_watchpoints)
d9121 1
a9121 1
		  len = (exact_watchpoints
d10480 6
a10485 1
  observer_notify_breakpoint_deleted (bpt);
@


1.572
log
@	* breakpoint.c (update_watchpoint): Move code to change
	the enable state of breakpoint from here ...
	(do_enable_breakpoint): ... to here.
@
text
@d11471 2
a11472 1
      enum enable_state orig_enable_state;
@


1.571
log
@	* mi/mi-parse.c (mi_parse): Remove incorrect sizeof.
	(mi_parse): Likewise.
	* breakpoint.c (break_range_command): Use sizeof char*, not
	char**.
	(create_breakpoint): Likewise.
	(parse_breakpoint_sals): Likewise.
@
text
@a1418 1
	      enum enable_state orig_enable_state;
a1428 6
	      /* hw_watchpoint_used_count ignores disabled watchpoints,
		 and b might be disabled if we're being called from
		 do_enable_breakpoint.  */
	      orig_enable_state = b->enable_state;
	      b->enable_state = bp_enabled;

a1431 2
	      b->enable_state = orig_enable_state;

d11471 1
d11476 2
d11482 1
@


1.570
log
@2011-04-27  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* breakpoint.c (user_settable_breakpoint): Delete.
	(user_breakpoint_p): Remove check on user_settable_breakpoint.
	(delete_command): Check user_breakpoint_p instead of looking at
	the breakpoint's type.
	(disable_command): Ditto.
	(enable_command): Ditto.
	(delete_trace_command): Use user_breakpoint_p instead of looking
	at the breakpoint number directly.  When checking if there are
	user visible tracepoints, in order to know whether to ask the user
	for confirmation, check whether the breakpoint is actually a
	tracepoint.
@
text
@d7701 1
a7701 1
    canonical->canonical = xcalloc (sals->nelts, sizeof (char **));
d7920 1
a7920 1
      canonical.canonical = xcalloc (sals.nelts, sizeof (char **));
d8576 1
a8576 1
    canonical_end.canonical = xcalloc (1, sizeof (char **));
@


1.569
log
@	MI breakpoint notifications.

        * annotate.c (breakpoint_changed): Adjust parameter type.
        * breakpoint.c (set_breakpoint_condition): Adjust to change
        in breakpoint_modified type.
        (breakpoint_set_commands): Likewise.
        (do_map_commands_command): Likewise.
        (bpstat_check_breakpoint_conditions): Notify that breakpoint has
        changed after bumping hit count.
        (bpstat_stop_status): Likewise.
        (print_one_breakpoint_location): Don't wrap in tuple here.
        (print_one_breakpoint): Always print individual locations.
        For locations, use unnamed tuple.
        (disable_breakpoints_in_unloaded_shlib): Notify that breakpoint
        has changed.
        (create_catchpoint, create_syscall_event_catchpoint): Call
        breakpoint_created obsever.
        (mention): Don't call breakpoint_created observer.
        (create_breakpoint_sal): Call breakpoint_created observer.
        (create_breakpoint, watch_command_1): Likewise.
        (create_ada_exception_breakpoint): Likewise.
        (delete_breakpoint): Call breakpoint_deleted breakpoint.
        (locations_are_equal): New.
        (update_breakpoint_locations): If locations were changed, notify.
        (set_ignore_count, disable_breakpoint, do_enable_breakpoint):
        Call breakpoint_modified observer.

        * mi/mi-cmd-break.c (breakpoint_notify): Adjust.
        (mi_cmd_break_insert): Don't set observers for modify and delete.
        * mi/mi-interp.c (mi_suppress_breakpoint_notifications): New.
        (mi_breakpoint_created, mi_breakpoint_deleted)
        (mi_breakpoint_modified): New.
        (mi_interpreter_init): Hook the above.
        * mi/mi-main.c (mi_cmd_execute): Disable breakpoint notifications
        while -break-* commands are executing.
        * mi/mi-main.h (mi_suppress_breakpoint_notifications): New.
        * mi/mi-out.c (struct ui_out_data): New field original_buffer.
        (mi_redirect): New.
        (mi_ui_out_impl): Hook in mi_redirect.
        (mi_field_skip): True to the name, skip the field, don't output
        a field with an empty value.

        * python/py-breakpoint.c (gdbpy_breakpoint_created)
        (gdbpy_breakpoint_deleted): Adjust.
        * tui/tui-hooks.c (tui_event_create_breakpoint)
        (tui_event_delete_breakpoint, tui_event_modify_breakpoint): Adjust.
@
text
@a5161 14
/* Return non-zero if B is user settable (breakpoints, watchpoints,
   catchpoints, et.al.).  */

static int
user_settable_breakpoint (const struct breakpoint *b)
{
  return (b->type == bp_breakpoint
	  || b->type == bp_catchpoint
	  || b->type == bp_hardware_breakpoint
	  || is_tracepoint (b)
	  || is_watchpoint (b)
	  || b->type == bp_gnu_ifunc_resolver);
}

d5168 1
a5168 1
  return user_settable_breakpoint (b) && b->number > 0;
d10581 3
a10583 3
      /* Delete all breakpoints if no argument.
         Do not delete internal or call-dummy breakpoints, these have
         to be deleted with an explicit breakpoint number argument.  */
d10585 1
a10585 11
      {
	if (b->type != bp_call_dummy
	    && b->type != bp_std_terminate
	    && b->type != bp_shlib_event
	    && b->type != bp_jit_event
	    && b->type != bp_thread_event
	    && b->type != bp_overlay_event
	    && b->type != bp_longjmp_master
	    && b->type != bp_std_terminate_master
	    && b->type != bp_exception_master
	    && b->number >= 0)
a10589 1
      }
d10596 1
a10596 11
	  {
	    if (b->type != bp_call_dummy
		&& b->type != bp_std_terminate
		&& b->type != bp_shlib_event
		&& b->type != bp_thread_event
		&& b->type != bp_jit_event
		&& b->type != bp_overlay_event
		&& b->type != bp_longjmp_master
		&& b->type != bp_std_terminate_master
		&& b->type != bp_exception_master
		&& b->number >= 0)
a10597 1
	  }
d11441 3
a11443 1
  struct breakpoint *bpt;
d11445 4
a11448 23
  if (args == 0)
    ALL_BREAKPOINTS (bpt)
      switch (bpt->type)
      {
      case bp_none:
	warning (_("attempted to disable apparently deleted breakpoint #%d?"),
		 bpt->number);
	break;
      case bp_breakpoint:
      case bp_tracepoint:
      case bp_fast_tracepoint:
      case bp_static_tracepoint:
      case bp_catchpoint:
      case bp_hardware_breakpoint:
      case bp_watchpoint:
      case bp_hardware_watchpoint:
      case bp_read_watchpoint:
      case bp_access_watchpoint:
	disable_breakpoint (bpt);
	break;
      default:
	break;
      }
d11526 3
a11528 1
  struct breakpoint *bpt;
d11530 4
a11533 23
  if (args == 0)
    ALL_BREAKPOINTS (bpt)
      switch (bpt->type)
      {
      case bp_none:
	warning (_("attempted to enable apparently deleted breakpoint #%d?"),
		 bpt->number);
	break;
      case bp_breakpoint:
      case bp_tracepoint:
      case bp_fast_tracepoint:
      case bp_static_tracepoint:
      case bp_catchpoint:
      case bp_hardware_breakpoint:
      case bp_watchpoint:
      case bp_hardware_watchpoint:
      case bp_read_watchpoint:
      case bp_access_watchpoint:
	enable_breakpoint (bpt);
	break;
      default:
	break;
      }
d12076 1
a12076 2
      {
	if (b->number >= 0)
a12080 1
      }
d12087 1
a12087 3
	  {
	    if (is_tracepoint (b)
		&& b->number >= 0)
a12088 1
	  }
@


1.568
log
@gdb
	* windows-tdep.c (windows_xfer_shared_library):
	* windows-nat.c (get_module_name, windows_make_so):
	* v850-tdep.c (v850_handle_pushm):
	* utils.c (null_cleanup, gdb_realpath):
	* ui-out.c (get_next_header):
	* tracepoint.c (clear_traceframe_info):
	* symtab.c (lookup_symtab):
	* serial.h (struct serial_ops):
	* mipsread.c (read_alphacoff_dynamic_symtab):
	* infcmd.c (print_return_value):
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address):
	* f-exp.y (parse_number):
	* exceptions.c (catch_exceptions):
	* dummy-frame.c (dummy_frame_this_id):
	* defs.h (struct cleanup):
	* breakpoint.c (disable_breakpoints_in_unloaded_shlib):
	* arm-tdep.c (arm_push_dummy_call):
	* amd64-tdep.h (amd64_collect_xsave):
	* amd64-tdep.c (amd64_collect_xsave):
	* alpha-tdep.c (alpha_heuristic_frame_unwind_cache):
	* README (typing): Remove duplicate words.
	* cli/cli-decode.c (lookup_cmd_composition): Add comma.
	* infrun.c (siginfo_value_read): Fix typo.
	* solib-frv.c (frv_fdpic_find_global_pointer): Likewise.
	* top.c (source_line_number): Add comma.
gdb/doc
	* gdbint.texinfo (Register Information Functions): Remove
	duplicate "the".
	* gdb.texinfo (Emacs): Remove duplicate "to".
	(GDB/MI Variable Objects): Remove duplicate "the".
	(General Query Packets): Likewise.
gdb/testsuite
	* gdb.mi/mi-nsmoribund.exp:
	* gdb.hp/gdb.objdbg/objdbg01.exp:
	* gdb.base/structs.exp (test_struct_returns):
	* gdb.base/call-sc.exp (test_scalar_returns):
	* gdb.base/bigcore.exp: Remove duplicate words.
gdb/gdbserver
	* win32-low.c (handle_load_dll): Remove duplicate "the".
@
text
@d629 1
a629 1
  observer_notify_breakpoint_modified (b->number);
d794 1
a794 1
  observer_notify_breakpoint_modified (b->number);
d808 1
a808 1
    observer_notify_breakpoint_modified (b->number);
d821 1
a821 1
    observer_notify_breakpoint_modified (b->number);
d834 1
a834 1
    observer_notify_breakpoint_modified (b->number);
d911 1
a911 1
      observer_notify_breakpoint_modified (b->number);
d1675 1
d4177 1
d4306 1
a4773 1
  struct cleanup *bkpt_chain;
a4791 1
  bkpt_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "bkpt");
a5055 2
	
  do_cleanups (bkpt_chain);
d5063 4
d5068 1
d5084 1
a5084 2
	  && (b->loc->next || !b->loc->enabled)
	  && !ui_out_is_mi_like_p (uiout)) 
d5088 1
d5090 6
a5095 1
	    print_one_breakpoint_location (b, loc, n, last_loc, allflag);
d6203 4
d6763 1
d6875 1
a7111 6
  /* FIXME: This is misplaced; mention() is called by things (like
     hitting a watchpoint) other than breakpoint creation.  It should
     be possible to clean this up and at the same time replace the
     random calls to breakpoint_changed with this hook.  */
  observer_notify_breakpoint_created (b->number);

d7466 3
a7468 5
  if (internal)
    /* Do not mention breakpoints with a negative number, but do
       notify observers.  */
    observer_notify_breakpoint_created (b->number);
  else
d7470 1
d8133 1
a8133 1
      if (internal)
d8136 2
a8137 3
        observer_notify_breakpoint_created (b->number);
      else
        mention (b);
d8641 1
d9076 2
a9077 2
  if (internal)
    /* Do not mention breakpoints with a negative number, but do
d9079 1
a9079 2
    observer_notify_breakpoint_created (b->number);
  else
d9081 2
d9702 1
d10509 1
a10509 1
  observer_notify_breakpoint_deleted (bpt->number);
d10820 27
d10961 3
d11307 1
a11307 1
      observer_notify_breakpoint_modified (b->number);
d11462 1
a11462 1
  observer_notify_breakpoint_modified (bpt->number);
d11553 1
a11553 1
  observer_notify_breakpoint_modified (bpt->number);
@


1.567
log
@	* breakpoint.c (print_exception_catchpoint): Rename to ...
	(print_it_exception_catchpoint): ... this.
	(gnu_v3_exception_catchpoint_ops): Update with new name
	for print_it_exception_catchpoint.
@
text
@d6157 1
a6157 1
/* Disable any breakpoints that are in in an unloaded shared library.
@


1.566
log
@gdb/
	* breakpoint.c (watch_command_1): Remove colon from exp_string.

gdb/testsuite/
	* gdb.base/watchpoint.exp (test_inaccessible_watchpoint): Don't
	expect a colon in watch -location output.
@
text
@d9475 1
a9475 1
print_exception_catchpoint (struct breakpoint *b)
d9566 1
a9566 1
  print_exception_catchpoint,
@


1.565
log
@	* breakpoint.c (save_breakpoints): Verify whether
	breakpoint_ops.print_recreate is defined before calling it.
@
text
@d9022 1
a9022 1
      b->exp_string = xstrprintf ("-location: %.*s",
@


1.564
log
@	* tracepoint.c (scope_info): Update.
	* symtab.c (decode_line_spec): Update.
	* python/python.c (gdbpy_decode_line): Update.
	* linespec.h (decode_line_1): Update.
	* linespec.c (decode_line_1): Remove 'not_found_ptr' argument.
	(decode_compound, find_method, symtab_from_filename)
	(decode_variable): Likewise.
	* cli/cli-cmds.c (edit_command): Update.
	(list_command): Update.
	* breakpoint.c (parse_breakpoint_sals): Remove 'not_found_ptr'
	argument.
	(create_breakpoint): Update.
	(until_break_command): Update.
	(addr_string_to_sals): Update.
	(decode_line_spec_1): Update.
@
text
@d12340 1
a12340 1
    if (tp->ops != NULL)
@


1.563
log
@	* breakpoint.c (struct captured_parse_breakpoint_args): Remove.
	(do_captured_parse_breakpoint): Remove.
	(create_breakpoint): `e' is now volatile.  Remove `parse_args'.
	Use TRY_CATCH directly.
@
text
@d7648 1
a7648 2
		       struct linespec_result *canonical,
		       int *not_found_ptr)
d7700 1
a7700 2
			       default_breakpoint_line, canonical, 
			       not_found_ptr);
d7703 1
a7703 1
		               canonical, not_found_ptr);
a7911 1
  int not_found = 0;
d7934 1
a7934 1
      parse_breakpoint_sals (&arg, &sals, &canonical, &not_found);
d8545 1
a8545 1
  parse_breakpoint_sals (&arg, &sals_start, &canonical_start, NULL);
d8579 1
a8579 1
			    &canonical_end, NULL);
d9282 1
a9282 1
			  default_breakpoint_line, NULL, NULL);
d9284 1
a9284 1
    sals = decode_line_1 (&arg, 1, (struct symtab *) NULL, 0, NULL, NULL);
d10934 1
a10934 1
  int marker_spec, not_found;
d10955 1
a10955 2
	sals = decode_line_1 (&s, 1, (struct symtab *) NULL, 0,
			      NULL, &not_found);
d10967 1
a10967 1
      if (not_found 
d10986 1
a10986 1
  if (!not_found)
d11008 2
d11011 2
a11012 2

  *found = !not_found;
d11651 1
a11651 1
			  NULL, NULL);
d11654 1
a11654 1
			  (struct symtab *) NULL, 0, NULL, NULL);
@


1.562
log
@improve Ada exception catchpoint MI notification

This rewrites the code generating the Ada exception catchpoint hit
notification for both the GDB/MI case as well as the non-MI case,
by using the relevant ui_out_* functions to generate the output.
the MI notifications for Ada exception catchpoints now include
the stop reason, and the breakpoint "disp", much like other breakpoint
events do.  It also introduces a new field "exception-name" for
exception catchpoints (excluding "failed assertion catchpoints,
where we just want to know that it was a failed assertion).

gdb/ChangeLog:

        * breakpoint.h (bpdisp_text): Add declaration.
        * breakpoint.c (bpdisp_text): Make non-static.
        * ada-lang.c: #include "mi/mi-common.h".
        (print_it_exception): Rewrite to improve GDB/MI output.

gdb/doc/ChangeLog:

        * gdb.texinfo (GDB/MI Ada Exception Information): Document
        the "exception-name" field in the *stopped async record.

gdb/testsuite/ChangeLog:

        * gdb.ada/mi_catch_ex: New testcase.
@
text
@a6068 8
struct captured_parse_breakpoint_args
  {
    char **arg_p;
    struct symtabs_and_lines *sals_p;
    struct linespec_result *canonical_p;
    int *not_found_ptr;
  };

a7768 9
static void
do_captured_parse_breakpoint (struct ui_out *ui, void *data)
{
  struct captured_parse_breakpoint_args *args = data;
  
  parse_breakpoint_sals (args->arg_p, args->sals_p, args->canonical_p, 
		         args->not_found_ptr);
}

d7904 1
a7904 1
  struct gdb_exception e;
a7911 1
  struct captured_parse_breakpoint_args parse_args;
a7921 5
  parse_args.arg_p = &arg;
  parse_args.sals_p = &sals;
  parse_args.canonical_p = &canonical;
  parse_args.not_found_ptr = &not_found;

d7935 4
a7938 2
  e = catch_exception (uiout, do_captured_parse_breakpoint, 
		       &parse_args, RETURN_MASK_ALL);
@


1.561
log
@	* breakpoint.c (break_range_command): Fix typo in comment.
@
text
@d254 1
a254 1
static const char *
@


1.561.2.1
log
@	* breakpoint.c (save_breakpoints): Verify whether
	breakpoint_ops.print_recreate is defined before calling it.
@
text
@d12363 1
a12363 1
    if (tp->ops != NULL && tp->ops->print_recreate != NULL)
@


1.561.2.2
log
@gdb/
	* breakpoint.c (watch_command_1): Remove colon from exp_string.

gdb/testsuite/
	* gdb.base/watchpoint.exp (test_inaccessible_watchpoint): Don't
	expect a colon in watch -location output.
@
text
@d9046 1
a9046 1
      b->exp_string = xstrprintf ("-location %.*s",
@


1.561.2.3
log
@improve Ada exception catchpoint MI notification

This rewrites the code generating the Ada exception catchpoint hit
notification for both the GDB/MI case as well as the non-MI case,
by using the relevant ui_out_* functions to generate the output.
the MI notifications for Ada exception catchpoints now include
the stop reason, and the breakpoint "disp", much like other breakpoint
events do.  It also introduces a new field "exception-name" for
exception catchpoints (excluding "failed assertion catchpoints,
where we just want to know that it was a failed assertion).

gdb/ChangeLog:

        * breakpoint.h (bpdisp_text): Add declaration.
        * breakpoint.c (bpdisp_text): Make non-static.
        * ada-lang.c: #include "mi/mi-common.h".
        (print_it_exception): Rewrite to improve GDB/MI output.

gdb/doc/ChangeLog:

        * gdb.texinfo (GDB/MI Ada Exception Information): Document
        the "exception-name" field in the *stopped async record.

gdb/testsuite/ChangeLog:

        * gdb.ada/mi_catch_ex: New testcase.
@
text
@d254 1
a254 1
const char *
@


1.561.2.4
log
@commit 7f71565092a430e0a7509868b7279497db6f7cbe
Author: Tom Tromey <tromey@@redhat.com>
Date:   Mon Apr 4 17:41:05 2011 +0000

gdb/
	* tracepoint.c (scope_info): Update.
	* symtab.c (decode_line_spec): Update.
	* python/python.c (gdbpy_decode_line): Update.
	* linespec.h (decode_line_1): Update.
	* linespec.c (decode_line_1): Remove 'not_found_ptr' argument.
	(decode_compound, find_method, symtab_from_filename)
	(decode_variable): Likewise.
	* cli/cli-cmds.c (edit_command): Update.
	(list_command): Update.
	* breakpoint.c (parse_breakpoint_sals): Remove 'not_found_ptr'
	argument.
	(create_breakpoint): Update.
	(until_break_command): Update.
	(addr_string_to_sals): Update.
	(decode_line_spec_1): Update.
@
text
@d6074 1
d7656 2
a7657 1
		       struct linespec_result *canonical)
d7709 2
a7710 1
			       default_breakpoint_line, canonical);
d7713 1
a7713 1
		               canonical);
d7782 2
a7783 1
  parse_breakpoint_sals (args->arg_p, args->sals_p, args->canonical_p);
d7932 1
d7943 1
d8569 1
a8569 1
  parse_breakpoint_sals (&arg, &sals_start, &canonical_start);
d8603 1
a8603 1
			    &canonical_end);
d9306 1
a9306 1
			  default_breakpoint_line, NULL);
d9308 1
a9308 1
    sals = decode_line_1 (&arg, 1, (struct symtab *) NULL, 0, NULL);
d10958 1
a10958 1
  int marker_spec;
d10979 2
a10980 1
	sals = decode_line_1 (&s, 1, (struct symtab *) NULL, 0, NULL);
d10992 1
a10992 1
      if (e.error == NOT_FOUND_ERROR
d11011 1
a11011 1
  if (e.reason == 0 || e.error != NOT_FOUND_ERROR)
d11033 1
d11035 1
a11035 4
      *found = 1;
    }
  else
    *found = 0;
d11674 1
a11674 1
			  NULL);
d11677 1
a11677 1
			  (struct symtab *) NULL, 0, NULL);
@


1.560
log
@2011-03-31  Thiago Jung Bauermann  <bauerman@@br.ibm.com>
	    Sergio Durigan Junior  <sergiodj@@linux.vnet.ibm.com>

	Implement support for PowerPC BookE ranged breakpoints.

gdb/
	* NEWS: Mention support for ranged breakpoints on embedded PowerPC.
	* breakpoint.h (struct bp_target_info) <length>: New member
	variable.
	(struct breakpoint_ops) <breakpoint_hit>: Take struct bp_location
	instead of struct breakpoint as argument, and also add ASPACE
	and BP_ADDR arguments.  Update all callers.
	(struct breakpoint_ops) <print_one_detail>: New method.
	(struct breakpoint) <addr_string_range_end>: New member variable.
	* breakpoint.c (breakpoint_location_address_match): Add function
	prototype.
	(insert_bp_location): Set bl->target_info.length.
	(breakpoint_here_p): Call breakpoint_location_address_match.
	(moribund_breakpoint_here_p): Likewise.
	(regular_breakpoint_inserted_here_p): Likewise.
	(breakpoint_thread_match): Likewise.
	(bpstat_stop_status): Likewise.
	(bpstat_check_location): Move call to
	breakpoint_ops.breakpoint_hit to the top.
	(print_one_breakpoint_location): Call
	breakpoint_ops.print_one_detail if available.
	(breakpoint_address_match_range): New function.
	(breakpoint_location_address_match): Likewise.
	(breakpoint_locations_match): Compare the length field of the
	locations too.
	(hw_breakpoint_used_count): Count resources used by all locations
	in a breakpoint, and use breakpoint_ops.resources_needed if
	available.
	(breakpoint_hit_ranged_breakpoint): New function.
	(resources_needed_ranged_breakpoint): Likewise.
	(print_it_ranged_breakpoint): Likewise.
	(print_one_ranged_breakpoint): Likewise.
	(print_one_detail_ranged_breakpoint): Likewise.
	(print_mention_ranged_breakpoint): Likewise.
	(print_recreate_ranged_breakpoint): Likewise.
	(ranged_breakpoint_ops): New structure.
	(find_breakpoint_range_end): New function.
	(break_range_command): Likewise.
	(delete_breakpoint): Free addr_string_range_end.
	(update_breakpoint_locations): Add SALS_END argument.  Update
	all callers.  Calculate breakpoint length if a non-zero SALS_END
	is given.  Call breakpoint_locations_match instead of
	breakpoint_address_match.
	(reset_breakpoint): Find SaL of the end of the range if B is a
	ranged breakpoint.
	(_initialize_breakpoint): Register break-range command.
	* defs.h (print_core_address): Add function prototype.
	* ppc-linux-nat.c (ppc_linux_ranged_break_num_registers): New
	function.
	(ppc_linux_insert_hw_breakpoint): Support ranged breakpoints.
	(ppc_linux_remove_hw_breakpoint): Likewise.
	(_initialize_ppc_linux_nat): Initialize
	to_ranged_break_num_registers.
	* target.c (update_current_target): Add comment about
	to_ranged_break_num_registers.
	(target_ranged_break_num_registers): New function.
	* target.h (struct target_ops) <to_ranged_break_num_registers>:
	New method.
	(target_ranged_break_num_registers): Add function prototype.
	* ui-out.c (ui_out_field_core_addr): Move address-printing logic to ...
	* utils.c (print_core_address): ... here.

gdb/doc/
	* gdb.texinfo (PowerPC Embedded): Document ranged breakpoints.
@
text
@d8597 1
a8597 1
  /* We call decode_line_n1 directly here instead of using
@


1.559
log
@	* breakpoint.c (addr_string_to_sals): Avoid uninitialized
	variable compiler warning.
@
text
@d134 4
d1544 1
d2807 1
a2807 1
      /* ALL_BP_LOCATIONS bp_location has bl->OWNER always non-NULL.  */
d2810 1
a2810 2
	  && breakpoint_address_match (bl->pspace->aspace, bl->address,
				       aspace, pc))
d2835 1
a2835 2
    if (breakpoint_address_match (loc->pspace->aspace, loc->address,
				  aspace,  pc))
d2859 1
a2859 2
	  && breakpoint_address_match (bl->pspace->aspace, bl->address,
				       aspace, pc))
d2976 1
a2976 2
      if (!breakpoint_address_match (bl->pspace->aspace, bl->address,
				     aspace, pc))
d3864 3
d3895 1
a3895 1
  
a3905 7
  if (b->type == bp_catchpoint)
    {
      gdb_assert (b->ops != NULL && b->ops->breakpoint_hit != NULL);
      if (!b->ops->breakpoint_hit (b))
        return 0;
    }
     
d4265 1
a4265 2
      if (breakpoint_address_match (loc->pspace->aspace, loc->address,
				    aspace, bp_addr))
d4951 1
a4951 1
  
d4953 4
a4956 1
  
d5539 33
d5594 4
a5597 2
    return breakpoint_address_match (loc1->pspace->aspace, loc1->address,
				     loc2->pspace->aspace, loc2->address);
d6238 2
a6239 1
breakpoint_hit_catch_fork (struct breakpoint *b)
d6241 1
a6241 1
  return inferior_has_forked (inferior_ptid, &b->forked_inferior_pid);
d6310 1
d6337 2
a6338 1
breakpoint_hit_catch_vfork (struct breakpoint *b)
d6340 1
a6340 1
  return inferior_has_vforked (inferior_ptid, &b->forked_inferior_pid);
d6408 1
d6498 2
a6499 1
breakpoint_hit_catch_syscall (struct breakpoint *b)
d6505 1
d6574 1
a6574 1
                         struct bp_location **last_loc)
d6695 1
d6791 2
a6792 1
breakpoint_hit_catch_exec (struct breakpoint *b)
d6794 1
a6794 1
  return inferior_has_execd (inferior_ptid, &b->exec_pathname);
d6851 1
d6875 1
d6877 1
a6877 1
  int i = 0;
d6882 9
a6890 1
      i++;
d8358 303
d8813 1
d9592 1
d10539 1
d10834 4
d10840 2
a10841 1
			     struct symtabs_and_lines sals)
a10843 1
  char *s;
d10846 3
d10869 1
d10896 7
d10928 1
a10928 2
		  if (breakpoint_address_match (e->pspace->aspace, e->address,
						l->pspace->aspace, l->address))
d11048 1
a11048 1
  struct symtabs_and_lines sals;
d11050 1
d11065 11
a11075 1
  update_breakpoint_locations (b, expanded);
d13119 17
a13135 1
  
@


1.558
log
@	* breakpoint.c (breakpoint_re_set_one): Factor out breakpoint-resetting
	code from here ...
	(re_set_breakpoint): ... to here ...
	(addr_string_to_sals): ... and here.
@
text
@d10587 1
a10587 1
  struct symtabs_and_lines sals;
@


1.557
log
@gdb/
	Support resolution of STT_GNU_IFUNC via breakpoints.
	* breakpoint.c (print_it_typical): Support bp_gnu_ifunc_resolver and
	bp_gnu_ifunc_resolver_return.
	(bpstat_what): Rename parameter to bs_head, new variable bs, adjust
	the loop.  Support bp_gnu_ifunc_resolver and
	bp_gnu_ifunc_resolver_return.  New comment after the loop.  New loop
	for bp_gnu_ifunc_resolver and bp_gnu_ifunc_resolver_return
	breakpoints.
	(bptype_string, print_one_breakpoint_location): Support
	bp_gnu_ifunc_resolver and bp_gnu_ifunc_resolver_return.
	(user_settable_breakpoint): Return true also for
	bp_gnu_ifunc_resolver.
	(allocate_bp_location): Support bp_gnu_ifunc_resolver and
	bp_gnu_ifunc_resolver_return.
	(set_breakpoint_location_function): New parameter explicit_loc,
	describe it.  Call find_pc_partial_function_gnu_ifunc with new
	variable IS_GNU_IFUNC and adjust the address for STT_GNU_IFUNC if
	EXPLICIT_LOC is not set.
	(set_raw_breakpoint): Set EXPLICIT_LOC for
	set_breakpoint_location_function.
	(clone_momentary_breakpoint): Use true for EXPLICIT_LOC of
	set_breakpoint_location_function.
	(mention): Support bp_gnu_ifunc_resolver and
	bp_gnu_ifunc_resolver_return.
	(add_location_to_breakpoint): Set EXPLICIT_LOC for
	set_breakpoint_location_function.
	(update_breakpoint_locations): Remove static.
	(breakpoint_re_set_one): Support bp_gnu_ifunc_resolver and
	bp_gnu_ifunc_resolver_return.
	* breakpoint.h (enum bptype): New fields bp_gnu_ifunc_resolver and
	bp_gnu_ifunc_resolver_return.
	(update_breakpoint_locations): New declaration.
	* elfread.c: Include gdbthread.h and regcache.h.
	(elf_gnu_ifunc_resolver_stop, elf_gnu_ifunc_resolver_return_stop): New
	functions.
	(elf_gnu_ifunc_fns): Install them.
	* minsyms.c (stub_gnu_ifunc_resolver_stop)
	(stub_gnu_ifunc_resolver_return_stop): New functions.
	(stub_gnu_ifunc_fns): Install them.
	* symtab.h (struct gnu_ifunc_fns): New fields gnu_ifunc_resolver_stop
	and gnu_ifunc_resolver_return_stop.
	(gnu_ifunc_resolver_stop, gnu_ifunc_resolver_return_stop): New.
@
text
@d10579 117
a10704 8
  int not_found = 0;
  int *not_found_ptr = &not_found;
  struct symtabs_and_lines sals = {0};
  struct symtabs_and_lines expanded = {0};
  char *s;
  struct gdb_exception e;
  struct cleanup *cleanups = make_cleanup (null_cleanup, NULL);
  int marker_spec = 0;
d10729 1
a10729 83
      input_radix = b->input_radix;
      s = b->addr_string;

      save_current_space_and_thread ();
      switch_to_program_space_and_thread (b->pspace);

      marker_spec = b->type == bp_static_tracepoint && is_marker_spec (s);

      set_language (b->language);
      TRY_CATCH (e, RETURN_MASK_ERROR)
	{
	  if (marker_spec)
	    {
	      sals = decode_static_tracepoint_spec (&s);
	      if (sals.nelts > b->static_trace_marker_id_idx)
		{
		  sals.sals[0] = sals.sals[b->static_trace_marker_id_idx];
		  sals.nelts = 1;
		}
	      else
		error (_("marker %s not found"), b->static_trace_marker_id);
	    }
	  else
	    sals = decode_line_1 (&s, 1, (struct symtab *) NULL, 0,
				  NULL, not_found_ptr);
	}
      if (e.reason < 0)
	{
	  int not_found_and_ok = 0;
	  /* For pending breakpoints, it's expected that parsing will
	     fail until the right shared library is loaded.  User has
	     already told to create pending breakpoints and don't need
	     extra messages.  If breakpoint is in bp_shlib_disabled
	     state, then user already saw the message about that
	     breakpoint being disabled, and don't want to see more
	     errors.  */
	  if (not_found 
	      && (b->condition_not_parsed 
		  || (b->loc && b->loc->shlib_disabled)
		  || b->enable_state == bp_disabled))
	    not_found_and_ok = 1;

	  if (!not_found_and_ok)
	    {
	      /* We surely don't want to warn about the same breakpoint
		 10 times.  One solution, implemented here, is disable
		 the breakpoint on error.  Another solution would be to
		 have separate 'warning emitted' flag.  Since this
		 happens only when a binary has changed, I don't know
		 which approach is better.  */
	      b->enable_state = bp_disabled;
	      throw_exception (e);
	    }
	}

      if (!not_found)
	{
	  gdb_assert (sals.nelts == 1);

	  resolve_sal_pc (&sals.sals[0]);
	  if (b->condition_not_parsed && s && s[0])
	    {
	      char *cond_string = 0;
	      int thread = -1;
	      int task = 0;

	      find_condition_and_thread (s, sals.sals[0].pc,
					 &cond_string, &thread, &task);
	      if (cond_string)
		b->cond_string = cond_string;
	      b->thread = thread;
	      b->task = task;
	      b->condition_not_parsed = 0;
	    }

	  if (b->type == bp_static_tracepoint && !marker_spec)
	    sals.sals[0] = update_static_tracepoint (b, sals.sals[0]);

	  expanded = expand_line_sal_maybe (sals.sals[0]);
	}

      make_cleanup (xfree, sals.sals);
      update_breakpoint_locations (b, expanded);
a10809 1
  do_cleanups (cleanups);
@


1.556
log
@gdb/
	Support a ring of related breakpoints.
	* breakpoint.c (watchpoint_del_at_next_stop): New, move here code from
	other functions, add gdb_assert.
	(update_watchpoint, watchpoint_check): Add gdb_assert.  Use
	watchpoint_del_at_next_stop.
	(bpstat_check_watchpoint): Use watchpoint_del_at_next_stop.
	(bpstat_stop_status): Handle ring in related_breakpoint.
	(set_raw_breakpoint_without_location): Initialize ring in
	related_breakpoint.
	(delete_breakpoint): Handle ring in related_breakpoint, use
	watchpoint_del_at_next_stop.
	(map_breakpoint_numbers): Handle ring in related_breakpoint.

gdb/testsuite/
	Support a ring of related breakpoints.
	* gdb.base/watchpoint-delete.c: New file.
	* gdb.base/watchpoint-delete.exp: New file.
@
text
@d3507 2
d4383 1
a4383 1
bpstat_what (bpstat bs)
d4391 1
d4397 1
a4397 1
  for (; bs != NULL; bs = bs->next)
d4527 10
d4545 3
d4577 17
d4751 2
d4887 2
d5164 2
a5165 1
	  || is_watchpoint (b));
d5661 2
d5769 4
a5772 1
/* Initialize loc->function_name.  */
d5774 1
a5774 1
set_breakpoint_location_function (struct bp_location *loc)
d5782 27
a5808 2
      find_pc_partial_function (loc->address, &(loc->function_name), 
				NULL, NULL);
d5883 2
a5884 1
  set_breakpoint_location_function (b->loc);
d7001 1
a7001 1
  set_breakpoint_location_function (copy->loc);
d7101 1
d7112 2
d7173 1
d7234 2
a7235 1
  set_breakpoint_location_function (loc);
d10476 1
a10476 1
static void
d10608 1
d10779 1
@


1.555
log
@	* linespec.h (struct linespec_result) <special_display>: New
	field.
	* breakpoint.h (struct breakpoint) <display_canonical>: New
	field.
	* breakpoint.c (print_breakpoint_location): Respect
	display_canonical.
	(create_breakpoint_sal): Add 'display_canonical' parameter.
	(create_breakpoints_sal): Update.
	(create_breakpoint): Update.
@
text
@d1162 19
d1240 2
d1477 1
a1477 7
      if (b->related_breakpoint)
	{
	  b->related_breakpoint->disposition = disp_del_at_next_stop;
	  b->related_breakpoint->related_breakpoint = NULL;
	  b->related_breakpoint= NULL;
	}
      b->disposition = disp_del_at_next_stop;
d3732 2
d3843 1
a3843 7
      if (b->related_breakpoint)
	{
	  b->related_breakpoint->disposition = disp_del_at_next_stop;
	  b->related_breakpoint->related_breakpoint = NULL;
	  b->related_breakpoint = NULL;
	}
      b->disposition = disp_del_at_next_stop;
d4048 1
a4048 3
	      if (b->related_breakpoint)
		b->related_breakpoint->disposition = disp_del_at_next_stop;
	      b->disposition = disp_del_at_next_stop;
d4259 1
a4259 1
	  if (b->type == bp_watchpoint_scope)
d5712 1
d10076 1
a10076 1
  if (bpt->related_breakpoint != NULL)
d10078 12
a10089 4
      gdb_assert (bpt->related_breakpoint->related_breakpoint == bpt);
      bpt->related_breakpoint->disposition = disp_del_at_next_stop;
      bpt->related_breakpoint->related_breakpoint = NULL;
      bpt->related_breakpoint = NULL;
d10870 2
a10871 1
		struct breakpoint *related_breakpoint = b->related_breakpoint;
d10873 16
a10888 3
		function (b, data);
		if (related_breakpoint)
		  function (related_breakpoint, data);
@


1.554
log
@	* symtab.c (decode_line_spec): Update.
	* linespec.c (build_canonical_line_spec): Change type of
	'canonical'.
	(decode_line_2, decode_line_1, decode_objc, decode_compound)
	(find_method, decode_all_digits, decode_dollar, decode_label)
	(symbol_found): Likewise.
	(init_linespec_result): New function.
	* breakpoint.c (struct captured_parse_breakpoint_args)
	<canonical_p>: New field, replaces addr_string_p.
	(create_breakpoints_sal): Add 'canonical' parameter, replacing
	'addr_string'.
	(parse_breakpoint_sals): Likewise.
	(do_captured_parse_breakpoint): Update.
	(create_breakpoint): Use struct linespec_result.
	(until_break_command): Update.
	(breakpoint_re_set_one): Update.
	(decode_line_spec_1): Update.
	* linespec.h (struct linespec_result): New.
	(init_linespec_result): Declare.
@
text
@d4625 3
a4627 1
  if (b->source_file && loc)
d7210 1
a7210 1
		       int enabled, int internal)
d7319 1
d7504 2
a7505 1
			     from_tty, enabled, internal);
d7961 2
a7962 1
				     from_tty, enabled, internal);
@


1.553
log
@2011-03-23  Kai Tietz  <ktietz@@redhat.com>

	* breakpoint.c (clear_command): Use filename_cmp
	instead of strcmp for comparison.
	* buildsym.c (watch_main_source_file_lossage): Likewise.
	(patch_subfile_names): Use IS_DIR_SEPARATOR instead of
	checking just for slash.
	* dbxread.c (read_dbx_symtab): Use lbasename instead of
	strrchr and filename_cmp instead of strcmp for filenames.
	(add_old_header_file): Use filename_cmp
	instead of strcmp for comparison.
	* exec.c (exec_set_section_address): Likewise.
	* macrotab.c (macro_lookup_inclusion): Likewise.
	(macro_lookup_inclusion): Likewise.
	* elfread.c (_initialize_elfread): Likewise.
	(elfstab_offset_sections): Likewise.
	(elfstab_offset_sections): Use lbasename instead of
	strrchr.
	* mdebugread.c (parse_partial_symbols): Likewise.
	(arse_partial_symbols): Use filename_(n)cmp instead of
	str(n)cmp for comparison.
	* minsyms.c (lookup_minimal_symbol): Likewise.
	* psymtab.c (read_psymtabs_with_filename): Likewise.
	* solib.c (solib_read_symbols): Likewise.
	(reload_shared_libraries_1): Likewise.
	* symmisc.c (maintenance_print_symbols): Likewise.
	* symfile.c (separate_debug_file_exists): Likewise.
	(reread_symbols): Likewise.
	(find_separate_debug_file_by_debuglink): Likewise.
	* remote-fileio.c (remote_fileio_func_rename): Likewise.
	* source.c (add_path): Likewise.
	* symtab.c (filename_seen): Likewise.
	(file_matches): Likewise.
	(print_symbol_info): Likewise.
	(maybe_add_partial_symtab_filename): Likewise.
	(make_source_files_completion_list): Likewise.
	* xml-syscall.c (init_sysinfo): Likewise.
	* windows-nat.c (_initialize_check_for_gdb_ini): Use
	IS_DIR_SEPARATOR for checking for trailing path separator.
@
text
@d5958 1
a5958 1
    char ***addr_string_p;
d7483 2
a7484 1
			struct symtabs_and_lines sals, char **addr_string,
d7498 1
a7498 1
      create_breakpoint_sal (gdbarch, expanded, addr_string[i],
d7516 1
a7516 1
		       char ***addr_string,
a7520 1
  *addr_string = NULL;
d7569 1
a7569 1
			       default_breakpoint_line, addr_string, 
d7573 1
a7573 1
		               addr_string, not_found_ptr);
d7576 2
a7577 2
  if (sals->nelts > 0 && *addr_string == NULL)
    *addr_string = xcalloc (sals->nelts, sizeof (char **));
d7585 3
a7587 3
	  if ((*addr_string)[i] == NULL)
	    (*addr_string)[i] = savestring (addr_start, 
					    (*address) - addr_start);
d7642 1
a7642 1
  parse_breakpoint_sals (args->arg_p, args->sals_p, args->addr_string_p, 
d7786 1
a7786 1
  char **addr_string;
d7798 1
a7798 1
  addr_string = NULL;
d7802 1
a7802 1
  parse_args.addr_string_p = &addr_string;
d7812 1
a7812 1
      addr_string = xcalloc (sals.nelts, sizeof (char **));
d7814 1
a7814 1
	addr_string[i] = xstrdup (copy_arg);
d7851 1
a7851 1
	  addr_string = &copy_arg;
d7876 2
a7877 2
      /* Cleanup the addr_string array but not its contents.  */
      make_cleanup (xfree, addr_string);
d7886 1
a7886 1
  /* Mark the contents of the addr_string for cleanup.  These go on
d7890 2
a7891 2
      if (addr_string[i] != NULL)
	make_cleanup (xfree, addr_string[i]);
d7938 1
a7938 1
	  && is_marker_spec (addr_string[0]))
d7953 1
a7953 1
	      create_breakpoint_sal (gdbarch, expanded, addr_string[i],
d7978 1
a7978 1
	create_breakpoints_sal (gdbarch, sals, addr_string, cond_string,
d7993 1
a7993 1
      b->addr_string = addr_string[0];
d8861 1
a8861 1
			  default_breakpoint_line, (char ***) NULL, NULL);
d8863 1
a8863 2
    sals = decode_line_1 (&arg, 1, (struct symtab *) NULL, 
			  0, (char ***) NULL, NULL);
d10546 1
a10546 1
				  (char ***) NULL, not_found_ptr);
d11152 1
a11152 1
			  (char ***) NULL, NULL);
d11155 1
a11155 1
			  (struct symtab *) NULL, 0, (char ***) NULL, NULL);
@


1.552
log
@2011-03-14  Phil Muldoon  <pmuldoon@@redhat.com>

	    * gdb.texinfo (Breakpoints In Python): Add description and
              example
	      of Python stop function operation.

2010-03-14  Phil Muldoon  <pmuldoon@@redhat.com>

	    * gdb.python/py-breakpoint.exp: Add Python stop operations
              tests.

2011-03-14  Phil Muldoon  <pmuldoon@@redhat.com>

	    * python/python.h: Declare gdbpy_should_stop and
	    gdbpy_breakpoint_has_py_cond.
	    * python/python.c: Add python.h to includes.  Remove
	    python.h from
	    HAVE_PYTHON definition
	    (gdbpy_should_stop): New dummy function.
	    (gdbpy_breakpoint_has_py_cond): New dummy function.
	    * python/py-breakpoint.c (bppy_init): Rewrite to allow
	    sub-classing capabilities.
	    (gdbpy_should_stop): New function.
	    (gdbpy_breakpoint_has_py_cond): New function.
	    (local_setattro): New function.
	    * breakpoint.c (condition_command): Add check for Python
	    'stop'
	    operation.
	    (bpstat_check_breakpoint_conditions): Execute Python
	    'stop'
	    operation function as part of stop/continue tests.
@
text
@d42 1
d9528 2
a9529 2
				    && strcmp (b->source_file,
					       sal.symtab->filename) == 0
@


1.551
log
@	Fix ARI warning about functions without parameters that do not
	use (void).
	* breakpoint.c (all_tracepoints): Replace () by (void).
	* f-exp.y (match_string_literal): Ditto.
	(yylex): Ditto.
	* m2-exp.y (yylex): Ditto.
	* mep-tdep.c (current_me_module): Ditto.
	(current_options): Ditto.
	(current_cop_data_bus_width): Ditto.
	(current_cr_names): Ditto.
	(current_cr_is_float): Ditto.
	(current_ccr_names): Ditto.
	* objc-exp.y (yylex): Ditto.
	* p-exp.y (yylex): Ditto.
	* remote.c (send_interrupt_sequence): Ditto.
	* tracepoint.c (current_trace_status): Ditto.
	* python/py-evts.c (gdbpy_initialize_py_events): Ditto.
	* python/py-prettyprint.c (push_dummy_python_frame): Ditto.
@
text
@d75 1
d647 8
d4082 5
@


1.550
log
@	* tracepoint.c (trace_actions_command): Update.
	* thread.c (thread_apply_command): Update.
	* reverse.c (delete_bookmark_command): Update.
	(bookmarks_info): Update.
	* printcmd.c (undisplay_command): Update.
	* memattr.c (mem_enable_command): Update.
	(mem_disable_command): Update.
	(mem_delete_command): Update.
	* inferior.c (detach_inferior_command): Update.
	(kill_inferior_command): Update.
	(remove_inferior_command): Update.
	* cli/cli-utils.h (struct get_number_or_range_state): New.
	(init_number_or_range): Declare.
	(get_number_or_range): Update.
	* cli/cli-utils.c (init_number_or_range): New function.
	(get_number_or_range): Change 'pp' parameter to 'state'.  Remove
	static variables.
	(number_is_in_list): Update.
	* breakpoint.h (get_tracepoint_by_number): Update.
	* breakpoint.c (map_breakpoint_numbers): Update for change to
	get_number_or_range.
	(find_location_by_number): Use get_number, not
	get_number_or_range.
	(trace_pass_set_count): New function.
	(trace_pass_command): Update for change to get_number_or_range.
	Rework loop logic.
	(get_tracepoint_by_number): Remove 'multi_p' parameter; add
	'state' parameter.
@
text
@d11955 1
a11955 1
all_tracepoints ()
@


1.549
log
@	* breakpointc (print_it_typical): Move NULL check from here...
	(print_bp_stop_message): ... to here.
@
text
@a10806 2
  char *p = args;
  char *p1;
d10810 1
d10812 1
a10812 1
  if (p == 0)
d10815 3
a10817 1
  while (*p)
d10819 2
a10821 1
      p1 = p;
d10823 1
a10823 1
      num = get_number_or_range (&p1);
a10842 1
      p = p1;
d10859 1
a10859 1
  bp_num = get_number_or_range (&p1);
d10873 1
a10873 1
  loc_num = get_number_or_range (&p1);
d11617 12
d11638 1
a11638 1
  struct breakpoint *t1 = (struct breakpoint *) -1, *t2;
a11639 1
  int all = 0;
a11652 1
      all = 1;
d11655 11
d11668 2
a11669 1
    t1 = get_tracepoint_by_number (&args, 1, 1);
d11671 2
a11672 3
  do
    {
      if (t1)
d11674 3
a11676 12
	  ALL_TRACEPOINTS (t2)
	    if (t1 == (struct breakpoint *) -1 || t1 == t2)
	      {
		t2->pass_count = count;
		observer_notify_tracepoint_modified (t2->number);
		if (from_tty)
		  printf_filtered (_("Setting tracepoint %d's "
				     "passcount to %d\n"),
				   t2->number, count);
	      }
	  if (! all && *args)
	    t1 = get_tracepoint_by_number (&args, 1, 0);
a11678 1
  while (*args);
d11710 2
a11711 2
   If MULTI_P is true, there might be a range of tracepoints in ARG.
   if OPTIONAL_P is true, then if the argument is missing, the most
d11714 3
a11716 1
get_tracepoint_by_number (char **arg, int multi_p, int optional_p)
d11723 6
a11728 1
  if (arg == NULL || *arg == NULL || ! **arg)
d11736 1
a11736 1
    tpnum = multi_p ? get_number_or_range (arg) : get_number (arg);
a11754 3
  /* FIXME: if we are in the middle of a range we don't want to give
     a message.  The current interface to get_number_or_range doesn't
     allow us to discover this.  */
@


1.548
log
@2011-03-04  Michael Snyder  <msnyder@@msnyder-server.eng.vmware.com>

	* breakpoint.c (enable_command): Use break instead of continue,
	and fill in a missing break.
	(disable_command): Ditto.
@
text
@a3311 5
  /* bs->breakpoint_at can be NULL if it was a momentary breakpoint
     which has since been deleted.  */
  if (bs->breakpoint_at == NULL)
    return PRINT_UNKNOWN;

d3517 5
d3524 1
a3524 2
	/* FIXME: how breakpoint can ever be NULL here?  */
	if (b != NULL && b->ops != NULL && b->ops->print_it != NULL)
@


1.547
log
@2011-03-04  Michael Snyder  <msnyder@@vmware.com>

	* breakpoint.c (create_breakpoint): Add missing break statement.
@
text
@d10933 1
a10933 1
	continue;
d10945 1
d10947 1
a10947 1
	continue;
d11035 1
a11035 1
	continue;
d11047 1
d11049 1
a11049 1
	continue;
@


1.546
log
@2011-02-28  Michael Snyder  <msnyder@@vmware.com>

	* breakpoint.c (breakpoint_adjustment_warning): Make local char
	buffers a little bigger, to avoid possibility of an overflow.
@
text
@d7846 1
@


1.545
log
@2011-02-28  Michael Snyder  <msnyder@@vmware.com>

	* breakpoint.c (catch_syscall_completer): Free malloced list.
@
text
@d5507 4
a5510 2
  char astr1[40];
  char astr2[40];
@


1.544
log
@	* breakpoint.c (print_one_breakpoint_location): Remove unused
	argument PRINT_ADDRESS_BITS.  Update callers.
	(print_one_breakpoint): Likewise.
@
text
@d11363 2
d11366 2
a11367 1
  return (list == NULL) ? NULL : complete_on_enum (list, text, word);
@


1.543
log
@	* breakpoint.c (wrap_indent_at_field): New function.
	(print_breakpoint_location): Use it instead of WRAP_INDENT argument.
	Allocate ui_stream locally instead of using STB argument.
	(print_one_breakpoint_location): Update call.
	* ui-out.c (ui_out_query_field): New function.
	* ui-out.h (ui_out_query_field): Add prototype.
@
text
@a4710 1
			       int print_address_bits,
a5000 1
		      int print_address_bits,
d5003 1
a5003 2
  print_one_breakpoint_location (b, NULL, 0, last_loc,
				 print_address_bits, allflag);
d5025 1
a5025 2
	    print_one_breakpoint_location (b, loc, n, last_loc,
					   print_address_bits, allflag);
d5069 1
a5069 3
	  int print_address_bits = breakpoint_address_bits (b);

	  print_one_breakpoint (b, &dummy_loc, print_address_bits, 0);
d5240 1
a5240 1
	print_one_breakpoint (b, &last_loc, print_address_bits, allflag);
@


1.542
log
@2011-02-26  Michael Snyder  <msnyder@@vmware.com>

	* breakpoint.c (reattach_breakpoints): Avoid resource leak (ui_file).
@
text
@d4568 29
d4599 3
a4601 4
static void print_breakpoint_location (struct breakpoint *b,
				       struct bp_location *loc,
				       char *wrap_indent,
				       struct ui_stream *stb)
d4620 3
a4622 2
	  ui_out_wrap_hint (uiout, wrap_indent);
	  ui_out_text (uiout, " at ");
d4640 3
d4646 2
a4715 3
  char wrap_indent[80];
  struct ui_stream *stb = ui_out_stream_new (uiout);
  struct cleanup *old_chain = make_cleanup_ui_out_stream_delete (stb);
a4776 9
  strcpy (wrap_indent, "                           ");
  if (opts.addressprint)
    {
      if (print_address_bits <= 32)
	strcat (wrap_indent, "           ");
      else
	strcat (wrap_indent, "                   ");
    }

d4841 1
a4841 1
	  print_breakpoint_location (b, loc, wrap_indent, stb);
a4996 1
  do_cleanups (old_chain);
@


1.541
log
@2011-02-21  Michael Snyder  <msnyder@@vmware.com>

	* breakpoint.c (breakpoint_1): Change first argument from an int
	to a char pointer, so that the function now accepts a list of
	breakpoints rather than just one.  Use new function
	'number_is_in_list' to implement.
	(breakpoints_info): Pass char * instead of int to breakpoint_1.
	(watchpoints_info): Ditto.
	(tracepoints_info): Ditto.
	(maintenance_info_breakpoints): Ditto.
	(_initialize_breakpoint): Update help strings to reflect the fact
	that these functions can now take more than one argument.
	* cli/cli-utils.c (number_is_in_list): New function.
	* cli/cli-utils.h (number_is_in_list): Export.

2011-02-21  Michael Snyder  <msnyder@@vmware.com>

	* gdb.texinfo (Set Breaks): Add @@dots{} to arguments of info break.
	(Set Watchpoints): Add @@dots{} to argument of info watchpoints.
	(Listing Tracepoints): Add @@dots{} to argument of info tracepoints.

2011-02-21  Michael Snyder  <msnyder@@vmware.com>

	* gdb.base/break.exp: Add tests for "info break" with arguments.
	* gdb.trace/infotrace.exp: Update patterns for error and help.
	* gdb.base/completion.exp: Update pattern.
	* gdb.base/ena-dis-br.exp: Update pattern.
	* gdb.base/help.exp: Update patterns.
@
text
@d1992 1
a1992 1
  struct ui_file *tmp_error_stream = mem_fileopen ();
d2006 1
@


1.540
log
@	* breakpoint.c (catch_syscall_command_1): Fix typo.
@
text
@d136 2
a137 1
static int breakpoint_1 (int, int, int (*) (const struct breakpoint *));
d5106 1
a5106 1
breakpoint_1 (int bnum, int allflag, 
d5123 18
a5140 10
    if (bnum == -1
	|| bnum == b->number)
      {
	/* If we have a filter, only list the breakpoints it accepts.  */
	if (filter && !filter (b))
	  continue;
	
	if (allflag || user_breakpoint_p (b))
	  {
	    int addr_bit, type_len;
d5142 3
a5144 3
	    addr_bit = breakpoint_address_bits (b);
	    if (addr_bit > print_address_bits)
	      print_address_bits = addr_bit;
d5146 3
a5148 3
	    type_len = strlen (bptype_string (b->type));
	    if (type_len > print_type_col_width)
	      print_type_col_width = type_len;
d5150 3
a5152 3
	    nr_printable_breakpoints++;
	  }
      }
d5181 10
a5190 10
	{
	  if (nr_printable_breakpoints > 0)
	    annotate_field (4);
	  if (print_address_bits <= 32)
	    ui_out_table_header (uiout, 10, ui_left, 
				 "addr", "Address");		/* 5 */
	  else
	    ui_out_table_header (uiout, 18, ui_left, 
				 "addr", "Address");		/* 5 */
	}
d5199 28
a5226 16
  {
    QUIT;
    if (bnum == -1
	|| bnum == b->number)
      {
	/* If we have a filter, only list the breakpoints it accepts.  */
	if (filter && !filter (b))
	  continue;
	
	/* We only print out user settable breakpoints unless the
	   allflag is set.  */
	if (allflag || user_breakpoint_p (b))
	  print_one_breakpoint (b, &last_loc, print_address_bits, allflag);
      }
  }
  
d5235 1
a5235 1
	  if (bnum == -1)
d5239 2
a5240 2
			    "No breakpoint or watchpoint number %d.\n",
			    bnum);
d5276 1
a5276 1
breakpoints_info (char *bnum_exp, int from_tty)
d5278 1
a5278 6
  int bnum = -1;

  if (bnum_exp)
    bnum = parse_and_eval_long (bnum_exp);

  breakpoint_1 (bnum, 0, NULL);
d5284 1
a5284 1
watchpoints_info (char *wpnum_exp, int from_tty)
d5286 1
a5286 6
  int wpnum = -1, num_printed;

  if (wpnum_exp)
    wpnum = parse_and_eval_long (wpnum_exp);

  num_printed = breakpoint_1 (wpnum, 0, is_watchpoint);
d5290 1
a5290 1
      if (wpnum == -1)
d5293 1
a5293 1
	ui_out_message (uiout, 0, "No watchpoint number %d.\n", wpnum);
d5298 1
a5298 1
maintenance_info_breakpoints (char *bnum_exp, int from_tty)
d5300 1
a5300 6
  int bnum = -1;

  if (bnum_exp)
    bnum = parse_and_eval_long (bnum_exp);

  breakpoint_1 (bnum, 1, NULL);
d11519 1
a11519 1
tracepoints_info (char *tpnum_exp, int from_tty)
d11521 1
a11521 4
  int tpnum = -1, num_printed;

  if (tpnum_exp)
    tpnum = parse_and_eval_long (tpnum_exp);
d11523 1
a11523 1
  num_printed = breakpoint_1 (tpnum, 0, is_tracepoint);
d11527 1
a11527 1
      if (tpnum == -1)
d11530 1
a11530 1
	ui_out_message (uiout, 0, "No tracepoint number %d.\n", tpnum);
d12220 1
a12220 1
Status of user-settable breakpoints, or breakpoint number NUMBER.\n\
d12368 1
a12368 3
Status of watchpoints, or watchpoint number NUMBER."));


d12434 1
a12434 1
Status of tracepoints, or tracepoint number NUMBER.\n\
@


1.539
log
@	* reverse.c: Include cli-utils.h.
	* printcmd.c: Include cli-utils.h.
	(string_printf): Use skip_spaces.
	* cli/cli-utils.h: New file.
	* cli/cli-utils.c: New file.
	* cli/cli-dump.h (skip_spaces): Move to cli-utils.h.
	* cli/cli-dump.c (skip_spaces): Move to cli-utils.c.
	* breakpoint.h (get_number, get_number_or_range): Move to
	cli-utils.h.
	* breakpoint.c: Include cli-utils.h.
	(get_number_trailer, get_number, get_number_or_range)
	(ep_skip_leading_whitespace): Move to cli-utils.c.
	(create_breakpoint_sal, find_condition_and_thread)
	(decode_static_tracepoint_spec, watch_command_1)
	(watch_maybe_just_location, ep_parse_optional_if_clause)
	(catch_fork_command_1, catch_exec_command_1)
	(catch_syscall_command_1): Use skip_spaces, skip_to_space.
	* Makefile.in (SUBDIR_CLI_OBS): Add cli-utils.o.
	(SUBDIR_CLI_SRCS): Add cli-utils.c.
	(HFILES_NO_SRCDIR): Add cli-utils.h.
	(cli-utils.o): New target.
@
text
@d9333 1
a9333 1
this architeture yet."));
@


1.538
log
@	* breakpoint.c (update_watchpoint): Do not attempt to recreate
	per-frame locations while within a function epilogue.
@
text
@d65 1
a145 2
static int get_number_trailer (char **, int);

a186 2
static void ep_skip_leading_whitespace (char **s);

a552 153
/* *PP is a string denoting a breakpoint.  Get the number of the
   breakpoint.  Advance *PP after the string and any trailing
   whitespace.

   Currently the string can either be a number or "$" followed by the
   name of a convenience variable.  Making it an expression wouldn't
   work well for map_breakpoint_numbers (e.g. "4 + 5 + 6").

   TRAILER is a character which can be found after the number; most
   commonly this is `-'.  If you don't want a trailer, use \0.  */

static int
get_number_trailer (char **pp, int trailer)
{
  int retval = 0;	/* default */
  char *p = *pp;

  if (*p == '$')
    {
      /* Make a copy of the name, so we can null-terminate it
         to pass to lookup_internalvar().  */
      char *varname;
      char *start = ++p;
      LONGEST val;

      while (isalnum (*p) || *p == '_')
	p++;
      varname = (char *) alloca (p - start + 1);
      strncpy (varname, start, p - start);
      varname[p - start] = '\0';
      if (get_internalvar_integer (lookup_internalvar (varname), &val))
	retval = (int) val;
      else
	{
	  printf_filtered (_("Convenience variable must "
			     "have integer value.\n"));
	  retval = 0;
	}
    }
  else
    {
      if (*p == '-')
	++p;
      while (*p >= '0' && *p <= '9')
	++p;
      if (p == *pp)
	/* There is no number here.  (e.g. "cond a == b").  */
	{
	  /* Skip non-numeric token.  */
	  while (*p && !isspace((int) *p))
	    ++p;
	  /* Return zero, which caller must interpret as error.  */
	  retval = 0;
	}
      else
	retval = atoi (*pp);
    }
  if (!(isspace (*p) || *p == '\0' || *p == trailer))
    {
      /* Trailing junk: return 0 and let caller print error msg.  */
      while (!(isspace (*p) || *p == '\0' || *p == trailer))
	++p;
      retval = 0;
    }
  while (isspace (*p))
    p++;
  *pp = p;
  return retval;
}


/* Like get_number_trailer, but don't allow a trailer.  */
int
get_number (char **pp)
{
  return get_number_trailer (pp, '\0');
}

/* Parse a number or a range.
   A number will be of the form handled by get_number.
   A range will be of the form <number1> - <number2>, and 
   will represent all the integers between number1 and number2,
   inclusive.

   While processing a range, this fuction is called iteratively;
   At each call it will return the next value in the range.

   At the beginning of parsing a range, the char pointer PP will
   be advanced past <number1> and left pointing at the '-' token.
   Subsequent calls will not advance the pointer until the range
   is completed.  The call that completes the range will advance
   pointer PP past <number2>.  */

int
get_number_or_range (char **pp)
{
  static int last_retval, end_value;
  static char *end_ptr;
  static int in_range = 0;

  if (**pp != '-')
    {
      /* Default case: pp is pointing either to a solo number, 
	 or to the first number of a range.  */
      last_retval = get_number_trailer (pp, '-');
      if (**pp == '-')
	{
	  char **temp;

	  /* This is the start of a range (<number1> - <number2>).
	     Skip the '-', parse and remember the second number,
	     and also remember the end of the final token.  */

	  temp = &end_ptr; 
	  end_ptr = *pp + 1; 
	  while (isspace ((int) *end_ptr))
	    end_ptr++;	/* skip white space */
	  end_value = get_number (temp);
	  if (end_value < last_retval) 
	    {
	      error (_("inverted range"));
	    }
	  else if (end_value == last_retval)
	    {
	      /* Degenerate range (number1 == number2).  Advance the
		 token pointer so that the range will be treated as a
		 single number.  */ 
	      *pp = end_ptr;
	    }
	  else
	    in_range = 1;
	}
    }
  else if (! in_range)
    error (_("negative value"));
  else
    {
      /* pp points to the '-' that betokens a range.  All
	 number-parsing has already been done.  Return the next
	 integer value (one greater than the saved previous value).
	 Do not advance the token pointer 'pp' until the end of range
	 is reached.  */

      if (++last_retval == end_value)
	{
	  /* End of range reached; advance token pointer.  */
	  *pp = end_ptr;
	  in_range = 0;
	}
    }
  return last_retval;
}

d7230 1
a7230 2
		  while (*p == ' ' || *p == '\t')
		    p++;
d7232 1
a7232 3
		  endp = p;
		  while (*endp != ' ' && *endp != '\t' && *endp != '\0')
		    endp++;
d7627 1
a7627 4
      while (*tok == ' ' || *tok == '\t')
	tok++;
      
      end_tok = tok;
d7629 1
a7629 2
      while (*end_tok != ' ' && *end_tok != '\t' && *end_tok != '\000')
	end_tok++;
d7688 1
a7688 2
  while (*p == ' ' || *p == '\t')
    p++;
d7690 1
a7690 3
  endp = p;
  while (*endp != ' ' && *endp != '\t' && *endp != '\0')
    endp++;
d8455 2
a8456 7
  tok = arg;
  while (*tok == ' ' || *tok == '\t')
    tok++;
  end_tok = tok;

  while (*end_tok != ' ' && *end_tok != '\t' && *end_tok != '\000')
    end_tok++;
d8740 1
a8740 1
      ep_skip_leading_whitespace (&arg);
a8896 9
static void
ep_skip_leading_whitespace (char **s)
{
  if ((s == NULL) || (*s == NULL))
    return;
  while (isspace (**s))
    *s += 1;
}

d8918 1
a8918 1
  ep_skip_leading_whitespace (arg);
d8953 1
a8953 1
  ep_skip_leading_whitespace (&arg);
d8997 1
a8997 1
  ep_skip_leading_whitespace (&arg);
d9147 1
a9147 1
  ep_skip_leading_whitespace (&arg);
d9337 1
a9337 1
  ep_skip_leading_whitespace (&arg);
@


1.537
log
@	* breakpoint.c (get_number_trailer): No longer accept a NULL PP.
	* breakpoint.h (get_number_or_range): Declare.
	* printcmd.c (ALL_DISPLAYS): Declare.
	(delete_display): Reimplement taking a display pointer.
	(undisplay_command): Accept a range of displays to delete, using
	get_number_or_range.
@
text
@a1371 5
  /* We don't free locations.  They are stored in the bp_location array
     and update_global_location_list will eventually delete them and
     remove breakpoints if needed.  */
  b->loc = NULL;

d1382 9
a1390 1
      struct frame_info *fi;
d1406 5
@


1.536
log
@2011-02-15  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* breakpoint.c (longjmp_names): New variable.
	(struct breakpoint_objfile_data): New type.
	(breakpoint_objfile_key): New variable.
	(msym_not_found): New variable.
	(msym_not_found_p): New predicate.
	(get_breakpoint_objfile_data): New function.
	(create_overlay_event_breakpoint): Check per-objfile cache for
	symbols first.
	(create_longjmp_master_breakpoint): Likewise.
	(create_std_terminate_master_breakpoint): Likewise.
	(create_exception_master_breakpoint): Likewise.
	(_initialize_breakpoint): Register per-objfile data key.
@
text
@a563 2
   If the string is a NULL pointer, that denotes the last breakpoint.
   
d573 1
a573 4
  if (p == NULL)
    /* Empty line means refer to the last breakpoint.  */
    return breakpoint_count;
  else if (*p == '$')
d649 1
a649 1
int 
@


1.535
log
@2011-02-15  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* breakpoint.c ((create_overlay_event_breakpoint): Const-propagate
	parameter value.
	(create_longjmp_master_breakpoint): Loop over longjmp names.
	(create_std_terminate_master_breakpoint): Const-propagate parameter
	value.
	(update_breakpoints_after_exec): Adjust.
	(breakpoint_re_set): Adjust.
@
text
@d2220 55
d2284 7
a2290 1
      struct minimal_symbol *m;
d2292 13
a2304 3
      m = lookup_minimal_symbol_text (func_name, objfile);
      if (m == NULL)
        continue;
d2306 2
a2307 2
      b = create_internal_breakpoint (get_objfile_arch (objfile),
				      SYMBOL_VALUE_ADDRESS (m),
a2340 4
      const char *const longjmp_names[]
	= { "longjmp", "_longjmp", "siglongjmp", "_siglongjmp" };
      const int num_longjmp_names
	= sizeof (longjmp_names) / sizeof (longjmp_names[0]);
d2343 1
d2349 3
a2351 1
      for (i = 0; i < num_longjmp_names; i++)
a2353 1
	  struct minimal_symbol *m;
d2355 4
d2361 13
a2373 3
	  m = lookup_minimal_symbol_text (func_name, objfile);
	  if (m == NULL)
	    continue;
d2375 2
a2376 3
	  b = create_internal_breakpoint (gdbarch,
					  SYMBOL_VALUE_ADDRESS (m),
					  bp_longjmp_master);
a2391 1
  struct objfile *objfile;
d2398 6
d2407 6
a2412 1
      struct minimal_symbol *m;
d2414 3
a2416 1
      set_current_program_space (pspace);
d2418 10
a2427 4
      m = lookup_minimal_symbol (func_name, NULL, objfile);
      if (m == NULL || (MSYMBOL_TYPE (m) != mst_text
			&& MSYMBOL_TYPE (m) != mst_file_text))
        continue;
d2429 2
a2430 2
      b = create_internal_breakpoint (get_objfile_arch (objfile),
				      SYMBOL_VALUE_ADDRESS (m),
d2435 2
d2448 1
d2452 11
a2462 1
      struct minimal_symbol *debug_hook;
d2464 1
a2464 2
      debug_hook = lookup_minimal_symbol ("_Unwind_DebugHook", NULL, objfile);
      if (debug_hook != NULL)
d2466 8
a2473 3
	  struct breakpoint *b;
	  CORE_ADDR addr = SYMBOL_VALUE_ADDRESS (debug_hook);
	  struct gdbarch *gdbarch = get_objfile_arch (objfile);
d2475 1
a2475 5
	  addr = gdbarch_convert_from_func_ptr_addr (gdbarch, addr,
						     &current_target);
	  b = create_internal_breakpoint (gdbarch, addr, bp_exception_master);
	  b->addr_string = xstrdup ("_Unwind_DebugHook");
	  b->enable_state = bp_disabled;
d2477 7
d12197 2
@


1.534
log
@	* breakpoint.c (parse_breakpoint_sals): Fix description.
@
text
@d2221 1
a2221 1
create_overlay_event_breakpoint (char *func_name)
d2224 1
d2255 1
a2255 1
create_longjmp_master_breakpoint (char *func_name)
a2257 1
  struct objfile *objfile;
d2263 6
a2268 1
  ALL_OBJFILES (objfile)
d2270 6
a2275 2
      struct breakpoint *b;
      struct minimal_symbol *m;
d2277 2
a2278 1
      if (!gdbarch_get_longjmp_target_p (get_objfile_arch (objfile)))
d2281 5
a2285 1
      set_current_program_space (pspace);
d2287 4
a2290 3
      m = lookup_minimal_symbol_text (func_name, objfile);
      if (m == NULL)
        continue;
d2292 6
a2297 5
      b = create_internal_breakpoint (get_objfile_arch (objfile),
				      SYMBOL_VALUE_ADDRESS (m),
                                      bp_longjmp_master);
      b->addr_string = xstrdup (func_name);
      b->enable_state = bp_disabled;
d2299 1
d2305 1
a2305 2
/* Create a master std::terminate breakpoint.  The actual function
   looked for is named FUNC_NAME.  */
d2307 1
a2307 1
create_std_terminate_master_breakpoint (const char *func_name)
d2312 1
d2482 3
a2484 6
  create_overlay_event_breakpoint ("_ovly_debug_event");
  create_longjmp_master_breakpoint ("longjmp");
  create_longjmp_master_breakpoint ("_longjmp");
  create_longjmp_master_breakpoint ("siglongjmp");
  create_longjmp_master_breakpoint ("_siglongjmp");
  create_std_terminate_master_breakpoint ("std::terminate()");
d10736 3
a10738 6
  create_overlay_event_breakpoint ("_ovly_debug_event");
  create_longjmp_master_breakpoint ("longjmp");
  create_longjmp_master_breakpoint ("_longjmp");
  create_longjmp_master_breakpoint ("siglongjmp");
  create_longjmp_master_breakpoint ("_siglongjmp");
  create_std_terminate_master_breakpoint ("std::terminate()");
@


1.533
log
@	Fix some typos.
	* breakpoint.c (update_watchpoint): Fix name of the
	update_global_location_list function.
	(print_one_breakpoint): Fix typo.
	(_initialize_breakpoint): Remove extra space in hbreak help
	string.
	* breakpoint.h (struct bp_location) <length>: Fix field
	description.
@
text
@d7488 1
a7488 1
/* Parse ARG which is assumed to be a SAL specification possibly
d7491 4
a7494 1
   address strings.  ARG points to the end of the SAL.  */
@


1.532
log
@2011-01-31  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* breakpoint.h (remove_jit_event_breakpoints): New prototype.
	* breakpoint.c (remove_jit_event_breakpoints): New function.
	* jit.c (jit_descriptor_addr): Delete.
	(registering_code): Delete.
	(clear_int): Delete.
	(jit_inferior_data): New variable.
	(struct jit_inferior_data): New type.
	(get_jit_inferior_data): New function.
	(jit_inferior_data_cleanup): New function.
	(jit_read_descriptor): Adjust.
	(jit_register_code): Adjust.
	(jit_breakpoint_re_set_internal): New function; move code here ...
	(jit_inferior_init): ... from here.
	(jit_breakpoint_re_set): Adjust.
	(jit_reset_inferior_data_and_breakpoints): New function.
	(jit_inferior_created_observer): Adjust.
	(jit_inferior_exit_hook): Adjust.
	(jit_executable_changed_observer): New function.
	(jit_event_handler): Adjust.
	(_initialize_jit): Adjust.
@
text
@d1377 2
a1378 2
  /* We don't free locations.  They are stored in bp_location array
     and update_global_locations will eventually delete them and
d5015 1
a5015 1
	 internally, that's no a property exposed to user.  */
d12100 1
a12100 1
Set a hardware assisted  breakpoint.\n\
@


1.531
log
@	* infcmd.c (finish_backward): Use breakpoint_set_silent.
	* python/py-breakpoint.c (bppy_set_silent): Use
	breakpoint_set_silent.
	(bppy_set_thread): Use breakpoint_set_thread.
	(bppy_set_task): Use breakpoint_set_task.
	* breakpoint.h (breakpoint_set_silent, breakpoint_set_thread)
	(breakpoint_set_task): Declare.
	(make_breakpoint_silent): Remove.
	* breakpoint.c (breakpoint_set_silent): New function.
	(breakpoint_set_thread): Likewise.
	(breakpoint_set_task): Likewise.
	(make_breakpoint_silent): Remove.
@
text
@d5961 13
@


1.530
log
@	* breakpoint.h (user_breakpoint_p): Declare.
	* breakpoint.c (user_breakpoint_p): New function.
	(breakpoint_1): Use it.
	(save_breakpoints): Likewise.
@
text
@d943 40
a10780 7
void
make_breakpoint_silent (struct breakpoint *b)
{
  /* Silence the breakpoint.  */
  b->silent = 1;
}

@


1.529
log
@2011-01-11  Thiago Jung Bauermann  <bauerman@@br.ibm.com>

	* breakpoint.c (resources_needed_watchpoint): Fix indentation.
	* gdbtypes.c (is_scalar_type_recursive): Fix formatting.
@
text
@d5067 9
d5108 1
a5108 2
	if (allflag || (user_settable_breakpoint (b)
			&& b->number > 0))
d5180 1
a5180 2
	if (allflag || (user_settable_breakpoint (b)
			&& b->number > 0))
d11737 1
a11737 1
    if (!user_settable_breakpoint (tp) || tp->number < 0)
d11775 1
a11775 1
    if (!user_settable_breakpoint (tp) || tp->number < 0)
@


1.528
log
@2011-01-11  Sergio Durigan Junior  <sergiodj@@linux.vnet.ibm.com>
	    Thiago Jung Bauermann  <bauerman@@br.ibm.com>

	Implement support for PowerPC BookE ranged watchpoints.

gdb/
	* breakpoint.h
	(struct breakpoint_ops) <resources_needed>: New method.
	Initialize to NULL in all existing breakpoint_ops instances.
	(struct breakpoint) <exact>: New field.
	(target_exact_watchpoints): Declare external global.
	* breakpoint.c (target_exact_watchpoints): New global flag.
	(update_watchpoint): Set b->type to bp_hardware_watchpoint and
	b->enable_state to bp_enabled before calling
	hw_watchpoint_used_count.
	(hw_watchpoint_used_count): Iterate over all bp_locations in a
	watchpoint.  Call breakpoint's breakpoint_ops.resources_needed
	if available.
	(insert_watchpoint, remove_watchpoint): Use fixed length of 1 byte
	if the watchpoint is exact.
	(resources_needed_watchpoint): New function.
	(watchpoint_breakpoint_ops): Add resources_needed_watchpoint.
	(watch_command_1): Set b->exact if the user asked for an exact
	watchpoint and one can be set.
	(can_use_hardware_watchpoint): Add exact_watchpoints argument.
	Pass fixed length of 1 to target_region_ok_for_hw_watchpoint if
	the user asks for an exact watchpoint and one can be set.  Return
	number of needed debug registers to watch the expression.
	* gdbtypes.c (is_scalar_type): New function, based on
	valprint.c:scalar_type_p.
	(is_scalar_type_recursive): New function.
	* gdbtypes.h (is_scalar_type_recursive): Declare.
	* ppc-linux-nat.c (ppc_linux_region_ok_for_hw_watchpoint): Always
	handle regions when ranged watchpoints are available.
	(create_watchpoint_request): New function.
	(ppc_linux_insert_watchpoint, ppc_linux_remove_watchpoint): Use
	create_watchpoint_request.
	* rs6000-tdep.c (show_powerpc_exact_watchpoints): New function.
	(_initialize_rs6000_tdep): Add `exact-watchpoints' boolean to the
	`set powerpc' and `show powerpc' commands.
	* target.h (struct target_ops) <to_region_ok_for_hw_watchpoint>:
	Mention documentation comment in the target macro.
	(target_region_ok_for_hw_watchpoint): Document return value.

gdb/doc/
	* gdb.texinfo (PowerPC Embedded): Document ranged watchpoints and
	the "set powerpc exact-watchpoints" flag.
@
text
@d8281 1
a8281 1
    int length = bl->owner->exact? 1 : bl->length;
d8283 1
a8283 1
    return target_region_ok_for_hw_watchpoint (bl->address, length);
@


1.527
log
@2011-01-11  Thiago Jung Bauermann  <bauerman@@br.ibm.com>

	* breakpoint.c (update_watchpoint): Decide on using a software or
	hardware watchpoint after the bp_locations are created.
@
text
@d101 1
a101 1
static int can_use_hardware_watchpoint (struct value *);
d354 3
d1487 1
a1487 1
	  int mem_cnt;
d1491 3
a1493 2
	  mem_cnt = can_use_hardware_watchpoint (val_chain);
	  if (mem_cnt)
d1496 1
d1499 14
a1512 6
		 used for all other hardware watchpoints to see if we
		 still have enough resources to also fit this watchpoint
		 in as well.  To avoid the hw_watchpoint_used_count call
		 below from counting this watchpoint, make sure that it
		 is marked as a software watchpoint.  */
	      b->type = bp_watchpoint;
d1515 3
d1519 3
a1521 4
		    (bp_hardware_watchpoint, i + mem_cnt, other_type_used);

	      if (target_resources_ok > 0)
		b->type = bp_hardware_watchpoint;
d6112 1
d6208 1
d6492 1
d6646 1
d6687 1
d6689 1
a6689 1
  int i = 0;
d6693 4
a6696 3
  {
    if (breakpoint_enabled (b))
      {
d6698 9
a6706 1
	  i++;
d6709 2
a6710 2
      }
  }
d8258 4
a8261 2
  return target_insert_watchpoint (bl->address, bl->length,
				   bl->watchpoint_type, bl->owner->cond_exp);
d8269 15
a8283 2
  return target_remove_watchpoint (bl->address, bl->length,
				   bl->watchpoint_type, bl->owner->cond_exp);
d8293 1
d8320 1
a8320 1
  int mem_cnt = 0;
d8455 2
a8456 2
  mem_cnt = can_use_hardware_watchpoint (val);
  if (mem_cnt == 0 && bp_type != bp_hardware_watchpoint)
d8458 1
a8458 1
  if (mem_cnt != 0)
d8462 1
a8462 1
	target_can_use_hardware_watchpoint (bp_type, i + mem_cnt, 
d8474 1
a8474 1
  if (!mem_cnt || target_resources_ok <= 0)
d8545 4
d8588 6
a8593 3
/* Return count of locations need to be watched and can be handled in
   hardware.  If the watchpoint can not be handled in hardware return
   zero.  */
d8596 1
a8596 1
can_use_hardware_watchpoint (struct value *v)
d8649 6
a8654 1
		  int       len   = TYPE_LENGTH (value_type (v));
d8656 2
a8657 1
		  if (!target_region_ok_for_hw_watchpoint (vaddr, len))
d8660 1
a8660 1
		    found_memory_cnt++;
d9086 1
@


1.526
log
@2010-01-11  Thiago Jung Bauermann  <bauerman@@br.ibm.com>

	Convert hardware watchpoints to use breakpoint_ops.

gdb/
	* breakpoint.h (breakpoint_ops) <insert>: Rename to...
	<insert_location>: ... this.  Return int instead of void.
	Accept pointer to struct bp_location instead of pointer to
	struct breakpoint.  Adapt all implementations.
	(breakpoint_ops) <remove>: Rename to...
	<remove_location>: ... this.  Accept pointer to struct bp_location
	instead of pointer to struct breakpoint.  Adapt all implementations.
	* breakpoint.c (insert_catchpoint): Delete function.
	(insert_bp_location): Call the watchpoint or catchpoint's
	breakpoint_ops.insert method.
	(remove_breakpoint_1): Call the watchpoint or catchpoint's
	breakpoint_ops.remove method.
	(insert_watchpoint, remove_watchpoint): New functions.
	(watchpoint_breakpoint_ops): New structure.
	(watch_command_1): Initialize the OPS field.
	* inf-child.c (inf_child_insert_fork_catchpoint)
	(inf_child_remove_fork_catchpoint, inf_child_insert_vfork_catchpoint)
	(inf_child_remove_vfork_catchpoint, inf_child_insert_exec_catchpoint)
	(inf_child_remove_exec_catchpoint, inf_child_set_syscall_catchpoint):
	Delete functions.
	(inf_child_target): Remove initialization of to_insert_fork_catchpoint,
	to_remove_fork_catchpoint, to_insert_vfork_catchpoint,
	to_remove_vfork_catchpoint, to_insert_exec_catchpoint,
	to_remove_exec_catchpoint and to_set_syscall_catchpoint.
	* target.c (update_current_target): Change default implementation of
	to_insert_fork_catchpoint, to_remove_fork_catchpoint,
	to_insert_vfork_catchpoint, to_remove_vfork_catchpoint,
	to_insert_exec_catchpoint, to_remove_exec_catchpoint and
	to_set_syscall_catchpoint to return_one.
	(debug_to_insert_fork_catchpoint, debug_to_insert_vfork_catchpoint)
	(debug_to_insert_exec_catchpoint): Report return value.
	* target.h (to_insert_fork_catchpoint, to_insert_vfork_catchpoint)
	(to_insert_exec_catchpoint): Change declaration to return int instead
	of void.

gdb/testsuite/
	* gdb.base/foll-exec.exp: Adapt to new error string when the catchpoint
	type is not supported.
	* gdb.base/foll-fork.exp: Likewise.
	* gdb.base/foll-vfork.exp: Likewise.
@
text
@a1428 33
	/* Change the type of breakpoint between hardware assisted or
	   an ordinary watchpoint depending on the hardware support
	   and free hardware slots.  REPARSE is set when the inferior
	   is started.  */
	if ((b->type == bp_watchpoint || b->type == bp_hardware_watchpoint)
	    && reparse)
	  {
	    int i, mem_cnt, other_type_used;

	    /* We need to determine how many resources are already
	       used for all other hardware watchpoints to see if we
	       still have enough resources to also fit this watchpoint
	       in as well.  To avoid the hw_watchpoint_used_count call
	       below from counting this watchpoint, make sure that it
	       is marked as a software watchpoint.  */
	    b->type = bp_watchpoint;
	    i = hw_watchpoint_used_count (bp_hardware_watchpoint,
					  &other_type_used);
	    mem_cnt = can_use_hardware_watchpoint (val_chain);

	    if (!mem_cnt)
	      b->type = bp_watchpoint;
	    else
	      {
		int target_resources_ok = target_can_use_hardware_watchpoint
		  (bp_hardware_watchpoint, i + mem_cnt, other_type_used);
		if (target_resources_ok <= 0)
		  b->type = bp_watchpoint;
		else
		  b->type = bp_hardware_watchpoint;
	      }
	  }

d1432 1
a1432 1
      for (v = val_chain; v; v = next)
d1475 29
d1505 14
@


1.525
log
@2011-01-07  Michael Snyder  <msnyder@@vmware.com>

	* ax-gdb.c: Adjust some long output strings.
	* breakpoint.c: Ditto.
	* charset.c: Ditto.
	* cp-abi.c: Ditto.
	* infcall.c: Ditto.
	* infrun.c: Ditto.
	* linux-nat.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
@
text
@a1230 12
/* A wrapper function for inserting catchpoints.  */
static void
insert_catchpoint (struct ui_out *uo, void *args)
{
  struct breakpoint *b = (struct breakpoint *) args;

  gdb_assert (b->type == bp_catchpoint);
  gdb_assert (b->ops != NULL && b->ops->insert != NULL);

  b->ops->insert (b);
}

d1781 4
a1784 4
      val = target_insert_watchpoint (bl->address,
				      bl->length,
				      bl->watchpoint_type,
				      bl->owner->cond_exp);
d1810 6
a1815 6
	      val = target_insert_watchpoint (bl->address,
					      bl->length,
					      hw_access,
					      bl->owner->cond_exp);
	      if (val == 0)
		bl->watchpoint_type = hw_access;
d1824 17
a1840 8
      struct gdb_exception e = catch_exception (uiout, insert_catchpoint,
						bl->owner, RETURN_MASK_ERROR);
      exception_fprintf (gdb_stderr, e, "warning: inserting catchpoint %d: ",
			 bl->owner->number);
      if (e.reason < 0)
	bl->owner->enable_state = bp_disabled;
      else
	bl->inserted = 1;
d2537 3
d2541 1
a2541 3
      val = target_remove_watchpoint (bl->address, bl->length,
				      bl->watchpoint_type, 
				      bl->owner->cond_exp);
d2552 2
a2553 1
      gdb_assert (bl->owner->ops != NULL && bl->owner->ops->remove != NULL);
d2555 1
a2555 1
      val = bl->owner->ops->remove (bl->owner);
d2558 1
d6000 2
a6001 2
static void
insert_catch_fork (struct breakpoint *b)
d6003 1
a6003 1
  target_insert_fork_catchpoint (PIDGET (inferior_ptid));
d6010 1
a6010 1
remove_catch_fork (struct breakpoint *b)
d6096 2
a6097 2
static void
insert_catch_vfork (struct breakpoint *b)
d6099 1
a6099 1
  target_insert_vfork_catchpoint (PIDGET (inferior_ptid));
d6106 1
a6106 1
remove_catch_vfork (struct breakpoint *b)
d6191 2
a6192 2
static void
insert_catch_syscall (struct breakpoint *b)
d6197 1
a6197 1
  if (!b->syscalls_to_be_caught)
d6204 1
a6204 1
           VEC_iterate (int, b->syscalls_to_be_caught, i, iter);
d6226 5
a6230 5
  target_set_syscall_catchpoint (PIDGET (inferior_ptid),
				 inf->total_syscalls_count != 0,
				 inf->any_syscall_count,
				 VEC_length (int, inf->syscalls_counts),
				 VEC_address (int, inf->syscalls_counts));
d6237 1
a6237 1
remove_catch_syscall (struct breakpoint *b)
d6242 1
a6242 1
  if (!b->syscalls_to_be_caught)
d6249 1
a6249 1
           VEC_iterate (int, b->syscalls_to_be_caught, i, iter);
d6549 2
a6550 2
static void
insert_catch_exec (struct breakpoint *b)
d6552 1
a6552 1
  target_insert_exec_catchpoint (PIDGET (inferior_ptid));
d6556 1
a6556 1
remove_catch_exec (struct breakpoint *b)
d8214 31
d8488 2
@


1.524
log
@2011-01-05  Michael Snyder  <msnyder@@vmware.com>

	* addrmap.c: Shorten lines of >= 80 columns.
	* arch-utils.c: Ditto.
	* arch-utils.h: Ditto.
	* ax-gdb.c: Ditto.
	* ax-general.c: Ditto.
	* bcache.c: Ditto.
	* blockframe.c: Ditto.
	* breakpoint.c: Ditto.
	* buildsym.c: Ditto.
	* c-lang.c: Ditto.
	* c-typeprint.c: Ditto.
	* charset.c: Ditto.
	* coffread.c: Ditto.
	* command.h: Ditto.
	* corelow.c: Ditto.
	* cp-abi.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* defs.h: Ditto.
	* dfp.c: Ditto.
	* dfp.h: Ditto.
	* dictionary.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* eval.c: Ditto.
	* event-loop.c: Ditto.
	* event-loop.h: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-lang.c: Ditto.
	* f-valprint.c: Ditto.
	* findcmd.c: Ditto.
	* frame-base.c: Ditto.
	* frame-unwind.c: Ditto.
	* frame-unwind.h: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_dirent.h: Ditto.
	* gdb_obstack.h: Ditto.
	* gdbcore.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* inf-ttrace.c: Ditto.
	* infcall.c: Ditto.
	* infcmd.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* inline-frame.h: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* libunwind-frame.c: Ditto.
	* libunwind-frame.h: Ditto.
	* linespec.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-nat.h: Ditto.
	* linux-thread-db.c: Ditto.
	* machoread.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* memattr.c: Ditto.
	* minsyms.c: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* osabi.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* parse.c: Ditto.
	* printcmd.c: Ditto.
	* proc-events.c: Ditto.
	* procfs.c: Ditto.
	* progspace.c: Ditto.
	* progspace.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote-fileio.c: Ditto.
	* remote.c: Ditto.
	* ser-mingw.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* solib-frv.c: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solib-target.c: Ditto.
	* solib.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.c: Ditto.
	* stack.c: Ditto.
	* stack.h: Ditto.
	* symfile-mem.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target-descriptions.c: Ditto.
	* target-memory.c: Ditto.
	* target.c: Ditto.
	* target.h: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* ui-file.c: Ditto.
	* ui-file.h: Ditto.
	* ui-out.h: Ditto.
	* user-regs.c: Ditto.
	* user-regs.h: Ditto.
	* utils.c: Ditto.
	* valarith.c: Ditto.
	* valops.c: Ditto.
	* valprint.c: Ditto.
	* valprint.h: Ditto.
	* value.c: Ditto.
	* varobj.c: Ditto.
	* varobj.h: Ditto.
	* vec.h: Ditto.
	* xcoffread.c: Ditto.
	* xcoffsolib.c: Ditto.
	* xcoffsolib.h: Ditto.
	* xml-syscall.c: Ditto.
	* xml-tdesc.c: Ditto.
@
text
@d1541 3
a1543 3
      printf_filtered (_("Watchpoint %d deleted because "
			 "the program has left the block\n"
			 "in which its expression is valid.\n"),
@


1.523
log
@run copyright.sh for 2011.
@
text
@d271 3
a273 2
  fprintf_filtered (file, _("\
Debugger's willingness to use watchpoint hardware is %s.\n"),
d287 3
a289 2
  fprintf_filtered (file, _("\
Debugger's behavior regarding pending breakpoints is %s.\n"),
d303 2
a304 2
  fprintf_filtered (file, _("\
Automatic usage of hardware breakpoints is %s.\n"),
d329 3
a331 2
    fprintf_filtered (file, _("\
Always inserted breakpoint mode is %s (currently %s).\n"),
d335 2
a336 1
    fprintf_filtered (file, _("Always inserted breakpoint mode is %s.\n"), value);
d592 2
a593 1
	  printf_filtered (_("Convenience variable must have integer value.\n"));
d824 2
a825 1
	error (_("The 'while-stepping' command can only be used for tracepoints"));
d872 2
a873 2
		error (_("\
The 'while-stepping' command cannot be used for fast tracepoint"));
d875 2
a876 2
		error (_("\
The 'while-stepping' command cannot be used for static tracepoint"));
d879 2
a880 1
		error (_("The 'while-stepping' command can be used only once"));
d987 2
a988 1
	  str = xstrprintf (_("Type commands for breakpoint(s) %s, one per line."),
d1541 3
a1543 3
      printf_filtered (_("\
Watchpoint %d deleted because the program has left the block\n\
in which its expression is valid.\n"),
d1659 4
a1662 2
			  fprintf_filtered (gdb_stdout, _("\
Note: automatically using hardware breakpoints for read-only addresses.\n"));
d1669 2
a1670 1
		warning (_("cannot set software breakpoint at readonly address %s"),
d1712 2
a1713 1
					"Overlay breakpoint %d failed: in ROM?\n",
d1750 2
a1751 1
				      "Temporarily disabling shared library breakpoints:\n");
d1762 3
a1764 2
		  fprintf_unfiltered (tmp_error_stream, 
				      "Cannot insert hardware breakpoint %d.\n",
d2816 2
a2817 1
software_breakpoint_inserted_here_p (struct address_space *aspace, CORE_ADDR pc)
d3331 2
a3332 1
      printf_filtered (_("std::terminate Master Breakpoint: gdb should not stop!\n"));
d3338 2
a3339 1
      printf_filtered (_("Exception Master Breakpoint: gdb should not stop!\n"));
d3765 2
a3766 1
      ui_out_text (uiout, " deleted because the program has left the block in\n\
d3880 3
a3882 2
	  char *message = xstrprintf ("Error evaluating expression for watchpoint %d\n",
				      b->number);
d5093 2
a5094 1
      = make_cleanup_ui_out_table_begin_end (uiout, 6, nr_printable_breakpoints,
d5098 2
a5099 1
      = make_cleanup_ui_out_table_begin_end (uiout, 5, nr_printable_breakpoints,
d5986 2
a5987 1
	    warning (_("Temporarily disabling breakpoints for unloaded shared library \"%s\""),
d6212 2
a6213 1
              uintptr_t vec_addr_offset = old_size * ((uintptr_t) sizeof (int));
d6265 2
a6266 1
					VEC_address (int, inf->syscalls_counts));
d6866 2
a6867 1
	printf_filtered (_("(apparently deleted?) Eventpoint %d: "), b->number);
d7160 2
a7161 1
		  printf_filtered (_("Probed static tracepoint marker \"%s\"\n"),
d7169 2
a7170 1
		  printf_filtered (_("Probed static tracepoint marker \"%s\"\n"),
d7174 2
a7175 2
		warning (_("\
Couldn't determine the static tracepoint marker to probe"));
d7731 2
a7732 1
	      && !nquery (_("Make breakpoint pending on future shared library load? ")))
d7867 2
a7868 1
				type_wanted, tempflag ? disp_del : disp_donttouch,
d7906 2
a7907 2
      warning (_("Multiple breakpoints were set.\n"
		 "Use the \"delete\" command to delete unwanted breakpoints."));
d8382 2
a8383 1
	error (_("Target can only support one kind of HW watchpoint at a time."));
d9241 2
a9242 1
catch_assert_command (char *arg, int from_tty, struct cmd_list_element *command)
d9367 2
a9368 1
				    && strcmp (b->source_file, sal.symtab->filename) == 0
d9677 2
a9678 1
		  printf_filtered (_("warning: Error removing breakpoint %d\n"), 
d10257 2
a10258 1
	      warning (_("failed to reevaluate condition for breakpoint %d: %s"), 
d10385 2
a10386 2
	    sals = decode_line_1 (&s, 1, (struct symtab *) NULL, 0, (char ***) NULL,
				  not_found_ptr);
d10613 2
a10614 1
	    printf_filtered (_("Will stop next time breakpoint %d is reached."),
d10620 2
a10621 1
	    printf_filtered (_("Will ignore next %d crossings of breakpoint %d."),
d11334 2
a11335 1
      warning (_("Uploaded tracepoint %d has no source location, using raw address"),
d11343 2
a11344 1
    warning (_("Uploaded tracepoint %d condition has no source form, ignoring it"),
d11390 2
a11391 1
    warning (_("Uploaded tracepoint %d actions have no source form, ignoring them"),
d11492 2
a11493 1
    error (_("passcount command requires an argument (count + optional TP num)"));
d11520 2
a11521 1
		  printf_filtered (_("Setting tracepoint %d's passcount to %d\n"),
d11587 2
a11588 1
	printf_filtered (_("Tracepoint argument missing and no previous tracepoint\n"));
d11879 2
a11880 2
  printf_unfiltered (_("\
\"save\" must be followed by the name of a save subcommand.\n"));
@


1.522
log
@2010-12-29  Michael Snyder  <msnyder@@vmware.com>

	* bcache.c: Comment clean-up.
	* block.c: Ditto.
	* blockframe.c: Ditto.
	* breakpoint.c: Ditto.
	* bsd-kvm.c: Ditto.
	* buildsym.c: Ditto.
@
text
@d5 1
a5 1
   2008, 2009, 2010 Free Software Foundation, Inc.
@


1.521
log
@	gdb/
	* breakpoint.c (breakpoint_restore_shadows): When looking for the
	location with the lowest address that overlaps the memory range we
	want to restore shadows for, account for multiple locations at the
	same address.
@
text
@d79 1
a79 1
/* Prototypes for local functions. */
d107 2
a108 1
/* This function is used in gdbtk sources and thus can not be made static.  */
d253 3
a255 2
  /* NOTE: the following values are a part of MI protocol and represent
     values of 'disp' field returned when inferior stops at a breakpoint.  */
d261 1
a261 1
/* Prototypes for exported functions. */
d263 1
a263 1
   if such is available. */
d278 1
a278 1
   for unrecognized breakpoint locations.  
d292 1
a292 1
   set with "break" but falling in read-only memory. 
d351 2
a352 2
   ALL_BREAKPOINTS_SAFE does so even if the statment deletes the current
   breakpoint.  */
d361 3
a363 3
/* Similar iterator for the low-level breakpoints.  SAFE variant is not
   provided so update_global_location_list must not be called while executing
   the block of ALL_BP_LOCATIONS.  */
d388 5
a392 4
/* Maximum alignment offset between bp_target_info.PLACED_ADDRESS and ADDRESS
   for the current elements of BP_LOCATION which get a valid result from
   bp_location_has_shadow.  You can use it for roughly limiting the subrange of
   BP_LOCATION to scan for shadow bytes for an address you need to read.  */
d396 5
a400 5
/* Maximum offset plus alignment between
   bp_target_info.PLACED_ADDRESS + bp_target_info.SHADOW_LEN and ADDRESS for
   the current elements of BP_LOCATION which get a valid result from
   bp_location_has_shadow.  You can use it for roughly limiting the subrange of
   BP_LOCATION to scan for shadow bytes for an address you need to read.  */
d404 3
a406 3
/* The locations that no longer correspond to any breakpoint,
   unlinked from bp_location array, but for which a hit
   may still be reported by a target.  */
d466 1
a466 1
/* Used in run_command to zero the hit count when a new run starts. */
d537 1
a537 1
   if default_breakpoint_valid is zero, the other three are
d549 7
a555 6
/* *PP is a string denoting a breakpoint.  Get the number of the breakpoint.
   Advance *PP after the string and any trailing whitespace.

   Currently the string can either be a number or "$" followed by the name
   of a convenience variable.  Making it an expression wouldn't work well
   for map_breakpoint_numbers (e.g. "4 + 5 + 6").
d560 2
a561 1
   commonly this is `-'.  If you don't want a trailer, use \0.  */ 
d601 1
a601 1
	  /* Skip non-numeric token */
d604 1
a604 1
	  /* Return zero, which caller must interpret as error. */
d612 1
a612 1
      /* Trailing junk: return 0 and let caller print error msg. */
d632 13
a644 14
 * A number will be of the form handled by get_number.
 * A range will be of the form <number1> - <number2>, and 
 * will represent all the integers between number1 and number2,
 * inclusive.
 *
 * While processing a range, this fuction is called iteratively;
 * At each call it will return the next value in the range.
 *
 * At the beginning of parsing a range, the char pointer PP will
 * be advanced past <number1> and left pointing at the '-' token.
 * Subsequent calls will not advance the pointer until the range
 * is completed.  The call that completes the range will advance
 * pointer PP past <number2>.
 */
d677 1
a677 1
	      /* degenerate range (number1 == number2).  Advance the
d807 2
a808 2
   Throw if any such commands is found.
*/
d825 1
a825 1
	 lines and also empty lines. So, we only need to check for
d855 4
a858 4
      /* We need to verify that each top-level element of commands
	 is valid for tracepoints, that there's at most one while-stepping
	 element, and that while-stepping's body has valid tracing commands
	 excluding nested while-stepping.  */
d919 1
a919 2
   validate that only allowed commands are included.
*/
d922 2
a923 1
breakpoint_set_commands (struct breakpoint *b, struct command_line *commands)
d1011 2
a1012 1
commands_command_1 (char *arg, int from_tty, struct command_line *control)
d1027 2
a1028 1
	arg = xstrprintf ("%d-%d", prev_breakpoint_count + 1, breakpoint_count);
d1107 2
a1108 1
  /* Left boundary, right boundary and median element of our binary search.  */
d1111 3
a1113 2
  /* Find BC_L which is a leftmost element which may affect BUF content.  It is
     safe to report lower value but a failure to report higher one.  */
d1124 8
a1131 7
      /* Check first BL->ADDRESS will not overflow due to the added constant.
	 Then advance the left boundary only if we are sure the BC element can
	 in no way affect the BUF content (MEMADDR to MEMADDR + LEN range).

	 Use the BP_LOCATION_SHADOW_LEN_AFTER_ADDRESS_MAX safety offset so that
	 we cannot miss a breakpoint with its shadow range tail still reaching
	 MEMADDR.  */
d1199 1
a1199 1
         reading. */
d1280 41
a1320 2
   If the watchpoint disposition is disp_del_at_next_stop, then do nothing.
   If this is local watchpoint that is out of scope, delete it.
d1322 2
a1323 37
   Even with `set breakpoint always-inserted on' the watchpoints are removed
   + inserted on each stop here.  Normal breakpoints must never be removed
   because they might be missed by a running thread when debugging in non-stop
   mode.  On the other hand, hardware watchpoints (is_hardware_watchpoint;
   processed here) are specific to each LWP since they are stored in each LWP's
   hardware debug registers.  Therefore, such LWP must be stopped first in
   order to be able to modify its hardware watchpoints.

   Hardware watchpoints must be reset exactly once after being presented to the
   user.  It cannot be done sooner, because it would reset the data used to
   present the watchpoint hit to the user.  And it must not be done later
   because it could display the same single watchpoint hit during multiple GDB
   stops.  Note that the latter is relevant only to the hardware watchpoint
   types bp_read_watchpoint and bp_access_watchpoint.  False hit by
   bp_hardware_watchpoint is not user-visible - its hit is suppressed if the
   memory content has not changed.

   The following constraints influence the location where we can reset hardware
   watchpoints:

   * target_stopped_by_watchpoint and target_stopped_data_address are called
     several times when GDB stops.

   [linux]
   * Multiple hardware watchpoints can be hit at the same time, causing GDB to
     stop.  GDB only presents one hardware watchpoint hit at a time as the
     reason for stopping, and all the other hits are presented later, one after
     the other, each time the user requests the execution to be resumed.
     Execution is not resumed for the threads still having pending hit event
     stored in LWP_INFO->STATUS.  While the watchpoint is already removed from
     the inferior on the first stop the thread hit event is kept being reported
     from its cached value by linux_nat_stopped_data_address until the real
     thread resume happens after the watchpoint gets presented and thus its
     LWP_INFO->STATUS gets reset.

   Therefore the hardware watchpoint hit can get safely reset on the watchpoint
   removal from inferior.  */
d1338 3
a1340 3
  /* We don't free locations.  They are stored in bp_location array and
     update_global_locations will eventually delete them and remove
     breakpoints if needed.  */
d1433 4
a1436 3
	/* Change the type of breakpoint between hardware assisted or an
	   ordinary watchpoint depending on the hardware support and free
	   hardware slots.  REPARSE is set when the inferior is started.  */
d1442 6
a1447 6
	    /* We need to determine how many resources are already used
	       for all other hardware watchpoints to see if we still have
	       enough resources to also fit this watchpoint in as well.
	       To avoid the hw_watchpoint_used_count call below from counting
	       this watchpoint, make sure that it is marked as a software
	       watchpoint.  */
d1589 2
a1590 2
   NOTE drow/2003-09-09: This routine could be broken down to an object-style
   method for each breakpoint or catchpoint type.  */
d1615 1
d1620 4
a1623 3
	     - location type is hardware breakpoint, memory is read-write.
	     This means we've previously made the location hardware one, but
	     then the memory map changed, so we undo.
d1625 5
a1629 4
	     When breakpoints are removed, remove_breakpoints will
	     use location types we've just set here, the only possible
	     problem is that memory map has changed during running program,
	     but it's not going to work anyway with current gdb.  */
d1680 1
a1680 1
	  /* This breakpoint is in an overlay section.  
d1729 1
a1729 1
	      /* See also: disable_breakpoints_in_shlibs. */
d1776 1
a1776 1
	      watchpoints.  It's not clear that it's necessary... */
d1894 1
a1894 1
      update_watchpoint (bpt, 0 /* don't reparse. */);
d1934 3
a1936 3
      /* There is no point inserting thread-specific breakpoints if the
	 thread no longer exists.  ALL_BP_LOCATIONS bp_location has BL->OWNER
	 always non-NULL.  */
d1957 2
a1958 2
  /* If we failed to insert all locations of a watchpoint,
     remove them, as half-inserted watchpoint is of limited use.  */
d2131 1
a2131 1
  init_sal (&sal);		/* initialize to zeroes */
d2299 1
a2299 1
    /* Solib breakpoints must be explicitly reset after an exec(). */
d2306 1
a2306 1
    /* JIT breakpoints must be explicitly reset after an exec(). */
d2323 1
a2323 1
    /* Step-resume breakpoints are meaningless after an exec(). */
d2381 1
a2381 1
       a.out. */
d2470 1
a2470 1
	  /* This breakpoint is in an overlay section.  
d2528 2
a2529 1
				      bl->watchpoint_type, bl->owner->cond_exp);
d2598 1
a2598 1
   init_wait_for_inferior). */
d2669 2
a2670 2
	    /* Reset val field to force reread of starting value
	       in insert_breakpoints.  */
d2752 3
a2754 3
   inserted using regular breakpoint_chain / bp_location array mechanism.
   This does not check for single-step breakpoints, which are
   inserted and removed using direct target manipulation.  */
d2757 2
a2758 1
regular_breakpoint_inserted_here_p (struct address_space *aspace, CORE_ADDR pc)
d3003 1
a3003 1
/* Find the bpstat associated with this breakpoint */
d3019 5
a3023 4
/* Put in *NUM the breakpoint number of the first breakpoint we are stopped
   at.  *BSP upon return is a bpstat which points to the remaining
   breakpoints stopped at (but which is not guaranteed to be good for
   anything but further calls to bpstat_num).
d3037 3
a3039 4
  /* We assume we'll never have several bpstats that
     correspond to a single breakpoint -- otherwise, 
     this function might return the same number more
     than once and this will look ugly.  */
d3086 2
a3087 1
/* Stub for cleaning up our state if we error-out of a breakpoint command */
d3094 4
a3097 4
/* Execute all the commands associated with all the breakpoints at this
   location.  Any of these commands could cause the process to proceed
   beyond this point, etc.  We look out for such changes by checking
   the global "breakpoint_proceeded" after each command.
d3118 1
a3118 1
  /* This pointer will iterate over the list of bpstat's. */
d3224 1
a3224 1
   print_bp_stop_message function on each one. The behavior of the
d3226 1
a3226 1
   bpstat. If such field so indicates, call this function here.
d3296 1
a3296 1
      /* Not sure how we will get here. 
d3303 1
a3303 1
      /* By analogy with the thread event, GDB should not stop for these. */
d3392 1
a3392 1
       here. */
d3432 1
a3432 1
   stopped. The behavior of this function depends on the value
d3435 1
a3435 1
   normal_stop(). */
d3443 1
a3443 1
      /* Nothing should be printed for this bpstat entry. */
d3449 1
a3449 1
         relevant messages. */
d3482 1
a3482 1
   PRINT_UNKNOWN: Means we printed nothing
d3484 1
a3484 1
   code to print the location. An example is 
d3490 1
a3490 1
   don't require a location appended to the end.  
d3492 1
a3492 1
   further info to be printed.*/
d3513 1
a3513 1
     with and nothing was printed. */
d3517 4
a3520 4
/* Evaluate the expression EXP and return 1 if value is zero.
   This is used inside a catch_errors to evaluate the breakpoint condition. 
   The argument is a "struct expression *" that has been cast to char * to 
   make it pass through catch_errors.  */
d3625 2
a3626 1
/* Evaluate watchpoint condition expression and check if its value changed.
d3657 9
a3665 8
      /* in_function_epilogue_p() returns a non-zero value if we're still
	 in the function but the stack frame has already been invalidated.
	 Since we can't rely on the values of local variables after the
	 stack has been destroyed, we are treating the watchpoint in that
	 state as `not changed' without further checking.  Don't mark
	 watchpoints as changed if the current frame is in an epilogue -
	 even if they are in some other frame, our view of the stack
	 is likely to be wrong and frame_find_by_id could error out.  */
d3694 4
a3697 4
      /* We use value_{,free_to_}mark because it could be a
         *long* time before we return to the command level and
         call free_all_values.  We can't call free_all_values because
         we might be in the middle of evaluating a function call.  */
d3705 4
a3708 3
      /* We use value_equal_contents instead of value_equal because the latter
	 coerces an array to a pointer, thus comparing just the address of the
	 array instead of its contents.  This is not what we want.  */
d3741 2
a3742 2
	 will be deleted already. So we have no choice but print the
	 information here. */
d3884 1
a3884 1
		     1. we're watching the triggered memory for reads.
d3893 1
a3893 1
		     2. we're watching the triggered memory for both
d3897 1
a3897 1
		     2.1. this is a target that can't break on data
d3902 1
a3902 1
		     2.2. otherwise, the target supports read
d4068 1
a4068 1
	  /* FIXME-someday, should give breakpoint # */
d4085 1
a4085 2
	  /* Increase the hit count even though we don't
	     stop.  */
d4096 2
a4097 1
   don't understand this stop.  Result is a chain of bpstat's such that:
d4139 5
a4143 5
	  /* For hardware watchpoints, we look only at the first location.
	     The watchpoint_check function will work on the entire expression,
	     not the individual locations.  For read watchpoints, the
	     watchpoints_triggered function has checked all locations
	     already.  */
d4153 2
a4154 1
	  /* Come here if it's a watchpoint, or if the break address matches */
d4156 2
a4157 1
	  bs = bpstat_alloc (bl, &bs_link);	/* Alloc a bpstat to explain stop */
d4217 1
a4217 1
	      /* We will stop here */
d4256 1
a4256 1
	  update_watchpoint (bs->breakpoint_at, 0 /* don't reparse. */);
d4627 2
a4628 3
  /* See comment in print_one_breakpoint concerning
     treatment of breakpoints with single disabled
     location.  */
d4673 2
a4674 2
      ui_out_field_fmt (uiout, "enabled", "%c", 
 			bpenables[(int) b->enable_state]);
d4690 3
a4692 4
      /* Although the print_one can possibly print
	 all locations,  calling it here is not likely
	 to get any nice result.  So, make sure there's
	 just one location.  */
d4767 2
a4768 2
	      /* LOC is for existing B, it cannot be in moribund_locations and
		 thus having NULL OWNER.  */
d4795 1
a4795 1
	     "stop only in" line a little further down. */
d4845 1
a4845 1
      /* FIXME should make an annotation for this */
d4853 1
a4853 1
      /* FIXME should make an annotation for this */
d4866 2
a4867 2
  /* Output the count also if it is zero, but only if this is
     mi. FIXME: Should have a better test for this. */
d4913 2
a4914 1
		      struct bp_location **last_loc, int print_address_bits,
d4925 7
a4931 8
      /* If breakpoint has a single location that is
	 disabled, we print it as if it had
	 several locations, since otherwise it's hard to
	 represent "breakpoint enabled, location disabled"
	 situation.  
	 Note that while hardware watchpoints have
	 several locations internally, that's no a property
	 exposed to user.  */
d4995 2
a4996 1
gdb_breakpoint_query (struct ui_out *uiout, int bnum, char **error_message)
d5002 1
a5002 1
     an error. */
d5011 1
a5011 1
   catchpoints, et.al.). */
d5022 1
a5022 1
	
d5031 2
a5032 1
breakpoint_1 (int bnum, int allflag, int (*filter) (const struct breakpoint *))
d5044 2
a5045 2
  /* Compute the number of rows in the table, as well as the
     size required for address fields.  */
d5085 1
a5085 1
  ui_out_table_header (uiout, 7, ui_left, "number", "Num");		/* 1 */
d5089 1
a5089 1
		       "type", "Type");		/* 2 */
d5092 1
a5092 1
  ui_out_table_header (uiout, 4, ui_left, "disp", "Disp");		/* 3 */
d5101 2
a5102 1
	    ui_out_table_header (uiout, 10, ui_left, "addr", "Address");/* 5 */
d5104 2
a5105 1
	    ui_out_table_header (uiout, 18, ui_left, "addr", "Address");/* 5 */
d5125 1
a5125 1
	   allflag is set. */
d5136 2
a5137 1
      /* If there's a filter, let the caller decide how to report empty list.  */
d5143 2
a5144 1
	    ui_out_message (uiout, 0, "No breakpoint or watchpoint number %d.\n",
d5154 1
a5154 1
  /* FIXME? Should this be moved up so that it is only called when
d5308 4
a5311 3
   More specifically, each of the following breakpoint types will always
   have a zero valued address and we don't want to mark breakpoints of any of
   these types to be a duplicate of an actual breakpoint at address zero:
d5330 2
a5331 1
watchpoint_locations_match (struct bp_location *loc1, struct bp_location *loc2)
d5337 6
a5342 5
  /* If the target can evaluate the condition expression in hardware, then we
     we need to insert both watchpoints even if they are at the same place.
     Otherwise the watchpoint will only trigger when the condition of whichever
     watchpoint was inserted evaluates to true, not giving a chance for GDB to
     check the condition of the other watchpoint.  */
d5344 2
a5345 1
       && target_can_accel_watchpoint_condition (loc1->address, loc1->length,
d5349 2
a5350 1
	  && target_can_accel_watchpoint_condition (loc2->address, loc2->length,
d5386 2
a5387 1
breakpoint_locations_match (struct bp_location *loc1, struct bp_location *loc2)
d5423 4
a5426 4
/* Adjust a breakpoint's address to account for architectural constraints
   on breakpoint placement.  Return the adjusted address.  Note: Very
   few targets require this kind of adjustment.  For most targets,
   this function is simply the identity function.  */
d5558 4
a5561 3
/* Helper to set_raw_breakpoint below.  Creates a breakpoint
   that has type BPTYPE and has no locations as yet.  */
/* This function is used in gdbtk sources and thus can not be made static.  */
d5590 2
a5591 3
  /* Add this breakpoint to the end of the chain
     so that a list of breakpoints will come out in order
     of increasing numbers.  */
d5653 2
a5654 1
  struct breakpoint *b = set_raw_breakpoint_without_location (gdbarch, bptype);
d5671 2
a5672 1
  adjusted_address = adjust_breakpoint_address (loc_gdbarch, sal.pc, b->type);
d5708 5
a5712 5
  /* By definition, permanent breakpoints are already present in the code. 
     Mark all locations as inserted.  For now, make_breakpoint_permanent
     is called in just one place, so it's hard to say if it's reasonable
     to have permanent breakpoint with multiple locations or not,
     but it's easy to implmement.  */
d5902 5
a5906 5
    /* We apply the check to all breakpoints, including disabled
       for those with loc->duplicate set.  This is so that when breakpoint
       becomes enabled, or the duplicate is removed, gdb will try to insert
       all breakpoints.  If we don't set shlib_disabled here, we'll try
       to insert those breakpoints and fail.  */
d5925 3
a5927 2
/* Disable any breakpoints that are in in an unloaded shared library.  Only
   apply to enabled breakpoints, disabled ones can just stay disabled.  */
d5975 2
a5976 1
/* Implement the "insert" breakpoint_ops method for fork catchpoints.  */
d5984 2
a5985 1
/* Implement the "remove" breakpoint_ops method for fork catchpoints.  */
d6002 2
a6003 1
/* Implement the "print_it" breakpoint_ops method for fork catchpoints.  */
d6014 2
a6015 1
/* Implement the "print_one" breakpoint_ops method for fork catchpoints.  */
d6024 3
a6026 3
  /* Field 4, the address, is omitted (which makes the columns
     not line up too nicely with the headers, but the effect
     is relatively readable).  */
d6071 2
a6072 1
/* Implement the "insert" breakpoint_ops method for vfork catchpoints.  */
d6080 2
a6081 1
/* Implement the "remove" breakpoint_ops method for vfork catchpoints.  */
d6098 2
a6099 1
/* Implement the "print_it" breakpoint_ops method for vfork catchpoints.  */
d6110 2
a6111 1
/* Implement the "print_one" breakpoint_ops method for vfork catchpoints.  */
d6119 3
a6121 3
  /* Field 4, the address, is omitted (which makes the columns
     not line up too nicely with the headers, but the effect
     is relatively readable).  */
d6251 3
a6253 3
  /* We must check if we are catching specific syscalls in this breakpoint.
     If we are, then we must guarantee that the called syscall is the same
     syscall we are catching.  */
d6328 3
a6330 3
  /* Field 4, the address, is omitted (which makes the columns
     not line up too nicely with the headers, but the effect
     is relatively readable).  */
d6753 3
a6755 3
  /* If we're debugging a multi-threaded program, then we
     want momentary breakpoints to be active in only a 
     single thread of control.  */
d7297 4
a7300 3
      /* This is un ugly workaround. If we get zero
       expanded sals then something is really wrong.
      Fix that by returnign the original sal. */
d7337 1
a7337 1
   COND and SALS arrays and each of those arrays contents. */
d7364 2
a7365 2
   addresses found. ADDR_STRING contains a vector of (canonical)
   address strings. ARG points to the end of the SAL. */
d7377 1
a7377 1
     breakpoint. */
d7385 1
a7385 1
	  init_sal (&sal);		/* initialize to zeroes */
d7394 5
a7398 5
	  /* "break" without arguments is equivalent to "break *PC" where PC is
	     the default_breakpoint_address.  So make sure to set
	     sal.explicit_pc to prevent GDB from trying to expand the list of
	     sals to include all other instances with the same symtab and line.
	   */
d7410 4
a7413 3
         current_source_symtab (which is decode_line_1's default).  This
         should produce the results we want almost all of the time while
         leaving default_breakpoint_* alone.  
d7430 1
a7430 1
  /* For any SAL that didn't have a canonical string, fill one in. */
d7439 1
a7439 1
	  /* Add the string if not present. */
d7449 1
a7449 1
   inserted as a breakpoint.  If it can't throw an error. */
d7504 1
a7504 1
   PC identifies the context at which the condition should be parsed.  
d7626 6
a7631 6
   breakpoint location, address and thread. Otherwise, ARG is just the
   location of breakpoint, with condition and thread specified by the
   COND_STRING and THREAD parameters.  If INTERNAL is non-zero, the
   breakpoint number will be allocated from the internal breakpoint
   count.  Returns true if any breakpoint was created; false
   otherwise.  */
d7728 1
a7728 1
  /* Create a chain of things that always need to be cleaned up. */
d7736 1
a7736 1
      /* Cleanup the addr_string array but not its contents. */
d7765 1
a7765 1
     breakpoint. */
d7936 2
a7937 2
      /* If this SAL corresponds to a breakpoint inserted using
         a line number, then skip the function prologue if necessary.  */
d7959 4
a7962 4
	      /* It really is worthwhile to have the section, so we'll just
	         have to look harder. This case can be executed if we have 
	         line numbers but no functions (as can happen in assembly 
	         source).  */
d8023 1
a8023 1
      /* look for a ':'.  If this is a line number specification, then
d8025 1
a8025 1
         function/method name */
d8056 2
a8057 2
      /* look for a ':'.  If there is a '::' then get out, otherwise
         it is probably a line number. */
d8076 4
a8079 3
/*  Return non-zero if EXP is verified as constant.  Returned zero means EXP is
    variable.  Also the constant detection may fail for some constant
    expressions and in such case still falsely return zero.  */
d8144 8
a8151 7
	  /* Unary, binary and ternary operators: We have to check their
	     operands.  If they are constant, then so is the result of
	     that operation.  For instance, if A and B are determined to be
	     constants, then so is "A + B".

	     UNOP_IND is one exception to the rule above, because the value
	     of *ADDR is not necessarily a constant, even when ADDR is.  */
d8156 1
d8158 6
a8163 5
	     possible that a buggy compiler could mark a variable as constant
	     even when it is not, and TYPE_CONST would return true in this
	     case, while SYMBOL_CLASS wouldn't.
	     We also have to check for function symbols because they are
	     always constant.  */
d8217 3
a8219 3
      /* Go backwards in the parameters list. Skip the last parameter.
         If we're expecting a 'thread <thread_num>' parameter, this should
         be the thread identifier.  */
d8228 3
a8230 3
      /* Go backwards in the parameters list. Skip one more parameter.
         If we're expecting a 'thread <thread_num>' parameter, we should
         reach a "thread" token.  */
d8356 2
a8357 2
  /* Change the type of breakpoint to an ordinary watchpoint if a hardware
     watchpoint could not be set.  */
d8466 3
a8468 3
/* Return count of locations need to be watched and can be handled
   in hardware.  If the watchpoint can not be handled
   in hardware return zero.  */
d8629 1
a8629 1
   cmd_continuation pointer, to complete the until command. It takes
d8631 1
a8631 1
   command. */
d8658 1
a8658 1
     this function */
d8671 1
a8671 1
  xfree (sals.sals);	/* malloc'd, so freed */
d8684 2
a8685 2
    /* Otherwise, specify the selected frame, because we want to stop only
       at the very same frame.  */
d8714 4
a8717 4
  /* If we are running asynchronously, and proceed call above has actually
     managed to start the target, arrange for breakpoints to be
     deleted when the target stops.  Otherwise, we're already stopped and
     delete breakpoints via cleanup chain.  */
d8752 1
a8752 1
   if clause in the arg string. */
d8762 1
a8762 1
  /* Skip the "if" keyword. */
d8766 1
a8766 1
     condition string. */
d8770 2
a8771 1
  /* Assume that the condition occupies the remainder of the arg string. */
d8808 1
a8808 1
     First, check if there's an if clause. */
d8815 1
a8815 1
     and enable reporting of such events. */
d8852 1
a8852 1
     First, check if there's an if clause. */
d8859 1
a8859 1
     and enable reporting of such events. */
d8939 2
a8940 1
print_recreate_exception_catchpoint (struct breakpoint *b, struct ui_file *fp)
d8985 1
a8985 1
/* Deal with "catch catch" and "catch throw" commands */
d9059 1
a9059 1
         unproductive.  Besides. the warning phrasing is also a bit
d9153 3
a9155 3
	    /* Here we have to issue an error instead of a warning, because
	       GDB cannot do anything useful if there's no syscall number to
	       be caught.  */
d9264 1
a9264 1
      init_sal (&sal);		/* initialize to zeroes */
d9278 4
a9281 5
  /* We don't call resolve_sal_pc here. That's not
     as bad as it seems, because all existing breakpoints
     typically have both file/line and pc set.  So, if
     clear is given file/line, we can match this to existing
     breakpoint without obtaining pc at all.
d9285 1
a9285 1
     at file:line. There were several PC values for that file:line,
d9287 2
a9288 1
     We've picked one PC value. If "clear" is issued with another
d9295 4
a9298 4
  /* For each line spec given, delete bps which correspond
     to it.  Do it in two passes, solely to preserve the current
     behavior that from_tty is forced true if we delete more than
     one breakpoint.  */
d9317 1
a9317 2
      /* Find all matching breakpoints and add them to
	 'found'.  */
d9321 1
a9321 1
	  /* Are we going to delete b? */
d9360 1
a9360 1
    from_tty = 1;		/* Always report if deleted more than one */
d9402 6
a9407 5
/* A comparison function for bp_location AP and BP being interfaced to qsort.
   Sort elements primarily by their ADDRESS (no matter what does
   breakpoint_address_is_meaningful say for its OWNER), secondarily by ordering
   first bp_permanent OWNERed elements and terciarily just ensuring the array
   is sorted stable way despite qsort being an instable algorithm.  */
d9425 2
a9426 2
  /* Make the user-visible order stable across GDB runs.  Locations of the same
     breakpoint can be sorted in arbitrary order.  */
d9436 2
a9437 2
   bp_location_shadow_len_after_address_max according to the current content of
   the bp_location array.  */
d9504 2
a9505 2
  /* Saved former bp_location array which we compare against the newly built
     bp_location from the current state of ALL_BREAKPOINTS.  */
d9529 6
a9534 5
  /* Identify bp_location instances that are no longer present in the new
     list, and therefore should be freed.  Note that it's not necessary that
     those locations should be removed from inferior -- if there's another
     location at the same address (previously marked as duplicate),
     we don't need to remove/insert the location.
d9536 2
a9537 2
     LOCP is kept in sync with OLD_LOCP, each pointing to the current and
     former bp_location array state respectively.  */
d9546 2
a9547 2
      /* Tells if 'old_loc' is found amoung the new locations.  If not, we
	 have to free it.  */
d9553 2
a9554 2
      /* Skip LOCP entries which will definitely never be needed.  Stop either
	 at or being the one matching OLD_LOC.  */
d9571 5
a9575 5
      /* If this location is no longer present, and inserted, look if there's
	 maybe a new location at the same address.  If so, mark that one 
	 inserted, and don't remove this one.  This is needed so that we 
	 don't have a time window where a breakpoint at certain location is not
	 inserted.  */
d9579 2
a9580 1
	  /* If the location is inserted now, we might have to remove it.  */
d9584 2
a9585 2
	      /* The location is still present in the location list, and still
		 should be inserted.  Don't do anything.  */
d9590 4
a9593 3
	      /* The location is either no longer present, or got disabled.
		 See if there's another location at the same address, in which 
		 case we don't need to remove this one from the target.  */
d9608 2
a9609 1
			     Duplicates check below will fix up this later.  */
d9637 4
a9640 4
		  /* This is just about all we can do.  We could keep this
		     location on the global list, and try to remove it next
		     time, but there's no particular reason why we will
		     succeed next time.  
d9642 3
a9644 3
		     Note that at this point, old_loc->owner is still valid,
		     as delete_breakpoint frees the breakpoint only
		     after calling us.  */
d9732 2
a9733 1
      /* ALL_BP_LOCATIONS bp_location has LOC->OWNER always non-NULL.  */
d9847 16
a9862 13
  /* Has this bp already been deleted?  This can happen because multiple
     lists can hold pointers to bp's.  bpstat lists are especial culprits.

     One example of this happening is a watchpoint's scope bp.  When the
     scope bp triggers, we notice that the watchpoint is out of scope, and
     delete it.  We also delete its scope bp.  But the scope bp is marked
     "auto-deleting", and is already on a bpstat.  That bpstat is then
     checked for auto-deleting bp's, which are deleted.

     A real solution to this problem might involve reference counts in bp's,
     and/or giving them pointers back to their referencing bpstat's, and
     teaching delete_breakpoint to only free a bp's storage when no more
     references were extent.  A cheaper bandaid was chosen.  */
d9866 2
a9867 2
  /* At least avoid this stale reference until the reference counting of
     breakpoints gets resolved.  */
d9913 6
a9918 8
  /* Now that breakpoint is removed from breakpoint
     list, update the global location list.  This
     will remove locations that used to belong to
     this breakpoint.  Do this before freeing
     the breakpoint itself, since remove_breakpoint
     looks at location's owner.  It might be better
     design to have location completely self-contained,
     but it's not the case now.  */
d9922 2
a9923 2
  /* On the chance that someone will soon try again to delete this same
     bp, we mark it as deleted before freeing its storage. */
d9962 2
a9963 2
         Do not delete internal or call-dummy breakpoints, these
         have to be deleted with an explicit breakpoint number argument.  */
d10039 2
a10040 2
      /* NOTE: We can assume slot != NULL here because xcalloc never returns
	 NULL.  */
d10194 6
a10199 7
  /* If there's no new locations, and all existing locations
     are pending, don't do anything.  This optimizes
     the common case where all locations are in the same
     shared library, that was unloaded. We'd like to
     retain the location, so that when the library
     is loaded again, we don't loose the enabled/disabled
     status of the individual locations.  */
d10245 2
a10246 1
  /* If possible, carry over 'disable' status from existing breakpoints.  */
d10295 1
a10295 1
  /* get past catch_errs */
d10323 1
a10323 1
	  /* Anything without a string can't be re-set. */
d10357 7
a10363 6
	  /* For pending breakpoints, it's expected that parsing
	     will fail until the right shared library is loaded.
	     User has already told to create pending breakpoints and
	     don't need extra messages.  If breakpoint is in bp_shlib_disabled
	     state, then user already saw the message about that breakpoint
	     being disabled, and don't want to see more errors.  */
d10417 2
a10418 2
      /* Watchpoint can be either on expression using entirely global variables,
	 or it can be on local variables.
d10420 12
a10431 11
	 Watchpoints of the first kind are never auto-deleted, and even persist
	 across program restarts. Since they can use variables from shared 
	 libraries, we need to reparse expression as libraries are loaded
	 and unloaded.

	 Watchpoints on local variables can also change meaning as result
	 of solib event. For example, if a watchpoint uses both a local and
	 a global variables in expression, it's a local watchpoint, but
	 unloading of a shared library will make the expression invalid.
	 This is not a very common use case, but we still re-evaluate
	 expression, to avoid surprises to the user. 
d10435 2
a10436 2
	 the watchpoint is out of scope and will be deleted soon. In fact,
	 I'm not sure we'll ever be called in this case.  
d10439 1
a10439 1
	 b->exp_valid_block is likewise valid, and we can safely use it.  
d10447 1
a10447 1
         loaded. */
d10471 5
a10475 4
      /* Keep temporary breakpoints, which can be encountered when we step
         over a dlopen call and SOLIB_ADD is resetting the breakpoints.
         Otherwise these should have been blown away via the cleanup chain
         or by breakpoint_init_inferior when we rerun the executable.  */
d10509 1
a10509 1
    /* Format possible error msg */
d10535 1
a10535 1
   - Else, reset it to the current thread for inferior_ptid. */
d10999 2
a11000 1
/* Remove a breakpoint BP inserted by deprecated_insert_raw_breakpoint.  */
d11014 2
a11015 1
/* One (or perhaps two) breakpoints used for software single stepping.  */
d11024 2
a11025 1
			       struct address_space *aspace, CORE_ADDR next_pc)
d11041 6
a11046 6
  /* NOTE drow/2006-04-11: A future improvement to this function would be
     to only create the breakpoints once, and actually put them on the
     breakpoint chain.  That would let us use set_raw_breakpoint.  We could
     adjust the addresses each time they were needed.  Doing this requires
     corresponding changes elsewhere where single step breakpoints are
     handled, however.  So, for now, we use this.  */
d11120 2
a11121 1
/* Check whether a software single-step breakpoint is inserted at PC.  */
d11382 1
a11382 1
/* The 'enable trace' command enables tracepoints.  
d11390 1
a11390 1
/* The 'disable trace' command disables tracepoints.  
d11398 1
a11398 1
/* Remove a tracepoint (or all if no argument) */
d11412 2
a11413 1
         have to be deleted with an explicit breakpoint number argument.  */
d11455 1
a11455 1
  count = strtoul (args, &args, 10);	/* Count comes first, then TP num. */
d11773 4
a11776 3
/* This help string is used for the break, hbreak, tbreak and thbreak commands.
   It is defined as a macro to prevent duplication.
   COMMAND should be a string constant containing the name of the command.  */
@


1.520
log
@	Code cleanup - renaming.
	* breakpoint.c: Use bl for `*bp_location' variables, blp_tmp for
	`**bp_location' helper variables, b_tmp for `*breakpoint' helper
	variables.
@
text
@d1133 17
@


1.519
log
@gdb
	PR c++/9593:
	* thread.c (clear_thread_inferior_resources): Call
	delete_longjmp_breakpoint.
	* infrun.c (handle_inferior_event): Handle exception breakpoints.
	(handle_inferior_event): Likewise.
	(insert_exception_resume_breakpoint): New function.
	(check_exception_resume): Likewise.
	* inferior.h (delete_longjmp_breakpoint_cleanup): Declare.
	* infcmd.c (delete_longjmp_breakpoint_cleanup): No longer static.
	(step_1): Set thread's initiating frame.
	(until_next_continuation): New function.
	(until_next_command): Support exception breakpoints.
	(finish_command_continuation): Delete longjmp breakpoint.
	(finish_forward): Support exception breakpoints.
	* gdbthread.h (struct thread_info) <initiating_frame>: New field.
	* breakpoint.h (enum bptype) <bp_exception, bp_exception_resume,
	bp_exception_master>: New constants.
	(struct bpstat_what) <is_longjmp>: New field.
	(set_longjmp_breakpoint): Update.
	* breakpoint.c (create_exception_master_breakpoint): New function.
	(update_breakpoints_after_exec): Handle bp_exception_master.  Call
	create_exception_master_breakpoint.
	(print_it_typical): Handle bp_exception_master, bp_exception.
	(bpstat_stop_status): Handle bp_exception_master.
	(bpstat_what): Handle bp_exception_master, bp_exception,
	bp_exception_resume.
	(bptype_string): Likewise.
	(print_one_breakpoint_location): Likewise.
	(allocate_bp_location): Likewise.
	(set_longjmp_breakpoint): Handle exception breakpoints.  Change
	interface.
	(delete_longjmp_breakpoint): Handle exception breakpoints.
	(mention): Likewise.
	(struct until_break_command_continuation_args) <thread_num>: New
	field.
	(until_break_command_continuation): Call
	delete_longjmp_breakpoint.
	(until_break_command): Support exception breakpoints.
	(delete_command): Likewise.
	(breakpoint_re_set_one): Likewise.
	(breakpoint_re_set): Likewise.
gdb/testuite
	* gdb.java/jnpe.java: New file.
	* gdb.java/jnpe.exp: New file.
	* gdb.cp/nextoverthrow.exp: New file.
	* gdb.cp/nextoverthrow.cc: New file.
@
text
@d1088 2
a1089 2
     b->address - bp_location_placed_address_before_address_max
     up to b->address + bp_location_shadow_len_after_address_max
d1093 2
a1094 1
     memaddr + len <= b->address - bp_location_placed_address_before_address_max
d1096 1
a1096 1
     b->address + bp_location_shadow_len_after_address_max <= memaddr  */
d1111 1
a1111 1
      struct bp_location *b;
d1114 1
a1114 1
      b = bp_location[bc];
d1116 1
a1116 1
      /* Check first B->ADDRESS will not overflow due to the added constant.
d1124 4
a1127 2
      if (b->address + bp_location_shadow_len_after_address_max >= b->address
	  && b->address + bp_location_shadow_len_after_address_max <= memaddr)
d1137 1
a1137 1
    struct bp_location *b = bp_location[bc];
d1142 2
a1143 2
    /* bp_location array has B->OWNER always non-NULL.  */
    if (b->owner->type == bp_none)
d1145 1
a1145 1
              b->owner->number);
d1150 3
a1152 3
    if (b->address >= bp_location_placed_address_before_address_max
        && memaddr + len <= b->address
			    - bp_location_placed_address_before_address_max)
d1155 1
a1155 1
    if (!bp_location_has_shadow (b))
d1157 1
a1157 1
    if (!breakpoint_address_match (b->target_info.placed_address_space, 0,
d1163 2
a1164 2
    bp_addr = b->target_info.placed_address;
    bp_size = b->target_info.shadow_len;
d1192 1
a1192 1
	    b->target_info.shadow_contents + bptoffset, bp_size);
d1524 1
a1524 1
should_be_inserted (struct bp_location *bpt)
d1526 1
a1526 1
  if (bpt->owner == NULL || !breakpoint_enabled (bpt->owner))
d1529 1
a1529 1
  if (bpt->owner->disposition == disp_del_at_next_stop)
d1532 1
a1532 1
  if (!bpt->enabled || bpt->shlib_disabled || bpt->duplicate)
d1543 1
a1543 1
  if (bpt->pspace->breakpoints_not_allowed)
d1548 1
a1548 1
  if (is_tracepoint (bpt->owner))
d1554 3
a1556 3
/* Insert a low-level "breakpoint" of some type.  BPT is the breakpoint.
   Any error messages are printed to TMP_ERROR_STREAM; and DISABLED_BREAKS,
   and HW_BREAKPOINT_ERROR are used to report problems.
d1561 1
a1561 1
insert_bp_location (struct bp_location *bpt,
d1568 1
a1568 1
  if (!should_be_inserted (bpt) || bpt->inserted)
d1572 3
a1574 3
  memset (&bpt->target_info, 0, sizeof (bpt->target_info));
  bpt->target_info.placed_address = bpt->address;
  bpt->target_info.placed_address_space = bpt->pspace->aspace;
d1576 2
a1577 2
  if (bpt->loc_type == bp_loc_software_breakpoint
      || bpt->loc_type == bp_loc_hardware_breakpoint)
d1579 1
a1579 1
      if (bpt->owner->type != bp_hardware_breakpoint)
d1597 1
a1597 1
	    = lookup_mem_region (bpt->target_info.placed_address);
d1610 1
a1610 1
		  if (new_type != bpt->loc_type)
d1614 1
a1614 1
		      bpt->loc_type = new_type;
d1623 1
a1623 1
	      else if (bpt->loc_type == bp_loc_software_breakpoint
d1626 1
a1626 1
			 paddress (bpt->gdbarch, bpt->address));
d1632 2
a1633 2
	  || bpt->section == NULL
	  || !(section_is_overlay (bpt->section)))
d1637 3
a1639 3
	  if (bpt->loc_type == bp_loc_hardware_breakpoint)
	    val = target_insert_hw_breakpoint (bpt->gdbarch,
					       &bpt->target_info);
d1641 2
a1642 2
	    val = target_insert_breakpoint (bpt->gdbarch,
					    &bpt->target_info);
d1653 1
a1653 1
	      if (bpt->loc_type == bp_loc_hardware_breakpoint)
d1655 1
a1655 1
			 bpt->owner->number);
d1658 2
a1659 2
		  CORE_ADDR addr = overlay_unmapped_address (bpt->address,
							     bpt->section);
d1661 4
a1664 4
		  bpt->overlay_target_info = bpt->target_info;
		  bpt->overlay_target_info.placed_address = addr;
		  val = target_insert_breakpoint (bpt->gdbarch,
						  &bpt->overlay_target_info);
d1668 1
a1668 1
					bpt->owner->number);
d1672 1
a1672 1
	  if (section_is_mapped (bpt->section))
d1675 3
a1677 3
	      if (bpt->loc_type == bp_loc_hardware_breakpoint)
		val = target_insert_hw_breakpoint (bpt->gdbarch,
						   &bpt->target_info);
d1679 2
a1680 2
		val = target_insert_breakpoint (bpt->gdbarch,
						&bpt->target_info);
d1693 1
a1693 1
	  if (solib_name_from_address (bpt->pspace, bpt->address))
d1697 1
a1697 1
	      bpt->shlib_disabled = 1;
d1702 1
a1702 1
				      bpt->owner->number);
d1708 1
a1708 1
				  "breakpoint #%d\n", bpt->owner->number);
d1712 1
a1712 1
	      if (bpt->loc_type == bp_loc_hardware_breakpoint)
d1717 1
a1717 1
				      bpt->owner->number);
d1723 1
a1723 1
				      bpt->owner->number);
d1726 1
a1726 1
		  fputs_filtered (paddress (bpt->gdbarch, bpt->address),
d1735 1
a1735 1
	bpt->inserted = 1;
d1740 1
a1740 1
  else if (bpt->loc_type == bp_loc_hardware_watchpoint
d1743 1
a1743 1
	   && bpt->owner->disposition != disp_del_at_next_stop)
d1745 4
a1748 4
      val = target_insert_watchpoint (bpt->address,
				      bpt->length,
				      bpt->watchpoint_type,
				      bpt->owner->cond_exp);
d1752 1
a1752 1
      if (val == 1 && bpt->watchpoint_type == hw_read)
d1760 1
a1760 1
	    if (loc != bpt
d1762 1
a1762 1
		&& watchpoint_locations_match (bpt, loc))
d1764 4
a1767 4
		bpt->duplicate = 1;
		bpt->inserted = 1;
		bpt->target_info = loc->target_info;
		bpt->watchpoint_type = hw_access;
d1774 2
a1775 2
	      val = target_insert_watchpoint (bpt->address,
					      bpt->length,
d1777 1
a1777 1
					      bpt->owner->cond_exp);
d1779 1
a1779 1
		bpt->watchpoint_type = hw_access;
d1783 1
a1783 1
      bpt->inserted = (val == 0);
d1786 1
a1786 1
  else if (bpt->owner->type == bp_catchpoint)
d1789 1
a1789 1
						bpt->owner, RETURN_MASK_ERROR);
d1791 1
a1791 1
			 bpt->owner->number);
d1793 1
a1793 1
	bpt->owner->enable_state = bp_disabled;
d1795 1
a1795 1
	bpt->inserted = 1;
d1880 1
a1880 1
  struct bp_location *b, **bp_tmp;
d1895 1
a1895 1
  ALL_BP_LOCATIONS (b, bp_tmp)
d1897 1
a1897 1
      if (!should_be_inserted (b) || b->inserted)
d1901 1
a1901 1
	 thread no longer exists.  ALL_BP_LOCATIONS bp_location has B->OWNER
d1903 2
a1904 2
      if (b->owner->thread != -1
	  && !valid_thread_id (b->owner->thread))
d1907 1
a1907 1
      switch_to_program_space_and_thread (b->pspace);
d1917 1
a1917 2
      val = insert_bp_location (b, tmp_error_stream,
				    &disabled_breaks,
d1979 1
a1979 1
  struct bp_location *b, **bp_tmp;
d1982 1
a1982 1
  ALL_BP_LOCATIONS (b, bp_tmp)
d1984 2
a1985 2
    if (b->inserted)
      val |= remove_breakpoint (b, mark_uninserted);
d1995 1
a1995 1
  struct bp_location *b, **b_tmp;
d1999 1
a1999 1
  ALL_BP_LOCATIONS (b, b_tmp)
d2001 1
a2001 1
    if (b->pspace != inf->pspace)
d2004 1
a2004 1
    if (b->inserted)
d2006 1
a2006 1
	val = remove_breakpoint (b, mark_uninserted);
d2017 1
a2017 1
  struct bp_location *b, **bp_tmp;
d2020 1
a2020 1
  ALL_BP_LOCATIONS (b, bp_tmp)
d2022 2
a2023 2
    if (b->inserted && b->loc_type == bp_loc_hardware_watchpoint)
      val |= remove_breakpoint (b, mark_uninserted);
d2032 1
a2032 1
  struct bp_location *b, **bp_tmp;
d2050 1
a2050 1
  ALL_BP_LOCATIONS (b, bp_tmp)
d2052 1
a2052 1
    if (b->pspace != inf->pspace)
d2055 1
a2055 1
    if (b->inserted)
d2057 2
a2058 3
	b->inserted = 0;
	val = insert_bp_location (b, tmp_error_stream,
				  &dummy1, &dummy2);
d2245 1
a2245 2
  struct breakpoint *b;
  struct breakpoint *temp;
d2260 1
a2260 1
  ALL_BREAKPOINTS_SAFE (b, temp)
d2367 1
a2367 1
  struct bp_location *b, **bp_tmp;
d2377 1
a2377 1
  ALL_BP_LOCATIONS (b, bp_tmp)
d2379 1
a2379 1
    if (b->pspace != inf->pspace)
d2382 2
a2383 2
    if (b->inserted)
      val |= remove_breakpoint_1 (b, mark_inserted);
d2393 1
a2393 1
/* Remove the breakpoint location B from the current address space.
d2397 1
a2397 1
   *not* look at b->pspace->aspace here.  */
d2400 1
a2400 1
remove_breakpoint_1 (struct bp_location *b, insertion_state_t is)
d2404 2
a2405 2
  /* B is never in moribund_locations by our callers.  */
  gdb_assert (b->owner != NULL);
d2407 1
a2407 1
  if (b->owner->enable_state == bp_permanent)
d2413 1
a2413 1
  gdb_assert (b->owner->type != bp_none);
d2415 2
a2416 2
  if (b->loc_type == bp_loc_software_breakpoint
      || b->loc_type == bp_loc_hardware_breakpoint)
d2424 2
a2425 2
	  || b->section == NULL
	  || !(section_is_overlay (b->section)))
d2429 2
a2430 2
	  if (b->loc_type == bp_loc_hardware_breakpoint)
	    val = target_remove_hw_breakpoint (b->gdbarch, &b->target_info);
d2432 1
a2432 1
	    val = target_remove_breakpoint (b->gdbarch, &b->target_info);
d2445 3
a2447 3
		if (b->loc_type == bp_loc_hardware_breakpoint)
		  target_remove_hw_breakpoint (b->gdbarch,
					       &b->overlay_target_info);
d2449 2
a2450 2
		  target_remove_breakpoint (b->gdbarch,
					    &b->overlay_target_info);
d2454 1
a2454 1
	  if (b->inserted)
d2460 3
a2462 3
	      if (b->loc_type == bp_loc_hardware_breakpoint)
		val = target_remove_hw_breakpoint (b->gdbarch,
						   &b->target_info);
d2467 3
a2469 3
	      else if (section_is_mapped (b->section))
		val = target_remove_breakpoint (b->gdbarch,
						&b->target_info);
d2483 1
a2483 1
      if (val && solib_name_from_address (b->pspace, b->address))
d2488 1
a2488 1
      b->inserted = (is == mark_inserted);
d2490 1
a2490 1
  else if (b->loc_type == bp_loc_hardware_watchpoint)
d2492 3
a2494 3
      b->inserted = (is == mark_inserted);
      val = target_remove_watchpoint (b->address, b->length,
				      b->watchpoint_type, b->owner->cond_exp);
d2497 1
a2497 1
      if ((is == mark_uninserted) && (b->inserted))
d2499 1
a2499 1
		 b->owner->number);
d2501 3
a2503 3
  else if (b->owner->type == bp_catchpoint
           && breakpoint_enabled (b->owner)
           && !b->duplicate)
d2505 1
a2505 1
      gdb_assert (b->owner->ops != NULL && b->owner->ops->remove != NULL);
d2507 1
a2507 1
      val = b->owner->ops->remove (b->owner);
d2510 1
a2510 1
      b->inserted = (is == mark_inserted);
d2517 1
a2517 1
remove_breakpoint (struct bp_location *b, insertion_state_t is)
d2522 2
a2523 2
  /* B is never in moribund_locations by our callers.  */
  gdb_assert (b->owner != NULL);
d2525 1
a2525 1
  if (b->owner->enable_state == bp_permanent)
d2531 1
a2531 1
  gdb_assert (b->owner->type != bp_none);
d2535 1
a2535 1
  switch_to_program_space_and_thread (b->pspace);
d2537 1
a2537 1
  ret = remove_breakpoint_1 (b, is);
d2548 1
a2548 1
  struct bp_location *bpt, **bptp_tmp;
d2550 3
a2552 3
  ALL_BP_LOCATIONS (bpt, bptp_tmp)
    if (bpt->pspace == current_program_space)
      bpt->inserted = 0;
d2570 2
a2571 2
  struct breakpoint *b, *temp;
  struct bp_location *bpt, **bptp_tmp;
d2580 1
a2580 1
  ALL_BP_LOCATIONS (bpt, bptp_tmp)
d2582 4
a2585 4
    /* ALL_BP_LOCATIONS bp_location has BPT->OWNER always non-NULL.  */
    if (bpt->pspace == pspace
	&& bpt->owner->enable_state != bp_permanent)
      bpt->inserted = 0;
d2588 1
a2588 1
  ALL_BREAKPOINTS_SAFE (b, temp)
d2648 2
a2649 2
  for (ix = 0; VEC_iterate (bp_location_p, moribund_locations, ix, bpt); ++ix)
    decref_bp_location (&bpt);
d2671 1
a2671 1
  struct bp_location *bpt, **bptp_tmp;
d2674 1
a2674 1
  ALL_BP_LOCATIONS (bpt, bptp_tmp)
d2676 2
a2677 2
      if (bpt->loc_type != bp_loc_software_breakpoint
	  && bpt->loc_type != bp_loc_hardware_breakpoint)
d2680 4
a2683 4
      /* ALL_BP_LOCATIONS bp_location has BPT->OWNER always non-NULL.  */
      if ((breakpoint_enabled (bpt->owner)
	   || bpt->owner->enable_state == bp_permanent)
	  && breakpoint_address_match (bpt->pspace->aspace, bpt->address,
d2687 2
a2688 2
	      && section_is_overlay (bpt->section) 
	      && !section_is_mapped (bpt->section))
d2690 1
a2690 1
	  else if (bpt->owner->enable_state == bp_permanent)
d2724 1
a2724 1
  struct bp_location *bpt, **bptp_tmp;
d2726 1
a2726 1
  ALL_BP_LOCATIONS (bpt, bptp_tmp)
d2728 2
a2729 2
      if (bpt->loc_type != bp_loc_software_breakpoint
	  && bpt->loc_type != bp_loc_hardware_breakpoint)
d2732 2
a2733 2
      if (bpt->inserted
	  && breakpoint_address_match (bpt->pspace->aspace, bpt->address,
d2737 2
a2738 2
	      && section_is_overlay (bpt->section) 
	      && !section_is_mapped (bpt->section))
d2768 1
a2768 1
  struct bp_location *bpt, **bptp_tmp;
d2770 1
a2770 1
  ALL_BP_LOCATIONS (bpt, bptp_tmp)
d2772 1
a2772 1
      if (bpt->loc_type != bp_loc_software_breakpoint)
d2775 2
a2776 2
      if (bpt->inserted
	  && breakpoint_address_match (bpt->pspace->aspace, bpt->address,
d2780 2
a2781 2
	      && section_is_overlay (bpt->section) 
	      && !section_is_mapped (bpt->section))
d2834 1
a2834 1
  struct bp_location *bpt, **bptp_tmp;
d2839 1
a2839 1
  ALL_BP_LOCATIONS (bpt, bptp_tmp)
d2841 2
a2842 2
      if (bpt->loc_type != bp_loc_software_breakpoint
	  && bpt->loc_type != bp_loc_hardware_breakpoint)
d2845 3
a2847 3
      /* ALL_BP_LOCATIONS bp_location has BPT->OWNER always non-NULL.  */
      if (!breakpoint_enabled (bpt->owner)
	  && bpt->owner->enable_state != bp_permanent)
d2850 1
a2850 1
      if (!breakpoint_address_match (bpt->pspace->aspace, bpt->address,
d2854 1
a2854 1
      if (bpt->owner->thread != -1)
d2861 1
a2861 1
	  if (bpt->owner->thread != thread)
d2865 1
a2865 1
      if (bpt->owner->task != 0)
d2872 1
a2872 1
	  if (bpt->owner->task != task)
d2877 2
a2878 2
	  && section_is_overlay (bpt->section) 
	  && !section_is_mapped (bpt->section))
d3748 1
a3748 1
	  && section_is_overlay (bl->section) 
d3769 1
a3769 1
	  && section_is_overlay (bl->section) 
d5670 1
a5670 1
  struct breakpoint *b, *temp;
d5677 1
a5677 1
  ALL_BREAKPOINTS_SAFE (b, temp)
d5695 1
a5695 1
  struct breakpoint *b, *temp;
d5697 1
a5697 1
  ALL_BREAKPOINTS_SAFE (b, temp)
d5738 1
a5738 1
  struct breakpoint *b, *temp;
d5740 1
a5740 1
  ALL_BREAKPOINTS_SAFE (b, temp)
d5753 1
a5753 1
  struct breakpoint *b, *temp;
d5755 1
a5755 1
  ALL_BREAKPOINTS_SAFE (b, temp)
d5780 1
a5780 1
  struct breakpoint *b, *temp;
d5782 1
a5782 1
  ALL_BREAKPOINTS_SAFE (b, temp)
d5817 1
a5817 1
  struct breakpoint *b, *temp;
d5819 1
a5819 1
  ALL_BREAKPOINTS_SAFE (b, temp)
d9317 1
a9317 1
  struct breakpoint *b, *temp;
d9325 1
a9325 1
  ALL_BREAKPOINTS_SAFE (b, temp)
d9876 1
a9876 1
  struct breakpoint *b, *temp;
d9909 1
a9909 1
	  ALL_BREAKPOINTS_SAFE (b, temp)
d10418 1
a10418 1
  struct breakpoint *b, *temp;
d10427 1
a10427 1
  ALL_BREAKPOINTS_SAFE (b, temp)
d11318 1
a11318 1
  struct breakpoint *b, *temp;
d11342 1
a11342 1
	  ALL_BREAKPOINTS_SAFE (b, temp)
d11760 1
a11760 1
  struct breakpoint *b, *temp;
d11762 1
a11762 1
  ALL_BREAKPOINTS_SAFE (b, temp)
@


1.518
log
@gdb/
	Rename and move inferior_thread_state and inferior_status.
	* gdbthread.h (struct thread_control_state): New struct, move fields
	step_range_start, step_range_end, step_frame_id, step_stack_frame_id,
	trap_expected, proceed_to_finish, in_infcall, step_over_calls,
	stop_step and stop_bpstat here from struct thread_info.
	(struct thread_suspend_state): New struct, move field stop_signal here
	from struct thread_info.
	(struct thread_info): Move the fields above from this struct.
	* inferior.h: Move the inferior_thread_state and inferior_status
	declarations comment to their definitions at infrun.c.
	(struct inferior_control_state): New struct, move field stop_soon from
	struct inferior here.
	(struct inferior_suspend_state): New empty struct.
	(struct inferior): New fields control and suspend.  Move out field
	stop_soon.
	* infrun.c (struct inferior_thread_state): Rename to ...
	(infcall_suspend_state): ... here.  Replace field stop_signal by
	fields thread_suspend and inferior_suspend.
	(save_inferior_thread_state): Rename to ...
	(save_infcall_suspend_state): ... here.  New variable inf.  Update the
	code for new fields.
	(restore_inferior_thread_state): Rename to ...
	(restore_infcall_suspend_state): ... here.  New variable inf.  Update
	the code for new fields.
	(do_restore_inferior_thread_state_cleanup): Rename to ...
	(do_restore_infcall_suspend_state_cleanup): ... here.
	(make_cleanup_restore_inferior_thread_state): Rename to ...
	(make_cleanup_restore_infcall_suspend_state): ... here.
	(discard_inferior_thread_state): Rename to ...
	(discard_infcall_suspend_state): ... here.
	(get_inferior_thread_state_regcache): Rename to ...
	(get_infcall_suspend_state_regcache): ... here.
	(struct inferior_status): Rename to ...
	(struct infcall_control_state): ... here.  Replace fields
	step_range_start, step_range_end, step_frame_id, step_stack_frame_id,
	trap_expected, proceed_to_finish, in_infcall, step_over_calls,
	stop_step, stop_bpstat and stop_soon by fields thread_control and
	inferior_control.
	(save_inferior_status): Rename to ...
	(save_infcall_control_state): ... here.  Update the code for new
	fields.
	(restore_inferior_status): Rename to ...
	(restore_infcall_control_state): ... here.  Update the code for new
	fields.
	(do_restore_inferior_status_cleanup): Rename to ...
	(do_restore_infcall_control_state_cleanup): ... here.
	(make_cleanup_restore_inferior_status): Rename to ...
	(make_cleanup_restore_infcall_control_state): ... here.
	(discard_inferior_status): Rename to ...
	(discard_infcall_control_state): ... here.
	* alpha-tdep.c, breakpoint.c, dummy-frame.c, dummy-frame.h,
	exceptions.c, fbsd-nat.c, gdbthread.h, infcall.c, infcmd.c,
	inferior.c, inferior.h, infrun.c, linux-nat.c, mi/mi-interp.c,
	mips-tdep.c, procfs.c, solib-irix.c, solib-osf.c, solib-spu.c,
	solib-sunos.c, solib-svr4.c, thread.c, windows-nat.c: Update all the
	references to the moved fields and renamed functions.
@
text
@d2212 29
d2282 2
a2283 1
	|| b->type == bp_longjmp_master || b->type == bp_std_terminate_master)
d2298 2
a2299 1
    if (b->type == bp_longjmp || b->type == bp_longjmp_resume)
d2361 1
d3283 6
d3376 2
d4164 2
a4165 1
	      || b->type == bp_std_terminate_master)
d4260 1
d4316 1
d4318 1
d4321 1
d4323 1
d4339 1
d4533 2
d4544 1
d4683 2
d4694 1
d5435 2
d5447 1
d5664 2
a5665 2
   if we do a longjmp() in THREAD.  When we hit that breakpoint, call
   set_longjmp_resume_breakpoint() to figure out where we are going. */
d5668 1
a5668 1
set_longjmp_breakpoint (int thread)
d5671 1
d5679 2
a5680 1
	&& b->type == bp_longjmp_master)
d5684 1
a5684 1
	clone->type = bp_longjmp;
d5687 2
d5698 1
a5698 1
    if (b->type == bp_longjmp)
d6870 2
d6882 1
d8556 1
d8571 1
d8583 2
d8623 3
d8638 3
d8657 1
d9897 1
d9919 1
d10380 1
d10404 2
d10449 1
@


1.517
log
@2010-11-25  Marc Khouzam  <marc.khouzam@@ericsson.com>

	PR breakpoints/12217

	* breakpoint.c (is_marker_spec): Check for NULL.
@
text
@d3011 1
a3011 1
      if (tp->in_infcall)
d3130 1
a3130 1
    if (!bpstat_do_actions_1 (&inferior_thread ()->stop_bpstat))
d9683 1
a9683 1
  bpstat_remove_bp_location (th->stop_bpstat, bpt);
@


1.516
log
@2010-11-11  Phil Muldoon  <pmuldoon@@redhat.com>

	* python/py-breakpoint.c (BPPY_REQUIRE_VALID): Check if bp is
	NULL.
	(BPPY_SET_REQUIRE_VALID): Ditto.
	(bpnum_is_valid): Delete function.
	(bppy_get_visibility): New function.
	(bppy_new): Parse for, and validate internal keyword.  Pass
	internal keyword to breakpoint or watchpoint functions.
	(build_bp_list): New function.
	(gdbpy_breakpoints): Rewrite.  Use build_bp_list and
	iterate_over_breakpoints.
	(gdbpy_breakpoint_created): Rewrite.  Do not store breakpoints in a
	look-aside vector.
	(gdbpy_breakpoint_deleted): Rewrite, defer breakpoint management
	to internal breakpoint chain.

	* breakpoint.c (set_breakpoint_number): New function.
	(breakpoint_1): Check if breakpoint number is more than zero.
	(set_raw_breakpoint_without_location): Set py_bp_object to NULL.
	(create_breakpoint_sal): Take a new parameter called internal.
	Call set_breakpoint_number with internal parameter.  Do not
	mention internal breakpoints.  All callers updated.
	(create_breakpoint): Ditto.
	(create_breakpoints_sal): Ditto.
	(watch_command_1): Ditto.
	(watch_command_wrapper): Take a new parameter called internal.
	All callers updated.
	(rwatch_command_wrapper): Ditto.
	(awatch_command_wrapper): Ditto.
	(save_breakpoints): Update breakpoint save condition check.
	(iterate_over_breakpoints): New function.
	* breakpoint.h: Add conditional python includes.  Add py_bp_object
	and comment to struct breakpoint.  Update all callers.
	* defs.h: Add PyObject definition for GDB builds without Python.

2010-11-11  Phil Muldoon  <pmuldoon@@redhat.com>

	* gdb.texinfo (Breakpoints In Python): Document "internal"
	parameter, and visible attribute.


2010-11-11  Phil Muldoon  <pmuldoon@@redhat.com>

	* gdb.python/py-breakpoint.exp: Add internal watchpoint and
	breakpoint tests.
@
text
@d225 1
a225 1
  (strncmp (s, "-m", 2) == 0 && ((s)[2] == ' ' || (s)[2] == '\t'))
@


1.515
log
@	gdb/
	* breakpoint.c (watch_command_1): Get a pointer of the lazy
	version of the expression's value, even if reading the value from
	memory fails.  When creating a -location watchpoint, get the
	value's address from the lazy value pointer.

	gdb/testsuite/
	* gdb.base/watchpoint.exp: Test "watch -location" with an
	innacessible location.
@
text
@d2071 18
d4960 2
a4961 1
	if (allflag || user_settable_breakpoint (b))
d5029 2
a5030 1
	if (allflag || user_settable_breakpoint (b))
d5479 1
d6938 2
a6939 1
		       struct breakpoint_ops *ops, int from_tty, int enabled)
d6976 1
a6976 2
	  set_breakpoint_count (breakpoint_count + 1);
	  b->number = breakpoint_count;
d7058 6
a7063 1
  mention (b);
d7219 1
a7219 1
			int enabled)
d7230 2
a7231 1
			     thread, task, ignore_count, ops, from_tty, enabled);
d7500 4
a7503 2
   COND_STRING and THREAD parameters.  Returns true if any breakpoint
   was created; false otherwise.  */
d7513 1
a7513 2
		   int from_tty,
		   int enabled)
d7689 1
a7689 1
				     from_tty, enabled);
d7694 4
a7697 1
	      tp = get_breakpoint (breakpoint_count);
d7713 1
a7713 1
				enabled);
d7722 1
a7722 2
      set_breakpoint_count (breakpoint_count + 1);
      b->number = breakpoint_count;
d7732 1
d7739 6
a7744 1
      mention (b);
d7789 2
a7790 1
		     1 /* enabled */);
d8057 2
a8058 1
watch_command_1 (char *arg, int accessflag, int from_tty, int just_location)
d8266 1
a8266 2
  set_breakpoint_count (breakpoint_count + 1);
  b->number = breakpoint_count;
d8325 6
a8330 2

  mention (b);
d8414 1
a8414 1
watch_command_wrapper (char *arg, int from_tty)
d8416 1
a8416 1
  watch_command_1 (arg, hw_write, from_tty, 0);
d8452 1
a8452 1
  watch_command_1 (arg, accessflag, from_tty, just_location);
d8462 1
a8462 1
rwatch_command_wrapper (char *arg, int from_tty)
d8464 1
a8464 1
  watch_command_1 (arg, hw_read, from_tty, 0);
d8474 1
a8474 1
awatch_command_wrapper (char *arg, int from_tty)
d8476 1
a8476 1
  watch_command_1 (arg, hw_access, from_tty, 0);
d8834 2
a8835 1
		     1 /* enabled */);
d11055 2
a11056 1
			 1 /* enabled */))
d11072 2
a11073 1
			 1 /* enabled */))
d11091 2
a11092 1
			 1 /* enabled */))
d11154 2
a11155 1
			  utp->enabled /* enabled */))
d11421 1
a11421 1
    if (!user_settable_breakpoint (tp))
d11459 1
a11459 1
    if (!user_settable_breakpoint (tp))
d11676 15
@


1.514
log
@	* breakpoint.c (create_breakpoint): Add missing _().
@
text
@d8025 1
a8025 1
  struct value *val, *mark;
d8124 1
a8124 1
  fetch_subexp_value (exp, &pc, &val, NULL, NULL);
d8129 1
a8129 1
      val = value_addr (val);
@


1.513
log
@	* breakpoint.c (can_use_hardware_watchpoint): Handle the first
	value specially.

	testsuite/
	* gdb.base/watchpoint.exp: Call test_inaccessible_watchpoint
	before disabling hardware watchpoints.
	(test_inaccessible_watchpoint): Check that hardware watchpoints
	are used.  Test for watchpoints on a constant address.
@
text
@d7548 1
a7548 1
	      && !nquery ("Make breakpoint pending on future shared library load? "))
@


1.512
log
@gdb/
	* breakpoint.c (save_breakpoints): Use RETURN_MASK_ALL.
	* cli-out.c: Include vec.h.
	(cli_field_fmt, cli_spaces, cli_text, cli_message, cli_flush): New
	variable stream, initialize it, use it.
	(cli_redirect): New function comment.  Replace the stream and
	original_stream fields by the new streams field.  Remove the
	original_stream != NULL conditional, assert error on NULL instead.
	(out_field_fmt, field_separator): New variable stream, initialize it, use it.
	(cli_out_data_ctor): Assert non-NULL stream.  Replace the stream and
	original_stream fields by the new streams field.
	(cli_out_set_stream): Replace the stream field by the new streams
	field.
	* cli-out.h: Include vec.h.
	(ui_filep): New typedef, call DEF_VEC_P for it.
	(struct cli_ui_out_data): Replace the stream and original_stream
	fields by the new streams field.
	* cli/cli-logging.c (set_logging_redirect): Call ui_out_redirect with
	NULL first.  Extend the comment.
	(handle_redirections): Call ui_out_redirect with output.
	* python/py-breakpoint.c (bppy_get_commands): Move ui_out_redirect
	calls outside of the TRY_CATCH block.

gdb/testsuite/
	* gdb.base/ui-redirect.exp: New file.
@
text
@d8330 6
a8335 4
	  if (value_lazy (v))
	    /* A lazy memory lvalue is one that GDB never needed to fetch;
	       we either just used its address (e.g., `a' in `a.b') or
	       we never needed it at all (e.g., `a' in `a,b').  */
@


1.511
log
@gdb/
	Code cleanup.
	* breakpoint.c (bpstat_alloc): Remove unused prototype.
	(bpstat_alloc): Change parameters cbs to bs_link_pointer.  Adjust the
	code.
	(bpstat_stop_status): Change root_bs into bs_head and bs_link.  Adjust
	calls of bpstat_alloc.  Remove explicit bs chain termination.
@
text
@d11490 1
a11490 1
	TRY_CATCH (ex, RETURN_MASK_ERROR)
@


1.510
log
@	* breakpoint.c (decref_bp_location): Assert the reference count is
	sane.
@
text
@a135 2
static bpstat bpstat_alloc (struct bp_location *, bpstat);

d3437 1
a3437 1
/* Allocate a new bpstat and chain it to the current one.  */
d3440 1
a3440 1
bpstat_alloc (struct bp_location *bl, bpstat cbs /* Current "bs" value */ )
d3445 3
a3447 1
  cbs->next = bs;
d4019 2
a4020 2
  /* Root of the chain of bpstat's */
  struct bpstats root_bs[1];
d4022 1
a4022 1
  bpstat bs = root_bs;
d4057 1
a4057 1
	  bs = bpstat_alloc (bl, bs);	/* Alloc a bpstat to explain stop */
d4079 1
a4079 1
	  bs = bpstat_alloc (loc, bs);
a4086 3
  /* Terminate the chain.  */
  bs->next = NULL;

d4093 1
a4093 1
  for (bs = root_bs->next; bs != NULL; bs = bs->next)
d4149 2
a4150 2
  if (! bpstat_causes_stop (root_bs->next))
    for (bs = root_bs->next; bs != NULL; bs = bs->next)
d4164 1
a4164 1
  return root_bs->next;
@


1.509
log
@gdb/
2010-08-17  Pedro Alves  <pedro@@codesourcery.com>

	PR breakpoints/11371

	* breakpoint.c (breakpoint_init_inferior): Decrement the
	location's reference count instead of deleting right away.
	(bpstat_free): Decrement the location's reference count.  Make
	static.
	(bpstat_copy): Increment the location's reference count.
	(bpstat_find_breakpoint): Adjust.
	(bpstat_num): Adjust.
	(print_it_typical): Adjust.  Use the breakpoint pointer in the
	bpstat instead of the location's owner.
	(bpstat_alloc): Remove const qualifier from the 'bl' parameter.
	Adjust to record the location's owner in the bpstat.
	(watchpoint_check): Use the breakpoint pointer in the bpstat
	instead of the location's owner.
	(bpstat_check_breakpoint_conditions): Don't handle
	bp_watchpoint_scope here.  Use the breakpoint pointer in the
	bpstat instead of the location's owner.
	(bpstat_stop_status): Defer inferior function calls to after
	building the bpstat list.  Handle bp_watchpoint_scope here.  Use
	the breakpoint pointer in the bpstat instead of the location's
	owner.
	(bpstat_what): Use the breakpoint pointer in the bpstat instead of
	the location's owner.
	(free_bp_location): Don't walk bpstats clearing locations.
	(incref_bp_location): New.
	(decref_bp_location): New.
	(breakpoint_auto_delete): Use the breakpoint pointer in the bpstat
	instead of the location's owner.
	(update_global_location_list): Clear the location's owner, and
	decrement the location's reference count instead of deleting it
	right away.
	(breakpoint_retire_moribund): Decrement the location's reference
	count instead of deleting it right away.
	(bpstat_remove_bp_location): Delete.
	(bpstat_remove_breakpoint): New.
	(bpstat_remove_bp_location_callback): Delete.
	(bpstat_remove_breakpoint_callback): New.
	(delete_breakpoint): Iterate over all threads' stop_bpstat's
	clearing references to the breakpoint that is being deleted.

	* breakpoint.h (struct bp_location) <refc>: New field.
	<owner>: Update comments.
	(bpstat_free): Delete declaration.
	(struct bpstats): Change the type of the breakpoint_at field to
	struct breakpoint point, from struct bp_location pointer.  Add new
	field bp_location_at.

gdb/testsuite/
2010-08-17  Jan Kratochvil  <jan.kratochvil@@redhat.com>
	    Pedro Alves  <pedro@@codesourcery.com>

	PR breakpoints/11371

	* gdb.base/watch-cond-infcall.exp: New file.
	* gdb.base/watch-cond-infcall.c: New file.
@
text
@d5426 2
@


1.508
log
@gdb/
	* breakpoint.c (update_watchpoint): Add source empty line.  Prefer
	EXP_STRING_REPARSE to EXP_STRING.
	(watch_command_1): Set also EXP_STRING_REPARSE.
	(delete_breakpoint): Free also EXP_STRING_REPARSE.
	* breakpoint.h (struct breakpoint): New field exp_string_reparse.
	Update comment for exp_string.
@
text
@d136 1
a136 1
static bpstat bpstat_alloc (const struct bp_location *, bpstat);
d197 2
a205 3
static int bpstat_remove_bp_location_callback (struct thread_info *th,
					       void *data);

d2601 1
a2601 1
    free_bp_location (bpt);
d2849 4
a2852 1
void 
d2858 1
d2901 1
d2929 1
a2929 1
      if (bsp->breakpoint_at && bsp->breakpoint_at->owner == breakpoint)
d2956 1
a2956 1
  b = (*bsp)->breakpoint_at ? (*bsp)->breakpoint_at->owner : NULL;
a3167 1
  bl = bs->breakpoint_at;
d3169 4
a3172 5
  /* bl->owner can be NULL if it was a momentary breakpoint
     which has since been placed into moribund_locations.  */
  if (bl->owner == NULL)
    return PRINT_UNKNOWN;
  b = bl->owner;
d3181 1
a3181 1
      bp_temp = bs->breakpoint_at->owner->disposition == disp_del;
d3362 2
a3363 3
	const struct bp_location *bl = bs->breakpoint_at;
	struct breakpoint *b = bl ? bl->owner : NULL;
	
d3442 1
a3442 1
bpstat_alloc (const struct bp_location *bl, bpstat cbs /* Current "bs" value */ )
d3448 3
a3450 1
  bs->breakpoint_at = bl;
d3543 1
a3543 1
  /* BS is built for existing struct breakpoint.  */
d3545 1
a3545 2
  gdb_assert (bs->breakpoint_at->owner != NULL);
  b = bs->breakpoint_at->owner;
d3736 1
a3736 1
  bl = bs->breakpoint_at;
d3738 1
a3738 1
  b = bl->owner;
d3887 1
d3896 1
a3896 1
  bl = bs->breakpoint_at;
d3898 1
a3898 1
  b = bl->owner;
a3908 7
      /* If this is a scope breakpoint, mark the associated
	 watchpoint as triggered so that we will handle the
	 out-of-scope event.  We'll get to the watchpoint next
	 iteration.  */
      if (b->type == bp_watchpoint_scope)
	b->related_breakpoint->watchpoint_triggered = watch_triggered_yes;

d3914 1
a3914 1
      if (cond && bl->owner->disposition != disp_del_at_next_stop)
d4025 1
d4027 6
a4032 3
  /* ALL_BP_LOCATIONS iteration would break across
     update_global_location_list possibly executed by
     bpstat_check_breakpoint_conditions's inferior call.  */
d4059 3
a4061 3
	  /* Assume we stop.  Should we find watchpoint that is not actually
	     triggered, or if condition of breakpoint is false, we'll reset
	     'stop' to 0.  */
d4065 41
a4105 3
	  bpstat_check_watchpoint (bs);
	  if (!bs->stop)
	    continue;
d4114 1
a4114 1
	
d4124 1
a4124 1
		  update_global_location_list (0);
a4144 1
	}
a4146 15
  for (ix = 0; VEC_iterate (bp_location_p, moribund_locations, ix, loc); ++ix)
    {
      if (breakpoint_address_match (loc->pspace->aspace, loc->address,
				    aspace, bp_addr))
	{
	  bs = bpstat_alloc (loc, bs);
	  /* For hits of moribund locations, we should just proceed.  */
	  bs->stop = 0;
	  bs->print = 0;
	  bs->print_it = print_it_noop;
	}
    }

  bs->next = NULL;		/* Terminate the chain */

d4155 2
a4156 2
	  && bs->breakpoint_at->owner
	  && is_hardware_watchpoint (bs->breakpoint_at->owner))
d4158 1
a4158 4
	  update_watchpoint (bs->breakpoint_at->owner, 0 /* don't reparse. */);
	  /* Updating watchpoints invalidates bs->breakpoint_at.
	     Prevent further code from trying to use it.  */
	  bs->breakpoint_at = NULL;
d4164 2
d4218 1
a4218 1
      else if (bs->breakpoint_at->owner == NULL)
d4221 1
a4221 1
	bptype = bs->breakpoint_at->owner->type;
d5396 1
d5400 2
a5401 1
static void free_bp_location (struct bp_location *loc)
a5402 12
  /* Be sure no bpstat's are pointing at it after it's been freed.  */
  /* FIXME, how can we find all bpstat's?
     We just check stop_bpstat for now.  Note that we cannot just
     remove bpstats pointing at bpt from the stop_bpstat list
     entirely, as breakpoint commands are associated with the bpstat;
     if we remove it here, then the later call to
         bpstat_do_actions (&stop_bpstat);
     in event-top.c won't do anything, and temporary breakpoints
     with commands won't work.  */

  iterate_over_threads (bpstat_remove_bp_location_callback, loc);

d5408 1
a5408 1
  
d5412 19
d9203 2
a9204 3
    if (bs->breakpoint_at 
	&& bs->breakpoint_at->owner
	&& bs->breakpoint_at->owner->disposition == disp_del
d9206 1
a9206 1
      delete_breakpoint (bs->breakpoint_at->owner);
d9517 4
a9520 1
	    free_bp_location (old_loc);
d9603 1
a9603 1
	free_bp_location (loc);
d9618 2
a9619 1
/* Clear LOC from a BPS.  */
d9621 1
a9621 1
bpstat_remove_bp_location (bpstat bps, struct bp_location *loc)
d9626 1
a9626 1
    if (bs->breakpoint_at == loc)
d9636 1
a9636 1
bpstat_remove_bp_location_callback (struct thread_info *th, void *data)
d9638 1
a9638 1
  struct bp_location *loc = data;
d9640 1
a9640 1
  bpstat_remove_bp_location (th->stop_bpstat, loc);
d9645 1
a9645 1
   structures. */
d9704 13
@


1.507
log
@gdb
	* value.c (release_value): Clear 'next' pointer.
	* breakpoint.c (watch_command_1): Add 'just_location' argument.
	(watch_command_wrapper): Update.
	(watch_maybe_just_location): New function.
	(watch_command): Update.
	(rwatch_command_wrapper): Update.
	(rwatch_command): Update.
	(awatch_command_wrapper): Update.
	(awatch_command): Update.
	(check_for_argument): New function.
	(_initialize_breakpoint): Update help text.
gdb/testsuite
	* gdb.base/help.exp: Update.
	* gdb.base/watchpoint.exp (test_watchpoint_and_breakpoint): Delete
	watchpoint.
	(test_watch_location): New proc.
	(test_watchpoint_in_big_blob): Delete watchpoint.
	* gdb.base/watchpoint.c (func5): New function.
	(main): Call it.
gdb/doc
	* gdb.texinfo (Set Watchpoints): Document -location option.
@
text
@d1342 1
d1348 1
a1348 1
      s = b->exp_string;
d8215 2
a8216 2
      b->exp_string = xstrprintf ("* (%s *) %s", name,
				  core_addr_to_string (addr));
d8219 3
d9665 1
@


1.506
log
@	* breakpoint.c (bpdisp_text): Constify bpdisps.
	* solib-svr4.c (solib_break_names): Constify.
	(bkpt_names, main_name_list): Constify.
	(match_main): Constify soname arg.
	(bfd_lookup_symbol): Constify symname arg.
	(enable_break): Constify bkpt_namep.
	* symtab.c (search_symbols): Constify types, types2, types3, types4.
	(symtab_symbol_info): Constify classnames.
@
text
@a100 2
static void watch_command (char *, int);

a173 6
static void watch_command_1 (char *, int, int);

static void rwatch_command (char *, int);

static void awatch_command (char *, int);

d7990 1
a7990 1
watch_command_1 (char *arg, int accessflag, int from_tty)
d8095 9
a8103 1
  if (val != NULL)
d8205 18
a8222 1
  b->exp_string = savestring (exp_start, exp_end - exp_start);
d8249 2
a8250 1
  value_free_to_mark (mark);
d8340 37
a8376 1
  watch_command (arg, from_tty);
d8382 1
a8382 1
  watch_command_1 (arg, hw_write, from_tty);
d8388 1
a8388 1
  rwatch_command (arg, from_tty);
d8394 1
a8394 1
  watch_command_1 (arg, hw_read, from_tty);
d8400 1
a8400 1
  awatch_command (arg, from_tty);
d8406 1
a8406 1
  watch_command_1 (arg, hw_access, from_tty);
d11904 1
d11906 3
a11908 1
an expression changes."));
d11913 1
d11915 3
a11917 1
an expression is read."));
d11922 1
d11924 3
a11926 1
an expression is either read or written."));
@


1.505
log
@[PATCH] breakpoint_re_set fails while connecting to gdbserver.

This is a problem that I noticed on GNU/Linux, when using both GDB
and GDBserver to debug an Ada program.  To reproduce, use any Ada
program, built with debug info ("gnatmake -g ...").

Then start the program with gdbserver:

        % gdbserver :4444 simple_main

And then insert a breakpoint using the name of an Ada function,
followed by connecting to the target server:

        (gdb) b simple.test_simple
        Breakpoint 1 at 0x401f28: file simple.adb, line 16.
        (gdb) tar rem :4444
        Remote debugging using :4444
        Reading symbols from /lib64/ld-linux-x86-64.so.2...
        Reading symbols from /usr/lib/debug/lib/ld-2.11.1.so...done.
        done.
        Loaded symbols for /lib64/ld-linux-x86-64.so.2
!! ->   Error in re-setting breakpoint 1: Can't find member of namespace, class,
!! ->    struct, or union named "simple.test_simple"
!! ->   Hint: try 'simple.test_simple<TAB> or 'simple.test_simple<ESC-?>
!! ->   (Note leading single quote.)
        0x00007f4db3cf2af0 in _start () from /lib64/ld-linux-x86-64.so.2
        Created trace state variable $trace_timestamp for target's variable 1.

The problem is related to the fact that GDB found debug symbols for
ld.so in /usr/lib/debug.  For debugger configured with a prefix that
is different from /usr, one way to force the problem to reproduce is
to use:

        (gdb) set debug-file-directory /usr/lib/debug

(assuming that debug info has been installed at that location).

The problem is that the wrong language is used to parse the breakpoint
location because it gets changed from under us as a side effect of
some of the code that we do in prepration for re-parsing.  In particular,
breakpoint_re_set_one reads:

      set_language (b->language);
      input_radix = b->input_radix;
      s = b->addr_string;

      save_current_space_and_thread ();
      switch_to_program_space_and_thread (b->pspace);

      marker_spec = b->type == bp_static_tracepoint && is_marker_spec (s);
      [if (marker_spec) decode_tracepoint_spec (...) else decode_line_1]

What happens in our case is that debugging information gets found
for ld.so.  As a result, the current_frame language is C whereas it
would have been unknown if we did not have debugging info. And
save_current_space_and_thread() implicitly causes the current frame
to be selected, which changes the language automatically if the new
language is not uknown and the the language mode is auto.

The fix, until all parsing routines (including decode_line_1) get upgraded
to take a language, is to select the breakpoint language as late as possible.
In this case, we don't need to do that until we actually try to parse
the breakpoint addr_string.

gdb/ChangeLog:

        * breakpoint.c (breakpoint_re_set_one): Move call to set_language
        down, just before the block that parse the breakpoint addr_string.
@
text
@d265 1
a265 1
  static char *bpdisps[] = {"del", "dstp", "dis", "keep"};
@


1.504
log
@	* breakpoint.c (bptype_string): New, abstracted out from
	print_one_breakpoint_location.
	(print_one_breakpoint_location): Adjust.
	(breakpoint_1): Adjust the type column width dynamically.
@
text
@a10026 1
      set_language (b->language);
d10035 1
@


1.503
log
@2010-07-19  Hui Zhu  <teawater@@gmail.com>

	* breakpoint.c (single_step_breakpoints_inserted): New
	function.
	* breakpoint.h (single_step_breakpoints_inserted): Extern.
	* infrun.c (maybe_software_singlestep): Add check code.
	* record.c (record_resume): Add code for software single step.
	(record_wait): Ditto.
@
text
@d4436 2
a4437 8
/* Print B to gdb_stdout. */
static void
print_one_breakpoint_location (struct breakpoint *b,
			       struct bp_location *loc,
			       int loc_number,
			       struct bp_location **last_loc,
			       int print_address_bits,
			       int allflag)
a4438 1
  struct command_line *l;
d4472 21
a4492 1
  
d4537 2
a4538 9
  else 
    {
      if (((int) b->type >= (sizeof (bptypes) / sizeof (bptypes[0])))
	  || ((int) b->type != bptypes[(int) b->type].type))
	internal_error (__FILE__, __LINE__,
			_("bptypes table does not describe type #%d."),
			(int) b->type);
      ui_out_field_string (uiout, "type", bptypes[(int) b->type].description);
    }
d4916 2
a4917 1
  
d4933 3
a4935 1
	    int addr_bit = breakpoint_address_bits (b);
d4939 4
d4963 2
a4964 1
  ui_out_table_header (uiout, 14, ui_left, "type", "Type");		/* 2 */
@


1.502
log
@gdb
	* breakpoint.c (save_cmdlist): No longer static.
	* gdbcmd.h (save_cmdlist): Declare.
	* symfile.c (symbol_file_add_with_addrs_or_offsets): Set
	OBJF_READNOW on objfile if readnow_symbol_files.
	* elfread.c (elf_symfile_read): Use dwarf2_initialize_objfile.
	(elf_sym_fns_gdb_index): New global.
	* dwarf2read.c: Include exceptions.h.
	(offset_type): New.
	(struct mapped_index): New.
	(dwarf2_per_cu_data_ptr): New typedef.
	(struct dwarf2_per_objfile) <using_index, index_table, gdb_index>:
	New fields.
	(GDB_INDEX_SECTION): New define.
	(struct dwarf2_per_cu_quick_data): New.
	(struct dwarf2_per_cu_data) <objfile>: New field.
	<psymtab>: Removed.
	<v>: New field.
	(byte_swap): New function.
	(MAYBE_SWAP): New macro.
	(INDEX_SUFFIX): New macro.
	(dw2_do_instantiate_symtab): New function.
	(dw2_instantiate_symtab): Likewise.
	(create_cus_from_index): Likewise.
	(create_addrmap_from_index): Likewise.
	(mapped_index_string_hash): Likewise.
	(find_slot_in_mapped_hash): Likewise.
	(dwarf2_read_index): Likewise.
	(dw2_setup): Likewise.
	(dw2_require_line_header): Likewise.
	(dw2_require_full_path): Likewise.
	(dw2_find_last_source_symtab): Likewise.
	(dw2_forget_cached_source_info): Likewise.
	(dw2_lookup_symtab): Likewise.
	(dw2_lookup_symbol): Likewise.
	(dw2_do_expand_symtabs_matching): Likewise.
	(dw2_pre_expand_symtabs_matching): Likewise.
	(dw2_print_stats): Likewise.
	(dw2_dump): Likewise.
	(dw2_relocate): Likewise.
	(dw2_expand_symtabs_for_function): Likewise.
	(dw2_expand_all_symtabs): Likewise.
	(dw2_expand_symtabs_with_filename): Likewise.
	(dw2_find_symbol_file): Likewise.
	(dw2_map_ada_symtabs): Likewise.
	(dw2_expand_symtabs_matching): Likewise.
	(dw2_find_pc_sect_symtab): Likewise.
	(dw2_map_symbol_names): Likewise.
	(dw2_map_symbol_filenames): Likewise.
	(dw2_has_symbols): Likewise.
	(dwarf2_gdb_index_functions): New global.
	(dwarf2_initialize_objfile): New function.
	(process_psymtab_comp_unit): Update.
	(add_partial_subprogram): Likewise.
	(dwarf2_psymtab_to_symtab): Likewise.
	(psymtab_to_symtab_1): Use dw2_do_instantiate_symtab.
	(process_full_comp_unit): Update.
	(find_file_and_directory): New function.
	(read_file_scope): Use find_file_and_directory.
	(dwarf2_per_cu_objfile): Update.
	(dwarf2_per_cu_addr_size): Update.
	(dwarf2_per_cu_offset_size): Update.
	(dwarf2_free_objfile): Free the index, if needed.
	(dwarf2_per_objfile_free): Unmap the index, if needed.
	(struct strtab_entry): New.
	(hash_strtab_entry): New function.
	(eq_strtab_entry): Likewise.
	(create_strtab): Likewise.
	(add_string): Likewise.
	(struct symtab_index_entry): New.
	(struct mapped_symtab): New.
	(hash_symtab_entry): New function.
	(eq_symtab_entry): Likewise.
	(delete_symtab_entry): Likewise.
	(create_index_table): Likewise.
	(create_mapped_symtab): Likewise.
	(cleanup_mapped_symtab): Likewise.
	(find_slot): Likewise.
	(hash_expand): Likewise.
	(add_index_entry): Likewise.
	(add_indices_to_cpool): Likewise.
	(write_hash_table): Likewise.
	(add_address_entry): Likewise.
	(write_psymbols): Likewise.
	(write_obstack): Likewise.
	(unlink_if_set): Likewise.
	(write_psymtabs_to_index): Likewise.
	(save_gdb_index_command): Likewise.
	(_initialize_dwarf2_read): Install "save gdb-index"
	command.
	(create_all_comp_units): Initialize 'objfile' field of CU.
	(dwarf2_locate_sections): Check for .gdb_index.
	* psymtab.h (dwarf2_gdb_index_functions): Declare.
	* symfile.h (dwarf2_initialize_objfile): Declare.
gdb/doc
	* gdb.texinfo (Index Files): New node.
@
text
@d10729 10
@


1.501
log
@2010-07-07  Sergio Durigan Junior  <sergiodj@@linux.vnet.ibm.com>
	    Thiago Jung Bauermann  <bauerman@@br.ibm.com>

	Support for hw accelerated condition watchpoints in booke powerpc.

	* breakpoint.c (fetch_watchpoint_value): Rename to fetch_subexp_value
	and move to eval.c.  Change callers.
	(insert_bp_location): Pass watchpoint condition in
	target_insert_watchpoint.
	(remove_breakpoint_1) Pass watchpoint condition in
	target_remove_watchpoint.
	(watchpoint_locations_match): Call
	target_can_accel_watchpoint_condition.
	* eval.c: Include wrapper.h.
	(fetch_subexp_value): Moved from breakpoint.c.
	* ppc-linux-nat.c (ppc_linux_region_ok_for_hw_watchpoint):
	Formatting fix.
	(can_use_watchpoint_cond_accel): New function.
	(calculate_dvc): Likewise.
	(num_memory_accesses): Likewise.
	(check_condition): Likewise.
	(ppc_linux_can_accel_watchpoint_condition): Likewise
	(ppc_linux_insert_watchpoint): Call can_use_watchpoint_cond_accel,
	check_condition and calculate_dvc.
	(ppc_linux_remove_watchpoint): Likewise.
	(_initialize_ppc_linux_nat): Set to_can_accel_watchpoint_condition to
	ppc_linux_can_accel_watchpoint_condition
	* target.c (debug_to_insert_watchpoint): Add argument for watchpoint
	condition.
	(debug_to_remove_watchpoint): Likewise.
	(debug_to_can_accel_watchpoint_condition): New function.
	(update_current_target): Set to_can_accel_watchpoint_condition.
	(setup_target_debug): Set to_can_accel_watchpoint_condition.
	* target.h: Add opaque declaration for struct expression.
	(struct target_ops) <to_insert_watchpoint>,
	<to_remove_watchpoint>: Add new arguments to pass the watchpoint
	<to_can_accel_watchpoint_condition>: New member.
	condition.  Update all callers and implementations.
	(target_can_accel_watchpoint_condition): New macro.
	* value.c (free_value_chain): New function.
	* value.h (fetch_subexp_value): New prototype.
	(free_value_chain): Likewise.
@
text
@d433 1
a433 1
static struct cmd_list_element *save_cmdlist;
@


1.501.2.1
log
@        * breakpoint.c (breakpoint_re_set_one): Move call to set_language
        down, just before the block that parse the breakpoint addr_string.
@
text
@d10013 1
a10021 1
      set_language (b->language);
@


1.501.2.2
log
@2010-11-25  Marc Khouzam  <marc.khouzam@@ericsson.com>

	PR breakpoints/12217

	* breakpoint.c (is_marker_spec): Check for NULL.
@
text
@d236 1
a236 1
  (s != NULL && strncmp (s, "-m", 2) == 0 && ((s)[2] == ' ' || (s)[2] == '\t'))
@


1.501.2.3
log
@	gdb/
	* breakpoint.c (breakpoint_restore_shadows): When looking for the
	location with the lowest address that overlaps the memory range we
	want to restore shadows for, account for multiple locations at the
	same address.
@
text
@a1140 17
  /* Due to the binary search above, we need to make sure we pick the
     first location that's at BC_L's address.  E.g., if there are
     multiple locations at the same address, BC_L may end up pointing
     at a duplicate location, and miss the "master"/"inserted"
     location.  Say, given locations L1, L2 and L3 at addresses A and
     B:

      L1@@A, L2@@A, L3@@B, ...

     BC_L could end up pointing at location L2, while the "master"
     location could be L1.  Since the `loc->inserted' flag is only set
     on "master" locations, we'd forget to restore the shadow of L1
     and L2.  */
  while (bc_l > 0
	 && bp_location[bc_l]->address == bp_location[bc_l - 1]->address)
    bc_l--;

@


1.500
log
@* breakpoint.c (_initialize_breakpoint): Add "cl" as alias for
"clear".
@
text
@a1236 78
/* Find the current value of a watchpoint on EXP.  Return the value in
   *VALP and *RESULTP and the chain of intermediate and final values
   in *VAL_CHAIN.  RESULTP and VAL_CHAIN may be NULL if the caller does
   not need them.

   If a memory error occurs while evaluating the expression, *RESULTP will
   be set to NULL.  *RESULTP may be a lazy value, if the result could
   not be read from memory.  It is used to determine whether a value
   is user-specified (we should watch the whole value) or intermediate
   (we should watch only the bit used to locate the final value).

   If the final value, or any intermediate value, could not be read
   from memory, *VALP will be set to NULL.  *VAL_CHAIN will still be
   set to any referenced values.  *VALP will never be a lazy value.
   This is the value which we store in struct breakpoint.

   If VAL_CHAIN is non-NULL, *VAL_CHAIN will be released from the
   value chain.  The caller must free the values individually.  If
   VAL_CHAIN is NULL, all generated values will be left on the value
   chain.  */

static void
fetch_watchpoint_value (struct expression *exp, struct value **valp,
			struct value **resultp, struct value **val_chain)
{
  struct value *mark, *new_mark, *result;
  volatile struct gdb_exception ex;

  *valp = NULL;
  if (resultp)
    *resultp = NULL;
  if (val_chain)
    *val_chain = NULL;

  /* Evaluate the expression.  */
  mark = value_mark ();
  result = NULL;

  TRY_CATCH (ex, RETURN_MASK_ALL)
    {
      result = evaluate_expression (exp);
    }
  if (ex.reason < 0)
    {
      /* Ignore memory errors, we want watchpoints pointing at
	 inaccessible memory to still be created; otherwise, throw the
	 error to some higher catcher.  */
      switch (ex.error)
	{
	case MEMORY_ERROR:
	  break;
	default:
	  throw_exception (ex);
	  break;
	}
    }

  new_mark = value_mark ();
  if (mark == new_mark)
    return;
  if (resultp)
    *resultp = result;

  /* Make sure it's not lazy, so that after the target stops again we
     have a non-lazy previous value to compare with.  */
  if (result != NULL
      && (!value_lazy (result) || gdb_value_fetch_lazy (result)))
    *valp = result;

  if (val_chain)
    {
      /* Return the chain of intermediate values.  We use this to
	 decide which addresses to watch.  */
      *val_chain = new_mark;
      value_release_to_mark (mark);
    }
}

d1394 1
d1398 1
a1398 1
      fetch_watchpoint_value (b->exp, &v, &result, &val_chain);
d1754 2
a1755 1
				      bpt->watchpoint_type);
d1783 2
a1784 1
					      hw_access);
d2453 2
a2454 2
      val = target_remove_watchpoint (b->address, b->length, 
				      b->watchpoint_type);
d3607 1
d3611 1
a3611 1
      fetch_watchpoint_value (b->exp, &new_val, NULL, NULL);
d5191 15
d8001 1
d8088 1
a8088 1
  fetch_watchpoint_value (exp, &val, NULL, NULL);
@


1.499
log
@2010-07-02  Ulrich Weigand  <uweigand@@de.ibm.com>
	    Thiago Jung Bauermann  <bauerman@@br.ibm.com>

	* breakpoint.c (can_use_hardware_watchpoint): Answer "what does this
	represent?" question in comment.  Change comment to a proper sentence.
@
text
@d11720 1
@


1.498
log
@	gdb/
	* breakpoint.c (BREAK_ARGS_HELP, _initialize_breakpoint): Clarify
	usefulness suggestion of multiple breakpoints at same location.

	gdb/testsuite/
	* gdb.base/help.exp: Adjust expected output.
@
text
@d8353 1
a8353 1
	return 0;	/* ??? What does this represent? */
d8355 1
a8355 1
	return 0;	/* cannot watch a register with a HW watchpoint */
@


1.497
log
@	gdb/
	* breakpoint.c (BREAK_ARGS_HELP): Add missing `the'.

	gdb/testsuite/
	* gdb.base/help: Adjust expected output.
@
text
@d11505 2
a11506 1
Multiple breakpoints at one place are permitted, and useful if conditional.\n\
d11960 2
a11961 1
Multiple tracepoints at one place are permitted, and useful if conditional.\n\
@


1.496
log
@	* breakpoint.c (update_watchpoint, _initialize_breakpoint): Remove
	unnecessary space in string.
	* filesystem.c (_initialize_filesystem): Ditto.
	* frame.c (_initialize_frame): Ditto.
	* infcmd.c (step_once): Ditto.
	* infrun.c (_initialize_infrun): Ditto.
	* linux-nat.c (linux_child_follow_fork): Ditto.
	* maint.c (maintenance_deprecate): Ditto.
	* memattr.c (_initialize_mem): Ditto.
	* mips-tdep.c (_initialize_mips_tdep): Ditto.
	* monitor.c (monitor_open): Ditto.
	* procfs.c (procfs_xfer_memory): Ditto.
	* reverse.c (bookmarks_info): Ditto.
	* sh64-tdep.c (sh64_show_media_regs, sh64_show_compact_regs): Ditto.
	* stack.c (_initialize_stack): Ditto.
	* tracepoint.c (_initialize_tracepoint): Ditto.
	* xtensa-tdep.c (xtensa_supply_gregset,
	xtensa_regset_from_core_section): Ditto.
@
text
@d11499 2
a11500 2
With no LOCATION, uses current execution address of selected stack frame.\n\
This is useful for breaking on return to a stack frame.\n\
@


1.495
log
@	Static tracepoints support, and UST integration.

	gdb/gdbserver/
	* configure.ac: Handle --with-ust.  substitute ustlibs and ustinc.
	* mem-break.c (uninsert_all_breakpoints)
	(reinsert_all_breakpoints): New.
	* mem-break.h (reinsert_all_breakpoints, uninsert_all_breakpoints):
	* tracepoint.c (ust_loaded, helper_thread_id, cmd_buf): New.
	(gdb_agent_ust_loaded, helper_thread_id)
	(gdb_agent_helper_thread_id): New macros.
	(struct ipa_sym_addresses): Add addr_ust_loaded,
	addr_helper_thread_id, addr_cmd_buf.
	(symbol_list): Add ust_loaded, helper_thread_id, cmd_buf.
	(in_process_agent_loaded_ust): New.
	(write_e_ust_not_loaded): New.
	(maybe_write_ipa_ust_not_loaded): New.
	(struct collect_static_trace_data_action): New.
	(enum tracepoint_type) <static_tracepoint>: New.
	(struct tracepoint) <handle>: Mention static tracepoints.
	(struct static_tracepoint_ctx): New.
	(CMD_BUF_SIZE): New.
	(add_tracepoint_action): Handle static tracepoint actions.
	(unprobe_marker_at): New.
	(clear_installed_tracepoints): Handle static tracepoints.
	(cmd_qtdp): Handle static tracepoints.
	(probe_marker_at): New.
	(cmd_qtstart): Handle static tracepoints.
	(response_tracepoint): Handle static tracepoints.
	(cmd_qtfstm, cmd_qtsstm, cmd_qtstmat): New.
	(handle_tracepoint_query): Handle qTfSTM, qTsSTM and qTSTMat.
	(get_context_regcache): Handle static tracepoints.
	(do_action_at_tracepoint): Handle static tracepoint actions.
	(traceframe_find_block_type): Handle static trace data blocks.
	(traceframe_read_sdata): New.
	(download_tracepoints): Download static tracepoint actions.
	[HAVE_UST] Include ust/ust.h, dlfcn.h, sys/socket.h, and sys/un.h.
	(GDB_PROBE_NAME): New.
	(ust_ops): New.
	(GET_UST_SYM): New.
	(USTF): New.
	(dlsym_ust): New.
	(ust_marker_to_static_tracepoint): New.
	(gdb_probe): New.
	(collect_ust_data_at_tracepoint): New.
	(gdb_ust_probe): New.
	(UNIX_PATH_MAX, SOCK_DIR): New.
	(gdb_ust_connect_sync_socket): New.
	(resume_thread, stop_thread): New.
	(run_inferior_command): New.
	(init_named_socket): New.
	(gdb_ust_socket_init): New.
	(cstr_to_hexstr): New.
	(next_st): New.
	(first_marker, next_marker): New.
	(response_ust_marker): New.
	(cmd_qtfstm, cmd_qtsstm): New.
	(unprobe_marker_at, probe_marker_at): New.
	(cmd_qtstmat, gdb_ust_thread): New.
	(gdb_ust_init): New.
	(initialize_tracepoint_ftlib): Call gdb_ust_init.
	* linux-amd64-ipa.c [HAVE_UST]: Include ust/processor.h
	(ST_REGENTRY): New.
	(x86_64_st_collect_regmap): New.
	(X86_64_NUM_ST_COLLECT_GREGS): New.
	(AMD64_RIP_REGNUM): New.
	(supply_static_tracepoint_registers): New.
	* linux-i386-ipa.c [HAVE_UST]: Include ust/processor.h
	(ST_REGENTRY): New.
	(i386_st_collect_regmap): New.
	(i386_NUM_ST_COLLECT_GREGS): New.
	(supply_static_tracepoint_registers): New.
	* server.c (handle_query): Handle qXfer:statictrace:read.
	<qSupported>: Report support for StaticTracepoints, and
	qXfer:statictrace:read features.
	* server.h (traceframe_read_sdata)
	(supply_static_tracepoint_registers): Declare.
	* remote-utils.c (convert_int_to_ascii, hexchars, ishex, tohex)
	(unpack_varlen_hex): Include in IPA build.
	* Makefile.in (ustlibs, ustinc): New.
	(IPA_OBJS): Add remote-utils-ipa.o.
	($(IPA_LIB)): Link -ldl and -lpthread.
	(UST_CFLAGS): New.
	(IPAGENT_CFLAGS): Add UST_CFLAGS.
	* config.in, configure: Regenerate.

	gdb/
	* NEWS: Mention new support for static tracepoints.
	(New packets): Mention qTfSTM, qTsSTM, qTSTMat and
	qXfer:statictrace:read.
	(New features in the GDB remote stub, GDBserver): Mention static
	tracepoints support using an UST based backend.
	(New commands): Mention "info static-tracepoint-markers" and
	"strace".
	* breakpoint.c (is_marker_spec): New.
	(is_tracepoint): Handle static tracepoints.
	(validate_commands_for_breakpoint): Static tracepoints can't do
	while-stepping.
	(static_tracepoints_here): New.
	(bpstat_what): Handle static tracepoints.
	(print_one_breakpoint_location, allocate_bp_location, mention):
	Ditto.
	(create_breakpoint_sal): Ditto.
	(decode_static_tracepoint_spec): New.
	(create_breakpoint): Replace `hardwareflag', and `traceflag' with
	`type_wanted'.  Adjust.  Handle static tracepoint marker
	locations.
	(break_command_1): Adjust.
	(update_static_tracepoint): New.
	(update_breakpoint_locations): Handle static tracepoints.
	(breakpoint_re_set_one): Handle static tracepoint marker
	locations.
	(disable_command, enable_command): Handle static tracepoints.
	(trace_command, ftrace_command): Adjust.
	(strace_command): New.
	(create_tracepoint_from_upload): Adjust.
	(save_breakpoints): Handle static tracepoints.
	(_initialize_breakpoint): Install the "strace" command.
	* breakpoint.h (enum bptype): New bp_static_tracepoint type.
	(struct breakpoint): New fields static_trace_marker_id and
	static_trace_marker_id_idx.
	(breakpoints_here_p): Declare.
	(create_breakpoint): Adjust.
	(static_tracepoints_here): Declare.
	* remote.c (struct remote_state) <static_tracepoints>: New field.
	(PACKET_qXfer_statictrace_read, PACKET_StaticTracepoints): New.
	(remote_static_tracepoint_marker_at): New.
	(remote_static_tracepoint_markers_by_strid): New.
	(remote_static_tracepoint_feature): New.
	(remote_disconnected_tracing_feature): Handle "StaticTracepoints".
	(remote_xfer_partial): Handle TARGET_OBJECT_STATIC_TRACE_DATA.
	(remote_supports_static_tracepoints): New.
	(remote_download_tracepoint): Download static tracepoints.
	(init_remote_ops): Install remote_static_tracepoint_marker_at and
	remote_static_tracepoint_markers_by_strid.
	(_initialize_remote): Install set|show remote static-tracepoints,
	and set|show remote read-sdata-object commands.
	* target.c (update_current_target): Inherit and default
	to_static_tracepoint_marker_at, and
	to_static_tracepoint_markers_by_strid.
	* target.h (static_tracepoint_marker): Forward declare.
	(enum target_object): New object TARGET_OBJECT_STATIC_TRACE_DATA.
	(static_tracepoint_marker_p): New typedef.
	(DEF_VEC_P(static_tracepoint_marker_p)): New VEC type.
	(struct target_ops): New fields to_static_tracepoint_marker_at and
	to_static_tracepoint_markers_by_strid.
	(target_static_tracepoint_marker_at)
	(target_static_tracepoint_markers_by_strid): New.
	* tracepoint.c: Include source.h.
	(validate_actionline): Handle $_sdata.
	(struct collection_list): New field strace_data.
	(add_static_trace_data): New.
	(clear_collection_list): Clear strace_data.
	(stringify_collection_list): Account for a possible static trace
	data collection.
	(encode_actions_1): Encode an $_sdata collection.
	(parse_tracepoint_definition): Handle static tracepoints.
	(parse_static_tracepoint_marker_definition): New.
	(release_static_tracepoint_marker): New.
	(print_one_static_tracepoint_marker): New.
	(info_static_tracepoint_markers_command): New.
	(sdata_make_value): New.
	(_initialize_tracepoint): Create the $_sdata convenience variable.
	Add the "info static-tracepoint-markers" command.
	Mention $_sdata in the "collect" command's help output.
	* tracepoint.h (struct static_tracepoint_marker): New.
	(parse_static_tracepoint_marker_definition)
	(release_static_tracepoint_marker): Declare.
	* mi/mi-cmd-break.c (mi_cmd_break_insert): Adjust.
	* python/py-breakpoint.c (bppy_new): Adjust.

	doc/
	* gdb.texinfo (Convenience Variables): Document $_sdata.
	(Commands to Set Tracepoints): Describe static tracepoints.  Add
	`Listing Static Tracepoint Markers' menu entry.  Document
	"strace".
	(Tracepoint Action Lists): Document collecting $_sdata.
	(Listing Static Tracepoint Markers): New subsection.
	(Tracepoints support in gdbserver): Mention static tracepoints.
	(remote packets, enabling and disabling): Mention
	read-sdata-object.
	(General Query Packets) <qSupported>: Document qXfer:sdata:read
	and StaticTracepoint.
	Mention qTfSTM, qTsSTM and qTSTMat as tracepoint packets.
	Document qXfer:sdata:read.
	(Tracepoint packets): Document qTfSTM, qTsSTM and qTSTMat.
@
text
@d1587 1
a1587 1
Watchpoint %d deleted because the program has left the block \n\
d12005 1
a12005 1
This includes all types of breakpoints (breakpoints, watchpoints, \n\
@


1.494
log
@	* breakpoint.c (breakpoint_sals_to_pc): Delete arg address, unused.
	All callers updated.
@
text
@d233 5
d847 3
a849 1
  return (b->type == bp_tracepoint || b->type == bp_fast_tracepoint);
d873 5
a877 1
		error (_("The 'while-stepping' command cannot be used for fast tracepoint"));
d904 21
d4384 1
d4550 1
d4683 1
d4754 10
d5420 1
d6797 10
d6986 1
d6988 38
a7025 1
	  b->pspace = sals.sals[0].pspace;
d7438 52
d7503 1
a7503 1
		   int tempflag, int hardwareflag, int traceflag,
a7521 1
  enum bptype type_wanted;
d7534 13
d7593 2
a7625 4
  type_wanted = (traceflag
		 ? (hardwareflag ? bp_fast_tracepoint : bp_tracepoint)
		 : (hardwareflag ? bp_hardware_breakpoint : bp_breakpoint));

d7657 49
a7705 4
      create_breakpoints_sal (gdbarch, sals, addr_string, cond_string,
			      type_wanted, tempflag ? disp_del : disp_donttouch,
			      thread, task, ignore_count, ops, from_tty,
			      enabled);
a7762 1
  int hardwareflag = flag & BP_HARDWAREFLAG;
d7764 3
d7771 1
a7771 1
		     tempflag, hardwareflag, 0 /* traceflag */,
d8744 1
a8744 1
		     tempflag, 0, 0,
d9796 133
a10030 1

d10047 1
d10059 1
d10078 2
d10082 14
a10095 2
	  sals = decode_line_1 (&s, 1, (struct symtab *) NULL, 0, (char ***) NULL,
				not_found_ptr);
d10145 3
d10500 1
d10601 1
d10935 2
a10936 2
			 0 /* tempflag */, 0 /* hardwareflag */,
			 1 /* traceflag */,
d10951 20
a10970 2
			 0 /* tempflag */, 1 /* hardwareflag */,
			 1 /* traceflag */,
d11032 1
a11032 2
			  (utp->type == bp_fast_tracepoint) /* hardwareflag */,
			  1 /* traceflag */,
d11354 2
d11940 25
@


1.493
log
@gdb/
	Fix PR 9436.
	* breakpoint.c (handle_jit_event): New function.
	(bpstat_what): Remove enum class, kc, ss, sn, sgl, slr, clr, sr, shl,
	jit, err, table and bs_class.  New variables shlib_event, jit_event,
	this_action and bptype.  Change bs_class assignments to this_action
	assignments.  new unhandled bptype internal error.  Move here
	shlib_event and jit_event handling from handle_inferior_event.
	* breakpoint.h (enum bpstat_what_main_action): Extend the comment.
	Reorder items.  Remove BPSTAT_WHAT_CHECK_SHLIBS and
	BPSTAT_WHAT_CHECK_JIT.
	* inferior.h (debug_infrun, stop_on_solib_events): New declarations.
	* infrun.c (debug_infrun, stop_on_solib_events): Remove static.
	(handle_inferior_event): Reinitialize frame and gdbarch after
	bpstat_what call.  Move BPSTAT_WHAT_CHECK_SHLIBS and
	BPSTAT_WHAT_CHECK_JIT handling to bpstat_what.  Reinitialize even
	gdbarch when frame gets reinitialized.

gdb/testsuite/
	Test PR 9436.
	* gdb.base/nostdlib.exp, gdb.base/nostdlib.c: New.
@
text
@d7226 1
a7226 2
breakpoint_sals_to_pc (struct symtabs_and_lines *sals,
		       char *address)
d7464 1
a7464 1
    breakpoint_sals_to_pc (&sals, addr_start);
@


1.492
log
@ChangeLog:

	* infrun.c (handle_inferior_event): Handle presence of single-step
	breakpoints for TARGET_WAITKIND_FORKED and TARGET_WAITKIND_VFORKED.
	Cancel single-step breakpoints for TARGET_WAITKIND_EXITED,
	TARGET_WAITKIND_SIGNALED, and TARGET_WAITKIND_EXECD.
	* breakpoint.c (detach_single_step_breakpoints): New function.
	(detach_breakpoints): Call it.
	(cancel_single_step_breakpoints): New function.
	* breakpoint.h (cancel_single_step_breakpoints): Add prototype.

	* spu-tdep.c (spu_memory_remove_breakpoint): New function.
	(spu_gdbarch_init): Install it.

testsuite/ChangeLog:

	* gdb.cell/fork.exp: New file.
	* gdb.cell/fork.c: Likewise.
	* gdb.cell/fork-spu.c: Likewise.
@
text
@d4197 3
a4199 4

/* Tell what to do about this bpstat.  */
struct bpstat_what
bpstat_what (bpstat bs)
d4201 2
a4202 5
  /* Classify each bpstat as one of the following.  */
  enum class
    {
      /* This bpstat element has no effect on the main_action.  */
      no_effect = 0,
d4204 3
a4206 2
      /* There was a watchpoint, stop but don't print.  */
      wp_silent,
d4208 2
a4209 2
      /* There was a watchpoint, stop and print.  */
      wp_noisy,
d4211 1
a4211 2
      /* There was a breakpoint but we're not stopping.  */
      bp_nostop,
d4213 2
a4214 2
      /* There was a breakpoint, stop but don't print.  */
      bp_silent,
d4216 1
a4216 2
      /* There was a breakpoint, stop and print.  */
      bp_noisy,
d4218 1
a4218 2
      /* We hit the longjmp breakpoint.  */
      long_jump,
d4220 3
a4222 98
      /* We hit the longjmp_resume breakpoint.  */
      long_resume,

      /* We hit the step_resume breakpoint.  */
      step_resume,

      /* We hit the shared library event breakpoint.  */
      shlib_event,

      /* We hit the jit event breakpoint.  */
      jit_event,

      /* This is just used to count how many enums there are.  */
      class_last
    };

  /* Here is the table which drives this routine.  So that we can
     format it pretty, we define some abbreviations for the
     enum bpstat_what codes.  */
#define kc BPSTAT_WHAT_KEEP_CHECKING
#define ss BPSTAT_WHAT_STOP_SILENT
#define sn BPSTAT_WHAT_STOP_NOISY
#define sgl BPSTAT_WHAT_SINGLE
#define slr BPSTAT_WHAT_SET_LONGJMP_RESUME
#define clr BPSTAT_WHAT_CLEAR_LONGJMP_RESUME
#define sr BPSTAT_WHAT_STEP_RESUME
#define shl BPSTAT_WHAT_CHECK_SHLIBS
#define jit BPSTAT_WHAT_CHECK_JIT

/* "Can't happen."  Might want to print an error message.
   abort() is not out of the question, but chances are GDB is just
   a bit confused, not unusable.  */
#define err BPSTAT_WHAT_STOP_NOISY

  /* Given an old action and a class, come up with a new action.  */
  /* One interesting property of this table is that wp_silent is the same
     as bp_silent and wp_noisy is the same as bp_noisy.  That is because
     after stopping, the check for whether to step over a breakpoint
     (BPSTAT_WHAT_SINGLE type stuff) is handled in proceed() without
     reference to how we stopped.  We retain separate wp_silent and
     bp_silent codes in case we want to change that someday. 

     Another possibly interesting property of this table is that
     there's a partial ordering, priority-like, of the actions.  Once
     you've decided that some action is appropriate, you'll never go
     back and decide something of a lower priority is better.  The
     ordering is:

     kc   < jit clr sgl shl slr sn sr ss
     sgl  < jit shl slr sn sr ss
     slr  < jit err shl sn sr ss
     clr  < jit err shl sn sr ss
     ss   < jit shl sn sr
     sn   < jit shl sr
     jit  < shl sr
     shl  < sr
     sr   <

     What I think this means is that we don't need a damned table
     here.  If you just put the rows and columns in the right order,
     it'd look awfully regular.  We could simply walk the bpstat list
     and choose the highest priority action we find, with a little
     logic to handle the 'err' cases.  */

  /* step_resume entries: a step resume breakpoint overrides another
     breakpoint of signal handling (see comment in wait_for_inferior
     at where we set the step_resume breakpoint).  */

  static const enum bpstat_what_main_action
    table[(int) class_last][(int) BPSTAT_WHAT_LAST] =
  {
  /*                              old action */
  /*               kc   ss   sn   sgl  slr  clr  sr  shl  jit */
/* no_effect */   {kc,  ss,  sn,  sgl, slr, clr, sr, shl, jit},
/* wp_silent */   {ss,  ss,  sn,  ss,  ss,  ss,  sr, shl, jit},
/* wp_noisy */    {sn,  sn,  sn,  sn,  sn,  sn,  sr, shl, jit},
/* bp_nostop */   {sgl, ss,  sn,  sgl, slr, slr, sr, shl, jit},
/* bp_silent */   {ss,  ss,  sn,  ss,  ss,  ss,  sr, shl, jit},
/* bp_noisy */    {sn,  sn,  sn,  sn,  sn,  sn,  sr, shl, jit},
/* long_jump */   {slr, ss,  sn,  slr, slr, err, sr, shl, jit},
/* long_resume */ {clr, ss,  sn,  err, err, err, sr, shl, jit},
/* step_resume */ {sr,  sr,  sr,  sr,  sr,  sr,  sr, sr,  sr },
/* shlib */       {shl, shl, shl, shl, shl, shl, sr, shl, shl},
/* jit_event */   {jit, jit, jit, jit, jit, jit, sr, jit, jit}
  };

#undef kc
#undef ss
#undef sn
#undef sgl
#undef slr
#undef clr
#undef err
#undef sr
#undef ts
#undef shl
#undef jit
  enum bpstat_what_main_action current_action = BPSTAT_WHAT_KEEP_CHECKING;
d4224 5
d4230 1
d4232 1
d4235 5
a4239 1
      enum class bs_class = no_effect;
d4241 7
a4247 5
	/* I suspect this can happen if it was a momentary breakpoint
	   which has since been deleted.  */
	continue;
      if (bs->breakpoint_at->owner == NULL)
	bs_class = bp_nostop;
d4249 3
a4251 1
      switch (bs->breakpoint_at->owner->type)
d4254 1
a4254 2
	  continue;

d4262 1
a4262 1
		bs_class = bp_noisy;
d4264 1
a4264 1
		bs_class = bp_silent;
d4267 1
a4267 1
	    bs_class = bp_nostop;
d4276 1
a4276 1
		bs_class = wp_noisy;
d4278 1
a4278 1
		bs_class = wp_silent;
d4281 4
a4284 3
	    /* There was a watchpoint, but we're not stopping. 
	       This requires no further action.  */
	    bs_class = no_effect;
d4287 1
a4287 1
	  bs_class = long_jump;
d4290 1
a4290 1
	  bs_class = long_resume;
d4294 2
d4297 2
a4298 1
	      bs_class = step_resume;
a4299 3
	  else
	    /* It is for the wrong frame.  */
	    bs_class = bp_nostop;
a4301 8
	  bs_class = bp_nostop;
	  break;
	case bp_shlib_event:
	  bs_class = shlib_event;
	  break;
	case bp_jit_event:
	  bs_class = jit_event;
	  break;
d4306 1
a4306 1
	  bs_class = bp_nostop;
d4312 1
a4312 1
		bs_class = bp_noisy;
d4314 6
a4319 1
		bs_class = bp_silent;
d4321 10
d4332 5
a4336 3
	    /* There was a catchpoint, but we're not stopping.  
	       This requires no further action.  */
	    bs_class = no_effect;
a4340 1
	  bs_class = bp_silent;
d4342 1
a4346 1
	  bs_class = bp_silent;
d4348 1
d4357 3
a4359 1
	  break;
d4361 31
a4391 1
      current_action = table[(int) bs_class][(int) current_action];
d4393 1
a4393 1
  retval.main_action = current_action;
@


1.491
log
@2010-06-21  Michael Snyder  <msnyder@@vmware.com>

	* breakpoint.c (_initialize_breakpoint): Use add_prefix_cmd,
	not add_abbrev_prefix_cmd, for "enable breakpoints".
@
text
@d199 2
d2388 4
d10500 33
@


1.490
log
@gdb/ChangeLog:

2010-06-16  Sergio Durigan Junior  <sergiodj@@redhat.com>
	    Jan Kratochvil  <jan.kratochvil@@redhat.com>

	* breakpoint.c: Include parser-defs.h.
	(watchpoint_exp_is_const): New function.
	(watch_command_1): Call watchpoint_exp_is_const to check
	if the expression is constant.

gdb/doc/ChangeLog:

2010-06-16  Jan Kratochvil  <jan.kratochvil@@redhat.com>

	* gdb.texinfo: Include information about the correct use
	of addresses in the `watch' command.

gdb/testsuite/ChangeLog:

2010-06-16  Jan Kratochvil  <jan.kratochvil@@redhat.com>
	    Sergio Durigan Junior  <sergiodj@@redhat.com>

	* gdb.base/watch-notconst.c: New file.
	* gdb.base/watch-notconst.S: New file.
	* gdb.base/watch-notconst2.c: New file.
	* gdb.base/watch-notconst2.S: New file.
	* gdb.base/watch-notconst.exp: New file.
	* gdb.base/watchpoint.c (global_ptr_ptr): New variable.
	(func4): Add operations on `global_ptr_ptr'.
	* gdb.base/watchpoint.exp (test_constant_watchpoint): New
	routine to test watchpoints created with a constant expression.
	(test_inaccessible_watchpoint): Include tests for watchpoints
	created with a constant expression.
@
text
@d11267 1
a11267 1
  add_abbrev_prefix_cmd ("breakpoints", class_breakpoint, enable_command, _("\
@


1.489
log
@gdb/
	* breakpoint.c (breakpoint_restore_shadows): New OWNER comment.
	(should_be_inserted): Return zero also on NULL OWNER.
	(breakpoint_program_space_exit): New OWNER comment.
	(insert_breakpoint_locations): Extend comment for OWNER.
	(remove_breakpoint_1, remove_breakpoint): Assert on OWNER.
	(breakpoint_init_inferior, breakpoint_here_p, breakpoint_thread_match):
	New OWNER comment.
	(print_it_typical): Return PRINT_UNKNOWN on NULL OWNER.
	(watchpoint_check): New assert on BREAKPOINT_AT and OWNER.
	(bpstat_check_location): New assert on OWNER.
	(bpstat_check_watchpoint, bpstat_check_breakpoint_conditions): Move BL
	and B initializations to the code block.  New assert on them.
	(print_one_breakpoint_location): New OWNER comment.
	(watchpoint_locations_match): Assert on OWNER.
	(breakpoint_locations_match): Move HW_POINT1 and HW_POINT2
	initializations to the code block.  New assert on OWNER.
	(set_breakpoint_location_function): New assert on OWNER.
	(disable_breakpoints_in_shlibs, disable_breakpoints_in_unloaded_shlib)
	(bp_location_compare, update_global_location_list)
	(update_global_location_list): New OWNER comment.

gdb/testsuite/
	* gdb.base/moribund-step.exp: New.
@
text
@d64 1
d7771 105
d7970 11
@


1.488
log
@gdb/
	Clear stale specific bp_location from former whole breakpoint.
	* breakpoint.c (delete_breakpoint): Move the stale referencing clear
	code ...
	(free_bp_location): ... here.  Rename there the called function to
	bpstat_remove_bp_location_callback.
	(bpstat_remove_breakpoint_callback): Rename to ...
	(bpstat_remove_bp_location_callback): ... here, change DATA resolution
	to struct bp_location.  Change the called function to
	bpstat_remove_bp_location.  Create new declaration for the function.
	(bpstat_remove_breakpoint): Rename to ...
	(bpstat_remove_bp_location): ..., change the parameter to loc, adjust
	code for the new parameter type.
@
text
@d1115 1
d1575 1
a1575 1
  if (!breakpoint_enabled (bpt->owner))
d1878 1
d1948 2
a1949 1
	 thread no longer exists.  */
d2400 3
d2518 3
d2578 1
d2676 1
d2841 1
d3208 5
d3583 3
d3714 3
d3772 8
a3779 2
  const struct bp_location *bl = bs->breakpoint_at;
  struct breakpoint *b = bl->owner;
d3931 8
a3938 2
  const struct bp_location *bl = bs->breakpoint_at;
  struct breakpoint *b = bl->owner;
d4716 2
d5254 4
d5291 8
a5298 2
  int hw_point1 = is_hardware_watchpoint (loc1->owner);
  int hw_point2 = is_hardware_watchpoint (loc2->owner);
d5495 2
d5779 1
d5781 1
d5824 1
d8903 1
d9081 1
d9214 1
@


1.487
log
@gdb/
	* breakpoint.c (update_global_location_list): Fix comment typo.
@
text
@d209 3
d5377 12
d9237 1
a9237 1
/* Clear BPT from a BPS.  */
d9239 1
a9239 1
bpstat_remove_breakpoint (bpstat bps, struct breakpoint *bpt)
d9244 1
a9244 1
    if (bs->breakpoint_at && bs->breakpoint_at->owner == bpt)
d9254 1
a9254 1
bpstat_remove_breakpoint_callback (struct thread_info *th, void *data)
d9256 1
a9256 1
  struct breakpoint *bpt = data;
d9258 1
a9258 1
  bpstat_remove_breakpoint (th->stop_bpstat, bpt);
a9320 12
  /* Be sure no bpstat's are pointing at it after it's been freed.  */
  /* FIXME, how can we find all bpstat's?
     We just check stop_bpstat for now.  Note that we cannot just
     remove bpstats pointing at bpt from the stop_bpstat list
     entirely, as breakpoint commands are associated with the bpstat;
     if we remove it here, then the later call to
         bpstat_do_actions (&stop_bpstat);
     in event-top.c won't do anything, and temporary breakpoints
     with commands won't work.  */

  iterate_over_threads (bpstat_remove_breakpoint_callback, bpt);

@


1.486
log
@2010-05-13  Michael Snyder  <msnyder@@vmware.com>

	* blockframe.c: White space.
	* breakpoint.c: White space.
	* buildsym.c: White space.
@
text
@d9099 1
a9099 1
		 with SIGILL/SIGBUS/SEGSEGV, or worse, get silently
@


1.485
log
@2010-05-05  Michael Snyder  <msnyder@@vmware.com>

	* breakpoint.c (validate_commands_for_breakpoint):
	Delete unused variables.
	(insert_catchpoint): Delete unused variable.
	(update_watchpoint): Delete unused variable.
	(insert_bp_location): Delete unused variable.
	(insert_breakpoint_locations): Delete unused variable.
	(remove_breakpoint_1): Delete unused variable.
	(software_breakpoint_inserted_here_p): Delete unused variable.
	(watchpoints_triggered): Delete unused variable.
	(bpstat_check_watchpoint): Delete unused variable.
	(bpstat_stop_status): Delete unused variable.
	(print_one_breakpoint_location): Delete unused variable.
	(allocate_bp_location): Delete unused variable.
	(create_breakpoint): Delete unused variable.
	(watch_command_1): Delete unused variable.
	(catch_exception_command_1): Delete unused variable.
	(catch_ada_exception_command): Delete unused variable.
	(delete_breakpoint): Delete unused variable.
	(breakpoint_re_set_one): Delete unused variable.
	(do_enable_breakpoint): Delete unused variable.
@
text
@d255 1
d482 1
d743 1
d809 1
d906 1
d1658 1
d3456 1
d4405 1
d4879 1
d4885 1
d4897 1
d5114 1
d5525 1
d5555 1
d5759 1
d5984 1
d5990 1
d6028 1
d6067 1
d6149 1
d7096 1
d7120 1
d7130 1
d7181 1
d7186 2
a7187 1
	    (*addr_string)[i] = savestring (addr_start, (*address) - addr_start);
d7201 1
d7265 1
a7548 1

d8211 2
a8212 1
catch_fork_command_1 (char *arg, int from_tty, struct cmd_list_element *command)
d8258 2
a8259 1
catch_exec_command_1 (char *arg, int from_tty, struct cmd_list_element *command)
d8319 2
a8320 1
print_one_exception_catchpoint (struct breakpoint *b, struct bp_location **last_loc)
d8323 1
d8439 1
d8449 1
d8591 2
a8592 1
catch_syscall_command_1 (char *arg, int from_tty, struct cmd_list_element *command)
d9217 1
d9227 1
d9242 1
d9429 2
a9430 1
				   (int (*) (const void *, const void *)) streq,
d9999 1
d10099 1
d10201 1
d10322 2
a10323 1
single_step_breakpoint_inserted_here_p (struct address_space *aspace, CORE_ADDR pc)
d10391 1
@


1.484
log
@	PR breakpoints/8554.

	Implement `save-breakpoints'.

	gdb/
	* breakpoint.c (save_cmdlist): New.
	(breakpoint_set_cmdlist, breakpoint_show_cmdlist): Moved up close
	to save_cmdlist.
	(print_recreate_catch_fork): New.
	(catch_fork_breakpoint_ops): Install it.
	(print_recreate_catch_vfork): New.
	(catch_vfork_breakpoint_ops): Install it.
	(print_recreate_catch_syscall): New.
	(catch_syscall_breakpoint_ops): Install it.
	(print_recreate_catch_exec): New.
	(catch_exec_breakpoint_ops): Install it.
	(print_recreate_exception_catchpoint): New.
	(gnu_v3_exception_catchpoint_ops): Install it.
	(save_breakpoints): New, based on tracepoint_save_command, but
	handle all breakpoint types.
	(save_breakpoints_command): New.
	(tracepoint_save_command): Rename to...
	(save_tracepoints_command): ... this, and reimplement using
	save_breakpoints.
	(save_command): New.
	(_initialize_breakpoints): Install the "save" command prefix.
	Install the "save breakpoints" command.  Make "save-tracepoints" a
	deprecated alias for "save tracepoints".
	* breakpoint.h (struct breakpoint_ops): New field `print_recreate'.
	* ada-lang.c (print_recreate_exception): New.
	(print_recreate_catch_exception): New.
	(catch_exception_breakpoint_ops): Install it.
	(print_recreate_catch_exception_unhandled): New.
	(catch_exception_unhandled_breakpoint_ops): Install it.
	(print_recreate_catch_assert): New.
	(catch_assert_breakpoint_ops): Install it.

	* NEWS: Mention the new `save breakpoints' command.  Mention the
	new `save tracepoints' alias and that `save-tracepoints' is now
	deprecated.

	gdb/doc/
	* gdb.texinfo (Save Breakpoints): New node.
	(save-tracepoints): Rename to ...
	(save tracepoints): ... this.  Mention that `save-tracepoints' is
	a deprecated alias to `save tracepoints'.

	gdb/testsuite/
	* gdb.trace/save-trace.exp: Adjust.
@
text
@a852 1
	  char *l = c->line;
a871 1
	      char *l = c2->line;
a1165 1
  int val = -1;
a1341 1
  struct bp_location *loc;
a1342 1
  bpstat bs;
a1642 1
		  int changed = 0;
a1932 3
      struct thread_info *tp;
      CORE_ADDR last_addr;

a2386 1
  struct cleanup *old_chain;
a2472 3
      struct value *v;
      struct value *n;

a2744 1
  int any_breakpoint_here = 0;
a3511 1
	struct value *v;
a3743 2
      CORE_ADDR addr;
      struct value *v;
d4018 1
a4018 1
  struct bp_location *bl, **blp_tmp;
a4478 1
  struct symbol *sym;
d5310 1
a5310 1
  struct bp_location *loc, *loc_p;
a7312 1
  char *err_msg;
a7452 1
      struct symtab_and_line sal = {0};
a7682 1
  struct gdbarch *gdbarch = get_current_arch ();
a8382 1
  struct symtab_and_line *sal = NULL;
a8481 1
  enum bptype type;
a9217 1
  struct bp_location *loc, *next;
a9532 2
  struct value *mark;
  int i;
a9537 1
  enum enable_state save_enable;
d9997 1
a9997 2
  int target_resources_ok, other_type_used;
  struct value *mark;
@


1.483
log
@	* breakpoint.c (watchpoints_triggered): Use
	is_hardware_watchpoint.
	(watchpoints_triggered): Ditto.
	(bpstat_check_location): Use is_watchpoint and
	is_hardware_watchpoint.
	(bpstat_check_watchpoint): Use is_watchpoint and
	is_hardware_watchpoint.
	(bpstat_stop_status): Fix comment.
	(user_settable_breakpoint): Use is_watchpoint.
	(hw_watchpoint_used_count): Use is_hardware_watchpoint.
	(disable_watchpoints_before_interactive_call_start): Use
	is_watchpoint.
	(enable_watchpoints_after_interactive_call_stop): Use
	is_watchpoint.
	(clear_command): Use is_watchpoint.
	(do_enable_breakpoint): Use is_watchpoint.
@
text
@d419 4
d5860 9
d5878 2
a5879 1
  print_mention_catch_fork
d5951 9
d5969 2
a5970 1
  print_mention_catch_vfork
d6209 27
d6245 2
a6246 1
  print_mention_catch_syscall
d6382 9
d6398 2
a6399 1
  print_mention_catch_exec
d8349 15
d8370 2
a8371 1
  print_mention_exception_catchpoint
d10725 5
a10729 1
/* save-tracepoints command */
d10731 2
a10732 1
tracepoint_save_command (char *args, int from_tty)
d10735 1
a10735 2
  int any_tp = 0;
  struct command_line *line;
a10736 1
  char tmp[40];
d10739 1
d10741 2
a10742 2
  if (args == 0 || *args == 0)
    error (_("Argument required (file name in which to save tracepoints)"));
d10745 1
a10745 1
  ALL_TRACEPOINTS (tp)
d10747 17
a10763 2
    any_tp = 1;
    break;
d10765 2
a10766 1
  if (!any_tp)
d10768 1
a10768 1
      warning (_("save-tracepoints: no tracepoints to save."));
d10772 1
a10772 1
  pathname = tilde_expand (args);
d10776 2
a10777 2
    error (_("Unable to open file '%s' for saving tracepoints (%s)"),
	   args, safe_strerror (errno));
d10780 2
a10781 1
  save_trace_state_variables (fp);
d10783 1
a10783 1
  ALL_TRACEPOINTS (tp)
d10785 7
a10791 4
    if (tp->type == bp_fast_tracepoint)
      fprintf_unfiltered (fp, "ftrace");
    else
      fprintf_unfiltered (fp, "trace");
d10793 2
a10794 2
    if (tp->addr_string)
      fprintf_unfiltered (fp, " %s", tp->addr_string);
d10797 36
a10832 2
	sprintf_vma (tmp, tp->loc->address);
	fprintf_unfiltered (fp, " *0x%s", tmp);
d10835 12
d10848 1
a10848 1
      fprintf_unfiltered (fp, " if %s", tp->cond_string);
d10850 2
a10851 1
    fprintf_unfiltered (fp, "\n");
d10860 1
a10860 1
	fprintf_unfiltered (fp, "  actions\n");
d10874 16
d10892 1
a10892 1
  if (*default_collect)
d10897 17
a10913 2
    printf_filtered (_("Tracepoints saved to file '%s'.\n"), args);
  return;
d10992 8
a11002 2
  static struct cmd_list_element *breakpoint_set_cmdlist;
  static struct cmd_list_element *breakpoint_show_cmdlist;
d11416 14
a11429 1
  c = add_com ("save-tracepoints", class_trace, tracepoint_save_command, _("\
d11431 2
a11432 1
Use the 'source' command in another debug session to restore them."));
d11435 3
@


1.482
log
@	* breakpoint.c (condition_command): Pass condition expression to
	set_breakpoint_condition stripped from breakpoint number.
@
text
@d3497 1
a3497 3
	if (b->type == bp_hardware_watchpoint
	    || b->type == bp_read_watchpoint
	    || b->type == bp_access_watchpoint)
d3508 1
a3508 3
	if (b->type == bp_hardware_watchpoint
	    || b->type == bp_read_watchpoint
	    || b->type == bp_access_watchpoint)
d3519 1
a3519 3
    if (b->type == bp_hardware_watchpoint
	|| b->type == bp_read_watchpoint
	|| b->type == bp_access_watchpoint)
d3700 1
a3700 4
  if (b->type != bp_watchpoint
      && b->type != bp_hardware_watchpoint
      && b->type != bp_read_watchpoint
      && b->type != bp_access_watchpoint
d3712 1
a3712 1
  
d3719 2
a3720 4
  
  if ((b->type == bp_hardware_watchpoint
       || b->type == bp_read_watchpoint
       || b->type == bp_access_watchpoint)
d3753 1
a3753 4
  if (b->type == bp_watchpoint
      || b->type == bp_read_watchpoint
      || b->type == bp_access_watchpoint
      || b->type == bp_hardware_watchpoint)
d4052 3
a4054 3
	     The watchpoint_check function will work on entire expression,
	     not the individual locations.  For read watchopints, the
	     watchpoints_triggered function have checked all locations
d4921 1
a4921 4
	  || b->type == bp_watchpoint
	  || b->type == bp_read_watchpoint
	  || b->type == bp_access_watchpoint
	  || b->type == bp_hardware_watchpoint);
d6384 1
a6384 3
	else if ((b->type == bp_hardware_watchpoint
		  || b->type == bp_read_watchpoint
		  || b->type == bp_access_watchpoint))
d6398 1
a6398 5
    if (((b->type == bp_watchpoint)
	 || (b->type == bp_hardware_watchpoint)
	 || (b->type == bp_read_watchpoint)
	 || (b->type == bp_access_watchpoint))
	&& breakpoint_enabled (b))
d6413 1
a6413 5
    if (((b->type == bp_watchpoint)
	 || (b->type == bp_hardware_watchpoint)
	 || (b->type == bp_read_watchpoint)
	 || (b->type == bp_access_watchpoint))
	&& (b->enable_state == bp_call_disabled))
d8656 1
a8656 5
	  if (b->type != bp_none
	      && b->type != bp_watchpoint
	      && b->type != bp_hardware_watchpoint
	      && b->type != bp_read_watchpoint
	      && b->type != bp_access_watchpoint)
d9962 1
a9962 4
  if (bpt->type == bp_watchpoint
      || bpt->type == bp_hardware_watchpoint
      || bpt->type == bp_read_watchpoint
      || bpt->type == bp_access_watchpoint)
@


1.481
log
@2010-04-09  Phil Muldoon  <pmuldoon@@redhat.com>
	    Thiago Jung Bauermann  <bauerman@@br.ibm.com>
   	    Tom Tromey  <tromey@@redhat.com>

	* breakpoint.c (condition_command): Simplify.  Move condition
	setting code to ...
	(set_breakpoint_condition): ... here.  New function.
	* breakpoint.h  (set_breakpoint_condition): Declare.
	* Makefile.in (SUBDIR_PYTHON_OBS): Add py-breakpoint.
	(SUBDIR_PYTHON_SRCS): Likewise.
	(py-breakpoint.o): New rule.
	* python/py-breakpoint.c: New file.
	* python/python-internal.h (gdbpy_breakpoints)
	(gdbpy_initialize_breakpoints): Declare.
	(GDB_PY_SET_HANDLE_EXCEPTION) Define.


2010-04-09  Phil Muldoon  <pmuldoon@@redhat.com>

	* gdb.python/py-breakpoint.exp: New File.
	* gdb.python/py-breakpoint.C: Ditto.

2010-04-09  Phil Muldoon  <pmuldoon@@redhat.com>
	    Thiago Jung Bauermann  <bauerman@@br.ibm.com>
   	    Tom Tromey  <tromey@@redhat.com>

	* gdb.texinfo (Breakpoints In Python): New Node.
@
text
@d787 1
a787 1
	set_breakpoint_condition (b, arg, from_tty);
@


1.480
log
@2010-04-08  Stan Shebs  <stan@@codesourcery.com>

	* breakpoint.c (default_collect_info): New function.
	(breakpoints_info): Call it.
	(maintenance_info_breakpoints): Ditto.
	(tracepoints_info): Ditto.
@
text
@d712 55
d787 1
a787 47
	struct bp_location *loc = b->loc;
	for (; loc; loc = loc->next)
	  {
	    xfree (loc->cond);
	    loc->cond = NULL;
	  }
	xfree (b->cond_string);
	b->cond_string = NULL;
	xfree (b->cond_exp);
	b->cond_exp = NULL;

	if (*p == 0)
	  {
	    if (from_tty)
	      printf_filtered (_("Breakpoint %d now unconditional.\n"), bnum);
	  }
	else
	  {
	    arg = p;
	    /* I don't know if it matters whether this is the string the user
	       typed in or the decompiled expression.  */
	    b->cond_string = xstrdup (arg);
	    b->condition_not_parsed = 0;

	    if (is_watchpoint (b))
	      {
		innermost_block = NULL;
		arg = p;
		b->cond_exp = parse_exp_1 (&arg, 0, 0);
		if (*arg)
		  error (_("Junk at end of expression"));
		b->cond_exp_valid_block = innermost_block;
	      }
	    else
	      {
		for (loc = b->loc; loc; loc = loc->next)
		  {
		    arg = p;
		    loc->cond =
		      parse_exp_1 (&arg, block_for_pc (loc->address), 0);
		    if (*arg)
		      error (_("Junk at end of expression"));
		  }
	      }
	  }
	breakpoints_changed ();
	observer_notify_breakpoint_modified (b->number);
@


1.479
log
@2010-04-06  Stan Shebs  <stan@@codesourcery.com>

	* defs.h (char_ptr): Move typedef here from...
	* ada-lang.c (char_ptr): Remove.
	* charset.c (char_ptr): Remove.
	* tracepoint.h (struct uploaded_string): Remove.
	(struct uploaded_tp): Use vectors for string arrays.
	* tracepoint.c (trace_save): Use vectors of actions.
	(parse_tracepoint_definition): Ditto.
	(get_uploaded_tp): Clear vectors.
	* breakpoint.c (create_tracepoint_from_upload): Use vectors.
	(next_cmd): Change to an int.
	(read_next_cmd): Use vector of command strings.
@
text
@d5055 19
d5083 2
d5115 2
d10488 2
@


1.478
log
@gdb/
	Code cleanup.
	* breakpoint.c (bpstat_stop_status): Use bpstat_causes_stop.
@
text
@d10351 1
a10351 1
static struct uploaded_string *next_cmd;
d10358 1
a10358 2
  if (!next_cmd)
    return NULL;
d10360 1
a10360 2
  rslt = next_cmd->str;
  next_cmd = next_cmd->next;
d10426 1
a10426 1
  if (utp->cmd_strings)
d10431 1
a10431 1
      next_cmd = utp->cmd_strings;
d10437 2
a10438 1
  else if (utp->numactions > 0 || utp->num_step_actions > 0)
@


1.477
log
@2010-04-04  Stan Shebs  <stan@@codesourcery.com>
	    Nathan Sidwell  <nathan@@codesourcery.com>

	* breakpoint.c (breakpoint_1): Add filter argument, return number of
	breakpoints printed.
	(is_hardware_watchpoint): Make argument const.
	(is_watchpoint): Ditto.
	(is_tracepoint): Merge of tracepoint_type and breakpoint_is_tracepoint,
	use it everywhere.
	(breakpoints_info): Pass NULL to breakpoint_1.
	(maintenance_info_breakpoints): Ditto.
	(watchpoints_info): New function.
	(tracepoints_info): Use breakpoint_1 filter.
	(set_ignore_count): Warn that tracepoint ignore count will be ignored.
	(_initialize_breakpoint): Make "info watchpoints" its own command.
	* breakpoint.h (is_tracepoint): Rename from breakpoint_is_tracepoint.
	* mi/mi-cmd-break.c (mi_cmd_break_commands): Use is_tracepoint.

	* gdb.texinfo (Setting Breakpoints): "info watch" no longer a synonym.
	(Setting Watchpoints): Update description of "info watch".
	(Disabling Breakpoints): Only "info break" lists all.

	* gdb.base/completion.exp: Update for new "info watchpoints".
	* gdb.base/default.exp: Ditto.
	* gdb.base/help.exp: Ditto.
	* gdb.base/watchpoint.exp: Ditto.
	* gdb.trace/infotrace.exp: Update "info tracpoints" output.
@
text
@a4143 4
  for (bs = root_bs->next; bs != NULL; bs = bs->next)
    if (bs->stop)
      break;

d4145 1
a4145 1
  if (bs == NULL)
@


1.476
log
@gdb/
	* breakpoint.c (bpstat_find_step_resume_breakpoint): Remove.
	* breakpoint.h (bpstat_find_step_resume_breakpoint): Remove.
@
text
@d133 3
a135 1
static void breakpoint_1 (int, int);
d209 1
a209 1
static int is_hardware_watchpoint (struct breakpoint *bpt);
d211 1
a211 1
static int is_watchpoint (struct breakpoint *bpt);
d371 1
a371 1
    if (tracepoint_type (B))
a468 8
/* Encapsulate tests for different types of tracepoints.  */

static int
tracepoint_type (const struct breakpoint *b)
{
  return (b->type == bp_tracepoint || b->type == bp_fast_tracepoint);
}
  
d814 2
d817 1
a817 1
breakpoint_is_tracepoint (const struct breakpoint *b)
d819 1
a819 9
  switch (b->type)
    {
    case bp_tracepoint:
    case bp_fast_tracepoint:
      return 1;
    default:
      return 0;

    }
d821 1
a821 1

d830 1
a830 1
  if (breakpoint_is_tracepoint (b))
d940 1
a940 1
				  (breakpoint_is_tracepoint (b)
d1166 1
a1166 1
is_hardware_watchpoint (struct breakpoint *bpt)
d1177 1
a1177 1
is_watchpoint (struct breakpoint *bpt)
d1580 1
a1580 1
  if (tracepoint_type (bpt->owner))
d3694 1
a3694 1
  if (tracepoint_type (b))
d4749 1
a4749 1
      if (tracepoint_type (b))
d4929 1
a4929 1
	  || tracepoint_type (b)
d4937 5
a4941 2
   number BNUM.  If BNUM is -1 print all user settable breakpoints.
   If ALLFLAG is non-zero, include non- user settable breakpoints. */
d4943 2
a4944 2
static void
breakpoint_1 (int bnum, int allflag)
d4962 4
d5021 4
d5036 9
a5044 5
      if (bnum == -1)
	ui_out_message (uiout, 0, "No breakpoints or watchpoints.\n");
      else
	ui_out_message (uiout, 0, "No breakpoint or watchpoint number %d.\n",
			bnum);
d5055 2
d5067 20
a5086 1
  breakpoint_1 (bnum, 0);
d5097 1
a5097 1
  breakpoint_1 (bnum, 1);
d5426 1
a5426 1
      || tracepoint_type (loc->owner))
d5713 1
a5713 1
	 || (tracepoint_type (b)))
d9069 1
a9069 1
	  || tracepoint_type (b))
d9729 8
d10456 6
a10461 2
  struct breakpoint *b;
  int tps_to_list = 0;
d10463 1
a10463 2
  /* In the no-arguments case, say "No tracepoints" if none found.  */
  if (tpnum_exp == 0)
d10465 4
a10468 13
      ALL_TRACEPOINTS (b)
      {
	if (b->number >= 0)
	  {
	    tps_to_list = 1;
	    break;
	  }
      }
      if (!tps_to_list)
	{
	  ui_out_message (uiout, 0, "No tracepoints.\n");
	  return;
	}
a10469 3

  /* Otherwise be the same as "info break".  */
  breakpoints_info (tpnum_exp, from_tty);
d10518 1
a10518 1
	    if (tracepoint_type (b)
d11160 3
a11162 2
  add_info ("watchpoints", breakpoints_info,
	    _("Synonym for ``info breakpoints''."));
@


1.475
log
@	* breakpoint.h (struct counted_command_line): Moved definition to
	breakpoint.c, and forward declare.
	(breakpoint_commands): Declare.
	* breakpoint.c (struct counted_command_line): Moved here.
	(breakpoint_commands): New.
	* tracepoint.c (encode_actions): Use breakpoint_commands.
	* remote.c (remote_download_tracepoint): Ditto.
@
text
@a2965 30
/* Find a step_resume breakpoint associated with this bpstat.
   (If there are multiple step_resume bp's on the list, this function
   will arbitrarily pick one.)

   It is an error to use this function if BPSTAT doesn't contain a
   step_resume breakpoint.

   See wait_for_inferior's use of this function.  */
struct breakpoint *
bpstat_find_step_resume_breakpoint (bpstat bsp)
{
  int current_thread;

  gdb_assert (bsp != NULL);

  current_thread = pid_to_thread_id (inferior_ptid);

  for (; bsp != NULL; bsp = bsp->next)
    {
      if ((bsp->breakpoint_at != NULL)
	  && (bsp->breakpoint_at->owner->type == bp_step_resume)
	  && (bsp->breakpoint_at->owner->thread == current_thread
	      || bsp->breakpoint_at->owner->thread == -1))
	return bsp->breakpoint_at->owner;
    }

  internal_error (__FILE__, __LINE__, _("No step_resume breakpoint found."));
}


@


1.474
log
@	gdb/
	* breakpoint.c (multi_start, multi_end, last_was_multi): Delete.
	(prev_breakpoint_count): New.
	(set_breakpoint_count): Adjust.
	(rbreak_start_breakpoint_count): New.
	(start_rbreak_breakpoints): Adjust.
	(end_rbreak_breakpoints): Adjust.
	(struct commands_info) <arg>: New field.
	(do_map_commands_command): Tweak output to include breakpoint spec
	range.
	(commands_command_1): Adjust.  Avoid setting an xfree cleanup if
	ARG was empty on entry.  Set INFO's arg.
	(create_breakpoint): Adjust.

	* NEWS: Clarify `commands' changes.

	gdb/doc/
	* gdb.texinfo (Break Commands): Clarify `commands' changes, and
	add cross reference.

	gdb/testsuite/
	* gdb.base/commands.exp: Adjust.
	* gdb.cp/extern-c.exp: Adjust.
@
text
@d225 16
@


1.473
log
@2010-03-31  Stan Shebs  <stan@@codesourcery.com>

	* breakpoint.c (tracepoint_save_command): Include variables,
 	conditionals, tracepoint types, and default-collect.
	* tracepoint.c (save_trace_state_variables): New function.
	* tracepoint.h (save_trace_state_variables): Declare it.

	* gdb.trace/save-trace.exp: Test save/restore of default-collect
	and tracepoint conditionals.
	(gdb_verify_tracepoints): Delete unused return.
@
text
@d391 5
a395 7
/* If the last command to create a breakpoint created multiple
   breakpoints, this holds the start and end breakpoint numbers.  */
static int multi_start;
static int multi_end;
/* True if the last breakpoint set was part of a group set with a
   single command, e.g., "rbreak".  */
static int last_was_multi;
d413 1
a414 1
  last_was_multi = 0;
d418 4
d424 1
d428 1
a428 1
  multi_start = breakpoint_count + 1;
d433 1
d437 1
a437 5
  if (breakpoint_count >= multi_start)
    {
      multi_end = breakpoint_count;
      last_was_multi = 1;
    }
d897 4
d904 1
d925 6
d932 10
a941 5
	l = read_command_lines (_("Type commands for all specified breakpoints"),
				info->from_tty, 1,
				(breakpoint_is_tracepoint (b)
				 ? check_tracepoint_command : 0),
				b);
d974 2
a975 2
      if (last_was_multi)
	arg = xstrprintf ("%d-%d", multi_start, multi_end);
d978 7
d990 5
a994 1
  make_cleanup (xfree, arg);
d7269 1
a7269 1
  int first_bp_set = breakpoint_count + 1;
d7429 1
a7429 3
      multi_start = first_bp_set;
      multi_end = breakpoint_count;
      last_was_multi = 1;
@


1.472
log
@2010-03-29  Stan Shebs  <stan@@codesourcery.com>

	* tracepoint.h (struct uploaded_string): New struct.
	(struct uploaded_tp): New fields for source strings.
	* breakpoint.c (this_utp, next_cmd): New globals.
	(read_uploaded_action): New function.
	(create_tracepoint_from_upload): Fill in more parts
	of a tracepoint.
	* tracepoint.c (encode_source_string): New function.
	(trace_save): Write out source strings, fix error checks.
	(parse_tracepoint_definition): Add source string parsing.
	* remote.c (PACKET_TracepointSource): New packet type.
	(remote_download_command_source): New function.
	(remote_download_tracepoint): Download source pieces also.
	(_initialize_remote): Add packet config command.

	* gdb.texinfo (Tracepoint Packets): Describe QTDPsrc.
	(General Query Packets): Describe TracepointSource.
@
text
@d10652 3
a10654 1
  
d10657 5
d10663 1
a10663 1
      fprintf_unfiltered (fp, "trace %s\n", tp->addr_string);
d10667 1
a10667 1
	fprintf_unfiltered (fp, "trace *0x%s\n", tmp);
d10670 5
d10697 4
@


1.471
log
@2010-03-26  Tom Tromey  <tromey@@redhat.com>

	* breakpoint.c (commands_command_1): Duplicate 'arg'.
@
text
@d10308 20
d10337 1
a10337 1
  char buf[100];
d10340 18
a10357 2
  /* In the absence of a source location, fall back to raw address.  */
  sprintf (buf, "*%s", paddress (get_current_arch(), utp->addr));
d10360 2
a10361 2
			  buf,
			  NULL, 0, 1 /* parse arg */,
d10374 1
d10380 1
a10380 1
      sprintf (buf, "%d %d", utp->pass, tp->number);
d10382 1
a10382 1
      trace_pass_command (buf, 0);
d10385 5
a10389 1
  if (utp->cond)
d10391 4
a10394 2
      printf_filtered ("Want to restore a condition\n");
    }
d10396 1
a10396 4
  if (utp->numactions > 0)
    {
      printf_filtered ("Want to restore action list\n");
    }
d10398 1
a10398 3
  if (utp->num_step_actions > 0)
    {
      printf_filtered ("Want to restore action list\n");
d10400 3
@


1.470
log
@	* breakpoint.c (expand_line_sal_maybe): Always call skip_prologue_sal.
	(skip_prologue_sal): Remove local definition.
	(resolve_sal_pc): Remove now unnecessary code.
	* linespec.c (minsym_found): Call skip_prologue_sal.
	* symtab.c (find_function_start_pc): Remove.
	(find_function_start_sal): Extract prologue skipping into ...
	(skip_prologue_sal): ... this new function.  Handle code both
	with and without debug info.  Respect SAL's explicit_pc and
	explicit_line flags.  Inline old find_function_start_pc.
	* symtab.h (find_function_start_pc): Remove.
	(skip_prologue_sal): Add prototype.
@
text
@a961 1
      make_cleanup (xfree, arg);
d963 5
@


1.469
log
@	* breakpoint.c (bpstat_clear_actions): Reset bs->commands_left.
@
text
@a224 2
static void skip_prologue_sal (struct symtab_and_line *sal);

a6926 21
	      else if (func_addr == pc)	    
		{	     
		  /* We're at beginning of a function, and should
		     skip prologue.  */
		  struct symbol *sym = find_pc_function (pc);
		  if (sym)
		    expanded.sals[i] = find_function_start_sal (sym, 1);
		  else
		    {
		      /* Since find_pc_partial_function returned true,
			 we should really always find the section here.  */
		      struct obj_section *section = find_pc_section (pc);
		      if (section)
			{
			  struct gdbarch *gdbarch
			    = get_objfile_arch (section->objfile);
			  expanded.sals[i].pc
			    = gdbarch_skip_prologue (gdbarch, pc);
			}
		    }
		}
d6930 4
a6933 9
  else
    {
      for (i = 0; i < expanded.nelts; ++i)
	{
	  /* If this SAL corresponds to a breakpoint inserted using a
	     line number, then skip the function prologue if necessary.  */
	  skip_prologue_sal (&expanded.sals[i]);
	}
    }
a7440 31
/* Adjust SAL to the first instruction past the function prologue.
   The end of the prologue is determined using the line table from
   the debugging information.  explicit_pc and explicit_line are
   not modified.

   If SAL is already past the prologue, then do nothing.  */

static void
skip_prologue_sal (struct symtab_and_line *sal)
{
  struct symbol *sym;
  struct symtab_and_line start_sal;
  struct cleanup *old_chain;

  old_chain = save_current_space_and_thread ();

  sym = find_pc_function (sal->pc);
  if (sym != NULL)
    {
      start_sal = find_function_start_sal (sym, 1);
      if (sal->pc < start_sal.pc)
	{
	  start_sal.explicit_line = sal->explicit_line;
	  start_sal.explicit_pc = sal->explicit_pc;
	  *sal = start_sal;
	}
    }

  do_cleanups (old_chain);
}

d7458 1
a7458 6
	{
	  /* Preserve the original line number.  */
	  int saved_line = sal->line;
	  skip_prologue_sal (sal);
	  sal->line = saved_line;
	}
@


1.468
log
@	PR gdb/11327, PR gdb/11328, PR breakpoints/11368:
	* infrun.c (handle_inferior_event): Change initialization of
	stop_stack_dummy.
	(handle_inferior_event): Change assignment to stop_stack_dummy.
	(normal_stop): Update use of stop_stack_dummy.
	(struct inferior_status) <stop_stack_dummy>: Change type.
	* inferior.h (stop_stack_dummy): Update.
	* infcmd.c (stop_stack_dummy): Change type.
	* infcall.c (cleanup_delete_std_terminate_breakpoint): New
	function.
	(call_function_by_hand): Call set_std_terminate_breakpoint.
	Rewrite std::terminate handling.
	* breakpoint.h (enum bptype) <bp_std_terminate,
	bp_std_terminate_master>: New.
	(enum stop_stack_kind): New.
	(struct bpstat_what) <call_dummy>: Change type.
	(set_std_terminate_breakpoint, delete_std_terminate_breakpoint):
	Declare.
	* breakpoint.c (create_std_terminate_master_breakpoint): New
	function.
	(update_breakpoints_after_exec): Handle bp_std_terminate_master.
	Call create_std_terminate_master_breakpoint.
	(print_it_typical): Handle new breakpoint kinds.
	(bpstat_stop_status): Handle bp_std_terminate_master.
	(bpstat_what): Correctly set call_dummy field.  Handle
	bp_std_terminate_master and bp_std_terminate.
	(print_one_breakpoint_location): Update.
	(allocate_bp_location): Update.
	(set_std_terminate_breakpoint): New function.
	(delete_std_terminate_breakpoint): Likewise.
	(create_thread_event_breakpoint): Update.
	(delete_command): Update.
	(breakpoint_re_set_one): Update.
	(breakpoint_re_set): Call create_std_terminate_master_breakpoint.
@
text
@d2989 1
@


1.467
log
@gdb
	PR breakpoints/9352:
	* NEWS: Mention changes to `commands' and `rbreak'.
	* symtab.c (do_end_rbreak_breakpoints): New function.
	(rbreak_command): Call start_rbreak_breakpoints; arrange to call
	end_rbreak_breakpoints.
	* breakpoint.c (breakpoint_count, tracepoint_count): Now static.
	(set_breakpoint_count): Likewise.  Clear last_was_multi.
	(multi_start, multi_end, last_was_multi): New globals.
	(start_rbreak_breakpoints, end_rbreak_breakpoints): New
	functions.
	(struct commands_info): New
	(do_map_commands_command): New function.
	(commands_command_1): New function.
	(commands_command): Use it.
	(commands_from_control_command): Likewise.
	(do_delete_breakpoint): New function.
	(delete_command): Use it.
	(map_breakpoint_numbers): Add 'data' argument.  Pass to callback.
	(do_map_disable_breakpoint): New function.
	(disable_command): Use it.
	(do_map_enable_breakpoint): New function.
	(enable_command): Use it.
	(enable_once_breakpoint): Add argument.
	(enable_once_command): Update.
	(enable_delete_breakpoint): Add argument.
	(enable_delete_command): Update.
	(break_command_really): Set last_was_multi when needed.
	(check_tracepoint_command): Fix formatting.
	(validate_commands_for_breakpoint): New function.
	(breakpoint_set_commands): Use it.
	(tracepoint_save_command): Update.
	* breakpoint.h (start_rbreak_breakpoints, end_rbreak_breakpoints):
	Declare.
gdb/doc
	PR breakpoints/9352:
	* gdb.texinfo (Break Commands): Update.
gdb/testsuite
	PR breakpoints/9352:
	* gdb.base/default.exp: Update.
	* gdb.base/commands.exp: Update.
	* gdb.cp/extern-c.exp: Test setting commands on multiple
	breakpoints at once.
@
text
@d2160 35
d2236 1
a2236 1
	|| b->type == bp_longjmp_master)
d2312 1
d3241 6
d3337 1
d4081 2
a4082 1
	      || b->type == bp_longjmp_master)
d4292 1
a4292 1
  retval.call_dummy = 0;
d4365 1
d4385 7
a4391 1
	  retval.call_dummy = 1;
d4519 1
d4524 1
d4652 1
d4657 1
d5293 1
d5299 1
d5552 27
d6624 1
d6631 1
d9311 1
d9317 1
d9332 1
d9338 1
d9649 1
d9669 1
d9715 1
@


1.466
log
@	* breakpoint.h (struct counted_command_line): New struct.
	(struct breakpoint) <commands>: Change type.
	(struct bpstats) <commands>: Change type.
	<commands_left>: New field.
	* breakpoint.c (alloc_counted_command_line): New function.
	(incref_counted_command_line): Likewise.
	(decref_counted_command_line): Likewise.
	(do_cleanup_counted_command_line): Likewise.
	(make_cleanup_decref_counted_command_line): Likewise.
	(breakpoint_set_commands): Use decref_counted_command_line and
	alloc_counted_command_line.
	(commands_command): Don't error if breakpoint commands are
	executing.
	(commands_from_control_command): Likewise.
	(bpstat_free): Update.
	(bpstat_copy): Likewise.
	(bpstat_clear_actions): Likewise.
	(bpstat_do_actions_1): Likewise.
	(bpstat_stop_status): Likewise.
	(print_one_breakpoint_location): Likewise.
	(delete_breakpoint): Likewise.
	(bpstat_alloc): Initialize new field.
	(tracepoint_save_command): Update.
	* tracepoint.c (encode_actions): Update.
	(trace_dump_command): Update.
@
text
@a81 2
static void enable_delete_breakpoint (struct breakpoint *);

a83 2
static void enable_once_breakpoint (struct breakpoint *);

d88 3
a90 1
static void map_breakpoint_numbers (char *, void (*)(struct breakpoint *));
a146 2
void set_breakpoint_count (int);

d391 9
a399 1
int breakpoint_count;
d403 1
a403 1
int tracepoint_count;
d414 1
a414 1
void
d418 1
d422 20
d820 3
a822 3
/* Set the command list of B to COMMANDS.  If breakpoint is tracepoint,
   validate that only allowed commands are included.
*/
d824 3
a826 2
void
breakpoint_set_commands (struct breakpoint *b, struct command_line *commands)
d868 10
d885 2
a886 1
void check_tracepoint_command (char *line, void *closure)
d892 18
d911 1
a911 1
commands_command (char *arg, int from_tty)
d913 31
a943 4
  struct breakpoint *b;
  char *p;
  int bnum;
  struct command_line *l;
d945 5
a949 2
  p = arg;
  bnum = get_number (&p);
d951 6
a956 2
  if (p && *p)
    error (_("Unexpected extra arguments following breakpoint number."));
d958 7
a964 15
  ALL_BREAKPOINTS (b)
    if (b->number == bnum)
      {
	char *tmpbuf = xstrprintf ("Type commands for when breakpoint %d is hit, one per line.", 
				 bnum);
	struct cleanup *cleanups = make_cleanup (xfree, tmpbuf);

	if (breakpoint_is_tracepoint (b))
	  l = read_command_lines (tmpbuf, from_tty, 1,
				  check_tracepoint_command, b);
	else
	  l = read_command_lines (tmpbuf, from_tty, 1, 0, 0);
	do_cleanups (cleanups);
	breakpoint_set_commands (b, l);
	return;
d966 13
a978 1
  error (_("No breakpoint number %d."), bnum);
d989 2
a990 30
  struct breakpoint *b;
  char *p;
  int bnum;

  /* An empty string for the breakpoint number means the last
     breakpoint, but get_number expects a NULL pointer.  */
  if (arg && !*arg)
    p = NULL;
  else
    p = arg;
  bnum = get_number (&p);

  if (p && *p)
    error (_("Unexpected extra arguments following breakpoint number."));

  ALL_BREAKPOINTS (b)
    if (b->number == bnum)
      {
	decref_counted_command_line (&b->commands);
	if (cmd->body_count != 1)
	  error (_("Invalid \"commands\" block structure."));
	/* We need to copy the commands because if/while will free the
	   list after it finishes execution.  */
	b->commands
	  = alloc_counted_command_line (copy_command_lines (cmd->body_list[0]));
	breakpoints_changed ();
	observer_notify_breakpoint_modified (b->number);
	return simple_control;
      }
  error (_("No breakpoint number %d."), bnum);
d7179 1
d7336 8
a7343 2
    warning (_("Multiple breakpoints were set.\n"
	       "Use the \"delete\" command to delete unwanted breakpoints."));
d9199 9
d9255 1
a9255 1
    map_breakpoint_numbers (arg, delete_breakpoint);
d9716 3
a9718 1
map_breakpoint_numbers (char *args, void (*function) (struct breakpoint *))
d9746 1
a9746 1
		function (b);
d9748 1
a9748 1
		  function (related_breakpoint);
d9824 9
d9866 1
a9866 1
    map_breakpoint_numbers (args, disable_breakpoint);
d9923 9
d9969 1
a9969 1
    map_breakpoint_numbers (args, enable_breakpoint);
d9973 1
a9973 1
enable_once_breakpoint (struct breakpoint *bpt)
d9981 1
a9981 1
  map_breakpoint_numbers (args, enable_once_breakpoint);
d9985 1
a9985 1
enable_delete_breakpoint (struct breakpoint *bpt)
d9993 1
a9993 1
  map_breakpoint_numbers (args, enable_delete_breakpoint);
d10416 1
a10416 1
    map_breakpoint_numbers (arg, delete_breakpoint);
@


1.465
log
@	* breakpoint.c (check_no_tracepoint_commands): Use
	current spelling of 'teval'.
@
text
@d436 57
d843 2
a844 2
  free_command_lines (&b->commands);
  b->commands = commands;
a862 7
  /* If we allowed this, we would have problems with when to
     free the storage, if we change the commands currently
     being read from.  */

  if (executing_breakpoint_commands)
    error (_("Can't use the \"commands\" command among a breakpoint's commands."));

a899 7
  /* If we allowed this, we would have problems with when to
     free the storage, if we change the commands currently
     being read from.  */

  if (executing_breakpoint_commands)
    error (_("Can't use the \"commands\" command among a breakpoint's commands."));

d914 1
a914 1
	free_command_lines (&b->commands);
d919 2
a920 1
	b->commands = copy_command_lines (cmd->body_list[0]);
d2744 1
a2744 1
  free_command_lines (&bs->commands);
d2786 1
a2786 2
      if (bs->commands != NULL)
	tmp->commands = copy_command_lines (bs->commands);
d2887 1
a2887 1
      free_command_lines (&bs->commands);
d2953 1
d2967 6
a2972 3
      cmd = bs->commands;
      bs->commands = 0;
      this_cmd_tree_chain = make_cleanup_free_command_lines (&cmd);
d3355 1
d3993 7
a3999 4
	      if (bs->commands
		  && (strcmp ("silent", bs->commands->line) == 0
		      || (xdb_commands && strcmp ("Q",
						  bs->commands->line) == 0)))
d4001 1
a4001 1
		  bs->commands = bs->commands->next;
a4003 1
	      bs->commands = copy_command_lines (bs->commands);
d4670 1
a4670 1
  l = b->commands;
d9074 1
a9074 1
  free_command_lines (&bpt->commands);
d10499 1
a10499 1
	    print_command_lines (uiout, tp->commands, 2);
@


1.464
log
@	Unify actions and commands

	* defs.h (read_command_lines, read_command_lines_1): New
	parameters validator and closure.
	* tracepoint.h (struct action_line): Remove.
	* breakpoint.h (struct breakpoint): Remove the 'actions'
	field.
	* defs.h (enum command_control_type): New value
	while_stepping_control.
	(struct command_line): Add comments.
	* breakpoint.c (breakoint_is_tracepoint): New.
	(breakpoint_set_commands): For tracepoints,
	verify the commands are permissible.
	(check_tracepoint_commands): New.
	(commands_command): Require that each new line is validated using
	check_tracepoint_command, if we set commands for a tracepoint.
	(create_tracepoint_from_upload): Likewise.
	(print_one_breakpoint_location): Remove the code to print
	actions specifically.
	(tracepoint_save_command): Relay to print_command_lines.
	* cli/cli-script.c (process_next_line): New parameters validator
	and closure. Handle 'while-stepping'. Call validator if not null.
	(read_command_lines, read_command_lines1): Likewise.
	(recurse_read_control_structure): New parameters validator and
	closure. Handle while_stepping_control.
	(print_command_lines): Handle while-stepping.
	(get_command_line, define_command, document_command): Adjust.
	* remote.c (remote_download_tracepoint): Adjust.
	* tracepoint.c (make_cleanup_free_actions, read_actions)
	(free_actions, do_free_actions_cleanup): Remove.
	(trace_actions_command): Use read_command_lines.
	(validate_actionline): Use error in one place.
	(encode_actions_1): New, extracted from...
	(encode_actions): ...this. Also use cleanups for exception
	safety.
	(trace_dump_command): Adjust.
	* mi/mi-cmd-break (mi_cmd_break_commands): Validate commands if
	it's tracepoint.
@
text
@d719 2
a720 2
      if (strstr (c->line, "eval ") == c->line)
	error (_("The 'eval' command can only be used for tracepoints"));
@


1.463
log
@2010-03-22  Reid Kleckner  <reid@@kleckner.net>

	PR gdb/11094
	* breakpoint.c (disable_breakpoints_in_unloaded_shlib): Add
	bp_jit_event.
	(disable_breakpoints_in_shlibs): Likewise.
@
text
@d695 46
a740 1
/* Set the command list of B to COMMANDS.  */
d745 41
d792 6
d825 6
a830 1
	l = read_command_lines (tmpbuf, from_tty, 1);
a4638 20
  if (!part_of_multiple && b->step_count)
    {
      annotate_field (11);
      ui_out_text (uiout, "\tstep count ");
      ui_out_field_int (uiout, "step", b->step_count);
      ui_out_text (uiout, " \n");
    }

  if (!part_of_multiple && b->actions)
    {
      struct action_line *action;
      annotate_field (12);
      for (action = b->actions; action; action = action->next)
	{
	  ui_out_text (uiout, "      A\t");
	  ui_out_text (uiout, action->action);
	  ui_out_text (uiout, "\n");
	}
    }

d10398 2
a10399 4
  struct action_line *line;
  FILE *fp;
  char *i1 = "    ", *i2 = "      ";
  char *indent, *actionline, *pathname;
d10402 1
d10421 1
a10421 1
  fp = fopen (pathname, "w");
d10425 1
a10425 1
  make_cleanup_fclose (fp);
d10430 1
a10430 1
      fprintf (fp, "trace %s\n", tp->addr_string);
d10434 1
a10434 1
	fprintf (fp, "trace *0x%s\n", tmp);
d10438 1
a10438 1
      fprintf (fp, "  passcount %d\n", tp->pass_count);
d10440 1
a10440 1
    if (tp->actions)
d10442 6
a10447 3
	fprintf (fp, "  actions\n");
	indent = i1;
	for (line = tp->actions; line; line = line->next)
d10449 3
a10451 1
	    struct cmd_list_element *cmd;
d10453 2
a10454 4
	    QUIT;		/* allow user to bail out with ^C */
	    actionline = line->action;
	    while (isspace ((int) *actionline))
	      actionline++;
d10456 1
a10456 12
	    fprintf (fp, "%s%s\n", indent, actionline);
	    if (*actionline != '#')	/* skip for comment lines */
	      {
		cmd = lookup_cmd (&actionline, cmdlist, "", -1, 1);
		if (cmd == 0)
		  error (_("Bad action list item: %s"), actionline);
		if (cmd_cfunc_eq (cmd, while_stepping_pseudocommand))
		  indent = i2;
		else if (cmd_cfunc_eq (cmd, end_actions_pseudocommand))
		  indent = i1;
	      }
	  }
@


1.462
log
@    Simplify MI breakpoint setting.

    	* breakpoint.c (break_command_really): Make nonstatic and
    	rename to...
    	(create_breakpoint): ...this. Rename prior function by this name
    	to...
    	(create_breakpoint_sal): ...this.
    	(create_breakpoints): Rename to...
    	(create_breakpoints_sal): ...this.
    	(set_breakpoint): Remove.
    	* breakpoint.h: Adjust to above changes.
    	* mi/mi-cmd-break.c (mi_cmd_break_insert): Simplify.
@
text
@d5395 1
d5436 3
a5438 1
	&& (b->type == bp_breakpoint || b->type == bp_hardware_breakpoint)
@


1.461
log
@	gdb/
	* breakpoint.c (condition_command): Handle watchpoint conditions.
	(is_hardware_watchpoint): Add comment.
	(is_watchpoint): New.
	(update_watchpoint): Don't reparse the watchpoint's condition
	unless necessary.
	(WP_IGNORE): New.
	(watchpoint_check): Use it.
	(bpstat_check_watchpoint): Handle it.
	(bpstat_check_breakpoint_conditions): Evaluate watchpoint local
	conditions in a frame where it makes sense.
	(watch_command_1): Store the innermost block of the condition
	expression.
	(delete_breakpoint): Delete the watchpoint condition expression.
	* breakpoint.h (struct bp_location) <cond>: Update comment.
	(struct breakpoint): New fields `cond_exp' and
	`cond_exp_valid_block'.

	gdb/testsuite/
	* gdb.base/watch-cond.c, gdb.base/watch-cond.exp: New.
@
text
@d6464 6
a6469 6
create_breakpoint (struct gdbarch *gdbarch,
		   struct symtabs_and_lines sals, char *addr_string,
		   char *cond_string,
		   enum bptype type, enum bpdisp disposition,
		   int thread, int task, int ignore_count, 
		   struct breakpoint_ops *ops, int from_tty, int enabled)
d6727 7
a6733 7
create_breakpoints (struct gdbarch *gdbarch,
		    struct symtabs_and_lines sals, char **addr_string,
		    char *cond_string,
		    enum bptype type, enum bpdisp disposition,
		    int thread, int task, int ignore_count, 
		    struct breakpoint_ops *ops, int from_tty,
		    int enabled)
d6741 3
a6743 3
      create_breakpoint (gdbarch, expanded, addr_string[i],
			 cond_string, type, disposition,
			 thread, task, ignore_count, ops, from_tty, enabled);
d6958 10
a6967 10
static int
break_command_really (struct gdbarch *gdbarch,
		      char *arg, char *cond_string, int thread,
		      int parse_condition_and_thread,
		      int tempflag, int hardwareflag, int traceflag,
		      int ignore_count,
		      enum auto_boolean pending_break_support,
		      struct breakpoint_ops *ops,
		      int from_tty,
		      int enabled)
d7106 4
a7109 3
      create_breakpoints (gdbarch, sals, addr_string, cond_string, type_wanted,
			  tempflag ? disp_del : disp_donttouch,
			  thread, task, ignore_count, ops, from_tty, enabled);
d7167 9
a7175 9
  break_command_really (get_current_arch (),
			arg,
			NULL, 0, 1 /* parse arg */,
			tempflag, hardwareflag, 0 /* traceflag */,
			0 /* Ignore count */,
			pending_break_support, 
			NULL /* breakpoint_ops */,
			from_tty,
			1 /* enabled */);
a7178 16
void
set_breakpoint (struct gdbarch *gdbarch,
		char *address, char *condition,
		int hardwareflag, int tempflag,
		int thread, int ignore_count,
		int pending, int enabled)
{
  break_command_really (gdbarch,
			address, condition, thread,
			0 /* condition and thread are valid.  */,
			tempflag, hardwareflag, 0 /* traceflag */,
			ignore_count,
			pending 
			? AUTO_BOOLEAN_TRUE : AUTO_BOOLEAN_FALSE,
			NULL, 0, enabled);
}
d8042 8
a8049 8
  break_command_really (get_current_arch (),
			trigger_func_name, cond_string, -1,
			0 /* condition and thread are valid.  */,
			tempflag, 0, 0,
			0,
			AUTO_BOOLEAN_TRUE /* pending */,
			&gnu_v3_exception_catchpoint_ops, from_tty,
			1 /* enabled */);
d10014 10
a10023 10
  if (break_command_really (get_current_arch (),
			    arg,
			    NULL, 0, 1 /* parse arg */,
			    0 /* tempflag */, 0 /* hardwareflag */,
			    1 /* traceflag */,
			    0 /* Ignore count */,
			    pending_break_support,
			    NULL,
			    from_tty,
			    1 /* enabled */))
d10030 10
a10039 10
  if (break_command_really (get_current_arch (),
			    arg,
			    NULL, 0, 1 /* parse arg */,
			    0 /* tempflag */, 1 /* hardwareflag */,
			    1 /* traceflag */,
			    0 /* Ignore count */,
			    pending_break_support,
			    NULL,
			    from_tty,
			    1 /* enabled */))
d10058 11
a10068 11
  if (!break_command_really (get_current_arch (),
			     buf,
			     NULL, 0, 1 /* parse arg */,
			     0 /* tempflag */,
			     (utp->type == bp_fast_tracepoint) /* hardwareflag */,
			     1 /* traceflag */,
			     0 /* Ignore count */,
			     pending_break_support,
			     NULL,
			     0 /* from_tty */,
			     utp->enabled /* enabled */))
@


1.460
log
@	* breakpoint.c (breakpoint_1): Add "QUIT".
@
text
@d213 2
d645 2
a646 5
	    if (loc->cond)
	      {
		xfree (loc->cond);
		loc->cond = 0;
	      }
d648 4
a651 2
	if (b->cond_string != NULL)
	  xfree (b->cond_string);
a654 1
	    b->cond_string = NULL;
d665 2
a666 1
	    for (loc = b->loc; loc; loc = loc->next)
d668 1
d670 1
a670 2
		loc->cond =
		  parse_exp_1 (&arg, block_for_pc (loc->address), 0);
d673 12
d924 2
d934 10
d1151 15
a1291 10

      /* We just regenerated the list of breakpoint locations.
         The new location does not have its condition field set to anything
         and therefore, we must always reparse the cond_string, independently
         of the value of the reparse flag.  */
      if (b->cond_string != NULL)
	{
	  char *s = b->cond_string;
	  b->loc->cond = parse_exp_1 (&s, b->exp_valid_block, 0);
	}
d1300 5
a1304 1
	b->related_breakpoint->disposition = disp_del_at_next_stop;
d3288 2
d3313 1
a3313 1
    return WP_VALUE_NOT_CHANGED;
d3332 1
a3332 1
	return WP_VALUE_NOT_CHANGED;
a3382 1
	  /* We will stop here */
d3387 1
a3387 1
	  /* Nothing changed, don't do anything.  */
a3388 1
	  /* We won't stop here */
d3415 5
a3419 1
	b->related_breakpoint->disposition = disp_del_at_next_stop;
d3539 4
d3662 2
a3663 1
      
d3670 7
a3676 2
      
      if (bl->cond && bl->owner->disposition != disp_del_at_next_stop)
d3678 2
d3693 39
a3731 5
	  select_frame (get_current_frame ());
	  value_is_zero
	    = catch_errors (breakpoint_cond_eval, (bl->cond),
			    "Error in testing breakpoint condition:\n",
			    RETURN_MASK_ALL);
d3735 2
a3736 1
      if (bl->cond && value_is_zero)
d7394 1
a7394 1
  struct block *exp_valid_block;
d7499 1
d7502 5
d7547 1
a7547 1
  if (innermost_block && frame)
d7584 1
d8960 8
a8967 14
  if (bpt->cond_string != NULL)
    xfree (bpt->cond_string);
  if (bpt->addr_string != NULL)
    xfree (bpt->addr_string);
  if (bpt->exp != NULL)
    xfree (bpt->exp);
  if (bpt->exp_string != NULL)
    xfree (bpt->exp_string);
  if (bpt->val != NULL)
    value_free (bpt->val);
  if (bpt->source_file != NULL)
    xfree (bpt->source_file);
  if (bpt->exec_pathname != NULL)
    xfree (bpt->exec_pathname);
@


1.459
log
@	gdb/
	* breakpoint.c (update_watchpoint): Create a sentinel location if
	the software watchpoint isn't watching any memory.
	(breakpoint_address_bits): Skip dummy software watchpoint locations.

	gdb/testsuite/
	* gdb.base/watch-non-mem.c, gdb.base/watch-non-mem.exp: New.
@
text
@d4673 2
d4683 1
@


1.458
log
@	Multiexec MI

	* breakpoint.c (clear_syscall_counts): Take struct inferior*.
	* inferior.c (add_inferior_silent): Notify inferior_added
	observer.
	(delete_inferior_1): Notify inferior_removed observer.
	(exit_inferior_1): Pass inferior, not pid, to observer.
	(inferior_appeared): Likewise.
	(add_inferior_with_spaces): New.
	(add_inferior_command): Use the above.
	* inferior.h (delete_inferior_1, add_inferior_with_spaces):
	Declare.

	* inflow.c (inflow_inferior_exit): Likewise.
	* jit.c (jit_inferior_exit_hook): Likewise.

	* mi/mi-cmds.c (mi_cmds): Register add-inferior and
	remove-inferior.
	* mi/mi-cmds.h (mi_cmd_add_inferior, mi_cmd_remove_inferior): New.
	* mi/mi-interp.c (mi_inferior_added, mi_inferior_removed): New.
	(report_initial_inferior): New.
	(mi_inferior_removed): Register the above. Make sure
	inferior_added observer is called on the first inferior.
	(mi_new_thread, mi_thread_exit): Thread group is now identified by
	inferior number, not pid.
	(mi_solib_loaded, mi_solib_unloaded): Report which inferiors are
	affected.
	* mi/mi-main.c (current_context): New.
	(proceed_thread_callback): Use typed closure.
	Proceed everything if pid is 0. Most implementation split into
	(proceed_thread): ... this.
	(run_one_inferior): New.
	(mi_cmd_exec_continue, mi_cmd_exec_interrupt, mi_cmd_exec_run):
	Adjust for multiexec behaviour.
	(mi_cmd_add_inferior, mi_cmd_remove_inferior): New.
	(mi_cmd_execute): Handle the 'thread-group' option here.
	Do some extra checks.
	* mi-parse.c (mi_parse): Handle the --all and --thread-group
	options.
	* mi-parse.h (struct mi_parse): New fields all and thread_group.
@
text
@d1240 13
d4532 8
a4539 1
      int addr_bit = gdbarch_addr_bit (loc->gdbarch);
@


1.457
log
@	* breakpoint.c (breakpoint_init_inferior): Also delete
	bp_shlib_event breakpoints.
	* solib-frv.c (enable_break): Remove call to
	remove_solib_event_breakpoints.
	* solib-svr4.c (enable_break): Ditto.
	* solib-darwin.c (darwin_solib_create_inferior_hook): Ditto.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Ditto.
	* solib-som.c (som_solib_create_inferior_hook): Ditto.
	* solib-spu.c (spu_enable_break): Ditto.
@
text
@d10369 1
a10369 1
clear_syscall_counts (int pid)
a10370 2
  struct inferior *inf = find_inferior_pid (pid);

@


1.456
log
@2010-02-22  Pedro Alves  <pedro@@codesourcery.com>

	PR9605

	gdb/
	* breakpoint.c (insert_bp_location): If inserting the read
	watchpoint failed, fallback to an access watchpoint.
	(bpstat_check_watchpoint): Stop for read watchpoint triggers even
	if the value changed, if not watching the same memory for writes.
	(watchpoint_locations_match): Add comment.
	(update_global_location_list): Copy the location's watchpoint type.
	* i386-nat.c (i386_length_and_rw_bits): It's an internal error to
	handle read watchpoints here.
	(i386_insert_watchpoint): Read watchpoints aren't supported.
	* remote.c (remote_insert_watchpoint): Return 1 for unsupported
	packets.
	* target.h (target_insert_watchpoint): Update description.

2010-02-22  Pedro Alves  <pedro@@codesourcery.com>

	PR9605

	gdbserver/
	* i386-low.c (i386_length_and_rw_bits): Throw a fatal error if
	handing a read watchpoint.
	(i386_low_insert_watchpoint): Read watchpoints aren't supported.

2010-02-22  Pedro Alves  <pedro@@codesourcery.com>

	PR9605

	gdb/testsuite/
	* gdb.base/watch-read.c, gdb.base/watch-read.exp: New files.
@
text
@d2251 5
d2258 17
a2274 3
	/* If the call dummy breakpoint is at the entry point it will
	   cause problems when the inferior is rerun, so we better
	   get rid of it. 
a2275 1
	   Also get rid of scope breakpoints.  */
@


1.455
log
@	* breakpoint.c (allocate_bp_location): Use bp_loc_other for
	bp_tracepoint and bp_fast_tracepoint, not
	bp_loc_software_breakpoint.
	(update_global_location_list): Tracepoints are never duplicates of
	anything.
@
text
@d130 3
d1491 1
a1491 1
      val = target_insert_watchpoint (bpt->address, 
d1494 34
a1527 1
      bpt->inserted = (val != -1);
d3473 61
a3533 5
		  /* Don't stop: read watchpoints shouldn't fire if
		     the value has changed.  This is for targets
		     which cannot set read-only watchpoints.  */
		  bs->print_it = print_it_noop;
		  bs->stop = 0;
d4792 6
d8560 10
@


1.454
log
@	* breakpoint.c (break_command_really): Change return type to int.
	Return false if no breakpoint was created, true otherwise.
	(trace_command): Don't set the tracepoint count if no tracepoint
	was created.
	(ftrace_command): Ditto.
	(create_tracepoint_from_upload): Bail out if the tracepoint wasn't
	created in the breakpoints table.
@
text
@a4814 2
    case bp_tracepoint:
    case bp_fast_tracepoint:
d4839 2
d8578 2
a8579 1
	  || !breakpoint_address_is_meaningful (b))
@


1.453
log
@gdb/
	* breakpoint.c (delete_breakpoint) <bpt->related_breakpoint != NULL>:
	New.
@
text
@d6725 8
a6732 9
/* Set a breakpoint.  This function is shared between
   CLI and MI functions for setting a breakpoint.
   This function has two major modes of operations,
   selected by the PARSE_CONDITION_AND_THREAD parameter.
   If non-zero, the function will parse arg, extracting
   breakpoint location, address and thread. Otherwise,
   ARG is just the location of breakpoint, with condition
   and thread specified by the COND_STRING and THREAD
   parameters.  */
d6734 1
a6734 1
static void
d6795 1
a6795 1
	    return;
d6813 1
a6813 1
	return;
d6925 2
d9793 11
a9803 11
  break_command_really (get_current_arch (),
			arg,
			NULL, 0, 1 /* parse arg */,
			0 /* tempflag */, 0 /* hardwareflag */,
			1 /* traceflag */,
			0 /* Ignore count */,
			pending_break_support, 
			NULL,
			from_tty,
			1 /* enabled */);
  set_tracepoint_count (breakpoint_count);
d9809 11
a9819 11
  break_command_really (get_current_arch (),
			arg, 
			NULL, 0, 1 /* parse arg */,
			0 /* tempflag */, 1 /* hardwareflag */,
			1 /* traceflag */,
			0 /* Ignore count */,
			pending_break_support, 
			NULL,
			from_tty,
			1 /* enabled */);
  set_tracepoint_count (breakpoint_count);
d9833 1
a9833 1
  
d9837 13
a9849 11
  break_command_really (get_current_arch (),
			buf, 
			NULL, 0, 1 /* parse arg */,
			0 /* tempflag */,
			(utp->type == bp_fast_tracepoint) /* hardwareflag */,
			1 /* traceflag */,
			0 /* Ignore count */,
			pending_break_support, 
			NULL,
			0 /* from_tty */,
			utp->enabled /* enabled */);
d9852 2
a9853 1
    tp = get_tracepoint (tracepoint_count);
@


1.452
log
@	* breakpoint.c (bpstat_stop_status): Delete useless code.
@
text
@d8694 10
@


1.451
log
@gdb/
	* breakpoint.c (watchpoint_check): Check the call
	gdbarch_in_function_epilogue_p before calling frame_find_by_id.
	Extend the comment.
	* config/djgpp/fnchange.lst: Add translations for
	watchpoint-cond-gone.exp, watchpoint-cond-gone.c and
	watchpoint-cond-gone-stripped.c.

gdb/testsuite/
	* gdb.base/watchpoint-cond-gone.exp, gdb.base/watchpoint-cond-gone.c,
	gdb.base/watchpoint-cond-gone-stripped.c: New.
@
text
@a3670 1
  bs = root_bs->next;		/* Re-grab the head of the chain */
@


1.450
log
@Delete unused or undefined functions.

        * breakpoint.c (ep_parse_optional_filename): Delete.
        * dcache.c (dcache_write_line): Remove declaration.
        * infrun.c (build_infrun): Remove declaration.
        * tracepoint.c (tracepoint_save_command): Remove declaration.
        * linux-nat.c (init_lwp_list): Delete. No longer used.
        * event-loop.c (check_async_signal_handlers): Delete declaration.
        * infrun.c (init_execution_control_state): Delete.
        (proceed): Update comment to avoid mentioning
        init_execution_control_state.
        * target.c (kill_or_be_killed, nosupport_runtime): Delete.
        * ada-lang.c (ada_to_static_fixed_value): Delete.
        * scm-lang.c (evaluate_subexp_scm): Delete declaration.
        * cp-namespace.c (cp_copy_usings): Delete.
        * xml-syscall.c (xml_number_of_syscalls): Delete.
        * progspace.c (find_program_space_by_num): Delete.
        * inflow.c (handle_sigio): Delete declaration.
        * hppa-tdep.c (hppa_alignof): Delete.
        * mipsnbsd-tdep.c (mipsnbsd_sigtramp_offset)
        (mipsnbsd_core_osabi_sniffer): Delete.
@
text
@d3220 11
a3246 11
      /* in_function_epilogue_p() returns a non-zero value if we're still
	 in the function but the stack frame has already been invalidated.
	 Since we can't rely on the values of local variables after the
	 stack has been destroyed, we are treating the watchpoint in that
	 state as `not changed' without further checking.  Don't mark
	 watchpoints as changed if the current frame is in an epilogue -
	 even if they are in some other frame, our view of the stack
	 is likely to be wrong.  */
      if (gdbarch_in_function_epilogue_p (frame_arch, frame_pc))
	return WP_VALUE_NOT_CHANGED;

@


1.449
log
@	Add trace file support.
	* tracepoint.h (enum trace_stop_reason): New enum.
	(struct trace_status): New struct.
	(parse_trace_status): Declare.
	(struct uploaded_tp): Move here from remote.c,
	add fields for actions.
	(struct uploaded_tsv): New struct.
	* tracepoint.c (tfile_ops): New target vector.
	(trace_fd): New global.
	(tfile_open): New function.
	(tfile_close): New function.
	(tfile_files_info): New function.
	(tfile_get_trace_status): New function.
	(tfile_get_traceframe_address): New function.
	(tfile_trace_find): New function.
	(tfile_fetch_registers): New function.
	(tfile_xfer_partial): New function.
	(tfile_get_trace_state_variable_value): New function.
	(init_tfile_ops): New function.
	(_initialize_tracepoint): Call it, add tfile target.
	(trace_status): New global.
	(current_trace_status): New function.
	(trace_running_p): Remove, change all users to get from
	current_trace_status()->running.
	(get_trace_status): Remove.
	(trace_status_command): Call target_get_trace_status directly,
	report more detail including tracing stop reasons.
	(trace_find_command): Always allow tfind on a file.
	(trace_find_pc_command): Ditto.
	(trace_find_tracepoint_command): Ditto.
	(trace_find_line_command): Ditto.
	(trace_find_range_command): Ditto.
	(trace_find_outside_command): Ditto.
	(trace_frames_offset, cur_offset): Declare as off_t.
	(trace_regblock_size): Rename from reg_size, update users.
	(parse_trace_status): New function.
	(tfile_interp_line): New function.
	(disconnect_or_stop_tracing): Ensure current trace
	status before asking what to do.
	(stop_reason_names): New global.
	(trace_save_command): New command.
	(get_uploaded_tp): Move here from remote.c.
	(find_matching_tracepoint): Ditto.
	(merge_uploaded_tracepoints): New function.
	(parse_trace_status): Use stop_reason_names.
	(_initialize_tracepoint): Define tsave command.
	* target.h (target_ops): New fields to_save_trace_data,
	to_upload_tracepoints, to_upload_trace_state_variables,
	to_get_raw_trace_data, change to_get_trace_status
	to take a pointer to a status struct.
	(target_save_trace_data): New macro.
	(target_upload_tracepoints): New macro.
	(target_upload_trace_state_variables): New macro.
	(target_get_raw_trace_data): New macro.
	* target.c (update_current_target): Add new methods, change
	signature of to_get_trace_status.
	* remote.c (hex2bin): Make globally visible.
	(bin2hex): Ditto.
	(remote_download_trace_state_variable): Download name also.
	(remote_get_trace_status): Update parameter, use
	parse_trace_status.
	(remote_save_trace_data): New function.
	(remote_upload_tracepoints): New function.
	(remote_upload_trace_state_variables): New function.
	(remote_get_raw_trace_data): New function.
	(remote_start_remote): Use them.
	(_initialize_remote_ops): Add operations.
	* ax-gdb.c: Include breakpoint.h.
	* breakpoint.c (create_tracepoint_from_upload): Use
	break_command_really, return tracepoint, warn about unimplemented
	parts.
	* NEWS: Mention trace file addition.

	* gdb.texinfo (Trace Files): New section.
	(Tracepoint Packets): Document QTSave and qTBuffer.
	(Trace File Format): New appendix.

	* generic/gdbtk-bp.c (gdb_trace_status): Use current_trace_status.

	* gdb.trace/tfile.c: New file.
	* gdb.trace/tfile.exp: New file.
@
text
@a189 2
static char *ep_parse_optional_filename (char **arg);

a7651 36
/* This function attempts to parse an optional filename from the arg
   string.  If one is not found, it returns NULL.

   Else, it returns a pointer to the parsed filename.  (This function
   makes no attempt to verify that a file of that name exists, or is
   accessible.)  And, it updates arg to point to the first character
   following the parsed filename in the arg string.

   Note that clients needing to preserve the returned filename for
   future access should copy it to their own buffers. */
static char *
ep_parse_optional_filename (char **arg)
{
  static char filename[1024];
  char *arg_p = *arg;
  int i;
  char c;

  if ((*arg_p == '\0') || isspace (*arg_p))
    return NULL;

  for (i = 0;; i++)
    {
      c = *arg_p;
      if (isspace (c))
	c = '\0';
      filename[i] = c;
      if (c == '\0')
	break;
      arg_p++;
    }
  *arg = arg_p;

  return filename;
}

@


1.448
log
@	Support disconnected tracing.
	* infcmd.c (detach_command): Ask whether to stop tracing.
	* cli/cli-cmds.c (quit_command): Ditto.
	* breakpoint.h (struct breakpoint): New field number_on_target.
	* breakpoint.c (create_tracepoint_from_upload): New function.
	(get_tracepoint_by_number_on_target): New function.
	* remote.c (struct remote): New field disconnected_tracing.
	(remote_disconnected_tracing_feature): New function.
	(remote_protocol_features): Add DisconnectedTracing.
	(struct uploaded_tp): New struct.
	(uploaded_tps): New global.
	(get_uploaded_tp): New function.
	(find_matching_tracepoint): New function.
	(remote_get_tracing_state): New function.
	(remote_start_remote): Call it.
	* tracepoint.c (disconnected_tracing): New global.
	(trace_start_command): Initialize number_on_target.
	(stop_tracing): New function, split out from...
	(trace_stop_command): Call stop_tracing.
	(get_trace_status): New function, split out from...
	(trace_status_command): Call get_trace_status, add info on
	disconnection behavior.
	(disconnect_or_stop_tracing): New function.
	(finish_tfind_command): Translate from number on target.
	(trace_find_tracepoint_command): Translate to number on target.
	(send_disconnected_tracing_value): New function.
	(set_disconnected_tracing): New function.
	(_initialize_tracepoint): Add disconnected-tracing variable.
	* NEWS: Mention disconnected tracing.

	* gdb.texinfo (Starting and Stopping Trace Experiments): Document
	disconnected tracing.
	(Tracepoint Packets): Document new protocol.
@
text
@d9850 8
a9857 5
extern void create_tracepoint_from_upload (int num, enum bptype type,
					   ULONGEST addr);

void
create_tracepoint_from_upload (int num, enum bptype type, ULONGEST addr)
d9861 25
d9887 9
a9895 5
  sprintf (buf, "*0x%s", paddress (get_current_arch (), addr));
  if (type == bp_fast_tracepoint)
    ftrace_command (buf, 0);
  else
    trace_command (buf, 0);
d9897 4
a9900 5
  /* Record that this tracepoint is numbered differently on host and
     target.  */
  tp = get_tracepoint (tracepoint_count);
  tp->number_on_target = num;
}
d9902 3
@


1.447
log
@	Add fast tracepoints.
	* arch-utils.h (default_fast_tracepoint_valid_at): Declare.
	* arch-utils.c (default_fast_tracepoint_valid_at): New function.
	* breakpoint.h (enum bptype): Add bp_fast_tracepoint.
	* breakpoint.c (tracepoint_type): New function.
	(ALL_TRACEPOINTS): Use it.
	(should_be_inserted): Ditto.
	(bpstat_check_location): Ditto.
	(print_one_breakpoint_location): Ditto.
	(user_settable_breakpoint): Ditto.
	(set_breakpoint_location_function): Ditto.
	(disable_breakpoints_in_shlibs): Ditto.
	(delete_trace_command): Ditto.
	(print_it_typical): Add bp_fast_tracepoint case.
	(bpstat_what): Ditto.
	(print_one_breakpoint_location): Ditto.
	(allocate_bp_location): Ditto.
	(mention): Ditto.
	(breakpoint_re_set_one): Ditto.
	(disable_command): Ditto.
	(enable_command): Ditto.
	(check_fast_tracepoint_sals): New function.
	(break_command_really): Call it.
	(ftrace_command): New function.
	(_initialize_breakpoint): Add ftrace command.
	* gdbarch.sh (fast_tracepoint_valid_at): New.
	* gdbarch.h, gdbarch.c: Regenerate.
	* i386-tdep.c (i386_fast_tracepoint_valid_at): New function.
	(i386_gdbarch_init): Use it.
	* remote.c (struct remote_state): New field fast_tracepoints.
	(PACKET_FastTracepoints): New packet config type.
	(remote_fast_tracepoint_feature): New function.
	(remote_protocol_features): Add FastTracepoints.
	(remote_supports_fast_tracepoints): New function.
	(_initialize_remote): Add FastTracepoints.
	* tracepoint.c (download_tracepoint): Add fast tracepoint option.
	* NEWS: Mention fast tracepoints.

	* gdb.texinfo (Create and Delete Tracepoints): Describe fast
	tracepoints.
	(Tracepoint Packets): Describe remote protocol for fast
	tracepoints.

	* gdb.trace/tracecmd.exp: Test ftrace.
@
text
@d9850 21
d10021 16
@


1.446
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d356 1
a356 1
    if ((B)->type == bp_tracepoint)
d425 8
d1293 1
a1293 1
  if (bpt->owner->type == bp_tracepoint)
d2988 1
d3334 1
a3334 1
  if (b->type == bp_tracepoint)
d3926 1
d3931 1
a3931 1
			  _("bpstat_what: bp_tracepoint encountered"));
d4057 1
d4187 1
d4273 1
a4273 1
      if (b->type == bp_tracepoint)
d4466 1
a4466 1
	  || b->type == bp_tracepoint
d4819 1
d4916 1
a4916 1
      || loc->owner->type == bp_tracepoint)
d5175 1
a5175 1
	 || (b->type == bp_tracepoint))
d6107 10
d6619 32
d6852 1
a6852 1
		 ? bp_tracepoint
d6855 4
d9032 1
d9432 1
d9526 1
d9834 16
d9927 1
a9927 1
	    if (b->type == bp_tracepoint
d10582 7
@


1.445
log
@20090-12-30  Jan Kratochvil  <jan.kratochvil@@redhat.com>
	     Thiago Jung Bauermann  <bauerman@@br.ibm.com>

	* breakpoint.c (update_watchpoint): Change b->type to
	bp_watchpoint before calling hw_watchpoint_used_count.
@
text
@d5 1
a5 1
   2008, 2009 Free Software Foundation, Inc.
@


1.444
log
@        * breakpoint.c (watchpoint_check): Expand the function description.
@
text
@d1155 7
@


1.443
log
@gdb/
	* valarith.c (value_equal_contents): New function.
	* value.h (value_equal_contents): Declare.
	* breakpoint.c (watchpoint_check): Use value_equal_contents
	instead of value_equal.

gdb/testsuite/
	* gdb.base/watchpoint.exp (test_watchpoint_in_big_blob): New function.
	(top level): Call test_watchpoint_in_big_blob.
	* gdb.base/watchpoint.c (buf): Change size to value too big for hardware
	watchpoints.
	(func3): Write to buf.
@
text
@d3177 4
a3180 1
/* Evaluate watchpoint condition expression and check if its value changed.  */
@


1.442
log
@	* defs.h (print_address_symbolic, build_address_symbolic): Update
	prototypes.
	* printcmd.c (print_address_symbolic): Take a gdbarch argument.
	Pass it to build_address_symbolic.  All callers updated.
	(build_address_symbolic): Take a gdbarch argument.  Use
	gdbarch_addr_bits_remove for functions.  All callers updated.
@
text
@d3177 1
a3177 1
/* Check watchpoint condition.  */
d3248 4
d3253 1
a3253 1
	  || (b->val != NULL && !value_equal (b->val, new_val)))
@


1.441
log
@gdb/
	* breakpoint.c (bpstat_stop_status): Iterate using ALL_BREAKPOINTS and
	the B->LOC list.  Remove gdb_assert on B.  Change bp_hardware_watchpoint
	continue to break.  Remove variable update_locations.  Remove HIT_COUNT
	increment protection by an ENABLE_STATE check.  Inline the delayed
	update_global_location_list call.

gdb/testsuite/
	* gdb.base/condbreak.exp: Put breakpoint on marker3 and marker4.
	(bp_location13, bp_location14, bp_location17, bp_location18)
	(marker3_proto, marker4_proto): New variables.
	(breakpoint info): Update output.
	(run until breakpoint at marker3, run until breakpoint at marker4): New
	tests.
@
text
@d3985 2
a3986 1
      print_address_symbolic (loc->address, stb->stream, demangle, "");
@


1.440
log
@gdb/
	* breakpoint.c (bpstat_stop_status): Check BL->SHLIB_DISABLED.
	(print_breakpoint_location): New comment.  Check LOC->SHLIB_DISABLED.
	Check LOC validity before printing it.  Use LOC instead of B->LOC.
	Swap the if conditionals order.

gdb/testsuite/
	* gdb.base/unload.c (main): Change the UNLOADSHR parameter to 1.
	Replace the printf call of Y by provided "y-set-1" label.  New block
	for the second shared library.
	* gdb.base/unload.exp: Compile also the second library, call
	gdb_load_shlibs also for it.  Use now gdb_breakpoint.
	(single pending breakpoint info): Rename to ...
	(pending breakpoint info before run): ... this extended test.
	(libfile2, libname2, libsrcfile2, libsrc2)
	(lib_sl2): New variables.
	(exec_opts): Set also SHLIB_NAME2.
	(pending breakpoint info on first run at shrfunc1)
	(pending breakpoint info on second run at shrfunc1)
	(pending breakpoint info on second run at shrfunc2)
	(print y from libfile, print y from libfile2): New tests.
	* gdb.base/unloadshr.c (shrfunc1): Change the returned value.
	* gdb.base/unloadshr2.c: New.
@
text
@d3557 1
a3557 1
  int need_remove_insert, update_locations = 0;
d3559 38
a3596 45
  ALL_BP_LOCATIONS (bl, blp_tmp)
  {
    b = bl->owner;
    gdb_assert (b);
    if (!breakpoint_enabled (b) && b->enable_state != bp_permanent)
      continue;
    if (bl->shlib_disabled)
      continue;

    /* For hardware watchpoints, we look only at the first location.
       The watchpoint_check function will work on entire expression,
       not the individual locations.  For read watchopints, the
       watchpoints_triggered function have checked all locations
       already.  */
    if (b->type == bp_hardware_watchpoint && bl != b->loc)
      continue;

    if (!bpstat_check_location (bl, aspace, bp_addr))
      continue;

    /* Come here if it's a watchpoint, or if the break address matches */

    bs = bpstat_alloc (bl, bs);	/* Alloc a bpstat to explain stop */

    /* Assume we stop.  Should we find watchpoint that is not actually
       triggered, or if condition of breakpoint is false, we'll reset
       'stop' to 0.  */
    bs->stop = 1;
    bs->print = 1;

    bpstat_check_watchpoint (bs);
    if (!bs->stop)
      continue;

    if (b->type == bp_thread_event || b->type == bp_overlay_event
	|| b->type == bp_longjmp_master)
      /* We do not stop for these.  */
      bs->stop = 0;
    else
      bpstat_check_breakpoint_conditions (bs, ptid);
  
    if (bs->stop)
      {
	if (b->enable_state != bp_disabled)
	  ++(b->hit_count);
d3598 10
a3607 19
	/* We will stop here */
	if (b->disposition == disp_disable)
	  {
	    if (b->enable_state != bp_permanent)
	      b->enable_state = bp_disabled;
	    update_locations = 1;
	  }
	if (b->silent)
	  bs->print = 0;
	bs->commands = b->commands;
	if (bs->commands
	    && (strcmp ("silent", bs->commands->line) == 0
		|| (xdb_commands && strcmp ("Q", bs->commands->line) == 0)))
	  {
	    bs->commands = bs->commands->next;
	    bs->print = 0;
	  }
	bs->commands = copy_command_lines (bs->commands);
      }
d3609 20
a3628 4
    /* Print nothing for this entry if we dont stop or if we dont print.  */
    if (bs->stop == 0 || bs->print == 0)
      bs->print_it = print_it_noop;
  }
d3630 5
a3634 3
  /* Delay this call which would break the ALL_BP_LOCATIONS iteration above.  */
  if (update_locations)
    update_global_location_list (0);
@


1.439
log
@2009-12-17  Stan Shebs  <stan@@codesourcery.com>

	* breakpoint.c (bpstat_check_location): Check for tracepoints.
@
text
@d3565 2
d3940 2
d3949 3
d3955 1
a3955 1
  if (b->source_file)
d3981 1
a3981 5
  else if (!b->loc)
    {
      ui_out_field_string (uiout, "pending", b->addr_string);
    }
  else
d3986 2
@


1.438
log
@ChangeLog:

2009-12-03  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	PR gdb/11022

	* breakpoint.c (invalidate_bp_value_on_memory_change):
	New function.
	(_initialize_breakpoint): Add it as memory change observer.

testsuite/ChangeLog:

2009-12-03  Paul Pluzhnikov  <ppluzhnikov@@google.com>

       PR gdb/11022

       * gdb.base/pr11022.exp: New test.
       * gdb.base/pr11022.c: New test.
@
text
@d3309 5
@


1.437
log
@	PR gdb/8704

	* breakpoint.c (find_condition_and_thread): Correct task error message.
	* c-exp.y (yylex): Stop before "thread N", "task N", or abbreviations
	of those.

	doc/
	* gdb.texinfo (Thread-Specific Breakpoints): Thread specifiers
	are allowed after the breakpoint condition.

	testsuite/
	* gdb.base/condbreak.exp: Test combinations of "break *EXP",
	"if", and "thread".  Correct matching in the previous test.
@
text
@d9493 29
d10109 1
@


1.436
log
@        * breakpoint.c (expand_line_sal_maybe): Adjust adjust the SAL
        past the function prologue in the case where we were given only
        one SAL.
@
text
@d6639 1
a6639 1
	    error (_("Unknown task %d\n"), *task);
@


1.435
log
@        Make hardware watchpoints work for process record.

        * breakpoint.c (hardware_watchpoint_inserted_in_range): New.
	* breakpoint.h (hardware_watchpoint_inserted_in_range): Declare.
	* record.c (record_beneath_to_stopped_by_watchpoint)
	(record_beneath_to_stopped_data_address, record_hw_watchpoint):
	New globals.
	(record_exec_insn): Check for watchpoint hits.
	(tmp_to_stopped_by_watchpoint, tmp_to_stopped_data_address): New
	globals.
	(record_open): Set tmp_to_stopped_by_watchpoint,
	tmp_to_stopped_data_address,
	record_beneath_to_stopped_by_watchpoint and
	record_beneath_to_stopped_data_address.
	(record_wait): Report watchpoint hits to the core.  Update and
	extend comments.
	(record_stopped_by_watchpoint): New.
	(record_stopped_data_address): New.
	(init_record_ops): Install them.
	(init_record_core_ops): Ditto.
@
text
@d6343 2
a6344 2
      /* We had one sal, we got one sal.  Without futher
	 processing, just return the original sal.  */
d6350 1
@


1.434
log
@	* breakpoint.c (update_watchpoint): Skip creating locations and
	reading the selected frame if there's no execution.
	(bpstat_stop_status): Use is_hardware_watchpoint.  If not
	stopping, update watchpoints and the global location list, instead
	of removing and inserting all breakpoints.
	(breakpoint_address_is_meaningful): Hardware watchpoints also have
	a meaningful target address.
	(watchpoint_locations_match): New.
	(breakpoint_locations_match): New.
	(watch_command_1): Create the watchpoint breakpoint without any
	location initially.  Use update_watchpoint to create the
	watchpoint locations.
	(update_global_location_list): Use breakpoint_locations_match, so
	watchpoint locations are handled too.  Also detect duplicate
	watchpoint locations.
@
text
@d2383 32
@


1.433
log
@	gdb/
	* breakpoint.h (struct breakpoint) <watchpoint_thread>: New field.
	* breakpoint.c (watchpoint_in_thread_scope): New.
	(update_watchpoint): Skip if the local watchpoint's thread doesn't
	match the current thread, or if the current thread is running.
	(watchpoint_check): Ditto.
	(watch_command_1): Set the watchpoint's watchpoint_thread field.

	gdb/testsuite/
	* gdb.threads/local-watch-wrong-thread.c,
	gdb.threads/local-watch-wrong-thread.exp: New files.
@
text
@a1061 1
  struct program_space *frame_pspace;
a1099 2
  frame_pspace = get_frame_program_space (get_selected_frame (NULL));

d1124 7
a1130 1
  if (within_current_scope && b->exp)
d1133 1
d1172 2
d3624 5
a3628 7
	  && (bs->breakpoint_at->owner->type == bp_hardware_watchpoint
	      || bs->breakpoint_at->owner->type == bp_read_watchpoint
	      || bs->breakpoint_at->owner->type == bp_access_watchpoint))
	{
	  /* remove/insert can invalidate bs->breakpoint_at, if this
	     location is no longer used by the watchpoint.  Prevent
	     further code from trying to use it.  */
d3634 1
a3634 4
    {
      remove_breakpoints ();
      insert_breakpoints ();
    }
d4614 3
a4616 4
      bp_hardware_watchpoint
      bp_read_watchpoint
      bp_access_watchpoint
      bp_catchpoint */
d4623 13
a4635 5
  return (type != bp_watchpoint
	  && type != bp_hardware_watchpoint
	  && type != bp_read_watchpoint
	  && type != bp_access_watchpoint
	  && type != bp_catchpoint);
d4652 19
a7051 1
  struct symtab_and_line sal;
a7061 1
  struct expression *cond = NULL;
a7066 2
  init_sal (&sal);		/* initialize to zeroes */

a7127 2
  sal.pspace = current_program_space;

d7156 2
d7160 1
d7230 1
a7230 1
  b = set_raw_breakpoint (gdbarch, sal, bp_type);
a7239 1
  b->loc->cond = cond;
d7265 5
d8268 10
a8277 3
  /* The first bp_location being the only one non-DUPLICATE for the current run
     of the same ADDRESS.  */
  struct bp_location *loc_first;
d8376 1
a8376 4
		      if (breakpoint_address_match (loc2->pspace->aspace,
						    loc2->address,
						    old_loc->pspace->aspace,
						    old_loc->address))
d8473 14
a8486 8
  /* Rescan breakpoints at the same address and section,
     marking the first one as "first" and any others as "duplicates".
     This is so that the bpt instruction is only inserted once.
     If we have a permanent breakpoint at the same place as BPT, make
     that one the official one, and the rest as duplicates.  Permanent
     breakpoints are sorted first for the same address.  */

  loc_first = NULL;
d8490 1
d8506 12
a8517 5
      if (loc_first == NULL
	  || (overlay_debugging && loc->section != loc_first->section)
	  || !breakpoint_address_match (loc->pspace->aspace, loc->address,
					loc_first->pspace->aspace,
					loc_first->address))
d8519 1
a8519 1
	  loc_first = loc;
d8526 2
a8527 2
      if (loc_first->owner->enable_state == bp_permanent && loc->inserted
          && b->enable_state != bp_permanent)
@


1.432
log
@gdb/
	* breakpoint.c (bp_location_compare): Change parameter a to ap and b to
	bp.  New variables a and b.
	(bp_location_compare_for_qsort): Remove.
	(update_global_location_list): Use now bp_location_compare.
@
text
@d988 18
d1064 6
d3151 6
d7223 4
a7226 1
    b->watchpoint_frame = get_frame_id (frame);
d7228 4
a7231 1
    b->watchpoint_frame = null_frame_id;
@


1.431
log
@gdb/
	Fix repeated rwatch output.
	* amd64-linux-nat.c (amd64_linux_dr_set, amd64_linux_dr_set_control)
	(amd64_linux_dr_set_addr, amd64_linux_dr_reset_addr)
	(amd64_linux_dr_get_status): New comments.
	(amd64_linux_dr_unset_status): New function.
	(_initialize_amd64_linux_nat): Install it.
	* i386-linux-nat.c (i386_linux_dr_get, i386_linux_dr_set)
	(i386_linux_dr_set_control, i386_linux_dr_set_addr)
	(i386_linux_dr_reset_addr, i386_linux_dr_get_status): New comments.
	(i386_linux_dr_unset_status): New function.
	(_initialize_i386_linux_nat): Install it.
	* i386-nat.c (I386_DR_WATCH_MASK): New macro.
	(I386_DR_WATCH_HIT): Use I386_DR_WATCH_MASK.
	(i386_insert_aligned_watchpoint): Call i386_dr_low.unset_status.
	* i386-nat.h (struct i386_dr_low_type): Extend comments for
	set_control, set_addr, reset_addr and get_status.  New unset_status.
	* breakpoint.c (update_watchpoint): Extend the comment.

gdb/testsuite/
	* gdb.base/watchpoint-hw-hit-once.exp,
	gdb.base/watchpoint-hw-hit-once.c: New.
@
text
@d8115 1
a8115 1
/* A comparison function for bp_location A and B being interfaced to qsort.
d8122 1
a8122 1
bp_location_compare (struct bp_location *a, struct bp_location *b)
d8124 2
a8145 11
/* Interface bp_location_compare as the COMPAR parameter of qsort function.  */

static int
bp_location_compare_for_qsort (const void *ap, const void *bp)
{
  struct bp_location *a = *(void **) ap;
  struct bp_location *b = *(void **) bp;

  return bp_location_compare (a, b);
}

d8229 1
a8229 1
	 bp_location_compare_for_qsort);
@


1.430
log
@2009-10-25  Michael Snyder  <msnyder@@vmware.com>

        * target.h (struct target_ops): New methods to_get_bookmark
        and to_goto_bookmark.
        (target_get_bookmark): New macro.
        (target_goto_bookmark): New macro.
        * target.c (dummy_get_bookmark): New function, default implementation.
        (dummy_goto_bookmark): New function, default implementation.
        (update_current_target): Inherit new methods.
        * record.c (record_get_bookmark): New function.
        (record_goto_bookmark): New function.
        (init_record_ops): Set to_get_bookmark and to_goto_bookmark methods.
        * reverse.c (struct bookmark): New type.
        (save_bookmark_command): New function (command).
        (delete_bookmark_command): New function (command).
        (goto_bookmark_command): New function (command).
        (bookmarks_info): New function (command).
        (_initialize_reverse): Add new bookmark commands.
	* command.h (enum command_class): Add class_bookmark.
	* NEWS: Mention bookmark commands.
@
text
@d996 40
a1035 1
   If this is local watchpoint that is out of scope, delete it.  */
@


1.429
log
@	* breakpoint.c (update_global_location_list): Fix duplicate
	locations detection.
@
text
@d10145 2
@


1.428
log
@	* infrun.c (handle_inferior_event): Hardware hatchpoint traps are
	never random signals.
	* breakpoint.c (update_global_location_list): Always delete
	immediately delete hardware watchpoint locations and other
	locations whose target address isn't meaningful.  Update comment
	explaining the hazard of moribund locations.
@
text
@d8217 1
d8221 1
a8221 1
      int found_object;
d8229 1
a8229 1
	     && bp_location_compare (*locp, old_loc) < 0)
d8231 12
a8242 1
      found_object = locp < bp_location + bp_location_count && *locp == old_loc;
a8267 2
		  struct bp_location **loc2p;

d8269 2
a8270 5
		       loc2p < bp_location + bp_location_count
		       && breakpoint_address_match ((*loc2p)->pspace->aspace,
						    (*loc2p)->address,
						    old_loc->pspace->aspace,
						    old_loc->address);
d8275 15
a8289 9
		      /* For the sake of should_be_inserted.
			 Duplicates check below will fix up this later.  */
		      loc2->duplicate = 0;
		      if (loc2 != old_loc && should_be_inserted (loc2))
			{		  
			  loc2->inserted = 1;
			  loc2->target_info = old_loc->target_info;
			  keep_in_target = 1;
			  break;
@


1.427
log
@	* breakpoint.c (breakpoint_address_bits): Visit all locations'
	gdbarchs, not the breakpoint's gdbarch.
@
text
@d8303 3
a8305 1
	  if (removed && non_stop)
d8307 45
a8351 12
	      /* This location was removed from the targets.  In non-stop mode,
		 a race condition is possible where we've removed a breakpoint,
		 but stop events for that breakpoint are already queued and will
		 arrive later.  To suppress spurious SIGTRAPs reported to user,
		 we keep this breakpoint location for a bit, and will retire it
		 after we see 3 * thread_count events.
		 The theory here is that reporting of events should,
		 "on the average", be fair, so after that many event we'll see
		 events from all threads that have anything of interest, and no
		 longer need to keep this breakpoint.  This is just a
		 heuristic, but if it's wrong, we'll report unexpected SIGTRAP,
		 which is usability issue, but not a correctness problem.  */
@


1.426
log
@	* infrun.c (handle_inferior_event): When handling a fork or vfork
	event, check if the bpstat causes a stop, instead of if it
	explains the signal.
	* breakpoint.c (bpstat_causes_stop): New.
	* breakpoint.h (bpstat_causes_stop): Declare.
@
text
@d4271 1
a4271 1
      int addr_bit = gdbarch_addr_bit (b->gdbarch);
@


1.425
log
@	* breakpoint.c (should_be_inserted): Don't insert breakpoints if
	the pspace doesn't allow breakpoints.
	(insert_breakpoint_locations): Remove waiting_for_vfork_done
	special case.  Expect watchpoints that shouldn't be inserted, to
	not be inserted.
	* progspace.h (struct program_space) <breakpoints_not_allowed>:
	New field.
	* infrun.c (handle_inferior_event): Clear it.
	* linux-nat.c (linux_child_follow_fork): Set it.
@
text
@d3819 10
@


1.424
log
@2009-11-13  Maciej W. Rozycki  <macro@@codesourcery.com>

	* breakpoint.c (update_watchpoint): Only fiddle with frames for
	local watchpoints.
@
text
@d1196 11
a1543 19
      if (!ptid_equal (inferior_ptid, null_ptid))
	{
	  struct inferior *inf = current_inferior ();
	  if (inf->waiting_for_vfork_done)
	    {
	      /* This is set when we're attached to the parent of the
		 vfork, and have detached from the child.  The child
		 is running free, and we expect it to do an exec or
		 exit, at which point the OS makes the parent
		 schedulable again (and the target reports that the
		 vfork is done).  Until the child is done with the
		 shared memory region, do not insert breakpoints in
		 parent, otherwise the child could still trip on the
		 parent's breakpoints.  Since the parent is blocked
		 anyway, it won't miss any breakpoint.  */
	      continue;
	    }
	}

d1568 1
a1568 1
	if (!loc->inserted)
@


1.423
log
@2009-10-31  Michael Snyder  <msnyder@@vmware.com>

	* breakpoint.c (bpstat_stop_status): Fix broken comment.
@
text
@d1003 1
d1015 1
a1015 6
  /* Save the current frame's ID so we can restore it after
     evaluating the watchpoint expression on its own frame.  */
  /* FIXME drow/2003-09-09: It would be nice if evaluate_expression
     took a frame parameter, so that we didn't have to change the
     selected frame.  */
  saved_frame_id = get_frame_id (get_selected_frame (NULL));
d1023 9
d1177 2
a1178 1
  select_frame (frame_find_by_id (saved_frame_id));
@


1.422
log
@gdb/ChangeLog:

2009-31-10  Sergio Durigan Junior <sergiodj@@linux.vnet.ibm.com>

	* breakpoint.c (catch_syscall_split_args): Remove unecessary warning
	displayed when the user provided a syscall name and there is no
	XML support.
	* xml-syscall.c: Renamed `_sysinfo' to `sysinfo'.
	(set_xml_syscall_file_name): Remove syscall_warn_user.
	(xml_init_syscalls_info): Remove warning.
	(init_sysinfo): Update warnings.

gdb/testsuite/ChangeLog:

2009-31-10  Sergio Durigan Junior <sergiodj@@linux.vnet.ibm.com>

	* gdb.base/catch-syscall.exp: Adapt the testcase in order to accept
	the modified warnings for catch syscall.  Verify if GDB was compiled
	with support for lib expat, and choose which tests to run depending
	on this.
@
text
@d3460 1
a3460 2
       alrea
     */
@


1.421
log
@gdb/
	Performance optimize large bp_location count.
	* breakpoint.c (ALL_BP_LOCATIONS_SAFE): Remove.
	(ALL_BP_LOCATIONS): New parameter BP_TMP.  Use now bp_location and
	bp_location_count.
	(bp_location_chain): Remove variable.
	(bp_location, bp_location_count)
	(bp_location_placed_address_before_address_max)
	(bp_location_shadow_len_after_address_max): New variables.
	(moribund_locations, update_watchpoint): Update the bp_location
	variable name.
	(breakpoint_restore_shadows): Extend the comment.  Move the variable
	b to local blocks.  Move the variables bp_addr, bp_size and bptoffset
	to a local block.  New variables bc_l, bc_r and bc.  New binary search
	for the left range boundary.  New break on reaching the right range
	boundary.  Move shadow existence conditionals to ...
	(bp_location_has_shadow): ... a new function.
	(insert_breakpoint_locations): Replace the temp variable by bp_tmp.
	Use now ALL_BP_LOCATIONS instead of ALL_BP_LOCATIONS_SAFE.
	(remove_breakpoints, remove_hw_watchpoints, reattach_breakpoints)
	(detach_breakpoints): New variable bp_tmp.  Update the ALL_BP_LOCATIONS
	calling convention.
	(update_breakpoints_after_exec): New variable bplocp_tmp.  Update the
	ALL_BP_LOCATIONS calling convention.
	(breakpoint_here_p, software_breakpoint_inserted_here_p)
	(breakpoint_thread_match): New variable bptp_tmp.  Drop the const
	attribute of bpt.  Update the ALL_BP_LOCATIONS calling convention.
	(regular_breakpoint_inserted_here_p): Likewise.  Update the bp_location
	variable name.
	(mark_breakpoints_out, breakpoint_init_inferior): New variable
	bptp_tmp.  Update the ALL_BP_LOCATIONS calling convention.
	(bpstat_stop_status): New variables blp_tmp and update_locations.  Drop
	the const attribute of bl.  Update the ALL_BP_LOCATIONS calling
	convention.  Protect HIT_COUNT increment by an ENABLE_STATE check.
	Delay the update_global_location_list call using update_locations.
	(set_default_breakpoint): Drop the check_duplicates name from comment.
	(disable_breakpoints_in_shlibs, disable_breakpoints_in_unloaded_shlib):
	New variable locp_tmp.  Update the ALL_BP_LOCATIONS calling convention.
	(bp_location_compare, bp_location_compare_for_qsort)
	(bp_location_target_extensions_update): New functions.
	(check_duplicates, check_duplicates_for): Remove, moving their code ...
	(update_global_location_list): ... into this existing function.  Remove
	variables next, loc2, old_locations, ret and ix.  New variables locp,
	loc_first, old_location, old_locp and old_location_count.  Stop using
	global_next, create now the array bp_location, sort it by
	bp_location_compare_for_qsort and call
	bp_location_target_extensions_update.  Change quadratic iteration by
	loc2 into an in-sync scanning by locp and loc2p.  Rename former loc
	usage as old_loc.
	(do_vec_free): Remove.
	(breakpoint_program_space_exit): Update the ALL_BP_LOCATIONS calling
	convention.
	(remove_breakpoints_pid): New variable b_tmp.  Update the
	ALL_BP_LOCATIONS calling convention.
	* breakpoint.h (struct bp_location <global_next>): Remove.
@
text
@d7807 1
a7807 11
	{
	  get_syscall_by_number (syscall_number, &s);

	  if (s.name == NULL)
	    /* We can issue just a warning, but still create the catchpoint.
	       This is because, even not knowing the syscall name that
	       this number represents, we can still try to catch the syscall
	       number.  */
	    warning (_("The number '%d' does not represent a known syscall."),
		     syscall_number);
	}
@


1.420
log
@2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	Add base multi-executable/process support to GDB.

	gdb/
	* Makefile.in (SFILES): Add progspace.c.
	(COMMON_OBS): Add progspace.o.
	* progspace.h: New.
	* progspace.c: New.

	* breakpoint.h (struct bp_target_info) <placed_address_space>: New
	field.
	(struct bp_location) <pspace>: New field.
	(struct breakpoint) <pspace>: New field.
	(bpstat_stop_status, breakpoint_here_p)
	(moribund_breakpoint_here_p, breakpoint_inserted_here_p)
	(regular_breakpoint_inserted_here_p)
	(software_breakpoint_inserted_here_p, breakpoint_thread_match)
	(set_default_breakpoint): Adjust prototypes.
	(remove_breakpoints_pid, breakpoint_program_space_exit): Declare.
	(insert_single_step_breakpoint, deprecated_insert_raw_breakpoint):
	Adjust prototypes.
	* breakpoint.c (executing_startup): Delete.
	(default_breakpoint_sspace): New.
	(breakpoint_restore_shadows): Skip if the address space doesn't
	match.
	(update_watchpoint): Record the frame's program space in the
	breakpoint location.
	(insert_bp_location): Record the address space in target_info.
	Adjust to pass the symbol space to solib_name_from_address.
	(breakpoint_program_space_exit): New.
	(insert_breakpoint_locations): Switch the symbol space and thread
	when inserting breakpoints.  Don't insert breakpoints in a vfork
	parent waiting for vfork done if we're not attached to the vfork
	child.
	(remove_breakpoints_pid): New.
	(reattach_breakpoints): Switch to a thread of PID.  Ignore
	breakpoints of other symbol spaces.
	(create_internal_breakpoint): Store the symbol space in the sal.
	(create_longjmp_master_breakpoint): Iterate over all symbol
	spaces.
	(update_breakpoints_after_exec): Ignore breakpoints for other
	symbol spaces.
	(remove_breakpoint): Rename to ...
	(remove_breakpoint_1): ... this.  Pass the breakpoints symbol
	space to solib_name_from_address.
	(remove_breakpoint): New.
	(mark_breakpoints_out): Ignore breakpoints from other symbol
	spaces.
	(breakpoint_init_inferior): Ditto.
	(breakpoint_here_p): Add an address space argument and adjust to
	use breakpoint_address_match.
	(moribund_breakpoint_here_p): Ditto.
	(regular_breakpoint_inserted_here_p): Ditto.
	(breakpoint_inserted_here_p): Ditto.
	(software_breakpoint_inserted_here_p): Ditto.
	(breakpoint_thread_match): Ditto.
	(bpstat_check_location): Ditto.
	(bpstat_stop_status): Ditto.
	(print_breakpoint_location): If there's a location to print,
	switch the current symbol space.
	(print_one_breakpoint_location): Add `allflag' argument.
	(print_one_breakpoint): Ditto.	Adjust.
	(do_captured_breakpoint_query): Adjust.
	(breakpoint_1): Adjust.
	(breakpoint_has_pc): Also match the symbol space.
	(describe_other_breakpoints): Add a symbol space argument and
	adjust.
	(set_default_breakpoint): Add a symbol space argument.	Set
	default_breakpoint_sspace.
	(breakpoint_address_match): New.
	(check_duplicates_for): Add an address space argument, and adjust.
	(set_raw_breakpoint): Record the symbol space in the location and
	in the breakpoint.
	(set_longjmp_breakpoint): Skip longjmp master breakpoints from
	other symbol spaces.
	(remove_thread_event_breakpoints, remove_solib_event_breakpoints)
	(disable_breakpoints_in_shlibs): Skip breakpoints from other
	symbol spaces.
	(disable_breakpoints_in_unloaded_shlib): Match symbol spaces.
	(create_catchpoint): Set the symbol space in the sal.
	(disable_breakpoints_before_startup): Skip breakpoints from other
	symbol spaces.	Set executing_startup in the current symbol space.
	(enable_breakpoints_after_startup): Clear executing_startup in the
	current symbol space.  Skip breakpoints from other symbol spaces.
	(clone_momentary_breakpoint): Also copy the symbol space.
	(add_location_to_breakpoint): Set the location's symbol space.
	(bp_loc_is_permanent): Switch thread and symbol space.
	(create_breakpoint): Adjust.
	(expand_line_sal_maybe): Expand comment to mention symbol spaces.
	Switch thread and symbol space when reading memory.
	(parse_breakpoint_sals): Set the symbol space in the sal.
	(break_command_really): Ditto.
	(skip_prologue_sal): Switch and space.
	(resolve_sal_pc): Ditto.
	(watch_command_1): Record the symbol space in the sal.
	(create_ada_exception_breakpoint): Adjust.
	(clear_command): Adjust.  Match symbol spaces.
	(update_global_location_list): Use breakpoint_address_match.
	(breakpoint_re_set_one): Switch thread and space.
	(breakpoint_re_set): Save symbol space.
	(breakpoint_re_set_thread): Also reset the symbol space.
	(deprecated_insert_raw_breakpoint): Add an address space argument.
	Adjust.
	(insert_single_step_breakpoint): Ditto.
	(single_step_breakpoint_inserted_here_p): Ditto.
	(clear_syscall_counts): New.
	(_initialize_breakpoint): Install it as inferior_exit observer.

	* exec.h: Include "progspace.h".
	(exec_bfd, exec_bfd_mtime): New defines.
	(exec_close): Declare.
	* exec.c: Include "gdbthread.h" and "progspace.h".
	(exec_bfd, exec_bfd_mtime, current_target_sections_1): Delete.
	(using_exec_ops): New.
	(exec_close_1): Rename to exec_close, and make public.
	(exec_close): Rename to exec_close_1, and adjust all callers.  Add
	description.  Remove target sections and close executables from
	all program spaces.
	(exec_file_attach): Add comment.
	(add_target_sections): Check on `using_exec_ops' to check if the
	target should be pushed.
	(remove_target_sections): Only unpush the target if there are no
	more target sections in any symbol space.
	* gdbcore.h: Include "exec.h".
	(exec_bfd, exec_bfd_mtime): Remove declarations.

	* frame.h (get_frame_program_space, get_frame_address_space)
	(frame_unwind_program_space): Declare.
	* frame.c (struct frame_info) <pspace, aspace>: New fields.
	(create_sentinel_frame): Add program space argument.  Set the
	pspace and aspace fields of the frame object.
	(get_current_frame, create_new_frame): Adjust.
	(get_frame_program_space): New.
	(frame_unwind_program_space): New.
	(get_frame_address_space): New.
	* stack.c (print_frame_info): Adjust.
	(print_frame): Use the frame's program space.

	* gdbthread.h (any_live_thread_of_process): Declare.
	* thread.c (any_live_thread_of_process): New.
	(switch_to_thread): Switch the program space as well.
	(restore_selected_frame): Don't warn if trying to restore frame
	level 0.

	* inferior.h: Include "progspace.h".
	(detach_fork): Declare.
	(struct inferior) <removable, aspace, pspace>
	<vfork_parent, vfork_child, pending_detach>
	<waiting_for_vfork_done>: New fields.
	<terminal_info>: Remove field.
	<data, num_data>: New fields.
	(register_inferior_data, register_inferior_data_with_cleanup)
	(clear_inferior_data, set_inferior_data, inferior_data): Declare.
	(exit_inferior, exit_inferior_silent, exit_inferior_num_silent)
	(inferior_appeared): Declare.
	(find_inferior_pid): Typo.
	(find_inferior_id, find_inferior_for_program_space): Declare.
	(set_current_inferior, save_current_inferior, prune_inferiors)
	(number_of_inferiors): Declare.
	(inferior_list): Declare.
	* inferior.c: Include "gdbcore.h" and "symfile.h".
	(inferior_list): Make public.
	(delete_inferior_1): Always delete thread silently.
	(find_inferior_id): Make public.
	(current_inferior_): New.
	(current_inferior): Use it.
	(set_current_inferior): New.
	(restore_inferior): New.
	(save_current_inferior): New.
	(free_inferior): Free the per-inferior data.
	(add_inferior_silent): Allocate per-inferior data.
	Call inferior_appeared.
	(delete_threads_of_inferior): New.
	(delete_inferior_1): Adjust interface to take an inferior pointer.
	(delete_inferior): Adjust.
	(delete_inferior_silent): Adjust.
	(exit_inferior_1): New.
	(exit_inferior): New.
	(exit_inferior_silent): New.
	(exit_inferior_num_silent): New.
	(detach_inferior): Adjust.
	(inferior_appeared): New.
	(discard_all_inferiors): Adjust.
	(find_inferior_id): Make public.  Assert pid is not zero.
	(find_inferior_for_program_space): New.
	(have_inferiors): Check if we have any inferior with pid not zero.
	(have_live_inferiors): Go over all pushed targets looking for
	process_stratum.
	(prune_inferiors): New.
	(number_of_inferiors): New.
	(print_inferior): Add executable column.  Print vfork parent/child
	relationships.
	(inferior_command): Adjust to cope with not running inferiors.
	(remove_inferior_command): New.
	(add_inferior_command): New.
	(clone_inferior_command): New.
	(struct inferior_data): New.
	(struct inferior_data_registration): New.
	(struct inferior_data_registry): New.
	(inferior_data_registry): New.
	(register_inferior_data_with_cleanup): New.
	(register_inferior_data): New.
	(inferior_alloc_data): New.
	(inferior_free_data): New.
	(clear_inferior_data): New.
	(set_inferior_data): New.
	(inferior_data): New.
	(initialize_inferiors): New.
	(_initialize_inferiors): Register "add-inferior",
	"remove-inferior" and "clone-inferior" commands.

	* objfiles.h: Include "progspace.h".
	(struct objfile) <pspace>: New field.
	(symfile_objfile, object_files): Don't declare.
	(ALL_PSPACE_OBJFILES): New.
	(ALL_PSPACE_OBJFILES_SAFE): New.
	(ALL_OBJFILES, ALL_OBJFILES_SAFE): Adjust.
	(ALL_PSPACE_SYMTABS): New.
	(ALL_PRIMARY_SYMTABS): Adjust.
	(ALL_PSPACE_PRIMARY_SYMTABS): New.
	(ALL_PSYMTABS): Adjust.
	(ALL_PSPACE_PSYMTABS): New.
	* objfiles.c (object_files, symfile_objfile): Delete.
	(struct objfile_sspace_info): New.
	(objfiles_pspace_data): New.
	(objfiles_pspace_data_cleanup): New.
	(get_objfile_pspace_data): New.
	(objfiles_changed_p): Delete.
	(allocate_objfile): Set the objfile's program space.  Adjust to
	reference objfiles_changed_p in pspace data.
	(free_objfile): Adjust to reference objfiles_changed_p in pspace
	data.
	(objfile_relocate): Ditto.
	(update_section_map): Add pspace argument.  Adjust to iterate over
	objfiles in the passed in pspace.
	(find_pc_section): Delete sections and num_sections statics.
	Adjust to refer to program space's objfiles_changed_p.	Adjust to
	refer to sections and num_sections store in the objfile's pspace
	data.
	(objfiles_changed): Adjust to reference objfiles_changed_p in
	pspace data.
	(_initialize_objfiles): New.
	* linespec.c (decode_all_digits, decode_dollar): Set the sal's
	program space.
	* source.c (current_source_pspace): New.
	(get_current_source_symtab_and_line): Set the sal's program space.
	(set_current_source_symtab_and_line): Set current_source_pspace.
	(select_source_symtab): Ditto.	Use ALL_OBJFILES.
	(forget_cached_source_info): Iterate over all program spaces.
	* symfile.c (clear_symtab_users): Adjust.
	* symmisc.c (print_symbol_bcache_statistics): Iterate over all
	program spaces.
	(print_objfile_statistics): Ditto.
	(maintenance_print_msymbols): Ditto.
	(maintenance_print_objfiles): Ditto.
	(maintenance_info_symtabs): Ditto.
	(maintenance_info_psymtabs): Ditto.
	* symtab.h (SYMTAB_PSPACE): New.
	(struct symtab_and_line) <pspace>: New field.
	* symtab.c (init_sal): Clear the sal's program space.
	(find_pc_sect_symtab): Set the sal's program space.  Switch thread
	and space.
	(append_expanded_sal): Add program space argument.  Iterate over
	all program spaces.
	(expand_line_sal): Iterate over all program spaces.  Switch
	program space.

	* target.h (enum target_waitkind) <TARGET_WAITKIND_VFORK_DONE>: New.
	(struct target_ops) <to_thread_address_space>: New field.
	(target_thread_address_space): Define.
	* target.c (target_detach): Only remove breakpoints from the
	inferior we're detaching.
	(target_thread_address_space): New.

	* defs.h (initialize_progspace): Declare.
	* top.c (gdb_init): Call it.

	* solist.h (struct so_list) <sspace>: New field.
	* solib.h (struct program_space): Forward declare.
	(solib_name_from_address): Adjust prototype.
	* solib.c (so_list_head): Replace with a macro referencing the
	program space.
	(update_solib_list): Set the so's program space.
	(solib_name_from_address): Add a program space argument and adjust.

	* solib-svr4.c (struct svr4_info) <pid>: Delete field.
	<interp_text_sect_low, interp_text_sect_high, interp_plt_sect_low>
	<interp_plt_sect_high>: New fields.
	(svr4_info_p, svr4_info): Delete.
	(solib_svr4_sspace_data): New.
	(get_svr4_info): Rewrite.
	(svr4_sspace_data_cleanup): New.
	(open_symbol_file_object): Adjust.
	(svr4_default_sos): Adjust.
	(svr4_fetch_objfile_link_map): Adjust.
	(interp_text_sect_low, interp_text_sect_high, interp_plt_sect_low)
	(interp_plt_sect_high): Delete.
	(svr4_in_dynsym_resolve_code): Adjust.
	(enable_break): Adjust.
	(svr4_clear_solib): Revert bit that removed the svr4_info here,
	and reinstate clearing debug_base, debug_loader_offset_p,
	debug_loader_offset and debug_loader_name.
	(_initialize_svr4_solib): Register solib_svr4_pspace_data.  Don't
	install an inferior_exit observer anymore.

	* printcmd.c (struct display) <pspace>: New field.
	(display_command): Set the display's sspace.
	(do_one_display): Match the display's sspace.
	(display_uses_solib_p): Ditto.

	* linux-fork.c (detach_fork): Moved to infrun.c.
	(_initialize_linux_fork): Moved "detach-on-fork" command to
	infrun.c.
	* infrun.c (detach_fork): Moved from linux-fork.c.
	(proceed_after_vfork_done): New.
	(handle_vfork_child_exec_or_exit): New.
	(follow_exec_mode_replace, follow_exec_mode_keep)
	(follow_exec_mode_names, follow_exec_mode_string)
	(show_follow_exec_mode_string): New.
	(follow_exec): New.  Reinstate the mark_breakpoints_out call.
	Remove shared libraries before attaching new executable.  If user
	wants to keep the inferior, keep it.
	(displaced_step_fixup): Adjust to pass an address space to the
	breakpoints module.
	(resume): Ditto.
	(clear_proceed_status): In all-stop mode, always clear the proceed
	status of all threads.
	(prepare_to_proceed): Adjust to pass an address space to the
	breakpoints module.
	(proceed): Ditto.
	(adjust_pc_after_break): Ditto.
	(handle_inferior_event): When handling a process exit, switch the
	program space to the inferior's that had exited.  Call
	handle_vfork_child_exec_or_exit.  Adjust to pass an address space
	to the breakpoints module.  In non-stop mode, when following a
	fork and detach-fork is off, also resume the other branch.  Handle
	TARGET_WAITKIND_VFORK_DONE.  Set the program space in sals.
	(normal_stop): Prune inferiors.
	(_initialize_infrun): Install the new "follow-exec-mode" command.
	"detach-on-fork" moved here.

	* regcache.h (get_regcache_aspace): Declare.
	* regcache.c (struct regcache) <aspace>: New field.
	(regcache_xmalloc): Clear the aspace.
	(get_regcache_aspace): New.
	(regcache_cpy): Copy the aspace field.
	(regcache_cpy_no_passthrough): Ditto.
	(get_thread_regcache): Fetch the thread's address space from the
	target, and store it in the regcache.

	* infcall.c (call_function_by_hand): Set the sal's pspace.

	* arch-utils.c (default_has_shared_address_space): New.
	* arch-utils.h (default_has_shared_address_space): Declare.

	* gdbarch.sh (has_shared_address_space): New.
	* gdbarch.h, gdbarch.c: Regenerate.

	* linux-tdep.c: Include auxv.h, target.h, elf/common.h.
	(linux_has_shared_address_space): New.
	(_initialize_linux_tdep): Declare.

	* arm-tdep.c (arm_software_single_step): Pass the frame's address
	space to insert_single_step_breakpoint.
	* arm-linux-tdep.c (arm_linux_software_single_step): Pass the
	frame's pspace to breakpoint functions.
	* cris-tdep.c (crisv32_single_step_through_delay): Ditto.
	(cris_software_single_step): Ditto.
	* mips-tdep.c (deal_with_atomic_sequence): Add frame argument.
	Pass the frame's pspace to breakpoint functions.
	(mips_software_single_step): Adjust.
	(mips_single_step_through_delay): Adjust.
	* rs6000-aix-tdep.c (rs6000_software_single_step): Adjust.
	* rs6000-tdep.c (ppc_deal_with_atomic_sequence): Adjust.
	* solib-irix.c (enable_break): Adjust to pass the current frame's
	address space to breakpoint functions.
	* sparc-tdep.c (sparc_software_single_step): Ditto.
	* spu-tdep.c (spu_software_single_step): Ditto.
	* alpha-tdep.c (alpha_software_single_step): Ditto.
	* record.c (record_wait): Adjust to pass an address space to the
	breakpoints module.

	* fork-child.c (fork_inferior): Set the new inferior's program and
	address spaces.
	* inf-ptrace.c (inf_ptrace_follow_fork): Copy the parent's program
	and address spaces.
	(inf_ptrace_attach): Set the inferior's program and address spaces.
	* linux-nat.c: Include "solib.h".
	(linux_child_follow_fork): Manage parent and child's program and
	address spaces.	 Clone the parent's program space if necessary.
	Don't wait for the vfork to be done here.  Refuse to resume if
	following the vfork parent while leaving the child stopped.
	(resume_callback): Don't resume a vfork parent.
	(linux_nat_resume): Also check for pending events in the
	lp->waitstatus field.
	(linux_handle_extended_wait): Report TARGET_WAITKIND_VFORK_DONE
	events to the core.
	(stop_wait_callback): Don't wait for SIGSTOP on vfork parents.
	(cancel_breakpoint): Adjust.
	* linux-thread-db.c (thread_db_wait): Don't remove thread event
	breakpoints here.
	(thread_db_mourn_inferior): Don't mark breakpoints out here.
	Remove thread event breakpoints after mourning.
	* corelow.c: Include progspace.h.
	(core_open): Set the inferior's program and address spaces.
	* remote.c (remote_add_inferior): Set the new inferior's program
	and address spaces.
	(remote_start_remote): Update address spaces.
	(extended_remote_create_inferior_1): Don't init the thread list if
	we already debugging other inferiors.
	* darwin-nat.c (darwin_attach): Set the new inferior's program and
	address spaces.
	* gnu-nat.c (gnu_attach): Ditto.
	* go32-nat.c (go32_create_inferior): Ditto.
	* inf-ttrace.c (inf_ttrace_follow_fork, inf_ttrace_attach): Ditto.
	* monitor.c (monitor_open): Ditto.
	* nto-procfs.c (procfs_attach, procfs_create_inferior): Ditto.
	* procfs.c (do_attach): Ditto.
	* windows-nat.c (do_initial_windows_stuff): Ditto.

	* inflow.c (inferior_process_group)
	(terminal_init_inferior_with_pgrp, terminal_inferior,
	(terminal_ours_1, inflow_inferior_exit, copy_terminal_info)
	(child_terminal_info, new_tty_postfork, set_sigint_trap): Adjust
	to use per-inferior data instead of inferior->terminal_info.
	(inflow_inferior_data): New.
	(inflow_new_inferior): Delete.
	(inflow_inferior_data_cleanup): New.
	(get_inflow_inferior_data): New.

	* mi/mi-interp.c (mi_new_inferior): Rename to...
	(mi_inferior_appeared): ... this.
	(mi_interpreter_init): Adjust.

	* tui/tui-disasm.c: Include "progspace.h".
	(tui_set_disassem_content): Pass an address space to
	breakpoint_here_p.

	* NEWS: Mention multi-program debugging support.  Mention new
	commands "add-inferior", "clone-inferior", "remove-inferior",
	"maint info program-spaces", and new option "set
	follow-exec-mode".

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/doc/
	* observer.texi (new_inferior): Rename to...
	(inferior_appeared): ... this.

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/testsuite/
	* gdb.base/foll-vfork.exp: Adjust to spell out "follow-fork".
	* gdb.base/foll-exec.exp: Adjust to expect a process id before
	"Executing new program".
	* gdb.base/foll-fork.exp: Adjust to spell out "follow-fork".
	* gdb.base/multi-forks.exp: Ditto.  Adjust to the inferior being
	left listed after having been killed.
	* gdb.base/attach.exp: Adjust to spell out "symbol-file".
	* gdb.base/maint.exp: Adjust test.

	* Makefile.in (ALL_SUBDIRS): Add gdb.multi.
	* gdb.multi/Makefile.in: New.
	* gdb.multi/base.exp: New.
	* gdb.multi/goodbye.c: New.
	* gdb.multi/hangout.c: New.
	* gdb.multi/hello.c: New.
	* gdb.multi/bkpt-multi-exec.c: New.
	* gdb.multi/bkpt-multi-exec.exp: New.
	* gdb.multi/crashme.c: New.

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/doc/
	* gdb.texinfo (Inferiors): Rename node to ...
	(Inferiors and Programs): ... this.  Mention running multiple
	programs in the same debug session.
	<info inferiors>: Mention the new 'Executable' column if "info
	inferiors".  Update examples.  Document the "add-inferior",
	"clone-inferior", "remove-inferior" and "maint info
	program-spaces" commands.
	(Process): Rename node to...
	(Forks): ... this.  Document "set|show follow-exec-mode".
@
text
@a114 2
static void check_duplicates (struct breakpoint *);

d343 8
a350 8
/* Similar iterators for the low-level breakpoints.  */

#define ALL_BP_LOCATIONS(B)  for (B = bp_location_chain; B; B = B->global_next)

#define ALL_BP_LOCATIONS_SAFE(B,TMP)	\
	for (B = bp_location_chain;	\
	     B ? (TMP=B->global_next, 1): 0;	\
	     B = TMP)
d362 22
a383 1
struct bp_location *bp_location_chain;
d386 1
a386 1
   unlinked from bp_location_chain, but for which a hit
d764 16
a779 1

d781 11
a791 1
   by replacing any memory breakpoints with their shadowed contents.  */
d796 14
a809 4
  struct bp_location *b;
  CORE_ADDR bp_addr = 0;
  int bp_size = 0;
  int bptoffset = 0;
d811 18
a828 1
  ALL_BP_LOCATIONS (b)
d830 5
d839 9
a847 3
    if (b->loc_type != bp_loc_software_breakpoint)
      continue;
    if (!b->inserted)
a856 3
    if (bp_size == 0)
      /* bp isn't valid, or doesn't shadow memory.  */
      continue;
d1006 1
a1006 1
  /* We don't free locations.  They are stored in bp_location_chain and
d1423 1
a1423 1
  struct bp_location *loc, *loc_temp;
d1434 1
a1434 1
  ALL_BP_LOCATIONS_SAFE (loc, loc_temp)
d1488 1
a1488 1
  struct bp_location *b, *temp;
d1503 1
a1503 1
  ALL_BP_LOCATIONS_SAFE (b, temp)
d1609 1
a1609 1
  struct bp_location *b;
d1612 1
a1612 1
  ALL_BP_LOCATIONS (b)
d1625 1
a1625 1
  struct bp_location *b;
d1629 1
a1629 1
  ALL_BP_LOCATIONS (b)
d1647 1
a1647 1
  struct bp_location *b;
d1650 1
a1650 1
  ALL_BP_LOCATIONS (b)
d1662 1
a1662 1
  struct bp_location *b;
d1680 1
a1680 1
  ALL_BP_LOCATIONS (b)
d1796 1
a1796 1
  struct bp_location *bploc;
d1806 1
a1806 1
  ALL_BP_LOCATIONS (bploc)
d1913 1
a1913 1
  struct bp_location *b;
d1923 1
a1923 1
  ALL_BP_LOCATIONS (b)
d2088 1
a2088 1
  struct bp_location *bpt;
d2090 1
a2090 1
  ALL_BP_LOCATIONS (bpt)
d2111 1
a2111 1
  struct bp_location *bpt;
d2120 1
a2120 1
  ALL_BP_LOCATIONS (bpt)
d2192 1
a2192 1
  const struct bp_location *bpt;
d2195 1
a2195 1
  ALL_BP_LOCATIONS (bpt)
d2237 1
a2237 1
   inserted using regular breakpoint_chain/bp_location_chain mechanism.
d2244 1
a2244 1
  const struct bp_location *bpt;
d2246 1
a2246 1
  ALL_BP_LOCATIONS (bpt)
d2288 1
a2288 1
  const struct bp_location *bpt;
d2291 1
a2291 1
  ALL_BP_LOCATIONS (bpt)
d2323 1
a2323 1
  const struct bp_location *bpt;
d2328 1
a2328 1
  ALL_BP_LOCATIONS (bpt)
d3440 1
a3440 1
  const struct bp_location *bl;
d3447 1
a3447 1
  int need_remove_insert;
d3449 1
a3449 1
  ALL_BP_LOCATIONS (bl)
d3491 2
a3492 1
	++(b->hit_count);
d3499 1
a3499 1
	    update_global_location_list (0);
d3519 4
d4533 2
a4534 3
   have a zero valued address and we don't want check_duplicates() to mark
   breakpoints of any of these types to be a duplicate of an actual
   breakpoint at address zero:
a4567 86
/* Rescan breakpoints at the same address and section as BPT,
   marking the first one as "first" and any others as "duplicates".
   This is so that the bpt instruction is only inserted once.
   If we have a permanent breakpoint at the same place as BPT, make
   that one the official one, and the rest as duplicates.  */

static void
check_duplicates_for (struct address_space *aspace,
		      CORE_ADDR address,
		      struct obj_section *section)
{
  struct bp_location *b;
  int count = 0;
  struct bp_location *perm_bp = 0;

  ALL_BP_LOCATIONS (b)
    if (b->owner->enable_state != bp_disabled
	&& b->owner->enable_state != bp_call_disabled
	&& b->owner->enable_state != bp_startup_disabled
	&& b->enabled
	&& !b->shlib_disabled
	&& (!overlay_debugging || b->section == section)
	&& breakpoint_address_is_meaningful (b->owner)
	&& breakpoint_address_match (b->pspace->aspace, b->address,
				     aspace, address))
    {
      /* Have we found a permanent breakpoint?  */
      if (b->owner->enable_state == bp_permanent)
	{
	  perm_bp = b;
	  break;
	}
	
      count++;
      b->duplicate = count > 1;
    }

  /* If we found a permanent breakpoint at this address, go over the
     list again and declare all the other breakpoints there (except
     other permanent breakpoints) to be the duplicates.  */
  if (perm_bp)
    {
      perm_bp->duplicate = 0;

      /* Permanent breakpoint should always be inserted.  */
      if (! perm_bp->inserted)
	internal_error (__FILE__, __LINE__,
			_("allegedly permanent breakpoint is not "
			"actually inserted"));

      ALL_BP_LOCATIONS (b)
	if (b != perm_bp)
	  {
	    if (b->owner->enable_state != bp_permanent
		&& b->owner->enable_state != bp_disabled
		&& b->owner->enable_state != bp_call_disabled
		&& b->owner->enable_state != bp_startup_disabled
		&& b->enabled && !b->shlib_disabled
		&& breakpoint_address_is_meaningful (b->owner)
		&& breakpoint_address_match (b->pspace->aspace, b->address,
					     aspace, address)
		&& (!overlay_debugging || b->section == section))
	      {
		if (b->inserted)
		  internal_error (__FILE__, __LINE__,
				  _("another breakpoint was inserted on top of "
				  "a permanent breakpoint"));

		b->duplicate = 1;
	      }
	  }
    }
}

static void
check_duplicates (struct breakpoint *bpt)
{
  struct bp_location *bl = bpt->loc;

  if (! breakpoint_address_is_meaningful (bpt))
    return;

  for (; bl; bl = bl->next)
    check_duplicates_for (bl->pspace->aspace, bl->address, bl->section);
}

d4988 1
a4988 1
  struct bp_location *loc;
d4990 1
a4990 1
  ALL_BP_LOCATIONS (loc)
d5021 1
a5021 1
  struct bp_location *loc;
d5032 1
a5032 1
  ALL_BP_LOCATIONS (loc)
d8079 43
a8121 1
/* A cleanup function which destroys a vector.  */
d8124 1
a8124 1
do_vec_free (void *p)
d8126 27
a8152 3
  VEC(bp_location_p) **vec = p;
  if (*vec)
    VEC_free (bp_location_p, *vec);
d8174 1
a8174 6
  struct bp_location **next = &bp_location_chain;
  struct bp_location *loc;
  struct bp_location *loc2;
  VEC(bp_location_p) *old_locations = NULL;
  int ret;
  int ix;
d8177 18
a8194 4
  cleanups = make_cleanup (do_vec_free, &old_locations);
  /* Store old locations for future reference.  */
  for (loc = bp_location_chain; loc; loc = loc->global_next)
    VEC_safe_push (bp_location_p, old_locations, loc);
d8196 2
a8197 1
  bp_location_chain = NULL;
d8199 6
a8204 8
    {
      for (loc = b->loc; loc; loc = loc->next)
	{
	  *next = loc;
	  next = &(loc->global_next);
	  *next = NULL;
	}
    }
d8210 8
a8217 2
     we don't need to remove/insert the location.  */
  for (ix = 0; VEC_iterate(bp_location_p, old_locations, ix, loc); ++ix)
d8219 3
a8221 1
      /* Tells if 'loc' is found amoung the new locations.  If not, we
d8223 1
a8223 1
      int found_object = 0;
d8227 7
a8233 6
      for (loc2 = bp_location_chain; loc2; loc2 = loc2->global_next)
	if (loc2 == loc)
	  {
	    found_object = 1;
	    break;
	  }
d8241 1
a8241 1
      if (loc->inserted)
d8245 1
a8245 1
	  if (found_object && should_be_inserted (loc))
d8256 27
a8282 19
	      if (breakpoint_address_is_meaningful (loc->owner))
		for (loc2 = bp_location_chain; loc2; loc2 = loc2->global_next)
		  {
		    /* For the sake of should_insert_location.  The
		       call to check_duplicates will fix up this later.  */
		    loc2->duplicate = 0;
		    if (should_be_inserted (loc2)
			&& loc2 != loc
			&& breakpoint_address_match (loc2->pspace->aspace,
						     loc2->address,
						     loc->pspace->aspace,
						     loc->address))
		      {
			loc2->inserted = 1;
			loc2->target_info = loc->target_info;
			keep_in_target = 1;
			break;
		      }
		  }
d8287 1
a8287 1
	      if (remove_breakpoint (loc, mark_uninserted))
d8294 1
a8294 1
		     Note that at this point, loc->owner is still valid,
d8298 1
a8298 1
				   loc->owner->number);
d8320 2
a8321 2
	      loc->events_till_retirement = 3 * (thread_count () + 1);
	      loc->owner = NULL;
d8323 1
a8323 1
	      VEC_safe_push (bp_location_p, moribund_locations, loc);
d8326 1
a8326 1
	    free_bp_location (loc);
d8330 9
a8338 1
  ALL_BREAKPOINTS (b)
d8340 34
a8373 1
      check_duplicates (b);
@


1.419
log
@Implementing catch syscall.

* amd64-linux-tdep.c: Include xml-syscall.h header, define the XML
syscall name for the architecture.
(amd64_linux_get_syscall_number): New function.
(amd64_linux_init_abi): Register the correct functions for syscall
catchpoint; set the correct syscall file name.
* breakpoint.c: New include: xml-syscall.h.
(set_raw_breakpoint_without_location): Setting the parameters
for the catch syscall feature.
(insert_catch_syscall): New.
(remove_catch_syscall): New.
(breakpoint_hit_catch_syscall): New.
(print_it_catch_syscall): New.
(print_one_catch_syscall): New.
(print_mention_catch_syscall): New.
(catch_syscall_breakpoint_ops): New.
(syscall_catchpoint_p): New.
(create_catchpoint_without_mention): New.
(create_catchpoint): Modified in order to use
create_catchpoint_without_mention.
(create_syscall_event_catchpoint): New.
(clean_up_filters): New.
(catch_syscall_split_args): New.
(catch_syscall_command_1): New.
(delete_breakpoint): Add cleanup for catch syscall.
(is_syscall_catchpoint_enabled): New.
(catch_syscall_enabled): New.
(catching_syscall_number): New.
(catch_syscall_completer): New completer function.
(add_catch_command): Add the completer function for catchpoints.
* breakpoint.h (syscalls_to_be_caught): New vector.
(catch_syscall_enabled): New.
(catching_syscall_number): New.
* gdbarch.c: Regenerated.
* gdbarch.h: Regenerated.
* gdbarch.sh: Add syscall catchpoint functions and structures.
(get_syscall_number): New.
(UNKNOWN_SYSCALL): New definition.
* i386-linux-nat.c (i386_linux_resume): Select the proper request
to be made for ptrace() considering if we are catching syscalls
or not.
* i386-linux-tdep.c: Include xml-syscall.h header, define the XML
syscall name for the architecture.
(i386_linux_get_syscall_number): New.
(i386_linux_init_abi): Register the correct functions for syscall
catchpoint; set the correct syscall file name.
* inf-child.c (inf_child_set_syscall_catchpoint): New.
(inf_child_target): Assign default values to target_ops.
* inf-ptrace.c (inf_ptrace_resume): Select the proper request
to be made for ptrace() considering if we are catching syscalls
or not.
* inferior.h (struct inferior): Included new variables
any_syscall_count, syscalls_counts and total_syscalls_count,
used to keep track of requested syscall catchpoints.
* infrun.c (resume): Add syscall catchpoint.
(deal_with_syscall_event): New.
(handle_inferior_event): Add syscall entry/return events.
(inferior_has_called_syscall): New.
* linux-nat.c: Define some helpful variables to track wether we have
support for the needed ptrace option.
(linux_test_for_tracesysgood): New.
(linux_supports_tracesysgood): New.
(linux_enable_tracesysgood): New.
(linux_enable_event_reporting): Save the current used ptrace
options.
(linux_child_post_attach): Calling linux_enable_tracesysgood.
(linux_child_post_startup_inferior): Likewise.
(linux_child_set_syscall_catchpoint): New function.
(linux_handle_extended_wait): Handle the case which the inferior stops
because it has called or returned from a syscall.
(linux_target_install_ops): Install the necessary functions to handle
syscall catchpoints.
* linux-nat.h (struct lwp_info): Include syscall_state into the
structure, which indicates if we are in a syscall entry or return.
* ppc-linux-tdep.c: Include xml-syscall.h header, define the XML
syscall filename for the arch.
(ppc_linux_get_syscall_number): New.
(ppc_linux_init_abi): Register the correct functions for syscall
catchpoint; setting the correct name for the XML syscall file.
* target.c (update_current_target): Update/copy functions related to
syscall catchpoint.
(target_waitstatus_to_string): Add syscall catchpoint entry/return
events.
* target.h (struct target_waitstatus): Add syscall number.
(struct syscall): New struct to hold information about syscalls
in the system.
(struct target_ops): Add ops for syscall catchpoint.
(inferior_has_called_syscall): New.
(target_set_syscall_catchpoint): New.
* xml-support.c (xml_fetch_content_from_file): New function,
transferred from xml-tdesc.c.
* xml-support.h (xml_fetch_content_from_file): New.
* xml-tdesc.c (fetch_xml_from_file): Function removed;
transferred to xml-support.c.
(file_read_description_xml): Updated to use the new
xml_fetch_content_from_file function.
* syscalls/gdb-syscalls.dtd: New definition file for syscall's XML
support.
* syscalls/amd64-linux.xml: New file containing information about
syscalls for GNU/Linux systems that use amd64 architecture.
* syscalls/i386-linux.xml: New file containing information about
syscalls for GNU/Linux systems that use i386 architecture.
* syscalls/ppc-linux.xml: New file containing information about
syscalls for GNU/Linux systems that use PPC architecture.
* syscalls/ppc64-linux.xml: New file containing information about
syscalls for GNU/Linux systems that use PPC64 architecture.
* xml-syscall.c: New file containing functions for manipulating
syscall's XML files.
* xml-syscall.h: New file, exporting the functions above mentioned.
* Makefile.in: Support for relocatable GDB datadir and XML
syscall.
* NEWS: Added information about the catch syscall feature.
* doc/gdb.texinfo (Set Catchpoints): Documentation about the new
feature.
* testsuite/Makefile.in: Inclusion of catch-syscall object.
* testsuite/gdb.base/catch-syscall.c: New file.
* testsuite/gdb.base/catch-syscall.exp: New file.
@
text
@d123 2
a124 1
static void describe_other_breakpoints (struct gdbarch *, CORE_ADDR,
d127 5
d158 1
d201 2
a202 1
static int single_step_breakpoint_inserted_here_p (CORE_ADDR pc);
a333 3
/* Are we executing startup code?  */
static int executing_startup;

d417 2
d767 4
d925 1
d954 2
d1058 2
d1139 1
d1258 1
a1258 1
	  if (solib_name_from_address (bpt->address))
d1336 42
d1421 3
a1423 1
	
d1426 3
d1438 29
d1541 24
d1582 1
a1584 1
  struct cleanup *old_chain = save_inferior_ptid ();
d1587 11
a1600 1
  inferior_ptid = pid_to_ptid (pid);
d1603 3
d1635 1
d1680 1
d1682 3
d1686 1
d1695 2
d1708 2
d1728 2
a1729 1
    gdb_assert (!bploc->inserted);
d1733 3
d1837 1
d1842 1
a1842 1
  /* Set inferior_ptid; remove_breakpoint uses this global.  */
d1846 3
d1850 1
a1850 1
      val |= remove_breakpoint (b, mark_inserted);
d1856 6
d1863 1
a1863 1
remove_breakpoint (struct bp_location *b, insertion_state_t is)
d1866 1
d1944 1
a1944 1
      if (val && solib_name_from_address (b->address))
d1980 24
d2012 2
a2013 1
    bpt->inserted = 0;
d2034 1
d2042 3
a2044 1
    if (bpt->owner->enable_state != bp_permanent)
d2046 1
d2050 3
d2095 5
d2111 1
a2111 1
breakpoint_here_p (CORE_ADDR pc)
d2124 2
a2125 1
	  && bpt->address == pc)	/* bp is enabled and matches pc */
d2144 1
a2144 1
moribund_breakpoint_here_p (CORE_ADDR pc)
d2150 2
a2151 1
    if (loc->address == pc)
d2163 1
a2163 1
regular_breakpoint_inserted_here_p (CORE_ADDR pc)
d2174 2
a2175 1
	  && bpt->address == pc)	/* bp is inserted and matches pc */
d2192 1
a2192 1
breakpoint_inserted_here_p (CORE_ADDR pc)
d2194 1
a2194 1
  if (regular_breakpoint_inserted_here_p (pc))
d2197 1
a2197 1
  if (single_step_breakpoint_inserted_here_p (pc))
d2207 1
a2207 1
software_breakpoint_inserted_here_p (CORE_ADDR pc)
d2218 2
a2219 1
	  && bpt->address == pc)	/* bp is enabled and matches pc */
d2231 1
a2231 1
  if (single_step_breakpoint_inserted_here_p (pc))
d2241 2
a2242 1
breakpoint_thread_match (CORE_ADDR pc, ptid_t ptid)
d2259 2
a2260 1
      if (bpt->address != pc)
d3120 2
a3121 1
bpstat_check_location (const struct bp_location *bl, CORE_ADDR bp_addr)
d3132 2
a3133 1
      if (bl->address != bp_addr) 	/* address doesn't match */
d3357 2
a3358 1
bpstat_stop_status (CORE_ADDR bp_addr, ptid_t ptid)
d3386 1
a3386 1
    if (!bpstat_check_location (bl, bp_addr))
d3441 2
a3442 1
      if (loc->address == bp_addr)
d3745 5
d3785 2
d3795 2
a3796 1
			       int print_address_bits)
d3976 30
d4139 2
a4140 1
		      struct bp_location **last_loc, int print_address_bits)
d4142 2
a4143 1
  print_one_breakpoint_location (b, NULL, 0, last_loc, print_address_bits);
d4167 1
a4167 1
					   print_address_bits);
d4204 1
a4204 1
	  print_one_breakpoint (b, &dummy_loc, print_address_bits);
d4320 1
a4320 1
	  print_one_breakpoint (b, &last_loc, print_address_bits);
d4368 1
d4374 2
a4375 1
      if (bl->address == pc
d4382 3
a4384 1
/* Print a message describing any breakpoints set at PC.  */
d4387 2
a4388 1
describe_other_breakpoints (struct gdbarch *gdbarch, CORE_ADDR pc,
d4395 1
a4395 1
    others += breakpoint_has_pc (b, pc, section);
d4403 1
a4403 1
	if (breakpoint_has_pc (b, pc, section))
d4432 2
a4433 1
set_default_breakpoint (int valid, CORE_ADDR addr, struct symtab *symtab,
d4437 1
d4471 14
d4492 3
a4494 1
check_duplicates_for (CORE_ADDR address, struct obj_section *section)
a4505 1
	&& b->address == address	/* address / overlay match */
d4507 3
a4509 1
	&& breakpoint_address_is_meaningful (b->owner))
d4542 5
a4546 4
		&& b->enabled && !b->shlib_disabled		
		&& b->address == address	/* address / overlay match */
		&& (!overlay_debugging || b->section == section)
		&& breakpoint_address_is_meaningful (b->owner))
d4568 1
a4568 1
    check_duplicates_for (bl->address, bl->section);    
d4792 3
d4807 5
d4859 2
a4860 1
    if (b->type == bp_longjmp_master)
d4933 2
a4934 1
    if (b->type == bp_thread_event)
d4970 2
a4971 1
    if (b->type == bp_shlib_event)
d5004 1
d5009 1
a5009 1
	&& solib_name_from_address (loc->address)
d5040 1
d5501 1
d5716 3
d5731 1
a5731 1
  executing_startup = 1;
d5740 1
a5740 1
  executing_startup = 0;
d5744 3
d5811 1
d5821 1
d6004 2
d6040 4
a6043 1
  cleanup = make_show_memory_breakpoints_cleanup (0);
d6083 2
d6097 1
a6097 1
				      sal.pc, sal.section, thread);
d6113 3
a6115 1
	  if (enabled && executing_startup
d6165 12
a6176 12
/* If appropriate, obtains all sals that correspond
   to the same file and line as SAL.  This is done
   only if SAL does not have explicit PC and has
   line and file information.  If we got just a single
   expanded sal, return the original.

   Otherwise, if SAL.explicit_line is not set, filter out 
   all sals for which the name of enclosing function 
   is different from SAL. This makes sure that if we have
   breakpoint originally set in template instantiation, say
   foo<int>(), we won't expand SAL to locations at the same
   line in all existing instantiations of 'foo'.
a6177 1
*/
d6186 1
d6199 5
d6205 2
a6206 1
  
d6208 1
d6218 1
d6229 5
d6277 2
a6278 1
  
d6370 1
d6689 1
d6691 1
a6691 1
      if (enabled && executing_startup
d6764 1
a6764 1
  struct symbol *sym = find_pc_function (sal->pc);
d6766 1
d6768 1
a6768 2
  if (sym == NULL)
    return;
d6770 2
a6771 2
  start_sal = find_function_start_sal (sym, 1);
  if (sal->pc < start_sal.pc)
d6773 7
a6779 3
      start_sal.explicit_line = sal->explicit_line;
      start_sal.explicit_pc = sal->explicit_pc;
      *sal = start_sal;
d6781 2
d6833 3
d6840 2
d7032 2
d7717 2
a7718 1
      describe_other_breakpoints (loc_gdbarch, sal.pc, sal.section, -1);
d7942 1
d8006 2
a8007 1
		  int pc_match = sal.pc 
d8014 1
d8183 6
a8188 2
			&& loc2 != loc && loc2->address == loc->address)
		      {		  
d8573 2
a8574 1
		  if (e->address == l->address)
d8611 2
a8612 2
  struct symtabs_and_lines sals = {};
  struct symtabs_and_lines expanded;
d8616 1
a8616 1
  struct cleanup *cleanups;
d8641 4
d8678 21
a8698 18
      if (not_found)
	break;
      
      gdb_assert (sals.nelts == 1);
      resolve_sal_pc (&sals.sals[0]);
      if (b->condition_not_parsed && s && s[0])
	{
	  char *cond_string = 0;
	  int thread = -1;
	  int task = 0;

	  find_condition_and_thread (s, sals.sals[0].pc, 
				     &cond_string, &thread, &task);
	  if (cond_string)
	    b->cond_string = cond_string;
	  b->thread = thread;
	  b->task = task;
	  b->condition_not_parsed = 0;
d8700 2
a8701 2
      expanded = expand_line_sal_maybe (sals.sals[0]);
      cleanups = make_cleanup (xfree, sals.sals);
a8702 1
      do_cleanups (cleanups);
d8775 1
d8786 1
d8790 2
d8806 2
d8826 6
d9202 2
a9203 1
deprecated_insert_raw_breakpoint (struct gdbarch *gdbarch, CORE_ADDR pc)
d9207 1
a9207 2
  bp_tgt = xmalloc (sizeof (struct bp_target_info));
  memset (bp_tgt, 0, sizeof (struct bp_target_info));
d9209 1
d9211 1
d9244 2
a9245 1
insert_single_step_breakpoint (struct gdbarch *gdbarch, CORE_ADDR next_pc)
d9268 1
a9268 1
  *bpt_p = deprecated_insert_raw_breakpoint (gdbarch, next_pc);
d9300 1
a9300 1
single_step_breakpoint_inserted_here_p (CORE_ADDR pc)
d9307 4
a9310 1
      if (bp_tgt && bp_tgt->placed_address == pc)
d9742 10
d9760 1
@


1.418
log
@	* jit.c (jit_read_descriptor): New arg gdbarch, all callers updated.
	(jit_read_code_entry, jit_register_code): Ditto.
	(jit_event_handler): Ditto.
	(jit_inferior_init): Renamed from previous jit_inferior_created_hook.
	(jit_inferior_created_hook, jit_breakpoint_re_set): New functions.
	(jit_inferior_created_observer): Renamed from
	jit_inferior_created_hook1, all callers updated.
	* jit.h (jit_breakpoint_re_set): Declare.
	(jit_event_handler): Update prototype.
	* breakpoint.c (breakpoint_re_set): Call jit_breakpoint_re_set instead
	of jit_inferior_created_hook.
@
text
@d63 1
d208 2
d4451 1
d4946 260
a5205 1
/* Create a new breakpoint of the bp_catchpoint kind and return it.
d5213 3
a5215 2
create_catchpoint (struct gdbarch *gdbarch, int tempflag,
		   char *cond_string, struct breakpoint_ops *ops)
a5220 3
  sal.pc = 0;
  sal.symtab = NULL;
  sal.line = 0;
d5233 17
d5336 16
d7447 107
d8020 1
d8957 54
d9362 2
d9373 1
d9379 1
d9653 1
d9660 1
d9665 1
d9670 1
d9675 11
d9692 1
d9699 1
@


1.417
log
@	Add interface for JIT code generation.
	* NEWS: Announce JIT interface.
	* Makefile.in (SFILES): Add jit.c.
	(HFILES_NO_SRCDIR): Add jit.h.
	(COMMON_OBS): Add jit.o.
	* jit.c: New file.
	* jit.h: New file.
	* breakpoint.h (enum bptype): Add bp_jit_event to enum.
	* breakpoint.c:
	(update_breakpoints_after_exec): Delete jit breakpoints after exec.
	(bpstat_what): Update event table for bp_jit_event.
	(print_it_typical): Added case for bp_jit_event.
	(print_one_breakpoint_location): Added case for bp_jit_event.
	(allocate_bp_location): Added case for bp_jit_event.
	(mention): Added case for bp_jit_event.
	(delete_command): Added case for bp_jit_event.
	(breakpoint_re_set_one): Added case for bp_jit_event.
	(breakpoint_re_set): Added call to jit_inferior_created_hook.
	(create_jit_event_breakpoint): New.
	* infrun.c (handle_inferior_event): Add handler for jit event.
	(follow_exec): Add call to jit_inferior_created_hook.
	* doc/gdb.texinfo: Add chapter on JIT interface.
@
text
@d8056 1
a8056 1
  jit_inferior_created_hook ();
@


1.416
log
@	Implement -break-commands

	* breakpoint.c (get_breakpoint, breakpoint_set_commands): New.
	(commands_command): Use breakpoint_set_commands.
	* breakpoint.h (get_breakpoint, breakpoint_set_commands): Declare.

	* mi/mi-cmds.h (mi_cmd_break_commands): New.
	* mi/mi-cmds.c: Register -break-commands.
	* mi/mi-cmd-break.c (mi_cmd_break_commands, mi_read_next_line)
	(mi_command_line_array, mi_command_line_array_cnt)
	(mi_command_line_array_ptr): New.
@
text
@d62 1
d1596 7
d2594 1
d3320 3
d3338 1
d3359 7
a3365 6
     kc   < clr sgl shl slr sn sr ss
     sgl  < shl slr sn sr ss
     slr  < err shl sn sr ss
     clr  < err shl sn sr ss
     ss   < shl sn sr
     sn   < shl sr
d3383 12
a3394 22
  /*       kc    ss    sn    sgl    slr   clr   sr   shl
   */
/*no_effect */
    {kc, ss, sn, sgl, slr, clr, sr, shl},
/*wp_silent */
    {ss, ss, sn, ss, ss, ss, sr, shl},
/*wp_noisy */
    {sn, sn, sn, sn, sn, sn, sr, shl},
/*bp_nostop */
    {sgl, ss, sn, sgl, slr, slr, sr, shl},
/*bp_silent */
    {ss, ss, sn, ss, ss, ss, sr, shl},
/*bp_noisy */
    {sn, sn, sn, sn, sn, sn, sr, shl},
/*long_jump */
    {slr, ss, sn, slr, slr, err, sr, shl},
/*long_resume */
    {clr, ss, sn, err, err, err, sr, shl},
/*step_resume */
    {sr, sr, sr, sr, sr, sr, sr, sr},
/*shlib */
    {shl, shl, shl, shl, shl, shl, sr, shl}
d3407 1
d3478 3
d3614 1
d3743 1
d4388 1
d4671 11
d5363 1
d7680 1
d7700 1
d8027 1
d8056 2
@


1.415
log
@	* breakpoint.c (remove_breakpoints): If removing one breakpoint
	location fails, still continue to remove other locations.
	(remove_hw_watchpoints): Likewise.
	(detach_breakpoints): Likewise.
@
text
@d565 14
d643 11
d683 1
a683 4
	free_command_lines (&b->commands);
	b->commands = l;
	breakpoints_changed ();
	observer_notify_breakpoint_modified (b->number);
@


1.414
log
@	* breakpoint.h (enum enable_state): Add bp_startup_disabled.
	(disable_breakpoints_before_startup): Add prototype.
	(enable_breakpoints_after_startup): Likewise.

	* breakpoint.c (executing_startup): New static variable.
	(describe_other_breakpoints): Handle bp_startup_disabled.
	(check_duplicates_for): Likewise.
	(disable_breakpoints_before_startup): New function.
	(enable_breakpoints_after_startup): New function.
	(create_breakpoint): Mark new breakpoints as bp_startup_disabled
	if executing_startup flag is true.
	(break_command_really): Likewise.
	(breakpoint_re_set_one): Skip bp_startup_disabled breakpoints.
@
text
@d1412 1
a1412 1
  int val;
d1417 1
a1417 5
      {
	val = remove_breakpoint (b, mark_uninserted);
	if (val != 0)
	  return val;
      }
d1419 1
a1419 1
  return 0;
d1426 1
a1426 1
  int val;
d1431 1
a1431 5
      {
	val = remove_breakpoint (b, mark_uninserted);
	if (val != 0)
	  return val;
      }
d1433 1
a1433 1
  return 0;
d1658 1
a1658 1
  int val;
d1669 1
a1669 8
      {
	val = remove_breakpoint (b, mark_inserted);
	if (val != 0)
	  {
	    do_cleanups (old_chain);
	    return val;
	  }
      }
d1672 1
a1672 1
  return 0;
@


1.413
log
@	* breakpoint.c (set_raw_breakpoint): Remove static modifier.
@
text
@d322 3
d4146 2
a4147 1
			       || b->enable_state == bp_call_disabled) 
d4218 1
d4255 1
d5104 46
d5493 5
d6053 5
d7857 4
@


1.412
log
@	* defs.h (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter.
	* utils.c (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter, use it instead of current_gdbarch.
	* ui-out.h (ui_out_field_core_addr): Add GDBARCH parameter.
	* ui-out.c (ui_out_field_core_addr): Add GDBARCH parameter,
	use it instead of current_gdbarch.

	Update calls to ui_out_field_core_addr to pass architecture:
	* ada-lang.c (print_one_exception): Update.
	* breakpoint.c (print_one_breakpoint_location,
	print_one_exception_catchpoint): Update.
	* disasm.c (dump_insns): Update.
	* darwin-nat-info.c (darwin_debug_regions_recurse): Update.
	* mi/mi-main.c (mi_cmd_data_read_memory): Update.
	* mi/mi-symbol-cmds.c: Include "objfiles.h".
	(mi_cmd_symbol_list_lines): Update.
	* stack.c (print_frame_info, print_frame): Update.

	Update callers of paddress to pass architecture:
	* ada-tasks.c (info_task): Update.
	* ada-valprint.c (ada_val_print_1): Update.
	* annotate.c (annotate_source, annotate_frame_begin): Update.
	* breakpoint.c (insert_bp_location, describe_other_breakpoints,
	mention): Update.
	* cli/cli-cmds.c (edit_command, list_command, print_disassembly):
	Update.
	* corefile.c (memory_error): Update.
	* c-valprint.c (print_function_pointer_address, c_val_print): Update.
	* disasm.c (dis_asm_print_address): Update.
	* exec.c (print_section_info): Update.
	* f-valprint.c (f_val_print): Update.
	* infcmd.c: Include "arch-utils.h".
	(jump_command, program_info): Update.
	* linux-fork.c: Include "arch-utils.h".
	(info_forks_command): Update.
	* m2-valprint.c (print_function_pointer_address,
	print_unpacked_pointer, print_variable_at_address,
	m2_val_print): Update.
	* m32r-rom.c (m32r_load_section, m32r_load, m32r_upload_command):
	Update.
	* printcmd.c (print_address, print_address_demangle, address_info):
	Update.
	* p-valprint.c (pascal_val_print): Update.
	* source.c: Include "arch-utils.h".
	(line_info): Update.
	* stack.c (frame_info, print_block_frame_labels): Update.
	* symfile.c (add_symbol_file_command, list_overlays_command): Update.
	* symmisc.c (dump_msymbols, dump_psymtab, dump_symtab_1,
	print_symbol, print_partial_symbols, maintenance_info_psymtabs,
	maintenance_check_symtabs): Update.
	* symtab.c (find_pc_sect_symtab): Update.
	* target.c (deprecated_debug_xfer_memory): Update.
	* tracepoint.c (scope_info): Update.
	* tui/tui-stack.c (tui_make_status_line): Update.
	* valprint.c (val_print_string): Update.

	Update callers of paddr_nz to use paddress instead (keeping
	user-visible output identical):
	* alpha-tdep.c (alpha_heuristic_proc_start): Update.
	* amd64-tdep.c (fixup_riprel, amd64_displaced_step_copy_insn,
	amd64_displaced_step_fixup): Update.
	* arch-utils.c (simple_displaced_step_copy_insn): Update.
	* auxv.c (fprint_target_auxv): Update.
	* breakpoint.c (insert_single_step_breakpoint): Update.
	* buildsym.c (finish_block): Update.
	* cli/cli-dump.c (restore_section_callback): Update.
	* fbsd-nat.c (fbsd_find_memory_regions): Update.
	* frame.c (frame_unwind_register_value): Update.
	* gcore.c (gcore_create_callback): Update.
	* hppa-tdep.c (hppa_frame_cache, hppa_skip_trampoline_code): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_record_modrm,
	i386_record_lea_modrm_addr, i386_record_lea_modrm,
	i386_process_record): Update.
	* ia64-tdep.c (ia64_frame_this_id, ia64_sigtramp_frame_this_id,
	ia64_libunwind_frame_this_id, ia64_libunwind_sigtramp_frame_this_id,
	ia64_dummy_id, ia64_access_reg, ia64_access_rse_reg): Update.
	* infrun.c (displaced_step_prepare, displaced_step_fixup,
	handle_inferior_event, insert_step_resume_breakpoint_at_sal,
	insert_longjmp_resume_breakpoint): Update.
	* linux-nat.c (linux_nat_find_memory_regions): Update.
	* linux-record.c (record_linux_system_call): Update.
	* mips-tdep.c (heuristic_proc_start, mips_eabi_push_dummy_call,
	mips_n32n64_push_dummy_call, mips_o32_push_dummy_call,
	mips_o64_push_dummy_call): Update.
	* monitor.c (monitor_error, monitor_remove_breakpoint): Update.
	* record.c (record_arch_list_add_mem, record_wait,
	record_xfer_partial): Update.
	* remote-mips.c (mips_fetch_word, mips_check_lsi_error,
	mips_common_breakpoint): Update.
	* remote-sim.c (gdbsim_xfer_inferior_memory): Update.
	* rs6000-tdep.c (ppc_displaced_step_fixup): Update.
	* solib-som.c (som_current_sos): Update.
	* symfile.c (load_progress, generic_load): Update.
	* symfile-mem.c (add_vsyscall_page): Update.
	* valops.c (value_fetch_lazy): Update.
	* windows-tdep.c (windows_xfer_shared_library): Update.

	Update callers of paddr_nz to use paddress instead (changing
	user-visible output to make it more correct):
	* dwarf2loc.c (locexpr_describe_location): Update.
	* ia64-tdep.c (ia64_memory_insert_breakpoint,
	ia64_memory_remove_breakpoint): Update.
	* jv-valprint.c (java_value_print): Update.
	* m32c-tdep.c (m32c_m16c_address_to_pointer): Update.
	* monitor.c (monitor_read_memory): Update.

	Update callers of paddr to use paddress instead (changing
	user-visible output to make it more correct):
	* arm-tdep.c (arm_push_dummy_call): Update.
	* breakpoint.c (insert_bp_location, create_thread_event_breakpoint,
	create_breakpoint): Update.
	* darwin-nat-info.c (darwin_debug_regions): Update.
	* dcache.c (dcache_info): Update.
	* dsrec.c (load_srec, make_srec): Update.
	* dwarf2-frame.c (dwarf2_restore_rule, execute_cfa_program,
	dwarf2_frame_cache): Update.
	* gcore.c (gcore_copy_callback): Update.
	* gnu-nat.c (gnu_xfer_memory): Update.
	* mips-linux-nat.c (mips_show_dr): Update.
	* monitor.c (monitor_write_memory, monitor_insert_breakpoint,
	monitor_remove_breakpoint): Update.
	* remote.c (compare_sections_command): Update.
	* remote-m32r-sdi.c (m32r_xfer_memory, m32r_insert_breakpoint,
	m32r_remove_breakpoint, m32r_insert_watchpoint,
	m32r_remove_watchpoint): Update.
	* sol-thread.c (info_cb): Update.
	* symfile.c (load_progress): Update.

	Update callers of paddress or paddr_nz to use hex_string instead
	(changes output of internal/error/debug messages only):
	* dwarf2read.c (dump_die_shallow): Update.
	* frame.c (fprint_field, fprint_frame, frame_pc_unwind,
	get_frame_func, create_new_frame): Update.
	* hppa-tdep.c (find_unwind_entry, unwind_command): Update.
	* ia64-tdep.c (get_kernel_table, ia64_find_proc_info_x,
	ia64_get_dyn_info_list): Update.
	* maint.c (maintenance_translate_address): Update.
	* mi/mi-cmd-var.c (mi_cmd_var_create): Update.
	* target.c (target_flash_erase): Update.

	Update callers of paddr/paddr_nz to use phex/phex_nz instead,
	using an appropriate address size.  Remove use of strlen_paddr.
	* exec.c (exec_files_info): Update.
	* i386-nat.c (i386_show_dr): Update.
	* remote.c (remote_flash_erase): Update.
	* m32r-rom.c (m32r_load_section): Update.
	* monitor.c (monitor_vsprintf, monitor_store_register): Update.
	* remote.c (remote_check_symbols, remote_search_memory): Update.
	* remote-mips.c (mips_request, mips_common_breakpoint): Update.
	* scm-valprint.c (scm_ipruk, scm_scmval_print): Update.
	* sh64-tdep.c (sh64_show_media_regs, sh64_show_compact_regs): Update.
	* sh-tdep.c (sh_generic_show_regs, sh3_show_regs, sh2e_show_regs,
	sh2a_show_regs, sh2a_nofpu_show_regs, sh3e_show_regs,
	sh3_dsp_show_regs, sh4_show_regs, sh4_nofpu_show_regs,
	sh_dsp_show_regs): Update.
	* xcoffsolib.c (sharedlibrary_command): Update.


	* maint.c (maint_print_section_info): Add ADDR_SIZE parameter.
	Use hex_string_custom instead of paddr.
	(print_bfd_section_info): Pass address size.
	(print_objfile_section_info): Likewise.

	* annotate.h (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* annotate.c (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* source.c (identify_source_line): Update call to annotate_source.
	* stack.c (print_frame_info, print_frame): Update call to
	annotate_frame_begin.

	* breakpoint.c (describe_other_breakpoints): Add GDBARCH parameter.
	(create_breakpoint, create_ada_exception_breakpoint): Update call.

	* stack.c (print_block_frame_labels): Add GDBARCH parameter.
	(print_frame_label_vars): Update call.

	* symmisc.c (print_partial_symbols): Add GDBARCH parameter.
	(dump_psymtab): Update call to print_partial_symbols.
	(struct print_symbol_args): Add GDBARCH member.
	(dump_symtab_1): Set print_symbol_args architecture member.
	(print_symbol): Use it.

	* windows-tdep.h (windows_xfer_shared_library): Add GDBARCH
	parameter.
	* windows-tdep.c (windows_xfer_shared_library): Likewise.
	* i386-cygwin-tdep.c (struct cpms_data): Add GDBARCH member.
	(core_process_module_section): Pass architecture from cpms_data to
	windows_xfer_shared_library.
	(windows_core_xfer_shared_libraries): Initialize cmps_data
	architecture member.
	* windows-nat.c (windows_xfer_shared_libraries): Pass architecture
	to windows_xfer_shared_library.

	* defs.h (print_address): Add GDBARCH parameter.
	* printcmd.c (print_address): Add GDBARCH parameter.
	(print_scalar_formatted, do_examine): Update call.
	* findcmd.c (find_command): Update call.
	* tracepoint.c: Include "arch-utils.h".
	(trace_find_line_command): Update call.
	* tui/tui-disasm.c (tui_disassemble): Update call.

	* value.h (print_address_demangle): Add GDBARCH parameter.
	* printcmd.c (print_address_demangle): Add GDBARCH parameter.
	* c-valprint.c (print_function_pointer_address, c_val_print):
	Update call.
	* f-valprint.c (f_val_print): Update call.
	* gnu-v3-abi.c (gnuv3_print_method_ptr): Update call.
	* jv-valprint.c (java_val_print): Update call.
	* m2-valprint.c (print_function_pointer_address, m2_val_print):
	Update call.
	* p-valprint.c (pascal_val_print): Update call.

	* disasm.c (gdb_disassemble_info): Install architecture into
	di.application_data field.

testsuite/ChangeLog:

	* gdb.threads/tls-shared.exp: Update to locexpr_describe_location
	change to prefix TLS offset in hex with 0x.

doc/ChangeLog:

	* gdbint.texinfo (Item Output Functions): Update signature
	for ui_out_field_core_addr.
@
text
@d108 2
a109 1
static struct breakpoint *set_raw_breakpoint (struct gdbarch *gdbarch,
d4400 1
d4485 1
a4485 1
static struct breakpoint *
@


1.411
log
@	* breakpoint.h (struct breakpoint): New member GDBARCH.
	* breakpoint.c: Include "arch-utils.h".
	(set_raw_breakpoint_without_location): Add GDBARCH parameter.
	Use it to set breakpoint architecture.
	(set_raw_breakpoint): Add GDBARCH parameter.
	(create_internal_breakpoint): Likewise.
	(create_catchpoint): Likewise.
	(create_fork_vfork_event_catchpoint): Likewise.
	(create_breakpoint): Likewise.
	(create_breakpoints): Likewise.
	(break_command_really): Likewise.
	(create_ada_exception_breakpoint): Likewise.
	Update local callers to pass architecture:
	(create_internal_breakpoint): Update.
	(create_overlay_event_breakpoint): Update.
	(create_longjmp_master_breakpoint): Update.
	(create_thread_event_breakpoint): Update.
	(create_solib_event_breakpoint): Update.
	(create_catchpoint): Update.
	(create_fork_vfork_event_catchpoint): Update.
	(set_momentary_breakpoint): Update.
	(clone_momentary_breakpoint): Update.
	(create_breakpoint): Update.
	(create_breakpoints): Update.
	(break_command_really): Update.
	(break_command_1): Update.
	(set_breakpoint): Update.
	(watch_command_1): Update.
	(catch_fork_command_1): Update.
	(catch_exec_commnd_1): Update.
	(handle_gnu_v3_exceptions): Update.
	(create_ada_exception_breakpoint): Update.
	(catch_ada_exception_command): Update.
	(catch_assert_command): Update.
	(trace_command): Update.

	* breakpoint.h (struct bp_location): New member GDBARCH.
	* breakpoint.c (get_sal_arch): New function.
	(set_raw_breakpoint): Set location architecture.
	(add_location_to_breakpoint): Likewise.
	(clone_momentary_breakpoint): Likewise.
	(watch_command_1): Likewise.
	(update_watchpoint): Likewise.
	(bp_loc_is_permanent): Use location architecture instead of
	current_gdbarch.
	(adjust_breakpoint_address): Add GDBARCH parameter; use it
	instead of current_gdbarch.
	Update callers of adjust_breakpoint_address to pass
	breakpoint location architecture:
	(set_raw_breakpoint): Update.
	(watch_command_1): Update.

        * tracepoint.c: (collect_symbol): Add GDBARCH parameter, use instead
	of current_gdbarch.
	(add_local_symbols): Add GDBARCH parameter.  Pass to collect_symbol.
	(encode_actions): Pass tracepoint architecture to add_local_symbols
	(encode_actions): Use tracepoint architecture instead of
	current_gdbarch.  Pass it to add_local_symbols and collect_symbol.

	* breakpoint.h (struct breakpoint_ops): Replace last_addr parameter
	of print_one callback with last_loc.
	* breakpoint.c (print_one_breakpoint_location): Replace last_addr
	parameter with last_loc.
	(print_one_breakpoint): Likewise.
	(do_captured_breakpoint_query): Update call.
	(breakpoint_1): Pass last_loc instead of last_addr to
	print_one_breakpoint.  Pass last location architecture instead of
	current_gdbarch to set_next_address.
	Update all implementations of the print_one callback:
	* breakpoint.c (print_one_catch_fork): Update.
	(print_one_catch_vfork): Update.
	(print_one_catch_exec): Update.
	(print_one_exception_catchpoint): Update.
	* ada-lang.c (print_one_exception): Update.
	(print_one_catch_exception): Update.
	(print_one_catch_exception_unhandled): Update.
	(print_one_catch_assert): Update.

	* breakpoint.c (print_one_breakpoint_location): Add PRINT_ADDRESS_BITS
	parameter.  Use it instead of gdbarch_addr_bit (current_gdbarch).
	(print_one_breakpoint): Add PRINT_ADDRESS_BITS parameter and pass it
	to print_one_breakpoint_location.
	(breakpoint_address_bits): New function.
	(do_captured_breakpoint_query): Compute number of address bits to print
	and pass it to print_one_breakpoint.
	(breakpoint_1): Likewise.  Use it instead of current_gdbarch.

	* breakpoint.h (create_thread_event_breakpoint): Add GDBARCH.
	* breakpoint.c (create_thread_event_breakpoint): Likewise.
	Update callers to create_thread_event_breakpoint:
	* aix-thread.c (pd_enable): Update.
	* linux-thread-db.c (enable_thread_event): Update.

	* breakpoint.h (create_solib_event_breakpoint): Add GDBARCH.
	* breakpoint.c (create_solib_event_breakpoint): Likewise.
	Update callers to create_solib_event_breakpoint:
	* solib-frv.c (enable_break, enable_break2): Update.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Update.
	* solib-som.c (som_solib_create_inferior_hook): Update.
	* solib-darwin.c (darwin_solib_create_inferior_hook): Update.
	* solib-svr4.c (enable_break): Update.

	* breakpoint.h (insert_single_step_breakpoint): Add GDBARCH.
	* breakpoint.c (insert_single_step_breakpoint): Likewise.
	Update callers to insert_single_step_breakpoint:
	* alpha-tdep.c (alpha_software_single_step): Update.
	* arm-linux-tdep.c (arm_linux_software_single_step): Update.
	* arm-tdep.c (arm_software_single_step): Update.
	* cris-tdep.c (cris_software_single_step): Update.
	* rs6000-aix-tdep.c (rs6000_software_single_step): Update.
	* rs6000-tdep.c (ppc_deal_with_atomic_sequence): Update.
	* sparc-tdep.c (sparc_software_single_step): Update.
	* spu-tdep.c (spu_software_single_step): Update.
	* mips-tdep.c (deal_with_atomic_sequence): Add GDBARCH parameter.
	Pass it to insert_single_step_breakpoint.
	(mips_software_single_step): Pass architecture to
	deal_with_atomic_sequence and insert_single_step_breakpoint.

	* breakpoint.h (deprecated_insert_raw_breakpoint): Add GDBARCH.
	(deprecated_remove_raw_breakpoint): Likewise.
	* breakpoint.c (deprecated_insert_raw_breakpoint): Add GDBARCH.
	(deprecated_remove_raw_breakpoint): Likewise.
	Update callers to deprecated_insert_raw_breakpoint and
	deprecated_remove_raw_breakpoint:
	* breakpoint.c (single_step_gdbarch): New static variable.
	(insert_single_step_breakpoint): Pass GDBARCH parameter to
	deprecated_insert_raw_breakpoint.  Store it in single_step_gdbarch.
	(remove_single_step_breakpoints): Pass architecture stored in
	single_step_gdbarch to deprecated_remove_raw_breakpoint.
	* rs6000-nat.c (exec_one_dummy_insn): Update.
	* solib-irix.c (enable_break, disable_break): Update.
	* procfs.c (procfs_mourn_inferior): Update.
	(remove_dbx_link_breakpoint): Update.

	* breakpoint.h (set_breakpoint): Add GDBARCH parameter.
	(set_momentary_breakpoint, set_momentary_breakpoint_at_pc): Likewise.
	* breakpoint.c (set_breakpoint): Add GDBARCH parameter.
	(set_momentary_breakpoint, set_momentary_breakpoint_at_pc): Likewise.
	Update callers to set_breakpoint, set_momentary_breakpoint and
	set_momentary_breakpoint_at_pc:
	* breakpoint.c (set_momentary_breakpoint_at_pc): Update.
	(until_break_command): Update.
	* infcall.c (call_function_by_hand): Update.
	* infcmd.c (finish_backward, finish_forward): Update.
	* infrun.c (insert_step_resume_breakpoint_at_sal): Add GDBARCH
	parameter.  Pass it to set_momentary_breakpoint.
	(insert_longjmp_resume_breakpoint): Add GDBARCH parameter.
	Pass it to set_momentary_breakpoint_at_pc.
	(handle_inferior_event): Update.
	(insert_step_resume_breakpoint_at_frame): Update.
	(insert_step_resume_breakpoint_at_caller): Update..
	* mi/mi-cmd-break.c: Include "arch-utils.h".
	(mi_cmd_break_insert): Update.

	* target.h (struct target_ops): Add GDBARCH parameter to
	to_insert_breakpoint, to_remove_breakpoint, to_insert_hw_breakpoint,
	and to_remove_hw_breakpoint members.
	(target_insert_breakpoint, target_remove_breakpoint,
	target_insert_hw_breakpoint, target_remove_hw_breakpoint): Add GDBARCH
	parameter, pass to target routine.
	(memory_remove_breakpoint, memory_insert_breakpoint): Add GDBARCH
	parameter.
	* target.c (debug_to_insert_breakpoint, debug_to_remove_breakpoint,
	debug_to_insert_hw_breakpoint, debug_to_remove_hw_breakpoint): Add
	GDBARCH parameter, pass to target routine.
	(update_current_target): Update function signature.
	* breakpoint.c (insert_bp_location, remove_breakpoint,
	deprecated_insert_raw_breakpoint, deprecated_remove_raw_breakpoint):
	Pass architecture to target_ routines.
	Update all implementations of the target breakpoint routines to take
	GDBARCH parameter and use it instead of GDBARCH as appropriate:
	* corelow.c (ignore): Update.
	* exec.c (ignore): Update.
	* mem-break.c (memory_insert_breakpoint): Update.
	(memory_remove_breakpoint): Update.
	* monitor.c (monitor_insert_breakpoint): Update.
	(monitor_remove_breakpoint): Update.
	* record.c (record_insert_breakpoint): Update.
	(record_beneath_to_insert_breakpoint): Update.
	(record_remove_breakpoint): Update.
	(record_beneath_to_remove_breakpoint): Update.
	* remote.c (remote_insert_breakpoint): Update.
	(remote_remove_breakpoint): Update.
	(remote_insert_hw_breakpoint): Update.
	(remote_remove_hw_breakpoint): Update.
	* remote-m32r-sdi.c (m32r_insert_breakpoint): Update.
	(m32r_remove_breakpoint): Update.
	* remote-mips.c (mips_insert_breakpoint): Update.
	(mips_remove_breakpoint): Update.
	* i386-nat.c (i386_insert_hw_breakpoint): Update.
	(i386_remove_hw_breakpoint): Update.
	* nto-procfs.c (procfs_insert_breakpoint):  Update.
	(procfs_remove_breakpoint): Update.
	(procfs_insert_hw_breakpoint): Update.
	(procfs_remove_hw_breakpoint): Update.

doc/ChangeLog:

	* gdbint.texi (Examples of Use of @@code{ui_out} functions):
	Update example code extrated from breakpoint.c.
@
text
@d120 2
a121 1
static void describe_other_breakpoints (CORE_ADDR, struct obj_section *, int);
d1144 1
a1144 1
			 paddr (bpt->address));
d1244 2
a1245 1
		  fputs_filtered (paddress (bpt->address), tmp_error_stream);
d3731 2
a3732 1
	      ui_out_field_core_addr (uiout, "addr", loc->address);
d3766 2
a3767 1
      ui_out_field_core_addr (uiout, "frame", b->frame_id.stack_addr);
d4117 2
a4118 2
describe_other_breakpoints (CORE_ADDR pc, struct obj_section *section,
			    int thread)
d4151 1
a4151 1
      fputs_filtered (paddress (pc), gdb_stdout);
d4613 2
a4614 1
  b->addr_string = xstrprintf ("*0x%s", paddr (b->loc->address));
d5297 2
a5298 1
	      fputs_filtered (paddress (b->loc->address), gdb_stdout);
d5417 8
a5424 1
	describe_other_breakpoints (sal.pc, sal.section, thread);
d5463 2
a5464 1
    b->addr_string = xstrprintf ("*0x%s", paddr (b->loc->address));
d6876 2
a6877 1
	ui_out_field_core_addr (uiout, "addr", b->loc->address);
d6998 5
a7002 1
      describe_other_breakpoints (sal.pc, sal.section, -1);
d8408 2
a8409 2
    error (_("Could not insert single-step breakpoint at 0x%s"),
	     paddr_nz (next_pc));
@


1.410
log
@	gdb/
	* NEWS: Document inlined function support.
	* Makefile.in (SFILES): Add inline-frame.c.
	(COMMON_OBS): Add inline-frame.o.
	* block.c (contained_in): Rewrite to use lexical nesting.
	(block_linkage_function): Skip inlined function blocks.
	(block_inlined_p): New.
	* block.h (struct block): Update comment.
	(block_inlined_p): New prototype.
	* blockframe.c (get_frame_block): Handle inlined functions.
	(get_frame_function): Do not use block_linkage_function.
	(block_innermost_frame): Use get_frame_block and contained_in.
	* breakpoint.c (watchpoint_check): Remove extra reinit_frame_cache.
	Skip over inlined functions.  Simplify epilogue check.
	(bpstat_check_breakpoint_conditions): Use get_stack_frame_id.
	Update comments.
	(set_momentary_breakpoint): Only accept non-inlined frames.
	(watch_command_1): Use frame_unwind_caller_pc and
	frame_unwind_caller_id instead of get_prev_frame.
	(until_break_command): Likewise.  Use get_stack_frame_id.
	* buildsym.c (end_symtab): Set SYMBOL_SYMTAB for block functions.
	* dwarf2loc.c (dwarf_expr_frame_base): Use block_linkage_function.
	* dwarf2read.c (process_die): Handle DW_TAG_inlined_subroutine.
	(read_func_scope, new_symbol): Likewise.  Handle arguments specially
	for inlined functions without call site information.
	(inherit_abstract_dies): Allow tag mismatch for inlined subroutines.
	(die_specification): Treat DW_AT_abstract_origin as a specification.
	(read_type_die): Handle DW_TAG_inlined_subroutine.
	* frame-unwind.c (frame_unwind_init): Add inline_frame_unwind.
	* frame.c (fprint_frame_id): Print inline depth.
	(fprint_frame_type): Handle INLINE_FRAME and SENTINEL_FRAME.
	(skip_inlined_frames, get_stack_frame_id): New.
	(frame_unwind_caller_id): Use skip_inlined_frames.
	(frame_id_inlined_p): New.
	(frame_id_eq): Make the logic match the comments.  Add inline_depth
	check.
	(frame_id_inner): Handle inlined functions.
	(frame_unwind_pc): New function, copied from frame_unwind_caller_pc.
	(frame_unwind_caller_pc): Use skip_inlined_frames and frame_unwind_pc.
	(get_prev_frame_1): Check for inline frames.  Split out frame
	allocation to get_prev_frame_raw.
	(get_prev_frame_raw): New function.
	(get_prev_frame): Handle inline frames.
	(get_frame_pc): Use frame_unwind_pc.
	(get_frame_address_in_block): Skip inlined frames on both sides.
	(pc_notcurrent): Delete.
	(find_frame_sal): Rewrite to handle inline call sites.  Use
	get_frame_address_in_block.
	(deprecated_update_frame_pc_hack): Make static.
	* frame.h: Update comments.
	(struct frame_id): Add inline_depth.
	(enum frame_type): Add INLINE_FRAME.
	(frame_id_inlined_p, get_stack_frame_id): New prototypes.
	* gdbthread.h (struct thread_info): Add step_stack_frame_id field.
	* infcmd.c (set_step_frame): New function.
	(step_once): Use set_step_frame.  Handle inlined functions.
	(until_next_command): Use set_step_frame.
	(finish_backward), finish_forward): Use get_stack_frame_id.
	(finish_command): Support inlined functions.
	* inferior.h (set_step_info): New prototype.
	* infrun.c (RESUME_ALL): Use minus_one_ptid.
	(clear_proceed_status): Clear step_stack_frame_id.
	(init_wait_for_inferior): Call clear_inline_frame_state.
	(init_execution_control_state): Make static.
	(set_step_info): New function.
	(init_thread_stepping_state): Do not set the symtab or line here.
	(stepped_in_from): New function.
	(handle_inferior_event): Handle inlined functions.  Use set_step_info.
	(insert_step_resume_breakpoint_at_frame): Use get_stack_frame_id.
	(struct inferior_status): Add step_stack_frame_id.
	(save_inferior_status, restore_inferior_status): Save and restore
	step_stack_frame_id.
	* inline-frame.c, inline-frame.h: New files.
	* minsyms.c (prim_record_minimal_symbol_and_info): Use XCALLOC.
	* regcache.c (regcache_write_pc): Call reinit_frame_cache.
	* s390-tdep.c (s390_prologue_frame_unwind_cache): Handle INLINE_FRAME.
	* stack.c (frame_show_address): New.
	(print_frame_info, print_frame): Use it.
	(find_frame_funname): Use get_frame_function.  Handle inlined blocks.
	(frame_info): Mark inlined functions.
	(backtrace_command_1): Use get_current_user_frame.
	(print_frame_local_vars, print_frame_label_vars): Update comments.
	(return_command): Refuse inlined functions.
	* symtab.c (lookup_symbol_aux_local): Stop at inlined function
	boundaries.
	(find_function_start_sal): Avoid inlined functions.
	(completion_list_add_fields): New function.
	(default_make_symbol_completion_list): Use it.  Use block_static_block
	and block_global_block.  Check for inlined functions.
	(skip_prologue_using_sal): Avoid line number comparison across
	inlining.
	* symtab.h (struct symbol): Add is_inlined.
	(SYMBOL_INLINED): New.
	* target.c (target_resume): Call clear_inline_frame_state.
	* valops.c (value_of_variable): Check block_inlined_p.

	gdb/doc/
	* gdb.texinfo (Debugging Optimized Code): New chapter.
	(Compiling for Debugging): Reference it.  Move some
	text to the new section.

	gdb/testsuite/
	* gdb.base/break.exp: Add an XFAIL for gcc/36748.
	* gdb.cp/annota2.exp: Accept frames-invalid in more places.
	* gdb.opt/Makefile.in (EXECUTABLES): Update.
	* gdb.opt/clobbered-registers-O2.exp: Update to GPL v3.
	* gdb.opt/inline-bt.c, gdb.opt/inline-bt.exp,
	gdb.opt/inline-cmds.c, gdb.opt/inline-cmds.exp,
	gdb.opt/inline-locals.c, gdb.opt/inline-locals.exp,
	gdb.opt/inline-markers.c: New files.
	* lib/gdb.exp (skip_inline_frame_tests): New function.
	(skip_inline_var_tests): New function.
@
text
@d23 1
d108 3
a110 1
struct breakpoint *set_raw_breakpoint (struct symtab_and_line, enum bptype);
d116 2
a117 1
static CORE_ADDR adjust_breakpoint_address (CORE_ADDR bpaddr,
d1012 1
d1155 2
a1156 1
	    val = target_insert_hw_breakpoint (&bpt->target_info);
d1158 2
a1159 1
	    val = target_insert_breakpoint (&bpt->target_info);
d1180 2
a1181 1
		  val = target_insert_breakpoint (&bpt->overlay_target_info);
d1193 2
a1194 1
		val = target_insert_hw_breakpoint (&bpt->target_info);
d1196 2
a1197 1
		val = target_insert_breakpoint (&bpt->target_info);
d1471 2
a1472 1
create_internal_breakpoint (CORE_ADDR address, enum bptype type)
d1482 1
a1482 1
  b = set_raw_breakpoint (sal, type);
d1503 2
a1504 1
      b = create_internal_breakpoint (SYMBOL_VALUE_ADDRESS (m),
d1539 2
a1540 1
      b = create_internal_breakpoint (SYMBOL_VALUE_ADDRESS (m),
d1712 1
a1712 1
	    val = target_remove_hw_breakpoint (&b->target_info);
d1714 1
a1714 1
	    val = target_remove_breakpoint (&b->target_info);
d1728 2
a1729 1
		  target_remove_hw_breakpoint (&b->overlay_target_info);
d1731 2
a1732 1
		  target_remove_breakpoint (&b->overlay_target_info);
d1743 2
a1744 1
		val = target_remove_hw_breakpoint (&b->target_info);
d1750 2
a1751 1
		val = target_remove_breakpoint (&b->target_info);
d3561 2
a3562 1
			       CORE_ADDR *last_addr)
d3671 1
a3671 1
      if (gdbarch_addr_bit (current_gdbarch) <= 32)
d3684 1
a3684 1
      b->ops->print_one (b, last_addr);
d3735 1
a3735 1
	  *last_addr = b->loc->address;
d3871 1
a3871 1
		      CORE_ADDR *last_addr)
d3873 1
a3873 1
  print_one_breakpoint_location (b, NULL, 0, last_addr);
d3896 2
a3897 1
	    print_one_breakpoint_location (b, loc, n, last_addr);
d3902 15
d3928 1
a3928 1
  CORE_ADDR dummy_addr = 0;
d3933 2
a3934 1
	  print_one_breakpoint (b, &dummy_addr);
d3979 1
a3979 1
  CORE_ADDR last_addr = (CORE_ADDR) -1;
d3983 1
d3987 2
a3988 1
  /* Compute the number of rows in the table. */
d3995 7
a4001 1
	  nr_printable_breakpoints++;
d4031 1
a4031 1
	  if (gdbarch_addr_bit (current_gdbarch) <= 32)
d4050 1
a4050 1
	  print_one_breakpoint (b, &last_addr);
d4065 2
a4066 4
      /* Compare against (CORE_ADDR)-1 in case some compiler decides
	 that a comparison of an unsigned with -1 is always false.  */
      if (last_addr != (CORE_ADDR) -1 && !server_command)
	set_next_address (current_gdbarch, last_addr);
d4295 2
a4296 1
adjust_breakpoint_address (CORE_ADDR bpaddr, enum bptype bptype)
d4298 1
a4298 1
  if (!gdbarch_adjust_breakpoint_address_p (current_gdbarch))
d4319 1
a4319 2
      adjusted_bpaddr = gdbarch_adjust_breakpoint_address (current_gdbarch,
                                                           bpaddr);
d4397 2
a4398 1
set_raw_breakpoint_without_location (enum bptype bptype)
d4406 1
d4452 12
d4479 3
a4481 2
struct breakpoint *
set_raw_breakpoint (struct symtab_and_line sal, enum bptype bptype)
d4483 1
a4483 1
  struct breakpoint *b = set_raw_breakpoint_without_location (bptype);
d4485 5
d4497 1
a4497 1
  adjusted_address = adjust_breakpoint_address (sal.pc, b->type);
d4500 1
d4601 1
a4601 1
create_thread_event_breakpoint (CORE_ADDR address)
d4605 1
a4605 1
  b = create_internal_breakpoint (address, bp_thread_event);
d4652 1
a4652 1
create_solib_event_breakpoint (CORE_ADDR address)
d4656 1
a4656 1
  b = create_internal_breakpoint (address, bp_shlib_event);
d4776 1
a4776 1
print_one_catch_fork (struct breakpoint *b, CORE_ADDR *last_addr)
d4858 1
a4858 1
print_one_catch_vfork (struct breakpoint *b, CORE_ADDR *last_addr)
d4908 2
a4909 2
create_catchpoint (int tempflag, char *cond_string,
                   struct breakpoint_ops *ops)
d4919 1
a4919 1
  b = set_raw_breakpoint (sal, bp_catchpoint);
d4937 2
a4938 1
create_fork_vfork_event_catchpoint (int tempflag, char *cond_string,
d4941 2
a4942 1
  struct breakpoint *b = create_catchpoint (tempflag, cond_string, ops);
d4979 1
a4979 1
print_one_catch_exec (struct breakpoint *b, CORE_ADDR *last_addr)
d5097 2
a5098 2
set_momentary_breakpoint (struct symtab_and_line sal, struct frame_id frame_id,
			  enum bptype type)
d5106 1
a5106 1
  b = set_raw_breakpoint (sal, type);
d5134 1
a5134 1
  copy = set_raw_breakpoint_without_location (orig->type);
d5138 1
d5161 2
a5162 1
set_momentary_breakpoint_at_pc (CORE_ADDR pc, enum bptype type)
d5171 1
a5171 1
  return set_momentary_breakpoint (sal, null_frame_id, type);
d5325 3
d5329 2
a5330 1
  loc->address = adjust_breakpoint_address (loc->requested_address, b->type);
d5354 1
a5354 1
  brk = gdbarch_breakpoint_from_pc (current_gdbarch, &addr, &len);
d5383 2
a5384 1
create_breakpoint (struct symtabs_and_lines sals, char *addr_string,
d5415 1
a5415 1
	  b = set_raw_breakpoint (sal, type);
d5614 2
a5615 1
create_breakpoints (struct symtabs_and_lines sals, char **addr_string,
d5628 1
a5628 1
      create_breakpoint (expanded, addr_string[i],
d5814 2
a5815 1
break_command_really (char *arg, char *cond_string, int thread,
d5957 1
a5957 1
      create_breakpoints (sals, addr_string, cond_string, type_wanted,
d5968 1
a5968 1
      b = set_raw_breakpoint_without_location (type_wanted);
d6009 2
a6010 1
  break_command_really (arg, 
d6022 2
a6023 1
set_breakpoint (char *address, char *condition,
d6028 2
a6029 1
  break_command_really (address, condition, thread,
d6223 1
d6379 2
a6380 1
	    = create_internal_breakpoint (frame_unwind_caller_pc (frame),
d6392 2
d6397 2
a6398 1
	    = adjust_breakpoint_address (scope_breakpoint->loc->requested_address,
d6404 1
a6404 1
  b = set_raw_breakpoint (sal, bp_type);
d6611 2
a6612 1
    breakpoint = set_momentary_breakpoint (sal, null_frame_id, bp_until);
d6616 2
a6617 1
    breakpoint = set_momentary_breakpoint (sal, get_stack_frame_id (frame),
d6629 2
a6630 1
      breakpoint2 = set_momentary_breakpoint (sal,
d6748 1
d6777 1
a6777 1
      create_fork_vfork_event_catchpoint (tempflag, cond_string,
d6782 1
a6782 1
      create_fork_vfork_event_catchpoint (tempflag, cond_string,
d6794 1
d6816 2
a6817 1
  create_catchpoint (tempflag, cond_string, &catch_exec_breakpoint_ops);
d6852 1
a6852 1
print_one_exception_catchpoint (struct breakpoint *b, CORE_ADDR *last_addr)
d6866 1
a6866 1
    *last_addr = b->loc->address;
d6908 2
a6909 1
  break_command_really (trigger_func_name, cond_string, -1,
d6969 2
a6970 1
create_ada_exception_breakpoint (struct symtab_and_line sal,
d6994 1
a6994 1
  b = set_raw_breakpoint (sal, bp_breakpoint);
d7019 1
d7035 1
a7035 1
  create_ada_exception_breakpoint (sal, addr_string, exp_string,
d7045 1
d7056 2
a7057 2
  create_ada_exception_breakpoint (sal, addr_string, NULL, NULL, NULL, ops,
                                   tempflag, from_tty);
d8324 1
a8324 1
deprecated_insert_raw_breakpoint (CORE_ADDR pc)
d8332 1
a8332 1
  if (target_insert_breakpoint (bp_tgt) != 0)
d8345 1
a8345 1
deprecated_remove_raw_breakpoint (void *bp)
d8350 1
a8350 1
  ret = target_remove_breakpoint (bp_tgt);
d8359 1
d8364 1
a8364 1
insert_single_step_breakpoint (CORE_ADDR next_pc)
d8369 4
a8372 1
    bpt_p = &single_step_breakpoints[0];
d8377 1
d8387 1
a8387 1
  *bpt_p = deprecated_insert_raw_breakpoint (next_pc);
d8402 3
a8404 1
  deprecated_remove_raw_breakpoint (single_step_breakpoints[0]);
d8409 3
a8411 1
      deprecated_remove_raw_breakpoint (single_step_breakpoints[1]);
d8446 2
a8447 1
  break_command_really (arg, 
@


1.409
log
@	* breakpoint.h (set_longjmp_breakpoint): Add THREAD argument.
	(enum bptype): Add bp_longjmp_master.

	* breakpoint.c (create_longjmp_master_breakpoint): New function.
	(update_breakpoints_after_exec): Handle bp_longjmp_master
	breakpoints.  Call create_longjmp_master_breakpoint.
	(print_it_typical, bpstat_stop_status, bpstat_what,
	print_one_breakpoint_location, allocate_bp_location, mention,
	delete_command, breakpoint_re_set_one): Handle bp_longjmp_master.
	(breakpoint_re_set): Call create_longjmp_master_breakpoint.
	(create_longjmp_breakpoint): Delete.
	(set_longjmp_breakpoint): Add THREAD argument.  Reimplement
	to install momentary clones of bp_longjmp_master breakpoints.

	* infcmd.c (step_1): Pass thread to set_longjmp_breakpoint.
@
text
@d2775 4
a2778 4
      /* There is no current frame at this moment.  If we're going to have
         any chance of handling watchpoints on local variables, we'll need
         the frame chain (so we can determine if we're in scope).  */
      reinit_frame_cache ();
d2784 10
a2793 4
      if (within_current_scope
	  && (block_linkage_function (b->exp_valid_block)
	      != get_frame_function (fr)))
	within_current_scope = 0;
d2799 6
a2804 11
	 state as `not changed' without further checking.
	 
	 vinschen/2003-09-04: The former implementation left out the case
	 that the watchpoint frame couldn't be found by frame_find_by_id()
	 because the current PC is currently in an epilogue.  Calling
	 gdbarch_in_function_epilogue_p() also when fr == NULL fixes that. */
      if (!within_current_scope || fr == get_current_frame ())
	{
	  struct frame_info *frame = get_current_frame ();
	  struct gdbarch *frame_arch = get_frame_arch (frame);
	  CORE_ADDR frame_pc = get_frame_pc (frame);
d2806 1
a2806 4
	  if (gdbarch_in_function_epilogue_p (frame_arch, frame_pc))
	    return WP_VALUE_NOT_CHANGED;
	}
      if (fr && within_current_scope)
d3040 1
a3040 1
      && !frame_id_eq (b->frame_id, get_frame_id (get_current_frame ())))
d3062 6
a3067 2
	  /* Need to select the frame, with all that implies
	     so that the conditions will have the right context.  */
d5037 5
a6152 1
  struct frame_info *prev_frame = NULL;
a6291 4
  if (frame)
    prev_frame = get_prev_frame (frame);
  else
    prev_frame = NULL;
d6297 1
a6297 1
  if (innermost_block && prev_frame)
d6299 5
a6303 2
      scope_breakpoint = create_internal_breakpoint (get_frame_pc (prev_frame),
						     bp_watchpoint_scope);
d6305 1
a6305 1
      scope_breakpoint->enable_state = bp_enabled;
d6307 2
a6308 2
      /* Automatically delete the breakpoint when it hits.  */
      scope_breakpoint->disposition = disp_del;
d6310 2
a6311 2
      /* Only break in the proper frame (help with recursion).  */
      scope_breakpoint->frame_id = get_frame_id (prev_frame);
d6313 7
a6319 6
      /* Set the address at which we will stop.  */
      scope_breakpoint->loc->requested_address
	= get_frame_pc (prev_frame);
      scope_breakpoint->loc->address
	= adjust_breakpoint_address (scope_breakpoint->loc->requested_address,
				     scope_breakpoint->type);
a6499 1
  struct frame_info *prev_frame = get_prev_frame (frame);
d6532 1
a6532 1
    /* Otherwise, specify the current frame, because we want to stop only
d6534 1
a6534 1
    breakpoint = set_momentary_breakpoint (sal, get_frame_id (frame),
d6541 2
a6542 1
  if (prev_frame)
d6544 4
a6547 3
      sal = find_pc_line (get_frame_pc (prev_frame), 0);
      sal.pc = get_frame_pc (prev_frame);
      breakpoint2 = set_momentary_breakpoint (sal, get_frame_id (prev_frame),
@


1.408
log
@2009-06-23  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	Revert 2009-05-14 breakpoint commit (no longer needed).
	* breakpoint.h (breakpoint_re_set_objfile): Remove
	* breakpoint.c (breakpoint_re_set_objfile): Likewise
	(create_overlay_event_breakpoint): Remove objfile parameter,
	iterate over all objfiles.
	* objfiles.c (objfile_relocate): Update.
	* symfile.c (new_symfile_objfile): Likewise.
@
text
@d1510 25
d1563 3
a1565 2
       as must overlay event breakpoints.  */
    if (b->type == bp_thread_event || b->type == bp_overlay_event)
d1637 4
d2459 6
d3158 2
a3159 1
    if (b->type == bp_thread_event || b->type == bp_overlay_event)
d3443 1
d3570 1
d3699 1
d4317 1
a4471 12
static void
create_longjmp_breakpoint (char *func_name)
{
  struct minimal_symbol *m;

  m = lookup_minimal_symbol_text (func_name, NULL);
  if (m == NULL)
    return;
  set_momentary_breakpoint_at_pc (SYMBOL_VALUE_ADDRESS (m), bp_longjmp);
  update_global_location_list (1);
}

d4473 1
a4473 1
   if we do a longjmp().  When we hit that breakpoint, call
d4477 1
a4477 1
set_longjmp_breakpoint (void)
d4479 13
a4491 7
  if (gdbarch_get_longjmp_target_p (current_gdbarch))
    {
      create_longjmp_breakpoint ("longjmp");
      create_longjmp_breakpoint ("_longjmp");
      create_longjmp_breakpoint ("siglongjmp");
      create_longjmp_breakpoint ("_siglongjmp");
    }
d5202 1
d7471 1
d7489 1
d7784 2
a7785 2
      /* Delete overlay event breakpoints; they will be reset later by
         breakpoint_re_set.  */
d7787 1
d7839 4
@


1.407
log
@	* breakpoint.c (expand_line_sal_maybe): When explicit_line,
	skip prologue on each sals.
	(skip_prologue_sal): Return explicit_line and explicit_pc
	unmodified.
@
text
@d1479 1
a1479 1
create_overlay_event_breakpoint (char *func_name, struct objfile *objfile)
d1481 6
a1486 2
  struct breakpoint *b;
  struct minimal_symbol *m;
d1488 3
a1490 3
  m = lookup_minimal_symbol_text (func_name, objfile);
  if (m == NULL)
    return;
d1492 3
a1494 3
  b = create_internal_breakpoint (SYMBOL_VALUE_ADDRESS (m),
				  bp_overlay_event);
  b->addr_string = xstrdup (func_name);
d1496 10
a1505 9
  if (overlay_debugging == ovly_auto)
    {
      b->enable_state = bp_enabled;
      overlay_events_enabled = 1;
    }
  else
    {
      b->enable_state = bp_disabled;
      overlay_events_enabled = 0;
a1515 1
  struct objfile *objfile;
d1610 1
a1610 2
  ALL_OBJFILES (objfile)
    create_overlay_event_breakpoint ("_ovly_debug_event", objfile);
d7777 1
a7777 5
/* Re-set all breakpoints after symbols have been re-loaded.

   If OBJFILE is non-null, create overlay break point only in OBJFILE
   (speed optimization).  Otherwise rescan all loaded objfiles.  */

d7779 1
a7779 1
breakpoint_re_set_objfile (struct objfile *objfile)
d7799 1
a7799 13
  if (objfile == NULL)
    ALL_OBJFILES (objfile)
      create_overlay_event_breakpoint ("_ovly_debug_event", objfile);
  else
    create_overlay_event_breakpoint ("_ovly_debug_event", objfile);
}

/* Re-set all breakpoints after symbols have been re-loaded.  */

void
breakpoint_re_set (void)
{
  breakpoint_re_set_objfile (NULL);
@


1.406
log
@	* dummy-frame.c (deprecated_pc_in_call_dummy): Add GDBARCH parameter,
	use it instead of current_gdbarch.
	* frame.h (deprecated_pc_in_call_dummy): Add GDBARCH parameter.
	* arm-tdep.c (arm_skip_prologue): Pass architecture to
	deprecated_pc_in_call_dummy.

	* symtab.c (skip_prologue_using_sal): Add GDBARCH parameter.
	Use it instead of current_gdbarch.
	* symtab.h (skip_prologue_using_sal): Add GDBARCH parameter.
	* breakpoint.c (expand_line_sal_maybe): Pass architecture to
	skip_prologue_using_sal.
	* arm-tdep.c (skip_prologue_using_sal): Likewise.
	* lm32-tdep.c (lm32_skip_prologue): Likewise.
	* m32-tdep.c (m32c_skip_prologue): Likewise.
	* mips-tdep.c (mips_skip_prologue): Likewise.
	* moxie-tdep.c (moxie_skip_prologue): Likewise.
	* mt-tdep.c (mt_frame_unwind_cache): Likewise.
	* rs6000-tdep.c (rs6000_skip_prologue): Likewise.
	* frv-tdep.c (frv_analyze_prologue): Add GDBARCH parameter, pass
	it to skip_prologue_using_sal.  Update call sites ...
	(frv_skip_prologue, frv_frame_unwind_cache): ... here.

	* mn10300-tdep.c (struct mn10300_prologue): Add GDBARCH member.
	(check_for_saved): Use it instead of current_gdbarch.
	(mn10300_analyze_prologue): Set it.

	* value.c (using_struct_return): Add GDBARCH parameter.  Use it
	instead of current_gdbarch.
	* value.h (using_struct_return): Add GDBARCH parameter.
	* eval.c (evaluate_subexp_standard): Pass architecture to
	using_struct_return.
	* infcall.c (call_function_by_hand): Likewise.
	* stack.c (return_command): Likewise.
	* sparc-tdep.c (sparc32_push_dummy_code): Likewise.

	* symtab.c (in_prologue): Add GDBARCH parameter.  Use it instead of
	current_gdbarch.
	* symtab.h (in_prologue): Add GDBARCH parameter.
	* infrun.c (handle_inferior_event): Pass architecture to in_prologue.

	* eval.c (evaluate_subexp_standard): Use expression architecture
	instead of current_gdbarch.

	* c-lang.c (evaluate_subexp_c): Use expression architecture and
	language instead of current_gdbarch and current_language.

	* printcmd.c (do_one_display): Use expression architecture instead
	of current_gdbarch.

	* infcmd.c (print_return_value): Use architecture of stop_regcache
	instead of current_gdbarch.
	(print_vector_info, print_float_info): Remove GDBARCH argument,
	use frame architecture instead.
	(vector_info, float_info): Update calls.

	* objc-lang.c (objc_skip_trampoline): Use frame architecture
	instead of current_gdbarch.

	* parse.c (write_dollar_variable): Use parse architecture instead
	of current_gdbarch.

	* source.c (line_info): Use objfile architecture instead of
	current_gdbarch.

	* symtab.c (find_function_start_sal): Use gdbarch instead of
	current_gdbarch.
	(print_msymbol_info): Use objfile architecture instead of
	current_gdbarch.

	* valops.c (value_assign): Use frame architecture instead of
	current_gdbarch.
@
text
@d210 3
d5442 9
d5918 2
a5919 1
   the debugging information.
d5934 5
a5938 1
    *sal = start_sal;
@


1.405
log
@	* breakpoint.c (break_command_really): Rename local variable
	breakpoint_chain to bkpt_chain.
@
text
@d5423 12
a5434 2
		    expanded.sals[i].pc 
		      = gdbarch_skip_prologue (current_gdbarch, pc);
@


1.404
log
@	* breakpoint.c: ARI fixes.
	(create_overlay_event_breakpoint): Avoid assignment inside if statement.
	(print_one_breakpoint_location): Likewise.
	(create_longjmp_breakpoint): Likewise.
	(tracepoint_save_command): Likewise
	(bpstat_find_step_resume_breakpoint): No operator at end of line.
	(bpstat_stop_status): Likewise.
	(describe_other_breakpoints): Likewise.
	(hw_watchpoint_used_count): Likewise.
	(expand_line_sal_maybe): Likewise.
	(break_command_really): Likewise.
	(delete_command): Likewise.
	(do_enable_breakpoint): Likewise.
	(delete_trace_command): Likewise.
	(catch_exception_command_1): Likewise and remove extra parentheses.
@
text
@d5691 1
a5691 1
  struct cleanup *breakpoint_chain = NULL;
d5769 2
a5770 2
     then the memory is not reclaimed. */
  breakpoint_chain = make_cleanup (null_cleanup, 0);
d5773 1
a5773 2
     the breakpoint_chain and only occure if the breakpoint create
     fails. */
d5845 4
a5848 4
  /* That's it. Discard the cleanups for data inserted into the
     breakpoint. */
  discard_cleanups (breakpoint_chain);
  /* But cleanup everything else. */
d5851 1
a5851 1
  /* error call may happen here - have BREAKPOINT_CHAIN already discarded.  */
@


1.403
log
@	* breakpoint.c (_initialize_breakpoint): Remove "bu" command alias of
	"ubreak" command that does not exist.
@
text
@d1481 2
a1482 1
  if ((m = lookup_minimal_symbol_text (func_name, objfile)) == NULL)
d2132 4
a2135 4
      if ((bsp->breakpoint_at != NULL) &&
	  (bsp->breakpoint_at->owner->type == bp_step_resume) &&
	  (bsp->breakpoint_at->owner->thread == current_thread || 
	   bsp->breakpoint_at->owner->thread == -1))
d3136 3
a3138 3
	if (bs->commands &&
	    (strcmp ("silent", bs->commands->line) == 0
	     || (xdb_commands && strcmp ("Q", bs->commands->line) == 0)))
d3751 3
a3753 2
  
  if (!part_of_multiple && (l = b->commands))
d4048 2
a4049 2
			     ((b->enable_state == bp_disabled || 
			       b->enable_state == bp_call_disabled) 
d4430 2
a4431 1
  if ((m = lookup_minimal_symbol_text (func_name, NULL)) == NULL)
d4937 3
a4939 3
	else if ((b->type == bp_hardware_watchpoint ||
		  b->type == bp_read_watchpoint ||
		  b->type == bp_access_watchpoint))
d5409 2
a5410 2
	      if (this_function && 
		  strcmp (this_function, original_function) != 0)
d5731 2
a5732 2
	  if (pending_break_support == AUTO_BOOLEAN_AUTO && 
	      !nquery ("Make breakpoint pending on future shared library load? "))
d6778 2
a6779 2
  if ((ex_event != EX_EVENT_THROW) &&
      (ex_event != EX_EVENT_CATCH))
d7402 5
a7406 5
	if (b->type != bp_call_dummy &&
	    b->type != bp_shlib_event &&
	    b->type != bp_thread_event &&
	    b->type != bp_overlay_event &&
	    b->number >= 0)
d7419 5
a7423 5
	    if (b->type != bp_call_dummy &&
		b->type != bp_shlib_event &&
		b->type != bp_thread_event &&
		b->type != bp_overlay_event &&
		b->number >= 0)
d8034 4
a8037 4
  if (bpt->type == bp_watchpoint || 
      bpt->type == bp_hardware_watchpoint ||
      bpt->type == bp_read_watchpoint || 
      bpt->type == bp_access_watchpoint)
d8372 2
a8373 2
	    if (b->type == bp_tracepoint &&
		b->number >= 0)
d8520 2
a8521 1
  if (!(fp = fopen (pathname, "w")))
@


1.402
log
@	* target.h (struct target_ops): Make to_has_all_memory,
	to_has_memory, to_has_stack, to_has_registers and to_has_execution
	methods instead of variables.
	(target_has_all_memory_1, target_has_memory_1, target_has_stack_1)
	(target_has_registers_1, target_has_execution_1): Declare
	functions.
	(target_has_all_memory): Rewrite to call target_has_all_memory_1.
	(target_has_memory): Rewrite to call target_has_memory_1.
	(target_has_stack): Rewrite to call target_has_all_stack_1.
	(target_has_registers): Rewrite to call target_has_registers_1.
	(target_has_execution): Rewrite to call target_has_execution_1.
	(default_child_has_all_memory, default_child_has_memory)
	(default_child_has_stack, default_child_has_registers)
	(default_child_has_execution): Declare.
	(target_mark_running, target_mark_exited): Delete declarations.
	* target.c (default_child_has_all_memory,
	default_child_has_memory, default_child_has_stack,
	default_child_has_registers, default_child_has_execution): New.
	(target_has_all_memory_1, target_has_memory_1, target_has_stack_1,
	target_has_registers_1, target_has_execution_1): New.
	(add_target): Default the to_has_all_memory, to_has_all_memory,
	to_has_memory, to_has_stack, to_has_registers and to_has_execution
	callbacks to return 0.
	(update_current_target): Do not inherit to_has_all_memory,
	to_has_memory, to_has_stack, to_has_registers or to_has_execution.
	(target_mark_running, target_mark_exited): Delete.
	(memory_xfer_partial): Adjust.
	(target_read_memory, target_write_memory, target_search_memory):
	Dispatch to the the top-most target, not the flattened
	current_target.
	(target_info): Adjust.
	(init_dummy_target): Install return_zero as callback for
	to_has_all_memory, to_has_memory, to_has_stack, to_has_registers,
	to_has_execution.
	(set_maintenance_target_async_permitted): Use have_live_inferiors
	instead of target_has_execution.
	* target-memory.c (target_write_memory_blocks): Dispatch memory
	writes to the the top-most target, not the flattened
	current_target.

	* breakpoint.c (insert_breakpoints): Don't check for
	target_has_execution here.
	(update_global_location_list): Check if there are live inferiors
	to debug instead of target_has_execution.
	* infcmd.c (kill_command, detach_command): Check if there are
	inferiors instead of target_has_execution.
	* inferior.h (have_live_inferiors): Declare.
	* inferior.c (have_live_inferiors): New.
	* infrun.c (normal_stop): Don't check for target_has_execution to
	finish the thread states.
	* thread.c (is_thread_state, is_stopped, is_exited, is_running)
	(any_running, is_executing): Remove checks for
	target_has_execution.
	* top.c (kill_or_detach): Don't try to kill core inferiors.
	(quit_target): Don't check for target_has_execution.

	* corelow.c (core_has_memory, core_has_stack, core_has_registers):
	New.
	(init_core_ops): Install core_has_memory, core_has_stack and
	core_has_registers.
	* exec.c (exec_has_memory): New.
	(init_exec_ops): Install exec_has_memory.
	* remote.c (remote_add_inferior): Don't call target_mark_running.
	(remote_start_remote): Don't call target_mark_exited or call
	target_mark_running.
	(remote_open_1): Use have_inferiors instead of
	target_has_execution.  Don't use target_mark_exited.
	(init_remote_ops): Install deafult_child_has_all_memory,
	default_child_has_memory, default_child_has_stack,
	default_child_has_registers, default_child_has_execution.
	* bsd-kvm.c (bsd_kvm_return_one): New.
	(bsd_kvm_add_target): Register bsd_kvm_return_one as
	to_has_memory, to_has_stack and to_has_registers callbacks.
	* remote-m32r-sdi.c (m32r_return_one): New.
	(init_m32r_ops): Register it.
	* inf-child.c (inf_child_target): Adjust to register
	default_child_has_all_memory, default_child_has_memory,
	default_child_has_stack, default_child_has_registers,
	default_child_has_execution callbacks.
	* gnu-nat.c (init_gnu_ops): Likewise.
	* go32-nat.c (init_go32_ops): Likewise.
	* hpux-thread.c (init_hpux_thread_ops): Likewise.
	* monitor.c (init_base_monitor_ops): Likewise.
	* nto-procfs.c (init_procfs_ops): Likewise.
	* remote-mips.c (_initialize_remote_mips): Likewise.
	* windows-nat.c (init_windows_ops): Likewise.
	* remote-sim.c (gdbsim_create_inferior): Don't use
	target_mark_running or target_mark_exited.
	(gdbsim_mourn_inferior): Don't call target_mark_exited.
	(init_gdbsim_ops): Adjust to register
	default_child_has_all_memory, default_child_has_memory,
	default_child_has_stack, default_child_has_registers,
	default_child_has_execution callbacks.

	* linux-nat.c (linux_nat_xfer_partial): If reading memory, and
	there's no inferior selected, defer to a lower stratum.
@
text
@d8805 2
a8806 5
 if (xdb_commands)
    {
      add_com_alias ("ba", "break", class_breakpoint, 1);
      add_com_alias ("bu", "ubreak", class_breakpoint, 1);
    }
@


1.401
log
@	* value.h (struct internalvar): Remove.
	(get_internalvar_integer): Add prototype.
	(set_internalvar_integer): Add prototype.
	(clear_internalvar): Add prototype.

	* value.c (struct internalvar): Move here.  Add type member.  Remove
	endian member.  Add union_internalvar member instead of value member.
	(init_if_undefined_command): Use intvar->type.
	(create_internalvar): Do not initialize value/endian, but type.
	(create_internalvar_type_lazy): Call create_internalvar.
	(value_of_internalvar): Handle host-side internalvar contents.
	(set_internalvar_component): Likewise.
	(set_internalvar): Likewise.
	(get_internalvar_integer): New function.
	(clear_internalvar): Likewise.
	(set_internalvar_integer): Likewise.
	(preserve_values): Handle host-side internalvar contents.

	* breakpoint.c (set_breakpoint_count, set_tracepoint_count): Call
	set_internalvar_integer instead of set_internalvar.
	* findcmd.c (find_command): Likewise.
	* infrun.c (handle_inferior_event): Likewise.
	* source.c (forward_search_command, reverse_search_command): Likewise.
	* tracepoint.c (set_traceframe_num, set_tracepoint_num,
	set_traceframe_context): Likewise.

	* printcmd.c (x_command): Call clear_internalvar instead of
	set_internalvar.
	* tracepoint.c (set_traceframe_context): Likewise.

	* breakpoint.c (get_number_trailer): Call get_internalvar_integer
	instead of value_of_internalvar.
	* linespec.c (decode_dollar): Likewise.

	* expprint.c (dump_subexp_body_standard): Use internalvar_name
	instead of accessing internalvar private elements.
	* valops.c (value_assign): Copy from original source instead of
	accessing internalvar private elements.
@
text
@d1289 4
a1292 6
  if (!breakpoints_always_inserted_mode ()
      && (target_has_execution
 	  || gdbarch_has_global_breakpoints (target_gdbarch)))
    /* update_global_location_list does not insert breakpoints
       when always_inserted_mode is not enabled.  Explicitly
       insert them now.  */
d7233 1
a7233 1
      && (target_has_execution
@


1.400
log
@2009-05-27  Tom Tromey  <tromey@@redhat.com>
	    Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* mi/mi-main.c (mi_cmd_data_evaluate_expression): Use
	value_address.
	* cli/cli-dump.c (dump_value_to_file): Use value_address.
	* valprint.c (common_val_print): Likewise.
	* v850-tdep.c (v850_push_dummy_call): Use value_address.
	* tracepoint.c (encode_actions): Use value_address.
	* printcmd.c (print_formatted): Use value_address.
	(x_command): Likewise.
	* p-valprint.c (pascal_object_print_static_field): Use
	value_address.
	* mn10300-tdep.c (mn10300_push_dummy_call): Use value_address.
	* mips-tdep.c (mips_eabi_push_dummy_call): Use value_address.
	* m32r-tdep.c (m32r_push_dummy_call): Use value_address.
	* jv-valprint.c (java_value_print): Use value_address.
	* infcall.c (find_function_addr): Use value_address.
	* gnu-v3-abi.c (gnuv3_rtti_type): Use value_address.
	* gnu-v2-abi.c (gnuv2_value_rtti_type): Use value_address.
	* frv-tdep.c (frv_push_dummy_call): Use value_address.
	* frame.c (frame_register_unwind): Use value_address.
	(frame_unwind_register_value): Likewise.
	* darwin-nat-info.c (info_mach_region_command): Use
	value_address.
	* cp-valprint.c (cp_print_static_field): Use value_address.
	* c-valprint.c (c_value_print): Use value_address.
	* breakpoint.c (update_watchpoint): Use value_address.
	(can_use_hardware_watchpoint): Likewise.
	* ada-valprint.c (ada_val_print_1): Use value_address.
	(ada_value_print): Likewise.
	* ada-tasks.c (read_fat_string_value): Use value_address.
	* jv-lang.c (java_link_class_type): Use set_value_address.
	(java_link_class_type): Likewise.
	(get_java_utf8_name): Use value_address.
	(type_from_class): Likewise.
	(java_link_class_type): Likewise.
	* findvar.c (value_of_register): Use set_value_address.
	(read_var_value): Likewise.
	(read_var_value): Likewise.
	* eval.c (evaluate_subexp_standard): Use set_value_address.
	(evaluate_subexp_standard): Use value_address.
	* dwarf2loc.c (dwarf2_evaluate_loc_desc): Use set_value_address.
	* ada-lang.c (coerce_unspec_val_to_type): Use set_value_address.
	(ada_value_primitive_packed_val): Likewise.
	(ensure_lval): Likewise.
	(thin_data_pntr): Use value_address.
	(desc_bounds): Likewise.
	(ada_value_primitive_packed_val): Likewise.
	(value_assign_to_component): Likewise.
	(ensure_lval): Likewise.
	(make_array_descriptor): Likewise.
	(ada_to_fixed_value): Likewise.
	(unwrap_value): Likewise.
	* value.c (deprecated_value_address_hack): Remove.
	(value_address): New function.
	(value_raw_address): Likewise.
	(set_value_address): Likewise.
	(value_fn_field): Use set_value_address.
	(value_from_contents_and_address): Likewise.
	(value_fn_field): Likewise.
	(allocate_value_lazy): Don't use VALUE_ADDRESS.
	(value_as_address): Use value_address.
	(value_static_field): Likewise.
	* valops.c (search_struct_field): Use set_value_address.
	(value_at): Likewise.
	(value_at_lazy): Likewise.
	(value_repeat): Likewise.
	(value_cast_structs): Use value_address.
	(value_cast): Likewise.
	(value_fetch_lazy): Likewise.
	(value_assign): Likewise.
	(value_repeat): Likewise.
	(address_of_variable): Likewise.
	(value_coerce_array): Likewise.
	(value_coerce_function): Likewise.
	(value_addr): Likewise.
	(search_struct_field): Likewise.
	(search_struct_method): Likewise.
	(find_method_list): Likewise.
	(value_struct_elt_for_reference): Likewise.
	(value_full_object): Likewise.
	* jv-valprint.c (java_value_print): Use set_value_address.
	* value.h (deprecated_value_address_hack): Remove.
	(VALUE_ADDRESS): Remove.
	(value_address): Declare.
	(value_raw_address): Declare.
	(set_value_address): Declare.
@
text
@d371 1
a371 2
  set_internalvar (lookup_internalvar ("bpnum"),
		   value_from_longest (builtin_type_int32, (LONGEST) num));
d423 1
a423 1
      struct value *val;
d430 2
a431 3
      val = value_of_internalvar (lookup_internalvar (varname));
      if (TYPE_CODE (value_type (val)) == TYPE_CODE_INT)
	retval = (int) value_as_long (val);
d8276 1
a8276 2
  set_internalvar (lookup_internalvar ("tpnum"),
		   value_from_longest (builtin_type_int32, (LONGEST) num));
@


1.399
log
@gdb/
	* gdbthread.h (struct thread_info): New `pending_follow' field.
	* thread.c (new_thread): New function.
	(add_thread_silent): Use it.
	* breakpoint.c (internal_breakpoint_number): New global, moved
	from inside...
	(create_internal_breakpoint): ... this.
	(clone_momentary_breakpoint): New.
	* breakpoint.h (clone_momentary_breakpoint): Declare.
	* infrun.c (nullify_last_target_wait_ptid): Move declaration
	higher.
	(pending_follow): Delete.
	(follow_fork): Handle pending follow fork event here.  Moved the
	preserving of thread stepping state here.
	(resume): Don't handle pending follow fork events here.  Only
	install the inferior's terminal modes if we're about to resume it.
	(proceed): Handle possible pending follow fork events here.
	(init_wait_for_inferior): No need to clear pending_follow anymore,
	it's gone.
	(handle_inferior_event): Adjust to per-thread `pending_follow'.
	Call `follow_fork' to handle following the fork.  If the
	follow-fork is cancelled, stop stepping.
	* linux-nat.c (linux_child_follow_fork): Adjust to per-thread
	`pending_follow' events.  Remove code that handled preserving the
	thread stepping state.
	* inf-ptrace.c (inf_ptrace_follow_fork): Ditto.
	* inf-ttrace.c (inf_ttrace_follow_fork): Ditto.

gdb/testsuite/
	* gdb.threads/fork-thread-pending.c: New.
	* gdb.threads/fork-thread-pending.exp: New.
@
text
@d995 1
a995 1
		  addr = VALUE_ADDRESS (v) + value_offset (v);
d6342 1
a6342 1
		  CORE_ADDR vaddr = VALUE_ADDRESS (v) + value_offset (v);
@


1.398
log
@gdb/
	Replace the savestring calls by xstrdup calls where possible.
	* breakpoint.c (condition_command, set_raw_breakpoint)
	(create_catchpoint, update_breakpoint_locations): Replace the
	savestring calls by xstrdup calls where possible.
	* buildsym.c (start_subfile, patch_subfile_names, record_debugformat)
	(record_producer): Likewise.
	* coffread.c (coff_start_symtab, complete_symtab): Likewise.
	* corefile.c (set_gnutarget): Likewise.
	* dbxread.c (add_new_header_file): Likewise.
	* demangle.c (set_demangling_command, set_demangling_style): Likewise.
	* event-top.c (push_prompt, pop_prompt, command_line_handler)
	(set_async_prompt): Likewise.
	* infcmd.c (set_inferior_io_terminal, attach_command_post_wait):
	Likewise.
	* language.c (set_language_command, _initialize_language): Likewise.
	* linespec.c (decode_line_2): Likewise.
	* rs6000-nat.c (add_vmap): Likewise.
	* top.c (set_prompt, init_history, init_main): Likewise.
	* tracepoint.c (stringify_collection_list): Likewise.
	* varobj.c (varobj_create): Remove variable expr_len.  Replace the
	savestring calls by xstrdup calls where possible.
	(value_of_root, c_name_of_variable, c_describe_child): Replace the
	savestring calls by xstrdup calls where possible.
	* xcoffread.c (complete_symtab): Likewise.
	* cli/cli-script.c (build_command_line, define_command): Likewise.
	* cli/cli-setshow.c (do_setshow_command): Likewise.
@
text
@d1459 2
a1463 1
  static int internal_breakpoint_number = -1;
d5011 37
@


1.397
log
@	* breakpoint.c (insert_breakpoints, breakpoint_init_inferior)
	(update_global_location_list): Use gdbarch_has_global_breakpoints
	instead of gdbarch_has_global_solist and
	target_supports_multi_process.
	* dicos-tdep.c (dicos_init_abi): Set
	gdbarch_has_global_breakpoints.
	* gdbarch.sh (has_global_solist): Update comment.
	(has_global_breakpoints): New.
	* remote.c (remote_start_remote): Use
	gdbarch_has_global_breakpoints instead of
	gdbarch_has_global_solist.
	* target.c (target_detach): Use gdbarch_has_global_breakpoints
	instead of gdbarch_has_global_solist.
	* infcmd.c (attach_command): Use gdbarch_has_global_solist instead
	of target_supports_multi_process.
@
text
@d600 1
a600 1
	    b->cond_string = savestring (arg, strlen (arg));
d4397 1
a4397 2
    b->source_file = savestring (sal.symtab->filename,
				 strlen (sal.symtab->filename));
d4818 1
a4818 2
  b->cond_string = (cond_string == NULL) ? 
    NULL : savestring (cond_string, strlen (cond_string));
d7491 1
a7491 3
	b->source_file =
	  savestring (sals.sals[i].symtab->filename,
		      strlen (sals.sals[i].symtab->filename));
@


1.396
log
@2009-05-14  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* breakpoint.h: Add breakpoint_re_set_objfile prototype.
	* breakpoint.c (create_overlay_event_breakpoint): Renamed
	from create_overlay_event_breakpoint_1, old
	create_overlay_event_breakpoint deleted.
	(breakpoint_re_set_objfile): Don't rescan all objfiles
	unnecessarily.
	(breakpoint_re_set): New function.
	* symfile.c (new_symfile_objfile): Call breakpoint_re_set_objfile
	instead of breakpoint_re_set.
	* objfiles.c (objfile_relocate): Likewise.
@
text
@d1293 1
a1293 2
 	  || (gdbarch_has_global_solist (target_gdbarch)
	      && target_supports_multi_process ())))
d1782 1
a1782 1
  if (gdbarch_has_global_solist (target_gdbarch))
d7202 1
a7202 2
	  || (gdbarch_has_global_solist (target_gdbarch)
	      && target_supports_multi_process ())))
@


1.395
log
@gdb/
	Fix internal error on breaking at a multi-locations caller source line.
	* breakpoint.c (parse_breakpoint_sals): Set EXPLICIT_PC for the `break'
	command with no parameters.

gdb/testsuite/
	* gdb.cp/expand-sals.exp, gdb.cp/expand-sals.cc: New.
@
text
@a152 2
static void create_overlay_event_breakpoint (char *);

d1460 45
d1511 1
d1606 2
a1607 1
  create_overlay_event_breakpoint ("_ovly_debug_event");
a4427 20
static struct breakpoint *
create_internal_breakpoint (CORE_ADDR address, enum bptype type)
{
  static int internal_breakpoint_number = -1;
  struct symtab_and_line sal;
  struct breakpoint *b;

  init_sal (&sal);		/* initialize to zeroes */

  sal.pc = address;
  sal.section = find_pc_overlay (sal.pc);

  b = set_raw_breakpoint (sal, type);
  b->number = internal_breakpoint_number--;
  b->disposition = disp_donttouch;

  return b;
}


a4468 34
static void
create_overlay_event_breakpoint_1 (char *func_name, struct objfile *objfile)
{
  struct breakpoint *b;
  struct minimal_symbol *m;

  if ((m = lookup_minimal_symbol_text (func_name, objfile)) == NULL)
    return;
 
  b = create_internal_breakpoint (SYMBOL_VALUE_ADDRESS (m), 
				  bp_overlay_event);
  b->addr_string = xstrdup (func_name);

  if (overlay_debugging == ovly_auto)
    {
      b->enable_state = bp_enabled;
      overlay_events_enabled = 1;
    }
  else 
    {
      b->enable_state = bp_disabled;
      overlay_events_enabled = 0;
    }
  update_global_location_list (1);
}

static void
create_overlay_event_breakpoint (char *func_name)
{
  struct objfile *objfile;
  ALL_OBJFILES (objfile)
    create_overlay_event_breakpoint_1 (func_name, objfile);
}

d7717 5
a7721 1
/* Re-set all breakpoints after symbols have been re-loaded.  */
d7723 1
a7723 1
breakpoint_re_set (void)
d7742 14
a7755 2
  
  create_overlay_event_breakpoint ("_ovly_debug_event");
@


1.394
log
@	Unify target macros.

	* target.h (STOPPED_BY_WATCHPOINT): Delete, replaced by ...
	(target_stoppped_by_watchpoint): New macro.
	(HAVE_STEPPABLE_WATCHPOINT): Delete, replaced by ...
	(target_have_steppable_watchpoint): New macro.
	(HAVE_CONTINUABLE_WATCHPOINT): Delete, replace by ...
	(target_have_continuable_watchpoint): New macro.
	(TARGET_CAN_USE_HARDWARE_WATCHPOINT):Delete, replaced by ...
	(target_can_use_hardware_watchpoint): New macro.
	(TARGET_REGION_OK_FOR_HW_WATCHPOINT):Delete, replaced by ...
	(target_region_ok_for_hw_watchpoint): New macro.

	* breakpoint.c (update_watchpoint): Use new macros.
	(bpstat_alloc): Likewise.
	(create_breakpoint): Likewise.
	(watch_command_1): Likewise.
	(can_use_hardware_watchpoint): Likewise.
	(do_enable_breakpoint): Likewise.
	* infrun.c (handle_inferior_event): Adapt to new macros.
	* mips-tdep.c (mips_gdbarch_init): Update comments.
	* procfs.c (procfs_set_watchpoint): Update comment.
	(procfs_insert_watchpoint): Adapt to new macros.
	* remote-m32r-sdi.c (m32r_stop):
	* remote-mips.c (mips_remove_breakpoint):
	* target.c (debug_to_region_ok_for_hw_watchpoint): Update to new macros.
	(debug_to_stopped_by_watchpoint): Likewise.
@
text
@d5497 8
@


1.393
log
@	* inferior.h (read_pc, write_pc): Remove.
	* regcache.c (read_pc, write_pc): Remove.

	* infrun.c (displaced_step_fixup): Use regcache_read_pc instead
	of read_pc.
	(handle_inferior_event): Use regcache_read_pc instead of read_pc
	when determining value of stop_pc.  Replace subsequent uses of
	read_pc by inspecting already-retrieved stop_pc value.
	(keep_going): Use regcache_read_pc instead of read_pc.

	* breakpoint.c (watchpoint_check): Use current frame architecture
	and PC instead of current_gdbarch and read_pc ().
	* tracepoint.c (set_traceframe_context): Replace PC argument
	with FRAME argument.
	(trace_start_command, finish_tfind_command): Update calls.
	(finish_tfind_command): Compare frame IDs to identify transitions
	between frames.
	(trace_find_pc_command): Use regcache_read_pc instead of read_pc.
	* rs6000-nat.c (exec_one_dummy_insn): Pass in regcache instead
	of gdbarch.  Use regcache_read_pc and regcache_write_pc instead
	of read_pc and write_pc.
	(store_register): Make regcache argument non-const.  Update call
	to exec_one_dummy_insn.

	* thread.c (switch_to_thread): Use regcache_read_pc instead of read_pc.
	* infcmd.c (post_create_inferior): Likewise.
	* solib-darwin.c (darwin_solib_create_inferior_hook): Likewise.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Likewise.
	* solib-sunos.c (sunos_solib_create_inferior_hook): Likewise.
	* solib-svr4.c (enable_break, svr4_relocate_main_executable): Likewise.
	* linux-fork.c (fork_load_infrun_state): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_push_dummy_code): Likewise.
	* record.c (record_wait): Likewise.
	* procfs.c (procfs_wait): Likewise.
	* remote-mips.c (common_open, mips_wait): Likewise.
	* remote-m32r-sdi.c (m32r_resume): Likewise.

	* symfile.c (generic_load): Use regcache_write_pc instead of write_pc.
	* monitor.c (monitor_create_inferior, monitor_load): Likewise.
	* m32r-rom.c (m32r_load, m32r_upload_command): Likewise.
	* remote-m32r-sdi.c (m32r_create_inferior, m32r_load): Likewise.
	* remote-mips.c (mips_create_inferior, mips_load): Likewise.

	* solib-darwin.c: Include "regcache.h".
	* solib-pa64.c: Include "regcache.h".
	* solib-svr4.c: Include "regcache.h.".

	* symfile.c: Do not mention read_pc or write_pc in comments.
	* dink32-rom.c: Likewise.
	* m32r-rom.c: Likewise.
	* mips-tdep.c: Likewise.
@
text
@d964 1
a964 1
		int target_resources_ok = TARGET_CAN_USE_HARDWARE_WATCHPOINT
d2605 1
a2605 1
  int stopped_by_watchpoint = STOPPED_BY_WATCHPOINT (*ws);
d5252 1
a5252 1
	TARGET_CAN_USE_HARDWARE_WATCHPOINT (bp_hardware_breakpoint, 
d6173 1
a6173 1
	TARGET_CAN_USE_HARDWARE_WATCHPOINT (bp_type, i + mem_cnt, 
d6311 1
a6311 1
		  if (!TARGET_REGION_OK_FOR_HW_WATCHPOINT (vaddr, len))
d7980 1
a7980 1
	TARGET_CAN_USE_HARDWARE_WATCHPOINT (bp_hardware_breakpoint, 
@


1.392
log
@	* breakpoint.c (print_exception_catchpoint): Access `b' directly
	instead of `b->loc->owner'.
	(print_mention_exception_catchpoint): Ditto.
@
text
@d2715 9
a2723 3
      if ((!within_current_scope || fr == get_current_frame ())
          && gdbarch_in_function_epilogue_p (current_gdbarch, read_pc ()))
	return WP_VALUE_NOT_CHANGED;
@


1.391
log
@gdb/
	Fix double free on error inserting the breakpoint instruction.
	* breakpoint.c (create_breakpoints): Move the
	update_global_location_list call to ...
	(break_command_really): ... here together with the second local call
	both unified after all the cleanups.
@
text
@d6634 1
a6634 1
  bp_temp = b->loc->owner->disposition == disp_del;
d6681 1
a6681 1
  bp_temp = b->loc->owner->disposition == disp_del;
@


1.390
log
@        Provide support for (Ada) task-specific breakpoints.

        * ada-lang.h (ada_get_task_number): Add declaration.
        (breakpoint_ada_task_match): Delete declaration.
        * ada-tasks.c (ada_get_task_number): Make non-static.
        * breakpoint.h (struct breakpoint): Add field "task".
        * breakpoint.c (print_one_breakpoint_location): Add handling of
        task-specific breakpoints.
        (create_breakpoint, create_breakpoints, find_condition_and_thread):
        New parameter "task".
        (break_command_really): Update calls to find_condition_and_thread
        and create_breakpoints.
        (breakpoint_re_set_one): Update call to find_condition_and_thread.
        Set b->task.
@
text
@a5460 2

  update_global_location_list (1);
a5800 1
      update_global_location_list (1);
d5812 3
@


1.389
log
@2009-03-30  Stan Shebs  <stan@@codesourcery.com>

	Make tracepoints into a type of breakpoint.
	* breakpoint.h (enum bptype): Add bp_tracepoint.
	(struct breakpoint): Add fields step_count, pass_count, actions.
	(get_tracepoint, get_tracepoint_by_number): Declare.
	(all_tracepoints): Declare.
	* breakpoint.c: Include tracepoint.h, readline.h.
	(ALL_TRACEPOINTS): Move here from tracepoint.c.
	(tracepoint_count): Ditto.
	(should_be_inserted): GDB does not insert tracepoints itself.
	(print_it_typical): Add tracepoint case.
	(bpstat_what): Ditto.
	(print_one_breakpoint_location): Ditto, and add printing for
	pass count, step count, and action list.
	(user_settable_breakpoint): Add tracepoint case.
	(allocate_bp_location): Ditto.
	(set_breakpoint_location_function): Ditto.
	(disable_breakpoints_in_shlibs): Ditto.
	(mention): Ditto.
	(break_command_really): Add argument traceflag, use to choose
	basic breakpoint type.
	(break_command_1): Pass extra argument.
	(set_breakpoint, handle_gnu_v3_exceptions): Ditto.
	(breakpoint_re_set_one): Add tracepoint case.
	(disable_command, enable_command): Ditto.
	(set_tracepoint_count): Move here from tracepoint.c.
	(trace_command): Move here from tracepoint.c and use
	break_command_really.
	(tracepoints_info): Move here from tracepoint.c and call
	breakpoints_info.
	(enable_trace_command): Move here from tracepoint.c and call
	enable_command.
	(disable_trace_command): Move here from tracepoint.c and call
	disable_command.
	(delete_trace_command): Move here from tracepoint.c and call
	delete_breakpoint.
	(trace_pass_command): Move here from tracepoint.c.
	(get_tracepoint_by_number): Ditto.
	(tracepoint_save_command): Ditto.
	(get_tracepoint): New function.
	(all_tracepoints): New function.
	(_initialize_breakpoint): Move tracepoint init from tracepoint.c,
	deprecate "enable trace" and "disable trace" commands.
	* tracepoint.h (struct tracepoint): Remove.
	(tracepoint_chain): Remove decl.
	(deprecated_create_tracepoint_hook): Remove decl.
	(deprecated_delete_tracepoint_hook): Remove decl.
	(deprecated_modify_tracepoint_hook): Remove decl.
	(ALL_TRACEPOINTS, ALL_TRACEPOINTS_SAFE): Remove.
	(free_actions): Update signature.
	(validate_actionline): Update signature.
	(end_actions_pseudocommand): Declare.
	(while_stepping_pseudocommand): Declare.
	* tracepoint.c: Include breakpoint.h.
	(tracepoint_chain, tracepoint_count): Remove.
	(free_actions, make_cleanup_free_actions): Update signature.
	(trace_command, set_raw_tracepoint): Remove.
	(trace_mention): Remove.
	(tracepoints_info): Remove.
	(tracepoint_operation, map_args_over_tracepoints): Remove.
	(get_tracepoint_by_number): Remove.
	(enable_trace_command, disable_trace_command): Remove.
	(delete_trace_command, trace_pass_command): Remove.
	(trace_actions_command, read_actions): Update signature.
	(validate_actionline): Update signature, use bp loc.
	(encode_actions): Ditto.
	(download_tracepoint): New function, body of trace_start_command.
	(trace_start_command): Call it, use all_tracepoints.
	(tracepoint_save_command): Remove.
	(tracepoint_dump_command): Use get_tracepoint.
	(end_actions_pseudocommand): Make globally visible.
	(while_stepping_pseudocommand): Ditto.
	(_initialize_tracepoint): Move command definitions to breakpoint.c.

	doc/
	* gdb.texinfo (Tracepoints): Describe tracepoints as a
	special case of breakpoints.
	(Enable and Disable Tracepoints): Mention deprecation.
	(Listing Tracepoints): Update description and example.

	testsuite/
	* gdb.trace/actions.exp: Update to match new info trace format.
	* gdb.trace/deltrace.exp: Ditto.
	* gdb.trace/infotrace.exp: Ditto.
	* gdb.trace/passcount.exp: Ditto.
	* gdb.trace/save-trace.exp: Ditto.
	* gdb.trace/while-stepping.exp: Ditto.
	* gdb.trace/tracecmd.exp: Ditto, plus don't allow pending option.

	gdbtk/
	* generic/gdbtk-bp.c (gdb_actions_command): Update to handle
	tracepoints as breakpoints.
	(gdb_get_tracepoint_info): Ditto, plus use get_tracepoint and
	breakpoint locations.
	(tracepoint_exists): Ditto, plus use all_tracepoints.
@
text
@d1929 1
a1929 1
  /* The thread ID associated to PTID, computed lazily.  */
d1931 1
d1957 11
d3625 1
a3625 1
  if (!part_of_multiple && b->thread != -1)
d3627 12
a3638 4
      /* FIXME: This seems to be redundant and lost here; see the
	 "stop only in" line a little further down. */
      ui_out_text (uiout, " thread ");
      ui_out_field_int (uiout, "thread", b->thread);
d5236 1
a5236 1
		   int thread, int ignore_count, 
d5268 1
d5447 1
a5447 1
		    int thread, int ignore_count, 
d5459 1
a5459 1
			 thread, ignore_count, ops, from_tty, enabled);
d5566 1
a5566 1
			   char **cond_string, int *thread)
d5609 12
d5660 1
d5766 2
a5767 1
            find_condition_and_thread (arg, sals.sals[0].pc, &cond_string, &thread);
d5782 1
a5782 1
			  thread, ignore_count, ops, from_tty, enabled);
d7625 2
d7628 1
a7628 1
				     &cond_string, &thread);
d7632 1
@


1.388
log
@gdb
	* breakpoint.c (resolve_sal_pc): Preserve original line number
	when skipping prologue.
gdb/testsuite
	Update for change to prologue skipping:
	* gdb.mi/mi2-simplerun.exp: Update.
	* gdb.mi/mi2-break.exp: Update.
	* gdb.mi/mi-simplerun.exp: Update.
	* gdb.mi/mi-break.exp: Update.
	* gdb.base/ending-run.exp: Update.
@
text
@d28 1
d62 7
d202 10
d335 6
d356 4
d1060 5
d2459 1
d3361 7
d3467 1
d3594 1
d3639 4
a3642 1
      ui_out_text (uiout, "\tstop only if ");
d3694 28
d3812 1
d4191 1
d4281 2
a4282 1
      || loc->owner->type == bp_hardware_breakpoint)
d4557 3
a4559 1
    if (((b->type == bp_breakpoint) || (b->type == bp_hardware_breakpoint))
d5089 10
d5606 1
a5606 1
		      int tempflag, int hardwareflag, 
d5626 1
d5715 4
d5745 1
a5745 3
      create_breakpoints (sals, addr_string, cond_string,
			  hardwareflag ? bp_hardware_breakpoint 
			  : bp_breakpoint,
d5756 1
a5756 3
      b = set_raw_breakpoint_without_location (hardwareflag 
					       ? bp_hardware_breakpoint 
					       : bp_breakpoint);
d5797 1
a5797 1
			tempflag, hardwareflag,
d5814 1
a5814 1
			tempflag, hardwareflag,
d6677 1
a6677 1
			tempflag, 0,
d7537 1
d7903 1
d7996 1
d8180 318
d8560 2
d8891 52
@


1.387
log
@        * breakpoint.c (breakpoint_thread_match): Split a large condition
        into several smaller conditions.  No behavior change.
@
text
@d5768 6
a5773 1
        skip_prologue_sal (sal);
@


1.386
log
@2009-03-23  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* breakpoint.c (disable_breakpoints_in_unloaded_shlib): Use
	solib_contains_address_p instead of searching.
@
text
@d1896 3
a1898 4
  int thread;

  thread = pid_to_thread_id (ptid);

d1905 16
a1920 11
      if ((breakpoint_enabled (bpt->owner)
	   || bpt->owner->enable_state == bp_permanent)
	  && bpt->address == pc
	  && (bpt->owner->thread == -1 || bpt->owner->thread == thread))
	{
	  if (overlay_debugging 
	      && section_is_overlay (bpt->section) 
	      && !section_is_mapped (bpt->section))
	    continue;		/* unmapped overlay -- can't be a match */
	  else
	    return 1;
d1922 7
@


1.385
log
@gdb/

	* mi/mi-interp.c (mi_interpreter_init): Attach mi_about_to_proceed
	to the about_to_proceed observer notification.
	(mi_about_to_proceed): New.
	(mi_on_resume): Only output ^running and the prompt here if the
	target was proceeded.
	* breakpoint.c (breakpoint_proceeded): New static.
	(breakpoint_about_to_proceed): New.
	(_initialize_breakpoints): Attach breakpoint_about_to_proceed to
	the about_to_proceed observer notification.
	* inferior.h (breakpoint_proceeded): Delete declaration.
	* infrun.c (clear_proceed_status): Don't set breakpoint_proceeded.
	Notify the about_to_proceed observers.
	(struct inferior_status): Delete breakpoint_proceeded member.
	(save_inferior_status): Don't save it.
	(restore_inferior_status): Don't restore it.
	* mi-main.h (mi_proceeded): Declare.
	* mi/mi-main.c (mi_cmd_execute): Clear mi_proceeded before running
	a command.

gdb/doc/

	* observer.texi (about_to_proceed): New.
@
text
@d4505 3
a4507 1
	&& !loc->shlib_disabled)
d4509 10
a4518 19
#ifdef PC_SOLIB
	char *so_name = PC_SOLIB (loc->address);
#else
	char *so_name = solib_name_from_address (loc->address);
#endif
	if (so_name && !strcmp (so_name, solib->so_name))
          {
	    loc->shlib_disabled = 1;
	    /* At this point, we cannot rely on remove_breakpoint
	       succeeding so we must mark the breakpoint as not inserted
	       to prevent future errors occurring in remove_breakpoints.  */
	    loc->inserted = 0;
	    if (!disabled_shlib_breaks)
	      {
		target_terminal_ours_for_output ();
		warning (_("Temporarily disabling breakpoints for unloaded shared library \"%s\""),
			  so_name);
	      }
	    disabled_shlib_breaks = 1;
d4520 1
@


1.384
log
@	* breakpoint.c (bpstat_should_step): Only consider software
	watchpoints that have a location.
@
text
@d194 5
d2091 20
d8526 2
@


1.383
log
@	* breakpoint.c (bpstat_check_breakpoint_conditions): Use
	value_mark and value_free_to_mark.
	* objfiles.c (free_objfile): Call objfile_free_data before
	freeing the BFD.
@
text
@d3307 1
a3307 1
    if (breakpoint_enabled (b) && b->type == bp_watchpoint)
@


1.382
log
@2009-03-06  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	Rename solib_address to solib_name_from_address.
	* breakpoint.c (insert_bp_location, disable_breakpoints_in_shlibs)
	(disable_breakpoints_in_unloaded_shlib): Update.
	* printcmd.c (display_uses_solib_p): Likewise.
	* stack.c (print_frame): Likewise.
	* solib.c: Rename.
	* solib.h: Rename.
@
text
@d2885 7
d2900 1
a2900 1
	  free_all_values ();
@


1.381
log
@gdb/
2009-03-05  Pedro Alves  <pedro@@codesourcery.com>

	* breakpoint.c (check_duplicates_for): Skip permanent breakpoints
	duplicates of permanent breakpoints.

gdb/testsuite/
2009-03-05  Pedro Alves  <pedro@@codesourcery.com>

	* gdb.arch/i386-permbkpt.S, gdb.arch/i386-permbkpt.exp: New.
@
text
@d1163 1
a1163 1
	  if (solib_address (bpt->address))
d1632 1
a1632 1
      if (val && solib_address (b->address))
d4442 1
a4442 1
	&& solib_address (loc->address)
d4478 1
a4478 1
	char *so_name = solib_address (loc->address);
@


1.380
log
@	* breakpoint.c (insert_bp_location): Add \n to overlay breakpoint
	error message.
@
text
@d3951 2
a3952 2
     list again and declare all the other breakpoints there to be the
     duplicates.  */
d3966 2
a3967 1
	    if (b->owner->enable_state != bp_disabled
@


1.379
log
@	* breakpoint.c (disable_breakpoints_in_shlibs): Delete local
	disabled_shlib_breaks, unused.
@
text
@d1138 2
a1139 2
		    fprintf_unfiltered (tmp_error_stream, 
					"Overlay breakpoint %d failed: in ROM?", 
@


1.378
log
@2008-02-21  Pedro Alves  <pedro@@codesorcery.com>

	Silence a few -Wmissing-prototypes warnings.

	PR build/9877:
	* amd64-nat.c: Include "amd64-nat.h".
	* fork-child.c (_initialize_fork_child): Ditto.
	* gcore.c (_initialize_gcore): Ditto.
	* inf-ptrace.c: Include "inf-ptrace.h".
	(inf_ptrace_store_registers): Make it static.
	* linux-nat.c (linux_nat_terminal_ours): Make it static.
	(_initialize_linux_nat): Declare before definition.
	* linux-tdep.c: Include "linux-tdep.h".
	* linux-thread-db.c (_initialize_thread_db): Declare before
	definition.
	* proc-service.c (_initialize_proc_service): Ditto.
	* remote.c (remote_send_printf): Make it static.
	* solib.c: Include "solib.h".
	* symfile-mem.c (_initialize_symfile_mem): Declare before
	definition.
	* ada-lang.c (ada_la_decode, ada_match_name)
	(ada_suppress_symbol_printing, ada_is_array_type)
	(ada_value_ptr_subscript, ada_array_length)
	(ada_to_static_fixed_value): Make them static.
	(_initialize_ada_language): Declare before definition.
	* ada-tasks.c (ada_get_task_number, ada_get_environment_task)
	(ada_task_list_changed, ada_new_objfile_observer): Make them
	static.
	(_initialize_tasks): Declare before definition.
	* addrmap.c (_initialize_addrmap): Declare before definition.
	* auxv.c (default_auxv_parse): Make it static.
	* bfd-target.c (target_bfd_xfer_partial, target_bfd_xclose): Make
	them static.
	* breakpoint.c (remove_sal): Add line break.
	(expand_line_sal_maybe): Make it static.
	* cp-name-parser.y: Include "cp-support.h".
	* cp-valprint.c (cp_find_class_member): Make it static.
	* eval.c (value_f90_subarray): Ditto.
	* exceptions.c (print_any_exception): Ditto.
	* findcmd.c (_initialize_mem_search): Declare before definition.
	* frame.c (frame_observer_target_changed): Make it static.
	* gnu-v3-abi.c (gnuv3_find_method_in): Make it static.
	* inf-child.c: Include "inf-child.h".
	* inferior.h (valid_inferior_id): Rename to ...
	(valid_gdb_inferior_id): ... this.
	* infrun.c (infrun_thread_stop_requested, siginfo_make_value):
	Make them static.
	* jv-lang.c (java_language_arch_info): Make it static.
	* m2-typeprint.c (m2_get_discrete_bounds): Ditto.
	* osdata.c (info_osdata_command): Make it static.
	* regcache.c (regcache_observer_target_changed): Make it static.
	* reverse.c (_initialize_reverse): Declare before definition.
	* stabsread.c (cleanup_undefined_types_noname)
	(cleanup_undefined_types_1): Make them static.
	* symfile.c (place_section): Make it static.
	* symtab.c (find_pc_sect_psymtab_closer): Make it static.
	* target-descriptions.c (_initialize_target_descriptions): Declare
	before definition.
	* target.c (default_get_ada_task_ptid, find_default_can_async_p)
	(find_default_is_async_p, find_default_supports_non_stop): Make
	them static.
	(target_supports_non_stop): Add prototype.
	(dummy_pid_to_str): Make it static.
	* utils.c (_initialize_utils): Declare before definition.
	* ada-exp.y (_initialize_ada_exp): Declare before definition.
	* solib-svr4.c (HAS_LM_DYNAMIC_FROM_LINK_MAP): Add a prototype.
	* target.h (struct target_ops): Add a prototype to the
	to_can_execute_reverse callback.
	* macroscope.c (_initialize_macroscope): Declare before definition.
	* cp-namespace.c (_initialize_cp_namespace): Declare before definition.
	* python/python.c (_initialize_python): Declare before definition.
	* tui/tui-command.c: Include "tui/tui-command.h".
	* tui/tui-data.c (init_content_element, init_win_info): Make them
	static.
	* tui/tui-disasm.c: Include "tui/tui-disasm.h".
	* tui/tui-interp.c (_initialize_tui_interp): Declare before
	definition.
	* tui/tui-layout.c: Include "tui/tui-layout.h".
	(_initialize_tui_layout): Declare before definition.
	* tui/tui-regs.c: Include "tui/tui-regs.h".
	(tui_display_reg_element_at_line): Make it static.
	(_initialize_tui_regs): Declare before definition.
	* tui/tui-stack.c (_initialize_tui_stack): Declare before
	definition.
	* tui/tui-win.c: Include "tui/tui-win.h".
	(_initialize_tui_win): Declare before definition.
	(tui_sigwinch_handler): Make it static.  Wrap in ifdef SIGWINCH.
	* tui/tui-win.h (tui_sigwinch_handler): Delete declaration.
	(tui_get_cmd_list): Add a prototype.
	* tui/tui-windata.c: Include tui-windata.h.
	* tui/tui-wingeneral.c (box_win): Make it static.
	* cli/cli-logging.c (show_logging_command): Make it static.
	(_initialize_cli_logging): Declare before definition.
	* mi/mi-common.c (_initialize_gdb_mi_common): Declare before
	definition.
@
text
@a4426 1
  int disabled_shlib_breaks = 0;
@


1.377
log
@	* mi/mi-interp.c (mi_solib_loaded, mi_solib_unloaded): New.
	(mi_interpreter_init): Register the above.
	* solib.c (clear_solib): Notify solib unload.
	* breakpoint.c (disable_breakpoints_in_unloaded_shlib): Do not
	disable breakpoints on a.out targets.
@
text
@d5160 2
a5161 1
static void remove_sal (struct symtabs_and_lines *sal, int index_to_remove)
d5186 1
a5186 1
struct symtabs_and_lines
@


1.376
log
@2009-01-07  Pierre Muller  <muller@@ics.u-strasbg.fr>
	    Tom Tromey  <tromey@@redhat.com>

	PR breakpoints/8079:
	* breakpoint.c (print_one_breakpoint): Use exp_string field
	to display expression of watchpoints.
	(mention): Likewise.
	(watch_command_1): Remove trailing whitespace from expression.
	* printcmd.c (struct display) <exp_string>: New field.
	(display_command): Set exp_string.
	(free_display): Free exp_string.
	(clear_displays): Use free_display.
	(do_one_display): Print exp_string.
	(display_info): Likewise.
@
text
@d4460 8
@


1.375
log
@        * breakpoint (update_watchpoint): Minor comment adjustment.
@
text
@d3494 1
a3494 2
	print_expression (b->exp, stb->stream);
	ui_out_field_stream (uiout, "what", stb);
d4892 1
a4892 2
  struct cleanup *old_chain, *ui_out_chain;
  struct ui_stream *stb;
a4896 3
  stb = ui_out_stream_new (uiout);
  old_chain = make_cleanup_ui_out_stream_delete (stb);

d4916 1
a4916 2
	print_expression (b->exp, stb->stream);
	ui_out_field_stream (uiout, "exp", stb);
d4924 1
a4924 2
	print_expression (b->exp, stb->stream);
	ui_out_field_stream (uiout, "exp", stb);
d4932 1
a4932 2
	print_expression (b->exp, stb->stream);
	ui_out_field_stream (uiout, "exp", stb);
d4940 1
a4940 2
	print_expression (b->exp, stb->stream);
	ui_out_field_stream (uiout, "exp", stb);
a5008 1
  do_cleanups (old_chain);
d5947 6
@


1.374
log
@        * breakpoint.c (create_breakpoint, create_breakpoints)
	(break_command_really, set_breakpoint): New parameter enabled.
	(create_breakpoint, break_command_really): Make breakpoint
	disabled if so requested.
	* breakpoint.h (set_breakpoint): New parameter enabled.
	* mi/mi-cmd-break.c (mi_cmd_break_insert): Handle the -d option.
@
text
@d838 2
a839 2
   If the watchpoint is disabled, do nothing.  If this is
   local watchpoint that is out of scope, delete it.  */
@


1.373
log
@	PR breakpoints/9350:
	* varobj.c (varobj_invalidate): Unconditionally free
	all_rootvarobj.
	* symfile.c (syms_from_objfile): Free local_addr when returning
	normally.
	* exec.c (exec_file_attach): Do cleanups before returning.
	(exec_file_command): Likewise.
	* corefile.c (reopen_exec_file): Do cleanups before returning.
	* breakpoint.c (insert_breakpoint_locations): Do cleanups before
	returning.
	(do_vec_free): New function.
	(update_global_location_list): Make a cleanup for old_locations.
	Do cleanups before returning.  Remove unused variable 'e'.
	(find_condition_and_thread): Free result of parsing the
	expression.
	(print_it_typical): Do cleanups before returning.
	(breakpoint_re_set_one): Always free sals.sals.
@
text
@d5093 1
a5093 1
		   struct breakpoint_ops *ops, int from_tty)
d5127 1
a5127 1
	  b->enable_state = bp_enabled;
d5302 2
a5303 1
		    struct breakpoint_ops *ops, int from_tty)
d5313 1
a5313 1
			 thread, ignore_count, ops, from_tty);
d5485 2
a5486 1
		      int from_tty)
d5619 1
a5619 1
			  thread, ignore_count, ops, from_tty);
d5640 1
d5675 2
a5676 1
			from_tty);
d5684 1
a5684 1
		int pending)
d5692 1
a5692 1
			NULL, 0);
d6543 2
a6544 1
			&gnu_v3_exception_catchpoint_ops, from_tty);
@


1.372
log
@* breakpoint.c (do_enable_breakpoint): Use update_watchpoint for
watchpoints.
@
text
@d1281 1
a1281 1
  make_cleanup_ui_file_delete (tmp_error_stream);
d1354 2
d2237 1
a2237 1
  struct cleanup *old_chain, *ui_out_chain;
d2241 3
a2243 3
  int bp_temp = 0;  
  stb = ui_out_stream_new (uiout);
  old_chain = make_cleanup_ui_out_stream_delete (stb);
d2251 3
d2276 1
a2276 1
      return PRINT_SRC_AND_LOC;
d2284 1
a2284 1
      return PRINT_NOTHING;
d2291 1
a2291 1
      return PRINT_NOTHING;
d2297 1
a2297 1
      return PRINT_NOTHING;
d2308 1
a2308 1
      ui_out_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "value");
a2314 1
      do_cleanups (ui_out_chain);
d2317 1
a2317 1
      return PRINT_UNKNOWN;
d2326 1
a2326 1
      ui_out_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "value");
a2329 1
      do_cleanups (ui_out_chain);
d2331 1
a2331 1
      return PRINT_UNKNOWN;
d2343 1
a2343 1
	  ui_out_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "value");
d2356 1
a2356 1
	  ui_out_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "value");
a2360 1
      do_cleanups (ui_out_chain);
d2362 1
a2362 1
      return PRINT_UNKNOWN;
d2373 1
a2373 1
      return PRINT_UNKNOWN;
d2381 1
a2381 1
      return PRINT_UNKNOWN;
d2391 2
a2392 1
      return PRINT_UNKNOWN;
d2394 3
d5441 2
d5444 2
a5445 1
	  parse_exp_1 (&tok, block_for_pc (pc), 0);
d6858 10
a6889 1
  struct gdb_exception e;
d6893 3
a6895 1
  
d7024 2
d7385 1
a7385 1

d7455 1
d7457 1
a7457 2

      xfree (sals.sals);
@


1.371
log
@gdb/
2009-01-07  Pedro Alves  <pedro@@codesourcery.com>

	Delete ONE_PROCESS_WRITETEXT leftovers.

	* breakpoint.c (insert_bp_location): Delete process_warning
	argument.  Adjust.
	(insert_breakpoint_locations): Adjust.
	(reattach_breakpoints): Adjust.
	* infrun.c (normal_stop): Drop "It might be running in another
	process" notice.

gdb/doc/
2009-01-07  Pedro Alves  <pedro@@codesourcery.com>

	* gdb.texinfo (Error in Breakpoints): Delete mention of "The same
	program may be running in another process" errors.
	* gdbint.texinfo (Native Conditionals): Delete
	ONE_PROCESS_WRITETEXT description.
@
text
@d7783 3
a7785 4
      struct frame_id saved_frame_id;
      
      saved_frame_id = get_frame_id (get_selected_frame (NULL));
      if (bpt->exp_valid_block != NULL)
d7787 1
a7787 10
	  struct frame_info *fr =
	    fr = frame_find_by_id (bpt->watchpoint_frame);
	  if (fr == NULL)
	    {
	      printf_filtered (_("\
Cannot enable watchpoint %d because the block in which its expression\n\
is valid is not currently in scope.\n"), bpt->number);
	      return;
	    }
	  select_frame (fr);
d7789 1
a7789 12
      
      if (bpt->val)
	value_free (bpt->val);
      mark = value_mark ();
      fetch_watchpoint_value (bpt->exp, &bpt->val, NULL, NULL);
      if (bpt->val)
	release_value (bpt->val);
      bpt->val_valid = 1;

      if (bpt->type == bp_hardware_watchpoint ||
	  bpt->type == bp_read_watchpoint ||
	  bpt->type == bp_access_watchpoint)
d7791 3
a7793 17
	  int i = hw_watchpoint_used_count (bpt->type, &other_type_used);
	  int mem_cnt = can_use_hardware_watchpoint (bpt->val);
	  
	  /* Hack around 'unused var' error for some targets here */
	  (void) mem_cnt, (void) i;
	  target_resources_ok = TARGET_CAN_USE_HARDWARE_WATCHPOINT (
								    bpt->type, i + mem_cnt, other_type_used);
	  /* we can consider of type is bp_hardware_watchpoint, convert to 
	     bp_watchpoint in the following condition */
	  if (target_resources_ok < 0)
	    {
	      printf_filtered (_("\
Cannot enable watchpoint %d because target watch resources\n\
have been allocated for other watchpoints.\n"), bpt->number);
	      value_free_to_mark (mark);
	      return;
	    }
a7794 3
      
      select_frame (frame_find_by_id (saved_frame_id));
      value_free_to_mark (mark);
@


1.370
log
@        Updated copyright notices for most files.
@
text
@d1032 1
a1032 1
   PROCESS_WARNING, and HW_BREAKPOINT_ERROR are used to report problems.
d1039 1
a1039 1
		    int *disabled_breaks, int *process_warning,
a1181 3
#ifdef ONE_PROCESS_WRITETEXT
	      *process_warning = 1;
#endif
a1278 1
  int process_warning = 0;
d1299 1
a1299 1
				    &disabled_breaks, &process_warning,
a1350 5
#ifdef ONE_PROCESS_WRITETEXT
      if (process_warning)
	fprintf_unfiltered (tmp_error_stream,
			    "The same program may be running in another process.");
#endif
d1399 1
a1399 1
  int dummy1 = 0, dummy2 = 0, dummy3 = 0;
d1410 1
a1410 1
				  &dummy1, &dummy2, &dummy3);
@


1.369
log
@2009-01-01  Pedro Alves  <pedro@@codesourcery.com>

	PR breakpoints/9681:
	* exceptions.h (enum errors): New error type, MEMORY_ERROR.
	* corefile.c (memory_error): Rewrite to throw a MEMORY_ERROR.
	* breakpoint.c (fetch_watchpoint_value): Ignore MEMORY_ERRORs, but
	retrow all other exceptions.

2009-01-01  Pedro Alves  <pedro@@codesourcery.com>

	PR breakpoints/9681:
	* gdb.base/watchpoint.exp: Add regression test.
@
text
@d5 1
a5 1
   2008 Free Software Foundation, Inc.
@


1.368
log
@2008-12-26  Sandra Loosemore  <sandra@@codesourcery.com>

	gdb/
	* breakpoint.c (update_watchpoint): Refactor to avoid compiler
	warning.
@
text
@d758 1
a758 1
   If an error occurs while evaluating the expression, *RESULTP will
d779 1
d790 20
a809 1
  gdb_evaluate_expression (exp, &result);
@


1.367
log
@        * breakpoint.c (update_watchpoint): Adjust and extend the description
        of this function.  Fix one error message accordingly.
@
text
@d901 1
a901 1
	    int i, mem_cnt, target_resources_ok, other_type_used;
d907 1
a907 4
	    if (mem_cnt)
	      target_resources_ok = TARGET_CAN_USE_HARDWARE_WATCHPOINT
			 (bp_hardware_watchpoint, i + mem_cnt, other_type_used);
	    if (!mem_cnt || target_resources_ok <= 0)
d910 8
a917 1
	      b->type = bp_hardware_watchpoint;
@


1.366
log
@gdb/
	Fix hw watchpoints created before the inferior was started.
	* breakpoint.c (update_watchpoint): Convert the bp_watchpoint and
	bp_hardware_watchpoint types according to the current runtime state.
gdb/testsuite/
	* gdb.base/watchpoint-hw.exp, gdb.base/watchpoint-hw.c: New.
@
text
@d811 2
a812 2
/* Assuming that B is a hardware watchpoint:
   - Reparse watchpoint expression, is REPARSE is non-zero
d814 2
d828 3
a830 4
  /* We don't free locations.  They are stored in
     bp_location_chain and update_global_locations will
     eventually delete them and remove breakpoints if
     needed.  */
d976 1
a976 1
Hardware watchpoint %d deleted because the program has left the block \n\
@


1.365
log
@	Fix loc_type of `bp_location's created by update_watchpoint.
	* breakpoint.c (allocate_bp_location): Remove the bp_type parameter.
	Replace bp_type by bpt->type.  Update prototype.  All callers updated.
	(add_location_to_breakpoint):  Remove the bp_type parameter.
	Replace bp_type by b->type.  All callers updated.
	(set_breakpoint_location_function): Replace bptype by b->type.
@
text
@d894 21
@


1.364
log
@	* breakpoint.c (update_global_location_list): Fix the comment.
@
text
@d184 1
a184 2
static struct bp_location *
allocate_bp_location (struct breakpoint *bpt, enum bptype bp_type);
d926 1
a926 1
		  loc = allocate_bp_location (b, bp_hardware_watchpoint);
d4015 1
a4015 1
allocate_bp_location (struct breakpoint *bpt, enum bptype bp_type)
d4027 1
a4027 1
  switch (bp_type)
d4155 1
a4155 1
  adjusted_address = adjust_breakpoint_address (sal.pc, bptype);
d4157 1
a4157 1
  b->loc = allocate_bp_location (b, bptype);
d4983 1
a4983 1
add_location_to_breakpoint (struct breakpoint *b, enum bptype bptype,
d4988 1
a4988 1
  loc = allocate_bp_location (b, bptype);
d4993 1
a4993 2
  loc->address = adjust_breakpoint_address (loc->requested_address,
					    bptype);
d5091 1
a5091 1
	  loc = add_location_to_breakpoint (b, type, &sal);
d7227 1
a7227 1
	add_location_to_breakpoint (b, b->type, &(sals.sals[i]));
@


1.363
log
@	Fix automatic restoration of breakpoints memory for ia64.
	* ia64-tdep.c: New #if check on BREAKPOINT_MAX vs. BUNDLE_LEN.
	(ia64_memory_insert_breakpoint): New comment part for SHADOW_CONTENTS
	content.  Remove variable instr.  New variable cleanup.  Force
	automatic breakpoints restoration.  PLACED_SIZE and SHADOW_LEN are now
	set larger, to BUNDLE_LEN - 2.  Variable `bundle' type update.  Return
	error if even just final target_write_memory has failed.
	(ia64_memory_remove_breakpoint): Rename variables bundle to bundle_mem
	and instr to instr_saved.  New variables bundle_saved and
	instr_breakpoint.  Comment new reasons why we need to disable automatic
	restoration of breakpoints.  Assert PLACED_SIZE and SHADOW_LEN.  New
	check of the original memory content.  Return error if even just final
	target_write_memory has failed.
	(ia64_breakpoint_from_pc): Implement the emulation of permanent
	breakpoints compatible with current bp_loc_is_permanent.
	(template_encoding_table): Make it `const'.
	* breakpoint.c (bp_loc_is_permanent): Support unsupported software
	breakpoints.  New variables `cleanup' and `retval'.
	* monitor.c (monitor_insert_breakpoint): Remove unused variable `bp'.
@
text
@d6814 1
a6814 1
/* If SHOULD_INSERT is true, do not insert any breakpoint locations
@


1.362
log
@        Remove the unused BPSTAT_WHAT_CHECK_SHLIBS_RESUME_FROM_HOOK.

        * breakpoint.h (enum bpstat_what_main_action): Remove
        BPSTAT_WHAT_CHECK_SHLIBS_RESUME_FROM_HOOK.
        * breakpoint.c (bpstat_what): Delete catch_shlib_event from enum class.
        Remove the BPSTAT_WHAT_CHECK_SHLIBS_RESUME_FROM_HOOK column from
        variable table.
        * infrun.c (wait_for_inferior): Remove handling of
        BPSTAT_WHAT_CHECK_SHLIBS_RESUME_FROM_HOOK.
@
text
@d5013 2
d5021 4
d5027 5
d5034 1
a5034 1
    return 1;
d5036 3
a5038 1
  return 0;
@


1.361
log
@        Remove some unused macros related to the old load/unload catchpoints.

        * breakpoint.c (SOLIB_LOADED_LIBRARY_PATHNAME)
        (SOLIB_UNLOADED_LIBRARY_PATHNAME, SOLIB_CREATE_CATCH_LOAD_HOOK)
        (SOLIB_CREATE_CATCH_UNLOAD_HOOK): Delete. No longer used.
@
text
@a3056 3
      /* We caught a shared library event.  */
      catch_shlib_event,

a3071 1
#define shlr BPSTAT_WHAT_CHECK_SHLIBS_RESUME_FROM_HOOK
d3092 7
a3098 8
     kc   < clr sgl shl shlr slr sn sr ss
     sgl  < shl shlr slr sn sr ss
     slr  < err shl shlr sn sr ss
     clr  < err shl shlr sn sr ss
     ss   < shl shlr sn sr
     sn   < shl shlr sr
     shl  < shlr sr
     shlr < sr
d3115 1
a3115 1
  /*       kc    ss    sn    sgl    slr   clr   sr   shl   shlr
d3118 1
a3118 1
    {kc, ss, sn, sgl, slr, clr, sr, shl, shlr},
d3120 1
a3120 1
    {ss, ss, sn, ss, ss, ss, sr, shl, shlr},
d3122 1
a3122 1
    {sn, sn, sn, sn, sn, sn, sr, shl, shlr},
d3124 1
a3124 1
    {sgl, ss, sn, sgl, slr, slr, sr, shl, shlr},
d3126 1
a3126 1
    {ss, ss, sn, ss, ss, ss, sr, shl, shlr},
d3128 1
a3128 1
    {sn, sn, sn, sn, sn, sn, sr, shl, shlr},
d3130 1
a3130 1
    {slr, ss, sn, slr, slr, err, sr, shl, shlr},
d3132 1
a3132 1
    {clr, ss, sn, err, err, err, sr, shl, shlr},
d3134 1
a3134 1
    {sr, sr, sr, sr, sr, sr, sr, sr, sr},
d3136 1
a3136 3
    {shl, shl, shl, shl, shl, shl, sr, shl, shlr},
/*catch_shlib */
    {shlr, shlr, shlr, shlr, shlr, shlr, sr, shlr, shlr}
a3148 1
#undef shlr
@


1.361.2.1
log
@2008-11-20  Stan Shebs  <stan@@codesourcery.com>

	Multi-process (primarily multi-exec) support.

	2008-10-14  Stan Shebs  <stan@@codesourcery.com>

	* blockframe.c (get_frame_block): Get inferior from frame.
	* block.c (block_for_pc_inf): New function.
	* block.h (block_for_pc_inf): Declare.
	* symfile.c (find_pc_inf_sect): New function.
	* symfile.h (find_pc_inf_sect): Declare.
	* symtab.c (find_pc_inf_line): New function.
	* symtab.h (find_pc_inf_line): Declare.
	* frame.c (struct frame_info) New field inferior.
	(fprint_frame_id): Display inferior.
	(get_frame_id): Set inferior_num from inferior.
	(frame_id_eq): Compare inferiors.
	(create_sentinel_frame): Set inferior.
	(create_new_frame): Copy inferior from sentinel.
	(get_prev_frame_raw): Copy inferior from next frame.
	(find_frame_sal): Use find_pc_inf_line.
	(get_frame_inferior): New function.
	* frame.h (struct frame_id): New field inferior_num.

	* breakpoint.c (expand_sals_by_inferiors): Copy section from input
	sal to expanded sals.
	* symtab.c (expand_line_sal): Ditto.

	2008-10-10  Stan Shebs  <stan@@codesourcery.com>

	* remote.c (discard_pending_stop_replies): Initialize prev.
	* infrun.c (infrun_thread_stop_requested): Ditto.

	2008-10-08  Stan Shebs  <stan@@codesourcery.com>

	* inferior.h (struct inferior): Rename environ field to inf_environ.
	* inferior.c (print_inferior): Ditto.

	2008-10-01  Stan Shebs  <stan@@codesourcery.com>

	* inferior.h (detach_fork): Declare here...
	* linux-fork.h (detach_fork): ...instead of here.
	* linux-fork.c (detach_fork): Move to...
	* infrun.c (detach_fork): ...here.
	* remote.c (detach_fork): Remove decl.

	2008-09-30  Stan Shebs  <stan@@codesourcery.com>

	* linespec.c (decode_line_1): Better default for one-exec case.
	* remote (remote_start_remote): Use the exec in the one-exec case.

	2008-09-29  Stan Shebs  <stan@@codesourcery.com>

	* infcmd.c (attach_command): If only one exec, assume it is the
	attached inferior's exec.
	(attach_command_post_wait): Set inferior's exec from
	the one that was found.
	* inf-ptrace.c (inf_ptrace_attach): Only report exec file if
	if there is just one present.
	(inf_ptrace_detach): Use inferior to get correct exec name.

	2008-09-29  Stan Shebs  <stan@@codesourcery.com>

	* inferior.c (print_inferior): Use exec short names, and drop
	unused address space display.

	2008-09-26  Stan Shebs  <stan@@codesourcery.com>

	* breakpoint.c (should_be_inserted): Test for no inferior.
	(clone_breakpoint_location): New function, broken out from...
	(update_breakpoint_inferiors): ...here, also tweak conditions
	for adding a location.
	(insert_breakpoint_location): Don't count non-running inferiors.
	(remove_breakpoint): Set tmp_inf.
	(print_one_breakpoint_location): Add allflag arg, use to always
	show inf.
	(print_one_breakpoint): Add allflag arg.
	(do_captured_breakpoint_query): Fix caller.
	(breakpoint_1): Ditto.
	* exec.c (create_exec): Save full pathname as exec name.
	(find_exec_by_name): Use find_exec_by_substr.
	* fork-child.c (fork_inferior): Warn if exec not found for new
	inferior.

	2008-09-25  Stan Shebs  <stan@@codesourcery.com>

	* breakpoint.c (should_be_inserted): Don't insert in inferiors
	that are not running.
	(update_breakpoint_inferiors): New function.
	(insert_breakpoints): Call it.
	(insert_breakpoint_locations): Don't insert in inferiors that are
	not running.
	(set_raw_breakpoint_without_location): Set trigger set from
	current itset here...
	(set_raw_breakpoint): Instead of here. Also add default fillins
	for the location's inferior.
	(add_location_to_breakpoint): Similarly.
	(expand_sals_by_inferiors): New function.
	(breakpoint_re_set_one): Call it.
	(resolve_sal_pc): Don't set sal inferior.
	* breakpoint.h (struct breakpoint): Remove exec field, never used.
	* inferior.h (inferior_list): Declare.
	* inferior.c (inferior_list): Make public.
	(add_inferior_to_itset): Auto-add inferiors after exec's inferior.
	(first_inferior_in_set): Check for zero-length vector.
	* exec.c (xfer_memory): Use tmp_inf as inferior if set.
	* infcmd.c (focus_command): Improve user feedback.
	* linespec.c (build_canonical_line_spec): Record exec name as part
	of canonical spec.
	(symbol_found): Canonicalize specs more.
	(decode_indirect): Revert rewrite from 2008-09-14.
	(decode_sharp): Use find_exec_by_substr, better error messages.
	* minsyms.c (lookup_minimal_symbol_in_exec): New function.
	(lookup_minimal_symbol_in_exec_1): New function, body of
	lookup_minimal_symbol.
	* symtab.h (lookup_minimal_symbol_in_exec): Declare.
	* symtab.c (find_function_start_sal): Set inferior to use.
	(append_expanded_sal): Return pointer to the new sal.
	* remote.c (remote_xfer_memory): Better parms to ptid_build, remove
	debug print.
	(remote_xfer_partial): Ditto.

	2008-09-22  Pedro Alves  <pedro@@codesourcery.com>

	* inferior.c (itset_member): Fix typo.

	2008-09-22  Stan Shebs  <stan@@codesourcery.com>

	* inferior.h (current_inf): Remove declaration.
	(tmp_inf): Declare.
	* inferior.c (current_inf): Remove.
	(tmp_inf): New global, hack to bypass passing inferior throughout
	target stack.
	(print_inferior): Don't report current_inf.
	(add_inferior_command): Don't use current_inf.
	(name_inferior_command): Use first inferior of current_itset.
	(update_itset): Handle NULL case.
	(add_inferior_itset): Recursively add all inferiors derived from
	an exec if the exec's own inferior is present.
	(first_inferior_in_set): New function.
	(free_inferior): Comment out until references cleared reliably.
	* infcmd.c (focus_command): Don't set current_inf.
	(get_inferior_args): Use first_inferior_in_set instead of
	current_inf.
	(set_inferior_args): Ditto.
	(set_inferior_args_vector): Ditto.
	(notice_args_set): Ditto.
	* breakpoint.c (insert_breakpoint_locations): Remove insertion test
	using current_inf, set tmp_inf.
	(reattach_breakpoints): Set tmp_inf.
	(bpstat_check_breakpoint_conditions): Test trigger set here...
	(bpstat_stop_status): ... instead of here.
	(bpstat_check_trigger_set): Add special case for exec's own
	inferior.
	(print_one_breakpoint_location): Also test for multiple inferiors
	before displaying location's inferior, flag trigger set with "i/t"
	instead of "focus".
	(check_duplicates): Pass location's inferior to...
	(check_duplicates_for): Add inferior arg and use.
	(set_raw_breakpoint): Override sal inferior with one from the
	trigger set.
	(add_location_to_breakpoint): Ditto.
	* remote.c (remote_xfer_memory): Switch inferiors if tmp_inf is
	set to something different from inferior_ptid.
	(remote_xfer_partial): Ditto.
	* top.c (execute_command): Always update the current itset.

	2008-09-19  Stan Shebs  <stan@@codesourcery.com>

	* inferior.c (set_inferior_exec): New function.
	(set_inferior_exec_command): New command.
	* inferior.h: Declare set_inferior_exec.
	* fork-child.c (fork_inferior): Set the inferior's exec.
	* remote.c (extended_remote_create_inferior_1): Ditto.
	gdb/doc/
	* gdb.texinfo (Debugging Multiple Programs): Describe set-exec.

	2008-09-18  Stan Shebs  <stan@@codesourcery.com>

	* target.c (target_resize_to_sections): Adjust execs' section
	tables too.

	2008-09-17  Stan Shebs  <stan@@codesourcery.com>

	gdb/doc/
	* gdb.texinfo (Invoking GDB): Describe multiple program args.
	(File Options): Describe multi-program effects.
	(Multiple Programs): New section, multi-program debugging.
	(Forks): Rename section from "Processes".
	(Specify Location): Describe the #-syntax.
	(Variables): Describe the #-syntax.
	(Files): Describe add-file and add-exec-file.
	(Maintenance Commands): Describe maint print execs.

	2008-09-15  Stan Shebs  <stan@@codesourcery.com>

	* exec.c (addr_space_info_command): Don't try to display host address.

	2008-09-14  Stan Shebs  <stan@@codesourcery.com>

	* c-exp.y: (yylex): Accept '#' in identifiers.
	* linespec.c (decode_sharp): New function.
	(decode_line_1): Use it for #-syntax.
	(decode_indirect): Rewrite to accept exec arg and iterate over
	inferiors.
	(struct d_i_data): New struct for inferior iteration.
	(decode_indirect_callback): New function.
	(decode_variable): Pass in exec, use in symbol lookup.

	2008-09-14  Stan Shebs  <stan@@codesourcery.com>

	* breakpoint.h (struct bp_location): Add inferior field instead
	of address space field.
	* breakpoint.c (insert_breakpoint_locations): Only insert in
	appropriate inferior.
	(bpstat_check_trigger_set): New function.
	(bpstat_stop_status): Call it, check location's inferior also.
	(print_one_breakpoint_location): Report location's inferior.
	(set_raw_breakpoint): Set location inferior, clear an experiment.
	(add_location_to_breakpoint): Ditto.
	(expand_line_sal_maybe): Check for non-NULL original function.
	(resolve_sal_pc): Set sal inferior.
	(clear_command): Be careful to not clear anything twice.
	* symtab.h: Update declarations of symbol lookups.
	(struct symtab_and_line): Change address space to inferior field.
	* symtab.c (init_sal): Clear inferior field.
	(append_expanded_sal): Set inferior.
	(lookup_symbol_in_language_1): New function.
	(lookup_symbol_in_language): Call it.
	(lookup_symbol_in_exec_in_language): New function.
	(lookup_symbol): Detect #-syntax and find exec to use.
	(lookup_symbol_aux): Add exec argument and use it.
	(lookup_symbol_aux_symtabs): Ditto.
	(lookup_symbol_aux_psymtabs): Ditto.
	(basic_lookup_symbol_nonlocal): Ditto.
	(lookup_symbol_static): Ditto.
	(lookup_symbol_global): Ditto.
	* ada-lang.c (cp_lookup_symbol_nonlocal): Ditto.
	* cp-support.h (cp_lookup_symbol_nonlocal): Ditto.
	* cp-namespace.c (cp_lookup_symbol_nonlocal): Ditto.
	* language.h (struct language_defn): Ditto.
	* scm-valprint.c (scm_inferior_print): Add exec arg to
	lookup_symbol_global.
	* source.c (select_source_symtab): Use current_exec.
	* addrspace.h (struct addr_space): New field num.
	* exec.h (struct exec): New fields sections and sections_end.
	* exec.c (exec_file_attach_1): Set them from exec_ops, set
	inferior's address space name from exec.
	(find_exec_by_substr): New function.
	(build_section_table): Don't free old table.
	(print_section_info): Use exec's section table.
	(next_address_space_num): New global, numbering for address spaces.
	(new_address_space): Use it.
	(addr_space_info_command): Display it.
	* infcmd.c (set_current_exec): Set exec_ops section table.
	* inferior.h (update_itset): Declare.
	* inferior.c (add_inferior_silent): Set address space.
	(print_inferior): Display it.
	(number_of_inferiors): New function.
	(itset_member): New function.

	2008-09-04  Stan Shebs  <stan@@codesourcery.com>

	* corefile.c (close_exec_file): Remove #if 0 block.
	(validate_files): Use first_exec instead of exec_bfd.
	(get_exec_file): Ditto.
	* corelow.c (core_open): Ditto.
	* utils.c (string_to_core_addr): Ditto.
	* arch-utils.c (gdbarch_update_p): Ditto.
	* linux-thread-db.c (enable_thread_event): Ditto.
	(thread_db_get_thread_local_address ): Ditto.
	* exec.c (find_exec_by_name): Test short name also.
	(file_command): Set current exec.

	2008-09-03  Stan Shebs  <stan@@codesourcery.com>

	* inferior.c (add_threads_to_itset): Default to including all
	of an inferior's threads.

	2008-08-31  Stan Shebs  <stan@@codesourcery.com>

	Parsing for i/t sets.
	* inferior.h (struct itset_entry): New struct.
	(struct itset): Make thread lists be per-inferior, add parse state
	variables.
	* inferior.c: (add_inferior_command): Add error checking and
	confirmation.
	(remove_inferior_command): Update for itset restructuring.
	(new_itset): Don't pass in dynamic-ness, call parse_itset_spec.
	(update_itset): Similarly.
	(parse_itset_spec): New, parsing of itset spec.
	(parse_itset_list, parse_itset_range, etc): New.
	(make_itset_from_spec): Rewrite.
	(dump_itset): Rewrite to reflect itset structure.
	* infcmd.c (focus_command): Similarly.

	2008-08-25  Stan Shebs  <stan@@codesourcery.com>

	First part of multiprocess support.
	* Makefile.in (COMMON_OBS): Add inferior.o.
	* addrspace.h: New file.
	* breakpoints.h (struct bp_location): Add address space field.
	(struct breakpoint): Add trigger set and exec fields.
	* breakpoints.c (print_one_breakpoint_location): Display trigger
	set.
	(set_raw_breakpoint): Set trigger set from current itset.
	* corefile.c (reopen_exec_file): Rewrite for multiple execs.
	(get_exec_file): Add case for current_exec.
	* corelow.c (is_core_file): New function.
	(core_files_info): Pass additional arg to print_section_info.
	* exec.h (struct exec): New struct.
	* exec.c (execs): New global.
	(exec_bfd_mtime): Remove.
	(last_exec_created, current_exec, first_exec): New globals.
	(exec_close): Clear all exec objects.
	(exec_file_clear): Tweak user message.
	(exec_file_add): New function.
	(exec_file_attach_1): New function, body of exec_file_attach,
	plus new code to handle multiple execs.
	(exec_file_attach): Call it.
	(exec_file_update): New function.
	(create_exec, find_exec_by_name, number_of_execs): New functions.
	(exec_file_command): Rephrase query, set current exec.
	(add_exec_file_command): New command.
	(add_file_command): New command.
	(print_section_info): Add exec argument.
	(exec_files_info): Rewrite for multiple execs.
	(maintenance_print_execs): New function.
	(new_address_space): New function.
	(addr_space_info_command): New command.
	* gdbcore.h (exec_bfd_mtime): Remove decl.
	(exec_file_add): Declare.
	* infcmd.c: Include exec.h.
	(current_itset): New global.
	(set_current_exec): New function.
	(focus_command): New command.
	(get_inferior_args): Maybe get from the current inferior.
	(set_inferior_args): Also set in current inferior.
	(set_inferior_args_vector): Similarly.
	(notice_args_set): Similarly.
	(attach_command): Rephrase query.
	* inferior.h (struct inferior): New struct.
	(struct itset): New struct.
	* inferior.c: New file, management of multiple inferiors.
	* main.c (captured_main): Rewrite to allow multiple executables,
	pids, and corefiles on the command line.
	* maint.c (maintenance_info_sections): Rewrite for multiple execs.
	* objfiles.h (struct objfile): New field for exec.
	(ALL_OBJFILES_FOR_EXEC, ALL_PRIMARY_SYMTABS_FOR_EXEC,
	ALL_PSYMTABS_FOR_EXEC): New macros.
	* objfiles.c (allocate_objfile): Clear exec field.
	* solib.c (clear_solib): Use first_exec instead of exec_bfd.
	* source.c (select_source_symtab): Use ALL_OBJFILES_FOR_EXEC.
	(find_source_lines): Use mtime from exec.
	* symfile.c (syms_from_objfile): Don't clear objfile if multiple
	execs.
	(new_symfile_objfile): Get objfile's exec from last_exec_created.
	(symbol_file_clear): Rephrase messages.
	(reread_symbols): Update objfile's exec if necessary.
	* symmisc.c (dump_objfile): Dump objfile's exec also.
	(maintenance_print_objfiles): Report symfile_objfile.
	* symtab.h (struct symtab_and_line): Add address space field.
	* symtab.c (find_pc_sect_psymtab): Look for a plausible exec, and
	then use it.
	(lookup_symbol_aux_symtabs): Use current exec.
	(lookup_symbol_aux_symtabs): Ditto.
	(basic_lookup_transparent_type): Ditto.
	(find_pc_sect_symtab): Ditto.
	* target.h (print_section_info): Add arg to decl.
	* tui/tui-win.c: Rename "focus" command to "ffocus".

gdb/testsuite:

2008-11-20  Stan Shebs  <stan@@codesourcery.com>

	2008-09-14  Stan Shebs  <stan@@codesourcery.com>

	* gdb.gdb/selftest.exp: Update to reflect current sources.
	* Makefile.in (ALL_SUBDIRS): Add gdb.multi.
	* configure.ac (AC_OUTPUT): Add gdb.multi/Makefile.
	* configure: Regenerate.

	* gdb.multi/Makefile.in: New.
	* gdb.multi/hello.c, hangout.c, goodbye.c: New source files.
	* gdb.multi/base.exp: New file, basic multiprocess tests.

	2008-08-25  Stan Shebs  <stan@@codesourcery.com>

	* config/monitor.exp: Match on rephrased message.
	* gdb.base/attach.exp: Ditto.
	* gdb.base/default.exp: Ditto.
	* lib/gdb.exp: Ditto.
@
text
@a40 1
#include "exec.h"
a62 4
static int
bpstat_check_trigger_set (const struct bp_location *bl, struct inferior *inf,
			  int thread_id);

a825 1
  struct inferior *inf;
a854 2
  inf = get_frame_inferior (get_selected_frame (NULL));

a930 1
		  loc->inferior = inf;
a981 3
  if (!bpt->inferior || (bpt->inferior && bpt->inferior->pid == 0))
    return 0;

a1197 77
/* Given a location, create and add another location differing only in
   the inferior.  */

void
clone_breakpoint_location (struct breakpoint *b, struct bp_location *loc,
			   struct inferior *inf)
{
  struct bp_location *new_loc, **tmp;
  struct gdb_exception e;

  new_loc = allocate_bp_location (b, b->type);
  for (tmp = &(b->loc); *tmp != NULL; tmp = &((*tmp)->next))
    ;
  *tmp = new_loc;
  new_loc->requested_address = loc->requested_address;
  new_loc->address = loc->address;
  new_loc->length = loc->length;
  new_loc->inferior = inf;
  if (b->cond_string)
    {
      char *s = b->cond_string;
      TRY_CATCH (e, RETURN_MASK_ERROR)
	{
	  new_loc->cond = parse_exp_1 (&s, block_for_pc_inf (new_loc->address,
							     inf), 0);
	}
      if (e.reason < 0)
	{
	}
    }
  /* Permanent breakpoints will be inserted in every inferior created
     from the same exec.  */
  if (b->enable_state == bp_permanent)
    new_loc->inserted = loc->inserted;
}

/* For the given breakpoint, look for any inferiors that might have
   appeared and need a breakpoint location to be inserted.  */

void
update_breakpoint_inferiors (struct breakpoint *b)
{
  struct bp_location *loc, *loc2;
  struct inferior *inf;

  update_itset (b->trigger_set);

  for (loc = b->loc; loc; loc = loc->next)
    {
      if (loc->inferior == NULL
	  || (loc->inferior
	      && loc->inferior->exec
	      && loc->inferior->exec->inferior == loc->inferior))
	{
	  for (inf = inferior_list; inf; inf = inf->next)
	    {
	      if ((loc->inferior == NULL
		   || inf->exec == loc->inferior->exec)
		  && inf->pid != 0)
		{
		  int found = 0;
		  for (loc2 = b->loc; loc2; loc2 = loc2->next)
		    {
		      if (inf == loc2->inferior)
			{
			  found = 1;
			  break;
			}
		    }
		  if (!found)
		    clone_breakpoint_location (b, loc, inf);
		}
	    }
	}
    }
}

a1207 3
  {
    update_breakpoint_inferiors (bpt);

a1209 1
  }
a1256 6
      /* Only insert into running inferiors.  */
      if (!b->inferior || b->inferior->pid == 0)
	continue;

      /* Nasty hack to smuggle the location's inferior down to target bits.  */
      tmp_inf = b->inferior;
a1259 2
      tmp_inf = NULL;

d1281 1
a1281 3
	if (!loc->inserted
	    && !(loc->inferior == NULL
		 || (loc->inferior && loc->inferior->pid == 0)))
a1372 3
	/* Nasty hack to smuggle the location's inferior down to
	   target bits.  */
	tmp_inf = b->inferior;
a1374 1
	tmp_inf = NULL;
a1529 3
  /* Nasty hack to smuggle the location's inferior down to target.  */
  tmp_inf = b->inferior;

a1626 1
  tmp_inf = NULL;
d2817 3
a2819 3
/* Check conditions (condition proper, frame, thread, ignore count,
   and trigger set) of breakpoint referred to by BS.  If we should not
   stop for this breakpoint, set BS->stop to 0.  */
a2860 7
      else if (b->trigger_set
	       && !bpstat_check_trigger_set (bl, 
					     find_inferior_pid (ptid_get_pid (ptid)),
					     pid_to_thread_id (ptid)))
	{
	  bs->stop = 0;
	}
a2872 27
/* Test whether this stopping inferior and thread are in the i/t set
   for this breakpoint.  */

static int
bpstat_check_trigger_set (const struct bp_location *bl, struct inferior *inf,
			  int thread_id)
{
  struct breakpoint *b = bl->owner;

  if (!b->trigger_set)
    return 1;

  update_itset (b->trigger_set);

  if (itset_member (b->trigger_set, inf, thread_id))
    return 1;

  /* Stop if the location points to the exec's own inferior, and the inferior
     here was launched from that exec.  */
  if (bl->inferior
      && bl->inferior->exec
      && bl->inferior->exec->inferior == bl->inferior
      && inf->exec == bl->inferior->exec)
    return 1;

  return 0;
}
a2910 5
    /* Any location that is somehow not connected with a running
       inferior cannot possibly cause a stop.  */
    if (!bl->inferior || bl->inferior->pid == 0)
      continue;

d3320 1
a3320 1
			       CORE_ADDR *last_addr, int allflag)
d3435 5
a3439 1
      /* FIXME make this work right for multiple inferiors etc */
a3493 9
  /* For backward compatibility, don't display inferiors unless there
     are several.  */
  if (number_of_execs () > 1 || number_of_inferiors () > 2 || allflag)
    {
      ui_out_text (uiout, " inf ");
      ui_out_field_int (uiout, "inf",
			((loc && loc->inferior) ? loc->inferior->num : 0));
    }
  
a3501 7
  if (!part_of_multiple && b->trigger_set)
    {
      ui_out_text (uiout, " i/t [");
      ui_out_field_string (uiout, "i/t", b->trigger_set->spec);
      ui_out_text (uiout, "]");
    }
  
d3586 1
a3586 1
		      CORE_ADDR *last_addr, int allflag)
d3588 1
a3588 1
  print_one_breakpoint_location (b, NULL, 0, last_addr, allflag);
d3611 1
a3611 1
	    print_one_breakpoint_location (b, loc, n, last_addr, allflag);
d3632 1
a3632 1
	  print_one_breakpoint (b, &dummy_addr, 0);
d3739 1
a3739 1
	  print_one_breakpoint (b, &last_addr, allflag);
d3891 1
a3891 1
check_duplicates_for (CORE_ADDR address, struct inferior *inf, struct obj_section *section)
a3902 1
	&& b->inferior == inf
a3936 1
		&& b->inferior == inf
d3960 1
a3960 1
    check_duplicates_for (bl->address, bl->inferior, bl->section);    
a4095 1
  b->trigger_set = current_itset;
a4156 1
  struct inferior *inf;
a4168 12
  b->loc->inferior = sal.inferior;

  /* Find an inferior in the trigger set.  */
  if (!b->loc->inferior)
    b->loc->inferior = first_inferior_in_set (b->trigger_set);

  /* Find an inferior from the sal's symtab.  */
  if (!b->loc->inferior
      && sal.symtab
      && sal.symtab->objfile
      && sal.symtab->objfile->exec)
    b->loc->inferior = sal.symtab->objfile->exec->inferior;
a4995 1
  struct inferior *inf;
a5003 13
  loc->inferior = sal->inferior;

  /* Find an inferior in the trigger set.  */
  if (!loc->inferior)
    loc->inferior = first_inferior_in_set (b->trigger_set);

  /* Find an inferior from the sal's symtab.  */
  if (!loc->inferior
      && sal->symtab
      && sal->symtab->objfile
      && sal->symtab->objfile->exec)
    loc->inferior = sal->symtab->objfile->exec->inferior;

d5186 2
a5187 3
	      if (this_function
		  && original_function
		  && strcmp (this_function, original_function) != 0)
a5235 44
extern /*static*/ struct symtab_and_line *
append_expanded_sal (struct symtabs_and_lines *sal,
		     struct symtab *symtab,
		     int lineno, CORE_ADDR pc);

struct symtabs_and_lines
expand_sals_by_inferiors (struct symtabs_and_lines sals)
{
  struct symtabs_and_lines expanded;
  struct symtab_and_line sal, *new_sal;
  struct inferior *sal_inf, *inf;
  int i;

  expanded.nelts = 0;
  expanded.sals = NULL;

  for (i = 0; i < sals.nelts; ++i)
    {
      sal = sals.sals[i];
      append_expanded_sal (&expanded, sal.symtab, sal.line, sal.pc);
      expanded.sals[expanded.nelts-1].section = sal.section;
      sal_inf = sal.inferior;
      if (!sal_inf
	  && sal.symtab
	  && sal.symtab->objfile
	  && sal.symtab->objfile->exec)
	sal_inf = sal.symtab->objfile->exec->inferior;
      if (sal_inf)
	{
	  for (inf = inferior_list; inf; inf = inf->next)
	    {
	      if (inf->exec == sal_inf->exec && inf->pid != 0)
		{
		  new_sal = append_expanded_sal (&expanded, sal.symtab, sal.line, sal.pc);
		  new_sal->section = sal.section;
		  new_sal->inferior = inf;
		}
	    }
	}
    }

  return expanded;
}

d6753 1
a6753 14
	    {
	      struct breakpoint *b2;
	      int already_there = 0;
	      for (ix = 0; VEC_iterate(breakpoint_p, found, ix, b2); ix++)
		{
		  if (b2 == b)
		    {
		      already_there = 1;
		      break;
		    }
		}
	      if (!already_there)
		VEC_safe_push(breakpoint_p, found, b);
	    }
a7392 1
      expanded = expand_sals_by_inferiors (expanded);
@


1.360
log
@        Remove support for catch load and catch unload commands.

        * breakpoint.h (enum bptype): Remove bp_catch_load and bp_catch_unload.
        (struct breakpoint): Remove fields dll_pathname and
        triggered_dll_pathname.
        (bpstat_get_triggered_catchpoints, ep_is_shlib_catchpoint): Delete.
        * breakpoint.c (ep_is_catchpoint): Remove handling of
        bp_catch_load and bp_catch_unload.
        (print_it_typical, bpstat_check_location, bpstat_what)
        (print_one_breakpoint_location, print_one_breakpoint_location)
        (user_settable_breakpoint, allocate_bp_location)
        (set_raw_breakpoint_without_location, mention, delete_breakpoint,
        (breakpoint_re_set_one, disable_command, enable_command): Likewise.
        (ep_is_shlib_catchpoint, bpstat_get_triggered_catchpoints)
        (catch_load_command_1, catch_unload_command_1): Delete.
        (_initialize_breakpoint): Remove the "catch load" and "catch unload"
        command creation.
        * infrun.c (handle_inferior_event): Remove the handling of
        load/unload catchpoint events.
@
text
@a327 53
/* This function returns a pointer to the string representation of the
   pathname of the dynamically-linked library that has just been
   loaded.

   This function must be used only when SOLIB_HAVE_LOAD_EVENT is TRUE,
   or undefined results are guaranteed.

   This string's contents are only valid immediately after the
   inferior has stopped in the dynamic linker hook, and becomes
   invalid as soon as the inferior is continued.  Clients should make
   a copy of this string if they wish to continue the inferior and
   then access the string.  */

#ifndef SOLIB_LOADED_LIBRARY_PATHNAME
#define SOLIB_LOADED_LIBRARY_PATHNAME(pid) ""
#endif

/* This function returns a pointer to the string representation of the
   pathname of the dynamically-linked library that has just been
   unloaded.

   This function must be used only when SOLIB_HAVE_UNLOAD_EVENT is
   TRUE, or undefined results are guaranteed.

   This string's contents are only valid immediately after the
   inferior has stopped in the dynamic linker hook, and becomes
   invalid as soon as the inferior is continued.  Clients should make
   a copy of this string if they wish to continue the inferior and
   then access the string.  */

#ifndef SOLIB_UNLOADED_LIBRARY_PATHNAME
#define SOLIB_UNLOADED_LIBRARY_PATHNAME(pid) ""
#endif

/* This function is called by the "catch load" command.  It allows the
   debugger to be notified by the dynamic linker when a specified
   library file (or any library file, if filename is NULL) is loaded.  */

#ifndef SOLIB_CREATE_CATCH_LOAD_HOOK
#define SOLIB_CREATE_CATCH_LOAD_HOOK(pid,tempflag,filename,cond_string) \
   error (_("catch of library loads not yet implemented on this platform"))
#endif

/* This function is called by the "catch unload" command.  It allows
   the debugger to be notified by the dynamic linker when a specified
   library file (or any library file, if filename is NULL) is
   unloaded.  */

#ifndef SOLIB_CREATE_CATCH_UNLOAD_HOOK
#define SOLIB_CREATE_CATCH_UNLOAD_HOOK(pid, tempflag, filename, cond_string) \
   error (_("catch of library unloads not yet implemented on this platform"))
#endif

@


1.359
log
@	* remote.c (remote_start_remote): If the solib list is global,
	fetch libraries and insert breakpoints after connecting.
	* infcmd.c (post_create_inferior): If the solist is shared between
	inferiors, no need to refetch it on every new inferior.
	(detach_command): If the shared library list is shared between
	inferiors, then don't clear it on every inferior detach.
	* gdbarch.sh (has_global_solist): New.
	* i386-dicos-tdep.c (i386_dicos_init_abi): Set
	gdbarch_has_global_solist.
	* target.c (target_pre_inferior): If the shared library list is
	shared between inferiors, then don't clear it here, neither
	invalidate the memory regions or clear the target description.
	(target_detach): If the shared library list is shared between
	inferiors, then don't remove breakpoints from the target here.
	(target_disconnect): Comment.
	* solib.c (update_solib_list): Check for null_ptid.
	* breakpoint.c (insert_breakpoints, update_global_location_list):
	If the shared library list is shared between inferiors, insert
	breakpoints even if there's no execution.
	(breakpoint_init_inferior): If the shared library list is shared
	between inferiors, don't delete breakpoints or mark them
	uninserted here.

	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d1940 1
a1940 13
  return (ep->type == bp_catchpoint)
    || (ep->type == bp_catch_load)
    || (ep->type == bp_catch_unload);

  /* ??rehrauer: Add more kinds here, as are implemented... */
}

int
ep_is_shlib_catchpoint (struct breakpoint *ep)
{
  return
    (ep->type == bp_catch_load)
    || (ep->type == bp_catch_unload);
a2311 16
    case bp_catch_load:
      annotate_catchpoint (b->number);
      printf_filtered (_("\nCatchpoint %d (loaded %s), "),
		       b->number,
		       b->triggered_dll_pathname);
      return PRINT_SRC_AND_LOC;
      break;

    case bp_catch_unload:
      annotate_catchpoint (b->number);
      printf_filtered (_("\nCatchpoint %d (unloaded %s), "),
		       b->number,
		       b->triggered_dll_pathname);
      return PRINT_SRC_AND_LOC;
      break;

a2762 27
  /* Is this a catchpoint of a load or unload?  If so, did we
     get a load or unload of the specified library?  If not,
     ignore it. */
  if ((b->type == bp_catch_load)
#if defined(SOLIB_HAVE_LOAD_EVENT)
      && (!SOLIB_HAVE_LOAD_EVENT (PIDGET (inferior_ptid))
	  || ((b->dll_pathname != NULL)
	      && (strcmp (b->dll_pathname, 
			  SOLIB_LOADED_LIBRARY_PATHNAME (
			    PIDGET (inferior_ptid)))
		  != 0)))
#endif
      )
    return 0;
  
  if ((b->type == bp_catch_unload)
#if defined(SOLIB_HAVE_UNLOAD_EVENT)
      && (!SOLIB_HAVE_UNLOAD_EVENT (PIDGET (inferior_ptid))
	  || ((b->dll_pathname != NULL)
	      && (strcmp (b->dll_pathname, 
			  SOLIB_UNLOADED_LIBRARY_PATHNAME (
			    PIDGET (inferior_ptid)))
		  != 0)))
#endif
      )
    return 0;

a3283 10
	case bp_catch_load:
	case bp_catch_unload:
	  /* Only if this catchpoint triggered should we cause the
	     step-out-of-dld behaviour.  Otherwise, we ignore this
	     catchpoint.  */
	  if (bs->stop)
	    bs_class = catch_shlib_event;
	  else
	    bs_class = no_effect;
	  break;
a3325 61
/* Given a bpstat that records zero or more triggered eventpoints, this
   function returns another bpstat which contains only the catchpoints
   on that first list, if any. */
void
bpstat_get_triggered_catchpoints (bpstat ep_list, bpstat *cp_list)
{
  struct bpstats root_bs[1];
  bpstat bs = root_bs;
  struct breakpoint *ep;
  char *dll_pathname;

  bpstat_clear (cp_list);
  root_bs->next = NULL;

  for (; ep_list != NULL; ep_list = ep_list->next)
    {
      /* Is this eventpoint a catchpoint?  If not, ignore it. */
      ep = ep_list->breakpoint_at->owner;
      if (ep == NULL)
	break;
      if ((ep->type != bp_catch_load) &&
	  (ep->type != bp_catch_unload))
	/* pai: (temp) ADD fork/vfork here!!  */
	continue;

      /* Yes; add it to the list. */
      bs = bpstat_alloc (ep_list->breakpoint_at, bs);
      *bs = *ep_list;
      bs->next = NULL;
      bs = root_bs->next;

#if defined(SOLIB_ADD)
      /* Also, for each triggered catchpoint, tag it with the name of
         the library that caused this trigger.  (We copy the name now,
         because it's only guaranteed to be available NOW, when the
         catchpoint triggers.  Clients who may wish to know the name
         later must get it from the catchpoint itself.) */
      if (ep->triggered_dll_pathname != NULL)
	xfree (ep->triggered_dll_pathname);
      if (ep->type == bp_catch_load)
	dll_pathname = SOLIB_LOADED_LIBRARY_PATHNAME (
	                 PIDGET (inferior_ptid));
      else
	dll_pathname = SOLIB_UNLOADED_LIBRARY_PATHNAME (
	                 PIDGET (inferior_ptid));
#else
      dll_pathname = NULL;
#endif
      if (dll_pathname)
	{
	  ep->triggered_dll_pathname = (char *) 
	    xmalloc (strlen (dll_pathname) + 1);
	  strcpy (ep->triggered_dll_pathname, dll_pathname);
	}
      else
	ep->triggered_dll_pathname = NULL;
    }

  *cp_list = bs;
}

a3401 2
    {bp_catch_load, "catch load"},
    {bp_catch_unload, "catch unload"}
a3516 21
      case bp_catch_load:
      case bp_catch_unload:
	/* Field 4, the address, is omitted (which makes the columns
	   not line up too nicely with the headers, but the effect
	   is relatively readable).  */
	if (opts.addressprint)
	  ui_out_field_skip (uiout, "addr");
	annotate_field (5);
	if (b->dll_pathname == NULL)
	  {
	    ui_out_field_string (uiout, "what", "<any library>");
	    ui_out_spaces (uiout, 1);
	  }
	else
	  {
	    ui_out_text (uiout, "library \"");
	    ui_out_field_string (uiout, "what", b->dll_pathname);
	    ui_out_text (uiout, "\" ");
	  }
	break;

a3713 2
	  || b->type == bp_catch_load
	  || b->type == bp_catch_unload
a4101 2
    case bp_catch_load:
    case bp_catch_unload:
a4154 2
  b->dll_pathname = NULL;
  b->triggered_dll_pathname = NULL;
a4992 8
      case bp_catch_load:
      case bp_catch_unload:
	printf_filtered (_("Catchpoint %d (%s %s)"),
			 b->number,
			 (b->type == bp_catch_load) ? "load" : "unload",
			 (b->dll_pathname != NULL) ? 
			 b->dll_pathname : "<any library>");
	break;
a6449 95
static void
catch_load_command_1 (char *arg, int from_tty, struct cmd_list_element *command)
{
  int tempflag;
  char *dll_pathname = NULL;
  char *cond_string = NULL;

  tempflag = get_cmd_context (command) == CATCH_TEMPORARY;

  if (!arg)
    arg = "";
  ep_skip_leading_whitespace (&arg);

  /* The allowed syntax is:
     catch load
     catch load if <cond>
     catch load <filename>
     catch load <filename> if <cond>

     The user is not allowed to specify the <filename> after an
     if clause.

     We'll ignore the pathological case of a file named "if".

     First, check if there's an if clause.  If so, then there
     cannot be a filename. */
  cond_string = ep_parse_optional_if_clause (&arg);

  /* If there was an if clause, then there cannot be a filename.
     Else, there might be a filename and an if clause. */
  if (cond_string == NULL)
    {
      dll_pathname = ep_parse_optional_filename (&arg);
      ep_skip_leading_whitespace (&arg);
      cond_string = ep_parse_optional_if_clause (&arg);
    }

  if ((*arg != '\0') && !isspace (*arg))
    error (_("Junk at end of arguments."));

  /* Create a load breakpoint that only triggers when a load of
     the specified dll (or any dll, if no pathname was specified)
     occurs. */
  SOLIB_CREATE_CATCH_LOAD_HOOK (PIDGET (inferior_ptid), tempflag, 
				dll_pathname, cond_string);
}

static void
catch_unload_command_1 (char *arg, int from_tty,
			struct cmd_list_element *command)
{
  int tempflag;
  char *dll_pathname = NULL;
  char *cond_string = NULL;

  tempflag = get_cmd_context (command) == CATCH_TEMPORARY;

  if (!arg)
    arg = "";
  ep_skip_leading_whitespace (&arg);

  /* The allowed syntax is:
     catch unload
     catch unload if <cond>
     catch unload <filename>
     catch unload <filename> if <cond>

     The user is not allowed to specify the <filename> after an
     if clause.

     We'll ignore the pathological case of a file named "if".

     First, check if there's an if clause.  If so, then there
     cannot be a filename. */
  cond_string = ep_parse_optional_if_clause (&arg);

  /* If there was an if clause, then there cannot be a filename.
     Else, there might be a filename and an if clause. */
  if (cond_string == NULL)
    {
      dll_pathname = ep_parse_optional_filename (&arg);
      ep_skip_leading_whitespace (&arg);
      cond_string = ep_parse_optional_if_clause (&arg);
    }

  if ((*arg != '\0') && !isspace (*arg))
    error (_("Junk at end of arguments."));

  /* Create an unload breakpoint that only triggers when an unload of
     the specified dll (or any dll, if no pathname was specified)
     occurs. */
  SOLIB_CREATE_CATCH_UNLOAD_HOOK (PIDGET (inferior_ptid), tempflag, 
				  dll_pathname, cond_string);
}

a7116 4
  if (bpt->dll_pathname != NULL)
    xfree (bpt->dll_pathname);
  if (bpt->triggered_dll_pathname != NULL)
    xfree (bpt->triggered_dll_pathname);
a7385 2
    case bp_catch_load:
    case bp_catch_unload:
a7751 2
      case bp_catch_load:
      case bp_catch_unload:
a7881 2
      case bp_catch_load:
      case bp_catch_unload:
a8403 12
  add_catch_command ("load", _("\
Catch library loads.\n\
With an argument, catch only loads of that library."),
		     catch_load_command_1,
		     CATCH_PERMANENT,
		     CATCH_TEMPORARY);
  add_catch_command ("unload", _("\
Catch library unloads.\n\
With an argument, catch only unloads of that library."),
		     catch_unload_command_1,
		     CATCH_PERMANENT,
		     CATCH_TEMPORARY);
@


1.358
log
@        * breakpoint.h (enum bptype): Delete bp_catch_exec.
        * breakpoint.c (insert_catchpoint): Remove handling for
        bp_catch_exec breakpoint kinds.
        (insert_bp_location, update_breakpoints_after_exec, remove_breakpoint)
        (ep_is_catchpoint, print_it_typical, bpstat_check_location),
        (bpstat_check_location, bpstat_what, print_one_breakpoint_location)
        (print_one_breakpoint_location, user_settable_breakpoint)
        (breakpoint_address_is_meaningful, adjust_breakpoint_address)
        (allocate_bp_location, mention, breakpoint_re_set_one)
        (disable_command, enable_command): Likewise.
        (create_exec_event_catchpoint): Delete.
        (insert_catch_exec, remove_catch_exec, breakpoint_hit_catch_exec)
        (print_it_catch_exec, print_one_catch_exec, print_mention_catch_exec):
        New functions.
        (catch_exec_breakpoint_ops): New static global.
        (catch_exec_command_1): Use create_catchpoint instead of
        create_exec_event_catchpoint to create the exec catchpoint.
@
text
@d1266 4
a1269 1
  if (!breakpoints_always_inserted_mode () && target_has_execution)
d1713 5
d7270 4
a7273 3
  if (breakpoints_always_inserted_mode ()
      && should_insert
      && target_has_execution)
@


1.357
log
@gdb
	* varobj.c (value_get_print_value): Include valprint.h.
	(value_get_print_value): Use get_formatted_print_options.
	* value.h (struct value_print_options): Declare.
	(value_print, val_print, common_val_print, val_print_string):
	Update.
	* value.c: Include valprint.h.
	(show_values): Use get_user_print_options.
	(show_convenience): Likewise.
	* valprint.h (prettyprint_arrays, prettyprint_structs): Don't
	declare.
	(struct value_print_options): New type.
	(vtblprint, unionprint, addressprint, objectprint, print_max,
	inspect_it, repeat_count_threshold, output_format,
	stop_print_at_null): Don't declare.
	(user_print_options, get_user_print_options,
	get_raw_print_options, get_formatted_print_options): Declare.
	(print_array_indexes_p): Don't declare.
	(maybe_print_array_index, val_print_array_elements): Update.
	* valprint.c (print_max): Remove.
	(user_print_options): New global.
	(get_user_print_options, get_raw_print_options,
	get_formatted_print_options): New functions.
	(print_array_indexes, repeat_count_threshold, stop_print_at_null,
	prettyprint_structs, prettyprint_arrays, unionprint,
	addressprint): Remove.
	(val_print): Remove format, deref_ref, pretty arguments; add
	options.  Update.
	(common_val_print): Likewise.
	(print_array_indexes_p): Remove.
	(maybe_print_array_index): Remove format, pretty arguments; add
	options.  Update.
	(val_print_array_elements): Remove format, deref_ref, pretty
	arguments; add options.  Update.
	(val_print_string): Add options argument.  Update.
	(_initialize_valprint): Use user_print_options.
	(output_format): Remove.
	(set_output_radix_1): Use user_print_options.
	* typeprint.c: Include valprint.h.
	(objectprint): Don't declare.
	(whatis_exp): Use get_user_print_options.
	* tui/tui-regs.c: Include valprint.h.
	(tui_register_format): Use get_formatted_print_options.
	* tracepoint.c: Include valprint.h.
	(addressprint): Don't declare.
	(trace_mention): Use get_user_print_options.
	(tracepoints_info): Likewise.
	* stack.c (print_frame_args): Use get_raw_print_options.
	(print_frame_info): Use get_user_print_options.
	(print_frame): Likewise.
	* sh64-tdep.c: Include valprint.h
	(sh64_do_register): Use get_formatted_print_options.
	* scm-valprint.c (scm_inferior_print): Remove format, deref_ref,
	pretty arguments; add options.
	(scm_scmlist_print): Likewise.  Update.
	(scm_scmval_print): Likewise.
	(scm_val_print): Likewise.
	(scm_value_print): Remove format, pretty arguments; add options.
	Update.
	* scm-lang.h (scm_value_print, scm_val_print, scm_scmval_print):
	Update.
	* scm-lang.c (scm_printstr): Add options argument.
	* python/python-value.c: Include valprint.h.
	(valpy_str): Use get_user_print_options.
	* printcmd.c: Include valprint.h.
	(addressprint): Don't declare.
	(inspect_it): Remove.
	(print_formatted): Remove format option; add options.  Update.
	(print_scalar_formatted): Likewise.
	(print_address_demangle): Use get_user_print_options.
	(do_examine): Use get_formatted_print_options.
	(print_command_1): Likewise.
	(output_command): Use get_formatted_print_options.
	(do_one_display): Likewise.
	(print_variable_value): Use get_user_print_options.
	* p-valprint.c (pascal_val_print): Remove format, deref_ref,
	pretty arguments; add options.  Update.
	(pascal_value_print): Remove format, pretty arguments; add
	options.  Update.
	(vtblprint, objectprint): Don't declare.
	(pascal_static_field_print): Remove.
	(pascal_object_print_value_fields): Remove format, pretty
	arguments; add options.  Update.
	(pascal_object_print_static_field): Likewise.
	(_initialize_pascal_valprint): Use user_print_options.  Update.
	* p-lang.h (pascal_val_print, pascal_value_print,
	pascal_printstr, pascal_object_print_value_fields): Update.
	(vtblprint, static_field_print): Don't declare.
	* p-lang.c (pascal_printstr): Add options argument.  Update.
	* objc-lang.c (objc_printstr): Add options argument.  Update.
	* mt-tdep.c: Include valprint.h.
	(mt_registers_info): Use get_raw_print_options.
	* mips-tdep.c: Include valprint.h.
	(mips_print_fp_register): Use get_formatted_print_options.
	(mips_print_register): Likewise.
	* mi/mi-main.c: Include valprint.h.
	(get_register): Use get_user_print_options.
	(mi_cmd_data_evaluate_expression): Likewise.
	(mi_cmd_data_read_memory): Use get_formatted_print_options.
	* mi/mi-cmd-stack.c: Include valprint.h.
	(list_args_or_locals): Use get_raw_print_options.
	* m2-valprint.c (print_function_pointer_address): Add addressprint
	argument.
	(m2_print_long_set): Remove format, pretty arguments.
	(m2_print_unbounded_array): Remove format, deref_ref, pretty
	arguments; add options.  Update.
	(print_unpacked_pointer): Remove format argument; add options.
	Now static.  Update.
	(print_variable_at_address): Remove format, deref_ref, pretty
	arguments; add options.  Update.
	(m2_print_array_contents): Likewise.
	(m2_val_print): Likewise.
	* m2-lang.h (m2_val_print): Update.
	* m2-lang.c (m2_printstr): Add options argument. Update.
	* language.h (struct value_print_options): Declare.
	(struct language_defn) <la_printstr>: Add options argument.
	<la_val_print>: Remove format, deref_ref, pretty argument; add
	options.
	<la_value_print>: Remove format, pretty arguments; add options.
	<la_print_array_index>: Likewise.
	(LA_VAL_PRINT, LA_VALUE_PRINT, LA_PRINT_STRING,
	LA_PRINT_ARRAY_INDEX): Update.
	(default_print_array_index): Update.
	* language.c (default_print_array_index): Remove format, pretty
	arguments; add options.  Update.
	(unk_lang_printstr): Add options argument.
	(unk_lang_val_print): Remove format, deref_ref, pretty arguments;
	add options.
	(unk_lang_value_print): Remove format, pretty arguments; add
	options.
	* jv-valprint.c (java_value_print): Remove format, pretty
	arguments; add options.  Update.
	(java_print_value_fields): Likewise.
	(java_val_print): Remove format, deref_ref, pretty arguments; add
	options.  Update.
	* jv-lang.h (java_val_print, java_value_print): Declare.
	* infcmd.c: Include valprint.h.
	(print_return_value): Use get_raw_print_options.
	(default_print_registers_info): Use get_user_print_options,
	get_formatted_print_options.
	(registers_info): Use get_formatted_print_options.
	* gdbtypes.h (struct value_print_options): Declare.
	(print_scalar_formatted): Update.
	* f-valprint.c (f77_print_array_1): Remove format, deref_ref,
	pretty arguments; add options.  Update.
	(f77_print_array): Likewise.
	(f_val_print): Likewise.
	* f-lang.h (f_val_print): Update.
	* f-lang.c (f_printstr): Add options argument.  Update.
	(c_value_print): Update declaration.
	* expprint.c: Include valprint.h.
	(print_subexp_standard): Use get_raw_print_options,
	get_user_print_options.
	* eval.c: Include valprint.h.
	(objectprint): Don't declare.
	(evaluate_subexp_standard): Use get_user_print_options.
	* cp-valprint.c (vtblprint, objectprint, static_field_print):
	Remove.
	(cp_print_value_fields): Remove format, pretty arguments; add
	options.  Update.
	(cp_print_value): Likewise.
	(cp_print_static_field): Likewise.
	(_initialize_cp_valprint): Use user_print_options.  Update.
	* c-valprint.c (print_function_pointer_address): Add addressprint
	argument.
	(c_val_print): Remove format, deref_ref, pretty arguments; add
	options.  Update.
	(c_value_print): Add options argument.  Update.
	* c-lang.h (c_val_print, c_value_print, c_printstr): Update.
	(vtblprint, static_field_print): Don't declare.
	(cp_print_value_fields): Update.
	* c-lang.c (c_printstr): Add options argument.  Update.
	* breakpoint.c: Include valprint.h.
	(addressprint): Don't declare.
	(watchpoint_value_print): Use get_user_print_options.
	(print_one_breakpoint_location): Likewise.
	(breakpoint_1, print_it_catch_fork, print_it_catch_vfork, mention,
	print_exception_catchpoint): Likewise.
	* auxv.c (fprint_target_auxv): Don't declare addressprint.  Use
	get_user_print_options.
	* ada-valprint.c (struct ada_val_print_args): Remove format,
	deref_ref, and pretty; add options.
	(print_optional_low_bound): Add options argument.
	(val_print_packed_array_elements): Remove format and pretty
	arguments; add options.  Update.
	(printstr): Add options argument.  Update.
	(ada_printstr): Likewise.
	(ada_val_print): Remove format, deref_ref, pretty arguments; add
	options argument.  Update.
	(ada_val_print_stub): Update.
	(ada_val_print_array): Remove format, deref_ref, pretty arguments;
	add options.  Update.
	(ada_val_print_1): Likewise.
	(print_variant_part): Likewise.
	(ada_value_print): Remove format, pretty arguments; add options.
	Update.
	(print_record): Likewise.
	(print_field_values): Likewise.
	* ada-lang.h (ada_val_print, ada_value_print, ada_printstr):
	Update.
	* ada-lang.c (ada_print_array_index): Add options argument; remove
	format and pretty arguments.
	(print_one_exception): Use get_user_print_options.
gdb/testsuite
	* gdb.base/exprs.exp (test_expr): Add enum formatting tests.
@
text
@d793 4
a796 13
  switch (b->type)
    {
    case bp_catchpoint:
      gdb_assert (b->ops != NULL && b->ops->insert != NULL);
      b->ops->insert (b);
      break;
    case bp_catch_exec:
      target_insert_exec_catchpoint (PIDGET (inferior_ptid));
      break;
    default:
      internal_error (__FILE__, __LINE__, _("unknown breakpoint type"));
      break;
    }
d1231 1
a1231 2
  else if (bpt->owner->type == bp_catchpoint
	   || bpt->owner->type == bp_catch_exec)
a1494 7
    /* Don't delete an exec catchpoint, because else the inferior
       won't stop when it ought!  */
    if (b->type == bp_catch_exec)
      {
	continue;
      }

a1675 18
  else if (b->owner->type == bp_catch_exec
	   && breakpoint_enabled (b->owner)
	   && !b->duplicate)
    {
      val = -1;
      switch (b->owner->type)
	{
	case bp_catch_exec:
	  val = target_remove_exec_catchpoint (PIDGET (inferior_ptid));
	  break;
	default:
	  warning (_("Internal error, %s line %d."), __FILE__, __LINE__);
	  break;
	}
      if (val)
	return val;
      b->inserted = (is == mark_inserted);
    }
d1934 1
a1934 2
    || (ep->type == bp_catch_unload)
    || (ep->type == bp_catch_exec);
a2331 8
    case bp_catch_exec:
      annotate_catchpoint (b->number);
      printf_filtered (_("\nCatchpoint %d (exec'd %s), "),
		       b->number,
		       b->exec_pathname);
      return PRINT_SRC_AND_LOC;
      break;

d2750 1
a2750 2
      && b->type != bp_catchpoint
      && b->type != bp_catch_exec)	/* a non-watchpoint bp */
a2816 4
  if ((b->type == bp_catch_exec)
      && !inferior_has_execd (inferior_ptid, &b->exec_pathname))
    return 0;

a3341 1
	case bp_catch_exec:
d3521 1
a3521 2
    {bp_catch_unload, "catch unload"},
    {bp_catch_exec, "catch exec"}
a3657 15
      case bp_catch_exec:
	/* Field 4, the address, is omitted (which makes the columns
	   not line up too nicely with the headers, but the effect
	   is relatively readable).  */
	if (opts.addressprint)
	  ui_out_field_skip (uiout, "addr");
	annotate_field (5);
	if (b->exec_pathname != NULL)
	  {
	    ui_out_text (uiout, "program \"");
	    ui_out_field_string (uiout, "what", b->exec_pathname);
	    ui_out_text (uiout, "\" ");
	  }
	break;

a3856 1
	  || b->type == bp_catch_exec
d4066 1
a4066 2
      bp_catchpoint
      bp_catch_exec */
d4077 1
a4077 2
	  && type != bp_catchpoint
	  && type != bp_catch_exec);
d4192 1
a4192 2
           || bptype == bp_catchpoint
           || bptype == bp_catch_exec)
a4258 1
    case bp_catch_exec:
d4871 29
d4901 1
a4901 1
create_exec_event_catchpoint (int tempflag, char *cond_string)
d4903 1
a4903 3
  struct symtab_and_line sal;
  struct breakpoint *b;
  int thread = -1;		/* All threads. */
d4905 1
a4905 4
  init_sal (&sal);
  sal.pc = 0;
  sal.symtab = NULL;
  sal.line = 0;
d4907 14
a4920 10
  b = set_raw_breakpoint (sal, bp_catch_exec);
  set_breakpoint_count (breakpoint_count + 1);
  b->number = breakpoint_count;
  b->cond_string = (cond_string == NULL) ?
    NULL : savestring (cond_string, strlen (cond_string));
  b->thread = thread;
  b->addr_string = NULL;
  b->enable_state = bp_enabled;
  b->disposition = tempflag ? disp_del : disp_donttouch;
  update_global_location_list (1);
d4922 4
a4925 1
  mention (b);
d4928 10
a5147 4
      case bp_catch_exec:
	printf_filtered (_("Catchpoint %d (exec)"),
			 b->number);
	break;
d6602 1
a6602 1
  create_exec_event_catchpoint (tempflag, cond_string);
a7740 1
    case bp_catch_exec:
a8008 1
      case bp_catch_exec:
a8140 1
      case bp_catch_exec:
@


1.356
log
@2008-10-17  Michael Snyder  <msnyder@@vmware.com>
	Target interface for reverse debugging.
	* target.h (enum target_waitkind):
	Add new wait event, TARGET_WAITKIND_NO_HISTORY.
	(struct target_ops): New method to_can_execute_reverse.
	(target_can_execute_reverse): New macro.
	* target.c (update_current_target): Inherit to_can_execute_reverse.

	Remote interface for reverse debugging.
	* remote.c (remote_can_execute_reverse): New target method.
	(remote_resume): Check for reverse exec direction, and send
	appropriate command to target.
	(remote_wait_as): Check target response for NO_HISTORY status.
	Also check for empty reply (target doesn't understand "bs" or "bc).
	(remote_vcont_resume): Jump out if attempting reverse execution.

	Event handling interface for reverse debugging.
	* infrun.c (execution_direction): New state variable.
	(enum inferior_stop_reason): Add NO_HISTORY reason.
	(handle_inferior_event): Handle TARGET_WAITKIND_NO_HISTORY.
	Handle stepping over a function call in reverse.
	Handle stepping thru a line range in reverse.
	Handle setting a step-resume breakpoint in reverse.
	Handle stepping into a function in reverse.
	Handle stepping between line ranges in reverse.
	(print_stop_reason): Print reason for NO_HISTORY.
	(step_into_function): Rename to handle_step_into_function.
	(handle_step_into_function_backward): New function.
	(set_exec_direction_func, show_exec_direction_func): New funcs.
	(proceed): No need to singlestep over a breakpoint
	when resuming in reverse.

	* inferior.h (enum exec_direction_kind): New enum.
	(execution_direction): Export new execution state variable.

	* breakpoint.c (make_breakpoint_silent): New function.
	* breakpoint.h (make_breakpoint_silent): Export.
	* infcmd.c (finish_command): Check for reverse exec direction.
	(finish_backward): New function, handle finish cmd in reverse.

	User interface for reverse execution.
	* Makefile.in (reverse.c): New file.
	* reverse.c: New file.  User interface for reverse execution.
@
text
@d59 1
a286 2
extern int addressprint;	/* Print machine addresses? */

d2261 5
a2265 1
    value_print (val, stream, 0, Val_pretty_default);
d3583 3
d3649 1
a3649 1
  if (addressprint)
d3681 1
a3681 1
	if (addressprint)
d3693 1
a3693 1
	if (addressprint)
d3713 1
a3713 1
	if (addressprint)
d3736 1
a3736 1
	if (addressprint)
d3942 1
d3944 2
d3956 1
a3956 1
  if (addressprint)
d3979 1
a3979 1
  if (addressprint)
d4772 4
d4779 1
a4779 1
  if (addressprint)
d4854 3
d4860 1
a4860 1
  if (addressprint)
d5091 3
d5206 1
a5206 1
	  if (addressprint || b->source_file == NULL)
d6768 3
a6770 1
  if (addressprint)
@


1.355
log
@        * breakpoint.h (enum bptype): New enum bp_catchpoint.
        Delete bp_catch_fork and bp_catch_vfork.
        (struct breakpoint_ops): Add new methods "insert", "remove"
        and "breakpoint_hit".
        * breakpoint.c (create_fork_vfork_event_catchpoint)
        (create_fork_event_catchpoint, create_vfork_event_catchpoint): Remove.
        (insert_catchpoint): Remove handling of bp_catch_fork and
        bp_catch_vfork catchpoints, and handle them as bp_catchpoint
        catchpoints instead.
        (insert_bp_location, update_breakpoints_after_exec)
        (remove_breakpoint, bpstat_check_location, bpstat_what)
        (allocate_bp_location): Likewise.
        (print_it_typical, print_one_breakpoint_location, mention): Remove
        handling of bp_catch_fork and bp_catch_vfork breakpoints.
        (ep_is_catchpoint, user_settable_breakpoint)
        (breakpoint_address_is_meaningful, adjust_breakpoint_address)
        (breakpoint_re_set_one, disable_command, enable_command):
        Remove use of bp_catch_fork and bp_catch_vfork.  Add handling of
        bp_catchpoint breakpoints.
        (insert_catch_fork, remove_catch_fork, breakpoint_hit_catch_fork)
        (print_it_catch_fork, print_one_catch_fork, print_mention_catch_fork):
        New functions.
        (catch_fork_breakpoint_ops): New static constant.
        (insert_catch_vfork, remove_catch_vfork, breakpoint_hit_catch_vfork)
        (print_it_catch_vfork, print_one_catch_vfork)
        (print_mention_catch_vfork): New functions.
        (catch_vfork_breakpoint_ops): New static constant.
        (create_catchpoint, create_fork_vfork_event_catchpoint): New functions.
        (catch_fork_command_1): Use create_fork_vfork_event_catchpoint
        to create the fork and vfork catchpoints.
        (gnu_v3_exception_catchpoint_ops): Set new breakpoint_ops fields.
        * ada-lang.c (catch_exception_breakpoint_ops): Set new breakpoint_ops
        fields.
        (catch_exception_unhandled_breakpoint_ops): Likewise.
        (catch_assert_breakpoint_ops): Likewise.
@
text
@d7866 7
@


1.354
log
@gdb/
*	breakpoint.c (breakpoint_init_inferior): Clean up the moribund
	locations list.
	(moribund_breakpoint_here_p): Record the moribund
	location in the moribund_locations vector.
	* breakpoint.h (moribund_breakpoint_here_p): Declare.
	(displaced_step_fixup): Check if the breakpoint the thread was
	trying to step over has been removed since having been placed in
	the displaced stepping queue.
	(adjust_pc_after_break): In non-stop mode, check for a moribund
	breakpoint at the stop pc.
	(handle_inferior_event): Don't retire moribund breakpoints on
	TARGET_WAITKIND_IGNORE.

gdb/testsuite/
	* gdb.mi/mi-nsmoribund.exp, gdb.mi/nsmoribund.c: New test.
@
text
@a161 4
static void create_fork_vfork_event_catchpoint (int tempflag,
						char *cond_string,
						enum bptype bp_kind);

d796 3
a798 5
    case bp_catch_fork:
      target_insert_fork_catchpoint (PIDGET (inferior_ptid));
      break;
    case bp_catch_vfork:
      target_insert_vfork_catchpoint (PIDGET (inferior_ptid));
d1241 1
a1241 2
  else if (bpt->owner->type == bp_catch_fork
	   || bpt->owner->type == bp_catch_vfork
d1497 9
d1507 2
a1508 10
       won't stop when it ought!

       Similarly, we probably ought to keep vfork catchpoints, 'cause
       on this target, we may not be able to stop when the vfork is
       seen, but only when the subsequent exec is seen.  (And because
       deleting fork catchpoints here but not vfork catchpoints will
       seem mysterious to users, keep those too.)  */
    if ((b->type == bp_catch_exec) ||
	(b->type == bp_catch_vfork) ||
	(b->type == bp_catch_fork))
d1683 12
a1694 3
  else if ((b->owner->type == bp_catch_fork ||
	    b->owner->type == bp_catch_vfork ||
	    b->owner->type == bp_catch_exec)
a1700 6
	case bp_catch_fork:
	  val = target_remove_fork_catchpoint (PIDGET (inferior_ptid));
	  break;
	case bp_catch_vfork:
	  val = target_remove_vfork_catchpoint (PIDGET (inferior_ptid));
	  break;
d1968 2
a1969 2
  return
    (ep->type == bp_catch_load)
a1970 2
    || (ep->type == bp_catch_fork)
    || (ep->type == bp_catch_vfork)
a2364 16
    case bp_catch_fork:
      annotate_catchpoint (b->number);
      printf_filtered (_("\nCatchpoint %d (forked process %d), "),
		       b->number, 
		       ptid_get_pid (b->forked_inferior_pid));
      return PRINT_SRC_AND_LOC;
      break;

    case bp_catch_vfork:
      annotate_catchpoint (b->number);
      printf_filtered (_("\nCatchpoint %d (vforked process %d), "),
		       b->number, 
		       ptid_get_pid (b->forked_inferior_pid));
      return PRINT_SRC_AND_LOC;
      break;

d2791 1
a2791 2
      && b->type != bp_catch_fork
      && b->type != bp_catch_vfork
d2824 1
a2824 1
  
d2852 7
a2858 10
  if ((b->type == bp_catch_fork)
      && !inferior_has_forked (inferior_ptid,
			       &b->forked_inferior_pid))
    return 0;
  
  if ((b->type == bp_catch_vfork)
      && !inferior_has_vforked (inferior_ptid,
				&b->forked_inferior_pid))
    return 0;
  
d3387 1
a3387 2
	case bp_catch_fork:
	case bp_catch_vfork:
d3566 1
a3568 2
    {bp_catch_fork, "catch fork"},
    {bp_catch_vfork, "catch vfork"},
a3702 17
      case bp_catch_fork:
      case bp_catch_vfork:
	/* Field 4, the address, is omitted (which makes the columns
	   not line up too nicely with the headers, but the effect
	   is relatively readable).  */
	if (addressprint)
	  ui_out_field_skip (uiout, "addr");
	annotate_field (5);
	if (!ptid_equal (b->forked_inferior_pid, null_ptid))
	  {
	    ui_out_text (uiout, "process ");
	    ui_out_field_int (uiout, "what",
			      ptid_get_pid (b->forked_inferior_pid));
	    ui_out_spaces (uiout, 1);
	  }
	break;

d3914 1
a3916 2
	  || b->type == bp_catch_fork
	  || b->type == bp_catch_vfork
d4124 2
a4125 3
      bp_catch_exec
      bp_catch_fork
      bp_catch_vork */
d4136 2
a4137 3
	  && type != bp_catch_exec
	  && type != bp_catch_fork
	  && type != bp_catch_vfork);
d4252 1
a4252 2
           || bptype == bp_catch_fork
           || bptype == bp_catch_vfork
d4319 1
a4319 2
    case bp_catch_fork:
    case bp_catch_vfork:
d4720 40
d4761 127
a4887 2
create_fork_vfork_event_catchpoint (int tempflag, char *cond_string,
				    enum bptype bp_kind)
a4890 1
  int thread = -1;		/* All threads. */
d4897 1
a4897 1
  b = set_raw_breakpoint (sal, bp_kind);
d4900 1
d4903 1
a4903 1
  b->thread = thread;
d4907 3
a4909 1
  b->forked_inferior_pid = null_ptid;
d4912 1
a4912 2

  mention (b);
d4916 2
a4917 1
create_fork_event_catchpoint (int tempflag, char *cond_string)
d4919 1
a4919 2
  create_fork_vfork_event_catchpoint (tempflag, cond_string, bp_catch_fork);
}
d4921 3
a4923 4
static void
create_vfork_event_catchpoint (int tempflag, char *cond_string)
{
  create_fork_vfork_event_catchpoint (tempflag, cond_string, bp_catch_vfork);
a5158 6
      case bp_catch_fork:
      case bp_catch_vfork:
	printf_filtered (_("Catchpoint %d (%s)"),
			 b->number,
			 (b->type == bp_catch_fork) ? "fork" : "vfork");
	break;
d6579 2
a6580 1
      create_fork_event_catchpoint (tempflag, cond_string);
d6584 2
a6585 1
      create_vfork_event_catchpoint (tempflag, cond_string);
d6782 3
d7753 1
a7753 2
    case bp_catch_fork:
    case bp_catch_vfork:
d8013 1
a8015 2
      case bp_catch_fork:
      case bp_catch_vfork:
d8146 1
a8148 2
      case bp_catch_fork:
      case bp_catch_vfork:
@


1.353
log
@	Remove dead code.

	* breakpoint.c (show_breakpoint_hit_counts): Delete.
	(print_one_breakpoint_location): Adjust.
	(breakpoint_clear_ignore_counts): Delete.
	* breakpoint.h (breakpoint_clear_ignore_counts): Remove
	declaration.
	* target.c (generic_mourn_inferior): Don't clear ignore
	counts (never reached).
@
text
@d1747 1
d1790 5
d1837 14
d7130 2
a7131 2
	{	      
	  if (removed)
d7139 1
a7139 1
		 The theory here is that reporting of events should, 
d7142 1
a7142 1
		 longer need to keep this breakpoint.  This is just a 
d7144 1
a7144 1
		 which is usability issue, but not a correctness problem.  */	  
d7147 2
d7150 2
a7151 2

	  free_bp_location (loc);
d7154 1
a7154 1
    
@


1.352
log
@	* breakpoint.c (bpstat_stop_status): Clear breakpoint_at for
	all hardware bpstats.
@
text
@a317 4
/* True if breakpoint hit counts should be displayed in breakpoint info.  */

int show_breakpoint_hit_counts = 1;

d3811 1
a3811 1
  if (!part_of_multiple && show_breakpoint_hit_counts && b->hit_count)
d3829 1
a3829 1
    if (!part_of_multiple && show_breakpoint_hit_counts && b->hit_count == 0)
a7729 10
/* Clear the ignore counts of all breakpoints.  */
void
breakpoint_clear_ignore_counts (void)
{
  struct breakpoint *b;

  ALL_BREAKPOINTS (b)
    b->ignore_count = 0;
}

@


1.352.2.1
log
@2008-09-30  Michael Snyder  <msnyder@@vmware.com>

	* breakpoint.h (breakpoint_silence): Export.
	* breakpoint.c (breakpoint_silence): New function.
	* infcmd.c (finish_command): Check for reverse exec direction.
	(finish_backward): New function, handle finish cmd in reverse.
@
text
@a7743 7
void
breakpoint_silence (struct breakpoint *b)
{
  /* Silence the breakpoint.  */
  b->silent = 1;
}

@


1.352.2.2
log
@2008-10-06  Michael Snyder  <msnyder@@vmware.com>

	* breakpoint.c (breakpoint_silence): Rename to make_breakpoint_silent.
	* breakpoint.h: Ditto.
	* infcmd.c (finish_backward): Call make_breakpoint_silent
	instead of breakpoint_silence.
@
text
@d7745 1
a7745 1
make_breakpoint_silent (struct breakpoint *b)
@


1.351
log
@	* defs.h (struct gdbarch): Add forward declaration.
	(set_next_address): Add GDBARCH argument.
	* printcmd.c (set_next_address): Use it to find pointer type.
	* breakpoint.c (breakpoint_1): Update call.
	* source.c (line_info): Likewise.
	* findcmd.c (find_command): Use current_gdbarch to find pointer type.

	* breakpoint.c (set_breakpoint_count): Use platform-neutral
	types for internal variable values.
	* infrun.c (handle_inferior_event): Likewise.
	* source.c (forward_search_command, reverse_search_command): Likewise.
	* tracepoint.c (set_tracepoint_count, set_traceframe_num,
	set_tracepoint_num, set_traceframe_context): Likewise.
@
text
@d3057 1
d3150 1
d3163 1
a3163 3
	  remove_breakpoints ();
	  insert_breakpoints ();
	  break;
d3166 6
@


1.350
log
@	Remove global continuations in favour of a per-thread
	continuations.

	* gdbthread.h (struct thread_info): Add comments around
	continuations and intermediate_continuations.
	(save_infrun_state, load_infrun_state): Delete continuations and
	intermediate_continuations arguments.
	* infrun.c (fetch_inferior_event): Only call normal_stop if
	stop_soon is NO_STOP_QUIETLY.
	(context_switch): Don't context-switch the continuations.
	* thread.c (clear_thread_inferior_resources): Discard all
	continuations of the thread we're clearing.
	(save_infrun_state, load_infrun_state): Delete continuations and
	intermediate_continuations arguments, and the code referencing
	them.
	* utils.c: Include "gdbthread.h".
	(cmd_continuation, intermediate_continuation): Delete.
	(add_continuation): Add thread_info* argument.  Install the
	continuation on it.
	(restore_thread_cleanup): New.
	(do_all_continuations_ptid, do_all_continuations_thread_callback):
	New.
	(do_all_continuations): Reimplement.
	(discard_all_continuations_thread_callback,
	discard_all_continuations_thread): New.
	(discard_all_continuations): Reimplement.
	(add_intermediate_continuation): Add thread_info* argument.
	Install the continuation on it.
	(do_all_intermediate_continuations_thread_callback)
	(do_all_intermediate_continuations_thread): New.
	(do_all_intermediate_continuations): Reimplement.
	(discard_all_intermediate_continuations_thread_callback): New.
	(discard_all_intermediate_continuations_thread): New.
	(discard_all_intermediate_continuations): Reimplement.

	* breakpoint.c (until_break_command): Install the continuation on
	the current thread.

	* defs.h (cmd_continuation, intermediate_continuation): Delete.
	(struct thread_info): Forward declare.
	(add_continuation, add_intermediate_continuation): Add
	thread_info* argument.
	(do_all_continuations_thread, discard_all_continuations_thread)
	(do_all_intermediate_continuations_thread)
	(discard_all_intermediate_continuations_thread): Declare.
	* inf-loop.c (inferior_event_handler): In non-stop only run
	continuations on the thread that stopped.  In all-stop, run
	continuations on all threads.
	* infcmd.c (step_once, finish_command): Adjust.
@
text
@d404 1
a404 1
		   value_from_longest (builtin_type_int, (LONGEST) num));
d4034 1
a4034 1
	set_next_address (last_addr);
@


1.349
log
@	* inferior.h (stop_bpstat): Delete.

	* breakpoint.h (bpstat_do_actions): Remove bpstat* argument.

	* breakpoint.c (bpstat_do_actions): Rename to ...
	(bpstat_do_actions_1): ... this.  Make static.  Change return type
	to int.  Return true if a breakpoint proceeded.
	(bpstat_do_actions): New, as wrapper around bpstat_do_actions_1.
	(delete_breakpoint): Don't reference the global stop_bpstat; it's
	gone.

	* gdbthread.h (struct thread_info): Add stop_bpstat.
	(save_infrun_state, load_infrun_state): Remove stop_bpstat
	argument.
	* thread.c (load_infrun_state, save_infrun_state): Remove
	stop_bpstat argument, and the code referencing it.

	* infcall.c: Include "gdbthread.h".
	(call_function_by_hand): Adjust.
	* exceptions.c: Include "gdbthread.h".
	(throw_exception): Adjust.
	* infcmd.c (stop_bpstat): Delete.
	(continue_command): In all-stop, set the ignore count on the
	thread that reported the stop.  In non-stop, set it on the current
	thread.
	(finish_command_continuation): Adjust.
	(program_info): Adjust.
	* infrun.c (clear_proceed_status): Adjust.
	(context_switch): Don't context-switch stop_bpstat.
	(handle_inferior_event): Adjust.
	(normal_stop): Adjust.
	(save_inferior_status, restore_inferior_status): Adjust.

	* inf-loop.c (inferior_event_handler): Remove parameter to
	bpstat_do_actions call.
	* top.c (command_loop): Remove parameter to bpstat_do_actions
	call.  Call it unconditionally.
	* event-top.c (command_handler): Ditto.
	* python/python.c (execute_gdb_command): Ditto.
@
text
@d6323 2
a6324 1
      add_continuation (until_break_command_continuation, args,
@


1.348
log
@	* breakpoint.h (struct bp_location): Change type of section
	member to "struct obj_section *".
	* tracepoint.h (struct tracepoint): Likewise.
	* symtab.h (struct general_symbol_info): Replace bfd_section
	member with obj_section.
	(struct symtab_and_line): Change type of section member to
	"struct obj_section *".
	(SYMBOL_BFD_SECTION): Remove macro, replace by ...
	(SYMBOL_OBJ_SECTION): ... this.

	* minsym.c (prim_record_minimal_symbol_and_info): Record symbol
	section as obj_section instead of bfd_section.

	* ada-lang.c (ada_decode_symbol): Use gsymbol->obj_section
	directly instead of looking of obj_section from bfd_section.

	* objfiles.h (find_pc_sect_section): Remove.
	* objfiles.c (find_pc_sect_section): Remove.
	(find_pc_section): Inline find_pc_sect_section code.

	* symfile.h (find_pc_overlay): Return struct obj_section *.
	(find_pc_mapped_section): Likewise.
	(section_is_overlay, section_is_mapped): Change type of section
	argument to struct obj_section *.
	(pc_in_mapped_range, pc_in_unmapped_range): Likewise.
	(overlay_mapped_address, overlay_unmapped_address): Likewise.
	(symbol_overlayed_address): Likewise.
	* symtab.h (symbol_overlayed_address): Likewise.
	* symfile.c (overlay_is_mapped): Remove.
	(section_is_mapped): Inline overlay_is_mapped code.  Update.
	(overlay_invalidate_all): Update.
	(section_is_overlay): Change section argument to type
	"struct obj_section *".  Use bfd_ methods.
	(pc_in_unmapped_range): Likewise.  Handle relocated sections.
	(pc_in_mapped_range): Likewise.  Handle relocated sections.
	(sections_overlap): Likewise.
	(overlay_unmapped_address): Likewise.
	(overlay_mapped_address): Likewise.
	(symbol_overlayed_address): Likewise.
	(find_pc_overlay): Return struct obj_section *.
	(find_pc_mapped_section): Likewise.
	(list_overlays_command): Update.
	(map_overlay_command, unmap_overlay_command): Update.
	(simple_overlay_update): Update.

	* block.h (blockvector_for_pc_sect): Change section argument
	to type "struct obj_section *".
	(block_for_pc_sect): Likewise.
	* block.c (blockvector_for_pc_sect): Change section argument
	to type "struct obj_section *".
	(block_for_pc_sect): Likewise.
	* symtab.h (find_pc_sect_function, find_pc_sect_psymtab,
	find_pc_sect_symtab, find_pc_sect_psymbol, find_pc_sect_line,
	lookup_minimal_symbol_by_pc_section, find_function_start_pc): Likewise.
	(matching_bfd_sections): Rename to ...
	(matching_obj_sections): ... this.  Update argument types.
	* blockframe.c (find_pc_sect_function): Likewise.
	* breakpoint.c (describe_other_breakpoints): Likewise.
	(breakpoint_has_pc, check_duplicates_for): Likewise.
	* minsyms.c (lookup_minimal_symbol_by_pc_section_1): Likewise.
	(lookup_minimal_symbol_by_pc_section): Likewise.
	* symtab.c (find_pc_sect_psymtab_closer): Likewise.
	(find_pc_sect_psymtab, find_pc_sect_psymbol, find_pc_sect_symtab,
	find_pc_sect_line, find_function_start_pc): Likewise.
	(matching_bfd_sections): Rename to ...
	(matching_obj_sections): ... this.  Update argument types.

	* blockframe.c (find_pc_partial_function): Update to section
	type changes.  No longer call find_pc_sect_section.
	(cache_pc_function_section): Change to type "struct obj_section *".
	* breakpoint.c (resolve_sal_pc): Update to section type changes.
	* exec.c (xfer_memory): Likewise.
	* findvar.c (read_var_value): Likewise.
	* infcmd.c (jump_command): Likewise.
	* linespec.c (minsym_found): Likewise.
	* maint.c (maintenance_translate_address): Likewise.
	* minsyms.c (lookup_minimal_symbol_by_pc_section_1): Likewise.
	(lookup_solib_trampoline_symbol_by_pc): Likewise.
	* parse.c (write_exp_msymbol): Likewise.
	* printcmd.c (build_address_symbolic): Likewise.
	(address_info, sym_info): Likewise.
	* symmisc.c (dump_msymbols, print_symbol): Likewise.
	* symtab.c (fixup_section): Likewise.
	(fixup_symbol_section, fixup_psymbol_section): Likewise.
	(find_pc_line, find_function_start_sal): Likewise.
	* target.c (memory_xfer_partial): Likewise.
	* hppa-hpux-tdep.c (hppa64_hpux_in_solib_call_trampoline): Likewise.
	* spu-tdep.c (spu_overlay_update): Likewise.
@
text
@d2141 1
a2141 1
   the global "breakpoint_proceeded" after each command.  */
d2143 6
a2148 2
void
bpstat_do_actions (bpstat *bsp)
d2152 1
d2157 1
a2157 1
    return;
a2161 9
top:
  /* Note that (as of this writing), our callers all appear to
     be passing us the address of global stop_bpstat.  And, if
     our calls to execute_control_command cause the inferior to
     proceed, that global (and hence, *bsp) will change.

     We must be careful to not touch *bsp unless the inferior
     has not proceeded. */

d2201 4
a2204 5
	  /* If we are in async mode, then the target might
	     be still running, not stopped at any breakpoint,
	     so nothing for us to do here -- just return to
	     the event loop.  */
	    break;
d2208 13
a2220 13
	       Breakpoint commands for that stop were not run,
	       since execute_command does not run breakpoint
	       commands -- only command_line_handler does, but
	       that one is not involved in execution of breakpoint
	       commands.  So, we can now execute breakpoint commands.
	       There's an implicit assumption that we're called with
	       stop_bpstat, so our parameter is the new bpstat to
	       handle.  
	       It should be noted that making execute_command do
	       bpstat actions is not an option -- in this case we'll
	       have recursive invocation of bpstat for each breakpoint
	       with a command, and can easily blow up GDB stack.  */
	    goto top;
d2224 17
a7255 3
  /* Clear the current context.  */
  bpstat_remove_breakpoint (stop_bpstat, bpt);
  /* And from all threads.  */
@


1.347
log
@
	* breakpoint.c (breakpoint_init_inferior): Mark as not inserted only
	non-permanent breakpoints.
	(bpstat_stop_status): Change enable_state to bp_disabled only for
	non-permanent breakpoints.
	(bp_loc_is_permanent): New function.
	(create_breakpoint): Check if the location points to a permanent
	breakpoint and if it does, make breakpoint permanent.
	(update_breakpoint_locations): Make sure new locations of permanent
	breakpoints are properly initialized.
	* i386-tdep.c (i386_skip_permanent_breakpoint): New function.
	(i386_gdbarch_init): Set gdbarch_skip_permanent_breakpoint.

	* gdb.arch/i386-bp_permanent.exp: New test.
@
text
@d107 1
a107 1
static void describe_other_breakpoints (CORE_ADDR, asection *, int);
d4053 2
a4054 1
breakpoint_has_pc (struct breakpoint *b, CORE_ADDR pc, asection *section)
d4069 2
a4070 1
describe_other_breakpoints (CORE_ADDR pc, asection *section, int thread)
d4160 1
a4160 1
check_duplicates_for (CORE_ADDR address, asection *section)
d5774 1
a5774 1
	      sal->section = SYMBOL_BFD_SECTION (sym);
d5787 1
a5787 1
		sal->section = SYMBOL_BFD_SECTION (msym);
@


1.346
log
@	* breakpoint.c (insert_breakpoints, update_global_location_list):
	Check breakpoints_always_inserted_mode instead of
	always_inserted_mode directly.
@
text
@d1753 2
a1754 1
    bpt->inserted = 0;
d3092 2
a3093 1
	    b->enable_state = bp_disabled;
d5086 28
d5168 3
d7427 4
@


1.345
log
@	* breakpoint.c (remove_breakpoint): Do not fail if unable to remove
	breakpoint from shared library.
@
text
@d1288 1
a1288 1
  if (!always_inserted_mode && target_has_execution)
d7088 3
a7090 1
  if (always_inserted_mode && should_insert && target_has_execution)
@


1.344
log
@	* breakpoint.c (create_overlay_event_breakpoint): Rename to ...
	(create_overlay_event_breakpoint_1): ... this.  Add OBJFILE parameter.
	(create_overlay_event_breakpoint): Loop over all objfiles to install
	multiple instances of the overlay event breakpoint if present.
@
text
@d1668 7
@


1.343
log
@gdb:
	PR gdb/1535:
	* breakpoint.c (CATCH_PERMANENT, CATCH_TEMPORARY): New macros.
	(ep_find_event_name_end): Remove.
	(catch_fork_temporary, catch_vfork_temporary,
	catch_fork_permanent, catch_vfork_permanent): New constants.
	(catch_vfork, catch_fork): Remove.
	(catch_fork_command_1): Add 'command' argument.  Remove
	'fork_kind' and 'tempflag'.  Handle NULL 'arg'.  Update switch for
	all cases.
	(catch_exec_command_1): Add 'command' argument; remove
	'tempflag'.  Handle NULL 'arg'.
	(catch_load_command_1): Likewise.
	(catch_unload_command_1): Likewise.
	(catch_ada_exception_command): Likewise.
	(catch_assert_command): Likewise.
	(catch_catch_command): New function.
	(catch_throw_command): Likewise.
	(catch_command_1): Remove.
	(catch_command): Just call error.
	(tcatch_command): Likewise.
	(catch_cmdlist): New global.
	(tcatch_cmdlist): Likewise.
	(add_catch_command): New function.
	(_initialize_breakpoint): Create "catch" and "tcatch" as prefix
	commands.  Create all catch sub-commands.
gdb/testsuite:
	* gdb.base/help.exp (help catch): Rewrite.
@
text
@d4531 1
a4531 1
create_overlay_event_breakpoint (char *func_name)
d4536 1
a4536 1
  if ((m = lookup_minimal_symbol_text (func_name, NULL)) == NULL)
d4556 8
@


1.342
log
@gdb/
2008-08-16  Vladimir Prus  <vladimir@@codesourcery.com>
	    Thiago Jung Bauermann  <bauerman@@br.ibm.com>

	* cli-script.c (read_next_line): Add parse_commands argument.
	(recurse_read_control_structure): Adapt to new read_next_line
	signature.
	(read_command_lines): Add parse_commands argument.
	(define_command): Adapt to new read_command_lines signature.
	(document_command): Likewise.
	* breakpoint.c (commands_command): Likewise.
	* defs.h (read_command_lines): Adjust function prototype.

testsuite/
2008-08-16  Thiago Jung Bauermann  <bauerman@@br.ibm.com>

	* gdb.base/define.exp: Test indented command documentation.
	* gdb.python/python.exp: Test indented multi-line command.
@
text
@d62 4
a67 2
static void catch_command_1 (char *, int, int);

a171 2
static char *ep_find_event_name_end (char *arg);

a6276 30
/* This function examines a string, and attempts to find a token
   that might be an event name in the leading characters.  If a
   possible match is found, a pointer to the last character of
   the token is returned.  Else, NULL is returned. */

static char *
ep_find_event_name_end (char *arg)
{
  char *s = arg;
  char *event_name_end = NULL;

  /* If we could depend upon the presense of strrpbrk, we'd use that... */
  if (arg == NULL)
    return NULL;

  /* We break out of the loop when we find a token delimiter.
     Basically, we're looking for alphanumerics and underscores;
     anything else delimites the token. */
  while (*s != '\0')
    {
      if (!isalnum (*s) && (*s != '_'))
	break;
      event_name_end = s;
      s++;
    }

  return event_name_end;
}


d6348 2
a6349 1
  catch_fork, catch_vfork
d6354 1
a6354 2
catch_fork_command_1 (catch_fork_kind fork_kind, char *arg, int tempflag,
		      int from_tty)
d6357 6
d6364 2
d6382 2
a6383 1
    case catch_fork:
d6386 2
a6387 1
    case catch_vfork:
d6397 1
a6397 1
catch_exec_command_1 (char *arg, int tempflag, int from_tty)
d6399 1
d6402 4
d6424 1
a6424 1
catch_load_command_1 (char *arg, int tempflag, int from_tty)
d6426 1
d6430 4
d6471 2
a6472 1
catch_unload_command_1 (char *arg, int tempflag, int from_tty)
d6474 1
d6478 4
d6620 2
d6639 18
d6706 2
a6707 1
catch_ada_exception_command (char *arg, int tempflag, int from_tty)
d6709 1
d6718 4
d6732 1
a6732 1
catch_assert_command (char *arg, int tempflag, int from_tty)
d6734 1
d6739 4
a6748 110
catch_command_1 (char *arg, int tempflag, int from_tty)
{

  /* The first argument may be an event name, such as "start" or "load".
     If so, then handle it as such.  If it doesn't match an event name,
     then attempt to interpret it as an exception name.  (This latter is
     the v4.16-and-earlier GDB meaning of the "catch" command.)

     First, try to find the bounds of what might be an event name. */
  char *arg1_start = arg;
  char *arg1_end;
  int arg1_length;

  if (arg1_start == NULL)
    {
      /* Old behaviour was to use pre-v-4.16 syntax */
      /* catch_throw_command_1 (arg1_start, tempflag, from_tty); */
      /* return; */
      /* Now, this is not allowed */
      error (_("Catch requires an event name."));

    }
  arg1_end = ep_find_event_name_end (arg1_start);
  if (arg1_end == NULL)
    error (_("catch requires an event"));
  arg1_length = arg1_end + 1 - arg1_start;

  /* Try to match what we found against known event names. */
  if (strncmp (arg1_start, "signal", arg1_length) == 0)
    {
      error (_("Catch of signal not yet implemented"));
    }
  else if (strncmp (arg1_start, "catch", arg1_length) == 0)
    {
      catch_exception_command_1 (EX_EVENT_CATCH, arg1_end + 1, 
				 tempflag, from_tty);
    }
  else if (strncmp (arg1_start, "throw", arg1_length) == 0)
    {
      catch_exception_command_1 (EX_EVENT_THROW, arg1_end + 1, 
				 tempflag, from_tty);
    }
  else if (strncmp (arg1_start, "thread_start", arg1_length) == 0)
    {
      error (_("Catch of thread_start not yet implemented"));
    }
  else if (strncmp (arg1_start, "thread_exit", arg1_length) == 0)
    {
      error (_("Catch of thread_exit not yet implemented"));
    }
  else if (strncmp (arg1_start, "thread_join", arg1_length) == 0)
    {
      error (_("Catch of thread_join not yet implemented"));
    }
  else if (strncmp (arg1_start, "start", arg1_length) == 0)
    {
      error (_("Catch of start not yet implemented"));
    }
  else if (strncmp (arg1_start, "exit", arg1_length) == 0)
    {
      error (_("Catch of exit not yet implemented"));
    }
  else if (strncmp (arg1_start, "fork", arg1_length) == 0)
    {
      catch_fork_command_1 (catch_fork, arg1_end + 1, tempflag, from_tty);
    }
  else if (strncmp (arg1_start, "vfork", arg1_length) == 0)
    {
      catch_fork_command_1 (catch_vfork, arg1_end + 1, tempflag, from_tty);
    }
  else if (strncmp (arg1_start, "exec", arg1_length) == 0)
    {
      catch_exec_command_1 (arg1_end + 1, tempflag, from_tty);
    }
  else if (strncmp (arg1_start, "load", arg1_length) == 0)
    {
      catch_load_command_1 (arg1_end + 1, tempflag, from_tty);
    }
  else if (strncmp (arg1_start, "unload", arg1_length) == 0)
    {
      catch_unload_command_1 (arg1_end + 1, tempflag, from_tty);
    }
  else if (strncmp (arg1_start, "stop", arg1_length) == 0)
    {
      error (_("Catch of stop not yet implemented"));
    }
  else if (strncmp (arg1_start, "exception", arg1_length) == 0)
    {
      catch_ada_exception_command (arg1_end + 1, tempflag, from_tty);
    }

  else if (strncmp (arg1_start, "assert", arg1_length) == 0)
    {
      catch_assert_command (arg1_end + 1, tempflag, from_tty);
    }

  /* This doesn't appear to be an event name */

  else
    {
      /* Pre-v.4.16 behaviour was to treat the argument
         as the name of an exception */
      /* catch_throw_command_1 (arg1_start, tempflag, from_tty); */
      /* Now this is not allowed */
      error (_("Unknown event kind specified for catch"));

    }
}

static void
d6751 1
a6751 1
  catch_command_1 (arg, 0, from_tty);
d6758 1
a6758 1
  catch_command_1 (arg, 1, from_tty);
d8160 28
d8445 59
a8503 46
  add_com ("catch", class_breakpoint, catch_command, _("\
Set catchpoints to catch events.\n\
Raised signals may be caught:\n\
\tcatch signal              - all signals\n\
\tcatch signal <signame>    - a particular signal\n\
Raised exceptions may be caught:\n\
\tcatch throw               - all exceptions, when thrown\n\
\tcatch throw <exceptname>  - a particular exception, when thrown\n\
\tcatch catch               - all exceptions, when caught\n\
\tcatch catch <exceptname>  - a particular exception, when caught\n\
Thread or process events may be caught:\n\
\tcatch thread_start        - any threads, just after creation\n\
\tcatch thread_exit         - any threads, just before expiration\n\
\tcatch thread_join         - any threads, just after joins\n\
Process events may be caught:\n\
\tcatch start               - any processes, just after creation\n\
\tcatch exit                - any processes, just before expiration\n\
\tcatch fork                - calls to fork()\n\
\tcatch vfork               - calls to vfork()\n\
\tcatch exec                - calls to exec()\n\
Dynamically-linked library events may be caught:\n\
\tcatch load                - loads of any library\n\
\tcatch load <libname>      - loads of a particular library\n\
\tcatch unload              - unloads of any library\n\
\tcatch unload <libname>    - unloads of a particular library\n\
The act of your program's execution stopping may also be caught:\n\
\tcatch stop\n\n\
C++ exceptions may be caught:\n\
\tcatch throw               - all exceptions, when thrown\n\
\tcatch catch               - all exceptions, when caught\n\
Ada exceptions may be caught:\n\
\tcatch exception           - all exceptions, when raised\n\
\tcatch exception <name>    - a particular exception, when raised\n\
\tcatch exception unhandled - all unhandled exceptions, when raised\n\
\tcatch assert              - all failed assertions, when raised\n\
\n\
Do \"help set follow-fork-mode\" for info on debugging your program\n\
after a fork or vfork is caught.\n\n\
Do \"help breakpoints\" for info on other commands dealing with breakpoints."));

  add_com ("tcatch", class_breakpoint, tcatch_command, _("\
Set temporary catchpoints to catch events.\n\
Args like \"catch\" command.\n\
Like \"catch\" except the catchpoint is only temporary,\n\
so it will be deleted when hit.  Equivalent to \"catch\" followed\n\
by using \"enable delete\" on the catchpoint number."));
@


1.341
log
@gdb/
	* breakpoint.c (always_inserted_auto, always_inserted_on)
	(always_inserted_off, always_inserted_enums): New.
	(always_inserted_mode): Change type to char* and point to
	always_inserted_auto.
	(show_always_inserted_mode): In auto mode, also show the current
	effect of the option.
	(breakpoints_always_inserted_mode): Adjust for the new auto mode.
	(_initialize_breakpoint): Make the "set breakpoints
	always-inserted" command an enum command.  Extend help to describe
	the auto mode.

gdb/doc/
	* gdb.texinfo (breakpoint always-inserted) Describe the auto mode
	setting, and make it the default.
	(Non-Stop Mode): Remove "set breakpoints always-inserted 1" from
	non-stop script example.
@
text
@d678 1
a678 1
	l = read_command_lines (tmpbuf, from_tty);
@


1.340
log
@2008-08-06  Phil Muldoon  <pmuldoon@@redhat.com>

	* breakpoint.c (hw_breakpoint_used_count): Use breakpoint_enabled.
	(insert_breakpoint_locations): Likewise.
@
text
@d252 17
a268 6
/* If 1, gdb will keep breakpoints inserted even as inferior is stopped, 
   and immediately insert any new breakpoints.  If 0, gdb will insert 
   breakpoints into inferior only when resuming it, and will remove 
   breakpoints upon stop.  */
static int always_inserted_mode = 0;
static void 
d270 1
a270 1
			   struct cmd_list_element *c, const char *value)
d272 7
a278 1
  fprintf_filtered (file, _("Always inserted breakpoint mode is %s.\n"), value);
d281 6
a8222 5
int breakpoints_always_inserted_mode (void)
{
  return always_inserted_mode;
}

d8625 2
a8626 2
  add_setshow_boolean_cmd ("always-inserted", class_support,
			   &always_inserted_mode, _("\
d8629 8
a8636 4
When this mode is off (which is the default), breakpoints are inserted in\n\
inferior when it is resumed, and removed when execution stops.  When this\n\
mode is on, breakpoints are inserted immediately and removed only when\n\
the user deletes the breakpoint."),
@


1.339
log
@2008-08-05  Phil Muldoon  <pmuldoon@@redhat.com>

	* breakpoint.c (create_longjmp_breakpoint): Remove unused struct
	breakpoint.
	(set_longjmp_breakpoint): Likewise.
@
text
@d1323 1
a1323 1
      if (bpt->enable_state != bp_enabled)
d4768 1
a4768 1
    if (b->type == bp_hardware_breakpoint && b->enable_state == bp_enabled)
@


1.338
log
@	* annotate.h (deprecated_annotate_starting_hook): Remove.
	(deprecated_annotate_stopped_hook): Remove.
	(deprecated_annotate_exited_hook): Remove.
	* Makefile.in (annotate.o): Depend on observer_h.
	* top.c (deprecated_delete_breakpoint_hook): Remove.
	(deprecated_create_breakpoint_hook): Likewise.
	(deprecated_modify_breakpoint_hook): Likewise.
	* interps.c (clear_interpreter_hooks): Update for removed hooks.
	* breakpoint.c (mention): Don't call removed hook.
	(delete_breakpoint): Likewise.
	(disable_breakpoint): Likewise.
	(do_enable_breakpoint): Likewise.
	* annotate.c: Include observer.h.
	(breakpoint_changed): Change type of argument.
	(_initialize_annotate): Register observers.
	(deprecated_annotate_starting_hook): Remove.
	(deprecated_annotate_stopped_hook): Remove.
	(deprecated_annotate_exited_hook): Remove.
	(annotate_starting): Update for hook removal.
	(annotate_stopped): Likewise.
	(annotate_exited): Likewise.
	* defs.h (deprecated_delete_breakpoint_hook): Remove.
	(deprecated_create_breakpoint_hook): Likewise.
	(deprecated_modify_breakpoint_hook): Likewise.
@
text
@a4468 1
  struct breakpoint *b;
a4483 2
  struct breakpoint *b;

@


1.337
log
@gdb:
	* tui/tui-hooks.c: Include observer.h.
	(tui_event_default, tui_old_event_hooks, tui_event_hooks):
	Remove.
	(tui_bp_created_observer, tui_bp_deleted_observer,
	tui_bp_modified_observer): New globals.
	(tui_install_hooks): Use observers, not events.
	(tui_remove_hooks): Likewise.
	* mi/mi-cmd-break.c: Include observer.h, not gdb-events.h.
	(mi_breakpoint_observers_installed, mi_can_breakpoint_notify): New
	globals.
	(breakpoint_notify): Check mi_can_breakpoint_notify.
	(breakpoint_hooks): Remove.
	(mi_cmd_break_insert): Attach observers.  Don't use events.
	* tracepoint.c: Include observer.h, not gdb-events.h.
	(tracepoint_operation, trace_pass_command): Notify observer.
	* interps.c: Don't include gdb-events.h.
	(clear_interpreter_hooks): Don't call clear_gdb_event_hooks.
	* gdbarch.c: Rebuild.
	* gdbarch.sh: Emit include for observer.h, not gdb-events.h.
	(deprecated_current_gdbarch_select_hack): Notify observer.
	* breakpoint.h: Don't include gdb-events.h.
	* breakpoint.c: Don't include gdb-events.h.
	(condition_command): Notify observer.
	(commands_command): Likewise.
	(commands_from_control_command): Likewise.
	(mention, delete_breakpoint, set_ignore_count): Likewise.
	(disable_breakpoint, do_enable_breakpoint): Likewise.
	* Makefile.in (gdb_events_h): Remove.
	(breakpoint_h): Update.
	(COMMON_OBS): Remove gdb-events.o.
	(gdb-events.o): Remove.
	(breakpoint.o, gdbarch.o, interps.o, tracepoint.o, gdbtk-bp.o,
	gdbtk-hooks.o, mi-cmd-break.o, tui-hooks.o): Update.
	* gdb-events.c: Remove.
	* gdb-events.h: Remove.
	* gdb-events.sh: Remove.
gdb/doc:
	* observer.texi (GDB Observers): Document new observers:
	breakpoint_created, breakpoint_deleted, breakpoint_modified,
	tracepoint_created, tracepoint_deleted, tracepoint_modified,
	architecture_changed.
gdb/gdbtk:
	* generic/gdbtk-hooks.c: Include observer.h, not gdb-events.h.
	(gdbtk_add_hooks): Use observers, not events.
	(gdbtk_architecture_changed): Add argument, for observer.
	* generic/gdbtk-bp.c: Include observer.h.
	(gdb_set_bp): Notify observer.
	(gdb_set_bp_addr): Likewise.
@
text
@d4893 1
a4893 4
     random calls to breakpoint_changed with this hook, as has already
     been done for deprecated_delete_breakpoint_hook and so on.  */
  if (deprecated_create_breakpoint_hook)
    deprecated_create_breakpoint_hook (b);
a7212 2
  if (deprecated_delete_breakpoint_hook)
    deprecated_delete_breakpoint_hook (bpt);
a7865 2
  if (deprecated_modify_breakpoint_hook)
    deprecated_modify_breakpoint_hook (bpt);
a7988 2
  if (deprecated_modify_breakpoint_hook)
    deprecated_modify_breakpoint_hook (bpt);
@


1.336
log
@	* block.c (block_function): Renamed to ...
	(block_linkage_function): ... this.  All callers changed.
	* block.h (block_function): Renamed to ...
	(block_linkage_function): ... this.
@
text
@a59 1
#include "gdb-events.h"
d621 1
a621 1
	breakpoint_modify_event (b->number);
d660 1
a660 1
	breakpoint_modify_event (b->number);
d706 1
a706 1
	breakpoint_modify_event (b->number);
d4897 1
a4897 1
  breakpoint_create_event (b->number);
d7218 1
a7218 1
  breakpoint_delete_event (bpt->number);
d7723 1
a7723 1
      breakpoint_modify_event (b->number);
d7873 1
a7873 1
  breakpoint_modify_event (bpt->number);
d7998 1
a7998 1
  breakpoint_modify_event (bpt->number);
@


1.336.2.1
log
@2008-07-17  Michael Snyder  <msnyder@@specifix.com>
	2006-05-02  Michael Snyder  <msnyder@@redhat.com>

	* Target interface for reverse execution.
	* target.h (enum target_waitkind):
	Add new wait event, TARGET_WAITKIND_NO_HISTORY.
	(enum exec_direction_kind): New enum.
	(struct target_ops): New methods to_set_execdir, to_get_execdir.
	* target.c (target_get_execdir): New generic method.
	(target_set_execdir): Ditto.
	* remote.c (remote_get_execdir, remote_set_execdir): New methods.
	(remote_vcont_resume): Jump out if attempting reverse execution.
	(remote_resume): Check for reverse exec direction, and send
	appropriate command to target.
	(remote_wait): Check target response for NO_HISTORY status.
	Also check for empty reply (target doesn't understand "bs" or "bc).
	(_initialize_remote): Add new methods to remote target vector.

	* breakpoint.h (breakpoint_silence): Export.
	* breakpoint.c (breakpoint_silence): New function.
	* infcmd.c (finish_command): Check for reverse exec direction.
	(finish_backward): New function, handle finish cmd in reverse.
	* infrun.c (enum inferior_stop_reason): Add NO_HISTORY reason.
	(handle_inferior_event): Handle TARGET_WAITKIND_NO_HISTORY.
	Handle stepping over a function call in reverse.
	Handle stepping thru a line range in reverse.
	Handle setting a step-resume breakpoint in reverse.
	Handle stepping into a function in reverse.
	Handle stepping between line ranges in reverse.
	(print_stop_reason): Print reason for NO_HISTORY.

	2006-03-31  Michael Snyder  <msnyder@@redhat.com>
	User interface for reverse execution.
	* Makefile.in (reverse.c): New file.
	* reverse.c: New file.  User interface for reverse execution.

	2007-04-18  Daniel Jacobowitz  <dan@@codesourcery.com>

	* infcmd.c (finish_backwards): Correct check for whether to back
	up after finishing.

	* arm-tdep.c (arm_scan_epilogue): New.
	(arm_make_prologue_cache): Use it.
	(arm_epilogue_unwind_sniffer): New.
	(arm_gdbarch_init): Register it.
@
text
@a7740 7
void
breakpoint_silence (struct breakpoint *b)
{
  /* Silence the breakpoint.  */
  b->silent = 1;
}

@


1.336.2.2
log
@2008-10-06  Michael Snyder  <msnyder@@vmware.com>

	* breakpoint.c (breakpoint_silence): Rename to make_breakpoint_silent.
	* breakpoint.h: Ditto.
	* infcmd.c (finish_backward): Call make_breakpoint_silent
	instead of breakpoint_silence.
@
text
@d7742 1
a7742 1
make_breakpoint_silent (struct breakpoint *b)
@


1.335
log
@2008-07-12  Pedro Alves  <pedro@@codesourcery.com>

	Rewrite continuations internals on top of cleanups and plug
	continuation arguments leaks.

	* defs.h (struct continuation): Make it opaque.
	(add_continuation, add_intermediate_continuation): Drop the int
	argument of the continuation hook argument.  Add
	continuation_free_args argument.
	(do_all_continuations, do_all_intermediate_continuations): Drop
	the error_p argument.

	* utils.c (add_continuation): Drop the int argument of the
	continuation hook argument.  Add continuation_free_args argument.
	Reimplement on top of cleanups.
	(do_all_continuations): Drop error argument.  Reimplement on top
	of cleanups.
	(discard_all_continuations): Reimplement on top of cleanups.
	(add_intermediate_continuation): Drop the int argument of the
	continuation hook argument.  Add continuation_free_args argument.
	Reimplement on top of cleanups.
	(do_all_intermediate_continuations): Drop error argument.
	Reimplement on top of cleanups.
	(discard_all_intermediate_continuations): Reimplement on top of
	cleanups.

	* breakpoint.c (until_break_command_continuation): Drop error
	argument.  Add xfree as continuation argument deleter.

	* inf-loop.c (inferior_event_handler): On error, discard all
	continuations.  Adjust to new do_all_intermediate_continuations
	and do_all_continuations interfaces.

	* infcmd.c (step_1_continuation): Drop error_p argument.  Adjust.
	Pass xfree as continuation argument deleter.
	(finish_command_continuation): Drop error_p argument.  Adjust.
	(finish_command_continuation_free_arg): New.
	(finish_command): Pass finish_command_continuation_free_arg as
	continuation argument deleter.  Adjust to new do_all_continuations
	interfaces.
	(attach_command_continuation): Drop error_p argument.
	(attach_command_continuation_free_args): New.
	(attach_command): Pass attach_command_continuation_free_args as
	continuation argument deleter.

	* interps.c (interp_set): Adjust to new do_all_continuations
	interfaces.

	* event-top.c (stdin_event_handler): In error, also discard the
	intermediate continuations.
@
text
@d2654 2
a2655 1
	  && block_function (b->exp_valid_block) != get_frame_function (fr))
d5704 1
a5704 1
	  sym = block_function (b);
@


1.334
log
@	Replace struct continuation_args by void* and per command structs.

	* top.c (execute_command): Remove unused arg1 and arg2 locals.

	* breakpoint.c (struct until_break_command_continuation_args):
	New.
	(until_break_command_continuation): Take a void* instead of a
	continuations_arg.  Adjust.
	(until_break_command): Adjust to use struct
	until_break_command_continuation_args instead of struct
	continuation_arg.

	* infcmd.c (struct step_1_continuation_args): New.
	(step_1_continuation): Take a void* instead of a
	continuations_arg.  Adjust to use struct step_1_continuation_args.
	(step_once): Adjust to use struct step_1_continuation_args.

	(struct finish_command_continuation_args): New.
	(finish_command_continuation): Take a void* instead of a
	continuations_arg.  Adjust to use struct
	finish_command_continuation_args.
	(finish_command): Adjust to use struct
	finish_command_continuation_args.
	(struct attach_command_continuation_args): New.
	(attach_command_continuation): Take a void* instead of a
	continuations_arg.  Adjust to use struct
	attach_command_continuation_args.
	(attach_command): Adjust to use struct
	attach_command_continuation_args.

	* defs.h (struct continuation_arg): Delete.
	(struct continuation): Replace the struct continuation_arg*
	parameter of continuation_hook by a void*.  Replace "arg_list"
	member by a new "args" member with void* type.
	(add_continuation, add_intermediate_continuation): Replace struct
	continuation_arg type usages by void* usages.

	* utils.c (add_continuation, do_all_continuations)
	(add_intermediate_continuation)
	(do_all_intermediate_continuations): Replace struct
	continuation_arg type usages by void* usages.  Pass "args" instead
	of "arg_list".
@
text
@a64 2
static void until_break_command_continuation (void *arg, int error);

d6162 1
a6162 1
until_break_command_continuation (void *arg, int error)
d6244 2
a6245 1
      add_continuation (until_break_command_continuation, args);
@


1.333
log
@	Per-thread commands.

	* gdbthread.h: Remove unneeded forward declarations.
	Include "inferior.h".
	(struct thread_info): Add continuations,
	intermediate_continuations, proceed_to_finish, step_over_calls,
	stop_step, step_multi and stop_signal members.
	(save_infrun_state): Add continuations,
	intermediate_continuations, proceed_to_finish, step_over_calls,
	stop_step, step_multi, stop_signal and stop_bpstat parameters.
	(load_infrun_state): Add continuations,
	intermediate_continuations, proceed_to_finish, step_over_calls,
	stop_step, step_multi, stop_signal and stop_bpstat parameters.

	* thread.c (load_infrun_state): In non-stop mode, load
	continuations, intermediate_continuations, proceed_to_finish,
	step_over_calls, stop_step, step_multi and stop_signal.
	(save_infrun_state): Store continuations,
	intermediate_continuations, proceed_to_finish, step_over_calls,
	stop_step, step_multi, stop_signal and stop_bpstat.
	(save_infrun_state): Store continuations,
	intermediate_continuations, proceed_to_finish, step_over_calls,
	stop_step, step_multi, stop_signal and stop_bpstat.
	(free_thread): Clear The thread's stop_bpstat.

	* inferior.h (context_switch_to): Declare.

	* infrun.c (ecss): New global.
	(context_switch): Context switch continuations,
	intermediate_continuations, proceed_to_finish, step_over_calls,
	stop_step, step_multi, stop_signal and stop_bpstat.
	(wait_for_inferior): Use global ecss.
	(async_ecss, async_ecs): Delete.
	(fetch_inferior_event): Use global ecss.
	(context_switch_to): New.

	* top.c (execute_command): In non-stop, only check if the current
	thread is running, in all-stop, check if there's any thread
	running.

	* breakpoint.c (bpstat_remove_breakpoint): New.
	(bpstat_remove_breakpoint_callback): New.
	(delete_breakpoint): Clear the stop_bpstats of all threads.

	* mi/mi-main.c (mi_cmd_execute): In non-stop, only check if the
	current thread is running, in all-stop, check if there's any
	thread running.

	* Makefile.in (gdbthread_h): Depend on $(inferior_h).
@
text
@d65 1
a65 2
static void until_break_command_continuation (struct continuation_arg *arg, 
					      int error);
d6153 6
d6164 1
a6164 1
until_break_command_continuation (struct continuation_arg *arg, int error)
d6166 5
a6170 3
  delete_breakpoint ((struct breakpoint *)(arg->data.pointer));
  if (arg->next)
    delete_breakpoint ((struct breakpoint *)(arg->next->data.pointer));
a6182 3
  struct continuation_arg *arg1;
  struct continuation_arg *arg2;

d6239 5
a6243 13
      arg1 =
	(struct continuation_arg *) xmalloc (sizeof (struct continuation_arg));
      arg1->next         = NULL;
      arg1->data.pointer = breakpoint;

      if (breakpoint2)
	{
	  arg2 = (struct continuation_arg *)
	    xmalloc ( sizeof (struct continuation_arg));
	  arg2->next         = NULL;
	  arg2->data.pointer = breakpoint2;
	  arg1->next = arg2;	   
	}
d6246 1
a6246 1
      add_continuation (until_break_command_continuation, arg1);
@


1.332
log
@	Adjust fork/vfork/exec to pass ptids around.

	* target.h (struct target_waitstatus): Store related_pid as a ptid.
	(inferior_has_forked, inferior_has_vforked, inferior_has_execd):
	Take a ptid_t.
	* breakpoint.h (struct breakpoint): Change forked_inferior_pid
	type to ptid.
	* breakpoint.c (print_it_typical, bpstat_check_location)
	(print_one_breakpoint_location, set_raw_breakpoint_without_location)
	(create_fork_vfork_event_catchpoint): Adjust.
	* infrun.c (fork_event): Change parent_pid and child_pid types to
	ptid.
	(follow_exec, inferior_has_forked, inferior_has_vforked)
	(inferior_has_execd): Take a ptid_t and don't trim it.
	* linux-thread-db.c (thread_db_wait): Don't trim the returned ptid.
	* linux-nat.c (linux_child_follow_fork): Adjust.
	* inf-ptrace.c (inf_ptrace_wait): Adjust.
	* inf-ttrace.c (inf_ttrace_wait): Adjust.
	* win32-nat.c (get_win32_debug_event): Don't set related_pid.
@
text
@d7171 23
a7200 1
  bpstat bs;
d7264 5
a7268 7
  for (bs = stop_bpstat; bs; bs = bs->next)
    if (bs->breakpoint_at && bs->breakpoint_at->owner == bpt)
      {
	bs->breakpoint_at = NULL;
	bs->old_val = NULL;
	/* bs->commands will be freed later.  */
      }
@


1.331
log
@	Add "executing" property to threads.

	* inferior.h (target_executing): Delete.
	* gdbthread.h (struct thread_info): Add executing_ field.
	(set_executing, is_executing): New.
	* thread.c (main_thread_executing): New.
	(init_thread_list): Clear it and also main_thread_running.
	(is_running): Return false if target has no execution.
	(any_running, is_executing, set_executing): New.

	* top.c: Include "gdbthread.h".
	(target_executing): Delete.
	(execute_command): Replace target_executing check by any_running.
	* event-top.c: Include "gdbthread.h".
	(display_gdb_prompt, command_handler): Replace target_executing by
	is_running.
	* inf-loop.c: Include "gdbthread.h".  Don't mark as not executing
	here.  Replace target_executing by is_running.
	* infrun.c (handle_inferior_event): Mark all threads as
	not-executing.
	* linux-nat.c (linux_nat_resume): Don't mark thread as executing
	here.
	* stack.c (get_selected_block): Return null if inferior is
	executing.
	* target.c (target_resume): Mark resumed ptid as executing.
	* breakpoint.c (until_break_command): Replace target_executing
	check by is_executing.
	* remote.c (remote_async_resume): Don't mark inferior as executing
	here.
	* mi/mi-interp.c (mi_cmd_interpreter_exec): Replace target_executing
	by any_running.

	* mi/mi-main.c (mi_cmd_exec_interrupt, mi_cmd_execute)
	(mi_execute_async_cli_command): Replace target_executing by
	is_running.

	* frame.c (get_current_frame): Error out if the current thread is
	executing.
	(has_stack_frames): New.
	(get_selected_frame, deprecated_safe_get_selected_frame): Check
	has_stack_frames.

	* Makefile.in (event-top.o, frame.o, inf-loop.o, top.o): Depend on
	$(gdbthread_h).
@
text
@d2319 1
a2319 1
		       b->forked_inferior_pid);
d2327 1
a2327 1
		       b->forked_inferior_pid);
d2819 1
a2819 1
      && !inferior_has_forked (PIDGET (inferior_ptid),
d2824 1
a2824 1
      && !inferior_has_vforked (PIDGET (inferior_ptid),
d2829 1
a2829 1
      && !inferior_has_execd (PIDGET (inferior_ptid), &b->exec_pathname))
d3675 1
a3675 1
	if (b->forked_inferior_pid != 0)
d3678 2
a3679 1
	    ui_out_field_int (uiout, "what", b->forked_inferior_pid);
d4348 1
a4348 1
  b->forked_inferior_pid = 0;
d4721 1
a4721 1
  b->forked_inferior_pid = 0;
@


1.330
log
@	* breakpoint.c (update_global_location_list): Add boolean
	"should_insert" argument.  Only insert locations if caller told it
	too.
	(update_global_location_list_nothrow): Add boolean "should_insert"
	argument.  Pass it to update_global_location_list.
	(insert_breakpoints, create_longjmp_breakpoint)
	(create_overlay_event_breakpoint, enable_overlay_breakpoints)
	(create_thread_event_breakpoint, create_solib_event_breakpoint)
	(create_fork_vfork_event_catchpoint, create_exec_event_catchpoint)
	(enable_watchpoints_after_interactive_call_stop)
	(set_momentary_breakpoint, create_breakpoints)
	(break_command_really, watch_command_1)
	(create_ada_exception_breakpoint, update_breakpoint_locations)
	(do_enable_breakpoint, enable_command): Pass true to
	update_global_location_list.
	(bpstat_stop_status, disable_overlay_breakpoints)
	(disable_watchpoints_before_interactive_call_start)
	(delete_breakpoint, disable_breakpoint, disable_command): Pass
	false to update_global_location_list.
	(update_breakpoints_after_exec): Don't temporarily disable
	always-inserted mode.
@
text
@d6232 1
a6232 1
  if (target_can_async_p () && target_executing)
@


1.329
log
@	* breakpoint.c (mark_breakpoints_out): Make public.
	(update_breakpoints_after_exec): Don't call mark_breakpoints_out
	here.  Update comment.
	* breakpoint.h (mark_breakpoints_out): Declare.

	* linux-nat.c (linux_handle_extended_wait): On
	TARGET_WAITKIND_EXECD, call mark_breakpoints_out.
	* inf-ttrace.c (inf_ttrace_wait): Likewise.
@
text
@d194 1
a194 1
static void update_global_location_list (void);
d196 1
a196 1
static void update_global_location_list_nothrow (void);
d1267 1
a1267 1
  update_global_location_list ();
a1444 1
  struct cleanup *cleanup;
a1456 6
  /* The binary we used to debug is now gone, and we're updating
     breakpoints for the new binary.  Until we're done, we should not
     try to insert breakpoints.  */
  cleanup = make_cleanup_restore_integer (&always_inserted_mode);
  always_inserted_mode = 0;

a1545 1
  do_cleanups (cleanup);
d3065 1
a3065 1
	    update_global_location_list ();
d4477 1
a4477 1
  update_global_location_list ();
d4535 1
a4535 1
  update_global_location_list ();
d4547 1
a4547 1
      update_global_location_list ();
d4561 1
a4561 1
      update_global_location_list ();
d4577 1
a4577 1
  update_global_location_list_nothrow ();
d4623 1
a4623 1
  update_global_location_list_nothrow ();
d4721 1
a4721 1
  update_global_location_list ();
d4760 1
a4760 1
  update_global_location_list ();
d4816 1
a4816 1
	update_global_location_list ();
d4835 1
a4835 1
	update_global_location_list ();
d4861 1
a4861 1
  update_global_location_list_nothrow ();
d5283 1
a5283 1
  update_global_location_list ();
d5604 1
a5604 1
      update_global_location_list ();
d6033 1
a6033 1
  update_global_location_list ();
d6671 1
a6671 1
  update_global_location_list ();
d6995 15
d7011 1
a7011 1
update_global_location_list (void)
d7143 1
a7143 1
  if (always_inserted_mode && target_has_execution)
d7163 1
a7163 1
update_global_location_list_nothrow (void)
d7167 1
a7167 1
    update_global_location_list ();
d7257 1
a7257 1
  update_global_location_list ();
d7467 1
a7467 1
  update_global_location_list ();
d7853 1
a7853 1
  update_global_location_list ();
d7892 1
a7892 1
      update_global_location_list ();
d7977 1
a7977 1
  update_global_location_list ();
d8028 1
a8028 1
      update_global_location_list ();
@


1.328
log
@gdb/
	* breakpoint.c (bpstat_copy): Call RELEASE_VALUE on the new OLD_VAL.

gdb/testsuite/
	* gdb.base/value-double-free.exp, gdb.base/value-double-free.c: New.
@
text
@a190 2
static void mark_breakpoints_out (void);

d1444 1
d1447 10
a1456 4
  /* Doing this first prevents the badness of having delete_breakpoint()
     write a breakpoint's current "shadow contents" to lift the bp.  That
     shadow is NOT valid after an exec()! */
  mark_breakpoints_out ();
d1707 1
a1707 1
static void
@


1.327
log
@        * breakpoint.c (moribund_locations): New.
        (bpstat_stop_status): Process moribund locations.
        (update_global_location_list): Add removed
        locations to moribund_locations.
        (breakpoint_retire_moribund): New.
        * breakpoint.h (struct bp_location): New field
        events_till_retirement.
        (breakpoint_retire_moribund): Declare.
        * thread.c (thread_count): New.
        * infrun.c (handle_inferior_event): Call
        breakpoint_retire_moribund.
        * gdbthread.h (thread_count): Declare.
@
text
@d1999 4
a2002 1
	tmp->old_val = value_copy (bs->old_val);
@


1.326
log
@	* Makefile.in (GNULIB_H): Use GNULIB_STDINT_H.
	(gdb_stdint_h, gdb_stdint.h, stamp-int): Delete.  Remove
	all dependencies on $(gdb_stdint_h).
	(distclean): Do not delete gdb_stdint.h.
	* acinclude.m4: Do not use stdint.m4.
	* configure.ac: Set GNULIB_STDINT_H.  Remove tests for stdint.h,
	uintptr_t, and gdb_stdint.h.
	* defs.h: Include <stdint.h>.
	* gdb_thread_db.h: Assume stdint.h is already included.
	* breakpoint.c, findcmd.c, hppa-tdep.c, inf-ptrace.c, proc-service.c,
	rs6000-nat.c, spu-linux-nat.c, target.c, win32-nat.c: Do not
	include gdb_stdint.h.
	* configure, config.in: Regenerate.
@
text
@d311 5
d3011 1
d3016 1
d3085 12
d3111 1
d3276 3
d6982 3
a6984 1
    if (bs->breakpoint_at && bs->breakpoint_at->owner->disposition == disp_del
d7032 3
a7050 1
	  int keep = 0;
d7056 1
a7056 1
	      keep = 1;
d7074 1
a7074 1
			keep = 1;
d7080 17
a7096 14
	  if (!keep)
	    if (remove_breakpoint (loc, mark_uninserted))
	      {
		/* This is just about all we can do.  We could keep this
		   location on the global list, and try to remove it next
		   time, but there's no particular reason why we will
		   succeed next time.  

		   Note that at this point, loc->owner is still valid,
		   as delete_breakpoint frees the breakpoint only
		   after calling us.  */
		printf_filtered (_("warning: Error removing breakpoint %d\n"), 
				 loc->owner->number);
	      }
d7100 21
a7120 1
	free_bp_location (loc);
d7132 15
@


1.325
log
@	Introduce common cleanup for restoring integers.
        * defs.h (make_cleanup_restore_integer): New declaration.
        (struct cleanup): New field free_arg.
        (make_my_cleanup_2): New.
        * utils.c (restore_integer_closure, restore_integer)
        (make_cleanup_restore_integer): New.
        (make_my_cleanup): Initialize the free_arg field and
        renamed to make_my_cleanup_2.
        (do_my_cleanups): Call free_arg.
        (discard_cleanups): Call free_arg.
        * breakpoint.c (restore_always_inserted_mode): Remove.
        (update_breakpoints_after_exec): Use make_cleanup_restore_integer.
@
text
@a62 2
#include "gdb_stdint.h"

@


1.324
log
@gdb
	* value.h (evaluate_subexpression_type, extract_field_op):
	Declare.
	* printcmd.c (_initialize_printcmd): Use expression_completer for
	'p', 'inspect', 'call'.
	* parser-defs.h (parse_field_expression): Declare.
	* parse.c: Include exceptions.h.
	(in_parse_field, expout_last_struct): New globals.
	(mark_struct_expression): New function.
	(prefixify_expression): Return int.
	(prefixify_subexp): Return int.  Use expout_last_struct.
	(parse_exp_1): Update.
	(parse_exp_in_context): Add 'out_subexp' argument.  Handle
	in_parse_field.
	(parse_field_expression): New function.
	* expression.h (parse_field_expression): Declare.
	(in_parse_field): Likewise.
	* eval.c (evaluate_subexpression_type): New function.
	(extract_field_op): Likewise.
	* completer.h (expression_completer): Declare.
	* completer.c (expression_completer): New function.
	(count_struct_fields, add_struct_fields): New functions.
	* c-exp.y (yyparse): Redefine.
	(COMPLETE): New token.
	(exp): New productions.
	(saw_name_at_eof, last_was_structop): New globals.
	(yylex): Return COMPLETE when needed.  Recognize in_parse_field.
	(c_parse): New function.
	* breakpoint.c (_initialize_breakpoint): Use expression_completer
	for watch, awatch, and rwatch.
	* Makefile.in (parse.o): Depend on exceptions_h.
gdb/testsuite
	* gdb.base/break1.c (struct some_struct): New struct.
	(values): New global.
	* gdb.base/completion.exp: Add field name completion test.
gdb/doc
	* gdb.texinfo (Completion): Add field name example.
@
text
@a1437 6
static void
restore_always_inserted_mode (void *p)
{
  always_inserted_mode = (uintptr_t) p;
}

d1453 1
a1453 2
  cleanup = make_cleanup (restore_always_inserted_mode, 
			  (void *) (uintptr_t) always_inserted_mode);
@


1.324.2.1
log
@Reverse execution branch

2008-06-09  Michael Snyder  <msnyder@@specifix.com>
	2006-05-02  Michael Snyder  <msnyder@@redhat.com>

	* Target interface for reverse execution.
	* target.h (enum target_waitkind):
	Add new wait event, TARGET_WAITKIND_NO_HISTORY.
	(enum exec_direction_kind): New enum.
	(struct target_ops): New methods to_set_execdir, to_get_execdir.
	* target.c (target_get_execdir): New generic method.
	(target_set_execdir): Ditto.
	* remote.c (remote_get_execdir, remote_set_execdir): New methods.
	(remote_vcont_resume): Jump out if attempting reverse execution.
	(remote_resume): Check for reverse exec direction, and send
	appropriate command to target.
	(remote_wait): Check target response for NO_HISTORY status.
	Also check for empty reply (target doesn't understand "bs" or "bc).
	(_initialize_remote): Add new methods to remote target vector.

	* breakpoint.h (breakpoint_silence): Export.
	* breakpoint.c (breakpoint_silence): New function.
	* infcmd.c (finish_command): Check for reverse exec direction.
	(finish_backward): New function, handle finish cmd in reverse.
	* infrun.c (enum inferior_stop_reason): Add NO_HISTORY reason.
	(handle_inferior_event): Handle TARGET_WAITKIND_NO_HISTORY.
	Handle stepping over a function call in reverse.
	Handle stepping thru a line range in reverse.
	Handle setting a step-resume breakpoint in reverse.
	Handle stepping into a function in reverse.
	Handle stepping between line ranges in reverse.
	(print_stop_reason): Print reason for NO_HISTORY.

	2006-03-31  Michael Snyder  <msnyder@@redhat.com>
	User interface for reverse execution.
	* Makefile.in (reverse.c): New file.
	* reverse.c: New file.  User interface for reverse execution.
@
text
@a7652 7
void
breakpoint_silence (struct breakpoint *b)
{
  /* Silence the breakpoint.  */
  b->silent = 1;
}

@


1.323
log
@	* breakpoint.c (print_exception_catchpoint): Put 'exception' back to
	'exception caught|thrown' message.
@
text
@d8458 1
a8458 1
  set_cmd_completer (c, location_completer);
d8464 1
a8464 1
  set_cmd_completer (c, location_completer);
d8470 1
a8470 1
  set_cmd_completer (c, location_completer);
@


1.322
log
@	* breakpoint.c (print_exception_catchpoint): In CLI add 'Temporary' for
	temporary catchpoints.  In MI add missing fields 'reason', 'disp',
	'bkptno'.
	(print_mention_exception_catchpoint): Add 'Temporary' for temporary
	catchpoints.
	(handle_gnu_v3_exceptions): Use tempflag.
@
text
@d6514 2
a6515 2
	       bp_throw ? " (thrown), "
		        : " (caught), ");
@


1.321
log
@gdb/
	* breakpoint.c (update_breakpoints_after_exec): Delete bp_longjmp
	and bp_longjmp_resume breakpoints.
	(breakpoint_address_is_meaningful): Claim bp_longjmp_resume as
	meaningful.
	(create_longjmp_breakpoint): Don't create bp_longjmp_resume
	breakpoints.  Create bp_longjmp breakpoints as momentary
	breakpoints.
	(enable_longjmp_breakpoint): Delete.
	(set_longjmp_breakpoint): New.
	(disable_longjmp_breakpoint): Delete.
	(delete_longjmp_breakpoint): New.
	(set_longjmp_resume_breakpoint): Delete.
	(set_momentary_breakpoint_at_pc): New.
	(breakpoint_re_set_one): Don't delete bp_longjmp and
	bp_longjmp_resume breakpoints.
	(breakpoint_re_set): Don't create longjmp and longjmp-resume
	breakpoints.

	* infrun.c (step_resume_breakpoint): Add comment.
	(struct execution_control_state): Delete handling_longjmp member.
	(init_execution_control_state). Don't clear handling_longjmp.
	(context_switch): Don't context switch handling_longjmp.
	(handle_inferior_event): If handling a bp_longjmp breakpoint,
	create a bp_longjmp_resume breakpoint, and set it as current
	step_resume_breakpoint, then step over the longjmp breakpoint.  If
	handling a bp_longjmp_resume breakpoint, don't delete the longjmp
	breakpoint, delete the longjmp-resume breakpoint, and stop
	stepping.
	(currently_stepping): Remove handling_longjmp from expression.
	(insert_step_resume_breakpoint_at_sal): Update comment.
	(insert_longjmp_resume_breakpoint): New.

	* breakpoint.h (set_momentary_breakpoint_at_pc): Declare.
	(enable_longjmp_breakpoint, disable_longjmp_breakpoint): Delete
	declarations.
	(set_longjmp_breakpoint, delete_longjmp_breakpoint): Declare.
	(set_longjmp_resume_breakpoint): Delete declaration.

	* gdbthread.h (save_infrun_state): Remove handling_longjmp
	parameter.
	(load_infrun_state): Delete *handling_longjmp parameter.
	* thread.c (save_infrun_state): Remove handling_longjmp parameter.
	Update body.
	(load_infrun_state): Delete *handling_longjmp parameter.  Update
	body.

	* infcmd.c (disable_longjmp_breakpoint_cleanup): Delete.
	(delete_longjmp_breakpoint_cleanup): New.
	(step_1): Call set_longjmp_breakpoint instead of
	enable_longjmp_breakpoint.  Use delete_longjmp_breakpoint_cleanup
	instead of disable_longjmp_breakpoint_cleanup when making cleanup.
	(step_1_continuation): Pass thread id in the continuation args to
	step_once.
	(step_once): Add thread parameter.  Pass thread id the the
	continuation.

gdb/testsuite/
	* gdb.cp/annota2.exp: Adjust to breakpoints invalidations at
	different times.
@
text
@d6498 2
d6502 21
a6522 7
  if (strstr (b->addr_string, "throw") != NULL)
    printf_filtered (_("\nCatchpoint %d (exception thrown)\n"),
		     b->number);
  else
    printf_filtered (_("\nCatchpoint %d (exception caught)\n"),
		     b->number);

d6549 10
a6558 4
  if (strstr (b->addr_string, "throw") != NULL)
    printf_filtered (_("Catchpoint %d (throw)"), b->number);
  else
    printf_filtered (_("Catchpoint %d (catch)"), b->number);
d6580 1
a6580 1
			0, 0,
@


1.320
log
@	* alpha-tdep.h (ALPHA_REGISTER_BYTES): Delete.
	* arm-tdep.h (STATUS_REGISTER_SIZE): Delete.
	* breakpoint.c (args_for_catchpoint_enable, current_exception_event):
	Delete.
	* c-typeprint.c (c_type_print_base): Delete handling of template
	instantiations.
	* cp-support.h (METHOD_PTR_IS_VIRTUAL, METHOD_PTR_FROM_VOFFSET)
	(METHOD_PTR_TO_VOFFSET): Delete.
	* defs.h (QUIT_FIXME): Delete.
	* f-lang.h (DEFAULT_DOTMAIN_NAME_IN_MF77, DEFAULT_MAIN_NAME_IN_MF77)
	(DEFAULT_DOTMAIN_NAME_IN_XLF_BUGGY, DEFAULT_DOTMAIN_NAME_IN_XLF): Delete.
	* gdbtypes.h (struct cplus_struct_type): Delete is_inlined,
	ninstantiations, and instantiations.
	(TYPE_INSTANTIATIONS, TYPE_NINSTANTIATIONS, TYPE_INSTANTIATION)
	(TYPE_FN_FIELD_INLINED): Delete.
	* srec.h (SREC_BINARY): Delete.
	* symtab.c (symbol_init_demangled_name): Delete.
	* symtab.h (SYMBOL_INIT_DEMANGLED_NAME, symbol_init_demangled_name)
	(SYMBOL_OBJFILE, struct exception_event_record, CURRENT_EXCEPTION_KIND)
	(CURRENT_EXCEPTION_CATCH_SAL, CURRENT_EXCEPTION_CATCH_LINE)
	(CURRENT_EXCEPTION_CATCH_FILE, CURRENT_EXCEPTION_CATCH_PC)
	(CURRENT_EXCEPTION_THROW_SAL, CURRENT_EXCEPTION_THROW_LINE)
	(CURRENT_EXCEPTION_THROW_FILE, CURRENT_EXCEPTION_THROW_PC): Delete.
	* target.h (enum thread_control_capabilities): Delete tc_switch.
	(target_can_switch_threads): Delete.
@
text
@a147 2
static void create_longjmp_breakpoint (char *);

d1487 8
a4089 1
      bp_longjmp_resume
a4102 1
	  && type != bp_longjmp_resume
d4460 3
a4462 14
  if (func_name == NULL)
    b = create_internal_breakpoint (0, bp_longjmp_resume);
  else
    {
      if ((m = lookup_minimal_symbol_text (func_name, NULL)) == NULL)
	return;
 
      b = create_internal_breakpoint (SYMBOL_VALUE_ADDRESS (m), bp_longjmp);
    }

  b->enable_state = bp_disabled;
  b->silent = 1;
  if (func_name)
    b->addr_string = xstrdup (func_name);
d4471 1
a4471 1
enable_longjmp_breakpoint (void)
d4475 1
a4475 2
  ALL_BREAKPOINTS (b)
    if (b->type == bp_longjmp)
d4477 4
a4480 2
      b->enable_state = bp_enabled;
      update_global_location_list ();
d4484 1
d4486 1
a4486 1
disable_longjmp_breakpoint (void)
d4488 1
a4488 1
  struct breakpoint *b;
d4490 6
a4495 7
  ALL_BREAKPOINTS (b)
    if (b->type == bp_longjmp
	|| b->type == bp_longjmp_resume)
    {
      b->enable_state = bp_disabled;
      update_global_location_list ();
    }
a4787 24
/* Call this after hitting the longjmp() breakpoint.  Use this to set
   a new breakpoint at the target of the jmp_buf.

   FIXME - This ought to be done by setting a temporary breakpoint
   that gets deleted automatically... */

void
set_longjmp_resume_breakpoint (CORE_ADDR pc, struct frame_id frame_id)
{
  struct breakpoint *b;

  ALL_BREAKPOINTS (b)
    if (b->type == bp_longjmp_resume)
    {
      b->loc->requested_address = pc;
      b->loc->address = adjust_breakpoint_address (b->loc->requested_address,
                                                   b->type);
      b->enable_state = bp_enabled;
      b->frame_id = frame_id;
      update_global_location_list ();
      return;
    }
}

d4851 13
d7515 2
a7516 4
      /* Delete longjmp and overlay event breakpoints; they will be
         reset later by breakpoint_re_set.  */
    case bp_longjmp:
    case bp_longjmp_resume:
d7538 2
a7566 9

  if (gdbarch_get_longjmp_target_p (current_gdbarch))
    {
      create_longjmp_breakpoint ("longjmp");
      create_longjmp_breakpoint ("_longjmp");
      create_longjmp_breakpoint ("siglongjmp");
      create_longjmp_breakpoint ("_siglongjmp");
      create_longjmp_breakpoint (NULL);
    }
@


1.319
log
@	* breakpoint.c (create_exception_catchpoint): Remove prototype
	for already deleted function.
	* breakpoint.h (ep_is_exception_catchpoint): Likewise.
	* frame.h (show_stack_frame): Remove prototype.
	* stack.c (show_stack_frame): Remove empty, unused function.
	* source.c (symtab_to_fullname, print_source_lines): Small fix
	in comment.
	* value.c (show_values): Update comments to mention "show values"
	command instead of "info history".
@
text
@a143 7
typedef struct
  {
    enum exception_event_kind kind;
    int enable_p;
  }
args_for_catchpoint_enable;

a318 3
/* Pointer to current exception event record */
static struct exception_event_record *current_exception_event;

@


1.318
log
@* target.h (struct target_ops): Add
to_watchpoint_addr_within_range.
(target_watchpoint_addr_within_range): New function.
* target.c (update_current_target): Inherit
to_watchpoint_addr_within_range, defaulting to
default_watchpoint_addr_within_range.
(default_watchpoint_addr_within_range): New function.
(debug_to_watchpoint_addr_within_range): New function.
(setup_target_debug): Set to_watchpoint_addr_within_range.
* ppc-linux-nat.c (ppc_linux_watchpoint_addr_within_range):
New function.
(_initialize_ppc_linux_nat): Set to_watchpoint_addr_within_range.
* breakpoint.c (watchpoints_triggered): Use
target_watchpoint_addr_within_range.

* gdbint.texinfo (Algorithms): Describe
target_watchpoint_addr_within_range.
@
text
@a190 4
static void create_exception_catchpoint (int tempflag, char *cond_string,
					 enum exception_event_kind ex_event,
					 struct symtab_and_line *sal);

@


1.317
log
@	PR gdb/1665
	* breakpoint.c (create_breakpoint): Add breakpoint_ops argument and
	assign its value to the breakpoint created.
	(create_breakpoints): Add breakpoint_ops argument and pass it
	to create_breakpoint call.
	(break_command_really): Add breakpoint_ops argument and pass/assign
	appropriately.
	(break_command_1): Pass NULL as ops argument.
	(set_breakpoint): Pass NULL as ops argument.
	(print_one_exception_catchpoint): Print <PENDING> if no loc available.
	(handle_gnu_v3_exceptions): Call generic breakpoint code to insert
	catch and throw catchpoints.
@
text
@d2619 3
a2621 2
	  if (addr >= loc->address
	      && addr < loc->address + loc->length)
@


1.316
log
@        * breakpoint.c (condition_command, commands_from_control_command)
        (break_command_really): Minor reformatting.
@
text
@d5079 2
a5080 1
		   int thread, int ignore_count, int from_tty)
d5140 1
d5285 2
a5286 1
		    int thread, int ignore_count, int from_tty)
d5296 1
a5296 1
			 thread, ignore_count, from_tty);
d5464 1
d5598 1
a5598 1
			  thread, ignore_count, from_tty);
d5618 1
d5651 3
a5653 1
			pending_break_support, from_tty);
d5669 1
a5669 1
			0);
d6546 4
a6549 1
      ui_out_field_core_addr (uiout, "addr", b->loc->address);
d6552 2
a6553 1
  *last_addr = b->loc->address;
d6579 2
a6580 4
  char *trigger_func_name, *nameptr;
  struct symtabs_and_lines sals;
  struct breakpoint *b;

d6582 1
a6582 1
    trigger_func_name = xstrdup ("__cxa_begin_catch");
d6584 1
a6584 1
    trigger_func_name = xstrdup ("__cxa_throw");
d6586 6
a6591 7
  nameptr = trigger_func_name;
  sals = decode_line_1 (&nameptr, 1, NULL, 0, NULL, NULL);
  if (sals.nelts == 0)
    {
      xfree (trigger_func_name);
      return 0;
    }
a6592 14
  b = set_raw_breakpoint (sals.sals[0], bp_breakpoint);
  set_breakpoint_count (breakpoint_count + 1);
  b->number = breakpoint_count;
  b->cond_string = (cond_string == NULL) ? 
    NULL : savestring (cond_string, strlen (cond_string));
  b->thread = -1;
  b->addr_string = trigger_func_name;
  b->enable_state = bp_enabled;
  b->disposition = tempflag ? disp_del : disp_donttouch;
  b->ops = &gnu_v3_exception_catchpoint_ops;

  xfree (sals.sals);
  mention (b);
  update_global_location_list ();
@


1.315
log
@	* breakpoint.h (enum bpstat_what_main_action): Delete
	BPSTAT_WHAT_CLEAR_LONGJMP_RESUME_SINGLE.

	* breakpoint.c (clrs): Delete.
	(bpstat_what): Update table.

	* infrun.c (handle_inferior_event): Remove
	BPSTAT_WHAT_CLEAR_LONGJMP_RESUME_SINGLE handling.
@
text
@d604 12
a615 12
    {
      struct bp_location *loc = b->loc;
      for (; loc; loc = loc->next)
	{
	  if (loc->cond)
	    {
	      xfree (loc->cond);
	      loc->cond = 0;
	    }
	}
      if (b->cond_string != NULL)
	xfree (b->cond_string);
d617 26
a642 25
      if (*p == 0)
	{
	  b->cond_string = NULL;
	  if (from_tty)
	    printf_filtered (_("Breakpoint %d now unconditional.\n"), bnum);
	}
      else
	{
	  arg = p;
	  /* I don't know if it matters whether this is the string the user
	     typed in or the decompiled expression.  */
	  b->cond_string = savestring (arg, strlen (arg));
	  b->condition_not_parsed = 0;
	  for (loc = b->loc; loc; loc = loc->next)
	    {
	      arg = p;
	      loc->cond = parse_exp_1 (&arg, block_for_pc (loc->address), 0);
	      if (*arg)
		error (_("Junk at end of expression"));
	    }
	}
      breakpoints_changed ();
      breakpoint_modify_event (b->number);
      return;
    }
d727 1
a727 1
    }
d5569 1
a5569 1
        if (parse_condition_and_thread)
d5581 1
a5581 1
        else
@


1.314
log
@        * breakpoint.c (bpstat_check_location)
        (bpstat_check_watchpoint, bpstat_check_breakpoint_conditions):
        New, extracted from bpstat_stop_status.
        (bpstat_stop_status): Use the above.
@
text
@a3175 1
#define clrs BPSTAT_WHAT_CLEAR_LONGJMP_RESUME_SINGLE
d3200 1
a3200 1
     sgl  < clrs shl shlr slr sn sr ss
d3202 1
a3202 2
     clr  < clrs err shl shlr sn sr ss
     clrs < err shl shlr sn sr ss
d3213 1
a3213 3
     logic to handle the 'err' cases, and the CLEAR_LONGJMP_RESUME/
     CLEAR_LONGJMP_RESUME_SINGLE distinction (which breakpoint.h says
     is messy anyway).  */
d3223 1
a3223 1
  /*       kc    ss    sn    sgl    slr   clr    clrs   sr   shl   shlr
d3226 1
a3226 1
    {kc, ss, sn, sgl, slr, clr, clrs, sr, shl, shlr},
d3228 1
a3228 1
    {ss, ss, sn, ss, ss, ss, ss, sr, shl, shlr},
d3230 1
a3230 1
    {sn, sn, sn, sn, sn, sn, sn, sr, shl, shlr},
d3232 1
a3232 1
    {sgl, ss, sn, sgl, slr, clrs, clrs, sr, shl, shlr},
d3234 1
a3234 1
    {ss, ss, sn, ss, ss, ss, ss, sr, shl, shlr},
d3236 1
a3236 1
    {sn, sn, sn, sn, sn, sn, sn, sr, shl, shlr},
d3238 1
a3238 1
    {slr, ss, sn, slr, slr, err, err, sr, shl, shlr},
d3240 1
a3240 1
    {clr, ss, sn, clrs, err, err, err, sr, shl, shlr},
d3242 1
a3242 1
    {sr, sr, sr, sr, sr, sr, sr, sr, sr, sr},
d3244 1
a3244 1
    {shl, shl, shl, shl, shl, shl, shl, sr, shl, shlr},
d3246 1
a3246 1
    {shlr, shlr, shlr, shlr, shlr, shlr, shlr, sr, shlr, shlr}
a3254 1
#undef clrs
@


1.313
log
@	exec_cleanup murder.
	* breakpoint.c (until_break_command_continuation): Add
	the 'error' parameter.  Directly delete the breakoint as
	opposed to running cleanups.
	(until_break_command): Install continuation only
	after starting the target.  Don't use exec cleanups,
	use ordinary cleanups.  Discard cleanups is successfully
	started the target in async mode.
	(make_cleanup_delete_breakpoint): Remove.
	* breakpoint.h (make_cleanup_delete_breakpoint): Remove
	declaration.
	* defs.h (do_exec_cleanups, make_exec_cleanup): Remove
	declarations.
	(struct continations): Add the 'error' parameter to the
	continuation_hook field.
	(add_continuation, do_all_continuations)
	(add_intermediate_continuation)
	(do_all_intermediate_continuations): Add the 'error' parameter.
	* exceptions.c (throw_exception): Don't call do_exec_cleanups.
	* inf-loop.c (inferior_event_handler): Instead of calling
	discard_all_continuations, use do_all_continuations with 1 as
	'error' parameter.  Pass 0 as 'error' parameter in existing uses
	of discard_all_continuations.
	* infcmd.c (step_1): Do not use exec cleanup.  For async case, discard
	cleanups.
	(step_once): Install continuation only after resuming the target.
	(step_1_continuation): Disable longjmp breakpoint on error.
	(finish_command_continuation): Add the error parameter.  Delete
	the finish breakpoint directly, do not use cleanups.
	(finish_command): Do not use exec_cleanups. Always setup
	continuation.  For sync case, immediately run them.
	(attach_command_continuation): Add the error parameter.
	* infrun.c (fetch_inferior_event): Do not use exec cleanups to
	remove step_resume_breakpoint -- adjust delete it directly.
	* interps.c (interp_set): Adjust call to do_all_continations.
	* mi/mi-interp.c (mi_interpreter_exec_continuation): Do not
	do exec cleanups.
	* mi/mi-main.c (mi_cmd_target_select): Do not do exec
	cleanups.
	(mi_cmd_execute): Do not use exec_cleanup.
	(mi_execute_async_cli_command): Simplify the string concatenation
	logic.  Do no use exec cleanup.
	(mi_exec_async_cli_cmd_continuation): New parameter error.
	Free last_async_command.
	* top.c (command_line_handler_continuation): New parameter error.
	* utils.c (exec_cleanup_chain, make_exec_cleanup)
	(do_exec_cleanups): Remove.
	(add_continuation, do_all_continations)
	(add_intermediate_continuation)
	(do_all_intermediate_continuations): New parameter error.
@
text
@d2753 246
a3024 1
  int thread_id = pid_to_thread_id (ptid);
a3032 81
    if (b->type != bp_watchpoint
	&& b->type != bp_hardware_watchpoint
	&& b->type != bp_read_watchpoint
	&& b->type != bp_access_watchpoint
	&& b->type != bp_hardware_breakpoint
	&& b->type != bp_catch_fork
	&& b->type != bp_catch_vfork
	&& b->type != bp_catch_exec)	/* a non-watchpoint bp */
      {
	if (bl->address != bp_addr) 	/* address doesn't match */
	  continue;
	if (overlay_debugging		/* unmapped overlay section */
	    && section_is_overlay (bl->section) 
	    && !section_is_mapped (bl->section))
	  continue;
      }

    /* Continuable hardware watchpoints are treated as non-existent if the
       reason we stopped wasn't a hardware watchpoint (we didn't stop on
       some data address).  Otherwise gdb won't stop on a break instruction
       in the code (not from a breakpoint) when a hardware watchpoint has
       been defined.  Also skip watchpoints which we know did not trigger
       (did not match the data address).  */

    if ((b->type == bp_hardware_watchpoint
	 || b->type == bp_read_watchpoint
	 || b->type == bp_access_watchpoint)
	&& b->watchpoint_triggered == watch_triggered_no)
      continue;

    if (b->type == bp_hardware_breakpoint)
      {
	if (bl->address != bp_addr)
	  continue;
	if (overlay_debugging		/* unmapped overlay section */
	    && section_is_overlay (bl->section) 
	    && !section_is_mapped (bl->section))
	  continue;
      }

    /* Is this a catchpoint of a load or unload?  If so, did we
       get a load or unload of the specified library?  If not,
       ignore it. */
    if ((b->type == bp_catch_load)
#if defined(SOLIB_HAVE_LOAD_EVENT)
	&& (!SOLIB_HAVE_LOAD_EVENT (PIDGET (inferior_ptid))
	    || ((b->dll_pathname != NULL)
		&& (strcmp (b->dll_pathname, 
			    SOLIB_LOADED_LIBRARY_PATHNAME (
			      PIDGET (inferior_ptid)))
		    != 0)))
#endif
      )
      continue;

    if ((b->type == bp_catch_unload)
#if defined(SOLIB_HAVE_UNLOAD_EVENT)
	&& (!SOLIB_HAVE_UNLOAD_EVENT (PIDGET (inferior_ptid))
	    || ((b->dll_pathname != NULL)
		&& (strcmp (b->dll_pathname, 
			    SOLIB_UNLOADED_LIBRARY_PATHNAME (
			      PIDGET (inferior_ptid)))
		    != 0)))
#endif
      )
      continue;

    if ((b->type == bp_catch_fork)
	&& !inferior_has_forked (PIDGET (inferior_ptid),
				 &b->forked_inferior_pid))
      continue;

    if ((b->type == bp_catch_vfork)
	&& !inferior_has_vforked (PIDGET (inferior_ptid),
				  &b->forked_inferior_pid))
      continue;

    if ((b->type == bp_catch_exec)
	&& !inferior_has_execd (PIDGET (inferior_ptid), &b->exec_pathname))
      continue;

d3042 3
d3049 3
a3051 1
    /* Watchpoints may change this, if not found to have triggered. */
d3055 3
a3057 25
    if (b->type == bp_watchpoint
	|| b->type == bp_read_watchpoint
	|| b->type == bp_access_watchpoint
	|| b->type == bp_hardware_watchpoint)
      {
	CORE_ADDR addr;
	struct value *v;
	int must_check_value = 0;

 	if (b->type == bp_watchpoint)
	  /* For a software watchpoint, we must always check the
	     watched value.  */
	  must_check_value = 1;
	else if (b->watchpoint_triggered == watch_triggered_yes)
	  /* We have a hardware watchpoint (read, write, or access)
	     and the target earlier reported an address watched by
	     this watchpoint.  */
	  must_check_value = 1;
	else if (b->watchpoint_triggered == watch_triggered_unknown
		 && b->type == bp_hardware_watchpoint)
	  /* We were stopped by a hardware watchpoint, but the target could
	     not report the data address.  We must check the watchpoint's
	     value.  Access and read watchpoints are out of luck; without
	     a data address, we can't figure it out.  */
	  must_check_value = 1;
d3059 3
a3061 64
 	if (must_check_value)
	  {
	    char *message = xstrprintf ("Error evaluating expression for watchpoint %d\n",
					b->number);
	    struct cleanup *cleanups = make_cleanup (xfree, message);
	    int e = catch_errors (watchpoint_check, bs, message,
				  RETURN_MASK_ALL);
	    do_cleanups (cleanups);
	    switch (e)
	      {
	      case WP_DELETED:
		/* We've already printed what needs to be printed.  */
		bs->print_it = print_it_done;
		/* Stop.  */
		break;
	      case WP_VALUE_CHANGED:
		if (b->type == bp_read_watchpoint)
		  {
		    /* Don't stop: read watchpoints shouldn't fire if
		       the value has changed.  This is for targets
		       which cannot set read-only watchpoints.  */
		    bs->print_it = print_it_noop;
		    bs->stop = 0;
		    continue;
		  }
		++(b->hit_count);
		break;
	      case WP_VALUE_NOT_CHANGED:
		if (b->type == bp_hardware_watchpoint
		    || b->type == bp_watchpoint)
		  {
		    /* Don't stop: write watchpoints shouldn't fire if
		       the value hasn't changed.  */
		    bs->print_it = print_it_noop;
		    bs->stop = 0;
		    continue;
		  }
		/* Stop.  */
		++(b->hit_count);
		break;
	      default:
		/* Can't happen.  */
	      case 0:
		/* Error from catch_errors.  */
		printf_filtered (_("Watchpoint %d deleted.\n"), b->number);
		if (b->related_breakpoint)
		  b->related_breakpoint->disposition = disp_del_at_next_stop;
		b->disposition = disp_del_at_next_stop;
		/* We've already printed what needs to be printed.  */
		bs->print_it = print_it_done;
		break;
	      }
	  }
	else	/* must_check_value == 0 */
	  {
	    /* This is a case where some watchpoint(s) triggered, but
	       not at the address of this watchpoint, or else no
	       watchpoint triggered after all.  So don't print
	       anything for this watchpoint.  */
	    bs->print_it = print_it_noop;
	    bs->stop = 0;
            continue;
	  }
      }
d3063 3
a3066 2
	/* By definition, an encountered breakpoint is a triggered
	   breakpoint. */
a3067 8
      }

    if (frame_id_p (b->frame_id)
	&& !frame_id_eq (b->frame_id, get_frame_id (get_current_frame ())))
      bs->stop = 0;
    else
      {
	int value_is_zero = 0;
d3069 2
a3070 8
	/* If this is a scope breakpoint, mark the associated
	   watchpoint as triggered so that we will handle the
	   out-of-scope event.  We'll get to the watchpoint next
	   iteration.  */
	if (b->type == bp_watchpoint_scope)
	  b->related_breakpoint->watchpoint_triggered = watch_triggered_yes;

	if (bl->cond && bl->owner->disposition != disp_del_at_next_stop)
d3072 2
a3073 9
	    /* Need to select the frame, with all that implies
	       so that the conditions will have the right context.  */
	    select_frame (get_current_frame ());
	    value_is_zero
	      = catch_errors (breakpoint_cond_eval, (bl->cond),
			      "Error in testing breakpoint condition:\n",
			      RETURN_MASK_ALL);
	    /* FIXME-someday, should give breakpoint # */
	    free_all_values ();
d3075 6
a3080 1
	if (bl->cond && value_is_zero)
d3082 2
a3083 38
	    bs->stop = 0;
	    /* Don't consider this a hit.  */
	    --(b->hit_count);
	  }
	else if (b->thread != -1 && b->thread != thread_id)
	  {
	    bs->stop = 0;
	    /* Don't consider this a hit.  */
	    --(b->hit_count);
	  }
	else if (b->ignore_count > 0)
	  {
	    b->ignore_count--;
	    annotate_ignore_count_change ();
	    bs->stop = 0;
	  }
	else if (b->type == bp_thread_event || b->type == bp_overlay_event)
	  /* We do not stop for these.  */
	  bs->stop = 0;
	else
	  {
	    /* We will stop here */
	    if (b->disposition == disp_disable)
	      {
		b->enable_state = bp_disabled;
		update_global_location_list ();
	      }
	    if (b->silent)
	      bs->print = 0;
	    bs->commands = b->commands;
	    if (bs->commands &&
		(strcmp ("silent", bs->commands->line) == 0
		 || (xdb_commands && strcmp ("Q", bs->commands->line) == 0)))
	      {
		bs->commands = bs->commands->next;
		bs->print = 0;
	      }
	    bs->commands = copy_command_lines (bs->commands);
d3085 1
d3087 1
@


1.312
log
@	* breakpoint.h (bp_location_p): New typedef.
	Register a vector of bp_location_p.
	* breakpoint.c (always_inserted_mode)
	(show_always_inserted_mode): New.
	(unlink_locations_from_global_list): Remove.
	(update_global_location_list)
	(update_global_location_list_nothrow): New.
	(update_watchpoint): Don't free locations.
	(should_insert_location): New.
	(insert_bp_location): Use should_insert_location.
	(insert_breakpoint_locations): Copied from
	insert_breakpoints.
	(insert_breakpoint): Use insert_breakpoint_locations.
	(bpstat_stop_status): Call update_global_location_list
	when disabling breakpoint.
	(allocate_bp_location): Don't add to bp_location_chain.
	(set_raw_breakpoint)
	(create_longjmp_breakpoint, enable_longjmp_breakpoint)
	(disable_longjmp_breakpoint, create_overlay_event_breakpoint)
	(enable_overlay_breakpoints, disable_overlay_breakpoints)
	(set_longjmp_resume_breakpoint)
	(enable_watchpoints_after_interactive_call_stop)
	(disable_watchpoints_before_interactive_call_start)
	(create_internal_breakpoint)
	(create_fork_vfork_event_catchpoint)
	(create_exec_event_catchpoint, set_momentary_breakpoint)
	(create_breakpoints, break_command_1, watch_command_1)
	(create_exception_catchpoint)
	(handle_gnu_v3_exceptions)
	(disable_breakpoint, breakpoint_re_set_one)
	(create_thread_event_breakpoint, create_solib_event_breakpoint)
	(create_ada_exception_breakpoint): : Don't call check_duplicates.
	Call update_global_location_list.
	(delete_breakpoint): Don't remove locations and don't
	try to reinsert them. Call update_global_location_list.
	(update_breakpoint_locations): Likewise.
	(restore_always_inserted_mode): New.
	(update_breakpoints_after_exec): Temporary disable
	always inserted mode.
	* Makefile.in: Update dependencies.

	* infrun.c (proceed): Remove breakpoints while stepping
	over breakpoint.
	(handle_inferior_event): Don't remove or insert
	breakpoints.
	* linux-fork.c (checkpoint_command): Remove breakpoints
	before fork and insert after.
	(linux_fork_context): Remove breakpoints before switch
	and insert after.
	* target.c (target_disconnect, target_detach): Remove
	breakpoints from target.
@
text
@d67 2
a68 1
static void until_break_command_continuation (struct continuation_arg *arg);
d6134 1
a6134 1
until_break_command_continuation (struct continuation_arg *arg)
d6136 3
a6138 4
  struct cleanup *cleanups;

  cleanups = (struct cleanup *) arg->data.pointer;
  do_exec_cleanups (cleanups);
d6149 1
d6152 1
d6188 1
a6188 25
  if (!target_can_async_p ())
    old_chain = make_cleanup_delete_breakpoint (breakpoint);
  else
    old_chain = make_exec_cleanup_delete_breakpoint (breakpoint);

  /* If we are running asynchronously, and the target supports async
     execution, we are not waiting for the target to stop, in the call
     tp proceed, below. This means that we cannot delete the
     brekpoints until the target has actually stopped. The only place
     where we get a chance to do that is in fetch_inferior_event, so
     we must set things up for that. */

  if (target_can_async_p ())
    {
      /* In this case the arg for the continuation is just the point
         in the exec_cleanups chain from where to start doing
         cleanups, because all the continuation does is the cleanups in
         the exec_cleanup_chain. */
      arg1 =
	(struct continuation_arg *) xmalloc (sizeof (struct continuation_arg));
      arg1->next         = NULL;
      arg1->data.pointer = old_chain;

      add_continuation (until_break_command_continuation, arg1);
    }
d6196 3
a6198 6
      breakpoint = set_momentary_breakpoint (sal, get_frame_id (prev_frame),
					     bp_until);
      if (!target_can_async_p ())
	make_cleanup_delete_breakpoint (breakpoint);
      else
	make_exec_cleanup_delete_breakpoint (breakpoint);
d6202 26
a6227 3
  /* Do the cleanups now, anly if we are not running asynchronously,
     of if we are, but the target is still synchronous. */
  if (!target_can_async_p ())
a7188 6
struct cleanup *
make_exec_cleanup_delete_breakpoint (struct breakpoint *b)
{
  return make_exec_cleanup (do_delete_breakpoint_cleanup, b);
}

@


1.311
log
@	* breakpoint.c (print_one_breakpoint_location): In MI
	mode, report the location string the breakpoint was
	originally created with.
@
text
@d63 2
d210 5
a214 2
static void
unlink_locations_from_global_list (struct breakpoint *bpt);
d216 1
a216 2
static int
is_hardware_watchpoint (struct breakpoint *bpt);
d272 12
d894 4
a897 8
  unlink_locations_from_global_list (b);
  for (loc = b->loc; loc;)
    {
      struct bp_location *loc_next = loc->next;
      remove_breakpoint (loc, mark_uninserted);
      xfree (loc);
      loc = loc_next;
    }
d1035 17
d1066 1
a1066 4
  if (!breakpoint_enabled (bpt->owner))
    return 0;

  if (!bpt->enabled || bpt->shlib_disabled || bpt->inserted || bpt->duplicate)
d1267 22
d1294 2
a1295 2
void
insert_breakpoints (void)
d1307 1
a1307 1

a1310 4

  ALL_BREAKPOINTS (bpt)
    if (is_hardware_watchpoint (bpt))
      update_watchpoint (bpt, 0 /* don't reparse */);      
d1314 1
a1314 1
      if (!breakpoint_enabled (b->owner))
d1342 3
d1452 6
d1463 1
d1470 7
d1558 1
d1598 3
a1600 3
  if (b->owner->type == bp_none)
    warning (_("attempted to remove apparently deleted breakpoint #%d?"), 
	     b->owner->number);
d3033 4
a3036 1
	      b->enable_state = bp_disabled;
a4270 12
  /* Add this breakpoint to the end of the chain.  */

  loc_p = bp_location_chain;
  if (loc_p == 0)
    bp_location_chain = loc;
  else
    {
      while (loc_p->global_next)
	loc_p = loc_p->global_next;
      loc_p->global_next = loc;
    }

d4278 4
a4385 1
  check_duplicates (b);
d4449 1
d4465 1
a4465 1
      check_duplicates (b);
d4479 1
a4479 1
      check_duplicates (b);
d4506 1
d4518 1
a4518 1
      check_duplicates (b);
d4532 1
a4532 1
      check_duplicates (b);
d4548 2
d4594 1
d4692 2
d4731 1
d4792 1
a4792 1
      check_duplicates (b);
d4811 1
a4811 1
	check_duplicates (b);
d4830 1
a4830 1
	check_duplicates (b);
d4856 2
d5261 2
d5580 2
d6008 1
d6567 1
d6640 1
a6961 3
/* Remove locations of breakpoint BPT from
   the global list of breakpoint locations.  */

d6963 1
a6963 1
unlink_locations_from_global_list (struct breakpoint *bpt)
d6965 12
a6976 5
  /* This code assumes that the locations
     of a breakpoint are found in the global list
     in the same order,  but not necessary adjacent.  */
  struct bp_location **tmp = &bp_location_chain;
  struct bp_location *here = bpt->loc;
d6978 2
a6979 4
  if (here == NULL)
    return;

  for (; *tmp && here;)
d6981 1
a6981 1
      if (*tmp == here)
d6983 3
a6985 2
	  *tmp = here->global_next;
	  here = here->next;
d6987 26
a7012 1
      else
d7014 45
a7058 1
	  tmp = &((*tmp)->global_next);
d7060 8
d7069 11
d7090 1
a7090 1
  struct bp_location *loc;
a7113 12
  for (loc = bpt->loc; loc; loc = loc->next)
    {
      if (loc->inserted)
	remove_breakpoint (loc, mark_inserted);
      
      if (loc->cond)
	xfree (loc->cond);

      if (loc->function_name)
	xfree (loc->function_name);
    }

a7123 79
  unlink_locations_from_global_list (bpt);

  check_duplicates (bpt);

  if (bpt->type != bp_hardware_watchpoint
      && bpt->type != bp_read_watchpoint
      && bpt->type != bp_access_watchpoint
      && bpt->type != bp_catch_fork
      && bpt->type != bp_catch_vfork
      && bpt->type != bp_catch_exec)
    for (loc = bpt->loc; loc; loc = loc->next)
      {
	/* If this breakpoint location was inserted, and there is 
	   another breakpoint at the same address, we need to 
	   insert the other breakpoint.  */
	if (loc->inserted)
	  {
	    struct bp_location *loc2;
	    ALL_BP_LOCATIONS (loc2)
	      if (loc2->address == loc->address
		  && loc2->section == loc->section
		  && !loc->duplicate
		  && loc2->owner->enable_state != bp_disabled
		  && loc2->enabled 
		  && !loc2->shlib_disabled
		  && loc2->owner->enable_state != bp_call_disabled)
		{
		  int val;

		  /* We should never reach this point if there is a permanent
		     breakpoint at the same address as the one being deleted.
		     If there is a permanent breakpoint somewhere, it should
		     always be the only one inserted.  */
		  if (loc2->owner->enable_state == bp_permanent)
		    internal_error (__FILE__, __LINE__,
				    _("another breakpoint was inserted on top of "
				      "a permanent breakpoint"));

		  memset (&loc2->target_info, 0, sizeof (loc2->target_info));
		  loc2->target_info.placed_address = loc2->address;
		  if (b->type == bp_hardware_breakpoint)
		    val = target_insert_hw_breakpoint (&loc2->target_info);
		  else
		    val = target_insert_breakpoint (&loc2->target_info);

		  /* If there was an error in the insert, print a message, then stop execution.  */
		  if (val != 0)
		    {
		      struct ui_file *tmp_error_stream = mem_fileopen ();
		      make_cleanup_ui_file_delete (tmp_error_stream);
		      
		      
		      if (b->type == bp_hardware_breakpoint)
			{
			  fprintf_unfiltered (tmp_error_stream, 
					      "Cannot insert hardware breakpoint %d.\n"
					      "You may have requested too many hardware breakpoints.\n",
					      b->number);
			}
		      else
			{
			  fprintf_unfiltered (tmp_error_stream, "Cannot insert breakpoint %d.\n", b->number);
			  fprintf_filtered (tmp_error_stream, "Error accessing memory address ");
			  fputs_filtered (paddress (loc2->address),
					  tmp_error_stream);
			  fprintf_filtered (tmp_error_stream, ": %s.\n",
					    safe_strerror (val));
			}
		      
		      fprintf_unfiltered (tmp_error_stream,"The same program may be running in another process.");
		      target_terminal_ours_for_output ();
		      error_stream(tmp_error_stream); 
		    }
		  else
		    loc2->inserted = 1;
		}
	  }
      }

d7160 12
a7175 6
  for (loc = bpt->loc; loc;)
    {
      struct bp_location *loc_next = loc->next;
      xfree (loc);
      loc = loc_next;
    }
a7306 1
  unlink_locations_from_global_list (b);
d7385 1
a7385 6
  while (existing_locations)
    {
      struct bp_location *next = existing_locations->next;
      free_bp_location (existing_locations);
      existing_locations = next;
    }
a7480 4
      /* Now that this is re-enabled, check_duplicates
	 can be used. */
      check_duplicates (b);

d7780 1
a7780 1
  check_duplicates (bpt);
d7819 1
a7819 1
      check_duplicates (loc->owner);
d7904 1
a7904 1
  check_duplicates (bpt);
d7955 1
a7955 1
      check_duplicates (loc->owner);
d8123 5
d8529 13
@


1.310
log
@2008-04-17  Marc Khouzam  <marc.khouzam@@ericsson.com>

       * breakpoint.c (update_watchpoint): Always reparse
       condition.
@
text
@d3699 9
@


1.309
log
@        * breakpoint.c (print_one_breakpoint_location): Make sure to print
        the breakpoint address only once.
@
text
@d997 5
a1001 1
      if (reparse && b->cond_string != NULL)
a1003 5
	  if (b->loc->cond)
	    {
	      xfree (b->loc->cond);
	      b->loc->cond = NULL;
	    }
@


1.308
log
@PR gdb/2424
	* infrun.c (normal_stop) Move breakpoint_auto_delete further down
	to allow printing to 'see' real reason of stop. This fixes PR 2424.
	* breakpoint.c (bpdisp_texst): New function. The function takes over
	the role of bpstats static array in print_one_breakpoint_location.
	(print_it_typical): Print "Temporary breakpoint" instead
	of just "Breakpoint" when breakpoint is, well, temporary. For mi-like
	protocols, print disp field.
	(print_one_breakpoint_location): Removed bpdisps static definition.
	Call new bpstat_text function to get value for 'disp' field.
	(mention): Print "Temporary breakpoint" instead of just "Breakpoint".
@
text
@d3610 1
a3610 1
	    if (b->loc == NULL || loc->shlib_disabled)
@


1.307
log
@	Async mode fixes.
        * Makefile.in (infcmd.o, inf-loop.o): Update dependencies.
        * breakpoint.c (bpstat_do_actions): In async mode,
        don't jump to top expecting stop_bpstat to be already
        updated.
        * event-loop.c (start_event_loop): Call async_enable_stdin
        on exception.
        * event-top.c (async_enable_stdin): Do nothing if sync_execution
        is not set.
        (command_handler): Do not setup continuation here.
        (command_line_handler_continuation): Move to...
        * top.c (command_line_handler_continuation): ... here.
        (execute_command): In async mode, register continuation.
        Don't check frame's language in running in async mode.
        * exceptions.c (throw_exception): Don't do exec_error_cleanups.
        * inf-loop.c (complete_execution): Inline into...
        (inferior_event_handler): ... here.  Clear target_executing before
        doing any cleanups.  Don't try to show prompt if the target was
        resumed.
        * infcmd.c (signal_command): Add support for async mode.
        (finish_command): Only add continuation if the target was
        successfully resumed.
        * remote.c (init_async_opts): Register to_get_thread_local_address
        handler.
        * mi/mi-interp.c (mi_cmd_interpreter_exec): Don't mess
        with sync_execution.
        * tui/tui-interp.c (tui_command_loop): Call async_enable_stdin
        on exception.
@
text
@d214 9
a223 1

d2192 1
d2206 1
d2212 4
a2215 1
      ui_out_text (uiout, "\nBreakpoint ");
d2217 5
a2221 2
	ui_out_field_string (uiout, "reason", 
			     async_reason_lookup (EXEC_ASYNC_BREAKPOINT_HIT));
a3430 2
  static char *bpdisps[] =
  {"del", "dstp", "dis", "keep"};
d3487 1
a3487 1
    ui_out_field_string (uiout, "disp", bpdisps[(int) b->disposition]);
d4859 5
a4863 1
	printf_filtered (_("Breakpoint %d"), b->number);
@


1.306
log
@	* breakpoint.h (breakpoint_restore_shadows): New
	declaration.
	* breakpoint.c (breakpoint_restore_shadows): New.
	(read_memory_nobpt): Delete.
	* gdbcore.h (read_memory_nobpt): Delete declaration.
	* target.c (memory_xfer_partial): Call
	breakpoint_restore_shadows.
	(restore_show_memory_breakpoints)
	(make_show_memory_beakpoints_cleanup): New.
	(show_memory_breakpoints): New.
	* target.h (make_show_memory_beakpoints_cleanup): Declare.
	* ppc-linux-tdep.c (ppc_linux_memory_remove_breakpoint):
	Make sure we see memory breakpoints when checking if
	breakpoint is still there.
	* alpha-tdep.c, alphanbsd-tdep.c, frame.c, frv-tdep.c,
	hppa-linux-tdep.c, hppa-tdep.c, i386-linux-nat.c, i386-tdep.c,
	m68klinux-tdep.c, mips-tdep.c, mn10300-tdep.c, s390-tdep.c,
	sparc-tdep.c: Use target_read_memory instead of read_memory_nobpt.
@
text
@d2117 24
a2140 5
	/* The inferior is proceeded by the command; bomb out now.
	   The bpstat chain has been blown away by wait_for_inferior.
	   But since execution has stopped again, there is a new bpstat
	   to look at, so start over.  */
	goto top;
@


1.305
log
@	* breakpoint.c (fetch_watchpoint_value): New function.
	(update_watchpoint): Set and clear val_valid.  Use
	fetch_watchpoint_value.  Handle unreadable values on the
	value chain.  Correct check for user-requested array watchpoints.
	(breakpoint_init_inferior): Clear val_valid.
	(watchpoint_value_print): New function.
	(print_it_typical): Use it.  Do not free or clear old_val.  Print
	watchpoints even if old_val == NULL.
	(watchpoint_check): Use fetch_watchpoint_value.  Check for values
	becoming readable or unreadable.
	(watch_command_1): Use fetch_watchpoint_value.  Set val_valid.
	(do_enable_watchpoint): Likewise.
	* breakpoint.h (struct breakpoint): Update comment for val.  Add
	val_valid.
	* NEWS: Mention watchpoints on inaccessible memory.

	* gdb.base/watchpoint.c (global_ptr, func4): New.
	(main): Call func4.
	* gdb.base/watchpoint.exp: Call test_inaccessible_watchpoint.
	(test_inaccessible_watchpoint): New.

	* gdb.texinfo (Set Watchpoints): Mention watchpoints on
	unreadable memory.  Delete obsolete SPARClite reference.
@
text
@d705 2
a706 2
/* Like target_read_memory() but if breakpoints are inserted, return
   the shadow contents instead of the breakpoints themselves.
d708 2
a709 7
   Read "memory data" from whatever target or inferior we have. 
   Returns zero if successful, errno value if not.  EIO is used
   for address out of bounds.  If breakpoints are inserted, returns
   shadow contents, not the breakpoints themselves.  From breakpoint.c.  */

int
read_memory_nobpt (CORE_ADDR memaddr, gdb_byte *myaddr, unsigned len)
d711 1
a711 2
  int status;
  const struct bp_location *b;
d714 1
a714 4

  if (gdbarch_breakpoint_from_pc (current_gdbarch, &bp_addr, &bp_size) == NULL)
    /* No breakpoints on this machine. */
    return target_read_memory (memaddr, myaddr, len);
d733 1
d738 1
a742 5
    /* Copy the breakpoint from the shadow contents, and recurse for
       the things before and after.  */
    {
      /* Offset within shadow_contents.  */
      int bptoffset = 0;
d744 8
a751 7
      if (bp_addr < memaddr)
	{
	  /* Only copy the second part of the breakpoint.  */
	  bp_size -= memaddr - bp_addr;
	  bptoffset = memaddr - bp_addr;
	  bp_addr = memaddr;
	}
d753 5
a757 16
      if (bp_addr + bp_size > memaddr + len)
	{
	  /* Only copy the first part of the breakpoint.  */
	  bp_size -= (bp_addr + bp_size) - (memaddr + len);
	}

      memcpy (myaddr + bp_addr - memaddr,
	      b->target_info.shadow_contents + bptoffset, bp_size);

      if (bp_addr > memaddr)
	{
	  /* Copy the section of memory before the breakpoint.  */
	  status = read_memory_nobpt (memaddr, myaddr, bp_addr - memaddr);
	  if (status != 0)
	    return status;
	}
d759 2
a760 11
      if (bp_addr + bp_size < memaddr + len)
	{
	  /* Copy the section of memory after the breakpoint.  */
	  status = read_memory_nobpt (bp_addr + bp_size,
				      myaddr + bp_addr + bp_size - memaddr,
				      memaddr + len - (bp_addr + bp_size));
	  if (status != 0)
	    return status;
	}
      return 0;
    }
a761 2
  /* Nothing overlaps.  Just call read_memory_noerr.  */
  return target_read_memory (memaddr, myaddr, len);
d4269 1
a4269 1
     breakpoint may cause read_memory_nobpt() to be called and we do
@


1.304
log
@        * breakpoint.c (skip_prologue_sal): New function.
        (resolve_sal_pc): Adjust SAL past prologue if the SAL was
        computed from a line number.
@
text
@d58 1
d830 59
a888 1
/* Assuming that B is a hardware breakpoint:
a898 1
  struct value *mark = value_mark ();
d950 2
a951 1
      b->val = NULL;      
a952 1
  
d961 3
a963 1
      struct value *v, *next;
a964 11
      /* Evaluate the expression and make sure it's not lazy, so that
	 after target stops again, we have a non-lazy previous value
	 to compare with. Also, making the value non-lazy will fetch
	 intermediate values as needed, which we use to decide which
	 addresses to watch.

	 The value returned by evaluate_expression is stored in b->val.
	 In addition, we look at all values which were created
	 during evaluation, and set watchoints at addresses as needed.
	 Those values are explicitly deleted here.  */
      v = evaluate_expression (b->exp);
d969 5
a973 4
      if (b->val == NULL)
	b->val = v;
      value_contents (v);
      value_release_to_mark (mark);
d976 1
a976 1
      for (; v; v = next)
d980 3
a982 1
	     must watch it.  */
d984 1
a984 1
	      && ! value_lazy (v))
d991 1
a991 1
	      if (v == b->val
d1736 1
d2159 11
d2288 15
a2302 20
      if (bs->old_val != NULL)
	{
	  annotate_watchpoint (b->number);
	  if (ui_out_is_mi_like_p (uiout))
	    ui_out_field_string
	      (uiout, "reason",
	       async_reason_lookup (EXEC_ASYNC_WATCHPOINT_TRIGGER));
	  mention (b);
	  ui_out_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "value");
	  ui_out_text (uiout, "\nOld value = ");
	  value_print (bs->old_val, stb->stream, 0, Val_pretty_default);
	  ui_out_field_stream (uiout, "old", stb);
	  ui_out_text (uiout, "\nNew value = ");
	  value_print (b->val, stb->stream, 0, Val_pretty_default);
	  ui_out_field_stream (uiout, "new", stb);
	  do_cleanups (ui_out_chain);
	  ui_out_text (uiout, "\n");
	  value_free (bs->old_val);
	  bs->old_val = NULL;
	}
d2315 1
a2315 1
      value_print (b->val, stb->stream, 0, Val_pretty_default);
d2323 1
a2323 1
      if (bs->old_val != NULL)     
d2333 1
a2333 1
	  value_print (bs->old_val, stb->stream, 0, Val_pretty_default);
a2334 2
	  value_free (bs->old_val);
	  bs->old_val = NULL;
d2347 1
a2347 1
      value_print (b->val, stb->stream, 0,Val_pretty_default);
d2634 5
a2638 2
      struct value *new_val = evaluate_expression (b->exp);
      if (!value_equal (b->val, new_val))
d2640 5
a2644 2
	  release_value (new_val);
	  value_free_to_mark (mark);
d2647 1
d5813 3
a5815 4
  val = evaluate_expression (exp);
  release_value (val);
  if (value_lazy (val))
    value_fetch_lazy (val);
d5904 1
d7788 5
a7792 5
      bpt->val = evaluate_expression (bpt->exp);
      release_value (bpt->val);
      if (value_lazy (bpt->val))
	value_fetch_lazy (bpt->val);
      
@


1.303
log
@	* breakpoint.c (print_one_breakpoint_location): Revert Enb field
	to old format.  Discard breakpoint address if shared library is
	unloaded.
	(breakpoint_1): Adjust formatting of table header accordingly.
@
text
@d5485 19
d5518 5
@


1.303.6.1
log
@gdb/insight for ARCompact (from Richard Stuckey)
@
text
@a95 4
// begin ARC
static void watch_range_command_1 (unsigned int, unsigned int, int, int);
// end ARC

a844 7
// begin ARC
  /* If this is a range watchpoint.  */
  if (b->exp == NULL)
      /* There is no need to change it.  */
      return;
// end ARC

a1019 3
// begin ARC
  bpt->target_info.range = bpt->length;
// end ARC
a2105 24
// begin ARC
static void
check_range (struct breakpoint *bp, enum async_reply_reason reason)
{ 
  CORE_ADDR addr;

  if (target_stopped_data_address (&current_target, &addr))
    {
      if (addr >= bp->loc->address &&
          addr <  bp->loc->address + bp->loc->length)
        {
          if (ui_out_is_mi_like_p (uiout))
            ui_out_field_string
              (uiout, "reason",
               async_reason_lookup (reason));
          mention (bp);
          ui_out_text(uiout, "triggered by access at address ");
          ui_out_field_core_addr(uiout, "", addr);
          ui_out_text (uiout, "\n");
        }
    }
}
// end ARC

d2224 20
a2243 29
// begin ARC
      if (b->exp)
        {
// end ARC
          if (bs->old_val != NULL)
	    {
	      annotate_watchpoint (b->number);
	      if (ui_out_is_mi_like_p (uiout))
	        ui_out_field_string
	          (uiout, "reason",
	           async_reason_lookup (EXEC_ASYNC_WATCHPOINT_TRIGGER));
	      mention (b);
	      ui_out_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "value");
	      ui_out_text (uiout, "\nOld value = ");
	      value_print (bs->old_val, stb->stream, 0, Val_pretty_default);
	      ui_out_field_stream (uiout, "old", stb);
	      ui_out_text (uiout, "\nNew value = ");
	      value_print (b->val, stb->stream, 0, Val_pretty_default);
	      ui_out_field_stream (uiout, "new", stb);
	      do_cleanups (ui_out_chain);
	      ui_out_text (uiout, "\n");
	      value_free (bs->old_val);
	      bs->old_val = NULL;
	    }
// begin ARC
        }
      else
        check_range(b, EXEC_ASYNC_WATCHPOINT_TRIGGER);
// end ARC
d2249 11
a2259 20
// begin ARC
      if (b->exp)
        {
// end ARC
          if (ui_out_is_mi_like_p (uiout))
	    ui_out_field_string
	      (uiout, "reason",
	       async_reason_lookup (EXEC_ASYNC_READ_WATCHPOINT_TRIGGER));
          mention (b);
          ui_out_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "value");
          ui_out_text (uiout, "\nValue = ");
          value_print (b->val, stb->stream, 0, Val_pretty_default);
          ui_out_field_stream (uiout, "value", stb);
          do_cleanups (ui_out_chain);
          ui_out_text (uiout, "\n");
// begin ARC
        }
      else
        check_range(b, EXEC_ASYNC_READ_WATCHPOINT_TRIGGER);
// end ARC
d2264 30
a2293 39
// begin ARC
      if (b->exp)
        {
// end ARC
          if (bs->old_val != NULL)     
	    {
	      annotate_watchpoint (b->number);
	      if (ui_out_is_mi_like_p (uiout))
	        ui_out_field_string
	          (uiout, "reason",
	           async_reason_lookup (EXEC_ASYNC_ACCESS_WATCHPOINT_TRIGGER));
	      mention (b);
	      ui_out_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "value");
	      ui_out_text (uiout, "\nOld value = ");
	      value_print (bs->old_val, stb->stream, 0, Val_pretty_default);
	      ui_out_field_stream (uiout, "old", stb);
	      value_free (bs->old_val);
	      bs->old_val = NULL;
	      ui_out_text (uiout, "\nNew value = ");
	    }
          else 
	    {
	      mention (b);
	      if (ui_out_is_mi_like_p (uiout))
	        ui_out_field_string
	          (uiout, "reason",
	           async_reason_lookup (EXEC_ASYNC_ACCESS_WATCHPOINT_TRIGGER));
	      ui_out_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "value");
	      ui_out_text (uiout, "\nValue = ");
	    }
          value_print (b->val, stb->stream, 0,Val_pretty_default);
          ui_out_field_stream (uiout, "new", stb);
          do_cleanups (ui_out_chain);
          ui_out_text (uiout, "\n");
// begin ARC
        }
      else
        check_range(b, EXEC_ASYNC_ACCESS_WATCHPOINT_TRIGGER);
// end ARC
a2531 5
// begin ARC
  if (b->exp == NULL)
     return WP_VALUE_CHANGED;
// end ARC

d2670 1
a2670 11
// begin ARC
          {
            /* is the address within the b/p range? */
            if (bp_addr < b->loc->address ||
                bp_addr > b->loc->address + b->loc->length - 1)
// end ARC
              continue;
// begin ARC
          }
// end ARC

d2767 16
a2782 7
// begin ARC
        if (b->exp == NULL)
          {
            CORE_ADDR addr;

            if (!target_stopped_data_address (&current_target, &addr))
               continue;
d2784 9
a2792 28
            if (addr >= b->loc->address &&
                addr < b->loc->address + b->loc->length)
              {
                /* Stop.  */
                ++(b->hit_count);
              }
          }
        else
          {
// end ARC
 	    if (b->type == bp_watchpoint)
	      /* For a software watchpoint, we must always check the
	         watched value.  */
	      must_check_value = 1;
	    else if (b->watchpoint_triggered == watch_triggered_yes)
	      /* We have a hardware watchpoint (read, write, or access)
	         and the target earlier reported an address watched by
	         this watchpoint.  */
	      must_check_value = 1;
	    else if (b->watchpoint_triggered == watch_triggered_unknown
		     && b->type == bp_hardware_watchpoint)
	      /* We were stopped by a hardware watchpoint, but the target could
	         not report the data address.  We must check the watchpoint's
	         value.  Access and read watchpoints are out of luck; without
	         a data address, we can't figure it out.  */
	      must_check_value = 1;

 	    if (must_check_value)
d2794 41
a2834 50
	        char *message = xstrprintf ("Error evaluating expression for watchpoint %d\n",
					    b->number);
	        struct cleanup *cleanups = make_cleanup (xfree, message);
	        int e = catch_errors (watchpoint_check, bs, message,
				      RETURN_MASK_ALL);
	        do_cleanups (cleanups);
	        switch (e)
	          {
	          case WP_DELETED:
		    /* We've already printed what needs to be printed.  */
		    bs->print_it = print_it_done;
		    /* Stop.  */
		    break;
	          case WP_VALUE_CHANGED:
		    if (b->type == bp_read_watchpoint)
		      {
		        /* Don't stop: read watchpoints shouldn't fire if
		           the value has changed.  This is for targets
		           which cannot set read-only watchpoints.  */
		        bs->print_it = print_it_noop;
		        bs->stop = 0;
		        continue;
		      }
		    ++(b->hit_count);
		    break;
	          case WP_VALUE_NOT_CHANGED:
		    if (b->type == bp_hardware_watchpoint
		        || b->type == bp_watchpoint)
		      {
		        /* Don't stop: write watchpoints shouldn't fire if
		           the value hasn't changed.  */
		        bs->print_it = print_it_noop;
		        bs->stop = 0;
		        continue;
		      }
		    /* Stop.  */
		    ++(b->hit_count);
		    break;
	          default:
		    /* Can't happen.  */
	          case 0:
		    /* Error from catch_errors.  */
		    printf_filtered (_("Watchpoint %d deleted.\n"), b->number);
		    if (b->related_breakpoint)
		      b->related_breakpoint->disposition = disp_del_at_next_stop;
		    b->disposition = disp_del_at_next_stop;
		    /* We've already printed what needs to be printed.  */
		    bs->print_it = print_it_done;
		    break;
	          }
d2836 11
a2846 13
	    else	/* must_check_value == 0 */
	      {
	        /* This is a case where some watchpoint(s) triggered, but
	           not at the address of this watchpoint, or else no
	           watchpoint triggered after all.  So don't print
	           anything for this watchpoint.  */
	        bs->print_it = print_it_noop;
	        bs->stop = 0;
                continue;
	      }
// begin ARC
          }
// end ARC
d3467 8
a3474 25
// begin ARC
        if (b->exp)
          {
// end ARC
	    /* Field 4, the address, is omitted (which makes the columns
	       not line up too nicely with the headers, but the effect
	       is relatively readable).  */
	    if (addressprint)
	      ui_out_field_skip (uiout, "addr");
	    annotate_field (5);
	    print_expression (b->exp, stb->stream);
	    ui_out_field_stream (uiout, "what", stb);
// begin ARC
          }
        else
          {
            /* exp_string has format "<address>:<bytes>" */
            char* colon = strchr(b->exp_string, ':');
            *colon = 0;
            ui_out_field_string(uiout, "addr", b->exp_string);
            ui_out_field_string(uiout, "what", colon+1);
            ui_out_text(uiout, "-byte range");
            *colon = ':';
          }
// end ARC
d3549 1
a3549 12
// begin ARC
              {
// end ARC
	        ui_out_field_core_addr (uiout, "addr", loc->address);
// begin ARC
                if (b->exp == NULL && b->loc->length > 0)
                  {
                    ui_out_field_int(uiout, "what",  b->loc->length);
                    ui_out_text(uiout, "-byte range ");
                  }
              }
// end ARC
d4767 1
a4767 8
// begin ARC
        if (b->exp)
// end ARC
          print_expression (b->exp, stb->stream);
// begin ARC
        else
          ui_out_text (uiout, b->exp_string);
// end ARC
d4776 1
a4776 8
// begin ARC
        if (b->exp)
// end ARC
          print_expression (b->exp, stb->stream);
// begin ARC
        else
          ui_out_text (uiout, b->exp_string);
// end ARC
d4785 1
a4785 8
// begin ARC
        if (b->exp)
// end ARC
          print_expression (b->exp, stb->stream);
// begin ARC
        else
          ui_out_text (uiout, b->exp_string);
// end ARC
a4852 4
// begin ARC
              if (b->exp == NULL && b->loc->length > 0)
                printf_filtered(" covering %u bytes", b->loc->length);
// end ARC
a5538 8
// begin ARC
void
watch_range_command (unsigned int address, unsigned int bytes, int accessflag, int from_tty)
{
    watch_range_command_1 (address, bytes, accessflag, from_tty);
}
// end ARC

a5544 8
// begin ARC
void
hbreak_command_wrapper (char *arg, int from_tty)
{
  hbreak_command (arg, from_tty);
}
// end ARC

a5839 75

// begin ARC
/* accessflag:  hw_write:   watch write, 
                hw_read:    watch read, 
                hw_access:  watch access (read or write)
                hw_execute: execute access */
static void
watch_range_command_1 (unsigned int address, unsigned int bytes, int accessflag, int from_tty)
{
  struct breakpoint *b;
  struct symtab_and_line sal;
  int i, other_type_used, target_resources_ok;
  enum bptype bp_type;
  enum target_hw_bp_type wp_type;
  char exp[50];

  (void) sprintf(exp, "0x%08X:%u", address, bytes);

  init_sal (&sal);  /* initialize to zeroes */

  if (accessflag == hw_read)
    {
      bp_type = bp_read_watchpoint;
      wp_type = hw_read;
    }
  else if (accessflag == hw_access)
    {
      bp_type = bp_access_watchpoint;
      wp_type = hw_access;
    }
  else if (accessflag == hw_write)
    {
      bp_type = bp_hardware_watchpoint;
      wp_type = hw_write;
    }
  else
    {
      bp_type = bp_hardware_breakpoint;
      wp_type = hw_execute;
    }

  i = hw_watchpoint_used_count (bp_type, &other_type_used);
  target_resources_ok = 
     TARGET_CAN_USE_HARDWARE_WATCHPOINT (bp_type, i, other_type_used);
  if (target_resources_ok == 0 && bp_type != bp_hardware_watchpoint)
      error (_("Target does not support this type of hardware watchpoint."));
  if (target_resources_ok < 0 && bp_type != bp_hardware_watchpoint)
   error (_("Target can only support one kind of HW watchpoint at a time."));


  /* Now set up the breakpoint.  */
  b = set_raw_breakpoint (sal, bp_type);
  set_breakpoint_count (breakpoint_count + 1);
  b->number = breakpoint_count;
  b->disposition = disp_donttouch;
  b->exp = NULL;
  b->exp_valid_block = NULL;
  b->exp_string = xstrdup(exp);
  b->val = NULL;
  //b->cond = NULL;   6.8 has removed this element?
  b->cond_string = 0;
  b->loc->address = (CORE_ADDR) address;
  b->loc->requested_address = b->loc->address;
  b->loc->length = bytes;

  b->loc->watchpoint_type = wp_type;

  memset (&b->watchpoint_frame, 0, sizeof (b->watchpoint_frame));

  mention (b);
}
// end ARC



d7914 2
a7915 12
    {
      /* richards/2008/10/27 ARC bug fix: if setting the (second)
       * b/p failed, we must unset the first
       *
       * gdb bug: 9649
       */
      if (single_step_breakpoints[0] != NULL)
         remove_single_step_breakpoints ();

      error (_("Could not insert single-step breakpoint at 0x%s"),
	       paddr_nz (next_pc));
    }
@


1.303.2.1
log
@        * breakpoint.c (print_one_breakpoint_location): Make sure to print
        the breakpoint address only once.
@
text
@d3546 1
a3546 1
	    else if (b->loc == NULL || loc->shlib_disabled)
@


1.303.2.2
log
@       * breakpoint.c (update_watchpoint): Always reparse
       condition.
@
text
@d970 1
a970 5
      /* We just regenerated the list of breakpoint locations.
         The new location does not have its condition field set to anything
         and therefore, we must always reparse the cond_string, independently
         of the value of the reparse flag.  */
      if (b->cond_string != NULL)
d973 5
@


1.302
log
@	* breakpoint.c: #include "hashtab.h".
	(ambiguous_names_p): New fn.
	(update_breakpoint_locations): When restoring bp enable status, don't
	compare function names if any functions have same name.
	* Makefile.in (breakpoint.o): Add hashtab.h dependency.

	* gdb.cp/mb-inline.exp: New.
	* gdb.cp/mb-inline.h: New.
	* gdb.cp/mb-inline1.cc: New.
	* gdb.cp/mb-inline2.cc: New.
@
text
@d3429 1
a3429 4
    ui_out_field_string (uiout, "enabled", 
			 loc->shlib_disabled 
			 ? (loc->enabled ? "y(p)" : "n(p)")
			 : (loc->enabled ? "y" : "n"));
d3431 3
a3433 12
    {
      int pending = (b->loc == NULL || b->loc->shlib_disabled);
      /* For header of multiple, there's no point showing pending
	 state -- it will be apparent from the locations.  */
      if (header_of_multiple)
	pending = 0;
      ui_out_field_fmt (uiout, "enabled", "%c%s", 
			bpenables[(int) b->enable_state],
			pending ? "(p)" : "");
      if (!pending)
	ui_out_spaces (uiout, 3);
    }
d3544 3
a3546 1
	    if (b->loc == NULL)
a3547 2
	    else if (header_of_multiple)
	      ui_out_field_string (uiout, "addr", "<MULTIPLE>");
d3772 1
a3772 1
  ui_out_table_header (uiout, 4, ui_left, "enabled", "Enb");	/* 4 */
@


1.301
log
@        * breakpoint.c (break_command_1): Return void.
        (break_command_really): Return void.  Rethrow
        exceptions instead of returning.
        (gdb_breakpoint): Remove the error_message parameter.
        Return void.  Rename to set_breakpoint.
        * gdb.h (gdb_breakpoint): Rename and move to...
	* breakpoint.h (set_breakpoint): ...here.
        * mi/mi-cmb-break.c (mi_cmd_break_insert): Restore
        event hooks even if exception is thrown.  Adjust to
        gdb_breakpoint interface changes.
@
text
@d24 1
d7085 37
d7184 7
d7196 19
a7214 7
	    for (; l; l = l->next)
	      if (l->function_name 
		  && strcmp (e->function_name, l->function_name) == 0)
		{
		  l->enabled = 0;
		  break;
		}
@


1.300
log
@	Properly rethrow exception.  This fixes errors
	about non-existent functions for -break-insert.
        * breakpoint.c (break_command_really): Use throw_exception
        for rethrowing.  If rethrowing, don't print the exception.
@
text
@d93 1
a93 1
static int break_command_1 (char *, int, int);
d5288 1
a5288 1
static int
d5326 1
a5326 2
      exception_print (gdb_stderr, e);
      return e.reason;
d5344 1
a5344 1
	    return e.reason;
d5358 1
a5358 2
	  exception_print (gdb_stderr, e);
	  return e.reason;
d5362 1
a5362 1
	return GDB_RC_FAIL;
a5457 2

  return GDB_RC_OK;
d5467 1
a5467 1
static int
d5473 5
a5477 5
  return break_command_really (arg, 
			       NULL, 0, 1 /* parse arg */,
			       tempflag, hardwareflag,
			       0 /* Ignore count */,
			       pending_break_support, from_tty);
d5481 2
a5482 2
enum gdb_rc
gdb_breakpoint (char *address, char *condition,
d5485 1
a5485 2
		int pending,
		char **error_message)
d5487 7
a5493 7
  return break_command_really (address, condition, thread,
			       0 /* condition and thread are valid.  */,
			       tempflag, hardwareflag,
			       ignore_count,
			       pending 
			       ? AUTO_BOOLEAN_TRUE : AUTO_BOOLEAN_FALSE,
			       0);
@


1.299
log
@	Use multiple locations for hardware watchpoints.
	This eliminates the need to traverse value chain, doing
	various checks, in three different places.

        * breakpoint.h (struct bp_location): New fields
        lengths and watchpoint_type.
        (struct breakpoint): Remove the val_chain field.
        * breakpoint.c (is_hardware_watchpoint): New.
        (free_valchain): Remove.
        (update_watchpoint): New.
        (insert_bp_location): For hardware watchpoint, just
        directly insert it.
        (insert_breakpoints): Call update_watchpoint_locations
        on all watchpoints.  If we have failed to insert
        any location of a hardware watchpoint, remove all inserted
        locations.
        (remove_breakpoint): For hardware watchpoints, directly
        remove location.
        (watchpoints_triggered): Iterate over locations.
        (bpstat_stop_status): Use only first location of
        a resource watchpoint.
        (delete_breakpoint): Don't call free_valchain.
        (print_one_breakpoint): Don't print all
        locations for watchpoints.
        (breakpoint_re_set_one): Use update_watchpoint for
        watchpoints.
@
text
@a5332 2
	  exception_print (gdb_stderr, e);

d5337 3
a5339 1
	    deprecated_throw_reason (RETURN_ERROR);
@


1.298
log
@        Don't reset watchpoint block on solib load.

        * breakpoint.c (insert_bp_location): For watchpoints,
        recompute condition.
        (breakpoint_re_set_one): Instead of recomputing value
        and condition for watchpoints, just reset value and
        let insert_breakpoints/insert_bp_location recompute it.
        Don't do anything about disabled watchpoint.
@
text
@d203 9
d820 7
a826 1
/* Helper routine: free the value chain for a breakpoint (watchpoint).  */
d828 7
d836 1
a836 1
free_valchain (struct bp_location *b)
d838 5
a842 2
  struct value *v;
  struct value *n;
d844 2
a845 3
  /* Free the saved value chain.  We will construct a new one
     the next time the watchpoint is inserted.  */
  for (v = b->owner->val_chain; v; v = n)
d847 4
a850 2
      n = value_next (v);
      value_free (v);
d852 141
a992 1
  b->owner->val_chain = NULL;
d995 1
d1186 4
a1189 130
      /* FIXME drow/2003-09-08: This code sets multiple hardware watchpoints
	 based on the expression.  Ideally this should happen at a higher level,
	 and there should be one bp_location for each computed address we
	 must watch.  As soon as a many-to-one mapping is available I'll
	 convert this.  */

      int within_current_scope;
      struct value *mark = value_mark ();
      struct value *v;
      struct frame_id saved_frame_id;

      /* Save the current frame's ID so we can restore it after
	 evaluating the watchpoint expression on its own frame.  */
      /* FIXME drow/2003-09-09: It would be nice if evaluate_expression
	 took a frame parameter, so that we didn't have to change the
	 selected frame.  */
      saved_frame_id = get_frame_id (get_selected_frame (NULL));

      /* Determine if the watchpoint is within scope.  */
      if (bpt->owner->exp_valid_block == NULL)
	within_current_scope = 1;
      else
	{
	  struct frame_info *fi;
	  fi = frame_find_by_id (bpt->owner->watchpoint_frame);
	  within_current_scope = (fi != NULL);
	  if (within_current_scope)
	    select_frame (fi);
	}

      if (within_current_scope)
	{
	  free_valchain (bpt);

	  /* Evaluate the expression and cut the chain of values
	     produced off from the value chain.

	     Make sure the value returned isn't lazy; we use
	     laziness to determine what memory GDB actually needed
	     in order to compute the value of the expression.  */
	  v = evaluate_expression (bpt->owner->exp);
	  value_contents (v);
	  value_release_to_mark (mark);

	  bpt->owner->val_chain = v;
	  bpt->inserted = 1;

	  /* Look at each value on the value chain.  */
	  for (; v; v = value_next (v))
	    {
	      /* If it's a memory location, and GDB actually needed
		 its contents to evaluate the expression, then we
		 must watch it.  */
	      if (VALUE_LVAL (v) == lval_memory
		  && ! value_lazy (v))
		{
		  struct type *vtype = check_typedef (value_type (v));

		  /* We only watch structs and arrays if user asked
		     for it explicitly, never if they just happen to
		     appear in the middle of some value chain.  */
		  if (v == bpt->owner->val_chain
		      || (TYPE_CODE (vtype) != TYPE_CODE_STRUCT
			  && TYPE_CODE (vtype) != TYPE_CODE_ARRAY))
		    {
		      CORE_ADDR addr;
		      int len, type;

		      addr = VALUE_ADDRESS (v) + value_offset (v);
		      len = TYPE_LENGTH (value_type (v));
		      type = hw_write;
		      if (bpt->owner->type == bp_read_watchpoint)
			type = hw_read;
		      else if (bpt->owner->type == bp_access_watchpoint)
			type = hw_access;

		      val = target_insert_watchpoint (addr, len, type);
		      if (val == -1)
			{
			  /* Don't exit the loop, try to insert
			     every value on the value chain.  That's
			     because we will be removing all the
			     watches below, and removing a
			     watchpoint we didn't insert could have
			     adverse effects.  */
			  bpt->inserted = 0;
			}
		      val = 0;
		    }
		}
	    }

	  if (bpt->owner->cond_string != NULL)
	    {
	      char *s = bpt->owner->cond_string;
	      if (bpt->cond)
		{
		  xfree (bpt->cond);
		  bpt->cond = NULL;
		}
	      bpt->cond = parse_exp_1 (&s, bpt->owner->exp_valid_block, 0);
	    }
	      
	  /* Failure to insert a watchpoint on any memory value in the
	     value chain brings us here.  */
	  if (!bpt->inserted)
	    {
	      remove_breakpoint (bpt, mark_uninserted);
	      *hw_breakpoint_error = 1;
	      fprintf_unfiltered (tmp_error_stream,
				  "Could not insert hardware watchpoint %d.\n", 
				  bpt->owner->number);
	      val = -1;
	    }               
	}
      else
	{
	  printf_filtered (_("\
Hardware watchpoint %d deleted because the program has left the block \n\
in which its expression is valid.\n"),
			   bpt->owner->number);
	  if (bpt->owner->related_breakpoint)
	    bpt->owner->related_breakpoint->disposition = disp_del_at_next_stop;
	  bpt->owner->disposition = disp_del_at_next_stop;
	}

      /* Restore the selected frame.  */
      select_frame (frame_find_by_id (saved_frame_id));

      return val;
d1222 1
d1237 4
a1251 13
      /* FIXME drow/2003-10-07: This code should be pushed elsewhere when
	 hardware watchpoints are split into multiple loc breakpoints.  */
      if ((b->loc_type == bp_loc_hardware_watchpoint
	   || b->owner->type == bp_watchpoint) && !b->owner->val)
	{
	  struct value *val;
	  val = evaluate_expression (b->owner->exp);
	  release_value (val);
	  if (value_lazy (val))
	    value_fetch_lazy (val);
	  b->owner->val = val;
	}

d1259 33
d1577 1
a1577 3
  else if (b->loc_type == bp_loc_hardware_watchpoint
	   && breakpoint_enabled (b->owner)
	   && !b->duplicate)
d1583 2
a1584 16
      /* Walk down the saved value chain.  */
      for (v = b->owner->val_chain; v; v = value_next (v))
	{
	  /* For each memory reference remove the watchpoint
	     at that address.  */
	  if (VALUE_LVAL (v) == lval_memory
	      && ! value_lazy (v))
	    {
	      struct type *vtype = check_typedef (value_type (v));

	      if (v == b->owner->val_chain
		  || (TYPE_CODE (vtype) != TYPE_CODE_STRUCT
		      && TYPE_CODE (vtype) != TYPE_CODE_ARRAY))
		{
		  CORE_ADDR addr;
		  int len, type;
a1585 15
		  addr = VALUE_ADDRESS (v) + value_offset (v);
		  len = TYPE_LENGTH (value_type (v));
		  type   = hw_write;
		  if (b->owner->type == bp_read_watchpoint)
		    type = hw_read;
		  else if (b->owner->type == bp_access_watchpoint)
		    type = hw_access;

		  val = target_remove_watchpoint (addr, len, type);
		  if (val == -1)
		    b->inserted = 1;
		  val = 0;
		}
	    }
	}
d2489 1
d2493 9
a2501 24
	for (v = b->val_chain; v; v = value_next (v))
	  {
	    if (VALUE_LVAL (v) == lval_memory && ! value_lazy (v))
	      {
		struct type *vtype = check_typedef (value_type (v));

		if (v == b->val_chain
		    || (TYPE_CODE (vtype) != TYPE_CODE_STRUCT
			&& TYPE_CODE (vtype) != TYPE_CODE_ARRAY))
		  {
		    CORE_ADDR vaddr;

		    vaddr = VALUE_ADDRESS (v) + value_offset (v);
		    /* Exact match not required.  Within range is
		       sufficient.  */
		    if (addr >= vaddr
			&& addr < vaddr + TYPE_LENGTH (value_type (v)))
		      {
			b->watchpoint_triggered = watch_triggered_yes;
			break;
		      }
		  }
	      }
	  }
d2740 9
d2942 4
d3666 4
a3669 1
	 situation.  */	 
d3671 1
d3673 1
a3673 1
	  && !ui_out_is_mi_like_p (uiout))
d6870 1
a6870 3

      free_valchain (loc);

d7304 1
a7304 33

      if (!breakpoint_enabled (b))
	break;

      if (b->exp_valid_block == NULL
	  || frame_find_by_id (b->watchpoint_frame) != NULL)
	{
	  if (b->exp)
	    {
	      xfree (b->exp);
	      b->exp = NULL;
	    }
	  s = b->exp_string;
	  b->exp = parse_exp_1 (&s, b->exp_valid_block, 0);

	  /* Since we reparsed expression, we need to update the
	     value.  I'm not aware of any way a single solib load or unload
	     can change a valid value into different valid value, but:
	     - even if the value is no longer valid, we have to record
	     this fact, so that when it becomes valid we reports this
	     as value change
	     - unloaded followed by load can change the value for sure.

   	     We set value to NULL, and insert_breakpoints will 
	     update the value.  */
	  if (b->val)
	    value_free (b->val);
	  b->val = NULL;

	  /* Loading of new shared library change the meaning of
	     watchpoint condition.  However, insert_bp_location will
	     recompute watchpoint condition anyway, nothing to do here.  */
	}
@


1.297
log
@	* breakpoint.c (break_command_really): New parameter
	ignore_count.
	(break_command_1): Pass 0 as
	ignore_count to break_command_really.
	(gdb_breakpoint): Pass ignore_count to
	break_command_really.
@
text
@d1110 12
d7243 28
a7270 31
      innermost_block = NULL;
      /* The issue arises of what context to evaluate this in.  The
         same one as when it was set, but what does that mean when
         symbols have been re-read?  We could save the filename and
         functionname, but if the context is more local than that, the
         best we could do would be something like how many levels deep
         and which index at that particular level, but that's going to
         be less stable than filenames or function names.  */

      /* So for now, just use a global context.  */
      if (b->exp)
	{
	  xfree (b->exp);
	  /* Avoid re-freeing b->exp if an error during the call to
             parse_expression.  */
	  b->exp = NULL;
	}
      b->exp = parse_expression (b->exp_string);
      b->exp_valid_block = innermost_block;
      mark = value_mark ();
      if (b->val)
	{
	  value_free (b->val);
	  /* Avoid re-freeing b->val if an error during the call to
             evaluate_expression.  */
	  b->val = NULL;
	}
      b->val = evaluate_expression (b->exp);
      release_value (b->val);
      if (value_lazy (b->val) && breakpoint_enabled (b))
	value_fetch_lazy (b->val);
d7272 2
a7273 1
      if (b->cond_string != NULL)
d7275 1
a7275 2
	  s = b->cond_string;
	  if (b->loc->cond)
d7277 2
a7278 4
	      xfree (b->loc->cond);
	      /* Avoid re-freeing b->exp if an error during the call
		 to parse_exp_1.  */
	      b->loc->cond = NULL;
d7280 20
a7299 1
	  b->loc->cond = parse_exp_1 (&s, (struct block *) 0, 0);
a7300 3
      if (breakpoint_enabled (b))
	mention (b);
      value_free_to_mark (mark);
@


1.296
log
@	* exec.c: #include "arch-utils.h"
	 (print_section_info): Use gdbarch_from_bfd to get at the
	current architecture. Replace current_gdbarch. Fix indention.
	Replace deprecated_print_address_numeric by paddress.
	* Makefile.in (exec.o) Add dependency to arch-utils.h.

	* valprint.c (val_print_string): Replace
	deprecated_print_address_numeric.
	* tracepoint.c (trace_mention, scope_info): Likewise.
	* symmisc.c (dump_msymbols, dump_psymtab, dump_symtab_1, print_symbol)
	(print_symbol, print_partial_symbols, maintenance_info_psymtabs)
	(maintenance_check_symtabs): Likewise.
	* symfile.c (list_overlays_command): Likewise.
	* stack.c (frame_info, print_block_frame_labels): Likewise.
	* printcmd.c (print_address, print_address_demangle)
	(address_info): Likewise.
	* corefile.c (memory_error): Likewise.
	* infcmd.c (jump_command): Likewise.
	* breakpoint.c (insert_bp_location, describe_other_breakpoints)
	(mention, delete_breakpoint): Likewise.
	* c-valprint.c (print_function_pointer_address, c_val_print): Likewise.
	* dwarf2read.c (dump_die): Likewise.
	* ada-valprint.c (ada_val_print_1): Likewise.
	* f-valprint.c (f_val_print): Likewise.
	* linux-fork.c (info_forks_command): Likewise.
	* m32r-com.c (m32r_load_section, m32r_load)
	(m32r_upload_command): Likewise.

	* ui-out.c (ui_out_field_core_addr): Remove unnecessary comment.
@
text
@d5240 5
a5244 4
                      int parse_condition_and_thread,
                      int tempflag, int hardwareflag, 
                      enum auto_boolean pending_break_support,
                      int from_tty)
a5257 1
  int ignore_count = 0;
d5430 1
d5445 1
@


1.295
log
@	Updated copyright notices for most files.
@
text
@d1001 1
a1001 1
		  deprecated_print_address_numeric (bpt->address, 1, tmp_error_stream);
d3854 1
a3854 1
      deprecated_print_address_numeric (pc, 1, gdb_stdout);
d4813 1
a4813 1
	      deprecated_print_address_numeric (b->loc->address, 1, gdb_stdout);
d6901 2
a6902 1
			  deprecated_print_address_numeric (loc2->address, 1, tmp_error_stream);
@


1.294
log
@      * breakpoint.c: (watch_command_1): Parse additional optional
      "thread" parameter to the watchpoint command and set the
      "thread" member of the breakpoint struct.
      * doc/gdb.texinfo: Add new parameter's description.
      * testsuite/gdb.base/watch_thread_num.c: New testcase source file.
      * testsuite/gdb.base/watch_thread_num.exp: New testcase expect file.
@
text
@d4 2
a5 2
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
   Free Software Foundation, Inc.
@


1.293
log
@	* breakpoint.c (bpstat_stop_status): Check an additional
	condition before evaluating an expression value.
@
text
@d5609 1
a5609 1
  char *tok, *end_tok;
d5617 1
d5621 62
a5682 1
  /* Parse arguments.  */
d5775 1
@


1.292
log
@	* breakpoint.c (bpstat_have_active_hw_watchpoints):
	Remove
	(bpstat_stop_status): Remove unused variable
	real_breakpoint.
	* breakpoint.h (bpstat_have_active_hw_watchpoints):
	Remove prototype.
@
text
@d2826 1
a2826 1
	if (bl->cond)
@


1.291
log
@	Add support for pending breakpoints in MI.
	* gdb.h (gdb_breakpoint): Add parameter pending.
	* breakpoint.c (gdb_breakpoint): Add parameter pending.
	* mi/mi-cmd-break.c (mi_break_insert): Change
	comment to refer to manual.  Add support for
	the -f flag, for pending breakpoint.
@
text
@a2612 2
  /* True if we've hit a breakpoint (as opposed to a watchpoint).  */
  int real_breakpoint = 0;
a2809 2

	real_breakpoint = 1;
a3172 12
/* Nonzero if there are enabled hardware watchpoints. */
int
bpstat_have_active_hw_watchpoints (void)
{
  const struct bp_location *bpt;
  ALL_BP_LOCATIONS (bpt)
    if (breakpoint_enabled (bpt->owner)
	&& bpt->inserted
	&& bpt->loc_type == bp_loc_hardware_watchpoint)
      return 1;
  return 0;
}
@


1.290
log
@	* breakpoint.c (break_command_really): New, copied
	from break_command_1. New parameters COND_STRING, THREAD
	PARSE_CONDITITION_AND_THREAD and PENDING_BREAK_SUPPORT.
	The previous FLAG parameter split into TEMPFLAG and
	HARDWAREFLAG.
	When PARSE_CONDITION_AND_THREAD is not set, duplicate
	the passed condition string.
	(struct captured_breakpoint_args): Remove
	(do_captured_breakpoint): Remove.
	(break_command_1): Relay to break_command_really.
	(gdb_breakpoint): Relay to break_command_really.
@
text
@d5454 1
d5460 2
a5461 1
			       AUTO_BOOLEAN_FALSE /* no pending. */,
@


1.289
log
@Remove unused support for target-based exception catching.
* target.h (struct target_ops): Delete
to_enable_exception_callback and to_get_current_exception_event
members.
(target_enable_exception_callback)
(target_get_current_exception_event): Delete macros.
* target.c (update_current_target): Remove code to inherit and
default those members.
(debug_to_enable_exception_callback)
(debug_to_get_current_exception_event): Delete functions.
(setup_target_debug): Don't install those methods.
* inf-child.c (inf_child_enable_exception_callback)
(inf_child_get_current_exception_event): Delete dummy functions.
(inf_child_target): Don't install them in the target vector.
* breakpoint.h (enum bptype): Delete bp_catch_catch,
bp_catch_throw.
* breakpoint.c (cover_target_enable_exception_callback)
(ep_is_exception_catchpoint, create_exception_catchpoint): Delete
functions.
(insert_bp_location, update_breakpoints_after_exec)
(remove_breakpoint, ep_is_catchpoint, print_it_typical)
(bpstat_stop_status, bpstat_what)
(bpstat_get_triggered_catchpoints, print_one_breakpoint_location)
(user_settable_breakpoint, allocate_bp_location)
(disable_watchpoints_before_interactive_call_start)
(enable_watchpoints_after_interactive_call_stop, mention)
(delete_breakpoint, breakpoint_re_set_one, disable_command)
(enable_command): Remove exception catchpoint cases.
(catch_exception_command_1): Don't try target-based exception
handling.
* stack.c (catch_info): Call print_frame_label_vars
unconditionally.
@
text
@d5244 9
a5252 3
/* Set a breakpoint according to ARG (function, linenum or *address)
   flag: first bit  : 0 non-temporary, 1 temporary.
   second bit : 0 normal breakpoint, 1 hardware breakpoint.  */
d5255 5
a5259 1
break_command_1 (char *arg, int flag, int from_tty)
a5261 1
  int tempflag, hardwareflag;
a5263 1
  char *cond_string = NULL;
a5272 1
  int thread = -1;
a5275 3
  hardwareflag = flag & BP_HARDWAREFLAG;
  tempflag = flag & BP_TEMPFLAG;

d5370 21
a5390 7
      /* Here we only parse 'arg' to separate condition
	 from thread number, so parsing in context of first
	 sal is OK.  When setting the breakpoint we'll 
	 re-parse it in context of each sal.  */
      find_condition_and_thread (arg, sals.sals[0].pc, &cond_string, &thread);
      if (cond_string)
	make_cleanup (xfree, cond_string);
d5409 1
a5409 1
      b->thread = thread;
d5411 1
a5411 1
      b->cond_string = cond_string;
d5430 7
a5436 13
/* Set a breakpoint of TYPE/DISPOSITION according to ARG (function,
   linenum or *address) with COND and IGNORE_COUNT. */

struct captured_breakpoint_args
  {
    char *address;
    char *condition;
    int hardwareflag;
    int tempflag;
    int thread;
    int ignore_count;
  };

d5438 1
a5438 1
do_captured_breakpoint (struct ui_out *uiout, void *data)
d5440 2
a5441 8
  struct captured_breakpoint_args *args = data;
  struct symtabs_and_lines sals;
  struct expression **cond;
  struct cleanup *old_chain;
  struct cleanup *breakpoint_chain = NULL;
  int i;
  char **addr_string;
  char *cond_string = 0;
d5443 5
a5447 32
  char *address_end;

  /* Parse the source and lines spec.  Delay check that the expression
     didn't contain trailing garbage until after cleanups are in
     place. */
  sals.sals = NULL;
  sals.nelts = 0;
  address_end = args->address;
  addr_string = NULL;
  parse_breakpoint_sals (&address_end, &sals, &addr_string, 0);

  if (!sals.nelts)
    return GDB_RC_NONE;

  /* Create a chain of things at always need to be cleaned up. */
  old_chain = make_cleanup (null_cleanup, 0);

  /* Always have a addr_string array, even if it is empty. */
  make_cleanup (xfree, addr_string);

  /* Make sure that all storage allocated to SALS gets freed.  */
  make_cleanup (xfree, sals.sals);

  /* Allocate space for all the cond expressions. */
  cond = xcalloc (sals.nelts, sizeof (struct expression *));
  make_cleanup (xfree, cond);

  /* ----------------------------- SNIP -----------------------------
     Anything added to the cleanup chain beyond this point is assumed
     to be part of a breakpoint.  If the breakpoint create goes
     through then that memory is not cleaned up. */
  breakpoint_chain = make_cleanup (null_cleanup, 0);
a5448 36
  /* Mark the contents of the addr_string for cleanup.  These go on
     the breakpoint_chain and only occure if the breakpoint create
     fails. */
  for (i = 0; i < sals.nelts; i++)
    {
      if (addr_string[i] != NULL)
	make_cleanup (xfree, addr_string[i]);
    }

  /* Wait until now before checking for garbage at the end of the
     address. That way cleanups can take care of freeing any
     memory. */
  if (*address_end != '\0')
    error (_("Garbage %s following breakpoint address"), address_end);

  /* Resolve all line numbers to PC's.  */
  breakpoint_sals_to_pc (&sals, args->address);

  if (args->condition != NULL)
    {
      cond_string = xstrdup (args->condition);
      make_cleanup (xfree, cond_string);
    }

  create_breakpoints (sals, addr_string, args->condition,
		      args->hardwareflag ? bp_hardware_breakpoint : bp_breakpoint,
		      args->tempflag ? disp_del : disp_donttouch,
		      args->thread, args->ignore_count, 0/*from-tty*/);

  /* That's it. Discard the cleanups for data inserted into the
     breakpoint. */
  discard_cleanups (breakpoint_chain);
  /* But cleanup everything else. */
  do_cleanups (old_chain);
  return GDB_RC_OK;
}
d5456 5
a5460 12
  struct captured_breakpoint_args args;
  args.address = address;
  args.condition = condition;
  args.hardwareflag = hardwareflag;
  args.tempflag = tempflag;
  args.thread = thread;
  args.ignore_count = ignore_count;
  if (catch_exceptions_with_msg (uiout, do_captured_breakpoint, &args,
				 error_message, RETURN_MASK_ALL) < 0)
    return GDB_RC_FAIL;
  else
    return GDB_RC_OK;
@


1.288
log
@Support lexical blocks and function bodies that occupy
non-contiguous address ranges.
* addrmap.c, addrmap.h: New files.
* block.h (struct addrmap): New forward declaration.
(struct blockvector): New member, 'map'.
(BLOCKVECTOR_MAP): New accessor macro.
* block.c: #include "addrmap.h"
(blockvector_for_pc_sect): If the blockvector we've found has
an address map, use it instead of searching the blocks.
* buildsym.c: #include "addrmap.h"
(pending_addrmap_obstack, pending_addrmap_interesting): New static
variables.
(really_free_pendings): If we have a pending addrmap, free it too.
(record_block_range): New function.
(make_blockvector): If we have an interesting pending addrmap,
record it in the new blockvector.
(start_symtab, buildsym_init): Assert that there is no pending
addrmap now; we should have cleaned up any addrmaps we'd built
previously.
(end_symtab): If there is a pending addrmap left over that didn't
get included in the blockvector, free it.
* buildsym.h (struct addrmap): New forward declaration.
(record_block_range): New prototype.
* objfiles.c: #include "addrmap.h".
(objfile_relocate): Relocate the blockvector's address map, if
present.
* dwarf2read.c (dwarf2_record_block_ranges): New function.
(read_func_scope, read_lexical_block_scope): Call it.
* Makefile.in (SFILES): Add addrmap.c.
(addrmap_h): New header dependency variable.
(COMMON_OBS): Add addrmap.o.
(addrmap.o): New rule.l
(block.o, objfiles.o, buildsym.o): Depend on $(addrmap_h).

* block.c (blockvector_for_pc, blockvector_for_pc_sect): Return a
pointer to the block, not its index in the blockvector.
(block_for_pc_sect): Use the returned block, instead of looking it
up ourselves.
* block.h (blockvector_for_pc, blockvector_for_pc_sect): Update
declarations.
* breakpoint.c (resolve_sal_pc): Use returned block, instead of
looking it up ourselves.
* stack.c (print_frame_label_vars): Disable function, which
depends on the block's index.

* buildsym.c (finish_block): Return the block we've built.
* buildsym.h (finish_block): Update prototype.

* defs.h (CORE_ADDR_MAX): New constant.
@
text
@a147 2
static int cover_target_enable_exception_callback (void *);

a1138 55
  else if (ep_is_exception_catchpoint (bpt->owner))
    {
      /* FIXME drow/2003-09-09: This code sets both a catchpoint and a
	 breakpoint.  Once again, it would be better if this was represented
	 as two bp_locations.  */

      /* If we get here, we must have a callback mechanism for exception
	 events -- with g++ style embedded label support, we insert
	 ordinary breakpoints and not catchpoints. */
      val = target_insert_breakpoint (&bpt->target_info);
      if (val)
	{
	  /* Couldn't set breakpoint for some reason */
	  fprintf_unfiltered (tmp_error_stream, 
			      "Cannot insert catchpoint %d; disabling it.\n",
			      bpt->owner->number);
	  fprintf_filtered (tmp_error_stream, 
			    "Error accessing memory address ");
	  deprecated_print_address_numeric (bpt->address, 1, tmp_error_stream);
	  fprintf_filtered (tmp_error_stream, ": %s.\n",
			    safe_strerror (val));
	  bpt->owner->enable_state = bp_disabled;
	}
      else
	{
	  /* Bp set, now make sure callbacks are enabled */
	  /* Format possible error msg */
	  char *message = xstrprintf ("Error inserting catchpoint %d:\n",
				      bpt->owner->number);
	  struct cleanup *cleanups = make_cleanup (xfree, message);
	  int val;
	  args_for_catchpoint_enable args;
	  args.kind = bpt->owner->type == bp_catch_catch ? 
	    EX_EVENT_CATCH : EX_EVENT_THROW;
	  args.enable_p = 1;
	  val = catch_errors (cover_target_enable_exception_callback,
			      &args, message, RETURN_MASK_ALL);
	  do_cleanups (cleanups);
	  if (val != 0 && val != -1)
	    bpt->inserted = 1;

	  /* Check if something went wrong; val == 0 can be ignored */
	  if (val == -1)
	    {
	      /* something went wrong */
	      fprintf_unfiltered (tmp_error_stream, 
				  "Cannot insert catchpoint %d; disabling it.\n",
				  bpt->owner->number);
	      bpt->owner->enable_state = bp_disabled;
	    }
	}

      return val;
    }

a1334 7
    /* Ditto the exception-handling catchpoints. */
    if ((b->type == bp_catch_catch) || (b->type == bp_catch_throw))
      {
	delete_breakpoint (b);
	continue;
      }

a1569 10
  else if ((b->owner->type == bp_catch_catch ||
	    b->owner->type == bp_catch_throw)
	   && breakpoint_enabled (b->owner)
	   && !b->duplicate)
    {
      val = target_remove_breakpoint (&b->target_info);
      if (val)
	return val;
      b->inserted = (is == mark_inserted);
    }
d1809 1
a1809 3
    || (ep->type == bp_catch_exec)
    || (ep->type == bp_catch_catch)
    || (ep->type == bp_catch_throw);
a1821 8
int
ep_is_exception_catchpoint (struct breakpoint *ep)
{
  return
    (ep->type == bp_catch_catch)
    || (ep->type == bp_catch_throw);
}

a2173 62
    case bp_catch_catch:
      if (current_exception_event && 
	  (CURRENT_EXCEPTION_KIND == EX_EVENT_CATCH))
	{
	  annotate_catchpoint (b->number);
	  printf_filtered (_("\nCatchpoint %d (exception caught), "), 
			   b->number);
	  if (CURRENT_EXCEPTION_THROW_PC && CURRENT_EXCEPTION_THROW_LINE)
	    printf_filtered (_("throw location %s:%d, "),
			     CURRENT_EXCEPTION_THROW_FILE,
			     CURRENT_EXCEPTION_THROW_LINE);
	  else
	    printf_filtered (_("throw location unknown, "));

	  if (CURRENT_EXCEPTION_CATCH_PC && CURRENT_EXCEPTION_CATCH_LINE)
	    printf_filtered (_("catch location %s:%d\n"),
			     CURRENT_EXCEPTION_CATCH_FILE,
			     CURRENT_EXCEPTION_CATCH_LINE);
	  else
	    printf_filtered (_("catch location unknown\n"));

	  /* don't bother to print location frame info */
	  return PRINT_SRC_ONLY;
	}
      else
	{
	  /* really throw, some other bpstat will handle it */
	  return PRINT_UNKNOWN;	
	}
      break;

    case bp_catch_throw:
      if (current_exception_event && 
	  (CURRENT_EXCEPTION_KIND == EX_EVENT_THROW))
	{
	  annotate_catchpoint (b->number);
	  printf_filtered (_("\nCatchpoint %d (exception thrown), "),
			   b->number);
	  if (CURRENT_EXCEPTION_THROW_PC && CURRENT_EXCEPTION_THROW_LINE)
	    printf_filtered (_("throw location %s:%d, "),
			     CURRENT_EXCEPTION_THROW_FILE,
			     CURRENT_EXCEPTION_THROW_LINE);
	  else
	    printf_filtered (_("throw location unknown, "));

	  if (CURRENT_EXCEPTION_CATCH_PC && CURRENT_EXCEPTION_CATCH_LINE)
	    printf_filtered (_("catch location %s:%d\n"),
			     CURRENT_EXCEPTION_CATCH_FILE,
			     CURRENT_EXCEPTION_CATCH_LINE);
	  else
	    printf_filtered (_("catch location unknown\n"));

	  /* don't bother to print location frame info */
	  return PRINT_SRC_ONLY; 
	}
      else
	{
	  /* really catch, some other bpstat will handle it */
	  return PRINT_UNKNOWN;	
	}
      break;

d2635 1
a2635 3
	&& b->type != bp_catch_exec
	&& b->type != bp_catch_catch
	&& b->type != bp_catch_throw)	/* a non-watchpoint bp */
a2708 4
    if (ep_is_exception_catchpoint (b) &&
	!(current_exception_event = target_get_current_exception_event ()))
      continue;

a3149 12
	case bp_catch_catch:
	  if (!bs->stop || CURRENT_EXCEPTION_KIND != EX_EVENT_CATCH)
	    bs_class = bp_nostop;
	  else if (bs->stop)
	    bs_class = bs->print ? bp_noisy : bp_silent;
	  break;
	case bp_catch_throw:
	  if (!bs->stop || CURRENT_EXCEPTION_KIND != EX_EVENT_THROW)
	    bs_class = bp_nostop;
	  else if (bs->stop)
	    bs_class = bs->print ? bp_noisy : bp_silent;
	  break;
d3212 1
a3212 3
	  (ep->type != bp_catch_unload) &&
	  (ep->type != bp_catch_catch) &&
	  (ep->type != bp_catch_throw))		
d3331 1
a3331 3
    {bp_catch_exec, "catch exec"},
    {bp_catch_catch, "catch catch"},
    {bp_catch_throw, "catch throw"}
a3509 22
      case bp_catch_catch:
	/* Field 4, the address, is omitted (which makes the columns
	   not line up too nicely with the headers, but the effect
	   is relatively readable).  */
	if (addressprint)
	  ui_out_field_skip (uiout, "addr");
	annotate_field (5);
	ui_out_field_string (uiout, "what", "exception catch");
	ui_out_spaces (uiout, 1);
	break;

      case bp_catch_throw:
	/* Field 4, the address, is omitted (which makes the columns
	   not line up too nicely with the headers, but the effect
	   is relatively readable).  */
	if (addressprint)
	  ui_out_field_skip (uiout, "addr");
	annotate_field (5);
	ui_out_field_string (uiout, "what", "exception throw");
	ui_out_spaces (uiout, 1);
	break;

a3697 2
	  || b->type == bp_catch_catch
	  || b->type == bp_catch_throw
a4104 2
    case bp_catch_catch:
    case bp_catch_throw:
d4648 1
a4648 2
	 || (b->type == bp_access_watchpoint)
	 || ep_is_exception_catchpoint (b))
d4667 1
a4667 2
	 || (b->type == bp_access_watchpoint)
	 || ep_is_exception_catchpoint (b))
a4801 6
      case bp_catch_catch:
      case bp_catch_throw:
	printf_filtered (_("Catchpoint %d (%s)"),
			 b->number,
			 (b->type == bp_catch_catch) ? "catch" : "throw");
	break;
a6294 41
/* Commands to deal with catching exceptions.  */

/* Set a breakpoint at the specified callback routine for an
   exception event callback */

static void
create_exception_catchpoint (int tempflag, char *cond_string,
			     enum exception_event_kind ex_event,
			     struct symtab_and_line *sal)
{
  struct breakpoint *b;
  int thread = -1;		/* All threads. */
  enum bptype bptype;

  if (!sal)			/* no exception support? */
    return;

  switch (ex_event)
    {
    case EX_EVENT_THROW:
      bptype = bp_catch_throw;
      break;
    case EX_EVENT_CATCH:
      bptype = bp_catch_catch;
      break;
    default:			/* error condition */
      error (_("Internal error -- invalid catchpoint kind"));
    }

  b = set_raw_breakpoint (*sal, bptype);
  set_breakpoint_count (breakpoint_count + 1);
  b->number = breakpoint_count;
  b->cond_string = (cond_string == NULL) ? 
    NULL : savestring (cond_string, strlen (cond_string));
  b->thread = thread;
  b->addr_string = NULL;
  b->enable_state = bp_enabled;
  b->disposition = tempflag ? disp_del : disp_donttouch;
  mention (b);
}

a6400 13
  /* See if we can find a callback routine */
  sal = target_enable_exception_callback (ex_event, 1);

  if (sal)
    {
      /* We have callbacks from the runtime system for exceptions.
         Set a breakpoint on the sal found, if no errors */
      if (sal != (struct symtab_and_line *) -1)
	create_exception_catchpoint (tempflag, cond_string, ex_event, sal);
      else
	return;		/* something went wrong with setting up callbacks */
    }

a6482 17
/* Cover routine to allow wrapping target_enable_exception_catchpoints
   inside a catch_errors */

static int
cover_target_enable_exception_callback (void *arg)
{
  args_for_catchpoint_enable *args = arg;
  struct symtab_and_line *sal;
  sal = target_enable_exception_callback (args->kind, args->enable_p);
  if (sal == NULL)
    return 0;
  else if (sal == (struct symtab_and_line *) -1)
    return -1;
  else
    return 1;			/*is valid */
}

a6845 22
  /* If we have callback-style exception catchpoints, don't go through
     the adjustments to the C++ runtime library etc. if the inferior
     isn't actually running.  target_enable_exception_callback for a
     null target ops vector gives an undesirable error message, so we
     check here and avoid it. Since currently (1997-09-17) only HP-UX aCC's
     exceptions are supported in this way, it's OK for now.  FIXME */
  if (ep_is_exception_catchpoint (bpt) && target_has_execution)
    {
      /* Format possible error msg */
      char *message = xstrprintf ("Error in deleting catchpoint %d:\n",
				  bpt->number);
      struct cleanup *cleanups = make_cleanup (xfree, message);
      args_for_catchpoint_enable args;
      args.kind = bpt->type == bp_catch_catch ? 
	EX_EVENT_CATCH : EX_EVENT_THROW;
      args.enable_p = 0;
      catch_errors (cover_target_enable_exception_callback, &args,
		    message, RETURN_MASK_ALL);
      do_cleanups (cleanups);
    }


a7290 3
    case bp_catch_catch:
    case bp_catch_throw:
      break;
a7580 2
      case bp_catch_catch:
      case bp_catch_throw:
a7716 2
      case bp_catch_catch:
      case bp_catch_throw:
@


1.287
log
@	Make insert_breakpoints return void.
	* breakpoint.h (insert_breakpoints): Change
	return type to void.
	* breakpoint.c (insert_breakpoints): Change
	return type to void.  Rename local return_val
	variable to error.
	* infrun.c (keep_going): Instead of checking
	return value from insert_breakpoints, catch exception.
@
text
@a5749 1
      int index;
d5751 1
a5751 1
      bv = blockvector_for_pc_sect (sal->pc, 0, &index, sal->symtab);
a5753 1
	  b = BLOCKVECTOR_BLOCK (bv, index);
@


1.286
log
@	Stop infrun from tracking breakpoint insertion status.

	The checks of breakpoints_inserted before calling
	remove_breakpoints are removed, as remove_breakpoint
	won't touch uninserted breakpoints. In a number of places,
	we're interested if a breakpoint is inserted at particular
	PC, and we now use breakpoint_inserted_here_p.  In a few
	places, insert_breakpoints can be called unconditionally,
	since it won't try to insert already inserted breakpoint.

	* breakpoint.h (regular_breakpoint_inserted_here_p): New
	declaration.
	* breakpoint.c (regular_breakpoint_inserted_here_p): New.
	(breakpoint_inserted_here_p): Use
	regular_breakpoint_inserted_here_p.
	* infrun.c (breakpoints_inserted): Remove.
	(resume): Don't check for breakpoints_inserted before
	remove_hw_watchpoints. Use breakpoint_inserted_here_p.
	(proceed, init_wait_for_inferior): Don't set breakpoints_inserted.
	(handle_inferior_event): Don't use breakpoints_inserted.
	Use breakpoints_meant_to_be_inserted and
	breakpoints_inserted_here_p.
	(insert_step_resume_breakpoint_at_sal, keep_going): Use
	breakpoints_meant_to_be_inserted. Don't set breakpoints_inserted.
	(normal_stop): Don't check for breakpoints_inserted.  Don't
	set breakpoints_inserted.
	(keep_going): Don't check for breakpoints_inserted.
	(insert_step_resume_breakpoint_at_sal): Don't insert
	breakpoints
@
text
@d1223 1
a1223 1
int
d1227 1
a1227 1
  int return_val = 0;	/* return success code. */
d1268 1
a1268 1
	return_val = val;
d1271 1
a1271 1
  if (return_val)
a1288 1
  return return_val;
@


1.285
log
@* breakpoint.c (watch_command_1): When the watchpoint isn't local
to any frame, initialize watchpoint_frame using null_frame_id, not
a memset.
@
text
@d1760 4
a1763 3
/* breakpoint_inserted_here_p (PC) is just like breakpoint_here_p(),
   but it only returns true if there is actually a breakpoint inserted
   at PC.  */
d1766 1
a1766 1
breakpoint_inserted_here_p (CORE_ADDR pc)
d1787 11
a1798 1
  /* Also check for software single-step breakpoints.  */
@


1.284
log
@	* breakpoint.c (insert_breakpoints)
	(insert_bp_location): Remove stale comments.
@
text
@d5999 1
a5999 1
    memset (&b->watchpoint_frame, 0, sizeof (b->watchpoint_frame));
@


1.283
log
@	Remove unused breakpoint fields.
	* breakpoint.h (struct breakpoint): Remove
	from_tty and flag fields.
	* breakpoint.c (break_command_1): Don't set
	from_tty and flag field set of breakpoint.
	(create_ada_exception_breakpoint): Don't set
	the from_tty field.
@
text
@a844 2
  /* Permanent breakpoints cannot be inserted or removed.  Disabled
     breakpoints should not be inserted.  */
a1241 2
      /* Permanent breakpoints cannot be inserted or removed.  Disabled
	 breakpoints should not be inserted.  */
@


1.282
log
@	* breakpoint.c (disable_breakpoints_in_unloaded_shlib):
	Make static.
@
text
@a5591 2
      b->from_tty = from_tty;
      b->flag = flag;
a6696 1
  b->from_tty = from_tty;
@


1.281
log
@	Apply const qualifier to some users of bp_location.
	* breakpoint.h (struct bpstats): Make
	the breakpoint_at field point at const bp_location.
	* breakpoint.c (bpstat_alloc): Accept const
	bp_location.
	(breakpoint_here_p, breakpoint_inserted_here_p)
	(software_breakpoint_inserted_here_p)
	(breakpoint_thread_match, bpstat_stop_status)
	(read_memory_nobpt, bpstat_have_active_hw_watchpoints): Use
	const bp_location for iteration.
	(print_it_typical, print_bp_stop_message): Use
	const bp_location variable.
@
text
@d4664 1
a4664 1
void
@


1.280
log
@	Make mark_breakpoints_out static.
	* breakpoint.h (mark_breakpoints_out): Remove
	declaration.
	* breakpoint.c (mark_breakpoints_out): Make static.
@
text
@d112 1
a112 1
static bpstat bpstat_alloc (struct bp_location *, bpstat);
d708 1
a708 1
  struct bp_location *b;
d1736 1
a1736 1
  struct bp_location *bpt;
d1771 1
a1771 1
  struct bp_location *bpt;
d1804 1
a1804 1
  struct bp_location *bpt;
d1837 1
a1837 1
  struct bp_location *bpt;
d2162 1
a2162 1
  struct bp_location *bl;
d2443 1
a2443 1
	struct bp_location *bl = bs->breakpoint_at;
d2523 1
a2523 1
bpstat_alloc (struct bp_location *bl, bpstat cbs /* Current "bs" value */ )
d2752 1
a2752 1
  struct bp_location *bl;
d3339 1
a3339 1
  struct bp_location *bpt;
@


1.279
log
@	Prevent clear_command from directly modifying breakpoint list.
	* Makefile.in (breakpoint_h): Update dependency.
	* breakpoint.c (clear_command): Do not remove
	breakpoints from breakpoint_chain.  Collect breakpoints
	to delete in a vector.
	* breakpoint.h (breakpoint_p): New typedef for pointer to
	breakpoint.  Register vector of breakpoint_p.
@
text
@d203 2
d1655 1
a1655 1
void
@


1.278
log
@	* breakpoint.c (break_command_1): Remove
	pending_bp parameter.
	(create_breakpoint): Likewise.
	(create_breakpoints): Likewise. Adjust call to
	create_breakpoint.
	(break_command_1): Likewise. Adjust call to
	create_breakpoints.
	(do_captured_breakpoint): Adjust call to
	create_breakpoints.
	(break_command, tbreak_command, hbreak_command)
	(stopin_command, stopat_command): Adjust call
	to break_command_1.
@
text
@d6881 3
a6883 1
  struct breakpoint *b, *tmp, *prev, *found;
a6949 1
      prev = NULL;
d6951 3
a6953 3
      /* Find all matching breakpoints, remove them from the
	 breakpoint chain, and add them to the 'found' chain.  */
      ALL_BREAKPOINTS_SAFE (b, tmp)
d6984 1
a6984 20
	    {
	      /* Remove it from breakpoint_chain...  */
	      if (b == breakpoint_chain)
		{
		  /* b is at the head of the list */
		  breakpoint_chain = b->next;
		}
	      else
		{
		  prev->next = b->next;
		}
	      /* And add it to 'found' chain.  */
	      b->next = found;
	      found = b;
	    }
	  else
	    {
	      /* Keep b, and keep a pointer to it.  */
	      prev = b;
	    }
d6988 1
a6988 1
  if (found == 0)
d6996 1
a6996 1
  if (found->next)
d7000 1
a7000 1
      if (!found->next)
d7006 2
a7007 1
  while (found)
d7010 2
a7011 4
	printf_unfiltered ("%d ", found->number);
      tmp = found->next;
      delete_breakpoint (found);
      found = tmp;
@


1.277
log
@        * breakpoint.c (set_raw_breakpoint_without_location): Make static.
@
text
@d93 1
a93 1
static int break_command_1 (char *, int, int, struct breakpoint *);
d5068 1
a5068 4
   as condition expression.

   The paramter PENDING_BP is same as for the
   create_breakpoints function.  */
d5074 1
a5074 2
		   int thread, int ignore_count, int from_tty,
		   struct breakpoint *pending_bp)
d5123 1
a5123 6
	    {
	      if (pending_bp)
		error (_("Junk at end of pending breakpoint condition expression"));
	      else
		error (_("Garbage %s follows condition"), arg);
	    }
a5267 5
   The parameter PENDING_BP points to a pending breakpoint that is
   the basis of the breakpoints currently being created.  The pending
   breakpoint may contain a separate condition string or commands
   that were added after the initial pending breakpoint was created.

d5278 1
a5278 2
		    int thread, int ignore_count, int from_tty,
		    struct breakpoint *pending_bp)
d5288 1
a5288 2
			 thread, ignore_count, from_tty,
			 pending_bp);
d5440 1
a5440 4
   second bit : 0 normal breakpoint, 1 hardware breakpoint. 

   PENDING_BP is non-NULL when this function is being called to resolve
   a pending breakpoint.  */
d5443 1
a5443 1
break_command_1 (char *arg, int flag, int from_tty, struct breakpoint *pending_bp)
a5487 4
	  /* If called to resolve pending breakpoint, just return
	     error code.  */
	  if (pending_bp)
	    return e.reason;
d5571 1
a5571 2
			  thread, ignore_count, from_tty,
			  pending_bp);
d5693 1
a5693 2
		      args->thread, args->ignore_count, 0/*from-tty*/, 
		      NULL/*pending_bp*/);
d5776 1
a5776 1
  break_command_1 (arg, 0, from_tty, NULL);
d5782 1
a5782 1
  break_command_1 (arg, BP_TEMPFLAG, from_tty, NULL);
d5788 1
a5788 1
  break_command_1 (arg, BP_HARDWAREFLAG, from_tty, NULL);
d5794 1
a5794 1
  break_command_1 (arg, (BP_TEMPFLAG | BP_HARDWAREFLAG), from_tty, NULL);
d5835 1
a5835 1
    break_command_1 (arg, 0, from_tty, NULL);
d5867 1
a5867 1
    break_command_1 (arg, 0, from_tty, NULL);
@


1.276
log
@        * breakpoint.h (create_solib_load_event_breakpoint)
        (create_solib_unload_event_breakpoint)
        (create_fork_event_catchpoint, create_vfork_event_catchpoint)
        (create_exec_event_catchpoint): Delete declaration.
        * breakpoint.c (create_solib_load_event_breakpoint)
        (solib_load_unload_1, create_solib_unload_event_breakpoint): Delete.
        (create_fork_event_catchpoint, create_vfork_event_catchpoint)
        (create_exec_event_catchpoint): Make static.
@
text
@d4322 1
a4322 1
struct breakpoint *
@


1.275
log
@        * breakpoint.h (set_breakpoint_sal): Remove declaration.
        * breakpoint.c (set_breakpoint_sal): Delete.
@
text
@a171 5
static void solib_load_unload_1 (char *hookname,
				 int tempflag,
				 char *dll_pathname,
				 char *cond_string, enum bptype bp_kind);

a4699 92
solib_load_unload_1 (char *hookname, int tempflag, char *dll_pathname,
		     char *cond_string, enum bptype bp_kind)
{
  struct breakpoint *b;
  struct symtabs_and_lines sals;
  struct cleanup *old_chain;
  struct cleanup *canonical_strings_chain = NULL;
  char *addr_start = hookname;
  char *addr_end = NULL;
  char **canonical = (char **) NULL;
  int thread = -1;		/* All threads. */

  /* Set a breakpoint on the specified hook.  */
  sals = decode_line_1 (&hookname, 1, (struct symtab *) NULL, 
			0, &canonical, NULL);
  addr_end = hookname;

  if (sals.nelts == 0)
    {
      warning (_("Unable to set a breakpoint on dynamic linker callback.\n"
		 "Suggest linking with /opt/langtools/lib/end.o.\n"
		 "GDB will be unable to track shl_load/shl_unload calls."));
      return;
    }
  if (sals.nelts != 1)
    {
      warning (_("Unable to set unique breakpoint on dynamic linker callback.\n"
		 "GDB will be unable to track shl_load/shl_unload calls."));
      return;
    }

  /* Make sure that all storage allocated in decode_line_1 gets freed
     in case the following errors out.  */
  old_chain = make_cleanup (xfree, sals.sals);
  if (canonical != (char **) NULL)
    {
      make_cleanup (xfree, canonical);
      canonical_strings_chain = make_cleanup (null_cleanup, 0);
      if (canonical[0] != NULL)
	make_cleanup (xfree, canonical[0]);
    }

  resolve_sal_pc (&sals.sals[0]);

  /* Remove the canonical strings from the cleanup, they are needed below.  */
  if (canonical != (char **) NULL)
    discard_cleanups (canonical_strings_chain);

  b = set_raw_breakpoint (sals.sals[0], bp_kind);
  set_breakpoint_count (breakpoint_count + 1);
  b->number = breakpoint_count;
  b->cond_string = (cond_string == NULL) ? 
    NULL : savestring (cond_string, strlen (cond_string));
  b->thread = thread;

  if (canonical != (char **) NULL && canonical[0] != NULL)
    b->addr_string = canonical[0];
  else if (addr_start)
    b->addr_string = savestring (addr_start, addr_end - addr_start);

  b->enable_state = bp_enabled;
  b->disposition = tempflag ? disp_del : disp_donttouch;

  if (dll_pathname == NULL)
    b->dll_pathname = NULL;
  else
    {
      b->dll_pathname = (char *) xmalloc (strlen (dll_pathname) + 1);
      strcpy (b->dll_pathname, dll_pathname);
    }

  mention (b);
  do_cleanups (old_chain);
}

void
create_solib_load_event_breakpoint (char *hookname, int tempflag,
				    char *dll_pathname, char *cond_string)
{
  solib_load_unload_1 (hookname, tempflag, dll_pathname, 
		       cond_string, bp_catch_load);
}

void
create_solib_unload_event_breakpoint (char *hookname, int tempflag,
				      char *dll_pathname, char *cond_string)
{
  solib_load_unload_1 (hookname, tempflag, dll_pathname, 
		       cond_string, bp_catch_unload);
}

static void
d4726 1
a4726 1
void
d4732 1
a4732 1
void
d4738 1
a4738 1
void
@


1.274
log
@	* breakpoint.c (breakpoint_sals_to_pc): Do not check for
	DEPRECATED_PC_REQUIRES_RUN_BEFORE_USE.

	* config/pa/tm-hppa.h: Delete file.
	* config/pa/hppa64.mt: Do not set DEPRECATED_TM_FILE.
	* config/pa/hppahpux.mt: Likewise.
	* config/pa/hppa.mt: Likewise.
	* config/pa/linux.mt: Likewise.
	* hppa-tdep.c (hppa_pc_requires_run_before_use): Delete.
@
text
@a6984 13
/* Used by the gui, could be made a worker for other things. */

struct breakpoint *
set_breakpoint_sal (struct symtab_and_line sal)
{
  struct breakpoint *b;
  b = set_raw_breakpoint (sal, bp_breakpoint);
  set_breakpoint_count (breakpoint_count + 1);
  b->number = breakpoint_count;
  b->thread = -1;
  return b;
}

@


1.273
log
@	* breakpoint.c (do_enable_breakpoint): Delay enabling until after
	checking watchpoint resources.
@
text
@d5486 1
a5486 27
    {
      resolve_sal_pc (&sals->sals[i]);

      /* It's possible for the PC to be nonzero, but still an illegal
         value on some targets.

         For example, on HP-UX if you start gdb, and before running the
         inferior you try to set a breakpoint on a shared library function
         "foo" where the inferior doesn't call "foo" directly but does
         pass its address to another function call, then we do find a
         minimal symbol for the "foo", but it's address is invalid.
         (Appears to be an index into a table that the loader sets up
         when the inferior is run.)

         Give the target a chance to bless sals.sals[i].pc before we
         try to make a breakpoint for it. */
#ifdef DEPRECATED_PC_REQUIRES_RUN_BEFORE_USE
      if (DEPRECATED_PC_REQUIRES_RUN_BEFORE_USE (sals->sals[i].pc))
	{
	  if (address == NULL)
	    error (_("Cannot break without a running program."));
	  else
	    error (_("Cannot break on %s without a running program."), 
		   address);
	}
#endif
    }
@


1.272
log
@2007-10-08  Pierre Muller  <muller@@ics.u-strasbg.fr>

        * breakpoint.c (print_one_breakpoint_location): ARI fix:
	Replace asprintf by xstrprintf.
@
text
@a8096 6
  if (bpt->enable_state != bp_permanent)
    bpt->enable_state = bp_enabled;
  bpt->disposition = disposition;
  check_duplicates (bpt);
  breakpoints_changed ();
  
a8113 1
	      bpt->enable_state = bp_disabled;
d8119 2
a8120 1
      value_free (bpt->val);
a8144 1
	      bpt->enable_state = bp_disabled;
d8154 6
@


1.271
log
@2007-09-16  Daniel Jacobowitz  <dan@@codesourcery.com>
	    Jeff Johnston  <jjohnstn@@redhat.com>

	* breakpoint.c (watchpoints_triggered): New.
	(bpstat_stop_status): Remove STOPPED_BY_WATCHPOINT argument.
	Check watchpoint_triggered instead.  Combine handling for software
	and hardware watchpoints.  Do not use target_stopped_data_address
	here.  Always check a watchpoint if its scope breakpoint triggers.
	Do not stop for thread or overlay events.  Improve check for
	triggered watchpoints without a value change.
	(watch_command_1): Insert the scope breakpoint first.  Link the
	scope breakpoint to the watchpoint.
	* breakpoint.h (enum watchpoint_triggered): New.
	(struct breakpoint): Add watchpoint_triggered.
	(bpstat_stop_status): Update prototype.
	(watchpoints_triggered): Declare.
	* infrun.c (enum infwait_status): Add infwait_step_watch_state.
	(stepped_after_stopped_by_watchpoint): Delete.
	(handle_inferior_event): Make stepped_after_stopped_by_watchpoint
	local.  Handle infwait_step_watch_state.  Update calls to
	bpstat_stop_status.  Use watchpoints_triggered to check
	watchpoints.
	* remote.c (stepped_after_stopped_by_watchpoint): Remove extern.
	(remote_stopped_data_address): Do not check it.

	* gdb.texinfo (Setting Watchpoints): Adjust warning text about
	multi-threaded watchpoints.
	* gdbint.texinfo (Watchpoints): Describe how watchpoints are
	checked.  Describe sticky notification.  Expand description
	of steppable and continuable watchpoints.
	(Watchpoints and Threads): New subsection.

	* gdb.threads/watchthreads.c (thread_function): Sleep between
	iterations.
	* gdb.threads/watchthreads.exp: Allow two watchpoints to trigger
	at once for S/390.  Generate matching fails and passes.
@
text
@d3529 1
a3529 1
      asprintf (&formatted, "%d.%d", b->number, loc_number);
@


1.270
log
@	* breakpoint.c (create_breakpoint): Set
	condition on each location, not on the first
	location of breakpoint.
@
text
@d2540 77
d2735 1
a2735 3
   BP_ADDR in thread PTID.  STOPPED_BY_WATCHPOINT is 1 if the
   target thinks we stopped due to a hardware watchpoint, 0 if we
   know we did not trigger a hardware watchpoint, and -1 if we do not know.  */
d2737 1
a2737 1
/* Determine whether we stopped at a breakpoint, etc, or whether we
d2752 1
a2752 1
bpstat_stop_status (CORE_ADDR bp_addr, ptid_t ptid, int stopped_by_watchpoint)
d2790 6
a2795 5
    /* Continuable hardware watchpoints are treated as non-existent if the 
       reason we stopped wasn't a hardware watchpoint (we didn't stop on 
       some data address).  Otherwise gdb won't stop on a break instruction 
       in the code (not from a breakpoint) when a hardware watchpoint has 
       been defined.  */
d2800 1
a2800 1
	&& !stopped_by_watchpoint)
d2866 4
a2869 46
    if (b->type == bp_watchpoint ||
	b->type == bp_hardware_watchpoint)
      {
	char *message = xstrprintf ("Error evaluating expression for watchpoint %d\n",
				    b->number);
	struct cleanup *cleanups = make_cleanup (xfree, message);
	int e = catch_errors (watchpoint_check, bs, message, 
			      RETURN_MASK_ALL);
	do_cleanups (cleanups);
	switch (e)
	  {
	  case WP_DELETED:
	    /* We've already printed what needs to be printed.  */
	    /* Actually this is superfluous, because by the time we
               call print_it_typical() the wp will be already deleted,
               and the function will return immediately. */
	    bs->print_it = print_it_done;
	    /* Stop.  */
	    break;
	  case WP_VALUE_CHANGED:
	    /* Stop.  */
	    ++(b->hit_count);
	    break;
	  case WP_VALUE_NOT_CHANGED:
	    /* Don't stop.  */
	    bs->print_it = print_it_noop;
	    bs->stop = 0;
	    continue;
	  default:
	    /* Can't happen.  */
	    /* FALLTHROUGH */
	  case 0:
	    /* Error from catch_errors.  */
	    printf_filtered (_("Watchpoint %d deleted.\n"), b->number);
	    if (b->related_breakpoint)
	      b->related_breakpoint->disposition = disp_del_at_next_stop;
	    b->disposition = disp_del_at_next_stop;
	    /* We've already printed what needs to be printed.  */
	    bs->print_it = print_it_done;

	    /* Stop.  */
	    break;
	  }
      }
    else if (b->type == bp_read_watchpoint || 
	     b->type == bp_access_watchpoint)
d2873 1
a2873 1
	int found = 0;
d2875 16
a2890 14
	if (!target_stopped_data_address (&current_target, &addr))
	  continue;
	for (v = b->val_chain; v; v = value_next (v))
	  {
	    if (VALUE_LVAL (v) == lval_memory
		&& ! value_lazy (v))
	      {
		struct type *vtype = check_typedef (value_type (v));

		if (v == b->val_chain
		    || (TYPE_CODE (vtype) != TYPE_CODE_STRUCT
			&& TYPE_CODE (vtype) != TYPE_CODE_ARRAY))
		  {
		    CORE_ADDR vaddr;
d2892 1
a2892 10
		    vaddr = VALUE_ADDRESS (v) + value_offset (v);
		    /* Exact match not required.  Within range is
                       sufficient.  */
		    if (addr >= vaddr &&
			addr < vaddr + TYPE_LENGTH (value_type (v)))
		      found = 1;
		  }
	      }
	  }
	if (found)
d2920 9
d2945 1
a2945 1
	else	/* found == 0 */
d2947 4
a2950 4
	    /* This is a case where some watchpoint(s) triggered,
	       but not at the address of this watchpoint (FOUND
	       was left zero).  So don't print anything for this
	       watchpoint.  */
d2972 7
d3009 3
d3038 21
a3058 11
  /* The value of a hardware watchpoint hasn't changed, but the
     intermediate memory locations we are watching may have.  */
  if (bs && !bs->stop &&
      (b->type == bp_hardware_watchpoint ||
       b->type == bp_read_watchpoint ||
       b->type == bp_access_watchpoint))
    {
      remove_breakpoints ();
      insert_breakpoints ();
    }
  return bs;
d6024 1
a6024 1
  struct breakpoint *b;
d6102 31
a6147 1
  frame = block_innermost_frame (exp_valid_block);
d6149 1
a6149 4
    {
      prev_frame = get_prev_frame (frame);
      b->watchpoint_frame = get_frame_id (frame);
    }
d6151 3
d6155 4
a6158 1
      memset (&b->watchpoint_frame, 0, sizeof (b->watchpoint_frame));
a6160 31
  /* If the expression is "local", then set up a "watchpoint scope"
     breakpoint at the point where we've left the scope of the watchpoint
     expression.  */
  if (innermost_block)
    {
      if (prev_frame)
	{
	  struct breakpoint *scope_breakpoint;
	  scope_breakpoint = create_internal_breakpoint (get_frame_pc (prev_frame),
							 bp_watchpoint_scope);

	  scope_breakpoint->enable_state = bp_enabled;

	  /* Automatically delete the breakpoint when it hits.  */
	  scope_breakpoint->disposition = disp_del;

	  /* Only break in the proper frame (help with recursion).  */
	  scope_breakpoint->frame_id = get_frame_id (prev_frame);

	  /* Set the address at which we will stop.  */
	  scope_breakpoint->loc->requested_address
	    = get_frame_pc (prev_frame);
	  scope_breakpoint->loc->address
	    = adjust_breakpoint_address (scope_breakpoint->loc->requested_address,
	                                 scope_breakpoint->type);

	  /* The scope breakpoint is related to the watchpoint.  We
	     will need to act on them together.  */
	  b->related_breakpoint = scope_breakpoint;
	}
    }
@


1.269
log
@	* breakpoint.c (remove_sal): New.
	(expand_line_sal_maybe): New.
	(create_breakpoints): Call expand_line_sal_maybe.
	(clear_command): Add comment.
	(breakpoint_re_set_one): Call expand_line_sal_maybe.
	* linespec.c (decode_indirect): Set explicit_pc to 1.
	(decode_all_digits): Set explicit_line to 1.
	(append_expanded_sal): New.
	(expand_line_sal): New.
	* linespec.h (expand_line_sal): Declare.
	* symtab.c (init_sal): Initialize explicit_pc
	and explicit_line.
	* symtab.h (struct symtab_and_line): New fields
	explicit_pc and explicit_line.
@
text
@d5166 1
a5166 1
	  b->loc->cond = parse_exp_1 (&arg, block_for_pc (b->loc->address), 0);
@


1.268
log
@	* breakpoint.h (enum enable_state): Remove the
	bp_shlib_disabled enumerator.
	(struct bp_location): New members shlib_disabled,
	global_next, enabled and function_name.
	Rename pending to condition_not_parsed.

	* breakpoint.c (ALL_BP_LOCATIONS): Iterate over global_next.
	(ALL_BP_LOCATIONS_SAFE): Likewise.
	(breakpoint_enabled): Don't check for pending.
	(condition_command): Free and update all locations of
	a breakpoint.
	(insert_bp_location): Adjust.
	(software_breakpoint_inserted_here_p): Don't care
	if breakpoint is enabled, as soon as it's inserted.
	(print_it_typical): Print bpstat's location, not
	bpstat's breakpoint's location.
	(bpstat_stop_status): Iterate over all locations, not
	all breakpoints.
	(print_breakpoint_location): New.
	(print_one_breakpoint): Renamed to
	(print_one_breakpoint_location): ...this. Take
	parameters to describe which location is being
	printed. Modify code to properly print header
	for several locations and individual locations.
	(print_one_breakpoint): Print all locations.
	(breakpoint_has_pc): New.
	(describe_other_breakpoints): Use the above.
	(check_duplicates): Renamed to...
	(check_duplicates_for): .. this.
	(check_duplicates): Use check_duplicates_for.
	(allocate_bp_location): Adjust.
	(set_raw_breakpoint_without_location): New,
	extracted from set_raw_breakpoint.
	(set_breakpoint_location_function): New.
	(set_raw_breakpoint): Use
	set_raw_breakpoint_without_location.
	(make_breakpoint_permanent): Mark all locations
	as inserted.
	(disable_breakpoints_in_shlibs): Iterate over
	locations.
	(disable_breakpoints_in_unloaded_shlib): Likewise.
	(re_enable_breakpoints_in_shlibs): Likewise.
	(mention): Say "pending" when breakpoint has
	zero locations.  If breakpoint has more than one
	location, say so.
	(add_location_to_breakpoint): New.
	(create_breakpoint): Accept symtabs_and_lines, not
	symtab_and_line. Pass extra sals to
	add_location_to_breakpoint.
	(create_breakpoints): Pass symtabs_and_lines to
	create_breakpoints.
	(break_command_1): Make pending breakpoints
	have zero locations.
	(do_captured_breakpoint): Remove wrong allocation.
	(clear_command): Iterate over all locations.
	(unlink_locations_from_global_list): Renamed
	from unlink_location_from_global_list. Remove
	all locations.
	(delete_breakpoint): Remove all locations.
	Iterate over all locations when deciding which
	other location to re-enable.
	(all_locations_are_pending): New.
	(update_breakpoint_locations): Renamed from
	update_breakpoint_location. Try to match old
	and new locations using names of containing
	functions.
	(breakpoint_re_set_one): Adjust.
	(find_location_by_number): New.
	(disable_command): Allow disabling individual location.
	(enable_command): Allow enabling individual location.
	* breakpoint.c: Adjust all uses of breakpoint's
	enable state to for bp_shlib_disabled change.
@
text
@d5187 122
d5339 2
a5340 3
      struct symtabs_and_lines sals2;
      sals2.sals = sals.sals + i;
      sals2.nelts = 1;
d5342 1
a5342 1
      create_breakpoint (sals2, addr_string[i],
d7013 17
d7545 6
a7550 2
  if (existing_locations)
    free_bp_location (existing_locations);
d7568 1
d7643 2
a7644 2

      update_breakpoint_locations (b, sals);
@


1.267
log
@	* breakpoint.c (do_restore_lang_radix_cleanup): Remove.
	(resolve_pending_breakpoint): Remove.
	(re_enable_breakpoints_in_shlibs): Remove.
	(unlink_locations_from_global_list): New.
	(update_breakpoint_locations): New.
	(breakpoint_re_set_one): Don't bail out on pending breakpoints.
	Use parse_condition and update_breakpoint_location to
	reset breakpoint.  Ignore 'symbol not found' error from
	decode_line_1.
	(breakpoint_re_set): Don't emit newline before the
	reason why breakpoint is not reset.
	(do_enable_breakpoint): Don't specially process pending
	breakpoints.
	(free_bp_location): New.
	(break_command_1): For pending breakpoints, initialize
	all fields of a sal with zeroes.
	* breakpoint.h (re_enable_breakpoints_in_shlibs): Remove.
	* infcmd.c (post_create_inferior): Don't call
	re_enable_breakpoints_in_shlibs.
	* infrun.c (handle_inferior_event): Likewise.
	* solib-irix.c (irix_solib_create_inferior_hook): Likewise.
	* solib-osf.c (osf_solib_create_inferior_hook): Likewise.
	* win32-nat.c (get_win32_debug_event): Likewise.
@
text
@d278 1
a278 1
#define ALL_BP_LOCATIONS(B)  for (B = bp_location_chain; B; B = B->next)
d282 1
a282 1
	     B ? (TMP=B->next, 1): 0;	\
d359 1
a359 1
  return (b->enable_state == bp_enabled && !b->pending);
d575 1
a575 1
      if (loc->cond)
d577 5
a581 2
	  xfree (loc->cond);
	  loc->cond = 0;
d598 2
a599 1
	  if (!b->pending)
d601 2
a602 2
	      b->loc->cond = parse_exp_1 (&arg, 
					  block_for_pc (b->loc->address), 0);
d853 1
a853 1
  if (bpt->inserted || bpt->duplicate)
d976 1
a976 1
	      bpt->owner->enable_state = bp_shlib_disabled;
d1815 1
a1815 3
      if ((breakpoint_enabled (bpt->owner)
	   || bpt->owner->enable_state == bp_permanent)
	  && bpt->inserted
d2165 1
d2173 2
a2174 1
  b = bs->breakpoint_at->owner;
d2180 3
a2182 3
      if (b->loc->address != b->loc->requested_address)
	breakpoint_adjustment_warning (b->loc->requested_address,
	                               b->loc->address,
d2679 2
a2680 1
  struct breakpoint *b, *temp;
d2689 1
a2689 1
  ALL_BREAKPOINTS_SAFE (b, temp)
d2691 2
d2707 1
a2707 1
	if (b->loc->address != bp_addr) 	/* address doesn't match */
d2710 2
a2711 2
	    && section_is_overlay (b->loc->section) 
	    && !section_is_mapped (b->loc->section))
d2729 1
a2729 1
	if (b->loc->address != bp_addr)
d2732 2
a2733 2
	    && section_is_overlay (b->loc->section) 
	    && !section_is_mapped (b->loc->section))
d2784 1
a2784 1
    bs = bpstat_alloc (b->loc, bs);	/* Alloc a bpstat to explain stop */
d2936 1
a2936 1
	if (b->loc->cond)
d2942 1
a2942 1
	      = catch_errors (breakpoint_cond_eval, (b->loc->cond),
d2948 1
a2948 1
	if (b->loc->cond && value_is_zero)
d2995 3
a2997 3
      (bs->breakpoint_at->owner->type == bp_hardware_watchpoint ||
       bs->breakpoint_at->owner->type == bp_read_watchpoint ||
       bs->breakpoint_at->owner->type == bp_access_watchpoint))
d3359 42
d3403 4
a3406 2
print_one_breakpoint (struct breakpoint *b,
		      CORE_ADDR *last_addr)
d3451 14
d3470 11
a3480 1
  ui_out_field_int (uiout, "number", b->number);
d3484 11
a3494 6
  if (((int) b->type >= (sizeof (bptypes) / sizeof (bptypes[0])))
      || ((int) b->type != bptypes[(int) b->type].type))
    internal_error (__FILE__, __LINE__,
		    _("bptypes table does not describe type #%d."),
		    (int) b->type);
  ui_out_field_string (uiout, "type", bptypes[(int) b->type].description);
d3498 5
a3502 1
  ui_out_field_string (uiout, "disp", bpdisps[(int) b->disposition]);
d3506 19
a3524 2
  ui_out_field_fmt (uiout, "enabled", "%c", bpenables[(int) b->enable_state]);
  ui_out_spaces (uiout, 2);
d3537 8
a3544 1
    b->ops->print_one (b, last_addr);
d3656 1
a3656 1
	    if (b->pending)
d3658 2
d3661 1
a3661 1
	      ui_out_field_core_addr (uiout, "addr", b->loc->address);
d3664 4
a3667 35
	*last_addr = b->loc->address;
	if (b->source_file)
	  {
	    sym = find_pc_sect_function (b->loc->address, b->loc->section);
	    if (sym)
	      {
		ui_out_text (uiout, "in ");
		ui_out_field_string (uiout, "func",
				     SYMBOL_PRINT_NAME (sym));
		ui_out_wrap_hint (uiout, wrap_indent);
		ui_out_text (uiout, " at ");
	      }
	    ui_out_field_string (uiout, "file", b->source_file);
	    ui_out_text (uiout, ":");

            if (ui_out_is_mi_like_p (uiout))
              {
                struct symtab_and_line sal = find_pc_line (b->loc->address, 0);
                char *fullname = symtab_to_fullname (sal.symtab);

                if (fullname)
                  ui_out_field_string (uiout, "fullname", fullname);
              }

	    ui_out_field_int (uiout, "line", b->line_number);
	  }
	else if (b->pending)
	  {
	    ui_out_field_string (uiout, "pending", b->addr_string);
	  }
	else
	  {
	    print_address_symbolic (b->loc->address, stb->stream, demangle, "");
	    ui_out_field_stream (uiout, "at", stb);
	  }
d3671 1
a3671 1
  if (b->thread != -1)
d3681 1
a3681 1
  if (frame_id_p (b->frame_id))
d3691 1
a3691 1
  if (b->loc->cond && !ada_exception_catchpoint_p (b))
a3697 9
      print_expression (b->loc->cond, stb->stream);
      ui_out_field_stream (uiout, "cond", stb);
      ui_out_text (uiout, "\n");
    }

  if (b->pending && b->cond_string)
    {
      annotate_field (7);
      ui_out_text (uiout, "\tstop only if ");
d3702 1
a3702 1
  if (b->thread != -1)
d3710 1
a3710 1
  if (show_breakpoint_hit_counts && b->hit_count)
d3728 1
a3728 1
    if (show_breakpoint_hit_counts && b->hit_count == 0)
d3731 1
a3731 1
  if (b->ignore_count)
d3739 1
a3739 1
  if ((l = b->commands))
d3752 29
d3873 1
a3873 1
  ui_out_table_header (uiout, 3, ui_left, "number", "Num");		/* 1 */
d3882 1
a3882 1
  ui_out_table_header (uiout, 3, ui_left, "enabled", "Enb");	/* 4 */
d3954 13
d3976 1
a3976 3
    if (b->loc->address == pc)	/* address match / overlay match */
      if (!b->pending && (!overlay_debugging || b->loc->section == section))
	others++;
d3984 18
a4001 20
	if (b->loc->address == pc)	/* address match / overlay match */
	  if (!b->pending && (!overlay_debugging || b->loc->section == section))
	    {
	      others--;
	      printf_filtered ("%d", b->number);
	      if (b->thread == -1 && thread != -1)
		printf_filtered (" (all threads)");
	      else if (b->thread != -1)
		printf_filtered (" (thread %d)", b->thread);
	      printf_filtered ("%s%s ",
			       ((b->enable_state == bp_disabled || 
				 b->enable_state == bp_shlib_disabled || 
				 b->enable_state == bp_call_disabled) 
				? " (disabled)"
				: b->enable_state == bp_permanent 
				? " (permanent)"
				: ""),
			       (others > 1) ? "," 
			       : ((others == 1) ? " and" : ""));
	    }
d4062 1
a4062 1
check_duplicates (struct breakpoint *bpt)
a4066 5
  CORE_ADDR address = bpt->loc->address;
  asection *section = bpt->loc->section;

  if (! breakpoint_address_is_meaningful (bpt))
    return;
a4069 2
	&& b->owner->enable_state != bp_shlib_disabled
	&& !b->owner->pending
d4071 2
a4104 2
		&& b->owner->enable_state != bp_shlib_disabled
		&& !b->owner->pending
d4106 1
d4123 12
d4206 2
d4253 3
a4255 3
      while (loc_p->next)
	loc_p = loc_p->next;
      loc_p->next = loc;
d4268 59
a4326 1
/* set_raw_breakpoint() is a low level routine for allocating and
d4336 2
a4337 2
   particular, set_raw_breakpoint() does NOT set the breakpoint
   number!  Care should be taken to not allow an error() to occur
d4344 1
a4344 1
  struct breakpoint *b, *b1;
a4346 3
  b = (struct breakpoint *) xmalloc (sizeof (struct breakpoint));
  memset (b, 0, sizeof (*b));

a4364 4
  b->type = bptype;
  b->language = current_language->la_language;
  b->input_radix = input_radix;
  b->thread = -1;
a4365 16
  b->enable_state = bp_enabled;
  b->next = 0;
  b->silent = 0;
  b->ignore_count = 0;
  b->commands = NULL;
  b->frame_id = null_frame_id;
  b->dll_pathname = NULL;
  b->triggered_dll_pathname = NULL;
  b->forked_inferior_pid = 0;
  b->exec_pathname = NULL;
  b->ops = NULL;
  b->pending = 0;

  /* Add this breakpoint to the end of the chain
     so that a list of breakpoints will come out in order
     of increasing numbers.  */
d4367 1
a4367 9
  b1 = breakpoint_chain;
  if (b1 == 0)
    breakpoint_chain = b;
  else
    {
      while (b1->next)
	b1 = b1->next;
      b1->next = b;
    }
d4381 1
d4384 7
a4390 2
  /* By definition, permanent breakpoints are already present in the code.  */
  b->loc->inserted = 1;
d4583 1
a4583 1
  struct breakpoint *b;
d4586 1
a4586 1
  ALL_BREAKPOINTS (b)
d4588 6
d4595 1
a4595 1
	&& breakpoint_enabled (b) && !b->loc->duplicate
d4597 1
a4597 1
	&& PC_SOLIB (b->loc->address)
d4599 1
a4599 1
	&& solib_address (b->loc->address)
d4602 3
a4604 1
	b->enable_state = bp_shlib_disabled;
d4614 1
a4614 1
  struct breakpoint *b;
d4617 1
a4617 1
  ALL_BREAKPOINTS (b)
d4619 4
a4622 3
    if ((b->loc->loc_type == bp_loc_hardware_breakpoint
	|| b->loc->loc_type == bp_loc_software_breakpoint)
	&& breakpoint_enabled (b) && !b->loc->duplicate)
d4625 1
a4625 1
	char *so_name = PC_SOLIB (b->loc->address);
d4627 1
a4627 1
	char *so_name = solib_address (b->loc->address);
d4631 1
a4631 1
	    b->enable_state = bp_shlib_disabled;
d4635 1
a4635 1
	    b->loc->inserted = 0;
d5055 1
a5055 1
      if (b->pending)
d5069 10
d5088 18
d5115 1
a5115 1
create_breakpoint (struct symtab_and_line sal, char *addr_string,
d5121 2
a5122 1
  struct breakpoint *b;
d5136 14
a5149 2
  if (from_tty)
    describe_other_breakpoints (sal.pc, sal.section, thread);
d5151 11
a5161 28
  b = set_raw_breakpoint (sal, type);
  set_breakpoint_count (breakpoint_count + 1);
  b->number = breakpoint_count;
  b->thread = thread;
  
  b->cond_string = cond_string;
  b->ignore_count = ignore_count;
  b->enable_state = bp_enabled;
  b->disposition = disposition;
  /* If resolving a pending breakpoint, a check must be made to see if
     the user has specified a new condition or commands for the 
     breakpoint.  A new condition will override any condition that was 
     initially specified with the initial breakpoint command.  */
  if (pending_bp)
    {
      if (pending_bp->cond_string)
	b->cond_string = savestring (pending_bp->cond_string, 
				     strlen (pending_bp->cond_string));
      
      /* If there are commands associated with the breakpoint, they should 
	 be copied too.  */
      if (pending_bp->commands)
	b->commands = copy_command_lines (pending_bp->commands);
	    
      /* We have to copy over the ignore_count and thread as well.  */
      b->ignore_count = pending_bp->ignore_count;
      b->thread = pending_bp->thread;
    }
d5163 1
a5163 5
  if (b->cond_string)
    {
      char *arg = b->cond_string;
      b->loc->cond = parse_exp_1 (&arg, block_for_pc (b->loc->address), 0);
      if (*arg)
d5165 9
a5173 4
	  if (pending_bp)
	    error (_("Junk at end of pending breakpoint condition expression"));
	  else
	    error (_("Garbage %s follows condition"), arg);
d5175 1
a5175 1
    }	    
d5217 5
a5221 1
      create_breakpoint (sals.sals[i], addr_string[i],
d5550 3
a5552 2
      b = set_raw_breakpoint (sal, hardwareflag ? bp_hardware_breakpoint 
		              : bp_breakpoint);
a5554 1
      b->loc->cond = NULL;
a5558 1
      b->pending = 1;
d5562 1
d5601 1
a5601 1
  char *cond_string;
a5629 4
  /* Allocate space for all the cond strings. */
  cond_string = xcalloc (sals.nelts, sizeof (char **));
  make_cleanup (xfree, cond_string);

d6919 1
d6925 23
a6947 12
	      && b->type != bp_access_watchpoint
	      /* Not if b is a watchpoint of any sort... */
	      && (((sal.pc && (b->loc->address == sal.pc)) 
		   && (!section_is_overlay (b->loc->section)
		       || b->loc->section == sal.section))
		  /* Yes, if sal.pc matches b (modulo overlays).  */
		  || ((default_match || (0 == sal.pc))
		      && b->source_file != NULL
		      && sal.symtab != NULL
		      && strcmp (b->source_file, sal.symtab->filename) == 0
		      && b->line_number == sal.line)))
	    /* Yes, if sal source file and line matches b.  */
d7022 29
d7083 6
a7088 2
  if (bpt->loc->inserted)
    remove_breakpoint (bpt->loc, mark_inserted);
d7090 6
a7095 1
  free_valchain (bpt->loc);
a7099 3
  if (bp_location_chain == bpt->loc)
    bp_location_chain = bpt->loc->next;

d7129 1
a7129 6
  ALL_BP_LOCATIONS (loc)
    if (loc->next == bpt->loc)
      {
	loc->next = bpt->loc->next;
	break;
      }
d7132 2
a7133 4
  /* If this breakpoint was inserted, and there is another breakpoint
     at the same address, we need to insert the other breakpoint.  */
  if (bpt->loc->inserted
      && bpt->type != bp_hardware_watchpoint
d7139 18
a7156 11
    {
      ALL_BREAKPOINTS (b)
	if (b->loc->address == bpt->loc->address
	    && b->loc->section == bpt->loc->section
	    && !b->loc->duplicate
	    && b->enable_state != bp_disabled
	    && b->enable_state != bp_shlib_disabled
	    && !b->pending
	    && b->enable_state != bp_call_disabled)
	{
	  int val;
d7158 15
a7172 15
	  /* We should never reach this point if there is a permanent
	     breakpoint at the same address as the one being deleted.
	     If there is a permanent breakpoint somewhere, it should
	     always be the only one inserted.  */
	  if (b->enable_state == bp_permanent)
	    internal_error (__FILE__, __LINE__,
			    _("another breakpoint was inserted on top of "
			    "a permanent breakpoint"));

	  memset (&b->loc->target_info, 0, sizeof (b->loc->target_info));
	  b->loc->target_info.placed_address = b->loc->address;
	  if (b->type == bp_hardware_breakpoint)
	    val = target_insert_hw_breakpoint (&b->loc->target_info);
	  else
	    val = target_insert_breakpoint (&b->loc->target_info);
d7174 32
a7205 31
	  /* If there was an error in the insert, print a message, then stop execution.  */
	  if (val != 0)
	    {
	      struct ui_file *tmp_error_stream = mem_fileopen ();
	      make_cleanup_ui_file_delete (tmp_error_stream);
	     

	      if (b->type == bp_hardware_breakpoint)
		{
		  fprintf_unfiltered (tmp_error_stream, 
					"Cannot insert hardware breakpoint %d.\n"
				      "You may have requested too many hardware breakpoints.\n",
					b->number);
		  }
		else
		  {
		    fprintf_unfiltered (tmp_error_stream, "Cannot insert breakpoint %d.\n", b->number);
		    fprintf_filtered (tmp_error_stream, "Error accessing memory address ");
		    deprecated_print_address_numeric (b->loc->address, 1, tmp_error_stream);
		    fprintf_filtered (tmp_error_stream, ": %s.\n",
				      safe_strerror (val));
		  }
	      
	      fprintf_unfiltered (tmp_error_stream,"The same program may be running in another process.");
	      target_terminal_ours_for_output ();
	      error_stream(tmp_error_stream); 
	    }
	  else
	    b->loc->inserted = 1;
	}
    }
d7247 6
a7252 3
  if (bpt->loc->cond)
    xfree (bpt->loc->cond);
  xfree (bpt->loc);
d7320 2
a7321 4
static void
unlink_locations_from_global_list (struct breakpoint *bpt)
  /* Remove locations of this breakpoint from the list of
     all breakpoint locations.  */
d7323 4
a7326 10
  struct bp_location **tmp = &bp_location_chain;
  struct bp_location *here = bpt->loc;

  if (here == NULL)
    return;

  for (; *tmp && *tmp != here; tmp = &((*tmp)->next));
  gdb_assert (*tmp);
       
  *tmp = here->next;	
a7328 1

d7330 2
a7331 2
update_breakpoint_location (struct breakpoint *b,
			    struct symtabs_and_lines sals)
d7335 10
a7344 6
  /* FIXME: memleak.  */
  struct bp_location *existing = b->loc;
  struct bp_location *loc;
  struct symtab_and_line sal;
  
  if (b->enable_state == bp_shlib_disabled && sals.nelts == 0)
d7350 4
a7353 4
  gdb_assert (sals.nelts == 0 || sals.nelts == 1);
  if (sals.nelts == 0)
    return;
  sal = sals.sals[0];
d7355 3
a7357 15
  loc = allocate_bp_location (b, b->type);
  loc->requested_address = sal.pc;
  loc->address = adjust_breakpoint_address (loc->requested_address,
					    b->type);
  loc->section = sal.section;
  b->loc = loc;

  /* Reparse conditions, they might contain references to the
     old symtab.  */
  if (b->cond_string != NULL)
    {
      struct gdb_exception e;
      
      s = b->cond_string;
      TRY_CATCH (e, RETURN_MASK_ERROR)
d7359 14
a7372 8
	  loc->cond = parse_exp_1 (&s, block_for_pc (sal.pc), 
				   0);
	}
      if (e.reason < 0)
	{
	  warning (_("failed to reevaluate condition for breakpoint %d: %s"), 
		   b->number, e.message);
	  b->enable_state = bp_disabled;
a7373 1
    }
d7375 8
a7382 8
  if (b->source_file != NULL)
    xfree (b->source_file);
  if (sal.symtab == NULL)
    b->source_file = NULL;
  else
    b->source_file =
      savestring (sal.symtab->filename,
		  strlen (sal.symtab->filename));
d7384 3
a7386 2
  if (b->line_number == 0)
    b->line_number = sal.line;
d7388 18
a7405 6
  if (b->enable_state == bp_shlib_disabled)
    b->enable_state = bp_enabled;

  b->pending = 0;

  check_duplicates (b);
d7407 2
a7408 2
  if (existing)
    free_bp_location (existing);
d7465 4
a7468 2
	  if (not_found && (b->pending || b->enable_state == bp_shlib_disabled
			    || b->enable_state == bp_disabled))
d7489 1
a7489 1
      if (b->pending && s && s[0])
d7498 1
d7501 5
a7505 1
      update_breakpoint_location (b, sals);
d7769 42
d7866 7
d8005 7
@


1.266
log
@	* breakpoint.c (create_breakpoint): Split from
	create_breakpoints, implementing most of its logic.
	Take just a single sal, single address string and
	single condition.  Do not take parsed condition at
	all.
	(create_breakpoints): Just call create_breakpoint
	for each sal.
	(find_condition_and_thread): New.
	(break_command_1): Use find_condition_and_thread.
	Do not keep parsed conditions.
	(do_captured_breakpoint): Don't convert
	condition string to struct expression.
@
text
@d206 2
d4145 7
a4407 45
/* Cleanup helper routine to restore the current language and
   input radix.  */
static void
do_restore_lang_radix_cleanup (void *old)
{
  struct lang_and_radix *p = old;
  set_language (p->lang);
  input_radix = p->radix;
}

/* Try and resolve a pending breakpoint.  */
static int
resolve_pending_breakpoint (struct breakpoint *b)
{
  /* Try and reparse the breakpoint in case the shared library
     is now loaded.  */
  struct symtabs_and_lines sals;
  struct symtab_and_line pending_sal;
  char **cond_string = (char **) NULL;
  char *copy_arg = b->addr_string;
  char **addr_string;
  char *errmsg;
  int rc;
  int not_found = 0;
  struct ui_file *old_gdb_stderr;
  struct lang_and_radix old_lr;
  struct cleanup *old_chain;
  
  /* Set language, input-radix, then reissue breakpoint command. 
     Ensure the language and input-radix are restored afterwards.  */
  old_lr.lang = current_language->la_language;
  old_lr.radix = input_radix;
  old_chain = make_cleanup (do_restore_lang_radix_cleanup, &old_lr);
  
  set_language (b->language);
  input_radix = b->input_radix;
  rc = break_command_1 (b->addr_string, b->flag, b->from_tty, b);
  
  if (rc == GDB_RC_OK)
    /* Pending breakpoint has been resolved.  */
    printf_filtered (_("Pending breakpoint \"%s\" resolved\n"), b->addr_string);

  do_cleanups (old_chain);
  return rc;
}
a4489 31
/* Try to reenable any breakpoints in shared libraries.  */
void
re_enable_breakpoints_in_shlibs (void)
{
  struct breakpoint *b, *tmp;

  ALL_BREAKPOINTS_SAFE (b, tmp)
  {
    if (b->enable_state == bp_shlib_disabled)
      {
	gdb_byte buf[1];
	char *lib;
	
	/* Do not reenable the breakpoint if the shared library is
	   still not mapped in.  */
#ifdef PC_SOLIB
	lib = PC_SOLIB (b->loc->address);
#else
	lib = solib_address (b->loc->address);
#endif
	if (lib != NULL && target_read_memory (b->loc->address, buf, 1) == 0)
	  b->enable_state = bp_enabled;
      }
    else if (b->pending && (b->enable_state == bp_enabled))
      {
	if (resolve_pending_breakpoint (b) == GDB_RC_OK)
	  delete_breakpoint (b);
      }
  }
}

d5358 1
a5358 1
      struct symtab_and_line sal;
a5360 3
      sal.symtab = NULL;
      sal.pc = 0;

d7086 91
d7188 3
a7190 3
  int not_found;
  int *not_found_ptr = NULL;
  struct symtabs_and_lines sals;
d7193 2
a7211 37
      /* HACK: cagney/2001-11-11: kettenis/2001-11-11: MarkK wrote:

	 ``And a hack it is, although Apple's Darwin version of GDB
	 contains an almost identical hack to implement a "future
	 break" command.  It seems to work in many real world cases,
	 but it is easy to come up with a test case where the patch
	 doesn't help at all.''

	 ``It seems that the way GDB implements breakpoints - in -
	 shared - libraries was designed for a.out shared library
	 systems (SunOS 4) where shared libraries were loaded at a
	 fixed address in memory.  Since ELF shared libraries can (and
	 will) be loaded at any address in memory, things break.
	 Fixing this is not trivial.  Therefore, I'm not sure whether
	 we should add this hack to the branch only.  I cannot
	 guarantee that things will be fixed on the trunk in the near
	 future.''

         In case we have a problem, disable this breakpoint.  We'll
         restore its status if we succeed.  Don't disable a
         shlib_disabled breakpoint though.  There's a fair chance we
         can't re-set it if the shared library it's in hasn't been
         loaded yet.  */

      if (b->pending)
	break;

      save_enable = b->enable_state;
      if (b->enable_state != bp_shlib_disabled)
        b->enable_state = bp_disabled;
      else
	/* If resetting a shlib-disabled breakpoint, we don't want to
	   see an error message if it is not found since we will expect
	   this to occur until the shared library is finally reloaded.
	   We accomplish this by giving decode_line_1 a pointer to use
	   for silent notification that the symbol is not found.  */
	not_found_ptr = &not_found;
d7216 17
a7232 20
      sals = decode_line_1 (&s, 1, (struct symtab *) NULL, 0, (char ***) NULL,
		            not_found_ptr);
      for (i = 0; i < sals.nelts; i++)
	{
	  resolve_sal_pc (&sals.sals[i]);

	  /* Reparse conditions, they might contain references to the
	     old symtab.  */
	  if (b->cond_string != NULL)
	    {
	      s = b->cond_string;
	      if (b->loc->cond)
		{
		  xfree (b->loc->cond);
		  /* Avoid re-freeing b->exp if an error during the call
		     to parse_exp_1.  */
		  b->loc->cond = NULL;
		}
	      b->loc->cond = parse_exp_1 (&s, block_for_pc (sals.sals[i].pc), 0);
	    }
d7234 1
a7234 13
	  /* We need to re-set the breakpoint if the address changes... */
	  if (b->loc->address != sals.sals[i].pc
	  /* ...or new and old breakpoints both have source files, and
	     the source file name or the line number changes...  */
	      || (b->source_file != NULL
		  && sals.sals[i].symtab != NULL
		  && (strcmp (b->source_file, sals.sals[i].symtab->filename) != 0
		      || b->line_number != sals.sals[i].line)
	      )
	  /* ...or we switch between having a source file and not having
	     one.  */
	      || ((b->source_file == NULL) != (sals.sals[i].symtab == NULL))
	    )
d7236 8
a7243 23
	      if (b->source_file != NULL)
		xfree (b->source_file);
	      if (sals.sals[i].symtab == NULL)
		b->source_file = NULL;
	      else
		b->source_file =
		  savestring (sals.sals[i].symtab->filename,
			      strlen (sals.sals[i].symtab->filename));
	      b->line_number = sals.sals[i].line;
	      b->loc->requested_address = sals.sals[i].pc;
	      b->loc->address
	        = adjust_breakpoint_address (b->loc->requested_address,
		                             b->type);

	      /* Used to check for duplicates here, but that can
	         cause trouble, as it doesn't check for disabled
	         breakpoints. */

	      mention (b);

	      /* Might be better to do this just once per breakpoint_re_set,
	         rather than once for every breakpoint.  */
	      breakpoints_changed ();
d7245 1
a7245 2
	  b->loc->section = sals.sals[i].section;
	  b->enable_state = save_enable;	/* Restore it, this worked. */
d7247 15
d7263 1
a7263 3
	  /* Now that this is re-enabled, check_duplicates
	     can be used. */
	  check_duplicates (b);
a7264 1
	}
d7378 1
a7378 1
    char *message = xstrprintf ("Error in re-setting breakpoint %d:\n",
d7605 10
a7614 1
  if (bpt->pending)
d7616 4
a7619 1
      if (bpt->enable_state != bp_enabled)
d7621 3
a7623 5
	  /* When enabling a pending breakpoint, we need to check if the breakpoint
	     is resolvable since shared libraries could have been loaded
	     after the breakpoint was disabled.  */
	  breakpoints_changed ();
 	  if (resolve_pending_breakpoint (bpt) == GDB_RC_OK)
d7625 4
a7628 1
	      delete_breakpoint (bpt);
d7631 1
a7631 2
	  bpt->enable_state = bp_enabled;
	  bpt->disposition = disposition;
a7632 8
    }
  else  /* Not a pending breakpoint.  */
    {
      if (bpt->enable_state != bp_permanent)
	bpt->enable_state = bp_enabled;
      bpt->disposition = disposition;
      check_duplicates (bpt);
      breakpoints_changed ();
d7634 9
a7642 3
      if (bpt->type == bp_watchpoint || 
	  bpt->type == bp_hardware_watchpoint ||
	  bpt->type == bp_read_watchpoint || 
d7645 2
a7646 24
	  struct frame_id saved_frame_id;

	  saved_frame_id = get_frame_id (get_selected_frame (NULL));
	  if (bpt->exp_valid_block != NULL)
	    {
	      struct frame_info *fr =
		fr = frame_find_by_id (bpt->watchpoint_frame);
	      if (fr == NULL)
		{
		  printf_filtered (_("\
Cannot enable watchpoint %d because the block in which its expression\n\
is valid is not currently in scope.\n"), bpt->number);
		  bpt->enable_state = bp_disabled;
		  return;
		}
	      select_frame (fr);
	    }
	  
	  value_free (bpt->val);
	  mark = value_mark ();
	  bpt->val = evaluate_expression (bpt->exp);
	  release_value (bpt->val);
	  if (value_lazy (bpt->val))
	    value_fetch_lazy (bpt->val);
d7648 7
a7654 3
	  if (bpt->type == bp_hardware_watchpoint ||
	      bpt->type == bp_read_watchpoint ||
	      bpt->type == bp_access_watchpoint)
d7656 1
a7656 12
	      int i = hw_watchpoint_used_count (bpt->type, &other_type_used);
	      int mem_cnt = can_use_hardware_watchpoint (bpt->val);
	      
	      /* Hack around 'unused var' error for some targets here */
	      (void) mem_cnt, (void) i;
	      target_resources_ok = TARGET_CAN_USE_HARDWARE_WATCHPOINT (
									bpt->type, i + mem_cnt, other_type_used);
	      /* we can consider of type is bp_hardware_watchpoint, convert to 
		 bp_watchpoint in the following condition */
	      if (target_resources_ok < 0)
		{
		  printf_filtered (_("\
d7659 3
a7661 4
		  bpt->enable_state = bp_disabled;
		  value_free_to_mark (mark);
		  return;
		}
a7662 3
	  
	  select_frame (frame_find_by_id (saved_frame_id));
	  value_free_to_mark (mark);
d7664 3
d7674 1
@


1.265
log
@	gdb/
	* breakpoint.h (struct breakpoint): Move the cond
	field to...
	(struct bp_location): Here.
	* breakpoint.c (condition_command, bpstat_stop_status)
	(print_one_breakpoint, allocate_bp_location)
	(solib_load_unload_1, create_fork_vfork_event_catchpoint)
	(create_exec_event_catchpoint, create_breakpoints)
	(break_command_1, watch_command_1, handle_gnu_v3_exceptions)
	(create_ada_exception_breakpoint, set_breakpoint_sal)
	(delete_breakpoint, breakpoint_re_set_one): Adjust.
	* tui/tui-winsource.c (tui_update_breakpoint_info): Adjust.
@
text
@d4987 84
d5072 8
a5079 3
   SALS.sal[i] breakpoint, include the corresponding ADDR_STRING[i],
   COND[i] and COND_STRING[i] values.

d5086 1
a5086 1
   the arrays ADDR_STRING, COND_STRING, COND and SALS (but not the
d5093 1
a5093 1
		    struct expression **cond, char **cond_string,
d5098 2
a5099 1
  if (type == bp_hardware_breakpoint)
d5101 4
a5104 8
      int i = hw_breakpoint_used_count ();
      int target_resources_ok = 
	TARGET_CAN_USE_HARDWARE_WATCHPOINT (bp_hardware_breakpoint, 
					    i + sals.nelts, 0);
      if (target_resources_ok == 0)
	error (_("No hardware breakpoint support in the target."));
      else if (target_resources_ok < 0)
	error (_("Hardware breakpoints used exceeds limit."));
a5105 54

  /* Now set all the breakpoints.  */
  {
    int i;
    for (i = 0; i < sals.nelts; i++)
      {
	struct breakpoint *b;
	struct symtab_and_line sal = sals.sals[i];

	if (from_tty)
	  describe_other_breakpoints (sal.pc, sal.section, thread);
	
	b = set_raw_breakpoint (sal, type);
	set_breakpoint_count (breakpoint_count + 1);
	b->number = breakpoint_count;
	b->loc->cond = cond[i];
	b->thread = thread;
	if (addr_string[i])
	  b->addr_string = addr_string[i];
	else
	  /* addr_string has to be used or breakpoint_re_set will delete
	     me.  */
	  b->addr_string = xstrprintf ("*0x%s", paddr (b->loc->address));
	b->cond_string = cond_string[i];
	b->ignore_count = ignore_count;
	b->enable_state = bp_enabled;
	b->disposition = disposition;
	/* If resolving a pending breakpoint, a check must be made to see if
	   the user has specified a new condition or commands for the 
	   breakpoint.  A new condition will override any condition that was 
	   initially specified with the initial breakpoint command.  */
	if (pending_bp)
	  {
	    char *arg;
	    if (pending_bp->cond_string)
	      {
		arg = pending_bp->cond_string;
		b->cond_string = savestring (arg, strlen (arg));
		b->loc->cond = parse_exp_1 (&arg, block_for_pc (b->loc->address), 0);
		if (*arg)
		  error (_("Junk at end of pending breakpoint condition expression"));
	      }
	    /* If there are commands associated with the breakpoint, they should 
	       be copied too.  */
	    if (pending_bp->commands)
	      b->commands = copy_command_lines (pending_bp->commands);
	    
	    /* We have to copy over the ignore_count and thread as well.  */
	    b->ignore_count = pending_bp->ignore_count;
	    b->thread = pending_bp->thread;
	  }
	mention (b);
      }
  }    
d5227 53
a5292 1
  struct expression **cond = 0;
d5294 1
a5294 1
  char **cond_string = (char **) NULL;
a5383 8
  /* Allocate space for all the cond expressions. */
  cond = xcalloc (sals.nelts, sizeof (struct expression *));
  make_cleanup (xfree, cond);

  /* Allocate space for all the cond strings. */
  cond_string = xcalloc (sals.nelts, sizeof (char **));
  make_cleanup (xfree, cond_string);

a5406 1
  thread = -1;			/* No specific thread yet */
d5409 8
a5416 47
      for (i = 0; i < sals.nelts; i++)
	{
	  char *tok = arg;
	  while (tok && *tok)
	    {
	      char *end_tok;
	      int toklen;
	      char *cond_start = NULL;
	      char *cond_end = NULL;
	      while (*tok == ' ' || *tok == '\t')
		tok++;
	      
	      end_tok = tok;
	      
	      while (*end_tok != ' ' && *end_tok != '\t' && *end_tok != '\000')
		end_tok++;
	      
	      toklen = end_tok - tok;
	      
	      if (toklen >= 1 && strncmp (tok, "if", toklen) == 0)
		{
		  tok = cond_start = end_tok + 1;
		  cond[i] = parse_exp_1 (&tok, block_for_pc (sals.sals[i].pc), 
				         0);
		  make_cleanup (xfree, cond[i]);
		  cond_end = tok;
		  cond_string[i] = savestring (cond_start, 
				               cond_end - cond_start);
		  make_cleanup (xfree, cond_string[i]);
		}
	      else if (toklen >= 1 && strncmp (tok, "thread", toklen) == 0)
		{
		  char *tmptok;
		  
		  tok = end_tok + 1;
		  tmptok = tok;
		  thread = strtol (tok, &tok, 0);
		  if (tok == tmptok)
		    error (_("Junk after thread keyword."));
		  if (!valid_thread_id (thread))
		    error (_("Unknown thread %d."), thread);
		}
	      else
		error (_("Junk at end of arguments."));
	    }
	}
      create_breakpoints (sals, addr_string, cond, cond_string,
d5437 1
a5437 1
      b->loc->cond = *cond;
d5439 2
a5440 2
      b->addr_string = *addr_string;
      b->cond_string = *cond_string;
d5484 1
a5484 1
  char **cond_string;
d5541 1
a5541 3
  /* Verify that conditions can be parsed, before setting any
     breakpoints.  */
  for (i = 0; i < sals.nelts; i++)
d5543 2
a5544 9
      if (args->condition != NULL)
	{
	  char *tok = args->condition;
	  cond[i] = parse_exp_1 (&tok, block_for_pc (sals.sals[i].pc), 0);
	  if (*tok != '\0')
	    error (_("Garbage %s follows condition"), tok);
	  make_cleanup (xfree, cond[i]);
	  cond_string[i] = xstrdup (args->condition);
	}
d5547 1
a5547 1
  create_breakpoints (sals, addr_string, cond, cond_string,
@


1.264
log
@	Associate bp_stat with bp_location, not breakpoint.
	* breakpoint.h (breakpoint_at): Change type
	to bp_location*.
	* breakpoint.c (bpstat_alloc): Take bp_location,
	not breakpoint.
	(bpstat_find_breakpoint): Look at bpstat's location's
	owner, not at bpstat->breakpoint_at.
	(bpstat_find_step_resume_breakpoint): Likewise.
	(bpstat_num): Likewise.
	(print_it_typical): Likewise.
	(print_bp_stop_message): Likewise.
	(watchpoint_check): Likewise.
	(bpstat_what): Likewise.
	(bpstat_get_triggered_catchpoints): Likewise.
	(breakpoint_auto_delete): Likewise.
	(delete_breakpoint): Likewise.
	(bpstat_stop_status): Pass location, not breakpoint,
	to bpstat_alloc.  Look at bpstat's location's
	owner, not at bpstat->breakpoint_at.
@
text
@d572 2
a573 1
      if (b->cond)
d575 2
a576 2
	  xfree (b->cond);
	  b->cond = 0;
a582 1
	  b->cond = 0;
d595 2
a596 1
	      b->cond = parse_exp_1 (&arg, block_for_pc (b->loc->address), 0);
d2927 1
a2927 1
	if (b->cond)
d2933 1
a2933 1
	      = catch_errors (breakpoint_cond_eval, (b->cond),
d2939 1
a2939 1
	if (b->cond && value_is_zero)
d3610 1
a3610 1
  if (b->cond && !ada_exception_catchpoint_p (b))
d3617 1
a3617 1
      print_expression (b->cond, stb->stream);
d4089 1
a4608 1
  b->cond = NULL;
a4664 1
  b->cond = NULL;
a4702 1
  b->cond = NULL;
d5035 1
a5035 1
	b->cond = cond[i];
d5058 1
a5058 1
		b->cond = parse_exp_1 (&arg, block_for_pc (b->loc->address), 0);
d5401 1
a5401 1
      b->cond = *cond;
d5794 1
a5794 1
  b->cond = cond;
a6353 1
  b->cond = NULL;
a6432 1
  b->cond = NULL;
d6519 1
a6519 1
  b->cond = cond;
a6700 1
  b->cond = 0;
a7019 2
  if (bpt->cond)
    xfree (bpt->cond);
d7059 2
d7214 1
a7214 1
	      if (b->cond)
d7216 1
a7216 1
		  xfree (b->cond);
d7219 1
a7219 1
		  b->cond = NULL;
d7221 1
a7221 1
	      b->cond = parse_exp_1 (&s, block_for_pc (sals.sals[i].pc), 0);
d7313 1
a7313 1
	  if (b->cond)
d7315 1
a7315 1
	      xfree (b->cond);
d7318 1
a7318 1
	      b->cond = NULL;
d7320 1
a7320 1
	  b->cond = parse_exp_1 (&s, (struct block *) 0, 0);
@


1.263
log
@* breakpoint.c (watch_command_1): Remove '#ifdef HPUXHPPA' block;
this code has not been compiled for two years.
@
text
@d112 1
a112 1
static bpstat bpstat_alloc (struct breakpoint *, bpstat);
d1971 1
a1971 1
      if (bsp->breakpoint_at == breakpoint)
d1997 4
a2000 4
	  (bsp->breakpoint_at->type == bp_step_resume) &&
	  (bsp->breakpoint_at->thread == current_thread || 
	   bsp->breakpoint_at->thread == -1))
	return bsp->breakpoint_at;
d2024 5
a2028 1
  b = (*bsp)->breakpoint_at;
d2159 1
d2167 1
d2169 1
a2169 1
  switch (bs->breakpoint_at->type)
d2173 5
a2177 5
      if (bs->breakpoint_at->loc->address != bs->breakpoint_at->loc->requested_address)
	breakpoint_adjustment_warning (bs->breakpoint_at->loc->requested_address,
	                               bs->breakpoint_at->loc->address,
				       bs->breakpoint_at->number, 1);
      annotate_breakpoint (bs->breakpoint_at->number);
d2182 1
a2182 1
      ui_out_field_int (uiout, "bkptno", bs->breakpoint_at->number);
d2209 1
a2209 1
      annotate_catchpoint (bs->breakpoint_at->number);
d2211 2
a2212 2
		       bs->breakpoint_at->number,
		       bs->breakpoint_at->triggered_dll_pathname);
d2217 1
a2217 1
      annotate_catchpoint (bs->breakpoint_at->number);
d2219 2
a2220 2
		       bs->breakpoint_at->number,
		       bs->breakpoint_at->triggered_dll_pathname);
d2225 1
a2225 1
      annotate_catchpoint (bs->breakpoint_at->number);
d2227 2
a2228 2
		       bs->breakpoint_at->number, 
		       bs->breakpoint_at->forked_inferior_pid);
d2233 1
a2233 1
      annotate_catchpoint (bs->breakpoint_at->number);
d2235 2
a2236 2
		       bs->breakpoint_at->number, 
		       bs->breakpoint_at->forked_inferior_pid);
d2241 1
a2241 1
      annotate_catchpoint (bs->breakpoint_at->number);
d2243 2
a2244 2
		       bs->breakpoint_at->number,
		       bs->breakpoint_at->exec_pathname);
d2252 1
a2252 1
	  annotate_catchpoint (bs->breakpoint_at->number);
d2254 1
a2254 1
			   bs->breakpoint_at->number);
d2283 1
a2283 1
	  annotate_catchpoint (bs->breakpoint_at->number);
d2285 1
a2285 1
			   bs->breakpoint_at->number);
d2314 1
a2314 1
	  annotate_watchpoint (bs->breakpoint_at->number);
d2319 1
a2319 1
	  mention (bs->breakpoint_at);
d2325 1
a2325 1
	  value_print (bs->breakpoint_at->val, stb->stream, 0, Val_pretty_default);
d2341 1
a2341 1
      mention (bs->breakpoint_at);
d2344 1
a2344 1
      value_print (bs->breakpoint_at->val, stb->stream, 0, Val_pretty_default);
d2354 1
a2354 1
	  annotate_watchpoint (bs->breakpoint_at->number);
d2359 1
a2359 1
	  mention (bs->breakpoint_at);
d2370 1
a2370 1
	  mention (bs->breakpoint_at);
d2378 1
a2378 1
      value_print (bs->breakpoint_at->val, stb->stream, 0,Val_pretty_default);
d2438 13
a2450 8
      /* Normal case.  Call the breakpoint's print_it method, or
	 print_it_typical.  */
      if (bs->breakpoint_at != NULL && bs->breakpoint_at->ops != NULL
	  && bs->breakpoint_at->ops->print_it != NULL)
	return bs->breakpoint_at->ops->print_it (bs->breakpoint_at);
      else
	return print_it_typical (bs);
      break;
d2519 1
a2519 1
bpstat_alloc (struct breakpoint *b, bpstat cbs /* Current "bs" value */ )
d2525 1
a2525 1
  bs->breakpoint_at = b;
d2555 1
a2555 1
  b = bs->breakpoint_at;
d2602 1
a2602 1
      struct value *new_val = evaluate_expression (bs->breakpoint_at->exp);
d2638 1
a2638 1
      ui_out_field_int (uiout, "wpnum", bs->breakpoint_at->number);
d2774 1
a2774 1
    bs = bpstat_alloc (b, bs);	/* Alloc a bpstat to explain stop */
d2985 3
a2987 3
      (bs->breakpoint_at->type == bp_hardware_watchpoint ||
       bs->breakpoint_at->type == bp_read_watchpoint ||
       bs->breakpoint_at->type == bp_access_watchpoint))
d3148 1
a3148 1
      switch (bs->breakpoint_at->type)
d3303 1
a3303 1
      ep = ep_list->breakpoint_at;
d3314 1
a3314 1
      bs = bpstat_alloc (ep, bs);
d6863 1
a6863 1
    if (bs->breakpoint_at && bs->breakpoint_at->disposition == disp_del
d6865 1
a6865 1
      delete_breakpoint (bs->breakpoint_at);
d7055 1
a7055 1
    if (bs->breakpoint_at == bpt)
@


1.262
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@a5769 22
#if defined(HPUXHPPA)
  /*  On HP-UX if you set a h/w
     watchpoint before the "run" command, the inferior dies with a e.g.,
     SIGILL once you start it.  I initially believed this was due to a
     bad interaction between page protection traps and the initial
     startup sequence by the dynamic linker.

     However, I tried avoiding that by having HP-UX's implementation of
     TARGET_CAN_USE_HW_WATCHPOINT return FALSE if there was no inferior_ptid
     yet, which forced slow watches before a "run" or "attach", and it
     still fails somewhere in the startup code.

     Until I figure out what's happening, I'm disallowing watches altogether
     before the "run" or "attach" command.  We'll tell the user they must
     set watches after getting the program started. */
  if (!target_has_execution)
    {
      warning (_("can't do that without a running program; try \"break main\"), \"run\" first");
      return;
    }
#endif /* HPUXHPPA */

@


1.261
log
@	* breakpoint.c (bpstat_free): New.
	(bpstat_clear): Use bpstat_free.
	(delete_breakpoint): Document why we cannot
	remove bpstats from stop_bpstat.
	* breakpoint.h (bpstat_free): Declare.
@
text
@d11 1
a11 1
   the Free Software Foundation; either version 2 of the License, or
d20 1
a20 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.260
log
@	gdb/
	* breakpoint.c (disable_breakpoints_in_shlibs): Remove
	the 'silent' parameter and code to implement that.
	* breakpoint.h (disable_breakpoints_in_shlibs): Adjust
	prototype.
	* win32-nat.c: Adjust.
	* solib.c: Adjust.
@
text
@d1900 9
d1924 1
a1924 4
      if (p->old_val != NULL)
	value_free (p->old_val);
      free_command_lines (&p->commands);
      xfree (p);
d7060 7
a7066 1
     We just check stop_bpstat for now.  */
@


1.259
log
@        gdb/
        * breakpoint.c (update_breakpoints_after_exec): Don't
        set address to zero.
@
text
@d4451 1
a4451 1
disable_breakpoints_in_shlibs (int silent)
a4465 1
      {
a4466 11
	if (!silent)
	  {
	    if (!disabled_shlib_breaks)
	      {
		target_terminal_ours_for_output ();
		warning (_("Temporarily disabling shared library breakpoints:"));
	      }
	    disabled_shlib_breaks = 1;
	    warning (_("breakpoint #%d "), b->number);
	  }
      }
@


1.258
log
@2007-08-04  Michael Snyder  <msnyder@@access-company.com>

	* breakpoint.c (print_one_breakpoint): Off by one error.
@
text
@d1409 1
a1409 15
       seem mysterious to users, keep those too.)

       ??rehrauer: Let's hope that merely clearing out this catchpoint's
       target address field, if any, is sufficient to have it be reset
       automagically.  Certainly on HP-UX that's true.

       Jim Blandy <jimb@@redhat.com>: Actually, zero is a perfectly
       valid code address on some platforms (like the mn10300
       simulators).  We shouldn't assign any special interpretation to
       a breakpoint with a zero address.  And in fact, GDB doesn't ---
       I can't see what that comment above is talking about.  As far
       as I can tell, setting the address of a
       bp_catch_exec/bp_catch_vfork/bp_catch_fork breakpoint to zero
       is meaningless, since those are implemented with HP-UX kernel
       hackery, not by storing breakpoint instructions somewhere.  */
a1413 1
	b->loc->address = (CORE_ADDR) 0;
a1455 11

    /* If this breakpoint has survived the above battery of checks, then
       it must have a symbolic address.  Be sure that it gets reevaluated
       to a target address, rather than reusing the old evaluation.

       Jim Blandy <jimb@@redhat.com>: As explained above in the comment
       for bp_catch_exec and friends, I'm pretty sure this is entirely
       unnecessary.  A call to breakpoint_re_set_one always recomputes
       the breakpoint's address from scratch, or deletes it if it can't.
       So I think this assignment could be deleted without effect.  */
    b->loc->address = (CORE_ADDR) 0;
@


1.257
log
@2007-07-31  Michael Snyder  <msnyder@@access-company.com>

	* breakpoint.c (breakpoint_init_inferior): Add 'else' to 'if'.
	True and false paths are mutually exclusive.
@
text
@d3417 1
a3417 1
  if (((int) b->type > (sizeof (bptypes) / sizeof (bptypes[0])))
@


1.256
log
@Include "top.h".
(breakpoint_1): Don't set convenience variable $_ if server prefix
is used.
(_initialize_breakpoint): Describe this behaviour in command help.
@
text
@d1732 1
a1732 1
	if (context == inf_starting) 
@


1.255
log
@2007-07-02  Markus Deuling  <deuling@@de.ibm.com>

	* breakpoint.c (insert_bp_location): Remove dead code
	(DISABLE_UNSETTABLE_BREAK).
	(disable_breakpoints_in_shlibs)
	(disable_breakpoints_in_unloaded_shlib): Likewise (comment).
@
text
@d58 1
d3832 1
a3832 1
      if (last_addr != (CORE_ADDR) -1)
d8165 2
a8166 1
are set to the address of the last breakpoint listed.\n\n\
d8182 2
a8183 1
are set to the address of the last breakpoint listed.\n\n\
d8199 2
a8200 1
are set to the address of the last breakpoint listed.\n\n\
d8219 2
a8220 2
are set to the address of the last breakpoint listed.\n\
\n\
@


1.254
log
@	* breakpoint.c (reattach_breakpoints): Do not use remove_breakpoint.
	Call insert_bp_location.
@
text
@d966 1
a966 7
	  if (
#if defined (DISABLE_UNSETTABLE_BREAK)
	      DISABLE_UNSETTABLE_BREAK (bpt->address)
#else
	      solib_address (bpt->address)
#endif
	      )
a4480 1
  /* See also: insert_breakpoints, under DISABLE_UNSETTABLE_BREAK. */
a4515 1
  /* See also: insert_breakpoints, under DISABLE_UNSETTABLE_BREAK.  */
@


1.253
log
@2007-06-13  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (TARGET_ADDR_BIT): Replace by gdbarch_addr_bit.
	* valops.c (value_cast): Likewise.
	* utils.c (strlen_paddr, paddr, paddr_nz, paddress): Likewise.
	* ui-out.c (ui_out_field_core_addr): Likewise.
	* tracepoint.c (tracepoints_info): Likewise.
	* symtab.c (print_msymbol_info): Likewise.
	* solib-irix.c (irix_current_sos)
	(irix_open_symbol_file_object): Likewise.
	* remote.c (build_remote_gdbarch_data): Likewise.
	* prologue-value.c (make_pv_area): Likewise.
	* procfs.c (info_mappings_callback): Likewise.
	* printcmd.c (print_scalar_formatted)
	(deprecated_print_address_numeric): Likewise.
	* memattr.c (mem_info_command): Likewise.
	* linux-nat.c (linux_nat_info_proc_cmd): Likewise.
	* gdbtypes.c (build_flt, gdbtypes_post_init): Likewise.
	* exec.c (print_section_info): Likewise.
	* dwarf2read.c (read_subrange_type): Likewise.
	* dwarf2loc.c (find_location_expression): Likewise.
	* dwarf2expr.c (dwarf2_read_address, unsigned_address_type)
	(signed_address_type, execute_stack_op): Likewise.
	* breakpoint.c (print_one_breakpoint, breakpoint_1): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d1341 4
a1345 1
  /* Set inferior_ptid; remove_breakpoint uses this global.  */
d1351 3
a1353 10
	remove_breakpoint (b, mark_inserted);
	/* Note: since we insert a breakpoint right after removing,
	   any decisions about automatically using hardware breakpoints
	   made in insert_bp_location are preserved.  */
	if (b->loc_type == bp_loc_hardware_breakpoint)
	  val = target_insert_hw_breakpoint (&b->target_info);
	else
	  val = target_insert_breakpoint (&b->target_info);
	/* FIXME drow/2003-10-07: This doesn't handle any other kinds of
	   breakpoints.  It's wrong for watchpoints, for example.  */
@


1.252
log
@2007-06-13  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (BREAKPOINT_FROM_PC): Replace by
	gdbarch_breakpoint_from_pc.
	* s390-tdep.c (s390_gdbarch_init): Likewise (comment).
	* remote.c (remote_insert_breakpoint)
	(remote_insert_hw_breakpoint): Likewise.
	* ppc-linux-tdep.c (ppc_linux_memory_remove_breakpoint): Likewise.
	* mips-tdep.c (mips_breakpoint_from_pc): Likewise (comment).
	* breakpoint.h (bp_target_info): Likewise (comment).
	* breakpoint.c (read_memory_nobpt): Likewise.
	* mem-break.c (default_memory_insert_breakpoint): Likewise.
	(symtab.h, breakpoint.h): Remove include. Remove unnecessary comment.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d3446 1
a3446 1
      if (TARGET_ADDR_BIT <= 32)
d3805 1
a3805 1
	  if (TARGET_ADDR_BIT <= 32)
@


1.251
log
@	* gdbarch.sh (GET_LONGJMP_TARGET): Replace by gdbarch_get_longjmp_target.
	* infrun.c (handle_inferior_event): Likewise.
	* gdbarch.sh (GET_LONGJMP_TARGET_P): Replace by
	gdbarch_get_longjmp_target_p.
	* breakpoint.c (breakpoint_re_set): Likewise.
	* infrun.c (handle_inferior_event): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d709 1
a709 1
  if (BREAKPOINT_FROM_PC (&bp_addr, &bp_size) == NULL)
@


1.250
log
@	* hppa-hpux-tdep.c (args_for_find_stub, HP_ACC_EH_notify_hook,
	HP_ACC_EH_set_hook_value, HP_ACC_EH_notify_callback, HP_ACC_EH_break,
	HP_ACC_EH_catch_throw, HP_ACC_EH_catch_catch, __eh_notification,
	hp_cxx_exception_support, hp_cxx_exception_support_initialized,
	eh_notify_hook_addr, eh_notify_callback_addr, eh_break_addr,
	eh_catch_throw_addr, break_callback_sal, setup_d_pid_in_inferior,
	find_stub_with_shl_get, cover_find_stub_with_shl_get,
	initialize_hp_cxx_exception_support, child_enable_exception_callback,
	current_ex_event, child_get_current_exception_event): Remove.
	(hppa_hpux_inferior_created): Remove.
	(hppa_hpux_init_abi): Do not install hppa_hpux_inferior_created.

	* breakpoint.h (deprecated_exception_catchpoints_are_fragile): Remove.
	(deprecated_exception_support_initialized): Remove.
	* breakpoint.c (deprecated_exception_catchpoints_are_fragile): Remove.
	(deprecated_exception_support_initialized): Remove.
	(breakpoint_init_inferior): Remove handling of non-zero
	deprecated_exception_catchpoints_are_fragile.

	* symtab.h (deprecated_hp_som_som_object_present): Remove.
	* symtab.c (deprecated_hp_som_som_object_present): Remove.
	* c-typeprint.c (c_type_print_base): Remove handling of non-zero
	deprecated_hp_som_som_object_present.
	* eval.c (evaluate_subexp_standard): Likewise.
	* valops.c (value_cast): Likewise.

	* parse.c (parse_nested_classes_for_hpacc, coloncolon): Remove.
	* parser-defs.h (parse_nested_classes_for_hpacc): Remove.
	* c-exp.y (yylex): Do not call parse_nested_classes_for_hpacc.
@
text
@d7447 1
a7447 1
  if (GET_LONGJMP_TARGET_P ())
@


1.249
log
@	* breakpoint.c (remove_breakpoint): Do not remove software
	breakpoints in unmapped overlay sections.
@
text
@a300 8
/* Indicator of whether exception catchpoints should be nuked between
   runs of a program.  */
int deprecated_exception_catchpoints_are_fragile = 0;

/* Indicator of when exception catchpoints set-up should be
   reinitialized -- e.g. when program is re-run.  */
int deprecated_exception_support_initialized = 0;

a1713 1
  static int warning_needed = 0;
a1750 8
	/* Likewise for exception catchpoints in dynamic-linked
	   executables where required */
	if (ep_is_exception_catchpoint (b)
	    && deprecated_exception_catchpoints_are_fragile)
	  {
	    warning_needed = 1;
	    delete_breakpoint (b);
	  }
a1753 11

  if (deprecated_exception_catchpoints_are_fragile)
    deprecated_exception_support_initialized = 0;

  /* Don't issue the warning unless it's really needed... */
  if (warning_needed && (context != inf_exited))
    {
      warning (_("Exception catchpoints from last run were deleted.\n"
		 "You must reinsert them explicitly."));
      warning_needed = 0;
    }
@


1.248
log
@	* breakpoint.c (single_step_breakpoint_inserted_here_p): New function.
	(breakpoint_inserted_here_p): Call it.
	(software_breakpoint_inserted_here_p): Likewise.
@
text
@d1590 6
d1597 1
a1597 1
		val = target_remove_breakpoint (&b->target_info);
@


1.247
log
@	* breakpoint.c (set_raw_breakpoint): Adjust breakpoint's address
	prior to allocating its location.
@
text
@d205 2
d1846 4
d1881 4
d7964 17
@


1.246
log
@	* breakpoint.c (update_breakpoints_after_exec, print_it_typical)
	(bpstat_what, print_one_breakpoint, allocate_bp_location)
	(mention): Remove bp_through_sigtramp support.
	* breakpoint.h (enum bptype): Remove bp_through_sigtramp.
@
text
@d4192 1
d4196 9
d4207 2
a4208 2
  b->loc->address = adjust_breakpoint_address (b->loc->requested_address,
                                               bptype);
@


1.245
log
@	* breakpoint.c (bpstat_what): Give step-resume higher priority than
	shlib events.
@
text
@a1409 7
    /* Ditto the sigtramp handler breakpoints. */
    if (b->type == bp_through_sigtramp)
      {
	delete_breakpoint (b);
	continue;
      }

a2444 1
    case bp_through_sigtramp:
a3060 3
      /* We hit the through_sigtramp breakpoint.  */
      through_sig,

a3081 1
#define ts BPSTAT_WHAT_THROUGH_SIGTRAMP
d3104 7
a3110 7
     kc   < clr sgl shl shlr slr sn sr ss ts
     sgl  < clrs shl shlr slr sn sr ss ts
     slr  < err shl shlr sn sr ss ts
     clr  < clrs err shl shlr sn sr ss ts
     clrs < err shl shlr sn sr ss ts
     ss   < shl shlr sn sr ts
     sn   < shl shlr sr ts
d3113 1
a3113 2
     sr   < ts
     ts   < 
d3131 1
a3131 1
  /*       kc    ss    sn    sgl    slr   clr    clrs   sr    ts   shl   shlr
d3134 1
a3134 1
    {kc, ss, sn, sgl, slr, clr, clrs, sr, ts, shl, shlr},
d3136 1
a3136 1
    {ss, ss, sn, ss, ss, ss, ss, sr, ts, shl, shlr},
d3138 1
a3138 1
    {sn, sn, sn, sn, sn, sn, sn, sr, ts, shl, shlr},
d3140 1
a3140 1
    {sgl, ss, sn, sgl, slr, clrs, clrs, sr, ts, shl, shlr},
d3142 1
a3142 1
    {ss, ss, sn, ss, ss, ss, ss, sr, ts, shl, shlr},
d3144 1
a3144 1
    {sn, sn, sn, sn, sn, sn, sn, sr, ts, shl, shlr},
d3146 1
a3146 1
    {slr, ss, sn, slr, slr, err, err, sr, ts, shl, shlr},
d3148 1
a3148 1
    {clr, ss, sn, clrs, err, err, err, sr, ts, shl, shlr},
d3150 1
a3150 3
    {sr, sr, sr, sr, sr, sr, sr, sr, ts, sr, sr},
/*through_sig */
    {ts, ts, ts, ts, ts, ts, ts, ts, ts, shl, shlr},
d3152 1
a3152 1
    {shl, shl, shl, shl, shl, shl, shl, sr, ts, shl, shlr},
d3154 1
a3154 1
    {shlr, shlr, shlr, shlr, shlr, shlr, shlr, sr, ts, shlr, shlr}
a3229 3
	case bp_through_sigtramp:
	  bs_class = through_sig;
	  break;
a3406 1
    {bp_through_sigtramp, "sigtramp"},
a3568 1
      case bp_through_sigtramp:
a4128 1
    case bp_through_sigtramp:
a4988 1
      case bp_through_sigtramp:
@


1.244
log
@	* breakpoint.c (gdb_breakpoint_query): Really return an
	enum gdb_rc.
	(gdb_breakpoint): Likewise.
	* thread.c (do_captured_list_thread_ids): Likewise.
	(do_captured_thread_select): Likewise.
	* mi/mi-main.c (mi_cmd_thread_select): Expect an enum gdb_rc.
	(mi_cmd_thread_list_ids): Remove bogus initialization.
@
text
@d3123 3
a3125 2
     sr   < shl shlr ts
     shl  < shlr
a3126 1
     shlr <
d3163 1
a3163 1
    {sr, sr, sr, sr, sr, sr, sr, sr, ts, shl, shlr},
d3167 1
a3167 1
    {shl, shl, shl, shl, shl, shl, shl, shl, ts, shl, shlr},
d3169 1
a3169 1
    {shlr, shlr, shlr, shlr, shlr, shlr, shlr, shlr, ts, shlr, shlr}
@


1.243
log
@	* breakpoint.c (bpstat_num): Add int *num parameter.
	* breakpoint.h (bpstat_num): Likewise.
	* infcmd.c (continue_command): Adjust to new bpstat_num
	interface.
	(program_info): Likewise.
@
text
@d3760 5
a3764 2
  return catch_exceptions_with_msg (uiout, do_captured_breakpoint_query, &args,
				    error_message, RETURN_MASK_ALL);
d5606 5
a5610 2
  return catch_exceptions_with_msg (uiout, do_captured_breakpoint, &args,
				    error_message, RETURN_MASK_ALL);
@


1.243.2.1
log
@Daniel Jacobowitz' update to Michael Snyder's reverse debugging patches
@
text
@a7536 7
void
breakpoint_silence (struct breakpoint *b)
{
  /* Silence the breakpoint.  */
  b->silent = 1;
}

@


1.242
log
@	* infrun.c (breakpoints_failed): Remove unnecessary variable.
	(handle_inferior_event): Remove unnecessary braces.
	* breakpoint.c (bpstat_what): Remove wrong comment.
@
text
@d2057 1
a2057 1
/* Return the breakpoint number of the first breakpoint we are stopped
d2061 4
a2064 1
   Return 0 if passed a bpstat which does not indicate any breakpoints.  */
d2067 1
a2067 1
bpstat_num (bpstat *bsp)
d2073 8
a2080 9
  else
    {
      b = (*bsp)->breakpoint_at;
      *bsp = (*bsp)->next;
      if (b == NULL)
	return -1;		/* breakpoint that's been deleted since */
      else
	return b->number;	/* We have its number */
    }
@


1.241
log
@	* frame.c (deprecated_selected_frame): Rename to...
	(selected_frame): ...this.  Make static.
	(get_selected_frame, select_frame): Update.
	* frame.h (deprected_select_frame): Delete.
	(deprecated_safe_get_selected_frame): Update comments.

	* breakpoint.c, cli/cli-cmds.c, f-valprint.c, infcmd.c, inflow.c,
	infrun.c, stack.c, tui/tui-disasm.c, tui/tui-source.c,
	tui/tui-winsource.c, valops.c, varobj.c, findvar.c, macroscope.c,
	parse.c, regcache.h, sh64-tdep.c, tui/tui-hooks.c, tui/tui-win.c,
	tui/tui.c: Replace references to deprecated_selected_frame.
@
text
@a3136 2
  /* We handle the through_sigtramp_breakpoint the same way; having both
     one of those and a step_resume_breakpoint is probably very rare (?).  */
@


1.240
log
@	* cli/cli-script.c: Include breakpoint.h.
	(build_command_line): Require arguments only for if and while commands.
	(get_command_line, execute_user_command, execute_control_command):
	Fix wording of warning messages.
	(print_command_lines): Print breakpoint commands.
	(execute_control_command): Call commands_from_control_command to
	handle the `commands' command inside a body of a flow-control command.
	(read_next_line): Recognize the `commands' command and build a
	command line structure for it.
	(recurse_read_control_structure, read_command_lines): Handle
	`commands' similarly to `if' and `while'.

	* breakpoint.c (get_number_trailer): Document the special meaning
	of NULL as the first argument PP.
	(commands_from_control_command): New function.

	* breakpoint.h (commands_from_control_command): Add prototype.

	* defs.h (commands_control): New enumerated value for enum
	command_control_type.
@
text
@d1048 1
a1048 1
      saved_frame_id = get_frame_id (deprecated_selected_frame);
d6056 2
a6057 1
  struct frame_info *prev_frame = get_prev_frame (deprecated_selected_frame);
d6093 1
a6093 2
    breakpoint = set_momentary_breakpoint (sal,
					   get_frame_id (deprecated_selected_frame),
@


1.239
log
@2007-01-21  Markus Deuling  <deuling@@de.ibm.com>

	* breakpoint.c (delete_command): Skip redundant loop iterations.
@
text
@d406 2
d652 46
@


1.238
log
@Copyright updates for 2007.
@
text
@d7128 4
a7131 1
	  breaks_to_delete = 1;
@


1.237
log
@        * ada-lang.h (ada_find_printable_frame): Remove.
        (ada_exception_catchpoint_p, ada_decode_exception_location)
        (ada_decode_assert_location): Add declaration.
        * ada-lang.c: Add include of annotate.h and valprint.h.
        (exception_catchpoint_kind): New enum.
        (function_name_from_pc, is_known_support_routine)
        (ada_find_printable_frame, ada_unhandled_exception_name_addr)
        (ada_exception_name_addr_1, ada_exception_name_addr)
        (print_it_exception, print_one_exception, print_mention_exception)
        (print_it_catch_exception, print_one_catch_exception)
        (print_mention_catch_exception, catch_exception_breakpoint_ops)
        (print_it_catch_exception_unhandled)
        (print_one_catch_exception_unhandled)
        (print_mention_catch_exception_unhandled, print_it_catch_assert)
        (print_one_catch_assert, print_mention_catch_assert)
        (ada_exception_catchpoint_p, error_breakpoint_runtime_sym_not_found)
        (ada_get_next_arg, catch_ada_exception_command_split)
        (ada_exception_sym_name, ada_exception_sym_name)
        (ada_exception_breakption_ops, ada_exception_catchpoint_cond_string)
        (ada_parse_catchpoint_condition, ada_exception_sal)
        (ada_decode_exception_location)
        (ada_decode_assert_location): New function.
        (catch_exception_unhandled_breakpoint_ops): New global variable.
        (catch_assert_breakpoint_ops): New global variable.
        * breakpoint.c: Add include of ada-lang.h.
        (print_one_breakpoint): Do not print the condition for Ada
        exception catchpoints.
        (create_ada_exception_breakpoint): New function.
        (catch_ada_exception_command, catch_assert_command): New function.
        (catch_command_1): Add support for the new "catch exception" and
        "catch assert" commands.
        (_initialize_breakpoint): Add help description for the new catch
        commands.
        * Makefile.in (ada-lang.o): Add dependency on annotate.h and
        valprint.h.
        (breakpoint.o): Add dependency on ada-lang.h.
@
text
@d3 2
a4 3
   Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994,
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
   2007
@


1.236
log
@	Warning fixes.
	* ada-lang.c (find_struct_field): Initialize *byte_offset_p.
	* breakpoint.c (do_enable_breakpoint): Ignore both mem_cnt and i.
	* c-typeprint.c (c_type_print_varspec_suffix): Don't test length
	greater than or equal to zero.
	* m2-typeprint.c (m2_array): Likewise.
	* p-typeprint.c (pascal_type_print_varspec_prefix): Likewise.
	* gdbtypes.c (copy_type_recursive): Correct == typo.
	* i386-tdep.c (i386_skip_prologue): Remove stray semicolon.
	* linux-nat.c (linux_nat_info_proc_cmd): Don't compare a pointer
	greater than zero.
	* macroscope.c (sal_macro_scope): Don't name a local variable "main".
	(default_macro_scope): Remove unused variable.
	* prologue-value.h (pv_area_find_reg): Don't name an argument
	"register".
	* remote-fileio.c (remote_fio_func_map): Add missing braces.
	* remote.c (sigint_remote_twice_token, sigint_remote_token): Change
	type.
	(cleanup_sigint_signal_handler): Remove casts.
	* valprint.c (val_print): Use a volatile local for the modified
	argument.
	* varobj.c (languages): Remove extra array dimension.
	(varobj_create): Correct access to languages array.
	* mi/mi-cmd-break.c (mi_cmd_break_insert, mi_cmd_break_watch): Add
	missing braces.
	* mi/mi-cmd-disas.c (mi_cmd_disassemble): Likewise.
	* mi/mi-cmd-env.c (mi_cmd_env_path, mi_cmd_env_dir): Likewise.
	* mi/mi-getopt.c (mi_valid_noargs): Likewise.
	* mi/mi-main.c (mi_cmd_data_read_memory): Likewise.
	(mi_cmd_data_write_memory): Likewise.
	* signals/signals.c (target_signal_to_string): Cast to int before
	comparing.
	* tui/tui-layout.c (init_and_make_win): Take and return a void *.
	Update all callers.
@
text
@d4 2
a5 1
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
d58 1
d3614 1
a3614 1
  if (b->cond)
d3616 3
d6515 80
d6699 9
d8214 5
@


1.235
log
@        * breakpoint.c (remove_breakpoint): Remove dead code.
@
text
@d7602 1
a7602 1
	      (void) mem_cnt, i;
@


1.234
log
@	* breakpoint.c (watchpoint_check): Double-check the found frame.
@
text
@a1639 11
  else if (ep_is_exception_catchpoint (b->owner)
	   && b->inserted	/* sometimes previous insert doesn't happen */
	   && breakpoint_enabled (b->owner)
	   && !b->duplicate)
    {
      val = target_remove_breakpoint (&b->target_info);
      if (val)
	return val;

      b->inserted = (is == mark_inserted);
    }
@


1.233
log
@	* breakpoint.c (insert_bp_location): Add newline to note.
@
text
@d2567 7
@


1.232
log
@2006-11-22  Vladimir Prus  <vladimir@@codesourcery.com>

        * breakpoint.c: Include "memattr.h".
        (automatic_hardware_breakpoints): New.
        (show_automatic_hardware_breakpoints): New.
        (insert_bp_location): Automatically use
        hardware breakpoints.
        (_initialize_breakpoint): Register the "auto-hw"
        variable.
        * Makefile.in (breakpoint.o): Update dependencies.
@
text
@d853 1
a853 1
Note: automatically using hardware breakpoints for read-only addresses."));
@


1.231
log
@2006-10-19  Andrew Stubbs  <andrew.stubbs@@st.com>

	* breakpoint.c (describe_other_breakpoints): Add thread parameter.
	Annotate display with thread number where appropriate.
	(create_breakpoints): Add thread parameter to call to
	describe_other_breakpoints.
@
text
@d56 1
d235 16
d814 51
d1306 3
d8201 14
@


1.230
log
@        * breakpoint.c (free_valchain): Minor reformatting.
@
text
@d105 1
a105 1
static void describe_other_breakpoints (CORE_ADDR, asection *);
d3785 1
a3785 1
describe_other_breakpoints (CORE_ADDR pc, asection *section)
d3805 6
a3810 2
	      printf_filtered ("%d%s%s ",
			       b->number,
d3814 1
a3814 1
				? " (disabled)" 
d4967 1
a4967 1
	  describe_other_breakpoints (sal.pc, sal.section);
@


1.229
log
@        * gdbcore.h (read_memory_nobpt): New function name instead of
        deprecated_read_memory_nobpt.
        * breakpoint.c (read_memory_nobpt): New function name instead
        of deprecated_read_memory_nobpt.
        Adjust calls to old deprecated_read_memory_nobpt accordingly.
        * alpha-tdep.c: Adjust calls to deprecated_read_memory_nobpt
        accordingly.
        * alphanbsd-tdep.c: Likewise.
        * frame.c: Likewise.
        * frv-tdep.c: Likewise.
        * hppa-linux-tdep.c: Likewise.
        * hppa-tdep.c: Likewise.
        * i386-linux-nat.c: Likewise.
        * m68klinux-tdep.c: Likewise.
        * mips-tdep.c: Likewise.
        * s390-tdep.c: Likewise.
@
text
@d752 2
a753 1
static void free_valchain (struct bp_location *b)
@


1.228
log
@	* breakpoint.c (update_breakpoints_after_exec): Fix type mismatch.
@
text
@d642 1
a642 2
deprecated_read_memory_nobpt (CORE_ADDR memaddr, gdb_byte *myaddr,
			      unsigned len)
d704 1
a704 1
	  status = deprecated_read_memory_nobpt (memaddr, myaddr, bp_addr - memaddr);
d712 1
a712 1
	  status = deprecated_read_memory_nobpt (bp_addr + bp_size,
@


1.227
log
@(print_it_typical): Use EXEC_ASYNC_LOCATION_REACHED.
@
text
@d1330 1
a1330 1
	b->loc->address = (CORE_ADDR) NULL;
d1383 1
a1383 1
    b->loc->address = (CORE_ADDR) NULL;
@


1.226
log
@* breakpoint.c (insert_single_step_breakpoint): Make a failure to
insert a single-step breakpoint an error instead of a warning.
* breakpoint.c (remove_single_step_breakpoints): Bail out early if
no breakpoints are inserted.
@
text
@d2331 3
a2333 1
	ui_out_field_string (uiout, "reason", "location-reached");
@


1.226.4.1
log
@Changes from nickrob-async-20060828-mergepoint.
@
text
@d642 2
a643 1
read_memory_nobpt (CORE_ADDR memaddr, gdb_byte *myaddr, unsigned len)
d705 1
a705 1
	  status = read_memory_nobpt (memaddr, myaddr, bp_addr - memaddr);
d713 1
a713 1
	  status = read_memory_nobpt (bp_addr + bp_size,
d1330 1
a1330 1
	b->loc->address = (CORE_ADDR) 0;
d1383 1
a1383 1
    b->loc->address = (CORE_ADDR) 0;
d2331 1
a2331 3
	ui_out_field_string
	  (uiout, "reason",
	   async_reason_lookup (EXEC_ASYNC_LOCATION_REACHED));
@


1.226.2.1
log
@2006-05-02  Michael Snyder  <msnyder@@redhat.com>

	* breakpoint.h (breakpoint_silence): Export.
	* breakpoint.c (breakpoint_silence): New function.
	* infcmd.c (finish_command): Check for reverse exec direction.
	(finish_backward): New function, handle finish cmd in reverse.
	* infrun.c (enum inferior_stop_reason): Add NO_HISTORY reason.
	(handle_inferior_event): Handle TARGET_WAITKIND_NO_HISTORY.
	Handle stepping over a function call in reverse.
	Handle stepping thru a line range in reverse.
	Handle setting a step-resume breakpoint in reverse.
	Handle stepping into a function in reverse.
	Handle stepping between line ranges in reverse.
	(print_stop_reason): Print reason for NO_HISTORY.
@
text
@a7319 7
void
breakpoint_silence (struct breakpoint *b)
{
  /* Silence the breakpoint.  */
  b->silent = 1;
}

@


1.225
log
@gdb/
	* breakpoint.c (deprecated_read_memory_nobpt): Update to use
	shadow_len.
	(insert_bp_location, reattach_breakpoints, remove_breakpoint)
	(delete_breakpoint): Update calls to changed methods.
	(deprecated_insert_raw_breakpoint, deprecated_remove_raw_breakpoint)
	(single_step_breakpoints, insert_single_step_breakpoint)
	(remove_single_step_breakpoints): New.
	* breakpoint.h (struct bp_target_info): New.
	(struct bp_location): Replace shadow_contents with
	target_info and overlay_target_info.
	(deprecated_insert_raw_breakpoint, deprecated_remove_raw_breakpoint)
	(insert_single_step_breakpoint, remove_single_step_breakpoints): New
	prototypes.
	* gdbarch.sh: Forward declare struct bp_target_info in gdbarch.h.
	(memory_insert_breakpoint, memory_remove_breakpoint): Update second
	argument.
	* mem-break.c (default_memory_insert_breakpoint): Update.  Set
	placed_address, placed_size, and shadow_len.
	(default_memory_remove_breakpoint): Update.  Don't use
	BREAKPOINT_FROM_PC.
	(memory_insert_breakpoint, memory_remove_breakpoint): Update.
	* target.c (update_current_target): Update prototypes for changed
	functions.
	(debug_to_insert_breakpoint, debug_to_remove_breakpoint)
	(debug_to_insert_hw_breakpoint, debug_to_remove_hw_breakpoint):
	Update.
	* target.h: Forward declare struct bp_target_info.
	(struct target_ops): Use a bp_target_info argument for
	to_insert_breakpoint, to_remove_breakpoint,
	to_insert_hw_breakpoint, and to_remove_hw_breakpoint.
	(target_insert_breakpoint, target_remove_breakpoint)
	(target_insert_hw_breakpoint, target_remove_hw_breakpoint)
	(memory_insert_breakpoint, memory_remove_breakpoint)
	(default_memory_insert_breakpoint, default_memory_remove_breakpoint):
	Update.
	* config/i386/nm-i386.h: Forward declare struct bp_target_info.
	(i386_insert_hw_breakpoint, i386_remove_hw_breakpoint): Update.
	(target_insert_hw_breakpoint, target_remove_hw_breakpoint): Likewise.

	* gdbarch.c, gdbarch.h: Regenerated.

	* alpha-tdep.c (alpha_software_single_step): Use
	insert_single_step_breakpoint and remove_single_step_breakpoints.
	Remove unused statics.
	* arm-tdep.c (arm_software_single_step): Likewise.  Add a note.
	* cris-tdep.c (cris_software_single_step): Likewise.
	* mips-tdep.c (mips_software_single_step): Likewise.
	* rs6000-tdep.c (rs6000_software_single_step): Likewise.
	* sparc-tdep.c (sparc_software_single_step): Likewise.
	* wince.c (struct thread_info_struct): Remove step_prev.
	(undoSStep): Use remove_single_step_breakpoints.
	(wince_software_single_step): Use insert_single_step_breakpoint.

	* corelow.c (ignore): Remove unneeded prototype.  Update arguments.
	* exec.c (ignore): Likewise.
	* sol-thread.c (ignore): Likewise.

	* procfs.c (dbx_link_shadow_contents): Delete.
	(dbx_link_bpt): New.
	(procfs_mourn_inferior): Remove it if necessary.
	(remove_dbx_link_breakpoint): Use it.
	(insert_dbx_link_bpt_in_file): Set it.
	(procfs_init_inferior): Don't update dbx_link_bpt_addr.
	* rs6000-nat.c (exec_one_dummy_insn): Use
	deprecated_insert_raw_breakpoint and
	deprecated_remove_raw_breakpoint.
	* solib-irix.c (shadow_contents, breakpoint_addr): Delete.
	(base_breakpoint): New.
	(disable_break): Use it.
	(enable_break): Set it.

	* i386-nat.c (i386_insert_hw_breakpoint, i386_remove_hw_breakpoint):
	Update.
	* ia64-tdep.c (ia64_memory_insert_breakpoint)
	(ia64_memory_remove_breakpoint): Likewise.
	* m32r-tdep.c (m32r_memory_insert_breakpoint)
	(m32r_memory_remove_breakpoint): Likewise.
	* monitor.c (monitor_insert_breakpoint, monitor_remove_breakpoint):
	Likewise.  Remove unnecessary prototypes.  Use placed_address
	and placed_size.  Removed useless read from memory.
	* nto-procfs.c (procfs_insert_breakpoint)
	(procfs_remove_breakpoint, procfs_insert_hw_breakpoint)
	(procfs_remove_hw_breakpoint): Update.
	* ocd.c (ocd_insert_breakpoint, ocd_remove_breakpoint): Likewise.
	* ocd.h (ocd_insert_breakpoint, ocd_remove_breakpoint): Likewise.
	* ppc-linux-tdep.c (ppc_linux_memory_remove_breakpoint): Likewise.
	* ppc-tdep.h (ppc_linux_memory_remove_breakpoint): Likewise.
	* remote-e7000.c (e7000_insert_breakpoint)
	(e7000_remove_breakpoint): Likewise.
	* remote-m32r-sdi.c (m32r_insert_breakpoint)
	(m32r_remove_breakpoint): Likewise.
	* remote-mips.c (mips_insert_breakpoint)
	(mips_remove_breakpoint): Likewise.
	* remote-rdp.c (remote_rdp_insert_breakpoint)
	(remote_rdp_remove_breakpoint): Likewise.
	(rdp_step): Use deprecated_insert_raw_breakpoint and
	deprecated_remove_raw_breakpoint.
	* remote-sds.c (sds_insert_breakpoint, sds_remove_breakpoint):
	Update.
	* remote-sim.c (gdbsim_insert_breakpoint, gdbsim_remove_breakpoint):
	Delete.
	(init_gdbsim_ops): Use memory_insert_breakpoint and
	memory_remove_breakpoint.
	* remote-st.c (st2000_insert_breakpoint)
	(st2000_remove_breakpoint): Update.  Remove unused
	BREAKPOINT_FROM_PC.
	* remote.c (remote_insert_breakpoint, remote_remove_breakpoint):
	Update.  Use placed_address and placed_size.
	(remote_insert_hw_breakpoint, remote_remove_hw_breakpoint): Likewise.
gdb/doc/
	* gdbint.texinfo (x86 Watchpoints, Target Conditionals): Update insert
	and remove breakpoint prototypes.
	(Watchpoints): Move description of target_insert_hw_breakpoint and
	target_remove_hw_breakpoint ...
	(Breakpoints): ... to here.  Document target_insert_breakpoint and
	target_remove_breakpoint.
@
text
@d7720 1
a7720 1
    warning (_("Could not insert single-step breakpoint at 0x%s"),
@


1.224
log
@        * breakpoint.c (_initialize_breakpoint): Add "del" as an alias
        of the "delete" command.
@
text
@d666 2
a667 8
    /* XXXX The m68k, sh and h8300 have different local and remote
       breakpoint values.  BREAKPOINT_FROM_PC still manages to
       correctly determine the breakpoints memory address and size
       for these targets. */
    bp_addr = b->address;
    bp_size = 0;
    if (BREAKPOINT_FROM_PC (&bp_addr, &bp_size) == NULL)
      continue;
d669 1
a669 1
      /* bp isn't valid */
d700 1
a700 1
	      b->shadow_contents + bptoffset, bp_size);
d790 4
d805 1
a805 2
	    val = target_insert_hw_breakpoint (bpt->address, 
					       bpt->shadow_contents);
d807 1
a807 2
	    val = target_insert_breakpoint (bpt->address,
					    bpt->shadow_contents);
d826 3
a828 1
		  val = target_insert_breakpoint (addr, bpt->shadow_contents);
d840 1
a840 2
		val = target_insert_hw_breakpoint (bpt->address, 
						   bpt->shadow_contents);
d842 1
a842 2
		val = target_insert_breakpoint (bpt->address,
						bpt->shadow_contents);
d1044 1
a1044 1
      val = target_insert_breakpoint (bpt->address, bpt->shadow_contents);
d1239 1
a1239 1
	  val = target_insert_hw_breakpoint (b->address, b->shadow_contents);
d1241 1
a1241 1
	  val = target_insert_breakpoint (b->address, b->shadow_contents);
d1445 1
a1445 2
	    val = target_remove_hw_breakpoint (b->address, 
					       b->shadow_contents);
d1447 1
a1447 1
	    val = target_remove_breakpoint (b->address, b->shadow_contents);
a1457 2
		CORE_ADDR addr = overlay_unmapped_address (b->address, 
							   b->section);
d1461 1
a1461 1
		  target_remove_hw_breakpoint (addr, b->shadow_contents);
d1463 1
a1463 1
		  target_remove_breakpoint (addr, b->shadow_contents);
d1474 1
a1474 2
		val = target_remove_hw_breakpoint (b->address, 
						   b->shadow_contents);
d1476 1
a1476 2
		val = target_remove_breakpoint (b->address,
						b->shadow_contents);
d1564 1
a1564 2

      val = target_remove_breakpoint (b->address, b->shadow_contents);
d1574 1
a1574 2

      val = target_remove_breakpoint (b->address, b->shadow_contents);
d6844 2
d6847 1
a6847 1
	    val = target_insert_hw_breakpoint (b->loc->address, b->loc->shadow_contents);
d6849 1
a6849 1
	    val = target_insert_breakpoint (b->loc->address, b->loc->shadow_contents);
d7652 91
@


1.223
log
@(print_one_breakpoint): Add break to case
bp_catch_vfork in switch statement.
@
text
@d7816 1
@


1.223.2.1
log
@Merge XML and VFP support to this branch.
@
text
@d935 1
a935 1
      saved_frame_id = get_frame_id (get_selected_frame (NULL));
d5942 1
a5942 1
  struct frame_info *prev_frame = get_prev_frame (get_selected_frame (NULL));
d5979 1
a5979 1
					   get_frame_id (get_selected_frame (NULL)),
@


1.223.2.2
log
@	* gdb/breakpoint.c (insert_bp_location): Remember the failing
	watchpoint address and pass to remove_breakpoint.
	(remove_breakpoints, remove_hw_watchpoints, reattach_breakpoints,
	detach_breakpoints): Adjust remove_breakpoint call.
	(remove_breakpoint): Add VAL_FAILED parameter.  Stop removing
	watchpoint addresses when it is reached.
	(delete_breakpoint): Adjust remove_breakpoint call.
@
text
@d132 1
a132 2
static int remove_breakpoint (struct bp_location *, insertion_state_t,
			      struct value *);
a950 1
	  struct value *val_failed = NULL;
d998 7
a1004 2
			  val_failed = v;
			  break;
d1012 1
a1012 1
	  if (val_failed)
d1014 1
a1014 2
	      remove_breakpoint (bpt, mark_uninserted, val_failed);
	      bpt->inserted = 0;
d1202 1
a1202 1
	val = remove_breakpoint (b, mark_uninserted, NULL);
d1220 1
a1220 1
	val = remove_breakpoint (b, mark_uninserted, NULL);
d1241 1
a1241 1
	remove_breakpoint (b, mark_inserted, NULL);
d1409 1
a1409 1
	val = remove_breakpoint (b, mark_inserted, NULL);
a1420 4
/* Remove the breakpoints for B.  FAILED_VAL, if non-null is the value
   in the bpt->owner->val_chain that failed to be inserted.  We stop
   at that point.  */

d1422 1
a1422 2
remove_breakpoint (struct bp_location *b, insertion_state_t is,
		   struct value *val_failed)
d1506 1
a1506 1
      for (v = b->owner->val_chain; v != val_failed; v = value_next (v))
d6778 1
a6778 1
    remove_breakpoint (bpt->loc, mark_inserted, NULL);
@


1.223.2.3
log
@	* gdb/remote.c (remote_insert_watchpoint): Return -1, rather than
	fatal error if packet is disabled.
	(remote_remove_watchpoint, remote_insert_hw_breakpoint,
	remote_remove_hw_breakpoint): Likewise.
	Revert my 2006-06-01  Nathan Sidwell  <nathan@@codesourcery.com>
	change to breakpoint.c
@
text
@d132 2
a133 1
static int remove_breakpoint (struct bp_location *, insertion_state_t);
d952 1
d1000 2
a1001 7
			  /* Don't exit the loop, try to insert
			     every value on the value chain.  That's
			     because we will be removing all the
			     watches below, and removing a
			     watchpoint we didn't insert could have
			     adverse effects.  */
			  bpt->inserted = 0;
d1009 1
a1009 1
	  if (!bpt->inserted)
d1011 2
a1012 1
	      remove_breakpoint (bpt, mark_uninserted);
d1200 1
a1200 1
	val = remove_breakpoint (b, mark_uninserted);
d1218 1
a1218 1
	val = remove_breakpoint (b, mark_uninserted);
d1239 1
a1239 1
	remove_breakpoint (b, mark_inserted);
d1407 1
a1407 1
	val = remove_breakpoint (b, mark_inserted);
d1419 4
d1424 2
a1425 1
remove_breakpoint (struct bp_location *b, insertion_state_t is)
d1509 1
a1509 1
      for (v = b->owner->val_chain; v; v = value_next (v))
d6781 1
a6781 1
    remove_breakpoint (bpt->loc, mark_inserted);
@


1.223.2.1.2.1
log
@Merge to branch:
  http://sourceware.org/ml/gdb-patches/2006-04/msg00139.html
@
text
@d807 2
a808 1
	    val = target_insert_hw_breakpoint (bpt->address, bpt);
d810 2
a811 1
	    val = target_insert_breakpoint (bpt->address, bpt);
d830 1
a830 1
		  val = target_insert_breakpoint (addr, bpt);
d842 2
a843 1
		val = target_insert_hw_breakpoint (bpt->address, bpt);
d845 2
a846 1
		val = target_insert_breakpoint (bpt->address, bpt);
d1048 1
a1048 1
      val = target_insert_breakpoint (bpt->address, bpt);
d1243 1
a1243 1
	  val = target_insert_hw_breakpoint (b->address, b);
d1245 1
a1245 1
	  val = target_insert_breakpoint (b->address, b);
d1449 2
a1450 1
	    val = target_remove_hw_breakpoint (b->address, b);
d1452 1
a1452 1
	    val = target_remove_breakpoint (b->address, b);
d1468 1
a1468 1
		  target_remove_hw_breakpoint (addr, b);
d1470 1
a1470 1
		  target_remove_breakpoint (addr, b);
d1481 2
a1482 1
		val = target_remove_hw_breakpoint (b->address, b);
d1484 2
a1485 1
		val = target_remove_breakpoint (b->address, b);
d1573 2
a1574 1
      val = target_remove_breakpoint (b->address, b);
d1584 2
a1585 1
      val = target_remove_breakpoint (b->address, b);
d6856 1
a6856 1
	    val = target_insert_hw_breakpoint (b->loc->address, b->loc);
d6858 1
a6858 1
	    val = target_insert_breakpoint (b->loc->address, b->loc);
a7660 103

/* Create and insert a raw software breakpoint at PC.  This is the only place
   besides set_raw_breakpoint that allocates a breakpoint; it should be
   eliminated someday.  */

struct breakpoint *
deprecated_insert_raw_breakpoint (CORE_ADDR pc)
{
  struct breakpoint *b;

  b = xmalloc (sizeof (struct breakpoint));
  memset (b, 0, sizeof (struct breakpoint));

  b->loc = xmalloc (sizeof (struct bp_location));
  memset (b->loc, 0, sizeof (struct bp_location));
  b->loc->owner = b;
  b->loc->loc_type = bp_loc_software_breakpoint;

  /* We don't bother with adjust_breakpoint_address here, but it
     would presumably be harmless to do so.  */
  b->loc->requested_address = pc;
  b->loc->address = b->loc->requested_address;

  b->type = bp_breakpoint;
  b->thread = -1;
  b->enable_state = bp_enabled;

  if (target_insert_breakpoint (b->loc->address, b->loc) != 0)
    {
      /* Could not insert the breakpoint.  */
      xfree (b->loc);
      xfree (b);
      return NULL;
    }

  return b;
}

/* Remove a breakpoint B inserted by deprecated_insert_raw_breakpoint.  */

int
deprecated_remove_raw_breakpoint (struct breakpoint *b)
{
  int ret;

  ret = target_remove_breakpoint (b->loc->address, b->loc);
  xfree (b->loc);
  xfree (b);

  return ret;
}

/* One (or perhaps two) breakpoints used for software single stepping.  */

static struct breakpoint *single_step_breakpoints[2];

/* Create and insert a breakpoint for software single step.  */

void
insert_single_step_breakpoint (CORE_ADDR next_pc)
{
  struct breakpoint **bpt_p;

  if (single_step_breakpoints[0] == NULL)
    bpt_p = &single_step_breakpoints[0];
  else
    {
      gdb_assert (single_step_breakpoints[1] == NULL);
      bpt_p = &single_step_breakpoints[1];
    }

  /* NOTE drow/2006-04-11: A future improvement to this function would be
     to only create the breakpoints once, and actually put them on the
     breakpoint chain.  That would let us use set_raw_breakpoint.  We could
     adjust the addresses each time they were needed.  Doing this requires
     corresponding changes elsewhere where single step breakpoints are
     handled, however.  So, for now, we use this.  */

  *bpt_p = deprecated_insert_raw_breakpoint (next_pc);
  if (*bpt_p == NULL)
    warning (_("Could not insert single-step breakpoint at 0x%s"),
	     paddr_nz (next_pc));
}

/* Remove and delete any breakpoints used for software single step.  */

void
remove_single_step_breakpoints (void)
{
  gdb_assert (single_step_breakpoints[0] != NULL);

  /* See insert_single_step_breakpoint for more about this deprecated
     call.  */
  deprecated_remove_raw_breakpoint (single_step_breakpoints[0]);
  single_step_breakpoints[0] = NULL;

  if (single_step_breakpoints[1] != NULL)
    {
      deprecated_remove_raw_breakpoint (single_step_breakpoints[1]);
      single_step_breakpoints[1] = NULL;
    }
}

@


1.223.4.1
log
@Add a Debian patch that prevents some bogus "No selected frame" errors.
This needs to go to mainline separately.
@
text
@d935 1
a935 1
      saved_frame_id = get_frame_id (get_selected_frame (NULL));
d5942 1
a5942 1
  struct frame_info *prev_frame = get_prev_frame (get_selected_frame (NULL));
d5979 1
a5979 1
					   get_frame_id (get_selected_frame (NULL)),
@


1.223.6.1
log
@2006-03-31  Michael Snyder  <msnyder@@redhat.com>

	Execution interface for reverse execution.
	* breakpoint.c (breakpoint_silence): New function.
	* breakpoint.h (breakpoint_silence): Export.
	* infcmd.c (finish_command): Check for reverse exec direction.
	(finish_backward): New function, handle finish cmd in reverse.
	* infrun.c (enum inferior_stop_reason): Add NO_HISTORY reason.
	(handle_inferior_event): Handle TARGET_WAITKIND_NO_HISTORY.
	Handle stepping over a function call in reverse.
	Handle stepping thru a line range in reverse.
	Handle setting a step-resume breakpoint in reverse.
	Handle stepping into a function in reverse.
	Handle stepping between line ranges in reverse.
	(print_stop_reason): Print reason for NO_HISTORY.
@
text
@a7328 7
void
breakpoint_silence (struct breakpoint *b)
{
  /* Silence the breakpoint.  */
  b->silent = 1;
}

@


1.222
log
@	* breakpoint.c (TARGET_REGION_OK_FOR_HW_WATCHPOINT): Delete.
	* config/i386/nm-i386sol2.h (TARGET_REGION_OK_FOR_HW_WATCHPOINT): New.
	(TARGET_REGION_SIZE_OK_FOR_HW_WATCHPOINT): Delete.
	* config/mips/nm-irix5.h (TARGET_REGION_OK_FOR_HW_WATCHPOINT): New.
	(TARGET_REGION_SIZE_OK_FOR_HW_WATCHPOINT): Delete.
	* config/sparc/nm-sol2.h (TARGET_REGION_OK_FOR_HW_WATCHPOINT): New.
	(TARGET_REGION_SIZE_OK_FOR_HW_WATCHPOINT): Delete.
	* inf-ttrace.c (inf_ttrace_region_ok_for_hw_watchpoint): New.
	(inf_ttrace_region_size_ok_for_hw_watchpoint): Delete.
	(inf_ttrace_target): Delete to_region_size_ok_for_hw_watchpoint and
	add to_region_ok_for_hw_watchpoint.
	* s390-nat.c (s390_region_size_ok_for_hw_watchpoint): Delete.
	(s390_region_ok_for_hw_watchpoint): New.
	(_initialize_s390_nat): Delete to_region_size_ok_for_hw_watchpoint
	and add to_region_ok_for_hw_watchpoint.
	* target.c (default_region_size_ok_for_hw_watchpoint,
	debug_to_region_size_ok_for_hw_watchpoint): Delete prototype.
	(update_current_target): Delete to_region_size_ok_for_hw_watchpoint
	inheritance and default_region_size_ok_for_hw_watchpoint.
	(default_region_ok_for_hw_watchpoint): If len is less than or equal
	the length of void pointer, return ok.
	(default_region_size_ok_for_hw_watchpoint): Delete.
	(debug_to_region_size_ok_for_hw_watchpoint): Delete.
	(setup_target_debug): Delete to_region_size_ok_for_hw_watchpoint.
	* target.h (struct target_ops): Delete
	to_region_size_ok_for_hw_watchpoint.
	(TARGET_REGION_SIZE_OK_FOR_HW_WATCHPOINT): Delete.
@
text
@d3435 1
@


1.221
log
@From Vladimir Prus  <ghost@@cs.msu.su>:
gdb/
	* breakpoint.c (print_one_breakpoint): For MI-like UI, output
	fullname field.
gdb/doc/
	* gdb.texinfo (Breakpoint table commands): Document the fullname
	field in -break-list output.
gdb/testsuite/
	* gdb.mi/mi-break.exp, gdb.mi/mi2-break.exp: Test for the fullname
	field.
@
text
@a5809 5
#if !defined(TARGET_REGION_OK_FOR_HW_WATCHPOINT)
#define TARGET_REGION_OK_FOR_HW_WATCHPOINT(ADDR,LEN) \
     (TARGET_REGION_SIZE_OK_FOR_HW_WATCHPOINT(LEN))
#endif

@


1.220
log
@2006-01-16  Andrew Stubbs  <andrew.stubbs@@st.com>

	* breakpoint.c (insert_breakpoints): Check that a thread exists
	before inserting thread specific breakpoints.
@
text
@d4 1
a4 1
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
d3509 10
@


1.219
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d1145 6
@


1.218
log
@2005-12-02  Andrew Stubbs  <andrew.stubbs@@st.com>

	* breakpoint.c (BREAK_ARGS_HELP): New mecro.
	(_initialize_breakpoint): Enhance break, tbreak, hbreak and thbreak
	commands' help by adding more information and using BREAK_ARGS_HELP
	to duplicate the common parts.  Remove now-redundant cross-references.

testsuite/
	* gdb.base/help.exp (help b, help br, help bre, help brea)
	(help break): Update the expected message.
@
text
@d3 1
a3 1
   Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994,
d21 2
a22 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.217
log
@This is a cleanup change. It is the beggining of allowing GDB/MI to be
better understood (internally).
@
text
@d7650 19
d7704 1
a7704 1
Set a temporary breakpoint.  Args like \"break\" command.\n\
d7707 3
a7709 1
by using \"enable delete\" on the breakpoint number."));
d7713 1
a7713 1
Set a hardware assisted  breakpoint. Args like \"break\" command.\n\
d7715 3
a7717 1
some target hardware may not have this support."));
d7721 1
a7721 1
Set a temporary hardware assisted breakpoint. Args like \"break\" command.\n\
d7723 3
a7725 1
so it will be deleted when hit."));
d7830 2
a7831 11
Set breakpoint at specified line or function.\n\
Argument may be line number, function name, or \"*\" and an address.\n\
If line number is specified, break at start of code for that line.\n\
If function is specified, break at start of code for that function.\n\
If an address is specified, break at that exact address.\n\
With no arg, uses current execution address of selected stack frame.\n\
This is useful for breaking on return to a stack frame.\n\
\n\
Multiple breakpoints at one place are permitted, and useful if conditional.\n\
\n\
Do \"help breakpoints\" for info on other commands dealing with breakpoints."));
@


1.217.2.1
log
@2005-05-30  Michael Snyder  <msnyder@@redhat.com>

	Add support for writing tracepoint/checkpoint data to a file.

	* breakpoint.c (bpstat_stop_status): Add hook for interpreting
	breakpoints as tracepoints, enabling gdb to handle them directly
	by a "default" fallback method (writing data to a file).

	* tracepoint.c (default_tracepoint_method): New user-settable
	mode variable -- tells gdb to use a "default" (fallback) method
	for collecting tracepoint data.
	(trace_start_command, trace_stop_command, trace_status_command):
	Add "default" mode.

	(tracepoint_event_p, default_do_tracepoints_command): New
	functions, entry points into default tracepoint collection method.

	(checkpoint_open, checkpoint_close): Open / close checkpoint file.
	(checkpoint_command): Drop a checkpoint into checkpoint file.

	(emit_checkpoint_method1, emit_checkpoint_method2,
	emit_checkpoint_method3, emit_checkpoint_method4): Experimental
	methods for writing checkpoint/tracepoint data to a file.

	(checkpoint_emit_memrange, checkpoint_emit_gregs,
	checkpoint_emit_stack, checkpoint_emit_id, etc.):
	Support functions for writing checkpoint/tracepoint data.

	(get_tracepoint_by_address): New function.
	(validate_actionline): Add "$stack" pseudo-object for collection.
	(tracepoint_top_of_stack, tracepoint_size_of_stack):
	New user-settable variables.
	(encode_actions): Interpret "$stack" pseudo-object, collect stack.

	* tracepoint.h (default_trace_method, tracepoint_event_p):
	Exported interface for default tracepoint method.
@
text
@a28 1
#include "tracepoint.h"	/* for default tracepoint method */
a2843 8
    /* tracepoint */
    /* OK -- if we put the action here, it means we will
       check for a tracepoint if a watchpoint has triggered, 
       or if we have a breakpoint at the current PC.  By
       checking now, we will NOT honor the breakpoint's 
       condition if any.  We would do that later.  */


d2883 9
a2891 5
	    /* tracepoint */
	    /* If we put the check here, we can honor the breakpoint's
	       condition and/or ignore-count and/or thread, if any.  */

	    if (default_trace_method && tracepoint_event_p ())
d2893 1
a2893 3
		/* This breakpoint has been handled as a tracepoint.
		   Don't stop.  */
		bs->stop = 0;
a2894 20
		/* hit_count -- should we consider this a hit?  */
	      }
	    else
	      {
		/* Not tracepoint -- back to your regularly scheduled
		   breakpoint handling.  */
		/* We will stop here */
		if (b->disposition == disp_disable)
		  b->enable_state = bp_disabled;
		if (b->silent)
		  bs->print = 0;
		bs->commands = b->commands;
		if (bs->commands &&
		    (strcmp ("silent", bs->commands->line) == 0
		     || (xdb_commands && strcmp ("Q", bs->commands->line) == 0)))
		  {
		    bs->commands = bs->commands->next;
		    bs->print = 0;
		  }
		bs->commands = copy_command_lines (bs->commands);
d2896 1
@


1.216
log
@2005-05-26  Andrew Cagney  <cagney@@gnu.org>

	* command.h (add_setshow_integer_cmd): Make VAR an integer.
	* cli/cli-decode.c (add_setshow_integer_cmd): Update to match.
	* valops.c (value_string): Add a cast.
	* eval.c (evaluate_subexp_standard): Use gdb_byte for byte buffers.
	* breakpoint.c (re_enable_breakpoints_in_shlibs): Use gdb_byte for
	byte buffers.
	* target.h (struct target_ops): For to_insert_hw_breakpoint and
	to_remove_hw_breakpoint use gdb_byte for byte buffer parameters.
	* breakpoint.h (struct bp_location): Make shadow_contents a
	gdb_byte buffer.
	* cli/cli-setshow.c (do_setshow_command): Fix cast.
	* cli/cli-dump.c (restore_section_callback)
	(restore_binary_file): Use gdb_byte for byte buffers.
	* proc-service.c (ps_ptwrite, ps_ptread, ps_pdwrite): Fix casts.
	(ps_xfer_memory): Use gdb_byte for byte buffers.
	* tracepoint.c (mem2hex): Use gdb_byte for byte buffers, and char
	for string buffers.
	* ser-tcp.c (net_open): Make len a socklen_t.
@
text
@d58 1
d2118 2
a2119 1
	ui_out_field_string (uiout, "reason", "breakpoint-hit");
d2254 3
a2256 1
	    ui_out_field_string (uiout, "reason", "watchpoint-trigger");
d2276 3
a2278 1
	ui_out_field_string (uiout, "reason", "read-watchpoint-trigger");
d2294 3
a2296 1
	    ui_out_field_string (uiout, "reason", "access-watchpoint-trigger");
d2310 3
a2312 1
	    ui_out_field_string (uiout, "reason", "access-watchpoint-trigger");
d2328 3
a2330 1
	ui_out_field_string (uiout, "reason", "function-finished");
d2560 2
a2561 1
	ui_out_field_string (uiout, "reason", "watchpoint-scope");
@


1.215
log
@2005-05-22  Andrew Cagney  <cagney@@gnu.org>

	* frame.h (frame_register_unwind, frame_unwind_register)
	(get_frame_register, frame_register, put_frame_register)
	(get_frame_memory, safe_frame_unwind_memory)
	(frame_register_read): Use gdb_byte for byte buffer parameters.
	* trad-frame.h (trad_frame_get_register)
	(frame_get_prev_register): Ditto.
	* frame-unwind.h (frame_prev_register_ftype): Ditto.
	* frame.c (frame_pop, frame_register, frame_unwind_register)
	(get_frame_register, frame_unwind_register_signed)
	(frame_unwind_register_unsigned, frame_unwind_unsigned_register)
	(frame_register_read, get_frame_memory): Update.
	* trad-frame.c (trad_frame_get_prev_register): Update.
	(trad_frame_get_register): Update.
	* gdbcore.h (deprecated_read_memory_nobpt, read_memory): Ditto.
	* breakpoint.c (deprecated_read_memory_nobpt): Update.
	* corefile.c (read_memory): Update.
	* tramp-frame.c (tramp_frame_prev_register): Update.
	* valops.c (value_assign): Update.
	* sentinel-frame.c (sentinel_frame_prev_register): Update.
	* std-regs.c (value_of_builtin_frame_fp_reg)
	(value_of_builtin_frame_pc_reg): Update.
	* infcmd.c (default_print_registers_info): Update
	* dummy-frame.c (dummy_frame_prev_register): Update.
	* findvar.c (value_of_register, value_from_register): Update.
	* tui/tui-regs.c (tui_register_format, tui_get_register): Update.
	* mi/mi-main.c (register_changed_p, get_register): Update.
@
text
@d4444 2
a4445 1
	char buf[1], *lib;
@


1.214
log
@* solib.h (CLEAR_SOLIB, SOLIB_ADD)
(SOLIB_CREATE_INFERIOR_HOOK, SOLIB_REMOVE_INFERIOR_HOOK)
(SOLIB_IN_DYNAMIC_LINKER, SOLIB_RESTART)
(DISABLE_UNSETTABLE_BREAK, PC_SOLIB)
(IN_SOLIB_DYNSYM_RESOLVE_CODE): Remove defines and orphaned
comments.
* breakpoint.c: Include "solib.h".
(insert_bp_location) [!DISABLE_UNSETTABLE_BREAK]: Call
solib_address.
(remove_solib_event_breakpoints, create_solib_event_breakpoint)
(disable_breakpoints_in_shlibs)
(disable_breakpoints_in_unloaded_shlib)
(re_enable_breakpoints_in_shlibs): Compile if SOLIB_ADD isn't
defined. If PC_SOLIB isn't defined, call solib_address.
(_initialize_breakpoint): Unconditionally install observer.
* corelow.c: Include "solib.h".
[SOLIB_ADD] (solib_add_stub): Remove prototype.
(core_close) [!CLEAR_SOLIB]: Call clear_solib.
(solib_add_stub) [!SOLIB_ADD] Call solib_add.
(core_open): Unconditionally call solib_add_stub.
* fork-child.c: Include "solib.h".
(fork_inferior) [!SOLIB_CREATE_INFERIOR_HOOK]: Call
solib_create_inferior_hook.
* infcmd.c: Include "solib.h".
(attach_command) [!SOLIB_ADD]: Call shlib_rescan.  Unconditionally
call re_enable_breakpoints_in_shlibs.
* infrun.c: Include "solib.h".
(SOLIB_IN_SYNSYM_RESOLVE_CODE): Don't define if not already
defined.
(stop_on_solib_events, show_stop_on_solib_events): Include
unconditionally.
(follow_exec) [!SOLIB_CREATE_INFERIOR_HOOK]: Call
solib_create_inferior_hook.
(handle_inferior_event) [!SOLIB_ADD]: Call shlib_add.
[!IN_SOLIB_DYNSYM_RESOLVE_CODE]: Call in_solib_dynsym_resolve_code.
(_initialize_infrun): Unconditionally add "stop_on_solib-events"
command.
* remote.c: Include "solib.h".
(remote_open_1): Unconditionally call no_shared_libraries.
[!SOLIB_CREATE_INFERIOR_HOOK] Call solib_create_inferior_hook.
* stack.c: Include "solib.h".
(print_frame) [!PC_SOLIB] Call shlib_for_pc.
* xcoffsolib.c (no_shared_libraries): Remove function.
* Makefile.in (SFILES): Add solib.c.
(ALLDEPFILES): Remove solib.c.
(COMMON_OBS): Add solib.o.
(breakpoint.o, corelow.o, fork-chiled.o, infcmd.o, infrun.o)
(remote.o, stack.o): Update dependencies.
@
text
@d641 2
a642 1
deprecated_read_memory_nobpt (CORE_ADDR memaddr, char *myaddr, unsigned len)
@


1.213
log
@2005-04-26  Andrew Cagney  <cagney@@gnu.org>

	Rename 'struct exception' to 'struct gdb_exception'.
	* wrapper.c: Update.
	* varobj.c: Update.
	* tui/tui-interp.c: Update.
	* remote.c: Update.
	* mi/mi-main.c: Update.
	* mi/mi-interp.c: Update.
	* linux-thread-db.c: Update.
	* interps.h: Update.
	* interps.c: Update.
	* exceptions.h: Update.
	* exceptions.c: Update.
	* dwarf2loc.c: Update.
	* cli/cli-interp.c: Update.
	* cli/cli-script.c: Update.
	* breakpoint.c: Update.
@
text
@d52 1
d857 1
d859 5
a863 1
	  if (DISABLE_UNSETTABLE_BREAK (bpt->address))
a880 1
#endif
a4337 1
#ifdef SOLIB_ADD
d4369 8
a4376 6
#if defined (PC_SOLIB)
    if (((b->type == bp_breakpoint) ||
	 (b->type == bp_hardware_breakpoint)) &&
	breakpoint_enabled (b) &&
	!b->loc->duplicate &&
	PC_SOLIB (b->loc->address))
a4389 1
#endif
a4401 1
#if defined (PC_SOLIB)
d4407 1
a4407 2
	&& breakpoint_enabled (b) 
	&& !b->loc->duplicate)
d4409 1
d4411 4
a4414 2
	if (so_name 
	    && !strcmp (so_name, solib->so_name))
a4430 1
#endif
d4445 3
a4447 2
	/* Do not reenable the breakpoint if the shared library
	   is still not mapped in.  */
d4449 3
a4462 2
#endif

a7641 1
#ifdef SOLIB_ADD
a7642 1
#endif
@


1.212
log
@2005-02-24  Andrew Cagney  <cagney@@gnu.org>

	Add show_VARIABLE functions, update add_setshow call.
	* varobj.c (_initialize_varobj, show_varobjdebug): Add and update.
	* valprint.c (_initialize_valprint, show_print_max)
	(show_stop_print_at_null, show_repeat_count_threshold)
	(show_prettyprint_structs, show_unionprint)
	(show_prettyprint_arrays, show_addressprint, show_input_radix)
	(show_output_radix): Ditto.
	* valops.c (_initialize_valops, show_overload_resolution): Ditto.
	* utils.c (initialize_utils, show_chars_per_line)
	(show_lines_per_page, show_demangle, show_pagination_enabled)
	(show_sevenbit_strings, show_asm_demangle): Ditto
	* tui/tui-win.c (_initialize_tui_win, show_tui_border_kind)
	(show_tui_border_mode, show_tui_active_border_mode): Ditto.
	* top.c (init_main, show_new_async_prompt)
	(show_async_command_editing_p, show_write_history_p)
	(show_history_size, show_history_filename, show_caution)
	(show_annotation_level, init_main): Ditto.
	* target.c (initialize_targets, show_targetdebug)
	(show_trust_readonly): Ditto.
	* symfile.c (_initialize_symfile, show_symbol_reloading)
	(show_ext_args, show_download_write_size)
	(show_debug_file_directory): Ditto.
	* source.c (_initialize_source, show_lines_to_list): Ditto.
	* solib.c (_initialize_solib, show_auto_solib_add)
	(show_solib_search_path): Ditto.
	* p-valprint.c (_initialize_pascal_valprint)
	(show_pascal_static_field_print): Ditto.
	* printcmd.c (_initialize_printcmd, show_max_symbolic_offset)
	(show_print_symbol_filename): Add and update.
	* parse.c (_initialize_parse, show_expressiondebug): Dito.
	* observer.c (_initialize_observer, show_observer_debug): Dito.
	* maint.c (_initialize_maint_cmds, show_watchdog)
	(show_maintenance_profile_p): Dito.
	* linux-nat.c (_initialize_linux_nat, show_debug_linux_nat): Dito.
	* infrun.c (_initialize_infrun, show_debug_infrun)
	(show_stop_on_solib_events, show_follow_fork_mode_string)
	(show_scheduler_mode, show_step_stop_if_no_debug): Ditto.
	* infcall.c (_initialize_infcall, show_coerce_float_to_double_p)
	(show_unwind_on_signal_p): Ditto.
	* gdbtypes.c (build_gdbtypes, show_opaque_type_resolution)
	(_initialize_gdbtypes, show_overload_debug): Ditto.
	* gdb-events.c, gdb-events.sh (_initialize_gdb_events)
	(show_gdb_events_debug): Ditto.
	* gdbarch.c, gdbarch.sh (show_gdbarch_debug)
	(_initialize_gdbarch): Ditto.
	* frame.c (_initialize_frame, show_backtrace_past_main)
	(show_backtrace_past_entry, show_backtrace_limit)
	(show_frame_debug): Ditto.
	* exec.c (_initialize_exec, show_write_files): Ditto.
	* dwarf2read.c (_initialize_dwarf2_read)
	(show_dwarf2_max_cache_age): Ditto.
	* demangle.c (_initialize_demangler)
	(show_demangling_style_names): Ditto.
	* dcache.c (_initialize_dcache, show_dcache_enabled_p): Ditto.
	* cp-valprint.c (show_static_field_print)
	(_initialize_cp_valprint, show_vtblprint, show_objectprint): Ditto.
	* corefile.c (_initialize_core, show_gnutarget_string): Ditto.
	* cli/cli-logging.c (_initialize_cli_logging)
	(show_logging_overwrite, show_logging_redirect)
	(show_logging_filename): Ditto.
	* cli/cli-cmds.c (show_info_verbose, show_history_expansion_p)
	(init_cli_cmds, show_baud_rate, show_remote_debug)
	(show_remote_timeout, show_max_user_call_depth): Ditto.
	* charset.c (show_host_charset_name, show_target_charset_name)
	(initialize_charset): Ditto.
	* breakpoint.c (show_can_use_hw_watchpoints)
	(show_pending_break_support, _initialize_breakpoint): Ditto.
@
text
@d1091 2
a1092 2
      struct exception e = catch_exception (uiout, insert_catchpoint,
					    bpt->owner, RETURN_MASK_ERROR);
d5108 1
a5108 1
  struct exception e;
@


1.211
log
@2005-02-18  Andrew Cagney  <cagney@@gnu.org>

	Use add_setshow_zinteger_cmd through out.  Re-sync gdbarch.sh
	and gdbarch.c.
	* breakpoint.c, frame.c, gdb-events.sh, gdbarch.sh: Update.
	* gdbtypes.c, infrun.c, linux-nat.c, maint.c, monitor.c: Update.
	* pa64solib.c, parse.c, remote-mips.c, ser-go32.c: Update.
	* serial.c, solib-frv.c, somsolib.c, target.c, top.c: Update.
	* varobj.c, cli/cli-cmds.c: Update.
	* gdbarch.c, gdb-events.c: Regenerate.
@
text
@d207 10
d222 9
d7950 2
d7961 1
a7961 1
			    NULL, /* FIXME: i18n: */
d7988 1
a7988 1
				NULL, /* FIXME: i18n: Debugger's behavior regarding pending breakpoints is %s.  */
@


1.210
log
@2005-02-17  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (add_setshow_cmd_full, add_setshow_enum_cmd)
	(add_setshow_auto_boolean_cmd, add_setshow_boolean_cmd)
	(add_setshow_filename_cmd, add_setshow_string_cmd)
	(add_setshow_uinteger_cmd, add_setshow_zinteger_cmd): Delete
	fprint_setshow parameter.
	* command.h (fprint_setshow_ftype): Delete.
	(add_setshow_cmd_full, add_setshow_enum_cmd)
	(add_setshow_auto_boolean_cmd, add_setshow_boolean_cmd)
	(add_setshow_filename_cmd, add_setshow_string_cmd)
	(add_setshow_uinteger_cmd, add_setshow_zinteger_cmd): Delete
	fprint_setshow parameter.
	* aix-thread.c, alpha-tdep.c, arm-tdep.c, breakpoint.c: Update.
	* complaints.c, cris-tdep.c, dwarf2read.c, frame.c: Update.
	* hppa-tdep.c, infcall.c, m32r-rom.c, maint.c: Update.
	* mips-tdep.c, nto-tdep.c, observer.c, remote-rdi.c: Update
	* remote.c, target.c, cli/cli-logging.c: Update.
@
text
@d7931 4
a7934 3
  c = add_set_cmd ("can-use-hw-watchpoints", class_support, var_zinteger,
		   (char *) &can_use_hw_watchpoints,
		   "Set debugger's willingness to use watchpoint hardware.\n\
d7938 4
a7941 3
hardware.)",
		   &setlist);
  deprecated_add_show_from_set (c, &showlist);
@


1.209
log
@2005-02-15  Andrew Cagney  <cagney@@gnu.org>

	Mark up add_com, add_info and add_prefix_cmd.
	* breakpoint.c, cp-support.c, dcache.c, dwarf2read.c: Update.
	* exec.c, f-valprint.c, frame.c, gcore.c, gnu-nat.c: Update.
	* go32-nat.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* kod.c, language.c, linux-nat.c, m32r-rom.c, macrocmd.c: Update.
	* maint.c, memattr.c, mips-tdep.c, nto-procfs.c, objc-lang.c: Update.
	* ocd.c, pa64solib.c, printcmd.c, procfs.c, regcache.c: Update.
	* remote-e7000.c, remote-m32r-sdi.c, remote-mips.c: Update.
	* remote-sds.c, remote-sim.c, remote-st.c, remote-utils.c: Update.
	* remote.c, rs6000-tdep.c, ser-go32.c, serial.c: Update.
	* sh-tdep.c, solib.c, somsolib.c, source.c, stack.c: Update.
	* symfile.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, typeprint.c, utils.c, valprint.c: Update.
	* win32-nat.c, xcoffsolib.c, cli/cli-cmds.c, cli/cli-dump.c: Update.
	* cli/cli-logging.c, tui/tui-layout.c, tui/tui-regs.c: Update.
	* tui/tui-stack.c, tui/tui-win.c: Update.
@
text
@d7964 1
a7965 1
				NULL, NULL,
@


1.208
log
@2005-02-14  Andrew Cagney  <cagney@@gnu.org>

	Mark up add_cmd.
	* arch-utils.c, avr-tdep.c, breakpoint.c, corefile.c: Update.
	* cp-abi.c, cp-namespace.c, cp-support.c, dummy-frame.c: Update.
	* exec.c, gnu-nat.c, go32-nat.c, hppa-tdep.c, infcmd.c: Update.
	* infrun.c, interps.c, macrocmd.c, maint.c, memattr.c: Update.
	* mips-tdep.c, ocd.c, osabi.c, printcmd.c, regcache.c: Update.
	* reggroups.c, remote-fileio.c, remote-rdi.c, remote.c: Update.
	* sol-thread.c, source.c, stack.c, symfile-mem.c: Update.
	* symfile.c, thread.c, tracepoint.c, valprint.c, value.c: Update.
	* win32-nat.c, cli/cli-cmds.c, cli/cli-dump.c: Update.
	* cli/cli-logging.c, tui/tui-regs.c: Update.
@
text
@d7625 3
a7627 3
  add_com ("ignore", class_breakpoint, ignore_command,
	   "Set ignore-count of breakpoint number N to COUNT.\n\
Usage is `ignore N COUNT'.");
d7631 2
a7632 2
  add_com ("commands", class_breakpoint, commands_command,
	   "Set commands to be executed when a breakpoint is hit.\n\
d7638 1
a7638 1
then no output is printed when it is hit, except what the commands print.");
d7640 2
a7641 2
  add_com ("condition", class_breakpoint, condition_command,
	   "Specify breakpoint number N to break only if COND is true.\n\
d7643 1
a7643 1
expression to be evaluated whenever breakpoint N is reached.");
d7645 2
a7646 2
  c = add_com ("tbreak", class_breakpoint, tbreak_command,
	       "Set a temporary breakpoint.  Args like \"break\" command.\n\
d7649 1
a7649 1
by using \"enable delete\" on the breakpoint number.");
d7652 2
a7653 2
  c = add_com ("hbreak", class_breakpoint, hbreak_command,
	       "Set a hardware assisted  breakpoint. Args like \"break\" command.\n\
d7655 1
a7655 1
some target hardware may not have this support.");
d7658 2
a7659 2
  c = add_com ("thbreak", class_breakpoint, thbreak_command,
	       "Set a temporary hardware assisted breakpoint. Args like \"break\" command.\n\
d7661 1
a7661 1
so it will be deleted when hit.");
d7664 2
a7665 2
  add_prefix_cmd ("enable", class_breakpoint, enable_command,
		  "Enable some breakpoints.\n\
d7669 1
a7669 1
With a subcommand you can enable temporarily.",
d7672 2
a7673 2
    add_com ("ab", class_breakpoint, enable_command,
	     "Enable some breakpoints.\n\
d7677 1
a7677 1
With a subcommand you can enable temporarily.");
d7681 2
a7682 2
  add_abbrev_prefix_cmd ("breakpoints", class_breakpoint, enable_command,
			 "Enable some breakpoints.\n\
d7685 1
a7685 1
May be abbreviated to simply \"enable\".\n",
d7708 2
a7709 2
  add_prefix_cmd ("disable", class_breakpoint, disable_command,
		  "Disable some breakpoints.\n\
d7712 1
a7712 1
A disabled breakpoint is not forgotten, but has no effect until reenabled.",
d7717 2
a7718 2
    add_com ("sb", class_breakpoint, disable_command,
	     "Disable some breakpoints.\n\
d7721 1
a7721 1
A disabled breakpoint is not forgotten, but has no effect until reenabled.");
d7731 2
a7732 2
  add_prefix_cmd ("delete", class_breakpoint, delete_command,
		  "Delete some breakpoints or auto-display expressions.\n\
d7737 1
a7737 1
The \"unset\" command is also an alias for \"delete\".",
d7741 2
a7742 2
    add_com ("db", class_breakpoint, delete_command,
	     "Delete some breakpoints.\n\
d7744 1
a7744 1
To delete all breakpoints, give no argument.\n");
d7753 2
a7754 2
  add_com ("clear", class_breakpoint, clear_command,
	   concat ("Clear breakpoint at specified line or function.\n\
d7758 3
a7760 2
If an address is specified, breakpoints at that address are cleared.\n\n",
		   "With no argument, clears all breakpoints in the line that the selected frame\n\
d7763 1
a7763 1
See also the \"delete\" command which clears breakpoints by number.", NULL));
d7765 2
a7766 2
  c = add_com ("break", class_breakpoint, break_command,
	       concat ("Set breakpoint at specified line or function.\n\
d7770 2
a7771 2
If an address is specified, break at that exact address.\n",
		   "With no arg, uses current execution address of selected stack frame.\n\
d7776 1
a7776 1
Do \"help breakpoints\" for info on other commands dealing with breakpoints.", NULL));
d7792 2
a7793 2
      add_abbrev_prefix_cmd ("stop", class_breakpoint, stop_command,
	"Break in function/address or break at a line in the current file.",
d7799 2
a7800 2
      add_com ("status", class_info, breakpoints_info,
	       concat ("Status of user-settable breakpoints, or breakpoint number NUMBER.\n\
d7807 3
a7809 2
address and file/line number respectively.\n\n",
		       "Convenience variable \"$_\" and default examine address for \"x\"\n\
d7812 1
a7812 1
breakpoint set.", NULL));
d7815 2
a7816 2
  add_info ("breakpoints", breakpoints_info,
	    concat ("Status of user-settable breakpoints, or breakpoint number NUMBER.\n\
d7823 3
a7825 2
address and file/line number respectively.\n\n",
		    "Convenience variable \"$_\" and default examine address for \"x\"\n\
d7828 1
a7828 1
breakpoint set.", NULL));
d7831 2
a7832 2
    add_com ("lb", class_breakpoint, breakpoints_info,
	     concat ("Status of user-settable breakpoints, or breakpoint number NUMBER.\n\
d7839 3
a7841 2
address and file/line number respectively.\n\n",
		     "Convenience variable \"$_\" and default examine address for \"x\"\n\
d7844 1
a7844 1
breakpoint set.", NULL));
d7867 2
a7868 2
  add_com ("catch", class_breakpoint, catch_command,
	   "Set catchpoints to catch events.\n\
d7900 1
a7900 1
Do \"help breakpoints\" for info on other commands dealing with breakpoints.");
d7902 2
a7903 2
  add_com ("tcatch", class_breakpoint, tcatch_command,
	   "Set temporary catchpoints to catch events.\n\
d7907 1
a7907 1
by using \"enable delete\" on the catchpoint number.");
d7909 2
a7910 2
  c = add_com ("watch", class_breakpoint, watch_command,
	       "Set a watchpoint for an expression.\n\
d7912 1
a7912 1
an expression changes.");
d7915 2
a7916 2
  c = add_com ("rwatch", class_breakpoint, rwatch_command,
	       "Set a read watchpoint for an expression.\n\
d7918 1
a7918 1
an expression is read.");
d7921 2
a7922 2
  c = add_com ("awatch", class_breakpoint, awatch_command,
	       "Set a watchpoint for an expression.\n\
d7924 1
a7924 1
an expression is either read or written.");
d7928 1
a7928 1
	    "Synonym for ``info breakpoints''.");
d7943 1
a7943 1
  add_prefix_cmd ("breakpoint", class_maintenance, set_breakpoint_cmd, "\
d7946 1
a7946 1
pending breakpoint behavior",
d7949 1
a7949 1
  add_prefix_cmd ("breakpoint", class_maintenance, show_breakpoint_cmd, "\
d7952 1
a7952 1
pending breakpoint behavior",
@


1.207
log
@2005-02-14  Andrew Cagney  <cagney@@gnu.org>

	Mark up add_setshow functions, replace "PRINT:" comment prefix
	with "FIXME: i18n:".
	* aix-thread.c, alpha-tdep.c, arm-tdep.c, breakpoint.c: Update.
	* cris-tdep.c, dwarf2read.c, frame.c, hppa-tdep.c: Update.
	* infcall.c, m32r-rom.c, maint.c, mips-tdep.c: Update.
	* nto-tdep.c, observer.c, remote-rdi.c, remote.c: Update.
	* target.c, cli/cli-logging.c: Update.
@
text
@d7688 3
a7690 3
  add_cmd ("once", no_class, enable_once_command,
	   "Enable breakpoints for one hit.  Give breakpoint numbers.\n\
If a breakpoint is hit while enabled in this fashion, it becomes disabled.",
d7693 3
a7695 3
  add_cmd ("delete", no_class, enable_delete_command,
	   "Enable breakpoints and delete when hit.  Give breakpoint numbers.\n\
If a breakpoint is hit while enabled in this fashion, it is deleted.",
d7698 3
a7700 3
  add_cmd ("delete", no_class, enable_delete_command,
	   "Enable breakpoints and delete when hit.  Give breakpoint numbers.\n\
If a breakpoint is hit while enabled in this fashion, it is deleted.",
d7703 3
a7705 3
  add_cmd ("once", no_class, enable_once_command,
	   "Enable breakpoints for one hit.  Give breakpoint numbers.\n\
If a breakpoint is hit while enabled in this fashion, it becomes disabled.",
d7723 2
a7724 2
  add_cmd ("breakpoints", class_alias, disable_command,
	   "Disable some breakpoints.\n\
d7728 1
a7728 1
This command may be abbreviated \"disable\".",
d7746 2
a7747 2
  add_cmd ("breakpoints", class_alias, delete_command,
	   "Delete some breakpoints or auto-display expressions.\n\
d7750 1
a7750 1
This command may be abbreviated \"delete\".",
d7795 1
a7795 1
	       "Break in function or address.\n", &stoplist);
d7797 1
a7797 1
	       "Break at a line in the current file.\n", &stoplist);
d7842 2
a7843 2
  add_cmd ("breakpoints", class_maintenance, maintenance_info_breakpoints,
	   concat ("Status of all breakpoints, or breakpoint number NUMBER.\n\
d7850 2
a7851 2
\tfinish         - internal breakpoint used by the \"finish\" command\n",
		   "The \"Disp\" column contains one of \"keep\", \"del\", or \"dis\" to indicate\n\
d7854 5
a7858 3
address and file/line number respectively.\n\n",
		   "Convenience variable \"$_\" and default examine address for \"x\"\n\
are set to the address of the last breakpoint listed.\n\n\
d7860 1
a7860 1
breakpoint set.", NULL),
@


1.206
log
@2005-02-14  Andrew Cagney  <cagney@@gnu.org>

	* utils.c (paddress): New function.
	* defs.h (paddress): Declare.
	* printcmd.c (deprecated_print_address_numeric): Rename
	print_address_numeric, call paddress.
	* valprint.c, ui-out.c, tui/tui-stack.c, tracepoint.c: Update.
	* symmisc.c, symfile.c stack.c, p-valprint.c, printcmd.c: Update.
	* maint.c, m32r-rom.c, infcmd.c, f-valprint.c, exec.c: Update.
	* dwarf2read.c, dve3900-rom.c, defs.h, c-valprint.c: Update.
	* corefile.c, cli/cli-cmds.c, breakpoint.c, annotate.c: Update.
	* ada-valprint.c: Update.
@
text
@d7950 4
a7953 3
  add_setshow_auto_boolean_cmd ("pending", no_class, &pending_break_support, "\
Set debugger's behavior regarding pending breakpoints.", "\
Show debugger's behavior regarding pending breakpoints.", "\
d7957 2
a7958 2
user-query to see if a pending breakpoint should be created.",
				NULL, /*  PRINT: Debugger's behavior regarding pending breakpoints is %s.  */
@


1.205
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up some of printf_filtered and printf_unfiltered.
	* ada-lang.c, annotate.c, arch-utils.c, breakpoint.c: Update.
	* corelow.c, cp-namespace.c, cp-support.c, dcache.c: Update.
	* demangle.c, dsrec.c, dwarf2read.c, dwarfread.c: Update.
	* event-loop.c, event-top.c, exec.c, f-valprint.c: Update.
	* gdbtypes.c, inf-loop.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcmd.c, inflow.c, infrun.c, inftarg.c, language.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, maint.c: Update.
	* mdebugread.c, memattr.c, monitor.c, objc-lang.c: Update.
	* ocd.c, osabi.c, printcmd.c, procfs.c, regcache.c: Update.
	* remote.c, solib-som.c, solib.c, somsolib.c, source.c: Update.
	* stack.c, symfile.c, symmisc.c, target.c, thread.c: Update.
	* top.c, utils.c, valprint.c, value.c, cli/cli-cmds.c: Update.
	* cli/cli-dump.c, cli/cli-logging.c, tui/tui-hooks.c: Update.
	* tui/tui-regs.c, tui/tui-win.c: Update.
@
text
@d875 1
a875 1
		  print_address_numeric (bpt->address, 1, tmp_error_stream);
d1031 1
a1031 1
	  print_address_numeric (bpt->address, 1, tmp_error_stream);
d3772 1
a3772 1
      print_address_numeric (pc, 1, gdb_stdout);
d4857 1
a4857 1
	      print_address_numeric (b->loc->address, 1, gdb_stdout);
d6825 1
a6825 1
		    print_address_numeric (b->loc->address, 1, tmp_error_stream);
@


1.204
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up error_no_arg, query, perror_with_name, complaint, and
	internal_error.
	* breakpoint.c, cp-abi.c, cp-namespace.c, cp-support.c: Update.
	* cris-tdep.c, dbxread.c, dictionary.c, dsrec.c: Update.
	* dummy-frame.c, dve3900-rom.c, dwarf2-frame.c, dwarf2expr.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, event-loop.c: Update.
	* exceptions.c, exec.c, f-lang.c, findvar.c, fork-child.c: Update.
	* frame-unwind.c, frame.c, frv-linux-tdep.c, frv-tdep.c: Update.
	* gdb_assert.h, gdbarch.c, gdbtypes.c, gnu-nat.c: Update.
	* go32-nat.c, hppa-tdep.c, hppabsd-nat.c, hpread.c: Update.
	* i386-linux-nat.c, i386-nat.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386fbsd-nat.c, inf-ptrace.c, inf-ttrace.c, infcall.c: Update.
	* infcmd.c, inflow.c, infptrace.c, infrun.c, inftarg.c: Update.
	* interps.c, language.c, linespec.c, linux-nat.c: Update.
	* m32r-linux-nat.c, m68k-tdep.c, m68kbsd-nat.c: Update.
	* m68klinux-nat.c, m88kbsd-nat.c, macroexp.c, macroscope.c: Update.
	* macrotab.c, maint.c, mdebugread.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mips64obsd-nat.c: Update.
	* mipsnbsd-nat.c, mn10300-tdep.c, monitor.c, nto-procfs.c: Update.
	* objc-lang.c, objfiles.c, objfiles.h, ocd.c, osabi.c: Update.
	* parse.c, ppc-bdm.c, ppc-linux-nat.c, ppc-sysv-tdep.c: Update.
	* ppcnbsd-nat.c, ppcobsd-nat.c, printcmd.c, procfs.c: Update.
	* regcache.c, reggroups.c, remote-e7000.c, remote-mips.c: Update.
	* remote-rdp.c, remote-sds.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote.c, rs6000-nat.c, rs6000-tdep.c: Update.
	* s390-nat.c, s390-tdep.c, sentinel-frame.c, serial.c: Update.
	* sh-tdep.c, sh3-rom.c, sh64-tdep.c, shnbsd-nat.c: Update.
	* solib-aix5.c, solib-svr4.c, solib.c, source.c: Update.
	* sparc-nat.c, stabsread.c, stack.c, symfile.c, symtab.c: Update.
	* symtab.h, target.c, tracepoint.c, ui-file.c, ui-out.c: Update.
	* utils.c, valops.c, valprint.c, vax-nat.c, vaxbsd-nat.c: Update.
	* win32-nat.c, xcoffread.c, xstormy16-tdep.c: Update.
	* cli/cli-cmds.c, cli/cli-logging.c, cli/cli-script.c: Update.
	* cli/cli-setshow.c, mi/mi-cmd-break.c, mi/mi-cmds.c: Update.
	* mi/mi-console.c, mi/mi-getopt.c, mi/mi-out.c: Update.
	* tui/tui-file.c, tui/tui-interp.c: Update.
@
text
@d397 1
a397 1
	  printf_filtered ("Convenience variable must have integer value.\n");
d551 1
a551 1
	    printf_filtered ("Breakpoint %d now unconditional.\n", bnum);
d998 4
a1001 3
	  printf_filtered (_("Hardware watchpoint %d deleted "), bpt->owner->number);
	  printf_filtered ("because the program has left the block \n");
	  printf_filtered ("in which its expression is valid.\n");
d2102 1
a2102 1
      printf_filtered ("Stopped due to shared library event\n");
d2109 1
a2109 1
      printf_filtered ("Thread Event Breakpoint: gdb should not stop!\n");
d2115 1
a2115 1
      printf_filtered ("Overlay Event Breakpoint: gdb should not stop!\n");
d2121 3
a2123 3
      printf_filtered ("\nCatchpoint %d (", bs->breakpoint_at->number);
      printf_filtered ("loaded");
      printf_filtered (" %s), ", bs->breakpoint_at->triggered_dll_pathname);
d2129 3
a2131 3
      printf_filtered ("\nCatchpoint %d (", bs->breakpoint_at->number);
      printf_filtered ("unloaded");
      printf_filtered (" %s), ", bs->breakpoint_at->triggered_dll_pathname);
d2137 2
a2138 3
      printf_filtered ("\nCatchpoint %d (", bs->breakpoint_at->number);
      printf_filtered ("forked");
      printf_filtered (" process %d), ", 
d2145 2
a2146 3
      printf_filtered ("\nCatchpoint %d (", bs->breakpoint_at->number);
      printf_filtered ("vforked");
      printf_filtered (" process %d), ", 
d2153 1
a2153 1
      printf_filtered ("\nCatchpoint %d (exec'd %s), ",
d2164 1
a2164 1
	  printf_filtered ("\nCatchpoint %d (exception caught), ", 
a2165 1
	  printf_filtered ("throw location ");
d2167 1
a2167 1
	    printf_filtered ("%s:%d",
d2171 1
a2171 1
	    printf_filtered ("unknown");
a2172 1
	  printf_filtered (", catch location ");
d2174 1
a2174 1
	    printf_filtered ("%s:%d",
d2178 1
a2178 1
	    printf_filtered ("unknown");
a2179 1
	  printf_filtered ("\n");
d2195 1
a2195 1
	  printf_filtered ("\nCatchpoint %d (exception thrown), ",
a2196 1
	  printf_filtered ("throw location ");
d2198 1
a2198 1
	    printf_filtered ("%s:%d",
d2202 1
a2202 1
	    printf_filtered ("unknown");
a2203 1
	  printf_filtered (", catch location ");
d2205 1
a2205 1
	    printf_filtered ("%s:%d",
d2209 1
a2209 1
	    printf_filtered ("unknown");
a2210 1
	  printf_filtered ("\n");
d2700 1
a2700 1
	    printf_filtered ("Watchpoint %d deleted.\n", b->number);
d2777 1
a2777 1
		printf_filtered ("Watchpoint %d deleted.\n", b->number);
d3750 4
a3753 1
      printf_filtered ("Note: breakpoint%s ", (others > 1) ? "s" : "");
d3771 1
a3771 1
      printf_filtered ("also set at pc ");
d4308 1
a4308 1
    printf_filtered ("Pending breakpoint \"%s\" resolved\n", b->addr_string);
d4749 1
a4749 1
	printf_filtered ("(apparently deleted?) Eventpoint %d: ", b->number);
d4793 1
a4793 1
	printf_filtered ("Breakpoint %d", b->number);
d4802 1
a4802 1
	printf_filtered ("Hardware assisted breakpoint %d", b->number);
d4807 1
a4807 1
	printf_filtered ("Catchpoint %d (%s %s)",
d4815 1
a4815 1
	printf_filtered ("Catchpoint %d (%s)",
d4820 1
a4820 1
	printf_filtered ("Catchpoint %d (exec)",
d4825 1
a4825 1
	printf_filtered ("Catchpoint %d (%s)",
d4846 2
d4850 1
a4850 1
	  printf_filtered (" (%s) pending.", b->addr_string);
d5512 1
a5512 1
  printf_filtered ("Specify the type of breakpoint to set.\n\
d5514 1
a5514 1
       stop at <line>\n");
d5545 1
a5545 1
    printf_filtered ("Usage: stop in <function | address>\n");
d5577 1
a5577 1
    printf_filtered ("Usage: stop at <line>\n");
d6278 1
a6278 1
    printf_filtered ("\nCatchpoint %d (exception thrown)\n",
d6281 1
a6281 1
    printf_filtered ("\nCatchpoint %d (exception caught)\n",
d6307 1
a6307 1
    printf_filtered ("Catchpoint %d (throw)", b->number);
d6309 1
a6309 1
    printf_filtered ("Catchpoint %d (catch)", b->number);
d6652 6
a6657 1
    printf_unfiltered ("Deleted breakpoint%s ", found->next ? "s" : "");
d7149 1
a7149 1
      printf_filtered ("Deleting unknown breakpoint type %d\n", b->type);
d7249 1
a7249 1
	    printf_filtered ("Will stop next time breakpoint %d is reached.",
d7252 1
a7252 1
	    printf_filtered ("Will ignore next crossing of breakpoint %d.",
d7255 1
a7255 1
	    printf_filtered ("Will ignore next %d crossings of breakpoint %d.",
d7338 1
a7338 1
	    printf_unfiltered ("No breakpoint number %d.\n", num);
d7461 1
a7461 1
		  printf_filtered ("\
d7463 1
a7463 1
is valid is not currently in scope.\n", bpt->number);
d7492 1
a7492 1
		  printf_filtered ("\
d7494 1
a7494 1
have been allocated for other watchpoints.\n", bpt->number);
@


1.203
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d528 1
a528 1
    error_no_arg ("breakpoint number");
d730 1
a730 1
      internal_error (__FILE__, __LINE__, "unknown breakpoint type");
d998 1
a998 1
	  printf_filtered ("Hardware watchpoint %d deleted ", bpt->owner->number);
d2356 1
a2356 1
		      "print_bp_stop_message: unrecognized enum value");
d3316 1
a3316 1
		    "bptypes table does not describe type #%d.",
d3346 1
a3346 1
			"print_one_breakpoint: bp_none encountered\n");
d3876 2
a3877 2
			"allegedly permanent breakpoint is not "
			"actually inserted");
d3892 2
a3893 2
				  "another breakpoint was inserted on top of "
				  "a permanent breakpoint");
d4008 1
a4008 1
      internal_error (__FILE__, __LINE__, "unknown breakpoint type");
d6796 2
a6797 2
			    "another breakpoint was inserted on top of "
			    "a permanent breakpoint");
d6920 1
a6920 1
	  || (breaks_to_delete && query ("Delete all breakpoints? ")))
d7282 1
a7282 1
    error_no_arg ("a breakpoint number");
d7310 1
a7310 1
    error_no_arg ("one or more breakpoint numbers");
@


1.202
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (add_setshow_enum_cmd, add_setshow_cmd_full)
	(add_setshow_auto_boolean_cmd, add_setshow_boolean_cmd)
	(add_setshow_filename_cmd, add_setshow_string_cmd)
	(add_setshow_uinteger_cmd, add_setshow_zinteger_cmd): Replace
	print string parameter with fprint_setshow function.
	* command.h (fprint_setshow_ftype): Define.  Update declarations.
	* cli/cli-setshow.c (do_setshow_command): When fprint_setshow is
	available, use that.
	* cli/cli-decode.h (struct cmd_list_element): Add field
	fprint_setshow.
	* complaints.c (fprint_setshow_complaints): New function.
	(_initialize_complaints): Pass to add_setshow_zinteger_cmd.
	* hppa-tdep.c (_initialize_hppa_tdep): Replace "print" parameter
	with NULL.
	* mips-tdep.c (_initialize_mips_tdep): Ditto.
	* m32r-rom.c (_initialize_m32r_rom): Ditto.
	* cris-tdep.c (_initialize_cris_tdep): Ditto.
	* arm-tdep.c (_initialize_arm_tdep): Ditto.
	* remote-rdi.c (_initialize_remote_rdi): Ditto.
	* alpha-tdep.c (_initialize_alpha_tdep): Ditto.
	* dwarf2read.c (_initialize_dwarf2_read): Ditto.
	* frame.c (_initialize_frame): Ditto.
	* target.c (initialize_targets): Ditto.
	* maint.c (_initialize_maint_cmds): Ditto.
	* observer.c (_initialize_observer): Ditto.
	* infcall.c (_initialize_infcall): Ditto.
	* breakpoint.c (_initialize_breakpoint): Ditto.
	* cli/cli-logging.c (_initialize_cli_logging): Ditto.
	* remote.c (add_packet_config_cmd, _initialize_remote): Ditto.
@
text
@d308 1
a308 1
   error ("catch of library loads not yet implemented on this platform")
d318 1
a318 1
   error ("catch of library unloads not yet implemented on this platform")
d483 1
a483 1
	      error ("inverted range");
d497 1
a497 1
    error ("negative value");
d533 1
a533 1
    error ("Bad breakpoint argument: '%s'", arg);
d563 1
a563 1
		error ("Junk at end of expression");
d571 1
a571 1
  error ("No breakpoint number %d.", bnum);
d587 1
a587 1
    error ("Can't use the \"commands\" command among a breakpoint's commands.");
d593 1
a593 1
    error ("Unexpected extra arguments following breakpoint number.");
d609 1
a609 1
  error ("No breakpoint number %d.", bnum);
d635 1
a635 1
      warning ("reading through apparently deleted breakpoint #%d?",
d801 1
a801 1
		warning ("hardware breakpoint %d not supported in overlay!\n",
d1368 1
a1368 1
    error ("Cannot detach breakpoints of inferior_ptid");
d1398 1
a1398 1
    warning ("attempted to remove apparently deleted breakpoint #%d?", 
d1506 1
a1506 1
	warning ("Could not remove hardware watchpoint %d.",
d1528 1
a1528 1
	  warning ("Internal error, %s line %d.", __FILE__, __LINE__);
d1646 2
a1647 2
      warning ("Exception catchpoints from last run were deleted.");
      warning ("You must reinsert them explicitly.");
d1909 1
a1909 2
  if (bsp == NULL)
    error ("Internal error (bpstat_find_step_resume_breakpoint)");
d1922 1
a1922 1
  error ("Internal error (no step_resume breakpoint found)");
d3911 1
a3911 1
    warning ("Breakpoint %d address previously adjusted from %s to %s.",
d3914 1
a3914 1
    warning ("Breakpoint address adjusted from %s to %s.", astr1, astr2);
d4363 1
a4363 1
		warning ("Temporarily disabling shared library breakpoints:");
d4366 1
a4366 1
	    warning ("breakpoint #%d ", b->number);
d4403 1
a4403 1
		warning ("Temporarily disabling breakpoints for unloaded shared library \"%s\"",
d4461 3
a4463 3
      warning ("Unable to set a breakpoint on dynamic linker callback.");
      warning ("Suggest linking with /opt/langtools/lib/end.o.");
      warning ("GDB will be unable to track shl_load/shl_unload calls");
d4468 2
a4469 2
      warning ("Unable to set unique breakpoint on dynamic linker callback.");
      warning ("GDB will be unable to track shl_load/shl_unload calls");
d4902 1
a4902 1
	error ("No hardware breakpoint support in the target.");
d4904 1
a4904 1
	error ("Hardware breakpoints used exceeds limit.");
d4946 1
a4946 1
		  error ("Junk at end of pending breakpoint condition expression");
d4994 1
a4994 1
	error ("No default breakpoint address now.");
d5063 1
a5063 1
	    error ("Cannot break without a running program.");
d5065 1
a5065 1
	    error ("Cannot break on %s without a running program.", 
d5258 1
a5258 1
		    error ("Junk after thread keyword.");
d5260 1
a5260 1
		    error ("Unknown thread %d\n", thread);
d5263 1
a5263 1
		error ("Junk at end of arguments.");
d5300 2
a5301 4
    {
      warning ("Multiple breakpoints were set.");
      warning ("Use the \"delete\" command to delete unwanted breakpoints.");
    }
d5386 1
a5386 1
    error ("Garbage %s following breakpoint address", address_end);
d5400 1
a5400 1
	    error ("Garbage %s follows condition", tok);
d5448 1
a5448 1
	error ("No line %d in file \"%s\".",
d5638 1
a5638 1
    error ("Junk at end of command.");
d5649 1
a5649 1
    error ("Expression cannot be implemented with read/access watchpoint.");
d5657 1
a5657 1
	error ("Target does not support this type of hardware watchpoint.");
d5660 1
a5660 1
	error ("Target can only support one kind of HW watchpoint at a time.");
d5680 1
a5680 1
      warning ("can't do that without a running program; try \"break main\", \"run\" first");
d5910 1
a5910 1
    error ("Couldn't get information on specified line.");
d5916 1
a5916 1
    error ("Junk at end of arguments.");
d6108 1
a6108 1
    error ("Junk at end of arguments.");
d6121 1
a6121 1
      error ("unsupported or unknown fork kind; cannot catch it");
d6141 1
a6141 1
    error ("Junk at end of arguments.");
d6181 1
a6181 1
    error ("Junk at end of arguments.");
d6223 1
a6223 1
    error ("Junk at end of arguments.");
d6258 1
a6258 1
      error ("Internal error -- invalid catchpoint kind");
d6372 1
a6372 1
    error ("Junk at end of arguments.");
d6376 1
a6376 1
    error ("Unsupported or unknown exception event; cannot catch it");
d6394 1
a6394 1
  warning ("Unsupported with this platform/compiler combination.");
d6434 1
a6434 1
      error ("Catch requires an event name.");
d6439 1
a6439 1
    error ("catch requires an event");
d6445 1
a6445 1
      error ("Catch of signal not yet implemented");
d6459 1
a6459 1
      error ("Catch of thread_start not yet implemented");
d6463 1
a6463 1
      error ("Catch of thread_exit not yet implemented");
d6467 1
a6467 1
      error ("Catch of thread_join not yet implemented");
d6471 1
a6471 1
      error ("Catch of start not yet implemented");
d6475 1
a6475 1
      error ("Catch of exit not yet implemented");
d6499 1
a6499 1
      error ("Catch of stop not yet implemented");
d6510 1
a6510 1
      error ("Unknown event kind specified for catch");
d6568 1
a6568 1
	error ("No source file specified.");
d6646 1
a6646 1
	error ("No breakpoint at %s.", arg);
d6648 1
a6648 1
	error ("No breakpoint at this line.");
d6699 1
a6699 3
  if (bpt == NULL)
    error ("Internal error (attempted to delete a NULL breakpoint)");

d6957 1
a6957 1
      warning ("attempted to reset apparently deleted breakpoint #%d?",
d7260 1
a7260 1
  error ("No breakpoint number %d.", bptnum);
d7286 1
a7286 1
    error ("bad breakpoint number: '%s'", args);
d7288 1
a7288 1
    error ("Second argument (specified ignore-count) is missing.");
d7320 1
a7320 1
	  warning ("bad breakpoint number at or near '%s'", p);
d7376 1
a7376 1
	warning ("attempted to disable apparently deleted breakpoint #%d?",
d7414 1
a7414 1
	error ("No hardware breakpoint support in the target.");
d7416 1
a7416 1
	error ("Hardware breakpoints used exceeds limit.");
d7527 1
a7527 1
	warning ("attempted to enable apparently deleted breakpoint #%d?",
d7592 1
a7592 1
    error ("Empty line specification.");
d7602 1
a7602 1
    error ("Junk at end of line specification: %s", string);
@


1.201
log
@2005-02-07  Andrew Cagney  <cagney@@gnu.org>

	* cp-valprint.c, c-valprint.c, infcall.c: Use value_contents or
	value_contents_writeable, include note that there are problems.
	* breakpoint.c, infcall.c: Use VALUE_LVAL.
@
text
@d7958 2
a7959 2
user-query to see if a pending breakpoint should be created.", "\
Debugger's behavior regarding pending breakpoints is %s.",
@


1.200
log
@2005-02-07  Andrew Cagney  <cagney@@gnu.org>

	* value.h (value_next): Declare.
	* value.c (value_next): Define.
	* breakpoint.c: Update.
@
text
@d5824 2
a5825 1
      else if (v->lval != not_lval && deprecated_value_modifiable (v) == 0)
d5827 1
a5827 1
      else if (v->lval == lval_register)
@


1.199
log
@2005-02-07  Andrew Cagney  <cagney@@gnu.org>

	* value.h (deprecated_set_value_modifiable)
	(deprecated_value_modifiable): Declare.
	* value.c (deprecated_set_value_modifiable): Define.
	(deprecated_value_modifiable): Define.
	* ada-lang.c, valops.c, breakpoint.c, tracepoint.c: Update.
@
text
@d746 1
a746 1
      n = v->next;
d941 1
a941 1
	  for (; v; v = v->next)
d1473 1
a1473 1
      for (v = b->owner->val_chain; v; v = v->next)
d2728 1
a2728 1
	for (v = b->val_chain; v; v = v->next)
d5792 1
a5792 1
  for (; v; v = v->next)
@


1.198
log
@2005-02-06  Andrew Cagney  <cagney@@gnu.org>

	* value.c (value_contents, value_contents_writeable): New
	functions.
	* value.h (VALUE_CONTENTS): Delete macro.
	(value_contents, value_contents_writeable): Declare.
	* xstormy16-tdep.c, value.c, valops.c, valarith.c: Update.
	* stack.c, sparc-tdep.c, sparc64-tdep.c, sh-tdep.c: Update.
	* sh64-tdep.c, scm-valprint.c, scm-exp.c, s390-tdep.c: Update.
	* rs6000-tdep.c, p-valprint.c, printcmd.c: Update.
	* ppc-sysv-tdep.c, mips-tdep.c, mi/mi-main.c: Update.
	* m88k-tdep.c, m68hc11-tdep.c, m32r-tdep.c: Update.
	* jv-valprint.c, ia64-tdep.c, hppa-tdep.c: Update.
	* hpacc-abi.c, f-valprint.c, frv-tdep.c, eval.c: Update.
	* c-valprint.c, cris-tdep.c, cp-valprint.c: Update.
	* cli/cli-dump.c, breakpoint.c, avr-tdep.c, arm-tdep.c: Update.
	* arm-linux-tdep.c, amd64-tdep.c, alpha-tdep.c: Update.
	* ada-valprint.c, ada-lang.c: Update.
@
text
@d5824 1
a5824 1
      else if (v->lval != not_lval && v->modifiable == 0)
@


1.197
log
@2005-02-02  Andrew Cagney  <cagney@@gnu.org>

	* value.h (value_lazy): Declare.
	* varobj.c, value.c, valops.c, valarith.c, printcmd.c: Update.
	* cp-valprint.c, breakpoint.c, ada-lang.c: Update.
@
text
@d934 1
a934 1
	  VALUE_CONTENTS (v);
@


1.196
log
@2005-01-19  Andrew Cagney  <cagney@@gnu.org>

	* exceptions.h (deprecated_throw_reason): Rename throw_reason.
	* exceptions.c (deprecated_throw_reason): Rename throw_reason.
	* utils.c (internal_verror, quit): Update.
	* remote-sds.c (interrupt_query): Update.
	* remote-mips.c (mips_error, mips_kill): Update.
	* remote-fileio.c (remote_fileio_ctrl_c_signal_handler): Update.
	* remote.c (interrupt_query): Update.
	* ocd.c (interrupt_query): Update.
	* nto-procfs.c (interrupt_query): Update.
	* monitor.c (monitor_interrupt_query): Update.
	* breakpoint.c (break_command_1): Update.
@
text
@d947 1
a947 1
		  && ! VALUE_LAZY (v))
d1126 1
a1126 1
	  if (VALUE_LAZY (val))
d1478 1
a1478 1
	      && ! VALUE_LAZY (v))
d2731 1
a2731 1
		&& ! VALUE_LAZY (v))
d5622 1
a5622 1
  if (VALUE_LAZY (val))
d5796 1
a5796 1
	  if (VALUE_LAZY (v))
d7119 1
a7119 1
      if (VALUE_LAZY (b->val) && breakpoint_enabled (b))
d7475 1
a7475 1
	  if (VALUE_LAZY (bpt->val))
@


1.195
log
@2005-01-18  Andrew Cagney  <cagney@@gnu.org>

	* target.h (struct target_ops): Change return type of
	to_insert_fork_catchpoint, to_insert_vfork_catchpoint and
	to_insert_exec_catchpoint to void.
	(child_insert_fork_catchpoint, child_insert_vfork_catchpoint)
	(child_insert_exec_catchpoint): Change return type to void.
	* target.c (update_current_target): Update.
	(debug_to_insert_fork_catchpoint)
	(debug_to_insert_vfork_catchpoint)
	(debug_to_insert_exec_catchpoint): Update.
	* inf-child.c (inf_child_insert_fork_catchpoint)
	(inf_child_insert_vfork_catchpoint)
	(inf_child_insert_exec_catchpoint): Update.
	* breakpoint.c (insert_catchpoint): Update, do not throw an error.
	* linux-nat.c (child_insert_fork_catchpoint)
	(child_insert_vfork_catchpoint)
	(child_insert_exec_catchpoint): Update.
	* inftarg.c (child_insert_fork_catchpoint)
	(child_insert_vfork_catchpoint,)
	(child_insert_exec_catchpoint): Update.
@
text
@d5147 1
a5147 1
	    throw_reason (RETURN_ERROR);
@


1.194
log
@2005-01-14  Andrew Cagney  <cagney@@gnu.org>

	* exceptions.h (catch_exceptions): Delete errstring parameter.
	(catch_exceptions_with_msg): Ditto.
	* exceptions.c (catch_exceptions_with_msg): Update.
	(catch_exceptions): Update.
	* symfile-mem.c (add_vsyscall_page): Update.
	* frame.c (get_current_frame): Update.
	* wrapper.c (gdb_value_struct_elt): Update.
	* exceptions.c (catch_exceptions): Update.
	* thread.c (gdb_list_thread_ids, gdb_thread_select): Update.
	* breakpoint.c (gdb_breakpoint_query, gdb_breakpoint): Update.
	* remote-fileio.c (remote_fileio_request): Update.
@
text
@d721 1
a721 1
      val = target_insert_fork_catchpoint (PIDGET (inferior_ptid));
d724 1
a724 1
      val = target_insert_vfork_catchpoint (PIDGET (inferior_ptid));
d727 1
a727 1
      val = target_insert_exec_catchpoint (PIDGET (inferior_ptid));
a732 3

  if (val < 0)
    throw_reason (RETURN_ERROR);
@


1.193
log
@2005-01-14  Andrew Cagney  <cagney@@gnu.org>

	* exceptions.h (exception_fprintf): Declare.
	(exception_print): Drop pre_print parameter.
	* mi/mi-main.c (mi_execute_command): Update exception_print call.
	* cli/cli-interp.c (safe_execute_command): Update exception_print
	call.
	* remote.c (remote_open_1): Instead of passing an error prefix to
	catch_exceptions, use catch_exceptions and exception_fprintf.
	(remote_start_remote): Change return type to void.
	* breakpoint.c (insert_bp_location): Instead of passing an error
	prefix to catch_exceptions, use catch_exceptions and
	exception_fprintf.
	(insert_catchpoint): Change return type to void.
	(break_command_1): Update exception_print call.
	* exceptions.c (exception_fprintf): New function.
	(print_exception): New function.
	(exception_print): Use print_exception.
@
text
@d3607 1
a3607 1
				    NULL, error_message, RETURN_MASK_ALL);
d5440 1
a5440 1
				    NULL, error_message, RETURN_MASK_ALL);
@


1.192
log
@2005-01-14  Andrew Cagney  <cagney@@gnu.org>

	* linespec.c (symtab_from_filename, decode_variable): Use
	throw_error instead of error_silent.
	* breakpoint.c (do_captured_parse_breakpoint): Change return type
	to void.
	(break_command_1): Use catch_exception and check the error return
	status.
	* exceptions.c (throw_error): New function.
	(throw_vsilent): Delete function.
	* exceptions.h (throw_error): Declare.
	(throw_vsilent): Delete declaration.
	* utils.c (error_silent): Delete function.
	* defs.h (error_silent): Delete declaration.
@
text
@d712 1
a712 1
static int
a735 2

  return 0;
d1074 5
a1078 7
      char *prefix = xstrprintf ("warning: inserting catchpoint %d: ",
				 bpt->owner->number);
      struct cleanup *cleanups = make_cleanup (xfree, prefix);
      val = catch_exceptions (uiout, insert_catchpoint, bpt->owner, prefix,
			      RETURN_MASK_ERROR);
      do_cleanups (cleanups);
      if (val < 0)
d5133 1
a5133 1
      exception_print (gdb_stderr, NULL, e);
d5144 1
a5144 1
	  exception_print (gdb_stderr, NULL, e);
d5170 1
a5170 1
	  exception_print (gdb_stderr, NULL, e);
@


1.191
log
@2005-01-13  Michael Snyder  <msnyder@@redhat.com>

	* breakpoint.c: Whitespace tweaks.
@
text
@d4 1
a4 1
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
a120 2
static int do_captured_parse_breakpoint (struct ui_out *, void *);

d5080 1
a5080 1
static int
a5086 2

  return GDB_RC_OK;
d5099 1
d5112 1
a5112 1
  int i, rc;
d5130 2
a5131 3
  rc = catch_exceptions_with_msg (uiout, do_captured_parse_breakpoint, 
		  		  &parse_args, NULL, &err_msg, 
				  RETURN_MASK_ALL);
d5134 1
a5134 2

  if (rc != GDB_RC_OK)
d5136 9
a5144 4
      /* Check for file or function not found.  */
      if (not_found)
	{
	  /* If called to resolve pending breakpoint, just return error code.  */
d5146 1
a5146 4
	    {
	      xfree (err_msg);
	      return rc;
	    }
d5148 1
a5148 2
	  error_output_message (NULL, err_msg);
	  xfree (err_msg);
d5150 2
a5151 1
	  /* If pending breakpoint support is turned off, throw error.  */
d5156 2
a5157 2
          /* If pending breakpoint support is auto query and the user selects 
	     no, then simply return the error code.  */
d5160 1
a5160 1
	    return rc;
d5162 4
a5165 4
	  /* At this point, either the user was queried about setting a 
	     pending breakpoint and selected yes, or pending breakpoint 
	     behavior is on and thus a pending breakpoint is defaulted 
	     on behalf of the user.  */
d5172 4
d5177 3
a5179 5
      else
	{
	  xfree (err_msg);
	  return rc;
	}
a5180 2
  else if (!sals.nelts)
    return GDB_RC_FAIL;
@


1.190
log
@2005-01-13  Andrew Cagney  <cagney@@gnu.org>

	* breakpoint.c (gdb_breakpoint_query): Update, use
	catch_exceptions_with_msg.
	(do_captured_breakpoint): Add uiout parameter.
	(gdb_breakpoint): Update, use catch_exceptions_with_msg.
	* mi/mi-main.c (mi_cmd_thread_select): Pass mi_error_message to
	gdb_thread_select.  Return MI_CMD_ERROR instead of
	MI_CMD_CAUGHT_ERROR.
	(mi_cmd_thread_list_ids): Ditto for gdb_list_thread_ids.
	(enum captured_mi_execute_command_actions): Delete
	EXECUTE_COMMAND_DISPLAY_ERROR.
	(captured_mi_execute_command): Delete code handling
	MI_CMD_CAUGHT_ERROR.
	(mi_execute_command): Don't check for
	EXECUTE_COMMAND_DISPLAY_ERROR.
	* mi/mi-cmd-break.c (breakpoint_notify): Update call to
	gdb_breakpoint_query.
	(mi_cmd_break_insert): Pass mi_error_message to gdb_breakpoint.
	* mi/mi-cmds.h (enum mi_cmd_result): Delete MI_CMD_CAUGHT_ERROR.
	* gdb.h (gdb_thread_select, gdb_list_thread_ids)
	(gdb_breakpoint, gdb_breakpoint_query): Add error_message
	parameter.
	* thread.c (thread_command): Update call.
	(gdb_thread_select, gdb_list_thread_ids): Update, call
	catch_exceptions_with_msg.
@
text
@d319 1
a319 1
#define SOLIB_CREATE_CATCH_UNLOAD_HOOK(pid,tempflag,filename,cond_string) \
d4464 3
a4466 2
  /* Set a breakpoint on the specified hook. */
  sals = decode_line_1 (&hookname, 1, (struct symtab *) NULL, 0, &canonical, NULL);
d4540 1
a4540 1
  solib_load_unload_1 (hookname,tempflag, dll_pathname, 
d6727 1
a6727 1
     references were extent.  A cheaper bandaid was chosen. */
d6751 1
a6751 1
     exceptions are supported in this way, it's OK for now. FIXME */
d7530 1
a7530 1
   in stopping the inferior. */
@


1.189
log
@2005-01-12  Andrew Cagney  <cagney@@gnu.org>

	* exceptions.h (throw_reason): Rename throw_exception.
	(enum errors, struct exception): Define.
	(catch_exception_ftype): Define.
	(catch_exception, throw_exception): Declare.
	* exceptions.c (throw_exception): Rewrite.
	(throw_reason): New function.
	(struct catcher, catcher_state_machine): Replace "reason" with
	"exception", delete "gdberrmsg".
	(catch_exception): New function.
	(catcher_init): Replace "gdberrmsg" parameter with "exception".
	(catch_errors, catch_exceptions_with_msg): Re-implement passing
	exception to catcher_init.
	* utils.c (error_silent, error_stream_1): Use throw_reason.
	(internal_verror, quit): Ditto.
	* breakpoint.c (insert_catchpoint, break_command_1): Ditto.
	* remote-fileio.c (remote_fileio_ctrl_c_signal_handler): Ditto.
	* remote.c (remote_open_1, interrupt_query): Ditto.
@
text
@d3606 1
a3606 1
gdb_breakpoint_query (struct ui_out *uiout, int bnum)
d3612 2
a3613 2
  return catch_exceptions (uiout, do_captured_breakpoint_query, &args,
			   NULL, RETURN_MASK_ALL);
d5337 1
a5337 1
do_captured_breakpoint (void *data)
d5435 2
a5436 1
		int thread, int ignore_count)
d5445 2
a5446 2
  return catch_errors (do_captured_breakpoint, &args,
		       NULL, RETURN_MASK_ALL);
@


1.188
log
@2005-01-12  Andrew Cagney  <cagney@@gnu.org>

	* exceptions.h (enum return_reason, RETURN_MASK)
	(RETURN_MASK_QUIT, RETURN_MASK_ERROR, RETURN_MASK_ALL)
	(return_mask, throw_exception, catch_exceptions_ftype)
	(catch_exceptions_with_msg, catch_errors_ftype, catch_errors)
	(catch_command_errors_ftype, catch_command_errors): Move to
	exceptions.h.
	* exceptions.c, exceptions.h: New files.
	* top.c: Do not include <setjmp.h>.
	(SIGJMP_BUF, SIGSETJMP, SIGLONGJMP, catch_return)
	(throw_exception, catcher, catch_exceptions)
	(catch_exceptions_with_msg, struct catch_errors_args)
	(do_catch_errors, catch_errors, struct captured_command_args)
	(do_captured_command, catch_command_errors): Move to exceptions.c.
	* wrapper.c, wince.c, win32-nat.c, utils.c: Include "exceptions.h".
	* tui/tui-interp.c, top.c, thread.c, symmisc.c: Ditto.
	* symfile-mem.c, stack.c, solib.c, rs6000-nat.c: Ditto.
	* remote-sds.c, remote-mips.c, remote-fileio.c: Ditto.
	* remote-e7000.c, objc-lang.c, ocd.c: Ditto.
	* remote.c, nto-procfs.c, monitor.c, mi/mi-main.c: Ditto.
	* main.c, m32r-rom.c, infrun.c, inf-loop.c: Ditto.
	* hppa-hpux-tdep.c, frame.c, event-top.c, event-loop.c: Ditto.
	* corelow.c, corefile.c, cli/cli-interp.c, breakpoint.c: Ditto.
	* ada-valprint.c, ada-lang.c: Ditto.
	* Makefile.in (HFILES_NO_SRCDIR, COMMON_OBS): Add exceptions.h and
	exceptions.o.  Update all dependencies.
@
text
@d737 1
a737 1
    throw_exception (RETURN_ERROR);
d5156 1
a5156 1
	    throw_exception (RETURN_ERROR);
@


1.187
log
@	* breakpoint.c (break_command_1): Always free err_msg before
	returning when an exception was caught.
@
text
@d54 1
@


1.186
log
@2004-11-30  Randolph Chung  <tausq@@debian.org>

	* breakpoint.c (break_at_finish_command): Delete.
	(break_at_finish_command_1): Delete.
	(break_at_finish_at_depth_command): Delete.
	(break_at_finish_at_depth_command_1): Delete.
	(tbreak_at_finish_command): Delete.
	* hppa-tdep.c (_initialize_hppa_tdep): Remove deprecated xbreak, tbreak
	and bx commands.
@
text
@d5144 4
a5147 1
	    return rc;
d5175 4
a5178 1
	return rc;
@


1.185
log
@2004-11-12  Andrew Cagney  <cagney@@gnu.org>

	* value.h (VALUE_TYPE, VALUE_NEXT, VALUE_OFFSET, VALUE_BITSIZE)
	(VALUE_BITPOS): Delete.
	(value_type, value_offset, value_bitsize, value_bitpos): Declare.
	* value.c (value_type, value_offset, value_bitpos)
	(value_bitsize): New functions.  Update references.
	* arm-tdep.c, gnu-v3-abi.c, hpacc-abi.c, gnu-v2-abi.c: Update.
	* f-valprint.c, cp-valprint.c, c-valprint.c: Update.
	* ada-valprint.c, typeprint.c, scm-valprint.c, scm-exp.c: Update.
	* p-valprint.c, jv-valprint.c, jv-lang.c, varobj.c: Update.
	* objc-lang.c, ada-lang.c, std-regs.c, stack.c: Update.
	* infcall.c, linespec.c, printcmd.c, valarith.c: Update.
	* valops.c, eval.c, findvar.c, breakpoint.c: Update.
	* tracepoint.c, ax-gdb.c, mi/mi-main.c, cli/cli-dump.c:
	* rs6000-tdep.c, ppc-sysv-tdep.c: Update.
@
text
@a88 5
extern void break_at_finish_command (char *, int);
extern void break_at_finish_at_depth_command (char *, int);

extern void tbreak_at_finish_command (char *, int);

a178 5
static void break_at_finish_at_depth_command_1 (char *arg,
						int flag, int from_tty);

static void break_at_finish_command_1 (char *arg, int flag, int from_tty);

a5441 163
static void
break_at_finish_at_depth_command_1 (char *arg, int flag, int from_tty)
{
  struct frame_info *frame;
  CORE_ADDR low, high, selected_pc = 0;
  char *extra_args = NULL;
  char *level_arg;
  int extra_args_len = 0, if_arg = 0;

  if (!arg ||
      (arg[0] == 'i' && arg[1] == 'f' && (arg[2] == ' ' || arg[2] == '\t')))
    {

      if (default_breakpoint_valid)
	{
	  if (deprecated_selected_frame)
	    {
	      selected_pc = get_frame_pc (deprecated_selected_frame);
	      if (arg)
		if_arg = 1;
	    }
	  else
	    error ("No selected frame.");
	}
      else
	error ("No default breakpoint address now.");
    }
  else
    {
      extra_args = strchr (arg, ' ');
      if (extra_args)
	{
	  extra_args++;
	  extra_args_len = strlen (extra_args);
	  level_arg = (char *) xmalloc (extra_args - arg);
	  strncpy (level_arg, arg, extra_args - arg - 1);
	  level_arg[extra_args - arg - 1] = '\0';
	}
      else
	{
	  level_arg = (char *) xmalloc (strlen (arg) + 1);
	  strcpy (level_arg, arg);
	}

      frame = parse_frame_specification (level_arg);
      if (frame)
	selected_pc = get_frame_pc (frame);
      else
	selected_pc = 0;
    }
  if (if_arg)
    {
      extra_args = arg;
      extra_args_len = strlen (arg);
    }

  if (selected_pc)
    {
      if (find_pc_partial_function (selected_pc, (char **) NULL, &low, &high))
	{
	  char *addr_string;
	  if (extra_args_len)
	    addr_string = xstrprintf ("*0x%s %s", paddr_nz (high), extra_args);
	  else
	    addr_string = xstrprintf ("*0x%s", paddr_nz (high));
	  break_command_1 (addr_string, flag, from_tty, NULL);
	  xfree (addr_string);
	}
      else
	error ("No function contains the specified address");
    }
  else
    error ("Unable to set breakpoint at procedure exit");
}


static void
break_at_finish_command_1 (char *arg, int flag, int from_tty)
{
  char *addr_string, *break_string, *beg_addr_string;
  CORE_ADDR low, high;
  struct symtabs_and_lines sals;
  struct symtab_and_line sal;
  struct cleanup *old_chain;
  char *extra_args = NULL;
  int extra_args_len = 0;
  int i, if_arg = 0;

  if (!arg ||
      (arg[0] == 'i' && arg[1] == 'f' && (arg[2] == ' ' || arg[2] == '\t')))
    {
      if (default_breakpoint_valid)
	{
	  if (deprecated_selected_frame)
	    {
	      addr_string = xstrprintf ("*0x%s",
					paddr_nz (get_frame_pc (deprecated_selected_frame)));
	      if (arg)
		if_arg = 1;
	    }
	  else
	    error ("No selected frame.");
	}
      else
	error ("No default breakpoint address now.");
    }
  else
    {
      addr_string = (char *) xmalloc (strlen (arg) + 1);
      strcpy (addr_string, arg);
    }

  if (if_arg)
    {
      extra_args = arg;
      extra_args_len = strlen (arg);
    }
  else if (arg)
    {
      /* get the stuff after the function name or address */
      extra_args = strchr (arg, ' ');
      if (extra_args)
	{
	  extra_args++;
	  extra_args_len = strlen (extra_args);
	}
    }

  sals.sals = NULL;
  sals.nelts = 0;

  beg_addr_string = addr_string;
  sals = decode_line_1 (&addr_string, 1, (struct symtab *) NULL, 0,
			(char ***) NULL, NULL);

  xfree (beg_addr_string);
  old_chain = make_cleanup (xfree, sals.sals);
  for (i = 0; (i < sals.nelts); i++)
    {
      sal = sals.sals[i];
      if (find_pc_partial_function (sal.pc, (char **) NULL, &low, &high))
	{
	  break_string;
	  if (extra_args_len)
	    break_string = xstrprintf ("*0x%s %s", paddr_nz (high),
				       extra_args);
	  else
	    break_string = xstrprintf ("*0x%s", paddr_nz (high));
	  break_command_1 (break_string, flag, from_tty, NULL);
	  xfree (break_string);
	}
      else
	error ("No function contains the specified address");
    }
  if (sals.nelts > 1)
    {
      warning ("Multiple breakpoints were set.\n");
      warning ("Use the \"delete\" command to delete unwanted breakpoints.");
    }
  do_cleanups (old_chain);
}


a5497 12
break_at_finish_command (char *arg, int from_tty)
{
  break_at_finish_command_1 (arg, 0, from_tty);
}

void
break_at_finish_at_depth_command (char *arg, int from_tty)
{
  break_at_finish_at_depth_command_1 (arg, 0, from_tty);
}

void
a5502 6
void
tbreak_at_finish_command (char *arg, int from_tty)
{
  break_at_finish_command_1 (arg, BP_TEMPFLAG, from_tty);
}

@


1.184
log
@2004-10-29  Andrew Cagney  <cagney@@gnu.org>

	* frame.h (get_selected_frame): Add message parameter.
	* frame.c (get_selected_frame): Add and use message parameter.
	* stack.c (current_frame_command, return_command, locals_info)
	(catch_info, args_info, up_silently_base, down_silently_base): Use
	get_selected_frame with an explicit message.
	* thread.c, stack.c, sh-tdep.c, sh64-tdep.c: Update.
	* remote-rdp.c, remote-mips.c, remote-e7000.c: Update.
	* ocd.c, mi/mi-main.c, mi/mi-cmd-stack.c: Update.
	* infrun.c, inflow.c, infcmd.c, frame.c: Update.
	* findvar.c, eval.c, corelow.c, bsd-kvm.c: Update.
	* breakpoint.c: Update.
@
text
@d404 1
a404 1
      if (TYPE_CODE (VALUE_TYPE (val)) == TYPE_CODE_INT)
d965 1
a965 1
		  struct type *vtype = check_typedef (VALUE_TYPE (v));
d977 2
a978 2
		      addr = VALUE_ADDRESS (v) + VALUE_OFFSET (v);
		      len = TYPE_LENGTH (VALUE_TYPE (v));
d1498 1
a1498 1
	      struct type *vtype = check_typedef (VALUE_TYPE (v));
d1507 2
a1508 2
		  addr = VALUE_ADDRESS (v) + VALUE_OFFSET (v);
		  len = TYPE_LENGTH (VALUE_TYPE (v));
d2751 1
a2751 1
		struct type *vtype = check_typedef (VALUE_TYPE (v));
d2759 1
a2759 1
		    vaddr = VALUE_ADDRESS (v) + VALUE_OFFSET (v);
d2763 1
a2763 1
			addr < vaddr + TYPE_LENGTH (VALUE_TYPE (v)))
d5997 1
a5997 1
	      struct type *vtype = check_typedef (VALUE_TYPE (v));
d6006 2
a6007 2
		  CORE_ADDR vaddr = VALUE_ADDRESS (v) + VALUE_OFFSET (v);
		  int       len   = TYPE_LENGTH (VALUE_TYPE (v));
@


1.183
log
@
2004-10-08  Jeff Johnston  <jjohnstn@@redhat.com>

        * target.h (to_stopped_data_address): Change prototype to
        take a CORE_ADDR pointer and return an int.
        * target.c (update_current_target): Change to_stopped_data_address
        to match new prototype.
        (debug_to_stopped_data_address): Change appropriately.
        * breakpoint.c (bpstat_stop_status): Change call to
        target_stopped_data_address to use new prototype.
        * frv-tdep.c (frv_have_stopped_data_address): New function.
        (frv_stopped_data_address): Change to new prototype and
        functionality.
        * ia64-linux-nat.c (ia64_stopped_data_address): Change to new
        prototype and functionality.
        (ia64_stopped_by_watchpoint): New function.
        * i386-nat.c (i386_stopped_data_address): Change to new
        prototype and functionality.
        (i386_stopped_by_watchpoint): New function.
        * remote.c (remote_stopped_data_address): Change to new prototype
        and functionality.
        * remote-m32r-sdi.c (m32r_stopped_data_address): Ditto.
        * config/frv/tm-frv.h (frv_stopped_data_address): Change prototype.
        (STOPPED_BY_WATCHPOINT): Change to use frv_have_stopped_data_address.
        * config/i386/nm-i386.h (STOPPED_BY_WATCHPOINT): Change to use
        new i386_stopped_by_watchpoint function.
        (i386_stopped_by_watchpoint): New prototype.
        (i386_stoppped_data_address): Change to new prototype.
        * config/ia64/nm-linux.h (STOPPED_BY_WATCHPOINT): Change to use
        new ia64_stopped_by_watchpoint function.
        (ia64_stopped_by_watchpoint): New prototype.
        (ia64_stopped_data_address): Ditto.
@
text
@d7647 1
a7647 1
	  saved_frame_id = get_frame_id (get_selected_frame ());
@


1.182
log
@2004-09-13  Andrew Cagney  <cagney@@gnu.org>

	Eliminate event_loop_p, always has the value 1.
	* defs.h (event_loop_p): Delete macro.
	* breakpoint.c (until_break_command): Simplify.
	* utils.c (prompt_for_continue): Simplify.
	* tracepoint.c (read_actions): Simplify.
	* top.c (throw_exception, execute_command, gdb_readline_wrapper)
	(gdb_rl_operate_and_get_next, command_line_input, get_prompt)
	(set_prompt, init_main): Simplify.
	(init_signals, disconnect): Delete, unused.
	* remote.c (remote_async_resume)
	(extended_remote_async_create_inferior): Simplify.
	* mi/mi-interp.c (mi_input): Delete, unused.
	(mi_interpreter_resume, mi_command_loop): Simplify.
	* interps.c (current_interp_command_loop): Simplify.
	* infrun.c (proceed): Simplify.
	* infcmd.c (run_command, continue_command, step_1, jump_command)
	(until_command, advance_command, finish_command)
	(interrupt_target_command): Simplify.
	* event-top.c (gdb_setup_readline, gdb_disable_readline): Simplify.
@
text
@d2744 1
a2744 2
	addr = target_stopped_data_address ();
	if (addr == 0)
@


1.181
log
@* language.c (local_hex_format_custom): Remove.
(local_hex_string): Rename to hex_string, use C format, and move to
utils.c
(local_hex_string_custom): Rename to hex_string_custom and change
interface.  Now uses C format.  Move to utils.c
(local_octal_format_custom): Remove.
(local_decimal_format_custom): Remove.
(unknown_language_defn): Remove language-specific number
formatting entries.
(auto_language_defn): Ditto.
(local_language_defn): Ditto.
* language.h (struct language_format_info): Delete declaration.
(struct language_defn): Remove language_format_info fields
la_binary_format, la_octal_format, la_decimal_format, la_hex_format.
(local_binary_format): Remove macro.
(local_binary_format_prefix): Remove macro.
(local_binary_format_specifier): Remove macro.
(local_binary_format_suffix): Remove macro.
(local_octal_format): Remove macro.
(local_octal_format_prefix): Remove macro.
(local_octal_format_specifier): Remove macro.
(local_octal_format_suffix): Remove macro.
(local_decimal_format): Remove macro.
(local_decimal_format_prefix): Remove macro.
(local_decimal_format_specifier): Remove macro.
(local_decimal_format_suffix): Remove macro.
(local_hex_format): Remove macro.
(local_hex_format_prefix): Remove macro.
(local_hex_format_specifier): Remove macro.
(local_hex_format_suffix): Remove macro.
(local_decimal_format_custom): Remove.
(local_octal_format_custom): Remove.
(local_hex_format_custom): Remove.
(local_hex_string): Rename to hex_string and move to defs.h.
(local_hex_string_custom): Rename to hex_string_custom, change
interface, and move to defs.h.
* utils.c: (int_string): New function.
(hex_string): New function (from language.c).
(hex_string_custom): New function (from language.c).
(octal2str): New function.
(decimal2str): Add width parameter.
(paddr_u): Use new decimal2str interface.
(paddr_d): Ditto.
* defs.h (hex_string): Declare.
(hex_string_custom): Declare.
(int_string): Declare.
* printcmd.c (print_scalar_formatted): Remove localized binary
formatting.
* valprint.c (print_longest): Use int_string.
(print_floating): Use C hex format.
(print_hex_chars): Ditto.
(print_binary_chars): Remove language-specific formatting.
(print_octal_chars): Use C octal format.
(print_decimal_chars): Delocalize format.
(print_decimal): Remove.
* ada-lang.c (ada_language_defn): Remove language-specific number
formatting entries.
* p-lang.c (pascal_language_defn): Ditto.
* c-lang.c (c_language_defn): Ditto.
(cplus_language_defn): Ditto.
(asm_language_defn): Ditto.
(minimal_language_defn): Ditto.
* f-lang.c (f_language_defn): Ditto.
* jv-lang.c (java_language_defn): Ditto.
* m2-lang.c (m2_language_defn): Ditto.
* scm-lang.c (scm_language_defn): Ditto.
* objc-lang.c (objc_language_defn): Ditto.
* memattr.c (mem_info_command): Use renamed hex_string_custom with
new interface.
* pa64solib.c (pa64_sharedlibrary_info_command): Ditto.
* ui-out.c (ui_out_field_core_addr): Ditto.
* breakpoint.c (breakpoint_adjustment_warning): Ditto.
* exec.c (print_section_info): Ditto.
* i387-tdep.c (print_i387_status_word): Ditto.
(print_i387_control_word): Ditto.
(i387_print_float_info): Ditto.
* maint.c (maint_print_section_info): Ditto.
* solib.c (info_sharedlibrary_command): Ditto.
* somsolib.c (som_sharedlibrary_info_command): Ditto.
* symtab.c (print_msymbol_info): Ditto.
* tracepoint.c (tracepoints_info): Ditto.
* solib-frv.c (lm_base): Ditto.
(frv_current_sos): Ditto.
(enable_break2): Ditto.
(enable_break): Ditto.
* dbxread.c (read_dbx_symtab): Use renamed hex_string.
(process_one_symbol): Ditto.
* infcmd.c (program_info): Ditto.
* mdebugread.c (parse_partial_symbols): Ditto.
* symfile.c (add_symbol_file_command): Ditto.
* cli/cli-cmds.c (edit_command): Ditto.
(list_command): Ditto.
* infcall.c (call_function_by_hand): Ditto.
* remote-vx.c (vx_run_files_info): Ditto.
(vx_wait): Ditto.
(vx_attach): Ditto.
(vx_detach): Ditto.
(vx_kill): Ditto.
* aix-thread.c (pdc_symbol_addrs): Ditto.
(pdc_read_regs): Ditto.
(pdc_write_regs): Ditto.
(pdc_read_data): Ditto.
(pdc_write_data): Ditto.
* d10v-tdep.c (display_trace): Ditto.
* rs6000-nat.c (find_toc_address): Ditto.
* aix-thread.c: Don't include language.h.
* buildsym.c: Ditto.
* dbxread.c: Ditto.
* mdebugread.c: Ditto.
* rs6000-nat.c: Ditto.
* buildsym.c (make_blockvector): Use renamed hex_string.
@
text
@d6126 1
a6126 1
  if (!event_loop_p || !target_can_async_p ())
d6138 1
a6138 1
  if (event_loop_p && target_can_async_p ())
d6160 1
a6160 1
      if (!event_loop_p || !target_can_async_p ())
d6169 1
a6169 1
  if (!event_loop_p || !target_can_async_p ())
@


1.180
log
@
2004-09-01  Jeff Johnston  <jjohnstn@@redhat.com>

        * observer.sh: Add struct so_list declaration.
        * Makefile.in: Add dependencies on observer.h for solib.c and
        breakpoint.c.
        * breakpoint.c (disable_breakpoints_in_unloaded_shlib): New
        function.
        (_initialize_breakpoint): Register
        disable_breakpoints_in_unloaded_shlib as an observer of the
        "solib unloaded" observation event.
        (re_enable_breakpoints_in_shlibs): For bp_shlib_disabled breakpoints,
        call decode_line_1 so unfound breakpoint errors are silent.
        * solib.c (update_solib_list): When a solib is discovered to have
        been unloaded by the program, notify all observers of the
        "solib unloaded" observation event.
@
text
@d3928 2
a3929 2
  strcpy (astr1, local_hex_string_custom ((unsigned long) from_addr, "08l"));
  strcpy (astr2, local_hex_string_custom ((unsigned long) to_addr, "08l"));
@


1.179
log
@2004-07-28  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (add_setshow_zinteger_cmd)
	(add_setshow_cmd, add_setshow_auto_boolean_cmd)
	(add_setshow_boolean_cmd, add_setshow_cmd_full): Add help_doc and
	print parameters.  Make string parameters constant.
	* command.h: Update.  Update copyright.
	* remote.c (add_packet_config_cmd, _initialize_remote): Ditto.
	* observer.c (_initialize_observer): Ditto.
	* frame.c (_initialize_frame): Ditto.
	* complaints.c (_initialize_complaints): Ditto.
	* maint.c (_initialize_maint_cmds): Ditto.
	* target.c (initialize_targets): Ditto.
	* cli/cli-logging.c (_initialize_cli_logging): Ditto.
	* infcall.c (_initialize_infcall): Ditto.
	* arm-tdep.c (_initialize_arm_tdep): Ditto.
	* m32r-rom.c (_initialize_m32r_rom): Ditto.
	* remote-rdi.c (_initialize_remote_rdi): Ditto.
	* d10v-tdep.c (_initialize_d10v_tdep): Ditto.
	* mips-tdep.c (_initialize_mips_tdep): Ditto.
@
text
@d52 2
d4393 40
d7145 2
d7197 7
d7208 2
a7209 1
      sals = decode_line_1 (&s, 1, (struct symtab *) NULL, 0, (char ***) NULL, NULL);
d7810 4
@


1.178
log
@2004-07-26  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (deprecated_add_show_from_set): Deprecate.
	* xcoffsolib.c (_initialize_xcoffsolib): Update.
	* wince.c (_initialize_wince): Update.
	* win32-nat.c (_initialize_win32_nat): Update.
	* varobj.c (_initialize_varobj): Update.
	* valops.c (_initialize_valops): Update.
	* utils.c (initialize_utils, initialize_utils): Update.
	* tui/tui-win.c (_initialize_tui_win): Update.
	* top.c (init_main): Update.
	* symfile.c (_initialize_symfile): Update.
	* source.c (_initialize_source): Update.
	* somsolib.c (_initialize_som_solib): Update.
	* solib.c (_initialize_solib): Update.
	* solib-frv.c (_initialize_frv_solib): Update.
	* serial.c (_initialize_serial): Update.
	* ser-go32.c (_initialize_ser_dos, _initialize_ser_dos): Update.
	* remote.c (_initialize_remote, _initialize_remote): Update.
	* remote-vx.c (_initialize_vx): Update.
	* remote-utils.c (_initialize_sr_support): Update.
	* remote-sds.c (_initialize_remote_sds): Update.
	* remote-mips.c (_initialize_remote_mips): Update.
	* remote-e7000.c (_initialize_remote_e7000): Update.
	* proc-api.c (_initialize_proc_api): Update.
	* printcmd.c: Update.
	* parse.c (_initialize_parse): Update.
	* pa64solib.c (_initialize_pa64_solib): Update.
	* p-valprint.c (_initialize_pascal_valprint): Update.
	* monitor.c (_initialize_remote_monitors): Update.
	* mips-tdep.c (_initialize_mips_tdep): Update.
	* mcore-tdep.c (_initialize_mcore_tdep): Update.
	* maint.c (_initialize_maint_cmds): Update.
	* lin-lwp.c (_initialize_lin_lwp): Update.
	* language.c (_initialize_language): Update.
	* kod.c (_initialize_kod): Update.
	* infrun.c (set_schedlock_func, _initialize_infrun): Update.
	* i386-tdep.c (_initialize_i386_tdep): Update.
	* gdbtypes.c (build_gdbtypes, _initialize_gdbtypes): Update.
	* gdbarch.sh: Update.
	* gdbarch.c: Re-generate.
	* gdb-events.sh: Update.
	* gdb-events.c: Re-generate.
	* frame.c (_initialize_frame): Update.
	* exec.c: Update.
	* demangle.c (_initialize_demangler): Update.
	* dcache.c (_initialize_dcache): Update.
	* cris-tdep.c (_initialize_cris_tdep, cris_version_update): Update.
	* cp-valprint.c (_initialize_cp_valprint): Update.
	* corefile.c (_initialize_core): Update.
	* command.h: Update.
	* cli/cli-decode.h: Update.
	* cli/cli-cmds.c (init_cli_cmds): Update.
	* charset.c (_initialize_charset): Update.
	* breakpoint.c (_initialize_breakpoint): Update.
	* arm-tdep.c (_initialize_arm_tdep_initialize_arm_tdep): Update.
	* alpha-tdep.c (_initialize_alpha_tdep): Update.
	* aix-thread.c (_initialize_aix_thread): Update.
@
text
@d8089 2
a8090 1
Set debugger's behavior regarding pending breakpoints.\n\
d8094 2
a8095 6
user-query to see if a pending breakpoint should be created.","\
Show debugger's behavior regarding pending breakpoints.\n\
If on, an unrecognized breakpoint location will cause gdb to create a\n\
pending breakpoint.  If off, an unrecognized breakpoint location results in\n\
an error.  If auto, an unrecognized breakpoint location results in a\n\
user-query to see if a pending breakpoint should be created.",
@


1.177
log
@2004-07-20  Andrew Cagney  <cagney@@gnu.org>

	* breakpoint.c (deprecated_read_memory_nobpt): Rename
	read_memory_nobpt.
	* sparc-linux-tdep.c (sparc_linux_sigtramp_start): Update.
	* s390-tdep.c (s390_readinstruction, s390_in_function_epilogue_p)
	(s390_sigtramp_frame_sniffer): Update.
	* mn10300-tdep.c (mn10300_analyze_prologue): Update.
	* mipsnbsd-tdep.c (mipsnbsd_sigtramp_offset): Update.
	* mips-tdep.c (mips_fetch_instruction, mips16_fetch_instruction)
	(mips32_fetch_instruction): Update.
	* mcore-tdep.c (get_insn): Update.
	* m68klinux-tdep.c (m68k_linux_pc_in_sigtramp): Update.
	* i386nbsd-tdep.c (i386nbsd_sigtramp_offset): Update.
	* i386ly-tdep.c (i386lynx_saved_pc_after_call): Update.
	* i386-linux-tdep.c (i386_linux_sigtramp_start)
	(i386_linux_rt_sigtramp_start): Update.
	* i386-linux-nat.c (child_resume): Update.
	* hppa-tdep.c (skip_prologue_hard_way, hppa_frame_cache): Update.
	* hppa-linux-tdep.c (insns_match_pattern): Update.
	* gdbcore.h: Update.
	* frv-tdep.c (frv_gdbarch_adjust_breakpoint_address): Update.
	* frame.c (safe_frame_unwind_memory): Update.
	* amd64-linux-tdep.c (amd64_linux_sigtramp_start): Update.
	* alphanbsd-tdep.c (alphanbsd_sigtramp_offset): Update.
	* alpha-tdep.c (alpha_read_insn): Update.
@
text
@d8071 1
a8071 1
  add_show_from_set (c, &showlist);
@


1.176
log
@2004-06-26  Andrew Cagney  <cagney@@gnu.org>

	* xcoffsolib.c (xcoff_solib_address): Replace xasprintf with
	xstrprintf.
	* varobj.c (varobj_gen_name, create_child, c_name_of_child)
	(c_value_of_variable): Ditto.
	* utils.c (internal_vproblem): Ditto.
	* solib-aix5.c (build_so_list_from_mapfile): Ditto.
	* remote.c (add_packet_config_cmd): Ditto.
	* remote-rdp.c (rdp_set_command_line): Ditto.
	* regcache.c (regcache_dump): Ditto.
	* frv-tdep.c (new_variant, new_variant): Ditto.
	* fbsd-proc.c (child_pid_to_exec_file): Ditto.
	(fbsd_find_memory_regions): Ditto.
	* breakpoint.c (create_thread_event_breakpoint)
	(create_breakpoints): Ditto.
	* aix-thread.c (aix_thread_pid_to_str): Ditto.
	* ada-lang.c (is_package_name): Ditto.  Also delete xmalloc call.

Index: doc/ChangeLog
2004-06-26  Andrew Cagney  <cagney@@gnu.org>

	* gdbint.texinfo (Coding): Replace xasprintf with xstrprintf.
@
text
@d630 1
a630 1
read_memory_nobpt (CORE_ADDR memaddr, char *myaddr, unsigned len)
d698 1
a698 1
	  status = read_memory_nobpt (memaddr, myaddr, bp_addr - memaddr);
d706 1
a706 1
	  status = read_memory_nobpt (bp_addr + bp_size,
@


1.175
log
@
2004-06-22  Jeff Johnston  <jjohnstn@@redhat.com>

        * infrun.c (handle_inferior_event): Initialize stopped_by_watchpoint
        to -1.
        * breakpoint.c (bpstat_stop_status): Move check for ignoring
        untriggered watchpoints to a separate if clause.  Update function
        comment regarding STOPPED_BY_WATCHPOINT argument.
@
text
@d4261 1
a4261 1
  xasprintf (&b->addr_string, "*0x%s", paddr (b->loc->address));
d4905 1
a4905 1
	  xasprintf (&b->addr_string, "*0x%s", paddr (b->loc->address));
@


1.174
log
@2004-06-07  Andrew Cagney  <cagney@@gnu.org>

	* target.h (PC_REQUIRES_RUN_BEFORE_USE): Delete definition.
	* config/pa/tm-hppa.h (DEPRECATED_PC_REQUIRES_RUN_BEFORE_USE):
	Rename PC_REQUIRES_RUN_BEFORE_USE.
	* breakpoint.c (breakpoint_sals_to_pc): Update.  Wrap reference in
	#ifdef.
@
text
@d2562 3
a2564 2
   BP_ADDR in thread PTID.  STOPPED_BY_WATCHPOINT is true if the
   target thinks we stopped due to a hardware watchpoint.  */
a2596 4
    /* Hardware watchpoints are treated as non-existent if the reason we 
       stopped wasn't a hardware watchpoint (we didn't stop on some data 
       address).  Otherwise gdb won't stop on a break instruction in the code
       (not from a breakpoint) when a hardware watchpoint has been defined.  */
d2598 3
a2600 4
	&& !((b->type == bp_hardware_watchpoint
	      || b->type == bp_read_watchpoint
	      || b->type == bp_access_watchpoint)
	     && stopped_by_watchpoint)
d2616 12
@


1.173
log
@	* breakpoint.c (bpstat_stop_status): Add new argument
	STOPPED_BY_WATCHPOINT.  Use it instead of testing
	target_stopped_data_address agaist 0 to check whether
	or not we stopped due to a hardware watchpoint.
	* breakpoint.h (bpstat_stop_status): Adapt prototype.
	* infrun.c (handle_inferior_event): Call bpstat_stop_status
	with new argument.
@
text
@d5028 2
a5029 1
      if (PC_REQUIRES_RUN_BEFORE_USE (sals->sals[i].pc))
d5037 1
@


1.172
log
@2004-05-08  Andrew Cagney  <cagney@@redhat.com>

	* breakpoint.h (deprecated_frame_in_dummy): Delete declaration.
	(struct frame_info): Delete opaque declaration.
	* breakpoint.c (deprecated_frame_in_dummy): Delete function.
	* frame.c (get_frame_type): Delete call.
@
text
@d2562 2
a2563 1
   BP_ADDR.  */
d2580 1
a2580 1
bpstat_stop_status (CORE_ADDR bp_addr, ptid_t ptid)
d2604 1
a2604 1
	     && target_stopped_data_address () != 0)
@


1.171
log
@Preserve the ignore count when we resolve a pending breakpoint.  Also add
a test for this to pending.exp.
@
text
@a1769 31
/* Return nonzero if FRAME is a dummy frame.  We can't use
   DEPRECATED_PC_IN_CALL_DUMMY because figuring out the saved SP would
   take too much time, at least using frame_register() on the 68k.
   This means that for this function to work right a port must use the
   bp_call_dummy breakpoint.  */

int
deprecated_frame_in_dummy (struct frame_info *frame)
{
  struct breakpoint *b;

  /* This function is used by two files: get_frame_type(), after first
     checking that !DEPRECATED_USE_GENERIC_DUMMY_FRAMES; and
     sparc-tdep.c, which doesn't yet use generic dummy frames anyway.  */
  gdb_assert (!DEPRECATED_USE_GENERIC_DUMMY_FRAMES);

  ALL_BREAKPOINTS (b)
  {
    if (b->type == bp_call_dummy
	&& frame_id_eq (b->frame_id, get_frame_id (frame))
    /* We need to check the PC as well as the frame on the sparc,
       for signals.exp in the testsuite.  */
	&& (get_frame_pc (frame)
	    >= (b->loc->address
		- DEPRECATED_SIZEOF_CALL_DUMMY_WORDS / sizeof (LONGEST) * DEPRECATED_REGISTER_SIZE))
	&& get_frame_pc (frame) <= b->loc->address)
      return 1;
  }
  return 0;
}

@


1.170
log
@2004-05-01  Andrew Cagney  <cagney@@redhat.com>

	* breakpoint.c (insert_bp_location): Use get_frame_id, and
	frame_find_by_id instead of frame_relative_level.
	(do_enable_breakpoint): Ditto.
	* thread.c: Update copyright.
	(info_threads_command): Ditto, simplify.
@
text
@d4951 4
@


1.169
log
@2004-05-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_PC_IN_SIGTRAMP): Delete.
	* gdbarch.h, gdbarch.c: Re-generate.
	* shnbsd-tdep.c (shnbsd_init_abi): Do not set pc_in_sigtramp.
	(shnbsd_pc_in_sigtramp): Delete.
	* i386-interix-tdep.c (i386_interix_init_abi): Do not set
	pc_in_sigtramp.
	* hppa-hpux-tdep.c (hppa_hpux_init_abi): Do not set
	pc_in_sigtramp.
	* frame.h: Update comments.
	* ppc-linux-tdep.c: Update comments.
	* breakpoint.c (bpstat_what): Update comments.

Index: doc/ChangeLog
2004-05-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	description of DEPRECATED_PC_IN_SIGTRAMP.
@
text
@d913 1
a913 2
      struct frame_info *saved_frame;
      int saved_level, within_current_scope;
d916 1
d918 1
a918 1
      /* Save the current frame and level so we can restore it after
d923 1
a923 2
      saved_frame = deprecated_selected_frame;
      saved_level = frame_relative_level (deprecated_selected_frame);
d1020 2
a1021 4
      /* Restore the frame and level.  */
      if (saved_frame != deprecated_selected_frame
	  || saved_level != frame_relative_level (deprecated_selected_frame))
	select_frame (saved_frame);
a7563 2
  struct frame_info *save_selected_frame = NULL;
  int save_selected_frame_level = -1;
d7610 3
a7624 3
	      
	      save_selected_frame = deprecated_selected_frame;
	      save_selected_frame_level = frame_relative_level (deprecated_selected_frame);
d7659 1
a7659 2
	  if (save_selected_frame_level >= 0)
	    select_frame (save_selected_frame);
@


1.168
log
@2004-04-26  Orjan Friberg <orjanf@@axis.com>

	From Paul Koning <pkoning@@equallogic.com>:
	* breakpoint.c (free_valchain): New function.
	(insert_bp_location, delete_breakpoint): Use free_valchain.
	(remove_breakpoint): Do not remove the valchain.
	(bpstat_stop_status): If not stopped by watchpoint, skip
	watchpoints when generating stop status list.
	* infrun.c (handle_inferior_event): Make
	stepped_after_stopped_by_watchpoint a global variable.
	* remote.c (remote_stopped_data_address): Return watch data
	address rather than zero if stepped_after_stopped_by_watchpoint is
	set.
@
text
@d3035 1
a3035 2
     at first DEPRECATED_PC_IN_SIGTRAMP where we set the step_resume
     breakpoint).  */
@


1.167
log
@2004-04-21  Andrew Cagney  <cagney@@redhat.com>

	* annotate.h (deprecated_annotate_starting_hook)
	(deprecated_annotate_stopped_hook)
	(deprecated_annotate_exited_hook)
	(deprecated_annotate_signal_hook)
	(deprecated_annotate_signalled_hook): Deprecate.
	* tracepoint.h (deprecated_create_tracepoint_hook)
	(deprecated_delete_tracepoint_hook)
	(deprecated_modify_tracepoint_hook)
	(deprecated_trace_find_hook)
	(deprecated_trace_start_stop_hook): Deprecate.
	* target.h (deprecated_target_new_objfile_hook): Deprecate.
	* remote.h (deprecated_target_resume_hook)
	(deprecated_target_wait_loop_hook): Deprecate.
	* gdbcore.h (deprecated_exec_file_display_hook)
	(deprecated_file_changed_hook): Deprecate.
	* frame.h (deprecated_selected_frame_level_changed_hook): Deprecate.
	* defs.h (deprecated_modify_breakpoint_hook)
	(deprecated_command_loop_hook, deprecated_show_load_progress)
	(deprecated_print_frame_info_listing_hook)
	(deprecated_query_hook, deprecated_warning_hook)
	(deprecated_flush_hook, deprecated_create_breakpoint_hook)
	(deprecated_delete_breakpoint_hook)
	(deprecated_interactive_hook, deprecated_registers_changed_hook)
	(deprecated_readline_begin_hook, deprecated_readline_hook)
	(deprecated_readline_end_hook, deprecated_register_changed_hook)
	(deprecated_memory_changed_hook, deprecated_init_ui_hook)
	(deprecated_context_hook, deprecated_target_wait_hook)
	(deprecated_attach_hook, deprecated_detach_hook)
	(deprecated_call_command_hook, deprecated_set_hook)
	(deprecated_error_hook, deprecated_error_begin_hook)
	(deprecated_ui_load_progress_hook): Deprecate.
	* valops.c, uw-thread.c, utils.c, tui/tui-io.c: Update.
	* tui/tui-hooks.c, tracepoint.c, top.c, thread-db.c: Update.
	* target.c, symfile.c, stack.c, sol-thread.c, rs6000-nat.c: Update.
	* remote.c, remote-mips.c, regcache.c, mi/mi-interp.c: Update.
	* main.c, interps.c, infcmd.c, hpux-thread.c, frame.c: Update.
	* exec.c, dsrec.c, d10v-tdep.c, corefile.c, complaints.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, breakpoint.c: Update.
	* annotate.c, aix-thread.c: Update.
@
text
@d749 17
d940 2
a1526 9

      /* Free the saved value chain.  We will construct a new one
         the next time the watchpoint is inserted.  */
      for (v = b->owner->val_chain; v; v = n)
	{
	  n = v->next;
	  value_free (v);
	}
      b->owner->val_chain = NULL;
d2629 4
d2634 4
a2637 3
	&& b->type != bp_hardware_watchpoint
	&& b->type != bp_read_watchpoint
	&& b->type != bp_access_watchpoint
d6898 2
@


1.166
log
@2004-04-08  Andrew Cagney  <cagney@@redhat.com>

	* breakpoint.h (deprecated_exception_catchpoints_are_fragile)
	(deprecated_exception_support_initialized): Declare.
	* hppa-hpux-tdep.c (initialize_hp_cxx_exception_support)
	(initialize_hp_cxx_exception_support)
	(child_enable_exception_callback): Update.
	* breakpoint.c (deprecated_exception_catchpoints_are_fragile)
	(deprecated_exception_support_initialized): Rename
	deprecated_exception_catchpoints_are_fragile and
	deprecated_exception_support_initialized.
	(breakpoint_init_inferior, breakpoint_init_inferior): Update.

	* symtab.c (deprecated_hp_som_som_object_present): Rename
	hp_som_som_object_present.
	* symtab.h (deprecated_hp_som_som_object_present): Declare.
	* symfile.c (hp_som_som_object_present, RESET_HP_UX_GLOBALS):
	Update.  Delete extern declaration.
	* valops.c (hp_som_som_object_present): Ditto.
	* parse.c (deprecated_hp_som_som_object_present)
	(parse_nested_classes_for_hpacc): Ditto.
	* hpread.c (hp_som_som_object_present, hpread_expand_symtab): Ditto.
	* hppa-hpux-tdep.c (hp_som_som_object_present)
	(initialize_hp_cxx_exception_support): Ditto.
	* eval.c (hp_som_som_object_present, evaluate_subexp_standard): Ditto.
	* cp-valprint.c (hp_som_som_object_present)
	(cp_print_class_method): Ditto.
	* c-typeprint.c (hp_som_som_object_present):
	(c_type_print_base): Ditto.
	* c-exp.y (hp_som_som_object_present): Ditto.
@
text
@d4726 7
a4732 7
  /* FIXME: This is misplaced; mention() is called by things (like hitting a
     watchpoint) other than breakpoint creation.  It should be possible to
     clean this up and at the same time replace the random calls to
     breakpoint_changed with this hook, as has already been done for
     delete_breakpoint_hook and so on.  */
  if (create_breakpoint_hook)
    create_breakpoint_hook (b);
d6877 2
a6878 2
  if (delete_breakpoint_hook)
    delete_breakpoint_hook (bpt);
d7510 2
a7511 2
  if (modify_breakpoint_hook)
    modify_breakpoint_hook (bpt);
d7654 2
a7655 2
  if (modify_breakpoint_hook)
    modify_breakpoint_hook (bpt);
@


1.165
log
@2004-03-23  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (PC_IN_SIGTRAMP): Change to a function with
	predicate, deprecate.
	* gdbarch.h, gdbarch.c: Re-generate.
	* alpha-linux-tdep.c (alpha_linux_init_abi): Update.
	* alpha-osf1-tdep.c (alpha_osf1_init_abi): Update.
	* alpha-tdep.c (alpha_sigtramp_frame_sniffer): Update.
	* alphafbsd-tdep.c (alphafbsd_init_abi): Update.
	* alphanbsd-tdep.c (alphanbsd_init_abi): Update.
	* amd64-linux-tdep.c (amd64_linux_init_abi): Update.
	* amd64-tdep.c (amd64_sigtramp_frame_sniffer): Update.
	* amd64nbsd-tdep.c (amd64nbsd_init_abi): Update.
	* amd64obsd-tdep.c (amd64obsd_init_abi): Update.
	* arm-tdep.c (arm_sigtramp_unwind_sniffer): Update.
	* blockframe.c (find_pc_partial_function): Update.
	* breakpoint.c (bpstat_what): Update.
	* frame.c (frame_type_from_pc, legacy_get_prev_frame): Update.
	* frv-linux-tdep.c (frv_linux_init_abi): Update.
	* frv-tdep.c (frv_sigtramp_frame_sniffer): Update.
	* hppa-hpux-tdep.c (hppa_hpux_init_abi): Update.
	* i386-interix-tdep.c (i386_interix_init_abi): Update.
	* i386-linux-tdep.c (i386_linux_init_abi): Update.
	* i386-nto-tdep.c (i386nto_init_abi): Update.
	* i386-sol2-tdep.c (i386_sol2_init_abi): Update.
	* i386-tdep.c (i386_sigtramp_frame_sniffer)
	(i386_svr4_init_abi, i386_go32_init_abi, i386_gdbarch_init): Update.
	* i386bsd-tdep.c (i386bsd_init_abi): Update.
	* i386nbsd-tdep.c (i386nbsd_init_abi): Update.
	* i386obsd-tdep.c (i386obsd_init_abi): Update.
	* ia64-tdep.c (ia64_sigtramp_frame_sniffer): Update.
	* infrun.c (pc_in_sigtramp): Update.
	* m68k-tdep.c (m68k_sigtramp_frame_sniffer): Update.
	* m68klinux-tdep.c (m68k_linux_init_abi): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mipsnbsd-tdep.c (mipsnbsd_init_abi): Update.
	* ppc-linux-tdep.c: Update comment.
	* ppcnbsd-tdep.c (ppcnbsd_init_abi): Update.
	* shnbsd-tdep.c (shnbsd_init_abi): Update.
	* sparc-linux-tdep.c (sparc32_linux_init_abi): Update.
	* sparc-sol2-tdep.c (sparc32_sol2_init_abi): Update.
	* sparc64-sol2-tdep.c (sparc64_sol2_init_abi): Update.
	* sparc64fbsd-tdep.c (sparc64fbsd_init_abi): Update.
	* sparc64nbsd-tdep.c (sparc64nbsd_init_abi): Update.
	* sparc64obsd-tdep.c (sparc64obsd_init_abi): Update.
	* sparcnbsd-tdep.c (sparc32nbsd_init_abi): Update.
	* sparcobsd-tdep.c (sparc32obsd_init_abi): Update.

Index: doc/ChangeLog
2004-03-23  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Deprecate
	references to PC_IN_SIGTRAMP.
@
text
@d269 3
a271 3
/* Indicator of whether exception catchpoints should be nuked
   between runs of a program */
int exception_catchpoints_are_fragile = 0;
d274 2
a275 2
   reinitialized -- e.g. when program is re-run */
int exception_support_initialized = 0;
d1639 2
a1640 2
	if (ep_is_exception_catchpoint (b) &&
	    exception_catchpoints_are_fragile)
d1649 2
a1650 2
  if (exception_catchpoints_are_fragile)
    exception_support_initialized = 0;
@


1.165.2.1
log
@2004-03-23  Elena Zannoni  <ezannoni@@redhat.com>

       * solib-svr4.c (svr4_solib_create_inferior_hook): Disable
       breakpoints at startup.
       (elf_locate_base): Find out where the entry point for the program
       is, using the auxv vector, if possible. Compute the address of
       .dynamic using it.
       (svr4_current_sos): Don't ignore the first entry if we have PIE,
       it's our main program. Delete code that was skipping over the
       solib entry for main executable.
       * solist.h (struct so_list): Add fields main and main_relocated.
        (add_to_target_sections): Export.
       * solib.c (symbol_add_stub): Handle main executable in shared
       library list. Ignore it if it has been relocated already. Add it
       as the main symbol file, otherwise.
       * infrun.c (handle_inferior_event): Re-enable startup breakpoints.

       * solib-svr4.c (elf_locate_base, first_link_map_member)
       svr4_current_sos, enable_break): Add debugging output.
       * solist.h (debug_solib): Export.
       * solib.c (debug_solib): New variable to enable debugging output.
       (symbol_add_stub, update_solib_list, update_solib_list)
       (add_to_target_sections): Add debugging output.
       (_initialize_solib): Add new comand to enable printing of
       debugging output.
       (add_to_target_sections): New function. Factored out from
       update_solib_list.
       (update_solib_list): Call add_to_target_sections.

       * varobj.h (varobj_refresh): New prototype.
       * varobj.c (varobj_refresh): New function.
       * symfile.c (reread_symbols): Make sure that we recompute the
       entry point for the program.
       (symbol_file_clear): Clear the solibs as well, if we change symbol
       files.
       (clear_symtab_users): Refresh the varobjs that depend on the symtabs
       we are clearing.
       * objfiles.c (entry_point_address): Rewrite, to fetch entry point
       from auxv vector, if possible.
       Add include of elf/common.h.
       * breakpoint.h (enum bptype): Add bp type bp_startup_disabled.
       (re_enable_breakpoints_at_startup)
       (disable_breakpoints_at_startup): Add prototypes
       * breakpoint.c (re_enable_breakpoints_at_startup)
       (disable_breakpoints_at_startup): New functions.
       (describe_other_breakpoints, delete_breakpoint)
       (breakpoint_re_set_one): Handle new bp type.
       * auxv.h (target_auxv_parse, target_auxv_search): Update.
       * auxv.c (target_auxv_parse, target_auxv_search)
       (fprint_target_auxv): Use ULONGEST instead of CORE_ADDR for
       variable. Change variable name to at_type.
@
text
@a3795 1
				 b->enable_state == bp_startup_disabled || 
a4429 56
void
disable_breakpoints_at_startup (int silent)
{
  struct breakpoint *b;
  int disabled_startup_breaks = 0;

  if (bfd_get_start_address (exec_bfd) != entry_point_address ())
    {
      ALL_BREAKPOINTS (b)
	{
	  if (((b->type == bp_breakpoint) ||
	       (b->type == bp_hardware_breakpoint)) &&
	      b->enable_state == bp_enabled &&
	      !b->loc->duplicate)
	    {
	      b->enable_state = bp_startup_disabled;
	      if (!silent)
		{
		  if (!disabled_startup_breaks)
		    {
		      target_terminal_ours_for_output ();
		      warning ("Temporarily disabling breakpoints:");
		    }
		  disabled_startup_breaks = 1;
		  warning ("breakpoint #%d addr 0x%s", b->number, paddr_nz(b->loc->address));
		}
	    }
	}
    }
}

/* Try to reenable any breakpoints after startup.  */
void
re_enable_breakpoints_at_startup (void)
{
  struct breakpoint *b;

  if (bfd_get_start_address (exec_bfd) != entry_point_address ())
    {
      ALL_BREAKPOINTS (b)
	if (b->enable_state == bp_startup_disabled)
	  {
	    char buf[1];

	    /* Do not reenable the breakpoint if the shared library
	       is still not mapped in.  */
	    if (target_read_memory (b->loc->address, buf, 1) == 0)
	      {
		/*printf ("enabling breakpoint at 0x%s\n", paddr_nz(b->loc->address));*/
		b->enable_state = bp_enabled;
	      }
	  }
    }
}


a6942 1
	    && b->enable_state != bp_startup_disabled
d7154 1
a7154 2
      if (b->enable_state != bp_shlib_disabled
          || b->enable_state != bp_shlib_disabled)
@


1.164
log
@	* breakpoint.c (adjust_breakpoint_address): Don't adjust
	breakpoint address for watchpoints or the catch eventpoints.
	Add new paramter ``bptype''.  Adjust all callers.
@
text
@d3020 2
a3021 1
     at first PC_IN_SIGTRAMP where we set the step_resume breakpoint).  */
@


1.163
log
@	* breakpoint.c (TARGET_REGION_SIZE_OK_FOR_HW_WATCHPOINT): Delete
	unused macro definition.  The definition in target.h (or perhaps
	elsewhere) takes precedence.
@
text
@d102 2
a103 1
static CORE_ADDR adjust_breakpoint_address (CORE_ADDR bpaddr);
d3951 1
a3951 1
adjust_breakpoint_address (CORE_ADDR bpaddr)
d3958 12
d4078 2
a4079 1
  b->loc->address = adjust_breakpoint_address (b->loc->requested_address);
d4639 2
a4640 1
      b->loc->address = adjust_breakpoint_address (b->loc->requested_address);
d5897 2
a5898 1
	    = adjust_breakpoint_address (scope_breakpoint->loc->requested_address);
d7204 2
a7205 1
	        = adjust_breakpoint_address (b->loc->requested_address);
@


1.162
log
@2004-02-28  Andrew Cagney  <cagney@@redhat.com>

	* breakpoint.c (_initialize_breakpoint): Use
	"add_setshow_auto_boolean_cmd.  Better word-wrap help messages.
	Add help to show command.
@
text
@a5896 5
#if !defined(TARGET_REGION_SIZE_OK_FOR_HW_WATCHPOINT)
#define TARGET_REGION_SIZE_OK_FOR_HW_WATCHPOINT(BYTE_SIZE) \
    ((BYTE_SIZE) <= (DEPRECATED_REGISTER_SIZE))
#endif

@


1.162.2.1
log
@2004-06-12  Andrew Cagney  <cagney@@gnu.org>

	Import from mainline:
	2004-05-05  Jim Ingham  <jingham@@apple.com>
	* breakpoint.c (create_breakpoints): Copy the ignore count and
	thread id over from the pended breakpoint to the actual
	breakpoint.
@
text
@a4923 4
	    
	    /* We have to copy over the ignore_count and thread as well.  */
	    b->ignore_count = pending_bp->ignore_count;
	    b->thread = pending_bp->thread;
@


1.162.4.1
log
@Merge with mainline cagney_tramp-20040321-mergepoint.
@
text
@d102 1
a102 2
static CORE_ADDR adjust_breakpoint_address (CORE_ADDR bpaddr,
                                            enum bptype bptype);
d3950 1
a3950 1
adjust_breakpoint_address (CORE_ADDR bpaddr, enum bptype bptype)
a3956 12
  else if (bptype == bp_watchpoint
           || bptype == bp_hardware_watchpoint
           || bptype == bp_read_watchpoint
           || bptype == bp_access_watchpoint
           || bptype == bp_catch_fork
           || bptype == bp_catch_vfork
           || bptype == bp_catch_exec)
    {
      /* Watchpoints and the various bp_catch_* eventpoints should not
         have their addresses modified.  */
      return bpaddr;
    }
d4065 1
a4065 2
  b->loc->address = adjust_breakpoint_address (b->loc->requested_address,
                                               bptype);
d4625 1
a4625 2
      b->loc->address = adjust_breakpoint_address (b->loc->requested_address,
                                                   b->type);
d5882 1
a5882 2
	    = adjust_breakpoint_address (scope_breakpoint->loc->requested_address,
	                                 scope_breakpoint->type);
d5897 5
d7193 1
a7193 2
	        = adjust_breakpoint_address (b->loc->requested_address,
		                             b->type);
@


1.161
log
@
2004-02-26  Jeff Johnston  <jjohnstn@@redhat.com>

        * breakpoint.c (pending_break_support): New setting variable.
        (break_command_1): Account for pending_break_support setting
        when creating pending breakpoints.
        (set_breakpoint_cmd, show_breakpoint_cmd): New functions.
        (_initialize_breakpoint): Add "set breakpoint pending" and
        "show breakpoint pending" commands.
@
text
@d8081 14
a8094 9
  add_setshow_cmd ("pending", no_class, var_auto_boolean,
		   (char *) &pending_break_support,
		   "Set debugger's behavior regarding pending breakpoints.\n\
If on, an unrecognized breakpoint location will cause gdb to create a pending\n\
breakpoint.  If off, an unrecognized breakpoint location results in an error.\n\
If auto, an unrecognized breakpoint location results in a user-query to see if\n\
a pending breakpoint should be created.","\
Show debugger's behavior regarding pending breakpoints.",
		   NULL, NULL, &breakpoint_set_cmdlist, &breakpoint_show_cmdlist);
@


1.160
log
@
2004-02-23  Jeff Johnston  <jjohnstn@@redhat.com>

        * breakpoint.c (print_one_breakpoint): Do not output spaces
        after printing <PENDING> for a pending breakpoint.
@
text
@d215 6
d5106 10
a5115 1
	  if (!nquery ("Make breakpoint pending on future shared library load? "))
d5117 5
d7713 10
d7747 2
d8067 25
@


1.159
log
@
2004-02-23  Jeff Johnston  <jjohnstn@@redhat.com>

        * defs.h (nquery, yquery): New prototypes.
        * breakpoint.c (break_command_1): Use new nquery interface.
        * utils.c (defaulted_query, nquery, yquery): New functions.
@
text
@d3474 1
a3474 7
	      {
		ui_out_field_string (uiout, "addr", "<PENDING>");
		if (TARGET_ADDR_BIT <= 32)
		  ui_out_spaces (uiout, 2);
		else
		  ui_out_spaces (uiout, 8);
	      }
@


1.158
log
@
2004-02-03  Jeff Johnston  <jjohnstn@@redhat.com>

        * breakpoint.c (struct captured_parse_breakpoint_args):  Move
        outside of #ifdef SOLIB_ADD region.
        (do_restore_lang_radix_cleanup): Ditto.
        (resolve_pending_breakpoint): Ditto.
@
text
@d5106 1
a5106 1
	  if (!query ("Make breakpoint pending on future shared library load? "))
@


1.158.4.1
log
@Merge mainline to intercu branch.
@
text
@d102 1
a102 2
static CORE_ADDR adjust_breakpoint_address (CORE_ADDR bpaddr,
                                            enum bptype bptype);
a214 6
/* If AUTO_BOOLEAN_FALSE, gdb will not attempt to create pending breakpoints.
   If AUTO_BOOLEAN_TRUE, gdb will automatically create pending breakpoints
   for unrecognized breakpoint locations.  
   If AUTO_BOOLEAN_AUTO, gdb will query when breakpoints are unrecognized.  */
static enum auto_boolean pending_break_support;

d3013 1
a3013 2
     at first DEPRECATED_PC_IN_SIGTRAMP where we set the step_resume
     breakpoint).  */
d3474 7
a3480 1
	      ui_out_field_string (uiout, "addr", "<PENDING>");
d3950 1
a3950 1
adjust_breakpoint_address (CORE_ADDR bpaddr, enum bptype bptype)
a3956 12
  else if (bptype == bp_watchpoint
           || bptype == bp_hardware_watchpoint
           || bptype == bp_read_watchpoint
           || bptype == bp_access_watchpoint
           || bptype == bp_catch_fork
           || bptype == bp_catch_vfork
           || bptype == bp_catch_exec)
    {
      /* Watchpoints and the various bp_catch_* eventpoints should not
         have their addresses modified.  */
      return bpaddr;
    }
d4065 1
a4065 2
  b->loc->address = adjust_breakpoint_address (b->loc->requested_address,
                                               bptype);
d4625 1
a4625 2
      b->loc->address = adjust_breakpoint_address (b->loc->requested_address,
                                                   b->type);
d5106 1
a5106 10

	  /* If pending breakpoint support is turned off, throw error.  */

	  if (pending_break_support == AUTO_BOOLEAN_FALSE)
	    throw_exception (RETURN_ERROR);

          /* If pending breakpoint support is auto query and the user selects 
	     no, then simply return the error code.  */
	  if (pending_break_support == AUTO_BOOLEAN_AUTO && 
	      !nquery ("Make breakpoint pending on future shared library load? "))
a5107 5

	  /* At this point, either the user was queried about setting a 
	     pending breakpoint and selected yes, or pending breakpoint 
	     behavior is on and thus a pending breakpoint is defaulted 
	     on behalf of the user.  */
d5868 1
a5868 2
	    = adjust_breakpoint_address (scope_breakpoint->loc->requested_address,
	                                 scope_breakpoint->type);
d5883 5
d7179 1
a7179 2
	        = adjust_breakpoint_address (b->loc->requested_address,
		                             b->type);
a7698 10
static void
set_breakpoint_cmd (char *args, int from_tty)
{
}

static void
show_breakpoint_cmd (char *args, int from_tty)
{
}

a7722 2
  static struct cmd_list_element *breakpoint_set_cmdlist;
  static struct cmd_list_element *breakpoint_show_cmdlist;
a8040 30

  add_prefix_cmd ("breakpoint", class_maintenance, set_breakpoint_cmd, "\
Breakpoint specific settings\n\
Configure various breakpoint-specific variables such as\n\
pending breakpoint behavior",
		  &breakpoint_set_cmdlist, "set breakpoint ",
		  0/*allow-unknown*/, &setlist);
  add_prefix_cmd ("breakpoint", class_maintenance, show_breakpoint_cmd, "\
Breakpoint specific settings\n\
Configure various breakpoint-specific variables such as\n\
pending breakpoint behavior",
		  &breakpoint_show_cmdlist, "show breakpoint ",
		  0/*allow-unknown*/, &showlist);

  add_setshow_auto_boolean_cmd ("pending", no_class, &pending_break_support, "\
Set debugger's behavior regarding pending breakpoints.\n\
If on, an unrecognized breakpoint location will cause gdb to create a\n\
pending breakpoint.  If off, an unrecognized breakpoint location results in\n\
an error.  If auto, an unrecognized breakpoint location results in a\n\
user-query to see if a pending breakpoint should be created.","\
Show debugger's behavior regarding pending breakpoints.\n\
If on, an unrecognized breakpoint location will cause gdb to create a\n\
pending breakpoint.  If off, an unrecognized breakpoint location results in\n\
an error.  If auto, an unrecognized breakpoint location results in a\n\
user-query to see if a pending breakpoint should be created.",
				NULL, NULL,
				&breakpoint_set_cmdlist,
				&breakpoint_show_cmdlist);

  pending_break_support = AUTO_BOOLEAN_AUTO;
@


1.158.4.2
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@a51 2
#include "solist.h"
#include "observer.h"
d269 3
a271 3
/* Indicator of whether exception catchpoints should be nuked between
   runs of a program.  */
int deprecated_exception_catchpoints_are_fragile = 0;
d274 2
a275 2
   reinitialized -- e.g. when program is re-run.  */
int deprecated_exception_support_initialized = 0;
d630 1
a630 1
deprecated_read_memory_nobpt (CORE_ADDR memaddr, char *myaddr, unsigned len)
d698 1
a698 1
	  status = deprecated_read_memory_nobpt (memaddr, myaddr, bp_addr - memaddr);
d706 1
a706 1
	  status = deprecated_read_memory_nobpt (bp_addr + bp_size,
a748 17
/* Helper routine: free the value chain for a breakpoint (watchpoint).  */

static void free_valchain (struct bp_location *b)
{
  struct value *v;
  struct value *n;

  /* Free the saved value chain.  We will construct a new one
     the next time the watchpoint is inserted.  */
  for (v = b->owner->val_chain; v; v = n)
    {
      n = v->next;
      value_free (v);
    }
  b->owner->val_chain = NULL;
}

d896 2
a897 1
      int within_current_scope;
a899 1
      struct frame_id saved_frame_id;
d901 1
a901 1
      /* Save the current frame's ID so we can restore it after
d906 2
a907 1
      saved_frame_id = get_frame_id (deprecated_selected_frame);
a922 2
	  free_valchain (bpt);

d1002 4
a1005 2
      /* Restore the selected frame.  */
      select_frame (frame_find_by_id (saved_frame_id));
d1508 9
d1639 2
a1640 2
	if (ep_is_exception_catchpoint (b)
	    && deprecated_exception_catchpoints_are_fragile)
d1649 2
a1650 2
  if (deprecated_exception_catchpoints_are_fragile)
    deprecated_exception_support_initialized = 0;
d1763 31
d2586 1
a2586 3
   BP_ADDR in thread PTID.  STOPPED_BY_WATCHPOINT is 1 if the
   target thinks we stopped due to a hardware watchpoint, 0 if we
   know we did not trigger a hardware watchpoint, and -1 if we do not know.  */
d2603 1
a2603 1
bpstat_stop_status (CORE_ADDR bp_addr, ptid_t ptid, int stopped_by_watchpoint)
a2637 12
    /* Continuable hardware watchpoints are treated as non-existent if the 
       reason we stopped wasn't a hardware watchpoint (we didn't stop on 
       some data address).  Otherwise gdb won't stop on a break instruction 
       in the code (not from a breakpoint) when a hardware watchpoint has 
       been defined.  */

    if ((b->type == bp_hardware_watchpoint
	 || b->type == bp_read_watchpoint
	 || b->type == bp_access_watchpoint)
	&& !stopped_by_watchpoint)
      continue;

d3020 2
a3021 1
     at where we set the step_resume breakpoint).  */
d3937 2
a3938 2
  strcpy (astr1, hex_string_custom ((unsigned long) from_addr, 8));
  strcpy (astr2, hex_string_custom ((unsigned long) to_addr, 8));
d4272 1
a4272 1
  b->addr_string = xstrprintf ("*0x%s", paddr (b->loc->address));
a4401 40
/* Disable any breakpoints that are in in an unloaded shared library.  Only
   apply to enabled breakpoints, disabled ones can just stay disabled.  */

void
disable_breakpoints_in_unloaded_shlib (struct so_list *solib)
{
  struct breakpoint *b;
  int disabled_shlib_breaks = 0;

#if defined (PC_SOLIB)
  /* See also: insert_breakpoints, under DISABLE_UNSETTABLE_BREAK.  */
  ALL_BREAKPOINTS (b)
  {
    if ((b->loc->loc_type == bp_loc_hardware_breakpoint
	|| b->loc->loc_type == bp_loc_software_breakpoint)
	&& breakpoint_enabled (b) 
	&& !b->loc->duplicate)
      {
	char *so_name = PC_SOLIB (b->loc->address);
	if (so_name 
	    && !strcmp (so_name, solib->so_name))
          {
	    b->enable_state = bp_shlib_disabled;
	    /* At this point, we cannot rely on remove_breakpoint
	       succeeding so we must mark the breakpoint as not inserted
	       to prevent future errors occurring in remove_breakpoints.  */
	    b->loc->inserted = 0;
	    if (!disabled_shlib_breaks)
	      {
		target_terminal_ours_for_output ();
		warning ("Temporarily disabling breakpoints for unloaded shared library \"%s\"",
			  so_name);
	      }
	    disabled_shlib_breaks = 1;
	  }
      }
  }
#endif
}

d4726 7
a4732 7
  /* FIXME: This is misplaced; mention() is called by things (like
     hitting a watchpoint) other than breakpoint creation.  It should
     be possible to clean this up and at the same time replace the
     random calls to breakpoint_changed with this hook, as has already
     been done for deprecated_delete_breakpoint_hook and so on.  */
  if (deprecated_create_breakpoint_hook)
    deprecated_create_breakpoint_hook (b);
d4916 1
a4916 1
	  b->addr_string = xstrprintf ("*0x%s", paddr (b->loc->address));
a4939 4
	    
	    /* We have to copy over the ignore_count and thread as well.  */
	    b->ignore_count = pending_bp->ignore_count;
	    b->thread = pending_bp->thread;
d5043 1
a5043 2
#ifdef DEPRECATED_PC_REQUIRES_RUN_BEFORE_USE
      if (DEPRECATED_PC_REQUIRES_RUN_BEFORE_USE (sals->sals[i].pc))
a5050 1
#endif
d6089 1
a6089 1
  if (!target_can_async_p ())
d6101 1
a6101 1
  if (target_can_async_p ())
d6123 1
a6123 1
      if (!target_can_async_p ())
d6132 1
a6132 1
  if (!target_can_async_p ())
d6877 2
a6878 2
  if (deprecated_delete_breakpoint_hook)
    deprecated_delete_breakpoint_hook (bpt);
a6883 2
  free_valchain (bpt->loc);

a7105 2
  int not_found;
  int *not_found_ptr = NULL;
a7155 7
      else
	/* If resetting a shlib-disabled breakpoint, we don't want to
	   see an error message if it is not found since we will expect
	   this to occur until the shared library is finally reloaded.
	   We accomplish this by giving decode_line_1 a pointer to use
	   for silent notification that the symbol is not found.  */
	not_found_ptr = &not_found;
d7160 1
a7160 2
      sals = decode_line_1 (&s, 1, (struct symtab *) NULL, 0, (char ***) NULL,
		            not_found_ptr);
d7510 2
a7511 2
  if (deprecated_modify_breakpoint_hook)
    deprecated_modify_breakpoint_hook (bpt);
d7551 2
a7598 3
	  struct frame_id saved_frame_id;

	  saved_frame_id = get_frame_id (get_selected_frame ());
d7611 3
d7648 2
a7649 1
	  select_frame (frame_find_by_id (saved_frame_id));
d7654 2
a7655 2
  if (deprecated_modify_breakpoint_hook)
    deprecated_modify_breakpoint_hook (bpt);
a7763 4
#ifdef SOLIB_ADD
  observer_attach_solib_unloaded (disable_breakpoints_in_unloaded_shlib);
#endif

d8077 1
a8077 1
  deprecated_add_show_from_set (c, &showlist);
d8095 6
a8100 2
Set debugger's behavior regarding pending breakpoints.", "\
Show debugger's behavior regarding pending breakpoints.", "\
d8104 1
a8104 2
user-query to see if a pending breakpoint should be created.", "\
Debugger's behavior regarding pending breakpoints is %s.",
@


1.157
log
@
2004-02-02  Jeff Johnston  <jjohnstn@@redhat.com>

        * breakpoint.h (struct breakpoint): Add new flag, from_tty,
        and pending fields for pending breakpoint support.
        * breakpoint.c (breakpoint_enabled): Add check for not pending.
        (condition_command): Only parse condition if not a pending
        breakpoint.
        (print_one_breakpoint): Add support for pending breakpoints.
        (describe_other_breakpoints): Add checks to verify we are not
        dealing with pending breakpoints.
        (check_duplicates): Don't check pending breakpoints.
        (set_raw_breakpoint): Initialize pending flag.
        (do_restore_lang_radix_cleanup): New cleanup routine.
        (resolve_pending_breakpoint): New function.
        (re_enable_breakpoints_in_shlibs): Try and resolve any
        pending breakpoints via resolve_pending_breakpoint.
        (mention): Add pending breakpoint support.
        (parse_breakpoint_sals): Add new parameter to pass to
        decode_line_1 to indicate silent errors when files or functions
        are not found.  Change all callers.
        (do_captured_parse_breakpoint): New function.
        (break_command_1): Change prototype to return an rc value and to
        take an optional pending breakpoint pointer.  Support creating
        a pending breakpoint if a "not found" form of error occurs when
        parsing the breakpoint.  Also support resolving an existing pending
        breakpoint and be silent if the resolution fails.
        (create_breakpoints): Change prototype to take pending breakpoint
        pointer.  When resolving a pending breakpoint, use the new pointer
        to provide a conditional or commands added by the end-user.
        (delete_breakpoint): Add appropriate check for pending.
        (breakpoint_re_set_one): Ditto.
        (do_enable_breakpoint): Ditto.
@
text
@a4271 55
#ifdef SOLIB_ADD
void
remove_solib_event_breakpoints (void)
{
  struct breakpoint *b, *temp;

  ALL_BREAKPOINTS_SAFE (b, temp)
    if (b->type == bp_shlib_event)
      delete_breakpoint (b);
}

struct breakpoint *
create_solib_event_breakpoint (CORE_ADDR address)
{
  struct breakpoint *b;

  b = create_internal_breakpoint (address, bp_shlib_event);
  return b;
}

/* Disable any breakpoints that are on code in shared libraries.  Only
   apply to enabled breakpoints, disabled ones can just stay disabled.  */

void
disable_breakpoints_in_shlibs (int silent)
{
  struct breakpoint *b;
  int disabled_shlib_breaks = 0;

  /* See also: insert_breakpoints, under DISABLE_UNSETTABLE_BREAK. */
  ALL_BREAKPOINTS (b)
  {
#if defined (PC_SOLIB)
    if (((b->type == bp_breakpoint) ||
	 (b->type == bp_hardware_breakpoint)) &&
	breakpoint_enabled (b) &&
	!b->loc->duplicate &&
	PC_SOLIB (b->loc->address))
      {
	b->enable_state = bp_shlib_disabled;
	if (!silent)
	  {
	    if (!disabled_shlib_breaks)
	      {
		target_terminal_ours_for_output ();
		warning ("Temporarily disabling shared library breakpoints:");
	      }
	    disabled_shlib_breaks = 1;
	    warning ("breakpoint #%d ", b->number);
	  }
      }
#endif
  }
}

d4330 55
@


1.156
log
@	* breakpoint.c (bpstat_stop_status): Take a ptid_t argument,
	and check the specified thread for each breakpoint.
	* breakpoint.h (bpstat_stop_status): Update prototype.
	* infrun.c (handle_inferior_event): Update calls to
	bpstat_stop_status.
@
text
@d92 1
a92 1
static void break_command_1 (char *, int, int);
d122 2
d327 1
a327 1
  return b->enable_state == bp_enabled;
d561 6
a566 3
	  b->cond = parse_exp_1 (&arg, block_for_pc (b->loc->address), 0);
	  if (*arg)
	    error ("Junk at end of expression");
d3473 10
a3482 1
	    ui_out_field_core_addr (uiout, "addr", b->loc->address);
d3501 4
d3541 9
a3549 1
  
d3780 1
a3780 1
      if (!overlay_debugging || b->loc->section == section)
d3787 1
a3787 1
	  if (!overlay_debugging || b->loc->section == section)
d3876 1
d3911 1
d4088 1
d4327 60
d4391 1
a4391 1
  struct breakpoint *b;
d4393 2
a4394 1
  ALL_BREAKPOINTS (b)
d4396 15
a4410 9
    {
      char buf[1], *lib;

      /* Do not reenable the breakpoint if the shared library
         is still not mapped in.  */
      lib = PC_SOLIB (b->loc->address);
      if (lib != NULL && target_read_memory (b->loc->address, buf, 1) == 0)
	b->enable_state = bp_enabled;
    }
d4822 1
a4822 1
      if (addressprint || b->source_file == NULL)
d4824 12
a4835 2
	  printf_filtered (" at ");
	  print_address_numeric (b->loc->address, 1, gdb_stdout);
a4836 3
      if (b->source_file)
	printf_filtered (": file %s, line %d.",
			 b->source_file, b->line_number);
d4849 5
d4864 2
a4865 1
		    int thread, int ignore_count, int from_tty)
d4905 20
d4938 2
a4939 1
		       char ***addr_string)
d4980 2
a4981 1
			       default_breakpoint_line, addr_string, NULL);
d4983 2
a4984 1
	*sals = decode_line_1 (address, 1, (struct symtab *) NULL, 0, addr_string, NULL);
d5038 11
d5051 1
a5051 1
   second bit : 0 normal breakpoint, 1 hardware breakpoint. */
d5053 5
a5057 2
static void
break_command_1 (char *arg, int flag, int from_tty)
d5062 1
a5062 2
  /* Pointers in arg to the start, and one past the end, of the
     condition.  */
d5064 2
d5070 3
a5072 1
  int i;
d5075 1
a5082 1
  parse_breakpoint_sals (&arg, &sals, &addr_string);
d5084 36
a5119 2
  if (!sals.nelts)
    return;
d5124 8
a5131 5
  /* Make sure that all storage allocated to SALS gets freed.  */
  make_cleanup (xfree, sals.sals);

  /* Cleanup the addr_string array but not its contents. */
  make_cleanup (xfree, addr_string);
d5158 2
a5159 1
  breakpoint_sals_to_pc (&sals, addr_start);
d5165 1
a5165 1
  for (i = 0; i < sals.nelts; i++)
d5167 1
a5167 2
      char *tok = arg;
      while (tok && *tok)
d5169 2
a5170 15
	  char *end_tok;
	  int toklen;
	  char *cond_start = NULL;
	  char *cond_end = NULL;
	  while (*tok == ' ' || *tok == '\t')
	    tok++;

	  end_tok = tok;

	  while (*end_tok != ' ' && *end_tok != '\t' && *end_tok != '\000')
	    end_tok++;

	  toklen = end_tok - tok;

	  if (toklen >= 1 && strncmp (tok, "if", toklen) == 0)
d5172 39
a5210 18
	      tok = cond_start = end_tok + 1;
	      cond[i] = parse_exp_1 (&tok, block_for_pc (sals.sals[i].pc), 0);
	      make_cleanup (xfree, cond[i]);
	      cond_end = tok;
	      cond_string[i] = savestring (cond_start, cond_end - cond_start);
	      make_cleanup (xfree, cond_string[i]);
	    }
	  else if (toklen >= 1 && strncmp (tok, "thread", toklen) == 0)
	    {
	      char *tmptok;

	      tok = end_tok + 1;
	      tmptok = tok;
	      thread = strtol (tok, &tok, 0);
	      if (tok == tmptok)
		error ("Junk after thread keyword.");
	      if (!valid_thread_id (thread))
		error ("Unknown thread %d\n", thread);
a5211 2
	  else
	    error ("Junk at end of arguments.");
d5213 6
d5220 7
d5228 1
a5228 4
  create_breakpoints (sals, addr_string, cond, cond_string,
		      hardwareflag ? bp_hardware_breakpoint : bp_breakpoint,
		      tempflag ? disp_del : disp_donttouch,
		      thread, ignore_count, from_tty);
d5230 16
d5256 2
d5294 1
a5294 1
  parse_breakpoint_sals (&address_end, &sals, &addr_string);
d5358 2
a5359 1
		      args->thread, args->ignore_count, 0/*from-tty*/);
d5451 1
a5451 1
	  break_command_1 (addr_string, flag, from_tty);
d5534 1
a5534 1
	  break_command_1 (break_string, flag, from_tty);
d5601 1
a5601 1
  break_command_1 (arg, 0, from_tty);
d5619 1
a5619 1
  break_command_1 (arg, BP_TEMPFLAG, from_tty);
d5631 1
a5631 1
  break_command_1 (arg, BP_HARDWAREFLAG, from_tty);
d5637 1
a5637 1
  break_command_1 (arg, (BP_TEMPFLAG | BP_HARDWAREFLAG), from_tty);
d5678 1
a5678 1
    break_command_1 (arg, 0, from_tty);
d5710 1
a5710 1
    break_command_1 (arg, 0, from_tty);
d6917 1
d7123 4
d7542 9
a7550 16
  if (bpt->enable_state != bp_permanent)
    bpt->enable_state = bp_enabled;
  bpt->disposition = disposition;
  check_duplicates (bpt);
  breakpoints_changed ();

  if (bpt->type == bp_watchpoint || 
      bpt->type == bp_hardware_watchpoint ||
      bpt->type == bp_read_watchpoint || 
      bpt->type == bp_access_watchpoint)
    {
      if (bpt->exp_valid_block != NULL)
	{
	  struct frame_info *fr =
	  fr = frame_find_by_id (bpt->watchpoint_frame);
	  if (fr == NULL)
d7552 1
a7552 4
	      printf_filtered ("\
Cannot enable watchpoint %d because the block in which its expression\n\
is valid is not currently in scope.\n", bpt->number);
	      bpt->enable_state = bp_disabled;
d7555 2
a7556 4

	  save_selected_frame = deprecated_selected_frame;
	  save_selected_frame_level = frame_relative_level (deprecated_selected_frame);
	  select_frame (fr);
d7558 12
a7569 10

      value_free (bpt->val);
      mark = value_mark ();
      bpt->val = evaluate_expression (bpt->exp);
      release_value (bpt->val);
      if (VALUE_LAZY (bpt->val))
	value_fetch_lazy (bpt->val);

      if (bpt->type == bp_hardware_watchpoint ||
	  bpt->type == bp_read_watchpoint ||
d7572 28
a7599 10
	  int i = hw_watchpoint_used_count (bpt->type, &other_type_used);
	  int mem_cnt = can_use_hardware_watchpoint (bpt->val);

	  /* Hack around 'unused var' error for some targets here */
	  (void) mem_cnt, i;
	  target_resources_ok = TARGET_CAN_USE_HARDWARE_WATCHPOINT (
				   bpt->type, i + mem_cnt, other_type_used);
	  /* we can consider of type is bp_hardware_watchpoint, convert to 
	     bp_watchpoint in the following condition */
	  if (target_resources_ok < 0)
d7601 12
a7612 1
	      printf_filtered ("\
d7615 4
a7618 3
	      bpt->enable_state = bp_disabled;
	      value_free_to_mark (mark);
	      return;
d7620 4
d7625 1
a7626 4
      if (save_selected_frame_level >= 0)
	select_frame (save_selected_frame);
      value_free_to_mark (mark);
    }
@


1.155
log
@	* breakpoint.c (bpstat_stop_status): Remove not_a_sw_breakpoint
	argument, and change first argument to a CORE_ADDR.
	* breakpoint.h (bpstat_stop_status): Update prototype.
	* infrun.c (adjust_pc_after_break): Add a new comment.
	(handle_inferior_event): Update calls to bpstat_stop_status.
@
text
@d2591 1
a2591 1
bpstat_stop_status (CORE_ADDR bp_addr)
d2600 1
d2849 6
@


1.154
log
@	* breakpoint.c (software_breakpoint_inserted_here_p): New function.
	(bpstat_stop_status): Don't decrement PC.
	* breakpoint.h (software_breakpoint_inserted_here_p): Add
	prototype.
	* infrun.c (adjust_pc_after_break): New function.
	(handle_inferior_event): Call it, early.  Remove later references
	to DECR_PC_AFTER_BREAK.
	(normal_stop): Add commentary.
@
text
@d2573 2
a2574 5
/* Get a bpstat associated with having just stopped at address *PC
   and frame address CORE_ADDRESS.  Update *PC to point at the
   breakpoint (if we hit a breakpoint).  NOT_A_SW_BREAKPOINT is nonzero
   if this is known to not be a real breakpoint (it could still be a
   watchpoint, though).  */
d2591 1
a2591 1
bpstat_stop_status (CORE_ADDR *pc, int not_a_sw_breakpoint)
a2593 1
  CORE_ADDR bp_addr;
a2600 2
  bp_addr = *pc;

d2627 1
a2627 1
	if (b->loc->address != *pc)
@


1.153
log
@	* breakpoint.c (breakpoint_re_set_one): Add missing chunk of
	2004-01-27 double-free fix.
@
text
@d1720 31
d2605 1
a2605 7
  /* Get the address where the breakpoint would have been.  The
     "not_a_sw_breakpoint" argument is meant to distinguish between a
     breakpoint trap event and a trace/singlestep trap event.  For a
     trace/singlestep trap event, we would not want to subtract
     DECR_PC_AFTER_BREAK from the PC. */

  bp_addr = *pc - (not_a_sw_breakpoint ? 0 : DECR_PC_AFTER_BREAK);
a2889 12

  if (real_breakpoint && bs)
    {
      if (bs->breakpoint_at->type != bp_hardware_breakpoint)
	{
	  if (DECR_PC_AFTER_BREAK != 0)
	    {
	      *pc = bp_addr;
	      write_pc (bp_addr);
	    }
	}
    }
@


1.152
log
@2004-01-27  Paul N. Hilfinger  <hilfinger@@gnat.com>

	* breakpoint.c (breakpoint_re_set_one): Set b->cond, b->val, and
	b->exp to NULL after freeing so that error during re-parsing or
	evaluation of expressions associated with breakpoint don't
	eventually lead to re-freeing of storage.
	Committed by Andrew Cagney.
@
text
@d6905 6
a6910 1
		xfree (b->cond);
@


1.151
log
@2004-01-26  Andrew Cagney  <cagney@@redhat.com>

	* breakpoint.c (catch_command_1): Delete #ifdef code.
	(catch_fork_command_1): Delete #ifdef wrapper.
	(catch_exec_command_1): Ditto.
	(catch_load_command_1): Ditto.
	(catch_unload_command_1): Ditto.
@
text
@d6973 6
a6978 1
	xfree (b->exp);
d6983 6
a6988 1
	value_free (b->val);
d6998 6
a7003 1
	    xfree (b->cond);
@


1.150
log
@2004-01-26  Andrew Cagney  <cagney@@redhat.com>

	* breakpoint.c (watchpoint_check): Delete #if0ed variable.
	(catch_breakpoint): Delete #if0ed function.
	(disable_catch_breakpoint): Ditto.
	(delete_catch_breakpoint, enable_catch_breakpoint): Ditto.
	(disable_catch, enable_catch, delete_catch): Ditto.

Index: breakpoint.c
===================================================================
RCS file: /cvs/src/src/gdb/breakpoint.c,v
retrieving revision 1.149
diff -u -r1.149 breakpoint.c
--- breakpoint.c	17 Jan 2004 21:56:12 -0000	1.149
+++ breakpoint.c	27 Jan 2004 00:11:06 -0000
@@@@ -2455,9 +2455,6 @@@@
   struct breakpoint *b;
   struct frame_info *fr;
   int within_current_scope;
-#if 0
-  struct frame_id current_frame_id;
-#endif

   b = bs->breakpoint_at;

@@@@ -5879,30 +5876,6 @@@@
     do_cleanups (old_chain);
 }

-#if 0
-/* These aren't used; I don't konw what they were for.  */
-/* Set a breakpoint at the catch clause for NAME.  */
-static int
-catch_breakpoint (char *name)
-{
-}
-
-static int
-disable_catch_breakpoint (void)
-{
-}
-
-static int
-delete_catch_breakpoint (void)
-{
-}
-
-static int
-enable_catch_breakpoint (void)
-{
-}
-#endif /* 0 */
-
 static void
 ep_skip_leading_whitespace (char **s)
 {
@@@@ -6482,30 +6455,6 @@@@
   b->thread = -1;
   return b;
 }
-
-#if 0
-/* These aren't used; I don't know what they were for.  */
-/* Disable breakpoints on all catch clauses described in ARGS.  */
-static void
-disable_catch (char *args)
-{
-  /* Map the disable command to catch clauses described in ARGS.  */
-}
-
-/* Enable breakpoints on all catch clauses described in ARGS.  */
-static void
-enable_catch (char *args)
-{
-  /* Map the disable command to catch clauses described in ARGS.  */
-}
-
-/* Delete breakpoints on all catch clauses in the active scope.  */
-static void
-delete_catch (char *args)
-{
-  /* Map the delete command to catch clauses described in ARGS.  */
-}
-#endif /* 0 */

 static void
 catch_command (char *arg, int from_tty)
@
text
@a195 4
#if defined(CHILD_INSERT_EXEC_CATCHPOINT)
static void catch_exec_command_1 (char *arg, int tempflag, int from_tty);
#endif

a5988 4
#if defined(CHILD_INSERT_FORK_CATCHPOINT) || defined(CHILD_INSERT_VFORK_CATCHPOINT)
static void catch_fork_command_1 (catch_fork_kind fork_kind,
				  char *arg, int tempflag, int from_tty);

a6021 1
#endif
a6022 1
#if defined(CHILD_INSERT_EXEC_CATCHPOINT)
a6043 1
#endif
a6044 1
#if defined(SOLIB_ADD)
a6127 1
#endif /* SOLIB_ADD */
a6375 1
#if defined(CHILD_INSERT_FORK_CATCHPOINT)
a6376 3
#else
      error ("Catch of fork not yet implemented");
#endif
a6379 1
#if defined(CHILD_INSERT_VFORK_CATCHPOINT)
a6380 3
#else
      error ("Catch of vfork not yet implemented");
#endif
a6383 1
#if defined(CHILD_INSERT_EXEC_CATCHPOINT)
a6384 3
#else
      error ("Catch of exec not yet implemented");
#endif
a6387 1
#if defined(SOLIB_ADD)
a6388 3
#else
      error ("Catch of load not implemented");
#endif
a6391 1
#if defined(SOLIB_ADD)
a6392 3
#else
      error ("Catch of load not implemented");
#endif
@


1.149
log
@	* breakpoint.c (must_shift_inst_regs): Delete.
	(bpstat_stop_status): Delete references to DECR_PC_AFTER_HW_BREAK
	and SHIFT_INST_REGS.
	* infcmd.c (step_1, step_1_continuation): Delete references to
	SHIFT_INST_REGS.
	* infrun.c (keep_going): Likewise.
	* target.h (DECR_PC_AFTER_HW_BREAK): Don't define.
	* config/i386/nm-i386.h (DECR_PC_AFTER_HW_BREAK): Likewise.
@
text
@a2457 3
#if 0
  struct frame_id current_frame_id;
#endif
a5878 24
#if 0
/* These aren't used; I don't konw what they were for.  */
/* Set a breakpoint at the catch clause for NAME.  */
static int
catch_breakpoint (char *name)
{
}

static int
disable_catch_breakpoint (void)
{
}

static int
delete_catch_breakpoint (void)
{
}

static int
enable_catch_breakpoint (void)
{
}
#endif /* 0 */

a6457 24

#if 0
/* These aren't used; I don't know what they were for.  */
/* Disable breakpoints on all catch clauses described in ARGS.  */
static void
disable_catch (char *args)
{
  /* Map the disable command to catch clauses described in ARGS.  */
}

/* Enable breakpoints on all catch clauses described in ARGS.  */
static void
enable_catch (char *args)
{
  /* Map the disable command to catch clauses described in ARGS.  */
}

/* Delete breakpoints on all catch clauses in the active scope.  */
static void
delete_catch (char *args)
{
  /* Map the delete command to catch clauses described in ARGS.  */
}
#endif /* 0 */
@


1.148
log
@* breakpoint.c (bpstat_do_actions): To ensure that
clear_proceed_status doesn't free the command tree we're
evaluating out from under us, zero the bpstat's pointer to it, and
take care of freeing it ourselves.
* cli/cli-script.c (make_cleanup_free_command_lines): Make this
function externally visible.
* cli/cli-script.h (make_cleanup_free_command_lines): New
declaration.
@
text
@d4 2
a5 2
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003 Free Software
   Foundation, Inc.
a246 10
/* True if SHIFT_INST_REGS defined, false otherwise.  */

int must_shift_inst_regs =
#if defined(SHIFT_INST_REGS)
1
#else
0
#endif
 ;

d2615 1
a2615 1
	if (b->loc->address != (*pc - DECR_PC_AFTER_HW_BREAK))
d2875 1
a2875 9
      if (bs->breakpoint_at->type == bp_hardware_breakpoint)
	{
	  if (DECR_PC_AFTER_HW_BREAK != 0)
	    {
	      *pc = *pc - DECR_PC_AFTER_HW_BREAK;
	      write_pc (*pc);
	    }
	}
      else
d2877 1
a2877 1
	  if (DECR_PC_AFTER_BREAK != 0 || must_shift_inst_regs)
a2879 3
#if defined (SHIFT_INST_REGS)
	      SHIFT_INST_REGS ();
#else /* No SHIFT_INST_REGS.  */
a2880 1
#endif /* No SHIFT_INST_REGS.  */
@


1.147
log
@
2003-12-17  Jeff Johnston  <jjohnstn@@redhat.com>

        * linespec.h (decode_line_1): Add new not_found_ptr parameter.
        * linespec.c (decode_line_1): Add new parameter.  Pass on
        new parameter to decode_variable and symtab_from_filename
        functions.
        (decode_variable): Add new not_found_ptr parameter.  Throw exception
        rather than failing if the not_found_ptr is non-null and the
        function is not found.
        (symtab_from_filename): Add new not_found_ptr parametr.   Throw
        exception rather than failing if the not_found_ptr is non-null and
        the source file is not found.
        * breakpoint.c: Change all callers of decode_line_1 to add default
        extra parameter for decode_line_1 calls.
        * tracepoint.c: Ditto.
        * cli/cli-cmds.c: Ditto.
@
text
@a1994 1
  struct command_line *cmd;
d2019 13
d2033 3
d2045 4
a2054 2
      else
	free_command_lines (&bs->commands);
@


1.146
log
@
2003-12-12  Jeff Johnston  <jjohnstn@@redhat.com>

        * breakpoint.c (breakpoint_enabled): New function to test whether
        breakpoint is active and enabled.
        (insert_bp_location, insert_breakpoints): Call new function to test
        for enabled breakpoint.
        (remove_breakpoint, breakpoint_here_p, breakpoint_thread_match)
        (bpstat_should_step, bpstat_have_active_hw_watchpoints)
        (disable_breakpoints_in_shlibs, hw_watchpoint_used_count)
        (disable_watchpoints_before_interactive_call_start)
        (breakpoint_re_set_one): Ditto.
        (bpstat_stop_status): Use new function and simplify test.
@
text
@d4331 1
a4331 1
  sals = decode_line_1 (&hookname, 1, (struct symtab *) NULL, 0, &canonical);
d4848 1
a4848 1
			       default_breakpoint_line, addr_string);
d4850 1
a4850 1
	*sals = decode_line_1 (address, 1, (struct symtab *) NULL, 0, addr_string);
d5296 1
a5296 1
			(char ***) NULL);
d5813 1
a5813 1
			  default_breakpoint_line, (char ***) NULL);
d5816 1
a5816 1
			  0, (char ***) NULL);
d6276 1
a6276 1
  sals = decode_line_1 (&nameptr, 1, NULL, 0, NULL);
d6983 1
a6983 1
      sals = decode_line_1 (&s, 1, (struct symtab *) NULL, 0, (char ***) NULL);
d7519 1
a7519 1
			  (char ***) NULL);
d7522 1
a7522 1
			  (struct symtab *) NULL, 0, (char ***) NULL);
@


1.145
log
@	* breakpoint.c (re_enable_breakpoints_in_shlibs): Only re-enable a
	bp_shlib_disabled breakpoint if there is a shared library mapped
	at its expected address.
@
text
@d335 7
d767 1
a767 1
  if (bpt->owner->enable_state != bp_enabled)
d1117 1
a1117 1
      if (b->owner->enable_state != bp_enabled)
d1467 1
a1467 1
	   && b->owner->enable_state == bp_enabled
d1523 1
a1523 1
	   && b->owner->enable_state == bp_enabled
d1548 1
a1548 1
	   && b->owner->enable_state == bp_enabled
d1559 1
a1559 1
	   && b->owner->enable_state == bp_enabled
d1685 1
a1685 1
      if ((bpt->owner->enable_state == bp_enabled
d1782 1
a1782 1
      if ((bpt->owner->enable_state == bp_enabled
d2584 1
a2584 3
    if (b->enable_state == bp_disabled
	|| b->enable_state == bp_shlib_disabled
	|| b->enable_state == bp_call_disabled)
d3187 1
a3187 1
    if (b->enable_state == bp_enabled && b->type == bp_watchpoint)
d3198 1
a3198 1
    if ((bpt->owner->enable_state == bp_enabled)
d4276 1
a4276 1
	b->enable_state == bp_enabled &&
d4499 1
a4499 1
    if (b->enable_state == bp_enabled)
d4505 1
a4505 2
		  b->type == bp_access_watchpoint)
		 && b->enable_state == bp_enabled)
d4547 1
a4547 1
	&& (b->enable_state == bp_enabled))
d7070 1
a7070 1
      if (VALUE_LAZY (b->val) && b->enable_state == bp_enabled)
d7080 1
a7080 1
      if (b->enable_state == bp_enabled)
@


1.144
log
@	PR breakpoints/1450
	* breakpoint.c (insert_bp_location): Fix a logic error by returning
	0 after a catchpoint fails.
@
text
@d4300 1
a4300 1
      char buf[1];
d4304 2
a4305 1
      if (target_read_memory (b->loc->address, buf, 1) == 0)
@


1.143
log
@2003-11-07  Andrew Cagney  <cagney@@redhat.com>

	* top.c (print_gdb_version): Replace STREQ with strcmp.
	* valops.c (value_struct_elt_for_reference): Ditto.
	(value_struct_elt_for_reference): Ditto.
	* symtab.c (gdb_mangle_name): Ditto.
	(find_line_symtab): Ditto.
	* symmisc.c (maintenance_print_symbols): Ditto.
	* symfile.c (symbol_file_command): Ditto.
	* stabsread.c (define_symbol, read_type): Ditto.
	(cleanup_undefined_types, scan_file_globals): Ditto.
	* solib.c (solib_map_sections): Ditto.
	* solib-svr4.c (bfd_lookup_symbol): Ditto.
	* rs6000-tdep.c (skip_prologue): Ditto.
	* p-valprint.c (pascal_value_print): Ditto.
	(pascal_object_is_vtbl_ptr_type): Ditto.
	* objfiles.c (in_plt_section): Ditto.
	* minsyms.c (lookup_minimal_symbol): Ditto.
	(compact_minimal_symbols): Ditto.
	(find_solib_trampoline_target): Ditto.
	* mdebugread.c (parse_type): Ditto.
	* language.c (set_language_command): Ditto.
	(set_type_command, set_range_command): Ditto.
	* f-lang.c (add_common_block): Ditto.
	(add_common_block): Ditto.
	(find_first_common_named): Ditto.
	(patch_all_commons_by_name): Ditto.
	* elfread.c (elf_locate_sections): Ditto.
	(elf_locate_sections): Ditto.
	(elfstab_offset_sections): Ditto.
	* dwarf2read.c (dwarf2_locate_sections): Ditto.
	* dbxread.c (add_old_header_file): Ditto.
	(find_corresponding_bincl_psymtab): Ditto.
	(read_dbx_symtab, process_one_symbol): Ditto.
	* coffread.c (patch_opaque_types): Ditto.
	* cli/cli-decode.c (delete_cmd): Ditto.
	* cli/cli-cmds.c (pwd_command, list_command): Ditto.
	* c-typeprint.c (c_type_print_base): Ditto.
	* breakpoint.c (bpstat_stop_status): Ditto.
	(clear_command, breakpoint_re_set_one): Ditto.
@
text
@d1074 5
a1078 1
      return val;
@


1.142
log
@	* breakpoint.c (insert_bp_location, allocate_bp_location): Make
	static.
@
text
@d2840 2
a2841 2
		(STREQ ("silent", bs->commands->line) ||
		 (xdb_commands && STREQ ("Q", bs->commands->line))))
d6594 1
a6594 1
		      && STREQ (b->source_file, sal.symtab->filename)
d6995 1
a6995 1
		  && (!STREQ (b->source_file, sals.sals[i].symtab->filename)
@


1.141
log
@	* breakpoint.c (remove_breakpoint): Take an bp_location
	instead of a breakpoint argument.  Check the bp_location's type.
	Fix a reversed condition for hardware breakpoints.

	(insert_bp_location): Update call to remove_breakpoint.
	(remove_breakpoints): Likewise.  Use ALL_BP_LOCATIONS.
	(remove_hw_watchpoints): Likewise.
	(reattach_breakpoints): Likewise.
	(detach_breakpoints): Likewise.
	(delete_breakpoint): Likewise.
@
text
@d750 1
a750 1
int
d752 3
a754 3
			struct ui_file *tmp_error_stream,
			int *disabled_breaks, int *process_warning,
			int *hw_breakpoint_error)
d3939 1
a3939 1
struct bp_location *
@


1.140
log
@	* breakpoint.c (mark_breakpoints_out): Use ALL_BP_LOCATIONS.
	(beakpoint_init_inferior): Likewise.
	(breakpoint_here_p): Likewise.  Only check addresses for software
	or hardware breakpoints.
	(breakpoint_inserted_here_p): Likewise.
	(breakpoint_thread_match): Likewise.  Correct comment.
	(bpstat_have_active_hw_watchpoints): Likewise.
	(check_duplicates): Likewise.
@
text
@d131 1
a131 1
static int remove_breakpoint (struct breakpoint *, insertion_state_t);
d979 1
a979 1
	      remove_breakpoint (bpt->owner, mark_uninserted);
d1153 1
a1153 1
  struct breakpoint *b;
d1156 1
a1156 1
  ALL_BREAKPOINTS (b)
d1158 1
a1158 1
    if (b->loc->inserted)
d1171 1
a1171 1
  struct breakpoint *b;
d1174 1
a1174 1
  ALL_BREAKPOINTS (b)
d1176 1
a1176 4
    if (b->loc->inserted
	&& (b->type == bp_hardware_watchpoint
	    || b->type == bp_read_watchpoint
	    || b->type == bp_access_watchpoint))
d1189 1
a1189 1
  struct breakpoint *b;
d1195 1
a1195 1
  ALL_BREAKPOINTS (b)
d1197 1
a1197 1
    if (b->loc->inserted)
d1200 2
a1201 2
	if (b->type == bp_hardware_breakpoint)
	  val = target_insert_hw_breakpoint (b->loc->address, b->loc->shadow_contents);
d1203 3
a1205 1
	  val = target_insert_breakpoint (b->loc->address, b->loc->shadow_contents);
d1354 1
a1354 1
  struct breakpoint *b;
d1363 1
a1363 1
  ALL_BREAKPOINTS (b)
d1365 1
a1365 1
    if (b->loc->inserted)
d1380 1
a1380 1
remove_breakpoint (struct breakpoint *b, insertion_state_t is)
d1384 1
a1384 1
  if (b->enable_state == bp_permanent)
d1388 1
a1388 1
  if (b->type == bp_none)
d1390 1
a1390 1
	     b->number);
d1392 2
a1393 9
  if (b->type != bp_watchpoint
      && b->type != bp_hardware_watchpoint
      && b->type != bp_read_watchpoint
      && b->type != bp_access_watchpoint
      && b->type != bp_catch_fork
      && b->type != bp_catch_vfork
      && b->type != bp_catch_exec
      && b->type != bp_catch_catch
      && b->type != bp_catch_throw)
d1401 2
a1402 2
	  || b->loc->section == NULL
	  || !(section_is_overlay (b->loc->section)))
d1406 3
a1408 3
	  if (b->type == bp_hardware_breakpoint)
	    val = target_remove_hw_breakpoint (b->loc->address, 
					       b->loc->shadow_contents);
d1410 1
a1410 1
	    val = target_remove_breakpoint (b->loc->address, b->loc->shadow_contents);
d1421 2
a1422 2
		CORE_ADDR addr = overlay_unmapped_address (b->loc->address, 
							   b->loc->section);
d1425 2
a1426 2
		if (b->type != bp_hardware_breakpoint)
		  target_remove_hw_breakpoint (addr, b->loc->shadow_contents);
d1428 1
a1428 1
		  target_remove_breakpoint (addr, b->loc->shadow_contents);
d1432 1
a1432 1
	  if (b->loc->inserted)
d1438 3
a1440 3
	      if (b->type == bp_hardware_breakpoint)
		val = target_remove_hw_breakpoint (b->loc->address, 
						   b->loc->shadow_contents);
d1442 2
a1443 2
		val = target_remove_breakpoint (b->loc->address,
						b->loc->shadow_contents);
d1453 1
a1453 1
      b->loc->inserted = (is == mark_inserted);
d1455 3
a1457 5
  else if ((b->type == bp_hardware_watchpoint ||
	    b->type == bp_read_watchpoint ||
	    b->type == bp_access_watchpoint)
	   && b->enable_state == bp_enabled
	   && !b->loc->duplicate)
d1462 1
a1462 1
      b->loc->inserted = (is == mark_inserted);
d1464 1
a1464 1
      for (v = b->val_chain; v; v = v->next)
d1473 1
a1473 1
	      if (v == b->val_chain
d1483 1
a1483 1
		  if (b->type == bp_read_watchpoint)
d1485 1
a1485 1
		  else if (b->type == bp_access_watchpoint)
d1490 1
a1490 1
		    b->loc->inserted = 1;
d1496 1
a1496 1
      if ((is == mark_uninserted) && (b->loc->inserted))
d1498 1
a1498 1
		 b->number);
d1502 1
a1502 1
      for (v = b->val_chain; v; v = n)
d1507 1
a1507 1
      b->val_chain = NULL;
d1509 5
a1513 5
  else if ((b->type == bp_catch_fork ||
	    b->type == bp_catch_vfork ||
	    b->type == bp_catch_exec)
	   && b->enable_state == bp_enabled
	   && !b->loc->duplicate)
d1516 1
a1516 1
      switch (b->type)
d1533 1
a1533 1
      b->loc->inserted = (is == mark_inserted);
d1535 4
a1538 4
  else if ((b->type == bp_catch_catch ||
	    b->type == bp_catch_throw)
	   && b->enable_state == bp_enabled
	   && !b->loc->duplicate)
d1541 1
a1541 1
      val = target_remove_breakpoint (b->loc->address, b->loc->shadow_contents);
d1544 1
a1544 1
      b->loc->inserted = (is == mark_inserted);
d1546 4
a1549 4
  else if (ep_is_exception_catchpoint (b)
	   && b->loc->inserted	/* sometimes previous insert doesn't happen */
	   && b->enable_state == bp_enabled
	   && !b->loc->duplicate)
d1552 1
a1552 1
      val = target_remove_breakpoint (b->loc->address, b->loc->shadow_contents);
d1556 1
a1556 1
      b->loc->inserted = (is == mark_inserted);
d6701 1
a6701 1
    remove_breakpoint (bpt, mark_inserted);
@


1.139
log
@	* breakpoints.c (insert_bp_location): New function, broken out
	from insert_breakpoints.  Work on an bp_location instead of a
	breakpoint.
	(insert_breakpoints): Use it.
@
text
@d1577 1
a1577 1
  struct breakpoint *b;
d1579 2
a1580 2
  ALL_BREAKPOINTS (b)
    b->loc->inserted = 0;
d1599 1
d1602 3
a1606 2
    b->loc->inserted = 0;

d1675 1
a1675 1
  struct breakpoint *b;
d1678 20
a1697 14
  ALL_BREAKPOINTS (b)
    if ((b->enable_state == bp_enabled
	 || b->enable_state == bp_permanent)
	&& b->loc->address == pc)	/* bp is enabled and matches pc */
      {
	if (overlay_debugging 
	    && section_is_overlay (b->loc->section) 
	    && !section_is_mapped (b->loc->section))
	  continue;		/* unmapped overlay -- can't be a match */
	else if (b->enable_state == bp_permanent)
	  return permanent_breakpoint_here;
	else
	  any_breakpoint_here = 1;
      }
d1710 1
a1710 1
  struct breakpoint *b;
d1712 1
a1712 3
  ALL_BREAKPOINTS (b)
    if (b->loc->inserted
	&& b->loc->address == pc)	/* bp is inserted and matches pc */
d1714 14
a1727 6
      if (overlay_debugging 
	  && section_is_overlay (b->loc->section) 
	  && !section_is_mapped (b->loc->section))
	continue;		/* unmapped overlay -- can't be a match */
      else
	return 1;
d1764 2
a1765 2
/* breakpoint_thread_match (PC, PID) returns true if the breakpoint at
   PC is valid for process/thread PID.  */
d1770 1
a1770 1
  struct breakpoint *b;
d1775 18
a1792 13
  ALL_BREAKPOINTS (b)
    if (b->enable_state != bp_disabled
	&& b->enable_state != bp_shlib_disabled
	&& b->enable_state != bp_call_disabled
	&& b->loc->address == pc
	&& (b->thread == -1 || b->thread == thread))
    {
      if (overlay_debugging 
	  && section_is_overlay (b->loc->section) 
	  && !section_is_mapped (b->loc->section))
	continue;		/* unmapped overlay -- can't be a match */
      else
	return 1;
d3197 5
a3201 7
  struct breakpoint *b;
  ALL_BREAKPOINTS (b)
    if ((b->enable_state == bp_enabled) &&
	(b->loc->inserted) &&
	((b->type == bp_hardware_watchpoint) ||
	 (b->type == bp_read_watchpoint) ||
	 (b->type == bp_access_watchpoint)))
d3837 1
a3837 1
  struct breakpoint *b;
d3839 1
a3839 1
  struct breakpoint *perm_bp = 0;
d3846 7
a3852 7
  ALL_BREAKPOINTS (b)
    if (b->enable_state != bp_disabled
	&& b->enable_state != bp_shlib_disabled
	&& b->enable_state != bp_call_disabled
	&& b->loc->address == address	/* address / overlay match */
	&& (!overlay_debugging || b->loc->section == section)
	&& breakpoint_address_is_meaningful (b))
d3855 1
a3855 1
      if (b->enable_state == bp_permanent)
d3862 1
a3862 1
      b->loc->duplicate = count > 1;
d3870 1
a3870 1
      perm_bp->loc->duplicate = 0;
d3873 1
a3873 1
      if (! perm_bp->loc->inserted)
d3878 1
a3878 1
      ALL_BREAKPOINTS (b)
d3881 14
a3894 12
	    if (b->loc->inserted)
	      internal_error (__FILE__, __LINE__,
			      "another breakpoint was inserted on top of "
			      "a permanent breakpoint");

	    if (b->enable_state != bp_disabled
		&& b->enable_state != bp_shlib_disabled
		&& b->enable_state != bp_call_disabled
		&& b->loc->address == address	/* address / overlay match */
		&& (!overlay_debugging || b->loc->section == section)
		&& breakpoint_address_is_meaningful (b))
	      b->loc->duplicate = 1;
@


1.138
log
@	* breakpoint.h (struct bp_location): Add section.
	(struct breakpoint): Remove section.
	* breakpoint.c (insert_breakpoints, remove_breakpoint)
	(breakpoint_here_p, breakpoint_inserted_here_p)
	(breakpoint_thread_match, bpstat_stop_status, print_one_breakpoint)
	(describe_other_breakpoints, check_duplicates, set_raw_breakpoint)
	(clear_command, delete_breakpoint, breakpoint_re_set_one): Access
	section through loc.
@
text
@d744 336
d1088 1
a1088 1
  struct breakpoint *b, *temp;
a1092 1
#ifdef ONE_PROCESS_WRITETEXT
a1093 1
#endif
d1102 28
a1129 339
  ALL_BREAKPOINTS_SAFE (b, temp)
  {
    /* Permanent breakpoints cannot be inserted or removed.  Disabled
       breakpoints should not be inserted.  */
    if (b->enable_state != bp_enabled)
      continue;

    if ((b->type == bp_watchpoint
	 || b->type == bp_hardware_watchpoint
	 || b->type == bp_read_watchpoint
	 || b->type == bp_access_watchpoint) && (!b->val))
      {
	struct value *val;
	val = evaluate_expression (b->exp);
	release_value (val);
	if (VALUE_LAZY (val))
	  value_fetch_lazy (val);
	b->val = val;
      } 
    if (b->type != bp_watchpoint
	&& b->type != bp_hardware_watchpoint
	&& b->type != bp_read_watchpoint
	&& b->type != bp_access_watchpoint
	&& b->type != bp_catch_fork
	&& b->type != bp_catch_vfork
	&& b->type != bp_catch_exec
	&& b->type != bp_catch_throw
	&& b->type != bp_catch_catch
	&& !b->loc->inserted
	&& !b->loc->duplicate)
      {
	/* "Normal" instruction breakpoint: either the standard
	   trap-instruction bp (bp_breakpoint), or a
	   bp_hardware_breakpoint.  */

	/* First check to see if we have to handle an overlay.  */
	if (overlay_debugging == ovly_off
	    || b->loc->section == NULL
	    || !(section_is_overlay (b->loc->section)))
	  {
	    /* No overlay handling: just set the breakpoint.  */

	    if (b->type == bp_hardware_breakpoint)
	      val = target_insert_hw_breakpoint (b->loc->address, 
						 b->loc->shadow_contents);
	    else
	      val = target_insert_breakpoint (b->loc->address, b->loc->shadow_contents);
	  }
	else
	  {
	    /* This breakpoint is in an overlay section.  
	       Shall we set a breakpoint at the LMA?  */
	    if (!overlay_events_enabled)
	      {
		/* Yes -- overlay event support is not active, 
		   so we must try to set a breakpoint at the LMA.
		   This will not work for a hardware breakpoint.  */
		if (b->type == bp_hardware_breakpoint)
		  warning ("hardware breakpoint %d not supported in overlay!\n",
			   b->number);
		else
		  {
		    CORE_ADDR addr = overlay_unmapped_address (b->loc->address, 
							       b->loc->section);
		    /* Set a software (trap) breakpoint at the LMA.  */
		    val = target_insert_breakpoint (addr, b->loc->shadow_contents);
		    if (val != 0)
		      fprintf_unfiltered (tmp_error_stream, 
					  "Overlay breakpoint %d failed: in ROM?", 
					  b->number);
		  }
	      }
	    /* Shall we set a breakpoint at the VMA? */
	    if (section_is_mapped (b->loc->section))
	      {
		/* Yes.  This overlay section is mapped into memory.  */
		if (b->type == bp_hardware_breakpoint)
		  val = target_insert_hw_breakpoint (b->loc->address, 
						     b->loc->shadow_contents);
		else
		  val = target_insert_breakpoint (b->loc->address,
						  b->loc->shadow_contents);
	      }
	    else
	      {
		/* No.  This breakpoint will not be inserted.  
		   No error, but do not mark the bp as 'inserted'.  */
		continue;
	      }
	  }

	if (val)
	  {
	    /* Can't set the breakpoint.  */
#if defined (DISABLE_UNSETTABLE_BREAK)
	    if (DISABLE_UNSETTABLE_BREAK (b->loc->address))
	      {
		/* See also: disable_breakpoints_in_shlibs. */
		val = 0;
		b->enable_state = bp_shlib_disabled;
		if (!disabled_breaks)
		  {
		    fprintf_unfiltered (tmp_error_stream, 
					"Cannot insert breakpoint %d.\n", 
					b->number);
		    fprintf_unfiltered (tmp_error_stream, 
					"Temporarily disabling shared library breakpoints:\n");
		  }
		disabled_breaks = 1;
		fprintf_unfiltered (tmp_error_stream, 
				    "breakpoint #%d\n", b->number);
	      }
	    else
#endif
	      {
#ifdef ONE_PROCESS_WRITETEXT
		process_warning = 1;
#endif
		if (b->type == bp_hardware_breakpoint)
		  {
		    hw_breakpoint_error = 1;
		    fprintf_unfiltered (tmp_error_stream, 
					"Cannot insert hardware breakpoint %d.\n",
					b->number);
		  }
		else
		  {
		    fprintf_unfiltered (tmp_error_stream, 
					"Cannot insert breakpoint %d.\n", 
					b->number);
		    fprintf_filtered (tmp_error_stream, 
				      "Error accessing memory address ");
		    print_address_numeric (b->loc->address, 1, tmp_error_stream);
		    fprintf_filtered (tmp_error_stream, ": %s.\n",
				      safe_strerror (val));
		  }

	      }
	  }
	else
	  b->loc->inserted = 1;

	if (val)
	  return_val = val;	/* remember failure */
      }
    else if (ep_is_exception_catchpoint (b)
	     && !b->loc->inserted
	     && !b->loc->duplicate)

      {
	/* If we get here, we must have a callback mechanism for exception
	   events -- with g++ style embedded label support, we insert
	   ordinary breakpoints and not catchpoints. */
	val = target_insert_breakpoint (b->loc->address, b->loc->shadow_contents);
	if (val)
	  {
	    /* Couldn't set breakpoint for some reason */
	    fprintf_unfiltered (tmp_error_stream, 
				"Cannot insert catchpoint %d; disabling it.\n",
				b->number);
	    fprintf_filtered (tmp_error_stream, 
			      "Error accessing memory address ");
	    print_address_numeric (b->loc->address, 1, tmp_error_stream);
	    fprintf_filtered (tmp_error_stream, ": %s.\n",
			      safe_strerror (val));
	    b->enable_state = bp_disabled;
	  }
	else
	  {
	    /* Bp set, now make sure callbacks are enabled */
	    /* Format possible error msg */
	    char *message = xstrprintf ("Error inserting catchpoint %d:\n",
					b->number);
	    struct cleanup *cleanups = make_cleanup (xfree, message);
	    int val;
	    args_for_catchpoint_enable args;
	    args.kind = b->type == bp_catch_catch ? 
	      EX_EVENT_CATCH : EX_EVENT_THROW;
	    args.enable_p = 1;
	    val = catch_errors (cover_target_enable_exception_callback,
				&args, message, RETURN_MASK_ALL);
	    do_cleanups (cleanups);
	    if (val != 0 && val != -1)
	      {
		b->loc->inserted = 1;
	      }
	    /* Check if something went wrong; val == 0 can be ignored */
	    if (val == -1)
	      {
		/* something went wrong */
		fprintf_unfiltered (tmp_error_stream, 
				    "Cannot insert catchpoint %d; disabling it.\n",
				    b->number);
		b->enable_state = bp_disabled;
	      }
	  }

	if (val)
	  return_val = val;	/* remember failure */
      }

    else if ((b->type == bp_hardware_watchpoint ||
	      b->type == bp_read_watchpoint ||
	      b->type == bp_access_watchpoint)
	     && b->disposition != disp_del_at_next_stop
	     && !b->loc->inserted
	     && !b->loc->duplicate)
      {
	struct frame_info *saved_frame;
	int saved_level, within_current_scope;
	struct value *mark = value_mark ();
	struct value *v;

	/* Save the current frame and level so we can restore it after
	   evaluating the watchpoint expression on its own frame.  */
	saved_frame = deprecated_selected_frame;
	saved_level = frame_relative_level (deprecated_selected_frame);

	/* Determine if the watchpoint is within scope.  */
	if (b->exp_valid_block == NULL)
	  within_current_scope = 1;
	else
	  {
	    struct frame_info *fi;
	    fi = frame_find_by_id (b->watchpoint_frame);
	    within_current_scope = (fi != NULL);
	    if (within_current_scope)
	      select_frame (fi);
	  }

	if (within_current_scope)
	  {
	    /* Evaluate the expression and cut the chain of values
	       produced off from the value chain.

	       Make sure the value returned isn't lazy; we use
	       laziness to determine what memory GDB actually needed
	       in order to compute the value of the expression.  */
	    v = evaluate_expression (b->exp);
	    VALUE_CONTENTS(v);
	    value_release_to_mark (mark);

	    b->val_chain = v;
	    b->loc->inserted = 1;

	    /* Look at each value on the value chain.  */
	    for (; v; v = v->next)
	      {
		/* If it's a memory location, and GDB actually needed
                   its contents to evaluate the expression, then we
                   must watch it.  */
		if (VALUE_LVAL (v) == lval_memory
		    && ! VALUE_LAZY (v))
		  {
		    struct type *vtype = check_typedef (VALUE_TYPE (v));

		    /* We only watch structs and arrays if user asked
		       for it explicitly, never if they just happen to
		       appear in the middle of some value chain.  */
		    if (v == b->val_chain
			|| (TYPE_CODE (vtype) != TYPE_CODE_STRUCT
			    && TYPE_CODE (vtype) != TYPE_CODE_ARRAY))
		      {
			CORE_ADDR addr;
			int len, type;

			addr = VALUE_ADDRESS (v) + VALUE_OFFSET (v);
			len = TYPE_LENGTH (VALUE_TYPE (v));
			type = hw_write;
			if (b->type == bp_read_watchpoint)
			  type = hw_read;
			else if (b->type == bp_access_watchpoint)
			  type = hw_access;

			val = target_insert_watchpoint (addr, len, type);
			if (val == -1)
			  {
			    /* Don't exit the loop, try to insert
			       every value on the value chain.  That's
			       because we will be removing all the
			       watches below, and removing a
			       watchpoint we didn't insert could have
			       adverse effects.  */
			    b->loc->inserted = 0;
			  }
			val = 0;
		      }
		  }
	      }
	    /* Failure to insert a watchpoint on any memory value in the
	       value chain brings us here.  */
	    if (!b->loc->inserted)
	      {
		remove_breakpoint (b, mark_uninserted);
		hw_breakpoint_error = 1;
		fprintf_unfiltered (tmp_error_stream,
				    "Could not insert hardware watchpoint %d.\n", 
				    b->number);
		val = -1;
	      }               
	  }
	else
	  {
	    printf_filtered ("Hardware watchpoint %d deleted ", b->number);
	    printf_filtered ("because the program has left the block \n");
	    printf_filtered ("in which its expression is valid.\n");
	    if (b->related_breakpoint)
	      b->related_breakpoint->disposition = disp_del_at_next_stop;
	    b->disposition = disp_del_at_next_stop;
	  }

	/* Restore the frame and level.  */
	if ((saved_frame != deprecated_selected_frame) ||
	    (saved_level != frame_relative_level (deprecated_selected_frame)))
	  select_frame (saved_frame);

	if (val)
	  return_val = val;	/* remember failure */
      }
    else if ((b->type == bp_catch_fork
	      || b->type == bp_catch_vfork
	      || b->type == bp_catch_exec)
	     && !b->loc->inserted
	     && !b->loc->duplicate)
      {
	char *prefix = xstrprintf ("warning: inserting catchpoint %d: ",
				   b->number);
	struct cleanup *cleanups = make_cleanup (xfree, prefix);
	val = catch_exceptions (uiout, insert_catchpoint, b, prefix,
				RETURN_MASK_ERROR);
	do_cleanups (cleanups);
	if (val < 0)
	  b->enable_state = bp_disabled;
	else
	  b->loc->inserted = 1;
      }
  }
  
  if (return_val) 
d1133 1
a1133 1
      if (hw_breakpoint_error)  
@


1.137
log
@	* breakpoint.c (read_memory_nobpt): Use ALL_BP_LOCATIONS
	instead of ALL_BREAKPOINTS.  Check for software breakpoints only.
@
text
@d805 2
a806 2
	    || b->section == NULL
	    || !(section_is_overlay (b->section)))
d831 1
a831 1
							       b->section);
d841 1
a841 1
	    if (section_is_mapped (b->section))
d1386 2
a1387 2
	  || b->section == NULL
	  || !(section_is_overlay (b->section)))
d1407 1
a1407 1
							   b->section);
d1659 2
a1660 2
	    && section_is_overlay (b->section) 
	    && !section_is_mapped (b->section))
d1686 2
a1687 2
	  && section_is_overlay (b->section) 
	  && !section_is_mapped (b->section))
d1746 2
a1747 2
	  && section_is_overlay (b->section) 
	  && !section_is_mapped (b->section))
d2560 2
a2561 2
	    && section_is_overlay (b->section) 
	    && !section_is_mapped (b->section))
d2570 2
a2571 2
	    && section_is_overlay (b->section) 
	    && !section_is_mapped (b->section))
d3433 1
a3433 1
	    sym = find_pc_sect_function (b->loc->address, b->section);
d3713 1
a3713 1
      if (!overlay_debugging || b->section == section)
d3720 1
a3720 1
	  if (!overlay_debugging || b->section == section)
d3801 1
a3801 1
  asection *section = bpt->section;
d3811 1
a3811 1
	&& (!overlay_debugging || b->section == section)
d3850 1
a3850 1
		&& (!overlay_debugging || b->section == section)
d4000 1
a4000 1
  b->section = sal.section;
d6556 2
a6557 2
		   && (!section_is_overlay (b->section)
		       || b->section == sal.section))
d6726 1
a6726 1
	    && b->section == bpt->section
d6994 1
a6994 1
	  b->section = sals.sals[i].section;
@


1.136
log
@	* breakpoint.c (allocate_bp_location): Take bpt and bp_type
	arguments.  Initialize owner and type for the new breakpoint
	location item.
	(set_raw_breakpoint): Update call to allocate_bp_location.
@
text
@d628 1
a628 1
  struct breakpoint *b;
d636 1
a636 1
  ALL_BREAKPOINTS (b)
d638 5
a642 9
    if (b->type == bp_none)
      warning ("reading through apparently deleted breakpoint #%d?", 
	       b->number);

    /* memory breakpoint? */
    if (b->type == bp_watchpoint
	|| b->type == bp_hardware_watchpoint
	|| b->type == bp_read_watchpoint
	|| b->type == bp_access_watchpoint)
d644 1
a644 2
    /* bp in memory? */
    if (!b->loc->inserted)
d652 1
a652 1
    bp_addr = b->loc->address;
d688 1
a688 1
	      b->loc->shadow_contents + bptoffset, bp_size);
@


1.135
log
@	* breakpoint.h (struct bp_location): Add a chain pointer.
	* breakpoint.c (ALL_BP_LOCATIONS, ALL_BP_LOCATIONS_SAFE): New
	macros.
	(bp_location_chain): New variable.
	(allocate_bp_location): New function.
	(set_raw_breakpoint): Use it.
	(delete_breakpoint): Remove ->loc from the bp_location_chain.
@
text
@d3913 1
a3913 1
allocate_bp_location (void)
d3920 40
d3997 1
a3997 1
  b->loc = allocate_bp_location ();
@


1.134
log
@	* breakpoint.h (enum bp_loc_type, struct bp_location): New.
	(struct breakpoint): Remove address, shadow_contents, inserted,
	and duplicate.  Add a struct bp_location.
	* breakpoint.c (condition_command, read_memory_nobpt)
	(insert_breakpoints, remove_breakpoints, remove_hw_watchpoints)
	(reattach_breakpoints, update_breakpoints_after_exec)
	(detach_breakpoints, remove_breakpoint, mark_breakpoints_out)
	(breakpoint_init_inferior, breakpoint_here_p)
	(breakpoint_inserted_here_p, deprecated_frame_in_dummy)
	(breakpoint_thread_match, bpstat_stop_status)
	(bpstat_have_active_hw_watchpoints, print_one_breakpoint)
	(describe_other_breakpoints, check_duplicates)
	(make_breakpoint_permanent, create_thread_event_breakpoint)
	(disable_breakpoints_in_shlibs, re_enable_berakpoints_in_shlibs)
	(set_longjmp_resume_breakpoint, mention, create_breakpoints)
	(watch_command_1, print_one_exception_catchpoint)
	(clear_command, breakpoint_re_set_one): Adjust member accesses to
	use the breakpoint's ->loc.
	(set_raw_breakpoint): Likewise.  Initialize ->loc.
	(delete_breakpoint): Likewise.  Free ->loc.
@
text
@d238 9
d261 1
a261 1
/* Chain of all breakpoints defined.  */
d265 2
d3910 25
d3957 1
a3957 2
  b->loc = (struct bp_location *) xmalloc (sizeof (struct bp_location));
  memset (b->loc, 0, sizeof (*b->loc));
d6607 1
d6639 3
d6670 7
@


1.133
log
@2003-10-21  Elena Zannoni  <ezannoni@@redhat.com>

	* minsyms.c (lookup_minimal_symbol_text): Remove unused parameter.
	Remove SOFUN_ADDRESS_MAYBE_MISSING ifdeffed code.
	* symtab.h (lookup_minimal_symbol_text): Update.
 	* breakpoint.c (create_overlay_event_breakpoint,
 	create_longjmp_breakpoint): Update callers.
	* ppc-linux-tdep.c (ppc_linux_skip_trampoline_code): Update caller.
	* symtab.c (find_pc_sect_line): Ditto.
@
text
@d555 1
a555 1
	  b->cond = parse_exp_1 (&arg, block_for_pc (b->address), 0);
d638 1
a638 1
    if (!b->inserted)
d646 1
a646 1
    bp_addr = b->address;
d682 1
a682 1
	      b->shadow_contents + bptoffset, bp_size);
d790 2
a791 2
	&& !b->inserted
	&& !b->duplicate)
d805 2
a806 2
	      val = target_insert_hw_breakpoint (b->address, 
						 b->shadow_contents);
d808 1
a808 1
	      val = target_insert_breakpoint (b->address, b->shadow_contents);
d824 1
a824 1
		    CORE_ADDR addr = overlay_unmapped_address (b->address, 
d827 1
a827 1
		    val = target_insert_breakpoint (addr, b->shadow_contents);
d839 2
a840 2
		  val = target_insert_hw_breakpoint (b->address, 
						     b->shadow_contents);
d842 2
a843 2
		  val = target_insert_breakpoint (b->address,
						  b->shadow_contents);
d857 1
a857 1
	    if (DISABLE_UNSETTABLE_BREAK (b->address))
d894 1
a894 1
		    print_address_numeric (b->address, 1, tmp_error_stream);
d902 1
a902 1
	  b->inserted = 1;
d908 2
a909 2
	     && !b->inserted
	     && !b->duplicate)
d915 1
a915 1
	val = target_insert_breakpoint (b->address, b->shadow_contents);
d924 1
a924 1
	    print_address_numeric (b->address, 1, tmp_error_stream);
d946 1
a946 1
		b->inserted = 1;
d967 2
a968 2
	     && !b->inserted
	     && !b->duplicate)
d1005 1
a1005 1
	    b->inserted = 1;
d1045 1
a1045 1
			    b->inserted = 0;
d1053 1
a1053 1
	    if (!b->inserted)
d1084 2
a1085 2
	     && !b->inserted
	     && !b->duplicate)
d1096 1
a1096 1
	  b->inserted = 1;
d1129 1
a1129 1
    if (b->inserted)
d1147 1
a1147 1
    if (b->inserted
d1171 1
a1171 1
    if (b->inserted)
d1175 1
a1175 1
	  val = target_insert_hw_breakpoint (b->address, b->shadow_contents);
d1177 1
a1177 1
	  val = target_insert_breakpoint (b->address, b->shadow_contents);
d1264 1
a1264 1
	b->address = (CORE_ADDR) NULL;
d1317 1
a1317 1
    b->address = (CORE_ADDR) NULL;
d1337 1
a1337 1
    if (b->inserted)
d1386 2
a1387 2
	    val = target_remove_hw_breakpoint (b->address, 
					       b->shadow_contents);
d1389 1
a1389 1
	    val = target_remove_breakpoint (b->address, b->shadow_contents);
d1400 1
a1400 1
		CORE_ADDR addr = overlay_unmapped_address (b->address, 
d1405 1
a1405 1
		  target_remove_hw_breakpoint (addr, b->shadow_contents);
d1407 1
a1407 1
		  target_remove_breakpoint (addr, b->shadow_contents);
d1411 1
a1411 1
	  if (b->inserted)
d1418 2
a1419 2
		val = target_remove_hw_breakpoint (b->address, 
						   b->shadow_contents);
d1421 2
a1422 2
		val = target_remove_breakpoint (b->address,
						b->shadow_contents);
d1432 1
a1432 1
      b->inserted = (is == mark_inserted);
d1438 1
a1438 1
	   && !b->duplicate)
d1443 1
a1443 1
      b->inserted = (is == mark_inserted);
d1471 1
a1471 1
		    b->inserted = 1;
d1477 1
a1477 1
      if ((is == mark_uninserted) && (b->inserted))
d1494 1
a1494 1
	   && !b->duplicate)
d1514 1
a1514 1
      b->inserted = (is == mark_inserted);
d1519 1
a1519 1
	   && !b->duplicate)
d1522 1
a1522 1
      val = target_remove_breakpoint (b->address, b->shadow_contents);
d1525 1
a1525 1
      b->inserted = (is == mark_inserted);
d1528 1
a1528 1
	   && b->inserted	/* sometimes previous insert doesn't happen */
d1530 1
a1530 1
	   && !b->duplicate)
d1533 1
a1533 1
      val = target_remove_breakpoint (b->address, b->shadow_contents);
d1537 1
a1537 1
      b->inserted = (is == mark_inserted);
d1551 1
a1551 1
    b->inserted = 0;
d1574 1
a1574 1
    b->inserted = 0;
d1650 1
a1650 1
	&& b->address == pc)	/* bp is enabled and matches pc */
d1676 2
a1677 2
    if (b->inserted
	&& b->address == pc)	/* bp is inserted and matches pc */
d1713 1
a1713 1
	    >= (b->address
d1715 1
a1715 1
	&& get_frame_pc (frame) <= b->address)
d1736 1
a1736 1
	&& b->address == pc
d2030 3
a2032 3
      if (bs->breakpoint_at->address != bs->breakpoint_at->requested_address)
	breakpoint_adjustment_warning (bs->breakpoint_at->requested_address,
	                               bs->breakpoint_at->address,
d2551 1
a2551 1
	if (b->address != bp_addr) 	/* address doesn't match */
d2561 1
a2561 1
	if (b->address != (*pc - DECR_PC_AFTER_HW_BREAK))
d3152 1
a3152 1
	(b->inserted) &&
d3421 1
a3421 1
	    ui_out_field_core_addr (uiout, "addr", b->address);
d3424 1
a3424 1
	*last_addr = b->address;
d3427 1
a3427 1
	    sym = find_pc_sect_function (b->address, b->section);
d3442 1
a3442 1
	    print_address_symbolic (b->address, stb->stream, demangle, "");
d3706 1
a3706 1
    if (b->address == pc)	/* address match / overlay match */
d3713 1
a3713 1
	if (b->address == pc)	/* address match / overlay match */
d3794 1
a3794 1
  CORE_ADDR address = bpt->address;
d3804 1
a3804 1
	&& b->address == address	/* address / overlay match */
d3816 1
a3816 1
      b->duplicate = count > 1;
d3824 1
a3824 1
      perm_bp->duplicate = 0;
d3827 1
a3827 1
      if (! perm_bp->inserted)
d3835 1
a3835 1
	    if (b->inserted)
d3843 1
a3843 1
		&& b->address == address	/* address / overlay match */
d3846 1
a3846 1
	      b->duplicate = 1;
d3921 4
a3924 2
  b->requested_address = sal.pc;
  b->address = adjust_breakpoint_address (b->requested_address);
d3977 1
a3977 1
  b->inserted = 1;
d4115 1
a4115 1
  xasprintf (&b->addr_string, "*0x%s", paddr (b->address));
d4166 2
a4167 2
	!b->duplicate &&
	PC_SOLIB (b->address))
d4198 1
a4198 1
      if (target_read_memory (b->address, buf, 1) == 0)
d4415 2
a4416 2
      b->requested_address = pc;
      b->address = adjust_breakpoint_address (b->requested_address);
d4616 1
a4616 1
	  print_address_numeric (b->address, 1, gdb_stdout);
d4678 1
a4678 1
	  xasprintf (&b->addr_string, "*0x%s", paddr (b->address));
d5531 4
a5534 3
	  scope_breakpoint->requested_address = get_frame_pc (prev_frame);
	  scope_breakpoint->address =
	    adjust_breakpoint_address (scope_breakpoint->requested_address);
d6126 1
a6126 1
      ui_out_field_core_addr (uiout, "addr", b->address);
d6129 1
a6129 1
  *last_addr = b->address;
d6485 1
a6485 1
	      && (((sal.pc && (b->address == sal.pc)) 
d6597 1
a6597 1
  if (bpt->inserted)
d6635 1
a6635 1
  if (bpt->inserted
d6644 1
a6644 1
	if (b->address == bpt->address
d6646 1
a6646 1
	    && !b->duplicate
d6663 1
a6663 1
	    val = target_insert_hw_breakpoint (b->address, b->shadow_contents);
d6665 1
a6665 1
	    val = target_insert_breakpoint (b->address, b->shadow_contents);
d6685 1
a6685 1
		    print_address_numeric (b->address, 1, tmp_error_stream);
d6695 1
a6695 1
	    b->inserted = 1;
d6735 1
d6877 1
a6877 1
	  if (b->address != sals.sals[i].pc
d6899 3
a6901 2
	      b->requested_address = sals.sals[i].pc;
	      b->address = adjust_breakpoint_address (b->requested_address);
@


1.132
log
@	* breakpoint.h (struct breakpoint): Add new member
	``requested_address''.
	* breakpoint.c (breakpoint_adjustment_warning)
	(adjust_breakpoint_address): New static functions.
	(print_it_typical): Issue warning if breakpoint's address is different
	from its requested address.
	(set_raw_breakpoint, set_longjmp_resume_breakpoint, watch_command_1)
	(breakpoint_re_set_one):  Set breakpoint's
	``requested_address'' field.  Set ``address'' field to the
	result of calling adjust_breakpoint_address() on the requested
	address.
@
text
@d4008 1
a4008 1
      if ((m = lookup_minimal_symbol_text (func_name, NULL, NULL)) == NULL)
d4057 1
a4057 1
  if ((m = lookup_minimal_symbol_text (func_name, NULL, NULL)) == NULL)
@


1.131
log
@2003-10-06  Andrew Cagney  <cagney@@redhat.com>

	* breakpoint.c, breakpoint.h: Remove obsolete code and comments.
	* buildsym.c, dbxread.c, gdbtypes.c, mdebugread.c: Ditto.
	* monitor.c, sparc-tdep.c, stabsread.c: Ditto.
	* stabsread.h, xcoffread.c: Ditto.
@
text
@d100 4
d2030 4
d3851 48
d3921 2
a3922 1
  b->address = sal.pc;
d4413 2
a4414 1
      b->address = pc;
d5529 3
a5531 1
	  scope_breakpoint->address = get_frame_pc (prev_frame);
d6895 2
a6896 1
	      b->address = sals.sals[i].pc;
@


1.130
log
@2003-09-20  Andrew Cagney  <cagney@@redhat.com>

	* breakpoint.c: Eliminate ARGSUSED.
	* buildsym.c, cli/cli-cmds.c, cli/cli-script.c: Ditto.
	* coffread.c, corelow.c, dwarf2read.c, event-top.c: Ditto.
	* exec.c, gcore.c, hpux-thread.c, infcmd.c, inflow.c: Ditto.
	* infrun.c, inftarg.c, maint.c, ocd.c, printcmd.c: Ditto.
	* procfs.c, regcache.c, remote-rdi.c, remote-sds.c: Ditto.
	* remote.c, sol-thread.c, source.c, stabsread.c: Ditto.
	* stack.c, symfile.c, target.c, top.c, typeprint.c: Ditto.
	* utils.c, v850ice.c, valprint.c, values.c, win32-nat.c: Ditto.
	* wince.c, remote-vx.c: Ditto.
@
text
@d1248 5
a1252 5
       valid code address on some platforms (like the OBSOLETE mn10200
       and mn10300 simulators).  We shouldn't assign any special
       interpretation to a breakpoint with a zero address.  And in
       fact, GDB doesn't --- I can't see what that comment above is
       talking about.  As far as I can tell, setting the address of a
@


1.129
log
@2003-09-14  Andrew Cagney  <cagney@@redhat.com>

	* alpha-nat.c: Remove some occurances of "register".
	* alpha-tdep.c, arm-tdep.c, blockframe.c, breakpoint.c: Ditto.
	* buildsym.c, c-typeprint.c, c-valprint.c, coffread.c: Ditto.
	* corefile.c, cp-support.c, cp-valprint.c, cris-tdep.c: Ditto.
	* dbxread.c, dcache.c, dwarf2read.c, elfread.c: Ditto.
	* environ.c, eval.c, event-top.c, f-typeprint.c: Ditto.
	* f-valprint.c, findvar.c, frame.c, gdbtypes.c: Ditto.
	* h8300-tdep.c, hppa-tdep.c, hppab-nat.c, hppah-nat.c: Ditto.
	* hppam3-nat.c, hpread.c, ia64-aix-nat.c, ia64-linux-nat.c: Ditto.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Ditto.
	* infttrace.c, irix5-nat.c, jv-typeprint.c: Ditto.
	* jv-valprint.c, m68k-tdep.c, m68klinux-nat.c, main.c: Ditto.
	* mdebugread.c, minsyms.c, mips-linux-tdep.c: Ditto.
	* mips-nat.c, mips-tdep.c, mipsread.c, mipsv4-nat.c: Ditto.
	* ns32k-tdep.c, objfiles.c, p-typeprint.c: Ditto.
	* p-valprint.c, ppc-linux-nat.c, printcmd.c: Ditto.
	* remote-mips.c, remote-vx.c, rs6000-nat.c: Ditto.
	* rs6000-tdep.c, scm-exp.c, sh-tdep.c, sh64-tdep.c: Ditto.
	* solib.c, somread.c, source.c, sparc-tdep.c: Ditto.
	* stabsread.c, stack.c, standalone.c, symfile.c: Ditto.
	* symmisc.c, symtab.c, top.c, tracepoint.c: Ditto.
	* typeprint.c, utils.c, valarith.c, valops.c: Ditto.
	* values.c, vax-tdep.c, xcoffread.c: Ditto.
@
text
@a562 1
/* ARGSUSED */
a1925 1
/* ARGSUSED */
a3666 1
/* ARGSUSED */
a3677 1
/* ARGSUSED */
a5318 1
/* ARGSUSED */
a5620 1
/* ARGSUSED */
a7128 1
/* ARGSUSED */
a7261 1
/* ARGSUSED */
a7300 1
/* ARGSUSED */
a7312 1
/* ARGSUSED */
@


1.128
log
@	* breakpoint.c (watchpoint_check): Remove accidentally checked in
	unused code.  Add comment.
@
text
@d515 1
a515 1
  register struct breakpoint *b;
d517 1
a517 1
  register int bnum;
d567 1
a567 1
  register struct breakpoint *b;
d569 1
a569 1
  register int bnum;
d743 1
a743 1
  register struct breakpoint *b, *temp;
d1121 1
a1121 1
  register struct breakpoint *b;
d1139 1
a1139 1
  register struct breakpoint *b;
d1160 1
a1160 1
  register struct breakpoint *b;
d1323 1
a1323 1
  register struct breakpoint *b;
d1545 1
a1545 1
  register struct breakpoint *b;
d1566 1
a1566 1
  register struct breakpoint *b, *temp;
d1641 1
a1641 1
  register struct breakpoint *b;
d1670 1
a1670 1
  register struct breakpoint *b;
d2510 1
a2510 1
  register struct breakpoint *b, *temp;
d3223 2
a3224 2
  register struct command_line *l;
  register struct symbol *sym;
d3530 1
a3530 1
  register struct breakpoint *b;
d3582 1
a3582 1
  register struct breakpoint *b;
d3698 2
a3699 2
  register int others = 0;
  register struct breakpoint *b;
d3787 2
a3788 2
  register struct breakpoint *b;
  register int count = 0;
d3865 1
a3865 1
  register struct breakpoint *b, *b1;
d3974 1
a3974 1
  register struct breakpoint *b;
d3987 1
a3987 1
  register struct breakpoint *b;
d4026 1
a4026 1
  register struct breakpoint *b;
d4040 1
a4040 1
  register struct breakpoint *b;
d4079 1
a4079 1
  register struct breakpoint *b, *temp;
d4311 1
a4311 1
  register struct breakpoint *b;
d4326 1
a4326 1
  register struct breakpoint *b;
d4355 1
a4355 1
  register struct breakpoint *b;
d4417 1
a4417 1
  register struct breakpoint *b;
d4746 1
a4746 1
  register struct expression **cond = 0;
d4889 1
a4889 1
  register struct expression **cond;
d6513 2
a6514 2
  register struct breakpoint *b;
  register bpstat bs;
d7002 1
a7002 1
  register struct breakpoint *b;
d7047 1
a7047 1
  register int num;
d7071 1
a7071 1
  register char *p = args;
d7073 2
a7074 2
  register int num;
  register struct breakpoint *b, *tmp;
d7139 1
a7139 1
  register struct breakpoint *bpt;
d7273 1
a7273 1
  register struct breakpoint *bpt;
@


1.127
log
@	* breakpoint.c (watchpoint_check): Check for pc being in an
	epilogue if watchpoint frame couldn't be found.
@
text
@a2410 6
#if 0
      current_frame_id = get_frame_id (get_current_frame ());
      within_current_scope = frame_id_eq (current_frame_id, b->watchpoint_frame)
			     || frame_id_inner (current_frame_id,
			     			b->watchpoint_frame);
#else
a2411 1
#endif
d2416 6
a2421 4
	 state as `not changed' without further checking. */
#if 0
      if (within_current_scope && (!fr || fr == get_current_frame ())
#else
a2422 1
#endif
@


1.126
log
@2003-08-09  Andrew Cagney  <cagney@@redhat.com>

	* defs.h (xstrprintf): Declare.
	* utils.c (xstrprintf): New function.
	* breakpoint.c (insert_breakpoints): Replace sprintf and
	non-literal format strings, with xstrprintf and cleanups.
	(delete_breakpoint,breakpoint_re_set): Ditto.
	(commands_command, insert_breakpoints): Ditto.
	(bpstat_stop_status, break_at_finish_at_depth_command_1): Ditto.
	(break_at_finish_command_1): Ditto.
@
text
@d2396 3
d2411 6
d2418 1
d2424 5
a2428 1
      if (within_current_scope && fr == get_current_frame ()
d2431 1
a2431 1
      if (within_current_scope)
@


1.125
log
@	* breakpoint.c (insert_catchpoint): Make static.
@
text
@d587 11
a597 11
    {
      char tmpbuf[128];
      sprintf (tmpbuf, 
	       "Type commands for when breakpoint %d is hit, one per line.", 
	       bnum);
      l = read_command_lines (tmpbuf, from_tty);
      free_command_lines (&b->commands);
      b->commands = l;
      breakpoints_changed ();
      breakpoint_modify_event (b->number);
      return;
a751 3
  static char message1[] = "Error inserting catchpoint %d:\n";
  static char message[sizeof (message1) + 30];

a911 3
	/* Format possible error message */
	sprintf (message, message1, b->number);

d929 4
d939 2
a940 2
				&args,
				message, RETURN_MASK_ALL);
d1084 3
a1086 3
	char prefix[64];

	sprintf (prefix, "warning: inserting catchpoint %d: ", b->number);
d1089 1
a2509 3
  static char message1[] =
  "Error evaluating expression for watchpoint %d\n";
  char message[sizeof (message1) + 30 /* slop */ ];
a2607 1
    sprintf (message, message1, b->number);
d2611 7
a2617 2
	switch (catch_errors (watchpoint_check, bs, message, 
			      RETURN_MASK_ALL))
d2685 43
a2727 36
	  switch (catch_errors (watchpoint_check, bs, message,
				RETURN_MASK_ALL))
	    {
	    case WP_DELETED:
	      /* We've already printed what needs to be printed.  */
	      bs->print_it = print_it_done;
	      /* Stop.  */
	      break;
	    case WP_VALUE_CHANGED:
	      if (b->type == bp_read_watchpoint)
		{
		  /* Don't stop: read watchpoints shouldn't fire if
		     the value has changed.  This is for targets which
		     cannot set read-only watchpoints.  */
		  bs->print_it = print_it_noop;
		  bs->stop = 0;
		  continue;
		}
	      ++(b->hit_count);
	      break;
	    case WP_VALUE_NOT_CHANGED:
	      /* Stop.  */
	      ++(b->hit_count);
	      break;
	    default:
	      /* Can't happen.  */
	    case 0:
	      /* Error from catch_errors.  */
	      printf_filtered ("Watchpoint %d deleted.\n", b->number);
	      if (b->related_breakpoint)
		b->related_breakpoint->disposition = disp_del_at_next_stop;
	      b->disposition = disp_del_at_next_stop;
	      /* We've already printed what needs to be printed.  */
	      bs->print_it = print_it_done;
	      break;
	    }
a4994 1
  char *addr_string;
d5048 1
a5048 1
	  addr_string = (char *) xmalloc (26 + extra_args_len);
d5050 1
a5050 1
	    sprintf (addr_string, "*0x%s %s", paddr_nz (high), extra_args);
d5052 1
a5052 1
	    sprintf (addr_string, "*0x%s", paddr_nz (high));
d5083 2
a5084 3
	      addr_string = (char *) xmalloc (15);
	      sprintf (addr_string, "*0x%s",
		       paddr_nz (get_frame_pc (deprecated_selected_frame)));
d5130 1
a5130 1
	  break_string = (char *) xmalloc (extra_args_len + 26);
d5132 2
a5133 1
	    sprintf (break_string, "*0x%s %s", paddr_nz (high), extra_args);
d5135 1
a5135 1
	    sprintf (break_string, "*0x%s", paddr_nz (high));
d6546 4
a6549 2
      static char message1[] = "Error in deleting catchpoint %d:\n";
      static char message[sizeof (message1) + 30];
a6550 3

      /* Format possible error msg */
      sprintf (message, message1, bpt->number);
d6556 1
a6945 2
  static char message1[] = "Error in re-setting breakpoint %d:\n";
  char message[sizeof (message1) + 30 /* slop */ ];
d6952 3
a6954 1
    sprintf (message, message1, b->number);
d6956 1
@


1.124
log
@	* breakpoint.c (insert_catchpoint): Call internal_error.
@
text
@d707 1
a707 1
int
@


1.124.2.1
log
@	* breakpoint.c (insert_catchpoint): Make static.
@
text
@d707 1
a707 1
static int
@


1.123
log
@	* breakpoint.c (insert_catchpoint): New function.
	(insert_breakpoints): Use catch_exceptions to call
	insert_catchpoint.  Disable catchpoints if they fail to insert.
@
text
@d725 1
a725 1
      warning ("Internal error, %s line %d.", __FILE__, __LINE__);
@


1.122
log
@2003-06-08  Andrew Cagney  <cagney@@redhat.com>

	* acinclude.m4 (gcc_AC_CHECK_DECL, (gcc_AC_CHECK_DECL): Stolen
	from GCC's acinclude.m4.
	* configure.in: Check for getopt's delcaration.
	* aclocal.m4, config.in, configure: Re-generate.
	* main.c (error_init): Delete declaration.
	* defs.h (error_init): Declare.
	* rs6000-tdep.c (rs6000_fetch_pointer_argument): Make static.
	(rs6000_convert_from_func_ptr_addr): Make static.
	(_initialize_rs6000_tdep): Add declaration.
	* cli/cli-cmds.c (dont_repeat): Delete declaration.
	(show_commands, set_verbose, show_history): Delete declaration.
	* top.h (set_verbose): Add declaration.
	(show_history, set_history, show_commands): Add declaration.
	(do_restore_instream_cleanup): Add declaration.
	* objc-lang.c (specialcmp): Make static.
	(print_object_command): Make static.
	(find_objc_msgsend): Make static.
	(find_objc_msgcall_submethod_helper): Make static.
	(find_objc_msgcall_submethod): Make static.
	(_initialize_objc_language): Add declaration.
	(find_implementation_from_class): Make static.
	(find_implementation): Make static.
	* objc-exp.y (yylex): Delete lookup_struct_typedef declaration.
	* objc-lang.h (lookup_struct_typedef): Add declaration.
	* cli/cli-interp.c (_initialize_cli_interp): Add declaration.
	* cli/cli-script.c (clear_hook_in_cleanup): Make static.
	(do_restore_user_call_depth): Make static.
	(do_restore_instream_cleanup): Delete declaration.
	(dont_repeat): Delete declaration.
	* cli/cli-decode.c (add_abbrev_cmd): Delete function.
	* cli/cli-dump.c (_initialize_cli_dump): Add declaration.
	* reggroups.c (_initialize_reggroup): Add declaration.
	* cp-support.c (_initialize_cp_support): Add declaration.
	* cp-abi.c (_initialize_cp_abi): Add declaration.
	* hpacc-abi.c (_initialize_hpacc_abi): Add declaration.
	* gnu-v3-abi.c (gnuv3_baseclass_offset): Make static.
	(_initialize_gnu_v3_abi): Add declaration.
	* gnu-v2-abi.c (gnuv2_value_rtti_type): Make static.
	(_initialize_gnu_v2_abi): Add declaration.
	* frame-base.c (_initialize_frame_base): Add declaration.
	* doublest.c (floatformat_from_length): Make static.
	* frame-unwind.c (_initialize_frame_unwind): Add declaration.
	* frame.c (create_sentinel_frame): Make static.
	(_initialize_frame): Add declaration.
	* top.c (do_catch_errors): Make static.
	(gdb_rl_operate_and_get_next_completion): Make static.
	* typeprint.c: Include "typeprint.h".
	* sentinel-frame.c (sentinel_frame_prev_register): Make static.
	(sentinel_frame_this_id): Make static.
	* p-valprint.c (_initialize_pascal_valprint): Add declaration.
	* ui-out.c (make_cleanup_ui_out_begin_end): Delete function.
	* dwarf2-frame.c (dwarf2_frame_cache): Make static.
	* p-exp.y (push_current_type, pop_current_type): ISO C declaration.
	* dwarf2expr.h (dwarf_expr_context): ISO C declaration.
	* maint.c (maintenance_print_architecture): Make static.
	* signals/signals.c (_initialize_signals): Add declaration.
	* std-regs.c (_initialize_frame_reg): Add declaration.
	* jv-exp.y (push_variable): ISO C definition.
	(push_qualified_expression_name): Ditto.
	* memattr.c (_initialize_mem): Add declaration.
	* remote.c (remote_check_watch_resources): Make static.
	(remote_stopped_by_watchpoint): Make static.
	(remote_stopped_data_address): Make static.
	* d10v-tdep.c (nr_dmap_regs): Make static.
	(a0_regnum): Make static.
	(d10v_frame_unwind_cache): Make static.
	(d10v_frame_p): Make static.
	* osabi.c (show_osabi): Make static.
	(_initialize_gdb_osabi): Add extern declaration.
	* gdbtypes.c (make_qualified_type): Make static.
	(safe_parse_type): Make static.
	* macrocmd.c (_initialize_macrocmd): Add extern declaration.
	* macrotab.c (macro_bcache_free): Make static.
	* interps.c (interp_set_quiet): Make static.
	(interpreter_exec_cmd): Make static.
	* stack.h (select_frame_command): New file.
	* stack.c: Include "stack.h".
	(select_frame_command_wrapper): Delete function.
	(select_frame_command): Make global.
	* infcall.c: Include "infcall.h".
	* linespec.c: Include "linespec.h".
	* symfile.c (sections_overlap): Make static.
	* cp-support.h (cp_initialize_namespace): ISO C declaration.
	* charset.c (_initialize_charset): Add missing prototype.
	* regcache.c (init_legacy_regcache_descr): Make static.
	(do_regcache_xfree): Make static.
	(regcache_xfer_part): Make static.
	(_initialize_regcache): Add missing prototype.
	* breakpoint.c (parse_breakpoint_sals): Make static.
	(breakpoint_sals_to_pc): Make static.
	* interps.h (clear_interpreter_hooks): ISO C declaration.
	* Makefile.in (stack_h): Define.
	(stack.o, typeprint.o, mi-main.o): Update dependencies.
	(mi-cmd-stack.o, infcall.o, linespec.o): Update dependencies.

Index: mi/ChangeLog
2003-06-08  Andrew Cagney  <cagney@@redhat.com>

	* mi-parse.c (_initialize_mi_parse): Delete function.
	* mi-main.c: Include "mi-main.h".
	* mi-interp.c (_initialize_mi_interp): Add declaration.
	* mi-cmd-stack.c: Include "stack.h".
	(select_frame_command_wrapper): Delete extern declaration.
	(mi_cmd_stack_select_frame): Replace select_frame_command_wrapper
	with select_frame_command.
@
text
@d706 29
d1086 5
a1090 16
	val = -1;
	switch (b->type)
	  {
	  case bp_catch_fork:
	    val = target_insert_fork_catchpoint (PIDGET (inferior_ptid));
	    break;
	  case bp_catch_vfork:
	    val = target_insert_vfork_catchpoint (PIDGET (inferior_ptid));
	    break;
	  case bp_catch_exec:
	    val = target_insert_exec_catchpoint (PIDGET (inferior_ptid));
	    break;
	  default:
	    warning ("Internal error, %s line %d.", __FILE__, __LINE__);
	    break;
	  }
d1092 1
a1092 4
	  {
	    fprintf_unfiltered (tmp_error_stream, 
				"Cannot insert catchpoint %d.", b->number);
	  }
a1094 3

	if (val)
	  return_val = val;	/* remember failure */
@


1.121
log
@2003-06-01  Andrew Cagney  <cagney@@redhat.com>

	* dwarfread.c: Eliminate "register"
	(decode_die_type): Eliminate assignment within "if".
	(struct_type, decode_array_element_type): Ditto.
	(dwarf_read_array_type, read_tag_pointer_type): Ditto.
	(read_subroutine_type, enum_type, add_enum_psymbol): Ditto.
	(decode_modified_type, completedieinfo): Ditto.
	* block.c: Eliminate "register".
	(blockvector_for_pc_sect): Eliminate assignment within "if".
	* cp-support.h (struct symbol): Opaque declaration.
	* breakpoint.c (handle_gnu_v3_exceptions): Use xfree, not free.
@
text
@d4610 1
a4610 1
void
d4677 1
a4677 1
void
@


1.120
log
@2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_SIZE): Rename REGISTER_SIZE.
	(DEPRECATED_SIZEOF_CALL_DUMMY_WORDS): Rename
	SIZEOF_CALL_DUMMY_WORDS.
	(DEPRECATED_CALL_DUMMY_WORDS): Rename CALL_DUMMY_WORDS.
	(DEPRECATED_FIX_CALL_DUMMY): Rename FIX_CALL_DUMMY.
	(DEPRECATED_CALL_DUMMY_BREAKPOINT_OFFSET): Rename
	CALL_DUMMY_BREAKPOINT_OFFSET.
	(DEPRECATED_CALL_DUMMY_START_OFFSET): Rename
	CALL_DUMMY_START_OFFSET.
	(DEPRECATED_CALL_DUMMY_LENGTH): Rename CALL_DUMMY_LENGTH.
	* gdbarch.h, gdbarch.c: Re-generate.
	* alpha-tdep.c, alphafbsd-tdep.c, arm-linux-tdep.c: Update.
	* arm-tdep.c, avr-tdep.c, breakpoint.c, cris-tdep.c: Update.
	* dummy-frame.c, dummy-frame.h, frv-tdep.c, gdbarch.c: Update.
	* gdbarch.h, gdbarch.sh, h8300-tdep.c, hppa-tdep.c: Update.
	* i386-tdep.c, ia64-tdep.c, infcall.c, inferior.h: Update.
	* m68hc11-tdep.c, m68k-tdep.c, mcore-tdep.c: Update.
	* mips-tdep.c, mn10300-tdep.c, ns32k-tdep.c: Update.
	* rs6000-tdep.c, s390-tdep.c, sh-tdep.c, sol-thread.c: Update.
	* sparc-tdep.c, target.c, v850-tdep.c, valops.c: Update.
	* vax-tdep.c, x86-64-tdep.c, xstormy16-tdep.c: Update.
	* config/ia64/tm-ia64.h, config/m68k/tm-vx68.h: Update.
	* config/mips/tm-mips.h, config/pa/nm-hppah.h: Update.
	* config/pa/tm-hppa.h, config/pa/tm-hppa64.h: Update.
	* config/s390/tm-s390.h, config/sparc/tm-sp64.h: Update.
	* config/sparc/tm-sparc.h: Update.

Index: doc/ChangeLog
2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Make
	CALL_DUMMY_WORDS, SIZEOF_CALL_DUMMY_WORDS, CALL_DUMMY_LENGTH,
	FIX_CALL_DUMMY, CALL_DUMMY_BREAKPOINT_OFFSET and
	CALL_DUMMY_BREAKPOINT_OFFSET deprecated.

Index: mi/ChangeLog
2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c (mi_cmd_data_write_register_values): Replace
	REGISTER_SIZE with DEPRECATED_REGISTER_SIZE.

Index: testsuite/ChangeLog
2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* gdb.base/watchpoint.exp: Rename CALL_DUMMY_BREAKPOINT_OFFSET to
	DEPRECATED_CALL_DUMMY_BREAKPOINT_OFFSET in comments.
@
text
@d6085 1
a6085 1
      free (trigger_func_name);
d6101 1
a6101 1
  free (sals.sals);
@


1.120.8.1
log
@Snap const char * mess.
@
text
@d59 1
a59 1
static void catch_command_1 (const char *, int, int);
d61 1
a61 1
static void enable_delete_command (const char *, int);
d65 1
a65 1
static void enable_once_command (const char *, int);
d69 1
a69 1
static void disable_command (const char *, int);
d71 1
a71 1
static void enable_command (const char *, int);
d73 1
a73 2
static void map_breakpoint_numbers (const char *,
				    void (*)(struct breakpoint *));
d75 1
a75 1
static void ignore_command (const char *, int);
d79 1
a79 1
static void clear_command (const char *, int);
d81 1
a81 1
static void catch_command (const char *, int);
d83 1
a83 1
static void watch_command (const char *, int);
d87 2
a88 2
extern void break_at_finish_command (const char *, int);
extern void break_at_finish_at_depth_command (const char *, int);
d90 1
a90 1
extern void tbreak_at_finish_command (const char *, int);
d92 1
a92 1
static void break_command_1 (const char *, int, int);
d102 1
a102 1
static void breakpoints_info (const char *, int);
d112 1
a112 1
static void commands_command (const char *, int);
d114 1
a114 1
static void condition_command (const char *, int);
d116 1
a116 1
static int get_number_trailer (const char **, int);
d144 1
a144 1
static void maintenance_info_breakpoints (const char *, int);
d146 1
a146 1
static void create_longjmp_breakpoint (const char *);
d148 1
a148 1
static void create_overlay_event_breakpoint (const char *);
d154 1
a154 1
static void hbreak_command (const char *, int);
d156 1
a156 1
static void thbreak_command (const char *, int);
d158 1
a158 1
static void watch_command_1 (const char *, int, int);
d160 1
a160 1
static void rwatch_command (const char *, int);
d162 1
a162 1
static void awatch_command (const char *, int);
d166 1
a166 1
static void solib_load_unload_1 (const char *hookname,
d175 1
a175 1
static void break_at_finish_at_depth_command_1 (const char *arg,
d178 1
a178 1
static void break_at_finish_command_1 (const char *arg, int flag, int from_tty);
d180 1
a180 1
static void stop_command (const char *arg, int from_tty);
d182 1
a182 1
static void stopin_command (const char *arg, int from_tty);
d184 1
a184 1
static void stopat_command (const char *arg, int from_tty);
d186 1
a186 1
static const char *ep_find_event_name_end (const char *arg);
d188 1
a188 1
static const char *ep_parse_optional_if_clause (const char **arg);
d190 1
a190 1
static char *ep_parse_optional_filename (const char **arg);
d196 1
a196 1
static void create_exception_catchpoint (int tempflag, const char *cond_string,
d201 1
a201 2
				       const char *arg, int tempflag,
				       int from_tty);
d203 1
a203 1
static void tcatch_command (const char *arg, int from_tty);
d205 1
a205 1
static void ep_skip_leading_whitespace (const char **s);
d363 1
a363 1
get_number_trailer (const char **pp, int trailer)
d366 1
a366 1
  const char *p = *pp;
d376 1
a376 1
      const char *start = ++p;
d427 1
a427 1
get_number (const char **pp)
d449 1
a449 1
get_number_or_range (const char **pp)
d452 1
a452 1
  static const char *end_ptr;
d462 1
a462 1
	  const char **temp;
d513 1
a513 1
condition_command (const char *arg, int from_tty)
d516 1
a516 1
  const char *p;
d565 1
a565 1
commands_command (const char *arg, int from_tty)
d568 1
a568 1
  const char *p;
d3201 1
a3201 1
      const char *description;
d3232 1
a3232 1
  static const char *bpdisps[] =
d3644 1
a3644 1
breakpoints_info (const char *bnum_exp, int from_tty)
d3656 1
a3656 1
maintenance_info_breakpoints (const char *bnum_exp, int from_tty)
d3919 1
a3919 1
create_longjmp_breakpoint (const char *func_name)
d3972 1
a3972 1
create_overlay_event_breakpoint (const char *func_name)
d4124 1
a4124 1
solib_load_unload_1 (const char *hookname, int tempflag, char *dll_pathname,
d4131 2
a4132 2
  const char *addr_start = hookname;
  const char *addr_end = NULL;
d4611 1
a4611 1
parse_breakpoint_sals (const char **address,
d4615 1
a4615 1
  const char *addr_start = *address;
d4679 1
a4679 1
		       const char *address)
d4715 1
a4715 1
break_command_1 (const char *arg, int flag, int from_tty)
d4723 1
a4723 1
  const char *addr_start = arg;
d4784 1
a4784 1
      const char *tok = arg;
d4787 1
a4787 1
	  const char *end_tok;
d4789 2
a4790 2
	  const char *cond_start = NULL;
	  const char *cond_end = NULL;
d4812 1
a4812 1
	      const char *tmptok;
d4869 1
a4869 1
  const char *address_end;
d4930 1
a4930 1
	  const char *tok = args->condition;
d4970 1
a4970 1
break_at_finish_at_depth_command_1 (const char *arg, int flag, int from_tty)
d4974 1
a4974 1
  const char *extra_args = NULL;
d5028 1
a5028 1
      if (find_pc_partial_function (selected_pc, NULL, &low, &high))
d5047 1
a5047 1
break_at_finish_command_1 (const char *arg, int flag, int from_tty)
d5049 1
a5049 3
  const char *addr_string;
  char *break_string;
  char *beg_addr_string;
d5054 1
a5054 1
  const char *extra_args = NULL;
d5065 3
a5067 4
	      char *tmp;
	      xasprintf (&tmp, "*0x%s",
			 paddr_nz (get_frame_pc (deprecated_selected_frame)));
	      beg_addr_string = tmp;
d5079 2
a5080 1
      beg_addr_string = xstrdup (arg);
d5102 1
a5102 1
  addr_string = beg_addr_string;
d5111 1
a5111 1
      if (find_pc_partial_function (sal.pc, NULL, &low, &high))
d5183 1
a5183 1
break_command (const char *arg, int from_tty)
d5189 1
a5189 1
break_at_finish_command (const char *arg, int from_tty)
d5195 1
a5195 1
break_at_finish_at_depth_command (const char *arg, int from_tty)
d5201 1
a5201 1
tbreak_command (const char *arg, int from_tty)
d5207 1
a5207 1
tbreak_at_finish_command (const char *arg, int from_tty)
d5213 1
a5213 1
hbreak_command (const char *arg, int from_tty)
d5219 1
a5219 1
thbreak_command (const char *arg, int from_tty)
d5225 1
a5225 1
stop_command (const char *arg, int from_tty)
d5233 1
a5233 1
stopin_command (const char *arg, int from_tty)
d5241 1
a5241 1
      const char *argptr = arg;
d5266 1
a5266 1
stopat_command (const char *arg, int from_tty)
d5274 1
a5274 1
      const char *argptr = arg;
d5302 1
a5302 1
watch_command_1 (const char *arg, int accessflag, int from_tty)
d5311 3
a5313 4
  const char *exp_start = NULL;
  const char *exp_end = NULL;
  const char *tok;
  const char *end_tok;
d5315 2
a5316 2
  const char *cond_start = NULL;
  const char *cond_end = NULL;
d5554 1
a5554 1
watch_command (const char *arg, int from_tty)
d5566 1
a5566 1
rwatch_command (const char *arg, int from_tty)
d5578 1
a5578 1
awatch_command (const char *arg, int from_tty)
d5602 1
a5602 1
until_break_command (const char *arg, int from_tty, int anywhere)
d5718 1
a5718 1
ep_skip_leading_whitespace (const char **s)
d5731 2
a5732 2
static const char *
ep_find_event_name_end (const char *arg)
d5734 2
a5735 2
  const char *s = arg;
  const char *event_name_end = NULL;
d5764 2
a5765 2
static const char *
ep_parse_optional_if_clause (const char **arg)
d5767 1
a5767 1
  const char *cond_string;
d5797 1
a5797 1
ep_parse_optional_filename (const char **arg)
d5800 1
a5800 1
  const char *arg_p = *arg;
d5896 1
a5896 1
catch_load_command_1 (const char *arg, int tempflag, int from_tty)
d5899 1
a5899 1
  const char *cond_string = NULL;
d5938 1
a5938 1
catch_unload_command_1 (const char *arg, int tempflag, int from_tty)
d5941 1
a5941 1
  const char *cond_string = NULL;
d5986 1
a5986 1
create_exception_catchpoint (int tempflag, const char *cond_string,
d6069 1
a6069 1
handle_gnu_v3_exceptions (int tempflag, const char *cond_string,
d6072 1
a6072 2
  char *trigger_func_name;
  const char *nameptr;
d6109 2
a6110 2
catch_exception_command_1 (enum exception_event_kind ex_event,
			   const char *arg, int tempflag, int from_tty)
d6112 1
a6112 1
  const char *cond_string = NULL;
d6163 1
a6163 1
catch_command_1 (const char *arg, int tempflag, int from_tty)
d6172 2
a6173 2
  const char *arg1_start = arg;
  const char *arg1_end;
d6322 1
a6322 1
catch_command (const char *arg, int from_tty)
d6329 1
a6329 1
tcatch_command (const char *arg, int from_tty)
d6337 1
a6337 1
clear_command (const char *arg, int from_tty)
d6674 1
a6674 1
delete_command (const char *arg, int from_tty)
d6728 1
a6728 1
  const char *s;
d7017 1
a7017 1
ignore_command (const char *args, int from_tty)
d7019 1
a7019 1
  const char *p = args;
d7042 1
a7042 2
map_breakpoint_numbers (const char *args,
			void (*function) (struct breakpoint *))
d7044 2
a7045 2
  const char *p = args;
  const char *p1;
d7110 1
a7110 1
disable_command (const char *args, int from_tty)
d7244 1
a7244 1
enable_command (const char *args, int from_tty)
d7284 1
a7284 1
enable_once_command (const char *args, int from_tty)
d7297 1
a7297 1
enable_delete_command (const char *args, int from_tty)
d7305 1
a7305 1
decode_line_spec_1 (const char *string, int funfirstline)
@


1.119
log
@	* breakpoint.h (struct breakpoint_ops): New.
	(struct breakpoint): Add ops member.

	* breakpoint.c (print_bp_stop_message, print_one_breakpoint)
	(mention): Use new breakpoint ops member.
	(set_raw_breakpoint): Initialize ops field to NULL.
	(print_exception_catchpoint, print_one_exception_catchpoint)
	(print_mention_exception_catchpoint, handle_gnu_v3_exceptions): New.
	(gnu_v3_exception_catchpoint_ops): New.
	(catch_exception_command_1): Call handle_gnu_v3_exceptions.
@
text
@d1700 1
a1700 1
		- SIZEOF_CALL_DUMMY_WORDS / sizeof (LONGEST) * REGISTER_SIZE))
d5467 1
a5467 1
    ((BYTE_SIZE) <= (REGISTER_SIZE))
@


1.118
log
@2003-04-09  Andrew Cagney  <cagney@@redhat.com>

	* frame.h (struct frame_id): Replace "pc" and "base" with
	"stack_addr" and "code_addr".  Update comments.
	(frame_id_build): Update parameter names and comment.
	(struct frame_info): Replace "id_p" and "id" with "this_id".
	* dummy-frame.c (dummy_frame_this_id): Update.
	* breakpoint.c (print_one_breakpoint): Update.
	* frame.c (get_frame_id): Update.
	(get_frame_base, frame_id_build): Update.
	(create_sentinel_frame, legacy_get_prev_frame): Update.
	(deprecated_update_frame_base_hack): Update.
	(frame_id_p, frame_id_eq): Rework, return 0 when an invalid ID.
	(frame_id_inner): Ditto.
@
text
@d2274 7
a2280 2
      /* Normal case, we handle everything in print_it_typical. */
      return print_it_typical (bs);
d2282 1
a3273 6
  switch (b->type)
    {
    case bp_none:
      internal_error (__FILE__, __LINE__,
		      "print_one_breakpoint: bp_none encountered\n");
      break;
d3275 96
a3370 64
    case bp_watchpoint:
    case bp_hardware_watchpoint:
    case bp_read_watchpoint:
    case bp_access_watchpoint:
      /* Field 4, the address, is omitted (which makes the columns
	 not line up too nicely with the headers, but the effect
	 is relatively readable).  */
      if (addressprint)
	ui_out_field_skip (uiout, "addr");
      annotate_field (5);
      print_expression (b->exp, stb->stream);
      ui_out_field_stream (uiout, "what", stb);
      break;
      
    case bp_catch_load:
    case bp_catch_unload:
      /* Field 4, the address, is omitted (which makes the columns
	 not line up too nicely with the headers, but the effect
	 is relatively readable).  */
      if (addressprint)
	ui_out_field_skip (uiout, "addr");
      annotate_field (5);
      if (b->dll_pathname == NULL)
	{
	  ui_out_field_string (uiout, "what", "<any library>");
	  ui_out_spaces (uiout, 1);
	}
      else
	{
	  ui_out_text (uiout, "library \"");
	  ui_out_field_string (uiout, "what", b->dll_pathname);
	  ui_out_text (uiout, "\" ");
	}
      break;
      
    case bp_catch_fork:
    case bp_catch_vfork:
      /* Field 4, the address, is omitted (which makes the columns
	 not line up too nicely with the headers, but the effect
	 is relatively readable).  */
      if (addressprint)
	ui_out_field_skip (uiout, "addr");
      annotate_field (5);
      if (b->forked_inferior_pid != 0)
	{
	  ui_out_text (uiout, "process ");
	  ui_out_field_int (uiout, "what", b->forked_inferior_pid);
	  ui_out_spaces (uiout, 1);
	}
      
    case bp_catch_exec:
      /* Field 4, the address, is omitted (which makes the columns
	 not line up too nicely with the headers, but the effect
	 is relatively readable).  */
      if (addressprint)
	ui_out_field_skip (uiout, "addr");
      annotate_field (5);
      if (b->exec_pathname != NULL)
	{
	  ui_out_text (uiout, "program \"");
	  ui_out_field_string (uiout, "what", b->exec_pathname);
	  ui_out_text (uiout, "\" ");
	}
      break;
d3372 42
a3413 10
    case bp_catch_catch:
      /* Field 4, the address, is omitted (which makes the columns
	 not line up too nicely with the headers, but the effect
	 is relatively readable).  */
      if (addressprint)
	ui_out_field_skip (uiout, "addr");
      annotate_field (5);
      ui_out_field_string (uiout, "what", "exception catch");
      ui_out_spaces (uiout, 1);
      break;
a3414 54
    case bp_catch_throw:
      /* Field 4, the address, is omitted (which makes the columns
	 not line up too nicely with the headers, but the effect
	 is relatively readable).  */
      if (addressprint)
	ui_out_field_skip (uiout, "addr");
      annotate_field (5);
      ui_out_field_string (uiout, "what", "exception throw");
      ui_out_spaces (uiout, 1);
      break;
      
    case bp_breakpoint:
    case bp_hardware_breakpoint:
    case bp_until:
    case bp_finish:
    case bp_longjmp:
    case bp_longjmp_resume:
    case bp_step_resume:
    case bp_through_sigtramp:
    case bp_watchpoint_scope:
    case bp_call_dummy:
    case bp_shlib_event:
    case bp_thread_event:
    case bp_overlay_event:
      if (addressprint)
	{
	  annotate_field (4);
	  ui_out_field_core_addr (uiout, "addr", b->address);
	}
      annotate_field (5);
      *last_addr = b->address;
      if (b->source_file)
	{
	  sym = find_pc_sect_function (b->address, b->section);
	  if (sym)
	    {
	      ui_out_text (uiout, "in ");
	      ui_out_field_string (uiout, "func",
				   SYMBOL_PRINT_NAME (sym));
	      ui_out_wrap_hint (uiout, wrap_indent);
	      ui_out_text (uiout, " at ");
	    }
	  ui_out_field_string (uiout, "file", b->source_file);
	  ui_out_text (uiout, ":");
	  ui_out_field_int (uiout, "line", b->line_number);
	}
      else
	{
	  print_address_symbolic (b->address, stb->stream, demangle, "");
	  ui_out_field_stream (uiout, "at", stb);
	}
      break;
    }
  
d3864 1
d4427 100
a4526 83
  switch (b->type)
    {
    case bp_none:
      printf_filtered ("(apparently deleted?) Eventpoint %d: ", b->number);
      break;
    case bp_watchpoint:
      ui_out_text (uiout, "Watchpoint ");
      ui_out_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "wpt");
      ui_out_field_int (uiout, "number", b->number);
      ui_out_text (uiout, ": ");
      print_expression (b->exp, stb->stream);
      ui_out_field_stream (uiout, "exp", stb);
      do_cleanups (ui_out_chain);
      break;
    case bp_hardware_watchpoint:
      ui_out_text (uiout, "Hardware watchpoint ");
      ui_out_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "wpt");
      ui_out_field_int (uiout, "number", b->number);
      ui_out_text (uiout, ": ");
      print_expression (b->exp, stb->stream);
      ui_out_field_stream (uiout, "exp", stb);
      do_cleanups (ui_out_chain);
      break;
    case bp_read_watchpoint:
      ui_out_text (uiout, "Hardware read watchpoint ");
      ui_out_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "hw-rwpt");
      ui_out_field_int (uiout, "number", b->number);
      ui_out_text (uiout, ": ");
      print_expression (b->exp, stb->stream);
      ui_out_field_stream (uiout, "exp", stb);
      do_cleanups (ui_out_chain);
      break;
    case bp_access_watchpoint:
      ui_out_text (uiout, "Hardware access (read/write) watchpoint ");
      ui_out_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "hw-awpt");
      ui_out_field_int (uiout, "number", b->number);
      ui_out_text (uiout, ": ");
      print_expression (b->exp, stb->stream);
      ui_out_field_stream (uiout, "exp", stb);
      do_cleanups (ui_out_chain);
      break;
    case bp_breakpoint:
      if (ui_out_is_mi_like_p (uiout))
	{
	  say_where = 0;
	  break;
	}
      printf_filtered ("Breakpoint %d", b->number);
      say_where = 1;
      break;
    case bp_hardware_breakpoint:
      if (ui_out_is_mi_like_p (uiout))
	{
	  say_where = 0;
	  break;
	}
      printf_filtered ("Hardware assisted breakpoint %d", b->number);
      say_where = 1;
      break;
    case bp_catch_load:
    case bp_catch_unload:
      printf_filtered ("Catchpoint %d (%s %s)",
		       b->number,
		       (b->type == bp_catch_load) ? "load" : "unload",
		       (b->dll_pathname != NULL) ? 
		       b->dll_pathname : "<any library>");
      break;
    case bp_catch_fork:
    case bp_catch_vfork:
      printf_filtered ("Catchpoint %d (%s)",
		       b->number,
		       (b->type == bp_catch_fork) ? "fork" : "vfork");
      break;
    case bp_catch_exec:
      printf_filtered ("Catchpoint %d (exec)",
		       b->number);
      break;
    case bp_catch_catch:
    case bp_catch_throw:
      printf_filtered ("Catchpoint %d (%s)",
		       b->number,
		       (b->type == bp_catch_catch) ? "catch" : "throw");
      break;
a4527 13
    case bp_until:
    case bp_finish:
    case bp_longjmp:
    case bp_longjmp_resume:
    case bp_step_resume:
    case bp_through_sigtramp:
    case bp_call_dummy:
    case bp_watchpoint_scope:
    case bp_shlib_event:
    case bp_thread_event:
    case bp_overlay_event:
      break;
    }
d6022 84
d6125 3
@


1.118.2.1
log
@Merge from mainline.
@
text
@d2274 2
a2275 7
      /* Normal case.  Call the breakpoint's print_it method, or
	 print_it_typical.  */
      if (bs->breakpoint_at != NULL && bs->breakpoint_at->ops != NULL
	  && bs->breakpoint_at->ops->print_it != NULL)
	return bs->breakpoint_at->ops->print_it (bs->breakpoint_at);
      else
	return print_it_typical (bs);
a2276 1

d3268 6
d3275 64
a3338 9
  if (b->ops != NULL && b->ops->print_one != NULL)
    b->ops->print_one (b, last_addr);
  else
    switch (b->type)
      {
      case bp_none:
	internal_error (__FILE__, __LINE__,
			"print_one_breakpoint: bp_none encountered\n");
	break;
d3340 10
a3349 129
      case bp_watchpoint:
      case bp_hardware_watchpoint:
      case bp_read_watchpoint:
      case bp_access_watchpoint:
	/* Field 4, the address, is omitted (which makes the columns
	   not line up too nicely with the headers, but the effect
	   is relatively readable).  */
	if (addressprint)
	  ui_out_field_skip (uiout, "addr");
	annotate_field (5);
	print_expression (b->exp, stb->stream);
	ui_out_field_stream (uiout, "what", stb);
	break;

      case bp_catch_load:
      case bp_catch_unload:
	/* Field 4, the address, is omitted (which makes the columns
	   not line up too nicely with the headers, but the effect
	   is relatively readable).  */
	if (addressprint)
	  ui_out_field_skip (uiout, "addr");
	annotate_field (5);
	if (b->dll_pathname == NULL)
	  {
	    ui_out_field_string (uiout, "what", "<any library>");
	    ui_out_spaces (uiout, 1);
	  }
	else
	  {
	    ui_out_text (uiout, "library \"");
	    ui_out_field_string (uiout, "what", b->dll_pathname);
	    ui_out_text (uiout, "\" ");
	  }
	break;

      case bp_catch_fork:
      case bp_catch_vfork:
	/* Field 4, the address, is omitted (which makes the columns
	   not line up too nicely with the headers, but the effect
	   is relatively readable).  */
	if (addressprint)
	  ui_out_field_skip (uiout, "addr");
	annotate_field (5);
	if (b->forked_inferior_pid != 0)
	  {
	    ui_out_text (uiout, "process ");
	    ui_out_field_int (uiout, "what", b->forked_inferior_pid);
	    ui_out_spaces (uiout, 1);
	  }

      case bp_catch_exec:
	/* Field 4, the address, is omitted (which makes the columns
	   not line up too nicely with the headers, but the effect
	   is relatively readable).  */
	if (addressprint)
	  ui_out_field_skip (uiout, "addr");
	annotate_field (5);
	if (b->exec_pathname != NULL)
	  {
	    ui_out_text (uiout, "program \"");
	    ui_out_field_string (uiout, "what", b->exec_pathname);
	    ui_out_text (uiout, "\" ");
	  }
	break;

      case bp_catch_catch:
	/* Field 4, the address, is omitted (which makes the columns
	   not line up too nicely with the headers, but the effect
	   is relatively readable).  */
	if (addressprint)
	  ui_out_field_skip (uiout, "addr");
	annotate_field (5);
	ui_out_field_string (uiout, "what", "exception catch");
	ui_out_spaces (uiout, 1);
	break;

      case bp_catch_throw:
	/* Field 4, the address, is omitted (which makes the columns
	   not line up too nicely with the headers, but the effect
	   is relatively readable).  */
	if (addressprint)
	  ui_out_field_skip (uiout, "addr");
	annotate_field (5);
	ui_out_field_string (uiout, "what", "exception throw");
	ui_out_spaces (uiout, 1);
	break;

      case bp_breakpoint:
      case bp_hardware_breakpoint:
      case bp_until:
      case bp_finish:
      case bp_longjmp:
      case bp_longjmp_resume:
      case bp_step_resume:
      case bp_through_sigtramp:
      case bp_watchpoint_scope:
      case bp_call_dummy:
      case bp_shlib_event:
      case bp_thread_event:
      case bp_overlay_event:
	if (addressprint)
	  {
	    annotate_field (4);
	    ui_out_field_core_addr (uiout, "addr", b->address);
	  }
	annotate_field (5);
	*last_addr = b->address;
	if (b->source_file)
	  {
	    sym = find_pc_sect_function (b->address, b->section);
	    if (sym)
	      {
		ui_out_text (uiout, "in ");
		ui_out_field_string (uiout, "func",
				     SYMBOL_PRINT_NAME (sym));
		ui_out_wrap_hint (uiout, wrap_indent);
		ui_out_text (uiout, " at ");
	      }
	    ui_out_field_string (uiout, "file", b->source_file);
	    ui_out_text (uiout, ":");
	    ui_out_field_int (uiout, "line", b->line_number);
	  }
	else
	  {
	    print_address_symbolic (b->address, stb->stream, demangle, "");
	    ui_out_field_stream (uiout, "at", stb);
	  }
	break;
      }
d3351 54
a3853 1
  b->ops = NULL;
d4416 83
a4498 100
  if (b->ops != NULL && b->ops->print_mention != NULL)
    b->ops->print_mention (b);
  else
    switch (b->type)
      {
      case bp_none:
	printf_filtered ("(apparently deleted?) Eventpoint %d: ", b->number);
	break;
      case bp_watchpoint:
	ui_out_text (uiout, "Watchpoint ");
	ui_out_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "wpt");
	ui_out_field_int (uiout, "number", b->number);
	ui_out_text (uiout, ": ");
	print_expression (b->exp, stb->stream);
	ui_out_field_stream (uiout, "exp", stb);
	do_cleanups (ui_out_chain);
	break;
      case bp_hardware_watchpoint:
	ui_out_text (uiout, "Hardware watchpoint ");
	ui_out_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "wpt");
	ui_out_field_int (uiout, "number", b->number);
	ui_out_text (uiout, ": ");
	print_expression (b->exp, stb->stream);
	ui_out_field_stream (uiout, "exp", stb);
	do_cleanups (ui_out_chain);
	break;
      case bp_read_watchpoint:
	ui_out_text (uiout, "Hardware read watchpoint ");
	ui_out_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "hw-rwpt");
	ui_out_field_int (uiout, "number", b->number);
	ui_out_text (uiout, ": ");
	print_expression (b->exp, stb->stream);
	ui_out_field_stream (uiout, "exp", stb);
	do_cleanups (ui_out_chain);
	break;
      case bp_access_watchpoint:
	ui_out_text (uiout, "Hardware access (read/write) watchpoint ");
	ui_out_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "hw-awpt");
	ui_out_field_int (uiout, "number", b->number);
	ui_out_text (uiout, ": ");
	print_expression (b->exp, stb->stream);
	ui_out_field_stream (uiout, "exp", stb);
	do_cleanups (ui_out_chain);
	break;
      case bp_breakpoint:
	if (ui_out_is_mi_like_p (uiout))
	  {
	    say_where = 0;
	    break;
	  }
	printf_filtered ("Breakpoint %d", b->number);
	say_where = 1;
	break;
      case bp_hardware_breakpoint:
	if (ui_out_is_mi_like_p (uiout))
	  {
	    say_where = 0;
	    break;
	  }
	printf_filtered ("Hardware assisted breakpoint %d", b->number);
	say_where = 1;
	break;
      case bp_catch_load:
      case bp_catch_unload:
	printf_filtered ("Catchpoint %d (%s %s)",
			 b->number,
			 (b->type == bp_catch_load) ? "load" : "unload",
			 (b->dll_pathname != NULL) ? 
			 b->dll_pathname : "<any library>");
	break;
      case bp_catch_fork:
      case bp_catch_vfork:
	printf_filtered ("Catchpoint %d (%s)",
			 b->number,
			 (b->type == bp_catch_fork) ? "fork" : "vfork");
	break;
      case bp_catch_exec:
	printf_filtered ("Catchpoint %d (exec)",
			 b->number);
	break;
      case bp_catch_catch:
      case bp_catch_throw:
	printf_filtered ("Catchpoint %d (%s)",
			 b->number,
			 (b->type == bp_catch_catch) ? "catch" : "throw");
	break;

      case bp_until:
      case bp_finish:
      case bp_longjmp:
      case bp_longjmp_resume:
      case bp_step_resume:
      case bp_through_sigtramp:
      case bp_call_dummy:
      case bp_watchpoint_scope:
      case bp_shlib_event:
      case bp_thread_event:
      case bp_overlay_event:
	break;
      }
d4500 13
a6006 84
static enum print_stop_action
print_exception_catchpoint (struct breakpoint *b)
{
  annotate_catchpoint (b->number);

  if (strstr (b->addr_string, "throw") != NULL)
    printf_filtered ("\nCatchpoint %d (exception thrown)\n",
		     b->number);
  else
    printf_filtered ("\nCatchpoint %d (exception caught)\n",
		     b->number);

  return PRINT_SRC_AND_LOC;
}

static void
print_one_exception_catchpoint (struct breakpoint *b, CORE_ADDR *last_addr)
{
  if (addressprint)
    {
      annotate_field (4);
      ui_out_field_core_addr (uiout, "addr", b->address);
    }
  annotate_field (5);
  *last_addr = b->address;
  if (strstr (b->addr_string, "throw") != NULL)
    ui_out_field_string (uiout, "what", "exception throw");
  else
    ui_out_field_string (uiout, "what", "exception catch");
}

static void
print_mention_exception_catchpoint (struct breakpoint *b)
{
  if (strstr (b->addr_string, "throw") != NULL)
    printf_filtered ("Catchpoint %d (throw)", b->number);
  else
    printf_filtered ("Catchpoint %d (catch)", b->number);
}

static struct breakpoint_ops gnu_v3_exception_catchpoint_ops = {
  print_exception_catchpoint,
  print_one_exception_catchpoint,
  print_mention_exception_catchpoint
};

static int
handle_gnu_v3_exceptions (int tempflag, char *cond_string,
			  enum exception_event_kind ex_event, int from_tty)
{
  char *trigger_func_name, *nameptr;
  struct symtabs_and_lines sals;
  struct breakpoint *b;

  if (ex_event == EX_EVENT_CATCH)
    trigger_func_name = xstrdup ("__cxa_begin_catch");
  else
    trigger_func_name = xstrdup ("__cxa_throw");

  nameptr = trigger_func_name;
  sals = decode_line_1 (&nameptr, 1, NULL, 0, NULL);
  if (sals.nelts == 0)
    {
      free (trigger_func_name);
      return 0;
    }

  b = set_raw_breakpoint (sals.sals[0], bp_breakpoint);
  set_breakpoint_count (breakpoint_count + 1);
  b->number = breakpoint_count;
  b->cond = NULL;
  b->cond_string = (cond_string == NULL) ? 
    NULL : savestring (cond_string, strlen (cond_string));
  b->thread = -1;
  b->addr_string = trigger_func_name;
  b->enable_state = bp_enabled;
  b->disposition = tempflag ? disp_del : disp_donttouch;
  b->ops = &gnu_v3_exception_catchpoint_ops;

  free (sals.sals);
  mention (b);
  return 1;
}

a6025 3

  if (handle_gnu_v3_exceptions (tempflag, cond_string, ex_event, from_tty))
    return;
@


1.118.2.2
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d1700 1
a1700 1
		- DEPRECATED_SIZEOF_CALL_DUMMY_WORDS / sizeof (LONGEST) * DEPRECATED_REGISTER_SIZE))
d5467 1
a5467 1
    ((BYTE_SIZE) <= (DEPRECATED_REGISTER_SIZE))
@


1.117
log
@2003-03-31  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (CALL_DUMMY_P): Delete.
	* gdbarch.h, gdbarch.c: Re-generate.
	* inferior.h (CALL_DUMMY_P): Delete macro.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* d10v-tdep.c (d10v_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* breakpoint.c (deprecated_frame_in_dummy): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* dummy-frame.c (dummy_frame_this_id): Update comments.
	* rs6000-tdep.c (rs6000_extract_struct_value_address): Ditto.
	* frame.c (legacy_get_prev_frame): Ditto.
	* valops.c (call_function_by_hand): Delete function.
	(hand_function_call): Rename to call_function_by_hand

2003-03-31  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	references to CALL_DUMMY_P.
@
text
@d3421 1
a3421 1
      ui_out_field_core_addr (uiout, "frame", b->frame_id.base);
@


1.117.2.1
log
@2003-04-03  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (frame_id_eq): Update.  Compare function addresses.
	(get_frame_func): New function.
	(frame_func_unwind): New function.
	(legacy_get_prev_frame): Move linking of prev to next to the start
	of the function.
	(frame_id_p): Update.
	(get_frame_id): Return the frame's "id".  Do not set "frame".
	(frame_id_build): Update.
	(frame_id_inner): Update.
	(create_sentinel_frame): Do not set the "pc".
	(select_frame): Use get_frame_pc.
	(legacy_saved_regs_this_id): Use frame_id_build.
	(create_new_frame): Set the frame's ID.  Store the PC in the
	sentinel frame's PC unwind cache.
	(legacy_get_prev_frame): Do not set "pc" or "frame".  Instead use
	frame_pc_unwind, frame_id_build, deprecated_update_frame_pc_hack,
	and deprecated_update_frame_base_hack.
	(get_prev_frame): Do not set "pc" or "frame", instead use
	frame_pc_unwind.
	(get_frame_pc): Use frame_pc_unwind.
	(find_frame_sal): Use get_frame_pc.
	(get_frame_base): Return the frame ID's stack address.
	(deprecated_update_frame_base_hack): Set the frame ID's stack
	address.
	(frame_id_eq, frame_id_p, frame_id_inner, get_frame_id): Add debug
	print statements.

	* d10v-tdep.c (d10v_frame_unwind_cache): Use frame_func_unwind.
	(d10v_frame_this_id): Get the frame's function.
	(d10v_frame_this_id): Use frame_id_eq.
	(d10v_unwind_dummy_id): Use frame_id_build.

	* stack.c (print_frame_info): Use get_frame_pc.

	* dummy-frame.c (dummy_frame_this_id): Use frame_id_build.  Update
	parameter to find_dummy_frame.

	* breakpoint.c (print_one_breakpoint): Update.

	* frame.h (struct frame_id): Rename "base" to "stack_addr",
	replace "pc" with "func_addr".
	(frame_id_build): Update parameter names and comment.
	(struct frame_info): Delete "frame" and "pc" fields.
	(frame_func_unwind): Declare.
	(get_frame_func): Declare.
	(struct frame_info): Add field "func".
@
text
@d3421 1
a3421 1
      ui_out_field_core_addr (uiout, "frame", b->frame_id.stack_addr);
@


1.116
log
@	* breakpoint.c (handle_gnu_4_16_catch_command, get_catch_sals)
	(struct sal_chain, map_catch_names): Remove.
	(catch_exception_command_1): Don't call
	handle_gnu_4_16_catch_command.
@
text
@a1686 3
  if (!CALL_DUMMY_P)
    return 0;

@


1.115
log
@2003-03-12  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (get_saved_register): Delete function.
	* xstormy16-tdep.c: Update comment.
	* regcache.h: Update comments.
	* sparc-tdep.c (sparc_init_extra_frame_info): Instead of
	get_saved_register and extract_address, use
	frame_read_unsigned_register.
	(sparc_frame_saved_pc): Ditto.
	(sparc_get_saved_register): Instead of get_saved_register, use
	frame_register.
	(sparc_pop_frame): Ditto.
	* frame.h (get_saved_register): Delete declaration.
	* findvar.c: Update comments.
	(value_of_register): Call frame_register instead of
	get_saved_register.
	(value_from_register): Ditto.
	* config/sparc/tm-sparc.h: Update comment.
	* breakpoint.c: Update comment.

Index: doc/ChangeLog
2003-03-12  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	references to get_saved_register.
@
text
@a82 4
static void handle_gnu_4_16_catch_command (char *, int, int);

static struct symtabs_and_lines get_catch_sals (int);

a5704 181
struct sal_chain
{
  struct sal_chain *next;
  struct symtab_and_line sal;
};

#if 0
/* Not really used -- invocation in handle_gnu_4_16_catch_command
   had been commented out in the v.4.16 sources, and stays
   disabled there now because "catch NAME" syntax isn't allowed.
   pai/1997-07-11 */
/* This isn't used; I don't know what it was for.  */
/* For each catch clause identified in ARGS, run FUNCTION
   with that clause as an argument.  */
static struct symtabs_and_lines
map_catch_names (char *args, int (*function) ())
{
  register char *p = args;
  register char *p1;
  struct symtabs_and_lines sals;
#if 0
  struct sal_chain *sal_chain = 0;
#endif

  if (p == 0)
    error_no_arg ("one or more catch names");

  sals.nelts = 0;
  sals.sals = NULL;

  while (*p)
    {
      p1 = p;
      /* Don't swallow conditional part.  */
      if (p1[0] == 'i' && p1[1] == 'f'
	  && (p1[2] == ' ' || p1[2] == '\t'))
	break;

      if (isalpha (*p1))
	{
	  p1++;
	  while (isalnum (*p1) || *p1 == '_' || *p1 == '$')
	    p1++;
	}

      if (*p1 && *p1 != ' ' && *p1 != '\t')
	error ("Arguments must be catch names.");

      *p1 = 0;
#if 0
      if (function (p))
	{
	  struct sal_chain *next = (struct sal_chain *)
	  alloca (sizeof (struct sal_chain));
	  next->next = sal_chain;
	  next->sal = get_catch_sal (p);
	  sal_chain = next;
	  goto win;
	}
#endif
      printf_unfiltered ("No catch clause for exception %s.\n", p);
#if 0
    win:
#endif
      p = p1;
      while (*p == ' ' || *p == '\t')
	p++;
    }
}
#endif

/* This shares a lot of code with `print_frame_label_vars' from stack.c.  */

static struct symtabs_and_lines
get_catch_sals (int this_level_only)
{
  register struct blockvector *bl;
  register struct block *block;
  int index, have_default = 0;
  CORE_ADDR pc;
  struct symtabs_and_lines sals;
  struct sal_chain *sal_chain = 0;
  char *blocks_searched;

  /* Not sure whether an error message is always the correct response,
     but it's better than a core dump.  */
  if (deprecated_selected_frame == NULL)
    error ("No selected frame.");
  block = get_frame_block (deprecated_selected_frame, 0);
  pc = get_frame_pc (deprecated_selected_frame);

  sals.nelts = 0;
  sals.sals = NULL;

  if (block == 0)
    error ("No symbol table info available.\n");

  bl = blockvector_for_pc (BLOCK_END (block) - 4, &index);
  blocks_searched = (char *) alloca (BLOCKVECTOR_NBLOCKS (bl) * sizeof (char));
  memset (blocks_searched, 0, BLOCKVECTOR_NBLOCKS (bl) * sizeof (char));

  while (block != 0)
    {
      CORE_ADDR end = BLOCK_END (block) - 4;
      int last_index;

      if (bl != blockvector_for_pc (end, &index))
	error ("blockvector blotch");
      if (BLOCKVECTOR_BLOCK (bl, index) != block)
	error ("blockvector botch");
      last_index = BLOCKVECTOR_NBLOCKS (bl);
      index += 1;

      /* Don't print out blocks that have gone by.  */
      while (index < last_index
	     && BLOCK_END (BLOCKVECTOR_BLOCK (bl, index)) < pc)
	index++;

      while (index < last_index
	     && BLOCK_END (BLOCKVECTOR_BLOCK (bl, index)) < end)
	{
	  if (blocks_searched[index] == 0)
	    {
	      struct block *b = BLOCKVECTOR_BLOCK (bl, index);
	      register int i;
	      register struct symbol *sym;

	      ALL_BLOCK_SYMBOLS (b, i, sym)
		{
		  if (STREQ (DEPRECATED_SYMBOL_NAME (sym), "default"))
		    {
		      if (have_default)
			continue;
		      have_default = 1;
		    }
		  if (SYMBOL_CLASS (sym) == LOC_LABEL)
		    {
		      struct sal_chain *next = (struct sal_chain *)
		      alloca (sizeof (struct sal_chain));
		      next->next = sal_chain;
		      next->sal = find_pc_line (SYMBOL_VALUE_ADDRESS (sym), 
						0);
		      sal_chain = next;
		    }
		}
	      blocks_searched[index] = 1;
	    }
	  index++;
	}
      if (have_default)
	break;
      if (sal_chain && this_level_only)
	break;

      /* After handling the function's top-level block, stop.
         Don't continue to its superblock, the block of
         per-file symbols.  */
      if (BLOCK_FUNCTION (block))
	break;
      block = BLOCK_SUPERBLOCK (block);
    }

  if (sal_chain)
    {
      struct sal_chain *tmp_chain;

      /* Count the number of entries.  */
      for (index = 0, tmp_chain = sal_chain; tmp_chain;
	   tmp_chain = tmp_chain->next)
	index++;

      sals.nelts = index;
      sals.sals = (struct symtab_and_line *)
	xmalloc (index * sizeof (struct symtab_and_line));
      for (index = 0; sal_chain; sal_chain = sal_chain->next, index++)
	sals.sals[index] = sal_chain->sal;
    }

  return sals;
}

a6041 11
  else
    {
      /* No callbacks from runtime system for exceptions.
         Try GNU C++ exception breakpoints using labels in debug info. */
      if (ex_event == EX_EVENT_CATCH)
	{
	  handle_gnu_4_16_catch_command (arg, tempflag, from_tty);
	}
      else if (ex_event == EX_EVENT_THROW)
	{
	  /* Set a breakpoint on __raise_exception () */
d6043 1
a6043 5
	  warning ("Unsupported with this platform/compiler combination.");
	  warning ("Perhaps you can achieve the effect you want by setting");
	  warning ("a breakpoint on __raise_exception().");
	}
    }
a6060 105
}



/* This is the original v.4.16 and earlier version of the
   catch_command_1() function.  Now that other flavours of "catch"
   have been introduced, and since exception handling can be handled
   in other ways (through target ops) also, this is used only for the
   GNU C++ exception handling system.
   Note: Only the "catch" flavour of GDB 4.16 is handled here.  The
   "catch NAME" is now no longer allowed in catch_command_1().  Also,
   there was no code in GDB 4.16 for "catch throw". 

   Called from catch_exception_command_1 () */


static void
handle_gnu_4_16_catch_command (char *arg, int tempflag, int from_tty)
{
  /* First, translate ARG into something we can deal with in terms
     of breakpoints.  */

  struct symtabs_and_lines sals;
  struct symtab_and_line sal;
  register struct expression *cond = 0;
  register struct breakpoint *b;
  char *save_arg;
  int i;

  init_sal (&sal);		/* initialize to zeroes */

  /* If no arg given, or if first arg is 'if ', all active catch clauses
     are breakpointed. */

  if (!arg || (arg[0] == 'i' && arg[1] == 'f'
	       && (arg[2] == ' ' || arg[2] == '\t')))
    {
      /* Grab all active catch clauses.  */
      sals = get_catch_sals (0);
    }
  else
    {
      /* Grab selected catch clauses.  */
      error ("catch NAME not implemented");

#if 0
      /* Not sure why this code has been disabled. I'm leaving
         it disabled.  We can never come here now anyway
         since we don't allow the "catch NAME" syntax.
         pai/1997-07-11 */

      /* This isn't used; I don't know what it was for.  */
      sals = map_catch_names (arg, catch_breakpoint);
#endif
    }

  if (!sals.nelts)
    return;

  save_arg = arg;
  for (i = 0; i < sals.nelts; i++)
    {
      resolve_sal_pc (&sals.sals[i]);

      while (arg && *arg)
	{
	  if (arg[0] == 'i' && arg[1] == 'f'
	      && (arg[2] == ' ' || arg[2] == '\t'))
	    cond = parse_exp_1 ((arg += 2, &arg),
				block_for_pc (sals.sals[i].pc), 0);
	  else
	    error ("Junk at end of arguments.");
	}
      arg = save_arg;
    }

  for (i = 0; i < sals.nelts; i++)
    {
      sal = sals.sals[i];

      if (from_tty)
	describe_other_breakpoints (sal.pc, sal.section);

      /* Important -- this is an ordinary breakpoint.  For platforms
	 with callback support for exceptions,
	 create_exception_catchpoint() will create special bp types
	 (bp_catch_catch and bp_catch_throw), and there is code in
	 insert_breakpoints() and elsewhere that depends on that. */
      b = set_raw_breakpoint (sal, bp_breakpoint);
      set_breakpoint_count (breakpoint_count + 1);
      b->number = breakpoint_count;

      b->cond = cond;
      b->enable_state = bp_enabled;
      b->disposition = tempflag ? disp_del : disp_donttouch;

      mention (b);
    }

  if (sals.nelts > 1)
    {
      warning ("Multiple breakpoints were set.");
      warning ("Use the \"delete\" command to delete unwanted breakpoints.");
    }
  xfree (sals.sals);
@


1.114
log
@       * breakpoint.c (bpstat_stop_status): Fix a small memory leak.
@
text
@d1682 1
a1682 1
   take too much time, at least using get_saved_register on the 68k.
@


1.113
log
@	* breakpoint.c (bpstat_copy): Copy the command lines as well
	as the old value, to match what is freed in bpstat_clear.
@
text
@a2765 1
	    bs->commands = copy_command_lines (b->commands);
d2768 1
d2776 1
@


1.112
log
@2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.h (SYMBOL_NATURAL_NAME): New macro.
	(SYMBOL_LINKAGE_NAME): Ditto.
	(SYMBOL_PRINT_NAME): Use SYMBOL_NATURAL_NAME and
	SYMBOL_LINKAGE_NAME.
	(struct general_symbol_info): Expand comment.
	(DEPRECATED_SYMBOL_NAME): Rename from SYMBOL_NAME.
	(SYMBOL_MATCHES_NAME): Use DEPRECATED_SYMBOL_NAME.
	(SYMBOL_MATCHES_REGEXP): Ditto.
	* symtab.c (symbol_natural_name): New function.
	* objfiles.h: Replace all uses of SYMBOL_NAME by
	DEPRECATED_SYMBOL_NAME.
	* xcoffread.c, valops.c, typeprint.c, tracepoint.c: Ditto.
	* symtab.c, symmisc.c, symfile.c, stack.c, stabsread.c: Ditto.
	* somsolib.c, sol-thread.c, rs6000-tdep.c, p-valprint.c: Ditto.
	* printcmd.c, objfiles.c, objc-lang.c, mipsread.c: Ditto.
	* minsyms.c, mdebugread.c, linespec.c, jv-lang.c: Ditto.
	* i386-tdep.c, i386-linux-tdep.c, hpread.c, hppa-tdep.c: Ditto.
	* gnu-v2-abi.c, f-valprint.c, findvar.c, expprint.c: Ditto.
	* dwarfread.c, dwarf2read.c, dbxread.c, c-valprint.c: Ditto.
	* cp-valprint.c, coffread.c, buildsym.c, breakpoint.c: Ditto.
	* blockframe.c, ax-gdb.c, arm-linux-tdep.c, ada-lang.c: Ditto.
	* ada-exp.y: Ditto.
	* ada-exp.y: Update copyright.
	* sol-thread.c, mipsread.c, jv-lang.c, f-valprint.c: Ditto.
	* cp-valprint.c: Ditto.

2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* generic/gdbtk.h: Replace all instances of SYMBOL_NAME by
	DEPRECATED_SYMBOL_NAME.
	* generic/gdbtk-stack.c, generic/gdbtk-cmds.c: Ditto.
	* generic/gdbtk-stack.c, generic/gdbtk-cmds.c: Update copyright.

2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c: Replace all instances of SYMBOL_NAME with
	DEPRECATED_SYMBOL_NAME.  Update copyright.
@
text
@d1819 5
@


1.112.4.1
log
@2003-03-16  Mark Kettenis  <kettenis@@gnu.org>

	Merge with mainline.  Tag is kettenis-i386newframe-20030316-mergepoint.
@
text
@d1682 1
a1682 1
   take too much time, at least using frame_register() on the 68k.
a1818 5
      if (bs->commands != NULL)
	tmp->commands = copy_command_lines (bs->commands);
      if (bs->old_val != NULL)
	tmp->old_val = value_copy (bs->old_val);

d2761 1
a2763 1
	    bs->commands = b->commands;
a2770 1
	    bs->commands = copy_command_lines (bs->commands);
@


1.111
log
@2003-02-20  David Carlton  <carlton@@math.stanford.edu>

	* symtab.h (SYMBOL_PRINT_NAME): Rename from SYMBOL_SOURCE_NAME;
	expand comment.
	* ada-lang.c (user_select_syms, ada_finish_decode_line_1): Replace
	SYMBOL_PRINT_NAME with SYMBOL_SOURCE_NAME.
	* ada-typeprint.c (ada_typedef_print): Ditto.
	* ax-gdb.c (gen_var_ref): Ditto.
	* breakpoint.c (print_one_breakpoint): Ditto.
	* buildsym.c (finish_block): Ditto.
	* c-valprint.c (c_val_print): Ditto.
	* expprint.c (print_subexp): Ditto.
	* findvar.c (locate_var_value): Ditto.
	* infcmd.c (jump_command): Ditto.
	* linespec.c (decode_line_2, decode_compound): Ditto.
	* maint.c (maintenance_translate_address): Ditto.
	* objc-lang.c (compare_selectors, compare_classes): Ditto.
	* printcmd.c (build_address_symbolic, sym_info, print_frame_args):
	Ditto.
	* p-valprint.c (pascal_val_print): Ditto.
	* stabsread.c (define_symbol): Ditto.
	* stack.c (print_frame, frame_info, print_block_frame_locals)
	(print_frame_arg_vars, return_command): Ditto.
	* symfile.c (compare_symbols, compare_psymbols): Ditto.
	* symmisc.c (print_symbol): Ditto.
	* symtab.c (lookup_partial_symbol, lookup_block_symbol)
	(compare_search_syms, print_symbol_info, print_msymbol_info)
	(rbreak_command): Ditto.
	* tracepoint.c (tracepoints_info): Ditto.
	* typeprint.c (typedef_print): Ditto.
	* valops.c (value_of_variable, hand_function_call): Ditto.
	* cli/cli-cmds.c (edit_command, list_command): Ditto.
	* ada-typeprint.c: Update Copyright.
	* infcmd.c, objc-lang.c, p-valprint.c, symmisc.c: Ditto.
	* tracepoint.c, cli/cli-cmds.c: Ditto.
@
text
@d5832 1
a5832 1
		  if (STREQ (SYMBOL_NAME (sym), "default"))
@


1.110
log
@2003-02-19  David Carlton  <carlton@@math.stanford.edu>

	* Makefile.in (SFILES): Add block.c.
	(block_h): New.
	(COMMON_OBS): Add block.o.
	(block.o): New.
	(x86-64-tdep.o): Add $(block_h).
	(values.o, valops.o, tracepoint.o, symtab.o, symmisc.o, symfile.o)
	(stack.o, printcmd.o, p-exp.tab.o, parse.o, objfiles.o)
	(objc-exp.tab.o, objc-lang.o, nlmread.o, mips-tdep.o, mdebugread.o)
	(m2-exp.tab.o, linespec.o, jv-lang.o, jv-exp.tab.o, infcmd.o)
	(f-valprint.o, findvar.o, f-exp.tab.o, expprint.o, coffread.o)
	(c-exp.tab.o, buildsym.o, breakpoint.o, blockframe.o, ax-gdb.o)
	(alpha-tdep.o, ada-lang.o, ada-exp.tab.o, mi-cmd-stack.o): Ditto.
	* value.h: Add opaque declaration for struct block.
	* parser-defs.h, objc-lang.h, buildsym.h, breakpoint.h: Ditto.
	* ada-lang.h: Ditto.
	* x86-64-tdep.c: #include "block.h"
	* values.c, valops.c, tracepoint.c, symtab.c, symmisc.c: Ditto.
	* symfile.c, stack.c, printcmd.c, p-exp.y, parse.c: Ditto.
	* objfiles.c, objc-exp.y, objc-lang.c, nlmread.c: Ditto.
	* mips-tdep.c, mdebugread.c, m2-exp.y, linespec.c: Ditto.
	* jv-lang.c, jv-exp.y, infcmd.c, f-valprint.c: Ditto.
	* findvar.c, f-exp.y, expprint.c, coffread.c, c-exp.y: Ditto.
	* buildsym.c, breakpoint.c, blockframe.c, ax-gdb.c: Ditto.
	* alpha-tdep.c, ada-lang.c, ada-exp.y: Ditto.
	* blockframe.c (blockvector_for_pc_sect): Move to "block.c".
	(blockvector_for_pc, block_for_pc_sect, block_for_pc): Ditto.
	* symtab.c (block_function): Ditto.
	(contained_in): Ditto.
	* frame.h: Move block_for_pc and block_for_pc_sect declarations to
	block.h.  Add opaque declaration for struct block.
	* symtab.h: Move block_function and contained_in declarations to
	block.h.  Add opaque declarations for struct block, struct
	blockvector.
	(struct block): Move to block.h.
	(struct blockvector): Ditto.
	(BLOCK_START, BLOCK_END, BLOCK_FUNCTION, BLOCK_SUPERBLOCK)
	(BLOCK_GCC_COMPILED, BLOCK_HASHTABLE, BLOCK_NSYMS, BLOCK_SYM)
	(BLOCK_BUCKETS, BLOCK_BUCKET, BLOCK_HASHTABLE_SIZE)
	(ALL_BLOCK_SYMBOLS, BLOCK_SHOULD_SORT, BLOCKVECTOR_NBLOCKS)
	(BLOCKVECTOR_BLOCK, GLOBAL_BLOCK, STATIC_BLOCK, FIRST_LOCAL_BLOCK):
	Ditto.
	* block.c: New file.
	* block.h: New file.

2003-02-19  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c: #include "block.h"
@
text
@d3390 1
a3390 1
				   SYMBOL_SOURCE_NAME (sym));
@


1.109
log
@2003-02-04  Andrew Cagney  <ac131313@@redhat.com>

	* NEWS: Mention that the mn10200-elf is obsolete.
	* configure.tgt: Obsolete mn10200-*-* target.
	* breakpoint.c (update_breakpoints_after_exec): Update comment to
	mention that the mn10200 is obsolete.
	* breakpoint.h: Ditto.
	* MAINTAINERS: Mark the mn10200-elf as obsolete.
	* config/mn10200/mn10200.mt: Obsolete file.
	* config/mn10200/tm-mn10200.h: Obsolete file.
	* mn10200-tdep.c: Obsolete file.

Index: testsuite/ChangeLog
2003-02-04  Andrew Cagney  <ac131313@@redhat.com>

	* gdb.disasm/mn10200.exp: Obsolete file.
	* gdb.trace/Makefile.in (clean mostlyclean): Remove mn10200.
	* gdb.disasm/Makefile.in (clean mostlyclean): Remove mn10200.
	* gdb.base/watchpoint.exp: Mark the mn10200 xfails as obsolete.
@
text
@d51 1
@


1.108
log
@2003-02-02  Elena Zannoni  <ezannoni@@redhat.com>

	Fix PR gdb/742 gdb/743
	* disasm.c (dump_insns): Use make_cleanup_ui_out_tuple_begin_end.
	(do_mixed_source_and_assembly): Use
	make_cleanup_ui_out_tuple_begin_end and
	make_cleanup_ui_out_tuple_begin_end.
	(do_mixed_source_and_assembly): Ditto.
	* thread.c (do_captured_list_thread_ids): Ditto.
	* ui-out.h (ui_out_table_begin, ui_out_list_begin,
	ui_out_tuple_begin, ui_out_table_end, ui_out_list_end,
	ui_out_tuple_end): Delete prototypes.
	* ui-out.c (ui_out_list_begin, ui_out_tuple_begin,
	ui_out_list_end, ui_out_tuple_end): Delete.

	From Kevin Buettner  <kevinb@@redhat.com>:
	* ui-out.h (make_cleanup_ui_out_table_begin_end): New function.
        * ui-out.c (make_cleanup_ui_out_table_begin_end)
        (do_cleanup_table_end):  New functions.
        * breakpoint.c (print_it_typical, print_one_breakpoint, mention):
        Use cleanups to invoke_ui_out_tuple_end().
        (breakpoint_1): Use cleanup to invoke ui_out_table_end().
	* cli/cli-setshow.c (cmd_show_list): Use
	make_cleanup_ui_out_tuple_begin_end.
@
text
@d1241 2
a1242 2
       valid code address on some platforms (like the mn10200 and
       mn10300 simulators).  We shouldn't assign any special
@


1.107
log
@2003-01-18  Andrew Cagney  <ac131313@@redhat.com>

	* ada-valprint.c: Eliminate PTR.
	* breakpoint.c, corelow.c, cris-tdep.c, dbxread.c: Ditto.
	* defs.h, dve3900-rom.c, dwarf2read.c, dwarfread.c: Ditto.
	* exec.c, hppa-tdep.c, hpread.c, infcmd.c, mdebugread.c: Ditto.
	* objfiles.c, objfiles.h, ocd.c, remote-es.c: Ditto.
	* remote-mips.c, remote-sds.c, remote-vx.c: Ditto.
	* solib-svr4.c, solib.c, stack.c, symfile.c, symfile.h: Ditto.
	* symmisc.c, v850ice.c, xcoffread.c, cli/cli-script.c: Ditto.
@
text
@d2005 1
a2005 1
  struct cleanup *old_chain;
d2166 1
a2166 1
	  ui_out_tuple_begin (uiout, "value");
d2173 1
a2173 1
	  ui_out_tuple_end (uiout);
d2186 1
a2186 1
      ui_out_tuple_begin (uiout, "value");
d2190 1
a2190 1
      ui_out_tuple_end (uiout);
d2202 1
a2202 1
	  ui_out_tuple_begin (uiout, "value");
d2215 1
a2215 1
	  ui_out_tuple_begin (uiout, "value");
d2220 1
a2220 1
      ui_out_tuple_end (uiout);
d3232 1
d3235 1
a3235 1
  ui_out_tuple_begin (uiout, "bkpt");
d3473 2
d3476 1
a3476 1
      ui_out_tuple_begin (uiout, "script");
d3478 1
a3478 1
      ui_out_tuple_end (uiout);
d3480 1
a3480 1
  ui_out_tuple_end (uiout);
d3548 1
d3561 3
a3563 1
    ui_out_table_begin (uiout, 6, nr_printable_breakpoints, "BreakpointTable");
d3565 3
a3567 1
    ui_out_table_begin (uiout, 5, nr_printable_breakpoints, "BreakpointTable");
d3609 1
a3609 1
  ui_out_table_end (uiout);
d4401 1
a4401 1
  struct cleanup *old_chain;
d4423 1
a4423 1
      ui_out_tuple_begin (uiout, "wpt");
d4428 1
a4428 1
      ui_out_tuple_end (uiout);
d4432 1
a4432 1
      ui_out_tuple_begin (uiout, "wpt");
d4437 1
a4437 1
      ui_out_tuple_end (uiout);
d4441 1
a4441 1
      ui_out_tuple_begin (uiout, "hw-rwpt");
d4446 1
a4446 1
      ui_out_tuple_end (uiout);
d4450 1
a4450 1
      ui_out_tuple_begin (uiout, "hw-awpt");
d4455 1
a4455 1
      ui_out_tuple_end (uiout);
@


1.107.2.1
log
@Merge kseitz_interps-20020528-branch.
@
text
@d2005 1
a2005 1
  struct cleanup *old_chain, *ui_out_chain;
d2166 1
a2166 1
	  ui_out_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "value");
d2173 1
a2173 1
	  do_cleanups (ui_out_chain);
d2186 1
a2186 1
      ui_out_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "value");
d2190 1
a2190 1
      do_cleanups (ui_out_chain);
d2202 1
a2202 1
	  ui_out_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "value");
d2215 1
a2215 1
	  ui_out_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "value");
d2220 1
a2220 1
      do_cleanups (ui_out_chain);
a3231 1
  struct cleanup *bkpt_chain;
d3234 1
a3234 1
  bkpt_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "bkpt");
a3471 2
      struct cleanup *script_chain;

d3473 1
a3473 1
      script_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "script");
d3475 1
a3475 1
      do_cleanups (script_chain);
d3477 1
a3477 1
  do_cleanups (bkpt_chain);
a3544 1
  struct cleanup *bkpttbl_chain;
d3557 1
a3557 3
    bkpttbl_chain 
      = make_cleanup_ui_out_table_begin_end (uiout, 6, nr_printable_breakpoints,
                                             "BreakpointTable");
d3559 1
a3559 3
    bkpttbl_chain 
      = make_cleanup_ui_out_table_begin_end (uiout, 5, nr_printable_breakpoints,
                                             "BreakpointTable");
d3601 1
a3601 1
  do_cleanups (bkpttbl_chain);
a3893 1
  breakpoint_create_event (b->number);
a4176 1
  breakpoint_create_event (b->number);
a4221 1
  breakpoint_create_event (b->number);
a4259 1
  breakpoint_create_event (b->number);
a4382 1
  breakpoint_create_event (b->number);
d4393 1
a4393 1
  struct cleanup *old_chain, *ui_out_chain;
d4399 9
d4415 1
a4415 1
      ui_out_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "wpt");
d4420 1
a4420 1
      do_cleanups (ui_out_chain);
d4424 1
a4424 1
      ui_out_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "wpt");
d4429 1
a4429 1
      do_cleanups (ui_out_chain);
d4433 1
a4433 1
      ui_out_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "hw-rwpt");
d4438 1
a4438 1
      do_cleanups (ui_out_chain);
d4442 1
a4442 1
      ui_out_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "hw-awpt");
d4447 1
a4447 1
      do_cleanups (ui_out_chain);
a4577 1
	breakpoint_create_event (b->number);
a5431 2

	  breakpoint_create_event (scope_breakpoint->number);
a5434 1
  breakpoint_create_event (b->number);
a6177 1
  breakpoint_create_event (b->number);
a6342 1
      breakpoint_create_event (b->number);
a6484 1
  breakpoint_create_event (b->number);
@


1.107.2.2
log
@Kill off anything not directly related to the CLI command.
@
text
@d3902 1
d4186 1
d4232 1
d4271 1
d4395 1
a4411 9
  /* FIXME: This is misplaced; mention() is called by things (like hitting a
     watchpoint) other than breakpoint creation.  It should be possible to
     clean this up and at the same time replace the random calls to
     breakpoint_changed with this hook, as has already been done for
     delete_breakpoint_hook and so on.  */
  if (create_breakpoint_hook)
    create_breakpoint_hook (b);
  breakpoint_create_event (b->number);

d4582 1
d5437 2
d5442 1
d6186 1
d6352 1
d6495 1
@


1.106
log
@2003-01-14  Elena Zannoni  <ezannoni@@redhat.com>

	* breakpoint.c (until_break_command): Add new argument.  Use it to
	decide whether to stop only at the current frame or not.
	* breakpoint.h (until_break_command): Update prototype.
 	* infcmd.c (until_command): Add new argument to until_break_command
	call.
	(advance_command): New function.
	(_initialize_infcmd): Update help string for 'until' command.
	Add new 'advance' command.
@
text
@d76 1
a76 1
static int breakpoint_re_set_one (PTR);
d111 1
a111 1
static int breakpoint_cond_eval (PTR);
d113 1
a113 1
static void cleanup_executing_breakpoints (PTR);
d143 1
a143 1
static int watchpoint_check (PTR);
d145 1
a145 1
static int cover_target_enable_exception_callback (PTR);
d1919 1
a1919 1
cleanup_executing_breakpoints (PTR ignore)
d2334 1
a2334 1
breakpoint_cond_eval (PTR exp)
d2374 1
a2374 1
watchpoint_check (PTR p)
d6235 1
a6235 1
cover_target_enable_exception_callback (PTR arg)
d6912 1
a6912 1
breakpoint_re_set_one (PTR bint)
@


1.105
log
@	* breakpoint.c (insert_breakpoints): Skip disabled breakpoints
	entirely.
	(breakpoint_re_set_one): Don't fetch the value for a disabled
	watchpoint.
@
text
@d5579 1
a5579 1
until_break_command (char *arg, int from_tty)
d5612 10
a5621 3
  breakpoint = 
    set_momentary_breakpoint (sal,get_frame_id (deprecated_selected_frame),
			      bp_until);
d5649 2
a5650 2
  /* Keep within the current frame */

d5669 1
a5669 1

@


1.104
log
@2002-12-17  Andrew Cagney  <ac131313@@redhat.com>

	* stack.c (frame_info): Use get_frame_saved_regs.
	* breakpoint.c (until_break_command): Use get_frame_pc.
@
text
@d4 1
a4 1
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002 Free Software
d738 3
a740 2
    if (b->enable_state == bp_permanent)
      /* Permanent breakpoints cannot be inserted or removed.  */
d742 1
a763 3
	&& b->enable_state != bp_disabled
	&& b->enable_state != bp_shlib_disabled
	&& b->enable_state != bp_call_disabled
a881 3
	     && b->enable_state != bp_disabled
	     && b->enable_state != bp_shlib_disabled
	     && b->enable_state != bp_call_disabled
a938 1
	     && b->enable_state == bp_enabled
a1056 1
	     && b->enable_state == bp_enabled
d7046 1
a7046 1
      if (VALUE_LAZY (b->val))
@


1.103
log
@2002-12-06  Andrew Cagney  <ac131313@@redhat.com>

	* breakpoint.h (struct breakpoint): Replace frame with frame_id.
	(set_momentary_breaokpoint): Replace `struct frame_info' parameter
	with `struct frame_id'.
	(set_longjmp_resume_breakpoint): Ditto.
	* infrun.c (handle_inferior_event): Update.
	* breakpoint.c (watch_command_1, until_break_command): Update.
	* infrun.c (handle_inferior_event, check_sigtramp2): Update.
	(handle_inferior_event, step_over_function): Update.
	* breakpoint.c (bpstat_stop_status, print_one_breakpoint): Update.
	(set_raw_breakpoint, set_longjmp_resume_breakpoint): Update.
	(set_momentary_breakpoint, deprecated_frame_in_dummy): Update.
	* infcmd.c (finish_command, run_stack_dummy): Update.
@
text
@d5652 2
a5653 2
      sal = find_pc_line (prev_frame->pc, 0);
      sal.pc = prev_frame->pc;
@


1.102
log
@2002-12-07  Andrew Cagney  <ac131313@@redhat.com>

	* f-valprint.c (info_common_command): Use get_frame_pc.
	* std-regs.c (value_of_builtin_frame_pc_reg): Ditto.
	* ax-gdb.c (agent_command): Ditto.
	* rs6000-tdep.c (rs6000_init_extra_frame_info): Ditto.
	(rs6000_pop_frame): Ditto.
	(rs6000_frameless_function_invocation): Ditto.
	(rs6000_frame_saved_pc, frame_get_saved_regs): Ditto.
	(frame_initial_stack_address, rs6000_frame_chain): Ditto.
	* macroscope.c (default_macro_scope): Ditto.
	* stack.c (print_frame_info_base): Ditto.
	(print_frame, frame_info, print_frame_label_vars): Ditto.
	(return_command, func_command, get_frame_language): Ditto.
	* infcmd.c (finish_command): Ditto.
	* dummy-frame.c (cached_find_dummy_frame): Ditto.
	* breakpoint.c (deprecated_frame_in_dummy): Ditto.
	(break_at_finish_at_depth_command_1): Ditto.
	(break_at_finish_command_1): Ditto.
	(until_break_command, get_catch_sals): Ditto.
	* blockframe.c (func_frame_chain_valid): Ditto.
	(frameless_look_for_prologue): Ditto.
	(frame_address_in_block, generic_func_frame_chain_valid): Ditto.
@
text
@d1707 1
a1707 1
	&& b->frame == get_frame_base (frame)
d2730 2
a2731 2
    if (b->frame &&
	b->frame != get_frame_base (get_current_frame ()))
d3420 1
a3420 1
  if (b->frame)
d3424 3
a3426 1
      ui_out_field_core_addr (uiout, "frame", b->frame);
d3847 1
a3847 1
  b->frame = 0;
d4313 1
a4313 1
set_longjmp_resume_breakpoint (CORE_ADDR pc, struct frame_info *frame)
d4322 1
a4322 4
      if (frame != NULL)
	b->frame = get_frame_base (frame);
      else
	b->frame = 0;
d4374 1
a4374 1
set_momentary_breakpoint (struct symtab_and_line sal, struct frame_info *frame,
d4381 1
a4381 1
  b->frame = (frame ? get_frame_base (frame) : 0);
d5430 1
a5430 1
	  scope_breakpoint->frame = get_frame_base (prev_frame);
d5618 3
a5620 1
  breakpoint = set_momentary_breakpoint (sal, deprecated_selected_frame, bp_until);
d5652 4
a5655 3
      sal = find_pc_line (get_frame_pc (prev_frame), 0);
      sal.pc = get_frame_pc (prev_frame);
      breakpoint = set_momentary_breakpoint (sal, prev_frame, bp_until);
@


1.101
log
@2002-12-08  Andrew Cagney  <ac131313@@redhat.com>

	* blockframe.c: Use get_frame_base instead of directly accessing
	the `struct frame_info' member frame.
	* f-valprint.c, std-regs.c, rs6000-tdep.c: Ditto.
	* stack.c, dummy-frame.c, breakpoint.c: Ditto.
@
text
@d1710 1
a1710 1
	&& (frame->pc
d1712 2
a1713 2
	      - SIZEOF_CALL_DUMMY_WORDS / sizeof (LONGEST) * REGISTER_SIZE))
	&& frame->pc <= b->address)
d4971 1
a4971 1
	      selected_pc = deprecated_selected_frame->pc;
d5000 1
a5000 1
	selected_pc = frame->pc;
d5050 2
a5051 1
	      sprintf (addr_string, "*0x%s", paddr_nz (deprecated_selected_frame->pc));
d5651 2
a5652 2
      sal = find_pc_line (prev_frame->pc, 0);
      sal.pc = prev_frame->pc;
d5780 1
a5780 1
  pc = deprecated_selected_frame->pc;
@


1.100
log
@	* breakpoint.c (create_thread_event_breakpoint): Use xasprintf.
	(create_breakpoints): Make sure the addr_string field is not
	NULL.
@
text
@d1707 1
a1707 1
	&& b->frame == frame->frame
d2731 1
a2731 1
       b->frame != (get_current_frame ())->frame)
d4321 1
a4321 1
	b->frame = frame->frame;
d4382 1
a4382 1
  b->frame = (frame ? frame->frame : 0);
d5430 1
a5430 1
	  scope_breakpoint->frame = prev_frame->frame;
@


1.99
log
@2002-12-03  Andrew Cagney  <ac131313@@redhat.com>

	* frame.h (get_frame_id): Convert to a function.
	(null_frame_id, frame_id_p): Declare.
	(frame_id_eq, frame_id_inner): Declare.
	(frame_id_build): New function.
	* frame.c (get_frame_id): Update.  Use null_frame_id.
	(frame_find_by_id): Rewrite using frame_id_p, frame_id_eq and
	frame_id_inner.
	(null_frame_id, frame_id_p): Define.
	(frame_id_eq, frame_id_inner): Define.
	(frame_id_build): New function.
	* varobj.c (varobj_create): Update.
	(varobj_update): Update.
	* valops.c (value_assign): Update.
	(new_root_variable): Update.
	* infrun.c (save_inferior_status): Update.
	* breakpoint.c (watch_command_1): Update.
@
text
@a4012 1
  char addr_string[80];		/* Surely an addr can't be longer than that. */
d4018 1
a4018 2
  sprintf (addr_string, "*0x%s", paddr (b->address));
  b->addr_string = xstrdup (addr_string);
d4574 6
a4579 1
	b->addr_string = addr_string[i];
@


1.98
log
@2002-12-01  Andrew Cagney  <ac131313@@redhat.com>

	* gdbarch.sh (DEPRECATED_PC_IN_CALL_DUMMY): Rename
	PC_IN_CALL_DUMMY.  Change to predicate.  Always allow call.
	* gdbarch.h, gdbarch.c: Re-generate.
	* config/sparc/tm-sparc.h, config/sparc/tm-sp64.h: Update.
	* config/mn10200/tm-mn10200.h, config/h8500/tm-h8500.h: Update.
	* config/pa/tm-hppa.h, frame.h: Update.
	* x86-64-tdep.c, vax-tdep.c, sparc-tdep.c: Update.
	* s390-tdep.c, ns32k-tdep.c, mn10300-tdep.c: Update.
	* m68k-tdep.c, i386-tdep.c, frv-tdep.c: Update.
	* cris-tdep.c, alpha-tdep.c: Update.
	* frame.c (set_unwind_by_pc, create_new_frame): Use either
	DEPRECATED_PC_IN_CALL_DUMMY or pc_in_dummy_frame.
	(get_prev_frame): Ditto.

Index: doc/ChangeLog
2002-12-01  Andrew Cagney  <ac131313@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	PC_IN_CALL_DUMMY.
@
text
@d5403 1
a5403 1
      get_frame_id (frame, &b->watchpoint_frame);
@


1.97
log
@2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* stack.c (selected_frame, select_frame): Move from here ...
	* frame.c (selected_frame, select_frame): ... to here.  Include
	"language.h".
	* Makefile.in (frame.o): Update dependencies.
	* frame.c (get_selected_frame): New function.
	* frame.h (get_selected_frame): Declare.
	(deprecated_selected_frame): Rename selected_frame.
	* ada-lang.c, ada-tasks.c, breakpoint.c, corelow.c: Update.
	* eval.c, f-valprint.c, findvar.c, frame.c, frame.h: Update.
	* h8300-tdep.c, h8500-tdep.c, hppa-tdep.c, infcmd.c: Update.
	* inflow.c, infrun.c, macroscope.c, mips-tdep.c: Update.
	* mn10300-tdep.c, ocd.c, regcache.h, remote-e7000.c: Update.
	* remote-mips.c, remote-rdp.c, sh-tdep.c, sparc-tdep.c: Update.
	* stack.c, thread.c, tracepoint.c, valops.c, varobj.c: Update.
	* z8k-tdep.c, cli/cli-cmds.c: Update.

Index: mi/ChangeLog
2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* mi/mi-cmd-stack.c, mi/mi-main.c: Update to use
	deprecated_selected_frame.

Index: tui/ChangeLog
2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* tui/tui-hooks.c: Update to use deprecated_selected_frame.
	* tui/tui.c, tui/tuiDisassem.c, tui/tuiRegs.c: Ditto.
	* tui/tuiSource.c, tui/tuiSourceWin.c, tui/tuiWin.c: Ditto.
@
text
@d1686 3
a1688 3
   PC_IN_CALL_DUMMY because figuring out the saved SP would take too
   much time, at least using get_saved_register on the 68k.  This
   means that for this function to work right a port must use the
@


1.96
log
@2002-11-28  Andrew Cagney  <ac131313@@redhat.com>

	* gdbarch.sh (DEPRECATED_USE_GENERIC_DUMMY_FRAMES): Rename
	USE_GENERIC_DUMMY_FRAMES.
	* gdbarch.h, gdbarch.c: Regenerate.
	* valops.c, frame.c: Update.
	* config/z8k/tm-z8k.h, config/mn10200/tm-mn10200.h: Update.
	* config/m32r/tm-m32r.h, config/h8500/tm-h8500.h: Update.
	* config/pa/tm-hppa.h, blockframe.c: Update.
	* vax-tdep.c, sparc-tdep.c, ns32k-tdep.c: Ditto.
	* m68k-tdep.c, alpha-tdep.c: Ditto.

	* arm-tdep.c: Eliminate USE_GENERIC_DUMMY_FRAMES as always 1.
	* mips-tdep.c: Ditto.

Index: doc/ChangeLog
2002-11-28  Andrew Cagney  <ac131313@@redhat.com>

	* gdbint.texinfo (Host Definition): Delete documentation on
	USE_GENERIC_DUMMY_FRAMES.
@
text
@d955 2
a956 2
	saved_frame = selected_frame;
	saved_level = frame_relative_level (selected_frame);
d1052 2
a1053 2
	if ((saved_frame != selected_frame) ||
	    (saved_level != frame_relative_level (selected_frame)))
d4966 1
a4966 1
	  if (selected_frame)
d4968 1
a4968 1
	      selected_pc = selected_frame->pc;
d5044 1
a5044 1
	  if (selected_frame)
d5047 1
a5047 1
	      sprintf (addr_string, "*0x%s", paddr_nz (selected_frame->pc));
d5586 1
a5586 1
  struct frame_info *prev_frame = get_prev_frame (selected_frame);
d5615 1
a5615 1
  breakpoint = set_momentary_breakpoint (sal, selected_frame, bp_until);
d5773 1
a5773 1
  if (selected_frame == NULL)
d5775 2
a5776 2
  block = get_frame_block (selected_frame, 0);
  pc = selected_frame->pc;
d7371 2
a7372 2
	  save_selected_frame = selected_frame;
	  save_selected_frame_level = frame_relative_level (selected_frame);
@


1.95
log
@2002-11-23  Andrew Cagney  <ac131313@@redhat.com>

	* breakpoint.c: Include "gdb_assert.h".
	(deprecated_frame_in_dummy): Assert that generic dummy frames are
	not being used.
	* Makefile.in (breakpoint.o): Update dependencies.
	* ada-lang.c (find_printable_frame): Use get_frame_type instead of
	deprecated_frame_in_dummy.
	* stack.c (print_frame_info_base): Ditto.
	(frame_info): Ditto.
	(print_frame_info_base): Ditto.  Delete dead code.

Index: tui/ChangeLog
2002-11-23  Andrew Cagney  <ac131313@@redhat.com>

	* tuiStack.c (tuiShowFrameInfo): Use get_frame_type instead of
	deprecated_frame_in_dummy.  Fix coding style.
@
text
@d1700 3
a1702 3
     checking that !USE_GENERIC_DUMMY_FRAMES; and sparc-tdep.c, which
     doesn't yet use generic dummy frames anyway.  */
  gdb_assert (!USE_GENERIC_DUMMY_FRAMES);
@


1.94
log
@	* breakpoint.c (bpstat_stop_status): Call inferior_has_forked,
	inferior_has_vforked, and inferior_has_execd instead of
	target_has_forked, target_has_vforked, and target_has_execd.
	* config/pa/nm-hppah.h (CHILD_HAS_FORKED, CHILD_HAS_VFORKED)
	(CHILD_HAS_EXECD, CHILD_HAS_SYSCALL_EVENT): Don't define.
	(CHILD_WAIT): Define.
	(child_wait): Add prototype.
	* hppah-nat.c (hpux_has_forked): Rename from child_has_forked.
	Add prototype.
	(hpux_has_vforked): Likewise, from child_has_vforked.
	(hpux_has_execd): Likewise, from child_has_execd.
	(hpux_has_syscall_event): Likewise, from child_has_syscall_event.
	(not_same_real_pid, child_wait): New, copied from inftarg.c.
	Call hpux_has_forked, hpux_has_vforked, hpux_has_execd,
	and hpux_has_syscall_event instead of the target hooks.
	* infrun.c (inferior_has_forked, inferior_has_vforked)
	(inferior_has_execd): New functions.
	* inftarg.c (not_same_real_pid): Remove.
	(child_wait): Remove references to not_same_real_pid,
	target_has_forked, target_has_vforked, target_has_execd,
	and target_has_syscall_event.
	(child_has_forked, child_has_vforked, child_has_execd)
	(child_has_syscall_event): Remove.
	(init_child_ops): Remove references to child_has_forked,
	child_has_vforked, child_has_execd, and child_has_syscall_event.
	* infttrace.c (hpux_has_forked): Rename from child_has_forked.
	(hpux_has_vforked): Likewise, from child_has_vforked.
	(hpux_has_execd): Likewise, from child_has_execd.
	(hpux_has_syscall_event): Likewise, from child_has_syscall_event.
	* target.c (cleanup_target): Remove references to
	to_has_forked, to_has_vforked, to_has_execd, and
	to_has_syscall_event.
	(update_current_target): Likewise.
	(setup_target_debug): Likewise.
	(debug_to_has_forked): Remove.
	(debug_to_has_vforked): Remove.
	(debug_to_has_execd): Remove.
	(debug_to_has_syscall_event): Remove.
	* target.h (struct target_ops): Remove to_has_forked.
	to_has_vforked, to_has_execd, and to_has_syscall_event.
	(child_has_forked, child_has_vforked, child_has_execd)
	(child_has_syscall_event): Remove prototypes.
	(inferior_has_forked, inferior_has_vforked, inferior_has_execd): Add
	prototypes.
	(target_has_forked, target_has_vforked, target_has_execd)
	(target_has_syscall_event): Remove macros.
@
text
@d50 1
d1699 4
a1702 2
  if (USE_GENERIC_DUMMY_FRAMES)
    return generic_pc_in_call_dummy (frame->pc, frame->frame, frame->frame);
@


1.93
log
@2002-11-10  Andrew Cagney  <ac131313@@redhat.com>

	* breakpoint.h (deprecated_frame_in_dummy): Rename frame_in_dummy.
	* stack.c (print_frame_info_base): Update.
	(print_frame_info_base, frame_info): Update.
	* sparc-tdep.c (sparc_init_extra_frame_info): Update.
	(sparc_frame_saved_pc): Update.
	* ada-lang.c (find_printable_frame): Update.
	* breakpoint.c (deprecated_frame_in_dummy): Update.
@
text
@d2573 2
a2574 2
	&& !target_has_forked (PIDGET (inferior_ptid),
	                       &b->forked_inferior_pid))
d2578 2
a2579 2
	&& !target_has_vforked (PIDGET (inferior_ptid),
	                        &b->forked_inferior_pid))
d2583 1
a2583 1
	&& !target_has_execd (PIDGET (inferior_ptid), &b->exec_pathname))
@


1.92
log
@2002-10-24  Elena Zannoni  <ezannoni@@redhat.com>

	* symtab.h (INIT_SAL): Delete macro.
	(init_sal): Export.
	* symtab.c (init_sal): New function.

	* ada-lang.c (ada_finish_decode_line_1): Change INIT_SAL macro
	to init_sal function call.
	(find_sal_from_funcs_and_line): Ditto.
	(all_sals_for_line): Ditto.
	* breakpoint.c (create_internal_breakpoint): Ditto.
	(create_fork_vfork_event_catchpoint): Ditto.
	(create_exec_event_catchpoint): Ditto.
	(parse_breakpoint_sals): Ditto.
	(watch_command_1): Ditto.
	(handle_gnu_4_16_catch_command): Ditto.
	(clear_command): Ditto.
	* hppa-tdep.c (child_enable_exception_callback): Ditto.
	* infcmd.c (run_stack_dummy): Ditto.
	* infrun.c (process_event_stop_test): Ditto.
	(check_sigtramp2): Ditto.
	(step_over_function): Ditto.
	* linespec.c (decode_line_2): Ditto.
	(decode_line_1): Ditto.
	* source.c (line_info): Ditto.
	* symtab.c (find_pc_sect_line): Ditto.
@
text
@d1691 1
a1691 1
frame_in_dummy (struct frame_info *frame)
@


1.91
log
@(parse_breakpoint_sals): Ignore ObjC method
names when matching breakpoints in current file.
@
text
@d3887 1
a3887 1
  INIT_SAL (&sal);		/* initialize to zeroes */
d4207 1
a4207 1
  INIT_SAL (&sal);
d4246 1
a4246 1
  INIT_SAL (&sal);
d4603 1
a4603 1
	  INIT_SAL (&sal);		/* initialize to zeroes */
d5299 1
a5299 1
  INIT_SAL (&sal);		/* initialize to zeroes */
d6265 1
a6265 1
  INIT_SAL (&sal);		/* initialize to zeroes */
d6536 1
a6536 1
      INIT_SAL (&sal);		/* initialize to zeroes */
@


1.90
log
@	* source.c (get_current_source_symtab_and_line): Initialize sal.pc and
	sal.end fields.
	(get_current_or_default_source_symtab_and_line): Ditto.
	* breakpoint.c (parse_breakpoint_sals): Use correct accessor function
	so we do not cause a new source symtab to be searched for (reverting an
	unintentional change from the 2002-09-20 patch).
	* scm-lang.c (scm_unpac): Ditto.
@
text
@d4621 3
a4623 1
         leaving default_breakpoint_* alone.  */
d4629 2
a4630 1
	      || (strchr ("+-", (*address)[0]) != NULL)))
@


1.90.2.1
log
@Merge drow-cplus-merge-20021025 to drow-cplus-branch.
@
text
@d3887 1
a3887 1
  init_sal (&sal);		/* initialize to zeroes */
d4207 1
a4207 1
  init_sal (&sal);
d4246 1
a4246 1
  init_sal (&sal);
d4603 1
a4603 1
	  init_sal (&sal);		/* initialize to zeroes */
d4621 1
a4621 3
         leaving default_breakpoint_* alone.  
         ObjC: However, don't match an Objective-C method name which
         may have a '+' or '-' succeeded by a '[' */
d4627 1
a4627 2
 	      || ((strchr ("+-", (*address)[0]) != NULL)
 		  && ((*address)[1] != '['))))
d5296 1
a5296 1
  init_sal (&sal);		/* initialize to zeroes */
d6262 1
a6262 1
  init_sal (&sal);		/* initialize to zeroes */
d6533 1
a6533 1
      init_sal (&sal);		/* initialize to zeroes */
@


1.90.2.2
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d4 1
a4 1
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003 Free Software
a49 2
#include "gdb_assert.h"
#include "block.h"
d75 1
a75 1
static int breakpoint_re_set_one (void *);
d81 4
a101 4
static void breakpoint_adjustment_warning (CORE_ADDR, CORE_ADDR, int, int);

static CORE_ADDR adjust_breakpoint_address (CORE_ADDR bpaddr);

d110 1
a110 1
static int breakpoint_cond_eval (void *);
d112 1
a112 1
static void cleanup_executing_breakpoints (void *);
d129 1
a129 1
static int remove_breakpoint (struct bp_location *, insertion_state_t);
d142 1
a142 1
static int watchpoint_check (void *);
d144 1
a144 1
static int cover_target_enable_exception_callback (void *);
a235 9
/* Similar iterators for the low-level breakpoints.  */

#define ALL_BP_LOCATIONS(B)  for (B = bp_location_chain; B; B = B->next)

#define ALL_BP_LOCATIONS_SAFE(B,TMP)	\
	for (B = bp_location_chain;	\
	     B ? (TMP=B->next, 1): 0;	\
	     B = TMP)

d250 1
a250 1
/* Chains of all breakpoints defined.  */
a253 2
struct bp_location *bp_location_chain;

a321 7
/* Return whether a breakpoint is an active enabled breakpoint.  */
static int
breakpoint_enabled (struct breakpoint *b)
{
  return b->enable_state == bp_enabled;
}

d517 1
a517 1
  struct breakpoint *b;
d519 1
a519 1
  int bnum;
d553 1
a553 1
	  b->cond = parse_exp_1 (&arg, block_for_pc (b->loc->address), 0);
d565 1
d569 1
a569 1
  struct breakpoint *b;
d571 1
a571 1
  int bnum;
d589 11
a599 11
      {
	char *tmpbuf = xstrprintf ("Type commands for when breakpoint %d is hit, one per line.", 
				 bnum);
	struct cleanup *cleanups = make_cleanup (xfree, tmpbuf);
	l = read_command_lines (tmpbuf, from_tty);
	do_cleanups (cleanups);
	free_command_lines (&b->commands);
	b->commands = l;
	breakpoints_changed ();
	breakpoint_modify_event (b->number);
	return;
d616 1
a616 1
  struct bp_location *b;
d624 1
a624 1
  ALL_BP_LOCATIONS (b)
d626 3
a628 3
    if (b->owner->type == bp_none)
      warning ("reading through apparently deleted breakpoint #%d?",
              b->owner->number);
d630 5
a634 1
    if (b->loc_type != bp_loc_software_breakpoint)
d636 1
d708 4
a711 6
/* A wrapper function for inserting catchpoints.  */
static int
insert_catchpoint (struct ui_out *uo, void *args)
{
  struct breakpoint *b = (struct breakpoint *) args;
  int val = -1;
d713 2
a714 33
  switch (b->type)
    {
    case bp_catch_fork:
      val = target_insert_fork_catchpoint (PIDGET (inferior_ptid));
      break;
    case bp_catch_vfork:
      val = target_insert_vfork_catchpoint (PIDGET (inferior_ptid));
      break;
    case bp_catch_exec:
      val = target_insert_exec_catchpoint (PIDGET (inferior_ptid));
      break;
    default:
      internal_error (__FILE__, __LINE__, "unknown breakpoint type");
      break;
    }

  if (val < 0)
    throw_exception (RETURN_ERROR);

  return 0;
}

/* Insert a low-level "breakpoint" of some type.  BPT is the breakpoint.
   Any error messages are printed to TMP_ERROR_STREAM; and DISABLED_BREAKS,
   PROCESS_WARNING, and HW_BREAKPOINT_ERROR are used to report problems.

   NOTE drow/2003-09-09: This routine could be broken down to an object-style
   method for each breakpoint or catchpoint type.  */
static int
insert_bp_location (struct bp_location *bpt,
		    struct ui_file *tmp_error_stream,
		    int *disabled_breaks, int *process_warning,
		    int *hw_breakpoint_error)
d716 2
d719 8
d728 2
a729 4
  /* Permanent breakpoints cannot be inserted or removed.  Disabled
     breakpoints should not be inserted.  */
  if (!breakpoint_enabled (bpt->owner))
    return 0;
d731 3
a733 2
  if (bpt->inserted || bpt->duplicate)
    return 0;
d735 42
a776 9
  if (bpt->loc_type == bp_loc_software_breakpoint
      || bpt->loc_type == bp_loc_hardware_breakpoint)
    {
      /* First check to see if we have to handle an overlay.  */
      if (overlay_debugging == ovly_off
	  || bpt->section == NULL
	  || !(section_is_overlay (bpt->section)))
	{
	  /* No overlay handling: just set the breakpoint.  */
d778 48
a825 49
	  if (bpt->loc_type == bp_loc_hardware_breakpoint)
	    val = target_insert_hw_breakpoint (bpt->address, 
					       bpt->shadow_contents);
	  else
	    val = target_insert_breakpoint (bpt->address,
					    bpt->shadow_contents);
	}
      else
	{
	  /* This breakpoint is in an overlay section.  
	     Shall we set a breakpoint at the LMA?  */
	  if (!overlay_events_enabled)
	    {
	      /* Yes -- overlay event support is not active, 
		 so we must try to set a breakpoint at the LMA.
		 This will not work for a hardware breakpoint.  */
	      if (bpt->loc_type == bp_loc_hardware_breakpoint)
		warning ("hardware breakpoint %d not supported in overlay!\n",
			 bpt->owner->number);
	      else
		{
		  CORE_ADDR addr = overlay_unmapped_address (bpt->address,
							     bpt->section);
		  /* Set a software (trap) breakpoint at the LMA.  */
		  val = target_insert_breakpoint (addr, bpt->shadow_contents);
		  if (val != 0)
		    fprintf_unfiltered (tmp_error_stream, 
					"Overlay breakpoint %d failed: in ROM?", 
					bpt->owner->number);
		}
	    }
	  /* Shall we set a breakpoint at the VMA? */
	  if (section_is_mapped (bpt->section))
	    {
	      /* Yes.  This overlay section is mapped into memory.  */
	      if (bpt->loc_type == bp_loc_hardware_breakpoint)
		val = target_insert_hw_breakpoint (bpt->address, 
						   bpt->shadow_contents);
	      else
		val = target_insert_breakpoint (bpt->address,
						bpt->shadow_contents);
	    }
	  else
	    {
	      /* No.  This breakpoint will not be inserted.  
		 No error, but do not mark the bp as 'inserted'.  */
	      return 0;
	    }
	}
d827 3
a829 3
      if (val)
	{
	  /* Can't set the breakpoint.  */
d831 18
a848 18
	  if (DISABLE_UNSETTABLE_BREAK (bpt->address))
	    {
	      /* See also: disable_breakpoints_in_shlibs. */
	      val = 0;
	      bpt->owner->enable_state = bp_shlib_disabled;
	      if (!*disabled_breaks)
		{
		  fprintf_unfiltered (tmp_error_stream, 
				      "Cannot insert breakpoint %d.\n", 
				      bpt->owner->number);
		  fprintf_unfiltered (tmp_error_stream, 
				      "Temporarily disabling shared library breakpoints:\n");
		}
	      *disabled_breaks = 1;
	      fprintf_unfiltered (tmp_error_stream,
				  "breakpoint #%d\n", bpt->owner->number);
	    }
	  else
d850 1
a850 1
	    {
d852 1
a852 1
	      *process_warning = 1;
d854 18
a871 18
	      if (bpt->loc_type == bp_loc_hardware_breakpoint)
		{
		  *hw_breakpoint_error = 1;
		  fprintf_unfiltered (tmp_error_stream, 
				      "Cannot insert hardware breakpoint %d.\n",
				      bpt->owner->number);
		}
	      else
		{
		  fprintf_unfiltered (tmp_error_stream, 
				      "Cannot insert breakpoint %d.\n", 
				      bpt->owner->number);
		  fprintf_filtered (tmp_error_stream, 
				    "Error accessing memory address ");
		  print_address_numeric (bpt->address, 1, tmp_error_stream);
		  fprintf_filtered (tmp_error_stream, ": %s.\n",
				    safe_strerror (val));
		}
d873 4
a876 4
	    }
	}
      else
	bpt->inserted = 1;
d878 9
a886 2
      return val;
    }
d888 6
a893 10
  else if (bpt->loc_type == bp_loc_hardware_watchpoint
	   /* NOTE drow/2003-09-08: This state only exists for removing
	      watchpoints.  It's not clear that it's necessary... */
	   && bpt->owner->disposition != disp_del_at_next_stop)
    {
      /* FIXME drow/2003-09-08: This code sets multiple hardware watchpoints
	 based on the expression.  Ideally this should happen at a higher level,
	 and there should be one bp_location for each computed address we
	 must watch.  As soon as a many-to-one mapping is available I'll
	 convert this.  */
d895 39
a933 4
      struct frame_info *saved_frame;
      int saved_level, within_current_scope;
      struct value *mark = value_mark ();
      struct value *v;
d935 3
a937 19
      /* Save the current frame and level so we can restore it after
	 evaluating the watchpoint expression on its own frame.  */
      /* FIXME drow/2003-09-09: It would be nice if evaluate_expression
	 took a frame parameter, so that we didn't have to change the
	 selected frame.  */
      saved_frame = deprecated_selected_frame;
      saved_level = frame_relative_level (deprecated_selected_frame);

      /* Determine if the watchpoint is within scope.  */
      if (bpt->owner->exp_valid_block == NULL)
	within_current_scope = 1;
      else
	{
	  struct frame_info *fi;
	  fi = frame_find_by_id (bpt->owner->watchpoint_frame);
	  within_current_scope = (fi != NULL);
	  if (within_current_scope)
	    select_frame (fi);
	}
d939 12
a950 4
      if (within_current_scope)
	{
	  /* Evaluate the expression and cut the chain of values
	     produced off from the value chain.
d952 16
a967 6
	     Make sure the value returned isn't lazy; we use
	     laziness to determine what memory GDB actually needed
	     in order to compute the value of the expression.  */
	  v = evaluate_expression (bpt->owner->exp);
	  VALUE_CONTENTS (v);
	  value_release_to_mark (mark);
d969 4
a972 2
	  bpt->owner->val_chain = v;
	  bpt->inserted = 1;
d974 6
a979 10
	  /* Look at each value on the value chain.  */
	  for (; v; v = v->next)
	    {
	      /* If it's a memory location, and GDB actually needed
		 its contents to evaluate the expression, then we
		 must watch it.  */
	      if (VALUE_LVAL (v) == lval_memory
		  && ! VALUE_LAZY (v))
		{
		  struct type *vtype = check_typedef (VALUE_TYPE (v));
d981 2
a982 9
		  /* We only watch structs and arrays if user asked
		     for it explicitly, never if they just happen to
		     appear in the middle of some value chain.  */
		  if (v == bpt->owner->val_chain
		      || (TYPE_CODE (vtype) != TYPE_CODE_STRUCT
			  && TYPE_CODE (vtype) != TYPE_CODE_ARRAY))
		    {
		      CORE_ADDR addr;
		      int len, type;
d984 10
a993 44
		      addr = VALUE_ADDRESS (v) + VALUE_OFFSET (v);
		      len = TYPE_LENGTH (VALUE_TYPE (v));
		      type = hw_write;
		      if (bpt->owner->type == bp_read_watchpoint)
			type = hw_read;
		      else if (bpt->owner->type == bp_access_watchpoint)
			type = hw_access;

		      val = target_insert_watchpoint (addr, len, type);
		      if (val == -1)
			{
			  /* Don't exit the loop, try to insert
			     every value on the value chain.  That's
			     because we will be removing all the
			     watches below, and removing a
			     watchpoint we didn't insert could have
			     adverse effects.  */
			  bpt->inserted = 0;
			}
		      val = 0;
		    }
		}
	    }
	  /* Failure to insert a watchpoint on any memory value in the
	     value chain brings us here.  */
	  if (!bpt->inserted)
	    {
	      remove_breakpoint (bpt, mark_uninserted);
	      *hw_breakpoint_error = 1;
	      fprintf_unfiltered (tmp_error_stream,
				  "Could not insert hardware watchpoint %d.\n", 
				  bpt->owner->number);
	      val = -1;
	    }               
	}
      else
	{
	  printf_filtered ("Hardware watchpoint %d deleted ", bpt->owner->number);
	  printf_filtered ("because the program has left the block \n");
	  printf_filtered ("in which its expression is valid.\n");
	  if (bpt->owner->related_breakpoint)
	    bpt->owner->related_breakpoint->disposition = disp_del_at_next_stop;
	  bpt->owner->disposition = disp_del_at_next_stop;
	}
d995 54
a1048 4
      /* Restore the frame and level.  */
      if (saved_frame != deprecated_selected_frame
	  || saved_level != frame_relative_level (deprecated_selected_frame))
	select_frame (saved_frame);
d1050 4
a1053 2
      return val;
    }
d1055 33
a1087 5
  else if (ep_is_exception_catchpoint (bpt->owner))
    {
      /* FIXME drow/2003-09-09: This code sets both a catchpoint and a
	 breakpoint.  Once again, it would be better if this was represented
	 as two bp_locations.  */
d1089 6
a1094 123
      /* If we get here, we must have a callback mechanism for exception
	 events -- with g++ style embedded label support, we insert
	 ordinary breakpoints and not catchpoints. */
      val = target_insert_breakpoint (bpt->address, bpt->shadow_contents);
      if (val)
	{
	  /* Couldn't set breakpoint for some reason */
	  fprintf_unfiltered (tmp_error_stream, 
			      "Cannot insert catchpoint %d; disabling it.\n",
			      bpt->owner->number);
	  fprintf_filtered (tmp_error_stream, 
			    "Error accessing memory address ");
	  print_address_numeric (bpt->address, 1, tmp_error_stream);
	  fprintf_filtered (tmp_error_stream, ": %s.\n",
			    safe_strerror (val));
	  bpt->owner->enable_state = bp_disabled;
	}
      else
	{
	  /* Bp set, now make sure callbacks are enabled */
	  /* Format possible error msg */
	  char *message = xstrprintf ("Error inserting catchpoint %d:\n",
				      bpt->owner->number);
	  struct cleanup *cleanups = make_cleanup (xfree, message);
	  int val;
	  args_for_catchpoint_enable args;
	  args.kind = bpt->owner->type == bp_catch_catch ? 
	    EX_EVENT_CATCH : EX_EVENT_THROW;
	  args.enable_p = 1;
	  val = catch_errors (cover_target_enable_exception_callback,
			      &args, message, RETURN_MASK_ALL);
	  do_cleanups (cleanups);
	  if (val != 0 && val != -1)
	    bpt->inserted = 1;

	  /* Check if something went wrong; val == 0 can be ignored */
	  if (val == -1)
	    {
	      /* something went wrong */
	      fprintf_unfiltered (tmp_error_stream, 
				  "Cannot insert catchpoint %d; disabling it.\n",
				  bpt->owner->number);
	      bpt->owner->enable_state = bp_disabled;
	    }
	}

      return val;
    }

  else if (bpt->owner->type == bp_catch_fork
	   || bpt->owner->type == bp_catch_vfork
	   || bpt->owner->type == bp_catch_exec)
    {
      char *prefix = xstrprintf ("warning: inserting catchpoint %d: ",
				 bpt->owner->number);
      struct cleanup *cleanups = make_cleanup (xfree, prefix);
      val = catch_exceptions (uiout, insert_catchpoint, bpt->owner, prefix,
			      RETURN_MASK_ERROR);
      do_cleanups (cleanups);
      if (val < 0)
	bpt->owner->enable_state = bp_disabled;
      else
	bpt->inserted = 1;

      /* We've already printed an error message if there was a problem
	 inserting this catchpoint, and we've disabled the catchpoint,
	 so just return success.  */
      return 0;
    }

  return 0;
}

/* insert_breakpoints is used when starting or continuing the program.
   remove_breakpoints is used when the program stops.
   Both return zero if successful,
   or an `errno' value if could not write the inferior.  */

int
insert_breakpoints (void)
{
  struct bp_location *b, *temp;
  int return_val = 0;	/* return success code. */
  int val = 0;
  int disabled_breaks = 0;
  int hw_breakpoint_error = 0;
  int process_warning = 0;

  struct ui_file *tmp_error_stream = mem_fileopen ();
  make_cleanup_ui_file_delete (tmp_error_stream);

  /* Explicitly mark the warning -- this will only be printed if
     there was an error.  */
  fprintf_unfiltered (tmp_error_stream, "Warning:\n");

  ALL_BP_LOCATIONS_SAFE (b, temp)
    {
      /* Permanent breakpoints cannot be inserted or removed.  Disabled
	 breakpoints should not be inserted.  */
      if (!breakpoint_enabled (b->owner))
	continue;

      /* FIXME drow/2003-10-07: This code should be pushed elsewhere when
	 hardware watchpoints are split into multiple loc breakpoints.  */
      if ((b->loc_type == bp_loc_hardware_watchpoint
	   || b->owner->type == bp_watchpoint) && !b->owner->val)
	{
	  struct value *val;
	  val = evaluate_expression (b->owner->exp);
	  release_value (val);
	  if (VALUE_LAZY (val))
	    value_fetch_lazy (val);
	  b->owner->val = val;
	}

      val = insert_bp_location (b, tmp_error_stream,
				    &disabled_breaks, &process_warning,
				    &hw_breakpoint_error);
      if (val)
	return_val = val;
    }

  if (return_val)
d1098 1
a1098 1
      if (hw_breakpoint_error)
d1118 1
a1118 1
  struct bp_location *b;
d1121 1
a1121 1
  ALL_BP_LOCATIONS (b)
d1136 1
a1136 1
  struct bp_location *b;
d1139 1
a1139 1
  ALL_BP_LOCATIONS (b)
d1141 4
a1144 1
    if (b->inserted && b->loc_type == bp_loc_hardware_watchpoint)
d1157 1
a1157 1
  struct bp_location *b;
d1163 1
a1163 1
  ALL_BP_LOCATIONS (b)
d1168 1
a1168 1
	if (b->loc_type == bp_loc_hardware_breakpoint)
a1171 2
	/* FIXME drow/2003-10-07: This doesn't handle any other kinds of
	   breakpoints.  It's wrong for watchpoints, for example.  */
d1246 5
a1250 5
       valid code address on some platforms (like the mn10300
       simulators).  We shouldn't assign any special interpretation to
       a breakpoint with a zero address.  And in fact, GDB doesn't ---
       I can't see what that comment above is talking about.  As far
       as I can tell, setting the address of a
d1258 1
a1258 1
	b->loc->address = (CORE_ADDR) NULL;
d1311 1
a1311 1
    b->loc->address = (CORE_ADDR) NULL;
d1320 1
a1320 1
  struct bp_location *b;
d1329 1
a1329 1
  ALL_BP_LOCATIONS (b)
d1346 1
a1346 1
remove_breakpoint (struct bp_location *b, insertion_state_t is)
d1350 1
a1350 1
  if (b->owner->enable_state == bp_permanent)
d1354 1
a1354 1
  if (b->owner->type == bp_none)
d1356 1
a1356 1
	     b->owner->number);
d1358 9
a1366 2
  if (b->loc_type == bp_loc_software_breakpoint
      || b->loc_type == bp_loc_hardware_breakpoint)
d1379 1
a1379 1
	  if (b->loc_type == bp_loc_hardware_breakpoint)
d1398 1
a1398 1
		if (b->loc_type == bp_loc_hardware_breakpoint)
d1411 1
a1411 1
	      if (b->loc_type == bp_loc_hardware_breakpoint)
d1428 4
a1431 2
  else if (b->loc_type == bp_loc_hardware_watchpoint
	   && breakpoint_enabled (b->owner)
d1439 1
a1439 1
      for (v = b->owner->val_chain; v; v = v->next)
d1448 1
a1448 1
	      if (v == b->owner->val_chain
d1458 1
a1458 1
		  if (b->owner->type == bp_read_watchpoint)
d1460 1
a1460 1
		  else if (b->owner->type == bp_access_watchpoint)
d1473 1
a1473 1
		 b->owner->number);
d1477 1
a1477 1
      for (v = b->owner->val_chain; v; v = n)
d1482 1
a1482 1
      b->owner->val_chain = NULL;
d1484 4
a1487 4
  else if ((b->owner->type == bp_catch_fork ||
	    b->owner->type == bp_catch_vfork ||
	    b->owner->type == bp_catch_exec)
	   && breakpoint_enabled (b->owner)
d1491 1
a1491 1
      switch (b->owner->type)
d1510 3
a1512 3
  else if ((b->owner->type == bp_catch_catch ||
	    b->owner->type == bp_catch_throw)
	   && breakpoint_enabled (b->owner)
d1521 1
a1521 1
  else if (ep_is_exception_catchpoint (b->owner)
d1523 1
a1523 1
	   && breakpoint_enabled (b->owner)
d1542 1
a1542 1
  struct bp_location *bpt;
d1544 2
a1545 2
  ALL_BP_LOCATIONS (bpt)
    bpt->inserted = 0;
d1563 1
a1563 2
  struct breakpoint *b, *temp;
  struct bp_location *bpt;
a1565 3
  ALL_BP_LOCATIONS (bpt)
    bpt->inserted = 0;

d1568 2
d1638 1
a1638 1
  struct bp_location *bpt;
d1641 14
a1654 20
  ALL_BP_LOCATIONS (bpt)
    {
      if (bpt->loc_type != bp_loc_software_breakpoint
	  && bpt->loc_type != bp_loc_hardware_breakpoint)
	continue;

      if ((breakpoint_enabled (bpt->owner)
	   || bpt->owner->enable_state == bp_permanent)
	  && bpt->address == pc)	/* bp is enabled and matches pc */
	{
	  if (overlay_debugging 
	      && section_is_overlay (bpt->section) 
	      && !section_is_mapped (bpt->section))
	    continue;		/* unmapped overlay -- can't be a match */
	  else if (bpt->owner->enable_state == bp_permanent)
	    return permanent_breakpoint_here;
	  else
	    any_breakpoint_here = 1;
	}
    }
d1667 1
a1667 1
  struct bp_location *bpt;
d1669 3
a1671 1
  ALL_BP_LOCATIONS (bpt)
d1673 6
a1678 14
      if (bpt->loc_type != bp_loc_software_breakpoint
	  && bpt->loc_type != bp_loc_hardware_breakpoint)
	continue;

      if (bpt->inserted
	  && bpt->address == pc)	/* bp is inserted and matches pc */
	{
	  if (overlay_debugging 
	      && section_is_overlay (bpt->section) 
	      && !section_is_mapped (bpt->section))
	    continue;		/* unmapped overlay -- can't be a match */
	  else
	    return 1;
	}
d1685 3
a1687 3
   DEPRECATED_PC_IN_CALL_DUMMY because figuring out the saved SP would
   take too much time, at least using frame_register() on the 68k.
   This means that for this function to work right a port must use the
d1691 1
a1691 1
deprecated_frame_in_dummy (struct frame_info *frame)
d1695 5
a1699 4
  /* This function is used by two files: get_frame_type(), after first
     checking that !DEPRECATED_USE_GENERIC_DUMMY_FRAMES; and
     sparc-tdep.c, which doesn't yet use generic dummy frames anyway.  */
  gdb_assert (!DEPRECATED_USE_GENERIC_DUMMY_FRAMES);
d1704 1
a1704 1
	&& frame_id_eq (b->frame_id, get_frame_id (frame))
d1707 4
a1710 4
	&& (get_frame_pc (frame)
	    >= (b->loc->address
		- DEPRECATED_SIZEOF_CALL_DUMMY_WORDS / sizeof (LONGEST) * DEPRECATED_REGISTER_SIZE))
	&& get_frame_pc (frame) <= b->loc->address)
d1716 2
a1717 2
/* breakpoint_thread_match (PC, PTID) returns true if the breakpoint at
   PC is valid for process/thread PTID.  */
d1722 1
a1722 1
  struct bp_location *bpt;
d1727 13
a1739 18
  ALL_BP_LOCATIONS (bpt)
    {
      if (bpt->loc_type != bp_loc_software_breakpoint
	  && bpt->loc_type != bp_loc_hardware_breakpoint)
	continue;

      if ((breakpoint_enabled (bpt->owner)
	   || bpt->owner->enable_state == bp_permanent)
	  && bpt->address == pc
	  && (bpt->owner->thread == -1 || bpt->owner->thread == thread))
	{
	  if (overlay_debugging 
	      && section_is_overlay (bpt->section) 
	      && !section_is_mapped (bpt->section))
	    continue;		/* unmapped overlay -- can't be a match */
	  else
	    return 1;
	}
a1820 5
      if (bs->commands != NULL)
	tmp->commands = copy_command_lines (bs->commands);
      if (bs->old_val != NULL)
	tmp->old_val = value_copy (bs->old_val);

d1920 1
d1922 1
a1922 1
cleanup_executing_breakpoints (void *ignore)
d2008 1
a2008 1
  struct cleanup *old_chain, *ui_out_chain;
a2020 4
      if (bs->breakpoint_at->loc->address != bs->breakpoint_at->loc->requested_address)
	breakpoint_adjustment_warning (bs->breakpoint_at->loc->requested_address,
	                               bs->breakpoint_at->loc->address,
				       bs->breakpoint_at->number, 1);
d2169 1
a2169 1
	  ui_out_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "value");
d2176 1
a2176 1
	  do_cleanups (ui_out_chain);
d2189 1
a2189 1
      ui_out_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "value");
d2193 1
a2193 1
      do_cleanups (ui_out_chain);
d2205 1
a2205 1
	  ui_out_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "value");
d2218 1
a2218 1
	  ui_out_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "value");
d2223 1
a2223 1
      do_cleanups (ui_out_chain);
d2278 2
a2279 7
      /* Normal case.  Call the breakpoint's print_it method, or
	 print_it_typical.  */
      if (bs->breakpoint_at != NULL && bs->breakpoint_at->ops != NULL
	  && bs->breakpoint_at->ops->print_it != NULL)
	return bs->breakpoint_at->ops->print_it (bs->breakpoint_at);
      else
	return print_it_typical (bs);
a2280 1

d2337 1
a2337 1
breakpoint_cond_eval (void *exp)
d2377 1
a2377 1
watchpoint_check (void *p)
a2382 3
#if 0
  struct frame_id current_frame_id;
#endif
d2400 2
a2401 7
	 state as `not changed' without further checking.
	 
	 vinschen/2003-09-04: The former implementation left out the case
	 that the watchpoint frame couldn't be found by frame_find_by_id()
	 because the current PC is currently in an epilogue.  Calling
	 gdbarch_in_function_epilogue_p() also when fr == NULL fixes that. */
      if ((!within_current_scope || fr == get_current_frame ())
d2404 1
a2404 1
      if (fr && within_current_scope)
d2489 1
a2489 1
  struct breakpoint *b, *temp;
d2497 3
d2511 3
a2513 1
    if (!breakpoint_enabled (b) && b->enable_state != bp_permanent)
d2527 1
a2527 1
	if (b->loc->address != bp_addr) 	/* address doesn't match */
d2530 2
a2531 2
	    && section_is_overlay (b->loc->section) 
	    && !section_is_mapped (b->loc->section))
d2537 1
a2537 1
	if (b->loc->address != (*pc - DECR_PC_AFTER_HW_BREAK))
d2540 2
a2541 2
	    && section_is_overlay (b->loc->section) 
	    && !section_is_mapped (b->loc->section))
d2573 2
a2574 2
	&& !inferior_has_forked (PIDGET (inferior_ptid),
				 &b->forked_inferior_pid))
d2578 2
a2579 2
	&& !inferior_has_vforked (PIDGET (inferior_ptid),
				  &b->forked_inferior_pid))
d2583 1
a2583 1
	&& !inferior_has_execd (PIDGET (inferior_ptid), &b->exec_pathname))
d2598 1
d2602 2
a2603 7
	char *message = xstrprintf ("Error evaluating expression for watchpoint %d\n",
				    b->number);
	struct cleanup *cleanups = make_cleanup (xfree, message);
	int e = catch_errors (watchpoint_check, bs, message, 
			      RETURN_MASK_ALL);
	do_cleanups (cleanups);
	switch (e)
d2671 36
a2706 43
	  {
	    char *message = xstrprintf ("Error evaluating expression for watchpoint %d\n",
					b->number);
	    struct cleanup *cleanups = make_cleanup (xfree, message);
	    int e = catch_errors (watchpoint_check, bs, message,
				  RETURN_MASK_ALL);
	    do_cleanups (cleanups);
	    switch (e)
	      {
	      case WP_DELETED:
		/* We've already printed what needs to be printed.  */
		bs->print_it = print_it_done;
		/* Stop.  */
		break;
	      case WP_VALUE_CHANGED:
		if (b->type == bp_read_watchpoint)
		  {
		    /* Don't stop: read watchpoints shouldn't fire if
		       the value has changed.  This is for targets
		       which cannot set read-only watchpoints.  */
		    bs->print_it = print_it_noop;
		    bs->stop = 0;
		    continue;
		  }
		++(b->hit_count);
		break;
	      case WP_VALUE_NOT_CHANGED:
		/* Stop.  */
		++(b->hit_count);
		break;
	      default:
		/* Can't happen.  */
	      case 0:
		/* Error from catch_errors.  */
		printf_filtered ("Watchpoint %d deleted.\n", b->number);
		if (b->related_breakpoint)
		  b->related_breakpoint->disposition = disp_del_at_next_stop;
		b->disposition = disp_del_at_next_stop;
		/* We've already printed what needs to be printed.  */
		bs->print_it = print_it_done;
		break;
	      }
	  }
d2727 2
a2728 2
    if (frame_id_p (b->frame_id)
	&& !frame_id_eq (b->frame_id, get_frame_id (get_current_frame ())))
d2763 1
a2765 1
	    bs->commands = b->commands;
d2767 2
a2768 2
		(strcmp ("silent", bs->commands->line) == 0
		 || (xdb_commands && strcmp ("Q", bs->commands->line) == 0)))
a2772 1
	    bs->commands = copy_command_lines (bs->commands);
d3104 1
a3104 1
    if (breakpoint_enabled (b) && b->type == bp_watchpoint)
d3113 7
a3119 5
  struct bp_location *bpt;
  ALL_BP_LOCATIONS (bpt)
    if (breakpoint_enabled (bpt->owner)
	&& bpt->inserted
	&& bpt->loc_type == bp_loc_hardware_watchpoint)
d3193 2
a3194 2
  struct command_line *l;
  struct symbol *sym;
a3234 1
  struct cleanup *bkpt_chain;
d3237 1
a3237 1
  bkpt_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "bkpt");
d3270 6
d3277 64
a3340 9
  if (b->ops != NULL && b->ops->print_one != NULL)
    b->ops->print_one (b, last_addr);
  else
    switch (b->type)
      {
      case bp_none:
	internal_error (__FILE__, __LINE__,
			"print_one_breakpoint: bp_none encountered\n");
	break;
d3342 10
a3351 129
      case bp_watchpoint:
      case bp_hardware_watchpoint:
      case bp_read_watchpoint:
      case bp_access_watchpoint:
	/* Field 4, the address, is omitted (which makes the columns
	   not line up too nicely with the headers, but the effect
	   is relatively readable).  */
	if (addressprint)
	  ui_out_field_skip (uiout, "addr");
	annotate_field (5);
	print_expression (b->exp, stb->stream);
	ui_out_field_stream (uiout, "what", stb);
	break;

      case bp_catch_load:
      case bp_catch_unload:
	/* Field 4, the address, is omitted (which makes the columns
	   not line up too nicely with the headers, but the effect
	   is relatively readable).  */
	if (addressprint)
	  ui_out_field_skip (uiout, "addr");
	annotate_field (5);
	if (b->dll_pathname == NULL)
	  {
	    ui_out_field_string (uiout, "what", "<any library>");
	    ui_out_spaces (uiout, 1);
	  }
	else
	  {
	    ui_out_text (uiout, "library \"");
	    ui_out_field_string (uiout, "what", b->dll_pathname);
	    ui_out_text (uiout, "\" ");
	  }
	break;

      case bp_catch_fork:
      case bp_catch_vfork:
	/* Field 4, the address, is omitted (which makes the columns
	   not line up too nicely with the headers, but the effect
	   is relatively readable).  */
	if (addressprint)
	  ui_out_field_skip (uiout, "addr");
	annotate_field (5);
	if (b->forked_inferior_pid != 0)
	  {
	    ui_out_text (uiout, "process ");
	    ui_out_field_int (uiout, "what", b->forked_inferior_pid);
	    ui_out_spaces (uiout, 1);
	  }

      case bp_catch_exec:
	/* Field 4, the address, is omitted (which makes the columns
	   not line up too nicely with the headers, but the effect
	   is relatively readable).  */
	if (addressprint)
	  ui_out_field_skip (uiout, "addr");
	annotate_field (5);
	if (b->exec_pathname != NULL)
	  {
	    ui_out_text (uiout, "program \"");
	    ui_out_field_string (uiout, "what", b->exec_pathname);
	    ui_out_text (uiout, "\" ");
	  }
	break;

      case bp_catch_catch:
	/* Field 4, the address, is omitted (which makes the columns
	   not line up too nicely with the headers, but the effect
	   is relatively readable).  */
	if (addressprint)
	  ui_out_field_skip (uiout, "addr");
	annotate_field (5);
	ui_out_field_string (uiout, "what", "exception catch");
	ui_out_spaces (uiout, 1);
	break;

      case bp_catch_throw:
	/* Field 4, the address, is omitted (which makes the columns
	   not line up too nicely with the headers, but the effect
	   is relatively readable).  */
	if (addressprint)
	  ui_out_field_skip (uiout, "addr");
	annotate_field (5);
	ui_out_field_string (uiout, "what", "exception throw");
	ui_out_spaces (uiout, 1);
	break;

      case bp_breakpoint:
      case bp_hardware_breakpoint:
      case bp_until:
      case bp_finish:
      case bp_longjmp:
      case bp_longjmp_resume:
      case bp_step_resume:
      case bp_through_sigtramp:
      case bp_watchpoint_scope:
      case bp_call_dummy:
      case bp_shlib_event:
      case bp_thread_event:
      case bp_overlay_event:
	if (addressprint)
	  {
	    annotate_field (4);
	    ui_out_field_core_addr (uiout, "addr", b->loc->address);
	  }
	annotate_field (5);
	*last_addr = b->loc->address;
	if (b->source_file)
	  {
	    sym = find_pc_sect_function (b->loc->address, b->loc->section);
	    if (sym)
	      {
		ui_out_text (uiout, "in ");
		ui_out_field_string (uiout, "func",
				     SYMBOL_PRINT_NAME (sym));
		ui_out_wrap_hint (uiout, wrap_indent);
		ui_out_text (uiout, " at ");
	      }
	    ui_out_field_string (uiout, "file", b->source_file);
	    ui_out_text (uiout, ":");
	    ui_out_field_int (uiout, "line", b->line_number);
	  }
	else
	  {
	    print_address_symbolic (b->loc->address, stb->stream, demangle, "");
	    ui_out_field_stream (uiout, "at", stb);
	  }
	break;
      }
d3353 54
d3417 1
a3417 1
  if (frame_id_p (b->frame_id))
d3421 1
a3421 3
      /* FIXME: cagney/2002-12-01: Shouldn't be poeking around inside
         the frame ID.  */
      ui_out_field_core_addr (uiout, "frame", b->frame_id.stack_addr);
a3472 2
      struct cleanup *script_chain;

d3474 1
a3474 1
      script_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "script");
d3476 1
a3476 1
      do_cleanups (script_chain);
d3478 1
a3478 1
  do_cleanups (bkpt_chain);
d3491 1
a3491 1
  struct breakpoint *b;
d3543 1
a3543 1
  struct breakpoint *b;
a3545 1
  struct cleanup *bkpttbl_chain;
d3558 1
a3558 3
    bkpttbl_chain 
      = make_cleanup_ui_out_table_begin_end (uiout, 6, nr_printable_breakpoints,
                                             "BreakpointTable");
d3560 1
a3560 3
    bkpttbl_chain 
      = make_cleanup_ui_out_table_begin_end (uiout, 5, nr_printable_breakpoints,
                                             "BreakpointTable");
d3602 1
a3602 1
  do_cleanups (bkpttbl_chain);
d3625 1
d3637 1
d3654 2
a3655 2
  int others = 0;
  struct breakpoint *b;
d3658 2
a3659 2
    if (b->loc->address == pc)	/* address match / overlay match */
      if (!overlay_debugging || b->loc->section == section)
d3665 2
a3666 2
	if (b->loc->address == pc)	/* address match / overlay match */
	  if (!overlay_debugging || b->loc->section == section)
d3743 5
a3747 5
  struct bp_location *b;
  int count = 0;
  struct bp_location *perm_bp = 0;
  CORE_ADDR address = bpt->loc->address;
  asection *section = bpt->loc->section;
d3752 4
a3755 4
  ALL_BP_LOCATIONS (b)
    if (b->owner->enable_state != bp_disabled
	&& b->owner->enable_state != bp_shlib_disabled
	&& b->owner->enable_state != bp_call_disabled
d3758 1
a3758 1
	&& breakpoint_address_is_meaningful (b->owner))
d3761 1
a3761 1
      if (b->owner->enable_state == bp_permanent)
d3784 1
a3784 1
      ALL_BP_LOCATIONS (b)
d3787 8
a3794 3
	    if (b->owner->enable_state != bp_disabled
		&& b->owner->enable_state != bp_shlib_disabled
		&& b->owner->enable_state != bp_call_disabled
d3797 2
a3798 9
		&& breakpoint_address_is_meaningful (b->owner))
	      {
		if (b->inserted)
		  internal_error (__FILE__, __LINE__,
				  "another breakpoint was inserted on top of "
				  "a permanent breakpoint");

		b->duplicate = 1;
	      }
a3802 113
static void
breakpoint_adjustment_warning (CORE_ADDR from_addr, CORE_ADDR to_addr,
                               int bnum, int have_bnum)
{
  char astr1[40];
  char astr2[40];

  strcpy (astr1, local_hex_string_custom ((unsigned long) from_addr, "08l"));
  strcpy (astr2, local_hex_string_custom ((unsigned long) to_addr, "08l"));
  if (have_bnum)
    warning ("Breakpoint %d address previously adjusted from %s to %s.",
             bnum, astr1, astr2);
  else
    warning ("Breakpoint address adjusted from %s to %s.", astr1, astr2);
}

/* Adjust a breakpoint's address to account for architectural constraints
   on breakpoint placement.  Return the adjusted address.  Note: Very
   few targets require this kind of adjustment.  For most targets,
   this function is simply the identity function.  */

static CORE_ADDR
adjust_breakpoint_address (CORE_ADDR bpaddr)
{
  if (!gdbarch_adjust_breakpoint_address_p (current_gdbarch))
    {
      /* Very few targets need any kind of breakpoint adjustment.  */
      return bpaddr;
    }
  else
    {
      CORE_ADDR adjusted_bpaddr;

      /* Some targets have architectural constraints on the placement
         of breakpoint instructions.  Obtain the adjusted address.  */
      adjusted_bpaddr = gdbarch_adjust_breakpoint_address (current_gdbarch,
                                                           bpaddr);

      /* An adjusted breakpoint address can significantly alter
         a user's expectations.  Print a warning if an adjustment
	 is required.  */
      if (adjusted_bpaddr != bpaddr)
	breakpoint_adjustment_warning (bpaddr, adjusted_bpaddr, 0, 0);

      return adjusted_bpaddr;
    }
}

/* Allocate a struct bp_location.  */

static struct bp_location *
allocate_bp_location (struct breakpoint *bpt, enum bptype bp_type)
{
  struct bp_location *loc, *loc_p;

  loc = xmalloc (sizeof (struct bp_location));
  memset (loc, 0, sizeof (*loc));

  loc->owner = bpt;

  switch (bp_type)
    {
    case bp_breakpoint:
    case bp_until:
    case bp_finish:
    case bp_longjmp:
    case bp_longjmp_resume:
    case bp_step_resume:
    case bp_through_sigtramp:
    case bp_watchpoint_scope:
    case bp_call_dummy:
    case bp_shlib_event:
    case bp_thread_event:
    case bp_overlay_event:
    case bp_catch_load:
    case bp_catch_unload:
      loc->loc_type = bp_loc_software_breakpoint;
      break;
    case bp_hardware_breakpoint:
      loc->loc_type = bp_loc_hardware_breakpoint;
      break;
    case bp_hardware_watchpoint:
    case bp_read_watchpoint:
    case bp_access_watchpoint:
      loc->loc_type = bp_loc_hardware_watchpoint;
      break;
    case bp_watchpoint:
    case bp_catch_fork:
    case bp_catch_vfork:
    case bp_catch_exec:
    case bp_catch_catch:
    case bp_catch_throw:
      loc->loc_type = bp_loc_other;
      break;
    default:
      internal_error (__FILE__, __LINE__, "unknown breakpoint type");
    }

  /* Add this breakpoint to the end of the chain.  */

  loc_p = bp_location_chain;
  if (loc_p == 0)
    bp_location_chain = loc;
  else
    {
      while (loc_p->next)
	loc_p = loc_p->next;
      loc_p->next = loc;
    }

  return loc;
}

d3821 1
a3821 1
  struct breakpoint *b, *b1;
d3825 1
a3825 3
  b->loc = allocate_bp_location (b, bptype);
  b->loc->requested_address = sal.pc;
  b->loc->address = adjust_breakpoint_address (b->loc->requested_address);
d3831 1
a3831 1
  b->loc->section = sal.section;
d3842 1
a3842 1
  b->frame_id = null_frame_id;
a3846 1
  b->ops = NULL;
d3877 1
a3877 1
  b->loc->inserted = 1;
d3910 1
a3910 1
      if ((m = lookup_minimal_symbol_text (func_name, NULL)) == NULL)
d3929 1
a3929 1
  struct breakpoint *b;
d3942 1
a3942 1
  struct breakpoint *b;
d3959 1
a3959 1
  if ((m = lookup_minimal_symbol_text (func_name, NULL)) == NULL)
d3981 1
a3981 1
  struct breakpoint *b;
d3995 1
a3995 1
  struct breakpoint *b;
d4010 1
d4016 2
a4017 1
  xasprintf (&b->addr_string, "*0x%s", paddr (b->loc->address));
d4036 1
a4036 1
  struct breakpoint *b, *temp;
d4067 3
a4069 3
	breakpoint_enabled (b) &&
	!b->loc->duplicate &&
	PC_SOLIB (b->loc->address))
d4096 1
a4096 1
      char buf[1], *lib;
d4100 1
a4100 2
      lib = PC_SOLIB (b->loc->address);
      if (lib != NULL && target_read_memory (b->loc->address, buf, 1) == 0)
d4268 1
a4268 1
  struct breakpoint *b;
d4283 1
a4283 1
  struct breakpoint *b;
d4289 1
a4289 1
    if (breakpoint_enabled (b))
d4295 2
a4296 1
		  b->type == bp_access_watchpoint))
d4310 1
a4310 1
set_longjmp_resume_breakpoint (CORE_ADDR pc, struct frame_id frame_id)
d4312 1
a4312 1
  struct breakpoint *b;
d4317 1
a4317 2
      b->loc->requested_address = pc;
      b->loc->address = adjust_breakpoint_address (b->loc->requested_address);
d4319 4
a4322 1
      b->frame_id = frame_id;
d4340 1
a4340 1
	&& breakpoint_enabled (b))
d4374 1
a4374 1
set_momentary_breakpoint (struct symtab_and_line sal, struct frame_id frame_id,
d4377 1
a4377 1
  struct breakpoint *b;
d4381 1
a4381 1
  b->frame_id = frame_id;
d4399 1
a4399 1
  struct cleanup *old_chain, *ui_out_chain;
d4414 83
a4496 100
  if (b->ops != NULL && b->ops->print_mention != NULL)
    b->ops->print_mention (b);
  else
    switch (b->type)
      {
      case bp_none:
	printf_filtered ("(apparently deleted?) Eventpoint %d: ", b->number);
	break;
      case bp_watchpoint:
	ui_out_text (uiout, "Watchpoint ");
	ui_out_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "wpt");
	ui_out_field_int (uiout, "number", b->number);
	ui_out_text (uiout, ": ");
	print_expression (b->exp, stb->stream);
	ui_out_field_stream (uiout, "exp", stb);
	do_cleanups (ui_out_chain);
	break;
      case bp_hardware_watchpoint:
	ui_out_text (uiout, "Hardware watchpoint ");
	ui_out_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "wpt");
	ui_out_field_int (uiout, "number", b->number);
	ui_out_text (uiout, ": ");
	print_expression (b->exp, stb->stream);
	ui_out_field_stream (uiout, "exp", stb);
	do_cleanups (ui_out_chain);
	break;
      case bp_read_watchpoint:
	ui_out_text (uiout, "Hardware read watchpoint ");
	ui_out_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "hw-rwpt");
	ui_out_field_int (uiout, "number", b->number);
	ui_out_text (uiout, ": ");
	print_expression (b->exp, stb->stream);
	ui_out_field_stream (uiout, "exp", stb);
	do_cleanups (ui_out_chain);
	break;
      case bp_access_watchpoint:
	ui_out_text (uiout, "Hardware access (read/write) watchpoint ");
	ui_out_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "hw-awpt");
	ui_out_field_int (uiout, "number", b->number);
	ui_out_text (uiout, ": ");
	print_expression (b->exp, stb->stream);
	ui_out_field_stream (uiout, "exp", stb);
	do_cleanups (ui_out_chain);
	break;
      case bp_breakpoint:
	if (ui_out_is_mi_like_p (uiout))
	  {
	    say_where = 0;
	    break;
	  }
	printf_filtered ("Breakpoint %d", b->number);
	say_where = 1;
	break;
      case bp_hardware_breakpoint:
	if (ui_out_is_mi_like_p (uiout))
	  {
	    say_where = 0;
	    break;
	  }
	printf_filtered ("Hardware assisted breakpoint %d", b->number);
	say_where = 1;
	break;
      case bp_catch_load:
      case bp_catch_unload:
	printf_filtered ("Catchpoint %d (%s %s)",
			 b->number,
			 (b->type == bp_catch_load) ? "load" : "unload",
			 (b->dll_pathname != NULL) ? 
			 b->dll_pathname : "<any library>");
	break;
      case bp_catch_fork:
      case bp_catch_vfork:
	printf_filtered ("Catchpoint %d (%s)",
			 b->number,
			 (b->type == bp_catch_fork) ? "fork" : "vfork");
	break;
      case bp_catch_exec:
	printf_filtered ("Catchpoint %d (exec)",
			 b->number);
	break;
      case bp_catch_catch:
      case bp_catch_throw:
	printf_filtered ("Catchpoint %d (%s)",
			 b->number,
			 (b->type == bp_catch_catch) ? "catch" : "throw");
	break;

      case bp_until:
      case bp_finish:
      case bp_longjmp:
      case bp_longjmp_resume:
      case bp_step_resume:
      case bp_through_sigtramp:
      case bp_call_dummy:
      case bp_watchpoint_scope:
      case bp_shlib_event:
      case bp_thread_event:
      case bp_overlay_event:
	break;
      }
d4498 13
d4516 1
a4516 1
	  print_address_numeric (b->loc->address, 1, gdb_stdout);
d4573 1
a4573 6
	if (addr_string[i])
	  b->addr_string = addr_string[i];
	else
	  /* addr_string has to be used or breakpoint_re_set will delete
	     me.  */
	  xasprintf (&b->addr_string, "*0x%s", paddr (b->loc->address));
d4588 1
a4588 1
static void
d4655 1
a4655 1
static void
d4697 1
a4697 1
  struct expression **cond = 0;
d4840 1
a4840 1
  struct expression **cond;
d4954 1
d4963 1
a4963 1
	  if (deprecated_selected_frame)
d4965 1
a4965 1
	      selected_pc = get_frame_pc (deprecated_selected_frame);
d4994 1
a4994 1
	selected_pc = get_frame_pc (frame);
d5008 1
a5008 1
	  char *addr_string;
d5010 1
a5010 1
	    addr_string = xstrprintf ("*0x%s %s", paddr_nz (high), extra_args);
d5012 1
a5012 1
	    addr_string = xstrprintf ("*0x%s", paddr_nz (high));
d5041 1
a5041 1
	  if (deprecated_selected_frame)
d5043 2
a5044 2
	      addr_string = xstrprintf ("*0x%s",
					paddr_nz (get_frame_pc (deprecated_selected_frame)));
d5090 1
a5090 1
	  break_string;
d5092 1
a5092 2
	    break_string = xstrprintf ("*0x%s %s", paddr_nz (high),
				       extra_args);
d5094 1
a5094 1
	    break_string = xstrprintf ("*0x%s", paddr_nz (high));
d5274 1
d5400 1
a5400 1
      b->watchpoint_frame = get_frame_id (frame);
d5424 1
a5424 1
	  scope_breakpoint->frame_id = get_frame_id (prev_frame);
d5427 1
a5427 4
	  scope_breakpoint->loc->requested_address
	    = get_frame_pc (prev_frame);
	  scope_breakpoint->loc->address
	    = adjust_breakpoint_address (scope_breakpoint->loc->requested_address);
d5444 1
a5444 1
    ((BYTE_SIZE) <= (DEPRECATED_REGISTER_SIZE))
d5577 1
d5579 1
a5579 1
until_break_command (char *arg, int from_tty, int anywhere)
d5583 1
a5583 1
  struct frame_info *prev_frame = get_prev_frame (deprecated_selected_frame);
d5612 1
a5612 10
  if (anywhere)
    /* If the user told us to continue until a specified location,
       we don't specify a frame at which we need to stop.  */
    breakpoint = set_momentary_breakpoint (sal, null_frame_id, bp_until);
  else
    /* Otherwise, specify the current frame, because we want to stop only
       at the very same frame.  */
    breakpoint = set_momentary_breakpoint (sal,
					   get_frame_id (deprecated_selected_frame),
					   bp_until);
d5640 2
a5641 2
  /* Keep within the current frame, or in frames called by the current
     one.  */
d5644 3
a5646 4
      sal = find_pc_line (get_frame_pc (prev_frame), 0);
      sal.pc = get_frame_pc (prev_frame);
      breakpoint = set_momentary_breakpoint (sal, get_frame_id (prev_frame),
					     bp_until);
d5659 1
a5659 1

d5684 181
a6169 84
static enum print_stop_action
print_exception_catchpoint (struct breakpoint *b)
{
  annotate_catchpoint (b->number);

  if (strstr (b->addr_string, "throw") != NULL)
    printf_filtered ("\nCatchpoint %d (exception thrown)\n",
		     b->number);
  else
    printf_filtered ("\nCatchpoint %d (exception caught)\n",
		     b->number);

  return PRINT_SRC_AND_LOC;
}

static void
print_one_exception_catchpoint (struct breakpoint *b, CORE_ADDR *last_addr)
{
  if (addressprint)
    {
      annotate_field (4);
      ui_out_field_core_addr (uiout, "addr", b->loc->address);
    }
  annotate_field (5);
  *last_addr = b->loc->address;
  if (strstr (b->addr_string, "throw") != NULL)
    ui_out_field_string (uiout, "what", "exception throw");
  else
    ui_out_field_string (uiout, "what", "exception catch");
}

static void
print_mention_exception_catchpoint (struct breakpoint *b)
{
  if (strstr (b->addr_string, "throw") != NULL)
    printf_filtered ("Catchpoint %d (throw)", b->number);
  else
    printf_filtered ("Catchpoint %d (catch)", b->number);
}

static struct breakpoint_ops gnu_v3_exception_catchpoint_ops = {
  print_exception_catchpoint,
  print_one_exception_catchpoint,
  print_mention_exception_catchpoint
};

static int
handle_gnu_v3_exceptions (int tempflag, char *cond_string,
			  enum exception_event_kind ex_event, int from_tty)
{
  char *trigger_func_name, *nameptr;
  struct symtabs_and_lines sals;
  struct breakpoint *b;

  if (ex_event == EX_EVENT_CATCH)
    trigger_func_name = xstrdup ("__cxa_begin_catch");
  else
    trigger_func_name = xstrdup ("__cxa_throw");

  nameptr = trigger_func_name;
  sals = decode_line_1 (&nameptr, 1, NULL, 0, NULL);
  if (sals.nelts == 0)
    {
      xfree (trigger_func_name);
      return 0;
    }

  b = set_raw_breakpoint (sals.sals[0], bp_breakpoint);
  set_breakpoint_count (breakpoint_count + 1);
  b->number = breakpoint_count;
  b->cond = NULL;
  b->cond_string = (cond_string == NULL) ? 
    NULL : savestring (cond_string, strlen (cond_string));
  b->thread = -1;
  b->addr_string = trigger_func_name;
  b->enable_state = bp_enabled;
  b->disposition = tempflag ? disp_del : disp_donttouch;
  b->ops = &gnu_v3_exception_catchpoint_ops;

  xfree (sals.sals);
  mention (b);
  return 1;
}

a6189 3
  if (handle_gnu_v3_exceptions (tempflag, cond_string, ex_event, from_tty))
    return;

d6202 11
d6214 5
a6218 1
  warning ("Unsupported with this platform/compiler combination.");
d6225 1
a6225 1
cover_target_enable_exception_callback (void *arg)
d6238 105
d6583 3
a6585 3
	      && (((sal.pc && (b->loc->address == sal.pc)) 
		   && (!section_is_overlay (b->loc->section)
		       || b->loc->section == sal.section))
d6590 1
a6590 1
		      && strcmp (b->source_file, sal.symtab->filename) == 0
d6668 2
a6669 3
  struct breakpoint *b;
  bpstat bs;
  struct bp_location *loc;
d6695 2
a6696 2
  if (bpt->loc->inserted)
    remove_breakpoint (bpt->loc, mark_inserted);
a6700 3
  if (bp_location_chain == bpt->loc)
    bp_location_chain = bpt->loc->next;

d6709 4
d6714 1
a6714 4
      char *message = xstrprintf ("Error in deleting catchpoint %d:\n",
				  bpt->number);
      struct cleanup *cleanups = make_cleanup (xfree, message);
      args_for_catchpoint_enable args;
a6719 1
      do_cleanups (cleanups);
a6729 7
  ALL_BP_LOCATIONS (loc)
    if (loc->next == bpt->loc)
      {
	loc->next = bpt->loc->next;
	break;
      }

d6733 1
a6733 1
  if (bpt->loc->inserted
d6742 3
a6744 3
	if (b->loc->address == bpt->loc->address
	    && b->loc->section == bpt->loc->section
	    && !b->loc->duplicate
d6761 1
a6761 1
	    val = target_insert_hw_breakpoint (b->loc->address, b->loc->shadow_contents);
d6763 1
a6763 1
	    val = target_insert_breakpoint (b->loc->address, b->loc->shadow_contents);
d6783 1
a6783 1
		    print_address_numeric (b->loc->address, 1, tmp_error_stream);
d6793 1
a6793 1
	    b->loc->inserted = 1;
a6832 1
  xfree (bpt->loc);
d6902 1
a6902 1
breakpoint_re_set_one (void *bint)
d6974 1
a6974 1
	  if (b->loc->address != sals.sals[i].pc
d6979 1
a6979 1
		  && (strcmp (b->source_file, sals.sals[i].symtab->filename) != 0
d6996 1
a6996 3
	      b->loc->requested_address = sals.sals[i].pc;
	      b->loc->address
	        = adjust_breakpoint_address (b->loc->requested_address);
d7008 1
a7008 1
	  b->loc->section = sals.sals[i].section;
d7043 1
a7043 1
      if (VALUE_LAZY (b->val) && breakpoint_enabled (b))
d7053 1
a7053 1
      if (breakpoint_enabled (b))
d7109 2
d7117 1
a7117 3
    char *message = xstrprintf ("Error in re-setting breakpoint %d:\n",
				b->number);
    struct cleanup *cleanups = make_cleanup (xfree, message);
a7118 1
    do_cleanups (cleanups);
d7156 1
a7156 1
  struct breakpoint *b;
d7201 1
a7201 1
  int num;
d7225 1
a7225 1
  char *p = args;
d7227 2
a7228 2
  int num;
  struct breakpoint *b, *tmp;
d7289 1
d7293 1
a7293 1
  struct breakpoint *bpt;
d7368 2
a7369 2
	  save_selected_frame = deprecated_selected_frame;
	  save_selected_frame_level = frame_relative_level (deprecated_selected_frame);
d7423 1
d7427 1
a7427 1
  struct breakpoint *bpt;
d7463 1
d7476 1
@


1.90.2.3
log
@Merge from mainline.
@
text
@d4331 1
a4331 1
  sals = decode_line_1 (&hookname, 1, (struct symtab *) NULL, 0, &canonical, NULL);
d4848 1
a4848 1
			       default_breakpoint_line, addr_string, NULL);
d4850 1
a4850 1
	*sals = decode_line_1 (address, 1, (struct symtab *) NULL, 0, addr_string, NULL);
d5296 1
a5296 1
			(char ***) NULL, NULL);
d5813 1
a5813 1
			  default_breakpoint_line, (char ***) NULL, NULL);
d5816 1
a5816 1
			  0, (char ***) NULL, NULL);
d6276 1
a6276 1
  sals = decode_line_1 (&nameptr, 1, NULL, 0, NULL, NULL);
d6983 1
a6983 1
      sals = decode_line_1 (&s, 1, (struct symtab *) NULL, 0, (char ***) NULL, NULL);
d7519 1
a7519 1
			  (char ***) NULL, NULL);
d7522 1
a7522 1
			  (struct symtab *) NULL, 0, (char ***) NULL, NULL);
@


1.90.2.4
log
@Merge from mainline.
@
text
@d1995 1
a2019 13
      struct command_line *cmd;
      struct cleanup *this_cmd_tree_chain;

      /* Take ownership of the BSP's command tree, if it has one.

         The command tree could legitimately contain commands like
         'step' and 'next', which call clear_proceed_status, which
         frees stop_bpstat's command tree.  To make sure this doesn't
         free the tree we're executing out from under us, we need to
         take ownership of the tree ourselves.  Since a given bpstat's
         commands are only executed once, we don't need to copy it; we
         can clear the pointer in the bpstat, and make sure we free
         the tree when we're done.  */
a2020 3
      bs->commands = 0;
      this_cmd_tree_chain = make_cleanup_free_command_lines (&cmd);

a2029 4

      /* We can free this command tree now.  */
      do_cleanups (this_cmd_tree_chain);

d2036 2
@


1.90.2.5
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d4 2
a5 2
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
   Free Software Foundation, Inc.
d92 1
a92 1
static int break_command_1 (char *, int, int, struct breakpoint *);
a121 2
static int do_captured_parse_breakpoint (struct ui_out *, void *);

d196 4
d247 10
d339 1
a339 1
  return (b->enable_state == bp_enabled && !b->pending);
d573 3
a575 6
	  if (!b->pending)
	    {
	      b->cond = parse_exp_1 (&arg, block_for_pc (b->loc->address), 0);
	      if (*arg)
		error ("Junk at end of expression");
	    }
a1733 31
/* This function returns non-zero iff there is a software breakpoint
   inserted at PC.  */

int
software_breakpoint_inserted_here_p (CORE_ADDR pc)
{
  struct bp_location *bpt;
  int any_breakpoint_here = 0;

  ALL_BP_LOCATIONS (bpt)
    {
      if (bpt->loc_type != bp_loc_software_breakpoint)
	continue;

      if ((breakpoint_enabled (bpt->owner)
	   || bpt->owner->enable_state == bp_permanent)
	  && bpt->inserted
	  && bpt->address == pc)	/* bp is enabled and matches pc */
	{
	  if (overlay_debugging 
	      && section_is_overlay (bpt->section) 
	      && !section_is_mapped (bpt->section))
	    continue;		/* unmapped overlay -- can't be a match */
	  else
	    return 1;
	}
    }

  return 0;
}

d2468 3
d2559 5
a2563 2
/* Get a bpstat associated with having just stopped at address
   BP_ADDR.  */
d2580 1
a2580 1
bpstat_stop_status (CORE_ADDR bp_addr, ptid_t ptid)
d2583 1
d2590 8
a2597 1
  int thread_id = pid_to_thread_id (ptid);
d2625 1
a2625 1
	if (b->loc->address != bp_addr)
a2850 6
	else if (b->thread != -1 && b->thread != thread_id)
	  {
	    bs->stop = 0;
	    /* Don't consider this a hit.  */
	    --(b->hit_count);
	  }
d2883 24
d3483 1
a3483 10
	    if (b->pending)
	      {
		ui_out_field_string (uiout, "addr", "<PENDING>");
		if (TARGET_ADDR_BIT <= 32)
		  ui_out_spaces (uiout, 2);
		else
		  ui_out_spaces (uiout, 8);
	      }
	    else
	      ui_out_field_core_addr (uiout, "addr", b->loc->address);
a3501 4
	else if (b->pending)
	  {
	    ui_out_field_string (uiout, "pending", b->addr_string);
	  }
d3538 1
a3538 9

  if (b->pending && b->cond_string)
    {
      annotate_field (7);
      ui_out_text (uiout, "\tstop only if ");
      ui_out_field_string (uiout, "cond", b->cond_string);
      ui_out_text (uiout, "\n");
    }

d3769 1
a3769 1
      if (!b->pending && (!overlay_debugging || b->loc->section == section))
d3776 1
a3776 1
	  if (!b->pending && (!overlay_debugging || b->loc->section == section))
a3864 1
	&& !b->owner->pending
a3898 1
		&& !b->owner->pending
a4074 1
  b->pending = 0;
a4257 60
struct captured_parse_breakpoint_args
  {
    char **arg_p;
    struct symtabs_and_lines *sals_p;
    char ***addr_string_p;
    int *not_found_ptr;
  };

struct lang_and_radix
  {
    enum language lang;
    int radix;
  };

/* Cleanup helper routine to restore the current language and
   input radix.  */
static void
do_restore_lang_radix_cleanup (void *old)
{
  struct lang_and_radix *p = old;
  set_language (p->lang);
  input_radix = p->radix;
}

/* Try and resolve a pending breakpoint.  */
static int
resolve_pending_breakpoint (struct breakpoint *b)
{
  /* Try and reparse the breakpoint in case the shared library
     is now loaded.  */
  struct symtabs_and_lines sals;
  struct symtab_and_line pending_sal;
  char **cond_string = (char **) NULL;
  char *copy_arg = b->addr_string;
  char **addr_string;
  char *errmsg;
  int rc;
  int not_found = 0;
  struct ui_file *old_gdb_stderr;
  struct lang_and_radix old_lr;
  struct cleanup *old_chain;
  
  /* Set language, input-radix, then reissue breakpoint command. 
     Ensure the language and input-radix are restored afterwards.  */
  old_lr.lang = current_language->la_language;
  old_lr.radix = input_radix;
  old_chain = make_cleanup (do_restore_lang_radix_cleanup, &old_lr);
  
  set_language (b->language);
  input_radix = b->input_radix;
  rc = break_command_1 (b->addr_string, b->flag, b->from_tty, b);
  
  if (rc == GDB_RC_OK)
    /* Pending breakpoint has been resolved.  */
    printf_filtered ("Pending breakpoint \"%s\" resolved\n", b->addr_string);

  do_cleanups (old_chain);
  return rc;
}

d4317 1
a4317 1
  struct breakpoint *b, *tmp;
d4319 1
a4319 2
  ALL_BREAKPOINTS_SAFE (b, tmp)
  {
d4321 9
a4329 15
      {
	char buf[1], *lib;
	
	/* Do not reenable the breakpoint if the shared library
	   is still not mapped in.  */
	lib = PC_SOLIB (b->loc->address);
	if (lib != NULL && target_read_memory (b->loc->address, buf, 1) == 0)
	  b->enable_state = bp_enabled;
      }
    else if (b->pending && (b->enable_state == bp_enabled))
      {
	if (resolve_pending_breakpoint (b) == GDB_RC_OK)
	  delete_breakpoint (b);
      }
  }
d4741 1
a4741 5
      if (b->pending)
	{
	  printf_filtered (" (%s) pending.", b->addr_string);
	}
      else
d4743 2
a4744 8
	  if (addressprint || b->source_file == NULL)
	    {
	      printf_filtered (" at ");
	      print_address_numeric (b->loc->address, 1, gdb_stdout);
	    }
	  if (b->source_file)
	    printf_filtered (": file %s, line %d.",
			     b->source_file, b->line_number);
d4746 3
a4760 5
   The parameter PENDING_BP points to a pending breakpoint that is
   the basis of the breakpoints currently being created.  The pending
   breakpoint may contain a separate condition string or commands
   that were added after the initial pending breakpoint was created.

d4771 1
a4771 2
		    int thread, int ignore_count, int from_tty,
		    struct breakpoint *pending_bp)
a4810 20
	/* If resolving a pending breakpoint, a check must be made to see if
	   the user has specified a new condition or commands for the 
	   breakpoint.  A new condition will override any condition that was 
	   initially specified with the initial breakpoint command.  */
	if (pending_bp)
	  {
	    char *arg;
	    if (pending_bp->cond_string)
	      {
		arg = pending_bp->cond_string;
		b->cond_string = savestring (arg, strlen (arg));
		b->cond = parse_exp_1 (&arg, block_for_pc (b->loc->address), 0);
		if (*arg)
		  error ("Junk at end of pending breakpoint condition expression");
	      }
	    /* If there are commands associated with the breakpoint, they should 
	       be copied too.  */
	    if (pending_bp->commands)
	      b->commands = copy_command_lines (pending_bp->commands);
	  }
d4824 1
a4824 2
		       char ***addr_string,
		       int *not_found_ptr)
d4865 1
a4865 2
			       default_breakpoint_line, addr_string, 
			       not_found_ptr);
d4867 1
a4867 2
	*sals = decode_line_1 (address, 1, (struct symtab *) NULL, 0,
		               addr_string, not_found_ptr);
a4920 11
static int
do_captured_parse_breakpoint (struct ui_out *ui, void *data)
{
  struct captured_parse_breakpoint_args *args = data;
  
  parse_breakpoint_sals (args->arg_p, args->sals_p, args->addr_string_p, 
		         args->not_found_ptr);

  return GDB_RC_OK;
}

d4923 1
a4923 1
   second bit : 0 normal breakpoint, 1 hardware breakpoint. 
d4925 2
a4926 5
   PENDING_BP is non-NULL when this function is being called to resolve
   a pending breakpoint.  */

static int
break_command_1 (char *arg, int flag, int from_tty, struct breakpoint *pending_bp)
d4931 2
a4932 1
  struct symtab_and_line pending_sal;
a4933 2
  char *copy_arg;
  char *err_msg;
d4938 1
a4938 3
  struct captured_parse_breakpoint_args parse_args;
  int i, rc;
  int pending = 0;
a4940 1
  int not_found = 0;
d4948 1
d4950 2
a4951 36
  parse_args.arg_p = &arg;
  parse_args.sals_p = &sals;
  parse_args.addr_string_p = &addr_string;
  parse_args.not_found_ptr = &not_found;

  rc = catch_exceptions_with_msg (uiout, do_captured_parse_breakpoint, 
		  		  &parse_args, NULL, &err_msg, 
				  RETURN_MASK_ALL);

  /* If caller is interested in rc value from parse, set value.  */

  if (rc != GDB_RC_OK)
    {
      /* Check for file or function not found.  */
      if (not_found)
	{
	  /* If called to resolve pending breakpoint, just return error code.  */
	  if (pending_bp)
	    return rc;

	  error_output_message (NULL, err_msg);
	  xfree (err_msg);
	  if (!query ("Make breakpoint pending on future shared library load? "))
	    return rc;
	  copy_arg = xstrdup (addr_start);
	  addr_string = &copy_arg;
	  sals.nelts = 1;
	  sals.sals = &pending_sal;
	  pending_sal.pc = 0;
	  pending = 1;
	}
      else
	return rc;
    }
  else if (!sals.nelts)
    return GDB_RC_FAIL;
d4956 5
a4960 8
  if (!pending)
    {
      /* Make sure that all storage allocated to SALS gets freed.  */
      make_cleanup (xfree, sals.sals);
      
      /* Cleanup the addr_string array but not its contents. */
      make_cleanup (xfree, addr_string);
    }
d4987 1
a4987 2
  if (!pending)
    breakpoint_sals_to_pc (&sals, addr_start);
d4993 1
a4993 1
  if (!pending)
d4995 2
a4996 1
      for (i = 0; i < sals.nelts; i++)
d4998 24
a5021 2
	  char *tok = arg;
	  while (tok && *tok)
d5023 9
a5031 39
	      char *end_tok;
	      int toklen;
	      char *cond_start = NULL;
	      char *cond_end = NULL;
	      while (*tok == ' ' || *tok == '\t')
		tok++;
	      
	      end_tok = tok;
	      
	      while (*end_tok != ' ' && *end_tok != '\t' && *end_tok != '\000')
		end_tok++;
	      
	      toklen = end_tok - tok;
	      
	      if (toklen >= 1 && strncmp (tok, "if", toklen) == 0)
		{
		  tok = cond_start = end_tok + 1;
		  cond[i] = parse_exp_1 (&tok, block_for_pc (sals.sals[i].pc), 
				         0);
		  make_cleanup (xfree, cond[i]);
		  cond_end = tok;
		  cond_string[i] = savestring (cond_start, 
				               cond_end - cond_start);
		  make_cleanup (xfree, cond_string[i]);
		}
	      else if (toklen >= 1 && strncmp (tok, "thread", toklen) == 0)
		{
		  char *tmptok;
		  
		  tok = end_tok + 1;
		  tmptok = tok;
		  thread = strtol (tok, &tok, 0);
		  if (tok == tmptok)
		    error ("Junk after thread keyword.");
		  if (!valid_thread_id (thread))
		    error ("Unknown thread %d\n", thread);
		}
	      else
		error ("Junk at end of arguments.");
d5033 2
a5035 6
      create_breakpoints (sals, addr_string, cond, cond_string,
			  hardwareflag ? bp_hardware_breakpoint 
			  : bp_breakpoint,
			  tempflag ? disp_del : disp_donttouch,
			  thread, ignore_count, from_tty,
			  pending_bp);
a5036 4
  else
    {
      struct symtab_and_line sal;
      struct breakpoint *b;
d5038 4
a5041 2
      sal.symtab = NULL;
      sal.pc = 0;
a5042 18
      make_cleanup (xfree, copy_arg);

      b = set_raw_breakpoint (sal, hardwareflag ? bp_hardware_breakpoint 
		              : bp_breakpoint);
      set_breakpoint_count (breakpoint_count + 1);
      b->number = breakpoint_count;
      b->cond = *cond;
      b->thread = thread;
      b->addr_string = *addr_string;
      b->cond_string = *cond_string;
      b->ignore_count = ignore_count;
      b->pending = 1;
      b->disposition = tempflag ? disp_del : disp_donttouch;
      b->from_tty = from_tty;
      b->flag = flag;
      mention (b);
    }
  
a5052 2

  return GDB_RC_OK;
d5089 1
a5089 1
  parse_breakpoint_sals (&address_end, &sals, &addr_string, 0);
d5153 1
a5153 2
		      args->thread, args->ignore_count, 0/*from-tty*/, 
		      NULL/*pending_bp*/);
d5245 1
a5245 1
	  break_command_1 (addr_string, flag, from_tty, NULL);
d5328 1
a5328 1
	  break_command_1 (break_string, flag, from_tty, NULL);
d5395 1
a5395 1
  break_command_1 (arg, 0, from_tty, NULL);
d5413 1
a5413 1
  break_command_1 (arg, BP_TEMPFLAG, from_tty, NULL);
d5425 1
a5425 1
  break_command_1 (arg, BP_HARDWAREFLAG, from_tty, NULL);
d5431 1
a5431 1
  break_command_1 (arg, (BP_TEMPFLAG | BP_HARDWAREFLAG), from_tty, NULL);
d5472 1
a5472 1
    break_command_1 (arg, 0, from_tty, NULL);
d5504 1
a5504 1
    break_command_1 (arg, 0, from_tty, NULL);
d5904 24
d6042 4
d6079 1
d6081 1
d6103 1
d6105 1
d6189 1
d6438 1
d6440 3
d6446 1
d6448 3
d6454 1
d6456 3
d6462 1
d6464 3
d6470 1
d6472 3
d6508 24
a6787 1
	    && !b->pending
a6992 4

      if (b->pending)
	break;

d7011 1
a7011 6
		{
		  xfree (b->cond);
		  /* Avoid re-freeing b->exp if an error during the call
		     to parse_exp_1.  */
		  b->cond = NULL;
		}
d7079 1
a7079 6
	{
	  xfree (b->exp);
	  /* Avoid re-freeing b->exp if an error during the call to
             parse_expression.  */
	  b->exp = NULL;
	}
d7084 1
a7084 6
	{
	  value_free (b->val);
	  /* Avoid re-freeing b->val if an error during the call to
             evaluate_expression.  */
	  b->val = NULL;
	}
d7094 1
a7094 6
	    {
	      xfree (b->cond);
	      /* Avoid re-freeing b->exp if an error during the call
		 to parse_exp_1.  */
	      b->cond = NULL;
	    }
d7388 16
a7403 9
  if (bpt->pending)
    {
      if (bpt->enable_state != bp_enabled)
	{
	  /* When enabling a pending breakpoint, we need to check if the breakpoint
	     is resolvable since shared libraries could have been loaded
	     after the breakpoint was disabled.  */
	  breakpoints_changed ();
 	  if (resolve_pending_breakpoint (bpt) == GDB_RC_OK)
d7405 4
a7408 1
	      delete_breakpoint (bpt);
d7411 4
a7414 2
	  bpt->enable_state = bp_enabled;
	  bpt->disposition = disposition;
d7416 10
a7425 12
    }
  else  /* Not a pending breakpoint.  */
    {
      if (bpt->enable_state != bp_permanent)
	bpt->enable_state = bp_enabled;
      bpt->disposition = disposition;
      check_duplicates (bpt);
      breakpoints_changed ();
      
      if (bpt->type == bp_watchpoint || 
	  bpt->type == bp_hardware_watchpoint ||
	  bpt->type == bp_read_watchpoint || 
d7428 10
a7437 28
	  if (bpt->exp_valid_block != NULL)
	    {
	      struct frame_info *fr =
		fr = frame_find_by_id (bpt->watchpoint_frame);
	      if (fr == NULL)
		{
		  printf_filtered ("\
Cannot enable watchpoint %d because the block in which its expression\n\
is valid is not currently in scope.\n", bpt->number);
		  bpt->enable_state = bp_disabled;
		  return;
		}
	      
	      save_selected_frame = deprecated_selected_frame;
	      save_selected_frame_level = frame_relative_level (deprecated_selected_frame);
	      select_frame (fr);
	    }
	  
	  value_free (bpt->val);
	  mark = value_mark ();
	  bpt->val = evaluate_expression (bpt->exp);
	  release_value (bpt->val);
	  if (VALUE_LAZY (bpt->val))
	    value_fetch_lazy (bpt->val);
	  
	  if (bpt->type == bp_hardware_watchpoint ||
	      bpt->type == bp_read_watchpoint ||
	      bpt->type == bp_access_watchpoint)
d7439 1
a7439 12
	      int i = hw_watchpoint_used_count (bpt->type, &other_type_used);
	      int mem_cnt = can_use_hardware_watchpoint (bpt->val);
	      
	      /* Hack around 'unused var' error for some targets here */
	      (void) mem_cnt, i;
	      target_resources_ok = TARGET_CAN_USE_HARDWARE_WATCHPOINT (
									bpt->type, i + mem_cnt, other_type_used);
	      /* we can consider of type is bp_hardware_watchpoint, convert to 
		 bp_watchpoint in the following condition */
	      if (target_resources_ok < 0)
		{
		  printf_filtered ("\
d7442 3
a7444 4
		  bpt->enable_state = bp_disabled;
		  value_free_to_mark (mark);
		  return;
		}
a7445 4
	  
	  if (save_selected_frame_level >= 0)
	    select_frame (save_selected_frame);
	  value_free_to_mark (mark);
d7447 4
a7451 1

@


1.89
log
@        * source.c: Make global variables current_source_symtab and
        current_source_line static.
        (list_command): Moved to cli/cli-cmds.c.
        (ambiguous_line_spec): Moved to cli/cli-cmds.c.
        (get_first_line_listed): New accessor function.
        (get_lines_to_list): New accessor function.
        (get_current_source_symtab_and_line): New function. Retrieves the
        position in the source code that we consider current.
        (get_current_or_default_source_symtab_and_line): New function.
        Like the above but attempts to determine a default position if one
        is not currently defined.
        (set_current_source_symtab_and_line): New function. Sets the source
        code position considered current and returns the previously set one.
        (clear_current_source_symtab_and_line): Reset stored information about
        a current source line.
        (_initialize_source): Remove registration for the "list" command and
        its alias.
        * source.h: Add declarations for the new functions above.
        * symtab.h: Remove declarations for the global variables mentioned
        above.
        * breakpoint.c (parse_breakpoint_sals): Use accessor functions to
        obtain current source line.
        * linespec.c (decode_line_1): Ditto.
        * macroscope.c (default_macro_scope): Ditto.
        * scm-lang.c (scm_unpac): Ditto.
        * stack.c (print_frame_info_base): Ditto.
        * symfile.c (clear_symtab_users): Ditto.
        * symtab.c (decode_line_spec): Ditto.
        * cli/cli-cmds.c (list_command): Moved here from source.c.
        (ambiguous_line_spec): Moved here from source.c.
        (_init_cli_cmds): Add definition for "list" and its alias.
        * Makefile.in: Update dependencies.
@
text
@d4623 1
a4623 2
      struct symtab_and_line cursal = 
      			get_current_or_default_source_symtab_and_line ();
@


1.89.2.1
log
@2002-09-23  David Carlton  <carlton@@math.stanford.edu>

	* dictionary.c (struct dict_vtbl): 'add_symbol' field.
	(add_symbol_generic): New function.
	(free_obstack): New function.
	(dict_create_hashed): New function.
	(lookup_hashed): New function.
	(iterator_first_hashed): New function.
	(iterator_hashed_advance): New function.
	(iterator_next_hashed): New function.
	* dictionary.h: A few more declarations.
	* mdebugread.c (parse_symbol): Use dict_iterator when finding
	parameters.
	* Makefile.in (valops.o): Depend on dictionary_h.
	* valops.c (value_of_this): Check empty block via dict_empty.
	#include "dictionary.h"
	* symfile.c (free_named_symtabs): Check empty block via dict_empty.
	* dictionary.h: Declare dict_empty.
	* symmisc.c (dump_symtab): Don't print out number of
	symbols/buckets.
	* printcmd.c (print_frame_args): Delete assertion that block isn't
	a hashtable.
	* symmisc.c (free_symtab_block): Update to use dictionary
	methods.
	* symtab.h (struct symtab): Comment on free_contents.
	* jv-lang.c (get_java_class_symtab): Set class_symtab->free_code.
	* mdebugread.c (add_symbol): Delete 'nsyms' variable.
	(fixup_sigtramp): Add symbol via dict_add_symbol_block.
	* Makefile.in (mi-cmd-stack.o): Depend on dictionary_h.
	* ada-lang.c (symtab_for_sym): Update uses of ALL_BLOCK_SYMBOLS.
	(ada_add_block_symbols): Ditto.
	(debug_print_block): Ditto.
	(fill_in_ada_prototype): Ditto.
	* breakpoint.c (get_catch_sals): Ditto.
	* coffread.c (patch_opaque_types): Ditto.
	* tracepoint.c (add_local_symbols): Ditto.
	(scope_info): Ditto.
	* symtab.c (find_pc_sect_symtab): Ditto.
	(search_symbols): Ditto.
	(make_symbol_completion_list): Ditto.
	(find_addr_symbol): Ditto.
	(make_file_symbol_completion_list): Ditto.
	(make_symbol_overload_list): Ditto.
	* symmisc.c (dump_symtab): Ditto.
	* stack.c (print_block_frame_locals): Ditto.
	(print_block_frame_labels): Ditto.
	(print_frame_arg_vars): Ditto.
	* printcmd.c (print_frame_args): Ditto.
	* objfiles.c (objfile_relocate): Ditto.
	* mdebugread.c (mylookup_symbol): Ditto.
	* Makefile.in (ada-lang.o): Depend on dictionary_h.
	* Makefile.in (tracepoint.o): Ditto.
	* Makefile.in (symmisc.o): Ditto.
	* Makefile.in (stack.o): Ditto.
	* Makefile.in (printcmd.o): Ditto.
	* Makefile.in (objfiles.o): Ditto.
	* Makefile.in (coffread.o): Ditto.
	* Makefile.in (breakpoint.o): Ditto.
	* ada-lang.c: #include "dictionary.h"
	* tracepoint.c: Ditto.
	* symmisc.c: Ditto.
	* stack.c: Ditto.
	* printcmd.c: Ditto.
	* objfiles.c: Ditto.
	* coffread.c: Ditto.
	* breakpoint.c: Ditto.
	* symtab.h: Comment out ALL_BLOCK_SYMBOLS.  (Moved to
	dictionary.h.)
	* dictionary.c: Dict_iterator accessor macros.
	(struct dict_vtbl): Add iterator_first, iterator_next.
	(dict_iterator_first): New function.
	(dict_iterator_next): New function.
	(iterator_first_block): New function.
	(iterator_next_block): New function.
	(iterator_block_hashed_advance): New function.
	* dictionary.h: Add dict_iterator stuff.
	* Makefile.in (symtab.o): Depend on dictionary_h.
	* symtab.c: #include "dictionary.h"
	* dictionary.c: Move down #include "dictionary.h", for now...
	(free_block): Rename from dict_free_block.
	(struct dict_vtbl): Add LOOKUP member.
	(dict_lookup): New function.
	(lookup_block): New function.
	* dictionary.h: Declare dict_lookup.
	* symtab.c (lookup_block_symbol): Use dict_lookup.

2002-09-23  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c (list_args_or_locals): Update use of
	ALL_BLOCK_SYMBOLS.
	#include "dictionary.h"
@
text
@a49 1
#include "dictionary.h"
d5806 1
a5806 1
	      struct dict_iterator iter;
d5809 1
a5809 1
	      ALL_BLOCK_SYMBOLS (b, iter, sym)
@


1.89.2.2
log
@Merge with mainline; tag is carlton_dictionary-20020927-merge
@
text
@d4624 2
a4625 1
      struct symtab_and_line cursal = get_current_source_symtab_and_line ();
@


1.89.2.3
log
@2002-10-18  David Carlton  <carlton@@math.stanford.edu>

	* Makefile.in (block_h): New variable.
	Updated dependencies to reflect it.
	* parse.c (parse_exp_1): Use BLOCK_START.
	#include "block.h"
	* p-exp.tab.c: Regenerated.
	* m2-exp.tab.c: Ditto.
	* jv-exp.tab.c: Ditto.
	* f-exp.tab.c: Ditto.
	* c-exp.tab.c: Ditto.
	* ada-exp.tab.c: Ditto.
	* ada-lang.c: #include "block.h"
	* p-exp.y: Ditto.
	* objc-exp.y: Ditto.
	* m2-exp.y: Ditto.
	* jv-exp.y: Ditto.
	* f-exp.y: Ditto.
	* c-exp.y: Ditto.
	* ada-exp.y: Ditto.
	* values.c: Ditto.
	* valops.c: Ditto.
	* tracepoint.c: Ditto.
	* symtab.c: Ditto.
	* symmisc.c: Ditto.
	* symfile.c: Ditto.
	* stack.c: Ditto.
	* printcmd.c: Ditto.
	* objfiles.c: Ditto.
	* objc-lang.c: Ditto.
	* nlmread.c: Ditto.
	* mips-tdep.c: Ditto.
	* mdebugread.c: Ditto.
	* linespec.c: Ditto.
	* jv-lang.c: Ditto.
	* infcmd.c: Ditto.
	* f-valprint.c: Ditto.
	* findvar.c: Ditto.
	* expprint.c: Ditto.
	* coffread.c: Ditto.
	* buildsym.c: Ditto.
	* breakpoint.c: Ditto.
	* blockframe.c: Ditto.
	* ax-gdb.c: Ditto.
	* alpha-tdep.c: Ditto.
	* block.h: New file.
	* symtab.h: Moved struct block, struct blockvector, and related
	macros and function declarations to block.h.
	* dwarf2read.c (process_die): Set processing_has_namespace_info if
	we run into DW_TAG_namespace, DW_TAG_imported_declaration, or
	DW_TAG_imported_module.
	New variable current_namespace.
	(psymtab_to_symtab_1): Set current_namespace to "".
	(dwarf2_name): New function.
	(dwarf2_add_member_fn): Get name via dwarf2_name.
	(read_typedef): Ditto.
	(read_file_scope): Ditto.
	(dwarf2_add_field): Ditto.
	(read_structure_scope): Ditto.
	(read_enumeration): Ditto.
	(dwarf2_extension): New function.
	(read_namespace): Set current_namespace correctly; also, if we're
	entering an anonymous namespace, add an appropriate using
	directive.
	* buildsym.c (start_symtab): Reset processing_has_namespace_info
	to 0.
	(add_symbol_to_list): Only scan for anonymous namespaces if
	!processing_has_namespace_info.
	* buildsym.h: Add new flag processing_has_namespace_info.

2002-10-18  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c: #include "block.h"
@
text
@a26 1
#include "block.h"
@


1.89.2.4
log
@2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_block): New function.
	(lookup_symbol_aux_local): Call lookup_symbol_aux_block.
	(lookup_symbol_aux): Ditto.

	* Merge from mainline; tag is carlton_dictionary-20021025-merge.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* cp-support.c: Add comment to demangled name pitfalls.
	* symtab.c (lookup_transparent_type): Add FIXME comment at
	beginning.

2002-10-23  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c: Delete cplusplus_hint.
	Delete prototype for find_template_name_end.
	* dwarf2read.c (scan_partial_symbols): Add in a gdb_assert from a
	later version of my namespace_minimal patch.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Change all of the setup_xfail tests that
	I added into setup_kfails.
@
text
@d3889 1
a3889 1
  init_sal (&sal);		/* initialize to zeroes */
d4209 1
a4209 1
  init_sal (&sal);
d4248 1
a4248 1
  init_sal (&sal);
d4605 1
a4605 1
	  init_sal (&sal);		/* initialize to zeroes */
d4623 1
a4623 3
         leaving default_breakpoint_* alone.  
         ObjC: However, don't match an Objective-C method name which
         may have a '+' or '-' succeeded by a '[' */
d4629 1
a4629 2
 	      || ((strchr ("+-", (*address)[0]) != NULL)
 		  && ((*address)[1] != '['))))
d5298 1
a5298 1
  init_sal (&sal);		/* initialize to zeroes */
d6264 1
a6264 1
  init_sal (&sal);		/* initialize to zeroes */
d6535 1
a6535 1
      init_sal (&sal);		/* initialize to zeroes */
@


1.89.2.5
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d1693 1
a1693 1
deprecated_frame_in_dummy (struct frame_info *frame)
@


1.89.2.6
log
@2002-11-27  David Carlton  <carlton@@math.stanford.edu>

	* dwarf2read.c (add_partial_enumeration): New function.
	(scan_partial_symbols): Call add_partial_enumeration.
	(locate_pdi_sibling): New function.
	(scan_partial_symbols): Call locate_pdi_sibling.  Get rid of
	nesting_level.
	(pdi_needs_namespace): New function.
	(add_partial_symbol): Add 'namespace' arg; calculate full name
	when appropriate.
	(scan_partial_symbols): Update calls to add_partial_symbol.
	(add_partial_enumeration): Ditto.
	(read_enumeration): Add processing_current_prefix to name when
	appropriate.
	(new_symbol): Set names of enumerators and typedefs appropriately
	if processing_has_namespace_info.
	* symtab.c (lookup_symbol_namespace): Rename 'namespace' argument
	to 'namespace_name'.
	* symtab.h: Ditto.
	* symtab.c (lookup_symbol_namespace): Delete FIXME comments; add a
	new one.
	(lookup_symbol_aux_file): New function.
	(lookup_symbol_aux): Delete FIXME comment.
	(lookup_symbol_aux): Don't search static block explicitly; delete
	FIXME comments.
	* valops.c (value_namespace_elt): Update call to
	lookup_symbol_namespace.
	* symtab.h: Update declaration for lookup_symbol_namespace.
	* symtab.c (lookup_symbol_namespace): Delete 'using' argument and
	add 'block' argument; get using directives via iterators.
	(lookup_symbol_aux_using_loop): Delete 'using' argument and add
	'block' argument.
	(lookup_symbol_aux_using): Don't calculate using directives.
	* block.c (block_using_iterator_first): New function.
	(block_using_iterator_next): Ditto.
	* block.h: Add comment.
	(struct block_using_iterator): New struct.
	Declare block_using_iterator_first, block_using_iterator_next.

2002-11-26  David Carlton  <carlton@@math.stanford.edu>

	* dwarf2read.c (read_structure_scope): Set type name and
	processing_current_prefix appropriately.
	(new_symbol): Make sure that, in symbols associated to class
	types, the name includes appropriate namespaces.
	* buildsym.h: Rename processing_current_namespace to
	processing_current_prefix.
	* buildsym.c (finish_block): Ditto.
	* dwarf2read.c (psymtab_to_symtab_1): Ditto.
	(read_namespace): Ditto.  Also rename previous_namespace to
	previous_prefix.

	Now come a thousand and one const correctness fixes:
	* p-typeprint.c (pascal_print_type): Const.
	(pascal_type_print_method_args): Const.
	* p-lang.h: Const.
	* m2-typeprint.c (m2_print_type): Const.
	* valops.c (hand_function_call): Const.
	* jv-lang.c (java_primitive_type_from_name): Const.
	* jv-lang.h: Const.
	* jv-typeprint.c (java_print_type): Const.
	* language.c: (unk_lang_print_type): Const.
	* stack.c (frame_info): Const.
	* linespec.c (find_methods): Const.
	(find_method_name): Const
	* f-lang.h: Const.
	* f-typeprint.c (f_print_type): Const.
	* c-typeprint.c (c_print_type): Const.
	* c-lang.h: Const.
	* gdbtypes.h: Const.
	* gdbtypes.c (lookup_primitive_typename): Const.
	* stack.c (print_frame): Const.
	(func_command): Delete pointless cast.
	* linespec.c (find_method_name): Const.
	* language.h: Const.
	* symfile.c (compare_psymbols): Const.
	* symtab.c (completion_list_add_name): Const.
	* breakpoint.c (break_at_finish_at_depth_command_1): Remove
	useless cast.
	(break_at_finish_command_1): Ditto.
	* typeprint.c (type_print): Const.
	* symtab.h: Const.
	* symtab.c (gdb_mangle_name): Const.
	(symbol_init_demangled_name): Const.
	(symbol_demangled_name): Const.
	* defs.h: Const.
	* printcmd.c (build_address_symbolic): Const.
	* valops.c (search_struct_method): Const.
	* cp-valprint.c (cp_is_vtbl_ptr_type): Const.
	(cp_print_value): Const.
	(cp_print_class_member): Const.
	* c-typeprint.c (cp_type_print_derivation_info): Const.
	(c_type_print_varspec_prefix): Const.
	(c_type_print_base): Const.
	* p-valprint.c (pascal_object_is_vtbl_ptr_type): Const.
	(pascal_object_print_value): Const.
	(pascal_object_print_class_member): Const.
	* p-typeprint.c (pascal_type_print_derivation_info): Const.
	(pascal_type_print_varspec_prefix): Const.
	(pascal_type_print_base): Const.
	* jv-typeprint.c (java_type_print_base): Const.
	* jv-lang.h (java_demangle_type_signature): Const.
	* jv-lang.c (java_demangle_type_signature): Const.
	(java_demangled_signature_length): Const.
	(java_demangled_signature_copy): Const.
	* jv-typeprint.c (java_type_print_derivation_info): Const.
	* jv-valprint.c (java_value_print): Const.
	(java_print_value_fields): Const.
	* jv-lang.c (is_object_type): Const.
	(evaluate_subexp_java): Const.
	* stabsread.c (read_cpp_abbrev): Const.
	(complain_about_struct_wipeout): Const.
	(cleanup_undefined_types): Const.
	* gdbtypes.h: Const.
	* gdbtypes.c (add_name): Second arg const.
	(lookup_typename): Const.
	(lookup_unsigned_typename): Const.
	(lookup_signed_typename): Const.
	* linespec.c (find_methods): const char *class_name.
	* symtab.c (gdb_mangle_name): const char *newname.
	* valops.c (destructor_name_p): const char *dname.
	(search_struct_field): First arg const.
	* gdbtypes.c (check_typedef): const char *name (multiple places).
	(cfront_mangle_name): const char *newname.
	* gdbtypes.c (add_mangled_type): const char *tname.
	* valops.c (find_overload_match): const char *obj_type_name.
	* utils.c (gdb_print_host_address): Make first arg const.
	* defs.h: Declare first arg of gdb_print_host_address to be
	const.
	* valarith.c (find_size_for_pointer_math): const char *name.

2002-11-27  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/m-data.cc (main): Add marker comment.
	* gdb.c++/m-data.exp: Use marker comment instead of line numbers.
	* gdb.c++/m-data.cc: Delete superfluous namespace.
	* gdb.c++/m-static.cc: Ditto.
	* gdb.c++/m-static1.cc: Ditto.
	* carlton_runtest: Compare based on gdb.sum, not based on output.
	* carlton_runnamespace: Ditto.

2002-11-26  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Put tests for CClass.
	* gdb.c++/namespace.cc (C): Add CClass.
@
text
@d5008 1
a5008 1
      if (find_pc_partial_function (selected_pc, NULL, &low, &high))
d5090 1
a5090 1
      if (find_pc_partial_function (sal.pc, NULL, &low, &high))
@


1.89.2.7
log
@2002-12-20  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_minsyms): Don't call
	lookup_symbol_aux from within this.
	* values.c (value_static_field): lookup_symbol_linkage.
	(value_fn_field): lookup_symbol_linkage.
	* valops.c (value_struct_elt_for_reference): lookup_symbol_linkage.
	* blockframe.c (inside_main_func): lookup_symbol_linkage.
	* source.c (select_source_symtab): lookup_symbol_linkage.
	* nlmread.c (nlm_symfile_read): Call lookup_symbol_linkage.
	* nindy-tdep.c (nindy_frame_chain_valid): Call
	lookup_symbol_linkage.
	* linespec.c (count_methods): Call lookup_symbol_linkage.
	(add_matching_methods): Ditto.
	(add_constructors): Ditto.
	* hppa-tdep.c (find_stub_with_shl_get): Call
	lookup_symbol_linkage.  Delete symbol2.
	(initialize_hp_cxx_exception_support): Call lookup_symbol_linkage.
	* cli/cli-cmds.c (edit_command): SYMBOL_PRINT_NAME.
	(list_command): SYMBOL_PRINT_NAME.
	* valops.c (value_of_variable): SYMBOL_PRINT_NAME
	(hand_function_call): SYMBOL_PRINT_NAME.
	* typeprint.c (typedef_print): SYMBOL_PRINT_NAME.
	* tracepoint.c (tracepoints_info): SYMBOL_PRINT_NAME.
	* symtab.c (lookup_partial_symbol): SYMBOL_BEST_NAME.
	(compare_search_syms): SYMBOL_BEST_NAME.
	(print_symbol_info): SYMBOL_PRINT_NAME.
	(print_msymbol_info): SYMBOL_PRINT_NAME.
	(rbreak_command): SYMBOL_PRINT_NAME.
	* symmisc.c (print_symbol): SYMBOL_PRINT_NAME.
	* stack.c (print_frame): SYMBOL_PRINT_NAME.
	(frame_info): SYMBOL_PRINT_NAME.
	(print_block_frame_locals): SYMBOL_PRINT_NAME.
	(print_block_frame_labels): SYMBOL_PRINT_NAME.
	(print_frame_arg_vars): SYMBOL_PRINT_NAME.
	(return_command): SYMBOL_PRINT_NAME.
	* stabsread.c (define_symbol): SYMBOL_PRINT_NAME.
	* p-valprint.c (pascal_val_print): SYMBOL_PRINT_NAME.
	* printcmd.c (build_address_symbolic): SYMBOL_PRINT_NAME.
	(sym_info): SYMBOL_PRINT_NAME.
	(print_frame_args): SYMBOL_PRINT_NAME.
	* objc-lang.c (compare_selectors): SYMBOL_BEST_NAME.
	(compare_classes): SYMBOL_BEST_NAME.
	* maint.c (maintenance_translate_address): SYMBOL_PRINT_NAME.
	* linespec.c (find_method): SYMBOL_PRINT_NAME.
	(select_symbols): SYMBOL_PRINT_NAME.
	* infcmd.c (jump_command): SYMBOL_PRINT_NAME.
	* findvar.c (locate_var_value): SYMBOL_PRINT_NAME.
	* expprint.c (print_subexp): SYMBOL_PRINT_NAME.
	* c-valprint.c (c_val_print): SYMBOL_PRINT_NAME.
	* buildsym.c (finish_block): SYMBOL_PRINT_NAME.
	* breakpoint.c (print_one_breakpoint): SYMBOL_PRINT_NAME.
	* ax-gdb.c (gen_var_ref): SYMBOL_PRINT_NAME.
	* ada-typeprint.c (ada_typedef_print): SYMBOL_PRINT_NAME.
	* ada-lang.c (user_select_syms): Use SYMBOL_PRINT_NAME instead of
	SYMBOL_SOURCE_NAME.
	(user_select_syms):
	(ada_finish_decode_line_1): Use SYMBOL_BEST_NAME instead of
	SYMBOL_SOURCE_NAME.
	* symtab.h (SYMBOL_PRINT_NAME): Rename from SYMBOL_SOURCE_NAME.
	* symfile.c (compare_symbols): Use SYMBOL_BEST_NAME, not
	SYMBOL_SOURCE_NAME.
	(compare_psymbols): Ditto.
	* symtab.c (lookup_symbol_linkage): New function.
	* symtab.h: Declare lookup_symbol_linkage.
	* c-valprint.c (c_val_print): Call lookup_symbol_minsym.
	* symtab.c (lookup_symbol_aux_minsyms): Call minsym_static.
	* minsyms.c (minsym_static): New function.
	* symtab.h: Declare minsym_static.
	* symtab.c (lookup_symbol_minsym): New function.
	(search_symbols): Call lookup_symbol_minsym instead of
	lookup_symbol.
	(lookup_symbol_namespace): Don't take apart NAME.
	* symtab.h: Declare lookup_symbol_minsym.
	* printcmd.c (build_address_symbolic): Don't use old version of
	SYMBOL_LINKAGE_NAME.
	* symtab.c (lookup_block_symbol): Change mangled names to linkage
	name, and use SYMBOL_LINKAGE_NAME as appropriate.
	* symtab.h (SYMBOL_LINKAGE_NAME): New macro, with a different
	meaning from the old macro of the same name.  Also, add comments
	about proper uses of names.
@
text
@d3393 1
a3393 1
				   SYMBOL_PRINT_NAME (sym));
@


1.89.2.8
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@a51 1
#include "gdb_assert.h"
d956 2
a957 2
	saved_frame = deprecated_selected_frame;
	saved_level = frame_relative_level (deprecated_selected_frame);
d1053 2
a1054 2
	if ((saved_frame != deprecated_selected_frame) ||
	    (saved_level != frame_relative_level (deprecated_selected_frame)))
d1687 3
a1689 3
   DEPRECATED_PC_IN_CALL_DUMMY because figuring out the saved SP would
   take too much time, at least using get_saved_register on the 68k.
   This means that for this function to work right a port must use the
d1700 2
a1701 4
  /* This function is used by two files: get_frame_type(), after first
     checking that !DEPRECATED_USE_GENERIC_DUMMY_FRAMES; and
     sparc-tdep.c, which doesn't yet use generic dummy frames anyway.  */
  gdb_assert (!DEPRECATED_USE_GENERIC_DUMMY_FRAMES);
d1706 1
a1706 1
	&& frame_id_eq (b->frame_id, get_frame_id (frame))
d1709 1
a1709 1
	&& (get_frame_pc (frame)
d1711 2
a1712 2
		- SIZEOF_CALL_DUMMY_WORDS / sizeof (LONGEST) * REGISTER_SIZE))
	&& get_frame_pc (frame) <= b->address)
d2575 2
a2576 2
	&& !inferior_has_forked (PIDGET (inferior_ptid),
				 &b->forked_inferior_pid))
d2580 2
a2581 2
	&& !inferior_has_vforked (PIDGET (inferior_ptid),
				  &b->forked_inferior_pid))
d2585 1
a2585 1
	&& !inferior_has_execd (PIDGET (inferior_ptid), &b->exec_pathname))
d2729 2
a2730 2
    if (frame_id_p (b->frame_id)
	&& !frame_id_eq (b->frame_id, get_frame_id (get_current_frame ())))
d3419 1
a3419 1
  if (frame_id_p (b->frame_id))
d3423 1
a3423 3
      /* FIXME: cagney/2002-12-01: Shouldn't be poeking around inside
         the frame ID.  */
      ui_out_field_core_addr (uiout, "frame", b->frame_id.base);
d3844 1
a3844 1
  b->frame_id = null_frame_id;
d4012 1
d4018 2
a4019 1
  xasprintf (&b->addr_string, "*0x%s", paddr (b->address));
d4312 1
a4312 1
set_longjmp_resume_breakpoint (CORE_ADDR pc, struct frame_id frame_id)
d4321 4
a4324 1
      b->frame_id = frame_id;
d4376 1
a4376 1
set_momentary_breakpoint (struct symtab_and_line sal, struct frame_id frame_id,
d4383 1
a4383 1
  b->frame_id = frame_id;
d4575 1
a4575 6
	if (addr_string[i])
	  b->addr_string = addr_string[i];
	else
	  /* addr_string has to be used or breakpoint_re_set will delete
	     me.  */
	  xasprintf (&b->addr_string, "*0x%s", paddr (b->address));
d4965 1
a4965 1
	  if (deprecated_selected_frame)
d4967 1
a4967 1
	      selected_pc = get_frame_pc (deprecated_selected_frame);
d4996 1
a4996 1
	selected_pc = get_frame_pc (frame);
d5043 1
a5043 1
	  if (deprecated_selected_frame)
d5046 1
a5046 2
	      sprintf (addr_string, "*0x%s",
		       paddr_nz (get_frame_pc (deprecated_selected_frame)));
d5402 1
a5402 1
      b->watchpoint_frame = get_frame_id (frame);
d5426 1
a5426 1
	  scope_breakpoint->frame_id = get_frame_id (prev_frame);
d5585 1
a5585 1
  struct frame_info *prev_frame = get_prev_frame (deprecated_selected_frame);
d5614 1
a5614 3
  breakpoint = 
    set_momentary_breakpoint (sal,get_frame_id (deprecated_selected_frame),
			      bp_until);
d5646 3
a5648 4
      sal = find_pc_line (get_frame_pc (prev_frame), 0);
      sal.pc = get_frame_pc (prev_frame);
      breakpoint = set_momentary_breakpoint (sal, get_frame_id (prev_frame),
					     bp_until);
d5772 1
a5772 1
  if (deprecated_selected_frame == NULL)
d5774 2
a5775 2
  block = get_frame_block (deprecated_selected_frame, 0);
  pc = get_frame_pc (deprecated_selected_frame);
d7370 2
a7371 2
	  save_selected_frame = deprecated_selected_frame;
	  save_selected_frame_level = frame_relative_level (deprecated_selected_frame);
@


1.89.2.9
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d4 1
a4 1
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003 Free Software
d78 1
a78 1
static int breakpoint_re_set_one (void *);
d113 1
a113 1
static int breakpoint_cond_eval (void *);
d115 1
a115 1
static void cleanup_executing_breakpoints (void *);
d145 1
a145 1
static int watchpoint_check (void *);
d147 1
a147 1
static int cover_target_enable_exception_callback (void *);
d740 2
a741 3
    /* Permanent breakpoints cannot be inserted or removed.  Disabled
       breakpoints should not be inserted.  */
    if (b->enable_state != bp_enabled)
a742 1

d764 3
d885 3
d945 1
d1064 1
d1249 2
a1250 2
       valid code address on some platforms (like the OBSOLETE mn10200
       and mn10300 simulators).  We shouldn't assign any special
d1927 1
a1927 1
cleanup_executing_breakpoints (void *ignore)
d2013 1
a2013 1
  struct cleanup *old_chain, *ui_out_chain;
d2174 1
a2174 1
	  ui_out_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "value");
d2181 1
a2181 1
	  do_cleanups (ui_out_chain);
d2194 1
a2194 1
      ui_out_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "value");
d2198 1
a2198 1
      do_cleanups (ui_out_chain);
d2210 1
a2210 1
	  ui_out_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "value");
d2223 1
a2223 1
	  ui_out_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "value");
d2228 1
a2228 1
      do_cleanups (ui_out_chain);
d2342 1
a2342 1
breakpoint_cond_eval (void *exp)
d2382 1
a2382 1
watchpoint_check (void *p)
a3239 1
  struct cleanup *bkpt_chain;
d3242 1
a3242 1
  bkpt_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "bkpt");
a3479 2
      struct cleanup *script_chain;

d3481 1
a3481 1
      script_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "script");
d3483 1
a3483 1
      do_cleanups (script_chain);
d3485 1
a3485 1
  do_cleanups (bkpt_chain);
a3552 1
  struct cleanup *bkpttbl_chain;
d3565 1
a3565 3
    bkpttbl_chain 
      = make_cleanup_ui_out_table_begin_end (uiout, 6, nr_printable_breakpoints,
                                             "BreakpointTable");
d3567 1
a3567 3
    bkpttbl_chain 
      = make_cleanup_ui_out_table_begin_end (uiout, 5, nr_printable_breakpoints,
                                             "BreakpointTable");
d3609 1
a3609 1
  do_cleanups (bkpttbl_chain);
d4401 1
a4401 1
  struct cleanup *old_chain, *ui_out_chain;
d4423 1
a4423 1
      ui_out_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "wpt");
d4428 1
a4428 1
      do_cleanups (ui_out_chain);
d4432 1
a4432 1
      ui_out_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "wpt");
d4437 1
a4437 1
      do_cleanups (ui_out_chain);
d4441 1
a4441 1
      ui_out_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "hw-rwpt");
d4446 1
a4446 1
      do_cleanups (ui_out_chain);
d4450 1
a4450 1
      ui_out_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "hw-awpt");
d4455 1
a4455 1
      do_cleanups (ui_out_chain);
d5587 1
a5587 1
until_break_command (char *arg, int from_tty, int anywhere)
d5620 3
a5622 10
  if (anywhere)
    /* If the user told us to continue until a specified location,
       we don't specify a frame at which we need to stop.  */
    breakpoint = set_momentary_breakpoint (sal, null_frame_id, bp_until);
  else
    /* Otherwise, specify the current frame, because we want to stop only
       at the very same frame.  */
    breakpoint = set_momentary_breakpoint (sal,
					   get_frame_id (deprecated_selected_frame),
					   bp_until);
d5650 2
a5651 2
  /* Keep within the current frame, or in frames called by the current
     one.  */
d5670 1
a5670 1

d6236 1
a6236 1
cover_target_enable_exception_callback (void *arg)
d6913 1
a6913 1
breakpoint_re_set_one (void *bint)
d7054 1
a7054 1
      if (VALUE_LAZY (b->val) && b->enable_state == bp_enabled)
@


1.89.2.10
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d27 1
a52 1
#include "block.h"
d5833 1
a5833 1
		  if (STREQ (DEPRECATED_SYMBOL_NAME (sym), "default"))
@


1.89.2.11
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d84 4
d1683 1
a1683 1
   take too much time, at least using frame_register() on the 68k.
d1692 3
a1819 5
      if (bs->commands != NULL)
	tmp->commands = copy_command_lines (bs->commands);
      if (bs->old_val != NULL)
	tmp->old_val = value_copy (bs->old_val);

d2762 1
a2764 1
	    bs->commands = b->commands;
a2771 1
	    bs->commands = copy_command_lines (bs->commands);
d3423 1
a3423 1
      ui_out_field_core_addr (uiout, "frame", b->frame_id.stack_addr);
d5704 181
d6222 11
d6234 5
a6238 1
  warning ("Unsupported with this platform/compiler combination.");
d6256 105
@


1.89.2.12
log
@2003-04-30  David Carlton  <carlton@@bactrian.org>

	* cp-namespace.c (get_namespace_objfile): Copy the namespace
	objfile's name.

	* block.h (ALL_BLOCK_SYMBOLS): Move here from dictionary.h.
	* dictionary.c: Sync up with mainline version I just posted.
	Specifically, update some commments, and:
	(dict_create_hashed): Fiddle with nsyms updating.
	(dict_create_linear): Ditto.
	(dict_lookup): Delete.
	(iterator_next_hashed): Delete FIXME comment.
	(iter_name_first_hashed): Replace 'sym' by 'sym != NULL'.
	(iter_name_next_hashed): Replate 'next' by 'next != NULL'.
	* dictionary.h: Sync up with mainline version I just posted: add
	inclusion guards, delete declaration of dict_lookup, delete
	ALL_BLOCK_SYMBOLs.

	* Merge with mainline; tag is carlton_dictionary-20030430-merge.
@
text
@d2275 2
a2276 7
      /* Normal case.  Call the breakpoint's print_it method, or
	 print_it_typical.  */
      if (bs->breakpoint_at != NULL && bs->breakpoint_at->ops != NULL
	  && bs->breakpoint_at->ops->print_it != NULL)
	return bs->breakpoint_at->ops->print_it (bs->breakpoint_at);
      else
	return print_it_typical (bs);
a2277 1

d3269 6
d3276 64
a3339 9
  if (b->ops != NULL && b->ops->print_one != NULL)
    b->ops->print_one (b, last_addr);
  else
    switch (b->type)
      {
      case bp_none:
	internal_error (__FILE__, __LINE__,
			"print_one_breakpoint: bp_none encountered\n");
	break;
d3341 10
a3350 129
      case bp_watchpoint:
      case bp_hardware_watchpoint:
      case bp_read_watchpoint:
      case bp_access_watchpoint:
	/* Field 4, the address, is omitted (which makes the columns
	   not line up too nicely with the headers, but the effect
	   is relatively readable).  */
	if (addressprint)
	  ui_out_field_skip (uiout, "addr");
	annotate_field (5);
	print_expression (b->exp, stb->stream);
	ui_out_field_stream (uiout, "what", stb);
	break;

      case bp_catch_load:
      case bp_catch_unload:
	/* Field 4, the address, is omitted (which makes the columns
	   not line up too nicely with the headers, but the effect
	   is relatively readable).  */
	if (addressprint)
	  ui_out_field_skip (uiout, "addr");
	annotate_field (5);
	if (b->dll_pathname == NULL)
	  {
	    ui_out_field_string (uiout, "what", "<any library>");
	    ui_out_spaces (uiout, 1);
	  }
	else
	  {
	    ui_out_text (uiout, "library \"");
	    ui_out_field_string (uiout, "what", b->dll_pathname);
	    ui_out_text (uiout, "\" ");
	  }
	break;

      case bp_catch_fork:
      case bp_catch_vfork:
	/* Field 4, the address, is omitted (which makes the columns
	   not line up too nicely with the headers, but the effect
	   is relatively readable).  */
	if (addressprint)
	  ui_out_field_skip (uiout, "addr");
	annotate_field (5);
	if (b->forked_inferior_pid != 0)
	  {
	    ui_out_text (uiout, "process ");
	    ui_out_field_int (uiout, "what", b->forked_inferior_pid);
	    ui_out_spaces (uiout, 1);
	  }

      case bp_catch_exec:
	/* Field 4, the address, is omitted (which makes the columns
	   not line up too nicely with the headers, but the effect
	   is relatively readable).  */
	if (addressprint)
	  ui_out_field_skip (uiout, "addr");
	annotate_field (5);
	if (b->exec_pathname != NULL)
	  {
	    ui_out_text (uiout, "program \"");
	    ui_out_field_string (uiout, "what", b->exec_pathname);
	    ui_out_text (uiout, "\" ");
	  }
	break;

      case bp_catch_catch:
	/* Field 4, the address, is omitted (which makes the columns
	   not line up too nicely with the headers, but the effect
	   is relatively readable).  */
	if (addressprint)
	  ui_out_field_skip (uiout, "addr");
	annotate_field (5);
	ui_out_field_string (uiout, "what", "exception catch");
	ui_out_spaces (uiout, 1);
	break;

      case bp_catch_throw:
	/* Field 4, the address, is omitted (which makes the columns
	   not line up too nicely with the headers, but the effect
	   is relatively readable).  */
	if (addressprint)
	  ui_out_field_skip (uiout, "addr");
	annotate_field (5);
	ui_out_field_string (uiout, "what", "exception throw");
	ui_out_spaces (uiout, 1);
	break;

      case bp_breakpoint:
      case bp_hardware_breakpoint:
      case bp_until:
      case bp_finish:
      case bp_longjmp:
      case bp_longjmp_resume:
      case bp_step_resume:
      case bp_through_sigtramp:
      case bp_watchpoint_scope:
      case bp_call_dummy:
      case bp_shlib_event:
      case bp_thread_event:
      case bp_overlay_event:
	if (addressprint)
	  {
	    annotate_field (4);
	    ui_out_field_core_addr (uiout, "addr", b->address);
	  }
	annotate_field (5);
	*last_addr = b->address;
	if (b->source_file)
	  {
	    sym = find_pc_sect_function (b->address, b->section);
	    if (sym)
	      {
		ui_out_text (uiout, "in ");
		ui_out_field_string (uiout, "func",
				     SYMBOL_PRINT_NAME (sym));
		ui_out_wrap_hint (uiout, wrap_indent);
		ui_out_text (uiout, " at ");
	      }
	    ui_out_field_string (uiout, "file", b->source_file);
	    ui_out_text (uiout, ":");
	    ui_out_field_int (uiout, "line", b->line_number);
	  }
	else
	  {
	    print_address_symbolic (b->address, stb->stream, demangle, "");
	    ui_out_field_stream (uiout, "at", stb);
	  }
	break;
      }
d3352 54
a3854 1
  b->ops = NULL;
d4417 83
a4499 100
  if (b->ops != NULL && b->ops->print_mention != NULL)
    b->ops->print_mention (b);
  else
    switch (b->type)
      {
      case bp_none:
	printf_filtered ("(apparently deleted?) Eventpoint %d: ", b->number);
	break;
      case bp_watchpoint:
	ui_out_text (uiout, "Watchpoint ");
	ui_out_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "wpt");
	ui_out_field_int (uiout, "number", b->number);
	ui_out_text (uiout, ": ");
	print_expression (b->exp, stb->stream);
	ui_out_field_stream (uiout, "exp", stb);
	do_cleanups (ui_out_chain);
	break;
      case bp_hardware_watchpoint:
	ui_out_text (uiout, "Hardware watchpoint ");
	ui_out_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "wpt");
	ui_out_field_int (uiout, "number", b->number);
	ui_out_text (uiout, ": ");
	print_expression (b->exp, stb->stream);
	ui_out_field_stream (uiout, "exp", stb);
	do_cleanups (ui_out_chain);
	break;
      case bp_read_watchpoint:
	ui_out_text (uiout, "Hardware read watchpoint ");
	ui_out_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "hw-rwpt");
	ui_out_field_int (uiout, "number", b->number);
	ui_out_text (uiout, ": ");
	print_expression (b->exp, stb->stream);
	ui_out_field_stream (uiout, "exp", stb);
	do_cleanups (ui_out_chain);
	break;
      case bp_access_watchpoint:
	ui_out_text (uiout, "Hardware access (read/write) watchpoint ");
	ui_out_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "hw-awpt");
	ui_out_field_int (uiout, "number", b->number);
	ui_out_text (uiout, ": ");
	print_expression (b->exp, stb->stream);
	ui_out_field_stream (uiout, "exp", stb);
	do_cleanups (ui_out_chain);
	break;
      case bp_breakpoint:
	if (ui_out_is_mi_like_p (uiout))
	  {
	    say_where = 0;
	    break;
	  }
	printf_filtered ("Breakpoint %d", b->number);
	say_where = 1;
	break;
      case bp_hardware_breakpoint:
	if (ui_out_is_mi_like_p (uiout))
	  {
	    say_where = 0;
	    break;
	  }
	printf_filtered ("Hardware assisted breakpoint %d", b->number);
	say_where = 1;
	break;
      case bp_catch_load:
      case bp_catch_unload:
	printf_filtered ("Catchpoint %d (%s %s)",
			 b->number,
			 (b->type == bp_catch_load) ? "load" : "unload",
			 (b->dll_pathname != NULL) ? 
			 b->dll_pathname : "<any library>");
	break;
      case bp_catch_fork:
      case bp_catch_vfork:
	printf_filtered ("Catchpoint %d (%s)",
			 b->number,
			 (b->type == bp_catch_fork) ? "fork" : "vfork");
	break;
      case bp_catch_exec:
	printf_filtered ("Catchpoint %d (exec)",
			 b->number);
	break;
      case bp_catch_catch:
      case bp_catch_throw:
	printf_filtered ("Catchpoint %d (%s)",
			 b->number,
			 (b->type == bp_catch_catch) ? "catch" : "throw");
	break;

      case bp_until:
      case bp_finish:
      case bp_longjmp:
      case bp_longjmp_resume:
      case bp_step_resume:
      case bp_through_sigtramp:
      case bp_call_dummy:
      case bp_watchpoint_scope:
      case bp_shlib_event:
      case bp_thread_event:
      case bp_overlay_event:
	break;
      }
d4501 13
a6007 84
static enum print_stop_action
print_exception_catchpoint (struct breakpoint *b)
{
  annotate_catchpoint (b->number);

  if (strstr (b->addr_string, "throw") != NULL)
    printf_filtered ("\nCatchpoint %d (exception thrown)\n",
		     b->number);
  else
    printf_filtered ("\nCatchpoint %d (exception caught)\n",
		     b->number);

  return PRINT_SRC_AND_LOC;
}

static void
print_one_exception_catchpoint (struct breakpoint *b, CORE_ADDR *last_addr)
{
  if (addressprint)
    {
      annotate_field (4);
      ui_out_field_core_addr (uiout, "addr", b->address);
    }
  annotate_field (5);
  *last_addr = b->address;
  if (strstr (b->addr_string, "throw") != NULL)
    ui_out_field_string (uiout, "what", "exception throw");
  else
    ui_out_field_string (uiout, "what", "exception catch");
}

static void
print_mention_exception_catchpoint (struct breakpoint *b)
{
  if (strstr (b->addr_string, "throw") != NULL)
    printf_filtered ("Catchpoint %d (throw)", b->number);
  else
    printf_filtered ("Catchpoint %d (catch)", b->number);
}

static struct breakpoint_ops gnu_v3_exception_catchpoint_ops = {
  print_exception_catchpoint,
  print_one_exception_catchpoint,
  print_mention_exception_catchpoint
};

static int
handle_gnu_v3_exceptions (int tempflag, char *cond_string,
			  enum exception_event_kind ex_event, int from_tty)
{
  char *trigger_func_name, *nameptr;
  struct symtabs_and_lines sals;
  struct breakpoint *b;

  if (ex_event == EX_EVENT_CATCH)
    trigger_func_name = xstrdup ("__cxa_begin_catch");
  else
    trigger_func_name = xstrdup ("__cxa_throw");

  nameptr = trigger_func_name;
  sals = decode_line_1 (&nameptr, 1, NULL, 0, NULL);
  if (sals.nelts == 0)
    {
      free (trigger_func_name);
      return 0;
    }

  b = set_raw_breakpoint (sals.sals[0], bp_breakpoint);
  set_breakpoint_count (breakpoint_count + 1);
  b->number = breakpoint_count;
  b->cond = NULL;
  b->cond_string = (cond_string == NULL) ? 
    NULL : savestring (cond_string, strlen (cond_string));
  b->thread = -1;
  b->addr_string = trigger_func_name;
  b->enable_state = bp_enabled;
  b->disposition = tempflag ? disp_del : disp_donttouch;
  b->ops = &gnu_v3_exception_catchpoint_ops;

  free (sals.sals);
  mention (b);
  return 1;
}

a6026 3

  if (handle_gnu_v3_exceptions (tempflag, cond_string, ex_event, from_tty))
    return;
@


1.89.2.13
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d1701 1
a1701 1
		- DEPRECATED_SIZEOF_CALL_DUMMY_WORDS / sizeof (LONGEST) * DEPRECATED_REGISTER_SIZE))
d5468 1
a5468 1
    ((BYTE_SIZE) <= (DEPRECATED_REGISTER_SIZE))
@


1.89.2.14
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@a706 29
/* A wrapper function for inserting catchpoints.  */
int
insert_catchpoint (struct ui_out *uo, void *args)
{
  struct breakpoint *b = (struct breakpoint *) args;
  int val = -1;

  switch (b->type)
    {
    case bp_catch_fork:
      val = target_insert_fork_catchpoint (PIDGET (inferior_ptid));
      break;
    case bp_catch_vfork:
      val = target_insert_vfork_catchpoint (PIDGET (inferior_ptid));
      break;
    case bp_catch_exec:
      val = target_insert_exec_catchpoint (PIDGET (inferior_ptid));
      break;
    default:
      internal_error (__FILE__, __LINE__, "unknown breakpoint type");
      break;
    }

  if (val < 0)
    throw_exception (RETURN_ERROR);

  return 0;
}

d1058 16
a1073 5
	char prefix[64];

	sprintf (prefix, "warning: inserting catchpoint %d: ", b->number);
	val = catch_exceptions (uiout, insert_catchpoint, b, prefix,
				RETURN_MASK_ERROR);
d1075 4
a1078 1
	  b->enable_state = bp_disabled;
d1081 3
d4611 1
a4611 1
static void
d4678 1
a4678 1
static void
d6086 1
a6086 1
      xfree (trigger_func_name);
d6102 1
a6102 1
  xfree (sals.sals);
@


1.89.2.15
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@d50 1
d708 1
a708 1
static int
@


1.89.2.16
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d515 1
a515 1
  struct breakpoint *b;
d517 1
a517 1
  int bnum;
d567 1
a567 1
  struct breakpoint *b;
d569 1
a569 1
  int bnum;
d587 11
a597 11
      {
	char *tmpbuf = xstrprintf ("Type commands for when breakpoint %d is hit, one per line.", 
				 bnum);
	struct cleanup *cleanups = make_cleanup (xfree, tmpbuf);
	l = read_command_lines (tmpbuf, from_tty);
	do_cleanups (cleanups);
	free_command_lines (&b->commands);
	b->commands = l;
	breakpoints_changed ();
	breakpoint_modify_event (b->number);
	return;
d743 1
a743 1
  struct breakpoint *b, *temp;
d752 3
d915 3
a934 4
	    /* Format possible error msg */
	    char *message = xstrprintf ("Error inserting catchpoint %d:\n",
					b->number);
	    struct cleanup *cleanups = make_cleanup (xfree, message);
d941 2
a942 2
				&args, message, RETURN_MASK_ALL);
	    do_cleanups (cleanups);
d1086 3
a1088 3
	char *prefix = xstrprintf ("warning: inserting catchpoint %d: ",
				   b->number);
	struct cleanup *cleanups = make_cleanup (xfree, prefix);
a1090 1
	do_cleanups (cleanups);
d1122 1
a1122 1
  struct breakpoint *b;
d1140 1
a1140 1
  struct breakpoint *b;
d1161 1
a1161 1
  struct breakpoint *b;
d1324 1
a1324 1
  struct breakpoint *b;
d1546 1
a1546 1
  struct breakpoint *b;
d1567 1
a1567 1
  struct breakpoint *b, *temp;
d1642 1
a1642 1
  struct breakpoint *b;
d1671 1
a1671 1
  struct breakpoint *b;
a2396 3
#if 0
  struct frame_id current_frame_id;
#endif
d2414 2
a2415 7
	 state as `not changed' without further checking.
	 
	 vinschen/2003-09-04: The former implementation left out the case
	 that the watchpoint frame couldn't be found by frame_find_by_id()
	 because the current PC is currently in an epilogue.  Calling
	 gdbarch_in_function_epilogue_p() also when fr == NULL fixes that. */
      if ((!within_current_scope || fr == get_current_frame ())
d2418 1
a2418 1
      if (fr && within_current_scope)
d2503 1
a2503 1
  struct breakpoint *b, *temp;
d2511 3
d2612 1
d2616 2
a2617 7
	char *message = xstrprintf ("Error evaluating expression for watchpoint %d\n",
				    b->number);
	struct cleanup *cleanups = make_cleanup (xfree, message);
	int e = catch_errors (watchpoint_check, bs, message, 
			      RETURN_MASK_ALL);
	do_cleanups (cleanups);
	switch (e)
d2685 36
a2720 43
	  {
	    char *message = xstrprintf ("Error evaluating expression for watchpoint %d\n",
					b->number);
	    struct cleanup *cleanups = make_cleanup (xfree, message);
	    int e = catch_errors (watchpoint_check, bs, message,
				  RETURN_MASK_ALL);
	    do_cleanups (cleanups);
	    switch (e)
	      {
	      case WP_DELETED:
		/* We've already printed what needs to be printed.  */
		bs->print_it = print_it_done;
		/* Stop.  */
		break;
	      case WP_VALUE_CHANGED:
		if (b->type == bp_read_watchpoint)
		  {
		    /* Don't stop: read watchpoints shouldn't fire if
		       the value has changed.  This is for targets
		       which cannot set read-only watchpoints.  */
		    bs->print_it = print_it_noop;
		    bs->stop = 0;
		    continue;
		  }
		++(b->hit_count);
		break;
	      case WP_VALUE_NOT_CHANGED:
		/* Stop.  */
		++(b->hit_count);
		break;
	      default:
		/* Can't happen.  */
	      case 0:
		/* Error from catch_errors.  */
		printf_filtered ("Watchpoint %d deleted.\n", b->number);
		if (b->related_breakpoint)
		  b->related_breakpoint->disposition = disp_del_at_next_stop;
		b->disposition = disp_del_at_next_stop;
		/* We've already printed what needs to be printed.  */
		bs->print_it = print_it_done;
		break;
	      }
	  }
d3208 2
a3209 2
  struct command_line *l;
  struct symbol *sym;
d3515 1
a3515 1
  struct breakpoint *b;
d3567 1
a3567 1
  struct breakpoint *b;
d3683 2
a3684 2
  int others = 0;
  struct breakpoint *b;
d3772 2
a3773 2
  struct breakpoint *b;
  int count = 0;
d3850 1
a3850 1
  struct breakpoint *b, *b1;
d3959 1
a3959 1
  struct breakpoint *b;
d3972 1
a3972 1
  struct breakpoint *b;
d4011 1
a4011 1
  struct breakpoint *b;
d4025 1
a4025 1
  struct breakpoint *b;
d4064 1
a4064 1
  struct breakpoint *b, *temp;
d4296 1
a4296 1
  struct breakpoint *b;
d4311 1
a4311 1
  struct breakpoint *b;
d4340 1
a4340 1
  struct breakpoint *b;
d4402 1
a4402 1
  struct breakpoint *b;
d4731 1
a4731 1
  struct expression **cond = 0;
d4874 1
a4874 1
  struct expression **cond;
d4988 1
d5042 1
a5042 1
	  char *addr_string;
d5044 1
a5044 1
	    addr_string = xstrprintf ("*0x%s %s", paddr_nz (high), extra_args);
d5046 1
a5046 1
	    addr_string = xstrprintf ("*0x%s", paddr_nz (high));
d5077 3
a5079 2
	      addr_string = xstrprintf ("*0x%s",
					paddr_nz (get_frame_pc (deprecated_selected_frame)));
d5125 1
a5125 1
	  break_string;
d5127 1
a5127 2
	    break_string = xstrprintf ("*0x%s %s", paddr_nz (high),
				       extra_args);
d5129 1
a5129 1
	    break_string = xstrprintf ("*0x%s", paddr_nz (high));
d6499 2
a6500 2
  struct breakpoint *b;
  bpstat bs;
d6540 4
d6545 1
a6545 4
      char *message = xstrprintf ("Error in deleting catchpoint %d:\n",
				  bpt->number);
      struct cleanup *cleanups = make_cleanup (xfree, message);
      args_for_catchpoint_enable args;
a6550 1
      do_cleanups (cleanups);
d6940 2
d6948 1
a6948 3
    char *message = xstrprintf ("Error in re-setting breakpoint %d:\n",
				b->number);
    struct cleanup *cleanups = make_cleanup (xfree, message);
a6949 1
    do_cleanups (cleanups);
d6987 1
a6987 1
  struct breakpoint *b;
d7032 1
a7032 1
  int num;
d7056 1
a7056 1
  char *p = args;
d7058 2
a7059 2
  int num;
  struct breakpoint *b, *tmp;
d7124 1
a7124 1
  struct breakpoint *bpt;
d7258 1
a7258 1
  struct breakpoint *bpt;
@


1.89.2.17
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@a99 4
static void breakpoint_adjustment_warning (CORE_ADDR, CORE_ADDR, int, int);

static CORE_ADDR adjust_breakpoint_address (CORE_ADDR bpaddr);

d127 1
a127 1
static int remove_breakpoint (struct bp_location *, insertion_state_t);
a233 9
/* Similar iterators for the low-level breakpoints.  */

#define ALL_BP_LOCATIONS(B)  for (B = bp_location_chain; B; B = B->next)

#define ALL_BP_LOCATIONS_SAFE(B,TMP)	\
	for (B = bp_location_chain;	\
	     B ? (TMP=B->next, 1): 0;	\
	     B = TMP)

d248 1
a248 1
/* Chains of all breakpoints defined.  */
a251 2
struct bp_location *bp_location_chain;

d551 1
a551 1
	  b->cond = parse_exp_1 (&arg, block_for_pc (b->loc->address), 0);
d563 1
d614 1
a614 1
  struct bp_location *b;
d622 1
a622 1
  ALL_BP_LOCATIONS (b)
d624 3
a626 3
    if (b->owner->type == bp_none)
      warning ("reading through apparently deleted breakpoint #%d?",
              b->owner->number);
d628 5
a632 1
    if (b->loc_type != bp_loc_software_breakpoint)
d634 1
d735 4
a738 3
/* Insert a low-level "breakpoint" of some type.  BPT is the breakpoint.
   Any error messages are printed to TMP_ERROR_STREAM; and DISABLED_BREAKS,
   PROCESS_WARNING, and HW_BREAKPOINT_ERROR are used to report problems.
d740 2
a741 7
   NOTE drow/2003-09-09: This routine could be broken down to an object-style
   method for each breakpoint or catchpoint type.  */
static int
insert_bp_location (struct bp_location *bpt,
		    struct ui_file *tmp_error_stream,
		    int *disabled_breaks, int *process_warning,
		    int *hw_breakpoint_error)
d743 2
d746 8
d755 3
a757 4
  /* Permanent breakpoints cannot be inserted or removed.  Disabled
     breakpoints should not be inserted.  */
  if (bpt->owner->enable_state != bp_enabled)
    return 0;
d759 6
a764 2
  if (bpt->inserted || bpt->duplicate)
    return 0;
d766 34
a799 9
  if (bpt->loc_type == bp_loc_software_breakpoint
      || bpt->loc_type == bp_loc_hardware_breakpoint)
    {
      /* First check to see if we have to handle an overlay.  */
      if (overlay_debugging == ovly_off
	  || bpt->section == NULL
	  || !(section_is_overlay (bpt->section)))
	{
	  /* No overlay handling: just set the breakpoint.  */
d801 48
a848 49
	  if (bpt->loc_type == bp_loc_hardware_breakpoint)
	    val = target_insert_hw_breakpoint (bpt->address, 
					       bpt->shadow_contents);
	  else
	    val = target_insert_breakpoint (bpt->address,
					    bpt->shadow_contents);
	}
      else
	{
	  /* This breakpoint is in an overlay section.  
	     Shall we set a breakpoint at the LMA?  */
	  if (!overlay_events_enabled)
	    {
	      /* Yes -- overlay event support is not active, 
		 so we must try to set a breakpoint at the LMA.
		 This will not work for a hardware breakpoint.  */
	      if (bpt->loc_type == bp_loc_hardware_breakpoint)
		warning ("hardware breakpoint %d not supported in overlay!\n",
			 bpt->owner->number);
	      else
		{
		  CORE_ADDR addr = overlay_unmapped_address (bpt->address,
							     bpt->section);
		  /* Set a software (trap) breakpoint at the LMA.  */
		  val = target_insert_breakpoint (addr, bpt->shadow_contents);
		  if (val != 0)
		    fprintf_unfiltered (tmp_error_stream, 
					"Overlay breakpoint %d failed: in ROM?", 
					bpt->owner->number);
		}
	    }
	  /* Shall we set a breakpoint at the VMA? */
	  if (section_is_mapped (bpt->section))
	    {
	      /* Yes.  This overlay section is mapped into memory.  */
	      if (bpt->loc_type == bp_loc_hardware_breakpoint)
		val = target_insert_hw_breakpoint (bpt->address, 
						   bpt->shadow_contents);
	      else
		val = target_insert_breakpoint (bpt->address,
						bpt->shadow_contents);
	    }
	  else
	    {
	      /* No.  This breakpoint will not be inserted.  
		 No error, but do not mark the bp as 'inserted'.  */
	      return 0;
	    }
	}
d850 3
a852 3
      if (val)
	{
	  /* Can't set the breakpoint.  */
d854 18
a871 18
	  if (DISABLE_UNSETTABLE_BREAK (bpt->address))
	    {
	      /* See also: disable_breakpoints_in_shlibs. */
	      val = 0;
	      bpt->owner->enable_state = bp_shlib_disabled;
	      if (!*disabled_breaks)
		{
		  fprintf_unfiltered (tmp_error_stream, 
				      "Cannot insert breakpoint %d.\n", 
				      bpt->owner->number);
		  fprintf_unfiltered (tmp_error_stream, 
				      "Temporarily disabling shared library breakpoints:\n");
		}
	      *disabled_breaks = 1;
	      fprintf_unfiltered (tmp_error_stream,
				  "breakpoint #%d\n", bpt->owner->number);
	    }
	  else
d873 1
a873 1
	    {
d875 1
a875 1
	      *process_warning = 1;
d877 18
a894 18
	      if (bpt->loc_type == bp_loc_hardware_breakpoint)
		{
		  *hw_breakpoint_error = 1;
		  fprintf_unfiltered (tmp_error_stream, 
				      "Cannot insert hardware breakpoint %d.\n",
				      bpt->owner->number);
		}
	      else
		{
		  fprintf_unfiltered (tmp_error_stream, 
				      "Cannot insert breakpoint %d.\n", 
				      bpt->owner->number);
		  fprintf_filtered (tmp_error_stream, 
				    "Error accessing memory address ");
		  print_address_numeric (bpt->address, 1, tmp_error_stream);
		  fprintf_filtered (tmp_error_stream, ": %s.\n",
				    safe_strerror (val));
		}
d896 4
a899 4
	    }
	}
      else
	bpt->inserted = 1;
d901 6
a906 2
      return val;
    }
d908 47
a954 10
  else if (bpt->loc_type == bp_loc_hardware_watchpoint
	   /* NOTE drow/2003-09-08: This state only exists for removing
	      watchpoints.  It's not clear that it's necessary... */
	   && bpt->owner->disposition != disp_del_at_next_stop)
    {
      /* FIXME drow/2003-09-08: This code sets multiple hardware watchpoints
	 based on the expression.  Ideally this should happen at a higher level,
	 and there should be one bp_location for each computed address we
	 must watch.  As soon as a many-to-one mapping is available I'll
	 convert this.  */
d956 3
a958 4
      struct frame_info *saved_frame;
      int saved_level, within_current_scope;
      struct value *mark = value_mark ();
      struct value *v;
d960 11
a970 31
      /* Save the current frame and level so we can restore it after
	 evaluating the watchpoint expression on its own frame.  */
      /* FIXME drow/2003-09-09: It would be nice if evaluate_expression
	 took a frame parameter, so that we didn't have to change the
	 selected frame.  */
      saved_frame = deprecated_selected_frame;
      saved_level = frame_relative_level (deprecated_selected_frame);

      /* Determine if the watchpoint is within scope.  */
      if (bpt->owner->exp_valid_block == NULL)
	within_current_scope = 1;
      else
	{
	  struct frame_info *fi;
	  fi = frame_find_by_id (bpt->owner->watchpoint_frame);
	  within_current_scope = (fi != NULL);
	  if (within_current_scope)
	    select_frame (fi);
	}

      if (within_current_scope)
	{
	  /* Evaluate the expression and cut the chain of values
	     produced off from the value chain.

	     Make sure the value returned isn't lazy; we use
	     laziness to determine what memory GDB actually needed
	     in order to compute the value of the expression.  */
	  v = evaluate_expression (bpt->owner->exp);
	  VALUE_CONTENTS (v);
	  value_release_to_mark (mark);
d972 16
a987 2
	  bpt->owner->val_chain = v;
	  bpt->inserted = 1;
d989 4
a992 10
	  /* Look at each value on the value chain.  */
	  for (; v; v = v->next)
	    {
	      /* If it's a memory location, and GDB actually needed
		 its contents to evaluate the expression, then we
		 must watch it.  */
	      if (VALUE_LVAL (v) == lval_memory
		  && ! VALUE_LAZY (v))
		{
		  struct type *vtype = check_typedef (VALUE_TYPE (v));
d994 6
a999 54
		  /* We only watch structs and arrays if user asked
		     for it explicitly, never if they just happen to
		     appear in the middle of some value chain.  */
		  if (v == bpt->owner->val_chain
		      || (TYPE_CODE (vtype) != TYPE_CODE_STRUCT
			  && TYPE_CODE (vtype) != TYPE_CODE_ARRAY))
		    {
		      CORE_ADDR addr;
		      int len, type;

		      addr = VALUE_ADDRESS (v) + VALUE_OFFSET (v);
		      len = TYPE_LENGTH (VALUE_TYPE (v));
		      type = hw_write;
		      if (bpt->owner->type == bp_read_watchpoint)
			type = hw_read;
		      else if (bpt->owner->type == bp_access_watchpoint)
			type = hw_access;

		      val = target_insert_watchpoint (addr, len, type);
		      if (val == -1)
			{
			  /* Don't exit the loop, try to insert
			     every value on the value chain.  That's
			     because we will be removing all the
			     watches below, and removing a
			     watchpoint we didn't insert could have
			     adverse effects.  */
			  bpt->inserted = 0;
			}
		      val = 0;
		    }
		}
	    }
	  /* Failure to insert a watchpoint on any memory value in the
	     value chain brings us here.  */
	  if (!bpt->inserted)
	    {
	      remove_breakpoint (bpt, mark_uninserted);
	      *hw_breakpoint_error = 1;
	      fprintf_unfiltered (tmp_error_stream,
				  "Could not insert hardware watchpoint %d.\n", 
				  bpt->owner->number);
	      val = -1;
	    }               
	}
      else
	{
	  printf_filtered ("Hardware watchpoint %d deleted ", bpt->owner->number);
	  printf_filtered ("because the program has left the block \n");
	  printf_filtered ("in which its expression is valid.\n");
	  if (bpt->owner->related_breakpoint)
	    bpt->owner->related_breakpoint->disposition = disp_del_at_next_stop;
	  bpt->owner->disposition = disp_del_at_next_stop;
	}
d1001 2
a1002 4
      /* Restore the frame and level.  */
      if (saved_frame != deprecated_selected_frame
	  || saved_level != frame_relative_level (deprecated_selected_frame))
	select_frame (saved_frame);
d1004 10
a1013 2
      return val;
    }
d1015 54
a1068 5
  else if (ep_is_exception_catchpoint (bpt->owner))
    {
      /* FIXME drow/2003-09-09: This code sets both a catchpoint and a
	 breakpoint.  Once again, it would be better if this was represented
	 as two bp_locations.  */
d1070 4
a1073 34
      /* If we get here, we must have a callback mechanism for exception
	 events -- with g++ style embedded label support, we insert
	 ordinary breakpoints and not catchpoints. */
      val = target_insert_breakpoint (bpt->address, bpt->shadow_contents);
      if (val)
	{
	  /* Couldn't set breakpoint for some reason */
	  fprintf_unfiltered (tmp_error_stream, 
			      "Cannot insert catchpoint %d; disabling it.\n",
			      bpt->owner->number);
	  fprintf_filtered (tmp_error_stream, 
			    "Error accessing memory address ");
	  print_address_numeric (bpt->address, 1, tmp_error_stream);
	  fprintf_filtered (tmp_error_stream, ": %s.\n",
			    safe_strerror (val));
	  bpt->owner->enable_state = bp_disabled;
	}
      else
	{
	  /* Bp set, now make sure callbacks are enabled */
	  /* Format possible error msg */
	  char *message = xstrprintf ("Error inserting catchpoint %d:\n",
				      bpt->owner->number);
	  struct cleanup *cleanups = make_cleanup (xfree, message);
	  int val;
	  args_for_catchpoint_enable args;
	  args.kind = bpt->owner->type == bp_catch_catch ? 
	    EX_EVENT_CATCH : EX_EVENT_THROW;
	  args.enable_p = 1;
	  val = catch_errors (cover_target_enable_exception_callback,
			      &args, message, RETURN_MASK_ALL);
	  do_cleanups (cleanups);
	  if (val != 0 && val != -1)
	    bpt->inserted = 1;
d1075 23
a1097 84
	  /* Check if something went wrong; val == 0 can be ignored */
	  if (val == -1)
	    {
	      /* something went wrong */
	      fprintf_unfiltered (tmp_error_stream, 
				  "Cannot insert catchpoint %d; disabling it.\n",
				  bpt->owner->number);
	      bpt->owner->enable_state = bp_disabled;
	    }
	}

      return val;
    }

  else if (bpt->owner->type == bp_catch_fork
	   || bpt->owner->type == bp_catch_vfork
	   || bpt->owner->type == bp_catch_exec)
    {
      char *prefix = xstrprintf ("warning: inserting catchpoint %d: ",
				 bpt->owner->number);
      struct cleanup *cleanups = make_cleanup (xfree, prefix);
      val = catch_exceptions (uiout, insert_catchpoint, bpt->owner, prefix,
			      RETURN_MASK_ERROR);
      do_cleanups (cleanups);
      if (val < 0)
	bpt->owner->enable_state = bp_disabled;
      else
	bpt->inserted = 1;
      return val;
    }

  return 0;
}

/* insert_breakpoints is used when starting or continuing the program.
   remove_breakpoints is used when the program stops.
   Both return zero if successful,
   or an `errno' value if could not write the inferior.  */

int
insert_breakpoints (void)
{
  struct bp_location *b, *temp;
  int return_val = 0;	/* return success code. */
  int val = 0;
  int disabled_breaks = 0;
  int hw_breakpoint_error = 0;
  int process_warning = 0;

  struct ui_file *tmp_error_stream = mem_fileopen ();
  make_cleanup_ui_file_delete (tmp_error_stream);

  /* Explicitly mark the warning -- this will only be printed if
     there was an error.  */
  fprintf_unfiltered (tmp_error_stream, "Warning:\n");

  ALL_BP_LOCATIONS_SAFE (b, temp)
    {
      /* Permanent breakpoints cannot be inserted or removed.  Disabled
	 breakpoints should not be inserted.  */
      if (b->owner->enable_state != bp_enabled)
	continue;

      /* FIXME drow/2003-10-07: This code should be pushed elsewhere when
	 hardware watchpoints are split into multiple loc breakpoints.  */
      if ((b->loc_type == bp_loc_hardware_watchpoint
	   || b->owner->type == bp_watchpoint) && !b->owner->val)
	{
	  struct value *val;
	  val = evaluate_expression (b->owner->exp);
	  release_value (val);
	  if (VALUE_LAZY (val))
	    value_fetch_lazy (val);
	  b->owner->val = val;
	}

      val = insert_bp_location (b, tmp_error_stream,
				    &disabled_breaks, &process_warning,
				    &hw_breakpoint_error);
      if (val)
	return_val = val;
    }

  if (return_val)
d1101 1
a1101 1
      if (hw_breakpoint_error)
d1121 1
a1121 1
  struct bp_location *b;
d1124 1
a1124 1
  ALL_BP_LOCATIONS (b)
d1139 1
a1139 1
  struct bp_location *b;
d1142 1
a1142 1
  ALL_BP_LOCATIONS (b)
d1144 4
a1147 1
    if (b->inserted && b->loc_type == bp_loc_hardware_watchpoint)
d1160 1
a1160 1
  struct bp_location *b;
d1166 1
a1166 1
  ALL_BP_LOCATIONS (b)
d1171 1
a1171 1
	if (b->loc_type == bp_loc_hardware_breakpoint)
a1174 2
	/* FIXME drow/2003-10-07: This doesn't handle any other kinds of
	   breakpoints.  It's wrong for watchpoints, for example.  */
d1249 5
a1253 5
       valid code address on some platforms (like the mn10300
       simulators).  We shouldn't assign any special interpretation to
       a breakpoint with a zero address.  And in fact, GDB doesn't ---
       I can't see what that comment above is talking about.  As far
       as I can tell, setting the address of a
d1261 1
a1261 1
	b->loc->address = (CORE_ADDR) NULL;
d1314 1
a1314 1
    b->loc->address = (CORE_ADDR) NULL;
d1323 1
a1323 1
  struct bp_location *b;
d1332 1
a1332 1
  ALL_BP_LOCATIONS (b)
d1349 1
a1349 1
remove_breakpoint (struct bp_location *b, insertion_state_t is)
d1353 1
a1353 1
  if (b->owner->enable_state == bp_permanent)
d1357 1
a1357 1
  if (b->owner->type == bp_none)
d1359 1
a1359 1
	     b->owner->number);
d1361 9
a1369 2
  if (b->loc_type == bp_loc_software_breakpoint
      || b->loc_type == bp_loc_hardware_breakpoint)
d1382 1
a1382 1
	  if (b->loc_type == bp_loc_hardware_breakpoint)
d1401 1
a1401 1
		if (b->loc_type == bp_loc_hardware_breakpoint)
d1414 1
a1414 1
	      if (b->loc_type == bp_loc_hardware_breakpoint)
d1431 4
a1434 2
  else if (b->loc_type == bp_loc_hardware_watchpoint
	   && b->owner->enable_state == bp_enabled
d1442 1
a1442 1
      for (v = b->owner->val_chain; v; v = v->next)
d1451 1
a1451 1
	      if (v == b->owner->val_chain
d1461 1
a1461 1
		  if (b->owner->type == bp_read_watchpoint)
d1463 1
a1463 1
		  else if (b->owner->type == bp_access_watchpoint)
d1476 1
a1476 1
		 b->owner->number);
d1480 1
a1480 1
      for (v = b->owner->val_chain; v; v = n)
d1485 1
a1485 1
      b->owner->val_chain = NULL;
d1487 4
a1490 4
  else if ((b->owner->type == bp_catch_fork ||
	    b->owner->type == bp_catch_vfork ||
	    b->owner->type == bp_catch_exec)
	   && b->owner->enable_state == bp_enabled
d1494 1
a1494 1
      switch (b->owner->type)
d1513 3
a1515 3
  else if ((b->owner->type == bp_catch_catch ||
	    b->owner->type == bp_catch_throw)
	   && b->owner->enable_state == bp_enabled
d1524 1
a1524 1
  else if (ep_is_exception_catchpoint (b->owner)
d1526 1
a1526 1
	   && b->owner->enable_state == bp_enabled
d1545 1
a1545 1
  struct bp_location *bpt;
d1547 2
a1548 2
  ALL_BP_LOCATIONS (bpt)
    bpt->inserted = 0;
a1566 1
  struct bp_location *bpt;
a1568 3
  ALL_BP_LOCATIONS (bpt)
    bpt->inserted = 0;

d1571 2
d1641 1
a1641 1
  struct bp_location *bpt;
d1644 14
a1657 20
  ALL_BP_LOCATIONS (bpt)
    {
      if (bpt->loc_type != bp_loc_software_breakpoint
	  && bpt->loc_type != bp_loc_hardware_breakpoint)
	continue;

      if ((bpt->owner->enable_state == bp_enabled
	   || bpt->owner->enable_state == bp_permanent)
	  && bpt->address == pc)	/* bp is enabled and matches pc */
	{
	  if (overlay_debugging 
	      && section_is_overlay (bpt->section) 
	      && !section_is_mapped (bpt->section))
	    continue;		/* unmapped overlay -- can't be a match */
	  else if (bpt->owner->enable_state == bp_permanent)
	    return permanent_breakpoint_here;
	  else
	    any_breakpoint_here = 1;
	}
    }
d1670 1
a1670 1
  struct bp_location *bpt;
d1672 3
a1674 1
  ALL_BP_LOCATIONS (bpt)
d1676 6
a1681 14
      if (bpt->loc_type != bp_loc_software_breakpoint
	  && bpt->loc_type != bp_loc_hardware_breakpoint)
	continue;

      if (bpt->inserted
	  && bpt->address == pc)	/* bp is inserted and matches pc */
	{
	  if (overlay_debugging 
	      && section_is_overlay (bpt->section) 
	      && !section_is_mapped (bpt->section))
	    continue;		/* unmapped overlay -- can't be a match */
	  else
	    return 1;
	}
d1710 1
a1710 1
	    >= (b->loc->address
d1712 1
a1712 1
	&& get_frame_pc (frame) <= b->loc->address)
d1718 2
a1719 2
/* breakpoint_thread_match (PC, PTID) returns true if the breakpoint at
   PC is valid for process/thread PTID.  */
d1724 1
a1724 1
  struct bp_location *bpt;
d1729 13
a1741 18
  ALL_BP_LOCATIONS (bpt)
    {
      if (bpt->loc_type != bp_loc_software_breakpoint
	  && bpt->loc_type != bp_loc_hardware_breakpoint)
	continue;

      if ((bpt->owner->enable_state == bp_enabled
	   || bpt->owner->enable_state == bp_permanent)
	  && bpt->address == pc
	  && (bpt->owner->thread == -1 || bpt->owner->thread == thread))
	{
	  if (overlay_debugging 
	      && section_is_overlay (bpt->section) 
	      && !section_is_mapped (bpt->section))
	    continue;		/* unmapped overlay -- can't be a match */
	  else
	    return 1;
	}
d1927 1
a2027 4
      if (bs->breakpoint_at->loc->address != bs->breakpoint_at->loc->requested_address)
	breakpoint_adjustment_warning (bs->breakpoint_at->loc->requested_address,
	                               bs->breakpoint_at->loc->address,
				       bs->breakpoint_at->number, 1);
d2545 1
a2545 1
	if (b->loc->address != bp_addr) 	/* address doesn't match */
d2548 2
a2549 2
	    && section_is_overlay (b->loc->section) 
	    && !section_is_mapped (b->loc->section))
d2555 1
a2555 1
	if (b->loc->address != (*pc - DECR_PC_AFTER_HW_BREAK))
d2558 2
a2559 2
	    && section_is_overlay (b->loc->section) 
	    && !section_is_mapped (b->loc->section))
d2796 2
a2797 2
		(strcmp ("silent", bs->commands->line) == 0
		 || (xdb_commands && strcmp ("Q", bs->commands->line) == 0)))
d3143 7
a3149 5
  struct bp_location *bpt;
  ALL_BP_LOCATIONS (bpt)
    if ((bpt->owner->enable_state == bp_enabled)
	&& bpt->inserted
	&& bpt->loc_type == bp_loc_hardware_watchpoint)
d3415 1
a3415 1
	    ui_out_field_core_addr (uiout, "addr", b->loc->address);
d3418 1
a3418 1
	*last_addr = b->loc->address;
d3421 1
a3421 1
	    sym = find_pc_sect_function (b->loc->address, b->loc->section);
d3436 1
a3436 1
	    print_address_symbolic (b->loc->address, stb->stream, demangle, "");
d3669 1
d3681 1
d3702 2
a3703 2
    if (b->loc->address == pc)	/* address match / overlay match */
      if (!overlay_debugging || b->loc->section == section)
d3709 2
a3710 2
	if (b->loc->address == pc)	/* address match / overlay match */
	  if (!overlay_debugging || b->loc->section == section)
d3787 1
a3787 1
  struct bp_location *b;
d3789 3
a3791 3
  struct bp_location *perm_bp = 0;
  CORE_ADDR address = bpt->loc->address;
  asection *section = bpt->loc->section;
d3796 4
a3799 4
  ALL_BP_LOCATIONS (b)
    if (b->owner->enable_state != bp_disabled
	&& b->owner->enable_state != bp_shlib_disabled
	&& b->owner->enable_state != bp_call_disabled
d3802 1
a3802 1
	&& breakpoint_address_is_meaningful (b->owner))
d3805 1
a3805 1
      if (b->owner->enable_state == bp_permanent)
d3828 1
a3828 1
      ALL_BP_LOCATIONS (b)
d3831 8
a3838 3
	    if (b->owner->enable_state != bp_disabled
		&& b->owner->enable_state != bp_shlib_disabled
		&& b->owner->enable_state != bp_call_disabled
d3841 2
a3842 9
		&& breakpoint_address_is_meaningful (b->owner))
	      {
		if (b->inserted)
		  internal_error (__FILE__, __LINE__,
				  "another breakpoint was inserted on top of "
				  "a permanent breakpoint");

		b->duplicate = 1;
	      }
a3846 113
static void
breakpoint_adjustment_warning (CORE_ADDR from_addr, CORE_ADDR to_addr,
                               int bnum, int have_bnum)
{
  char astr1[40];
  char astr2[40];

  strcpy (astr1, local_hex_string_custom ((unsigned long) from_addr, "08l"));
  strcpy (astr2, local_hex_string_custom ((unsigned long) to_addr, "08l"));
  if (have_bnum)
    warning ("Breakpoint %d address previously adjusted from %s to %s.",
             bnum, astr1, astr2);
  else
    warning ("Breakpoint address adjusted from %s to %s.", astr1, astr2);
}

/* Adjust a breakpoint's address to account for architectural constraints
   on breakpoint placement.  Return the adjusted address.  Note: Very
   few targets require this kind of adjustment.  For most targets,
   this function is simply the identity function.  */

static CORE_ADDR
adjust_breakpoint_address (CORE_ADDR bpaddr)
{
  if (!gdbarch_adjust_breakpoint_address_p (current_gdbarch))
    {
      /* Very few targets need any kind of breakpoint adjustment.  */
      return bpaddr;
    }
  else
    {
      CORE_ADDR adjusted_bpaddr;

      /* Some targets have architectural constraints on the placement
         of breakpoint instructions.  Obtain the adjusted address.  */
      adjusted_bpaddr = gdbarch_adjust_breakpoint_address (current_gdbarch,
                                                           bpaddr);

      /* An adjusted breakpoint address can significantly alter
         a user's expectations.  Print a warning if an adjustment
	 is required.  */
      if (adjusted_bpaddr != bpaddr)
	breakpoint_adjustment_warning (bpaddr, adjusted_bpaddr, 0, 0);

      return adjusted_bpaddr;
    }
}

/* Allocate a struct bp_location.  */

static struct bp_location *
allocate_bp_location (struct breakpoint *bpt, enum bptype bp_type)
{
  struct bp_location *loc, *loc_p;

  loc = xmalloc (sizeof (struct bp_location));
  memset (loc, 0, sizeof (*loc));

  loc->owner = bpt;

  switch (bp_type)
    {
    case bp_breakpoint:
    case bp_until:
    case bp_finish:
    case bp_longjmp:
    case bp_longjmp_resume:
    case bp_step_resume:
    case bp_through_sigtramp:
    case bp_watchpoint_scope:
    case bp_call_dummy:
    case bp_shlib_event:
    case bp_thread_event:
    case bp_overlay_event:
    case bp_catch_load:
    case bp_catch_unload:
      loc->loc_type = bp_loc_software_breakpoint;
      break;
    case bp_hardware_breakpoint:
      loc->loc_type = bp_loc_hardware_breakpoint;
      break;
    case bp_hardware_watchpoint:
    case bp_read_watchpoint:
    case bp_access_watchpoint:
      loc->loc_type = bp_loc_hardware_watchpoint;
      break;
    case bp_watchpoint:
    case bp_catch_fork:
    case bp_catch_vfork:
    case bp_catch_exec:
    case bp_catch_catch:
    case bp_catch_throw:
      loc->loc_type = bp_loc_other;
      break;
    default:
      internal_error (__FILE__, __LINE__, "unknown breakpoint type");
    }

  /* Add this breakpoint to the end of the chain.  */

  loc_p = bp_location_chain;
  if (loc_p == 0)
    bp_location_chain = loc;
  else
    {
      while (loc_p->next)
	loc_p = loc_p->next;
      loc_p->next = loc;
    }

  return loc;
}

d3869 1
a3869 3
  b->loc = allocate_bp_location (b, bptype);
  b->loc->requested_address = sal.pc;
  b->loc->address = adjust_breakpoint_address (b->loc->requested_address);
d3875 1
a3875 1
  b->loc->section = sal.section;
d3922 1
a3922 1
  b->loc->inserted = 1;
d3955 1
a3955 1
      if ((m = lookup_minimal_symbol_text (func_name, NULL)) == NULL)
d4004 1
a4004 1
  if ((m = lookup_minimal_symbol_text (func_name, NULL)) == NULL)
d4060 1
a4060 1
  xasprintf (&b->addr_string, "*0x%s", paddr (b->loc->address));
d4111 2
a4112 2
	!b->loc->duplicate &&
	PC_SOLIB (b->loc->address))
d4143 1
a4143 1
      if (target_read_memory (b->loc->address, buf, 1) == 0)
d4360 1
a4360 2
      b->loc->requested_address = pc;
      b->loc->address = adjust_breakpoint_address (b->loc->requested_address);
d4560 1
a4560 1
	  print_address_numeric (b->loc->address, 1, gdb_stdout);
d4622 1
a4622 1
	  xasprintf (&b->addr_string, "*0x%s", paddr (b->loc->address));
d5323 1
d5476 1
a5476 4
	  scope_breakpoint->loc->requested_address
	    = get_frame_pc (prev_frame);
	  scope_breakpoint->loc->address
	    = adjust_breakpoint_address (scope_breakpoint->loc->requested_address);
d5626 1
d6069 1
a6069 1
      ui_out_field_core_addr (uiout, "addr", b->loc->address);
d6072 1
a6072 1
  *last_addr = b->loc->address;
d6428 3
a6430 3
	      && (((sal.pc && (b->loc->address == sal.pc)) 
		   && (!section_is_overlay (b->loc->section)
		       || b->loc->section == sal.section))
d6435 1
a6435 1
		      && strcmp (b->source_file, sal.symtab->filename) == 0
a6514 1
  struct bp_location *loc;
d6540 2
a6541 2
  if (bpt->loc->inserted)
    remove_breakpoint (bpt->loc, mark_inserted);
a6545 3
  if (bp_location_chain == bpt->loc)
    bp_location_chain = bpt->loc->next;

a6574 7
  ALL_BP_LOCATIONS (loc)
    if (loc->next == bpt->loc)
      {
	loc->next = bpt->loc->next;
	break;
      }

d6578 1
a6578 1
  if (bpt->loc->inserted
d6587 3
a6589 3
	if (b->loc->address == bpt->loc->address
	    && b->loc->section == bpt->loc->section
	    && !b->loc->duplicate
d6606 1
a6606 1
	    val = target_insert_hw_breakpoint (b->loc->address, b->loc->shadow_contents);
d6608 1
a6608 1
	    val = target_insert_breakpoint (b->loc->address, b->loc->shadow_contents);
d6628 1
a6628 1
		    print_address_numeric (b->loc->address, 1, tmp_error_stream);
d6638 1
a6638 1
	    b->loc->inserted = 1;
a6677 1
  xfree (bpt->loc);
d6819 1
a6819 1
	  if (b->loc->address != sals.sals[i].pc
d6824 1
a6824 1
		  && (strcmp (b->source_file, sals.sals[i].symtab->filename) != 0
d6841 1
a6841 3
	      b->loc->requested_address = sals.sals[i].pc;
	      b->loc->address
	        = adjust_breakpoint_address (b->loc->requested_address);
d6853 1
a6853 1
	  b->loc->section = sals.sals[i].section;
d7135 1
d7269 1
d7309 1
d7322 1
@


1.89.2.18
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@a334 7
/* Return whether a breakpoint is an active enabled breakpoint.  */
static int
breakpoint_enabled (struct breakpoint *b)
{
  return b->enable_state == bp_enabled;
}

d760 1
a760 1
  if (!breakpoint_enabled (bpt->owner))
d1074 1
a1074 5

      /* We've already printed an error message if there was a problem
	 inserting this catchpoint, and we've disabled the catchpoint,
	 so just return success.  */
      return 0;
d1106 1
a1106 1
      if (!breakpoint_enabled (b->owner))
d1456 1
a1456 1
	   && breakpoint_enabled (b->owner)
d1512 1
a1512 1
	   && breakpoint_enabled (b->owner)
d1537 1
a1537 1
	   && breakpoint_enabled (b->owner)
d1548 1
a1548 1
	   && breakpoint_enabled (b->owner)
d1674 1
a1674 1
      if ((breakpoint_enabled (bpt->owner)
d1771 1
a1771 1
      if ((breakpoint_enabled (bpt->owner)
d2573 3
a2575 1
    if (!breakpoint_enabled (b) && b->enable_state != bp_permanent)
d3178 1
a3178 1
    if (breakpoint_enabled (b) && b->type == bp_watchpoint)
d3189 1
a3189 1
    if (breakpoint_enabled (bpt->owner)
d4267 1
a4267 1
	breakpoint_enabled (b) &&
d4296 1
a4296 1
      char buf[1], *lib;
d4300 1
a4300 2
      lib = PC_SOLIB (b->loc->address);
      if (lib != NULL && target_read_memory (b->loc->address, buf, 1) == 0)
d4489 1
a4489 1
    if (breakpoint_enabled (b))
d4495 2
a4496 1
		  b->type == bp_access_watchpoint))
d4538 1
a4538 1
	&& breakpoint_enabled (b))
d7061 1
a7061 1
      if (VALUE_LAZY (b->val) && breakpoint_enabled (b))
d7071 1
a7071 1
      if (breakpoint_enabled (b))
@


1.89.2.19
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d4 2
a5 2
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
   Free Software Foundation, Inc.
d247 10
d1995 1
a2019 13
      struct command_line *cmd;
      struct cleanup *this_cmd_tree_chain;

      /* Take ownership of the BSP's command tree, if it has one.

         The command tree could legitimately contain commands like
         'step' and 'next', which call clear_proceed_status, which
         frees stop_bpstat's command tree.  To make sure this doesn't
         free the tree we're executing out from under us, we need to
         take ownership of the tree ourselves.  Since a given bpstat's
         commands are only executed once, we don't need to copy it; we
         can clear the pointer in the bpstat, and make sure we free
         the tree when we're done.  */
a2020 3
      bs->commands = 0;
      this_cmd_tree_chain = make_cleanup_free_command_lines (&cmd);

a2029 4

      /* We can free this command tree now.  */
      do_cleanups (this_cmd_tree_chain);

d2036 2
d2608 1
a2608 1
	if (b->loc->address != *pc)
d2868 9
a2876 1
      if (bs->breakpoint_at->type != bp_hardware_breakpoint)
d2878 1
a2878 1
	  if (DECR_PC_AFTER_BREAK != 0)
d2881 3
d2885 1
d4331 1
a4331 1
  sals = decode_line_1 (&hookname, 1, (struct symtab *) NULL, 0, &canonical, NULL);
d4848 1
a4848 1
			       default_breakpoint_line, addr_string, NULL);
d4850 1
a4850 1
	*sals = decode_line_1 (address, 1, (struct symtab *) NULL, 0, addr_string, NULL);
d5296 1
a5296 1
			(char ***) NULL, NULL);
d5813 1
a5813 1
			  default_breakpoint_line, (char ***) NULL, NULL);
d5816 1
a5816 1
			  0, (char ***) NULL, NULL);
d6276 1
a6276 1
  sals = decode_line_1 (&nameptr, 1, NULL, 0, NULL, NULL);
d6983 1
a6983 1
      sals = decode_line_1 (&s, 1, (struct symtab *) NULL, 0, (char ***) NULL, NULL);
d7519 1
a7519 1
			  (char ***) NULL, NULL);
d7522 1
a7522 1
			  (struct symtab *) NULL, 0, (char ***) NULL, NULL);
@


1.88
log
@Revert previous change.  Not obvious.
@
text
@d44 1
d4622 4
d4627 1
a4627 1
	  && (!current_source_symtab
@


1.87
log
@2002-09-18  Michael Snyder  <msnyder@@redhat.com>

	Preliminary support for Objective-C:
	* defs.h (language_objc): New enum value.
	(puts_filtered_tabular): Declaration only, exported from utils.c.
	(skip_quoted): Delete, declared in completer.h.
	* c-exp.y: Include completer.h.
	* p-exp.y: Ditto.
	* jv-exp.y: Ditto.
	* expression.h (OP_MSGCALL, OP_SELECTOR, OP_SELF, OP_NSSTRING):
	New operator enum values.
	* language.h (CAST_IS_CONVERSION): Test for language_objc.
	* language.c (binop_result_type): Handle language_objc case.
	(integral_type, character_type, string_type, boolean_type,
	structured_type, binop_type_check): Ditto.
	* symtab.h (SYMBOL_OBJC_DEMANGLED_NAME): Define.
	(struct objc_specific): Add to general_symbol_info.
	(SYMBOL_INIT_LANGUAGE_SPECIFIC): Add objc initialization.
	(SYMBOL_DEMANGLED_NAME): Handle objc case.
	* parser-defs.h (struct objc_class_str): New struct type.
	(start_msglist, end_msglist, add_msglist): Declaration only,
	exported from objc-lang.c.
	* value.h (value_of_local, value_nsstring,
	call_function_by_hand_expecting_type): Exported from valops.c.
	* valops.c (find_function_addr): Export.
	(call_function_by_hand_expecting_type): New function.
	(value_of_local): New function.
	* symfile.c (init_filename_language_table): Add ".m" extension
	for Objective-C.
	* utils.c (puts_filtered_tabular): New function.
	(fprintf_symbol_filtered): Add objc demangling support (disabled).
	(set/show demangle): Extend help-string to refer to ObjC.
	* elfread.c (elf_symtab_read): Skip Objective-C special symbols.
	* stabsread.c (symbol_reference_defined): Objective-C symbols
	may contain colons: make allowances when scanning stabs strings
	for colons.
	(objc_find_colon): New function.
	* printcmd.c (address_info): If language == objc then print
	"self" instead of "this".
	* parse.c (length_of_subexp): Handle new operators OP_MSGCALL,
	OP_NSSTRING, and OP_SELF.
	(prefixify_subexp): Ditto.
	* source.c (print_source_lines): Mention objc in comment.
	* breakpoint.c (parse_breakpoint_sals): Recognize Objective-C
	method names.
@
text
@a4620 1
      /* Also ignore objc method name.  FIXME better comment?  */
d4623 1
a4623 2
	      || ((strchr ("+-", (*address)[0]) != NULL)
		  && ((*address)[1] != '['))))
d4627 1
a4627 2
	*sals = decode_line_1 (address, 1, (struct symtab *) NULL, 
			       0, addr_string);
@


1.86
log
@2002-08-26  Michael Snyder  <msnyder@@redhat.com>

	* breakpoint.c (insert_breakpoints): Protect all references
	to 'process_warning'.  Shorten long lines.
@
text
@d4621 1
d4624 2
a4625 1
	      || (strchr ("+-", (*address)[0]) != NULL)))
d4629 2
a4630 1
	*sals = decode_line_1 (address, 1, (struct symtab *) NULL, 0, addr_string);
@


1.85
log
@2002-08-30  Pierre Muller  <muller@@ics.u-strasbg.fr>

	* breakpoint.c (breakpoint_init_inferior): Reset the val field of
	watchpoints to NULL.
	(insert_breakpoints): set val field of watchpoints if NULL.
@
text
@d720 1
d722 1
a726 4
#ifdef ONE_PROCESS_WRITETEXT
  process_warning = 1;
#endif

d838 2
a839 1
					"Cannot insert breakpoint %d.\n", b->number);
d844 2
a845 1
		fprintf_unfiltered (tmp_error_stream, "breakpoint #%d\n", b->number);
d850 1
d852 1
d862 5
a866 2
		    fprintf_unfiltered (tmp_error_stream, "Cannot insert breakpoint %d.\n", b->number);
		    fprintf_filtered (tmp_error_stream, "Error accessing memory address ");
d901 2
a902 1
	    fprintf_filtered (tmp_error_stream, "Error accessing memory address ");
a1030 1
		process_warning = 1;
d1034 2
a1035 1
				    "Cannot insert hardware watchpoint %d.\n", b->number);
d1082 2
a1083 1
	    fprintf_unfiltered (tmp_error_stream, "Cannot insert catchpoint %d.", b->number);
d1099 3
a1101 2
	  fprintf_unfiltered (tmp_error_stream, "Could not insert hardware breakpoints:\n" 
			      "You may have requested too many hardware breakpoints/watchpoints.\n");
d1103 1
a1103 1

d1105 3
a1107 2
	fprintf_unfiltered (tmp_error_stream,"The same program may be running in another process.");

@


1.84
log
@2002-08-27  Elena Zannoni  <ezannoni@@redhat.com>

	* cli/cli-script.h (copy_command_lines): Export.
	* breakpoint.c: Include cli/cli-script.h.
	* Makefile.in (breakpoint.o): Update dependencies.
@
text
@d741 13
a753 1
    else if (b->type != bp_watchpoint
d1581 8
@


1.83
log
@2002-08-26  Joel Brobecker  <brobecker@@gnat.com>

	* cli/cli-script.c (copy_command_lines): New function.
	* defs.h (copy_command_lines): Export.
	* testsuite/gdb.base/commands.exp: New tests for commands
	attached to a temporary breakpoint, and for commands that
	delete the breakpoint they are attached to.

2002-08-26  Michael Snyder  <msnyder@@redhat.com>

	* breakpoint.c (bpstat_stop_status): Instead of copying the
	pointer to the breakpoint commands struct, make a new copy
	of the struct and point to that.
	(bpstat_clear): Free the commands struct.
	(bpstat_clear_actions): Free the commands struct.
	(bpstat_do_actions): Free the command actions.  Also execute
	the local cleanups, instead of deleting them.
	(delete_breakpoint): Leave the commands field of the bpstat
	chain alone -- it will be freed later.
@
text
@d48 1
@


1.82
log
@	* infrun.c (normal_stop, proceed): Remove call to print_sys_errmsg
	when breakpoints fail. Move general breakpoint error messages to
	insert_breakpoints.
	* breakpoint.c (insert_breakpoints): Change warnings when
	breakpoints are nto inserted to specify the type. Remove call to
	memory_error when hardware breakpoints can't be inserted. Remove
	multiple calls to warning so all messages are sent to the user at
	once.
	(delete_breakpoints): Make insert error messsages more explicit.
@
text
@d1766 1
d1879 1
a1879 1
      bs->commands = NULL;
d1948 1
a1948 1
	bs->commands = NULL;
d1950 1
a1950 3

  executing_breakpoint_commands = 0;
  discard_cleanups (old_chain);
d2732 1
a2732 1
	    bs->commands = b->commands;
a6788 7

	/* we'd call bpstat_clear_actions, but that free's stuff and due
	   to the multiple pointers pointing to one item with no
	   reference counts found anywhere through out the bpstat's (how
	   do you spell fragile?), we don't want to free things twice --
	   better a memory leak than a corrupt malloc pool! */
	bs->commands = NULL;
d6790 1
@


1.81
log
@        * breakpoints.c (watch_command_1): Use internal breakpoint
        when setting a watchpoint_scope breakpoint.
@
text
@d718 2
d724 10
d791 3
a793 2
		      warning ("overlay breakpoint %d failed: in ROM?", 
			       b->number);
d826 4
a829 3
		    target_terminal_ours_for_output ();
		    warning ("Cannot insert breakpoint %d:", b->number);
		    warning ("Temporarily disabling shared library breakpoints:");
d832 1
a832 1
		warning ("breakpoint #%d ", b->number);
d837 17
a853 6
		target_terminal_ours_for_output ();
		warning ("Cannot insert breakpoint %d:", b->number);
#ifdef ONE_PROCESS_WRITETEXT
		warning ("The same program may be running in another process.");
#endif
		memory_error (val, b->address);	   /* which bombs us out */
d880 7
a886 3
	    target_terminal_ours_for_output ();
	    warning ("Cannot insert catchpoint %d; disabling it.",
		     b->number);
d908 3
a910 3
		target_terminal_ours_for_output ();
		warning ("Cannot insert catchpoint %d; disabling it.",
			 b->number);
d987 1
a987 1
			type   = hw_write;
d1012 1
d1014 3
a1016 2
		warning ("Could not insert hardware watchpoint %d.",
			 b->number);
d1063 1
a1063 2
	    target_terminal_ours_for_output ();
	    warning ("Cannot insert catchpoint %d.", b->number);
d1072 10
d1083 6
a1091 1

d6729 1
d6732 21
d6754 1
a6754 2
	      warning ("Cannot insert breakpoint %d:", b->number);
	      memory_error (val, b->address);	/* which bombs us out */
@


1.80
log
@        * alpha-osf1-tdep.c (alpha_osf1_init_abi): Unfortunately,
        procfs appears to be broken when debugging on multi-processor
        machines. So enable software single stepping in order to avoid
        using the procfs interface to do next/step operations, using
        internal breakpoints instead.

        * infrun.c (handle_inferior_event): Readjust the stop_pc by
        DECR_PC_AFTER_BREAK when hitting a single step breakpoint, to
        make this pc address equal to the value it would have if the
        system stepping capability was used. Also set a new flag used
        to ensure that we don't readjust the PC one more time later.

        * breakpoint.c (bpstat_stop_status): Do not adjust the PC
        address by DECR_PC_AFTER_BREAK when software single step is
        in use for this architecture, as this has already been taken
        care of in handle_inferior_event().
@
text
@d5334 2
a5335 10
	  struct symtab_and_line scope_sal;

	  INIT_SAL (&scope_sal);	/* initialize to zeroes */
	  scope_sal.pc = get_frame_pc (prev_frame);
	  scope_sal.section = find_pc_overlay (scope_sal.pc);

	  scope_breakpoint = set_raw_breakpoint (scope_sal,
	                                         bp_watchpoint_scope);
	  set_breakpoint_count (breakpoint_count + 1);
	  scope_breakpoint->number = breakpoint_count;
@


1.79
log
@* breakpoint.c (bpstat_stop_status): Rename not_a_breakpoint to
not_a_sw_breakpoint.
* breakpoint.h (bpstat_stop_status): Add parameter names.
@
text
@d2432 1
a2432 2
  bp_addr = *pc - (not_a_sw_breakpoint && !SOFTWARE_SINGLE_STEP_P () ? 
                   0 : DECR_PC_AFTER_BREAK);
@


1.78
log
@	* breakpoint.c (delete_command): Don't repeat `delete' commands.
@
text
@d2393 1
a2393 1
   breakpoint (if we hit a breakpoint).  NOT_A_BREAKPOINT is nonzero
d2412 1
a2412 1
bpstat_stop_status (CORE_ADDR *pc, int not_a_breakpoint)
d2426 5
a2430 5
  /* Get the address where the breakpoint would have been.  
     The "not_a_breakpoint" argument is meant to distinguish 
     between a breakpoint trap event and a trace/singlestep
     trap event.  For a trace/singlestep trap event, we would
     not want to subtract DECR_PC_AFTER_BREAK from the PC. */
d2432 1
a2432 1
  bp_addr = *pc - (not_a_breakpoint && !SOFTWARE_SINGLE_STEP_P () ? 
@


1.77
log
@        * breakpoint.c (condition_command): Post breakpoint_modify
        when a condition is added to an existing breakpoint.
        (commands_command): Likewise for commands.
        (set_ignore_count): Likewise for ignore counts.
        If no tty, do not simply return, still need to send event
        notification.
        (ignore_command): Only print a newline if the command came
        from a tty.
        Don't call breakpoints_changed, since this is now properly
        handled by set_ignore_count.
@
text
@d6772 2
@


1.76
log
@* infrun.c (struct inferior_status): Replace fields
selected_frame_address and selected_level with field
selected_frame_id.
(save_inferior_status): Update.  Use get_frame_id.
(struct restore_selected_frame_args): Delete.
(restore_selected_frame): Update.  Use frame_find_by_id.
(restore_inferior_status): Update.

* breakpoint.h (struct breakpoint): Change type of
watchpoint_frame to frame_id.
* breakpoint.c (insert_breakpoints): Use frame_find_by_id.  Remove
call to get_current_frame.
(do_enable_breakpoint): Use frame_find_by_id.  Remove call to
get_current_frame.
(watchpoint_check): Use frame_find_by_id.

* frame.h (record_selected_frame): Delete declaration.
* stack.c (record_selected_frame): Delete function.

* frame.h (struct frame_id): Define.
(get_frame_id): Declare.
(frame_find_by_id): Declare.
* frame.c (frame_find_by_id): New function.
(get_frame_id): New function.
@
text
@d556 1
d596 1
d7076 12
a7087 11
      if (!from_tty)
	return;
      else if (count == 0)
	printf_filtered ("Will stop next time breakpoint %d is reached.",
			 bptnum);
      else if (count == 1)
	printf_filtered ("Will ignore next crossing of breakpoint %d.",
			 bptnum);
      else
	printf_filtered ("Will ignore next %d crossings of breakpoint %d.",
			 count, bptnum);
d7089 1
d7126 2
a7127 2
  printf_filtered ("\n");
  breakpoints_changed ();
@


1.75
log
@* frame.h (select_frame): Delete level parameter.
* stack.c (select_frame): Update.  Use frame_relative_level to
obtain the frame's level.
(select_and_print_frame): Update call.
(select_frame_command): Ditto.
(up_silently_base): Ditto.
(down_silently_base): Ditto.
* ocd.c (ocd_start_remote): Ditto.
* remote-rdp.c (remote_rdp_open): Ditto.
* remote-mips.c (mips_initialize): Ditto.
(common_open): Ditto.
* remote-e7000.c (e7000_start_remote): Ditto.
* m3-nat.c (select_thread): Ditto.
* hppa-tdep.c (child_get_current_exception_event): Ditto.
(child_get_current_exception_event): Ditto.
* varobj.c (varobj_create): Ditto.
(varobj_update): Ditto.
(c_value_of_root): Ditto.
* tracepoint.c (finish_tfind_command): Ditto.
* corelow.c (core_open): Ditto.
* arch-utils.c (generic_prepare_to_proceed): Ditto.
* thread.c (info_threads_command): Ditto.
(switch_to_thread): Ditto.
* infrun.c (normal_stop): Ditto.
(restore_selected_frame): Ditto.
(restore_inferior_status): Ditto.
* breakpoint.c (insert_breakpoints): Ditto.
(watchpoint_check): Ditto.
(bpstat_stop_status): Ditto.
(do_enable_breakpoint): Ditto.
* blockframe.c (flush_cached_frames): Ditto.
(reinit_frame_cache): Ditto.
@
text
@d912 1
a912 7

	    /* There might be no current frame at this moment if we are
	       resuming from a step over a breakpoint.
	       Set up current frame before trying to find the watchpoint
	       frame.  */
	    get_current_frame ();
	    fi = find_frame_addr_in_frame_chain (b->watchpoint_frame);
d2317 1
a2317 1
      fr = find_frame_addr_in_frame_chain (b->watchpoint_frame);
d5318 1
a5318 1
      b->watchpoint_frame = frame->frame;
d5321 3
a5323 1
    b->watchpoint_frame = (CORE_ADDR) 0;
d7265 1
a7265 6

	  /* Ensure that we have the current frame.  Else, this
	     next query may pessimistically be answered as, "No,
	     not within current scope". */
	  get_current_frame ();
	  fr = find_frame_addr_in_frame_chain (bpt->watchpoint_frame);
@


1.75.6.1
log
@        * breakpoint.c (internal_breakpoint_number): Make static global.
        (condition_command): Add modify breakpoint event notification.
        (commands_command): Likewise.
        (create_internal_breakpoint): internal_breakpoint_number is now global.
        Add create breakpoint event notification.
        (create_fork_vfork_event_catchpoint): Likewise.
        (create_exec_event_catchpoint): Likewise.
        (mention): Remove FIXME and create breakpoint event.
        (create_breakpoints): Add create breakpoint event notification.
        (watch_command_1): Likewise.
        (create_exception_catchpoint): Likewise.
        (set_breakpoint_sal): Likewise.
        (set_ignore_count): Add modify breakopint event notification.

        * interps.h: Add GDB_INTERPRETER_MI1. GDB_INTERPRETER_MI will
        now be mi version 2.

        * cli/cli-interp.c (cli_uiout): Make static.
        (cli_interp): Make static.
        (cli_interpreter_exec): Use cli_uiout instead of uiout.
@
text
@a255 3
/* Internal breakpoint number */
static int internal_breakpoint_number = -1;

d3813 1
a3824 1
  breakpoint_create_event (b->number);
a4109 1
  breakpoint_create_event (b->number);
a4154 1
  breakpoint_create_event (b->number);
a4192 1
  breakpoint_create_event (b->number);
a4318 1
  breakpoint_create_event (b->number);
d4335 9
a4508 1
	breakpoint_create_event (b->number);
d5345 2
a5346 1
	  scope_breakpoint->number = internal_breakpoint_number--;
a5361 2

	  breakpoint_create_event (scope_breakpoint->number);
a5364 1
  breakpoint_create_event (b->number);
a6097 1
  breakpoint_create_event (b->number);
a6262 1
      breakpoint_create_event (b->number);
a6404 1
  breakpoint_create_event (b->number);
@


1.75.6.2
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@a558 1
      breakpoint_modify_event (b->number);
a597 1
      breakpoint_modify_event (b->number);
d915 7
a921 1
	    fi = frame_find_by_id (b->watchpoint_frame);
d2326 1
a2326 1
      fr = frame_find_by_id (b->watchpoint_frame);
d5323 1
a5323 1
      get_frame_id (frame, &b->watchpoint_frame);
d5326 1
a5326 3
    {
      memset (&b->watchpoint_frame, 0, sizeof (b->watchpoint_frame));
    }
d7082 11
a7092 12
      if (from_tty)
	{
	  if (count == 0)
	    printf_filtered ("Will stop next time breakpoint %d is reached.",
			     bptnum);
	  else if (count == 1)
	    printf_filtered ("Will ignore next crossing of breakpoint %d.",
			     bptnum);
	  else
	    printf_filtered ("Will ignore next %d crossings of breakpoint %d.",
			     count, bptnum);
	}
a7093 1
      breakpoint_modify_event (b->number);
d7130 2
a7131 2
  if (from_tty)
    printf_filtered ("\n");
d7273 6
a7278 1
	  fr = frame_find_by_id (bpt->watchpoint_frame);
@


1.75.6.3
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@a6775 2
  dont_repeat ();

@


1.75.6.4
log
@Update with patch that went into mainline.
        * breakpoint.c (internal_breakpoint_number): Revert 2002-06-18 change.
        (create_internal_breakpoint): Likewise.
        (watch_command_1): Use create_internal_breakpoint to create
        the watchpoint scope breakpoint.
@
text
@d256 3
a3811 1
  static int internal_breakpoint_number = -1;
d5334 9
a5342 2
	  scope_breakpoint = create_internal_breakpoint (get_frame_pc (prev_frame),
							 bp_watchpoint_scope);
@


1.75.6.5
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@a47 1
#include "cli/cli-script.h"
a717 2
  int hw_breakpoint_error = 0;
  int process_warning = 0;
a721 10
#ifdef ONE_PROCESS_WRITETEXT
  process_warning = 1;
#endif

  struct ui_file *tmp_error_stream = mem_fileopen ();
  make_cleanup_ui_file_delete (tmp_error_stream);

  /* Explicitly mark the warning -- this will only be printed if
     there was an error.  */
  fprintf_unfiltered (tmp_error_stream, "Warning:\n");
d779 2
a780 3
		      fprintf_unfiltered (tmp_error_stream, 
					  "Overlay breakpoint %d failed: in ROM?", 
					  b->number);
d813 3
a815 4
		    fprintf_unfiltered (tmp_error_stream, 
					"Cannot insert breakpoint %d.\n", b->number);
		    fprintf_unfiltered (tmp_error_stream, 
					"Temporarily disabling shared library breakpoints:\n");
d818 1
a818 1
		fprintf_unfiltered (tmp_error_stream, "breakpoint #%d\n", b->number);
d823 6
a828 17
		process_warning = 1;
		if (b->type == bp_hardware_breakpoint)
		  {
		    hw_breakpoint_error = 1;
		    fprintf_unfiltered (tmp_error_stream, 
					"Cannot insert hardware breakpoint %d.\n",
					b->number);
		  }
		else
		  {
		    fprintf_unfiltered (tmp_error_stream, "Cannot insert breakpoint %d.\n", b->number);
		    fprintf_filtered (tmp_error_stream, "Error accessing memory address ");
		    print_address_numeric (b->address, 1, tmp_error_stream);
		    fprintf_filtered (tmp_error_stream, ": %s.\n",
				      safe_strerror (val));
		  }

d855 3
a857 7
	    fprintf_unfiltered (tmp_error_stream, 
				"Cannot insert catchpoint %d; disabling it.\n",
				b->number);
	    fprintf_filtered (tmp_error_stream, "Error accessing memory address ");
	    print_address_numeric (b->address, 1, tmp_error_stream);
	    fprintf_filtered (tmp_error_stream, ": %s.\n",
			      safe_strerror (val));
d879 3
a881 3
		fprintf_unfiltered (tmp_error_stream, 
				    "Cannot insert catchpoint %d; disabling it.\n",
				    b->number);
d958 1
a958 1
			type = hw_write;
a982 1
		process_warning = 1;
d984 2
a985 3
		hw_breakpoint_error = 1;
		fprintf_unfiltered (tmp_error_stream,
				    "Cannot insert hardware watchpoint %d.\n", b->number);
d1032 2
a1033 1
	    fprintf_unfiltered (tmp_error_stream, "Cannot insert catchpoint %d.", b->number);
a1041 10
  
  if (return_val) 
    {
      /* If a hardware breakpoint or watchpoint was inserted, add a
         message about possibly exhausted resources.  */
      if (hw_breakpoint_error)  
	{
	  fprintf_unfiltered (tmp_error_stream, "Could not insert hardware breakpoints:\n" 
			      "You may have requested too many hardware breakpoints/watchpoints.\n");
	}
a1042 6
      if (process_warning)
	fprintf_unfiltered (tmp_error_stream,"The same program may be running in another process.");

      target_terminal_ours_for_output ();
      error_stream (tmp_error_stream);
    }
d1046 1
a1720 1
      free_command_lines (&p->commands);
d1833 1
a1833 1
      free_command_lines (&bs->commands);
d1902 1
a1902 1
	free_command_lines (&bs->commands);
d1904 3
a1906 1
  do_cleanups (old_chain);
d2393 1
a2393 1
   breakpoint (if we hit a breakpoint).  NOT_A_SW_BREAKPOINT is nonzero
d2412 1
a2412 1
bpstat_stop_status (CORE_ADDR *pc, int not_a_sw_breakpoint)
d2426 5
a2430 5
  /* Get the address where the breakpoint would have been.  The
     "not_a_sw_breakpoint" argument is meant to distinguish between a
     breakpoint trap event and a trace/singlestep trap event.  For a
     trace/singlestep trap event, we would not want to subtract
     DECR_PC_AFTER_BREAK from the PC. */
d2432 2
a2433 1
  bp_addr = *pc - (not_a_sw_breakpoint ? 0 : DECR_PC_AFTER_BREAK);
d2689 1
a2689 1
	    bs->commands = copy_command_lines (b->commands);
a6687 1
	  /* If there was an error in the insert, print a message, then stop execution.  */
a6689 21
	      struct ui_file *tmp_error_stream = mem_fileopen ();
	      make_cleanup_ui_file_delete (tmp_error_stream);
	     

	      if (b->type == bp_hardware_breakpoint)
		{
		  fprintf_unfiltered (tmp_error_stream, 
					"Cannot insert hardware breakpoint %d.\n"
				      "You may have requested too many hardware breakpoints.\n",
					b->number);
		  }
		else
		  {
		    fprintf_unfiltered (tmp_error_stream, "Cannot insert breakpoint %d.\n", b->number);
		    fprintf_filtered (tmp_error_stream, "Error accessing memory address ");
		    print_address_numeric (b->address, 1, tmp_error_stream);
		    fprintf_filtered (tmp_error_stream, ": %s.\n",
				      safe_strerror (val));
		  }
	      
	      fprintf_unfiltered (tmp_error_stream,"The same program may be running in another process.");
d6691 2
a6692 1
	      error_stream(tmp_error_stream); 
d6728 7
a6735 1
	/* bs->commands will be freed later.  */
@


1.75.6.6
log
@Merge with kseitz_interps-20020930-merge.
@
text
@a43 1
#include "source.h"
a719 1
#ifdef ONE_PROCESS_WRITETEXT
a720 1
#endif
d725 4
d741 1
a741 13
    if ((b->type == bp_watchpoint
	 || b->type == bp_hardware_watchpoint
	 || b->type == bp_read_watchpoint
	 || b->type == bp_access_watchpoint) && (!b->val))
      {
	struct value *val;
	val = evaluate_expression (b->exp);
	release_value (val);
	if (VALUE_LAZY (val))
	  value_fetch_lazy (val);
	b->val = val;
      } 
    if (b->type != bp_watchpoint
d828 1
a828 2
					"Cannot insert breakpoint %d.\n", 
					b->number);
d833 1
a833 2
		fprintf_unfiltered (tmp_error_stream, 
				    "breakpoint #%d\n", b->number);
a837 1
#ifdef ONE_PROCESS_WRITETEXT
a838 1
#endif
d848 2
a849 5
		    fprintf_unfiltered (tmp_error_stream, 
					"Cannot insert breakpoint %d.\n", 
					b->number);
		    fprintf_filtered (tmp_error_stream, 
				      "Error accessing memory address ");
d884 1
a884 2
	    fprintf_filtered (tmp_error_stream, 
			      "Error accessing memory address ");
d1013 1
d1017 1
a1017 2
				    "Could not insert hardware watchpoint %d.\n", 
				    b->number);
d1064 1
a1064 2
	    fprintf_unfiltered (tmp_error_stream, 
				"Cannot insert catchpoint %d.", b->number);
d1080 2
a1081 3
	  fprintf_unfiltered (tmp_error_stream, 
			      "Could not insert hardware breakpoints:\n\
You may have requested too many hardware breakpoints/watchpoints.\n");
d1083 1
a1083 1
#ifdef ONE_PROCESS_WRITETEXT
d1085 2
a1086 3
	fprintf_unfiltered (tmp_error_stream,
			    "The same program may be running in another process.");
#endif
a1568 8
	if (context == inf_starting) 
	  {
	    /* Reset val field to force reread of starting value
	       in insert_breakpoints.  */
	    if (b->val)
	      value_free (b->val);
	    b->val = NULL;
	  }
a4588 3
	 
      struct symtab_and_line cursal = get_current_source_symtab_and_line ();
			
d4590 1
a4590 1
	  && (!cursal.symtab
@


1.75.6.7
log
@merge from mainline
@
text
@d3887 1
a3887 1
  init_sal (&sal);		/* initialize to zeroes */
d4209 1
a4209 1
  init_sal (&sal);
d4249 1
a4249 1
  init_sal (&sal);
d4600 1
a4600 1
	  init_sal (&sal);		/* initialize to zeroes */
d4618 1
a4618 3
         leaving default_breakpoint_* alone.  
         ObjC: However, don't match an Objective-C method name which
         may have a '+' or '-' succeeded by a '[' */
d4624 1
a4624 2
 	      || ((strchr ("+-", (*address)[0]) != NULL)
 		  && ((*address)[1] != '['))))
d5293 1
a5293 1
  init_sal (&sal);		/* initialize to zeroes */
d6263 1
a6263 1
  init_sal (&sal);		/* initialize to zeroes */
d6536 1
a6536 1
      init_sal (&sal);		/* initialize to zeroes */
@


1.75.4.1
log
@merge from trunk
@
text
@d912 7
a918 1
	    fi = frame_find_by_id (b->watchpoint_frame);
d2323 1
a2323 1
      fr = frame_find_by_id (b->watchpoint_frame);
d5324 1
a5324 1
      get_frame_id (frame, &b->watchpoint_frame);
d5327 1
a5327 3
    {
      memset (&b->watchpoint_frame, 0, sizeof (b->watchpoint_frame));
    }
d7269 6
a7274 1
	  fr = frame_find_by_id (bpt->watchpoint_frame);
@


1.75.4.2
log
@Merge with trunk.
@
text
@a555 1
      breakpoint_modify_event (b->number);
a594 1
      breakpoint_modify_event (b->number);
d7074 11
a7084 12
      if (from_tty)
	{
	  if (count == 0)
	    printf_filtered ("Will stop next time breakpoint %d is reached.",
			     bptnum);
	  else if (count == 1)
	    printf_filtered ("Will ignore next crossing of breakpoint %d.",
			     bptnum);
	  else
	    printf_filtered ("Will ignore next %d crossings of breakpoint %d.",
			     count, bptnum);
	}
a7085 1
      breakpoint_modify_event (b->number);
d7122 2
a7123 2
  if (from_tty)
    printf_filtered ("\n");
@


1.75.4.3
log
@merge with trunk
@
text
@a6771 2
  dont_repeat ();

@


1.74
log
@* arch-utils.h: Update copyright.

* gdbarch.sh (PC_IN_SIGTRAMP): Add.
* gdbarch.h, gdbarch.c: Re-generate.

* inferior.h (IN_SIGTRAMP): Delete definition.
* arch-utils.c (legacy_pc_in_sigtramp): New function.
* arch-utils.h (legacy_pc_in_sigtramp): Declare.

* mips-tdep.c (mips_init_extra_frame_info): Use PC_IN_SIGTRAMP.
(mips_dump_tdep): Do not print value of IN_SIGTRAMP.
* hppa-tdep.c (pc_in_interrupt_handler):  Use PC_IN_SIGTRAMP.
(find_proc_framesize): Ditto.
* alpha-tdep.c (alpha_osf_skip_sigtramp_frame): Ditto.
(alpha_init_extra_frame_info): Ditto.
* infrun.c (handle_inferior_event): Ditto.
(handle_inferior_event): Ditto.
(check_sigtramp2): Ditto.
* blockframe.c (create_new_frame): Ditto.
(get_prev_frame): Ditto.
* ppc-linux-tdep.c: Update comments.
* i386-linux-tdep.c: Update comments.
* breakpoint.c (bpstat_what): Update comment.

* gdbint.texinfo (Target Architecture Definition): Replace
IN_SIGTRAMP with PC_IN_SIGTRAMP.
@
text
@d921 1
a921 1
	      select_frame (fi, -1);
d1006 1
a1006 1
	  select_frame (saved_frame, saved_level);
d2337 1
a2337 1
	select_frame (fr, -1);
d2668 1
a2668 1
	    select_frame (get_current_frame (), 0);
d7286 1
a7286 1
	  select_frame (fr, -1);
d7321 1
a7321 1
	select_frame (save_selected_frame, save_selected_frame_level);
@


1.73
log
@* frame.h (selected_frame_level): Document as deprecated.
(frame_relative_level): Declare.
* stack.c (frame_relative_level): New function.
(selected_frame_level): Document as deprecated.
(select_frame): Do not set the selected_frame_level.

* stack.c (frame_info, record_selected_frame): Update.
(frame_command, current_frame_command): Update.
(up_silently_base, up_command, down_silently_base): Update.
(down_command): Update.
* inflow.c (kill_command): Update.
* tracepoint.c (finish_tfind_command): Update.
* corelow.c (core_open): Update.
* thread.c (info_threads_command): Update.
(do_captured_thread_select): Update.
* infcmd.c (finish_command): Update.
* breakpoint.c (insert_breakpoints, do_enable_breakpoint): Update.
@
text
@d2853 1
a2853 1
     at first IN_SIGTRAMP where we set the step_resume breakpoint).  */
@


1.72
log
@2002-04-05  Michael Snyder  <msnyder@@redhat.com>

	* breakpoint.c (clear_command): Rewrite middle section to
	combine two loops with identical control conditions.
	Add a cleanup to eliminate a memory leak.
@
text
@d904 1
a904 1
	saved_level = selected_frame_level;
d1005 1
a1005 1
	    (saved_level != selected_frame_level))
d7285 1
a7285 1
	  save_selected_frame_level = selected_frame_level;
@


1.71
log
@gdb/ChangeLog:
* stack.c (get_selected_block): Add new argument `addr_in_block',
used to return the exact code address we used to select the block,
not just the block.
* blockframe.c (get_frame_block, get_current_block): Same.
* frame.h (get_frame_block, get_current_block,
get_selected_block): Update declarations.
* linespec.c, stack.c, blockframe.c, breakpoint.c, findvar.c,
linespec.c, varobj.c, printcmd.c, symtab.c: Callers changed.

gdb/mi/ChangeLog:
* mi-cmd-stack.c (list_args_or_locals): Pass new arg to
get_frame_block.  (See entry in gdb/ChangeLog.)
@
text
@d6445 1
d6450 1
a6450 1
  register struct breakpoint *b, *b1;
a6453 1
  register struct breakpoint *found;
d6465 1
d6480 3
a6482 6
     to it.  We do this in two loops: the first loop looks at
     the initial bp(s) in the chain which should be deleted,
     the second goes down the rest of the chain looking ahead
     one so it can take those bps off the chain without messing
     up the chain. */

d6484 1
d6500 1
a6500 49
      found = (struct breakpoint *) 0;


      while (breakpoint_chain
      /* Why don't we check here that this is not
         a watchpoint, etc., as we do below?
         I can't make it fail, but don't know
         what's stopping the failure: a watchpoint
         of the same address as "sal.pc" should
         wind up being deleted. */

	     && (((sal.pc && (breakpoint_chain->address == sal.pc)) 
		  && (!overlay_debugging 
		      || breakpoint_chain->section == sal.section))
		 || ((default_match || (0 == sal.pc))
		     && breakpoint_chain->source_file != NULL
		     && sal.symtab != NULL
	      && STREQ (breakpoint_chain->source_file, sal.symtab->filename)
		     && breakpoint_chain->line_number == sal.line)))

	{
	  b1 = breakpoint_chain;
	  breakpoint_chain = b1->next;
	  b1->next = found;
	  found = b1;
	}

      ALL_BREAKPOINTS (b)
	while (b->next
	       && b->next->type != bp_none
	       && b->next->type != bp_watchpoint
	       && b->next->type != bp_hardware_watchpoint
	       && b->next->type != bp_read_watchpoint
	       && b->next->type != bp_access_watchpoint
	       && (((sal.pc && (b->next->address == sal.pc)) 
		    && (!overlay_debugging || b->next->section == sal.section))
		   || ((default_match || (0 == sal.pc))
		       && b->next->source_file != NULL
		       && sal.symtab != NULL
		       && STREQ (b->next->source_file, sal.symtab->filename)
		       && b->next->line_number == sal.line)))


	{
	  b1 = b->next;
	  b->next = b1->next;
	  b1->next = found;
	  found = b1;
	}
d6502 3
a6504 1
      if (found == 0)
d6506 32
a6537 2
	  if (arg)
	    error ("No breakpoint at %s.", arg);
d6539 4
a6542 1
	    error ("No breakpoint at this line.");
d6544 9
d6554 7
a6560 13
      if (found->next)
	from_tty = 1;		/* Always report if deleted more than one */
      if (from_tty)
	printf_unfiltered ("Deleted breakpoint%s ", found->next ? "s" : "");
      breakpoints_changed ();
      while (found)
	{
	  if (from_tty)
	    printf_unfiltered ("%d ", found->number);
	  b1 = found->next;
	  delete_breakpoint (found);
	  found = b1;
	}
d6562 4
a6565 1
	putchar_unfiltered ('\n');
d6567 2
a6568 1
  xfree (sals.sals);
@


1.70
log
@2002-04-05  Michael Snyder  <msnyder@@redhat.com>

	* breakpoint.c (insert_breakpoints): Change 'hw' to 'hardware in
	warning message.
@
text
@d5702 1
a5702 1
  block = get_frame_block (selected_frame);
@


1.69
log
@2002-04-04  Michael Snyder  <msnyder@@redhat.com>

	* breakpoint.c: Add support for hardware breakpoints in overlays.
	(overlay_events_enabled): New state variable.
	(insert_breakpoints): Use overlay_events_enabled to decide
	whether to attempt to set a breakpoint at the overlay load addr.
	Handle bp_hardware_breakpoint as well as bp_breakpoint.
	(remove_breakpoint): Use overlay_events_enabled to decide
	whether breakpoints need to be removed from overlay load addr.
	Handle bp_hardware_breakpoint as well as bp_breakpoint.
	(bpstat_stop_status): Handle bp_hardware_breakpoint in overlays.
	(create_overlay_event_breakpoint, enable_overlay_breakpoints,
	disable_overlay_breakpoints): Update overlay_events_enabled.
@
text
@d768 1
a768 1
		  warning ("hw breakpoint %d not supported in overlay!\n",
@


1.68
log
@2002-03-27  Michael Snyder  <msnyder@@redhat.com>

	* breakpoint.c (_initialize_breakpoint): Clean up help string.
	* infcmd.c (_initialize_infcmd): Ditto.
	* language.c (_initialize_language): Ditto.
	* symfile.c (_initialize_symfile): Ditto.
	* top.c (_init_main): Ditto.
	* cli/cli-cmds.c (init_cli_cmds): Ditto.
@
text
@d220 3
d741 17
a757 2
	if (b->type == bp_hardware_breakpoint)
	  val = target_insert_hw_breakpoint (b->address, b->shadow_contents);
d760 23
a782 6
	    /* Check to see if breakpoint is in an overlay section;
	       if so, we should set the breakpoint at the LMA address.
	       Only if the section is currently mapped should we ALSO
	       set a break at the VMA address. */
	    if (overlay_debugging && b->section 
		&& section_is_overlay (b->section))
d784 5
a788 10
		CORE_ADDR addr;

		addr = overlay_unmapped_address (b->address, b->section);
		val = target_insert_breakpoint (addr, b->shadow_contents);
		/* This would be the time to check val, to see if the
		   breakpoint write to the load address succeeded.  
		   However, this might be an ordinary occurrance, eg. if 
		   the unmapped overlay is in ROM.  */
		val = 0;	/* in case unmapped address failed */
		if (section_is_mapped (b->section))
d792 6
a797 2
	    else		/* ordinary (non-overlay) address */
	      val = target_insert_breakpoint (b->address, b->shadow_contents);
d799 1
d1304 17
a1320 2
      if (b->type == bp_hardware_breakpoint)
	val = target_remove_hw_breakpoint (b->address, b->shadow_contents);
d1323 19
a1341 6
	  /* Check to see if breakpoint is in an overlay section;
	     if so, we should remove the breakpoint at the LMA address.
	     If that is not equal to the raw address, then we should 
	     presumably remove the breakpoint there as well.  */
	  if (overlay_debugging && b->section 
	      && section_is_overlay (b->section))
d1343 8
a1350 10
	      CORE_ADDR addr;

	      addr = overlay_unmapped_address (b->address, b->section);
	      val = target_remove_breakpoint (addr, b->shadow_contents);
	      /* This would be the time to check val, to see if the
	         shadow breakpoint write to the load address succeeded.  
	         However, this might be an ordinary occurrance, eg. if 
	         the unmapped overlay is in ROM.  */
	      val = 0;		/* in case unmapped address failed */
	      if (section_is_mapped (b->section))
d1354 5
a1358 2
	  else			/* ordinary (non-overlay) address */
	    val = target_remove_breakpoint (b->address, b->shadow_contents);
d2465 9
a2473 3
    if (b->type == bp_hardware_breakpoint
	&& b->address != (*pc - DECR_PC_AFTER_HW_BREAK))
      continue;
d3897 4
a3900 1
    b->enable_state = bp_enabled;
d3902 4
a3905 1
    b->enable_state = bp_disabled;
d3918 1
d3932 1
@


1.67
log
@* cli/cli-decode.c (set_cmd_completer): New function.
* command.h (set_cmd_completer): Declare.
* cli/cli-decode.h (set_cmd_completer): Ditto.

* breakpoint.c (_initialize_breakpoint): Use set_cmd_completer.
* cli/cli-cmds.c (init_cli_cmds): Ditto.
* win32-nat.c (_initialize_inftarg): Ditto.
* remote-rdi.c (_initialize_remote_rdi): Ditto.
* proc-api.c (_initialize_proc_api): Ditto.
* hppa-tdep.c (_initialize_hppa_tdep): Ditto.
* source.c (_initialize_source): Ditto.
* exec.c (_initialize_exec): Ditto.
* solib.c (_initialize_solib): Ditto.
* top.c (init_main): Ditto.
* tracepoint.c (_initialize_tracepoint): Ditto.
* symfile.c (_initialize_symfile): Ditto.
* printcmd.c (_initialize_printcmd): Ditto.
* infcmd.c (_initialize_infcmd): Ditto.
* corefile.c (_initialize_core): Ditto.
@
text
@d7377 1
a7377 1
expression to be evaluated whenever breakpoint N is reached.  ");
@


1.66
log
@* gdbarch.sh (GET_LONGJMP_TARGET): Add rule.
* gdbarch.c gdbarch.h: Regenerate.
* breakpoint.c (create_longjmp_breakpoint): Always compile this
function.
(breakpoint_reset): Test GET_LONGJMP_TARGET_P().
* infrun.c (GET_LONGJMP_TARGET): Delete default definition.
(handle_inferior_event): Test GET_LONGJMP_TARGET_P().

* arm-tdep.h (struct gdbarch_tdep): Add jb_pc and jb_elt_size fields.
* arm-tdep.c (arm_get_longjmp_target): New function.
(arm_gdbarch_init): Initialize jb_pc to -1.  If ABI handler changes
this to a positive value register arm_get_longjmp_target as the
longjmp handler.
* arm-linux-tdep.c (arm_get_longjmp_target): Delete.
(arm_linux_init_abi): Set up longjmp description in tdep.
* armnbsd-nat.c (get_longjmp_target): Delete.
* armnbsd-tdep.c (arm_netbsd_init_abi_common): Set up longjmp
description in tdep.
* config/arm/tm-nbsd.h (JB_ELEMENT_SIZE, JB_PC): Delete.
(get_longjmp_target): Delete declaration.
(GET_LONGJMP_TARGET): Delete.
* config/arm/tm-linux.h (arm_get_longjmp_target): Delete declaration.
(GET_LONGJMP_TARGET): Delete.
@
text
@d7384 1
a7384 1
  c->completer = location_completer;
d7390 1
a7390 1
  c->completer = location_completer;
d7396 1
a7396 1
  c->completer = location_completer;
d7510 1
a7510 1
  c->completer = location_completer;
d7641 1
a7641 1
  c->completer = location_completer;
d7647 1
a7647 1
  c->completer = location_completer;
d7653 1
a7653 1
  c->completer = location_completer;
@


1.65
log
@2002-02-04  Michael Snyder  <msnyder@@redhat.com>

	* breakpoint.h (enum bptype): Add new overlay event bp type.
	(enable_overlay_breakpoints, disable_overlay_breakpoints): Export.

	* breakpoint.c (create_internal_breakpoint): New function.
	(internal_breakpoint_number): Moved into create_internal_breakpoint.
	(create_longjmp_breakpoint): Use create_internal_breakpoint.
	(create_thread_event_breakpoint): Ditto.
	(create_solib_event_breakpoint): Ditto.
	(create_overlay_event_breakpoint): New function.
	(enable_overlay_breakpoints, disable_overlay_breakpoints): New funcs.
	(update_breakpoints_after_exec): Delete and re-initialize
	overlay event breakpoints after an exec.  Add FIXME comment
	about longjmp breakpoint.
	(print_it_typical): Ignore overlay event breakpoints.
	(print_one_breakpoint): Ditto.
	(mention): Ditto.
	(bpstat_what): Do not stop for overlay event breakpoints.
	(delete_breakpoint): Don't delete overlay event breakpoints.
	(breakpoint_re_set_one): Delete the overlay event breakpoint.
	(breakpoint_re_set): Re-create overlay event breakpoint.

	* symfile.c (overlay_auto_command): Enable overlay breakpoints.
	(overlay_manual_command): Disable overlay breakpoints.
	(overlay_off_command): Disable overlay breakpoints.
@
text
@a145 1
#ifdef GET_LONGJMP_TARGET
a146 1
#endif
a3758 1
#ifdef GET_LONGJMP_TARGET
a3781 2
#endif /* #ifdef GET_LONGJMP_TARGET */

d6965 8
a6972 7
#ifdef GET_LONGJMP_TARGET
  create_longjmp_breakpoint ("longjmp");
  create_longjmp_breakpoint ("_longjmp");
  create_longjmp_breakpoint ("siglongjmp");
  create_longjmp_breakpoint ("_siglongjmp");
  create_longjmp_breakpoint (NULL);
#endif
@


1.64
log
@	* breakpoint.c (break_at_finish_command): Really export.
	(break_at_finish_at_depth_command): Ditto.
	(tbreak_at_finish_command): Ditto.
	* hppa-tdep.c: Include completer.h.
	* Makefile.in (hppa-tdep.o): Add dependency on $(completer_h).
	(COMMON_OBS): Remove duplicate ui-file.o, frame.o, doublest.o.
@
text
@a119 4
#if 0
static struct breakpoint *create_temp_exception_breakpoint (CORE_ADDR);
#endif

d150 2
a218 2
static int internal_breakpoint_number = -1;

d1106 3
a1108 2
    /* Thread event breakpoints must be set anew after an exec().  */
    if (b->type == bp_thread_event)
d1216 2
d1912 6
d2904 1
d3081 1
d3238 1
d3742 19
a3765 1
  struct symtab_and_line sal;
d3767 1
d3769 3
a3771 2
  INIT_SAL (&sal);		/* initialize to zeroes */
  if (func_name != NULL)
d3773 1
a3773 7
      struct minimal_symbol *m;

      m = lookup_minimal_symbol_text (func_name, NULL, 
				      (struct objfile *) NULL);
      if (m)
	sal.pc = SYMBOL_VALUE_ADDRESS (m);
      else
d3775 2
a3777 3
  sal.section = find_pc_overlay (sal.pc);
  b = set_raw_breakpoint (sal,
                          func_name != NULL ? bp_longjmp : bp_longjmp_resume);
a3778 1
  b->disposition = disp_donttouch;
a3782 1
  b->number = internal_breakpoint_number--;
d3818 45
a3866 1
  struct symtab_and_line sal;
d3869 1
a3869 4
  INIT_SAL (&sal);		/* initialize to zeroes */
  sal.pc = address;
  sal.section = find_pc_overlay (sal.pc);
  b = set_raw_breakpoint (sal, bp_thread_event);
a3870 2
  b->number = internal_breakpoint_number--;
  b->disposition = disp_donttouch;
a3903 8
  struct symtab_and_line sal;

  INIT_SAL (&sal);		/* initialize to zeroes */
  sal.pc = address;
  sal.section = find_pc_overlay (sal.pc);
  b = set_raw_breakpoint (sal, bp_shlib_event);
  b->number = internal_breakpoint_number--;
  b->disposition = disp_donttouch;
d3905 1
d4365 1
d6720 1
d6734 1
d6918 2
a6919 2
      /* Delete longjmp breakpoints, they will be reset later by
         breakpoint_re_set.  */
d6922 1
d6977 2
d7106 4
@


1.63
log
@2002-02-01  Michael Snyder  <msnyder@@redhat.com>

	* breakpoint.c (breakpoint_re_set): Delete ancient #if 0 code.
@
text
@d87 2
a88 2
static void break_at_finish_command (char *, int);
static void break_at_finish_at_depth_command (char *, int);
d90 1
a90 1
static void tbreak_at_finish_command (char *, int);
@


1.62
log
@2002-02-01  Michael Snyder  <msnyder@@redhat.com>

	* breakpoint.c (set_ignore_count): Move misplaced comment
	back where it belongs.
@
text
@d6792 1
a6792 1
	         cause trouble, as it doesn't check for disable
a6920 7
#endif

#if 0
  /* Took this out (temporarily at least), since it produces an extra 
     blank line at startup. This messes up the gdbtests. -PB */
  /* Blank line to finish off all those mention() messages we just printed.  */
  printf_filtered ("\n");
@


1.61
log
@2002-02-01  Michael Snyder  <msnyder@@redhat.com>

	* breakpoint.c (create_temp_exception_breakpoint): Delete.
@
text
@a6930 4
/* Set ignore-count of breakpoint number BPTNUM to COUNT.
   If from_tty is nonzero, it prints a message to that effect,
   which ends with a period (no newline).  */

d6944 4
@


1.60
log
@2002-01-31  Michael Snyder  <msnyder@@redhat.com>

	* breakpoint.c (break_at_finish_command): Export.
	(break_at_finish_at_depth_command): Export.
	(tbreak_at_finish_command): Export.
	(_initialize_breakpoint): Delete "xbreak" and "tbreak" commands.
	* hppa-tdep.c (_initialize_hppa_tdep): Add "xbreak" and
	"tbreak" commands, which are HPPA specific.
@
text
@a6147 24
#if 0
/* This creates a temporary internal breakpoint
   just to placate infrun */
static struct breakpoint *
create_temp_exception_breakpoint (CORE_ADDR pc)
{
  struct symtab_and_line sal;
  struct breakpoint *b;

  INIT_SAL (&sal);
  sal.pc = pc;
  sal.symtab = NULL;
  sal.line = 0;

  b = set_raw_breakpoint (sal, bp_breakpoint);

  b->disposition = disp_del;
  b->enable_state = bp_enabled;
  b->silent = 1;
  b->number = internal_breakpoint_number--;
  return b;
}
#endif

@


1.59
log
@2002-01-31  Michael Snyder  <msnyder@@redhat.com>

	* breakpoint.c (insert_breakpoints, remove_breakpoint,
	breakpoint_here_p, breakpoint_inserted_here_p,
	breakpoint_thread_match, bpstat_stop_status,
	describe_other_breakpoints, check_duplicates, clear_command):
	Coding standard fixes.
@
text
@d4964 1
a4964 1
static void
d4970 1
a4970 1
static void
d4982 1
a4982 1
static void
a7359 5
  c = add_com ("txbreak", class_breakpoint, tbreak_at_finish_command,
	       "Set temporary breakpoint at procedure exit.  Either there should\n\
be no argument or the argument must be a depth.\n");
  c->completer = location_completer;

d7491 1
a7491 18
  add_com ("xbreak", class_breakpoint, break_at_finish_command,
	   concat ("Set breakpoint at procedure exit. \n\
Argument may be function name, or \"*\" and an address.\n\
If function is specified, break at end of code for that function.\n\
If an address is specified, break at the end of the function that contains \n\
that exact address.\n",
		   "With no arg, uses current execution address of selected stack frame.\n\
This is useful for breaking on return to a stack frame.\n\
\n\
Multiple breakpoints at one place are permitted, and useful if conditional.\n\
\n\
Do \"help breakpoints\" for info on other commands dealing with breakpoints.", NULL));
  add_com_alias ("xb", "xbreak", class_breakpoint, 1);
  add_com_alias ("xbr", "xbreak", class_breakpoint, 1);
  add_com_alias ("xbre", "xbreak", class_breakpoint, 1);
  add_com_alias ("xbrea", "xbreak", class_breakpoint, 1);

  if (xdb_commands)
a7494 3
      add_com ("bx", class_breakpoint, break_at_finish_at_depth_command,
	       "Set breakpoint at procedure exit.  Either there should\n\
be no argument or the argument must be a depth.\n");
@


1.58
log
@Remove else clause to #if UI_OUT.
@
text
@d752 2
a753 2
	    if (overlay_debugging && b->section &&
		section_is_overlay (b->section))
d1280 2
a1281 2
	  if (overlay_debugging && b->section &&
	      section_is_overlay (b->section))
d1513 3
a1515 3
	if (overlay_debugging &&
	    section_is_overlay (b->section) &&
	    !section_is_mapped (b->section))
d1540 3
a1542 3
      if (overlay_debugging &&
	  section_is_overlay (b->section) &&
	  !section_is_mapped (b->section))
d1601 3
a1603 3
      if (overlay_debugging &&
	  section_is_overlay (b->section) &&
	  !section_is_mapped (b->section))
d2389 8
a2396 5
      if (b->address != bp_addr ||	/* address doesn't match or */
	  (overlay_debugging &&	/* overlay doesn't match */
	   section_is_overlay (b->section) &&
	   !section_is_mapped (b->section)))
	continue;
d3512 3
a3514 4
    if (b->address == pc)
    if (overlay_debugging == 0 ||
	b->section == section)
      others++;
d3519 16
a3534 15
	if (b->address == pc)
	if (overlay_debugging == 0 ||
	    b->section == section)
	  {
	    others--;
	    printf_filtered ("%d%s%s ",
			     b->number,
			     ((b->enable_state == bp_disabled || 
			       b->enable_state == bp_shlib_disabled || 
			       b->enable_state == bp_call_disabled) ? " (disabled)" 
			      : b->enable_state == bp_permanent ? " (permanent)"
			      : ""),
			     (others > 1) ? "," 
			     : ((others == 1) ? " and" : ""));
	  }
d3610 2
a3611 2
	&& b->address == address
	&& (overlay_debugging == 0 || b->section == section)
d3649 2
a3650 2
		&& b->address == address
		&& (overlay_debugging == 0 || b->section == section)
d6411 3
a6413 3
	     && (((sal.pc && (breakpoint_chain->address == sal.pc)) &&
		  (overlay_debugging == 0 ||
		   breakpoint_chain->section == sal.section))
a6427 1

d6434 2
a6435 3
	       && (((sal.pc && (b->next->address == sal.pc)) &&
		    (overlay_debugging == 0 ||
		     b->next->section == sal.section))
@


1.57
log
@From Mark Kettenis  <kettenis@@gnu.org>:
* breakpoint.c (breakpoint_re_set_one): Don't discard SHLIB
breakpoints when they fail.
@
text
@d2 4
a5 2
   Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
   1996, 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
a46 1
#ifdef UI_OUT
a47 1
#endif
a1875 1
#ifdef UI_OUT
a1879 1
#endif /* UI_OUT */
a1888 1
#ifdef UI_OUT
a1895 7
#else
      /* I think the user probably only wants to see one breakpoint
         number, not all of them.  */
      annotate_breakpoint (bs->breakpoint_at->number);
      printf_filtered ("\nBreakpoint %d, ", bs->breakpoint_at->number);
      return PRINT_SRC_AND_LOC;
#endif
a2027 1
#ifdef UI_OUT
a2039 9
#else
	  mention (bs->breakpoint_at);
	  printf_filtered ("\nOld value = ");
	  value_print (bs->old_val, gdb_stdout, 0, Val_pretty_default);
	  printf_filtered ("\nNew value = ");
	  value_print (bs->breakpoint_at->val, gdb_stdout, 0,
		       Val_pretty_default);
	  printf_filtered ("\n");
#endif
a2047 1
#ifdef UI_OUT
a2056 7
#else
      mention (bs->breakpoint_at);
      printf_filtered ("\nValue = ");
      value_print (bs->breakpoint_at->val, gdb_stdout, 0,
		   Val_pretty_default);
      printf_filtered ("\n");
#endif
a2060 1
#ifdef UI_OUT
a2086 20
#else
      if (bs->old_val != NULL)     
	{
	  annotate_watchpoint (bs->breakpoint_at->number);
	  mention (bs->breakpoint_at);
	  printf_filtered ("\nOld value = ");
	  value_print (bs->old_val, gdb_stdout, 0, Val_pretty_default);
	  value_free (bs->old_val);
	  bs->old_val = NULL;
	  printf_filtered ("\nNew value = ");
	}
      else 
	{
	  mention (bs->breakpoint_at);
	  printf_filtered ("\nValue = ");
	}
      value_print (bs->breakpoint_at->val, gdb_stdout, 0,
		   Val_pretty_default);
      printf_filtered ("\n");
#endif
a2093 1
#ifdef UI_OUT
a2095 1
#endif
a2099 1
#ifdef UI_OUT
a2101 1
#endif
a2312 1
#ifdef UI_OUT
a2318 5
#else
      printf_filtered ("\
Watchpoint %d deleted because the program has left the block in\n\
which its expression is valid.\n", bs->breakpoint_at->number);
#endif 
a3084 1
#ifdef UI_OUT
a3086 1
#endif
a3088 1
#ifdef UI_OUT
a3089 1
#endif
a3092 1
#ifdef UI_OUT
a3093 3
#else
  printf_filtered ("%-3d ", b->number);
#endif
a3101 1
#ifdef UI_OUT
a3102 3
#else
  printf_filtered ("%-14s ", bptypes[(int) b->type].description);
#endif
a3105 1
#ifdef UI_OUT
a3106 3
#else
  printf_filtered ("%-4s ", bpdisps[(int) b->disposition]);
#endif
a3109 1
#ifdef UI_OUT
a3111 3
#else
  printf_filtered ("%-3c ", bpenables[(int) b->enable_state]);
#endif
a3135 1
#ifdef UI_OUT
a3140 4
#else
      annotate_field (5);
      print_expression (b->exp, gdb_stdout);
#endif
a3147 1
#ifdef UI_OUT
a3161 7
#else
      annotate_field (5);
      if (b->dll_pathname == NULL)
	printf_filtered ("<any library> ");
      else
	printf_filtered ("library \"%s\" ", b->dll_pathname);
#endif
a3168 1
#ifdef UI_OUT
a3177 6
#else
      annotate_field (5);
      if (b->forked_inferior_pid != 0)
	printf_filtered ("process %d ", b->forked_inferior_pid);
      break;
#endif
a3182 1
#ifdef UI_OUT
a3191 5
#else
      annotate_field (5);
      if (b->exec_pathname != NULL)
	printf_filtered ("program \"%s\" ", b->exec_pathname);
#endif
a3197 1
#ifdef UI_OUT
a3202 4
#else
      annotate_field (5);
      printf_filtered ("exception catch ");
#endif
a3208 1
#ifdef UI_OUT
a3213 4
#else
      annotate_field (5);
      printf_filtered ("exception throw ");
#endif
a3227 1
#ifdef UI_OUT
a3254 34
#else
      if (addressprint)
	{
	  char *tmp;

	  annotate_field (4);

	  if (TARGET_ADDR_BIT <= 32)
	    tmp = longest_local_hex_string_custom (b->address
						   & (CORE_ADDR) 0xffffffff, 
						   "08l");
	  else
	    tmp = longest_local_hex_string_custom (b->address, "016l");

	  printf_filtered ("%s ", tmp);
	}
      annotate_field (5);
      *last_addr = b->address;
      if (b->source_file)
	{
	  sym = find_pc_sect_function (b->address, b->section);
	  if (sym)
	    {
	      fputs_filtered ("in ", gdb_stdout);
	      fputs_filtered (SYMBOL_SOURCE_NAME (sym), gdb_stdout);
	      wrap_here (wrap_indent);
	      fputs_filtered (" at ", gdb_stdout);
	    }
	  fputs_filtered (b->source_file, gdb_stdout);
	  printf_filtered (":%d", b->line_number);
	}
      else
	print_address_symbolic (b->address, gdb_stdout, demangle, " ");
#endif
a3259 1
#ifdef UI_OUT
a3263 3
#else
      printf_filtered (" thread %d", b->thread);
#endif
a3265 1
#ifdef UI_OUT
a3266 3
#else
  printf_filtered ("\n");
#endif
a3270 1
#ifdef UI_OUT
a3273 5
#else
      printf_filtered ("\tstop only in stack frame at ");
      print_address_numeric (b->frame, 1, gdb_stdout);
      printf_filtered ("\n");
#endif
a3278 1
#ifdef UI_OUT
a3282 5
#else
      printf_filtered ("\tstop only if ");
      print_expression (b->cond, gdb_stdout);
      printf_filtered ("\n");
#endif
a3287 1
#ifdef UI_OUT
a3290 3
#else
      printf_filtered ("\tstop only in thread %d\n", b->thread);
#endif
a3295 1
#ifdef UI_OUT
a3305 8
#else
      if (ep_is_catchpoint (b))
	printf_filtered ("\tcatchpoint");
      else
	printf_filtered ("\tbreakpoint");
      printf_filtered (" already hit %d time%s\n",
		       b->hit_count, (b->hit_count == 1 ? "" : "s"));
#endif
a3307 1
#ifdef UI_OUT
a3312 1
#endif
a3316 1
#ifdef UI_OUT
a3319 3
#else
      printf_filtered ("\tignore next %d hits\n", b->ignore_count);
#endif
a3324 1
#ifdef UI_OUT
a3327 7
#else
      while (l)
	{
	  print_command_line (l, 4, gdb_stdout);
	  l = l->next;
	}
#endif
a3328 1
#ifdef UI_OUT
a3330 1
#endif
a3407 1
#ifdef UI_OUT
a3411 1
#endif /* UI_OUT */
a3412 1
#ifdef UI_OUT
a3441 25
#else
  if (nr_printable_breakpoints > 0)
    {
      annotate_breakpoints_headers ();
      annotate_field (0);
      printf_filtered ("Num ");
      annotate_field (1);
      printf_filtered ("Type           ");
      annotate_field (2);
      printf_filtered ("Disp ");
      annotate_field (3);
      printf_filtered ("Enb ");
      if (addressprint)
	{
	  annotate_field (4);
	  if (TARGET_ADDR_BIT <= 32)
	    printf_filtered ("Address    ");
	  else
	    printf_filtered ("Address            ");
	}
      annotate_field (5);
      printf_filtered ("What\n");
      annotate_breakpoints_table ();
    }
#endif /* UI_OUT */
a3452 2

#ifdef UI_OUT
a3453 1
#endif /* UI_OUT */
a3456 1
#ifdef UI_OUT
a3461 6
#else
      if (bnum == -1)
	printf_filtered ("No breakpoints or watchpoints.\n");
      else
	printf_filtered ("No breakpoint or watchpoint number %d.\n", bnum);
#endif /* UI_OUT */
a4201 1
#ifdef UI_OUT
a4206 1
#endif /* UI_OUT */
a4221 1
#ifdef UI_OUT
a4239 11
#else
    case bp_watchpoint:
      printf_filtered ("Watchpoint %d: ", b->number);
      print_expression (b->exp, gdb_stdout);
      break;
    case bp_hardware_watchpoint:
      printf_filtered ("Hardware watchpoint %d: ", b->number);
      print_expression (b->exp, gdb_stdout);
      break;
#endif
#ifdef UI_OUT
a4257 11
#else
    case bp_read_watchpoint:
      printf_filtered ("Hardware read watchpoint %d: ", b->number);
      print_expression (b->exp, gdb_stdout);
      break;
    case bp_access_watchpoint:
      printf_filtered ("Hardware access (read/write) watchpoint %d: ", 
		       b->number);
      print_expression (b->exp, gdb_stdout);
      break;
#endif
a4258 1
#ifdef UI_OUT
a4263 1
#endif
a4267 1
#ifdef UI_OUT
a4272 1
#endif
a4323 1
#ifdef UI_OUT
a4324 2
#endif
#ifdef UI_OUT
a4326 1
#endif
a5325 1
#ifdef UI_OUT
d5331 1
a5331 1
#endif
a5337 1
#ifdef UI_OUT
d5343 1
a5343 1
#endif
a5349 1
#ifdef UI_OUT
d5355 1
a5355 1
#endif
@


1.56
log
@	* arch-utils.c (generic_in_function_epilogue_p): New function.
	* arch-utils.h (generic_in_function_epilogue_p): Declare extern.
	* breakpoint.c (watchpoint_check): Add test whether the pc is
	currently in the epilogue of a function.
	* gdbarch.c: Autogenerated from gdbarch.sh.
	* gdbarch.h: Ditto.
	* gdbarch.sh (function_list): Add `in_function_epilogue_p' definition.
@
text
@d7017 23
a7039 2
      /* In case we have a problem, disable this breakpoint.  We'll restore
         its status if we succeed.  */
d7041 2
a7042 1
      b->enable_state = bp_disabled;
@


1.55
log
@* breakpoint.h, breakpoint.c: Ditto.
@
text
@d2311 8
@


1.54
log
@2001-10-12  Daniel Jacobowitz  <drow@@mvista.com>

        * symtab.h (struct block): (ALL_BLOCK_SYMBOLS): New macro.

        * symtab.c (find_pc_sect_symtab): Use ALL_BLOCK_SYMBOLS.
        (make_symbol_completion_list): Likewise.
        (make_symbol_overload_list): Likewise.
        * buildsym.c (finish_block): Likewise.
        * breakpoint.c (get_catch_sals):  Likewise.
        * mdebugread.c (mylookup_symbol): Likewise.
        * objfiles.c (objfile_relocate): Likewise.
        * printcmd.c (print_frame_args): Likewise.
        * stack.c (print_block_frame_locals): Likewise.
        (print_block_frame_labels): Likewise.
        (print_frame_arg_vars): Likewise.
        * symmisc.c (dump_symtab): Likewise.
        * tracepoint.c (add_local_symbols): Likewise.
        (scope_info): Likewise.

2001-10-12  Daniel Jacobowitz  <drow@@mvista.com>

        * mi-cmd-stack.c (list_args_or_locals): Use ALL_BLOCK_SYMBOLS.

2001-10-12  Daniel Jacobowitz  <drow@@mvista.com>

        * generic/gdbtk-cmds.c (gdb_listfuncs): Use ALL_BLOCK_SYMBOLS.
        * generic/gdbtk-stack.c (gdb_block_vars): Likewise.
        (gdb_get_blocks): Likewise.
        (gdb_get_vars_command): Likewise.
5~
@
text
@d380 1
a380 1
      value_ptr val;
d869 2
a870 2
	value_ptr mark = value_mark ();
	value_ptr v;
d1309 2
a1310 1
      value_ptr v, n;
d2254 1
a2254 1
  value_ptr mark = value_mark ();
d2325 2
a2326 2
      value_ptr mark = value_mark ();
      value_ptr new_val = evaluate_expression (bs->breakpoint_at->exp);
d2547 1
a2547 1
	value_ptr v;
@


1.53
log
@Add ui_out parameter to libgdb functions.
@
text
@a5873 1
	      int nsyms;
d5877 1
a5877 3
	      nsyms = BLOCK_NSYMS (b);

	      for (i = 0; i < nsyms; i++)
a5878 1
		  sym = BLOCK_SYM (b, i);
@


1.52
log
@	The following changes avoid polluting global namespace with the
	`enable' and `disable' identifiers, because some platforms define
	in their system headers symbols with global scope that go by those
	names.

	* breakpoint.h (enum enable_state): Rename from `enum enable'.
	Also rename all the enum members to have the "bp_" prefix.
	(struct breakpoint): Rename the `enable' member to `enable_state'.
	(enum bpdisp): Rename all members to have the "disp_" prefix.

	* breakpoint.c: All users of `enum enable' and `enum bpdisp'
	changed.
	(args_for_catchpoint_enable): Rename the `enable' member to
	`enable_p'.  All users changed.

	* tracepoint.h (enum enable): Remove.
	(struct tracepoint): The member `enabled' is now `int enabled_p'.

	* tracepoint.c: All users of the `enabled' member changed.

	* printcmd.c (struct display): The `status' member is now an int.

	* memattr.h (struct mem_region): Rename the `status' member to
	`enabled_p'.
	(enum enable): Remove.

	* memattr.c: Change all users of the `status' member of struct
	mem_region to use `enabled_p' instead.

	* infcmd.c (run_stack_dummy): Use disp_del instead of del.

	* go32-nat.c: Remove the kludgey work-around for conflicts between
	<dos.h> and "breakpoint.h".
	* tui/tuiSourceWin.c: Use disp_del instead of del.

	* tui/tuiSource.c: Use disp_del instead of del.

	* tui/tuiDisassem.c: Use disp_del instead of del.
@
text
@d3529 1
a3529 1
do_captured_breakpoint_query (void *data)
d3546 1
a3546 1
gdb_breakpoint_query (/* output object, */ int bnum)
d3552 2
a3553 2
  return catch_errors (do_captured_breakpoint_query, &args,
		       NULL, RETURN_MASK_ALL);
@


1.51
log
@Move libgdb library functions to gdb.h (new file).
Update everything related to this.
@
text
@d140 1
a140 1
    int enable;
d726 1
a726 1
    if (b->enable == permanent)
d738 3
a740 3
	&& b->enable != disabled
	&& b->enable != shlib_disabled
	&& b->enable != call_disabled
d779 1
a779 1
		b->enable = shlib_disabled;
d807 3
a809 3
	     && b->enable != disabled
	     && b->enable != shlib_disabled
	     && b->enable != call_disabled
d827 1
a827 1
	    b->enable = disabled;
d836 1
a836 1
	    args.enable = 1;
d851 1
a851 1
		b->enable = disabled;
d862 2
a863 2
	     && b->enable == enabled
	     && b->disposition != del_at_next_stop
d970 2
a971 2
	      b->related_breakpoint->disposition = del_at_next_stop;
	    b->disposition = del_at_next_stop;
d985 1
a985 1
	     && b->enable == enabled
d1254 1
a1254 1
  if (b->enable == permanent)
d1306 1
a1306 1
	   && b->enable == enabled
d1361 1
a1361 1
	   && b->enable == enabled
d1386 1
a1386 1
	   && b->enable == enabled
d1397 1
a1397 1
	   && b->enable == enabled
d1508 2
a1509 2
    if ((b->enable == enabled
	 || b->enable == permanent)
d1516 1
a1516 1
	else if (b->enable == permanent)
d1594 3
a1596 3
    if (b->enable != disabled
	&& b->enable != shlib_disabled
	&& b->enable != call_disabled
d2371 2
a2372 2
	b->related_breakpoint->disposition = del_at_next_stop;
      b->disposition = del_at_next_stop;
d2424 3
a2426 3
    if (b->enable == disabled
	|| b->enable == shlib_disabled
	|| b->enable == call_disabled)
d2533 2
a2534 2
	      b->related_breakpoint->disposition = del_at_next_stop;
	    b->disposition = del_at_next_stop;
d2605 2
a2606 2
		b->related_breakpoint->disposition = del_at_next_stop;
	      b->disposition = del_at_next_stop;
d2665 2
a2666 2
	    if (b->disposition == disable)
	      b->enable = disabled;
d3007 1
a3007 1
    if (b->enable == enabled && b->type == bp_watchpoint)
d3018 1
a3018 1
    if ((b->enable == enabled) &&
d3177 1
a3177 1
  ui_out_field_fmt (uiout, "enabled", "%c", bpenables[(int) b->enable]);
d3180 1
a3180 1
  printf_filtered ("%-3c ", bpenables[(int) b->enable]);
d3752 4
a3755 4
			     ((b->enable == disabled || 
			       b->enable == shlib_disabled || 
			       b->enable == call_disabled) ? " (disabled)" 
			      : b->enable == permanent ? " (permanent)"
d3832 3
a3834 3
    if (b->enable != disabled
	&& b->enable != shlib_disabled
	&& b->enable != call_disabled
d3840 1
a3840 1
      if (b->enable == permanent)
d3871 3
a3873 3
	    if (b->enable != disabled
		&& b->enable != shlib_disabled
		&& b->enable != call_disabled
d3916 1
a3916 1
  b->enable = enabled;
d3953 1
a3953 1
  b->enable = permanent;
d3983 2
a3984 2
  b->disposition = donttouch;
  b->enable = disabled;
d4005 1
a4005 1
      b->enable = enabled;
d4019 1
a4019 1
      b->enable = disabled;
d4037 2
a4038 2
  b->disposition = donttouch;
  b->enable = enabled;
d4078 1
a4078 1
  b->disposition = donttouch;
d4098 1
a4098 1
	b->enable == enabled &&
d4102 1
a4102 1
	b->enable = shlib_disabled;
d4125 1
a4125 1
    if (b->enable == shlib_disabled)
d4132 1
a4132 1
	b->enable = enabled;
d4199 2
a4200 2
  b->enable = enabled;
  b->disposition = tempflag ? del : donttouch;
d4251 2
a4252 2
  b->enable = enabled;
  b->disposition = tempflag ? del : donttouch;
d4290 2
a4291 2
  b->enable = enabled;
  b->disposition = tempflag ? del : donttouch;
d4304 1
a4304 1
    if (b->type == bp_hardware_breakpoint && b->enable == enabled)
d4320 1
a4320 1
    if (b->enable == enabled)
d4327 1
a4327 1
		 && b->enable == enabled)
d4349 1
a4349 1
      b->enable = enabled;
d4371 1
a4371 1
	&& (b->enable == enabled))
d4373 1
a4373 1
	b->enable = call_disabled;
d4391 1
a4391 1
	&& (b->enable == call_disabled))
d4393 1
a4393 1
	b->enable = enabled;
d4410 2
a4411 2
  b->enable = enabled;
  b->disposition = donttouch;
d4639 1
a4639 1
	b->enable = enabled;
d4864 1
a4864 1
		      tempflag ? del : donttouch,
d4976 1
a4976 1
		      args->tempflag ? del : donttouch,
d5442 1
a5442 1
  b->disposition = donttouch;
d5481 1
a5481 1
	  scope_breakpoint->enable = enabled;
d5484 1
a5484 1
	  scope_breakpoint->disposition = del;
d6235 2
a6236 2
  b->enable = enabled;
  b->disposition = tempflag ? del : donttouch;
d6299 1
a6299 1
  sal = target_enable_exception_callback (args->kind, args->enable);
d6399 2
a6400 2
      b->enable = enabled;
      b->disposition = tempflag ? del : donttouch;
d6429 2
a6430 2
  b->disposition = del;
  b->enable = enabled;
d6754 1
a6754 1
    if (bs->breakpoint_at && bs->breakpoint_at->disposition == del
d6760 1
a6760 1
    if (b->disposition == del_at_next_stop)
d6820 1
a6820 1
      args.enable = 0;
d6848 3
a6850 3
	    && b->enable != disabled
	    && b->enable != shlib_disabled
	    && b->enable != call_disabled)
d6858 1
a6858 1
	  if (b->enable == permanent)
d6994 1
a6994 1
  enum enable save_enable;
d7014 2
a7015 2
      save_enable = b->enable;
      b->enable = disabled;
d7071 1
a7071 1
	  b->enable = save_enable;	/* Restore it, this worked. */
d7115 1
a7115 1
      if (b->enable == enabled)
d7336 1
a7336 1
  if (bpt->enable == permanent)
d7339 1
a7339 1
  bpt->enable = disabled;
d7403 2
a7404 2
  if (bpt->enable != permanent)
    bpt->enable = enabled;
d7428 1
a7428 1
	      bpt->enable = disabled;
d7462 1
a7462 1
	      bpt->enable = disabled;
d7524 1
a7524 1
  do_enable_breakpoint (bpt, disable);
d7537 1
a7537 1
  do_enable_breakpoint (bpt, del);
@


1.51.2.1
log
@	The following changes avoid polluting global namespace with the
	`enable' and `disable' identifiers, because some platforms define
	in their system headers symbols with global scope that go by those
	names.

	* breakpoint.h (enum enable_state): Rename from `enum enable'.
	Also rename all the enum members to have the "bp_" prefix.
	(struct breakpoint): Rename the `enable' member to `enable_state'.
	(enum bpdisp): Rename all members to have the "disp_" prefix.

	* breakpoint.c: All users of `enum enable' and `enum bpdisp'
	changed.
	(args_for_catchpoint_enable): Rename the `enable' member to
	`enable_p'.  All users changed.

	* tracepoint.h (enum enable): Remove.
	(struct tracepoint): The member `enabled' is now `int enabled_p'.

	* tracepoint.c: All users of the `enabled' member changed.

	* printcmd.c (struct display): The `status' member is now an int.

	* memattr.h (struct mem_region): Rename the `status' member to
	`enabled_p'.
	(enum enable): Remove.

	* memattr.c: Change all users of the `status' member of struct
	mem_region to use `enabled_p' instead.

	* infcmd.c (run_stack_dummy): Use disp_del instead of del.

	* go32-nat.c: Remove the kludgey work-around for conflicts between
	<dos.h> and "breakpoint.h".

	* tui/tuiSourceWin.c: Use disp_del instead of del.

	* tui/tuiSource.c: Use disp_del instead of del.

	* tui/tuiDisassem.c: Use disp_del instead of del.
@
text
@d140 1
a140 1
    int enable_p;
d726 1
a726 1
    if (b->enable_state == bp_permanent)
d738 3
a740 3
	&& b->enable_state != bp_disabled
	&& b->enable_state != bp_shlib_disabled
	&& b->enable_state != bp_call_disabled
d779 1
a779 1
		b->enable_state = bp_shlib_disabled;
d807 3
a809 3
	     && b->enable_state != bp_disabled
	     && b->enable_state != bp_shlib_disabled
	     && b->enable_state != bp_call_disabled
d827 1
a827 1
	    b->enable_state = bp_disabled;
d836 1
a836 1
	    args.enable_p = 1;
d851 1
a851 1
		b->enable_state = bp_disabled;
d862 2
a863 2
	     && b->enable_state == bp_enabled
	     && b->disposition != disp_del_at_next_stop
d970 2
a971 2
	      b->related_breakpoint->disposition = disp_del_at_next_stop;
	    b->disposition = disp_del_at_next_stop;
d985 1
a985 1
	     && b->enable_state == bp_enabled
d1254 1
a1254 1
  if (b->enable_state == bp_permanent)
d1306 1
a1306 1
	   && b->enable_state == bp_enabled
d1361 1
a1361 1
	   && b->enable_state == bp_enabled
d1386 1
a1386 1
	   && b->enable_state == bp_enabled
d1397 1
a1397 1
	   && b->enable_state == bp_enabled
d1508 2
a1509 2
    if ((b->enable_state == bp_enabled
	 || b->enable_state == bp_permanent)
d1516 1
a1516 1
	else if (b->enable_state == bp_permanent)
d1594 3
a1596 3
    if (b->enable_state != bp_disabled
	&& b->enable_state != bp_shlib_disabled
	&& b->enable_state != bp_call_disabled
d2371 2
a2372 2
	b->related_breakpoint->disposition = disp_del_at_next_stop;
      b->disposition = disp_del_at_next_stop;
d2424 3
a2426 3
    if (b->enable_state == bp_disabled
	|| b->enable_state == bp_shlib_disabled
	|| b->enable_state == bp_call_disabled)
d2533 2
a2534 2
	      b->related_breakpoint->disposition = disp_del_at_next_stop;
	    b->disposition = disp_del_at_next_stop;
d2605 2
a2606 2
		b->related_breakpoint->disposition = disp_del_at_next_stop;
	      b->disposition = disp_del_at_next_stop;
d2665 2
a2666 2
	    if (b->disposition == disp_disable)
	      b->enable_state = bp_disabled;
d3007 1
a3007 1
    if (b->enable_state == bp_enabled && b->type == bp_watchpoint)
d3018 1
a3018 1
    if ((b->enable_state == bp_enabled) &&
d3177 1
a3177 1
  ui_out_field_fmt (uiout, "enabled", "%c", bpenables[(int) b->enable_state]);
d3180 1
a3180 1
  printf_filtered ("%-3c ", bpenables[(int) b->enable_state]);
d3752 4
a3755 4
			     ((b->enable_state == bp_disabled || 
			       b->enable_state == bp_shlib_disabled || 
			       b->enable_state == bp_call_disabled) ? " (disabled)" 
			      : b->enable_state == bp_permanent ? " (permanent)"
d3832 3
a3834 3
    if (b->enable_state != bp_disabled
	&& b->enable_state != bp_shlib_disabled
	&& b->enable_state != bp_call_disabled
d3840 1
a3840 1
      if (b->enable_state == bp_permanent)
d3871 3
a3873 3
	    if (b->enable_state != bp_disabled
		&& b->enable_state != bp_shlib_disabled
		&& b->enable_state != bp_call_disabled
d3916 1
a3916 1
  b->enable_state = bp_enabled;
d3953 1
a3953 1
  b->enable_state = bp_permanent;
d3983 2
a3984 2
  b->disposition = disp_donttouch;
  b->enable_state = bp_disabled;
d4005 1
a4005 1
      b->enable_state = bp_enabled;
d4019 1
a4019 1
      b->enable_state = bp_disabled;
d4037 2
a4038 2
  b->disposition = disp_donttouch;
  b->enable_state = bp_enabled;
d4078 1
a4078 1
  b->disposition = disp_donttouch;
d4098 1
a4098 1
	b->enable_state == bp_enabled &&
d4102 1
a4102 1
	b->enable_state = bp_shlib_disabled;
d4125 1
a4125 1
    if (b->enable_state == bp_shlib_disabled)
d4132 1
a4132 1
	b->enable_state = bp_enabled;
d4199 2
a4200 2
  b->enable_state = bp_enabled;
  b->disposition = tempflag ? disp_del : disp_donttouch;
d4251 2
a4252 2
  b->enable_state = bp_enabled;
  b->disposition = tempflag ? disp_del : disp_donttouch;
d4290 2
a4291 2
  b->enable_state = bp_enabled;
  b->disposition = tempflag ? disp_del : disp_donttouch;
d4304 1
a4304 1
    if (b->type == bp_hardware_breakpoint && b->enable_state == bp_enabled)
d4320 1
a4320 1
    if (b->enable_state == bp_enabled)
d4327 1
a4327 1
		 && b->enable_state == bp_enabled)
d4349 1
a4349 1
      b->enable_state = bp_enabled;
d4371 1
a4371 1
	&& (b->enable_state == bp_enabled))
d4373 1
a4373 1
	b->enable_state = bp_call_disabled;
d4391 1
a4391 1
	&& (b->enable_state == bp_call_disabled))
d4393 1
a4393 1
	b->enable_state = bp_enabled;
d4410 2
a4411 2
  b->enable_state = bp_enabled;
  b->disposition = disp_donttouch;
d4639 1
a4639 1
	b->enable_state = bp_enabled;
d4864 1
a4864 1
		      tempflag ? disp_del : disp_donttouch,
d4976 1
a4976 1
		      args->tempflag ? disp_del : disp_donttouch,
d5442 1
a5442 1
  b->disposition = disp_donttouch;
d5481 1
a5481 1
	  scope_breakpoint->enable_state = bp_enabled;
d5484 1
a5484 1
	  scope_breakpoint->disposition = disp_del;
d6235 2
a6236 2
  b->enable_state = bp_enabled;
  b->disposition = tempflag ? disp_del : disp_donttouch;
d6299 1
a6299 1
  sal = target_enable_exception_callback (args->kind, args->enable_p);
d6399 2
a6400 2
      b->enable_state = bp_enabled;
      b->disposition = tempflag ? disp_del : disp_donttouch;
d6429 2
a6430 2
  b->disposition = disp_del;
  b->enable_state = bp_enabled;
d6754 1
a6754 1
    if (bs->breakpoint_at && bs->breakpoint_at->disposition == disp_del
d6760 1
a6760 1
    if (b->disposition == disp_del_at_next_stop)
d6820 1
a6820 1
      args.enable_p = 0;
d6848 3
a6850 3
	    && b->enable_state != bp_disabled
	    && b->enable_state != bp_shlib_disabled
	    && b->enable_state != bp_call_disabled)
d6858 1
a6858 1
	  if (b->enable_state == bp_permanent)
d6994 1
a6994 1
  enum enable_state save_enable;
d7014 2
a7015 2
      save_enable = b->enable_state;
      b->enable_state = bp_disabled;
d7071 1
a7071 1
	  b->enable_state = save_enable;	/* Restore it, this worked. */
d7115 1
a7115 1
      if (b->enable_state == bp_enabled)
d7336 1
a7336 1
  if (bpt->enable_state == bp_permanent)
d7339 1
a7339 1
  bpt->enable_state = bp_disabled;
d7403 2
a7404 2
  if (bpt->enable_state != bp_permanent)
    bpt->enable_state = bp_enabled;
d7428 1
a7428 1
	      bpt->enable_state = bp_disabled;
d7462 1
a7462 1
	      bpt->enable_state = bp_disabled;
d7524 1
a7524 1
  do_enable_breakpoint (bpt, disp_disable);
d7537 1
a7537 1
  do_enable_breakpoint (bpt, disp_del);
@


1.51.2.2
log
@From Mark Kettenis  <kettenis@@gnu.org>:
* breakpoint.c (breakpoint_re_set_one): Don't discard SHLIB
breakpoints when they fail.
@
text
@d7012 2
a7013 23
      /* HACK: cagney/2001-11-11: kettenis/2001-11-11: MarkK wrote:

	 ``And a hack it is, although Apple's Darwin version of GDB
	 contains an almost identical hack to implement a "future
	 break" command.  It seems to work in many real world cases,
	 but it is easy to come up with a test case where the patch
	 doesn't help at all.''

	 ``It seems that the way GDB implements breakpoints - in -
	 shared - libraries was designed for a.out shared library
	 systems (SunOS 4) where shared libraries were loaded at a
	 fixed address in memory.  Since ELF shared libraries can (and
	 will) be loaded at any address in memory, things break.
	 Fixing this is not trivial.  Therefore, I'm not sure whether
	 we should add this hack to the branch only.  I cannot
	 guarantee that things will be fixed on the trunk in the near
	 future.''

         In case we have a problem, disable this breakpoint.  We'll
         restore its status if we succeed.  Don't disable a
         shlib_disabled breakpoint though.  There's a fair chance we
         can't re-set it if the shared library it's in hasn't been
         loaded yet.  */
d7015 1
a7015 2
      if (b->enable_state != bp_shlib_disabled)
        b->enable_state = bp_disabled;
@


1.50
log
@	* utils.c (query): Remove tui hacks; tui must use the query_hook.
	* top.c (command_loop): Remove tui insert_mode hacks; don't call
	tuiCleanUp because this must be made with atexit by tui.
	* symfile.c (symbol_file_command): Remove call to TUIDO
	* stack.c (show_and_print_stack_frame_stub): Remove tui check;
	not necessary when using the selected frame hooks.
	(print_stack_frame_stub): Likewise.
	(print_frame_info_base): Likewise.
	(print_frame_info): Likewise.
	(up_silently_command): Likewise.
	(down_silently_command): Likewise.
	(show_stack_frame): Likewise for TUIDO.
	(select_frame): Likewise.
	(select_and_print_frame): Likewise.
	(stack_publish_stopped_with_no_frame): Remove.
	(select_and_maybe_print_frame): Remove.
	* main.c (captured_main): Remove tui_fileopen and tuiInit; tui
	must use the initialize ui hook.
	* infrun.c (normal_stop): Remove call to TUIDO; tui must use the
	selected frame hooks.
	* event-top.c (command_handler): Remove tui insert_mode hack.
	* defs.h: Remove TUIDO; Only include tui.h.
	* breakpoint.c (mention): Remove calls to TUIDO.
	(delete_breakpoint): Remove tui hacks; tui must install
	the breakpoint hooks.
@
text
@d44 1
@


1.49
log
@Replace:
  if (interpreter_p && strncmp (interpreter_p, "mi", 2) == 0)
with:
  if (ui_out_is_mi_like_p (uiout))
@
text
@a4578 2
      TUIDO (((TuiOpaqueFuncPtr) tui_vAllSetHasBreakAt, b, 1));
      TUIDO (((TuiOpaqueFuncPtr) tuiUpdateAllExecInfos));
a6829 20
    }

  /* Before turning off the visuals for the bp, check to see that
     there are no other bps at the same address. */
  if (tui_version)
    {
      int clearIt;

      ALL_BREAKPOINTS (b)
      {
	clearIt = (b->address != bpt->address);
	if (!clearIt)
	  break;
      }

      if (clearIt)
	{
	  TUIDO (((TuiOpaqueFuncPtr) tui_vAllSetHasBreakAt, bpt, 0));
	  TUIDO (((TuiOpaqueFuncPtr) tuiUpdateAllExecInfos));
	}
@


1.49.2.1
log
@Typesystem work initial import.
Note that this currently isn't building, i'm in the middle of converting make_function_type/lookup_function_type
@
text
@d78 1
d5757 178
d6279 1
d6311 102
@


1.48
log
@2001-06-28  Michael Snyder  <msnyder@@redhat.com>

	* infrun.c (handle_inferior_event): Replace prev_pc test in all
	calls to bpstat_stop_status (removed in 1999-09-24).  This test
	helps distinguish stepping over a breakpoint trap from stepping
	thru a jump to the instruction after a breakpoint trap.
	(handle_inferior_event): Don't bother writing the PC if
	DECR_PC_AFTER_BREAK is zero (optimization).
	* breakpoint.c (bpstat_stop_status): Add comment explaining the
	purpose and usage of the "not_a_breakpoint" argument in computing
	the breakpoint address.
@
text
@d1892 1
a1892 1
      if (interpreter_p && strncmp (interpreter_p, "mi", 2) == 0)
d2037 1
a2037 1
	  if (interpreter_p && strncmp (interpreter_p, "mi", 2) == 0)
d2067 1
a2067 1
      if (interpreter_p && strncmp (interpreter_p, "mi", 2) == 0)
d2091 1
a2091 1
	  if (interpreter_p && strncmp (interpreter_p, "mi", 2) == 0)
d2105 1
a2105 1
	  if (interpreter_p && strncmp (interpreter_p, "mi", 2) == 0)
d2142 1
a2142 1
      if (interpreter_p && strncmp (interpreter_p, "mi", 2) == 0)
d2150 1
a2150 1
      if (interpreter_p && strncmp (interpreter_p, "mi", 2) == 0)
d2357 1
a2357 1
      if (interpreter_p && strncmp (interpreter_p, "mi", 2) == 0)
d3484 1
a3484 1
  if (interpreter_p && strncmp (interpreter_p, "mi", 2) == 0)
d4512 1
a4512 1
      if (interpreter_p && strncmp (interpreter_p, "mi", 2) == 0)
d4523 1
a4523 1
      if (interpreter_p && strncmp (interpreter_p, "mi", 2) == 0)
d4586 1
a4586 1
  if (interpreter_p && strncmp (interpreter_p, "mi", 2) == 0)
@


1.47
log
@Always send the breakpoint table headers to ui-out.  MI/CLI can
internally decide if they should be displayed.
@
text
@d2412 6
a2417 1
  /* Get the address where the breakpoint would have been.  */
@


1.46
log
@* ui-out.h (ui_out_table_header): Add parameter ``col_name''.
(table_header_ftype): Ditto.
* cli-out.c (cli_table_header): Update.
* ui-out.c (ui_out_table_header): Update.
(uo_table_header): Update.
(default_table_header): Update.
(append_header_to_list): Update.
(struct ui_out_header): Add field ``col_name''.
(append_header_to_list): Use xstrdup.  Initialize col_name.
* breakpoint.c (breakpoint_1): Pass COL_NAME to
ui_out_table_header.
@
text
@d3601 14
a3614 11
    {
      annotate_breakpoints_headers ();
      annotate_field (0);
      ui_out_table_header (uiout, 3, ui_left, "number", "Num");		/* 1 */
      annotate_field (1);
      ui_out_table_header (uiout, 14, ui_left, "type", "Type");		/* 2 */
      annotate_field (2);
      ui_out_table_header (uiout, 4, ui_left, "disp", "Disp");		/* 3 */
      annotate_field (3);
      ui_out_table_header (uiout, 3, ui_left, "enabled", "Enb");	/* 4 */
      if (addressprint)
d3616 2
a3617 1
	  annotate_field (4);
d3623 6
a3628 5
      annotate_field (5);
      ui_out_table_header (uiout, 40, ui_noalign, "what", "What");	/* 6 */
      ui_out_table_body (uiout);
      annotate_breakpoints_table ();
    }
@


1.45
log
@* cli-out.c: Include "gdb_assert.h'.
(struct ui_out_data): Add field ``suppress_output.
(cli_table_begin): When NR_ROWS is zero, suppress_output.
(cli_table_end): Clear suppress_output.
(cli_table_body): Check suppress_output.
(cli_table_header, cli_begin): Ditto.
(cli_end, cli_field_int, cli_field_skip): Ditto.
(cli_field_string, cli_field_fmt, cli_spaces): Ditto.
(cli_text, cli_message, cli_wrap_hint): Ditto.
* breakpoint.c (breakpoint_1): Close the ui_out table before
printing the breakpoint not found message.
@
text
@d3604 1
a3604 1
      ui_out_table_header (uiout, 3, ui_left, "Num");	/* 1 */
d3606 1
a3606 1
      ui_out_table_header (uiout, 14, ui_left, "Type");	/* 2 */
d3608 1
a3608 1
      ui_out_table_header (uiout, 4, ui_left, "Disp");	/* 3 */
d3610 1
a3610 1
      ui_out_table_header (uiout, 3, ui_left, "Enb");	/* 4 */
d3615 1
a3615 1
	    ui_out_table_header (uiout, 10, ui_left, "Address");	/* 5 */
d3617 1
a3617 1
	    ui_out_table_header (uiout, 18, ui_left, "Address");	/* 5 */
d3620 1
a3620 1
      ui_out_table_header (uiout, 40, ui_noalign, "What");	/* 6 */
@


1.44
log
@* ui-out.c (ui_out_table_begin): Add parameter ``nr_rows''.
(default_table_begin): Ditto.
* breakpoint.c (breakpoint_1): Pass nr_printable_breakpoints to
ui_out_table_begin.
Update everything.
@
text
@d3660 5
a3687 3
#ifdef UI_OUT
  ui_out_table_end (uiout);
#endif /* UI_OUT */
@


1.43
log
@* breakpoint.c (breakpoint_1): Restructure.  Compute the
nr_printable_breakpoints.  Move the header output to before the
main print breakpoints loop.
(user_settable_breakpoint): New function.
@
text
@d3594 1
a3594 1
    ui_out_table_begin (uiout, 6, "BreakpointTable");
d3596 1
a3596 1
    ui_out_table_begin (uiout, 5, "BreakpointTable");
@


1.42
log
@Recognize -i=mi0, -i=mi1 and -i=mi.
@
text
@d3550 24
a3573 3
/* Print information on breakpoint number BNUM, or -1 if all.
   If WATCHPOINTS is zero, process only breakpoints; if WATCHPOINTS
   is nonzero, process only watchpoints.  */
d3580 1
a3580 1
  int found_a_breakpoint = 0;
d3582 10
d3599 51
d3656 2
a3657 63
	if (!allflag
	    && b->type != bp_breakpoint
	    && b->type != bp_catch_load
	    && b->type != bp_catch_unload
	    && b->type != bp_catch_fork
	    && b->type != bp_catch_vfork
	    && b->type != bp_catch_exec
	    && b->type != bp_catch_catch
	    && b->type != bp_catch_throw
	    && b->type != bp_hardware_breakpoint
	    && b->type != bp_watchpoint
	    && b->type != bp_read_watchpoint
	    && b->type != bp_access_watchpoint
	    && b->type != bp_hardware_watchpoint)
	  continue;
	
	if (!found_a_breakpoint++)
	  {
	    annotate_breakpoints_headers ();
#ifdef UI_OUT
	    annotate_field (0);
	    ui_out_table_header (uiout, 3, ui_left, "Num");	/* 1 */
	    annotate_field (1);
	    ui_out_table_header (uiout, 14, ui_left, "Type");	/* 2 */
	    annotate_field (2);
	    ui_out_table_header (uiout, 4, ui_left, "Disp");	/* 3 */
	    annotate_field (3);
	    ui_out_table_header (uiout, 3, ui_left, "Enb");	/* 4 */
	    if (addressprint)
	      {
		annotate_field (4);
		if (TARGET_ADDR_BIT <= 32)
		  ui_out_table_header (uiout, 10, ui_left, "Address");	/* 5 */
		else
		  ui_out_table_header (uiout, 18, ui_left, "Address");	/* 5 */
	      }
	    annotate_field (5);
	    ui_out_table_header (uiout, 40, ui_noalign, "What");	/* 6 */
	    ui_out_table_body (uiout);
#else
	    annotate_field (0);
	    printf_filtered ("Num ");
	    annotate_field (1);
	    printf_filtered ("Type           ");
	    annotate_field (2);
	    printf_filtered ("Disp ");
	    annotate_field (3);
	    printf_filtered ("Enb ");
	    if (addressprint)
	      {
		annotate_field (4);
		if (TARGET_ADDR_BIT <= 32)
		  printf_filtered ("Address    ");
		else
		  printf_filtered ("Address            ");
	      }
	    annotate_field (5);
	    printf_filtered ("What\n");
#endif /* UI_OUT */
	    annotate_breakpoints_table ();
	  }
	
	print_one_breakpoint (b, &last_addr);
d3660 1
a3660 1
  if (!found_a_breakpoint)
@


1.41
log
@	* completer.c (gdb_completer_loc_break_characters): New variable.
	(line_completion_function): If we are completing on locations,
	back up the start of word pointer past all characters which can
	appear in a location spec.
	(location_completer): New function.

	* completer.h: Add prototype for location_completer.

	* symtab.c (make_source_files_completion_list)
	(add_filename_to_list, not_interesting_fname): New functions.
	(filename_seen): New function, body extracted from
	output_source_filename.
	(output_source_filename): Call filename_seen to check if the file
	was already printed.
	(make_symbol_completion_list): If TEXT includes a
	double-quoted string, return an empty list, not NULL.
	(make_file_symbol_completion_list): New function, similar to
	make_symbol_completion_list but with an additional argument
	SRCFILE.

	* symtab.h (make_file_symbol_completion_list)
	(make_source_files_completion_list): Add prototypes.

	* breakpoint.c (_initialize_breakpoint): Make location_completer
	be the completion function for all commands which set breakpoints
	and watchpoints.
	(top-level): #include "completer.h".

	* tracepoint.c (_initialize_tracepoint): Make location_completer
	be the completion function for the "trace" command.
	(top-level): #include "completer.h".

	* printcmd.c (_initialize_printcmd): Make location_completer be
	the completion function for the "print", "inspect", "call", and
	"disassemble" commands.
	(top-level): #include "completer.h".

	* infcmd.c (_initialize_infcmd): Make location_completer be the
	completion function for the "go", "jump", and "until" commands.
	(top-level): #include "completer.h".
@
text
@d1892 1
a1892 1
      if (interpreter_p && strcmp (interpreter_p, "mi") == 0)
d2037 1
a2037 1
	  if (interpreter_p && strcmp (interpreter_p, "mi") == 0)
d2067 1
a2067 1
      if (interpreter_p && strcmp (interpreter_p, "mi") == 0)
d2091 1
a2091 1
	  if (interpreter_p && strcmp (interpreter_p, "mi") == 0)
d2105 1
a2105 1
	  if (interpreter_p && strcmp (interpreter_p, "mi") == 0)
d2142 1
a2142 1
      if (interpreter_p && strcmp (interpreter_p, "mi") == 0)
d2150 1
a2150 1
      if (interpreter_p && strcmp (interpreter_p, "mi") == 0)
d2357 1
a2357 1
      if (interpreter_p && strcmp (interpreter_p, "mi") == 0)
d3479 1
a3479 1
  if (interpreter_p && strcmp (interpreter_p, "mi") == 0)
d4479 1
a4479 1
      if (interpreter_p && strcmp (interpreter_p, "mi") == 0)
d4490 1
a4490 1
      if (interpreter_p && strcmp (interpreter_p, "mi") == 0)
d4553 1
a4553 1
  if (interpreter_p && strcmp (interpreter_p, "mi") == 0)
@


1.40
log
@2001-06-08  Michael Snyder  <msnyder@@redhat.com>

	* breakpoint.c (delete_breakpoint): Pass mark_inserted to
        remove_breakpoint, so that the subsequent test for
        bpt->inserted will succeed, and duplicates will be fixed up.
@
text
@d43 1
d7586 2
a7587 2
  add_com ("tbreak", class_breakpoint, tbreak_command,
	   "Set a temporary breakpoint.  Args like \"break\" command.\n\
d7591 4
a7594 2
  add_com ("txbreak", class_breakpoint, tbreak_at_finish_command,
	   "Set temporary breakpoint at procedure exit.  Either there should\n\
d7596 1
d7598 2
a7599 2
  add_com ("hbreak", class_breakpoint, hbreak_command,
	   "Set a hardware assisted  breakpoint. Args like \"break\" command.\n\
d7602 1
d7604 2
a7605 2
  add_com ("thbreak", class_breakpoint, thbreak_command,
	   "Set a temporary hardware assisted breakpoint. Args like \"break\" command.\n\
d7608 1
d7710 2
a7711 2
  add_com ("break", class_breakpoint, break_command,
	   concat ("Set breakpoint at specified line or function.\n\
d7722 2
d7869 2
a7870 2
  add_com ("watch", class_breakpoint, watch_command,
	   "Set a watchpoint for an expression.\n\
d7873 1
d7875 2
a7876 2
  add_com ("rwatch", class_breakpoint, rwatch_command,
	   "Set a read watchpoint for an expression.\n\
d7879 1
d7881 2
a7882 2
  add_com ("awatch", class_breakpoint, awatch_command,
	   "Set a watchpoint for an expression.\n\
d7885 1
@


1.39
log
@2001-06-01  Michael Snyder  <msnyder@@redhat.com>

	* thread.c (delete_step_resume_breakpoint): New function.
	Maintain internal consistency of the thread list while deleting
	a step_resume_breakpoint.
	* gdbthread.h (delete_step_resume_breakpoint): Export.
	* breakpoint.c (bpstat_find_step_resume_breakpoint):
	Make thread-aware: don't return a step_resume_breakpoint
	for the wrong thread.
	* infrun.c (wait_for_inferior): Call delete_step_resume_breakpoint
	instead of delete_breakpoint_current_contents.
	(fetch_inferior_event): Ditto.
	(handle_inferior_event): Call delete_step_resume_breakpoint
	instead of delete_breakpoint.
@
text
@d6766 1
a6766 1
    remove_breakpoint (bpt, mark_uninserted);
@


1.38
log
@	* breakpoint.c (breakpoint_address_is_meaningful): New function.
	(check_duplicates): Don't compare non-meaningful addresses.
@
text
@d1722 2
d1727 2
d1732 3
a1734 1
	  (bsp->breakpoint_at->type == bp_step_resume))
@


1.37
log
@s/ui_out_list/ui_out_tupple/
@
text
@d3738 34
d3787 1
a3787 5
  /* Watchpoints are uninteresting.  */
  if (bpt->type == bp_watchpoint
      || bpt->type == bp_hardware_watchpoint
      || bpt->type == bp_read_watchpoint
      || bpt->type == bp_access_watchpoint)
d3795 2
a3796 1
	&& (overlay_debugging == 0 || b->section == section))
d3834 2
a3835 1
		&& (overlay_debugging == 0 || b->section == section))
@


1.36
log
@Add ``type'' parameter to set_raw_breakpoint().
@
text
@d2033 1
a2033 1
	  ui_out_list_begin (uiout, "value");
d2040 1
a2040 1
	  ui_out_list_end (uiout);
d2063 1
a2063 1
      ui_out_list_begin (uiout, "value");
d2067 1
a2067 1
      ui_out_list_end (uiout);
d2087 1
a2087 1
	  ui_out_list_begin (uiout, "value");
d2100 1
a2100 1
	  ui_out_list_begin (uiout, "value");
d2105 1
a2105 1
      ui_out_list_end (uiout);
d3129 1
a3129 1
  ui_out_list_begin (uiout, "bkpt");
d3493 1
a3493 1
      ui_out_list_begin (uiout, "script");
d3495 1
a3495 1
      ui_out_list_end (uiout);
d3505 1
a3505 1
  ui_out_list_end (uiout);
d4382 1
a4382 1
      ui_out_list_begin (uiout, "wpt");
d4387 1
a4387 1
      ui_out_list_end (uiout);
d4391 1
a4391 1
      ui_out_list_begin (uiout, "wpt");
d4396 1
a4396 1
      ui_out_list_end (uiout);
d4411 1
a4411 1
      ui_out_list_begin (uiout, "hw-rwpt");
d4416 1
a4416 1
      ui_out_list_end (uiout);
d4420 1
a4420 1
      ui_out_list_begin (uiout, "hw-awpt");
d4425 1
a4425 1
      ui_out_list_end (uiout);
@


1.35
log
@Consolidate save_inferior_ptid/restore_inferior_ptid implementation to
one source file.
@
text
@d94 1
a94 1
struct breakpoint *set_raw_breakpoint (struct symtab_and_line);
d3809 14
a3822 9
/* Low level routine to set a breakpoint.
   Takes as args the three things that every breakpoint must have.
   Returns the breakpoint object so caller can set other things.
   Does not set the breakpoint number!
   Does not print anything.

   ==> This routine should not be called if there is a chance of later
   error(); otherwise it leaves a bogus breakpoint on the chain.  Validate
   your arguments BEFORE calling this routine!  */
d3825 1
a3825 1
set_raw_breakpoint (struct symtab_and_line sal)
d3838 1
d3907 2
a3908 3
  b = set_raw_breakpoint (sal);
  if (!b)
    return;
a3909 1
  b->type = func_name != NULL ? bp_longjmp : bp_longjmp_resume;
d3961 1
a3961 2
  if ((b = set_raw_breakpoint (sal)) == NULL)
    return NULL;
a3964 2
  b->type = bp_thread_event;	/* XXX: do we need a new type? 
				   bp_thread_event */
d4003 1
a4003 1
  b = set_raw_breakpoint (sal);
a4005 1
  b->type = bp_shlib_event;
d4113 1
a4113 1
  b = set_raw_breakpoint (sals.sals[0]);
a4135 1
  b->type = bp_kind;
d4170 1
a4170 1
  b = set_raw_breakpoint (sal);
a4181 2
  b->type = bp_kind;

d4209 1
a4209 1
  b = set_raw_breakpoint (sal);
a4219 2
  b->type = bp_catch_exec;

d4336 1
a4336 2
  b = set_raw_breakpoint (sal);
  b->type = type;
d4560 1
a4560 1
	b = set_raw_breakpoint (sal);
a4562 1
	b->type = type;
d5362 5
d5368 1
a5368 1
  b = set_raw_breakpoint (sal);
a5390 5
  if (mem_cnt && target_resources_ok > 0)
    b->type = bp_type;
  else
    b->type = bp_watchpoint;

d5405 2
a5406 1
	  scope_breakpoint = set_raw_breakpoint (scope_sal);
a5409 1
	  scope_breakpoint->type = bp_watchpoint_scope;
d6139 1
d6144 13
a6156 1
  b = set_raw_breakpoint (*sal);
a6165 13
  switch (ex_event)
    {
    case EX_EVENT_THROW:
      b->type = bp_catch_throw;
      break;
    case EX_EVENT_CATCH:
      b->type = bp_catch_catch;
      break;
    default:			/* error condition */
      b->type = bp_none;
      b->enable = disabled;
      error ("Internal error -- invalid catchpoint kind");
    }
a6317 4
      b = set_raw_breakpoint (sal);
      set_breakpoint_count (breakpoint_count + 1);
      b->number = breakpoint_count;

d6323 3
a6325 1
      b->type = bp_breakpoint;	
d6356 1
a6356 3
  b = set_raw_breakpoint (sal);
  if (!b)
    error ("Internal error -- couldn't set temp exception breakpoint");
a6357 1
  b->type = bp_breakpoint;
d6493 1
a6493 1
  b = set_raw_breakpoint (sal);
a6495 1
  b->type = bp_breakpoint;
@


1.34
log
@* breakpoint.c (check_duplicates): Use the breakpoint's type, not
its address, to decide whether it's a watchpoint or not.  Zero
is a valid code address.
(update_breakpoints_after_exec): Admonishing comments.
* breakpoint.h (struct breakpoint): Doc fixes.
@
text
@d1064 1
a1064 1
  ptid_t saved_inferior_ptid = inferior_ptid;
d1066 2
a1067 2
  /* FIXME: use a cleanup, to insure that inferior_ptid gets replaced! */
  inferior_ptid = pid_to_ptid (pid);	/* Because remove_breakpoint will use this global. */
d1079 1
a1079 1
	    inferior_ptid = saved_inferior_ptid;
d1084 1
a1084 1
  inferior_ptid = saved_inferior_ptid;
d1224 1
a1224 1
  ptid_t saved_inferior_ptid = inferior_ptid;
d1229 2
a1230 2
  /* FIXME: use a cleanup, to insure that inferior_ptid gets replaced! */
  inferior_ptid = pid_to_ptid (pid);	/* Because remove_breakpoint will use this global. */
d1238 1
a1238 1
	    inferior_ptid = saved_inferior_ptid;
d1243 1
a1243 1
  inferior_ptid = saved_inferior_ptid;
@


1.33
log
@* breakpoint.c (check_duplicates): Take a breakpoint object as an
argument, rather than an address and section.  All callers changed.
@
text
@d1147 11
a1157 1
       automagically.  Certainly on HP-UX that's true. */
d1208 7
a1214 1
       to a target address, rather than reusing the old evaluation.  */
d3753 5
a3757 1
  if (address == 0)		/* Watchpoints are uninteresting */
@


1.32
log
@Phase 1 of the ptid_t changes.
@
text
@d96 1
a96 1
static void check_duplicates (CORE_ADDR, asection *);
d3722 1
a3722 1
/* Rescan breakpoints at address ADDRESS,
d3725 2
a3726 2
   If we have a permanent breakpoint at ADDRESS, make that one
   the official one, and the rest as duplicates.  */
d3729 1
a3729 1
check_duplicates (CORE_ADDR address, asection *section)
d3734 2
d3842 1
a3842 1
  check_duplicates (sal.pc, sal.section);
d3909 1
a3909 1
      check_duplicates (b->address, b->section);
d3923 1
a3923 1
      check_duplicates (b->address, b->section);
d4266 1
a4266 1
      check_duplicates (b->address, b->section);
d4286 1
a4286 1
	check_duplicates (b->address, b->section);
d4306 1
a4306 1
	check_duplicates (b->address, b->section);
d6775 1
a6775 1
  check_duplicates (bpt->address, bpt->section);
d7018 1
a7018 1
	  check_duplicates (b->address, b->section);
d7283 1
a7283 1
  check_duplicates (bpt->address, bpt->section);
d7348 1
a7348 1
  check_duplicates (bpt->address, bpt->section);
@


1.31
log
@2001-04-17  Michael Snyder  <msnyder@@redhat.com>

        * breakpoint.c (print_one_breakpoint): Handle 64-bit addresses.
	* tracepoint.c (tracepoints_info): Handle 64-bit addresses.
        * testsuite/gdb.trace/deltrace.exp: Allow for 64-bit addresses.
	* testsuite/gdb.trace/infotrace.exp: Ditto.
        * testsuite/gdb.trace/passcount.exp: Ditto.
	* testsuite/gdb.trace/while-stepping.exp: Ditto.
@
text
@d991 1
a991 1
	    val = target_insert_fork_catchpoint (inferior_pid);
d994 1
a994 1
	    val = target_insert_vfork_catchpoint (inferior_pid);
d997 1
a997 1
	    val = target_insert_exec_catchpoint (inferior_pid);
d1064 1
a1064 1
  int saved_inferior_pid = inferior_pid;
d1066 2
a1067 2
  /* FIXME: use a cleanup, to insure that inferior_pid gets replaced! */
  inferior_pid = pid;	/* Because remove_breakpoint will use this global. */
d1079 1
a1079 1
	    inferior_pid = saved_inferior_pid;
d1084 1
a1084 1
  inferior_pid = saved_inferior_pid;
d1208 1
a1208 1
  int saved_inferior_pid = inferior_pid;
d1210 2
a1211 2
  if (pid == inferior_pid)
    error ("Cannot detach breakpoints of inferior_pid");
d1213 2
a1214 2
  /* FIXME: use a cleanup, to insure that inferior_pid gets replaced! */
  inferior_pid = pid;	/* Because remove_breakpoint will use this global. */
d1222 1
a1222 1
	    inferior_pid = saved_inferior_pid;
d1227 1
a1227 1
  inferior_pid = saved_inferior_pid;
d1350 1
a1350 1
	  val = target_remove_fork_catchpoint (inferior_pid);
d1353 1
a1353 1
	  val = target_remove_vfork_catchpoint (inferior_pid);
d1356 1
a1356 1
	  val = target_remove_exec_catchpoint (inferior_pid);
d1568 1
a1568 1
breakpoint_thread_match (CORE_ADDR pc, int pid)
d1573 1
a1573 1
  thread = pid_to_thread_id (pid);
d2425 1
a2425 1
	&& (!SOLIB_HAVE_LOAD_EVENT (inferior_pid)
d2428 2
a2429 1
			    SOLIB_LOADED_LIBRARY_PATHNAME (inferior_pid)) 
d2437 1
a2437 1
	&& (!SOLIB_HAVE_UNLOAD_EVENT (inferior_pid)
d2440 2
a2441 1
			    SOLIB_UNLOADED_LIBRARY_PATHNAME (inferior_pid)) 
d2448 2
a2449 1
	&& !target_has_forked (inferior_pid, &b->forked_inferior_pid))
d2453 2
a2454 1
	&& !target_has_vforked (inferior_pid, &b->forked_inferior_pid))
d2458 1
a2458 1
	&& !target_has_execd (inferior_pid, &b->exec_pathname))
d3041 2
a3042 1
	dll_pathname = SOLIB_LOADED_LIBRARY_PATHNAME (inferior_pid);
d3044 2
a3045 1
	dll_pathname = SOLIB_UNLOADED_LIBRARY_PATHNAME (inferior_pid);
d4328 2
a4329 2
  if (in_thread_list (inferior_pid))
    b->thread = pid_to_thread_id (inferior_pid);
d5333 1
a5333 1
     TARGET_CAN_USE_HW_WATCHPOINT return FALSE if there was no inferior_pid
d6065 1
a6065 1
  SOLIB_CREATE_CATCH_LOAD_HOOK (inferior_pid, tempflag, 
d6107 1
a6107 1
  SOLIB_CREATE_CATCH_UNLOAD_HOOK (inferior_pid, tempflag, 
d7147 1
a7147 1
   - Else, reset it to the current thread for inferior_pid. */
d7153 2
a7154 2
      if (in_thread_list (inferior_pid))
	b->thread = pid_to_thread_id (inferior_pid);
@


1.30
log
@* arch-utils.c (#include "gdbthread.h"): Removed.
(#include "symfile.h"): Removed.
(XMALLOC): Removed unused macro.
* breakpoint.c (tbreak_command): Removed local declaration.
(awatch_command, do_enable_breakpoint, set_breakpoint_count):
Remove duplicate declarations.
(bpstat_should_step, bpstat_have_active_hw_watchpoints)
(remove_solib_event_breakpoints): Fix indentation botch.
* c-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
* ch-exp.c (ch_terminal_match_float_literal, parse_expr)
(parse_primval, parse_untyped_expr, parse_opt_untyped_expr):
Removed duplicate declarations.
* ch-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
* corefile.c (#include "frame.h"): Removed
(#include "symfile.h"): Removed.
(#include "language.h"): Removed.
* dbxread.c (#include "command.h"): Removed.
* environ.c (#include "gdbcore.h"): Removed.
* event-loop.c (#include "top.h"): Removed.
* f-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
(#include "language.h"): Removed.
(#include "typeprint.h"): Removed.
(#include "frame.h"): Removed.
* gdbtypes.h (print_type_scalar): Removed declaration.
* infcmd.c (#include "completer.h"): Removed.
* language.c (#include "frame.h"): Removed.
* m2-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
(#include "language.h"): Removed.
* m2-valprint.c (#include "valprint.h"): Removed.
* p-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
* p-valprint.c (#include "typeprint.h"): Removed.
* parse.c (#include "linespec.h"): Removed.
* regcache.c (#include "frame.h"): Removed.
* remote.c (#include "frame.h"): Removed.
(getpkt_sane): Make static.
* source.c (#include "completer.h"): Removed.
* stack.c (#include "symfile.h"): Removed.
(#include "objfiles.h"): Removed.
* symfile.c (#include "completer.h"): Removed.
* tracepoint.c (#include "completer.h"): Removed.
* values.c (#include "frame.h"): Removed.
* varobj.c (#include "valprint.h"): Removed.
* wrapper.c (#include "frame.h"): Removed.

* memattr.c (create_mem_region): Removed unused variable.
* remote-nrom.c: Removed spurious semicolon after init_nrom_ops.
-------------------------------------------------------------------
@
text
@d3151 6
a3156 1
    strcat (wrap_indent, "           ");
d3330 2
d3333 9
a3341 5
	  /* FIXME-32x64: need a print_address_numeric with
	     field width */
	  printf_filtered ("%s ",
			   local_hex_string_custom
			   ((unsigned long) b->address, "08l"));
d3576 4
a3579 1
		ui_out_table_header (uiout, 10, ui_left, "Address");	/* 5 */
d3596 4
a3599 1
		printf_filtered ("Address    ");
@


1.29
log
@Change SOFTWARE_SINGLE_STEP_P into SOFTWARE_SINGLE_STEP_P().
@
text
@a87 2
void tbreak_command (char *, int);

a210 4
static void awatch_command (char *, int);

static void do_enable_breakpoint (struct breakpoint *, enum bpdisp);

a216 2
void set_breakpoint_count (int);

d2975 1
a2975 1
    return 1;
d2990 1
a2990 1
    return 1;
d3945 1
a3945 1
    delete_breakpoint (b);
@


1.28
log
@	* breakpoint.c (print_it_typical) <bp_access_watchpoint> [UI_OUT]:
	Correct the order of calls to ui_out_field_string and
	ui_out_list_begin when bs->old_val is NULL.
@
text
@d2398 1
a2398 1
  bp_addr = *pc - (not_a_breakpoint && !SOFTWARE_SINGLE_STEP_P ? 
@


1.27
log
@Update/correct copyright notices.
@
text
@d2091 2
a2092 2
	    ui_out_list_begin (uiout, "value");
	  ui_out_field_string (uiout, "reason", "access-watchpoint-trigger");
@


1.26
log
@2001-02-28  Michael Snyder  <msnyder@@mvstp600e.cygnus.com>

	* breakpoint.c (print_one_breakpoint): Formatting clean-up.
	(read_memory_nobpt): Ditto.
	(ep_is_catchpoint): Ditto.
	(ep_is_shlib_catchpoint): Ditto.
	(ep_is_exception_catchpoint): Ditto.
	(describe_other_breakpoints): Ditto.
@
text
@d2 2
a3 2
   Copyright 1986, 87, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 1999,
   2000, 2001 Free Software Foundation, Inc.
@


1.25
log
@Add __FILE__ and __LINE__ parameter to internal_error() /
internal_verror().
@
text
@d200 3
a202 3
static void create_exception_catchpoint
  (int tempflag, char *cond_string,
   enum exception_event_kind ex_event, struct symtab_and_line *sal);
d204 2
a205 2
static void catch_exception_command_1
  (enum exception_event_kind ex_event, char *arg, int tempflag, int from_tty);
d699 3
a701 4
	  status = read_memory_nobpt
	    (bp_addr + bp_size,
	     myaddr + bp_addr + bp_size - memaddr,
	     memaddr + len - (bp_addr + bp_size));
d1615 1
a1615 2
    || (ep->type == bp_catch_throw)

a1617 1
    ;
d1625 1
a1625 2
    || (ep->type == bp_catch_unload)
    ;
d1633 1
a1633 2
    || (ep->type == bp_catch_throw)
    ;
d3336 3
a3338 4
	  printf_filtered
	    ("%s ",
	     local_hex_string_custom
	     ((unsigned long) b->address, "08l"));
d3678 9
a3686 9
	    printf_filtered
	      ("%d%s%s ",
	       b->number,
	       ((b->enable == disabled || 
		 b->enable == shlib_disabled || 
		 b->enable == call_disabled) ? " (disabled)" 
		: b->enable == permanent ? " (permanent)"
		: ""),
	       (others > 1) ? "," : ((others == 1) ? " and" : ""));
@


1.24
log
@Replace strsave() with xstrdup().
@
text
@d2185 2
a2186 1
      internal_error ("print_bp_stop_message: unrecognized enum value");
d3135 2
a3136 1
    internal_error ("bptypes table does not describe type #%d.",
d3168 2
a3169 1
      internal_error ("print_one_breakpoint: bp_none encountered\n");
d3756 2
a3757 1
	internal_error ("allegedly permanent breakpoint is not "
d3764 2
a3765 1
	      internal_error ("another breakpoint was inserted on top of "
d6790 2
a6791 1
	    internal_error ("another breakpoint was inserted on top of "
@


1.23
log
@* target.h (TARGET_REGION_SIZE_OK_FOR_HW_WATCHPOINT)
* breakpoint.c (TARGET_REGION_OK_FOR_HW_WATCHPOINT): Wrap macro
definition in parenthesis.
@
text
@d2 2
a3 2
   Copyright 1986, 87, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 1999, 2000
   Free Software Foundation, Inc.
d3874 1
a3874 1
    b->addr_string = strsave (func_name);
d3931 1
a3931 1
  b->addr_string = strsave (addr_string);
@


1.22
log
@Replace free() with xfree().
@
text
@d5412 1
a5412 1
     TARGET_REGION_SIZE_OK_FOR_HW_WATCHPOINT(LEN)
@


1.21
log
@2000-11-30  Fernando Nasser  <fnasser@@redhat.com>

        * linespec.h: New file. Declarations for linespec.c.
        * linespec.c, alpha-tdep.c, breakpoint.c, parse.c, source.c,
        symtab.c, tracepoint.c: Include the above.
        * completer.c: New file. Line completion stuff for GDB.
        (get_gdb_completer_word_break_characters,
        get_gdb_completer_quote_characters): New functions. Accessors for
        useful completer internal data.
        (filename_completer, line_completion_function, skip_quoted): Moved
        here from top.c.
        * completer.h: New file. Declarations for the above.
        * linespec.c (decode_line_1): Use
        get_gdb_completer_word_break_characters and
        get_gdb_completer_quote_characters.
        * top.c: Include completer.h.
        (filename_completer, line_completion_function, skip_quoted):
        Moved to completer.c.
        * corefile.c, exec.c, source.c, symfile.c, linespec.c: Include
        completer.h.
        * Makefile.in (SFILES): Add completer.c.
        (COMMON_OBS): Add completer.o.
        (completer.o): New target.
        (linespec.o, alpha-tdep.o, breakpoint.o, parse.o, source.o,
        symtab.o, tracepoint.o): Add linespec.h to dependencies list.
        (corefile.o, exec.o, source.o, symfile.o, linespec.o): Add completer.h
        to dependencies list.
@
text
@d541 1
a541 1
	  free ((PTR) b->cond);
d545 1
a545 1
	free ((PTR) b->cond_string);
d1658 1
a1658 1
      free ((PTR) p);
d3047 1
a3047 1
	free (ep->triggered_dll_pathname);
d4062 1
a4062 1
  old_chain = make_cleanup (free, sals.sals);
d4065 1
a4065 1
      make_cleanup (free, canonical);
d4068 1
a4068 1
	make_cleanup (free, canonical[0]);
d4681 1
a4681 1
  make_cleanup (free, sals.sals);
d4684 1
a4684 1
  make_cleanup (free, addr_string);
d4688 1
a4688 1
  make_cleanup (free, cond);
d4692 1
a4692 1
  make_cleanup (free, cond_string);
d4706 1
a4706 1
	make_cleanup (free, addr_string[i]);
d4740 1
a4740 1
	      make_cleanup (free, cond[i]);
d4743 1
a4743 1
	      make_cleanup (free, cond_string[i]);
d4822 1
a4822 1
  make_cleanup (free, addr_string);
d4825 1
a4825 1
  make_cleanup (free, sals.sals);
d4829 1
a4829 1
  make_cleanup (free, cond);
d4833 1
a4833 1
  make_cleanup (free, cond_string);
d4847 1
a4847 1
	make_cleanup (free, addr_string[i]);
d4869 1
a4869 1
	  make_cleanup (free, cond[i]);
d4971 1
a4971 1
	  free (addr_string);
d5040 2
a5041 2
  free (beg_addr_string);
  old_chain = make_cleanup (free, sals.sals);
d5053 1
a5053 1
	  free (break_string);
d5571 1
a5571 1
  free ((PTR) sals.sals);	/* malloc'd, so freed */
d6312 1
a6312 1
  free ((PTR) sals.sals);
d6647 1
a6647 1
  free ((PTR) sals.sals);
d6806 1
a6806 1
    free (bpt->cond);
d6808 1
a6808 1
    free (bpt->cond_string);
d6810 1
a6810 1
    free (bpt->addr_string);
d6812 1
a6812 1
    free (bpt->exp);
d6814 1
a6814 1
    free (bpt->exp_string);
d6818 1
a6818 1
    free (bpt->source_file);
d6820 1
a6820 1
    free (bpt->dll_pathname);
d6822 1
a6822 1
    free (bpt->triggered_dll_pathname);
d6824 1
a6824 1
    free (bpt->exec_pathname);
d6846 1
a6846 1
  free ((PTR) bpt);
d6956 1
a6956 1
		free ((PTR) b->cond);
d6975 1
a6975 1
		free (b->source_file);
d7004 1
a7004 1
      free ((PTR) sals.sals);
d7022 1
a7022 1
	free ((PTR) b->exp);
d7037 1
a7037 1
	    free ((PTR) b->cond);
@


1.20
log
@* remote.c (remote_write_bytes): Add default case to switch
initializing ``todo''. Ditto for ``nr_bytes''.
* top.c (catch_errors): Always initialize ``val''.
* solib.c (info_sharedlibrary_command): Handle bfd_get_arch_size
returning an unknown size.
* gdbtypes.c (count_virtual_fns): Always initialize ``vfuncs''.
* breakpoint.c (break_at_finish_at_depth_command_1): Initialise
extra_args to NULL.
(break_at_finish_command_1): Ditto.
@
text
@d42 1
@


1.19
log
@	* eval.c (parse_and_eval_long): New function.
	* value.h: Declare it.

	* breakpoint.c (breakpoints_info, maintenance_info_breakpoints):
	Call parse_and_eval_long, not parse_and_eval_address.
	* command.c (do_setshow_command): Ditto.
	* infcmd.c (step_1, signal_command, continue_command): Ditto.
	* infrun.c (signals_info): Ditto.
	* stack.c (set_backtrace_limit_command, backtrace_command_1,
	up_silently_base, down_silently_base): Ditto.
	* tracepoints.c (tracepoints_info, trace_find_command,
 	trace_find_tracepoint_command): Ditto.
	* valprint.c (set_radix): Ditto.
	* values.c (show_values): Ditto.
@
text
@d4908 3
a4910 1
  char *extra_args, *level_arg, *addr_string;
d4988 1
a4988 1
  char *extra_args;
@


1.18
log
@
Corrected spelling errors in comments.
gdbarch.{c,sh} removed a word from a comment.
@
text
@d3641 1
a3641 1
    bnum = parse_and_eval_address (bnum_exp);
d3653 1
a3653 1
    bnum = parse_and_eval_address (bnum_exp);
@


1.17
log
@2000-08-29  Michael Snyder  <msnyder@@seadog.cygnus.com>

        * valops.c (value_cast): Indentation fix-up.
        * acconfig.h (HAVE_PRGREGSET32_T, HAVE_PRFPREGSET32_T,
        HAVE_STRUCT_LINK_MAP32): New configure macros.
        * config.in: Ditto.
        * configure.in: Test for the above new macros.
        * breakpoint.c: Update copyright date.
        * core-sol2.c: Include v9/sys/privregs.h directly to
        work around a bug in Sun's Solaris 8 header files.
        (fetch_core_registers): Use the above new configure macros to
        handle cross-debugging of 32-bit core files on a 64-bit host.
        * sol-thread.c (ps_pdmodel) New function.
        (rw_common): For debugging of 32-bit apps on a 64-bit host,
        truncate addresses to 32 bits.
        * solib.c (solib_extract_address): Functionize.  Make 32/64 aware.
        (LM_ADDR, LM_NEXT, LM_NAME): Ditto.
        (IGNORE_FIRST_LINK_MAP): Ditto.
        (first_link_map_member): Make 32/64 aware.
        (open_symbol_file_object): Ditto.
        (current_sos): Ditto.
@
text
@d1269 1
a1269 1
	     presumable remove the breakpoint there as well.  */
d2783 1
a2783 1
     kc   < clr sgl shl slr sn sr ss ts
@


1.16
log
@Protoization.
@
text
@d2 1
a2 1
   Copyright 1986, 87, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 1999
@


1.15
log
@Protoization.
@
text
@d2249 1
a2249 3
bpstat_alloc (b, cbs)
     register struct breakpoint *b;
     bpstat cbs;		/* Current "bs" value */
d5662 1
a5662 3
map_catch_names (args, function)
     char *args;
     int (*function) ();
d7208 1
a7208 3
map_breakpoint_numbers (args, function)
     char *args;
     void (*function) (struct breakpoint *);
@


1.14
log
@* breakpoint.c (bpstat_what): Keep returning
BPSTAT_WHAT_SET_LONGJMP_RESUME when hitting multiple longjmp()
breakpoints instead of signalling an error by returning
BPSTAT_WHAT_STOP_NOISY.
@
text
@d331 1
a331 2
set_breakpoint_count (num)
     int num;
d341 1
a341 1
clear_breakpoint_hit_counts ()
d371 1
a371 3
get_number_trailer (pp, trailer)
     char **pp;
     int trailer;
d435 1
a435 2
get_number (pp)
     char **pp;
d457 1
a457 2
get_number_or_range (pp)
     char **pp;
d521 1
a521 3
condition_command (arg, from_tty)
     char *arg;
     int from_tty;
d572 1
a572 3
commands_command (arg, from_tty)
     char *arg;
     int from_tty;
d617 1
a617 4
read_memory_nobpt (memaddr, myaddr, len)
     CORE_ADDR memaddr;
     char *myaddr;
     unsigned len;
d719 1
a719 1
insert_breakpoints ()
d1029 1
a1029 1
remove_breakpoints ()
d1068 1
a1068 2
reattach_breakpoints (pid)
     int pid;
d1097 1
a1097 1
update_breakpoints_after_exec ()
d1212 1
a1212 2
detach_breakpoints (pid)
     int pid;
d1240 1
a1240 3
remove_breakpoint (b, is)
     struct breakpoint *b;
     insertion_state_t is;
d1404 1
a1404 1
mark_breakpoints_out ()
d1425 1
a1425 2
breakpoint_init_inferior (context)
     enum inf_context context;
d1492 1
a1492 2
breakpoint_here_p (pc)
     CORE_ADDR pc;
d1521 1
a1521 2
breakpoint_inserted_here_p (pc)
     CORE_ADDR pc;
d1547 1
a1547 2
frame_in_dummy (frame)
     struct frame_info *frame;
d1576 1
a1576 3
breakpoint_thread_match (pc, pid)
     CORE_ADDR pc;
     int pid;
d1606 1
a1606 2
ep_is_catchpoint (ep)
     struct breakpoint *ep;
d1623 1
a1623 2
ep_is_shlib_catchpoint (ep)
     struct breakpoint *ep;
d1632 1
a1632 2
ep_is_exception_catchpoint (ep)
     struct breakpoint *ep;
d1644 1
a1644 2
bpstat_clear (bsp)
     bpstat *bsp;
d1667 1
a1667 2
bpstat_copy (bs)
     bpstat bs;
d1694 1
a1694 3
bpstat_find_breakpoint (bsp, breakpoint)
     bpstat bsp;
     struct breakpoint *breakpoint;
d1716 1
a1716 2
bpstat_find_step_resume_breakpoint (bsp)
     bpstat bsp;
d1739 1
a1739 2
bpstat_num (bsp)
     bpstat *bsp;
d1759 1
a1759 2
bpstat_clear_actions (bs)
     bpstat bs;
d1775 1
a1775 2
cleanup_executing_breakpoints (ignore)
     PTR ignore;
d1786 1
a1786 2
bpstat_do_actions (bsp)
     bpstat *bsp;
d1861 1
a1861 2
print_it_typical (bs)
     bpstat bs;
d2210 1
a2210 2
bpstat_print (bs)
     bpstat bs;
d2238 1
a2238 2
breakpoint_cond_eval (exp)
     PTR exp;
d2280 1
a2280 2
watchpoint_check (p)
     PTR p;
d2388 1
a2388 3
bpstat_stop_status (pc, not_a_breakpoint)
     CORE_ADDR *pc;
     int not_a_breakpoint;
d2706 1
a2706 2
bpstat_what (bs)
     bpstat bs;
d2983 1
a2983 1
bpstat_should_step ()
d2994 1
a2994 1
bpstat_have_active_hw_watchpoints ()
d3012 1
a3012 3
bpstat_get_triggered_catchpoints (ep_list, cp_list)
     bpstat ep_list;
     bpstat *cp_list;
d3527 1
a3527 3
breakpoint_1 (bnum, allflag)
     int bnum;
     int allflag;
d3638 1
a3638 3
breakpoints_info (bnum_exp, from_tty)
     char *bnum_exp;
     int from_tty;
d3650 1
a3650 3
maintenance_info_breakpoints (bnum_exp, from_tty)
     char *bnum_exp;
     int from_tty;
d3663 1
a3663 3
describe_other_breakpoints (pc, section)
     CORE_ADDR pc;
     asection *section;
d3702 2
a3703 5
set_default_breakpoint (valid, addr, symtab, line)
     int valid;
     CORE_ADDR addr;
     struct symtab *symtab;
     int line;
d3718 1
a3718 3
check_duplicates (address, section)
     CORE_ADDR address;
     asection *section;
d3785 1
a3785 2
set_raw_breakpoint (sal)
     struct symtab_and_line sal;
d3848 1
a3848 2
create_longjmp_breakpoint (func_name)
     char *func_name;
d3886 1
a3886 1
enable_longjmp_breakpoint ()
d3899 1
a3899 1
disable_longjmp_breakpoint ()
d3913 1
a3913 2
create_thread_event_breakpoint (address)
     CORE_ADDR address;
d3949 1
a3949 1
remove_solib_event_breakpoints ()
d3959 1
a3959 2
create_solib_event_breakpoint (address)
     CORE_ADDR address;
d3979 1
a3979 2
disable_breakpoints_in_shlibs (silent)
     int silent;
d4012 1
a4012 1
re_enable_breakpoints_in_shlibs ()
d4031 2
a4032 6
solib_load_unload_1 (hookname, tempflag, dll_pathname, cond_string, bp_kind)
     char *hookname;
     int tempflag;
     char *dll_pathname;
     char *cond_string;
     enum bptype bp_kind;
d4108 2
a4109 6
create_solib_load_event_breakpoint (hookname, tempflag, 
				    dll_pathname, cond_string)
     char *hookname;
     int tempflag;
     char *dll_pathname;
     char *cond_string;
d4116 2
a4117 6
create_solib_unload_event_breakpoint (hookname, tempflag, 
				      dll_pathname, cond_string)
     char *hookname;
     int tempflag;
     char *dll_pathname;
     char *cond_string;
d4124 2
a4125 4
create_fork_vfork_event_catchpoint (tempflag, cond_string, bp_kind)
     int tempflag;
     char *cond_string;
     enum bptype bp_kind;
d4154 1
a4154 3
create_fork_event_catchpoint (tempflag, cond_string)
     int tempflag;
     char *cond_string;
d4160 1
a4160 3
create_vfork_event_catchpoint (tempflag, cond_string)
     int tempflag;
     char *cond_string;
d4166 1
a4166 3
create_exec_event_catchpoint (tempflag, cond_string)
     int tempflag;
     char *cond_string;
d4194 1
a4194 1
hw_breakpoint_used_count ()
d4209 1
a4209 3
hw_watchpoint_used_count (type, other_type_used)
     enum bptype type;
     int *other_type_used;
d4238 1
a4238 3
set_longjmp_resume_breakpoint (pc, frame)
     CORE_ADDR pc;
     struct frame_info *frame;
d4257 1
a4257 1
disable_watchpoints_before_interactive_call_start ()
d4277 1
a4277 1
enable_watchpoints_after_interactive_call_stop ()
d4302 2
a4303 4
set_momentary_breakpoint (sal, frame, type)
     struct symtab_and_line sal;
     struct frame_info *frame;
     enum bptype type;
d4325 1
a4325 2
mention (b)
     struct breakpoint *b;
d4651 1
a4651 3
break_command_1 (arg, flag, from_tty)
     char *arg;
     int flag, from_tty;
d4906 1
a4906 4
break_at_finish_at_depth_command_1 (arg, flag, from_tty)
     char *arg;
     int flag;
     int from_tty;
d4981 1
a4981 4
break_at_finish_command_1 (arg, flag, from_tty)
     char *arg;
     int flag;
     int from_tty;
d5069 1
a5069 2
resolve_sal_pc (sal)
     struct symtab_and_line *sal;
d5116 1
a5116 3
break_command (arg, from_tty)
     char *arg;
     int from_tty;
d5122 1
a5122 3
break_at_finish_command (arg, from_tty)
     char *arg;
     int from_tty;
d5128 1
a5128 3
break_at_finish_at_depth_command (arg, from_tty)
     char *arg;
     int from_tty;
d5134 1
a5134 3
tbreak_command (arg, from_tty)
     char *arg;
     int from_tty;
d5140 1
a5140 3
tbreak_at_finish_command (arg, from_tty)
     char *arg;
     int from_tty;
d5146 1
a5146 3
hbreak_command (arg, from_tty)
     char *arg;
     int from_tty;
d5152 1
a5152 3
thbreak_command (arg, from_tty)
     char *arg;
     int from_tty;
d5158 1
a5158 3
stop_command (arg, from_tty)
     char *arg;
     int from_tty;
d5166 1
a5166 3
stopin_command (arg, from_tty)
     char *arg;
     int from_tty;
d5199 1
a5199 3
stopat_command (arg, from_tty)
     char *arg;
     int from_tty;
d5235 1
a5235 4
watch_command_1 (arg, accessflag, from_tty)
     char *arg;
     int accessflag;
     int from_tty;
d5415 1
a5415 2
can_use_hardware_watchpoint (v)
     struct value *v;
d5488 1
a5488 3
watch_command_wrapper (arg, from_tty)
     char *arg;
     int from_tty;
d5494 1
a5494 3
watch_command (arg, from_tty)
     char *arg;
     int from_tty;
d5501 1
a5501 3
rwatch_command_wrapper (arg, from_tty)
     char *arg;
     int from_tty;
d5507 1
a5507 3
rwatch_command (arg, from_tty)
     char *arg;
     int from_tty;
d5514 1
a5514 3
awatch_command_wrapper (arg, from_tty)
     char *arg;
     int from_tty;
d5520 1
a5520 3
awatch_command (arg, from_tty)
     char *arg;
     int from_tty;
d5544 1
a5544 3
until_break_command (arg, from_tty)
     char *arg;
     int from_tty;
d5629 1
a5629 2
catch_breakpoint (name)
     char *name;
d5634 1
a5634 1
disable_catch_breakpoint ()
d5639 1
a5639 1
delete_catch_breakpoint ()
d5644 1
a5644 1
enable_catch_breakpoint ()
d5725 1
a5725 2
get_catch_sals (this_level_only)
     int this_level_only;
d5837 1
a5837 2
ep_skip_leading_whitespace (s)
     char **s;
d5851 1
a5851 2
ep_find_event_name_end (arg)
     char *arg;
d5884 1
a5884 2
ep_parse_optional_if_clause (arg)
     char **arg;
d5916 1
a5916 2
ep_parse_optional_filename (arg)
     char **arg;
d5955 2
a5956 5
catch_fork_command_1 (fork_kind, arg, tempflag, from_tty)
     catch_fork_kind fork_kind;
     char *arg;
     int tempflag;
     int from_tty;
d5991 1
a5991 4
catch_exec_command_1 (arg, tempflag, from_tty)
     char *arg;
     int tempflag;
     int from_tty;
d6015 1
a6015 4
catch_load_command_1 (arg, tempflag, from_tty)
     char *arg;
     int tempflag;
     int from_tty;
d6057 1
a6057 4
catch_unload_command_1 (arg, tempflag, from_tty)
     char *arg;
     int tempflag;
     int from_tty;
d6105 3
a6107 5
create_exception_catchpoint (tempflag, cond_string, ex_event, sal)
     int tempflag;
     char *cond_string;
     enum exception_event_kind ex_event;
     struct symtab_and_line *sal;
d6144 2
a6145 5
catch_exception_command_1 (ex_event, arg, tempflag, from_tty)
     enum exception_event_kind ex_event;
     char *arg;
     int tempflag;
     int from_tty;
d6196 1
a6196 2
cover_target_enable_exception_callback (arg)
     PTR arg;
d6224 1
a6224 4
handle_gnu_4_16_catch_command (arg, tempflag, from_tty)
     char *arg;
     int tempflag;
     int from_tty;
d6320 1
a6320 2
create_temp_exception_breakpoint (pc)
     CORE_ADDR pc;
d6344 1
a6344 4
catch_command_1 (arg, tempflag, from_tty)
     char *arg;
     int tempflag;
     int from_tty;
d6467 1
a6467 2
set_breakpoint_sal (sal)
     struct symtab_and_line sal;
d6483 1
a6483 2
disable_catch (args)
     char *args;
d6490 1
a6490 2
enable_catch (args)
     char *args;
d6497 1
a6497 2
delete_catch (args)
     char *args;
d6504 1
a6504 3
catch_command (arg, from_tty)
     char *arg;
     int from_tty;
d6511 1
a6511 3
tcatch_command (arg, from_tty)
     char *arg;
     int from_tty;
d6518 1
a6518 3
clear_command (arg, from_tty)
     char *arg;
     int from_tty;
d6656 1
a6656 2
breakpoint_auto_delete (bs)
     bpstat bs;
d6676 1
a6676 2
delete_breakpoint (bpt)
     struct breakpoint *bpt;
d6869 1
a6869 3
delete_command (arg, from_tty)
     char *arg;
     int from_tty;
d6912 1
a6912 2
breakpoint_re_set_one (bint)
     PTR bint;
d7091 1
a7091 1
breakpoint_re_set ()
d7135 1
a7135 2
breakpoint_re_set_thread (b)
     struct breakpoint *b;
d7145 1
a7145 2
set_ignore_count (bptnum, count, from_tty)
     int bptnum, count, from_tty;
d7176 1
a7176 1
breakpoint_clear_ignore_counts ()
d7187 1
a7187 3
ignore_command (args, from_tty)
     char *args;
     int from_tty;
d7255 1
a7255 2
disable_breakpoint (bpt)
     struct breakpoint *bpt;
d7278 1
a7278 3
disable_command (args, from_tty)
     char *args;
     int from_tty;
d7311 1
a7311 3
do_enable_breakpoint (bpt, disposition)
     struct breakpoint *bpt;
     enum bpdisp disposition;
d7406 1
a7406 2
enable_breakpoint (bpt)
     struct breakpoint *bpt;
d7417 1
a7417 3
enable_command (args, from_tty)
     char *args;
     int from_tty;
d7450 1
a7450 2
enable_once_breakpoint (bpt)
     struct breakpoint *bpt;
d7457 1
a7457 3
enable_once_command (args, from_tty)
     char *args;
     int from_tty;
d7463 1
a7463 2
enable_delete_breakpoint (bpt)
     struct breakpoint *bpt;
d7470 1
a7470 3
enable_delete_command (args, from_tty)
     char *args;
     int from_tty;
d7478 1
a7478 3
decode_line_spec_1 (string, funfirstline)
     char *string;
     int funfirstline;
d7497 1
a7497 1
_initialize_breakpoint ()
@


1.13
log
@2000-06-12  Michael Snyder  <msnyder@@cleaver.cygnus.com>

        * breakpoint.c (breakpoint_thread_match): Fix comment.
@
text
@d2871 1
a2871 1
    {slr, ss, sn, slr, err, err, err, sr, ts, shl, shlr},
@


1.12
log
@Eliminate PARAMS from function pointer declarations.
@
text
@d1592 2
a1593 2
/* breakpoint_match_thread (PC, PID) returns true if the breakpoint at PC
   is valid for process/thread PID.  */
@


1.11
log
@PARAMS removal.
@
text
@d7399 1
a7399 1
     void (*function) PARAMS ((struct breakpoint *));
@


1.10
log
@Cleanup delete_breakpoint cleanups.
@
text
@d52 1
a52 2
static void
catch_command_1 PARAMS ((char *, int, int));
d54 1
a54 2
static void
enable_delete_command PARAMS ((char *, int));
d56 1
a56 2
static void
enable_delete_breakpoint PARAMS ((struct breakpoint *));
d58 1
a58 2
static void
enable_once_command PARAMS ((char *, int));
d60 1
a60 2
static void
enable_once_breakpoint PARAMS ((struct breakpoint *));
d62 1
a62 2
static void
disable_command PARAMS ((char *, int));
d64 1
a64 2
static void
enable_command PARAMS ((char *, int));
d66 1
a66 2
static void
map_breakpoint_numbers PARAMS ((char *, void (*)(struct breakpoint *)));
d68 1
a68 2
static void
ignore_command PARAMS ((char *, int));
d70 1
a70 1
static int breakpoint_re_set_one PARAMS ((PTR));
d72 1
a72 2
static void
clear_command PARAMS ((char *, int));
d74 1
a74 2
static void
catch_command PARAMS ((char *, int));
d76 1
a76 2
static void
handle_gnu_4_16_catch_command PARAMS ((char *, int, int));
d78 1
a78 2
static struct symtabs_and_lines
get_catch_sals PARAMS ((int));
d80 1
a80 2
static void
watch_command PARAMS ((char *, int));
d82 1
a82 2
static int
can_use_hardware_watchpoint PARAMS ((struct value *));
d84 2
a85 2
static void break_at_finish_command PARAMS ((char *, int));
static void break_at_finish_at_depth_command PARAMS ((char *, int));
d87 1
a87 2
void
tbreak_command PARAMS ((char *, int));
d89 1
a89 1
static void tbreak_at_finish_command PARAMS ((char *, int));
d91 1
a91 2
static void
break_command_1 PARAMS ((char *, int, int));
d93 1
a93 2
static void
mention PARAMS ((struct breakpoint *));
d95 1
a95 2
struct breakpoint *
  set_raw_breakpoint PARAMS ((struct symtab_and_line));
d97 1
a97 2
static void
check_duplicates PARAMS ((CORE_ADDR, asection *));
d99 1
a99 2
static void
describe_other_breakpoints PARAMS ((CORE_ADDR, asection *));
d101 1
a101 2
static void
breakpoints_info PARAMS ((char *, int));
d103 1
a103 2
static void
breakpoint_1 PARAMS ((int, int));
d105 1
a105 2
static bpstat
  bpstat_alloc PARAMS ((struct breakpoint *, bpstat));
d107 1
a107 1
static int breakpoint_cond_eval PARAMS ((PTR));
d109 1
a109 2
static void
cleanup_executing_breakpoints PARAMS ((PTR));
d111 1
a111 2
static void
commands_command PARAMS ((char *, int));
d113 1
a113 2
static void
condition_command PARAMS ((char *, int));
d115 1
a115 2
static int
get_number_trailer PARAMS ((char **, int));
d117 1
a117 2
void
set_breakpoint_count PARAMS ((int));
d120 1
a120 2
static struct breakpoint *
  create_temp_exception_breakpoint PARAMS ((CORE_ADDR));
d130 1
a130 2
static int
remove_breakpoint PARAMS ((struct breakpoint *, insertion_state_t));
d132 1
a132 1
static enum print_stop_action print_it_typical PARAMS ((bpstat));
d143 1
a143 1
static int watchpoint_check PARAMS ((PTR));
d145 1
a145 1
static int cover_target_enable_exception_callback PARAMS ((PTR));
d147 1
a147 1
static void maintenance_info_breakpoints PARAMS ((char *, int));
d150 1
a150 1
static void create_longjmp_breakpoint PARAMS ((char *));
d153 1
a153 1
static int hw_breakpoint_used_count PARAMS ((void));
d155 1
a155 1
static int hw_watchpoint_used_count PARAMS ((enum bptype, int *));
d157 1
a157 1
static void hbreak_command PARAMS ((char *, int));
d159 1
a159 1
static void thbreak_command PARAMS ((char *, int));
d161 1
a161 1
static void watch_command_1 PARAMS ((char *, int, int));
d163 1
a163 1
static void rwatch_command PARAMS ((char *, int));
d165 1
a165 1
static void awatch_command PARAMS ((char *, int));
d167 1
a167 1
static void do_enable_breakpoint PARAMS ((struct breakpoint *, enum bpdisp));
d169 4
a172 5
static void solib_load_unload_1 PARAMS ((char *hookname,
					 int tempflag,
					 char *dll_pathname,
					 char *cond_string,
					 enum bptype bp_kind));
d174 3
a176 3
static void create_fork_vfork_event_catchpoint PARAMS ((int tempflag, 
							char *cond_string,
							enum bptype bp_kind));
d178 2
a179 3
static void break_at_finish_at_depth_command_1 PARAMS ((char *arg, 
							int flag, 
							int from_tty));
d181 1
a181 3
static void break_at_finish_command_1 PARAMS ((char *arg, 
					       int flag, 
					       int from_tty));
d183 1
a183 1
static void stop_command PARAMS ((char *arg, int from_tty));
d185 1
a185 1
static void stopin_command PARAMS ((char *arg, int from_tty));
d187 1
a187 1
static void stopat_command PARAMS ((char *arg, int from_tty));
d189 1
a189 1
static char *ep_find_event_name_end PARAMS ((char *arg));
d191 1
a191 1
static char *ep_parse_optional_if_clause PARAMS ((char **arg));
d193 1
a193 1
static char *ep_parse_optional_filename PARAMS ((char **arg));
d196 1
a196 2
static void catch_exec_command_1 PARAMS ((char *arg, int tempflag, 
					  int from_tty));
d199 3
a201 4
static void create_exception_catchpoint 
  PARAMS ((int tempflag, char *cond_string,
	   enum exception_event_kind ex_event,
	   struct symtab_and_line * sal));
d203 2
a204 3
static void catch_exception_command_1 
  PARAMS ((enum exception_event_kind ex_event,
	   char *arg, int tempflag, int from_tty));
d206 1
a206 1
static void tcatch_command PARAMS ((char *arg, int from_tty));
d208 1
a208 1
static void ep_skip_leading_whitespace PARAMS ((char **s));
d212 1
a212 2
static void
awatch_command PARAMS ((char *, int));
d214 1
a214 2
static void
do_enable_breakpoint PARAMS ((struct breakpoint *, enum bpdisp));
d220 1
a220 1
void _initialize_breakpoint PARAMS ((void));
d222 1
a222 1
void set_breakpoint_count PARAMS ((int));
d6092 2
a6093 4
static void catch_fork_command_1 PARAMS ((catch_fork_kind fork_kind, 
					  char *arg, 
					  int tempflag, 
					  int from_tty));
@


1.9
log
@Use make_cleanup_ui_out_stream_delete().
@
text
@d5755 1
a5755 2
    old_chain = make_cleanup ((make_cleanup_func) delete_breakpoint, 
			      breakpoint);
d5757 1
a5757 1
    old_chain = make_exec_cleanup ((make_cleanup_func) delete_breakpoint, breakpoint);
d5788 1
a5788 1
	make_cleanup ((make_cleanup_func) delete_breakpoint, breakpoint);
d5790 1
a5790 1
	make_exec_cleanup ((make_cleanup_func) delete_breakpoint, breakpoint);
d7068 18
@


1.8
log
@2000-03-30  Michael Snyder  <msnyder@@cleaver.cygnus.com>

        * defs.h (struct continuation_arg): make 'data' a union, to avoid
        casting problems when int and pointer are not the  same size.
        * event-top.c (command_handler): use data as a union.
        (command_line_handler_continuation): ditto.
        * infcmd.c (step_1_continuation): use data as a union.  Re-indent.
        (step_once): ditto.  (finish_command_continuation): ditto.
        (finish_command): ditto.
        * breakpoint.c (until_break_command): use data as a union.
        (until_break_command_continuation): ditto.
        * utils.c (add_intermediate_continuation): fix typo in comment.
@
text
@d1942 1
a1942 1
  old_chain = make_cleanup ((make_cleanup_func) ui_out_stream_delete, stb);
d4461 1
a4461 1
  old_chain = make_cleanup ((make_cleanup_func) ui_out_stream_delete, stb);
@


1.7
log
@Fix various GCC warnings.
@
text
@d5711 1
a5711 1
  cleanups = (struct cleanup *) arg->data;
d5775 2
a5776 2
      arg1->next = NULL;
      arg1->data = (PTR) old_chain;
@


1.6
log
@2000-03-28  Peter Schauer  <pes@@regent.e-technik.tu-muenchen.de>

        breakpoint.c, breakpoint.h (remove_hw_watchpoints):  New function.
        infrun.c (resume):  Remove hardware watchpoints before stepping
        when CANNOT_STEP_HW_WATCHPOINTS is nonzero.
@
text
@d1099 1
a1099 1
remove_hw_watchpoints ()
@


1.5
log
@2000-03-28  Peter Schauer  <pes@@regent.e-technik.tu-muenchen.de>

        * breakpoint.c (insert_breakpoints, do_enable_breakpoint):
        Reselect the saved frame silently after frame selection for
        watchpoint evaluation.
        (insert_breakpoints):  Add missing space in `Hardware watchpoint
        deleted' message.  Do not reinsert hardware watchpoint if it is
        already marked for deletion at next stop.
@
text
@d1099 21
@


1.4
log
@2000-03-21  Eli Zaretskii  <eliz@@is.elta.co.il>

        * breakpoint.c (bpstat_stop_status): Don't stop if a read
        watchpoint appears to break, but the watched value changed.
@
text
@d921 1
d1024 1
a1024 1
	    printf_filtered ("Hardware watchpoint %d deleted", b->number);
d1035 1
a1035 1
	  select_and_print_frame (saved_frame, saved_level);
d7591 1
a7591 2
	select_and_print_frame (save_selected_frame,
				save_selected_frame_level);
@


1.3
log
@2000-03-20  Eli Zaretskii  <eliz@@is.elta.co.il>

        * breakpoint.c (insert_breakpoints, remove_breakpoint)
        (bpstat_stop_status, can_use_hardware_watchpoint): Don't insert,
        remove, or check status of hardware watchpoints for entire structs
        and arrays unless the user explicitly asked to watch that struct
        or array.
        (insert_breakpoints): Try to insert watchpoints for all the values
        on the value chain, even if some of them fail to insert.

        * values.c (value_primitive_field): Set the offset in struct value
        we return when the field is a packed bitfield.
@
text
@d2622 11
@


1.2
log
@Add mi/ and testsuite/gdb.mi/ subdirectories.
Add --enable-gdbmi option to configury.
Add mi rules to Makefile.in
Add mi conditional output to event-top.c infrun.c main.c top.c.
Add -i=mi option.
@
text
@d976 1
a976 2
		    CORE_ADDR addr;
		    int len, type;
d978 9
a986 7
		    addr = VALUE_ADDRESS (v) + VALUE_OFFSET (v);
		    len = TYPE_LENGTH (VALUE_TYPE (v));
		    type   = hw_write;
		    if (b->type == bp_read_watchpoint)
		      type = hw_read;
		    else if (b->type == bp_access_watchpoint)
		      type = hw_access;
d988 20
a1007 5
		    val = target_insert_watchpoint (addr, len, type);
		    if (val == -1)
		      {
			b->inserted = 0;
			break;
a1008 1
		    val = 0;
d1344 1
a1344 2
	      CORE_ADDR addr;
	      int len, type;
d1346 20
a1365 12
	      addr = VALUE_ADDRESS (v) + VALUE_OFFSET (v);
	      len = TYPE_LENGTH (VALUE_TYPE (v));
	      type   = hw_write;
	      if (b->type == bp_read_watchpoint)
		type = hw_read;
	      else if (b->type == bp_access_watchpoint)
		type = hw_access;

	      val = target_remove_watchpoint (addr, len, type);
	      if (val == -1)
		b->inserted = 1;
	      val = 0;
d2595 1
a2595 1
		CORE_ADDR vaddr;
d2597 13
a2609 6
		vaddr = VALUE_ADDRESS (v) + VALUE_OFFSET (v);
		/* Exact match not required.  Within range is sufficient.  
		 */
		if (addr >= vaddr &&
		    addr < vaddr + TYPE_LENGTH (VALUE_TYPE (v)))
		  found = 1;
d5546 1
d5584 1
a5584 2
	      CORE_ADDR vaddr = VALUE_ADDRESS (v) + VALUE_OFFSET (v);
	      int       len   = TYPE_LENGTH (VALUE_TYPE (v));
d5586 15
a5600 4
	      if (!TARGET_REGION_OK_FOR_HW_WATCHPOINT (vaddr, len))
		return 0;
	      else
		found_memory_cnt++;
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
             Free Software Foundation, Inc.
d5 1
a5 1
This file is part of GDB.
d7 14
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d42 5
d50 2
d74 1
a74 1
map_breakpoint_numbers PARAMS ((char *,	void (*)(struct breakpoint *)));
d99 3
d105 2
d114 1
a114 1
set_raw_breakpoint PARAMS ((struct symtab_and_line));
d129 1
a129 1
bpstat_alloc PARAMS ((struct breakpoint *, bpstat));
d143 1
a143 1
get_number PARAMS ((char **));
d150 1
a150 1
create_temp_exception_breakpoint PARAMS ((CORE_ADDR));
d153 6
a158 4
typedef enum {
  mark_inserted,
  mark_uninserted
} insertion_state_t;
d163 3
a165 1
static int print_it_normal PARAMS ((bpstat));
d167 6
a172 4
typedef struct {
  enum exception_event_kind kind;
  int enable;
} args_for_catchpoint_enable;
a177 4
static int print_it_done PARAMS ((bpstat));

static int print_it_noop PARAMS ((bpstat));

d200 48
a259 2
void delete_command PARAMS ((char *, int));

d264 1
a264 1
extern int addressprint;		/* Print machine addresses? */
a265 1
#if defined (GET_LONGJMP_TARGET) || defined (SOLIB_ADD)
a266 1
#endif
d275 1
a275 1
#define ALL_BREAKPOINTS(b)  for (b = breakpoint_chain; b; b = b->next)
d277 4
a280 4
#define ALL_BREAKPOINTS_SAFE(b,tmp)	\
	for (b = breakpoint_chain;	\
	     b? (tmp=b->next, 1): 0;	\
	     b = tmp)
d290 1
a290 1
;
d304 2
a305 2
/* Pointer to current exception event record */ 
static struct exception_event_record * current_exception_event;
d310 1
a310 1
 
d407 4
a410 1
   for map_breakpoint_numbers (e.g. "4 + 5 + 6").  */
d412 1
a412 1
get_number (pp)
d414 1
d416 1
a416 1
  int retval;
d425 1
a425 1
	 to pass to lookup_internalvar().  */
d436 7
a442 5
      if (TYPE_CODE (VALUE_TYPE (val)) != TYPE_CODE_INT)
	error (
"Convenience variables used to specify breakpoints must have integer values."
	       );
      retval = (int) value_as_long (val);
d452 16
a467 2
	error_no_arg ("breakpoint number");
      retval = atoi (*pp);
a468 2
  if (!(isspace (*p) || *p == '\0'))
    error ("breakpoint number expected");
d474 88
d579 2
d584 8
a591 8
      {
	if (b->cond)
	  {
	    free ((PTR)b->cond);
	    b->cond = 0;
	  }
	if (b->cond_string != NULL)
	  free ((PTR)b->cond_string);
d593 20
a612 20
	if (*p == 0)
	  {
	    b->cond = 0;
	    b->cond_string = NULL;
	    if (from_tty)
	      printf_filtered ("Breakpoint %d now unconditional.\n", bnum);
	  }
	else
	  {
	    arg = p;
	    /* I don't know if it matters whether this is the string the user
	       typed in or the decompiled expression.  */
	    b->cond_string = savestring (arg, strlen (arg));
	    b->cond = parse_exp_1 (&arg, block_for_pc (b->address), 0);
	    if (*arg)
	      error ("Junk at end of expression");
	  }
	breakpoints_changed ();
	return;
      }
d637 1
d640 1
a640 1
      
d643 11
a653 9
      {
	char tmpbuf[128];
	sprintf (tmpbuf, "Type commands for when breakpoint %d is hit, one per line.", bnum);
	l = read_command_lines (tmpbuf, from_tty);
	free_command_lines (&b->commands);
	b->commands = l;
	breakpoints_changed ();
	return;
      }
d679 1
a679 1
  
d681 77
a757 77
    {
      if (b->type == bp_none)
        warning ("attempted to read through apparently deleted breakpoint #%d?\n", b->number);

      /* memory breakpoint? */
      if (b->type == bp_watchpoint
	  || b->type == bp_hardware_watchpoint
	  || b->type == bp_read_watchpoint
	  || b->type == bp_access_watchpoint)
	continue;
      /* bp in memory? */
      if (!b->inserted)
	continue;
      /* Addresses and length of the part of the breakpoint that
	 we need to copy.  */
      /* XXXX The m68k, sh and h8300 have different local and remote
	 breakpoint values.  BREAKPOINT_FROM_PC still manages to
	 correctly determine the breakpoints memory address and size
	 for these targets. */
      bp_addr = b->address;
      bp_size = 0;
      if (BREAKPOINT_FROM_PC (&bp_addr, &bp_size) == NULL)
	continue;
      if (bp_size == 0)
	/* bp isn't valid */
	continue;
      if (bp_addr + bp_size <= memaddr)
	/* The breakpoint is entirely before the chunk of memory we
	   are reading.  */
	continue;
      if (bp_addr >= memaddr + len)
	/* The breakpoint is entirely after the chunk of memory we are
	   reading. */
	continue;
      /* Copy the breakpoint from the shadow contents, and recurse for
	 the things before and after.  */
      {
	/* Offset within shadow_contents.  */
	int bptoffset = 0;
	  
	if (bp_addr < memaddr)
	  {
	    /* Only copy the second part of the breakpoint.  */
	    bp_size -= memaddr - bp_addr;
	    bptoffset = memaddr - bp_addr;
	    bp_addr = memaddr;
	  }
	
	if (bp_addr + bp_size > memaddr + len)
	  {
	    /* Only copy the first part of the breakpoint.  */
	    bp_size -= (bp_addr + bp_size) - (memaddr + len);
	  }
	
	memcpy (myaddr + bp_addr - memaddr, 
		b->shadow_contents + bptoffset, bp_size);
	
	if (bp_addr > memaddr)
	  {
	    /* Copy the section of memory before the breakpoint.  */
	    status = read_memory_nobpt (memaddr, myaddr, bp_addr - memaddr);
	    if (status != 0)
	      return status;
	  }
	
	if (bp_addr + bp_size < memaddr + len)
	  {
	    /* Copy the section of memory after the breakpoint.  */
	    status = read_memory_nobpt
	      (bp_addr + bp_size,
	       myaddr + bp_addr + bp_size - memaddr,
	       memaddr + len - (bp_addr + bp_size));
	    if (status != 0)
	      return status;
	  }
	return 0;
      }
d759 1
d763 1
a764 1

d774 1
d783 31
a813 28
    {
      if (b->type != bp_watchpoint
	  && b->type != bp_hardware_watchpoint
	  && b->type != bp_read_watchpoint
	  && b->type != bp_access_watchpoint
	  && b->type != bp_catch_fork
	  && b->type != bp_catch_vfork
	  && b->type != bp_catch_exec
          && b->type != bp_catch_throw
          && b->type != bp_catch_catch
	  && b->enable != disabled
	  && b->enable != shlib_disabled
          && b->enable != call_disabled
	  && ! b->inserted
	  && ! b->duplicate)
	{
	  if (b->type == bp_hardware_breakpoint)
	    val = target_insert_hw_breakpoint(b->address, b->shadow_contents);
	  else
	    {
	      /* Check to see if breakpoint is in an overlay section;
		 if so, we should set the breakpoint at the LMA address.
		 Only if the section is currently mapped should we ALSO
		 set a break at the VMA address. */
	      if (overlay_debugging && b->section &&
		  section_is_overlay (b->section))
		{
		  CORE_ADDR addr;
d815 17
a831 17
		  addr = overlay_unmapped_address (b->address, b->section);
		  val = target_insert_breakpoint (addr, b->shadow_contents);
		  /* This would be the time to check val, to see if the
		     breakpoint write to the load address succeeded.  
		     However, this might be an ordinary occurrance, eg. if 
		     the unmapped overlay is in ROM.  */
		  val = 0;	/* in case unmapped address failed */
		  if (section_is_mapped (b->section))
		    val = target_insert_breakpoint (b->address, 
						    b->shadow_contents);
		}
	      else /* ordinary (non-overlay) address */
		val = target_insert_breakpoint(b->address, b->shadow_contents);
	    }
	  if (val)
	    {
	      /* Can't set the breakpoint.  */
d833 15
a847 16
	      if (DISABLE_UNSETTABLE_BREAK (b->address))
		{
                  /* See also: disable_breakpoints_in_shlibs. */
		  val = 0;
		  b->enable = shlib_disabled;
		  if (!disabled_breaks)
		    {
		      target_terminal_ours_for_output ();
		      fprintf_unfiltered (gdb_stderr,
					  "Cannot insert breakpoint %d:\n", b->number);
		      printf_filtered ("Temporarily disabling shared library breakpoints:\n");
		    }
		  disabled_breaks = 1;
		  printf_filtered ("%d ", b->number);
		}
	      else
d849 3
a851 3
		{
		  target_terminal_ours_for_output ();
		  fprintf_unfiltered (gdb_stderr, "Cannot insert breakpoint %d:\n", b->number);
d853 1
a853 2
		  fprintf_unfiltered (gdb_stderr,
				      "The same program may be running in another process.\n");
d855 9
a863 6
		  memory_error (val, b->address);	/* which bombs us out */
		}
	    }
	  else
            b->inserted = 1;
       }
d865 5
a869 5
             && b->enable != disabled
             && b->enable != shlib_disabled
             && b->enable != call_disabled
             && ! b->inserted
             && ! b->duplicate)
d872 18
a889 17
         /* If we get here, we must have a callback mechanism for exception
            events -- with g++ style embedded label support, we insert
            ordinary breakpoints and not catchpoints. */ 
        sprintf (message, message1, b->number); /* Format possible error message */
 
        val = target_insert_breakpoint(b->address, b->shadow_contents);
        if (val)
          {
           /* Couldn't set breakpoint for some reason */ 
           target_terminal_ours_for_output ();
           fprintf_unfiltered (gdb_stderr,
                        "Cannot insert catchpoint %d; disabling it\n", b->number);
           b->enable = disabled;
          }
        else
          {
              /* Bp set, now make sure callbacks are enabled */ 
d891 3
a893 2
	    args_for_catchpoint_enable args;  
	    args.kind = b->type == bp_catch_catch ? EX_EVENT_CATCH : EX_EVENT_THROW;
d902 1
a902 1
	    /* Check if something went wrong; val == 0 can be ignored */ 
d905 1
a905 1
		/* something went wrong */ 
d907 2
a908 1
		fprintf_unfiltered (gdb_stderr, "Cannot insert catchpoint %d; disabling it\n", b->number);
d911 4
a914 1
          }
d917 49
a965 23
      else if ((b->type == bp_hardware_watchpoint ||
		b->type == bp_read_watchpoint ||
		b->type == bp_access_watchpoint)
	       && b->enable == enabled
	       && ! b->inserted
	       && ! b->duplicate)
	{
	  struct frame_info *saved_frame;
	  int saved_level, within_current_scope;
	  value_ptr mark = value_mark ();
	  value_ptr v;

	  /* Save the current frame and level so we can restore it after
	     evaluating the watchpoint expression on its own frame.  */
	  saved_frame = selected_frame;
	  saved_level = selected_frame_level;

	  /* Determine if the watchpoint is within scope.  */
	  if (b->exp_valid_block == NULL)
	    within_current_scope = 1;
	  else
	    {
	      struct frame_info *fi;
d967 11
a977 20
	      /* There might be no current frame at this moment if we are
		 resuming from a step over a breakpoint.
		 Set up current frame before trying to find the watchpoint
		 frame.  */
	      get_current_frame ();
	      fi = find_frame_addr_in_frame_chain (b->watchpoint_frame);
	      within_current_scope = (fi != NULL);
	      if (within_current_scope)
		select_frame (fi, -1);
	    }
	
	  if (within_current_scope)
	    {
	      /* Evaluate the expression and cut the chain of values
		 produced off from the value chain.  */
	      v = evaluate_expression (b->exp);
	      value_release_to_mark (mark);
	    
	      b->val_chain = v;
	      b->inserted = 1;
d979 23
a1001 29
	      /* Look at each value on the value chain.  */
	      for ( ; v; v=v->next)
		{
		  /* If it's a memory location, then we must watch it.  */
		  if (v->lval == lval_memory)
		    {
		      int addr, len, type;
		    
		      addr = VALUE_ADDRESS (v) + VALUE_OFFSET (v);
		      len = TYPE_LENGTH (VALUE_TYPE (v));
		      type = 0;
		      if (b->type == bp_read_watchpoint)
			type = 1;
		      else if (b->type == bp_access_watchpoint)
			type = 2;

		      val = target_insert_watchpoint (addr, len, type);
		      if (val == -1)
			{
			  b->inserted = 0;
			  break;
			}
		      val = 0;
		    }
		}
	      /* Failure to insert a watchpoint on any memory value in the
		 value chain brings us here.  */
	      if (!b->inserted)
		warning ("Hardware watchpoint %d: Could not insert watchpoint\n",
d1003 51
a1053 10
	    }
	  else
	    {
	      printf_filtered ("\
Hardware watchpoint %d deleted because the program has left the block in\n\
which its expression is valid.\n", b->number);
	      if (b->related_breakpoint)
		b->related_breakpoint->disposition = del_at_next_stop;
	      b->disposition = del_at_next_stop;
	    }
d1055 4
a1058 36
	  /* Restore the frame and level.  */
	  if ((saved_frame != selected_frame) ||
	      (saved_level != selected_frame_level))
	    select_and_print_frame (saved_frame, saved_level);
	} 
      else if ((b->type == bp_catch_fork
                || b->type == bp_catch_vfork
                || b->type == bp_catch_exec)
               && b->enable == enabled
               && ! b->inserted
               && ! b->duplicate)
	{
	  val = -1;
          switch (b->type)
            {
	    case bp_catch_fork :
	      val = target_insert_fork_catchpoint (inferior_pid);
	      break;
	    case bp_catch_vfork :
	      val = target_insert_vfork_catchpoint (inferior_pid);
	      break;
	    case bp_catch_exec :
	      val = target_insert_exec_catchpoint (inferior_pid);
	      break;
            }
          if (val < 0)
            {
              target_terminal_ours_for_output ();
              fprintf_unfiltered (gdb_stderr, "Cannot insert catchpoint %d:\n", b->number);
            }
          else
            b->inserted = 1;
        }
    }
  if (disabled_breaks)
    printf_filtered ("\n");
d1060 1
a1060 1
  return val;
d1071 8
a1078 8
    {
      if (b->inserted)
	{
	  val = remove_breakpoint (b, mark_uninserted);
	  if (val != 0)
	    return val;
	}
    }
d1084 1
a1084 1
  int  pid;
d1088 1
a1088 1
  int  saved_inferior_pid = inferior_pid;
d1090 2
a1091 1
  inferior_pid = pid;  /* Because remove_breakpoint will use this global. */
d1093 16
a1108 16
    {
      if (b->inserted)
	{
          remove_breakpoint (b, mark_inserted);
          if (b->type == bp_hardware_breakpoint)
            val = target_insert_hw_breakpoint(b->address, b->shadow_contents);
          else
            val = target_insert_breakpoint(b->address, b->shadow_contents);
	  if (val != 0)
            {
              inferior_pid = saved_inferior_pid;
              return val;
            }
        }
    }
  inferior_pid = saved_inferior_pid;
d1115 2
a1116 2
  struct breakpoint *  b;
  struct breakpoint *  temp;
d1124 101
a1224 92
    {
      /* Solib breakpoints must be explicitly reset after an exec(). */
      if (b->type == bp_shlib_event)
        {
          delete_breakpoint (b);
          continue;
        }

      /* Step-resume breakpoints are meaningless after an exec(). */
      if (b->type == bp_step_resume)
        {
          delete_breakpoint (b);
          continue;
        }

      /* Ditto the sigtramp handler breakpoints. */
      if (b->type == bp_through_sigtramp)
        {
          delete_breakpoint (b);
          continue;
        }

      /* Ditto the exception-handling catchpoints. */
      if ((b->type == bp_catch_catch) || (b->type == bp_catch_throw))
        {
          delete_breakpoint (b);
          continue;
        }

      /* Don't delete an exec catchpoint, because else the inferior
         won't stop when it ought!

         Similarly, we probably ought to keep vfork catchpoints, 'cause
         on this target, we may not be able to stop when the vfork is seen,
         but only when the subsequent exec is seen.  (And because deleting
         fork catchpoints here but not vfork catchpoints will seem mysterious
         to users, keep those too.)

         ??rehrauer: Let's hope that merely clearing out this catchpoint's
         target address field, if any, is sufficient to have it be reset
         automagically.  Certainly on HP-UX that's true. */
      if ((b->type == bp_catch_exec) ||
          (b->type == bp_catch_vfork) ||
          (b->type == bp_catch_fork))
        {
          b->address = (CORE_ADDR) NULL;
          continue;
        }

      /* bp_finish is a special case.  The only way we ought to be able
         to see one of these when an exec() has happened, is if the user
         caught a vfork, and then said "finish".  Ordinarily a finish just
         carries them to the call-site of the current callee, by setting
         a temporary bp there and resuming.  But in this case, the finish
         will carry them entirely through the vfork & exec.

         We don't want to allow a bp_finish to remain inserted now.  But
         we can't safely delete it, 'cause finish_command has a handle to
         the bp on a bpstat, and will later want to delete it.  There's a
         chance (and I've seen it happen) that if we delete the bp_finish
         here, that its storage will get reused by the time finish_command
         gets 'round to deleting the "use to be a bp_finish" breakpoint.
         We really must allow finish_command to delete a bp_finish.

         In the absense of a general solution for the "how do we know it's
         safe to delete something others may have handles to?" problem, what
         we'll do here is just uninsert the bp_finish, and let finish_command
         delete it.

         (We know the bp_finish is "doomed" in the sense that it's momentary,
         and will be deleted as soon as finish_command sees the inferior stopped.
         So it doesn't matter that the bp's address is probably bogus in the
         new a.out, unlike e.g., the solib breakpoints.)  */
      if (b->type == bp_finish)
        {
          continue;
        }

      /* Without a symbolic address, we have little hope of the
         pre-exec() address meaning the same thing in the post-exec()
         a.out. */
      if (b->addr_string == NULL)
        {
          delete_breakpoint (b);
          continue;
        }

      /* If this breakpoint has survived the above battery of checks, then
         it must have a symbolic address.  Be sure that it gets reevaluated
         to a target address, rather than reusing the old evaluation.  */
      b->address = (CORE_ADDR) NULL;
    }
d1229 1
a1229 1
  int  pid;
d1233 2
a1234 2
  int  saved_inferior_pid = inferior_pid;
 
d1237 3
a1239 2
 
  inferior_pid = pid;  /* Because remove_breakpoint will use this global. */
d1241 11
a1251 11
    {
      if (b->inserted)
        {
          val = remove_breakpoint (b, mark_inserted);
          if (val != 0)
            {
              inferior_pid = saved_inferior_pid;
              return val;
            }
        }
    }
d1259 1
a1259 1
     insertion_state_t  is;
d1262 5
a1266 1
  
d1268 2
a1269 1
    warning ("attempted to remove apparently deleted breakpoint #%d?\n", b->number);
a1279 1
      
d1282 1
a1282 1
        val = target_remove_hw_breakpoint(b->address, b->shadow_contents);
d1289 1
a1289 1
	  if (overlay_debugging && b->section && 
d1297 4
a1300 4
		 shadow breakpoint write to the load address succeeded.  
		 However, this might be an ordinary occurrance, eg. if 
		 the unmapped overlay is in ROM.  */
	      val = 0;	/* in case unmapped address failed */
d1302 1
a1302 1
		val = target_remove_breakpoint (b->address, 
d1305 2
a1306 2
	  else /* ordinary (non-overlay) address */
	    val = target_remove_breakpoint(b->address, b->shadow_contents);
d1313 2
a1314 2
            b->type == bp_read_watchpoint ||
  	    b->type == bp_access_watchpoint)
d1316 1
a1316 1
	   && ! b->duplicate)
d1319 1
a1319 1
      
d1326 2
a1327 1
	  if (v->lval == lval_memory)
d1329 3
a1331 2
	      int addr, len, type;
	      
d1334 1
a1334 1
	      type = 0;
d1336 1
a1336 1
		type = 1;
d1338 1
a1338 1
		type = 2;
d1348 1
a1348 1
	warning ("Hardware watchpoint %d: Could not remove watchpoint\n",
d1350 1
a1350 1
      
d1352 1
a1352 1
	 the next time the watchpoint is inserted.  */
d1361 2
a1362 2
            b->type == bp_catch_vfork ||
  	    b->type == bp_catch_exec)
d1364 1
a1364 1
	   && ! b->duplicate)
d1368 14
a1381 11
        {
          case bp_catch_fork:
            val = target_remove_fork_catchpoint (inferior_pid);
            break;
          case bp_catch_vfork :
            val = target_remove_vfork_catchpoint (inferior_pid);
            break;
          case bp_catch_exec :
            val = target_remove_exec_catchpoint (inferior_pid);
            break;
        }
d1387 3
a1389 3
            b->type == bp_catch_throw)
           && b->enable == enabled
           && ! b->duplicate)
d1392 1
a1392 1
      val = target_remove_breakpoint(b->address, b->shadow_contents);
d1394 1
a1394 1
        return val;
d1398 3
a1400 3
           && b->inserted /* sometimes previous insert doesn't happen */ 
           && b->enable == enabled
           && ! b->duplicate)
d1403 1
a1403 1
      val = target_remove_breakpoint(b->address, b->shadow_contents);
d1405 2
a1406 2
          return val;
      
d1424 2
a1425 2
/* Clear the "inserted" flag in all breakpoints and delete any breakpoints
   which should go away between runs of the program.
d1430 3
a1432 2
   Note: this function gets called at the end of a run (by generic_mourn_inferior)
   and when a run begins (by init_wait_for_inferior). */ 
d1438 1
a1438 1
  enum inf_context context;
d1444 2
a1445 2
    {
      b->inserted = 0;
d1447 4
a1450 4
      switch (b->type)
	{
	case bp_call_dummy:
	case bp_watchpoint_scope:
d1452 3
a1454 3
	  /* If the call dummy breakpoint is at the entry point it will
	     cause problems when the inferior is rerun, so we better
	     get rid of it. 
d1456 3
a1458 3
	     Also get rid of scope breakpoints.  */
	  delete_breakpoint (b);
	  break;
d1460 4
a1463 4
	case bp_watchpoint:
	case bp_hardware_watchpoint:
	case bp_read_watchpoint:
	case bp_access_watchpoint:
d1465 11
a1475 2
	  /* Likewise for watchpoints on local expressions.  */
	  if (b->exp_valid_block != NULL)
d1477 4
a1480 13
	  break;
	default:
         /* Likewise for exception catchpoints in dynamic-linked
         executables where required */
         if (ep_is_exception_catchpoint (b) &&
            exception_catchpoints_are_fragile)
          {
            warning_needed = 1;
            delete_breakpoint (b);
          }
          break;
	}
    }
d1485 1
a1485 1
  /* Don't issue the warning unless it's really needed... */ 
d1488 2
a1489 1
      warning ("Exception catchpoints from last run were deleted, you must reinsert them explicitly");
d1491 1
a1491 1
    }  
d1494 9
a1502 3
/* breakpoint_here_p (PC) returns 1 if an enabled breakpoint exists at PC.
   When continuing from a location with a breakpoint,
   we actually single step once before calling insert_breakpoints.  */
d1504 1
a1504 1
int
d1509 1
d1512 2
a1513 3
    if (b->enable == enabled
	&& b->enable != shlib_disabled
	&& b->enable != call_disabled
d1516 1
a1516 1
        if (overlay_debugging &&
d1520 4
a1523 2
        else
	  return 1;
d1526 1
a1526 1
  return 0;
d1529 4
a1532 2
/* breakpoint_inserted_here_p (PC) is just like breakpoint_here_p(), but it
   only returns true if there is actually a breakpoint inserted at PC.  */
d1543 8
a1550 8
      {
        if (overlay_debugging &&
	    section_is_overlay (b->section) &&
	    !section_is_mapped (b->section))
	  continue;		/* unmapped overlay -- can't be a match */
        else
	  return 1;
      }
d1555 5
a1559 4
/* Return nonzero if FRAME is a dummy frame.  We can't use PC_IN_CALL_DUMMY
   because figuring out the saved SP would take too much time, at least using
   get_saved_register on the 68k.  This means that for this function to
   work right a port must use the bp_call_dummy breakpoint.  */
a1564 4
#ifdef CALL_DUMMY
#ifdef USE_GENERIC_DUMMY_FRAMES 
  return generic_pc_in_call_dummy (frame->pc, frame->frame);
#else
d1567 2
a1568 3
  ALL_BREAKPOINTS (b)
    {
      static ULONGEST dummy[] = CALL_DUMMY;
d1570 2
a1571 2
      if (b->type == bp_call_dummy
	  && b->frame == frame->frame
d1573 12
a1584 10
	  /* We need to check the PC as well as the frame on the sparc,
	     for signals.exp in the testsuite.  */
	  && (frame->pc
	      >= (b->address
		  - sizeof (dummy) / sizeof (LONGEST) * REGISTER_SIZE))
	  && frame->pc <= b->address)
	return 1;
    }
#endif	/* GENERIC_DUMMY_FRAMES */
#endif /* CALL_DUMMY */
d1607 8
a1614 8
      {
        if (overlay_debugging &&
	    section_is_overlay (b->section) &&
	    !section_is_mapped (b->section))
	  continue;		/* unmapped overlay -- can't be a match */
        else
	  return 1;
      }
d1618 1
a1619 1

d1625 1
a1625 1
  struct breakpoint *  ep;
d1637 1
a1637 1
    /* ??rehrauer: Add more kinds here, as are implemented... */
d1640 1
a1640 1
 
d1643 1
a1643 1
  struct breakpoint *  ep;
d1653 1
a1653 1
  struct breakpoint *  ep;
d1679 1
a1679 1
      free ((PTR)p);
d1717 1
a1717 1
bpstat_find_breakpoint(bsp, breakpoint)
d1721 2
a1722 1
  if (bsp == NULL) return NULL;
d1724 5
a1728 3
  for (;bsp != NULL; bsp = bsp->next) {
    if (bsp->breakpoint_at == breakpoint) return bsp;
  }
d1742 1
a1742 1
  bpstat  bsp;
d1750 2
a1751 2
          (bsp->breakpoint_at->type == bp_step_resume))
        return bsp->breakpoint_at;
d1779 1
a1779 1
        return b->number;	/* We have its number */
d1869 1
a1869 1
/* This is the normal print_it function for a bpstat.  In the future,
d1871 1
a1871 1
   by having it set different print_it functions.
d1873 16
a1888 13
   Current scheme: When we stop, bpstat_print() is called.
   It loops through the bpstat list of things causing this stop,
   calling the print_it function for each one. The default
   print_it function, used for breakpoints, is print_it_normal().
   (Also see print_it_noop() and print_it_done()).
   
   Return values from this routine (used by bpstat_print() to
   decide what to do):
   1: Means we printed something, and we do *not* desire that
      something to be followed by a location.
   0: Means we printed something, and we *do*  desire that
      something to be followed by a location.
   -1: Means we printed nothing.  */
d1890 2
a1891 2
static int
print_it_normal (bs)
d1894 6
d1902 2
a1903 15
  if (bs->breakpoint_at == NULL
      || (bs->breakpoint_at->type != bp_breakpoint
          && bs->breakpoint_at->type != bp_catch_load
          && bs->breakpoint_at->type != bp_catch_unload
          && bs->breakpoint_at->type != bp_catch_fork
          && bs->breakpoint_at->type != bp_catch_vfork
          && bs->breakpoint_at->type != bp_catch_exec
          && bs->breakpoint_at->type != bp_catch_catch
          && bs->breakpoint_at->type != bp_catch_throw
	  && bs->breakpoint_at->type != bp_hardware_breakpoint
	  && bs->breakpoint_at->type != bp_watchpoint
	  && bs->breakpoint_at->type != bp_read_watchpoint
	  && bs->breakpoint_at->type != bp_access_watchpoint
	  && bs->breakpoint_at->type != bp_hardware_watchpoint))
    return -1;
d1905 1
a1905 1
  if (ep_is_shlib_catchpoint (bs->breakpoint_at))
d1907 43
d1952 1
a1952 4
      if (bs->breakpoint_at->type == bp_catch_load)
        printf_filtered ("loaded");
      else if (bs->breakpoint_at->type == bp_catch_unload)
        printf_filtered ("unloaded");
d1954 13
a1966 5
      return 0;
    }
  else if (bs->breakpoint_at->type == bp_catch_fork ||
      bs->breakpoint_at->type == bp_catch_vfork)
    {
d1969 7
a1975 9
      if (bs->breakpoint_at->type == bp_catch_fork)
        printf_filtered ("forked");
      else if (bs->breakpoint_at->type == bp_catch_vfork)
        printf_filtered ("vforked");
      printf_filtered (" process %d), ", bs->breakpoint_at->forked_inferior_pid);
      return 0;
    }
  else if (bs->breakpoint_at->type == bp_catch_exec)
    {
d1978 32
a2009 29
                       bs->breakpoint_at->number,
                       bs->breakpoint_at->exec_pathname);
      return 0;
    }
 else if (bs->breakpoint_at->type == bp_catch_catch)
    {
      if (current_exception_event && (CURRENT_EXCEPTION_KIND == EX_EVENT_CATCH))
        {
          annotate_catchpoint (bs->breakpoint_at->number);
          printf_filtered ("\nCatchpoint %d (exception caught), ", bs->breakpoint_at->number);
          printf_filtered ("throw location ");
          if (CURRENT_EXCEPTION_THROW_PC && CURRENT_EXCEPTION_THROW_LINE)
                printf_filtered ("%s:%d",
                                 CURRENT_EXCEPTION_THROW_FILE,
                                 CURRENT_EXCEPTION_THROW_LINE);
          else
            printf_filtered ("unknown");
          
          printf_filtered (", catch location ");
          if (CURRENT_EXCEPTION_CATCH_PC  && CURRENT_EXCEPTION_CATCH_LINE)
            printf_filtered ("%s:%d",
                             CURRENT_EXCEPTION_CATCH_FILE,
                             CURRENT_EXCEPTION_CATCH_LINE);
          else
            printf_filtered ("unknown");
          
          printf_filtered ("\n");
          return 1;   /* don't bother to print location frame info */ 
        }
d2011 33
a2043 29
        {
          return -1;  /* really throw, some other bpstat will handle it */
        }
    }
  else if (bs->breakpoint_at->type == bp_catch_throw)
    {
      if (current_exception_event && (CURRENT_EXCEPTION_KIND == EX_EVENT_THROW))
        {
          annotate_catchpoint (bs->breakpoint_at->number);
          printf_filtered ("\nCatchpoint %d (exception thrown), ", bs->breakpoint_at->number);
          printf_filtered ("throw location ");
          if (CURRENT_EXCEPTION_THROW_PC && CURRENT_EXCEPTION_THROW_LINE)
                printf_filtered ("%s:%d",
                                 CURRENT_EXCEPTION_THROW_FILE,
                                 CURRENT_EXCEPTION_THROW_LINE);
          else
            printf_filtered ("unknown");
          
          printf_filtered (", catch location ");
          if (CURRENT_EXCEPTION_CATCH_PC  && CURRENT_EXCEPTION_CATCH_LINE)
            printf_filtered ("%s:%d",
                             CURRENT_EXCEPTION_CATCH_FILE,
                             CURRENT_EXCEPTION_CATCH_LINE);
          else
            printf_filtered ("unknown");
          
          printf_filtered ("\n");
          return 1;   /* don't bother to print location frame info */ 
        }
d2045 39
a2083 4
        {
          return -1;  /* really catch, some other bpstat willhandle it */
        }
    }
d2085 12
a2096 15
  else if (bs->breakpoint_at->type == bp_breakpoint ||
      bs->breakpoint_at->type == bp_hardware_breakpoint)
    {
      /* I think the user probably only wants to see one breakpoint
	 number, not all of them.  */
      annotate_breakpoint (bs->breakpoint_at->number);
      printf_filtered ("\nBreakpoint %d, ", bs->breakpoint_at->number);
      return 0;
    }
  else if ((bs->old_val != NULL) &&
	(bs->breakpoint_at->type == bp_watchpoint ||
	 bs->breakpoint_at->type == bp_access_watchpoint ||
	 bs->breakpoint_at->type == bp_hardware_watchpoint))
    {
      annotate_watchpoint (bs->breakpoint_at->number);
d2098 1
a2098 3
      printf_filtered ("\nOld value = ");
      value_print (bs->old_val, gdb_stdout, 0, Val_pretty_default);
      printf_filtered ("\nNew value = ");
d2102 83
a2184 4
      value_free (bs->old_val);
      bs->old_val = NULL;
      /* More than one watchpoint may have been triggered.  */
      return -1;
d2186 12
a2197 2
  else if (bs->breakpoint_at->type == bp_access_watchpoint ||
	   bs->breakpoint_at->type == bp_read_watchpoint)
d2199 18
a2216 6
      mention (bs->breakpoint_at);
      printf_filtered ("\nValue = ");
      value_print (bs->breakpoint_at->val, gdb_stdout, 0,
                   Val_pretty_default);
      printf_filtered ("\n");
      return -1;
a2217 2
  /* We can't deal with it.  Maybe another member of the bpstat chain can.  */
  return -1;
d2220 19
a2238 18
/* Print a message indicating what happened.
   This is called from normal_stop().
   The input to this routine is the head of the bpstat list - a list
   of the eventpoints that caused this stop.
   This routine calls the "print_it" routine(s) associated
   with these eventpoints. This will print (for example)
   the "Breakpoint n," part of the output.
   The return value of this routine is one of:

   -1: Means we printed nothing
   0: Means we printed something, and expect subsequent
      code to print the location. An example is 
      "Breakpoint 1, " which should be followed by
      the location.
   1 : Means we printed something, but there is no need
       to also print the location part of the message.
       An example is the catch/throw messages, which
       don't require a location appended to the end.  */ 
d2240 1
a2240 1
int
a2244 3
  
  if (bs == NULL)
    return -1;
a2245 4
  val = (*bs->print_it) (bs);
  if (val >= 0)
    return val;
  
d2247 2
a2248 2
     (Currently all watchpoints go on the bpstat whether hit or
     not.  That probably could (should) be changed, provided care is taken
d2250 8
a2257 2
  if (bs->next)
    return bpstat_print (bs->next);
d2259 3
a2261 2
  /* We reached the end of the chain without printing anything.  */
  return -1;
d2274 1
a2274 1
  int i = !value_true (evaluate_expression ((struct expression *)exp));
d2284 1
a2284 1
     bpstat cbs;			/* Current "bs" value */
d2328 3
a2330 3
	 any chance of handling watchpoints on local variables, we'll need
	 the frame chain (so we can determine if we're in scope).  */
      reinit_frame_cache();
d2339 1
a2339 1
      
d2344 2
a2345 2
	 call free_all_values.  We can't call free_all_values because
	 we might be in the middle of evaluating a function call.  */
d2369 19
a2387 7
	 if we temporarily ignored the watchpoint, then when
	 we reenter the block in which it is valid it contains
	 garbage (in the case of a function, it may have two
	 garbage values, one before and one after the prologue).
	 So we can't even detect the first assignment to it and
	 watch after that (since the garbage may or may not equal
	 the first value assigned).  */
d2391 2
a2400 34
/* This is used when everything which needs to be printed has
   already been printed.  But we still want to print the frame.  */

/* Background: When we stop, bpstat_print() is called.
   It loops through the bpstat list of things causing this stop,
   calling the print_it function for each one. The default
   print_it function, used for breakpoints, is print_it_normal().
   Also see print_it_noop() and print_it_done() are the other 
   two possibilities. See comments in bpstat_print() and
   in header of print_it_normal() for more detail.  */

static int
print_it_done (bs)
     bpstat bs;
{
  return 0;
}

/* This is used when nothing should be printed for this bpstat entry.  */
/* Background: When we stop, bpstat_print() is called.
   It loops through the bpstat list of things causing this stop,
   calling the print_it function for each one. The default
   print_it function, used for breakpoints, is print_it_normal().
   Also see print_it_noop() and print_it_done() are the other 
   two possibilities. See comments in bpstat_print() and
   in header of print_it_normal() for more detail.  */

static int
print_it_noop (bs)
     bpstat bs;
{
  return -1;
}

d2410 1
a2410 1
	if we don't understand the stop, the result is a null pointer.
d2412 1
a2412 1
	if we understand why we stopped, the result is not null.
d2414 3
a2416 3
	Each element of the chain refers to a particular breakpoint or
	watchpoint at which we have stopped.  (We may have stopped for
	several reasons concurrently.)
d2418 2
a2419 2
	Each element of the chain has valid next, breakpoint_at,
	commands, FIXME??? fields.  */
d2435 2
a2436 2
            "Error evaluating expression for watchpoint %d\n";
  char message[sizeof (message1) + 30 /* slop */];
d2439 2
a2440 1
  bp_addr = *pc - DECR_PC_AFTER_BREAK;
d2443 20
a2462 4
    {
      if (b->enable == disabled
	  || b->enable == shlib_disabled
          || b->enable == call_disabled)
d2465 40
a2504 15
      if (b->type != bp_watchpoint
	  && b->type != bp_hardware_watchpoint
          && b->type != bp_read_watchpoint
          && b->type != bp_access_watchpoint
	  && b->type != bp_hardware_breakpoint
          && b->type != bp_catch_fork
          && b->type != bp_catch_vfork
          && b->type != bp_catch_exec
          && b->type != bp_catch_catch
          && b->type != bp_catch_throw)         /* a non-watchpoint bp */
	if (b->address != bp_addr ||		/* address doesn't match or */
	    (overlay_debugging &&		/* overlay doesn't match */
	     section_is_overlay (b->section) &&
	     !section_is_mapped (b->section)))
	  continue;
d2506 3
a2508 3
      if (b->type == bp_hardware_breakpoint
	  && b->address != (*pc - DECR_PC_AFTER_HW_BREAK))
	continue;
d2510 1
a2510 6
      if (b->type != bp_watchpoint
	  && b->type != bp_hardware_watchpoint
	  && b->type != bp_read_watchpoint
	  && b->type != bp_access_watchpoint
	  && not_a_breakpoint)
	continue;
d2512 1
a2512 32
      /* Is this a catchpoint of a load or unload?  If so, did we
         get a load or unload of the specified library?  If not,
         ignore it. */
      if ((b->type == bp_catch_load)
#if defined(SOLIB_HAVE_LOAD_EVENT)
          && (!SOLIB_HAVE_LOAD_EVENT(inferior_pid)
              || ((b->dll_pathname != NULL)
                  && (strcmp (b->dll_pathname, SOLIB_LOADED_LIBRARY_PATHNAME(inferior_pid)) != 0)))
#endif
		  )
        continue;
 
      if ((b->type == bp_catch_unload)
#if defined(SOLIB_HAVE_UNLOAD_EVENT)
          && (!SOLIB_HAVE_UNLOAD_EVENT(inferior_pid)
              || ((b->dll_pathname != NULL)
                  && (strcmp (b->dll_pathname, SOLIB_UNLOADED_LIBRARY_PATHNAME(inferior_pid)) != 0)))
#endif
	  )
        continue;
 
      if ((b->type == bp_catch_fork)
          && ! target_has_forked (inferior_pid, &b->forked_inferior_pid))
          continue;
 
      if ((b->type == bp_catch_vfork)
          && ! target_has_vforked (inferior_pid, &b->forked_inferior_pid))
          continue;
 
      if ((b->type == bp_catch_exec)
	  && ! target_has_execd (inferior_pid, &b->exec_pathname))
	continue;
d2514 3
a2516 3
      if (ep_is_exception_catchpoint (b) &&
          !(current_exception_event = target_get_current_exception_event ()))
        continue;
d2518 35
a2552 1
      /* Come here if it's a watchpoint, or if the break address matches */
d2554 10
a2563 1
      bs = bpstat_alloc (b, bs);	/* Alloc a bpstat to explain stop */
d2565 9
a2573 3
      /* Watchpoints may change this, if not found to have triggered. */
      bs->stop = 1;
      bs->print = 1;
d2575 11
a2585 4
      sprintf (message, message1, b->number);
      if (b->type == bp_watchpoint || b->type == bp_hardware_watchpoint)
	{
	  switch (catch_errors (watchpoint_check, bs, message, RETURN_MASK_ALL))
d2593 1
a2596 7
	    case WP_VALUE_NOT_CHANGED:
	      /* Don't stop.  */
	      bs->print_it = print_it_noop;
	      bs->stop = 0;
	      /* Don't consider this a hit.  */
	      --(b->hit_count);
	      continue;
a2598 1
	      /* FALLTHROUGH */
a2606 2

	      /* Stop.  */
d2609 26
a2634 62
	}
      else if (b->type == bp_read_watchpoint || b->type == bp_access_watchpoint)
        {
	  CORE_ADDR addr;
	  value_ptr v;
          int found = 0;

	  addr = target_stopped_data_address();
	  if (addr == 0) continue;
          for (v = b->val_chain; v; v = v->next)
            {
              if (v->lval == lval_memory)
                {
                  CORE_ADDR vaddr;

                  vaddr = VALUE_ADDRESS (v) + VALUE_OFFSET (v);
	          if (addr == vaddr)
	            found = 1;
                }
            }
	  if (found) 
	    switch (catch_errors (watchpoint_check, bs, message, RETURN_MASK_ALL))
   	      {
                case WP_DELETED:
                  /* We've already printed what needs to be printed.  */
                  bs->print_it = print_it_done;
                  /* Stop.  */
                  break;
                case WP_VALUE_CHANGED:
                case WP_VALUE_NOT_CHANGED:
                  /* Stop.  */
		  ++(b->hit_count);
                  break;
                default:
                  /* Can't happen.  */
                case 0:
                  /* Error from catch_errors.  */
                  printf_filtered ("Watchpoint %d deleted.\n", b->number);
		  if (b->related_breakpoint)
		    b->related_breakpoint->disposition = del_at_next_stop;
		  b->disposition = del_at_next_stop;
                  /* We've already printed what needs to be printed.  */
                  bs->print_it = print_it_done;
                  break;
	      }
        }
      else 
        {
          /* By definition, an encountered breakpoint is a triggered
             breakpoint. */
          ++(b->hit_count);

	  real_breakpoint = 1;
        }

      if (b->frame && b->frame != (get_current_frame ())->frame &&
          (b->type == bp_step_resume && 
           (INNER_THAN (get_current_frame ()->frame, b->frame))))
	bs->stop = 0;
      else
	{
	  int value_is_zero = 0;
d2636 37
a2672 30
	  if (b->cond)
	    {
	      /* Need to select the frame, with all that implies
		 so that the conditions will have the right context.  */
	      select_frame (get_current_frame (), 0);
	      value_is_zero
		= catch_errors (breakpoint_cond_eval, (b->cond),
				"Error in testing breakpoint condition:\n",
				RETURN_MASK_ALL);
				/* FIXME-someday, should give breakpoint # */
	      free_all_values ();
	    }
	  if (b->cond && value_is_zero)
	    {
	      bs->stop = 0;
	      /* Don't consider this a hit.  */
	      --(b->hit_count);
	    }
	  else if (b->ignore_count > 0)
	    {
	      b->ignore_count--;
	      bs->stop = 0;
	    }
	  else
	    {
	      /* We will stop here */
	      if (b->disposition == disable)
		b->enable = disabled;
	      bs->commands = b->commands;
	      if (b->silent)
d2674 7
a2680 13
	      if (bs->commands &&
		  (STREQ ("silent", bs->commands->line) ||
		   (xdb_commands && STREQ ("Q", bs->commands->line))))
		{
		  bs->commands = bs->commands->next;
		  bs->print = 0;
		}
	    }
	}
      /* Print nothing for this entry if we dont stop or if we dont print.  */
      if (bs->stop == 0 || bs->print == 0)
	bs->print_it = print_it_noop;
    }
d2687 1
a2687 1
      if (bs->breakpoint_at->type == bp_hardware_breakpoint) 
d2689 1
a2689 1
	  if (DECR_PC_AFTER_HW_BREAK != 0) 
d2701 1
a2701 1
	      SHIFT_INST_REGS();
d2711 1
a2711 1
  if (bs && ! bs->stop &&
d2728 7
a2734 3
  enum class {
    /* This bpstat element has no effect on the main_action.  */
    no_effect = 0,
d2736 2
a2737 2
    /* There was a watchpoint, stop but don't print.  */
    wp_silent,
d2739 2
a2740 2
    /* There was a watchpoint, stop and print.  */
    wp_noisy,
d2742 2
a2743 2
    /* There was a breakpoint but we're not stopping.  */
    bp_nostop,
d2745 2
a2746 2
    /* There was a breakpoint, stop but don't print.  */
    bp_silent,
d2748 2
a2749 2
    /* There was a breakpoint, stop and print.  */
    bp_noisy,
d2751 2
a2752 2
    /* We hit the longjmp breakpoint.  */
    long_jump,
d2754 2
a2755 2
    /* We hit the longjmp_resume breakpoint.  */
    long_resume,
d2757 2
a2758 2
    /* We hit the step_resume breakpoint.  */
    step_resume,
d2760 2
a2761 2
    /* We hit the through_sigtramp breakpoint.  */
    through_sig,
d2763 2
a2764 2
    /* We hit the shared library event breakpoint.  */
    shlib_event,
d2766 2
a2767 5
    /* We caught a shared library event.  */
    catch_shlib_event,
 
    /* This is just used to count how many enums there are.  */
    class_last
d2795 28
a2822 2
     reference to how we stopped.  We retain separate wp_silent and bp_silent
     codes in case we want to change that someday.  */
d2831 30
a2860 18
    table[(int)class_last][(int)BPSTAT_WHAT_LAST] =
      {
	/*                              old action */
        /*       kc    ss    sn    sgl    slr   clr    clrs   sr    ts   shl   shlr
         */
/*no_effect*/   {kc,   ss,   sn,   sgl,   slr,  clr,   clrs,  sr,   ts,  shl,  shlr},
/*wp_silent*/   {ss,   ss,   sn,   ss,    ss,   ss,    ss,    sr,   ts,  shl,  shlr},
/*wp_noisy*/    {sn,   sn,   sn,   sn,    sn,   sn,    sn,    sr,   ts,  shl,  shlr},
/*bp_nostop*/   {sgl,  ss,   sn,   sgl,   slr,  clrs,  clrs,  sr,   ts,  shl,  shlr},
/*bp_silent*/   {ss,   ss,   sn,   ss,    ss,   ss,    ss,    sr,   ts,  shl,  shlr},
/*bp_noisy*/    {sn,   sn,   sn,   sn,    sn,   sn,    sn,    sr,   ts,  shl,  shlr},
/*long_jump*/   {slr,  ss,   sn,   slr,   err,  err,   err,   sr,   ts,  shl,  shlr},
/*long_resume*/ {clr,  ss,   sn,   clrs,  err,  err,   err,   sr,   ts,  shl,  shlr},
/*step_resume*/ {sr,   sr,   sr,   sr,    sr,   sr,    sr,    sr,   ts,  shl,  shlr},
/*through_sig*/ {ts,   ts,   ts,   ts,    ts,   ts,    ts,    ts,   ts,  shl,  shlr},
/*shlib*/       {shl,  shl,  shl,  shl,   shl,  shl,   shl,   shl,  ts,  shl,  shlr},
/*catch_shlib*/ {shlr, shlr, shlr, shlr,  shlr, shlr,  shlr,  shlr, ts,  shlr, shlr}
              };
d2916 2
a2917 2
	    /* There was a watchpoint, but we're not stopping.  This requires
	       no further action.  */
d2944 15
a2958 12
        case bp_catch_load:
        case bp_catch_unload:
          /* Only if this catchpoint triggered should we cause the
             step-out-of-dld behaviour.  Otherwise, we ignore this
             catchpoint.  */
          if (bs->stop)
            bs_class = catch_shlib_event;
          else
            bs_class = no_effect;
          break;
        case bp_catch_fork:
        case bp_catch_vfork:
d2960 24
a2983 24
          if (bs->stop)
            {
              if (bs->print)
                bs_class = bp_noisy;
              else
                bs_class = bp_silent;
            }
          else
            /* There was a catchpoint, but we're not stopping.  This requires
               no further action.  */
            bs_class = no_effect;
          break;
        case bp_catch_catch:
          if (!bs->stop || CURRENT_EXCEPTION_KIND != EX_EVENT_CATCH)
            bs_class = bp_nostop;
          else if (bs->stop)
            bs_class = bs->print ? bp_noisy : bp_silent;
          break;
        case bp_catch_throw:
          if (!bs->stop || CURRENT_EXCEPTION_KIND != EX_EVENT_THROW)
            bs_class = bp_nostop;
          else if (bs->stop)
            bs_class = bs->print ? bp_noisy : bp_silent;
          break;
d2985 2
a2986 2
	  /* Make sure the action is stop (silent or noisy), so infrun.c
	     pops the dummy frame.  */
d2991 1
a2991 1
      current_action = table[(int)bs_class][(int)current_action];
d3001 1
a3001 1
int 
d3007 1
a3007 1
      return 1;
d3018 5
a3022 5
        (b->inserted) &&
        ((b->type == bp_hardware_watchpoint) ||
         (b->type == bp_read_watchpoint) ||
         (b->type == bp_access_watchpoint)))
      return 1;
d3025 1
a3026 1

d3032 2
a3033 2
  bpstat  ep_list;
  bpstat *  cp_list;
d3035 5
a3039 5
  struct bpstats  root_bs[1];
  bpstat  bs = root_bs;
  struct breakpoint *  ep;
  char *  dll_pathname;
 
d3042 2
a3043 2
 
  for (; ep_list != NULL; ep_list = ep_list->next )
d3048 8
a3055 7
        break;
      if ((ep->type != bp_catch_load) && 
          (ep->type != bp_catch_unload) &&
          (ep->type != bp_catch_catch) &&
          (ep->type != bp_catch_throw))   /* pai: (temp) ADD fork/vfork here!!  */
        continue;
 
d3061 1
a3061 1
 
d3069 1
a3069 1
        free (ep->triggered_dll_pathname);
d3071 1
a3071 1
        dll_pathname = SOLIB_LOADED_LIBRARY_PATHNAME (inferior_pid);
d3073 1
a3073 1
        dll_pathname = SOLIB_UNLOADED_LIBRARY_PATHNAME (inferior_pid);
d3079 2
a3080 1
	  ep->triggered_dll_pathname = (char *) xmalloc (strlen (dll_pathname) + 1);
d3083 445
a3527 2
      else
	ep->triggered_dll_pathname = NULL;
d3529 12
a3540 2
 
  *cp_list = bs;
a3546 5
typedef struct {
  enum bptype  type;
  char *  description;
} ep_type_description_t;

d3553 1
a3553 3
  register struct command_line *l;
  register struct symbol *sym;
  CORE_ADDR last_addr = (CORE_ADDR)-1;
d3555 7
a3561 30
  static ep_type_description_t  bptypes[] =
  {
    {bp_none,                "?deleted?"},
    {bp_breakpoint,          "breakpoint"},
    {bp_hardware_breakpoint, "hw breakpoint"},
    {bp_until,               "until"},
    {bp_finish,              "finish"},
    {bp_watchpoint,          "watchpoint"},
    {bp_hardware_watchpoint, "hw watchpoint"},
    {bp_read_watchpoint,     "read watchpoint"},
    {bp_access_watchpoint,   "acc watchpoint"},
    {bp_longjmp,             "longjmp"},
    {bp_longjmp_resume,      "longjmp resume"},
    {bp_step_resume,         "step resume"},
    {bp_through_sigtramp,    "sigtramp"},
    {bp_watchpoint_scope,    "watchpoint scope"},
    {bp_call_dummy,          "call dummy"},
    {bp_shlib_event,         "shlib events"},
    {bp_catch_load,          "catch load"},
    {bp_catch_unload,        "catch unload"},
    {bp_catch_fork,          "catch fork"},
    {bp_catch_vfork,         "catch vfork"},
    {bp_catch_exec,          "catch exec"},
    {bp_catch_catch,         "catch catch"},
    {bp_catch_throw,         "catch throw"}
   };

  static char *bpdisps[] = {"del", "dstp", "dis", "keep"};
  static char bpenables[] = "nyn";
  char wrap_indent[80];
d3567 2
a3568 1
/*  We only print out user settable breakpoints unless the allflag is set. */
d3571 5
a3575 5
            && b->type != bp_catch_load
            && b->type != bp_catch_unload
            && b->type != bp_catch_fork
            && b->type != bp_catch_vfork
            && b->type != bp_catch_exec
d3584 1
a3584 1

d3587 10
a3596 107
            annotate_breakpoints_headers ();
  
            annotate_field (0);
            printf_filtered ("Num ");
            annotate_field (1);
            printf_filtered ("Type           ");
            annotate_field (2);
            printf_filtered ("Disp ");
            annotate_field (3);
            printf_filtered ("Enb ");
            if (addressprint)
              {
                annotate_field (4);
                printf_filtered ("Address    ");
              }
            annotate_field (5);
            printf_filtered ("What\n");
  
            annotate_breakpoints_table ();
          }
  
        annotate_record ();
        annotate_field (0);
        printf_filtered ("%-3d ", b->number);
        annotate_field (1);
        if ((int)b->type > (sizeof(bptypes)/sizeof(bptypes[0])))
          error ("bptypes table does not describe type #%d.", (int)b->type);
        if ((int)b->type != bptypes[(int)b->type].type)
          error ("bptypes table does not describe type #%d?", (int)b->type);
        printf_filtered ("%-14s ", bptypes[(int)b->type].description);
        annotate_field (2);
        printf_filtered ("%-4s ", bpdisps[(int)b->disposition]);
        annotate_field (3);
	printf_filtered ("%-3c ", bpenables[(int)b->enable]);

	strcpy (wrap_indent, "                           ");
	if (addressprint)
	  strcat (wrap_indent, "           ");
	switch (b->type)
	  {
	  case bp_watchpoint:
	  case bp_hardware_watchpoint:
	  case bp_read_watchpoint:
	  case bp_access_watchpoint:
	    /* Field 4, the address, is omitted (which makes the columns
	       not line up too nicely with the headers, but the effect
	       is relatively readable).  */
	    annotate_field (5);
	    print_expression (b->exp, gdb_stdout);
	    break;
 
          case bp_catch_load:
          case bp_catch_unload:
            /* Field 4, the address, is omitted (which makes the columns
               not line up too nicely with the headers, but the effect
               is relatively readable).  */
            annotate_field (5);
            if (b->dll_pathname == NULL)
              printf_filtered ("<any library> ");
            else
              printf_filtered ("library \"%s\" ", b->dll_pathname);
            break;

          case bp_catch_fork:
          case bp_catch_vfork:
	    /* Field 4, the address, is omitted (which makes the columns
	       not line up too nicely with the headers, but the effect
	       is relatively readable).  */
	    annotate_field (5);
	    if (b->forked_inferior_pid != 0)
	      printf_filtered ("process %d ", b->forked_inferior_pid);
            break;

          case bp_catch_exec:
	    /* Field 4, the address, is omitted (which makes the columns
	       not line up too nicely with the headers, but the effect
	       is relatively readable).  */
	    annotate_field (5);
	    if (b->exec_pathname != NULL)
	      printf_filtered ("program \"%s\" ", b->exec_pathname);
            break;
          case bp_catch_catch:
	    /* Field 4, the address, is omitted (which makes the columns
	       not line up too nicely with the headers, but the effect
	       is relatively readable).  */
	    annotate_field (5);
            printf_filtered ("exception catch ");
            break;
          case bp_catch_throw:
	    /* Field 4, the address, is omitted (which makes the columns
	       not line up too nicely with the headers, but the effect
	       is relatively readable).  */
	    annotate_field (5);
            printf_filtered ("exception throw ");
            break;

	  case bp_breakpoint:
	  case bp_hardware_breakpoint:
	  case bp_until:
	  case bp_finish:
	  case bp_longjmp:
	  case bp_longjmp_resume:
	  case bp_step_resume:
	  case bp_through_sigtramp:
	  case bp_watchpoint_scope:
	  case bp_call_dummy:
	  case bp_shlib_event:
d3599 2
a3600 7
	        annotate_field (4);
		/* FIXME-32x64: need a print_address_numeric with
                   field width */
		printf_filtered
		  ("%s ",
		   local_hex_string_custom
		   ((unsigned long) b->address, "08l"));
a3601 1

d3603 12
a3614 3

	    last_addr = b->address;
	    if (b->source_file)
d3616 2
a3617 71
		sym = find_pc_sect_function (b->address, b->section);
		if (sym)
		  {
		    fputs_filtered ("in ", gdb_stdout);
		    fputs_filtered (SYMBOL_SOURCE_NAME (sym), gdb_stdout);
		    wrap_here (wrap_indent);
		    fputs_filtered (" at ", gdb_stdout);
		  }
		fputs_filtered (b->source_file, gdb_stdout);
		printf_filtered (":%d", b->line_number);
	      }
	    else
	      print_address_symbolic (b->address, gdb_stdout, demangle, " ");
	    break;
	  }

        if (b->thread != -1)
            printf_filtered (" thread %d", b->thread );

	printf_filtered ("\n");

	if (b->frame)
	  {
            annotate_field (6);

	    printf_filtered ("\tstop only in stack frame at ");
	    print_address_numeric (b->frame, 1, gdb_stdout);
	    printf_filtered ("\n");
	  }

	if (b->cond)
	  {
            annotate_field (7);

	    printf_filtered ("\tstop only if ");
	    print_expression (b->cond, gdb_stdout);
	    printf_filtered ("\n");
	  }

	if (b->thread != -1)
	  {
	    /* FIXME should make an annotation for this */
	    printf_filtered ("\tstop only in thread %d\n", b->thread);
	  }

        if (show_breakpoint_hit_counts && b->hit_count)
	  {
	    /* FIXME should make an annotation for this */
            if (ep_is_catchpoint (b))
              printf_filtered ("\tcatchpoint");
            else
              printf_filtered ("\tbreakpoint");
            printf_filtered (" already hit %d time%s\n",
                             b->hit_count, (b->hit_count == 1 ? "" : "s"));
	  }

	if (b->ignore_count)
	  {
            annotate_field (8);

	    printf_filtered ("\tignore next %d hits\n", b->ignore_count);
	  }

	if ((l = b->commands))
	  {
            annotate_field (9);

	    while (l)
	      {
		print_command_line (l, 4);
		l = l->next;
d3619 4
d3624 2
d3627 1
a3627 1

d3630 7
d3638 1
a3638 1
        printf_filtered ("No breakpoints or watchpoints.\n");
d3640 2
a3641 1
        printf_filtered ("No breakpoint or watchpoint number %d.\n", bnum);
d3644 6
a3649 4
    /* Compare against (CORE_ADDR)-1 in case some compiler decides
       that a comparison of an unsigned with -1 is always false.  */
    if (last_addr != (CORE_ADDR)-1)
      set_next_address (last_addr);
d3651 5
a3672 2
#if MAINTENANCE_CMDS

d3674 1
a3674 1
void
a3686 2
#endif

d3699 3
a3701 3
      if (overlay_debugging == 0 ||
	  b->section == section)
	others++;
d3707 14
a3720 11
	  if (overlay_debugging == 0 ||
	      b->section == section)
	    {
	      others--;
	      printf_filtered
		("%d%s%s ",
		 b->number,
		 ((b->enable == disabled || b->enable == shlib_disabled || b->enable == call_disabled)
		  ? " (disabled)" : ""),
		 (others > 1) ? "," : ((others == 1) ? " and" : ""));
	    }
d3745 3
a3747 1
   This is so that the bpt instruction is only inserted once.  */
d3756 1
d3767 39
a3805 4
      {
	count++;
	b->duplicate = count > 1;
      }
d3868 12
d3889 1
a3889 1
  INIT_SAL (&sal);	/* initialize to zeroes */
d3894 2
a3895 1
      m = lookup_minimal_symbol_text (func_name, NULL, (struct objfile *)NULL);
d3903 2
a3904 1
  if (!b) return;
d3911 1
a3911 1
    b->addr_string = strsave(func_name);
d3915 1
a3915 1
#endif	/* #ifdef GET_LONGJMP_TARGET */
d3917 2
a3918 2
/* Call this routine when stepping and nexting to enable a breakpoint if we do
   a longjmp().  When we hit that breakpoint, call
d3922 1
a3922 1
enable_longjmp_breakpoint()
d3928 4
a3931 4
      {
	b->enable = enabled;
	check_duplicates (b->address, b->section);
      }
d3935 1
a3935 1
disable_longjmp_breakpoint()
d3940 1
a3940 1
    if (   b->type == bp_longjmp
d3942 40
a3981 4
      {
	b->enable = disabled;
	check_duplicates (b->address, b->section);
      }
d3992 1
a3992 1
      delete_breakpoint (b);
d3995 1
a3995 1
void
d4002 1
a4002 1
  INIT_SAL (&sal);	/* initialize to zeroes */
d4009 2
d4013 3
d4020 2
a4021 2
  struct breakpoint *  b;
  int  disabled_shlib_breaks = 0;
d4025 1
a4025 1
    {
d4027 18
a4044 19
      if (((b->type == bp_breakpoint) ||
           (b->type == bp_hardware_breakpoint)) &&
          (b->enable != shlib_disabled) &&
          (b->enable != call_disabled) &&
          ! b->duplicate &&
          PC_SOLIB (b->address))
        {
          b->enable = shlib_disabled;
	  if (!silent)
	    {
	      if (!disabled_shlib_breaks)
		{
		  target_terminal_ours_for_output ();
		  printf_filtered ("Temporarily disabling shared library breakpoints:\n");
		}
	      disabled_shlib_breaks = 1;
	      printf_filtered ("%d ", b->number);
	    }
        }
d4046 1
a4046 3
    }
  if (disabled_shlib_breaks && !silent)
    printf_filtered ("\n");
d4057 2
a4058 2
      {
	char buf[1];
d4060 5
a4064 5
	/* Do not reenable the breakpoint if the shared library
	   is still not mapped in.  */
	if (target_read_memory (b->address, buf, 1) == 0)
	  b->enable = enabled;
      }
d4070 6
a4075 6
create_solib_load_unload_event_breakpoint (hookname, tempflag, dll_pathname, cond_string, bp_kind)
  char *  hookname;
  int  tempflag;
  char *  dll_pathname;
  char *  cond_string;
  enum bptype  bp_kind;
d4077 1
a4077 1
  struct breakpoint *  b;
d4079 7
a4085 9
  struct symtab_and_line  sal;
  struct cleanup *  old_chain;
  struct cleanup *  canonical_strings_chain = NULL;
  int  i;
  char *  addr_start = hookname;
  char *  addr_end = NULL;
  char **  canonical = (char **) NULL;
  int  thread = -1;  /* All threads. */
 
d4089 1
a4089 1
 
d4099 1
a4099 1
      warning ("Unable to set a unique breakpoint on dynamic linker callback.");
d4104 2
a4105 2
  /* Make sure that all storage allocated in decode_line_1 gets freed in case
     the following errors out.  */
d4107 1
a4107 1
  if (canonical != (char **)NULL)
d4112 1
a4112 1
        make_cleanup (free, canonical[0]);
d4114 1
a4114 1
 
d4116 1
a4116 1
 
d4118 1
a4118 1
  if (canonical != (char **)NULL)
d4120 1
a4120 1
 
d4125 2
a4126 1
  b->cond_string = (cond_string == NULL) ? NULL : savestring (cond_string, strlen (cond_string));
d4128 2
a4129 2
 
  if (canonical != (char **)NULL && canonical[0] != NULL)
d4133 1
a4133 1
 
d4136 1
a4136 1
 
d4145 1
a4145 1
 
d4151 9
a4159 11
create_solib_load_event_breakpoint (hookname, tempflag, dll_pathname, cond_string)
  char *  hookname;
  int  tempflag;
  char *  dll_pathname;
  char *  cond_string;
{
  create_solib_load_unload_event_breakpoint (hookname,
                                             tempflag,
                                             dll_pathname,
                                             cond_string,
                                             bp_catch_load);
d4163 9
a4171 11
create_solib_unload_event_breakpoint (hookname, tempflag, dll_pathname, cond_string)
  char *  hookname;
  int  tempflag;
  char *  dll_pathname;
  char *  cond_string;
{
  create_solib_load_unload_event_breakpoint (hookname,
                                             tempflag,
                                             dll_pathname,
                                             cond_string,
                                             bp_catch_unload);
d4176 9
a4184 9
  int  tempflag;
  char *  cond_string;
  enum bptype  bp_kind;
{
  struct symtab_and_line  sal;
  struct breakpoint *  b;
  int  thread = -1;  /* All threads. */
 
  INIT_SAL(&sal);
d4188 1
a4188 1
 
d4193 2
a4194 1
  b->cond_string = (cond_string == NULL) ? NULL : savestring (cond_string, strlen (cond_string));
d4200 1
a4200 1
 
d4202 1
a4202 1
 
d4208 2
a4209 2
  int  tempflag;
  char *  cond_string;
d4213 1
a4213 1
 
d4216 2
a4217 2
  int  tempflag;
  char *  cond_string;
d4224 2
a4225 2
  int  tempflag;
  char *  cond_string;
d4227 3
a4229 3
  struct symtab_and_line  sal;
  struct breakpoint *  b;
  int  thread = -1;  /* All threads. */
d4231 1
a4231 1
  INIT_SAL(&sal);
d4240 2
a4241 1
  b->cond_string = (cond_string == NULL) ? NULL : savestring (cond_string, strlen (cond_string));
d4253 1
a4253 1
hw_breakpoint_used_count()
d4259 4
a4262 4
    {
      if (b->type == bp_hardware_breakpoint && b->enable == enabled)
	i++;
    }
d4268 3
a4270 3
hw_watchpoint_used_count(type, other_type_used)
    enum bptype type;
    int *other_type_used;
d4277 12
a4288 11
    {
      if (b->enable == enabled)
	{
          if (b->type == type) i++;
          else if ((b->type == bp_hardware_watchpoint ||
	       b->type == bp_read_watchpoint ||
	       b->type == bp_access_watchpoint)
	       && b->enable == enabled)
	    *other_type_used = 1;
        }
    }
d4292 2
a4293 2
/* Call this after hitting the longjmp() breakpoint.  Use this to set a new
   breakpoint at the target of the jmp_buf.
d4295 2
a4296 2
   FIXME - This ought to be done by setting a temporary breakpoint that gets
   deleted automatically... */
d4299 1
a4299 1
set_longjmp_resume_breakpoint(pc, frame)
d4307 10
a4316 10
      {
	b->address = pc;
	b->enable = enabled;
	if (frame != NULL)
	  b->frame = frame->frame;
	else
	  b->frame = 0;
	check_duplicates (b->address, b->section);
	return;
      }
d4322 1
a4322 1
  struct breakpoint *  b;
d4325 12
a4336 12
    {
      if (((b->type == bp_watchpoint)
           || (b->type == bp_hardware_watchpoint)
           || (b->type == bp_read_watchpoint)
           || (b->type == bp_access_watchpoint)
           || ep_is_exception_catchpoint (b))
          && (b->enable == enabled))
        {
          b->enable = call_disabled;
          check_duplicates (b->address, b->section);
        }
    }
d4342 1
a4342 1
  struct breakpoint *  b;
d4345 12
a4356 12
    {
      if (((b->type == bp_watchpoint)
           || (b->type == bp_hardware_watchpoint)
           || (b->type == bp_read_watchpoint)
           || (b->type == bp_access_watchpoint)
           || ep_is_exception_catchpoint (b))
          && (b->enable == call_disabled))
        {
          b->enable = enabled;
          check_duplicates (b->address, b->section);
        }
    }
d4385 1
a4386 1

d4394 7
d4409 1
d4412 22
a4433 3
    {
    case bp_none:
      printf_filtered ("(apparently deleted?) Eventpoint %d: ", b->number);
d4435 1
d4444 21
d4470 2
a4471 1
      printf_filtered ("Hardware access (read/write) watchpoint %d: ",b->number);
d4474 1
d4476 7
d4487 7
d4500 4
a4503 3
                       b->number,
                       (b->type == bp_catch_load) ? "load" : "unload",
                       (b->dll_pathname != NULL) ? b->dll_pathname : "<any library>");
d4508 2
a4509 2
                       b->number,
                       (b->type == bp_catch_fork) ? "fork" : "vfork");
d4513 1
a4513 1
                       b->number);
d4518 2
a4519 2
                       b->number,
                       (b->type == bp_catch_catch) ? "catch" : "throw");
d4531 1
d4544 2
a4545 2
      TUIDO(((TuiOpaqueFuncPtr)tui_vAllSetHasBreakAt, b, 1));
      TUIDO(((TuiOpaqueFuncPtr)tuiUpdateAllExecInfos));
d4547 7
a4555 1

a4556 3
/* Set a breakpoint according to ARG (function, linenum or *address)
   flag: first bit  : 0 non-temporary, 1 temporary.
	 second bit : 0 normal breakpoint, 1 hardware breakpoint. */
d4558 27
a4584 10
static void
break_command_1 (arg, flag, from_tty)
     char *arg;
     int flag, from_tty;
{
  int tempflag, hardwareflag;
  struct symtabs_and_lines sals;
  struct symtab_and_line sal;
  register struct expression *cond = 0;
  register struct breakpoint *b;
d4586 7
a4592 12
  /* Pointers in arg to the start, and one past the end, of the condition.  */
  char *cond_start = NULL;
  char *cond_end = NULL;
  /* Pointers in arg to the start, and one past the end,
     of the address part.  */
  char *addr_start = NULL;
  char *addr_end = NULL;
  struct cleanup *old_chain;
  struct cleanup *canonical_strings_chain = NULL;
  char **canonical = (char **)NULL;
  int i;
  int thread;
d4594 18
a4611 2
  hardwareflag = flag & BP_HARDWAREFLAG;
  tempflag = flag & BP_TEMPFLAG;
d4613 4
a4616 2
  sals.sals = NULL;
  sals.nelts = 0;
d4618 11
a4628 6
  INIT_SAL (&sal);	/* initialize to zeroes */

  /* If no arg given, or if first arg is 'if ', use the default breakpoint. */

  if (!arg || (arg[0] == 'i' && arg[1] == 'f' 
	       && (arg[2] == ' ' || arg[2] == '\t')))
d4632 3
a4634 1
	  sals.sals = (struct symtab_and_line *) 
d4639 3
a4641 3
	  sal.section  = find_pc_overlay (sal.pc);
	  sals.sals[0] = sal;
	  sals.nelts = 1;
a4647 2
      addr_start = arg;

d4649 3
a4651 3
	 current_source_symtab (which is decode_line_1's default).  This
	 should produce the results we want almost all of the time while
	 leaving default_breakpoint_* alone.  */
d4654 3
a4656 3
	      || (arg && (*arg == '+' || *arg == '-'))))
	sals = decode_line_1 (&arg, 1, default_breakpoint_symtab,
			      default_breakpoint_line, &canonical);
d4658 1
a4658 3
	sals = decode_line_1 (&arg, 1, (struct symtab *)NULL, 0, &canonical);

      addr_end = arg;
d4660 4
a4663 8
  
  if (! sals.nelts) 
    return;

  /* Make sure that all storage allocated in decode_line_1 gets freed in case
     the following `for' loop errors out.  */
  old_chain = make_cleanup (free, sals.sals);
  if (canonical != (char **)NULL)
d4665 2
a4666 3
      make_cleanup (free, canonical);
      canonical_strings_chain = make_cleanup (null_cleanup, 0);
      for (i = 0; i < sals.nelts; i++)
d4668 3
a4670 2
	  if (canonical[i] != NULL)
	    make_cleanup (free, canonical[i]);
d4673 2
d4676 2
a4677 1
  thread = -1;			/* No specific thread yet */
d4679 6
a4684 3
  /* Resolve all line numbers to PC's, and verify that conditions
     can be parsed, before setting any breakpoints.  */
  for (i = 0; i < sals.nelts; i++)
d4686 1
a4686 4
      char *tok, *end_tok;
      int toklen;

      resolve_sal_pc (&sals.sals[i]);
d4701 80
a4780 6
      if (PC_REQUIRES_RUN_BEFORE_USE(sals.sals[i].pc))
        {
          error ("Cannot break on %s without a running program.", addr_start);
        }
      
      tok = arg;
d4782 7
d4791 4
d4808 2
a4809 1
	      cond = parse_exp_1 (&tok, block_for_pc (sals.sals[i].pc), 0);
d4811 2
d4830 7
a4836 1
  if (hardwareflag)
d4838 22
a4859 1
      int i, target_resources_ok;
d4861 11
a4871 8
      i = hw_breakpoint_used_count ();  
      target_resources_ok = TARGET_CAN_USE_HARDWARE_WATCHPOINT (
		bp_hardware_breakpoint, i + sals.nelts, 0);
      if (target_resources_ok == 0)
	error ("No hardware breakpoint support in the target.");
      else if (target_resources_ok < 0)
        error ("Hardware breakpoints used exceeds limit.");
    }
d4873 1
a4873 3
  /* Remove the canonical strings from the cleanup, they are needed below.  */
  if (canonical != (char **)NULL)
    discard_cleanups (canonical_strings_chain);
d4875 38
a4912 1
  /* Now set all the breakpoints.  */
d4915 3
a4917 1
      sal = sals.sals[i];
d4919 5
a4923 2
      if (from_tty)
	describe_other_breakpoints (sal.pc, sal.section);
d4925 2
a4926 6
      b = set_raw_breakpoint (sal);
      set_breakpoint_count (breakpoint_count + 1);
      b->number = breakpoint_count;
      b->type = hardwareflag ? bp_hardware_breakpoint : bp_breakpoint;
      b->cond = cond;
      b->thread = thread;
d4928 13
a4940 12
      /* If a canonical line spec is needed use that instead of the
	 command string.  */
      if (canonical != (char **)NULL && canonical[i] != NULL)
	b->addr_string = canonical[i];
      else if (addr_start)
	b->addr_string = savestring (addr_start, addr_end - addr_start);
      if (cond_start)
	b->cond_string = savestring (cond_start, cond_end - cond_start);
				     
      b->enable = enabled;
      b->disposition = tempflag ? del : donttouch;
      mention (b);
d4943 9
a4951 5
  if (sals.nelts > 1)
    {
      printf_filtered ("Multiple breakpoints were set.\n");
      printf_filtered ("Use the \"delete\" command to delete unwanted breakpoints.\n");
    }
d4953 17
d4972 1
d5028 1
a5028 1
      extra_args_len = strlen (arg); 
d5033 1
a5033 1
      if (find_pc_partial_function(selected_pc, (char **)NULL, &low, &high))
d5037 1
a5037 1
	    sprintf (addr_string, "*0x%x %s", high, extra_args);
d5039 1
a5039 1
	    sprintf (addr_string, "*0x%x", high);
d5074 1
a5074 1
	      sprintf (addr_string, "*0x%x", selected_frame->pc);
d5093 11
a5103 1
      extra_args_len = strlen (arg); 
a5104 11
  else
    if (arg)
      {
	/* get the stuff after the function name or address */
	extra_args = strchr (arg, ' ');
        if (extra_args)
	  {
	    extra_args++;
	    extra_args_len = strlen (extra_args);
          }
      }
d5109 3
a5111 3
  beg_addr_string = addr_string;  
  sals = decode_line_1 (&addr_string, 1, (struct symtab *)NULL, 0, 
			(char ***)NULL);
d5118 1
a5118 1
      if (find_pc_partial_function (sal.pc, (char **)NULL, &low, &high))
d5122 1
a5122 1
	    sprintf (break_string, "*0x%x %s", high, extra_args);
d5124 1
a5124 1
	    sprintf (break_string, "*0x%x", high);
d5126 1
a5126 1
	  free(break_string);
d5133 2
a5134 2
      printf_filtered ("Multiple breakpoints were set.\n");
      printf_filtered ("Use the \"delete\" command to delete unwanted breakpoints.\n");
d5136 1
a5136 1
  do_cleanups(old_chain);
d5159 3
a5161 3
      struct block       *b;
      struct symbol      *sym;
      int                 index;
d5163 1
a5163 1
      bv  = blockvector_for_pc_sect (sal->pc, 0, &index, sal->symtab);
d5166 1
a5166 1
	  b   = BLOCKVECTOR_BLOCK (bv, index);
d5176 3
a5178 3
		 have to look harder. This case can be executed if we have 
		 line numbers but no functions (as can happen in assembly 
		 source).  */
d5180 1
a5180 1
	      struct minimal_symbol *msym; 
d5198 1
a5198 1
void
d5206 1
a5206 1
void
d5222 1
a5222 1
void
d5263 1
a5263 1
  if (arg == (char *)NULL)
d5270 3
a5272 3
      /* look for a ':'.  If this is a line number specification, then say
	 it is bad, otherwise, it should be an address or function/method
	 name */
d5274 4
a5277 4
        {
          hasColon = (*argptr == ':');
          argptr++;
        }
d5280 1
a5280 1
        badInput = (*argptr != ':'); /* Not a class::method */
d5282 1
a5282 1
        badInput = isdigit(*arg); /* a simple line number */
d5286 1
a5286 1
    printf_filtered("Usage: stop in <function | address>\n");
d5298 1
a5298 1
  if (arg == (char *)NULL || *arg == '*') /* no line number */
d5306 1
a5306 1
	 it is probably a line number. */
d5308 4
a5311 4
        {
          hasColon = (*argptr == ':');
          argptr++;
        }
d5314 1
a5314 1
        badInput = (*argptr == ':'); /* we have class::method */
d5316 1
a5316 1
        badInput = !isdigit(*arg); /* not a line number */
d5320 1
a5320 1
    printf_filtered("Usage: stop at <line>\n");
d5326 3
a5328 1
/* accessflag:  0: watch write, 1: watch read, 2: watch access(read or write) */
d5353 2
a5354 2
  INIT_SAL (&sal);	/* initialize to zeroes */
  
d5383 1
a5383 1
    error("Junk at end of command.");
d5385 6
a5390 3
  if (accessflag == 1) bp_type = bp_read_watchpoint;
  else if (accessflag == 2) bp_type = bp_access_watchpoint;
  else bp_type = bp_hardware_watchpoint;
d5395 12
a5406 9
  if (mem_cnt != 0) { 
    i = hw_watchpoint_used_count (bp_type, &other_type_used);
    target_resources_ok = TARGET_CAN_USE_HARDWARE_WATCHPOINT(
		bp_type, i + mem_cnt, other_type_used);
    if (target_resources_ok == 0 && bp_type != bp_hardware_watchpoint)
      error ("Target does not have this type of hardware watchpoint support.");
    if (target_resources_ok < 0 && bp_type != bp_hardware_watchpoint)
      error ("Target resources have been allocated for other types of watchpoints.");
  }
d5409 1
a5409 1
 /*  On HP-UX if you set a h/w
d5423 1
a5423 1
  if (! target_has_execution)
d5429 1
a5429 1
  
d5444 1
a5444 1
         
d5452 1
a5452 1
    b->watchpoint_frame = (CORE_ADDR)0;
d5470 1
a5470 1
	  scope_sal.pc      = get_frame_pc (prev_frame);
d5503 7
a5509 2
#define TARGET_REGION_SIZE_OK_FOR_HW_WATCHPOINT(byte_size) \
    ((byte_size) <= (REGISTER_SIZE))
d5519 1
a5519 1
  if (! can_use_hw_watchpoints)
d5521 42
a5562 12
	
  /* Make sure all the intermediate values are in memory.  Also make sure
     we found at least one memory expression.  Guards against watch 0x12345,
     which is meaningless, but could cause errors if one tries to insert a 
     hardware watchpoint for the constant expression.  */
  for ( ; v; v = v->next)
    {
      if (v->lval == lval_memory)
	{
	  if (TARGET_REGION_SIZE_OK_FOR_HW_WATCHPOINT (TYPE_LENGTH (VALUE_TYPE (v))))
	    found_memory_cnt++;
        }
d5564 3
a5566 1
	return 0;
d5574 3
a5576 1
static void watch_command (arg, from_tty)
d5580 9
a5588 1
  watch_command_1 (arg, 0, from_tty);
d5591 11
a5601 1
static void rwatch_command (arg, from_tty)
d5605 1
a5605 1
  watch_command_1 (arg, 1, from_tty);
d5608 11
a5618 1
static void awatch_command (arg, from_tty)
d5622 1
a5622 1
  watch_command_1 (arg, 2, from_tty);
d5624 1
d5626 1
a5626 2

/* Helper routine for the until_command routine in infcmd.c.  Here
d5629 13
d5653 2
d5660 1
a5660 1
  
d5663 1
a5663 1
			  default_breakpoint_line, (char ***)NULL);
d5665 3
a5667 2
    sals = decode_line_1 (&arg, 1, (struct symtab *)NULL, 0, (char ***)NULL);
  
d5670 1
a5670 1
  
d5672 2
a5673 2
  free ((PTR)sals.sals);		/* malloc'd, so freed */
  
d5676 1
a5676 1
  
d5678 1
a5678 1
  
d5680 27
a5706 2
  
  old_chain = make_cleanup ((make_cleanup_func) delete_breakpoint, breakpoint);
d5709 1
a5709 1
  
d5715 4
a5718 1
      make_cleanup ((make_cleanup_func) delete_breakpoint, breakpoint);
d5720 1
a5720 1
  
d5722 4
a5725 1
  do_cleanups(old_chain);
d5759 1
d5770 1
a5770 1
     int (*function)();
d5808 1
a5808 1
	    alloca (sizeof (struct sal_chain));
d5820 2
a5821 1
      while (*p == ' ' || *p == '\t') p++;
d5824 1
d5898 1
a5898 1
			alloca (sizeof (struct sal_chain));
d5900 2
a5901 1
		      next->sal = find_pc_line (SYMBOL_VALUE_ADDRESS (sym), 0);
d5915 2
a5916 2
	 Don't continue to its superblock, the block of
	 per-file symbols.  */
d5943 1
a5943 1
    char **  s;
d5945 4
a5948 4
   if ((s == NULL) || (*s == NULL))
       return;
   while (isspace(**s))
       *s += 1;
d5950 1
a5950 1
 
d5955 1
d5958 1
a5958 1
  char *  arg;
d5960 3
a5962 3
  char *  s = arg;
  char *  event_name_end = NULL;
 
d5966 1
a5966 1
 
d5968 2
a5969 2
   Basically, we're looking for alphanumerics and underscores;
   anything else delimites the token. */
d5972 2
a5973 2
      if (! isalnum(*s) && (*s != '_'))
        break;
d5977 1
a5977 1
 
d5981 1
a5981 1
 
d5984 1
a5984 1
 
d5989 1
d5992 1
a5992 1
  char **  arg;
d5994 3
a5996 3
  char *  cond_string;
 
  if (((*arg)[0] != 'i') || ((*arg)[1] != 'f') || !isspace((*arg)[2]))
d5998 1
a5998 1
 
d6001 1
a6001 1
 
d6006 1
a6006 1
 
d6009 1
a6009 1
 
d6012 1
a6012 1
 
d6015 1
a6015 1
 
d6020 1
a6020 1
 
d6025 1
a6025 1
  char **  arg;
d6027 5
a6031 5
  static char  filename [1024];
  char *  arg_p = *arg;
  int  i;
  char  c;
 
d6034 2
a6035 2
 
  for (i=0; ; i++)
d6039 1
a6039 1
        c = '\0';
d6042 1
a6042 1
        break;
d6046 1
a6046 1
 
d6049 1
a6049 1
 
d6052 13
a6064 3
 
typedef enum {catch_fork, catch_vfork} catch_fork_kind;
 
d6067 4
a6070 4
  catch_fork_kind  fork_kind;
  char *  arg;
  int  tempflag;
  int  from_tty;
d6072 2
a6073 2
  char *  cond_string = NULL;
 
d6075 1
a6075 1
 
d6077 3
a6079 3
        catch [v]fork
        catch [v]fork if <cond>
 
d6082 1
a6082 1
 
d6085 1
a6085 1
 
d6088 3
a6090 2
  switch (fork_kind) {
    case catch_fork :
d6093 1
a6093 1
    case catch_vfork :
d6096 1
a6096 1
    default :
d6099 1
a6099 1
  }
d6101 1
d6103 1
d6106 3
a6108 3
  char *  arg;
  int  tempflag;
  int  from_tty;
d6110 1
a6110 1
  char *  cond_string = NULL;
d6115 2
a6116 2
        catch exec
        catch exec if <cond>
d6128 2
a6129 1
 
d6133 7
a6139 7
  char *  arg;
  int  tempflag;
  int  from_tty;
{
  char *  dll_pathname = NULL;
  char *  cond_string = NULL;
 
d6141 1
a6141 1
 
d6143 5
a6147 5
        catch load
        catch load if <cond>
        catch load <filename>
        catch load <filename> if <cond>
 
d6150 1
a6150 1
 
d6152 1
a6152 1
 
d6156 1
a6156 1
 
d6165 1
a6165 1
 
d6168 1
a6168 1
 
d6172 2
a6173 1
  SOLIB_CREATE_CATCH_LOAD_HOOK (inferior_pid, tempflag, dll_pathname, cond_string);
d6175 1
a6175 1
 
d6178 7
a6184 7
  char *  arg;
  int  tempflag;
  int  from_tty;
{
  char *  dll_pathname = NULL;
  char *  cond_string = NULL;
 
d6186 1
a6186 1
 
d6188 5
a6192 5
        catch unload
        catch unload if <cond>
        catch unload <filename>
        catch unload <filename> if <cond>
 
d6195 1
a6195 1
 
d6197 1
a6197 1
 
d6201 1
a6201 1
 
d6210 1
a6210 1
 
d6213 1
a6213 1
 
d6217 2
a6218 1
  SOLIB_CREATE_CATCH_UNLOAD_HOOK (inferior_pid, tempflag, dll_pathname, cond_string);
d6225 1
a6225 1
   exception event callback */ 
d6229 7
a6235 8
  int tempflag;
  char * cond_string;
  enum exception_event_kind ex_event;
  struct symtab_and_line * sal;
{
  struct breakpoint *  b;
  int  i;
  int  thread = -1;  /* All threads. */
d6237 1
a6237 1
  if (!sal) /* no exception support? */
d6244 2
a6245 1
  b->cond_string = (cond_string == NULL) ? NULL : savestring (cond_string, strlen (cond_string));
d6252 10
a6261 10
      case EX_EVENT_THROW:
        b->type = bp_catch_throw;
        break;
      case EX_EVENT_CATCH:
        b->type = bp_catch_catch;
        break;
      default: /* error condition */ 
        b->type = bp_none;
        b->enable = disabled;
        error ("Internal error -- invalid catchpoint kind");
d6266 1
a6266 1
/* Deal with "catch catch" and "catch throw" commands */ 
d6270 4
a6273 4
  enum exception_event_kind ex_event;
  char *  arg;
  int  tempflag;
  int  from_tty;
d6275 3
a6277 3
  char * cond_string = NULL;
  struct symtab_and_line * sal = NULL;
  
d6279 1
a6279 1
  
d6292 1
a6292 1
  if (sal) 
d6295 1
a6295 1
         Set a breakpoint on the sal found, if no errors */ 
d6297 1
a6297 1
        create_exception_catchpoint (tempflag, cond_string, ex_event, sal);
d6299 1
a6299 1
        return; /* something went wrong with setting up callbacks */ 
d6301 1
a6301 1
  else  
d6306 3
a6308 3
        {
          handle_gnu_4_16_catch_command (arg, tempflag, from_tty);
        }
d6310 7
a6316 7
        {
          /* Set a breakpoint on __raise_exception () */
          
          fprintf_filtered (gdb_stderr, "Unsupported with this platform/compiler combination.\n");
          fprintf_filtered (gdb_stderr, "Perhaps you can achieve the effect you want by setting\n");
          fprintf_filtered (gdb_stderr, "a breakpoint on __raise_exception().\n");
        }
d6325 1
a6325 1
  PTR arg;
d6335 1
a6335 1
    return 1; /*is valid*/
d6348 1
a6348 1
  
d6368 1
a6368 1
  INIT_SAL (&sal);	/* initialize to zeroes */
d6373 1
a6373 1
  if (!arg || (arg[0] == 'i' && arg[1] == 'f' 
d6388 1
a6388 1
         pai/1997-07-11 */ 
d6395 1
a6395 1
  if (! sals.nelts) 
d6402 1
a6402 1
      
d6407 1
a6407 1
	    cond = parse_exp_1 ((arg += 2, &arg), 
d6425 7
a6431 6
      b->type = bp_breakpoint; /* Important -- this is an ordinary breakpoint.
                                  For platforms with callback support for exceptions,
                                  create_exception_catchpoint() will create special
                                  bp types (bp_catch_catch and bp_catch_throw), and
                                  there is code in insert_breakpoints() and elsewhere
                                  that depends on that. */
d6442 2
a6443 2
      printf_unfiltered ("Multiple breakpoints were set.\n");
      printf_unfiltered ("Use the \"delete\" command to delete unwanted breakpoints.\n");
d6445 1
a6445 1
  free ((PTR)sals.sals);
d6453 1
a6453 1
  CORE_ADDR pc;
d6458 1
a6458 1
  INIT_SAL(&sal);
d6478 3
a6480 3
  char *arg;
  int tempflag;
  int from_tty;
d6482 1
a6482 1
 
d6487 1
a6487 1
 
d6489 4
a6492 4
  char *  arg1_start = arg;
  char *  arg1_end;
  int  arg1_length;
 
d6495 1
a6495 1
      /* Old behaviour was to use pre-v-4.16 syntax */ 
d6498 1
a6498 1
      /* Now, this is not allowed */ 
d6506 1
a6506 1
 
d6514 2
a6515 1
      catch_exception_command_1 (EX_EVENT_CATCH, arg1_end+1, tempflag, from_tty); 
d6519 2
a6520 1
      catch_exception_command_1 (EX_EVENT_THROW, arg1_end+1, tempflag, from_tty);
d6545 1
a6545 1
      catch_fork_command_1 (catch_fork, arg1_end+1, tempflag, from_tty);
d6553 1
a6553 1
      catch_fork_command_1 (catch_vfork, arg1_end+1, tempflag, from_tty);
d6561 1
a6561 1
      catch_exec_command_1 (arg1_end+1, tempflag, from_tty);
d6569 1
a6569 1
      catch_load_command_1 (arg1_end+1, tempflag, from_tty);
d6577 1
a6577 1
      catch_unload_command_1 (arg1_end+1, tempflag, from_tty);
d6586 1
a6586 1
 
d6592 1
a6592 1
         as the name of an exception */ 
d6594 1
a6594 1
      /* Now this is not allowed */ 
d6680 1
a6680 1
      sals.sals = (struct symtab_and_line *) 
d6682 1
a6682 1
      INIT_SAL (&sal);	/* initialize to zeroes */
d6706 2
a6707 2
	 If line given (pc == 0), clear all bpts on specified line.
	 If defaulting, clear all bpts on default line
d6709 7
a6715 7
       
		defaulting    sal.pc != 0    tests to do
       
                0              1             pc
                1              1             pc _and_ line
                0              0             line
                1              0             <can't happen> */
d6722 15
a6736 15
             /* Why don't we check here that this is not
		a watchpoint, etc., as we do below?
		I can't make it fail, but don't know
		what's stopping the failure: a watchpoint
		of the same address as "sal.pc" should
		wind up being deleted. */
 
             && (  ((sal.pc && (breakpoint_chain->address == sal.pc)) &&
                   (overlay_debugging == 0 ||
                    breakpoint_chain->section == sal.section))
                || ((default_match || (0 == sal.pc))
                   && breakpoint_chain->source_file != NULL
                   && sal.symtab != NULL
                   && STREQ (breakpoint_chain->source_file, sal.symtab->filename)
                   && breakpoint_chain->line_number == sal.line)))
d6747 14
a6760 14
      while (b->next
             && b->next->type != bp_none
             && b->next->type != bp_watchpoint
             && b->next->type != bp_hardware_watchpoint
             && b->next->type != bp_read_watchpoint
             && b->next->type != bp_access_watchpoint
             && (  ((sal.pc && (b->next->address == sal.pc)) &&
                   (overlay_debugging == 0 ||
                    b->next->section == sal.section))
                || ((default_match || (0 == sal.pc))
                   && b->next->source_file != NULL
                   && sal.symtab != NULL
                   && STREQ (b->next->source_file, sal.symtab->filename)
                   && b->next->line_number == sal.line)))
d6763 6
a6768 6
	  {
	    b1 = b->next;
	    b->next = b1->next;
	    b1->next = found;
	    found = b1;
	  }
d6778 4
a6781 2
      if (found->next) from_tty = 1; /* Always report if deleted more than one */
      if (from_tty) printf_unfiltered ("Deleted breakpoint%s ", found->next ? "s" : "");
d6785 2
a6786 1
	  if (from_tty) printf_unfiltered ("%d ", found->number);
d6791 2
a6792 1
      if (from_tty) putchar_unfiltered ('\n');
d6794 1
a6794 1
  free ((PTR)sals.sals);
d6808 1
a6808 1
    if (bs->breakpoint_at && bs->breakpoint_at->disposition == del 
d6813 4
a6816 4
    {
      if (b->disposition == del_at_next_stop)
	delete_breakpoint (b);
    }
d6819 2
a6820 1
/* Delete a breakpoint and clean up all traces of it in the data structures. */
d6851 1
d6855 1
a6855 1
      
d6864 1
a6864 1
     exceptions are supported in this way, it's OK for now. FIXME */ 
d6871 4
a6874 2
      sprintf (message, message1, bpt->number);	/* Format possible error msg */
      args.kind = bpt->type == bp_catch_catch ? EX_EVENT_CATCH : EX_EVENT_THROW;
d6883 4
a6886 4
      {
	b->next = bpt->next;
	break;
      }
d6895 5
a6899 5
        {
          clearIt = (b->address != bpt->address);
          if (!clearIt)
            break;
        }
d6902 4
a6905 4
        {
          TUIDO(((TuiOpaqueFuncPtr)tui_vAllSetHasBreakAt, bpt, 0));
          TUIDO(((TuiOpaqueFuncPtr)tuiUpdateAllExecInfos));
        }
d6926 14
a6939 2
	  {
	    int val;
d6941 10
a6950 9
	    if (val != 0)
	      {
		target_terminal_ours_for_output ();
		fprintf_unfiltered (gdb_stderr, "Cannot insert breakpoint %d:\n", b->number);
		memory_error (val, b->address);	/* which bombs us out */
	      }
	    else
	      b->inserted = 1;
	  }
d6995 1
a6995 1
  free ((PTR)bpt);
d7010 10
a7019 9
	 Do not delete internal or call-dummy breakpoints, these
	 have to be deleted with an explicit breakpoint number argument.  */
      ALL_BREAKPOINTS (b) 
	{
	  if (b->type != bp_call_dummy && 
              b->type != bp_shlib_event && 
              b->number >= 0)
	    breaks_to_delete = 1;
	}
d7025 8
a7032 7
	  ALL_BREAKPOINTS_SAFE (b, temp) 
	    {
	      if (b->type != bp_call_dummy &&
                  b->type != bp_shlib_event &&
                  b->number >= 0)
		delete_breakpoint (b);
	    }
d7047 2
a7048 1
  struct breakpoint *b = (struct breakpoint *)bint;  /* get past catch_errs */
d7058 2
a7059 1
      warning ("attempted to reset apparently deleted breakpoint #%d?\n", b->number);
d7072 1
a7072 1
	 its status if we succeed.  */
d7079 1
a7079 1
      sals = decode_line_1 (&s, 1, (struct symtab *)NULL, 0, (char ***)NULL);
d7090 1
a7090 1
		free ((PTR)b->cond);
d7094 1
a7094 1
	  /* We need to re-set the breakpoint if the address changes...*/
d7096 2
a7097 2
	      /* ...or new and old breakpoints both have source files, and
		 the source file name or the line number changes...  */
d7102 3
a7104 3
		  )
	      /* ...or we switch between having a source file and not having
		 one.  */
d7106 1
a7106 1
	      )
d7119 3
a7121 3
             /* Used to check for duplicates here, but that can
		cause trouble, as it doesn't check for disable
                breakpoints. */
d7126 1
a7126 1
		 rather than once for every breakpoint.  */
d7133 1
a7133 1
          /* Now that this is re-enabled, check_duplicates
d7135 1
a7135 1
          check_duplicates (b->address, b->section);
d7138 1
a7138 1
      free ((PTR)sals.sals);
d7146 8
a7153 7
      /* The issue arises of what context to evaluate this in.  The same
	 one as when it was set, but what does that mean when symbols have
	 been re-read?  We could save the filename and functionname, but
	 if the context is more local than that, the best we could do would
	 be something like how many levels deep and which index at that
	 particular level, but that's going to be less stable than filenames
	 or functionnames.  */
d7156 1
a7156 1
	free ((PTR)b->exp);
d7171 2
a7172 2
	    free ((PTR)b->cond);
	  b->cond = parse_exp_1 (&s, (struct block *)0, 0);
d7178 2
a7179 2
    case bp_catch_catch:  
    case bp_catch_throw:  
d7181 3
a7183 3
    /* We needn't really do anything to reset these, since the mask
       that requests them is unaffected by e.g., new libraries being
       loaded. */
d7188 1
a7188 1
 
d7192 2
a7193 2
    /* Delete longjmp breakpoints, they will be reset later by
       breakpoint_re_set.  */
d7199 2
a7200 2
    /* This breakpoint is special, it's set up when the inferior
       starts and we really don't want to touch it.  */
d7203 8
a7210 4
    /* Keep temporary breakpoints, which can be encountered when we step
       over a dlopen call and SOLIB_ADD is resetting the breakpoints.
       Otherwise these should have been blown away via the cleanup chain
       or by breakpoint_init_inferior when we rerun the executable.  */
d7230 2
a7231 2
  char message[sizeof (message1) + 30 /* slop */];
  
d7235 5
a7239 4
    {
      sprintf (message, message1, b->number);	/* Format possible error msg */
      catch_errors (breakpoint_re_set_one, b, message, RETURN_MASK_ALL);
    }
d7269 1
a7269 1
  struct breakpoint *  b;
d7274 1
a7274 1
        b->thread = pid_to_thread_id (inferior_pid);
d7289 3
a7291 14
      {
	b->ignore_count = count;
	if (!from_tty)
	  return;
	else if (count == 0)
	  printf_filtered ("Will stop next time breakpoint %d is reached.",
			   bptnum);
	else if (count == 1)
	  printf_filtered ("Will ignore next crossing of breakpoint %d.",
			   bptnum);
	else
	  printf_filtered ("Will ignore next %d crossings of breakpoint %d.",
		  count, bptnum);
	breakpoints_changed ();
d7293 12
a7304 1
      }
d7331 1
a7331 1
  
d7333 2
a7334 1

d7356 2
a7357 1
  register struct breakpoint *b;
d7364 1
a7365 2
      
      num = get_number (&p1);
d7367 20
a7386 11
      ALL_BREAKPOINTS (b)
	if (b->number == num)
	  {
	    struct breakpoint *related_breakpoint = b->related_breakpoint;
	    function (b);
	    if (related_breakpoint)
	      function (related_breakpoint);
	    goto win;
	  }
      printf_unfiltered ("No breakpoint number %d.\n", num);
    win:
d7401 4
d7411 1
d7424 22
a7445 21
	{
        case bp_none:
          warning ("attempted to disable apparently deleted breakpoint #%d?\n", bpt->number);
          continue;
	case bp_breakpoint:
        case bp_catch_load:
        case bp_catch_unload:
        case bp_catch_fork:
        case bp_catch_vfork:
        case bp_catch_exec:
	case bp_catch_catch:
	case bp_catch_throw:
        case bp_hardware_breakpoint:
        case bp_watchpoint:
        case bp_hardware_watchpoint:
        case bp_read_watchpoint:
        case bp_access_watchpoint:
	  disable_breakpoint (bpt);
	default:
	  continue;
	}
d7463 4
a7466 3
      i = hw_breakpoint_used_count();
      target_resources_ok = TARGET_CAN_USE_HARDWARE_WATCHPOINT(
		bp_hardware_breakpoint, i+1, 0);
d7468 1
a7468 1
        error ("No hardware breakpoint support in the target.");
d7470 1
a7470 1
        error ("Hardware breakpoints used exceeds limit.");
d7473 2
a7474 1
  bpt->enable = enabled;
d7479 4
a7482 2
  if (bpt->type == bp_watchpoint || bpt->type == bp_hardware_watchpoint ||
      bpt->type == bp_read_watchpoint || bpt->type == bp_access_watchpoint)
d7488 5
a7492 5
          /* Ensure that we have the current frame.  Else, this
             next query may pessimistically be answered as, "No,
             not within current scope". */
          get_current_frame ();
          fr = find_frame_addr_in_frame_chain (bpt->watchpoint_frame);
d7515 5
a7519 5
           bpt->type == bp_read_watchpoint ||
           bpt->type == bp_access_watchpoint)
      {
        int i = hw_watchpoint_used_count (bpt->type, &other_type_used);
        int mem_cnt = can_use_hardware_watchpoint (bpt->val);
d7521 9
a7529 9
        /* Hack around 'unused var' error for some targets here */
        (void) mem_cnt, i;
        target_resources_ok = TARGET_CAN_USE_HARDWARE_WATCHPOINT(
                bpt->type, i + mem_cnt, other_type_used);
        /* we can consider of type is bp_hardware_watchpoint, convert to 
	   bp_watchpoint in the following condition */
        if (target_resources_ok < 0)
	  {
             printf_filtered("\
d7532 5
a7536 5
	     bpt->enable = disabled;
	     value_free_to_mark (mark);
	     return;
          }
      }
d7539 2
a7540 1
	select_and_print_frame (save_selected_frame, save_selected_frame_level);
d7545 1
d7569 22
a7590 21
	{
        case bp_none:
          warning ("attempted to enable apparently deleted breakpoint #%d?\n", bpt->number);
          continue;
	case bp_breakpoint:
        case bp_catch_load:
        case bp_catch_unload:
        case bp_catch_fork:
        case bp_catch_vfork:
        case bp_catch_exec:
	case bp_catch_catch:
	case bp_catch_throw:
	case bp_hardware_breakpoint:
	case bp_watchpoint:
	case bp_hardware_watchpoint:
	case bp_read_watchpoint:
	case bp_access_watchpoint:
	  enable_breakpoint (bpt);
	default:
	  continue;
	}
d7639 3
a7641 2
			  default_breakpoint_symtab, default_breakpoint_line,
			  (char ***)NULL);
d7644 1
a7644 1
			  (struct symtab *)NULL, 0, (char ***)NULL);
d7664 1
a7664 1
    add_com_alias("bc", "ignore", class_breakpoint, 1);
d7685 2
a7686 2
  add_com("txbreak", class_breakpoint, tbreak_at_finish_command,
          "Set temporary breakpoint at procedure exit.  Either there should\n\
d7707 2
a7708 2
      add_com("ab", class_breakpoint, enable_command,
		      "Enable some breakpoints.\n\
d7717 1
a7717 1
		  "Enable some breakpoints.\n\
d7721 1
a7721 1
		  &enablebreaklist, "enable breakpoints ", 1, &enablelist);
d7744 1
a7744 1
	   "Disable some breakpoints.\n\
d7752 2
a7753 2
    add_com("sb", class_breakpoint, disable_command,
	        "Disable some breakpoints.\n\
d7767 1
a7767 1
	   "Delete some breakpoints or auto-display expressions.\n\
d7777 1
a7777 1
    	   "Delete some breakpoints.\n\
d7794 1
a7794 1
"With no argument, clears all breakpoints in the line that the selected frame\n\
d7805 1
a7805 1
"With no arg, uses current execution address of selected stack frame.\n\
d7816 2
a7817 2
  add_com("xbreak", class_breakpoint, break_at_finish_command,
          concat("Set breakpoint at procedure exit. \n\
d7822 1
a7822 1
"With no arg, uses current execution address of selected stack frame.\n\
d7838 1
a7838 1
          "Set breakpoint at procedure exit.  Either there should\n\
d7844 9
a7852 9
      add_abbrev_prefix_cmd("stop", class_breakpoint, stop_command, 
           "Break in function/address or break at a line in the current file.",
           &stoplist, "stop ", 1, &cmdlist);
      add_cmd("in", class_breakpoint, stopin_command,
              "Break in function or address.\n", &stoplist);
      add_cmd("at", class_breakpoint, stopat_command,
              "Break at a line in the current file.\n", &stoplist);
      add_com("status", class_info, breakpoints_info, 
	    concat ("Status of user-settable breakpoints, or breakpoint number NUMBER.\n\
d7860 1
a7860 1
"Convenience variable \"$_\" and default examine address for \"x\"\n\
d7875 1
a7875 1
"Convenience variable \"$_\" and default examine address for \"x\"\n\
d7881 2
a7882 2
    add_com("lb", class_breakpoint, breakpoints_info,
	    concat ("Status of user-settable breakpoints, or breakpoint number NUMBER.\n\
d7890 1
a7890 1
"Convenience variable \"$_\" and default examine address for \"x\"\n\
a7894 2
#if MAINTENANCE_CMDS

d7896 1
a7896 1
	    concat ("Status of all breakpoints, or breakpoint number NUMBER.\n\
d7904 1
a7904 1
"The \"Disp\" column contains one of \"keep\", \"del\", or \"dis\" to indicate\n\
d7908 1
a7908 1
"Convenience variable \"$_\" and default examine address for \"x\"\n\
a7913 2
#endif	/* MAINTENANCE_CMDS */

d7915 1
a7915 1
         "Set catchpoints to catch events.\n\
d7948 1
a7948 1
 
d7950 1
a7950 1
         "Set temporary catchpoints to catch events.\n\
a7954 2
 
add_com ("watch", class_breakpoint, watch_command,
d7956 1
d7976 2
a7977 2
                   (char *) &can_use_hw_watchpoints,
                   "Set debugger's willingness to use watchpoint hardware.\n\
d7982 1
a7982 1
               &setlist);
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@a90 3
static void break_at_finish_command PARAMS ((char *, int));
static void break_at_finish_at_depth_command PARAMS ((char *, int));

a93 2
static void tbreak_at_finish_command PARAMS ((char *, int));

a184 30
static void create_solib_load_unload_event_breakpoint PARAMS ((char *hookname, int  tempflag, char *dll_pathname, char *cond_string, enum bptype bp_kind));

static void create_fork_vfork_event_catchpoint PARAMS ((int  tempflag, char *  cond_string, enum bptype bp_kind));

static void break_at_finish_at_depth_command_1 PARAMS ((char *arg, int flag, int from_tty));

static void break_at_finish_command_1 PARAMS ((char *arg, int flag, int from_tty));

static void stop_command PARAMS ((char *arg, int from_tty));

static void stopin_command PARAMS ((char *arg, int from_tty));

static void stopat_command PARAMS ((char *arg, int from_tty));

static char *ep_find_event_name_end PARAMS ((char *arg));

static char *ep_parse_optional_if_clause PARAMS ((char **arg));

static char *ep_parse_optional_filename PARAMS ((char **arg));

static void catch_exec_command_1 PARAMS ((char *arg, int tempflag, int from_tty));

static void create_exception_catchpoint PARAMS ((int tempflag, char *cond_string, enum exception_event_kind ex_event, struct symtab_and_line *sal));

static void catch_exception_command_1 PARAMS ((enum exception_event_kind ex_event, char *arg, int tempflag, int from_tty));

static void tcatch_command PARAMS ((char *arg, int from_tty));

static void ep_skip_leading_whitespace PARAMS ((char **s));

d1330 4
a1335 6
  if (! CALL_DUMMY_P)
    return 0;

  if (USE_GENERIC_DUMMY_FRAMES)
    return generic_pc_in_call_dummy (frame->pc, frame->frame, frame->frame);
  
d1338 2
d1342 1
d1347 1
a1347 1
		  - SIZEOF_CALL_DUMMY_WORDS / sizeof (LONGEST) * REGISTER_SIZE))
d1351 2
d2935 2
d2938 1
a2938 1
static void
d2951 2
d3244 5
a3248 5
     char *hookname;
     int tempflag;
     char *dll_pathname;
     char *cond_string;
     enum bptype bp_kind;
d3354 3
a3356 3
     int tempflag;
     char *cond_string;
     enum bptype bp_kind;
d4095 1
a4095 1
static void
d4103 1
a4103 1
static void
d4119 1
a4119 1
static void
a4533 1
#if 0
a4596 1
#endif
d4714 1
a4714 1
     char **s;
d4728 1
a4728 1
     char *arg;
d4761 1
a4761 1
     char **arg;
d4794 1
a4794 1
     char **arg;
a4823 2
static void catch_fork_command_1 PARAMS ((catch_fork_kind fork_kind, char *arg, int tempflag, int from_tty));

d4826 4
a4829 4
     catch_fork_kind fork_kind;
     char *arg;
     int tempflag;
     int from_tty;
d4862 3
a4864 3
     char *arg;
     int tempflag;
     int from_tty;
d4982 4
a4985 4
     int tempflag;
     char *cond_string;
     enum exception_event_kind ex_event;
     struct symtab_and_line *sal;
d5023 4
a5026 4
     enum exception_event_kind ex_event;
     char *arg;
     int tempflag;
     int from_tty;
d6590 2
d6610 2
@


1.1.1.3
log
@import gdb-1999-0519
@
text
@d2931 1
a2931 1
		print_command_line (l, 4, gdb_stdout);
@


1.1.1.4
log
@import gdb-1999-05-25 snapshot
@
text
@a2715 1

@


1.1.1.5
log
@import gdb-1999-06-01 snapshot
@
text
@a879 3
	    default:
	      warning ("GDB bug: breakpoint.c (insert_breakpoints): enclosing `if' does not protect `switch'");
	      break;
a1193 3
	default:
	  warning ("GDB bug: breakpoint.c (remove_breakpoint): enclosing `if' does not protect `switch'");
	  break;
@


1.1.1.6
log
@import gdb-1999-07-05 snapshot
@
text
@d2421 1
a2421 27
     codes in case we want to change that someday. 

     Another possibly interesting property of this table is that
     there's a partial ordering, priority-like, of the actions.  Once
     you've decided that some action is appropriate, you'll never go
     back and decide something of a lower priority is better.  The
     ordering is:

	kc   < clr sgl shl slr sn sr ss ts
	sgl  < clrs shl shlr slr sn sr ss ts
	slr  < err shl shlr sn sr ss ts
	clr  < clrs err shl shlr sn sr ss ts
	clrs < err shl shlr sn sr ss ts
	ss   < shl shlr sn sr ts
	sn   < shl shlr sr ts
	sr   < shl shlr ts
	shl  < shlr
	ts   < 
	shlr <
       
     What I think this means is that we don't need a damned table
     here.  If you just put the rows and columns in the right order,
     it'd look awfully regular.  We could simply walk the bpstat list
     and choose the highest priority action we find, with a little
     logic to handle the 'err' cases, and the CLEAR_LONGJMP_RESUME/
     CLEAR_LONGJMP_RESUME_SINGLE distinction (which breakpoint.h says
     is messy anyway).  */
d4483 1
a4483 1
/* Helper routines for the until_command routine in infcmd.c.  Here
a4485 14
/* This function is called by fetch_inferior_event via the
   cmd_continuation pointer, to complete the until command. It takes
   care of cleaning up the temporary breakpoints set up by the until
   command. */
void
until_break_command_continuation (arg)
     struct continuation_arg *arg;
{
  /* Do all the exec cleanups, which at this point should only be the
     one set up in the first part of the until_break_command
     function. */
  do_exec_cleanups (ALL_CLEANUPS);
}

a4496 1
  struct continuation_arg *arg1, *arg2;
d4522 1
a4522 20
  if (!async_p || !target_has_async)
    old_chain = make_cleanup ((make_cleanup_func) delete_breakpoint, breakpoint);
  else
    make_exec_cleanup ((make_cleanup_func) delete_breakpoint, breakpoint);

  /* If we are running asynchronously, and the target supports async
     execution, we are not waiting for the target to stop, in the call
     tp proceed, below. This means that we cannot delete the
     brekpoints until the target has actually stopped. The only place
     where we get a chance to do that is in fetch_inferior_event, so
     we must set things up for that. */

  if (async_p && target_has_async)
    {
      /* In this case we don't need args for the continuation, because
	 all it needs to do is do the cleanups in the
	 exec_cleanup_chain, which will be only those inserted by this
	 function. We can get away by using ALL_CLEANUPS. */
      add_continuation (until_break_command_continuation, NULL);
    }
d4531 1
a4531 4
      if (!async_p || !target_has_async)
	make_cleanup ((make_cleanup_func) delete_breakpoint, breakpoint);
      else
	make_exec_cleanup ((make_cleanup_func) delete_breakpoint, breakpoint);
d4535 1
a4535 4
  /* Do the cleanups now, anly if we are not running asynchronously,
     of if we are, but the target is still synchronous. */
  if (!async_p || !target_has_async)
    do_cleanups(old_chain);
@


1.1.1.7
log
@import gdb-1999-07-07 post reformat
@
text
@d3 1
a3 1
   Free Software Foundation, Inc.
d5 1
a5 1
   This file is part of GDB.
d7 13
a19 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d66 1
a66 1
map_breakpoint_numbers PARAMS ((char *, void (*)(struct breakpoint *)));
d106 1
a106 1
  set_raw_breakpoint PARAMS ((struct symtab_and_line));
d121 1
a121 1
  bpstat_alloc PARAMS ((struct breakpoint *, bpstat));
d142 1
a142 1
  create_temp_exception_breakpoint PARAMS ((CORE_ADDR));
d145 4
a148 6
typedef enum
  {
    mark_inserted,
    mark_uninserted
  }
insertion_state_t;
d155 4
a158 6
typedef struct
  {
    enum exception_event_kind kind;
    int enable;
  }
args_for_catchpoint_enable;
d190 1
a190 1
static void create_solib_load_unload_event_breakpoint PARAMS ((char *hookname, int tempflag, char *dll_pathname, char *cond_string, enum bptype bp_kind));
d192 1
a192 1
static void create_fork_vfork_event_catchpoint PARAMS ((int tempflag, char *cond_string, enum bptype bp_kind));
d212 1
a212 1
static void create_exception_catchpoint PARAMS ((int tempflag, char *cond_string, enum exception_event_kind ex_event, struct symtab_and_line * sal));
d238 1
a238 1
extern int addressprint;	/* Print machine addresses? */
d266 1
a266 1
 ;
d280 2
a281 2
/* Pointer to current exception event record */
static struct exception_event_record *current_exception_event;
d286 1
a286 1

d397 1
a397 1
         to pass to lookup_internalvar().  */
d410 2
a411 2
		"Convenience variables used to specify breakpoints must have integer values."
	  );
d452 8
a459 8
    {
      if (b->cond)
	{
	  free ((PTR) b->cond);
	  b->cond = 0;
	}
      if (b->cond_string != NULL)
	free ((PTR) b->cond_string);
d461 20
a480 20
      if (*p == 0)
	{
	  b->cond = 0;
	  b->cond_string = NULL;
	  if (from_tty)
	    printf_filtered ("Breakpoint %d now unconditional.\n", bnum);
	}
      else
	{
	  arg = p;
	  /* I don't know if it matters whether this is the string the user
	     typed in or the decompiled expression.  */
	  b->cond_string = savestring (arg, strlen (arg));
	  b->cond = parse_exp_1 (&arg, block_for_pc (b->address), 0);
	  if (*arg)
	    error ("Junk at end of expression");
	}
      breakpoints_changed ();
      return;
    }
d507 1
a507 1

d510 9
a518 9
    {
      char tmpbuf[128];
      sprintf (tmpbuf, "Type commands for when breakpoint %d is hit, one per line.", bnum);
      l = read_command_lines (tmpbuf, from_tty);
      free_command_lines (&b->commands);
      b->commands = l;
      breakpoints_changed ();
      return;
    }
d544 1
a544 1

d546 3
a548 3
  {
    if (b->type == bp_none)
      warning ("attempted to read through apparently deleted breakpoint #%d?\n", b->number);
d550 73
a622 72
    /* memory breakpoint? */
    if (b->type == bp_watchpoint
	|| b->type == bp_hardware_watchpoint
	|| b->type == bp_read_watchpoint
	|| b->type == bp_access_watchpoint)
      continue;
    /* bp in memory? */
    if (!b->inserted)
      continue;
    /* Addresses and length of the part of the breakpoint that
       we need to copy.  */
    /* XXXX The m68k, sh and h8300 have different local and remote
       breakpoint values.  BREAKPOINT_FROM_PC still manages to
       correctly determine the breakpoints memory address and size
       for these targets. */
    bp_addr = b->address;
    bp_size = 0;
    if (BREAKPOINT_FROM_PC (&bp_addr, &bp_size) == NULL)
      continue;
    if (bp_size == 0)
      /* bp isn't valid */
      continue;
    if (bp_addr + bp_size <= memaddr)
      /* The breakpoint is entirely before the chunk of memory we
         are reading.  */
      continue;
    if (bp_addr >= memaddr + len)
      /* The breakpoint is entirely after the chunk of memory we are
         reading. */
      continue;
    /* Copy the breakpoint from the shadow contents, and recurse for
       the things before and after.  */
    {
      /* Offset within shadow_contents.  */
      int bptoffset = 0;

      if (bp_addr < memaddr)
	{
	  /* Only copy the second part of the breakpoint.  */
	  bp_size -= memaddr - bp_addr;
	  bptoffset = memaddr - bp_addr;
	  bp_addr = memaddr;
	}

      if (bp_addr + bp_size > memaddr + len)
	{
	  /* Only copy the first part of the breakpoint.  */
	  bp_size -= (bp_addr + bp_size) - (memaddr + len);
	}

      memcpy (myaddr + bp_addr - memaddr,
	      b->shadow_contents + bptoffset, bp_size);

      if (bp_addr > memaddr)
	{
	  /* Copy the section of memory before the breakpoint.  */
	  status = read_memory_nobpt (memaddr, myaddr, bp_addr - memaddr);
	  if (status != 0)
	    return status;
	}

      if (bp_addr + bp_size < memaddr + len)
	{
	  /* Copy the section of memory after the breakpoint.  */
	  status = read_memory_nobpt
	    (bp_addr + bp_size,
	     myaddr + bp_addr + bp_size - memaddr,
	     memaddr + len - (bp_addr + bp_size));
	  if (status != 0)
	    return status;
	}
      return 0;
a623 1
  }
d627 1
a628 1

d646 28
a673 28
  {
    if (b->type != bp_watchpoint
	&& b->type != bp_hardware_watchpoint
	&& b->type != bp_read_watchpoint
	&& b->type != bp_access_watchpoint
	&& b->type != bp_catch_fork
	&& b->type != bp_catch_vfork
	&& b->type != bp_catch_exec
	&& b->type != bp_catch_throw
	&& b->type != bp_catch_catch
	&& b->enable != disabled
	&& b->enable != shlib_disabled
	&& b->enable != call_disabled
	&& !b->inserted
	&& !b->duplicate)
      {
	if (b->type == bp_hardware_breakpoint)
	  val = target_insert_hw_breakpoint (b->address, b->shadow_contents);
	else
	  {
	    /* Check to see if breakpoint is in an overlay section;
	       if so, we should set the breakpoint at the LMA address.
	       Only if the section is currently mapped should we ALSO
	       set a break at the VMA address. */
	    if (overlay_debugging && b->section &&
		section_is_overlay (b->section))
	      {
		CORE_ADDR addr;
d675 17
a691 17
		addr = overlay_unmapped_address (b->address, b->section);
		val = target_insert_breakpoint (addr, b->shadow_contents);
		/* This would be the time to check val, to see if the
		   breakpoint write to the load address succeeded.  
		   However, this might be an ordinary occurrance, eg. if 
		   the unmapped overlay is in ROM.  */
		val = 0;	/* in case unmapped address failed */
		if (section_is_mapped (b->section))
		  val = target_insert_breakpoint (b->address,
						  b->shadow_contents);
	      }
	    else		/* ordinary (non-overlay) address */
	      val = target_insert_breakpoint (b->address, b->shadow_contents);
	  }
	if (val)
	  {
	    /* Can't set the breakpoint.  */
d693 16
a708 16
	    if (DISABLE_UNSETTABLE_BREAK (b->address))
	      {
		/* See also: disable_breakpoints_in_shlibs. */
		val = 0;
		b->enable = shlib_disabled;
		if (!disabled_breaks)
		  {
		    target_terminal_ours_for_output ();
		    fprintf_unfiltered (gdb_stderr,
			       "Cannot insert breakpoint %d:\n", b->number);
		    printf_filtered ("Temporarily disabling shared library breakpoints:\n");
		  }
		disabled_breaks = 1;
		printf_filtered ("%d ", b->number);
	      }
	    else
d710 3
a712 3
	      {
		target_terminal_ours_for_output ();
		fprintf_unfiltered (gdb_stderr, "Cannot insert breakpoint %d:\n", b->number);
d714 2
a715 2
		fprintf_unfiltered (gdb_stderr,
		   "The same program may be running in another process.\n");
d717 6
a722 6
		memory_error (val, b->address);		/* which bombs us out */
	      }
	  }
	else
	  b->inserted = 1;
      }
d724 5
a728 5
	     && b->enable != disabled
	     && b->enable != shlib_disabled
	     && b->enable != call_disabled
	     && !b->inserted
	     && !b->duplicate)
d731 17
a747 17
	/* If we get here, we must have a callback mechanism for exception
	   events -- with g++ style embedded label support, we insert
	   ordinary breakpoints and not catchpoints. */
	sprintf (message, message1, b->number);		/* Format possible error message */

	val = target_insert_breakpoint (b->address, b->shadow_contents);
	if (val)
	  {
	    /* Couldn't set breakpoint for some reason */
	    target_terminal_ours_for_output ();
	    fprintf_unfiltered (gdb_stderr,
		  "Cannot insert catchpoint %d; disabling it\n", b->number);
	    b->enable = disabled;
	  }
	else
	  {
	    /* Bp set, now make sure callbacks are enabled */
d749 1
a749 1
	    args_for_catchpoint_enable args;
d759 1
a759 1
	    /* Check if something went wrong; val == 0 can be ignored */
d762 1
a762 1
		/* something went wrong */
d767 1
a767 1
	  }
d770 23
a792 23
    else if ((b->type == bp_hardware_watchpoint ||
	      b->type == bp_read_watchpoint ||
	      b->type == bp_access_watchpoint)
	     && b->enable == enabled
	     && !b->inserted
	     && !b->duplicate)
      {
	struct frame_info *saved_frame;
	int saved_level, within_current_scope;
	value_ptr mark = value_mark ();
	value_ptr v;

	/* Save the current frame and level so we can restore it after
	   evaluating the watchpoint expression on its own frame.  */
	saved_frame = selected_frame;
	saved_level = selected_frame_level;

	/* Determine if the watchpoint is within scope.  */
	if (b->exp_valid_block == NULL)
	  within_current_scope = 1;
	else
	  {
	    struct frame_info *fi;
d794 20
a813 10
	    /* There might be no current frame at this moment if we are
	       resuming from a step over a breakpoint.
	       Set up current frame before trying to find the watchpoint
	       frame.  */
	    get_current_frame ();
	    fi = find_frame_addr_in_frame_chain (b->watchpoint_frame);
	    within_current_scope = (fi != NULL);
	    if (within_current_scope)
	      select_frame (fi, -1);
	  }
d815 34
a848 44
	if (within_current_scope)
	  {
	    /* Evaluate the expression and cut the chain of values
	       produced off from the value chain.  */
	    v = evaluate_expression (b->exp);
	    value_release_to_mark (mark);

	    b->val_chain = v;
	    b->inserted = 1;

	    /* Look at each value on the value chain.  */
	    for (; v; v = v->next)
	      {
		/* If it's a memory location, then we must watch it.  */
		if (v->lval == lval_memory)
		  {
		    int addr, len, type;

		    addr = VALUE_ADDRESS (v) + VALUE_OFFSET (v);
		    len = TYPE_LENGTH (VALUE_TYPE (v));
		    type = 0;
		    if (b->type == bp_read_watchpoint)
		      type = 1;
		    else if (b->type == bp_access_watchpoint)
		      type = 2;

		    val = target_insert_watchpoint (addr, len, type);
		    if (val == -1)
		      {
			b->inserted = 0;
			break;
		      }
		    val = 0;
		  }
	      }
	    /* Failure to insert a watchpoint on any memory value in the
	       value chain brings us here.  */
	    if (!b->inserted)
	      warning ("Hardware watchpoint %d: Could not insert watchpoint\n",
		       b->number);
	  }
	else
	  {
	    printf_filtered ("\
d851 4
a854 4
	    if (b->related_breakpoint)
	      b->related_breakpoint->disposition = del_at_next_stop;
	    b->disposition = del_at_next_stop;
	  }
d856 37
a892 37
	/* Restore the frame and level.  */
	if ((saved_frame != selected_frame) ||
	    (saved_level != selected_frame_level))
	  select_and_print_frame (saved_frame, saved_level);
      }
    else if ((b->type == bp_catch_fork
	      || b->type == bp_catch_vfork
	      || b->type == bp_catch_exec)
	     && b->enable == enabled
	     && !b->inserted
	     && !b->duplicate)
      {
	val = -1;
	switch (b->type)
	  {
	  case bp_catch_fork:
	    val = target_insert_fork_catchpoint (inferior_pid);
	    break;
	  case bp_catch_vfork:
	    val = target_insert_vfork_catchpoint (inferior_pid);
	    break;
	  case bp_catch_exec:
	    val = target_insert_exec_catchpoint (inferior_pid);
	    break;
	  default:
	    warning ("GDB bug: breakpoint.c (insert_breakpoints): enclosing `if' does not protect `switch'");
	    break;
	  }
	if (val < 0)
	  {
	    target_terminal_ours_for_output ();
	    fprintf_unfiltered (gdb_stderr, "Cannot insert catchpoint %d:\n", b->number);
	  }
	else
	  b->inserted = 1;
      }
  }
d907 8
a914 8
  {
    if (b->inserted)
      {
	val = remove_breakpoint (b, mark_uninserted);
	if (val != 0)
	  return val;
      }
  }
d920 1
a920 1
     int pid;
d924 1
a924 1
  int saved_inferior_pid = inferior_pid;
d926 1
a926 1
  inferior_pid = pid;		/* Because remove_breakpoint will use this global. */
d928 15
a942 15
  {
    if (b->inserted)
      {
	remove_breakpoint (b, mark_inserted);
	if (b->type == bp_hardware_breakpoint)
	  val = target_insert_hw_breakpoint (b->address, b->shadow_contents);
	else
	  val = target_insert_breakpoint (b->address, b->shadow_contents);
	if (val != 0)
	  {
	    inferior_pid = saved_inferior_pid;
	    return val;
	  }
      }
  }
d950 2
a951 2
  struct breakpoint *b;
  struct breakpoint *temp;
d959 92
a1050 92
  {
    /* Solib breakpoints must be explicitly reset after an exec(). */
    if (b->type == bp_shlib_event)
      {
	delete_breakpoint (b);
	continue;
      }

    /* Step-resume breakpoints are meaningless after an exec(). */
    if (b->type == bp_step_resume)
      {
	delete_breakpoint (b);
	continue;
      }

    /* Ditto the sigtramp handler breakpoints. */
    if (b->type == bp_through_sigtramp)
      {
	delete_breakpoint (b);
	continue;
      }

    /* Ditto the exception-handling catchpoints. */
    if ((b->type == bp_catch_catch) || (b->type == bp_catch_throw))
      {
	delete_breakpoint (b);
	continue;
      }

    /* Don't delete an exec catchpoint, because else the inferior
       won't stop when it ought!

       Similarly, we probably ought to keep vfork catchpoints, 'cause
       on this target, we may not be able to stop when the vfork is seen,
       but only when the subsequent exec is seen.  (And because deleting
       fork catchpoints here but not vfork catchpoints will seem mysterious
       to users, keep those too.)

       ??rehrauer: Let's hope that merely clearing out this catchpoint's
       target address field, if any, is sufficient to have it be reset
       automagically.  Certainly on HP-UX that's true. */
    if ((b->type == bp_catch_exec) ||
	(b->type == bp_catch_vfork) ||
	(b->type == bp_catch_fork))
      {
	b->address = (CORE_ADDR) NULL;
	continue;
      }

    /* bp_finish is a special case.  The only way we ought to be able
       to see one of these when an exec() has happened, is if the user
       caught a vfork, and then said "finish".  Ordinarily a finish just
       carries them to the call-site of the current callee, by setting
       a temporary bp there and resuming.  But in this case, the finish
       will carry them entirely through the vfork & exec.

       We don't want to allow a bp_finish to remain inserted now.  But
       we can't safely delete it, 'cause finish_command has a handle to
       the bp on a bpstat, and will later want to delete it.  There's a
       chance (and I've seen it happen) that if we delete the bp_finish
       here, that its storage will get reused by the time finish_command
       gets 'round to deleting the "use to be a bp_finish" breakpoint.
       We really must allow finish_command to delete a bp_finish.

       In the absense of a general solution for the "how do we know it's
       safe to delete something others may have handles to?" problem, what
       we'll do here is just uninsert the bp_finish, and let finish_command
       delete it.

       (We know the bp_finish is "doomed" in the sense that it's momentary,
       and will be deleted as soon as finish_command sees the inferior stopped.
       So it doesn't matter that the bp's address is probably bogus in the
       new a.out, unlike e.g., the solib breakpoints.)  */
    if (b->type == bp_finish)
      {
	continue;
      }

    /* Without a symbolic address, we have little hope of the
       pre-exec() address meaning the same thing in the post-exec()
       a.out. */
    if (b->addr_string == NULL)
      {
	delete_breakpoint (b);
	continue;
      }

    /* If this breakpoint has survived the above battery of checks, then
       it must have a symbolic address.  Be sure that it gets reevaluated
       to a target address, rather than reusing the old evaluation.  */
    b->address = (CORE_ADDR) NULL;
  }
d1055 1
a1055 1
     int pid;
d1059 2
a1060 2
  int saved_inferior_pid = inferior_pid;

d1063 2
a1064 2

  inferior_pid = pid;		/* Because remove_breakpoint will use this global. */
d1066 11
a1076 11
  {
    if (b->inserted)
      {
	val = remove_breakpoint (b, mark_inserted);
	if (val != 0)
	  {
	    inferior_pid = saved_inferior_pid;
	    return val;
	  }
      }
  }
d1084 1
a1084 1
     insertion_state_t is;
d1087 1
a1087 1

d1100 1
a1100 1

d1103 1
a1103 1
	val = target_remove_hw_breakpoint (b->address, b->shadow_contents);
d1110 1
a1110 1
	  if (overlay_debugging && b->section &&
d1118 4
a1121 4
	         shadow breakpoint write to the load address succeeded.  
	         However, this might be an ordinary occurrance, eg. if 
	         the unmapped overlay is in ROM.  */
	      val = 0;		/* in case unmapped address failed */
d1123 1
a1123 1
		val = target_remove_breakpoint (b->address,
d1126 2
a1127 2
	  else			/* ordinary (non-overlay) address */
	    val = target_remove_breakpoint (b->address, b->shadow_contents);
d1134 2
a1135 2
	    b->type == bp_read_watchpoint ||
	    b->type == bp_access_watchpoint)
d1137 1
a1137 1
	   && !b->duplicate)
d1140 1
a1140 1

d1150 1
a1150 1

d1169 1
a1169 1

d1171 1
a1171 1
         the next time the watchpoint is inserted.  */
d1180 2
a1181 2
	    b->type == bp_catch_vfork ||
	    b->type == bp_catch_exec)
d1183 1
a1183 1
	   && !b->duplicate)
d1187 10
a1196 10
	{
	case bp_catch_fork:
	  val = target_remove_fork_catchpoint (inferior_pid);
	  break;
	case bp_catch_vfork:
	  val = target_remove_vfork_catchpoint (inferior_pid);
	  break;
	case bp_catch_exec:
	  val = target_remove_exec_catchpoint (inferior_pid);
	  break;
d1200 1
a1200 1
	}
d1206 3
a1208 3
	    b->type == bp_catch_throw)
	   && b->enable == enabled
	   && !b->duplicate)
d1211 1
a1211 1
      val = target_remove_breakpoint (b->address, b->shadow_contents);
d1213 1
a1213 1
	return val;
d1217 3
a1219 3
	   && b->inserted	/* sometimes previous insert doesn't happen */
	   && b->enable == enabled
	   && !b->duplicate)
d1222 1
a1222 1
      val = target_remove_breakpoint (b->address, b->shadow_contents);
d1224 2
a1225 2
	return val;

d1250 1
a1250 1
   and when a run begins (by init_wait_for_inferior). */
d1256 1
a1256 1
     enum inf_context context;
d1262 2
a1263 2
  {
    b->inserted = 0;
d1265 4
a1268 4
    switch (b->type)
      {
      case bp_call_dummy:
      case bp_watchpoint_scope:
d1270 3
a1272 3
	/* If the call dummy breakpoint is at the entry point it will
	   cause problems when the inferior is rerun, so we better
	   get rid of it. 
d1274 3
a1276 3
	   Also get rid of scope breakpoints.  */
	delete_breakpoint (b);
	break;
d1278 4
a1281 4
      case bp_watchpoint:
      case bp_hardware_watchpoint:
      case bp_read_watchpoint:
      case bp_access_watchpoint:
d1283 2
a1284 11
	/* Likewise for watchpoints on local expressions.  */
	if (b->exp_valid_block != NULL)
	  delete_breakpoint (b);
	break;
      default:
	/* Likewise for exception catchpoints in dynamic-linked
	   executables where required */
	if (ep_is_exception_catchpoint (b) &&
	    exception_catchpoints_are_fragile)
	  {
	    warning_needed = 1;
d1286 13
a1298 4
	  }
	break;
      }
  }
d1303 1
a1303 1
  /* Don't issue the warning unless it's really needed... */
d1308 1
a1308 1
    }
d1326 8
a1333 8
    {
      if (overlay_debugging &&
	  section_is_overlay (b->section) &&
	  !section_is_mapped (b->section))
	continue;		/* unmapped overlay -- can't be a match */
      else
	return 1;
    }
d1350 8
a1357 8
    {
      if (overlay_debugging &&
	  section_is_overlay (b->section) &&
	  !section_is_mapped (b->section))
	continue;		/* unmapped overlay -- can't be a match */
      else
	return 1;
    }
d1373 1
a1373 1
  if (!CALL_DUMMY_P)
d1378 1
a1378 1

d1380 11
a1390 11
  {
    if (b->type == bp_call_dummy
	&& b->frame == frame->frame
    /* We need to check the PC as well as the frame on the sparc,
       for signals.exp in the testsuite.  */
	&& (frame->pc
	    >= (b->address
	      - SIZEOF_CALL_DUMMY_WORDS / sizeof (LONGEST) * REGISTER_SIZE))
	&& frame->pc <= b->address)
      return 1;
  }
d1413 8
a1420 8
    {
      if (overlay_debugging &&
	  section_is_overlay (b->section) &&
	  !section_is_mapped (b->section))
	continue;		/* unmapped overlay -- can't be a match */
      else
	return 1;
    }
d1424 1
a1425 1

d1431 1
a1431 1
     struct breakpoint *ep;
d1443 1
a1443 1
  /* ??rehrauer: Add more kinds here, as are implemented... */
d1446 1
a1446 1

d1449 1
a1449 1
     struct breakpoint *ep;
d1459 1
a1459 1
     struct breakpoint *ep;
d1485 1
a1485 1
      free ((PTR) p);
d1523 1
a1523 1
bpstat_find_breakpoint (bsp, breakpoint)
d1527 1
a1527 2
  if (bsp == NULL)
    return NULL;
d1529 3
a1531 5
  for (; bsp != NULL; bsp = bsp->next)
    {
      if (bsp->breakpoint_at == breakpoint)
	return bsp;
    }
d1545 1
a1545 1
     bpstat bsp;
d1553 2
a1554 2
	  (bsp->breakpoint_at->type == bp_step_resume))
	return bsp->breakpoint_at;
d1582 1
a1582 1
	return b->number;	/* We have its number */
d1681 1
a1681 1

d1685 1
a1685 1
   something to be followed by a location.
d1687 1
a1687 1
   something to be followed by a location.
d1698 7
a1704 7
	  && bs->breakpoint_at->type != bp_catch_load
	  && bs->breakpoint_at->type != bp_catch_unload
	  && bs->breakpoint_at->type != bp_catch_fork
	  && bs->breakpoint_at->type != bp_catch_vfork
	  && bs->breakpoint_at->type != bp_catch_exec
	  && bs->breakpoint_at->type != bp_catch_catch
	  && bs->breakpoint_at->type != bp_catch_throw
d1717 1
a1717 1
	printf_filtered ("loaded");
d1719 1
a1719 1
	printf_filtered ("unloaded");
d1724 1
a1724 1
	   bs->breakpoint_at->type == bp_catch_vfork)
d1729 1
a1729 1
	printf_filtered ("forked");
d1731 1
a1731 1
	printf_filtered ("vforked");
d1739 2
a1740 2
		       bs->breakpoint_at->number,
		       bs->breakpoint_at->exec_pathname);
d1743 1
a1743 1
  else if (bs->breakpoint_at->type == bp_catch_catch)
d1746 22
a1767 22
	{
	  annotate_catchpoint (bs->breakpoint_at->number);
	  printf_filtered ("\nCatchpoint %d (exception caught), ", bs->breakpoint_at->number);
	  printf_filtered ("throw location ");
	  if (CURRENT_EXCEPTION_THROW_PC && CURRENT_EXCEPTION_THROW_LINE)
	    printf_filtered ("%s:%d",
			     CURRENT_EXCEPTION_THROW_FILE,
			     CURRENT_EXCEPTION_THROW_LINE);
	  else
	    printf_filtered ("unknown");

	  printf_filtered (", catch location ");
	  if (CURRENT_EXCEPTION_CATCH_PC && CURRENT_EXCEPTION_CATCH_LINE)
	    printf_filtered ("%s:%d",
			     CURRENT_EXCEPTION_CATCH_FILE,
			     CURRENT_EXCEPTION_CATCH_LINE);
	  else
	    printf_filtered ("unknown");

	  printf_filtered ("\n");
	  return 1;		/* don't bother to print location frame info */
	}
d1769 3
a1771 3
	{
	  return -1;		/* really throw, some other bpstat will handle it */
	}
d1776 22
a1797 22
	{
	  annotate_catchpoint (bs->breakpoint_at->number);
	  printf_filtered ("\nCatchpoint %d (exception thrown), ", bs->breakpoint_at->number);
	  printf_filtered ("throw location ");
	  if (CURRENT_EXCEPTION_THROW_PC && CURRENT_EXCEPTION_THROW_LINE)
	    printf_filtered ("%s:%d",
			     CURRENT_EXCEPTION_THROW_FILE,
			     CURRENT_EXCEPTION_THROW_LINE);
	  else
	    printf_filtered ("unknown");

	  printf_filtered (", catch location ");
	  if (CURRENT_EXCEPTION_CATCH_PC && CURRENT_EXCEPTION_CATCH_LINE)
	    printf_filtered ("%s:%d",
			     CURRENT_EXCEPTION_CATCH_FILE,
			     CURRENT_EXCEPTION_CATCH_LINE);
	  else
	    printf_filtered ("unknown");

	  printf_filtered ("\n");
	  return 1;		/* don't bother to print location frame info */
	}
d1799 3
a1801 3
	{
	  return -1;		/* really catch, some other bpstat willhandle it */
	}
d1805 1
a1805 1
	   bs->breakpoint_at->type == bp_hardware_breakpoint)
d1808 1
a1808 1
         number, not all of them.  */
d1814 3
a1816 3
	   (bs->breakpoint_at->type == bp_watchpoint ||
	    bs->breakpoint_at->type == bp_access_watchpoint ||
	    bs->breakpoint_at->type == bp_hardware_watchpoint))
d1837 1
a1837 1
		   Val_pretty_default);
d1856 3
a1858 3
   code to print the location. An example is 
   "Breakpoint 1, " which should be followed by
   the location.
d1860 3
a1862 3
   to also print the location part of the message.
   An example is the catch/throw messages, which
   don't require a location appended to the end.  */
d1869 1
a1869 1

d1876 1
a1876 1

d1898 1
a1898 1
  int i = !value_true (evaluate_expression ((struct expression *) exp));
d1908 1
a1908 1
     bpstat cbs;		/* Current "bs" value */
d1952 3
a1954 3
         any chance of handling watchpoints on local variables, we'll need
         the frame chain (so we can determine if we're in scope).  */
      reinit_frame_cache ();
d1963 1
a1963 1

d1968 2
a1969 2
         call free_all_values.  We can't call free_all_values because
         we might be in the middle of evaluating a function call.  */
d1993 7
a1999 7
         if we temporarily ignored the watchpoint, then when
         we reenter the block in which it is valid it contains
         garbage (in the case of a function, it may have two
         garbage values, one before and one after the prologue).
         So we can't even detect the first assignment to it and
         watch after that (since the garbage may or may not equal
         the first value assigned).  */
d2054 1
a2054 1
   if we don't understand the stop, the result is a null pointer.
d2056 1
a2056 1
   if we understand why we stopped, the result is not null.
d2058 3
a2060 3
   Each element of the chain refers to a particular breakpoint or
   watchpoint at which we have stopped.  (We may have stopped for
   several reasons concurrently.)
d2062 2
a2063 2
   Each element of the chain has valid next, breakpoint_at,
   commands, FIXME??? fields.  */
d2079 2
a2080 2
  "Error evaluating expression for watchpoint %d\n";
  char message[sizeof (message1) + 30 /* slop */ ];
d2086 31
a2116 20
  {
    if (b->enable == disabled
	|| b->enable == shlib_disabled
	|| b->enable == call_disabled)
      continue;

    if (b->type != bp_watchpoint
	&& b->type != bp_hardware_watchpoint
	&& b->type != bp_read_watchpoint
	&& b->type != bp_access_watchpoint
	&& b->type != bp_hardware_breakpoint
	&& b->type != bp_catch_fork
	&& b->type != bp_catch_vfork
	&& b->type != bp_catch_exec
	&& b->type != bp_catch_catch
	&& b->type != bp_catch_throw)	/* a non-watchpoint bp */
      if (b->address != bp_addr ||	/* address doesn't match or */
	  (overlay_debugging &&	/* overlay doesn't match */
	   section_is_overlay (b->section) &&
	   !section_is_mapped (b->section)))
d2119 4
a2122 15
    if (b->type == bp_hardware_breakpoint
	&& b->address != (*pc - DECR_PC_AFTER_HW_BREAK))
      continue;

    if (b->type != bp_watchpoint
	&& b->type != bp_hardware_watchpoint
	&& b->type != bp_read_watchpoint
	&& b->type != bp_access_watchpoint
	&& not_a_breakpoint)
      continue;

    /* Is this a catchpoint of a load or unload?  If so, did we
       get a load or unload of the specified library?  If not,
       ignore it. */
    if ((b->type == bp_catch_load)
d2124 3
a2126 3
	&& (!SOLIB_HAVE_LOAD_EVENT (inferior_pid)
	    || ((b->dll_pathname != NULL)
		&& (strcmp (b->dll_pathname, SOLIB_LOADED_LIBRARY_PATHNAME (inferior_pid)) != 0)))
d2128 4
a2131 4
      )
      continue;

    if ((b->type == bp_catch_unload)
d2133 3
a2135 3
	&& (!SOLIB_HAVE_UNLOAD_EVENT (inferior_pid)
	    || ((b->dll_pathname != NULL)
		&& (strcmp (b->dll_pathname, SOLIB_UNLOADED_LIBRARY_PATHNAME (inferior_pid)) != 0)))
d2137 14
a2150 2
      )
      continue;
d2152 3
a2154 3
    if ((b->type == bp_catch_fork)
	&& !target_has_forked (inferior_pid, &b->forked_inferior_pid))
      continue;
d2156 1
a2156 3
    if ((b->type == bp_catch_vfork)
	&& !target_has_vforked (inferior_pid, &b->forked_inferior_pid))
      continue;
d2158 1
a2158 3
    if ((b->type == bp_catch_exec)
	&& !target_has_execd (inferior_pid, &b->exec_pathname))
      continue;
d2160 3
a2162 3
    if (ep_is_exception_catchpoint (b) &&
	!(current_exception_event = target_get_current_exception_event ()))
      continue;
d2164 3
a2166 66
    /* Come here if it's a watchpoint, or if the break address matches */

    bs = bpstat_alloc (b, bs);	/* Alloc a bpstat to explain stop */

    /* Watchpoints may change this, if not found to have triggered. */
    bs->stop = 1;
    bs->print = 1;

    sprintf (message, message1, b->number);
    if (b->type == bp_watchpoint || b->type == bp_hardware_watchpoint)
      {
	switch (catch_errors (watchpoint_check, bs, message, RETURN_MASK_ALL))
	  {
	  case WP_DELETED:
	    /* We've already printed what needs to be printed.  */
	    bs->print_it = print_it_done;
	    /* Stop.  */
	    break;
	  case WP_VALUE_CHANGED:
	    /* Stop.  */
	    ++(b->hit_count);
	    break;
	  case WP_VALUE_NOT_CHANGED:
	    /* Don't stop.  */
	    bs->print_it = print_it_noop;
	    bs->stop = 0;
	    /* Don't consider this a hit.  */
	    --(b->hit_count);
	    continue;
	  default:
	    /* Can't happen.  */
	    /* FALLTHROUGH */
	  case 0:
	    /* Error from catch_errors.  */
	    printf_filtered ("Watchpoint %d deleted.\n", b->number);
	    if (b->related_breakpoint)
	      b->related_breakpoint->disposition = del_at_next_stop;
	    b->disposition = del_at_next_stop;
	    /* We've already printed what needs to be printed.  */
	    bs->print_it = print_it_done;

	    /* Stop.  */
	    break;
	  }
      }
    else if (b->type == bp_read_watchpoint || b->type == bp_access_watchpoint)
      {
	CORE_ADDR addr;
	value_ptr v;
	int found = 0;

	addr = target_stopped_data_address ();
	if (addr == 0)
	  continue;
	for (v = b->val_chain; v; v = v->next)
	  {
	    if (v->lval == lval_memory)
	      {
		CORE_ADDR vaddr;

		vaddr = VALUE_ADDRESS (v) + VALUE_OFFSET (v);
		if (addr == vaddr)
		  found = 1;
	      }
	  }
	if (found)
a2174 1
	    case WP_VALUE_NOT_CHANGED:
d2178 7
d2187 1
d2196 2
d2200 62
a2261 6
      }
    else
      {
	/* By definition, an encountered breakpoint is a triggered
	   breakpoint. */
	++(b->hit_count);
d2263 30
a2292 47
	real_breakpoint = 1;
      }

    if (b->frame && b->frame != (get_current_frame ())->frame &&
	(b->type == bp_step_resume &&
	 (INNER_THAN (get_current_frame ()->frame, b->frame))))
      bs->stop = 0;
    else
      {
	int value_is_zero = 0;

	if (b->cond)
	  {
	    /* Need to select the frame, with all that implies
	       so that the conditions will have the right context.  */
	    select_frame (get_current_frame (), 0);
	    value_is_zero
	      = catch_errors (breakpoint_cond_eval, (b->cond),
			      "Error in testing breakpoint condition:\n",
			      RETURN_MASK_ALL);
	    /* FIXME-someday, should give breakpoint # */
	    free_all_values ();
	  }
	if (b->cond && value_is_zero)
	  {
	    bs->stop = 0;
	    /* Don't consider this a hit.  */
	    --(b->hit_count);
	  }
	else if (b->ignore_count > 0)
	  {
	    b->ignore_count--;
	    bs->stop = 0;
	  }
	else
	  {
	    /* We will stop here */
	    if (b->disposition == disable)
	      b->enable = disabled;
	    bs->commands = b->commands;
	    if (b->silent)
	      bs->print = 0;
	    if (bs->commands &&
		(STREQ ("silent", bs->commands->line) ||
		 (xdb_commands && STREQ ("Q", bs->commands->line))))
	      {
		bs->commands = bs->commands->next;
d2294 13
a2306 7
	      }
	  }
      }
    /* Print nothing for this entry if we dont stop or if we dont print.  */
    if (bs->stop == 0 || bs->print == 0)
      bs->print_it = print_it_noop;
  }
d2313 1
a2313 1
      if (bs->breakpoint_at->type == bp_hardware_breakpoint)
d2315 1
a2315 1
	  if (DECR_PC_AFTER_HW_BREAK != 0)
d2327 1
a2327 1
	      SHIFT_INST_REGS ();
d2337 1
a2337 1
  if (bs && !bs->stop &&
d2354 3
a2356 7
  enum class
    {
      /* This bpstat element has no effect on the main_action.  */
      no_effect = 0,

      /* There was a watchpoint, stop but don't print.  */
      wp_silent,
d2358 2
a2359 2
      /* There was a watchpoint, stop and print.  */
      wp_noisy,
d2361 2
a2362 2
      /* There was a breakpoint but we're not stopping.  */
      bp_nostop,
d2364 2
a2365 2
      /* There was a breakpoint, stop but don't print.  */
      bp_silent,
d2367 2
a2368 2
      /* There was a breakpoint, stop and print.  */
      bp_noisy,
d2370 2
a2371 2
      /* We hit the longjmp breakpoint.  */
      long_jump,
d2373 2
a2374 2
      /* We hit the longjmp_resume breakpoint.  */
      long_resume,
d2376 2
a2377 2
      /* We hit the step_resume breakpoint.  */
      step_resume,
d2379 2
a2380 2
      /* We hit the through_sigtramp breakpoint.  */
      through_sig,
d2382 2
a2383 2
      /* We hit the shared library event breakpoint.  */
      shlib_event,
d2385 2
a2386 2
      /* We caught a shared library event.  */
      catch_shlib_event,
d2388 5
a2392 2
      /* This is just used to count how many enums there are.  */
      class_last
d2429 12
a2440 12
     kc   < clr sgl shl slr sn sr ss ts
     sgl  < clrs shl shlr slr sn sr ss ts
     slr  < err shl shlr sn sr ss ts
     clr  < clrs err shl shlr sn sr ss ts
     clrs < err shl shlr sn sr ss ts
     ss   < shl shlr sn sr ts
     sn   < shl shlr sr ts
     sr   < shl shlr ts
     shl  < shlr
     ts   < 
     shlr <

d2456 18
a2473 30
    table[(int) class_last][(int) BPSTAT_WHAT_LAST] =
  {
  /*                              old action */
  /*       kc    ss    sn    sgl    slr   clr    clrs   sr    ts   shl   shlr
   */
/*no_effect */
    {kc, ss, sn, sgl, slr, clr, clrs, sr, ts, shl, shlr},
/*wp_silent */
    {ss, ss, sn, ss, ss, ss, ss, sr, ts, shl, shlr},
/*wp_noisy */
    {sn, sn, sn, sn, sn, sn, sn, sr, ts, shl, shlr},
/*bp_nostop */
    {sgl, ss, sn, sgl, slr, clrs, clrs, sr, ts, shl, shlr},
/*bp_silent */
    {ss, ss, sn, ss, ss, ss, ss, sr, ts, shl, shlr},
/*bp_noisy */
    {sn, sn, sn, sn, sn, sn, sn, sr, ts, shl, shlr},
/*long_jump */
    {slr, ss, sn, slr, err, err, err, sr, ts, shl, shlr},
/*long_resume */
    {clr, ss, sn, clrs, err, err, err, sr, ts, shl, shlr},
/*step_resume */
    {sr, sr, sr, sr, sr, sr, sr, sr, ts, shl, shlr},
/*through_sig */
    {ts, ts, ts, ts, ts, ts, ts, ts, ts, shl, shlr},
/*shlib */
    {shl, shl, shl, shl, shl, shl, shl, shl, ts, shl, shlr},
/*catch_shlib */
    {shlr, shlr, shlr, shlr, shlr, shlr, shlr, shlr, ts, shlr, shlr}
  };
d2554 2
a2555 39
	case bp_shlib_event:
	  bs_class = shlib_event;
	  break;
	case bp_catch_load:
	case bp_catch_unload:
	  /* Only if this catchpoint triggered should we cause the
	     step-out-of-dld behaviour.  Otherwise, we ignore this
	     catchpoint.  */
	  if (bs->stop)
	    bs_class = catch_shlib_event;
	  else
	    bs_class = no_effect;
	  break;
	case bp_catch_fork:
	case bp_catch_vfork:
	case bp_catch_exec:
	  if (bs->stop)
	    {
	      if (bs->print)
		bs_class = bp_noisy;
	      else
		bs_class = bp_silent;
	    }
	  else
	    /* There was a catchpoint, but we're not stopping.  This requires
	       no further action.  */
	    bs_class = no_effect;
	  break;
	case bp_catch_catch:
	  if (!bs->stop || CURRENT_EXCEPTION_KIND != EX_EVENT_CATCH)
	    bs_class = bp_nostop;
	  else if (bs->stop)
	    bs_class = bs->print ? bp_noisy : bp_silent;
	  break;
	case bp_catch_throw:
	  if (!bs->stop || CURRENT_EXCEPTION_KIND != EX_EVENT_THROW)
	    bs_class = bp_nostop;
	  else if (bs->stop)
	    bs_class = bs->print ? bp_noisy : bp_silent;
d2557 37
d2601 1
a2601 1
      current_action = table[(int) bs_class][(int) current_action];
d2611 1
a2611 1
int
d2617 1
a2617 1
    return 1;
d2628 5
a2632 5
	(b->inserted) &&
	((b->type == bp_hardware_watchpoint) ||
	 (b->type == bp_read_watchpoint) ||
	 (b->type == bp_access_watchpoint)))
    return 1;
d2635 1
a2636 1

d2642 2
a2643 2
     bpstat ep_list;
     bpstat *cp_list;
d2645 5
a2649 5
  struct bpstats root_bs[1];
  bpstat bs = root_bs;
  struct breakpoint *ep;
  char *dll_pathname;

d2652 2
a2653 2

  for (; ep_list != NULL; ep_list = ep_list->next)
d2658 7
a2664 7
	break;
      if ((ep->type != bp_catch_load) &&
	  (ep->type != bp_catch_unload) &&
	  (ep->type != bp_catch_catch) &&
	  (ep->type != bp_catch_throw))		/* pai: (temp) ADD fork/vfork here!!  */
	continue;

d2670 1
a2670 1

d2678 1
a2678 1
	free (ep->triggered_dll_pathname);
d2680 1
a2680 1
	dll_pathname = SOLIB_LOADED_LIBRARY_PATHNAME (inferior_pid);
d2682 1
a2682 1
	dll_pathname = SOLIB_UNLOADED_LIBRARY_PATHNAME (inferior_pid);
d2694 1
a2694 1

d2702 4
a2705 6
typedef struct
{
  enum bptype type;
  char *description;
}
ep_type_description_t;
d2715 1
a2715 1
  CORE_ADDR last_addr = (CORE_ADDR) - 1;
d2717 1
a2717 1
  static ep_type_description_t bptypes[] =
d2719 2
a2720 2
    {bp_none, "?deleted?"},
    {bp_breakpoint, "breakpoint"},
d2722 3
a2724 3
    {bp_until, "until"},
    {bp_finish, "finish"},
    {bp_watchpoint, "watchpoint"},
d2726 17
a2742 17
    {bp_read_watchpoint, "read watchpoint"},
    {bp_access_watchpoint, "acc watchpoint"},
    {bp_longjmp, "longjmp"},
    {bp_longjmp_resume, "longjmp resume"},
    {bp_step_resume, "step resume"},
    {bp_through_sigtramp, "sigtramp"},
    {bp_watchpoint_scope, "watchpoint scope"},
    {bp_call_dummy, "call dummy"},
    {bp_shlib_event, "shlib events"},
    {bp_catch_load, "catch load"},
    {bp_catch_unload, "catch unload"},
    {bp_catch_fork, "catch fork"},
    {bp_catch_vfork, "catch vfork"},
    {bp_catch_exec, "catch exec"},
    {bp_catch_catch, "catch catch"},
    {bp_catch_throw, "catch throw"}
  };
d2744 1
a2744 2
  static char *bpdisps[] =
  {"del", "dstp", "dis", "keep"};
d2752 1
a2752 1
    {
d2754 15
a2768 15
      if (!allflag
	  && b->type != bp_breakpoint
	  && b->type != bp_catch_load
	  && b->type != bp_catch_unload
	  && b->type != bp_catch_fork
	  && b->type != bp_catch_vfork
	  && b->type != bp_catch_exec
	  && b->type != bp_catch_catch
	  && b->type != bp_catch_throw
	  && b->type != bp_hardware_breakpoint
	  && b->type != bp_watchpoint
	  && b->type != bp_read_watchpoint
	  && b->type != bp_access_watchpoint
	  && b->type != bp_hardware_watchpoint)
	continue;
d2770 119
a2888 3
      if (!found_a_breakpoint++)
	{
	  annotate_breakpoints_headers ();
d2890 1
a2890 15
	  annotate_field (0);
	  printf_filtered ("Num ");
	  annotate_field (1);
	  printf_filtered ("Type           ");
	  annotate_field (2);
	  printf_filtered ("Disp ");
	  annotate_field (3);
	  printf_filtered ("Enb ");
	  if (addressprint)
	    {
	      annotate_field (4);
	      printf_filtered ("Address    ");
	    }
	  annotate_field (5);
	  printf_filtered ("What\n");
d2892 18
a2909 2
	  annotate_breakpoints_table ();
	}
d2911 2
a2912 29
      annotate_record ();
      annotate_field (0);
      printf_filtered ("%-3d ", b->number);
      annotate_field (1);
      if ((int) b->type > (sizeof (bptypes) / sizeof (bptypes[0])))
	error ("bptypes table does not describe type #%d.", (int) b->type);
      if ((int) b->type != bptypes[(int) b->type].type)
	error ("bptypes table does not describe type #%d?", (int) b->type);
      printf_filtered ("%-14s ", bptypes[(int) b->type].description);
      annotate_field (2);
      printf_filtered ("%-4s ", bpdisps[(int) b->disposition]);
      annotate_field (3);
      printf_filtered ("%-3c ", bpenables[(int) b->enable]);

      strcpy (wrap_indent, "                           ");
      if (addressprint)
	strcat (wrap_indent, "           ");
      switch (b->type)
	{
	case bp_watchpoint:
	case bp_hardware_watchpoint:
	case bp_read_watchpoint:
	case bp_access_watchpoint:
	  /* Field 4, the address, is omitted (which makes the columns
	     not line up too nicely with the headers, but the effect
	     is relatively readable).  */
	  annotate_field (5);
	  print_expression (b->exp, gdb_stdout);
	  break;
d2914 1
a2914 11
	case bp_catch_load:
	case bp_catch_unload:
	  /* Field 4, the address, is omitted (which makes the columns
	     not line up too nicely with the headers, but the effect
	     is relatively readable).  */
	  annotate_field (5);
	  if (b->dll_pathname == NULL)
	    printf_filtered ("<any library> ");
	  else
	    printf_filtered ("library \"%s\" ", b->dll_pathname);
	  break;
d2916 3
a2918 9
	case bp_catch_fork:
	case bp_catch_vfork:
	  /* Field 4, the address, is omitted (which makes the columns
	     not line up too nicely with the headers, but the effect
	     is relatively readable).  */
	  annotate_field (5);
	  if (b->forked_inferior_pid != 0)
	    printf_filtered ("process %d ", b->forked_inferior_pid);
	  break;
d2920 4
a2923 22
	case bp_catch_exec:
	  /* Field 4, the address, is omitted (which makes the columns
	     not line up too nicely with the headers, but the effect
	     is relatively readable).  */
	  annotate_field (5);
	  if (b->exec_pathname != NULL)
	    printf_filtered ("program \"%s\" ", b->exec_pathname);
	  break;
	case bp_catch_catch:
	  /* Field 4, the address, is omitted (which makes the columns
	     not line up too nicely with the headers, but the effect
	     is relatively readable).  */
	  annotate_field (5);
	  printf_filtered ("exception catch ");
	  break;
	case bp_catch_throw:
	  /* Field 4, the address, is omitted (which makes the columns
	     not line up too nicely with the headers, but the effect
	     is relatively readable).  */
	  annotate_field (5);
	  printf_filtered ("exception throw ");
	  break;
d2925 3
a2927 21
	case bp_breakpoint:
	case bp_hardware_breakpoint:
	case bp_until:
	case bp_finish:
	case bp_longjmp:
	case bp_longjmp_resume:
	case bp_step_resume:
	case bp_through_sigtramp:
	case bp_watchpoint_scope:
	case bp_call_dummy:
	case bp_shlib_event:
	  if (addressprint)
	    {
	      annotate_field (4);
	      /* FIXME-32x64: need a print_address_numeric with
	         field width */
	      printf_filtered
		("%s ",
		 local_hex_string_custom
		 ((unsigned long) b->address, "08l"));
	    }
d2929 4
a2932 1
	  annotate_field (5);
d2934 5
a2938 18
	  last_addr = b->address;
	  if (b->source_file)
	    {
	      sym = find_pc_sect_function (b->address, b->section);
	      if (sym)
		{
		  fputs_filtered ("in ", gdb_stdout);
		  fputs_filtered (SYMBOL_SOURCE_NAME (sym), gdb_stdout);
		  wrap_here (wrap_indent);
		  fputs_filtered (" at ", gdb_stdout);
		}
	      fputs_filtered (b->source_file, gdb_stdout);
	      printf_filtered (":%d", b->line_number);
	    }
	  else
	    print_address_symbolic (b->address, gdb_stdout, demangle, " ");
	  break;
	}
d2940 10
a2949 2
      if (b->thread != -1)
	printf_filtered (" thread %d", b->thread);
d2951 3
a2953 1
      printf_filtered ("\n");
d2955 2
a2956 3
      if (b->frame)
	{
	  annotate_field (6);
d2958 3
a2960 4
	  printf_filtered ("\tstop only in stack frame at ");
	  print_address_numeric (b->frame, 1, gdb_stdout);
	  printf_filtered ("\n");
	}
d2962 7
a2968 44
      if (b->cond)
	{
	  annotate_field (7);

	  printf_filtered ("\tstop only if ");
	  print_expression (b->cond, gdb_stdout);
	  printf_filtered ("\n");
	}

      if (b->thread != -1)
	{
	  /* FIXME should make an annotation for this */
	  printf_filtered ("\tstop only in thread %d\n", b->thread);
	}

      if (show_breakpoint_hit_counts && b->hit_count)
	{
	  /* FIXME should make an annotation for this */
	  if (ep_is_catchpoint (b))
	    printf_filtered ("\tcatchpoint");
	  else
	    printf_filtered ("\tbreakpoint");
	  printf_filtered (" already hit %d time%s\n",
			   b->hit_count, (b->hit_count == 1 ? "" : "s"));
	}

      if (b->ignore_count)
	{
	  annotate_field (8);

	  printf_filtered ("\tignore next %d hits\n", b->ignore_count);
	}

      if ((l = b->commands))
	{
	  annotate_field (9);

	  while (l)
	    {
	      print_command_line (l, 4, gdb_stdout);
	      l = l->next;
	    }
	}
    }
d2973 1
a2973 1
	printf_filtered ("No breakpoints or watchpoints.\n");
d2975 1
a2975 1
	printf_filtered ("No breakpoint or watchpoint number %d.\n", bnum);
d2980 2
a2981 2
  if (last_addr != (CORE_ADDR) - 1)
    set_next_address (last_addr);
d3026 3
a3028 3
    if (overlay_debugging == 0 ||
	b->section == section)
      others++;
d3034 11
a3044 11
	if (overlay_debugging == 0 ||
	    b->section == section)
	  {
	    others--;
	    printf_filtered
	      ("%d%s%s ",
	       b->number,
	       ((b->enable == disabled || b->enable == shlib_disabled || b->enable == call_disabled)
		? " (disabled)" : ""),
	       (others > 1) ? "," : ((others == 1) ? " and" : ""));
	  }
d3088 4
a3091 4
    {
      count++;
      b->duplicate = count > 1;
    }
d3163 1
a3163 1
  INIT_SAL (&sal);		/* initialize to zeroes */
d3168 1
a3168 1
      m = lookup_minimal_symbol_text (func_name, NULL, (struct objfile *) NULL);
d3176 1
a3176 2
  if (!b)
    return;
d3183 1
a3183 1
    b->addr_string = strsave (func_name);
d3187 1
a3187 1
#endif /* #ifdef GET_LONGJMP_TARGET */
d3194 1
a3194 1
enable_longjmp_breakpoint ()
d3200 4
a3203 4
    {
      b->enable = enabled;
      check_duplicates (b->address, b->section);
    }
d3207 1
a3207 1
disable_longjmp_breakpoint ()
d3212 1
a3212 1
    if (b->type == bp_longjmp
d3214 4
a3217 4
    {
      b->enable = disabled;
      check_duplicates (b->address, b->section);
    }
d3228 1
a3228 1
    delete_breakpoint (b);
d3238 1
a3238 1
  INIT_SAL (&sal);		/* initialize to zeroes */
d3251 2
a3252 2
  struct breakpoint *b;
  int disabled_shlib_breaks = 0;
d3256 1
a3256 1
  {
d3258 19
a3276 19
    if (((b->type == bp_breakpoint) ||
	 (b->type == bp_hardware_breakpoint)) &&
	(b->enable != shlib_disabled) &&
	(b->enable != call_disabled) &&
	!b->duplicate &&
	PC_SOLIB (b->address))
      {
	b->enable = shlib_disabled;
	if (!silent)
	  {
	    if (!disabled_shlib_breaks)
	      {
		target_terminal_ours_for_output ();
		printf_filtered ("Temporarily disabling shared library breakpoints:\n");
	      }
	    disabled_shlib_breaks = 1;
	    printf_filtered ("%d ", b->number);
	  }
      }
d3278 1
a3278 1
  }
d3291 2
a3292 2
    {
      char buf[1];
d3294 5
a3298 5
      /* Do not reenable the breakpoint if the shared library
         is still not mapped in.  */
      if (target_read_memory (b->address, buf, 1) == 0)
	b->enable = enabled;
    }
d3311 1
a3311 1
  struct breakpoint *b;
d3313 9
a3321 9
  struct symtab_and_line sal;
  struct cleanup *old_chain;
  struct cleanup *canonical_strings_chain = NULL;
  int i;
  char *addr_start = hookname;
  char *addr_end = NULL;
  char **canonical = (char **) NULL;
  int thread = -1;		/* All threads. */

d3325 1
a3325 1

d3343 1
a3343 1
  if (canonical != (char **) NULL)
d3348 1
a3348 1
	make_cleanup (free, canonical[0]);
d3350 1
a3350 1

d3352 1
a3352 1

d3354 1
a3354 1
  if (canonical != (char **) NULL)
d3356 1
a3356 1

d3363 2
a3364 2

  if (canonical != (char **) NULL && canonical[0] != NULL)
d3368 1
a3368 1

d3371 1
a3371 1

d3380 1
a3380 1

d3387 4
a3390 4
     char *hookname;
     int tempflag;
     char *dll_pathname;
     char *cond_string;
d3393 4
a3396 4
					     tempflag,
					     dll_pathname,
					     cond_string,
					     bp_catch_load);
d3401 4
a3404 4
     char *hookname;
     int tempflag;
     char *dll_pathname;
     char *cond_string;
d3407 4
a3410 4
					     tempflag,
					     dll_pathname,
					     cond_string,
					     bp_catch_unload);
d3419 5
a3423 5
  struct symtab_and_line sal;
  struct breakpoint *b;
  int thread = -1;		/* All threads. */

  INIT_SAL (&sal);
d3427 1
a3427 1

d3438 1
a3438 1

d3440 1
a3440 1

d3446 2
a3447 2
     int tempflag;
     char *cond_string;
d3451 1
a3451 1

d3454 2
a3455 2
     int tempflag;
     char *cond_string;
d3462 2
a3463 2
     int tempflag;
     char *cond_string;
d3465 3
a3467 3
  struct symtab_and_line sal;
  struct breakpoint *b;
  int thread = -1;		/* All threads. */
d3469 1
a3469 1
  INIT_SAL (&sal);
d3490 1
a3490 1
hw_breakpoint_used_count ()
d3496 4
a3499 4
  {
    if (b->type == bp_hardware_breakpoint && b->enable == enabled)
      i++;
  }
d3505 3
a3507 3
hw_watchpoint_used_count (type, other_type_used)
     enum bptype type;
     int *other_type_used;
d3514 11
a3524 12
  {
    if (b->enable == enabled)
      {
	if (b->type == type)
	  i++;
	else if ((b->type == bp_hardware_watchpoint ||
		  b->type == bp_read_watchpoint ||
		  b->type == bp_access_watchpoint)
		 && b->enable == enabled)
	  *other_type_used = 1;
      }
  }
d3535 1
a3535 1
set_longjmp_resume_breakpoint (pc, frame)
d3543 10
a3552 10
    {
      b->address = pc;
      b->enable = enabled;
      if (frame != NULL)
	b->frame = frame->frame;
      else
	b->frame = 0;
      check_duplicates (b->address, b->section);
      return;
    }
d3558 1
a3558 1
  struct breakpoint *b;
d3561 12
a3572 12
  {
    if (((b->type == bp_watchpoint)
	 || (b->type == bp_hardware_watchpoint)
	 || (b->type == bp_read_watchpoint)
	 || (b->type == bp_access_watchpoint)
	 || ep_is_exception_catchpoint (b))
	&& (b->enable == enabled))
      {
	b->enable = call_disabled;
	check_duplicates (b->address, b->section);
      }
  }
d3578 1
a3578 1
  struct breakpoint *b;
d3581 12
a3592 12
  {
    if (((b->type == bp_watchpoint)
	 || (b->type == bp_hardware_watchpoint)
	 || (b->type == bp_read_watchpoint)
	 || (b->type == bp_access_watchpoint)
	 || ep_is_exception_catchpoint (b))
	&& (b->enable == call_disabled))
      {
	b->enable = enabled;
	check_duplicates (b->address, b->section);
      }
  }
d3621 1
a3622 1

d3657 1
a3657 1
      printf_filtered ("Hardware access (read/write) watchpoint %d: ", b->number);
d3671 3
a3673 3
		       b->number,
		       (b->type == bp_catch_load) ? "load" : "unload",
	     (b->dll_pathname != NULL) ? b->dll_pathname : "<any library>");
d3678 2
a3679 2
		       b->number,
		       (b->type == bp_catch_fork) ? "fork" : "vfork");
d3683 1
a3683 1
		       b->number);
d3688 2
a3689 2
		       b->number,
		       (b->type == bp_catch_catch) ? "catch" : "throw");
d3713 2
a3714 2
      TUIDO (((TuiOpaqueFuncPtr) tui_vAllSetHasBreakAt, b, 1));
      TUIDO (((TuiOpaqueFuncPtr) tuiUpdateAllExecInfos));
d3718 1
a3719 1

d3722 1
a3722 1
   second bit : 0 normal breakpoint, 1 hardware breakpoint. */
d3744 1
a3744 1
  char **canonical = (char **) NULL;
d3754 1
a3754 1
  INIT_SAL (&sal);		/* initialize to zeroes */
d3758 1
a3758 1
  if (!arg || (arg[0] == 'i' && arg[1] == 'f'
d3763 1
a3763 1
	  sals.sals = (struct symtab_and_line *)
d3768 1
a3768 1
	  sal.section = find_pc_overlay (sal.pc);
d3780 3
a3782 3
         current_source_symtab (which is decode_line_1's default).  This
         should produce the results we want almost all of the time while
         leaving default_breakpoint_* alone.  */
d3789 1
a3789 1
	sals = decode_line_1 (&arg, 1, (struct symtab *) NULL, 0, &canonical);
d3793 2
a3794 2

  if (!sals.nelts)
d3800 1
a3800 1
  if (canonical != (char **) NULL)
d3835 5
a3839 5
      if (PC_REQUIRES_RUN_BEFORE_USE (sals.sals[i].pc))
	{
	  error ("Cannot break on %s without a running program.", addr_start);
	}

d3880 1
a3880 1
      i = hw_breakpoint_used_count ();
d3882 1
a3882 1
				 bp_hardware_breakpoint, i + sals.nelts, 0);
d3886 1
a3886 1
	error ("Hardware breakpoints used exceeds limit.");
d3890 1
a3890 1
  if (canonical != (char **) NULL)
d3909 2
a3910 2
         command string.  */
      if (canonical != (char **) NULL && canonical[i] != NULL)
d3916 1
a3916 1

d3985 1
a3985 1
      extra_args_len = strlen (arg);
d3990 1
a3990 1
      if (find_pc_partial_function (selected_pc, (char **) NULL, &low, &high))
d4050 1
a4050 11
      extra_args_len = strlen (arg);
    }
  else if (arg)
    {
      /* get the stuff after the function name or address */
      extra_args = strchr (arg, ' ');
      if (extra_args)
	{
	  extra_args++;
	  extra_args_len = strlen (extra_args);
	}
d4052 11
d4067 3
a4069 3
  beg_addr_string = addr_string;
  sals = decode_line_1 (&addr_string, 1, (struct symtab *) NULL, 0,
			(char ***) NULL);
d4076 1
a4076 1
      if (find_pc_partial_function (sal.pc, (char **) NULL, &low, &high))
d4084 1
a4084 1
	  free (break_string);
d4094 1
a4094 1
  do_cleanups (old_chain);
d4117 3
a4119 3
      struct block *b;
      struct symbol *sym;
      int index;
d4121 1
a4121 1
      bv = blockvector_for_pc_sect (sal->pc, 0, &index, sal->symtab);
d4124 1
a4124 1
	  b = BLOCKVECTOR_BLOCK (bv, index);
d4134 3
a4136 3
	         have to look harder. This case can be executed if we have 
	         line numbers but no functions (as can happen in assembly 
	         source).  */
d4138 1
a4138 1
	      struct minimal_symbol *msym;
d4221 1
a4221 1
  if (arg == (char *) NULL)
d4229 2
a4230 2
         it is bad, otherwise, it should be an address or function/method
         name */
d4232 4
a4235 4
	{
	  hasColon = (*argptr == ':');
	  argptr++;
	}
d4238 1
a4238 1
	badInput = (*argptr != ':');	/* Not a class::method */
d4240 1
a4240 1
	badInput = isdigit (*arg);	/* a simple line number */
d4244 1
a4244 1
    printf_filtered ("Usage: stop in <function | address>\n");
d4256 1
a4256 1
  if (arg == (char *) NULL || *arg == '*')	/* no line number */
d4264 1
a4264 1
         it is probably a line number. */
d4266 4
a4269 4
	{
	  hasColon = (*argptr == ':');
	  argptr++;
	}
d4272 1
a4272 1
	badInput = (*argptr == ':');	/* we have class::method */
d4274 1
a4274 1
	badInput = !isdigit (*arg);	/* not a line number */
d4278 1
a4278 1
    printf_filtered ("Usage: stop at <line>\n");
d4309 2
a4310 2
  INIT_SAL (&sal);		/* initialize to zeroes */

d4339 1
a4339 1
    error ("Junk at end of command.");
d4341 3
a4343 6
  if (accessflag == 1)
    bp_type = bp_read_watchpoint;
  else if (accessflag == 2)
    bp_type = bp_access_watchpoint;
  else
    bp_type = bp_hardware_watchpoint;
d4348 9
a4356 10
  if (mem_cnt != 0)
    {
      i = hw_watchpoint_used_count (bp_type, &other_type_used);
      target_resources_ok = TARGET_CAN_USE_HARDWARE_WATCHPOINT (
				     bp_type, i + mem_cnt, other_type_used);
      if (target_resources_ok == 0 && bp_type != bp_hardware_watchpoint)
	error ("Target does not have this type of hardware watchpoint support.");
      if (target_resources_ok < 0 && bp_type != bp_hardware_watchpoint)
	error ("Target resources have been allocated for other types of watchpoints.");
    }
d4359 1
a4359 1
  /*  On HP-UX if you set a h/w
d4373 1
a4373 1
  if (!target_has_execution)
d4379 1
a4379 1

d4394 1
a4394 1

d4402 1
a4402 1
    b->watchpoint_frame = (CORE_ADDR) 0;
d4420 1
a4420 1
	  scope_sal.pc = get_frame_pc (prev_frame);
d4464 1
a4464 1
  if (!can_use_hw_watchpoints)
d4466 1
a4466 1

d4471 1
a4471 1
  for (; v; v = v->next)
d4477 1
a4477 1
	}
d4487 1
a4487 2
static void
watch_command (arg, from_tty)
d4494 1
a4494 2
static void
rwatch_command (arg, from_tty)
d4501 1
a4501 2
static void
awatch_command (arg, from_tty)
d4507 1
a4508 1

d4543 1
a4543 1

d4546 1
a4546 1
			  default_breakpoint_line, (char ***) NULL);
d4548 2
a4549 2
    sals = decode_line_1 (&arg, 1, (struct symtab *) NULL, 0, (char ***) NULL);

d4552 1
a4552 1

d4554 2
a4555 2
  free ((PTR) sals.sals);	/* malloc'd, so freed */

d4558 1
a4558 1

d4560 1
a4560 1

d4562 1
a4562 1

d4578 3
a4580 3
         all it needs to do is do the cleanups in the
         exec_cleanup_chain, which will be only those inserted by this
         function. We can get away by using ALL_CLEANUPS. */
d4585 1
a4585 1

d4596 1
a4596 1

d4601 1
a4601 1
    do_cleanups (old_chain);
d4646 1
a4646 1
     int (*function) ();
d4684 1
a4684 1
	  alloca (sizeof (struct sal_chain));
d4696 1
a4696 2
      while (*p == ' ' || *p == '\t')
	p++;
d4773 1
a4773 1
		      alloca (sizeof (struct sal_chain));
d4789 2
a4790 2
         Don't continue to its superblock, the block of
         per-file symbols.  */
d4819 4
a4822 4
  if ((s == NULL) || (*s == NULL))
    return;
  while (isspace (**s))
    *s += 1;
d4824 1
a4824 1

d4833 3
a4835 3
  char *s = arg;
  char *event_name_end = NULL;

d4839 1
a4839 1

d4841 2
a4842 2
     Basically, we're looking for alphanumerics and underscores;
     anything else delimites the token. */
d4845 2
a4846 2
      if (!isalnum (*s) && (*s != '_'))
	break;
d4850 1
a4850 1

d4854 1
a4854 1

d4857 1
a4857 1

d4866 3
a4868 3
  char *cond_string;

  if (((*arg)[0] != 'i') || ((*arg)[1] != 'f') || !isspace ((*arg)[2]))
d4870 1
a4870 1

d4873 1
a4873 1

d4878 1
a4878 1

d4881 1
a4881 1

d4884 1
a4884 1

d4887 1
a4887 1

d4892 1
a4892 1

d4899 5
a4903 5
  static char filename[1024];
  char *arg_p = *arg;
  int i;
  char c;

d4906 2
a4907 2

  for (i = 0;; i++)
d4911 1
a4911 1
	c = '\0';
d4914 1
a4914 1
	break;
d4918 1
a4918 1

d4921 1
a4921 1

d4924 3
a4926 7

typedef enum
{
  catch_fork, catch_vfork
}
catch_fork_kind;

d4936 2
a4937 2
  char *cond_string = NULL;

d4939 1
a4939 1

d4941 3
a4943 3
     catch [v]fork
     catch [v]fork if <cond>

d4946 1
a4946 1

d4949 1
a4949 1

d4952 2
a4953 3
  switch (fork_kind)
    {
    case catch_fork:
d4956 1
a4956 1
    case catch_vfork:
d4959 1
a4959 1
    default:
d4962 1
a4962 1
    }
d4971 1
a4971 1
  char *cond_string = NULL;
d4976 2
a4977 2
     catch exec
     catch exec if <cond>
d4989 1
a4989 1

d4993 7
a4999 7
     char *arg;
     int tempflag;
     int from_tty;
{
  char *dll_pathname = NULL;
  char *cond_string = NULL;

d5001 1
a5001 1

d5003 5
a5007 5
     catch load
     catch load if <cond>
     catch load <filename>
     catch load <filename> if <cond>

d5010 1
a5010 1

d5012 1
a5012 1

d5016 1
a5016 1

d5025 1
a5025 1

d5028 1
a5028 1

d5034 1
a5034 1

d5037 7
a5043 7
     char *arg;
     int tempflag;
     int from_tty;
{
  char *dll_pathname = NULL;
  char *cond_string = NULL;

d5045 1
a5045 1

d5047 5
a5051 5
     catch unload
     catch unload if <cond>
     catch unload <filename>
     catch unload <filename> if <cond>

d5054 1
a5054 1

d5056 1
a5056 1

d5060 1
a5060 1

d5069 1
a5069 1

d5072 1
a5072 1

d5083 1
a5083 1
   exception event callback */
d5092 3
a5094 3
  struct breakpoint *b;
  int i;
  int thread = -1;		/* All threads. */
d5096 1
a5096 1
  if (!sal)			/* no exception support? */
d5110 10
a5119 10
    case EX_EVENT_THROW:
      b->type = bp_catch_throw;
      break;
    case EX_EVENT_CATCH:
      b->type = bp_catch_catch;
      break;
    default:			/* error condition */
      b->type = bp_none;
      b->enable = disabled;
      error ("Internal error -- invalid catchpoint kind");
d5124 1
a5124 1
/* Deal with "catch catch" and "catch throw" commands */
d5133 3
a5135 3
  char *cond_string = NULL;
  struct symtab_and_line *sal = NULL;

d5137 1
a5137 1

d5150 1
a5150 1
  if (sal)
d5153 1
a5153 1
         Set a breakpoint on the sal found, if no errors */
d5155 1
a5155 1
	create_exception_catchpoint (tempflag, cond_string, ex_event, sal);
d5157 1
a5157 1
	return;			/* something went wrong with setting up callbacks */
d5159 1
a5159 1
  else
d5164 3
a5166 3
	{
	  handle_gnu_4_16_catch_command (arg, tempflag, from_tty);
	}
d5168 7
a5174 7
	{
	  /* Set a breakpoint on __raise_exception () */

	  fprintf_filtered (gdb_stderr, "Unsupported with this platform/compiler combination.\n");
	  fprintf_filtered (gdb_stderr, "Perhaps you can achieve the effect you want by setting\n");
	  fprintf_filtered (gdb_stderr, "a breakpoint on __raise_exception().\n");
	}
d5183 1
a5183 1
     PTR arg;
d5193 1
a5193 1
    return 1;			/*is valid */
d5206 1
a5206 1

d5226 1
a5226 1
  INIT_SAL (&sal);		/* initialize to zeroes */
d5231 1
a5231 1
  if (!arg || (arg[0] == 'i' && arg[1] == 'f'
d5246 1
a5246 1
         pai/1997-07-11 */
d5253 1
a5253 1
  if (!sals.nelts)
d5260 1
a5260 1

d5265 1
a5265 1
	    cond = parse_exp_1 ((arg += 2, &arg),
d5283 6
a5288 6
      b->type = bp_breakpoint;	/* Important -- this is an ordinary breakpoint.
				   For platforms with callback support for exceptions,
				   create_exception_catchpoint() will create special
				   bp types (bp_catch_catch and bp_catch_throw), and
				   there is code in insert_breakpoints() and elsewhere
				   that depends on that. */
d5302 1
a5302 1
  free ((PTR) sals.sals);
d5310 1
a5310 1
     CORE_ADDR pc;
d5315 1
a5315 1
  INIT_SAL (&sal);
d5335 3
a5337 3
     char *arg;
     int tempflag;
     int from_tty;
d5339 1
a5339 1

d5344 1
a5344 1

d5346 4
a5349 4
  char *arg1_start = arg;
  char *arg1_end;
  int arg1_length;

d5352 1
a5352 1
      /* Old behaviour was to use pre-v-4.16 syntax */
d5355 1
a5355 1
      /* Now, this is not allowed */
d5363 1
a5363 1

d5371 1
a5371 1
      catch_exception_command_1 (EX_EVENT_CATCH, arg1_end + 1, tempflag, from_tty);
d5375 1
a5375 1
      catch_exception_command_1 (EX_EVENT_THROW, arg1_end + 1, tempflag, from_tty);
d5400 1
a5400 1
      catch_fork_command_1 (catch_fork, arg1_end + 1, tempflag, from_tty);
d5408 1
a5408 1
      catch_fork_command_1 (catch_vfork, arg1_end + 1, tempflag, from_tty);
d5416 1
a5416 1
      catch_exec_command_1 (arg1_end + 1, tempflag, from_tty);
d5424 1
a5424 1
      catch_load_command_1 (arg1_end + 1, tempflag, from_tty);
d5432 1
a5432 1
      catch_unload_command_1 (arg1_end + 1, tempflag, from_tty);
d5441 1
a5441 1

d5447 1
a5447 1
         as the name of an exception */
d5449 1
a5449 1
      /* Now this is not allowed */
d5535 1
a5535 1
      sals.sals = (struct symtab_and_line *)
d5537 1
a5537 1
      INIT_SAL (&sal);		/* initialize to zeroes */
d5561 2
a5562 2
         If line given (pc == 0), clear all bpts on specified line.
         If defaulting, clear all bpts on default line
d5564 7
a5570 7

         defaulting    sal.pc != 0    tests to do

         0              1             pc
         1              1             pc _and_ line
         0              0             line
         1              0             <can't happen> */
d5577 15
a5591 15
      /* Why don't we check here that this is not
         a watchpoint, etc., as we do below?
         I can't make it fail, but don't know
         what's stopping the failure: a watchpoint
         of the same address as "sal.pc" should
         wind up being deleted. */

	     && (((sal.pc && (breakpoint_chain->address == sal.pc)) &&
		  (overlay_debugging == 0 ||
		   breakpoint_chain->section == sal.section))
		 || ((default_match || (0 == sal.pc))
		     && breakpoint_chain->source_file != NULL
		     && sal.symtab != NULL
	      && STREQ (breakpoint_chain->source_file, sal.symtab->filename)
		     && breakpoint_chain->line_number == sal.line)))
d5602 14
a5615 14
	while (b->next
	       && b->next->type != bp_none
	       && b->next->type != bp_watchpoint
	       && b->next->type != bp_hardware_watchpoint
	       && b->next->type != bp_read_watchpoint
	       && b->next->type != bp_access_watchpoint
	       && (((sal.pc && (b->next->address == sal.pc)) &&
		    (overlay_debugging == 0 ||
		     b->next->section == sal.section))
		   || ((default_match || (0 == sal.pc))
		       && b->next->source_file != NULL
		       && sal.symtab != NULL
		       && STREQ (b->next->source_file, sal.symtab->filename)
		       && b->next->line_number == sal.line)))
d5618 6
a5623 6
	{
	  b1 = b->next;
	  b->next = b1->next;
	  b1->next = found;
	  found = b1;
	}
d5633 2
a5634 4
      if (found->next)
	from_tty = 1;		/* Always report if deleted more than one */
      if (from_tty)
	printf_unfiltered ("Deleted breakpoint%s ", found->next ? "s" : "");
d5638 1
a5638 2
	  if (from_tty)
	    printf_unfiltered ("%d ", found->number);
d5643 1
a5643 2
      if (from_tty)
	putchar_unfiltered ('\n');
d5645 1
a5645 1
  free ((PTR) sals.sals);
d5659 1
a5659 1
    if (bs->breakpoint_at && bs->breakpoint_at->disposition == del
d5664 4
a5667 4
  {
    if (b->disposition == del_at_next_stop)
      delete_breakpoint (b);
  }
d5704 1
a5704 1

d5713 1
a5713 1
     exceptions are supported in this way, it's OK for now. FIXME */
d5720 1
a5720 1
      sprintf (message, message1, bpt->number);		/* Format possible error msg */
d5730 4
a5733 4
    {
      b->next = bpt->next;
      break;
    }
d5742 5
a5746 5
      {
	clearIt = (b->address != bpt->address);
	if (!clearIt)
	  break;
      }
d5749 4
a5752 4
	{
	  TUIDO (((TuiOpaqueFuncPtr) tui_vAllSetHasBreakAt, bpt, 0));
	  TUIDO (((TuiOpaqueFuncPtr) tuiUpdateAllExecInfos));
	}
d5773 12
a5784 12
	{
	  int val;
	  val = target_insert_breakpoint (b->address, b->shadow_contents);
	  if (val != 0)
	    {
	      target_terminal_ours_for_output ();
	      fprintf_unfiltered (gdb_stderr, "Cannot insert breakpoint %d:\n", b->number);
	      memory_error (val, b->address);	/* which bombs us out */
	    }
	  else
	    b->inserted = 1;
	}
d5829 1
a5829 1
  free ((PTR) bpt);
d5844 9
a5852 9
         Do not delete internal or call-dummy breakpoints, these
         have to be deleted with an explicit breakpoint number argument.  */
      ALL_BREAKPOINTS (b)
      {
	if (b->type != bp_call_dummy &&
	    b->type != bp_shlib_event &&
	    b->number >= 0)
	  breaks_to_delete = 1;
      }
d5858 7
a5864 7
	  ALL_BREAKPOINTS_SAFE (b, temp)
	  {
	    if (b->type != bp_call_dummy &&
		b->type != bp_shlib_event &&
		b->number >= 0)
	      delete_breakpoint (b);
	  }
d5879 1
a5879 1
  struct breakpoint *b = (struct breakpoint *) bint;	/* get past catch_errs */
d5902 1
a5902 1
         its status if we succeed.  */
d5909 1
a5909 1
      sals = decode_line_1 (&s, 1, (struct symtab *) NULL, 0, (char ***) NULL);
d5920 1
a5920 1
		free ((PTR) b->cond);
d5924 1
a5924 1
	  /* We need to re-set the breakpoint if the address changes... */
d5926 2
a5927 2
	  /* ...or new and old breakpoints both have source files, and
	     the source file name or the line number changes...  */
d5932 4
a5936 4
	  /* ...or we switch between having a source file and not having
	     one.  */
	      || ((b->source_file == NULL) != (sals.sals[i].symtab == NULL))
	    )
d5949 3
a5951 3
	      /* Used to check for duplicates here, but that can
	         cause trouble, as it doesn't check for disable
	         breakpoints. */
d5956 1
a5956 1
	         rather than once for every breakpoint.  */
d5963 1
a5963 1
	  /* Now that this is re-enabled, check_duplicates
d5965 1
a5965 1
	  check_duplicates (b->address, b->section);
d5968 1
a5968 1
      free ((PTR) sals.sals);
d5977 6
a5982 6
         one as when it was set, but what does that mean when symbols have
         been re-read?  We could save the filename and functionname, but
         if the context is more local than that, the best we could do would
         be something like how many levels deep and which index at that
         particular level, but that's going to be less stable than filenames
         or functionnames.  */
d5985 1
a5985 1
	free ((PTR) b->exp);
d6000 2
a6001 2
	    free ((PTR) b->cond);
	  b->cond = parse_exp_1 (&s, (struct block *) 0, 0);
d6007 2
a6008 2
    case bp_catch_catch:
    case bp_catch_throw:
d6010 3
a6012 3
      /* We needn't really do anything to reset these, since the mask
         that requests them is unaffected by e.g., new libraries being
         loaded. */
d6017 1
a6017 1

d6021 2
a6022 2
      /* Delete longjmp breakpoints, they will be reset later by
         breakpoint_re_set.  */
d6028 2
a6029 2
      /* This breakpoint is special, it's set up when the inferior
         starts and we really don't want to touch it.  */
d6032 4
a6035 4
      /* Keep temporary breakpoints, which can be encountered when we step
         over a dlopen call and SOLIB_ADD is resetting the breakpoints.
         Otherwise these should have been blown away via the cleanup chain
         or by breakpoint_init_inferior when we rerun the executable.  */
d6055 2
a6056 2
  char message[sizeof (message1) + 30 /* slop */ ];

d6060 4
a6063 4
  {
    sprintf (message, message1, b->number);	/* Format possible error msg */
    catch_errors (breakpoint_re_set_one, b, message, RETURN_MASK_ALL);
  }
d6093 1
a6093 1
     struct breakpoint *b;
d6098 1
a6098 1
	b->thread = pid_to_thread_id (inferior_pid);
d6113 14
a6126 3
    {
      b->ignore_count = count;
      if (!from_tty)
d6128 1
a6128 12
      else if (count == 0)
	printf_filtered ("Will stop next time breakpoint %d is reached.",
			 bptnum);
      else if (count == 1)
	printf_filtered ("Will ignore next crossing of breakpoint %d.",
			 bptnum);
      else
	printf_filtered ("Will ignore next %d crossings of breakpoint %d.",
			 count, bptnum);
      breakpoints_changed ();
      return;
    }
d6155 1
a6155 1

d6187 1
a6187 1

d6192 7
a6198 7
	{
	  struct breakpoint *related_breakpoint = b->related_breakpoint;
	  function (b);
	  if (related_breakpoint)
	    function (related_breakpoint);
	  goto win;
	}
d6233 21
a6253 21
      {
      case bp_none:
	warning ("attempted to disable apparently deleted breakpoint #%d?\n", bpt->number);
	continue;
      case bp_breakpoint:
      case bp_catch_load:
      case bp_catch_unload:
      case bp_catch_fork:
      case bp_catch_vfork:
      case bp_catch_exec:
      case bp_catch_catch:
      case bp_catch_throw:
      case bp_hardware_breakpoint:
      case bp_watchpoint:
      case bp_hardware_watchpoint:
      case bp_read_watchpoint:
      case bp_access_watchpoint:
	disable_breakpoint (bpt);
      default:
	continue;
      }
d6271 3
a6273 3
      i = hw_breakpoint_used_count ();
      target_resources_ok = TARGET_CAN_USE_HARDWARE_WATCHPOINT (
					  bp_hardware_breakpoint, i + 1, 0);
d6275 1
a6275 1
	error ("No hardware breakpoint support in the target.");
d6277 1
a6277 1
	error ("Hardware breakpoints used exceeds limit.");
d6292 5
a6296 5
	  /* Ensure that we have the current frame.  Else, this
	     next query may pessimistically be answered as, "No,
	     not within current scope". */
	  get_current_frame ();
	  fr = find_frame_addr_in_frame_chain (bpt->watchpoint_frame);
d6319 5
a6323 5
	  bpt->type == bp_read_watchpoint ||
	  bpt->type == bp_access_watchpoint)
	{
	  int i = hw_watchpoint_used_count (bpt->type, &other_type_used);
	  int mem_cnt = can_use_hardware_watchpoint (bpt->val);
d6325 9
a6333 9
	  /* Hack around 'unused var' error for some targets here */
	  (void) mem_cnt, i;
	  target_resources_ok = TARGET_CAN_USE_HARDWARE_WATCHPOINT (
				   bpt->type, i + mem_cnt, other_type_used);
	  /* we can consider of type is bp_hardware_watchpoint, convert to 
	     bp_watchpoint in the following condition */
	  if (target_resources_ok < 0)
	    {
	      printf_filtered ("\
d6336 5
a6340 5
	      bpt->enable = disabled;
	      value_free_to_mark (mark);
	      return;
	    }
	}
d6371 21
a6391 21
      {
      case bp_none:
	warning ("attempted to enable apparently deleted breakpoint #%d?\n", bpt->number);
	continue;
      case bp_breakpoint:
      case bp_catch_load:
      case bp_catch_unload:
      case bp_catch_fork:
      case bp_catch_vfork:
      case bp_catch_exec:
      case bp_catch_catch:
      case bp_catch_throw:
      case bp_hardware_breakpoint:
      case bp_watchpoint:
      case bp_hardware_watchpoint:
      case bp_read_watchpoint:
      case bp_access_watchpoint:
	enable_breakpoint (bpt);
      default:
	continue;
      }
d6441 1
a6441 1
			  (char ***) NULL);
d6444 1
a6444 1
			  (struct symtab *) NULL, 0, (char ***) NULL);
d6464 1
a6464 1
    add_com_alias ("bc", "ignore", class_breakpoint, 1);
d6485 2
a6486 2
  add_com ("txbreak", class_breakpoint, tbreak_at_finish_command,
	   "Set temporary breakpoint at procedure exit.  Either there should\n\
d6507 2
a6508 2
    add_com ("ab", class_breakpoint, enable_command,
	     "Enable some breakpoints.\n\
d6517 1
a6517 1
			 "Enable some breakpoints.\n\
d6521 1
a6521 1
		   &enablebreaklist, "enable breakpoints ", 1, &enablelist);
d6544 1
a6544 1
		  "Disable some breakpoints.\n\
d6552 2
a6553 2
    add_com ("sb", class_breakpoint, disable_command,
	     "Disable some breakpoints.\n\
d6567 1
a6567 1
		  "Delete some breakpoints or auto-display expressions.\n\
d6577 1
a6577 1
	     "Delete some breakpoints.\n\
d6594 1
a6594 1
		   "With no argument, clears all breakpoints in the line that the selected frame\n\
d6605 1
a6605 1
		   "With no arg, uses current execution address of selected stack frame.\n\
d6616 2
a6617 2
  add_com ("xbreak", class_breakpoint, break_at_finish_command,
	   concat ("Set breakpoint at procedure exit. \n\
d6622 1
a6622 1
		   "With no arg, uses current execution address of selected stack frame.\n\
d6638 1
a6638 1
	       "Set breakpoint at procedure exit.  Either there should\n\
d6644 9
a6652 9
      add_abbrev_prefix_cmd ("stop", class_breakpoint, stop_command,
	"Break in function/address or break at a line in the current file.",
			     &stoplist, "stop ", 1, &cmdlist);
      add_cmd ("in", class_breakpoint, stopin_command,
	       "Break in function or address.\n", &stoplist);
      add_cmd ("at", class_breakpoint, stopat_command,
	       "Break at a line in the current file.\n", &stoplist);
      add_com ("status", class_info, breakpoints_info,
	       concat ("Status of user-settable breakpoints, or breakpoint number NUMBER.\n\
d6660 1
a6660 1
		       "Convenience variable \"$_\" and default examine address for \"x\"\n\
d6675 1
a6675 1
		    "Convenience variable \"$_\" and default examine address for \"x\"\n\
d6681 2
a6682 2
    add_com ("lb", class_breakpoint, breakpoints_info,
	     concat ("Status of user-settable breakpoints, or breakpoint number NUMBER.\n\
d6690 1
a6690 1
		     "Convenience variable \"$_\" and default examine address for \"x\"\n\
d6696 1
a6696 1
	   concat ("Status of all breakpoints, or breakpoint number NUMBER.\n\
d6704 1
a6704 1
		   "The \"Disp\" column contains one of \"keep\", \"del\", or \"dis\" to indicate\n\
d6708 1
a6708 1
		   "Convenience variable \"$_\" and default examine address for \"x\"\n\
d6715 1
a6715 1
	   "Set catchpoints to catch events.\n\
d6748 1
a6748 1

d6750 1
a6750 1
	   "Set temporary catchpoints to catch events.\n\
d6755 2
a6756 2

  add_com ("watch", class_breakpoint, watch_command,
d6777 2
a6778 2
		   (char *) &can_use_hw_watchpoints,
		   "Set debugger's willingness to use watchpoint hardware.\n\
d6783 1
a6783 1
		   &setlist);
@


1.1.1.8
log
@import gdb-1999-08-23 snapshot
@
text
@d195 7
a201 17
static void solib_load_unload_1 PARAMS ((char *hookname,
					 int tempflag,
					 char *dll_pathname,
					 char *cond_string,
					 enum bptype bp_kind));

static void create_fork_vfork_event_catchpoint PARAMS ((int tempflag, 
							char *cond_string,
							enum bptype bp_kind));

static void break_at_finish_at_depth_command_1 PARAMS ((char *arg, 
							int flag, 
							int from_tty));

static void break_at_finish_command_1 PARAMS ((char *arg, 
					       int flag, 
					       int from_tty));
d215 1
a215 2
static void catch_exec_command_1 PARAMS ((char *arg, int tempflag, 
					  int from_tty));
d217 3
a219 8
static void create_exception_catchpoint 
  PARAMS ((int tempflag, char *cond_string,
	   enum exception_event_kind ex_event,
	   struct symtab_and_line * sal));

static void catch_exception_command_1 
  PARAMS ((enum exception_event_kind ex_event,
	   char *arg, int tempflag, int from_tty));
d415 1
a415 1
 "Convenience variables used to specify breakpoints must have integer values."
d517 1
a517 3
      sprintf (tmpbuf, 
	       "Type commands for when breakpoint %d is hit, one per line.", 
	       bnum);
d553 1
a553 2
      warning ("reading through apparently deleted breakpoint #%d?", 
	       b->number);
a642 1
  int return_val = 0;	/* return success code. */
d706 3
a708 2
		    warning ("Cannot insert breakpoint %d:", b->number);
		    warning ("Temporarily disabling shared library breakpoints:");
d711 1
a711 1
		warning ("breakpoint #%d ", b->number);
d717 1
a717 1
		warning ("Cannot insert breakpoint %d:", b->number);
d719 2
a720 1
		warning ("The same program may be running in another process.");
d722 1
a722 1
		memory_error (val, b->address);	   /* which bombs us out */
a726 3

	if (val)
	  return_val = val;	/* remember failure */
d739 1
a739 2
	/* Format possible error message */
	sprintf (message, message1, b->number);
d746 2
a747 2
	    warning ("Cannot insert catchpoint %d; disabling it.",
		     b->number);
d755 1
a755 2
	    args.kind = b->type == bp_catch_catch ? 
	      EX_EVENT_CATCH : EX_EVENT_THROW;
d769 1
a769 2
		warning ("Cannot insert catchpoint %d; disabling it.",
			 b->number);
a772 3

	if (val)
	  return_val = val;	/* remember failure */
d830 1
a830 1
		    type   = hw_write;
d832 1
a832 1
		      type = hw_read;
d834 1
a834 1
		      type = hw_access;
d848 2
a849 6
	      {
		remove_breakpoint (b, mark_uninserted);
		warning ("Could not insert hardware watchpoint %d.",
			 b->number);
		val = -1;
	      }               
d853 3
a855 3
	    printf_filtered ("Hardware watchpoint %d deleted", b->number);
	    printf_filtered ("because the program has left the block \n");
	    printf_filtered ("in which its expression is valid.\n");
a864 3

	if (val)
	  return_val = val;	/* remember failure */
d886 1
a886 1
	    warning ("Internal error, %s line %d.", __FILE__, __LINE__);
d892 1
a892 1
	    warning ("Cannot insert catchpoint %d.", b->number);
a895 3

	if (val)
	  return_val = val;	/* remember failure */
d898 2
d901 1
a901 1
  return return_val;
d931 1
a931 2
  /* FIXME: use a cleanup, to insure that inferior_pid gets replaced! */
  inferior_pid = pid;	/* Because remove_breakpoint will use this global. */
d997 4
a1000 4
       on this target, we may not be able to stop when the vfork is
       seen, but only when the subsequent exec is seen.  (And because
       deleting fork catchpoints here but not vfork catchpoints will
       seem mysterious to users, keep those too.)
d1028 9
a1036 11
       In the absense of a general solution for the "how do we know
       it's safe to delete something others may have handles to?"
       problem, what we'll do here is just uninsert the bp_finish, and
       let finish_command delete it.

       (We know the bp_finish is "doomed" in the sense that it's
       momentary, and will be deleted as soon as finish_command sees
       the inferior stopped.  So it doesn't matter that the bp's
       address is probably bogus in the new a.out, unlike e.g., the
       solib breakpoints.)  */

d1069 1
a1069 2
  /* FIXME: use a cleanup, to insure that inferior_pid gets replaced! */
  inferior_pid = pid;	/* Because remove_breakpoint will use this global. */
d1094 1
a1094 2
    warning ("attempted to remove apparently deleted breakpoint #%d?", 
	     b->number);
d1158 1
a1158 1
	      type   = hw_write;
d1160 1
a1160 1
		type = hw_read;
d1162 1
a1162 1
		type = hw_access;
d1172 1
a1172 1
	warning ("Could not remove hardware watchpoint %d.",
d1203 1
a1203 1
	  warning ("Internal error, %s line %d.", __FILE__, __LINE__);
d1248 2
a1249 2
/* Clear the "inserted" flag in all breakpoints and delete any
   breakpoints which should go away between runs of the program.
d1254 2
a1255 3
   Note: this function gets called at the end of a run (by
   generic_mourn_inferior) and when a run begins (by
   init_wait_for_inferior). */
d1311 1
a1311 2
      warning ("Exception catchpoints from last run were deleted.");
      warning ("You must reinsert them explicitly.");
d1316 3
a1318 3
/* breakpoint_here_p (PC) returns 1 if an enabled breakpoint exists at
   PC.  When continuing from a location with a breakpoint, we actually
   single step once before calling insert_breakpoints.  */
d1343 2
a1344 3
/* breakpoint_inserted_here_p (PC) is just like breakpoint_here_p(),
   but it only returns true if there is actually a breakpoint inserted
   at PC.  */
d1367 4
a1370 5
/* Return nonzero if FRAME is a dummy frame.  We can't use
   PC_IN_CALL_DUMMY because figuring out the saved SP would take too
   much time, at least using get_saved_register on the 68k.  This
   means that for this function to work right a port must use the
   bp_call_dummy breakpoint.  */
d1740 1
a1740 2
      printf_filtered (" process %d), ", 
		       bs->breakpoint_at->forked_inferior_pid);
d1753 1
a1753 2
      if (current_exception_event && 
	  (CURRENT_EXCEPTION_KIND == EX_EVENT_CATCH))
d1756 1
a1756 2
	  printf_filtered ("\nCatchpoint %d (exception caught), ", 
			   bs->breakpoint_at->number);
d1774 1
a1774 1
	  return 1;	/* don't bother to print location frame info */
d1778 1
a1778 1
	  return -1;	/* really throw, some other bpstat will handle it */
d1783 1
a1783 2
      if (current_exception_event && 
	  (CURRENT_EXCEPTION_KIND == EX_EVENT_THROW))
d1786 1
a1786 2
	  printf_filtered ("\nCatchpoint %d (exception thrown), ",
			   bs->breakpoint_at->number);
d1804 1
a1804 1
	  return 1;	/* don't bother to print location frame info */
d1808 1
a1808 1
	  return -1;	/* really catch, some other bpstat willhandle it */
d1849 1
a1849 2
  /* We can't deal with it.  
     Maybe another member of the bpstat chain can.  */
d1886 2
a1887 2
     (Currently all watchpoints go on the bpstat whether hit or not.
     That probably could (should) be changed, provided care is taken
d2134 1
a2134 3
		&& (strcmp (b->dll_pathname, 
			    SOLIB_LOADED_LIBRARY_PATHNAME (inferior_pid)) 
		    != 0)))
d2143 1
a2143 3
		&& (strcmp (b->dll_pathname, 
			    SOLIB_UNLOADED_LIBRARY_PATHNAME (inferior_pid)) 
		    != 0)))
d2173 1
a2173 2
    if (b->type == bp_watchpoint ||
	b->type == bp_hardware_watchpoint)
d2175 1
a2175 2
	switch (catch_errors (watchpoint_check, bs, message, 
			      RETURN_MASK_ALL))
d2209 1
a2209 2
    else if (b->type == bp_read_watchpoint || 
	     b->type == bp_access_watchpoint)
d2225 1
a2225 4
		/* Exact match not required.  Within range is sufficient.  
		 */
		if (addr >= vaddr &&
		    addr < vaddr + TYPE_LENGTH (VALUE_TYPE (v)))
d2230 1
a2230 2
	  switch (catch_errors (watchpoint_check, bs, message,
				RETURN_MASK_ALL))
a2253 10
	else	/* found == 0 */
	  {
	    /* This is a case where some watchpoint(s) triggered,
	       but not at the address of this watchpoint (FOUND
	       was left zero).  So don't print anything for this
	       watchpoint.  */
	    bs->print_it = print_it_noop;
	    bs->stop = 0;
            continue;
	  }
d2430 2
a2431 2
     reference to how we stopped.  We retain separate wp_silent and
     bp_silent codes in case we want to change that someday. 
d2551 2
a2552 2
	    /* There was a watchpoint, but we're not stopping. 
	       This requires no further action.  */
d2600 2
a2601 2
	    /* There was a catchpoint, but we're not stopping.  
	       This requires no further action.  */
d2617 2
a2618 2
	  /* Make sure the action is stop (silent or noisy),
	     so infrun.c pops the dummy frame.  */
d2684 1
a2684 2
	  (ep->type != bp_catch_throw))		
	/* pai: (temp) ADD fork/vfork here!!  */
d2710 1
a2710 2
	  ep->triggered_dll_pathname = (char *) 
	    xmalloc (strlen (dll_pathname) + 1);
a2773 1

d3066 1
a3066 3
	       ((b->enable == disabled || 
		 b->enable == shlib_disabled || 
		 b->enable == call_disabled)
d3193 1
a3193 2
      m = lookup_minimal_symbol_text (func_name, NULL, 
				      (struct objfile *) NULL);
d3215 2
a3216 2
/* Call this routine when stepping and nexting to enable a breakpoint
   if we do a longjmp().  When we hit that breakpoint, call
d3297 1
a3297 1
		warning ("Temporarily disabling shared library breakpoints:");
d3300 1
a3300 1
	    warning ("breakpoint #%d ", b->number);
d3305 2
d3330 1
a3330 1
solib_load_unload_1 (hookname, tempflag, dll_pathname, cond_string, bp_kind)
d3361 1
a3361 1
      warning ("Unable to set unique breakpoint on dynamic linker callback.");
d3366 2
a3367 2
  /* Make sure that all storage allocated in decode_line_1 gets freed
     in case the following errors out.  */
d3387 1
a3387 2
  b->cond_string = (cond_string == NULL) ? 
    NULL : savestring (cond_string, strlen (cond_string));
d3412 1
a3412 2
create_solib_load_event_breakpoint (hookname, tempflag, 
				    dll_pathname, cond_string)
d3418 5
a3422 2
  solib_load_unload_1 (hookname, tempflag, dll_pathname, 
		       cond_string, bp_catch_load);
d3426 1
a3426 2
create_solib_unload_event_breakpoint (hookname, tempflag, 
				      dll_pathname, cond_string)
d3432 5
a3436 2
  solib_load_unload_1 (hookname,tempflag, dll_pathname, 
		       cond_string, bp_catch_unload);
d3458 1
a3458 2
  b->cond_string = (cond_string == NULL) ? 
    NULL : savestring (cond_string, strlen (cond_string));
d3504 1
a3504 2
  b->cond_string = (cond_string == NULL) ?
    NULL : savestring (cond_string, strlen (cond_string));
d3555 2
a3556 2
/* Call this after hitting the longjmp() breakpoint.  Use this to set
   a new breakpoint at the target of the jmp_buf.
d3558 2
a3559 2
   FIXME - This ought to be done by setting a temporary breakpoint
   that gets deleted automatically... */
d3684 1
a3684 2
      printf_filtered ("Hardware access (read/write) watchpoint %d: ", 
		       b->number);
d3700 1
a3700 2
		       (b->dll_pathname != NULL) ? 
		       b->dll_pathname : "<any library>");
d3824 2
a3825 2
  /* Make sure that all storage allocated in decode_line_1 gets freed
     in case the following `for' loop errors out.  */
d3864 1
a3864 2
	  error ("Cannot break on %s without a running program.", 
		 addr_start);
d3908 2
a3909 3
      target_resources_ok = 
	TARGET_CAN_USE_HARDWARE_WATCHPOINT (bp_hardware_breakpoint, 
					    i + sals.nelts, 0);
d3951 2
a3952 2
      warning ("Multiple breakpoints were set.");
      warning ("Use the \"delete\" command to delete unwanted breakpoints.");
d4117 2
a4118 2
      warning ("Multiple breakpoints were set.\n");
      warning ("Use the \"delete\" command to delete unwanted breakpoints.");
d4254 3
a4256 3
      /* look for a ':'.  If this is a line number specification, then
         say it is bad, otherwise, it should be an address or
         function/method name */
d4310 1
a4310 3
/* accessflag:  hw_write:  watch write, 
                hw_read:   watch read, 
		hw_access: watch access (read or write) */
d4367 1
a4367 1
  if (accessflag == hw_read)
d4369 1
a4369 1
  else if (accessflag == hw_access)
d4380 2
a4381 3
      target_resources_ok = 
	TARGET_CAN_USE_HARDWARE_WATCHPOINT (bp_type, i + mem_cnt, 
					    other_type_used);
d4383 1
a4383 2
	error ("Target does not support this type of hardware watchpoint.");

d4385 1
a4385 1
	error ("Target can only support one kind of HW watchpoint at a time.");
d4483 2
a4484 7
#define TARGET_REGION_SIZE_OK_FOR_HW_WATCHPOINT(BYTE_SIZE) \
    ((BYTE_SIZE) <= (REGISTER_SIZE))
#endif

#if !defined(TARGET_REGION_OK_FOR_HW_WATCHPOINT)
#define TARGET_REGION_OK_FOR_HW_WATCHPOINT(ADDR,LEN) \
     TARGET_REGION_SIZE_OK_FOR_HW_WATCHPOINT(LEN)
d4505 1
a4505 6
	  CORE_ADDR vaddr = VALUE_ADDRESS (v) + VALUE_OFFSET (v);
	  int       len   = TYPE_LENGTH (VALUE_TYPE (v));

	  if (!TARGET_REGION_OK_FOR_HW_WATCHPOINT (vaddr, len))
	    return 0;
	  else
d4509 1
a4509 3
	return 0;	/* ??? What does this represent? */
      else if (v->lval == lval_register)
	return 0;	/* cannot watch a register with a HW watchpoint */
d4522 1
a4522 1
  watch_command_1 (arg, hw_write, from_tty);
d4530 1
a4530 1
  watch_command_1 (arg, hw_read, from_tty);
d4538 1
a4538 1
  watch_command_1 (arg, hw_access, from_tty);
d4581 1
a4581 2
    sals = decode_line_1 (&arg, 1, (struct symtab *) NULL, 
			  0, (char ***) NULL);
d4597 1
a4597 2
    old_chain = make_cleanup ((make_cleanup_func) delete_breakpoint, 
			      breakpoint);
d4809 1
a4809 2
		      next->sal = find_pc_line (SYMBOL_VALUE_ADDRESS (sym), 
						0);
a4862 1

a4895 1

d4965 1
a4965 4
static void catch_fork_command_1 PARAMS ((catch_fork_kind fork_kind, 
					  char *arg, 
					  int tempflag, 
					  int from_tty));
d5071 1
a5071 2
  SOLIB_CREATE_CATCH_LOAD_HOOK (inferior_pid, tempflag, 
				dll_pathname, cond_string);
d5115 1
a5115 2
  SOLIB_CREATE_CATCH_UNLOAD_HOOK (inferior_pid, tempflag, 
				  dll_pathname, cond_string);
d5142 1
a5142 2
  b->cond_string = (cond_string == NULL) ? 
    NULL : savestring (cond_string, strlen (cond_string));
d5196 1
a5196 1
	return;		/* something went wrong with setting up callbacks */
d5210 3
a5212 3
	  warning ("Unsupported with this platform/compiler combination.");
	  warning ("Perhaps you can achieve the effect you want by setting");
	  warning ("a breakpoint on __raise_exception().");
d5322 6
a5327 7

      /* Important -- this is an ordinary breakpoint.  For platforms
	 with callback support for exceptions,
	 create_exception_catchpoint() will create special bp types
	 (bp_catch_catch and bp_catch_throw), and there is code in
	 insert_breakpoints() and elsewhere that depends on that. */
      b->type = bp_breakpoint;	
d5338 2
a5339 2
      warning ("Multiple breakpoints were set.");
      warning ("Use the \"delete\" command to delete unwanted breakpoints.");
d5410 1
a5410 2
      catch_exception_command_1 (EX_EVENT_CATCH, arg1_end + 1, 
				 tempflag, from_tty);
d5414 1
a5414 2
      catch_exception_command_1 (EX_EVENT_THROW, arg1_end + 1, 
				 tempflag, from_tty);
d5713 1
a5713 2
/* Delete a breakpoint and clean up all traces of it in the data
   structures. */
d5763 2
a5764 4
      /* Format possible error msg */
      sprintf (message, message1, bpt->number);
      args.kind = bpt->type == bp_catch_catch ? 
	EX_EVENT_CATCH : EX_EVENT_THROW;
d5818 1
a5818 6

	  if (b->type == bp_hardware_breakpoint)
	    val = target_insert_hw_breakpoint (b->address, b->shadow_contents);
	  else
	    val = target_insert_breakpoint (b->address, b->shadow_contents);

d5822 1
a5822 1
	      warning ("Cannot insert breakpoint %d:", b->number);
d5922 1
a5922 2
  /* get past catch_errs */
  struct breakpoint *b = (struct breakpoint *) bint;
d5932 1
a5932 2
      warning ("attempted to reset apparently deleted breakpoint #%d?",
	       b->number);
d6019 7
a6025 8
      /* The issue arises of what context to evaluate this in.  The
         same one as when it was set, but what does that mean when
         symbols have been re-read?  We could save the filename and
         functionname, but if the context is more local than that, the
         best we could do would be something like how many levels deep
         and which index at that particular level, but that's going to
         be less stable than filenames or function names.  */

d6104 1
a6104 2
    /* Format possible error msg */
    sprintf (message, message1, b->number);
d6278 1
a6278 2
	warning ("attempted to disable apparently deleted breakpoint #%d?",
		 bpt->number);
d6315 2
a6316 3
      target_resources_ok = 
	TARGET_CAN_USE_HARDWARE_WATCHPOINT (bp_hardware_breakpoint, 
					    i + 1, 0);
d6328 2
a6329 4
  if (bpt->type == bp_watchpoint || 
      bpt->type == bp_hardware_watchpoint ||
      bpt->type == bp_read_watchpoint || 
      bpt->type == bp_access_watchpoint)
d6386 1
a6386 2
	select_and_print_frame (save_selected_frame,
				save_selected_frame_level);
d6416 1
a6416 2
	warning ("attempted to enable apparently deleted breakpoint #%d?",
		 bpt->number);
d6483 1
a6483 2
			  default_breakpoint_symtab,
			  default_breakpoint_line,
d6800 1
@


1.1.1.9
log
@import gdb-1999-08-30 snapshot
@
text
@a42 2
#include "gdb-events.h"

a3349 3
/* Disable any breakpoints that are on code in shared libraries.  Only
   apply to enabled breakpoints, disabled ones can just stay disabled.  */

d3363 2
a3364 1
	b->enable == enabled &&
a3738 1
  breakpoint_create_event (b->number);
a5852 1
  breakpoint_delete_event (bpt->number);
a6383 1
  breakpoint_modify_event (bpt->number);
a6515 1
  breakpoint_modify_event (bpt->number);
@


1.1.1.10
log
@import gdb-1999-09-08 snapshot
@
text
@d3418 1
d3421 1
d4104 1
a4104 1
	    sprintf (addr_string, "*0x%s %s", paddr_nz (high), extra_args);
d4106 1
a4106 1
	    sprintf (addr_string, "*0x%s", paddr_nz (high));
d4141 1
a4141 1
	      sprintf (addr_string, "*0x%s", paddr_nz (selected_frame->pc));
d4189 1
a4189 1
	    sprintf (break_string, "*0x%s %s", paddr_nz (high), extra_args);
d4191 1
a4191 1
	    sprintf (break_string, "*0x%s", paddr_nz (high));
d4669 1
d5241 1
@


1.1.1.11
log
@import gdb-1999-09-21
@
text
@a46 2
static void until_break_command_continuation (struct continuation_arg *arg);

d255 2
d674 1
a674 4
    if (b->enable == permanent)
      /* Permanent breakpoints cannot be inserted or removed.  */
      continue;
    else if (b->type != bp_watchpoint
a1133 4
  if (b->enable == permanent)
    /* Permanent breakpoints cannot be inserted or removed.  */
    return 0;

d1147 1
d1360 3
a1362 9
/* breakpoint_here_p (PC) returns non-zero if an enabled breakpoint
   exists at PC.  It returns ordinary_breakpoint_here if it's an
   ordinary breakpoint, or permanent_breakpoint_here if it's a
   permanent breakpoint.
   - When continuing from a location with an ordinary breakpoint, we
     actually single step once before calling insert_breakpoints.
   - When continuing from a localion with a permanent breakpoint, we
     need to use the `SKIP_PERMANENT_BREAKPOINT' macro, provided by
     the target, to advance the PC past the breakpoint.  */
d1364 1
a1364 1
enum breakpoint_here
a1368 1
  int any_breakpoint_here = 0;
d1371 3
a1373 2
    if ((b->enable == enabled
	 || b->enable == permanent)
d1375 8
a1382 10
      {
	if (overlay_debugging &&
	    section_is_overlay (b->section) &&
	    !section_is_mapped (b->section))
	  continue;		/* unmapped overlay -- can't be a match */
	else if (b->enable == permanent)
	  return permanent_breakpoint_here;
	else
	  any_breakpoint_here = 1;
      }
d1384 1
a1384 1
  return any_breakpoint_here ? ordinary_breakpoint_here : 0;
a1386 1

d2845 1
a2845 1
  static char bpenables[] = "nynny";
d3144 2
a3145 3
		 b->enable == call_disabled) ? " (disabled)" 
		: b->enable == permanent ? " (permanent)"
		: ""),
d3172 1
a3172 3
   This is so that the bpt instruction is only inserted once.
   If we have a permanent breakpoint at ADDRESS, make that one
   the official one, and the rest as duplicates.  */
a3180 1
  struct breakpoint *perm_bp = 0;
a3191 7
      /* Have we found a permanent breakpoint?  */
      if (b->enable == permanent)
	{
	  perm_bp = b;
	  break;
	}
	
a3194 28

  /* If we found a permanent breakpoint at this address, go over the
     list again and declare all the other breakpoints there to be the
     duplicates.  */
  if (perm_bp)
    {
      perm_bp->duplicate = 0;

      /* Permanent breakpoint should always be inserted.  */
      if (! perm_bp->inserted)
	internal_error ("allegedly permanent breakpoint is not "
			"actually inserted");

      ALL_BREAKPOINTS (b)
	if (b != perm_bp)
	  {
	    if (b->inserted)
	      internal_error ("another breakpoint was inserted on top of "
			      "a permanent breakpoint");

	    if (b->enable != disabled
		&& b->enable != shlib_disabled
		&& b->enable != call_disabled
		&& b->address == address
		&& (overlay_debugging == 0 || b->section == section))
	      b->duplicate = 1;
	  }
    }
a3256 12

/* Note that the breakpoint object B describes a permanent breakpoint
   instruction, hard-wired into the inferior's code.  */
void
make_breakpoint_permanent (struct breakpoint *b)
{
  b->enable = permanent;

  /* By definition, permanent breakpoints are already present in the code.  */
  b->inserted = 1;
}

d3336 1
a3336 1
struct breakpoint *
a3349 2

  return b;
d4646 3
a4648 2
static void
until_break_command_continuation (struct continuation_arg *arg)
a5931 8
	  /* We should never reach this point if there is a permanent
	     breakpoint at the same address as the one being deleted.
	     If there is a permanent breakpoint somewhere, it should
	     always be the only one inserted.  */
	  if (b->enable == permanent)
	    internal_error ("another breakpoint was inserted on top of "
			    "a permanent breakpoint");

a6379 4
  /* You can't disable permanent breakpoints.  */
  if (bpt->enable == permanent)
    return;

d6448 1
a6448 2
  if (bpt->enable != permanent)
    bpt->enable = enabled;
@


1.1.1.12
log
@import gdb-1999-09-28 snapshot
@
text
@d2158 1
a2158 2
  bp_addr = *pc - (not_a_breakpoint && !SOFTWARE_SINGLE_STEP_P ? 
                   0 : DECR_PC_AFTER_BREAK);
d2187 7
d4760 1
a4760 1
  if (!event_loop_p || !target_can_async_p ())
d4773 1
a4773 1
  if (event_loop_p && target_can_async_p ())
d4789 1
a4789 1
      if (!event_loop_p || !target_can_async_p ())
d4798 1
a4798 1
  if (!event_loop_p || !target_can_async_p ())
@


1.1.1.13
log
@import gdb-1999-10-04 snapshot
@
text
@d858 1
a858 2
		    CORE_ADDR addr;
		    int len, type;
d1202 1
a1202 2
	      CORE_ADDR addr;
	      int len, type;
d2823 1
a2823 1
  CORE_ADDR last_addr = (CORE_ADDR) -1;
d3090 1
a3090 1
  if (last_addr != (CORE_ADDR) -1)
@


1.1.1.14
log
@import gdb-1999-10-18 snapshot
@
text
@d160 1
a160 1
static enum print_stop_action print_it_normal PARAMS ((bpstat));
d173 1
a173 1
static enum print_stop_action print_it_done PARAMS ((bpstat));
d175 1
a175 1
static enum print_stop_action print_it_noop PARAMS ((bpstat));
d1755 1
a1755 3
   PRINT_NOTHING: Means we already printed all we needed to print, don't 
   print anything else.
   PRINT_SRC_ONLY: Means we printed something, and we do *not* desire that
d1757 1
a1757 1
   PRINT_SCR_AND_LOC: Means we printed something, and we *do*  desire that
d1759 1
a1759 1
   PRINT_UNKNOWN: Means we printed nothing or we need to do some more analysis.  */
d1761 1
a1761 1
static enum print_stop_action
a1768 1
	  && bs->breakpoint_at->type != bp_shlib_event
d1781 1
a1781 1
    return PRINT_UNKNOWN;
d1792 1
a1792 9
      return PRINT_SRC_AND_LOC;
    }
  else if (bs->breakpoint_at->type == bp_shlib_event)
    {
      /* Did we stop because the user set the stop_on_solib_events
	 variable?  (If so, we report this as a generic, "Stopped due
	 to shlib event" message.) */
       printf_filtered ("Stopped due to shared library event\n");
       return PRINT_NOTHING;
d1805 1
a1805 1
      return PRINT_SRC_AND_LOC;
d1813 1
a1813 1
      return PRINT_SRC_AND_LOC;
d1840 1
a1840 1
	  return PRINT_SRC_ONLY;  /* don't bother to print location frame info */
d1844 1
a1844 1
	  return PRINT_UNKNOWN;	/* really throw, some other bpstat will handle it */
d1872 1
a1872 1
	  return PRINT_SRC_ONLY; /* don't bother to print location frame info */
d1876 1
a1876 1
	  return PRINT_UNKNOWN;	/* really catch, some other bpstat willhandle it */
d1887 1
a1887 1
      return PRINT_SRC_AND_LOC;
d1905 1
a1905 1
      return PRINT_UNKNOWN;
d1915 1
a1915 1
      return PRINT_UNKNOWN;
d1919 1
a1919 1
  return PRINT_UNKNOWN;
d1931 2
a1932 2
   PRINT_UNKNOWN: Means we printed nothing
   PRINT_SRC_AND_LOC: Means we printed something, and expect subsequent
d1936 1
a1936 1
   PRINT_SRC_ONLY: Means we printed something, but there is no need
d1939 1
a1939 3
   don't require a location appended to the end.  
   PRINT_NOTHING: We have done some printing and we don't need any 
   further info to be printed.*/
d1941 1
a1941 1
enum print_stop_action
d1948 1
a1948 1
    return PRINT_UNKNOWN;
d1951 1
a1951 1
  if (val == PRINT_SRC_ONLY || val == PRINT_SRC_AND_LOC || val == PRINT_NOTHING)
d1962 1
a1962 1
  return PRINT_UNKNOWN;
d2099 1
a2099 1
static enum print_stop_action
d2103 1
a2103 1
  return PRINT_SRC_AND_LOC;
d2115 1
a2115 1
static enum print_stop_action
d2119 1
a2119 1
  return PRINT_UNKNOWN;
@


1.1.1.15
log
@import gdb-1999-10-25 snapshot
@
text
@d160 1
a160 3
static enum print_stop_action print_it_typical PARAMS ((bpstat));

static enum print_stop_action print_bp_stop_message (bpstat bs);
d173 4
a228 1
#if defined(CHILD_INSERT_EXEC_CATCHPOINT)
a230 1
#endif
d1743 1
a1743 1
/* This is the normal print function for a bpstat.  In the future,
d1745 1
a1745 1
   by having it set different print_it values.
d1747 15
a1761 16
   Current scheme: When we stop, bpstat_print() is called.  It loops
   through the bpstat list of things causing this stop, calling the
   print_bp_stop_message function on each one. The behavior of the
   print_bp_stop_message function depends on the print_it field of
   bpstat. If such field so indicates, call this function here.

   Return values from this routine (ultimately used by bpstat_print()
   and normal_stop() to decide what to do): 
   PRINT_NOTHING: Means we already printed all we needed to print,
   don't print anything else.
   PRINT_SRC_ONLY: Means we printed something, and we do *not* desire
   that something to be followed by a location.
   PRINT_SCR_AND_LOC: Means we printed something, and we *do* desire
   that something to be followed by a location.
   PRINT_UNKNOWN: Means we printed nothing or we need to do some more
   analysis.  */
d1764 1
a1764 1
print_it_typical (bs)
d1769 15
a1783 1
  if (bs->breakpoint_at == NULL)
d1786 1
a1786 1
  switch (bs->breakpoint_at->type)
d1788 7
a1794 6
    case bp_breakpoint:
    case bp_hardware_breakpoint:
      /* I think the user probably only wants to see one breakpoint
         number, not all of them.  */
      annotate_breakpoint (bs->breakpoint_at->number);
      printf_filtered ("\nBreakpoint %d, ", bs->breakpoint_at->number);
d1796 3
a1798 3
      break;

    case bp_shlib_event:
d1802 6
a1807 5
      printf_filtered ("Stopped due to shared library event\n");
      return PRINT_NOTHING;
      break;

    case bp_catch_load:
d1810 4
a1813 17
      printf_filtered ("loaded");
      printf_filtered (" %s), ", bs->breakpoint_at->triggered_dll_pathname);
      return PRINT_SRC_AND_LOC;
      break;

    case bp_catch_unload:
      annotate_catchpoint (bs->breakpoint_at->number);
      printf_filtered ("\nCatchpoint %d (", bs->breakpoint_at->number);
      printf_filtered ("unloaded");
      printf_filtered (" %s), ", bs->breakpoint_at->triggered_dll_pathname);
      return PRINT_SRC_AND_LOC;
      break;

    case bp_catch_fork:
      annotate_catchpoint (bs->breakpoint_at->number);
      printf_filtered ("\nCatchpoint %d (", bs->breakpoint_at->number);
      printf_filtered ("forked");
d1817 3
a1819 12
      break;

    case bp_catch_vfork:
      annotate_catchpoint (bs->breakpoint_at->number);
      printf_filtered ("\nCatchpoint %d (", bs->breakpoint_at->number);
      printf_filtered ("vforked");
      printf_filtered (" process %d), ", 
		       bs->breakpoint_at->forked_inferior_pid);
      return PRINT_SRC_AND_LOC;
      break;

    case bp_catch_exec:
d1825 3
a1827 3
      break;

    case bp_catch_catch:
d1851 1
a1851 2
	  /* don't bother to print location frame info */
	  return PRINT_SRC_ONLY;
d1855 1
a1855 2
	  /* really throw, some other bpstat will handle it */
	  return PRINT_UNKNOWN;	
d1857 3
a1859 3
      break;

    case bp_catch_throw:
d1883 1
a1883 2
	  /* don't bother to print location frame info */
	  return PRINT_SRC_ONLY; 
d1887 1
a1887 2
	  /* really catch, some other bpstat will handle it */
	  return PRINT_UNKNOWN;	
d1889 1
a1889 1
      break;
d1891 15
a1905 20
    case bp_watchpoint:
    case bp_hardware_watchpoint:
      if (bs->old_val != NULL)
	{
	  annotate_watchpoint (bs->breakpoint_at->number);
	  mention (bs->breakpoint_at);
	  printf_filtered ("\nOld value = ");
	  value_print (bs->old_val, gdb_stdout, 0, Val_pretty_default);
	  printf_filtered ("\nNew value = ");
	  value_print (bs->breakpoint_at->val, gdb_stdout, 0,
		       Val_pretty_default);
	  printf_filtered ("\n");
	  value_free (bs->old_val);
	  bs->old_val = NULL;
	}
      /* More than one watchpoint may have been triggered.  */
      return PRINT_UNKNOWN;
      break;

    case bp_read_watchpoint:
d1907 3
a1909 1
      printf_filtered ("\nValue = ");
d1913 3
d1917 6
a1922 18
      break;

    case bp_access_watchpoint:
      if (bs->old_val != NULL)     
	{
	  annotate_watchpoint (bs->breakpoint_at->number);
	  mention (bs->breakpoint_at);
	  printf_filtered ("\nOld value = ");
	  value_print (bs->old_val, gdb_stdout, 0, Val_pretty_default);
	  value_free (bs->old_val);
	  bs->old_val = NULL;
	  printf_filtered ("\nNew value = ");
	}
      else 
	{
	  mention (bs->breakpoint_at);
	  printf_filtered ("\nValue = ");
	}
a1926 47
      break;
    /* Fall through, we don't deal with these types of breakpoints
       here. */

    case bp_none:
    case bp_until:
    case bp_finish:
    case bp_longjmp:
    case bp_longjmp_resume:
    case bp_step_resume:
    case bp_through_sigtramp:
    case bp_watchpoint_scope:
    case bp_call_dummy:
    default:
      return PRINT_UNKNOWN;
    }
}

/* Generic routine for printing messages indicating why we
   stopped. The behavior of this function depends on the value
   'print_it' in the bpstat structure.  Under some circumstances we
   may decide not to print anything here and delegate the task to
   normal_stop(). */

static enum print_stop_action
print_bp_stop_message (bpstat bs)
{
  switch (bs->print_it)
    {
    case print_it_noop:
      /* Nothing should be printed for this bpstat entry. */
      return PRINT_UNKNOWN;
      break;

    case print_it_done:
      /* We still want to print the frame, but we already printed the
         relevant messages. */
      return PRINT_SRC_AND_LOC;
      break;

    case print_it_normal:
      /* Normal case, we handle everything in print_it_typical. */
      return print_it_typical (bs);
      break;
    default:
      internal_error ("print_bp_stop_message: unrecognized enum value");
      break;
d1928 3
d1933 8
a1940 8

/* Print a message indicating what happened.  This is called from
   normal_stop().  The input to this routine is the head of the bpstat
   list - a list of the eventpoints that caused this stop.  This
   routine calls the generic print routine for printing a message
   about reasons for stopping.  This will print (for example) the
   "Breakpoint n," part of the output.  The return value of this
   routine is one of:
d1960 7
d1971 2
a1972 8
  for (; bs; bs = bs->next)
    {
      val = print_bp_stop_message (bs);
      if (val == PRINT_SRC_ONLY 
	  || val == PRINT_SRC_AND_LOC 
	  || val == PRINT_NOTHING)
	return val;
    }
d1974 1
a1974 2
  /* We reached the end of the chain, or we got a null BS to start
     with and nothing was printed. */
d2101 34
a5141 1
#if defined(CHILD_INSERT_FORK_CATCHPOINT) || defined(CHILD_INSERT_VFORK_CATCHPOINT)
a5182 1
#endif
a5183 1
#if defined(CHILD_INSERT_EXEC_CATCHPOINT)
a5207 1
#endif
@


1.1.1.16
log
@import gdb-1999-11-01 snapshot
@
text
@d140 1
a140 1
get_number_trailer PARAMS ((char **, int));
d274 1
a274 1
#define ALL_BREAKPOINTS(B)  for (B = breakpoint_chain; B; B = B->next)
d276 4
a279 4
#define ALL_BREAKPOINTS_SAFE(B,TMP)	\
	for (B = breakpoint_chain;	\
	     B ? (TMP=B->next, 1): 0;	\
	     B = TMP)
d406 1
a406 4
   for map_breakpoint_numbers (e.g. "4 + 5 + 6").
   
   TRAILER is a character which can be found after the number; most
   commonly this is `-'.  If you don't want a trailer, use \0.  */ 
d408 1
a408 1
get_number_trailer (pp, trailer)
a409 1
     int trailer;
d411 1
a411 1
  int retval = 0;	/* default */
d431 5
a435 7
      if (TYPE_CODE (VALUE_TYPE (val)) == TYPE_CODE_INT)
	retval = (int) value_as_long (val);
      else
	{
	  printf_filtered ("Convenience variable must have integer value.\n");
	  retval = 0;
	}
d445 2
a446 16
	{
	  /* Skip non-numeric token */
	  while (*p && !isspace((int) *p))
	    ++p;
	  /* Return zero, which caller must interpret as error. */
	  retval = 0;
	}
      else
	retval = atoi (*pp);
    }
  if (!(isspace (*p) || *p == '\0' || *p == trailer))
    {
      /* Trailing junk: return 0 and let caller print error msg. */
      while (!(isspace (*p) || *p == '\0' || *p == trailer))
	++p;
      retval = 0;
d448 2
a454 87

/* Like get_number_trailer, but don't allow a trailer.  */
int
get_number (pp)
     char **pp;
{
  return get_number_trailer (pp, '\0');
}

/* Parse a number or a range.
 * A number will be of the form handled by get_number.
 * A range will be of the form <number1> - <number2>, and 
 * will represent all the integers between number1 and number2,
 * inclusive.
 *
 * While processing a range, this fuction is called iteratively;
 * At each call it will return the next value in the range.
 *
 * At the beginning of parsing a range, the char pointer PP will
 * be advanced past <number1> and left pointing at the '-' token.
 * Subsequent calls will not advance the pointer until the range
 * is completed.  The call that completes the range will advance
 * pointer PP past <number2>.
 */

int 
get_number_or_range (pp)
     char **pp;
{
  static int last_retval, end_value;
  static char *end_ptr;
  static int in_range = 0;

  if (**pp != '-')
    {
      /* Default case: pp is pointing either to a solo number, 
	 or to the first number of a range.  */
      last_retval = get_number_trailer (pp, '-');
      if (**pp == '-')
	{
	  char **temp;

	  /* This is the start of a range (<number1> - <number2>).
	     Skip the '-', parse and remember the second number,
	     and also remember the end of the final token.  */

	  temp = &end_ptr; 
	  end_ptr = *pp + 1; 
	  while (isspace ((int) *end_ptr))
	    end_ptr++;	/* skip white space */
	  end_value = get_number (temp);
	  if (end_value < last_retval) 
	    {
	      error ("inverted range");
	    }
	  else if (end_value == last_retval)
	    {
	      /* degenerate range (number1 == number2).  Advance the
		 token pointer so that the range will be treated as a
		 single number.  */ 
	      *pp = end_ptr;
	    }
	  else
	    in_range = 1;
	}
    }
  else if (! in_range)
    error ("negative value");
  else
    {
      /* pp points to the '-' that betokens a range.  All
	 number-parsing has already been done.  Return the next
	 integer value (one greater than the saved previous value).
	 Do not advance the token pointer 'pp' until the end of range
	 is reached.  */

      if (++last_retval == end_value)
	{
	  /* End of range reached; advance token pointer.  */
	  *pp = end_ptr;
	  in_range = 0;
	}
    }
  return last_retval;
}


a471 2
  if (bnum == 0)
    error ("Bad breakpoint argument: '%s'", arg);
a527 3
  if (bnum == 0)
    error ("bad breakpoint number: '%s'", arg);

d845 1
a845 5
	       produced off from the value chain.

	       Make sure the value returned isn't lazy; we use
	       laziness to determine what memory GDB actually needed
	       in order to compute the value of the expression.  */
a846 1
	    VALUE_CONTENTS(v);
d855 2
a856 5
		/* If it's a memory location, and GDB actually needed
                   its contents to evaluate the expression, then we
                   must watch it.  */
		if (VALUE_LVAL (v) == lval_memory
		    && ! VALUE_LAZY (v))
d1201 1
a1201 2
	  if (VALUE_LVAL (v) == lval_memory
	      && ! VALUE_LAZY (v))
d2336 1
a2336 2
	    if (VALUE_LVAL (v) == lval_memory
		&& ! VALUE_LAZY (v))
a2422 1
	    annotate_ignore_count_change ();
d4697 4
a4700 19
  /* Make sure that the value of the expression depends only upon
     memory contents, and values computed from them within GDB.  If we
     find any register references or function calls, we can't use a
     hardware watchpoint.

     The idea here is that evaluating an expression generates a series
     of values, one holding the value of every subexpression.  (The
     expression a*b+c has five subexpressions: a, b, a*b, c, and
     a*b+c.)  GDB's values hold almost enough information to establish
     the criteria given above --- they identify memory lvalues,
     register lvalues, computed values, etcetera.  So we can evaluate
     the expression, and then scan the chain of values that leaves
     behind to decide whether we can detect any possible change to the
     expression's final value using only hardware watchpoints.

     However, I don't think that the values returned by inferior
     function calls are special in any way.  So this function may not
     notice that an expression involving an inferior function call
     can't be watched with hardware watchpoints.  FIXME.  */
d4703 1
a4703 1
      if (VALUE_LVAL (v) == lval_memory)
d4705 5
a4709 5
	  if (VALUE_LAZY (v))
	    /* A lazy memory lvalue is one that GDB never needed to fetch;
	       we either just used its address (e.g., `a' in `a.b') or
	       we never needed it at all (e.g., `a' in `a,b').  */
	    ;
d4711 1
a4711 11
	    {
	      /* Ahh, memory we actually used!  Check if we can cover
                 it with hardware watchpoints.  */
	      CORE_ADDR vaddr = VALUE_ADDRESS (v) + VALUE_OFFSET (v);
	      int       len   = TYPE_LENGTH (VALUE_TYPE (v));

	      if (!TARGET_REGION_OK_FOR_HW_WATCHPOINT (vaddr, len))
		return 0;
	      else
		found_memory_cnt++;
	    }
d6443 1
a6443 2
  if (num == 0)
    error ("bad breakpoint number: '%s'", args);
d6465 1
a6465 1
  register struct breakpoint *b, *tmp;
d6474 4
a6477 2
      num = get_number_or_range (&p1);
      if (num == 0)
d6479 5
a6483 15
	  warning ("bad breakpoint number at or near '%s'", p);
	}
      else
	{
	  ALL_BREAKPOINTS_SAFE (b, tmp)
	    if (b->number == num)
	      {
		struct breakpoint *related_breakpoint = b->related_breakpoint;
		function (b);
		if (related_breakpoint)
		  function (related_breakpoint);
		goto win;
	      }
	  printf_unfiltered ("No breakpoint number %d.\n", num);
	win:
d6485 2
@


1.1.1.17
log
@import gdb-1999-11-08 snapshot
@
text
@a473 1

d635 2
a2072 1
    case bp_finish:
d2075 1
d2119 1
a6612 1
  int match;
a6618 1
      match = 0;
a6631 1
		match = 1;
d6635 1
a6635 1
		break;
d6637 2
a6638 2
	  if (match == 0)
	    printf_unfiltered ("No breakpoint number %d.\n", num);
@


1.1.1.18
log
@import gdb-1999-11-16 snapshot
@
text
@a2068 1

a2273 4
      /* We print all the stop information in print_it_typical(), but
	 in this case, by the time we call print_it_typical() this bp
	 will be deleted already. So we have no choice but print the
	 information here. */
a2276 1

a2410 3
	    /* Actually this is superfluous, because by the time we
               call print_it_typical() the wp will be already deleted,
               and the function will return immediately. */
@


1.1.1.19
log
@import gdb-1999-12-06 snapshot
@
text
@d2074 1
a2075 1
    case bp_none:
d2431 2
@


1.1.1.20
log
@import gdb-1999-12-13 snapshot
@
text
@d263 1
d265 1
a1130 7
    /* Thread event breakpoints must be set anew after an exec().  */
    if (b->type == bp_thread_event)
      {
	delete_breakpoint (b);
	continue;
      }

a1909 7
    case bp_thread_event:
      /* Not sure how we will get here. 
	 GDB should not stop for these breakpoints.  */
      printf_filtered ("Thread Event Breakpoint: gdb should not stop!\n");
      return PRINT_NOTHING;
      break;

a2834 3
	case bp_thread_event:
	  bs_class = bp_nostop;
	  break;
d2978 11
a2988 1
/* Print B to gdb_stdout. */
d2990 3
a2992 2
print_one_breakpoint (struct breakpoint *b,
		      CORE_ADDR *last_addr)
d2994 1
d2997 3
a2999 6
  struct ep_type_description
    {
      enum bptype type;
      char *description;
    };
  static struct ep_type_description bptypes[] =
a3016 1
    {bp_thread_event, "thread events"},
d3025 1
a3025 1
  
a3030 1
  annotate_record ();
d3032 4
a3035 25
  /* 1 */
  annotate_field (0);
  printf_filtered ("%-3d ", b->number);

  /* 2 */
  annotate_field (1);
  if (((int) b->type > (sizeof (bptypes) / sizeof (bptypes[0])))
      || ((int) b->type != bptypes[(int) b->type].type))
    internal_error ("bptypes table does not describe type #%d.",
		    (int) b->type);
  printf_filtered ("%-14s ", bptypes[(int) b->type].description);

  /* 3 */
  annotate_field (2);
  printf_filtered ("%-4s ", bpdisps[(int) b->disposition]);

  /* 4 */
  annotate_field (3);
  printf_filtered ("%-3c ", bpenables[(int) b->enable]);
  
  /* 5 and 6 */
  strcpy (wrap_indent, "                           ");
  if (addressprint)
    strcat (wrap_indent, "           ");
  switch (b->type)
d3037 36
a3072 3
    case bp_none:
      internal_error ("print_one_breakpoint: bp_none encountered\n");
      break;
d3074 2
a3075 41
    case bp_watchpoint:
    case bp_hardware_watchpoint:
    case bp_read_watchpoint:
    case bp_access_watchpoint:
      /* Field 4, the address, is omitted (which makes the columns
	 not line up too nicely with the headers, but the effect
	 is relatively readable).  */
      annotate_field (5);
      print_expression (b->exp, gdb_stdout);
      break;
      
    case bp_catch_load:
    case bp_catch_unload:
      /* Field 4, the address, is omitted (which makes the columns
	 not line up too nicely with the headers, but the effect
	 is relatively readable).  */
      annotate_field (5);
      if (b->dll_pathname == NULL)
	printf_filtered ("<any library> ");
      else
	printf_filtered ("library \"%s\" ", b->dll_pathname);
      break;
      
    case bp_catch_fork:
    case bp_catch_vfork:
      /* Field 4, the address, is omitted (which makes the columns
	 not line up too nicely with the headers, but the effect
	 is relatively readable).  */
      annotate_field (5);
      if (b->forked_inferior_pid != 0)
	printf_filtered ("process %d ", b->forked_inferior_pid);
      break;
      
    case bp_catch_exec:
      /* Field 4, the address, is omitted (which makes the columns
	 not line up too nicely with the headers, but the effect
	 is relatively readable).  */
      annotate_field (5);
      if (b->exec_pathname != NULL)
	printf_filtered ("program \"%s\" ", b->exec_pathname);
      break;
d3077 13
a3089 7
    case bp_catch_catch:
      /* Field 4, the address, is omitted (which makes the columns
	 not line up too nicely with the headers, but the effect
	 is relatively readable).  */
      annotate_field (5);
      printf_filtered ("exception catch ");
      break;
d3091 1
a3091 20
    case bp_catch_throw:
      /* Field 4, the address, is omitted (which makes the columns
	 not line up too nicely with the headers, but the effect
	 is relatively readable).  */
      annotate_field (5);
      printf_filtered ("exception throw ");
      break;
      
    case bp_breakpoint:
    case bp_hardware_breakpoint:
    case bp_until:
    case bp_finish:
    case bp_longjmp:
    case bp_longjmp_resume:
    case bp_step_resume:
    case bp_through_sigtramp:
    case bp_watchpoint_scope:
    case bp_call_dummy:
    case bp_shlib_event:
    case bp_thread_event:
d3093 2
d3096 82
a3177 14
	  annotate_field (4);
	  /* FIXME-32x64: need a print_address_numeric with
	     field width */
	  printf_filtered
	    ("%s ",
	     local_hex_string_custom
	     ((unsigned long) b->address, "08l"));
	}
      annotate_field (5);
      *last_addr = b->address;
      if (b->source_file)
	{
	  sym = find_pc_sect_function (b->address, b->section);
	  if (sym)
d3179 10
a3188 4
	      fputs_filtered ("in ", gdb_stdout);
	      fputs_filtered (SYMBOL_SOURCE_NAME (sym), gdb_stdout);
	      wrap_here (wrap_indent);
	      fputs_filtered (" at ", gdb_stdout);
d3190 3
a3192 2
	  fputs_filtered (b->source_file, gdb_stdout);
	  printf_filtered (":%d", b->line_number);
d3194 4
a3197 17
      else
	print_address_symbolic (b->address, gdb_stdout, demangle, " ");
      break;
    }
  
  if (b->thread != -1)
    {
      printf_filtered (" thread %d", b->thread);
    }
  
  printf_filtered ("\n");
  
  if (b->frame)
    {
      annotate_field (6);
      printf_filtered ("\tstop only in stack frame at ");
      print_address_numeric (b->frame, 1, gdb_stdout);
d3199 20
a3218 37
    }
  
  if (b->cond)
    {
      annotate_field (7);
      printf_filtered ("\tstop only if ");
      print_expression (b->cond, gdb_stdout);
      printf_filtered ("\n");
    }
  
  if (b->thread != -1)
    {
      /* FIXME should make an annotation for this */
      printf_filtered ("\tstop only in thread %d\n", b->thread);
    }
  
  if (show_breakpoint_hit_counts && b->hit_count)
    {
      /* FIXME should make an annotation for this */
      if (ep_is_catchpoint (b))
	printf_filtered ("\tcatchpoint");
      else
	printf_filtered ("\tbreakpoint");
      printf_filtered (" already hit %d time%s\n",
		       b->hit_count, (b->hit_count == 1 ? "" : "s"));
    }
  
  if (b->ignore_count)
    {
      annotate_field (8);
      printf_filtered ("\tignore next %d hits\n", b->ignore_count);
    }
  
  if ((l = b->commands))
    {
      annotate_field (9);
      while (l)
d3220 2
a3221 2
	  print_command_line (l, 4, gdb_stdout);
	  l = l->next;
a3222 2
    }
}
d3224 10
a3233 4
struct captured_breakpoint_query_args
  {
    int bnum;
  };
d3235 1
a3235 9
static int
do_captured_breakpoint_query (void *data)
{
  struct captured_breakpoint_query_args *args = data;
  register struct breakpoint *b;
  CORE_ADDR dummy_addr = 0;
  ALL_BREAKPOINTS (b)
    {
      if (args->bnum == b->number)
d3237 3
a3239 2
	  print_one_breakpoint (b, &dummy_addr);
	  return GDB_RC_OK;
a3240 3
    }
  return GDB_RC_NONE;
}
d3242 3
a3244 10
enum gdb_rc
gdb_breakpoint_query (/* output object, */ int bnum)
{
  struct captured_breakpoint_query_args args;
  args.bnum = bnum;
  /* For the moment we don't trust print_one_breakpoint() to not throw
     an error. */
  return catch_errors (do_captured_breakpoint_query, &args,
		       NULL, RETURN_MASK_ALL);
}
d3246 7
a3252 3
/* Print information on breakpoint number BNUM, or -1 if all.
   If WATCHPOINTS is zero, process only breakpoints; if WATCHPOINTS
   is nonzero, process only watchpoints.  */
a3253 55
static void
breakpoint_1 (bnum, allflag)
     int bnum;
     int allflag;
{
  register struct breakpoint *b;
  CORE_ADDR last_addr = (CORE_ADDR) -1;
  int found_a_breakpoint = 0;
  
  ALL_BREAKPOINTS (b)
    if (bnum == -1
	|| bnum == b->number)
      {
	/* We only print out user settable breakpoints unless the
	   allflag is set. */
	if (!allflag
	    && b->type != bp_breakpoint
	    && b->type != bp_catch_load
	    && b->type != bp_catch_unload
	    && b->type != bp_catch_fork
	    && b->type != bp_catch_vfork
	    && b->type != bp_catch_exec
	    && b->type != bp_catch_catch
	    && b->type != bp_catch_throw
	    && b->type != bp_hardware_breakpoint
	    && b->type != bp_watchpoint
	    && b->type != bp_read_watchpoint
	    && b->type != bp_access_watchpoint
	    && b->type != bp_hardware_watchpoint)
	  continue;
	
	if (!found_a_breakpoint++)
	  {
	    annotate_breakpoints_headers ();
	    annotate_field (0);
	    printf_filtered ("Num ");
	    annotate_field (1);
	    printf_filtered ("Type           ");
	    annotate_field (2);
	    printf_filtered ("Disp ");
	    annotate_field (3);
	    printf_filtered ("Enb ");
	    if (addressprint)
	      {
		annotate_field (4);
		printf_filtered ("Address    ");
	      }
	    annotate_field (5);
	    printf_filtered ("What\n");
	    annotate_breakpoints_table ();
	  }
	
	print_one_breakpoint (b, &last_addr);
      }
  
d3262 4
a3265 6
    {
      /* Compare against (CORE_ADDR)-1 in case some compiler decides
	 that a comparison of an unsigned with -1 is always false.  */
      if (last_addr != (CORE_ADDR) -1)
	set_next_address (last_addr);
    }
a3266 2
  /* FIXME? Should this be moved up so that it is only called when
     there have been breakpoints? */
a3558 36
struct breakpoint *
create_thread_event_breakpoint (address)
     CORE_ADDR address;
{
  struct breakpoint *b;
  struct symtab_and_line sal;
  char addr_string[80];		/* Surely an addr can't be longer than that. */

  INIT_SAL (&sal);		/* initialize to zeroes */
  sal.pc = address;
  sal.section = find_pc_overlay (sal.pc);
  if ((b = set_raw_breakpoint (sal)) == NULL)
    return NULL;
  
  b->number = internal_breakpoint_number--;
  b->disposition = donttouch;
  b->type = bp_thread_event;	/* XXX: do we need a new type? 
				   bp_thread_event */
  b->enable = enabled;
  /* addr_string has to be used or breakpoint_re_set will delete me.  */
  sprintf (addr_string, "*0x%s", paddr (b->address));
  b->addr_string = strsave (addr_string);

  return b;
}

void
remove_thread_event_breakpoints (void)
{
  struct breakpoint *b, *temp;

  ALL_BREAKPOINTS_SAFE (b, temp)
    if (b->type == bp_thread_event)
      delete_breakpoint (b);
}

a4042 1
    case bp_thread_event:
a6282 1
	    b->type != bp_thread_event &&
a6294 1
		b->type != bp_thread_event &&
a6466 4

      /* Like bp_shlib_event, this breakpoint type is special.
	 Once it is set up, we do not want to touch it.  */
    case bp_thread_event:
@


1.1.1.21
log
@import gdb-1999-12-21 snapshot
@
text
@d2531 3
a2533 2
    if (b->frame &&
       b->frame != (get_current_frame ())->frame)
@


1.1.1.22
log
@import gdb-2000-01-05 snapshot
@
text
@d4167 3
a4169 9
/* Add SALS.nelts breakpoints to the breakpoint table.  For each
   SALS.sal[i] breakpoint, include the corresponding ADDR_STRING[i],
   COND[i] and COND_STRING[i] values.

   NOTE: If the function succeeds, the caller is expected to cleanup
   the arrays ADDR_STRING, COND_STRING, COND and SALS (but not the
   array contents).  If the function fails (error() is called), the
   caller is expected to cleanups both the ADDR_STRING, COND_STRING,
   COND and SALS arrays and each of those arrays contents. */
d4172 3
a4174 4
create_breakpoints (struct symtabs_and_lines sals, char **addr_string,
		    struct expression **cond, char **cond_string,
		    enum bptype type, enum bpdisp disposition,
		    int thread, int ignore_count, int from_tty)
d4176 26
a4201 11
  if (type == bp_hardware_breakpoint)
    {
      int i = hw_breakpoint_used_count ();
      int target_resources_ok = 
	TARGET_CAN_USE_HARDWARE_WATCHPOINT (bp_hardware_breakpoint, 
					    i + sals.nelts, 0);
      if (target_resources_ok == 0)
	error ("No hardware breakpoint support in the target.");
      else if (target_resources_ok < 0)
	error ("Hardware breakpoints used exceeds limit.");
    }
d4203 1
a4203 26
  /* Now set all the breakpoints.  */
  {
    int i;
    for (i = 0; i < sals.nelts; i++)
      {
	struct breakpoint *b;
	struct symtab_and_line sal = sals.sals[i];

	if (from_tty)
	  describe_other_breakpoints (sal.pc, sal.section);
	
	b = set_raw_breakpoint (sal);
	set_breakpoint_count (breakpoint_count + 1);
	b->number = breakpoint_count;
	b->type = type;
	b->cond = cond[i];
	b->thread = thread;
	b->addr_string = addr_string[i];
	b->cond_string = cond_string[i];
	b->ignore_count = ignore_count;
	b->enable = enabled;
	b->disposition = disposition;
	mention (b);
      }
  }    
}
d4205 2
a4206 16
/* Parse ARG which is assumed to be a SAL specification possibly
   followed by conditionals.  On return, SALS contains an array of SAL
   addresses found. ADDR_STRING contains a vector of (canonical)
   address strings. ARG points to the end of the SAL. */

void
parse_breakpoint_sals (char **address,
		       struct symtabs_and_lines *sals,
		       char ***addr_string)
{
  char *addr_start = *address;
  *addr_string = NULL;
  /* If no arg given, or if first arg is 'if ', use the default
     breakpoint. */
  if ((*address) == NULL
      || (strncmp ((*address), "if", 2) == 0 && isspace ((*address)[2])))
d4210 1
a4210 3
	  struct symtab_and_line sal;
	  INIT_SAL (&sal);		/* initialize to zeroes */
	  sals->sals = (struct symtab_and_line *)
d4216 2
a4217 2
	  sals->sals[0] = sal;
	  sals->nelts = 1;
d4224 2
d4232 3
a4234 3
	      || (strchr ("+-", (*address)[0]) != NULL)))
	*sals = decode_line_1 (address, 1, default_breakpoint_symtab,
			       default_breakpoint_line, addr_string);
d4236 3
a4238 1
	*sals = decode_line_1 (address, 1, (struct symtab *) NULL, 0, addr_string);
d4240 12
a4251 7
  /* For any SAL that didn't have a canonical string, fill one in. */
  if (sals->nelts > 0 && *addr_string == NULL)
    *addr_string = xcalloc (sals->nelts, sizeof (char **));
  if (addr_start != (*address))
    {
      int i;
      for (i = 0; i < sals->nelts; i++)
d4253 2
a4254 3
	  /* Add the string if not present. */
	  if ((*addr_string)[i] == NULL)
	    (*addr_string)[i] = savestring (addr_start, (*address) - addr_start);
a4256 1
}
d4258 1
d4260 6
a4265 2
/* Convert each SAL into a real PC.  Verify that the PC can be
   inserted as a breakpoint.  If it can't throw an error. */
d4267 1
a4267 8
void
breakpoint_sals_to_pc (struct symtabs_and_lines *sals,
		       char *address)
{    
  int i;
  for (i = 0; i < sals->nelts; i++)
    {
      resolve_sal_pc (&sals->sals[i]);
d4282 1
a4282 1
      if (PC_REQUIRES_RUN_BEFORE_USE (sals->sals[i].pc))
d4284 2
a4285 5
	  if (address == NULL)
	    error ("Cannot break without a running program.");
	  else
	    error ("Cannot break on %s without a running program.", 
		   address);
a4286 36
    }
}

/* Set a breakpoint according to ARG (function, linenum or *address)
   flag: first bit  : 0 non-temporary, 1 temporary.
   second bit : 0 normal breakpoint, 1 hardware breakpoint. */

static void
break_command_1 (arg, flag, from_tty)
     char *arg;
     int flag, from_tty;
{
  int tempflag, hardwareflag;
  struct symtabs_and_lines sals;
  register struct expression **cond = 0;
  /* Pointers in arg to the start, and one past the end, of the
     condition.  */
  char **cond_string = (char **) NULL;
  char *addr_start = arg;
  char **addr_string;
  struct cleanup *old_chain;
  struct cleanup *breakpoint_chain = NULL;
  int i;
  int thread = -1;
  int ignore_count = 0;

  hardwareflag = flag & BP_HARDWAREFLAG;
  tempflag = flag & BP_TEMPFLAG;

  sals.sals = NULL;
  sals.nelts = 0;
  addr_string = NULL;
  parse_breakpoint_sals (&arg, &sals, &addr_string);

  if (!sals.nelts)
    return;
d4288 1
a4288 2
  /* Create a chain of things that always need to be cleaned up. */
  old_chain = make_cleanup (null_cleanup, 0);
a4289 40
  /* Make sure that all storage allocated to SALS gets freed.  */
  make_cleanup (free, sals.sals);

  /* Cleanup the addr_string array but not its contents. */
  make_cleanup (free, addr_string);

  /* Allocate space for all the cond expressions. */
  cond = xcalloc (sals.nelts, sizeof (struct expression *));
  make_cleanup (free, cond);

  /* Allocate space for all the cond strings. */
  cond_string = xcalloc (sals.nelts, sizeof (char **));
  make_cleanup (free, cond_string);

  /* ----------------------------- SNIP -----------------------------
     Anything added to the cleanup chain beyond this point is assumed
     to be part of a breakpoint.  If the breakpoint create succeeds
     then the memory is not reclaimed. */
  breakpoint_chain = make_cleanup (null_cleanup, 0);

  /* Mark the contents of the addr_string for cleanup.  These go on
     the breakpoint_chain and only occure if the breakpoint create
     fails. */
  for (i = 0; i < sals.nelts; i++)
    {
      if (addr_string[i] != NULL)
	make_cleanup (free, addr_string[i]);
    }

  /* Resolve all line numbers to PC's and verify that the addresses
     are ok for the target.  */
  breakpoint_sals_to_pc (&sals, addr_start);

  /* Verify that condition can be parsed, before setting any
     breakpoints.  Allocate a separate condition expression for each
     breakpoint. */
  thread = -1;			/* No specific thread yet */
  for (i = 0; i < sals.nelts; i++)
    {
      char *tok = arg;
a4291 4
	  char *end_tok;
	  int toklen;
	  char *cond_start = NULL;
	  char *cond_end = NULL;
d4305 1
a4305 2
	      cond[i] = parse_exp_1 (&tok, block_for_pc (sals.sals[i].pc), 0);
	      make_cleanup (free, cond[i]);
a4306 2
	      cond_string[i] = savestring (cond_start, cond_end - cond_start);
	      make_cleanup (free, cond_string[i]);
d4324 3
d4328 8
a4335 9
  create_breakpoints (sals, addr_string, cond, cond_string,
		      hardwareflag ? bp_hardware_breakpoint : bp_breakpoint,
		      tempflag ? del : donttouch,
		      thread, ignore_count, from_tty);

  if (sals.nelts > 1)
    {
      warning ("Multiple breakpoints were set.");
      warning ("Use the \"delete\" command to delete unwanted breakpoints.");
a4336 6
  /* That's it. Discard the cleanups for data inserted into the
     breakpoint. */
  discard_cleanups (breakpoint_chain);
  /* But cleanup everything else. */
  do_cleanups (old_chain);
}
d4338 3
a4340 2
/* Set a breakpoint of TYPE/DISPOSITION according to ARG (function,
   linenum or *address) with COND and IGNORE_COUNT. */
d4342 1
a4342 62
struct captured_breakpoint_args
  {
    char *address;
    char *condition;
    int hardwareflag;
    int tempflag;
    int thread;
    int ignore_count;
  };

static int
do_captured_breakpoint (void *data)
{
  struct captured_breakpoint_args *args = data;
  struct symtabs_and_lines sals;
  register struct expression **cond;
  struct cleanup *old_chain;
  struct cleanup *breakpoint_chain = NULL;
  int i;
  char **addr_string;
  char **cond_string;

  char *address_end;

  /* Parse the source and lines spec.  Delay check that the expression
     didn't contain trailing garbage until after cleanups are in
     place. */
  sals.sals = NULL;
  sals.nelts = 0;
  address_end = args->address;
  addr_string = NULL;
  parse_breakpoint_sals (&address_end, &sals, &addr_string);

  if (!sals.nelts)
    return GDB_RC_NONE;

  /* Create a chain of things at always need to be cleaned up. */
  old_chain = make_cleanup (null_cleanup, 0);

  /* Always have a addr_string array, even if it is empty. */
  make_cleanup (free, addr_string);

  /* Make sure that all storage allocated to SALS gets freed.  */
  make_cleanup (free, sals.sals);

  /* Allocate space for all the cond expressions. */
  cond = xcalloc (sals.nelts, sizeof (struct expression *));
  make_cleanup (free, cond);

  /* Allocate space for all the cond strings. */
  cond_string = xcalloc (sals.nelts, sizeof (char **));
  make_cleanup (free, cond_string);

  /* ----------------------------- SNIP -----------------------------
     Anything added to the cleanup chain beyond this point is assumed
     to be part of a breakpoint.  If the breakpoint create goes
     through then that memory is not cleaned up. */
  breakpoint_chain = make_cleanup (null_cleanup, 0);

  /* Mark the contents of the addr_string for cleanup.  These go on
     the breakpoint_chain and only occure if the breakpoint create
     fails. */
d4345 1
a4345 3
      if (addr_string[i] != NULL)
	make_cleanup (free, addr_string[i]);
    }
d4347 2
a4348 5
  /* Wait until now before checking for garbage at the end of the
     address. That way cleanups can take care of freeing any
     memory. */
  if (*address_end != '\0')
    error ("Garbage %s following breakpoint address", address_end);
d4350 20
a4369 2
  /* Resolve all line numbers to PC's.  */
  breakpoint_sals_to_pc (&sals, args->address);
d4371 1
a4371 3
  /* Verify that conditions can be parsed, before setting any
     breakpoints.  */
  for (i = 0; i < sals.nelts; i++)
d4373 2
a4374 9
      if (args->condition != NULL)
	{
	  char *tok = args->condition;
	  cond[i] = parse_exp_1 (&tok, block_for_pc (sals.sals[i].pc), 0);
	  if (*tok != '\0')
	    error ("Garbage %s follows condition", tok);
	  make_cleanup (free, cond[i]);
	  cond_string[i] = xstrdup (args->condition);
	}
a4375 10

  create_breakpoints (sals, addr_string, cond, cond_string,
		      args->hardwareflag ? bp_hardware_breakpoint : bp_breakpoint,
		      args->tempflag ? del : donttouch,
		      args->thread, args->ignore_count, 0/*from-tty*/);

  /* That's it. Discard the cleanups for data inserted into the
     breakpoint. */
  discard_cleanups (breakpoint_chain);
  /* But cleanup everything else. */
a4376 1
  return GDB_RC_OK;
a4377 17

enum gdb_rc
gdb_breakpoint (char *address, char *condition,
		int hardwareflag, int tempflag,
		int thread, int ignore_count)
{
  struct captured_breakpoint_args args;
  args.address = address;
  args.condition = condition;
  args.hardwareflag = hardwareflag;
  args.tempflag = tempflag;
  args.thread = thread;
  args.ignore_count = ignore_count;
  return catch_errors (do_captured_breakpoint, &args,
		       NULL, RETURN_MASK_ALL);
}

@


1.1.1.23
log
@import gdb-2000-01-10 snapshot
@
text
@d5218 4
a5221 4
  struct cleanup *cleanups;

  cleanups = (struct cleanup *) arg->data;
  do_exec_cleanups (cleanups);
a5234 2
  struct continuation_arg *arg1;

d5265 1
a5265 1
    old_chain = make_exec_cleanup ((make_cleanup_func) delete_breakpoint, breakpoint);
d5276 5
a5280 10
      /* In this case the arg for the continuation is just the point
         in the exec_cleanups chain from where to start doing
         cleanups, because all the continuation does is the cleanups in
         the exec_cleanup_chain. */
      arg1 =
	(struct continuation_arg *) xmalloc (sizeof (struct continuation_arg));
      arg1->next = NULL;
      arg1->data = (PTR) old_chain;

      add_continuation (until_break_command_continuation, arg1);
@


1.1.1.24
log
@import gdb-2000-02-02 snapshot
@
text
@a41 3
#ifdef UI_OUT
#include "ui-out.h"
#endif
a1890 6
#ifdef UI_OUT
  struct cleanup *old_chain;
  struct ui_stream *stb;
  stb = ui_out_stream_new (uiout);
  old_chain = make_cleanup ((make_cleanup_func) ui_out_stream_delete, stb);
#endif /* UI_OUT */
a1899 7
#ifdef UI_OUT
      annotate_breakpoint (bs->breakpoint_at->number);
      ui_out_text (uiout, "\nBreakpoint ");
      ui_out_field_int (uiout, "bkptno", bs->breakpoint_at->number);
      ui_out_text (uiout, ", ");
      return PRINT_SRC_AND_LOC;
#else
a1904 1
#endif
a2036 12
#ifdef UI_OUT
	  mention (bs->breakpoint_at);
	  ui_out_list_begin (uiout, "value");
	  ui_out_text (uiout, "\nOld value = ");
	  value_print (bs->old_val, stb->stream, 0, Val_pretty_default);
	  ui_out_field_stream (uiout, "old", stb);
	  ui_out_text (uiout, "\nNew value = ");
	  value_print (bs->breakpoint_at->val, stb->stream, 0, Val_pretty_default);
	  ui_out_field_stream (uiout, "new", stb);
	  ui_out_list_end (uiout);
	  ui_out_text (uiout, "\n");
#else
a2043 1
#endif
a2051 9
#ifdef UI_OUT
      mention (bs->breakpoint_at);
      ui_out_list_begin (uiout, "value");
      ui_out_text (uiout, "\nValue = ");
      value_print (bs->breakpoint_at->val, stb->stream, 0, Val_pretty_default);
      ui_out_field_stream (uiout, "value", stb);
      ui_out_list_end (uiout);
      ui_out_text (uiout, "\n");
#else
a2056 1
#endif
a2060 24
#ifdef UI_OUT
      if (bs->old_val != NULL)     
	{
	  annotate_watchpoint (bs->breakpoint_at->number);
	  mention (bs->breakpoint_at);
	  ui_out_list_begin (uiout, "value");
	  ui_out_text (uiout, "\nOld value = ");
	  value_print (bs->old_val, stb->stream, 0, Val_pretty_default);
	  ui_out_field_stream (uiout, "old", stb);
	  value_free (bs->old_val);
	  bs->old_val = NULL;
	  ui_out_text (uiout, "\nNew value = ");
	}
      else 
	{
	  mention (bs->breakpoint_at);
	  ui_out_field_string (uiout, "reason", "access-watchpoint-trigger");
	  ui_out_text (uiout, "\nValue = ");
	}
      value_print (bs->breakpoint_at->val, stb->stream, 0,Val_pretty_default);
      ui_out_field_stream (uiout, "new", stb);
      ui_out_list_end (uiout);
      ui_out_text (uiout, "\n");
#else
a2078 1
#endif
a2085 3
      return PRINT_UNKNOWN;
      break;

a2086 3
      return PRINT_UNKNOWN;
      break;

a2290 6
#ifdef UI_OUT
      ui_out_text (uiout, "\nWatchpoint ");
      ui_out_field_int (uiout, "wpnum", bs->breakpoint_at->number);
      ui_out_text (uiout, " deleted because the program has left the block in\n\
which its expression is valid.\n");     
#else
a2293 1
#endif 
a3035 4
#ifdef UI_OUT
  struct ui_stream *stb = ui_out_stream_new (uiout);
  struct cleanup *old_chain = make_cleanup_ui_out_stream_delete (stb);
#endif
a3037 3
#ifdef UI_OUT
  ui_out_list_begin (uiout, "bkpt");
#endif
a3040 3
#ifdef UI_OUT
  ui_out_field_int (uiout, "number", b->number);
#else
a3041 1
#endif
a3048 3
#ifdef UI_OUT
  ui_out_field_string (uiout, "type", bptypes[(int) b->type].description);
#else
a3049 1
#endif
a3052 3
#ifdef UI_OUT
  ui_out_field_string (uiout, "disp", bpdisps[(int) b->disposition]);
#else
a3053 1
#endif
a3056 4
#ifdef UI_OUT
  ui_out_field_fmt (uiout, "enabled", "%c", bpenables[(int) b->enable]);
  ui_out_spaces (uiout, 2);
#else
a3057 1
#endif
a3075 7
#ifdef UI_OUT
      if (addressprint)
	ui_out_field_skip (uiout, "addr");
      annotate_field (5);
      print_expression (b->exp, stb->stream);
      ui_out_field_stream (uiout, "what", stb);
#else
a3077 1
#endif
a3084 16
#ifdef UI_OUT
      if (addressprint)
	ui_out_field_skip (uiout, "addr");
      annotate_field (5);
      if (b->dll_pathname == NULL)
	{
	  ui_out_field_string (uiout, "what", "<any library>");
	  ui_out_spaces (uiout, 1);
	}
      else
	{
	  ui_out_text (uiout, "library \"");
	  ui_out_field_string (uiout, "what", b->dll_pathname);
	  ui_out_text (uiout, "\" ");
	}
#else
a3089 1
#endif
a3096 11
#ifdef UI_OUT
      if (addressprint)
	ui_out_field_skip (uiout, "addr");
      annotate_field (5);
      if (b->forked_inferior_pid != 0)
	{
	  ui_out_text (uiout, "process ");
	  ui_out_field_int (uiout, "what", b->forked_inferior_pid);
	  ui_out_spaces (uiout, 1);
	}
#else
a3100 1
#endif
a3105 11
#ifdef UI_OUT
      if (addressprint)
	ui_out_field_skip (uiout, "addr");
      annotate_field (5);
      if (b->exec_pathname != NULL)
	{
	  ui_out_text (uiout, "program \"");
	  ui_out_field_string (uiout, "what", b->exec_pathname);
	  ui_out_text (uiout, "\" ");
	}
#else
a3108 1
#endif
a3114 7
#ifdef UI_OUT
      if (addressprint)
	ui_out_field_skip (uiout, "addr");
      annotate_field (5);
      ui_out_field_string (uiout, "what", "exception catch");
      ui_out_spaces (uiout, 1);
#else
a3116 1
#endif
a3122 7
#ifdef UI_OUT
      if (addressprint)
	ui_out_field_skip (uiout, "addr");
      annotate_field (5);
      ui_out_field_string (uiout, "what", "exception throw");
      ui_out_spaces (uiout, 1);
#else
a3124 1
#endif
a3138 29
#ifdef UI_OUT
      if (addressprint)
	{
	  annotate_field (4);
	  ui_out_field_core_addr (uiout, "addr", b->address);
	}
      annotate_field (5);
      *last_addr = b->address;
      if (b->source_file)
	{
	  sym = find_pc_sect_function (b->address, b->section);
	  if (sym)
	    {
	      ui_out_text (uiout, "in ");
	      ui_out_field_string (uiout, "func",
				   SYMBOL_SOURCE_NAME (sym));
	      ui_out_wrap_hint (uiout, wrap_indent);
	      ui_out_text (uiout, " at ");
	    }
	  ui_out_field_string (uiout, "file", b->source_file);
	  ui_out_text (uiout, ":");
	  ui_out_field_int (uiout, "line", b->line_number);
	}
      else
	{
	  print_address_symbolic (b->address, stb->stream, demangle, "");
	  ui_out_field_stream (uiout, "at", stb);
	}
#else
a3165 1
#endif
a3170 6
#ifdef UI_OUT
      /* FIXME: This seems to be redundant and lost here; see the
	 "stop only in" line a little further down. */
      ui_out_text (uiout, " thread ");
      ui_out_field_int (uiout, "thread", b->thread);
#else
a3171 1
#endif
a3173 3
#ifdef UI_OUT
  ui_out_text (uiout, "\n");
#else
a3174 1
#endif
a3178 5
#ifdef UI_OUT
      ui_out_text (uiout, "\tstop only in stack frame at ");
      ui_out_field_core_addr (uiout, "frame", b->frame);
      ui_out_text (uiout, "\n");
#else
a3181 1
#endif
a3186 6
#ifdef UI_OUT
      ui_out_text (uiout, "\tstop only if ");
      print_expression (b->cond, stb->stream);
      ui_out_field_stream (uiout, "cond", stb);
      ui_out_text (uiout, "\n");
#else
a3189 1
#endif
a3194 5
#ifdef UI_OUT
      ui_out_text (uiout, "\tstop only in thread ");
      ui_out_field_int (uiout, "thread", b->thread);
      ui_out_text (uiout, "\n");
#else
a3195 1
#endif
a3200 12
#ifdef UI_OUT
      if (ep_is_catchpoint (b))
	ui_out_text (uiout, "\tcatchpoint");
      else
	ui_out_text (uiout, "\tbreakpoint");
      ui_out_text (uiout, " already hit ");
      ui_out_field_int (uiout, "times", b->hit_count);
      if (b->hit_count == 1)
	ui_out_text (uiout, " time\n");
      else
	ui_out_text (uiout, " times\n");
#else
a3206 1
#endif
a3208 1

a3211 5
#ifdef UI_OUT
      ui_out_text (uiout, "\tignore next ");
      ui_out_field_int (uiout, "ignore", b->ignore_count);
      ui_out_text (uiout, " hits\n");
#else
a3212 1
#endif
a3217 5
#ifdef UI_OUT
      ui_out_list_begin (uiout, "script");
      print_command_lines (uiout, l, 4);
      ui_out_list_end (uiout);
#else
a3222 1
#endif
a3223 4
#ifdef UI_OUT
  ui_out_list_end (uiout);
  do_cleanups (old_chain);
#endif
a3271 7
#ifdef UI_OUT
  if (addressprint)
    ui_out_table_begin (uiout, 6, "BreakpointTable");
  else
    ui_out_table_begin (uiout, 5, "BreakpointTable");
#endif /* UI_OUT */

a3296 18
#ifdef UI_OUT
	    annotate_field (0);
	    ui_out_table_header (uiout, 3, ui_left, "Num");	/* 1 */
	    annotate_field (1);
	    ui_out_table_header (uiout, 14, ui_left, "Type");	/* 2 */
	    annotate_field (2);
	    ui_out_table_header (uiout, 4, ui_left, "Disp");	/* 3 */
	    annotate_field (3);
	    ui_out_table_header (uiout, 3, ui_left, "Enb");	/* 4 */
	    if (addressprint)
	      {
		annotate_field (4);
		ui_out_table_header (uiout, 10, ui_left, "Address");	/* 5 */
	      }
	    annotate_field (5);
	    ui_out_table_header (uiout, 40, ui_noalign, "What");	/* 6 */
	    ui_out_table_body (uiout);
#else
a3311 1
#endif /* UI_OUT */
a3319 7
#ifdef UI_OUT
      if (bnum == -1)
	ui_out_message (uiout, 0, "No breakpoints or watchpoints.\n");
      else
	ui_out_message (uiout, 0, "No breakpoint or watchpoint number %d.\n",
			bnum);
#else
a3323 1
#endif /* UI_OUT */
a3332 3
#ifdef UI_OUT
  ui_out_table_end (uiout);
#endif /* UI_OUT */
a4072 7
#ifdef UI_OUT
  struct cleanup *old_chain;
  struct ui_stream *stb;

  stb = ui_out_stream_new (uiout);
  old_chain = make_cleanup ((make_cleanup_func) ui_out_stream_delete, stb);
#endif /* UI_OUT */
a4087 20
#ifdef UI_OUT
    case bp_watchpoint:
      ui_out_text (uiout, "Watchpoint ");
      ui_out_list_begin (uiout, "wpt");
      ui_out_field_int (uiout, "number", b->number);
      ui_out_text (uiout, ": ");
      print_expression (b->exp, stb->stream);
      ui_out_field_stream (uiout, "exp", stb);
      ui_out_list_end (uiout);
      break;
    case bp_hardware_watchpoint:
      ui_out_text (uiout, "Hardware watchpoint ");
      ui_out_list_begin (uiout, "wpt");
      ui_out_field_int (uiout, "number", b->number);
      ui_out_text (uiout, ": ");
      print_expression (b->exp, stb->stream);
      ui_out_field_stream (uiout, "exp", stb);
      ui_out_list_end (uiout);
      break;
#else
a4095 21
#endif
#ifdef UI_OUT
    case bp_read_watchpoint:
      ui_out_text (uiout, "Hardware read watchpoint ");
      ui_out_list_begin (uiout, "hw-rwpt");
      ui_out_field_int (uiout, "number", b->number);
      ui_out_text (uiout, ": ");
      print_expression (b->exp, stb->stream);
      ui_out_field_stream (uiout, "exp", stb);
      ui_out_list_end (uiout);
      break;
    case bp_access_watchpoint:
      ui_out_text (uiout, "Hardware access (read/write) watchpoint ");
      ui_out_list_begin (uiout, "hw-awpt");
      ui_out_field_int (uiout, "number", b->number);
      ui_out_text (uiout, ": ");
      print_expression (b->exp, stb->stream);
      ui_out_field_stream (uiout, "exp", stb);
      ui_out_list_end (uiout);
      break;
#else
a4104 1
#endif
a4162 3
#ifdef UI_OUT
  do_cleanups (old_chain);
#endif
a5182 9
#ifdef UI_OUT
void
watch_command_wrapper (arg, from_tty)
     char *arg;
     int from_tty;
{
  watch_command (arg, from_tty);
}
#endif
a5190 9
#ifdef UI_OUT
void
rwatch_command_wrapper (arg, from_tty)
     char *arg;
     int from_tty;
{
  rwatch_command (arg, from_tty);
}
#endif
a5198 9
#ifdef UI_OUT
void
awatch_command_wrapper (arg, from_tty)
     char *arg;
     int from_tty;
{
  awatch_command (arg, from_tty);
}
#endif
@


