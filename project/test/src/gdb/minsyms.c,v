head	1.103;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.97
	gdb_7_6-2013-04-26-release:1.97
	gdb_7_6-branch:1.97.0.2
	gdb_7_6-2013-03-12-branchpoint:1.97
	gdb_7_5_1-2012-11-29-release:1.91
	gdb_7_5-2012-08-17-release:1.91
	gdb_7_5-branch:1.91.0.2
	gdb_7_5-2012-07-18-branchpoint:1.91
	gdb_7_4_1-2012-04-26-release:1.85.2.1
	gdb_7_4-2012-01-24-release:1.85.2.1
	gdb_7_4-branch:1.85.0.2
	gdb_7_4-2011-12-13-branchpoint:1.85
	gdb_7_3_1-2011-09-04-release:1.81
	gdb_7_3-2011-07-26-release:1.81
	gdb_7_3-branch:1.81.0.2
	gdb_7_3-2011-04-01-branchpoint:1.81
	gdb_7_2-2010-09-02-release:1.72
	gdb_7_2-branch:1.72.0.2
	gdb_7_2-2010-07-07-branchpoint:1.72
	gdb_7_1-2010-03-18-release:1.71
	gdb_7_1-branch:1.71.0.2
	gdb_7_1-2010-02-18-branchpoint:1.71
	gdb_7_0_1-2009-12-22-release:1.67
	gdb_7_0-2009-10-06-release:1.67
	gdb_7_0-branch:1.67.0.2
	gdb_7_0-2009-09-16-branchpoint:1.67
	arc-sim-20090309:1.55
	msnyder-checkpoint-072509-branch:1.66.0.2
	msnyder-checkpoint-072509-branchpoint:1.66
	arc-insight_6_8-branch:1.55.0.6
	arc-insight_6_8-branchpoint:1.55
	insight_6_8-branch:1.55.0.4
	insight_6_8-branchpoint:1.55
	reverse-20081226-branch:1.63.0.4
	reverse-20081226-branchpoint:1.63
	multiprocess-20081120-branch:1.63.0.2
	multiprocess-20081120-branchpoint:1.63
	reverse-20080930-branch:1.61.0.2
	reverse-20080930-branchpoint:1.61
	reverse-20080717-branch:1.59.0.4
	reverse-20080717-branchpoint:1.59
	msnyder-reverse-20080609-branch:1.59.0.2
	msnyder-reverse-20080609-branchpoint:1.59
	drow-reverse-20070409-branch:1.49.0.2
	drow-reverse-20070409-branchpoint:1.49
	gdb_6_8-2008-03-27-release:1.55
	gdb_6_8-branch:1.55.0.2
	gdb_6_8-2008-02-26-branchpoint:1.55
	gdb_6_7_1-2007-10-29-release:1.52
	gdb_6_7-2007-10-10-release:1.52
	gdb_6_7-branch:1.52.0.2
	gdb_6_7-2007-09-07-branchpoint:1.52
	insight_6_6-20070208-release:1.47
	gdb_6_6-2006-12-18-release:1.47
	gdb_6_6-branch:1.47.0.2
	gdb_6_6-2006-11-15-branchpoint:1.47
	insight_6_5-20061003-release:1.45
	gdb-csl-symbian-6_4_50_20060226-12:1.45
	gdb-csl-sourcerygxx-3_4_4-25:1.44
	nickrob-async-20060828-mergepoint:1.46
	gdb-csl-symbian-6_4_50_20060226-11:1.45
	gdb-csl-sourcerygxx-4_1-17:1.45
	gdb-csl-20060226-branch-local-2:1.45
	gdb-csl-sourcerygxx-4_1-14:1.45
	gdb-csl-sourcerygxx-4_1-13:1.45
	gdb-csl-sourcerygxx-4_1-12:1.45
	gdb-csl-sourcerygxx-3_4_4-21:1.45
	gdb_6_5-20060621-release:1.45
	gdb-csl-sourcerygxx-4_1-9:1.45
	gdb-csl-sourcerygxx-4_1-8:1.45
	gdb-csl-sourcerygxx-4_1-7:1.45
	gdb-csl-arm-2006q1-6:1.45
	gdb-csl-sourcerygxx-4_1-6:1.45
	gdb-csl-symbian-6_4_50_20060226-10:1.45
	gdb-csl-symbian-6_4_50_20060226-9:1.45
	gdb-csl-symbian-6_4_50_20060226-8:1.45
	gdb-csl-coldfire-4_1-11:1.45
	gdb-csl-sourcerygxx-3_4_4-19:1.45
	gdb-csl-coldfire-4_1-10:1.45
	gdb_6_5-branch:1.45.0.16
	gdb_6_5-2006-05-14-branchpoint:1.45
	gdb-csl-sourcerygxx-4_1-5:1.45
	nickrob-async-20060513-branch:1.45.0.14
	nickrob-async-20060513-branchpoint:1.45
	gdb-csl-sourcerygxx-4_1-4:1.45
	msnyder-reverse-20060502-branch:1.45.0.12
	msnyder-reverse-20060502-branchpoint:1.45
	gdb-csl-morpho-4_1-4:1.45
	gdb-csl-sourcerygxx-3_4_4-17:1.45
	readline_5_1-import-branch:1.45.0.10
	readline_5_1-import-branchpoint:1.45
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.45
	gdb-csl-symbian-20060226-branch:1.45.0.8
	gdb-csl-symbian-20060226-branchpoint:1.45
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.45
	msnyder-reverse-20060331-branch:1.45.0.6
	msnyder-reverse-20060331-branchpoint:1.45
	gdb-csl-available-20060303-branch:1.45.0.4
	gdb-csl-available-20060303-branchpoint:1.45
	gdb-csl-20060226-branch:1.45.0.2
	gdb-csl-20060226-branchpoint:1.45
	gdb_6_4-20051202-release:1.44
	msnyder-fork-checkpoint-branch:1.44.0.14
	msnyder-fork-checkpoint-branchpoint:1.44
	gdb-csl-gxxpro-6_3-branch:1.44.0.12
	gdb-csl-gxxpro-6_3-branchpoint:1.44
	gdb_6_4-branch:1.44.0.10
	gdb_6_4-2005-11-01-branchpoint:1.44
	gdb-csl-arm-20051020-branch:1.44.0.8
	gdb-csl-arm-20051020-branchpoint:1.44
	msnyder-tracepoint-checkpoint-branch:1.44.0.6
	msnyder-tracepoint-checkpoint-branchpoint:1.44
	gdb-csl-arm-20050325-2005-q1b:1.44
	gdb-csl-arm-20050325-2005-q1a:1.44
	csl-arm-20050325-branch:1.44.0.4
	csl-arm-20050325-branchpoint:1.44
	gdb-post-i18n-errorwarning-20050211:1.44
	gdb-pre-i18n-errorwarning-20050211:1.44
	gdb_6_3-20041109-release:1.44
	gdb_6_3-branch:1.44.0.2
	gdb_6_3-20041019-branchpoint:1.44
	drow_intercu-merge-20040921:1.44
	drow_intercu-merge-20040915:1.43
	jimb-gdb_6_2-e500-branch:1.43.0.6
	jimb-gdb_6_2-e500-branchpoint:1.43
	gdb_6_2-20040730-release:1.43
	gdb_6_2-branch:1.43.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.43
	gdb_6_1_1-20040616-release:1.41
	gdb_6_1-2004-04-05-release:1.41
	drow_intercu-merge-20040402:1.42
	drow_intercu-merge-20040327:1.41
	ezannoni_pie-20040323-branch:1.41.0.10
	ezannoni_pie-20040323-branchpoint:1.41
	cagney_tramp-20040321-mergepoint:1.41
	cagney_tramp-20040309-branch:1.41.0.8
	cagney_tramp-20040309-branchpoint:1.41
	gdb_6_1-branch:1.41.0.6
	gdb_6_1-2004-03-01-gmt-branchpoint:1.41
	drow_intercu-20040221-branch:1.41.0.4
	drow_intercu-20040221-branchpoint:1.41
	cagney_bfdfile-20040213-branch:1.41.0.2
	cagney_bfdfile-20040213-branchpoint:1.41
	drow-cplus-merge-20040208:1.40
	carlton_dictionary-20040126-merge:1.39
	cagney_bigcore-20040122-branch:1.39.0.2
	cagney_bigcore-20040122-branchpoint:1.39
	drow-cplus-merge-20040113:1.39
	drow-cplus-merge-20031224:1.39
	drow-cplus-merge-20031220:1.39
	carlton_dictionary-20031215-merge:1.39
	drow-cplus-merge-20031214:1.39
	carlton-dictionary-20031111-merge:1.38
	gdb_6_0-2003-10-04-release:1.31.10.1
	kettenis_sparc-20030918-branch:1.34.0.4
	kettenis_sparc-20030918-branchpoint:1.34
	carlton_dictionary-20030917-merge:1.34
	ezannoni_pie-20030916-branchpoint:1.34
	ezannoni_pie-20030916-branch:1.34.0.2
	cagney_x86i386-20030821-branch:1.32.0.2
	cagney_x86i386-20030821-branchpoint:1.32
	carlton_dictionary-20030805-merge:1.32
	carlton_dictionary-20030627-merge:1.31
	gdb_6_0-branch:1.31.0.10
	gdb_6_0-2003-06-23-branchpoint:1.31
	jimb-ppc64-linux-20030613-branch:1.31.0.8
	jimb-ppc64-linux-20030613-branchpoint:1.31
	cagney_convert-20030606-branch:1.31.0.6
	cagney_convert-20030606-branchpoint:1.31
	cagney_writestrings-20030508-branch:1.30.0.6
	cagney_writestrings-20030508-branchpoint:1.30
	jimb-ppc64-linux-20030528-branch:1.31.0.4
	jimb-ppc64-linux-20030528-branchpoint:1.31
	carlton_dictionary-20030523-merge:1.31
	cagney_fileio-20030521-branch:1.31.0.2
	cagney_fileio-20030521-branchpoint:1.31
	kettenis_i386newframe-20030517-mergepoint:1.31
	jimb-ppc64-linux-20030509-branch:1.30.0.4
	jimb-ppc64-linux-20030509-branchpoint:1.30
	kettenis_i386newframe-20030504-mergepoint:1.30
	carlton_dictionary-20030430-merge:1.30
	kettenis_i386newframe-20030419-branch:1.30.0.2
	kettenis_i386newframe-20030419-branchpoint:1.30
	carlton_dictionary-20030416-merge:1.30
	cagney_frameaddr-20030409-mergepoint:1.29
	kettenis_i386newframe-20030406-branch:1.29.0.10
	kettenis_i386newframe-20030406-branchpoint:1.29
	cagney_frameaddr-20030403-branchpoint:1.29
	cagney_frameaddr-20030403-branch:1.29.0.8
	cagney_framebase-20030330-mergepoint:1.29
	cagney_framebase-20030326-branch:1.29.0.6
	cagney_framebase-20030326-branchpoint:1.29
	cagney_lazyid-20030317-branch:1.29.0.4
	cagney_lazyid-20030317-branchpoint:1.29
	kettenis-i386newframe-20030316-mergepoint:1.29
	offbyone-20030313-branch:1.29.0.2
	offbyone-20030313-branchpoint:1.29
	kettenis-i386newframe-20030308-branch:1.28.0.2
	kettenis-i386newframe-20030308-branchpoint:1.28
	carlton_dictionary-20030305-merge:1.28
	cagney_offbyone-20030303-branch:1.27.0.2
	cagney_offbyone-20030303-branchpoint:1.27
	carlton_dictionary-20030207-merge:1.25
	interps-20030203-mergepoint:1.24
	interps-20030202-branch:1.23.0.4
	interps-20030202-branchpoint:1.23
	cagney-unwind-20030108-branch:1.23.0.2
	cagney-unwind-20030108-branchpoint:1.23
	carlton_dictionary-20021223-merge:1.22
	gdb_5_3-2002-12-12-release:1.22
	carlton_dictionary-20021115-merge:1.22
	kseitz_interps-20021105-merge:1.22
	kseitz_interps-20021103-merge:1.22
	drow-cplus-merge-20021020:1.22
	drow-cplus-merge-20021025:1.22
	carlton_dictionary-20021025-merge:1.22
	carlton_dictionary-20021011-merge:1.22
	drow-cplus-branch:1.22.0.10
	drow-cplus-branchpoint:1.22
	kseitz_interps-20020930-merge:1.22
	carlton_dictionary-20020927-merge:1.22
	carlton_dictionary-branch:1.22.0.8
	carlton_dictionary-20020920-branchpoint:1.22
	gdb_5_3-branch:1.22.0.6
	gdb_5_3-2002-09-04-branchpoint:1.22
	kseitz_interps-20020829-merge:1.22
	cagney_sysregs-20020825-branch:1.22.0.4
	cagney_sysregs-20020825-branchpoint:1.22
	readline_4_3-import-branch:1.22.0.2
	readline_4_3-import-branchpoint:1.22
	gdb_5_2_1-2002-07-23-release:1.19.2.1
	kseitz_interps-20020528-branch:1.21.0.6
	kseitz_interps-20020528-branchpoint:1.21
	cagney_regbuf-20020515-branch:1.21.0.4
	cagney_regbuf-20020515-branchpoint:1.21
	jimb-macro-020506-branch:1.21.0.2
	jimb-macro-020506-branchpoint:1.21
	gdb_5_2-2002-04-29-release:1.19.2.1
	gdb_5_2-branch:1.19.0.2
	gdb_5_2-2002-03-03-branchpoint:1.19
	gdb_5_1_1-2002-01-24-release:1.17
	gdb_5_1_0_1-2002-01-03-release:1.17
	cygnus_cvs_20020108_pre:1.19
	gdb_5_1_0_1-2002-01-03-branchpoint:1.17
	gdb_5_1_0_1-2002-01-03-branch:1.17.0.8
	gdb_5_1-2001-11-21-release:1.17
	gdb_s390-2001-09-26-branch:1.17.0.6
	gdb_s390-2001-09-26-branchpoint:1.17
	gdb_5_1-2001-07-29-branch:1.17.0.4
	gdb_5_1-2001-07-29-branchpoint:1.17
	dberlin-typesystem-branch:1.17.0.2
	dberlin-typesystem-branchpoint:1.17
	gdb-post-ptid_t-2001-05-03:1.15
	gdb-pre-ptid_t-2001-05-03:1.15
	insight-precleanup-2001-01-01:1.12
	gdb-post-protoization-2000-07-29:1.10
	gdb-pre-protoization-2000-07-29:1.9
	gdb-premipsmulti-2000-06-06-branch:1.9.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.9
	gdb-post-params-removal-2000-06-04:1.9
	gdb-pre-params-removal-2000-06-04:1.9
	gdb-post-params-removal-2000-05-28:1.9
	gdb-pre-params-removal-2000-05-28:1.8
	gdb_5_0-2000-05-19-release:1.5
	gdb_4_18_2-2000-05-18-release:1.5
	gdb_4_95_1-2000-05-11-snapshot:1.5
	gdb_4_95_0-2000-04-27-snapshot:1.5
	gdb_5_0-2000-04-10-branch:1.5.0.2
	gdb_5_0-2000-04-10-branchpoint:1.5
	repo-unification-2000-02-06:1.1.1.3
	insight-2000-02-04:1.1.1.3
	gdb-2000-02-04:1.1.1.3
	gdb-2000-02-02:1.1.1.3
	gdb-2000-02-01:1.1.1.3
	gdb-2000-01-31:1.1.1.3
	gdb-2000-01-26:1.1.1.3
	gdb-2000-01-24:1.1.1.3
	gdb-2000-01-17:1.1.1.3
	gdb-2000-01-10:1.1.1.3
	gdb-2000-01-05:1.1.1.3
	gdb-1999-12-21:1.1.1.3
	gdb-1999-12-13:1.1.1.3
	gdb-1999-12-07:1.1.1.3
	gdb-1999-12-06:1.1.1.3
	gdb-1999-11-16:1.1.1.3
	gdb-1999-11-08:1.1.1.3
	gdb-1999-11-01:1.1.1.3
	gdb-1999-10-25:1.1.1.3
	gdb-1999-10-18:1.1.1.3
	gdb-1999-10-11:1.1.1.3
	gdb-1999-10-04:1.1.1.3
	gdb-1999-09-28:1.1.1.3
	gdb-1999-09-21:1.1.1.3
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.103
date	2013.09.24.13.57.37;	author jkratoch;	state Exp;
branches;
next	1.102;

1.102
date	2013.08.05.15.51.02;	author tromey;	state Exp;
branches;
next	1.101;

1.101
date	2013.04.08.20.18.11;	author tromey;	state Exp;
branches;
next	1.100;

1.100
date	2013.04.08.20.13.22;	author tromey;	state Exp;
branches;
next	1.99;

1.99
date	2013.04.08.19.59.09;	author tromey;	state Exp;
branches;
next	1.98;

1.98
date	2013.04.08.19.56.03;	author tromey;	state Exp;
branches;
next	1.97;

1.97
date	2013.03.07.21.57.29;	author kseitz;	state Exp;
branches;
next	1.96;

1.96
date	2013.01.21.17.29.39;	author tromey;	state Exp;
branches;
next	1.95;

1.95
date	2013.01.01.06.32.47;	author brobecke;	state Exp;
branches;
next	1.94;

1.94
date	2012.12.18.19.21.53;	author tromey;	state Exp;
branches;
next	1.93;

1.93
date	2012.09.11.21.26.16;	author brobecke;	state Exp;
branches;
next	1.92;

1.92
date	2012.09.11.21.26.04;	author brobecke;	state Exp;
branches;
next	1.91;

1.91
date	2012.06.26.20.14.02;	author devans;	state Exp;
branches;
next	1.90;

1.90
date	2012.02.07.04.48.21;	author devans;	state Exp;
branches;
next	1.89;

1.89
date	2012.01.04.08.17.06;	author brobecke;	state Exp;
branches;
next	1.88;

1.88
date	2011.12.22.02.34.34;	author tromey;	state Exp;
branches;
next	1.87;

1.87
date	2011.12.21.21.51.56;	author tromey;	state Exp;
branches;
next	1.86;

1.86
date	2011.12.19.16.11.14;	author tromey;	state Exp;
branches;
next	1.85;

1.85
date	2011.12.06.18.54.39;	author tromey;	state Exp;
branches
	1.85.2.1;
next	1.84;

1.84
date	2011.07.05.04.34.56;	author bauermann;	state Exp;
branches;
next	1.83;

1.83
date	2011.04.27.20.03.03;	author jkratoch;	state Exp;
branches;
next	1.82;

1.82
date	2011.04.06.19.50.05;	author jkratoch;	state Exp;
branches;
next	1.81;

1.81
date	2011.03.28.20.29.51;	author jkratoch;	state Exp;
branches;
next	1.80;

1.80
date	2011.03.28.20.26.24;	author jkratoch;	state Exp;
branches;
next	1.79;

1.79
date	2011.03.28.20.21.03;	author jkratoch;	state Exp;
branches;
next	1.78;

1.78
date	2011.03.23.18.23.55;	author ktietz;	state Exp;
branches;
next	1.77;

1.77
date	2011.03.09.12.48.55;	author palves;	state Exp;
branches;
next	1.76;

1.76
date	2011.01.09.03.20.33;	author msnyder;	state Exp;
branches;
next	1.75;

1.75
date	2011.01.05.22.22.49;	author msnyder;	state Exp;
branches;
next	1.74;

1.74
date	2011.01.01.15.33.11;	author brobecke;	state Exp;
branches;
next	1.73;

1.73
date	2010.08.09.19.42.48;	author swagiaal;	state Exp;
branches;
next	1.72;

1.72
date	2010.05.16.00.18.02;	author msnyder;	state Exp;
branches;
next	1.71;

1.71
date	2010.01.21.17.12.18;	author tromey;	state Exp;
branches;
next	1.70;

1.70
date	2010.01.06.10.11.04;	author gingold;	state Exp;
branches;
next	1.69;

1.69
date	2010.01.01.07.31.37;	author brobecke;	state Exp;
branches;
next	1.68;

1.68
date	2009.11.16.18.40.22;	author tromey;	state Exp;
branches;
next	1.67;

1.67
date	2009.09.14.17.17.30;	author ppluzhnikov;	state Exp;
branches;
next	1.66;

1.66
date	2009.06.28.00.20.22;	author drow;	state Exp;
branches;
next	1.65;

1.65
date	2009.03.31.20.21.07;	author tromey;	state Exp;
branches;
next	1.64;

1.64
date	2009.01.03.05.57.52;	author brobecke;	state Exp;
branches;
next	1.63;

1.63
date	2008.10.01.16.56.52;	author tromey;	state Exp;
branches
	1.63.2.1;
next	1.62;

1.62
date	2008.10.01.16.41.27;	author tromey;	state Exp;
branches;
next	1.61;

1.61
date	2008.09.05.11.37.17;	author uweigand;	state Exp;
branches;
next	1.60;

1.60
date	2008.08.21.18.14.39;	author drow;	state Exp;
branches;
next	1.59;

1.59
date	2008.05.16.12.58.48;	author uweigand;	state Exp;
branches;
next	1.58;

1.58
date	2008.05.16.12.51.21;	author uweigand;	state Exp;
branches;
next	1.57;

1.57
date	2008.05.14.18.14.34;	author drow;	state Exp;
branches;
next	1.56;

1.56
date	2008.05.03.00.37.34;	author uweigand;	state Exp;
branches;
next	1.55;

1.55
date	2008.01.01.22.53.12;	author drow;	state Exp;
branches;
next	1.54;

1.54
date	2007.12.18.16.02.54;	author drow;	state Exp;
branches;
next	1.53;

1.53
date	2007.10.19.12.26.34;	author uweigand;	state Exp;
branches;
next	1.52;

1.52
date	2007.08.23.18.08.36;	author brobecke;	state Exp;
branches;
next	1.51;

1.51
date	2007.07.01.22.39.04;	author drow;	state Exp;
branches;
next	1.50;

1.50
date	2007.06.15.22.39.52;	author uweigand;	state Exp;
branches;
next	1.49;

1.49
date	2007.01.09.22.14.35;	author drow;	state Exp;
branches;
next	1.48;

1.48
date	2007.01.09.17.58.52;	author drow;	state Exp;
branches;
next	1.47;

1.47
date	2006.10.17.20.17.44;	author drow;	state Exp;
branches;
next	1.46;

1.46
date	2006.07.19.02.17.23;	author drow;	state Exp;
branches;
next	1.45;

1.45
date	2005.12.17.22.34.01;	author eliz;	state Exp;
branches
	1.45.14.1;
next	1.44;

1.44
date	2004.09.20.16.54.28;	author jimb;	state Exp;
branches;
next	1.43;

1.43
date	2004.05.20.09.51.33;	author hilfingr;	state Exp;
branches;
next	1.42;

1.42
date	2004.03.29.11.26.04;	author corinna;	state Exp;
branches;
next	1.41;

1.41
date	2004.02.09.19.13.46;	author cagney;	state Exp;
branches
	1.41.4.1;
next	1.40;

1.40
date	2004.02.07.23.13.47;	author ezannoni;	state Exp;
branches;
next	1.39;

1.39
date	2003.11.11.20.04.52;	author chastain;	state Exp;
branches;
next	1.38;

1.38
date	2003.11.08.00.13.02;	author cagney;	state Exp;
branches;
next	1.37;

1.37
date	2003.11.06.22.54.01;	author cagney;	state Exp;
branches;
next	1.36;

1.36
date	2003.10.21.22.56.38;	author ezannoni;	state Exp;
branches;
next	1.35;

1.35
date	2003.10.16.16.35.27;	author ezannoni;	state Exp;
branches;
next	1.34;

1.34
date	2003.09.16.18.56.35;	author cagney;	state Exp;
branches;
next	1.33;

1.33
date	2003.09.14.16.32.13;	author cagney;	state Exp;
branches;
next	1.32;

1.32
date	2003.07.26.22.03.38;	author drow;	state Exp;
branches;
next	1.31;

1.31
date	2003.05.15.22.23.24;	author cagney;	state Exp;
branches
	1.31.10.1;
next	1.30;

1.30
date	2003.04.13.15.25.23;	author drow;	state Exp;
branches
	1.30.2.1;
next	1.29;

1.29
date	2003.03.10.20.40.45;	author carlton;	state Exp;
branches;
next	1.28;

1.28
date	2003.03.05.18.01.46;	author drow;	state Exp;
branches
	1.28.2.1;
next	1.27;

1.27
date	2003.03.03.18.34.12;	author carlton;	state Exp;
branches;
next	1.26;

1.26
date	2003.02.25.21.36.18;	author carlton;	state Exp;
branches;
next	1.25;

1.25
date	2003.02.04.18.07.01;	author drow;	state Exp;
branches;
next	1.24;

1.24
date	2003.02.03.20.39.41;	author jimb;	state Exp;
branches;
next	1.23;

1.23
date	2003.01.08.18.38.47;	author drow;	state Exp;
branches
	1.23.4.1;
next	1.22;

1.22
date	2002.07.11.20.46.19;	author drow;	state Exp;
branches
	1.22.8.1
	1.22.10.1;
next	1.21;

1.21
date	2002.04.24.08.00.54;	author davem;	state Exp;
branches
	1.21.6.1;
next	1.20;

1.20
date	2002.03.19.19.00.04;	author aoliva;	state Exp;
branches;
next	1.19;

1.19
date	2001.12.10.22.04.10;	author fnf;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2001.10.12.19.07.07;	author drow;	state Exp;
branches;
next	1.17;

1.17
date	2001.05.29.10.45.10;	author aoliva;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2001.05.22.21.02.41;	author jimb;	state Exp;
branches;
next	1.15;

1.15
date	2001.03.07.02.57.08;	author jtc;	state Exp;
branches;
next	1.14;

1.14
date	2001.03.06.08.21.10;	author kevinb;	state Exp;
branches;
next	1.13;

1.13
date	2001.02.11.06.11.38;	author eliz;	state Exp;
branches;
next	1.12;

1.12
date	2000.12.15.01.01.48;	author kevinb;	state Exp;
branches;
next	1.11;

1.11
date	2000.08.04.18.41.05;	author kevinb;	state Exp;
branches;
next	1.10;

1.10
date	2000.07.30.01.48.26;	author kevinb;	state Exp;
branches;
next	1.9;

1.9
date	2000.05.28.01.12.28;	author kevinb;	state Exp;
branches;
next	1.8;

1.8
date	2000.05.16.04.07.39;	author cagney;	state Exp;
branches;
next	1.7;

1.7
date	2000.05.04.16.52.33;	author ezannoni;	state Exp;
branches;
next	1.6;

1.6
date	2000.04.19.21.13.09;	author jimb;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.03.04.47.27;	author cagney;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.30.03.03.23;	author dberlin;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.09.22.58.49;	author ezannoni;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.04.33.52;	author jimb;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.02;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.85.2.1
date	2012.01.06.04.43.20;	author brobecke;	state Exp;
branches;
next	;

1.63.2.1
date	2008.11.21.02.31.57;	author shebs;	state Exp;
branches;
next	;

1.45.14.1
date	2006.08.28.07.48.48;	author nickrob;	state Exp;
branches;
next	;

1.41.4.1
date	2004.04.02.16.47.47;	author drow;	state Exp;
branches;
next	1.41.4.2;

1.41.4.2
date	2004.09.16.17.01.13;	author drow;	state Exp;
branches;
next	1.41.4.3;

1.41.4.3
date	2004.09.21.20.44.17;	author drow;	state Exp;
branches;
next	;

1.31.10.1
date	2003.08.04.03.07.01;	author drow;	state Exp;
branches;
next	;

1.30.2.1
date	2003.05.18.09.44.16;	author kettenis;	state Exp;
branches;
next	;

1.28.2.1
date	2003.03.16.14.01.50;	author kettenis;	state Exp;
branches;
next	;

1.23.4.1
date	2003.02.03.22.00.55;	author cagney;	state Exp;
branches;
next	;

1.22.8.1
date	2002.12.21.00.17.43;	author carlton;	state Exp;
branches;
next	1.22.8.2;

1.22.8.2
date	2003.02.01.01.17.22;	author carlton;	state Exp;
branches;
next	1.22.8.3;

1.22.8.3
date	2003.02.07.19.17.51;	author carlton;	state Exp;
branches;
next	1.22.8.4;

1.22.8.4
date	2003.03.06.00.56.30;	author carlton;	state Exp;
branches;
next	1.22.8.5;

1.22.8.5
date	2003.03.07.00.31.44;	author carlton;	state Exp;
branches;
next	1.22.8.6;

1.22.8.6
date	2003.03.07.22.52.54;	author carlton;	state Exp;
branches;
next	1.22.8.7;

1.22.8.7
date	2003.04.16.19.56.53;	author carlton;	state Exp;
branches;
next	1.22.8.8;

1.22.8.8
date	2003.05.02.20.36.08;	author carlton;	state Exp;
branches;
next	1.22.8.9;

1.22.8.9
date	2003.08.05.17.13.11;	author carlton;	state Exp;
branches;
next	1.22.8.10;

1.22.8.10
date	2003.09.17.21.28.25;	author carlton;	state Exp;
branches;
next	1.22.8.11;

1.22.8.11
date	2003.11.11.23.50.49;	author carlton;	state Exp;
branches;
next	1.22.8.12;

1.22.8.12
date	2003.12.16.00.00.41;	author carlton;	state Exp;
branches;
next	;

1.22.10.1
date	2003.12.14.20.27.21;	author drow;	state Exp;
branches;
next	1.22.10.2;

1.22.10.2
date	2004.02.09.19.43.44;	author drow;	state Exp;
branches;
next	;

1.21.6.1
date	2002.07.22.21.47.00;	author kseitz;	state Exp;
branches;
next	;

1.19.2.1
date	2002.03.25.16.50.20;	author aoliva;	state Exp;
branches;
next	;

1.17.2.1
date	2001.07.06.19.17.02;	author dberlin;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.02;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.07.07.20.08.05;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.09.22.03.24.47;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.103
log
@Code cleanup: Add objfile_name accessor

gdb/
2013-09-24  Jan Kratochvil  <jan.kratochvil@@redhat.com>

	Code cleanup: Add objfile_name accessor function.
	* ada-lang.c (is_known_support_routine): Use objfile_name.
	* auto-load.c (source_gdb_script_for_objfile)
	(auto_load_objfile_script): Likewise.
	* coffread.c (coff_symtab_read, read_one_sym): Likewise.
	* dbxread.c (dbx_symfile_read): Likewise.
	* dwarf2-frame.c (dwarf2_build_frame_info): Likewise.
	* dwarf2loc.c (locexpr_describe_location_piece): Likewise.
	* dwarf2read.c (dwarf2_get_dwz_file, dwarf2_read_index)
	(dw2_symtab_iter_next, dw2_expand_symtabs_matching)
	(lookup_dwp_signatured_type, lookup_dwo_unit)
	(dwarf2_build_psymtabs_hard, scan_partial_symbols, process_queue)
	(fixup_go_packaging, process_imported_unit_die, dwarf2_physname)
	(read_import_statement, create_dwo_cu, open_and_init_dwp_file)
	(lookup_dwo_cutu, read_call_site_scope, dwarf2_ranges_read)
	(dwarf2_record_block_ranges, read_common_block, read_typedef)
	(read_subrange_type, load_partial_dies, read_partial_die)
	(read_addr_index_1, read_str_index, dwarf_decode_lines_1)
	(die_containing_type, build_error_marker_type, lookup_die_type)
	(follow_die_ref_or_sig, follow_die_ref, dwarf2_fetch_die_loc_sect_off)
	(dwarf2_fetch_constant_bytes, follow_die_sig, get_signatured_type)
	(get_DW_AT_signature_type, write_psymtabs_to_index)
	(save_gdb_index_command): Likewise.
	* elfread.c (find_separate_debug_file_by_buildid, elf_symfile_read):
	Likewise.
	* expprint.c (dump_subexp_body_standard): Likewise.
	* gdbtypes.c (type_name_no_tag_or_error): Likewise.
	* jit.c (jit_object_close_impl): Use the objfile field name renamed to
	original_name.
	* linux-thread-db.c (try_thread_db_load_from_pdir_1): New variable
	obj_name, use objfile_name for it, use the variable.
	(try_thread_db_load_from_pdir, has_libpthread, thread_db_new_objfile):
	Use objfile_name.
	* machoread.c (macho_symtab_read, macho_check_dsym)
	(macho_symfile_relocate): Likewise.
	* maint.c (maintenance_translate_address): Likewise.
	* minidebug.c (find_separate_debug_file_in_section): Likewise.
	* minsyms.c (install_minimal_symbols): Likewise.
	* objfiles.c (allocate_objfile): Use the objfile field name renamed to
	original_name.
	(filter_overlapping_sections): Use objfile_name.
	(objfile_name): New function.
	* objfiles.h (struct objfile): Rename field name to original_name.
	(objfile_name): New prototype.
	* printcmd.c (sym_info, address_info): Use objfile_name.
	* probe.c (parse_probes, collect_probes, compare_probes)
	(info_probes_for_ops): Likewise.
	* progspace.c (clone_program_space): Likewise.
	* psymtab.c (require_partial_symbols, dump_psymtab, allocate_psymtab)
	(maintenance_info_psymtabs): Likewise.
	* python/py-auto-load.c (gdbpy_load_auto_script_for_objfile)
	(source_section_scripts): Likewise.
	* python/py-objfile.c (objfpy_get_filename): Likewise.
	* python/py-progspace.c (pspy_get_filename): Likewise.
	* solib-aix.c (solib_aix_get_toc_value): Likewise.
	* solib-som.c (match_main, som_solib_section_offsets): Likewise.
	* solib.c (solib_read_symbols): Likewise.
	* stabsread.c (scan_file_globals): Likewise.
	* stap-probe.c (handle_stap_probe): Likewise.
	* symfile.c (symbol_file_clear, separate_debug_file_exists)
	(find_separate_debug_file_by_debuglink): Likewise.
	(reread_symbols): Likewise.  Use the objfile field name renamed to
	original_name.
	(allocate_symtab): Use objfile_name.
	* symmisc.c (print_symbol_bcache_statistics, print_objfile_statistics)
	(dump_objfile, dump_msymbols, dump_symtab_1)
	(maintenance_print_msymbols, maintenance_print_objfiles)
	(maintenance_info_symtabs, maintenance_check_symtabs): Likewise.
	* target.c (target_translate_tls_address, target_info): Likewise.
	* xcoffread.c (xcoff_initial_scan): Make variable name const.  Use
	objfile_name.
@
text
@/* GDB routines for manipulating the minimal symbol tables.
   Copyright (C) 1992-2013 Free Software Foundation, Inc.
   Contributed by Cygnus Support, using pieces from other GDB modules.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */


/* This file contains support routines for creating, manipulating, and
   destroying minimal symbol tables.

   Minimal symbol tables are used to hold some very basic information about
   all defined global symbols (text, data, bss, abs, etc).  The only two
   required pieces of information are the symbol's name and the address
   associated with that symbol.

   In many cases, even if a file was compiled with no special options for
   debugging at all, as long as was not stripped it will contain sufficient
   information to build useful minimal symbol tables using this structure.

   Even when a file contains enough debugging information to build a full
   symbol table, these minimal symbols are still useful for quickly mapping
   between names and addresses, and vice versa.  They are also sometimes used
   to figure out what full symbol table entries need to be read in.  */


#include "defs.h"
#include <ctype.h>
#include "gdb_string.h"
#include "symtab.h"
#include "bfd.h"
#include "filenames.h"
#include "symfile.h"
#include "objfiles.h"
#include "demangle.h"
#include "value.h"
#include "cp-abi.h"
#include "target.h"
#include "cp-support.h"
#include "language.h"
#include "cli/cli-utils.h"

/* Accumulate the minimal symbols for each objfile in bunches of BUNCH_SIZE.
   At the end, copy them all into one newly allocated location on an objfile's
   symbol obstack.  */

#define BUNCH_SIZE 127

struct msym_bunch
  {
    struct msym_bunch *next;
    struct minimal_symbol contents[BUNCH_SIZE];
  };

/* Bunch currently being filled up.
   The next field points to chain of filled bunches.  */

static struct msym_bunch *msym_bunch;

/* Number of slots filled in current bunch.  */

static int msym_bunch_index;

/* Total number of minimal symbols recorded so far for the objfile.  */

static int msym_count;

/* See minsyms.h.  */

unsigned int
msymbol_hash_iw (const char *string)
{
  unsigned int hash = 0;

  while (*string && *string != '(')
    {
      string = skip_spaces_const (string);
      if (*string && *string != '(')
	{
	  hash = SYMBOL_HASH_NEXT (hash, *string);
	  ++string;
	}
    }
  return hash;
}

/* See minsyms.h.  */

unsigned int
msymbol_hash (const char *string)
{
  unsigned int hash = 0;

  for (; *string; ++string)
    hash = SYMBOL_HASH_NEXT (hash, *string);
  return hash;
}

/* Add the minimal symbol SYM to an objfile's minsym hash table, TABLE.  */
static void
add_minsym_to_hash_table (struct minimal_symbol *sym,
			  struct minimal_symbol **table)
{
  if (sym->hash_next == NULL)
    {
      unsigned int hash
	= msymbol_hash (SYMBOL_LINKAGE_NAME (sym)) % MINIMAL_SYMBOL_HASH_SIZE;

      sym->hash_next = table[hash];
      table[hash] = sym;
    }
}

/* Add the minimal symbol SYM to an objfile's minsym demangled hash table,
   TABLE.  */
static void
add_minsym_to_demangled_hash_table (struct minimal_symbol *sym,
                                  struct minimal_symbol **table)
{
  if (sym->demangled_hash_next == NULL)
    {
      unsigned int hash = msymbol_hash_iw (SYMBOL_SEARCH_NAME (sym))
	% MINIMAL_SYMBOL_HASH_SIZE;

      sym->demangled_hash_next = table[hash];
      table[hash] = sym;
    }
}

/* Look through all the current minimal symbol tables and find the
   first minimal symbol that matches NAME.  If OBJF is non-NULL, limit
   the search to that objfile.  If SFILE is non-NULL, the only file-scope
   symbols considered will be from that source file (global symbols are
   still preferred).  Returns a pointer to the minimal symbol that
   matches, or NULL if no match is found.

   Note:  One instance where there may be duplicate minimal symbols with
   the same name is when the symbol tables for a shared library and the
   symbol tables for an executable contain global symbols with the same
   names (the dynamic linker deals with the duplication).

   It's also possible to have minimal symbols with different mangled
   names, but identical demangled names.  For example, the GNU C++ v3
   ABI requires the generation of two (or perhaps three) copies of
   constructor functions --- "in-charge", "not-in-charge", and
   "allocate" copies; destructors may be duplicated as well.
   Obviously, there must be distinct mangled names for each of these,
   but the demangled names are all the same: S::S or S::~S.  */

static struct bound_minimal_symbol
lookup_minimal_symbol_internal (const char *name, const char *sfile,
				struct objfile *objf)
{
  struct objfile *objfile;
  struct bound_minimal_symbol found_symbol = { NULL, NULL };
  struct bound_minimal_symbol found_file_symbol = { NULL, NULL };
  struct bound_minimal_symbol trampoline_symbol = { NULL, NULL };

  unsigned int hash = msymbol_hash (name) % MINIMAL_SYMBOL_HASH_SIZE;
  unsigned int dem_hash = msymbol_hash_iw (name) % MINIMAL_SYMBOL_HASH_SIZE;

  int needtofreename = 0;
  const char *modified_name;

  if (sfile != NULL)
    sfile = lbasename (sfile);

  /* For C++, canonicalize the input name.  */
  modified_name = name;
  if (current_language->la_language == language_cplus)
    {
      char *cname = cp_canonicalize_string (name);

      if (cname)
	{
	  modified_name = cname;
	  needtofreename = 1;
	}
    }

  for (objfile = object_files;
       objfile != NULL && found_symbol.minsym == NULL;
       objfile = objfile->next)
    {
      struct minimal_symbol *msymbol;

      if (objf == NULL || objf == objfile
	  || objf == objfile->separate_debug_objfile_backlink)
	{
	  /* Do two passes: the first over the ordinary hash table,
	     and the second over the demangled hash table.  */
        int pass;

        for (pass = 1; pass <= 2 && found_symbol.minsym == NULL; pass++)
	    {
            /* Select hash list according to pass.  */
            if (pass == 1)
              msymbol = objfile->msymbol_hash[hash];
            else
              msymbol = objfile->msymbol_demangled_hash[dem_hash];

            while (msymbol != NULL && found_symbol.minsym == NULL)
		{
		  int match;

		  if (pass == 1)
		    {
		      int (*cmp) (const char *, const char *);

		      cmp = (case_sensitivity == case_sensitive_on
		             ? strcmp : strcasecmp);
		      match = cmp (SYMBOL_LINKAGE_NAME (msymbol),
				   modified_name) == 0;
		    }
		  else
		    {
		      /* The function respects CASE_SENSITIVITY.  */
		      match = SYMBOL_MATCHES_SEARCH_NAME (msymbol,
							  modified_name);
		    }

		  if (match)
		    {
                    switch (MSYMBOL_TYPE (msymbol))
                      {
                      case mst_file_text:
                      case mst_file_data:
                      case mst_file_bss:
                        if (sfile == NULL
			    || filename_cmp (msymbol->filename, sfile) == 0)
			  {
			    found_file_symbol.minsym = msymbol;
			    found_file_symbol.objfile = objfile;
			  }
                        break;

                      case mst_solib_trampoline:

                        /* If a trampoline symbol is found, we prefer to
                           keep looking for the *real* symbol.  If the
                           actual symbol is not found, then we'll use the
                           trampoline entry.  */
                        if (trampoline_symbol.minsym == NULL)
			  {
			    trampoline_symbol.minsym = msymbol;
			    trampoline_symbol.objfile = objfile;
			  }
                        break;

                      case mst_unknown:
                      default:
                        found_symbol.minsym = msymbol;
			found_symbol.objfile = objfile;
                        break;
                      }
		    }

                /* Find the next symbol on the hash chain.  */
                if (pass == 1)
                  msymbol = msymbol->hash_next;
                else
                  msymbol = msymbol->demangled_hash_next;
		}
	    }
	}
    }

  if (needtofreename)
    xfree ((void *) modified_name);

  /* External symbols are best.  */
  if (found_symbol.minsym != NULL)
    return found_symbol;

  /* File-local symbols are next best.  */
  if (found_file_symbol.minsym != NULL)
    return found_file_symbol;

  /* Symbols for shared library trampolines are next best.  */
  return trampoline_symbol;
}

/* See minsyms.h.  */

struct minimal_symbol *
lookup_minimal_symbol (const char *name, const char *sfile,
		       struct objfile *objf)
{
  struct bound_minimal_symbol bms = lookup_minimal_symbol_internal (name,
								    sfile,
								    objf);

  return bms.minsym;
}

/* See minsyms.h.  */

struct bound_minimal_symbol
lookup_bound_minimal_symbol (const char *name)
{
  return lookup_minimal_symbol_internal (name, NULL, NULL);
}

/* See minsyms.h.  */

void
iterate_over_minimal_symbols (struct objfile *objf, const char *name,
			      void (*callback) (struct minimal_symbol *,
						void *),
			      void *user_data)
{
  unsigned int hash;
  struct minimal_symbol *iter;
  int (*cmp) (const char *, const char *);

  /* The first pass is over the ordinary hash table.  */
  hash = msymbol_hash (name) % MINIMAL_SYMBOL_HASH_SIZE;
  iter = objf->msymbol_hash[hash];
  cmp = (case_sensitivity == case_sensitive_on ? strcmp : strcasecmp);
  while (iter)
    {
      if (cmp (SYMBOL_LINKAGE_NAME (iter), name) == 0)
	(*callback) (iter, user_data);
      iter = iter->hash_next;
    }

  /* The second pass is over the demangled table.  */
  hash = msymbol_hash_iw (name) % MINIMAL_SYMBOL_HASH_SIZE;
  iter = objf->msymbol_demangled_hash[hash];
  while (iter)
    {
      if (SYMBOL_MATCHES_SEARCH_NAME (iter, name))
	(*callback) (iter, user_data);
      iter = iter->demangled_hash_next;
    }
}

/* See minsyms.h.  */

struct minimal_symbol *
lookup_minimal_symbol_text (const char *name, struct objfile *objf)
{
  struct objfile *objfile;
  struct minimal_symbol *msymbol;
  struct minimal_symbol *found_symbol = NULL;
  struct minimal_symbol *found_file_symbol = NULL;

  unsigned int hash = msymbol_hash (name) % MINIMAL_SYMBOL_HASH_SIZE;

  for (objfile = object_files;
       objfile != NULL && found_symbol == NULL;
       objfile = objfile->next)
    {
      if (objf == NULL || objf == objfile
	  || objf == objfile->separate_debug_objfile_backlink)
	{
	  for (msymbol = objfile->msymbol_hash[hash];
	       msymbol != NULL && found_symbol == NULL;
	       msymbol = msymbol->hash_next)
	    {
	      if (strcmp (SYMBOL_LINKAGE_NAME (msymbol), name) == 0 &&
		  (MSYMBOL_TYPE (msymbol) == mst_text
		   || MSYMBOL_TYPE (msymbol) == mst_text_gnu_ifunc
		   || MSYMBOL_TYPE (msymbol) == mst_file_text))
		{
		  switch (MSYMBOL_TYPE (msymbol))
		    {
		    case mst_file_text:
		      found_file_symbol = msymbol;
		      break;
		    default:
		      found_symbol = msymbol;
		      break;
		    }
		}
	    }
	}
    }
  /* External symbols are best.  */
  if (found_symbol)
    return found_symbol;

  /* File-local symbols are next best.  */
  if (found_file_symbol)
    return found_file_symbol;

  return NULL;
}

/* See minsyms.h.  */

struct minimal_symbol *
lookup_minimal_symbol_by_pc_name (CORE_ADDR pc, const char *name,
				  struct objfile *objf)
{
  struct objfile *objfile;
  struct minimal_symbol *msymbol;

  unsigned int hash = msymbol_hash (name) % MINIMAL_SYMBOL_HASH_SIZE;

  for (objfile = object_files;
       objfile != NULL;
       objfile = objfile->next)
    {
      if (objf == NULL || objf == objfile
	  || objf == objfile->separate_debug_objfile_backlink)
	{
	  for (msymbol = objfile->msymbol_hash[hash];
	       msymbol != NULL;
	       msymbol = msymbol->hash_next)
	    {
	      if (SYMBOL_VALUE_ADDRESS (msymbol) == pc
		  && strcmp (SYMBOL_LINKAGE_NAME (msymbol), name) == 0)
		return msymbol;
	    }
	}
    }

  return NULL;
}

/* See minsyms.h.  */

struct minimal_symbol *
lookup_minimal_symbol_solib_trampoline (const char *name,
					struct objfile *objf)
{
  struct objfile *objfile;
  struct minimal_symbol *msymbol;
  struct minimal_symbol *found_symbol = NULL;

  unsigned int hash = msymbol_hash (name) % MINIMAL_SYMBOL_HASH_SIZE;

  for (objfile = object_files;
       objfile != NULL && found_symbol == NULL;
       objfile = objfile->next)
    {
      if (objf == NULL || objf == objfile
	  || objf == objfile->separate_debug_objfile_backlink)
	{
	  for (msymbol = objfile->msymbol_hash[hash];
	       msymbol != NULL && found_symbol == NULL;
	       msymbol = msymbol->hash_next)
	    {
	      if (strcmp (SYMBOL_LINKAGE_NAME (msymbol), name) == 0 &&
		  MSYMBOL_TYPE (msymbol) == mst_solib_trampoline)
		return msymbol;
	    }
	}
    }

  return NULL;
}

/* Search through the minimal symbol table for each objfile and find
   the symbol whose address is the largest address that is still less
   than or equal to PC, and matches SECTION (which is not NULL).
   Returns a pointer to the minimal symbol if such a symbol is found,
   or NULL if PC is not in a suitable range.
   Note that we need to look through ALL the minimal symbol tables
   before deciding on the symbol that comes closest to the specified PC.
   This is because objfiles can overlap, for example objfile A has .text
   at 0x100 and .data at 0x40000 and objfile B has .text at 0x234 and
   .data at 0x40048.

   If WANT_TRAMPOLINE is set, prefer mst_solib_trampoline symbols when
   there are text and trampoline symbols at the same address.
   Otherwise prefer mst_text symbols.  */

static struct bound_minimal_symbol
lookup_minimal_symbol_by_pc_section_1 (CORE_ADDR pc,
				       struct obj_section *section,
				       int want_trampoline)
{
  int lo;
  int hi;
  int new;
  struct objfile *objfile;
  struct minimal_symbol *msymbol;
  struct minimal_symbol *best_symbol = NULL;
  struct objfile *best_objfile = NULL;
  struct bound_minimal_symbol result;
  enum minimal_symbol_type want_type, other_type;

  want_type = want_trampoline ? mst_solib_trampoline : mst_text;
  other_type = want_trampoline ? mst_text : mst_solib_trampoline;

  /* We can not require the symbol found to be in section, because
     e.g. IRIX 6.5 mdebug relies on this code returning an absolute
     symbol - but find_pc_section won't return an absolute section and
     hence the code below would skip over absolute symbols.  We can
     still take advantage of the call to find_pc_section, though - the
     object file still must match.  In case we have separate debug
     files, search both the file and its separate debug file.  There's
     no telling which one will have the minimal symbols.  */

  gdb_assert (section != NULL);

  for (objfile = section->objfile;
       objfile != NULL;
       objfile = objfile_separate_debug_iterate (section->objfile, objfile))
    {
      /* If this objfile has a minimal symbol table, go search it using
         a binary search.  Note that a minimal symbol table always consists
         of at least two symbols, a "real" symbol and the terminating
         "null symbol".  If there are no real symbols, then there is no
         minimal symbol table at all.  */

      if (objfile->minimal_symbol_count > 0)
	{
	  int best_zero_sized = -1;

          msymbol = objfile->msymbols;
	  lo = 0;
	  hi = objfile->minimal_symbol_count - 1;

	  /* This code assumes that the minimal symbols are sorted by
	     ascending address values.  If the pc value is greater than or
	     equal to the first symbol's address, then some symbol in this
	     minimal symbol table is a suitable candidate for being the
	     "best" symbol.  This includes the last real symbol, for cases
	     where the pc value is larger than any address in this vector.

	     By iterating until the address associated with the current
	     hi index (the endpoint of the test interval) is less than
	     or equal to the desired pc value, we accomplish two things:
	     (1) the case where the pc value is larger than any minimal
	     symbol address is trivially solved, (2) the address associated
	     with the hi index is always the one we want when the interation
	     terminates.  In essence, we are iterating the test interval
	     down until the pc value is pushed out of it from the high end.

	     Warning: this code is trickier than it would appear at first.  */

	  /* Should also require that pc is <= end of objfile.  FIXME!  */
	  if (pc >= SYMBOL_VALUE_ADDRESS (&msymbol[lo]))
	    {
	      while (SYMBOL_VALUE_ADDRESS (&msymbol[hi]) > pc)
		{
		  /* pc is still strictly less than highest address.  */
		  /* Note "new" will always be >= lo.  */
		  new = (lo + hi) / 2;
		  if ((SYMBOL_VALUE_ADDRESS (&msymbol[new]) >= pc) ||
		      (lo == new))
		    {
		      hi = new;
		    }
		  else
		    {
		      lo = new;
		    }
		}

	      /* If we have multiple symbols at the same address, we want
	         hi to point to the last one.  That way we can find the
	         right symbol if it has an index greater than hi.  */
	      while (hi < objfile->minimal_symbol_count - 1
		     && (SYMBOL_VALUE_ADDRESS (&msymbol[hi])
			 == SYMBOL_VALUE_ADDRESS (&msymbol[hi + 1])))
		hi++;

	      /* Skip various undesirable symbols.  */
	      while (hi >= 0)
		{
		  /* Skip any absolute symbols.  This is apparently
		     what adb and dbx do, and is needed for the CM-5.
		     There are two known possible problems: (1) on
		     ELF, apparently end, edata, etc. are absolute.
		     Not sure ignoring them here is a big deal, but if
		     we want to use them, the fix would go in
		     elfread.c.  (2) I think shared library entry
		     points on the NeXT are absolute.  If we want
		     special handling for this it probably should be
		     triggered by a special mst_abs_or_lib or some
		     such.  */

		  if (MSYMBOL_TYPE (&msymbol[hi]) == mst_abs)
		    {
		      hi--;
		      continue;
		    }

		  /* If SECTION was specified, skip any symbol from
		     wrong section.  */
		  if (section
		      /* Some types of debug info, such as COFF,
			 don't fill the bfd_section member, so don't
			 throw away symbols on those platforms.  */
		      && SYMBOL_OBJ_SECTION (objfile, &msymbol[hi]) != NULL
		      && (!matching_obj_sections
			  (SYMBOL_OBJ_SECTION (objfile, &msymbol[hi]),
			   section)))
		    {
		      hi--;
		      continue;
		    }

		  /* If we are looking for a trampoline and this is a
		     text symbol, or the other way around, check the
		     preceding symbol too.  If they are otherwise
		     identical prefer that one.  */
		  if (hi > 0
		      && MSYMBOL_TYPE (&msymbol[hi]) == other_type
		      && MSYMBOL_TYPE (&msymbol[hi - 1]) == want_type
		      && (MSYMBOL_SIZE (&msymbol[hi])
			  == MSYMBOL_SIZE (&msymbol[hi - 1]))
		      && (SYMBOL_VALUE_ADDRESS (&msymbol[hi])
			  == SYMBOL_VALUE_ADDRESS (&msymbol[hi - 1]))
		      && (SYMBOL_OBJ_SECTION (objfile, &msymbol[hi])
			  == SYMBOL_OBJ_SECTION (objfile, &msymbol[hi - 1])))
		    {
		      hi--;
		      continue;
		    }

		  /* If the minimal symbol has a zero size, save it
		     but keep scanning backwards looking for one with
		     a non-zero size.  A zero size may mean that the
		     symbol isn't an object or function (e.g. a
		     label), or it may just mean that the size was not
		     specified.  */
		  if (MSYMBOL_SIZE (&msymbol[hi]) == 0
		      && best_zero_sized == -1)
		    {
		      best_zero_sized = hi;
		      hi--;
		      continue;
		    }

		  /* If we are past the end of the current symbol, try
		     the previous symbol if it has a larger overlapping
		     size.  This happens on i686-pc-linux-gnu with glibc;
		     the nocancel variants of system calls are inside
		     the cancellable variants, but both have sizes.  */
		  if (hi > 0
		      && MSYMBOL_SIZE (&msymbol[hi]) != 0
		      && pc >= (SYMBOL_VALUE_ADDRESS (&msymbol[hi])
				+ MSYMBOL_SIZE (&msymbol[hi]))
		      && pc < (SYMBOL_VALUE_ADDRESS (&msymbol[hi - 1])
			       + MSYMBOL_SIZE (&msymbol[hi - 1])))
		    {
		      hi--;
		      continue;
		    }

		  /* Otherwise, this symbol must be as good as we're going
		     to get.  */
		  break;
		}

	      /* If HI has a zero size, and best_zero_sized is set,
		 then we had two or more zero-sized symbols; prefer
		 the first one we found (which may have a higher
		 address).  Also, if we ran off the end, be sure
		 to back up.  */
	      if (best_zero_sized != -1
		  && (hi < 0 || MSYMBOL_SIZE (&msymbol[hi]) == 0))
		hi = best_zero_sized;

	      /* If the minimal symbol has a non-zero size, and this
		 PC appears to be outside the symbol's contents, then
		 refuse to use this symbol.  If we found a zero-sized
		 symbol with an address greater than this symbol's,
		 use that instead.  We assume that if symbols have
		 specified sizes, they do not overlap.  */

	      if (hi >= 0
		  && MSYMBOL_SIZE (&msymbol[hi]) != 0
		  && pc >= (SYMBOL_VALUE_ADDRESS (&msymbol[hi])
			    + MSYMBOL_SIZE (&msymbol[hi])))
		{
		  if (best_zero_sized != -1)
		    hi = best_zero_sized;
		  else
		    /* Go on to the next object file.  */
		    continue;
		}

	      /* The minimal symbol indexed by hi now is the best one in this
	         objfile's minimal symbol table.  See if it is the best one
	         overall.  */

	      if (hi >= 0
		  && ((best_symbol == NULL) ||
		      (SYMBOL_VALUE_ADDRESS (best_symbol) <
		       SYMBOL_VALUE_ADDRESS (&msymbol[hi]))))
		{
		  best_symbol = &msymbol[hi];
		  best_objfile = objfile;
		}
	    }
	}
    }

  result.minsym = best_symbol;
  result.objfile = best_objfile;
  return result;
}

struct bound_minimal_symbol
lookup_minimal_symbol_by_pc_section (CORE_ADDR pc, struct obj_section *section)
{
  if (section == NULL)
    {
      /* NOTE: cagney/2004-01-27: This was using find_pc_mapped_section to
	 force the section but that (well unless you're doing overlay
	 debugging) always returns NULL making the call somewhat useless.  */
      section = find_pc_section (pc);
      if (section == NULL)
	{
	  struct bound_minimal_symbol result;

	  memset (&result, 0, sizeof (result));
	  return result;
	}
    }
  return lookup_minimal_symbol_by_pc_section_1 (pc, section, 0);
}

/* See minsyms.h.  */

struct bound_minimal_symbol
lookup_minimal_symbol_by_pc (CORE_ADDR pc)
{
  struct obj_section *section = find_pc_section (pc);

  if (section == NULL)
    {
      struct bound_minimal_symbol result;

      memset (&result, 0, sizeof (result));
      return result;
    }
  return lookup_minimal_symbol_by_pc_section_1 (pc, section, 0);
}

/* Return non-zero iff PC is in an STT_GNU_IFUNC function resolver.  */

int
in_gnu_ifunc_stub (CORE_ADDR pc)
{
  struct bound_minimal_symbol msymbol = lookup_minimal_symbol_by_pc (pc);

  return msymbol.minsym && MSYMBOL_TYPE (msymbol.minsym) == mst_text_gnu_ifunc;
}

/* See elf_gnu_ifunc_resolve_addr for its real implementation.  */

static CORE_ADDR
stub_gnu_ifunc_resolve_addr (struct gdbarch *gdbarch, CORE_ADDR pc)
{
  error (_("GDB cannot resolve STT_GNU_IFUNC symbol at address %s without "
	   "the ELF support compiled in."),
	 paddress (gdbarch, pc));
}

/* See elf_gnu_ifunc_resolve_name for its real implementation.  */

static int
stub_gnu_ifunc_resolve_name (const char *function_name,
			     CORE_ADDR *function_address_p)
{
  error (_("GDB cannot resolve STT_GNU_IFUNC symbol \"%s\" without "
	   "the ELF support compiled in."),
	 function_name);
}

/* See elf_gnu_ifunc_resolver_stop for its real implementation.  */

static void
stub_gnu_ifunc_resolver_stop (struct breakpoint *b)
{
  internal_error (__FILE__, __LINE__,
		  _("elf_gnu_ifunc_resolver_stop cannot be reached."));
}

/* See elf_gnu_ifunc_resolver_return_stop for its real implementation.  */

static void
stub_gnu_ifunc_resolver_return_stop (struct breakpoint *b)
{
  internal_error (__FILE__, __LINE__,
		  _("elf_gnu_ifunc_resolver_return_stop cannot be reached."));
}

/* See elf_gnu_ifunc_fns for its real implementation.  */

static const struct gnu_ifunc_fns stub_gnu_ifunc_fns =
{
  stub_gnu_ifunc_resolve_addr,
  stub_gnu_ifunc_resolve_name,
  stub_gnu_ifunc_resolver_stop,
  stub_gnu_ifunc_resolver_return_stop,
};

/* A placeholder for &elf_gnu_ifunc_fns.  */

const struct gnu_ifunc_fns *gnu_ifunc_fns_p = &stub_gnu_ifunc_fns;

/* See minsyms.h.  */

struct bound_minimal_symbol
lookup_minimal_symbol_and_objfile (const char *name)
{
  struct bound_minimal_symbol result;
  struct objfile *objfile;
  unsigned int hash = msymbol_hash (name) % MINIMAL_SYMBOL_HASH_SIZE;

  ALL_OBJFILES (objfile)
    {
      struct minimal_symbol *msym;

      for (msym = objfile->msymbol_hash[hash];
	   msym != NULL;
	   msym = msym->hash_next)
	{
	  if (strcmp (SYMBOL_LINKAGE_NAME (msym), name) == 0)
	    {
	      result.minsym = msym;
	      result.objfile = objfile;
	      return result;
	    }
	}
    }

  memset (&result, 0, sizeof (result));
  return result;
}


/* Return leading symbol character for a BFD.  If BFD is NULL,
   return the leading symbol character from the main objfile.  */

static int get_symbol_leading_char (bfd *);

static int
get_symbol_leading_char (bfd *abfd)
{
  if (abfd != NULL)
    return bfd_get_symbol_leading_char (abfd);
  if (symfile_objfile != NULL && symfile_objfile->obfd != NULL)
    return bfd_get_symbol_leading_char (symfile_objfile->obfd);
  return 0;
}

/* See minsyms.h.  */

void
init_minimal_symbol_collection (void)
{
  msym_count = 0;
  msym_bunch = NULL;
  /* Note that presetting msym_bunch_index to BUNCH_SIZE causes the
     first call to save a minimal symbol to allocate the memory for
     the first bunch.  */
  msym_bunch_index = BUNCH_SIZE;
}

/* See minsyms.h.  */

void
prim_record_minimal_symbol (const char *name, CORE_ADDR address,
			    enum minimal_symbol_type ms_type,
			    struct objfile *objfile)
{
  int section;

  switch (ms_type)
    {
    case mst_text:
    case mst_text_gnu_ifunc:
    case mst_file_text:
    case mst_solib_trampoline:
      section = SECT_OFF_TEXT (objfile);
      break;
    case mst_data:
    case mst_file_data:
      section = SECT_OFF_DATA (objfile);
      break;
    case mst_bss:
    case mst_file_bss:
      section = SECT_OFF_BSS (objfile);
      break;
    default:
      section = -1;
    }

  prim_record_minimal_symbol_and_info (name, address, ms_type,
				       section, objfile);
}

/* See minsyms.h.  */

struct minimal_symbol *
prim_record_minimal_symbol_full (const char *name, int name_len, int copy_name,
				 CORE_ADDR address,
				 enum minimal_symbol_type ms_type,
				 int section,
				 struct objfile *objfile)
{
  struct obj_section *obj_section;
  struct msym_bunch *new;
  struct minimal_symbol *msymbol;

  /* Don't put gcc_compiled, __gnu_compiled_cplus, and friends into
     the minimal symbols, because if there is also another symbol
     at the same address (e.g. the first function of the file),
     lookup_minimal_symbol_by_pc would have no way of getting the
     right one.  */
  if (ms_type == mst_file_text && name[0] == 'g'
      && (strcmp (name, GCC_COMPILED_FLAG_SYMBOL) == 0
	  || strcmp (name, GCC2_COMPILED_FLAG_SYMBOL) == 0))
    return (NULL);

  /* It's safe to strip the leading char here once, since the name
     is also stored stripped in the minimal symbol table.  */
  if (name[0] == get_symbol_leading_char (objfile->obfd))
    {
      ++name;
      --name_len;
    }

  if (ms_type == mst_file_text && strncmp (name, "__gnu_compiled", 14) == 0)
    return (NULL);

  if (msym_bunch_index == BUNCH_SIZE)
    {
      new = XCALLOC (1, struct msym_bunch);
      msym_bunch_index = 0;
      new->next = msym_bunch;
      msym_bunch = new;
    }
  msymbol = &msym_bunch->contents[msym_bunch_index];
  SYMBOL_SET_LANGUAGE (msymbol, language_auto, &objfile->objfile_obstack);
  SYMBOL_SET_NAMES (msymbol, name, name_len, copy_name, objfile);

  SYMBOL_VALUE_ADDRESS (msymbol) = address;
  SYMBOL_SECTION (msymbol) = section;

  MSYMBOL_TYPE (msymbol) = ms_type;
  MSYMBOL_TARGET_FLAG_1 (msymbol) = 0;
  MSYMBOL_TARGET_FLAG_2 (msymbol) = 0;
  /* Do not use the SET_MSYMBOL_SIZE macro to initialize the size,
     as it would also set the has_size flag.  */
  msymbol->size = 0;

  /* The hash pointers must be cleared! If they're not,
     add_minsym_to_hash_table will NOT add this msymbol to the hash table.  */
  msymbol->hash_next = NULL;
  msymbol->demangled_hash_next = NULL;

  msym_bunch_index++;
  msym_count++;
  OBJSTAT (objfile, n_minsyms++);
  return msymbol;
}

/* See minsyms.h.  */

struct minimal_symbol *
prim_record_minimal_symbol_and_info (const char *name, CORE_ADDR address,
				     enum minimal_symbol_type ms_type,
				     int section,
				     struct objfile *objfile)
{
  return prim_record_minimal_symbol_full (name, strlen (name), 1,
					  address, ms_type,
					  section, objfile);
}

/* Compare two minimal symbols by address and return a signed result based
   on unsigned comparisons, so that we sort into unsigned numeric order.
   Within groups with the same address, sort by name.  */

static int
compare_minimal_symbols (const void *fn1p, const void *fn2p)
{
  const struct minimal_symbol *fn1;
  const struct minimal_symbol *fn2;

  fn1 = (const struct minimal_symbol *) fn1p;
  fn2 = (const struct minimal_symbol *) fn2p;

  if (SYMBOL_VALUE_ADDRESS (fn1) < SYMBOL_VALUE_ADDRESS (fn2))
    {
      return (-1);		/* addr 1 is less than addr 2.  */
    }
  else if (SYMBOL_VALUE_ADDRESS (fn1) > SYMBOL_VALUE_ADDRESS (fn2))
    {
      return (1);		/* addr 1 is greater than addr 2.  */
    }
  else
    /* addrs are equal: sort by name */
    {
      const char *name1 = SYMBOL_LINKAGE_NAME (fn1);
      const char *name2 = SYMBOL_LINKAGE_NAME (fn2);

      if (name1 && name2)	/* both have names */
	return strcmp (name1, name2);
      else if (name2)
	return 1;		/* fn1 has no name, so it is "less".  */
      else if (name1)		/* fn2 has no name, so it is "less".  */
	return -1;
      else
	return (0);		/* Neither has a name, so they're equal.  */
    }
}

/* Discard the currently collected minimal symbols, if any.  If we wish
   to save them for later use, we must have already copied them somewhere
   else before calling this function.

   FIXME:  We could allocate the minimal symbol bunches on their own
   obstack and then simply blow the obstack away when we are done with
   it.  Is it worth the extra trouble though?  */

static void
do_discard_minimal_symbols_cleanup (void *arg)
{
  struct msym_bunch *next;

  while (msym_bunch != NULL)
    {
      next = msym_bunch->next;
      xfree (msym_bunch);
      msym_bunch = next;
    }
}

/* See minsyms.h.  */

struct cleanup *
make_cleanup_discard_minimal_symbols (void)
{
  return make_cleanup (do_discard_minimal_symbols_cleanup, 0);
}



/* Compact duplicate entries out of a minimal symbol table by walking
   through the table and compacting out entries with duplicate addresses
   and matching names.  Return the number of entries remaining.

   On entry, the table resides between msymbol[0] and msymbol[mcount].
   On exit, it resides between msymbol[0] and msymbol[result_count].

   When files contain multiple sources of symbol information, it is
   possible for the minimal symbol table to contain many duplicate entries.
   As an example, SVR4 systems use ELF formatted object files, which
   usually contain at least two different types of symbol tables (a
   standard ELF one and a smaller dynamic linking table), as well as
   DWARF debugging information for files compiled with -g.

   Without compacting, the minimal symbol table for gdb itself contains
   over a 1000 duplicates, about a third of the total table size.  Aside
   from the potential trap of not noticing that two successive entries
   identify the same location, this duplication impacts the time required
   to linearly scan the table, which is done in a number of places.  So we
   just do one linear scan here and toss out the duplicates.

   Note that we are not concerned here about recovering the space that
   is potentially freed up, because the strings themselves are allocated
   on the objfile_obstack, and will get automatically freed when the symbol
   table is freed.  The caller can free up the unused minimal symbols at
   the end of the compacted region if their allocation strategy allows it.

   Also note we only go up to the next to last entry within the loop
   and then copy the last entry explicitly after the loop terminates.

   Since the different sources of information for each symbol may
   have different levels of "completeness", we may have duplicates
   that have one entry with type "mst_unknown" and the other with a
   known type.  So if the one we are leaving alone has type mst_unknown,
   overwrite its type with the type from the one we are compacting out.  */

static int
compact_minimal_symbols (struct minimal_symbol *msymbol, int mcount,
			 struct objfile *objfile)
{
  struct minimal_symbol *copyfrom;
  struct minimal_symbol *copyto;

  if (mcount > 0)
    {
      copyfrom = copyto = msymbol;
      while (copyfrom < msymbol + mcount - 1)
	{
	  if (SYMBOL_VALUE_ADDRESS (copyfrom)
	      == SYMBOL_VALUE_ADDRESS ((copyfrom + 1))
	      && strcmp (SYMBOL_LINKAGE_NAME (copyfrom),
			 SYMBOL_LINKAGE_NAME ((copyfrom + 1))) == 0)
	    {
	      if (MSYMBOL_TYPE ((copyfrom + 1)) == mst_unknown)
		{
		  MSYMBOL_TYPE ((copyfrom + 1)) = MSYMBOL_TYPE (copyfrom);
		}
	      copyfrom++;
	    }
	  else
	    *copyto++ = *copyfrom++;
	}
      *copyto++ = *copyfrom++;
      mcount = copyto - msymbol;
    }
  return (mcount);
}

/* Build (or rebuild) the minimal symbol hash tables.  This is necessary
   after compacting or sorting the table since the entries move around
   thus causing the internal minimal_symbol pointers to become jumbled.  */
  
static void
build_minimal_symbol_hash_tables (struct objfile *objfile)
{
  int i;
  struct minimal_symbol *msym;

  /* Clear the hash tables.  */
  for (i = 0; i < MINIMAL_SYMBOL_HASH_SIZE; i++)
    {
      objfile->msymbol_hash[i] = 0;
      objfile->msymbol_demangled_hash[i] = 0;
    }

  /* Now, (re)insert the actual entries.  */
  for (i = objfile->minimal_symbol_count, msym = objfile->msymbols;
       i > 0;
       i--, msym++)
    {
      msym->hash_next = 0;
      add_minsym_to_hash_table (msym, objfile->msymbol_hash);

      msym->demangled_hash_next = 0;
      if (SYMBOL_SEARCH_NAME (msym) != SYMBOL_LINKAGE_NAME (msym))
	add_minsym_to_demangled_hash_table (msym,
                                            objfile->msymbol_demangled_hash);
    }
}

/* Add the minimal symbols in the existing bunches to the objfile's official
   minimal symbol table.  In most cases there is no minimal symbol table yet
   for this objfile, and the existing bunches are used to create one.  Once
   in a while (for shared libraries for example), we add symbols (e.g. common
   symbols) to an existing objfile.

   Because of the way minimal symbols are collected, we generally have no way
   of knowing what source language applies to any particular minimal symbol.
   Specifically, we have no way of knowing if the minimal symbol comes from a
   C++ compilation unit or not.  So for the sake of supporting cached
   demangled C++ names, we have no choice but to try and demangle each new one
   that comes in.  If the demangling succeeds, then we assume it is a C++
   symbol and set the symbol's language and demangled name fields
   appropriately.  Note that in order to avoid unnecessary demanglings, and
   allocating obstack space that subsequently can't be freed for the demangled
   names, we mark all newly added symbols with language_auto.  After
   compaction of the minimal symbols, we go back and scan the entire minimal
   symbol table looking for these new symbols.  For each new symbol we attempt
   to demangle it, and if successful, record it as a language_cplus symbol
   and cache the demangled form on the symbol obstack.  Symbols which don't
   demangle are marked as language_unknown symbols, which inhibits future
   attempts to demangle them if we later add more minimal symbols.  */

void
install_minimal_symbols (struct objfile *objfile)
{
  int bindex;
  int mcount;
  struct msym_bunch *bunch;
  struct minimal_symbol *msymbols;
  int alloc_count;

  if (msym_count > 0)
    {
      if (symtab_create_debug)
	{
	  fprintf_unfiltered (gdb_stdlog,
			      "Installing %d minimal symbols of objfile %s.\n",
			      msym_count, objfile_name (objfile));
	}

      /* Allocate enough space in the obstack, into which we will gather the
         bunches of new and existing minimal symbols, sort them, and then
         compact out the duplicate entries.  Once we have a final table,
         we will give back the excess space.  */

      alloc_count = msym_count + objfile->minimal_symbol_count + 1;
      obstack_blank (&objfile->objfile_obstack,
		     alloc_count * sizeof (struct minimal_symbol));
      msymbols = (struct minimal_symbol *)
	obstack_base (&objfile->objfile_obstack);

      /* Copy in the existing minimal symbols, if there are any.  */

      if (objfile->minimal_symbol_count)
	memcpy ((char *) msymbols, (char *) objfile->msymbols,
	    objfile->minimal_symbol_count * sizeof (struct minimal_symbol));

      /* Walk through the list of minimal symbol bunches, adding each symbol
         to the new contiguous array of symbols.  Note that we start with the
         current, possibly partially filled bunch (thus we use the current
         msym_bunch_index for the first bunch we copy over), and thereafter
         each bunch is full.  */

      mcount = objfile->minimal_symbol_count;

      for (bunch = msym_bunch; bunch != NULL; bunch = bunch->next)
	{
	  for (bindex = 0; bindex < msym_bunch_index; bindex++, mcount++)
	    msymbols[mcount] = bunch->contents[bindex];
	  msym_bunch_index = BUNCH_SIZE;
	}

      /* Sort the minimal symbols by address.  */

      qsort (msymbols, mcount, sizeof (struct minimal_symbol),
	     compare_minimal_symbols);

      /* Compact out any duplicates, and free up whatever space we are
         no longer using.  */

      mcount = compact_minimal_symbols (msymbols, mcount, objfile);

      obstack_blank (&objfile->objfile_obstack,
	       (mcount + 1 - alloc_count) * sizeof (struct minimal_symbol));
      msymbols = (struct minimal_symbol *)
	obstack_finish (&objfile->objfile_obstack);

      /* We also terminate the minimal symbol table with a "null symbol",
         which is *not* included in the size of the table.  This makes it
         easier to find the end of the table when we are handed a pointer
         to some symbol in the middle of it.  Zero out the fields in the
         "null symbol" allocated at the end of the array.  Note that the
         symbol count does *not* include this null symbol, which is why it
         is indexed by mcount and not mcount-1.  */

      memset (&msymbols[mcount], 0, sizeof (struct minimal_symbol));

      /* Attach the minimal symbol table to the specified objfile.
         The strings themselves are also located in the objfile_obstack
         of this objfile.  */

      objfile->minimal_symbol_count = mcount;
      objfile->msymbols = msymbols;

      /* Now build the hash tables; we can't do this incrementally
         at an earlier point since we weren't finished with the obstack
	 yet.  (And if the msymbol obstack gets moved, all the internal
	 pointers to other msymbols need to be adjusted.)  */
      build_minimal_symbol_hash_tables (objfile);
    }
}

/* See minsyms.h.  */

void
terminate_minimal_symbol_table (struct objfile *objfile)
{
  if (! objfile->msymbols)
    objfile->msymbols = ((struct minimal_symbol *)
                         obstack_alloc (&objfile->objfile_obstack,
                                        sizeof (objfile->msymbols[0])));

  {
    struct minimal_symbol *m
      = &objfile->msymbols[objfile->minimal_symbol_count];

    memset (m, 0, sizeof (*m));
    /* Don't rely on these enumeration values being 0's.  */
    MSYMBOL_TYPE (m) = mst_unknown;
    SYMBOL_SET_LANGUAGE (m, language_unknown, &objfile->objfile_obstack);
  }
}

/* Sort all the minimal symbols in OBJFILE.  */

void
msymbols_sort (struct objfile *objfile)
{
  qsort (objfile->msymbols, objfile->minimal_symbol_count,
	 sizeof (struct minimal_symbol), compare_minimal_symbols);
  build_minimal_symbol_hash_tables (objfile);
}

/* Check if PC is in a shared library trampoline code stub.
   Return minimal symbol for the trampoline entry or NULL if PC is not
   in a trampoline code stub.  */

static struct minimal_symbol *
lookup_solib_trampoline_symbol_by_pc (CORE_ADDR pc)
{
  struct obj_section *section = find_pc_section (pc);
  struct bound_minimal_symbol msymbol;

  if (section == NULL)
    return NULL;
  msymbol = lookup_minimal_symbol_by_pc_section_1 (pc, section, 1);

  if (msymbol.minsym != NULL
      && MSYMBOL_TYPE (msymbol.minsym) == mst_solib_trampoline)
    return msymbol.minsym;
  return NULL;
}

/* If PC is in a shared library trampoline code stub, return the
   address of the `real' function belonging to the stub.
   Return 0 if PC is not in a trampoline code stub or if the real
   function is not found in the minimal symbol table.

   We may fail to find the right function if a function with the
   same name is defined in more than one shared library, but this
   is considered bad programming style.  We could return 0 if we find
   a duplicate function in case this matters someday.  */

CORE_ADDR
find_solib_trampoline_target (struct frame_info *frame, CORE_ADDR pc)
{
  struct objfile *objfile;
  struct minimal_symbol *msymbol;
  struct minimal_symbol *tsymbol = lookup_solib_trampoline_symbol_by_pc (pc);

  if (tsymbol != NULL)
    {
      ALL_MSYMBOLS (objfile, msymbol)
      {
	if ((MSYMBOL_TYPE (msymbol) == mst_text
	    || MSYMBOL_TYPE (msymbol) == mst_text_gnu_ifunc)
	    && strcmp (SYMBOL_LINKAGE_NAME (msymbol),
		       SYMBOL_LINKAGE_NAME (tsymbol)) == 0)
	  return SYMBOL_VALUE_ADDRESS (msymbol);

	/* Also handle minimal symbols pointing to function descriptors.  */
	if (MSYMBOL_TYPE (msymbol) == mst_data
	    && strcmp (SYMBOL_LINKAGE_NAME (msymbol),
		       SYMBOL_LINKAGE_NAME (tsymbol)) == 0)
	  {
	    CORE_ADDR func;

	    func = gdbarch_convert_from_func_ptr_addr
		    (get_objfile_arch (objfile),
		     SYMBOL_VALUE_ADDRESS (msymbol),
		     &current_target);

	    /* Ignore data symbols that are not function descriptors.  */
	    if (func != SYMBOL_VALUE_ADDRESS (msymbol))
	      return func;
	  }
      }
    }
  return 0;
}
@


1.102
log
@remove msymbol_objfile

This is another patch in my ongoing series to "split" objfile to share
more read-only data across inferiors.  See

    http://sourceware.org/gdb/wiki/ObjfileSplitting

When symbols are finally shared, there will be no back-link from the
symbol to its containing objfile, because there may be more than one
such objfile.  So, all such back-links must be removed.

One hidden back-link is the msymbol_objfile function.  Since
(eventually) a symbol may appear in more than one objfile, trying to
look up the objfile given just a symbol cannot work.

This patch removes msymbol_objfile in favor of using a bound minimal
symbol.  It introduces a new function to make this conversion simpler
in some spots.

The bonus of this patch is that using msymbol_objfile is slower than
simply looking up the owning objfile in the first place.

Built and regtested on x86-64 Fedora 18.

	* ada-exp.y (write_var_or_type): Use bound_minimal_symbol.
	* ada-lang.c (ada_lookup_simple_minsym): Return
	bound_minimal_symbol.
	* ada-lang.h (ada_lookup_simple_minsym): Update.
	* c-exp.y (variable): Use lookup_bound_minimal_symbol.
	* f-exp.y (variable): Use lookup_bound_minimal_symbol.
	* go-exp.y (variable): Use lookup_bound_minimal_symbol.
	* jv-exp.y (push_expression_name): Use lookup_bound_minimal_symbol.
	* m2-exp.y (variable): Use lookup_bound_minimal_symbol.
	* minsyms.c (msymbol_objfile): Remove.
	(lookup_minimal_symbol_internal): New function, from
	lookup_minimal_symbol.
	(lookup_minimal_symbol): Rewrite using
	lookup_minimal_symbol_internal.
	(lookup_bound_minimal_symbol): New function.
	* minsyms.h (msymbol_objfile): Remove.
	(lookup_bound_minimal_symbol): Declare.
	* p-exp.y (variable): Use lookup_bound_minimal_symbol.
	* parse.c (write_exp_msymbol): Change parameter to a
	bound_minimal_symbol.
	(write_dollar_variable): Use lookup_bound_minimal_symbol.
	* parser-defs.h (write_exp_msymbol): Update.
	* printcmd.c (address_info): Use lookup_bound_minimal_symbol.
	* symfile.c (simple_read_overlay_table): Use
	lookup_bound_minimal_symbol.
	* symtab.c (skip_prologue_sal): Don't use msymbol_objfile.
	(search_symbols): Likewise.
	(print_msymbol_info): Take a bound_minimal_symbol argument.
	(symtab_symbol_info, rbreak_command): Update.
	* symtab.h (struct symbol_search) <msymbol>: Change type
	to bound_minimal_symbol.
	* valops.c (find_function_in_inferior): Use
	lookup_bound_minimal_symbol.
	* value.c (value_fn_field): Use lookup_bound_minimal_symbol.
@
text
@d1190 1
a1190 1
			      msym_count, objfile->name);
@


1.101
log
@	PR symtab/8424:
	* blockframe.c (find_pc_partial_function_gnu_ifunc): Check
	SYMBOL_SECTION, not SYMBOL_OBJ_SECTION.
	* breakpoint.c (resolve_sal_pc): Update.
	* elfread.c (elf_gnu_ifunc_record_cache): Update.
	* findvar.c (struct minsym_lookup_data) <objfile>: New field.
	(minsym_lookup_iterator_cb): Use it.
	(default_read_var_value): Update.
	* hppa-hpux-tdep.c (hppa64_hpux_in_solib_call_trampoline):
	Update.
	* infcmd.c (jump_command): Update.
	* linespec.c (minsym_found): Update.
	* maint.c (maintenance_translate_address): Update.
	* minsyms.c (lookup_minimal_symbol_by_pc_section_1): Update.
	(prim_record_minimal_symbol_full): Don't set SYMBOL_OBJ_SECTION.
	* parse.c (write_exp_msymbol): Update.
	* printcmd.c (address_info): Update.
	* psymtab.c (find_pc_sect_psymbol): Update.
	(fixup_psymbol_section): Check SYMBOL_SECTION, not
	SYMBOL_OBJ_SECTION.
	(add_psymbol_to_bcache): Correctly initialize SYMBOL_SECTION.
	Don't initialize SYMBOL_OBJ_SECTION.
	* spu-tdep.c (spu_catch_start): Update.
	* stabsread.c (define_symbol): Don't set SYMBOL_SECTION.
	* symmisc.c (dump_msymbols, print_symbol): Update.
	* symtab.c (fixup_section): Don't set 'obj_section'.  Change
	how fallback section is computed.
	(fixup_symbol_section): Update.
	(find_pc_sect_symtab, find_function_start_sal, skip_prologue_sal):
	Update.
	(allocate_symbol, initialize_symbol, allocate_template_symbol):
	Initialize SYMBOL_SECTION.
	* symtab.h (struct general_symbol_info) <section>: Update comment.
	<obj_section>: Remove.
	(SYMBOL_OBJ_SECTION): Add 'objfile' argument.  Rewrite.
	(SYMBOL_OBJFILE): New macro.
@
text
@a141 21
/* See minsyms.h.  */

struct objfile *
msymbol_objfile (struct minimal_symbol *sym)
{
  struct objfile *objf;
  struct minimal_symbol *tsym;

  unsigned int hash
    = msymbol_hash (SYMBOL_LINKAGE_NAME (sym)) % MINIMAL_SYMBOL_HASH_SIZE;

  for (objf = object_files; objf; objf = objf->next)
    for (tsym = objf->msymbol_hash[hash]; tsym; tsym = tsym->hash_next)
      if (tsym == sym)
	return objf;

  /* We should always be able to find the objfile ...  */
  internal_error (__FILE__, __LINE__, _("failed internal consistency check"));
}


d162 3
a164 3
struct minimal_symbol *
lookup_minimal_symbol (const char *name, const char *sfile,
		       struct objfile *objf)
d167 3
a169 4
  struct minimal_symbol *msymbol;
  struct minimal_symbol *found_symbol = NULL;
  struct minimal_symbol *found_file_symbol = NULL;
  struct minimal_symbol *trampoline_symbol = NULL;
d194 1
a194 1
       objfile != NULL && found_symbol == NULL;
d197 2
d206 1
a206 1
        for (pass = 1; pass <= 2 && found_symbol == NULL; pass++)
d214 1
a214 1
            while (msymbol != NULL && found_symbol == NULL)
d243 4
a246 1
                          found_file_symbol = msymbol;
d255 5
a259 2
                        if (trampoline_symbol == NULL)
                          trampoline_symbol = msymbol;
d264 2
a265 1
                        found_symbol = msymbol;
d284 1
a284 1
  if (found_symbol)
d288 1
a288 1
  if (found_file_symbol)
d292 4
a295 2
  if (trampoline_symbol)
    return trampoline_symbol;
d297 17
a313 1
  return NULL;
@


1.100
log
@	* coffread.c (record_minimal_symbol): Update.
	* dbxread.c (record_minimal_symbol): Update.
	* elfread.c (record_minimal_symbol): Update.
	* machoread.c (macho_symtab_add_minsym): Update.
	* mdebugread.c (record_minimal_symbol, parse_partial_symbols):
	Update.
	* minsyms.c (prim_record_minimal_symbol): Update.
	(prim_record_minimal_symbol_full): Remove 'bfd_section'
	argument.
	(prim_record_minimal_symbol_and_info): Likewise.
	* minsyms.h (prim_record_minimal_symbol_full)
	(prim_record_minimal_symbol_and_info): Update.
	* symtab.c (allocate_symbol, initialize_symbol)
	(allocate_template_symbol): Initialize SYMBOL_SECTION.
	* xcoffread.c (record_minimal_symbol, scan_xcoff_symtab):
	Update.
@
text
@d596 1
a596 1
		      && SYMBOL_OBJ_SECTION (&msymbol[hi]) != NULL
d598 2
a599 1
			  (SYMBOL_OBJ_SECTION (&msymbol[hi]), section)))
d616 2
a617 2
		      && (SYMBOL_OBJ_SECTION (&msymbol[hi])
			  == SYMBOL_OBJ_SECTION (&msymbol[hi - 1])))
a945 1
  SYMBOL_OBJ_SECTION (msymbol) = NULL;
@


1.99
log
@	* minsyms.h (struct bound_minimal_symbol): New.
	(lookup_minimal_symbol_and_objfile): Return bound_minimal_symbol.
	Remove objfile argument.
	(lookup_minimal_symbol_by_pc_section, lookup_minimal_symbol_by_pc):
	Return bound_minimal_symbol.
	* minsyms.c (lookup_minimal_symbol_by_pc_1)
	(lookup_minimal_symbol_by_pc_section, lookup_minimal_symbol_by_pc):
	Return bound_minimal_symbol.
	(in_gnu_ifunc_stub): Update.
	(lookup_minimal_symbol_and_objfile): Return bound_minimal_symbol.
	Remove 'objfile_p' argument.
	(lookup_solib_trampoline_symbol_by_pc): Update.
	* ada-tasks.c, amd64-windows-tdep.c, arm-tdep.c,
	arm-wince-tdep.c, block.c, blockframe.c, breakpoint.c, btrace.c,
	c-valprint.c, dwarf2loc.c, elfread.c, frame.c, frv-tdep.c,
	glibc-tdep.c, gnu-v2-abi.c, gnu-v3-abi.c, hppa-hpux-tdep.c,
	i386-tdep.c, ia64-tdep.c, infcall.c, infcmd.c, jit.c,
	linux-fork.c, m32c-tdep.c, m68hc11-tdep.c, maint.c,
	mips-tdep.c, p-valprint.c, parse.c, ppc-linux-tdep.c,
	ppc-sysv-tdep.c, printcmd.c, rs6000-tdep.c, sh64-tdep.c,
	stack.c, symtab.c, tui/tui-disasm.c: Update.
@
text
@d895 1
a895 1
				       section, NULL, objfile);
a904 1
				 asection *bfd_section,
a946 11
  /* Find obj_section corresponding to bfd_section.  */
  if (bfd_section)
    ALL_OBJFILE_OSECTIONS (objfile, obj_section)
      {
	if (obj_section->the_bfd_section == bfd_section)
	  {
	    SYMBOL_OBJ_SECTION (msymbol) = obj_section;
	    break;
	  }
      }

a970 1
				     asection *bfd_section,
d974 2
a975 2
					  address, ms_type, section,
					  bfd_section, objfile);
@


1.98
log
@	* ada-lang.c (ada_decode_symbol): Check and set 'ada_mangled'.
	Use symbol's obstack, not an objfile.
	* coffread.c (process_coff_symbol): Update.
	* dwarf2read.c (fixup_go_packaging, new_symbol_full): Update.
	* jv-lang.c (add_class_symbol): Update.
	* mdebugread.c (new_symbol): Update.
	* minsyms.c (prim_record_minimal_symbol_full)
	(terminate_minimal_symbol_table): Update.
	* psymtab.c (add_psymbol_to_bcache): Clear entire symbol.  Update.
	* stabsread.c (define_symbol, read_enum_type): Update.
	* symtab.c (symbol_set_demangled_name, symbol_get_demangled_name):
	Handle Ada specially.
	(symbol_set_language): Add 'obstack' argument.
	(symbol_set_names): Update.
	(symbol_natural_name, symbol_demangled_name): Always use
	ada_decode_symbol.
	* symtab.h (struct general_symbol_info)
	<language_specific::obstack>: New field.
	<ada_mangled>: New field.
	(SYMBOL_SET_LANGUAGE): Add 'obstack' argument.
	(symbol_set_language): Update.
@
text
@d477 1
a477 1
static struct minimal_symbol *
d488 2
d695 1
d700 4
a703 1
  return (best_symbol);
d706 1
a706 1
struct minimal_symbol *
d716 6
a721 1
	return NULL;
d728 1
a728 1
struct minimal_symbol *
d731 10
a740 1
  return lookup_minimal_symbol_by_pc_section (pc, NULL);
d748 1
a748 1
  struct minimal_symbol *msymbol = lookup_minimal_symbol_by_pc (pc);
d750 1
a750 1
  return msymbol && MSYMBOL_TYPE (msymbol) == mst_text_gnu_ifunc;
d808 2
a809 3
struct minimal_symbol *
lookup_minimal_symbol_and_objfile (const char *name,
				   struct objfile **objfile_p)
d811 1
d825 3
a827 2
	      *objfile_p = objfile;
	      return msym;
d832 2
a833 1
  return 0;
d1312 1
a1312 1
  struct minimal_symbol *msymbol;
d1318 3
a1320 2
  if (msymbol != NULL && MSYMBOL_TYPE (msymbol) == mst_solib_trampoline)
    return msymbol;
@


1.97
log
@	* breakpoint.c (catch_syscall_split_args): Use skip_spaces.
	(trace_pass_command): Likewise.
	* cli/cli-cmds.c: Include cli/cli-utils.h.
	(source_command): Use skip-spaces.
	(disassemble_command): Likewise.
	* findcmd.c: Include cli/cli-utils.h.
	(parse_find_args): Use skip_spaces.
	* go32-nat.c: Include cli/cli-utils.h.
	(go32_sldt): Use skip_spaces.
	(go32_sgdt): Likewise.
	(go32_sidt): Likewise.
	(go32_pde): Likewise.
	(go32_pte): Likewise.
	(go32_pte_for_address): Likewise.
	* infcmd.c: Include cli/cli-utils.h.
	(registers_info): Use skip_spaces.
	* linux-tdep.c (read_mapping): Use skip_spaces_const.
	(linux_info_proc): Likewise.
	* linux-thread-db.c: Include cli/cli-utils.h.
	(info_auto_load_libthread_db): Use skip_spaces_const.
	* m32r-rom.c: Include cli/cli-utils.h.
	(m32r_upload_command): Use skip_spaces.
	* maint.c: Include cli/cli-utils.h.
	(maintenance_translate_address): Use skip_spaces.
	* mi/mi-parse.c: Include cli/cli-utils.h.
	(mi_parse_argv): Use skip_spaces.
	(mi_parse): Likewise.
	* minsyms.c: Include cli/cli-utils.h.
	(msymbol_hash_iw): Use skip_spaces_const.
	* objc-lang.c: Include cli/cli-utils.h.
	(parse_selector): Use skip_spaces.
	(parse_method): Likewise.
	* python/python.c: Include cli/cli-utils.h.
	(python_interactive_command)[HAVE_PYTHON]: Use skip_spaces.
	(python_command)[HAVE_PYTHON]: Likewise.
	(python_interactive_command)[!HAVE_PYTHON]: Likewise.
	* remote-m32r-sdi.c: Include cli/cli-utils.h.
	(m32r_load): Use skip_spaces.
	* serial.c: Include cli/cli-utils.h.
	(serial_open): Use skip_spaces_const.
	* stack.c: Include cli/cli-utils.h.
	(parse_frame_specification_1): Use skip_spaces_const.
	* symfile.c: Include cli/cli-utils.h.
	(set_ext_lang_command): Use skip_spaces.
	* symtab.c: Include cli/cli-utils.h.
	(rbreak_command): Use skip_spaces.
	* thread.c (thread_name_command): Use skip_spaces.
	* tracepoint.c (validate_actionline): Use skip_spaces.
	(encode_actions_1): Likewise.
	(trace_find_range_command): Likewise.
	(trace_find_outside_command): Likewise.
	(trace_dump_actions): Likewise.
@
text
@d919 1
a919 1
  SYMBOL_SET_LANGUAGE (msymbol, language_auto);
d1268 1
a1268 1
    SYMBOL_SET_LANGUAGE (m, language_unknown);
@


1.96
log
@	* gnu-v2-abi.c (_initialize_gnu_v2_abi): Don't set default ABI.
	* gnu-v3-abi.c (_initialize_gnu_v3_abi): Set default ABI.
	* minsyms.c (install_minimal_symbols): Don't check for _Z symbols.
	* NEWS: Update.
@
text
@d53 1
d89 1
a89 2
      while (isspace (*string))
	++string;
@


1.95
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@a1242 23
      /* Try to guess the appropriate C++ ABI by looking at the names 
	 of the minimal symbols in the table.  */
      {
	int i;

	for (i = 0; i < mcount; i++)
	  {
	    /* If a symbol's name starts with _Z and was successfully
	       demangled, then we can assume we've found a GNU v3 symbol.
	       For now we set the C++ ABI globally; if the user is
	       mixing ABIs then the user will need to "set cp-abi"
	       manually.  */
	    const char *name = SYMBOL_LINKAGE_NAME (&objfile->msymbols[i]);

	    if (name[0] == '_' && name[1] == 'Z'
		&& SYMBOL_DEMANGLED_NAME (&objfile->msymbols[i]) != NULL)
	      {
		set_cp_abi_as_auto_default ("gnu-v3");
		break;
	      }
	  }
      }

@


1.94
log
@	* minsyms.c (lookup_solib_trampoline_symbol_by_pc): Now static.
	* minsyms.h (lookup_solib_trampoline_symbol_by_pc): Don't
	declare.
@
text
@d2 1
a2 1
   Copyright (C) 1992-2004, 2007-2012 Free Software Foundation, Inc.
@


1.93
log
@Name of symbol missing when printing global variable's address

The build_address_symbolic funnction filters out data symbols if
their size is set to zero.  But the problem is that the COFF symbol
table (for instance) does not provide any size information, leaving
the size to its default value of zero, thus always triggering
the filter.

This shows up when trying to print the address of a global variable
when debugging a Windows executable, for instance.

gdb/ChangeLog:

        * symtab.h (struct minimal_symbol) [has_size]: New field.
        (MSYMBOL_SIZE): Adjust to forbid macro from being used as lvalue.
        (SET_MSYMBOL_SIZE, MSYMBOL_HAS_SIZE): New macros.
        * printcmd.c (build_address_symbolic): Only filter out zero-sized
        minimal symbols if the symbol's size is actually known.
        * minsyms.c (prim_record_minimal_symbol_full): Adjust setting
        of msymbol's size field.  Add comment.
        * elfread.c (elf_symtab_read, elf_rel_plt_read): Use
        SET_MSYMBOL_SIZE to set the minimal symbol size.
@
text
@d1305 3
a1307 1
/* See minsyms.h.  */
d1309 1
a1309 1
struct minimal_symbol *
@


1.92
log
@install_minimal_symbols: use memset instead of setting each field.

gdb/ChangeLog:

        * minsyms.c (install_minimal_symbols): Use memset to fill entire
        minimal_symbol struct object, rather than setting some of its
        fields one by one.
@
text
@d940 3
a942 1
  MSYMBOL_SIZE (msymbol) = 0;
@


1.91
log
@	* NEWS: Mention new options "set debug dwarf2-read" and
	"set debug symtab-create".
	* dwarf2read.c (dwarf2_read_debug): New static global.
	(dwarf2_build_psymtabs_hard): Add debugging printfs.
	(process_queue): Ditto.
	(process_full_comp_unit): Ditto.
	(_initialize_dwarf2_read): Add new option "set debug dwarf2-read".
	* elfread.c (elf_symfile_read): Add debugging printf.
	* minsyms.c (install_minimal_symbols): Ditto.
	* psymtab.c (allocate_psymtab): Ditto.
	* symfile.c (allocate_symtab): Ditto.
	* symtab.c (symtab_create_debug): New global.
	(_initialize_symtab): Add new option "set debug symtab-create".
	* symtab.h (symtab_create_debug): Declare.

	doc/
	* gdb.texinfo (Debugging Output): Document debug options dwarf2-read
	and symtab-create.
@
text
@d1232 1
a1232 7
      SYMBOL_LINKAGE_NAME (&msymbols[mcount]) = NULL;
      SYMBOL_VALUE_ADDRESS (&msymbols[mcount]) = 0;
      MSYMBOL_TARGET_FLAG_1 (&msymbols[mcount]) = 0;
      MSYMBOL_TARGET_FLAG_2 (&msymbols[mcount]) = 0;
      MSYMBOL_SIZE (&msymbols[mcount]) = 0;
      MSYMBOL_TYPE (&msymbols[mcount]) = mst_unknown;
      SYMBOL_SET_LANGUAGE (&msymbols[mcount], language_unknown);
@


1.90
log
@	* gdbtypes.h (struct main_type): Change type of name,tag_name,
	and fields.name members from char * to const char *.  All uses updated.
	(struct cplus_struct_type): Change type of fn_fieldlists.name member
	from char * to const char *.  All uses updated.
	(type_name_no_tag): Update.
	(lookup_unsigned_typename, lookup_signed_typename): Update.
	* gdbtypes.c (type_name_no_tag): Change result type
	from char * to const char *.  All callers updated.
	(lookup_unsigned_typename, lookup_signed_typename): Change type of
	name parameter from char * to const char *.
	* symtab.h (struct cplus_specific): Change type of demangled_name
	member from char * to const char *.  All uses updated.
	(struct general_symbol_info): Change type of name and
	mangled_lang.demangled_name members from char * to const char *.
	All uses updated.
	(symbol_get_demangled_name, symbol_natural_name): Update.
	(symbol_demangled_name, symbol_search_name): Update.
	* symtab.c (symbol_get_demangled_name): Change result type
	from char * to const char *.  All callers updated.
	(symbol_natural_name, symbol_demangled_name): Ditto.
	(symbol_search_name): Ditto.
	(completion_list_add_name): Change type of symname,sym_text,
	text,word parameters from char * to const char *.
	(completion_list_objc_symbol): Change type of sym_text,
	text,word parameters from char * to const char *.
	* ada-lang.c (find_struct_field): Change type of name parameter
	from char * to const char *.
	(encoded_ordered_before): Similarly for N0,N1 parameters.
	(old_renaming_is_invisible): Similarly for function_name parameter.
	(ada_type_name): Change result type from char * to const char *.
	All callers updated.
	* ada-lang.h (ada_type_name): Update.
	* buildsym.c (hashname): Change type of name parameter
	from char * to const char *.
	* buildsym.h (hashname): Update.
	* dbxread.c (end_psymtab): Change type of include_list parameter
	from char ** to const char **.
	* dwarf2read.c (determine_prefix): Change result type
	from char * to const char *.  All callers updated.
	* f-lang.c (find_common_for_function): Change type of name, funcname
	parameters from char * to const char *.
	* f-lang.c (find_common_for_function): Update.
	* f-valprint.c (list_all_visible_commons): Change type of funcname
	parameters from char * to const char *.
	* gdbarch.sh (static_transform_name): Change type of name parameter
	and result from char * to const char *.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* i386-sol2-tdep.c (i386_sol2_static_transform_name): Change type
	of name parameter from char * to const char *.
	* jv-lang.c (java_primitive_type_from_name): Ditto.
	(java_demangled_signature_length): Similarly for signature parameter.
	(java_demangled_signature_copy): Ditto.
	(java_demangle_type_signature): Ditto.
	* jv-lang.h (java_primitive_type_from_name): Update.
	(java_demangle_type_signature): Update.
	* objc-lang.c (specialcmp): Change type of a,b parameters
	from char * to const char *.
	* p-lang.c (is_pascal_string_type): Change type of arrayname parameter
	from char * to const char *.  All callers updated.
	* p-lang.h (is_pascal_string_type): Update.
	* solib-frv.c (find_canonical_descriptor_in_load_object): Change type
	of name parameter from char * to const char *.
	* sparc-sol2-tdep.c (sparc_sol2_static_transform_name): Ditto.
	* utils.c (fprintf_symbol_filtered): Ditto.
	* defs.h (fprintf_symbol_filtered): Update.
	* sparc-tdep.h (sparc_sol2_static_transform_name): Update.
	* stabsread.h (end_psymtab): Update.
	* stack.c (find_frame_funname): Change type of funname parameter
	from char ** to const char **.
	* stack.h (find_frame_funname): Update.
	* typeprint.c (type_print): Change type of varstring parameter
	from char * to const char *.
	* value.h (type_print): Update.
	* xcoffread.c (xcoff_start_psymtab): Change type of filename parameter
	from char * to const char *.  All callers updated.
	(xcoff_end_psymtab): Change type of include_list parameter
	from char ** to const char **.  All callers updated.
	(swap_sym): Similarly for name parameter.  All callers updated.
	* coffread.c (patch_type): Add (char*) cast to xfree parameter.
	Use xstrdup.
	(process_coff_symbol): Use xstrdup.
	* stabsread.c (stabs_method_name_from_physname): Renamed from
	update_method_name_from_physname.  Change result type from void
	to char *.  All callers updated.
	(read_member_functions): In has_destructor case, store name in objfile
	obstack instead of malloc space.  In !has_stub case, fix mem leak.
@
text
@d1170 7
@


1.89
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d991 2
a992 2
      char *name1 = SYMBOL_LINKAGE_NAME (fn1);
      char *name2 = SYMBOL_LINKAGE_NAME (fn2);
@


1.88
log
@	* minsyms.h: Rearrange.  Document header and all functions.
	* minsyms.c: Move some comments to minsyms.h.
@
text
@d2 1
a2 3
   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
   2002, 2003, 2004, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.87
log
@	* symtab.h: Include minsyms.h.
	(prim_record_minimal_symbol, prim_record_minimal_symbol_full)
	(prim_record_minimal_symbol_and_info, msymbol_hash_iw)
	(msymbol_hash, SYMBOL_HASH_NEXT, msymbol_objfile)
	(lookup_minimal_symbol, lookup_minimal_symbol_text)
	(lookup_minimal_symbol_solib_trampoline)
	(lookup_minimal_symbol_by_pc_name, lookup_minimal_symbol_by_pc)
	(iterate_over_minimal_symbols, lookup_minimal_symbol_and_objfile)
	(lookup_minimal_symbol_by_pc_section)
	(lookup_solib_trampoline_symbol_by_pc)
	(init_minimal_symbol_collection)
	(make_cleanup_discard_minimal_symbols, install_minimal_symbols)
	(msymbols_sort): Move to minsyms.h.
	* objfiles.c (terminate_minimal_symbol_table): Move to minsyms.c.
	* minsyms.c (terminate_minimal_symbol_table): Move from
	objfiles.c.
	* minsyms.h: New file.
@
text
@d81 1
a81 1
/* Compute a hash code based using the same criteria as `strcmp_iw'.  */
d101 1
a101 1
/* Compute a hash code for a string.  */
d144 1
a145 1
/* Return OBJFILE where minimal symbol SYM is defined.  */
d313 1
a313 7
/* Iterate over all the minimal symbols in the objfile OBJF which
   match NAME.  Both the ordinary and demangled names of each symbol
   are considered.  The caller is responsible for canonicalizing NAME,
   should that need to be done.
   
   For each matching symbol, CALLBACK is called with the symbol and
   USER_DATA as arguments.  */
d347 1
a347 6
/* Look through all the current minimal symbol tables and find the
   first minimal symbol that matches NAME and has text type.  If OBJF
   is non-NULL, limit the search to that objfile.  Returns a pointer
   to the minimal symbol that matches, or NULL if no match is found.

   This function only searches the mangled (linkage) names.  */
d399 1
a399 4
/* Look through all the current minimal symbol tables and find the
   first minimal symbol that matches NAME and PC.  If OBJF is non-NULL,
   limit the search to that objfile.  Returns a pointer to the minimal
   symbol that matches, or NULL if no match is found.  */
d431 1
a431 7
/* Look through all the current minimal symbol tables and find the
   first minimal symbol that matches NAME and is a solib trampoline.
   If OBJF is non-NULL, limit the search to that objfile.  Returns a
   pointer to the minimal symbol that matches, or NULL if no match is
   found.

   This function only searches the mangled (linkage) names.  */
d717 1
a717 2
/* Backward compatibility: search through the minimal symbol table 
   for a matching PC (no section given).  */
d788 1
a788 4
/* Find the minimal symbol named NAME, and return both the minsym
   struct and its objfile.  This only checks the linkage name.  Sets
   *OBJFILE_P and returns the minimal symbol, if it is found.  If it
   is not found, returns NULL.  */
d832 1
a832 3
/* Prepare to start collecting minimal symbols.  Note that presetting
   msym_bunch_index to BUNCH_SIZE causes the first call to save a minimal
   symbol to allocate the memory for the first bunch.  */
d839 3
d845 2
d878 1
a878 2
/* Record a minimal symbol in the msym bunches.  Returns the symbol
   newly created.  */
d955 1
a955 2
/* Record a minimal symbol in the msym bunches.  Returns the symbol
   newly created.  */
d1028 2
d1304 1
a1304 3
/* Check if PC is in a shared library trampoline code stub.
   Return minimal symbol for the trampoline entry or NULL if PC is not
   in a trampoline code stub.  */
@


1.86
log
@	* symtab.h (add_minsym_to_hash_table): Don't declare.
	* minsyms.c (add_minsym_to_hash_table): Now static.
@
text
@d1294 21
@


1.85
log
@the "ambiguous linespec" series
gdb
2011-12-06  Joel Brobecker  <brobecker@@acacore.com>

        * language.h (struct language_defn): Add new component
        la_symbol_name_compare.
        * symfile.h (struct quick_symbol_functions): Update the profile
        of parameter "name_matcher" for the expand_symtabs_matching
        method.  Update the documentation accordingly.
        * ada-lang.h (ada_name_for_lookup): Add declaration.
        * ada-lang.c (ada_name_for_lookup): New function, extracted out
        from ada_iterate_over_symbols.
        (ada_iterate_over_symbols): Do not encode symbol name anymore.
        (ada_expand_partial_symbol_name): Adjust profile.
        (ada_language_defn): Add value for la_symbol_name_compare field.
        * linespec.c: #include "ada-lang.h".
        (iterate_name_matcher): Add language parameter. Replace call
        to strcmp_iw by call to language->la_symbol_name_compare.
        (decode_variable): Encode COPY if current language is Ada.
        * dwarf2read.c (dw2_expand_symtabs_matching): Adjust profile
        of name_matcher parameter.  Adjust call to name_matcher.
        * psymtab.c (expand_symtabs_matching_via_partial): Likewise.
        (expand_partial_symbol_names): Update profile of parameter "fun".
        * psymtab.h (expand_partial_symbol_names): Update profile of
        parameter "fun".
        * symtab.c (demangle_for_lookup): Update function documentation.
        (search_symbols_name_matches): Add language parameter.
        (expand_partial_symbol_name): Likewise.
        * c-lang.c (c_language_defn, cplus_language_defn)
        (asm_language_defn, minimal_language_defn): Add value for
        la_symbol_name_compare field.
        * d-lang.c (d_language_defn): Likewise.
        * f-lang.c (f_language_defn): Ditto.
        * jv-lang.c (java_language_defn): Ditto.
        * m2-lang.c (m2_language_defn): Ditto.
        * objc-lang.c (objc_language_defn): Ditto.
        * opencl-lang.c (opencl_language_defn): Ditto.
        * p-lang.c (pascal_language_defn): Ditto.
        * language.c (unknown_language_defn, auto_language_defn)
        (local_language_defn): Ditto.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* linespec.c (iterate_over_all_matching_symtabs): Use
	LA_ITERATE_OVER_SYMBOLS.
	(lookup_prefix_sym, add_matching_symbols_to_info): Likewise.
	(find_function_symbols, decode_variable): Remove Ada special
	case.
	* language.h (struct language_defn) <la_iterate_over_symbols>: New
	field.
	(LA_ITERATE_OVER_SYMBOLS): New macro.
	* language.c (unknown_language_defn, auto_language_defn)
	(local_language_defn): Update.
	* c-lang.c (c_language_defn, cplus_language_defn)
	(asm_language_defn, minimal_language_defn): Update.
	* d-lang.c (d_language_defn): Update.
	* f-lang.c (f_language_defn): Update.
	* jv-lang.c (java_language_defn): Update.
	* m2-lang.c (m2_language_defn): Update.
	* objc-lang.c (objc_language_defn): Update.
	* opencl-lang.c (opencl_language_defn): Update.
	* p-lang.c (pascal_language_defn): Update.
	* ada-lang.c (ada_iterate_over_symbols): New function.
	(ada_language_defn): Update.

2011-12-06  Tom Tromey  <tromey@@redhat.com>
	    Joel Brobecker  <brobecker@@acacore.com>

	PR breakpoints/13105, PR objc/8341, PR objc/8343, PR objc/8366,
	PR objc/8535, PR breakpoints/11657, PR breakpoints/11970,
	PR breakpoints/12023, PR breakpoints/12334, PR breakpoints/12856,
	PR shlibs/8929, PR shlibs/7393:
	* python/py-type.c (compare_maybe_null_strings): Rename from
	compare_strings.
	(check_types_equal): Update.
	* utils.c (compare_strings): New function.
	* tui/tui-winsource.c (tui_update_breakpoint_info): Update for
	location changes.
	* tracepoint.c (scope_info): Update.
	(trace_find_line_command): Use DECODE_LINE_FUNFIRSTLINE.
	* symtab.h (iterate_over_minimal_symbols)
	(iterate_over_some_symtabs, iterate_over_symtabs)
	(find_pcs_for_symtab_line, iterate_over_symbols)
	(demangle_for_lookup): Declare.
	(expand_line_sal): Remove.
	* symtab.c (iterate_over_some_symtabs, iterate_over_symtabs)
	(lookup_symtab_callback): New functions.
	(lookup_symtab): Rewrite.
	(demangle_for_lookup): New function, extract from
	lookup_symbol_in_language.
	(lookup_symbol_in_language): Use it.
	(iterate_over_symbols): New function.
	(find_line_symtab): Update.
	(find_pcs_for_symtab_line): New functions.
	(find_line_common): Add 'start' argument.
	(decode_line_spec): Update.  Change argument to 'flags', change
	interpretation.
	(append_expanded_sal): Remove.
	(append_exact_match_to_sals): Remove.
	(expand_line_sal): Remove.
	* symfile.h (struct quick_symbol_functions) <lookup_symtab>:
	Remove.
	<map_symtabs_matching_filename>: New field.
	* stack.c (func_command): Only look in the current program space.
	Use DECODE_LINE_FUNFIRSTLINE.
	* source.c (line_info): Set pspace on sal.  Check program space in
	the loop.  Use DECODE_LINE_LIST_MODE.
	(select_source_symtab): Use DECODE_LINE_FUNFIRSTLINE.
	* solib-target.c: Remove DEF_VEC_I(CORE_ADDR).
	* python/python.c (gdbpy_decode_line): Update.
	* psymtab.c (partial_map_expand_apply): New function.
	(partial_map_symtabs_matching_filename): Rename from
	lookup_partial_symbol.  Update arguments.
	(lookup_symtab_via_partial_symtab): Remove.
	(psym_functions): Update.
	* objc-lang.h (parse_selector, parse_method): Don't declare.
	(find_imps): Update.
	* objc-lang.c (parse_selector, parse_method): Now static.
	(find_methods): Change arguments.  Fill in a vector of symbol
	names.
	(uniquify_strings): New function.
	(find_imps): Change arguments.
	* minsyms.c (iterate_over_minimal_symbols): New function.
	* linespec.h (enum decode_line_flags): New.
	(struct linespec_sals): New.
	(struct linespec_result) <canonical>: Remove.
	<pre_expanded, addr_string, sals>: New fields.
	(destroy_linespec_result, make_cleanup_destroy_linespec_result)
	(decode_line_full): Declare.
	(decode_line_1): Update.
	* linespec.c (struct address_entry, struct linespec_state, struct
	collect_info): New types.
	(add_sal_to_sals_basic, add_sal_to_sals, hash_address_entry)
	(eq_address_entry, maybe_add_address): New functions.
	(total_number_of_methods): Remove.
	(iterate_name_matcher, iterate_over_all_matching_symtabs): New
	functions.
	(find_methods): Change arguments.  Don't canonicalize input.
	Simplify logic.
	(add_matching_methods, add_constructors)
	(build_canonical_line_spec): Remove.
	(filter_results, convert_results_to_lsals): New functions.
	(decode_line_2): Change arguments.  Rewrite for new data
	structures.
	(decode_line_internal): Rename from decode_line_1.  Change
	arguments.  Add cleanups.  Update for new data structures.
	(linespec_state_constructor, linespec_state_destructor)
	(decode_line_full, decode_line_1): New functions.
	(decode_indirect): Change arguments.  Update.
	(locate_first_half): Use skip_spaces.
	(decode_objc): Change arguments.  Update for new data structures.
	Simplify logic.
	(decode_compound): Change arguments.  Add cleanups.  Remove
	fallback code, replace with error.
	(struct decode_compound_collector): New type.
	(collect_one_symbol): New function.
	(lookup_prefix_sym): Change arguments.  Update.
	(compare_symbol_name, add_all_symbol_names_from_pspace)
	(find_superclass_methods ): New functions.
	(find_method): Rewrite.
	(struct symtab_collector): New type.
	(add_symtabs_to_list, collect_symtabs_from_filename): New
	functions.
	(symtabs_from_filename): Change API.  Rename from
	symtab_from_filename.
	(collect_function_symbols): New function.
	(find_function_symbols): Change API.  Rename from
	find_function_symbol.  Rewrite.
	(decode_all_digits): Change arguments.  Rewrite.
	(decode_dollar): Change arguments.  Use decode_variable.
	(decode_label): Change arguments.  Rewrite.
	(collect_symbols): New function.
	(minsym_found): Change arguments.  Rewrite.
	(check_minsym, search_minsyms_for_name)
	(add_matching_symbols_to_info): New function.
	(decode_variable): Change arguments.  Iterate over all symbols.
	(symbol_found): Remove.
	(symbol_to_sal): New function.
	(init_linespec_result, destroy_linespec_result)
	(cleanup_linespec_result, make_cleanup_destroy_linespec_result):
	New functions.
	(decode_digits_list_mode, decode_digits_ordinary): New functions.
	* dwarf2read.c (dw2_map_expand_apply): New function.
	(dw2_map_symtabs_matching_filename): Rename from
	dw2_lookup_symtab.  Change arguments.
	(dwarf2_gdb_index_functions): Update.
	* dwarf2loc.c: Remove DEF_VEC_I(CORE_ADDR).
	* defs.h (compare_strings): Declare.
	* cli/cli-cmds.c (compare_strings): Move to utils.c.
	(edit_command, list_command): Use DECODE_LINE_LIST_MODE.  Call
	filter_sals.
	(compare_symtabs, filter_sals): New functions.
	* breakpoint.h (struct bp_location) <line_number, source_file>:
	New fields.
	(struct breakpoint) <line_number, source_file>: Remove.
	<filter>: New field.
	* breakpoint.c (print_breakpoint_location, init_raw_breakpoint)
	(momentary_breakpoint_from_master, add_location_to_breakpoint):
	Update for changes to locations.
	(init_breakpoint_sal): Add 'filter' argument.  Set 'filter' on
	breakpoint.
	(create_breakpoint_sal): Add 'filter' argument.
	(remove_sal, expand_line_sal_maybe): Remove.
	(create_breakpoints_sal): Remove 'sals' argument.  Handle
	pre-expanded sals and the filter.
	(parse_breakpoint_sals): Use decode_line_full.
	(check_fast_tracepoint_sals): Use get_sal_arch.
	(create_breakpoint): Create a linespec_sals.  Update.
	(break_range_command): Use decode_line_full.  Update.
	(until_break_command): Update.
	(clear_command): Update match conditions for linespec.c changes.
	Use DECODE_LINE_LIST_MODE.
	(say_where): Update for changes to locations.
	(bp_location_dtor): Free 'source_file'.
	(base_breakpoint_dtor): Free 'filter'.  Don't free 'source_file'.
	(update_static_tracepoint): Update for changes to locations.
	(update_breakpoint_locations): Disable ranged breakpoint if too
	many locations match.  Update.
	(addr_string_to_sals): Use decode_line_full.  Resolve all sal
	PCs.
	(breakpoint_re_set_default): Don't call expand_line_sal_maybe.
	(decode_line_spec_1): Update.  Change argument name to 'flags',
	change interpretation.
	* block.h (block_containing_function): Declare.
	* block.c (block_containing_function): New function.
	* skip.c (skip_function_command): Update.
	(skip_re_set): Update.
	* infcmd.c (jump_command): Use DECODE_LINE_FUNFIRSTLINE.
	* mi/mi-main.c (mi_cmd_trace_find): Use DECODE_LINE_FUNFIRSTLINE.
	* NEWS: Add entry.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* elfread.c (elf_gnu_ifunc_resolver_return_stop): Allow
	breakpoint's pspace to be NULL.
	* breakpoint.h (struct breakpoint) <pspace>: Update comment.
	* breakpoint.c (init_raw_breakpoint): Conditionally set
	breakpoint's pspace.
	(init_breakpoint_sal): Don't set breakpoint's pspace.
	(prepare_re_set_context): Conditionally switch program space.
	(addr_string_to_sals): Check executing_startup on location's
	program space.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* breakpoint.h (enum enable_state) <bp_startup_disabled>: Remove.
	* breakpoint.c (should_be_inserted): Explicitly check if program
	space is executing startup.
	(describe_other_breakpoints): Update.
	(disable_breakpoints_before_startup): Change executing_startup
	earlier.  Remove loop.
	(enable_breakpoints_after_startup): Likewise.
	(init_breakpoint_sal): Don't use bp_startup_disabled.
	(create_breakpoint): Don't use bp_startup_disabled.
	(update_global_location_list): Use should_be_inserted.
	(bkpt_re_set): Update.
gdb/testsuite
2011-12-06  Joel Brobecker  <brobecker@@acacore.com>

        * gdb.ada/fullname_bp.exp: Add tests for other valid linespecs
        involving a fully qualified function name.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* gdb.ada/homonym.exp: Add three breakpoint tests.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* gdb.base/solib-weak.exp (do_test): Remove kfail.
	* gdb.trace/tracecmd.exp: Disable pending breakpoints earlier.
	* gdb.objc/objcdecode.exp: Update for output changes.
	* gdb.linespec/linespec.exp: New file.
	* gdb.linespec/lspec.cc: New file.
	* gdb.linespec/lspec.h: New file.
	* gdb.linespec/body.h: New file.
	* gdb.linespec/base/two/thefile.cc: New file.
	* gdb.linespec/base/one/thefile.cc: New file.
	* gdb.linespec/Makefile.in: New file.
	* gdb.cp/templates.exp (test_template_breakpoints): Update for
	output changes.
	* gdb.cp/re-set-overloaded.exp: Remove kfail.
	* gdb.cp/ovldbreak.exp: Update for output changes.  "all" test now
	makes one breakpoint.
	* gdb.cp/method2.exp (test_break): Update for output changes.
	* gdb.cp/mb-templates.exp: Update for output changes.
	* gdb.cp/mb-inline.exp: Update for output changes.
	* gdb.cp/mb-ctor.exp: Update for output changes.
	* gdb.cp/ovsrch.exp: Use fully-qualified names.
	* gdb.base/solib-symbol.exp: Run to main later.  Breakpoint now
	has multiple matches.
	* gdb.base/sepdebug.exp: Disable pending breakpoints.  Update for
	error message change.
	* gdb.base/list.exp (test_list_filename_and_number): Update for
	error message change.
	* gdb.base/break.exp: Disable pending breakpoints.  Update for
	output changes.
	* configure.ac: Add gdb.linespec.
	* configure: Rebuild.
	* Makefile.in (ALL_SUBDIRS): Add gdb.linespec.
gdb/doc
2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* gdb.texinfo (Set Breaks): Update for new behavior.
@
text
@d114 1
a114 1
void
@


1.85.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 3
a4 1
   Copyright (C) 1992-2004, 2007-2012 Free Software Foundation, Inc.
@


1.84
log
@gdb/
	* ada-lang.c: Fix typos.
	* amd64-tdep.c: Likewise.
	* breakpoint.c: Likewise.
	* cli/cli-decode.c: Likewise.
	* findcmd.c: Likewise.
	* inline-frame.c: Likewise.
	* mi/mi-main.c: Likewise.
	* minsyms.c: Likewise.
	* monitor.c: Likewise.
	* monitor.h: Likewise.
	* prologue-value.c: Likewise.
	* reverse.c: Likewise.
	* s390-tdep.c: Likewise.

gdb/testsuite/
	* gdb.base/call-sc.c: Likewise.
	* gdb.base/ifelse.exp: Likewise.
	* gdb.base/structs.c: Likewise.

gdb/doc/
	* gdb.texinfo: Likewise.
@
text
@d313 40
@


1.83
log
@gdb/doc/
	* gdb.texinfo (Index Section Format): Change the version to 5.
	Describe the different formula.

gdb/
	Case insensitive lookups implementation.
	* dwarf2read.c: Include ctype.h.
	(struct mapped_index): New field version.
	(mapped_index_string_hash): New parameter index_version.  New comment
	for it.  Call tolower appropriately.
	(find_slot_in_mapped_hash): New variable cmp, initialize it, use it.
	Choose the right index version for mapped_index_string_hash.
	(dwarf2_read_index): Support also the index version 5.  Initialize the
	new struct mapped_index field version.
	(hash_strtab_entry): Pass INT_MAX for the new parameter, explain why.
	(find_slot): Explain the version needs.  Pass INT_MAX for the new
	parameter.
	(write_psymtabs_to_index): Produce version 5.
	* minsyms.c (lookup_minimal_symbol): New variable cmp, initialize it,
	use it.  New comment for SYMBOL_MATCHES_SEARCH_NAME.
	* psymtab.c (lookup_partial_symbol): Find the
	SYMBOL_MATCHES_SEARCH_NAME start of the found block of matching
	entries.
	* symtab.c (lookup_symbol_in_language): Remove the case_sensitive_off
	NAME lowercasing.
	(search_symbols): Pass REG_ICASE to regcomp for case_sensitive_off.
	(completion_list_add_name): New variable ncmp, initialize it, use it.
	* symtab.h (SYMBOL_HASH_NEXT): Always call tolower.
	* utils.c (strcmp_iw): Support case_sensitive_off.
	(strcmp_iw_ordered): Sort in a way compatible with case_sensitive_off.
	New function comment part.  New variables saved_string1,
	saved_string2 and case_pass.  Add a proper second pass.

gdb/testsuite/
	* gdb.base/fortran-sym-case.c: New file.
	* gdb.base/fortran-sym-case.exp: New file.
	* gdb.dwarf2/dw2-case-insensitive-debug.S: New file.
	* gdb.dwarf2/dw2-case-insensitive.c: New file.
	* gdb.dwarf2/dw2-case-insensitive.exp: New file.
@
text
@d586 1
a586 1
		     preceeding symbol too.  If they are otherwise
@


1.82
log
@gdb/
	Code cleanup.
	* dictionary.c (dict_hash): Use SYMBOL_HASH_NEXT.
	* dwarf2read.c (mapped_index_string_hash): Refer to SYMBOL_HASH_NEXT
	in the function comment, a new note on values compatibility.
	* minsyms.c (msymbol_hash_iw, msymbol_hash): Use SYMBOL_HASH_NEXT.
	* symtab.h (SYMBOL_HASH_NEXT): New.
@
text
@d242 6
a247 2
		      match = strcmp (SYMBOL_LINKAGE_NAME (msymbol),
				      modified_name) == 0;
d251 1
@


1.81
log
@gdb/
	Support resolution of STT_GNU_IFUNC via breakpoints.
	* breakpoint.c (print_it_typical): Support bp_gnu_ifunc_resolver and
	bp_gnu_ifunc_resolver_return.
	(bpstat_what): Rename parameter to bs_head, new variable bs, adjust
	the loop.  Support bp_gnu_ifunc_resolver and
	bp_gnu_ifunc_resolver_return.  New comment after the loop.  New loop
	for bp_gnu_ifunc_resolver and bp_gnu_ifunc_resolver_return
	breakpoints.
	(bptype_string, print_one_breakpoint_location): Support
	bp_gnu_ifunc_resolver and bp_gnu_ifunc_resolver_return.
	(user_settable_breakpoint): Return true also for
	bp_gnu_ifunc_resolver.
	(allocate_bp_location): Support bp_gnu_ifunc_resolver and
	bp_gnu_ifunc_resolver_return.
	(set_breakpoint_location_function): New parameter explicit_loc,
	describe it.  Call find_pc_partial_function_gnu_ifunc with new
	variable IS_GNU_IFUNC and adjust the address for STT_GNU_IFUNC if
	EXPLICIT_LOC is not set.
	(set_raw_breakpoint): Set EXPLICIT_LOC for
	set_breakpoint_location_function.
	(clone_momentary_breakpoint): Use true for EXPLICIT_LOC of
	set_breakpoint_location_function.
	(mention): Support bp_gnu_ifunc_resolver and
	bp_gnu_ifunc_resolver_return.
	(add_location_to_breakpoint): Set EXPLICIT_LOC for
	set_breakpoint_location_function.
	(update_breakpoint_locations): Remove static.
	(breakpoint_re_set_one): Support bp_gnu_ifunc_resolver and
	bp_gnu_ifunc_resolver_return.
	* breakpoint.h (enum bptype): New fields bp_gnu_ifunc_resolver and
	bp_gnu_ifunc_resolver_return.
	(update_breakpoint_locations): New declaration.
	* elfread.c: Include gdbthread.h and regcache.h.
	(elf_gnu_ifunc_resolver_stop, elf_gnu_ifunc_resolver_return_stop): New
	functions.
	(elf_gnu_ifunc_fns): Install them.
	* minsyms.c (stub_gnu_ifunc_resolver_stop)
	(stub_gnu_ifunc_resolver_return_stop): New functions.
	(stub_gnu_ifunc_fns): Install them.
	* symtab.h (struct gnu_ifunc_fns): New fields gnu_ifunc_resolver_stop
	and gnu_ifunc_resolver_return_stop.
	(gnu_ifunc_resolver_stop, gnu_ifunc_resolver_return_stop): New.
@
text
@d94 1
a94 1
	  hash = hash * 67 + *string - 113;
d109 1
a109 1
    hash = hash * 67 + *string - 113;
@


1.80
log
@gdb/
	STT_GNU_IFUNC reader implementation.
	* elfread.c: Include gdbtypes.h, value.h and infcall.h.
	(SYMBOL_GOT_PLT_SUFFIX, elf_rel_plt_read)
	(elf_objfile_gnu_ifunc_cache_data, struct elf_gnu_ifunc_cache)
	(elf_gnu_ifunc_cache_hash, elf_gnu_ifunc_cache_eq)
	(elf_gnu_ifunc_record_cache, elf_gnu_ifunc_resolve_by_cache)
	(elf_gnu_ifunc_resolve_by_got, elf_gnu_ifunc_resolve_name)
	(elf_gnu_ifunc_resolve_addr): New.
	(elf_symfile_read): Call elf_rel_plt_read.
	(elf_gnu_ifunc_fns): New.
	(_initialize_elfread): Initialize elf_objfile_gnu_ifunc_cache_data.
	Install elf_gnu_ifunc_fns.
	* infcall.c (find_function_return_type): New function.
	(find_function_addr): Resolve TYPE_GNU_IFUNC functions, if possible.
	* minsyms.c (stub_gnu_ifunc_resolve_addr)
	(stub_gnu_ifunc_resolve_name): New functions.
	(stub_gnu_ifunc_fns, gnu_ifunc_fns_p): New variables.
	* symtab.h (struct gnu_ifunc_fns, gnu_ifunc_resolve_addr)
	(gnu_ifunc_resolve_name, gnu_ifunc_fns_p): New.
@
text
@d732 18
d756 2
@


1.79
log
@gdb/
	GDB internal type support for STT_GNU_IFUNC.
	* elfread.c (record_minimal_symbol): Support mst_text_gnu_ifunc.
	(elf_symtab_read): Set mst_text_gnu_ifunc for
	BSF_GNU_INDIRECT_FUNCTION.
	* eval.c (evaluate_subexp_standard): Support TYPE_GNU_IFUNC.
	* gdbtypes.c (init_type): Support TYPE_FLAG_GNU_IFUNC,
	builtin_func_func, nodebug_text_gnu_ifunc_symbol and
	nodebug_got_plt_symbol.
	* gdbtypes.h (enum type_flag_value): New entry TYPE_FLAG_GNU_IFUNC.
	(TYPE_GNU_IFUNC): New.
	(struct main_type): New field flag_gnu_ifunc.
	(struct builtin_type): New field builtin_func_func.
	(struct objfile_type): New fields nodebug_text_gnu_ifunc_symbol and
	nodebug_got_plt_symbol.
	* minsyms.c (lookup_minimal_symbol_text): Support mst_text_gnu_ifunc.
	(in_gnu_ifunc_stub): New.
	(prim_record_minimal_symbol, find_solib_trampoline_target): Support
	mst_text_gnu_ifunc.
	* parse.c (write_exp_msymbol): New variable ifunc_msym.  Detect and
	support mst_text_gnu_ifunc.  Support mst_slot_got_plt.
	* solib-svr4.c (svr4_in_dynsym_resolve_code): Return true also for
	in_gnu_ifunc_stub.
	* symmisc.c (dump_msymbols): Support mst_text_gnu_ifunc.
	* symtab.c (search_symbols): Likewise.
	* symtab.h (enum minimal_symbol_type): New fields mst_text_gnu_ifunc
	and mst_slot_got_plt.
	(in_gnu_ifunc_stub): New declaration.
@
text
@d711 33
@


1.78
log
@2011-03-23  Kai Tietz  <ktietz@@redhat.com>

	* breakpoint.c (clear_command): Use filename_cmp
	instead of strcmp for comparison.
	* buildsym.c (watch_main_source_file_lossage): Likewise.
	(patch_subfile_names): Use IS_DIR_SEPARATOR instead of
	checking just for slash.
	* dbxread.c (read_dbx_symtab): Use lbasename instead of
	strrchr and filename_cmp instead of strcmp for filenames.
	(add_old_header_file): Use filename_cmp
	instead of strcmp for comparison.
	* exec.c (exec_set_section_address): Likewise.
	* macrotab.c (macro_lookup_inclusion): Likewise.
	(macro_lookup_inclusion): Likewise.
	* elfread.c (_initialize_elfread): Likewise.
	(elfstab_offset_sections): Likewise.
	(elfstab_offset_sections): Use lbasename instead of
	strrchr.
	* mdebugread.c (parse_partial_symbols): Likewise.
	(arse_partial_symbols): Use filename_(n)cmp instead of
	str(n)cmp for comparison.
	* minsyms.c (lookup_minimal_symbol): Likewise.
	* psymtab.c (read_psymtabs_with_filename): Likewise.
	* solib.c (solib_read_symbols): Likewise.
	(reload_shared_libraries_1): Likewise.
	* symmisc.c (maintenance_print_symbols): Likewise.
	* symfile.c (separate_debug_file_exists): Likewise.
	(reread_symbols): Likewise.
	(find_separate_debug_file_by_debuglink): Likewise.
	* remote-fileio.c (remote_fileio_func_rename): Likewise.
	* source.c (add_path): Likewise.
	* symtab.c (filename_seen): Likewise.
	(file_matches): Likewise.
	(print_symbol_info): Likewise.
	(maybe_add_partial_symtab_filename): Likewise.
	(make_source_files_completion_list): Likewise.
	* xml-syscall.c (init_sysinfo): Likewise.
	* windows-nat.c (_initialize_check_for_gdb_ini): Use
	IS_DIR_SEPARATOR for checking for trailing path separator.
@
text
@d337 3
a339 2
		  (MSYMBOL_TYPE (msymbol) == mst_text ||
		   MSYMBOL_TYPE (msymbol) == mst_file_text))
d701 10
d780 1
d1246 2
a1247 1
	if (MSYMBOL_TYPE (msymbol) == mst_text
@


1.77
log
@	* cli/cli-cmds.c (shell_escape): Use lbasename.
	* coffread.c (coff_start_symtab): Constify parameter.
	(complete_symtab): Constify `name' parameter.
	(coff_symtab_read): Constify `filestring' local.
	(coff_getfilename): Constify return and `result' local.
	Use lbasename.
	* fbsd-nat.c (fbsd_make_corefile_notes): Use lbasename.
	* linux-fork.c (info_checkpoints_command): Use lbasename.
	* linux-nat.c (linux_nat_make_corefile_notes): Use lbasename.
	* minsyms.c (lookup_minimal_symbol): Use lbasename.
	* nto-tdep.c (nto_find_and_open_solib): Use lbasename.
	* procfs.c (procfs_make_note_section): Use lbasename.
	* tui/tui-io.c (printable_part): Constity return and parameter.
	Use lbasename.
	(print_filename): Constify parameters, and local `s'.
	(tui_rl_display_match_list): Constify local `temp'.
@
text
@d46 1
d259 1
a259 1
			    || strcmp (msymbol->filename, sfile) == 0)
@


1.76
log
@2011-01-08  Michael Snyder  <msnyder@@vmware.com>

	* m2-exp.y: Comment cleanup, mostly periods and spaces.
	* m2-lang.c: Ditto.
	* m2-typeprint.c: Ditto.
	* m2-valprint.c: Ditto.
	* m32c-tdep.c: Ditto.
	* m32r-linux-nat.c: Ditto.
	* m32r-rom.c: Ditto.
	* m32r-tdep.c: Ditto.
	* m32r-tdep.h: Ditto.
	* m68hc11-tdep.c: Ditto.
	* m58klinux-nat.c: Ditto.
	* m68k-tdep.c: Ditto.
	* m88k-tdep.c: Ditto.
	* m88k-tdep.h: Ditto.
	* machoread.c: Ditto.
	* macrocmd.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* mdebugread.h: Ditto.
	* memattr.c: Ditto.
	* memattr.h: Ditto.
	* memory-map.h: Ditto.
	* mep-tdep.c: Ditto.
	* microblaze-rom.c: Ditto.
	* microblaze-tdep.c: Ditto.
	* minsyms.c: Ditto.
	* mips-irix-tdep.c: Ditto.
	* mips-linux-nat.c: Ditto.
	* mips-linux-tdep.c: Ditto.
	* mips-linux-tdep.h: Ditto.
	* mipsnbsd-nat.c: Ditto.
	* mipsnbsd-tdep.c: Ditto.
	* mipsread.c: Ditto.
	* mips-tdep.c: Ditto.
	* mips-tdep.h: Ditto.
	* mn10300-linux-tdep.c: Ditto.
	* mn10300-tdep.c: Ditto.
	* mn10300-tdep.h: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* moxie-tdep.c: Ditto.
	* moxie-tdep.h: Ditto.
	* mt-tdep.c: Ditto.
@
text
@d201 1
a201 6
    {
      char *p = strrchr (sfile, '/');

      if (p != NULL)
	sfile = p + 1;
    }
@


1.75
log
@2011-01-05  Michael Snyder  <msnyder@@vmware.com>

	* addrmap.c: Shorten lines of >= 80 columns.
	* arch-utils.c: Ditto.
	* arch-utils.h: Ditto.
	* ax-gdb.c: Ditto.
	* ax-general.c: Ditto.
	* bcache.c: Ditto.
	* blockframe.c: Ditto.
	* breakpoint.c: Ditto.
	* buildsym.c: Ditto.
	* c-lang.c: Ditto.
	* c-typeprint.c: Ditto.
	* charset.c: Ditto.
	* coffread.c: Ditto.
	* command.h: Ditto.
	* corelow.c: Ditto.
	* cp-abi.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* defs.h: Ditto.
	* dfp.c: Ditto.
	* dfp.h: Ditto.
	* dictionary.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* eval.c: Ditto.
	* event-loop.c: Ditto.
	* event-loop.h: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-lang.c: Ditto.
	* f-valprint.c: Ditto.
	* findcmd.c: Ditto.
	* frame-base.c: Ditto.
	* frame-unwind.c: Ditto.
	* frame-unwind.h: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_dirent.h: Ditto.
	* gdb_obstack.h: Ditto.
	* gdbcore.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* inf-ttrace.c: Ditto.
	* infcall.c: Ditto.
	* infcmd.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* inline-frame.h: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* libunwind-frame.c: Ditto.
	* libunwind-frame.h: Ditto.
	* linespec.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-nat.h: Ditto.
	* linux-thread-db.c: Ditto.
	* machoread.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* memattr.c: Ditto.
	* minsyms.c: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* osabi.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* parse.c: Ditto.
	* printcmd.c: Ditto.
	* proc-events.c: Ditto.
	* procfs.c: Ditto.
	* progspace.c: Ditto.
	* progspace.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote-fileio.c: Ditto.
	* remote.c: Ditto.
	* ser-mingw.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* solib-frv.c: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solib-target.c: Ditto.
	* solib.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.c: Ditto.
	* stack.c: Ditto.
	* stack.h: Ditto.
	* symfile-mem.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target-descriptions.c: Ditto.
	* target-memory.c: Ditto.
	* target.c: Ditto.
	* target.h: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* ui-file.c: Ditto.
	* ui-file.h: Ditto.
	* ui-out.h: Ditto.
	* user-regs.c: Ditto.
	* user-regs.h: Ditto.
	* utils.c: Ditto.
	* valarith.c: Ditto.
	* valops.c: Ditto.
	* valprint.c: Ditto.
	* valprint.h: Ditto.
	* value.c: Ditto.
	* varobj.c: Ditto.
	* varobj.h: Ditto.
	* vec.h: Ditto.
	* xcoffread.c: Ditto.
	* xcoffsolib.c: Ditto.
	* xcoffsolib.h: Ditto.
	* xml-syscall.c: Ditto.
	* xml-tdesc.c: Ditto.
@
text
@d38 1
a38 1
   to figure out what full symbol table entries need to be read in. */
d208 1
a208 1
  /* For C++, canonicalize the input name. */
d270 1
a270 1
                           keep looking for the *real* symbol. If the
d272 1
a272 1
                           trampoline entry. */
d492 1
a492 1
         minimal symbol table at all. */
d518 1
a518 1
	     Warning: this code is trickier than it would appear at first. */
d520 1
a520 1
	  /* Should also require that pc is <= end of objfile.  FIXME! */
d525 2
a526 2
		  /* pc is still strictly less than highest address */
		  /* Note "new" will always be >= lo */
d665 1
a665 1
	         overall. */
d696 1
a696 1
   for a matching PC (no section given) */
d736 1
a736 1
/* Return leading symbol character for a BFD. If BFD is NULL,
d753 1
a753 1
   symbol to allocate the memory for the first bunch. */
d819 1
a819 1
     is also stored stripped in the minimal symbol table. */
d861 1
a861 1
     add_minsym_to_hash_table will NOT add this msymbol to the hash table. */
d887 1
a887 1
   on unsigned comparisons, so that we sort into unsigned numeric order.  
d901 1
a901 1
      return (-1);		/* addr 1 is less than addr 2 */
d905 1
a905 1
      return (1);		/* addr 1 is greater than addr 2 */
d916 2
a917 2
	return 1;		/* fn1 has no name, so it is "less" */
      else if (name1)		/* fn2 has no name, so it is "less" */
d920 1
a920 1
	return (0);		/* neither has a name, so they're equal. */
d930 1
a930 1
   it.  Is it worth the extra trouble though? */
d1023 1
a1023 1
   thus causing the internal minimal_symbol pointers to become jumbled. */
d1031 1
a1031 1
  /* Clear the hash tables. */
d1038 1
a1038 1
  /* Now, (re)insert the actual entries. */
d1074 1
a1074 1
   attempts to demangle them if we later add more minimal symbols. */
d1108 1
a1108 1
         each bunch is full. */
d1140 1
a1140 1
         is indexed by mcount and not mcount-1. */
d1183 1
a1183 1
	 pointers to other msymbols need to be adjusted.) */
d1224 1
a1224 1
   is considered bad programming style. We could return 0 if we find
@


1.74
log
@run copyright.sh for 2011.
@
text
@d135 2
a136 2
      unsigned int hash
	= msymbol_hash_iw (SYMBOL_SEARCH_NAME (sym)) % MINIMAL_SYMBOL_HASH_SIZE;
@


1.73
log
@create and use symbol_set_language.

2010-08-09  Sami Wagiaalla  <swagiaal@@redhat.com>

	* symtab.h: Renamed SYMBOL_INIT_LANGUAGE_SPECIFIC to
	SYMBOL_SET_LANGUAGE.
	(symbol_init_language_specific): Renamed to symbol_set_language.
	* symtab.c (symbol_init_language_specific): Removed redundant check
	for language_cplus.
	Renamed to symbol_set_language.
	* stabsread.c (define_symbol): Updated.
	(read_enum_type): Updated
	* psymtab.c (add_psymbol_to_bcache): Updated.
	* minsyms.c (install_minimal_symbols): Updated.
	* coffread.c (process_coff_symbol): SYMBOL_SET_LANGUAGE instead of
	SYMBOL_LANGUAGE to set the language.
	* minsyms.c (prim_record_minimal_symbol_full): Ditto.
	* mdebugread.c (new_symbol): Ditto.
	* cp-namespace.c (check_one_possible_namespace_symbol): Ditto.
	* dwarf2read.c (new_symbol_full): Ditto.
	* jv-lang.c (add_class_symbol): Ditto.
@
text
@d3 2
a4 1
   2002, 2003, 2004, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
@


1.72
log
@2010-05-15  Michael Snyder  <msnyder@@vmware.com>

	* m2-lang.c: White space.
	* m2-valprint.c: White space.
	* macrocmd.c: White space.
	* macroexp.c: White space.
	* macroscope.c: White space.
	* macrotab.c: White space.
	* main.c: White space.
	* maint.c: White space.
	* mdebugread.c: White space.
	* memattr.c: White space.
	* minsyms.c: White space.
	* monitor.c: White space.
@
text
@d836 1
a836 2
  SYMBOL_INIT_LANGUAGE_SPECIFIC (msymbol, language_unknown);
  SYMBOL_LANGUAGE (msymbol) = language_auto;
d1147 1
a1147 1
      SYMBOL_INIT_LANGUAGE_SPECIFIC (&msymbols[mcount], language_unknown);
@


1.71
log
@	PR symtab/11198:
	* symtab.h (lookup_minimal_symbol_and_objfile): Declare.
	* minsyms.c (lookup_minimal_symbol_and_objfile): New function.
	* glibc-tdep.c (find_minsym_and_objfile): Remove.
	(glibc_skip_solib_resolver): Use
	lookup_minimal_symbol_and_objfile.
@
text
@d85 1
d105 1
d120 1
d136 1
d202 1
d212 1
d1170 1
d1249 1
@


1.70
log
@2010-01-06  Tristan Gingold  <gingold@@adacore.com>

	* symtab.c (lookup_global_symbol_from_objfile): Rename objfile
	parameter to main_objfile.  Iterate on all separate debug objfiles.
	* symfile.h (symbol_file_add_separate)
	(find_separate_debug_file_by_debuglink): Remove parameter names.
	* symfile.c (symbol_file_add_separate): Use add_separate_objfile.
	(reread_symbols): Use free_objfile_separate_debug.
	* objfiles.h (struct objfile): Add separate_debug_objfile_link.
	Adjust comment.
	(objfile_separate_debug_iterate, add_separate_debug_objfile)
	(free_objfile_separate_debug): New prototypes.
	* objfiles.c (objfile_separate_debug_iterate): New function.
	(add_separate_debug_objfile, free_objfile_separate_debug): New
	functions.
	(free_objfile): Use free_objfile_separate_debug.  Adjust for
	multiple separate debug objfile.
	(objfile_has_symbols): Adjust comment.  Iterate on all separate
	debug objfiles.
	* minsyms.c (lookup_minimal_symbol): Adjust for multiple separate
	debug objfile.
	(lookup_minimal_symbol_text): Ditto.
	(lookup_minimal_symbol_by_pc_name): Ditto.
	(lookup_minimal_symbol_solib_trampoline): Ditto.
	(lookup_minimal_symbol_by_pc_section_1): Iterate on all separate
	debug objfiles.
@
text
@d696 31
@


1.69
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d219 1
a219 1
	  || objf->separate_debug_objfile == objfile)
d327 1
a327 1
	  || objf->separate_debug_objfile == objfile)
d380 1
a380 1
	  || objf->separate_debug_objfile == objfile)
d419 1
a419 1
	  || objf->separate_debug_objfile == objfile)
a475 3
  objfile = section->objfile;
  if (objfile->separate_debug_objfile)
    objfile = objfile->separate_debug_objfile;
d477 3
a479 1
  for (; objfile != NULL; objfile = objfile->separate_debug_objfile_backlink)
@


1.68
log
@	* xcoffread.c (scan_xcoff_symtab): Update.
	* symfile.h (add_psymbol_to_list): Update prototype.
	* symfile.c (add_psymbol_to_bcache): Add copy_name argument.
	(add_psymbol_to_list): Likewise.
	* stabsread.c (define_symbol): Update.
	* mdebugread.c (parse_partial_symbols): Update.
	(handle_psymbol_enumerators): Update.
	(new_symbol): Update.
	* dbxread.c (read_dbx_symtab): Update.
	* coffread.c (process_coff_symbol): Update.
	* symtab.h (prim_record_minimal_symbol_full): Declare.
	(SYMBOL_SET_NAMES): Add copy_name argument.
	* symtab.c (struct demangled_name_entry): New struct.
	(hash_demangled_name_entry): New function.
	(eq_demangled_name_entry): Likewise.
	(create_demangled_names_hash): Use new functions.
	(symbol_set_names): Use struct demangled_name_entry.  Add
	copy_name argument.
	* minsyms.c (prim_record_minimal_symbol_full): New function.
	(prim_record_minimal_symbol_and_info): Use it.
	* elfread.c (record_minimal_symbol): Add name_len and copy_name
	arguments.  Call prim_record_minimal_symbol_full.
	(elf_symtab_read): Add copy_names argument.
	(elf_symfile_read): Update calls to elf_symtab_read.
	* dwarf2read.c (add_partial_symbol): Don't copy symbol names.
	(load_partial_dies): Likewise.
	(new_symbol): Likewise.
	* cp-namespace.c (check_one_possible_namespace_symbol): Don't save
	name on the obstack.  Update call to SYMBOL_SET_NAMES.
@
text
@d3 1
a3 1
   2002, 2003, 2004, 2007, 2008, 2009 Free Software Foundation, Inc.
@


1.67
log
@2009-09-14  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	*minsyms.c (lookup_minimal_symbol_by_pc_section_1): Assert non-NULL
	section.
	(lookup_minimal_symbol_by_pc_section): Check for NULL section.
	(lookup_minimal_symbol_by_pc): Adjust.
@
text
@d760 6
a765 5
prim_record_minimal_symbol_and_info (const char *name, CORE_ADDR address,
				     enum minimal_symbol_type ms_type,
				     int section,
				     asection *bfd_section,
				     struct objfile *objfile)
d784 4
a787 1
    ++name;
d802 1
a802 1
  SYMBOL_SET_NAMES (msymbol, (char *)name, strlen (name), objfile);
d835 15
@


1.66
log
@	gdb/
	* NEWS: Document inlined function support.
	* Makefile.in (SFILES): Add inline-frame.c.
	(COMMON_OBS): Add inline-frame.o.
	* block.c (contained_in): Rewrite to use lexical nesting.
	(block_linkage_function): Skip inlined function blocks.
	(block_inlined_p): New.
	* block.h (struct block): Update comment.
	(block_inlined_p): New prototype.
	* blockframe.c (get_frame_block): Handle inlined functions.
	(get_frame_function): Do not use block_linkage_function.
	(block_innermost_frame): Use get_frame_block and contained_in.
	* breakpoint.c (watchpoint_check): Remove extra reinit_frame_cache.
	Skip over inlined functions.  Simplify epilogue check.
	(bpstat_check_breakpoint_conditions): Use get_stack_frame_id.
	Update comments.
	(set_momentary_breakpoint): Only accept non-inlined frames.
	(watch_command_1): Use frame_unwind_caller_pc and
	frame_unwind_caller_id instead of get_prev_frame.
	(until_break_command): Likewise.  Use get_stack_frame_id.
	* buildsym.c (end_symtab): Set SYMBOL_SYMTAB for block functions.
	* dwarf2loc.c (dwarf_expr_frame_base): Use block_linkage_function.
	* dwarf2read.c (process_die): Handle DW_TAG_inlined_subroutine.
	(read_func_scope, new_symbol): Likewise.  Handle arguments specially
	for inlined functions without call site information.
	(inherit_abstract_dies): Allow tag mismatch for inlined subroutines.
	(die_specification): Treat DW_AT_abstract_origin as a specification.
	(read_type_die): Handle DW_TAG_inlined_subroutine.
	* frame-unwind.c (frame_unwind_init): Add inline_frame_unwind.
	* frame.c (fprint_frame_id): Print inline depth.
	(fprint_frame_type): Handle INLINE_FRAME and SENTINEL_FRAME.
	(skip_inlined_frames, get_stack_frame_id): New.
	(frame_unwind_caller_id): Use skip_inlined_frames.
	(frame_id_inlined_p): New.
	(frame_id_eq): Make the logic match the comments.  Add inline_depth
	check.
	(frame_id_inner): Handle inlined functions.
	(frame_unwind_pc): New function, copied from frame_unwind_caller_pc.
	(frame_unwind_caller_pc): Use skip_inlined_frames and frame_unwind_pc.
	(get_prev_frame_1): Check for inline frames.  Split out frame
	allocation to get_prev_frame_raw.
	(get_prev_frame_raw): New function.
	(get_prev_frame): Handle inline frames.
	(get_frame_pc): Use frame_unwind_pc.
	(get_frame_address_in_block): Skip inlined frames on both sides.
	(pc_notcurrent): Delete.
	(find_frame_sal): Rewrite to handle inline call sites.  Use
	get_frame_address_in_block.
	(deprecated_update_frame_pc_hack): Make static.
	* frame.h: Update comments.
	(struct frame_id): Add inline_depth.
	(enum frame_type): Add INLINE_FRAME.
	(frame_id_inlined_p, get_stack_frame_id): New prototypes.
	* gdbthread.h (struct thread_info): Add step_stack_frame_id field.
	* infcmd.c (set_step_frame): New function.
	(step_once): Use set_step_frame.  Handle inlined functions.
	(until_next_command): Use set_step_frame.
	(finish_backward), finish_forward): Use get_stack_frame_id.
	(finish_command): Support inlined functions.
	* inferior.h (set_step_info): New prototype.
	* infrun.c (RESUME_ALL): Use minus_one_ptid.
	(clear_proceed_status): Clear step_stack_frame_id.
	(init_wait_for_inferior): Call clear_inline_frame_state.
	(init_execution_control_state): Make static.
	(set_step_info): New function.
	(init_thread_stepping_state): Do not set the symtab or line here.
	(stepped_in_from): New function.
	(handle_inferior_event): Handle inlined functions.  Use set_step_info.
	(insert_step_resume_breakpoint_at_frame): Use get_stack_frame_id.
	(struct inferior_status): Add step_stack_frame_id.
	(save_inferior_status, restore_inferior_status): Save and restore
	step_stack_frame_id.
	* inline-frame.c, inline-frame.h: New files.
	* minsyms.c (prim_record_minimal_symbol_and_info): Use XCALLOC.
	* regcache.c (regcache_write_pc): Call reinit_frame_cache.
	* s390-tdep.c (s390_prologue_frame_unwind_cache): Handle INLINE_FRAME.
	* stack.c (frame_show_address): New.
	(print_frame_info, print_frame): Use it.
	(find_frame_funname): Use get_frame_function.  Handle inlined blocks.
	(frame_info): Mark inlined functions.
	(backtrace_command_1): Use get_current_user_frame.
	(print_frame_local_vars, print_frame_label_vars): Update comments.
	(return_command): Refuse inlined functions.
	* symtab.c (lookup_symbol_aux_local): Stop at inlined function
	boundaries.
	(find_function_start_sal): Avoid inlined functions.
	(completion_list_add_fields): New function.
	(default_make_symbol_completion_list): Use it.  Use block_static_block
	and block_global_block.  Check for inlined functions.
	(skip_prologue_using_sal): Avoid line number comparison across
	inlining.
	* symtab.h (struct symbol): Add is_inlined.
	(SYMBOL_INLINED): New.
	* target.c (target_resume): Call clear_inline_frame_state.
	* valops.c (value_of_variable): Check block_inlined_p.

	gdb/doc/
	* gdb.texinfo (Debugging Optimized Code): New chapter.
	(Compiling for Debugging): Reference it.  Move some
	text to the new section.

	gdb/testsuite/
	* gdb.base/break.exp: Add an XFAIL for gcc/36748.
	* gdb.cp/annota2.exp: Accept frames-invalid in more places.
	* gdb.opt/Makefile.in (EXECUTABLES): Update.
	* gdb.opt/clobbered-registers-O2.exp: Update to GPL v3.
	* gdb.opt/inline-bt.c, gdb.opt/inline-bt.exp,
	gdb.opt/inline-cmds.c, gdb.opt/inline-cmds.exp,
	gdb.opt/inline-locals.c, gdb.opt/inline-locals.exp,
	gdb.opt/inline-markers.c: New files.
	* lib/gdb.exp (skip_inline_frame_tests): New function.
	(skip_inline_var_tests): New function.
@
text
@d437 8
a444 7
   than or equal to PC, and matches SECTION (if non-NULL).  Returns a
   pointer to the minimal symbol if such a symbol is found, or NULL if
   PC is not in a suitable range.  Note that we need to look through
   ALL the minimal symbol tables before deciding on the symbol that
   comes closest to the specified PC.  This is because objfiles can
   overlap, for example objfile A has .text at 0x100 and .data at
   0x40000 and objfile B has .text at 0x234 and .data at 0x40048.
a460 1
  struct obj_section *pc_section;
a464 7
  
  /* PC has to be in a known section.  This ensures that anything
     beyond the end of the last segment doesn't appear to be part of
     the last function in the last segment.  */
  pc_section = find_pc_section (pc);
  if (pc_section == NULL)
    return NULL;
d466 1
a466 1
  /* We can not require the symbol found to be in pc_section, because
d475 2
a476 1
  objfile = pc_section->objfile;
d677 9
d695 1
a695 7
  /* NOTE: cagney/2004-01-27: This was using find_pc_mapped_section to
     force the section but that (well unless you're doing overlay
     debugging) always returns NULL making the call somewhat useless.  */
  struct obj_section *section = find_pc_section (pc);
  if (section == NULL)
    return NULL;
  return lookup_minimal_symbol_by_pc_section (pc, section);
@


1.65
log
@gdb

2009-03-31  Daniel Jacobowitz  <dan@@codesourcery.com>
	    Keith Seitz  <keiths@@redhat.com>
	    Jan Kratochvil  <jan.kratochvil@@redhat.com>

	PR gdb/6817
	* Makefile.in (dbxread.o): Update.
	* dbxread.c (read_dbx_symtab): Use cp_canonicalize_string.
	* dwarf2read.c (GDB_FORM_cached_string): New.
	(read_partial_die): Use dwarf2_canonicalize_name.
	(dwarf2_linkage_name): Use dwarf2_name.
	(dwarf2_canonicalize_name): New.
	(dwarf2_name): Use dwarf2_canonicalize_name.
	(dwarf_form_name, dump_die): Handle GDB_FORM_cached_string.
	* stabsread.c (define_symbol, read_type): Use cp_canonicalize_string.
	* symtab.c (lookup_symbol_in_language): Canonicalize input before
	searching.
	* cp-name-parser.y: operator() requires two parameters,
	according to libiberty.
	* minsyms.c (lookup_minimal_symbol): Canonicalize input
	before searching.
	* NEWS: Update.

gdb/testsuite

2009-03-31  Daniel Jacobowitz  <dan@@codesourcery.com>
	    Jan Kratochvil  <jan.kratochvil@@redhat.com>

	PR gdb/931
	* gdb.cp/gdb1355.exp (f_li, f_lui, f_si, f_sui): Allow canonical
	output.
	* gdb.cp/templates.exp: Allow canonical output.  Remove KFAILs
	for gdb/931.
	* dw2-strp.S (DW_AT_language): Change to C++.
	(DW_TAG_variable (name ""), Abbrev code 7, .Lemptyname): New.
@
text
@d793 1
a793 1
      new = (struct msym_bunch *) xmalloc (sizeof (struct msym_bunch));
@


1.64
log
@        Updated copyright notices for most files.
@
text
@d51 2
d192 3
d202 12
d238 4
a241 1
		    match = strcmp (SYMBOL_LINKAGE_NAME (msymbol), name) == 0;
d243 5
a247 1
		    match = SYMBOL_MATCHES_SEARCH_NAME (msymbol, name);
d286 4
@


1.63
log
@	* symtab.c (find_pc_sect_psymtab): Use MSYMBOL_TYPE.
	(find_pc_sect_symtab): Likewise.
	* symmisc.c (dump_msymbols): Use MSYMBOL_TYPE.
	* solib-som.c (som_solib_desire_dynamic_linker_symbols): Use
	MSYMBOL_TYPE, not SYMBOL_TYPE.
	* parse.c (write_exp_msymbol): Use MSYMBOL_TYPE.
	* objc-lang.c (find_methods): Use MSYMBOL_TYPE.
	* minsyms.c (lookup_minimal_symbol_by_pc_section_1): Use
	MSYMBOL_TYPE.
	* m2-exp.y (yylex): Use SYMBOL_CLASS.
@
text
@d3 1
a3 1
   2002, 2003, 2004, 2007, 2008 Free Software Foundation, Inc.
@


1.63.2.1
log
@2008-11-20  Stan Shebs  <stan@@codesourcery.com>

	Multi-process (primarily multi-exec) support.

	2008-10-14  Stan Shebs  <stan@@codesourcery.com>

	* blockframe.c (get_frame_block): Get inferior from frame.
	* block.c (block_for_pc_inf): New function.
	* block.h (block_for_pc_inf): Declare.
	* symfile.c (find_pc_inf_sect): New function.
	* symfile.h (find_pc_inf_sect): Declare.
	* symtab.c (find_pc_inf_line): New function.
	* symtab.h (find_pc_inf_line): Declare.
	* frame.c (struct frame_info) New field inferior.
	(fprint_frame_id): Display inferior.
	(get_frame_id): Set inferior_num from inferior.
	(frame_id_eq): Compare inferiors.
	(create_sentinel_frame): Set inferior.
	(create_new_frame): Copy inferior from sentinel.
	(get_prev_frame_raw): Copy inferior from next frame.
	(find_frame_sal): Use find_pc_inf_line.
	(get_frame_inferior): New function.
	* frame.h (struct frame_id): New field inferior_num.

	* breakpoint.c (expand_sals_by_inferiors): Copy section from input
	sal to expanded sals.
	* symtab.c (expand_line_sal): Ditto.

	2008-10-10  Stan Shebs  <stan@@codesourcery.com>

	* remote.c (discard_pending_stop_replies): Initialize prev.
	* infrun.c (infrun_thread_stop_requested): Ditto.

	2008-10-08  Stan Shebs  <stan@@codesourcery.com>

	* inferior.h (struct inferior): Rename environ field to inf_environ.
	* inferior.c (print_inferior): Ditto.

	2008-10-01  Stan Shebs  <stan@@codesourcery.com>

	* inferior.h (detach_fork): Declare here...
	* linux-fork.h (detach_fork): ...instead of here.
	* linux-fork.c (detach_fork): Move to...
	* infrun.c (detach_fork): ...here.
	* remote.c (detach_fork): Remove decl.

	2008-09-30  Stan Shebs  <stan@@codesourcery.com>

	* linespec.c (decode_line_1): Better default for one-exec case.
	* remote (remote_start_remote): Use the exec in the one-exec case.

	2008-09-29  Stan Shebs  <stan@@codesourcery.com>

	* infcmd.c (attach_command): If only one exec, assume it is the
	attached inferior's exec.
	(attach_command_post_wait): Set inferior's exec from
	the one that was found.
	* inf-ptrace.c (inf_ptrace_attach): Only report exec file if
	if there is just one present.
	(inf_ptrace_detach): Use inferior to get correct exec name.

	2008-09-29  Stan Shebs  <stan@@codesourcery.com>

	* inferior.c (print_inferior): Use exec short names, and drop
	unused address space display.

	2008-09-26  Stan Shebs  <stan@@codesourcery.com>

	* breakpoint.c (should_be_inserted): Test for no inferior.
	(clone_breakpoint_location): New function, broken out from...
	(update_breakpoint_inferiors): ...here, also tweak conditions
	for adding a location.
	(insert_breakpoint_location): Don't count non-running inferiors.
	(remove_breakpoint): Set tmp_inf.
	(print_one_breakpoint_location): Add allflag arg, use to always
	show inf.
	(print_one_breakpoint): Add allflag arg.
	(do_captured_breakpoint_query): Fix caller.
	(breakpoint_1): Ditto.
	* exec.c (create_exec): Save full pathname as exec name.
	(find_exec_by_name): Use find_exec_by_substr.
	* fork-child.c (fork_inferior): Warn if exec not found for new
	inferior.

	2008-09-25  Stan Shebs  <stan@@codesourcery.com>

	* breakpoint.c (should_be_inserted): Don't insert in inferiors
	that are not running.
	(update_breakpoint_inferiors): New function.
	(insert_breakpoints): Call it.
	(insert_breakpoint_locations): Don't insert in inferiors that are
	not running.
	(set_raw_breakpoint_without_location): Set trigger set from
	current itset here...
	(set_raw_breakpoint): Instead of here. Also add default fillins
	for the location's inferior.
	(add_location_to_breakpoint): Similarly.
	(expand_sals_by_inferiors): New function.
	(breakpoint_re_set_one): Call it.
	(resolve_sal_pc): Don't set sal inferior.
	* breakpoint.h (struct breakpoint): Remove exec field, never used.
	* inferior.h (inferior_list): Declare.
	* inferior.c (inferior_list): Make public.
	(add_inferior_to_itset): Auto-add inferiors after exec's inferior.
	(first_inferior_in_set): Check for zero-length vector.
	* exec.c (xfer_memory): Use tmp_inf as inferior if set.
	* infcmd.c (focus_command): Improve user feedback.
	* linespec.c (build_canonical_line_spec): Record exec name as part
	of canonical spec.
	(symbol_found): Canonicalize specs more.
	(decode_indirect): Revert rewrite from 2008-09-14.
	(decode_sharp): Use find_exec_by_substr, better error messages.
	* minsyms.c (lookup_minimal_symbol_in_exec): New function.
	(lookup_minimal_symbol_in_exec_1): New function, body of
	lookup_minimal_symbol.
	* symtab.h (lookup_minimal_symbol_in_exec): Declare.
	* symtab.c (find_function_start_sal): Set inferior to use.
	(append_expanded_sal): Return pointer to the new sal.
	* remote.c (remote_xfer_memory): Better parms to ptid_build, remove
	debug print.
	(remote_xfer_partial): Ditto.

	2008-09-22  Pedro Alves  <pedro@@codesourcery.com>

	* inferior.c (itset_member): Fix typo.

	2008-09-22  Stan Shebs  <stan@@codesourcery.com>

	* inferior.h (current_inf): Remove declaration.
	(tmp_inf): Declare.
	* inferior.c (current_inf): Remove.
	(tmp_inf): New global, hack to bypass passing inferior throughout
	target stack.
	(print_inferior): Don't report current_inf.
	(add_inferior_command): Don't use current_inf.
	(name_inferior_command): Use first inferior of current_itset.
	(update_itset): Handle NULL case.
	(add_inferior_itset): Recursively add all inferiors derived from
	an exec if the exec's own inferior is present.
	(first_inferior_in_set): New function.
	(free_inferior): Comment out until references cleared reliably.
	* infcmd.c (focus_command): Don't set current_inf.
	(get_inferior_args): Use first_inferior_in_set instead of
	current_inf.
	(set_inferior_args): Ditto.
	(set_inferior_args_vector): Ditto.
	(notice_args_set): Ditto.
	* breakpoint.c (insert_breakpoint_locations): Remove insertion test
	using current_inf, set tmp_inf.
	(reattach_breakpoints): Set tmp_inf.
	(bpstat_check_breakpoint_conditions): Test trigger set here...
	(bpstat_stop_status): ... instead of here.
	(bpstat_check_trigger_set): Add special case for exec's own
	inferior.
	(print_one_breakpoint_location): Also test for multiple inferiors
	before displaying location's inferior, flag trigger set with "i/t"
	instead of "focus".
	(check_duplicates): Pass location's inferior to...
	(check_duplicates_for): Add inferior arg and use.
	(set_raw_breakpoint): Override sal inferior with one from the
	trigger set.
	(add_location_to_breakpoint): Ditto.
	* remote.c (remote_xfer_memory): Switch inferiors if tmp_inf is
	set to something different from inferior_ptid.
	(remote_xfer_partial): Ditto.
	* top.c (execute_command): Always update the current itset.

	2008-09-19  Stan Shebs  <stan@@codesourcery.com>

	* inferior.c (set_inferior_exec): New function.
	(set_inferior_exec_command): New command.
	* inferior.h: Declare set_inferior_exec.
	* fork-child.c (fork_inferior): Set the inferior's exec.
	* remote.c (extended_remote_create_inferior_1): Ditto.
	gdb/doc/
	* gdb.texinfo (Debugging Multiple Programs): Describe set-exec.

	2008-09-18  Stan Shebs  <stan@@codesourcery.com>

	* target.c (target_resize_to_sections): Adjust execs' section
	tables too.

	2008-09-17  Stan Shebs  <stan@@codesourcery.com>

	gdb/doc/
	* gdb.texinfo (Invoking GDB): Describe multiple program args.
	(File Options): Describe multi-program effects.
	(Multiple Programs): New section, multi-program debugging.
	(Forks): Rename section from "Processes".
	(Specify Location): Describe the #-syntax.
	(Variables): Describe the #-syntax.
	(Files): Describe add-file and add-exec-file.
	(Maintenance Commands): Describe maint print execs.

	2008-09-15  Stan Shebs  <stan@@codesourcery.com>

	* exec.c (addr_space_info_command): Don't try to display host address.

	2008-09-14  Stan Shebs  <stan@@codesourcery.com>

	* c-exp.y: (yylex): Accept '#' in identifiers.
	* linespec.c (decode_sharp): New function.
	(decode_line_1): Use it for #-syntax.
	(decode_indirect): Rewrite to accept exec arg and iterate over
	inferiors.
	(struct d_i_data): New struct for inferior iteration.
	(decode_indirect_callback): New function.
	(decode_variable): Pass in exec, use in symbol lookup.

	2008-09-14  Stan Shebs  <stan@@codesourcery.com>

	* breakpoint.h (struct bp_location): Add inferior field instead
	of address space field.
	* breakpoint.c (insert_breakpoint_locations): Only insert in
	appropriate inferior.
	(bpstat_check_trigger_set): New function.
	(bpstat_stop_status): Call it, check location's inferior also.
	(print_one_breakpoint_location): Report location's inferior.
	(set_raw_breakpoint): Set location inferior, clear an experiment.
	(add_location_to_breakpoint): Ditto.
	(expand_line_sal_maybe): Check for non-NULL original function.
	(resolve_sal_pc): Set sal inferior.
	(clear_command): Be careful to not clear anything twice.
	* symtab.h: Update declarations of symbol lookups.
	(struct symtab_and_line): Change address space to inferior field.
	* symtab.c (init_sal): Clear inferior field.
	(append_expanded_sal): Set inferior.
	(lookup_symbol_in_language_1): New function.
	(lookup_symbol_in_language): Call it.
	(lookup_symbol_in_exec_in_language): New function.
	(lookup_symbol): Detect #-syntax and find exec to use.
	(lookup_symbol_aux): Add exec argument and use it.
	(lookup_symbol_aux_symtabs): Ditto.
	(lookup_symbol_aux_psymtabs): Ditto.
	(basic_lookup_symbol_nonlocal): Ditto.
	(lookup_symbol_static): Ditto.
	(lookup_symbol_global): Ditto.
	* ada-lang.c (cp_lookup_symbol_nonlocal): Ditto.
	* cp-support.h (cp_lookup_symbol_nonlocal): Ditto.
	* cp-namespace.c (cp_lookup_symbol_nonlocal): Ditto.
	* language.h (struct language_defn): Ditto.
	* scm-valprint.c (scm_inferior_print): Add exec arg to
	lookup_symbol_global.
	* source.c (select_source_symtab): Use current_exec.
	* addrspace.h (struct addr_space): New field num.
	* exec.h (struct exec): New fields sections and sections_end.
	* exec.c (exec_file_attach_1): Set them from exec_ops, set
	inferior's address space name from exec.
	(find_exec_by_substr): New function.
	(build_section_table): Don't free old table.
	(print_section_info): Use exec's section table.
	(next_address_space_num): New global, numbering for address spaces.
	(new_address_space): Use it.
	(addr_space_info_command): Display it.
	* infcmd.c (set_current_exec): Set exec_ops section table.
	* inferior.h (update_itset): Declare.
	* inferior.c (add_inferior_silent): Set address space.
	(print_inferior): Display it.
	(number_of_inferiors): New function.
	(itset_member): New function.

	2008-09-04  Stan Shebs  <stan@@codesourcery.com>

	* corefile.c (close_exec_file): Remove #if 0 block.
	(validate_files): Use first_exec instead of exec_bfd.
	(get_exec_file): Ditto.
	* corelow.c (core_open): Ditto.
	* utils.c (string_to_core_addr): Ditto.
	* arch-utils.c (gdbarch_update_p): Ditto.
	* linux-thread-db.c (enable_thread_event): Ditto.
	(thread_db_get_thread_local_address ): Ditto.
	* exec.c (find_exec_by_name): Test short name also.
	(file_command): Set current exec.

	2008-09-03  Stan Shebs  <stan@@codesourcery.com>

	* inferior.c (add_threads_to_itset): Default to including all
	of an inferior's threads.

	2008-08-31  Stan Shebs  <stan@@codesourcery.com>

	Parsing for i/t sets.
	* inferior.h (struct itset_entry): New struct.
	(struct itset): Make thread lists be per-inferior, add parse state
	variables.
	* inferior.c: (add_inferior_command): Add error checking and
	confirmation.
	(remove_inferior_command): Update for itset restructuring.
	(new_itset): Don't pass in dynamic-ness, call parse_itset_spec.
	(update_itset): Similarly.
	(parse_itset_spec): New, parsing of itset spec.
	(parse_itset_list, parse_itset_range, etc): New.
	(make_itset_from_spec): Rewrite.
	(dump_itset): Rewrite to reflect itset structure.
	* infcmd.c (focus_command): Similarly.

	2008-08-25  Stan Shebs  <stan@@codesourcery.com>

	First part of multiprocess support.
	* Makefile.in (COMMON_OBS): Add inferior.o.
	* addrspace.h: New file.
	* breakpoints.h (struct bp_location): Add address space field.
	(struct breakpoint): Add trigger set and exec fields.
	* breakpoints.c (print_one_breakpoint_location): Display trigger
	set.
	(set_raw_breakpoint): Set trigger set from current itset.
	* corefile.c (reopen_exec_file): Rewrite for multiple execs.
	(get_exec_file): Add case for current_exec.
	* corelow.c (is_core_file): New function.
	(core_files_info): Pass additional arg to print_section_info.
	* exec.h (struct exec): New struct.
	* exec.c (execs): New global.
	(exec_bfd_mtime): Remove.
	(last_exec_created, current_exec, first_exec): New globals.
	(exec_close): Clear all exec objects.
	(exec_file_clear): Tweak user message.
	(exec_file_add): New function.
	(exec_file_attach_1): New function, body of exec_file_attach,
	plus new code to handle multiple execs.
	(exec_file_attach): Call it.
	(exec_file_update): New function.
	(create_exec, find_exec_by_name, number_of_execs): New functions.
	(exec_file_command): Rephrase query, set current exec.
	(add_exec_file_command): New command.
	(add_file_command): New command.
	(print_section_info): Add exec argument.
	(exec_files_info): Rewrite for multiple execs.
	(maintenance_print_execs): New function.
	(new_address_space): New function.
	(addr_space_info_command): New command.
	* gdbcore.h (exec_bfd_mtime): Remove decl.
	(exec_file_add): Declare.
	* infcmd.c: Include exec.h.
	(current_itset): New global.
	(set_current_exec): New function.
	(focus_command): New command.
	(get_inferior_args): Maybe get from the current inferior.
	(set_inferior_args): Also set in current inferior.
	(set_inferior_args_vector): Similarly.
	(notice_args_set): Similarly.
	(attach_command): Rephrase query.
	* inferior.h (struct inferior): New struct.
	(struct itset): New struct.
	* inferior.c: New file, management of multiple inferiors.
	* main.c (captured_main): Rewrite to allow multiple executables,
	pids, and corefiles on the command line.
	* maint.c (maintenance_info_sections): Rewrite for multiple execs.
	* objfiles.h (struct objfile): New field for exec.
	(ALL_OBJFILES_FOR_EXEC, ALL_PRIMARY_SYMTABS_FOR_EXEC,
	ALL_PSYMTABS_FOR_EXEC): New macros.
	* objfiles.c (allocate_objfile): Clear exec field.
	* solib.c (clear_solib): Use first_exec instead of exec_bfd.
	* source.c (select_source_symtab): Use ALL_OBJFILES_FOR_EXEC.
	(find_source_lines): Use mtime from exec.
	* symfile.c (syms_from_objfile): Don't clear objfile if multiple
	execs.
	(new_symfile_objfile): Get objfile's exec from last_exec_created.
	(symbol_file_clear): Rephrase messages.
	(reread_symbols): Update objfile's exec if necessary.
	* symmisc.c (dump_objfile): Dump objfile's exec also.
	(maintenance_print_objfiles): Report symfile_objfile.
	* symtab.h (struct symtab_and_line): Add address space field.
	* symtab.c (find_pc_sect_psymtab): Look for a plausible exec, and
	then use it.
	(lookup_symbol_aux_symtabs): Use current exec.
	(lookup_symbol_aux_symtabs): Ditto.
	(basic_lookup_transparent_type): Ditto.
	(find_pc_sect_symtab): Ditto.
	* target.h (print_section_info): Add arg to decl.
	* tui/tui-win.c: Rename "focus" command to "ffocus".

gdb/testsuite:

2008-11-20  Stan Shebs  <stan@@codesourcery.com>

	2008-09-14  Stan Shebs  <stan@@codesourcery.com>

	* gdb.gdb/selftest.exp: Update to reflect current sources.
	* Makefile.in (ALL_SUBDIRS): Add gdb.multi.
	* configure.ac (AC_OUTPUT): Add gdb.multi/Makefile.
	* configure: Regenerate.

	* gdb.multi/Makefile.in: New.
	* gdb.multi/hello.c, hangout.c, goodbye.c: New source files.
	* gdb.multi/base.exp: New file, basic multiprocess tests.

	2008-08-25  Stan Shebs  <stan@@codesourcery.com>

	* config/monitor.exp: Match on rephrased message.
	* gdb.base/attach.exp: Ditto.
	* gdb.base/default.exp: Ditto.
	* lib/gdb.exp: Ditto.
@
text
@a176 5
extern struct minimal_symbol *lookup_minimal_symbol_in_exec_1 (const char *name,
							       const char *sfile,
							       struct objfile *objf,
							       struct exec *exec);

a180 14
  return lookup_minimal_symbol_in_exec_1 (name, sfile, objf, NULL);
}

struct minimal_symbol *
lookup_minimal_symbol_in_exec (const char *name, const char *sfile,
			       struct exec *exec)
{
  return lookup_minimal_symbol_in_exec_1 (name, sfile, NULL, exec);
}

struct minimal_symbol *
lookup_minimal_symbol_in_exec_1 (const char *name, const char *sfile,
				 struct objfile *objf, struct exec *exec)
{
a200 4
      /* If an exec is specified, limit to objfiles associated with it.  */
      if (exec != NULL && exec != objfile->exec)
	continue;

@


1.62
log
@	* xcoffread.c (RECORD_MINIMAL_SYMBOL): Update.
	(scan_xcoff_symtab): Update.
	* mdebugread.c (record_minimal_symbol): Update.
	(parse_partial_symbols): Update.
	* elfread.c (record_minimal_symbol): Update.
	* dbxread.c (record_minimal_symbol): Update.
	* coffread.c (record_minimal_symbol): Update.
	* sh64-tdep.c (MSYMBOL_IS_SPECIAL): Redefine.
	(sh64_elf_make_msymbol_special): Update.
	* mips-tdep.c (mips_elf_make_msymbol_special): Use
	MSYMBOL_TARGET_FLAG_1.
	(mips_elf_make_msymbol_special): Likewise.
	(msymbol_is_special): Likewise.
	* minsyms.c (prim_record_minimal_symbol_and_info): Update.
	(install_minimal_symbols): Likewise.
	(prim_record_minimal_symbol): Update.
	(prim_record_minimal_symbol_and_info): Remove 'info' argument.
	* m68hc11-tdep.c (MSYMBOL_SET_RTC): Redefine.
	(MSYMBOL_SET_RTI): Redefine.
	(MSYMBOL_IS_RTC): Redefine.
	(MSYMBOL_IS_RTI): Redefine.
	* arm-tdep.c (MSYMBOL_SET_SPECIAL): Redefine.
	(MSYMBOL_IS_SPECIAL): Redefine.
	* symtab.h (struct minimal_symbol) <info>: Remove.
	<target_flag_1, target_flag_2>: New fields.
	(MSYMBOL_INFO): Remove.
	(MSYMBOL_TARGET_FLAG_1): New macro.
	(MSYMBOL_TARGET_FLAG_2): Likewise.
	(prim_record_minimal_symbol_and_info): Update.
@
text
@d534 1
a534 1
		  if (msymbol[hi].type == mst_abs)
@


1.61
log
@	* breakpoint.h (struct bp_location): Change type of section
	member to "struct obj_section *".
	* tracepoint.h (struct tracepoint): Likewise.
	* symtab.h (struct general_symbol_info): Replace bfd_section
	member with obj_section.
	(struct symtab_and_line): Change type of section member to
	"struct obj_section *".
	(SYMBOL_BFD_SECTION): Remove macro, replace by ...
	(SYMBOL_OBJ_SECTION): ... this.

	* minsym.c (prim_record_minimal_symbol_and_info): Record symbol
	section as obj_section instead of bfd_section.

	* ada-lang.c (ada_decode_symbol): Use gsymbol->obj_section
	directly instead of looking of obj_section from bfd_section.

	* objfiles.h (find_pc_sect_section): Remove.
	* objfiles.c (find_pc_sect_section): Remove.
	(find_pc_section): Inline find_pc_sect_section code.

	* symfile.h (find_pc_overlay): Return struct obj_section *.
	(find_pc_mapped_section): Likewise.
	(section_is_overlay, section_is_mapped): Change type of section
	argument to struct obj_section *.
	(pc_in_mapped_range, pc_in_unmapped_range): Likewise.
	(overlay_mapped_address, overlay_unmapped_address): Likewise.
	(symbol_overlayed_address): Likewise.
	* symtab.h (symbol_overlayed_address): Likewise.
	* symfile.c (overlay_is_mapped): Remove.
	(section_is_mapped): Inline overlay_is_mapped code.  Update.
	(overlay_invalidate_all): Update.
	(section_is_overlay): Change section argument to type
	"struct obj_section *".  Use bfd_ methods.
	(pc_in_unmapped_range): Likewise.  Handle relocated sections.
	(pc_in_mapped_range): Likewise.  Handle relocated sections.
	(sections_overlap): Likewise.
	(overlay_unmapped_address): Likewise.
	(overlay_mapped_address): Likewise.
	(symbol_overlayed_address): Likewise.
	(find_pc_overlay): Return struct obj_section *.
	(find_pc_mapped_section): Likewise.
	(list_overlays_command): Update.
	(map_overlay_command, unmap_overlay_command): Update.
	(simple_overlay_update): Update.

	* block.h (blockvector_for_pc_sect): Change section argument
	to type "struct obj_section *".
	(block_for_pc_sect): Likewise.
	* block.c (blockvector_for_pc_sect): Change section argument
	to type "struct obj_section *".
	(block_for_pc_sect): Likewise.
	* symtab.h (find_pc_sect_function, find_pc_sect_psymtab,
	find_pc_sect_symtab, find_pc_sect_psymbol, find_pc_sect_line,
	lookup_minimal_symbol_by_pc_section, find_function_start_pc): Likewise.
	(matching_bfd_sections): Rename to ...
	(matching_obj_sections): ... this.  Update argument types.
	* blockframe.c (find_pc_sect_function): Likewise.
	* breakpoint.c (describe_other_breakpoints): Likewise.
	(breakpoint_has_pc, check_duplicates_for): Likewise.
	* minsyms.c (lookup_minimal_symbol_by_pc_section_1): Likewise.
	(lookup_minimal_symbol_by_pc_section): Likewise.
	* symtab.c (find_pc_sect_psymtab_closer): Likewise.
	(find_pc_sect_psymtab, find_pc_sect_psymbol, find_pc_sect_symtab,
	find_pc_sect_line, find_function_start_pc): Likewise.
	(matching_bfd_sections): Rename to ...
	(matching_obj_sections): ... this.  Update argument types.

	* blockframe.c (find_pc_partial_function): Update to section
	type changes.  No longer call find_pc_sect_section.
	(cache_pc_function_section): Change to type "struct obj_section *".
	* breakpoint.c (resolve_sal_pc): Update to section type changes.
	* exec.c (xfer_memory): Likewise.
	* findvar.c (read_var_value): Likewise.
	* infcmd.c (jump_command): Likewise.
	* linespec.c (minsym_found): Likewise.
	* maint.c (maintenance_translate_address): Likewise.
	* minsyms.c (lookup_minimal_symbol_by_pc_section_1): Likewise.
	(lookup_solib_trampoline_symbol_by_pc): Likewise.
	* parse.c (write_exp_msymbol): Likewise.
	* printcmd.c (build_address_symbolic): Likewise.
	(address_info, sym_info): Likewise.
	* symmisc.c (dump_msymbols, print_symbol): Likewise.
	* symtab.c (fixup_section): Likewise.
	(fixup_symbol_section, fixup_psymbol_section): Likewise.
	(find_pc_line, find_function_start_sal): Likewise.
	* target.c (memory_xfer_partial): Likewise.
	* hppa-hpux-tdep.c (hppa64_hpux_in_solib_call_trampoline): Likewise.
	* spu-tdep.c (spu_overlay_update): Likewise.
@
text
@d728 1
a728 1
				       NULL, section, NULL, objfile);
d737 1
a737 1
				     char *info, int section,
d791 2
a792 2
  /* FIXME:  This info, if it remains, needs its own field.  */
  MSYMBOL_INFO (msymbol) = info;	/* FIXME! */
d1064 2
a1065 1
      MSYMBOL_INFO (&msymbols[mcount]) = NULL;
@


1.60
log
@	* ax-gdb.c (gen_var_ref): Use SYMBOL_LINKAGE_NAME.
	* blockframe.c (find_pc_partial_function): Likewise.
	* buildsym.c (find_symbol_in_list): Likewise.
	* c-valprint.c (c_val_print): Likewise.
	* coffread.c (patch_opaque_types, process_coff_symbol): Likewise.
	(coff_read_enum_type): Likewise.  Use SYMBOL_SET_LINKAGE_NAME.
	* cp-support.c (cp_remove_params): Renamed from remove_params and
	made global.
	(overload_list_add_symbol): Update call to remove_params.
	* cp-support.h (cp_remove_params): Declare.
	* dwarf2read.c (process_enumeration_scope): Use SYMBOL_LINKAGE_NAME.
	(dwarf2_const_value): Use SYMBOL_PRINT_NAME.
	* expprint.c (dump_subexp_body_standard): Likewise.
	* f-valprint.c (info_common_command, there_is_a_visible_common_named):
	Use SYMBOL_LINKAGE_NAME to find symbols and SYMBOL_PRINT_NAME
	for messages.
	* findvar.c (read_var_value): Use SYMBOL_LINKAGE_NAME.
	* gnu-v2-abi.c (gnuv2_value_rtti_type): Likewise.
	* hppa-hpux-tdep.c (hppa32_hpux_in_solib_call_trampoline)
	(hppa_hpux_skip_trampoline_code): Use SYMBOL_LINKAGE_NAME to find
	symbols and SYMBOL_PRINT_NAME for messages.
	* jv-lang.c (add_class_symbol): Use SYMBOL_SET_LINKAGE_NAME.
	* linespec.c (decode_line_2): Use SYMBOL_LINKAGE_NAME.
	* mdebugread.c (parse_symbol): Use SYMBOL_LINKAGE_NAME and
	SYMBOL_SET_LINKAGE_NAME.
	(mylookup_symbol): Use SYMBOL_LINKAGE_NAME.
	* minsyms.c (add_minsym_to_demangled_hash_table): Use
	SYMBOL_SEARCH_NAME.
	(lookup_minimal_symbol): Use SYMBOL_LINKAGE_NAME or
	SYMBOL_MATCHES_SEARCH_NAME, depending on the pass.
	* objfiles.h (ALL_OBJFILE_MSYMBOLS): Use SYMBOL_LINKAGE_NAME.
	* printcmd.c (build_address_symbolic): Use SYMBOL_LINKAGE_NAME.
	(address_info): Use SYMBOL_PRINT_NAME for messages and
	SYMBOL_LINKAGE_NAME for lookups.
	* sol-thread.c (info_cb): Use SYMBOL_PRINT_NAME for messages.
	* stabsread.c (patch_block_stabs, define_symbol)
	(read_type, read_enum_type, common_block_end)
	(cleanup_undefined_types_1, scan_file_globals): Use
	SYMBOL_LINKAGE_NAME, SYMBOL_SET_LINKAGE_NAME, ALL_OBJFILE_MSYMBOLS,
	and SYMBOL_PRINT_NAME.
	* stack.c (print_frame_args): Use SYMBOL_LINKAGE_NAME.
	(print_frame, frame_info): Use SYMBOL_PRINT_NAME for output.  Use
	cp_remove_params instead of cplus_demangle.
	(print_block_frame_labels, print_frame_arg_vars): Use
	SYMBOL_LINKAGE_NAME.
	* symmisc.c (dump_msymbols): Use ALL_OBJFILE_MSYMBOLS and
	SYMBOL_LINKAGE_NAME.
	(dump_symtab_1, print_symbol, print_partial_symbols)
	(maintenance_check_symtabs): Use SYMBOL_LINKAGE_NAME.
	* symtab.h (DEPRECATED_SYMBOL_NAME): Delete.
	(SYMBOL_SET_LINKAGE_NAME): New.
	(SYMBOL_SET_NAMES): Add a comment.
	* tracepoint.c (set_traceframe_context, validate_actionline)
	(collect_symbol, scope_info): Use SYMBOL_LINKAGE_NAME for
	lookups and SYMBOL_PRINT_NAME for output.
	* typeprint.c (typedef_print): Use SYMBOL_LINKAGE_NAME.
	* xcoffread.c (process_xcoff_symbol): Use SYMBOL_SET_LINKAGE_NAME.
@
text
@d422 2
a423 1
lookup_minimal_symbol_by_pc_section_1 (CORE_ADDR pc, asection *section,
d546 3
a548 3
		      && SYMBOL_BFD_SECTION (&msymbol[hi]) != NULL
		      && (!matching_bfd_sections
			  (SYMBOL_BFD_SECTION (&msymbol[hi]), section)))
d565 2
a566 2
		      && (SYMBOL_BFD_SECTION (&msymbol[hi])
			  == SYMBOL_BFD_SECTION (&msymbol[hi - 1])))
d653 1
a653 1
lookup_minimal_symbol_by_pc_section (CORE_ADDR pc, asection *section)
d670 1
a670 1
  return lookup_minimal_symbol_by_pc_section (pc, section->the_bfd_section);
d741 1
d777 12
a788 1
  SYMBOL_BFD_SECTION (msymbol) = bfd_section;
d1128 1
a1128 2
  msymbol = lookup_minimal_symbol_by_pc_section_1 (pc, section->the_bfd_section,
						   1);
@


1.59
log
@gdb/

2008-05-15  Pedro Alves  <pedro@@codesourcery.com>
	    Ulrich Weigand  <uweigand@@de.ibm.com>

	* minsyms.c (lookup_minimal_symbol_by_pc_name): New function.
	* symtab.h (lookup_minimal_symbol_by_pc_name): Add prototype.

	* symtab.c (fixup_section): Remove prototype.  Add ADDR parameter;
	use it instead of ginfo->value.address.  Look up minimal symbol by
	address and name.  Assume OBJFILE is non-NULL.
	(fixup_symbol_section): Ensure we always have an objfile to look
	into.  Extract and pass to fixup_section the symbol's address that
	will match the minimal symbol's address.
	(fixup_psymbol_section): Likewise.

	(find_pc_sect_psymtab): Fall back to non-addrmap case when debugging
	overlays and the addrmap returned the wrong section.

	* dwarf2read.c (var_decode_location): Set SYMBOL_CLASS before
	calling fixup_symbol_section.


gdb/testsuite/

2008-05-15  Pedro Alves  <pedro@@codesourcery.com>

	* gdb.base/fixsection.exp: New file.
	* gdb.base/fixsection0.c: New file.
	* gdb.base/fixsection1.c: New file.
@
text
@d129 2
a130 1
      unsigned int hash = msymbol_hash_iw (SYMBOL_DEMANGLED_NAME (sym)) % MINIMAL_SYMBOL_HASH_SIZE;
d218 7
a224 9
		  /* FIXME: carlton/2003-02-27: This is an unholy
		     mixture of linkage names and natural names.  If
		     you want to test the linkage names with strcmp,
		     do that.  If you want to test the natural names
		     with strcmp_iw, use SYMBOL_MATCHES_NATURAL_NAME.  */
		  if (strcmp (DEPRECATED_SYMBOL_NAME (msymbol), (name)) == 0
		      || (SYMBOL_DEMANGLED_NAME (msymbol) != NULL
			  && strcmp_iw (SYMBOL_DEMANGLED_NAME (msymbol),
					(name)) == 0))
@


1.58
log
@	* minsyms.c: Include "target.h".
	(find_solib_trampoline_target): Handle minimal symbols pointing
	to function descriptors as well.
	* Makefile.in (minsyms.o): Update dependencies.

	* ppc-linux-tdep.c (ppc64_standard_linkage): Rename to ...
	(ppc64_standard_linkage1): ... this.  Fix optional instructions.
	(PPC64_STANDARD_LINKAGE_LEN): Rename to ...
	(PPC64_STANDARD_LINKAGE1_LEN): ... this.
	(ppc64_standard_linkage2, ppc64_standard_linkage3): New.
	(PPC64_STANDARD_LINKAGE2_LEN, PPC64_STANDARD_LINKAGE3_LEN): New.
	(ppc64_standard_linkage_target): Rename to ...
	(ppc64_standard_linkage1_target): ... this.
	(ppc64_standard_linkage2_target, ppc64_standard_linkage3_target): New.
	(ppc64_skip_trampoline_code): Support three variants of standard
	linkage stubs.  Call find_solib_trampoline_target to handle
	glink stubs.
@
text
@d335 35
@


1.57
log
@	* elfread.c (elf_symtab_read): Create trampolines for @@plt symbols.
	* minsyms.c (lookup_minimal_symbol_by_pc_section_1): Renamed from
	lookup_minimal_symbol_by_pc_section.  Prefer trampolines if requested.
	(lookup_minimal_symbol_by_pc_section): Use
	lookup_minimal_symbol_by_pc_section_1.
	(lookup_solib_trampoline_symbol_by_pc): Likewise.
@
text
@d50 1
d1114 16
@


1.56
log
@	* linespec.c: Include "target.h".
	(minsym_found): Handle minimal symbols pointing to function
	descriptors.  Use find_function_start_pc.
	* minsyms.c (msymbol_objfile): New function.
	* parse.c (write_exp_msymbol): Handle minimal symbols pointing
	to function descriptors.
	* symtab.c (fixup_section): Only use minimal symbol at the same
	address to determine section of a symbol.
	(find_function_start_pc): New function.
	(find_function_start_sal): Use it.
	* symtab.h (msymbol_objfile): Add prototype.
	(find_function_start_pc): Likewise.
	* value.c: Include "objfiles.h".
	(value_fn_field): Handle minimal symbols pointing to function
	descriptors.
	* Makefile.in (linespec.o): Update dependencies.
	(value.o): Likewise.
@
text
@d380 1
a380 1
   0x40000 and objfile B has .text at 0x234 and .data at 0x40048.  */
d382 7
a388 2
struct minimal_symbol *
lookup_minimal_symbol_by_pc_section (CORE_ADDR pc, asection *section)
d397 1
d399 3
d518 18
d616 6
d1075 7
a1081 1
  struct minimal_symbol *msymbol = lookup_minimal_symbol_by_pc (pc);
@


1.55
log
@	Updated copyright notices for most files.
@
text
@d135 20
@


1.54
log
@	* minsyms.c (lookup_minimal_symbol): Also check the separate
	debug objfile.
	(lookup_minimal_symbol_text): Likewise.
	(lookup_minimal_symbol_solib_trampoline): Likewise.
	* symtab.c (lookup_global_symbol_from_objfile): Likewise.
@
text
@d3 1
a3 1
   2002, 2003, 2004, 2007 Free Software Foundation, Inc.
@


1.53
log
@
	* gdbarch.sh (sofun_address_maybe_missing): New gdbarch variable.
	* gdbarch.c, gdbarch.h: Regenerate.
	* dbxread.c (find_stab_function_addr): Define unconditionally.
	(read_dbx_symtab): Use gdbarch_sofun_address_maybe_missing
	instead of SOFUN_ADDRESS_MAYBE_MISSING.
	(end_psymtab): Likewise.
	(process_one_symbol): Likewise.
	* mdebugread.c (parse_partial_symbols): Likewise.

	* symtab.h (struct minimal_symbol): Always define "filename" member.
	* elfread.c (elf_symtab_read): Use msym->filename unconditionally.
	* minsyms.c (lookup_minimal_symbol): Likewise.
	* symmisc.c (dump_msymbols): Likewise.

	* config/i386/i386sol2.mt (DEPRECATED_TM_FILE): Remove.
	* config/i386/linux.mt (DEPRECATED_TM_FILE): Remove.
	* config/i386/tm-i386sol2.h: Remove file.
	* config/i386/tm-linux.h: Remove file.
	* i386-linux-tdep.c (i386_linux_init_abi): Add call to
	set_gdbarch_sofun_address_maybe_missing.
	* i386-sol2-tdep.c (i386_sol2_init_abi): Likewise.

	* config/powerpc/linux.mt (DEPRECATED_TM_FILE): Remove.
	* config/powerpc/nbsd.mt (DEPRECATED_TM_FILE): Remove.
	* config/powerpc/obsd.mt (DEPRECATED_TM_FILE): Remove.
	* config/powerpc/ppc-eabi.mt (DEPRECATED_TM_FILE): Remove.
	* config/powerpc/ppc-sim.mt (DEPRECATED_TM_FILE): Remove.
	* config/powerpc/tm-ppc-eabi.h: Remove file.
	* rs6000-tdep.c (rs6000_gdbarch_init): Add call to
	set_gdbarch_sofun_address_maybe_missing.

	* config/sparc/sol2-64.mt (DEPRECATED_TM_FILE): Remove.
	* config/sparc/sol2.mt (DEPRECATED_TM_FILE): Remove.
	* config/sparc/tm-sol2.h: Remove file.
	* sparc64-sol2-tdep.c (sparc64_sol2_init_abi): Add call to
	set_gdbarch_sofun_address_maybe_missing.
	* sparc-sol2-tdep.c (sparc32_sol2_init_abi): Likewise.

doc/ChangeLog:

	* gdbarch.texi (Target Conditionals): Remove documentation of
	SOFUN_ADDRESS_MAYBE_MISSING, replaced by ...
	(Compiler Characteristics): ... documentation of
	set_gdbarch_sofun_address_maybe_missing.
@
text
@d179 2
a180 1
      if (objf == NULL || objf == objfile)
d278 2
a279 1
      if (objf == NULL || objf == objfile)
d335 2
a336 1
      if (objf == NULL || objf == objfile)
@


1.52
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@a167 1
#ifdef SOFUN_ADDRESS_MAYBE_MISSING
a173 1
#endif
a209 1
#ifdef SOFUN_ADDRESS_MAYBE_MISSING
a212 8
#else
                        /* We have neither the ability nor the need to
                           deal with the SFILE parameter.  If we find
                           more than one symbol, just return the latest
                           one (the user can't expect useful behavior in
                           that case).  */
                        found_file_symbol = msymbol;
#endif
@


1.51
log
@	* minsyms.c (lookup_minimal_symbol_by_pc_section): Search fewer
	objfiles.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d19 1
a19 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.50
log
@	* gdbarch.sh (skip_trampoline_code): Add FRAME argument.
	* gdbarch.c, gdbarch.h: Regenerate.
	* arch-utils.c (generic_skip_trampoline_code): Add FRAME argument.
	* arch-utils.h (generic_skip_trampoline_code): Likewise.
	* infrun.c (handle_inferior_event): Pass current frame to
	gdbarch_skip_trampoline_code and skip_language_trampoline.

	* language.c (unk_lang_trampoline): Add FRAME argument.
	(skip_language_trampoline): Add FRAME argument.  Pass it to
	skip_trampoline callback.
	* language.h: Add forward declaration of struct frame_info.
	(struct language_defn): Add FRAME argument to skip_trampoline.
	(skip_language_trampoline): Add FRAME argument.
	* cp-abi.c (cplus_skip_trampoline): Add FRAME argument.  Pass it
	to skip_trampoline callback.
	* cp-abi.h: Add forward declaration of struct frame_info.
	(cplus_skip_trampoline): Add FRAME argument.
	(struct cp_abi_ops): Add FRAME argument to skip_trampoline callback.
	* gnu-v3-abi.c (gnuv3_skip_trampoline): Add FRAME argument.  Pass it
	to gdbarch_skip_trampoline_code.
	* objc-lang.c (objc_skip_trampoline): Add FRAME argument.  Pass it
	to gdbarch_skip_trampoline_code.

	* minsyms.c (find_solib_trampoline_target): Add FRAME argument.
	* symtab.h (find_solib_trampoline_target): Likewise.
	* obsd-tdep.c (obsd_skip_solib_resolver): Pass current frame to
	find_solib_trampoline_target.

	* arm-tdep.c (arm_skip_stub): Add FRAME argument.  Read registers
	from FRAME instead of calling read_register.

	* hppa-hpux-tdep.c (hppa_hpux_skip_trampoline_code): Add FRAME
	argument.  Read registers from FRAME instead of using read_register.
	* hppa-tdep.c (hppa_skip_trampoline_code): Likewise.
	* hppa-tdep.h (hppa_skip_trampoline_code): Add FRAME argument.

	* i386-cygwin-tdep.c (i386_cygwin_skip_trampoline_code): Add FRAME
	argument.

	* m32c-tdep.c (m32c_skip_trampoline_code): Add FRAME argument.

	* mips-tdep.c (mips_skip_trampoline_code): Add FRAME argument.  Read
	registers from FRAME instead of using read_signed_register.

	* ppc-linux-tdep.c (ppc_linux_skip_trampoline_code): Add FRAME
	argument.
	(ppc64_standard_linkage_target): Likewise.  Read registers from FRAME
	instead of using read_register.
	(ppc64_skip_trampoline_code): Add FRAME argument.  Pass it to
	ppc64_standard_linkage_target.
	* rs6000-tdep.c (rs6000_skip_trampoline_code): Add FRAME argument.
	Pass it to find_solib_trampoline_target.  Read registers from FRAME
	instead of using read_register.

	* xstormy16-tdep.c (xstormy16_skip_trampoline_code): Add FRAME
	argument.
@
text
@d390 14
a403 14
  /* NOTE: cagney/2004-01-27: Removed code (added 2003-07-19) that was
     trying to force the PC into a valid section as returned by
     find_pc_section.  It broke IRIX 6.5 mdebug which relies on this
     code returning an absolute symbol - the problem was that
     find_pc_section wasn't returning an absolute section and hence
     the code below would skip over absolute symbols.  Since the
     original problem was with finding a frame's function, and that
     uses [indirectly] lookup_minimal_symbol_by_pc, the original
     problem has been fixed by having that function use
     find_pc_section.  */

  for (objfile = object_files;
       objfile != NULL;
       objfile = objfile->next)
@


1.49
log
@2007-01-09  Jan Kratochvil  <jan.kratochvil@@redhat.com>

	* minsyms.c (lookup_minimal_symbol_by_pc_section): Handle
	nested symbols.

	* gdb.arch/i386-size-overlap.c, gdb.arch/i386-size-overlap.exp: New.
@
text
@d1050 1
a1050 1
find_solib_trampoline_target (CORE_ADDR pc)
@


1.48
log
@Copyright updates for 2007.
@
text
@d513 16
@


1.47
log
@gdb/
	* Makefile.in (symtab.o): Update.
	* symtab.h (matching_bfd_section): New prototype.
	* symtab.c (matching_bfd_section): New.
	(find_pc_sect_psymbol, find_pc_sect_symtab): Use it.
	* minsyms.c (lookup_minimal_symbol_by_pc_section): Likewise.
	* printcmd.c (sym_info): Ignore separate debug objfiles.
gdb/testsuite/
	* gdb.base/sepdebug.exp: Remove debug format test.
	* lib/gdb.exp (gdb_gnu_strip_debug): Perform debug format test.
	Handle no-symtab.
	* gdb.base/sepsymtab.c, gdb.base/sepsymtab.exp: New.
@
text
@d3 1
a3 2
   2002, 2003, 2004
   Free Software Foundation, Inc.
@


1.46
log
@	* blockframe.c (find_pc_partial_function): Use the minimal symbol
	size to control the cache entry, if available.
	* minsyms.c (lookup_minimal_symbol_by_pc_section): Handle minimal
	symbols with zero and non-zero sizes differently.

	* gdb.arch/i386-size.c, gdb.arch/i386-size.exp: New files.
@
text
@a362 1

d493 2
a494 1
		      && SYMBOL_BFD_SECTION (&msymbol[hi]) != section)
@


1.45
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d415 2
d466 81
a550 24
	      /* Skip any absolute symbols.  This is apparently what adb
	         and dbx do, and is needed for the CM-5.  There are two
	         known possible problems: (1) on ELF, apparently end, edata,
	         etc. are absolute.  Not sure ignoring them here is a big
	         deal, but if we want to use them, the fix would go in
	         elfread.c.  (2) I think shared library entry points on the
	         NeXT are absolute.  If we want special handling for this
	         it probably should be triggered by a special
	         mst_abs_or_lib or some such.  */
	      while (hi >= 0
		     && msymbol[hi].type == mst_abs)
		--hi;

	      /* If "section" specified, skip any symbol from wrong section */
	      /* This is the new code that distinguishes it from the old function */
	      if (section)
		while (hi >= 0
		       /* Some types of debug info, such as COFF,
			  don't fill the bfd_section member, so don't
			  throw away symbols on those platforms.  */
		       && SYMBOL_BFD_SECTION (&msymbol[hi]) != NULL
		       && SYMBOL_BFD_SECTION (&msymbol[hi]) != section)
		  --hi;

@


1.45.14.1
log
@Changes from nickrob-async-20060828-mergepoint.
@
text
@a414 2
	  int best_zero_sized = -1;

a463 81
	      /* Skip various undesirable symbols.  */
	      while (hi >= 0)
		{
		  /* Skip any absolute symbols.  This is apparently
		     what adb and dbx do, and is needed for the CM-5.
		     There are two known possible problems: (1) on
		     ELF, apparently end, edata, etc. are absolute.
		     Not sure ignoring them here is a big deal, but if
		     we want to use them, the fix would go in
		     elfread.c.  (2) I think shared library entry
		     points on the NeXT are absolute.  If we want
		     special handling for this it probably should be
		     triggered by a special mst_abs_or_lib or some
		     such.  */

		  if (msymbol[hi].type == mst_abs)
		    {
		      hi--;
		      continue;
		    }

		  /* If SECTION was specified, skip any symbol from
		     wrong section.  */
		  if (section
		      /* Some types of debug info, such as COFF,
			 don't fill the bfd_section member, so don't
			 throw away symbols on those platforms.  */
		      && SYMBOL_BFD_SECTION (&msymbol[hi]) != NULL
		      && SYMBOL_BFD_SECTION (&msymbol[hi]) != section)
		    {
		      hi--;
		      continue;
		    }

		  /* If the minimal symbol has a zero size, save it
		     but keep scanning backwards looking for one with
		     a non-zero size.  A zero size may mean that the
		     symbol isn't an object or function (e.g. a
		     label), or it may just mean that the size was not
		     specified.  */
		  if (MSYMBOL_SIZE (&msymbol[hi]) == 0
		      && best_zero_sized == -1)
		    {
		      best_zero_sized = hi;
		      hi--;
		      continue;
		    }

		  /* Otherwise, this symbol must be as good as we're going
		     to get.  */
		  break;
		}

	      /* If HI has a zero size, and best_zero_sized is set,
		 then we had two or more zero-sized symbols; prefer
		 the first one we found (which may have a higher
		 address).  Also, if we ran off the end, be sure
		 to back up.  */
	      if (best_zero_sized != -1
		  && (hi < 0 || MSYMBOL_SIZE (&msymbol[hi]) == 0))
		hi = best_zero_sized;

	      /* If the minimal symbol has a non-zero size, and this
		 PC appears to be outside the symbol's contents, then
		 refuse to use this symbol.  If we found a zero-sized
		 symbol with an address greater than this symbol's,
		 use that instead.  We assume that if symbols have
		 specified sizes, they do not overlap.  */

	      if (hi >= 0
		  && MSYMBOL_SIZE (&msymbol[hi]) != 0
		  && pc >= (SYMBOL_VALUE_ADDRESS (&msymbol[hi])
			    + MSYMBOL_SIZE (&msymbol[hi])))
		{
		  if (best_zero_sized != -1)
		    hi = best_zero_sized;
		  else
		    /* Go on to the next object file.  */
		    continue;
		}

d468 24
@


1.44
log
@* minsyms.c (lookup_minimal_symbol): Doc fix.
@
text
@d2 1
a2 1
   Copyright 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
d21 2
a22 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.43
log
@* symtab.h (SYMBOL_SEARCH_NAME): New definition.
(SYMBOL_MATCHES_SEARCH_NAME): New definition.
(symbol_search_name): Declare.

* dictionary.c (iter_name_first_hashed): Match on SYMBOL_SEARCH_NAME.
(iter_name_next_hashed): Ditto.
(iter_name_next_linear): Ditto.
(insert_symbol_hashed): Hash on SYMBOL_SEARCH_NAME.

* symtab.c (lookup_partial_symbol): Assume symbols ordered by
search name, using SYMBOL_SEARCH_NAME and SYMBOL_MATCHES_SEARCH_NAME.
(symbol_search_name): New function.

* symfile.c (compare_psymbols): Order by SYMBOL_SEARCH_NAME.

* minsyms.c (build_minimal_symbol_hash_tables): Change
test for adding to demangled hash table to check for difference
between SYMBOL_SEARCH_NAME and SYMBOL_LINKAGE_NAME.
@
text
@d148 9
a156 1
   names (the dynamic linker deals with the duplication).  */
@


1.42
log
@	* minsyms.c (install_minimal_symbols): Move dropping leading
	char from linkage name from here...
	(prim_record_minimal_symbol_and_info): ...to here.  Simplify
	test for "__gnu_compiled*" symbols.
@
text
@d794 1
a794 1
      if (SYMBOL_DEMANGLED_NAME (msym) != NULL)
@


1.41
log
@2004-02-09  Andrew Cagney  <cagney@@redhat.com>

	* blockframe.c (find_pc_partial_function): If find_pc_overlay
	fails, try find_pc_section.  Fix PR c++/1267.
	* minsyms.c (lookup_minimal_symbol_by_pc): Use find_pc_section
	instead of find_pc_mapped_section.
	(lookup_minimal_symbol_by_pc_section): If the SECTION is NULL, do
	not default to the section containing PC.  Fix PR symtab/1519.
@
text
@d583 17
a599 20
  if (ms_type == mst_file_text)
    {
      /* Don't put gcc_compiled, __gnu_compiled_cplus, and friends into
         the minimal symbols, because if there is also another symbol
         at the same address (e.g. the first function of the file),
         lookup_minimal_symbol_by_pc would have no way of getting the
         right one.  */
      if (name[0] == 'g'
	  && (strcmp (name, GCC_COMPILED_FLAG_SYMBOL) == 0
	      || strcmp (name, GCC2_COMPILED_FLAG_SYMBOL) == 0))
	return (NULL);

      {
	const char *tempstring = name;
	if (tempstring[0] == get_symbol_leading_char (objfile->obfd))
	  ++tempstring;
	if (strncmp (tempstring, "__gnu_compiled", 14) == 0)
	  return (NULL);
      }
    }
a830 1
  char leading_char;
a857 1
      leading_char = get_symbol_leading_char (objfile->obfd);
d862 1
a862 7
	    {
	      msymbols[mcount] = bunch->contents[bindex];
	      if (SYMBOL_LINKAGE_NAME (&msymbols[mcount])[0] == leading_char)
		{
		  SYMBOL_LINKAGE_NAME (&msymbols[mcount])++;
		}
	    }
@


1.41.4.1
log
@Merge GDB mainline of 20040402 to intercu branch.
@
text
@d583 20
a602 17
  /* Don't put gcc_compiled, __gnu_compiled_cplus, and friends into
     the minimal symbols, because if there is also another symbol
     at the same address (e.g. the first function of the file),
     lookup_minimal_symbol_by_pc would have no way of getting the
     right one.  */
  if (ms_type == mst_file_text && name[0] == 'g'
      && (strcmp (name, GCC_COMPILED_FLAG_SYMBOL) == 0
	  || strcmp (name, GCC2_COMPILED_FLAG_SYMBOL) == 0))
    return (NULL);

  /* It's safe to strip the leading char here once, since the name
     is also stored stripped in the minimal symbol table. */
  if (name[0] == get_symbol_leading_char (objfile->obfd))
    ++name;

  if (ms_type == mst_file_text && strncmp (name, "__gnu_compiled", 14) == 0)
    return (NULL);
d834 1
d862 1
d867 7
a873 1
	    msymbols[mcount] = bunch->contents[bindex];
@


1.41.4.2
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d794 1
a794 1
      if (SYMBOL_SEARCH_NAME (msym) != SYMBOL_LINKAGE_NAME (msym))
@


1.41.4.3
log
@Merge from mainline.
@
text
@d148 1
a148 9
   names (the dynamic linker deals with the duplication).

   It's also possible to have minimal symbols with different mangled
   names, but identical demangled names.  For example, the GNU C++ v3
   ABI requires the generation of two (or perhaps three) copies of
   constructor functions --- "in-charge", "not-in-charge", and
   "allocate" copies; destructors may be duplicated as well.
   Obviously, there must be distinct mangled names for each of these,
   but the demangled names are all the same: S::S or S::~S.  */
@


1.40
log
@2004-02-07  Elena Zannoni  <ezannoni@@redhat.com>

	* buildsym.c (free_pending_blocks, finish_block)
	(record_pending_block, make_blockvector, end_symtab): Replace
	symbol_obstack with objfile_obstack.
	* coffread.c (process_coff_symbol, coff_read_struct_type)
	(coff_read_enum_type): Ditto.
	* cp-namespace.c (initialize_namespace_symtab)
	(check_one_possible_namespace_symbol): Ditto.
	* dwarf2read.c (new_symbol, dwarf2_const_value, macro_start_file)
	(dwarf2_symbol_mark_computed): Ditto.
	* dwarfread.c (enum_type, new_symbol, synthesize_typedef): Ditto.
	* elfread.c (elf_symtab_read): Ditto.
	* hpread.c (hpread_symfile_init, hpread_symfile_init)
	(hpread_read_enum_type, hpread_read_function_type)
	(hpread_read_doc_function_type, hpread_process_one_debug_symbol):
	Ditto.
	* jv-lang.c (get_java_class_symtab, add_class_symbol)
	(java_link_class_type): Ditto.
	* mdebugread.c (parse_symbol, psymtab_to_symtab_1, new_symtab)
	(new_symbol): Ditto.
	* minsyms.c (install_minimal_symbols): Ditto.
	* objfiles.c (allocate_objfile): Remove init of symbol_obstack.
	(terminate_minimal_symbol_table): Replace symbol_obstack with
	objfile_obstack.
	(free_objfile): Remove freeing of symbol_obstack.
	* objfiles.h: Remove symbol_obstack field.
	* pa64solib.c (add_to_solist): Replace symbol_obstack with
	objfile_obstack.
	* solib-sunos.c (allocate_rt_common_objfile): Remove init of
	symbol_obstack.
	(solib_add_common_symbols): Replace symbol_obstack with
	objfile_obstack.
	* somsolib.c (som_solib_add): Ditto.
	* stabsread.c (patch_block_stabs, define_symbol, read_enum_type)
	(common_block_start, common_block_end): Ditto.
	* symfile.c (reread_symbols): Remove freeing and init of
	symbol_obstack.
	(allocate_symtab): Rename symbol_obstack to objfile_obstack.
	* symfile.h: Update comment.
	* symmisc.c (print_objfile_statistics): Remove symbol_obstack
	stats printing.
	* symtab.c (symbol_set_names): Replace symbol_obstack with
	objfile_obstack.
	* symtab.h (struct general_symbol_info, struct minimal_symbol):
	Update comments.
	* xcoffread.c (read_xcoff_symtab, SYMBOL_DUP, SYMNAME_ALLOC)
	(init_stringtab, xcoff_initial_scan): Replace symbol_obstack with
	objfile_obstack.
@
text
@d358 1
a358 1
   than or equal to PC, and matches SECTION (if non-null).  Returns a
d377 3
a379 3
  /* pc has to be in a known section. This ensures that anything beyond
     the end of the last segment doesn't appear to be part of the last
     function in the last segment.  */
d384 10
a393 7
  /* If no section was specified, then just make sure that the PC is in
     the same section as the minimal symbol we find.  */
  if (section == NULL)
    section = pc_section->the_bfd_section;

  /* FIXME drow/2003-07-19: Should we also check that PC is in SECTION
     if we were passed a non-NULL SECTION argument?  */
d503 7
a509 1
  return lookup_minimal_symbol_by_pc_section (pc, find_pc_mapped_section (pc));
@


1.39
log
@2003-11-07  Michael Chastain  <mec@@shout.net>

	* symtab.h (struct minimal_symbol): Add size.
	* dbxread.c: Use it.
	* elfread.c: (record_minimal_symbol_and_info): Do not use info.
	Rename to record_minimal_symbol.
	(elf_symtab_read): Set MSYMBOL_SIZE explicitly.
	* minsyms.c (prim_record_minimal_symbol_and_info): Initialize MSYMBOL_SIZE.
	(install_minimal_symbols): Ditto.
	* objfiles.c (terminate_minimal_symbol_table): Ditto.
	* arm-tdep.c: Delete unused MSYMBOL_SIZE.
	* m68hc11-tdep.c: Ditto.
	* mips-tdep.c: Ditto.
	* sh64-tdep.c: Ditto.
@
text
@d3 1
a3 1
   2002, 2003
d717 1
a717 1
   on the symbol_obstack, and will get automatically freed when the symbol
d835 1
a835 1
      obstack_blank (&objfile->symbol_obstack,
d838 1
a838 1
	obstack_base (&objfile->symbol_obstack);
d878 1
a878 1
      obstack_blank (&objfile->symbol_obstack,
d881 1
a881 1
	obstack_finish (&objfile->symbol_obstack);
d899 1
a899 1
         The strings themselves are also located in the symbol_obstack
@


1.38
log
@2003-11-07  Andrew Cagney  <cagney@@redhat.com>

	* top.c (print_gdb_version): Replace STREQ with strcmp.
	* valops.c (value_struct_elt_for_reference): Ditto.
	(value_struct_elt_for_reference): Ditto.
	* symtab.c (gdb_mangle_name): Ditto.
	(find_line_symtab): Ditto.
	* symmisc.c (maintenance_print_symbols): Ditto.
	* symfile.c (symbol_file_command): Ditto.
	* stabsread.c (define_symbol, read_type): Ditto.
	(cleanup_undefined_types, scan_file_globals): Ditto.
	* solib.c (solib_map_sections): Ditto.
	* solib-svr4.c (bfd_lookup_symbol): Ditto.
	* rs6000-tdep.c (skip_prologue): Ditto.
	* p-valprint.c (pascal_value_print): Ditto.
	(pascal_object_is_vtbl_ptr_type): Ditto.
	* objfiles.c (in_plt_section): Ditto.
	* minsyms.c (lookup_minimal_symbol): Ditto.
	(compact_minimal_symbols): Ditto.
	(find_solib_trampoline_target): Ditto.
	* mdebugread.c (parse_type): Ditto.
	* language.c (set_language_command): Ditto.
	(set_type_command, set_range_command): Ditto.
	* f-lang.c (add_common_block): Ditto.
	(add_common_block): Ditto.
	(find_first_common_named): Ditto.
	(patch_all_commons_by_name): Ditto.
	* elfread.c (elf_locate_sections): Ditto.
	(elf_locate_sections): Ditto.
	(elfstab_offset_sections): Ditto.
	* dwarf2read.c (dwarf2_locate_sections): Ditto.
	* dbxread.c (add_old_header_file): Ditto.
	(find_corresponding_bincl_psymtab): Ditto.
	(read_dbx_symtab, process_one_symbol): Ditto.
	* coffread.c (patch_opaque_types): Ditto.
	* cli/cli-decode.c (delete_cmd): Ditto.
	* cli/cli-cmds.c (pwd_command, list_command): Ditto.
	* c-typeprint.c (c_type_print_base): Ditto.
	* breakpoint.c (bpstat_stop_status): Ditto.
	(clear_command, breakpoint_re_set_one): Ditto.
@
text
@d614 1
d894 1
@


1.37
log
@2003-11-06  Andrew Cagney  <cagney@@redhat.com>

	* valops.c (destructor_name_p): Replace STREQN with strncmp.
	* top.c (command_line_input): Ditto.
	* objc-exp.y (yylex): Ditto.
	* minsyms.c (prim_record_minimal_symbol_and_info): Ditto.
	* jv-exp.y (yylex): Ditto.
	* f-exp.y (yylex): Ditto.
	* event-top.c (command_line_handler): Ditto.
	* environ.c (get_in_environ): Ditto.
	(set_in_environ): Ditto.
	* dwarfread.c (handle_producer): Ditto.
	* dbxread.c (process_one_symbol): Ditto.
	* c-typeprint.c (c_type_print_base): Ditto.
	* c-exp.y (yylex): Ditto.

2003-11-06  Andrew Cagney  <cagney@@redhat.com>

	* mi-cmd-var.c (mi_cmd_var_set_format): Replace STREQN with
	strncmp.
@
text
@d208 2
a209 1
                        if (sfile == NULL || STREQ (msymbol->filename, sfile))
d741 4
a744 4
	  if (SYMBOL_VALUE_ADDRESS (copyfrom) ==
	      SYMBOL_VALUE_ADDRESS ((copyfrom + 1)) &&
	      (STREQ (SYMBOL_LINKAGE_NAME (copyfrom),
		      SYMBOL_LINKAGE_NAME ((copyfrom + 1)))))
d979 2
a980 2
	    && STREQ (SYMBOL_LINKAGE_NAME (msymbol),
		      SYMBOL_LINKAGE_NAME (tsymbol)))
@


1.36
log
@2003-10-21  Elena Zannoni  <ezannoni@@redhat.com>

	* minsyms.c (lookup_minimal_symbol_text): Remove unused parameter.
	Remove SOFUN_ADDRESS_MAYBE_MISSING ifdeffed code.
	* symtab.h (lookup_minimal_symbol_text): Update.
 	* breakpoint.c (create_overlay_event_breakpoint,
 	create_longjmp_breakpoint): Update callers.
	* ppc-linux-tdep.c (ppc_linux_skip_trampoline_code): Update caller.
	* symtab.c (find_pc_sect_line): Ditto.
@
text
@d589 1
a589 1
	if (STREQN (tempstring, "__gnu_compiled", 14))
@


1.35
log
@2003-10-16  Elena Zannoni  <ezannoni@@redhat.com>

	* minsyms.c (lookup_minimal_symbol_solib_trampoline): Remove
	second parameter, which is always null. Remove
	SOFUN_ADDRESS_MAYBE_MISSING ifdeffed code.
	* symtab.h (lookup_minimal_symbol_solib_trampoline): Update
	accordingly.
	* somsolib.c (som_solib_create_inferior_hook,
	som_solib_desire_dynamic_linker_symbols): Update callers.
	* hppa-tdep.c (hppa_fix_call_dummy): Ditto.
@
text
@d263 2
a264 4
   is non-NULL, limit the search to that objfile.  If SFILE is non-NULL,
   the only file-scope symbols considered will be from that source file
   (global symbols are still preferred).  Returns a pointer to the minimal
   symbol that matches, or NULL if no match is found.
d269 1
a269 2
lookup_minimal_symbol_text (const char *name, const char *sfile,
			    struct objfile *objf)
a277 9
#ifdef SOFUN_ADDRESS_MAYBE_MISSING
  if (sfile != NULL)
    {
      char *p = strrchr (sfile, '/');
      if (p != NULL)
	sfile = p + 1;
    }
#endif

a294 9
#ifdef SOFUN_ADDRESS_MAYBE_MISSING
		      if (sfile == NULL || STREQ (msymbol->filename, sfile))
			found_file_symbol = msymbol;
#else
		      /* We have neither the ability nor the need to
		         deal with the SFILE parameter.  If we find
		         more than one symbol, just return the latest
		         one (the user can't expect useful behavior in
		         that case).  */
a295 1
#endif
d317 4
a320 5
   first minimal symbol that matches NAME and is a solib trampoline.  If OBJF
   is non-NULL, limit the search to that objfile.  If SFILE is non-NULL,
   the only file-scope symbols considered will be from that source file
   (global symbols are still preferred).  Returns a pointer to the minimal
   symbol that matches, or NULL if no match is found.
@


1.34
log
@2003-09-16  Andrew Cagney  <cagney@@redhat.com>

	* buildsym.c: Remove more occurances of "register".
	* coffread.c, dbxread.c, dcache.c, dwarf2read.c: Ditto.
	* environ.c, eval.c, f-valprint.c, findvar.c: Ditto.
	* gdbtypes.c, gnu-v2-abi.c, h8300-tdep.c, hppa-tdep.c: Ditto.
	* infcmd.c, mdebugread.c, minsyms.c, mips-tdep.c: Ditto.
	* printcmd.c, remote-vx.c, sh-stub.c, sh-tdep.c: Ditto.
	* sh64-tdep.c, source.c, stabsread.c, stack.c: Ditto.
	* standalone.c, symfile.c, symmisc.c, symtab.c: Ditto.
	* utils.c, valops.c, values.c, xcoffread.c: Ditto.
@
text
@a348 1
					const char *sfile,
a355 9

#ifdef SOFUN_ADDRESS_MAYBE_MISSING
  if (sfile != NULL)
    {
      char *p = strrchr (sfile, '/');
      if (p != NULL)
	sfile = p + 1;
    }
#endif
@


1.33
log
@2003-09-14  Andrew Cagney  <cagney@@redhat.com>

	* alpha-nat.c: Remove some occurances of "register".
	* alpha-tdep.c, arm-tdep.c, blockframe.c, breakpoint.c: Ditto.
	* buildsym.c, c-typeprint.c, c-valprint.c, coffread.c: Ditto.
	* corefile.c, cp-support.c, cp-valprint.c, cris-tdep.c: Ditto.
	* dbxread.c, dcache.c, dwarf2read.c, elfread.c: Ditto.
	* environ.c, eval.c, event-top.c, f-typeprint.c: Ditto.
	* f-valprint.c, findvar.c, frame.c, gdbtypes.c: Ditto.
	* h8300-tdep.c, hppa-tdep.c, hppab-nat.c, hppah-nat.c: Ditto.
	* hppam3-nat.c, hpread.c, ia64-aix-nat.c, ia64-linux-nat.c: Ditto.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Ditto.
	* infttrace.c, irix5-nat.c, jv-typeprint.c: Ditto.
	* jv-valprint.c, m68k-tdep.c, m68klinux-nat.c, main.c: Ditto.
	* mdebugread.c, minsyms.c, mips-linux-tdep.c: Ditto.
	* mips-nat.c, mips-tdep.c, mipsread.c, mipsv4-nat.c: Ditto.
	* ns32k-tdep.c, objfiles.c, p-typeprint.c: Ditto.
	* p-valprint.c, ppc-linux-nat.c, printcmd.c: Ditto.
	* remote-mips.c, remote-vx.c, rs6000-nat.c: Ditto.
	* rs6000-tdep.c, scm-exp.c, sh-tdep.c, sh64-tdep.c: Ditto.
	* solib.c, somread.c, source.c, sparc-tdep.c: Ditto.
	* stabsread.c, stack.c, standalone.c, symfile.c: Ditto.
	* symmisc.c, symtab.c, top.c, tracepoint.c: Ditto.
	* typeprint.c, utils.c, valarith.c, valops.c: Ditto.
	* values.c, vax-tdep.c, xcoffread.c: Ditto.
@
text
@d151 1
a151 1
lookup_minimal_symbol (register const char *name, const char *sfile,
d271 1
a271 1
lookup_minimal_symbol_text (register const char *name, const char *sfile,
d348 3
a350 2
lookup_minimal_symbol_solib_trampoline (register const char *name,
					const char *sfile, struct objfile *objf)
@


1.32
log
@	PR c++/1267
	* minsyms.c (lookup_minimal_symbol_by_pc_section): If SECTION is
	NULL, default to the section containing PC.
@
text
@d602 2
a603 2
  register struct msym_bunch *new;
  register struct minimal_symbol *msymbol;
d664 2
a665 2
  register const struct minimal_symbol *fn1;
  register const struct minimal_symbol *fn2;
d706 1
a706 1
  register struct msym_bunch *next;
d850 4
a853 4
  register int bindex;
  register int mcount;
  register struct msym_bunch *bunch;
  register struct minimal_symbol *msymbols;
d855 1
a855 1
  register char leading_char;
@


1.31
log
@2003-05-15  Andrew Cagney  <cagney@@redhat.com>

	* symtab.h (DEPRECATED_SYMBOL_MATCHES_NAME): Delete macro.
	* minsyms.c (lookup_minimal_symbol): Inline
	DEPRECATED_SYMBOL_MATCHES_NAME.  Replace STREQ with strcmp.
@
text
@d406 1
d411 2
a412 1
  if (find_pc_section (pc) == NULL)
d414 8
@


1.31.10.1
log
@	PR c++/1267
	* minsyms.c (lookup_minimal_symbol_by_pc_section): If SECTION is
	NULL, default to the section containing PC.
@
text
@a405 1
  struct obj_section *pc_section;
d410 1
a410 2
  pc_section = find_pc_section (pc);
  if (pc_section == NULL)
a411 8

  /* If no section was specified, then just make sure that the PC is in
     the same section as the minimal symbol we find.  */
  if (section == NULL)
    section = pc_section->the_bfd_section;

  /* FIXME drow/2003-07-19: Should we also check that PC is in SECTION
     if we were passed a non-NULL SECTION argument?  */
@


1.30
log
@	* minsyms.c (install_minimal_symbols): Only switch to gnu-v3 mode
	if the linkage name demangled successfully.
@
text
@d192 9
a200 1
                if (DEPRECATED_SYMBOL_MATCHES_NAME (msymbol, name))
@


1.30.2.1
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d192 1
a192 9
		  /* FIXME: carlton/2003-02-27: This is an unholy
		     mixture of linkage names and natural names.  If
		     you want to test the linkage names with strcmp,
		     do that.  If you want to test the natural names
		     with strcmp_iw, use SYMBOL_MATCHES_NATURAL_NAME.  */
		  if (strcmp (DEPRECATED_SYMBOL_NAME (msymbol), (name)) == 0
		      || (SYMBOL_DEMANGLED_NAME (msymbol) != NULL
			  && strcmp_iw (SYMBOL_DEMANGLED_NAME (msymbol),
					(name)) == 0))
@


1.29
log
@2003-03-10  David Carlton  <carlton@@math.stanford.edu>

	* minsyms.c (add_minsym_to_hash_table): Replace
	DEPRECATED_SYMBOL_NAME by SYMBOL_LINKAGE_NAME.
	(compare_minimal_symbols, compact_minimal_symbols)
	(install_minimal_symbols, find_solib_trampoline_target): Ditto.
	(lookup_minimal_symbol_text): Use strcmp on linkage names instead
	of DEPRECATED_SYMBOL_MATCHES_NAME.
	(lookup_minimal_symbol_solib_trampoline): Ditto.
@
text
@d923 5
d929 2
a930 1
	    if (name[0] == '_' && name[1] == 'Z')
@


1.28
log
@	* cp-abi.c: Include "command.h", "gdbcmd.h", and "ui-out.h".
	(auto_cp_abi): New variable.
	(current_cp_abi, num_cp_abis): Make static.
	(CP_ABI_MAX): Define.
	(cp_abis): Turn into an array.
	(value_virtual_fn_field): Fix formatting.
	(switch_to_cp_abi, register_cp_abi): Update.  register_cp_abi now
	takes a pointer.
	(set_cp_abi_as_auto_default, set_cp_abi_cmd, show_cp_abi_cmd)
	(list_cp_abis, _initialize_cp_abi): New functions.
	* cp-abi.h: Add prototype for set_cp_abi_as_auto_default.  Remove
	declarations for cp_abis, num_cp_abis, current_cp_abi, and
	switch_to_cp_abi.  Update prototype for register_cp_abi.
	* Makefile.in (cp-abi.o): Update dependencies.
	* minsyms.c (install_minimal_symbols): Call set_cp_abi_as_auto_default
	instead of switch_to_cp_abi.
	* gnu-v2-abi.c (_initialize_gnu_v2_abi): Likewise.  Update call to
	register_cp_abi.
	* gnu-v3-abi.c (_initialize_gnu_v3_abi): Update call to
	register_cp_abi.
	* hpacc-abi.c (_initialize_hpacc_abi): Likewise.
@
text
@d116 2
a117 1
      unsigned int hash = msymbol_hash (DEPRECATED_SYMBOL_NAME (sym)) % MINIMAL_SYMBOL_HASH_SIZE;
d292 1
a292 1
	      if (DEPRECATED_SYMBOL_MATCHES_NAME (msymbol, name) &&
d368 1
a368 1
	      if (DEPRECATED_SYMBOL_MATCHES_NAME (msymbol, name) &&
d663 2
a664 2
      char *name1 = DEPRECATED_SYMBOL_NAME (fn1);
      char *name2 = DEPRECATED_SYMBOL_NAME (fn2);
d756 2
a757 1
	      (STREQ (DEPRECATED_SYMBOL_NAME (copyfrom), DEPRECATED_SYMBOL_NAME ((copyfrom + 1)))))
d872 1
a872 1
	      if (DEPRECATED_SYMBOL_NAME (&msymbols[mcount])[0] == leading_char)
d874 1
a874 1
		  DEPRECATED_SYMBOL_NAME (&msymbols[mcount])++;
d903 1
a903 1
      DEPRECATED_SYMBOL_NAME (&msymbols[mcount]) = NULL;
d923 1
a923 1
	    const char *name = DEPRECATED_SYMBOL_NAME (&objfile->msymbols[i]);
d986 2
a987 1
	    && STREQ (DEPRECATED_SYMBOL_NAME (msymbol), DEPRECATED_SYMBOL_NAME (tsymbol)))
@


1.28.2.1
log
@2003-03-16  Mark Kettenis  <kettenis@@gnu.org>

	Merge with mainline.  Tag is kettenis-i386newframe-20030316-mergepoint.
@
text
@d116 1
a116 2
      unsigned int hash
	= msymbol_hash (SYMBOL_LINKAGE_NAME (sym)) % MINIMAL_SYMBOL_HASH_SIZE;
d291 1
a291 1
	      if (strcmp (SYMBOL_LINKAGE_NAME (msymbol), name) == 0 &&
d367 1
a367 1
	      if (strcmp (SYMBOL_LINKAGE_NAME (msymbol), name) == 0 &&
d662 2
a663 2
      char *name1 = SYMBOL_LINKAGE_NAME (fn1);
      char *name2 = SYMBOL_LINKAGE_NAME (fn2);
d755 1
a755 2
	      (STREQ (SYMBOL_LINKAGE_NAME (copyfrom),
		      SYMBOL_LINKAGE_NAME ((copyfrom + 1)))))
d870 1
a870 1
	      if (SYMBOL_LINKAGE_NAME (&msymbols[mcount])[0] == leading_char)
d872 1
a872 1
		  SYMBOL_LINKAGE_NAME (&msymbols[mcount])++;
d901 1
a901 1
      SYMBOL_LINKAGE_NAME (&msymbols[mcount]) = NULL;
d921 1
a921 1
	    const char *name = SYMBOL_LINKAGE_NAME (&objfile->msymbols[i]);
d984 1
a984 2
	    && STREQ (SYMBOL_LINKAGE_NAME (msymbol),
		      SYMBOL_LINKAGE_NAME (tsymbol)))
@


1.27
log
@2003-03-03  David Carlton  <carlton@@math.stanford.edu>

	* symtab.h (DEPRECATED_SYMBOL_MATCHES_NAME): Rename from
	SYMBOL_MATCHES_NAME, add comment.
	(SYMBOL_MATCHES_NATURAL_NAME): New.
	* minsyms.c (lookup_minimal_symbol_solib_trampoline): Replace
	SYMBOL_MATCHES_NAME with DEPRECATED_SYMBOL_MATCHES_NAME.
	(lookup_minimal_symbol, lookup_minimal_symbol_text): Ditto.
	* symtab.c (lookup_partial_symbol): Use
	SYMBOL_MATCHES_NATURAL_NAME, not SYMBOL_MATCHES_NAME.  Delete
	unhelpful comment.
	(lookup_block_symbol): Use SYMBOL_MATCHES_NATURAL_NAME, not
	SYMBOL_MATCHES_NAME.
	Fix for PR c++/33.
@
text
@d924 1
a924 1
		switch_to_cp_abi ("gnu-v3");
@


1.26
log
@2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.h (SYMBOL_NATURAL_NAME): New macro.
	(SYMBOL_LINKAGE_NAME): Ditto.
	(SYMBOL_PRINT_NAME): Use SYMBOL_NATURAL_NAME and
	SYMBOL_LINKAGE_NAME.
	(struct general_symbol_info): Expand comment.
	(DEPRECATED_SYMBOL_NAME): Rename from SYMBOL_NAME.
	(SYMBOL_MATCHES_NAME): Use DEPRECATED_SYMBOL_NAME.
	(SYMBOL_MATCHES_REGEXP): Ditto.
	* symtab.c (symbol_natural_name): New function.
	* objfiles.h: Replace all uses of SYMBOL_NAME by
	DEPRECATED_SYMBOL_NAME.
	* xcoffread.c, valops.c, typeprint.c, tracepoint.c: Ditto.
	* symtab.c, symmisc.c, symfile.c, stack.c, stabsread.c: Ditto.
	* somsolib.c, sol-thread.c, rs6000-tdep.c, p-valprint.c: Ditto.
	* printcmd.c, objfiles.c, objc-lang.c, mipsread.c: Ditto.
	* minsyms.c, mdebugread.c, linespec.c, jv-lang.c: Ditto.
	* i386-tdep.c, i386-linux-tdep.c, hpread.c, hppa-tdep.c: Ditto.
	* gnu-v2-abi.c, f-valprint.c, findvar.c, expprint.c: Ditto.
	* dwarfread.c, dwarf2read.c, dbxread.c, c-valprint.c: Ditto.
	* cp-valprint.c, coffread.c, buildsym.c, breakpoint.c: Ditto.
	* blockframe.c, ax-gdb.c, arm-linux-tdep.c, ada-lang.c: Ditto.
	* ada-exp.y: Ditto.
	* ada-exp.y: Update copyright.
	* sol-thread.c, mipsread.c, jv-lang.c, f-valprint.c: Ditto.
	* cp-valprint.c: Ditto.

2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* generic/gdbtk.h: Replace all instances of SYMBOL_NAME by
	DEPRECATED_SYMBOL_NAME.
	* generic/gdbtk-stack.c, generic/gdbtk-cmds.c: Ditto.
	* generic/gdbtk-stack.c, generic/gdbtk-cmds.c: Update copyright.

2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c: Replace all instances of SYMBOL_NAME with
	DEPRECATED_SYMBOL_NAME.  Update copyright.
@
text
@d191 1
a191 1
                if (SYMBOL_MATCHES_NAME (msymbol, name))
d291 1
a291 1
	      if (SYMBOL_MATCHES_NAME (msymbol, name) &&
d367 1
a367 1
	      if (SYMBOL_MATCHES_NAME (msymbol, name) &&
@


1.25
log
@	* defs.h (streq): Add prototype.
	* utils.c (streq): New function.

	* dwarf2read.c (new_symbol): Use SYMBOL_SET_NAMES instead of
	SYMBOL_NAME and SYMBOL_INIT_DEMANGLED_NAME.
	* mdebugread.c (new_symbol): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* coffread.c (process_coff_symbol): Likewise.
	* dwarfread.c (new_symbol): Likewise.

	* minsyms.c (prim_record_minimal_symbol_and_info): Use
	SYMBOL_SET_NAMES instead of setting SYMBOL_NAME.  Set the language
	here.
	(install_minimal_symbols): Don't set SYMBOL_LANGUAGE or call
	SYMBOL_INIT_DEMANGLED_NAME.
	* objfiles.c: Include "hashtab.h".
	(allocate_objfile): Call htab_set_functions_ex for the
	demangled_names_hash.
	(free_objfile): Call htab_delete for the demangled_names_hash.
	* objfiles.h (struct htab): Add declaration.
	(struct objfile): Add demangled_names_hash.
	* symfile.c: Include "hashtab.h".
	(reread_symbols): Call htab_delete for the demangled_names_hash.
	(add_psymbol_to_list): Use SYMBOL_SET_NAMES instead of putting
	SYMBOL_NAME in the bcache.
	* symtab.c: Include "hashtab.h".  Update comments.
	(create_demangled_names_hash, symbol_set_names): New functions.
	(symbol_find_demangled_name): New function, broken out from
	symbol_init_demangled_names.
	(symbol_init_demangled_names): Use it.
	* symtab.h (SYMBOL_INIT_DEMANGLED_NAME): Add missing parentheses.
	(SYMBOL_SET_NAMES): New macro.
	(symbol_set_names): Add prototype.
@
text
@d116 1
a116 1
      unsigned int hash = msymbol_hash (SYMBOL_NAME (sym)) % MINIMAL_SYMBOL_HASH_SIZE;
d662 2
a663 2
      char *name1 = SYMBOL_NAME (fn1);
      char *name2 = SYMBOL_NAME (fn2);
d755 1
a755 1
	      (STREQ (SYMBOL_NAME (copyfrom), SYMBOL_NAME ((copyfrom + 1)))))
d870 1
a870 1
	      if (SYMBOL_NAME (&msymbols[mcount])[0] == leading_char)
d872 1
a872 1
		  SYMBOL_NAME (&msymbols[mcount])++;
d901 1
a901 1
      SYMBOL_NAME (&msymbols[mcount]) = NULL;
d921 1
a921 1
	    const char *name = SYMBOL_NAME (&objfile->msymbols[i]);
d984 1
a984 1
	    && STREQ (SYMBOL_NAME (msymbol), SYMBOL_NAME (tsymbol)))
@


1.24
log
@Use a single, consistent representation for an empty minimal
symbol table in an objfile.
* objfiles.c (terminate_minimal_symbol_table): New function.
(allocate_objfile): Call it.
* objfiles.h (terminate_minimal_symbol_table): New declaration.
(ALL_MSYMBOLS): No need to test whether (objfile)->msymbols is
non-NULL.
* minsyms.c (lookup_minimal_symbol_by_pc_section): To see whether
objfile has minimal symbols, compare minimal_symbol_count to zero,
instead of comparing msymbols with NULL.
* objfiles.c (have_minimal_symbols): Same.
* solib-sunos.c (solib_add_common_symbols): Call
terminate_minimal_symbol_table.
* symfile.c (reread_symbols): Same.
@
text
@a614 2
  SYMBOL_NAME (msymbol) = obsavestring ((char *) name, strlen (name),
					&objfile->symbol_obstack);
d616 3
a869 1
	      SYMBOL_LANGUAGE (&msymbols[mcount]) = language_auto;
a928 5
      
      /* Now walk through all the minimal symbols, selecting the newly added
         ones and attempting to cache their C++ demangled names. */
      for (; mcount-- > 0; msymbols++)
	SYMBOL_INIT_DEMANGLED_NAME (msymbols, &objfile->symbol_obstack);
@


1.23
log
@	* minsyms.c (lookup_minimal_symbol): Update comment.
	(lookup_minimal_symbol_text): Update comment.  Use the hash table.
	(lookup_minimal_symbol_solib_trampoline): Likewise.
@
text
@d414 1
a414 1
      if ((msymbol = objfile->msymbols) != NULL)
d416 1
@


1.23.4.1
log
@Merge with interps-20030203-mergepoint.
@
text
@d414 1
a414 1
      if (objfile->minimal_symbol_count > 0)
a415 1
          msymbol = objfile->msymbols;
@


1.22
log
@2002-07-11  Daniel Jacobowitz  <drow@@mvista.com>

	Based on patch from Daniel Berlin <dberlin@@dberlin.org>.
	* buildsym.c: Include "demangle.h" for SYMBOL_INIT_DEMANGLED_NAME.
	(finish_block) For non-function blocks, hash the symbol table.  For
	function blocks, mark the symbol table as unhashed.
	* minsyms.c (msymbol_hash): Return hash value without taking modulus.
	(msymbol_hash_iw): Likewise.
	(add_minsym_to_hash_table): Take modulus of msymbol_hash's return
	value.
	(add_minsym_to_demangled_hash_table): Likewise for msymbol_hash_iw.
	(lookup_minimal_symbol): Likewise for both.
	* symtab.h (struct block): Add `hashtable' flag.  Comment the
	hashtable.
	(BLOCK_HASHTABLE, BLOCK_BUCKETS, BLOCK_BUCKET): New macro.
	(ALL_BLOCK_SYMBOLS): Update.
	(BLOCK_SHOULD_SORT): Do not sort hashed blocks.
	(struct symbol): Add `hash_next' pointer.
	* symtab.c (lookup_block_symbol): Search using the hash table when
	possible.
	(find_pc_sect_symtab): Use ALL_BLOCK_SYMBOLS.
	(search_symbols, find_addr_symbol): Likewise.

	* dstread.c (process_dst_block): Clear hashtable bit for new block.
	(read_dst_symtab): Likewise.
	* jv-lang.c (get_java_class_symtab): Likewise.
	* mdebugread.c: Include "gdb_assert.h".
	(shrink_block): Assert that the block being modified is not hashed.
	* coffread.c (patch_opaque_types): Use ALL_BLOCK_SYMBOLS.
	* symmisc.c (free_symtab_block): Walk the hash table when freeing
	symbols.
	(dump_symtab): Recognize hashed blocks.
	* printcmd.c (print_frame_args):  Assert that function blocks do not
	have hashed symbol tables.
	* ada-lang.c (symtab_for_sym): Use ALL_BLOCK_SYMBOLS.
	(fill_in_ada_prototype, debug_print_block): Likewise.
	(ada_add_block_symbols): Use ALL_BLOCK_SYMBOLS.  Handle hash tables.
@
text
@d2 2
a3 1
   Copyright 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
d139 3
a141 2
   the search to that objfile.  If SFILE is non-NULL, limit the search
   to that source file.  Returns a pointer to the minimal symbol that
d147 1
a147 1
   names (the dynamic linker deals with the duplication). */
d253 7
a259 6
   first minimal symbol that matches NAME and of text type.  
   If OBJF is non-NULL, limit
   the search to that objfile.  If SFILE is non-NULL, limit the search
   to that source file.  Returns a pointer to the minimal symbol that
   matches, or NULL if no match is found.
 */
d270 2
d287 3
a289 4
	  for (msymbol = objfile->msymbols;
	       msymbol != NULL && SYMBOL_NAME (msymbol) != NULL &&
	       found_symbol == NULL;
	       msymbol++)
d330 7
a336 6
   first minimal symbol that matches NAME and of solib trampoline type.  
   If OBJF is non-NULL, limit
   the search to that objfile.  If SFILE is non-NULL, limit the search
   to that source file.  Returns a pointer to the minimal symbol that
   matches, or NULL if no match is found.
 */
d346 2
d363 3
a365 4
	  for (msymbol = objfile->msymbols;
	       msymbol != NULL && SYMBOL_NAME (msymbol) != NULL &&
	       found_symbol == NULL;
	       msymbol++)
@


1.22.10.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 2
   Copyright 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
   2002, 2003
d115 1
a115 2
      unsigned int hash
	= msymbol_hash (SYMBOL_LINKAGE_NAME (sym)) % MINIMAL_SYMBOL_HASH_SIZE;
d138 2
a139 3
   the search to that objfile.  If SFILE is non-NULL, the only file-scope
   symbols considered will be from that source file (global symbols are
   still preferred).  Returns a pointer to the minimal symbol that
d145 1
a145 1
   names (the dynamic linker deals with the duplication).  */
d148 1
a148 1
lookup_minimal_symbol (const char *name, const char *sfile,
d189 1
a189 9
		  /* FIXME: carlton/2003-02-27: This is an unholy
		     mixture of linkage names and natural names.  If
		     you want to test the linkage names with strcmp,
		     do that.  If you want to test the natural names
		     with strcmp_iw, use SYMBOL_MATCHES_NATURAL_NAME.  */
		  if (strcmp (DEPRECATED_SYMBOL_NAME (msymbol), (name)) == 0
		      || (SYMBOL_DEMANGLED_NAME (msymbol) != NULL
			  && strcmp_iw (SYMBOL_DEMANGLED_NAME (msymbol),
					(name)) == 0))
d197 1
a197 2
                        if (sfile == NULL
			    || strcmp (msymbol->filename, sfile) == 0)
d251 6
a256 5
   first minimal symbol that matches NAME and has text type.  If OBJF
   is non-NULL, limit the search to that objfile.  Returns a pointer
   to the minimal symbol that matches, or NULL if no match is found.

   This function only searches the mangled (linkage) names.  */
d259 2
a260 1
lookup_minimal_symbol_text (const char *name, struct objfile *objf)
d267 8
a274 1
  unsigned int hash = msymbol_hash (name) % MINIMAL_SYMBOL_HASH_SIZE;
d282 4
a285 3
	  for (msymbol = objfile->msymbol_hash[hash];
	       msymbol != NULL && found_symbol == NULL;
	       msymbol = msymbol->hash_next)
d287 1
a287 1
	      if (strcmp (SYMBOL_LINKAGE_NAME (msymbol), name) == 0 &&
d294 9
d304 1
d326 6
a331 6
   first minimal symbol that matches NAME and is a solib trampoline.
   If OBJF is non-NULL, limit the search to that objfile.  Returns a
   pointer to the minimal symbol that matches, or NULL if no match is
   found.

   This function only searches the mangled (linkage) names.  */
d334 2
a335 2
lookup_minimal_symbol_solib_trampoline (const char *name,
					struct objfile *objf)
d341 8
a348 1
  unsigned int hash = msymbol_hash (name) % MINIMAL_SYMBOL_HASH_SIZE;
d356 4
a359 3
	  for (msymbol = objfile->msymbol_hash[hash];
	       msymbol != NULL && found_symbol == NULL;
	       msymbol = msymbol->hash_next)
d361 1
a361 1
	      if (strcmp (SYMBOL_LINKAGE_NAME (msymbol), name) == 0 &&
a390 1
  struct obj_section *pc_section;
d395 1
a395 2
  pc_section = find_pc_section (pc);
  if (pc_section == NULL)
a397 8
  /* If no section was specified, then just make sure that the PC is in
     the same section as the minimal symbol we find.  */
  if (section == NULL)
    section = pc_section->the_bfd_section;

  /* FIXME drow/2003-07-19: Should we also check that PC is in SECTION
     if we were passed a non-NULL SECTION argument?  */

d408 1
a408 1
      if (objfile->minimal_symbol_count > 0)
a409 1
          msymbol = objfile->msymbols;
d576 2
a577 2
  struct msym_bunch *new;
  struct minimal_symbol *msymbol;
d595 1
a595 1
	if (strncmp (tempstring, "__gnu_compiled", 14) == 0)
d608 2
a610 3
  SYMBOL_LANGUAGE (msymbol) = language_auto;
  SYMBOL_SET_NAMES (msymbol, (char *)name, strlen (name), objfile);

a617 1
  MSYMBOL_SIZE (msymbol) = 0;
d637 2
a638 2
  const struct minimal_symbol *fn1;
  const struct minimal_symbol *fn2;
d654 2
a655 2
      char *name1 = SYMBOL_LINKAGE_NAME (fn1);
      char *name2 = SYMBOL_LINKAGE_NAME (fn2);
d679 1
a679 1
  struct msym_bunch *next;
d745 3
a747 4
	  if (SYMBOL_VALUE_ADDRESS (copyfrom)
	      == SYMBOL_VALUE_ADDRESS ((copyfrom + 1))
	      && strcmp (SYMBOL_LINKAGE_NAME (copyfrom),
			 SYMBOL_LINKAGE_NAME ((copyfrom + 1))) == 0)
d822 4
a825 4
  int bindex;
  int mcount;
  struct msym_bunch *bunch;
  struct minimal_symbol *msymbols;
d827 1
a827 1
  char leading_char;
d862 2
a863 1
	      if (SYMBOL_LINKAGE_NAME (&msymbols[mcount])[0] == leading_char)
d865 1
a865 1
		  SYMBOL_LINKAGE_NAME (&msymbols[mcount])++;
d894 1
a894 1
      SYMBOL_LINKAGE_NAME (&msymbols[mcount]) = NULL;
a896 1
      MSYMBOL_SIZE (&msymbols[mcount]) = 0;
d914 2
a915 8
	    /* If a symbol's name starts with _Z and was successfully
	       demangled, then we can assume we've found a GNU v3 symbol.
	       For now we set the C++ ABI globally; if the user is
	       mixing ABIs then the user will need to "set cp-abi"
	       manually.  */
	    const char *name = SYMBOL_LINKAGE_NAME (&objfile->msymbols[i]);
	    if (name[0] == '_' && name[1] == 'Z'
		&& SYMBOL_DEMANGLED_NAME (&objfile->msymbols[i]) != NULL)
d917 1
a917 1
		set_cp_abi_as_auto_default ("gnu-v3");
d922 5
d982 1
a982 2
	    && strcmp (SYMBOL_LINKAGE_NAME (msymbol),
		       SYMBOL_LINKAGE_NAME (tsymbol)) == 0)
@


1.22.10.2
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d3 1
a3 1
   2002, 2003, 2004
d717 1
a717 1
   on the objfile_obstack, and will get automatically freed when the symbol
d835 1
a835 1
      obstack_blank (&objfile->objfile_obstack,
d838 1
a838 1
	obstack_base (&objfile->objfile_obstack);
d878 1
a878 1
      obstack_blank (&objfile->objfile_obstack,
d881 1
a881 1
	obstack_finish (&objfile->objfile_obstack);
d899 1
a899 1
         The strings themselves are also located in the objfile_obstack
@


1.22.8.1
log
@2002-12-20  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_minsyms): Don't call
	lookup_symbol_aux from within this.
	* values.c (value_static_field): lookup_symbol_linkage.
	(value_fn_field): lookup_symbol_linkage.
	* valops.c (value_struct_elt_for_reference): lookup_symbol_linkage.
	* blockframe.c (inside_main_func): lookup_symbol_linkage.
	* source.c (select_source_symtab): lookup_symbol_linkage.
	* nlmread.c (nlm_symfile_read): Call lookup_symbol_linkage.
	* nindy-tdep.c (nindy_frame_chain_valid): Call
	lookup_symbol_linkage.
	* linespec.c (count_methods): Call lookup_symbol_linkage.
	(add_matching_methods): Ditto.
	(add_constructors): Ditto.
	* hppa-tdep.c (find_stub_with_shl_get): Call
	lookup_symbol_linkage.  Delete symbol2.
	(initialize_hp_cxx_exception_support): Call lookup_symbol_linkage.
	* cli/cli-cmds.c (edit_command): SYMBOL_PRINT_NAME.
	(list_command): SYMBOL_PRINT_NAME.
	* valops.c (value_of_variable): SYMBOL_PRINT_NAME
	(hand_function_call): SYMBOL_PRINT_NAME.
	* typeprint.c (typedef_print): SYMBOL_PRINT_NAME.
	* tracepoint.c (tracepoints_info): SYMBOL_PRINT_NAME.
	* symtab.c (lookup_partial_symbol): SYMBOL_BEST_NAME.
	(compare_search_syms): SYMBOL_BEST_NAME.
	(print_symbol_info): SYMBOL_PRINT_NAME.
	(print_msymbol_info): SYMBOL_PRINT_NAME.
	(rbreak_command): SYMBOL_PRINT_NAME.
	* symmisc.c (print_symbol): SYMBOL_PRINT_NAME.
	* stack.c (print_frame): SYMBOL_PRINT_NAME.
	(frame_info): SYMBOL_PRINT_NAME.
	(print_block_frame_locals): SYMBOL_PRINT_NAME.
	(print_block_frame_labels): SYMBOL_PRINT_NAME.
	(print_frame_arg_vars): SYMBOL_PRINT_NAME.
	(return_command): SYMBOL_PRINT_NAME.
	* stabsread.c (define_symbol): SYMBOL_PRINT_NAME.
	* p-valprint.c (pascal_val_print): SYMBOL_PRINT_NAME.
	* printcmd.c (build_address_symbolic): SYMBOL_PRINT_NAME.
	(sym_info): SYMBOL_PRINT_NAME.
	(print_frame_args): SYMBOL_PRINT_NAME.
	* objc-lang.c (compare_selectors): SYMBOL_BEST_NAME.
	(compare_classes): SYMBOL_BEST_NAME.
	* maint.c (maintenance_translate_address): SYMBOL_PRINT_NAME.
	* linespec.c (find_method): SYMBOL_PRINT_NAME.
	(select_symbols): SYMBOL_PRINT_NAME.
	* infcmd.c (jump_command): SYMBOL_PRINT_NAME.
	* findvar.c (locate_var_value): SYMBOL_PRINT_NAME.
	* expprint.c (print_subexp): SYMBOL_PRINT_NAME.
	* c-valprint.c (c_val_print): SYMBOL_PRINT_NAME.
	* buildsym.c (finish_block): SYMBOL_PRINT_NAME.
	* breakpoint.c (print_one_breakpoint): SYMBOL_PRINT_NAME.
	* ax-gdb.c (gen_var_ref): SYMBOL_PRINT_NAME.
	* ada-typeprint.c (ada_typedef_print): SYMBOL_PRINT_NAME.
	* ada-lang.c (user_select_syms): Use SYMBOL_PRINT_NAME instead of
	SYMBOL_SOURCE_NAME.
	(user_select_syms):
	(ada_finish_decode_line_1): Use SYMBOL_BEST_NAME instead of
	SYMBOL_SOURCE_NAME.
	* symtab.h (SYMBOL_PRINT_NAME): Rename from SYMBOL_SOURCE_NAME.
	* symfile.c (compare_symbols): Use SYMBOL_BEST_NAME, not
	SYMBOL_SOURCE_NAME.
	(compare_psymbols): Ditto.
	* symtab.c (lookup_symbol_linkage): New function.
	* symtab.h: Declare lookup_symbol_linkage.
	* c-valprint.c (c_val_print): Call lookup_symbol_minsym.
	* symtab.c (lookup_symbol_aux_minsyms): Call minsym_static.
	* minsyms.c (minsym_static): New function.
	* symtab.h: Declare minsym_static.
	* symtab.c (lookup_symbol_minsym): New function.
	(search_symbols): Call lookup_symbol_minsym instead of
	lookup_symbol.
	(lookup_symbol_namespace): Don't take apart NAME.
	* symtab.h: Declare lookup_symbol_minsym.
	* printcmd.c (build_address_symbolic): Don't use old version of
	SYMBOL_LINKAGE_NAME.
	* symtab.c (lookup_block_symbol): Change mangled names to linkage
	name, and use SYMBOL_LINKAGE_NAME as appropriate.
	* symtab.h (SYMBOL_LINKAGE_NAME): New macro, with a different
	meaning from the old macro of the same name.  Also, add comments
	about proper uses of names.
@
text
@a987 16

/* Test whether or not MINSYM corresponnds to a static symbol (i.e. is
   file-local) or not.  */
int
minsym_static (const struct minimal_symbol *minsym)
{
  switch (MSYMBOL_TYPE (minsym))
    {
    case mst_file_text:
    case mst_file_data:
    case mst_file_bss:
      return 1;
    default:
      return 0;
    }
}
@


1.22.8.2
log
@2003-01-31  David Carlton  <carlton@@math.stanford.edu>

	From Jim Blandy  <jimb@@redhat.com>:

	Use a single, consistent representation for an empty minimal
	symbol table in an objfile.
	* objfiles.c (terminate_minimal_symbol_table): New function.
	(allocate_objfile): Call it.
	* objfiles.h (terminate_minimal_symbol_table): New declaration.
	(ALL_MSYMBOLS): No need to test whether (objfile)->msymbols is
	non-NULL.
	* minsyms.c (lookup_minimal_symbol_by_pc_section): To see whether
	objfile has minimal symbols, compare minimal_symbol_count to zero,
	instead of comparing msymbols with NULL.
	* objfiles.c (have_minimal_symbols): Same.
	* solib-sunos.c (solib_add_common_symbols): Call
	terminate_minimal_symbol_table.
	* symfile.c (reread_symbols): Same.

	* objfiles.h: Revert patch from 2003-01-27, to be replaced by
	similar patch from Jim Blandy.
	* objfiles.c (objfile_relocate): Ditto.
	* i386-linux-tdep.c (find_minsym_and_objfile): Ditto.
	* arm-linux-tdep.c (find_minsym_and_objfile): Ditto.
	* gdbtypes.h: Delete INTEGER_COERCION_BADNESS,
	FLOAT_COERCION_BADNESS.
	* gdbtypes.c (rank_one_type): Replace all uses of
	INTEGER_COERCION_BADNESS by INTEGER_CONVERSION_BADNESS.
	* valops.c (find_overload_match): Call cp_func_name.
	* cp-support.h: Declare cp_func_name.
	* cp-support.c (cp_func_name): New function.

2003-01-30  David Carlton  <carlton@@math.stanford.edu>

	* valops.c (find_overload_match): Move code into
	find_oload_champ_namespace.
	(find_oload_champ_namespace): New function, which immediately gets
	eviscerated and turned into a call to
	find_oload_champ_namespace_loop.
	(find_oload_champ_namespace_loop): New function.
	* symtab.c (make_symbol_overload_list): Move entire body into
	make_symbol_overload_list_qualified.
	(make_symbol_overload_list_qualified): New.
	(read_in_psymtabs): New.
	(make_symbol_overload_list_qualified): Rewrite.
	(make_symbol_overload_list_using): New.
	(lookup_symbol_namespace): Use alloca, not xmalloc.
	(make_symbol_overload_list): Put some memory management stuff back
	in.
@
text
@d408 1
a408 1
      if (objfile->minimal_symbol_count > 0)
a409 1
          msymbol = objfile->msymbols;
@


1.22.8.3
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d2 1
a2 2
   Copyright 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
   2002, 2003
d138 2
a139 3
   the search to that objfile.  If SFILE is non-NULL, the only file-scope
   symbols considered will be from that source file (global symbols are
   still preferred).  Returns a pointer to the minimal symbol that
d145 1
a145 1
   names (the dynamic linker deals with the duplication).  */
d251 6
a256 7
   first minimal symbol that matches NAME and has text type.  If OBJF
   is non-NULL, limit the search to that objfile.  If SFILE is non-NULL,
   the only file-scope symbols considered will be from that source file
   (global symbols are still preferred).  Returns a pointer to the minimal
   symbol that matches, or NULL if no match is found.

   This function only searches the mangled (linkage) names.  */
a266 2
  unsigned int hash = msymbol_hash (name) % MINIMAL_SYMBOL_HASH_SIZE;

d282 4
a285 3
	  for (msymbol = objfile->msymbol_hash[hash];
	       msymbol != NULL && found_symbol == NULL;
	       msymbol = msymbol->hash_next)
d326 6
a331 7
   first minimal symbol that matches NAME and is a solib trampoline.  If OBJF
   is non-NULL, limit the search to that objfile.  If SFILE is non-NULL,
   the only file-scope symbols considered will be from that source file
   (global symbols are still preferred).  Returns a pointer to the minimal
   symbol that matches, or NULL if no match is found.

   This function only searches the mangled (linkage) names.  */
a340 2
  unsigned int hash = msymbol_hash (name) % MINIMAL_SYMBOL_HASH_SIZE;

d356 4
a359 3
	  for (msymbol = objfile->msymbol_hash[hash];
	       msymbol != NULL && found_symbol == NULL;
	       msymbol = msymbol->hash_next)
d609 2
a611 3
  SYMBOL_LANGUAGE (msymbol) = language_auto;
  SYMBOL_SET_NAMES (msymbol, (char *)name, strlen (name), objfile);

d863 1
d923 5
@


1.22.8.4
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d116 1
a116 1
      unsigned int hash = msymbol_hash (DEPRECATED_SYMBOL_NAME (sym)) % MINIMAL_SYMBOL_HASH_SIZE;
d191 1
a191 1
                if (DEPRECATED_SYMBOL_MATCHES_NAME (msymbol, name))
d291 1
a291 1
	      if (DEPRECATED_SYMBOL_MATCHES_NAME (msymbol, name) &&
d367 1
a367 1
	      if (DEPRECATED_SYMBOL_MATCHES_NAME (msymbol, name) &&
d662 2
a663 2
      char *name1 = DEPRECATED_SYMBOL_NAME (fn1);
      char *name2 = DEPRECATED_SYMBOL_NAME (fn2);
d755 1
a755 1
	      (STREQ (DEPRECATED_SYMBOL_NAME (copyfrom), DEPRECATED_SYMBOL_NAME ((copyfrom + 1)))))
d870 1
a870 1
	      if (DEPRECATED_SYMBOL_NAME (&msymbols[mcount])[0] == leading_char)
d872 1
a872 1
		  DEPRECATED_SYMBOL_NAME (&msymbols[mcount])++;
d901 1
a901 1
      DEPRECATED_SYMBOL_NAME (&msymbols[mcount]) = NULL;
d921 1
a921 1
	    const char *name = DEPRECATED_SYMBOL_NAME (&objfile->msymbols[i]);
d924 1
a924 1
		set_cp_abi_as_auto_default ("gnu-v3");
d984 1
a984 1
	    && STREQ (DEPRECATED_SYMBOL_NAME (msymbol), DEPRECATED_SYMBOL_NAME (tsymbol)))
@


1.22.8.5
log
@2003-03-06  David Carlton  <carlton@@math.stanford.edu>

	* minsyms.c (add_minsym_to_hash_table): Use SYMBOL_LINKAGE_NAME.
	(add_minsym_to_demangled_hash_table): Use SYMBOL_NATURAL_NAME.
	(build_minimal_symbol_hash_tables): Add all minsyms to demangled
	hash table.
	(install_minimal_symbols): Use SYMBOL_LINKAGE_NAME.
	(find_solib_trampoline_target): Ditto.
	(compare_minimal_symbols): Ditto.
	(compact_minimal_symbols): Ditto.
	* symtab.h (DEPRECATED_SYMBOL_MATCHES_NAME): Delete.
	* minsyms.c (lookup_minimal_symbol_text): Replace use of
	DEPRECATED_SYMBOL_MATCHES_NAME by strcmp on linkage name.
	(lookup_minimal_symbol_solib_trampoline): Ditto.
	* symtab.h: Declare lookup_minimal_symbol_linkage,
	lookup_minimal_symbol_natural.
	* minsyms.c (lookup_minimal_symbol_aux): New function.
	(lookup_minimal_symbol_linkage): Ditto.
	(lookup_minimal_symbol_natural): Ditto.
	(lookup_minimal_symbol): Move body into
	lookup_minimal_symbol_aux.

2003-03-06  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/templates.exp (do_tests): Make expressions for 'ptype
	Bar' and 'ptype Qux' more generous.
@
text
@a78 5
static struct minimal_symbol *lookup_minimal_symbol_aux (const char *name,
							 int linkage,
							 const char *sfile,
							 struct objfile *objf);

d116 1
a116 2
      unsigned int hash
	= msymbol_hash (SYMBOL_LINKAGE_NAME (sym)) % MINIMAL_SYMBOL_HASH_SIZE;
d126 1
a126 1
				    struct minimal_symbol **table)
d130 1
a130 3
      unsigned int hash
	= (msymbol_hash_iw (SYMBOL_NATURAL_NAME (sym))
	   % MINIMAL_SYMBOL_HASH_SIZE);
d147 1
a147 4
   names (the dynamic linker deals with the duplication).

   This function first searches for matches via linkage names; if it
   doesn't find a match there, it then searches via natural names.  */
a152 39
  struct minimal_symbol *msymbol;

  msymbol = lookup_minimal_symbol_linkage (name, sfile, objf);

  if (msymbol != NULL)
    return msymbol;
  else
    return lookup_minimal_symbol_natural (name, sfile, objf);
}

/* Search for a minimal symbol via linkage names; args are as in
   lookup_minimal_symbol.  */

struct minimal_symbol *
lookup_minimal_symbol_linkage (const char *name, const char *sfile,
			       struct objfile *objf)
{
  return lookup_minimal_symbol_aux (name, 1, sfile, objf);
}

/* Search for a minimal symbol via natural names; args are as in
   lookup_minimal_symbol.  */

struct minimal_symbol *
lookup_minimal_symbol_natural (const char *name, const char *sfile,
			       struct objfile *objf)
{
  return lookup_minimal_symbol_aux (name, 0, sfile, objf);
}

/* Helper function for lookup_minimal_symbol and friends, which only
   searches for matches via linkage names or natural names but not
   both.  Args are in lookup_minimal_symbol; if LINKAGE is non-zero,
   search in linkage names, if zero, search in natural names.  */

static struct minimal_symbol *
lookup_minimal_symbol_aux (const char *name, int linkage,
			   const char *sfile, struct objfile *objf)
{
d159 2
a160 6
  unsigned int hash;

  if (linkage)
    hash = msymbol_hash (name) % MINIMAL_SYMBOL_HASH_SIZE;
  else
    hash = msymbol_hash_iw (name) % MINIMAL_SYMBOL_HASH_SIZE;
d177 3
a179 4
	  if (linkage)
	    msymbol = objfile->msymbol_hash[hash];
	  else
	    msymbol = objfile->msymbol_demangled_hash[hash];
d181 1
a181 1
	  while (msymbol != NULL && found_symbol == NULL)
d183 7
a189 3
	      if (linkage
		  ? strcmp (SYMBOL_LINKAGE_NAME (msymbol), name) == 0
		  : SYMBOL_MATCHES_NATURAL_NAME (msymbol, name))
d191 1
a191 1
		  switch (MSYMBOL_TYPE (msymbol))
d193 5
a197 3
		    case mst_file_text:
		    case mst_file_data:
		    case mst_file_bss:
d199 2
a200 2
		      if (sfile == NULL || STREQ (msymbol->filename, sfile))
			found_file_symbol = msymbol;
d202 6
a207 6
		      /* We have neither the ability nor the need to
			 deal with the SFILE parameter.  If we find
			 more than one symbol, just return the latest
			 one (the user can't expect useful behavior in
			 that case).  */
		      found_file_symbol = msymbol;
d209 1
a209 1
		      break;
d211 1
a211 1
		    case mst_solib_trampoline:
d213 14
a226 7
		      /* If a trampoline symbol is found, we prefer to
			 keep looking for the *real* symbol. If the
			 actual symbol is not found, then we'll use the
			 trampoline entry. */
		      if (trampoline_symbol == NULL)
			trampoline_symbol = msymbol;
		      break;
d228 5
a232 5
		    case mst_unknown:
		    default:
		      found_symbol = msymbol;
		      break;
		    }
a233 6

	      /* Find the next symbol on the hash chain.  */
	      if (linkage)
		msymbol = msymbol->hash_next;
	      else
		msymbol = msymbol->demangled_hash_next;
a236 1

d291 1
a291 1
	      if (strcmp (SYMBOL_LINKAGE_NAME (msymbol), name) == 0 &&
d367 1
a367 1
	      if (strcmp (SYMBOL_LINKAGE_NAME (msymbol), name) == 0 &&
d662 2
a663 2
      char *name1 = SYMBOL_LINKAGE_NAME (fn1);
      char *name2 = SYMBOL_LINKAGE_NAME (fn2);
d755 1
a755 2
	      (STREQ (SYMBOL_LINKAGE_NAME (copyfrom),
		      SYMBOL_LINKAGE_NAME ((copyfrom + 1)))))
d798 3
a800 2
      add_minsym_to_demangled_hash_table (msym,
					  objfile->msymbol_demangled_hash);
d870 1
a870 1
	      if (SYMBOL_LINKAGE_NAME (&msymbols[mcount])[0] == leading_char)
d872 1
a872 1
		  SYMBOL_LINKAGE_NAME (&msymbols[mcount])++;
d901 1
a901 1
      SYMBOL_LINKAGE_NAME (&msymbols[mcount]) = NULL;
d921 1
a921 1
	    const char *name = SYMBOL_LINKAGE_NAME (&objfile->msymbols[i]);
d984 1
a984 2
	    && STREQ (SYMBOL_LINKAGE_NAME (msymbol),
		      SYMBOL_LINKAGE_NAME (tsymbol)))
@


1.22.8.6
log
@2003-03-07  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_partial_symbol): Replace uses of
	SYMBOL_MATCHES_NATURAL_NAME by equivalent uses of
	SYMBOL_NATURAL_NAME, strcmp_iw.
	* symtab.h (SYMBOL_MATCHES_NATURAL_NAME): Delete.
	* minsyms.c (lookup_minimal_symbol_linkage): Make static.
	(lookup_minimal_symbol_natural): Ditto.
	(lookup_minimal_symbol): Only search on linkage names; rename
	first argument to 'linkage_name'.
	(lookup_minimal_symbol_linkage): Delete.
	(lookup_minimal_symbol_natural): Delete.
	(add_minsym_to_demangled_hash_table): Go back to using
	SYMBOL_DEMANGLED_NAME instead of SYMBOL_NATURAL_NAME.
	(lookup_minimal_symbol_aux): Don't use
	SYMBOL_MATCHES_NATURAL_NAME: do a strcmp_iw on
	SYMBOL_DEMANGLED_NAME instead.  Add comment.
	(build_minimal_symbol_hash_tables): Go back to only adding to
	demangled has table if SYMBOL_DEMANGLED_NAME is non-NULL.
	* symtab.h: Delete declarations for lookup_minimal_symbol_linkage
	and lookup_minimal_symbol_natural.
	* valops.c (find_function_in_inferior): Use lookup_symbol_linkage
	instead of lookup_symbol.  Change comment.
	* remote.c (remote_check_symbols): Use
	lookup_minimal_symbol_linkage_or_natural instead of
	lookup_minimal_symbol, but add FIXME comment as well.
	* objc-lang.c: Ditto.
	* c-exp.y: Use lookup_minimal_symbol_linkage_or_natural instead of
	lookup_minimal_symbol.
	* p-exp.y: Ditto.
	* objc-exp.y: Ditto.
	* m2-exp.y: Ditto.
	* jv-exp.y (push_expression_name): Ditto.
	* f-exp.y: Ditto.
	* printcmd.c (address_info): Ditto.
	* symtab.h: Declare lookup_minimal_symbol_linkage_or_natural.
	* minsyms.c (lookup_minimal_symbol_linkage_or_natural): New.
	* ax-gdb.c (gen_var_ref): Use SYMBOL_LINKAGE_NAME instead of
	DEPRECATED_SYMBOL_NAME.
	* tracepoint.c (scope_info): Ditto.
	* symtab.c (find_pc_sect_line): Ditto.
	* stabsread.c (define_symbol): Ditto.
	* sol-thread.c (info_cb): Ditto.
	* printcmd.c (address_info): Ditto.
	* hppa-tdep.c (hppa_fix_call_dummy): Ditto.
	(hppa_in_solib_call_trampoline): Ditto.
	* findvar.c (read_var_value): Ditto.
@
text
@a78 10
static struct minimal_symbol *lookup_minimal_symbol_linkage (const char *name,
							     const char *sfile,
							     struct objfile
							     *objf);

static struct minimal_symbol *lookup_minimal_symbol_natural (const char *name,
							     const char *sfile,
							     struct objfile
							     *objf);

d137 1
a137 1
	= (msymbol_hash_iw (SYMBOL_DEMANGLED_NAME (sym))
d146 5
a150 6
   first minimal symbol whose linkage name is LINKAGE_NAME.  If OBJF
   is non-NULL, limit the search to that objfile.  If SFILE is
   non-NULL, the only file-scope symbols considered will be from that
   source file (global symbols are still preferred).  Returns a
   pointer to the minimal symbol that matches, or NULL if no match is
   found.
d155 1
a155 1
   names (the dynamic linker deals with the duplication).  */
d157 2
a158 3
/* NOTE: carlton/2003-03-07: This function used to match on natural
   names as well; if you want that behavior, call
   lookup_minimal_symbol_linkage_or_natural.  */
d161 1
a161 1
lookup_minimal_symbol (register const char *linkage_name, const char *sfile,
d164 8
a171 1
  return lookup_minimal_symbol_aux (linkage_name, 1, sfile, objf);
d174 2
a175 15
/* Search for a minimal symbol named NAME.  Search for that name as
   either a linkage name or a natural name.  */

/* NOTE: carlton/2003-03-07: I normally strongly dislike functions
   that accept either linkage names or natural names, but I'm making
   an exception here: callers of this function derive NAME from user
   input, and do so in situations where using a linkage name might be
   necessary as a workaround for some of GDB's C++ bugs.  */

/* NOTE: carlton/2003-03-07: This never searches on all natural names
   at once: it searches on linkage names via strcmp, and on demangled
   names via strcmp_iw.  However, for natural names that turn out to
   be linkage names of minimal symbols, using strcmp in place of
   strcmp_iw is safe.  (You have to be more careful if the name isn't
   associated to a minimal symbol: see PR gdb/33.)  */
d178 2
a179 1
lookup_minimal_symbol_linkage_or_natural (const char *name)
d181 2
a182 1
  struct minimal_symbol *msymbol;
d184 2
a185 1
  msymbol = lookup_minimal_symbol_aux (name, 1, NULL, NULL);
d187 5
a191 4
  if (msymbol != NULL)
    return msymbol;
  else
    return lookup_minimal_symbol_aux (name, 0, NULL, NULL);
d197 1
a197 5
   search in linkage names via strcmp, and if zero, search in
   demangled names via strcmp_iw.  */

/* NOTE: carlton/2003-03-07: If non-zero, it really only searches in
   demangled names, not in all natural names.  Be careful.  */
d240 1
a240 1
		  : strcmp_iw (SYMBOL_DEMANGLED_NAME (msymbol), name) == 0)
d848 2
a849 3
      if (SYMBOL_DEMANGLED_NAME (msym) != NULL)
	add_minsym_to_demangled_hash_table (msym,
					    objfile->msymbol_demangled_hash);
@


1.22.8.7
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@a988 5
	    /* If a symbol's name starts with _Z and was successfully
	       demangled, then we can assume we've found a GNU v3 symbol.
	       For now we set the C++ ABI globally; if the user is
	       mixing ABIs then the user will need to "set cp-abi"
	       manually.  */
d990 1
a990 2
	    if (name[0] == '_' && name[1] == 'Z'
		&& SYMBOL_DEMANGLED_NAME (&objfile->msymbols[i]) != NULL)
@


1.22.8.8
log
@2003-05-02  David Carlton  <carlton@@bactrian.org>

	* minsyms.c: Delete declarations for lookup_minimal_symbol_linkage
	and lookup_minimal_symbol_natural.
	* linespec.c (decode_variable): Call
	lookup_minimal_symbol_linkage_or_natural instead of
	lookup_minimal_symbol.
	(decode_dollar): Ditto.
@
text
@d79 10
@


1.22.8.9
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@a453 1
  struct obj_section *pc_section;
d458 1
a458 2
  pc_section = find_pc_section (pc);
  if (pc_section == NULL)
a459 8

  /* If no section was specified, then just make sure that the PC is in
     the same section as the minimal symbol we find.  */
  if (section == NULL)
    section = pc_section->the_bfd_section;

  /* FIXME drow/2003-07-19: Should we also check that PC is in SECTION
     if we were passed a non-NULL SECTION argument?  */
@


1.22.8.10
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d163 1
a163 1
lookup_minimal_symbol (const char *linkage_name, const char *sfile,
d319 1
a319 1
lookup_minimal_symbol_text (const char *name, const char *sfile,
d396 2
a397 3
lookup_minimal_symbol_solib_trampoline (const char *name,
					const char *sfile,
					struct objfile *objf)
d650 2
a651 2
  struct msym_bunch *new;
  struct minimal_symbol *msymbol;
d712 2
a713 2
  const struct minimal_symbol *fn1;
  const struct minimal_symbol *fn2;
d754 1
a754 1
  struct msym_bunch *next;
d898 4
a901 4
  int bindex;
  int mcount;
  struct msym_bunch *bunch;
  struct minimal_symbol *msymbols;
d903 1
a903 1
  char leading_char;
@


1.22.8.11
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d256 2
a257 3
                        if (sfile == NULL
			    || strcmp (msymbol->filename, sfile) == 0)
                          found_file_symbol = msymbol;
d311 4
a314 2
   is non-NULL, limit the search to that objfile.  Returns a pointer
   to the minimal symbol that matches, or NULL if no match is found.
d319 2
a320 1
lookup_minimal_symbol_text (const char *name, struct objfile *objf)
d329 9
d355 9
d365 1
d387 5
a391 4
   first minimal symbol that matches NAME and is a solib trampoline.
   If OBJF is non-NULL, limit the search to that objfile.  Returns a
   pointer to the minimal symbol that matches, or NULL if no match is
   found.
d397 1
d406 9
d670 1
a670 1
	if (strncmp (tempstring, "__gnu_compiled", 14) == 0)
d821 4
a824 4
	  if (SYMBOL_VALUE_ADDRESS (copyfrom)
	      == SYMBOL_VALUE_ADDRESS ((copyfrom + 1))
	      && strcmp (SYMBOL_LINKAGE_NAME (copyfrom),
			 SYMBOL_LINKAGE_NAME ((copyfrom + 1))) == 0)
d1059 2
a1060 2
	    && strcmp (SYMBOL_LINKAGE_NAME (msymbol),
		       SYMBOL_LINKAGE_NAME (tsymbol)) == 0)
@


1.22.8.12
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@a661 1
  MSYMBOL_SIZE (msymbol) = 0;
a940 1
      MSYMBOL_SIZE (&msymbols[mcount]) = 0;
@


1.21
log
@2002-04-24  David S. Miller  <davem@@redhat.com>

	* symtab.h (find_stab_function_addr): Kill extern.
	* minsyms.c (find_stab_function_addr): Remove from here...
	* dbxread.c: ... to here, and mark it static.
@
text
@d94 1
a94 1
  return hash % MINIMAL_SYMBOL_HASH_SIZE;
d105 1
a105 1
  return hash % MINIMAL_SYMBOL_HASH_SIZE;
d115 1
a115 1
      unsigned int hash = msymbol_hash (SYMBOL_NAME (sym));
d129 1
a129 1
      unsigned int hash = msymbol_hash_iw (SYMBOL_DEMANGLED_NAME (sym));
d157 2
a158 2
  unsigned int hash = msymbol_hash (name);
  unsigned int dem_hash = msymbol_hash_iw (name);
@


1.21.6.1
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d94 1
a94 1
  return hash;
d105 1
a105 1
  return hash;
d115 1
a115 1
      unsigned int hash = msymbol_hash (SYMBOL_NAME (sym)) % MINIMAL_SYMBOL_HASH_SIZE;
d129 1
a129 1
      unsigned int hash = msymbol_hash_iw (SYMBOL_DEMANGLED_NAME (sym)) % MINIMAL_SYMBOL_HASH_SIZE;
d157 2
a158 2
  unsigned int hash = msymbol_hash (name) % MINIMAL_SYMBOL_HASH_SIZE;
  unsigned int dem_hash = msymbol_hash_iw (name) % MINIMAL_SYMBOL_HASH_SIZE;
@


1.20
log
@* coffread.c: Remove redundant static declarations.  Replace
occurrences of `PTR' with `void *'.
* elfread.c, mdebugread.c, minsyms.c, mipsread.c: Likewise.
* top.h (quit_cover): Likewise.
* defs.h (catch_errors): Likewise.
@
text
@a506 46

#ifdef SOFUN_ADDRESS_MAYBE_MISSING
CORE_ADDR
find_stab_function_addr (char *namestring, char *filename,
			 struct objfile *objfile)
{
  struct minimal_symbol *msym;
  char *p;
  int n;

  p = strchr (namestring, ':');
  if (p == NULL)
    p = namestring;
  n = p - namestring;
  p = alloca (n + 2);
  strncpy (p, namestring, n);
  p[n] = 0;

  msym = lookup_minimal_symbol (p, filename, objfile);
  if (msym == NULL)
    {
      /* Sun Fortran appends an underscore to the minimal symbol name,
         try again with an appended underscore if the minimal symbol
         was not found.  */
      p[n] = '_';
      p[n + 1] = 0;
      msym = lookup_minimal_symbol (p, filename, objfile);
    }

  if (msym == NULL && filename != NULL)
    {
      /* Try again without the filename. */
      p[n] = 0;
      msym = lookup_minimal_symbol (p, NULL, objfile);
    }
  if (msym == NULL && filename != NULL)
    {
      /* And try again for Sun Fortran, but without the filename. */
      p[n] = '_';
      p[n + 1] = 0;
      msym = lookup_minimal_symbol (p, NULL, objfile);
    }

  return msym == NULL ? 0 : SYMBOL_VALUE_ADDRESS (msym);
}
#endif /* SOFUN_ADDRESS_MAYBE_MISSING */
@


1.19
log
@Approved by Jim Blandy:

	2001-12-10  Fred Fish  <fnf@@redhat.com>
	* arm-linux-tdep.c (skip_hurd_resolver): Use NULL rather than
	zero in args to lookup_minimal_symbol.
	* linespec.c (decode_line_1): Ditto.
	* i386-linux-tdep.c (skip_hurd_resolver): Ditto.
	* minsyms.c (find_stab_function_addr): Ditto.
	* symfile.c (simple_read_overlay_table): Ditto.
	(simple_read_overlay_region_table): Ditto.
@
text
@a77 10
/* Prototypes for local functions. */

static int compare_minimal_symbols (const PTR, const PTR);

static int
compact_minimal_symbols (struct minimal_symbol *, int, struct objfile *);

static void add_minsym_to_demangled_hash_table (struct minimal_symbol *sym,
						struct minimal_symbol **table);

d681 1
a681 1
compare_minimal_symbols (const PTR fn1p, const PTR fn2p)
@


1.19.2.1
log
@* coffread.c: Remove redundant static declarations.  Replace
occurrences of `PTR' with `void *'.
* elfread.c, mdebugread.c, minsyms.c, mipsread.c: Likewise.
* top.h (quit_cover): Likewise.
* defs.h (catch_errors): Likewise.
@
text
@d78 10
d691 1
a691 1
compare_minimal_symbols (const void *fn1p, const void *fn2p)
@


1.18
log
@        * minsyms.c (msymbol_hash): Use better hash function.
        (msymbol_hash_iw): Likewise.  Terminate loop at '(' properly.

        * objfiles.h: Increase MINIMAL_SYMBOL_HASH_SIZE to match modern
        binaries.
@
text
@d550 1
a550 1
      msym = lookup_minimal_symbol (p, 0, objfile);
d557 1
a557 1
      msym = lookup_minimal_symbol (p, 0, objfile);
@


1.17
log
@* symfile.c (compare_psymbols, compare_symbols): Declare using
PTR, as in the definition.
* minsyms.c (compare_minimal_symbols): Likewise.
* coffread.c (find_targ_sec): Likewise.
* elfread.c (free_elfinfo, elf_locate_sections): Likewise.
* mipsread.c (alphacoff_locate_sections): Likewise.
* mdebugread.c (compare_blocks): Likewise.
@
text
@d99 4
a102 2
	hash = (31 * hash) + *string;
      ++string;
d114 1
a114 1
    hash = (31 * hash) + *string;
@


1.17.2.1
log
@Typesystem work initial import.
Note that this currently isn't building, i'm in the middle of converting make_function_type/lookup_function_type
@
text
@d57 1
a57 1
#define BUNCH_SIZE 4096
d88 1
a88 2
/* Compute a hash code based using the same criteria as `strcmp_iw'. 
   Based on FNV-1 hash used in bcache.c.
d90 4
a93 3
   Note, we used to have a loop that, with the new hashing algorithm, would have looked like:
   
  unsigned int hash = 0x811c9dc5;
d99 1
a99 4
	{
	  hash *= 16777619;
	  hash ^= *string;
	}
d102 1
a102 46
  return hash;
}

This loop is over twice as slow as the loop used in the function.

The other possibility would have been

  unsigned int hash = 0x811c9dc5;
  for (*string; *string && *string != '('; ++string)
  {
	  if (isspace (*string))
	     continue;
	  hash *= 16777619;
	  hash ^= *string;
  }
  return hash;

This loop is 1.5 times as slow as below.

All three were hand verified to give the same hash values for symbols
with/without spaces in them, ending/not ending in parens, etc.

These timings are consistent on a 500mhz G3 PPC, a 266mhz PII, and a
500mhz PIII, and a 300mhz Ultrasparc IIi, using gcc 2.95.3 on all of
them, so AFAIK, it's because the compiler can better optimize the loop
below , not because of the  platform I tested on.

Since this function now almost completely dominates symbol lookup
time, please be careful in changing it.

*/

unsigned int
msymbol_hash_iw (const char *string)
{
  unsigned int hash = 0x811c9dc5;
  unsigned int c;
  unsigned int len = strlen(string);
  for (c=0; c < len && string[c] != '('; c++)
    {
      if (isspace (string[c]))
	continue;
      hash *= 16777619;
      hash ^= string[c];
    }
  return hash;
d110 4
a113 1
  return hash((char *)string, strlen(string));
d123 1
a123 1
      unsigned int hash = msymbol_hash (SYMBOL_NAME (sym)) % MINIMAL_SYMBOL_HASH_SIZE;
d137 1
a137 1
      unsigned int hash = msymbol_hash_iw (SYMBOL_DEMANGLED_NAME (sym)) % MINIMAL_SYMBOL_HASH_SIZE;
d165 2
a166 2
  unsigned int hash = msymbol_hash (name) % MINIMAL_SYMBOL_HASH_SIZE;
  unsigned int dem_hash = msymbol_hash_iw (name)  % MINIMAL_SYMBOL_HASH_SIZE;
@


1.16
log
@Add support for the GNU V3 C++ ABI.
(Includes changes by Dan Berlin.)

* gnu-v3-abi.c: New file.
* minsyms.c: #include "value.h" and "cp-abi.h".
(install_minimal_symbols): Check the minimal symbol table for
symbols that look mangled in the V3 style, and select the V3 ABI
if we find any.
* Makefile.in (SFILES): Add gnu-v3-abi.c.
(COMMON_OBS): Add gnu-v3-abi.o.
(gnu-v3-abi.o): Add new rule.
(minsyms.o): Depend on $(cp_abi_h) and $(value_h).
@
text
@d80 1
a80 1
static int compare_minimal_symbols (const void *, const void *);
@


1.15
log
@2001-03-06  J.T. Conklin  <jtc@@redback.com>

        * symtab.h (decode_line_1): Removed declaration.

        * symfile.c (#include <assert.h>): Removed.

        * arch-utils.c (#include <ctype.h>): Removed.
        * c-typeprint.c: Likewise.
        * dbxread.c: Likewise.
        * gdbtypes.c: Likewise.
        * target.c: Likewise.
        * os9kread.c: Likewise.

        * c-valprint.c (#include "demangle.h"): Removed.
        * ch-typeprint.c: Likewise.
        * eval.c: Likewise.
        * f-typeprint.c: Likewise.
        * f-valprint.c: Likewise.
        * m2-typeprint.c: Likewise.
        * typeprint.c: Likewise.
        * p-typeprint.c: Likewise.
        * valarith.c: Likewise.
        * valprint.c: Likewise.

        * m2-typeprint.c (#include "gdb_string.h"): Removed.
        * nlmread.c: Likewise.

        * mdebugread.c (#include "gdb-stabs.h"): Removed.
        * minsyms.c: Likewise.
        * mipsread.c: Likewise.
        * nlmread.c: Likewise.

        * m2-typeprint.c (#include "obstack.h"): Removed.
        * m2-valprint.c: Likewise.

        * event-loop.c (#include <setjmp.h>): Removed.
@
text
@d50 2
d961 16
a978 1

@


1.14
log
@Update/correct copyright notices.
@
text
@a49 1
#include "gdb-stabs.h"
@


1.13
log
@	* NEWS: Document that "info symbol" works with COFF debug info and
	its variants.

	* minsyms.c (lookup_minimal_symbol_by_pc_section): Don't skip
	symbols whose SYMBOL_BFD_SECTION is NULL.
@
text
@d2 2
a3 1
   Copyright 1992, 93, 94, 96, 97, 1998 Free Software Foundation, Inc.
@


1.12
log
@Replace free() with xfree().
@
text
@d485 4
@


1.11
log
@Add code for (re)building the minimal symbol hash tables.
@
text
@d732 1
a732 1
      free ((PTR) msym_bunch);
@


1.10
log
@Protoization.
@
text
@d804 1
a804 5
	    {
	      *copyto++ = *copyfrom++;

	      add_minsym_to_hash_table (copyto - 1, objfile->msymbol_hash);
	    }
d812 32
d959 7
a965 6
	{
	  SYMBOL_INIT_DEMANGLED_NAME (msymbols, &objfile->symbol_obstack);
	  if (SYMBOL_DEMANGLED_NAME (msymbols) != NULL)
          add_minsym_to_demangled_hash_table (msymbols,
                                              objfile->msymbol_demangled_hash);
	}
d976 1
@


1.9
log
@PARAMS removal.
@
text
@d154 2
a155 4
lookup_minimal_symbol (name, sfile, objf)
     register const char *name;
     const char *sfile;
     struct objfile *objf;
d265 2
a266 4
lookup_minimal_symbol_text (name, sfile, objf)
     register const char *name;
     const char *sfile;
     struct objfile *objf;
d340 2
a341 4
lookup_minimal_symbol_solib_trampoline (name, sfile, objf)
     register const char *name;
     const char *sfile;
     struct objfile *objf;
d389 1
a389 3
lookup_minimal_symbol_by_pc_section (pc, section)
     CORE_ADDR pc;
     asection *section;
d505 1
a505 2
lookup_minimal_symbol_by_pc (pc)
     CORE_ADDR pc;
d512 2
a513 4
find_stab_function_addr (namestring, filename, objfile)
     char *namestring;
     char *filename;
     struct objfile *objfile;
d563 1
a563 2
get_symbol_leading_char (abfd)
     bfd *abfd;
d577 1
a577 1
init_minimal_symbol_collection ()
d585 3
a587 5
prim_record_minimal_symbol (name, address, ms_type, objfile)
     const char *name;
     CORE_ADDR address;
     enum minimal_symbol_type ms_type;
     struct objfile *objfile;
d618 5
a622 9
prim_record_minimal_symbol_and_info (name, address, ms_type, info, section,
				     bfd_section, objfile)
     const char *name;
     CORE_ADDR address;
     enum minimal_symbol_type ms_type;
     char *info;
     int section;
     asection *bfd_section;
     struct objfile *objfile;
d683 1
a683 3
compare_minimal_symbols (fn1p, fn2p)
     const PTR fn1p;
     const PTR fn2p;
d782 2
a783 4
compact_minimal_symbols (msymbol, mcount, objfile)
     struct minimal_symbol *msymbol;
     int mcount;
     struct objfile *objfile;
d840 1
a840 2
install_minimal_symbols (objfile)
     struct objfile *objfile;
d943 1
a943 2
msymbols_sort (objfile)
     struct objfile *objfile;
d954 1
a954 2
lookup_solib_trampoline_symbol_by_pc (pc)
     CORE_ADDR pc;
d974 1
a974 2
find_solib_trampoline_target (pc)
     CORE_ADDR pc;
@


1.8
log
@Cleanup discard_minimal_symbols cleanup.
@
text
@d78 1
a78 2
static int
compare_minimal_symbols PARAMS ((const void *, const void *));
d81 1
a81 2
compact_minimal_symbols PARAMS ((struct minimal_symbol *, int,
				 struct objfile *));
d571 1
a571 1
static int get_symbol_leading_char PARAMS ((bfd *));
@


1.7
log
@Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * objfiles.h (SECT_OFF_DATA, SECT_OFF_TEXT, SECT_OFF_BSS,
        SECT_OFF_RODATA): Define as functions of OBJFILE.  Add
        sect_index_text, sect_index_data, sect_index_rodata,
        sect_index_bss to objfile structure.
        * gdb-stabs.h (SECT_OFF_DATA, SECT_OFF_TEXT, SECT_OFF_BSS,
        SECT_OFF_RODATA): Remove.
        * objfiles.c (allocate_objfile): Initialize
        sect_index_{text,data,bss,rodata} to -1, for error detection.

        * symfile.c (default_symfile_offsets): Initialize
        sect_index_{text,data,bss,rodata} from bfd information.
        * xcoffread.c (xcoff_symfile_offsets): Ditto.
        * somread.c (som_symfile_offsets): Initialize
        sect_index_{text,data,bss,rodata}.

        * coffread.c, dbxread.c, elfread.c, hp-psymtab-read.c,
        hp-symtab-read.c, hpread.c, mdebugread.c, minsyms.c,
        mipsread.c, objfiles.c, os9kread.c, pa64solib.c, partial-stab.h,
        remote-os9k.c, remote-vx.c, remote.c, rs6000-nat.c, somsolib.c,
        stabsread.c, symfile.c, xcoffread.c:
        Update use of SECT_OFF_{TEXT,DATA,BSS,RODATA} to depend on the
        current objfile.

        * xcoffread.c: Add new field objfile to find_targ_sec_arg.
@
text
@d746 2
a747 4
/* ARGSUSED */
void
discard_minimal_symbols (foo)
     int foo;
d758 7
@


1.6
log
@* minsyms.c (prim_record_minimal_symbol_and_info): Doc fix.
(Thanks to Guy Harris.)
@
text
@d612 1
a612 1
      section = SECT_OFF_TEXT;
d616 1
a616 1
      section = SECT_OFF_DATA;
d620 1
a620 1
      section = SECT_OFF_BSS;
@


1.5
log
@Delete add_minsym_to_demangled_hash_table from symtabs.h.  Static function.
@
text
@d688 1
a688 1
     MSYMBOL_HASH_ADD will NOT add this msymbol to the hash table. */
@


1.4
log
@demangled symbol lookup fixes
@
text
@d85 3
@


1.3
log
@2000-03-06  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * minsyms.c (prim_record_minimal_symbol_and_info): Add comment.
@
text
@d126 14
d184 1
a184 1
	  int pass = 1;
d186 1
a186 3
	  msymbol = objfile->msymbol_hash[hash];
	  
	  while (msymbol != NULL && found_symbol == NULL)
d188 7
a194 1
	      if (SYMBOL_MATCHES_NAME (msymbol, name))
d196 1
a196 1
		  switch (MSYMBOL_TYPE (msymbol))
d198 5
a202 3
		    case mst_file_text:
		    case mst_file_data:
		    case mst_file_bss:
d204 2
a205 2
		      if (sfile == NULL || STREQ (msymbol->filename, sfile))
			found_file_symbol = msymbol;
d207 6
a212 6
		      /* We have neither the ability nor the need to
		         deal with the SFILE parameter.  If we find
		         more than one symbol, just return the latest
		         one (the user can't expect useful behavior in
		         that case).  */
		      found_file_symbol = msymbol;
d214 1
a214 3
		      break;

		    case mst_solib_trampoline:
d216 1
a216 7
		      /* If a trampoline symbol is found, we prefer to
		         keep looking for the *real* symbol. If the
		         actual symbol is not found, then we'll use the
		         trampoline entry. */
		      if (trampoline_symbol == NULL)
			trampoline_symbol = msymbol;
		      break;
d218 13
a230 4
		    case mst_unknown:
		    default:
		      found_symbol = msymbol;
		      break;
a231 1
		}
d233 5
a237 11
	      /* Find the next symbol on the hash chain.  At the end
		 of the first pass, try the demangled hash list.  */
	      if (pass == 1)
		msymbol = msymbol->hash_next;
	      else
		msymbol = msymbol->demangled_hash_next;
	      if (msymbol == NULL)
		{
		  ++pass;
		  if (pass == 2)
		    msymbol = objfile->msymbol_demangled_hash[dem_hash];
d951 2
a952 2
	    add_minsym_to_hash_table (msymbols,
				      objfile->msymbol_demangled_hash);
@


1.2
log
@From Tom Tromey <tromey@@cygnus.com> and Keith Seitz <?>:

* minsyms.c: #include <ctype.h>, for msymbol_hash_iw.
(compact_minimal_symbols): Added `objfile' argument.
Put symbols in the objfile's hash table.
(install_minimal_symbols): Put symbols in the objfile's demangled
hash table.
(lookup_minimal_symbol): Use hash table to find symbol in
objfile.
(msymbol_hash_iw, msymbol_hash, add_minsym_to_hash_table): New
functions.
(prim_record_minimal_symbol_and_info): Initialize the
hash link fields of the new minimal symbol.
* symtab.h (struct minimal_symbol): New fields `hash_next',
`demangled_hash_next'.
(msymbol_hash_iw, msymbol_hash, add_minsym_to_hash_table): Declare.
* objfiles.h (MINIMAL_SYMBOL_HASH_SIZE): New define.
(struct objfile): New fields `msymbol_hash',
`msymbol_demangled_hash'.
@
text
@d670 2
@


1.1
log
@Initial revision
@
text
@d5 1
a5 1
This file is part of GDB.
d7 14
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d34 1
a34 1
   
d42 1
d58 4
a61 4
{
  struct msym_bunch *next;
  struct minimal_symbol contents[BUNCH_SIZE];
};
d82 44
a125 1
compact_minimal_symbols PARAMS ((struct minimal_symbol *, int));
d150 3
d164 1
a164 1
       objfile = objfile -> next)
d168 7
a174 4
	  for (msymbol = objfile -> msymbols;
	       msymbol != NULL && SYMBOL_NAME (msymbol) != NULL &&
	       found_symbol == NULL;
	       msymbol++)
d188 4
a191 4
			 deal with the SFILE parameter.  If we find
			 more than one symbol, just return the latest
			 one (the user can't expect useful behavior in
			 that case).  */
d196 1
a196 1
                    case mst_solib_trampoline:
d199 3
a201 3
			 keep looking for the *real* symbol. If the
			 actual symbol is not found, then we'll use the
			 trampoline entry. */
d212 13
d249 2
a250 2
*/
   
d273 1
a273 1
       objfile = objfile -> next)
d277 1
a277 1
	  for (msymbol = objfile -> msymbols;
d282 1
a282 1
	      if (SYMBOL_MATCHES_NAME (msymbol, name) && 
d294 4
a297 4
			 deal with the SFILE parameter.  If we find
			 more than one symbol, just return the latest
			 one (the user can't expect useful behavior in
			 that case).  */
d326 2
a327 2
*/
   
d349 1
a349 1
       objfile = objfile -> next)
d353 1
a353 1
	  for (msymbol = objfile -> msymbols;
d358 1
a358 1
	      if (SYMBOL_MATCHES_NAME (msymbol, name) && 
d399 1
a399 1
       objfile = objfile -> next)
d402 4
a405 4
	 a binary search.  Note that a minimal symbol table always consists
	 of at least two symbols, a "real" symbol and the terminating
	 "null symbol".  If there are no real symbols, then there is no
	 minimal symbol table at all. */
d407 1
a407 1
      if ((msymbol = objfile -> msymbols) != NULL)
d410 1
a410 1
	  hi = objfile -> minimal_symbol_count - 1;
d450 3
a452 3
		 hi to point to the last one.  That way we can find the
		 right symbol if it has an index greater than hi.  */
	      while (hi < objfile -> minimal_symbol_count - 1
d454 1
a454 1
			 == SYMBOL_VALUE_ADDRESS (&msymbol[hi+1])))
d458 2
a459 2
		 objfile's minimal symbol table.  See if it is the best one
		 overall. */
d462 8
a469 8
		 and dbx do, and is needed for the CM-5.  There are two
		 known possible problems: (1) on ELF, apparently end, edata,
		 etc. are absolute.  Not sure ignoring them here is a big
		 deal, but if we want to use them, the fix would go in
		 elfread.c.  (2) I think shared library entry points on the
		 NeXT are absolute.  If we want special handling for this
		 it probably should be triggered by a special
		 mst_abs_or_lib or some such.  */
d483 1
a483 1
		      (SYMBOL_VALUE_ADDRESS (best_symbol) < 
d506 1
a506 1
find_stab_function_addr (namestring, pst, objfile)
d508 1
a508 1
     struct partial_symtab *pst;
d523 1
a523 1
  msym = lookup_minimal_symbol (p, pst->filename, objfile);
d527 2
a528 2
	 try again with an appended underscore if the minimal symbol
	 was not found.  */
d531 8
a538 1
      msym = lookup_minimal_symbol (p, pst->filename, objfile);
d540 8
d551 1
a552 1

d560 1
a560 1
     bfd * abfd;
d633 4
a636 4
	 the minimal symbols, because if there is also another symbol
	 at the same address (e.g. the first function of the file),
	 lookup_minimal_symbol_by_pc would have no way of getting the
	 right one.  */
d655 1
a655 1
      new -> next = msym_bunch;
d658 1
a658 1
  msymbol = &msym_bunch -> contents[msym_bunch_index];
d668 5
a672 1
  MSYMBOL_INFO (msymbol) = info; /* FIXME! */
d696 1
a696 1
      return (-1);	/* addr 1 is less than addr 2 */
d700 1
a700 1
      return (1);	/* addr 1 is greater than addr 2 */
d702 2
a703 1
  else			/* addrs are equal: sort by name */
d711 2
a712 2
	return 1;	/* fn1 has no name, so it is "less" */
      else if (name1)	/* fn2 has no name, so it is "less" */
d715 1
a715 1
	return (0);	/* neither has a name, so they're equal. */
d736 2
a737 2
      next = msym_bunch -> next;
      free ((PTR)msym_bunch);
d742 1
d780 1
a780 1
compact_minimal_symbols (msymbol, mcount)
d783 1
d793 1
a793 1
	  if (SYMBOL_VALUE_ADDRESS (copyfrom) == 
d797 1
a797 1
	      if (MSYMBOL_TYPE((copyfrom + 1)) == mst_unknown)
d806 2
d853 3
a855 3
	 bunches of new and existing minimal symbols, sort them, and then
	 compact out the duplicate entries.  Once we have a final table,
	 we will give back the excess space.  */
d861 1
a861 1
		 obstack_base (&objfile->symbol_obstack);
d866 2
a867 2
        memcpy ((char *)msymbols, (char *)objfile->msymbols, 
		objfile->minimal_symbol_count * sizeof (struct minimal_symbol));
d870 5
a874 5
	 to the new contiguous array of symbols.  Note that we start with the
	 current, possibly partially filled bunch (thus we use the current
	 msym_bunch_index for the first bunch we copy over), and thereafter
	 each bunch is full. */
      
d877 2
a878 2
      
      for (bunch = msym_bunch; bunch != NULL; bunch = bunch -> next)
d882 1
a882 1
	      msymbols[mcount] = bunch -> contents[bindex];
d886 1
a886 1
		  SYMBOL_NAME(&msymbols[mcount])++;
d893 1
a893 1
      
d896 1
a896 1
      
d898 3
a900 3
	 no longer using.  */
      
      mcount = compact_minimal_symbols (msymbols, mcount);
d903 1
a903 1
	(mcount + 1 - alloc_count) * sizeof (struct minimal_symbol));
d908 6
a913 6
	 which is *not* included in the size of the table.  This makes it
	 easier to find the end of the table when we are handed a pointer
	 to some symbol in the middle of it.  Zero out the fields in the
	 "null symbol" allocated at the end of the array.  Note that the
	 symbol count does *not* include this null symbol, which is why it
	 is indexed by mcount and not mcount-1. */
d922 2
a923 2
	 The strings themselves are also located in the symbol_obstack
	 of this objfile.  */
d925 2
a926 2
      objfile -> minimal_symbol_count = mcount;
      objfile -> msymbols = msymbols;
d929 1
a929 1
	 ones and attempting to cache their C++ demangled names. */
d931 1
a931 1
      for ( ; mcount-- > 0 ; msymbols++)
d934 3
d987 5
a991 5
	{
	  if (MSYMBOL_TYPE (msymbol) == mst_text
	      && STREQ (SYMBOL_NAME (msymbol), SYMBOL_NAME (tsymbol)))
	    return SYMBOL_VALUE_ADDRESS (msymbol);
	}
a994 1

@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-07-07 post reformat
@
text
@d5 1
a5 1
   This file is part of GDB.
d7 13
a19 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d33 1
a33 1

d56 4
a59 4
  {
    struct msym_bunch *next;
    struct minimal_symbol contents[BUNCH_SIZE];
  };
d116 1
a116 1
       objfile = objfile->next)
d120 1
a120 1
	  for (msymbol = objfile->msymbols;
d137 4
a140 4
		         deal with the SFILE parameter.  If we find
		         more than one symbol, just return the latest
		         one (the user can't expect useful behavior in
		         that case).  */
d145 1
a145 1
		    case mst_solib_trampoline:
d148 3
a150 3
		         keep looking for the *real* symbol. If the
		         actual symbol is not found, then we'll use the
		         trampoline entry. */
d185 2
a186 2
 */

d209 1
a209 1
       objfile = objfile->next)
d213 1
a213 1
	  for (msymbol = objfile->msymbols;
d218 1
a218 1
	      if (SYMBOL_MATCHES_NAME (msymbol, name) &&
d230 4
a233 4
		         deal with the SFILE parameter.  If we find
		         more than one symbol, just return the latest
		         one (the user can't expect useful behavior in
		         that case).  */
d262 2
a263 2
 */

d285 1
a285 1
       objfile = objfile->next)
d289 1
a289 1
	  for (msymbol = objfile->msymbols;
d294 1
a294 1
	      if (SYMBOL_MATCHES_NAME (msymbol, name) &&
d335 1
a335 1
       objfile = objfile->next)
d338 4
a341 4
         a binary search.  Note that a minimal symbol table always consists
         of at least two symbols, a "real" symbol and the terminating
         "null symbol".  If there are no real symbols, then there is no
         minimal symbol table at all. */
d343 1
a343 1
      if ((msymbol = objfile->msymbols) != NULL)
d346 1
a346 1
	  hi = objfile->minimal_symbol_count - 1;
d386 3
a388 3
	         hi to point to the last one.  That way we can find the
	         right symbol if it has an index greater than hi.  */
	      while (hi < objfile->minimal_symbol_count - 1
d390 1
a390 1
			 == SYMBOL_VALUE_ADDRESS (&msymbol[hi + 1])))
d394 2
a395 2
	         objfile's minimal symbol table.  See if it is the best one
	         overall. */
d398 8
a405 8
	         and dbx do, and is needed for the CM-5.  There are two
	         known possible problems: (1) on ELF, apparently end, edata,
	         etc. are absolute.  Not sure ignoring them here is a big
	         deal, but if we want to use them, the fix would go in
	         elfread.c.  (2) I think shared library entry points on the
	         NeXT are absolute.  If we want special handling for this
	         it probably should be triggered by a special
	         mst_abs_or_lib or some such.  */
d419 1
a419 1
		      (SYMBOL_VALUE_ADDRESS (best_symbol) <
d463 2
a464 2
         try again with an appended underscore if the minimal symbol
         was not found.  */
d472 1
a473 1

d481 1
a481 1
     bfd *abfd;
d554 4
a557 4
         the minimal symbols, because if there is also another symbol
         at the same address (e.g. the first function of the file),
         lookup_minimal_symbol_by_pc would have no way of getting the
         right one.  */
d576 1
a576 1
      new->next = msym_bunch;
d579 1
a579 1
  msymbol = &msym_bunch->contents[msym_bunch_index];
d589 1
a589 1
  MSYMBOL_INFO (msymbol) = info;	/* FIXME! */
d613 1
a613 1
      return (-1);		/* addr 1 is less than addr 2 */
d617 1
a617 1
      return (1);		/* addr 1 is greater than addr 2 */
d619 1
a619 2
  else
    /* addrs are equal: sort by name */
d627 2
a628 2
	return 1;		/* fn1 has no name, so it is "less" */
      else if (name1)		/* fn2 has no name, so it is "less" */
d631 1
a631 1
	return (0);		/* neither has a name, so they're equal. */
d652 2
a653 2
      next = msym_bunch->next;
      free ((PTR) msym_bunch);
d707 1
a707 1
	  if (SYMBOL_VALUE_ADDRESS (copyfrom) ==
d711 1
a711 1
	      if (MSYMBOL_TYPE ((copyfrom + 1)) == mst_unknown)
d765 3
a767 3
         bunches of new and existing minimal symbols, sort them, and then
         compact out the duplicate entries.  Once we have a final table,
         we will give back the excess space.  */
d773 1
a773 1
	obstack_base (&objfile->symbol_obstack);
d778 2
a779 2
	memcpy ((char *) msymbols, (char *) objfile->msymbols,
	    objfile->minimal_symbol_count * sizeof (struct minimal_symbol));
d782 5
a786 5
         to the new contiguous array of symbols.  Note that we start with the
         current, possibly partially filled bunch (thus we use the current
         msym_bunch_index for the first bunch we copy over), and thereafter
         each bunch is full. */

d789 2
a790 2

      for (bunch = msym_bunch; bunch != NULL; bunch = bunch->next)
d794 1
a794 1
	      msymbols[mcount] = bunch->contents[bindex];
d798 1
a798 1
		  SYMBOL_NAME (&msymbols[mcount])++;
d805 1
a805 1

d808 1
a808 1

d810 2
a811 2
         no longer using.  */

d815 1
a815 1
	       (mcount + 1 - alloc_count) * sizeof (struct minimal_symbol));
d820 6
a825 6
         which is *not* included in the size of the table.  This makes it
         easier to find the end of the table when we are handed a pointer
         to some symbol in the middle of it.  Zero out the fields in the
         "null symbol" allocated at the end of the array.  Note that the
         symbol count does *not* include this null symbol, which is why it
         is indexed by mcount and not mcount-1. */
d834 2
a835 2
         The strings themselves are also located in the symbol_obstack
         of this objfile.  */
d837 2
a838 2
      objfile->minimal_symbol_count = mcount;
      objfile->msymbols = msymbols;
d841 1
a841 1
         ones and attempting to cache their C++ demangled names. */
d843 1
a843 1
      for (; mcount-- > 0; msymbols++)
d896 5
a900 5
      {
	if (MSYMBOL_TYPE (msymbol) == mst_text
	    && STREQ (SYMBOL_NAME (msymbol), SYMBOL_NAME (tsymbol)))
	  return SYMBOL_VALUE_ADDRESS (msymbol);
      }
d904 1
@


1.1.1.3
log
@import gdb-1999-09-21
@
text
@d443 1
a443 1
find_stab_function_addr (namestring, filename, objfile)
d445 1
a445 1
     char *filename;
d460 1
a460 1
  msym = lookup_minimal_symbol (p, filename, objfile);
d468 1
a468 1
      msym = lookup_minimal_symbol (p, filename, objfile);
a469 15

  if (msym == NULL && filename != NULL)
    {
      /* Try again without the filename. */
      p[n] = 0;
      msym = lookup_minimal_symbol (p, 0, objfile);
    }
  if (msym == NULL && filename != NULL)
    {
      /* And try again for Sun Fortran, but without the filename. */
      p[n] = '_';
      p[n + 1] = 0;
      msym = lookup_minimal_symbol (p, 0, objfile);
    }

@


