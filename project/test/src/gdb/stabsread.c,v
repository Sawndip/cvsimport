head	1.158;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.151
	gdb_7_6-2013-04-26-release:1.151
	gdb_7_6-branch:1.151.0.2
	gdb_7_6-2013-03-12-branchpoint:1.151
	gdb_7_5_1-2012-11-29-release:1.148
	gdb_7_5-2012-08-17-release:1.148
	gdb_7_5-branch:1.148.0.2
	gdb_7_5-2012-07-18-branchpoint:1.148
	gdb_7_4_1-2012-04-26-release:1.140.2.1
	gdb_7_4-2012-01-24-release:1.140.2.1
	gdb_7_4-branch:1.140.0.2
	gdb_7_4-2011-12-13-branchpoint:1.140
	gdb_7_3_1-2011-09-04-release:1.137
	gdb_7_3-2011-07-26-release:1.137
	gdb_7_3-branch:1.137.0.2
	gdb_7_3-2011-04-01-branchpoint:1.137
	gdb_7_2-2010-09-02-release:1.129
	gdb_7_2-branch:1.129.0.2
	gdb_7_2-2010-07-07-branchpoint:1.129
	gdb_7_1-2010-03-18-release:1.123
	gdb_7_1-branch:1.123.0.2
	gdb_7_1-2010-02-18-branchpoint:1.123
	gdb_7_0_1-2009-12-22-release:1.119
	gdb_7_0-2009-10-06-release:1.119
	gdb_7_0-branch:1.119.0.4
	gdb_7_0-2009-09-16-branchpoint:1.119
	arc-sim-20090309:1.104
	msnyder-checkpoint-072509-branch:1.119.0.2
	msnyder-checkpoint-072509-branchpoint:1.119
	arc-insight_6_8-branch:1.104.0.6
	arc-insight_6_8-branchpoint:1.104
	insight_6_8-branch:1.104.0.4
	insight_6_8-branchpoint:1.104
	reverse-20081226-branch:1.111.0.6
	reverse-20081226-branchpoint:1.111
	multiprocess-20081120-branch:1.111.0.4
	multiprocess-20081120-branchpoint:1.111
	reverse-20080930-branch:1.111.0.2
	reverse-20080930-branchpoint:1.111
	reverse-20080717-branch:1.108.0.4
	reverse-20080717-branchpoint:1.108
	msnyder-reverse-20080609-branch:1.108.0.2
	msnyder-reverse-20080609-branchpoint:1.108
	drow-reverse-20070409-branch:1.88.0.2
	drow-reverse-20070409-branchpoint:1.88
	gdb_6_8-2008-03-27-release:1.104
	gdb_6_8-branch:1.104.0.2
	gdb_6_8-2008-02-26-branchpoint:1.104
	gdb_6_7_1-2007-10-29-release:1.99.2.1
	gdb_6_7-2007-10-10-release:1.99.2.1
	gdb_6_7-branch:1.99.0.2
	gdb_6_7-2007-09-07-branchpoint:1.99
	insight_6_6-20070208-release:1.84
	gdb_6_6-2006-12-18-release:1.84
	gdb_6_6-branch:1.84.0.18
	gdb_6_6-2006-11-15-branchpoint:1.84
	insight_6_5-20061003-release:1.84
	gdb-csl-symbian-6_4_50_20060226-12:1.84
	gdb-csl-sourcerygxx-3_4_4-25:1.81
	nickrob-async-20060828-mergepoint:1.84
	gdb-csl-symbian-6_4_50_20060226-11:1.84
	gdb-csl-sourcerygxx-4_1-17:1.84
	gdb-csl-20060226-branch-local-2:1.84
	gdb-csl-sourcerygxx-4_1-14:1.84
	gdb-csl-sourcerygxx-4_1-13:1.84
	gdb-csl-sourcerygxx-4_1-12:1.84
	gdb-csl-sourcerygxx-3_4_4-21:1.84
	gdb_6_5-20060621-release:1.84
	gdb-csl-sourcerygxx-4_1-9:1.84
	gdb-csl-sourcerygxx-4_1-8:1.84
	gdb-csl-sourcerygxx-4_1-7:1.84
	gdb-csl-arm-2006q1-6:1.84
	gdb-csl-sourcerygxx-4_1-6:1.84
	gdb-csl-symbian-6_4_50_20060226-10:1.84
	gdb-csl-symbian-6_4_50_20060226-9:1.84
	gdb-csl-symbian-6_4_50_20060226-8:1.84
	gdb-csl-coldfire-4_1-11:1.84
	gdb-csl-sourcerygxx-3_4_4-19:1.84
	gdb-csl-coldfire-4_1-10:1.84
	gdb_6_5-branch:1.84.0.16
	gdb_6_5-2006-05-14-branchpoint:1.84
	gdb-csl-sourcerygxx-4_1-5:1.84
	nickrob-async-20060513-branch:1.84.0.14
	nickrob-async-20060513-branchpoint:1.84
	gdb-csl-sourcerygxx-4_1-4:1.84
	msnyder-reverse-20060502-branch:1.84.0.12
	msnyder-reverse-20060502-branchpoint:1.84
	gdb-csl-morpho-4_1-4:1.84
	gdb-csl-sourcerygxx-3_4_4-17:1.84
	readline_5_1-import-branch:1.84.0.10
	readline_5_1-import-branchpoint:1.84
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.84
	gdb-csl-symbian-20060226-branch:1.84.0.8
	gdb-csl-symbian-20060226-branchpoint:1.84
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.84
	msnyder-reverse-20060331-branch:1.84.0.6
	msnyder-reverse-20060331-branchpoint:1.84
	gdb-csl-available-20060303-branch:1.84.0.4
	gdb-csl-available-20060303-branchpoint:1.84
	gdb-csl-20060226-branch:1.84.0.2
	gdb-csl-20060226-branchpoint:1.84
	gdb_6_4-20051202-release:1.81
	msnyder-fork-checkpoint-branch:1.81.0.8
	msnyder-fork-checkpoint-branchpoint:1.81
	gdb-csl-gxxpro-6_3-branch:1.81.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.81
	gdb_6_4-branch:1.81.0.4
	gdb_6_4-2005-11-01-branchpoint:1.81
	gdb-csl-arm-20051020-branch:1.81.0.2
	gdb-csl-arm-20051020-branchpoint:1.81
	msnyder-tracepoint-checkpoint-branch:1.80.0.4
	msnyder-tracepoint-checkpoint-branchpoint:1.80
	gdb-csl-arm-20050325-2005-q1b:1.80
	gdb-csl-arm-20050325-2005-q1a:1.80
	csl-arm-20050325-branch:1.80.0.2
	csl-arm-20050325-branchpoint:1.80
	gdb-post-i18n-errorwarning-20050211:1.79
	gdb-pre-i18n-errorwarning-20050211:1.78
	gdb_6_3-20041109-release:1.77
	gdb_6_3-branch:1.77.0.4
	gdb_6_3-20041019-branchpoint:1.77
	drow_intercu-merge-20040921:1.77
	drow_intercu-merge-20040915:1.77
	jimb-gdb_6_2-e500-branch:1.77.0.6
	jimb-gdb_6_2-e500-branchpoint:1.77
	gdb_6_2-20040730-release:1.77
	gdb_6_2-branch:1.77.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.77
	gdb_6_1_1-20040616-release:1.75
	gdb_6_1-2004-04-05-release:1.75
	drow_intercu-merge-20040402:1.76
	drow_intercu-merge-20040327:1.76
	ezannoni_pie-20040323-branch:1.76.0.4
	ezannoni_pie-20040323-branchpoint:1.76
	cagney_tramp-20040321-mergepoint:1.76
	cagney_tramp-20040309-branch:1.76.0.2
	cagney_tramp-20040309-branchpoint:1.76
	gdb_6_1-branch:1.75.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.75
	drow_intercu-20040221-branch:1.75.0.2
	drow_intercu-20040221-branchpoint:1.75
	cagney_bfdfile-20040213-branch:1.74.0.2
	cagney_bfdfile-20040213-branchpoint:1.74
	drow-cplus-merge-20040208:1.74
	carlton_dictionary-20040126-merge:1.72
	cagney_bigcore-20040122-branch:1.72.0.2
	cagney_bigcore-20040122-branchpoint:1.72
	drow-cplus-merge-20040113:1.70
	drow-cplus-merge-20031224:1.69
	drow-cplus-merge-20031220:1.69
	carlton_dictionary-20031215-merge:1.69
	drow-cplus-merge-20031214:1.69
	carlton-dictionary-20031111-merge:1.67
	gdb_6_0-2003-10-04-release:1.59
	kettenis_sparc-20030918-branch:1.63.0.2
	kettenis_sparc-20030918-branchpoint:1.63
	carlton_dictionary-20030917-merge:1.62
	ezannoni_pie-20030916-branchpoint:1.62
	ezannoni_pie-20030916-branch:1.62.0.2
	cagney_x86i386-20030821-branch:1.59.0.10
	cagney_x86i386-20030821-branchpoint:1.59
	carlton_dictionary-20030805-merge:1.59
	carlton_dictionary-20030627-merge:1.59
	gdb_6_0-branch:1.59.0.8
	gdb_6_0-2003-06-23-branchpoint:1.59
	jimb-ppc64-linux-20030613-branch:1.59.0.6
	jimb-ppc64-linux-20030613-branchpoint:1.59
	cagney_convert-20030606-branch:1.59.0.4
	cagney_convert-20030606-branchpoint:1.59
	cagney_writestrings-20030508-branch:1.57.0.20
	cagney_writestrings-20030508-branchpoint:1.57
	jimb-ppc64-linux-20030528-branch:1.59.0.2
	jimb-ppc64-linux-20030528-branchpoint:1.59
	carlton_dictionary-20030523-merge:1.58
	cagney_fileio-20030521-branch:1.58.0.2
	cagney_fileio-20030521-branchpoint:1.58
	kettenis_i386newframe-20030517-mergepoint:1.58
	jimb-ppc64-linux-20030509-branch:1.57.0.18
	jimb-ppc64-linux-20030509-branchpoint:1.57
	kettenis_i386newframe-20030504-mergepoint:1.57
	carlton_dictionary-20030430-merge:1.57
	kettenis_i386newframe-20030419-branch:1.57.0.16
	kettenis_i386newframe-20030419-branchpoint:1.57
	carlton_dictionary-20030416-merge:1.57
	cagney_frameaddr-20030409-mergepoint:1.57
	kettenis_i386newframe-20030406-branch:1.57.0.14
	kettenis_i386newframe-20030406-branchpoint:1.57
	cagney_frameaddr-20030403-branchpoint:1.57
	cagney_frameaddr-20030403-branch:1.57.0.12
	cagney_framebase-20030330-mergepoint:1.57
	cagney_framebase-20030326-branch:1.57.0.10
	cagney_framebase-20030326-branchpoint:1.57
	cagney_lazyid-20030317-branch:1.57.0.8
	cagney_lazyid-20030317-branchpoint:1.57
	kettenis-i386newframe-20030316-mergepoint:1.57
	offbyone-20030313-branch:1.57.0.6
	offbyone-20030313-branchpoint:1.57
	kettenis-i386newframe-20030308-branch:1.57.0.4
	kettenis-i386newframe-20030308-branchpoint:1.57
	carlton_dictionary-20030305-merge:1.57
	cagney_offbyone-20030303-branch:1.57.0.2
	cagney_offbyone-20030303-branchpoint:1.57
	carlton_dictionary-20030207-merge:1.55
	interps-20030203-mergepoint:1.54
	interps-20030202-branch:1.54.0.2
	interps-20030202-branchpoint:1.54
	cagney-unwind-20030108-branch:1.49.0.2
	cagney-unwind-20030108-branchpoint:1.49
	carlton_dictionary-20021223-merge:1.46
	gdb_5_3-2002-12-12-release:1.38
	carlton_dictionary-20021115-merge:1.45
	kseitz_interps-20021105-merge:1.45
	kseitz_interps-20021103-merge:1.45
	drow-cplus-merge-20021020:1.44
	drow-cplus-merge-20021025:1.44
	carlton_dictionary-20021025-merge:1.44
	carlton_dictionary-20021011-merge:1.42
	drow-cplus-branch:1.41.0.4
	drow-cplus-branchpoint:1.41
	kseitz_interps-20020930-merge:1.41
	carlton_dictionary-20020927-merge:1.41
	carlton_dictionary-branch:1.41.0.2
	carlton_dictionary-20020920-branchpoint:1.41
	gdb_5_3-branch:1.38.0.6
	gdb_5_3-2002-09-04-branchpoint:1.38
	kseitz_interps-20020829-merge:1.38
	cagney_sysregs-20020825-branch:1.38.0.4
	cagney_sysregs-20020825-branchpoint:1.38
	readline_4_3-import-branch:1.38.0.2
	readline_4_3-import-branchpoint:1.38
	gdb_5_2_1-2002-07-23-release:1.27
	kseitz_interps-20020528-branch:1.34.0.4
	kseitz_interps-20020528-branchpoint:1.34
	cagney_regbuf-20020515-branch:1.34.0.2
	cagney_regbuf-20020515-branchpoint:1.34
	jimb-macro-020506-branch:1.32.0.2
	jimb-macro-020506-branchpoint:1.32
	gdb_5_2-2002-04-29-release:1.27
	gdb_5_2-branch:1.27.0.2
	gdb_5_2-2002-03-03-branchpoint:1.27
	gdb_5_1_1-2002-01-24-release:1.13
	gdb_5_1_0_1-2002-01-03-release:1.13
	cygnus_cvs_20020108_pre:1.21
	gdb_5_1_0_1-2002-01-03-branchpoint:1.13
	gdb_5_1_0_1-2002-01-03-branch:1.13.0.8
	gdb_5_1-2001-11-21-release:1.13
	gdb_s390-2001-09-26-branch:1.13.0.6
	gdb_s390-2001-09-26-branchpoint:1.13
	gdb_5_1-2001-07-29-branch:1.13.0.4
	gdb_5_1-2001-07-29-branchpoint:1.13
	dberlin-typesystem-branch:1.13.0.2
	dberlin-typesystem-branchpoint:1.13
	gdb-post-ptid_t-2001-05-03:1.13
	gdb-pre-ptid_t-2001-05-03:1.13
	insight-precleanup-2001-01-01:1.10
	gdb-post-protoization-2000-07-29:1.6
	gdb-pre-protoization-2000-07-29:1.5
	gdb-premipsmulti-2000-06-06-branch:1.5.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.5
	gdb-post-params-removal-2000-06-04:1.5
	gdb-pre-params-removal-2000-06-04:1.5
	gdb-post-params-removal-2000-05-28:1.5
	gdb-pre-params-removal-2000-05-28:1.4
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.2
	repo-unification-2000-02-06:1.1.1.10
	insight-2000-02-04:1.1.1.10
	gdb-2000-02-04:1.1.1.10
	gdb-2000-02-02:1.1.1.10
	gdb-2000-02-01:1.1.1.10
	gdb-2000-01-31:1.1.1.10
	gdb-2000-01-26:1.1.1.10
	gdb-2000-01-24:1.1.1.10
	gdb-2000-01-17:1.1.1.10
	gdb-2000-01-10:1.1.1.10
	gdb-2000-01-05:1.1.1.10
	gdb-1999-12-21:1.1.1.10
	gdb-1999-12-13:1.1.1.10
	gdb-1999-12-07:1.1.1.10
	gdb-1999-12-06:1.1.1.10
	gdb-1999-11-16:1.1.1.9
	gdb-1999-11-08:1.1.1.8
	gdb-1999-11-01:1.1.1.8
	gdb-1999-10-25:1.1.1.8
	gdb-1999-10-18:1.1.1.8
	gdb-1999-10-11:1.1.1.8
	gdb-1999-10-04:1.1.1.8
	gdb-1999-09-28:1.1.1.8
	gdb-1999-09-21:1.1.1.8
	gdb-1999-09-13:1.1.1.8
	gdb-1999-09-08:1.1.1.8
	gdb-1999-08-30:1.1.1.8
	gdb-1999-08-23:1.1.1.8
	gdb-1999-08-16:1.1.1.7
	gdb-1999-08-09:1.1.1.6
	gdb-1999-08-02:1.1.1.6
	gdb-1999-07-26:1.1.1.5
	gdb-1999-07-19:1.1.1.5
	gdb-1999-07-12:1.1.1.5
	gdb-post-reformat-19990707:1.1.1.5
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.5
	gdb-pre-reformat-19990707:1.1.1.4
	gdb-1999-07-07:1.1.1.4
	gdb-1999-07-05:1.1.1.3
	gdb-1999-06-28:1.1.1.3
	gdb-1999-06-21:1.1.1.3
	gdb-1999-06-14:1.1.1.3
	gdb-1999-06-07:1.1.1.3
	gdb-1999-06-01:1.1.1.3
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.3
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.158
date	2013.09.24.13.57.37;	author jkratoch;	state Exp;
branches;
next	1.157;

1.157
date	2013.08.20.18.57.00;	author devans;	state Exp;
branches;
next	1.156;

1.156
date	2013.05.30.17.25.15;	author tromey;	state Exp;
branches;
next	1.155;

1.155
date	2013.04.08.20.18.11;	author tromey;	state Exp;
branches;
next	1.154;

1.154
date	2013.04.08.19.56.03;	author tromey;	state Exp;
branches;
next	1.153;

1.153
date	2013.04.08.19.48.30;	author tromey;	state Exp;
branches;
next	1.152;

1.152
date	2013.03.20.18.33.05;	author tromey;	state Exp;
branches;
next	1.151;

1.151
date	2013.01.21.18.13.13;	author tromey;	state Exp;
branches;
next	1.150;

1.150
date	2013.01.01.06.32.51;	author brobecke;	state Exp;
branches;
next	1.149;

1.149
date	2012.08.16.07.36.20;	author qiyao;	state Exp;
branches;
next	1.148;

1.148
date	2012.05.29.18.54.50;	author devans;	state Exp;
branches;
next	1.147;

1.147
date	2012.04.18.06.46.46;	author jkratoch;	state Exp;
branches;
next	1.146;

1.146
date	2012.04.17.13.55.32;	author palves;	state Exp;
branches;
next	1.145;

1.145
date	2012.04.17.12.43.20;	author jkratoch;	state Exp;
branches;
next	1.144;

1.144
date	2012.03.13.16.29.16;	author brobecke;	state Exp;
branches;
next	1.143;

1.143
date	2012.02.07.04.48.22;	author devans;	state Exp;
branches;
next	1.142;

1.142
date	2012.01.08.21.02.45;	author devans;	state Exp;
branches;
next	1.141;

1.141
date	2012.01.04.08.17.12;	author brobecke;	state Exp;
branches;
next	1.140;

1.140
date	2011.11.10.20.21.28;	author devans;	state Exp;
branches
	1.140.2.1;
next	1.139;

1.139
date	2011.10.20.20.06.14;	author aristovski;	state Exp;
branches;
next	1.138;

1.138
date	2011.05.18.16.30.36;	author tromey;	state Exp;
branches;
next	1.137;

1.137
date	2011.03.15.17.54.27;	author msnyder;	state Exp;
branches
	1.137.2.1;
next	1.136;

1.136
date	2011.02.28.23.32.27;	author msnyder;	state Exp;
branches;
next	1.135;

1.135
date	2011.02.26.02.07.09;	author msnyder;	state Exp;
branches;
next	1.134;

1.134
date	2011.01.11.21.53.24;	author msnyder;	state Exp;
branches;
next	1.133;

1.133
date	2011.01.05.22.22.50;	author msnyder;	state Exp;
branches;
next	1.132;

1.132
date	2011.01.01.15.33.15;	author brobecke;	state Exp;
branches;
next	1.131;

1.131
date	2010.08.09.20.13.51;	author swagiaal;	state Exp;
branches;
next	1.130;

1.130
date	2010.08.09.19.42.48;	author swagiaal;	state Exp;
branches;
next	1.129;

1.129
date	2010.05.16.23.49.58;	author msnyder;	state Exp;
branches;
next	1.128;

1.128
date	2010.05.08.04.58.45;	author jkratoch;	state Exp;
branches;
next	1.127;

1.127
date	2010.05.05.23.44.19;	author msnyder;	state Exp;
branches;
next	1.126;

1.126
date	2010.04.22.12.34.24;	author muller;	state Exp;
branches;
next	1.125;

1.125
date	2010.04.22.12.30.55;	author muller;	state Exp;
branches;
next	1.124;

1.124
date	2010.04.05.22.43.47;	author muller;	state Exp;
branches;
next	1.123;

1.123
date	2010.01.08.08.55.16;	author jkratoch;	state Exp;
branches;
next	1.122;

1.122
date	2010.01.01.07.31.42;	author brobecke;	state Exp;
branches;
next	1.121;

1.121
date	2009.11.16.18.40.22;	author tromey;	state Exp;
branches;
next	1.120;

1.120
date	2009.11.05.19.53.04;	author tromey;	state Exp;
branches;
next	1.119;

1.119
date	2009.06.29.13.19.19;	author uweigand;	state Exp;
branches;
next	1.118;

1.118
date	2009.06.29.13.18.37;	author uweigand;	state Exp;
branches;
next	1.117;

1.117
date	2009.06.04.12.28.39;	author uweigand;	state Exp;
branches;
next	1.116;

1.116
date	2009.05.01.14.43.21;	author jkratoch;	state Exp;
branches;
next	1.115;

1.115
date	2009.04.02.17.34.25;	author kseitz;	state Exp;
branches;
next	1.114;

1.114
date	2009.03.31.20.21.07;	author tromey;	state Exp;
branches;
next	1.113;

1.113
date	2009.02.21.16.14.49;	author palves;	state Exp;
branches;
next	1.112;

1.112
date	2009.01.03.05.57.53;	author brobecke;	state Exp;
branches;
next	1.111;

1.111
date	2008.08.24.16.39.57;	author tromey;	state Exp;
branches;
next	1.110;

1.110
date	2008.08.21.18.40.34;	author drow;	state Exp;
branches;
next	1.109;

1.109
date	2008.08.21.18.14.39;	author drow;	state Exp;
branches;
next	1.108;

1.108
date	2008.05.27.19.29.51;	author schwab;	state Exp;
branches;
next	1.107;

1.107
date	2008.04.19.01.33.26;	author brobecke;	state Exp;
branches;
next	1.106;

1.106
date	2008.04.08.22.09.20;	author brobecke;	state Exp;
branches;
next	1.105;

1.105
date	2008.03.26.14.53.28;	author uweigand;	state Exp;
branches;
next	1.104;

1.104
date	2008.01.01.22.53.13;	author drow;	state Exp;
branches;
next	1.103;

1.103
date	2007.12.04.23.33.00;	author uweigand;	state Exp;
branches;
next	1.102;

1.102
date	2007.10.19.12.23.20;	author uweigand;	state Exp;
branches;
next	1.101;

1.101
date	2007.10.09.09.05.53;	author palves;	state Exp;
branches;
next	1.100;

1.100
date	2007.10.08.23.06.20;	author palves;	state Exp;
branches;
next	1.99;

1.99
date	2007.09.05.00.51.48;	author drow;	state Exp;
branches
	1.99.2.1;
next	1.98;

1.98
date	2007.09.05.00.01.41;	author msnyder;	state Exp;
branches;
next	1.97;

1.97
date	2007.08.23.18.08.38;	author brobecke;	state Exp;
branches;
next	1.96;

1.96
date	2007.08.18.20.22.27;	author msnyder;	state Exp;
branches;
next	1.95;

1.95
date	2007.08.10.22.08.22;	author msnyder;	state Exp;
branches;
next	1.94;

1.94
date	2007.06.19.17.21.51;	author uweigand;	state Exp;
branches;
next	1.93;

1.93
date	2007.06.18.17.45.26;	author uweigand;	state Exp;
branches;
next	1.92;

1.92
date	2007.06.12.16.59.43;	author uweigand;	state Exp;
branches;
next	1.91;

1.91
date	2007.06.12.15.33.04;	author uweigand;	state Exp;
branches;
next	1.90;

1.90
date	2007.05.31.17.32.21;	author uweigand;	state Exp;
branches;
next	1.89;

1.89
date	2007.05.31.17.00.07;	author uweigand;	state Exp;
branches;
next	1.88;

1.88
date	2007.03.29.18.33.58;	author brobecke;	state Exp;
branches;
next	1.87;

1.87
date	2007.02.28.05.59.14;	author brobecke;	state Exp;
branches;
next	1.86;

1.86
date	2007.01.09.17.58.58;	author drow;	state Exp;
branches;
next	1.85;

1.85
date	2007.01.03.18.05.43;	author drow;	state Exp;
branches;
next	1.84;

1.84
date	2006.01.17.22.30.29;	author jimb;	state Exp;
branches;
next	1.83;

1.83
date	2006.01.15.20.26.02;	author drow;	state Exp;
branches;
next	1.82;

1.82
date	2005.12.17.22.34.02;	author eliz;	state Exp;
branches;
next	1.81;

1.81
date	2005.07.04.13.29.12;	author kettenis;	state Exp;
branches;
next	1.80;

1.80
date	2005.02.11.18.13.53;	author cagney;	state Exp;
branches;
next	1.79;

1.79
date	2005.02.11.04.06.05;	author cagney;	state Exp;
branches;
next	1.78;

1.78
date	2004.12.13.15.56.47;	author guitton;	state Exp;
branches;
next	1.77;

1.77
date	2004.04.30.14.40.54;	author cagney;	state Exp;
branches;
next	1.76;

1.76
date	2004.03.02.20.31.56;	author jimb;	state Exp;
branches;
next	1.75;

1.75
date	2004.02.18.01.09.03;	author jimb;	state Exp;
branches
	1.75.2.1;
next	1.74;

1.74
date	2004.02.07.23.13.47;	author ezannoni;	state Exp;
branches;
next	1.73;

1.73
date	2004.02.07.16.57.55;	author ezannoni;	state Exp;
branches;
next	1.72;

1.72
date	2004.01.19.01.20.11;	author cagney;	state Exp;
branches;
next	1.71;

1.71
date	2004.01.17.01.05.06;	author cagney;	state Exp;
branches;
next	1.70;

1.70
date	2004.01.05.19.53.07;	author cagney;	state Exp;
branches;
next	1.69;

1.69
date	2003.12.05.00.45.39;	author brobecke;	state Exp;
branches;
next	1.68;

1.68
date	2003.11.15.21.49.30;	author cagney;	state Exp;
branches;
next	1.67;

1.67
date	2003.11.08.00.13.02;	author cagney;	state Exp;
branches;
next	1.66;

1.66
date	2003.11.04.22.22.31;	author cagney;	state Exp;
branches;
next	1.65;

1.65
date	2003.10.06.19.27.12;	author cagney;	state Exp;
branches;
next	1.64;

1.64
date	2003.09.21.01.26.45;	author cagney;	state Exp;
branches;
next	1.63;

1.63
date	2003.09.17.19.48.42;	author kettenis;	state Exp;
branches;
next	1.62;

1.62
date	2003.09.16.18.56.35;	author cagney;	state Exp;
branches;
next	1.61;

1.61
date	2003.09.14.16.32.14;	author cagney;	state Exp;
branches;
next	1.60;

1.60
date	2003.09.13.14.12.40;	author kettenis;	state Exp;
branches;
next	1.59;

1.59
date	2003.05.26.19.35.51;	author ezannoni;	state Exp;
branches;
next	1.58;

1.58
date	2003.05.14.17.43.18;	author ezannoni;	state Exp;
branches;
next	1.57;

1.57
date	2003.02.25.21.36.19;	author carlton;	state Exp;
branches
	1.57.16.1;
next	1.56;

1.56
date	2003.02.20.17.17.24;	author carlton;	state Exp;
branches;
next	1.55;

1.55
date	2003.02.04.18.07.01;	author drow;	state Exp;
branches;
next	1.54;

1.54
date	2003.02.02.03.16.44;	author cagney;	state Exp;
branches;
next	1.53;

1.53
date	2003.02.01.20.51.05;	author cagney;	state Exp;
branches;
next	1.52;

1.52
date	2003.01.19.04.06.46;	author cagney;	state Exp;
branches;
next	1.51;

1.51
date	2003.01.14.00.15.05;	author ezannoni;	state Exp;
branches;
next	1.50;

1.50
date	2003.01.13.20.08.58;	author drow;	state Exp;
branches;
next	1.49;

1.49
date	2003.01.05.04.59.28;	author drow;	state Exp;
branches;
next	1.48;

1.48
date	2003.01.04.22.37.47;	author drow;	state Exp;
branches;
next	1.47;

1.47
date	2003.01.02.14.27.26;	author cagney;	state Exp;
branches;
next	1.46;

1.46
date	2002.12.17.00.39.08;	author kevinb;	state Exp;
branches;
next	1.45;

1.45
date	2002.10.25.22.25.55;	author cagney;	state Exp;
branches;
next	1.44;

1.44
date	2002.10.18.22.49.42;	author fedor;	state Exp;
branches;
next	1.43;

1.43
date	2002.10.16.17.36.44;	author kdienes;	state Exp;
branches;
next	1.42;

1.42
date	2002.10.11.14.02.38;	author drow;	state Exp;
branches;
next	1.41;

1.41
date	2002.09.19.03.58.41;	author cagney;	state Exp;
branches
	1.41.2.1
	1.41.4.1;
next	1.40;

1.40
date	2002.09.19.01.34.51;	author msnyder;	state Exp;
branches;
next	1.39;

1.39
date	2002.09.14.02.09.39;	author drow;	state Exp;
branches;
next	1.38;

1.38
date	2002.08.01.17.18.32;	author cagney;	state Exp;
branches;
next	1.37;

1.37
date	2002.07.29.22.55.26;	author cagney;	state Exp;
branches;
next	1.36;

1.36
date	2002.07.18.17.22.50;	author ezannoni;	state Exp;
branches;
next	1.35;

1.35
date	2002.06.14.14.34.25;	author drow;	state Exp;
branches;
next	1.34;

1.34
date	2002.05.14.18.30.51;	author drow;	state Exp;
branches
	1.34.2.1
	1.34.4.1;
next	1.33;

1.33
date	2002.05.09.18.11.17;	author msnyder;	state Exp;
branches;
next	1.32;

1.32
date	2002.05.04.00.21.09;	author jimb;	state Exp;
branches;
next	1.31;

1.31
date	2002.05.04.00.02.50;	author jimb;	state Exp;
branches;
next	1.30;

1.30
date	2002.03.21.00.53.44;	author drow;	state Exp;
branches;
next	1.29;

1.29
date	2002.03.19.20.27.04;	author schauer;	state Exp;
branches;
next	1.28;

1.28
date	2002.03.08.17.19.39;	author schauer;	state Exp;
branches;
next	1.27;

1.27
date	2002.02.20.18.40.52;	author jimb;	state Exp;
branches;
next	1.26;

1.26
date	2002.02.20.00.26.46;	author jimb;	state Exp;
branches;
next	1.25;

1.25
date	2002.02.09.20.09.45;	author jimb;	state Exp;
branches;
next	1.24;

1.24
date	2002.02.03.22.57.56;	author drow;	state Exp;
branches;
next	1.23;

1.23
date	2002.01.20.19.12.23;	author drow;	state Exp;
branches;
next	1.22;

1.22
date	2002.01.15.16.47.17;	author drow;	state Exp;
branches;
next	1.21;

1.21
date	2002.01.05.04.30.19;	author cagney;	state Exp;
branches;
next	1.20;

1.20
date	2002.01.04.19.43.09;	author ezannoni;	state Exp;
branches;
next	1.19;

1.19
date	2001.12.12.02.11.51;	author fnf;	state Exp;
branches;
next	1.18;

1.18
date	2001.12.07.23.30.13;	author drow;	state Exp;
branches;
next	1.17;

1.17
date	2001.12.07.22.11.51;	author drow;	state Exp;
branches;
next	1.16;

1.16
date	2001.09.24.17.16.53;	author cagney;	state Exp;
branches;
next	1.15;

1.15
date	2001.08.08.16.15.38;	author dhoward;	state Exp;
branches;
next	1.14;

1.14
date	2001.08.01.18.39.23;	author cagney;	state Exp;
branches;
next	1.13;

1.13
date	2001.03.24.00.42.59;	author jimb;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2001.03.21.16.42.38;	author cagney;	state Exp;
branches;
next	1.11;

1.11
date	2001.03.06.08.21.17;	author kevinb;	state Exp;
branches;
next	1.10;

1.10
date	2000.12.15.01.01.49;	author kevinb;	state Exp;
branches;
next	1.9;

1.9
date	2000.11.10.23.18.16;	author jimb;	state Exp;
branches;
next	1.8;

1.8
date	2000.10.26.16.08.20;	author ezannoni;	state Exp;
branches;
next	1.7;

1.7
date	2000.10.24.17.45.35;	author kevinb;	state Exp;
branches;
next	1.6;

1.6
date	2000.07.30.01.48.27;	author kevinb;	state Exp;
branches;
next	1.5;

1.5
date	2000.05.28.01.12.29;	author kevinb;	state Exp;
branches;
next	1.4;

1.4
date	2000.05.04.16.52.34;	author ezannoni;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.22.06.44.39;	author cagney;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.08.04.39.02;	author kingdon;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.06;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.140.2.1
date	2012.01.06.04.43.30;	author brobecke;	state Exp;
branches;
next	;

1.137.2.1
date	2011.10.25.18.32.25;	author aristovski;	state Exp;
branches;
next	;

1.99.2.1
date	2007.10.08.22.44.32;	author palves;	state Exp;
branches;
next	;

1.75.2.1
date	2004.03.27.17.37.54;	author drow;	state Exp;
branches;
next	1.75.2.2;

1.75.2.2
date	2004.09.16.17.01.22;	author drow;	state Exp;
branches;
next	;

1.57.16.1
date	2003.05.18.09.44.21;	author kettenis;	state Exp;
branches;
next	;

1.41.2.1
date	2002.10.11.22.22.56;	author carlton;	state Exp;
branches;
next	1.41.2.2;

1.41.2.2
date	2002.10.25.23.49.55;	author carlton;	state Exp;
branches;
next	1.41.2.3;

1.41.2.3
date	2002.11.15.19.18.56;	author carlton;	state Exp;
branches;
next	1.41.2.4;

1.41.2.4
date	2002.11.28.00.53.24;	author carlton;	state Exp;
branches;
next	1.41.2.5;

1.41.2.5
date	2002.12.21.00.17.43;	author carlton;	state Exp;
branches;
next	1.41.2.6;

1.41.2.6
date	2002.12.23.19.38.44;	author carlton;	state Exp;
branches;
next	1.41.2.7;

1.41.2.7
date	2003.02.07.19.17.53;	author carlton;	state Exp;
branches;
next	1.41.2.8;

1.41.2.8
date	2003.03.06.00.56.32;	author carlton;	state Exp;
branches;
next	1.41.2.9;

1.41.2.9
date	2003.03.07.22.52.55;	author carlton;	state Exp;
branches;
next	1.41.2.10;

1.41.2.10
date	2003.05.23.18.40.45;	author carlton;	state Exp;
branches;
next	1.41.2.11;

1.41.2.11
date	2003.06.27.21.50.11;	author carlton;	state Exp;
branches;
next	1.41.2.12;

1.41.2.12
date	2003.09.17.21.28.32;	author carlton;	state Exp;
branches;
next	1.41.2.13;

1.41.2.13
date	2003.11.11.23.50.57;	author carlton;	state Exp;
branches;
next	1.41.2.14;

1.41.2.14
date	2003.12.16.00.00.49;	author carlton;	state Exp;
branches;
next	1.41.2.15;

1.41.2.15
date	2004.01.26.19.11.31;	author carlton;	state Exp;
branches;
next	;

1.41.4.1
date	2002.10.06.03.11.38;	author drow;	state Exp;
branches;
next	1.41.4.2;

1.41.4.2
date	2002.10.26.17.12.09;	author drow;	state Exp;
branches;
next	1.41.4.3;

1.41.4.3
date	2003.12.14.20.27.30;	author drow;	state Exp;
branches;
next	1.41.4.4;

1.41.4.4
date	2004.01.13.16.12.01;	author drow;	state Exp;
branches;
next	1.41.4.5;

1.41.4.5
date	2004.02.09.19.43.48;	author drow;	state Exp;
branches;
next	;

1.34.2.1
date	2002.06.15.16.42.55;	author cagney;	state Exp;
branches;
next	;

1.34.4.1
date	2002.06.20.01.33.09;	author kseitz;	state Exp;
branches;
next	1.34.4.2;

1.34.4.2
date	2002.07.22.21.47.02;	author kseitz;	state Exp;
branches;
next	1.34.4.3;

1.34.4.3
date	2002.08.09.18.34.27;	author kseitz;	state Exp;
branches;
next	1.34.4.4;

1.34.4.4
date	2002.10.01.00.46.14;	author kseitz;	state Exp;
branches;
next	1.34.4.5;

1.34.4.5
date	2002.11.04.00.17.33;	author ezannoni;	state Exp;
branches;
next	;

1.13.2.1
date	2001.07.06.19.17.02;	author dberlin;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.06;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.25.23;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.05.25.18.03.24;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.07.07.17.23.18;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.07.07.20.10.15;	author jsm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.08.02.23.46.06;	author jsm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	99.08.16.19.54.02;	author jsm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	99.08.23.22.36.13;	author jsm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	99.11.17.02.30.29;	author jsm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	99.12.07.03.56.06;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.158
log
@Code cleanup: Add objfile_name accessor

gdb/
2013-09-24  Jan Kratochvil  <jan.kratochvil@@redhat.com>

	Code cleanup: Add objfile_name accessor function.
	* ada-lang.c (is_known_support_routine): Use objfile_name.
	* auto-load.c (source_gdb_script_for_objfile)
	(auto_load_objfile_script): Likewise.
	* coffread.c (coff_symtab_read, read_one_sym): Likewise.
	* dbxread.c (dbx_symfile_read): Likewise.
	* dwarf2-frame.c (dwarf2_build_frame_info): Likewise.
	* dwarf2loc.c (locexpr_describe_location_piece): Likewise.
	* dwarf2read.c (dwarf2_get_dwz_file, dwarf2_read_index)
	(dw2_symtab_iter_next, dw2_expand_symtabs_matching)
	(lookup_dwp_signatured_type, lookup_dwo_unit)
	(dwarf2_build_psymtabs_hard, scan_partial_symbols, process_queue)
	(fixup_go_packaging, process_imported_unit_die, dwarf2_physname)
	(read_import_statement, create_dwo_cu, open_and_init_dwp_file)
	(lookup_dwo_cutu, read_call_site_scope, dwarf2_ranges_read)
	(dwarf2_record_block_ranges, read_common_block, read_typedef)
	(read_subrange_type, load_partial_dies, read_partial_die)
	(read_addr_index_1, read_str_index, dwarf_decode_lines_1)
	(die_containing_type, build_error_marker_type, lookup_die_type)
	(follow_die_ref_or_sig, follow_die_ref, dwarf2_fetch_die_loc_sect_off)
	(dwarf2_fetch_constant_bytes, follow_die_sig, get_signatured_type)
	(get_DW_AT_signature_type, write_psymtabs_to_index)
	(save_gdb_index_command): Likewise.
	* elfread.c (find_separate_debug_file_by_buildid, elf_symfile_read):
	Likewise.
	* expprint.c (dump_subexp_body_standard): Likewise.
	* gdbtypes.c (type_name_no_tag_or_error): Likewise.
	* jit.c (jit_object_close_impl): Use the objfile field name renamed to
	original_name.
	* linux-thread-db.c (try_thread_db_load_from_pdir_1): New variable
	obj_name, use objfile_name for it, use the variable.
	(try_thread_db_load_from_pdir, has_libpthread, thread_db_new_objfile):
	Use objfile_name.
	* machoread.c (macho_symtab_read, macho_check_dsym)
	(macho_symfile_relocate): Likewise.
	* maint.c (maintenance_translate_address): Likewise.
	* minidebug.c (find_separate_debug_file_in_section): Likewise.
	* minsyms.c (install_minimal_symbols): Likewise.
	* objfiles.c (allocate_objfile): Use the objfile field name renamed to
	original_name.
	(filter_overlapping_sections): Use objfile_name.
	(objfile_name): New function.
	* objfiles.h (struct objfile): Rename field name to original_name.
	(objfile_name): New prototype.
	* printcmd.c (sym_info, address_info): Use objfile_name.
	* probe.c (parse_probes, collect_probes, compare_probes)
	(info_probes_for_ops): Likewise.
	* progspace.c (clone_program_space): Likewise.
	* psymtab.c (require_partial_symbols, dump_psymtab, allocate_psymtab)
	(maintenance_info_psymtabs): Likewise.
	* python/py-auto-load.c (gdbpy_load_auto_script_for_objfile)
	(source_section_scripts): Likewise.
	* python/py-objfile.c (objfpy_get_filename): Likewise.
	* python/py-progspace.c (pspy_get_filename): Likewise.
	* solib-aix.c (solib_aix_get_toc_value): Likewise.
	* solib-som.c (match_main, som_solib_section_offsets): Likewise.
	* solib.c (solib_read_symbols): Likewise.
	* stabsread.c (scan_file_globals): Likewise.
	* stap-probe.c (handle_stap_probe): Likewise.
	* symfile.c (symbol_file_clear, separate_debug_file_exists)
	(find_separate_debug_file_by_debuglink): Likewise.
	(reread_symbols): Likewise.  Use the objfile field name renamed to
	original_name.
	(allocate_symtab): Use objfile_name.
	* symmisc.c (print_symbol_bcache_statistics, print_objfile_statistics)
	(dump_objfile, dump_msymbols, dump_symtab_1)
	(maintenance_print_msymbols, maintenance_print_objfiles)
	(maintenance_info_symtabs, maintenance_check_symtabs): Likewise.
	* target.c (target_translate_tls_address, target_info): Likewise.
	* xcoffread.c (xcoff_initial_scan): Make variable name const.  Use
	objfile_name.
@
text
@/* Support routines for decoding "stabs" debugging information format.

   Copyright (C) 1986-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/* Support routines for reading and decoding debugging information in
   the "stabs" format.  This format is used with many systems that use
   the a.out object file format, as well as some systems that use
   COFF or ELF where the stabs data is placed in a special section.
   Avoid placing any object file format specific code in this file.  */

#include "defs.h"
#include "gdb_string.h"
#include "bfd.h"
#include "gdb_obstack.h"
#include "symtab.h"
#include "gdbtypes.h"
#include "expression.h"
#include "symfile.h"
#include "objfiles.h"
#include "aout/stab_gnu.h"	/* We always use GNU stabs, not native.  */
#include "libaout.h"
#include "aout/aout64.h"
#include "gdb-stabs.h"
#include "buildsym.h"
#include "complaints.h"
#include "demangle.h"
#include "gdb-demangle.h"
#include "language.h"
#include "doublest.h"
#include "cp-abi.h"
#include "cp-support.h"
#include "gdb_assert.h"

#include <ctype.h>

/* Ask stabsread.h to define the vars it normally declares `extern'.  */
#define	EXTERN
/**/
#include "stabsread.h"		/* Our own declarations */
#undef	EXTERN

extern void _initialize_stabsread (void);

/* The routines that read and process a complete stabs for a C struct or 
   C++ class pass lists of data member fields and lists of member function
   fields in an instance of a field_info structure, as defined below.
   This is part of some reorganization of low level C++ support and is
   expected to eventually go away...  (FIXME) */

struct field_info
  {
    struct nextfield
      {
	struct nextfield *next;

	/* This is the raw visibility from the stab.  It is not checked
	   for being one of the visibilities we recognize, so code which
	   examines this field better be able to deal.  */
	int visibility;

	struct field field;
      }
     *list;
    struct next_fnfieldlist
      {
	struct next_fnfieldlist *next;
	struct fn_fieldlist fn_fieldlist;
      }
     *fnlist;
  };

static void
read_one_struct_field (struct field_info *, char **, char *,
		       struct type *, struct objfile *);

static struct type *dbx_alloc_type (int[2], struct objfile *);

static long read_huge_number (char **, int, int *, int);

static struct type *error_type (char **, struct objfile *);

static void
patch_block_stabs (struct pending *, struct pending_stabs *,
		   struct objfile *);

static void fix_common_block (struct symbol *, CORE_ADDR);

static int read_type_number (char **, int *);

static struct type *read_type (char **, struct objfile *);

static struct type *read_range_type (char **, int[2], int, struct objfile *);

static struct type *read_sun_builtin_type (char **, int[2], struct objfile *);

static struct type *read_sun_floating_type (char **, int[2],
					    struct objfile *);

static struct type *read_enum_type (char **, struct type *, struct objfile *);

static struct type *rs6000_builtin_type (int, struct objfile *);

static int
read_member_functions (struct field_info *, char **, struct type *,
		       struct objfile *);

static int
read_struct_fields (struct field_info *, char **, struct type *,
		    struct objfile *);

static int
read_baseclasses (struct field_info *, char **, struct type *,
		  struct objfile *);

static int
read_tilde_fields (struct field_info *, char **, struct type *,
		   struct objfile *);

static int attach_fn_fields_to_type (struct field_info *, struct type *);

static int attach_fields_to_type (struct field_info *, struct type *,
				  struct objfile *);

static struct type *read_struct_type (char **, struct type *,
                                      enum type_code,
				      struct objfile *);

static struct type *read_array_type (char **, struct type *,
				     struct objfile *);

static struct field *read_args (char **, int, struct objfile *, int *, int *);

static void add_undefined_type (struct type *, int[2]);

static int
read_cpp_abbrev (struct field_info *, char **, struct type *,
		 struct objfile *);

static char *find_name_end (char *name);

static int process_reference (char **string);

void stabsread_clear_cache (void);

static const char vptr_name[] = "_vptr$";
static const char vb_name[] = "_vb$";

static void
invalid_cpp_abbrev_complaint (const char *arg1)
{
  complaint (&symfile_complaints, _("invalid C++ abbreviation `%s'"), arg1);
}

static void
reg_value_complaint (int regnum, int num_regs, const char *sym)
{
  complaint (&symfile_complaints,
	     _("register number %d too large (max %d) in symbol %s"),
             regnum, num_regs - 1, sym);
}

static void
stabs_general_complaint (const char *arg1)
{
  complaint (&symfile_complaints, "%s", arg1);
}

/* Make a list of forward references which haven't been defined.  */

static struct type **undef_types;
static int undef_types_allocated;
static int undef_types_length;
static struct symbol *current_symbol = NULL;

/* Make a list of nameless types that are undefined.
   This happens when another type is referenced by its number
   before this type is actually defined.  For instance "t(0,1)=k(0,2)"
   and type (0,2) is defined only later.  */

struct nat
{
  int typenums[2];
  struct type *type;
};
static struct nat *noname_undefs;
static int noname_undefs_allocated;
static int noname_undefs_length;

/* Check for and handle cretinous stabs symbol name continuation!  */
#define STABS_CONTINUE(pp,objfile)				\
  do {							\
    if (**(pp) == '\\' || (**(pp) == '?' && (*(pp))[1] == '\0')) \
      *(pp) = next_symbol_text (objfile);	\
  } while (0)

/* Vector of types defined so far, indexed by their type numbers.
   (In newer sun systems, dbx uses a pair of numbers in parens,
   as in "(SUBFILENUM,NUMWITHINSUBFILE)".
   Then these numbers must be translated through the type_translations
   hash table to get the index into the type vector.)  */

static struct type **type_vector;

/* Number of elements allocated for type_vector currently.  */

static int type_vector_length;

/* Initial size of type vector.  Is realloc'd larger if needed, and
   realloc'd down to the size actually used, when completed.  */

#define INITIAL_TYPE_VECTOR_LENGTH 160


/* Look up a dbx type-number pair.  Return the address of the slot
   where the type for that number-pair is stored.
   The number-pair is in TYPENUMS.

   This can be used for finding the type associated with that pair
   or for associating a new type with the pair.  */

static struct type **
dbx_lookup_type (int typenums[2], struct objfile *objfile)
{
  int filenum = typenums[0];
  int index = typenums[1];
  unsigned old_len;
  int real_filenum;
  struct header_file *f;
  int f_orig_length;

  if (filenum == -1)		/* -1,-1 is for temporary types.  */
    return 0;

  if (filenum < 0 || filenum >= n_this_object_header_files)
    {
      complaint (&symfile_complaints,
		 _("Invalid symbol data: type number "
		   "(%d,%d) out of range at symtab pos %d."),
		 filenum, index, symnum);
      goto error_return;
    }

  if (filenum == 0)
    {
      if (index < 0)
	{
	  /* Caller wants address of address of type.  We think
	     that negative (rs6k builtin) types will never appear as
	     "lvalues", (nor should they), so we stuff the real type
	     pointer into a temp, and return its address.  If referenced,
	     this will do the right thing.  */
	  static struct type *temp_type;

	  temp_type = rs6000_builtin_type (index, objfile);
	  return &temp_type;
	}

      /* Type is defined outside of header files.
         Find it in this object file's type vector.  */
      if (index >= type_vector_length)
	{
	  old_len = type_vector_length;
	  if (old_len == 0)
	    {
	      type_vector_length = INITIAL_TYPE_VECTOR_LENGTH;
	      type_vector = (struct type **)
		xmalloc (type_vector_length * sizeof (struct type *));
	    }
	  while (index >= type_vector_length)
	    {
	      type_vector_length *= 2;
	    }
	  type_vector = (struct type **)
	    xrealloc ((char *) type_vector,
		      (type_vector_length * sizeof (struct type *)));
	  memset (&type_vector[old_len], 0,
		  (type_vector_length - old_len) * sizeof (struct type *));
	}
      return (&type_vector[index]);
    }
  else
    {
      real_filenum = this_object_header_files[filenum];

      if (real_filenum >= N_HEADER_FILES (objfile))
	{
	  static struct type *temp_type;

	  warning (_("GDB internal error: bad real_filenum"));

	error_return:
	  temp_type = objfile_type (objfile)->builtin_error;
	  return &temp_type;
	}

      f = HEADER_FILES (objfile) + real_filenum;

      f_orig_length = f->length;
      if (index >= f_orig_length)
	{
	  while (index >= f->length)
	    {
	      f->length *= 2;
	    }
	  f->vector = (struct type **)
	    xrealloc ((char *) f->vector, f->length * sizeof (struct type *));
	  memset (&f->vector[f_orig_length], 0,
		  (f->length - f_orig_length) * sizeof (struct type *));
	}
      return (&f->vector[index]);
    }
}

/* Make sure there is a type allocated for type numbers TYPENUMS
   and return the type object.
   This can create an empty (zeroed) type object.
   TYPENUMS may be (-1, -1) to return a new type object that is not
   put into the type vector, and so may not be referred to by number.  */

static struct type *
dbx_alloc_type (int typenums[2], struct objfile *objfile)
{
  struct type **type_addr;

  if (typenums[0] == -1)
    {
      return (alloc_type (objfile));
    }

  type_addr = dbx_lookup_type (typenums, objfile);

  /* If we are referring to a type not known at all yet,
     allocate an empty type for it.
     We will fill it in later if we find out how.  */
  if (*type_addr == 0)
    {
      *type_addr = alloc_type (objfile);
    }

  return (*type_addr);
}

/* for all the stabs in a given stab vector, build appropriate types 
   and fix their symbols in given symbol vector.  */

static void
patch_block_stabs (struct pending *symbols, struct pending_stabs *stabs,
		   struct objfile *objfile)
{
  int ii;
  char *name;
  char *pp;
  struct symbol *sym;

  if (stabs)
    {
      /* for all the stab entries, find their corresponding symbols and 
         patch their types!  */

      for (ii = 0; ii < stabs->count; ++ii)
	{
	  name = stabs->stab[ii];
	  pp = (char *) strchr (name, ':');
	  gdb_assert (pp);	/* Must find a ':' or game's over.  */
	  while (pp[1] == ':')
	    {
	      pp += 2;
	      pp = (char *) strchr (pp, ':');
	    }
	  sym = find_symbol_in_list (symbols, name, pp - name);
	  if (!sym)
	    {
	      /* FIXME-maybe: it would be nice if we noticed whether
	         the variable was defined *anywhere*, not just whether
	         it is defined in this compilation unit.  But neither
	         xlc or GCC seem to need such a definition, and until
	         we do psymtabs (so that the minimal symbols from all
	         compilation units are available now), I'm not sure
	         how to get the information.  */

	      /* On xcoff, if a global is defined and never referenced,
	         ld will remove it from the executable.  There is then
	         a N_GSYM stab for it, but no regular (C_EXT) symbol.  */
	      sym = allocate_symbol (objfile);
	      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
	      SYMBOL_ACLASS_INDEX (sym) = LOC_OPTIMIZED_OUT;
	      SYMBOL_SET_LINKAGE_NAME
		(sym, obstack_copy0 (&objfile->objfile_obstack,
				     name, pp - name));
	      pp += 2;
	      if (*(pp - 1) == 'F' || *(pp - 1) == 'f')
		{
		  /* I don't think the linker does this with functions,
		     so as far as I know this is never executed.
		     But it doesn't hurt to check.  */
		  SYMBOL_TYPE (sym) =
		    lookup_function_type (read_type (&pp, objfile));
		}
	      else
		{
		  SYMBOL_TYPE (sym) = read_type (&pp, objfile);
		}
	      add_symbol_to_list (sym, &global_symbols);
	    }
	  else
	    {
	      pp += 2;
	      if (*(pp - 1) == 'F' || *(pp - 1) == 'f')
		{
		  SYMBOL_TYPE (sym) =
		    lookup_function_type (read_type (&pp, objfile));
		}
	      else
		{
		  SYMBOL_TYPE (sym) = read_type (&pp, objfile);
		}
	    }
	}
    }
}


/* Read a number by which a type is referred to in dbx data,
   or perhaps read a pair (FILENUM, TYPENUM) in parentheses.
   Just a single number N is equivalent to (0,N).
   Return the two numbers by storing them in the vector TYPENUMS.
   TYPENUMS will then be used as an argument to dbx_lookup_type.

   Returns 0 for success, -1 for error.  */

static int
read_type_number (char **pp, int *typenums)
{
  int nbits;

  if (**pp == '(')
    {
      (*pp)++;
      typenums[0] = read_huge_number (pp, ',', &nbits, 0);
      if (nbits != 0)
	return -1;
      typenums[1] = read_huge_number (pp, ')', &nbits, 0);
      if (nbits != 0)
	return -1;
    }
  else
    {
      typenums[0] = 0;
      typenums[1] = read_huge_number (pp, 0, &nbits, 0);
      if (nbits != 0)
	return -1;
    }
  return 0;
}


#define VISIBILITY_PRIVATE	'0'	/* Stabs character for private field */
#define VISIBILITY_PROTECTED	'1'	/* Stabs character for protected fld */
#define VISIBILITY_PUBLIC	'2'	/* Stabs character for public field */
#define VISIBILITY_IGNORE	'9'	/* Optimized out or zero length */

/* Structure for storing pointers to reference definitions for fast lookup 
   during "process_later".  */

struct ref_map
{
  char *stabs;
  CORE_ADDR value;
  struct symbol *sym;
};

#define MAX_CHUNK_REFS 100
#define REF_CHUNK_SIZE (MAX_CHUNK_REFS * sizeof (struct ref_map))
#define REF_MAP_SIZE(ref_chunk) ((ref_chunk) * REF_CHUNK_SIZE)

static struct ref_map *ref_map;

/* Ptr to free cell in chunk's linked list.  */
static int ref_count = 0;

/* Number of chunks malloced.  */
static int ref_chunk = 0;

/* This file maintains a cache of stabs aliases found in the symbol
   table.  If the symbol table changes, this cache must be cleared
   or we are left holding onto data in invalid obstacks.  */
void
stabsread_clear_cache (void)
{
  ref_count = 0;
  ref_chunk = 0;
}

/* Create array of pointers mapping refids to symbols and stab strings.
   Add pointers to reference definition symbols and/or their values as we 
   find them, using their reference numbers as our index.
   These will be used later when we resolve references.  */
void
ref_add (int refnum, struct symbol *sym, char *stabs, CORE_ADDR value)
{
  if (ref_count == 0)
    ref_chunk = 0;
  if (refnum >= ref_count)
    ref_count = refnum + 1;
  if (ref_count > ref_chunk * MAX_CHUNK_REFS)
    {
      int new_slots = ref_count - ref_chunk * MAX_CHUNK_REFS;
      int new_chunks = new_slots / MAX_CHUNK_REFS + 1;

      ref_map = (struct ref_map *)
	xrealloc (ref_map, REF_MAP_SIZE (ref_chunk + new_chunks));
      memset (ref_map + ref_chunk * MAX_CHUNK_REFS, 0, 
	      new_chunks * REF_CHUNK_SIZE);
      ref_chunk += new_chunks;
    }
  ref_map[refnum].stabs = stabs;
  ref_map[refnum].sym = sym;
  ref_map[refnum].value = value;
}

/* Return defined sym for the reference REFNUM.  */
struct symbol *
ref_search (int refnum)
{
  if (refnum < 0 || refnum > ref_count)
    return 0;
  return ref_map[refnum].sym;
}

/* Parse a reference id in STRING and return the resulting
   reference number.  Move STRING beyond the reference id.  */

static int
process_reference (char **string)
{
  char *p;
  int refnum = 0;

  if (**string != '#')
    return 0;

  /* Advance beyond the initial '#'.  */
  p = *string + 1;

  /* Read number as reference id.  */
  while (*p && isdigit (*p))
    {
      refnum = refnum * 10 + *p - '0';
      p++;
    }
  *string = p;
  return refnum;
}

/* If STRING defines a reference, store away a pointer to the reference 
   definition for later use.  Return the reference number.  */

int
symbol_reference_defined (char **string)
{
  char *p = *string;
  int refnum = 0;

  refnum = process_reference (&p);

  /* Defining symbols end in '='.  */
  if (*p == '=')
    {
      /* Symbol is being defined here.  */
      *string = p + 1;
      return refnum;
    }
  else
    {
      /* Must be a reference.  Either the symbol has already been defined,
         or this is a forward reference to it.  */
      *string = p;
      return -1;
    }
}

static int
stab_reg_to_regnum (struct symbol *sym, struct gdbarch *gdbarch)
{
  int regno = gdbarch_stab_reg_to_regnum (gdbarch, SYMBOL_VALUE (sym));

  if (regno >= gdbarch_num_regs (gdbarch)
		+ gdbarch_num_pseudo_regs (gdbarch))
    {
      reg_value_complaint (regno,
			   gdbarch_num_regs (gdbarch)
			     + gdbarch_num_pseudo_regs (gdbarch),
			   SYMBOL_PRINT_NAME (sym));

      regno = gdbarch_sp_regnum (gdbarch); /* Known safe, though useless.  */
    }

  return regno;
}

static const struct symbol_register_ops stab_register_funcs = {
  stab_reg_to_regnum
};

/* The "aclass" indices for computed symbols.  */

static int stab_register_index;
static int stab_regparm_index;

struct symbol *
define_symbol (CORE_ADDR valu, char *string, int desc, int type,
	       struct objfile *objfile)
{
  struct gdbarch *gdbarch = get_objfile_arch (objfile);
  struct symbol *sym;
  char *p = (char *) find_name_end (string);
  int deftype;
  int synonym = 0;
  int i;
  char *new_name = NULL;

  /* We would like to eliminate nameless symbols, but keep their types.
     E.g. stab entry ":t10=*2" should produce a type 10, which is a pointer
     to type 2, but, should not create a symbol to address that type.  Since
     the symbol will be nameless, there is no way any user can refer to it.  */

  int nameless;

  /* Ignore syms with empty names.  */
  if (string[0] == 0)
    return 0;

  /* Ignore old-style symbols from cc -go.  */
  if (p == 0)
    return 0;

  while (p[1] == ':')
    {
      p += 2;
      p = strchr (p, ':');
      if (p == NULL)
	{
	  complaint (&symfile_complaints, 
		     _("Bad stabs string '%s'"), string);
	  return NULL;
	}
    }

  /* If a nameless stab entry, all we need is the type, not the symbol.
     e.g. ":t10=*2" or a nameless enum like " :T16=ered:0,green:1,blue:2,;" */
  nameless = (p == string || ((string[0] == ' ') && (string[1] == ':')));

  current_symbol = sym = allocate_symbol (objfile);

  if (processing_gcc_compilation)
    {
      /* GCC 2.x puts the line number in desc.  SunOS apparently puts in the
         number of bytes occupied by a type or object, which we ignore.  */
      SYMBOL_LINE (sym) = desc;
    }
  else
    {
      SYMBOL_LINE (sym) = 0;	/* unknown */
    }

  if (is_cplus_marker (string[0]))
    {
      /* Special GNU C++ names.  */
      switch (string[1])
	{
	case 't':
	  SYMBOL_SET_LINKAGE_NAME (sym, "this");
	  break;

	case 'v':		/* $vtbl_ptr_type */
	  goto normal;

	case 'e':
	  SYMBOL_SET_LINKAGE_NAME (sym, "eh_throw");
	  break;

	case '_':
	  /* This was an anonymous type that was never fixed up.  */
	  goto normal;

	case 'X':
	  /* SunPRO (3.0 at least) static variable encoding.  */
	  if (gdbarch_static_transform_name_p (gdbarch))
	    goto normal;
	  /* ... fall through ...  */

	default:
	  complaint (&symfile_complaints, _("Unknown C++ symbol name `%s'"),
		     string);
	  goto normal;		/* Do *something* with it.  */
	}
    }
  else
    {
    normal:
      SYMBOL_SET_LANGUAGE (sym, current_subfile->language,
			   &objfile->objfile_obstack);
      if (SYMBOL_LANGUAGE (sym) == language_cplus)
	{
	  char *name = alloca (p - string + 1);

	  memcpy (name, string, p - string);
	  name[p - string] = '\0';
	  new_name = cp_canonicalize_string (name);
	}
      if (new_name != NULL)
	{
	  SYMBOL_SET_NAMES (sym, new_name, strlen (new_name), 1, objfile);
	  xfree (new_name);
	}
      else
	SYMBOL_SET_NAMES (sym, string, p - string, 1, objfile);

      if (SYMBOL_LANGUAGE (sym) == language_cplus)
	cp_scan_for_anonymous_namespaces (sym, objfile);

    }
  p++;

  /* Determine the type of name being defined.  */
#if 0
  /* Getting GDB to correctly skip the symbol on an undefined symbol
     descriptor and not ever dump core is a very dodgy proposition if
     we do things this way.  I say the acorn RISC machine can just
     fix their compiler.  */
  /* The Acorn RISC machine's compiler can put out locals that don't
     start with "234=" or "(3,4)=", so assume anything other than the
     deftypes we know how to handle is a local.  */
  if (!strchr ("cfFGpPrStTvVXCR", *p))
#else
  if (isdigit (*p) || *p == '(' || *p == '-')
#endif
    deftype = 'l';
  else
    deftype = *p++;

  switch (deftype)
    {
    case 'c':
      /* c is a special case, not followed by a type-number.
         SYMBOL:c=iVALUE for an integer constant symbol.
         SYMBOL:c=rVALUE for a floating constant symbol.
         SYMBOL:c=eTYPE,INTVALUE for an enum constant symbol.
         e.g. "b:c=e6,0" for "const b = blob1"
         (where type 6 is defined by "blobs:t6=eblob1:0,blob2:1,;").  */
      if (*p != '=')
	{
	  SYMBOL_ACLASS_INDEX (sym) = LOC_CONST;
	  SYMBOL_TYPE (sym) = error_type (&p, objfile);
	  SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
	  add_symbol_to_list (sym, &file_symbols);
	  return sym;
	}
      ++p;
      switch (*p++)
	{
	case 'r':
	  {
	    double d = atof (p);
	    gdb_byte *dbl_valu;
	    struct type *dbl_type;

	    /* FIXME-if-picky-about-floating-accuracy: Should be using
	       target arithmetic to get the value.  real.c in GCC
	       probably has the necessary code.  */

	    dbl_type = objfile_type (objfile)->builtin_double;
	    dbl_valu =
	      obstack_alloc (&objfile->objfile_obstack,
			     TYPE_LENGTH (dbl_type));
	    store_typed_floating (dbl_valu, dbl_type, d);

	    SYMBOL_TYPE (sym) = dbl_type;
	    SYMBOL_VALUE_BYTES (sym) = dbl_valu;
	    SYMBOL_ACLASS_INDEX (sym) = LOC_CONST_BYTES;
	  }
	  break;
	case 'i':
	  {
	    /* Defining integer constants this way is kind of silly,
	       since 'e' constants allows the compiler to give not
	       only the value, but the type as well.  C has at least
	       int, long, unsigned int, and long long as constant
	       types; other languages probably should have at least
	       unsigned as well as signed constants.  */

	    SYMBOL_TYPE (sym) = objfile_type (objfile)->builtin_long;
	    SYMBOL_VALUE (sym) = atoi (p);
	    SYMBOL_ACLASS_INDEX (sym) = LOC_CONST;
	  }
	  break;

	case 'c':
	  {
	    SYMBOL_TYPE (sym) = objfile_type (objfile)->builtin_char;
	    SYMBOL_VALUE (sym) = atoi (p);
	    SYMBOL_ACLASS_INDEX (sym) = LOC_CONST;
	  }
	  break;

	case 's':
	  {
	    struct type *range_type;
	    int ind = 0;
	    char quote = *p++;
	    gdb_byte *string_local = (gdb_byte *) alloca (strlen (p));
	    gdb_byte *string_value;

	    if (quote != '\'' && quote != '"')
	      {
		SYMBOL_ACLASS_INDEX (sym) = LOC_CONST;
		SYMBOL_TYPE (sym) = error_type (&p, objfile);
		SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
		add_symbol_to_list (sym, &file_symbols);
		return sym;
	      }

	    /* Find matching quote, rejecting escaped quotes.  */
	    while (*p && *p != quote)
	      {
		if (*p == '\\' && p[1] == quote)
		  {
		    string_local[ind] = (gdb_byte) quote;
		    ind++;
		    p += 2;
		  }
		else if (*p) 
		  {
		    string_local[ind] = (gdb_byte) (*p);
		    ind++;
		    p++;
		  }
	      }
	    if (*p != quote)
	      {
		SYMBOL_ACLASS_INDEX (sym) = LOC_CONST;
		SYMBOL_TYPE (sym) = error_type (&p, objfile);
		SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
		add_symbol_to_list (sym, &file_symbols);
		return sym;
	      }

	    /* NULL terminate the string.  */
	    string_local[ind] = 0;
	    range_type
	      = create_range_type (NULL,
				   objfile_type (objfile)->builtin_int,
				   0, ind);
	    SYMBOL_TYPE (sym) = create_array_type (NULL,
				  objfile_type (objfile)->builtin_char,
				  range_type);
	    string_value = obstack_alloc (&objfile->objfile_obstack, ind + 1);
	    memcpy (string_value, string_local, ind + 1);
	    p++;

	    SYMBOL_VALUE_BYTES (sym) = string_value;
	    SYMBOL_ACLASS_INDEX (sym) = LOC_CONST_BYTES;
	  }
	  break;

	case 'e':
	  /* SYMBOL:c=eTYPE,INTVALUE for a constant symbol whose value
	     can be represented as integral.
	     e.g. "b:c=e6,0" for "const b = blob1"
	     (where type 6 is defined by "blobs:t6=eblob1:0,blob2:1,;").  */
	  {
	    SYMBOL_ACLASS_INDEX (sym) = LOC_CONST;
	    SYMBOL_TYPE (sym) = read_type (&p, objfile);

	    if (*p != ',')
	      {
		SYMBOL_TYPE (sym) = error_type (&p, objfile);
		break;
	      }
	    ++p;

	    /* If the value is too big to fit in an int (perhaps because
	       it is unsigned), or something like that, we silently get
	       a bogus value.  The type and everything else about it is
	       correct.  Ideally, we should be using whatever we have
	       available for parsing unsigned and long long values,
	       however.  */
	    SYMBOL_VALUE (sym) = atoi (p);
	  }
	  break;
	default:
	  {
	    SYMBOL_ACLASS_INDEX (sym) = LOC_CONST;
	    SYMBOL_TYPE (sym) = error_type (&p, objfile);
	  }
	}
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
      add_symbol_to_list (sym, &file_symbols);
      return sym;

    case 'C':
      /* The name of a caught exception.  */
      SYMBOL_TYPE (sym) = read_type (&p, objfile);
      SYMBOL_ACLASS_INDEX (sym) = LOC_LABEL;
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
      SYMBOL_VALUE_ADDRESS (sym) = valu;
      add_symbol_to_list (sym, &local_symbols);
      break;

    case 'f':
      /* A static function definition.  */
      SYMBOL_TYPE (sym) = read_type (&p, objfile);
      SYMBOL_ACLASS_INDEX (sym) = LOC_BLOCK;
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
      add_symbol_to_list (sym, &file_symbols);
      /* fall into process_function_types.  */

    process_function_types:
      /* Function result types are described as the result type in stabs.
         We need to convert this to the function-returning-type-X type
         in GDB.  E.g. "int" is converted to "function returning int".  */
      if (TYPE_CODE (SYMBOL_TYPE (sym)) != TYPE_CODE_FUNC)
	SYMBOL_TYPE (sym) = lookup_function_type (SYMBOL_TYPE (sym));

      /* All functions in C++ have prototypes.  Stabs does not offer an
         explicit way to identify prototyped or unprototyped functions,
         but both GCC and Sun CC emit stabs for the "call-as" type rather
         than the "declared-as" type for unprototyped functions, so
         we treat all functions as if they were prototyped.  This is used
         primarily for promotion when calling the function from GDB.  */
      TYPE_PROTOTYPED (SYMBOL_TYPE (sym)) = 1;

      /* fall into process_prototype_types.  */

    process_prototype_types:
      /* Sun acc puts declared types of arguments here.  */
      if (*p == ';')
	{
	  struct type *ftype = SYMBOL_TYPE (sym);
	  int nsemi = 0;
	  int nparams = 0;
	  char *p1 = p;

	  /* Obtain a worst case guess for the number of arguments
	     by counting the semicolons.  */
	  while (*p1)
	    {
	      if (*p1++ == ';')
		nsemi++;
	    }

	  /* Allocate parameter information fields and fill them in.  */
	  TYPE_FIELDS (ftype) = (struct field *)
	    TYPE_ALLOC (ftype, nsemi * sizeof (struct field));
	  while (*p++ == ';')
	    {
	      struct type *ptype;

	      /* A type number of zero indicates the start of varargs.
	         FIXME: GDB currently ignores vararg functions.  */
	      if (p[0] == '0' && p[1] == '\0')
		break;
	      ptype = read_type (&p, objfile);

	      /* The Sun compilers mark integer arguments, which should
	         be promoted to the width of the calling conventions, with
	         a type which references itself.  This type is turned into
	         a TYPE_CODE_VOID type by read_type, and we have to turn
	         it back into builtin_int here.
	         FIXME: Do we need a new builtin_promoted_int_arg ?  */
	      if (TYPE_CODE (ptype) == TYPE_CODE_VOID)
		ptype = objfile_type (objfile)->builtin_int;
	      TYPE_FIELD_TYPE (ftype, nparams) = ptype;
	      TYPE_FIELD_ARTIFICIAL (ftype, nparams++) = 0;
	    }
	  TYPE_NFIELDS (ftype) = nparams;
	  TYPE_PROTOTYPED (ftype) = 1;
	}
      break;

    case 'F':
      /* A global function definition.  */
      SYMBOL_TYPE (sym) = read_type (&p, objfile);
      SYMBOL_ACLASS_INDEX (sym) = LOC_BLOCK;
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
      add_symbol_to_list (sym, &global_symbols);
      goto process_function_types;

    case 'G':
      /* For a class G (global) symbol, it appears that the
         value is not correct.  It is necessary to search for the
         corresponding linker definition to find the value.
         These definitions appear at the end of the namelist.  */
      SYMBOL_TYPE (sym) = read_type (&p, objfile);
      SYMBOL_ACLASS_INDEX (sym) = LOC_STATIC;
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
      /* Don't add symbol references to global_sym_chain.
         Symbol references don't have valid names and wont't match up with
         minimal symbols when the global_sym_chain is relocated.
         We'll fixup symbol references when we fixup the defining symbol.  */
      if (SYMBOL_LINKAGE_NAME (sym) && SYMBOL_LINKAGE_NAME (sym)[0] != '#')
	{
	  i = hashname (SYMBOL_LINKAGE_NAME (sym));
	  SYMBOL_VALUE_CHAIN (sym) = global_sym_chain[i];
	  global_sym_chain[i] = sym;
	}
      add_symbol_to_list (sym, &global_symbols);
      break;

      /* This case is faked by a conditional above,
         when there is no code letter in the dbx data.
         Dbx data never actually contains 'l'.  */
    case 's':
    case 'l':
      SYMBOL_TYPE (sym) = read_type (&p, objfile);
      SYMBOL_ACLASS_INDEX (sym) = LOC_LOCAL;
      SYMBOL_VALUE (sym) = valu;
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
      add_symbol_to_list (sym, &local_symbols);
      break;

    case 'p':
      if (*p == 'F')
	/* pF is a two-letter code that means a function parameter in Fortran.
	   The type-number specifies the type of the return value.
	   Translate it into a pointer-to-function type.  */
	{
	  p++;
	  SYMBOL_TYPE (sym)
	    = lookup_pointer_type
	    (lookup_function_type (read_type (&p, objfile)));
	}
      else
	SYMBOL_TYPE (sym) = read_type (&p, objfile);

      SYMBOL_ACLASS_INDEX (sym) = LOC_ARG;
      SYMBOL_VALUE (sym) = valu;
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
      SYMBOL_IS_ARGUMENT (sym) = 1;
      add_symbol_to_list (sym, &local_symbols);

      if (gdbarch_byte_order (gdbarch) != BFD_ENDIAN_BIG)
	{
	  /* On little-endian machines, this crud is never necessary,
	     and, if the extra bytes contain garbage, is harmful.  */
	  break;
	}

      /* If it's gcc-compiled, if it says `short', believe it.  */
      if (processing_gcc_compilation
	  || gdbarch_believe_pcc_promotion (gdbarch))
	break;

      if (!gdbarch_believe_pcc_promotion (gdbarch))
	{
	  /* If PCC says a parameter is a short or a char, it is
	     really an int.  */
	  if (TYPE_LENGTH (SYMBOL_TYPE (sym))
	      < gdbarch_int_bit (gdbarch) / TARGET_CHAR_BIT
	      && TYPE_CODE (SYMBOL_TYPE (sym)) == TYPE_CODE_INT)
	    {
	      SYMBOL_TYPE (sym) =
		TYPE_UNSIGNED (SYMBOL_TYPE (sym))
		? objfile_type (objfile)->builtin_unsigned_int
		: objfile_type (objfile)->builtin_int;
	    }
	  break;
	}

    case 'P':
      /* acc seems to use P to declare the prototypes of functions that
         are referenced by this file.  gdb is not prepared to deal
         with this extra information.  FIXME, it ought to.  */
      if (type == N_FUN)
	{
	  SYMBOL_TYPE (sym) = read_type (&p, objfile);
	  goto process_prototype_types;
	}
      /*FALLTHROUGH */

    case 'R':
      /* Parameter which is in a register.  */
      SYMBOL_TYPE (sym) = read_type (&p, objfile);
      SYMBOL_ACLASS_INDEX (sym) = stab_register_index;
      SYMBOL_IS_ARGUMENT (sym) = 1;
      SYMBOL_VALUE (sym) = valu;
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
      add_symbol_to_list (sym, &local_symbols);
      break;

    case 'r':
      /* Register variable (either global or local).  */
      SYMBOL_TYPE (sym) = read_type (&p, objfile);
      SYMBOL_ACLASS_INDEX (sym) = stab_register_index;
      SYMBOL_VALUE (sym) = valu;
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
      if (within_function)
	{
	  /* Sun cc uses a pair of symbols, one 'p' and one 'r', with
	     the same name to represent an argument passed in a
	     register.  GCC uses 'P' for the same case.  So if we find
	     such a symbol pair we combine it into one 'P' symbol.
	     For Sun cc we need to do this regardless of
	     stabs_argument_has_addr, because the compiler puts out
	     the 'p' symbol even if it never saves the argument onto
	     the stack.

	     On most machines, we want to preserve both symbols, so
	     that we can still get information about what is going on
	     with the stack (VAX for computing args_printed, using
	     stack slots instead of saved registers in backtraces,
	     etc.).

	     Note that this code illegally combines
	     main(argc) struct foo argc; { register struct foo argc; }
	     but this case is considered pathological and causes a warning
	     from a decent compiler.  */

	  if (local_symbols
	      && local_symbols->nsyms > 0
	      && gdbarch_stabs_argument_has_addr (gdbarch, SYMBOL_TYPE (sym)))
	    {
	      struct symbol *prev_sym;

	      prev_sym = local_symbols->symbol[local_symbols->nsyms - 1];
	      if ((SYMBOL_CLASS (prev_sym) == LOC_REF_ARG
		   || SYMBOL_CLASS (prev_sym) == LOC_ARG)
		  && strcmp (SYMBOL_LINKAGE_NAME (prev_sym),
			     SYMBOL_LINKAGE_NAME (sym)) == 0)
		{
		  SYMBOL_ACLASS_INDEX (prev_sym) = stab_register_index;
		  /* Use the type from the LOC_REGISTER; that is the type
		     that is actually in that register.  */
		  SYMBOL_TYPE (prev_sym) = SYMBOL_TYPE (sym);
		  SYMBOL_VALUE (prev_sym) = SYMBOL_VALUE (sym);
		  sym = prev_sym;
		  break;
		}
	    }
	  add_symbol_to_list (sym, &local_symbols);
	}
      else
	add_symbol_to_list (sym, &file_symbols);
      break;

    case 'S':
      /* Static symbol at top level of file.  */
      SYMBOL_TYPE (sym) = read_type (&p, objfile);
      SYMBOL_ACLASS_INDEX (sym) = LOC_STATIC;
      SYMBOL_VALUE_ADDRESS (sym) = valu;
      if (gdbarch_static_transform_name_p (gdbarch)
	  && gdbarch_static_transform_name (gdbarch,
					    SYMBOL_LINKAGE_NAME (sym))
	     != SYMBOL_LINKAGE_NAME (sym))
	{
	  struct minimal_symbol *msym;

	  msym = lookup_minimal_symbol (SYMBOL_LINKAGE_NAME (sym),
					NULL, objfile);
	  if (msym != NULL)
	    {
	      const char *new_name = gdbarch_static_transform_name
		(gdbarch, SYMBOL_LINKAGE_NAME (sym));

	      SYMBOL_SET_LINKAGE_NAME (sym, new_name);
	      SYMBOL_VALUE_ADDRESS (sym) = SYMBOL_VALUE_ADDRESS (msym);
	    }
	}
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
      add_symbol_to_list (sym, &file_symbols);
      break;

    case 't':
      /* In Ada, there is no distinction between typedef and non-typedef;
         any type declaration implicitly has the equivalent of a typedef,
         and thus 't' is in fact equivalent to 'Tt'.

         Therefore, for Ada units, we check the character immediately
         before the 't', and if we do not find a 'T', then make sure to
         create the associated symbol in the STRUCT_DOMAIN ('t' definitions
         will be stored in the VAR_DOMAIN).  If the symbol was indeed
         defined as 'Tt' then the STRUCT_DOMAIN symbol will be created
         elsewhere, so we don't need to take care of that.
         
         This is important to do, because of forward references:
         The cleanup of undefined types stored in undef_types only uses
         STRUCT_DOMAIN symbols to perform the replacement.  */
      synonym = (SYMBOL_LANGUAGE (sym) == language_ada && p[-2] != 'T');

      /* Typedef */
      SYMBOL_TYPE (sym) = read_type (&p, objfile);

      /* For a nameless type, we don't want a create a symbol, thus we
         did not use `sym'.  Return without further processing.  */
      if (nameless)
	return NULL;

      SYMBOL_ACLASS_INDEX (sym) = LOC_TYPEDEF;
      SYMBOL_VALUE (sym) = valu;
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
      /* C++ vagaries: we may have a type which is derived from
         a base type which did not have its name defined when the
         derived class was output.  We fill in the derived class's
         base part member's name here in that case.  */
      if (TYPE_NAME (SYMBOL_TYPE (sym)) != NULL)
	if ((TYPE_CODE (SYMBOL_TYPE (sym)) == TYPE_CODE_STRUCT
	     || TYPE_CODE (SYMBOL_TYPE (sym)) == TYPE_CODE_UNION)
	    && TYPE_N_BASECLASSES (SYMBOL_TYPE (sym)))
	  {
	    int j;

	    for (j = TYPE_N_BASECLASSES (SYMBOL_TYPE (sym)) - 1; j >= 0; j--)
	      if (TYPE_BASECLASS_NAME (SYMBOL_TYPE (sym), j) == 0)
		TYPE_BASECLASS_NAME (SYMBOL_TYPE (sym), j) =
		  type_name_no_tag (TYPE_BASECLASS (SYMBOL_TYPE (sym), j));
	  }

      if (TYPE_NAME (SYMBOL_TYPE (sym)) == NULL)
	{
	  /* gcc-2.6 or later (when using -fvtable-thunks)
	     emits a unique named type for a vtable entry.
	     Some gdb code depends on that specific name.  */
	  extern const char vtbl_ptr_name[];

	  if ((TYPE_CODE (SYMBOL_TYPE (sym)) == TYPE_CODE_PTR
	       && strcmp (SYMBOL_LINKAGE_NAME (sym), vtbl_ptr_name))
	      || TYPE_CODE (SYMBOL_TYPE (sym)) == TYPE_CODE_FUNC)
	    {
	      /* If we are giving a name to a type such as "pointer to
	         foo" or "function returning foo", we better not set
	         the TYPE_NAME.  If the program contains "typedef char
	         *caddr_t;", we don't want all variables of type char
	         * to print as caddr_t.  This is not just a
	         consequence of GDB's type management; PCC and GCC (at
	         least through version 2.4) both output variables of
	         either type char * or caddr_t with the type number
	         defined in the 't' symbol for caddr_t.  If a future
	         compiler cleans this up it GDB is not ready for it
	         yet, but if it becomes ready we somehow need to
	         disable this check (without breaking the PCC/GCC2.4
	         case).

	         Sigh.

	         Fortunately, this check seems not to be necessary
	         for anything except pointers or functions.  */
              /* ezannoni: 2000-10-26.  This seems to apply for
		 versions of gcc older than 2.8.  This was the original
		 problem: with the following code gdb would tell that
		 the type for name1 is caddr_t, and func is char().

	         typedef char *caddr_t;
		 char *name2;
		 struct x
		 {
		   char *name1;
		 } xx;
		 char *func()
		 {
		 }
		 main () {}
		 */

	      /* Pascal accepts names for pointer types.  */
	      if (current_subfile->language == language_pascal)
		{
		  TYPE_NAME (SYMBOL_TYPE (sym)) = SYMBOL_LINKAGE_NAME (sym);
          	}
	    }
	  else
	    TYPE_NAME (SYMBOL_TYPE (sym)) = SYMBOL_LINKAGE_NAME (sym);
	}

      add_symbol_to_list (sym, &file_symbols);

      if (synonym)
        {
          /* Create the STRUCT_DOMAIN clone.  */
          struct symbol *struct_sym = allocate_symbol (objfile);

          *struct_sym = *sym;
          SYMBOL_ACLASS_INDEX (struct_sym) = LOC_TYPEDEF;
          SYMBOL_VALUE (struct_sym) = valu;
          SYMBOL_DOMAIN (struct_sym) = STRUCT_DOMAIN;
          if (TYPE_NAME (SYMBOL_TYPE (sym)) == 0)
            TYPE_NAME (SYMBOL_TYPE (sym))
	      = obconcat (&objfile->objfile_obstack,
			  SYMBOL_LINKAGE_NAME (sym),
			  (char *) NULL);
          add_symbol_to_list (struct_sym, &file_symbols);
        }
      
      break;

    case 'T':
      /* Struct, union, or enum tag.  For GNU C++, this can be be followed
         by 't' which means we are typedef'ing it as well.  */
      synonym = *p == 't';

      if (synonym)
	p++;

      SYMBOL_TYPE (sym) = read_type (&p, objfile);
 
      /* For a nameless type, we don't want a create a symbol, thus we
         did not use `sym'.  Return without further processing.  */
      if (nameless)
	return NULL;

      SYMBOL_ACLASS_INDEX (sym) = LOC_TYPEDEF;
      SYMBOL_VALUE (sym) = valu;
      SYMBOL_DOMAIN (sym) = STRUCT_DOMAIN;
      if (TYPE_TAG_NAME (SYMBOL_TYPE (sym)) == 0)
	TYPE_TAG_NAME (SYMBOL_TYPE (sym))
	  = obconcat (&objfile->objfile_obstack,
		      SYMBOL_LINKAGE_NAME (sym),
		      (char *) NULL);
      add_symbol_to_list (sym, &file_symbols);

      if (synonym)
	{
	  /* Clone the sym and then modify it.  */
	  struct symbol *typedef_sym = allocate_symbol (objfile);

	  *typedef_sym = *sym;
	  SYMBOL_ACLASS_INDEX (typedef_sym) = LOC_TYPEDEF;
	  SYMBOL_VALUE (typedef_sym) = valu;
	  SYMBOL_DOMAIN (typedef_sym) = VAR_DOMAIN;
	  if (TYPE_NAME (SYMBOL_TYPE (sym)) == 0)
	    TYPE_NAME (SYMBOL_TYPE (sym))
	      = obconcat (&objfile->objfile_obstack,
			  SYMBOL_LINKAGE_NAME (sym),
			  (char *) NULL);
	  add_symbol_to_list (typedef_sym, &file_symbols);
	}
      break;

    case 'V':
      /* Static symbol of local scope.  */
      SYMBOL_TYPE (sym) = read_type (&p, objfile);
      SYMBOL_ACLASS_INDEX (sym) = LOC_STATIC;
      SYMBOL_VALUE_ADDRESS (sym) = valu;
      if (gdbarch_static_transform_name_p (gdbarch)
	  && gdbarch_static_transform_name (gdbarch,
					    SYMBOL_LINKAGE_NAME (sym))
	     != SYMBOL_LINKAGE_NAME (sym))
	{
	  struct minimal_symbol *msym;

	  msym = lookup_minimal_symbol (SYMBOL_LINKAGE_NAME (sym), 
					NULL, objfile);
	  if (msym != NULL)
	    {
	      const char *new_name = gdbarch_static_transform_name
		(gdbarch, SYMBOL_LINKAGE_NAME (sym));

	      SYMBOL_SET_LINKAGE_NAME (sym, new_name);
	      SYMBOL_VALUE_ADDRESS (sym) = SYMBOL_VALUE_ADDRESS (msym);
	    }
	}
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
	add_symbol_to_list (sym, &local_symbols);
      break;

    case 'v':
      /* Reference parameter */
      SYMBOL_TYPE (sym) = read_type (&p, objfile);
      SYMBOL_ACLASS_INDEX (sym) = LOC_REF_ARG;
      SYMBOL_IS_ARGUMENT (sym) = 1;
      SYMBOL_VALUE (sym) = valu;
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
      add_symbol_to_list (sym, &local_symbols);
      break;

    case 'a':
      /* Reference parameter which is in a register.  */
      SYMBOL_TYPE (sym) = read_type (&p, objfile);
      SYMBOL_ACLASS_INDEX (sym) = stab_regparm_index;
      SYMBOL_IS_ARGUMENT (sym) = 1;
      SYMBOL_VALUE (sym) = valu;
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
      add_symbol_to_list (sym, &local_symbols);
      break;

    case 'X':
      /* This is used by Sun FORTRAN for "function result value".
         Sun claims ("dbx and dbxtool interfaces", 2nd ed)
         that Pascal uses it too, but when I tried it Pascal used
         "x:3" (local symbol) instead.  */
      SYMBOL_TYPE (sym) = read_type (&p, objfile);
      SYMBOL_ACLASS_INDEX (sym) = LOC_LOCAL;
      SYMBOL_VALUE (sym) = valu;
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
      add_symbol_to_list (sym, &local_symbols);
      break;

    default:
      SYMBOL_TYPE (sym) = error_type (&p, objfile);
      SYMBOL_ACLASS_INDEX (sym) = LOC_CONST;
      SYMBOL_VALUE (sym) = 0;
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
      add_symbol_to_list (sym, &file_symbols);
      break;
    }

  /* Some systems pass variables of certain types by reference instead
     of by value, i.e. they will pass the address of a structure (in a
     register or on the stack) instead of the structure itself.  */

  if (gdbarch_stabs_argument_has_addr (gdbarch, SYMBOL_TYPE (sym))
      && SYMBOL_IS_ARGUMENT (sym))
    {
      /* We have to convert LOC_REGISTER to LOC_REGPARM_ADDR (for
         variables passed in a register).  */
      if (SYMBOL_CLASS (sym) == LOC_REGISTER)
	SYMBOL_ACLASS_INDEX (sym) = LOC_REGPARM_ADDR;
      /* Likewise for converting LOC_ARG to LOC_REF_ARG (for the 7th
	 and subsequent arguments on SPARC, for example).  */
      else if (SYMBOL_CLASS (sym) == LOC_ARG)
	SYMBOL_ACLASS_INDEX (sym) = LOC_REF_ARG;
    }

  return sym;
}

/* Skip rest of this symbol and return an error type.

   General notes on error recovery:  error_type always skips to the
   end of the symbol (modulo cretinous dbx symbol name continuation).
   Thus code like this:

   if (*(*pp)++ != ';')
   return error_type (pp, objfile);

   is wrong because if *pp starts out pointing at '\0' (typically as the
   result of an earlier error), it will be incremented to point to the
   start of the next symbol, which might produce strange results, at least
   if you run off the end of the string table.  Instead use

   if (**pp != ';')
   return error_type (pp, objfile);
   ++*pp;

   or

   if (**pp != ';')
   foo = error_type (pp, objfile);
   else
   ++*pp;

   And in case it isn't obvious, the point of all this hair is so the compiler
   can define new types and new syntaxes, and old versions of the
   debugger will be able to read the new symbol tables.  */

static struct type *
error_type (char **pp, struct objfile *objfile)
{
  complaint (&symfile_complaints,
	     _("couldn't parse type; debugger out of date?"));
  while (1)
    {
      /* Skip to end of symbol.  */
      while (**pp != '\0')
	{
	  (*pp)++;
	}

      /* Check for and handle cretinous dbx symbol name continuation!  */
      if ((*pp)[-1] == '\\' || (*pp)[-1] == '?')
	{
	  *pp = next_symbol_text (objfile);
	}
      else
	{
	  break;
	}
    }
  return objfile_type (objfile)->builtin_error;
}


/* Read type information or a type definition; return the type.  Even
   though this routine accepts either type information or a type
   definition, the distinction is relevant--some parts of stabsread.c
   assume that type information starts with a digit, '-', or '(' in
   deciding whether to call read_type.  */

static struct type *
read_type (char **pp, struct objfile *objfile)
{
  struct type *type = 0;
  struct type *type1;
  int typenums[2];
  char type_descriptor;

  /* Size in bits of type if specified by a type attribute, or -1 if
     there is no size attribute.  */
  int type_size = -1;

  /* Used to distinguish string and bitstring from char-array and set.  */
  int is_string = 0;

  /* Used to distinguish vector from array.  */
  int is_vector = 0;

  /* Read type number if present.  The type number may be omitted.
     for instance in a two-dimensional array declared with type
     "ar1;1;10;ar1;1;10;4".  */
  if ((**pp >= '0' && **pp <= '9')
      || **pp == '('
      || **pp == '-')
    {
      if (read_type_number (pp, typenums) != 0)
	return error_type (pp, objfile);

      if (**pp != '=')
        {
          /* Type is not being defined here.  Either it already
             exists, or this is a forward reference to it.
             dbx_alloc_type handles both cases.  */
          type = dbx_alloc_type (typenums, objfile);

          /* If this is a forward reference, arrange to complain if it
             doesn't get patched up by the time we're done
             reading.  */
          if (TYPE_CODE (type) == TYPE_CODE_UNDEF)
            add_undefined_type (type, typenums);

          return type;
        }

      /* Type is being defined here.  */
      /* Skip the '='.
         Also skip the type descriptor - we get it below with (*pp)[-1].  */
      (*pp) += 2;
    }
  else
    {
      /* 'typenums=' not present, type is anonymous.  Read and return
         the definition, but don't put it in the type vector.  */
      typenums[0] = typenums[1] = -1;
      (*pp)++;
    }

again:
  type_descriptor = (*pp)[-1];
  switch (type_descriptor)
    {
    case 'x':
      {
	enum type_code code;

	/* Used to index through file_symbols.  */
	struct pending *ppt;
	int i;

	/* Name including "struct", etc.  */
	char *type_name;

	{
	  char *from, *to, *p, *q1, *q2;

	  /* Set the type code according to the following letter.  */
	  switch ((*pp)[0])
	    {
	    case 's':
	      code = TYPE_CODE_STRUCT;
	      break;
	    case 'u':
	      code = TYPE_CODE_UNION;
	      break;
	    case 'e':
	      code = TYPE_CODE_ENUM;
	      break;
	    default:
	      {
		/* Complain and keep going, so compilers can invent new
		   cross-reference types.  */
		complaint (&symfile_complaints,
			   _("Unrecognized cross-reference type `%c'"),
			   (*pp)[0]);
		code = TYPE_CODE_STRUCT;
		break;
	      }
	    }

	  q1 = strchr (*pp, '<');
	  p = strchr (*pp, ':');
	  if (p == NULL)
	    return error_type (pp, objfile);
	  if (q1 && p > q1 && p[1] == ':')
	    {
	      int nesting_level = 0;

	      for (q2 = q1; *q2; q2++)
		{
		  if (*q2 == '<')
		    nesting_level++;
		  else if (*q2 == '>')
		    nesting_level--;
		  else if (*q2 == ':' && nesting_level == 0)
		    break;
		}
	      p = q2;
	      if (*p != ':')
		return error_type (pp, objfile);
	    }
	  type_name = NULL;
	  if (current_subfile->language == language_cplus)
	    {
	      char *new_name, *name = alloca (p - *pp + 1);

	      memcpy (name, *pp, p - *pp);
	      name[p - *pp] = '\0';
	      new_name = cp_canonicalize_string (name);
	      if (new_name != NULL)
		{
		  type_name = obstack_copy0 (&objfile->objfile_obstack,
					     new_name, strlen (new_name));
		  xfree (new_name);
		}
	    }
	  if (type_name == NULL)
	    {
	      to = type_name = (char *)
		obstack_alloc (&objfile->objfile_obstack, p - *pp + 1);

	      /* Copy the name.  */
	      from = *pp + 1;
	      while (from < p)
		*to++ = *from++;
	      *to = '\0';
	    }

	  /* Set the pointer ahead of the name which we just read, and
	     the colon.  */
	  *pp = p + 1;
	}

        /* If this type has already been declared, then reuse the same
           type, rather than allocating a new one.  This saves some
           memory.  */

	for (ppt = file_symbols; ppt; ppt = ppt->next)
	  for (i = 0; i < ppt->nsyms; i++)
	    {
	      struct symbol *sym = ppt->symbol[i];

	      if (SYMBOL_CLASS (sym) == LOC_TYPEDEF
		  && SYMBOL_DOMAIN (sym) == STRUCT_DOMAIN
		  && (TYPE_CODE (SYMBOL_TYPE (sym)) == code)
		  && strcmp (SYMBOL_LINKAGE_NAME (sym), type_name) == 0)
		{
		  obstack_free (&objfile->objfile_obstack, type_name);
		  type = SYMBOL_TYPE (sym);
	          if (typenums[0] != -1)
	            *dbx_lookup_type (typenums, objfile) = type;
		  return type;
		}
	    }

	/* Didn't find the type to which this refers, so we must
	   be dealing with a forward reference.  Allocate a type
	   structure for it, and keep track of it so we can
	   fill in the rest of the fields when we get the full
	   type.  */
	type = dbx_alloc_type (typenums, objfile);
	TYPE_CODE (type) = code;
	TYPE_TAG_NAME (type) = type_name;
	INIT_CPLUS_SPECIFIC (type);
	TYPE_STUB (type) = 1;

	add_undefined_type (type, typenums);
	return type;
      }

    case '-':			/* RS/6000 built-in type */
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
    case '(':
      (*pp)--;

      /* We deal with something like t(1,2)=(3,4)=... which
         the Lucid compiler and recent gcc versions (post 2.7.3) use.  */

      /* Allocate and enter the typedef type first.
         This handles recursive types.  */
      type = dbx_alloc_type (typenums, objfile);
      TYPE_CODE (type) = TYPE_CODE_TYPEDEF;
      {
	struct type *xtype = read_type (pp, objfile);

	if (type == xtype)
	  {
	    /* It's being defined as itself.  That means it is "void".  */
	    TYPE_CODE (type) = TYPE_CODE_VOID;
	    TYPE_LENGTH (type) = 1;
	  }
	else if (type_size >= 0 || is_string)
	  {
	    /* This is the absolute wrong way to construct types.  Every
	       other debug format has found a way around this problem and
	       the related problems with unnecessarily stubbed types;
	       someone motivated should attempt to clean up the issue
	       here as well.  Once a type pointed to has been created it
	       should not be modified.

               Well, it's not *absolutely* wrong.  Constructing recursive
               types (trees, linked lists) necessarily entails modifying
               types after creating them.  Constructing any loop structure
               entails side effects.  The Dwarf 2 reader does handle this
               more gracefully (it never constructs more than once
               instance of a type object, so it doesn't have to copy type
               objects wholesale), but it still mutates type objects after
               other folks have references to them.

               Keep in mind that this circularity/mutation issue shows up
               at the source language level, too: C's "incomplete types",
               for example.  So the proper cleanup, I think, would be to
               limit GDB's type smashing to match exactly those required
               by the source language.  So GDB could have a
               "complete_this_type" function, but never create unnecessary
               copies of a type otherwise.  */
	    replace_type (type, xtype);
	    TYPE_NAME (type) = NULL;
	    TYPE_TAG_NAME (type) = NULL;
	  }
	else
	  {
	    TYPE_TARGET_STUB (type) = 1;
	    TYPE_TARGET_TYPE (type) = xtype;
	  }
      }
      break;

      /* In the following types, we must be sure to overwrite any existing
         type that the typenums refer to, rather than allocating a new one
         and making the typenums point to the new one.  This is because there
         may already be pointers to the existing type (if it had been
         forward-referenced), and we must change it to a pointer, function,
         reference, or whatever, *in-place*.  */

    case '*':			/* Pointer to another type */
      type1 = read_type (pp, objfile);
      type = make_pointer_type (type1, dbx_lookup_type (typenums, objfile));
      break;

    case '&':			/* Reference to another type */
      type1 = read_type (pp, objfile);
      type = make_reference_type (type1, dbx_lookup_type (typenums, objfile));
      break;

    case 'f':			/* Function returning another type */
      type1 = read_type (pp, objfile);
      type = make_function_type (type1, dbx_lookup_type (typenums, objfile));
      break;

    case 'g':                   /* Prototyped function.  (Sun)  */
      {
        /* Unresolved questions:

           - According to Sun's ``STABS Interface Manual'', for 'f'
           and 'F' symbol descriptors, a `0' in the argument type list
           indicates a varargs function.  But it doesn't say how 'g'
           type descriptors represent that info.  Someone with access
           to Sun's toolchain should try it out.

           - According to the comment in define_symbol (search for
           `process_prototype_types:'), Sun emits integer arguments as
           types which ref themselves --- like `void' types.  Do we
           have to deal with that here, too?  Again, someone with
           access to Sun's toolchain should try it out and let us
           know.  */

        const char *type_start = (*pp) - 1;
        struct type *return_type = read_type (pp, objfile);
        struct type *func_type
          = make_function_type (return_type,
				dbx_lookup_type (typenums, objfile));
        struct type_list {
          struct type *type;
          struct type_list *next;
        } *arg_types = 0;
        int num_args = 0;

        while (**pp && **pp != '#')
          {
            struct type *arg_type = read_type (pp, objfile);
            struct type_list *new = alloca (sizeof (*new));
            new->type = arg_type;
            new->next = arg_types;
            arg_types = new;
            num_args++;
          }
        if (**pp == '#')
          ++*pp;
        else
          {
	    complaint (&symfile_complaints,
		       _("Prototyped function type didn't "
			 "end arguments with `#':\n%s"),
		       type_start);
          }

        /* If there is just one argument whose type is `void', then
           that's just an empty argument list.  */
        if (arg_types
            && ! arg_types->next
            && TYPE_CODE (arg_types->type) == TYPE_CODE_VOID)
          num_args = 0;

        TYPE_FIELDS (func_type)
          = (struct field *) TYPE_ALLOC (func_type,
                                         num_args * sizeof (struct field));
        memset (TYPE_FIELDS (func_type), 0, num_args * sizeof (struct field));
        {
          int i;
          struct type_list *t;

          /* We stuck each argument type onto the front of the list
             when we read it, so the list is reversed.  Build the
             fields array right-to-left.  */
          for (t = arg_types, i = num_args - 1; t; t = t->next, i--)
            TYPE_FIELD_TYPE (func_type, i) = t->type;
        }
        TYPE_NFIELDS (func_type) = num_args;
        TYPE_PROTOTYPED (func_type) = 1;

        type = func_type;
        break;
      }

    case 'k':			/* Const qualifier on some type (Sun) */
      type = read_type (pp, objfile);
      type = make_cv_type (1, TYPE_VOLATILE (type), type,
			   dbx_lookup_type (typenums, objfile));
      break;

    case 'B':			/* Volatile qual on some type (Sun) */
      type = read_type (pp, objfile);
      type = make_cv_type (TYPE_CONST (type), 1, type,
			   dbx_lookup_type (typenums, objfile));
      break;

    case '@@':
      if (isdigit (**pp) || **pp == '(' || **pp == '-')
	{			/* Member (class & variable) type */
	  /* FIXME -- we should be doing smash_to_XXX types here.  */

	  struct type *domain = read_type (pp, objfile);
	  struct type *memtype;

	  if (**pp != ',')
	    /* Invalid member type data format.  */
	    return error_type (pp, objfile);
	  ++*pp;

	  memtype = read_type (pp, objfile);
	  type = dbx_alloc_type (typenums, objfile);
	  smash_to_memberptr_type (type, domain, memtype);
	}
      else
	/* type attribute */
	{
	  char *attr = *pp;

	  /* Skip to the semicolon.  */
	  while (**pp != ';' && **pp != '\0')
	    ++(*pp);
	  if (**pp == '\0')
	    return error_type (pp, objfile);
	  else
	    ++ * pp;		/* Skip the semicolon.  */

	  switch (*attr)
	    {
	    case 's':		/* Size attribute */
	      type_size = atoi (attr + 1);
	      if (type_size <= 0)
		type_size = -1;
	      break;

	    case 'S':		/* String attribute */
	      /* FIXME: check to see if following type is array?  */
	      is_string = 1;
	      break;

	    case 'V':		/* Vector attribute */
	      /* FIXME: check to see if following type is array?  */
	      is_vector = 1;
	      break;

	    default:
	      /* Ignore unrecognized type attributes, so future compilers
	         can invent new ones.  */
	      break;
	    }
	  ++*pp;
	  goto again;
	}
      break;

    case '#':			/* Method (class & fn) type */
      if ((*pp)[0] == '#')
	{
	  /* We'll get the parameter types from the name.  */
	  struct type *return_type;

	  (*pp)++;
	  return_type = read_type (pp, objfile);
	  if (*(*pp)++ != ';')
	    complaint (&symfile_complaints,
		       _("invalid (minimal) member type "
			 "data format at symtab pos %d."),
		       symnum);
	  type = allocate_stub_method (return_type);
	  if (typenums[0] != -1)
	    *dbx_lookup_type (typenums, objfile) = type;
	}
      else
	{
	  struct type *domain = read_type (pp, objfile);
	  struct type *return_type;
	  struct field *args;
	  int nargs, varargs;

	  if (**pp != ',')
	    /* Invalid member type data format.  */
	    return error_type (pp, objfile);
	  else
	    ++(*pp);

	  return_type = read_type (pp, objfile);
	  args = read_args (pp, ';', objfile, &nargs, &varargs);
	  if (args == NULL)
	    return error_type (pp, objfile);
	  type = dbx_alloc_type (typenums, objfile);
	  smash_to_method_type (type, domain, return_type, args,
				nargs, varargs);
	}
      break;

    case 'r':			/* Range type */
      type = read_range_type (pp, typenums, type_size, objfile);
      if (typenums[0] != -1)
	*dbx_lookup_type (typenums, objfile) = type;
      break;

    case 'b':
	{
	  /* Sun ACC builtin int type */
	  type = read_sun_builtin_type (pp, typenums, objfile);
	  if (typenums[0] != -1)
	    *dbx_lookup_type (typenums, objfile) = type;
	}
      break;

    case 'R':			/* Sun ACC builtin float type */
      type = read_sun_floating_type (pp, typenums, objfile);
      if (typenums[0] != -1)
	*dbx_lookup_type (typenums, objfile) = type;
      break;

    case 'e':			/* Enumeration type */
      type = dbx_alloc_type (typenums, objfile);
      type = read_enum_type (pp, type, objfile);
      if (typenums[0] != -1)
	*dbx_lookup_type (typenums, objfile) = type;
      break;

    case 's':			/* Struct type */
    case 'u':			/* Union type */
      {
        enum type_code type_code = TYPE_CODE_UNDEF;
        type = dbx_alloc_type (typenums, objfile);
        switch (type_descriptor)
          {
          case 's':
            type_code = TYPE_CODE_STRUCT;
            break;
          case 'u':
            type_code = TYPE_CODE_UNION;
            break;
          }
        type = read_struct_type (pp, type, type_code, objfile);
        break;
      }

    case 'a':			/* Array type */
      if (**pp != 'r')
	return error_type (pp, objfile);
      ++*pp;

      type = dbx_alloc_type (typenums, objfile);
      type = read_array_type (pp, type, objfile);
      if (is_string)
	TYPE_CODE (type) = TYPE_CODE_STRING;
      if (is_vector)
	make_vector_type (type);
      break;

    case 'S':			/* Set type */
      type1 = read_type (pp, objfile);
      type = create_set_type ((struct type *) NULL, type1);
      if (typenums[0] != -1)
	*dbx_lookup_type (typenums, objfile) = type;
      break;

    default:
      --*pp;			/* Go back to the symbol in error.  */
      /* Particularly important if it was \0!  */
      return error_type (pp, objfile);
    }

  if (type == 0)
    {
      warning (_("GDB internal error, type is NULL in stabsread.c."));
      return error_type (pp, objfile);
    }

  /* Size specified in a type attribute overrides any other size.  */
  if (type_size != -1)
    TYPE_LENGTH (type) = (type_size + TARGET_CHAR_BIT - 1) / TARGET_CHAR_BIT;

  return type;
}

/* RS/6000 xlc/dbx combination uses a set of builtin types, starting from -1.
   Return the proper type node for a given builtin type number.  */

static const struct objfile_data *rs6000_builtin_type_data;

static struct type *
rs6000_builtin_type (int typenum, struct objfile *objfile)
{
  struct type **negative_types = objfile_data (objfile,
					       rs6000_builtin_type_data);

  /* We recognize types numbered from -NUMBER_RECOGNIZED to -1.  */
#define NUMBER_RECOGNIZED 34
  struct type *rettype = NULL;

  if (typenum >= 0 || typenum < -NUMBER_RECOGNIZED)
    {
      complaint (&symfile_complaints, _("Unknown builtin type %d"), typenum);
      return objfile_type (objfile)->builtin_error;
    }

  if (!negative_types)
    {
      /* This includes an empty slot for type number -0.  */
      negative_types = OBSTACK_CALLOC (&objfile->objfile_obstack,
				       NUMBER_RECOGNIZED + 1, struct type *);
      set_objfile_data (objfile, rs6000_builtin_type_data, negative_types);
    }

  if (negative_types[-typenum] != NULL)
    return negative_types[-typenum];

#if TARGET_CHAR_BIT != 8
#error This code wrong for TARGET_CHAR_BIT not 8
  /* These definitions all assume that TARGET_CHAR_BIT is 8.  I think
     that if that ever becomes not true, the correct fix will be to
     make the size in the struct type to be in bits, not in units of
     TARGET_CHAR_BIT.  */
#endif

  switch (-typenum)
    {
    case 1:
      /* The size of this and all the other types are fixed, defined
         by the debugging format.  If there is a type called "int" which
         is other than 32 bits, then it should use a new negative type
         number (or avoid negative type numbers for that case).
         See stabs.texinfo.  */
      rettype = init_type (TYPE_CODE_INT, 4, 0, "int", objfile);
      break;
    case 2:
      rettype = init_type (TYPE_CODE_INT, 1, 0, "char", objfile);
      break;
    case 3:
      rettype = init_type (TYPE_CODE_INT, 2, 0, "short", objfile);
      break;
    case 4:
      rettype = init_type (TYPE_CODE_INT, 4, 0, "long", objfile);
      break;
    case 5:
      rettype = init_type (TYPE_CODE_INT, 1, TYPE_FLAG_UNSIGNED,
			   "unsigned char", objfile);
      break;
    case 6:
      rettype = init_type (TYPE_CODE_INT, 1, 0, "signed char", objfile);
      break;
    case 7:
      rettype = init_type (TYPE_CODE_INT, 2, TYPE_FLAG_UNSIGNED,
			   "unsigned short", objfile);
      break;
    case 8:
      rettype = init_type (TYPE_CODE_INT, 4, TYPE_FLAG_UNSIGNED,
			   "unsigned int", objfile);
      break;
    case 9:
      rettype = init_type (TYPE_CODE_INT, 4, TYPE_FLAG_UNSIGNED,
			   "unsigned", objfile);
      break;
    case 10:
      rettype = init_type (TYPE_CODE_INT, 4, TYPE_FLAG_UNSIGNED,
			   "unsigned long", objfile);
      break;
    case 11:
      rettype = init_type (TYPE_CODE_VOID, 1, 0, "void", objfile);
      break;
    case 12:
      /* IEEE single precision (32 bit).  */
      rettype = init_type (TYPE_CODE_FLT, 4, 0, "float", objfile);
      break;
    case 13:
      /* IEEE double precision (64 bit).  */
      rettype = init_type (TYPE_CODE_FLT, 8, 0, "double", objfile);
      break;
    case 14:
      /* This is an IEEE double on the RS/6000, and different machines with
         different sizes for "long double" should use different negative
         type numbers.  See stabs.texinfo.  */
      rettype = init_type (TYPE_CODE_FLT, 8, 0, "long double", objfile);
      break;
    case 15:
      rettype = init_type (TYPE_CODE_INT, 4, 0, "integer", objfile);
      break;
    case 16:
      rettype = init_type (TYPE_CODE_BOOL, 4, TYPE_FLAG_UNSIGNED,
			   "boolean", objfile);
      break;
    case 17:
      rettype = init_type (TYPE_CODE_FLT, 4, 0, "short real", objfile);
      break;
    case 18:
      rettype = init_type (TYPE_CODE_FLT, 8, 0, "real", objfile);
      break;
    case 19:
      rettype = init_type (TYPE_CODE_ERROR, 0, 0, "stringptr", objfile);
      break;
    case 20:
      rettype = init_type (TYPE_CODE_CHAR, 1, TYPE_FLAG_UNSIGNED,
			   "character", objfile);
      break;
    case 21:
      rettype = init_type (TYPE_CODE_BOOL, 1, TYPE_FLAG_UNSIGNED,
			   "logical*1", objfile);
      break;
    case 22:
      rettype = init_type (TYPE_CODE_BOOL, 2, TYPE_FLAG_UNSIGNED,
			   "logical*2", objfile);
      break;
    case 23:
      rettype = init_type (TYPE_CODE_BOOL, 4, TYPE_FLAG_UNSIGNED,
			   "logical*4", objfile);
      break;
    case 24:
      rettype = init_type (TYPE_CODE_BOOL, 4, TYPE_FLAG_UNSIGNED,
			   "logical", objfile);
      break;
    case 25:
      /* Complex type consisting of two IEEE single precision values.  */
      rettype = init_type (TYPE_CODE_COMPLEX, 8, 0, "complex", objfile);
      TYPE_TARGET_TYPE (rettype) = init_type (TYPE_CODE_FLT, 4, 0, "float",
					      objfile);
      break;
    case 26:
      /* Complex type consisting of two IEEE double precision values.  */
      rettype = init_type (TYPE_CODE_COMPLEX, 16, 0, "double complex", NULL);
      TYPE_TARGET_TYPE (rettype) = init_type (TYPE_CODE_FLT, 8, 0, "double",
					      objfile);
      break;
    case 27:
      rettype = init_type (TYPE_CODE_INT, 1, 0, "integer*1", objfile);
      break;
    case 28:
      rettype = init_type (TYPE_CODE_INT, 2, 0, "integer*2", objfile);
      break;
    case 29:
      rettype = init_type (TYPE_CODE_INT, 4, 0, "integer*4", objfile);
      break;
    case 30:
      rettype = init_type (TYPE_CODE_CHAR, 2, 0, "wchar", objfile);
      break;
    case 31:
      rettype = init_type (TYPE_CODE_INT, 8, 0, "long long", objfile);
      break;
    case 32:
      rettype = init_type (TYPE_CODE_INT, 8, TYPE_FLAG_UNSIGNED,
			   "unsigned long long", objfile);
      break;
    case 33:
      rettype = init_type (TYPE_CODE_INT, 8, TYPE_FLAG_UNSIGNED,
			   "logical*8", objfile);
      break;
    case 34:
      rettype = init_type (TYPE_CODE_INT, 8, 0, "integer*8", objfile);
      break;
    }
  negative_types[-typenum] = rettype;
  return rettype;
}

/* This page contains subroutines of read_type.  */

/* Wrapper around method_name_from_physname to flag a complaint
   if there is an error.  */

static char *
stabs_method_name_from_physname (const char *physname)
{
  char *method_name;

  method_name = method_name_from_physname (physname);

  if (method_name == NULL)
    {
      complaint (&symfile_complaints,
		 _("Method has bad physname %s\n"), physname);
      return NULL;
    }

  return method_name;
}

/* Read member function stabs info for C++ classes.  The form of each member
   function data is:

   NAME :: TYPENUM[=type definition] ARGS : PHYSNAME ;

   An example with two member functions is:

   afunc1::20=##15;:i;2A.;afunc2::20:i;2A.;

   For the case of overloaded operators, the format is op$::*.funcs, where
   $ is the CPLUS_MARKER (usually '$'), `*' holds the place for an operator
   name (such as `+=') and `.' marks the end of the operator name.

   Returns 1 for success, 0 for failure.  */

static int
read_member_functions (struct field_info *fip, char **pp, struct type *type,
		       struct objfile *objfile)
{
  int nfn_fields = 0;
  int length = 0;
  int i;
  struct next_fnfield
    {
      struct next_fnfield *next;
      struct fn_field fn_field;
    }
   *sublist;
  struct type *look_ahead_type;
  struct next_fnfieldlist *new_fnlist;
  struct next_fnfield *new_sublist;
  char *main_fn_name;
  char *p;

  /* Process each list until we find something that is not a member function
     or find the end of the functions.  */

  while (**pp != ';')
    {
      /* We should be positioned at the start of the function name.
         Scan forward to find the first ':' and if it is not the
         first of a "::" delimiter, then this is not a member function.  */
      p = *pp;
      while (*p != ':')
	{
	  p++;
	}
      if (p[1] != ':')
	{
	  break;
	}

      sublist = NULL;
      look_ahead_type = NULL;
      length = 0;

      new_fnlist = (struct next_fnfieldlist *)
	xmalloc (sizeof (struct next_fnfieldlist));
      make_cleanup (xfree, new_fnlist);
      memset (new_fnlist, 0, sizeof (struct next_fnfieldlist));

      if ((*pp)[0] == 'o' && (*pp)[1] == 'p' && is_cplus_marker ((*pp)[2]))
	{
	  /* This is a completely wierd case.  In order to stuff in the
	     names that might contain colons (the usual name delimiter),
	     Mike Tiemann defined a different name format which is
	     signalled if the identifier is "op$".  In that case, the
	     format is "op$::XXXX." where XXXX is the name.  This is
	     used for names like "+" or "=".  YUUUUUUUK!  FIXME!  */
	  /* This lets the user type "break operator+".
	     We could just put in "+" as the name, but that wouldn't
	     work for "*".  */
	  static char opname[32] = "op$";
	  char *o = opname + 3;

	  /* Skip past '::'.  */
	  *pp = p + 2;

	  STABS_CONTINUE (pp, objfile);
	  p = *pp;
	  while (*p != '.')
	    {
	      *o++ = *p++;
	    }
	  main_fn_name = savestring (opname, o - opname);
	  /* Skip past '.'  */
	  *pp = p + 1;
	}
      else
	{
	  main_fn_name = savestring (*pp, p - *pp);
	  /* Skip past '::'.  */
	  *pp = p + 2;
	}
      new_fnlist->fn_fieldlist.name = main_fn_name;

      do
	{
	  new_sublist =
	    (struct next_fnfield *) xmalloc (sizeof (struct next_fnfield));
	  make_cleanup (xfree, new_sublist);
	  memset (new_sublist, 0, sizeof (struct next_fnfield));

	  /* Check for and handle cretinous dbx symbol name continuation!  */
	  if (look_ahead_type == NULL)
	    {
	      /* Normal case.  */
	      STABS_CONTINUE (pp, objfile);

	      new_sublist->fn_field.type = read_type (pp, objfile);
	      if (**pp != ':')
		{
		  /* Invalid symtab info for member function.  */
		  return 0;
		}
	    }
	  else
	    {
	      /* g++ version 1 kludge */
	      new_sublist->fn_field.type = look_ahead_type;
	      look_ahead_type = NULL;
	    }

	  (*pp)++;
	  p = *pp;
	  while (*p != ';')
	    {
	      p++;
	    }

	  /* If this is just a stub, then we don't have the real name here.  */

	  if (TYPE_STUB (new_sublist->fn_field.type))
	    {
	      if (!TYPE_DOMAIN_TYPE (new_sublist->fn_field.type))
		TYPE_DOMAIN_TYPE (new_sublist->fn_field.type) = type;
	      new_sublist->fn_field.is_stub = 1;
	    }
	  new_sublist->fn_field.physname = savestring (*pp, p - *pp);
	  *pp = p + 1;

	  /* Set this member function's visibility fields.  */
	  switch (*(*pp)++)
	    {
	    case VISIBILITY_PRIVATE:
	      new_sublist->fn_field.is_private = 1;
	      break;
	    case VISIBILITY_PROTECTED:
	      new_sublist->fn_field.is_protected = 1;
	      break;
	    }

	  STABS_CONTINUE (pp, objfile);
	  switch (**pp)
	    {
	    case 'A':		/* Normal functions.  */
	      new_sublist->fn_field.is_const = 0;
	      new_sublist->fn_field.is_volatile = 0;
	      (*pp)++;
	      break;
	    case 'B':		/* `const' member functions.  */
	      new_sublist->fn_field.is_const = 1;
	      new_sublist->fn_field.is_volatile = 0;
	      (*pp)++;
	      break;
	    case 'C':		/* `volatile' member function.  */
	      new_sublist->fn_field.is_const = 0;
	      new_sublist->fn_field.is_volatile = 1;
	      (*pp)++;
	      break;
	    case 'D':		/* `const volatile' member function.  */
	      new_sublist->fn_field.is_const = 1;
	      new_sublist->fn_field.is_volatile = 1;
	      (*pp)++;
	      break;
	    case '*':		/* File compiled with g++ version 1 --
				   no info.  */
	    case '?':
	    case '.':
	      break;
	    default:
	      complaint (&symfile_complaints,
			 _("const/volatile indicator missing, got '%c'"),
			 **pp);
	      break;
	    }

	  switch (*(*pp)++)
	    {
	    case '*':
	      {
		int nbits;
		/* virtual member function, followed by index.
		   The sign bit is set to distinguish pointers-to-methods
		   from virtual function indicies.  Since the array is
		   in words, the quantity must be shifted left by 1
		   on 16 bit machine, and by 2 on 32 bit machine, forcing
		   the sign bit out, and usable as a valid index into
		   the array.  Remove the sign bit here.  */
		new_sublist->fn_field.voffset =
		  (0x7fffffff & read_huge_number (pp, ';', &nbits, 0)) + 2;
		if (nbits != 0)
		  return 0;

		STABS_CONTINUE (pp, objfile);
		if (**pp == ';' || **pp == '\0')
		  {
		    /* Must be g++ version 1.  */
		    new_sublist->fn_field.fcontext = 0;
		  }
		else
		  {
		    /* Figure out from whence this virtual function came.
		       It may belong to virtual function table of
		       one of its baseclasses.  */
		    look_ahead_type = read_type (pp, objfile);
		    if (**pp == ':')
		      {
			/* g++ version 1 overloaded methods.  */
		      }
		    else
		      {
			new_sublist->fn_field.fcontext = look_ahead_type;
			if (**pp != ';')
			  {
			    return 0;
			  }
			else
			  {
			    ++*pp;
			  }
			look_ahead_type = NULL;
		      }
		  }
		break;
	      }
	    case '?':
	      /* static member function.  */
	      {
		int slen = strlen (main_fn_name);

		new_sublist->fn_field.voffset = VOFFSET_STATIC;

		/* For static member functions, we can't tell if they
		   are stubbed, as they are put out as functions, and not as
		   methods.
		   GCC v2 emits the fully mangled name if
		   dbxout.c:flag_minimal_debug is not set, so we have to
		   detect a fully mangled physname here and set is_stub
		   accordingly.  Fully mangled physnames in v2 start with
		   the member function name, followed by two underscores.
		   GCC v3 currently always emits stubbed member functions,
		   but with fully mangled physnames, which start with _Z.  */
		if (!(strncmp (new_sublist->fn_field.physname,
			       main_fn_name, slen) == 0
		      && new_sublist->fn_field.physname[slen] == '_'
		      && new_sublist->fn_field.physname[slen + 1] == '_'))
		  {
		    new_sublist->fn_field.is_stub = 1;
		  }
		break;
	      }

	    default:
	      /* error */
	      complaint (&symfile_complaints,
			 _("member function type missing, got '%c'"),
			 (*pp)[-1]);
	      /* Fall through into normal member function.  */

	    case '.':
	      /* normal member function.  */
	      new_sublist->fn_field.voffset = 0;
	      new_sublist->fn_field.fcontext = 0;
	      break;
	    }

	  new_sublist->next = sublist;
	  sublist = new_sublist;
	  length++;
	  STABS_CONTINUE (pp, objfile);
	}
      while (**pp != ';' && **pp != '\0');

      (*pp)++;
      STABS_CONTINUE (pp, objfile);

      /* Skip GCC 3.X member functions which are duplicates of the callable
	 constructor/destructor.  */
      if (strcmp_iw (main_fn_name, "__base_ctor ") == 0
	  || strcmp_iw (main_fn_name, "__base_dtor ") == 0
	  || strcmp (main_fn_name, "__deleting_dtor") == 0)
	{
	  xfree (main_fn_name);
	}
      else
	{
	  int has_stub = 0;
	  int has_destructor = 0, has_other = 0;
	  int is_v3 = 0;
	  struct next_fnfield *tmp_sublist;

	  /* Various versions of GCC emit various mostly-useless
	     strings in the name field for special member functions.

	     For stub methods, we need to defer correcting the name
	     until we are ready to unstub the method, because the current
	     name string is used by gdb_mangle_name.  The only stub methods
	     of concern here are GNU v2 operators; other methods have their
	     names correct (see caveat below).

	     For non-stub methods, in GNU v3, we have a complete physname.
	     Therefore we can safely correct the name now.  This primarily
	     affects constructors and destructors, whose name will be
	     __comp_ctor or __comp_dtor instead of Foo or ~Foo.  Cast
	     operators will also have incorrect names; for instance,
	     "operator int" will be named "operator i" (i.e. the type is
	     mangled).

	     For non-stub methods in GNU v2, we have no easy way to
	     know if we have a complete physname or not.  For most
	     methods the result depends on the platform (if CPLUS_MARKER
	     can be `$' or `.', it will use minimal debug information, or
	     otherwise the full physname will be included).

	     Rather than dealing with this, we take a different approach.
	     For v3 mangled names, we can use the full physname; for v2,
	     we use cplus_demangle_opname (which is actually v2 specific),
	     because the only interesting names are all operators - once again
	     barring the caveat below.  Skip this process if any method in the
	     group is a stub, to prevent our fouling up the workings of
	     gdb_mangle_name.

	     The caveat: GCC 2.95.x (and earlier?) put constructors and
	     destructors in the same method group.  We need to split this
	     into two groups, because they should have different names.
	     So for each method group we check whether it contains both
	     routines whose physname appears to be a destructor (the physnames
	     for and destructors are always provided, due to quirks in v2
	     mangling) and routines whose physname does not appear to be a
	     destructor.  If so then we break up the list into two halves.
	     Even if the constructors and destructors aren't in the same group
	     the destructor will still lack the leading tilde, so that also
	     needs to be fixed.

	     So, to summarize what we expect and handle here:

	        Given         Given          Real         Real       Action
	     method name     physname      physname   method name

	     __opi            [none]     __opi__3Foo  operator int    opname
	                                                         [now or later]
	     Foo              _._3Foo       _._3Foo      ~Foo      separate and
	                                                               rename
	     operator i     _ZN3FoocviEv _ZN3FoocviEv operator int    demangle
	     __comp_ctor  _ZN3FooC1ERKS_ _ZN3FooC1ERKS_   Foo         demangle
	  */

	  tmp_sublist = sublist;
	  while (tmp_sublist != NULL)
	    {
	      if (tmp_sublist->fn_field.is_stub)
		has_stub = 1;
	      if (tmp_sublist->fn_field.physname[0] == '_'
		  && tmp_sublist->fn_field.physname[1] == 'Z')
		is_v3 = 1;

	      if (is_destructor_name (tmp_sublist->fn_field.physname))
		has_destructor++;
	      else
		has_other++;

	      tmp_sublist = tmp_sublist->next;
	    }

	  if (has_destructor && has_other)
	    {
	      struct next_fnfieldlist *destr_fnlist;
	      struct next_fnfield *last_sublist;

	      /* Create a new fn_fieldlist for the destructors.  */

	      destr_fnlist = (struct next_fnfieldlist *)
		xmalloc (sizeof (struct next_fnfieldlist));
	      make_cleanup (xfree, destr_fnlist);
	      memset (destr_fnlist, 0, sizeof (struct next_fnfieldlist));
	      destr_fnlist->fn_fieldlist.name
		= obconcat (&objfile->objfile_obstack, "~",
			    new_fnlist->fn_fieldlist.name, (char *) NULL);

	      destr_fnlist->fn_fieldlist.fn_fields = (struct fn_field *)
		obstack_alloc (&objfile->objfile_obstack,
			       sizeof (struct fn_field) * has_destructor);
	      memset (destr_fnlist->fn_fieldlist.fn_fields, 0,
		  sizeof (struct fn_field) * has_destructor);
	      tmp_sublist = sublist;
	      last_sublist = NULL;
	      i = 0;
	      while (tmp_sublist != NULL)
		{
		  if (!is_destructor_name (tmp_sublist->fn_field.physname))
		    {
		      tmp_sublist = tmp_sublist->next;
		      continue;
		    }
		  
		  destr_fnlist->fn_fieldlist.fn_fields[i++]
		    = tmp_sublist->fn_field;
		  if (last_sublist)
		    last_sublist->next = tmp_sublist->next;
		  else
		    sublist = tmp_sublist->next;
		  last_sublist = tmp_sublist;
		  tmp_sublist = tmp_sublist->next;
		}

	      destr_fnlist->fn_fieldlist.length = has_destructor;
	      destr_fnlist->next = fip->fnlist;
	      fip->fnlist = destr_fnlist;
	      nfn_fields++;
	      length -= has_destructor;
	    }
	  else if (is_v3)
	    {
	      /* v3 mangling prevents the use of abbreviated physnames,
		 so we can do this here.  There are stubbed methods in v3
		 only:
		 - in -gstabs instead of -gstabs+
		 - or for static methods, which are output as a function type
		   instead of a method type.  */
	      char *new_method_name =
		stabs_method_name_from_physname (sublist->fn_field.physname);

	      if (new_method_name != NULL
		  && strcmp (new_method_name,
			     new_fnlist->fn_fieldlist.name) != 0)
		{
		  new_fnlist->fn_fieldlist.name = new_method_name;
		  xfree (main_fn_name);
		}
	      else
		xfree (new_method_name);
	    }
	  else if (has_destructor && new_fnlist->fn_fieldlist.name[0] != '~')
	    {
	      new_fnlist->fn_fieldlist.name =
		obconcat (&objfile->objfile_obstack,
			  "~", main_fn_name, (char *)NULL);
	      xfree (main_fn_name);
	    }
	  else if (!has_stub)
	    {
	      char dem_opname[256];
	      int ret;

	      ret = cplus_demangle_opname (new_fnlist->fn_fieldlist.name,
					      dem_opname, DMGL_ANSI);
	      if (!ret)
		ret = cplus_demangle_opname (new_fnlist->fn_fieldlist.name,
					     dem_opname, 0);
	      if (ret)
		new_fnlist->fn_fieldlist.name
		  = obstack_copy0 (&objfile->objfile_obstack,
				   dem_opname, strlen (dem_opname));
	      xfree (main_fn_name);
	    }

	  new_fnlist->fn_fieldlist.fn_fields = (struct fn_field *)
	    obstack_alloc (&objfile->objfile_obstack,
			   sizeof (struct fn_field) * length);
	  memset (new_fnlist->fn_fieldlist.fn_fields, 0,
		  sizeof (struct fn_field) * length);
	  for (i = length; (i--, sublist); sublist = sublist->next)
	    {
	      new_fnlist->fn_fieldlist.fn_fields[i] = sublist->fn_field;
	    }

	  new_fnlist->fn_fieldlist.length = length;
	  new_fnlist->next = fip->fnlist;
	  fip->fnlist = new_fnlist;
	  nfn_fields++;
	}
    }

  if (nfn_fields)
    {
      ALLOCATE_CPLUS_STRUCT_TYPE (type);
      TYPE_FN_FIELDLISTS (type) = (struct fn_fieldlist *)
	TYPE_ALLOC (type, sizeof (struct fn_fieldlist) * nfn_fields);
      memset (TYPE_FN_FIELDLISTS (type), 0,
	      sizeof (struct fn_fieldlist) * nfn_fields);
      TYPE_NFN_FIELDS (type) = nfn_fields;
    }

  return 1;
}

/* Special GNU C++ name.

   Returns 1 for success, 0 for failure.  "failure" means that we can't
   keep parsing and it's time for error_type().  */

static int
read_cpp_abbrev (struct field_info *fip, char **pp, struct type *type,
		 struct objfile *objfile)
{
  char *p;
  const char *name;
  char cpp_abbrev;
  struct type *context;

  p = *pp;
  if (*++p == 'v')
    {
      name = NULL;
      cpp_abbrev = *++p;

      *pp = p + 1;

      /* At this point, *pp points to something like "22:23=*22...",
         where the type number before the ':' is the "context" and
         everything after is a regular type definition.  Lookup the
         type, find it's name, and construct the field name.  */

      context = read_type (pp, objfile);

      switch (cpp_abbrev)
	{
	case 'f':		/* $vf -- a virtual function table pointer */
	  name = type_name_no_tag (context);
	  if (name == NULL)
	    {
	      name = "";
	    }
	  fip->list->field.name = obconcat (&objfile->objfile_obstack,
					    vptr_name, name, (char *) NULL);
	  break;

	case 'b':		/* $vb -- a virtual bsomethingorother */
	  name = type_name_no_tag (context);
	  if (name == NULL)
	    {
	      complaint (&symfile_complaints,
			 _("C++ abbreviated type name "
			   "unknown at symtab pos %d"),
			 symnum);
	      name = "FOO";
	    }
	  fip->list->field.name = obconcat (&objfile->objfile_obstack, vb_name,
					    name, (char *) NULL);
	  break;

	default:
	  invalid_cpp_abbrev_complaint (*pp);
	  fip->list->field.name = obconcat (&objfile->objfile_obstack,
					    "INVALID_CPLUSPLUS_ABBREV",
					    (char *) NULL);
	  break;
	}

      /* At this point, *pp points to the ':'.  Skip it and read the
         field type.  */

      p = ++(*pp);
      if (p[-1] != ':')
	{
	  invalid_cpp_abbrev_complaint (*pp);
	  return 0;
	}
      fip->list->field.type = read_type (pp, objfile);
      if (**pp == ',')
	(*pp)++;		/* Skip the comma.  */
      else
	return 0;

      {
	int nbits;

	SET_FIELD_BITPOS (fip->list->field,
			  read_huge_number (pp, ';', &nbits, 0));
	if (nbits != 0)
	  return 0;
      }
      /* This field is unpacked.  */
      FIELD_BITSIZE (fip->list->field) = 0;
      fip->list->visibility = VISIBILITY_PRIVATE;
    }
  else
    {
      invalid_cpp_abbrev_complaint (*pp);
      /* We have no idea what syntax an unrecognized abbrev would have, so
         better return 0.  If we returned 1, we would need to at least advance
         *pp to avoid an infinite loop.  */
      return 0;
    }
  return 1;
}

static void
read_one_struct_field (struct field_info *fip, char **pp, char *p,
		       struct type *type, struct objfile *objfile)
{
  struct gdbarch *gdbarch = get_objfile_arch (objfile);

  fip->list->field.name =
    obstack_copy0 (&objfile->objfile_obstack, *pp, p - *pp);
  *pp = p + 1;

  /* This means we have a visibility for a field coming.  */
  if (**pp == '/')
    {
      (*pp)++;
      fip->list->visibility = *(*pp)++;
    }
  else
    {
      /* normal dbx-style format, no explicit visibility */
      fip->list->visibility = VISIBILITY_PUBLIC;
    }

  fip->list->field.type = read_type (pp, objfile);
  if (**pp == ':')
    {
      p = ++(*pp);
#if 0
      /* Possible future hook for nested types.  */
      if (**pp == '!')
	{
	  fip->list->field.bitpos = (long) -2;	/* nested type */
	  p = ++(*pp);
	}
      else
	...;
#endif
      while (*p != ';')
	{
	  p++;
	}
      /* Static class member.  */
      SET_FIELD_PHYSNAME (fip->list->field, savestring (*pp, p - *pp));
      *pp = p + 1;
      return;
    }
  else if (**pp != ',')
    {
      /* Bad structure-type format.  */
      stabs_general_complaint ("bad structure-type format");
      return;
    }

  (*pp)++;			/* Skip the comma.  */

  {
    int nbits;

    SET_FIELD_BITPOS (fip->list->field,
		      read_huge_number (pp, ',', &nbits, 0));
    if (nbits != 0)
      {
	stabs_general_complaint ("bad structure-type format");
	return;
      }
    FIELD_BITSIZE (fip->list->field) = read_huge_number (pp, ';', &nbits, 0);
    if (nbits != 0)
      {
	stabs_general_complaint ("bad structure-type format");
	return;
      }
  }

  if (FIELD_BITPOS (fip->list->field) == 0
      && FIELD_BITSIZE (fip->list->field) == 0)
    {
      /* This can happen in two cases: (1) at least for gcc 2.4.5 or so,
         it is a field which has been optimized out.  The correct stab for
         this case is to use VISIBILITY_IGNORE, but that is a recent
         invention.  (2) It is a 0-size array.  For example
         union { int num; char str[0]; } foo.  Printing _("<no value>" for
         str in "p foo" is OK, since foo.str (and thus foo.str[3])
         will continue to work, and a 0-size array as a whole doesn't
         have any contents to print.

         I suspect this probably could also happen with gcc -gstabs (not
         -gstabs+) for static fields, and perhaps other C++ extensions.
         Hopefully few people use -gstabs with gdb, since it is intended
         for dbx compatibility.  */

      /* Ignore this field.  */
      fip->list->visibility = VISIBILITY_IGNORE;
    }
  else
    {
      /* Detect an unpacked field and mark it as such.
         dbx gives a bit size for all fields.
         Note that forward refs cannot be packed,
         and treat enums as if they had the width of ints.  */

      struct type *field_type = check_typedef (FIELD_TYPE (fip->list->field));

      if (TYPE_CODE (field_type) != TYPE_CODE_INT
	  && TYPE_CODE (field_type) != TYPE_CODE_RANGE
	  && TYPE_CODE (field_type) != TYPE_CODE_BOOL
	  && TYPE_CODE (field_type) != TYPE_CODE_ENUM)
	{
	  FIELD_BITSIZE (fip->list->field) = 0;
	}
      if ((FIELD_BITSIZE (fip->list->field)
	   == TARGET_CHAR_BIT * TYPE_LENGTH (field_type)
	   || (TYPE_CODE (field_type) == TYPE_CODE_ENUM
	       && FIELD_BITSIZE (fip->list->field)
		  == gdbarch_int_bit (gdbarch))
	  )
	  &&
	  FIELD_BITPOS (fip->list->field) % 8 == 0)
	{
	  FIELD_BITSIZE (fip->list->field) = 0;
	}
    }
}


/* Read struct or class data fields.  They have the form:

   NAME : [VISIBILITY] TYPENUM , BITPOS , BITSIZE ;

   At the end, we see a semicolon instead of a field.

   In C++, this may wind up being NAME:?TYPENUM:PHYSNAME; for
   a static field.

   The optional VISIBILITY is one of:

   '/0' (VISIBILITY_PRIVATE)
   '/1' (VISIBILITY_PROTECTED)
   '/2' (VISIBILITY_PUBLIC)
   '/9' (VISIBILITY_IGNORE)

   or nothing, for C style fields with public visibility.

   Returns 1 for success, 0 for failure.  */

static int
read_struct_fields (struct field_info *fip, char **pp, struct type *type,
		    struct objfile *objfile)
{
  char *p;
  struct nextfield *new;

  /* We better set p right now, in case there are no fields at all...    */

  p = *pp;

  /* Read each data member type until we find the terminating ';' at the end of
     the data member list, or break for some other reason such as finding the
     start of the member function list.  */
  /* Stab string for structure/union does not end with two ';' in
     SUN C compiler 5.3 i.e. F6U2, hence check for end of string.  */

  while (**pp != ';' && **pp != '\0')
    {
      STABS_CONTINUE (pp, objfile);
      /* Get space to record the next field's data.  */
      new = (struct nextfield *) xmalloc (sizeof (struct nextfield));
      make_cleanup (xfree, new);
      memset (new, 0, sizeof (struct nextfield));
      new->next = fip->list;
      fip->list = new;

      /* Get the field name.  */
      p = *pp;

      /* If is starts with CPLUS_MARKER it is a special abbreviation,
         unless the CPLUS_MARKER is followed by an underscore, in
         which case it is just the name of an anonymous type, which we
         should handle like any other type name.  */

      if (is_cplus_marker (p[0]) && p[1] != '_')
	{
	  if (!read_cpp_abbrev (fip, pp, type, objfile))
	    return 0;
	  continue;
	}

      /* Look for the ':' that separates the field name from the field
         values.  Data members are delimited by a single ':', while member
         functions are delimited by a pair of ':'s.  When we hit the member
         functions (if any), terminate scan loop and return.  */

      while (*p != ':' && *p != '\0')
	{
	  p++;
	}
      if (*p == '\0')
	return 0;

      /* Check to see if we have hit the member functions yet.  */
      if (p[1] == ':')
	{
	  break;
	}
      read_one_struct_field (fip, pp, p, type, objfile);
    }
  if (p[0] == ':' && p[1] == ':')
    {
      /* (the deleted) chill the list of fields: the last entry (at
         the head) is a partially constructed entry which we now
         scrub.  */
      fip->list = fip->list->next;
    }
  return 1;
}
/* *INDENT-OFF* */
/* The stabs for C++ derived classes contain baseclass information which
   is marked by a '!' character after the total size.  This function is
   called when we encounter the baseclass marker, and slurps up all the
   baseclass information.

   Immediately following the '!' marker is the number of base classes that
   the class is derived from, followed by information for each base class.
   For each base class, there are two visibility specifiers, a bit offset
   to the base class information within the derived class, a reference to
   the type for the base class, and a terminating semicolon.

   A typical example, with two base classes, would be "!2,020,19;0264,21;".
   						       ^^ ^ ^ ^  ^ ^  ^
	Baseclass information marker __________________|| | | |  | |  |
	Number of baseclasses __________________________| | | |  | |  |
	Visibility specifiers (2) ________________________| | |  | |  |
	Offset in bits from start of class _________________| |  | |  |
	Type number for base class ___________________________|  | |  |
	Visibility specifiers (2) _______________________________| |  |
	Offset in bits from start of class ________________________|  |
	Type number of base class ____________________________________|

  Return 1 for success, 0 for (error-type-inducing) failure.  */
/* *INDENT-ON* */



static int
read_baseclasses (struct field_info *fip, char **pp, struct type *type,
		  struct objfile *objfile)
{
  int i;
  struct nextfield *new;

  if (**pp != '!')
    {
      return 1;
    }
  else
    {
      /* Skip the '!' baseclass information marker.  */
      (*pp)++;
    }

  ALLOCATE_CPLUS_STRUCT_TYPE (type);
  {
    int nbits;

    TYPE_N_BASECLASSES (type) = read_huge_number (pp, ',', &nbits, 0);
    if (nbits != 0)
      return 0;
  }

#if 0
  /* Some stupid compilers have trouble with the following, so break
     it up into simpler expressions.  */
  TYPE_FIELD_VIRTUAL_BITS (type) = (B_TYPE *)
    TYPE_ALLOC (type, B_BYTES (TYPE_N_BASECLASSES (type)));
#else
  {
    int num_bytes = B_BYTES (TYPE_N_BASECLASSES (type));
    char *pointer;

    pointer = (char *) TYPE_ALLOC (type, num_bytes);
    TYPE_FIELD_VIRTUAL_BITS (type) = (B_TYPE *) pointer;
  }
#endif /* 0 */

  B_CLRALL (TYPE_FIELD_VIRTUAL_BITS (type), TYPE_N_BASECLASSES (type));

  for (i = 0; i < TYPE_N_BASECLASSES (type); i++)
    {
      new = (struct nextfield *) xmalloc (sizeof (struct nextfield));
      make_cleanup (xfree, new);
      memset (new, 0, sizeof (struct nextfield));
      new->next = fip->list;
      fip->list = new;
      FIELD_BITSIZE (new->field) = 0;	/* This should be an unpacked
					   field!  */

      STABS_CONTINUE (pp, objfile);
      switch (**pp)
	{
	case '0':
	  /* Nothing to do.  */
	  break;
	case '1':
	  SET_TYPE_FIELD_VIRTUAL (type, i);
	  break;
	default:
	  /* Unknown character.  Complain and treat it as non-virtual.  */
	  {
	    complaint (&symfile_complaints,
		       _("Unknown virtual character `%c' for baseclass"),
		       **pp);
	  }
	}
      ++(*pp);

      new->visibility = *(*pp)++;
      switch (new->visibility)
	{
	case VISIBILITY_PRIVATE:
	case VISIBILITY_PROTECTED:
	case VISIBILITY_PUBLIC:
	  break;
	default:
	  /* Bad visibility format.  Complain and treat it as
	     public.  */
	  {
	    complaint (&symfile_complaints,
		       _("Unknown visibility `%c' for baseclass"),
		       new->visibility);
	    new->visibility = VISIBILITY_PUBLIC;
	  }
	}

      {
	int nbits;

	/* The remaining value is the bit offset of the portion of the object
	   corresponding to this baseclass.  Always zero in the absence of
	   multiple inheritance.  */

	SET_FIELD_BITPOS (new->field, read_huge_number (pp, ',', &nbits, 0));
	if (nbits != 0)
	  return 0;
      }

      /* The last piece of baseclass information is the type of the
         base class.  Read it, and remember it's type name as this
         field's name.  */

      new->field.type = read_type (pp, objfile);
      new->field.name = type_name_no_tag (new->field.type);

      /* Skip trailing ';' and bump count of number of fields seen.  */
      if (**pp == ';')
	(*pp)++;
      else
	return 0;
    }
  return 1;
}

/* The tail end of stabs for C++ classes that contain a virtual function
   pointer contains a tilde, a %, and a type number.
   The type number refers to the base class (possibly this class itself) which
   contains the vtable pointer for the current class.

   This function is called when we have parsed all the method declarations,
   so we can look for the vptr base class info.  */

static int
read_tilde_fields (struct field_info *fip, char **pp, struct type *type,
		   struct objfile *objfile)
{
  char *p;

  STABS_CONTINUE (pp, objfile);

  /* If we are positioned at a ';', then skip it.  */
  if (**pp == ';')
    {
      (*pp)++;
    }

  if (**pp == '~')
    {
      (*pp)++;

      if (**pp == '=' || **pp == '+' || **pp == '-')
	{
	  /* Obsolete flags that used to indicate the presence
	     of constructors and/or destructors.  */
	  (*pp)++;
	}

      /* Read either a '%' or the final ';'.  */
      if (*(*pp)++ == '%')
	{
	  /* The next number is the type number of the base class
	     (possibly our own class) which supplies the vtable for
	     this class.  Parse it out, and search that class to find
	     its vtable pointer, and install those into TYPE_VPTR_BASETYPE
	     and TYPE_VPTR_FIELDNO.  */

	  struct type *t;
	  int i;

	  t = read_type (pp, objfile);
	  p = (*pp)++;
	  while (*p != '\0' && *p != ';')
	    {
	      p++;
	    }
	  if (*p == '\0')
	    {
	      /* Premature end of symbol.  */
	      return 0;
	    }

	  TYPE_VPTR_BASETYPE (type) = t;
	  if (type == t)	/* Our own class provides vtbl ptr.  */
	    {
	      for (i = TYPE_NFIELDS (t) - 1;
		   i >= TYPE_N_BASECLASSES (t);
		   --i)
		{
		  const char *name = TYPE_FIELD_NAME (t, i);

		  if (!strncmp (name, vptr_name, sizeof (vptr_name) - 2)
		      && is_cplus_marker (name[sizeof (vptr_name) - 2]))
		    {
		      TYPE_VPTR_FIELDNO (type) = i;
		      goto gotit;
		    }
		}
	      /* Virtual function table field not found.  */
	      complaint (&symfile_complaints,
			 _("virtual function table pointer "
			   "not found when defining class `%s'"),
			 TYPE_NAME (type));
	      return 0;
	    }
	  else
	    {
	      TYPE_VPTR_FIELDNO (type) = TYPE_VPTR_FIELDNO (t);
	    }

	gotit:
	  *pp = p + 1;
	}
    }
  return 1;
}

static int
attach_fn_fields_to_type (struct field_info *fip, struct type *type)
{
  int n;

  for (n = TYPE_NFN_FIELDS (type);
       fip->fnlist != NULL;
       fip->fnlist = fip->fnlist->next)
    {
      --n;			/* Circumvent Sun3 compiler bug.  */
      TYPE_FN_FIELDLISTS (type)[n] = fip->fnlist->fn_fieldlist;
    }
  return 1;
}

/* Create the vector of fields, and record how big it is.
   We need this info to record proper virtual function table information
   for this class's virtual functions.  */

static int
attach_fields_to_type (struct field_info *fip, struct type *type,
		       struct objfile *objfile)
{
  int nfields = 0;
  int non_public_fields = 0;
  struct nextfield *scan;

  /* Count up the number of fields that we have, as well as taking note of
     whether or not there are any non-public fields, which requires us to
     allocate and build the private_field_bits and protected_field_bits
     bitfields.  */

  for (scan = fip->list; scan != NULL; scan = scan->next)
    {
      nfields++;
      if (scan->visibility != VISIBILITY_PUBLIC)
	{
	  non_public_fields++;
	}
    }

  /* Now we know how many fields there are, and whether or not there are any
     non-public fields.  Record the field count, allocate space for the
     array of fields, and create blank visibility bitfields if necessary.  */

  TYPE_NFIELDS (type) = nfields;
  TYPE_FIELDS (type) = (struct field *)
    TYPE_ALLOC (type, sizeof (struct field) * nfields);
  memset (TYPE_FIELDS (type), 0, sizeof (struct field) * nfields);

  if (non_public_fields)
    {
      ALLOCATE_CPLUS_STRUCT_TYPE (type);

      TYPE_FIELD_PRIVATE_BITS (type) =
	(B_TYPE *) TYPE_ALLOC (type, B_BYTES (nfields));
      B_CLRALL (TYPE_FIELD_PRIVATE_BITS (type), nfields);

      TYPE_FIELD_PROTECTED_BITS (type) =
	(B_TYPE *) TYPE_ALLOC (type, B_BYTES (nfields));
      B_CLRALL (TYPE_FIELD_PROTECTED_BITS (type), nfields);

      TYPE_FIELD_IGNORE_BITS (type) =
	(B_TYPE *) TYPE_ALLOC (type, B_BYTES (nfields));
      B_CLRALL (TYPE_FIELD_IGNORE_BITS (type), nfields);
    }

  /* Copy the saved-up fields into the field vector.  Start from the
     head of the list, adding to the tail of the field array, so that
     they end up in the same order in the array in which they were
     added to the list.  */

  while (nfields-- > 0)
    {
      TYPE_FIELD (type, nfields) = fip->list->field;
      switch (fip->list->visibility)
	{
	case VISIBILITY_PRIVATE:
	  SET_TYPE_FIELD_PRIVATE (type, nfields);
	  break;

	case VISIBILITY_PROTECTED:
	  SET_TYPE_FIELD_PROTECTED (type, nfields);
	  break;

	case VISIBILITY_IGNORE:
	  SET_TYPE_FIELD_IGNORE (type, nfields);
	  break;

	case VISIBILITY_PUBLIC:
	  break;

	default:
	  /* Unknown visibility.  Complain and treat it as public.  */
	  {
	    complaint (&symfile_complaints,
		       _("Unknown visibility `%c' for field"),
		       fip->list->visibility);
	  }
	  break;
	}
      fip->list = fip->list->next;
    }
  return 1;
}


/* Complain that the compiler has emitted more than one definition for the
   structure type TYPE.  */
static void 
complain_about_struct_wipeout (struct type *type)
{
  const char *name = "";
  const char *kind = "";

  if (TYPE_TAG_NAME (type))
    {
      name = TYPE_TAG_NAME (type);
      switch (TYPE_CODE (type))
        {
        case TYPE_CODE_STRUCT: kind = "struct "; break;
        case TYPE_CODE_UNION:  kind = "union ";  break;
        case TYPE_CODE_ENUM:   kind = "enum ";   break;
        default: kind = "";
        }
    }
  else if (TYPE_NAME (type))
    {
      name = TYPE_NAME (type);
      kind = "";
    }
  else
    {
      name = "<unknown>";
      kind = "";
    }

  complaint (&symfile_complaints,
	     _("struct/union type gets multiply defined: %s%s"), kind, name);
}

/* Set the length for all variants of a same main_type, which are
   connected in the closed chain.
   
   This is something that needs to be done when a type is defined *after*
   some cross references to this type have already been read.  Consider
   for instance the following scenario where we have the following two
   stabs entries:

        .stabs  "t:p(0,21)=*(0,22)=k(0,23)=xsdummy:",160,0,28,-24
        .stabs  "dummy:T(0,23)=s16x:(0,1),0,3[...]"

   A stubbed version of type dummy is created while processing the first
   stabs entry.  The length of that type is initially set to zero, since
   it is unknown at this point.  Also, a "constant" variation of type
   "dummy" is created as well (this is the "(0,22)=k(0,23)" section of
   the stabs line).

   The second stabs entry allows us to replace the stubbed definition
   with the real definition.  However, we still need to adjust the length
   of the "constant" variation of that type, as its length was left
   untouched during the main type replacement...  */

static void
set_length_in_type_chain (struct type *type)
{
  struct type *ntype = TYPE_CHAIN (type);

  while (ntype != type)
    {
      if (TYPE_LENGTH(ntype) == 0)
	TYPE_LENGTH (ntype) = TYPE_LENGTH (type);
      else
        complain_about_struct_wipeout (ntype);
      ntype = TYPE_CHAIN (ntype);
    }
}

/* Read the description of a structure (or union type) and return an object
   describing the type.

   PP points to a character pointer that points to the next unconsumed token
   in the stabs string.  For example, given stabs "A:T4=s4a:1,0,32;;",
   *PP will point to "4a:1,0,32;;".

   TYPE points to an incomplete type that needs to be filled in.

   OBJFILE points to the current objfile from which the stabs information is
   being read.  (Note that it is redundant in that TYPE also contains a pointer
   to this same objfile, so it might be a good idea to eliminate it.  FIXME). 
 */

static struct type *
read_struct_type (char **pp, struct type *type, enum type_code type_code,
                  struct objfile *objfile)
{
  struct cleanup *back_to;
  struct field_info fi;

  fi.list = NULL;
  fi.fnlist = NULL;

  /* When describing struct/union/class types in stabs, G++ always drops
     all qualifications from the name.  So if you've got:
       struct A { ... struct B { ... }; ... };
     then G++ will emit stabs for `struct A::B' that call it simply
     `struct B'.  Obviously, if you've got a real top-level definition for
     `struct B', or other nested definitions, this is going to cause
     problems.

     Obviously, GDB can't fix this by itself, but it can at least avoid
     scribbling on existing structure type objects when new definitions
     appear.  */
  if (! (TYPE_CODE (type) == TYPE_CODE_UNDEF
         || TYPE_STUB (type)))
    {
      complain_about_struct_wipeout (type);

      /* It's probably best to return the type unchanged.  */
      return type;
    }

  back_to = make_cleanup (null_cleanup, 0);

  INIT_CPLUS_SPECIFIC (type);
  TYPE_CODE (type) = type_code;
  TYPE_STUB (type) = 0;

  /* First comes the total size in bytes.  */

  {
    int nbits;

    TYPE_LENGTH (type) = read_huge_number (pp, 0, &nbits, 0);
    if (nbits != 0)
      {
	do_cleanups (back_to);
	return error_type (pp, objfile);
      }
    set_length_in_type_chain (type);
  }

  /* Now read the baseclasses, if any, read the regular C struct or C++
     class member fields, attach the fields to the type, read the C++
     member functions, attach them to the type, and then read any tilde
     field (baseclass specifier for the class holding the main vtable).  */

  if (!read_baseclasses (&fi, pp, type, objfile)
      || !read_struct_fields (&fi, pp, type, objfile)
      || !attach_fields_to_type (&fi, type, objfile)
      || !read_member_functions (&fi, pp, type, objfile)
      || !attach_fn_fields_to_type (&fi, type)
      || !read_tilde_fields (&fi, pp, type, objfile))
    {
      type = error_type (pp, objfile);
    }

  do_cleanups (back_to);
  return (type);
}

/* Read a definition of an array type,
   and create and return a suitable type object.
   Also creates a range type which represents the bounds of that
   array.  */

static struct type *
read_array_type (char **pp, struct type *type,
		 struct objfile *objfile)
{
  struct type *index_type, *element_type, *range_type;
  int lower, upper;
  int adjustable = 0;
  int nbits;

  /* Format of an array type:
     "ar<index type>;lower;upper;<array_contents_type>".
     OS9000: "arlower,upper;<array_contents_type>".

     Fortran adjustable arrays use Adigits or Tdigits for lower or upper;
     for these, produce a type like float[][].  */

    {
      index_type = read_type (pp, objfile);
      if (**pp != ';')
	/* Improper format of array type decl.  */
	return error_type (pp, objfile);
      ++*pp;
    }

  if (!(**pp >= '0' && **pp <= '9') && **pp != '-')
    {
      (*pp)++;
      adjustable = 1;
    }
  lower = read_huge_number (pp, ';', &nbits, 0);

  if (nbits != 0)
    return error_type (pp, objfile);

  if (!(**pp >= '0' && **pp <= '9') && **pp != '-')
    {
      (*pp)++;
      adjustable = 1;
    }
  upper = read_huge_number (pp, ';', &nbits, 0);
  if (nbits != 0)
    return error_type (pp, objfile);

  element_type = read_type (pp, objfile);

  if (adjustable)
    {
      lower = 0;
      upper = -1;
    }

  range_type =
    create_range_type ((struct type *) NULL, index_type, lower, upper);
  type = create_array_type (type, element_type, range_type);

  return type;
}


/* Read a definition of an enumeration type,
   and create and return a suitable type object.
   Also defines the symbols that represent the values of the type.  */

static struct type *
read_enum_type (char **pp, struct type *type,
		struct objfile *objfile)
{
  struct gdbarch *gdbarch = get_objfile_arch (objfile);
  char *p;
  char *name;
  long n;
  struct symbol *sym;
  int nsyms = 0;
  struct pending **symlist;
  struct pending *osyms, *syms;
  int o_nsyms;
  int nbits;
  int unsigned_enum = 1;

#if 0
  /* FIXME!  The stabs produced by Sun CC merrily define things that ought
     to be file-scope, between N_FN entries, using N_LSYM.  What's a mother
     to do?  For now, force all enum values to file scope.  */
  if (within_function)
    symlist = &local_symbols;
  else
#endif
    symlist = &file_symbols;
  osyms = *symlist;
  o_nsyms = osyms ? osyms->nsyms : 0;

  /* The aix4 compiler emits an extra field before the enum members;
     my guess is it's a type of some sort.  Just ignore it.  */
  if (**pp == '-')
    {
      /* Skip over the type.  */
      while (**pp != ':')
	(*pp)++;

      /* Skip over the colon.  */
      (*pp)++;
    }

  /* Read the value-names and their values.
     The input syntax is NAME:VALUE,NAME:VALUE, and so on.
     A semicolon or comma instead of a NAME means the end.  */
  while (**pp && **pp != ';' && **pp != ',')
    {
      STABS_CONTINUE (pp, objfile);
      p = *pp;
      while (*p != ':')
	p++;
      name = obstack_copy0 (&objfile->objfile_obstack, *pp, p - *pp);
      *pp = p + 1;
      n = read_huge_number (pp, ',', &nbits, 0);
      if (nbits != 0)
	return error_type (pp, objfile);

      sym = allocate_symbol (objfile);
      SYMBOL_SET_LINKAGE_NAME (sym, name);
      SYMBOL_SET_LANGUAGE (sym, current_subfile->language,
			   &objfile->objfile_obstack);
      SYMBOL_ACLASS_INDEX (sym) = LOC_CONST;
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
      SYMBOL_VALUE (sym) = n;
      if (n < 0)
	unsigned_enum = 0;
      add_symbol_to_list (sym, symlist);
      nsyms++;
    }

  if (**pp == ';')
    (*pp)++;			/* Skip the semicolon.  */

  /* Now fill in the fields of the type-structure.  */

  TYPE_LENGTH (type) = gdbarch_int_bit (gdbarch) / HOST_CHAR_BIT;
  set_length_in_type_chain (type);
  TYPE_CODE (type) = TYPE_CODE_ENUM;
  TYPE_STUB (type) = 0;
  if (unsigned_enum)
    TYPE_UNSIGNED (type) = 1;
  TYPE_NFIELDS (type) = nsyms;
  TYPE_FIELDS (type) = (struct field *)
    TYPE_ALLOC (type, sizeof (struct field) * nsyms);
  memset (TYPE_FIELDS (type), 0, sizeof (struct field) * nsyms);

  /* Find the symbols for the values and put them into the type.
     The symbols can be found in the symlist that we put them on
     to cause them to be defined.  osyms contains the old value
     of that symlist; everything up to there was defined by us.  */
  /* Note that we preserve the order of the enum constants, so
     that in something like "enum {FOO, LAST_THING=FOO}" we print
     FOO, not LAST_THING.  */

  for (syms = *symlist, n = nsyms - 1; syms; syms = syms->next)
    {
      int last = syms == osyms ? o_nsyms : 0;
      int j = syms->nsyms;

      for (; --j >= last; --n)
	{
	  struct symbol *xsym = syms->symbol[j];

	  SYMBOL_TYPE (xsym) = type;
	  TYPE_FIELD_NAME (type, n) = SYMBOL_LINKAGE_NAME (xsym);
	  SET_FIELD_ENUMVAL (TYPE_FIELD (type, n), SYMBOL_VALUE (xsym));
	  TYPE_FIELD_BITSIZE (type, n) = 0;
	}
      if (syms == osyms)
	break;
    }

  return type;
}

/* Sun's ACC uses a somewhat saner method for specifying the builtin
   typedefs in every file (for int, long, etc):

   type = b <signed> <width> <format type>; <offset>; <nbits>
   signed = u or s.
   optional format type = c or b for char or boolean.
   offset = offset from high order bit to start bit of type.
   width is # bytes in object of this type, nbits is # bits in type.

   The width/offset stuff appears to be for small objects stored in
   larger ones (e.g. `shorts' in `int' registers).  We ignore it for now,
   FIXME.  */

static struct type *
read_sun_builtin_type (char **pp, int typenums[2], struct objfile *objfile)
{
  int type_bits;
  int nbits;
  int signed_type;
  enum type_code code = TYPE_CODE_INT;

  switch (**pp)
    {
    case 's':
      signed_type = 1;
      break;
    case 'u':
      signed_type = 0;
      break;
    default:
      return error_type (pp, objfile);
    }
  (*pp)++;

  /* For some odd reason, all forms of char put a c here.  This is strange
     because no other type has this honor.  We can safely ignore this because
     we actually determine 'char'acterness by the number of bits specified in
     the descriptor.
     Boolean forms, e.g Fortran logical*X, put a b here.  */

  if (**pp == 'c')
    (*pp)++;
  else if (**pp == 'b')
    {
      code = TYPE_CODE_BOOL;
      (*pp)++;
    }

  /* The first number appears to be the number of bytes occupied
     by this type, except that unsigned short is 4 instead of 2.
     Since this information is redundant with the third number,
     we will ignore it.  */
  read_huge_number (pp, ';', &nbits, 0);
  if (nbits != 0)
    return error_type (pp, objfile);

  /* The second number is always 0, so ignore it too.  */
  read_huge_number (pp, ';', &nbits, 0);
  if (nbits != 0)
    return error_type (pp, objfile);

  /* The third number is the number of bits for this type.  */
  type_bits = read_huge_number (pp, 0, &nbits, 0);
  if (nbits != 0)
    return error_type (pp, objfile);
  /* The type *should* end with a semicolon.  If it are embedded
     in a larger type the semicolon may be the only way to know where
     the type ends.  If this type is at the end of the stabstring we
     can deal with the omitted semicolon (but we don't have to like
     it).  Don't bother to complain(), Sun's compiler omits the semicolon
     for "void".  */
  if (**pp == ';')
    ++(*pp);

  if (type_bits == 0)
    return init_type (TYPE_CODE_VOID, 1,
		      signed_type ? 0 : TYPE_FLAG_UNSIGNED, (char *) NULL,
		      objfile);
  else
    return init_type (code,
		      type_bits / TARGET_CHAR_BIT,
		      signed_type ? 0 : TYPE_FLAG_UNSIGNED, (char *) NULL,
		      objfile);
}

static struct type *
read_sun_floating_type (char **pp, int typenums[2], struct objfile *objfile)
{
  int nbits;
  int details;
  int nbytes;
  struct type *rettype;

  /* The first number has more details about the type, for example
     FN_COMPLEX.  */
  details = read_huge_number (pp, ';', &nbits, 0);
  if (nbits != 0)
    return error_type (pp, objfile);

  /* The second number is the number of bytes occupied by this type.  */
  nbytes = read_huge_number (pp, ';', &nbits, 0);
  if (nbits != 0)
    return error_type (pp, objfile);

  if (details == NF_COMPLEX || details == NF_COMPLEX16
      || details == NF_COMPLEX32)
    {
      rettype = init_type (TYPE_CODE_COMPLEX, nbytes, 0, NULL, objfile);
      TYPE_TARGET_TYPE (rettype)
	= init_type (TYPE_CODE_FLT, nbytes / 2, 0, NULL, objfile);
      return rettype;
    }

  return init_type (TYPE_CODE_FLT, nbytes, 0, NULL, objfile);
}

/* Read a number from the string pointed to by *PP.
   The value of *PP is advanced over the number.
   If END is nonzero, the character that ends the
   number must match END, or an error happens;
   and that character is skipped if it does match.
   If END is zero, *PP is left pointing to that character.

   If TWOS_COMPLEMENT_BITS is set to a strictly positive value and if
   the number is represented in an octal representation, assume that
   it is represented in a 2's complement representation with a size of
   TWOS_COMPLEMENT_BITS.

   If the number fits in a long, set *BITS to 0 and return the value.
   If not, set *BITS to be the number of bits in the number and return 0.

   If encounter garbage, set *BITS to -1 and return 0.  */

static long
read_huge_number (char **pp, int end, int *bits, int twos_complement_bits)
{
  char *p = *pp;
  int sign = 1;
  int sign_bit = 0;
  long n = 0;
  int radix = 10;
  char overflow = 0;
  int nbits = 0;
  int c;
  long upper_limit;
  int twos_complement_representation = 0;

  if (*p == '-')
    {
      sign = -1;
      p++;
    }

  /* Leading zero means octal.  GCC uses this to output values larger
     than an int (because that would be hard in decimal).  */
  if (*p == '0')
    {
      radix = 8;
      p++;
    }

  /* Skip extra zeros.  */
  while (*p == '0')
    p++;

  if (sign > 0 && radix == 8 && twos_complement_bits > 0)
    {
      /* Octal, possibly signed.  Check if we have enough chars for a
	 negative number.  */

      size_t len;
      char *p1 = p;

      while ((c = *p1) >= '0' && c < '8')
	p1++;

      len = p1 - p;
      if (len > twos_complement_bits / 3
	  || (twos_complement_bits % 3 == 0
	      && len == twos_complement_bits / 3))
	{
	  /* Ok, we have enough characters for a signed value, check
	     for signness by testing if the sign bit is set.  */
	  sign_bit = (twos_complement_bits % 3 + 2) % 3;
	  c = *p - '0';
	  if (c & (1 << sign_bit))
	    {
	      /* Definitely signed.  */
	      twos_complement_representation = 1;
	      sign = -1;
	    }
	}
    }

  upper_limit = LONG_MAX / radix;

  while ((c = *p++) >= '0' && c < ('0' + radix))
    {
      if (n <= upper_limit)
        {
          if (twos_complement_representation)
            {
	      /* Octal, signed, twos complement representation.  In
		 this case, n is the corresponding absolute value.  */
	      if (n == 0)
		{
		  long sn = c - '0' - ((2 * (c - '0')) | (2 << sign_bit));

		  n = -sn;
		}
              else
                {
                  n *= radix;
                  n -= c - '0';
                }
            }
          else
            {
              /* unsigned representation */
              n *= radix;
              n += c - '0';		/* FIXME this overflows anyway.  */
            }
        }
      else
        overflow = 1;

      /* This depends on large values being output in octal, which is
         what GCC does.  */
      if (radix == 8)
	{
	  if (nbits == 0)
	    {
	      if (c == '0')
		/* Ignore leading zeroes.  */
		;
	      else if (c == '1')
		nbits = 1;
	      else if (c == '2' || c == '3')
		nbits = 2;
	      else
		nbits = 3;
	    }
	  else
	    nbits += 3;
	}
    }
  if (end)
    {
      if (c && c != end)
	{
	  if (bits != NULL)
	    *bits = -1;
	  return 0;
	}
    }
  else
    --p;

  if (radix == 8 && twos_complement_bits > 0 && nbits > twos_complement_bits)
    {
      /* We were supposed to parse a number with maximum
	 TWOS_COMPLEMENT_BITS bits, but something went wrong.  */
      if (bits != NULL)
	*bits = -1;
      return 0;
    }

  *pp = p;
  if (overflow)
    {
      if (nbits == 0)
	{
	  /* Large decimal constants are an error (because it is hard to
	     count how many bits are in them).  */
	  if (bits != NULL)
	    *bits = -1;
	  return 0;
	}

      /* -0x7f is the same as 0x80.  So deal with it by adding one to
         the number of bits.  Two's complement represention octals
         can't have a '-' in front.  */
      if (sign == -1 && !twos_complement_representation)
	++nbits;
      if (bits)
	*bits = nbits;
    }
  else
    {
      if (bits)
	*bits = 0;
      return n * sign;
    }
  /* It's *BITS which has the interesting information.  */
  return 0;
}

static struct type *
read_range_type (char **pp, int typenums[2], int type_size,
                 struct objfile *objfile)
{
  struct gdbarch *gdbarch = get_objfile_arch (objfile);
  char *orig_pp = *pp;
  int rangenums[2];
  long n2, n3;
  int n2bits, n3bits;
  int self_subrange;
  struct type *result_type;
  struct type *index_type = NULL;

  /* First comes a type we are a subrange of.
     In C it is usually 0, 1 or the type being defined.  */
  if (read_type_number (pp, rangenums) != 0)
    return error_type (pp, objfile);
  self_subrange = (rangenums[0] == typenums[0] &&
		   rangenums[1] == typenums[1]);

  if (**pp == '=')
    {
      *pp = orig_pp;
      index_type = read_type (pp, objfile);
    }

  /* A semicolon should now follow; skip it.  */
  if (**pp == ';')
    (*pp)++;

  /* The remaining two operands are usually lower and upper bounds
     of the range.  But in some special cases they mean something else.  */
  n2 = read_huge_number (pp, ';', &n2bits, type_size);
  n3 = read_huge_number (pp, ';', &n3bits, type_size);

  if (n2bits == -1 || n3bits == -1)
    return error_type (pp, objfile);

  if (index_type)
    goto handle_true_range;

  /* If limits are huge, must be large integral type.  */
  if (n2bits != 0 || n3bits != 0)
    {
      char got_signed = 0;
      char got_unsigned = 0;
      /* Number of bits in the type.  */
      int nbits = 0;

      /* If a type size attribute has been specified, the bounds of
         the range should fit in this size.  If the lower bounds needs
         more bits than the upper bound, then the type is signed.  */
      if (n2bits <= type_size && n3bits <= type_size)
        {
          if (n2bits == type_size && n2bits > n3bits)
            got_signed = 1;
          else
            got_unsigned = 1;
          nbits = type_size;
        }
      /* Range from 0 to <large number> is an unsigned large integral type.  */
      else if ((n2bits == 0 && n2 == 0) && n3bits != 0)
	{
	  got_unsigned = 1;
	  nbits = n3bits;
	}
      /* Range from <large number> to <large number>-1 is a large signed
         integral type.  Take care of the case where <large number> doesn't
         fit in a long but <large number>-1 does.  */
      else if ((n2bits != 0 && n3bits != 0 && n2bits == n3bits + 1)
	       || (n2bits != 0 && n3bits == 0
		   && (n2bits == sizeof (long) * HOST_CHAR_BIT)
		   && n3 == LONG_MAX))
	{
	  got_signed = 1;
	  nbits = n2bits;
	}

      if (got_signed || got_unsigned)
	{
	  return init_type (TYPE_CODE_INT, nbits / TARGET_CHAR_BIT,
			    got_unsigned ? TYPE_FLAG_UNSIGNED : 0, NULL,
			    objfile);
	}
      else
	return error_type (pp, objfile);
    }

  /* A type defined as a subrange of itself, with bounds both 0, is void.  */
  if (self_subrange && n2 == 0 && n3 == 0)
    return init_type (TYPE_CODE_VOID, 1, 0, NULL, objfile);

  /* If n3 is zero and n2 is positive, we want a floating type, and n2
     is the width in bytes.

     Fortran programs appear to use this for complex types also.  To
     distinguish between floats and complex, g77 (and others?)  seem
     to use self-subranges for the complexes, and subranges of int for
     the floats.

     Also note that for complexes, g77 sets n2 to the size of one of
     the member floats, not the whole complex beast.  My guess is that
     this was to work well with pre-COMPLEX versions of gdb.  */

  if (n3 == 0 && n2 > 0)
    {
      struct type *float_type
	= init_type (TYPE_CODE_FLT, n2, 0, NULL, objfile);

      if (self_subrange)
	{
	  struct type *complex_type = 
	    init_type (TYPE_CODE_COMPLEX, 2 * n2, 0, NULL, objfile);

	  TYPE_TARGET_TYPE (complex_type) = float_type;
	  return complex_type;
	}
      else
	return float_type;
    }

  /* If the upper bound is -1, it must really be an unsigned integral.  */

  else if (n2 == 0 && n3 == -1)
    {
      int bits = type_size;

      if (bits <= 0)
	{
	  /* We don't know its size.  It is unsigned int or unsigned
	     long.  GCC 2.3.3 uses this for long long too, but that is
	     just a GDB 3.5 compatibility hack.  */
	  bits = gdbarch_int_bit (gdbarch);
	}

      return init_type (TYPE_CODE_INT, bits / TARGET_CHAR_BIT,
			TYPE_FLAG_UNSIGNED, NULL, objfile);
    }

  /* Special case: char is defined (Who knows why) as a subrange of
     itself with range 0-127.  */
  else if (self_subrange && n2 == 0 && n3 == 127)
    return init_type (TYPE_CODE_INT, 1, TYPE_FLAG_NOSIGN, NULL, objfile);

  /* We used to do this only for subrange of self or subrange of int.  */
  else if (n2 == 0)
    {
      /* -1 is used for the upper bound of (4 byte) "unsigned int" and
         "unsigned long", and we already checked for that,
         so don't need to test for it here.  */

      if (n3 < 0)
	/* n3 actually gives the size.  */
	return init_type (TYPE_CODE_INT, -n3, TYPE_FLAG_UNSIGNED,
			  NULL, objfile);

      /* Is n3 == 2**(8n)-1 for some integer n?  Then it's an
         unsigned n-byte integer.  But do require n to be a power of
         two; we don't want 3- and 5-byte integers flying around.  */
      {
	int bytes;
	unsigned long bits;

	bits = n3;
	for (bytes = 0; (bits & 0xff) == 0xff; bytes++)
	  bits >>= 8;
	if (bits == 0
	    && ((bytes - 1) & bytes) == 0) /* "bytes is a power of two" */
	  return init_type (TYPE_CODE_INT, bytes, TYPE_FLAG_UNSIGNED, NULL,
			    objfile);
      }
    }
  /* I think this is for Convex "long long".  Since I don't know whether
     Convex sets self_subrange, I also accept that particular size regardless
     of self_subrange.  */
  else if (n3 == 0 && n2 < 0
	   && (self_subrange
	       || n2 == -gdbarch_long_long_bit
			  (gdbarch) / TARGET_CHAR_BIT))
    return init_type (TYPE_CODE_INT, -n2, 0, NULL, objfile);
  else if (n2 == -n3 - 1)
    {
      if (n3 == 0x7f)
	return init_type (TYPE_CODE_INT, 1, 0, NULL, objfile);
      if (n3 == 0x7fff)
	return init_type (TYPE_CODE_INT, 2, 0, NULL, objfile);
      if (n3 == 0x7fffffff)
	return init_type (TYPE_CODE_INT, 4, 0, NULL, objfile);
    }

  /* We have a real range type on our hands.  Allocate space and
     return a real pointer.  */
handle_true_range:

  if (self_subrange)
    index_type = objfile_type (objfile)->builtin_int;
  else
    index_type = *dbx_lookup_type (rangenums, objfile);
  if (index_type == NULL)
    {
      /* Does this actually ever happen?  Is that why we are worrying
         about dealing with it rather than just calling error_type?  */

      complaint (&symfile_complaints,
		 _("base type %d of range type is not defined"), rangenums[1]);

      index_type = objfile_type (objfile)->builtin_int;
    }

  result_type = create_range_type ((struct type *) NULL, index_type, n2, n3);
  return (result_type);
}

/* Read in an argument list.  This is a list of types, separated by commas
   and terminated with END.  Return the list of types read in, or NULL
   if there is an error.  */

static struct field *
read_args (char **pp, int end, struct objfile *objfile, int *nargsp,
	   int *varargsp)
{
  /* FIXME!  Remove this arbitrary limit!  */
  struct type *types[1024];	/* Allow for fns of 1023 parameters.  */
  int n = 0, i;
  struct field *rval;

  while (**pp != end)
    {
      if (**pp != ',')
	/* Invalid argument list: no ','.  */
	return NULL;
      (*pp)++;
      STABS_CONTINUE (pp, objfile);
      types[n++] = read_type (pp, objfile);
    }
  (*pp)++;			/* get past `end' (the ':' character).  */

  if (n == 0)
    {
      /* We should read at least the THIS parameter here.  Some broken stabs
	 output contained `(0,41),(0,42)=@@s8;-16;,(0,43),(0,1);' where should
	 have been present ";-16,(0,43)" reference instead.  This way the
	 excessive ";" marker prematurely stops the parameters parsing.  */

      complaint (&symfile_complaints, _("Invalid (empty) method arguments"));
      *varargsp = 0;
    }
  else if (TYPE_CODE (types[n - 1]) != TYPE_CODE_VOID)
    *varargsp = 1;
  else
    {
      n--;
      *varargsp = 0;
    }

  rval = (struct field *) xmalloc (n * sizeof (struct field));
  memset (rval, 0, n * sizeof (struct field));
  for (i = 0; i < n; i++)
    rval[i].type = types[i];
  *nargsp = n;
  return rval;
}

/* Common block handling.  */

/* List of symbols declared since the last BCOMM.  This list is a tail
   of local_symbols.  When ECOMM is seen, the symbols on the list
   are noted so their proper addresses can be filled in later,
   using the common block base address gotten from the assembler
   stabs.  */

static struct pending *common_block;
static int common_block_i;

/* Name of the current common block.  We get it from the BCOMM instead of the
   ECOMM to match IBM documentation (even though IBM puts the name both places
   like everyone else).  */
static char *common_block_name;

/* Process a N_BCOMM symbol.  The storage for NAME is not guaranteed
   to remain after this function returns.  */

void
common_block_start (char *name, struct objfile *objfile)
{
  if (common_block_name != NULL)
    {
      complaint (&symfile_complaints,
		 _("Invalid symbol data: common block within common block"));
    }
  common_block = local_symbols;
  common_block_i = local_symbols ? local_symbols->nsyms : 0;
  common_block_name = obstack_copy0 (&objfile->objfile_obstack,
				     name, strlen (name));
}

/* Process a N_ECOMM symbol.  */

void
common_block_end (struct objfile *objfile)
{
  /* Symbols declared since the BCOMM are to have the common block
     start address added in when we know it.  common_block and
     common_block_i point to the first symbol after the BCOMM in
     the local_symbols list; copy the list and hang it off the
     symbol for the common block name for later fixup.  */
  int i;
  struct symbol *sym;
  struct pending *new = 0;
  struct pending *next;
  int j;

  if (common_block_name == NULL)
    {
      complaint (&symfile_complaints, _("ECOMM symbol unmatched by BCOMM"));
      return;
    }

  sym = allocate_symbol (objfile);
  /* Note: common_block_name already saved on objfile_obstack.  */
  SYMBOL_SET_LINKAGE_NAME (sym, common_block_name);
  SYMBOL_ACLASS_INDEX (sym) = LOC_BLOCK;

  /* Now we copy all the symbols which have been defined since the BCOMM.  */

  /* Copy all the struct pendings before common_block.  */
  for (next = local_symbols;
       next != NULL && next != common_block;
       next = next->next)
    {
      for (j = 0; j < next->nsyms; j++)
	add_symbol_to_list (next->symbol[j], &new);
    }

  /* Copy however much of COMMON_BLOCK we need.  If COMMON_BLOCK is
     NULL, it means copy all the local symbols (which we already did
     above).  */

  if (common_block != NULL)
    for (j = common_block_i; j < common_block->nsyms; j++)
      add_symbol_to_list (common_block->symbol[j], &new);

  SYMBOL_TYPE (sym) = (struct type *) new;

  /* Should we be putting local_symbols back to what it was?
     Does it matter?  */

  i = hashname (SYMBOL_LINKAGE_NAME (sym));
  SYMBOL_VALUE_CHAIN (sym) = global_sym_chain[i];
  global_sym_chain[i] = sym;
  common_block_name = NULL;
}

/* Add a common block's start address to the offset of each symbol
   declared to be in it (by being between a BCOMM/ECOMM pair that uses
   the common block name).  */

static void
fix_common_block (struct symbol *sym, CORE_ADDR valu)
{
  struct pending *next = (struct pending *) SYMBOL_TYPE (sym);

  for (; next; next = next->next)
    {
      int j;

      for (j = next->nsyms - 1; j >= 0; j--)
	SYMBOL_VALUE_ADDRESS (next->symbol[j]) += valu;
    }
}



/* Add {TYPE, TYPENUMS} to the NONAME_UNDEFS vector.
   See add_undefined_type for more details.  */

static void
add_undefined_type_noname (struct type *type, int typenums[2])
{
  struct nat nat;

  nat.typenums[0] = typenums [0];
  nat.typenums[1] = typenums [1];
  nat.type = type;

  if (noname_undefs_length == noname_undefs_allocated)
    {
      noname_undefs_allocated *= 2;
      noname_undefs = (struct nat *)
	xrealloc ((char *) noname_undefs,
		  noname_undefs_allocated * sizeof (struct nat));
    }
  noname_undefs[noname_undefs_length++] = nat;
}

/* Add TYPE to the UNDEF_TYPES vector.
   See add_undefined_type for more details.  */

static void
add_undefined_type_1 (struct type *type)
{
  if (undef_types_length == undef_types_allocated)
    {
      undef_types_allocated *= 2;
      undef_types = (struct type **)
	xrealloc ((char *) undef_types,
		  undef_types_allocated * sizeof (struct type *));
    }
  undef_types[undef_types_length++] = type;
}

/* What about types defined as forward references inside of a small lexical
   scope?  */
/* Add a type to the list of undefined types to be checked through
   once this file has been read in.
   
   In practice, we actually maintain two such lists: The first list
   (UNDEF_TYPES) is used for types whose name has been provided, and
   concerns forward references (eg 'xs' or 'xu' forward references);
   the second list (NONAME_UNDEFS) is used for types whose name is
   unknown at creation time, because they were referenced through
   their type number before the actual type was declared.
   This function actually adds the given type to the proper list.  */

static void
add_undefined_type (struct type *type, int typenums[2])
{
  if (TYPE_TAG_NAME (type) == NULL)
    add_undefined_type_noname (type, typenums);
  else
    add_undefined_type_1 (type);
}

/* Try to fix all undefined types pushed on the UNDEF_TYPES vector.  */

static void
cleanup_undefined_types_noname (struct objfile *objfile)
{
  int i;

  for (i = 0; i < noname_undefs_length; i++)
    {
      struct nat nat = noname_undefs[i];
      struct type **type;

      type = dbx_lookup_type (nat.typenums, objfile);
      if (nat.type != *type && TYPE_CODE (*type) != TYPE_CODE_UNDEF)
        {
          /* The instance flags of the undefined type are still unset,
             and needs to be copied over from the reference type.
             Since replace_type expects them to be identical, we need
             to set these flags manually before hand.  */
          TYPE_INSTANCE_FLAGS (nat.type) = TYPE_INSTANCE_FLAGS (*type);
          replace_type (nat.type, *type);
        }
    }

  noname_undefs_length = 0;
}

/* Go through each undefined type, see if it's still undefined, and fix it
   up if possible.  We have two kinds of undefined types:

   TYPE_CODE_ARRAY:  Array whose target type wasn't defined yet.
   Fix:  update array length using the element bounds
   and the target type's length.
   TYPE_CODE_STRUCT, TYPE_CODE_UNION:  Structure whose fields were not
   yet defined at the time a pointer to it was made.
   Fix:  Do a full lookup on the struct/union tag.  */

static void
cleanup_undefined_types_1 (void)
{
  struct type **type;

  /* Iterate over every undefined type, and look for a symbol whose type
     matches our undefined type.  The symbol matches if:
       1. It is a typedef in the STRUCT domain;
       2. It has the same name, and same type code;
       3. The instance flags are identical.
     
     It is important to check the instance flags, because we have seen
     examples where the debug info contained definitions such as:

         "foo_t:t30=B31=xefoo_t:"

     In this case, we have created an undefined type named "foo_t" whose
     instance flags is null (when processing "xefoo_t"), and then created
     another type with the same name, but with different instance flags
     ('B' means volatile).  I think that the definition above is wrong,
     since the same type cannot be volatile and non-volatile at the same
     time, but we need to be able to cope with it when it happens.  The
     approach taken here is to treat these two types as different.  */

  for (type = undef_types; type < undef_types + undef_types_length; type++)
    {
      switch (TYPE_CODE (*type))
	{

	case TYPE_CODE_STRUCT:
	case TYPE_CODE_UNION:
	case TYPE_CODE_ENUM:
	  {
	    /* Check if it has been defined since.  Need to do this here
	       as well as in check_typedef to deal with the (legitimate in
	       C though not C++) case of several types with the same name
	       in different source files.  */
	    if (TYPE_STUB (*type))
	      {
		struct pending *ppt;
		int i;
		/* Name of the type, without "struct" or "union".  */
		const char *typename = TYPE_TAG_NAME (*type);

		if (typename == NULL)
		  {
		    complaint (&symfile_complaints, _("need a type name"));
		    break;
		  }
		for (ppt = file_symbols; ppt; ppt = ppt->next)
		  {
		    for (i = 0; i < ppt->nsyms; i++)
		      {
			struct symbol *sym = ppt->symbol[i];

			if (SYMBOL_CLASS (sym) == LOC_TYPEDEF
			    && SYMBOL_DOMAIN (sym) == STRUCT_DOMAIN
			    && (TYPE_CODE (SYMBOL_TYPE (sym)) ==
				TYPE_CODE (*type))
			    && (TYPE_INSTANCE_FLAGS (*type) ==
				TYPE_INSTANCE_FLAGS (SYMBOL_TYPE (sym)))
			    && strcmp (SYMBOL_LINKAGE_NAME (sym),
				       typename) == 0)
                          replace_type (*type, SYMBOL_TYPE (sym));
		      }
		  }
	      }
	  }
	  break;

	default:
	  {
	    complaint (&symfile_complaints,
		       _("forward-referenced types left unresolved, "
                       "type code %d."),
		       TYPE_CODE (*type));
	  }
	  break;
	}
    }

  undef_types_length = 0;
}

/* Try to fix all the undefined types we ecountered while processing
   this unit.  */

void
cleanup_undefined_stabs_types (struct objfile *objfile)
{
  cleanup_undefined_types_1 ();
  cleanup_undefined_types_noname (objfile);
}

/* Scan through all of the global symbols defined in the object file,
   assigning values to the debugging symbols that need to be assigned
   to.  Get these symbols from the minimal symbol table.  */

void
scan_file_globals (struct objfile *objfile)
{
  int hash;
  struct minimal_symbol *msymbol;
  struct symbol *sym, *prev;
  struct objfile *resolve_objfile;

  /* SVR4 based linkers copy referenced global symbols from shared
     libraries to the main executable.
     If we are scanning the symbols for a shared library, try to resolve
     them from the minimal symbols of the main executable first.  */

  if (symfile_objfile && objfile != symfile_objfile)
    resolve_objfile = symfile_objfile;
  else
    resolve_objfile = objfile;

  while (1)
    {
      /* Avoid expensive loop through all minimal symbols if there are
         no unresolved symbols.  */
      for (hash = 0; hash < HASHSIZE; hash++)
	{
	  if (global_sym_chain[hash])
	    break;
	}
      if (hash >= HASHSIZE)
	return;

      ALL_OBJFILE_MSYMBOLS (resolve_objfile, msymbol)
	{
	  QUIT;

	  /* Skip static symbols.  */
	  switch (MSYMBOL_TYPE (msymbol))
	    {
	    case mst_file_text:
	    case mst_file_data:
	    case mst_file_bss:
	      continue;
	    default:
	      break;
	    }

	  prev = NULL;

	  /* Get the hash index and check all the symbols
	     under that hash index.  */

	  hash = hashname (SYMBOL_LINKAGE_NAME (msymbol));

	  for (sym = global_sym_chain[hash]; sym;)
	    {
	      if (strcmp (SYMBOL_LINKAGE_NAME (msymbol),
			  SYMBOL_LINKAGE_NAME (sym)) == 0)
		{
		  /* Splice this symbol out of the hash chain and
		     assign the value we have to it.  */
		  if (prev)
		    {
		      SYMBOL_VALUE_CHAIN (prev) = SYMBOL_VALUE_CHAIN (sym);
		    }
		  else
		    {
		      global_sym_chain[hash] = SYMBOL_VALUE_CHAIN (sym);
		    }

		  /* Check to see whether we need to fix up a common block.  */
		  /* Note: this code might be executed several times for
		     the same symbol if there are multiple references.  */
		  if (sym)
		    {
		      if (SYMBOL_CLASS (sym) == LOC_BLOCK)
			{
			  fix_common_block (sym,
					    SYMBOL_VALUE_ADDRESS (msymbol));
			}
		      else
			{
			  SYMBOL_VALUE_ADDRESS (sym)
			    = SYMBOL_VALUE_ADDRESS (msymbol);
			}
		      SYMBOL_SECTION (sym) = SYMBOL_SECTION (msymbol);
		    }

		  if (prev)
		    {
		      sym = SYMBOL_VALUE_CHAIN (prev);
		    }
		  else
		    {
		      sym = global_sym_chain[hash];
		    }
		}
	      else
		{
		  prev = sym;
		  sym = SYMBOL_VALUE_CHAIN (sym);
		}
	    }
	}
      if (resolve_objfile == objfile)
	break;
      resolve_objfile = objfile;
    }

  /* Change the storage class of any remaining unresolved globals to
     LOC_UNRESOLVED and remove them from the chain.  */
  for (hash = 0; hash < HASHSIZE; hash++)
    {
      sym = global_sym_chain[hash];
      while (sym)
	{
	  prev = sym;
	  sym = SYMBOL_VALUE_CHAIN (sym);

	  /* Change the symbol address from the misleading chain value
	     to address zero.  */
	  SYMBOL_VALUE_ADDRESS (prev) = 0;

	  /* Complain about unresolved common block symbols.  */
	  if (SYMBOL_CLASS (prev) == LOC_STATIC)
	    SYMBOL_ACLASS_INDEX (prev) = LOC_UNRESOLVED;
	  else
	    complaint (&symfile_complaints,
		       _("%s: common block `%s' from "
			 "global_sym_chain unresolved"),
		       objfile_name (objfile), SYMBOL_PRINT_NAME (prev));
	}
    }
  memset (global_sym_chain, 0, sizeof (global_sym_chain));
}

/* Initialize anything that needs initializing when starting to read
   a fresh piece of a symbol file, e.g. reading in the stuff corresponding
   to a psymtab.  */

void
stabsread_init (void)
{
}

/* Initialize anything that needs initializing when a completely new
   symbol file is specified (not just adding some symbols from another
   file, e.g. a shared library).  */

void
stabsread_new_init (void)
{
  /* Empty the hash table of global syms looking for values.  */
  memset (global_sym_chain, 0, sizeof (global_sym_chain));
}

/* Initialize anything that needs initializing at the same time as
   start_symtab() is called.  */

void
start_stabs (void)
{
  global_stabs = NULL;		/* AIX COFF */
  /* Leave FILENUM of 0 free for builtin types and this file's types.  */
  n_this_object_header_files = 1;
  type_vector_length = 0;
  type_vector = (struct type **) 0;

  /* FIXME: If common_block_name is not already NULL, we should complain().  */
  common_block_name = NULL;
}

/* Call after end_symtab().  */

void
end_stabs (void)
{
  if (type_vector)
    {
      xfree (type_vector);
    }
  type_vector = 0;
  type_vector_length = 0;
  previous_stab_code = 0;
}

void
finish_global_stabs (struct objfile *objfile)
{
  if (global_stabs)
    {
      patch_block_stabs (global_symbols, global_stabs, objfile);
      xfree (global_stabs);
      global_stabs = NULL;
    }
}

/* Find the end of the name, delimited by a ':', but don't match
   ObjC symbols which look like -[Foo bar::]:bla.  */
static char *
find_name_end (char *name)
{
  char *s = name;

  if (s[0] == '-' || *s == '+')
    {
      /* Must be an ObjC method symbol.  */
      if (s[1] != '[')
	{
	  error (_("invalid symbol name \"%s\""), name);
	}
      s = strchr (s, ']');
      if (s == NULL)
	{
	  error (_("invalid symbol name \"%s\""), name);
	}
      return strchr (s, ':');
    }
  else
    {
      return strchr (s, ':');
    }
}

/* Initializer for this module.  */

void
_initialize_stabsread (void)
{
  rs6000_builtin_type_data = register_objfile_data ();

  undef_types_allocated = 20;
  undef_types_length = 0;
  undef_types = (struct type **)
    xmalloc (undef_types_allocated * sizeof (struct type *));

  noname_undefs_allocated = 20;
  noname_undefs_length = 0;
  noname_undefs = (struct nat *)
    xmalloc (noname_undefs_allocated * sizeof (struct nat));

  stab_register_index = register_symbol_register_impl (LOC_REGISTER,
						       &stab_register_funcs);
  stab_regparm_index = register_symbol_register_impl (LOC_REGPARM_ADDR,
						      &stab_register_funcs);
}
@


1.157
log
@	* buildsym.c (subfile_stack): Move here from buildsym.h.
	(pending_macros): Ditto.
	(get_macro_table): New function.
	(buildsym_init): Initialize subfile_stack.
	* coffread.c (type_vector,type_vector_length): Moved here from
	buildsym.h.
	(INITIAL_TYPE_VECTOR_LENGTH): Ditto.
	(coff_symtab_read): Use it.
	* dbxread.c (read_ofile_symtab): Delete init of subfile_stack.
	* dwarf2read.c (macro_start_file): Replace uses of pending_macros
	with call to get_macro_table.
	* stabsread.c (type_vector,type_vector_length): Moved here from
	buildsym.h.
	(INITIAL_TYPE_VECTOR_LENGTH): Ditto.
	* buildsym.h (get_macro_table): Declare.
@
text
@d4735 1
a4735 1
		       objfile->name, SYMBOL_PRINT_NAME (prev));
@


1.156
log
@fix one bug in stabsread.c

Some code in stabsread.c can return without running cleanups.

	* stabsread.c (read_struct_type): Call do_cleanups along
	all return paths.
@
text
@d210 17
@


1.155
log
@	PR symtab/8424:
	* blockframe.c (find_pc_partial_function_gnu_ifunc): Check
	SYMBOL_SECTION, not SYMBOL_OBJ_SECTION.
	* breakpoint.c (resolve_sal_pc): Update.
	* elfread.c (elf_gnu_ifunc_record_cache): Update.
	* findvar.c (struct minsym_lookup_data) <objfile>: New field.
	(minsym_lookup_iterator_cb): Use it.
	(default_read_var_value): Update.
	* hppa-hpux-tdep.c (hppa64_hpux_in_solib_call_trampoline):
	Update.
	* infcmd.c (jump_command): Update.
	* linespec.c (minsym_found): Update.
	* maint.c (maintenance_translate_address): Update.
	* minsyms.c (lookup_minimal_symbol_by_pc_section_1): Update.
	(prim_record_minimal_symbol_full): Don't set SYMBOL_OBJ_SECTION.
	* parse.c (write_exp_msymbol): Update.
	* printcmd.c (address_info): Update.
	* psymtab.c (find_pc_sect_psymbol): Update.
	(fixup_psymbol_section): Check SYMBOL_SECTION, not
	SYMBOL_OBJ_SECTION.
	(add_psymbol_to_bcache): Correctly initialize SYMBOL_SECTION.
	Don't initialize SYMBOL_OBJ_SECTION.
	* spu-tdep.c (spu_catch_start): Update.
	* stabsread.c (define_symbol): Don't set SYMBOL_SECTION.
	* symmisc.c (dump_msymbols, print_symbol): Update.
	* symtab.c (fixup_section): Don't set 'obj_section'.  Change
	how fallback section is computed.
	(fixup_symbol_section): Update.
	(find_pc_sect_symtab, find_function_start_sal, skip_prologue_sal):
	Update.
	(allocate_symbol, initialize_symbol, allocate_template_symbol):
	Initialize SYMBOL_SECTION.
	* symtab.h (struct general_symbol_info) <section>: Update comment.
	<obj_section>: Remove.
	(SYMBOL_OBJ_SECTION): Add 'objfile' argument.  Rewrite.
	(SYMBOL_OBJFILE): New macro.
@
text
@d3518 4
a3521 1
      return error_type (pp, objfile);
@


1.154
log
@	* ada-lang.c (ada_decode_symbol): Check and set 'ada_mangled'.
	Use symbol's obstack, not an objfile.
	* coffread.c (process_coff_symbol): Update.
	* dwarf2read.c (fixup_go_packaging, new_symbol_full): Update.
	* jv-lang.c (add_class_symbol): Update.
	* mdebugread.c (new_symbol): Update.
	* minsyms.c (prim_record_minimal_symbol_full)
	(terminate_minimal_symbol_table): Update.
	* psymtab.c (add_psymbol_to_bcache): Clear entire symbol.  Update.
	* stabsread.c (define_symbol, read_enum_type): Update.
	* symtab.c (symbol_set_demangled_name, symbol_get_demangled_name):
	Handle Ada specially.
	(symbol_set_language): Add 'obstack' argument.
	(symbol_set_names): Update.
	(symbol_natural_name, symbol_demangled_name): Always use
	ada_decode_symbol.
	* symtab.h (struct general_symbol_info)
	<language_specific::obstack>: New field.
	<ada_mangled>: New field.
	(SYMBOL_SET_LANGUAGE): Add 'obstack' argument.
	(symbol_set_language): Update.
@
text
@a652 13
  switch (type & N_TYPE)
    {
    case N_TEXT:
      SYMBOL_SECTION (sym) = SECT_OFF_TEXT (objfile);
      break;
    case N_DATA:
      SYMBOL_SECTION (sym) = SECT_OFF_DATA (objfile);
      break;
    case N_BSS:
      SYMBOL_SECTION (sym) = SECT_OFF_BSS (objfile);
      break;
    }

@


1.153
log
@	* coffread.c (process_coff_symbol, coff_read_enum_type): Call
	allocate_symbol.
	* dwarf2read.c (fixup_go_packaging): Call allocate_symbol.
	(read_func_scope): Call allocate_template_symbol.
	(new_symbol_full): Call allocate_symbol.
	* jit.c (finalize_symtab): Call allocate_symbol.
	* jv-lang.c (add_class_symbol): Call allocate_symbol.
	* mdebugread.c (parse_symbol, new_block): Call allocate_symbol.
	* stabsread.c (patch_block_stabs, define_symbol, read_enum_type)
	(common_block_end): Call allocate_symbol.
	* symtab.c (allocate_symbol, initialize_symbol)
	(allocate_template_symbol): New functions.
	* symtab.c (allocate_symbol, initialize_symbol)
	(allocate_template_symbol): Declare.
	* xcoffread.c (process_xcoff_symbol): Call initialize_symbol.
@
text
@d712 2
a713 1
      SYMBOL_SET_LANGUAGE (sym, current_subfile->language);
d3679 2
a3680 1
      SYMBOL_SET_LANGUAGE (sym, current_subfile->language);
@


1.152
log
@2013-03-20  Jan Kratochvil  <jan.kratochvil@@redhat.com>
	    Tom Tromey  <tromey@@redhat.com>

	PR symtab/8421:
	* coffread.c (coff_register_index): New global.
	(process_coff_symbol, coff_read_enum_type): Set
	SYMBOL_ACLASS_INDEX.
	(_initialize_coffread): Initialize new global.
	* dwarf2loc.c (locexpr_find_frame_base_location)
	(dwarf2_block_frame_base_locexpr_funcs)
	(loclist_find_frame_base_location)
	(dwarf2_block_frame_base_loclist_funcs): New.
	(dwarf_expr_frame_base_1): Call SYMBOL_BLOCK_OPS, remove internal_error.
	(dwarf2_locexpr_funcs, dwarf2_loclist_funcs): Add location_has_loclist.
	* dwarf2loc.h (dwarf2_block_frame_base_locexpr_funcs)
	(dwarf2_block_frame_base_loclist_funcs): New.
	* dwarf2read.c (dwarf2_locexpr_index, dwarf2_loclist_index)
	(dwarf2_locexpr_block_index, dwarf2_loclist_block_index): New
	globals.
	(read_func_scope): Update.
	(fixup_go_packaging, mark_common_block_symbol_computed)
	(var_decode_location, new_symbol_full, dwarf2_const_value):
	Set SYMBOL_ACLASS_INDEX.
	(dwarf2_symbol_mark_computed): Likewise.  Add 'is_block' argument.
	(_initialize_dwarf2_read): Initialize new globals.
	* jit.c (finalize_symtab): Set SYMBOL_ACLASS_INDEX.
	* jv-lang.c (add_class_symbol): Set SYMBOL_ACLASS_INDEX.
	* mdebugread.c (mdebug_register_index, mdebug_regparm_index): New
	globals.
	(parse_symbol, psymtab_to_symtab_1): Set SYMBOL_ACLASS_INDEX.
	(_initialize_mdebugread): Initialize new globals.
	* psympriv.h (struct partial_symbol) <aclass>: Update comment.
	* stabsread.c (patch_block_stabs): Set SYMBOL_ACLASS_INDEX.
	(stab_register_index, stab_regparm_index): New globals.
	(define_symbol, read_enum_type, common_block_end): Set
	SYMBOL_ACLASS_INDEX.
	(_initialize_stabsread): Initialize new globals.
	* symtab.c (next_aclass_value, symbol_impl, symbol_impls): New
	globals.
	(MAX_SYMBOL_IMPLS): New define.
	(register_symbol_computed_impl, register_symbol_block_impl)
	(register_symbol_register_impl)
	(initialize_ordinary_address_classes): New functions.
	(_initialize_symtab): Call initialize_ordinary_address_classes.
	* symtab.h (enum address_class) <LOC_FINAL_VALUE>: New constant.
	(struct symbol_impl): New.
	(SYMBOL_ACLASS_BITS): New define.
	(struct symbol) <aclass, ops>: Remove fields.
	<aclass_index>: New field.
	(symbol_impls): Declare.
	(SYMBOL_CLASS, SYMBOL_COMPUTED_OPS, SYMBOL_REGISTER_OPS): Redefine.
	(SYMBOL_IMPL, SYMBOL_ACLASS_INDEX): New defines.
	(register_symbol_computed_impl, register_symbol_block_impl)
	(register_symbol_register_impl): Declare.
	(struct symbol_computed_ops): Add location_has_loclist.
	(struct symbol_block_ops): New.
	(SYMBOL_BLOCK_OPS): New.
	* xcoffread.c (process_xcoff_symbol): Set SYMBOL_ACLASS_INDEX.
@
text
@d382 1
a382 5
	      sym = (struct symbol *)
		obstack_alloc (&objfile->objfile_obstack,
			       sizeof (struct symbol));

	      memset (sym, 0, sizeof (struct symbol));
d651 1
a651 3
  current_symbol = sym = (struct symbol *)
    obstack_alloc (&objfile->objfile_obstack, sizeof (struct symbol));
  memset (sym, 0, sizeof (struct symbol));
d1289 1
a1289 2
          struct symbol *struct_sym = (struct symbol *)
            obstack_alloc (&objfile->objfile_obstack, sizeof (struct symbol));
d1333 1
a1333 2
	  struct symbol *typedef_sym = (struct symbol *)
	    obstack_alloc (&objfile->objfile_obstack, sizeof (struct symbol));
d3676 1
a3676 3
      sym = (struct symbol *)
	obstack_alloc (&objfile->objfile_obstack, sizeof (struct symbol));
      memset (sym, 0, sizeof (struct symbol));
d4348 1
a4348 3
  sym = (struct symbol *)
    obstack_alloc (&objfile->objfile_obstack, sizeof (struct symbol));
  memset (sym, 0, sizeof (struct symbol));
@


1.151
log
@	* symfile.h (obsavestring): Don't declare.
	* symfile.c (obsavestring): Remove.
	* ada-exp.y: Use obstack_copy0, not obsavestring.
	* ada-lang.c: Use obstack_copy0, not obsavestring.
	* coffread.c: Use obstack_copy0, not obsavestring.
	* cp-namespace.c: Use obstack_copy0, not obsavestring.
	* dbxread.c: Use obstack_copy0, not obsavestring.
	* dwarf2read.c: Use obstack_copy0, not obsavestring.
	* jit.c: Use obstack_copy0, not obsavestring.
	* mdebugread.c: Use obstack_copy0, not obsavestring.
	* psymtab.c: Use obstack_copy0, not obsavestring.
	* stabsread.c: Use obstack_copy0, not obsavestring.
	* xcoffread.c: Use obstack_copy0, not obsavestring.
@
text
@d388 1
a388 1
	      SYMBOL_CLASS (sym) = LOC_OPTIMIZED_OUT;
d607 5
d769 1
a769 1
	  SYMBOL_CLASS (sym) = LOC_CONST;
d796 1
a796 1
	    SYMBOL_CLASS (sym) = LOC_CONST_BYTES;
d810 1
a810 1
	    SYMBOL_CLASS (sym) = LOC_CONST;
d818 1
a818 1
	    SYMBOL_CLASS (sym) = LOC_CONST;
d832 1
a832 1
		SYMBOL_CLASS (sym) = LOC_CONST;
d857 1
a857 1
		SYMBOL_CLASS (sym) = LOC_CONST;
d878 1
a878 1
	    SYMBOL_CLASS (sym) = LOC_CONST_BYTES;
d888 1
a888 1
	    SYMBOL_CLASS (sym) = LOC_CONST;
d909 1
a909 1
	    SYMBOL_CLASS (sym) = LOC_CONST;
d920 1
a920 1
      SYMBOL_CLASS (sym) = LOC_LABEL;
d929 1
a929 1
      SYMBOL_CLASS (sym) = LOC_BLOCK;
d1000 1
a1000 1
      SYMBOL_CLASS (sym) = LOC_BLOCK;
d1011 1
a1011 1
      SYMBOL_CLASS (sym) = LOC_STATIC;
d1032 1
a1032 1
      SYMBOL_CLASS (sym) = LOC_LOCAL;
d1052 1
a1052 1
      SYMBOL_CLASS (sym) = LOC_ARG;
d1100 1
a1100 2
      SYMBOL_CLASS (sym) = LOC_REGISTER;
      SYMBOL_REGISTER_OPS (sym) = &stab_register_funcs;
d1110 1
a1110 2
      SYMBOL_CLASS (sym) = LOC_REGISTER;
      SYMBOL_REGISTER_OPS (sym) = &stab_register_funcs;
d1147 1
a1147 2
		  SYMBOL_CLASS (prev_sym) = LOC_REGISTER;
		  SYMBOL_REGISTER_OPS (prev_sym) = &stab_register_funcs;
d1165 1
a1165 1
      SYMBOL_CLASS (sym) = LOC_STATIC;
d1214 1
a1214 1
      SYMBOL_CLASS (sym) = LOC_TYPEDEF;
d1299 1
a1299 1
          SYMBOL_CLASS (struct_sym) = LOC_TYPEDEF;
d1327 1
a1327 1
      SYMBOL_CLASS (sym) = LOC_TYPEDEF;
d1344 1
a1344 1
	  SYMBOL_CLASS (typedef_sym) = LOC_TYPEDEF;
d1359 1
a1359 1
      SYMBOL_CLASS (sym) = LOC_STATIC;
d1386 1
a1386 1
      SYMBOL_CLASS (sym) = LOC_REF_ARG;
d1396 1
a1396 2
      SYMBOL_CLASS (sym) = LOC_REGPARM_ADDR;
      SYMBOL_REGISTER_OPS (sym) = &stab_register_funcs;
d1409 1
a1409 1
      SYMBOL_CLASS (sym) = LOC_LOCAL;
d1417 1
a1417 1
      SYMBOL_CLASS (sym) = LOC_CONST;
d1434 1
a1434 1
	SYMBOL_CLASS (sym) = LOC_REGPARM_ADDR;
d1438 1
a1438 1
	SYMBOL_CLASS (sym) = LOC_REF_ARG;
d3689 1
a3689 1
      SYMBOL_CLASS (sym) = LOC_CONST;
d4363 1
a4363 1
  SYMBOL_CLASS (sym) = LOC_BLOCK;
d4733 1
a4733 1
	    SYMBOL_CLASS (prev) = LOC_UNRESOLVED;
d4848 5
@


1.150
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d390 2
a391 2
		(sym, obsavestring (name, pp - name,
				    &objfile->objfile_obstack));
d1635 2
a1636 2
		  type_name = obsavestring (new_name, strlen (new_name),
					    &objfile->objfile_obstack);
d2715 2
a2716 2
		  = obsavestring (dem_opname, strlen (dem_opname),
				  &objfile->objfile_obstack);
d2858 1
a2858 1
    obsavestring (*pp, p - *pp, &objfile->objfile_obstack);
d3677 1
a3677 1
      name = obsavestring (*pp, p - *pp, &objfile->objfile_obstack);
d4331 2
a4332 2
  common_block_name = obsavestring (name, strlen (name),
				    &objfile->objfile_obstack);
@


1.149
log
@gdb/
	* gdbtypes.h (enum type_code): Define TYPE_CODE_BITSTRING -1.
	* arm-tdep.c (arm_type_align): Remove code handling TYPE_CODE_BITSTRING.
	* c-typeprint.c (c_type_print_varspec_prefix): Likewise.
	(c_type_print_varspec_suffix): Likewise.
	* eval.c (evaluate_subexp_standard): Likewise.
	* f-typeprint.c (f_type_print_varspec_prefix): Likewise.
	(f_type_print_varspec_suffix): Likewise.
	* gdbtypes.c (is_scalar_type): Likewise.
	(recursive_dump_type): Likewise.
	* infcall.c (value_arg_coerce): Likewise.
	* m2-valprint.c (m2_val_print): Likewise.
	* p-typeprint.c (pascal_type_print_varspec_prefix): Likewise.
	(pascal_type_print_varspec_suffix): Likewise.
	(pascal_type_print_base): Likewise.
	* p-valprint.c (pascal_val_print): Likewise.
	(pascal_val_print): Likewise.
	* valops.c (value_slice): Likewise.
	* valprint.c (scalar_type_p): Likewise.
	* valarith.c (value_bitstring_subscript): Remove.
	(value_concat): Remove code handling TYPE_CODE_BITSTRING.
	Remove comment on TYPE_CODE_BITSTRING.

	* stabsread.c (read_type): Don't set TYPE_CODE (type) to
	TYPE_CODE_BITSTRING.

	* python/py-type.c (pyty_codes): Move ENTRY (TYPE_CODE_BITSTRING) to
	slot 0.

gdb/doc:
	* gdb.texinfo (Types In Python): Mention gdb.TYPE_CODE_BITSTRING
	is deprecated.
@
text
@d3 1
a3 1
   Copyright (C) 1986-2012 Free Software Foundation, Inc.
@


1.148
log
@	* stabsread.h (cleanup_undefined_stabs_types): Renamed from
	cleanup_undefined_types.
	* stabsread.c (cleanup_undefined_stabs_types): Ditto.
	All callers updated.
@
text
@d2027 1
a2027 1
    case 'S':			/* Set or bitstring  type */
a2029 2
      if (is_string)
	TYPE_CODE (type) = TYPE_CODE_BITSTRING;
@


1.147
log
@gdb/
	PR symtab/7259:
	* ada-exp.y (convert_char_literal): Use TYPE_FIELD_ENUMVAL.
	* ada-lang.c (ada_discrete_type_high_bound)
	(ada_discrete_type_low_bound): Use TYPE_FIELD_ENUMVAL for
	TYPE_CODE_ENUM.
	(ada_identical_enum_types_p): Use TYPE_FIELD_ENUMVAL.
	(pos_atr, value_val_atr): Use TYPE_FIELD_ENUMVAL for TYPE_CODE_ENUM.
	* ada-typeprint.c (print_enum_type): Change variable lastval to LONGEST.
	Use TYPE_FIELD_ENUMVAL.
	* ada-valprint.c (print_optional_low_bound, ada_print_scalar)
	(ada_val_print_1): Use TYPE_FIELD_ENUMVAL for TYPE_CODE_ENUM.
	* c-typeprint.c (c_type_print_base): Move variable lastval to inner
	block, change it to LONGEST.  Use TYPE_FIELD_ENUMVAL for
	TYPE_CODE_ENUM.
	* coffread.c (coff_read_enum_type): Use SET_FIELD_ENUMVAL.
	* dwarf2read.c (process_enumeration_scope): Likewise.
	* gdb-gdb.py (TypeFlagsPrinter): Use field.enumval instead of
	field.bitpos.
	(class StructMainTypePrettyPrinter): Support also
	FIELD_LOC_KIND_ENUMVAL.
	* gdbtypes.c (get_discrete_bounds): Use TYPE_FIELD_ENUMVAL for
	TYPE_CODE_ENUM.
	(recursive_dump_type): Use TYPE_FIELD_ENUMVAL for TYPE_CODE_ENUM.
	(copy_type_recursive): Support also FIELD_LOC_KIND_ENUMVAL.
	* gdbtypes.h (enum field_loc_kind): New FIELD_LOC_KIND_ENUMVAL.
	(struct main_type.flds_bnds.fields.loc): Adjust bitpos comment.  New
	field enumval.
	(struct main_type.flds_bnds.bields): Adjust loc_kind and bitsize to
	accommodate enumval.
	(struct call_site): Adjust loc_kind to accommodate enumval.
	(FIELD_ENUMVAL, FIELD_ENUMVAL_LVAL, SET_FIELD_ENUMVAL)
	(TYPE_FIELD_ENUMVAL): New macros.
	* m2-typeprint.c (m2_enum): Use TYPE_FIELD_ENUMVAL.
	* mdebugread.c (parse_symbol): Use TYPE_FIELD_ENUMVAL for
	TYPE_CODE_ENUM.
	* p-typeprint.c (pascal_type_print_base): Likewise.
	* python/lib/gdb/printing.py (class FlagEnumerationPrinter): Use
	enumval.
	* python/lib/gdb/types.py (make_enum_dict): Likewise.
	* python/py-type.c (convert_field): New variable addrstring.  Use
	TYPE_FIELD_ENUMVAL for TYPE_CODE_ENUM.
	(check_types_equal): Support also FIELD_LOC_KIND_ENUMVAL.
	* stabsread.c (read_enum_type): Use SET_FIELD_ENUMVAL.
	* typepint.c (print_type_scalar): Use TYPE_FIELD_ENUMVAL for
	TYPE_CODE_ENUM.
	* valprint.c (generic_val_print): Likewise.

gdb/testsuite/
	PR symtab/7259:
	* gdb.base/enumval.c: New test case.
	* gdb.base/enumval.exp: New test case.
	* gdb.python/py-type.exp (test_enums): Use field.enumval instead of
	field.bitpos.
@
text
@d4601 1
a4601 1
cleanup_undefined_types (struct objfile *objfile)
@


1.146
log
@2012-04-17  Pedro Alves  <palves@@redhat.com>

	* gdbtypes.h (FIELD_BITPOS): Rename to ...
	(FIELD_BITPOS_LVAL): ... this.
	(FIELD_BITPOS): New.
	(SET_FIELD_BITPOS): Adjust to use FIELD_BITPOS_LVAL.
	* dwarf2read.c (dwarf2_add_field): Use SET_FIELD_BITPOS.
	* gdbtypes.c (append_composite_type_field_aligned): Adjust to use
	SET_FIELD_BITPOS.
	* gnu-v3-abi.c (build_gdb_vtable_type): Adjust to use
	SET_FIELD_BITPOS.
	* stabsread.c (read_cpp_abbrev, read_one_struct_field)
	(read_baseclasses): Adjust to use SET_FIELD_BITPOS.
	* target-descriptions.c (tdesc_gdb_type): Adjust to use
	SET_FIELD_BITPOS.
@
text
@d3734 1
a3734 1
	  SET_FIELD_BITPOS (TYPE_FIELD (type, n), SYMBOL_VALUE (xsym));
@


1.145
log
@gdb/
	Do not rely on FIELD_LOC_KIND_BITPOS being zero.
	* ada-lang.c (ada_template_to_fixed_record_type_1): Replace
	TYPE_FIELD_BITPOS used as lvalue by SET_FIELD_BITPOS.
	* gdbtypes.c (append_flags_type_flag): Likewise, twice.
	* jv-lang.c (java_link_class_type): Likewise, once.
	* stabsread.c (read_enum_type): Likewise.
@
text
@d2833 2
a2834 2
	FIELD_BITPOS (fip->list->field) = read_huge_number (pp, ';', &nbits,
                                                            0);
d2910 2
a2911 1
    FIELD_BITPOS (fip->list->field) = read_huge_number (pp, ',', &nbits, 0);
d3191 1
a3191 1
	FIELD_BITPOS (new->field) = read_huge_number (pp, ',', &nbits, 0);
@


1.144
log
@[stabs] The address of Fortran common blocks may be > INT_MAX.

gdb/
2012-03-08  Chris January  <chris.january@@allinea.com>

        * stabsread.c (fix_common_block): Change type of valu argument
        to CORE_ADDR.
@
text
@d3733 1
a3733 1
	  TYPE_FIELD_BITPOS (type, n) = SYMBOL_VALUE (xsym);
@


1.143
log
@	* gdbtypes.h (struct main_type): Change type of name,tag_name,
	and fields.name members from char * to const char *.  All uses updated.
	(struct cplus_struct_type): Change type of fn_fieldlists.name member
	from char * to const char *.  All uses updated.
	(type_name_no_tag): Update.
	(lookup_unsigned_typename, lookup_signed_typename): Update.
	* gdbtypes.c (type_name_no_tag): Change result type
	from char * to const char *.  All callers updated.
	(lookup_unsigned_typename, lookup_signed_typename): Change type of
	name parameter from char * to const char *.
	* symtab.h (struct cplus_specific): Change type of demangled_name
	member from char * to const char *.  All uses updated.
	(struct general_symbol_info): Change type of name and
	mangled_lang.demangled_name members from char * to const char *.
	All uses updated.
	(symbol_get_demangled_name, symbol_natural_name): Update.
	(symbol_demangled_name, symbol_search_name): Update.
	* symtab.c (symbol_get_demangled_name): Change result type
	from char * to const char *.  All callers updated.
	(symbol_natural_name, symbol_demangled_name): Ditto.
	(symbol_search_name): Ditto.
	(completion_list_add_name): Change type of symname,sym_text,
	text,word parameters from char * to const char *.
	(completion_list_objc_symbol): Change type of sym_text,
	text,word parameters from char * to const char *.
	* ada-lang.c (find_struct_field): Change type of name parameter
	from char * to const char *.
	(encoded_ordered_before): Similarly for N0,N1 parameters.
	(old_renaming_is_invisible): Similarly for function_name parameter.
	(ada_type_name): Change result type from char * to const char *.
	All callers updated.
	* ada-lang.h (ada_type_name): Update.
	* buildsym.c (hashname): Change type of name parameter
	from char * to const char *.
	* buildsym.h (hashname): Update.
	* dbxread.c (end_psymtab): Change type of include_list parameter
	from char ** to const char **.
	* dwarf2read.c (determine_prefix): Change result type
	from char * to const char *.  All callers updated.
	* f-lang.c (find_common_for_function): Change type of name, funcname
	parameters from char * to const char *.
	* f-lang.c (find_common_for_function): Update.
	* f-valprint.c (list_all_visible_commons): Change type of funcname
	parameters from char * to const char *.
	* gdbarch.sh (static_transform_name): Change type of name parameter
	and result from char * to const char *.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* i386-sol2-tdep.c (i386_sol2_static_transform_name): Change type
	of name parameter from char * to const char *.
	* jv-lang.c (java_primitive_type_from_name): Ditto.
	(java_demangled_signature_length): Similarly for signature parameter.
	(java_demangled_signature_copy): Ditto.
	(java_demangle_type_signature): Ditto.
	* jv-lang.h (java_primitive_type_from_name): Update.
	(java_demangle_type_signature): Update.
	* objc-lang.c (specialcmp): Change type of a,b parameters
	from char * to const char *.
	* p-lang.c (is_pascal_string_type): Change type of arrayname parameter
	from char * to const char *.  All callers updated.
	* p-lang.h (is_pascal_string_type): Update.
	* solib-frv.c (find_canonical_descriptor_in_load_object): Change type
	of name parameter from char * to const char *.
	* sparc-sol2-tdep.c (sparc_sol2_static_transform_name): Ditto.
	* utils.c (fprintf_symbol_filtered): Ditto.
	* defs.h (fprintf_symbol_filtered): Update.
	* sparc-tdep.h (sparc_sol2_static_transform_name): Update.
	* stabsread.h (end_psymtab): Update.
	* stack.c (find_frame_funname): Change type of funname parameter
	from char ** to const char **.
	* stack.h (find_frame_funname): Update.
	* typeprint.c (type_print): Change type of varstring parameter
	from char * to const char *.
	* value.h (type_print): Update.
	* xcoffread.c (xcoff_start_psymtab): Change type of filename parameter
	from char * to const char *.  All callers updated.
	(xcoff_end_psymtab): Change type of include_list parameter
	from char ** to const char **.  All callers updated.
	(swap_sym): Similarly for name parameter.  All callers updated.
	* coffread.c (patch_type): Add (char*) cast to xfree parameter.
	Use xstrdup.
	(process_coff_symbol): Use xstrdup.
	* stabsread.c (stabs_method_name_from_physname): Renamed from
	update_method_name_from_physname.  Change result type from void
	to char *.  All callers updated.
	(read_member_functions): In has_destructor case, store name in objfile
	obstack instead of malloc space.  In !has_stub case, fix mem leak.
@
text
@d101 1
a101 1
static void fix_common_block (struct symbol *, int);
d4400 1
a4400 1
fix_common_block (struct symbol *sym, int valu)
@


1.142
log
@	* gdbtypes.h (struct cplus_struct_type): Delete member
	nfn_fields_total.  All uses removed.
@
text
@d1176 1
a1176 1
	      char *new_name = gdbarch_static_transform_name
d1370 1
a1370 1
	      char *new_name = gdbarch_static_transform_name
d2235 2
a2236 1
/* Replace *OLD_NAME with the method name portion of PHYSNAME.  */
d2238 2
a2239 2
static void
update_method_name_from_physname (char **old_name, const char *physname)
d2249 1
a2249 1
      return;
d2252 1
a2252 7
  if (strcmp (*old_name, method_name) != 0)
    {
      xfree (*old_name);
      *old_name = method_name;
    }
  else
    xfree (method_name);
d2685 2
d2688 9
a2696 2
	      update_method_name_from_physname (&new_fnlist->fn_fieldlist.name,
						sublist->fn_field.physname);
d2701 2
a2702 1
		concat ("~", main_fn_name, (char *)NULL);
d2719 1
d2762 1
a2762 1
  char *name;
d3275 1
a3275 1
		  char *name = TYPE_FIELD_NAME (t, i);
d3415 2
a3416 2
  char *name = "";
  char *kind = "";
d4554 1
a4554 1
		char *typename = TYPE_TAG_NAME (*type);
@


1.141
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@a2280 4
  /* Total number of member functions defined in this class.  If the class
     defines two `f' functions, and one `g' function, then this will have
     the value 3.  */
  int total_length = 0;
a2679 1
	      total_length += has_destructor;
a2729 1
	  total_length += length;
a2740 1
      TYPE_NFN_FIELDS_TOTAL (type) = total_length;
@


1.140
log
@	* defs.h (is_cplus_marker, set_demangling_style): Moved to ...
	* gdb-demangle.h: ... here.  New file.
	* demangle.c: #include "gdb-demangle.h".
	(_initialize_demangler): Use initialize_file_ftype for prototype.
	Move "set demangle" and "set asm-demangle" parameters here from utils.c
	(demangle, show_demangle, asm_demangle, show_asm_demangle): Move here
	from utils.c
	* utils.c: Update. #include "gdb-demangle.h".
	* symtab.h (asm_demangle): Delete.
	(demangle): Move declaration next to use.
	* breakpoint.c: #include "gdb-demangle.h" instead of "demangle.h".
	* dwarf2read.c: #include "gdb-demangle.h".
	* gnu-v2-abi.c: Ditto.
	* jv-typeprint.c: Ditto.
	* mdebugread.c: Ditto.
	* p-typeprint.c: Ditto.
	* stabsread.c: Ditto.
	* printcmd.c: Ditto.
	(asm_demangle): Delete declaration.
	* tui/tui-stack.c: #include "gdb-demangle.h".
@
text
@d3 1
a3 3
   Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
   2008, 2009, 2010, 2011 Free Software Foundation, Inc.
@


1.140.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 3
a5 1
   Copyright (C) 1986-2012 Free Software Foundation, Inc.
@


1.139
log
@	* cp-namespace.c (cp_scan_for_anonymous_namespaces): Changed function
	arguments by adding OBJFILE.  Instead of getting objfile from
	symbol's symtab, use new argument OBJFILE.
	* cp-support.h (cp_scan_for_anonymous_namespaces): Changed function
	arguments by adding OBJFILE.
	* gdb/dwarf2read.c (new_symbol_full): Change call to
	cp_scan_for_anonymous_namespaces to match new signature.
	* gdb/stabsread.c (define_symbol): Change call to
	cp_scan_for_anonymous_namespaces to match new signature.
@
text
@d44 1
@


1.138
log
@	* value.c (value_fn_field): Constify.
	* symtab.c (gdb_mangle_name): Constify.
	* stabsread.c (update_method_name_from_physname): Make 'physname'
	argument const.
	* p-typeprint.c (pascal_type_print_method_args): Make arguments
	const.  Use explicit fputc_filtered loop.
	(pascal_type_print_base): Constify.
	* p-lang.h (pascal_type_print_method_args): Update.
	* linespec.c (add_matching_methods): Constify.
	(add_constructors): Likewise.
	* jv-typeprint.c (java_type_print_base): Constify.
	* gdbtypes.h (struct cplus_struct_type)
	<fn_fieldlist.fn_field.physname>: Now const.
	* dwarf2read.c (compute_delayed_physnames): Constify.
	(dwarf2_add_member_fn): Likewise.
	* c-typeprint.c (c_type_print_base): Constify.  Use cleanups.
@
text
@d732 1
a732 1
	cp_scan_for_anonymous_namespaces (sym);
@


1.137
log
@2011-03-04  Michael Snyder  <msnyder@@vmware.com>

	* stabsread.c (define_symbol): Guard against bad stabstring input.
@
text
@d2239 1
a2239 1
update_method_name_from_physname (char **old_name, char *physname)
@


1.137.2.1
log
@Commit patch from HEAD: http://sourceware.org/ml/gdb-patches/2011-10/msg00577.html

	* cp-namespace.c (cp_scan_for_anonymous_namespaces): Changed function
	arguments by adding OBJFILE.  Instead of getting objfile from
	symbol's symtab, use new argument OBJFILE.
	* cp-support.h (cp_scan_for_anonymous_namespaces): Changed function
	arguments by adding OBJFILE.
	* gdb/dwarf2read.c (new_symbol_full): Change call to
	cp_scan_for_anonymous_namespaces to match new signature.
	* gdb/stabsread.c (define_symbol): Change call to
	cp_scan_for_anonymous_namespaces to match new signature.
@
text
@d732 1
a732 1
	cp_scan_for_anonymous_namespaces (sym, objfile);
@


1.136
log
@2011-02-28  Michael Snyder  <msnyder@@vmware.com>

	* stabsread.c (rs6000_builtin_type): Missing break statement.
@
text
@d639 6
@


1.135
log
@2011-02-25  Michael Snyder  <msnyder@@vmware.com>

	* arm-tdep.c: Fix typos in comments.
	* bsd-uthread.c: Ditto.
	* completer.c: Ditto.
	* corelow.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* cris-tdep.c: Ditto.
	* dbxread.c: Ditto.
	* dwarf2read.c: Ditto.
	* frame.h: Ditto.
	* gdbtypes.h: Ditto.
	* inferior.h: Ditto.
	* mdebugread.c: Ditto.
	* mips-tdep.c: Ditto.
	* ppc-linux-nat.c: Ditto.
	* ppc-linux-tdep.c: Ditto.
	* printcmd.c: Ditto.
	* sol-thread.c: Ditto.
	* solib-frv.c: Ditto.
	* solist.h: Ditto.
	* sparc64-tdep.c: Ditto.
	* spu-tdep.c: Ditto.
	* stabsread.c: Ditto.
	* symfile.c: Ditto.
	* valops.c: Ditto.
	* varobj.c: Ditto.
	* vax-nat.c: Ditto.
	* python/py-block.c: Ditto.
	* python/py-symbol.c: Ditto.
	* python/py-symtab.c: Ditto.
	* python/py-value.c: Ditto.
	* tui/tui-win.c: Ditto.
@
text
@d2127 1
@


1.134
log
@2011-01-11  Michael Snyder  <msnyder@@vmware.com>

	* s390-tdep.c: Comment cleanup, mostly periods and spaces.
	* score-tdep.c: Ditto.
	* score-tdep.h: Ditto.
	* ser-base.c: Ditto.
	* ser-go32.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* ser-mingw.c: Ditto.
	* ser-pipe.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* sh64-tdep.c: Ditto.
	* shnbsd-nat.c: Ditto.
	* sh-tdep.c: Ditto.
	* sh-tdep.h: Ditto.
	* solib.c: Ditto.
	* solib-darwin.c: Ditto.
	* solib-frv.c: Ditto.
	* solib.h: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-spu.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solist.h: Ditto.
	* sol-thread.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* source.h: Ditto.
	* sparc64-linux-tdep.c: Ditto.
	* sparc64-tdep.c: Ditto.
	* sparc-linux-nat.c: Ditto.
	* sparc-linux-tdep.c: Ditto.
	* sparc-sol2-nat.c: Ditto.
	* sparc-sol2-tdep.c: Ditto.
	* sparc-tdep.c: Ditto.
	* sparc-tdep.h: Ditto.
	* spu-tdep.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.h: Ditto.
	* stack.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target.c: Ditto.
	* target-descriptions.c: Ditto.
	* target-descriptions.h: Ditto.
	* target.h: Ditto.
	* target-memory.c: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* trad-frame.h: Ditto.
	* typeprint.c: Ditto.
@
text
@d3480 1
a3480 1
   in the the stabs string.  For example, given stabs "A:T4=s4a:1,0,32;;",
@


1.133
log
@2011-01-05  Michael Snyder  <msnyder@@vmware.com>

	* addrmap.c: Shorten lines of >= 80 columns.
	* arch-utils.c: Ditto.
	* arch-utils.h: Ditto.
	* ax-gdb.c: Ditto.
	* ax-general.c: Ditto.
	* bcache.c: Ditto.
	* blockframe.c: Ditto.
	* breakpoint.c: Ditto.
	* buildsym.c: Ditto.
	* c-lang.c: Ditto.
	* c-typeprint.c: Ditto.
	* charset.c: Ditto.
	* coffread.c: Ditto.
	* command.h: Ditto.
	* corelow.c: Ditto.
	* cp-abi.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* defs.h: Ditto.
	* dfp.c: Ditto.
	* dfp.h: Ditto.
	* dictionary.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* eval.c: Ditto.
	* event-loop.c: Ditto.
	* event-loop.h: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-lang.c: Ditto.
	* f-valprint.c: Ditto.
	* findcmd.c: Ditto.
	* frame-base.c: Ditto.
	* frame-unwind.c: Ditto.
	* frame-unwind.h: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_dirent.h: Ditto.
	* gdb_obstack.h: Ditto.
	* gdbcore.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* inf-ttrace.c: Ditto.
	* infcall.c: Ditto.
	* infcmd.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* inline-frame.h: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* libunwind-frame.c: Ditto.
	* libunwind-frame.h: Ditto.
	* linespec.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-nat.h: Ditto.
	* linux-thread-db.c: Ditto.
	* machoread.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* memattr.c: Ditto.
	* minsyms.c: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* osabi.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* parse.c: Ditto.
	* printcmd.c: Ditto.
	* proc-events.c: Ditto.
	* procfs.c: Ditto.
	* progspace.c: Ditto.
	* progspace.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote-fileio.c: Ditto.
	* remote.c: Ditto.
	* ser-mingw.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* solib-frv.c: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solib-target.c: Ditto.
	* solib.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.c: Ditto.
	* stack.c: Ditto.
	* stack.h: Ditto.
	* symfile-mem.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target-descriptions.c: Ditto.
	* target-memory.c: Ditto.
	* target.c: Ditto.
	* target.h: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* ui-file.c: Ditto.
	* ui-file.h: Ditto.
	* ui-out.h: Ditto.
	* user-regs.c: Ditto.
	* user-regs.h: Ditto.
	* utils.c: Ditto.
	* valarith.c: Ditto.
	* valops.c: Ditto.
	* valprint.c: Ditto.
	* valprint.h: Ditto.
	* value.c: Ditto.
	* varobj.c: Ditto.
	* varobj.h: Ditto.
	* vec.h: Ditto.
	* xcoffread.c: Ditto.
	* xcoffsolib.c: Ditto.
	* xcoffsolib.h: Ditto.
	* xml-syscall.c: Ditto.
	* xml-tdesc.c: Ditto.
@
text
@d26 1
a26 1
   Avoid placing any object file format specific code in this file. */
d64 1
a64 1
   expected to eventually go away... (FIXME) */
d193 1
a193 1
   before this type is actually defined. For instance "t(0,1)=k(0,2)"
d317 1
a317 1
   put into the type vector, and so may not be referred to by number. */
d343 1
a343 1
   and fix their symbols in given symbol vector. */
d357 1
a357 1
         patch their types! */
d466 1
a466 1
   during "process_later". */
d481 1
a481 1
/* Ptr to free cell in chunk's linked list. */
d484 1
a484 1
/* Number of chunks malloced. */
d488 2
a489 2
   table. If the symbol table changes, this cache must be cleared
   or we are left holding onto data in invalid obstacks. */
d499 2
a500 2
   find them, using their reference numbers as our index. 
   These will be used later when we resolve references. */
d548 1
a548 1
  /* Read number as reference id. */
d569 1
a569 1
  /* Defining symbols end in '=' */
d572 1
a572 1
      /* Symbol is being defined here. */
d578 1
a578 1
      /* Must be a reference.   Either the symbol has already been defined,
d598 1
a598 1
      regno = gdbarch_sp_regnum (gdbarch); /* Known safe, though useless */
d622 2
a623 2
     to type 2, but, should not create a symbol to address that type. Since
     the symbol will be nameless, there is no way any user can refer to it. */
d631 1
a631 1
  /* Ignore old-style symbols from cc -go  */
d697 1
a697 1
	  /* ... fall through ... */
d702 1
a702 1
	  goto normal;		/* Do *something* with it */
d939 1
a939 1
      /* fall into process_prototype_types */
d958 1
a958 1
	  /* Allocate parameter information fields and fill them in. */
d973 1
a973 1
	         a type which references itself. This type is turned into
d1156 1
a1156 1
      /* Static symbol at top level of file */
d1185 1
a1185 1
         and thus 't' is in fact equivalent to 'Tt'. 
d1203 1
a1203 1
         did not use `sym'. Return without further processing. */
d1231 1
a1231 1
	     Some gdb code depends on that specific name. */
d1256 2
a1257 2
              /* ezannoni: 2000-10-26. This seems to apply for
		 versions of gcc older than 2.8. This was the original
d1259 2
a1260 1
		 the type for name1 is caddr_t, and func is char()
d1265 1
a1265 1
		 char *name1;
d1273 1
a1273 1
	      /* Pascal accepts names for pointer types. */
d1316 1
a1316 1
         did not use `sym'. Return without further processing. */
d1332 1
a1332 1
	  /* Clone the sym and then modify it. */
d1350 1
a1350 1
      /* Static symbol of local scope */
d1512 1
a1512 1
  /* Used to distinguish string and bitstring from char-array and set. */
d1515 1
a1515 1
  /* Used to distinguish vector from array. */
d1704 1
a1704 1
         the Lucid compiler and recent gcc versions (post 2.7.3) use. */
d1707 1
a1707 1
         This handles recursive types. */
d1904 1
a1904 1
	      /* FIXME: check to see if following type is array? */
d1909 1
a1909 1
	      /* FIXME: check to see if following type is array? */
d2032 2
a2033 2
      --*pp;			/* Go back to the symbol in error */
      /* Particularly important if it was \0! */
d2051 1
a2051 1
   Return the proper type node for a given builtin type number. */
d2293 1
a2293 1
     or find the end of the functions. */
d2299 1
a2299 1
         first of a "::" delimiter, then this is not a member function. */
d2364 1
a2364 1
	      /* Normal case. */
d2388 1
a2388 1
	  /* If this is just a stub, then we don't have the real name here. */
d2413 1
a2413 1
	    case 'A':		/* Normal functions. */
d2418 1
a2418 1
	    case 'B':		/* `const' member functions. */
d2423 1
a2423 1
	    case 'C':		/* `volatile' member function. */
d2428 1
a2428 1
	    case 'D':		/* `const volatile' member function. */
d2434 1
a2434 1
				   no info */
d2476 1
a2476 1
			/* g++ version 1 overloaded methods. */
d2772 1
a2772 1
         type, find it's name, and construct the field name. */
d2811 1
a2811 1
         field type. */
d2858 1
a2858 1
  /* This means we have a visibility for a field coming. */
d2875 1
a2875 1
      /* Possible future hook for nested types. */
d3003 1
a3003 1
     start of the member function list. */
d3005 1
a3005 1
     SUN C compiler 5.3 i.e. F6U2, hence check for end of string. */
d3035 1
a3035 1
         functions (if any), terminate scan loop and return. */
d3055 1
a3055 1
         scrub. */
d3101 1
a3101 1
      /* Skip the '!' baseclass information marker. */
d3138 2
a3139 1
      FIELD_BITSIZE (new->field) = 0;	/* this should be an unpacked field! */
d3145 1
a3145 1
	  /* Nothing to do. */
d3192 1
a3192 1
         field's name. */
d3197 1
a3197 1
      /* skip trailing ';' and bump count of number of fields seen */
d3222 1
a3222 1
  /* If we are positioned at a ';', then skip it. */
d3235 1
a3235 1
	     of constructors and/or destructors. */
d3264 1
a3264 1
	  if (type == t)	/* Our own class provides vtbl ptr */
d3307 1
a3307 1
      --n;			/* Circumvent Sun3 compiler bug */
d3328 1
a3328 1
     bitfields. */
d3341 1
a3341 1
     array of fields, and create blank visibility bitfields if necessary. */
d3365 4
a3368 3
  /* Copy the saved-up fields into the field vector.  Start from the head
     of the list, adding to the tail of the field array, so that they end
     up in the same order in the array in which they were added to the list. */
d3794 1
a3794 1
  /* The second number is always 0, so ignore it too. */
d3799 1
a3799 1
  /* The third number is the number of bits for this type. */
d3837 1
a3837 1
  /* The second number is the number of bytes occupied by this type */
d3958 1
a3958 1
              n += c - '0';		/* FIXME this overflows anyway */
d3965 1
a3965 1
         what GCC does. */
d4085 1
a4085 1
         the range should fit in this size. If the lower bounds needs
d4137 1
a4137 1
     this was to work well with pre-COMPLEX versions of gdb. */
d4257 1
a4257 1
  struct type *types[1024];	/* allow for fns of 1023 parameters */
d4270 1
a4270 1
  (*pp)++;			/* get past `end' (the ':' character) */
d4356 1
a4356 1
  /* Note: common_block_name already saved on objfile_obstack */
d4548 1
a4548 1
		/* Name of the type, without "struct" or "union" */
d4653 1
a4653 1
	     under that hash index. */
d4663 1
a4663 1
		     assign the value we have to it. */
d4760 1
a4760 1
   start_symtab() is called. */
d4775 1
a4775 1
/* Call after end_symtab() */
d4827 1
a4827 1
/* Initializer for this module */
@


1.132
log
@run copyright.sh for 2011.
@
text
@d37 1
a37 1
#include "aout/stab_gnu.h"	/* We always use GNU stabs, not native */
d236 2
a237 1
		 _("Invalid symbol data: type number (%d,%d) out of range at symtab pos %d."),
d856 4
a859 3
	    range_type = create_range_type (NULL,
					    objfile_type (objfile)->builtin_int,
					    0, ind);
d1167 2
a1168 1
	  msym = lookup_minimal_symbol (SYMBOL_LINKAGE_NAME (sym), NULL, objfile);
d1295 4
a1298 3
            TYPE_NAME (SYMBOL_TYPE (sym)) = obconcat (&objfile->objfile_obstack,
						      SYMBOL_LINKAGE_NAME (sym),
						      (char *) NULL);
d1323 4
a1326 3
	TYPE_TAG_NAME (SYMBOL_TYPE (sym)) = obconcat (&objfile->objfile_obstack,
						      SYMBOL_LINKAGE_NAME (sym),
						      (char *) NULL);
d1340 4
a1343 3
	    TYPE_NAME (SYMBOL_TYPE (sym)) = obconcat (&objfile->objfile_obstack,
						      SYMBOL_LINKAGE_NAME (sym),
						      (char *) NULL);
d1469 2
a1470 1
  complaint (&symfile_complaints, _("couldn't parse type; debugger out of date?"));
d1591 2
a1592 1
			   _("Unrecognized cross-reference type `%c'"), (*pp)[0]);
d1636 2
a1637 2
	      to = type_name =
		(char *) obstack_alloc (&objfile->objfile_obstack, p - *pp + 1);
d1819 2
a1820 1
		       _("Prototyped function type didn't end arguments with `#':\n%s"),
d1932 2
a1933 1
		       _("invalid (minimal) member type data format at symtab pos %d."),
d2057 2
a2058 1
  struct type **negative_types = objfile_data (objfile, rs6000_builtin_type_data);
d2432 2
a2433 1
	    case '*':		/* File compiled with g++ version 1 -- no info */
d2439 2
a2440 1
			 _("const/volatile indicator missing, got '%c'"), **pp);
d2523 2
a2524 1
			 _("member function type missing, got '%c'"), (*pp)[-1]);
d2608 2
a2609 2
	                                                           [now or later]
	     Foo              _._3Foo       _._3Foo      ~Foo       separate and
d2792 2
a2793 1
			 _("C++ abbreviated type name unknown at symtab pos %d"),
d3152 2
a3153 1
		       _("Unknown virtual character `%c' for baseclass"), **pp);
d3279 2
a3280 1
			 _("virtual function table pointer not found when defining class `%s'"),
d3390 2
a3391 1
	    complaint (&symfile_complaints, _("Unknown visibility `%c' for field"),
d3537 1
a3537 1
     field (baseclass specifier for the class holding the main vtable). */
d3913 2
a3914 1
	  || (twos_complement_bits % 3 == 0 && len == twos_complement_bits / 3))
d4728 2
a4729 1
		       _("%s: common block `%s' from global_sym_chain unresolved"),
@


1.131
log
@Fixed stabs cplus_specific issue

2010-08-09  Sami Wagiaalla  <swagiaal@@redhat.com>

	* symtab.c (symbol_get_demangled_name): Remove assertion and
	return NULL when language_specific.cplus_specific is not initialized.
	* stabsread.c (define_symbol): Set the name before calling
	cp_scan_for_anonymous_namespaces.
@
text
@d5 1
a5 1
   2008, 2009, 2010 Free Software Foundation, Inc.
@


1.130
log
@create and use symbol_set_language.

2010-08-09  Sami Wagiaalla  <swagiaal@@redhat.com>

	* symtab.h: Renamed SYMBOL_INIT_LANGUAGE_SPECIFIC to
	SYMBOL_SET_LANGUAGE.
	(symbol_init_language_specific): Renamed to symbol_set_language.
	* symtab.c (symbol_init_language_specific): Removed redundant check
	for language_cplus.
	Renamed to symbol_set_language.
	* stabsread.c (define_symbol): Updated.
	(read_enum_type): Updated
	* psymtab.c (add_psymbol_to_bcache): Updated.
	* minsyms.c (install_minimal_symbols): Updated.
	* coffread.c (process_coff_symbol): SYMBOL_SET_LANGUAGE instead of
	SYMBOL_LANGUAGE to set the language.
	* minsyms.c (prim_record_minimal_symbol_full): Ditto.
	* mdebugread.c (new_symbol): Ditto.
	* cp-namespace.c (check_one_possible_namespace_symbol): Ditto.
	* dwarf2read.c (new_symbol_full): Ditto.
	* jv-lang.c (add_class_symbol): Ditto.
@
text
@a714 1
	  cp_scan_for_anonymous_namespaces (sym);
d723 4
@


1.129
log
@2010-05-16  Michael Snyder  <msnyder@@vmware.com>

	* scm-exp.c: White space.
	* scm-lang.c: White space.
	* scm-valprint.c: White space.
	* sentinel-frame.c: White space.
	* ser-base.c: White space.
	* ser-go32.c: White space.
	* serial.c: White space.
	* ser-mingw.c: White space.
	* ser-pipe.c: White space.
	* ser-tcp.c: White space.
	* ser-unix.c: White space.
	* solib.c: White space.
	* solib-darwin.c: White space.
	* solib-frv.c: White space.
	* solib-irix.c: White space.
	* solib-osf.c: White space.
	* solib-pa64.c: White space.
	* solib-som.c: White space.
	* solib-spu.c: White space.
	* solib-svr4.c: White space.
	* solib-target.c: White space.
	* source.c: White space.
	* stabsread.c: White space.
	* stack.c: White space.
	* std-regs.c: White space.
	* symfile.c: White space.
	* symmisc.c: White space.
	* symtab.c: White space.
@
text
@d707 1
a707 1
      SYMBOL_LANGUAGE (sym) = current_subfile->language;
d3659 1
a3659 1
      SYMBOL_LANGUAGE (sym) = current_subfile->language;
@


1.128
log
@gdb/
	* dwarf2read.c (typename_concat): Use (char *) NULL terminated stdarg
	list for the obconcat call.
	* mdebugread.c (parse_symbol): Likewise.
	* stabsread.c (define_symbol, read_member_functions, read_cpp_abbrev):
	Likewise.
	* symfile.c (obconcat): Replace the s1, s2 and s3 parameters by `...'.
	New variable ap.  Remove variables len and val.
	* symfile.h (obconcat): Likewise for the prototype.
@
text
@a354 1

d437 1
d511 1
d514 2
a515 1
      memset (ref_map + ref_chunk * MAX_CHUNK_REFS, 0, new_chunks * REF_CHUNK_SIZE);
d711 1
d1127 1
d1161 1
d1167 1
d1214 1
d1325 2
a1326 1
	  obstack_alloc (&objfile->objfile_obstack, sizeof (struct symbol));
d1350 3
a1352 1
	  msym = lookup_minimal_symbol (SYMBOL_LINKAGE_NAME (sym), NULL, objfile);
d1357 1
d1594 1
d1612 1
d1700 1
d1873 1
d2685 1
d2763 3
a2765 3
	  {
		  name = "";
	  }
d2808 1
d2885 1
d3089 1
d3250 1
d3506 1
d3697 1
d3701 1
d3886 1
d3920 1
d4123 1
d4136 1
d4373 1
d4377 1
d4780 1
@


1.127
log
@2010-05-05  Michael Snyder  <msnyder@@vmware.com>

	* elfread.c (elf_symtab_read): Delete unused variable.
	(find_separate_debug_file_by_buildid): Delete unused variables.
	(elf_symfile_read): Delete unused variable.

	* coffread.c (coff_symfile_read): Delete unused variables.

	* coff-pe-read.c (add_pe_exported_sym): Delete unused variable.
	(read_pe_exported_syms): Delete unused variable.

	* stabsread.c (define_symbol): Delete unused variable.

	* dwarf2read.c (read_type_comp_unit_head): Delete unused variable.
	(process_psymtab_comp_unit): Delete unused variable.
	(dwarf2_build_psymtabs_hard): Delete unused variable.
	(load_partial_comp_unit): Delete unused variable.
	(create_all_comp_units): Delete unused variable.
	(scan_partial_symbols): Delete unused variable.
	(add_partial_symbol): Delete unused variable.
	(add_partial_namespace): Delete unused variable.
	(add_partial_enumeration): Delete unused variable.
	(load_full_comp_unit): Delete unused variable.
	(process_full_comp_unit): Delete unused variable.
	(read_file_scope): Delete unused variable.
	(read_type_unit_scope): Delete unused variable.
	(process_structure_scope): Delete unused variable.
	(process_enumeration_scope): Delete unused variable.
	(read_tag_ptr_to_member_type): Delete unused variable.
	(read_typedef): Delete unused variable.
	(read_partial_die): Delete unused variable.
	(decode_locdesc): Delete unused variable.
	(zeroed_partial_die): Delete unused global variable.
@
text
@d1282 3
a1284 3
            TYPE_NAME (SYMBOL_TYPE (sym))
              = obconcat (&objfile->objfile_obstack, "", "",
                          SYMBOL_LINKAGE_NAME (sym));
d1309 3
a1311 3
	TYPE_TAG_NAME (SYMBOL_TYPE (sym))
	  = obconcat (&objfile->objfile_obstack, "", "",
		      SYMBOL_LINKAGE_NAME (sym));
d1324 3
a1326 3
	    TYPE_NAME (SYMBOL_TYPE (sym))
	      = obconcat (&objfile->objfile_obstack, "", "",
			  SYMBOL_LINKAGE_NAME (sym));
d2612 2
a2613 2
		= obconcat (&objfile->objfile_obstack, "", "~",
			    new_fnlist->fn_fieldlist.name);
d2750 2
a2751 2
	  fip->list->field.name =
	    obconcat (&objfile->objfile_obstack, vptr_name, name, "");
d2763 2
a2764 2
	  fip->list->field.name =
	    obconcat (&objfile->objfile_obstack, vb_name, name, "");
d2769 3
a2771 3
	  fip->list->field.name =
	    obconcat (&objfile->objfile_obstack,
		      "INVALID_CPLUSPLUS_ABBREV", "", "");
@


1.126
log
@ * Remove unwanted space in set_length_in_type_chain parameterdeclaration
@
text
@a809 1
	    char *startp = p;
@


1.125
log
@	PR stabs/11479.
	* stabsread.c (set_length_in_type_chain): New function.
	(read_struct_type): Call set_length_in_type_chain function.
	(read_enum_type): Idem.
@
text
@d3419 1
a3419 1
set_length_in_type_chain (struct type * type)
@


1.124
log
@	* gdb/stabsread.c (define_symbol): Add support for char
	and string constants.

	* gdb/testsuite/gdb.stabs/aout.sed: Convert all backslash to double backslash
	within one line, unless it is followed by a double quote.
	* gdb/testsuite/gdb.stabs/hppa.sed: Idem.
	* gdb/testsuite/gdb.stabs/weird.def: Add char and String constants
	* gdb/testsuite/gdb.stabs/weird.exp: Check for correct parsing of
	chhar and string constants.
	* gdb/testsuite/gdb.stabs/xcoff.sed: Ignore escaped quote quotes
	in .stabs to .stabx substitution.
@
text
@d3396 36
d3490 1
d3655 1
@


1.123
log
@gdb/
	* stabsread.c (read_args): Handle zero arguments.

gdb/testsuite/
	* gdb.stabs/weird.def (args93): New.
@
text
@d796 69
@


1.122
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d4114 11
a4124 1
  if (TYPE_CODE (types[n - 1]) != TYPE_CODE_VOID)
@


1.121
log
@	* xcoffread.c (scan_xcoff_symtab): Update.
	* symfile.h (add_psymbol_to_list): Update prototype.
	* symfile.c (add_psymbol_to_bcache): Add copy_name argument.
	(add_psymbol_to_list): Likewise.
	* stabsread.c (define_symbol): Update.
	* mdebugread.c (parse_partial_symbols): Update.
	(handle_psymbol_enumerators): Update.
	(new_symbol): Update.
	* dbxread.c (read_dbx_symtab): Update.
	* coffread.c (process_coff_symbol): Update.
	* symtab.h (prim_record_minimal_symbol_full): Declare.
	(SYMBOL_SET_NAMES): Add copy_name argument.
	* symtab.c (struct demangled_name_entry): New struct.
	(hash_demangled_name_entry): New function.
	(eq_demangled_name_entry): Likewise.
	(create_demangled_names_hash): Use new functions.
	(symbol_set_names): Use struct demangled_name_entry.  Add
	copy_name argument.
	* minsyms.c (prim_record_minimal_symbol_full): New function.
	(prim_record_minimal_symbol_and_info): Use it.
	* elfread.c (record_minimal_symbol): Add name_len and copy_name
	arguments.  Call prim_record_minimal_symbol_full.
	(elf_symtab_read): Add copy_names argument.
	(elf_symfile_read): Update calls to elf_symtab_read.
	* dwarf2read.c (add_partial_symbol): Don't copy symbol names.
	(load_partial_dies): Likewise.
	(new_symbol): Likewise.
	* cp-namespace.c (check_one_possible_namespace_symbol): Don't save
	name on the obstack.  Update call to SYMBOL_SET_NAMES.
@
text
@d5 1
a5 1
   2008, 2009 Free Software Foundation, Inc.
@


1.120
log
@	* symtab.h (SYMBOL_SET_LINKAGE_NAME): Update comment.
	* symfile.c (allocate_symtab): Don't use obsavestring on a
	constant string.
	* stabsread.c (define_symbol): Don't use obsavestring on a
	constant string.
	* mdebugread.c (parse_type): Don't use obsavestring on a constant
	string.
	(new_symtab): Likewise.
	* elfread.c (elf_symtab_read): Don't use obsavestring on a
	constant string.
@
text
@d716 1
a716 1
	  SYMBOL_SET_NAMES (sym, new_name, strlen (new_name), objfile);
d720 1
a720 1
	SYMBOL_SET_NAMES (sym, string, p - string, objfile);
@


1.119
log
@	* gdbtypes.h (make_function_type): Remove OBJFILE parameter.
	* gdbtypes.c (make_function_type): Remove OBJFILE parameter.
	(lookup_function_type): Update call.
	* stabsread.c (read_type): Likewise.
	* dwarf2read.c (read_subroutine_type): Use lookup_function_type
	instead of make_function_type.
	* jv-lang.c (type_from_class): Likewise.  Do not allocate types
	on the fake "dynamics" obstack.
@
text
@d676 1
a676 3
	  SYMBOL_SET_LINKAGE_NAME
	    (sym, obsavestring ("this", strlen ("this"),
				&objfile->objfile_obstack));
d683 1
a683 3
	  SYMBOL_SET_LINKAGE_NAME
	    (sym, obsavestring ("eh_throw", strlen ("eh_throw"),
				&objfile->objfile_obstack));
@


1.118
log
@	* gdbtypes.h (struct builtin_type): Remove builtin_core_addr,
	nodebug_text_symbol, nodebug_data_symbol, nodebug_unknown_symbol,
	and nodebug_tls_symbol members.
	(struct objfile_type): New data structure.
	(objfile_type): Add prototype.
	* gdbtypes.c (gdbtypes_post_init): Remove initialization code
	for types no longer in struct builtin_type.
	(objfile_type_data): New static variable.
	(_initialize_gdbtypes): Initialize it.
	(objfile_type): New function.

	* gdbtypes.h (builtin_type_error): Remove.
	* gdbtypes.c (build_complex): Do not use builtin_type_error.
	* symtab.c (builtin_type_error): Remove.
	(_initialize_symtab): Remove initialization.

	* stabsread.c (dbx_lookup_type, define_symbol, error_type,
	rs6000_builtin_type, read_range_type): Use per-objfile types
	instead of global or per-architecture builtin types.
	* coffread.c (decode_type): Likewise.
	* dwarf2read.c (read_array_type, read_tag_string_type,
	new_symbol, die_type): Likewise.
	* mdebugread.c (parse_symbol, basic_type, upgrade_type,
	parse_procedure, psymtab_to_symtab_1): Likewise.
	* xcoffread.c (process_xcoff_symbol): Likewise.
	* parse.c (write_exp_msymbol): Likewise.

	* stabsread.c (rs6000_builtin_type_data): New static variable.
	(_initialize_stabsread): Initialize it.
	(rs6000_builtin_type): Add OBJFILE argument.  Allocate builtin
	types per-objfile instead of globally.

	* stabsread.c (dbx_lookup_type): Add OBJFILE argument.  Use it
	instead of current_objfile; pass it to rs6000_builtin_type.
	(dbx_alloc_type, read_type, read_range_type): Update calls.
	(cleanup_undefined_types_noname): Add OBJFILE argument and
	pass it to dbx_lookup_type.
	(cleanup_undefined_types): Add OBJFILE argument and pass it
	to cleanup_undefined_types_noname.
	* stabsread.h (cleanup_undefined_types): Add OBJFILE argument.
	* buildsym.c (end_symtab): Update call.
@
text
@d1685 1
a1685 2
      type = make_function_type (type1, dbx_lookup_type (typenums, objfile),
				 objfile);
d1709 1
a1709 1
				dbx_lookup_type (typenums, objfile), objfile);
@


1.117
log
@	* symtab.h: Rename SYMBOL_OPS to SYMBOL_COMPUTED_OPS.
	* ax-gdb.c (gen_var_ref): Likewise.
	* findvar.c (read_var_value, symbol_read_needs_frame): Likewise.
	* printcmd.c (address_info): Likewise.
	* dwarf2loc.c (dwarf_expr_frame_base): Likewise.
	* dwarf2read.c (dwarf2_symbol_mark_computed): Likewise.
	* symtab.h: Rename struct symbol_ops to struct symbol_computed_ops.
	* dwarf2loc.h: Likewise.
	* dwarf2loc.c (dwarf2_locexpr_funcs, dwarf2_loclist_funcs): Likewise.

	* symtab.h: (struct symbol_register_ops): New struct definition.
	(struct symbol): Make "ops" member a union of symbol_computed_ops and
	symbol_register_ops callback pointers.
	(SYMBOL_REGISTER_OPS): New macro.
	* tracepoint.c: Include "objfiles.h".
	(scope_info, collect_symbol): Use SYMBOL_REGISTER_OPS register_number
	callback to retrieve register numbers.
	* ax-gdb.c (gen_var_ref): Likewise.
	* findvar.c (read_var_value): Likewise.
	* printcmd.c (address_info): Likewise.

	* coffread.c (coff_reg_to_regnum): New function.
	(coff_register_funcs): New static variable.
	(process_coff_symbol): Do not call gdbarch_sdb_reg_to_regnum.
	Install SYMBOL_REGISTER_OPS callbacks.
	* mdebugread.c (mdebug_reg_to_regnum): New function.
	(mdebug_register_funcs): New static variable.
	(parse_symbol): Do not call gdbarch_ecoff_reg_to_regnum.
	Install SYMBOL_REGISTER_OPS callbacks.
	* stabsread.c (stab_reg_to_regnum): New function.
	(stab_register_funcs): New static variable.
	(define_symbol): Do not call gdbarch_stab_reg_to_regnum.
	Install SYMBOL_REGISTER_OPS callbacks.
@
text
@d117 1
a117 1
static struct type *rs6000_builtin_type (int);
d221 1
a221 1
dbx_lookup_type (int typenums[2])
d252 1
a252 1
	  temp_type = rs6000_builtin_type (index);
d283 1
a283 1
      if (real_filenum >= N_HEADER_FILES (current_objfile))
d285 1
a285 1
	  static struct type **temp_type_p;
d290 2
a291 2
	  temp_type_p = &builtin_type_error;
	  return temp_type_p;
d294 1
a294 1
      f = HEADER_FILES (current_objfile) + real_filenum;
d328 1
a328 1
  type_addr = dbx_lookup_type (typenums);
d775 1
a775 1
	    dbl_type = builtin_type (gdbarch)->builtin_double;
d795 1
a795 1
	    SYMBOL_TYPE (sym) = builtin_type (gdbarch)->builtin_long;
d906 1
a906 1
		ptype = builtin_type (gdbarch)->builtin_int;
d998 2
a999 2
		? builtin_type (gdbarch)->builtin_unsigned_int
		: builtin_type (gdbarch)->builtin_int;
d1404 1
a1404 1
  return (builtin_type_error);
d1580 1
a1580 1
	            *dbx_lookup_type (typenums) = type;
d1675 1
a1675 1
      type = make_pointer_type (type1, dbx_lookup_type (typenums));
d1680 1
a1680 1
      type = make_reference_type (type1, dbx_lookup_type (typenums));
d1685 2
a1686 1
      type = make_function_type (type1, dbx_lookup_type (typenums), objfile);
d1709 2
a1710 2
          = make_function_type (return_type, dbx_lookup_type (typenums),
				objfile);
d1766 1
a1766 1
			   dbx_lookup_type (typenums));
d1772 1
a1772 1
			   dbx_lookup_type (typenums));
d1846 1
a1846 1
	    *dbx_lookup_type (typenums) = type;
d1874 1
a1874 1
	*dbx_lookup_type (typenums) = type;
d1882 1
a1882 1
	    *dbx_lookup_type (typenums) = type;
d1889 1
a1889 1
	*dbx_lookup_type (typenums) = type;
d1896 1
a1896 1
	*dbx_lookup_type (typenums) = type;
d1936 1
a1936 1
	*dbx_lookup_type (typenums) = type;
d1961 2
d1964 1
a1964 1
rs6000_builtin_type (int typenum)
d1966 2
a1969 2
  /* This includes an empty slot for type number -0.  */
  static struct type *negative_types[NUMBER_RECOGNIZED + 1];
d1975 1
a1975 1
      return builtin_type_error;
d1977 9
d2005 1
a2005 1
      rettype = init_type (TYPE_CODE_INT, 4, 0, "int", NULL);
d2008 1
a2008 1
      rettype = init_type (TYPE_CODE_INT, 1, 0, "char", NULL);
d2011 1
a2011 1
      rettype = init_type (TYPE_CODE_INT, 2, 0, "short", NULL);
d2014 1
a2014 1
      rettype = init_type (TYPE_CODE_INT, 4, 0, "long", NULL);
d2018 1
a2018 1
			   "unsigned char", NULL);
d2021 1
a2021 1
      rettype = init_type (TYPE_CODE_INT, 1, 0, "signed char", NULL);
d2025 1
a2025 1
			   "unsigned short", NULL);
d2029 1
a2029 1
			   "unsigned int", NULL);
d2033 1
a2033 1
			   "unsigned", NULL);
d2036 1
a2036 1
			   "unsigned long", NULL);
d2039 1
a2039 1
      rettype = init_type (TYPE_CODE_VOID, 1, 0, "void", NULL);
d2043 1
a2043 1
      rettype = init_type (TYPE_CODE_FLT, 4, 0, "float", NULL);
d2047 1
a2047 1
      rettype = init_type (TYPE_CODE_FLT, 8, 0, "double", NULL);
d2053 1
a2053 1
      rettype = init_type (TYPE_CODE_FLT, 8, 0, "long double", NULL);
d2056 1
a2056 1
      rettype = init_type (TYPE_CODE_INT, 4, 0, "integer", NULL);
d2060 1
a2060 1
			   "boolean", NULL);
d2063 1
a2063 1
      rettype = init_type (TYPE_CODE_FLT, 4, 0, "short real", NULL);
d2066 1
a2066 1
      rettype = init_type (TYPE_CODE_FLT, 8, 0, "real", NULL);
d2069 1
a2069 1
      rettype = init_type (TYPE_CODE_ERROR, 0, 0, "stringptr", NULL);
d2073 1
a2073 1
			   "character", NULL);
d2077 1
a2077 1
			   "logical*1", NULL);
d2081 1
a2081 1
			   "logical*2", NULL);
d2085 1
a2085 1
			   "logical*4", NULL);
d2089 1
a2089 1
			   "logical", NULL);
d2093 1
a2093 1
      rettype = init_type (TYPE_CODE_COMPLEX, 8, 0, "complex", NULL);
d2095 1
a2095 1
					      NULL);
d2101 1
a2101 1
					      NULL);
d2104 1
a2104 1
      rettype = init_type (TYPE_CODE_INT, 1, 0, "integer*1", NULL);
d2107 1
a2107 1
      rettype = init_type (TYPE_CODE_INT, 2, 0, "integer*2", NULL);
d2110 1
a2110 1
      rettype = init_type (TYPE_CODE_INT, 4, 0, "integer*4", NULL);
d2113 1
a2113 1
      rettype = init_type (TYPE_CODE_CHAR, 2, 0, "wchar", NULL);
d2116 1
a2116 1
      rettype = init_type (TYPE_CODE_INT, 8, 0, "long long", NULL);
d2120 1
a2120 1
			   "unsigned long long", NULL);
d2124 1
a2124 1
			   "logical*8", NULL);
d2127 1
a2127 1
      rettype = init_type (TYPE_CODE_INT, 8, 0, "integer*8", NULL);
d4077 1
a4077 1
    index_type = builtin_type (gdbarch)->builtin_int;
d4079 1
a4079 1
    index_type = *dbx_lookup_type (rangenums);
d4088 1
a4088 1
      index_type = builtin_type (gdbarch)->builtin_int;
d4308 1
a4308 1
cleanup_undefined_types_noname (void)
d4317 1
a4317 1
      type = dbx_lookup_type (nat.typenums);
d4430 1
a4430 1
cleanup_undefined_types (void)
d4433 1
a4433 1
  cleanup_undefined_types_noname ();
d4665 2
@


1.116
log
@gdb/
	Make specifiable the make_function_type type memory ownership.
	* gdbtypes.c (make_function_type): New parameter `objfile', use it
	explicitely instead of TYPE-initialized removed local variable
	`objfile'.  Describe `objfile' it in the function comment.
	(lookup_function_type): Update make_function_type callers.
	* gdbtypes.h (make_function_type): Update the prototype.
	* jv-lang.c (java_link_class_type): Update make_function_type callers.
	* dwarf2read.c (read_subroutine_type): Likewise.
	* stabsread.c (read_type): Likewise.
@
text
@d582 23
d1019 1
d1021 1
a1021 11
      SYMBOL_VALUE (sym) = gdbarch_stab_reg_to_regnum (current_gdbarch, valu);
      if (SYMBOL_VALUE (sym) >= gdbarch_num_regs (current_gdbarch)
				  + gdbarch_num_pseudo_regs (current_gdbarch))
	{
	  reg_value_complaint (SYMBOL_VALUE (sym),
			       gdbarch_num_regs (current_gdbarch)
				 + gdbarch_num_pseudo_regs (current_gdbarch),
			       SYMBOL_PRINT_NAME (sym));
	  SYMBOL_VALUE (sym) = gdbarch_sp_regnum (current_gdbarch);
	  /* Known safe, though useless */
	}
d1030 2
a1031 11
      SYMBOL_VALUE (sym) = gdbarch_stab_reg_to_regnum (current_gdbarch, valu);
      if (SYMBOL_VALUE (sym) >= gdbarch_num_regs (current_gdbarch)
				+ gdbarch_num_pseudo_regs (current_gdbarch))
	{
	  reg_value_complaint (SYMBOL_VALUE (sym),
			       gdbarch_num_regs (current_gdbarch)
				 + gdbarch_num_pseudo_regs (current_gdbarch),
			       SYMBOL_PRINT_NAME (sym));
	  SYMBOL_VALUE (sym) = gdbarch_sp_regnum (current_gdbarch);
	  /* Known safe, though useless */
	}
d1067 1
d1305 1
d1307 1
a1307 11
      SYMBOL_VALUE (sym) = gdbarch_stab_reg_to_regnum (current_gdbarch, valu);
      if (SYMBOL_VALUE (sym) >= gdbarch_num_regs (current_gdbarch)
				+ gdbarch_num_pseudo_regs (current_gdbarch))
	{
	  reg_value_complaint (SYMBOL_VALUE (sym),
			       gdbarch_num_regs (current_gdbarch)
				 + gdbarch_num_pseudo_regs (current_gdbarch),
			       SYMBOL_PRINT_NAME (sym));
	  SYMBOL_VALUE (sym) = gdbarch_sp_regnum (current_gdbarch);
	  /* Known safe, though useless */
	}
@


1.115
log
@	* stabsread.c (read_member_functions): GCC may emit an extra space
	at the end of the names "__base_ctor" and "__base_dtor"; so ignore
	whitespace when looking for these functions.
@
text
@d1688 1
a1688 1
      type = make_function_type (type1, dbx_lookup_type (typenums));
d1711 2
a1712 1
          = make_function_type (return_type, dbx_lookup_type (typenums));
@


1.114
log
@gdb

2009-03-31  Daniel Jacobowitz  <dan@@codesourcery.com>
	    Keith Seitz  <keiths@@redhat.com>
	    Jan Kratochvil  <jan.kratochvil@@redhat.com>

	PR gdb/6817
	* Makefile.in (dbxread.o): Update.
	* dbxread.c (read_dbx_symtab): Use cp_canonicalize_string.
	* dwarf2read.c (GDB_FORM_cached_string): New.
	(read_partial_die): Use dwarf2_canonicalize_name.
	(dwarf2_linkage_name): Use dwarf2_name.
	(dwarf2_canonicalize_name): New.
	(dwarf2_name): Use dwarf2_canonicalize_name.
	(dwarf_form_name, dump_die): Handle GDB_FORM_cached_string.
	* stabsread.c (define_symbol, read_type): Use cp_canonicalize_string.
	* symtab.c (lookup_symbol_in_language): Canonicalize input before
	searching.
	* cp-name-parser.y: operator() requires two parameters,
	according to libiberty.
	* minsyms.c (lookup_minimal_symbol): Canonicalize input
	before searching.
	* NEWS: Update.

gdb/testsuite

2009-03-31  Daniel Jacobowitz  <dan@@codesourcery.com>
	    Jan Kratochvil  <jan.kratochvil@@redhat.com>

	PR gdb/931
	* gdb.cp/gdb1355.exp (f_li, f_lui, f_si, f_sui): Allow canonical
	output.
	* gdb.cp/templates.exp: Allow canonical output.  Remove KFAILs
	for gdb/931.
	* dw2-strp.S (DW_AT_language): Change to C++.
	(DW_TAG_variable (name ""), Abbrev code 7, .Lemptyname): New.
@
text
@d2441 2
a2442 2
      if (strcmp (main_fn_name, "__base_ctor") == 0
	  || strcmp (main_fn_name, "__base_dtor") == 0
@


1.113
log
@2008-02-21  Pedro Alves  <pedro@@codesorcery.com>

	Silence a few -Wmissing-prototypes warnings.

	PR build/9877:
	* amd64-nat.c: Include "amd64-nat.h".
	* fork-child.c (_initialize_fork_child): Ditto.
	* gcore.c (_initialize_gcore): Ditto.
	* inf-ptrace.c: Include "inf-ptrace.h".
	(inf_ptrace_store_registers): Make it static.
	* linux-nat.c (linux_nat_terminal_ours): Make it static.
	(_initialize_linux_nat): Declare before definition.
	* linux-tdep.c: Include "linux-tdep.h".
	* linux-thread-db.c (_initialize_thread_db): Declare before
	definition.
	* proc-service.c (_initialize_proc_service): Ditto.
	* remote.c (remote_send_printf): Make it static.
	* solib.c: Include "solib.h".
	* symfile-mem.c (_initialize_symfile_mem): Declare before
	definition.
	* ada-lang.c (ada_la_decode, ada_match_name)
	(ada_suppress_symbol_printing, ada_is_array_type)
	(ada_value_ptr_subscript, ada_array_length)
	(ada_to_static_fixed_value): Make them static.
	(_initialize_ada_language): Declare before definition.
	* ada-tasks.c (ada_get_task_number, ada_get_environment_task)
	(ada_task_list_changed, ada_new_objfile_observer): Make them
	static.
	(_initialize_tasks): Declare before definition.
	* addrmap.c (_initialize_addrmap): Declare before definition.
	* auxv.c (default_auxv_parse): Make it static.
	* bfd-target.c (target_bfd_xfer_partial, target_bfd_xclose): Make
	them static.
	* breakpoint.c (remove_sal): Add line break.
	(expand_line_sal_maybe): Make it static.
	* cp-name-parser.y: Include "cp-support.h".
	* cp-valprint.c (cp_find_class_member): Make it static.
	* eval.c (value_f90_subarray): Ditto.
	* exceptions.c (print_any_exception): Ditto.
	* findcmd.c (_initialize_mem_search): Declare before definition.
	* frame.c (frame_observer_target_changed): Make it static.
	* gnu-v3-abi.c (gnuv3_find_method_in): Make it static.
	* inf-child.c: Include "inf-child.h".
	* inferior.h (valid_inferior_id): Rename to ...
	(valid_gdb_inferior_id): ... this.
	* infrun.c (infrun_thread_stop_requested, siginfo_make_value):
	Make them static.
	* jv-lang.c (java_language_arch_info): Make it static.
	* m2-typeprint.c (m2_get_discrete_bounds): Ditto.
	* osdata.c (info_osdata_command): Make it static.
	* regcache.c (regcache_observer_target_changed): Make it static.
	* reverse.c (_initialize_reverse): Declare before definition.
	* stabsread.c (cleanup_undefined_types_noname)
	(cleanup_undefined_types_1): Make them static.
	* symfile.c (place_section): Make it static.
	* symtab.c (find_pc_sect_psymtab_closer): Make it static.
	* target-descriptions.c (_initialize_target_descriptions): Declare
	before definition.
	* target.c (default_get_ada_task_ptid, find_default_can_async_p)
	(find_default_is_async_p, find_default_supports_non_stop): Make
	them static.
	(target_supports_non_stop): Add prototype.
	(dummy_pid_to_str): Make it static.
	* utils.c (_initialize_utils): Declare before definition.
	* ada-exp.y (_initialize_ada_exp): Declare before definition.
	* solib-svr4.c (HAS_LM_DYNAMIC_FROM_LINK_MAP): Add a prototype.
	* target.h (struct target_ops): Add a prototype to the
	to_can_execute_reverse callback.
	* macroscope.c (_initialize_macroscope): Declare before definition.
	* cp-namespace.c (_initialize_cp_namespace): Declare before definition.
	* python/python.c (_initialize_python): Declare before definition.
	* tui/tui-command.c: Include "tui/tui-command.h".
	* tui/tui-data.c (init_content_element, init_win_info): Make them
	static.
	* tui/tui-disasm.c: Include "tui/tui-disasm.h".
	* tui/tui-interp.c (_initialize_tui_interp): Declare before
	definition.
	* tui/tui-layout.c: Include "tui/tui-layout.h".
	(_initialize_tui_layout): Declare before definition.
	* tui/tui-regs.c: Include "tui/tui-regs.h".
	(tui_display_reg_element_at_line): Make it static.
	(_initialize_tui_regs): Declare before definition.
	* tui/tui-stack.c (_initialize_tui_stack): Declare before
	definition.
	* tui/tui-win.c: Include "tui/tui-win.h".
	(_initialize_tui_win): Declare before definition.
	(tui_sigwinch_handler): Make it static.  Wrap in ifdef SIGWINCH.
	* tui/tui-win.h (tui_sigwinch_handler): Delete declaration.
	(tui_get_cmd_list): Add a prototype.
	* tui/tui-windata.c: Include tui-windata.h.
	* tui/tui-wingeneral.c (box_win): Make it static.
	* cli/cli-logging.c (show_logging_command): Make it static.
	(_initialize_cli_logging): Declare before definition.
	* mi/mi-common.c (_initialize_gdb_mi_common): Declare before
	definition.
@
text
@d592 1
a686 1
      SYMBOL_SET_NAMES (sym, string, p - string, objfile);
d688 14
a701 1
	cp_scan_for_anonymous_namespaces (sym);
d1535 18
a1552 2
	  to = type_name =
	    (char *) obstack_alloc (&objfile->objfile_obstack, p - *pp + 1);
d1554 6
a1559 5
	  /* Copy the name.  */
	  from = *pp + 1;
	  while (from < p)
	    *to++ = *from++;
	  *to = '\0';
d1563 1
a1563 1
	  *pp = from + 1;
@


1.112
log
@        Updated copyright notices for most files.
@
text
@d4267 1
a4267 1
void
d4302 1
a4302 1
void
@


1.111
log
@gdb:
	* xml-tdesc.c (tdesc_end_union): Update.
	* stabsread.c (define_symbol): Update.
	(read_type): Update.
	(read_struct_type): Update.
	(read_enum_type): Update.
	* spu-tdep.c (spu_builtin_type_vec128): Update.
	* sh-tdep.c (sh_push_dummy_call_fpu): Update.
	(sh_push_dummy_call_nofpu): Update.
	* mdebugread.c (parse_symbol): Update.
	(parse_symbol): Update.
	(parse_symbol): Update.
	(upgrade_type): Update.
	* jv-lang.c (java_lookup_class): Update.
	* iq2000-tdep.c (iq2000_pointer_to_address): Update.
	* i386-tdep.c (i386_mmx_type): Update.
	(i386_sse_type): Update.
	* gdbtypes.h (enum type_flag_value): New enum.
	(enum type_instance_flag_value): New enum.
	(TYPE_FLAG_UNSIGNED, TYPE_FLAG_NOSIGN, TYPE_FLAG_STUB,
	TYPE_FLAG_TARGET_STUB, TYPE_FLAG_STATIC, TYPE_FLAG_PROTOTYPED,
	TYPE_FLAG_INCOMPLETE, TYPE_FLAG_VARARGS, TYPE_FLAG_VECTOR,
	TYPE_FLAG_FIXED_INSTANCE, TYPE_FLAG_STUB_SUPPORTED,
	TYPE_FLAG_NOTTEXT): Now enum constants.
	(TYPE_FLAG_CONST, TYPE_FLAG_VOLATILE, TYPE_FLAG_CODE_SPACE,
	TYPE_FLAG_DATA_SPACE, TYPE_FLAG_ADDRESS_CLASS_1,
	TYPE_FLAG_ADDRESS_CLASS_2): Remove.
	(TYPE_INSTANCE_FLAG_CONST, TYPE_INSTANCE_FLAG_VOLATILE,
	TYPE_INSTANCE_FLAG_CODE_SPACE, TYPE_INSTANCE_FLAG_DATA_SPACE,
	TYPE_INSTANCE_FLAG_ADDRESS_CLASS_1,
	TYPE_INSTANCE_FLAG_ADDRESS_CLASS_2): New constants.
	(TYPE_UNSIGNED, TYPE_NOSIGN, TYPE_STUB, TYPE_TARGET_STUB,
	TYPE_STATIC, TYPE_PROTOTYPED, TYPE_INCOMPLETE, TYPE_VARARGS,
	TYPE_VECTOR, TYPE_FIXED_INSTANCE, TYPE_STUB_SUPPORTED,
	TYPE_NOTTEXT): Update.
	(TYPE_FLAG_ADDRESS_CLASS_ALL): Remove.
	(TYPE_INSTANCE_FLAG_ADDRESS_CLASS_ALL): New define.
	(TYPE_VOLATILE, TYPE_CODE_SPACE, TYPE_DATA_SPACE,
	TYPE_ADDRESS_CLASS_1, TYPE_ADDRESS_CLASS_2,
	TYPE_ADDRESS_CLASS_ALL): Update.
	(struct main_type) <flags>: Remove.
	<flag_unsigned, flag_nosign, flag_stub, flag_target_stub,
	flag_static, flag_prototyped, flag_incomplete, flag_varargs,
	flag_vector, flag_stub_supported, flag_nottext,
	flag_fixed_instance>: New fields.
	<nfields, vptr_fieldno>: Move earlier.
	(TYPE_FLAGS): Remove.
	* gdbtypes.c (make_pointer_type): Update.
	(address_space_name_to_int): Update.
	(address_space_int_to_name): Update.
	(make_type_with_address_space): Update.
	(make_cv_type): Update.
	(create_range_type): Update.
	(get_discrete_bounds): Update.
	(create_set_type): Update.
	(make_vector_type): Update.
	(smash_to_method_type): Update.
	(check_typedef): Update.
	(check_stub_method): Update.
	(init_type): Individually assign flag fields.
	(recursive_dump_type): Don't print entire TYPE_FLAGS field.  Do
	print TYPE_FIXED_INSTANCE, TYPE_STUB_SUPPORTED, and TYPE_NOTTEXT.
	(copy_type_recursive): Copy the entire main type.  Don't use
	TYPE_FLAGS.
	* features/rs6000/powerpc-altivec64l.c
	(initialize_tdesc_powerpc_altivec64l): Update.
	* features/rs6000/powerpc-altivec64.c
	(initialize_tdesc_powerpc_altivec64): Update.
	* features/rs6000/powerpc-altivec32l.c
	(initialize_tdesc_powerpc_altivec32l): Update.
	* features/rs6000/powerpc-altivec32.c
	(initialize_tdesc_powerpc_altivec32): Update.
	* features/rs6000/powerpc-7400.c (initialize_tdesc_powerpc_7400):
	Update.
	* features/arm-with-iwmmxt.c (initialize_tdesc_arm_with_iwmmxt):
	Update.
	* dwarf2read.c (read_structure_type): Update.
	(read_enumeration_type): Likewise.
	(process_enumeration_scope): Likewise.
	(read_tag_pointer_type): Likewise.
	(read_subroutine_type): Likewise.
	(read_subroutine_type): Likewise.
	(read_base_type): Likewise.
	* coffread.c (coff_read_enum_type): Update.
	* ada-valprint.c (adjust_type_signedness): Update.
	* ada-typeprint.c (print_record_field_types): Update.
	* ada-lang.c (packed_array_type): Update.
	(empty_record): Don't reset TYPE_FLAGS.
	(ada_template_to_fixed_record_type_1): Update.
	(ada_template_to_fixed_record_type_1): Likewise.
	(template_to_static_fixed_type): Likewise.
	(to_record_with_fixed_variant_part): Likewise.
	(to_fixed_record_type): Likewise.
	(to_fixed_array_type): Likewise.
	(to_static_fixed_type): Likewise.
gdb/testsuite:
	* gdb.base/maint.exp: Update "maint print type".
@
text
@d5 1
a5 1
   2008 Free Software Foundation, Inc.
@


1.110
log
@	* buildsym.c (add_symbol_to_list): Do not call
	cp_scan_for_anonymous_namespaces here.
	(finish_block): Do not call cp_set_block_scope here.
	* cp-namespace.c (processing_has_namespace_info)
	(processing_current_prefix): Delete.
	(cp_initialize_namespace): Do not initialize
	processing_has_namespace_info.
	(cp_scan_for_anonymous_namespaces): Use SYMBOL_DEMANGLED_NAME.  Do
	not check processing_has_namespace_info.
	(cp_set_block_scope): Take prefix and namespace info flag as
	arguments.  Honor namespaces regardless of a demangled name.
	* cp-support.h (processing_has_namespace_info)
	(processing_current_prefix): Delete declarations.
	(cp_set_block_scope): Update prototype.
	* dwarf2read.c (processing_has_namespace_info)
	(processing_current_prefix): New static variables.
	(read_file_scope): Initialize processing_has_namespace_info.
	(read_func_scope): Call cp_set_block_scope for C++.
	(new_symbol): Call cp_scan_for_anonymous_namespaces for C++.
	* symtab.c (symbol_demangled_name): Accept a const argument.
	* symtab.h (symbol_demangled_name): Update prototype.
@
text
@d829 1
a829 1
      TYPE_FLAGS (SYMBOL_TYPE (sym)) |= TYPE_FLAG_PROTOTYPED;
d875 1
a875 1
	  TYPE_FLAGS (ftype) |= TYPE_FLAG_PROTOTYPED;
d1567 1
a1567 1
	TYPE_FLAGS (type) |= TYPE_FLAG_STUB;
d1633 1
a1633 1
	    TYPE_FLAGS (type) |= TYPE_FLAG_TARGET_STUB;
d1728 1
a1728 1
        TYPE_FLAGS (func_type) |= TYPE_FLAG_PROTOTYPED;
d3341 1
a3341 1
  TYPE_FLAGS (type) &= ~TYPE_FLAG_STUB;
d3515 1
a3515 1
  TYPE_FLAGS (type) &= ~TYPE_FLAG_STUB;
d3517 1
a3517 1
    TYPE_FLAGS (type) |= TYPE_FLAG_UNSIGNED;
@


1.109
log
@	* ax-gdb.c (gen_var_ref): Use SYMBOL_LINKAGE_NAME.
	* blockframe.c (find_pc_partial_function): Likewise.
	* buildsym.c (find_symbol_in_list): Likewise.
	* c-valprint.c (c_val_print): Likewise.
	* coffread.c (patch_opaque_types, process_coff_symbol): Likewise.
	(coff_read_enum_type): Likewise.  Use SYMBOL_SET_LINKAGE_NAME.
	* cp-support.c (cp_remove_params): Renamed from remove_params and
	made global.
	(overload_list_add_symbol): Update call to remove_params.
	* cp-support.h (cp_remove_params): Declare.
	* dwarf2read.c (process_enumeration_scope): Use SYMBOL_LINKAGE_NAME.
	(dwarf2_const_value): Use SYMBOL_PRINT_NAME.
	* expprint.c (dump_subexp_body_standard): Likewise.
	* f-valprint.c (info_common_command, there_is_a_visible_common_named):
	Use SYMBOL_LINKAGE_NAME to find symbols and SYMBOL_PRINT_NAME
	for messages.
	* findvar.c (read_var_value): Use SYMBOL_LINKAGE_NAME.
	* gnu-v2-abi.c (gnuv2_value_rtti_type): Likewise.
	* hppa-hpux-tdep.c (hppa32_hpux_in_solib_call_trampoline)
	(hppa_hpux_skip_trampoline_code): Use SYMBOL_LINKAGE_NAME to find
	symbols and SYMBOL_PRINT_NAME for messages.
	* jv-lang.c (add_class_symbol): Use SYMBOL_SET_LINKAGE_NAME.
	* linespec.c (decode_line_2): Use SYMBOL_LINKAGE_NAME.
	* mdebugread.c (parse_symbol): Use SYMBOL_LINKAGE_NAME and
	SYMBOL_SET_LINKAGE_NAME.
	(mylookup_symbol): Use SYMBOL_LINKAGE_NAME.
	* minsyms.c (add_minsym_to_demangled_hash_table): Use
	SYMBOL_SEARCH_NAME.
	(lookup_minimal_symbol): Use SYMBOL_LINKAGE_NAME or
	SYMBOL_MATCHES_SEARCH_NAME, depending on the pass.
	* objfiles.h (ALL_OBJFILE_MSYMBOLS): Use SYMBOL_LINKAGE_NAME.
	* printcmd.c (build_address_symbolic): Use SYMBOL_LINKAGE_NAME.
	(address_info): Use SYMBOL_PRINT_NAME for messages and
	SYMBOL_LINKAGE_NAME for lookups.
	* sol-thread.c (info_cb): Use SYMBOL_PRINT_NAME for messages.
	* stabsread.c (patch_block_stabs, define_symbol)
	(read_type, read_enum_type, common_block_end)
	(cleanup_undefined_types_1, scan_file_globals): Use
	SYMBOL_LINKAGE_NAME, SYMBOL_SET_LINKAGE_NAME, ALL_OBJFILE_MSYMBOLS,
	and SYMBOL_PRINT_NAME.
	* stack.c (print_frame_args): Use SYMBOL_LINKAGE_NAME.
	(print_frame, frame_info): Use SYMBOL_PRINT_NAME for output.  Use
	cp_remove_params instead of cplus_demangle.
	(print_block_frame_labels, print_frame_arg_vars): Use
	SYMBOL_LINKAGE_NAME.
	* symmisc.c (dump_msymbols): Use ALL_OBJFILE_MSYMBOLS and
	SYMBOL_LINKAGE_NAME.
	(dump_symtab_1, print_symbol, print_partial_symbols)
	(maintenance_check_symtabs): Use SYMBOL_LINKAGE_NAME.
	* symtab.h (DEPRECATED_SYMBOL_NAME): Delete.
	(SYMBOL_SET_LINKAGE_NAME): New.
	(SYMBOL_SET_NAMES): Add a comment.
	* tracepoint.c (set_traceframe_context, validate_actionline)
	(collect_symbol, scope_info): Use SYMBOL_LINKAGE_NAME for
	lookups and SYMBOL_PRINT_NAME for output.
	* typeprint.c (typedef_print): Use SYMBOL_LINKAGE_NAME.
	* xcoffread.c (process_xcoff_symbol): Use SYMBOL_SET_LINKAGE_NAME.
@
text
@d687 2
@


1.108
log
@	* symtab.h (enum address_class): Remove LOC_REGPARM and
	LOC_COMPUTED_ARG.
	(struct symbol): Add is_argument.
	(SYMBOL_IS_ARGUMENT): Define.

	* ada-lang.c (ada_add_block_symbols): Use SYMBOL_IS_ARGUMENT.
	* buildsym.c (finish_block): Likewise.
	* stack.c (print_frame_args, print_block_frame_locals)
	(print_frame_arg_vars): Likewise.
	* symtab.c (lookup_block_symbol): Likewise.
	* tracepoint.c (add_local_symbols): Likewise.
	* mi/mi-cmd-stack.c (list_args_or_locals): Likewise.

	* coffread.c (process_coff_symbol): Set SYMBOL_IS_ARGUMENT.
	* dwarf2read.c (new_symbol): Likewise.
	* mdebugread.c (parse_symbol): Likewise.
	* stabsread.c (define_symbol): Likewise.

	* ada-exp.y (select_possible_type_sym): Don't handle LOC_REGPARM
	and LOC_COMPUTED_ARG.
	* ada-lang.c (resolve_subexp, symtab_for_sym): Likewise.
	* ax-gdb.c (gen_var_ref): Likewise.
	* eval.c (evaluate_subexp_for_address): Likewise.
	* findvar.c (symbol_read_needs_frame, read_var_value): Likewise.
	* m2-exp.y (yylex): Likewise.
	* printcmd.c (address_info): Likewise.
	* symmisc.c (print_symbol, print_partial_symbols): Likewise.
	* tracepoint.c (collect_symbol, scope_info): Likewise.

testsuite/:
	* gdb.base/frame-args.exp: Handle arguments that are optimized
	out.
@
text
@d390 3
a392 2
	      DEPRECATED_SYMBOL_NAME (sym) =
		obsavestring (name, pp - name, &objfile->objfile_obstack);
d652 3
a654 2
	  DEPRECATED_SYMBOL_NAME (sym) = obsavestring ("this", strlen ("this"),
					    &objfile->objfile_obstack);
a657 1
	  /* Was: DEPRECATED_SYMBOL_NAME (sym) = "vptr"; */
d661 3
a663 2
	  DEPRECATED_SYMBOL_NAME (sym) = obsavestring ("eh_throw", strlen ("eh_throw"),
					    &objfile->objfile_obstack);
d897 1
a897 1
      if (DEPRECATED_SYMBOL_NAME (sym) && DEPRECATED_SYMBOL_NAME (sym)[0] != '#')
d899 1
a899 1
	  i = hashname (DEPRECATED_SYMBOL_NAME (sym));
d1043 2
a1044 2
		  && strcmp (DEPRECATED_SYMBOL_NAME (prev_sym),
			     DEPRECATED_SYMBOL_NAME (sym)) == 0)
d1068 2
a1069 2
					    DEPRECATED_SYMBOL_NAME (sym))
	     != DEPRECATED_SYMBOL_NAME (sym))
d1072 1
a1072 1
	  msym = lookup_minimal_symbol (DEPRECATED_SYMBOL_NAME (sym), NULL, objfile);
d1075 3
a1077 3
	      DEPRECATED_SYMBOL_NAME (sym) = gdbarch_static_transform_name
					       (gdbarch,	
						DEPRECATED_SYMBOL_NAME (sym));
d1137 1
a1137 1
	       && strcmp (DEPRECATED_SYMBOL_NAME (sym), vtbl_ptr_name))
d1177 1
a1177 1
		  TYPE_NAME (SYMBOL_TYPE (sym)) = DEPRECATED_SYMBOL_NAME (sym);
d1181 1
a1181 1
	    TYPE_NAME (SYMBOL_TYPE (sym)) = DEPRECATED_SYMBOL_NAME (sym);
d1199 1
a1199 1
                          DEPRECATED_SYMBOL_NAME (sym));
d1225 2
a1226 1
	  = obconcat (&objfile->objfile_obstack, "", "", DEPRECATED_SYMBOL_NAME (sym));
d1240 2
a1241 1
	      = obconcat (&objfile->objfile_obstack, "", "", DEPRECATED_SYMBOL_NAME (sym));
d1253 2
a1254 2
					    DEPRECATED_SYMBOL_NAME (sym))
	     != DEPRECATED_SYMBOL_NAME (sym))
d1257 1
a1257 1
	  msym = lookup_minimal_symbol (DEPRECATED_SYMBOL_NAME (sym), NULL, objfile);
d1260 3
a1262 3
	      DEPRECATED_SYMBOL_NAME (sym) = gdbarch_static_transform_name
					       (gdbarch,	
						DEPRECATED_SYMBOL_NAME (sym));
d1546 1
a1546 1
		  && strcmp (DEPRECATED_SYMBOL_NAME (sym), type_name) == 0)
d3495 1
a3495 1
      DEPRECATED_SYMBOL_NAME (sym) = name;
d3537 1
a3537 1
	  TYPE_FIELD_NAME (type, n) = DEPRECATED_SYMBOL_NAME (xsym);
d4152 1
a4152 1
  DEPRECATED_SYMBOL_NAME (sym) = common_block_name;
d4179 1
a4179 1
  i = hashname (DEPRECATED_SYMBOL_NAME (sym));
d4361 1
a4361 1
			    && strcmp (DEPRECATED_SYMBOL_NAME (sym),
d4428 1
a4428 3
      for (msymbol = resolve_objfile->msymbols;
	   msymbol && DEPRECATED_SYMBOL_NAME (msymbol) != NULL;
	   msymbol++)
d4448 1
a4448 1
	  hash = hashname (DEPRECATED_SYMBOL_NAME (msymbol));
d4452 2
a4453 2
	      if (DEPRECATED_SYMBOL_NAME (msymbol)[0] == DEPRECATED_SYMBOL_NAME (sym)[0] &&
		  strcmp (DEPRECATED_SYMBOL_NAME (msymbol) + 1, DEPRECATED_SYMBOL_NAME (sym) + 1) == 0)
d4525 1
a4525 1
		       objfile->name, DEPRECATED_SYMBOL_NAME (prev));
@


1.107
log
@        * stabsread.c (cleanup_undefined_types_1): Add instance flags check
        in the search for the matching symbol.
@
text
@d933 1
d978 2
a979 1
      SYMBOL_CLASS (sym) = LOC_REGPARM;
d1044 1
a1044 1
		  SYMBOL_CLASS (prev_sym) = LOC_REGPARM;
d1270 1
d1280 1
d1322 1
a1322 1
      && (SYMBOL_CLASS (sym) == LOC_REGPARM || SYMBOL_CLASS (sym) == LOC_ARG))
d1324 1
a1324 1
      /* We have to convert LOC_REGPARM to LOC_REGPARM_ADDR (for
d1326 1
a1326 1
      if (SYMBOL_CLASS (sym) == LOC_REGPARM)
@


1.106
log
@        * stabsread.c (cleanup_undefined_types_noname): Manually set the
        instance flags of the undefined type before calling replace_type.
@
text
@d4297 19
d4351 4
a4354 1
			    && strcmp (DEPRECATED_SYMBOL_NAME (sym), typename) == 0)
@


1.105
log
@	* objfiles.h (struct objfile): New GDBARCH member.
	(get_objfile_arch): Add prototype.
	* objfiles.c: Include "arch-utils.h".
	(allocate_objfile): Look up gdbarch associated with bfd.
	(get_objfile_arch): New function.
	* Makefile (objfiles.o): Update dependencies.

	* dwarf2-frame.c (decode_frame_entry_1): Replace current_gdbarch
	by objfile arch.
	* dwarf2loc.c (dwarf_expr_read_reg): Replace current_gdbarch
	by frame arch.
	(locexpr_describe_location): Replace current_gdbarch by
	objfile arch.
	* dwarf2read.c (die_type): Replace current_gdbarch by objfile arch.
	(dwarf2_add_field): Likewise.
	(read_tag_pointer_type): Likewise.
	(read_base_type): Likewise.
	(new_symbol): Likewise.

	* coffread.c (decode_type): Add OBJFILE argument.  Update callers.
	(decode_base_type, decode_function_type): Likewise.
	(coff_read_struct_type, coff_read_enum_type): Likewise.
	(coff_symtab_read): Replace current_gdbarch by objfile arch.
	(decode_base_type): Likewise.
	(coff_read_enum_type): Likewise.
	(coff_read_struct_type): Replace current_objfile by OBJFILE argument.
	(coff_read_enum_type): Likewise.

	* dbxread.c (read_dbx_symtab): Replace current_gdbarch by objfile arch.
	(end_psymtab): Likewise.
	(process_one_symbol): Likewise.

	* mdebugread.c (parse_symbol): Replace current_gdbarch by objfile arch.
	(parse_procedure): Likewise.
	(parse_partial_symbols): Likewise.

	* somread.c (som_symtab_read): Replace current_gdbarch by objfile arch.

	* stabsread.c (define_symbol): Replace current_gdbarch by objfile arch.
	Replace static pcc_promotion_type and pcc_unsigned_promotion_type by
	built-in types.
	(read_range_type): Replace current_gdbarch by objfile arch.  Replace
	static range_index_type by built-in type.
	(read_one_struct_field): Replace current_gdbarch by objfile arch.
	(read_enum_type): Likewise.

	* xcoffread.c (read_xcoff_symtab): Replace current_gdbarch by
	objfile arch.
@
text
@d4269 8
a4276 1
        replace_type (nat.type, *type);
@


1.104
log
@	Updated copyright notices for most files.
@
text
@d585 1
d670 1
a670 1
	  if (gdbarch_static_transform_name_p (current_gdbarch))
d735 1
a735 1
	    dbl_type = builtin_type (current_gdbarch)->builtin_double;
d755 1
a755 1
	    SYMBOL_TYPE (sym) = builtin_type (current_gdbarch)->builtin_long;
d863 2
a864 2
	         it back into builtin_type_int here.
	         FIXME: Do we need a new builtin_type_promoted_int_arg ?  */
d866 1
a866 1
		ptype = builtin_type_int;
d935 1
a935 1
      if (gdbarch_byte_order (current_gdbarch) != BFD_ENDIAN_BIG)
d944 1
a944 1
	  || gdbarch_believe_pcc_promotion (current_gdbarch))
d947 1
a947 1
      if (!gdbarch_believe_pcc_promotion (current_gdbarch))
a948 18
	  /* This is the signed type which arguments get promoted to.  */
	  static struct type *pcc_promotion_type;
	  /* This is the unsigned type which arguments get promoted to.  */
	  static struct type *pcc_unsigned_promotion_type;

	  /* Call it "int" because this is mainly C lossage.  */
	  if (pcc_promotion_type == NULL)
	    pcc_promotion_type =
	      init_type (TYPE_CODE_INT, 
			 gdbarch_int_bit (current_gdbarch) / TARGET_CHAR_BIT,
			 0, "int", NULL);

	  if (pcc_unsigned_promotion_type == NULL)
	    pcc_unsigned_promotion_type =
	      init_type (TYPE_CODE_INT, 
			 gdbarch_int_bit (current_gdbarch) / TARGET_CHAR_BIT,
			 TYPE_FLAG_UNSIGNED, "unsigned int", NULL);

d951 2
a952 1
	  if (TYPE_LENGTH (SYMBOL_TYPE (sym)) < TYPE_LENGTH (pcc_promotion_type)
d957 2
a958 2
		? pcc_unsigned_promotion_type
		: pcc_promotion_type;
d1033 1
a1033 2
	      && gdbarch_stabs_argument_has_addr (current_gdbarch,
						  SYMBOL_TYPE (sym)))
d1062 2
a1063 2
      if (gdbarch_static_transform_name_p (current_gdbarch)
	  && gdbarch_static_transform_name (current_gdbarch,
d1072 1
a1072 1
					       (current_gdbarch,	
d1245 2
a1246 2
      if (gdbarch_static_transform_name_p (current_gdbarch)
	  && gdbarch_static_transform_name (current_gdbarch,
d1255 1
a1255 1
					       (current_gdbarch,	
d1317 1
a1317 1
  if (gdbarch_stabs_argument_has_addr (current_gdbarch, SYMBOL_TYPE (sym))
d2703 2
d2809 1
a2809 1
		  == gdbarch_int_bit (current_gdbarch))
d3433 1
d3503 1
a3503 1
  TYPE_LENGTH (type) = gdbarch_int_bit (current_gdbarch) / HOST_CHAR_BIT;
d3838 1
d3964 1
a3964 1
	  bits = gdbarch_int_bit (current_gdbarch);
d4010 1
a4010 1
			  (current_gdbarch) / TARGET_CHAR_BIT))
d4027 1
a4027 1
    index_type = builtin_type_int;
a4034 2
      static struct type *range_type_index;

d4037 2
a4038 6
      if (range_type_index == NULL)
	range_type_index =
	  init_type (TYPE_CODE_INT, 
		     gdbarch_int_bit (current_gdbarch) / TARGET_CHAR_BIT,
		     0, "range type index type", NULL);
      index_type = range_type_index;
@


1.103
log
@	* coffread.c (decode_type): Use builtin_type_int32 instead
	of FT_INTEGER fundamental type for array range index type.
	(decode_base_type): Use builtin types of current_gdbarch
	instead of fundamental types.

	* dwarf2read.c (struct dwarf2_cu): Remove ftypes member.
	(read_file_scope): Do not initialize ftypes member.
	(dwarf_base_type, dwarf2_fundamental_types): Remove functions.
	(read_array_type): Use builtin_type_int32 instead of FT_INTEGER
	fundamental type for array range index type.
	(read_tag_string_type): Likewise for string range index type.
	Also, do not overwrite FT_CHAR type with new string type.
	(read_base_type): If DW_AT_name is missing, create unnamed type
	with given properties instead of looking for a fundamental type.
	Create new types as TYPE_TARGET_TYPE for DW_ATE_address and
	DW_ATE_complex_float types.
	(read_subrange_type): Create new type to represent missing
	DW_AT_type instead of looking for a fundamental type.
	(die_type): Use builtin type to represent "void" instead of
	looking for a fundamental type.

	* stabsread.c (define_symbol): Use builtin types to represent
	'r' and 'i' floating-point and integer constants.

	* gdbtypes.c (lookup_fundamental_type): Remove.
	* gdbtypes.h (lookup_fundamental_type): Remove prototype.
	(FT_VOID, FT_BOOLEAN, FT_CHAR, FT_SIGNED_CHAR, FT_UNSIGNED_CHAR,
	FT_SHORT, FT_SIGNED_SHORT, FT_UNSIGNED_SHORT, FT_INTEGER,
	FT_SIGNED_INTEGER, FT_UNSIGNED_INTEGER, FT_LONG, FT_SIGNED_LONG,
	FT_UNSIGNED_LONG, FT_LONG_LONG, FT_SIGNED_LONG_LONG,
	FT_UNSIGNED_LONG_LONG, FT_FLOAT, FT_DBL_PREC_FLOAT, FT_EXT_PREC_FLOAT,
	FT_COMPLEX, FT_DBL_PREC_COMPLEX, FT_EXT_PREC_COMPLEX, FT_STRING,
	FT_FIXED_DECIMAL, FT_FLOAT_DECIMAL, FT_BYTE, FT_UNSIGNED_BYTE,
	FT_TEMPLATE_ARG, FT_DECFLOAT, FT_DBL_PREC_DECFLOAT,
	FT_EXT_PREC_DECFLOAT, FT_NUM_MEMBERS): Remove macros.
	* objfiles.c (struct objfile): Remove fundamental_types member.
	* symfile.c (reread_symbols): Do not clear fundamental_types.

	* language.h (struct language_defn): Remove la_fund_type member.
	(create_fundamental_type): Remove.
	* language.c (unk_lang_create_fundamental_type): Remove.
	(unknown_language_defn, auto_language_defn,
	local_language_defn): Adapt initializer.
	* ada-lang.c (ada_create_fundamental_type): Remove.
	(ada_language_defn): Adapt initializer.
	* c-lang.h (c_create_fundamental_type): Remove prototype.
	* c-lang.c (c_create_fundamental_type): Remove.
	(c_language_defn, cplus_language_defn, asm_language_defn,
	minimal_language_defn): Adapt initializer.
	* f-lang.c (f_create_fundamental_type): Remove.
	(f_language_defn): Adapt initializer.
	* jv-lang.c (java_create_fundamental_type): Remove.
	(java_language_defn): Adapt initializer.
	* m2-lang.c (m2_create_fundamental_type): Remove.
	(m2_language_defn): Adapt initializer.
	* objc-lang.c (objc_create_fundamental_type): Remove.
	(objc_language_defn): Adapt initializer.
	* p-lang.h (pascal_create_fundamental_type): Remove prototype.
	* p-lang.c (pascal_create_fundamental_type): Remove.
	(pascal_language_defn): Adapt initializer.
	* scm-lang.c (scm_language_defn): Adapt initializer.
@
text
@d4 2
a5 2
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
   Free Software Foundation, Inc.
@


1.102
log
@	* gdbarch.sh (static_transform_name): New gdbarch callback.
	* gdbarch.c, gdbarch.h: Regenerate.
	* dbxread.c (read_dbx_symtab): Use gdbarch_static_transform_name
	instead of STATIC_TRANSFORM_NAME.
	* mdebugread.c (parse_partial_symbols): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* xcoffread.c (scan_xcoff_symtab): Likewise.

	* config/i368/tm-i386sol2.h (STATIC_TRANSFORM_NAME): Remove.
	(IS_STATIC_TRANSFORM_NAME): Remove.
	* i386-tdep.c (sunpro_static_transform_name): Remove, move to ...
	* i386-sol2-tdep.c (i386_sol2_static_transform_name): ... here.
	(i386_sol2_init_abi): Install it.

	* config/sparc/tm-sol2.h (STATIC_TRANSFORM_NAME): Remove.
	(IS_STATIC_TRANSFORM_NAME): Remove.
	* sparc-tdep.c (sparc_stabs_unglobalize_name): Remove, move to ...
	* sparc-sol2-tdep.c (sparc_sol2_static_transform_name): ... here.
	(sparc32_sol2_init_abi): Install it.
	* sparc64-sol2-tdep.c (sparc64_sol2_init_abi): Likewise.
	* sparc-tdep.h (sparc_sol2_static_transform_name): Add prototype.
@
text
@d728 1
d734 1
a734 9
	    /* FIXME: lookup_fundamental_type is a hack.  We should be
	       creating a type especially for the type of float constants.
	       Problem is, what type should it be?

	       Also, what should the name of this type be?  Should we
	       be using 'S' constants (see stabs.texinfo) instead?  */

	    SYMBOL_TYPE (sym) = lookup_fundamental_type (objfile,
							 FT_DBL_PREC_FLOAT);
d737 4
a740 2
			     TYPE_LENGTH (SYMBOL_TYPE (sym)));
	    store_typed_floating (dbl_valu, SYMBOL_TYPE (sym), d);
d754 1
a754 16
	    /* We just need one int constant type for all objfiles.
	       It doesn't depend on languages or anything (arguably its
	       name should be a language-specific name for a type of
	       that size, but I'm inclined to say that if the compiler
	       wants a nice name for the type, it can use 'e').  */
	    static struct type *int_const_type;

	    /* Yes, this is as long as a *host* int.  That is because we
	       use atoi.  */
	    if (int_const_type == NULL)
	      int_const_type =
		init_type (TYPE_CODE_INT,
			   sizeof (int) * HOST_CHAR_BIT / TARGET_CHAR_BIT, 0,
			   "integer constant",
			     (struct objfile *) NULL);
	    SYMBOL_TYPE (sym) = int_const_type;
@


1.101
log
@	* stabsread.c (read_huge_number): Initialize local variable to 0.
@
text
@a666 1
#ifdef STATIC_TRANSFORM_NAME
d669 3
a671 2
	  goto normal;
#endif
d1099 4
a1102 2
#ifdef STATIC_TRANSFORM_NAME
      if (IS_STATIC_TRANSFORM_NAME (DEPRECATED_SYMBOL_NAME (sym)))
d1108 3
a1110 1
	      DEPRECATED_SYMBOL_NAME (sym) = STATIC_TRANSFORM_NAME (DEPRECATED_SYMBOL_NAME (sym));
a1113 1
#endif
d1282 4
a1285 2
#ifdef STATIC_TRANSFORM_NAME
      if (IS_STATIC_TRANSFORM_NAME (DEPRECATED_SYMBOL_NAME (sym)))
d1291 3
a1293 1
	      DEPRECATED_SYMBOL_NAME (sym) = STATIC_TRANSFORM_NAME (DEPRECATED_SYMBOL_NAME (sym));
a1296 1
#endif
@


1.100
log
@2007-10-09  Pedro Alves  <pedro_alves@@portugalmail.pt>

	* stabsread.c (read_huge_number): Fix handling of octal
	representation when the bit width is known.
	(read_range_type): Record unsigned integral types with their size,
	when the type size is known.
@
text
@d3706 1
a3706 1
  int sign_bit;
@


1.99
log
@	* NEWS: Update description of string changes.  Mention print/s.
	* c-valprint.c (textual_element_type): New.
	(c_val_print): Use it.  Do not skip address printing for pointers
	with a string format.
	(c_value_print): Doc update.
	* dwarf2read.c (read_array_type): Use make_vector_type.
	* gdbtypes.c (make_vector_type): New.
	(init_vector_type): Use it.
	(gdbtypes_post_init): Initialize builtin_true_unsigned_char.
	(_initialize_gdbtypes): Mark int8_t and uint8_t as TYPE_FLAG_NOTTEXT.
	* gdbtypes.h (struct builtin_type): Add builtin_true_unsigned_char.
	(TYPE_FLAG_NOTTEXT, TYPE_NOTTEXT): New.
	(make_vector_type): New.
	* printcmd.c (print_formatted): Only handle 's' and 'i' for examine.
	Call the language print routine for string format.
	(print_scalar_formatted): Call val_print for string format.  Handle
	unsigned original types for char format.
	(validate_format): Do not reject string format.
	* stabsread.c (read_type): Use make_vector_type.
	* xml-tdesc.c (tdesc_start_vector): Use init_vector_type.

	* gdb.texinfo (Output Formats): Update 'c' description.  Describe 's'.
	(Examining Memory): Update mentions of the 's' format.
	(Automatic Display): Likewise.

	* gdb.arch/i386-sse.exp: Do not expect character constants.
	* gdb.base/charsign.c, gdb.base/charsign.exp: Delete.
	* gdb.base/display.exp: Allow print/s.
	* gdb.base/printcmds.exp, gdb.base/setvar.exp: Revert signed
	and unsigned char array changes.
@
text
@a3707 1
  long sn = 0;
d3713 1
a3713 1
  int twos_complement_representation;
d3729 31
a3759 1
  twos_complement_representation = radix == 8 && twos_complement_bits > 0;
d3768 7
a3774 9
              /* Octal, signed, twos complement representation. In this case,
                 sn is the signed value, n is the corresponding absolute
                 value. signed_bit is the position of the sign bit in the
                 first three bits.  */
              if (sn == 0)
                {
                  sign_bit = (twos_complement_bits % 3 + 2) % 3;
                  sn = c - '0' - ((2 * (c - '0')) | (2 << sign_bit));
                }
d3777 2
a3778 2
                  sn *= radix;
                  sn += c - '0';
a3779 3

              if (sn < 0)
                n = -sn;
d3823 9
d3845 3
a3847 2
         the number of bits.  */
      if (sign == -1)
d3856 1
a3856 4
      if (twos_complement_representation)
        return sn;
      else
        return n * sign;
d3981 1
a3981 1
  /* If the upper bound is -1, it must really be an unsigned int.  */
d3985 10
a3994 5
      /* It is unsigned int or unsigned long.  */
      /* GCC 2.3.3 uses this for long long too, but that is just a GDB 3.5
         compatibility hack.  */
      return init_type (TYPE_CODE_INT, 
			gdbarch_int_bit (current_gdbarch) / TARGET_CHAR_BIT,
@


1.99.2.1
log
@2007-10-08  Pedro Alves  <pedro_alves@@portugalmail.pt>

	Revert:
	2007-08-10  Michael Snyder  <msnyder@@access-company.com>

	* stabsread.c (read_huge_number): Attempt to compute value before
	values that it depends on.
@
text
@d3714 1
a3714 1
  int twos_complement_representation = radix == 8 && twos_complement_bits > 0;
d3730 1
@


1.98
log
@2007-09-04  Michael Snyder  <msnyder@@access-company.com>

	* stabsread.c (patch_block_status): Guard against null.
	* Makefile.in (stabsread.o): Depend on gdb_assert.h.
@
text
@d1919 1
a1919 1
	TYPE_FLAGS (type) |= TYPE_FLAG_VECTOR;
@


1.97
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d48 1
d363 1
@


1.96
log
@2007-08-18  Michael Snyder  <msnyder@@svkmacdonelllnx>

	* stabsread.c (dbx_lookup_type): Memory leak.
@
text
@d11 1
a11 1
   the Free Software Foundation; either version 2 of the License, or
d20 1
a20 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.95
log
@2007-08-10  Michael Snyder  <msnyder@@access-company.com>

	* stabsread.c (read_huge_number): Attempt to compute value before
	values that it depends on.
@
text
@d286 1
a286 2
	  struct type *temp_type;
	  struct type **temp_type_p;
d291 1
a291 3
	  temp_type = init_type (TYPE_CODE_ERROR, 0, 0, NULL, NULL);
	  temp_type_p = (struct type **) xmalloc (sizeof (struct type *));
	  *temp_type_p = temp_type;
@


1.94
log
@	* gdbarch.sh (BELIEVE_PCC_PROMOTION): Replace by
	gdbarch_believe_pcc_promotion.
	* stabsread.c (define_symbol): Likewise.
	Remove unnecessary definition.
	* coffread.c (process_coff_symbol): Remove unnecessary code.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d3717 1
a3717 1
  int twos_complement_representation = radix == 8 && twos_complement_bits > 0;
d3733 1
@


1.93
log
@2007-06-18  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (SP_REGNUM): Replace by gdbarch_sp_regnum.
	* v850-tdep.c (v850_unwind_sp): Likewise.
	* std-regs.c (value_of_builtin_frame_sp_reg): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh-tdep.c (sh_push_dummy_call_fpu, sh_push_dummy_call_nofpu)
	(sh_dwarf2_frame_init_reg, sh_frame_cache, sh_frame_prev_register)
	(sh_unwind_sp): Likewise.
	* sh64-tdep.c (sh64_push_dummy_call, sh64_frame_cache)
	(sh64_frame_prev_register, sh64_unwind_sp): Likewise.
	* rs6000-tdep.c (rs6000_push_dummy_call, rs6000_unwind_dummy_id)
	(rs6000_frame_cache): Likewise.
	* rs6000-nat.c (store_register): Likewise.
	* remote-mips.c (mips_wait): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_cache): Likewise.
	* ppcobsd-nat.c (ppcobsd_supply_pcb): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_sigtramp_cache_init): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* m32r-rom.c (m32r_supply_register): Likewise.
	* frame.c (frame_sp_unwind): Likewise.
	* mips-tdep.c (mips_insn16_frame_cache)
	(mips_insn32_frame_cache): Likewise (comment).
	* m68klinux-nat.c (supply_gregset): Likewise.
	* m68k-tdep.c (m68k_get_longjmp_target): Likewise.
	* ia64-tdep.c (ia64_frame_prev_register): Likewise.
	* i386-tdep.c (i386_get_longjmp_target): Likewise.
	* dwarf2-frame.c (dwarf2_frame_default_init_reg): Likewise.
	* cris-tdep.c (cris_regnums, cris_sigcontext_addr)
	(cris_sigtramp_frame_unwind_cache, cris_push_dummy_call)
	(cris_scan_prologue, crisv32_scan_prologue, cris_unwind_sp)
	(cris_register_type, crisv32_register_type)
	(cris_dwarf2_frame_init_reg): Likewise.
	* arch-utils.c (legacy_virtual_frame_pointer): Likewise.
	* amd64-tdep.c (amd64_frame_prev_register): Likewise.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Likewise.
	* libunwind-frame.c (libunwind_frame_cache): Likewise.

	* gdbarch.sh (PC_REGNUM): Replace by gdbarch_pc_regnum.
	* regcache.c (read_pc_pid, generic_target_write_pc): Likewise.
	* xtensa-tdep.c (xtensa_register_type, xtensa_supply_gregset)
	(xtensa_unwind_pc, xtensa_frame_cache, xtensa_frame_prev_register)
	(xtensa_extract_return_value, xtensa_store_return_value): Likewise.
	* v850-tdep.c (v850_unwind_pc): Likewise.
	* stack.c (frame_info): Likewise.
	* sh-tdep.c (sh_generic_show_regs, sh3_show_regs, sh2e_show_regs)
	(sh2a_show_regs, sh2a_nofpu_show_regs, sh3e_show_regs)
	(sh3_dsp_show_regs, sh4_show_regs, sh4_nofpu_show_regs)
	(sh_dwarf2_frame_init_reg, sh_frame_prev_register, sh_unwind_pc)
	(sh_dsp_show_regs): Likewise.
	* shnbsd-tdep.c (shnbsd_supply_gregset)
	(shnbsd_collect_gregset): Likewise.
	* shnbsd-nat.c (GETREGS_SUPPLIES): Likewise.
	* sh64-tdep.c (sh64_compact_reg_base_num, sh64_show_media_regs)
	(sh64_frame_prev_register, sh64_unwind_pc): Likewise.
	* rs6000-tdep.c (ppc_supply_gregset, ppc_collect_gregset)
	(6000_register_reggroup_p, rs6000_unwind_pc)
	(rs6000_frame_cache): Likewise.
	* rs6000-nat.c (regmap, rs6000_fetch_inferior_registers)
	(rs6000_store_inferior_registers): Likewise.
	* remote-mips.c (mips_wait, mips_load): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_cache): Likewise.
	* ppcobsd-nat.c (ppcobsd_supply_pcb): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_sigtramp_cache_init): Likewise.
	* ppcnbsd-nat.c (getregs_supplies, ppcnbsd_supply_pcb): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* ppc-linux-nat.c (ppc_register_u_addr, fetch_ppc_registers)
	(store_ppc_registers, fill_gregset): Likewise.
	* mips-tdep.c (mips_stub_frame_cache, mips_gdbarch_init): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_supply_reg, mipsnbsd_fill_reg): Likewise.
	* mipsnbsd-nat.c (getregs_supplies): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_unwind_pc): Likewise.
	* m68klinux-nat.c (supply_gregset): Likewise.
	* irix5-nat.c (fill_gregset): Likewise.
	* i386-tdep.c (i386_unwind_pc): Likewise.
	* i386-linux-nat.c (i386_linux_resume): Likewise.
	* frame.c (get_prev_frame_1): Likewise.
	* dwarf2-frame.c (dwarf2_frame_default_init_reg): Likewise.
	* dbug-rom.c (dbug_supply_register): Likewise.
	* cris-tdep.c (cris_sigtramp_frame_unwind_cache, cris_scan_prologue)
	(crisv32_scan_prologue, cris_unwind_pc, cris_register_size)
	(cris_register_type, crisv32_register_type, crisv32_register_name)
	(cris_dwarf2_frame_init_reg, find_step_target)
	(cris_software_single_step, cris_supply_gregset)
	(cris_regnums): Likewise.
	* alpha-linux-nat.c (alpha_linux_register_u_offset): Likewise.
	* aix-thread.c (special_register_p, supply_sprs64, supply_sprs32)
	(fill_sprs64, fill_sprs32, store_regs_user_thread): Likewise.
	* mips-linux-tdep.c (mips_linux_write_pc): Likewise.

	* gdbarch.sh (PS_REGNUM): Replace by gdbarch_ps_regnum.
	* dbug-rom.c (dbug_supply_register): Likewise.
	* xtensa-tdep.c (xtensa_supply_gregset, xtensa_frame_cache)
	(xtensa_frame_prev_register, xtensa_push_dummy_call): Likewise.
	* win32-nat.c (win32_resume): Likewise.
	* std-regs.c (value_of_builtin_frame_ps_reg)
	(value_of_builtin_frame_pc_reg): Likewise.
	* m68k-tdep.c (m68k_register_type): Likewise.
	* m68klinux-nat.c (supply_gregset): Likewise.

	* gdbarch.sh (FP0_REGNUM): Replace by gdbarch_fp0_regnum.
	* sh-tdep.c (sh_extract_return_value_fpu, sh_store_return_value_fpu)
	(sh2e_show_regs, sh2a_show_regs, sh3e_show_regs, sh4_show_regs)
	(sh_sh2a_register_type, sh_sh3e_register_type, sh_sh4_register_type)
	(fv_reg_base_num, dr_reg_base_num): Likewise.
	* sh64-tdep.c (sh64_fv_reg_base_num, sh64_dr_reg_base_num)
	(sh64_fpp_reg_base_num, sh64_compact_reg_base_num, sh64_push_dummy_call)
	(sh64_extract_return_value, sh64_store_return_value)
	(sh64_show_media_regs, sh64_show_compact_regs, sh64_register_type)
	(sh64_do_fp_register, sh64_media_print_registers_info): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers)
	(invalidate_cache): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_supply_fpreg)
	(mipsnbsd_fill_fpreg): Likewise.
	* mipsnbsd-nat.c (mipsnbsd_fetch_inferior_registers)
	(mipsnbsd_store_inferior_registers): Likewise.
	* mips-linux-tdep.c (mips_supply_fpregset, mips_fill_fpregset)
	(mips64_supply_fpregset, mips64_fill_fpregset): Likewise.
	* mips-linux-nat.c (mips64_linux_register_addr): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_convert_register_p): Likewise.
	* m68klinux-nat.c (getfpregs_supplies, supply_fpregset)
	(fill_fpregset): Likewise.
	* irix5-nat.c (supply_fpregset, fill_fpregset): Likewise.
	* i386-tdep.h (struct_return): Likewise (comment).
	* i386-nto-tdep.c (i386nto_register_area): Likewise.
	* go32-nat.c (fetch_register, go32_fetch_registers, store_register)
	(go32_store_registers): Likewise.
	* alpha-tdep.c (alpha_next_pc): Likewise.
	* alpha-linux-nat.c (alpha_linux_register_u_offset): Likewise.
	* alphabsd-nat.c (alphabsd_fetch_inferior_registers)
	(alphabsd_store_inferior_registers): Likewise.
	* core-regset.c (fetch_core_registers): Likewise.
	* i386v4-nat.c (supply_fpregset, fill_fpregset): Likewise.

	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@a164 9
/* Define this as 1 if a pcc declaration of a char or short argument
   gives the correct address.  Otherwise assume pcc gives the
   address of the corresponding int, which is not the same on a
   big-endian machine.  */

#if !defined (BELIEVE_PCC_PROMOTION)
#define BELIEVE_PCC_PROMOTION 0
#endif

d965 2
a966 1
      if (processing_gcc_compilation || BELIEVE_PCC_PROMOTION)
d969 1
a969 1
      if (!BELIEVE_PCC_PROMOTION)
@


1.92
log
@2007-06-12  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (STAB_REG_TO_REGNUM): Replace by
	gdbarch_stab_reg_to_regnum.
	* stabsread.c (define_symbol): Likewise.
	* gdbarch.sh (ECOFF_REG_TO_REGNUM): Replace by
	gdbarch_ecoff_reg_to_regnum.
	* mdebugread.c (parse_symbol): Likewise.
	* i386-tdep.c (i386_gdbarch_init): Likewise (comment).
	* gdbarch.sh (DWARF_REG_TO_REGNUM): Replace by
	gdbarch_dwarf_reg_to_regnum.
	* gdbarch.sh (SDB_REG_TO_REGNUM): Replace by gdbarch_sdb_reg_to_regnum.
	* coffread.c (process_coff_symbol): Likewise.
	* gdbarch.sh (DWARF2_REG_TO_REGNUM): Replace by
	gdbarch_dwarf2_reg_to_regnum.
	* dwarf2loc.c (dwarf_expr_read_reg,dwarf2_evaluate_loc_desc)
	(locexpr_describe_location): Likewise.
	* dwarf2-frame.c (read_reg,execute_cfa_program,dwarf2_frame_cache)
	(dwarf2_frame_prev_register,dwarf2_signal_frame_this_id): Likewise.
	* dwarf2loc.c (DWARF2_REG_TO_REGNUM): Remove macro.
	* dwarf2read.c (DWARF2_REG_TO_REGNUM): Remove macro.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d1033 2
a1034 1
	  SYMBOL_VALUE (sym) = SP_REGNUM;	/* Known safe, though useless */
d1052 2
a1053 1
	  SYMBOL_VALUE (sym) = SP_REGNUM;	/* Known safe, though useless */
d1327 2
a1328 1
	  SYMBOL_VALUE (sym) = SP_REGNUM;	/* Known safe, though useless */
@


1.91
log
@2007-06-12  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (TARGET_SHORT_BIT): Replace by gdbarch_int_bit.
	* ada-lang.c (ada_create_fundamental_type)
	(ada_language_arch_info): Likewise.
	* c-lang.c (c_create_fundamental_type): Likewise.
	* f-lang.c (f_create_fundamental_type, build_fortran_types): Likewise.
	* gdbtypes.c (build_gdbtypes, gdbtypes_post_init): Likewise.
	* m2-lang.c (m2_create_fundamental_type): Likewise.
	* objc-lang.c (objc_create_fundamental_type): Likewise.
	* p-lang.c (pascal_create_fundamental_type): Likewise.
	* gdbarch.sh (TARGET_INT_BIT): Replace by gdbarch_int_bit.
	* c-exp.y (parse_number): Likewise.
	* objc-exp.y (parse_number): Likewise.
	* ada-lex.l (processInt): Likewise.
	* f-exp.y (parse_number): Likewise.
	* p-exp.y (parse_number): Likewise.
	* ada-lang.c (ada_create_fundamental_type, ada_language_arch_info)
	(gdbtypes_post_init, build_gdbtypes): Likewise.
	* p-lang.c (pascal_create_fundamental_type): Likewise.
	* parse.c (build_parse): Likewise.
	* xcoffread.c (_initialize_xcoffread): Likewise.
	* stabsread.c (define_symbol, read_one_struct_field, read_enum_type)
	(read_range_type): Likewise.
	* objc-lang.c (objc_create_fundamental_type): Likewise.
	* f-lang.c (build_fortran_types, f_create_fundamental_type): Likewise.
	* m2-lang.c (m2_create_fundamental_type, _initialize_m2_language)
	(m2_create_fundamental_type): Likewise.
	* c-lang.c (c_create_fundamental_type): Likewise.
	* coffread.c (coff_read_enum_type): Likewise.
	* mdebugread.c (parse_symbol, _initialize_mdebugread): Likewise.
	* dwarf2read.c (new_symbol): Likewise.
	* gdbarch.sh (TARGET_LONG_BIT): Replace by gdbarch_long_bit.
	* c-exp.y (parse_number): Likewise.
	* objc-exp.y (parse_number): Likewise.
	* ada-lex.l (processInt): Likewise.
	* f-exp.y (parse_number): Likewise.
	* p-exp.y (parse_number): Likewise.
	* valarith.c (value_binop): Likewise.
	* symfile.c (read_target_long_array, simple_overlay_update_1): Likewise.
	* ada-lang.c (ada_create_fundamental_type)
	(ada_language_arch_info): Likewise.
	* gdbtypes.c (build_gdbtypes, gdbtypes_post_init): Likewise.
	* symfile.c (TARGET_LONG_BYTES): Likewise.
	* p-lang.c (pascal_create_fundamental_type): Likewise.
	* objc-lang.c (objc_create_fundamental_type): Likewise.
	* m2-lang.c (m2_create_fundamental_type): Likewise.
	* f-lang.c (f_create_fundamental_type): Likewise.
	* c-lang.c (c_create_fundamental_type): Likewise.
	* coffread.c (decode_base_type): Likewise.
	* gdbarch.sh (TARGET_LONG_LONG_BIT): Replace by gdbarch_long_long_bit.
	* c-exp.y (parse_number): Likewise.
	* objc-exp.y (parse_number): Likewise.
	* p-exp.y (parse_number): Likewise.
	* ada-lang.c (ada_create_fundamental_type)
	(ada_language_arch_info): Likewise.
	* gdbtypes.c (gdbtypes_post_init, build_gdbtypes): Likewise.
	* stabsread.c (read_range_type): Likewise.
	* p-lang.c (pascal_create_fundamental_type): Likewise.
	* objc-lang.c (objc_create_fundamental_type): Likewise.
	* m2-lang.c (m2_create_fundamental_type): Likewise.
	* f-lang.c (f_create_fundamental_type): Likewise.
	* c-lang.c (c_create_fundamental_type): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d1025 1
a1025 1
      SYMBOL_VALUE (sym) = STAB_REG_TO_REGNUM (valu);
d1043 1
a1043 1
      SYMBOL_VALUE (sym) = STAB_REG_TO_REGNUM (valu);
d1317 1
a1317 1
      SYMBOL_VALUE (sym) = STAB_REG_TO_REGNUM (valu);
@


1.90
log
@2007-05-31  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (NUM_REGS): Replace by gdbarch_num_regs.
	* i386-tdep.c (i386_dbx_reg_to_regnum)
	(i386_svr4_reg_to_regnum): Likewise.
	* inf-ptrace.c (inf_ptrace_fetch_registers)
	(inf_ptrace_store_registers): Likewise.
	* corelow.c (get_core_registers): Likewise.
	* i386-linux-nat.c (supply_gregset, fill_gregset)
	(i386_linux_fetch_inferior_registers)
	(i386_linux_store_inferior_registers): Likewise.
	* remote.c (init_remote_state,packet_reg_from_regnum)
	(packet_reg_from_pnum,process_g_packet,remote_fetch_registers)
	(remote_prepare_to_store,store_registers_using_G)
	(remote_store_registers,remote_arch_state): Likewise.
	* tracepoint.c (encode_actions): Likewise.
	* mi/mi-main.c (mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers,mi_cmd_data_list_register_values)
	(mi_cmd_data_write_register_values): Likewise.
	* tui/tui-regs.c (tui_show_register_group)
	(tui_show_register_group): Likewise.
	* xtensa-tdep.h (FP_ALIAS): Likewise.
	* xtensa-tdep.c (xtensa_register_name,xtensa_register_type)
	(xtensa_reg_to_regnum,xtensa_pseudo_register_read)
	(xtensa_pseudo_register_write,xtensa_register_reggroup_p): Likewise.
	* win32-nat.c (do_win32_fetch_inferior_registers)
	(do_win32_store_inferior_registers,fetch_elf_core_registers
	* user-regs.h: Likewise (comment).
	* user-regs.c (user_reg, user_reg_map_name_to_regnum): Likewise.
	* trad-frame.c (trad_frame_alloc_saved_regs): Likewise.
	* target-descriptions.h: Likewise (comment).
	* target-descriptions.c (tdesc_use_registers): Likewise (comment).
	* target.c (debug_print_register): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh64-tdep.c (sh64_do_pseudo_register,sh64_print_register)
	(sh64_media_print_registers_info)
	(sh64_compact_print_registers_info): Likewise.
	* rs6000-tdep.c (rs6000_register_sim_regno): Likewise.
	* rs6000-nat.c (fetch_register,store_register): Likewise.
	* remote-sim.c (one2one_register_sim_regno,gdbsim_fetch_register)
	(gdbsim_fetch_register,gdbsim_store_register): Likewise.
	* remote-mips.c (mips_fetch_registers,mips_store_registers): Likewise.
	* remote-m32r-sdi.c (m32r_fetch_registers)
	(m32r_store_registers): Likewise.
	* reggroups.c (default_register_reggroup_p): Likewise.
	* regcache.c (init_regcache_descr,register_size,regcache,regcache_save)
	(regcache_restore,regcache_dump): Likewise.
	* monitor.c (monitor_fetch_registers,monitor_store_registers): Likewise.
	* mips-tdep.c (mips_xfer_register,mips_register_name)
	(mips_register_reggroup_p,mips_pseudo_register_read)
	(mips_pseudo_register_write,mips_convert_register_p,mips_register_type)
	(mips_unwind_pc,mips_unwind_sp,mips_unwind_dummy_id,set_reg_offset)
	(mips16_scan_prologue,mips_insn16_frame_cache,reset_saved_regs)
	(mips32_scan_prologue,mips_insn32_frame_cache,read_next_frame_reg)
	(mips_n32n64_return_value,mips_o32_return_value,mips_o64_return_value)
	(print_gp_register_row,mips_print_registers_info)
	(mips_stab_reg_to_regnum,mips_dwarf_dwarf2_ecoff_reg_to_regnum)
	(mips_register_sim_regno): Likewise.
	* mips-linux-tdep.c (mips_linux_o32_sigframe_init)
	(mips_linux_n32n64_sigframe_init): Likewise.
	* mips-linux-nat.c (mips_linux_register_addr)
	(mips64_linux_register_addr): Likewise.
	* findvar.c (value_of_register): Likewise.
	* infcmd.c (default_print_registers_info,registers_info)
	(print_vector_info,print_float_info): Likewise.
	* mips64obsd-tdep.c (mips64obsd_sigframe_init): Likewise.
	* inf-child.c (inf_child_fetch_inferior_registers): Likewise.
	* m68k-tdep.c (m68k_dwarf_reg_to_regnum): Likewise.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache(: Likewise.
	* m32r-tdep.c (m32r_frame_unwind_cache): Likewise.
	* ia64-linux-nat.c (ia64_register_addr,ia64_cannot_fetch_register)
	(ia64_cannot_store_register,ia64_linux_fetch_registers)
	(ia64_linux_store_registers): Likewise.
	* hpux-thread.c (hpux_thread_fetch_registers)
	(hpux_thread_store_registers): Likewise.
	* h8300-tdep.c (E_PSEUDO_CCR_REGNUM,E_PSEUDO_EXR_REGNUM)
	(h8300_init_frame_cache,h8300_frame_cache,h8300_frame_prev_register)
	(h8300_register_type): Likewise.
	* dwarf2-frame.c (dwarf2_frame_cache)
	(dwarf2_frame_state_alloc_regs): Likewise.
	* cris-tdep.c (cris_register_size,cris_cannot_fetch_register)
	(cris_cannot_store_register,crisv32_cannot_fetch_register)
	(crisv32_cannot_store_register,cris_register_name): Likewise.
	* avr-tdep.c (avr_frame_unwind_cache): Likewise.
	* arch-utils.c (legacy_register_sim_regno)
	(legacy_virtual_frame_pointer): Likewise.
	* arm-tdep.c (arm_make_prologue_cache,arm_register_sim_regno):Likewise.
	* arm-tdep.h: Likewise (comment).
	* frv-tdep.c (frv_register_sim_regno): Likewise.
	* m68klinux-nat.c (old_fetch_inferior_registers)
	(old_store_inferior_registers): Likewise.
	* m32c-tdep.c (m32c_virtual_frame_pointer): Likewise.
	* irix5-nat.c (fetch_core_registers): Likewise.
	* hppa-tdep.c (hppa_frame_cache): Likewise.
	* hppa-linux-nat.c (hppa_linux_register_addr)
	(hppa_linux_fetch_inferior_registers)
	(hppa_linux_store_inferior_registers): Likewise.
	* hppa-hpux-nat.c (hppa_hpux_fetch_inferior_registers)
	(hppa_hpux_store_inferior_registers): Likewise.
	* amd64-nat.c (amd64_native_gregset_reg_offset)
	(amd64_supply_native_gregset,amd64_collect_native_gregset): Likewise.
	* dbug-rom.c (dbug_regname): Likewise.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache)
	(HARD_PAGE_REGNUM (comment)): Likewise.
	* gdbarch.sh (NUM_PSEUDO_REGS): Replace by gdbarch_num_pseudo_regs.
	* i386-tdep.c (i386_dbx_reg_to_regnum)
	(i386_svr4_reg_to_regnum): Likewise.
	* mi/mi-main.c (mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers,mi_cmd_data_list_register_values)
	(mi_cmd_data_write_register_values): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
	* tui/tui-regs.c (tui_show_register_group): Likewise.
	* xtensa-tdep.h (FP_ALIAS): Likewise.
	* user-regs.h: Likewise (comment).
	* user-regs.c (user_reg, user_reg_map_name_to_regnum): Likewise.
	* trad-frame.c (trad_frame_alloc_saved_regs): Likewise.
	* target-descriptions.h: Likewise (comment).
	* target.c (debug_print_register): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh64-tdep.c (sh64_print_register,sh64_media_print_registers_info)
	(sh64_compact_print_registers_info): Likewise.
	* rs6000-tdep.c (rs6000_register_sim_regno): Likewise.
	* regcache.c (init_regcache_descr,register_size,regcache,regcache_save
	(regcache_restore,regcache_dump): Likewise.
	* mips-tdep.c (print_gp_register_row,mips_print_registers_info)
	(mips_dwarf_dwarf2_ecoff_reg_to_regnum)
	(mips_stab_reg_to_regnum): Likewise.
	* findvar.c (value_of_register): Likewise.
	* infcmd.c (default_print_registers_info,registers_info)
	(print_vector_info,print_float_info): Likewise.
	* m68k-tdep.c (m68k_dwarf_reg_to_regnum): Likewise.
	* h8300-tdep.c (h8300_register_type): Likewise.
	* dwarf2-frame.c (dwarf2_frame_cache): Likewise.
	* frame.h (SIZEOF_FRAME_SAVED_REGS): Likewise.
	* xtensa-tdep.c (xtensa_register_type,xtensa_reg_to_regnum)
	(xtensa_pseudo_register_read,xtensa_pseudo_register_write): Likewise.
	* parse.c: Remove comment.
	* gdbarch.c, gdbarch.h: Regenerate
@
text
@d987 2
a988 1
	      init_type (TYPE_CODE_INT, TARGET_INT_BIT / TARGET_CHAR_BIT,
d993 2
a994 1
	      init_type (TYPE_CODE_INT, TARGET_INT_BIT / TARGET_CHAR_BIT,
d2845 2
a2846 1
	       && FIELD_BITSIZE (fip->list->field) == TARGET_INT_BIT)
d3539 1
a3539 1
  TYPE_LENGTH (type) = TARGET_INT_BIT / HOST_CHAR_BIT;
d3964 2
a3965 1
      return init_type (TYPE_CODE_INT, TARGET_INT_BIT / TARGET_CHAR_BIT,
d4007 2
a4008 1
	       || n2 == -TARGET_LONG_LONG_BIT / TARGET_CHAR_BIT))
d4039 2
a4040 1
	  init_type (TYPE_CODE_INT, TARGET_INT_BIT / TARGET_CHAR_BIT,
@


1.89
log
@2007-05-31  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (TARGET_BYTE_ORDER): Replace by gdbarch_byte_order.
	* ax-gdb.c (gen_bitfield_ref): Likewise.
	* mi/mi-main.c (get_register): Likewise.
	* findvar.c (default_value_from_register, extract_signed_integer)
	(extract_unsigned_integer, extract_long_unsigned_integer)
	(store_signed_integer, store_unsigned_integer): Likewise.
	* regcache.c (regcache_dump): Likewise.
	* value.c (lookup_internalvar, value_of_internalvar)
	(set_internalvar): Likewise.
	* defs.h: Likewise.
	* valprint.c (print_binary_chars, print_octal_chars)
	(print_decimal_chars, print_hex_chars, print_char_chars): Likewise.
	* infcmd.c (default_print_registers_info): Likewise.
	* arch-utils.c (selected_byte_order, show_endian): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* doublest.c (floatformat_from_length, floatformat_from_type)
	(extract_typed_floating, store_typed_floating): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d1024 2
a1025 1
      if (SYMBOL_VALUE (sym) >= NUM_REGS + NUM_PSEUDO_REGS)
d1028 2
a1029 1
			       NUM_REGS + NUM_PSEUDO_REGS,
d1042 2
a1043 1
      if (SYMBOL_VALUE (sym) >= NUM_REGS + NUM_PSEUDO_REGS)
d1046 2
a1047 1
			       NUM_REGS + NUM_PSEUDO_REGS,
d1316 2
a1317 1
      if (SYMBOL_VALUE (sym) >= NUM_REGS + NUM_PSEUDO_REGS)
d1320 2
a1321 1
			       NUM_REGS + NUM_PSEUDO_REGS,
@


1.88
log
@        * stabsread.c (add_undefined_type): Add extra parameter.
        Now handles nameless types separately.
        (struct nat): New type.
        (noname_undefs, noname_undefs_allocated, noname_undefs_length):
        New static variables.
        (read_type): Update calls to add_undefined_type.
        (add_undefined_type_noname): New function.
        (add_undefined_type_1): Renames from add_undefined_type.
        (cleanup_undefined_types_noname): New function.
        (cleanup_undefined_types_1): Renames cleanup_undefined_types.
        (cleanup_undefined_types): New handles nameless types separately.
        (_initialize_stabsread): Initialize our new static constants.
@
text
@d966 1
a966 1
      if (TARGET_BYTE_ORDER != BFD_ENDIAN_BIG)
@


1.87
log
@        * stabsread.c (define_symbol): Create an associated STRUCT_DOMAIN
        symbol for Ada units when the symbol is defined using 't' rather
        than 'Tt' as symbol descriptor.
@
text
@d150 1
a150 1
static void add_undefined_type (struct type *);
d201 14
d1464 1
a1464 1
            add_undefined_type (type);
d1590 1
a1590 1
	add_undefined_type (type);
d4187 24
a4210 4
/* What about types defined as forward references inside of a small lexical
   scope?  */
/* Add a type to the list of undefined types to be checked through
   once this file has been read in.  */
d4213 1
a4213 1
add_undefined_type (struct type *type)
d4225 42
d4276 1
d4278 1
a4278 1
cleanup_undefined_types (void)
d4339 10
d4584 5
@


1.86
log
@Copyright updates for 2007.
@
text
@d1105 16
d1204 18
@


1.85
log
@	* NEWS: Mention pointer to member improvements.
	* Makefile.in (gnu-v3-abi.o): Delete special rule.
	(eval.o, gnu-v3-abi.o, ia64-tdep.o): Update.
	* ada-valprint.c (ada_print_scalar): Update for new type codes.
	* c-typeprint.c (c_print_type): Update for new type codes.
	(c_type_print_varspec_prefix, c_type_print_varspec_suffix)
	(c_type_print_base): Likewise.
	(c_type_print_args): Rewrite.
	* c-valprint.c (c_val_print): Update for new type codes.  Remove
	support for references to members.  Treat methods like functions.
	* cp-abi.c (cplus_print_method_ptr, cplus_method_ptr_size)
	(cplus_make_method_ptr, cplus_method_ptr_to_value): New.
	* cp-abi.h (cplus_print_method_ptr, cplus_method_ptr_size)
	(cplus_make_method_ptr, cplus_method_ptr_to_value): New prototypes.
	(struct cp_abi_ops): Add corresponding members.
	* cp-valprint.c (cp_print_class_method): Delete.
	(cp_find_class_member): New function.
	(cp_print_class_member): Use it.  Simplify support for bogus
	member pointers.
	* dwarf2read.c (quirk_gcc_member_function_pointer): Use
	lookup_methodptr_type.
	(read_tag_ptr_to_member_type): Likewise, and lookup_memberptr_type.
	* eval.c (evaluate_subexp_standard): Implement EVAL_SKIP for
	OP_SCOPE.  Update call to value_aggregate_elt.  Rewrite member
	pointer support.
	(evaluate_subexp_for_address): Handle OP_SCOPE explicitly.  Handle
	references returned by user defined operators.
	* f-typeprint.c (f_print_type, f_type_print_varspec_prefix)
	(f_type_print_varspec_suffix): Remove support for member pointers.
	* gdbtypes.c (lookup_memberptr_type): Renamed from lookup_member_type
	and adjusted.
	(smash_to_memberptr_type): Likewise, from smash_to_member_type.
	(lookup_methodptr_type): New.
	(rank_one_type): Adjust for TYPE_CODE_MEMBERPTR.
	(recursive_dump_type): Update for new types.
	* gdbtypes.h (enum type_code): Replace TYPE_CODE_MEMBER with
	TYPE_CODE_MEMBERPTR and TYPE_CODE_METHODPTR.
	(lookup_memberptr_type, lookup_methodptr_type)
	(smash_to_memberptr_type): New prototypes.
	(smash_to_method_type): Formatting fix.
	(lookup_member_type, smash_to_member_type): Delete prototypes.
	* gnu-v3-abi.c (gnuv3_get_vtable, gnuv3_get_virtual_fn): New.
	Do not rely on debug information for the vptr or the method's
	enclosing type.  Handle function descriptors for IA64.
	(gnuv3_virtual_fn_field): Rewrite using the new functions.
	(gnuv3_find_method_in, gnuv3_print_method_ptr)
	(gnuv3_method_ptr_size, gnuv3_make_method_ptr)
	(gnuv3_method_ptr_to_value): New.
	(init_gnuv3_ops): Set new members of gnu_v3_abi_ops.
	* hpread.c (hpread_type_lookup): Update for new types.
	* infcall.c (value_arg_coerce): Likewise.
	* m2-typeprint.c (m2_print_type): Remove explicit support
	for member pointers.
	* m2-valprint.c (m2_val_print): Likewise.
	* p-typeprint.c (pascal_type_print_varspec_prefix)
	(pascal_type_print_varspec_suffix, pascal_type_print_base): Likewise.
	* p-valprint.c (pascal_val_print): Likewise.
	(pascal_object_print_class_method, pascal_object_print_class_member):
	Delete.
	* p-lang.h (pascal_object_print_class_method)
	(pascal_object_print_class_member): Delete prototypes.
	* stabsread.c (read_type): Update for new types.
	* typeprint.c (print_type_scalar): Likewise.
	* valops.c (value_struct_elt_for_reference, value_namespace_elt)
	(value_maybe_namespace_elt, value_aggregate_elt): Add want_address
	argument.  Construct a pointer to member if the address of a
	function or data member is requested.
	(value_cast_pointers): Don't modify the input value.
	(value_cast): Adjust pointer to member handling for new types.
	Allow null pointer to member constants.  Don't modify the input
	value.
	(value_ind): Remove pointer to member check.  Handle function
	descriptors for function pointers.
	(value_struct_elt, value_find_oload_method_list, check_field):
	Remove pointer to member checks.
	* value.c (unpack_long): Allow pointers to data members.
	(value_from_longest): Allow member pointers.
	* value.h (value_aggregate_elt): Add want_address.
	* varobj.c (c_variable_editable): Remove check for members.
	* gdbarch.sh: Add vtable_function_descriptors and vbit_in_delta.
	* ia64-tdep.c (ia64_convert_from_func_ptr_addr): Handle descriptors
	in virtual tables.
	(ia64_gdbarch_init): Call set_gdbarch_vtable_function_descriptors.
	* c-lang.h (cp_print_class_method): Delete prototype.
	* arm-tdep.c (arm_gdbarch_init): Call set_gdbarch_vbit_in_delta.
	* mips-tdep.c (mips_gdbarch_init): Likewise.
	* gdbarch.c, gdbarch.h: Regenerated.

	* gdb.cp/classes.exp (test_pointers_to_class_members): Update expected
	output.  Test the types of members and member pointers.
	* gdb.cp/inherit.exp (test_print_mi_member_types): Remove KFAILs for
	gdb/2092.
	* gdb.cp/member-ptr.exp: Search for a comment instead of a
	statement.  Enable for GCC.  Update expected output for some tests
	and add new tests.  Remove obsolete GCC KFAILs.  Allow GCC's class
	layout.
	* gdb.cp/member-ptr.cc (Padding, Padding::vspacer, Base, Base::get_x)
	(Base::vget_base, Left, Left::vget, Right, Right::vget, Diamond)
	(Diamond::vget_base): New.
	(main): Add new tests.
	* gdb.cp/printmethod.exp: Update expected output for member functions.
	* gdb.cp/virtfunc.exp (test_virtual_calls): Add a KFAIL for
	print pEe->D::vg().
@
text
@d3 2
a4 2
   Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994,
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
@


1.84
log
@gdb/ChangeLog:
2006-01-17  Jim Blandy  <jimb@@redhat.com>

	* symtab.h (struct general_symbol_info): Use gdb_byte for
	value.bytes.
	* stabsread.c (define_symbol): Use gdb_byte for the buffer holding
	a floating-point constant's value.
	* dwarf2read.c (dwarf2_const_value): Remove casts of value buffer
	to char *.
	* findvar.c (read_var_value): Eliminate needless temporary.
@
text
@d4 1
a4 1
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
d1734 1
a1734 1
	  smash_to_member_type (type, domain, memtype);
@


1.83
log
@	* macroexp.c (expand): Initialize argc.
	* stabsread.c (read_type): Handle errors from read_args.
	(read_args): Return NULL for errors.
@
text
@d725 1
a725 1
	    char *dbl_valu;
d740 1
a740 1
	    dbl_valu = (char *)
@


1.82
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d1807 2
d3990 2
a3991 2
   and terminated with END.  Return the list of types read in, or (struct type
   **)-1 if there is an error.  */
d4006 1
a4006 1
	return (struct field *) -1;
@


1.81
log
@* bsd-kvm.c (bsd_kvm_open): Properly cast sentinel in concat call.
* coffread.c (patch_type, process_coff_symbol): Likewise.
* corelow.c (core_open): Likewise.
* dwarf2read.c (dwarf_decode_lines, dwarf2_start_subfile):
* language.c (set_lang_str, set_type_str, set_range_str)
(set_case_str): Likewise.
* source.c (add_path, openp): Likewise.
* stabsread.c: Likewise.
* top.c (init_history): Likewise.
* utils.c (xfullpath): Likewise.
* value.c (lookup_internalvar): Likewise.
* cli/cli-cmds.c (cd_command): Likewise.
* cli/cli-dump.c (add_dump_command): Likewise.
@
text
@d3 1
a3 1
   Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994,
d21 2
a22 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.80
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up error_no_arg, query, perror_with_name, complaint, and
	internal_error.
	* breakpoint.c, cp-abi.c, cp-namespace.c, cp-support.c: Update.
	* cris-tdep.c, dbxread.c, dictionary.c, dsrec.c: Update.
	* dummy-frame.c, dve3900-rom.c, dwarf2-frame.c, dwarf2expr.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, event-loop.c: Update.
	* exceptions.c, exec.c, f-lang.c, findvar.c, fork-child.c: Update.
	* frame-unwind.c, frame.c, frv-linux-tdep.c, frv-tdep.c: Update.
	* gdb_assert.h, gdbarch.c, gdbtypes.c, gnu-nat.c: Update.
	* go32-nat.c, hppa-tdep.c, hppabsd-nat.c, hpread.c: Update.
	* i386-linux-nat.c, i386-nat.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386fbsd-nat.c, inf-ptrace.c, inf-ttrace.c, infcall.c: Update.
	* infcmd.c, inflow.c, infptrace.c, infrun.c, inftarg.c: Update.
	* interps.c, language.c, linespec.c, linux-nat.c: Update.
	* m32r-linux-nat.c, m68k-tdep.c, m68kbsd-nat.c: Update.
	* m68klinux-nat.c, m88kbsd-nat.c, macroexp.c, macroscope.c: Update.
	* macrotab.c, maint.c, mdebugread.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mips64obsd-nat.c: Update.
	* mipsnbsd-nat.c, mn10300-tdep.c, monitor.c, nto-procfs.c: Update.
	* objc-lang.c, objfiles.c, objfiles.h, ocd.c, osabi.c: Update.
	* parse.c, ppc-bdm.c, ppc-linux-nat.c, ppc-sysv-tdep.c: Update.
	* ppcnbsd-nat.c, ppcobsd-nat.c, printcmd.c, procfs.c: Update.
	* regcache.c, reggroups.c, remote-e7000.c, remote-mips.c: Update.
	* remote-rdp.c, remote-sds.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote.c, rs6000-nat.c, rs6000-tdep.c: Update.
	* s390-nat.c, s390-tdep.c, sentinel-frame.c, serial.c: Update.
	* sh-tdep.c, sh3-rom.c, sh64-tdep.c, shnbsd-nat.c: Update.
	* solib-aix5.c, solib-svr4.c, solib.c, source.c: Update.
	* sparc-nat.c, stabsread.c, stack.c, symfile.c, symtab.c: Update.
	* symtab.h, target.c, tracepoint.c, ui-file.c, ui-out.c: Update.
	* utils.c, valops.c, valprint.c, vax-nat.c, vaxbsd-nat.c: Update.
	* win32-nat.c, xcoffread.c, xstormy16-tdep.c: Update.
	* cli/cli-cmds.c, cli/cli-logging.c, cli/cli-script.c: Update.
	* cli/cli-setshow.c, mi/mi-cmd-break.c, mi/mi-cmds.c: Update.
	* mi/mi-console.c, mi/mi-getopt.c, mi/mi-out.c: Update.
	* tui/tui-file.c, tui/tui-interp.c: Update.
@
text
@d4 2
a5 2
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free
   Software Foundation, Inc.
d2530 2
a2531 1
	      new_fnlist->fn_fieldlist.name = concat ("~", main_fn_name, NULL);
@


1.79
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d177 1
a177 1
  complaint (&symfile_complaints, "invalid C++ abbreviation `%s'", arg1);
d184 1
a184 1
	     "register number %d too large (max %d) in symbol %s",
d232 1
a232 1
		 "Invalid symbol data: type number (%d,%d) out of range at symtab pos %d.",
d672 1
a672 1
	  complaint (&symfile_complaints, "Unknown C++ symbol name `%s'",
d1348 1
a1348 1
  complaint (&symfile_complaints, "couldn't parse type; debugger out of date?");
d1469 1
a1469 1
			   "Unrecognized cross-reference type `%c'", (*pp)[0]);
d1675 1
a1675 1
		       "Prototyped function type didn't end arguments with `#':\n%s",
d1786 1
a1786 1
		       "invalid (minimal) member type data format at symtab pos %d.",
d1914 1
a1914 1
      complaint (&symfile_complaints, "Unknown builtin type %d", typenum);
d2079 1
a2079 1
		 "Method has bad physname %s\n", physname);
d2277 1
a2277 1
			 "const/volatile indicator missing, got '%c'", **pp);
d2360 1
a2360 1
			 "member function type missing, got '%c'", (*pp)[-1]);
d2626 1
a2626 1
			 "C++ abbreviated type name unknown at symtab pos %d",
d2754 1
a2754 1
         union { int num; char str[0]; } foo.  Printing "<no value>" for
d2979 1
a2979 1
		       "Unknown virtual character `%c' for baseclass", **pp);
d2996 1
a2996 1
		       "Unknown visibility `%c' for baseclass",
d3104 1
a3104 1
			 "virtual function table pointer not found when defining class `%s'",
d3214 1
a3214 1
	    complaint (&symfile_complaints, "Unknown visibility `%c' for field",
d3256 1
a3256 1
	     "struct/union type gets multiply defined: %s%s", kind, name);
d3974 1
a3974 1
		 "base type %d of range type is not defined", rangenums[1]);
d4051 1
a4051 1
		 "Invalid symbol data: common block within common block");
d4077 1
a4077 1
      complaint (&symfile_complaints, "ECOMM symbol unmatched by BCOMM");
d4190 1
a4190 1
		    complaint (&symfile_complaints, "need a type name");
d4214 2
a4215 2
		       "forward-referenced types left unresolved, "
                       "type code %d.",
d4357 1
a4357 1
		       "%s: common block `%s' from global_sym_chain unresolved",
@


1.78
log
@	* stabsread.c (read_huge_number): Add support for reading octal
	signed number in twos complement, based on the size of this
	number.
	(read_range_type): Add support for reading octal signed bounds
	in twos complements, based on the size of the type.
	(read_type_number, read_cpp_abbrev, read_member_functions,
	read_cpp_abbrev, read_one_struct_field, read_baseclasses,
	read_struct_type, read_array_type, read_enum_type,
	read_sun_builtin_type, read_sun_floating_type): Update calls to
	read_huge_number.
	(read_type): Update call to read_range_type.
@
text
@d284 1
a284 1
	  warning ("GDB internal error: bad real_filenum");
d1889 1
a1889 1
      warning ("GDB internal error, type is NULL in stabsread.c\n");
d4436 1
a4436 1
	  error ("invalid symbol name \"%s\"", name);
d4441 1
a4441 1
	  error ("invalid symbol name \"%s\"", name);
@


1.77
log
@2004-04-30  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (BELIEVE_PCC_PROMOTION_TYPE): Delete.
	* gdbarch.h, gdbarch.c: Re-generate.
	* stabsread.c (define_symbol): Delete BELIEVE_PCC_PROMOTION_TYPE
	code.
@
text
@d95 1
a95 1
static long read_huge_number (char **, int, int *);
d109 1
a109 1
static struct type *read_range_type (char **, int[2], struct objfile *);
d438 1
a438 1
      typenums[0] = read_huge_number (pp, ',', &nbits);
d441 1
a441 1
      typenums[1] = read_huge_number (pp, ')', &nbits);
d448 1
a448 1
      typenums[1] = read_huge_number (pp, 0, &nbits);
d1814 1
a1814 1
      type = read_range_type (pp, typenums, objfile);
d2294 1
a2294 1
		  (0x7fffffff & read_huge_number (pp, ';', &nbits)) + 2;
d2659 2
a2660 1
	FIELD_BITPOS (fip->list->field) = read_huge_number (pp, ';', &nbits);
d2733 1
a2733 1
    FIELD_BITPOS (fip->list->field) = read_huge_number (pp, ',', &nbits);
d2739 1
a2739 1
    FIELD_BITSIZE (fip->list->field) = read_huge_number (pp, ';', &nbits);
d2935 1
a2935 1
    TYPE_N_BASECLASSES (type) = read_huge_number (pp, ',', &nbits);
d3009 1
a3009 1
	FIELD_BITPOS (new->field) = read_huge_number (pp, ',', &nbits);
d3314 1
a3314 1
    TYPE_LENGTH (type) = read_huge_number (pp, 0, &nbits);
d3372 1
a3372 1
  lower = read_huge_number (pp, ';', &nbits);
d3382 1
a3382 1
  upper = read_huge_number (pp, ';', &nbits);
d3456 1
a3456 1
      n = read_huge_number (pp, ',', &nbits);
d3568 1
a3568 1
  read_huge_number (pp, ';', &nbits);
d3573 1
a3573 1
  read_huge_number (pp, ';', &nbits);
d3578 1
a3578 1
  type_bits = read_huge_number (pp, 0, &nbits);
d3611 1
a3611 1
  details = read_huge_number (pp, ';', &nbits);
d3616 1
a3616 1
  nbytes = read_huge_number (pp, ';', &nbits);
d3639 5
d3650 1
a3650 1
read_huge_number (char **pp, int end, int *bits)
d3654 1
d3656 1
d3662 1
d3683 28
a3710 4
	{
	  n *= radix;
	  n += c - '0';		/* FIXME this overflows anyway */
	}
d3712 1
a3712 1
	overflow = 1;
d3769 4
a3772 1
      return n * sign;
d3779 2
a3780 1
read_range_type (char **pp, int typenums[2], struct objfile *objfile)
d3809 2
a3810 2
  n2 = read_huge_number (pp, ';', &n2bits);
  n3 = read_huge_number (pp, ';', &n3bits);
d3826 11
d3838 1
a3838 1
      if ((n2bits == 0 && n2 == 0) && n3bits != 0)
@


1.76
log
@* stabsread.c (reg_value_complaint): The maximum register number
is one less than the number of registers.
@
text
@d981 4
a984 1
	  if (BELIEVE_PCC_PROMOTION_TYPE)
d986 4
a989 52
	      /* This is defined on machines (e.g. sparc) where we
	         should believe the type of a PCC 'short' argument,
	         but shouldn't believe the address (the address is the
	         address of the corresponding int).

	         My guess is that this correction, as opposed to
	         changing the parameter to an 'int' (as done below,
	         for PCC on most machines), is the right thing to do
	         on all machines, but I don't want to risk breaking
	         something that already works.  On most PCC machines,
	         the sparc problem doesn't come up because the calling
	         function has to zero the top bytes (not knowing
	         whether the called function wants an int or a short),
	         so there is little practical difference between an
	         int and a short (except perhaps what happens when the
	         GDB user types "print short_arg = 0x10000;").

	         Hacked for SunOS 4.1 by gnu@@cygnus.com.  In 4.1, the
	         compiler actually produces the correct address (we
	         don't need to fix it up).  I made this code adapt so
	         that it will offset the symbol if it was pointing at
	         an int-aligned location and not otherwise.  This way
	         you can use the same gdb for 4.0.x and 4.1 systems.

	         If the parameter is shorter than an int, and is
	         integral (e.g. char, short, or unsigned equivalent),
	         and is claimed to be passed on an integer boundary,
	         don't believe it!  Offset the parameter's address to
	         the tail-end of that integer.  */

	      if (TYPE_LENGTH (SYMBOL_TYPE (sym)) < TYPE_LENGTH (pcc_promotion_type)
		  && TYPE_CODE (SYMBOL_TYPE (sym)) == TYPE_CODE_INT
	      && 0 == SYMBOL_VALUE (sym) % TYPE_LENGTH (pcc_promotion_type))
		{
		  SYMBOL_VALUE (sym) += TYPE_LENGTH (pcc_promotion_type)
		    - TYPE_LENGTH (SYMBOL_TYPE (sym));
		}
	      break;
	    }
	  else
	    {
	      /* If PCC says a parameter is a short or a char,
	         it is really an int.  */
	      if (TYPE_LENGTH (SYMBOL_TYPE (sym)) < TYPE_LENGTH (pcc_promotion_type)
		  && TYPE_CODE (SYMBOL_TYPE (sym)) == TYPE_CODE_INT)
		{
		  SYMBOL_TYPE (sym) =
		    TYPE_UNSIGNED (SYMBOL_TYPE (sym))
		    ? pcc_unsigned_promotion_type
		    : pcc_promotion_type;
		}
	      break;
d991 1
@


1.75
log
@* stabsread.c (read_type): If we find any type numbers that are
forward references, complain if the references aren't resolved by
the time we're finished reading.
(cleanup_undefined_types): Make error message more appropriate for
a complaint.
@
text
@d181 1
a181 1
reg_value_complaint (int arg1, int arg2, const char *arg3)
d184 2
a185 2
	     "register number %d too large (max %d) in symbol %s", arg1, arg2,
	     arg3);
@


1.75.2.1
log
@Merge mainline to intercu branch.
@
text
@d181 1
a181 1
reg_value_complaint (int regnum, int num_regs, const char *sym)
d184 2
a185 2
	     "register number %d too large (max %d) in symbol %s",
             regnum, num_regs - 1, sym);
@


1.75.2.2
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d981 54
a1034 9
	  /* If PCC says a parameter is a short or a char, it is
	     really an int.  */
	  if (TYPE_LENGTH (SYMBOL_TYPE (sym)) < TYPE_LENGTH (pcc_promotion_type)
	      && TYPE_CODE (SYMBOL_TYPE (sym)) == TYPE_CODE_INT)
	    {
	      SYMBOL_TYPE (sym) =
		TYPE_UNSIGNED (SYMBOL_TYPE (sym))
		? pcc_unsigned_promotion_type
		: pcc_promotion_type;
a1035 1
	  break;
@


1.74
log
@2004-02-07  Elena Zannoni  <ezannoni@@redhat.com>

	* buildsym.c (free_pending_blocks, finish_block)
	(record_pending_block, make_blockvector, end_symtab): Replace
	symbol_obstack with objfile_obstack.
	* coffread.c (process_coff_symbol, coff_read_struct_type)
	(coff_read_enum_type): Ditto.
	* cp-namespace.c (initialize_namespace_symtab)
	(check_one_possible_namespace_symbol): Ditto.
	* dwarf2read.c (new_symbol, dwarf2_const_value, macro_start_file)
	(dwarf2_symbol_mark_computed): Ditto.
	* dwarfread.c (enum_type, new_symbol, synthesize_typedef): Ditto.
	* elfread.c (elf_symtab_read): Ditto.
	* hpread.c (hpread_symfile_init, hpread_symfile_init)
	(hpread_read_enum_type, hpread_read_function_type)
	(hpread_read_doc_function_type, hpread_process_one_debug_symbol):
	Ditto.
	* jv-lang.c (get_java_class_symtab, add_class_symbol)
	(java_link_class_type): Ditto.
	* mdebugread.c (parse_symbol, psymtab_to_symtab_1, new_symtab)
	(new_symbol): Ditto.
	* minsyms.c (install_minimal_symbols): Ditto.
	* objfiles.c (allocate_objfile): Remove init of symbol_obstack.
	(terminate_minimal_symbol_table): Replace symbol_obstack with
	objfile_obstack.
	(free_objfile): Remove freeing of symbol_obstack.
	* objfiles.h: Remove symbol_obstack field.
	* pa64solib.c (add_to_solist): Replace symbol_obstack with
	objfile_obstack.
	* solib-sunos.c (allocate_rt_common_objfile): Remove init of
	symbol_obstack.
	(solib_add_common_symbols): Replace symbol_obstack with
	objfile_obstack.
	* somsolib.c (som_solib_add): Ditto.
	* stabsread.c (patch_block_stabs, define_symbol, read_enum_type)
	(common_block_start, common_block_end): Ditto.
	* symfile.c (reread_symbols): Remove freeing and init of
	symbol_obstack.
	(allocate_symtab): Rename symbol_obstack to objfile_obstack.
	* symfile.h: Update comment.
	* symmisc.c (print_objfile_statistics): Remove symbol_obstack
	stats printing.
	* symtab.c (symbol_set_names): Replace symbol_obstack with
	objfile_obstack.
	* symtab.h (struct general_symbol_info, struct minimal_symbol):
	Update comments.
	* xcoffread.c (read_xcoff_symtab, SYMBOL_DUP, SYMNAME_ALLOC)
	(init_stringtab, xcoff_initial_scan): Replace symbol_obstack with
	objfile_obstack.
@
text
@a1448 3
      /* Type is not being defined here.  Either it already exists,
         or this is a forward reference to it.  dbx_alloc_type handles
         both cases.  */
d1450 14
a1463 1
	return dbx_alloc_type (typenums, objfile);
d4210 2
a4211 1
		       "GDB internal error.  cleanup_undefined_types with bad type %d.",
@


1.73
log
@2004-02-07  Elena Zannoni  <ezannoni@@redhat.com>

        * objfiles.h (struct objfile): Add objfile_obstack field.
        Remove type_obstack field.

        * dwarf2read.c (dwarf2_add_field,dwarf2_add_member_fn,
        read_structure_scope read_enumeration, new_symbol): Replace
        type_obstack with objfile_obstack.
        * dwarfread.c (struct_type, enum_type): Ditto.
        * gdbtypes.c (alloc_type, alloc_type_instance, init_type)
        (lookup_fundamental_type): Ditto.
        * gdbtypes.h (TYPE_ALLOC): Ditto.
        * hpread.c (hpread_read_enum_type, hpread_read_function_type)
        (hpread_read_doc_function_type, hpread_read_struct_type)
        (fix_static_member_physnames, hpread_read_array_type)
        (hpread_read_subrange_type, hpread_type_lookup): Ditto.
        * jv-lang.c (java_lookup_class, type_from_class, type_from_class)
        (java_link_class_type): Ditto.
        * mdebugread.c (parse_type): Ditto.
        * objfiles.c (allocate_objfile, free_objfile): Ditto.
        * solib-sunos.c (solib_add_common_symbols): Ditto.
        * stabsread.c (define_symbol, read_type, read_member_functions,
        read_cpp_abbrev, read_one_struct_field): Ditto.
        * symfile.c (reread_symbols): Ditto.
        * symmisc.c (print_objfile_statistics): Ditto.
@
text
@d382 1
a382 1
		obstack_alloc (&objfile->symbol_obstack,
d389 1
a389 1
		obsavestring (name, pp - name, &objfile->symbol_obstack);
d615 1
a615 1
    obstack_alloc (&objfile->symbol_obstack, sizeof (struct symbol));
d649 1
a649 1
					    &objfile->symbol_obstack);
d658 1
a658 1
					    &objfile->symbol_obstack);
d741 1
a741 1
	      obstack_alloc (&objfile->symbol_obstack,
d1261 1
a1261 1
	  obstack_alloc (&objfile->symbol_obstack, sizeof (struct symbol));
d3487 1
a3487 1
      name = obsavestring (*pp, p - *pp, &objfile->symbol_obstack);
d3494 1
a3494 1
	obstack_alloc (&objfile->symbol_obstack, sizeof (struct symbol));
d4042 1
a4042 1
				    &objfile->symbol_obstack);
d4068 1
a4068 1
    obstack_alloc (&objfile->symbol_obstack, sizeof (struct symbol));
d4070 1
a4070 1
  /* Note: common_block_name already saved on symbol_obstack */
@


1.72
log
@2004-01-18  Andrew Cagney  <cagney@@redhat.com>

	* remote-sds.c (tohex): Delete unused function.  Update copyright.
	* xstormy16-tdep.c (xstormy16_register_virtual_size): Ditto.
	* v850-tdep.c (v850_register_virtual_size): Ditto.
	* target.c (normal_target_post_startup_inferior): Ditto.
	* source.c (ambiguous_line_spec): Ditto.
	* remote.c (adapt_remote_get_threadinfo): Ditto.
	* mi/mi-out.c (out_field_fmt): Ditto.
	* mi/mi-interp.c (mi_interp_read_one_line_hook): Ditto.
	(output_control_change_notification): Ditto.
	* m68k-tdep.c (m68k_register_byte): Ditto.
	(m68k_remote_breakpoint_from_pc): Ditto.
	* ui-out.c (init_ui_out_state): Delete unused declaration.
	* stabsread.c (search_value): Ditto.
	* mi/mi-cmd-env.c (env_cli_command): Ditto.
	* maint.c (print_section_table): Ditto.
	* infrun.c (set_follow_fork_mode_command): Ditto.
@
text
@d1254 1
a1254 1
	  = obconcat (&objfile->type_obstack, "", "", DEPRECATED_SYMBOL_NAME (sym));
d1268 1
a1268 1
	      = obconcat (&objfile->type_obstack, "", "", DEPRECATED_SYMBOL_NAME (sym));
d1530 1
a1530 1
	    (char *) obstack_alloc (&objfile->type_obstack, p - *pp + 1);
d1557 1
a1557 1
		  obstack_free (&objfile->type_obstack, type_name);
d2514 1
a2514 1
		= obconcat (&objfile->type_obstack, "", "~",
d2518 1
a2518 1
		obstack_alloc (&objfile->type_obstack,
d2579 1
a2579 1
				  &objfile->type_obstack);
d2583 1
a2583 1
	    obstack_alloc (&objfile->type_obstack,
d2652 1
a2652 1
	    obconcat (&objfile->type_obstack, vptr_name, name, "");
d2665 1
a2665 1
	    obconcat (&objfile->type_obstack, vb_name, name, "");
d2671 1
a2671 1
	    obconcat (&objfile->type_obstack,
d2717 1
a2717 1
    obsavestring (*pp, p - *pp, &objfile->type_obstack);
@


1.71
log
@2004-01-16  Andrew Cagney  <cagney@@redhat.com>

	* symfile.c: Update copyright year.
	(compare_symbols): Delete unused function.
	* stabsread.c: Update copyright year.
	(lrs_general_complaint): Delete unused function.
	(ref_search_value): Ditto.
	(get_substring): Delete declaration.
	* sh64-tdep.c: Update copyright year.
	(sh64_get_gdb_regnum): Delete unused function.
	* dwarf2read.c (dwarf2_unsupported_at_frame_base_complaint):
	Delete unused function.
@
text
@a159 2
static CORE_ADDR ref_search_value (int refnum);

@


1.70
log
@2004-01-05  Andrew Cagney  <cagney@@redhat.com>

	* libunwind-frame.h (struct frame_id): Add opaque declaration,
	move to start of file.
	* i386-tdep.h (struct regcache): Add opaque declaration.
	* config/ia64/nm-linux.h (struct target_ops): Add opaque
	declaration.
	* ia64-tdep.c (ia64_find_proc_info_x): Do not use __FUNCTION__.
	(ia64_gdbarch_init): Use "GNU/Linux" in comment.
	* win32-nat.c (fake_create_process): Use ISO C style definition.
	* stabsread.c (define_symbol): Delete #ifndef
	DEPRECATED_USE_REGISTER_NOT_ARG wrapper around
	stabs_argument_has_addr call, macro never defined.
@
text
@d2 4
a5 3
   Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.
a92 2
static char *get_substring (char **, int);

a195 6
static void
lrs_general_complaint (const char *arg1)
{
  complaint (&symfile_complaints, "%s", arg1);
}

a526 10
}

/* Return value for the reference REFNUM.  */

static CORE_ADDR
ref_search_value (int refnum)
{
  if (refnum < 0 || refnum > ref_count)
    return 0;
  return ref_map[refnum].value;
@


1.69
log
@        * stabsread.c (read_type): Save a reference to types that are defined
        as cross references to other types.
@
text
@a1120 3
#ifndef DEPRECATED_USE_REGISTER_NOT_ARG
	      /* DEPRECATED_USE_REGISTER_NOT_ARG is only defined by
                 the SPARC.  */
d1122 1
a1122 3
						  SYMBOL_TYPE (sym))
#endif
	    )
@


1.68
log
@2003-11-15  Andrew Cagney  <cagney@@redhat.com>

	* config/sparc/tm-sparc.h (DEPRECATE_USE_REGISTER_NOT_ARG): Rename
	USE_REGISTER_NOT_ARG.
	* stabsread.c (define_symbol): Update.
@
text
@d1567 3
a1569 5
	/* Now check to see whether the type has already been
	   declared.  This was written for arrays of cross-referenced
	   types before we had TYPE_CODE_TARGET_STUBBED, so I'm pretty
	   sure it is not necessary anymore.  But it might be a good
	   idea, to save a little memory.  */
d1583 2
@


1.67
log
@2003-11-07  Andrew Cagney  <cagney@@redhat.com>

	* top.c (print_gdb_version): Replace STREQ with strcmp.
	* valops.c (value_struct_elt_for_reference): Ditto.
	(value_struct_elt_for_reference): Ditto.
	* symtab.c (gdb_mangle_name): Ditto.
	(find_line_symtab): Ditto.
	* symmisc.c (maintenance_print_symbols): Ditto.
	* symfile.c (symbol_file_command): Ditto.
	* stabsread.c (define_symbol, read_type): Ditto.
	(cleanup_undefined_types, scan_file_globals): Ditto.
	* solib.c (solib_map_sections): Ditto.
	* solib-svr4.c (bfd_lookup_symbol): Ditto.
	* rs6000-tdep.c (skip_prologue): Ditto.
	* p-valprint.c (pascal_value_print): Ditto.
	(pascal_object_is_vtbl_ptr_type): Ditto.
	* objfiles.c (in_plt_section): Ditto.
	* minsyms.c (lookup_minimal_symbol): Ditto.
	(compact_minimal_symbols): Ditto.
	(find_solib_trampoline_target): Ditto.
	* mdebugread.c (parse_type): Ditto.
	* language.c (set_language_command): Ditto.
	(set_type_command, set_range_command): Ditto.
	* f-lang.c (add_common_block): Ditto.
	(add_common_block): Ditto.
	(find_first_common_named): Ditto.
	(patch_all_commons_by_name): Ditto.
	* elfread.c (elf_locate_sections): Ditto.
	(elf_locate_sections): Ditto.
	(elfstab_offset_sections): Ditto.
	* dwarf2read.c (dwarf2_locate_sections): Ditto.
	* dbxread.c (add_old_header_file): Ditto.
	(find_corresponding_bincl_psymtab): Ditto.
	(read_dbx_symtab, process_one_symbol): Ditto.
	* coffread.c (patch_opaque_types): Ditto.
	* cli/cli-decode.c (delete_cmd): Ditto.
	* cli/cli-cmds.c (pwd_command, list_command): Ditto.
	* c-typeprint.c (c_type_print_base): Ditto.
	* breakpoint.c (bpstat_stop_status): Ditto.
	(clear_command, breakpoint_re_set_one): Ditto.
@
text
@d1121 3
a1123 1
#ifndef USE_REGISTER_NOT_ARG
@


1.66
log
@2003-11-04  Andrew Cagney  <cagney@@redhat.com>

	* symtab.c (find_active_alias): Delete function.
	(lookup_block_symbol): Delete alias code.
	* stabsread.c (resolve_live_range): Delete function.
	(add_live_range): Delete function.
	(resolve_symbol_reference): Delete function.
	(define_symbol): Delete live range and alias code.
	(scan_file_globals): Delete alias code.
	* symtab.h (SYMBOL_RANGES): Delete macro.
	(struct range_list): Delete structure.
	(struct symbol): Delete field "ranges".
	(SYMBOL_ALIASES): Delete macro.
	(struct alias_list): Delete structure.
	(struct symbol): Delete field "aliases".
@
text
@d1131 2
a1132 1
		  && STREQ (DEPRECATED_SYMBOL_NAME (prev_sym), DEPRECATED_SYMBOL_NAME (sym)))
d1579 1
a1579 1
		  && STREQ (DEPRECATED_SYMBOL_NAME (sym), type_name))
d4211 1
a4211 1
			    && STREQ (DEPRECATED_SYMBOL_NAME (sym), typename))
d4293 1
a4293 1
		  STREQ (DEPRECATED_SYMBOL_NAME (msymbol) + 1, DEPRECATED_SYMBOL_NAME (sym) + 1))
@


1.65
log
@2003-10-06  Andrew Cagney  <cagney@@redhat.com>

	* breakpoint.c, breakpoint.h: Remove obsolete code and comments.
	* buildsym.c, dbxread.c, gdbtypes.c, mdebugread.c: Ditto.
	* monitor.c, sparc-tdep.c, stabsread.c: Ditto.
	* stabsread.h, xcoffread.c: Ditto.
@
text
@a158 5
static void add_live_range (struct objfile *, struct symbol *, CORE_ADDR,
			    CORE_ADDR);

static int resolve_live_range (struct objfile *, struct symbol *, char *);

a162 3
static int resolve_symbol_reference (struct objfile *, struct symbol *,
				     char *);

a469 103
/* This routine fixes up symbol references/aliases to point to the original
   symbol definition.  Returns 0 on failure, non-zero on success.  */

static int
resolve_symbol_reference (struct objfile *objfile, struct symbol *sym, char *p)
{
  int refnum;
  struct symbol *ref_sym = 0;
  struct alias_list *alias;

  /* If this is not a symbol reference return now.  */
  if (*p != '#')
    return 0;

  /* Use "#<num>" as the name; we'll fix the name later.
     We stored the original symbol name as "#<id>=<name>"
     so we can now search for "#<id>" to resolving the reference.
     We'll fix the names later by removing the "#<id>" or "#<id>=" */

/*---------------------------------------------------------*/
  /* Get the reference id number, and 
     advance p past the names so we can parse the rest. 
     eg: id=2 for p : "2=", "2=z:r(0,1)" "2:r(0,1);l(#5,#6),l(#7,#4)" */
/*---------------------------------------------------------*/

  /* This gets reference name from string.  sym may not have a name. */

  /* Get the reference number associated with the reference id in the
     gdb stab string.  From that reference number, get the main/primary
     symbol for this alias.  */
  refnum = process_reference (&p);
  ref_sym = ref_search (refnum);
  if (!ref_sym)
    {
      lrs_general_complaint ("symbol for reference not found");
      return 0;
    }

  /* Parse the stab of the referencing symbol
     now that we have the referenced symbol.
     Add it as a new symbol and a link back to the referenced symbol.
     eg: p : "=", "=z:r(0,1)" ":r(0,1);l(#5,#6),l(#7,#4)" */


  /* If the stab symbol table and string contain:
     RSYM   0      5      00000000 868    #15=z:r(0,1)
     LBRAC  0      0      00000000 899    #5=
     SLINE  0      16     00000003 923    #6=
     Then the same symbols can be later referenced by:
     RSYM   0      5      00000000 927    #15:r(0,1);l(#5,#6)
     This is used in live range splitting to:
     1) specify that a symbol (#15) is actually just a new storage 
     class for a symbol (#15=z) which was previously defined.
     2) specify that the beginning and ending ranges for a symbol 
     (#15) are the values of the beginning (#5) and ending (#6) 
     symbols. */

  /* Read number as reference id.
     eg: p : "=", "=z:r(0,1)" ":r(0,1);l(#5,#6),l(#7,#4)" */
  /* FIXME! Might I want to use SYMBOL_CLASS (sym) = LOC_OPTIMIZED_OUT;
     in case of "l(0,0)"? */

/*--------------------------------------------------*/
  /* Add this symbol to the reference list.           */
/*--------------------------------------------------*/

  alias = (struct alias_list *) obstack_alloc (&objfile->type_obstack,
					       sizeof (struct alias_list));
  if (!alias)
    {
      lrs_general_complaint ("Unable to allocate alias list memory");
      return 0;
    }

  alias->next = 0;
  alias->sym = sym;

  if (!SYMBOL_ALIASES (ref_sym))
    {
      SYMBOL_ALIASES (ref_sym) = alias;
    }
  else
    {
      struct alias_list *temp;

      /* Get to the end of the list.  */
      for (temp = SYMBOL_ALIASES (ref_sym);
	   temp->next;
	   temp = temp->next)
	;
      temp->next = alias;
    }

  /* Want to fix up name so that other functions (eg. valops)
     will correctly print the name.
     Don't add_symbol_to_list so that lookup_symbol won't find it.
     nope... needed for fixups. */
  DEPRECATED_SYMBOL_NAME (sym) = DEPRECATED_SYMBOL_NAME (ref_sym);

  /* Done!  */
  return 1;
}

a695 35
  else if (string[0] == '#')
    {
      /* Special GNU C extension for referencing symbols.  */
      char *s;
      int refnum, nlen;

      /* If STRING defines a new reference id, then add it to the
         reference map.  Else it must be referring to a previously
         defined symbol, so add it to the alias list of the previously
         defined symbol.  */
      s = string;
      refnum = symbol_reference_defined (&s);
      if (refnum >= 0)
	ref_add (refnum, sym, string, SYMBOL_VALUE (sym));
      else if (!resolve_symbol_reference (objfile, sym, string))
	return NULL;

      /* S..P contains the name of the symbol.  We need to store
         the correct name into DEPRECATED_SYMBOL_NAME.  */
      nlen = p - s;
      if (refnum >= 0)
	{
	  if (nlen > 0)
	    SYMBOL_SET_NAMES (sym, s, nlen, objfile);
	  else
	    /* FIXME! Want DEPRECATED_SYMBOL_NAME (sym) = 0;
	       Get error if leave name 0.  So give it something. */
	    {
	      nlen = p - string;
	      SYMBOL_SET_NAMES (sym, string, nlen, objfile);
	    }
	}
      /* Advance STRING beyond the reference id.  */
      string = s;
    }
a1377 23
  /* Is there more to parse?  For example LRS/alias information?  */
  while (*p && *p == ';')
    {
      p++;
      if (*p && p[0] == 'l' && p[1] == '(')
	{
	  /* GNU extensions for live range splitting may be appended to 
	     the end of the stab string.  eg. "l(#1,#2);l(#3,#5)" */

	  /* Resolve the live range and add it to SYM's live range list.  */
	  if (!resolve_live_range (objfile, sym, p))
	    return NULL;

	  /* Find end of live range info. */
	  p = strchr (p, ')');
	  if (!*p || *p != ')')
	    {
	      lrs_general_complaint ("live range format not recognized");
	      return NULL;
	    }
	  p++;
	}
    }
a1380 104
/* Add the live range found in P to the symbol SYM in objfile OBJFILE.  Returns
   non-zero on success, zero otherwise.  */

static int
resolve_live_range (struct objfile *objfile, struct symbol *sym, char *p)
{
  int refnum;
  CORE_ADDR start, end;

  /* Sanity check the beginning of the stabs string.  */
  if (!*p || *p != 'l')
    {
      lrs_general_complaint ("live range string 1");
      return 0;
    }
  p++;

  if (!*p || *p != '(')
    {
      lrs_general_complaint ("live range string 2");
      return 0;
    }
  p++;

  /* Get starting value of range and advance P past the reference id.

     ?!? In theory, the process_reference should never fail, but we should
     catch that case just in case the compiler scrogged the stabs.  */
  refnum = process_reference (&p);
  start = ref_search_value (refnum);
  if (!start)
    {
      lrs_general_complaint ("Live range symbol not found 1");
      return 0;
    }

  if (!*p || *p != ',')
    {
      lrs_general_complaint ("live range string 3");
      return 0;
    }
  p++;

  /* Get ending value of range and advance P past the reference id.

     ?!? In theory, the process_reference should never fail, but we should
     catch that case just in case the compiler scrogged the stabs.  */
  refnum = process_reference (&p);
  end = ref_search_value (refnum);
  if (!end)
    {
      lrs_general_complaint ("Live range symbol not found 2");
      return 0;
    }

  if (!*p || *p != ')')
    {
      lrs_general_complaint ("live range string 4");
      return 0;
    }

  /* Now that we know the bounds of the range, add it to the
     symbol.  */
  add_live_range (objfile, sym, start, end);

  return 1;
}

/* Add a new live range defined by START and END to the symbol SYM
   in objfile OBJFILE.  */

static void
add_live_range (struct objfile *objfile, struct symbol *sym, CORE_ADDR start,
		CORE_ADDR end)
{
  struct range_list *r, *rs;

  if (start >= end)
    {
      lrs_general_complaint ("end of live range follows start");
      return;
    }

  /* Alloc new live range structure. */
  r = (struct range_list *)
    obstack_alloc (&objfile->type_obstack,
		   sizeof (struct range_list));
  r->start = start;
  r->end = end;
  r->next = 0;

  /* Append this range to the symbol's range list. */
  if (!SYMBOL_RANGES (sym))
    SYMBOL_RANGES (sym) = r;
  else
    {
      /* Get the last range for the symbol. */
      for (rs = SYMBOL_RANGES (sym); rs->next; rs = rs->next)
	;
      rs->next = r;
    }
}


d4240 1
a4240 1
  struct symbol *sym, *prev, *rsym;
a4293 3

		  struct alias_list *aliases;

d4308 1
a4308 10

		  /* If symbol has aliases, do minimal symbol fixups for each.
		     These live aliases/references weren't added to 
		     global_sym_chain hash but may also need to be fixed up. */
		  /* FIXME: Maybe should have added aliases to the global chain,                     resolved symbol name, then treated aliases as normal 
		     symbols?  Still, we wouldn't want to add_to_list. */
		  /* Now do the same for each alias of this symbol */
		  rsym = sym;
		  aliases = SYMBOL_ALIASES (sym);
		  while (rsym)
d4310 1
a4310 1
		      if (SYMBOL_CLASS (rsym) == LOC_BLOCK)
d4312 1
a4312 1
			  fix_common_block (rsym,
d4317 1
a4317 1
			  SYMBOL_VALUE_ADDRESS (rsym)
d4320 1
a4320 8
		      SYMBOL_SECTION (rsym) = SYMBOL_SECTION (msymbol);
		      if (aliases)
			{
			  rsym = aliases->sym;
			  aliases = aliases->next;
			}
		      else
			rsym = NULL;
a4321 1

@


1.64
log
@2003-09-20  Andrew Cagney  <cagney@@redhat.com>

	* breakpoint.c: Eliminate ARGSUSED.
	* buildsym.c, cli/cli-cmds.c, cli/cli-script.c: Ditto.
	* coffread.c, corelow.c, dwarf2read.c, event-top.c: Ditto.
	* exec.c, gcore.c, hpux-thread.c, infcmd.c, inflow.c: Ditto.
	* infrun.c, inftarg.c, maint.c, ocd.c, printcmd.c: Ditto.
	* procfs.c, regcache.c, remote-rdi.c, remote-sds.c: Ditto.
	* remote.c, sol-thread.c, source.c, stabsread.c: Ditto.
	* stack.c, symfile.c, target.c, top.c, typeprint.c: Ditto.
	* utils.c, v850ice.c, valprint.c, values.c, win32-nat.c: Ditto.
	* wince.c, remote-vx.c: Ditto.
@
text
@a155 22
#if 0 /* OBSOLETE CFront */
// OBSOLETE  /* new functions added for cfront support */

// OBSOLETE  static int
// OBSOLETE  copy_cfront_struct_fields (struct field_info *, struct type *,
// OBSOLETE  			   struct objfile *);

// OBSOLETE  static char *get_cfront_method_physname (char *);

// OBSOLETE  static int
// OBSOLETE  read_cfront_baseclasses (struct field_info *, char **,
// OBSOLETE  			 struct type *, struct objfile *);

// OBSOLETE  static int
// OBSOLETE  read_cfront_static_fields (struct field_info *, char **,
// OBSOLETE  			   struct type *, struct objfile *);
// OBSOLETE  static int
// OBSOLETE  read_cfront_member_functions (struct field_info *, char **,
// OBSOLETE  			      struct type *, struct objfile *);

// OBSOLETE  /* end new functions added for cfront support */
#endif /* OBSOLETE CFront */
a477 483
#if 0 /* OBSOLETE CFront */
// OBSOLETE  #define CFRONT_VISIBILITY_PRIVATE	'2'	/* Stabs character for private field */
// OBSOLETE  #define CFRONT_VISIBILITY_PUBLIC	'1'	/* Stabs character for public field */

// OBSOLETE  /* This code added to support parsing of ARM/Cfront stabs strings */

// OBSOLETE  /* Get substring from string up to char c, advance string pointer past
// OBSOLETE     suibstring. */

// OBSOLETE  static char *
// OBSOLETE  get_substring (char **p, int c)
// OBSOLETE  {
// OBSOLETE    char *str;
// OBSOLETE    str = *p;
// OBSOLETE    *p = strchr (*p, c);
// OBSOLETE    if (*p)
// OBSOLETE      {
// OBSOLETE        **p = 0;
// OBSOLETE        (*p)++;
// OBSOLETE      }
// OBSOLETE    else
// OBSOLETE      str = 0;
// OBSOLETE    return str;
// OBSOLETE  }

// OBSOLETE  /* Physname gets strcat'd onto sname in order to recreate the mangled
// OBSOLETE     name (see funtion gdb_mangle_name in gdbtypes.c).  For cfront, make
// OBSOLETE     the physname look like that of g++ - take out the initial mangling
// OBSOLETE     eg: for sname="a" and fname="foo__1aFPFs_i" return "FPFs_i" */

// OBSOLETE  static char *
// OBSOLETE  get_cfront_method_physname (char *fname)
// OBSOLETE  {
// OBSOLETE    int len = 0;
// OBSOLETE    /* FIXME would like to make this generic for g++ too, but 
// OBSOLETE       that is already handled in read_member_funcctions */
// OBSOLETE    char *p = fname;

// OBSOLETE    /* search ahead to find the start of the mangled suffix */
// OBSOLETE    if (*p == '_' && *(p + 1) == '_')	/* compiler generated; probably a ctor/dtor */
// OBSOLETE      p += 2;
// OBSOLETE    while (p && (unsigned) ((p + 1) - fname) < strlen (fname) && *(p + 1) != '_')
// OBSOLETE      p = strchr (p, '_');
// OBSOLETE    if (!(p && *p == '_' && *(p + 1) == '_'))
// OBSOLETE      error ("Invalid mangled function name %s", fname);
// OBSOLETE    p += 2;			/* advance past '__' */

// OBSOLETE    /* struct name length and name of type should come next; advance past it */
// OBSOLETE    while (isdigit (*p))
// OBSOLETE      {
// OBSOLETE        len = len * 10 + (*p - '0');
// OBSOLETE        p++;
// OBSOLETE      }
// OBSOLETE    p += len;

// OBSOLETE    return p;
// OBSOLETE  }

// OBSOLETE  static void
// OBSOLETE  msg_unknown_complaint (const char *arg1)
// OBSOLETE  {
// OBSOLETE    complaint (&symfile_complaints, "Unsupported token in stabs string %s", arg1);
// OBSOLETE  }

// OBSOLETE  /* Read base classes within cfront class definition.
// OBSOLETE     eg: A:ZcA;1@@Bpub v2@@Bvirpri;__ct__1AFv func__1AFv *sfunc__1AFv ;as__1A ;;
// OBSOLETE     ^^^^^^^^^^^^^^^^^^

// OBSOLETE     A:ZcA;;foopri__1AFv foopro__1AFv __ct__1AFv __ct__1AFRC1A foopub__1AFv ;;;
// OBSOLETE     ^
// OBSOLETE   */

// OBSOLETE  static int
// OBSOLETE  read_cfront_baseclasses (struct field_info *fip, char **pp, struct type *type,
// OBSOLETE  			 struct objfile *objfile)
// OBSOLETE  {
// OBSOLETE    int bnum = 0;
// OBSOLETE    char *p;
// OBSOLETE    int i;
// OBSOLETE    struct nextfield *new;

// OBSOLETE    if (**pp == ';')		/* no base classes; return */
// OBSOLETE      {
// OBSOLETE        ++(*pp);
// OBSOLETE        return 1;
// OBSOLETE      }

// OBSOLETE    /* first count base classes so we can allocate space before parsing */
// OBSOLETE    for (p = *pp; p && *p && *p != ';'; p++)
// OBSOLETE      {
// OBSOLETE        if (*p == ' ')
// OBSOLETE  	bnum++;
// OBSOLETE      }
// OBSOLETE    bnum++;			/* add one more for last one */

// OBSOLETE    /* now parse the base classes until we get to the start of the methods 
// OBSOLETE       (code extracted and munged from read_baseclasses) */
// OBSOLETE    ALLOCATE_CPLUS_STRUCT_TYPE (type);
// OBSOLETE    TYPE_N_BASECLASSES (type) = bnum;

// OBSOLETE    /* allocate space */
// OBSOLETE    {
// OBSOLETE      int num_bytes = B_BYTES (TYPE_N_BASECLASSES (type));
// OBSOLETE      char *pointer;

// OBSOLETE      pointer = (char *) TYPE_ALLOC (type, num_bytes);
// OBSOLETE      TYPE_FIELD_VIRTUAL_BITS (type) = (B_TYPE *) pointer;
// OBSOLETE    }
// OBSOLETE    B_CLRALL (TYPE_FIELD_VIRTUAL_BITS (type), TYPE_N_BASECLASSES (type));

// OBSOLETE    for (i = 0; i < TYPE_N_BASECLASSES (type); i++)
// OBSOLETE      {
// OBSOLETE        new = (struct nextfield *) xmalloc (sizeof (struct nextfield));
// OBSOLETE        make_cleanup (xfree, new);
// OBSOLETE        memset (new, 0, sizeof (struct nextfield));
// OBSOLETE        new->next = fip->list;
// OBSOLETE        fip->list = new;
// OBSOLETE        FIELD_BITSIZE (new->field) = 0;	/* this should be an unpacked field! */

// OBSOLETE        STABS_CONTINUE (pp, objfile);

// OBSOLETE        /* virtual?  eg: v2@@Bvir */
// OBSOLETE        if (**pp == 'v')
// OBSOLETE  	{
// OBSOLETE  	  SET_TYPE_FIELD_VIRTUAL (type, i);
// OBSOLETE  	  ++(*pp);
// OBSOLETE  	}

// OBSOLETE        /* access?  eg: 2@@Bvir */
// OBSOLETE        /* Note: protected inheritance not supported in cfront */
// OBSOLETE        switch (*(*pp)++)
// OBSOLETE  	{
// OBSOLETE  	case CFRONT_VISIBILITY_PRIVATE:
// OBSOLETE  	  new->visibility = VISIBILITY_PRIVATE;
// OBSOLETE  	  break;
// OBSOLETE  	case CFRONT_VISIBILITY_PUBLIC:
// OBSOLETE  	  new->visibility = VISIBILITY_PUBLIC;
// OBSOLETE  	  break;
// OBSOLETE  	default:
// OBSOLETE  	  /* Bad visibility format.  Complain and treat it as
// OBSOLETE  	     public.  */
// OBSOLETE  	  {
// OBSOLETE  	    complaint (&symfile_complaints,
// OBSOLETE  		       "Unknown visibility `%c' for baseclass",
// OBSOLETE  		       new->visibility);
// OBSOLETE  	    new->visibility = VISIBILITY_PUBLIC;
// OBSOLETE  	  }
// OBSOLETE  	}

// OBSOLETE        /* "@@" comes next - eg: @@Bvir */
// OBSOLETE        if (**pp != '@@')
// OBSOLETE  	{
// OBSOLETE  	  msg_unknown_complaint (*pp);
// OBSOLETE  	  return 1;
// OBSOLETE  	}
// OBSOLETE        ++(*pp);


// OBSOLETE        /* Set the bit offset of the portion of the object corresponding 
// OBSOLETE           to this baseclass.  Always zero in the absence of
// OBSOLETE           multiple inheritance.  */
// OBSOLETE        /* Unable to read bit position from stabs;
// OBSOLETE           Assuming no multiple inheritance for now FIXME! */
// OBSOLETE        /* We may have read this in the structure definition;
// OBSOLETE           now we should fixup the members to be the actual base classes */
// OBSOLETE        FIELD_BITPOS (new->field) = 0;

// OBSOLETE        /* Get the base class name and type */
// OBSOLETE        {
// OBSOLETE  	char *bname;		/* base class name */
// OBSOLETE  	struct symbol *bsym;	/* base class */
// OBSOLETE  	char *p1, *p2;
// OBSOLETE  	p1 = strchr (*pp, ' ');
// OBSOLETE  	p2 = strchr (*pp, ';');
// OBSOLETE  	if (p1 < p2)
// OBSOLETE  	  bname = get_substring (pp, ' ');
// OBSOLETE  	else
// OBSOLETE  	  bname = get_substring (pp, ';');
// OBSOLETE  	if (!bname || !*bname)
// OBSOLETE  	  {
// OBSOLETE  	    msg_unknown_complaint (*pp);
// OBSOLETE  	    return 1;
// OBSOLETE  	  }
// OBSOLETE  	/* FIXME! attach base info to type */
// OBSOLETE  	bsym = lookup_symbol (bname, 0, STRUCT_DOMAIN, 0, 0);	/*demangled_name */
// OBSOLETE  	if (bsym)
// OBSOLETE  	  {
// OBSOLETE  	    new->field.type = SYMBOL_TYPE (bsym);
// OBSOLETE  	    new->field.name = type_name_no_tag (new->field.type);
// OBSOLETE  	  }
// OBSOLETE  	else
// OBSOLETE  	  {
// OBSOLETE  	    complaint (&symfile_complaints, "Unable to find base type for %s",
// OBSOLETE  		       *pp);
// OBSOLETE  	    return 1;
// OBSOLETE  	  }
// OBSOLETE        }

// OBSOLETE        /* If more base classes to parse, loop again.
// OBSOLETE           We ate the last ' ' or ';' in get_substring,
// OBSOLETE           so on exit we will have skipped the trailing ';' */
// OBSOLETE        /* if invalid, return 0; add code to detect  - FIXME! */
// OBSOLETE      }
// OBSOLETE    return 1;
// OBSOLETE  }

// OBSOLETE  /* read cfront member functions.
// OBSOLETE     pp points to string starting with list of functions
// OBSOLETE     eg: A:ZcA;1@@Bpub v2@@Bvirpri;__ct__1AFv func__1AFv *sfunc__1AFv ;as__1A ;;
// OBSOLETE     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 
// OBSOLETE     A:ZcA;;foopri__1AFv foopro__1AFv __ct__1AFv __ct__1AFRC1A foopub__1AFv ;;;
// OBSOLETE     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 
// OBSOLETE   */

// OBSOLETE  static int
// OBSOLETE  read_cfront_member_functions (struct field_info *fip, char **pp,
// OBSOLETE  			      struct type *type, struct objfile *objfile)
// OBSOLETE  {
// OBSOLETE    /* This code extracted from read_member_functions 
// OBSOLETE       so as to do the similar thing for our funcs */

// OBSOLETE    int nfn_fields = 0;
// OBSOLETE    int length = 0;
// OBSOLETE    /* Total number of member functions defined in this class.  If the class
// OBSOLETE       defines two `f' functions, and one `g' function, then this will have
// OBSOLETE       the value 3.  */
// OBSOLETE    int total_length = 0;
// OBSOLETE    int i;
// OBSOLETE    struct next_fnfield
// OBSOLETE      {
// OBSOLETE        struct next_fnfield *next;
// OBSOLETE        struct fn_field fn_field;
// OBSOLETE      }
// OBSOLETE     *sublist;
// OBSOLETE    struct type *look_ahead_type;
// OBSOLETE    struct next_fnfieldlist *new_fnlist;
// OBSOLETE    struct next_fnfield *new_sublist;
// OBSOLETE    char *main_fn_name;
// OBSOLETE    char *fname;
// OBSOLETE    struct symbol *ref_func = 0;

// OBSOLETE    /* Process each list until we find the end of the member functions.
// OBSOLETE       eg: p = "__ct__1AFv foo__1AFv ;;;" */

// OBSOLETE    STABS_CONTINUE (pp, objfile);	/* handle \\ */

// OBSOLETE    while (**pp != ';' && (fname = get_substring (pp, ' '), fname))
// OBSOLETE      {
// OBSOLETE        int is_static = 0;
// OBSOLETE        int sublist_count = 0;
// OBSOLETE        char *pname;
// OBSOLETE        if (fname[0] == '*')	/* static member */
// OBSOLETE  	{
// OBSOLETE  	  is_static = 1;
// OBSOLETE  	  sublist_count++;
// OBSOLETE  	  fname++;
// OBSOLETE  	}
// OBSOLETE        ref_func = lookup_symbol (fname, 0, VAR_DOMAIN, 0, 0);		/* demangled name */
// OBSOLETE        if (!ref_func)
// OBSOLETE  	{
// OBSOLETE  	  complaint (&symfile_complaints,
// OBSOLETE  		     "Unable to find function symbol for %s", fname);
// OBSOLETE  	  continue;
// OBSOLETE  	}
// OBSOLETE        sublist = NULL;
// OBSOLETE        look_ahead_type = NULL;
// OBSOLETE        length = 0;

// OBSOLETE        new_fnlist = (struct next_fnfieldlist *)
// OBSOLETE  	xmalloc (sizeof (struct next_fnfieldlist));
// OBSOLETE        make_cleanup (xfree, new_fnlist);
// OBSOLETE        memset (new_fnlist, 0, sizeof (struct next_fnfieldlist));

// OBSOLETE        /* The following is code to work around cfront generated stabs.
// OBSOLETE           The stabs contains full mangled name for each field.
// OBSOLETE           We try to demangle the name and extract the field name out of it.  */
// OBSOLETE        {
// OBSOLETE  	char *dem, *dem_p, *dem_args;
// OBSOLETE  	int dem_len;
// OBSOLETE  	dem = cplus_demangle (fname, DMGL_ANSI | DMGL_PARAMS);
// OBSOLETE  	if (dem != NULL)
// OBSOLETE  	  {
// OBSOLETE  	    dem_p = strrchr (dem, ':');
// OBSOLETE  	    if (dem_p != 0 && *(dem_p - 1) == ':')
// OBSOLETE  	      dem_p++;
// OBSOLETE  	    /* get rid of args */
// OBSOLETE  	    dem_args = strchr (dem_p, '(');
// OBSOLETE  	    if (dem_args == NULL)
// OBSOLETE  	      dem_len = strlen (dem_p);
// OBSOLETE  	    else
// OBSOLETE  	      dem_len = dem_args - dem_p;
// OBSOLETE  	    main_fn_name =
// OBSOLETE  	      obsavestring (dem_p, dem_len, &objfile->type_obstack);
// OBSOLETE  	  }
// OBSOLETE  	else
// OBSOLETE  	  {
// OBSOLETE  	    main_fn_name =
// OBSOLETE  	      obsavestring (fname, strlen (fname), &objfile->type_obstack);
// OBSOLETE  	  }
// OBSOLETE        }				/* end of code for cfront work around */

// OBSOLETE        new_fnlist->fn_fieldlist.name = main_fn_name;

// OBSOLETE  /*-------------------------------------------------*/
// OBSOLETE        /* Set up the sublists
// OBSOLETE           Sublists are stuff like args, static, visibility, etc.
// OBSOLETE           so in ARM, we have to set that info some other way.
// OBSOLETE           Multiple sublists happen if overloading
// OBSOLETE           eg: foo::26=##1;:;2A.;
// OBSOLETE           In g++, we'd loop here thru all the sublists...  */

// OBSOLETE        new_sublist =
// OBSOLETE  	(struct next_fnfield *) xmalloc (sizeof (struct next_fnfield));
// OBSOLETE        make_cleanup (xfree, new_sublist);
// OBSOLETE        memset (new_sublist, 0, sizeof (struct next_fnfield));

// OBSOLETE        /* eat 1; from :;2A.; */
// OBSOLETE        new_sublist->fn_field.type = SYMBOL_TYPE (ref_func);	/* normally takes a read_type */
// OBSOLETE        /* Make this type look like a method stub for gdb */
// OBSOLETE        TYPE_FLAGS (new_sublist->fn_field.type) |= TYPE_FLAG_STUB;
// OBSOLETE        TYPE_CODE (new_sublist->fn_field.type) = TYPE_CODE_METHOD;

// OBSOLETE        /* If this is just a stub, then we don't have the real name here. */
// OBSOLETE        if (TYPE_STUB (new_sublist->fn_field.type))
// OBSOLETE  	{
// OBSOLETE  	  if (!TYPE_DOMAIN_TYPE (new_sublist->fn_field.type))
// OBSOLETE  	    TYPE_DOMAIN_TYPE (new_sublist->fn_field.type) = type;
// OBSOLETE  	  new_sublist->fn_field.is_stub = 1;
// OBSOLETE  	}

// OBSOLETE        /* physname used later in mangling; eg PFs_i,5 for foo__1aFPFs_i 
// OBSOLETE           physname gets strcat'd in order to recreate the onto mangled name */
// OBSOLETE        pname = get_cfront_method_physname (fname);
// OBSOLETE        new_sublist->fn_field.physname = savestring (pname, strlen (pname));


// OBSOLETE        /* Set this member function's visibility fields. 
// OBSOLETE           Unable to distinguish access from stabs definition!
// OBSOLETE           Assuming public for now.  FIXME!
// OBSOLETE           (for private, set new_sublist->fn_field.is_private = 1,
// OBSOLETE           for public, set new_sublist->fn_field.is_protected = 1) */

// OBSOLETE        /* Unable to distinguish const/volatile from stabs definition!
// OBSOLETE           Assuming normal for now.  FIXME! */

// OBSOLETE        new_sublist->fn_field.is_const = 0;
// OBSOLETE        new_sublist->fn_field.is_volatile = 0;	/* volatile not implemented in cfront */

// OBSOLETE        /* Set virtual/static function info
// OBSOLETE           How to get vtable offsets ? 
// OBSOLETE           Assuming normal for now FIXME!! 
// OBSOLETE           For vtables, figure out from whence this virtual function came.
// OBSOLETE           It may belong to virtual function table of
// OBSOLETE           one of its baseclasses.
// OBSOLETE           set:
// OBSOLETE           new_sublist -> fn_field.voffset = vtable offset,
// OBSOLETE           new_sublist -> fn_field.fcontext = look_ahead_type;
// OBSOLETE           where look_ahead_type is type of baseclass */
// OBSOLETE        if (is_static)
// OBSOLETE  	new_sublist->fn_field.voffset = VOFFSET_STATIC;
// OBSOLETE        else			/* normal member function.  */
// OBSOLETE  	new_sublist->fn_field.voffset = 0;
// OBSOLETE        new_sublist->fn_field.fcontext = 0;


// OBSOLETE        /* Prepare new sublist */
// OBSOLETE        new_sublist->next = sublist;
// OBSOLETE        sublist = new_sublist;
// OBSOLETE        length++;

// OBSOLETE        /* In g++, we loop thu sublists - now we set from functions. */
// OBSOLETE        new_fnlist->fn_fieldlist.fn_fields = (struct fn_field *)
// OBSOLETE  	obstack_alloc (&objfile->type_obstack,
// OBSOLETE  		       sizeof (struct fn_field) * length);
// OBSOLETE        memset (new_fnlist->fn_fieldlist.fn_fields, 0,
// OBSOLETE  	      sizeof (struct fn_field) * length);
// OBSOLETE        for (i = length; (i--, sublist); sublist = sublist->next)
// OBSOLETE  	{
// OBSOLETE  	  new_fnlist->fn_fieldlist.fn_fields[i] = sublist->fn_field;
// OBSOLETE  	}

// OBSOLETE        new_fnlist->fn_fieldlist.length = length;
// OBSOLETE        new_fnlist->next = fip->fnlist;
// OBSOLETE        fip->fnlist = new_fnlist;
// OBSOLETE        nfn_fields++;
// OBSOLETE        total_length += length;
// OBSOLETE        STABS_CONTINUE (pp, objfile);	/* handle \\ */
// OBSOLETE      }				/* end of loop */

// OBSOLETE    if (nfn_fields)
// OBSOLETE      {
// OBSOLETE        /* type should already have space */
// OBSOLETE        TYPE_FN_FIELDLISTS (type) = (struct fn_fieldlist *)
// OBSOLETE  	TYPE_ALLOC (type, sizeof (struct fn_fieldlist) * nfn_fields);
// OBSOLETE        memset (TYPE_FN_FIELDLISTS (type), 0,
// OBSOLETE  	      sizeof (struct fn_fieldlist) * nfn_fields);
// OBSOLETE        TYPE_NFN_FIELDS (type) = nfn_fields;
// OBSOLETE        TYPE_NFN_FIELDS_TOTAL (type) = total_length;
// OBSOLETE      }

// OBSOLETE    /* end of scope for reading member func */

// OBSOLETE    /* eg: ";;" */

// OBSOLETE    /* Skip trailing ';' and bump count of number of fields seen */
// OBSOLETE    if (**pp == ';')
// OBSOLETE      (*pp)++;
// OBSOLETE    else
// OBSOLETE      return 0;
// OBSOLETE    return 1;
// OBSOLETE  }

// OBSOLETE  /* This routine fixes up partial cfront types that were created
// OBSOLETE     while parsing the stabs.  The main need for this function is
// OBSOLETE     to add information such as methods to classes.
// OBSOLETE     Examples of "p": "sA;;__ct__1AFv foo__1AFv ;;;" */
// OBSOLETE  int
// OBSOLETE  resolve_cfront_continuation (struct objfile *objfile, struct symbol *sym,
// OBSOLETE  			     char *p)
// OBSOLETE  {
// OBSOLETE    struct symbol *ref_sym = 0;
// OBSOLETE    char *sname;
// OBSOLETE    /* snarfed from read_struct_type */
// OBSOLETE    struct field_info fi;
// OBSOLETE    struct type *type;
// OBSOLETE    struct cleanup *back_to;

// OBSOLETE    /* Need to make sure that fi isn't gunna conflict with struct 
// OBSOLETE       in case struct already had some fnfs */
// OBSOLETE    fi.list = NULL;
// OBSOLETE    fi.fnlist = NULL;
// OBSOLETE    back_to = make_cleanup (null_cleanup, 0);

// OBSOLETE    /* We only accept structs, classes and unions at the moment. 
// OBSOLETE       Other continuation types include t (typedef), r (long dbl), ... 
// OBSOLETE       We may want to add support for them as well; 
// OBSOLETE       right now they are handled by duplicating the symbol information 
// OBSOLETE       into the type information (see define_symbol) */
// OBSOLETE    if (*p != 's'			/* structs */
// OBSOLETE        && *p != 'c'		/* class */
// OBSOLETE        && *p != 'u')		/* union */
// OBSOLETE      return 0;			/* only handle C++ types */
// OBSOLETE    p++;

// OBSOLETE    /* Get symbol typs name and validate 
// OBSOLETE       eg: p = "A;;__ct__1AFv foo__1AFv ;;;" */
// OBSOLETE    sname = get_substring (&p, ';');
// OBSOLETE    if (!sname || strcmp (sname, DEPRECATED_SYMBOL_NAME (sym)))
// OBSOLETE      error ("Internal error: base symbol type name does not match\n");

// OBSOLETE    /* Find symbol's internal gdb reference using demangled_name.
// OBSOLETE       This is the real sym that we want; 
// OBSOLETE       sym was a temp hack to make debugger happy */
// OBSOLETE    ref_sym = lookup_symbol (DEPRECATED_SYMBOL_NAME (sym), 0, STRUCT_DOMAIN, 0, 0);
// OBSOLETE    type = SYMBOL_TYPE (ref_sym);


// OBSOLETE    /* Now read the baseclasses, if any, read the regular C struct or C++
// OBSOLETE       class member fields, attach the fields to the type, read the C++
// OBSOLETE       member functions, attach them to the type, and then read any tilde
// OBSOLETE       field (baseclass specifier for the class holding the main vtable). */

// OBSOLETE    if (!read_cfront_baseclasses (&fi, &p, type, objfile)
// OBSOLETE    /* g++ does this next, but cfront already did this: 
// OBSOLETE       || !read_struct_fields (&fi, &p, type, objfile) */
// OBSOLETE        || !copy_cfront_struct_fields (&fi, type, objfile)
// OBSOLETE        || !read_cfront_member_functions (&fi, &p, type, objfile)
// OBSOLETE        || !read_cfront_static_fields (&fi, &p, type, objfile)
// OBSOLETE        || !attach_fields_to_type (&fi, type, objfile)
// OBSOLETE        || !attach_fn_fields_to_type (&fi, type)
// OBSOLETE    /* g++ does this next, but cfront doesn't seem to have this: 
// OBSOLETE       || !read_tilde_fields (&fi, &p, type, objfile) */
// OBSOLETE      )
// OBSOLETE      {
// OBSOLETE        type = error_type (&p, objfile);
// OBSOLETE      }

// OBSOLETE    do_cleanups (back_to);
// OBSOLETE    return 0;
// OBSOLETE  }
// OBSOLETE  /* End of code added to support parsing of ARM/Cfront stabs strings */
#endif /* OBSOLETE CFront */

a1407 9
#if 0 /* OBSOLETE CFront */
// OBSOLETE      /* The semantics of C++ state that "struct foo { ... }" also defines 
// OBSOLETE         a typedef for "foo".  Unfortunately, cfront never makes the typedef
// OBSOLETE         when translating C++ into C.  We make the typedef here so that
// OBSOLETE         "ptype foo" works as expected for cfront translated code.  */
// OBSOLETE       else if ((current_subfile->language == language_cplus)
// OBSOLETE 	       || (current_subfile->language == language_objc))
// OBSOLETE 	synonym = 1;
#endif /* OBSOLETE CFront */
a1496 26
#if 0 /* OBSOLETE CFront */
// OBSOLETE        /* New code added to support cfront stabs strings.
// OBSOLETE           Note: case 'P' already handled above */
// OBSOLETE      case 'Z':
// OBSOLETE        /* Cfront type continuation coming up!
// OBSOLETE           Find the original definition and add to it.
// OBSOLETE           We'll have to do this for the typedef too,
// OBSOLETE           since we cloned the symbol to define a type in read_type.
// OBSOLETE           Stabs info examples:
// OBSOLETE           __1C :Ztl 
// OBSOLETE           foo__1CFv :ZtF (first def foo__1CFv:F(0,3);(0,24))
// OBSOLETE           C:ZsC;;__ct__1CFv func1__1CFv func2__1CFv ... ;;;
// OBSOLETE           where C is the name of the class.
// OBSOLETE           Unfortunately, we can't lookup the original symbol yet 'cuz 
// OBSOLETE           we haven't finished reading all the symbols.
// OBSOLETE           Instead, we save it for processing later */
// OBSOLETE        process_later (sym, p, resolve_cfront_continuation);
// OBSOLETE        SYMBOL_TYPE (sym) = error_type (&p, objfile);	/* FIXME! change later */
// OBSOLETE        SYMBOL_CLASS (sym) = LOC_CONST;
// OBSOLETE        SYMBOL_VALUE (sym) = 0;
// OBSOLETE        SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
// OBSOLETE        /* Don't add to list - we'll delete it later when 
// OBSOLETE           we add the continuation to the real sym */
// OBSOLETE        return sym;
// OBSOLETE        /* End of new code added to support cfront stabs strings */
#endif /* OBSOLETE CFront */
d3010 2
a3011 33
#if 0 /* OBSOLETE CFront */
// OBSOLETE    /* The following is code to work around cfront generated stabs.
// OBSOLETE       The stabs contains full mangled name for each field.
// OBSOLETE       We try to demangle the name and extract the field name out of it.
// OBSOLETE     */
// OBSOLETE    if (ARM_DEMANGLING && current_subfile->language == language_cplus)
// OBSOLETE      {
// OBSOLETE        char save_p;
// OBSOLETE        char *dem, *dem_p;
// OBSOLETE        save_p = *p;
// OBSOLETE        *p = '\0';
// OBSOLETE        dem = cplus_demangle (*pp, DMGL_ANSI | DMGL_PARAMS);
// OBSOLETE        if (dem != NULL)
// OBSOLETE  	{
// OBSOLETE  	  dem_p = strrchr (dem, ':');
// OBSOLETE  	  if (dem_p != 0 && *(dem_p - 1) == ':')
// OBSOLETE  	    dem_p++;
// OBSOLETE  	  FIELD_NAME (fip->list->field) =
// OBSOLETE  	    obsavestring (dem_p, strlen (dem_p), &objfile->type_obstack);
// OBSOLETE  	}
// OBSOLETE        else
// OBSOLETE  	{
// OBSOLETE  	  FIELD_NAME (fip->list->field) =
// OBSOLETE  	    obsavestring (*pp, p - *pp, &objfile->type_obstack);
// OBSOLETE  	}
// OBSOLETE        *p = save_p;
// OBSOLETE      }
// OBSOLETE    /* end of code for cfront work around */

// OBSOLETE   else
#endif /* OBSOLETE CFront */
    fip->list->field.name =
      obsavestring (*pp, p - *pp, &objfile->type_obstack);
a3460 132

#if 0 /* OBSOLETE CFront */
// OBSOLETE  /* read cfront class static data.
// OBSOLETE     pp points to string starting with the list of static data
// OBSOLETE     eg: A:ZcA;1@@Bpub v2@@Bvirpri;__ct__1AFv func__1AFv *sfunc__1AFv ;as__1A ;;
// OBSOLETE     ^^^^^^^^

// OBSOLETE     A:ZcA;;foopri__1AFv foopro__1AFv __ct__1AFv __ct__1AFRC1A foopub__1AFv ;;;
// OBSOLETE     ^
// OBSOLETE   */

// OBSOLETE  static int
// OBSOLETE  read_cfront_static_fields (struct field_info *fip, char **pp, struct type *type,
// OBSOLETE  			   struct objfile *objfile)
// OBSOLETE  {
// OBSOLETE    struct nextfield *new;
// OBSOLETE    struct type *stype;
// OBSOLETE    char *sname;
// OBSOLETE    struct symbol *ref_static = 0;

// OBSOLETE    if (**pp == ';')		/* no static data; return */
// OBSOLETE      {
// OBSOLETE        ++(*pp);
// OBSOLETE        return 1;
// OBSOLETE      }

// OBSOLETE    /* Process each field in the list until we find the terminating ";" */

// OBSOLETE    /* eg: p = "as__1A ;;;" */
// OBSOLETE    STABS_CONTINUE (pp, objfile);	/* handle \\ */
// OBSOLETE    while (**pp != ';' && (sname = get_substring (pp, ' '), sname))
// OBSOLETE      {
// OBSOLETE        ref_static = lookup_symbol (sname, 0, VAR_DOMAIN, 0, 0);	/*demangled_name */
// OBSOLETE        if (!ref_static)
// OBSOLETE  	{
// OBSOLETE  	  complaint (&symfile_complaints,
// OBSOLETE  		     "Unable to find symbol for static data field %s", sname);
// OBSOLETE  	  continue;
// OBSOLETE  	}
// OBSOLETE        stype = SYMBOL_TYPE (ref_static);

// OBSOLETE        /* allocate a new fip */
// OBSOLETE        new = (struct nextfield *) xmalloc (sizeof (struct nextfield));
// OBSOLETE        make_cleanup (xfree, new);
// OBSOLETE        memset (new, 0, sizeof (struct nextfield));
// OBSOLETE        new->next = fip->list;
// OBSOLETE        fip->list = new;

// OBSOLETE        /* set visibility */
// OBSOLETE        /* FIXME! no way to tell visibility from stabs??? */
// OBSOLETE        new->visibility = VISIBILITY_PUBLIC;

// OBSOLETE        /* set field info into fip */
// OBSOLETE        fip->list->field.type = stype;

// OBSOLETE        /* set bitpos & bitsize */
// OBSOLETE        SET_FIELD_PHYSNAME (fip->list->field, savestring (sname, strlen (sname)));

// OBSOLETE        /* set name field */
// OBSOLETE        /* The following is code to work around cfront generated stabs.
// OBSOLETE           The stabs contains full mangled name for each field.
// OBSOLETE           We try to demangle the name and extract the field name out of it.
// OBSOLETE         */
// OBSOLETE        if (ARM_DEMANGLING)
// OBSOLETE  	{
// OBSOLETE  	  char *dem, *dem_p;
// OBSOLETE  	  dem = cplus_demangle (sname, DMGL_ANSI | DMGL_PARAMS);
// OBSOLETE  	  if (dem != NULL)
// OBSOLETE  	    {
// OBSOLETE  	      dem_p = strrchr (dem, ':');
// OBSOLETE  	      if (dem_p != 0 && *(dem_p - 1) == ':')
// OBSOLETE  		dem_p++;
// OBSOLETE  	      fip->list->field.name =
// OBSOLETE  		obsavestring (dem_p, strlen (dem_p), &objfile->type_obstack);
// OBSOLETE  	    }
// OBSOLETE  	  else
// OBSOLETE  	    {
// OBSOLETE  	      fip->list->field.name =
// OBSOLETE  		obsavestring (sname, strlen (sname), &objfile->type_obstack);
// OBSOLETE  	    }
// OBSOLETE  	}			/* end of code for cfront work around */
// OBSOLETE      }				/* loop again for next static field */
// OBSOLETE    return 1;
// OBSOLETE  }

// OBSOLETE  /* Copy structure fields to fip so attach_fields_to_type will work.
// OBSOLETE     type has already been created with the initial instance data fields.
// OBSOLETE     Now we want to be able to add the other members to the class,
// OBSOLETE     so we want to add them back to the fip and reattach them again
// OBSOLETE     once we have collected all the class members. */

// OBSOLETE  static int
// OBSOLETE  copy_cfront_struct_fields (struct field_info *fip, struct type *type,
// OBSOLETE  			   struct objfile *objfile)
// OBSOLETE  {
// OBSOLETE    int nfields = TYPE_NFIELDS (type);
// OBSOLETE    int i;
// OBSOLETE    struct nextfield *new;

// OBSOLETE    /* Copy the fields into the list of fips and reset the types 
// OBSOLETE       to remove the old fields */

// OBSOLETE    for (i = 0; i < nfields; i++)
// OBSOLETE      {
// OBSOLETE        /* allocate a new fip */
// OBSOLETE        new = (struct nextfield *) xmalloc (sizeof (struct nextfield));
// OBSOLETE        make_cleanup (xfree, new);
// OBSOLETE        memset (new, 0, sizeof (struct nextfield));
// OBSOLETE        new->next = fip->list;
// OBSOLETE        fip->list = new;

// OBSOLETE        /* copy field info into fip */
// OBSOLETE        new->field = TYPE_FIELD (type, i);
// OBSOLETE        /* set visibility */
// OBSOLETE        if (TYPE_FIELD_PROTECTED (type, i))
// OBSOLETE  	new->visibility = VISIBILITY_PROTECTED;
// OBSOLETE        else if (TYPE_FIELD_PRIVATE (type, i))
// OBSOLETE  	new->visibility = VISIBILITY_PRIVATE;
// OBSOLETE        else
// OBSOLETE  	new->visibility = VISIBILITY_PUBLIC;
// OBSOLETE      }
// OBSOLETE    /* Now delete the fields from the type since we will be 
// OBSOLETE       allocing new space once we get the rest of the fields 
// OBSOLETE       in attach_fields_to_type.
// OBSOLETE       The pointer TYPE_FIELDS(type) is left dangling but should 
// OBSOLETE       be freed later by objstack_free */
// OBSOLETE    TYPE_FIELDS (type) = 0;
// OBSOLETE    TYPE_NFIELDS (type) = 0;

// OBSOLETE    return 1;
// OBSOLETE  }
#endif /* OBSOLETE CFront */
@


1.63
log
@* gdbarch.sh (DEPRECATED_REG_STRUCT_HAS_ADDR): Add comment.
* gdbarch.h, gdbarch.c: Regenerate.
(stabs_argument_has_addr): New architecture method.
* arch-utils.h (default_stabs_argument_has_addr): New prototype.
* arch-utils.c: Include "buildsym.h".
(default_stabs_argument_has_addr): New function.
* stabsread.c (define_symbol): Use stabs_argument_has_addr
instead of DEPRECATED_REG_STRUCT_HAS_ADDR.
@
text
@a1213 1
/* ARGSUSED */
@


1.62
log
@2003-09-16  Andrew Cagney  <cagney@@redhat.com>

	* buildsym.c: Remove more occurances of "register".
	* coffread.c, dbxread.c, dcache.c, dwarf2read.c: Ditto.
	* environ.c, eval.c, f-valprint.c, findvar.c: Ditto.
	* gdbtypes.c, gnu-v2-abi.c, h8300-tdep.c, hppa-tdep.c: Ditto.
	* infcmd.c, mdebugread.c, minsyms.c, mips-tdep.c: Ditto.
	* printcmd.c, remote-vx.c, sh-stub.c, sh-tdep.c: Ditto.
	* sh64-tdep.c, source.c, stabsread.c, stack.c: Ditto.
	* standalone.c, symfile.c, symmisc.c, symtab.c: Ditto.
	* utils.c, valops.c, values.c, xcoffread.c: Ditto.
@
text
@d1751 14
a1764 11
	  /* Sun cc uses a pair of symbols, one 'p' and one 'r' with the same
	     name to represent an argument passed in a register.
	     GCC uses 'P' for the same case.  So if we find such a symbol pair
	     we combine it into one 'P' symbol.  For Sun cc we need to do this
	     regardless of DEPRECATED_REG_STRUCT_HAS_ADDR, because the compiler puts out
	     the 'p' symbol even if it never saves the argument onto the stack.

	     On most machines, we want to preserve both symbols, so that
	     we can still get information about what is going on with the
	     stack (VAX for computing args_printed, using stack slots instead
	     of saved registers in backtraces, etc.).
d1774 2
a1775 7
	      && DEPRECATED_REG_STRUCT_HAS_ADDR_P ()
	      && DEPRECATED_REG_STRUCT_HAS_ADDR (processing_gcc_compilation,
				      SYMBOL_TYPE (sym))
	      && (TYPE_CODE (SYMBOL_TYPE (sym)) == TYPE_CODE_STRUCT
		  || TYPE_CODE (SYMBOL_TYPE (sym)) == TYPE_CODE_UNION
		  || TYPE_CODE (SYMBOL_TYPE (sym)) == TYPE_CODE_SET
		  || TYPE_CODE (SYMBOL_TYPE (sym)) == TYPE_CODE_BITSTRING)
d2048 3
a2050 2
  /* When passing structures to a function, some systems sometimes pass
     the address in a register, not the structure itself. */
d2052 1
a2052 2
  if (DEPRECATED_REG_STRUCT_HAS_ADDR_P ()
      && DEPRECATED_REG_STRUCT_HAS_ADDR (processing_gcc_compilation, SYMBOL_TYPE (sym))
d2055 8
a2062 16
      struct type *symbol_type = check_typedef (SYMBOL_TYPE (sym));

      if ((TYPE_CODE (symbol_type) == TYPE_CODE_STRUCT)
	  || (TYPE_CODE (symbol_type) == TYPE_CODE_UNION)
	  || (TYPE_CODE (symbol_type) == TYPE_CODE_BITSTRING)
	  || (TYPE_CODE (symbol_type) == TYPE_CODE_SET))
	{
	  /* If DEPRECATED_REG_STRUCT_HAS_ADDR yields non-zero we have to convert
	     LOC_REGPARM to LOC_REGPARM_ADDR for structures and unions. */
	  if (SYMBOL_CLASS (sym) == LOC_REGPARM)
	    SYMBOL_CLASS (sym) = LOC_REGPARM_ADDR;
	  /* Likewise for converting LOC_ARG to LOC_REF_ARG (for the 7th
	     and subsequent arguments on the sparc, for example).  */
	  else if (SYMBOL_CLASS (sym) == LOC_ARG)
	    SYMBOL_CLASS (sym) = LOC_REF_ARG;
	}
@


1.61
log
@2003-09-14  Andrew Cagney  <cagney@@redhat.com>

	* alpha-nat.c: Remove some occurances of "register".
	* alpha-tdep.c, arm-tdep.c, blockframe.c, breakpoint.c: Ditto.
	* buildsym.c, c-typeprint.c, c-valprint.c, coffread.c: Ditto.
	* corefile.c, cp-support.c, cp-valprint.c, cris-tdep.c: Ditto.
	* dbxread.c, dcache.c, dwarf2read.c, elfread.c: Ditto.
	* environ.c, eval.c, event-top.c, f-typeprint.c: Ditto.
	* f-valprint.c, findvar.c, frame.c, gdbtypes.c: Ditto.
	* h8300-tdep.c, hppa-tdep.c, hppab-nat.c, hppah-nat.c: Ditto.
	* hppam3-nat.c, hpread.c, ia64-aix-nat.c, ia64-linux-nat.c: Ditto.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Ditto.
	* infttrace.c, irix5-nat.c, jv-typeprint.c: Ditto.
	* jv-valprint.c, m68k-tdep.c, m68klinux-nat.c, main.c: Ditto.
	* mdebugread.c, minsyms.c, mips-linux-tdep.c: Ditto.
	* mips-nat.c, mips-tdep.c, mipsread.c, mipsv4-nat.c: Ditto.
	* ns32k-tdep.c, objfiles.c, p-typeprint.c: Ditto.
	* p-valprint.c, ppc-linux-nat.c, printcmd.c: Ditto.
	* remote-mips.c, remote-vx.c, rs6000-nat.c: Ditto.
	* rs6000-tdep.c, scm-exp.c, sh-tdep.c, sh64-tdep.c: Ditto.
	* solib.c, somread.c, source.c, sparc-tdep.c: Ditto.
	* stabsread.c, stack.c, standalone.c, symfile.c: Ditto.
	* symmisc.c, symtab.c, top.c, tracepoint.c: Ditto.
	* typeprint.c, utils.c, valarith.c, valops.c: Ditto.
	* values.c, vax-tdep.c, xcoffread.c: Ditto.
@
text
@d471 1
a471 1
read_type_number (register char **pp, register int *typenums)
d1944 1
a1944 1
	  register struct symbol *typedef_sym = (struct symbol *)
d2267 1
a2267 1
read_type (register char **pp, struct objfile *objfile)
d4030 1
a4030 1
attach_fn_fields_to_type (struct field_info *fip, register struct type *type)
d4181 1
a4181 1
attach_fields_to_type (struct field_info *fip, register struct type *type,
d4385 1
a4385 1
read_array_type (register char **pp, register struct type *type,
d4448 1
a4448 1
read_enum_type (register char **pp, register struct type *type,
d5122 1
a5122 1
      register int j;
@


1.60
log
@* gdbarch.sh (DEPRECATED_REG_STRUCT_HAS_ADDR): Renamed from
REG_STRUCT_HAS_ADDR.
* gdbarch.c, gdbarch.h: Updated.
* infcall.c (call_function_by_hand): Update.
* stabsread.c (define_symbol): Updated.
@
text
@d258 2
a259 2
  register int filenum = typenums[0];
  register int index = typenums[1];
d261 2
a262 2
  register int real_filenum;
  register struct header_file *f;
d359 1
a359 1
  register struct type **type_addr;
d1219 1
a1219 1
  register struct symbol *sym;
d1223 1
a1223 1
  register int i;
d2269 1
a2269 1
  register struct type *type = 0;
d3007 1
a3007 1
  register char *p;
d3468 1
a3468 1
  register char *p;
d3730 1
a3730 1
  register char *p;
d3951 1
a3951 1
  register char *p;
d4032 1
a4032 1
  register int n;
d4184 3
a4186 3
  register int nfields = 0;
  register int non_public_fields = 0;
  register struct nextfield *scan;
d4451 1
a4451 1
  register char *p;
d4453 2
a4454 2
  register long n;
  register struct symbol *sym;
@


1.59
log
@2003-05-26  Elena Zannoni  <ezannoni@@redhat.com>

	* stabsread.c (dbx_lookup_type): Make static.
	(read_type): Ditto.
	(add_undefined_type): Ditto.
	* stabsread.h (dbx_lookup_type, read_type, add_undefined_type): Do
	not export.
@
text
@d1755 1
a1755 1
	     regardless of REG_STRUCT_HAS_ADDR, because the compiler puts out
d1771 2
a1772 2
	      && REG_STRUCT_HAS_ADDR_P ()
	      && REG_STRUCT_HAS_ADDR (processing_gcc_compilation,
d2053 2
a2054 2
  if (REG_STRUCT_HAS_ADDR_P ()
      && REG_STRUCT_HAS_ADDR (processing_gcc_compilation, SYMBOL_TYPE (sym))
d2064 1
a2064 1
	  /* If REG_STRUCT_HAS_ADDR yields non-zero we have to convert
@


1.58
log
@2003-05-14  Elena Zannoni  <ezannoni@@redhat.com>

	* symtab.h (enum domain_enum): Rename from namespace_enum.
	(UNDEF_DOMAIN, VAR_DOMAIN, STRUCT_DOMAIN, LABEL_DOMAIN,
	VARIABLES_DOMAIN, FUNCTIONS_DOMAIN, TYPES_DOMAIN, METHODS_DOMAIN):
	Rename from UNDEF_NAMESPACE, VAR_NAMESPACE, STRUCT_NAMESPACE,
	LABEL_NAMESPACE, VARIABLES_NAMESPACE, FUNCTIONS_NAMESPACE,
	TYPES_NAMESPACE, METHODS_NAMESPACE.
	(SYMBOL_NAMESPACE): Rename to SYMBOL_DOMAIN.
	(struct symbol, struct partial_symbol): Rename field
	'namespace_enum namespace' to 'domain_enum domain'.
	(PSYMBOL_NAMESPACE): Rename to PSYMBOL_DOMAIN.
	Delete old define kludge for namespace.

	* ada-exp.y, ada-lang.c, ada-lang.h, alpha-tdep.c, arm-tdep.c,
	blockframe.c, c-exp.y, c-valprint.c, coffread.c, dbxread.c,
	dwarf2read.c, dwarfread.c, f-exp.y, gdbtypes.c, gdbtypes.h,
	gnu-v3-abi.c, hppa-tdep.c, hpread.c, jv-exp.y, jv-lang.c,
	language.c, linespec.c, m2-exp.y, m3-nat.c, mdebugread.c,
	mips-tdep.c, nlmread.c, objc-exp.y, objc-lang.c, objfiles.c,
	p-exp.y, p-valprint.c, parse.c, printcmd.c, scm-lang.c, source.c,
	stabsread.c, stack.c, symfile.c, symfile.h, symmisc.c, symtab.c,
	valops.c, values.c, xcoffread.c, xstormy16-tdep.c: Replace all
	occurrences of the above.

2003-05-12  Elena Zannoni  <ezannoni@@redhat.com>

	* mi-mi-cmd-stack.c (list_args_or_locals): Rename VAR_NAMESPACE to
	VAR_DOMAIN.
@
text
@d108 2
d151 2
d255 1
a255 1
struct type **
d2266 1
a2266 1
struct type *
d5135 1
a5135 1
void
@


1.57
log
@2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.h (SYMBOL_NATURAL_NAME): New macro.
	(SYMBOL_LINKAGE_NAME): Ditto.
	(SYMBOL_PRINT_NAME): Use SYMBOL_NATURAL_NAME and
	SYMBOL_LINKAGE_NAME.
	(struct general_symbol_info): Expand comment.
	(DEPRECATED_SYMBOL_NAME): Rename from SYMBOL_NAME.
	(SYMBOL_MATCHES_NAME): Use DEPRECATED_SYMBOL_NAME.
	(SYMBOL_MATCHES_REGEXP): Ditto.
	* symtab.c (symbol_natural_name): New function.
	* objfiles.h: Replace all uses of SYMBOL_NAME by
	DEPRECATED_SYMBOL_NAME.
	* xcoffread.c, valops.c, typeprint.c, tracepoint.c: Ditto.
	* symtab.c, symmisc.c, symfile.c, stack.c, stabsread.c: Ditto.
	* somsolib.c, sol-thread.c, rs6000-tdep.c, p-valprint.c: Ditto.
	* printcmd.c, objfiles.c, objc-lang.c, mipsread.c: Ditto.
	* minsyms.c, mdebugread.c, linespec.c, jv-lang.c: Ditto.
	* i386-tdep.c, i386-linux-tdep.c, hpread.c, hppa-tdep.c: Ditto.
	* gnu-v2-abi.c, f-valprint.c, findvar.c, expprint.c: Ditto.
	* dwarfread.c, dwarf2read.c, dbxread.c, c-valprint.c: Ditto.
	* cp-valprint.c, coffread.c, buildsym.c, breakpoint.c: Ditto.
	* blockframe.c, ax-gdb.c, arm-linux-tdep.c, ada-lang.c: Ditto.
	* ada-exp.y: Ditto.
	* ada-exp.y: Update copyright.
	* sol-thread.c, mipsread.c, jv-lang.c, f-valprint.c: Ditto.
	* cp-valprint.c: Ditto.

2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* generic/gdbtk.h: Replace all instances of SYMBOL_NAME by
	DEPRECATED_SYMBOL_NAME.
	* generic/gdbtk-stack.c, generic/gdbtk-cmds.c: Ditto.
	* generic/gdbtk-stack.c, generic/gdbtk-cmds.c: Update copyright.

2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c: Replace all instances of SYMBOL_NAME with
	DEPRECATED_SYMBOL_NAME.  Update copyright.
@
text
@d421 1
a421 1
	      SYMBOL_NAMESPACE (sym) = VAR_NAMESPACE;
d680 1
a680 1
// OBSOLETE  	bsym = lookup_symbol (bname, 0, STRUCT_NAMESPACE, 0, 0);	/*demangled_name */
d753 1
a753 1
// OBSOLETE        ref_func = lookup_symbol (fname, 0, VAR_NAMESPACE, 0, 0);		/* demangled name */
d949 1
a949 1
// OBSOLETE    ref_sym = lookup_symbol (DEPRECATED_SYMBOL_NAME (sym), 0, STRUCT_NAMESPACE, 0, 0);
d1382 1
a1382 1
	  SYMBOL_NAMESPACE (sym) = VAR_NAMESPACE;
d1475 1
a1475 1
      SYMBOL_NAMESPACE (sym) = VAR_NAMESPACE;
d1483 1
a1483 1
      SYMBOL_NAMESPACE (sym) = VAR_NAMESPACE;
d1492 1
a1492 1
      SYMBOL_NAMESPACE (sym) = VAR_NAMESPACE;
d1563 1
a1563 1
      SYMBOL_NAMESPACE (sym) = VAR_NAMESPACE;
d1574 1
a1574 1
      SYMBOL_NAMESPACE (sym) = VAR_NAMESPACE;
d1596 1
a1596 1
      SYMBOL_NAMESPACE (sym) = VAR_NAMESPACE;
d1616 1
a1616 1
      SYMBOL_NAMESPACE (sym) = VAR_NAMESPACE;
d1728 1
a1728 1
      SYMBOL_NAMESPACE (sym) = VAR_NAMESPACE;
d1744 1
a1744 1
      SYMBOL_NAMESPACE (sym) = VAR_NAMESPACE;
d1815 1
a1815 1
      SYMBOL_NAMESPACE (sym) = VAR_NAMESPACE;
d1830 1
a1830 1
      SYMBOL_NAMESPACE (sym) = VAR_NAMESPACE;
d1931 1
a1931 1
      SYMBOL_NAMESPACE (sym) = STRUCT_NAMESPACE;
d1945 1
a1945 1
	  SYMBOL_NAMESPACE (typedef_sym) = VAR_NAMESPACE;
d1970 1
a1970 1
      SYMBOL_NAMESPACE (sym) = VAR_NAMESPACE;
d1979 1
a1979 1
      SYMBOL_NAMESPACE (sym) = VAR_NAMESPACE;
d1995 1
a1995 1
      SYMBOL_NAMESPACE (sym) = VAR_NAMESPACE;
d2007 1
a2007 1
      SYMBOL_NAMESPACE (sym) = VAR_NAMESPACE;
d2030 1
a2030 1
// OBSOLETE        SYMBOL_NAMESPACE (sym) = VAR_NAMESPACE;
d2041 1
a2041 1
      SYMBOL_NAMESPACE (sym) = VAR_NAMESPACE;
d2396 1
a2396 1
		  && SYMBOL_NAMESPACE (sym) == STRUCT_NAMESPACE
d4071 1
a4071 1
// OBSOLETE        ref_static = lookup_symbol (sname, 0, VAR_NAMESPACE, 0, 0);	/*demangled_name */
d4503 1
a4503 1
      SYMBOL_NAMESPACE (sym) = VAR_NAMESPACE;
d5190 1
a5190 1
			    && SYMBOL_NAMESPACE (sym) == STRUCT_NAMESPACE
@


1.57.16.1
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d421 1
a421 1
	      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d680 1
a680 1
// OBSOLETE  	bsym = lookup_symbol (bname, 0, STRUCT_DOMAIN, 0, 0);	/*demangled_name */
d753 1
a753 1
// OBSOLETE        ref_func = lookup_symbol (fname, 0, VAR_DOMAIN, 0, 0);		/* demangled name */
d949 1
a949 1
// OBSOLETE    ref_sym = lookup_symbol (DEPRECATED_SYMBOL_NAME (sym), 0, STRUCT_DOMAIN, 0, 0);
d1382 1
a1382 1
	  SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d1475 1
a1475 1
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d1483 1
a1483 1
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d1492 1
a1492 1
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d1563 1
a1563 1
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d1574 1
a1574 1
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d1596 1
a1596 1
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d1616 1
a1616 1
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d1728 1
a1728 1
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d1744 1
a1744 1
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d1815 1
a1815 1
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d1830 1
a1830 1
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d1931 1
a1931 1
      SYMBOL_DOMAIN (sym) = STRUCT_DOMAIN;
d1945 1
a1945 1
	  SYMBOL_DOMAIN (typedef_sym) = VAR_DOMAIN;
d1970 1
a1970 1
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d1979 1
a1979 1
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d1995 1
a1995 1
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d2007 1
a2007 1
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d2030 1
a2030 1
// OBSOLETE        SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d2041 1
a2041 1
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d2396 1
a2396 1
		  && SYMBOL_DOMAIN (sym) == STRUCT_DOMAIN
d4071 1
a4071 1
// OBSOLETE        ref_static = lookup_symbol (sname, 0, VAR_DOMAIN, 0, 0);	/*demangled_name */
d4503 1
a4503 1
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d5190 1
a5190 1
			    && SYMBOL_DOMAIN (sym) == STRUCT_DOMAIN
@


1.56
log
@2003-02-20  David Carlton  <carlton@@math.stanford.edu>

	* symtab.h (SYMBOL_PRINT_NAME): Rename from SYMBOL_SOURCE_NAME;
	expand comment.
	* ada-lang.c (user_select_syms, ada_finish_decode_line_1): Replace
	SYMBOL_PRINT_NAME with SYMBOL_SOURCE_NAME.
	* ada-typeprint.c (ada_typedef_print): Ditto.
	* ax-gdb.c (gen_var_ref): Ditto.
	* breakpoint.c (print_one_breakpoint): Ditto.
	* buildsym.c (finish_block): Ditto.
	* c-valprint.c (c_val_print): Ditto.
	* expprint.c (print_subexp): Ditto.
	* findvar.c (locate_var_value): Ditto.
	* infcmd.c (jump_command): Ditto.
	* linespec.c (decode_line_2, decode_compound): Ditto.
	* maint.c (maintenance_translate_address): Ditto.
	* objc-lang.c (compare_selectors, compare_classes): Ditto.
	* printcmd.c (build_address_symbolic, sym_info, print_frame_args):
	Ditto.
	* p-valprint.c (pascal_val_print): Ditto.
	* stabsread.c (define_symbol): Ditto.
	* stack.c (print_frame, frame_info, print_block_frame_locals)
	(print_frame_arg_vars, return_command): Ditto.
	* symfile.c (compare_symbols, compare_psymbols): Ditto.
	* symmisc.c (print_symbol): Ditto.
	* symtab.c (lookup_partial_symbol, lookup_block_symbol)
	(compare_search_syms, print_symbol_info, print_msymbol_info)
	(rbreak_command): Ditto.
	* tracepoint.c (tracepoints_info): Ditto.
	* typeprint.c (typedef_print): Ditto.
	* valops.c (value_of_variable, hand_function_call): Ditto.
	* cli/cli-cmds.c (edit_command, list_command): Ditto.
	* ada-typeprint.c: Update Copyright.
	* infcmd.c, objc-lang.c, p-valprint.c, symmisc.c: Ditto.
	* tracepoint.c, cli/cli-cmds.c: Ditto.
@
text
@d423 1
a423 1
	      SYMBOL_NAME (sym) =
d943 1
a943 1
// OBSOLETE    if (!sname || strcmp (sname, SYMBOL_NAME (sym)))
d949 1
a949 1
// OBSOLETE    ref_sym = lookup_symbol (SYMBOL_NAME (sym), 0, STRUCT_NAMESPACE, 0, 0);
d1076 1
a1076 1
  SYMBOL_NAME (sym) = SYMBOL_NAME (ref_sym);
d1280 1
a1280 1
	  SYMBOL_NAME (sym) = obsavestring ("this", strlen ("this"),
d1285 1
a1285 1
	  /* Was: SYMBOL_NAME (sym) = "vptr"; */
d1289 1
a1289 1
	  SYMBOL_NAME (sym) = obsavestring ("eh_throw", strlen ("eh_throw"),
d1327 1
a1327 1
         the correct name into SYMBOL_NAME.  */
d1334 1
a1334 1
	    /* FIXME! Want SYMBOL_NAME (sym) = 0;
d1579 1
a1579 1
      if (SYMBOL_NAME (sym) && SYMBOL_NAME (sym)[0] != '#')
d1581 1
a1581 1
	  i = hashname (SYMBOL_NAME (sym));
d1781 1
a1781 1
		  && STREQ (SYMBOL_NAME (prev_sym), SYMBOL_NAME (sym)))
d1804 1
a1804 1
      if (IS_STATIC_TRANSFORM_NAME (SYMBOL_NAME (sym)))
d1807 1
a1807 1
	  msym = lookup_minimal_symbol (SYMBOL_NAME (sym), NULL, objfile);
d1810 1
a1810 1
	      SYMBOL_NAME (sym) = STATIC_TRANSFORM_NAME (SYMBOL_NAME (sym));
d1855 1
a1855 1
	       && strcmp (SYMBOL_NAME (sym), vtbl_ptr_name))
d1895 1
a1895 1
		  TYPE_NAME (SYMBOL_TYPE (sym)) = SYMBOL_NAME (sym);
d1899 1
a1899 1
	    TYPE_NAME (SYMBOL_TYPE (sym)) = SYMBOL_NAME (sym);
d1934 1
a1934 1
	  = obconcat (&objfile->type_obstack, "", "", SYMBOL_NAME (sym));
d1948 1
a1948 1
	      = obconcat (&objfile->type_obstack, "", "", SYMBOL_NAME (sym));
d1959 1
a1959 1
      if (IS_STATIC_TRANSFORM_NAME (SYMBOL_NAME (sym)))
d1962 1
a1962 1
	  msym = lookup_minimal_symbol (SYMBOL_NAME (sym), NULL, objfile);
d1965 1
a1965 1
	      SYMBOL_NAME (sym) = STATIC_TRANSFORM_NAME (SYMBOL_NAME (sym));
d2398 1
a2398 1
		  && STREQ (SYMBOL_NAME (sym), type_name))
d4500 1
a4500 1
      SYMBOL_NAME (sym) = name;
d4542 1
a4542 1
	  TYPE_FIELD_NAME (type, n) = SYMBOL_NAME (xsym);
d5075 1
a5075 1
  SYMBOL_NAME (sym) = common_block_name;
d5102 1
a5102 1
  i = hashname (SYMBOL_NAME (sym));
d5193 1
a5193 1
			    && STREQ (SYMBOL_NAME (sym), typename))
d5249 1
a5249 1
	   msymbol && SYMBOL_NAME (msymbol) != NULL;
d5270 1
a5270 1
	  hash = hashname (SYMBOL_NAME (msymbol));
d5274 2
a5275 2
	      if (SYMBOL_NAME (msymbol)[0] == SYMBOL_NAME (sym)[0] &&
		  STREQ (SYMBOL_NAME (msymbol) + 1, SYMBOL_NAME (sym) + 1))
d5367 1
a5367 1
		       objfile->name, SYMBOL_NAME (prev));
@


1.55
log
@	* defs.h (streq): Add prototype.
	* utils.c (streq): New function.

	* dwarf2read.c (new_symbol): Use SYMBOL_SET_NAMES instead of
	SYMBOL_NAME and SYMBOL_INIT_DEMANGLED_NAME.
	* mdebugread.c (new_symbol): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* coffread.c (process_coff_symbol): Likewise.
	* dwarfread.c (new_symbol): Likewise.

	* minsyms.c (prim_record_minimal_symbol_and_info): Use
	SYMBOL_SET_NAMES instead of setting SYMBOL_NAME.  Set the language
	here.
	(install_minimal_symbols): Don't set SYMBOL_LANGUAGE or call
	SYMBOL_INIT_DEMANGLED_NAME.
	* objfiles.c: Include "hashtab.h".
	(allocate_objfile): Call htab_set_functions_ex for the
	demangled_names_hash.
	(free_objfile): Call htab_delete for the demangled_names_hash.
	* objfiles.h (struct htab): Add declaration.
	(struct objfile): Add demangled_names_hash.
	* symfile.c: Include "hashtab.h".
	(reread_symbols): Call htab_delete for the demangled_names_hash.
	(add_psymbol_to_list): Use SYMBOL_SET_NAMES instead of putting
	SYMBOL_NAME in the bcache.
	* symtab.c: Include "hashtab.h".  Update comments.
	(create_demangled_names_hash, symbol_set_names): New functions.
	(symbol_find_demangled_name): New function, broken out from
	symbol_init_demangled_names.
	(symbol_init_demangled_names): Use it.
	* symtab.h (SYMBOL_INIT_DEMANGLED_NAME): Add missing parentheses.
	(SYMBOL_SET_NAMES): New macro.
	(symbol_set_names): Add prototype.
@
text
@d1725 1
a1725 1
			       SYMBOL_SOURCE_NAME (sym));
d1741 1
a1741 1
			       SYMBOL_SOURCE_NAME (sym));
d1992 1
a1992 1
			       SYMBOL_SOURCE_NAME (sym));
@


1.54
log
@2003-02-01  Andrew Cagney  <ac131313@@redhat.com>

	* gdbarch.sh: Explictly specify all method levels.  When a
	variable with an empty level, provide a non-multi-arch default.
	(BELIEVE_PCC_PROMOTION_TYPE): Set level to empty.
	* gdbarch.h: Re-generate.
	* stabsread.c (BELIEVE_PCC_PROMOTION_TYPE): Delete.  Always defined.
	* config/m68k/tm-sun3.h (BELIEVE_PCC_PROMOTION_TYPE): Define as 1
@
text
@d1332 1
a1332 7
	    {
	      SYMBOL_NAME (sym) = (char *)
		obstack_alloc (&objfile->symbol_obstack, nlen);
	      strncpy (SYMBOL_NAME (sym), s, nlen);
	      SYMBOL_NAME (sym)[nlen] = '\0';
	      SYMBOL_INIT_DEMANGLED_NAME (sym, &objfile->symbol_obstack);
	    }
d1338 1
a1338 5
	      SYMBOL_NAME (sym) = (char *)
		obstack_alloc (&objfile->symbol_obstack, nlen);
	      strncpy (SYMBOL_NAME (sym), string, nlen);
	      SYMBOL_NAME (sym)[nlen] = '\0';
	      SYMBOL_INIT_DEMANGLED_NAME (sym, &objfile->symbol_obstack);
d1348 1
a1348 23
      SYMBOL_NAME (sym) = (char *)
	obstack_alloc (&objfile->symbol_obstack, ((p - string) + 1));
      /* Open-coded memcpy--saves function call time.  */
      /* FIXME:  Does it really?  Try replacing with simple strcpy and
         try it on an executable with a large symbol table. */
      /* FIXME: considering that gcc can open code memcpy anyway, I
         doubt it.  xoxorich. */
      {
	register char *p1 = string;
	register char *p2 = SYMBOL_NAME (sym);
	while (p1 != p)
	  {
	    *p2++ = *p1++;
	  }
	*p2++ = '\0';
      }

      /* If this symbol is from a C++ compilation, then attempt to cache the
         demangled form for future reference.  This is a typical time versus
         space tradeoff, that was decided in favor of time because it sped up
         C++ symbol lookups by a factor of about 20. */

      SYMBOL_INIT_DEMANGLED_NAME (sym, &objfile->symbol_obstack);
@


1.53
log
@2003-02-01  Andrew Cagney  <ac131313@@redhat.com>

	* main.c (captured_main): Delete #ifdef ADDITIONAL_OPTIONS,
	ADDITIONAL_OPTION_CASES, and ADDITIONAL_OPTION_HANDLER code.
	(print_gdb_help): Delete #ifdef ADDITIONAL_OPTION_HELP code.
	* stabsread.c (DBX_PARM_SYMBOL_CLASS): Delete macro.
	(define_symbol): Update.
	* symfile.c (generic_load): Remove references to nindy.
	* symtab.c: Remove references to nindy.

Index: doc/ChangeLog
2003-02-01  Andrew Cagney  <ac131313@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	description of ADDITIONAL_OPTIONS, ADDITIONAL_OPTION_CASES,
	ADDITIONAL_OPTION_HANDLER, and ADDITIONAL_OPTION_HELP, and
	BEFORE_MAIN_LOOP_HOOK, and DBX_PARM_SYMBOL_CLASS along with
	references to nindy and i960.
	* gdb.texinfo (i960): Delete all references to i960 and nindy.
@
text
@a201 3
#if !defined (BELIEVE_PCC_PROMOTION_TYPE)
#define BELIEVE_PCC_PROMOTION_TYPE 0
#endif
@


1.52
log
@2003-01-18  Andrew Cagney  <ac131313@@redhat.com>

	* cris-tdep.c: Fix function declaration indentation.
	* dwarfread.c, gdbcore.h, gdbtypes.h, i386v-nat.c: Ditto.
	* mips-tdep.c, monitor.h, parse.c, proc-utils.h: Ditto.
	* rs6000-nat.c, ser-go32.c, somread.c, stabsread.c: Ditto.
	* symfile.h, symtab.h, target.c, target.h, value.h: Ditto.
	* xcoffread.c, config/pa/tm-hppa.h: Ditto.
	* config/sparc/tm-sp64.h, config/sparc/tm-sparc.h: Ditto.
@
text
@d1649 1
a1649 7
      /* Normally this is a parameter, a LOC_ARG.  On the i960, it
         can also be a LOC_LOCAL_ARG depending on symbol type.  */
#ifndef DBX_PARM_SYMBOL_CLASS
#define	DBX_PARM_SYMBOL_CLASS(type)	LOC_ARG
#endif

      SYMBOL_CLASS (sym) = DBX_PARM_SYMBOL_CLASS (type);
@


1.51
log
@2003-01-13  Elena Zannoni  <ezannoni@@redhat.com>

	* stabsread.h (process_later, resolve_cfront_continuation):
	Obsolete.
	Update copyright years.
	* buildsym.c (start_subfile): Obsolete comment pertinent to Cfront.
	Update copyright year.
	* dbxread.c(struct cont_elem): Obsolete.
	(process_later, process_now): Obsolete functions.
	(read_dbx_symtab, read_ofile_symtab): Obsolete cfront support.
	Update copyright year.
	* gdbtypes.c (INIT_EXTRA, ADD_EXTRA): Obsolete macros.
	(add_name, add_mangled_type, cfront_mangle_name): Obsolete functions.
	* mdebugread.c (parse_type): Obsolete comment pertinent to Cfront.
	(parse_partial_symbols): Obsolete cfront support.
	* stabsread.c
	(CFRONT_VISIBILITY_PRIVATE,CFRONT_VISIBILITY_PUBLIC): Obsolete
	macros.
	(get_substring, get_cfront_method_physname, msg_unknown_complaint,
	read_cfront_baseclasses, read_cfront_member_functions,
	resolve_cfront_continuation,read_cfront_static_fields,
	copy_cfront_struct_fields): Obsolete functions.
	(define_symbol, read_one_struct_field): Obsolete cfront support.
	* xcoffread.c (scan_xcoff_symtab): Obsolete CFront support.
	Update Copyright year.
@
text
@d137 2
a138 2
static int
attach_fields_to_type (struct field_info *, struct type *, struct objfile *);
d177 2
a178 2
static void
add_live_range (struct objfile *, struct symbol *, CORE_ADDR, CORE_ADDR);
d186 2
a187 2
static int
resolve_symbol_reference (struct objfile *, struct symbol *, char *);
@


1.50
log
@	Fix PR gdb/872.
	* gdbtypes.c (init_type): Mark "char" as TYPE_FLAG_NOSIGN.
	(integer_types_same_name_p): New function.
	(rank_one_type): Use it.
	* stabsread.c (read_range_type): Mark "char" as TYPE_FLAG_NOSIGN.
@
text
@d152 2
d155 16
a170 1
/* new functions added for cfront support */
d172 2
a173 16
static int
copy_cfront_struct_fields (struct field_info *, struct type *,
			   struct objfile *);

static char *get_cfront_method_physname (char *);

static int
read_cfront_baseclasses (struct field_info *, char **,
			 struct type *, struct objfile *);

static int
read_cfront_static_fields (struct field_info *, char **,
			   struct type *, struct objfile *);
static int
read_cfront_member_functions (struct field_info *, char **,
			      struct type *, struct objfile *);
a176 2
/* end new functions added for cfront support */

d499 482
a980 481
#define CFRONT_VISIBILITY_PRIVATE	'2'	/* Stabs character for private field */
#define CFRONT_VISIBILITY_PUBLIC	'1'	/* Stabs character for public field */

/* This code added to support parsing of ARM/Cfront stabs strings */

/* Get substring from string up to char c, advance string pointer past
   suibstring. */

static char *
get_substring (char **p, int c)
{
  char *str;
  str = *p;
  *p = strchr (*p, c);
  if (*p)
    {
      **p = 0;
      (*p)++;
    }
  else
    str = 0;
  return str;
}

/* Physname gets strcat'd onto sname in order to recreate the mangled
   name (see funtion gdb_mangle_name in gdbtypes.c).  For cfront, make
   the physname look like that of g++ - take out the initial mangling
   eg: for sname="a" and fname="foo__1aFPFs_i" return "FPFs_i" */

static char *
get_cfront_method_physname (char *fname)
{
  int len = 0;
  /* FIXME would like to make this generic for g++ too, but 
     that is already handled in read_member_funcctions */
  char *p = fname;

  /* search ahead to find the start of the mangled suffix */
  if (*p == '_' && *(p + 1) == '_')	/* compiler generated; probably a ctor/dtor */
    p += 2;
  while (p && (unsigned) ((p + 1) - fname) < strlen (fname) && *(p + 1) != '_')
    p = strchr (p, '_');
  if (!(p && *p == '_' && *(p + 1) == '_'))
    error ("Invalid mangled function name %s", fname);
  p += 2;			/* advance past '__' */

  /* struct name length and name of type should come next; advance past it */
  while (isdigit (*p))
    {
      len = len * 10 + (*p - '0');
      p++;
    }
  p += len;

  return p;
}

static void
msg_unknown_complaint (const char *arg1)
{
  complaint (&symfile_complaints, "Unsupported token in stabs string %s", arg1);
}

/* Read base classes within cfront class definition.
   eg: A:ZcA;1@@Bpub v2@@Bvirpri;__ct__1AFv func__1AFv *sfunc__1AFv ;as__1A ;;
   ^^^^^^^^^^^^^^^^^^

   A:ZcA;;foopri__1AFv foopro__1AFv __ct__1AFv __ct__1AFRC1A foopub__1AFv ;;;
   ^
 */

static int
read_cfront_baseclasses (struct field_info *fip, char **pp, struct type *type,
			 struct objfile *objfile)
{
  int bnum = 0;
  char *p;
  int i;
  struct nextfield *new;

  if (**pp == ';')		/* no base classes; return */
    {
      ++(*pp);
      return 1;
    }

  /* first count base classes so we can allocate space before parsing */
  for (p = *pp; p && *p && *p != ';'; p++)
    {
      if (*p == ' ')
	bnum++;
    }
  bnum++;			/* add one more for last one */

  /* now parse the base classes until we get to the start of the methods 
     (code extracted and munged from read_baseclasses) */
  ALLOCATE_CPLUS_STRUCT_TYPE (type);
  TYPE_N_BASECLASSES (type) = bnum;

  /* allocate space */
  {
    int num_bytes = B_BYTES (TYPE_N_BASECLASSES (type));
    char *pointer;

    pointer = (char *) TYPE_ALLOC (type, num_bytes);
    TYPE_FIELD_VIRTUAL_BITS (type) = (B_TYPE *) pointer;
  }
  B_CLRALL (TYPE_FIELD_VIRTUAL_BITS (type), TYPE_N_BASECLASSES (type));

  for (i = 0; i < TYPE_N_BASECLASSES (type); i++)
    {
      new = (struct nextfield *) xmalloc (sizeof (struct nextfield));
      make_cleanup (xfree, new);
      memset (new, 0, sizeof (struct nextfield));
      new->next = fip->list;
      fip->list = new;
      FIELD_BITSIZE (new->field) = 0;	/* this should be an unpacked field! */

      STABS_CONTINUE (pp, objfile);

      /* virtual?  eg: v2@@Bvir */
      if (**pp == 'v')
	{
	  SET_TYPE_FIELD_VIRTUAL (type, i);
	  ++(*pp);
	}

      /* access?  eg: 2@@Bvir */
      /* Note: protected inheritance not supported in cfront */
      switch (*(*pp)++)
	{
	case CFRONT_VISIBILITY_PRIVATE:
	  new->visibility = VISIBILITY_PRIVATE;
	  break;
	case CFRONT_VISIBILITY_PUBLIC:
	  new->visibility = VISIBILITY_PUBLIC;
	  break;
	default:
	  /* Bad visibility format.  Complain and treat it as
	     public.  */
	  {
	    complaint (&symfile_complaints,
		       "Unknown visibility `%c' for baseclass",
		       new->visibility);
	    new->visibility = VISIBILITY_PUBLIC;
	  }
	}

      /* "@@" comes next - eg: @@Bvir */
      if (**pp != '@@')
	{
	  msg_unknown_complaint (*pp);
	  return 1;
	}
      ++(*pp);


      /* Set the bit offset of the portion of the object corresponding 
         to this baseclass.  Always zero in the absence of
         multiple inheritance.  */
      /* Unable to read bit position from stabs;
         Assuming no multiple inheritance for now FIXME! */
      /* We may have read this in the structure definition;
         now we should fixup the members to be the actual base classes */
      FIELD_BITPOS (new->field) = 0;

      /* Get the base class name and type */
      {
	char *bname;		/* base class name */
	struct symbol *bsym;	/* base class */
	char *p1, *p2;
	p1 = strchr (*pp, ' ');
	p2 = strchr (*pp, ';');
	if (p1 < p2)
	  bname = get_substring (pp, ' ');
	else
	  bname = get_substring (pp, ';');
	if (!bname || !*bname)
	  {
	    msg_unknown_complaint (*pp);
	    return 1;
	  }
	/* FIXME! attach base info to type */
	bsym = lookup_symbol (bname, 0, STRUCT_NAMESPACE, 0, 0);	/*demangled_name */
	if (bsym)
	  {
	    new->field.type = SYMBOL_TYPE (bsym);
	    new->field.name = type_name_no_tag (new->field.type);
	  }
	else
	  {
	    complaint (&symfile_complaints, "Unable to find base type for %s",
		       *pp);
	    return 1;
	  }
      }

      /* If more base classes to parse, loop again.
         We ate the last ' ' or ';' in get_substring,
         so on exit we will have skipped the trailing ';' */
      /* if invalid, return 0; add code to detect  - FIXME! */
    }
  return 1;
}

/* read cfront member functions.
   pp points to string starting with list of functions
   eg: A:ZcA;1@@Bpub v2@@Bvirpri;__ct__1AFv func__1AFv *sfunc__1AFv ;as__1A ;;
   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 
   A:ZcA;;foopri__1AFv foopro__1AFv __ct__1AFv __ct__1AFRC1A foopub__1AFv ;;;
   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 
 */

static int
read_cfront_member_functions (struct field_info *fip, char **pp,
			      struct type *type, struct objfile *objfile)
{
  /* This code extracted from read_member_functions 
     so as to do the similar thing for our funcs */

  int nfn_fields = 0;
  int length = 0;
  /* Total number of member functions defined in this class.  If the class
     defines two `f' functions, and one `g' function, then this will have
     the value 3.  */
  int total_length = 0;
  int i;
  struct next_fnfield
    {
      struct next_fnfield *next;
      struct fn_field fn_field;
    }
   *sublist;
  struct type *look_ahead_type;
  struct next_fnfieldlist *new_fnlist;
  struct next_fnfield *new_sublist;
  char *main_fn_name;
  char *fname;
  struct symbol *ref_func = 0;

  /* Process each list until we find the end of the member functions.
     eg: p = "__ct__1AFv foo__1AFv ;;;" */

  STABS_CONTINUE (pp, objfile);	/* handle \\ */

  while (**pp != ';' && (fname = get_substring (pp, ' '), fname))
    {
      int is_static = 0;
      int sublist_count = 0;
      char *pname;
      if (fname[0] == '*')	/* static member */
	{
	  is_static = 1;
	  sublist_count++;
	  fname++;
	}
      ref_func = lookup_symbol (fname, 0, VAR_NAMESPACE, 0, 0);		/* demangled name */
      if (!ref_func)
	{
	  complaint (&symfile_complaints,
		     "Unable to find function symbol for %s", fname);
	  continue;
	}
      sublist = NULL;
      look_ahead_type = NULL;
      length = 0;

      new_fnlist = (struct next_fnfieldlist *)
	xmalloc (sizeof (struct next_fnfieldlist));
      make_cleanup (xfree, new_fnlist);
      memset (new_fnlist, 0, sizeof (struct next_fnfieldlist));

      /* The following is code to work around cfront generated stabs.
         The stabs contains full mangled name for each field.
         We try to demangle the name and extract the field name out of it.  */
      {
	char *dem, *dem_p, *dem_args;
	int dem_len;
	dem = cplus_demangle (fname, DMGL_ANSI | DMGL_PARAMS);
	if (dem != NULL)
	  {
	    dem_p = strrchr (dem, ':');
	    if (dem_p != 0 && *(dem_p - 1) == ':')
	      dem_p++;
	    /* get rid of args */
	    dem_args = strchr (dem_p, '(');
	    if (dem_args == NULL)
	      dem_len = strlen (dem_p);
	    else
	      dem_len = dem_args - dem_p;
	    main_fn_name =
	      obsavestring (dem_p, dem_len, &objfile->type_obstack);
	  }
	else
	  {
	    main_fn_name =
	      obsavestring (fname, strlen (fname), &objfile->type_obstack);
	  }
      }				/* end of code for cfront work around */

      new_fnlist->fn_fieldlist.name = main_fn_name;

/*-------------------------------------------------*/
      /* Set up the sublists
         Sublists are stuff like args, static, visibility, etc.
         so in ARM, we have to set that info some other way.
         Multiple sublists happen if overloading
         eg: foo::26=##1;:;2A.;
         In g++, we'd loop here thru all the sublists...  */

      new_sublist =
	(struct next_fnfield *) xmalloc (sizeof (struct next_fnfield));
      make_cleanup (xfree, new_sublist);
      memset (new_sublist, 0, sizeof (struct next_fnfield));

      /* eat 1; from :;2A.; */
      new_sublist->fn_field.type = SYMBOL_TYPE (ref_func);	/* normally takes a read_type */
      /* Make this type look like a method stub for gdb */
      TYPE_FLAGS (new_sublist->fn_field.type) |= TYPE_FLAG_STUB;
      TYPE_CODE (new_sublist->fn_field.type) = TYPE_CODE_METHOD;

      /* If this is just a stub, then we don't have the real name here. */
      if (TYPE_STUB (new_sublist->fn_field.type))
	{
	  if (!TYPE_DOMAIN_TYPE (new_sublist->fn_field.type))
	    TYPE_DOMAIN_TYPE (new_sublist->fn_field.type) = type;
	  new_sublist->fn_field.is_stub = 1;
	}

      /* physname used later in mangling; eg PFs_i,5 for foo__1aFPFs_i 
         physname gets strcat'd in order to recreate the onto mangled name */
      pname = get_cfront_method_physname (fname);
      new_sublist->fn_field.physname = savestring (pname, strlen (pname));


      /* Set this member function's visibility fields. 
         Unable to distinguish access from stabs definition!
         Assuming public for now.  FIXME!
         (for private, set new_sublist->fn_field.is_private = 1,
         for public, set new_sublist->fn_field.is_protected = 1) */

      /* Unable to distinguish const/volatile from stabs definition!
         Assuming normal for now.  FIXME! */

      new_sublist->fn_field.is_const = 0;
      new_sublist->fn_field.is_volatile = 0;	/* volatile not implemented in cfront */

      /* Set virtual/static function info
         How to get vtable offsets ? 
         Assuming normal for now FIXME!! 
         For vtables, figure out from whence this virtual function came.
         It may belong to virtual function table of
         one of its baseclasses.
         set:
         new_sublist -> fn_field.voffset = vtable offset,
         new_sublist -> fn_field.fcontext = look_ahead_type;
         where look_ahead_type is type of baseclass */
      if (is_static)
	new_sublist->fn_field.voffset = VOFFSET_STATIC;
      else			/* normal member function.  */
	new_sublist->fn_field.voffset = 0;
      new_sublist->fn_field.fcontext = 0;


      /* Prepare new sublist */
      new_sublist->next = sublist;
      sublist = new_sublist;
      length++;

      /* In g++, we loop thu sublists - now we set from functions. */
      new_fnlist->fn_fieldlist.fn_fields = (struct fn_field *)
	obstack_alloc (&objfile->type_obstack,
		       sizeof (struct fn_field) * length);
      memset (new_fnlist->fn_fieldlist.fn_fields, 0,
	      sizeof (struct fn_field) * length);
      for (i = length; (i--, sublist); sublist = sublist->next)
	{
	  new_fnlist->fn_fieldlist.fn_fields[i] = sublist->fn_field;
	}

      new_fnlist->fn_fieldlist.length = length;
      new_fnlist->next = fip->fnlist;
      fip->fnlist = new_fnlist;
      nfn_fields++;
      total_length += length;
      STABS_CONTINUE (pp, objfile);	/* handle \\ */
    }				/* end of loop */

  if (nfn_fields)
    {
      /* type should already have space */
      TYPE_FN_FIELDLISTS (type) = (struct fn_fieldlist *)
	TYPE_ALLOC (type, sizeof (struct fn_fieldlist) * nfn_fields);
      memset (TYPE_FN_FIELDLISTS (type), 0,
	      sizeof (struct fn_fieldlist) * nfn_fields);
      TYPE_NFN_FIELDS (type) = nfn_fields;
      TYPE_NFN_FIELDS_TOTAL (type) = total_length;
    }

  /* end of scope for reading member func */

  /* eg: ";;" */

  /* Skip trailing ';' and bump count of number of fields seen */
  if (**pp == ';')
    (*pp)++;
  else
    return 0;
  return 1;
}

/* This routine fixes up partial cfront types that were created
   while parsing the stabs.  The main need for this function is
   to add information such as methods to classes.
   Examples of "p": "sA;;__ct__1AFv foo__1AFv ;;;" */
int
resolve_cfront_continuation (struct objfile *objfile, struct symbol *sym,
			     char *p)
{
  struct symbol *ref_sym = 0;
  char *sname;
  /* snarfed from read_struct_type */
  struct field_info fi;
  struct type *type;
  struct cleanup *back_to;

  /* Need to make sure that fi isn't gunna conflict with struct 
     in case struct already had some fnfs */
  fi.list = NULL;
  fi.fnlist = NULL;
  back_to = make_cleanup (null_cleanup, 0);

  /* We only accept structs, classes and unions at the moment. 
     Other continuation types include t (typedef), r (long dbl), ... 
     We may want to add support for them as well; 
     right now they are handled by duplicating the symbol information 
     into the type information (see define_symbol) */
  if (*p != 's'			/* structs */
      && *p != 'c'		/* class */
      && *p != 'u')		/* union */
    return 0;			/* only handle C++ types */
  p++;

  /* Get symbol typs name and validate 
     eg: p = "A;;__ct__1AFv foo__1AFv ;;;" */
  sname = get_substring (&p, ';');
  if (!sname || strcmp (sname, SYMBOL_NAME (sym)))
    error ("Internal error: base symbol type name does not match\n");

  /* Find symbol's internal gdb reference using demangled_name.
     This is the real sym that we want; 
     sym was a temp hack to make debugger happy */
  ref_sym = lookup_symbol (SYMBOL_NAME (sym), 0, STRUCT_NAMESPACE, 0, 0);
  type = SYMBOL_TYPE (ref_sym);


  /* Now read the baseclasses, if any, read the regular C struct or C++
     class member fields, attach the fields to the type, read the C++
     member functions, attach them to the type, and then read any tilde
     field (baseclass specifier for the class holding the main vtable). */

  if (!read_cfront_baseclasses (&fi, &p, type, objfile)
  /* g++ does this next, but cfront already did this: 
     || !read_struct_fields (&fi, &p, type, objfile) */
      || !copy_cfront_struct_fields (&fi, type, objfile)
      || !read_cfront_member_functions (&fi, &p, type, objfile)
      || !read_cfront_static_fields (&fi, &p, type, objfile)
      || !attach_fields_to_type (&fi, type, objfile)
      || !attach_fn_fields_to_type (&fi, type)
  /* g++ does this next, but cfront doesn't seem to have this: 
     || !read_tilde_fields (&fi, &p, type, objfile) */
    )
    {
      type = error_type (&p, objfile);
    }

  do_cleanups (back_to);
  return 0;
}
/* End of code added to support parsing of ARM/Cfront stabs strings */

d1953 9
a1961 7
      /* The semantics of C++ state that "struct foo { ... }" also defines 
         a typedef for "foo".  Unfortunately, cfront never makes the typedef
         when translating C++ into C.  We make the typedef here so that
         "ptype foo" works as expected for cfront translated code.  */
      else if ((current_subfile->language == language_cplus)
	       || (current_subfile->language == language_objc))
	synonym = 1;
d1964 1
a1964 1

d2051 26
a2076 25

      /* New code added to support cfront stabs strings.
         Note: case 'P' already handled above */
    case 'Z':
      /* Cfront type continuation coming up!
         Find the original definition and add to it.
         We'll have to do this for the typedef too,
         since we cloned the symbol to define a type in read_type.
         Stabs info examples:
         __1C :Ztl 
         foo__1CFv :ZtF (first def foo__1CFv:F(0,3);(0,24))
         C:ZsC;;__ct__1CFv func1__1CFv func2__1CFv ... ;;;
         where C is the name of the class.
         Unfortunately, we can't lookup the original symbol yet 'cuz 
         we haven't finished reading all the symbols.
         Instead, we save it for processing later */
      process_later (sym, p, resolve_cfront_continuation);
      SYMBOL_TYPE (sym) = error_type (&p, objfile);	/* FIXME! change later */
      SYMBOL_CLASS (sym) = LOC_CONST;
      SYMBOL_VALUE (sym) = 0;
      SYMBOL_NAMESPACE (sym) = VAR_NAMESPACE;
      /* Don't add to list - we'll delete it later when 
         we add the continuation to the real sym */
      return sym;
      /* End of new code added to support cfront stabs strings */
d3598 28
a3625 27
  /* The following is code to work around cfront generated stabs.
     The stabs contains full mangled name for each field.
     We try to demangle the name and extract the field name out of it.
   */
  if (ARM_DEMANGLING && current_subfile->language == language_cplus)
    {
      char save_p;
      char *dem, *dem_p;
      save_p = *p;
      *p = '\0';
      dem = cplus_demangle (*pp, DMGL_ANSI | DMGL_PARAMS);
      if (dem != NULL)
	{
	  dem_p = strrchr (dem, ':');
	  if (dem_p != 0 && *(dem_p - 1) == ':')
	    dem_p++;
	  FIELD_NAME (fip->list->field) =
	    obsavestring (dem_p, strlen (dem_p), &objfile->type_obstack);
	}
      else
	{
	  FIELD_NAME (fip->list->field) =
	    obsavestring (*pp, p - *pp, &objfile->type_obstack);
	}
      *p = save_p;
    }
  /* end of code for cfront work around */
d3627 2
a3628 1
  else
d4081 131
a4211 129
/* read cfront class static data.
   pp points to string starting with the list of static data
   eg: A:ZcA;1@@Bpub v2@@Bvirpri;__ct__1AFv func__1AFv *sfunc__1AFv ;as__1A ;;
   ^^^^^^^^

   A:ZcA;;foopri__1AFv foopro__1AFv __ct__1AFv __ct__1AFRC1A foopub__1AFv ;;;
   ^
 */

static int
read_cfront_static_fields (struct field_info *fip, char **pp, struct type *type,
			   struct objfile *objfile)
{
  struct nextfield *new;
  struct type *stype;
  char *sname;
  struct symbol *ref_static = 0;

  if (**pp == ';')		/* no static data; return */
    {
      ++(*pp);
      return 1;
    }

  /* Process each field in the list until we find the terminating ";" */

  /* eg: p = "as__1A ;;;" */
  STABS_CONTINUE (pp, objfile);	/* handle \\ */
  while (**pp != ';' && (sname = get_substring (pp, ' '), sname))
    {
      ref_static = lookup_symbol (sname, 0, VAR_NAMESPACE, 0, 0);	/*demangled_name */
      if (!ref_static)
	{
	  complaint (&symfile_complaints,
		     "Unable to find symbol for static data field %s", sname);
	  continue;
	}
      stype = SYMBOL_TYPE (ref_static);

      /* allocate a new fip */
      new = (struct nextfield *) xmalloc (sizeof (struct nextfield));
      make_cleanup (xfree, new);
      memset (new, 0, sizeof (struct nextfield));
      new->next = fip->list;
      fip->list = new;

      /* set visibility */
      /* FIXME! no way to tell visibility from stabs??? */
      new->visibility = VISIBILITY_PUBLIC;

      /* set field info into fip */
      fip->list->field.type = stype;

      /* set bitpos & bitsize */
      SET_FIELD_PHYSNAME (fip->list->field, savestring (sname, strlen (sname)));

      /* set name field */
      /* The following is code to work around cfront generated stabs.
         The stabs contains full mangled name for each field.
         We try to demangle the name and extract the field name out of it.
       */
      if (ARM_DEMANGLING)
	{
	  char *dem, *dem_p;
	  dem = cplus_demangle (sname, DMGL_ANSI | DMGL_PARAMS);
	  if (dem != NULL)
	    {
	      dem_p = strrchr (dem, ':');
	      if (dem_p != 0 && *(dem_p - 1) == ':')
		dem_p++;
	      fip->list->field.name =
		obsavestring (dem_p, strlen (dem_p), &objfile->type_obstack);
	    }
	  else
	    {
	      fip->list->field.name =
		obsavestring (sname, strlen (sname), &objfile->type_obstack);
	    }
	}			/* end of code for cfront work around */
    }				/* loop again for next static field */
  return 1;
}

/* Copy structure fields to fip so attach_fields_to_type will work.
   type has already been created with the initial instance data fields.
   Now we want to be able to add the other members to the class,
   so we want to add them back to the fip and reattach them again
   once we have collected all the class members. */

static int
copy_cfront_struct_fields (struct field_info *fip, struct type *type,
			   struct objfile *objfile)
{
  int nfields = TYPE_NFIELDS (type);
  int i;
  struct nextfield *new;

  /* Copy the fields into the list of fips and reset the types 
     to remove the old fields */

  for (i = 0; i < nfields; i++)
    {
      /* allocate a new fip */
      new = (struct nextfield *) xmalloc (sizeof (struct nextfield));
      make_cleanup (xfree, new);
      memset (new, 0, sizeof (struct nextfield));
      new->next = fip->list;
      fip->list = new;

      /* copy field info into fip */
      new->field = TYPE_FIELD (type, i);
      /* set visibility */
      if (TYPE_FIELD_PROTECTED (type, i))
	new->visibility = VISIBILITY_PROTECTED;
      else if (TYPE_FIELD_PRIVATE (type, i))
	new->visibility = VISIBILITY_PRIVATE;
      else
	new->visibility = VISIBILITY_PUBLIC;
    }
  /* Now delete the fields from the type since we will be 
     allocing new space once we get the rest of the fields 
     in attach_fields_to_type.
     The pointer TYPE_FIELDS(type) is left dangling but should 
     be freed later by objstack_free */
  TYPE_FIELDS (type) = 0;
  TYPE_NFIELDS (type) = 0;

  return 1;
}
@


1.49
log
@	* stabsread.c (update_method_name_from_physname): Call complaint()
	instead of error.
@
text
@d4933 1
a4933 1
    return init_type (TYPE_CODE_INT, 1, 0, NULL, objfile);
@


1.48
log
@gdb/
	* buildsym.h (processing_hp_compilation): Remove obsolete variable.
	* gdbarch.sh Remove include of "value.h" in gdbarch.h.
	(COERCE_FLOAT_TO_DOUBLE): Remove.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* Makefile.in: Remove value_h from gdbarch_h.
	* valops.c (coerce_float_to_double): New variable.
	(default_coerce_float_to_double): Remove.
	(standard_coerce_float_to_double): Remove.
	(value_arg_coerce): Use coerce_float_to_double.
	(_initialize_valops): Add "set coerce-float-to-double".
	* value.h (default_coerce_float_to_double): Remove prototype.
	(standard_coerce_float_to_double): Remove prototype.

	* hpread.c (hpread_process_one_debug_symbol): Mark C++ functions as
	prototyped.
	* mdebugread.c (parse_symbol): Likewise.
	* stabsread.c (define_symbol): Mark all functions as prototyped.

	* hppa-tdep.c (hppa_coerce_float_to_double): Remove.
	* alpha-tdep.c (alpha_gdbarch_init): Remove call to
	set_gdbarch_coerce_float_to_double.
	* arm-tdep.c (arm_gdbarch_init): Likewise.
	* frv-tdep.c (frv_gdbarch_init): Likewise.
	* h8300-tdep.c (h8300_gdbarch_init): Likewise (commented out).
	* i386-sol2-tdep.c (i386_sol2_init_abi): Likewise.
	* mips-tdep.c (mips_gdbarch_init): Likewise.
	(mips_coerce_float_to_double): Remove.
	* rs6000-tdep.c (rs6000_gdbarch_init): Likewise.
	(rs6000_coerce_float_to_double): Remove.
	* s390-tdep.c (s390_gdbarch_init): Likewise.
	* sh-tdep.c (sh_gdbarch_init): Likewise.
	(sh_coerce_float_to_double): Remove.
	* sparc-tdep.c (sparc_gdbarch_init): Likewise.
	(sparc_coerce_float_to_double): Remove.
	* v850-tdep.c (v850_gdbarch_init): Likewise.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Likewise.
	* config/m32r/tm-m32r.h (COERCE_FLOAT_TO_DOUBLE): Remove.
	* config/pa/tm-hppa.h: (COERCE_FLOAT_TO_DOUBLE): Remove.
	(hppa_coerce_float_to_double): Remove prototype.
	* config/sparc/tm-sparc.h (COERCE_FLOAT_TO_DOUBLE): Remove.
doc/
	* gdb.texinfo (Controlling GDB): Add ABI section.  Document
	"set coerce-float-to-double".
	* gdbint.texinfo (COERCE_FLOAT_TO_DOUBLE): Remove documentation.
testsuite/
	* gdb.base/callfuncs.exp: Don't XFAIL unprototyped functions for
	stabs.
	* gdb.base/completion.exp: Allow marker1(void) as well as marker1().
	* gdb.base/whatis.exp: Always allow (void) after function names.
@
text
@d2988 5
a2992 1
    error ("bad physname %s\n", physname);
@


1.47
log
@2003-01-02  Andrew Cagney  <ac131313@@redhat.com>

	* valarith.c (value_binop): Delete obsolete code and comments.
	* configure.host: Ditto.
	* buildsym.h (make_blockvector): Ditto.
	* buildsym.c (make_blockvector): Ditto.
	* defs.h (enum language): Ditto.
	(chill_demangle): Ditto.
	* elfread.c (elf_symtab_read): Ditto.
	* dwarfread.c (CHILL_PRODUCER): Ditto.
	(set_cu_language): Ditto.
	(handle_producer): Ditto.
	* expprint.c (print_subexp): Ditto.
	* gdbtypes.c (chill_varying_type): Ditto.
	* gdbtypes.h (builtin_type_chill_bool): Ditto.
	(builtin_type_chill_char, builtin_type_chill_long): Ditto.
	(builtin_type_chill_ulong, builtin_type_chill_real): Ditto.
	(chill_varying_type): Ditto.
	* language.h (_LANG_chill): Ditto.
	* language.c (binop_result_type, integral_type): Ditto.
	(character_type, string_type, structured_type): Ditto.
	(lang_bool_type, binop_type_check): Ditto.
	* stabsread.h (os9k_stabs): Ditto.
	* stabsread.c (os9k_type_vector, dbx_lookup_type): Ditto.
	(define_symbol, read_type, read_struct_fields): Ditto.
	(read_array_type, read_enum_type, read_huge_number): Ditto.
	(read_range_type, start_stabs): Ditto.
	* symfile.c (init_filename_language_table): Ditto.
	(add_psymbol_with_dem_name_to_list): Ditto.
	* symtab.c (symbol_init_language_specific): Ditto.
	(symbol_init_demangled_name, symbol_demangled_name): Ditto.
	* symtab.h (struct general_symbol_info): Ditto.
	(SYMBOL_CHILL_DEMANGLED_NAME): Ditto.
	* typeprint.c (typedef_print): Ditto.
	* utils.c (fprintf_symbol_filtered): Ditto.
	* valops.c (value_cast, search_struct_field, value_slice): Delete
	obsolete code.
	(varying_to_slice): Delete function.
	* value.h (COERCE_VARYING_ARRAY): Delete obsolete macro contents.
	(varying_to_slice): Delete declaration.
	* MAINTAINERS: Update.
@
text
@d3 1
a3 1
   1996, 1997, 1998, 1999, 2000, 2001, 2002
d1536 7
a1542 3
      /* All functions in C++ have prototypes.  */
      if (SYMBOL_LANGUAGE (sym) == language_cplus)
	TYPE_FLAGS (SYMBOL_TYPE (sym)) |= TYPE_FLAG_PROTOTYPED;
@


1.46
log
@Replace complain() with complaint().
@
text
@a244 30
#if 0 /* OBSOLETE OS9K */
// OBSOLETE /* FIXME: These probably should be our own types (like rs6000_builtin_type
// OBSOLETE    has its own types) rather than builtin_type_*.  */
// OBSOLETE static struct type **os9k_type_vector[] =
// OBSOLETE {
// OBSOLETE   0,
// OBSOLETE   &builtin_type_int,
// OBSOLETE   &builtin_type_char,
// OBSOLETE   &builtin_type_long,
// OBSOLETE   &builtin_type_short,
// OBSOLETE   &builtin_type_unsigned_char,
// OBSOLETE   &builtin_type_unsigned_short,
// OBSOLETE   &builtin_type_unsigned_long,
// OBSOLETE   &builtin_type_unsigned_int,
// OBSOLETE   &builtin_type_float,
// OBSOLETE   &builtin_type_double,
// OBSOLETE   &builtin_type_void,
// OBSOLETE   &builtin_type_long_double
// OBSOLETE };
// OBSOLETE
// OBSOLETE static void os9k_init_type_vector (struct type **);
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE os9k_init_type_vector (struct type **tv)
// OBSOLETE {
// OBSOLETE   unsigned int i;
// OBSOLETE   for (i = 0; i < sizeof (os9k_type_vector) / sizeof (struct type **); i++)
// OBSOLETE     tv[i] = (os9k_type_vector[i] == 0 ? 0 : *(os9k_type_vector[i]));
// OBSOLETE }
#endif /* OBSOLETE OS9K */
a308 6

#if 0 /* OBSOLETE OS9K */
// OBSOLETE 	  if (os9k_stabs)
// OBSOLETE 	    /* Deal with OS9000 fundamental types.  */
// OBSOLETE 	    os9k_init_type_vector (type_vector);
#endif /* OBSOLETE OS9K */
a2003 5
#if 0 /* OBSOLETE OS9K */
// OBSOLETE       if (os9k_stabs)
// OBSOLETE 	add_symbol_to_list (sym, &global_symbols);
// OBSOLETE       else
#endif /* OBSOLETE OS9K */
a2536 18
#if 0 /* OBSOLETE OS9K */
// OBSOLETE       if (os9k_stabs && **pp == '(')
// OBSOLETE 	{
// OBSOLETE 	  /* Function prototype; parse it.
// OBSOLETE 	     We must conditionalize this on os9k_stabs because otherwise
// OBSOLETE 	     it could be confused with a Sun-style (1,3) typenumber
// OBSOLETE 	     (I think).  */
// OBSOLETE 	  struct type *t;
// OBSOLETE 	  ++*pp;
// OBSOLETE 	  while (**pp != ')')
// OBSOLETE 	    {
// OBSOLETE 	      t = read_type (pp, objfile);
// OBSOLETE 	      if (**pp == ',')
// OBSOLETE 		++ * pp;
// OBSOLETE 	    }
// OBSOLETE 	}
#endif /* OBSOLETE OS9K */

a2614 12
#if 0 /* OBSOLETE OS9K */
// OBSOLETE       /* ezannoni 2002-07-16: This can be safely deleted, because 'c'
// OBSOLETE 	 means complex type in AIX stabs, while it means const qualifier
// OBSOLETE 	 in os9k stabs.  Obviously we were supporting only the os9k meaning.
// OBSOLETE 	 We were erroring out if we were reading AIX stabs.  Right now the
// OBSOLETE 	 erroring out will happen in the default clause of the switch.  */
// OBSOLETE     case 'c':			/* Const qualifier on some type (OS9000) */
// OBSOLETE       /* Because 'c' means other things to AIX and 'k' is perfectly good,
// OBSOLETE          only accept 'c' in the os9k_stabs case.  */
// OBSOLETE       if (type_descriptor == 'c' && !os9k_stabs)
// OBSOLETE 	return error_type (pp, objfile);
#endif /* OBSOLETE OS9K */
a2620 12
#if 0 /* OBSOLETE OS9K */
// OBSOLETE       /* ezannoni 2002-07-16: This can be safely deleted, because 'i'
// OBSOLETE 	 means imported type in AIX stabs, while it means volatile qualifier
// OBSOLETE 	 in os9k stabs.  Obviously we were supporting only the os9k meaning.
// OBSOLETE 	 We were erroring out if we were reading AIX stabs.  Right now the
// OBSOLETE 	 erroring out will happen in the default clause of the switch.  */
// OBSOLETE     case 'i':			/* Volatile qual on some type (OS9000) */
// OBSOLETE       /* Because 'i' means other things to AIX and 'B' is perfectly good,
// OBSOLETE          only accept 'i' in the os9k_stabs case.  */
// OBSOLETE       if (type_descriptor == 'i' && !os9k_stabs)
// OBSOLETE 	return error_type (pp, objfile);
#endif /* OBSOLETE OS9K */
a2726 6
#if 0 /* OBSOLETE OS9K */
// OBSOLETE       if (os9k_stabs)
// OBSOLETE 	/* Const and volatile qualified type.  */
// OBSOLETE 	type = read_type (pp, objfile);
// OBSOLETE       else
#endif /* OBSOLETE OS9K */
a3766 4
#if 0 /* OBSOLETE OS9K */
// OBSOLETE       if (os9k_stabs && **pp == ',')
// OBSOLETE 	break;
#endif /* OBSOLETE OS9K */
d3811 3
a3813 3
      /* (OBSOLETE) chill (OBSOLETE) the list of fields: the last
         entry (at the head) is a partially constructed entry which we
         now scrub. */
a4419 5
#if 0 /* OBSOLETE OS9K */
// OBSOLETE   if (os9k_stabs)
// OBSOLETE     index_type = builtin_type_int;
// OBSOLETE   else
#endif /* OBSOLETE OS9K */
a4432 3
#if 0 /* OBSOLETE OS9K */
// OBSOLETE   lower = read_huge_number (pp, os9k_stabs ? ',' : ';', &nbits);
#else /* OBSOLETE OS9K */
a4433 1
#endif /* OBSOLETE OS9K */
a4493 12
#if 0 /* OBSOLETE OS9K */
// OBSOLETE   if (os9k_stabs)
// OBSOLETE     {
// OBSOLETE       /* Size.  Perhaps this does not have to be conditionalized on
// OBSOLETE          os9k_stabs (assuming the name of an enum constant can't start
// OBSOLETE          with a digit).  */
// OBSOLETE       read_huge_number (pp, 0, &nbits);
// OBSOLETE       if (nbits != 0)
// OBSOLETE 	return error_type (pp, objfile);
// OBSOLETE     }
#endif /* OBSOLETE OS9K */

d4731 1
a4731 6
#if 0 /* OBSOLETE OS9K */
// OBSOLETE   if (os9k_stabs)
// OBSOLETE     upper_limit = ULONG_MAX / radix;
// OBSOLETE   else
#endif /* OBSOLETE OS9K */
    upper_limit = LONG_MAX / radix;
a4926 6
#if 0
  /* OBSOLETE else if (current_symbol && SYMBOL_LANGUAGE (current_symbol) == language_chill */
  /* OBSOLETE          && !self_subrange) */
  /* OBSOLETE   goto handle_true_range; */
#endif

a5430 4

#if 0 /* OBSOLETE OS9K */
// OBSOLETE   os9k_stabs = 0;
#endif /* OBSOLETE OS9K */
@


1.45
log
@2002-10-25  Andrew Cagney  <cagney@@redhat.com>

	* complaints.h (struct deprecated_complaint): Rename `struct
	complaint'.
	* complaints.c (complain): Update.
	* remote-vx68.c, remote-vxmips.c, remote-vxsparc.c: Delete
	incorrect comment indicating that "symfile.h" was being included
	for the `struct complaint' definition.
	* remote-vx.c: Update.
	* objc-lang.c: Update.
	* xcoffread.c: Update.
	* hpread.c: Update.
	* mdebugread.c: Update.
	* stabsread.c: Update.
	* dwarf2read.c: Update.
	* dwarfread.c: Update.
	* elfread.c: Update.
	* coffread.c: Update.
	* stabsread.h: Update.
	* dbxread.c: Update.
	* buildsym.c: Update.
	* gdbtypes.c: Update.
	* macrotab.c: Update.
@
text
@d205 5
a209 2
static struct deprecated_complaint invalid_cpp_abbrev_complaint =
{"invalid C++ abbreviation `%s'", 0, 0};
d211 7
a217 2
static struct deprecated_complaint invalid_cpp_type_complaint =
{"C++ abbreviated type name unknown at symtab pos %d", 0, 0};
d219 5
a223 2
static struct deprecated_complaint member_fn_complaint =
{"member function type missing, got '%c'", 0, 0};
d225 5
a229 32
static struct deprecated_complaint const_vol_complaint =
{"const/volatile indicator missing, got '%c'", 0, 0};

static struct deprecated_complaint error_type_complaint =
{"couldn't parse type; debugger out of date?", 0, 0};

static struct deprecated_complaint invalid_member_complaint =
{"invalid (minimal) member type data format at symtab pos %d.", 0, 0};

static struct deprecated_complaint range_type_base_complaint =
{"base type %d of range type is not defined", 0, 0};

static struct deprecated_complaint reg_value_complaint =
{"register number %d too large (max %d) in symbol %s", 0, 0};

static struct deprecated_complaint vtbl_notfound_complaint =
{"virtual function table pointer not found when defining class `%s'", 0, 0};

static struct deprecated_complaint unrecognized_cplus_name_complaint =
{"Unknown C++ symbol name `%s'", 0, 0};

static struct deprecated_complaint rs6000_builtin_complaint =
{"Unknown builtin type %d", 0, 0};

static struct deprecated_complaint unresolved_sym_chain_complaint =
{"%s: common block `%s' from global_sym_chain unresolved", 0, 0};

static struct deprecated_complaint stabs_general_complaint =
{"%s", 0, 0};

static struct deprecated_complaint lrs_general_complaint =
{"%s", 0, 0};
d298 3
a300 5
      static struct deprecated_complaint msg =
      {"\
Invalid symbol data: type number (%d,%d) out of range at symtab pos %d.",
       0, 0};
      complain (&msg, filenum, index, symnum);
d591 6
a608 8
  static struct deprecated_complaint msg_unknown =
  {"\
	 Unsupported token in stabs string %s.\n",
   0, 0};
  static struct deprecated_complaint msg_notfound =
  {"\
	           Unable to find base type for %s.\n",
   0, 0};
d675 3
a677 4
	    static struct deprecated_complaint msg =
	    {
	      "Unknown visibility `%c' for baseclass", 0, 0};
	    complain (&msg, new->visibility);
d685 1
a685 1
	  complain (&msg_unknown, *pp);
d713 1
a713 1
	    complain (&msg_unknown, *pp);
d725 2
a726 1
	    complain (&msg_notfound, *pp);
d793 2
a794 5
	  static struct deprecated_complaint msg =
	  {"\
      		Unable to find function symbol for %s\n",
	   0, 0};
	  complain (&msg, fname);
d1050 1
a1050 1
      complain (&lrs_general_complaint, "symbol for reference not found");
d1086 1
a1086 1
      complain (&lrs_general_complaint, "Unable to allocate alias list memory");
d1341 2
a1342 1
	  complain (&unrecognized_cplus_name_complaint, string);
d1794 3
a1796 3
	  complain (&reg_value_complaint, SYMBOL_VALUE (sym),
		    NUM_REGS + NUM_PSEUDO_REGS,
		    SYMBOL_SOURCE_NAME (sym));
d1810 3
a1812 3
	  complain (&reg_value_complaint, SYMBOL_VALUE (sym),
		    NUM_REGS + NUM_PSEUDO_REGS,
		    SYMBOL_SOURCE_NAME (sym));
d2064 3
a2066 3
	  complain (&reg_value_complaint, SYMBOL_VALUE (sym),
		    NUM_REGS + NUM_PSEUDO_REGS,
		    SYMBOL_SOURCE_NAME (sym));
d2161 1
a2161 1
	      complain (&lrs_general_complaint, "live range format not recognized");
d2182 1
a2182 1
      complain (&lrs_general_complaint, "live range string 1");
d2189 1
a2189 1
      complain (&lrs_general_complaint, "live range string 2");
d2202 1
a2202 1
      complain (&lrs_general_complaint, "Live range symbol not found 1");
d2208 1
a2208 1
      complain (&lrs_general_complaint, "live range string 3");
d2221 1
a2221 1
      complain (&lrs_general_complaint, "Live range symbol not found 2");
d2227 1
a2227 1
      complain (&lrs_general_complaint, "live range string 4");
d2249 1
a2249 1
      complain (&lrs_general_complaint, "end of live range follows start");
d2306 1
a2306 1
  complain (&error_type_complaint);
d2416 2
a2417 3
		static struct deprecated_complaint msg =
		{"Unrecognized cross-reference type `%c'", 0, 0};
		complain (&msg, (*pp)[0]);
d2640 3
a2642 5
            static struct deprecated_complaint msg = {
              "Prototyped function type didn't end arguments with `#':\n%s",
              0, 0
            };
            complain (&msg, type_start);
d2775 3
a2777 1
	    complain (&invalid_member_complaint, symnum);
d2910 1
a2910 1
      complain (&rs6000_builtin_complaint, typenum);
d3268 2
a3269 1
	      complain (&const_vol_complaint, **pp);
d3351 2
a3352 1
	      complain (&member_fn_complaint, (*pp)[-1]);
d3617 3
a3619 1
	      complain (&invalid_cpp_type_complaint, symnum);
d3627 1
a3627 1
	  complain (&invalid_cpp_abbrev_complaint, *pp);
d3640 1
a3640 1
	  complain (&invalid_cpp_abbrev_complaint, *pp);
d3661 1
a3661 1
      complain (&invalid_cpp_abbrev_complaint, *pp);
d3745 1
a3745 1
      complain (&stabs_general_complaint, "bad structure-type format");
d3756 1
a3756 1
	complain (&stabs_general_complaint, "bad structure-type format");
d3762 1
a3762 1
	complain (&stabs_general_complaint, "bad structure-type format");
d4002 2
a4003 4
	    static struct deprecated_complaint msg =
	    {
	      "Unknown virtual character `%c' for baseclass", 0, 0};
	    complain (&msg, **pp);
d4019 3
a4021 5
	    static struct deprecated_complaint msg =
	    {
	      "Unknown visibility `%c' for baseclass", 0, 0
	    };
	    complain (&msg, new->visibility);
d4127 3
a4129 1
	      complain (&vtbl_notfound_complaint, TYPE_NAME (type));
d4192 2
a4193 5
	  static struct deprecated_complaint msg =
	  {"\
      		Unable to find symbol for static data field %s\n",
	   0, 0};
	  complain (&msg, sname);
d4368 2
a4369 4
	    static struct deprecated_complaint msg =
	    {
	      "Unknown visibility `%c' for field", 0, 0};
	    complain (&msg, fip->list->visibility);
a4378 4
static struct deprecated_complaint multiply_defined_struct =
{"struct/union type gets multiply defined: %s%s", 0, 0};


d4409 2
a4410 1
  complain (&multiply_defined_struct, kind, name);
d5112 2
a5113 1
      complain (&range_type_base_complaint, rangenums[1]);
d5189 2
a5190 5
      static struct deprecated_complaint msg =
      {
	"Invalid symbol data: common block within common block",
	0, 0};
      complain (&msg);
d5216 1
a5216 3
      static struct deprecated_complaint msg =
      {"ECOMM symbol unmatched by BCOMM", 0, 0};
      complain (&msg);
d5329 1
a5329 3
		    static struct deprecated_complaint msg =
		    {"need a type name", 0, 0};
		    complain (&msg);
d5352 3
a5354 4
	    static struct deprecated_complaint msg =
	    {"\
GDB internal error.  cleanup_undefined_types with bad type %d.", 0, 0};
	    complain (&msg, TYPE_CODE (*type));
d5514 3
a5516 2
	    complain (&unresolved_sym_chain_complaint,
		      objfile->name, SYMBOL_NAME (prev));
@


1.44
log
@stabsread.c (find_name_end): New function.
(define_symbol): Use it.
@
text
@d205 1
a205 1
static struct complaint invalid_cpp_abbrev_complaint =
d208 1
a208 1
static struct complaint invalid_cpp_type_complaint =
d211 1
a211 1
static struct complaint member_fn_complaint =
d214 1
a214 1
static struct complaint const_vol_complaint =
d217 1
a217 1
static struct complaint error_type_complaint =
d220 1
a220 1
static struct complaint invalid_member_complaint =
d223 1
a223 1
static struct complaint range_type_base_complaint =
d226 1
a226 1
static struct complaint reg_value_complaint =
d229 1
a229 1
static struct complaint vtbl_notfound_complaint =
d232 1
a232 1
static struct complaint unrecognized_cplus_name_complaint =
d235 1
a235 1
static struct complaint rs6000_builtin_complaint =
d238 1
a238 1
static struct complaint unresolved_sym_chain_complaint =
d241 1
a241 1
static struct complaint stabs_general_complaint =
d244 1
a244 1
static struct complaint lrs_general_complaint =
d314 1
a314 1
      static struct complaint msg =
d621 1
a621 1
  static struct complaint msg_unknown =
d625 1
a625 1
  static struct complaint msg_notfound =
d695 1
a695 1
	    static struct complaint msg =
d813 1
a813 1
	  static struct complaint msg =
d2438 1
a2438 1
		static struct complaint msg =
d2663 1
a2663 1
            static struct complaint msg = {
d4021 1
a4021 1
	    static struct complaint msg =
d4040 1
a4040 1
	    static struct complaint msg =
d4213 1
a4213 1
	  static struct complaint msg =
d4392 1
a4392 1
	    static struct complaint msg =
d4405 1
a4405 1
static struct complaint multiply_defined_struct =
d5217 1
a5217 1
      static struct complaint msg =
d5247 1
a5247 1
      static struct complaint msg =
d5362 1
a5362 1
		    static struct complaint msg =
d5387 1
a5387 1
	    static struct complaint msg =
@


1.43
log
@2002-10-16  Klee Dienes  <kdienes@@apple.com>

        * stabsread.c (read_tilde_fields): Use name[sizeof(vptr_name)-2]
        to get the last character of a char[] buffer, not
        name[sizeof(vptr_name)-1].
@
text
@d172 2
d1276 1
a1276 1
  char *p = (char *) strchr (string, ':');
d2009 2
a2010 1
      else if (current_subfile->language == language_cplus)
d5619 26
@


1.42
log
@        * c-exp.y (THIS): Delete token and grammar rule.
        (yylex): Don't return THIS.
        * cp-valprint.c (vtbl_ptr_name_old): Delete.
        (cp_is_vtbl_ptr_type): Don't check vtbl_ptr_name_old.
        * demangle.c (cplus_markers): Update comment.  Put '$'
        first.  Remove CPLUS_MARKER.
        (_initialize_demangler): Don't call set_cplus_marker_for_demangling.
        * jv-exp.y (THIS): Delete token and grammar rule.
        (yylex): Don't return THIS.
        * mips-tdep.c (mips_dump_tdep): Don't dump CPLUS_MARKER.
        * objc-exp.y (THIS): Delete token and grammar rule.
        (yylex): Don't return THIS.
        * p-exp.y (yylex): Remove reference to CPLUS_MARKER.
        * stabsread.c (vptr_name, vb_name): Replace CPLUS_MARKER with '$'.
        (read_member_functions): Likewise for opname.
        (read_tilde_fields): Use is_cplus_marker.

        * defs.h (CPLUS_MARKER): Don't define.
        * config/tm-sysv4.h (CPLUS_MARKER): Likewise.
        * config/i386/xm-i386sco.h (CPLUS_MARKER): Likewise.
        * config/mips/tm-irix3.h (CPLUS_MARKER): Likewise.
        * config/mips/tm-irix6.h (CPLUS_MARKER): Likewise.
        * config/rs6000/tm-rs6000.h (CPLUS_MARKER): Likewise.

        * config/i386/tm-i386v4.h: Delete file.
        * config/djgpp/fnchange.lst: Delete tm-i386v4.h.
        * config/i386/tm-i386sol2.h: Include "i386/tm-i386.h" instead.
        * config/i386/tm-i386v42mp.h: Include "i386/tm-i386.h" instead.
        * config/i386/tm-ptx.h: Include "i386/tm-i386.h" instead.
        * config/i386/i386gnu.mt (TM_FILE): Use tm-i386.h.
        * config/i386/i386sco5.mt (TM_FILE): Likewise.
        * config/i386/i386v4.mt (TM_FILE): Likewise.
        * config/i386/ncr3000.mt (TM_FILE): Likewise.
@
text
@d4140 1
a4140 1
		      && is_cplus_marker (name[sizeof (vptr_name) - 1]))
@


1.41
log
@Revert previous change.  Not obvious.
@
text
@d188 2
a189 4
static const char vptr_name[] =
{'_', 'v', 'p', 't', 'r', CPLUS_MARKER, '\0'};
static const char vb_name[] =
{'_', 'v', 'b', CPLUS_MARKER, '\0'};
d3180 1
a3180 2
	  static char opname[32] =
	  {'o', 'p', CPLUS_MARKER};
d4138 3
a4140 2
		  if (!strncmp (TYPE_FIELD_NAME (t, i), vptr_name,
				sizeof (vptr_name) - 1))
@


1.41.2.1
log
@Merge with mainline; merge tag carlton_dictionary-20021011-merge.
@
text
@d188 4
a191 2
static const char vptr_name[] = "_vptr$";
static const char vb_name[] = "_vb$";
d3182 2
a3183 1
	  static char opname[32] = "op$";
d4141 2
a4142 3
		  char *name = TYPE_FIELD_NAME (t, i);
		  if (!strncmp (name, vptr_name, sizeof (vptr_name) - 2)
		      && is_cplus_marker (name[sizeof (vptr_name) - 1]))
@


1.41.2.2
log
@2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_block): New function.
	(lookup_symbol_aux_local): Call lookup_symbol_aux_block.
	(lookup_symbol_aux): Ditto.

	* Merge from mainline; tag is carlton_dictionary-20021025-merge.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* cp-support.c: Add comment to demangled name pitfalls.
	* symtab.c (lookup_transparent_type): Add FIXME comment at
	beginning.

2002-10-23  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c: Delete cplusplus_hint.
	Delete prototype for find_template_name_end.
	* dwarf2read.c (scan_partial_symbols): Add in a gdb_assert from a
	later version of my namespace_minimal patch.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Change all of the setup_xfail tests that
	I added into setup_kfails.
@
text
@a171 2
static char *find_name_end (char *name);

d1274 1
a1274 1
  char *p = (char *) find_name_end (string);
d2007 1
a2007 2
      else if ((current_subfile->language == language_cplus)
	       || (current_subfile->language == language_objc))
d4140 1
a4140 1
		      && is_cplus_marker (name[sizeof (vptr_name) - 2]))
a5615 26
    }
}

/* Find the end of the name, delimited by a ':', but don't match
   ObjC symbols which look like -[Foo bar::]:bla.  */
static char *
find_name_end (char *name)
{
  char *s = name;
  if (s[0] == '-' || *s == '+')
    {
      /* Must be an ObjC method symbol.  */
      if (s[1] != '[')
	{
	  error ("invalid symbol name \"%s\"", name);
	}
      s = strchr (s, ']');
      if (s == NULL)
	{
	  error ("invalid symbol name \"%s\"", name);
	}
      return strchr (s, ':');
    }
  else
    {
      return strchr (s, ':');
@


1.41.2.3
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d205 1
a205 1
static struct deprecated_complaint invalid_cpp_abbrev_complaint =
d208 1
a208 1
static struct deprecated_complaint invalid_cpp_type_complaint =
d211 1
a211 1
static struct deprecated_complaint member_fn_complaint =
d214 1
a214 1
static struct deprecated_complaint const_vol_complaint =
d217 1
a217 1
static struct deprecated_complaint error_type_complaint =
d220 1
a220 1
static struct deprecated_complaint invalid_member_complaint =
d223 1
a223 1
static struct deprecated_complaint range_type_base_complaint =
d226 1
a226 1
static struct deprecated_complaint reg_value_complaint =
d229 1
a229 1
static struct deprecated_complaint vtbl_notfound_complaint =
d232 1
a232 1
static struct deprecated_complaint unrecognized_cplus_name_complaint =
d235 1
a235 1
static struct deprecated_complaint rs6000_builtin_complaint =
d238 1
a238 1
static struct deprecated_complaint unresolved_sym_chain_complaint =
d241 1
a241 1
static struct deprecated_complaint stabs_general_complaint =
d244 1
a244 1
static struct deprecated_complaint lrs_general_complaint =
d314 1
a314 1
      static struct deprecated_complaint msg =
d621 1
a621 1
  static struct deprecated_complaint msg_unknown =
d625 1
a625 1
  static struct deprecated_complaint msg_notfound =
d695 1
a695 1
	    static struct deprecated_complaint msg =
d813 1
a813 1
	  static struct deprecated_complaint msg =
d2438 1
a2438 1
		static struct deprecated_complaint msg =
d2663 1
a2663 1
            static struct deprecated_complaint msg = {
d4021 1
a4021 1
	    static struct deprecated_complaint msg =
d4040 1
a4040 1
	    static struct deprecated_complaint msg =
d4213 1
a4213 1
	  static struct deprecated_complaint msg =
d4392 1
a4392 1
	    static struct deprecated_complaint msg =
d4405 1
a4405 1
static struct deprecated_complaint multiply_defined_struct =
d5217 1
a5217 1
      static struct deprecated_complaint msg =
d5247 1
a5247 1
      static struct deprecated_complaint msg =
d5362 1
a5362 1
		    static struct deprecated_complaint msg =
d5387 1
a5387 1
	    static struct deprecated_complaint msg =
@


1.41.2.4
log
@2002-11-27  David Carlton  <carlton@@math.stanford.edu>

	* dwarf2read.c (add_partial_enumeration): New function.
	(scan_partial_symbols): Call add_partial_enumeration.
	(locate_pdi_sibling): New function.
	(scan_partial_symbols): Call locate_pdi_sibling.  Get rid of
	nesting_level.
	(pdi_needs_namespace): New function.
	(add_partial_symbol): Add 'namespace' arg; calculate full name
	when appropriate.
	(scan_partial_symbols): Update calls to add_partial_symbol.
	(add_partial_enumeration): Ditto.
	(read_enumeration): Add processing_current_prefix to name when
	appropriate.
	(new_symbol): Set names of enumerators and typedefs appropriately
	if processing_has_namespace_info.
	* symtab.c (lookup_symbol_namespace): Rename 'namespace' argument
	to 'namespace_name'.
	* symtab.h: Ditto.
	* symtab.c (lookup_symbol_namespace): Delete FIXME comments; add a
	new one.
	(lookup_symbol_aux_file): New function.
	(lookup_symbol_aux): Delete FIXME comment.
	(lookup_symbol_aux): Don't search static block explicitly; delete
	FIXME comments.
	* valops.c (value_namespace_elt): Update call to
	lookup_symbol_namespace.
	* symtab.h: Update declaration for lookup_symbol_namespace.
	* symtab.c (lookup_symbol_namespace): Delete 'using' argument and
	add 'block' argument; get using directives via iterators.
	(lookup_symbol_aux_using_loop): Delete 'using' argument and add
	'block' argument.
	(lookup_symbol_aux_using): Don't calculate using directives.
	* block.c (block_using_iterator_first): New function.
	(block_using_iterator_next): Ditto.
	* block.h: Add comment.
	(struct block_using_iterator): New struct.
	Declare block_using_iterator_first, block_using_iterator_next.

2002-11-26  David Carlton  <carlton@@math.stanford.edu>

	* dwarf2read.c (read_structure_scope): Set type name and
	processing_current_prefix appropriately.
	(new_symbol): Make sure that, in symbols associated to class
	types, the name includes appropriate namespaces.
	* buildsym.h: Rename processing_current_namespace to
	processing_current_prefix.
	* buildsym.c (finish_block): Ditto.
	* dwarf2read.c (psymtab_to_symtab_1): Ditto.
	(read_namespace): Ditto.  Also rename previous_namespace to
	previous_prefix.

	Now come a thousand and one const correctness fixes:
	* p-typeprint.c (pascal_print_type): Const.
	(pascal_type_print_method_args): Const.
	* p-lang.h: Const.
	* m2-typeprint.c (m2_print_type): Const.
	* valops.c (hand_function_call): Const.
	* jv-lang.c (java_primitive_type_from_name): Const.
	* jv-lang.h: Const.
	* jv-typeprint.c (java_print_type): Const.
	* language.c: (unk_lang_print_type): Const.
	* stack.c (frame_info): Const.
	* linespec.c (find_methods): Const.
	(find_method_name): Const
	* f-lang.h: Const.
	* f-typeprint.c (f_print_type): Const.
	* c-typeprint.c (c_print_type): Const.
	* c-lang.h: Const.
	* gdbtypes.h: Const.
	* gdbtypes.c (lookup_primitive_typename): Const.
	* stack.c (print_frame): Const.
	(func_command): Delete pointless cast.
	* linespec.c (find_method_name): Const.
	* language.h: Const.
	* symfile.c (compare_psymbols): Const.
	* symtab.c (completion_list_add_name): Const.
	* breakpoint.c (break_at_finish_at_depth_command_1): Remove
	useless cast.
	(break_at_finish_command_1): Ditto.
	* typeprint.c (type_print): Const.
	* symtab.h: Const.
	* symtab.c (gdb_mangle_name): Const.
	(symbol_init_demangled_name): Const.
	(symbol_demangled_name): Const.
	* defs.h: Const.
	* printcmd.c (build_address_symbolic): Const.
	* valops.c (search_struct_method): Const.
	* cp-valprint.c (cp_is_vtbl_ptr_type): Const.
	(cp_print_value): Const.
	(cp_print_class_member): Const.
	* c-typeprint.c (cp_type_print_derivation_info): Const.
	(c_type_print_varspec_prefix): Const.
	(c_type_print_base): Const.
	* p-valprint.c (pascal_object_is_vtbl_ptr_type): Const.
	(pascal_object_print_value): Const.
	(pascal_object_print_class_member): Const.
	* p-typeprint.c (pascal_type_print_derivation_info): Const.
	(pascal_type_print_varspec_prefix): Const.
	(pascal_type_print_base): Const.
	* jv-typeprint.c (java_type_print_base): Const.
	* jv-lang.h (java_demangle_type_signature): Const.
	* jv-lang.c (java_demangle_type_signature): Const.
	(java_demangled_signature_length): Const.
	(java_demangled_signature_copy): Const.
	* jv-typeprint.c (java_type_print_derivation_info): Const.
	* jv-valprint.c (java_value_print): Const.
	(java_print_value_fields): Const.
	* jv-lang.c (is_object_type): Const.
	(evaluate_subexp_java): Const.
	* stabsread.c (read_cpp_abbrev): Const.
	(complain_about_struct_wipeout): Const.
	(cleanup_undefined_types): Const.
	* gdbtypes.h: Const.
	* gdbtypes.c (add_name): Second arg const.
	(lookup_typename): Const.
	(lookup_unsigned_typename): Const.
	(lookup_signed_typename): Const.
	* linespec.c (find_methods): const char *class_name.
	* symtab.c (gdb_mangle_name): const char *newname.
	* valops.c (destructor_name_p): const char *dname.
	(search_struct_field): First arg const.
	* gdbtypes.c (check_typedef): const char *name (multiple places).
	(cfront_mangle_name): const char *newname.
	* gdbtypes.c (add_mangled_type): const char *tname.
	* valops.c (find_overload_match): const char *obj_type_name.
	* utils.c (gdb_print_host_address): Make first arg const.
	* defs.h: Declare first arg of gdb_print_host_address to be
	const.
	* valarith.c (find_size_for_pointer_math): const char *name.

2002-11-27  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/m-data.cc (main): Add marker comment.
	* gdb.c++/m-data.exp: Use marker comment instead of line numbers.
	* gdb.c++/m-data.cc: Delete superfluous namespace.
	* gdb.c++/m-static.cc: Ditto.
	* gdb.c++/m-static1.cc: Ditto.
	* carlton_runtest: Compare based on gdb.sum, not based on output.
	* carlton_runnamespace: Ditto.

2002-11-26  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Put tests for CClass.
	* gdb.c++/namespace.cc (C): Add CClass.
@
text
@d3603 1
a3603 1
  const char *name;
d4414 1
a4414 1
  const char *name = "";
d5358 1
a5358 1
		const char *typename = TYPE_TAG_NAME (*type);
@


1.41.2.5
log
@2002-12-20  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_minsyms): Don't call
	lookup_symbol_aux from within this.
	* values.c (value_static_field): lookup_symbol_linkage.
	(value_fn_field): lookup_symbol_linkage.
	* valops.c (value_struct_elt_for_reference): lookup_symbol_linkage.
	* blockframe.c (inside_main_func): lookup_symbol_linkage.
	* source.c (select_source_symtab): lookup_symbol_linkage.
	* nlmread.c (nlm_symfile_read): Call lookup_symbol_linkage.
	* nindy-tdep.c (nindy_frame_chain_valid): Call
	lookup_symbol_linkage.
	* linespec.c (count_methods): Call lookup_symbol_linkage.
	(add_matching_methods): Ditto.
	(add_constructors): Ditto.
	* hppa-tdep.c (find_stub_with_shl_get): Call
	lookup_symbol_linkage.  Delete symbol2.
	(initialize_hp_cxx_exception_support): Call lookup_symbol_linkage.
	* cli/cli-cmds.c (edit_command): SYMBOL_PRINT_NAME.
	(list_command): SYMBOL_PRINT_NAME.
	* valops.c (value_of_variable): SYMBOL_PRINT_NAME
	(hand_function_call): SYMBOL_PRINT_NAME.
	* typeprint.c (typedef_print): SYMBOL_PRINT_NAME.
	* tracepoint.c (tracepoints_info): SYMBOL_PRINT_NAME.
	* symtab.c (lookup_partial_symbol): SYMBOL_BEST_NAME.
	(compare_search_syms): SYMBOL_BEST_NAME.
	(print_symbol_info): SYMBOL_PRINT_NAME.
	(print_msymbol_info): SYMBOL_PRINT_NAME.
	(rbreak_command): SYMBOL_PRINT_NAME.
	* symmisc.c (print_symbol): SYMBOL_PRINT_NAME.
	* stack.c (print_frame): SYMBOL_PRINT_NAME.
	(frame_info): SYMBOL_PRINT_NAME.
	(print_block_frame_locals): SYMBOL_PRINT_NAME.
	(print_block_frame_labels): SYMBOL_PRINT_NAME.
	(print_frame_arg_vars): SYMBOL_PRINT_NAME.
	(return_command): SYMBOL_PRINT_NAME.
	* stabsread.c (define_symbol): SYMBOL_PRINT_NAME.
	* p-valprint.c (pascal_val_print): SYMBOL_PRINT_NAME.
	* printcmd.c (build_address_symbolic): SYMBOL_PRINT_NAME.
	(sym_info): SYMBOL_PRINT_NAME.
	(print_frame_args): SYMBOL_PRINT_NAME.
	* objc-lang.c (compare_selectors): SYMBOL_BEST_NAME.
	(compare_classes): SYMBOL_BEST_NAME.
	* maint.c (maintenance_translate_address): SYMBOL_PRINT_NAME.
	* linespec.c (find_method): SYMBOL_PRINT_NAME.
	(select_symbols): SYMBOL_PRINT_NAME.
	* infcmd.c (jump_command): SYMBOL_PRINT_NAME.
	* findvar.c (locate_var_value): SYMBOL_PRINT_NAME.
	* expprint.c (print_subexp): SYMBOL_PRINT_NAME.
	* c-valprint.c (c_val_print): SYMBOL_PRINT_NAME.
	* buildsym.c (finish_block): SYMBOL_PRINT_NAME.
	* breakpoint.c (print_one_breakpoint): SYMBOL_PRINT_NAME.
	* ax-gdb.c (gen_var_ref): SYMBOL_PRINT_NAME.
	* ada-typeprint.c (ada_typedef_print): SYMBOL_PRINT_NAME.
	* ada-lang.c (user_select_syms): Use SYMBOL_PRINT_NAME instead of
	SYMBOL_SOURCE_NAME.
	(user_select_syms):
	(ada_finish_decode_line_1): Use SYMBOL_BEST_NAME instead of
	SYMBOL_SOURCE_NAME.
	* symtab.h (SYMBOL_PRINT_NAME): Rename from SYMBOL_SOURCE_NAME.
	* symfile.c (compare_symbols): Use SYMBOL_BEST_NAME, not
	SYMBOL_SOURCE_NAME.
	(compare_psymbols): Ditto.
	* symtab.c (lookup_symbol_linkage): New function.
	* symtab.h: Declare lookup_symbol_linkage.
	* c-valprint.c (c_val_print): Call lookup_symbol_minsym.
	* symtab.c (lookup_symbol_aux_minsyms): Call minsym_static.
	* minsyms.c (minsym_static): New function.
	* symtab.h: Declare minsym_static.
	* symtab.c (lookup_symbol_minsym): New function.
	(search_symbols): Call lookup_symbol_minsym instead of
	lookup_symbol.
	(lookup_symbol_namespace): Don't take apart NAME.
	* symtab.h: Declare lookup_symbol_minsym.
	* printcmd.c (build_address_symbolic): Don't use old version of
	SYMBOL_LINKAGE_NAME.
	* symtab.c (lookup_block_symbol): Change mangled names to linkage
	name, and use SYMBOL_LINKAGE_NAME as appropriate.
	* symtab.h (SYMBOL_LINKAGE_NAME): New macro, with a different
	meaning from the old macro of the same name.  Also, add comments
	about proper uses of names.
@
text
@d1818 1
a1818 1
		    SYMBOL_PRINT_NAME (sym));
d1834 1
a1834 1
		    SYMBOL_PRINT_NAME (sym));
d2088 1
a2088 1
		    SYMBOL_PRINT_NAME (sym));
@


1.41.2.6
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d205 32
a236 5
static void
invalid_cpp_abbrev_complaint (const char *arg1)
{
  complaint (&symfile_complaints, "invalid C++ abbreviation `%s'", arg1);
}
d238 2
a239 7
static void
reg_value_complaint (int arg1, int arg2, const char *arg3)
{
  complaint (&symfile_complaints,
	     "register number %d too large (max %d) in symbol %s", arg1, arg2,
	     arg3);
}
d241 2
a242 5
static void
stabs_general_complaint (const char *arg1)
{
  complaint (&symfile_complaints, "%s", arg1);
}
d244 2
a245 5
static void
lrs_general_complaint (const char *arg1)
{
  complaint (&symfile_complaints, "%s", arg1);
}
d314 5
a318 3
      complaint (&symfile_complaints,
		 "Invalid symbol data: type number (%d,%d) out of range at symtab pos %d.",
		 filenum, index, symnum);
a608 6
static void
msg_unknown_complaint (const char *arg1)
{
  complaint (&symfile_complaints, "Unsupported token in stabs string %s", arg1);
}

d621 8
d695 4
a698 3
	    complaint (&symfile_complaints,
		       "Unknown visibility `%c' for baseclass",
		       new->visibility);
d706 1
a706 1
	  msg_unknown_complaint (*pp);
d734 1
a734 1
	    msg_unknown_complaint (*pp);
d746 1
a746 2
	    complaint (&symfile_complaints, "Unable to find base type for %s",
		       *pp);
d813 5
a817 2
	  complaint (&symfile_complaints,
		     "Unable to find function symbol for %s", fname);
d1073 1
a1073 1
      lrs_general_complaint ("symbol for reference not found");
d1109 1
a1109 1
      lrs_general_complaint ("Unable to allocate alias list memory");
d1364 1
a1364 2
	  complaint (&symfile_complaints, "Unknown C++ symbol name `%s'",
		     string);
d1816 3
a1818 3
	  reg_value_complaint (SYMBOL_VALUE (sym),
			       NUM_REGS + NUM_PSEUDO_REGS,
			       SYMBOL_PRINT_NAME (sym));
d1832 3
a1834 3
	  reg_value_complaint (SYMBOL_VALUE (sym),
			       NUM_REGS + NUM_PSEUDO_REGS,
			       SYMBOL_PRINT_NAME (sym));
d2086 3
a2088 3
	  reg_value_complaint (SYMBOL_VALUE (sym),
			       NUM_REGS + NUM_PSEUDO_REGS,
			       SYMBOL_PRINT_NAME (sym));
d2183 1
a2183 1
	      lrs_general_complaint ("live range format not recognized");
d2204 1
a2204 1
      lrs_general_complaint ("live range string 1");
d2211 1
a2211 1
      lrs_general_complaint ("live range string 2");
d2224 1
a2224 1
      lrs_general_complaint ("Live range symbol not found 1");
d2230 1
a2230 1
      lrs_general_complaint ("live range string 3");
d2243 1
a2243 1
      lrs_general_complaint ("Live range symbol not found 2");
d2249 1
a2249 1
      lrs_general_complaint ("live range string 4");
d2271 1
a2271 1
      lrs_general_complaint ("end of live range follows start");
d2328 1
a2328 1
  complaint (&symfile_complaints, "couldn't parse type; debugger out of date?");
d2438 3
a2440 2
		complaint (&symfile_complaints,
			   "Unrecognized cross-reference type `%c'", (*pp)[0]);
d2663 5
a2667 3
	    complaint (&symfile_complaints,
		       "Prototyped function type didn't end arguments with `#':\n%s",
		       type_start);
d2800 1
a2800 3
	    complaint (&symfile_complaints,
		       "invalid (minimal) member type data format at symtab pos %d.",
		       symnum);
d2933 1
a2933 1
      complaint (&symfile_complaints, "Unknown builtin type %d", typenum);
d3291 1
a3291 2
	      complaint (&symfile_complaints,
			 "const/volatile indicator missing, got '%c'", **pp);
d3373 1
a3373 2
	      complaint (&symfile_complaints,
			 "member function type missing, got '%c'", (*pp)[-1]);
d3638 1
a3638 3
	      complaint (&symfile_complaints,
			 "C++ abbreviated type name unknown at symtab pos %d",
			 symnum);
d3646 1
a3646 1
	  invalid_cpp_abbrev_complaint (*pp);
d3659 1
a3659 1
	  invalid_cpp_abbrev_complaint (*pp);
d3680 1
a3680 1
      invalid_cpp_abbrev_complaint (*pp);
d3764 1
a3764 1
      stabs_general_complaint ("bad structure-type format");
d3775 1
a3775 1
	stabs_general_complaint ("bad structure-type format");
d3781 1
a3781 1
	stabs_general_complaint ("bad structure-type format");
d4021 4
a4024 2
	    complaint (&symfile_complaints,
		       "Unknown virtual character `%c' for baseclass", **pp);
d4040 5
a4044 3
	    complaint (&symfile_complaints,
		       "Unknown visibility `%c' for baseclass",
		       new->visibility);
d4150 1
a4150 3
	      complaint (&symfile_complaints,
			 "virtual function table pointer not found when defining class `%s'",
			 TYPE_NAME (type));
d4213 5
a4217 2
	  complaint (&symfile_complaints,
		     "Unable to find symbol for static data field %s", sname);
d4392 4
a4395 2
	    complaint (&symfile_complaints, "Unknown visibility `%c' for field",
		       fip->list->visibility);
d4405 4
d4439 1
a4439 2
  complaint (&symfile_complaints,
	     "struct/union type gets multiply defined: %s%s", kind, name);
d5141 1
a5141 2
      complaint (&symfile_complaints,
		 "base type %d of range type is not defined", rangenums[1]);
d5217 5
a5221 2
      complaint (&symfile_complaints,
		 "Invalid symbol data: common block within common block");
d5247 3
a5249 1
      complaint (&symfile_complaints, "ECOMM symbol unmatched by BCOMM");
d5362 3
a5364 1
		    complaint (&symfile_complaints, "need a type name");
d5387 4
a5390 3
	    complaint (&symfile_complaints,
		       "GDB internal error.  cleanup_undefined_types with bad type %d.",
		       TYPE_CODE (*type));
d5550 2
a5551 3
	    complaint (&symfile_complaints,
		       "%s: common block `%s' from global_sym_chain unresolved",
		       objfile->name, SYMBOL_NAME (prev));
@


1.41.2.7
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d3 1
a3 1
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d137 2
a138 2
static int attach_fields_to_type (struct field_info *, struct type *,
				  struct objfile *);
a151 2
#if 0 /* OBSOLETE CFront */
// OBSOLETE  /* new functions added for cfront support */
d153 11
a163 16
// OBSOLETE  static int
// OBSOLETE  copy_cfront_struct_fields (struct field_info *, struct type *,
// OBSOLETE  			   struct objfile *);

// OBSOLETE  static char *get_cfront_method_physname (char *);

// OBSOLETE  static int
// OBSOLETE  read_cfront_baseclasses (struct field_info *, char **,
// OBSOLETE  			 struct type *, struct objfile *);

// OBSOLETE  static int
// OBSOLETE  read_cfront_static_fields (struct field_info *, char **,
// OBSOLETE  			   struct type *, struct objfile *);
// OBSOLETE  static int
// OBSOLETE  read_cfront_member_functions (struct field_info *, char **,
// OBSOLETE  			      struct type *, struct objfile *);
d165 6
a170 2
// OBSOLETE  /* end new functions added for cfront support */
#endif /* OBSOLETE CFront */
d174 4
a177 2
static void add_live_range (struct objfile *, struct symbol *, CORE_ADDR,
			    CORE_ADDR);
d185 2
a186 2
static int resolve_symbol_reference (struct objfile *, struct symbol *,
				     char *);
d201 3
d245 30
d339 6
d534 481
a1014 482
#if 0 /* OBSOLETE CFront */
// OBSOLETE  #define CFRONT_VISIBILITY_PRIVATE	'2'	/* Stabs character for private field */
// OBSOLETE  #define CFRONT_VISIBILITY_PUBLIC	'1'	/* Stabs character for public field */

// OBSOLETE  /* This code added to support parsing of ARM/Cfront stabs strings */

// OBSOLETE  /* Get substring from string up to char c, advance string pointer past
// OBSOLETE     suibstring. */

// OBSOLETE  static char *
// OBSOLETE  get_substring (char **p, int c)
// OBSOLETE  {
// OBSOLETE    char *str;
// OBSOLETE    str = *p;
// OBSOLETE    *p = strchr (*p, c);
// OBSOLETE    if (*p)
// OBSOLETE      {
// OBSOLETE        **p = 0;
// OBSOLETE        (*p)++;
// OBSOLETE      }
// OBSOLETE    else
// OBSOLETE      str = 0;
// OBSOLETE    return str;
// OBSOLETE  }

// OBSOLETE  /* Physname gets strcat'd onto sname in order to recreate the mangled
// OBSOLETE     name (see funtion gdb_mangle_name in gdbtypes.c).  For cfront, make
// OBSOLETE     the physname look like that of g++ - take out the initial mangling
// OBSOLETE     eg: for sname="a" and fname="foo__1aFPFs_i" return "FPFs_i" */

// OBSOLETE  static char *
// OBSOLETE  get_cfront_method_physname (char *fname)
// OBSOLETE  {
// OBSOLETE    int len = 0;
// OBSOLETE    /* FIXME would like to make this generic for g++ too, but 
// OBSOLETE       that is already handled in read_member_funcctions */
// OBSOLETE    char *p = fname;

// OBSOLETE    /* search ahead to find the start of the mangled suffix */
// OBSOLETE    if (*p == '_' && *(p + 1) == '_')	/* compiler generated; probably a ctor/dtor */
// OBSOLETE      p += 2;
// OBSOLETE    while (p && (unsigned) ((p + 1) - fname) < strlen (fname) && *(p + 1) != '_')
// OBSOLETE      p = strchr (p, '_');
// OBSOLETE    if (!(p && *p == '_' && *(p + 1) == '_'))
// OBSOLETE      error ("Invalid mangled function name %s", fname);
// OBSOLETE    p += 2;			/* advance past '__' */

// OBSOLETE    /* struct name length and name of type should come next; advance past it */
// OBSOLETE    while (isdigit (*p))
// OBSOLETE      {
// OBSOLETE        len = len * 10 + (*p - '0');
// OBSOLETE        p++;
// OBSOLETE      }
// OBSOLETE    p += len;

// OBSOLETE    return p;
// OBSOLETE  }

// OBSOLETE  static void
// OBSOLETE  msg_unknown_complaint (const char *arg1)
// OBSOLETE  {
// OBSOLETE    complaint (&symfile_complaints, "Unsupported token in stabs string %s", arg1);
// OBSOLETE  }

// OBSOLETE  /* Read base classes within cfront class definition.
// OBSOLETE     eg: A:ZcA;1@@Bpub v2@@Bvirpri;__ct__1AFv func__1AFv *sfunc__1AFv ;as__1A ;;
// OBSOLETE     ^^^^^^^^^^^^^^^^^^

// OBSOLETE     A:ZcA;;foopri__1AFv foopro__1AFv __ct__1AFv __ct__1AFRC1A foopub__1AFv ;;;
// OBSOLETE     ^
// OBSOLETE   */

// OBSOLETE  static int
// OBSOLETE  read_cfront_baseclasses (struct field_info *fip, char **pp, struct type *type,
// OBSOLETE  			 struct objfile *objfile)
// OBSOLETE  {
// OBSOLETE    int bnum = 0;
// OBSOLETE    char *p;
// OBSOLETE    int i;
// OBSOLETE    struct nextfield *new;

// OBSOLETE    if (**pp == ';')		/* no base classes; return */
// OBSOLETE      {
// OBSOLETE        ++(*pp);
// OBSOLETE        return 1;
// OBSOLETE      }

// OBSOLETE    /* first count base classes so we can allocate space before parsing */
// OBSOLETE    for (p = *pp; p && *p && *p != ';'; p++)
// OBSOLETE      {
// OBSOLETE        if (*p == ' ')
// OBSOLETE  	bnum++;
// OBSOLETE      }
// OBSOLETE    bnum++;			/* add one more for last one */

// OBSOLETE    /* now parse the base classes until we get to the start of the methods 
// OBSOLETE       (code extracted and munged from read_baseclasses) */
// OBSOLETE    ALLOCATE_CPLUS_STRUCT_TYPE (type);
// OBSOLETE    TYPE_N_BASECLASSES (type) = bnum;

// OBSOLETE    /* allocate space */
// OBSOLETE    {
// OBSOLETE      int num_bytes = B_BYTES (TYPE_N_BASECLASSES (type));
// OBSOLETE      char *pointer;

// OBSOLETE      pointer = (char *) TYPE_ALLOC (type, num_bytes);
// OBSOLETE      TYPE_FIELD_VIRTUAL_BITS (type) = (B_TYPE *) pointer;
// OBSOLETE    }
// OBSOLETE    B_CLRALL (TYPE_FIELD_VIRTUAL_BITS (type), TYPE_N_BASECLASSES (type));

// OBSOLETE    for (i = 0; i < TYPE_N_BASECLASSES (type); i++)
// OBSOLETE      {
// OBSOLETE        new = (struct nextfield *) xmalloc (sizeof (struct nextfield));
// OBSOLETE        make_cleanup (xfree, new);
// OBSOLETE        memset (new, 0, sizeof (struct nextfield));
// OBSOLETE        new->next = fip->list;
// OBSOLETE        fip->list = new;
// OBSOLETE        FIELD_BITSIZE (new->field) = 0;	/* this should be an unpacked field! */

// OBSOLETE        STABS_CONTINUE (pp, objfile);

// OBSOLETE        /* virtual?  eg: v2@@Bvir */
// OBSOLETE        if (**pp == 'v')
// OBSOLETE  	{
// OBSOLETE  	  SET_TYPE_FIELD_VIRTUAL (type, i);
// OBSOLETE  	  ++(*pp);
// OBSOLETE  	}

// OBSOLETE        /* access?  eg: 2@@Bvir */
// OBSOLETE        /* Note: protected inheritance not supported in cfront */
// OBSOLETE        switch (*(*pp)++)
// OBSOLETE  	{
// OBSOLETE  	case CFRONT_VISIBILITY_PRIVATE:
// OBSOLETE  	  new->visibility = VISIBILITY_PRIVATE;
// OBSOLETE  	  break;
// OBSOLETE  	case CFRONT_VISIBILITY_PUBLIC:
// OBSOLETE  	  new->visibility = VISIBILITY_PUBLIC;
// OBSOLETE  	  break;
// OBSOLETE  	default:
// OBSOLETE  	  /* Bad visibility format.  Complain and treat it as
// OBSOLETE  	     public.  */
// OBSOLETE  	  {
// OBSOLETE  	    complaint (&symfile_complaints,
// OBSOLETE  		       "Unknown visibility `%c' for baseclass",
// OBSOLETE  		       new->visibility);
// OBSOLETE  	    new->visibility = VISIBILITY_PUBLIC;
// OBSOLETE  	  }
// OBSOLETE  	}

// OBSOLETE        /* "@@" comes next - eg: @@Bvir */
// OBSOLETE        if (**pp != '@@')
// OBSOLETE  	{
// OBSOLETE  	  msg_unknown_complaint (*pp);
// OBSOLETE  	  return 1;
// OBSOLETE  	}
// OBSOLETE        ++(*pp);


// OBSOLETE        /* Set the bit offset of the portion of the object corresponding 
// OBSOLETE           to this baseclass.  Always zero in the absence of
// OBSOLETE           multiple inheritance.  */
// OBSOLETE        /* Unable to read bit position from stabs;
// OBSOLETE           Assuming no multiple inheritance for now FIXME! */
// OBSOLETE        /* We may have read this in the structure definition;
// OBSOLETE           now we should fixup the members to be the actual base classes */
// OBSOLETE        FIELD_BITPOS (new->field) = 0;

// OBSOLETE        /* Get the base class name and type */
// OBSOLETE        {
// OBSOLETE  	char *bname;		/* base class name */
// OBSOLETE  	struct symbol *bsym;	/* base class */
// OBSOLETE  	char *p1, *p2;
// OBSOLETE  	p1 = strchr (*pp, ' ');
// OBSOLETE  	p2 = strchr (*pp, ';');
// OBSOLETE  	if (p1 < p2)
// OBSOLETE  	  bname = get_substring (pp, ' ');
// OBSOLETE  	else
// OBSOLETE  	  bname = get_substring (pp, ';');
// OBSOLETE  	if (!bname || !*bname)
// OBSOLETE  	  {
// OBSOLETE  	    msg_unknown_complaint (*pp);
// OBSOLETE  	    return 1;
// OBSOLETE  	  }
// OBSOLETE  	/* FIXME! attach base info to type */
// OBSOLETE  	bsym = lookup_symbol (bname, 0, STRUCT_NAMESPACE, 0, 0);	/*demangled_name */
// OBSOLETE  	if (bsym)
// OBSOLETE  	  {
// OBSOLETE  	    new->field.type = SYMBOL_TYPE (bsym);
// OBSOLETE  	    new->field.name = type_name_no_tag (new->field.type);
// OBSOLETE  	  }
// OBSOLETE  	else
// OBSOLETE  	  {
// OBSOLETE  	    complaint (&symfile_complaints, "Unable to find base type for %s",
// OBSOLETE  		       *pp);
// OBSOLETE  	    return 1;
// OBSOLETE  	  }
// OBSOLETE        }

// OBSOLETE        /* If more base classes to parse, loop again.
// OBSOLETE           We ate the last ' ' or ';' in get_substring,
// OBSOLETE           so on exit we will have skipped the trailing ';' */
// OBSOLETE        /* if invalid, return 0; add code to detect  - FIXME! */
// OBSOLETE      }
// OBSOLETE    return 1;
// OBSOLETE  }

// OBSOLETE  /* read cfront member functions.
// OBSOLETE     pp points to string starting with list of functions
// OBSOLETE     eg: A:ZcA;1@@Bpub v2@@Bvirpri;__ct__1AFv func__1AFv *sfunc__1AFv ;as__1A ;;
// OBSOLETE     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 
// OBSOLETE     A:ZcA;;foopri__1AFv foopro__1AFv __ct__1AFv __ct__1AFRC1A foopub__1AFv ;;;
// OBSOLETE     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 
// OBSOLETE   */

// OBSOLETE  static int
// OBSOLETE  read_cfront_member_functions (struct field_info *fip, char **pp,
// OBSOLETE  			      struct type *type, struct objfile *objfile)
// OBSOLETE  {
// OBSOLETE    /* This code extracted from read_member_functions 
// OBSOLETE       so as to do the similar thing for our funcs */

// OBSOLETE    int nfn_fields = 0;
// OBSOLETE    int length = 0;
// OBSOLETE    /* Total number of member functions defined in this class.  If the class
// OBSOLETE       defines two `f' functions, and one `g' function, then this will have
// OBSOLETE       the value 3.  */
// OBSOLETE    int total_length = 0;
// OBSOLETE    int i;
// OBSOLETE    struct next_fnfield
// OBSOLETE      {
// OBSOLETE        struct next_fnfield *next;
// OBSOLETE        struct fn_field fn_field;
// OBSOLETE      }
// OBSOLETE     *sublist;
// OBSOLETE    struct type *look_ahead_type;
// OBSOLETE    struct next_fnfieldlist *new_fnlist;
// OBSOLETE    struct next_fnfield *new_sublist;
// OBSOLETE    char *main_fn_name;
// OBSOLETE    char *fname;
// OBSOLETE    struct symbol *ref_func = 0;

// OBSOLETE    /* Process each list until we find the end of the member functions.
// OBSOLETE       eg: p = "__ct__1AFv foo__1AFv ;;;" */

// OBSOLETE    STABS_CONTINUE (pp, objfile);	/* handle \\ */

// OBSOLETE    while (**pp != ';' && (fname = get_substring (pp, ' '), fname))
// OBSOLETE      {
// OBSOLETE        int is_static = 0;
// OBSOLETE        int sublist_count = 0;
// OBSOLETE        char *pname;
// OBSOLETE        if (fname[0] == '*')	/* static member */
// OBSOLETE  	{
// OBSOLETE  	  is_static = 1;
// OBSOLETE  	  sublist_count++;
// OBSOLETE  	  fname++;
// OBSOLETE  	}
// OBSOLETE        ref_func = lookup_symbol (fname, 0, VAR_NAMESPACE, 0, 0);		/* demangled name */
// OBSOLETE        if (!ref_func)
// OBSOLETE  	{
// OBSOLETE  	  complaint (&symfile_complaints,
// OBSOLETE  		     "Unable to find function symbol for %s", fname);
// OBSOLETE  	  continue;
// OBSOLETE  	}
// OBSOLETE        sublist = NULL;
// OBSOLETE        look_ahead_type = NULL;
// OBSOLETE        length = 0;

// OBSOLETE        new_fnlist = (struct next_fnfieldlist *)
// OBSOLETE  	xmalloc (sizeof (struct next_fnfieldlist));
// OBSOLETE        make_cleanup (xfree, new_fnlist);
// OBSOLETE        memset (new_fnlist, 0, sizeof (struct next_fnfieldlist));

// OBSOLETE        /* The following is code to work around cfront generated stabs.
// OBSOLETE           The stabs contains full mangled name for each field.
// OBSOLETE           We try to demangle the name and extract the field name out of it.  */
// OBSOLETE        {
// OBSOLETE  	char *dem, *dem_p, *dem_args;
// OBSOLETE  	int dem_len;
// OBSOLETE  	dem = cplus_demangle (fname, DMGL_ANSI | DMGL_PARAMS);
// OBSOLETE  	if (dem != NULL)
// OBSOLETE  	  {
// OBSOLETE  	    dem_p = strrchr (dem, ':');
// OBSOLETE  	    if (dem_p != 0 && *(dem_p - 1) == ':')
// OBSOLETE  	      dem_p++;
// OBSOLETE  	    /* get rid of args */
// OBSOLETE  	    dem_args = strchr (dem_p, '(');
// OBSOLETE  	    if (dem_args == NULL)
// OBSOLETE  	      dem_len = strlen (dem_p);
// OBSOLETE  	    else
// OBSOLETE  	      dem_len = dem_args - dem_p;
// OBSOLETE  	    main_fn_name =
// OBSOLETE  	      obsavestring (dem_p, dem_len, &objfile->type_obstack);
// OBSOLETE  	  }
// OBSOLETE  	else
// OBSOLETE  	  {
// OBSOLETE  	    main_fn_name =
// OBSOLETE  	      obsavestring (fname, strlen (fname), &objfile->type_obstack);
// OBSOLETE  	  }
// OBSOLETE        }				/* end of code for cfront work around */

// OBSOLETE        new_fnlist->fn_fieldlist.name = main_fn_name;

// OBSOLETE  /*-------------------------------------------------*/
// OBSOLETE        /* Set up the sublists
// OBSOLETE           Sublists are stuff like args, static, visibility, etc.
// OBSOLETE           so in ARM, we have to set that info some other way.
// OBSOLETE           Multiple sublists happen if overloading
// OBSOLETE           eg: foo::26=##1;:;2A.;
// OBSOLETE           In g++, we'd loop here thru all the sublists...  */

// OBSOLETE        new_sublist =
// OBSOLETE  	(struct next_fnfield *) xmalloc (sizeof (struct next_fnfield));
// OBSOLETE        make_cleanup (xfree, new_sublist);
// OBSOLETE        memset (new_sublist, 0, sizeof (struct next_fnfield));

// OBSOLETE        /* eat 1; from :;2A.; */
// OBSOLETE        new_sublist->fn_field.type = SYMBOL_TYPE (ref_func);	/* normally takes a read_type */
// OBSOLETE        /* Make this type look like a method stub for gdb */
// OBSOLETE        TYPE_FLAGS (new_sublist->fn_field.type) |= TYPE_FLAG_STUB;
// OBSOLETE        TYPE_CODE (new_sublist->fn_field.type) = TYPE_CODE_METHOD;

// OBSOLETE        /* If this is just a stub, then we don't have the real name here. */
// OBSOLETE        if (TYPE_STUB (new_sublist->fn_field.type))
// OBSOLETE  	{
// OBSOLETE  	  if (!TYPE_DOMAIN_TYPE (new_sublist->fn_field.type))
// OBSOLETE  	    TYPE_DOMAIN_TYPE (new_sublist->fn_field.type) = type;
// OBSOLETE  	  new_sublist->fn_field.is_stub = 1;
// OBSOLETE  	}

// OBSOLETE        /* physname used later in mangling; eg PFs_i,5 for foo__1aFPFs_i 
// OBSOLETE           physname gets strcat'd in order to recreate the onto mangled name */
// OBSOLETE        pname = get_cfront_method_physname (fname);
// OBSOLETE        new_sublist->fn_field.physname = savestring (pname, strlen (pname));


// OBSOLETE        /* Set this member function's visibility fields. 
// OBSOLETE           Unable to distinguish access from stabs definition!
// OBSOLETE           Assuming public for now.  FIXME!
// OBSOLETE           (for private, set new_sublist->fn_field.is_private = 1,
// OBSOLETE           for public, set new_sublist->fn_field.is_protected = 1) */

// OBSOLETE        /* Unable to distinguish const/volatile from stabs definition!
// OBSOLETE           Assuming normal for now.  FIXME! */

// OBSOLETE        new_sublist->fn_field.is_const = 0;
// OBSOLETE        new_sublist->fn_field.is_volatile = 0;	/* volatile not implemented in cfront */

// OBSOLETE        /* Set virtual/static function info
// OBSOLETE           How to get vtable offsets ? 
// OBSOLETE           Assuming normal for now FIXME!! 
// OBSOLETE           For vtables, figure out from whence this virtual function came.
// OBSOLETE           It may belong to virtual function table of
// OBSOLETE           one of its baseclasses.
// OBSOLETE           set:
// OBSOLETE           new_sublist -> fn_field.voffset = vtable offset,
// OBSOLETE           new_sublist -> fn_field.fcontext = look_ahead_type;
// OBSOLETE           where look_ahead_type is type of baseclass */
// OBSOLETE        if (is_static)
// OBSOLETE  	new_sublist->fn_field.voffset = VOFFSET_STATIC;
// OBSOLETE        else			/* normal member function.  */
// OBSOLETE  	new_sublist->fn_field.voffset = 0;
// OBSOLETE        new_sublist->fn_field.fcontext = 0;


// OBSOLETE        /* Prepare new sublist */
// OBSOLETE        new_sublist->next = sublist;
// OBSOLETE        sublist = new_sublist;
// OBSOLETE        length++;

// OBSOLETE        /* In g++, we loop thu sublists - now we set from functions. */
// OBSOLETE        new_fnlist->fn_fieldlist.fn_fields = (struct fn_field *)
// OBSOLETE  	obstack_alloc (&objfile->type_obstack,
// OBSOLETE  		       sizeof (struct fn_field) * length);
// OBSOLETE        memset (new_fnlist->fn_fieldlist.fn_fields, 0,
// OBSOLETE  	      sizeof (struct fn_field) * length);
// OBSOLETE        for (i = length; (i--, sublist); sublist = sublist->next)
// OBSOLETE  	{
// OBSOLETE  	  new_fnlist->fn_fieldlist.fn_fields[i] = sublist->fn_field;
// OBSOLETE  	}

// OBSOLETE        new_fnlist->fn_fieldlist.length = length;
// OBSOLETE        new_fnlist->next = fip->fnlist;
// OBSOLETE        fip->fnlist = new_fnlist;
// OBSOLETE        nfn_fields++;
// OBSOLETE        total_length += length;
// OBSOLETE        STABS_CONTINUE (pp, objfile);	/* handle \\ */
// OBSOLETE      }				/* end of loop */

// OBSOLETE    if (nfn_fields)
// OBSOLETE      {
// OBSOLETE        /* type should already have space */
// OBSOLETE        TYPE_FN_FIELDLISTS (type) = (struct fn_fieldlist *)
// OBSOLETE  	TYPE_ALLOC (type, sizeof (struct fn_fieldlist) * nfn_fields);
// OBSOLETE        memset (TYPE_FN_FIELDLISTS (type), 0,
// OBSOLETE  	      sizeof (struct fn_fieldlist) * nfn_fields);
// OBSOLETE        TYPE_NFN_FIELDS (type) = nfn_fields;
// OBSOLETE        TYPE_NFN_FIELDS_TOTAL (type) = total_length;
// OBSOLETE      }

// OBSOLETE    /* end of scope for reading member func */

// OBSOLETE    /* eg: ";;" */

// OBSOLETE    /* Skip trailing ';' and bump count of number of fields seen */
// OBSOLETE    if (**pp == ';')
// OBSOLETE      (*pp)++;
// OBSOLETE    else
// OBSOLETE      return 0;
// OBSOLETE    return 1;
// OBSOLETE  }

// OBSOLETE  /* This routine fixes up partial cfront types that were created
// OBSOLETE     while parsing the stabs.  The main need for this function is
// OBSOLETE     to add information such as methods to classes.
// OBSOLETE     Examples of "p": "sA;;__ct__1AFv foo__1AFv ;;;" */
// OBSOLETE  int
// OBSOLETE  resolve_cfront_continuation (struct objfile *objfile, struct symbol *sym,
// OBSOLETE  			     char *p)
// OBSOLETE  {
// OBSOLETE    struct symbol *ref_sym = 0;
// OBSOLETE    char *sname;
// OBSOLETE    /* snarfed from read_struct_type */
// OBSOLETE    struct field_info fi;
// OBSOLETE    struct type *type;
// OBSOLETE    struct cleanup *back_to;

// OBSOLETE    /* Need to make sure that fi isn't gunna conflict with struct 
// OBSOLETE       in case struct already had some fnfs */
// OBSOLETE    fi.list = NULL;
// OBSOLETE    fi.fnlist = NULL;
// OBSOLETE    back_to = make_cleanup (null_cleanup, 0);

// OBSOLETE    /* We only accept structs, classes and unions at the moment. 
// OBSOLETE       Other continuation types include t (typedef), r (long dbl), ... 
// OBSOLETE       We may want to add support for them as well; 
// OBSOLETE       right now they are handled by duplicating the symbol information 
// OBSOLETE       into the type information (see define_symbol) */
// OBSOLETE    if (*p != 's'			/* structs */
// OBSOLETE        && *p != 'c'		/* class */
// OBSOLETE        && *p != 'u')		/* union */
// OBSOLETE      return 0;			/* only handle C++ types */
// OBSOLETE    p++;

// OBSOLETE    /* Get symbol typs name and validate 
// OBSOLETE       eg: p = "A;;__ct__1AFv foo__1AFv ;;;" */
// OBSOLETE    sname = get_substring (&p, ';');
// OBSOLETE    if (!sname || strcmp (sname, SYMBOL_NAME (sym)))
// OBSOLETE      error ("Internal error: base symbol type name does not match\n");

// OBSOLETE    /* Find symbol's internal gdb reference using demangled_name.
// OBSOLETE       This is the real sym that we want; 
// OBSOLETE       sym was a temp hack to make debugger happy */
// OBSOLETE    ref_sym = lookup_symbol (SYMBOL_NAME (sym), 0, STRUCT_NAMESPACE, 0, 0);
// OBSOLETE    type = SYMBOL_TYPE (ref_sym);


// OBSOLETE    /* Now read the baseclasses, if any, read the regular C struct or C++
// OBSOLETE       class member fields, attach the fields to the type, read the C++
// OBSOLETE       member functions, attach them to the type, and then read any tilde
// OBSOLETE       field (baseclass specifier for the class holding the main vtable). */

// OBSOLETE    if (!read_cfront_baseclasses (&fi, &p, type, objfile)
// OBSOLETE    /* g++ does this next, but cfront already did this: 
// OBSOLETE       || !read_struct_fields (&fi, &p, type, objfile) */
// OBSOLETE        || !copy_cfront_struct_fields (&fi, type, objfile)
// OBSOLETE        || !read_cfront_member_functions (&fi, &p, type, objfile)
// OBSOLETE        || !read_cfront_static_fields (&fi, &p, type, objfile)
// OBSOLETE        || !attach_fields_to_type (&fi, type, objfile)
// OBSOLETE        || !attach_fn_fields_to_type (&fi, type)
// OBSOLETE    /* g++ does this next, but cfront doesn't seem to have this: 
// OBSOLETE       || !read_tilde_fields (&fi, &p, type, objfile) */
// OBSOLETE      )
// OBSOLETE      {
// OBSOLETE        type = error_type (&p, objfile);
// OBSOLETE      }

// OBSOLETE    do_cleanups (back_to);
// OBSOLETE    return 0;
// OBSOLETE  }
// OBSOLETE  /* End of code added to support parsing of ARM/Cfront stabs strings */
#endif /* OBSOLETE CFront */
d1369 7
a1375 1
	    SYMBOL_SET_NAMES (sym, s, nlen, objfile);
d1381 5
a1385 1
	      SYMBOL_SET_NAMES (sym, string, nlen, objfile);
d1395 23
a1417 1
      SYMBOL_SET_NAMES (sym, string, p - string, objfile);
d1572 3
a1574 7
      /* All functions in C++ have prototypes.  Stabs does not offer an
         explicit way to identify prototyped or unprototyped functions,
         but both GCC and Sun CC emit stabs for the "call-as" type rather
         than the "declared-as" type for unprototyped functions, so
         we treat all functions as if they were prototyped.  This is used
         primarily for promotion when calling the function from GDB.  */
      TYPE_FLAGS (SYMBOL_TYPE (sym)) |= TYPE_FLAG_PROTOTYPED;
d1679 7
a1685 1
      SYMBOL_CLASS (sym) = LOC_ARG;
d1983 7
a1989 9
#if 0 /* OBSOLETE CFront */
// OBSOLETE      /* The semantics of C++ state that "struct foo { ... }" also defines 
// OBSOLETE         a typedef for "foo".  Unfortunately, cfront never makes the typedef
// OBSOLETE         when translating C++ into C.  We make the typedef here so that
// OBSOLETE         "ptype foo" works as expected for cfront translated code.  */
// OBSOLETE       else if ((current_subfile->language == language_cplus)
// OBSOLETE 	       || (current_subfile->language == language_objc))
// OBSOLETE 	synonym = 1;
#endif /* OBSOLETE CFront */
d1992 1
a1992 1
 
d2040 5
d2084 25
a2108 26
#if 0 /* OBSOLETE CFront */
// OBSOLETE        /* New code added to support cfront stabs strings.
// OBSOLETE           Note: case 'P' already handled above */
// OBSOLETE      case 'Z':
// OBSOLETE        /* Cfront type continuation coming up!
// OBSOLETE           Find the original definition and add to it.
// OBSOLETE           We'll have to do this for the typedef too,
// OBSOLETE           since we cloned the symbol to define a type in read_type.
// OBSOLETE           Stabs info examples:
// OBSOLETE           __1C :Ztl 
// OBSOLETE           foo__1CFv :ZtF (first def foo__1CFv:F(0,3);(0,24))
// OBSOLETE           C:ZsC;;__ct__1CFv func1__1CFv func2__1CFv ... ;;;
// OBSOLETE           where C is the name of the class.
// OBSOLETE           Unfortunately, we can't lookup the original symbol yet 'cuz 
// OBSOLETE           we haven't finished reading all the symbols.
// OBSOLETE           Instead, we save it for processing later */
// OBSOLETE        process_later (sym, p, resolve_cfront_continuation);
// OBSOLETE        SYMBOL_TYPE (sym) = error_type (&p, objfile);	/* FIXME! change later */
// OBSOLETE        SYMBOL_CLASS (sym) = LOC_CONST;
// OBSOLETE        SYMBOL_VALUE (sym) = 0;
// OBSOLETE        SYMBOL_NAMESPACE (sym) = VAR_NAMESPACE;
// OBSOLETE        /* Don't add to list - we'll delete it later when 
// OBSOLETE           we add the continuation to the real sym */
// OBSOLETE        return sym;
// OBSOLETE        /* End of new code added to support cfront stabs strings */
#endif /* OBSOLETE CFront */
d2578 18
d2674 12
d2692 12
d2810 6
d3073 1
a3073 5
    {
      complaint (&symfile_complaints,
		 "Method has bad physname %s\n", physname);
      return;
    }
d3674 27
a3700 28
#if 0 /* OBSOLETE CFront */
// OBSOLETE    /* The following is code to work around cfront generated stabs.
// OBSOLETE       The stabs contains full mangled name for each field.
// OBSOLETE       We try to demangle the name and extract the field name out of it.
// OBSOLETE     */
// OBSOLETE    if (ARM_DEMANGLING && current_subfile->language == language_cplus)
// OBSOLETE      {
// OBSOLETE        char save_p;
// OBSOLETE        char *dem, *dem_p;
// OBSOLETE        save_p = *p;
// OBSOLETE        *p = '\0';
// OBSOLETE        dem = cplus_demangle (*pp, DMGL_ANSI | DMGL_PARAMS);
// OBSOLETE        if (dem != NULL)
// OBSOLETE  	{
// OBSOLETE  	  dem_p = strrchr (dem, ':');
// OBSOLETE  	  if (dem_p != 0 && *(dem_p - 1) == ':')
// OBSOLETE  	    dem_p++;
// OBSOLETE  	  FIELD_NAME (fip->list->field) =
// OBSOLETE  	    obsavestring (dem_p, strlen (dem_p), &objfile->type_obstack);
// OBSOLETE  	}
// OBSOLETE        else
// OBSOLETE  	{
// OBSOLETE  	  FIELD_NAME (fip->list->field) =
// OBSOLETE  	    obsavestring (*pp, p - *pp, &objfile->type_obstack);
// OBSOLETE  	}
// OBSOLETE        *p = save_p;
// OBSOLETE      }
// OBSOLETE    /* end of code for cfront work around */
d3702 1
a3702 2
// OBSOLETE   else
#endif /* OBSOLETE CFront */
d3856 4
d3904 3
a3906 3
      /* (the deleted) chill the list of fields: the last entry (at
         the head) is a partially constructed entry which we now
         scrub. */
d4159 129
a4287 131
#if 0 /* OBSOLETE CFront */
// OBSOLETE  /* read cfront class static data.
// OBSOLETE     pp points to string starting with the list of static data
// OBSOLETE     eg: A:ZcA;1@@Bpub v2@@Bvirpri;__ct__1AFv func__1AFv *sfunc__1AFv ;as__1A ;;
// OBSOLETE     ^^^^^^^^

// OBSOLETE     A:ZcA;;foopri__1AFv foopro__1AFv __ct__1AFv __ct__1AFRC1A foopub__1AFv ;;;
// OBSOLETE     ^
// OBSOLETE   */

// OBSOLETE  static int
// OBSOLETE  read_cfront_static_fields (struct field_info *fip, char **pp, struct type *type,
// OBSOLETE  			   struct objfile *objfile)
// OBSOLETE  {
// OBSOLETE    struct nextfield *new;
// OBSOLETE    struct type *stype;
// OBSOLETE    char *sname;
// OBSOLETE    struct symbol *ref_static = 0;

// OBSOLETE    if (**pp == ';')		/* no static data; return */
// OBSOLETE      {
// OBSOLETE        ++(*pp);
// OBSOLETE        return 1;
// OBSOLETE      }

// OBSOLETE    /* Process each field in the list until we find the terminating ";" */

// OBSOLETE    /* eg: p = "as__1A ;;;" */
// OBSOLETE    STABS_CONTINUE (pp, objfile);	/* handle \\ */
// OBSOLETE    while (**pp != ';' && (sname = get_substring (pp, ' '), sname))
// OBSOLETE      {
// OBSOLETE        ref_static = lookup_symbol (sname, 0, VAR_NAMESPACE, 0, 0);	/*demangled_name */
// OBSOLETE        if (!ref_static)
// OBSOLETE  	{
// OBSOLETE  	  complaint (&symfile_complaints,
// OBSOLETE  		     "Unable to find symbol for static data field %s", sname);
// OBSOLETE  	  continue;
// OBSOLETE  	}
// OBSOLETE        stype = SYMBOL_TYPE (ref_static);

// OBSOLETE        /* allocate a new fip */
// OBSOLETE        new = (struct nextfield *) xmalloc (sizeof (struct nextfield));
// OBSOLETE        make_cleanup (xfree, new);
// OBSOLETE        memset (new, 0, sizeof (struct nextfield));
// OBSOLETE        new->next = fip->list;
// OBSOLETE        fip->list = new;

// OBSOLETE        /* set visibility */
// OBSOLETE        /* FIXME! no way to tell visibility from stabs??? */
// OBSOLETE        new->visibility = VISIBILITY_PUBLIC;

// OBSOLETE        /* set field info into fip */
// OBSOLETE        fip->list->field.type = stype;

// OBSOLETE        /* set bitpos & bitsize */
// OBSOLETE        SET_FIELD_PHYSNAME (fip->list->field, savestring (sname, strlen (sname)));

// OBSOLETE        /* set name field */
// OBSOLETE        /* The following is code to work around cfront generated stabs.
// OBSOLETE           The stabs contains full mangled name for each field.
// OBSOLETE           We try to demangle the name and extract the field name out of it.
// OBSOLETE         */
// OBSOLETE        if (ARM_DEMANGLING)
// OBSOLETE  	{
// OBSOLETE  	  char *dem, *dem_p;
// OBSOLETE  	  dem = cplus_demangle (sname, DMGL_ANSI | DMGL_PARAMS);
// OBSOLETE  	  if (dem != NULL)
// OBSOLETE  	    {
// OBSOLETE  	      dem_p = strrchr (dem, ':');
// OBSOLETE  	      if (dem_p != 0 && *(dem_p - 1) == ':')
// OBSOLETE  		dem_p++;
// OBSOLETE  	      fip->list->field.name =
// OBSOLETE  		obsavestring (dem_p, strlen (dem_p), &objfile->type_obstack);
// OBSOLETE  	    }
// OBSOLETE  	  else
// OBSOLETE  	    {
// OBSOLETE  	      fip->list->field.name =
// OBSOLETE  		obsavestring (sname, strlen (sname), &objfile->type_obstack);
// OBSOLETE  	    }
// OBSOLETE  	}			/* end of code for cfront work around */
// OBSOLETE      }				/* loop again for next static field */
// OBSOLETE    return 1;
// OBSOLETE  }

// OBSOLETE  /* Copy structure fields to fip so attach_fields_to_type will work.
// OBSOLETE     type has already been created with the initial instance data fields.
// OBSOLETE     Now we want to be able to add the other members to the class,
// OBSOLETE     so we want to add them back to the fip and reattach them again
// OBSOLETE     once we have collected all the class members. */

// OBSOLETE  static int
// OBSOLETE  copy_cfront_struct_fields (struct field_info *fip, struct type *type,
// OBSOLETE  			   struct objfile *objfile)
// OBSOLETE  {
// OBSOLETE    int nfields = TYPE_NFIELDS (type);
// OBSOLETE    int i;
// OBSOLETE    struct nextfield *new;

// OBSOLETE    /* Copy the fields into the list of fips and reset the types 
// OBSOLETE       to remove the old fields */

// OBSOLETE    for (i = 0; i < nfields; i++)
// OBSOLETE      {
// OBSOLETE        /* allocate a new fip */
// OBSOLETE        new = (struct nextfield *) xmalloc (sizeof (struct nextfield));
// OBSOLETE        make_cleanup (xfree, new);
// OBSOLETE        memset (new, 0, sizeof (struct nextfield));
// OBSOLETE        new->next = fip->list;
// OBSOLETE        fip->list = new;

// OBSOLETE        /* copy field info into fip */
// OBSOLETE        new->field = TYPE_FIELD (type, i);
// OBSOLETE        /* set visibility */
// OBSOLETE        if (TYPE_FIELD_PROTECTED (type, i))
// OBSOLETE  	new->visibility = VISIBILITY_PROTECTED;
// OBSOLETE        else if (TYPE_FIELD_PRIVATE (type, i))
// OBSOLETE  	new->visibility = VISIBILITY_PRIVATE;
// OBSOLETE        else
// OBSOLETE  	new->visibility = VISIBILITY_PUBLIC;
// OBSOLETE      }
// OBSOLETE    /* Now delete the fields from the type since we will be 
// OBSOLETE       allocing new space once we get the rest of the fields 
// OBSOLETE       in attach_fields_to_type.
// OBSOLETE       The pointer TYPE_FIELDS(type) is left dangling but should 
// OBSOLETE       be freed later by objstack_free */
// OBSOLETE    TYPE_FIELDS (type) = 0;
// OBSOLETE    TYPE_NFIELDS (type) = 0;

// OBSOLETE    return 1;
// OBSOLETE  }
#endif /* OBSOLETE CFront */
d4513 5
d4531 3
d4535 1
d4596 12
d4845 6
a4850 1
  upper_limit = LONG_MAX / radix;
d5044 7
a5050 1
    return init_type (TYPE_CODE_INT, 1, TYPE_FLAG_NOSIGN, NULL, objfile);
d5556 4
@


1.41.2.8
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d423 1
a423 1
	      DEPRECATED_SYMBOL_NAME (sym) =
d943 1
a943 1
// OBSOLETE    if (!sname || strcmp (sname, DEPRECATED_SYMBOL_NAME (sym)))
d949 1
a949 1
// OBSOLETE    ref_sym = lookup_symbol (DEPRECATED_SYMBOL_NAME (sym), 0, STRUCT_NAMESPACE, 0, 0);
d1076 1
a1076 1
  DEPRECATED_SYMBOL_NAME (sym) = DEPRECATED_SYMBOL_NAME (ref_sym);
d1280 1
a1280 1
	  DEPRECATED_SYMBOL_NAME (sym) = obsavestring ("this", strlen ("this"),
d1285 1
a1285 1
	  /* Was: DEPRECATED_SYMBOL_NAME (sym) = "vptr"; */
d1289 1
a1289 1
	  DEPRECATED_SYMBOL_NAME (sym) = obsavestring ("eh_throw", strlen ("eh_throw"),
d1327 1
a1327 1
         the correct name into DEPRECATED_SYMBOL_NAME.  */
d1334 1
a1334 1
	    /* FIXME! Want DEPRECATED_SYMBOL_NAME (sym) = 0;
d1579 1
a1579 1
      if (DEPRECATED_SYMBOL_NAME (sym) && DEPRECATED_SYMBOL_NAME (sym)[0] != '#')
d1581 1
a1581 1
	  i = hashname (DEPRECATED_SYMBOL_NAME (sym));
d1781 1
a1781 1
		  && STREQ (DEPRECATED_SYMBOL_NAME (prev_sym), DEPRECATED_SYMBOL_NAME (sym)))
d1804 1
a1804 1
      if (IS_STATIC_TRANSFORM_NAME (DEPRECATED_SYMBOL_NAME (sym)))
d1807 1
a1807 1
	  msym = lookup_minimal_symbol (DEPRECATED_SYMBOL_NAME (sym), NULL, objfile);
d1810 1
a1810 1
	      DEPRECATED_SYMBOL_NAME (sym) = STATIC_TRANSFORM_NAME (DEPRECATED_SYMBOL_NAME (sym));
d1855 1
a1855 1
	       && strcmp (DEPRECATED_SYMBOL_NAME (sym), vtbl_ptr_name))
d1895 1
a1895 1
		  TYPE_NAME (SYMBOL_TYPE (sym)) = DEPRECATED_SYMBOL_NAME (sym);
d1899 1
a1899 1
	    TYPE_NAME (SYMBOL_TYPE (sym)) = DEPRECATED_SYMBOL_NAME (sym);
d1934 1
a1934 1
	  = obconcat (&objfile->type_obstack, "", "", DEPRECATED_SYMBOL_NAME (sym));
d1948 1
a1948 1
	      = obconcat (&objfile->type_obstack, "", "", DEPRECATED_SYMBOL_NAME (sym));
d1959 1
a1959 1
      if (IS_STATIC_TRANSFORM_NAME (DEPRECATED_SYMBOL_NAME (sym)))
d1962 1
a1962 1
	  msym = lookup_minimal_symbol (DEPRECATED_SYMBOL_NAME (sym), NULL, objfile);
d1965 1
a1965 1
	      DEPRECATED_SYMBOL_NAME (sym) = STATIC_TRANSFORM_NAME (DEPRECATED_SYMBOL_NAME (sym));
d2398 1
a2398 1
		  && STREQ (DEPRECATED_SYMBOL_NAME (sym), type_name))
d4500 1
a4500 1
      DEPRECATED_SYMBOL_NAME (sym) = name;
d4542 1
a4542 1
	  TYPE_FIELD_NAME (type, n) = DEPRECATED_SYMBOL_NAME (xsym);
d5075 1
a5075 1
  DEPRECATED_SYMBOL_NAME (sym) = common_block_name;
d5102 1
a5102 1
  i = hashname (DEPRECATED_SYMBOL_NAME (sym));
d5193 1
a5193 1
			    && STREQ (DEPRECATED_SYMBOL_NAME (sym), typename))
d5249 1
a5249 1
	   msymbol && DEPRECATED_SYMBOL_NAME (msymbol) != NULL;
d5270 1
a5270 1
	  hash = hashname (DEPRECATED_SYMBOL_NAME (msymbol));
d5274 2
a5275 2
	      if (DEPRECATED_SYMBOL_NAME (msymbol)[0] == DEPRECATED_SYMBOL_NAME (sym)[0] &&
		  STREQ (DEPRECATED_SYMBOL_NAME (msymbol) + 1, DEPRECATED_SYMBOL_NAME (sym) + 1))
d5367 1
a5367 1
		       objfile->name, DEPRECATED_SYMBOL_NAME (prev));
@


1.41.2.9
log
@2003-03-07  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_partial_symbol): Replace uses of
	SYMBOL_MATCHES_NATURAL_NAME by equivalent uses of
	SYMBOL_NATURAL_NAME, strcmp_iw.
	* symtab.h (SYMBOL_MATCHES_NATURAL_NAME): Delete.
	* minsyms.c (lookup_minimal_symbol_linkage): Make static.
	(lookup_minimal_symbol_natural): Ditto.
	(lookup_minimal_symbol): Only search on linkage names; rename
	first argument to 'linkage_name'.
	(lookup_minimal_symbol_linkage): Delete.
	(lookup_minimal_symbol_natural): Delete.
	(add_minsym_to_demangled_hash_table): Go back to using
	SYMBOL_DEMANGLED_NAME instead of SYMBOL_NATURAL_NAME.
	(lookup_minimal_symbol_aux): Don't use
	SYMBOL_MATCHES_NATURAL_NAME: do a strcmp_iw on
	SYMBOL_DEMANGLED_NAME instead.  Add comment.
	(build_minimal_symbol_hash_tables): Go back to only adding to
	demangled has table if SYMBOL_DEMANGLED_NAME is non-NULL.
	* symtab.h: Delete declarations for lookup_minimal_symbol_linkage
	and lookup_minimal_symbol_natural.
	* valops.c (find_function_in_inferior): Use lookup_symbol_linkage
	instead of lookup_symbol.  Change comment.
	* remote.c (remote_check_symbols): Use
	lookup_minimal_symbol_linkage_or_natural instead of
	lookup_minimal_symbol, but add FIXME comment as well.
	* objc-lang.c: Ditto.
	* c-exp.y: Use lookup_minimal_symbol_linkage_or_natural instead of
	lookup_minimal_symbol.
	* p-exp.y: Ditto.
	* objc-exp.y: Ditto.
	* m2-exp.y: Ditto.
	* jv-exp.y (push_expression_name): Ditto.
	* f-exp.y: Ditto.
	* printcmd.c (address_info): Ditto.
	* symtab.h: Declare lookup_minimal_symbol_linkage_or_natural.
	* minsyms.c (lookup_minimal_symbol_linkage_or_natural): New.
	* ax-gdb.c (gen_var_ref): Use SYMBOL_LINKAGE_NAME instead of
	DEPRECATED_SYMBOL_NAME.
	* tracepoint.c (scope_info): Ditto.
	* symtab.c (find_pc_sect_line): Ditto.
	* stabsread.c (define_symbol): Ditto.
	* sol-thread.c (info_cb): Ditto.
	* printcmd.c (address_info): Ditto.
	* hppa-tdep.c (hppa_fix_call_dummy): Ditto.
	(hppa_in_solib_call_trampoline): Ditto.
	* findvar.c (read_var_value): Ditto.
@
text
@d1804 1
a1804 1
      if (IS_STATIC_TRANSFORM_NAME (SYMBOL_LINKAGE_NAME (sym)))
d1807 1
a1807 1
	  msym = lookup_minimal_symbol (SYMBOL_LINKAGE_NAME (sym), NULL, objfile);
d1810 1
a1810 1
	      SYMBOL_LINKAGE_NAME (sym) = STATIC_TRANSFORM_NAME (SYMBOL_LINKAGE_NAME (sym));
d1962 1
a1962 1
	  msym = lookup_minimal_symbol (SYMBOL_LINKAGE_NAME (sym), NULL, objfile);
d1965 1
a1965 1
	      SYMBOL_LINKAGE_NAME (sym) = STATIC_TRANSFORM_NAME (SYMBOL_LINKAGE_NAME (sym));
@


1.41.2.10
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d421 1
a421 1
	      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d680 1
a680 1
// OBSOLETE  	bsym = lookup_symbol (bname, 0, STRUCT_DOMAIN, 0, 0);	/*demangled_name */
d753 1
a753 1
// OBSOLETE        ref_func = lookup_symbol (fname, 0, VAR_DOMAIN, 0, 0);		/* demangled name */
d949 1
a949 1
// OBSOLETE    ref_sym = lookup_symbol (DEPRECATED_SYMBOL_NAME (sym), 0, STRUCT_DOMAIN, 0, 0);
d1382 1
a1382 1
	  SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d1475 1
a1475 1
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d1483 1
a1483 1
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d1492 1
a1492 1
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d1563 1
a1563 1
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d1574 1
a1574 1
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d1596 1
a1596 1
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d1616 1
a1616 1
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d1728 1
a1728 1
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d1744 1
a1744 1
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d1815 1
a1815 1
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d1830 1
a1830 1
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d1931 1
a1931 1
      SYMBOL_DOMAIN (sym) = STRUCT_DOMAIN;
d1945 1
a1945 1
	  SYMBOL_DOMAIN (typedef_sym) = VAR_DOMAIN;
d1970 1
a1970 1
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d1979 1
a1979 1
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d1995 1
a1995 1
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d2007 1
a2007 1
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d2030 1
a2030 1
// OBSOLETE        SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d2041 1
a2041 1
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d2396 1
a2396 1
		  && SYMBOL_DOMAIN (sym) == STRUCT_DOMAIN
d4071 1
a4071 1
// OBSOLETE        ref_static = lookup_symbol (sname, 0, VAR_DOMAIN, 0, 0);	/*demangled_name */
d4503 1
a4503 1
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d5190 1
a5190 1
			    && SYMBOL_DOMAIN (sym) == STRUCT_DOMAIN
@


1.41.2.11
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@a107 2
static struct type *read_type (char **, struct objfile *);

a148 2
static void add_undefined_type (struct type *);

d251 1
a251 1
static struct type **
d2262 1
a2262 1
static struct type *
d5131 1
a5131 1
static void
@


1.41.2.12
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d258 2
a259 2
  int filenum = typenums[0];
  int index = typenums[1];
d261 2
a262 2
  int real_filenum;
  struct header_file *f;
d359 1
a359 1
  struct type **type_addr;
d471 1
a471 1
read_type_number (char **pp, int *typenums)
d1219 1
a1219 1
  struct symbol *sym;
d1223 1
a1223 1
  int i;
d1755 1
a1755 1
	     regardless of DEPRECATED_REG_STRUCT_HAS_ADDR, because the compiler puts out
d1771 2
a1772 2
	      && DEPRECATED_REG_STRUCT_HAS_ADDR_P ()
	      && DEPRECATED_REG_STRUCT_HAS_ADDR (processing_gcc_compilation,
d1944 1
a1944 1
	  struct symbol *typedef_sym = (struct symbol *)
d2053 2
a2054 2
  if (DEPRECATED_REG_STRUCT_HAS_ADDR_P ()
      && DEPRECATED_REG_STRUCT_HAS_ADDR (processing_gcc_compilation, SYMBOL_TYPE (sym))
d2064 1
a2064 1
	  /* If DEPRECATED_REG_STRUCT_HAS_ADDR yields non-zero we have to convert
d2267 1
a2267 1
read_type (char **pp, struct objfile *objfile)
d2269 1
a2269 1
  struct type *type = 0;
d3007 1
a3007 1
  char *p;
d3468 1
a3468 1
  char *p;
d3730 1
a3730 1
  char *p;
d3951 1
a3951 1
  char *p;
d4030 1
a4030 1
attach_fn_fields_to_type (struct field_info *fip, struct type *type)
d4032 1
a4032 1
  int n;
d4181 1
a4181 1
attach_fields_to_type (struct field_info *fip, struct type *type,
d4184 3
a4186 3
  int nfields = 0;
  int non_public_fields = 0;
  struct nextfield *scan;
d4385 1
a4385 1
read_array_type (char **pp, struct type *type,
d4448 1
a4448 1
read_enum_type (char **pp, struct type *type,
d4451 1
a4451 1
  char *p;
d4453 2
a4454 2
  long n;
  struct symbol *sym;
d5122 1
a5122 1
      int j;
@


1.41.2.13
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d156 22
d181 5
d190 3
d500 586
d1214 1
d1313 35
d1751 11
a1761 14
	  /* Sun cc uses a pair of symbols, one 'p' and one 'r', with
	     the same name to represent an argument passed in a
	     register.  GCC uses 'P' for the same case.  So if we find
	     such a symbol pair we combine it into one 'P' symbol.
	     For Sun cc we need to do this regardless of
	     stabs_argument_has_addr, because the compiler puts out
	     the 'p' symbol even if it never saves the argument onto
	     the stack.

	     On most machines, we want to preserve both symbols, so
	     that we can still get information about what is going on
	     with the stack (VAX for computing args_printed, using
	     stack slots instead of saved registers in backtraces,
	     etc.).
d1771 7
a1777 2
	      && gdbarch_stabs_argument_has_addr (current_gdbarch,
						  SYMBOL_TYPE (sym))
d1785 1
a1785 2
		  && strcmp (DEPRECATED_SYMBOL_NAME (prev_sym),
			     DEPRECATED_SYMBOL_NAME (sym)) == 0)
d1916 9
d2014 26
d2050 2
a2051 3
  /* Some systems pass variables of certain types by reference instead
     of by value, i.e. they will pass the address of a structure (in a
     register or on the stack) instead of the structure itself.  */
d2053 2
a2054 1
  if (gdbarch_stabs_argument_has_addr (current_gdbarch, SYMBOL_TYPE (sym))
d2057 16
a2072 8
      /* We have to convert LOC_REGPARM to LOC_REGPARM_ADDR (for
         variables passed in a register).  */
      if (SYMBOL_CLASS (sym) == LOC_REGPARM)
	SYMBOL_CLASS (sym) = LOC_REGPARM_ADDR;
      /* Likewise for converting LOC_ARG to LOC_REF_ARG (for the 7th
	 and subsequent arguments on SPARC, for example).  */
      else if (SYMBOL_CLASS (sym) == LOC_ARG)
	SYMBOL_CLASS (sym) = LOC_REF_ARG;
d2075 23
d2101 104
d2402 1
a2402 1
		  && strcmp (DEPRECATED_SYMBOL_NAME (sym), type_name) == 0)
d3561 33
a3593 2
  fip->list->field.name =
    obsavestring (*pp, p - *pp, &objfile->type_obstack);
d4044 132
d5197 1
a5197 1
			    && strcmp (DEPRECATED_SYMBOL_NAME (sym), typename) == 0)
d5227 1
a5227 1
  struct symbol *sym, *prev;
d5279 1
a5279 1
		  strcmp (DEPRECATED_SYMBOL_NAME (msymbol) + 1, DEPRECATED_SYMBOL_NAME (sym) + 1) == 0)
d5281 3
d5298 10
a5307 1
		  if (sym)
d5309 1
a5309 1
		      if (SYMBOL_CLASS (sym) == LOC_BLOCK)
d5311 1
a5311 1
			  fix_common_block (sym,
d5316 1
a5316 1
			  SYMBOL_VALUE_ADDRESS (sym)
d5319 8
a5326 1
		      SYMBOL_SECTION (sym) = SYMBOL_SECTION (msymbol);
d5328 1
@


1.41.2.14
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d1121 1
a1121 3
#ifndef DEPRECATED_USE_REGISTER_NOT_ARG
	      /* DEPRECATED_USE_REGISTER_NOT_ARG is only defined by
                 the SPARC.  */
d1565 5
a1569 3
        /* If this type has already been declared, then reuse the same
           type, rather than allocating a new one.  This saves some
           memory.  */
a1582 2
	          if (typenums[0] != -1)
	            *dbx_lookup_type (typenums) = type;
@


1.41.2.15
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d2 3
a4 4

   Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994,
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free
   Software Foundation, Inc.
d92 2
d161 2
d197 6
d536 10
d1121 3
d1125 3
a1127 1
						  SYMBOL_TYPE (sym)))
@


1.41.4.1
log
@        * stabsread.c (read_member_functions): Update comment.
        Set TYPE_NAME if possible.
@
text
@a3118 3
   If we read at least one method with a complete physname, set
   TYPE_NAME (TYPE) appropriately.

a3250 28

	  /* For classes with qualified names (e.g. nested classes, classes
	     in namespaces, etc.) we can infer what the fully qualified name
	     should be.  GCC doesn't output this information directly,
	     but it does output mangled names for methods:
	     - Every class will have debug information for at least one
	     constructor, either user specified or compiler-synthesized.
	     - For v3 there are no abbreviated physnames, so we can find the
	     fully qualified class name from such a constructor.
	     - For v2 constructors (related to the fact that the mangled name
	     for a constructor starts with a double underscore instead of
	     with the method name, as for ordinary methods) the full physname
	     will be included.

	     So from a constructor we can infer the class's qualified name.  */

	  if (TYPE_NAME (type) == NULL
	      && is_constructor_name (new_sublist->fn_field.physname))
	    {
	      char *class_name
		= class_name_from_physname (new_sublist->fn_field.physname);

	      /* G++ anonymous structures have names starting with '.' or
		 '$'.  */
	      if (is_cplus_marker (class_name[0]))
		TYPE_NAME (type) = obconcat (&objfile->type_obstack, "",
					     "", class_name);
	    }
@


1.41.4.2
log
@Merge drow-cplus-merge-20021025 to drow-cplus-branch.
@
text
@a171 2
static char *find_name_end (char *name);

d188 4
a191 2
static const char vptr_name[] = "_vptr$";
static const char vb_name[] = "_vb$";
d1276 1
a1276 1
  char *p = (char *) find_name_end (string);
d2009 1
a2009 2
      else if ((current_subfile->language == language_cplus)
	       || (current_subfile->language == language_objc))
d3185 2
a3186 1
	  static char opname[32] = "op$";
d4172 2
a4173 3
		  char *name = TYPE_FIELD_NAME (t, i);
		  if (!strncmp (name, vptr_name, sizeof (vptr_name) - 2)
		      && is_cplus_marker (name[sizeof (vptr_name) - 2]))
a5648 26
    }
}

/* Find the end of the name, delimited by a ':', but don't match
   ObjC symbols which look like -[Foo bar::]:bla.  */
static char *
find_name_end (char *name)
{
  char *s = name;
  if (s[0] == '-' || *s == '+')
    {
      /* Must be an ObjC method symbol.  */
      if (s[1] != '[')
	{
	  error ("invalid symbol name \"%s\"", name);
	}
      s = strchr (s, ']');
      if (s == NULL)
	{
	  error ("invalid symbol name \"%s\"", name);
	}
      return strchr (s, ':');
    }
  else
    {
      return strchr (s, ':');
@


1.41.4.3
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d3 1
a3 1
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
a107 2
static struct type *read_type (char **, struct objfile *);

d137 2
a138 2
static int attach_fields_to_type (struct field_info *, struct type *,
				  struct objfile *);
a148 2
static void add_undefined_type (struct type *);

d153 19
d174 7
d185 3
d201 27
d229 8
a236 5
static void
invalid_cpp_abbrev_complaint (const char *arg1)
{
  complaint (&symfile_complaints, "invalid C++ abbreviation `%s'", arg1);
}
d238 2
a239 7
static void
reg_value_complaint (int arg1, int arg2, const char *arg3)
{
  complaint (&symfile_complaints,
	     "register number %d too large (max %d) in symbol %s", arg1, arg2,
	     arg3);
}
d241 2
a242 5
static void
stabs_general_complaint (const char *arg1)
{
  complaint (&symfile_complaints, "%s", arg1);
}
d244 2
a245 5
static void
lrs_general_complaint (const char *arg1)
{
  complaint (&symfile_complaints, "%s", arg1);
}
d261 30
d299 1
a299 1
static struct type **
d302 2
a303 2
  int filenum = typenums[0];
  int index = typenums[1];
d305 2
a306 2
  int real_filenum;
  struct header_file *f;
d314 5
a318 3
      complaint (&symfile_complaints,
		 "Invalid symbol data: type number (%d,%d) out of range at symtab pos %d.",
		 filenum, index, symnum);
d357 6
d411 1
a411 1
  struct type **type_addr;
d477 1
a477 1
	      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d479 1
a479 1
	      DEPRECATED_SYMBOL_NAME (sym) =
d523 1
a523 1
read_type_number (char **pp, int *typenums)
d552 590
d1270 1
d1275 1
a1275 1
  struct symbol *sym;
d1279 1
a1279 1
  int i;
d1340 1
a1340 1
	  DEPRECATED_SYMBOL_NAME (sym) = obsavestring ("this", strlen ("this"),
d1345 1
a1345 1
	  /* Was: DEPRECATED_SYMBOL_NAME (sym) = "vptr"; */
d1349 1
a1349 1
	  DEPRECATED_SYMBOL_NAME (sym) = obsavestring ("eh_throw", strlen ("eh_throw"),
d1364 1
a1364 2
	  complaint (&symfile_complaints, "Unknown C++ symbol name `%s'",
		     string);
d1368 45
d1417 23
a1439 1
      SYMBOL_SET_NAMES (sym, string, p - string, objfile);
d1473 1
a1473 1
	  SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d1566 1
a1566 1
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d1574 1
a1574 1
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d1583 1
a1583 1
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d1594 3
a1596 7
      /* All functions in C++ have prototypes.  Stabs does not offer an
         explicit way to identify prototyped or unprototyped functions,
         but both GCC and Sun CC emit stabs for the "call-as" type rather
         than the "declared-as" type for unprototyped functions, so
         we treat all functions as if they were prototyped.  This is used
         primarily for promotion when calling the function from GDB.  */
      TYPE_FLAGS (SYMBOL_TYPE (sym)) |= TYPE_FLAG_PROTOTYPED;
d1650 1
a1650 1
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d1661 1
a1661 1
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d1666 1
a1666 1
      if (DEPRECATED_SYMBOL_NAME (sym) && DEPRECATED_SYMBOL_NAME (sym)[0] != '#')
d1668 1
a1668 1
	  i = hashname (DEPRECATED_SYMBOL_NAME (sym));
d1683 1
a1683 1
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d1701 7
a1707 1
      SYMBOL_CLASS (sym) = LOC_ARG;
d1709 1
a1709 1
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d1816 3
a1818 3
	  reg_value_complaint (SYMBOL_VALUE (sym),
			       NUM_REGS + NUM_PSEUDO_REGS,
			       SYMBOL_PRINT_NAME (sym));
d1821 1
a1821 1
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d1832 3
a1834 3
	  reg_value_complaint (SYMBOL_VALUE (sym),
			       NUM_REGS + NUM_PSEUDO_REGS,
			       SYMBOL_PRINT_NAME (sym));
d1837 1
a1837 1
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d1840 11
a1850 14
	  /* Sun cc uses a pair of symbols, one 'p' and one 'r', with
	     the same name to represent an argument passed in a
	     register.  GCC uses 'P' for the same case.  So if we find
	     such a symbol pair we combine it into one 'P' symbol.
	     For Sun cc we need to do this regardless of
	     stabs_argument_has_addr, because the compiler puts out
	     the 'p' symbol even if it never saves the argument onto
	     the stack.

	     On most machines, we want to preserve both symbols, so
	     that we can still get information about what is going on
	     with the stack (VAX for computing args_printed, using
	     stack slots instead of saved registers in backtraces,
	     etc.).
d1859 8
a1866 5
#ifndef DEPRECATED_USE_REGISTER_NOT_ARG
	      /* DEPRECATED_USE_REGISTER_NOT_ARG is only defined by
                 the SPARC.  */
	      && gdbarch_stabs_argument_has_addr (current_gdbarch,
						  SYMBOL_TYPE (sym))
d1874 1
a1874 2
		  && strcmp (DEPRECATED_SYMBOL_NAME (prev_sym),
			     DEPRECATED_SYMBOL_NAME (sym)) == 0)
d1897 1
a1897 1
      if (IS_STATIC_TRANSFORM_NAME (DEPRECATED_SYMBOL_NAME (sym)))
d1900 1
a1900 1
	  msym = lookup_minimal_symbol (DEPRECATED_SYMBOL_NAME (sym), NULL, objfile);
d1903 1
a1903 1
	      DEPRECATED_SYMBOL_NAME (sym) = STATIC_TRANSFORM_NAME (DEPRECATED_SYMBOL_NAME (sym));
d1908 1
a1908 1
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d1923 1
a1923 1
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d1948 1
a1948 1
	       && strcmp (DEPRECATED_SYMBOL_NAME (sym), vtbl_ptr_name))
d1988 1
a1988 1
		  TYPE_NAME (SYMBOL_TYPE (sym)) = DEPRECATED_SYMBOL_NAME (sym);
d1992 1
a1992 1
	    TYPE_NAME (SYMBOL_TYPE (sym)) = DEPRECATED_SYMBOL_NAME (sym);
d2005 7
d2014 1
a2014 1
 
d2022 1
a2022 1
      SYMBOL_DOMAIN (sym) = STRUCT_DOMAIN;
d2025 1
a2025 1
	  = obconcat (&objfile->type_obstack, "", "", DEPRECATED_SYMBOL_NAME (sym));
d2031 1
a2031 1
	  struct symbol *typedef_sym = (struct symbol *)
d2036 1
a2036 1
	  SYMBOL_DOMAIN (typedef_sym) = VAR_DOMAIN;
d2039 1
a2039 1
	      = obconcat (&objfile->type_obstack, "", "", DEPRECATED_SYMBOL_NAME (sym));
d2050 1
a2050 1
      if (IS_STATIC_TRANSFORM_NAME (DEPRECATED_SYMBOL_NAME (sym)))
d2053 1
a2053 1
	  msym = lookup_minimal_symbol (DEPRECATED_SYMBOL_NAME (sym), NULL, objfile);
d2056 1
a2056 1
	      DEPRECATED_SYMBOL_NAME (sym) = STATIC_TRANSFORM_NAME (DEPRECATED_SYMBOL_NAME (sym));
d2061 6
a2066 1
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d2075 1
a2075 1
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d2086 3
a2088 3
	  reg_value_complaint (SYMBOL_VALUE (sym),
			       NUM_REGS + NUM_PSEUDO_REGS,
			       SYMBOL_PRINT_NAME (sym));
d2091 1
a2091 1
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d2103 1
a2103 1
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d2107 25
d2136 1
a2136 1
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d2141 2
a2142 3
  /* Some systems pass variables of certain types by reference instead
     of by value, i.e. they will pass the address of a structure (in a
     register or on the stack) instead of the structure itself.  */
d2144 2
a2145 1
  if (gdbarch_stabs_argument_has_addr (current_gdbarch, SYMBOL_TYPE (sym))
d2148 16
a2163 8
      /* We have to convert LOC_REGPARM to LOC_REGPARM_ADDR (for
         variables passed in a register).  */
      if (SYMBOL_CLASS (sym) == LOC_REGPARM)
	SYMBOL_CLASS (sym) = LOC_REGPARM_ADDR;
      /* Likewise for converting LOC_ARG to LOC_REF_ARG (for the 7th
	 and subsequent arguments on SPARC, for example).  */
      else if (SYMBOL_CLASS (sym) == LOC_ARG)
	SYMBOL_CLASS (sym) = LOC_REF_ARG;
d2166 23
d2192 104
d2328 1
a2328 1
  complaint (&symfile_complaints, "couldn't parse type; debugger out of date?");
d2357 2
a2358 2
static struct type *
read_type (char **pp, struct objfile *objfile)
d2360 1
a2360 1
  struct type *type = 0;
d2438 3
a2440 2
		complaint (&symfile_complaints,
			   "Unrecognized cross-reference type `%c'", (*pp)[0]);
d2480 5
a2484 3
        /* If this type has already been declared, then reuse the same
           type, rather than allocating a new one.  This saves some
           memory.  */
d2492 1
a2492 1
		  && SYMBOL_DOMAIN (sym) == STRUCT_DOMAIN
d2494 1
a2494 1
		  && strcmp (DEPRECATED_SYMBOL_NAME (sym), type_name) == 0)
a2497 2
	          if (typenums[0] != -1)
	            *dbx_lookup_type (typenums) = type;
d2601 18
d2663 5
a2667 3
	    complaint (&symfile_complaints,
		       "Prototyped function type didn't end arguments with `#':\n%s",
		       type_start);
d2699 12
d2717 12
d2800 1
a2800 3
	    complaint (&symfile_complaints,
		       "invalid (minimal) member type data format at symtab pos %d.",
		       symnum);
d2833 6
d2933 1
a2933 1
      complaint (&symfile_complaints, "Unknown builtin type %d", typenum);
d3096 1
a3096 5
    {
      complaint (&symfile_complaints,
		 "Method has bad physname %s\n", physname);
      return;
    }
d3146 1
a3146 1
  char *p;
d3322 1
a3322 2
	      complaint (&symfile_complaints,
			 "const/volatile indicator missing, got '%c'", **pp);
d3404 1
a3404 2
	      complaint (&symfile_complaints,
			 "member function type missing, got '%c'", (*pp)[-1]);
d3633 1
a3633 1
  char *p;
d3669 1
a3669 3
	      complaint (&symfile_complaints,
			 "C++ abbreviated type name unknown at symtab pos %d",
			 symnum);
d3677 1
a3677 1
	  invalid_cpp_abbrev_complaint (*pp);
d3690 1
a3690 1
	  invalid_cpp_abbrev_complaint (*pp);
d3711 1
a3711 1
      invalid_cpp_abbrev_complaint (*pp);
d3724 31
a3754 2
  fip->list->field.name =
    obsavestring (*pp, p - *pp, &objfile->type_obstack);
d3795 1
a3795 1
      stabs_general_complaint ("bad structure-type format");
d3806 1
a3806 1
	stabs_general_complaint ("bad structure-type format");
d3812 1
a3812 1
	stabs_general_complaint ("bad structure-type format");
d3891 1
a3891 1
  char *p;
d3906 4
d3954 3
a3956 3
      /* (the deleted) chill the list of fields: the last entry (at
         the head) is a partially constructed entry which we now
         scrub. */
d4052 4
a4055 2
	    complaint (&symfile_complaints,
		       "Unknown virtual character `%c' for baseclass", **pp);
d4071 5
a4075 3
	    complaint (&symfile_complaints,
		       "Unknown visibility `%c' for baseclass",
		       new->visibility);
d4120 1
a4120 1
  char *p;
d4181 1
a4181 3
	      complaint (&symfile_complaints,
			 "virtual function table pointer not found when defining class `%s'",
			 TYPE_NAME (type));
d4197 1
a4197 1
attach_fn_fields_to_type (struct field_info *fip, struct type *type)
d4199 1
a4199 1
  int n;
d4211 133
d4349 1
a4349 1
attach_fields_to_type (struct field_info *fip, struct type *type,
d4352 3
a4354 3
  int nfields = 0;
  int non_public_fields = 0;
  struct nextfield *scan;
d4423 4
a4426 2
	    complaint (&symfile_complaints, "Unknown visibility `%c' for field",
		       fip->list->visibility);
d4436 4
d4470 1
a4470 2
  complaint (&symfile_complaints,
	     "struct/union type gets multiply defined: %s%s", kind, name);
d4558 1
a4558 1
read_array_type (char **pp, struct type *type,
d4573 5
d4591 3
d4595 1
d4630 1
a4630 1
read_enum_type (char **pp, struct type *type,
d4633 1
a4633 1
  char *p;
d4635 2
a4636 2
  long n;
  struct symbol *sym;
d4656 12
d4698 1
a4698 1
      DEPRECATED_SYMBOL_NAME (sym) = name;
d4701 1
a4701 1
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d4740 1
a4740 1
	  TYPE_FIELD_NAME (type, n) = DEPRECATED_SYMBOL_NAME (xsym);
d4905 6
a4910 1
  upper_limit = LONG_MAX / radix;
d5104 7
a5110 1
    return init_type (TYPE_CODE_INT, 1, TYPE_FLAG_NOSIGN, NULL, objfile);
d5172 1
a5172 2
      complaint (&symfile_complaints,
		 "base type %d of range type is not defined", rangenums[1]);
d5248 5
a5252 2
      complaint (&symfile_complaints,
		 "Invalid symbol data: common block within common block");
d5278 3
a5280 1
      complaint (&symfile_complaints, "ECOMM symbol unmatched by BCOMM");
d5288 1
a5288 1
  DEPRECATED_SYMBOL_NAME (sym) = common_block_name;
d5315 1
a5315 1
  i = hashname (DEPRECATED_SYMBOL_NAME (sym));
d5331 1
a5331 1
      int j;
d5344 1
a5344 1
static void
d5393 3
a5395 1
		    complaint (&symfile_complaints, "need a type name");
d5405 1
a5405 1
			    && SYMBOL_DOMAIN (sym) == STRUCT_DOMAIN
d5408 1
a5408 1
			    && strcmp (DEPRECATED_SYMBOL_NAME (sym), typename) == 0)
d5418 4
a5421 3
	    complaint (&symfile_complaints,
		       "GDB internal error.  cleanup_undefined_types with bad type %d.",
		       TYPE_CODE (*type));
d5439 1
a5439 1
  struct symbol *sym, *prev;
d5465 1
a5465 1
	   msymbol && DEPRECATED_SYMBOL_NAME (msymbol) != NULL;
d5486 1
a5486 1
	  hash = hashname (DEPRECATED_SYMBOL_NAME (msymbol));
d5490 2
a5491 2
	      if (DEPRECATED_SYMBOL_NAME (msymbol)[0] == DEPRECATED_SYMBOL_NAME (sym)[0] &&
		  strcmp (DEPRECATED_SYMBOL_NAME (msymbol) + 1, DEPRECATED_SYMBOL_NAME (sym) + 1) == 0)
d5493 3
d5510 10
a5519 1
		  if (sym)
d5521 1
a5521 1
		      if (SYMBOL_CLASS (sym) == LOC_BLOCK)
d5523 1
a5523 1
			  fix_common_block (sym,
d5528 1
a5528 1
			  SYMBOL_VALUE_ADDRESS (sym)
d5531 8
a5538 1
		      SYMBOL_SECTION (sym) = SYMBOL_SECTION (msymbol);
d5541 1
d5581 2
a5582 3
	    complaint (&symfile_complaints,
		       "%s: common block `%s' from global_sym_chain unresolved",
		       objfile->name, DEPRECATED_SYMBOL_NAME (prev));
d5622 4
@


1.41.4.4
log
@Merge mainline to branch.  GDB is broken until I update cp-names.y.
@
text
@d1121 3
d1125 3
a1127 1
						  SYMBOL_TYPE (sym)))
@


1.41.4.5
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d2 3
a4 4

   Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994,
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free
   Software Foundation, Inc.
d92 2
d161 2
d197 6
d391 1
a391 1
		obstack_alloc (&objfile->objfile_obstack,
d398 1
a398 1
		obsavestring (name, pp - name, &objfile->objfile_obstack);
d536 10
d634 1
a634 1
    obstack_alloc (&objfile->objfile_obstack, sizeof (struct symbol));
d668 1
a668 1
					    &objfile->objfile_obstack);
d677 1
a677 1
					    &objfile->objfile_obstack);
d760 1
a760 1
	      obstack_alloc (&objfile->objfile_obstack,
d1273 1
a1273 1
	  = obconcat (&objfile->objfile_obstack, "", "", DEPRECATED_SYMBOL_NAME (sym));
d1280 1
a1280 1
	  obstack_alloc (&objfile->objfile_obstack, sizeof (struct symbol));
d1287 1
a1287 1
	      = obconcat (&objfile->objfile_obstack, "", "", DEPRECATED_SYMBOL_NAME (sym));
d1549 1
a1549 1
	    (char *) obstack_alloc (&objfile->objfile_obstack, p - *pp + 1);
d1576 1
a1576 1
		  obstack_free (&objfile->objfile_obstack, type_name);
d2317 2
a2318 3
		TYPE_NAME (type) = obsavestring (&objfile->objfile_obstack,
						 class_name,
						 strlen (class_name));
d2564 1
a2564 1
		= obconcat (&objfile->objfile_obstack, "", "~",
d2568 1
a2568 1
		obstack_alloc (&objfile->objfile_obstack,
d2629 1
a2629 1
				  &objfile->objfile_obstack);
d2633 1
a2633 1
	    obstack_alloc (&objfile->objfile_obstack,
d2702 1
a2702 1
	    obconcat (&objfile->objfile_obstack, vptr_name, name, "");
d2715 1
a2715 1
	    obconcat (&objfile->objfile_obstack, vb_name, name, "");
d2721 1
a2721 1
	    obconcat (&objfile->objfile_obstack,
d2767 1
a2767 1
    obsavestring (*pp, p - *pp, &objfile->objfile_obstack);
d3537 1
a3537 1
      name = obsavestring (*pp, p - *pp, &objfile->objfile_obstack);
d3544 1
a3544 1
	obstack_alloc (&objfile->objfile_obstack, sizeof (struct symbol));
d4092 1
a4092 1
				    &objfile->objfile_obstack);
d4118 1
a4118 1
    obstack_alloc (&objfile->objfile_obstack, sizeof (struct symbol));
d4120 1
a4120 1
  /* Note: common_block_name already saved on objfile_obstack */
@


1.40
log
@2002-09-18  Michael Snyder  <msnyder@@redhat.com>

	Preliminary support for Objective-C:
	* defs.h (language_objc): New enum value.
	(puts_filtered_tabular): Declaration only, exported from utils.c.
	(skip_quoted): Delete, declared in completer.h.
	* c-exp.y: Include completer.h.
	* p-exp.y: Ditto.
	* jv-exp.y: Ditto.
	* expression.h (OP_MSGCALL, OP_SELECTOR, OP_SELF, OP_NSSTRING):
	New operator enum values.
	* language.h (CAST_IS_CONVERSION): Test for language_objc.
	* language.c (binop_result_type): Handle language_objc case.
	(integral_type, character_type, string_type, boolean_type,
	structured_type, binop_type_check): Ditto.
	* symtab.h (SYMBOL_OBJC_DEMANGLED_NAME): Define.
	(struct objc_specific): Add to general_symbol_info.
	(SYMBOL_INIT_LANGUAGE_SPECIFIC): Add objc initialization.
	(SYMBOL_DEMANGLED_NAME): Handle objc case.
	* parser-defs.h (struct objc_class_str): New struct type.
	(start_msglist, end_msglist, add_msglist): Declaration only,
	exported from objc-lang.c.
	* value.h (value_of_local, value_nsstring,
	call_function_by_hand_expecting_type): Exported from valops.c.
	* valops.c (find_function_addr): Export.
	(call_function_by_hand_expecting_type): New function.
	(value_of_local): New function.
	* symfile.c (init_filename_language_table): Add ".m" extension
	for Objective-C.
	* utils.c (puts_filtered_tabular): New function.
	(fprintf_symbol_filtered): Add objc demangling support (disabled).
	(set/show demangle): Extend help-string to refer to ObjC.
	* elfread.c (elf_symtab_read): Skip Objective-C special symbols.
	* stabsread.c (symbol_reference_defined): Objective-C symbols
	may contain colons: make allowances when scanning stabs strings
	for colons.
	(objc_find_colon): New function.
	* printcmd.c (address_info): If language == objc then print
	"self" instead of "this".
	* parse.c (length_of_subexp): Handle new operators OP_MSGCALL,
	OP_NSSTRING, and OP_SELF.
	(prefixify_subexp): Ditto.
	* source.c (print_source_lines): Mention objc in comment.
	* breakpoint.c (parse_breakpoint_sals): Recognize Objective-C
	method names.
@
text
@a1269 24
static char *
objc_find_colon (name)
     char *name;
{
  char *s = name;
  if (s[0] == '-' || *s == '+')
    {
      if (s[1] != '[')
	{
	  error ("invalid symbol name \"%s\"", name);
	}
      s = strchr (s, ']');
      if (s == NULL)
	{
	  error ("invalid symbol name \"%s\"", name);
	}
      return strchr (s, ':');
    }
  else
    {
      return strchr (s, ':');
    }
}

d1276 1
a1276 1
  char *p = (char *) objc_find_colon (string);
d2009 1
a2009 2
      else if ((current_subfile->language == language_cplus)
	       || (current_subfile->language == language_objc))
@


1.39
log
@        * gdbtypes.c (check_stub_method): Make static.
        (check_stub_method_group): New function.
        * gdbtypes.h: Update prototypes.
        * cp-support.c: New file.
        * cp-support.h: New file.

        * stabsread.c: Include "cp-abi.h" and "cp-support.h".
        (update_method_name_from_physname): New function.
        (read_member_functions): Correct method names for operators
        and v3 constructors/destructors.  Separate v2 constructors and
        destructors.
        * Makefile.in (stabsread.o): Update dependencies.
        (SFILES): Add cp-support.c.
        (COMMON_OBS): Add cp-support.o.
        (cp_support_h, cp-support.o): Add.

        * cp-valprint.c (cp_print_class_method): Call
        check_stub_method_group instead of check_stub_method.  Remove
        extraneous QUITs.
        * p-valprint.c (pascal_object_print_class_method): Likewise.
        * valops.c (search_struct_method): Likewise.
        (find_method_list, value_struct_elt_for_reference): Likewise.
@
text
@d1270 24
d1300 1
a1300 1
  char *p = (char *) strchr (string, ':');
d2033 2
a2034 1
      else if (current_subfile->language == language_cplus)
@


1.38
log
@2002-08-01  Andrew Cagney  <cagney@@redhat.com>

* NEWS: Menion that CHILL has been made obsolete.

* gdbtypes.c (chill_varying_type): Make chill references obsolete.
* gdbserver/Makefile.in: Ditto.
* stabsread.c (read_range_type): Ditto.
* gdbtypes.h: Ditto.
* language.c (binop_type_check): Ditto.
(binop_result_type): Ditto.
(integral_type): Ditto.
(character_type): Ditto.
(string_type): Ditto.
(boolean_type): Ditto.
(structured_type): Ditto.
(lang_bool_type): Ditto.
(binop_type_check): Ditto.
* language.h (_LANG_chill): Ditto.
* dwarfread.c (set_cu_language): Ditto.
* dwarfread.c (CHILL_PRODUCER): Ditto.
* dwarfread.c (handle_producer): Ditto.
* expression.h (enum exp_opcode): Ditto.
* eval.c: Ditto for comments.
* typeprint.c (typedef_print) [_LANG_chill]: Ditto.
* expprint.c (print_subexp): Ditto.
(print_subexp): Ditto.
* valops.c (value_cast): Ditto.
(search_struct_field): Ditto.
* value.h (COERCE_VARYING_ARRAY): Ditto.
* symfile.c (init_filename_language_table): Ditto.
(add_psymbol_with_dem_name_to_list): Ditto.
* valarith.c (value_binop): Ditto.
(value_neg): Ditto.
* valops.c (value_slice): Ditto.
* symtab.h (union language_specific): Ditto.
(SYMBOL_INIT_LANGUAGE_SPECIFIC): Ditto.
(SYMBOL_DEMANGLED_NAME): Ditto.
(SYMBOL_CHILL_DEMANGLED_NAME): Ditto.
* defs.h (enum language): Ditto.
* symtab.c (got_symtab): Ditto.
* utils.c (fprintf_symbol_filtered): Ditto.

* ch-typeprint.c: Make file obsolete.
* ch-valprint.c: Make file obsolete.
* ch-lang.h: Make file obsolete.
* ch-exp.c: Make file obsolete.
* ch-lang.c: Make file obsolete.

* Makefile.in (FLAGS_TO_PASS): Do not pass CHILL or CHILLFLAGS or
CHILL_LIB.
(TARGET_FLAGS_TO_PASS): Ditto.
(CHILLFLAGS): Obsolete.
(CHILL): Obsolete.
(CHILL_FOR_TARGET): Obsolete.
(CHILL_LIB): Obsolete.
(SFILES): Remove ch-exp.c, ch-lang.c, ch-typeprint.c and
ch-valprint.c.
(HFILES_NO_SRCDIR): Remove ch-lang.h.
(COMMON_OBS): Remove ch-valprint.o, ch-typeprint.o, ch-exp.o and
ch-lang.o.
(ch-exp.o, ch-lang.o, ch-typeprint.o, ch-valprint.o): Delete
targets.

2002-08-01  Andrew Cagney  <cagney@@redhat.com>

* stabs.texinfo, gdb.texinfo, gdbint.texinfo: Obsolete references
to CHILL.

2002-08-01  Andrew Cagney  <cagney@@redhat.com>

* Makefile.in (TARGET_FLAGS_TO_PASS): Remove CHILLFLAGS, CHILL,
CHILL_FOR_TARGET and CHILL_LIB.
* configure.in (configdirs): Remove gdb.chill.
* configure: Regenerate.
* lib/gdb.exp: Obsolete references to chill.
* gdb.fortran/types.exp: Ditto.
* gdb.fortran/exprs.exp: Ditto.
@
text
@d47 2
d3085 21
d3403 158
@


1.37
log
@2002-07-29  Andrew Cagney  <ac131313@@redhat.com>

* gdb_obstack.h: New file.
* symtab.h: Include "gdb_obstack.h" instead of "obstack.h".
(obstack_chunk_alloc, obstack_chunk_free): Delete macros.
* objfiles.h: Include "gdb_obstack.h".
* Makefile.in (gdb_obstack_h): Define.
(symtab_h): Add $(gdb_obstack_h).
(objfiles_h): Add $(gdb_obstack_h).

* objfiles.c: Include "gdb_obstack.h" instead of "obstack.h".
* macrotab.c, cp-valprint.c, dbxread.c: Ditto.
* ch-typeprint.c, ch-valprint.c, dstread.c: Ditto.
* macroexp.c, p-typeprint.c, stabsread.c: Ditto.
* symtab.c, f-typeprint.c, mdebugread.c: Ditto.
* p-valprint.c, symmisc.c, typeprint.c: Ditto.
* symfile.c, coffread.c, c-typeprint.c: Ditto.
* buildsym.c, bcache.c, ada-typeprint.c: Ditto.

* Makefile.in (bcache.o): Update dependencies.
(buildsym.o, c-typeprint.o, ch-typeprint.o): Ditto.
(ch-valprint.o, coffread.o, cp-valprint.o): Ditto.
(dbxread.o, dstread.o, f-typeprint.o): Ditto.
(objfiles.o, p-typeprint.o, p-valprint.o): Ditto.
(stabsread.o, symfile.o, symmisc.o): Ditto.
(symtab.o, typeprint.o, macroexp.o): Ditto.
(macrotab.o, mdebugread.o): Ditto.
(f_lang_h, coff_sym_h, coff_symconst_h): Define.
(coff_ecoff_h, aout_aout64_h): Define.
(aout_stabs_gnu_h, libaout_h): Define.
@
text
@d3742 3
a3744 2
      /* chill the list of fields: the last entry (at the head) is a
         partially constructed entry which we now scrub. */
d4893 5
a4897 3
  else if (current_symbol && SYMBOL_LANGUAGE (current_symbol) == language_chill
	   && !self_subrange)
    goto handle_true_range;
@


1.36
log
@2002-07-18  Elena Zannoni  <ezannoni@@redhat.com>

	* stabsread.c: Make os9k sections of the code obsolete,
	for real this time.
	* stabsread.h: Make os9k sections of the code obsolete.
@
text
@d32 1
a32 1
#include "obstack.h"
@


1.35
log
@2002-06-14  Daniel Jacobowitz  <drow@@mvista.com>

        * gdbtypes.h (TYPE_FLAG_VARARGS): Update comment.
        (struct main_type): Remove arg_types member.  Update comments for
        struct field.
        (TYPE_ARG_TYPES): Remove.
        (TYPE_FN_FIELD_ARGS): Update.
        (smash_to_method_type): Update prototype.

        * c-typeprint.c (cp_type_print_method_args): Take method type
        instead of argument list.  Use new argument layout.  Simplify.
        (c_type_print_args): Use new argument layout.  Simplify.
        (c_type_print_base): Update call to cp_type_print_method_args.
        * dwarf2read.c (dwarf2_add_member_fn): Remove unneeded type
        argument; use die->type instead.  Update call to
        smash_to_method_type.
        (read_structure_scope): Update call to dwarf2_add_member_fn.
        * gdbtypes.c (allocate_stub_method): Update comment.
        (smash_to_method_type): Take new NARGS and VARARGS arguments.
        Use new argument layout.
        (check_stub_method): Use new argument layout.  Don't count
        void as an argument.
        (print_arg_types): Update comments.  Use new argument layout.
        (recursive_dump_type): Don't print arg_types member.
        * hpread.c (hpread_read_struct_type): Use new argument layout.
        (fixup_class_method_type): Likewise.
        (hpread_type_lookup): Likewise.
        * stabsread.c (read_type): Update calls to read_args and
        smash_to_method_type.
        (read_args): Use new argument layout.  Simplify.
        * valops.c (typecmp): Use new argument layout.  Update parameters
        and comments.  Simplify.
        (hand_function_call): Use new argument layout.
        (search_struct_method): Update call to typecmp.
        (find_overload_match): Use new argument layout.
@
text
@d259 30
a288 28
/* FIXME: These probably should be our own types (like rs6000_builtin_type
   has its own types) rather than builtin_type_*.  */
static struct type **os9k_type_vector[] =
{
  0,
  &builtin_type_int,
  &builtin_type_char,
  &builtin_type_long,
  &builtin_type_short,
  &builtin_type_unsigned_char,
  &builtin_type_unsigned_short,
  &builtin_type_unsigned_long,
  &builtin_type_unsigned_int,
  &builtin_type_float,
  &builtin_type_double,
  &builtin_type_void,
  &builtin_type_long_double
};

static void os9k_init_type_vector (struct type **);

static void
os9k_init_type_vector (struct type **tv)
{
  unsigned int i;
  for (i = 0; i < sizeof (os9k_type_vector) / sizeof (struct type **); i++)
    tv[i] = (os9k_type_vector[i] == 0 ? 0 : *(os9k_type_vector[i]));
}
d356 5
a360 3
	  if (os9k_stabs)
	    /* Deal with OS9000 fundamental types.  */
	    os9k_init_type_vector (type_vector);
d2059 5
a2063 3
      if (os9k_stabs)
	add_symbol_to_list (sym, &global_symbols);
      else
d2598 18
a2615 15
      if (os9k_stabs && **pp == '(')
	{
	  /* Function prototype; parse it.
	     We must conditionalize this on os9k_stabs because otherwise
	     it could be confused with a Sun-style (1,3) typenumber
	     (I think).  */
	  struct type *t;
	  ++*pp;
	  while (**pp != ')')
	    {
	      t = read_type (pp, objfile);
	      if (**pp == ',')
		++ * pp;
	    }
	}
d2696 12
a2707 5
    case 'c':			/* Const qualifier on some type (OS9000) */
      /* Because 'c' means other things to AIX and 'k' is perfectly good,
         only accept 'c' in the os9k_stabs case.  */
      if (type_descriptor == 'c' && !os9k_stabs)
	return error_type (pp, objfile);
d2714 12
a2725 5
    case 'i':			/* Volatile qual on some type (OS9000) */
      /* Because 'i' means other things to AIX and 'B' is perfectly good,
         only accept 'i' in the os9k_stabs case.  */
      if (type_descriptor == 'i' && !os9k_stabs)
	return error_type (pp, objfile);
d2830 6
a2835 4
      if (os9k_stabs)
	/* Const and volatile qualified type.  */
	type = read_type (pp, objfile);
      else
d3694 4
a3697 2
      if (os9k_stabs && **pp == ',')
	break;
d4359 5
a4363 3
  if (os9k_stabs)
    index_type = builtin_type_int;
  else
d4377 6
a4382 1
  lower = read_huge_number (pp, os9k_stabs ? ',' : ';', &nbits);
d4442 11
a4452 9
  if (os9k_stabs)
    {
      /* Size.  Perhaps this does not have to be conditionalized on
         os9k_stabs (assuming the name of an enum constant can't start
         with a digit).  */
      read_huge_number (pp, 0, &nbits);
      if (nbits != 0)
	return error_type (pp, objfile);
    }
d4691 5
a4695 3
  if (os9k_stabs)
    upper_limit = ULONG_MAX / radix;
  else
d5407 3
a5409 1
  os9k_stabs = 0;
@


1.34
log
@2002-05-14  Daniel Jacobowitz  <drow@@mvista.com>

        * gdbtypes.h: Update accessor macros to use TYPE_MAIN_TYPE.
        (TYPE_CONST, TYPE_VOLATILE, TYPE_CODE_SPACE, TYPE_DATA_SPACE): Use
        TYPE_INSTANCE_FLAGS.
        (struct main_type): New.
        (struct type): Move most members to struct main_type.  Change
        cv_type and as_type to new type_chain member.  Add instance_flags.
        (TYPE_MAIN_TYPE, TYPE_CHAIN, TYPE_INSTANCE_FLAGS): New macros.
        (TYPE_CV_TYPE, TYPE_AS_TYPE): Remove.
        (finish_cv_type): Remove prototype.
        * gdbtypes.c (alloc_type): Update comment.  Allocate TYPE_MAIN_TYPE.
        Set TYPE_CHAIN.
        (alloc_type_instance): New function.
        (smash_type): New function.
        (make_pointer_type, make_reference_type, make_function_type)
        (smash_to_member_type, smash_to_method_type): Call smash_type.
        (make_qualified_type): New function.
        (make_type_with_address_space): Call make_qualified_type.
        (make_cv_type): Likewise.
        (finish_cv_type): Remove unnecessary function.
        (replace_type): Update comment.  Copy TYPE_MAIN_TYPE.
        (recursive_dump_type): Dump TYPE_CHAIN and TYPE_INSTANCE_FLAGS;
        remove TYPE_CV_TYPE and TYPE_AS_TYPE.
        * c-typeprint.c (c_type_print_modifier): Use TYPE_INSTANCE_FLAGS.
        * dwarf2read.c (read_structure_scope): Don't call finish_cv_type.
        * hpread.c (hpread_read_struct_type): Likewise.
        * stabsread.c (read_struct_type): Likewise.

2002-05-14  Daniel Jacobowitz  <drow@@mvista.com>

        * gdb.base/maint.exp (maint print type): Update for new type
        structure.
@
text
@d145 1
a145 1
static struct type **read_args (char **, int, struct objfile *);
d2783 2
a2784 1
	  struct type **args;
d2793 1
a2793 1
	  args = read_args (pp, ';', objfile);
d2795 2
a2796 1
	  smash_to_method_type (type, domain, return_type, args);
d4934 3
a4936 2
static struct type **
read_args (char **pp, int end, struct objfile *objfile)
d4939 3
a4941 2
  struct type *types[1024], **rval;	/* allow for fns of 1023 parameters */
  int n = 0;
d4947 1
a4947 1
	return (struct type **) -1;
d4954 2
a4955 9
  if (n == 1)
    {
      rval = (struct type **) xmalloc (2 * sizeof (struct type *));
    }
  else if (TYPE_CODE (types[n - 1]) != TYPE_CODE_VOID)
    {
      rval = (struct type **) xmalloc ((n + 1) * sizeof (struct type *));
      memset (rval + n, 0, sizeof (struct type *));
    }
d4958 2
a4959 1
      rval = (struct type **) xmalloc (n * sizeof (struct type *));
d4961 6
a4966 1
  memcpy (rval, types, n * sizeof (struct type *));
@


1.34.4.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d145 1
a145 1
static struct field *read_args (char **, int, struct objfile *, int *, int *);
d2783 1
a2783 2
	  struct field *args;
	  int nargs, varargs;
d2792 1
a2792 1
	  args = read_args (pp, ';', objfile, &nargs, &varargs);
d2794 1
a2794 2
	  smash_to_method_type (type, domain, return_type, args,
				nargs, varargs);
d4932 2
a4933 3
static struct field *
read_args (char **pp, int end, struct objfile *objfile, int *nargsp,
	   int *varargsp)
d4936 2
a4937 3
  struct type *types[1024];	/* allow for fns of 1023 parameters */
  int n = 0, i;
  struct field *rval;
d4943 1
a4943 1
	return (struct field *) -1;
d4950 9
a4958 2
  if (TYPE_CODE (types[n - 1]) != TYPE_CODE_VOID)
    *varargsp = 1;
d4961 1
a4961 2
      n--;
      *varargsp = 0;
d4963 1
a4963 6

  rval = (struct field *) xmalloc (n * sizeof (struct field));
  memset (rval, 0, n * sizeof (struct field));
  for (i = 0; i < n; i++)
    rval[i].type = types[i];
  *nargsp = n;
@


1.34.4.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d259 28
a286 30
#if 0 /* OBSOLETE OS9K */
// OBSOLETE /* FIXME: These probably should be our own types (like rs6000_builtin_type
// OBSOLETE    has its own types) rather than builtin_type_*.  */
// OBSOLETE static struct type **os9k_type_vector[] =
// OBSOLETE {
// OBSOLETE   0,
// OBSOLETE   &builtin_type_int,
// OBSOLETE   &builtin_type_char,
// OBSOLETE   &builtin_type_long,
// OBSOLETE   &builtin_type_short,
// OBSOLETE   &builtin_type_unsigned_char,
// OBSOLETE   &builtin_type_unsigned_short,
// OBSOLETE   &builtin_type_unsigned_long,
// OBSOLETE   &builtin_type_unsigned_int,
// OBSOLETE   &builtin_type_float,
// OBSOLETE   &builtin_type_double,
// OBSOLETE   &builtin_type_void,
// OBSOLETE   &builtin_type_long_double
// OBSOLETE };
// OBSOLETE
// OBSOLETE static void os9k_init_type_vector (struct type **);
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE os9k_init_type_vector (struct type **tv)
// OBSOLETE {
// OBSOLETE   unsigned int i;
// OBSOLETE   for (i = 0; i < sizeof (os9k_type_vector) / sizeof (struct type **); i++)
// OBSOLETE     tv[i] = (os9k_type_vector[i] == 0 ? 0 : *(os9k_type_vector[i]));
// OBSOLETE }
#endif /* OBSOLETE OS9K */
d354 3
a356 5
#if 0 /* OBSOLETE OS9K */
// OBSOLETE 	  if (os9k_stabs)
// OBSOLETE 	    /* Deal with OS9000 fundamental types.  */
// OBSOLETE 	    os9k_init_type_vector (type_vector);
#endif /* OBSOLETE OS9K */
d2055 3
a2057 5
#if 0 /* OBSOLETE OS9K */
// OBSOLETE       if (os9k_stabs)
// OBSOLETE 	add_symbol_to_list (sym, &global_symbols);
// OBSOLETE       else
#endif /* OBSOLETE OS9K */
d2592 15
a2606 18
#if 0 /* OBSOLETE OS9K */
// OBSOLETE       if (os9k_stabs && **pp == '(')
// OBSOLETE 	{
// OBSOLETE 	  /* Function prototype; parse it.
// OBSOLETE 	     We must conditionalize this on os9k_stabs because otherwise
// OBSOLETE 	     it could be confused with a Sun-style (1,3) typenumber
// OBSOLETE 	     (I think).  */
// OBSOLETE 	  struct type *t;
// OBSOLETE 	  ++*pp;
// OBSOLETE 	  while (**pp != ')')
// OBSOLETE 	    {
// OBSOLETE 	      t = read_type (pp, objfile);
// OBSOLETE 	      if (**pp == ',')
// OBSOLETE 		++ * pp;
// OBSOLETE 	    }
// OBSOLETE 	}
#endif /* OBSOLETE OS9K */

d2687 5
a2691 12
#if 0 /* OBSOLETE OS9K */
// OBSOLETE       /* ezannoni 2002-07-16: This can be safely deleted, because 'c'
// OBSOLETE 	 means complex type in AIX stabs, while it means const qualifier
// OBSOLETE 	 in os9k stabs.  Obviously we were supporting only the os9k meaning.
// OBSOLETE 	 We were erroring out if we were reading AIX stabs.  Right now the
// OBSOLETE 	 erroring out will happen in the default clause of the switch.  */
// OBSOLETE     case 'c':			/* Const qualifier on some type (OS9000) */
// OBSOLETE       /* Because 'c' means other things to AIX and 'k' is perfectly good,
// OBSOLETE          only accept 'c' in the os9k_stabs case.  */
// OBSOLETE       if (type_descriptor == 'c' && !os9k_stabs)
// OBSOLETE 	return error_type (pp, objfile);
#endif /* OBSOLETE OS9K */
d2698 5
a2702 12
#if 0 /* OBSOLETE OS9K */
// OBSOLETE       /* ezannoni 2002-07-16: This can be safely deleted, because 'i'
// OBSOLETE 	 means imported type in AIX stabs, while it means volatile qualifier
// OBSOLETE 	 in os9k stabs.  Obviously we were supporting only the os9k meaning.
// OBSOLETE 	 We were erroring out if we were reading AIX stabs.  Right now the
// OBSOLETE 	 erroring out will happen in the default clause of the switch.  */
// OBSOLETE     case 'i':			/* Volatile qual on some type (OS9000) */
// OBSOLETE       /* Because 'i' means other things to AIX and 'B' is perfectly good,
// OBSOLETE          only accept 'i' in the os9k_stabs case.  */
// OBSOLETE       if (type_descriptor == 'i' && !os9k_stabs)
// OBSOLETE 	return error_type (pp, objfile);
#endif /* OBSOLETE OS9K */
d2807 4
a2810 6
#if 0 /* OBSOLETE OS9K */
// OBSOLETE       if (os9k_stabs)
// OBSOLETE 	/* Const and volatile qualified type.  */
// OBSOLETE 	type = read_type (pp, objfile);
// OBSOLETE       else
#endif /* OBSOLETE OS9K */
d3669 2
a3670 4
#if 0 /* OBSOLETE OS9K */
// OBSOLETE       if (os9k_stabs && **pp == ',')
// OBSOLETE 	break;
#endif /* OBSOLETE OS9K */
d4332 3
a4334 5
#if 0 /* OBSOLETE OS9K */
// OBSOLETE   if (os9k_stabs)
// OBSOLETE     index_type = builtin_type_int;
// OBSOLETE   else
#endif /* OBSOLETE OS9K */
d4348 1
a4348 6
#if 0 /* OBSOLETE OS9K */
// OBSOLETE   lower = read_huge_number (pp, os9k_stabs ? ',' : ';', &nbits);
#else /* OBSOLETE OS9K */
  lower = read_huge_number (pp, ';', &nbits);
#endif /* OBSOLETE OS9K */

d4408 9
a4416 11
#if 0 /* OBSOLETE OS9K */
// OBSOLETE   if (os9k_stabs)
// OBSOLETE     {
// OBSOLETE       /* Size.  Perhaps this does not have to be conditionalized on
// OBSOLETE          os9k_stabs (assuming the name of an enum constant can't start
// OBSOLETE          with a digit).  */
// OBSOLETE       read_huge_number (pp, 0, &nbits);
// OBSOLETE       if (nbits != 0)
// OBSOLETE 	return error_type (pp, objfile);
// OBSOLETE     }
#endif /* OBSOLETE OS9K */
d4655 3
a4657 5
#if 0 /* OBSOLETE OS9K */
// OBSOLETE   if (os9k_stabs)
// OBSOLETE     upper_limit = ULONG_MAX / radix;
// OBSOLETE   else
#endif /* OBSOLETE OS9K */
d5369 1
a5369 3
#if 0 /* OBSOLETE OS9K */
// OBSOLETE   os9k_stabs = 0;
#endif /* OBSOLETE OS9K */
@


1.34.4.3
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d32 1
a32 1
#include "gdb_obstack.h"
d3742 2
a3743 3
      /* (OBSOLETE) chill (OBSOLETE) the list of fields: the last
         entry (at the head) is a partially constructed entry which we
         now scrub. */
d4892 3
a4894 5
#if 0
  /* OBSOLETE else if (current_symbol && SYMBOL_LANGUAGE (current_symbol) == language_chill */
  /* OBSOLETE          && !self_subrange) */
  /* OBSOLETE   goto handle_true_range; */
#endif
@


1.34.4.4
log
@Merge with kseitz_interps-20020930-merge.
@
text
@a46 2
#include "cp-abi.h"
#include "cp-support.h"
a3082 21
/* Replace *OLD_NAME with the method name portion of PHYSNAME.  */

static void
update_method_name_from_physname (char **old_name, char *physname)
{
  char *method_name;

  method_name = method_name_from_physname (physname);

  if (method_name == NULL)
    error ("bad physname %s\n", physname);

  if (strcmp (*old_name, method_name) != 0)
    {
      xfree (*old_name);
      *old_name = method_name;
    }
  else
    xfree (method_name);
}

a3379 158
	  int has_stub = 0;
	  int has_destructor = 0, has_other = 0;
	  int is_v3 = 0;
	  struct next_fnfield *tmp_sublist;

	  /* Various versions of GCC emit various mostly-useless
	     strings in the name field for special member functions.

	     For stub methods, we need to defer correcting the name
	     until we are ready to unstub the method, because the current
	     name string is used by gdb_mangle_name.  The only stub methods
	     of concern here are GNU v2 operators; other methods have their
	     names correct (see caveat below).

	     For non-stub methods, in GNU v3, we have a complete physname.
	     Therefore we can safely correct the name now.  This primarily
	     affects constructors and destructors, whose name will be
	     __comp_ctor or __comp_dtor instead of Foo or ~Foo.  Cast
	     operators will also have incorrect names; for instance,
	     "operator int" will be named "operator i" (i.e. the type is
	     mangled).

	     For non-stub methods in GNU v2, we have no easy way to
	     know if we have a complete physname or not.  For most
	     methods the result depends on the platform (if CPLUS_MARKER
	     can be `$' or `.', it will use minimal debug information, or
	     otherwise the full physname will be included).

	     Rather than dealing with this, we take a different approach.
	     For v3 mangled names, we can use the full physname; for v2,
	     we use cplus_demangle_opname (which is actually v2 specific),
	     because the only interesting names are all operators - once again
	     barring the caveat below.  Skip this process if any method in the
	     group is a stub, to prevent our fouling up the workings of
	     gdb_mangle_name.

	     The caveat: GCC 2.95.x (and earlier?) put constructors and
	     destructors in the same method group.  We need to split this
	     into two groups, because they should have different names.
	     So for each method group we check whether it contains both
	     routines whose physname appears to be a destructor (the physnames
	     for and destructors are always provided, due to quirks in v2
	     mangling) and routines whose physname does not appear to be a
	     destructor.  If so then we break up the list into two halves.
	     Even if the constructors and destructors aren't in the same group
	     the destructor will still lack the leading tilde, so that also
	     needs to be fixed.

	     So, to summarize what we expect and handle here:

	        Given         Given          Real         Real       Action
	     method name     physname      physname   method name

	     __opi            [none]     __opi__3Foo  operator int    opname
	                                                           [now or later]
	     Foo              _._3Foo       _._3Foo      ~Foo       separate and
	                                                               rename
	     operator i     _ZN3FoocviEv _ZN3FoocviEv operator int    demangle
	     __comp_ctor  _ZN3FooC1ERKS_ _ZN3FooC1ERKS_   Foo         demangle
	  */

	  tmp_sublist = sublist;
	  while (tmp_sublist != NULL)
	    {
	      if (tmp_sublist->fn_field.is_stub)
		has_stub = 1;
	      if (tmp_sublist->fn_field.physname[0] == '_'
		  && tmp_sublist->fn_field.physname[1] == 'Z')
		is_v3 = 1;

	      if (is_destructor_name (tmp_sublist->fn_field.physname))
		has_destructor++;
	      else
		has_other++;

	      tmp_sublist = tmp_sublist->next;
	    }

	  if (has_destructor && has_other)
	    {
	      struct next_fnfieldlist *destr_fnlist;
	      struct next_fnfield *last_sublist;

	      /* Create a new fn_fieldlist for the destructors.  */

	      destr_fnlist = (struct next_fnfieldlist *)
		xmalloc (sizeof (struct next_fnfieldlist));
	      make_cleanup (xfree, destr_fnlist);
	      memset (destr_fnlist, 0, sizeof (struct next_fnfieldlist));
	      destr_fnlist->fn_fieldlist.name
		= obconcat (&objfile->type_obstack, "", "~",
			    new_fnlist->fn_fieldlist.name);

	      destr_fnlist->fn_fieldlist.fn_fields = (struct fn_field *)
		obstack_alloc (&objfile->type_obstack,
			       sizeof (struct fn_field) * has_destructor);
	      memset (destr_fnlist->fn_fieldlist.fn_fields, 0,
		  sizeof (struct fn_field) * has_destructor);
	      tmp_sublist = sublist;
	      last_sublist = NULL;
	      i = 0;
	      while (tmp_sublist != NULL)
		{
		  if (!is_destructor_name (tmp_sublist->fn_field.physname))
		    {
		      tmp_sublist = tmp_sublist->next;
		      continue;
		    }
		  
		  destr_fnlist->fn_fieldlist.fn_fields[i++]
		    = tmp_sublist->fn_field;
		  if (last_sublist)
		    last_sublist->next = tmp_sublist->next;
		  else
		    sublist = tmp_sublist->next;
		  last_sublist = tmp_sublist;
		  tmp_sublist = tmp_sublist->next;
		}

	      destr_fnlist->fn_fieldlist.length = has_destructor;
	      destr_fnlist->next = fip->fnlist;
	      fip->fnlist = destr_fnlist;
	      nfn_fields++;
	      total_length += has_destructor;
	      length -= has_destructor;
	    }
	  else if (is_v3)
	    {
	      /* v3 mangling prevents the use of abbreviated physnames,
		 so we can do this here.  There are stubbed methods in v3
		 only:
		 - in -gstabs instead of -gstabs+
		 - or for static methods, which are output as a function type
		   instead of a method type.  */

	      update_method_name_from_physname (&new_fnlist->fn_fieldlist.name,
						sublist->fn_field.physname);
	    }
	  else if (has_destructor && new_fnlist->fn_fieldlist.name[0] != '~')
	    {
	      new_fnlist->fn_fieldlist.name = concat ("~", main_fn_name, NULL);
	      xfree (main_fn_name);
	    }
	  else if (!has_stub)
	    {
	      char dem_opname[256];
	      int ret;
	      ret = cplus_demangle_opname (new_fnlist->fn_fieldlist.name,
					      dem_opname, DMGL_ANSI);
	      if (!ret)
		ret = cplus_demangle_opname (new_fnlist->fn_fieldlist.name,
					     dem_opname, 0);
	      if (ret)
		new_fnlist->fn_fieldlist.name
		  = obsavestring (dem_opname, strlen (dem_opname),
				  &objfile->type_obstack);
	    }

@


1.34.4.5
log
@merge from mainline
@
text
@a171 2
static char *find_name_end (char *name);

d188 4
a191 2
static const char vptr_name[] = "_vptr$";
static const char vb_name[] = "_vb$";
d205 1
a205 1
static struct deprecated_complaint invalid_cpp_abbrev_complaint =
d208 1
a208 1
static struct deprecated_complaint invalid_cpp_type_complaint =
d211 1
a211 1
static struct deprecated_complaint member_fn_complaint =
d214 1
a214 1
static struct deprecated_complaint const_vol_complaint =
d217 1
a217 1
static struct deprecated_complaint error_type_complaint =
d220 1
a220 1
static struct deprecated_complaint invalid_member_complaint =
d223 1
a223 1
static struct deprecated_complaint range_type_base_complaint =
d226 1
a226 1
static struct deprecated_complaint reg_value_complaint =
d229 1
a229 1
static struct deprecated_complaint vtbl_notfound_complaint =
d232 1
a232 1
static struct deprecated_complaint unrecognized_cplus_name_complaint =
d235 1
a235 1
static struct deprecated_complaint rs6000_builtin_complaint =
d238 1
a238 1
static struct deprecated_complaint unresolved_sym_chain_complaint =
d241 1
a241 1
static struct deprecated_complaint stabs_general_complaint =
d244 1
a244 1
static struct deprecated_complaint lrs_general_complaint =
d314 1
a314 1
      static struct deprecated_complaint msg =
d621 1
a621 1
  static struct deprecated_complaint msg_unknown =
d625 1
a625 1
  static struct deprecated_complaint msg_notfound =
d695 1
a695 1
	    static struct deprecated_complaint msg =
d813 1
a813 1
	  static struct deprecated_complaint msg =
d1276 1
a1276 1
  char *p = (char *) find_name_end (string);
d2009 1
a2009 2
      else if ((current_subfile->language == language_cplus)
	       || (current_subfile->language == language_objc))
d2437 1
a2437 1
		static struct deprecated_complaint msg =
d2662 1
a2662 1
            static struct deprecated_complaint msg = {
d3182 2
a3183 1
	  static char opname[32] = "op$";
d4021 1
a4021 1
	    static struct deprecated_complaint msg =
d4040 1
a4040 1
	    static struct deprecated_complaint msg =
d4141 2
a4142 3
		  char *name = TYPE_FIELD_NAME (t, i);
		  if (!strncmp (name, vptr_name, sizeof (vptr_name) - 2)
		      && is_cplus_marker (name[sizeof (vptr_name) - 2]))
d4212 1
a4212 1
	  static struct deprecated_complaint msg =
d4391 1
a4391 1
	    static struct deprecated_complaint msg =
d4404 1
a4404 1
static struct deprecated_complaint multiply_defined_struct =
d5216 1
a5216 1
      static struct deprecated_complaint msg =
d5246 1
a5246 1
      static struct deprecated_complaint msg =
d5361 1
a5361 1
		    static struct deprecated_complaint msg =
d5386 1
a5386 1
	    static struct deprecated_complaint msg =
a5617 26
    }
}

/* Find the end of the name, delimited by a ':', but don't match
   ObjC symbols which look like -[Foo bar::]:bla.  */
static char *
find_name_end (char *name)
{
  char *s = name;
  if (s[0] == '-' || *s == '+')
    {
      /* Must be an ObjC method symbol.  */
      if (s[1] != '[')
	{
	  error ("invalid symbol name \"%s\"", name);
	}
      s = strchr (s, ']');
      if (s == NULL)
	{
	  error ("invalid symbol name \"%s\"", name);
	}
      return strchr (s, ':');
    }
  else
    {
      return strchr (s, ':');
@


1.34.2.1
log
@merge from trunk
@
text
@d145 1
a145 1
static struct field *read_args (char **, int, struct objfile *, int *, int *);
d2783 1
a2783 2
	  struct field *args;
	  int nargs, varargs;
d2792 1
a2792 1
	  args = read_args (pp, ';', objfile, &nargs, &varargs);
d2794 1
a2794 2
	  smash_to_method_type (type, domain, return_type, args,
				nargs, varargs);
d4932 2
a4933 3
static struct field *
read_args (char **pp, int end, struct objfile *objfile, int *nargsp,
	   int *varargsp)
d4936 2
a4937 3
  struct type *types[1024];	/* allow for fns of 1023 parameters */
  int n = 0, i;
  struct field *rval;
d4943 1
a4943 1
	return (struct field *) -1;
d4950 9
a4958 2
  if (TYPE_CODE (types[n - 1]) != TYPE_CODE_VOID)
    *varargsp = 1;
d4961 1
a4961 2
      n--;
      *varargsp = 0;
d4963 1
a4963 6

  rval = (struct field *) xmalloc (n * sizeof (struct field));
  memset (rval, 0, n * sizeof (struct field));
  for (i = 0; i < n; i++)
    rval[i].type = types[i];
  *nargsp = n;
@


1.33
log
@2002-05-06  Michael Snyder  <msnyder@@redhat.com>

	* stabsread.c (read_type): Add recognition for new attribute:
	"@@V;" means that an array type is actually a vector.
	This is analogous to the vector flag that's been added to dwarf2.
@
text
@a4304 2
  /* Fix up any cv-qualified versions of this type.  */
  finish_cv_type (type);
@


1.32
log
@* stabsread.c (cleanup_undefined_types): Use replace_type, not memcpy.
(read_type): Doc fix.
* gdbtypes.c (replace_type): Doc fix.
@
text
@d1907 1
d2363 3
d2581 1
a2581 1
    case '*':
d2739 1
a2739 1
	    case 's':
d2745 2
a2746 1
	    case 'S':
d2750 5
d2857 2
d2861 1
a2861 1
    case 'S':
@


1.31
log
@* stabsread.c (multiply_defined_struct): New complaint.
(read_struct_type): If the type we were passed isn't empty, or
incomplete, don't read the new struct type into it; complain,
and return the original type unchanged.  Take a new `type_code'
argument, which is the type code for the new type.
(read_type): Rather than storing the type's type code here, pass
it as an argument to read_struct_type, and let that take care of
storing it.  That way, we don't overwrite the original type code,
so read_struct_type can use it to decide whether we're overwriting
something we shouldn't.
(complain_about_struct_wipeout): New function.
@
text
@d2540 18
a2557 1
	       should not be modified.  */
d5142 1
a5142 4
			  {
			    memcpy (*type, SYMBOL_TYPE (sym),
				    sizeof (struct type));
			  }
@


1.30
log
@2002-03-20  Daniel Jacobowitz  <drow@@mvista.com>

        Fix PR gdb/422.
        * c-lang.c (c_create_fundamental_type): Handle FT_COMPLEX,
        FT_DBL_PREC_COMPLEX, and FT_EXT_PREC_COMPLEX.
        * dwarf2read.c (read_base_type): Set TYPE_TARGET_TYPE for
        complex types.
        * stabsread.c (rs6000_builtin_type): Likewise.
        (read_sun_floating_type): Likewise.
@
text
@d139 1
d2805 15
a2819 12
      type = dbx_alloc_type (typenums, objfile);
      switch (type_descriptor)
	{
	case 's':
	  TYPE_CODE (type) = TYPE_CODE_STRUCT;
	  break;
	case 'u':
	  TYPE_CODE (type) = TYPE_CODE_UNION;
	  break;
	}
      type = read_struct_type (pp, type, objfile);
      break;
d4163 39
d4217 2
a4218 1
read_struct_type (char **pp, struct type *type, struct objfile *objfile)
d4226 20
d4249 1
@


1.29
log
@	* stabsread.c (read_member_functions): Remove skip code for duplicate
	constructor/destructor methods.  Use standard parsing for these
	methods and just do not chain them to the list of methods after
	parsing.
@
text
@d2981 2
d2987 2
d4498 1
d4513 6
a4518 3
    /* This is a type we can't handle, but we do know the size.
       We also will be able to give it a name.  */
    return init_type (TYPE_CODE_COMPLEX, nbytes, 0, NULL, objfile);
@


1.28
log
@	* stabsread.c (read_member_functions): Fix is_stub test for
	static member functions, improve comment.
@
text
@a3039 1
  int skip_method;
a3078 30
      skip_method = 0;
      if (p - *pp == strlen ("__base_ctor")
	  && strncmp (*pp, "__base_ctor", strlen ("__base_ctor")) == 0)
	skip_method = 1;
      else if (p - *pp == strlen ("__base_dtor")
	       && strncmp (*pp, "__base_dtor", strlen ("__base_dtor")) == 0)
	skip_method = 1;
      else if (p - *pp == strlen ("__deleting_dtor")
	       && strncmp (*pp, "__deleting_dtor",
			   strlen ("__deleting_dtor")) == 0)
	skip_method = 1;

      if (skip_method)
	{
	  /* Skip past '::'.  */
	  *pp = p + 2;
	  /* Read the type.  */
	  read_type (pp, objfile);
	  /* Skip past the colon, mangled name, semicolon, flags, and final
	     semicolon.  */
	  while (**pp != ';')
	    (*pp) ++;
	  (*pp) ++;
	  while (**pp != ';')
	    (*pp) ++;
	  (*pp) ++;

	  continue;
	}

d3304 1
d3306 5
a3310 6
      new_fnlist->fn_fieldlist.fn_fields = (struct fn_field *)
	obstack_alloc (&objfile->type_obstack,
		       sizeof (struct fn_field) * length);
      memset (new_fnlist->fn_fieldlist.fn_fields, 0,
	      sizeof (struct fn_field) * length);
      for (i = length; (i--, sublist); sublist = sublist->next)
d3312 1
a3312 1
	  new_fnlist->fn_fieldlist.fn_fields[i] = sublist->fn_field;
d3314 11
d3326 6
a3331 6
      new_fnlist->fn_fieldlist.length = length;
      new_fnlist->next = fip->fnlist;
      fip->fnlist = new_fnlist;
      nfn_fields++;
      total_length += length;
      STABS_CONTINUE (pp, objfile);
@


1.27
log
@* stabsread.c (error_type_complaint): Improve error message.
@
text
@d3290 24
a3313 7
	      new_sublist->fn_field.voffset = VOFFSET_STATIC;
	      if (strncmp (new_sublist->fn_field.physname,
			   main_fn_name, strlen (main_fn_name)))
		{
		  new_sublist->fn_field.is_stub = 1;
		}
	      break;
@


1.26
log
@* stabsread.c (error_type_complaint): Improve error message.
@
text
@d215 1
a215 1
{"During symbol reading, couldn't parse type; debugger out of date?", 0, 0};
@


1.25
log
@* stabsread.c (read_type): Add code to parse Sun's syntax for
prototyped function types.
@
text
@d215 1
a215 1
{"debug info mismatch between compiler and debugger", 0, 0};
@


1.24
log
@2002-02-01  Daniel Jacobowitz  <drow@@mvista.com>

        PR gdb/280
        * gdbtypes.c (replace_type): New function.
        * gdbtypes.h (replace_type): Add prototype.
        * stabsread.c (read_type): Use replace_type.
@
text
@d2589 75
@


1.23
log
@2002-01-15  Daniel Jacobowitz  <drow@@mvista.com>

	* gdbtypes.h (struct type): Fix whitespace.  Remove obsolete
	comment.  Add ``artificial'' to ``union field_location''.

	* dwarf2read.c: Remove ad-hoc TYPE_FIELD_ARTIFICIAL.

	* buildsym.c (finish_block): Initialize TYPE_FIELD_ARTIFICIAL to 0.
	* mdebugread.c (parse_symbol): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* hp-symtab-read.c (hpread_function_type): Likewise, instead of
	initializing TYPE_FIELD_BITPOS to n (obsolete).
	(hpread_doc_function_type): Likewise.
	* hpread.c (hpread_function_type): Likewise.
@
text
@d2534 7
a2540 1
	    *type = *xtype;
@


1.22
log
@2001-01-15  Daniel Jacobowitz  <drow@@mvista.com>

        * stabsread.c (read_type): Pass dbx_lookup_type (typenums)
        to make_cv_type.
@
text
@d1631 2
a1632 1
	      TYPE_FIELD_TYPE (ftype, nparams++) = ptype;
@


1.21
log
@s/BIG_ENDIAN/BFD_ENDIAN_BIG/
@
text
@d2589 2
a2590 1
      type = make_cv_type (1, TYPE_VOLATILE (type), type, 0);
d2600 2
a2601 1
      type = make_cv_type (TYPE_CONST (type), 1, type, 0);
@


1.20
log
@2002-01-04  Elena Zannoni  <ezannoni@@redhat.com>

	* stabsread.c: Update copyright years.

	From Debashis Mahata <debashis.mahata@@wipro.com>:
	(read_struct_fields): Deal with Sun C compiler erroneous stab
	output for structs and unions.
@
text
@d1704 1
a1704 1
      if (TARGET_BYTE_ORDER != BIG_ENDIAN)
@


1.19
log
@Approved by Jim Blandy:

	2001-12-11  Fred Fish  <fnf@@redhat.com>
	* c-typeprint.c (c_type_print_base): Use type flags access macros
	to test bits.
	* ch-typeprint.c (chill_type_print_base): Ditto.
	* ch-valprint.c (chill_val_print): Ditto.
	* d10v-tdep.c (d10v_pointer_to_address): Ditto.
	* dwarf2read.c (dwarf2_add_member_fn): Ditto.
	* dwarfread.c (read_structure_scope): Ditto.
	* gdbtypes.c (create_range_type): Dittol
	(create_set_type): Ditto.
	(check_typedef): Ditto.
	* jv-typeprint.c (java_type_print_base): Ditto.
	* p-typeprint.c (pascal_type_print_base): Ditto
	* p-valprint.c (pascal_val_print): Ditto.
	* stabsread.c (read_cfront_member_functions): Ditto.
	(read_member_functions): Ditto.
	(cleanup_undefined_types): Ditto.
	* valprint.c (val_print): Ditto.
	* valops.c (hand_function_call): Remove is_prototyped
	variable and just use type flag test macro directly.
@
text
@d3 1
a3 1
   1996, 1997, 1998, 1999, 2000
d3544 2
d3547 1
a3547 1
  while (**pp != ';')
@


1.18
log
@        * stabsread.c (read_member_functions): Skip member functions which
        are duplicates of the callable constructor/destructor.
@
text
@d872 1
a872 1
      if (TYPE_FLAGS (new_sublist->fn_field.type) & TYPE_FLAG_STUB)
d3103 1
a3103 1
	  if (TYPE_FLAGS (new_sublist->fn_field.type) & TYPE_FLAG_STUB)
d4944 1
a4944 1
	    if (TYPE_FLAGS (*type) & TYPE_FLAG_STUB)
@


1.17
log
@        * gdbtypes.c (finish_cv_type): New function.
        (check_typedef): Remove ``register'' keyword from argument.
        Preserve const and volatile attributes across filling in
        opaque types.
        * gdbtypes.h (finish_cv_type): Add prototype.

        * hp-symtab-read.c (hpread_read_struct_type): Call finish_cv_type.
        * stabsread.c (read_struct_type): Likewise.
        * dwarf2read.c (read_structure_scope): Likewise.  Remove redundant
        assignment to die->type.
@
text
@d2956 1
d2995 30
@


1.16
log
@* doublest.h (store_floating, extract_floating): Add comment
indicating these functions are deprecated.
(extract_typed_floating, store_typed_floating): Declare.
* doublest.c: Include "gdbtypes.h".
(extract_typed_floating, store_typed_floating): Define.

* stabsread.c (define_symbol): Use store_typed_floating.
* valarith.c (value_binop): Ditto.
* values.c (unpack_long): Use extract_typed_floating.
(unpack_double): Ditto.
@
text
@d4093 2
@


1.15
log
@2001-08-08  Don Howard  <dhoward@@redhat.com>

	* stabsread.c (read_type): Add support for const and volatile
	modifiers.
@
text
@d1494 1
a1494 1
	    store_floating (dbl_valu, TYPE_LENGTH (SYMBOL_TYPE (sym)), d);
@


1.14
log
@* defs.h (HOST_FLOAT_FORMAT, HOST_DOUBLE_FORMAT)
(HOST_FLOAT_FORMAT, HOST_DOUBLE_FORMAT)
(HOST_LONG_DOUBLE_FORMAT, DOUBLEST)
(floatformat_to_doublest, floatformat_from_doublest)
(floatformat_is_negative, floatformat_is_nan)
(floatformat_mantissa, store_floating)
(extract_floating): Move declaration from here.
* doublest.h: To here.  New file.
* utils.c (get_field, floatformat_to_doublest, put_field)
(ldfrexp, floatformat_from_doublest, floatformat_is_negative)
(floatformat_is_nan, floatformat_mantissa)
(FLOATFORMAT_CHAR_BIT): Move from here.
* doublest.c: To here.  New file.
* findvar.c (store_floating, extract_floating): Move from here.
* doublest.c: To here.
* Makefile.in (SFILES): Add doublest.c.
(COMMON_OBS): Add doublest.o.
(doublest.o): Specify dependencies.
(doublest_h): Define.

* config/m88k/tm-m88k.h: Include "doublest.h".
* config/i960/tm-i960.h: Ditto.
* config/i386/tm-symmetry.h: Ditto.
* rs6000-tdep.c, valarith.c: Ditto.
* valprint.c, stabsread.c, sh-tdep.c: Ditto.
* ia64-tdep.c, i387-tdep.c, i386-tdep.c: Ditto.
* values.c, arm-tdep.c, arm-linux-tdep.c: Ditto.
* alpha-tdep.c, ax.h, expression.h: Ditto.
* sh-tdep.c, parse.c, top.c, value.h: Ditto.

* Makefile.in (arm-tdep.o): Add $(doublest_h).
(i386-tdep.o, i387-tdep.o, ia64-tdep.o): Ditto.
(rs6000-tdep.o, stabsread.o, valarith.o): Ditto.
(values.o, valprint.o, arm-linux-tdep.o): Ditto.
(alpha-tdep.o, ax_h, parse.o, top.o, value_h): Ditto.
(parser_defs_h): Ditto.
(expression_h): Add $(doublest_h) and $(symtab_h).
@
text
@d2589 1
a2589 1
      /* FIXME! For now, we ignore const and volatile qualifiers.  */
d2599 1
a2599 1
      /* FIXME! For now, we ignore const and volatile qualifiers.  */
@


1.13
log
@* stabsread.c (read_cpp_abbrev): Properly construct the names of
virtual function table pointer fields.
@
text
@d46 1
@


1.13.2.1
log
@Typesystem work initial import.
Note that this currently isn't building, i'm in the middle of converting make_function_type/lookup_function_type
@
text
@d417 1
a417 3
	    enum language old_language;
	    old_language = current_language->la_language;
	    *type_addr = alloc_type (objfile);
d734 1
a734 1
	    new->field.name = xstrdup(type_name_no_tag (new->field.type));
d840 1
a840 1
	    obsavestring (dem_p, dem_len, &objfile->type_obstack);
d1332 2
a1333 3
	  SYMBOL_NAME (sym) = bcache("this", strlen("this")+1, &objfile->psymbol_cache);
	 /* obsavestring ("this", strlen ("this"),
					    &objfile->symbol_obstack);*/
d1583 2
a1584 2
      if (TYPE_CODE (SYMBOL_TYPE (sym)) != TYPE_CODE_FUNC)       
	SYMBOL_TYPE (sym) = (struct type *)make_function_type (objfile, SYMBOL_TYPE (sym), 0, NULL, 0);
d1713 1
a1713 1
#if TYPEFIX
d1720 1
a1787 1
#endif
d1927 1
a1927 1
		  xstrdup(type_name_no_tag (TYPE_BASECLASS (SYMBOL_TYPE (sym), j)));
d2552 2
a2553 8
      {
	struct type **oldtype;
	type1 = read_type (pp, objfile);
	oldtype = dbx_lookup_type (typenums);	
	type = (struct type *)make_pointer_type (objfile, type1);
	if (oldtype != NULL)
	  *oldtype = type;
      }
d2555 1
a2555 1
      
d2557 2
a2558 8
      {
	struct type **oldtype;
	type1 = read_type (pp, objfile);
	oldtype = dbx_lookup_type (typenums);
	type = (struct type *)make_reference_type (objfile, type1);
	if (oldtype != NULL)
	  *oldtype = type;
      }
a2601 1
      current_subfile->language = language_cplus;
d2745 1
a2745 1
      type = (struct type *)make_set_type (objfile, (struct range_type *)type1);
d2807 1
a2807 1
      rettype = builtin_type_int;
d2810 1
a2810 1
      rettype = builtin_type_char;
d2813 1
a2813 1
      rettype = builtin_type_short;
d2816 1
a2816 1
      rettype = builtin_type_long;
d2819 2
a2820 1
      rettype = builtin_type_unsigned_char;
d2823 1
a2823 1
      rettype = builtin_type_signed_char;
d2826 2
a2827 1
      rettype = builtin_type_unsigned_short;
d2830 2
a2831 1
      rettype = builtin_type_unsigned_int;
d2834 2
a2835 1
      rettype = (struct type *)make_integer_type (NULL, "unsigned", 4, ST_unsigned);
d2837 2
a2838 1
      rettype = builtin_type_unsigned_long;
d2841 1
a2841 1
      rettype = builtin_type_void;
a2859 1
#if TYPEFIX
a2912 1
#endif
d2914 1
a2914 1
      rettype = builtin_type_long_long;
d2917 2
a2918 1
      rettype = builtin_type_unsigned_long_long;
a2919 1
#if TYPEFIX
a2926 1
#endif
d3245 1
a3245 1
  const char *name;
d3365 1
a3365 1
 obsavestring (*pp, p - *pp, &objfile->type_obstack);
d3703 1
a3703 1
      new->field.name = xstrdup(type_name_no_tag (new->field.type));
d3889 2
a3890 1
	      fip->list->field.name = obsavestring (dem_p, strlen (dem_p), &objfile->type_obstack);
d3894 2
a3895 1
	      fip->list->field.name = obsavestring (sname, strlen (sname), &objfile->type_obstack);
d4105 1
a4105 2
  struct type *index_type, *element_type;
  struct range_type *range_type;
d4155 2
a4156 2
    make_range_type (objfile, index_type, lower, upper);
  type = (struct type *)make_array_type (objfile,  element_type, range_type);
d4179 2
a4180 1
  struct enum_pair *pairs;
d4238 2
d4247 12
a4258 4
  pairs = (struct enum_pair *) obstack_alloc (&objfile->symbol_obstack, 
					      sizeof (struct enum_pair) *  nsyms);
  type = (struct type *)  make_enum_type (objfile,  nsyms, &pairs);
  
d4275 3
a4277 4
	  ENUM_VALUE_NAME (type, n) = SYMBOL_NAME (xsym);
	  ENUM_VALUE_VALUE (type, n) = SYMBOL_VALUE (xsym);
	  if (SYMBOL_VALUE (xsym) < 0)
	    SIGNED_TYPE_SIGN (type) = ST_signed;	 
d4361 3
a4363 2
    return builtin_type_void;
#if TYPEFIX
a4368 2
#endif
  return NULL;
d4520 1
a4520 1
  struct range_type *result_type;
d4580 1
a4580 5
			    got_unsigned ? 
#if TYPEFIX
			    TYPE_FLAG_UNSIGNED :
#endif
0 : 0, NULL,
d4626 2
a4627 1
      return builtin_type_unsigned_int;
d4633 1
a4633 1
    return builtin_type_char;
d4647 3
a4649 1
         return (struct type *)make_integer_type (objfile, NULL, -n3, ST_unsigned);
d4663 2
a4664 1
	  return (struct type *) make_integer_type (objfile, NULL, bytes, ST_unsigned);
d4707 2
a4708 2
  result_type = make_range_type (objfile, index_type, n2, n3);
  return (struct type *)(result_type);
d4782 2
a4783 1
  common_block_name = obsavestring (name, strlen (name), &objfile->symbol_obstack);
@


1.12
log
@* frame.h (SIZEOF_FRAME_SAVED_REGS): Report an error if macro
already defined.

From 2000-08-25 Stephane Carrez <Stephane.Carrez@@worldnet.fr>:
* stabsread.c (define_symbol): A parameter ('R'), a local ('r'),
or a reference ('a') can be in a pseudo register.
* infcmd.c (do_registers_info): Must take into account the pseudo
registers to print their value.
(registers_info): Likewise.
* stack.c (frame_info): Likewise.
* frame.h (SIZEOF_FRAME_SAVED_REGS): Save the pseudo registers.
@
text
@d3267 5
d3273 1
a3273 1
	    obconcat (&objfile->type_obstack, vptr_name, "", "");
@


1.11
log
@Update/correct copyright notices.
@
text
@d1805 1
a1805 1
      if (SYMBOL_VALUE (sym) >= NUM_REGS)
d1807 2
a1808 1
	  complain (&reg_value_complaint, SYMBOL_VALUE (sym), NUM_REGS,
d1821 1
a1821 1
      if (SYMBOL_VALUE (sym) >= NUM_REGS)
d1823 2
a1824 1
	  complain (&reg_value_complaint, SYMBOL_VALUE (sym), NUM_REGS,
d2071 1
a2071 1
      if (SYMBOL_VALUE (sym) >= NUM_REGS)
d2073 2
a2074 1
	  complain (&reg_value_complaint, SYMBOL_VALUE (sym), NUM_REGS,
@


1.10
log
@Replace free() with xfree().
@
text
@d2 2
a3 1
   Copyright 1986, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 1998
@


1.9
log
@* stabsread.c (read_range_type): Properly construct complex
type nodes.
@
text
@d657 1
a657 1
      make_cleanup (free, new);
d817 1
a817 1
      make_cleanup (free, new_fnlist);
d860 1
a860 1
      make_cleanup (free, new_sublist);
d2992 1
a2992 1
      make_cleanup (free, new_fnlist);
d3035 1
a3035 1
	  make_cleanup (free, new_sublist);
d3511 1
a3511 1
      make_cleanup (free, new);
d3631 1
a3631 1
      make_cleanup (free, new);
d3851 1
a3851 1
      make_cleanup (free, new);
d3914 1
a3914 1
      make_cleanup (free, new);
d5153 1
a5153 1
      free ((char *) type_vector);
d5166 1
a5166 1
      free ((PTR) global_stabs);
@


1.8
log
@2000-10-26  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

	* stabsread.c (define_symbol): Update comment.

2000-10-26 Pierre Muller <muller@@ics.u-strasbg.fr>

     	* stabsread.c (define_symbol): Set the type_name of the type
	of the new symbol to the symbol name for type symbol, if the
	language is Pascal.
@
text
@d4596 3
d4601 4
a4604 1
	  return init_type (TYPE_CODE_COMPLEX, 2 * n2, 0, NULL, objfile);
d4607 1
a4607 3
	{
	  return init_type (TYPE_CODE_FLT, n2, 0, NULL, objfile);
	}
@


1.7
log
@Protoization.
@
text
@d1956 21
@


1.6
log
@Protoization.
@
text
@d293 1
a293 2
dbx_lookup_type (typenums)
     int typenums[2];
d400 1
a400 3
dbx_alloc_type (typenums, objfile)
     int typenums[2];
     struct objfile *objfile;
d4270 1
a4270 4
read_sun_builtin_type (pp, typenums, objfile)
     char **pp;
     int typenums[2];
     struct objfile *objfile;
d4342 1
a4342 4
read_sun_floating_type (pp, typenums, objfile)
     char **pp;
     int typenums[2];
     struct objfile *objfile;
d4483 1
a4483 4
read_range_type (pp, typenums, objfile)
     char **pp;
     int typenums[2];
     struct objfile *objfile;
@


1.5
log
@PARAMS removal.
@
text
@d278 1
a278 2
os9k_init_type_vector (tv)
     struct type **tv;
d429 2
a430 4
patch_block_stabs (symbols, stabs, objfile)
     struct pending *symbols;
     struct pending_stabs *stabs;
     struct objfile *objfile;
d517 1
a517 3
read_type_number (pp, typenums)
     register char **pp;
     register int *typenums;
d555 1
a555 3
get_substring (p, c)
     char **p;
     int c;
d576 1
a576 2
get_cfront_method_physname (fname)
     char *fname;
d612 2
a613 5
read_cfront_baseclasses (fip, pp, type, objfile)
     struct field_info *fip;
     struct objfile *objfile;
     char **pp;
     struct type *type;
d762 2
a763 5
read_cfront_member_functions (fip, pp, type, objfile)
     struct field_info *fip;
     char **pp;
     struct type *type;
     struct objfile *objfile;
d967 2
a968 4
resolve_cfront_continuation (objfile, sym, p)
     struct objfile *objfile;
     struct symbol *sym;
     char *p;
d1037 1
a1037 4
resolve_symbol_reference (objfile, sym, p)
     struct objfile *objfile;
     struct symbol *sym;
     char *p;
d1162 1
a1162 1
stabsread_clear_cache ()
d1173 1
a1173 5
ref_add (refnum, sym, stabs, value)
     int refnum;
     struct symbol *sym;
     char *stabs;
     CORE_ADDR value;
d1195 1
a1195 2
ref_search (refnum)
     int refnum;
d1205 1
a1205 2
ref_search_value (refnum)
     int refnum;
d1216 1
a1216 2
process_reference (string)
     char **string;
d1241 1
a1241 2
symbol_reference_defined (string)
     char **string;
d1266 2
a1267 6
define_symbol (valu, string, desc, type, objfile)
     CORE_ADDR valu;
     char *string;
     int desc;
     int type;
     struct objfile *objfile;
d2161 1
a2161 4
resolve_live_range (objfile, sym, p)
     struct objfile *objfile;
     struct symbol *sym;
     char *p;
d2229 2
a2230 4
add_live_range (objfile, sym, start, end)
     struct objfile *objfile;
     struct symbol *sym;
     CORE_ADDR start, end;
d2291 1
a2291 3
error_type (pp, objfile)
     char **pp;
     struct objfile *objfile;
d2323 1
a2323 3
read_type (pp, objfile)
     register char **pp;
     struct objfile *objfile;
d2753 1
a2753 2
rs6000_builtin_type (typenum)
     int typenum;
d2928 2
a2929 5
read_member_functions (fip, pp, type, objfile)
     struct field_info *fip;
     char **pp;
     struct type *type;
     struct objfile *objfile;
d3219 2
a3220 5
read_cpp_abbrev (fip, pp, type, objfile)
     struct field_info *fip;
     char **pp;
     struct type *type;
     struct objfile *objfile;
d3305 2
a3306 6
read_one_struct_field (fip, pp, p, type, objfile)
     struct field_info *fip;
     char **pp;
     char *p;
     struct type *type;
     struct objfile *objfile;
d3472 2
a3473 5
read_struct_fields (fip, pp, type, objfile)
     struct field_info *fip;
     char **pp;
     struct type *type;
     struct objfile *objfile;
d3569 2
a3570 5
read_baseclasses (fip, pp, type, objfile)
     struct field_info *fip;
     char **pp;
     struct type *type;
     struct objfile *objfile;
d3696 2
a3697 5
read_tilde_fields (fip, pp, type, objfile)
     struct field_info *fip;
     char **pp;
     struct type *type;
     struct objfile *objfile;
d3775 1
a3775 3
attach_fn_fields_to_type (fip, type)
     struct field_info *fip;
     register struct type *type;
d3799 2
a3800 5
read_cfront_static_fields (fip, pp, type, objfile)
     struct field_info *fip;
     char **pp;
     struct type *type;
     struct objfile *objfile;
d3882 2
a3883 4
copy_cfront_struct_fields (fip, type, objfile)
     struct field_info *fip;
     struct type *type;
     struct objfile *objfile;
d3927 2
a3928 4
attach_fields_to_type (fip, type, objfile)
     struct field_info *fip;
     register struct type *type;
     struct objfile *objfile;
d4028 1
a4028 4
read_struct_type (pp, type, objfile)
     char **pp;
     struct type *type;
     struct objfile *objfile;
d4075 2
a4076 4
read_array_type (pp, type, objfile)
     register char **pp;
     register struct type *type;
     struct objfile *objfile;
d4140 2
a4141 4
read_enum_type (pp, type, objfile)
     register char **pp;
     register struct type *type;
     struct objfile *objfile;
d4390 1
a4390 4
read_huge_number (pp, end, bits)
     char **pp;
     int end;
     int *bits;
d4694 1
a4694 4
read_args (pp, end, objfile)
     char **pp;
     int end;
     struct objfile *objfile;
d4748 1
a4748 3
common_block_start (name, objfile)
     char *name;
     struct objfile *objfile;
d4767 1
a4767 2
common_block_end (objfile)
     struct objfile *objfile;
d4830 1
a4830 3
fix_common_block (sym, valu)
     struct symbol *sym;
     int valu;
d4849 1
a4849 2
add_undefined_type (type)
     struct type *type;
d4871 1
a4871 1
cleanup_undefined_types ()
d4942 1
a4942 2
scan_file_globals (objfile)
     struct objfile *objfile;
d5100 1
a5100 1
stabsread_init ()
d5109 1
a5109 1
stabsread_new_init ()
d5119 1
a5119 1
start_stabs ()
d5136 1
a5136 1
end_stabs ()
d5148 1
a5148 2
finish_global_stabs (objfile)
     struct objfile *objfile;
d5161 1
a5161 1
_initialize_stabsread ()
@


1.4
log
@Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * objfiles.h (SECT_OFF_DATA, SECT_OFF_TEXT, SECT_OFF_BSS,
        SECT_OFF_RODATA): Define as functions of OBJFILE.  Add
        sect_index_text, sect_index_data, sect_index_rodata,
        sect_index_bss to objfile structure.
        * gdb-stabs.h (SECT_OFF_DATA, SECT_OFF_TEXT, SECT_OFF_BSS,
        SECT_OFF_RODATA): Remove.
        * objfiles.c (allocate_objfile): Initialize
        sect_index_{text,data,bss,rodata} to -1, for error detection.

        * symfile.c (default_symfile_offsets): Initialize
        sect_index_{text,data,bss,rodata} from bfd information.
        * xcoffread.c (xcoff_symfile_offsets): Ditto.
        * somread.c (som_symfile_offsets): Initialize
        sect_index_{text,data,bss,rodata}.

        * coffread.c, dbxread.c, elfread.c, hp-psymtab-read.c,
        hp-symtab-read.c, hpread.c, mdebugread.c, minsyms.c,
        mipsread.c, objfiles.c, os9kread.c, pa64solib.c, partial-stab.h,
        remote-os9k.c, remote-vx.c, remote.c, rs6000-nat.c, somsolib.c,
        stabsread.c, symfile.c, xcoffread.c:
        Update use of SECT_OFF_{TEXT,DATA,BSS,RODATA} to depend on the
        current objfile.

        * xcoffread.c: Add new field objfile to find_targ_sec_arg.
@
text
@d54 1
a54 1
extern void _initialize_stabsread PARAMS ((void));
d85 2
a86 2
read_one_struct_field PARAMS ((struct field_info *, char **, char *,
			       struct type *, struct objfile *));
d88 1
a88 2
static char *
  get_substring PARAMS ((char **, int));
d90 1
a90 2
static struct type *
  dbx_alloc_type PARAMS ((int[2], struct objfile *));
d92 1
a92 1
static long read_huge_number PARAMS ((char **, int, int *));
d94 1
a94 1
static struct type *error_type PARAMS ((char **, struct objfile *));
d97 2
a98 2
patch_block_stabs PARAMS ((struct pending *, struct pending_stabs *,
			   struct objfile *));
d100 1
a100 2
static void
fix_common_block PARAMS ((struct symbol *, int));
d102 1
a102 2
static int
read_type_number PARAMS ((char **, int *));
d104 1
a104 2
static struct type *
  read_range_type PARAMS ((char **, int[2], struct objfile *));
d106 1
a106 2
static struct type *
  read_sun_builtin_type PARAMS ((char **, int[2], struct objfile *));
d108 2
a109 2
static struct type *
  read_sun_floating_type PARAMS ((char **, int[2], struct objfile *));
d111 1
a111 2
static struct type *
  read_enum_type PARAMS ((char **, struct type *, struct objfile *));
d113 1
a113 2
static struct type *
  rs6000_builtin_type PARAMS ((int));
d116 2
a117 2
read_member_functions PARAMS ((struct field_info *, char **, struct type *,
			       struct objfile *));
d120 2
a121 2
read_struct_fields PARAMS ((struct field_info *, char **, struct type *,
			    struct objfile *));
d124 2
a125 2
read_baseclasses PARAMS ((struct field_info *, char **, struct type *,
			  struct objfile *));
d128 2
a129 2
read_tilde_fields PARAMS ((struct field_info *, char **, struct type *,
			   struct objfile *));
d131 1
a131 2
static int
attach_fn_fields_to_type PARAMS ((struct field_info *, struct type *));
d134 1
a134 2
attach_fields_to_type PARAMS ((struct field_info *, struct type *,
			       struct objfile *));
d136 2
a137 2
static struct type *
  read_struct_type PARAMS ((char **, struct type *, struct objfile *));
d139 2
a140 2
static struct type *
  read_array_type PARAMS ((char **, struct type *, struct objfile *));
d142 1
a142 2
static struct type **
  read_args PARAMS ((char **, int, struct objfile *));
d145 2
a146 2
read_cpp_abbrev PARAMS ((struct field_info *, char **, struct type *,
			 struct objfile *));
d151 2
a152 2
copy_cfront_struct_fields PARAMS ((struct field_info *, struct type *,
				   struct objfile *));
d154 1
a154 2
static char *
  get_cfront_method_physname PARAMS ((char *));
d157 2
a158 2
read_cfront_baseclasses PARAMS ((struct field_info *, char **,
				 struct type *, struct objfile *));
d161 2
a162 2
read_cfront_static_fields PARAMS ((struct field_info *, char **,
				   struct type *, struct objfile *));
d164 2
a165 2
read_cfront_member_functions PARAMS ((struct field_info *, char **,
				      struct type *, struct objfile *));
d170 1
a170 2
add_live_range PARAMS ((struct objfile *, struct symbol *,
			CORE_ADDR, CORE_ADDR));
d172 1
a172 2
static int
resolve_live_range PARAMS ((struct objfile *, struct symbol *, char *));
d174 1
a174 2
static int
process_reference PARAMS ((char **string));
d176 1
a176 2
static CORE_ADDR
  ref_search_value PARAMS ((int refnum));
d179 1
a179 1
resolve_symbol_reference PARAMS ((struct objfile *, struct symbol *, char *));
d181 1
a181 1
void stabsread_clear_cache PARAMS ((void));
d275 1
a275 1
static void os9k_init_type_vector PARAMS ((struct type **));
@


1.3
log
@Convert REG_STRUCT_HAS_ADDR to multi-arch.  Use REG_STRUCT_HAS_ADDR_P
in conversion.
@
text
@d1354 1
a1354 1
      SYMBOL_SECTION (sym) = SECT_OFF_TEXT;
d1357 1
a1357 1
      SYMBOL_SECTION (sym) = SECT_OFF_DATA;
d1360 1
a1360 1
      SYMBOL_SECTION (sym) = SECT_OFF_BSS;
@


1.2
log
@	Clean up compiler warnings:
	* bcache.h, bcache.c, c-valprint.c, coffread.c, stabsread.c,
	stack.c, valprint.c: Change variables to unsigned.
	* bcache.c: Rearrange to avoid warnings about variables not being set.
	* c-lang.c, ch-lang.c, f-lang.c, m2-lang.c: Include valprint.h
	rather than declaring print_max and repeat_count_threashold
	ourselves (incorrectly).
	* valprint.h: Do declare repeat_count_threashold.
	* ch-exp.c: Use default case for internal error.
	* findvar.c: Don't omit argument type.
	* symtab.c: Remove unused variable.
@
text
@a561 4
#if !defined (REG_STRUCT_HAS_ADDR)
#define REG_STRUCT_HAS_ADDR(gcc_p,type) 0
#endif

d1898 1
d2156 3
a2158 2
  if (REG_STRUCT_HAS_ADDR (processing_gcc_compilation, SYMBOL_TYPE (sym))
    && (SYMBOL_CLASS (sym) == LOC_REGPARM || SYMBOL_CLASS (sym) == LOC_ARG))
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
             Free Software Foundation, Inc.
d5 1
a5 1
This file is part of GDB.
d7 14
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d49 2
a50 1
#define	EXTERN	/**/
d54 2
d63 9
a71 4
{
  struct nextfield
    {
      struct nextfield *next;
d73 10
a82 13
      /* This is the raw visibility from the stab.  It is not checked
	 for being one of the visibilities we recognize, so code which
	 examines this field better be able to deal.  */
      int visibility;

      struct field field;
    } *list;
  struct next_fnfieldlist
    {
      struct next_fnfieldlist *next;
      struct fn_fieldlist fn_fieldlist;
    } *fnlist;
};
d88 2
a89 2
static char * 
get_substring PARAMS ((char **, int));
d92 1
a92 1
dbx_alloc_type PARAMS ((int [2], struct objfile *));
d109 1
a109 1
read_range_type PARAMS ((char **, int [2], struct objfile *));
d112 1
a112 1
read_sun_builtin_type PARAMS ((char **, int [2], struct objfile *));
d115 1
a115 1
read_sun_floating_type PARAMS ((char **, int [2], struct objfile *));
d118 1
a118 1
read_enum_type PARAMS ((char **, struct type *, struct objfile *));
d121 1
a121 1
rs6000_builtin_type PARAMS ((int));
d147 1
a147 1
read_struct_type PARAMS ((char **, struct type *, struct objfile *));
d150 1
a150 1
read_array_type PARAMS ((char **, struct type *, struct objfile *));
d153 1
a153 1
read_args PARAMS ((char **, int, struct objfile *));
d163 1
a163 1
                                   struct objfile *));
d166 1
a166 1
get_cfront_method_physname PARAMS ((char *));
d169 1
a169 1
read_cfront_baseclasses PARAMS ((struct field_info *, char **, 
d173 1
a173 1
read_cfront_static_fields PARAMS ((struct field_info *, char**,
d176 1
a176 1
read_cfront_member_functions PARAMS ((struct field_info *, char **, 
d182 1
a182 1
add_live_range PARAMS ((struct objfile *, struct symbol *, 
d192 1
a192 1
ref_search_value PARAMS ((int refnum));
d197 6
a202 2
static const char vptr_name[] = { '_','v','p','t','r',CPLUS_MARKER,'\0' };
static const char vb_name[] =   { '_','v','b',CPLUS_MARKER,'\0' };
d209 1
a209 1
#ifndef BELIEVE_PCC_PROMOTION
d212 3
d217 1
a217 1
  {"invalid C++ abbreviation `%s'", 0, 0};
d220 1
a220 1
  {"C++ abbreviated type name unknown at symtab pos %d", 0, 0};
d223 1
a223 1
  {"member function type missing, got '%c'", 0, 0};
d226 1
a226 1
  {"const/volatile indicator missing, got '%c'", 0, 0};
d229 1
a229 1
  {"debug info mismatch between compiler and debugger", 0, 0};
d232 1
a232 1
  {"invalid (minimal) member type data format at symtab pos %d.", 0, 0};
d235 1
a235 1
  {"base type %d of range type is not defined", 0, 0};
d238 1
a238 1
  {"register number %d too large (max %d) in symbol %s", 0, 0};
d241 1
a241 1
  {"virtual function table pointer not found when defining class `%s'", 0, 0};
d244 1
a244 1
  {"Unknown C++ symbol name `%s'", 0, 0};
d247 1
a247 1
  {"Unknown builtin type %d", 0, 0};
d250 1
a250 1
  {"%s: common block `%s' from global_sym_chain unresolved", 0, 0};
d253 1
a253 1
  {"%s", 0, 0};
d256 1
a256 1
  {"%s", 0, 0};
d274 15
a288 14
static struct type **os9k_type_vector[] = {
	0,
	&builtin_type_int,
	&builtin_type_char,
	&builtin_type_long,
	&builtin_type_short,
	&builtin_type_unsigned_char,
	&builtin_type_unsigned_short,
	&builtin_type_unsigned_long,
	&builtin_type_unsigned_int,
	&builtin_type_float,
	&builtin_type_double,
	&builtin_type_void,
	&builtin_type_long_double
d294 2
a295 2
os9k_init_type_vector(tv)
    struct type **tv;
d297 2
a298 2
  int i;
  for (i=0; i<sizeof(os9k_type_vector)/sizeof(struct type **); i++)
d325 2
a326 1
      static struct complaint msg = {"\
d328 1
a328 1
				0, 0};
d344 1
a344 1
	  temp_type = rs6000_builtin_type(index);
d349 1
a349 1
	 Find it in this object file's type vector.  */
d458 1
a458 1
      
d460 2
a461 2
	 patch their types! */
      
d465 1
a465 1
	  pp = (char*) strchr (name, ':');
d468 2
a469 2
	       pp += 2;
	       pp = (char *)strchr(pp, ':');
d471 1
a471 1
	  sym = find_symbol_in_list (symbols, name, pp-name);
d475 6
a480 6
		 the variable was defined *anywhere*, not just whether
		 it is defined in this compilation unit.  But neither
		 xlc or GCC seem to need such a definition, and until
		 we do psymtabs (so that the minimal symbols from all
		 compilation units are available now), I'm not sure
		 how to get the information.  */
d483 2
a484 2
		 ld will remove it from the executable.  There is then
		 a N_GSYM stab for it, but no regular (C_EXT) symbol.  */
d495 1
a495 1
	      if (*(pp-1) == 'F' || *(pp-1) == 'f')
d512 1
a512 1
	      if (*(pp-1) == 'F' || *(pp-1) == 'f')
d525 1
a526 1

d545 2
a546 1
      if (nbits != 0) return -1;
d548 2
a549 1
      if (nbits != 0) return -1;
d555 2
a556 1
      if (nbits != 0) return -1;
d560 1
a561 1

d579 1
a579 1
static char * 
d581 2
a582 2
  char ** p;
  int c;
d587 1
a587 1
  if (*p) 
d592 1
a592 1
  else 
d602 1
a602 1
static char * 
d604 1
a604 1
  char *fname;
d609 1
a609 1
  char * p = fname;
d612 3
a614 3
  if (*p == '_' && *(p+1)=='_') /* compiler generated; probably a ctor/dtor */
    p += 2;  		
  while (p && (unsigned) ((p+1) - fname) < strlen (fname) && *(p+1) != '_')
d616 3
a618 3
  if (!(p && *p == '_' && *(p+1) == '_')) 
    error ("Invalid mangled function name %s",fname);
  p += 2; /* advance past '__' */
d633 1
a633 1
             ^^^^^^^^^^^^^^^^^^
d635 3
a637 3
       A:ZcA;;foopri__1AFv foopro__1AFv __ct__1AFv __ct__1AFRC1A foopub__1AFv ;;;
             ^
   */
d640 5
a644 5
read_cfront_baseclasses (fip, pp, type, objfile) 
  struct field_info *fip;
  struct objfile *objfile;
  char ** pp;
  struct type *type;
d646 2
a647 1
  static struct complaint msg_unknown = {"\
d649 3
a651 2
		  0, 0};
  static struct complaint msg_notfound = {"\
d653 1
a653 1
                                0, 0};
d655 1
a655 1
  char * p;
d671 1
a671 1
  bnum++;	/* add one more for last one */
d676 1
a676 1
  TYPE_N_BASECLASSES(type) = bnum;
d693 3
a695 3
      new -> next = fip -> list;
      fip -> list = new;
      FIELD_BITSIZE (new->field) = 0; /* this should be an unpacked field! */
d700 4
a703 4
      if (**pp=='v')
        {
          SET_TYPE_FIELD_VIRTUAL (type, i);
          ++(*pp);
d707 1
a707 1
	/* Note: protected inheritance not supported in cfront */
d709 18
a726 17
        {
          case CFRONT_VISIBILITY_PRIVATE:
            new -> visibility = VISIBILITY_PRIVATE;
            break;
          case CFRONT_VISIBILITY_PUBLIC:
            new -> visibility = VISIBILITY_PUBLIC;
            break;
          default:
            /* Bad visibility format.  Complain and treat it as
               public.  */
            {
              static struct complaint msg = {
                "Unknown visibility `%c' for baseclass", 0, 0};
              complain (&msg, new -> visibility);
              new -> visibility = VISIBILITY_PUBLIC;
            }
        }
d729 4
a732 4
      if (**pp!='@@')
        {
          complain (&msg_unknown, *pp);
          return 1;
d737 8
a744 8
        /* Set the bit offset of the portion of the object corresponding 
	   to this baseclass.  Always zero in the absence of
           multiple inheritance.  */
 	/* Unable to read bit position from stabs;
	   Assuming no multiple inheritance for now FIXME! */
	/* We may have read this in the structure definition;
	   now we should fixup the members to be the actual base classes */
        FIELD_BITPOS (new->field) = 0;
d746 24
a769 1
	/* Get the base class name and type */
d771 2
a772 26
  	    char * bname;		/* base class name */
  	    struct symbol * bsym;	/* base class */
	    char * p1, * p2;
	    p1 = strchr (*pp,' ');
	    p2 = strchr (*pp,';');
	    if (p1<p2)
              bname = get_substring (pp,' ');
	    else
              bname = get_substring (pp,';');
            if (!bname || !*bname)
	      {
	        complain (&msg_unknown, *pp);
		return 1;
	      }
	    /* FIXME! attach base info to type */
	    bsym = lookup_symbol (bname, 0, STRUCT_NAMESPACE, 0, 0); /*demangled_name*/
	    if (bsym) 
	      {
	        new -> field.type = SYMBOL_TYPE(bsym);
      		new -> field.name = type_name_no_tag (new -> field.type);
	      }
	    else
	      {
	        complain (&msg_notfound, *pp);
		return 1;
	      }
d774 1
d787 4
a790 4
                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 
       A:ZcA;;foopri__1AFv foopro__1AFv __ct__1AFv __ct__1AFRC1A foopub__1AFv ;;;
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 
*/
d813 2
a814 1
    } *sublist;
d819 3
a821 3
  char * fname;
  struct symbol * ref_func = 0;
      
d825 1
a825 1
  STABS_CONTINUE (pp, objfile); 		/* handle \\ */
d827 1
a827 1
  while (**pp != ';' && (fname = get_substring (pp, ' '), fname)) 
d831 12
a842 11
      char * pname;
      if (fname[0] == '*')      /* static member */
        {
          is_static=1;
          sublist_count++;
          fname++;
        }
      ref_func = lookup_symbol (fname, 0, VAR_NAMESPACE, 0, 0); /* demangled name */
      if (!ref_func) 
        {
          static struct complaint msg = {"\
d844 1
a844 1
                                0, 0};
d851 1
a851 1
          
d853 1
a853 1
      xmalloc (sizeof (struct next_fnfieldlist));
d856 1
a856 1
          
d861 8
a868 8
        char *dem, *dem_p, *dem_args;
        int dem_len;
        dem = cplus_demangle (fname, DMGL_ANSI | DMGL_PARAMS);
        if (dem != NULL)
          {
            dem_p = strrchr (dem, ':');
            if (dem_p != 0 && *(dem_p-1) == ':')
              dem_p++;
d870 1
a870 1
            dem_args = strchr (dem_p, '(');
d874 25
a898 31
      	      dem_len = dem_args - dem_p;
            main_fn_name =
                   obsavestring (dem_p, dem_len, &objfile -> type_obstack);
          }
        else
          {
            main_fn_name =
                   obsavestring (fname, strlen (fname), &objfile -> type_obstack);
          }
      } /* end of code for cfront work around */

    new_fnlist -> fn_fieldlist.name = main_fn_name;
      
    /*-------------------------------------------------*/
    /* Set up the sublists
       Sublists are stuff like args, static, visibility, etc.
       so in ARM, we have to set that info some other way.
       Multiple sublists happen if overloading
       eg: foo::26=##1;:;2A.;
       In g++, we'd loop here thru all the sublists...  */

    new_sublist =
    	(struct next_fnfield *) xmalloc (sizeof (struct next_fnfield));
    make_cleanup (free, new_sublist);
    memset (new_sublist, 0, sizeof (struct next_fnfield));
	  
    /* eat 1; from :;2A.; */
    new_sublist -> fn_field.type = SYMBOL_TYPE(ref_func); /* normally takes a read_type */
    /* Make this type look like a method stub for gdb */
    TYPE_FLAGS (new_sublist -> fn_field.type) |= TYPE_FLAG_STUB;
    TYPE_CODE (new_sublist -> fn_field.type) = TYPE_CODE_METHOD;
d900 18
a917 7
    /* If this is just a stub, then we don't have the real name here. */
    if (TYPE_FLAGS (new_sublist -> fn_field.type) & TYPE_FLAG_STUB)
      {
        if (!TYPE_DOMAIN_TYPE (new_sublist -> fn_field.type))
        TYPE_DOMAIN_TYPE (new_sublist -> fn_field.type) = type;
        new_sublist -> fn_field.is_stub = 1;
      }
a918 5
    /* physname used later in mangling; eg PFs_i,5 for foo__1aFPFs_i 
       physname gets strcat'd in order to recreate the onto mangled name */
    pname = get_cfront_method_physname (fname);
    new_sublist -> fn_field.physname = savestring (pname, strlen (pname));
      
d920 2
a921 2
    /* Set this member function's visibility fields. 
       Unable to distinguish access from stabs definition!
d923 49
a971 49
	 (for private, set new_sublist->fn_field.is_private = 1,
	 for public, set new_sublist->fn_field.is_protected = 1) */
       
    /* Unable to distinguish const/volatile from stabs definition!
       Assuming normal for now.  FIXME! */

    new_sublist -> fn_field.is_const = 0;
    new_sublist -> fn_field.is_volatile = 0;	/* volatile not implemented in cfront */
	  
    /* Set virtual/static function info
       How to get vtable offsets ? 
       Assuming normal for now FIXME!! 
       For vtables, figure out from whence this virtual function came.
       It may belong to virtual function table of
       one of its baseclasses.
	 set:
	   new_sublist -> fn_field.voffset = vtable offset,
	   new_sublist -> fn_field.fcontext = look_ahead_type;
	   where look_ahead_type is type of baseclass */
    if (is_static)
      new_sublist -> fn_field.voffset = VOFFSET_STATIC;
    else 				/* normal member function.  */
      new_sublist -> fn_field.voffset = 0;
    new_sublist -> fn_field.fcontext = 0;
 

    /* Prepare new sublist */
    new_sublist -> next = sublist;
    sublist = new_sublist;
    length++;

    /* In g++, we loop thu sublists - now we set from functions. */
    new_fnlist -> fn_fieldlist.fn_fields = (struct fn_field *)
         obstack_alloc (&objfile -> type_obstack, 
     	       sizeof (struct fn_field) * length);
    memset (new_fnlist -> fn_fieldlist.fn_fields, 0,
           sizeof (struct fn_field) * length);
    for (i = length; (i--, sublist); sublist = sublist -> next)
      {
        new_fnlist -> fn_fieldlist.fn_fields[i] = sublist -> fn_field;
      }
      
    new_fnlist -> fn_fieldlist.length = length;
    new_fnlist -> next = fip -> fnlist;
    fip -> fnlist = new_fnlist;
    nfn_fields++;
    total_length += length;
    STABS_CONTINUE (pp, objfile); /* handle \\ */
  } /* end of loop */
d977 1
a977 1
      TYPE_ALLOC (type, sizeof (struct fn_fieldlist) * nfn_fields);
d979 1
a979 1
         	sizeof (struct fn_fieldlist) * nfn_fields);
d1002 3
a1004 3
  struct objfile * objfile;
  struct symbol * sym;
  char * p;
d1006 2
a1007 2
  struct symbol * ref_sym=0;
  char * sname;
d1016 1
a1016 1
  fi.fnlist = NULL;       
d1024 5
a1028 5
  if (*p != 's'       /* structs */
    && *p != 'c'      /* class */
    && *p != 'u')     /* union */
    return 0;  /* only handle C++ types */
  p++;  
d1033 1
a1033 1
  if (!sname || strcmp (sname, SYMBOL_NAME(sym)))
d1039 2
a1040 2
  ref_sym = lookup_symbol (SYMBOL_NAME(sym), 0, STRUCT_NAMESPACE, 0, 0); 
  type = SYMBOL_TYPE(ref_sym);
d1049 2
a1050 2
      /* g++ does this next, but cfront already did this: 
	    || !read_struct_fields (&fi, &p, type, objfile) */
d1056 3
a1058 3
      /* g++ does this next, but cfront doesn't seem to have this: 
      		|| !read_tilde_fields (&fi, &p, type, objfile) */
      )
d1064 1
a1064 1
  return 0;  
d1074 3
a1076 3
  struct objfile *objfile;
  struct symbol *sym;
  char *p;
d1079 1
a1079 1
  struct symbol *ref_sym=0;
d1084 1
a1084 1
    return 0;  
d1091 1
a1091 1
  /*---------------------------------------------------------*/
d1094 2
a1095 2
       eg: id=2 for p : "2=", "2=z:r(0,1)" "2:r(0,1);l(#5,#6),l(#7,#4)" */
  /*---------------------------------------------------------*/
d1117 3
a1119 3
         RSYM   0      5      00000000 868    #15=z:r(0,1)
         LBRAC  0      0      00000000 899    #5=
         SLINE  0      16     00000003 923    #6=
d1121 1
a1121 1
         RSYM   0      5      00000000 927    #15:r(0,1);l(#5,#6)
d1124 1
a1124 1
        class for a symbol (#15=z) which was previously defined.
d1126 11
a1136 11
        (#15) are the values of the beginning (#5) and ending (#6) 
        symbols. */
       
   /* Read number as reference id.
      eg: p : "=", "=z:r(0,1)" ":r(0,1);l(#5,#6),l(#7,#4)" */
   /* FIXME! Might I want to use SYMBOL_CLASS (sym) = LOC_OPTIMIZED_OUT;
      in case of "l(0,0)"? */

   /*--------------------------------------------------*/
   /* Add this symbol to the reference list.           */
   /*--------------------------------------------------*/
d1165 5
a1169 5
   /* Want to fix up name so that other functions (eg. valops)
      will correctly print the name.
      Don't add_symbol_to_list so that lookup_symbol won't find it.
      nope... needed for fixups. */
   SYMBOL_NAME (sym) = SYMBOL_NAME (ref_sym);
d1189 1
a1189 1
static struct ref_map *ref_map;	
d1192 1
a1192 1
static int ref_count = 0;	
d1197 10
d1224 1
a1224 1
      int new_slots = ref_count - ref_chunk * MAX_CHUNK_REFS; 
d1256 1
a1256 1
   
d1260 1
a1260 1
static int 
d1262 1
a1262 1
    char **string;
d1267 3
a1269 3
  if (**string != '#') 
    return 0;	
     
d1296 1
a1296 1
  if (*p == '=') 
d1298 1
a1298 1
      /* Symbol is being defined here. */ 
d1343 2
a1344 2
       p += 2;
       p = strchr (p, ':');
d1351 2
a1352 2
  current_symbol = sym = (struct symbol *) 
    obstack_alloc (&objfile -> symbol_obstack, sizeof (struct symbol));
d1358 1
a1358 1
      SYMBOL_SECTION(sym) = SECT_OFF_TEXT;
d1361 1
a1361 1
      SYMBOL_SECTION(sym) = SECT_OFF_DATA;
d1364 1
a1364 1
      SYMBOL_SECTION(sym) = SECT_OFF_BSS;
d1371 2
a1372 2
	 number of bytes occupied by a type or object, which we ignore.  */
      SYMBOL_LINE(sym) = desc;
d1376 1
a1376 1
      SYMBOL_LINE(sym) = 0;			/* unknown */
d1384 8
a1391 4
	  case 't':
	    SYMBOL_NAME (sym) = obsavestring ("this", strlen ("this"),
					      &objfile -> symbol_obstack);
	    break;
d1393 4
a1396 8
	  case 'v': /* $vtbl_ptr_type */
	    /* Was: SYMBOL_NAME (sym) = "vptr"; */
	    goto normal;

	  case 'e':
	    SYMBOL_NAME (sym) = obsavestring ("eh_throw", strlen ("eh_throw"),
					      &objfile -> symbol_obstack);
	    break;
d1398 3
a1400 3
	  case '_':
	    /* This was an anonymous type that was never fixed up.  */
	    goto normal;
d1403 3
a1405 3
	  case 'X':
	    /* SunPRO (3.0 at least) static variable encoding.  */
	    goto normal;
d1408 3
a1410 3
	  default:
	    complain (&unrecognized_cplus_name_complaint, string);
	    goto normal;		/* Do *something* with it */
d1420 3
a1422 3
	 reference map.  Else it must be referring to a previously
	 defined symbol, so add it to the alias list of the previously
	 defined symbol.  */
d1426 3
a1428 4
	  ref_add (refnum, sym, string, SYMBOL_VALUE (sym));
      else
	if (!resolve_symbol_reference (objfile, sym, string))
	  return NULL;
d1431 1
a1431 1
	 the correct name into SYMBOL_NAME.  */
d1438 1
a1438 1
		obstack_alloc (&objfile -> symbol_obstack, nlen);
d1448 2
a1449 2
	      SYMBOL_NAME (sym)	= (char *)
		obstack_alloc (&objfile -> symbol_obstack, nlen);
d1461 3
a1463 3
      SYMBOL_LANGUAGE (sym) = current_subfile -> language;
      SYMBOL_NAME (sym)	= (char *)
	obstack_alloc (&objfile -> symbol_obstack, ((p - string) + 1));
d1466 1
a1466 1
	 try it on an executable with a large symbol table. */
d1468 1
a1468 1
	 doubt it.  xoxorich. */
d1480 3
a1482 3
	 demangled form for future reference.  This is a typical time versus
	 space tradeoff, that was decided in favor of time because it sped up
	 C++ symbol lookups by a factor of about 20. */
d1509 5
a1513 5
	 SYMBOL:c=iVALUE for an integer constant symbol.
	 SYMBOL:c=rVALUE for a floating constant symbol.
	 SYMBOL:c=eTYPE,INTVALUE for an enum constant symbol.
	 e.g. "b:c=e6,0" for "const b = blob1"
	 (where type 6 is defined by "blobs:t6=eblob1:0,blob2:1,;").  */
d1544 1
a1544 1
	      obstack_alloc (&objfile -> symbol_obstack,
d1574 1
a1574 1
			   (struct objfile *)NULL);
d1634 2
a1635 2
	 We need to convert this to the function-returning-type-X type
	 in GDB.  E.g. "int" is converted to "function returning int".  */
d1670 1
a1670 1
         	 FIXME: GDB currently ignores vararg functions.  */
d1676 5
a1680 5
		 be promoted to the width of the calling conventions, with
		 a type which references itself. This type is turned into
		 a TYPE_CODE_VOID type by read_type, and we have to turn
		 it back into builtin_type_int here.
		 FIXME: Do we need a new builtin_type_promoted_int_arg ?  */
d1700 3
a1702 3
	 value is not correct.  It is necessary to search for the
	 corresponding linker definition to find the value.
	 These definitions appear at the end of the namelist.  */
d1707 3
a1709 3
	 Symbol references don't have valid names and wont't match up with
	 minimal symbols when the global_sym_chain is relocated.
	 We'll fixup symbol references when we fixup the defining symbol.  */
d1712 3
a1714 3
          i = hashname (SYMBOL_NAME (sym));
          SYMBOL_VALUE_CHAIN (sym) = global_sym_chain[i];
          global_sym_chain[i] = sym;
d1720 2
a1721 2
	 when there is no code letter in the dbx data.
	 Dbx data never actually contains 'l'.  */
d1740 1
a1740 1
	      (lookup_function_type (read_type (&p, objfile)));
d1746 1
a1746 1
	 can also be a LOC_LOCAL_ARG depending on symbol type.  */
d1767 17
a1783 58
#if !BELIEVE_PCC_PROMOTION
      {
	/* This is the signed type which arguments get promoted to.  */
	static struct type *pcc_promotion_type;
	/* This is the unsigned type which arguments get promoted to.  */
	static struct type *pcc_unsigned_promotion_type;

	/* Call it "int" because this is mainly C lossage.  */
	if (pcc_promotion_type == NULL)
	  pcc_promotion_type =
	    init_type (TYPE_CODE_INT, TARGET_INT_BIT / TARGET_CHAR_BIT,
		       0, "int", NULL);

	if (pcc_unsigned_promotion_type == NULL)
	  pcc_unsigned_promotion_type =
	    init_type (TYPE_CODE_INT, TARGET_INT_BIT / TARGET_CHAR_BIT,
		       TYPE_FLAG_UNSIGNED, "unsigned int", NULL);

#if defined(BELIEVE_PCC_PROMOTION_TYPE)
	/* This macro is defined on machines (e.g. sparc) where
	   we should believe the type of a PCC 'short' argument,
	   but shouldn't believe the address (the address is
	   the address of the corresponding int).
	   
	   My guess is that this correction, as opposed to changing
	   the parameter to an 'int' (as done below, for PCC
	   on most machines), is the right thing to do
	   on all machines, but I don't want to risk breaking
	   something that already works.  On most PCC machines,
	   the sparc problem doesn't come up because the calling
	   function has to zero the top bytes (not knowing whether
	   the called function wants an int or a short), so there
	   is little practical difference between an int and a short
	   (except perhaps what happens when the GDB user types
	   "print short_arg = 0x10000;"). 
	   
	   Hacked for SunOS 4.1 by gnu@@cygnus.com.  In 4.1, the compiler
	   actually produces the correct address (we don't need to fix it
	   up).  I made this code adapt so that it will offset the symbol
	   if it was pointing at an int-aligned location and not
	   otherwise.  This way you can use the same gdb for 4.0.x and
	   4.1 systems.
	   
	   If the parameter is shorter than an int, and is integral
	   (e.g. char, short, or unsigned equivalent), and is claimed to
	   be passed on an integer boundary, don't believe it!  Offset the
	   parameter's address to the tail-end of that integer.  */
	
	if (TYPE_LENGTH (SYMBOL_TYPE (sym)) < TYPE_LENGTH (pcc_promotion_type)
	    && TYPE_CODE (SYMBOL_TYPE (sym)) == TYPE_CODE_INT
	    && 0 == SYMBOL_VALUE (sym) % TYPE_LENGTH (pcc_promotion_type))
	  {
	    SYMBOL_VALUE (sym) += TYPE_LENGTH (pcc_promotion_type)
	      - TYPE_LENGTH (SYMBOL_TYPE (sym));
	  }
	break;
	
#else /* no BELIEVE_PCC_PROMOTION_TYPE.  */
d1785 56
a1840 15
	/* If PCC says a parameter is a short or a char,
	   it is really an int.  */
	if (TYPE_LENGTH (SYMBOL_TYPE (sym)) < TYPE_LENGTH (pcc_promotion_type)
	    && TYPE_CODE (SYMBOL_TYPE (sym)) == TYPE_CODE_INT)
	  {
	    SYMBOL_TYPE (sym) =
	      TYPE_UNSIGNED (SYMBOL_TYPE (sym))
		? pcc_unsigned_promotion_type
		: pcc_promotion_type;
	  }
	break;

#endif /* no BELIEVE_PCC_PROMOTION_TYPE.  */
      }
#endif /* !BELIEVE_PCC_PROMOTION.  */
d1851 1
a1851 1
      /*FALLTHROUGH*/
d1862 1
a1862 1
	  SYMBOL_VALUE (sym) = SP_REGNUM;  /* Known safe, though useless */
d1877 1
a1877 1
	  SYMBOL_VALUE (sym) = SP_REGNUM;  /* Known safe, though useless */
d1895 1
a1895 1
	       main(argc) struct foo argc; { register struct foo argc; }
d1909 1
a1909 1
	      )
d1915 1
a1915 1
		  && STREQ (SYMBOL_NAME (prev_sym), SYMBOL_NAME(sym)))
d1926 1
a1926 1
          add_symbol_to_list (sym, &local_symbols);
d1929 1
a1929 1
        add_symbol_to_list (sym, &file_symbols);
d1939 9
a1947 9
      {
	struct minimal_symbol *msym;
	msym = lookup_minimal_symbol (SYMBOL_NAME (sym), NULL, objfile);
	if (msym != NULL)
	  {
	    SYMBOL_NAME (sym) = STATIC_TRANSFORM_NAME (SYMBOL_NAME (sym));
	    SYMBOL_VALUE_ADDRESS (sym) = SYMBOL_VALUE_ADDRESS (msym);
	  }
      }
d1957 3
a1959 2
	 did not use `sym'. Return without further processing. */
      if (nameless) return NULL;
d1965 3
a1967 3
	 a base type which did not have its name defined when the
	 derived class was output.  We fill in the derived class's
	 base part member's name here in that case.  */
d1992 12
a2003 12
		 foo" or "function returning foo", we better not set
		 the TYPE_NAME.  If the program contains "typedef char
		 *caddr_t;", we don't want all variables of type char
		 * to print as caddr_t.  This is not just a
		 consequence of GDB's type management; PCC and GCC (at
		 least through version 2.4) both output variables of
		 either type char * or caddr_t with the type number
		 defined in the 't' symbol for caddr_t.  If a future
		 compiler cleans this up it GDB is not ready for it
		 yet, but if it becomes ready we somehow need to
		 disable this check (without breaking the PCC/GCC2.4
		 case).
d2005 1
a2005 1
		 Sigh.
d2007 2
a2008 2
		 Fortunately, this check seems not to be necessary
		 for anything except pointers or functions.  */
d2019 1
a2019 1
	 by 't' which means we are typedef'ing it as well.  */
d2025 3
a2027 3
	 a typedef for "foo".  Unfortunately, cfront never makes the typedef
	 when translating C++ into C.  We make the typedef here so that
	 "ptype foo" works as expected for cfront translated code.  */
d2034 3
a2036 2
	 did not use `sym'. Return without further processing. */
      if (nameless) return NULL;
d2043 1
a2043 1
	  = obconcat (&objfile -> type_obstack, "", "", SYMBOL_NAME (sym));
d2050 1
a2050 1
	    obstack_alloc (&objfile -> symbol_obstack, sizeof (struct symbol));
d2057 1
a2057 1
	      = obconcat (&objfile -> type_obstack, "", "", SYMBOL_NAME (sym));
d2069 9
a2077 9
      {
	struct minimal_symbol *msym;
	msym = lookup_minimal_symbol (SYMBOL_NAME (sym), NULL, objfile);
	if (msym != NULL)
	  {
	    SYMBOL_NAME (sym) = STATIC_TRANSFORM_NAME (SYMBOL_NAME (sym));
	    SYMBOL_VALUE_ADDRESS (sym) = SYMBOL_VALUE_ADDRESS (msym);
	  }
      }
d2104 1
a2104 1
	  SYMBOL_VALUE (sym) = SP_REGNUM;  /* Known safe, though useless */
d2112 3
a2114 3
	 Sun claims ("dbx and dbxtool interfaces", 2nd ed)
	 that Pascal uses it too, but when I tried it Pascal used
	 "x:3" (local symbol) instead.  */
d2122 2
a2123 2
    /* New code added to support cfront stabs strings.
       Note: case 'P' already handled above */
d2126 11
a2136 11
	 Find the original definition and add to it.
	 We'll have to do this for the typedef too,
	 since we cloned the symbol to define a type in read_type.
	 Stabs info examples:
		 __1C :Ztl 
		 foo__1CFv :ZtF (first def foo__1CFv:F(0,3);(0,24))
		 C:ZsC;;__ct__1CFv func1__1CFv func2__1CFv ... ;;;
		 where C is the name of the class.
	 Unfortunately, we can't lookup the original symbol yet 'cuz 
	 we haven't finished reading all the symbols.
	 Instead, we save it for processing later */
d2138 3
a2140 3
      SYMBOL_TYPE (sym) = error_type (&p, objfile); /* FIXME! change later */ 
      SYMBOL_CLASS (sym) = LOC_CONST; 
      SYMBOL_VALUE (sym) = 0; 
d2160 1
a2160 1
      && (SYMBOL_CLASS (sym) == LOC_REGPARM || SYMBOL_CLASS (sym) == LOC_ARG))
d2184 4
a2187 4
      if (*p && *p == 'l')
        {
          /* GNU extensions for live range splitting may be appended to 
             the end of the stab string.  eg. "l(#1,#2);l(#3,#5)" */
d2195 1
a2195 1
          if (!*p || *p != ')')
d2200 2
a2201 2
          p++;
       }
d2232 1
a2232 1
	
d2296 1
a2296 1
    obstack_alloc (&objfile->type_obstack, 
d2313 1
a2314 1

d2322 1
a2322 1
     return error_type (pp, objfile);
d2330 1
a2330 1
     return error_type (pp, objfile);
d2336 1
a2336 1
     foo = error_type (pp, objfile);
d2338 1
a2338 1
     ++*pp;
d2370 1
a2371 1

d2404 1
a2404 1
      
d2406 2
a2407 2
	 or this is a forward reference to it.  dbx_alloc_type handles
	 both cases.  */
d2413 2
a2414 2
	 Also skip the type descriptor - we get it below with (*pp)[-1].  */
      (*pp)+=2;
d2419 1
a2419 1
	 the definition, but don't put it in the type vector.  */
d2424 1
a2424 1
 again:
d2435 1
a2435 1
	
d2438 1
a2438 1
	
d2441 1
a2441 1
	  
d2459 1
a2459 1
		  {"Unrecognized cross-reference type `%c'", 0, 0};
d2465 1
a2465 1
	   
d2486 3
a2488 3
	  to = type_name = 
		(char *)obstack_alloc (&objfile->type_obstack, p - *pp + 1);
	
d2491 1
a2491 1
	  while (from < p) 
d2494 1
a2494 1
	  
d2516 1
a2516 1
		  obstack_free (&objfile -> type_obstack, type_name);
d2530 1
a2530 1
	INIT_CPLUS_SPECIFIC(type);
d2537 1
a2537 1
    case '-':				/* RS/6000 built-in type */
d2552 1
a2552 1
	 the Lucid compiler and recent gcc versions (post 2.7.3) use. */
d2555 1
a2555 1
	 This handles recursive types. */
d2558 2
a2559 1
      { struct type *xtype = read_type (pp, objfile);
d2580 6
a2585 6
    /* In the following types, we must be sure to overwrite any existing
       type that the typenums refer to, rather than allocating a new one
       and making the typenums point to the new one.  This is because there
       may already be pointers to the existing type (if it had been
       forward-referenced), and we must change it to a pointer, function,
       reference, or whatever, *in-place*.  */
d2592 1
a2592 1
    case '&':				/* Reference to another type */
d2597 1
a2597 1
    case 'f':				/* Function returning another type */
d2607 5
a2611 4
            {
              t = read_type (pp, objfile);
              if (**pp == ',') ++*pp;
            }
d2617 2
a2618 2
    case 'k':			   /* Const qualifier on some type (Sun) */
    case 'c':			   /* Const qualifier on some type (OS9000) */
d2620 1
a2620 1
	 only accept 'c' in the os9k_stabs case.  */
d2627 2
a2628 2
    case 'B':			     /* Volatile qual on some type (Sun) */
    case 'i':			     /* Volatile qual on some type (OS9000) */
d2630 1
a2630 1
	 only accept 'i' in the os9k_stabs case.  */
d2638 2
a2639 2
      if (isdigit (**pp) || **pp ==  '(' || **pp == '-')
	{ /* Member (class & variable) type */
d2654 2
a2655 1
      else /* type attribute */
d2664 1
a2664 1
	    ++*pp;  /* Skip the semicolon.  */
d2680 1
a2680 1
		 can invent new ones.  */
d2688 1
a2688 1
    case '#':				/* Method (class & fn) type */
d2721 1
a2721 1
    case 'r':				/* Range type */
d2740 1
a2740 1
    case 'R':				/* Sun ACC builtin float type */
d2745 2
a2746 2
    
    case 'e':				/* Enumeration type */
d2753 2
a2754 2
    case 's':				/* Struct type */
    case 'u':				/* Union type */
d2758 6
a2763 6
	  case 's':
	    TYPE_CODE (type) = TYPE_CODE_STRUCT;
	    break;
	  case 'u':
	    TYPE_CODE (type) = TYPE_CODE_UNION;
	    break;
d2768 1
a2768 1
    case 'a':				/* Array type */
d2772 1
a2772 1
      
d2781 1
a2781 1
      type = create_set_type ((struct type*) NULL, type1);
d2790 1
a2790 1
				/* Particularly important if it was \0! */
d2829 1
a2829 1
  #error This code wrong for TARGET_CHAR_BIT not 8
d2840 4
a2843 4
	 by the debugging format.  If there is a type called "int" which
	 is other than 32 bits, then it should use a new negative type
	 number (or avoid negative type numbers for that case).
	 See stabs.texinfo.  */
d2890 2
a2891 2
	 different sizes for "long double" should use different negative
	 type numbers.  See stabs.texinfo.  */
d2974 1
a2974 1
	NAME :: TYPENUM[=type definition] ARGS : PHYSNAME ;
d2978 1
a2978 1
	afunc1::20=##15;:i;2A.;afunc2::20:i;2A.;
d3004 2
a3005 1
    } *sublist;
d3011 1
a3011 1
      
d3018 2
a3019 2
	 Scan forward to find the first ':' and if it is not the
	 first of a "::" delimiter, then this is not a member function. */
d3033 1
a3033 1
      
d3038 1
a3038 1
      
d3050 2
a3051 1
	  static char opname[32] = {'o', 'p', CPLUS_MARKER};
d3053 1
a3053 1
	  
d3073 2
a3074 2
      new_fnlist -> fn_fieldlist.name = main_fn_name;
      
d3081 1
a3081 1
	  
d3087 2
a3088 2
	      
	      new_sublist -> fn_field.type = read_type (pp, objfile);
d3098 1
a3098 1
	      new_sublist -> fn_field.type = look_ahead_type;
d3101 1
a3101 1
	  
d3108 1
a3108 1
	  
d3111 1
a3111 1
	  if (TYPE_FLAGS (new_sublist -> fn_field.type) & TYPE_FLAG_STUB)
d3113 3
a3115 3
	      if (!TYPE_DOMAIN_TYPE (new_sublist -> fn_field.type))
		TYPE_DOMAIN_TYPE (new_sublist -> fn_field.type) = type;
	      new_sublist -> fn_field.is_stub = 1;
d3117 1
a3117 1
	  new_sublist -> fn_field.physname = savestring (*pp, p - *pp);
d3119 1
a3119 1
	  
d3123 6
a3128 6
	      case VISIBILITY_PRIVATE:
	        new_sublist -> fn_field.is_private = 1;
		break;
	      case VISIBILITY_PROTECTED:
		new_sublist -> fn_field.is_protected = 1;
		break;
d3130 1
a3130 1
	  
d3134 27
a3160 27
	      case 'A': /* Normal functions. */
	        new_sublist -> fn_field.is_const = 0;
		new_sublist -> fn_field.is_volatile = 0;
		(*pp)++;
		break;
	      case 'B': /* `const' member functions. */
		new_sublist -> fn_field.is_const = 1;
		new_sublist -> fn_field.is_volatile = 0;
		(*pp)++;
		break;
	      case 'C': /* `volatile' member function. */
		new_sublist -> fn_field.is_const = 0;
		new_sublist -> fn_field.is_volatile = 1;
		(*pp)++;
		break;
	      case 'D': /* `const volatile' member function. */
		new_sublist -> fn_field.is_const = 1;
		new_sublist -> fn_field.is_volatile = 1;
		(*pp)++;
		break;
	      case '*': /* File compiled with g++ version 1 -- no info */
	      case '?':
	      case '.':
		break;
	      default:
		complain (&const_vol_complaint, **pp);
		break;
d3162 1
a3162 1
	  
d3165 1
a3165 1
	      case '*':
d3168 1
a3168 1
	        /* virtual member function, followed by index.
d3175 1
a3175 1
	        new_sublist -> fn_field.voffset =
d3179 1
a3179 1
	      
d3184 1
a3184 1
		    new_sublist -> fn_field.fcontext = 0;
d3198 1
a3198 1
			new_sublist -> fn_field.fcontext = look_ahead_type;
d3212 20
a3231 20
	      case '?':
		/* static member function.  */
		new_sublist -> fn_field.voffset = VOFFSET_STATIC;
		if (strncmp (new_sublist -> fn_field.physname,
			     main_fn_name, strlen (main_fn_name)))
		  {
		    new_sublist -> fn_field.is_stub = 1;
		  }
		break;
	      
	      default:
		/* error */
		complain (&member_fn_complaint, (*pp)[-1]);
		/* Fall through into normal member function.  */
	      
	      case '.':
		/* normal member function.  */
		new_sublist -> fn_field.voffset = 0;
		new_sublist -> fn_field.fcontext = 0;
		break;
d3233 2
a3234 2
	  
	  new_sublist -> next = sublist;
d3240 1
a3240 1
      
d3242 3
a3244 3
      
      new_fnlist -> fn_fieldlist.fn_fields = (struct fn_field *)
	obstack_alloc (&objfile -> type_obstack, 
d3246 1
a3246 1
      memset (new_fnlist -> fn_fieldlist.fn_fields, 0,
d3248 1
a3248 1
      for (i = length; (i--, sublist); sublist = sublist -> next)
d3250 1
a3250 1
	  new_fnlist -> fn_fieldlist.fn_fields[i] = sublist -> fn_field;
d3252 4
a3255 4
      
      new_fnlist -> fn_fieldlist.length = length;
      new_fnlist -> next = fip -> fnlist;
      fip -> fnlist = new_fnlist;
d3301 3
a3303 3
	 where the type number before the ':' is the "context" and
	 everything after is a regular type definition.  Lookup the
	 type, find it's name, and construct the field name. */
d3309 4
a3312 4
	  case 'f':		/* $vf -- a virtual function table pointer */
	    fip->list->field.name =
	      obconcat (&objfile->type_obstack, vptr_name, "", "");
	    break;
d3314 10
a3323 10
	  case 'b':		/* $vb -- a virtual bsomethingorother */
	    name = type_name_no_tag (context);
	    if (name == NULL)
	      {
		complain (&invalid_cpp_type_complaint, symnum);
		name = "FOO";
	      }
	    fip->list->field.name =
	      obconcat (&objfile->type_obstack, vb_name, name, "");
	    break;
d3325 6
a3330 6
	  default:
	    complain (&invalid_cpp_abbrev_complaint, *pp);
	    fip->list->field.name =
	      obconcat (&objfile->type_obstack,
			"INVALID_CPLUSPLUS_ABBREV", "", "");
	    break;
d3334 1
a3334 1
	 field type. */
d3344 1
a3344 1
	(*pp)++;			/* Skip the comma.  */
d3362 2
a3363 2
	 better return 0.  If we returned 1, we would need to at least advance
	 *pp to avoid an infinite loop.  */
d3380 1
a3380 1
  */
d3389 7
a3395 7
        {
          dem_p = strrchr (dem, ':');
          if (dem_p != 0 && *(dem_p-1)==':')
            dem_p++;
          FIELD_NAME (fip->list->field) =
            obsavestring (dem_p, strlen (dem_p), &objfile -> type_obstack);
        }
d3397 4
a3400 4
        {
          FIELD_NAME (fip->list->field) =
            obsavestring (*pp, p - *pp, &objfile -> type_obstack);
        }
d3406 2
a3407 2
    fip -> list -> field.name =
    obsavestring (*pp, p - *pp, &objfile -> type_obstack);
d3414 1
a3414 1
      fip -> list -> visibility = *(*pp)++;
d3419 1
a3419 1
      fip -> list -> visibility = VISIBILITY_PUBLIC;
d3422 1
a3422 1
  fip -> list -> field.type = read_type (pp, objfile);
d3430 1
a3430 1
	  fip -> list -> field.bitpos = (long)-2; /* nested type */
d3433 2
a3434 1
      else ...;
d3436 1
a3436 1
      while (*p != ';') 
d3474 12
a3485 12
	 it is a field which has been optimized out.  The correct stab for
	 this case is to use VISIBILITY_IGNORE, but that is a recent
	 invention.  (2) It is a 0-size array.  For example
	 union { int num; char str[0]; } foo.  Printing "<no value>" for
	 str in "p foo" is OK, since foo.str (and thus foo.str[3])
	 will continue to work, and a 0-size array as a whole doesn't
	 have any contents to print.

	 I suspect this probably could also happen with gcc -gstabs (not
	 -gstabs+) for static fields, and perhaps other C++ extensions.
	 Hopefully few people use -gstabs with gdb, since it is intended
	 for dbx compatibility.  */
d3488 1
a3488 1
      fip -> list-> visibility = VISIBILITY_IGNORE;
d3493 3
a3495 3
	 dbx gives a bit size for all fields.
	 Note that forward refs cannot be packed,
	 and treat enums as if they had the width of ints.  */
d3506 1
a3506 1
      if ((FIELD_BITSIZE (fip->list->field) 
d3509 2
a3510 2
	       && FIELD_BITSIZE (fip->list->field) == TARGET_INT_BIT )
	   )
d3522 1
a3522 1
   	NAME : [VISIBILITY] TYPENUM , BITPOS , BITSIZE ;
d3531 4
a3534 4
   	'/0'	(VISIBILITY_PRIVATE)
	'/1'	(VISIBILITY_PROTECTED)
	'/2'	(VISIBILITY_PUBLIC)
	'/9'	(VISIBILITY_IGNORE)
d3560 2
a3561 1
      if (os9k_stabs && **pp == ',') break;
d3567 2
a3568 2
      new -> next = fip -> list;
      fip -> list = new;
d3574 3
a3576 3
	 unless the CPLUS_MARKER is followed by an underscore, in
	 which case it is just the name of an anonymous type, which we
	 should handle like any other type name.  */
d3586 3
a3588 3
	 values.  Data members are delimited by a single ':', while member
	 functions are delimited by a pair of ':'s.  When we hit the member
	 functions (if any), terminate scan loop and return. */
d3590 1
a3590 1
      while (*p != ':' && *p != '\0') 
d3607 2
a3608 2
	 partially constructed entry which we now scrub. */
      fip -> list = fip -> list -> next;
d3612 1
a3612 1

d3636 3
d3690 2
a3691 2
      new -> next = fip -> list;
      fip -> list = new;
d3697 10
a3706 8
	  case '0':
	    /* Nothing to do. */
	    break;
	  case '1':
	    SET_TYPE_FIELD_VIRTUAL (type, i);
	    break;
	  default:
	    /* Unknown character.  Complain and treat it as non-virtual.  */
d3708 3
a3710 4
	      static struct complaint msg = {
		"Unknown virtual character `%c' for baseclass", 0, 0};
	      complain (&msg, **pp);
	    }
d3714 2
a3715 2
      new -> visibility = *(*pp)++;
      switch (new -> visibility)
d3717 15
a3731 13
	  case VISIBILITY_PRIVATE:
	  case VISIBILITY_PROTECTED:
	  case VISIBILITY_PUBLIC:
	    break;
	  default:
	    /* Bad visibility format.  Complain and treat it as
	       public.  */
	    {
	      static struct complaint msg = {
		"Unknown visibility `%c' for baseclass", 0, 0};
	      complain (&msg, new -> visibility);
	      new -> visibility = VISIBILITY_PUBLIC;
	    }
d3736 1
a3736 1
	
d3747 2
a3748 2
	 base class.  Read it, and remember it's type name as this
	 field's name. */
d3750 2
a3751 2
      new -> field.type = read_type (pp, objfile);
      new -> field.name = type_name_no_tag (new -> field.type);
d3821 1
a3821 1
	  
d3823 1
a3823 1
	  if (type == t)		/* Our own class provides vtbl ptr */
d3829 2
a3830 2
		  if (! strncmp (TYPE_FIELD_NAME (t, i), vptr_name, 
				 sizeof (vptr_name) - 1))
d3845 1
a3845 1
    gotit:
d3860 2
a3861 2
       fip -> fnlist != NULL;
       fip -> fnlist = fip -> fnlist -> next)
d3863 2
a3864 2
      --n;                      /* Circumvent Sun3 compiler bug */
      TYPE_FN_FIELDLISTS (type)[n] = fip -> fnlist -> fn_fieldlist;
d3872 1
a3872 1
             							   ^^^^^^^^
d3874 3
a3876 3
       A:ZcA;;foopri__1AFv foopro__1AFv __ct__1AFv __ct__1AFRC1A foopub__1AFv ;;;
             							               ^
   */
d3885 1
a3885 1
  struct nextfield * new;
d3887 4
a3890 4
  char * sname;
  struct symbol * ref_static=0;
      
  if (**pp==';')		/* no static data; return */
d3899 2
a3900 2
  STABS_CONTINUE (pp, objfile); 		/* handle \\ */
  while (**pp!=';' && (sname = get_substring (pp, ' '), sname)) 
d3902 5
a3906 4
      ref_static = lookup_symbol (sname, 0, VAR_NAMESPACE, 0, 0); /*demangled_name*/
      if (!ref_static) 
        {
          static struct complaint msg = {"\
d3908 1
a3908 1
                                0, 0};
d3912 1
a3912 1
      stype = SYMBOL_TYPE(ref_static);
d3918 2
a3919 2
      new -> next = fip -> list;
      fip -> list = new;
d3923 1
a3923 1
      new -> visibility = VISIBILITY_PUBLIC;
d3926 1
a3926 1
      fip -> list -> field.type = stype; 
d3935 1
a3935 1
      */
d3937 15
a3951 15
        {
          char *dem, *dem_p;
          dem = cplus_demangle (sname, DMGL_ANSI | DMGL_PARAMS);
          if (dem != NULL)
            {
              dem_p = strrchr (dem, ':');
              if (dem_p != 0 && *(dem_p-1)==':')
                dem_p++;
              fip->list->field.name =
                obsavestring (dem_p, strlen (dem_p), &objfile -> type_obstack);
            }
          else
            {
              fip->list->field.name =
                obsavestring (sname, strlen (sname), &objfile -> type_obstack); 
d3953 2
a3954 2
        } /* end of code for cfront work around */ 
    } /* loop again for next static field */
d3970 1
a3970 1
  int nfields = TYPE_NFIELDS(type);
d3972 1
a3972 1
  struct nextfield * new;
d3977 1
a3977 1
  for (i=0; i<nfields; i++)
d3983 2
a3984 2
      new -> next = fip -> list;
      fip -> list = new;
d3987 1
a3987 1
      new -> field = TYPE_FIELD (type, i);
d3990 1
a3990 1
	new -> visibility = VISIBILITY_PROTECTED;
d3992 1
a3992 1
  	 new -> visibility = VISIBILITY_PRIVATE;
d3994 1
a3994 1
	 new -> visibility = VISIBILITY_PUBLIC;
d4001 1
a4001 1
  TYPE_FIELDS (type)=0;
d4026 1
a4026 1
  for (scan = fip -> list; scan != NULL; scan = scan -> next)
d4029 1
a4029 1
      if (scan -> visibility != VISIBILITY_PUBLIC)
d4067 2
a4068 2
      TYPE_FIELD (type, nfields) = fip -> list -> field;
      switch (fip -> list -> visibility)
d4070 3
a4072 3
	  case VISIBILITY_PRIVATE:
	    SET_TYPE_FIELD_PRIVATE (type, nfields);
	    break;
d4074 3
a4076 3
	  case VISIBILITY_PROTECTED:
	    SET_TYPE_FIELD_PROTECTED (type, nfields);
	    break;
d4078 3
a4080 3
	  case VISIBILITY_IGNORE:
	    SET_TYPE_FIELD_IGNORE (type, nfields);
	    break;
d4082 2
a4083 2
	  case VISIBILITY_PUBLIC:
	    break;
d4085 4
a4088 2
	  default:
	    /* Unknown visibility.  Complain and treat it as public.  */
d4090 4
a4093 5
	      static struct complaint msg = {
		"Unknown visibility `%c' for field", 0, 0};
	      complain (&msg, fip -> list -> visibility);
	    }
	    break;
d4095 1
a4095 1
      fip -> list = fip -> list -> next;
d4112 1
a4112 1
   */
d4210 1
a4210 1
  
d4263 2
a4264 2
	 os9k_stabs (assuming the name of an enum constant can't start
	 with a digit).  */
d4276 1
a4276 1
        (*pp)++;
d4289 3
a4291 2
      while (*p != ':') p++;
      name = obsavestring (*pp, p - *pp, &objfile -> symbol_obstack);
d4298 1
a4298 1
	obstack_alloc (&objfile -> symbol_obstack, sizeof (struct symbol));
d4301 1
a4301 1
      SYMBOL_LANGUAGE (sym) = current_subfile -> language;
d4356 5
a4360 5
	type = b <signed> <width> <format type>; <offset>; <nbits>
	signed = u or s.
	optional format type = c or b for char or boolean.
	offset = offset from high order bit to start bit of type.
	width is # bytes in object of this type, nbits is # bits in type.
d4379 8
a4386 8
      case 's':
        signed_type = 1;
	break;
      case 'u':
	signed_type = 0;
	break;
      default:
	return error_type (pp, objfile);
d4432 1
a4432 1
		      signed_type ? 0 : TYPE_FLAG_UNSIGNED, (char *)NULL,
d4437 1
a4437 1
		      signed_type ? 0 : TYPE_FLAG_UNSIGNED, (char *)NULL,
d4497 1
a4497 1
  
d4526 1
a4526 1
      
d4528 1
a4528 1
	 what GCC does. */
d4570 1
a4570 1
      
d4572 1
a4572 1
	 the number of bits.  */
d4645 2
a4646 2
	 integral type.  Take care of the case where <large number> doesn't
	 fit in a long but <large number>-1 does.  */
d4700 1
a4700 1
	 compatibility hack.  */
d4717 4
d4723 1
a4723 1
	return init_type (TYPE_CODE_INT, - n3, TYPE_FLAG_UNSIGNED,
a4724 4
      if (n3 == 0xff)
	return init_type (TYPE_CODE_INT, 1, TYPE_FLAG_UNSIGNED, NULL, objfile);
      if (n3 == 0xffff)
	return init_type (TYPE_CODE_INT, 2, TYPE_FLAG_UNSIGNED, NULL, objfile);
d4726 15
a4740 3
      /* -1 is used for the upper bound of (4 byte) "unsigned int" and
	 "unsigned long", and we already checked for that,
	 so don't need to test for it here.  */
d4747 3
a4749 3
	       || n2 == - TARGET_LONG_LONG_BIT / TARGET_CHAR_BIT))
    return init_type (TYPE_CODE_INT, - n2, 0, NULL, objfile);
  else if (n2 == -n3 -1)
d4761 1
a4761 1
 handle_true_range:
d4797 1
a4797 1
  struct type *types[1024], **rval; /* allow for fns of 1023 parameters */
d4804 1
a4804 1
	return (struct type **)-1;
d4815 1
a4815 1
  else if (TYPE_CODE (types[n-1]) != TYPE_CODE_VOID)
d4854 2
a4855 1
      static struct complaint msg = {
d4863 1
a4863 1
				    &objfile -> symbol_obstack);
d4885 2
a4886 1
      static struct complaint msg = {"ECOMM symbol unmatched by BCOMM", 0, 0};
d4891 2
a4892 2
  sym = (struct symbol *) 
    obstack_alloc (&objfile -> symbol_obstack, sizeof (struct symbol));
d4934 2
a4935 2
    struct symbol *sym;
    int valu;
d4938 1
a4938 1
  for ( ; next; next = next->next)
d4945 1
a4947 1

d4971 2
a4972 2
			Fix:  update array length using the element bounds
			and the target type's length.
d4974 2
a4975 2
			yet defined at the time a pointer to it was made.
   			Fix:  Do a full lookup on the struct/union tag.  */
d4986 3
a4988 3
	  case TYPE_CODE_STRUCT:
	  case TYPE_CODE_UNION:
	  case TYPE_CODE_ENUM:
d5003 2
a5004 1
		    static struct complaint msg = {"need a type name", 0, 0};
d5013 1
a5013 1
			
d5031 2
a5032 1
	    static struct complaint msg = {"\
d5069 1
a5069 1
	 no unresolved symbols.  */
d5078 1
a5078 1
      for (msymbol = resolve_objfile -> msymbols;
d5105 1
a5105 1
		  STREQ(SYMBOL_NAME (msymbol) + 1, SYMBOL_NAME (sym) + 1))
d5120 1
a5120 1
		  
d5128 1
a5128 1
		  /* FIXME: Maybe should have added aliases to the global chain,		     resolved symbol name, then treated aliases as normal 
d5155 1
a5155 1
		  
d5196 1
a5196 1
		      objfile -> name, SYMBOL_NAME (prev));
d5225 2
a5226 1
void start_stabs ()
d5242 2
a5243 1
void end_stabs ()
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@d199 1
a199 1
#if !defined (BELIEVE_PCC_PROMOTION)
a201 3
#if !defined (BELIEVE_PCC_PROMOTION_TYPE)
#define BELIEVE_PCC_PROMOTION_TYPE 0
#endif
d1735 74
a1808 74
      if (!BELIEVE_PCC_PROMOTION)
	{
	  /* This is the signed type which arguments get promoted to.  */
	  static struct type *pcc_promotion_type;
	  /* This is the unsigned type which arguments get promoted to.  */
	  static struct type *pcc_unsigned_promotion_type;
	  
	  /* Call it "int" because this is mainly C lossage.  */
	  if (pcc_promotion_type == NULL)
	    pcc_promotion_type =
	      init_type (TYPE_CODE_INT, TARGET_INT_BIT / TARGET_CHAR_BIT,
			 0, "int", NULL);
	  
	  if (pcc_unsigned_promotion_type == NULL)
	    pcc_unsigned_promotion_type =
	      init_type (TYPE_CODE_INT, TARGET_INT_BIT / TARGET_CHAR_BIT,
			 TYPE_FLAG_UNSIGNED, "unsigned int", NULL);
	  
	  if (BELIEVE_PCC_PROMOTION_TYPE)
	    {
	      /* This is defined on machines (e.g. sparc) where we
		 should believe the type of a PCC 'short' argument,
		 but shouldn't believe the address (the address is the
		 address of the corresponding int).
		 
		 My guess is that this correction, as opposed to
		 changing the parameter to an 'int' (as done below,
		 for PCC on most machines), is the right thing to do
		 on all machines, but I don't want to risk breaking
		 something that already works.  On most PCC machines,
		 the sparc problem doesn't come up because the calling
		 function has to zero the top bytes (not knowing
		 whether the called function wants an int or a short),
		 so there is little practical difference between an
		 int and a short (except perhaps what happens when the
		 GDB user types "print short_arg = 0x10000;").
		 
		 Hacked for SunOS 4.1 by gnu@@cygnus.com.  In 4.1, the
		 compiler actually produces the correct address (we
		 don't need to fix it up).  I made this code adapt so
		 that it will offset the symbol if it was pointing at
		 an int-aligned location and not otherwise.  This way
		 you can use the same gdb for 4.0.x and 4.1 systems.
		 
		 If the parameter is shorter than an int, and is
		 integral (e.g. char, short, or unsigned equivalent),
		 and is claimed to be passed on an integer boundary,
		 don't believe it!  Offset the parameter's address to
		 the tail-end of that integer.  */
	      
	      if (TYPE_LENGTH (SYMBOL_TYPE (sym)) < TYPE_LENGTH (pcc_promotion_type)
		  && TYPE_CODE (SYMBOL_TYPE (sym)) == TYPE_CODE_INT
		  && 0 == SYMBOL_VALUE (sym) % TYPE_LENGTH (pcc_promotion_type))
		{
		  SYMBOL_VALUE (sym) += TYPE_LENGTH (pcc_promotion_type)
		    - TYPE_LENGTH (SYMBOL_TYPE (sym));
		}
	      break;
	    }
	  else
	    {
	      /* If PCC says a parameter is a short or a char,
		 it is really an int.  */
	      if (TYPE_LENGTH (SYMBOL_TYPE (sym)) < TYPE_LENGTH (pcc_promotion_type)
		  && TYPE_CODE (SYMBOL_TYPE (sym)) == TYPE_CODE_INT)
		{
		  SYMBOL_TYPE (sym) =
		    TYPE_UNSIGNED (SYMBOL_TYPE (sym))
		    ? pcc_unsigned_promotion_type
		    : pcc_promotion_type;
		}
	      break;
	    }
	}
d2150 1
a2150 1
      if (*p && p[0] == 'l' && p[1] == '(')
@


1.1.1.3
log
@import gdb-1999-05-25 snapshot
@
text
@a51 2
extern void _initialize_stabsread PARAMS ((void));

@


1.1.1.4
log
@import gdb-1999-07-07 pre reformat
@
text
@a3576 1
/* *INDENT-OFF* */
a3599 1
/* *INDENT-ON* */
@


1.1.1.5
log
@import gdb-1999-07-07 post reformat
@
text
@d3 1
a3 1
   Free Software Foundation, Inc.
d5 1
a5 1
   This file is part of GDB.
d7 13
a19 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d48 1
a48 2
#define	EXTERN
/**/
d61 4
a64 4
  {
    struct nextfield
      {
	struct nextfield *next;
d66 13
a78 15
	/* This is the raw visibility from the stab.  It is not checked
	   for being one of the visibilities we recognize, so code which
	   examines this field better be able to deal.  */
	int visibility;

	struct field field;
      }
     *list;
    struct next_fnfieldlist
      {
	struct next_fnfieldlist *next;
	struct fn_fieldlist fn_fieldlist;
      }
     *fnlist;
  };
d84 2
a85 2
static char *
  get_substring PARAMS ((char **, int));
d88 1
a88 1
  dbx_alloc_type PARAMS ((int[2], struct objfile *));
d105 1
a105 1
  read_range_type PARAMS ((char **, int[2], struct objfile *));
d108 1
a108 1
  read_sun_builtin_type PARAMS ((char **, int[2], struct objfile *));
d111 1
a111 1
  read_sun_floating_type PARAMS ((char **, int[2], struct objfile *));
d114 1
a114 1
  read_enum_type PARAMS ((char **, struct type *, struct objfile *));
d117 1
a117 1
  rs6000_builtin_type PARAMS ((int));
d143 1
a143 1
  read_struct_type PARAMS ((char **, struct type *, struct objfile *));
d146 1
a146 1
  read_array_type PARAMS ((char **, struct type *, struct objfile *));
d149 1
a149 1
  read_args PARAMS ((char **, int, struct objfile *));
d159 1
a159 1
				   struct objfile *));
d162 1
a162 1
  get_cfront_method_physname PARAMS ((char *));
d165 1
a165 1
read_cfront_baseclasses PARAMS ((struct field_info *, char **,
d169 1
a169 1
read_cfront_static_fields PARAMS ((struct field_info *, char **,
d172 1
a172 1
read_cfront_member_functions PARAMS ((struct field_info *, char **,
d178 1
a178 1
add_live_range PARAMS ((struct objfile *, struct symbol *,
d188 1
a188 1
  ref_search_value PARAMS ((int refnum));
d193 2
a194 4
static const char vptr_name[] =
{'_', 'v', 'p', 't', 'r', CPLUS_MARKER, '\0'};
static const char vb_name[] =
{'_', 'v', 'b', CPLUS_MARKER, '\0'};
d209 1
a209 1
{"invalid C++ abbreviation `%s'", 0, 0};
d212 1
a212 1
{"C++ abbreviated type name unknown at symtab pos %d", 0, 0};
d215 1
a215 1
{"member function type missing, got '%c'", 0, 0};
d218 1
a218 1
{"const/volatile indicator missing, got '%c'", 0, 0};
d221 1
a221 1
{"debug info mismatch between compiler and debugger", 0, 0};
d224 1
a224 1
{"invalid (minimal) member type data format at symtab pos %d.", 0, 0};
d227 1
a227 1
{"base type %d of range type is not defined", 0, 0};
d230 1
a230 1
{"register number %d too large (max %d) in symbol %s", 0, 0};
d233 1
a233 1
{"virtual function table pointer not found when defining class `%s'", 0, 0};
d236 1
a236 1
{"Unknown C++ symbol name `%s'", 0, 0};
d239 1
a239 1
{"Unknown builtin type %d", 0, 0};
d242 1
a242 1
{"%s: common block `%s' from global_sym_chain unresolved", 0, 0};
d245 1
a245 1
{"%s", 0, 0};
d248 1
a248 1
{"%s", 0, 0};
d266 14
a279 15
static struct type **os9k_type_vector[] =
{
  0,
  &builtin_type_int,
  &builtin_type_char,
  &builtin_type_long,
  &builtin_type_short,
  &builtin_type_unsigned_char,
  &builtin_type_unsigned_short,
  &builtin_type_unsigned_long,
  &builtin_type_unsigned_int,
  &builtin_type_float,
  &builtin_type_double,
  &builtin_type_void,
  &builtin_type_long_double
d285 2
a286 2
os9k_init_type_vector (tv)
     struct type **tv;
d289 1
a289 1
  for (i = 0; i < sizeof (os9k_type_vector) / sizeof (struct type **); i++)
d316 1
a316 2
      static struct complaint msg =
      {"\
d318 1
a318 1
       0, 0};
d334 1
a334 1
	  temp_type = rs6000_builtin_type (index);
d339 1
a339 1
         Find it in this object file's type vector.  */
d448 1
a448 1

d450 2
a451 2
         patch their types! */

d455 1
a455 1
	  pp = (char *) strchr (name, ':');
d458 2
a459 2
	      pp += 2;
	      pp = (char *) strchr (pp, ':');
d461 1
a461 1
	  sym = find_symbol_in_list (symbols, name, pp - name);
d465 6
a470 6
	         the variable was defined *anywhere*, not just whether
	         it is defined in this compilation unit.  But neither
	         xlc or GCC seem to need such a definition, and until
	         we do psymtabs (so that the minimal symbols from all
	         compilation units are available now), I'm not sure
	         how to get the information.  */
d473 2
a474 2
	         ld will remove it from the executable.  There is then
	         a N_GSYM stab for it, but no regular (C_EXT) symbol.  */
d485 1
a485 1
	      if (*(pp - 1) == 'F' || *(pp - 1) == 'f')
d502 1
a502 1
	      if (*(pp - 1) == 'F' || *(pp - 1) == 'f')
d515 1
a516 1

d535 1
a535 2
      if (nbits != 0)
	return -1;
d537 1
a537 2
      if (nbits != 0)
	return -1;
d543 1
a543 2
      if (nbits != 0)
	return -1;
d547 1
a548 1

d566 1
a566 1
static char *
d568 2
a569 2
     char **p;
     int c;
d574 1
a574 1
  if (*p)
d579 1
a579 1
  else
d589 1
a589 1
static char *
d591 1
a591 1
     char *fname;
d596 1
a596 1
  char *p = fname;
d599 3
a601 3
  if (*p == '_' && *(p + 1) == '_')	/* compiler generated; probably a ctor/dtor */
    p += 2;
  while (p && (unsigned) ((p + 1) - fname) < strlen (fname) && *(p + 1) != '_')
d603 3
a605 3
  if (!(p && *p == '_' && *(p + 1) == '_'))
    error ("Invalid mangled function name %s", fname);
  p += 2;			/* advance past '__' */
d620 1
a620 1
   ^^^^^^^^^^^^^^^^^^
d622 3
a624 3
   A:ZcA;;foopri__1AFv foopro__1AFv __ct__1AFv __ct__1AFRC1A foopub__1AFv ;;;
   ^
 */
d627 5
a631 5
read_cfront_baseclasses (fip, pp, type, objfile)
     struct field_info *fip;
     struct objfile *objfile;
     char **pp;
     struct type *type;
d633 1
a633 2
  static struct complaint msg_unknown =
  {"\
d635 2
a636 3
   0, 0};
  static struct complaint msg_notfound =
  {"\
d638 1
a638 1
   0, 0};
d640 1
a640 1
  char *p;
d656 1
a656 1
  bnum++;			/* add one more for last one */
d661 1
a661 1
  TYPE_N_BASECLASSES (type) = bnum;
d678 3
a680 3
      new->next = fip->list;
      fip->list = new;
      FIELD_BITSIZE (new->field) = 0;	/* this should be an unpacked field! */
d685 4
a688 4
      if (**pp == 'v')
	{
	  SET_TYPE_FIELD_VIRTUAL (type, i);
	  ++(*pp);
d692 1
a692 1
      /* Note: protected inheritance not supported in cfront */
d694 17
a710 18
	{
	case CFRONT_VISIBILITY_PRIVATE:
	  new->visibility = VISIBILITY_PRIVATE;
	  break;
	case CFRONT_VISIBILITY_PUBLIC:
	  new->visibility = VISIBILITY_PUBLIC;
	  break;
	default:
	  /* Bad visibility format.  Complain and treat it as
	     public.  */
	  {
	    static struct complaint msg =
	    {
	      "Unknown visibility `%c' for baseclass", 0, 0};
	    complain (&msg, new->visibility);
	    new->visibility = VISIBILITY_PUBLIC;
	  }
	}
d713 4
a716 4
      if (**pp != '@@')
	{
	  complain (&msg_unknown, *pp);
	  return 1;
d721 8
a728 8
      /* Set the bit offset of the portion of the object corresponding 
         to this baseclass.  Always zero in the absence of
         multiple inheritance.  */
      /* Unable to read bit position from stabs;
         Assuming no multiple inheritance for now FIXME! */
      /* We may have read this in the structure definition;
         now we should fixup the members to be the actual base classes */
      FIELD_BITPOS (new->field) = 0;
d730 1
a730 12
      /* Get the base class name and type */
      {
	char *bname;		/* base class name */
	struct symbol *bsym;	/* base class */
	char *p1, *p2;
	p1 = strchr (*pp, ' ');
	p2 = strchr (*pp, ';');
	if (p1 < p2)
	  bname = get_substring (pp, ' ');
	else
	  bname = get_substring (pp, ';');
	if (!bname || !*bname)
d732 26
a757 14
	    complain (&msg_unknown, *pp);
	    return 1;
	  }
	/* FIXME! attach base info to type */
	bsym = lookup_symbol (bname, 0, STRUCT_NAMESPACE, 0, 0);	/*demangled_name */
	if (bsym)
	  {
	    new->field.type = SYMBOL_TYPE (bsym);
	    new->field.name = type_name_no_tag (new->field.type);
	  }
	else
	  {
	    complain (&msg_notfound, *pp);
	    return 1;
a758 1
      }
d771 4
a774 4
   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 
   A:ZcA;;foopri__1AFv foopro__1AFv __ct__1AFv __ct__1AFRC1A foopub__1AFv ;;;
   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 
 */
d797 1
a797 2
    }
   *sublist;
d802 3
a804 3
  char *fname;
  struct symbol *ref_func = 0;

d808 1
a808 1
  STABS_CONTINUE (pp, objfile);	/* handle \\ */
d810 1
a810 1
  while (**pp != ';' && (fname = get_substring (pp, ' '), fname))
d814 11
a824 12
      char *pname;
      if (fname[0] == '*')	/* static member */
	{
	  is_static = 1;
	  sublist_count++;
	  fname++;
	}
      ref_func = lookup_symbol (fname, 0, VAR_NAMESPACE, 0, 0);		/* demangled name */
      if (!ref_func)
	{
	  static struct complaint msg =
	  {"\
d826 1
a826 1
	   0, 0};
d833 1
a833 1

d835 1
a835 1
	xmalloc (sizeof (struct next_fnfieldlist));
d838 1
a838 1

d843 8
a850 8
	char *dem, *dem_p, *dem_args;
	int dem_len;
	dem = cplus_demangle (fname, DMGL_ANSI | DMGL_PARAMS);
	if (dem != NULL)
	  {
	    dem_p = strrchr (dem, ':');
	    if (dem_p != 0 && *(dem_p - 1) == ':')
	      dem_p++;
d852 1
a852 1
	    dem_args = strchr (dem_p, '(');
d856 31
a886 10
	      dem_len = dem_args - dem_p;
	    main_fn_name =
	      obsavestring (dem_p, dem_len, &objfile->type_obstack);
	  }
	else
	  {
	    main_fn_name =
	      obsavestring (fname, strlen (fname), &objfile->type_obstack);
	  }
      }				/* end of code for cfront work around */
d888 7
a894 9
      new_fnlist->fn_fieldlist.name = main_fn_name;

/*-------------------------------------------------*/
      /* Set up the sublists
         Sublists are stuff like args, static, visibility, etc.
         so in ARM, we have to set that info some other way.
         Multiple sublists happen if overloading
         eg: foo::26=##1;:;2A.;
         In g++, we'd loop here thru all the sublists...  */
d896 5
a900 4
      new_sublist =
	(struct next_fnfield *) xmalloc (sizeof (struct next_fnfield));
      make_cleanup (free, new_sublist);
      memset (new_sublist, 0, sizeof (struct next_fnfield));
d902 2
a903 22
      /* eat 1; from :;2A.; */
      new_sublist->fn_field.type = SYMBOL_TYPE (ref_func);	/* normally takes a read_type */
      /* Make this type look like a method stub for gdb */
      TYPE_FLAGS (new_sublist->fn_field.type) |= TYPE_FLAG_STUB;
      TYPE_CODE (new_sublist->fn_field.type) = TYPE_CODE_METHOD;

      /* If this is just a stub, then we don't have the real name here. */
      if (TYPE_FLAGS (new_sublist->fn_field.type) & TYPE_FLAG_STUB)
	{
	  if (!TYPE_DOMAIN_TYPE (new_sublist->fn_field.type))
	    TYPE_DOMAIN_TYPE (new_sublist->fn_field.type) = type;
	  new_sublist->fn_field.is_stub = 1;
	}

      /* physname used later in mangling; eg PFs_i,5 for foo__1aFPFs_i 
         physname gets strcat'd in order to recreate the onto mangled name */
      pname = get_cfront_method_physname (fname);
      new_sublist->fn_field.physname = savestring (pname, strlen (pname));


      /* Set this member function's visibility fields. 
         Unable to distinguish access from stabs definition!
d905 49
a953 49
         (for private, set new_sublist->fn_field.is_private = 1,
         for public, set new_sublist->fn_field.is_protected = 1) */

      /* Unable to distinguish const/volatile from stabs definition!
         Assuming normal for now.  FIXME! */

      new_sublist->fn_field.is_const = 0;
      new_sublist->fn_field.is_volatile = 0;	/* volatile not implemented in cfront */

      /* Set virtual/static function info
         How to get vtable offsets ? 
         Assuming normal for now FIXME!! 
         For vtables, figure out from whence this virtual function came.
         It may belong to virtual function table of
         one of its baseclasses.
         set:
         new_sublist -> fn_field.voffset = vtable offset,
         new_sublist -> fn_field.fcontext = look_ahead_type;
         where look_ahead_type is type of baseclass */
      if (is_static)
	new_sublist->fn_field.voffset = VOFFSET_STATIC;
      else			/* normal member function.  */
	new_sublist->fn_field.voffset = 0;
      new_sublist->fn_field.fcontext = 0;


      /* Prepare new sublist */
      new_sublist->next = sublist;
      sublist = new_sublist;
      length++;

      /* In g++, we loop thu sublists - now we set from functions. */
      new_fnlist->fn_fieldlist.fn_fields = (struct fn_field *)
	obstack_alloc (&objfile->type_obstack,
		       sizeof (struct fn_field) * length);
      memset (new_fnlist->fn_fieldlist.fn_fields, 0,
	      sizeof (struct fn_field) * length);
      for (i = length; (i--, sublist); sublist = sublist->next)
	{
	  new_fnlist->fn_fieldlist.fn_fields[i] = sublist->fn_field;
	}

      new_fnlist->fn_fieldlist.length = length;
      new_fnlist->next = fip->fnlist;
      fip->fnlist = new_fnlist;
      nfn_fields++;
      total_length += length;
      STABS_CONTINUE (pp, objfile);	/* handle \\ */
    }				/* end of loop */
d959 1
a959 1
	TYPE_ALLOC (type, sizeof (struct fn_fieldlist) * nfn_fields);
d961 1
a961 1
	      sizeof (struct fn_fieldlist) * nfn_fields);
d984 3
a986 3
     struct objfile *objfile;
     struct symbol *sym;
     char *p;
d988 2
a989 2
  struct symbol *ref_sym = 0;
  char *sname;
d998 1
a998 1
  fi.fnlist = NULL;
d1006 5
a1010 5
  if (*p != 's'			/* structs */
      && *p != 'c'		/* class */
      && *p != 'u')		/* union */
    return 0;			/* only handle C++ types */
  p++;
d1015 1
a1015 1
  if (!sname || strcmp (sname, SYMBOL_NAME (sym)))
d1021 2
a1022 2
  ref_sym = lookup_symbol (SYMBOL_NAME (sym), 0, STRUCT_NAMESPACE, 0, 0);
  type = SYMBOL_TYPE (ref_sym);
d1031 2
a1032 2
  /* g++ does this next, but cfront already did this: 
     || !read_struct_fields (&fi, &p, type, objfile) */
d1038 3
a1040 3
  /* g++ does this next, but cfront doesn't seem to have this: 
     || !read_tilde_fields (&fi, &p, type, objfile) */
    )
d1046 1
a1046 1
  return 0;
d1056 3
a1058 3
     struct objfile *objfile;
     struct symbol *sym;
     char *p;
d1061 1
a1061 1
  struct symbol *ref_sym = 0;
d1066 1
a1066 1
    return 0;
d1073 1
a1073 1
/*---------------------------------------------------------*/
d1076 2
a1077 2
     eg: id=2 for p : "2=", "2=z:r(0,1)" "2:r(0,1);l(#5,#6),l(#7,#4)" */
/*---------------------------------------------------------*/
d1099 3
a1101 3
     RSYM   0      5      00000000 868    #15=z:r(0,1)
     LBRAC  0      0      00000000 899    #5=
     SLINE  0      16     00000003 923    #6=
d1103 1
a1103 1
     RSYM   0      5      00000000 927    #15:r(0,1);l(#5,#6)
d1106 1
a1106 1
     class for a symbol (#15=z) which was previously defined.
d1108 11
a1118 11
     (#15) are the values of the beginning (#5) and ending (#6) 
     symbols. */

  /* Read number as reference id.
     eg: p : "=", "=z:r(0,1)" ":r(0,1);l(#5,#6),l(#7,#4)" */
  /* FIXME! Might I want to use SYMBOL_CLASS (sym) = LOC_OPTIMIZED_OUT;
     in case of "l(0,0)"? */

/*--------------------------------------------------*/
  /* Add this symbol to the reference list.           */
/*--------------------------------------------------*/
d1147 5
a1151 5
  /* Want to fix up name so that other functions (eg. valops)
     will correctly print the name.
     Don't add_symbol_to_list so that lookup_symbol won't find it.
     nope... needed for fixups. */
  SYMBOL_NAME (sym) = SYMBOL_NAME (ref_sym);
d1171 1
a1171 1
static struct ref_map *ref_map;
d1174 1
a1174 1
static int ref_count = 0;
d1196 1
a1196 1
      int new_slots = ref_count - ref_chunk * MAX_CHUNK_REFS;
d1228 1
a1228 1

d1232 1
a1232 1
static int
d1234 1
a1234 1
     char **string;
d1239 3
a1241 3
  if (**string != '#')
    return 0;

d1268 1
a1268 1
  if (*p == '=')
d1270 1
a1270 1
      /* Symbol is being defined here. */
d1315 2
a1316 2
      p += 2;
      p = strchr (p, ':');
d1323 2
a1324 2
  current_symbol = sym = (struct symbol *)
    obstack_alloc (&objfile->symbol_obstack, sizeof (struct symbol));
d1330 1
a1330 1
      SYMBOL_SECTION (sym) = SECT_OFF_TEXT;
d1333 1
a1333 1
      SYMBOL_SECTION (sym) = SECT_OFF_DATA;
d1336 1
a1336 1
      SYMBOL_SECTION (sym) = SECT_OFF_BSS;
d1343 2
a1344 2
         number of bytes occupied by a type or object, which we ignore.  */
      SYMBOL_LINE (sym) = desc;
d1348 1
a1348 1
      SYMBOL_LINE (sym) = 0;	/* unknown */
d1356 4
a1359 4
	case 't':
	  SYMBOL_NAME (sym) = obsavestring ("this", strlen ("this"),
					    &objfile->symbol_obstack);
	  break;
d1361 8
a1368 8
	case 'v':		/* $vtbl_ptr_type */
	  /* Was: SYMBOL_NAME (sym) = "vptr"; */
	  goto normal;

	case 'e':
	  SYMBOL_NAME (sym) = obsavestring ("eh_throw", strlen ("eh_throw"),
					    &objfile->symbol_obstack);
	  break;
d1370 3
a1372 3
	case '_':
	  /* This was an anonymous type that was never fixed up.  */
	  goto normal;
d1375 3
a1377 3
	case 'X':
	  /* SunPRO (3.0 at least) static variable encoding.  */
	  goto normal;
d1380 3
a1382 3
	default:
	  complain (&unrecognized_cplus_name_complaint, string);
	  goto normal;		/* Do *something* with it */
d1392 3
a1394 3
         reference map.  Else it must be referring to a previously
         defined symbol, so add it to the alias list of the previously
         defined symbol.  */
d1398 4
a1401 3
	ref_add (refnum, sym, string, SYMBOL_VALUE (sym));
      else if (!resolve_symbol_reference (objfile, sym, string))
	return NULL;
d1404 1
a1404 1
         the correct name into SYMBOL_NAME.  */
d1411 1
a1411 1
		obstack_alloc (&objfile->symbol_obstack, nlen);
d1421 2
a1422 2
	      SYMBOL_NAME (sym) = (char *)
		obstack_alloc (&objfile->symbol_obstack, nlen);
d1434 3
a1436 3
      SYMBOL_LANGUAGE (sym) = current_subfile->language;
      SYMBOL_NAME (sym) = (char *)
	obstack_alloc (&objfile->symbol_obstack, ((p - string) + 1));
d1439 1
a1439 1
         try it on an executable with a large symbol table. */
d1441 1
a1441 1
         doubt it.  xoxorich. */
d1453 3
a1455 3
         demangled form for future reference.  This is a typical time versus
         space tradeoff, that was decided in favor of time because it sped up
         C++ symbol lookups by a factor of about 20. */
d1482 5
a1486 5
         SYMBOL:c=iVALUE for an integer constant symbol.
         SYMBOL:c=rVALUE for a floating constant symbol.
         SYMBOL:c=eTYPE,INTVALUE for an enum constant symbol.
         e.g. "b:c=e6,0" for "const b = blob1"
         (where type 6 is defined by "blobs:t6=eblob1:0,blob2:1,;").  */
d1517 1
a1517 1
	      obstack_alloc (&objfile->symbol_obstack,
d1547 1
a1547 1
			     (struct objfile *) NULL);
d1607 2
a1608 2
         We need to convert this to the function-returning-type-X type
         in GDB.  E.g. "int" is converted to "function returning int".  */
d1643 1
a1643 1
	         FIXME: GDB currently ignores vararg functions.  */
d1649 5
a1653 5
	         be promoted to the width of the calling conventions, with
	         a type which references itself. This type is turned into
	         a TYPE_CODE_VOID type by read_type, and we have to turn
	         it back into builtin_type_int here.
	         FIXME: Do we need a new builtin_type_promoted_int_arg ?  */
d1673 3
a1675 3
         value is not correct.  It is necessary to search for the
         corresponding linker definition to find the value.
         These definitions appear at the end of the namelist.  */
d1680 3
a1682 3
         Symbol references don't have valid names and wont't match up with
         minimal symbols when the global_sym_chain is relocated.
         We'll fixup symbol references when we fixup the defining symbol.  */
d1685 3
a1687 3
	  i = hashname (SYMBOL_NAME (sym));
	  SYMBOL_VALUE_CHAIN (sym) = global_sym_chain[i];
	  global_sym_chain[i] = sym;
d1693 2
a1694 2
         when there is no code letter in the dbx data.
         Dbx data never actually contains 'l'.  */
d1713 1
a1713 1
	    (lookup_function_type (read_type (&p, objfile)));
d1719 1
a1719 1
         can also be a LOC_LOCAL_ARG depending on symbol type.  */
d1746 1
a1746 1

d1752 1
a1752 1

d1757 1
a1757 1

d1761 29
a1789 29
	         should believe the type of a PCC 'short' argument,
	         but shouldn't believe the address (the address is the
	         address of the corresponding int).

	         My guess is that this correction, as opposed to
	         changing the parameter to an 'int' (as done below,
	         for PCC on most machines), is the right thing to do
	         on all machines, but I don't want to risk breaking
	         something that already works.  On most PCC machines,
	         the sparc problem doesn't come up because the calling
	         function has to zero the top bytes (not knowing
	         whether the called function wants an int or a short),
	         so there is little practical difference between an
	         int and a short (except perhaps what happens when the
	         GDB user types "print short_arg = 0x10000;").

	         Hacked for SunOS 4.1 by gnu@@cygnus.com.  In 4.1, the
	         compiler actually produces the correct address (we
	         don't need to fix it up).  I made this code adapt so
	         that it will offset the symbol if it was pointing at
	         an int-aligned location and not otherwise.  This way
	         you can use the same gdb for 4.0.x and 4.1 systems.

	         If the parameter is shorter than an int, and is
	         integral (e.g. char, short, or unsigned equivalent),
	         and is claimed to be passed on an integer boundary,
	         don't believe it!  Offset the parameter's address to
	         the tail-end of that integer.  */

d1792 1
a1792 1
	      && 0 == SYMBOL_VALUE (sym) % TYPE_LENGTH (pcc_promotion_type))
d1802 1
a1802 1
	         it is really an int.  */
d1824 1
a1824 1
      /*FALLTHROUGH */
d1835 1
a1835 1
	  SYMBOL_VALUE (sym) = SP_REGNUM;	/* Known safe, though useless */
d1850 1
a1850 1
	  SYMBOL_VALUE (sym) = SP_REGNUM;	/* Known safe, though useless */
d1868 1
a1868 1
	     main(argc) struct foo argc; { register struct foo argc; }
d1882 1
a1882 1
	    )
d1888 1
a1888 1
		  && STREQ (SYMBOL_NAME (prev_sym), SYMBOL_NAME (sym)))
d1899 1
a1899 1
	  add_symbol_to_list (sym, &local_symbols);
d1902 1
a1902 1
	add_symbol_to_list (sym, &file_symbols);
d1912 9
a1920 9
	{
	  struct minimal_symbol *msym;
	  msym = lookup_minimal_symbol (SYMBOL_NAME (sym), NULL, objfile);
	  if (msym != NULL)
	    {
	      SYMBOL_NAME (sym) = STATIC_TRANSFORM_NAME (SYMBOL_NAME (sym));
	      SYMBOL_VALUE_ADDRESS (sym) = SYMBOL_VALUE_ADDRESS (msym);
	    }
	}
d1930 2
a1931 3
         did not use `sym'. Return without further processing. */
      if (nameless)
	return NULL;
d1937 3
a1939 3
         a base type which did not have its name defined when the
         derived class was output.  We fill in the derived class's
         base part member's name here in that case.  */
d1964 12
a1975 12
	         foo" or "function returning foo", we better not set
	         the TYPE_NAME.  If the program contains "typedef char
	         *caddr_t;", we don't want all variables of type char
	         * to print as caddr_t.  This is not just a
	         consequence of GDB's type management; PCC and GCC (at
	         least through version 2.4) both output variables of
	         either type char * or caddr_t with the type number
	         defined in the 't' symbol for caddr_t.  If a future
	         compiler cleans this up it GDB is not ready for it
	         yet, but if it becomes ready we somehow need to
	         disable this check (without breaking the PCC/GCC2.4
	         case).
d1977 1
a1977 1
	         Sigh.
d1979 2
a1980 2
	         Fortunately, this check seems not to be necessary
	         for anything except pointers or functions.  */
d1991 1
a1991 1
         by 't' which means we are typedef'ing it as well.  */
d1997 3
a1999 3
         a typedef for "foo".  Unfortunately, cfront never makes the typedef
         when translating C++ into C.  We make the typedef here so that
         "ptype foo" works as expected for cfront translated code.  */
d2006 2
a2007 3
         did not use `sym'. Return without further processing. */
      if (nameless)
	return NULL;
d2014 1
a2014 1
	  = obconcat (&objfile->type_obstack, "", "", SYMBOL_NAME (sym));
d2021 1
a2021 1
	  obstack_alloc (&objfile->symbol_obstack, sizeof (struct symbol));
d2028 1
a2028 1
	      = obconcat (&objfile->type_obstack, "", "", SYMBOL_NAME (sym));
d2040 9
a2048 9
	{
	  struct minimal_symbol *msym;
	  msym = lookup_minimal_symbol (SYMBOL_NAME (sym), NULL, objfile);
	  if (msym != NULL)
	    {
	      SYMBOL_NAME (sym) = STATIC_TRANSFORM_NAME (SYMBOL_NAME (sym));
	      SYMBOL_VALUE_ADDRESS (sym) = SYMBOL_VALUE_ADDRESS (msym);
	    }
	}
d2075 1
a2075 1
	  SYMBOL_VALUE (sym) = SP_REGNUM;	/* Known safe, though useless */
d2083 3
a2085 3
         Sun claims ("dbx and dbxtool interfaces", 2nd ed)
         that Pascal uses it too, but when I tried it Pascal used
         "x:3" (local symbol) instead.  */
d2093 2
a2094 2
      /* New code added to support cfront stabs strings.
         Note: case 'P' already handled above */
d2097 11
a2107 11
         Find the original definition and add to it.
         We'll have to do this for the typedef too,
         since we cloned the symbol to define a type in read_type.
         Stabs info examples:
         __1C :Ztl 
         foo__1CFv :ZtF (first def foo__1CFv:F(0,3);(0,24))
         C:ZsC;;__ct__1CFv func1__1CFv func2__1CFv ... ;;;
         where C is the name of the class.
         Unfortunately, we can't lookup the original symbol yet 'cuz 
         we haven't finished reading all the symbols.
         Instead, we save it for processing later */
d2109 3
a2111 3
      SYMBOL_TYPE (sym) = error_type (&p, objfile);	/* FIXME! change later */
      SYMBOL_CLASS (sym) = LOC_CONST;
      SYMBOL_VALUE (sym) = 0;
d2131 1
a2131 1
    && (SYMBOL_CLASS (sym) == LOC_REGPARM || SYMBOL_CLASS (sym) == LOC_ARG))
d2156 3
a2158 3
	{
	  /* GNU extensions for live range splitting may be appended to 
	     the end of the stab string.  eg. "l(#1,#2);l(#3,#5)" */
d2166 1
a2166 1
	  if (!*p || *p != ')')
d2171 2
a2172 2
	  p++;
	}
d2203 1
a2203 1

d2267 1
a2267 1
    obstack_alloc (&objfile->type_obstack,
d2284 1
a2285 1

d2293 1
a2293 1
   return error_type (pp, objfile);
d2301 1
a2301 1
   return error_type (pp, objfile);
d2307 1
a2307 1
   foo = error_type (pp, objfile);
d2309 1
a2309 1
   ++*pp;
d2341 1
a2342 1

d2375 1
a2375 1

d2377 2
a2378 2
         or this is a forward reference to it.  dbx_alloc_type handles
         both cases.  */
d2384 2
a2385 2
         Also skip the type descriptor - we get it below with (*pp)[-1].  */
      (*pp) += 2;
d2390 1
a2390 1
         the definition, but don't put it in the type vector.  */
d2395 1
a2395 1
again:
d2406 1
a2406 1

d2409 1
a2409 1

d2412 1
a2412 1

d2430 1
a2430 1
		{"Unrecognized cross-reference type `%c'", 0, 0};
d2436 1
a2436 1

d2457 3
a2459 3
	  to = type_name =
	    (char *) obstack_alloc (&objfile->type_obstack, p - *pp + 1);

d2462 1
a2462 1
	  while (from < p)
d2465 1
a2465 1

d2487 1
a2487 1
		  obstack_free (&objfile->type_obstack, type_name);
d2501 1
a2501 1
	INIT_CPLUS_SPECIFIC (type);
d2508 1
a2508 1
    case '-':			/* RS/6000 built-in type */
d2523 1
a2523 1
         the Lucid compiler and recent gcc versions (post 2.7.3) use. */
d2526 1
a2526 1
         This handles recursive types. */
d2529 1
a2529 2
      {
	struct type *xtype = read_type (pp, objfile);
d2550 6
a2555 6
      /* In the following types, we must be sure to overwrite any existing
         type that the typenums refer to, rather than allocating a new one
         and making the typenums point to the new one.  This is because there
         may already be pointers to the existing type (if it had been
         forward-referenced), and we must change it to a pointer, function,
         reference, or whatever, *in-place*.  */
d2562 1
a2562 1
    case '&':			/* Reference to another type */
d2567 1
a2567 1
    case 'f':			/* Function returning another type */
d2577 4
a2580 5
	    {
	      t = read_type (pp, objfile);
	      if (**pp == ',')
		++ * pp;
	    }
d2586 2
a2587 2
    case 'k':			/* Const qualifier on some type (Sun) */
    case 'c':			/* Const qualifier on some type (OS9000) */
d2589 1
a2589 1
         only accept 'c' in the os9k_stabs case.  */
d2596 2
a2597 2
    case 'B':			/* Volatile qual on some type (Sun) */
    case 'i':			/* Volatile qual on some type (OS9000) */
d2599 1
a2599 1
         only accept 'i' in the os9k_stabs case.  */
d2607 2
a2608 2
      if (isdigit (**pp) || **pp == '(' || **pp == '-')
	{			/* Member (class & variable) type */
d2623 1
a2623 2
      else
	/* type attribute */
d2632 1
a2632 1
	    ++ * pp;		/* Skip the semicolon.  */
d2648 1
a2648 1
	         can invent new ones.  */
d2656 1
a2656 1
    case '#':			/* Method (class & fn) type */
d2689 1
a2689 1
    case 'r':			/* Range type */
d2708 1
a2708 1
    case 'R':			/* Sun ACC builtin float type */
d2713 2
a2714 2

    case 'e':			/* Enumeration type */
d2721 2
a2722 2
    case 's':			/* Struct type */
    case 'u':			/* Union type */
d2726 6
a2731 6
	case 's':
	  TYPE_CODE (type) = TYPE_CODE_STRUCT;
	  break;
	case 'u':
	  TYPE_CODE (type) = TYPE_CODE_UNION;
	  break;
d2736 1
a2736 1
    case 'a':			/* Array type */
d2740 1
a2740 1

d2749 1
a2749 1
      type = create_set_type ((struct type *) NULL, type1);
d2758 1
a2758 1
      /* Particularly important if it was \0! */
d2797 1
a2797 1
#error This code wrong for TARGET_CHAR_BIT not 8
d2808 4
a2811 4
         by the debugging format.  If there is a type called "int" which
         is other than 32 bits, then it should use a new negative type
         number (or avoid negative type numbers for that case).
         See stabs.texinfo.  */
d2858 2
a2859 2
         different sizes for "long double" should use different negative
         type numbers.  See stabs.texinfo.  */
d2942 1
a2942 1
   NAME :: TYPENUM[=type definition] ARGS : PHYSNAME ;
d2946 1
a2946 1
   afunc1::20=##15;:i;2A.;afunc2::20:i;2A.;
d2972 1
a2972 2
    }
   *sublist;
d2978 1
a2978 1

d2985 2
a2986 2
         Scan forward to find the first ':' and if it is not the
         first of a "::" delimiter, then this is not a member function. */
d3000 1
a3000 1

d3005 1
a3005 1

d3017 1
a3017 2
	  static char opname[32] =
	  {'o', 'p', CPLUS_MARKER};
d3019 1
a3019 1

d3039 2
a3040 2
      new_fnlist->fn_fieldlist.name = main_fn_name;

d3047 1
a3047 1

d3053 2
a3054 2

	      new_sublist->fn_field.type = read_type (pp, objfile);
d3064 1
a3064 1
	      new_sublist->fn_field.type = look_ahead_type;
d3067 1
a3067 1

d3074 1
a3074 1

d3077 1
a3077 1
	  if (TYPE_FLAGS (new_sublist->fn_field.type) & TYPE_FLAG_STUB)
d3079 3
a3081 3
	      if (!TYPE_DOMAIN_TYPE (new_sublist->fn_field.type))
		TYPE_DOMAIN_TYPE (new_sublist->fn_field.type) = type;
	      new_sublist->fn_field.is_stub = 1;
d3083 1
a3083 1
	  new_sublist->fn_field.physname = savestring (*pp, p - *pp);
d3085 1
a3085 1

d3089 6
a3094 6
	    case VISIBILITY_PRIVATE:
	      new_sublist->fn_field.is_private = 1;
	      break;
	    case VISIBILITY_PROTECTED:
	      new_sublist->fn_field.is_protected = 1;
	      break;
d3096 1
a3096 1

d3100 27
a3126 27
	    case 'A':		/* Normal functions. */
	      new_sublist->fn_field.is_const = 0;
	      new_sublist->fn_field.is_volatile = 0;
	      (*pp)++;
	      break;
	    case 'B':		/* `const' member functions. */
	      new_sublist->fn_field.is_const = 1;
	      new_sublist->fn_field.is_volatile = 0;
	      (*pp)++;
	      break;
	    case 'C':		/* `volatile' member function. */
	      new_sublist->fn_field.is_const = 0;
	      new_sublist->fn_field.is_volatile = 1;
	      (*pp)++;
	      break;
	    case 'D':		/* `const volatile' member function. */
	      new_sublist->fn_field.is_const = 1;
	      new_sublist->fn_field.is_volatile = 1;
	      (*pp)++;
	      break;
	    case '*':		/* File compiled with g++ version 1 -- no info */
	    case '?':
	    case '.':
	      break;
	    default:
	      complain (&const_vol_complaint, **pp);
	      break;
d3128 1
a3128 1

d3131 1
a3131 1
	    case '*':
d3134 1
a3134 1
		/* virtual member function, followed by index.
d3141 1
a3141 1
		new_sublist->fn_field.voffset =
d3145 1
a3145 1

d3150 1
a3150 1
		    new_sublist->fn_field.fcontext = 0;
d3164 1
a3164 1
			new_sublist->fn_field.fcontext = look_ahead_type;
d3178 20
a3197 20
	    case '?':
	      /* static member function.  */
	      new_sublist->fn_field.voffset = VOFFSET_STATIC;
	      if (strncmp (new_sublist->fn_field.physname,
			   main_fn_name, strlen (main_fn_name)))
		{
		  new_sublist->fn_field.is_stub = 1;
		}
	      break;

	    default:
	      /* error */
	      complain (&member_fn_complaint, (*pp)[-1]);
	      /* Fall through into normal member function.  */

	    case '.':
	      /* normal member function.  */
	      new_sublist->fn_field.voffset = 0;
	      new_sublist->fn_field.fcontext = 0;
	      break;
d3199 2
a3200 2

	  new_sublist->next = sublist;
d3206 1
a3206 1

d3208 3
a3210 3

      new_fnlist->fn_fieldlist.fn_fields = (struct fn_field *)
	obstack_alloc (&objfile->type_obstack,
d3212 1
a3212 1
      memset (new_fnlist->fn_fieldlist.fn_fields, 0,
d3214 1
a3214 1
      for (i = length; (i--, sublist); sublist = sublist->next)
d3216 1
a3216 1
	  new_fnlist->fn_fieldlist.fn_fields[i] = sublist->fn_field;
d3218 4
a3221 4

      new_fnlist->fn_fieldlist.length = length;
      new_fnlist->next = fip->fnlist;
      fip->fnlist = new_fnlist;
d3267 3
a3269 3
         where the type number before the ':' is the "context" and
         everything after is a regular type definition.  Lookup the
         type, find it's name, and construct the field name. */
d3275 4
a3278 4
	case 'f':		/* $vf -- a virtual function table pointer */
	  fip->list->field.name =
	    obconcat (&objfile->type_obstack, vptr_name, "", "");
	  break;
d3280 10
a3289 10
	case 'b':		/* $vb -- a virtual bsomethingorother */
	  name = type_name_no_tag (context);
	  if (name == NULL)
	    {
	      complain (&invalid_cpp_type_complaint, symnum);
	      name = "FOO";
	    }
	  fip->list->field.name =
	    obconcat (&objfile->type_obstack, vb_name, name, "");
	  break;
d3291 6
a3296 6
	default:
	  complain (&invalid_cpp_abbrev_complaint, *pp);
	  fip->list->field.name =
	    obconcat (&objfile->type_obstack,
		      "INVALID_CPLUSPLUS_ABBREV", "", "");
	  break;
d3300 1
a3300 1
         field type. */
d3310 1
a3310 1
	(*pp)++;		/* Skip the comma.  */
d3328 2
a3329 2
         better return 0.  If we returned 1, we would need to at least advance
         *pp to avoid an infinite loop.  */
d3346 1
a3346 1
   */
d3355 7
a3361 7
	{
	  dem_p = strrchr (dem, ':');
	  if (dem_p != 0 && *(dem_p - 1) == ':')
	    dem_p++;
	  FIELD_NAME (fip->list->field) =
	    obsavestring (dem_p, strlen (dem_p), &objfile->type_obstack);
	}
d3363 4
a3366 4
	{
	  FIELD_NAME (fip->list->field) =
	    obsavestring (*pp, p - *pp, &objfile->type_obstack);
	}
d3372 2
a3373 2
    fip->list->field.name =
      obsavestring (*pp, p - *pp, &objfile->type_obstack);
d3380 1
a3380 1
      fip->list->visibility = *(*pp)++;
d3385 1
a3385 1
      fip->list->visibility = VISIBILITY_PUBLIC;
d3388 1
a3388 1
  fip->list->field.type = read_type (pp, objfile);
d3396 1
a3396 1
	  fip->list->field.bitpos = (long) -2;	/* nested type */
d3399 1
a3399 2
      else
	...;
d3401 1
a3401 1
      while (*p != ';')
d3439 12
a3450 12
         it is a field which has been optimized out.  The correct stab for
         this case is to use VISIBILITY_IGNORE, but that is a recent
         invention.  (2) It is a 0-size array.  For example
         union { int num; char str[0]; } foo.  Printing "<no value>" for
         str in "p foo" is OK, since foo.str (and thus foo.str[3])
         will continue to work, and a 0-size array as a whole doesn't
         have any contents to print.

         I suspect this probably could also happen with gcc -gstabs (not
         -gstabs+) for static fields, and perhaps other C++ extensions.
         Hopefully few people use -gstabs with gdb, since it is intended
         for dbx compatibility.  */
d3453 1
a3453 1
      fip->list->visibility = VISIBILITY_IGNORE;
d3458 3
a3460 3
         dbx gives a bit size for all fields.
         Note that forward refs cannot be packed,
         and treat enums as if they had the width of ints.  */
d3471 1
a3471 1
      if ((FIELD_BITSIZE (fip->list->field)
d3474 2
a3475 2
	       && FIELD_BITSIZE (fip->list->field) == TARGET_INT_BIT)
	  )
d3487 1
a3487 1
   NAME : [VISIBILITY] TYPENUM , BITPOS , BITSIZE ;
d3496 4
a3499 4
   '/0' (VISIBILITY_PRIVATE)
   '/1' (VISIBILITY_PROTECTED)
   '/2' (VISIBILITY_PUBLIC)
   '/9' (VISIBILITY_IGNORE)
d3525 1
a3525 2
      if (os9k_stabs && **pp == ',')
	break;
d3531 2
a3532 2
      new->next = fip->list;
      fip->list = new;
d3538 3
a3540 3
         unless the CPLUS_MARKER is followed by an underscore, in
         which case it is just the name of an anonymous type, which we
         should handle like any other type name.  */
d3550 3
a3552 3
         values.  Data members are delimited by a single ':', while member
         functions are delimited by a pair of ':'s.  When we hit the member
         functions (if any), terminate scan loop and return. */
d3554 1
a3554 1
      while (*p != ':' && *p != '\0')
d3571 2
a3572 2
         partially constructed entry which we now scrub. */
      fip->list = fip->list->next;
d3576 1
a3602 2


d3653 2
a3654 2
      new->next = fip->list;
      fip->list = new;
d3660 8
a3667 10
	case '0':
	  /* Nothing to do. */
	  break;
	case '1':
	  SET_TYPE_FIELD_VIRTUAL (type, i);
	  break;
	default:
	  /* Unknown character.  Complain and treat it as non-virtual.  */
	  {
	    static struct complaint msg =
d3669 4
a3672 3
	      "Unknown virtual character `%c' for baseclass", 0, 0};
	    complain (&msg, **pp);
	  }
d3676 2
a3677 2
      new->visibility = *(*pp)++;
      switch (new->visibility)
d3679 13
a3691 14
	case VISIBILITY_PRIVATE:
	case VISIBILITY_PROTECTED:
	case VISIBILITY_PUBLIC:
	  break;
	default:
	  /* Bad visibility format.  Complain and treat it as
	     public.  */
	  {
	    static struct complaint msg =
	    {
	      "Unknown visibility `%c' for baseclass", 0, 0};
	    complain (&msg, new->visibility);
	    new->visibility = VISIBILITY_PUBLIC;
	  }
d3696 1
a3696 1

d3707 2
a3708 2
         base class.  Read it, and remember it's type name as this
         field's name. */
d3710 2
a3711 2
      new->field.type = read_type (pp, objfile);
      new->field.name = type_name_no_tag (new->field.type);
d3781 1
a3781 1

d3783 1
a3783 1
	  if (type == t)	/* Our own class provides vtbl ptr */
d3789 2
a3790 2
		  if (!strncmp (TYPE_FIELD_NAME (t, i), vptr_name,
				sizeof (vptr_name) - 1))
d3805 1
a3805 1
	gotit:
d3820 2
a3821 2
       fip->fnlist != NULL;
       fip->fnlist = fip->fnlist->next)
d3823 2
a3824 2
      --n;			/* Circumvent Sun3 compiler bug */
      TYPE_FN_FIELDLISTS (type)[n] = fip->fnlist->fn_fieldlist;
d3832 1
a3832 1
   ^^^^^^^^
d3834 3
a3836 3
   A:ZcA;;foopri__1AFv foopro__1AFv __ct__1AFv __ct__1AFRC1A foopub__1AFv ;;;
   ^
 */
d3845 1
a3845 1
  struct nextfield *new;
d3847 4
a3850 4
  char *sname;
  struct symbol *ref_static = 0;

  if (**pp == ';')		/* no static data; return */
d3859 2
a3860 2
  STABS_CONTINUE (pp, objfile);	/* handle \\ */
  while (**pp != ';' && (sname = get_substring (pp, ' '), sname))
d3862 4
a3865 5
      ref_static = lookup_symbol (sname, 0, VAR_NAMESPACE, 0, 0);	/*demangled_name */
      if (!ref_static)
	{
	  static struct complaint msg =
	  {"\
d3867 1
a3867 1
	   0, 0};
d3871 1
a3871 1
      stype = SYMBOL_TYPE (ref_static);
d3877 2
a3878 2
      new->next = fip->list;
      fip->list = new;
d3882 1
a3882 1
      new->visibility = VISIBILITY_PUBLIC;
d3885 1
a3885 1
      fip->list->field.type = stype;
d3894 1
a3894 1
       */
d3896 15
a3910 10
	{
	  char *dem, *dem_p;
	  dem = cplus_demangle (sname, DMGL_ANSI | DMGL_PARAMS);
	  if (dem != NULL)
	    {
	      dem_p = strrchr (dem, ':');
	      if (dem_p != 0 && *(dem_p - 1) == ':')
		dem_p++;
	      fip->list->field.name =
		obsavestring (dem_p, strlen (dem_p), &objfile->type_obstack);
d3912 2
a3913 7
	  else
	    {
	      fip->list->field.name =
		obsavestring (sname, strlen (sname), &objfile->type_obstack);
	    }
	}			/* end of code for cfront work around */
    }				/* loop again for next static field */
d3929 1
a3929 1
  int nfields = TYPE_NFIELDS (type);
d3931 1
a3931 1
  struct nextfield *new;
d3936 1
a3936 1
  for (i = 0; i < nfields; i++)
d3942 2
a3943 2
      new->next = fip->list;
      fip->list = new;
d3946 1
a3946 1
      new->field = TYPE_FIELD (type, i);
d3949 1
a3949 1
	new->visibility = VISIBILITY_PROTECTED;
d3951 1
a3951 1
	new->visibility = VISIBILITY_PRIVATE;
d3953 1
a3953 1
	new->visibility = VISIBILITY_PUBLIC;
d3960 1
a3960 1
  TYPE_FIELDS (type) = 0;
d3985 1
a3985 1
  for (scan = fip->list; scan != NULL; scan = scan->next)
d3988 1
a3988 1
      if (scan->visibility != VISIBILITY_PUBLIC)
d4026 2
a4027 2
      TYPE_FIELD (type, nfields) = fip->list->field;
      switch (fip->list->visibility)
d4029 3
a4031 3
	case VISIBILITY_PRIVATE:
	  SET_TYPE_FIELD_PRIVATE (type, nfields);
	  break;
d4033 3
a4035 3
	case VISIBILITY_PROTECTED:
	  SET_TYPE_FIELD_PROTECTED (type, nfields);
	  break;
d4037 3
a4039 3
	case VISIBILITY_IGNORE:
	  SET_TYPE_FIELD_IGNORE (type, nfields);
	  break;
d4041 2
a4042 2
	case VISIBILITY_PUBLIC:
	  break;
d4044 2
a4045 4
	default:
	  /* Unknown visibility.  Complain and treat it as public.  */
	  {
	    static struct complaint msg =
d4047 5
a4051 4
	      "Unknown visibility `%c' for field", 0, 0};
	    complain (&msg, fip->list->visibility);
	  }
	  break;
d4053 1
a4053 1
      fip->list = fip->list->next;
d4070 1
a4070 1
 */
d4168 1
a4168 1

d4221 2
a4222 2
         os9k_stabs (assuming the name of an enum constant can't start
         with a digit).  */
d4234 1
a4234 1
	(*pp)++;
d4247 2
a4248 3
      while (*p != ':')
	p++;
      name = obsavestring (*pp, p - *pp, &objfile->symbol_obstack);
d4255 1
a4255 1
	obstack_alloc (&objfile->symbol_obstack, sizeof (struct symbol));
d4258 1
a4258 1
      SYMBOL_LANGUAGE (sym) = current_subfile->language;
d4313 5
a4317 5
   type = b <signed> <width> <format type>; <offset>; <nbits>
   signed = u or s.
   optional format type = c or b for char or boolean.
   offset = offset from high order bit to start bit of type.
   width is # bytes in object of this type, nbits is # bits in type.
d4336 8
a4343 8
    case 's':
      signed_type = 1;
      break;
    case 'u':
      signed_type = 0;
      break;
    default:
      return error_type (pp, objfile);
d4389 1
a4389 1
		      signed_type ? 0 : TYPE_FLAG_UNSIGNED, (char *) NULL,
d4394 1
a4394 1
		      signed_type ? 0 : TYPE_FLAG_UNSIGNED, (char *) NULL,
d4454 1
a4454 1

d4483 1
a4483 1

d4485 1
a4485 1
         what GCC does. */
d4527 1
a4527 1

d4529 1
a4529 1
         the number of bits.  */
d4602 2
a4603 2
         integral type.  Take care of the case where <large number> doesn't
         fit in a long but <large number>-1 does.  */
d4657 1
a4657 1
         compatibility hack.  */
d4676 1
a4676 1
	return init_type (TYPE_CODE_INT, -n3, TYPE_FLAG_UNSIGNED,
d4684 2
a4685 2
         "unsigned long", and we already checked for that,
         so don't need to test for it here.  */
d4692 3
a4694 3
	       || n2 == -TARGET_LONG_LONG_BIT / TARGET_CHAR_BIT))
    return init_type (TYPE_CODE_INT, -n2, 0, NULL, objfile);
  else if (n2 == -n3 - 1)
d4706 1
a4706 1
handle_true_range:
d4742 1
a4742 1
  struct type *types[1024], **rval;	/* allow for fns of 1023 parameters */
d4749 1
a4749 1
	return (struct type **) -1;
d4760 1
a4760 1
  else if (TYPE_CODE (types[n - 1]) != TYPE_CODE_VOID)
d4799 1
a4799 2
      static struct complaint msg =
      {
d4807 1
a4807 1
				    &objfile->symbol_obstack);
d4829 1
a4829 2
      static struct complaint msg =
      {"ECOMM symbol unmatched by BCOMM", 0, 0};
d4834 2
a4835 2
  sym = (struct symbol *)
    obstack_alloc (&objfile->symbol_obstack, sizeof (struct symbol));
d4877 2
a4878 2
     struct symbol *sym;
     int valu;
d4881 1
a4881 1
  for (; next; next = next->next)
a4887 1

d4890 1
d4914 2
a4915 2
   Fix:  update array length using the element bounds
   and the target type's length.
d4917 2
a4918 2
   yet defined at the time a pointer to it was made.
   Fix:  Do a full lookup on the struct/union tag.  */
d4929 3
a4931 3
	case TYPE_CODE_STRUCT:
	case TYPE_CODE_UNION:
	case TYPE_CODE_ENUM:
d4946 1
a4946 2
		    static struct complaint msg =
		    {"need a type name", 0, 0};
d4955 1
a4955 1

d4973 1
a4973 2
	    static struct complaint msg =
	    {"\
d5010 1
a5010 1
         no unresolved symbols.  */
d5019 1
a5019 1
      for (msymbol = resolve_objfile->msymbols;
d5046 1
a5046 1
		  STREQ (SYMBOL_NAME (msymbol) + 1, SYMBOL_NAME (sym) + 1))
d5061 1
a5061 1

d5069 1
a5069 1
		  /* FIXME: Maybe should have added aliases to the global chain,                     resolved symbol name, then treated aliases as normal 
d5096 1
a5096 1

d5137 1
a5137 1
		      objfile->name, SYMBOL_NAME (prev));
d5166 1
a5166 2
void
start_stabs ()
d5182 1
a5182 2
void
end_stabs ()
@


1.1.1.6
log
@import gdb-1999-08-02 snapshot
@
text
@a4703 4
      /* -1 is used for the upper bound of (4 byte) "unsigned int" and
         "unsigned long", and we already checked for that,
         so don't need to test for it here.  */

d4708 4
d4713 3
a4715 15
      /* Is n3 == 2**(8n))-1 for some integer n?  Then it's an
         unsigned n-byte integer.  But do require n to be a power of
         two; we don't want 3- and 5-byte integers flying around.  */
      {
	int bytes;
	unsigned long bits;

	bits = n3;
	for (bytes = 0; (bits & 0xff) == 0xff; bytes++)
	  bits >>= 8;
	if (bits == 0
	    && ((bytes - 1) & bytes) == 0) /* "bytes is a power of two" */
	  return init_type (TYPE_CODE_INT, bytes, TYPE_FLAG_UNSIGNED, NULL,
			    objfile);
      }
@


1.1.1.7
log
@import gdb-1999-08-16 snapshot
@
text
@a196 2
void stabsread_clear_cache PARAMS ((void));

a1194 10
/* This file maintains a cache of stabs aliases found in the symbol
   table. If the symbol table changes, this cache must be cleared
   or we are left holding onto data in invalid obstacks. */
void
stabsread_clear_cache ()
{
  ref_count = 0;
  ref_chunk = 0;
}

d4713 1
a4713 1
      /* Is n3 == 2**(8n)-1 for some integer n?  Then it's an
@


1.1.1.8
log
@import gdb-1999-08-23 snapshot
@
text
@d3727 1
a3727 2
	      "Unknown visibility `%c' for baseclass", 0, 0
	    };
@


1.1.1.9
log
@import gdb-1999-11-16 snapshot
@
text
@d94 1
a94 1
static LONGEST read_huge_number PARAMS ((char **, int, int *));
d4483 1
a4483 1
static LONGEST
d4491 1
a4491 1
  LONGEST n = 0;
d4496 1
a4496 1
  LONGEST upper_limit;
d4513 1
a4513 1
    upper_limit = ULONGEST_MAX / radix;
d4515 1
a4515 1
    upper_limit = LONGEST_MAX / radix;
d4596 1
a4596 1
  LONGEST n2, n3;
d4649 2
a4650 2
		   && (n2bits == sizeof (LONGEST) * HOST_CHAR_BIT)
		   && n3 == LONGEST_MAX))
@


1.1.1.10
log
@import gdb-1999-12-06 snapshot
@
text
@d94 1
a94 1
static long read_huge_number PARAMS ((char **, int, int *));
d4483 1
a4483 1
static long
d4491 1
a4491 1
  long n = 0;
d4496 1
a4496 1
  long upper_limit;
d4513 1
a4513 1
    upper_limit = ULONG_MAX / radix;
d4515 1
a4515 1
    upper_limit = LONG_MAX / radix;
d4596 1
a4596 1
  long n2, n3;
d4649 2
a4650 2
		   && (n2bits == sizeof (long) * HOST_CHAR_BIT)
		   && n3 == LONG_MAX))
@


