head	1.48;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.48
	gdb_7_6-2013-04-26-release:1.48
	gdb_7_6-branch:1.48.0.2
	gdb_7_6-2013-03-12-branchpoint:1.48
	gdb_7_5_1-2012-11-29-release:1.46
	gdb_7_5-2012-08-17-release:1.46
	gdb_7_5-branch:1.46.0.2
	gdb_7_5-2012-07-18-branchpoint:1.46
	gdb_7_4_1-2012-04-26-release:1.43.2.1
	gdb_7_4-2012-01-24-release:1.43.2.1
	gdb_7_4-branch:1.43.0.2
	gdb_7_4-2011-12-13-branchpoint:1.43
	gdb_7_3_1-2011-09-04-release:1.40
	gdb_7_3-2011-07-26-release:1.40
	gdb_7_3-branch:1.40.0.2
	gdb_7_3-2011-04-01-branchpoint:1.40
	gdb_7_2-2010-09-02-release:1.36
	gdb_7_2-branch:1.36.0.2
	gdb_7_2-2010-07-07-branchpoint:1.36
	gdb_7_1-2010-03-18-release:1.32
	gdb_7_1-branch:1.32.0.2
	gdb_7_1-2010-02-18-branchpoint:1.32
	gdb_7_0_1-2009-12-22-release:1.28
	gdb_7_0-2009-10-06-release:1.28
	gdb_7_0-branch:1.28.0.4
	gdb_7_0-2009-09-16-branchpoint:1.28
	arc-sim-20090309:1.19
	msnyder-checkpoint-072509-branch:1.28.0.2
	msnyder-checkpoint-072509-branchpoint:1.28
	arc-insight_6_8-branch:1.19.0.10
	arc-insight_6_8-branchpoint:1.19
	insight_6_8-branch:1.19.0.8
	insight_6_8-branchpoint:1.19
	reverse-20081226-branch:1.22.0.6
	reverse-20081226-branchpoint:1.22
	multiprocess-20081120-branch:1.22.0.4
	multiprocess-20081120-branchpoint:1.22
	reverse-20080930-branch:1.22.0.2
	reverse-20080930-branchpoint:1.22
	reverse-20080717-branch:1.19.0.6
	reverse-20080717-branchpoint:1.19
	msnyder-reverse-20080609-branch:1.19.0.4
	msnyder-reverse-20080609-branchpoint:1.19
	drow-reverse-20070409-branch:1.15.0.2
	drow-reverse-20070409-branchpoint:1.15
	gdb_6_8-2008-03-27-release:1.19
	gdb_6_8-branch:1.19.0.2
	gdb_6_8-2008-02-26-branchpoint:1.19
	gdb_6_7_1-2007-10-29-release:1.16
	gdb_6_7-2007-10-10-release:1.16
	gdb_6_7-branch:1.16.0.2
	gdb_6_7-2007-09-07-branchpoint:1.16
	insight_6_6-20070208-release:1.14
	gdb_6_6-2006-12-18-release:1.14
	gdb_6_6-branch:1.14.0.18
	gdb_6_6-2006-11-15-branchpoint:1.14
	insight_6_5-20061003-release:1.14
	gdb-csl-symbian-6_4_50_20060226-12:1.14
	gdb-csl-sourcerygxx-3_4_4-25:1.11
	nickrob-async-20060828-mergepoint:1.14
	gdb-csl-symbian-6_4_50_20060226-11:1.14
	gdb-csl-sourcerygxx-4_1-17:1.14
	gdb-csl-20060226-branch-local-2:1.14
	gdb-csl-sourcerygxx-4_1-14:1.14
	gdb-csl-sourcerygxx-4_1-13:1.14
	gdb-csl-sourcerygxx-4_1-12:1.14
	gdb-csl-sourcerygxx-3_4_4-21:1.14
	gdb_6_5-20060621-release:1.14
	gdb-csl-sourcerygxx-4_1-9:1.14
	gdb-csl-sourcerygxx-4_1-8:1.14
	gdb-csl-sourcerygxx-4_1-7:1.14
	gdb-csl-arm-2006q1-6:1.14
	gdb-csl-sourcerygxx-4_1-6:1.14
	gdb-csl-symbian-6_4_50_20060226-10:1.14
	gdb-csl-symbian-6_4_50_20060226-9:1.14
	gdb-csl-symbian-6_4_50_20060226-8:1.14
	gdb-csl-coldfire-4_1-11:1.14
	gdb-csl-sourcerygxx-3_4_4-19:1.14
	gdb-csl-coldfire-4_1-10:1.14
	gdb_6_5-branch:1.14.0.16
	gdb_6_5-2006-05-14-branchpoint:1.14
	gdb-csl-sourcerygxx-4_1-5:1.14
	nickrob-async-20060513-branch:1.14.0.14
	nickrob-async-20060513-branchpoint:1.14
	gdb-csl-sourcerygxx-4_1-4:1.14
	msnyder-reverse-20060502-branch:1.14.0.12
	msnyder-reverse-20060502-branchpoint:1.14
	gdb-csl-morpho-4_1-4:1.14
	gdb-csl-sourcerygxx-3_4_4-17:1.14
	readline_5_1-import-branch:1.14.0.10
	readline_5_1-import-branchpoint:1.14
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.14
	gdb-csl-symbian-20060226-branch:1.14.0.8
	gdb-csl-symbian-20060226-branchpoint:1.14
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.14
	msnyder-reverse-20060331-branch:1.14.0.6
	msnyder-reverse-20060331-branchpoint:1.14
	gdb-csl-available-20060303-branch:1.14.0.4
	gdb-csl-available-20060303-branchpoint:1.14
	gdb-csl-20060226-branch:1.14.0.2
	gdb-csl-20060226-branchpoint:1.14
	gdb_6_4-20051202-release:1.11
	msnyder-fork-checkpoint-branch:1.11.0.12
	msnyder-fork-checkpoint-branchpoint:1.11
	gdb-csl-gxxpro-6_3-branch:1.11.0.10
	gdb-csl-gxxpro-6_3-branchpoint:1.11
	gdb_6_4-branch:1.11.0.8
	gdb_6_4-2005-11-01-branchpoint:1.11
	gdb-csl-arm-20051020-branch:1.11.0.6
	gdb-csl-arm-20051020-branchpoint:1.11
	msnyder-tracepoint-checkpoint-branch:1.11.0.4
	msnyder-tracepoint-checkpoint-branchpoint:1.11
	gdb-csl-arm-20050325-2005-q1b:1.11
	gdb-csl-arm-20050325-2005-q1a:1.11
	csl-arm-20050325-branch:1.11.0.2
	csl-arm-20050325-branchpoint:1.11
	gdb-post-i18n-errorwarning-20050211:1.11
	gdb-pre-i18n-errorwarning-20050211:1.11
	gdb_6_3-20041109-release:1.9
	gdb_6_3-branch:1.9.0.2
	gdb_6_3-20041019-branchpoint:1.9
	drow_intercu-merge-20040921:1.8
	drow_intercu-merge-20040915:1.7
	jimb-gdb_6_2-e500-branch:1.7.0.6
	jimb-gdb_6_2-e500-branchpoint:1.7
	gdb_6_2-20040730-release:1.7
	gdb_6_2-branch:1.7.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.7
	gdb_6_1_1-20040616-release:1.6
	gdb_6_1-2004-04-05-release:1.6
	drow_intercu-merge-20040402:1.6
	drow_intercu-merge-20040327:1.6
	ezannoni_pie-20040323-branch:1.6.0.48
	ezannoni_pie-20040323-branchpoint:1.6
	cagney_tramp-20040321-mergepoint:1.6
	cagney_tramp-20040309-branch:1.6.0.46
	cagney_tramp-20040309-branchpoint:1.6
	gdb_6_1-branch:1.6.0.44
	gdb_6_1-2004-03-01-gmt-branchpoint:1.6
	drow_intercu-20040221-branch:1.6.0.42
	drow_intercu-20040221-branchpoint:1.6
	cagney_bfdfile-20040213-branch:1.6.0.40
	cagney_bfdfile-20040213-branchpoint:1.6
	drow-cplus-merge-20040208:1.6
	carlton_dictionary-20040126-merge:1.6
	cagney_bigcore-20040122-branch:1.6.0.38
	cagney_bigcore-20040122-branchpoint:1.6
	drow-cplus-merge-20040113:1.6
	drow-cplus-merge-20031224:1.6
	drow-cplus-merge-20031220:1.6
	carlton_dictionary-20031215-merge:1.6
	drow-cplus-merge-20031214:1.6
	carlton-dictionary-20031111-merge:1.6
	gdb_6_0-2003-10-04-release:1.6
	kettenis_sparc-20030918-branch:1.6.0.36
	kettenis_sparc-20030918-branchpoint:1.6
	carlton_dictionary-20030917-merge:1.6
	ezannoni_pie-20030916-branchpoint:1.6
	ezannoni_pie-20030916-branch:1.6.0.34
	cagney_x86i386-20030821-branch:1.6.0.32
	cagney_x86i386-20030821-branchpoint:1.6
	carlton_dictionary-20030805-merge:1.6
	carlton_dictionary-20030627-merge:1.6
	gdb_6_0-branch:1.6.0.30
	gdb_6_0-2003-06-23-branchpoint:1.6
	jimb-ppc64-linux-20030613-branch:1.6.0.28
	jimb-ppc64-linux-20030613-branchpoint:1.6
	cagney_convert-20030606-branch:1.6.0.26
	cagney_convert-20030606-branchpoint:1.6
	cagney_writestrings-20030508-branch:1.6.0.24
	cagney_writestrings-20030508-branchpoint:1.6
	jimb-ppc64-linux-20030528-branch:1.6.0.22
	jimb-ppc64-linux-20030528-branchpoint:1.6
	carlton_dictionary-20030523-merge:1.6
	cagney_fileio-20030521-branch:1.6.0.20
	cagney_fileio-20030521-branchpoint:1.6
	kettenis_i386newframe-20030517-mergepoint:1.6
	jimb-ppc64-linux-20030509-branch:1.6.0.18
	jimb-ppc64-linux-20030509-branchpoint:1.6
	kettenis_i386newframe-20030504-mergepoint:1.6
	carlton_dictionary-20030430-merge:1.6
	kettenis_i386newframe-20030419-branch:1.6.0.16
	kettenis_i386newframe-20030419-branchpoint:1.6
	carlton_dictionary-20030416-merge:1.6
	cagney_frameaddr-20030409-mergepoint:1.6
	kettenis_i386newframe-20030406-branch:1.6.0.14
	kettenis_i386newframe-20030406-branchpoint:1.6
	cagney_frameaddr-20030403-branchpoint:1.6
	cagney_frameaddr-20030403-branch:1.6.0.12
	cagney_framebase-20030330-mergepoint:1.6
	cagney_framebase-20030326-branch:1.6.0.10
	cagney_framebase-20030326-branchpoint:1.6
	cagney_lazyid-20030317-branch:1.6.0.8
	cagney_lazyid-20030317-branchpoint:1.6
	kettenis-i386newframe-20030316-mergepoint:1.6
	offbyone-20030313-branch:1.6.0.6
	offbyone-20030313-branchpoint:1.6
	kettenis-i386newframe-20030308-branch:1.6.0.4
	kettenis-i386newframe-20030308-branchpoint:1.6
	carlton_dictionary-20030305-merge:1.6
	cagney_offbyone-20030303-branch:1.6.0.2
	cagney_offbyone-20030303-branchpoint:1.6
	carlton_dictionary-20030207-merge:1.5
	interps-20030203-mergepoint:1.5
	interps-20030202-branch:1.5.0.14
	interps-20030202-branchpoint:1.5
	cagney-unwind-20030108-branch:1.5.0.12
	cagney-unwind-20030108-branchpoint:1.5
	carlton_dictionary-20021223-merge:1.5
	gdb_5_3-2002-12-12-release:1.5
	carlton_dictionary-20021115-merge:1.5
	kseitz_interps-20021105-merge:1.5
	kseitz_interps-20021103-merge:1.5
	drow-cplus-merge-20021020:1.5
	drow-cplus-merge-20021025:1.5
	carlton_dictionary-20021025-merge:1.5
	carlton_dictionary-20021011-merge:1.5
	drow-cplus-branch:1.5.0.10
	drow-cplus-branchpoint:1.5
	kseitz_interps-20020930-merge:1.5
	carlton_dictionary-20020927-merge:1.5
	carlton_dictionary-branch:1.5.0.8
	carlton_dictionary-20020920-branchpoint:1.5
	gdb_5_3-branch:1.5.0.6
	gdb_5_3-2002-09-04-branchpoint:1.5
	kseitz_interps-20020829-merge:1.5
	cagney_sysregs-20020825-branch:1.5.0.4
	cagney_sysregs-20020825-branchpoint:1.5
	readline_4_3-import-branch:1.5.0.2
	readline_4_3-import-branchpoint:1.5
	kseitz_interps-20020528-branch:1.1.0.4
	cagney_regbuf-20020515-branch:1.1.0.2;
locks; strict;
comment	@ * @;


1.48
date	2013.01.01.06.32.37;	author brobecke;	state Exp;
branches;
next	1.47;

1.47
date	2012.11.12.17.14.54;	author tromey;	state Exp;
branches;
next	1.46;

1.46
date	2012.04.18.06.46.46;	author jkratoch;	state Exp;
branches;
next	1.45;

1.45
date	2012.02.07.04.48.18;	author devans;	state Exp;
branches;
next	1.44;

1.44
date	2012.01.04.08.16.55;	author brobecke;	state Exp;
branches;
next	1.43;

1.43
date	2011.07.01.18.27.35;	author brobecke;	state Exp;
branches
	1.43.2.1;
next	1.42;

1.42
date	2011.07.01.18.27.25;	author brobecke;	state Exp;
branches;
next	1.41;

1.41
date	2011.07.01.18.27.12;	author brobecke;	state Exp;
branches;
next	1.40;

1.40
date	2011.01.01.15.32.56;	author brobecke;	state Exp;
branches;
next	1.39;

1.39
date	2010.12.29.08.01.31;	author brobecke;	state Exp;
branches;
next	1.38;

1.38
date	2010.11.23.00.58.04;	author brobecke;	state Exp;
branches;
next	1.37;

1.37
date	2010.10.04.06.37.54;	author hilfingr;	state Exp;
branches;
next	1.36;

1.36
date	2010.06.14.08.26.56;	author jkratoch;	state Exp;
branches;
next	1.35;

1.35
date	2010.05.18.19.23.37;	author msnyder;	state Exp;
branches;
next	1.34;

1.34
date	2010.05.17.16.55.31;	author brobecke;	state Exp;
branches;
next	1.33;

1.33
date	2010.04.20.22.38.01;	author brobecke;	state Exp;
branches;
next	1.32;

1.32
date	2010.01.08.11.58.23;	author brobecke;	state Exp;
branches;
next	1.31;

1.31
date	2010.01.01.07.31.29;	author brobecke;	state Exp;
branches;
next	1.30;

1.30
date	2009.12.14.06.19.13;	author hilfingr;	state Exp;
branches;
next	1.29;

1.29
date	2009.11.19.22.42.48;	author brobecke;	state Exp;
branches;
next	1.28;

1.28
date	2009.06.29.17.30.12;	author uweigand;	state Exp;
branches;
next	1.27;

1.27
date	2009.06.29.17.28.59;	author uweigand;	state Exp;
branches;
next	1.26;

1.26
date	2009.03.20.22.00.10;	author tromey;	state Exp;
branches;
next	1.25;

1.25
date	2009.02.19.23.59.27;	author brobecke;	state Exp;
branches;
next	1.24;

1.24
date	2009.01.03.05.57.50;	author brobecke;	state Exp;
branches;
next	1.23;

1.23
date	2008.12.28.14.14.18;	author jkratoch;	state Exp;
branches;
next	1.22;

1.22
date	2008.09.11.14.22.32;	author uweigand;	state Exp;
branches;
next	1.21;

1.21
date	2008.08.24.16.39.56;	author tromey;	state Exp;
branches;
next	1.20;

1.20
date	2008.08.19.10.10.39;	author hilfingr;	state Exp;
branches;
next	1.19;

1.19
date	2008.01.04.20.45.05;	author brobecke;	state Exp;
branches;
next	1.18;

1.18
date	2008.01.03.13.11.51;	author brobecke;	state Exp;
branches;
next	1.17;

1.17
date	2008.01.01.22.53.09;	author drow;	state Exp;
branches;
next	1.16;

1.16
date	2007.08.23.18.08.25;	author brobecke;	state Exp;
branches;
next	1.15;

1.15
date	2007.01.09.17.58.49;	author drow;	state Exp;
branches;
next	1.14;

1.14
date	2006.01.08.07.19.40;	author hilfingr;	state Exp;
branches;
next	1.13;

1.13
date	2006.01.02.09.39.21;	author hilfingr;	state Exp;
branches;
next	1.12;

1.12
date	2005.12.17.22.33.59;	author eliz;	state Exp;
branches;
next	1.11;

1.11
date	2004.12.21.10.03.55;	author hilfingr;	state Exp;
branches;
next	1.10;

1.10
date	2004.12.12.17.06.26;	author cagney;	state Exp;
branches;
next	1.9;

1.9
date	2004.10.08.09.40.12;	author hilfingr;	state Exp;
branches;
next	1.8;

1.8
date	2004.09.18.22.23.23;	author hilfingr;	state Exp;
branches;
next	1.7;

1.7
date	2004.06.02.09.55.36;	author hilfingr;	state Exp;
branches;
next	1.6;

1.6
date	2003.02.20.17.17.23;	author carlton;	state Exp;
branches
	1.6.42.1;
next	1.5;

1.5
date	2002.08.18.18.23.47;	author aidan;	state Exp;
branches
	1.5.8.1
	1.5.10.1;
next	1.4;

1.4
date	2002.08.18.18.07.29;	author aidan;	state Exp;
branches;
next	1.3;

1.3
date	2002.07.29.22.55.26;	author cagney;	state Exp;
branches;
next	1.2;

1.2
date	2002.07.25.01.14.20;	author aidan;	state Exp;
branches;
next	1.1;

1.1
date	2002.06.04.15.28.48;	author aidan;	state Exp;
branches
	1.1.2.1
	1.1.4.1;
next	;

1.43.2.1
date	2012.01.06.04.43.03;	author brobecke;	state Exp;
branches;
next	;

1.6.42.1
date	2004.09.16.17.00.52;	author drow;	state Exp;
branches;
next	1.6.42.2;

1.6.42.2
date	2004.09.21.20.44.13;	author drow;	state Exp;
branches;
next	;

1.5.8.1
date	2002.12.21.00.17.42;	author carlton;	state Exp;
branches;
next	1.5.8.2;

1.5.8.2
date	2003.03.06.00.56.22;	author carlton;	state Exp;
branches;
next	;

1.5.10.1
date	2003.12.14.20.27.04;	author drow;	state Exp;
branches;
next	;

1.1.2.1
date	2002.06.15.16.42.50;	author cagney;	state Exp;
branches;
next	;

1.1.4.1
date	2002.06.20.01.32.10;	author kseitz;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2002.08.09.18.34.23;	author kseitz;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2002.08.30.22.52.42;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.48
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@/* Support for printing Ada types for GDB, the GNU debugger.
   Copyright (C) 1986-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "gdb_obstack.h"
#include "bfd.h"		/* Binary File Description */
#include "symtab.h"
#include "gdbtypes.h"
#include "expression.h"
#include "value.h"
#include "gdbcore.h"
#include "target.h"
#include "command.h"
#include "gdbcmd.h"
#include "language.h"
#include "demangle.h"
#include "c-lang.h"
#include "typeprint.h"
#include "ada-lang.h"

#include <ctype.h>
#include "gdb_string.h"
#include <errno.h>

static int print_selected_record_field_types (struct type *, struct type *,
					      int, int,
					      struct ui_file *, int, int,
					      const struct type_print_options *);
   
static int print_record_field_types (struct type *, struct type *,
				     struct ui_file *, int, int,
				     const struct type_print_options *);

static void print_array_type (struct type *, struct ui_file *, int, int,
			      const struct type_print_options *);

static int print_choices (struct type *, int, struct ui_file *,
			  struct type *);

static void print_range (struct type *, struct ui_file *);

static void print_range_bound (struct type *, char *, int *,
			       struct ui_file *);

static void
print_dynamic_range_bound (struct type *, const char *, int,
			   const char *, struct ui_file *);

static void print_range_type (struct type *, struct ui_file *);



static char *name_buffer;
static int name_buffer_len;

/* The (decoded) Ada name of TYPE.  This value persists until the
   next call.  */

static char *
decoded_type_name (struct type *type)
{
  if (ada_type_name (type) == NULL)
    return NULL;
  else
    {
      const char *raw_name = ada_type_name (type);
      char *s, *q;

      if (name_buffer == NULL || name_buffer_len <= strlen (raw_name))
	{
	  name_buffer_len = 16 + 2 * strlen (raw_name);
	  name_buffer = xrealloc (name_buffer, name_buffer_len);
	}
      strcpy (name_buffer, raw_name);

      s = (char *) strstr (name_buffer, "___");
      if (s != NULL)
	*s = '\0';

      s = name_buffer + strlen (name_buffer) - 1;
      while (s > name_buffer && (s[0] != '_' || s[-1] != '_'))
	s -= 1;

      if (s == name_buffer)
	return name_buffer;

      if (!islower (s[1]))
	return NULL;

      for (s = q = name_buffer; *s != '\0'; q += 1)
	{
	  if (s[0] == '_' && s[1] == '_')
	    {
	      *q = '.';
	      s += 2;
	    }
	  else
	    {
	      *q = *s;
	      s += 1;
	    }
	}
      *q = '\0';
      return name_buffer;
    }
}

/* Print TYPE on STREAM, preferably as a range.  */

static void
print_range (struct type *type, struct ui_file *stream)
{
  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_RANGE:
    case TYPE_CODE_ENUM:
      {
	struct type *target_type;
	target_type = TYPE_TARGET_TYPE (type);
	if (target_type == NULL)
	  target_type = type;
	ada_print_scalar (target_type, ada_discrete_type_low_bound (type),
			  stream);
	fprintf_filtered (stream, " .. ");
	ada_print_scalar (target_type, ada_discrete_type_high_bound (type),
			  stream);
      }
      break;
    default:
      fprintf_filtered (stream, "%.*s",
			ada_name_prefix_len (TYPE_NAME (type)),
			TYPE_NAME (type));
      break;
    }
}

/* Print the number or discriminant bound at BOUNDS+*N on STREAM, and
   set *N past the bound and its delimiter, if any.  */

static void
print_range_bound (struct type *type, char *bounds, int *n,
		   struct ui_file *stream)
{
  LONGEST B;

  if (ada_scan_number (bounds, *n, &B, n))
    {
      /* STABS decodes all range types which bounds are 0 .. -1 as
         unsigned integers (ie. the type code is TYPE_CODE_INT, not
         TYPE_CODE_RANGE).  Unfortunately, ada_print_scalar() relies
         on the unsigned flag to determine whether the bound should
         be printed as a signed or an unsigned value.  This causes
         the upper bound of the 0 .. -1 range types to be printed as
         a very large unsigned number instead of -1.
         To workaround this stabs deficiency, we replace the TYPE by NULL
         to indicate default output when we detect that the bound is negative,
         and the type is a TYPE_CODE_INT.  The bound is negative when
         'm' is the last character of the number scanned in BOUNDS.  */
      if (bounds[*n - 1] == 'm' && TYPE_CODE (type) == TYPE_CODE_INT)
	type = NULL;
      ada_print_scalar (type, B, stream);
      if (bounds[*n] == '_')
	*n += 2;
    }
  else
    {
      int bound_len;
      char *bound = bounds + *n;
      char *pend;

      pend = strstr (bound, "__");
      if (pend == NULL)
	*n += bound_len = strlen (bound);
      else
	{
	  bound_len = pend - bound;
	  *n += bound_len + 2;
	}
      fprintf_filtered (stream, "%.*s", bound_len, bound);
    }
}

/* Assuming NAME[0 .. NAME_LEN-1] is the name of a range type, print
   the value (if found) of the bound indicated by SUFFIX ("___L" or
   "___U") according to the ___XD conventions.  */

static void
print_dynamic_range_bound (struct type *type, const char *name, int name_len,
			   const char *suffix, struct ui_file *stream)
{
  static char *name_buf = NULL;
  static size_t name_buf_len = 0;
  LONGEST B;
  int OK;

  GROW_VECT (name_buf, name_buf_len, name_len + strlen (suffix) + 1);
  strncpy (name_buf, name, name_len);
  strcpy (name_buf + name_len, suffix);

  B = get_int_var_value (name_buf, &OK);
  if (OK)
    ada_print_scalar (type, B, stream);
  else
    fprintf_filtered (stream, "?");
}

/* Print RAW_TYPE as a range type, using any bound information
   following the GNAT encoding (if available).  */

static void
print_range_type (struct type *raw_type, struct ui_file *stream)
{
  const char *name;
  struct type *base_type;
  const char *subtype_info;

  gdb_assert (raw_type != NULL);
  name = TYPE_NAME (raw_type);
  gdb_assert (name != NULL);

  if (TYPE_CODE (raw_type) == TYPE_CODE_RANGE)
    base_type = TYPE_TARGET_TYPE (raw_type);
  else
    base_type = raw_type;

  subtype_info = strstr (name, "___XD");
  if (subtype_info == NULL)
    print_range (raw_type, stream);
  else
    {
      int prefix_len = subtype_info - name;
      char *bounds_str;
      int n;

      subtype_info += 5;
      bounds_str = strchr (subtype_info, '_');
      n = 1;

      if (*subtype_info == 'L')
	{
	  print_range_bound (base_type, bounds_str, &n, stream);
	  subtype_info += 1;
	}
      else
	print_dynamic_range_bound (base_type, name, prefix_len, "___L",
				   stream);

      fprintf_filtered (stream, " .. ");

      if (*subtype_info == 'U')
	print_range_bound (base_type, bounds_str, &n, stream);
      else
	print_dynamic_range_bound (base_type, name, prefix_len, "___U",
				   stream);
    }
}

/* Print enumerated type TYPE on STREAM.  */

static void
print_enum_type (struct type *type, struct ui_file *stream)
{
  int len = TYPE_NFIELDS (type);
  int i;
  LONGEST lastval;

  fprintf_filtered (stream, "(");
  wrap_here (" ");

  lastval = 0;
  for (i = 0; i < len; i++)
    {
      QUIT;
      if (i)
	fprintf_filtered (stream, ", ");
      wrap_here ("    ");
      fputs_filtered (ada_enum_name (TYPE_FIELD_NAME (type, i)), stream);
      if (lastval != TYPE_FIELD_ENUMVAL (type, i))
	{
	  fprintf_filtered (stream, " => %s",
			    plongest (TYPE_FIELD_ENUMVAL (type, i)));
	  lastval = TYPE_FIELD_ENUMVAL (type, i);
	}
      lastval += 1;
    }
  fprintf_filtered (stream, ")");
}

/* Print representation of Ada fixed-point type TYPE on STREAM.  */

static void
print_fixed_point_type (struct type *type, struct ui_file *stream)
{
  DOUBLEST delta = ada_delta (type);
  DOUBLEST small = ada_fixed_to_float (type, 1.0);

  if (delta < 0.0)
    fprintf_filtered (stream, "delta ??");
  else
    {
      fprintf_filtered (stream, "delta %g", (double) delta);
      if (delta != small)
	fprintf_filtered (stream, " <'small = %g>", (double) small);
    }
}

/* Print simple (constrained) array type TYPE on STREAM.  LEVEL is the
   recursion (indentation) level, in case the element type itself has
   nested structure, and SHOW is the number of levels of internal
   structure to show (see ada_print_type).  */

static void
print_array_type (struct type *type, struct ui_file *stream, int show,
		  int level, const struct type_print_options *flags)
{
  int bitsize;
  int n_indices;

  if (ada_is_constrained_packed_array_type (type))
    type = ada_coerce_to_simple_array_type (type);

  bitsize = 0;
  fprintf_filtered (stream, "array (");

  if (type == NULL)
    {
      fprintf_filtered (stream, _("<undecipherable array type>"));
      return;
    }

  n_indices = -1;
  if (ada_is_simple_array_type (type))
    {
      struct type *range_desc_type;
      struct type *arr_type;

      range_desc_type = ada_find_parallel_type (type, "___XA");
      ada_fixup_array_indexes_type (range_desc_type);

      bitsize = 0;
      if (range_desc_type == NULL)
	{
	  for (arr_type = type; TYPE_CODE (arr_type) == TYPE_CODE_ARRAY;
	       arr_type = TYPE_TARGET_TYPE (arr_type))
	    {
	      if (arr_type != type)
		fprintf_filtered (stream, ", ");
	      print_range (TYPE_INDEX_TYPE (arr_type), stream);
	      if (TYPE_FIELD_BITSIZE (arr_type, 0) > 0)
		bitsize = TYPE_FIELD_BITSIZE (arr_type, 0);
	    }
	}
      else
	{
	  int k;

	  n_indices = TYPE_NFIELDS (range_desc_type);
	  for (k = 0, arr_type = type;
	       k < n_indices;
	       k += 1, arr_type = TYPE_TARGET_TYPE (arr_type))
	    {
	      if (k > 0)
		fprintf_filtered (stream, ", ");
	      print_range_type (TYPE_FIELD_TYPE (range_desc_type, k),
				stream);
	      if (TYPE_FIELD_BITSIZE (arr_type, 0) > 0)
		bitsize = TYPE_FIELD_BITSIZE (arr_type, 0);
	    }
	}
    }
  else
    {
      int i, i0;

      for (i = i0 = ada_array_arity (type); i > 0; i -= 1)
	fprintf_filtered (stream, "%s<>", i == i0 ? "" : ", ");
    }

  fprintf_filtered (stream, ") of ");
  wrap_here ("");
  ada_print_type (ada_array_element_type (type, n_indices), "", stream,
		  show == 0 ? 0 : show - 1, level + 1, flags);
  if (bitsize > 0)
    fprintf_filtered (stream, " <packed: %d-bit elements>", bitsize);
}

/* Print the choices encoded by field FIELD_NUM of variant-part TYPE on
   STREAM, assuming that VAL_TYPE (if non-NULL) is the type of the
   values.  Return non-zero if the field is an encoding of
   discriminant values, as in a standard variant record, and 0 if the
   field is not so encoded (as happens with single-component variants
   in types annotated with pragma Unchecked_Variant).  */

static int
print_choices (struct type *type, int field_num, struct ui_file *stream,
	       struct type *val_type)
{
  int have_output;
  int p;
  const char *name = TYPE_FIELD_NAME (type, field_num);

  have_output = 0;

  /* Skip over leading 'V': NOTE soon to be obsolete.  */
  if (name[0] == 'V')
    {
      if (!ada_scan_number (name, 1, NULL, &p))
	goto Huh;
    }
  else
    p = 0;

  while (1)
    {
      switch (name[p])
	{
	default:
	  goto Huh;
	case '_':
	case '\0':
	  fprintf_filtered (stream, " =>");
	  return 1;
	case 'S':
	case 'R':
	case 'O':
	  if (have_output)
	    fprintf_filtered (stream, " | ");
	  have_output = 1;
	  break;
	}

      switch (name[p])
	{
	case 'S':
	  {
	    LONGEST W;

	    if (!ada_scan_number (name, p + 1, &W, &p))
	      goto Huh;
	    ada_print_scalar (val_type, W, stream);
	    break;
	  }
	case 'R':
	  {
	    LONGEST L, U;

	    if (!ada_scan_number (name, p + 1, &L, &p)
		|| name[p] != 'T' || !ada_scan_number (name, p + 1, &U, &p))
	      goto Huh;
	    ada_print_scalar (val_type, L, stream);
	    fprintf_filtered (stream, " .. ");
	    ada_print_scalar (val_type, U, stream);
	    break;
	  }
	case 'O':
	  fprintf_filtered (stream, "others");
	  p += 1;
	  break;
	}
    }

Huh:
  fprintf_filtered (stream, "?? =>");
  return 0;
}

/* Assuming that field FIELD_NUM of TYPE represents variants whose
   discriminant is contained in OUTER_TYPE, print its components on STREAM.
   LEVEL is the recursion (indentation) level, in case any of the fields
   themselves have nested structure, and SHOW is the number of levels of 
   internal structure to show (see ada_print_type).  For this purpose,
   fields nested in a variant part are taken to be at the same level as
   the fields immediately outside the variant part.  */

static void
print_variant_clauses (struct type *type, int field_num,
		       struct type *outer_type, struct ui_file *stream,
		       int show, int level,
		       const struct type_print_options *flags)
{
  int i;
  struct type *var_type, *par_type;
  struct type *discr_type;

  var_type = TYPE_FIELD_TYPE (type, field_num);
  discr_type = ada_variant_discrim_type (var_type, outer_type);

  if (TYPE_CODE (var_type) == TYPE_CODE_PTR)
    {
      var_type = TYPE_TARGET_TYPE (var_type);
      if (var_type == NULL || TYPE_CODE (var_type) != TYPE_CODE_UNION)
	return;
    }

  par_type = ada_find_parallel_type (var_type, "___XVU");
  if (par_type != NULL)
    var_type = par_type;

  for (i = 0; i < TYPE_NFIELDS (var_type); i += 1)
    {
      fprintf_filtered (stream, "\n%*swhen ", level + 4, "");
      if (print_choices (var_type, i, stream, discr_type))
	{
	  if (print_record_field_types (TYPE_FIELD_TYPE (var_type, i),
					outer_type, stream, show, level + 4,
					flags)
	      <= 0)
	    fprintf_filtered (stream, " null;");
	}
      else
	print_selected_record_field_types (var_type, outer_type, i, i,
					   stream, show, level + 4, flags);
    }
}

/* Assuming that field FIELD_NUM of TYPE is a variant part whose
   discriminants are contained in OUTER_TYPE, print a description of it
   on STREAM.  LEVEL is the recursion (indentation) level, in case any of
   the fields themselves have nested structure, and SHOW is the number of
   levels of internal structure to show (see ada_print_type).  For this
   purpose, fields nested in a variant part are taken to be at the same
   level as the fields immediately outside the variant part.  */

static void
print_variant_part (struct type *type, int field_num, struct type *outer_type,
		    struct ui_file *stream, int show, int level,
		    const struct type_print_options *flags)
{
  fprintf_filtered (stream, "\n%*scase %s is", level + 4, "",
		    ada_variant_discrim_name
		    (TYPE_FIELD_TYPE (type, field_num)));
  print_variant_clauses (type, field_num, outer_type, stream, show,
			 level + 4, flags);
  fprintf_filtered (stream, "\n%*send case;", level + 4, "");
}

/* Print a description on STREAM of the fields FLD0 through FLD1 in
   record or union type TYPE, whose discriminants are in OUTER_TYPE.
   LEVEL is the recursion (indentation) level, in case any of the
   fields themselves have nested structure, and SHOW is the number of
   levels of internal structure to show (see ada_print_type).  Does
   not print parent type information of TYPE.  Returns 0 if no fields
   printed, -1 for an incomplete type, else > 0.  Prints each field
   beginning on a new line, but does not put a new line at end.  */

static int
print_selected_record_field_types (struct type *type, struct type *outer_type,
				   int fld0, int fld1,
				   struct ui_file *stream, int show, int level,
				   const struct type_print_options *flags)
{
  int i, flds;

  flds = 0;

  if (fld0 > fld1 && TYPE_STUB (type))
    return -1;

  for (i = fld0; i <= fld1; i += 1)
    {
      QUIT;

      if (ada_is_parent_field (type, i) || ada_is_ignored_field (type, i))
	;
      else if (ada_is_wrapper_field (type, i))
	flds += print_record_field_types (TYPE_FIELD_TYPE (type, i), type,
					  stream, show, level, flags);
      else if (ada_is_variant_part (type, i))
	{
	  print_variant_part (type, i, outer_type, stream, show, level, flags);
	  flds = 1;
	}
      else
	{
	  flds += 1;
	  fprintf_filtered (stream, "\n%*s", level + 4, "");
	  ada_print_type (TYPE_FIELD_TYPE (type, i),
			  TYPE_FIELD_NAME (type, i),
			  stream, show - 1, level + 4, flags);
	  fprintf_filtered (stream, ";");
	}
    }

  return flds;
}

/* Print a description on STREAM of all fields of record or union type
   TYPE, as for print_selected_record_field_types, above.  */

static int
print_record_field_types (struct type *type, struct type *outer_type,
			  struct ui_file *stream, int show, int level,
			  const struct type_print_options *flags)
{
  return print_selected_record_field_types (type, outer_type,
					    0, TYPE_NFIELDS (type) - 1,
					    stream, show, level, flags);
}
   

/* Print record type TYPE on STREAM.  LEVEL is the recursion (indentation)
   level, in case the element type itself has nested structure, and SHOW is
   the number of levels of internal structure to show (see ada_print_type).  */

static void
print_record_type (struct type *type0, struct ui_file *stream, int show,
		   int level, const struct type_print_options *flags)
{
  struct type *parent_type;
  struct type *type;

  type = ada_find_parallel_type (type0, "___XVE");
  if (type == NULL)
    type = type0;

  parent_type = ada_parent_type (type);
  if (ada_type_name (parent_type) != NULL)
    {
      const char *parent_name = decoded_type_name (parent_type);

      /* If we fail to decode the parent type name, then use the parent
	 type name as is.  Not pretty, but should never happen except
	 when the debugging info is incomplete or incorrect.  This
	 prevents a crash trying to print a NULL pointer.  */
      if (parent_name == NULL)
	parent_name = ada_type_name (parent_type);
      fprintf_filtered (stream, "new %s with record", parent_name);
    }
  else if (parent_type == NULL && ada_is_tagged_type (type, 0))
    fprintf_filtered (stream, "tagged record");
  else
    fprintf_filtered (stream, "record");

  if (show < 0)
    fprintf_filtered (stream, " ... end record");
  else
    {
      int flds;

      flds = 0;
      if (parent_type != NULL && ada_type_name (parent_type) == NULL)
	flds += print_record_field_types (parent_type, parent_type,
					  stream, show, level, flags);
      flds += print_record_field_types (type, type, stream, show, level,
					flags);

      if (flds > 0)
	fprintf_filtered (stream, "\n%*send record", level, "");
      else if (flds < 0)
	fprintf_filtered (stream, _(" <incomplete type> end record"));
      else
	fprintf_filtered (stream, " null; end record");
    }
}

/* Print the unchecked union type TYPE in something resembling Ada
   format on STREAM.  LEVEL is the recursion (indentation) level
   in case the element type itself has nested structure, and SHOW is the
   number of levels of internal structure to show (see ada_print_type).  */
static void
print_unchecked_union_type (struct type *type, struct ui_file *stream,
			    int show, int level,
			    const struct type_print_options *flags)
{
  if (show < 0)
    fprintf_filtered (stream, "record (?) is ... end record");
  else if (TYPE_NFIELDS (type) == 0)
    fprintf_filtered (stream, "record (?) is null; end record");
  else
    {
      int i;

      fprintf_filtered (stream, "record (?) is\n%*scase ? is", level + 4, "");

      for (i = 0; i < TYPE_NFIELDS (type); i += 1)
	{
	  fprintf_filtered (stream, "\n%*swhen ? =>\n%*s", level + 8, "",
			    level + 12, "");
	  ada_print_type (TYPE_FIELD_TYPE (type, i),
			  TYPE_FIELD_NAME (type, i),
			  stream, show - 1, level + 12, flags);
	  fprintf_filtered (stream, ";");
	}

      fprintf_filtered (stream, "\n%*send case;\n%*send record",
			level + 4, "", level, "");
    }
}



/* Print function or procedure type TYPE on STREAM.  Make it a header
   for function or procedure NAME if NAME is not null.  */

static void
print_func_type (struct type *type, struct ui_file *stream, const char *name,
		 const struct type_print_options *flags)
{
  int i, len = TYPE_NFIELDS (type);

  if (TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_VOID)
    fprintf_filtered (stream, "procedure");
  else
    fprintf_filtered (stream, "function");

  if (name != NULL && name[0] != '\0')
    fprintf_filtered (stream, " %s", name);

  if (len > 0)
    {
      fprintf_filtered (stream, " (");
      for (i = 0; i < len; i += 1)
	{
	  if (i > 0)
	    {
	      fputs_filtered ("; ", stream);
	      wrap_here ("    ");
	    }
	  fprintf_filtered (stream, "a%d: ", i + 1);
	  ada_print_type (TYPE_FIELD_TYPE (type, i), "", stream, -1, 0,
			  flags);
	}
      fprintf_filtered (stream, ")");
    }

  if (TYPE_CODE (TYPE_TARGET_TYPE (type)) != TYPE_CODE_VOID)
    {
      fprintf_filtered (stream, " return ");
      ada_print_type (TYPE_TARGET_TYPE (type), "", stream, 0, 0, flags);
    }
}


/* Print a description of a type TYPE0.
   Output goes to STREAM (via stdio).
   If VARSTRING is a non-empty string, print as an Ada variable/field
       declaration.
   SHOW+1 is the maximum number of levels of internal type structure
      to show (this applies to record types, enumerated types, and
      array types).
   SHOW is the number of levels of internal type structure to show
      when there is a type name for the SHOWth deepest level (0th is
      outer level).
   When SHOW<0, no inner structure is shown.
   LEVEL indicates level of recursion (for nested definitions).  */

void
ada_print_type (struct type *type0, const char *varstring,
		struct ui_file *stream, int show, int level,
		const struct type_print_options *flags)
{
  struct type *type = ada_check_typedef (ada_get_base_type (type0));
  char *type_name = decoded_type_name (type0);
  int is_var_decl = (varstring != NULL && varstring[0] != '\0');

  if (type == NULL)
    {
      if (is_var_decl)
	fprintf_filtered (stream, "%.*s: ",
			  ada_name_prefix_len (varstring), varstring);
      fprintf_filtered (stream, "<null type?>");
      return;
    }

  if (show > 0)
    type = ada_check_typedef (type);

  if (is_var_decl && TYPE_CODE (type) != TYPE_CODE_FUNC)
    fprintf_filtered (stream, "%.*s: ",
		      ada_name_prefix_len (varstring), varstring);

  if (type_name != NULL && show <= 0 && !ada_is_aligner_type (type))
    {
      fprintf_filtered (stream, "%.*s",
			ada_name_prefix_len (type_name), type_name);
      return;
    }

  if (ada_is_aligner_type (type))
    ada_print_type (ada_aligned_type (type), "", stream, show, level, flags);
  else if (ada_is_constrained_packed_array_type (type)
	   && TYPE_CODE (type) != TYPE_CODE_PTR)
    print_array_type (type, stream, show, level, flags);
  else
    switch (TYPE_CODE (type))
      {
      default:
	fprintf_filtered (stream, "<");
	c_print_type (type, "", stream, show, level, flags);
	fprintf_filtered (stream, ">");
	break;
      case TYPE_CODE_PTR:
      case TYPE_CODE_TYPEDEF:
	fprintf_filtered (stream, "access ");
	ada_print_type (TYPE_TARGET_TYPE (type), "", stream, show, level,
			flags);
	break;
      case TYPE_CODE_REF:
	fprintf_filtered (stream, "<ref> ");
	ada_print_type (TYPE_TARGET_TYPE (type), "", stream, show, level,
			flags);
	break;
      case TYPE_CODE_ARRAY:
	print_array_type (type, stream, show, level, flags);
	break;
      case TYPE_CODE_BOOL:
	fprintf_filtered (stream, "(false, true)");
	break;
      case TYPE_CODE_INT:
	if (ada_is_fixed_point_type (type))
	  print_fixed_point_type (type, stream);
	else
	  {
	    const char *name = ada_type_name (type);

	    if (!ada_is_range_type_name (name))
	      fprintf_filtered (stream, _("<%d-byte integer>"),
				TYPE_LENGTH (type));
	    else
	      {
		fprintf_filtered (stream, "range ");
		print_range_type (type, stream);
	      }
	  }
	break;
      case TYPE_CODE_RANGE:
	if (ada_is_fixed_point_type (type))
	  print_fixed_point_type (type, stream);
	else if (ada_is_modular_type (type))
	  fprintf_filtered (stream, "mod %s", 
			    int_string (ada_modulus (type), 10, 0, 0, 1));
	else
	  {
	    fprintf_filtered (stream, "range ");
	    print_range (type, stream);
	  }
	break;
      case TYPE_CODE_FLT:
	fprintf_filtered (stream, _("<%d-byte float>"), TYPE_LENGTH (type));
	break;
      case TYPE_CODE_ENUM:
	if (show < 0)
	  fprintf_filtered (stream, "(...)");
	else
	  print_enum_type (type, stream);
	break;
      case TYPE_CODE_STRUCT:
	if (ada_is_array_descriptor_type (type))
	  print_array_type (type, stream, show, level, flags);
	else if (ada_is_bogus_array_descriptor (type))
	  fprintf_filtered (stream,
			    _("array (?) of ? (<mal-formed descriptor>)"));
	else
	  print_record_type (type, stream, show, level, flags);
	break;
      case TYPE_CODE_UNION:
	print_unchecked_union_type (type, stream, show, level, flags);
	break;
      case TYPE_CODE_FUNC:
	print_func_type (type, stream, varstring, flags);
	break;
      }
}

/* Implement the la_print_typedef language method for Ada.  */

void
ada_print_typedef (struct type *type, struct symbol *new_symbol,
                   struct ui_file *stream)
{
  type = ada_check_typedef (type);
  ada_print_type (type, "", stream, 0, 0, &type_print_raw_options);
  fprintf_filtered (stream, "\n");
}
@


1.47
log
@	* ada-lang.c (user_select_syms, ada_print_subexp): Pass flags
	to type-printing functions.
	* ada-lang.h (ada_print_type): Add argument.
	* ada-typeprint.c (print_array_type, print_variant_clauses,
	print_variant_part, print_selected_record_field_types,
	print_record_field_types, print_unchecked_union_type,
	print_func_type, ada_print_type): Add flags argument.
	(ada_print_typedef): Update.
	* c-exp.y (OPERATOR conversion_type_id): Update.
	* c-lang.h (c_print_type, c_type_print_base): Update.
	* c-typeprint.c (c_print_type, c_type_print_varspec_prefix,
	c_type_print_modifier, c_type_print_args,
	c_type_print_varspec_suffix, c_type_print_base): Add flags
	argument.
	* cp-valprint.c (cp_print_class_member): Update.
	* dwarf2read.c (dwarf2_compute_name): Update.
	* f-lang.h (f_print_type): Add argument.
	* f-typeprint.c (f_print_type): Add flags argument.
	* gnu-v3-abi.c (gnuv3_print_method_ptr): Update.
	* go-lang.h (go_print_type): Add argument.
	* go-typeprint.c (go_print_type): Add flags argument.
	* jv-lang.h (java_print_type): Add argument.
	* jv-typeprint.c (java_type_print_base, java_print_type): Add
	flags argument.
	* language.c (unk_lang_print_type): Add flags argument.
	* language.h (struct language_defn) <la_print_type>: Add flags
	argument.
	(LA_PRINT_TYPE): Likewise.
	* m2-lang.h (m2_print_type): Add argument.
	* m2-typeprint.c (m2_print_type, m2_range, m2_typedef,
	m2_array, m2_pointer, m2_ref, m2_procedure, m2_long_set,
	m2_unbounded_array, m2_record_fields): Add flags argument.
	* p-lang.h (pascal_print_type, pascal_type_print_base,
	pascal_type_print_varspec_prefix): Add argument.
	* p-typeprint.c (pascal_print_type,
	pascal_type_print_varspec_prefix, pascal_print_func_args,
	pascal_type_print_varspec_suffix, pascal_type_print_base): Add
	flags argument.
	* symmisc.c (print_symbol): Update.
	* typeprint.c (type_print_raw_options, default_ptype_flags):
	New globals.
	(type_print): Update.
	* typeprint.h (struct type_print_options): New.
	(type_print_raw_options): Declare.
	(c_type_print_varspec_suffix, c_type_print_args): Add argument.
@
text
@d2 1
a2 2
   Copyright (C) 1986, 1988-1989, 1991, 1997-2004, 2007-2012 Free
   Software Foundation, Inc.
@


1.46
log
@gdb/
	PR symtab/7259:
	* ada-exp.y (convert_char_literal): Use TYPE_FIELD_ENUMVAL.
	* ada-lang.c (ada_discrete_type_high_bound)
	(ada_discrete_type_low_bound): Use TYPE_FIELD_ENUMVAL for
	TYPE_CODE_ENUM.
	(ada_identical_enum_types_p): Use TYPE_FIELD_ENUMVAL.
	(pos_atr, value_val_atr): Use TYPE_FIELD_ENUMVAL for TYPE_CODE_ENUM.
	* ada-typeprint.c (print_enum_type): Change variable lastval to LONGEST.
	Use TYPE_FIELD_ENUMVAL.
	* ada-valprint.c (print_optional_low_bound, ada_print_scalar)
	(ada_val_print_1): Use TYPE_FIELD_ENUMVAL for TYPE_CODE_ENUM.
	* c-typeprint.c (c_type_print_base): Move variable lastval to inner
	block, change it to LONGEST.  Use TYPE_FIELD_ENUMVAL for
	TYPE_CODE_ENUM.
	* coffread.c (coff_read_enum_type): Use SET_FIELD_ENUMVAL.
	* dwarf2read.c (process_enumeration_scope): Likewise.
	* gdb-gdb.py (TypeFlagsPrinter): Use field.enumval instead of
	field.bitpos.
	(class StructMainTypePrettyPrinter): Support also
	FIELD_LOC_KIND_ENUMVAL.
	* gdbtypes.c (get_discrete_bounds): Use TYPE_FIELD_ENUMVAL for
	TYPE_CODE_ENUM.
	(recursive_dump_type): Use TYPE_FIELD_ENUMVAL for TYPE_CODE_ENUM.
	(copy_type_recursive): Support also FIELD_LOC_KIND_ENUMVAL.
	* gdbtypes.h (enum field_loc_kind): New FIELD_LOC_KIND_ENUMVAL.
	(struct main_type.flds_bnds.fields.loc): Adjust bitpos comment.  New
	field enumval.
	(struct main_type.flds_bnds.bields): Adjust loc_kind and bitsize to
	accommodate enumval.
	(struct call_site): Adjust loc_kind to accommodate enumval.
	(FIELD_ENUMVAL, FIELD_ENUMVAL_LVAL, SET_FIELD_ENUMVAL)
	(TYPE_FIELD_ENUMVAL): New macros.
	* m2-typeprint.c (m2_enum): Use TYPE_FIELD_ENUMVAL.
	* mdebugread.c (parse_symbol): Use TYPE_FIELD_ENUMVAL for
	TYPE_CODE_ENUM.
	* p-typeprint.c (pascal_type_print_base): Likewise.
	* python/lib/gdb/printing.py (class FlagEnumerationPrinter): Use
	enumval.
	* python/lib/gdb/types.py (make_enum_dict): Likewise.
	* python/py-type.c (convert_field): New variable addrstring.  Use
	TYPE_FIELD_ENUMVAL for TYPE_CODE_ENUM.
	(check_types_equal): Support also FIELD_LOC_KIND_ENUMVAL.
	* stabsread.c (read_enum_type): Use SET_FIELD_ENUMVAL.
	* typepint.c (print_type_scalar): Use TYPE_FIELD_ENUMVAL for
	TYPE_CODE_ENUM.
	* valprint.c (generic_val_print): Likewise.

gdb/testsuite/
	PR symtab/7259:
	* gdb.base/enumval.c: New test case.
	* gdb.base/enumval.exp: New test case.
	* gdb.python/py-type.exp (test_enums): Use field.enumval instead of
	field.bitpos.
@
text
@d43 2
a44 1
					      struct ui_file *, int, int);
d47 2
a48 1
				     struct ui_file *, int, int);
d50 2
a51 1
static void print_array_type (struct type *, struct ui_file *, int, int);
d330 1
a330 1
		  int level)
d398 1
a398 1
		  show == 0 ? 0 : show - 1, level + 1);
d494 2
a495 1
		       int show, int level)
d521 2
a522 1
					outer_type, stream, show, level + 4) 
d528 1
a528 1
					   stream, show, level + 4);
d542 2
a543 1
		    struct ui_file *stream, int show, int level)
d549 1
a549 1
			 level + 4);
d565 2
a566 1
				   struct ui_file *stream, int show, int level)
d583 1
a583 1
					  stream, show, level);
d586 1
a586 1
	  print_variant_part (type, i, outer_type, stream, show, level);
d595 1
a595 1
			  stream, show - 1, level + 4);
d608 2
a609 1
			  struct ui_file *stream, int show, int level)
d613 1
a613 1
					    stream, show, level);
d623 1
a623 1
		   int level)
d659 3
a661 2
					  stream, show, level);
      flds += print_record_field_types (type, type, stream, show, level);
d678 2
a679 1
			    int show, int level)
d697 1
a697 1
			  stream, show - 1, level + 12);
d712 2
a713 1
print_func_type (struct type *type, struct ui_file *stream, const char *name)
d736 2
a737 1
	  ada_print_type (TYPE_FIELD_TYPE (type, i), "", stream, -1, 0);
d745 1
a745 1
      ada_print_type (TYPE_TARGET_TYPE (type), "", stream, 0, 0);
d765 2
a766 1
		struct ui_file *stream, int show, int level)
d796 1
a796 1
    ada_print_type (ada_aligned_type (type), "", stream, show, level);
d799 1
a799 1
    print_array_type (type, stream, show, level);
d805 1
a805 1
	c_print_type (type, "", stream, show, level);
d811 2
a812 1
	ada_print_type (TYPE_TARGET_TYPE (type), "", stream, show, level);
d816 2
a817 1
	ada_print_type (TYPE_TARGET_TYPE (type), "", stream, show, level);
d820 1
a820 1
	print_array_type (type, stream, show, level);
d865 1
a865 1
	  print_array_type (type, stream, show, level);
d870 1
a870 1
	  print_record_type (type, stream, show, level);
d873 1
a873 1
	print_unchecked_union_type (type, stream, show, level);
d876 1
a876 1
	print_func_type (type, stream, varstring);
d888 1
a888 1
  ada_print_type (type, "", stream, 0, 0);
@


1.45
log
@	* gdbtypes.h (struct main_type): Change type of name,tag_name,
	and fields.name members from char * to const char *.  All uses updated.
	(struct cplus_struct_type): Change type of fn_fieldlists.name member
	from char * to const char *.  All uses updated.
	(type_name_no_tag): Update.
	(lookup_unsigned_typename, lookup_signed_typename): Update.
	* gdbtypes.c (type_name_no_tag): Change result type
	from char * to const char *.  All callers updated.
	(lookup_unsigned_typename, lookup_signed_typename): Change type of
	name parameter from char * to const char *.
	* symtab.h (struct cplus_specific): Change type of demangled_name
	member from char * to const char *.  All uses updated.
	(struct general_symbol_info): Change type of name and
	mangled_lang.demangled_name members from char * to const char *.
	All uses updated.
	(symbol_get_demangled_name, symbol_natural_name): Update.
	(symbol_demangled_name, symbol_search_name): Update.
	* symtab.c (symbol_get_demangled_name): Change result type
	from char * to const char *.  All callers updated.
	(symbol_natural_name, symbol_demangled_name): Ditto.
	(symbol_search_name): Ditto.
	(completion_list_add_name): Change type of symname,sym_text,
	text,word parameters from char * to const char *.
	(completion_list_objc_symbol): Change type of sym_text,
	text,word parameters from char * to const char *.
	* ada-lang.c (find_struct_field): Change type of name parameter
	from char * to const char *.
	(encoded_ordered_before): Similarly for N0,N1 parameters.
	(old_renaming_is_invisible): Similarly for function_name parameter.
	(ada_type_name): Change result type from char * to const char *.
	All callers updated.
	* ada-lang.h (ada_type_name): Update.
	* buildsym.c (hashname): Change type of name parameter
	from char * to const char *.
	* buildsym.h (hashname): Update.
	* dbxread.c (end_psymtab): Change type of include_list parameter
	from char ** to const char **.
	* dwarf2read.c (determine_prefix): Change result type
	from char * to const char *.  All callers updated.
	* f-lang.c (find_common_for_function): Change type of name, funcname
	parameters from char * to const char *.
	* f-lang.c (find_common_for_function): Update.
	* f-valprint.c (list_all_visible_commons): Change type of funcname
	parameters from char * to const char *.
	* gdbarch.sh (static_transform_name): Change type of name parameter
	and result from char * to const char *.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* i386-sol2-tdep.c (i386_sol2_static_transform_name): Change type
	of name parameter from char * to const char *.
	* jv-lang.c (java_primitive_type_from_name): Ditto.
	(java_demangled_signature_length): Similarly for signature parameter.
	(java_demangled_signature_copy): Ditto.
	(java_demangle_type_signature): Ditto.
	* jv-lang.h (java_primitive_type_from_name): Update.
	(java_demangle_type_signature): Update.
	* objc-lang.c (specialcmp): Change type of a,b parameters
	from char * to const char *.
	* p-lang.c (is_pascal_string_type): Change type of arrayname parameter
	from char * to const char *.  All callers updated.
	* p-lang.h (is_pascal_string_type): Update.
	* solib-frv.c (find_canonical_descriptor_in_load_object): Change type
	of name parameter from char * to const char *.
	* sparc-sol2-tdep.c (sparc_sol2_static_transform_name): Ditto.
	* utils.c (fprintf_symbol_filtered): Ditto.
	* defs.h (fprintf_symbol_filtered): Update.
	* sparc-tdep.h (sparc_sol2_static_transform_name): Update.
	* stabsread.h (end_psymtab): Update.
	* stack.c (find_frame_funname): Change type of funname parameter
	from char ** to const char **.
	* stack.h (find_frame_funname): Update.
	* typeprint.c (type_print): Change type of varstring parameter
	from char * to const char *.
	* value.h (type_print): Update.
	* xcoffread.c (xcoff_start_psymtab): Change type of filename parameter
	from char * to const char *.  All callers updated.
	(xcoff_end_psymtab): Change type of include_list parameter
	from char ** to const char **.  All callers updated.
	(swap_sym): Similarly for name parameter.  All callers updated.
	* coffread.c (patch_type): Add (char*) cast to xfree parameter.
	Use xstrdup.
	(process_coff_symbol): Use xstrdup.
	* stabsread.c (stabs_method_name_from_physname): Renamed from
	update_method_name_from_physname.  Change result type from void
	to char *.  All callers updated.
	(read_member_functions): In has_destructor case, store name in objfile
	obstack instead of malloc space.  In !has_stub case, fix mem leak.
@
text
@d277 2
a278 1
  int i, lastval;
d291 1
a291 1
      if (lastval != TYPE_FIELD_BITPOS (type, i))
d293 3
a295 2
	  fprintf_filtered (stream, " => %d", TYPE_FIELD_BITPOS (type, i));
	  lastval = TYPE_FIELD_BITPOS (type, i);
@


1.44
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d79 1
a79 1
      char *raw_name = ada_type_name (type);
d226 1
a226 1
  char *name;
d228 1
a228 1
  char *subtype_info;
d813 1
a813 1
	    char *name = ada_type_name (type);
@


1.43
log
@crash when printing type of tagged type

If the debugging info is incorrect or incomplete, printing the
type description of a variable that's a variant tagged type can
trigger a crash.  The crash comes from us trying print a NULL
string which was supposed to be the parent type name.

We observed this behavior on bareboard targets where a-tags is
not always linked in, as is the case for native platforms, for
instance. Coupled with -feliminate-unused-debug-types, this leads
to GDB being unable to find type ada__tags__type_specific_data,
without which printing the type description above cannot be done
acurately.  There is an easy workaround for this limitation,
which is to compile at least 1 unit with
-fno-eliminate-unused-debug-types, but GDB should also be made
resilient to this situation.

gdb/ChangeLog:

        * ada-typeprint.c (print_record_type): If unable to decode
        the name of the parent type, use the encoded name.
@
text
@d2 2
a3 2
   Copyright (C) 1986, 1988, 1989, 1991, 1997, 1998, 1999, 2000, 2001, 2002,
   2003, 2004, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
@


1.43.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 2
a3 2
   Copyright (C) 1986, 1988-1989, 1991, 1997-2004, 2007-2012 Free
   Software Foundation, Inc.
@


1.42
log
@Fix printing address of packed array

When trying to print the address of a non-packed array, GDB
correctly prints the type name and address:

    (gdb) print &var
    $2 = (access pa.var) 0xbffff1d8

However, it is behaving differently when dealing with a packed
array:

    (gdb) p &var
    (access array (4 .. 8) of boolean <packed: 1-bit elements>) (4 =>
    false, false, false, true, false)

The type description isn't all that bad, but GDB shouldn't be
printing the array value!

This patch fixes the `print` and `ptype` command on packed and
non-packed array.  It also fixes a gdb.ada test to match with
the new ouput.

gdb/ChangeLog (Jean-Charles Delay):

        * ada-typeprint.c (ada_print_type): Fix both PAD type and
        pointer to constrained packed array type output.
        * ada-valprint.c (ada_val_print_1): Fix pointer to constrained
        packed array output.

gdb/testsuite/ChangeLog (Jean-Charles Delay):

        * gdb.ada/packed_array.exp: Fix expected outout.
@
text
@d624 11
a634 2
    fprintf_filtered (stream, "new %s with record",
		      decoded_type_name (parent_type));
@


1.41
log
@Fix ada array bounds display

Array bounds were not correctly displayed when the SHOW parameter of
print_type functions is set to -1.  This shows up in the following
type of situation, where we have a declaration as follow:

    Anon_Array_Int_Obj : array (1..10) of Integer := (others => 8);

In GDB/MI mode, trying to print the type info for our array object
yields:

    (gdb) -var-create ai 0 Anon_Array_Int_Obj
    (gdb) -var-info-type ai
    ^done,type="array (...) of integer"

The actual bounds are missing.  Contrast this with what happens
when in GDB/CLI mode:

    (gdb) ptype Anon_Array_Int_Obj
    type = array (1 .. 10) of integer

This patch fixes array type printing accordingly. And as it turns
out, it also improves the output for one of the tests already present,
so it shows that it's not just the GDB/MI mode that's affected.

gdb/ChangeLog (Jean-Charles Delay):

	* ada-typeprint.c (print_array_type): removed if condition on show
	being negative for bounds printing.

gdb/testsuite/ChangeLog (Jean-Charles Delay):

	* gdb.ada/packed_array.exp: fixed expected output.
@
text
@d764 1
a764 1
  if (type_name != NULL && show <= 0)
d773 3
a775 12
  else if (ada_is_constrained_packed_array_type (type))
    {
      if (TYPE_CODE (type) == TYPE_CODE_PTR)
        {
          fprintf_filtered (stream, "access ");
          print_array_type (TYPE_TARGET_TYPE (type), stream, show, level);
        }
      else
        {
          print_array_type (type, stream, show, level);
        }
    }
@


1.40
log
@run copyright.sh for 2011.
@
text
@d343 1
a343 3
  if (show < 0)
    fprintf_filtered (stream, "...");
  else
d345 2
a346 4
      if (ada_is_simple_array_type (type))
	{
	  struct type *range_desc_type;
	  struct type *arr_type;
d348 2
a349 2
	  range_desc_type = ada_find_parallel_type (type, "___XA");
	  ada_fixup_array_indexes_type (range_desc_type);
d351 5
a355 2
	  bitsize = 0;
	  if (range_desc_type == NULL)
d357 5
a361 26
	      for (arr_type = type; TYPE_CODE (arr_type) == TYPE_CODE_ARRAY;
		   arr_type = TYPE_TARGET_TYPE (arr_type))
		{
		  if (arr_type != type)
		    fprintf_filtered (stream, ", ");
		  print_range (TYPE_INDEX_TYPE (arr_type), stream);
		  if (TYPE_FIELD_BITSIZE (arr_type, 0) > 0)
		    bitsize = TYPE_FIELD_BITSIZE (arr_type, 0);
		}
	    }
	  else
	    {
	      int k;

	      n_indices = TYPE_NFIELDS (range_desc_type);
	      for (k = 0, arr_type = type;
		   k < n_indices;
		   k += 1, arr_type = TYPE_TARGET_TYPE (arr_type))
		{
		  if (k > 0)
		    fprintf_filtered (stream, ", ");
		  print_range_type (TYPE_FIELD_TYPE (range_desc_type, k),
				    stream);
		  if (TYPE_FIELD_BITSIZE (arr_type, 0) > 0)
		    bitsize = TYPE_FIELD_BITSIZE (arr_type, 0);
		}
d366 1
a366 1
	  int i, i0;
d368 12
a379 2
	  for (i = i0 = ada_array_arity (type); i > 0; i -= 1)
	    fprintf_filtered (stream, "%s<>", i == i0 ? "" : ", ");
d382 7
@


1.39
log
@[Ada] do not print arrays as array pointers

This patch enhances the debugger to distinguish between fat pointers
that represent either: array types, or array access types.  In the latter
case, the object/type is encoded as a typedef type pointing to the fat
pointer.

The first part of the change is to adjust ada_check_typedef to avoid
stripping the typedef layer when it points to a fat pointer.  The rest
of the patch is adjustments required in various places to deal with
the fact that the type is uses might now be a typedef.

gdb/ChangeLog:

        * ada-lang.h (ada_coerce_to_simple_array): Add declaration.
        * ada-lang.c (ada_typedef_target_type): New function.
        (desc_base_type): Add handling of fat pointer typedefs.
        (ada_coerce_to_simple_array): Make non-static.
        (decode_packed_array_bitsize): Add handling of fat pointer typedefs.
        Add assertion.
        (ada_template_to_fixed_record_type_1, ada_to_fixed_type)
        (ada_check_typedef): Add handling of fat pointer typedefs.
        (ada_evaluate_subexp) [OP_FUNCALL]: Likewise.
        * ada-typeprint.c (ada_print_type): Add handling of fat pointer
        typedefs.
        * ada-valprint.c (ada_val_print_1): Convert fat pointers that are not
        array accesses to simple arrays rather than simple array pointers.
        (ada_value_print): In the case of array descriptors, do not print
        the value type description unless it is an array access.

gdb/testsuite/ChangeLog:

        * gdb.ada/lang_switch.exp: Correct expected parameter value.

gdb/doc/ChangeLog:

        * gdb.texinfo (Ada Glitches): Remove paragraph describing the
        occasional case where the debugger prints an array address
        instead of the array itself.
@
text
@d3 1
a3 1
   2003, 2004, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
@


1.38
log
@Minor comment reformatting in ada-typeprint.c

gdb/ChangeLog:

        * ada-typeprint.c (print_array_type): Fix formatting in comment.
        (print_selected_record_field_types): Fix formatting in function
        documentation.
@
text
@d799 1
@


1.37
log
@Have ptype handle types declared pragma Unchecked_Variants.

When a type is marked with pragma Unchecked_Variants, ptype did not print
variants having a single component, since the compiler produces incorrect
debugging output for such cases.  With this patch, we special-case these
components so that they print.

Changelog:

    * gdb/ada-typeprint.c (print_selected_record_field_types): New function,
    incorporating and generalizing print_record_field_types.
    (print_record_field_types): Change return value and update comment.
    Re-implement using print_selected_record_field_types.
    (print_choices): Print "=>" here.
    Handle case of unencoded variant branch.
    (print_variant_clauses): Reformat comment.
    Special-case unencoded variant branch.
@
text
@d405 1
a405 1
   values. Returns non-zero if the field is an encoding of
d408 1
a408 2
   in types annotated with pragma Unchecked_Variant.)
 */
d555 1
a555 1
   not print parent type information of TYPE. Returns 0 if no fields
@


1.36
log
@gdb/
	* ada-lang.h (ada_print_type): Make varstring const.
	* ada-typeprint.c (print_func_type): Make name const.
	(ada_print_type): Make varstring const.
	* c-lang.h (c_print_type): Make varstring const.
	* c-typeprint.c (c_print_type): Likewise.
	* f-lang.h (f_print_type): Likewise.
	* f-typeprint.c (f_print_type): Likewise.
	* jv-lang.h (java_print_type): Likewise.
	* jv-typeprint.c (java_print_type): Likewise.
	* language.c (unk_lang_print_type): Likewise.
	* language.h (struct language_defn) <la_print_type>: Likewise.
	* m2-lang.h (m2_print_type): Likewise.
	* m2-typeprint.c (m2_print_type): Likewise.
	* p-lang.h (pascal_print_type): Likewise.
	* p-typeprint.c (pascal_print_type): Likewise.
@
text
@d41 4
d50 2
a51 2
static void print_choices (struct type *, int, struct ui_file *,
			   struct type *);
d404 6
a409 1
   STREAM, assuming that VAL_TYPE (if non-NULL) is the type of the values.  */
d411 1
a411 1
static void
d435 5
a439 1
	  return;
d480 2
a481 2
  fprintf_filtered (stream, "??");

d484 7
a490 8
/* Assuming that field FIELD_NUM of TYPE is a VARIANTS field whose
   discriminant is contained in OUTER_TYPE, print its variants on STREAM.
   LEVEL is the recursion
   (indentation) level, in case any of the fields themselves have
   nested structure, and SHOW is the number of levels of internal structure
   to show (see ada_print_type).  For this purpose, fields nested in a
   variant part are taken to be at the same level as the fields
   immediately outside the variant part.  */
d518 10
a527 5
      print_choices (var_type, i, stream, discr_type);
      fprintf_filtered (stream, " =>");
      if (print_record_field_types (TYPE_FIELD_TYPE (var_type, i),
				    outer_type, stream, show, level + 4) <= 0)
	fprintf_filtered (stream, " null;");
d551 8
a558 8
/* Print a description on STREAM of the fields in record type TYPE, whose
   discriminants are in OUTER_TYPE.  LEVEL is the recursion (indentation)
   level, in case any of the fields themselves have nested structure,
   and SHOW is the number of levels of internal structure to show
   (see ada_print_type).  Does not print parent type information of TYPE.
   Returns 0 if no fields printed, -1 for an incomplete type, else > 0.
   Prints each field beginning on a new line, but does not put a new line at
   end.  */
d561 3
a563 2
print_record_field_types (struct type *type, struct type *outer_type,
			  struct ui_file *stream, int show, int level)
d565 1
a565 1
  int len, i, flds;
a567 1
  len = TYPE_NFIELDS (type);
d569 1
a569 1
  if (len == 0 && TYPE_STUB (type))
d572 1
a572 1
  for (i = 0; i < len; i += 1)
d600 13
@


1.35
log
@2010-05-18  Michael Snyder  <msnyder@@vmware.com>

	* ada-lang.c: White space.
	* ada-typeprint.c: White space.
	* ada-valprint.c: White space.
	* addrmap.c: White space.
	* auxv.c: White space.
	* ax-gdb.c: White space.
@
text
@d667 1
a667 1
print_func_type (struct type *type, struct ui_file *stream, char *name)
d717 2
a718 2
ada_print_type (struct type *type0, char *varstring, struct ui_file *stream,
		int show, int level)
@


1.34
log
@Avoid global lookup when decoding XA type.

This patch enhances GDB to take advantage of a recent change in the GNAT
encoding regarding XA types.  A detailed description of the logic has
been added at the start of ada_fixup_array_indexes_type to give the
context behind this enhancement.

2010-05-17  Joel Brobecker  <brobecker@@adacore.com>

        * ada-lang.c (to_fixed_range_type): The the raw index type as
        argument instead of the raw type name.  Remove orig_type parameter.
        Update calls throughout.
        (ada_fixup_array_indexes_type): New function.
        (ada_array_bound_from_type): Add call to ada_fixup_array_indexes_type.
        * ada-lang.h (ada_fixup_array_indexes_type): Add declaration.
        * ada-typeprint.c (print_range_type): Renames print_range_type_named.
        Remove name parameter.
        (print_array_type): Add call to ada_fixup_array_indexes_type.
        Update calls to print_range_type.
        (ada_print_type): Update calls to print_range_type.
@
text
@d154 1
d367 1
d385 1
d441 1
d450 1
d789 1
@


1.33
log
@"unsupported language" error in info types when using Ada.

This implements a rudimentary version of the la_print_typedef method
for Ada.  Ada usually does not use typedefs, but there is one exception:
pointers to unconstrained arrays.  Without this patch, we sometimes
get an error in the "info types" output:

    (gdb) info types new_integer_type
    All types matching regular expression "new_integer_type":

    File foo.adb:
    Language not supported.

For now, we treat the typedef as if it did not exist - using the
underlying type instead.  This is the right thing to do for most cases,
the only exception being access to array types.  Since we already have
a general issue in handling these pointers (we confuse them with fat
pointers), we will enhance ada_print_typedef to handle these pointers
at the same time we address the general issue.

gdb/ChangeLog:

        * ada-typeprint.c (ada_print_typedef): New function.
        * ada-lang.h (ada_print_typedef): Add declaration.
        * ada-lang.c (ada_language_defn): set la_print_typdef field
        to ada_print_typedef.

gdb/testsuite/ChangeLog:

        * info_types.c, info_types.exp: New files.

Tested on x86_64-linux.
@
text
@d58 1
a58 1
static void print_range_type_named (char *, struct type *, struct ui_file *);
d215 2
a216 2
/* Print the range type named NAME.  If symbol lookup fails, fall back
   to ORIG_TYPE as base type.  */
d219 1
a219 2
print_range_type_named (char *name, struct type *orig_type,
			struct ui_file *stream)
d221 1
a221 1
  struct type *raw_type = ada_find_any_type (name);
d225 3
a227 2
  if (raw_type == NULL)
    raw_type = orig_type;
d344 1
a344 2
	  struct type *range_desc_type =
	    ada_find_parallel_type (type, "___XA");
d347 3
d373 2
a374 3
		  print_range_type_named (TYPE_FIELD_NAME
					  (range_desc_type, k),
					  TYPE_INDEX_TYPE (arr_type), stream);
d790 1
a790 1
		print_range_type_named (name, type, stream);
@


1.32
log
@Get rid of support for VAX Floats.

        * ada-lang.h (ada_is_vax_floating_type, ada_vax_float_type_suffix)
        (ada_vax_float_print_function): Delete.
        * ada-lang.c (ada_is_vax_floating_type, ada_vax_float_type_suffix)
        (ada_vax_float_print_function): Delete.
        * ada-typeprint.c (print_vax_floating_point_type): Delete.
        (ada_print_type): Remove support for VAX floats.
        * ada-valprint.c (ada_val_print_1): Remove support for VAX floats.
@
text
@d831 11
@


1.31
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@a312 9
/* Print representation of special VAX floating-point type TYPE on STREAM.  */

static void
print_vax_floating_point_type (struct type *type, struct ui_file *stream)
{
  fprintf_filtered (stream, "<float format %c>",
		    ada_vax_float_type_suffix (type));
}

a779 2
	else if (ada_is_vax_floating_type (type))
	  print_vax_floating_point_type (type, stream);
a795 2
	else if (ada_is_vax_floating_type (type))
	  print_vax_floating_point_type (type, stream);
@


1.30
log
@* dwarf2read.c (struct attribute): Increase sizes of unsnd and snd
fields to allow larger integer sizes.
(read_subrange_type): Increase size of bound values.
Add logic to determine signedness based on base-type size, signedness.
(read_attribute_value): Change format for bad byte size in message.
(read_8_bytes): Increase size of result type.
(dump_die_shallow): Change format for value.
(dwarf2_get_attr_constant_value): Increase size of return type.
Correct comment.
* gdbtypes.c (create_range_type): Change API to increase size of
bounds. struct field -> union field.
Always take signedness from base type.
(check_typedef): Use new API for TYPE_LOW_BOUND, TYPE_HIGH_BOUND.
(recursive_dump_type, copy_type_recursive): Adjust to new
representation of range types.
* gdbtypes.h (fields_or_bounds): New union containing struct field and
new struct range_bounds, used for range types.
(TYPE_RANGE_DATA): New macro to access range_bounds member.
(TYPE_LOW_BOUND, TYPE_HIGH_BOUND): Represent with new TYPE_RANGE_DATA.
(TYPE_LOW_BOUND_UNDEFINED, TYPE_HIGH_BOUND_UNDEFINED): New macros,
taking over the job of TYPE_FIELD_ARTIFICIAL for range bounds.
(SET_TYPE_LOW_BOUND, SET_TYPE_HIGH_BOUND, SET_TYPE_LOW_BOUND_DEFINED)
(SET_TYPE_HIGH_BOUND_DEFINED): New macros.
(TYPE_FIELDS, TYPE_BASECLASS, TYPE_BASECLASS_NAME, TYPE_FIELD)
(TYPE_ARRAY_UPPER_BOUND_IS_UNDEFINED)
(TYPE_ARRAY_LOWER_BOUND_IS_UNDEFINED, TYPE_ARRAY_UPPER_BOUND_VALUE)
(TYPE_ARRAY_LOWER_BOUND_VALUE):	Adjust to new representation.
(create_range_type): Adjust API.
* ada-lang.c (ada_modulus): Use new extended bound values.
(discrete_type_low_bound): Rename to...
(ada_discrete_type_low_bound): ... and make external.
(discrete_type_high_bound): Rename to...
(ada_discrete_type_high_bound): ... and make external.
(ada_value_slice_from_ptr, ada_array_bound_from_type)
(ada_evaluate_subexp, to_fixed_range_type):
Use ada_discrete_type_low_bound, ada_discrete_type_high_bound.
* ada-typeprint.c (print_range): Use ada_discrete_type_low_bound,
ada_discrete_type_high_bound.  Don't look at field count, which
is no longer meaningful.  Print bounds whenever argument is a range
or enumeration.
* ada-lang.h (ada_discrete_type_low_bound,ada_discrete_type_high_bound):
Declare.
* varobj.c (c_describe_child): Adjust to render larger values.
* mdebugread.c (parse_type): Use proper abstractions for range types:
TYPE_RANGE_DATA, SET_TYPE_LOW_BOUND_DEFINED,
SET_TYPE_HIGH_BOUND_DEFINED.
* p-typeprint.c (pascal_type_print_varspec_prefix): Use larger format
for bounds.
@
text
@d3 1
a3 1
   2003, 2004, 2007, 2008, 2009 Free Software Foundation, Inc.
@


1.29
log
@        * ada-lang.c (packed_array_type): Rename to...
        (constrained_packed_array_type): ...and update comment.
        (decode_packed_array, decode_constrained_packed_array): Ditto.
        (decode_packed_array_type, decode_constrained_packed_array_type):
        Ditto.
        (ada_is_constrained_packed_array_type): New function.
        (ada_is_unconstrained_packed_array_type): New function.
        (decode_packed_array_bitsize): New function, extracted from
        decode_packed_array_type.
        (ada_type_of_array): Add support for unconstrained packed arrays.
        (ada_coerce_to_simple_array_ptr, ada_coerce_to_simple_array)
        (ada_array_bound_from_type, ada_array_bound, ada_array_length)
        (ada_prefer_type, to_fixed_array_type, ada_evaluate_subexp): Resync.
        * ada-lang.h (ada_is_packed_array_type,
        ada_is_constrained_packed_array_type): Renaming.
        * ada-valprint.c (ada_val_print_1): Resync.
        * ada-typeprint.c (print_array_type, ada_print_type): Resync.
@
text
@d117 1
a117 1
/* Print range type TYPE on STREAM.  */
d122 1
a122 6
  struct type *target_type;
  target_type = TYPE_TARGET_TYPE (type);
  if (target_type == NULL)
    target_type = type;

  switch (TYPE_CODE (target_type))
a124 3
    case TYPE_CODE_INT:
    case TYPE_CODE_BOOL:
    case TYPE_CODE_CHAR:
d126 11
a138 12
      target_type = NULL;
      break;
    }

  if (TYPE_NFIELDS (type) < 2)
    {
      /* A range needs at least 2 bounds to be printed.  If there are less
         than 2, just print the type name instead of the range itself.
         This check handles cases such as characters, for example.

         If the name is not defined, then we don't print anything.
       */
d142 1
a142 13
    }
  else
    {
      /* We extract the range type bounds respectively from the first element
         and the last element of the type->fields array */
      const LONGEST lower_bound = (LONGEST) TYPE_LOW_BOUND (type);
      const LONGEST upper_bound = (TYPE_CODE (type) == TYPE_CODE_RANGE
	? (LONGEST) TYPE_HIGH_BOUND (type)
	: (LONGEST) TYPE_FIELD_BITPOS (type, TYPE_NFIELDS (type) - 1));

      ada_print_scalar (target_type, lower_bound, stream);
      fprintf_filtered (stream, " .. ");
      ada_print_scalar (target_type, upper_bound, stream);
@


1.28
log
@	* ada-valprint.c (ada_print_scalar): Accept NULL type argument
	to indicate scalar should be printed as default integer.
	(print_optional_low_bound): Pass NULL to ada_print_scalar to
	indicate default integer output.
	* ada-typeprint.c (print_range, print_range_bound): Likewise.
	(print_choices): Likewise.  Thus, accept NULL as val_type.
	* ada-lang.c (ada_variant_discrim_type): Return NULL when failed
	to look up controlling discriminant name.
@
text
@d355 1
a355 1
  if (ada_is_packed_array_type (type))
d773 1
a773 1
  else if (ada_is_packed_array_type (type))
@


1.27
log
@	* ada-lang.c (to_fixed_range_type): Add ORIG_TYPE argument.
	Fall back to orig_type as index type if symbol lookup fails.
	Allocate result types from ORIG_TYPE's objfile.
	(ada_array_bound_from_type, to_fixed_array_type,
	ada_evaluate_subexp): Pass original index type to
	to_fixed_range_type.  Do not pass objfile.

	* ada-typeprint.c (print_range_type_named): Add ORIG_TYPE argument.
	Fall back to orig_type as index type if symbol lookup fails.
	(print_array_type, ada_print_type): Pass original index type
	to print_range_type_named.
@
text
@d136 1
a136 1
      target_type = builtin_type_int32;
d184 2
a185 2
         To workaround this stabs deficiency, we replace the TYPE by
         builtin_type_int32 when we detect that the bound is negative,
d189 1
a189 1
	type = builtin_type_int32;
d426 1
a426 1
   STREAM, assuming the VAL_TYPE is the type of the values.  */
@


1.26
log
@2009-03-20  Tom Tromey  <tromey@@redhat.com>
	    Jan Kratochvil  <jan.kratochvil@@redhat.com>

	* dwarf2read.c (process_die): Handle DW_TAG_typedef.
	* eval.c (evaluate_subexp_standard) <OP_TYPE>: Strip a single
	typedef.
	* ada-lang.c (decode_packed_array_type): Call CHECK_TYPEDEF on the
	SYMBOL_TYPE result.
	* ada-typeprint.c (print_array_type): Do the NULL check
	unconditionally.
@
text
@d58 1
a58 1
static void print_range_type_named (char *, struct ui_file *);
d236 2
a237 1
/* Print the range type named NAME.  */
d240 2
a241 1
print_range_type_named (char *name, struct ui_file *stream)
d248 3
a250 2
    base_type = builtin_type_int32;
  else if (TYPE_CODE (raw_type) == TYPE_CODE_RANGE)
d256 1
a256 3
  if (subtype_info == NULL && raw_type == NULL)
    fprintf_filtered (stream, "? .. ?");
  else if (subtype_info == NULL)
d402 2
a403 1
					  (range_desc_type, k), stream);
d821 1
a821 1
		print_range_type_named (name, stream);
@


1.25
log
@        * ada-typeprint.c (ada_typedef_print): Remove.  Unused.
@
text
@d360 6
a370 5
      if (type == NULL)
        {
          fprintf_filtered (stream, _("<undecipherable array type>"));
          return;
        }
@


1.24
log
@        Updated copyright notices for most files.
@
text
@a116 16

/* Print a description of a type in the format of a
   typedef for the current language.
   NEW is the new name for a type TYPE.  */

void
ada_typedef_print (struct type *type, struct symbol *new,
		   struct ui_file *stream)
{
   /* XXX: type_sprint */
  fprintf_filtered (stream, "type %.*s is ",
		    ada_name_prefix_len (SYMBOL_PRINT_NAME (new)),
		    SYMBOL_PRINT_NAME (new));
  type_print (type, "", stream, 1);
}

@


1.23
log
@	Fix TYPE_HIGH_BOUND for TYPE_CODE_RANGE using arbitrary TYPE_NFIELDS in
	preparation for supporting DW_AT_byte_stride.
	* ada-lang.c (packed_array_type, ada_index_type): Use TYPE_INDEX_TYPE.
	(ada_array_bound_from_type): Move `index_type' declaration to the
	function start.  New variable `retval'.  Return the bounds for
	TYPE_CODE_RANGE using TYPE_LOW_BOUND and TYPE_HIGH_BOUND.  Abort on
	invalid index type codes.
	* ada-typeprint.c (print_range): Set `upper_bound' for TYPE_CODE_RANGE
	now using TYPE_HIGH_BOUND.
	* ada-valprint.c (val_print_packed_array_elements): Use `index_type'.
	* eval.c (evaluate_subexp_standard): Use TYPE_INDEX_TYPE.
	* gdbtypes.c (create_range_type): Use TYPE_LOW_BOUND, TYPE_HIGH_BOUND,
	refer to the number of fields only through TYPE_NFIELDS.
	(create_array_type): Use TYPE_INDEX_TYPE.
	(check_typedef): Use TYPE_INDEX_TYPE, TYPE_LOW_BOUND, TYPE_HIGH_BOUND.
	* gdbtypes.h (TYPE_ARRAY_UPPER_BOUND_IS_UNDEFINED)
	(TYPE_ARRAY_LOWER_BOUND_IS_UNDEFINED): Use TYPE_INDEX_TYPE.
	(TYPE_ARRAY_UPPER_BOUND_VALUE, TYPE_ARRAY_LOWER_BOUND_VALUE): Use
	TYPE_INDEX_TYPE, TYPE_LOW_BOUND, TYPE_HIGH_BOUND,
	* hppa-tdep.c (hppa_alignof <TYPE_CODE_ARRAY>): Use TYPE_INDEX_TYPE.
	* mdebugread.c (parse_type): Use TYPE_LOW_BOUND, TYPE_HIGH_BOUND,
	* valarith.c (value_bit_index): Use TYPE_INDEX_TYPE.
@
text
@d3 1
a3 1
   2003, 2004, 2007, 2008 Free Software Foundation, Inc.
@


1.22
log
@	* ada-lang.c (ada_coerce_to_simple_array_type): Use builtin_type_int32
	instead of builtin_type_int as default unspecified integral type.
	(ada_index_type, ada_array_bound_from_type, ada_variant_discrim_type,
	assign_component, to_fixed_range_type): Likewise.
	* ada-typeprint.c (print_range, print_range_bound,
	print_range_type_named): Likewise.
	* ada-valprint.c (print_optional_low_bound, ada_val_print_1): Likewise.
	* eval.c (evaluate_subexp_standard): Likewise.
	* gnu-v2-abi.c (gnuv2_virtual_fn_field): Likewise.
	* gnu-v3-abi.c (gnuv3_get_virtual_fn, gnuv3_baseclass_offset,
	build_gdb_vtable_type): Likewise.
	* jv-lang.c (java_array_type): Likewise.
	* m2-typeprint.c (m2_print_bounds, m2_is_long_set_of_type): Likewise.
	* m2-valprint.c (m2_print_long_set): Likewise.
	* parse.c (follow_types): Likewise.
	* p-typeprint.c (pascal_type_print_base): Likewise.
	* valops.c (value_one, value_array, value_string,
	value_bitstring): Likewise.
	* value.c (allocate_repeat_value, value_from_string): Likewise.
	* varobj.c (c_describe_child): Likewise.
	* mt-tdep.c (mt_register_type): Likewise.
	* sh-tdep.c (sh_sh4_build_float_register_type): Likewise.
	* sh64-tdep.c (sh64_build_float_register_type): Likewise.
@
text
@d173 3
a175 2
      const LONGEST upper_bound =
	(LONGEST) TYPE_FIELD_BITPOS (type, TYPE_NFIELDS (type) - 1);
@


1.21
log
@gdb:
	* xml-tdesc.c (tdesc_end_union): Update.
	* stabsread.c (define_symbol): Update.
	(read_type): Update.
	(read_struct_type): Update.
	(read_enum_type): Update.
	* spu-tdep.c (spu_builtin_type_vec128): Update.
	* sh-tdep.c (sh_push_dummy_call_fpu): Update.
	(sh_push_dummy_call_nofpu): Update.
	* mdebugread.c (parse_symbol): Update.
	(parse_symbol): Update.
	(parse_symbol): Update.
	(upgrade_type): Update.
	* jv-lang.c (java_lookup_class): Update.
	* iq2000-tdep.c (iq2000_pointer_to_address): Update.
	* i386-tdep.c (i386_mmx_type): Update.
	(i386_sse_type): Update.
	* gdbtypes.h (enum type_flag_value): New enum.
	(enum type_instance_flag_value): New enum.
	(TYPE_FLAG_UNSIGNED, TYPE_FLAG_NOSIGN, TYPE_FLAG_STUB,
	TYPE_FLAG_TARGET_STUB, TYPE_FLAG_STATIC, TYPE_FLAG_PROTOTYPED,
	TYPE_FLAG_INCOMPLETE, TYPE_FLAG_VARARGS, TYPE_FLAG_VECTOR,
	TYPE_FLAG_FIXED_INSTANCE, TYPE_FLAG_STUB_SUPPORTED,
	TYPE_FLAG_NOTTEXT): Now enum constants.
	(TYPE_FLAG_CONST, TYPE_FLAG_VOLATILE, TYPE_FLAG_CODE_SPACE,
	TYPE_FLAG_DATA_SPACE, TYPE_FLAG_ADDRESS_CLASS_1,
	TYPE_FLAG_ADDRESS_CLASS_2): Remove.
	(TYPE_INSTANCE_FLAG_CONST, TYPE_INSTANCE_FLAG_VOLATILE,
	TYPE_INSTANCE_FLAG_CODE_SPACE, TYPE_INSTANCE_FLAG_DATA_SPACE,
	TYPE_INSTANCE_FLAG_ADDRESS_CLASS_1,
	TYPE_INSTANCE_FLAG_ADDRESS_CLASS_2): New constants.
	(TYPE_UNSIGNED, TYPE_NOSIGN, TYPE_STUB, TYPE_TARGET_STUB,
	TYPE_STATIC, TYPE_PROTOTYPED, TYPE_INCOMPLETE, TYPE_VARARGS,
	TYPE_VECTOR, TYPE_FIXED_INSTANCE, TYPE_STUB_SUPPORTED,
	TYPE_NOTTEXT): Update.
	(TYPE_FLAG_ADDRESS_CLASS_ALL): Remove.
	(TYPE_INSTANCE_FLAG_ADDRESS_CLASS_ALL): New define.
	(TYPE_VOLATILE, TYPE_CODE_SPACE, TYPE_DATA_SPACE,
	TYPE_ADDRESS_CLASS_1, TYPE_ADDRESS_CLASS_2,
	TYPE_ADDRESS_CLASS_ALL): Update.
	(struct main_type) <flags>: Remove.
	<flag_unsigned, flag_nosign, flag_stub, flag_target_stub,
	flag_static, flag_prototyped, flag_incomplete, flag_varargs,
	flag_vector, flag_stub_supported, flag_nottext,
	flag_fixed_instance>: New fields.
	<nfields, vptr_fieldno>: Move earlier.
	(TYPE_FLAGS): Remove.
	* gdbtypes.c (make_pointer_type): Update.
	(address_space_name_to_int): Update.
	(address_space_int_to_name): Update.
	(make_type_with_address_space): Update.
	(make_cv_type): Update.
	(create_range_type): Update.
	(get_discrete_bounds): Update.
	(create_set_type): Update.
	(make_vector_type): Update.
	(smash_to_method_type): Update.
	(check_typedef): Update.
	(check_stub_method): Update.
	(init_type): Individually assign flag fields.
	(recursive_dump_type): Don't print entire TYPE_FLAGS field.  Do
	print TYPE_FIXED_INSTANCE, TYPE_STUB_SUPPORTED, and TYPE_NOTTEXT.
	(copy_type_recursive): Copy the entire main type.  Don't use
	TYPE_FLAGS.
	* features/rs6000/powerpc-altivec64l.c
	(initialize_tdesc_powerpc_altivec64l): Update.
	* features/rs6000/powerpc-altivec64.c
	(initialize_tdesc_powerpc_altivec64): Update.
	* features/rs6000/powerpc-altivec32l.c
	(initialize_tdesc_powerpc_altivec32l): Update.
	* features/rs6000/powerpc-altivec32.c
	(initialize_tdesc_powerpc_altivec32): Update.
	* features/rs6000/powerpc-7400.c (initialize_tdesc_powerpc_7400):
	Update.
	* features/arm-with-iwmmxt.c (initialize_tdesc_arm_with_iwmmxt):
	Update.
	* dwarf2read.c (read_structure_type): Update.
	(read_enumeration_type): Likewise.
	(process_enumeration_scope): Likewise.
	(read_tag_pointer_type): Likewise.
	(read_subroutine_type): Likewise.
	(read_subroutine_type): Likewise.
	(read_base_type): Likewise.
	* coffread.c (coff_read_enum_type): Update.
	* ada-valprint.c (adjust_type_signedness): Update.
	* ada-typeprint.c (print_record_field_types): Update.
	* ada-lang.c (packed_array_type): Update.
	(empty_record): Don't reset TYPE_FLAGS.
	(ada_template_to_fixed_record_type_1): Update.
	(ada_template_to_fixed_record_type_1): Likewise.
	(template_to_static_fixed_type): Likewise.
	(to_record_with_fixed_variant_part): Likewise.
	(to_fixed_record_type): Likewise.
	(to_fixed_array_type): Likewise.
	(to_static_fixed_type): Likewise.
gdb/testsuite:
	* gdb.base/maint.exp: Update "maint print type".
@
text
@d152 1
a152 1
      target_type = builtin_type_int;
d200 1
a200 1
         builtin_type_long when we detect that the bound is negative,
d204 1
a204 1
	type = builtin_type_long;
d261 1
a261 1
    base_type = builtin_type_int;
@


1.20
log
@* ada-lang.c (discrete_type_high_bound,discrete_type_low_bound): Change
API to return LONGEST values rather than struct values.
(ada_evaluate_subexp): Change to use new API of discrete_type_low_bound
and discrete_type_high_bound.
(to_fixed_range_type): Create a range type in cases where
argument is base type and its limits are representable as ints.
(ada_is_modular_type): Correct so that base type must be integral.
* ada-lex.l (TRUEKEYWORD,FALSEKEYWORD): Make 'true' and 'false'
keywords when they appear alone, since we are phasing out
direct representation of these identifiers in ebugging data.
* ada-exp.y: Define 'true' and 'false' as primaries.
(type_boolean): New function.
(type_int,type_long,type_long_long,type_floattype_double)
(type_long_double): Remove uses of current_gdbarch for consistency
with type_boolean.
(write_int): Change comment to indicate that it might write boolean
constant as well.
* ada-typeprint.c (ada_print_type): Print '(false, true)' for boolean
type, since will no longer be represented as enumerated type in
debugging data.
* ada-valprint.c (print_optional_low_bound): Handle boolean case
as well.
@
text
@d588 1
a588 1
  if (len == 0 && (TYPE_FLAGS (type) & TYPE_FLAG_STUB) != 0)
@


1.19
log
@        * ada-lang.c (decode_packed_array_type): Avoid a seg fault
        when the type is an anonymous pointer type.
        (ada_check_typedef): Avoid a seg fault when the type is null.
        * ada-typeprint.c (print_array_type): Add support for pointer
        to packed arrays.
@
text
@d816 3
@


1.18
log
@        * ada-lang.c (static_unwrap_type): Add forward declaration.
        (template_to_static_fixed_type): Fields of dynamic types sometimes
        also need to be unwrapped. Take this into account.
        (ada_to_fixed_type_1): Renamed from ada_to_fixed_type.
        (ada_to_fixed_type): New wrapper around ada_to_fixed_type_1.
        * ada-typeprint.c (ada_print_type): Get the typename from
        the original type, not the base type.
@
text
@d369 3
a379 2
      if (ada_is_packed_array_type (type))
	type = ada_coerce_to_simple_array_type (type);
d786 11
a796 1
    print_array_type (type, stream, show, level);
@


1.17
log
@	Updated copyright notices for most files.
@
text
@d756 1
a756 1
  char *type_name = decoded_type_name (type);
@


1.16
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d3 1
a3 1
   2003, 2004, 2007 Free Software Foundation, Inc.
@


1.15
log
@Copyright updates for 2007.
@
text
@d5 1
a5 1
This file is part of GDB.
d7 12
a18 14
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor,
Boston, MA 02110-1301, USA.  */
@


1.14
log
@* ada-exp.y, ada-lex.l, ada-typeprint.c: I18n markup.
* ada-tasks.c, ada-lang.c: I18n markup.
Editorial: change "can not" => "cannot" throughout.
@
text
@d2 2
a3 2
   Copyright (C) 1986, 1988, 1989, 1991, 1997, 1998, 1999, 2000, 
   2001, 2002, 2003, 2004 Free Software Foundation, Inc.
@


1.13
log
@	* ada-lang.c (process_raise_exception_name): Remove extraneous
        definition from unsubmitted code.
	(is_lower_alphanum): New function.
	(ada_decode):  Add support for decoding protected object subprograms
	and entries, and of entities declared inside protected object
	subprograms.
	Also add missing handling for__{DIGITS}+ suffixes.
	Allow '$<digits>' as valid overloading suffix.
	(is_name_suffix): Add handling for protected type entriy suffixes.
	Also add support for protected type subprogram suffixes, but keep
	it commented out for now, as there is an ambiguity between these
	entities and other internally generated entities.
	Allow '$<digits>' as valid overloading suffix.
	(is_valid_name_for_wild_match): New function.
	(wild_match): Add an exra level of verification of the entity name
	before declaring it a match for the given pattern.
	(ada_type_of_array, ada_evaluate_subexp): Use more proper
	longest_to_int rather than cast.
	(ada_evaluate_subexp): Use "invalid" rather than "illegal" in comment.
	(ada_coerce_to_simple_array): Call check_size to make sure
	that the object size is reasonable.
	(ada_value_primitive_packed_val):  Use correct location in target
	buffer for extracting packed record fields that are themselves records.
	(add_defn_to_vec): Do not try to replace a stub type by its full
	type. Avoids a potential infinite loop.
	(ada_lookup_symbol): Move return incorrectly placed return statement,
	causing a loop that should be scanning all object files to only
	scan the first one.
	(ada_tag_name_2): New function.
	(ada_tag_name_1): If no 'tsd' field found in the dispatching table,
	use alternative representation.
	(ada_find_renaming_symbol): Strip the function name suffix when
	computing the XR type name.
	(ada_to_fixed_type): Try determining the tag only if we have the
	object's address.
	(to_fixed_array_type): Add comments.
	(ada_check_typedef): Replace expression checking whether the given
	type is a stub or not by a "call" to TYPE_STUB. Clearer and more
	consistent.

	* ada-lang.h (ADA_KNOWN_AUXILIARY_FUNCTION_NAME_PATTERNS): Allow
	'$' in addition to '.' for runtime auxiliary function name suffixes.
	See changes to ada_decode above.
	(struct task_control_block): Add field called_task.  (This change is
	to keep synchronized with our local sources; it does not affect the
	public version yet.)

	* ada-typeprint.c (ada_print_type): Use int_string for printing
	modulus of modular type.
	(print_range): Trivial editorial comment fix.

	* ada-valprint.c (ada_emit_char): Use normal Ada syntax for
	double quote in string.
@
text
@d383 1
a383 1
          fprintf_filtered (stream, "<undecipherable array type>");
d816 1
a816 1
	      fprintf_filtered (stream, "<%d-byte integer>",
d840 1
a840 1
	fprintf_filtered (stream, "<%d-byte float>", TYPE_LENGTH (type));
d853 1
a853 1
			    "array (?) of ? (<mal-formed descriptor>)");
@


1.12
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d164 1
a164 1
         Note that if the name is not defined, then we don't print anything.
d831 2
a832 1
	  fprintf_filtered (stream, "mod %ld", (long) ada_modulus (type));
@


1.11
log
@* ada-lang.c (ada_print_subexp): Remove i18n markup from Ada code
output.
* ada-typeprint.c (ada_typedef_print): Ditto.
(print_unchecked_union_type): Ditto.
(print_record_type): Ditto, and correct output for non-derived
types that was inadvertently left off during the markup.
@
text
@d2 1
a2 1
   Copyright 1986, 1988, 1989, 1991, 1997, 1998, 1999, 2000, 
d19 2
a20 1
Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
@


1.10
log
@2004-11-27  Baurjan Ismagulov  <ibr@@ata.cs.hun.edu.tr>

	Committed by Andrw Cagney.
	* abug-rom.c, ada-lang.c, ada-typeprint.c, alpha-tdep.c: i18n
	markup.
@
text
@d128 1
a128 1
  fprintf_filtered (stream, _("type %.*s is "),
d636 1
a636 1
    fprintf_filtered (stream, _("new %s with record"),
d639 3
a641 1
    fprintf_filtered (stream, _("tagged record"));
d644 1
a644 1
    fprintf_filtered (stream, _(" ... end record"));
d656 1
a656 1
	fprintf_filtered (stream, _("\n%*send record"), level, "");
d660 1
a660 1
	fprintf_filtered (stream, _(" null; end record"));
d673 1
a673 1
    fprintf_filtered (stream, _("record (?) is ... end record"));
d675 1
a675 1
    fprintf_filtered (stream, _("record (?) is null; end record"));
d680 1
a680 1
      fprintf_filtered (stream, _("record (?) is\n%*scase ? is"), level + 4, "");
d684 1
a684 1
	  fprintf_filtered (stream, _("\n%*swhen ? =>\n%*s"), level + 8, "",
d692 1
a692 1
      fprintf_filtered (stream, _("\n%*send case;\n%*send record"),
@


1.9
log
@* ada-typeprint.c (ada_print_type): Use int_string for printing
modulus of modular type.
* ada-lang.h (ada_modulus): Change return type to unsigned.
* ada-lang.c (ada_language_arch_info): Correct type of
string_char_type.
(ada_modulus): Return unsigned result.
(ada_lookup_symbol): Remove user disambiguation and modify comment
accordingly.

2004-10-08 Eric Botcazou  <ebotcazou@@act-europe.fr>

Committed by Paul Hilfinger.
* ada-lang.c (decode_packed_array): On big-endian targets,
left-justify the value if it comes with a modular type.

2004-10-08  Joel Brobecker  <brobecker@@gnat.com>

Committed by Paul Hilfinger.
* ada-lang.c (template_to_static_fixed_type): Fix a small typo.
(is_name_suffix): Add support for "___JM" suffixes.
(ada_check_typedef): Renames ada_completed_type.
Update all users of CHECK_TYPEDEF, check_typedef, and
ada_complete_type to call ada_check_typedef.
* ada-typeprint.c: Likewise.
* ada-valprint.c: Likewise.
@
text
@d127 2
a128 1
  fprintf_filtered (stream, "type %.*s is ",
d636 1
a636 1
    fprintf_filtered (stream, "new %s with ",
d639 1
a639 3
    fprintf_filtered (stream, "tagged ");

  fprintf_filtered (stream, "record");
d642 1
a642 1
    fprintf_filtered (stream, " ... end record");
d654 1
a654 1
	fprintf_filtered (stream, "\n%*send record", level, "");
d656 1
a656 1
	fprintf_filtered (stream, " <incomplete type> end record");
d658 1
a658 1
	fprintf_filtered (stream, " null; end record");
a669 2
  fprintf_filtered (stream, "record (?) is");

d671 1
a671 1
    fprintf_filtered (stream, " ... end record");
d673 1
a673 1
    fprintf_filtered (stream, " null; end record");
d678 1
a678 1
      fprintf_filtered (stream, "\n%*scase ? is", level + 4, "");
d682 1
a682 1
	  fprintf_filtered (stream, "\n%*swhen ? =>\n%*s", level + 8, "",
d690 1
a690 1
      fprintf_filtered (stream, "\n%*send case;\n%*send record",
@


1.8
log
@* ada-exp.y (type_int): New function to add layer of abstraction
around references to expression types.
(type_long): Ditto.
(type_long_long): Ditto.
(type_float): Ditto.
(type_double): Ditto.
(type_long_double): Ditto.
(type_char): Ditto.
(type_system_address): Ditto.
(simple_exp): Use type_* functions in place of builtin_*
variables.
(exp): Ditto.
(write_var_from_name): Ditto.
(write_object_renaming): Ditto.
* ada-lang.c (ada_create_fundamental_type): Remove redundant
declaration.
(build_ada_types): Remove, replacing with...
(ada_language_arch_info): New function to initialize primitive
type vector in language_arch_info.
(ada_array_length): Remove use of builtin_type_ada_int.
(value_pos_atr): Ditto.
(ada_evaluate_subexp): Ditto.
(builtin_type_ada_int, builtin_type_ada_short, builtin_type_ada_long,
builtin_type_ada_long_long, builtin_type_ada_char,
builtin_type_ada_float, builtin_type_ada_double,
builtin_type_ada_long_double, builtin_type_ada_natural,
builtin_type_ada_positive, builtin_type_ada_system_address): Remove.
(ada_builtin_types): Remove.
(ada_language_defn): Remove entries for la_builtin_type_vector and
string_char_type and use ada_language_arch_info.
(_initialize_ada_language): Do type-vector initialization along
the lines of c-lang.c.
(ada_create_fundamental_type): Break up line.
(ada_dump_symtab): Remove unused function.
(enum ada_primitive_types): Define.
* ada-lang.h (builtin_type_ada_int, builtin_type_ada_short,
builtin_type_ada_long,builtin_type_ada_long_long,builtin_type_ada_char,
builtin_type_ada_float, builtin_type_ada_double,
builtin_type_ada_long_double, builtin_type_ada_natural,
builtin_type_ada_positive, builtin_type_ada_system_address): Remove.
* ada-lex.l: Use type_* functions in place of builtin_* variables.
(processInt): Ditto.
(processReal): Ditto.
(name_lookup): Ditto.
* ada-typeprint.c (print_range): Use builtin_type_int, not
builtin_type_ada_int.
@
text
@d757 1
a757 1
  struct type *type = ada_completed_type (ada_get_base_type (type0));
d771 1
a771 1
    CHECK_TYPEDEF (type);
@


1.7
log
@ada-exp.y: Synchronize with current ACT sources.
ada-lang.c: Ditto.
ada-lang.h: Ditto.
ada-lex.l: Ditto.
ada-tasks.c: Ditto.
ada-typeprint.c: Ditto.
ada-valprint.c: Ditto.
@
text
@d152 1
a152 1
      target_type = builtin_type_ada_int;
@


1.6
log
@2003-02-20  David Carlton  <carlton@@math.stanford.edu>

	* symtab.h (SYMBOL_PRINT_NAME): Rename from SYMBOL_SOURCE_NAME;
	expand comment.
	* ada-lang.c (user_select_syms, ada_finish_decode_line_1): Replace
	SYMBOL_PRINT_NAME with SYMBOL_SOURCE_NAME.
	* ada-typeprint.c (ada_typedef_print): Ditto.
	* ax-gdb.c (gen_var_ref): Ditto.
	* breakpoint.c (print_one_breakpoint): Ditto.
	* buildsym.c (finish_block): Ditto.
	* c-valprint.c (c_val_print): Ditto.
	* expprint.c (print_subexp): Ditto.
	* findvar.c (locate_var_value): Ditto.
	* infcmd.c (jump_command): Ditto.
	* linespec.c (decode_line_2, decode_compound): Ditto.
	* maint.c (maintenance_translate_address): Ditto.
	* objc-lang.c (compare_selectors, compare_classes): Ditto.
	* printcmd.c (build_address_symbolic, sym_info, print_frame_args):
	Ditto.
	* p-valprint.c (pascal_val_print): Ditto.
	* stabsread.c (define_symbol): Ditto.
	* stack.c (print_frame, frame_info, print_block_frame_locals)
	(print_frame_arg_vars, return_command): Ditto.
	* symfile.c (compare_symbols, compare_psymbols): Ditto.
	* symmisc.c (print_symbol): Ditto.
	* symtab.c (lookup_partial_symbol, lookup_block_symbol)
	(compare_search_syms, print_symbol_info, print_msymbol_info)
	(rbreak_command): Ditto.
	* tracepoint.c (tracepoints_info): Ditto.
	* typeprint.c (typedef_print): Ditto.
	* valops.c (value_of_variable, hand_function_call): Ditto.
	* cli/cli-cmds.c (edit_command, list_command): Ditto.
	* ada-typeprint.c: Update Copyright.
	* infcmd.c, objc-lang.c, p-valprint.c, symmisc.c: Ditto.
	* tracepoint.c, cli/cli-cmds.c: Ditto.
@
text
@d2 2
a3 2
   Copyright 1986, 1988, 1989, 1991, 1997, 2003 Free Software
   Foundation, Inc.
d66 2
a67 2
/* The (demangled) Ada name of TYPE. This value persists until the
   next call. */
d70 1
a70 1
demangled_type_name (struct type *type)
d119 1
a119 1
/* Print a description of a type in the format of a 
d121 1
a121 1
   NEW is the new name for a type TYPE. */
d133 1
a133 1
/* Print range type TYPE on STREAM. */
d158 1
a158 1
      /* A range needs at least 2 bounds to be printed. If there are less
d160 1
a160 1
         This check handles cases such as characters, for example. 
d183 1
a183 1
   set *N past the bound and its delimiter, if any. */
d192 13
d229 1
a229 1
   "___U") according to the ___XD conventions. */
d244 1
a244 1
  B = get_int_var_value (name_buf, 0, &OK);
d251 1
a251 1
/* Print the range type named NAME. */
a257 1
  LONGEST low, high;
d284 1
a284 1
	  print_range_bound (raw_type, bounds_str, &n, stream);
d288 1
a288 1
	print_dynamic_range_bound (raw_type, name, prefix_len, "___L",
d294 1
a294 1
	print_range_bound (raw_type, bounds_str, &n, stream);
d296 1
a296 1
	print_dynamic_range_bound (raw_type, name, prefix_len, "___U",
d301 1
a301 1
/* Print enumerated type TYPE on STREAM. */
d330 1
a330 1
/* Print representation of Ada fixed-point type TYPE on STREAM. */
d348 1
a348 1
/* Print representation of special VAX floating-point type TYPE on STREAM. */
d357 2
a358 2
/* Print simple (constrained) array type TYPE on STREAM.  LEVEL is the 
   recursion (indentation) level, in case the element type itself has 
d360 1
a360 1
   structure to show (see ada_print_type). */
d379 6
a384 1
      if (ada_is_simple_array (type))
d437 1
a437 1
   STREAM, assuming the VAL_TYPE is the type of the values. */
d449 1
a449 1
  /* Skip over leading 'V': NOTE soon to be obsolete. */
d506 2
a507 2
/* Assuming that field FIELD_NUM of TYPE is a VARIANTS field whose 
   discriminant is contained in OUTER_TYPE, print its variants on STREAM.  
d511 1
a511 1
   to show (see ada_print_type). For this purpose, fields nested in a
d513 1
a513 1
   immediately outside the variant part. */
d521 1
a521 1
  struct type *var_type;
d530 2
a531 6
      if (TYPE_FLAGS (var_type) & TYPE_FLAG_STUB)
	{
	  var_type = ada_find_parallel_type (var_type, "___XVU");
	  if (var_type == NULL)
	    return;
	}
d534 4
d549 1
a549 1
/* Assuming that field FIELD_NUM of TYPE is a variant part whose 
d551 5
a555 5
   on STREAM.  LEVEL is the recursion (indentation) level, in case any of 
   the fields themselves have nested structure, and SHOW is the number of 
   levels of internal structure to show (see ada_print_type). For this 
   purpose, fields nested in a variant part are taken to be at the same 
   level as the fields immediately outside the variant part. */
d569 6
a574 6
/* Print a description on STREAM of the fields in record type TYPE, whose 
   discriminants are in OUTER_TYPE.  LEVEL is the recursion (indentation) 
   level, in case any of the fields themselves have nested structure, 
   and SHOW is the number of levels of internal structure to show 
   (see ada_print_type).  Does not print parent type information of TYPE. 
   Returns 0 if no fields printed, -1 for an incomplete type, else > 0. 
d576 1
a576 1
   end. */
d618 3
a620 3
/* Print record type TYPE on STREAM.  LEVEL is the recursion (indentation) 
   level, in case the element type itself has nested structure, and SHOW is 
   the number of levels of internal structure to show (see ada_print_type). */
d629 3
a631 7
  type = type0;
  if (TYPE_FLAGS (type) & TYPE_FLAG_STUB)
    {
      struct type *type1 = ada_find_parallel_type (type, "___XVE");
      if (type1 != NULL)
	type = type1;
    }
d636 2
a637 2
		      demangled_type_name (parent_type));
  else if (parent_type == NULL && ada_is_tagged_type (type))
d664 1
a664 1
   format on STREAM. LEVEL is the recursion (indentation) level
d666 1
a666 1
   number of levels of internal structure to show (see ada_print_type). */
d701 1
a701 1
   for function or procedure NAME if NAME is not null. */
d744 1
a744 1
   SHOW+1 is the maximum number of levels of internal type structure 
d748 1
a748 1
      when there is a type name for the SHOWth deepest level (0th is 
d751 1
a751 1
   LEVEL indicates level of recursion (for nested definitions). */
a756 2
  enum type_code code;
  int demangled_args;
d758 1
a758 1
  char *type_name = demangled_type_name (type);
d848 1
a848 1
	if (ada_is_array_descriptor (type))
@


1.6.42.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d2 2
a3 2
   Copyright 1986, 1988, 1989, 1991, 1997, 1998, 1999, 2000, 
   2001, 2002, 2003, 2004 Free Software Foundation, Inc.
d66 2
a67 2
/* The (decoded) Ada name of TYPE.  This value persists until the
   next call.  */
d70 1
a70 1
decoded_type_name (struct type *type)
d119 1
a119 1
/* Print a description of a type in the format of a
d121 1
a121 1
   NEW is the new name for a type TYPE.  */
d133 1
a133 1
/* Print range type TYPE on STREAM.  */
d158 1
a158 1
      /* A range needs at least 2 bounds to be printed.  If there are less
d160 1
a160 1
         This check handles cases such as characters, for example.
d183 1
a183 1
   set *N past the bound and its delimiter, if any.  */
a191 13
      /* STABS decodes all range types which bounds are 0 .. -1 as
         unsigned integers (ie. the type code is TYPE_CODE_INT, not
         TYPE_CODE_RANGE).  Unfortunately, ada_print_scalar() relies
         on the unsigned flag to determine whether the bound should
         be printed as a signed or an unsigned value.  This causes
         the upper bound of the 0 .. -1 range types to be printed as
         a very large unsigned number instead of -1.
         To workaround this stabs deficiency, we replace the TYPE by
         builtin_type_long when we detect that the bound is negative,
         and the type is a TYPE_CODE_INT.  The bound is negative when
         'm' is the last character of the number scanned in BOUNDS.  */
      if (bounds[*n - 1] == 'm' && TYPE_CODE (type) == TYPE_CODE_INT)
	type = builtin_type_long;
d216 1
a216 1
   "___U") according to the ___XD conventions.  */
d231 1
a231 1
  B = get_int_var_value (name_buf, &OK);
d238 1
a238 1
/* Print the range type named NAME.  */
d245 1
d272 1
a272 1
	  print_range_bound (base_type, bounds_str, &n, stream);
d276 1
a276 1
	print_dynamic_range_bound (base_type, name, prefix_len, "___L",
d282 1
a282 1
	print_range_bound (base_type, bounds_str, &n, stream);
d284 1
a284 1
	print_dynamic_range_bound (base_type, name, prefix_len, "___U",
d289 1
a289 1
/* Print enumerated type TYPE on STREAM.  */
d318 1
a318 1
/* Print representation of Ada fixed-point type TYPE on STREAM.  */
d336 1
a336 1
/* Print representation of special VAX floating-point type TYPE on STREAM.  */
d345 2
a346 2
/* Print simple (constrained) array type TYPE on STREAM.  LEVEL is the
   recursion (indentation) level, in case the element type itself has
d348 1
a348 1
   structure to show (see ada_print_type).  */
d367 1
a367 6
      if (type == NULL)
        {
          fprintf_filtered (stream, "<undecipherable array type>");
          return;
        }
      if (ada_is_simple_array_type (type))
d420 1
a420 1
   STREAM, assuming the VAL_TYPE is the type of the values.  */
d432 1
a432 1
  /* Skip over leading 'V': NOTE soon to be obsolete.  */
d489 2
a490 2
/* Assuming that field FIELD_NUM of TYPE is a VARIANTS field whose
   discriminant is contained in OUTER_TYPE, print its variants on STREAM.
d494 1
a494 1
   to show (see ada_print_type).  For this purpose, fields nested in a
d496 1
a496 1
   immediately outside the variant part.  */
d504 1
a504 1
  struct type *var_type, *par_type;
d513 6
a518 2
      if (var_type == NULL || TYPE_CODE (var_type) != TYPE_CODE_UNION)
	return;
a520 4
  par_type = ada_find_parallel_type (var_type, "___XVU");
  if (par_type != NULL)
    var_type = par_type;

d532 1
a532 1
/* Assuming that field FIELD_NUM of TYPE is a variant part whose
d534 5
a538 5
   on STREAM.  LEVEL is the recursion (indentation) level, in case any of
   the fields themselves have nested structure, and SHOW is the number of
   levels of internal structure to show (see ada_print_type).  For this
   purpose, fields nested in a variant part are taken to be at the same
   level as the fields immediately outside the variant part.  */
d552 6
a557 6
/* Print a description on STREAM of the fields in record type TYPE, whose
   discriminants are in OUTER_TYPE.  LEVEL is the recursion (indentation)
   level, in case any of the fields themselves have nested structure,
   and SHOW is the number of levels of internal structure to show
   (see ada_print_type).  Does not print parent type information of TYPE.
   Returns 0 if no fields printed, -1 for an incomplete type, else > 0.
d559 1
a559 1
   end.  */
d601 3
a603 3
/* Print record type TYPE on STREAM.  LEVEL is the recursion (indentation)
   level, in case the element type itself has nested structure, and SHOW is
   the number of levels of internal structure to show (see ada_print_type).  */
d612 7
a618 3
  type = ada_find_parallel_type (type0, "___XVE");
  if (type == NULL)
    type = type0;
d623 2
a624 2
		      decoded_type_name (parent_type));
  else if (parent_type == NULL && ada_is_tagged_type (type, 0))
d651 1
a651 1
   format on STREAM.  LEVEL is the recursion (indentation) level
d653 1
a653 1
   number of levels of internal structure to show (see ada_print_type).  */
d688 1
a688 1
   for function or procedure NAME if NAME is not null.  */
d731 1
a731 1
   SHOW+1 is the maximum number of levels of internal type structure
d735 1
a735 1
      when there is a type name for the SHOWth deepest level (0th is
d738 1
a738 1
   LEVEL indicates level of recursion (for nested definitions).  */
d744 2
d747 1
a747 1
  char *type_name = decoded_type_name (type);
d837 1
a837 1
	if (ada_is_array_descriptor_type (type))
@


1.6.42.2
log
@Merge from mainline.
@
text
@d152 1
a152 1
      target_type = builtin_type_int;
@


1.5
log
@	* ada-lang.c: Use gdb_string.h instead of <string.h>.
	* ada-typeprint.c: Use gdb_string.h instead of <string.h>.
@
text
@d2 2
a3 1
   Copyright 1986, 1988, 1989, 1991, 1997 Free Software Foundation, Inc.
d128 2
a129 2
		    ada_name_prefix_len (SYMBOL_SOURCE_NAME (new)),
		    SYMBOL_SOURCE_NAME (new));
@


1.5.10.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 2
   Copyright 1986, 1988, 1989, 1991, 1997, 2003 Free Software
   Foundation, Inc.
d127 2
a128 2
		    ada_name_prefix_len (SYMBOL_PRINT_NAME (new)),
		    SYMBOL_PRINT_NAME (new));
@


1.5.8.1
log
@2002-12-20  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_minsyms): Don't call
	lookup_symbol_aux from within this.
	* values.c (value_static_field): lookup_symbol_linkage.
	(value_fn_field): lookup_symbol_linkage.
	* valops.c (value_struct_elt_for_reference): lookup_symbol_linkage.
	* blockframe.c (inside_main_func): lookup_symbol_linkage.
	* source.c (select_source_symtab): lookup_symbol_linkage.
	* nlmread.c (nlm_symfile_read): Call lookup_symbol_linkage.
	* nindy-tdep.c (nindy_frame_chain_valid): Call
	lookup_symbol_linkage.
	* linespec.c (count_methods): Call lookup_symbol_linkage.
	(add_matching_methods): Ditto.
	(add_constructors): Ditto.
	* hppa-tdep.c (find_stub_with_shl_get): Call
	lookup_symbol_linkage.  Delete symbol2.
	(initialize_hp_cxx_exception_support): Call lookup_symbol_linkage.
	* cli/cli-cmds.c (edit_command): SYMBOL_PRINT_NAME.
	(list_command): SYMBOL_PRINT_NAME.
	* valops.c (value_of_variable): SYMBOL_PRINT_NAME
	(hand_function_call): SYMBOL_PRINT_NAME.
	* typeprint.c (typedef_print): SYMBOL_PRINT_NAME.
	* tracepoint.c (tracepoints_info): SYMBOL_PRINT_NAME.
	* symtab.c (lookup_partial_symbol): SYMBOL_BEST_NAME.
	(compare_search_syms): SYMBOL_BEST_NAME.
	(print_symbol_info): SYMBOL_PRINT_NAME.
	(print_msymbol_info): SYMBOL_PRINT_NAME.
	(rbreak_command): SYMBOL_PRINT_NAME.
	* symmisc.c (print_symbol): SYMBOL_PRINT_NAME.
	* stack.c (print_frame): SYMBOL_PRINT_NAME.
	(frame_info): SYMBOL_PRINT_NAME.
	(print_block_frame_locals): SYMBOL_PRINT_NAME.
	(print_block_frame_labels): SYMBOL_PRINT_NAME.
	(print_frame_arg_vars): SYMBOL_PRINT_NAME.
	(return_command): SYMBOL_PRINT_NAME.
	* stabsread.c (define_symbol): SYMBOL_PRINT_NAME.
	* p-valprint.c (pascal_val_print): SYMBOL_PRINT_NAME.
	* printcmd.c (build_address_symbolic): SYMBOL_PRINT_NAME.
	(sym_info): SYMBOL_PRINT_NAME.
	(print_frame_args): SYMBOL_PRINT_NAME.
	* objc-lang.c (compare_selectors): SYMBOL_BEST_NAME.
	(compare_classes): SYMBOL_BEST_NAME.
	* maint.c (maintenance_translate_address): SYMBOL_PRINT_NAME.
	* linespec.c (find_method): SYMBOL_PRINT_NAME.
	(select_symbols): SYMBOL_PRINT_NAME.
	* infcmd.c (jump_command): SYMBOL_PRINT_NAME.
	* findvar.c (locate_var_value): SYMBOL_PRINT_NAME.
	* expprint.c (print_subexp): SYMBOL_PRINT_NAME.
	* c-valprint.c (c_val_print): SYMBOL_PRINT_NAME.
	* buildsym.c (finish_block): SYMBOL_PRINT_NAME.
	* breakpoint.c (print_one_breakpoint): SYMBOL_PRINT_NAME.
	* ax-gdb.c (gen_var_ref): SYMBOL_PRINT_NAME.
	* ada-typeprint.c (ada_typedef_print): SYMBOL_PRINT_NAME.
	* ada-lang.c (user_select_syms): Use SYMBOL_PRINT_NAME instead of
	SYMBOL_SOURCE_NAME.
	(user_select_syms):
	(ada_finish_decode_line_1): Use SYMBOL_BEST_NAME instead of
	SYMBOL_SOURCE_NAME.
	* symtab.h (SYMBOL_PRINT_NAME): Rename from SYMBOL_SOURCE_NAME.
	* symfile.c (compare_symbols): Use SYMBOL_BEST_NAME, not
	SYMBOL_SOURCE_NAME.
	(compare_psymbols): Ditto.
	* symtab.c (lookup_symbol_linkage): New function.
	* symtab.h: Declare lookup_symbol_linkage.
	* c-valprint.c (c_val_print): Call lookup_symbol_minsym.
	* symtab.c (lookup_symbol_aux_minsyms): Call minsym_static.
	* minsyms.c (minsym_static): New function.
	* symtab.h: Declare minsym_static.
	* symtab.c (lookup_symbol_minsym): New function.
	(search_symbols): Call lookup_symbol_minsym instead of
	lookup_symbol.
	(lookup_symbol_namespace): Don't take apart NAME.
	* symtab.h: Declare lookup_symbol_minsym.
	* printcmd.c (build_address_symbolic): Don't use old version of
	SYMBOL_LINKAGE_NAME.
	* symtab.c (lookup_block_symbol): Change mangled names to linkage
	name, and use SYMBOL_LINKAGE_NAME as appropriate.
	* symtab.h (SYMBOL_LINKAGE_NAME): New macro, with a different
	meaning from the old macro of the same name.  Also, add comments
	about proper uses of names.
@
text
@d127 2
a128 2
		    ada_name_prefix_len (SYMBOL_PRINT_NAME (new)),
		    SYMBOL_PRINT_NAME (new));
@


1.5.8.2
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d2 1
a2 2
   Copyright 1986, 1988, 1989, 1991, 1997, 2003 Free Software
   Foundation, Inc.
@


1.4
log
@        * ada-lang.c: run through gdb_indent.sh
        * ada-lang.h: run through gdb_indent.sh
        * ada-tasks.c: run through gdb_indent.sh
        * ada-typeprint.c: run through gdb_indent.sh
        * ada-valprint.c: run through gdb_indent.sh
@
text
@d38 1
a38 1
#include <string.h>
@


1.3
log
@2002-07-29  Andrew Cagney  <ac131313@@redhat.com>

* gdb_obstack.h: New file.
* symtab.h: Include "gdb_obstack.h" instead of "obstack.h".
(obstack_chunk_alloc, obstack_chunk_free): Delete macros.
* objfiles.h: Include "gdb_obstack.h".
* Makefile.in (gdb_obstack_h): Define.
(symtab_h): Add $(gdb_obstack_h).
(objfiles_h): Add $(gdb_obstack_h).

* objfiles.c: Include "gdb_obstack.h" instead of "obstack.h".
* macrotab.c, cp-valprint.c, dbxread.c: Ditto.
* ch-typeprint.c, ch-valprint.c, dstread.c: Ditto.
* macroexp.c, p-typeprint.c, stabsread.c: Ditto.
* symtab.c, f-typeprint.c, mdebugread.c: Ditto.
* p-valprint.c, symmisc.c, typeprint.c: Ditto.
* symfile.c, coffread.c, c-typeprint.c: Ditto.
* buildsym.c, bcache.c, ada-typeprint.c: Ditto.

* Makefile.in (bcache.o): Update dependencies.
(buildsym.o, c-typeprint.o, ch-typeprint.o): Ditto.
(ch-valprint.o, coffread.o, cp-valprint.o): Ditto.
(dbxread.o, dstread.o, f-typeprint.o): Ditto.
(objfiles.o, p-typeprint.o, p-valprint.o): Ditto.
(stabsread.o, symfile.o, symmisc.o): Ditto.
(symtab.o, typeprint.o, macroexp.o): Ditto.
(macrotab.o, mdebugread.o): Ditto.
(f_lang_h, coff_sym_h, coff_symconst_h): Define.
(coff_ecoff_h, aout_aout64_h): Define.
(aout_stabs_gnu_h, libaout_h): Define.
@
text
@d41 1
a41 1
static int print_record_field_types (struct type *, struct type *, 
d44 1
a44 1
static void print_array_type (struct type*, struct ui_file*, int, int);
d46 2
a47 1
static void print_choices (struct type*, int, struct ui_file*, struct type*);
d49 1
a49 1
static void print_range (struct type*, struct ui_file*);
d51 2
a52 1
static void print_range_bound (struct type*, char*, int*, struct ui_file*);
d54 3
a56 3
static void 
print_dynamic_range_bound (struct type*, const char*, int, 
			   const char*, struct ui_file*);
d58 2
a59 1
static void print_range_type_named (char*, struct ui_file*);
a60 1

d62 1
a62 1
static char* name_buffer;
d68 1
a68 1
static char*
d73 1
a73 1
  else 
d75 2
a76 2
      char* raw_name = ada_type_name (type);
      char *s, *q; 
d85 1
a85 1
      s = (char*) strstr (name_buffer, "___");
d96 1
a96 1
      if (! islower (s[1]))
d103 2
a104 1
	      *q = '.'; s += 2;
d108 2
a109 1
	      *q = *s; s += 1;
d123 2
a124 1
ada_typedef_print (struct type *type, struct symbol *new, struct ui_file *stream)
d126 3
a128 3
  fprintf_filtered (stream, "type %.*s is ", 
		    ada_name_prefix_len (SYMBOL_SOURCE_NAME(new)), 
		    SYMBOL_SOURCE_NAME(new));
d135 1
a135 1
print_range (struct type* type, struct ui_file* stream)
d137 1
a137 1
  struct type* target_type;
d142 1
a142 1
  switch (TYPE_CODE (target_type)) 
d164 2
a165 2
                        ada_name_prefix_len (TYPE_NAME (type)),
                        TYPE_NAME (type));
d173 1
a173 1
        (LONGEST) TYPE_FIELD_BITPOS (type, TYPE_NFIELDS (type) -1);
d185 2
a186 1
print_range_bound (struct type* type, char* bounds, int* n, struct ui_file* stream)
d198 2
a199 2
      char* bound = bounds + *n;
      char* pend;
d204 1
a204 1
      else 
d218 2
a219 1
print_dynamic_range_bound (struct type* type, const char* name, int name_len, const char* suffix, struct ui_file* stream)
d240 1
a240 1
print_range_type_named (char* name, struct ui_file* stream)
d245 1
a245 1
  char* subtype_info;
d269 1
a269 1
      if (*subtype_info == 'L') 
d275 2
a276 1
	print_dynamic_range_bound (raw_type, name, prefix_len, "___L", stream);
d280 1
a280 1
      if (*subtype_info == 'U') 
d283 2
a284 1
	print_dynamic_range_bound (raw_type, name, prefix_len, "___U", stream);
d286 1
a286 1
}  
d303 2
a304 1
      if (i) fprintf_filtered (stream, ", ");
d330 1
a330 1
      if (delta != small) 
d350 2
a351 1
print_array_type (struct type *type, struct ui_file *stream, int show, int level)
d360 1
a360 1
  if (show < 0) 
d366 1
a366 1
      if (ada_is_simple_array (type)) 
d368 1
a368 1
	  struct type* range_desc_type = 
d370 1
a370 1
	  struct type* arr_type;
d385 1
a385 1
	  else 
d388 2
a389 2
	      n_indices = TYPE_NFIELDS (range_desc_type); 
	      for (k = 0, arr_type = type; 
d395 2
a396 2
		  print_range_type_named (TYPE_FIELD_NAME (range_desc_type, k),
					  stream);
d399 1
a399 1
		}		  
d402 1
a402 1
      else 
d412 2
a413 2
  ada_print_type (ada_array_element_type (type, n_indices), "", stream, 
		  show == 0 ? 0 : show-1, level+1);
d422 2
a423 1
print_choices (struct type *type, int field_num, struct ui_file *stream, struct type *val_type)
d427 1
a427 1
  const char* name = TYPE_FIELD_NAME (type, field_num);
d434 1
a434 1
      if (! ada_scan_number (name, 1, NULL, &p))
d442 1
a442 1
      switch (name[p]) 
d449 1
a449 1
	  if (have_output) 
d455 1
a455 1
      switch (name[p]) 
d460 1
a460 1
	    if (! ada_scan_number (name, p + 1, &W, &p))
d468 2
a469 3
	    if (! ada_scan_number (name, p + 1, &L, &p)
		|| name[p] != 'T'
		|| ! ada_scan_number (name, p + 1, &U, &p))
d512 1
a512 1
      if (TYPE_FLAGS (var_type) & TYPE_FLAG_STUB) 
d520 1
a520 1
  for (i = 0; i < TYPE_NFIELDS (var_type); i += 1) 
d525 2
a526 2
      if (print_record_field_types (TYPE_FIELD_TYPE (var_type, i), 
				    outer_type, stream, show, level+4) <= 0)
d544 4
a547 3
		    ada_variant_discrim_name 
		      (TYPE_FIELD_TYPE (type, field_num)));
  print_variant_clauses (type, field_num, outer_type, stream, show, level + 4);
d576 1
a576 2
      if (ada_is_parent_field (type, i) 
	  || ada_is_ignored_field (type, i))
d581 1
a581 1
      else if (ada_is_variant_part (type, i)) 
d605 2
a606 1
print_record_type (struct type* type0, struct ui_file* stream, int show, int level)
d608 3
a610 3
  struct type* parent_type;
  struct type* type;
  
d614 1
a614 1
      struct type* type1 = ada_find_parallel_type (type, "___XVE");
d620 2
a621 2
  if (ada_type_name (parent_type) != NULL) 
    fprintf_filtered (stream, "new %s with ", 
d636 1
a636 1
	flds += print_record_field_types (parent_type, parent_type, 
d639 1
a639 1
      
d642 1
a642 1
      else if (flds < 0) 
d644 1
a644 1
      else 
d654 1
a654 1
print_unchecked_union_type (struct type* type, struct ui_file* stream, 
d661 1
a661 1
  else if (TYPE_NFIELDS (type) == 0) 
d667 1
a667 2
      fprintf_filtered (stream, "\n%*scase ? is", 
			level+4, "");
d669 1
a669 1
      for (i = 0; i < TYPE_NFIELDS (type); i += 1) 
d671 2
a672 2
	  fprintf_filtered (stream, "\n%*swhen ? =>\n%*s", level+8, "",
			    level+12, "");
d679 2
a680 2
      fprintf_filtered (stream, "\n%*send case;\n%*send record", 
			level+4, "", level, "");
d683 1
a683 1
  
d690 1
a690 1
print_func_type (struct type *type, struct ui_file *stream, char* name)
d699 1
a699 1
  if (name != NULL && name[0] != '\0') 
d702 1
a702 1
  if (len > 0) 
d712 1
a712 1
	  fprintf_filtered (stream, "a%d: ", i+1);
d716 1
a716 1
    }      
d740 1
a740 1
ada_print_type (struct type* type0, char* varstring, struct ui_file* stream,
d745 2
a746 2
  struct type* type = ada_completed_type (ada_get_base_type (type0));
  char* type_name = demangled_type_name (type);
d753 1
a753 2
			  ada_name_prefix_len(varstring),
			  varstring);
d759 1
a759 1
      CHECK_TYPEDEF (type);
d762 2
a763 2
      fprintf_filtered (stream, "%.*s: ", 
			ada_name_prefix_len (varstring), varstring);
d767 1
a767 1
      fprintf_filtered (stream, "%.*s", 
d777 16
a792 61
  switch (TYPE_CODE (type))
    {
    default:
      fprintf_filtered (stream, "<");
      c_print_type (type, "", stream, show, level);
      fprintf_filtered (stream, ">");
      break;
    case TYPE_CODE_PTR:
      fprintf_filtered (stream, "access ");
      ada_print_type (TYPE_TARGET_TYPE (type), "", stream, show,
		      level);
      break;
    case TYPE_CODE_REF:
      fprintf_filtered (stream, "<ref> ");
      ada_print_type (TYPE_TARGET_TYPE (type), "", stream, show,
		      level);
      break;
    case TYPE_CODE_ARRAY:
      print_array_type (type, stream, show, level);
      break;
    case TYPE_CODE_INT:
      if (ada_is_fixed_point_type (type))
	print_fixed_point_type (type, stream);
      else if (ada_is_vax_floating_type (type))
	print_vax_floating_point_type (type, stream);
      else
	{
	  char* name = ada_type_name (type);
	  if (! ada_is_range_type_name (name))
	    fprintf_filtered (stream, "<%d-byte integer>", TYPE_LENGTH (type));
	  else
	    {
	      fprintf_filtered (stream, "range ");
	      print_range_type_named (name, stream);
	    }
	}
      break;
    case TYPE_CODE_RANGE:
      if (ada_is_fixed_point_type (type))
	print_fixed_point_type (type, stream);
      else if (ada_is_vax_floating_type (type))
	print_vax_floating_point_type (type, stream);
      else if (ada_is_modular_type (type))
	fprintf_filtered (stream, "mod %ld", (long) ada_modulus (type));
      else
	{
	  fprintf_filtered (stream, "range ");
	  print_range (type, stream);
	}
      break;
    case TYPE_CODE_FLT:
      fprintf_filtered (stream, "<%d-byte float>", TYPE_LENGTH (type));
      break;
    case TYPE_CODE_ENUM:
      if (show < 0)
	fprintf_filtered (stream, "(...)");
      else
	print_enum_type (type, stream);
      break;
    case TYPE_CODE_STRUCT:
      if (ada_is_array_descriptor (type))
d794 57
a850 12
      else if (ada_is_bogus_array_descriptor (type))
	fprintf_filtered (stream, "array (?) of ? (<mal-formed descriptor>)");
      else
	print_record_type (type, stream, show, level);
      break;
    case TYPE_CODE_UNION:
      print_unchecked_union_type (type, stream, show, level);
      break;
    case TYPE_CODE_FUNC:
      print_func_type (type, stream, varstring);
      break;
    }
@


1.2
log
@        * ada-lang.c: Change k&r style function definitions to prototyped
        form.
        * ada-typeprint.c: Change k&r style function definitions to prototyped
        form.
        * ada-valprint.c: Change k&r style function definitions to prototyped
        form.
@
text
@d21 1
a21 1
#include "obstack.h"
@


1.1
log
@Add base ada language files
@
text
@d67 1
a67 2
demangled_type_name (type)
     struct type *type;
d119 1
a119 4
ada_typedef_print (type, new, stream)
   struct type *type;
   struct symbol *new;
   struct ui_file *stream;
d130 1
a130 3
print_range (type, stream)
     struct type* type;
     struct ui_file* stream;
d180 1
a180 5
print_range_bound (type, bounds, n, stream)
     struct type* type;
     char* bounds;
     int* n;
     struct ui_file* stream;
d212 1
a212 6
print_dynamic_range_bound (type, name, name_len, suffix, stream)
     struct type* type;
     const char* name;
     int name_len;
     const char* suffix;
     struct ui_file* stream;
d233 1
a233 3
print_range_type_named (name, stream)
     char* name;
     struct ui_file* stream;
d282 1
a282 3
print_enum_type (type, stream)
     struct type *type;
     struct ui_file *stream;
d310 1
a310 3
print_fixed_point_type (type, stream)
     struct type *type;
     struct ui_file *stream;
d328 1
a328 3
print_vax_floating_point_type (type, stream)
     struct type *type;
     struct ui_file *stream;
d340 1
a340 5
print_array_type (type, stream, show, level)
     struct type *type;
     struct ui_file *stream;
     int show;
     int level;
d411 1
a411 5
print_choices (type, field_num, stream, val_type)
     struct type *type;
     int field_num;
     struct ui_file *stream;
     struct type *val_type;
d487 3
a489 7
print_variant_clauses (type, field_num, outer_type, stream, show, level)
     struct type *type;
     int field_num;
     struct type *outer_type;
     struct ui_file *stream;
     int show;
     int level;
d529 2
a530 7
print_variant_part (type, field_num, outer_type, stream, show, level)
     struct type *type;
     int field_num;
     struct type *outer_type;
     struct ui_file *stream;
     int show;
     int level;
d549 2
a550 6
print_record_field_types (type, outer_type, stream, show, level)
     struct type *type;
     struct type *outer_type;
     struct ui_file *stream;
     int show;
     int level;
d594 1
a594 5
print_record_type (type0, stream, show, level)
     struct type* type0;
     struct ui_file* stream;
     int show;
     int level;
d679 1
a679 4
print_func_type (type, stream, name)
     struct type *type;
     struct ui_file *stream;
     char* name;
d729 2
a730 6
ada_print_type (type0, varstring, stream, show, level)
     struct type* type0;
     char* varstring;
     struct ui_file* stream;
     int show;
     int level;
@


1.1.4.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@@


1.1.4.2
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d21 1
a21 1
#include "gdb_obstack.h"
d67 2
a68 1
demangled_type_name (struct type *type)
d120 4
a123 1
ada_typedef_print (struct type *type, struct symbol *new, struct ui_file *stream)
d134 3
a136 1
print_range (struct type* type, struct ui_file* stream)
d186 5
a190 1
print_range_bound (struct type* type, char* bounds, int* n, struct ui_file* stream)
d222 6
a227 1
print_dynamic_range_bound (struct type* type, const char* name, int name_len, const char* suffix, struct ui_file* stream)
d248 3
a250 1
print_range_type_named (char* name, struct ui_file* stream)
d299 3
a301 1
print_enum_type (struct type *type, struct ui_file *stream)
d329 3
a331 1
print_fixed_point_type (struct type *type, struct ui_file *stream)
d349 3
a351 1
print_vax_floating_point_type (struct type *type, struct ui_file *stream)
d363 5
a367 1
print_array_type (struct type *type, struct ui_file *stream, int show, int level)
d438 5
a442 1
print_choices (struct type *type, int field_num, struct ui_file *stream, struct type *val_type)
d518 7
a524 3
print_variant_clauses (struct type *type, int field_num,
		       struct type *outer_type, struct ui_file *stream,
		       int show, int level)
d564 7
a570 2
print_variant_part (struct type *type, int field_num, struct type *outer_type,
		    struct ui_file *stream, int show, int level)
d589 6
a594 2
print_record_field_types (struct type *type, struct type *outer_type,
			  struct ui_file *stream, int show, int level)
d638 5
a642 1
print_record_type (struct type* type0, struct ui_file* stream, int show, int level)
d727 4
a730 1
print_func_type (struct type *type, struct ui_file *stream, char* name)
d780 6
a785 2
ada_print_type (struct type* type0, char* varstring, struct ui_file* stream,
		int show, int level)
@


1.1.4.3
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@d38 1
a38 1
#include "gdb_string.h"
d41 1
a41 1
static int print_record_field_types (struct type *, struct type *,
d44 1
a44 1
static void print_array_type (struct type *, struct ui_file *, int, int);
d46 1
a46 2
static void print_choices (struct type *, int, struct ui_file *,
			   struct type *);
d48 1
a48 1
static void print_range (struct type *, struct ui_file *);
d50 1
a50 2
static void print_range_bound (struct type *, char *, int *,
			       struct ui_file *);
d52 5
a56 3
static void
print_dynamic_range_bound (struct type *, const char *, int,
			   const char *, struct ui_file *);
a57 1
static void print_range_type_named (char *, struct ui_file *);
d60 1
a60 2

static char *name_buffer;
d66 1
a66 1
static char *
d71 1
a71 1
  else
d73 2
a74 2
      char *raw_name = ada_type_name (type);
      char *s, *q;
d83 1
a83 1
      s = (char *) strstr (name_buffer, "___");
d94 1
a94 1
      if (!islower (s[1]))
d101 1
a101 2
	      *q = '.';
	      s += 2;
d105 1
a105 2
	      *q = *s;
	      s += 1;
d119 1
a119 2
ada_typedef_print (struct type *type, struct symbol *new,
		   struct ui_file *stream)
d121 3
a123 3
  fprintf_filtered (stream, "type %.*s is ",
		    ada_name_prefix_len (SYMBOL_SOURCE_NAME (new)),
		    SYMBOL_SOURCE_NAME (new));
d130 1
a130 1
print_range (struct type *type, struct ui_file *stream)
d132 1
a132 1
  struct type *target_type;
d137 1
a137 1
  switch (TYPE_CODE (target_type))
d159 2
a160 2
			ada_name_prefix_len (TYPE_NAME (type)),
			TYPE_NAME (type));
d168 1
a168 1
	(LONGEST) TYPE_FIELD_BITPOS (type, TYPE_NFIELDS (type) - 1);
d180 1
a180 2
print_range_bound (struct type *type, char *bounds, int *n,
		   struct ui_file *stream)
d192 2
a193 2
      char *bound = bounds + *n;
      char *pend;
d198 1
a198 1
      else
d212 1
a212 2
print_dynamic_range_bound (struct type *type, const char *name, int name_len,
			   const char *suffix, struct ui_file *stream)
d233 1
a233 1
print_range_type_named (char *name, struct ui_file *stream)
d238 1
a238 1
  char *subtype_info;
d262 1
a262 1
      if (*subtype_info == 'L')
d268 1
a268 2
	print_dynamic_range_bound (raw_type, name, prefix_len, "___L",
				   stream);
d272 1
a272 1
      if (*subtype_info == 'U')
d275 1
a275 2
	print_dynamic_range_bound (raw_type, name, prefix_len, "___U",
				   stream);
d277 1
a277 1
}
d294 1
a294 2
      if (i)
	fprintf_filtered (stream, ", ");
d320 1
a320 1
      if (delta != small)
d340 1
a340 2
print_array_type (struct type *type, struct ui_file *stream, int show,
		  int level)
d349 1
a349 1
  if (show < 0)
d355 1
a355 1
      if (ada_is_simple_array (type))
d357 1
a357 1
	  struct type *range_desc_type =
d359 1
a359 1
	  struct type *arr_type;
d374 1
a374 1
	  else
d377 2
a378 2
	      n_indices = TYPE_NFIELDS (range_desc_type);
	      for (k = 0, arr_type = type;
d384 2
a385 2
		  print_range_type_named (TYPE_FIELD_NAME
					  (range_desc_type, k), stream);
d388 1
a388 1
		}
d391 1
a391 1
      else
d401 2
a402 2
  ada_print_type (ada_array_element_type (type, n_indices), "", stream,
		  show == 0 ? 0 : show - 1, level + 1);
d411 1
a411 2
print_choices (struct type *type, int field_num, struct ui_file *stream,
	       struct type *val_type)
d415 1
a415 1
  const char *name = TYPE_FIELD_NAME (type, field_num);
d422 1
a422 1
      if (!ada_scan_number (name, 1, NULL, &p))
d430 1
a430 1
      switch (name[p])
d437 1
a437 1
	  if (have_output)
d443 1
a443 1
      switch (name[p])
d448 1
a448 1
	    if (!ada_scan_number (name, p + 1, &W, &p))
d456 3
a458 2
	    if (!ada_scan_number (name, p + 1, &L, &p)
		|| name[p] != 'T' || !ada_scan_number (name, p + 1, &U, &p))
d501 1
a501 1
      if (TYPE_FLAGS (var_type) & TYPE_FLAG_STUB)
d509 1
a509 1
  for (i = 0; i < TYPE_NFIELDS (var_type); i += 1)
d514 2
a515 2
      if (print_record_field_types (TYPE_FIELD_TYPE (var_type, i),
				    outer_type, stream, show, level + 4) <= 0)
d533 3
a535 4
		    ada_variant_discrim_name
		    (TYPE_FIELD_TYPE (type, field_num)));
  print_variant_clauses (type, field_num, outer_type, stream, show,
			 level + 4);
d564 2
a565 1
      if (ada_is_parent_field (type, i) || ada_is_ignored_field (type, i))
d570 1
a570 1
      else if (ada_is_variant_part (type, i))
d594 1
a594 2
print_record_type (struct type *type0, struct ui_file *stream, int show,
		   int level)
d596 3
a598 3
  struct type *parent_type;
  struct type *type;

d602 1
a602 1
      struct type *type1 = ada_find_parallel_type (type, "___XVE");
d608 2
a609 2
  if (ada_type_name (parent_type) != NULL)
    fprintf_filtered (stream, "new %s with ",
d624 1
a624 1
	flds += print_record_field_types (parent_type, parent_type,
d627 1
a627 1

d630 1
a630 1
      else if (flds < 0)
d632 1
a632 1
      else
d642 1
a642 1
print_unchecked_union_type (struct type *type, struct ui_file *stream,
d649 1
a649 1
  else if (TYPE_NFIELDS (type) == 0)
d655 2
a656 1
      fprintf_filtered (stream, "\n%*scase ? is", level + 4, "");
d658 1
a658 1
      for (i = 0; i < TYPE_NFIELDS (type); i += 1)
d660 2
a661 2
	  fprintf_filtered (stream, "\n%*swhen ? =>\n%*s", level + 8, "",
			    level + 12, "");
d668 2
a669 2
      fprintf_filtered (stream, "\n%*send case;\n%*send record",
			level + 4, "", level, "");
d672 1
a672 1

d679 1
a679 1
print_func_type (struct type *type, struct ui_file *stream, char *name)
d688 1
a688 1
  if (name != NULL && name[0] != '\0')
d691 1
a691 1
  if (len > 0)
d701 1
a701 1
	  fprintf_filtered (stream, "a%d: ", i + 1);
d705 1
a705 1
    }
d729 1
a729 1
ada_print_type (struct type *type0, char *varstring, struct ui_file *stream,
d734 2
a735 2
  struct type *type = ada_completed_type (ada_get_base_type (type0));
  char *type_name = demangled_type_name (type);
d742 2
a743 1
			  ada_name_prefix_len (varstring), varstring);
d749 1
a749 1
    CHECK_TYPEDEF (type);
d752 2
a753 2
    fprintf_filtered (stream, "%.*s: ",
		      ada_name_prefix_len (varstring), varstring);
d757 1
a757 1
      fprintf_filtered (stream, "%.*s",
d767 61
a827 16
    switch (TYPE_CODE (type))
      {
      default:
	fprintf_filtered (stream, "<");
	c_print_type (type, "", stream, show, level);
	fprintf_filtered (stream, ">");
	break;
      case TYPE_CODE_PTR:
	fprintf_filtered (stream, "access ");
	ada_print_type (TYPE_TARGET_TYPE (type), "", stream, show, level);
	break;
      case TYPE_CODE_REF:
	fprintf_filtered (stream, "<ref> ");
	ada_print_type (TYPE_TARGET_TYPE (type), "", stream, show, level);
	break;
      case TYPE_CODE_ARRAY:
d829 12
a840 57
	break;
      case TYPE_CODE_INT:
	if (ada_is_fixed_point_type (type))
	  print_fixed_point_type (type, stream);
	else if (ada_is_vax_floating_type (type))
	  print_vax_floating_point_type (type, stream);
	else
	  {
	    char *name = ada_type_name (type);
	    if (!ada_is_range_type_name (name))
	      fprintf_filtered (stream, "<%d-byte integer>",
				TYPE_LENGTH (type));
	    else
	      {
		fprintf_filtered (stream, "range ");
		print_range_type_named (name, stream);
	      }
	  }
	break;
      case TYPE_CODE_RANGE:
	if (ada_is_fixed_point_type (type))
	  print_fixed_point_type (type, stream);
	else if (ada_is_vax_floating_type (type))
	  print_vax_floating_point_type (type, stream);
	else if (ada_is_modular_type (type))
	  fprintf_filtered (stream, "mod %ld", (long) ada_modulus (type));
	else
	  {
	    fprintf_filtered (stream, "range ");
	    print_range (type, stream);
	  }
	break;
      case TYPE_CODE_FLT:
	fprintf_filtered (stream, "<%d-byte float>", TYPE_LENGTH (type));
	break;
      case TYPE_CODE_ENUM:
	if (show < 0)
	  fprintf_filtered (stream, "(...)");
	else
	  print_enum_type (type, stream);
	break;
      case TYPE_CODE_STRUCT:
	if (ada_is_array_descriptor (type))
	  print_array_type (type, stream, show, level);
	else if (ada_is_bogus_array_descriptor (type))
	  fprintf_filtered (stream,
			    "array (?) of ? (<mal-formed descriptor>)");
	else
	  print_record_type (type, stream, show, level);
	break;
      case TYPE_CODE_UNION:
	print_unchecked_union_type (type, stream, show, level);
	break;
      case TYPE_CODE_FUNC:
	print_func_type (type, stream, varstring);
	break;
      }
@


1.1.2.1
log
@merge from trunk
@
text
@@

