head	1.22;
access;
symbols
	insight_7_6-2013-04-10-branchpoint:1.20
	gdb_7_6-branch:1.20.0.4
	gdb_7_5-branch:1.20.0.2
	gdb_7_4-branch:1.19.0.4
	gdb_7_3-branch:1.19.0.2
	gdb_7_1-branch:1.18.0.4
	gdb_7_0-branch:1.18.0.2
	arc-sim-20090309:1.15
	arc-insight_6_8-branch:1.15.0.6
	arc-insight_6_8-branchpoint:1.15
	insight_6_8-branch:1.15.0.4
	insight_6_8-branchpoint:1.15
	gdb_6_8-branch:1.15.0.2
	insight_6_6-20070208-release:1.13
	gdb_6_6-branch:1.13.0.4
	gdb_6_6-2006-11-15-branchpoint:1.13
	insight_6_5-20061003-release:1.13
	gdb_6_5-branch:1.13.0.2
	gdb_6_5-2006-05-14-branchpoint:1.13
	gdb-csl-gxxpro-6_3-branch:1.12.0.4
	gdb-csl-gxxpro-6_3-branchpoint:1.12
	gdb_6_4-branch:1.12.0.2
	gdb_6_4-2005-11-01-branchpoint:1.12
	gdb_6_1-2004-04-05-release:1.9
	gdb_6_1-branch:1.9.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.9
	gdb_6_0-2003-10-04-release:1.9
	gdb_6_0-branch:1.9.0.2
	gdb_6_0-2003-06-23-branchpoint:1.9
	gdb_5_3-2002-12-12-release:1.8
	gdb_5_3-branch:1.8.0.2
	gdb_5_3-2002-09-04-branchpoint:1.8
	gdb_5_2_1-2002-07-23-release:1.5
	gdb_5_2-2002-04-29-release:1.5
	gdb_5_2-branch:1.5.0.2
	gdb_5_2-2002-03-03-branchpoint:1.5
	gdb_5_1_1-2002-01-24-release:1.4
	cygnus_cvs_20020108_pre:1.4
	gdb_5_1_0_1-2002-01-03-branch:1.4.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.4
	gdb_5_1-2001-11-21-release:1.4
	gdb_s390-2001-09-26-branch:1.4.0.6
	gdb_s390-2001-09-26-branchpoint:1.4
	gdb_5_1-2001-07-29-branch:1.4.0.4
	gdb_5_1-2001-07-29-branchpoint:1.4
	dberlin-typesystem-branch:1.4.0.2
	dberlin-typesystem-branchpoint:1.4
	insight-precleanup-2001-01-01:1.4
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.2
	repo-unification-2000-02-06:1.1.1.1
	insight-2000-02-04:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.22
date	2013.07.15.07.42.21;	author rosch;	state Exp;
branches;
next	1.21;

1.21
date	2013.07.02.17.07.29;	author kseitz;	state Exp;
branches;
next	1.20;

1.20
date	2012.08.08.13.50.32;	author rosch;	state Exp;
branches;
next	1.19;

1.19
date	2010.06.18.22.25.26;	author muller;	state Exp;
branches;
next	1.18;

1.18
date	2008.12.15.18.06.12;	author kevinb;	state Exp;
branches;
next	1.17;

1.17
date	2008.07.14.23.43.36;	author kseitz;	state Exp;
branches;
next	1.16;

1.16
date	2008.05.12.07.24.54;	author muller;	state Exp;
branches;
next	1.15;

1.15
date	2008.03.07.08.03.19;	author kseitz;	state Exp;
branches;
next	1.14;

1.14
date	2007.04.27.15.39.50;	author macro;	state Exp;
branches;
next	1.13;

1.13
date	2005.12.23.18.23.16;	author eliz;	state Exp;
branches;
next	1.12;

1.12
date	2005.05.27.01.30.53;	author kseitz;	state Exp;
branches;
next	1.11;

1.11
date	2005.01.18.00.14.39;	author kseitz;	state Exp;
branches;
next	1.10;

1.10
date	2004.11.19.00.19.56;	author kseitz;	state Exp;
branches;
next	1.9;

1.9
date	2003.02.20.12.12.33;	author muller;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.04.19.08.32;	author cagney;	state Exp;
branches;
next	1.7;

1.7
date	2002.04.21.22.52.41;	author cagney;	state Exp;
branches;
next	1.6;

1.6
date	2002.04.09.01.51.08;	author cagney;	state Exp;
branches;
next	1.5;

1.5
date	2002.02.07.05.05.06;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.02.20.07.07;	author kevinb;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.17.20.20.59;	author jlarmour;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.24.03.11.47;	author kseitz;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.07.00.19.42;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.07.00.19.42;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.22
log
@2013-07-15  Roland Schwingel  <roland.schwingel@@onevision.com>

   * generic/gdbtk-register.c (get_register): Update
   to reflect changes from upstream gdb. Prettyprinting
   becomes prettyformatting now.
   * generic/gdbtk-wrapper.c (GDB_val_print,wrap_val_print):
   Likewise.
   * generic/gdbtk-wrapper.h (GDB_val_print): Likewise.
@
text
@/* longjmp-free interface between gdb and gdbtk.
   Copyright (C) 1999, 2000, 2002, 2008, 2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */

#include "defs.h"
#include "frame.h"
#include "value.h"
#include "varobj.h"
#include "block.h"
#include "exceptions.h"
#include "language.h"
#include "valprint.h"
#include "gdbtk-wrapper.h"

/*
 * Wrapper functions exported to the world
 */

gdb_result GDB_value_fetch_lazy (value_ptr);

gdb_result GDB_evaluate_expression (struct expression *, value_ptr *);

gdb_result GDB_type_print (value_ptr, char *, struct ui_file *, int);

gdb_result GDB_val_print (struct type *type, char *valaddr,
			  CORE_ADDR address, struct ui_file *stream,
			  int format, int deref_ref, int recurse,
			  enum val_prettyformat pretty);

gdb_result GDB_value_equal (value_ptr, value_ptr, int *);

/*
gdb_result GDB_parse_exp_1 (char **stringptr, struct block *block, int comma,
			    struct expression **result);
*/

gdb_result GDB_evaluate_type (struct expression *exp, value_ptr * result);

gdb_result GDB_block_for_pc (CORE_ADDR pc, struct block **result);

gdb_result GDB_block_innermost_frame (struct block *block,
				      struct frame_info **result);

gdb_result GDB_reinit_frame_cache (void);

gdb_result GDB_value_ind (value_ptr val, value_ptr * rval);

gdb_result GDB_value_slice (value_ptr val, int low, int num,
			    value_ptr * rval);

gdb_result GDB_value_coerce_array (value_ptr val, value_ptr * rval);

gdb_result GDB_value_struct_elt (value_ptr * argp, value_ptr * args,
				 char *name, int *static_memfunc,
				 char *err, value_ptr * rval);

gdb_result GDB_value_cast (struct type *type, value_ptr val,
			   value_ptr * rval);

gdb_result GDB_get_frame_block (struct frame_info *fi, struct block **rval);

gdb_result GDB_get_prev_frame (struct frame_info *fi,
			       struct frame_info **result);

gdb_result GDB_get_next_frame (struct frame_info *fi,
			       struct frame_info **result);

gdb_result GDB_find_relative_frame (struct frame_info *fi,
				    int *start, struct frame_info **result);

gdb_result GDB_get_current_frame (struct frame_info **result);

gdb_result GDB_varobj_update (struct varobj **varp, int explicit,
			      VEC (varobj_update_result) **changes);

/*
 * Private functions for this file
 */
static gdb_result call_wrapped_function (catch_errors_ftype *,
					 struct gdb_wrapper_arguments *);

static int wrap_type_print (char *);

static int wrap_evaluate_expression (char *);

static int wrap_value_fetch_lazy (char *);

static int wrap_val_print (char *);

static int wrap_value_equal (char *);

/*
static int wrap_parse_exp_1 (char *opaque_arg);
*/

static int wrap_evaluate_type (char *opaque_arg);

static int wrap_block_for_pc (char *opaque_arg);

static int wrap_block_innermost_frame (char *opaque_arg);

static int wrap_reinit_frame_cache (char *opaque_arg);

static int wrap_value_ind (char *opaque_arg);

static int wrap_value_slice (char *opaque_arg);

static int wrap_value_coerce_array (char *opaque_arg);

static int wrap_value_struct_elt (char *opaque_arg);

static int wrap_value_cast (char *opaque_arg);

static int wrap_get_frame_block (char *opaque_arg);

static int wrap_get_prev_frame (char *opaque_arg);

static int wrap_get_next_frame (char *opaque_arg);

static int wrap_find_relative_frame (char *opaque_arg);

static int wrap_get_current_frame (char *opaque_arg);

static int wrap_varobj_update (char *opaque_arg);

static gdb_result
call_wrapped_function (catch_errors_ftype *fn, struct gdb_wrapper_arguments *arg)
{
  if (!catch_errors (fn, (char *) &arg, "", RETURN_MASK_ERROR))
    {
      /* An error occurred */
      return GDB_ERROR;
    }

  return GDB_OK;
}

gdb_result
GDB_type_print (value_ptr val, char *varstring,
		struct ui_file *stream, int show)
{
  struct gdb_wrapper_arguments args;

  args.args[0].ptr = val;
  args.args[1].ptr = varstring;
  args.args[2].ptr = stream;
  args.args[3].integer = show;
  return call_wrapped_function ((catch_errors_ftype *) wrap_type_print, &args);
}

static int
wrap_type_print (char *a)
{
  struct gdb_wrapper_arguments **args = (struct gdb_wrapper_arguments **) a;
  value_ptr val = (value_ptr) (*args)->args[0].ptr;
  char *varstring = (*args)->args[1].ptr;
  struct ui_file *stream = (struct ui_file *) (*args)->args[2].ptr;
  int show = (*args)->args[3].integer;
  type_print (value_type (val), varstring, stream, show);
  return 1;
}

gdb_result
GDB_val_print (struct type *type,
	       char *valaddr,
	       CORE_ADDR address,
	       struct ui_file *stream,
	       int format,
	       int deref_ref,
	       int recurse,
	       enum val_prettyformat pretty)
{
  struct gdb_wrapper_arguments args;

  args.args[0].ptr = type;
  args.args[1].ptr = valaddr;
  args.args[2].ptr = &address;
  args.args[3].ptr = stream;
  args.args[4].integer = format;
  args.args[5].integer = deref_ref;
  args.args[6].integer = recurse;
  args.args[7].integer = pretty;

  return call_wrapped_function ((catch_errors_ftype *) wrap_val_print, &args);
}

static int
wrap_val_print (char *a)
{
  struct gdb_wrapper_arguments **args = (struct gdb_wrapper_arguments **) a;
  struct type *type;
  const gdb_byte *valaddr;
  CORE_ADDR address;
  struct ui_file *stream;
  int format;
  int recurse;
  struct value_print_options opts;

  type = (struct type *) (*args)->args[0].ptr;
  valaddr = (gdb_byte *) (*args)->args[1].ptr;
  address = *(CORE_ADDR *) (*args)->args[2].ptr;
  stream = (struct ui_file *) (*args)->args[3].ptr;
  format = (*args)->args[4].integer;
  get_formatted_print_options (&opts, format);
  opts.deref_ref = (*args)->args[5].integer;
  recurse = (*args)->args[6].integer;
  opts.prettyformat = (enum val_prettyformat) (*args)->args[7].integer;

  val_print (type, valaddr, 0, address, stream, recurse, NULL, &opts,
             current_language);
  return 1;
}

gdb_result
GDB_value_fetch_lazy (value_ptr value)
{
  struct gdb_wrapper_arguments args;

  args.args[0].ptr = value;
  return call_wrapped_function ((catch_errors_ftype *) wrap_value_fetch_lazy, &args);
}

static int
wrap_value_fetch_lazy (char *a)
{
  struct gdb_wrapper_arguments **args = (struct gdb_wrapper_arguments **) a;

  value_fetch_lazy ((value_ptr) (*args)->args[0].ptr);
  return 1;
}

gdb_result
GDB_evaluate_expression (struct expression *exp, value_ptr *value)
{
  struct gdb_wrapper_arguments args;
  gdb_result result;
  args.args[0].ptr = exp;

  result = call_wrapped_function ((catch_errors_ftype *) wrap_evaluate_expression, &args);
  if (result != GDB_OK)
    return result;

  *value = (value_ptr) args.result.ptr;
  return GDB_OK;
}

static int
wrap_evaluate_expression (char *a)
{
  struct gdb_wrapper_arguments **args = (struct gdb_wrapper_arguments **) a;

  (*args)->result.ptr =
    evaluate_expression ((struct expression *) (*args)->args[0].ptr);
  return 1;
}

gdb_result
GDB_value_equal (value_ptr val1, value_ptr val2, int *result)
{
  struct gdb_wrapper_arguments args;
  gdb_result r;

  args.args[0].ptr = val1;
  args.args[1].ptr = val2;

  r = call_wrapped_function ((catch_errors_ftype *) wrap_value_equal, &args);
  if (r != GDB_OK)
    return r;

  *result = args.result.integer;
  return GDB_OK;
}

static int
wrap_value_equal (char *a)
{
  struct gdb_wrapper_arguments **args = (struct gdb_wrapper_arguments **) a;
  value_ptr val1, val2;

  val1 = (value_ptr) (*args)->args[0].ptr;
  val2 = (value_ptr) (*args)->args[1].ptr;

  (*args)->result.integer = value_equal (val1, val2);
  return 1;
}

/*
gdb_result
GDB_parse_exp_1 (char **stringptr, struct block *block,
		 int comma, struct expression **result)
{
  struct gdb_wrapper_arguments args;
  gdb_result r;

  args.args[0].ptr = stringptr;
  args.args[1].ptr = block;
  args.args[2].integer = comma;

  r = call_wrapped_function ((catch_errors_ftype *) wrap_parse_exp_1, &args);
  if (r != GDB_OK)
    return r;

  *result = (struct expression *) args.result.ptr;
  return GDB_OK;
}

static int
wrap_parse_exp_1 (char *opaque_arg)
{
  struct gdb_wrapper_arguments **args = (struct gdb_wrapper_arguments **) opaque_arg;
  struct block *block;
  char **stringptr;
  int comma;

  stringptr = (char **) (*args)->args[0].ptr;
  block = (struct block *) (*args)->args[1].ptr;
  comma = (*args)->args[2].integer;

  (*args)->result.ptr = parse_exp_1 (stringptr, block, comma);
  return 1;
}
*/

gdb_result
GDB_evaluate_type (struct expression *exp, value_ptr *result)
{
  struct gdb_wrapper_arguments args;
  gdb_result r;

  args.args[0].ptr = exp;

  r = call_wrapped_function ((catch_errors_ftype *) wrap_evaluate_type, &args);
  if (r != GDB_OK)
    return r;

  *result = (value_ptr) args.result.ptr;
  return GDB_OK;
}

static int
wrap_evaluate_type (char *opaque_arg)
{
  struct gdb_wrapper_arguments **args = (struct gdb_wrapper_arguments **) opaque_arg;
  struct expression *exp;

  exp = (struct expression *) (*args)->args[0].ptr;
  (*args)->result.ptr = evaluate_type (exp);
  return 1;
}

gdb_result
GDB_block_for_pc (CORE_ADDR pc, struct block **result)
{
  struct gdb_wrapper_arguments args;
  gdb_result r;

  args.args[0].ptr = &pc;

  r = call_wrapped_function ((catch_errors_ftype *) wrap_block_for_pc, &args);
  if (r != GDB_OK)
    return r;

  *result = (struct block *) args.result.ptr;
  return GDB_OK;
}

static int
wrap_block_for_pc (char *opaque_arg)
{
  struct gdb_wrapper_arguments **args = (struct gdb_wrapper_arguments **) opaque_arg;
  CORE_ADDR pc;

  pc = *(CORE_ADDR *) (*args)->args[0].ptr;
  (*args)->result.ptr = block_for_pc (pc);
  return 1;
}

gdb_result
GDB_block_innermost_frame (struct block *block, struct frame_info **result)
{
  struct gdb_wrapper_arguments args;
  gdb_result r;

  args.args[0].ptr = block;

  r = call_wrapped_function ((catch_errors_ftype *) wrap_block_innermost_frame, &args);
  if (r != GDB_OK)
    return r;

  *result = (struct frame_info *) args.result.ptr;
  return GDB_OK;
}

static int
wrap_block_innermost_frame (char *opaque_arg)
{
  struct gdb_wrapper_arguments **args = (struct gdb_wrapper_arguments **) opaque_arg;
  struct block *block;

  block = (struct block *) (*args)->args[0].ptr;
  (*args)->result.ptr = block_innermost_frame (block);
  return 1;
}

gdb_result
GDB_reinit_frame_cache (void)
{
  gdb_result r;

  r = call_wrapped_function ((catch_errors_ftype *) wrap_reinit_frame_cache, NULL);
  if (r != GDB_OK)
    return r;

  return GDB_OK;
}

static int
wrap_reinit_frame_cache (char *opaque_arg)
{
  reinit_frame_cache ();
  return 1;
}

gdb_result
GDB_value_ind (value_ptr val, value_ptr *rval)
{
  struct gdb_wrapper_arguments args;
  gdb_result r;

  args.args[0].ptr = val;

  r = call_wrapped_function ((catch_errors_ftype *) wrap_value_ind, &args);
  if (r != GDB_OK)
    return r;

  *rval = (value_ptr) args.result.ptr;
  return GDB_OK;
}

static int
wrap_value_ind (char *opaque_arg)
{
  struct gdb_wrapper_arguments **args = (struct gdb_wrapper_arguments **) opaque_arg;
  value_ptr val;

  val = (value_ptr) (*args)->args[0].ptr;
  (*args)->result.ptr = value_ind (val);
  return 1;
}

gdb_result
GDB_value_slice (value_ptr val, int low, int num, value_ptr *rval)
{
  struct gdb_wrapper_arguments args;
  gdb_result r;

  args.args[0].ptr = val;
  args.args[1].integer = low;
  args.args[2].integer = num;

  r = call_wrapped_function ((catch_errors_ftype *) wrap_value_slice, &args);
  if (r != GDB_OK)
    return r;

  *rval = (value_ptr) args.result.ptr;
  return GDB_OK;
}

static int
wrap_value_slice (char *opaque_arg)
{
  struct gdb_wrapper_arguments **args = (struct gdb_wrapper_arguments **) opaque_arg;
  value_ptr val;
  int low, num;

  val = (value_ptr) (*args)->args[0].ptr;
  low = (*args)->args[1].integer;
  num = (*args)->args[2].integer;
  (*args)->result.ptr = value_slice (val, low, num);
  return 1;
}

gdb_result
GDB_value_coerce_array (value_ptr val, value_ptr *rval)
{
  struct gdb_wrapper_arguments args;
  gdb_result r;

  args.args[0].ptr = val;

  r = call_wrapped_function ((catch_errors_ftype *) wrap_value_coerce_array,
			     &args);
  if (r != GDB_OK)
    return r;

  *rval = (value_ptr) args.result.ptr;
  return GDB_OK;
}

static int
wrap_value_coerce_array (char *opaque_arg)
{
  struct gdb_wrapper_arguments **args = (struct gdb_wrapper_arguments **) opaque_arg;
  value_ptr val;

  val = (value_ptr) (*args)->args[0].ptr;
  (*args)->result.ptr = value_coerce_array (val);
  return 1;
}

gdb_result
GDB_value_struct_elt (value_ptr *argp,
		      value_ptr *args,
		      char *name,
		      int *static_memfunc,
		      char *err,
		      value_ptr *rval)
{
  struct gdb_wrapper_arguments argss;
  gdb_result r;

  argss.args[0].ptr = argp;
  argss.args[1].ptr = args;
  argss.args[2].ptr = name;
  argss.args[3].ptr = static_memfunc;
  argss.args[4].ptr = err;
  r = call_wrapped_function ((catch_errors_ftype *) wrap_value_struct_elt, &argss);
  if (r != GDB_OK)
    return r;

  *rval = (value_ptr) argss.result.ptr;
  return GDB_OK;
}

static int
wrap_value_struct_elt (char *opaque_arg)
{
  struct gdb_wrapper_arguments **argss = (struct gdb_wrapper_arguments **) opaque_arg;
  value_ptr *argp, *args;
  char *name;
  int *static_memfunc;
  char *err;

  argp = (value_ptr *) (*argss)->args[0].ptr;
  args = (value_ptr *) (*argss)->args[1].ptr;
  name = (char *) (*argss)->args[2].ptr;
  static_memfunc = (int *) (*argss)->args[3].ptr;
  err = (char *) (*argss)->args[4].ptr;

  (*argss)->result.ptr = value_struct_elt (argp, args, name, static_memfunc, err);
  return 1;
}

gdb_result
GDB_value_cast (struct type *type, value_ptr val, value_ptr *rval)
{
  struct gdb_wrapper_arguments args;
  gdb_result r;

  args.args[0].ptr = type;
  args.args[1].ptr = val;

  r = call_wrapped_function ((catch_errors_ftype *) wrap_value_cast, &args);
  if (r != GDB_OK)
    return r;

  *rval = (value_ptr) args.result.ptr;
  return GDB_OK;
}

static int
wrap_value_cast (char *opaque_arg)
{
  struct gdb_wrapper_arguments **args = (struct gdb_wrapper_arguments **) opaque_arg;
  value_ptr val;
  struct type *type;

  type = (struct type *) (*args)->args[0].ptr;
  val = (value_ptr) (*args)->args[1].ptr;
  (*args)->result.ptr = value_cast (type, val);

  return 1;
}

gdb_result
GDB_get_frame_block (struct frame_info *fi, struct block **rval)
{
  struct gdb_wrapper_arguments args;
  gdb_result r;

  args.args[0].ptr = fi;

  r = call_wrapped_function ((catch_errors_ftype *) wrap_get_frame_block, &args);
  if (r != GDB_OK)
    return r;

  *rval = (struct block *) args.result.ptr;
  return GDB_OK;
}

static int
wrap_get_frame_block (char *opaque_arg)
{
  struct gdb_wrapper_arguments **args = (struct gdb_wrapper_arguments **) opaque_arg;
  struct frame_info *fi;

  fi = (struct frame_info *) (*args)->args[0].ptr;
  (*args)->result.ptr = get_frame_block (fi, NULL);

  return 1;
}

gdb_result
GDB_get_prev_frame (struct frame_info *fi, struct frame_info **result)
{
  struct gdb_wrapper_arguments args;
  gdb_result r;

  args.args[0].ptr = fi;
  r = call_wrapped_function ((catch_errors_ftype *) wrap_get_prev_frame, &args);
  if (r != GDB_OK)
    return r;

  *result = (struct frame_info *) args.result.ptr;
  return GDB_OK;
}

static int
wrap_get_prev_frame (char *opaque_arg)
{
  struct gdb_wrapper_arguments **args = (struct gdb_wrapper_arguments **) opaque_arg;
  struct frame_info *fi = (struct frame_info *) (*args)->args[0].ptr;

  (*args)->result.ptr = get_prev_frame (fi);
  return 1;
}

gdb_result
GDB_get_next_frame (struct frame_info *fi, struct frame_info **result)
{
  struct gdb_wrapper_arguments args;
  gdb_result r;

  args.args[0].ptr = fi;
  r = call_wrapped_function ((catch_errors_ftype *) wrap_get_next_frame, &args);
  if (r != GDB_OK)
    return r;

  *result = (struct frame_info *) args.result.ptr;
  return GDB_OK;
}

static int
wrap_get_next_frame (char *opaque_arg)
{
  struct gdb_wrapper_arguments **args = (struct gdb_wrapper_arguments **) opaque_arg;
  struct frame_info *fi = (struct frame_info *) (*args)->args[0].ptr;

  (*args)->result.ptr = get_next_frame (fi);
  return 1;
}

gdb_result
GDB_find_relative_frame (struct frame_info *fi, int *start,
			 struct frame_info **result)
{
  struct gdb_wrapper_arguments args;
  gdb_result r;

  args.args[0].ptr = fi;
  args.args[1].ptr = start;

  r = call_wrapped_function ((catch_errors_ftype *) wrap_find_relative_frame, 
			     &args);
  if (r != GDB_OK)
    return r;

  *result = (struct frame_info *) args.result.ptr;
  return GDB_OK;
}

static int
wrap_find_relative_frame (char *opaque_arg)
{
  struct gdb_wrapper_arguments **args = (struct gdb_wrapper_arguments **) opaque_arg;
  struct frame_info *fi = (struct frame_info *) (*args)->args[0].ptr;
  int *start = (int *) (*args)->args[1].ptr;

  (*args)->result.ptr = find_relative_frame (fi, start);
  return 1;
}

gdb_result
GDB_get_current_frame (struct frame_info **result)
{
  struct gdb_wrapper_arguments args;
  gdb_result r;

  r = call_wrapped_function ((catch_errors_ftype *) wrap_get_current_frame, 
			     &args);
  if (r != GDB_OK)
    return r;

  *result = (struct frame_info *) args.result.ptr;
  return GDB_OK;
}

static int
wrap_get_current_frame (char *opaque_arg)
{
  struct gdb_wrapper_arguments **args = (struct gdb_wrapper_arguments **) opaque_arg;

  (*args)->result.ptr = get_current_frame ();
  return 1;
}

gdb_result
GDB_varobj_update (struct varobj **varp, int explicit,
		   VEC (varobj_update_result) **changes)
{
  struct gdb_wrapper_arguments args;
  gdb_result r;

  args.args[0].ptr = varp;
  args.args[1].integer = explicit;

  r = call_wrapped_function ((catch_errors_ftype *) wrap_varobj_update, &args);
  if (r != GDB_OK)
    return r;

  *changes = args.result.ptr;
  return GDB_OK;
}

static int wrap_varobj_update (char *opaque_arg)
{
  struct gdb_wrapper_arguments **args
    = (struct gdb_wrapper_arguments **) opaque_arg;
  struct varobj **varp = (struct varobj **) (*args)->args[0].ptr;
  int explicit = (*args)->args[1].integer;
  (*args)->result.ptr = varobj_update (varp, explicit);
  return 1;
}
@


1.21
log
@	* generic/gdbtk-cmds.c (gdb_listfuncs): Update declaration.
	* generic/gdbtk-hooks.c (gdb_two_elem_cmd): Likewise.
	(report_error): Likewise.
	(gdbtk_readline_end, gdbtk_post_add_symbol, gdbtk_error_begin,
	gdbtk_attach): Likewise.
	* generic/gdbtk/gdbtk-register.c (setup_architecture_data):
	Likewise.
	* generic/gdbtk-wrapper.c (GDB_equal_value, GDB_reinit_frame_cache,
	GDB_value-coerce_array): Likewise.
	* generic/gdbtk.c (gdbtk_interactive, gdbtk_start_timer,
	gdbtk_stop_timer, _initialize_gdbtk): Likewise.
@
text
@d44 1
a44 1
			  enum val_prettyprint pretty);
d187 1
a187 1
	       enum val_prettyprint pretty)
d223 1
a223 1
  opts.pretty = (enum val_prettyprint) (*args)->args[7].integer;
@


1.20
log
@	* generic/gdbtk-cmds.c (gdb_load_info): Replace call to
	make_cleanup_bfd_close with make_cleanup_bfd_unref due
	to changes in gdb.
	(gdb_loc): Replace call to decode_line_spec with call to
	decode_line_with_current_source due to changes in gdb.
	* generic/gdbtk-wrapper.c: Comment unused functions
	GDB_parse_exp_1 and wrap_parse_exp_1 as parse_exp_1 has
	changed its interface and the code appears to be unused
	anyway.
	* generic/gdbtk-wrapper.h: ditto
@
text
@d2 1
a2 1
   Copyright (C) 1999, 2000, 2002, 2008 Free Software Foundation, Inc.
d274 1
a274 4
GDB_value_equal (val1, val2, result)
     value_ptr val1;
     value_ptr val2;
     int *result;
d422 1
a422 1
GDB_reinit_frame_cache ()
d500 1
a500 3
GDB_value_coerce_array (val, rval)
     value_ptr val;
     value_ptr *rval;
@


1.19
log
@	* generic/gdbtk-cmds.c: Add cygwin macros to allow compilation
	with old or recent cygwin version.
	(gdb_path_conv): Use cygwin_conv_path function.
	(gdb_eval): Adapt to new field in val_print.
	* generic/gdbtk-register.c (get_register): Likewise.
	* generic/gdbtk-wrapper.c (wrap_val_print): Likewise.
	* generic/gdbtk.c (_initialize_gdbtk): Use cygwin_attach_handle_to_fd
	call to allow compilation with old and new cygwin version.
@
text
@d48 1
d51 1
d108 1
d110 1
d306 1
d341 1
@


1.18
log
@	* generic/gdbtk-cmds.c (valprint.h): Include.
	(gdb_eval): Fetch print options via get_formatted_print_options.
	Update call to val_print.
	(gdb_update_mem): Likewise, but for print_scalar_formatted.
	* generic/gdbtk-register.c (valprint.h): Include.
	(get_register): Use get_formatted_print_options.  Update calls
	to val_print.
	* generic/gdbtk-wrapper.c (valprint.h): Include.
	(wrap_val_print): Use get_formatted_print_options.  Delete
	variables deref_ref and pretty; assign to equivalent fields
	in the value_print_options struct instead.  Update call to
	val_print.
@
text
@d221 1
a221 1
  val_print (type, valaddr, 0, address, stream, recurse, &opts,
@


1.17
log
@        * generic/gdbtk-stack.c (gdb_block_args): Remove deprecated values
        LOC_LOCAL_ARG, LOC_COMPUTED_ARG, LOC_REGPARM, LOC_BASEARG_ARG, and
        LOC_BASEARG.
        (gdb_get_blocks): Likewise.
        (gdb_get_vars_command): Likewise.
        Fix type-punned pointer error introduced on 03-07.

        * generic/gdbtk-cmds.c (gdbtk_load_asm): Use paddress instead
        of deprecated_print_address_numeric.
        (gdb_stop): Update use of target_stop.

        * generic/gdbtk.h (gdbtk_get_ptid): Declare new function.
        * generic/gdbtk-hooks.c (gdbtk_wait): Save inferior's ptid.
        (gdbtk_get_ptid): Define new function.
        * generic/gdbtk-varobj.c (variable_update): Update for recent
        varobj_update API change.
        * generic/gdbtk-wrapper.h (GDB_varobj_update): Likewise.
        * generic/gdbtk-wrapper.c (GDB_varobj_update): Likewise.
        (wrap_varobj_update): Likewise.

        * library/targetselection.itb (init_target_db): Initialize
        preferences here instead of ...
        (_init): ... here.
        (_init_prefs): Define gdb/load/default-portname, too.
@
text
@d28 1
a207 1
  int deref_ref;
d209 1
a209 1
  enum val_prettyprint pretty;
d216 2
a217 1
  deref_ref = (*args)->args[5].integer;
d219 1
a219 1
  pretty = (enum val_prettyprint) (*args)->args[7].integer;
d221 2
a222 2
  val_print (type, valaddr, 0, address, stream, format, deref_ref,
	     recurse, pretty, current_language);
@


1.16
log
@	* Update uses of val_print functions with additional language argument.
	generic/gdbtk-cmds.c: Add "language.h" include.
	(gdb_eval): Add current_language as new arg of val_print.
	generic/gdbtk-register.c: Add "language.h" include.
	(get_register): Add current_language as new arg of val_print.
	generic/gdbtk-wrapper.c: Add "language.h" include.
	(wrap_val_print): Add current_language as new arg of val_print.
@
text
@d2 1
a2 1
   Copyright (C) 1999, 2000, 2002 Free Software Foundation, Inc.
d86 2
a87 3
gdb_result GDB_varobj_update (struct varobj **varp,
			      struct varobj ***changelist, int explicit,
			      int *result);
d732 2
a733 2
GDB_varobj_update (struct varobj **varp, struct varobj ***changelist,
		   int explicit, int *result)
d739 1
a739 2
  args.args[1].ptr = changelist;
  args.args[2].integer = explicit;
d745 1
a745 1
  *result = args.result.integer;
d754 2
a755 4
  struct varobj ***changelist = (struct varobj ***) (*args)->args[1].ptr;
  int explicit = (*args)->args[2].integer;

  (*args)->result.integer = varobj_update (varp, changelist, explicit);
@


1.15
log
@        * generic/gdbtk-register.c (map_arg): New data type
        for passing arguments to mapping functions.
        (map_func): New definition of mapping function.
        Changed all callers to use these new types.
        * generic/gdbtk-stack.c (gdb_get_vars_command): Change
        cast to int to dereference of int *.
        * generic/gdbtk-wrapper.c: Change all casts to char * for
        results and args to use pointer or integer flavor of
        gdb_wrapper_args.results and .args.
        * generic/gdbtk-wrapper.h: struct gdb_wrapper_arguments
        members result and args now return a union of void * and int.
@
text
@d27 1
d222 1
a222 1
	     recurse, pretty);
@


1.14
log
@gdb/:
* Makefile.in (gdbtk-wrapper.o): Update dependencies.
(gdbtk-varobj.o, gdbtk-cmds.o, gdbtk-stack.o): Likewise.

gdb/gdbtk/:
* generic/gdbtk-wrapper.c (GDB_varobj_update): New function.
(wrap_varobj_update): Likewise.
* generic/gdbtk-wrapper.h (GDB_varobj_update): New declaration.
* generic/gdbtk-varobj.c (variable_update): Call
GDB_varobj_update() rather than varobj_update() directly.  Take
the new semantics of the latter into account.
* generic/gdbtk-cmds.c: Include "varobj.h".
* generic/gdbtk-stack.c: Likewise.
@
text
@d155 4
a158 4
  args.args[0] = (char *) val;
  args.args[1] = varstring;
  args.args[2] = (char *) stream;
  args.args[3] = (char *) show;
d166 4
a169 4
  value_ptr val = (value_ptr) (*args)->args[0];
  char *varstring = (*args)->args[1];
  struct ui_file *stream = (struct ui_file *) (*args)->args[2];
  int show = (int) (*args)->args[3];
d186 8
a193 8
  args.args[0] = (char *) type;
  args.args[1] = (char *) valaddr;
  args.args[2] = (char *) &address;
  args.args[3] = (char *) stream;
  args.args[4] = (char *) format;
  args.args[5] = (char *) deref_ref;
  args.args[6] = (char *) recurse;
  args.args[7] = (char *) pretty;
d211 8
a218 8
  type = (struct type *) (*args)->args[0];
  valaddr = (gdb_byte *) (*args)->args[1];
  address = *(CORE_ADDR *) (*args)->args[2];
  stream = (struct ui_file *) (*args)->args[3];
  format = (int) (*args)->args[4];
  deref_ref = (int) (*args)->args[5];
  recurse = (int) (*args)->args[6];
  pretty = (enum val_prettyprint) (*args)->args[7];
d230 1
a230 1
  args.args[0] = (char *) value;
d239 1
a239 1
  value_fetch_lazy ((value_ptr) (*args)->args[0]);
d248 1
a248 1
  args.args[0] = (char *) exp;
d254 1
a254 1
  *value = (value_ptr) args.result;
d263 2
a264 2
  (*args)->result =
    (char *) evaluate_expression ((struct expression *) (*args)->args[0]);
d277 2
a278 2
  args.args[0] = (char *) val1;
  args.args[1] = (char *) val2;
d284 1
a284 1
  *result = (int) args.result;
d294 2
a295 2
  val1 = (value_ptr) (*args)->args[0];
  val2 = (value_ptr) (*args)->args[1];
d297 1
a297 1
  (*args)->result = (char *) value_equal (val1, val2);
d308 3
a310 3
  args.args[0] = (char *) stringptr;
  args.args[1] = (char *) block;
  args.args[2] = (char *) comma;
d316 1
a316 1
  *result = (struct expression *) args.result;
d328 3
a330 3
  stringptr = (char **) (*args)->args[0];
  block = (struct block *) (*args)->args[1];
  comma = (int) (*args)->args[2];
d332 1
a332 1
  (*args)->result = (char *) parse_exp_1 (stringptr, block, comma);
d342 1
a342 1
  args.args[0] = (char *) exp;
d348 1
a348 1
  *result = (value_ptr) args.result;
d358 2
a359 2
  exp = (struct expression *) (*args)->args[0];
  (*args)->result = (char *) evaluate_type (exp);
d369 1
a369 1
  args.args[0] = (char *) &pc;
d375 1
a375 1
  *result = (struct block *) args.result;
d385 2
a386 2
  pc = *(CORE_ADDR *) (*args)->args[0];
  (*args)->result = (char *) block_for_pc (pc);
d396 1
a396 1
  args.args[0] = (char *) block;
d402 1
a402 1
  *result = (struct frame_info *) args.result;
d412 2
a413 2
  block = (struct block *) (*args)->args[0];
  (*args)->result = (char *) block_innermost_frame (block);
d442 1
a442 1
  args.args[0] = (char *) val;
d448 1
a448 1
  *rval = (value_ptr) args.result;
d458 2
a459 2
  val = (value_ptr) (*args)->args[0];
  (*args)->result = (char *) value_ind (val);
d469 3
a471 3
  args.args[0] = (char *) val;
  args.args[1] = (char *) &low;
  args.args[2] = (char *) &num;
d477 1
a477 1
  *rval = (value_ptr) args.result;
d488 4
a491 4
  val = (value_ptr) (*args)->args[0];
  low = *(int *) (*args)->args[1];
  num = *(int *) (*args)->args[2];
  (*args)->result = (char *) value_slice (val, low, num);
d503 1
a503 1
  args.args[0] = (char *) val;
d510 1
a510 1
  *rval = (value_ptr) args.result;
d520 2
a521 2
  val = (value_ptr) (*args)->args[0];
  (*args)->result = (char *) value_coerce_array (val);
d536 5
a540 5
  argss.args[0] = (char *) argp;
  argss.args[1] = (char *) args;
  argss.args[2] = name;
  argss.args[3] = (char *) static_memfunc;
  argss.args[4] = err;
d545 1
a545 1
  *rval = (value_ptr) argss.result;
d558 5
a562 5
  argp = (value_ptr *) (*argss)->args[0];
  args = (value_ptr *) (*argss)->args[1];
  name = (*argss)->args[2];
  static_memfunc = (int *) (*argss)->args[3];
  err = (*argss)->args[4];
d564 1
a564 1
  (*argss)->result = (char *) value_struct_elt (argp, args, name, static_memfunc, err);
d574 2
a575 2
  args.args[0] = (char *) type;
  args.args[1] = (char *) val;
d581 1
a581 1
  *rval = (value_ptr) args.result;
d592 3
a594 3
  type = (struct type *) (*args)->args[0];
  val = (value_ptr) (*args)->args[1];
  (*args)->result = (char *) value_cast (type, val);
d605 1
a605 1
  args.args[0] = (char *) fi;
d611 1
a611 1
  *rval = (struct block *) args.result;
d621 2
a622 2
  fi = (struct frame_info *) (*args)->args[0];
  (*args)->result = (char *) get_frame_block (fi, NULL);
d633 1
a633 1
  args.args[0] = (char *) fi;
d638 1
a638 1
  *result = (struct frame_info *) args.result;
d646 1
a646 1
  struct frame_info *fi = (struct frame_info *) (*args)->args[0];
d648 1
a648 1
  (*args)->result = (char *) get_prev_frame (fi);
d658 1
a658 1
  args.args[0] = (char *) fi;
d663 1
a663 1
  *result = (struct frame_info *) args.result;
d671 1
a671 1
  struct frame_info *fi = (struct frame_info *) (*args)->args[0];
d673 1
a673 1
  (*args)->result = (char *) get_next_frame (fi);
d684 2
a685 2
  args.args[0] = (char *) fi;
  args.args[1] = (char *) start;
d692 1
a692 1
  *result = (struct frame_info *) args.result;
d700 2
a701 2
  struct frame_info *fi = (struct frame_info *) (*args)->args[0];
  int *start = (int *) (*args)->args[1];
d703 1
a703 1
  (*args)->result = (char *) find_relative_frame (fi, start);
d718 1
a718 1
  *result = (struct frame_info *) args.result;
d727 1
a727 1
  (*args)->result = (char *) get_current_frame ();
d738 3
a740 3
  args.args[0] = (char *) varp;
  args.args[1] = (char *) changelist;
  args.args[2] = (char *) explicit;
d746 1
a746 1
  *result = (int) args.result;
d754 3
a756 3
  struct varobj **varp = (struct varobj **) (*args)->args[0];
  struct varobj ***changelist = (struct varobj ***) (*args)->args[1];
  int explicit = (int) (*args)->args[2];
d758 1
a758 1
  (*args)->result = (char *) varobj_update (varp, changelist, explicit);
@


1.13
log
@	* generic/gdbtk.h:
	* generic/gdbtk.c:
	* generic/gdbtk-wrapper.h:
	* generic/gdbtk-wrapper.c:
	* generic/gdbtk-varobj.c:
	* generic/gdbtk-stack.c:
	* generic/gdbtk-register.c:
	* generic/gdbtk-main.c:
	* generic/gdbtk-interp.c:
	* generic/gdbtk-hooks.c:
	* generic/gdbtk-cmds.h:
	* generic/gdbtk-cmds.c:
	* generic/gdbtk-bp.c: Put (C) after Copyright.  Update the FSF
	address.
@
text
@d24 1
d85 4
d134 2
d731 30
@


1.12
log
@        * generic/gdbtk-cmds.c (gdb_set_mem): target_write_memory now takes
        gdb_byte* instead of char*.
        * generic/gdbtk-register.c (get_register): frame_register and val_print
        take gdb_byte* instead of char*.
        * generic/gdbtk-wrapper.c: Ditto the val_print part.

        From Paul Schlie  <schlie@@comcast.net>:
        * generic/gdbtk-bp.c (gdb_set_bp): Use lbasename instead of basename.
        * generic/gdbtk-cmds.c (gdb_listfiles): Likewise.
@
text
@d18 2
a19 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.11
log
@        * generic/gdbtk-varobj.c (variable_value): Remove all instances
        of error_last_message. It's gone.

        * generic/gdbtk-wrapper.c: Include exceptions.h
        * generic/gdbtk-cmds.c: Likewise.
        * generic/gdbtk-interp.c: Likewise.
        (gdbtk_interpreter_exec): Change return type to struct
        exception. Return exception_none.
@
text
@d195 1
a195 1
  char *valaddr;
d204 1
a204 1
  valaddr = (char *) (*args)->args[1];
@


1.10
log
@        * generic/gdbtk-wrapper.c (wrap_type_print): Use value_type instead
        of VALUE_TYPE.
        * generic/gdbtk-cmds.c (gdb_eval): Likewise.
@
text
@d24 1
@


1.9
log
@
2003-02-20  Pierre Muller  <muller@@ics.u-strasbg.fr>

	* generic/gdbtk-cmds.c: Add missing "block.h" include.
	generic/gdbtk-stack.c: Ditto.
	generic/gdbtk-wrapper.c: Ditto.
@
text
@d161 1
a161 1
  type_print (VALUE_TYPE (val), varstring, stream, show);
@


1.8
log
@* generic/gdbtk-wrapper.h (GDB_select_frame): Delete declaration.
* generic/gdbtk-wrapper.c (GDB_select_frame): Delete function.
(wrap_select_frame): Delete function.
@
text
@d23 1
@


1.7
log
@* generic/gdbtk-wrapper.c (GDB_find_frame_addr_in_frame_chain):
Delete function.
(wrap_find_frame_addr_in_frame_chain): Delete function.
* generic/gdbtk-wrapper.h (GDB_find_frame_addr_in_frame_chain):
Delete declaration.
@
text
@a39 2
gdb_result GDB_select_frame (struct frame_info *, int);

a94 2
static int wrap_select_frame (char *);

a254 22
  return 1;
}

gdb_result
GDB_select_frame (struct frame_info *fi, int level)
{
  struct gdb_wrapper_arguments args;

  args.args[0] = (char *) fi;
  args.args[1] = (char *) &level;

  return call_wrapped_function ((catch_errors_ftype *) wrap_select_frame, &args);
}

static int
wrap_select_frame (char *a)
{
  struct gdb_wrapper_arguments **args = (struct gdb_wrapper_arguments **) a;
  int level = *(int *) (*args)->args[1];
  struct frame_info *fi = (struct frame_info *) (*args)->args[0];

  select_frame (fi, level);
@


1.6
log
@* generic/gdbtk-wrapper.c (wrap_get_frame_block): Add missing NULL
parameter.  Match recent get_frame_block changes.
@
text
@a55 3
gdb_result GDB_find_frame_addr_in_frame_chain (CORE_ADDR addr,
					       struct frame_info **result);

a110 2
static int wrap_find_frame_addr_in_frame_chain (char *opaque_arg);

a448 28
  return 1;
}

gdb_result
GDB_find_frame_addr_in_frame_chain (CORE_ADDR addr, 
				    struct frame_info **result)
{
  struct gdb_wrapper_arguments args;
  gdb_result r;

  args.args[0] = (char *) &addr;

  r = call_wrapped_function ((catch_errors_ftype *) wrap_find_frame_addr_in_frame_chain, &args);
  if (r != GDB_OK)
    return r;

  *result = (struct frame_info *) args.result;
  return GDB_OK;
}

static int
wrap_find_frame_addr_in_frame_chain (char *opaque_arg)
{
  struct gdb_wrapper_arguments **args = (struct gdb_wrapper_arguments **) opaque_arg;
  CORE_ADDR addr;

  addr = *(CORE_ADDR *) (*args)->args[0];
  (*args)->result = (char *) find_frame_addr_in_frame_chain (addr);
@


1.5
log
@2002-02-06  Martin M. Hunt  <hunt@@redhat.com>

	* generic/gdbtk.c, generic/gdbtk-bp.c, generic/gdbtk-cmds.c,
	generic/gdbtk-hooks.c, generic/gdbtk-register.c,
	generic/gdbtk-stack.c, generic/gdbtk-varobj.c,
	generic/gdbtk-wrapper.c: Cleanup. Fix indentation. Fix
	function declarations. Remove unused variables. Add 2002
	copyrights.
@
text
@d671 1
a671 1
  (*args)->result = (char *) get_frame_block (fi);
@


1.4
log
@PARAMS elimination.
@
text
@d2 1
a2 1
   Copyright (C) 1999-2000 Free Software Foundation, Inc.
d137 1
a137 3
call_wrapped_function (fn, arg)
     catch_errors_ftype *fn;
     struct gdb_wrapper_arguments *arg;
d149 2
a150 5
GDB_type_print (val, varstring, stream, show)
     value_ptr val;
     char *varstring;
     struct ui_file *stream;
     int show;
d162 1
a162 2
wrap_type_print (a)
     char *a;
d174 8
a181 10
GDB_val_print (type, valaddr, address, stream, format, deref_ref,
	       recurse, pretty)
     struct type *type;
     char *valaddr;
     CORE_ADDR address;
     struct ui_file *stream;
     int format;
     int deref_ref;
     int recurse;
     enum val_prettyprint pretty;
d198 1
a198 2
wrap_val_print (a)
     char *a;
d225 1
a225 2
GDB_value_fetch_lazy (value)
     value_ptr value;
d234 1
a234 2
wrap_value_fetch_lazy (a)
     char *a;
d243 1
a243 3
GDB_evaluate_expression (exp, value)
     struct expression *exp;
     value_ptr *value;
d258 1
a258 2
wrap_evaluate_expression (a)
     char *a;
d268 1
a268 3
GDB_select_frame (fi, level)
     struct frame_info *fi;
     int level;
d279 1
a279 2
wrap_select_frame (a)
     char *a;
d310 1
a310 2
wrap_value_equal (a)
     char *a;
d323 2
a324 5
GDB_parse_exp_1 (stringptr, block, comma, result)
     char **stringptr;
     struct block *block;
     int comma;
     struct expression **result;
d342 1
a342 2
wrap_parse_exp_1 (opaque_arg)
     char *opaque_arg;
d358 1
a358 3
GDB_evaluate_type (exp, result)
     struct expression *exp;
     value_ptr *result;
d374 1
a374 2
wrap_evaluate_type (opaque_arg)
     char *opaque_arg;
d385 1
a385 3
GDB_block_for_pc (pc, result)
     CORE_ADDR pc;
     struct block **result;
d401 1
a401 2
wrap_block_for_pc (opaque_arg)
     char *opaque_arg;
d412 1
a412 3
GDB_block_innermost_frame (block, result)
     struct block *block;
     struct frame_info **result;
d428 1
a428 2
wrap_block_innermost_frame (opaque_arg)
     char *opaque_arg;
d451 1
a451 2
wrap_reinit_frame_cache (opaque_arg)
     char *opaque_arg;
d458 2
a459 3
GDB_find_frame_addr_in_frame_chain (addr, result)
     CORE_ADDR addr;
     struct frame_info **result;
d475 1
a475 2
wrap_find_frame_addr_in_frame_chain (opaque_arg)
     char *opaque_arg;
d486 1
a486 3
GDB_value_ind (val, rval)
     value_ptr val;
     value_ptr *rval;
d502 1
a502 2
wrap_value_ind (opaque_arg)
     char *opaque_arg;
d513 1
a513 5
GDB_value_slice (val, low, num, rval)
     value_ptr val;
     int low;
     int num;
     value_ptr *rval;
d531 1
a531 2
wrap_value_slice (opaque_arg)
     char *opaque_arg;
d564 1
a564 2
wrap_value_coerce_array (opaque_arg)
     char *opaque_arg;
d575 6
a580 7
GDB_value_struct_elt (argp, args, name, static_memfunc, err, rval)
     value_ptr *argp;
     value_ptr *args;
     char *name;
     int *static_memfunc;
     char *err;
     value_ptr *rval;
d599 1
a599 2
wrap_value_struct_elt (opaque_arg)
     char *opaque_arg;
d618 1
a618 4
GDB_value_cast (type, val, rval)
     struct type *type;
     value_ptr val;
     value_ptr *rval;
d635 1
a635 2
wrap_value_cast (opaque_arg)
     char *opaque_arg;
d649 1
a649 3
GDB_get_frame_block (fi, rval)
     struct frame_info *fi;
     struct block **rval;
d665 1
a665 2
wrap_get_frame_block (opaque_arg)
     char *opaque_arg;
@


1.3
log
@        * ChangeLog-gdbtk: Renamed to ChangeLog
        * ChangeLog: New file
        * gdbtk-cmds.c, gdbtk-hooks.c, gdbtk-variable.c, gdbtk-varobj.c,
        gdbtk-wrapper.h, gdbtk-wrapper.c, gdbtk.h, gdbtk.c: No need for
        changelog-default-name hint for Emacs now
@
text
@d29 1
a29 1
gdb_result GDB_value_fetch_lazy PARAMS ((value_ptr));
d31 1
a31 1
gdb_result GDB_evaluate_expression PARAMS ((struct expression *, value_ptr *));
d33 1
a33 1
gdb_result GDB_type_print PARAMS ((value_ptr, char *, struct ui_file *, int));
d35 4
a38 4
gdb_result GDB_val_print PARAMS ((struct type * type, char *valaddr,
				  CORE_ADDR address, struct ui_file * stream,
				  int format, int deref_ref, int recurse,
				  enum val_prettyprint pretty));
d40 1
a40 1
gdb_result GDB_select_frame PARAMS ((struct frame_info *, int));
d42 1
a42 1
gdb_result GDB_value_equal PARAMS ((value_ptr, value_ptr, int *));
d44 2
a45 2
gdb_result GDB_parse_exp_1 PARAMS ((char **stringptr, struct block * block, int comma,
				    struct expression ** result));
d47 1
a47 1
gdb_result GDB_evaluate_type PARAMS ((struct expression * exp, value_ptr * result));
d49 1
a49 1
gdb_result GDB_block_for_pc PARAMS ((CORE_ADDR pc, struct block ** result));
d51 2
a52 2
gdb_result GDB_block_innermost_frame PARAMS ((struct block * block,
					      struct frame_info ** result));
d54 1
a54 1
gdb_result GDB_reinit_frame_cache PARAMS ((void));
d56 2
a57 2
gdb_result GDB_find_frame_addr_in_frame_chain PARAMS ((CORE_ADDR addr,
					      struct frame_info ** result));
d59 1
a59 1
gdb_result GDB_value_ind PARAMS ((value_ptr val, value_ptr * rval));
d61 2
a62 2
gdb_result GDB_value_slice PARAMS ((value_ptr val, int low, int num,
				    value_ptr * rval));
d64 1
a64 1
gdb_result GDB_value_coerce_array PARAMS ((value_ptr val, value_ptr * rval));
d66 3
a68 3
gdb_result GDB_value_struct_elt PARAMS ((value_ptr * argp, value_ptr * args,
					 char *name, int *static_memfunc,
					 char *err, value_ptr * rval));
d70 2
a71 1
gdb_result GDB_value_cast PARAMS ((struct type * type, value_ptr val, value_ptr * rval));
d73 1
a73 1
gdb_result GDB_get_frame_block PARAMS ((struct frame_info * fi, struct block ** rval));
d75 2
a76 2
gdb_result GDB_get_prev_frame PARAMS ((struct frame_info *fi,
				       struct frame_info **result));
d78 2
a79 2
gdb_result GDB_get_next_frame PARAMS ((struct frame_info *fi,
				       struct frame_info **result));
d81 2
a82 3
gdb_result GDB_find_relative_frame PARAMS ((struct frame_info *fi,
					    int *start,
					    struct frame_info **result));
d84 1
a84 1
gdb_result GDB_get_current_frame PARAMS ((struct frame_info **result));
d89 2
a90 2
static gdb_result call_wrapped_function PARAMS ((catch_errors_ftype *,
					   struct gdb_wrapper_arguments *));
d92 1
a92 1
static int wrap_type_print PARAMS ((char *));
d94 1
a94 1
static int wrap_evaluate_expression PARAMS ((char *));
d96 1
a96 1
static int wrap_value_fetch_lazy PARAMS ((char *));
d98 1
a98 1
static int wrap_val_print PARAMS ((char *));
d100 1
a100 1
static int wrap_select_frame PARAMS ((char *));
d102 1
a102 1
static int wrap_value_equal PARAMS ((char *));
d104 1
a104 1
static int wrap_parse_exp_1 PARAMS ((char *opaque_arg));
d106 1
a106 1
static int wrap_evaluate_type PARAMS ((char *opaque_arg));
d108 1
a108 1
static int wrap_block_for_pc PARAMS ((char *opaque_arg));
d110 1
a110 1
static int wrap_block_innermost_frame PARAMS ((char *opaque_arg));
d112 1
a112 1
static int wrap_reinit_frame_cache PARAMS ((char *opaque_arg));
d114 1
a114 1
static int wrap_find_frame_addr_in_frame_chain PARAMS ((char *opaque_arg));
d116 1
a116 1
static int wrap_value_ind PARAMS ((char *opaque_arg));
d118 1
a118 1
static int wrap_value_slice PARAMS ((char *opaque_arg));
d120 1
a120 1
static int wrap_value_coerce_array PARAMS ((char *opaque_arg));
d122 1
a122 1
static int wrap_value_struct_elt PARAMS ((char *opaque_arg));
d124 1
a124 1
static int wrap_value_cast PARAMS ((char *opaque_arg));
d126 1
a126 1
static int wrap_get_frame_block PARAMS ((char *opaque_arg));
d128 1
a128 1
static int wrap_get_prev_frame PARAMS ((char *opaque_arg));
d130 1
a130 1
static int wrap_get_next_frame PARAMS ((char *opaque_arg));
d132 1
a132 1
static int wrap_find_relative_frame PARAMS ((char *opaque_arg));
d134 1
a134 1
static int wrap_get_current_frame PARAMS ((char *opaque_arg));
@


1.2
log
@        * gdbtk-wrapper.h: Add declarations for GDB_get_prev_frame, GDB_get_next_frame,
        GDB_find_relative_frame, GDB_get_current_frame.
        * gdbtk-wrapper.c (GDB_get_prev_frame, wrap_get_prev_frame): New functions.
        (GDB_get_next_frame, wrap_get_next_frame): New functions.
        (GDB_find_relative_frame, wrap_find_relative_frame): New functions.
        (GDB_get_current_frame, wrap_get_current_frame): New functions.

        * gdbtk-hooks.c (gdbtk_add_hooks): Use "specify_exec_file_hook" so
        that our hook is added to the list of hooks run instead of overwriting
        all other hooks.

        * gdbtk-cmds.c (gdb_stack): Wrap all calls to internal functions and
        deal with errors more gracefully.
@
text
@a830 1

a831 4

/* Local variables: */
/* change-log-default-name: "ChangeLog-gdbtk" */
/* End: */
@


1.1
log
@Initial revision
@
text
@d33 1
a33 1
gdb_result GDB_type_print (value_ptr, char *, struct ui_file *, int);
d35 4
a38 4
gdb_result GDB_val_print (struct type * type, char *valaddr,
			  CORE_ADDR address, struct ui_file *stream,
			  int format, int deref_ref, int recurse,
			  enum val_prettyprint pretty);
d74 12
d128 8
d725 104
@


1.1.1.1
log
@import insight-2000-02-04 snapshot (2nd try)
@
text
@@
