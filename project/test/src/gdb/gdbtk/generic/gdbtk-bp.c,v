head	1.51;
access;
symbols
	insight_7_6-2013-04-10-branchpoint:1.51
	gdb_7_6-branch:1.51.0.2
	gdb_7_5-branch:1.48.0.2
	gdb_7_4-branch:1.46.0.2
	gdb_7_3-branch:1.40.0.2
	gdb_7_1-branch:1.33.0.2
	gdb_7_0-branch:1.31.0.2
	arc-sim-20090309:1.26
	arc-insight_6_8-branch:1.26.0.10
	arc-insight_6_8-branchpoint:1.26
	insight_6_8-branch:1.26.0.8
	insight_6_8-branchpoint:1.26
	gdb_6_8-branch:1.26.0.6
	insight_6_6-20070208-release:1.26
	gdb_6_6-branch:1.26.0.4
	gdb_6_6-2006-11-15-branchpoint:1.26
	insight_6_5-20061003-release:1.26
	gdb_6_5-branch:1.26.0.2
	gdb_6_5-2006-05-14-branchpoint:1.26
	gdb-csl-gxxpro-6_3-branch:1.25.0.4
	gdb-csl-gxxpro-6_3-branchpoint:1.25
	gdb_6_4-branch:1.25.0.2
	gdb_6_4-2005-11-01-branchpoint:1.25
	gdb_6_1-2004-04-05-release:1.22
	gdb_6_1-branch:1.22.0.2
	gdb_6_1-2004-03-01-gmt-branchpoint:1.22
	gdb_6_0-2003-10-04-release:1.20
	gdb_6_0-branch:1.20.0.2
	gdb_6_0-2003-06-23-branchpoint:1.20
	gdb_5_3-2002-12-12-release:1.17
	gdb_5_3-branch:1.17.0.2
	gdb_5_3-2002-09-04-branchpoint:1.17
	gdb_5_2_1-2002-07-23-release:1.16
	gdb_5_2-2002-04-29-release:1.16
	gdb_5_2-branch:1.16.0.2
	gdb_5_2-2002-03-03-branchpoint:1.16
	gdb_5_1_1-2002-01-24-release:1.8.4.1
	cygnus_cvs_20020108_pre:1.14
	gdb_5_1_0_1-2002-01-03-branch:1.8.4.1.0.4
	gdb_5_1_0_1-2002-01-03-branchpoint:1.8.4.1
	gdb_5_1-2001-11-21-release:1.8.4.1
	gdb_s390-2001-09-26-branch:1.8.4.1.0.2
	gdb_s390-2001-09-26-branchpoint:1.8.4.1
	gdb_5_1-2001-07-29-branch:1.8.0.4
	gdb_5_1-2001-07-29-branchpoint:1.8
	dberlin-typesystem-branch:1.8.0.2
	dberlin-typesystem-branchpoint:1.8;
locks; strict;
comment	@ * @;


1.51
date	2013.02.16.07.05.36;	author kseitz;	state Exp;
branches;
next	1.50;

1.50
date	2012.11.10.18.09.30;	author kseitz;	state Exp;
branches;
next	1.49;

1.49
date	2012.11.10.17.49.57;	author kseitz;	state Exp;
branches;
next	1.48;

1.48
date	2012.05.25.11.36.08;	author rosch;	state Exp;
branches;
next	1.47;

1.47
date	2012.04.19.09.41.24;	author rosch;	state Exp;
branches;
next	1.46;

1.46
date	2012.03.20.14.20.24;	author rosch;	state Exp;
branches;
next	1.45;

1.45
date	2012.02.28.21.50.50;	author kevinb;	state Exp;
branches;
next	1.44;

1.44
date	2011.12.17.19.30.39;	author kseitz;	state Exp;
branches;
next	1.43;

1.43
date	2011.08.02.18.05.23;	author kseitz;	state Exp;
branches;
next	1.42;

1.42
date	2011.08.01.22.08.20;	author kseitz;	state Exp;
branches;
next	1.41;

1.41
date	2011.05.13.00.36.26;	author kseitz;	state Exp;
branches;
next	1.40;

1.40
date	2011.04.12.05.11.08;	author kseitz;	state Exp;
branches;
next	1.39;

1.39
date	2011.04.08.23.32.42;	author kseitz;	state Exp;
branches;
next	1.38;

1.38
date	2010.11.13.23.23.46;	author kseitz;	state Exp;
branches;
next	1.37;

1.37
date	2010.07.04.18.13.14;	author kseitz;	state Exp;
branches;
next	1.36;

1.36
date	2010.04.02.23.39.55;	author kseitz;	state Exp;
branches;
next	1.35;

1.35
date	2010.03.30.16.48.31;	author kseitz;	state Exp;
branches;
next	1.34;

1.34
date	2010.03.24.20.18.28;	author kseitz;	state Exp;
branches;
next	1.33;

1.33
date	2010.01.15.22.37.18;	author shebs;	state Exp;
branches;
next	1.32;

1.32
date	2009.11.09.19.39.32;	author kseitz;	state Exp;
branches;
next	1.31;

1.31
date	2009.07.07.12.38.56;	author muller;	state Exp;
branches;
next	1.30;

1.30
date	2009.03.31.05.08.35;	author shebs;	state Exp;
branches;
next	1.29;

1.29
date	2009.03.25.23.43.07;	author muller;	state Exp;
branches;
next	1.28;

1.28
date	2008.09.19.07.23.17;	author denis;	state Exp;
branches;
next	1.27;

1.27
date	2008.07.25.16.12.03;	author tromey;	state Exp;
branches;
next	1.26;

1.26
date	2005.12.23.18.23.15;	author eliz;	state Exp;
branches;
next	1.25;

1.25
date	2005.05.27.01.30.53;	author kseitz;	state Exp;
branches;
next	1.24;

1.24
date	2004.07.02.22.00.56;	author hunt;	state Exp;
branches;
next	1.23;

1.23
date	2004.06.11.18.49.38;	author hunt;	state Exp;
branches;
next	1.22;

1.22
date	2004.01.07.18.35.59;	author jjohnstn;	state Exp;
branches;
next	1.21;

1.21
date	2003.11.11.18.55.42;	author carlton;	state Exp;
branches;
next	1.20;

1.20
date	2003.03.06.21.45.39;	author hunt;	state Exp;
branches;
next	1.19;

1.19
date	2003.03.06.21.28.33;	author hunt;	state Exp;
branches;
next	1.18;

1.18
date	2003.03.06.01.25.49;	author hunt;	state Exp;
branches;
next	1.17;

1.17
date	2002.08.03.16.22.07;	author cagney;	state Exp;
branches;
next	1.16;

1.16
date	2002.02.07.21.56.06;	author hunt;	state Exp;
branches;
next	1.15;

1.15
date	2002.02.07.05.05.06;	author hunt;	state Exp;
branches;
next	1.14;

1.14
date	2001.12.21.22.31.08;	author tromey;	state Exp;
branches;
next	1.13;

1.13
date	2001.11.05.19.42.48;	author hunt;	state Exp;
branches;
next	1.12;

1.12
date	2001.10.29.21.45.31;	author hunt;	state Exp;
branches;
next	1.11;

1.11
date	2001.10.29.19.37.05;	author hunt;	state Exp;
branches;
next	1.10;

1.10
date	2001.10.06.01.42.33;	author kseitz;	state Exp;
branches;
next	1.9;

1.9
date	2001.08.03.03.37.40;	author kseitz;	state Exp;
branches;
next	1.8;

1.8
date	2001.06.13.20.01.42;	author kseitz;	state Exp;
branches
	1.8.4.1;
next	1.7;

1.7
date	2001.06.11.23.08.05;	author tromey;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.07.14.43.01;	author kseitz;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.11.20.01.57;	author kevinb;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.11.14.33.10;	author kseitz;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.11.05.08.32;	author kseitz;	state Exp;
branches;
next	1.2;

1.2
date	2001.05.10.22.34.54;	author kseitz;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.10.18.04.23;	author kseitz;	state Exp;
branches;
next	;

1.8.4.1
date	2001.08.21.18.34.45;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.51
log
@	* generic/gdbtk-bp.c (gdb_find_bp_at_line): Update struct
	bp_location changes wrt source_file from GDB.
@
text
@/* Tcl/Tk command definitions for Insight - Breakpoints.
   Copyright (C) 2001-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */

#include "defs.h"
#include "symtab.h"
#include "symfile.h"
#include "source.h"
#include "linespec.h"
#include "breakpoint.h"
#include "tracepoint.h"
#include "gdb_string.h"
#include <tcl.h>
#include "gdbtk.h"
#include "gdbtk-cmds.h"
#include "observer.h"
#include "arch-utils.h"
#include "exceptions.h"

/* Globals to support action and breakpoint commands.  */
static Tcl_Obj **gdbtk_obj_array;
static int gdbtk_obj_array_cnt;
static int gdbtk_obj_array_ptr;

/* From breakpoint.c */
extern struct breakpoint *breakpoint_chain;

#define ALL_BREAKPOINTS(B)  for (B = breakpoint_chain; B; B = B->next)

/* From gdbtk-hooks.c */
extern void report_error (void);

/* These two lookup tables are used to translate the type & disposition fields
   of the breakpoint structure (respectively) into something gdbtk understands.
   They are also used in gdbtk-hooks.c */

char *bptypes[] =
  {"none", "breakpoint", "hw breakpoint", "until",
   "finish", "watchpoint", "hw watchpoint",
   "read watchpoint", "acc watchpoint",
   "longjmp", "longjmp resume", "step resume",
   "sigtramp", "watchpoint scope",
   "call dummy", "shlib events", "catch load",
   "catch unload", "catch fork", "catch vfork",
   "catch exec", "catch catch", "catch throw"
  };
char *bpdisp[] =
  {"delete", "delstop", "disable", "donttouch"};

/* Is this breakpoint interesting to a user interface? */
#define BREAKPOINT_IS_INTERESTING(bp) \
((bp)->type == bp_breakpoint             \
 || (bp)->type == bp_hardware_breakpoint \
 || (bp)->type == bp_watchpoint          \
 || (bp)->type == bp_hardware_watchpoint \
 || (bp)->type == bp_read_watchpoint     \
 || (bp)->type == bp_access_watchpoint)

/*
 * Forward declarations
 */

/* Breakpoint-related functions */
static int gdb_find_bp_at_addr (ClientData, Tcl_Interp *, int,
				Tcl_Obj * CONST objv[]);
static int gdb_find_bp_at_line (ClientData, Tcl_Interp *, int,
				Tcl_Obj * CONST objv[]);
static int gdb_get_breakpoint_info (ClientData, Tcl_Interp *, int,
				    Tcl_Obj * CONST[]);
static int gdb_get_breakpoint_list (ClientData, Tcl_Interp *, int,
				    Tcl_Obj * CONST[]);
static int gdb_set_bp (ClientData, Tcl_Interp *, int, Tcl_Obj * CONST objv[]);

/* Tracepoint-related functions */
static int gdb_actions_command (ClientData, Tcl_Interp *, int,
				Tcl_Obj * CONST objv[]);
static int gdb_get_trace_frame_num (ClientData, Tcl_Interp *, int,
				    Tcl_Obj * CONST objv[]);
static int gdb_get_tracepoint_info (ClientData, Tcl_Interp *, int,
				    Tcl_Obj * CONST objv[]);
static int gdb_get_tracepoint_list (ClientData, Tcl_Interp *, int,
				    Tcl_Obj * CONST objv[]);
static int gdb_trace_status (ClientData, Tcl_Interp *, int,
			     Tcl_Obj * CONST[]);
static int gdb_tracepoint_exists_command (ClientData, Tcl_Interp *,
					  int, Tcl_Obj * CONST objv[]);
static Tcl_Obj *get_breakpoint_commands (struct command_line *cmd);

static int tracepoint_exists (char *args);

/* Breakpoint/tracepoint events and related functions */

void gdbtk_create_breakpoint (struct breakpoint *);
void gdbtk_delete_breakpoint (struct breakpoint *);
void gdbtk_modify_breakpoint (struct breakpoint *);
static void breakpoint_notify (int, const char *);

int
Gdbtk_Breakpoint_Init (Tcl_Interp *interp)
{
  /* Breakpoint commands */
  Tcl_CreateObjCommand (interp, "gdb_find_bp_at_addr", gdbtk_call_wrapper,
			gdb_find_bp_at_addr, NULL);
  Tcl_CreateObjCommand (interp, "gdb_find_bp_at_line", gdbtk_call_wrapper,
			gdb_find_bp_at_line, NULL);
  Tcl_CreateObjCommand (interp, "gdb_get_breakpoint_info", gdbtk_call_wrapper,
			gdb_get_breakpoint_info, NULL);
  Tcl_CreateObjCommand (interp, "gdb_get_breakpoint_list", gdbtk_call_wrapper,
			gdb_get_breakpoint_list, NULL);
  Tcl_CreateObjCommand (interp, "gdb_set_bp", gdbtk_call_wrapper, gdb_set_bp, NULL);

  /* Tracepoint commands */
  Tcl_CreateObjCommand (interp, "gdb_actions",
			gdbtk_call_wrapper, gdb_actions_command, NULL);
  Tcl_CreateObjCommand (interp, "gdb_get_trace_frame_num",
			gdbtk_call_wrapper, gdb_get_trace_frame_num, NULL);
  Tcl_CreateObjCommand (interp, "gdb_get_tracepoint_info",
			gdbtk_call_wrapper, gdb_get_tracepoint_info, NULL);
  Tcl_CreateObjCommand (interp, "gdb_get_tracepoint_list",
			gdbtk_call_wrapper, gdb_get_tracepoint_list, NULL);
  Tcl_CreateObjCommand (interp, "gdb_is_tracing",
			gdbtk_call_wrapper, gdb_trace_status,	NULL);
  Tcl_CreateObjCommand (interp, "gdb_tracepoint_exists",
			gdbtk_call_wrapper, gdb_tracepoint_exists_command, NULL);

  return TCL_OK;
}

/* A line buffer for breakpoint commands and tracepoint actions
   input validation.  */
static char *
gdbtk_read_next_line (void)
{
  if (gdbtk_obj_array_ptr == gdbtk_obj_array_cnt)
    return NULL;

  return  Tcl_GetStringFromObj (gdbtk_obj_array[gdbtk_obj_array_ptr++], NULL);
}

/*
 *  This section contains commands for manipulation of breakpoints.
 */

/* set a breakpoint by source file and line number
   flags are as follows:
   least significant 2 bits are disposition, rest is 
   type (normally 0).

   enum bptype {
   bp_breakpoint,                Normal breakpoint 
   bp_hardware_breakpoint,      Hardware assisted breakpoint
   }

   Disposition of breakpoint.  Ie: what to do after hitting it.
   enum bpdisp {
   del,                         Delete it
   del_at_next_stop,            Delete at next stop, whether hit or not
   disable,                     Disable it 
   donttouch                    Leave it alone 
   };
*/


/* This implements the tcl command "gdb_find_bp_at_addr"

* Tcl Arguments:
*    addr:     CORE_ADDR
* Tcl Result:
*    It returns a list of breakpoint numbers
*/
static int
gdb_find_bp_at_addr (ClientData clientData, Tcl_Interp *interp,
		     int objc, Tcl_Obj *CONST objv[])
{
  CORE_ADDR addr;
  Tcl_WideInt waddr;
  struct breakpoint *b;

  if (objc != 2)
    {
      Tcl_WrongNumArgs (interp, 1, objv, "address");
      return TCL_ERROR;
    }
  
  if (Tcl_GetWideIntFromObj (interp, objv[1], &waddr) != TCL_OK)
    return TCL_ERROR;
  addr = waddr;

  Tcl_SetListObj (result_ptr->obj_ptr, 0, NULL);
  ALL_BREAKPOINTS (b)
    {
      if (b->loc != NULL && b->loc->address == addr)
	Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr,
				  Tcl_NewIntObj (b->number));
    }

  return TCL_OK;
}

/* This implements the tcl command "gdb_find_bp_at_line"

* Tcl Arguments:
*    filename: the file in which to find the breakpoint
*    line:     the line number for the breakpoint
* Tcl Result:
*    It returns a list of breakpoint numbers
*/
static int
gdb_find_bp_at_line (ClientData clientData, Tcl_Interp *interp,
		     int objc, Tcl_Obj *CONST objv[])

{
  struct symtab *s;
  int line;
  struct breakpoint *b;

  if (objc != 3)
    {
      Tcl_WrongNumArgs (interp, 1, objv, "filename line");
      return TCL_ERROR;
    }

  s = lookup_symtab (Tcl_GetStringFromObj (objv[1], NULL));
  if (s == NULL)
    return TCL_ERROR;

  if (Tcl_GetIntFromObj (interp, objv[2], &line) == TCL_ERROR)
    {
      result_ptr->flags = GDBTK_IN_TCL_RESULT;
      return TCL_ERROR;
    }

  Tcl_SetListObj (result_ptr->obj_ptr, 0, NULL);
  ALL_BREAKPOINTS (b)
  {
    if (b->loc && b->loc->symtab && b->loc->line_number == line
	&& !strcmp (b->loc->symtab->filename, s->filename))
      {
	Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr,
				  Tcl_NewIntObj (b->number));
      }
  }

  return TCL_OK;
}

/* This implements the tcl command gdb_get_breakpoint_info
 *
 * Tcl Arguments:
 *   breakpoint_number
 * Tcl Result:
 *   A list with {file, function, line_number, address, type, enabled?,
 *                disposition, ignore_count, {list_of_commands},
 *                condition, thread, hit_count user_specification}
 */
static int
gdb_get_breakpoint_info (ClientData clientData, Tcl_Interp *interp, int objc,
			 Tcl_Obj *CONST objv[])
{
  struct symtab_and_line sal;
  int bpnum;
  struct breakpoint *b;
  struct watchpoint *w;
  const char *funcname, *filename;
  int isPending = 0;

  Tcl_Obj *new_obj;

  if (objc != 2)
    {
      Tcl_WrongNumArgs (interp, 1, objv, "breakpoint");
      return TCL_ERROR;
    }

  if (Tcl_GetIntFromObj (NULL, objv[1], &bpnum) != TCL_OK)
    {
      result_ptr->flags = GDBTK_IN_TCL_RESULT;
      return TCL_ERROR;
    }

  b = get_breakpoint (bpnum);
  if (!b || b->type != bp_breakpoint)
    {
      gdbtk_set_result (interp, "Breakpoint #%d does not exist.", bpnum);
      return TCL_ERROR;
    }

  w = (is_watchpoint (b)) ? (struct watchpoint *) b : NULL;

  isPending = (b->loc == NULL);
  Tcl_SetListObj (result_ptr->obj_ptr, 0, NULL);
  /* Pending breakpoints will display "<PENDING>" as the file name and the 
     user expression into the Function field of the breakpoint view.
    "0" and "0" in the line number and address field.  */
  if (isPending)
    {
      Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr,
                                Tcl_NewStringObj ("<PENDING>", -1));
      Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr,
                                Tcl_NewStringObj (b->addr_string, -1));
      Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr,
                                Tcl_NewIntObj (0));
      Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr,
                                Tcl_NewIntObj (0));
    }
  else
    {
      sal = find_pc_line (b->loc->address, 0);

      filename = symtab_to_filename (sal.symtab);
      if (filename == NULL)
        filename = "";
      Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr,
                                Tcl_NewStringObj (filename, -1));
      funcname = pc_function_name (b->loc->address);
      Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr,
                                Tcl_NewStringObj (funcname, -1));
      Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr,
                                Tcl_NewIntObj (b->loc->line_number));
      Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr,
                                Tcl_NewStringObj (core_addr_to_string
                               (b->loc->address), -1));
  }

  Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr,
			    Tcl_NewStringObj (bptypes[b->type], -1));
  Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr,
			    Tcl_NewBooleanObj (b->enable_state == bp_enabled));
  Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr,
			    Tcl_NewStringObj (bpdisp[b->disposition], -1));
  Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr,
			    Tcl_NewIntObj (b->ignore_count));

  Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr,
			    get_breakpoint_commands ((breakpoint_commands (b)) ? breakpoint_commands (b) : NULL));

  Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr,
			    Tcl_NewStringObj (b->cond_string, -1));

  Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr,
			    Tcl_NewIntObj (b->thread));
  Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr,
			    Tcl_NewIntObj (b->hit_count));

  Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr,
			    Tcl_NewStringObj (w ? w->exp_string
					      : b->addr_string, -1));

  return TCL_OK;
}

/* Helper function for gdb_get_breakpoint_info, this function is
   responsible for figuring out what to type at the "commands" command
   in gdb's cli in order to get at the same command list passed here. */

static Tcl_Obj *
get_breakpoint_commands (struct command_line *cmd)
{
  Tcl_Obj *obj, *tmp;

  obj = Tcl_NewObj ();
  while (cmd != NULL)
    {
      switch (cmd->control_type)
	{
	case simple_control:
	  /* A simple command. Just append it. */
	  Tcl_ListObjAppendElement (NULL, obj,
				    Tcl_NewStringObj (cmd->line, -1));
	  break;

	case break_control:
	  /* A loop_break */
	  Tcl_ListObjAppendElement (NULL, obj,
				    Tcl_NewStringObj ("loop_break", -1));
	  break;

	case continue_control:
	  /* A loop_continue */
	  Tcl_ListObjAppendElement (NULL, obj,
				    Tcl_NewStringObj ("loop_continue", -1));
	  break;

	case while_control:
	  /* A while loop. Must append "end" to the end of it. */
	  tmp = Tcl_NewStringObj ("while ", -1);
	  Tcl_AppendToObj (tmp, cmd->line, -1);
	  Tcl_ListObjAppendElement (NULL, obj, tmp);
	  Tcl_ListObjAppendList (NULL, obj,
				 get_breakpoint_commands (*cmd->body_list));
	  Tcl_ListObjAppendElement (NULL, obj,
				    Tcl_NewStringObj ("end", -1));
	  break;

	case if_control:
	  /* An if statement. cmd->body_list[0] is the true part,
	     cmd->body_list[1] contains the "else" (false) part. */
	  tmp = Tcl_NewStringObj ("if ", -1);
	  Tcl_AppendToObj (tmp, cmd->line, -1);
	  Tcl_ListObjAppendElement (NULL, obj, tmp);
	  Tcl_ListObjAppendList (NULL, obj,
				 get_breakpoint_commands (cmd->body_list[0]));
	  if (cmd->body_count == 2)
	    {
	      Tcl_ListObjAppendElement (NULL, obj,
					Tcl_NewStringObj ("else", -1));
	      Tcl_ListObjAppendList (NULL, obj,
				     get_breakpoint_commands(cmd->body_list[1]));
	    }
	  Tcl_ListObjAppendElement (NULL, obj,
				    Tcl_NewStringObj ("end", -1));
	  break;

	case invalid_control:
	  /* Something invalid. Just skip it. */
	  break;
	}

      cmd = cmd->next;
    }

  return obj;
}

/* This implements the tcl command gdb_get_breakpoint_list
 * It builds up a list of the current breakpoints.
 *
 * Tcl Arguments:
 *    None.
 * Tcl Result:
 *    A list of breakpoint numbers.
 */
static int
gdb_get_breakpoint_list (ClientData clientData, Tcl_Interp *interp,
			 int objc, Tcl_Obj *CONST objv[])
{
  Tcl_Obj *new_obj;
  struct breakpoint *b;

  if (objc != 1)
    {
      Tcl_WrongNumArgs (interp, 1, objv, NULL);
      return TCL_ERROR;
    }

  ALL_BREAKPOINTS (b)
  {
    if (b->type == bp_breakpoint)
      {
	new_obj = Tcl_NewIntObj (b->number);
	Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr, new_obj);
      }
  }

  return TCL_OK;
}

/* This implements the tcl command "gdb_set_bp"
 * It sets breakpoints, and notifies the GUI.
 *
 * Tcl Arguments:
 *    addr:     the "address" for the breakpoint (either *ADDR or file:line)
 *    type:     the type of the breakpoint
 *    thread:   optional thread number
 * Tcl Result:
 *    The return value of the call to gdbtk_tcl_breakpoint.
 */
static int
gdb_set_bp (ClientData clientData, Tcl_Interp *interp,
	    int objc, Tcl_Obj *CONST objv[])
{
  int temp, ignore_count, thread, pending, enabled;
  char *address, *typestr, *condition;
  struct gdb_exception e;

  /* Insight does not use all of these (yet?).  */
  ignore_count = 0;
  condition = NULL;
  pending = 0;
  enabled = 1;

  if (objc != 3 && objc != 4)
    {
      Tcl_WrongNumArgs (interp, 1, objv, "addr type ?thread?");
      return TCL_ERROR;
    }

  address = Tcl_GetStringFromObj (objv[1], NULL);
  if (address == NULL)
    {
      result_ptr->flags = GDBTK_IN_TCL_RESULT;
      return TCL_ERROR;
    }

  typestr = Tcl_GetStringFromObj (objv[2], NULL);
  if (strncmp (typestr, "temp", 4) == 0)
    temp = 1;
  else if (strncmp (typestr, "normal", 6) == 0)
    temp = 0;
  else
    {
      gdbtk_set_result (interp, "type must be \"temp\" or \"normal\"");
      return TCL_ERROR;
    }

  if (objc == 4)
    {
      if (Tcl_GetIntFromObj (interp, objv[3], &thread) == TCL_ERROR)
	{
	  result_ptr->flags = GDBTK_IN_TCL_RESULT;
	  return TCL_ERROR;
	}
    }

  TRY_CATCH (e, RETURN_MASK_ALL)
    {
      create_breakpoint (get_current_arch (), address, condition, thread,
			 NULL,
			 0	/* condition and thread are valid */,
			 temp,
			 bp_breakpoint /* type wanted */,
			 ignore_count,
			 (pending ? AUTO_BOOLEAN_TRUE : AUTO_BOOLEAN_FALSE),
			 &bkpt_breakpoint_ops,
			 0	/* from_tty */,
			 enabled, 0, 0);
    }

  if (e.reason < 0)
    return TCL_ERROR;

  return TCL_OK;
}

/*
 * This section contains functions that deal with breakpoint
 * events from gdb.
 */

/* The next three functions use breakpoint_notify to allow the GUI 
 * to handle creating, deleting and modifying breakpoints.  These three
 * functions are put into the appropriate gdb hooks in gdbtk_init.
 */

void
gdbtk_create_breakpoint (struct breakpoint *b)
{
  if (b == NULL || !BREAKPOINT_IS_INTERESTING (b))
    return;

  breakpoint_notify (b->number, "create");
}

void
gdbtk_delete_breakpoint (struct breakpoint *b)
{
  breakpoint_notify (b->number, "delete");
}

void
gdbtk_modify_breakpoint (struct breakpoint *b)
{
  if (b->number >= 0)
    breakpoint_notify (b->number, "modify");
}

/* This is the generic function for handling changes in
 * a breakpoint.  It routes the information to the Tcl
 * command "gdbtk_tcl_breakpoint" (or "gdbtk_tcl_tracepoint") in the form:
 *   gdbtk_tcl_breakpoint action b_number b_address b_line b_file
 * On error, the error string is written to gdb_stdout.
 */
static void
breakpoint_notify (int num, const char *action)
{
  char *buf;
  struct breakpoint *b;

  b = get_breakpoint (num);
  if (b == NULL)
    {
      struct tracepoint *tp;

      tp = get_tracepoint (num);
      if (tp == NULL)
	return;
      b = &tp->base;
    }

  if (b->number < 0
      /* FIXME: should not be so restrictive... */
      || (b->type != bp_breakpoint
	  && b->type != bp_tracepoint
	  && b->type != bp_fast_tracepoint))
    return;

  /* We ensure that ACTION contains no special Tcl characters, so we
     can do this.  */
  if (b->type == bp_breakpoint)
    buf = xstrprintf ("gdbtk_tcl_breakpoint %s %d", action, b->number);
  else
    buf = xstrprintf ("gdbtk_tcl_tracepoint %s %d", action, b->number);

  if (Tcl_Eval (gdbtk_interp, buf) != TCL_OK)
    report_error ();
  xfree(buf); 
}

/*
 * This section contains the commands that deal with tracepoints:
 */

/* This implements the tcl command gdb_actions
 * It sets actions for a given tracepoint.
 *
 * Tcl Arguments:
 *    number: the tracepoint in question
 *    actions: the actions to add to this tracepoint
 * Tcl Result:
 *    None.
 */

static int
gdb_actions_command (ClientData clientData, Tcl_Interp *interp,
		     int objc, Tcl_Obj *CONST objv[])
{
  int tpnum;
  struct tracepoint *tp;
  struct command_line *commands;

  if (objc != 3)
    {
      Tcl_WrongNumArgs (interp, 1, objv, "number actions");
      return TCL_ERROR;
    }

  if (Tcl_GetIntFromObj (NULL, objv[1], &tpnum) != TCL_OK)
    {
      result_ptr->flags |= GDBTK_IN_TCL_RESULT;
      return TCL_ERROR;
    }

  tp = get_tracepoint (tpnum);

  if (tp == NULL)
    {
      gdbtk_set_result (interp, "Tracepoint #%d does not exist", tpnum);
      return TCL_ERROR;
    }

  /* Validate and set new tracepoint actions.  */
  Tcl_ListObjGetElements (interp, objv[2], &gdbtk_obj_array_cnt,
			  &gdbtk_obj_array);
  gdbtk_obj_array_ptr = 1;
  commands = read_command_lines_1 (gdbtk_read_next_line, 1,
				   check_tracepoint_command, tp);  

  breakpoint_set_commands ((struct breakpoint *) tp, commands);
  return TCL_OK;
}

static int
gdb_get_trace_frame_num (ClientData clientData, Tcl_Interp *interp,
			 int objc, Tcl_Obj *CONST objv[])
{
  if (objc != 1)
    {
      Tcl_WrongNumArgs (interp, 1, objv, "linespec");
      return TCL_ERROR;
    }

  Tcl_SetIntObj (result_ptr->obj_ptr, get_traceframe_number ());
  return TCL_OK;

}

static int
gdb_get_tracepoint_info (ClientData clientData, Tcl_Interp *interp,
			 int objc, Tcl_Obj *CONST objv[])
{
  struct symtab_and_line sal;
  int tpnum;
  struct tracepoint *tp;
  struct breakpoint *bp;
  struct command_line *cl;
  Tcl_Obj *action_list;
  const char *filename, *funcname;

  if (objc != 2)
    {
      Tcl_WrongNumArgs (interp, 1, objv, "tpnum");
      return TCL_ERROR;
    }

  if (Tcl_GetIntFromObj (NULL, objv[1], &tpnum) != TCL_OK)
    {
      result_ptr->flags |= GDBTK_IN_TCL_RESULT;
      return TCL_ERROR;
    }

  tp = get_tracepoint (tpnum);
  bp = (struct breakpoint *) tp;
  if (tp == NULL)
    {
      gdbtk_set_result (interp, "Tracepoint #%d does not exist", tpnum);
      return TCL_ERROR;
    }

  Tcl_SetListObj (result_ptr->obj_ptr, 0, NULL);
  sal = find_pc_line (bp->loc->address, 0);
  filename = symtab_to_filename (sal.symtab);
  if (filename == NULL)
    filename = "N/A";
  Tcl_ListObjAppendElement (interp, result_ptr->obj_ptr,
			    Tcl_NewStringObj (filename, -1));

  funcname = pc_function_name (bp->loc->address);
  Tcl_ListObjAppendElement (interp, result_ptr->obj_ptr, Tcl_NewStringObj
			    (funcname, -1));

  Tcl_ListObjAppendElement (interp, result_ptr->obj_ptr,
			    Tcl_NewIntObj (sal.line));
  Tcl_ListObjAppendElement (interp, result_ptr->obj_ptr,
			    Tcl_NewStringObj (core_addr_to_string (bp->loc->address), -1));
  Tcl_ListObjAppendElement (interp, result_ptr->obj_ptr,
			    Tcl_NewIntObj (bp->enable_state == bp_enabled));
  Tcl_ListObjAppendElement (interp, result_ptr->obj_ptr,
			    Tcl_NewIntObj (tp->pass_count));
  Tcl_ListObjAppendElement (interp, result_ptr->obj_ptr,
			    Tcl_NewIntObj (tp->step_count));
  Tcl_ListObjAppendElement (interp, result_ptr->obj_ptr,
			    Tcl_NewIntObj (bp->thread));
  Tcl_ListObjAppendElement (interp, result_ptr->obj_ptr,
			    Tcl_NewIntObj (bp->hit_count));

  /* Append a list of actions */
  action_list = Tcl_NewObj ();
  if (bp->commands != NULL)
    {
      for (cl = breakpoint_commands (bp); cl != NULL; cl = cl->next)
	{
	  Tcl_ListObjAppendElement (interp, action_list,
				    Tcl_NewStringObj (cl->line, -1));
	}
      Tcl_ListObjAppendElement (interp, result_ptr->obj_ptr, action_list);
    }

  return TCL_OK;
}

/* return a list of all tracepoint numbers in interpreter */
static int
gdb_get_tracepoint_list (ClientData clientData,
			 Tcl_Interp *interp,
			 int objc,
			 Tcl_Obj *CONST objv[])
{
  VEC(breakpoint_p) *tp_vec = NULL;
  int ix;
  struct breakpoint *tp;

  Tcl_SetListObj (result_ptr->obj_ptr, 0, NULL);

  tp_vec = all_tracepoints ();
  for (ix = 0; VEC_iterate (breakpoint_p, tp_vec, ix, tp); ix++)
    Tcl_ListObjAppendElement (interp, result_ptr->obj_ptr,
			      Tcl_NewIntObj (tp->number));
  VEC_free (breakpoint_p, tp_vec);

  return TCL_OK;
}

static int
gdb_trace_status (ClientData clientData,
		  Tcl_Interp *interp,
		  int objc,
		  Tcl_Obj *CONST objv[])
{
  int result = 0;

  if (current_trace_status ()->running)
    result = 1;

  Tcl_SetIntObj (result_ptr->obj_ptr, result);
  return TCL_OK;
}

/* returns -1 if not found, tracepoint # if found */
static int
tracepoint_exists (char *args)
{
  VEC(breakpoint_p) *tp_vec = NULL;
  int ix;
  struct breakpoint *tp;
  struct symtabs_and_lines sals;
  char *file = NULL;
  int result = -1;

  sals = decode_line_1 (&args, DECODE_LINE_FUNFIRSTLINE, NULL, 0);
  if (sals.nelts == 1)
    {
      resolve_sal_pc (&sals.sals[0]);
      file = xmalloc (strlen (sals.sals[0].symtab->dirname)
		      + strlen (sals.sals[0].symtab->filename) + 1);
      if (file != NULL)
	{
	  strcpy (file, sals.sals[0].symtab->dirname);
	  strcat (file, sals.sals[0].symtab->filename);

	  tp_vec = all_tracepoints ();
	  for (ix = 0; VEC_iterate (breakpoint_p, tp_vec, ix, tp); ix++)
	    {
	      if (tp->loc && tp->loc->address == sals.sals[0].pc)
		result = tp->number;
#if 0
	      /* Why is this here? This messes up assembly traces */
	      else if (tp->source_file != NULL
		       && strcmp (tp->source_file, file) == 0
		       && sals.sals[0].line == tp->line_number)
		result = tp->number;
#endif
	    }
	  VEC_free (breakpoint_p, tp_vec);
	}
    }
  if (file != NULL)
    free (file);
  return result;
}

static int
gdb_tracepoint_exists_command (ClientData clientData,
			       Tcl_Interp *interp,
			       int objc,
			       Tcl_Obj *CONST objv[])
{
  char *args;

  if (objc != 2)
    {
      Tcl_WrongNumArgs (interp, 1, objv,
			"function:line|function|line|*addr");
      return TCL_ERROR;
    }

  args = Tcl_GetStringFromObj (objv[1], NULL);

  Tcl_SetIntObj (result_ptr->obj_ptr, tracepoint_exists (args));
  return TCL_OK;
}
@


1.50
log
@	* generic/gdbtk-bp.c (breakpoint_notify): Fix logic error
	when detecting breakpoint types to be handled.
@
text
@d2 1
a2 1
   Copyright (C) 2001-2012 Free Software Foundation, Inc.
d252 2
a253 2
    if (b->loc && b->loc->line_number == line
	&& !strcmp (b->loc->source_file, s->filename))
@


1.49
log
@	* generic/gdbtk-bp.c (breakpoint_notify): Handle tracepoints, too.
	(tracepoint_notify): Remove.
	(gdbtk_create_tracepoint): Remove.
	(gdbtk_delete_tracepoint): Remove.
	(gdbtk_modify_tracepoint): Remove.
	* generic/gdbtk-hooks.c: Remove deleted function extern declarations.
	(gdbtk_add_hooks): Remove tracepoint observers.
@
text
@d608 3
a610 3
      && b->type != bp_breakpoint
      && b->type != bp_tracepoint
      && b->type != bp_fast_tracepoint)
@


1.48
log
@2012-05-25  Roland Schwingel  <roland.schwingel@@onevision.com>

	* generic/gdbtk-bp.c (gdb_set_bp): Add new NULL param
	to call to create_breakpoint() due to changes in gdb.
	* generic/gdbtk-cmds.c (gdb_listfuncs): Iterator param
	in call to ALL_BLOCK_SYMBOLS() now is a pointer to
	struct block_iterator instead of struct dict_iterator.
	* generic/gdbtk-stack.c (gdb_block_vars,gdb_get_blocks)
	(gdb_get_vars_command): Likewise.
	* generic/gdbtk-hooks.c (gdbtk_annotate_signal): Change
	function calls: target_signal_to_name -> gdb_signal_to_name
	target_signal_to_string -> gdb_signal_to_string due to
	recent changes in gdb.
@
text
@a111 3
void gdbtk_create_tracepoint (int);
void gdbtk_delete_tracepoint (int);
void gdbtk_modify_tracepoint (int);
a112 1
static void tracepoint_notify (int, const char *);
d585 1
a585 1
 * command "gdbtk_tcl_breakpoint" in the form:
d596 9
d608 3
a610 1
      || b->type != bp_breakpoint)
d615 4
a618 1
  buf = xstrprintf ("gdbtk_tcl_breakpoint %s %d", action, b->number);
a866 37

/*
 * This section contains functions which deal with tracepoint
 * events from gdb.
 */

void
gdbtk_create_tracepoint (int num)
{
  tracepoint_notify (num, "create");
}

void
gdbtk_delete_tracepoint (int num)
{
  tracepoint_notify (num, "delete");
}

void
gdbtk_modify_tracepoint (int num)
{
  tracepoint_notify (num, "modify");
}

static void
tracepoint_notify (int num, const char *action)
{
  char *buf;

  /* We ensure that ACTION contains no special Tcl characters, so we
     can do this.  */
  buf = xstrprintf ("gdbtk_tcl_tracepoint %s %d", action, num);

  if (Tcl_Eval (gdbtk_interp, buf) != TCL_OK)
    report_error ();
  free(buf); 
}
@


1.47
log
@2012-04-19  Roland Schwingel  <roland.schwingel@@onevision.com>

   * generic/gdbtk-bp.c: Updated copyright.
   (gdb_find_bp_at_line): Don't access location struct
   of breakpoint if it is NULL.
@
text
@d538 1
@


1.46
log
@   * generic/gdbtk-bp.c (gdb_set_bp): Adjust parameters
   of create_breakpoint() to match recent change.
@
text
@d2 1
a2 2
   Copyright (C) 2001, 2002, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
d256 1
a256 1
    if (b->loc->line_number == line
@


1.45
log
@	* generic/gdbtk-cmds.h (pc_function_name): Make return type
	const.
	* generic/gdbtk-bp.c (gdb_get_breakpoint_info)
	(gdb_get_tracepoint_info): Make char * variables const to match
	recent GDB API changes.
	* generic/gdbtk-stack.c (get_frame_name): Likewise.
	* generic/gdbtk-cmds.c (gdb_get_function_command, gdb_listfuncs)
	(gdb_loc, perror_with_name_wrapper): Likewise.
	(pc_function_name): Likewise, plus change return type to be const.
@
text
@d546 1
a546 1
			 enabled, 0);
@


1.44
log
@	* generic/gdbtk-cmds.c (gdb_listfiles): Update API changes
	for map_partial_symbol_filenames.
	(gdb_get_line_command): Update API changes for decode_line_1 in gdb.
	(gdb_get_file_command): Likewise.
	(gdb_get_function_command): Likewise.
	* generic/gdbtk-stack.c (gdb_get_vars_command): Likewise.
	* generic/gdbtk-bp.c (tracepoint_exists): Likewise.
	(gdb_find_bp_at_line, gdb_get_breakpoint_info): Update breakpoint
	API changes in gdb.
@
text
@d285 1
a285 1
  char *funcname, *filename;
d693 1
a693 1
  char *filename, *funcname;
@


1.43
log
@	* generic/gdbtk-bp.c (gdb_set_bp): Pass a valid breakpoint_ops
	to create_breakpoint.
@
text
@d257 2
a258 1
    if (b->line_number == line && !strcmp (b->source_file, s->filename))
d340 1
a340 1
                                Tcl_NewIntObj (b->line_number));
d805 1
a805 1
  sals = decode_line_1 (&args, 1, NULL, 0, NULL);
@


1.42
log
@	* generic/gdbtk-bp.c (BREAKPOINT_IS_WATCHPOINT): Remove.
	(gdb_get_breakpoint_info): Update with recent GDB API changes.
	(gdb_actions_command): Likewise.
	(gdb_get_tracepoint_info): Likewise.
	(breakpoint_notify): Use get_breakpoint.

	* generic/gdbtk-cmds.c (gdb_prompt_command): Update with recent
	GDB API changes.
@
text
@d543 1
a543 1
			 NULL	/* breakpoint ops */,
@


1.41
log
@	* generic/gdbtk-hooks.c (gdbtk_create_breakpoint): Change
	parameter from `int' to `struct breakpoint *'.
	(gdbtk_delete_breakpoint): Likewise.
	(gdbtk_modify_breakpoint): Likewise.
	* generic/gdbtk-bp.c (ALL_BREAKPOINTS): Define.
	(breakpoint_list): Remove.
	(breakpoint_list_size): Remove.
	(Gdbtk_Breakpoint_Init): Remove initialization of breakpoint_list.
	(gdb_find_bp_at_addr): Rewrite using ALL_BREAKPOINTS.
	(gdb_find_bp_at_line): Likewise.
	(gdb_get_breakpoint_info): Likewise.
	(gdb_get_breakpoint_list): Likewise.
	(gdbtk_create_breakpoint): Change parameter from `int' to
	`struct breakpoint *' and update function.
	(gdbtk_delete_breakpoint): Likewise.
	(gdbtk_modify_breakpoint): Likewise.
	(breakpoint_notify): Rewrite using ALL_BREAKPOINTS.
@
text
@a75 7
/* Is this breakpoint a watchpoint?  */
#define BREAKPOINT_IS_WATCHPOINT(bp)					      \
((bp)->type == bp_watchpoint						      \
 || (bp)->type == bp_hardware_watchpoint				      \
 || (bp)->type == bp_read_watchpoint					      \
 || (bp)->type == bp_access_watchpoint)

d283 1
d301 1
a301 5
  ALL_BREAKPOINTS (b)
  {
    if (b->number == bpnum)
      break;
  }
d308 2
d366 1
a366 2
			    Tcl_NewStringObj (BREAKPOINT_IS_WATCHPOINT (b)
					      ? b->exp_string
d598 1
a598 5
  ALL_BREAKPOINTS (b)
  {
    if (num == b->number)
      break;
  }
d632 2
a633 2
  char *number;
  struct breakpoint *tp;
d642 8
a649 2
  number = Tcl_GetStringFromObj (objv[1], NULL);
  tp = get_tracepoint_by_number (&number, 0, 0);
d652 1
a652 2
      Tcl_AppendStringsToObj (result_ptr->obj_ptr, "Tracepoint \"",
			      number, "\" does not exist", NULL);
d663 1
a663 1
  breakpoint_set_commands (tp, commands);
d688 2
a689 1
  struct breakpoint *tp;
d707 1
a707 1

d715 1
a715 1
  sal = find_pc_line (tp->loc->address, 0);
d722 1
a722 1
  funcname = pc_function_name (tp->loc->address);
d729 1
a729 1
			    Tcl_NewStringObj (core_addr_to_string (tp->loc->address), -1));
d731 1
a731 1
			    Tcl_NewIntObj (tp->enable_state == bp_enabled));
d737 1
a737 1
			    Tcl_NewIntObj (tp->thread));
d739 1
a739 1
			    Tcl_NewIntObj (tp->hit_count));
d743 1
a743 1
  if (tp->commands != NULL)
d745 1
a745 1
      for (cl = breakpoint_commands (tp); cl != NULL; cl = cl->next)
@


1.40
log
@	* generic/gdbtk-bp.c (tracepoint_exists): Remove recently
	removed "not_found_ptr" argument from call to decode_line_1.
	* generic/gdbtk-stack.c (gdb_get_vars_command): Likewise.
	* generic/gdbtk-cmds.c (gdb_get_line_command): Likewise.
	(gdb_get_file_command): Likewise.
	(gdb_get_function_command): Likewise.

	From Kevin Buettner  <kevinb@@redhat.com>
	* generic/gdbtk-register.c (): Delete declaration of `buffer'.
	Use `valaddr' in its place.
@
text
@d45 2
a82 7
/* Breakpoint/Tracepoint lists. Unfortunately, gdb forces us to
   keep a list of breakpoints, too. Why couldn't it be done like
   treacepoints? */
#define DEFAULT_LIST_SIZE 32
static struct breakpoint **breakpoint_list;
static int breakpoint_list_size = DEFAULT_LIST_SIZE;

d117 3
a119 3
void gdbtk_create_breakpoint (int);
void gdbtk_delete_breakpoint (int);
void gdbtk_modify_breakpoint (int);
a153 4
  /* Initialize our tables of BPs. */
  breakpoint_list = (struct breakpoint **) xmalloc (breakpoint_list_size * sizeof (struct breakpoint *));
  memset (breakpoint_list, 0, breakpoint_list_size * sizeof (struct breakpoint *));

a202 1
  int i;
d205 1
d218 1
a218 1
  for (i = 0; i < breakpoint_list_size; i++)
d220 1
a220 2
      if (breakpoint_list[i] != NULL && breakpoint_list[i]->loc != NULL
	  && breakpoint_list[i]->loc->address == addr)
d222 1
a222 1
				  Tcl_NewIntObj (i));
d242 2
a243 1
  int i, line;
d262 8
a269 6
  for (i = 0; i < breakpoint_list_size; i++)
    if (breakpoint_list[i] != NULL
	&& breakpoint_list[i]->line_number == line
	&& !strcmp (breakpoint_list[i]->source_file, s->filename))
      Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr,
				Tcl_NewIntObj (i));
d307 5
a311 1
  b = (bpnum <= breakpoint_list_size ? breakpoint_list[bpnum] : NULL);
a465 1
  int i;
d467 1
d475 8
a482 9
  for (i = 0; i < breakpoint_list_size; i++)
    {
      if (breakpoint_list[i] != NULL
	  && breakpoint_list[i]->type == bp_breakpoint)
	{
	  new_obj = Tcl_NewIntObj (i);
	  Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr, new_obj);
	}
    }
d574 1
a574 1
gdbtk_create_breakpoint (int num)
a575 7
  struct breakpoint *b;
  for (b = breakpoint_chain; b != NULL; b = b->next)
    {
      if (b->number == num)
	break;
    }

d579 1
a579 12
  /* Check if there is room to store it */
  if (num >= breakpoint_list_size)
    {
      int oldsize = breakpoint_list_size;
      while (num >= breakpoint_list_size)
	breakpoint_list_size += DEFAULT_LIST_SIZE;
      breakpoint_list = (struct breakpoint **) xrealloc (breakpoint_list, breakpoint_list_size * sizeof (struct breakpoint *));
      memset (&(breakpoint_list[oldsize]), 0, (breakpoint_list_size - oldsize) * sizeof (struct breakpoint *));
    }

  breakpoint_list[num] = b;
  breakpoint_notify (num, "create");
d583 1
a583 1
gdbtk_delete_breakpoint (int num)
d585 1
a585 7
  if (num >= 0
      && num <= breakpoint_list_size
      && breakpoint_list[num] != NULL)
    {
      breakpoint_notify (num, "delete");
      breakpoint_list[num] = NULL;
    }
d589 1
a589 1
gdbtk_modify_breakpoint (int num)
d591 2
a592 2
  if (num >= 0)
    breakpoint_notify (num, "modify");
d605 1
d607 7
a613 3
  if (num > breakpoint_list_size
      || num < 0
      || breakpoint_list[num] == NULL
d615 1
a615 1
      || breakpoint_list[num]->type != bp_breakpoint)
d620 1
a620 1
  buf = xstrprintf ("gdbtk_tcl_breakpoint %s %d", action, num);
d624 1
a624 1
  free(buf); 
@


1.39
log
@	* generic/gdbtk-bp.c (tracepoint_exists): Update for
	decode_line_1 API change.
	* generic/gdbtk-cmds.c (gdb_eval): Use comman_val_print
	instead of val_print.
	(gdb_get_line_command): Update for decode_line_1 API
	changes.
	(gdb_get_file_command): Likewise.
	(gdb_get_function_command): Likewise.
	* generic/gdbtk-register.c (get_register_types): Use
	get_frame_register_value instead of frame_register.
	(get_register): Pass valid VALUE to val_print.
	Consolidate calls to get_current_gdbarch.
	* generic/gdbtk-stack.c (gdb_get_vars_command): Update
	for decode_line_1 API change.
@
text
@d834 1
a834 1
  sals = decode_line_1 (&args, 1, NULL, 0, NULL, NULL);
@


1.38
log
@	* generic/gdbtk-bp.c (gdb_set_bp): Update for recent
	create_breakpoint API update.
@
text
@d2 2
a3 1
   Copyright (C) 2001, 2002, 2008, 2009, 2010 Free Software Foundation, Inc.
a829 1
  char **canonical;
d834 1
a834 1
  sals = decode_line_1 (&args, 1, NULL, 0, &canonical, NULL);
@


1.37
log
@	* generic/gdbtk-bp.c (gdb_set_bp): Update arguments for API
	change in create_breakpoint.
@
text
@d557 1
a557 1
			 enabled);
@


1.36
log
@  * generic/gdbtk-bp.c (gdb_get_breakpoint_info): Use
  breakpoint_commands to access breakpoint commands.
  (gdb_get_tracepoint_info): Likewise for tracepoint actions.
@
text
@d552 1
a552 2
			 0	/* hardware flag */,
			 0	/* trace flag */,
@


1.35
log
@  * generic/gdbtk-bp.c (gdb_get_breakpoint_info): Breakpoint
  commands are now reference counted. Adjust data pointers.
  (gdb_get_tracepoint_info): Likewise.
  (gdb_actions_command): Don't free previous actions. If the
  commands aren't valid, we would prefer to keep the old ones
  any way. break_point_set_commands will also clobber any
  previous results anyway.
@
text
@d365 1
a365 1
			    get_breakpoint_commands (b->commands ? b->commands->commands : NULL));
d775 1
a775 1
      for (cl = tp->commands->commands; cl != NULL; cl = cl->next)
@


1.34
log
@  * generic/gdbtk-bp.c (gdb_set_bp): set_breakpoint is no more.
  Use create_breakpoint.
  (gdbtk_obj_array, gdbtk_obj_array_ptr, gdbtk_obj_array_cnt):
  New globals.
  (gdbtk_read_next_line): New function.
  (gdb_actions_command): Rewrite using new command_line
  infrastructure.
  (gdb_get_tracepoint_info): Actions are now stored in the breakpoint
  struct's commands element.
@
text
@d365 1
a365 1
			    get_breakpoint_commands (b->commands));
a686 3
  /* Free any existing actions.  */
  free_command_lines (&tp->commands);

d773 1
a773 1
  for (cl = tp->commands; cl != NULL; cl = cl->next)
d775 6
a780 2
      Tcl_ListObjAppendElement (interp, action_list,
				Tcl_NewStringObj (cl->line, -1));
a781 1
  Tcl_ListObjAppendElement (interp, result_ptr->obj_ptr, action_list);
@


1.33
log
@	Add trace file support.
	* tracepoint.h (enum trace_stop_reason): New enum.
	(struct trace_status): New struct.
	(parse_trace_status): Declare.
	(struct uploaded_tp): Move here from remote.c,
	add fields for actions.
	(struct uploaded_tsv): New struct.
	* tracepoint.c (tfile_ops): New target vector.
	(trace_fd): New global.
	(tfile_open): New function.
	(tfile_close): New function.
	(tfile_files_info): New function.
	(tfile_get_trace_status): New function.
	(tfile_get_traceframe_address): New function.
	(tfile_trace_find): New function.
	(tfile_fetch_registers): New function.
	(tfile_xfer_partial): New function.
	(tfile_get_trace_state_variable_value): New function.
	(init_tfile_ops): New function.
	(_initialize_tracepoint): Call it, add tfile target.
	(trace_status): New global.
	(current_trace_status): New function.
	(trace_running_p): Remove, change all users to get from
	current_trace_status()->running.
	(get_trace_status): Remove.
	(trace_status_command): Call target_get_trace_status directly,
	report more detail including tracing stop reasons.
	(trace_find_command): Always allow tfind on a file.
	(trace_find_pc_command): Ditto.
	(trace_find_tracepoint_command): Ditto.
	(trace_find_line_command): Ditto.
	(trace_find_range_command): Ditto.
	(trace_find_outside_command): Ditto.
	(trace_frames_offset, cur_offset): Declare as off_t.
	(trace_regblock_size): Rename from reg_size, update users.
	(parse_trace_status): New function.
	(tfile_interp_line): New function.
	(disconnect_or_stop_tracing): Ensure current trace
	status before asking what to do.
	(stop_reason_names): New global.
	(trace_save_command): New command.
	(get_uploaded_tp): Move here from remote.c.
	(find_matching_tracepoint): Ditto.
	(merge_uploaded_tracepoints): New function.
	(parse_trace_status): Use stop_reason_names.
	(_initialize_tracepoint): Define tsave command.
	* target.h (target_ops): New fields to_save_trace_data,
	to_upload_tracepoints, to_upload_trace_state_variables,
	to_get_raw_trace_data, change to_get_trace_status
	to take a pointer to a status struct.
	(target_save_trace_data): New macro.
	(target_upload_tracepoints): New macro.
	(target_upload_trace_state_variables): New macro.
	(target_get_raw_trace_data): New macro.
	* target.c (update_current_target): Add new methods, change
	signature of to_get_trace_status.
	* remote.c (hex2bin): Make globally visible.
	(bin2hex): Ditto.
	(remote_download_trace_state_variable): Download name also.
	(remote_get_trace_status): Update parameter, use
	parse_trace_status.
	(remote_save_trace_data): New function.
	(remote_upload_tracepoints): New function.
	(remote_upload_trace_state_variables): New function.
	(remote_get_raw_trace_data): New function.
	(remote_start_remote): Use them.
	(_initialize_remote_ops): Add operations.
	* ax-gdb.c: Include breakpoint.h.
	* breakpoint.c (create_tracepoint_from_upload): Use
	break_command_really, return tracepoint, warn about unimplemented
	parts.
	* NEWS: Mention trace file addition.

	* gdb.texinfo (Trace Files): New section.
	(Tracepoint Packets): Document QTSave and qTBuffer.
	(Trace File Format): New appendix.

	* generic/gdbtk-bp.c (gdb_trace_status): Use current_trace_status.

	* gdb.trace/tfile.c: New file.
	* gdb.trace/tfile.exp: New file.
@
text
@d2 1
a2 1
   Copyright (C) 2001, 2002, 2008, 2009 Free Software Foundation, Inc.
d36 5
d164 11
d549 10
a558 3
      set_breakpoint (get_current_arch (), address, condition,
		      0 /* hardwareflag */, temp, thread, ignore_count,
		      pending, enabled);
d668 1
d670 1
a670 6
  Tcl_Obj **actions;
  int nactions, i, len;
  char *number, *args, *action;
  long step_count;
  struct action_line *next = NULL, *temp;
  enum actionline_type linetype;
d678 2
a679 2
  args = number = Tcl_GetStringFromObj (objv[1], NULL);
  tp = get_tracepoint_by_number (&args, 0, 0);
d687 2
a688 17
  /* Free any existing actions */
  if (tp->actions != NULL)
    free_actions (tp);

  step_count = 0;

  Tcl_ListObjGetElements (interp, objv[2], &nactions, &actions);

  /* Add the actions to the tracepoint */
  for (i = 0; i < nactions; i++)
    {
      temp = xmalloc (sizeof (struct action_line));
      temp->next = NULL;
      action = Tcl_GetStringFromObj (actions[i], &len);
      temp->action = savestring (action, len);

      linetype = validate_actionline (&(temp->action), tp);
d690 6
a695 17
      if (linetype == BADLINE)
	{
	  free (temp);
	  continue;
	}

      if (next == NULL)
	{
	  tp->actions = temp;
	  next = temp;
	}
      else
	{
	  next->next = temp;
	  next = temp;
	}
    }
d697 1
d723 1
a723 1
  struct action_line *al;
d776 1
a776 1
  for (al = tp->actions; al != NULL; al = al->next)
d779 1
a779 1
				Tcl_NewStringObj (al->action, -1));
@


1.32
log
@	* library/srctextwin.itb (lookup_line): Update parameters
	to gdb_set_bp.
	* generic/gdbtk-bp.c: Remove extern declarations for symbols
	in breakpoint.c.
	(gdb_set_bp_addr): Remove.
	(Gdbtk_Breakpoint_Init): Remove Tcl command "gdb_set_bp_addr".
	(gdb_set_bp): Remove file and line arguments; add "addr" argument.
	Rewrite to use "public" APIs from gdb.
@
text
@d822 1
a822 1
  if (trace_running_p)
@


1.31
log
@	* generic/gdbtk-bp.c: Include "arch-utils.h".
	(set_raw_breakpoint): Update external definition.
	(gdb_set_bp): Adapt to set_raw_breakpoint change.
	(gdb_set_bp_addr): Likewise.
	* generic/gdbtk-cmds.c: Include "arch-utils.h.
	(gdbtk_load_asm): Adapt to paddress and gdb_print_insn changes.
	(hex2bin): Replace current_gdbarch by get_current_arch call.
	(gdb_update_mem): Adapt to builtin_type changes.
	(gdb_CA_to_TAS): Use paddress to replace removed function paddr_nz.
	* generic/gdbtk-register.c: Include "arch-utils.h".
	(get_register_size): Replace current_gdbarch by get_current_arch call.
	(get_register_types): Likewise.
	(get_register): Likewise.
	(get_register_name): Likewise.
	(map_arg_registers): Likewise.
	(register_changed_p): Likewise.
	(setup_architecture_data): Likewise.
	(gdb_regformat): Likewise.
	(gdb_reggrouplist): Likewise.
	(gdb_reggroup): Likewise.
	* generic/gdbtk-stack.c: Inlcude "arch-utils.h".
	(gdb_get_blocks): Use paddress instead of removed paddr_nz function.
	(gdb_selected_block): Likewise.
	(gdb_selected_frame): Likewise.
@
text
@d2 1
a2 1
   Copyright (C) 2001, 2002, 2008 Free Software Foundation, Inc.
d34 1
a74 11
/*
 * These are routines we need from breakpoint.c.
 * at some point make these static in breakpoint.c and move GUI code there
 */

extern struct breakpoint *set_raw_breakpoint (struct gdbarch *gdbarch,
					      struct symtab_and_line,
					      enum bptype);
extern void set_breakpoint_count (int);
extern int breakpoint_count;

a95 2
static int gdb_set_bp_addr (ClientData, Tcl_Interp *, int,
			    Tcl_Obj * CONST objv[]);
a137 2
  Tcl_CreateObjCommand (interp, "gdb_set_bp_addr", gdbtk_call_wrapper,
			gdb_set_bp_addr, NULL);
d478 1
a478 2
 *    filename: the file in which to set the breakpoint
 *    line:     the line number for the breakpoint
d488 9
a496 5
  struct symtab_and_line sal;
  int line, thread = -1;
  struct breakpoint *b;
  char *buf, *typestr;
  enum bpdisp disp;
d498 1
a498 1
  if (objc != 4 && objc != 5)
d500 1
a500 1
      Tcl_WrongNumArgs (interp, 1, objv, "filename line type ?thread?");
d504 2
a505 5
  sal.symtab = lookup_symtab (Tcl_GetStringFromObj (objv[1], NULL));
  if (sal.symtab == NULL)
    return TCL_ERROR;

  if (Tcl_GetIntFromObj (interp, objv[2], &line) == TCL_ERROR)
d511 1
a511 1
  typestr = Tcl_GetStringFromObj (objv[3], NULL);
d513 1
a513 1
    disp = disp_del;
d515 1
a515 1
    disp = disp_donttouch;
d522 1
a522 1
  if (objc == 5)
d524 1
a524 1
      if (Tcl_GetIntFromObj (interp, objv[4], &thread) == TCL_ERROR)
d531 1
a531 46
  sal.line = line;
  if (!find_line_pc (sal.symtab, sal.line, &sal.pc))
    return TCL_ERROR;

  sal.section = find_pc_overlay (sal.pc);
  b = set_raw_breakpoint (get_current_arch (), sal, bp_breakpoint);
  set_breakpoint_count (breakpoint_count + 1);
  b->number = breakpoint_count;
  b->disposition = disp;
  b->thread = thread;

  /* FIXME: this won't work for duplicate basenames! */
  buf = xstrprintf ("%s:%d", lbasename (Tcl_GetStringFromObj (objv[1], NULL)),
	     line);
  b->addr_string = xstrdup (buf);
  free(buf);

  /* now send notification command back to GUI */
  observer_notify_breakpoint_created (b->number);
  return TCL_OK;
}

/* This implements the tcl command "gdb_set_bp_addr"
 * It sets breakpoints, and notifies the GUI.
 *
 * Tcl Arguments:
 *    addr:     the CORE_ADDR at which to set the breakpoint
 *    type:     the type of the breakpoint
 *    thread:   optional thread number
 * Tcl Result:
 *    The return value of the call to gdbtk_tcl_breakpoint.
 */
static int
gdb_set_bp_addr (ClientData clientData, Tcl_Interp *interp, int objc,
		 Tcl_Obj *CONST objv[])
     
{
  struct symtab_and_line sal;
  int thread = -1;
  CORE_ADDR addr;
  Tcl_WideInt waddr;
  struct breakpoint *b;
  char *saddr, *typestr;
  enum bpdisp disp;

  if (objc != 3 && objc != 4)
d533 3
a535 2
      Tcl_WrongNumArgs (interp, 1, objv, "address type ?thread?");
      return TCL_ERROR;
d538 1
a538 1
  if (Tcl_GetWideIntFromObj (interp, objv[1], &waddr) != TCL_OK)
a539 31
  addr = waddr;
  saddr = Tcl_GetStringFromObj (objv[1], NULL);

  typestr = Tcl_GetStringFromObj (objv[2], NULL);
  if (strncmp (typestr, "temp", 4) == 0)
    disp = disp_del;
  else if (strncmp (typestr, "normal", 6) == 0)
    disp = disp_donttouch;
  else
    {
      gdbtk_set_result (interp, "type must be \"temp\" or \"normal\"");
      return TCL_ERROR;
    }

  if (objc == 4)
    {
      if (Tcl_GetIntFromObj (interp, objv[3], &thread) == TCL_ERROR)
	{
	  result_ptr->flags = GDBTK_IN_TCL_RESULT;
	  return TCL_ERROR;
	}
    }

  sal = find_pc_line (addr, 0);
  sal.pc = addr;
  b = set_raw_breakpoint (get_current_arch (), sal, bp_breakpoint);
  set_breakpoint_count (breakpoint_count + 1);
  b->number = breakpoint_count;
  b->disposition = disp;
  b->thread = thread;
  b->addr_string = xstrdup (saddr);
a540 2
  /* now send notification command back to GUI */
  observer_notify_breakpoint_created (b->number);
@


1.30
log
@2009-03-30  Stan Shebs  <stan@@codesourcery.com>

	Make tracepoints into a type of breakpoint.
	* breakpoint.h (enum bptype): Add bp_tracepoint.
	(struct breakpoint): Add fields step_count, pass_count, actions.
	(get_tracepoint, get_tracepoint_by_number): Declare.
	(all_tracepoints): Declare.
	* breakpoint.c: Include tracepoint.h, readline.h.
	(ALL_TRACEPOINTS): Move here from tracepoint.c.
	(tracepoint_count): Ditto.
	(should_be_inserted): GDB does not insert tracepoints itself.
	(print_it_typical): Add tracepoint case.
	(bpstat_what): Ditto.
	(print_one_breakpoint_location): Ditto, and add printing for
	pass count, step count, and action list.
	(user_settable_breakpoint): Add tracepoint case.
	(allocate_bp_location): Ditto.
	(set_breakpoint_location_function): Ditto.
	(disable_breakpoints_in_shlibs): Ditto.
	(mention): Ditto.
	(break_command_really): Add argument traceflag, use to choose
	basic breakpoint type.
	(break_command_1): Pass extra argument.
	(set_breakpoint, handle_gnu_v3_exceptions): Ditto.
	(breakpoint_re_set_one): Add tracepoint case.
	(disable_command, enable_command): Ditto.
	(set_tracepoint_count): Move here from tracepoint.c.
	(trace_command): Move here from tracepoint.c and use
	break_command_really.
	(tracepoints_info): Move here from tracepoint.c and call
	breakpoints_info.
	(enable_trace_command): Move here from tracepoint.c and call
	enable_command.
	(disable_trace_command): Move here from tracepoint.c and call
	disable_command.
	(delete_trace_command): Move here from tracepoint.c and call
	delete_breakpoint.
	(trace_pass_command): Move here from tracepoint.c.
	(get_tracepoint_by_number): Ditto.
	(tracepoint_save_command): Ditto.
	(get_tracepoint): New function.
	(all_tracepoints): New function.
	(_initialize_breakpoint): Move tracepoint init from tracepoint.c,
	deprecate "enable trace" and "disable trace" commands.
	* tracepoint.h (struct tracepoint): Remove.
	(tracepoint_chain): Remove decl.
	(deprecated_create_tracepoint_hook): Remove decl.
	(deprecated_delete_tracepoint_hook): Remove decl.
	(deprecated_modify_tracepoint_hook): Remove decl.
	(ALL_TRACEPOINTS, ALL_TRACEPOINTS_SAFE): Remove.
	(free_actions): Update signature.
	(validate_actionline): Update signature.
	(end_actions_pseudocommand): Declare.
	(while_stepping_pseudocommand): Declare.
	* tracepoint.c: Include breakpoint.h.
	(tracepoint_chain, tracepoint_count): Remove.
	(free_actions, make_cleanup_free_actions): Update signature.
	(trace_command, set_raw_tracepoint): Remove.
	(trace_mention): Remove.
	(tracepoints_info): Remove.
	(tracepoint_operation, map_args_over_tracepoints): Remove.
	(get_tracepoint_by_number): Remove.
	(enable_trace_command, disable_trace_command): Remove.
	(delete_trace_command, trace_pass_command): Remove.
	(trace_actions_command, read_actions): Update signature.
	(validate_actionline): Update signature, use bp loc.
	(encode_actions): Ditto.
	(download_tracepoint): New function, body of trace_start_command.
	(trace_start_command): Call it, use all_tracepoints.
	(tracepoint_save_command): Remove.
	(tracepoint_dump_command): Use get_tracepoint.
	(end_actions_pseudocommand): Make globally visible.
	(while_stepping_pseudocommand): Ditto.
	(_initialize_tracepoint): Move command definitions to breakpoint.c.

	doc/
	* gdb.texinfo (Tracepoints): Describe tracepoints as a
	special case of breakpoints.
	(Enable and Disable Tracepoints): Mention deprecation.
	(Listing Tracepoints): Update description and example.

	testsuite/
	* gdb.trace/actions.exp: Update to match new info trace format.
	* gdb.trace/deltrace.exp: Ditto.
	* gdb.trace/infotrace.exp: Ditto.
	* gdb.trace/passcount.exp: Ditto.
	* gdb.trace/save-trace.exp: Ditto.
	* gdb.trace/while-stepping.exp: Ditto.
	* gdb.trace/tracecmd.exp: Ditto, plus don't allow pending option.

	gdbtk/
	* generic/gdbtk-bp.c (gdb_actions_command): Update to handle
	tracepoints as breakpoints.
	(gdb_get_tracepoint_info): Ditto, plus use get_tracepoint and
	breakpoint locations.
	(tracepoint_exists): Ditto, plus use all_tracepoints.
@
text
@d33 1
d79 3
a81 2
extern struct breakpoint *set_raw_breakpoint (struct symtab_and_line sal,
					      enum bptype bp_type);
d550 1
a550 1
  b = set_raw_breakpoint (sal, bp_breakpoint);
d623 1
a623 1
  b = set_raw_breakpoint (sal, bp_breakpoint);
@


1.29
log
@	ARI fix: "xasprintf" rule.
	* generic/gdbtk-bp.c (gdb_set_bp): Replace xasprintf by xstrprintf.
	(breakpoint_notify, tracepoint_notify):Ditto.
	* generic/gdbtk-cmds.c (gdbtk_load_source, gdbtk_load_asm):Ditto.
	* generic/gdbtk-hooks.c (gdbtk_ignorable_warning): Ditto.
	(gdbtk_set_hook, gdbtk_load_hash): Ditto.
	(gdbtk_selected_frame_changed, gdbtk_annotate_signal): Ditto.
	* generic/gdbtk-register.c (get_register_types):Ditto.
	* generic/gdbtk-stack.c (gdb_get_blocks): Ditto.
	(gdb_selected_block, gdb_selected_frame): Ditto.
	* generic/gdbtk.c (gdbtk_init, view_command): Ditto.
@
text
@d734 1
a734 1
  struct tracepoint *tp;
d817 1
a817 1
  struct tracepoint *tp;
d834 1
a834 3
  ALL_TRACEPOINTS (tp)
    if (tp->number == tpnum)
      break;
d843 1
a843 1
  sal = find_pc_line (tp->address, 0);
d850 1
a850 1
  funcname = pc_function_name (tp->address);
d857 1
a857 1
			    Tcl_NewStringObj (core_addr_to_string (tp->address), -1));
d859 1
a859 1
			    Tcl_NewIntObj (tp->enabled_p));
d888 3
a890 1
  struct tracepoint *tp;
d894 2
a895 1
  ALL_TRACEPOINTS (tp)
d898 1
d922 3
a924 1
  struct tracepoint *tp;
d941 2
a942 1
	  ALL_TRACEPOINTS (tp)
d944 1
a944 1
	      if (tp->address == sals.sals[0].pc)
d954 1
@


1.28
log
@Fix insight crash when setting pending breakpoints:

2008-09-19  Denis Pilat  <denis.pilat@@st.com>

	* generic/gdbtk-bp.c (gdb_get_breakpoint_info): Manage the case of NULL
	location to handle pending breakpoint in a better way.
	(gdb_find_bp_at_addr): Likewise.
@
text
@d555 1
a555 1
  xasprintf (&buf, "%s:%d", lbasename (Tcl_GetStringFromObj (objv[1], NULL)),
d709 1
a709 1
  xasprintf (&buf, "gdbtk_tcl_breakpoint %s %d", action, num);
d1007 1
a1007 1
  xasprintf (&buf, "gdbtk_tcl_tracepoint %s %d", action, num);
@


1.27
log
@gdb:
	* tui/tui-hooks.c: Include observer.h.
	(tui_event_default, tui_old_event_hooks, tui_event_hooks):
	Remove.
	(tui_bp_created_observer, tui_bp_deleted_observer,
	tui_bp_modified_observer): New globals.
	(tui_install_hooks): Use observers, not events.
	(tui_remove_hooks): Likewise.
	* mi/mi-cmd-break.c: Include observer.h, not gdb-events.h.
	(mi_breakpoint_observers_installed, mi_can_breakpoint_notify): New
	globals.
	(breakpoint_notify): Check mi_can_breakpoint_notify.
	(breakpoint_hooks): Remove.
	(mi_cmd_break_insert): Attach observers.  Don't use events.
	* tracepoint.c: Include observer.h, not gdb-events.h.
	(tracepoint_operation, trace_pass_command): Notify observer.
	* interps.c: Don't include gdb-events.h.
	(clear_interpreter_hooks): Don't call clear_gdb_event_hooks.
	* gdbarch.c: Rebuild.
	* gdbarch.sh: Emit include for observer.h, not gdb-events.h.
	(deprecated_current_gdbarch_select_hack): Notify observer.
	* breakpoint.h: Don't include gdb-events.h.
	* breakpoint.c: Don't include gdb-events.h.
	(condition_command): Notify observer.
	(commands_command): Likewise.
	(commands_from_control_command): Likewise.
	(mention, delete_breakpoint, set_ignore_count): Likewise.
	(disable_breakpoint, do_enable_breakpoint): Likewise.
	* Makefile.in (gdb_events_h): Remove.
	(breakpoint_h): Update.
	(COMMON_OBS): Remove gdb-events.o.
	(gdb-events.o): Remove.
	(breakpoint.o, gdbarch.o, interps.o, tracepoint.o, gdbtk-bp.o,
	gdbtk-hooks.o, mi-cmd-break.o, tui-hooks.o): Update.
	* gdb-events.c: Remove.
	* gdb-events.h: Remove.
	* gdb-events.sh: Remove.
gdb/doc:
	* observer.texi (GDB Observers): Document new observers:
	breakpoint_created, breakpoint_deleted, breakpoint_modified,
	tracepoint_created, tracepoint_deleted, tracepoint_modified,
	architecture_changed.
gdb/gdbtk:
	* generic/gdbtk-hooks.c: Include observer.h, not gdb-events.h.
	(gdbtk_add_hooks): Use observers, not events.
	(gdbtk_architecture_changed): Add argument, for observer.
	* generic/gdbtk-bp.c: Include observer.h.
	(gdb_set_bp): Notify observer.
	(gdb_set_bp_addr): Likewise.
@
text
@d224 1
a224 1
      if (breakpoint_list[i] != NULL
d293 1
d316 1
a316 6
  sal = find_pc_line (b->loc->address, 0);

  filename = symtab_to_filename (sal.symtab);
  if (filename == NULL)
    filename = "";

d318 17
a334 2
  Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr,
			    Tcl_NewStringObj (filename, -1));
d336 14
a349 3
  funcname = pc_function_name (b->loc->address);
  new_obj = Tcl_NewStringObj (funcname, -1);
  Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr, new_obj);
a351 6
			    Tcl_NewIntObj (b->line_number));
  Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr,
			    Tcl_NewStringObj (core_addr_to_string
					      (b->loc->address),
					      -1));
  Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr,
@


1.26
log
@	* generic/gdbtk.h:
	* generic/gdbtk.c:
	* generic/gdbtk-wrapper.h:
	* generic/gdbtk-wrapper.c:
	* generic/gdbtk-varobj.c:
	* generic/gdbtk-stack.c:
	* generic/gdbtk-register.c:
	* generic/gdbtk-main.c:
	* generic/gdbtk-interp.c:
	* generic/gdbtk-hooks.c:
	* generic/gdbtk-cmds.h:
	* generic/gdbtk-cmds.c:
	* generic/gdbtk-bp.c: Put (C) after Copyright.  Update the FSF
	address.
@
text
@d2 1
a2 1
   Copyright (C) 2001, 2002 Free Software Foundation, Inc.
d32 1
d545 1
a545 1
  breakpoint_create_event (b->number);
d613 1
a613 1
  breakpoint_create_event (b->number);
@


1.25
log
@        * generic/gdbtk-cmds.c (gdb_set_mem): target_write_memory now takes
        gdb_byte* instead of char*.
        * generic/gdbtk-register.c (get_register): frame_register and val_print
        take gdb_byte* instead of char*.
        * generic/gdbtk-wrapper.c: Ditto the val_print part.

        From Paul Schlie  <schlie@@comcast.net>:
        * generic/gdbtk-bp.c (gdb_set_bp): Use lbasename instead of basename.
        * generic/gdbtk-cmds.c (gdb_listfiles): Likewise.
@
text
@d2 1
a2 1
   Copyright 2001, 2002 Free Software Foundation, Inc.
d18 2
a19 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.24
log
@2004-07-02  Martin Hunt  <hunt@@redhat.com>

	* generic/gdbtk-cmds.c (symtab_to_filename): New function. Like
	symtab_to_fullname() but returns the filename if the fullname
	cannot be found.

	* generic/gdbtk-cmds.c (gdb_find_file_command): Revert
	patch of 2004-06-11. Use symtab_to_filename() again.
	(gdb_loc): Ditto.
	(gdb_loadfile): Ditto.
	* generic/gdbtk-bp.c (gdb_get_breakpoint_info): Ditto.
	(gdb_get_tracepoint_info): Ditto.

	* generic/gdbtk-cmds.h: Declare symtab_to_filename().
@
text
@d538 1
a538 1
  xasprintf (&buf, "%s:%d", basename (Tcl_GetStringFromObj (objv[1], NULL)),
@


1.23
log
@2004-06-11  Martin Hunt  <hunt@@redhat.com>

	* generic/gdbtk-cmds.c (gdb_find_file_command): Use
	symtab_to_fullname() instead of symtab_to_filename().
	(gdb_loc): Ditto.
	(gdb_loadfile): Ditto.
	* generic/gdbtk-bp.c (gdb_get_breakpoint_info): Ditto.
	(gdb_get_tracepoint_info): Ditto.

	* generic/gdbtk-register.c (get_register): Simplify and remove
	references to DEPRECATED_REGISTER_CONVERT_TO_VIRTUAL.
@
text
@d316 1
a316 1
  filename = symtab_to_fullname (sal.symtab);
d829 1
a829 1
  filename = symtab_to_fullname (sal.symtab);
@


1.22
log
@
2003-12-17  Jeff Johnston  <jjohnstn@@redhat.com>

        * generic/gdbtk-bp.c: Change calls to decode_line_1 to add
        new NULL parameter.
        * generic/gdbtk-cmds.c: Ditto.
        * generic/gdbtk-stack.c: Ditto.
@
text
@d24 1
d316 1
a316 1
  filename = symtab_to_filename (sal.symtab);
d829 1
a829 1
  filename = symtab_to_filename (sal.symtab);
@


1.21
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* generic/gdbtk-bp.c (gdb_find_bp_at_addr): Replace use of
	BREAKPOINT->address by BREAKPOINT->loc->address.
	(gdb_get_breakpoint_info): Ditto.
@
text
@d908 1
a908 1
  sals = decode_line_1 (&args, 1, NULL, 0, &canonical);
@


1.20
log
@2003-03-06  Martin M. Hunt  <hunt@@redhat.com>

	* generic/gdbtk-bp.c (gdb_get_tracepoint_info): Return CORE_ADDR.
@
text
@d223 1
a223 1
	  && breakpoint_list[i]->address == addr)
d313 1
a313 1
  sal = find_pc_line (b->address, 0);
d323 1
a323 1
  funcname = pc_function_name (b->address);
d330 3
a332 1
			    Tcl_NewStringObj (core_addr_to_string (b->address), -1));
@


1.19
log
@2003-03-06  Martin M. Hunt  <hunt@@redhat.com>

	* generic/gdbtk-cmds.c (gdb_disassemble): Deleted.
	(sprintf_append_element_to_obj): Deleted.

	* generic/gdbtk-bp.c (get_breakpoint_commands): Use
	Tcl_ListObjAppendElement() instead of
	sprintf_append_element_to_obj().
@
text
@d838 2
a839 7
  {
    char *tmp;
    xasprintf (&tmp, "0x%s", paddr_nz (tp->address));
    Tcl_ListObjAppendElement (interp, result_ptr->obj_ptr,
			      Tcl_NewStringObj (tmp, -1));
    free (tmp);
  }
@


1.18
log
@2003-03-05  Martin M. Hunt  <hunt@@redhat.com>

	* generic/gdbtk-cmds.c (Gdbtk_Init): Create gdb_CA_to_TAS.
	(gdb_load_disassembly): Now takes CORE_ADDRs. Returns CORE_ADDRs
	for low and high.
	(gdbtk_load_asm): Use CORE_ADDRs.
	(gdb_loc): Return CORE_ADDRs.
	(gdb_entry_point): Return CORE_ADDR.
	(gdb_incr_addr): Update description.
	(gdb_CA_to_TAS): New function. Takes a CORE_ADDR and returns
	a target sddress string.

	* generic/gdbtk-bp.c (gdb_find_bp_at_addr): Change to
	take a CORE_ADDR.
	(gdb_get_breakpoint_info): Returns a CORE_ADDR.
	(gdb_set_bp_addr): Takes a CORE_ADDR.

	* library/bpwin.itb (bp_add): Call gdb_CA_to_TAS before
	displaying address.
	(bp_modify): Ditto.

	* library/srcwin.itb (location): Call gdb_CA_to_TAS before
	displaying address. Don't add "0x" in front of address.
	(set_execution_status): Call gdb_CA_to_TAS before
	displaying address. Don't call [gdb_cmd printf] to format
	output. Weird.
@
text
@d361 1
a361 1
   in gdb's cli in order to get at the same command list passed here.
a362 2
   NOTE: cannot use sprintf_append_element_to_obj with anything from
   gdb, since those things could contain unescaped sequences. */
d381 2
a382 1
	  sprintf_append_element_to_obj (obj, "loop_break");
d387 2
a388 1
	  sprintf_append_element_to_obj (obj, "loop_continue");
d398 2
a399 1
	  sprintf_append_element_to_obj (obj, "end");
d412 2
a413 1
	      sprintf_append_element_to_obj (obj, "else");
d417 2
a418 1
	  sprintf_append_element_to_obj (obj, "end");
@


1.17
log
@Index: ChangeLog
2002-08-03  Andrew Cagney  <ac131313@@redhat.com>

* Makefile.in (gdbtk-bp.o): Update dependencies.
(gdbtk-register.o): Ditto.
(gdbtk-varobj.o): Ditto.

Index: gdbtk/ChangeLog
2002-08-03  Andrew Cagney  <ac131313@@redhat.com>

* generic/gdbtk-bp.c: Include "gdb_string.h".
* generic/gdbtk-register.c: Ditto.
* generic/gdbtk-varobj.c: Ditto.
@
text
@d197 1
a197 1
*    addr:     address
d207 1
d214 4
a217 2

  addr = string_to_core_addr (Tcl_GetStringFromObj (objv[1], NULL));
d329 2
a330 2
  sprintf_append_element_to_obj (result_ptr->obj_ptr, "0x%s",
				 paddr_nz (b->address));
d546 1
a546 1
 *    addr: the address at which to set the breakpoint
d560 1
d571 3
d575 1
a575 2
  addr = string_to_core_addr (saddr);
  
@


1.16
log
@2002-02-07  Martin M. Hunt  <hunt@@redhat.com>

	* generic/gdbtk.c, generic/gdbtk-bp.c, generic/gdbtk-cmds.c,
	generic/gdbtk-hooks.c, generic/gdbtk-stack.c: Cleanup includes.
@
text
@d27 1
a27 1

@


1.15
log
@2002-02-06  Martin M. Hunt  <hunt@@redhat.com>

	* generic/gdbtk.c, generic/gdbtk-bp.c, generic/gdbtk-cmds.c,
	generic/gdbtk-hooks.c, generic/gdbtk-register.c,
	generic/gdbtk-stack.c, generic/gdbtk-varobj.c,
	generic/gdbtk-wrapper.c: Cleanup. Fix indentation. Fix
	function declarations. Remove unused variables. Add 2002
	copyrights.
@
text
@a26 1
#include "gdb-events.h"
@


1.14
log
@	* generic/gdbtk-cmds.h (full_lookup_symtab): Don't declare.
	* generic/gdbtk-cmds.c (gdb_find_file_command): Use
	lookup_symtab.
	(gdb_listfuncs): Likewise.
	(gdb_loadfile): Likewise.
	(full_lookup_symtab): Removed.
	* generic/gdbtk-bp.c (gdb_find_bp_at_line): Use lookup_symtab.
	(gdb_set_bp): Likewise.
@
text
@d2 1
a2 1
   Copyright 2001 Free Software Foundation, Inc.
d44 9
a52 9
{"none", "breakpoint", "hw breakpoint", "until",
 "finish", "watchpoint", "hw watchpoint",
 "read watchpoint", "acc watchpoint",
 "longjmp", "longjmp resume", "step resume",
 "sigtramp", "watchpoint scope",
 "call dummy", "shlib events", "catch load",
 "catch unload", "catch fork", "catch vfork",
 "catch exec", "catch catch", "catch throw"
};
d54 1
a54 1
{"delete", "delstop", "disable", "donttouch"};
d192 1
a192 1
 */
d197 5
a201 5
 * Tcl Arguments:
 *    addr:     address
 * Tcl Result:
 *    It returns a list of breakpoint numbers
 */
d231 6
a236 6
 * Tcl Arguments:
 *    filename: the file in which to find the breakpoint
 *    line:     the line number for the breakpoint
 * Tcl Result:
 *    It returns a list of breakpoint numbers
 */
d238 2
a239 5
gdb_find_bp_at_line (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
d243 1
a243 2
  int line;
  int i;
a285 1
  struct command_line *cmd;
d395 1
a395 1
				    get_breakpoint_commands (*cmd->body_list));
d411 1
a411 1
					get_breakpoint_commands(cmd->body_list[1]));
d436 2
a437 5
gdb_get_breakpoint_list (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
d531 1
a531 1
	   line);
d559 1
a559 1
  char *saddr, *typestr, *buf;
d668 1
a668 3
breakpoint_notify (num, action)
     int num;
     const char *action;
d703 2
a704 5
gdb_actions_command (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
d769 2
a770 5
gdb_get_trace_frame_num (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
d808 1
a808 1
    break;
d862 4
a865 5
gdb_get_tracepoint_list (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
d879 4
a882 5
gdb_trace_status (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
d915 3
a917 3
	  {
	    if (tp->address == sals.sals[0].pc)
	      result = tp->number;
d919 5
a923 5
	    /* Why is this here? This messes up assembly traces */
	    else if (tp->source_file != NULL
		     && strcmp (tp->source_file, file) == 0
		     && sals.sals[0].line == tp->line_number)
	      result = tp->number;
d925 1
a925 1
	  }
d934 4
a937 5
gdb_tracepoint_exists_command (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
d978 1
a978 3
tracepoint_notify (num, action)
     int num;
     const char *action;
@


1.13
log
@2001-11-05  Martin M. Hunt  <hunt@@redhat.com>
	* generic/gdbtk-cmds.h (gdbtk_set_result): Declare.
	A printf-like function to return error messages.
	* generic/gdbtk-cmds.c (gdbtk_set_result): New
	function.
	(gdb_cmd): Use gdbtk_set_result.
	(gdb_immediate_command): Ditto.
	(gdb_load_info): Ditto.
	(gdb_find_file_command): Ditto.
	(gdb_listfuncs): Ditto.
	(gdb_load_disassembly): Ditto.
	(gdb_loc): Ditto.
	(gdb_set_mem): Ditto.
	(gdb_get_mem): Ditto.
	(gdb_loadfile): Ditto.
	* generic/gdbtk-varobj.c (variable_format): Ditto.
	(variable_value): Ditto.
	* generic/gdbtk-stack.c (gdb_get_vars_command): Ditto.
	* generic/gdbtk-bp.c (gdb_get_breakpoint_info): Ditto.
	(gdb_set_bp): Ditto.
	(gdb_set_bp_addr): Ditto.
	(gdb_get_tracepoint_info): Ditto.
@
text
@d255 1
a255 1
  s = full_lookup_symtab (Tcl_GetStringFromObj (objv[1], NULL));
d496 1
a496 1
  sal.symtab = full_lookup_symtab (Tcl_GetStringFromObj (objv[1], NULL));
@


1.12
log
@2001-10-29  Martin M. Hunt  <hunt@@redhat.com>

	* generic/gdbtk-bp.c (gdb_set_bp_addr): When setting
	the bp addr_string, use the string the function was called
	with instead of using sprintf to write a new one. This
	avoids a problem with truncating 64-bit addresses.

	* library/srcbar.itcl (SrcBar::create_buttons) Don't
	set width of address label.
	(SrcBar::address) When the address changes, recompute
	width of address label.  If it is more than 10, force it
	to 18, otherwise use 10.
@
text
@d312 1
a312 4
      char *err_buf;
      xasprintf (&err_buf, "Breakpoint #%d does not exist.", bpnum);
      Tcl_SetStringObj (result_ptr->obj_ptr, err_buf, -1);
      free(err_buf);
d513 1
a513 2
      Tcl_SetObjResult (interp, 
			Tcl_NewStringObj ("type must be \"temp\" or \"normal\"", -1));
d586 1
a586 2
      Tcl_SetObjResult (interp, 
			Tcl_NewStringObj ("type must be \"temp\" or \"normal\"", -1));
d828 1
a828 4
      char *buff;
      xasprintf (&buff, "Tracepoint #%d does not exist", tpnum);
      Tcl_SetStringObj (result_ptr->obj_ptr, buff, -1);
      free(buff);
@


1.11
log
@2001-10-29  Martin M. Hunt  <hunt@@redhat.com>

	* generic/gdbtk-bp.c (gdb_find_bp_at_addr): Use
	string_to_core_addr to read address so 64 bits will work.
	(gdb_set_bp): Set error message with Tcl_SetObjResult()
	so it will be displayed.
	(gdb_set_bp_addr):Use string_to_core_addr to read address.
	Set error message with Tcl_SetObjResult().

	* generic/gdbtk-cmds.c (gdb_get_mem): :Use string_to_core_addr
	to read address. Set error message with Tcl_SetObjResult() or
	Tcl_WrongNumArgs.
@
text
@d203 2
a204 2
gdb_find_bp_at_addr ( ClientData clientData, Tcl_Interp *interp,
		      int objc, Tcl_Obj *CONST objv[])
d571 1
a571 1
  char *typestr, *buf;
d580 3
a582 2
  addr = string_to_core_addr (Tcl_GetStringFromObj (objv[1], NULL));

d611 1
a611 3

  xasprintf (&buf, "*(0x%lx)", addr);
  b->addr_string = xstrdup (buf);
@


1.10
log
@	* generic/gdbtk-bp.c (get_breakpoint_commands): New function.
	(gdb_get_breakpoint_info): Use gdb_breakpoint_commands to
	assemble breakpoint commands information.
@
text
@d203 2
a204 6
gdb_find_bp_at_addr (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];

d207 1
a207 1
  long addr;
d215 1
a215 5
  if (Tcl_GetLongFromObj (interp, objv[1], &addr) == TCL_ERROR)
    {
      result_ptr->flags = GDBTK_IN_TCL_RESULT;
      return TCL_ERROR;
    }
d221 1
a221 1
	  && breakpoint_list[i]->address == (CORE_ADDR) addr)
d484 2
a485 5
gdb_set_bp (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
a509 5
  if (typestr == NULL)
    {
      result_ptr->flags = GDBTK_IN_TCL_RESULT;
      return TCL_ERROR;
    }
d516 2
a517 2
      Tcl_SetStringObj (result_ptr->obj_ptr,
			"type must be \"temp\" or \"normal\"", -1);
d569 1
a569 1
  long addr;
d580 1
a580 5
  if (Tcl_GetLongFromObj (interp, objv[1], &addr) == TCL_ERROR)
    {
      result_ptr->flags = GDBTK_IN_TCL_RESULT;
      return TCL_ERROR;
    }
a582 5
  if (typestr == NULL)
    {
      result_ptr->flags = GDBTK_IN_TCL_RESULT;
      return TCL_ERROR;
    }
d589 2
a590 2
      Tcl_SetStringObj (result_ptr->obj_ptr,
			"type must be \"temp\" or \"normal\"", -1);
@


1.9
log
@	* generic/gdbtk-bp.c (gdb_get_breakpoint_info): Update
	with recent breakpoint structure changes in gdb.
	(gdb_set_bp_addr): Likewise.
	(gdb_get_tracepoint_info): Update with recent tracepoint
	structure changes in gdb.
@
text
@d119 2
d354 2
a355 5
  new_obj = Tcl_NewObj ();
  for (cmd = b->commands; cmd; cmd = cmd->next)
    Tcl_ListObjAppendElement (NULL, new_obj,
			      Tcl_NewStringObj (cmd->line, -1));
  Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr, new_obj);
d373 69
@


1.8
log
@	* generic/gdbtk-bp.c (gdbtk_tracepoint_create): Change
	parameter to int to match breakpoint notifications.
	(gdbtk_tracepoint_modify): Ditto.
	(gdbtk_tracepoint_delete): Ditto.
	(tracepoint_notify): Ditto.
	* generic/gdbtk-hooks.c (gdbtk_add_hooks): Remove
	tracepoint hooks and install tracepoint event handlers.
@
text
@d346 1
a346 1
			    Tcl_NewBooleanObj (b->enable == enabled));
d459 1
a459 1
    disp = del;
d461 1
a461 1
    disp = donttouch;
d541 1
a541 1
    disp = del;
d543 1
a543 1
    disp = donttouch;
d820 1
a820 1
			    Tcl_NewIntObj (tp->enabled));
@


1.8.4.1
log
@        * generic/gdbtk-bp.c (gdb_get_breakpoint_info): Update
        with recent breakpoint structure changes in gdb.
        (gdb_set_bp_addr): Likewise.
        (gdb_get_tracepoint_info): Update with recent tracepoint
        structure changes in gdb.
@
text
@d346 1
a346 1
			    Tcl_NewBooleanObj (b->enable_state == bp_enabled));
d459 1
a459 1
    disp = disp_del;
d461 1
a461 1
    disp = disp_donttouch;
d541 1
a541 1
    disp = disp_del;
d543 1
a543 1
    disp = disp_donttouch;
d820 1
a820 1
			    Tcl_NewIntObj (tp->enabled_p));
@


1.7
log
@	* library/session.tcl (session_save): Save breakpoints.
	(SESSION_serialize_bps): New proc.
	(SESSION_recreate_bps): New proc.
	(session_load): Recreate breakpoints.
	* library/util.tcl (bp_exists): Expect user specification in
	breakpoint info.
	* library/srctextwin.itb (SrcTextWin::showBPBalloon): Expect user
	specification in breakpoint info.
	* library/gdbevent.itb (BreakpointEvent::_init): Initialize
	_user_specification.
	(BreakpointEvent::get): Handle user_specification.
	* library/gdbevent.ith (BreakpointEvent): Added
	_user_specification field.
	* library/bpwin.itb (BpWin::bp_store): Expect user specification
	and use it when saving.
	(BpWin::bp_type): Expect user specification.
	* generic/gdbtk-bp.c (BREAKPOINT_IS_WATCHPOINT): New macro.
	(gdb_get_breakpoint_info): Added `user specification' to result.
@
text
@d126 3
a128 3
void gdbtk_create_tracepoint (struct tracepoint *);
void gdbtk_delete_tracepoint (struct tracepoint *);
void gdbtk_modify_tracepoint (struct tracepoint *);
d130 1
a130 1
static void tracepoint_notify (struct tracepoint *, const char *);
d945 1
a945 2
gdbtk_create_tracepoint (tp)
     struct tracepoint *tp;
d947 1
a947 1
  tracepoint_notify (tp, "create");
d951 1
a951 2
gdbtk_delete_tracepoint (tp)
     struct tracepoint *tp;
d953 1
a953 1
  tracepoint_notify (tp, "delete");
d957 1
a957 2
gdbtk_modify_tracepoint (tp)
     struct tracepoint *tp;
d959 1
a959 1
  tracepoint_notify (tp, "modify");
d963 2
a964 2
tracepoint_notify (tp, action)
     struct tracepoint *tp;
d971 1
a971 1
  xasprintf (&buf, "gdbtk_tcl_tracepoint %s %d", action, tp->number);
@


1.6
log
@	Some "-Wall" cleanups.

	* generic/gdbtk-hooks.c (x_event): Remove unused variable "count".
	(tracepoint_notify): Remove superfluous declaration. This funtion
	was moved to gdbtk-bp.c.

	* generic/gdbtk-bp.c (gdb_find_bp_at_addr): Remove unused variable
	"b".
	(gdb_set_bp): Remove unused variable "cmd".
	(gdb_set_bp_addr): Remove unused variables "cmd" and "filename".

	* generic/gdbtk.c (gdbtk_init): Remove unused variables
	"auto_path_name", "auto_path_elem", and "found_main".
@
text
@d65 7
d289 1
a289 1
 *                condition, thread, hit_count}
d365 5
@


1.5
log
@	* generic/gdbtk-bp.c (set_raw_breakpoint): Revise declaration
	to match the recently changed declaration in breakpoint.c.
	Update all callers.
@
text
@d27 1
a202 1
  struct breakpoint *b;
a421 1
  Tcl_DString cmd;
d507 1
a507 2
  char *filename, *typestr, *buf;
  Tcl_DString cmd;
@


1.4
log
@	* generic/gdbtk-bp.c (gdbtk_create_breakpoint): Safe guard
	against "invalid" (internal) breakpoint numbers.
	(gdbtk_modify_breakpoint): Ditto.
	(gdbtk_delete_breakpoint): Ditto.
@
text
@d69 2
a70 1
extern struct breakpoint *set_raw_breakpoint (struct symtab_and_line sal);
d472 1
a472 1
  b = set_raw_breakpoint (sal);
a474 1
  b->type = bp_breakpoint;
d552 1
a552 1
  b = set_raw_breakpoint (sal);
a554 1
  b->type = bp_breakpoint;
@


1.3
log
@	* generic/gdbtk-bp.c (gdb_set_bp): Generate a breakpoint event
	when we create a breakpoint. The hook is no longer used.
	(gdb_set_bp_addr): Ditto.
@
text
@d55 9
d587 1
a587 1
  if (b == NULL)
d607 3
a609 1
  if (breakpoint_list[num] != NULL)
d619 2
a620 1
  breakpoint_notify (num, "modify");
d637 1
d639 1
@


1.2
log
@	* generic/gdbtk-bp.c (breakpoint_list, breakpoint_list_size): New
	variables. Gdb is forcing us to maintain our own breakpoint
	database.
	(Gdbtk_Breakpoint_Init): Initialize our breakpoint database.
	(gdb_find_bp_at_addr): Use our breakpoint database.
	(gdb_find_bp_at_line): Ditto.
	(gdb_get_breakpoint_list): Ditto.
	(gdb_get_breakpoint_info): Remove deleted breakpoint hack.
	(gdbtk_create_breakpoint): Moved here from gdbtk-hooks.c.
	Add breakpoint to our breakpoint database.
	(gdbtk_modify_breakpoint): Ditto the move.
	(gdbtk_delete_breakpoint): Ditto the move.
	Remove breakpoint from our database.
	(gdb_get_tracepoint_info): Remove delete tracepoint hack.
	It's not needed for tracepoints: they were implemented properly.
	(gdbtk_create_tracepoint): Moved here from gdbtk-hooks.c.
	(gdbtk_modify_tracepoint): Ditto.
	(gdbtk_delete_tracepoint): Ditto.
	* generic/gdbtk-hooks.c: Include "gdb-events.h".
	(gdbtk_create_breakpoint): Moved to gdbtk-bp.c
	(gdbtk_modify_breakpoint): Ditto.
	(gdbtk_delete_breakpoint): Ditto.
	(breakpoint_notify): Ditto.
	(gdbtk_create_tracepoint): Ditto.
	(gdbtk_modify_tracepoint): Ditto.
	(gdbtk_delete_tracepoint): Ditto.
	(tracepoint_notify): Ditto.
	(report_error): No longer static.
	(gdbtk_add_hooks): Create our own event handler
	vector and register breakpoint_create, breakpoint_modify,
	and breakpoint_delete handlers in gdbtk-bp.c.
@
text
@d476 1
a476 1
  create_breakpoint_hook (b);
d554 1
a554 1
  create_breakpoint_hook (b);
@


1.1
log
@	* generic/gdbtk-cmds.c: Put on diet. All breakpoint-,
	tracepoint-, register-, and stack-related functions moved
	into separate files.
	(call_wrapper): Renamed to "gdbtk_call_wrapper" and export.
	Update all callers.
	* generic/gdbtk.h: Move all breakpoint-related stuff into
	gdbtk-bp.c.
	Remove declaration for "call_wrapper". Now in gdbtk-cmds.h
	(and called "gdbtk_call_wrapper").
	* generic/gdbtk-varobj.c: Include "gdbtk-cmds.h".
	* generic/gdbtk-cmds.h: New file.
	* generic/gdbtk-bp.c: New file.
	* generic/gdbtk-register.c: New file.
	* generic/gdbtk-stack.c: New file.
@
text
@d32 2
a33 2
/* Various globals we reference. */
extern void *gdbtk_deleted_bp;
d35 2
a36 1
static int tracepoint_exists (char *args);
d64 7
d101 12
d144 4
d190 1
a192 1
  extern struct breakpoint *breakpoint_chain;
d207 7
a213 4
  for (b = breakpoint_chain; b; b = b->next)
    if (b->address == (CORE_ADDR) addr)
      Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr,
				Tcl_NewIntObj (b->number));
d236 1
a236 2
  struct breakpoint *b;
  extern struct breakpoint *breakpoint_chain;
d255 4
a258 2
  for (b = breakpoint_chain; b; b = b->next)
    if (b->line_number == line && !strcmp (b->source_file, s->filename))
d260 1
a260 1
				Tcl_NewIntObj (b->number));
a281 1
  extern struct breakpoint *breakpoint_chain;
d298 1
a298 4
  for (b = breakpoint_chain; b; b = b->next)
    if (b->number == bpnum)
      break;

d301 5
a305 14
      /* Hack. Check if this BP is being deleted. See comments
	 around the definition of gdbtk_deleted_bp in
	 gdbtk-hooks.c. */
      struct breakpoint *dbp = (struct breakpoint *) gdbtk_deleted_bp;
      if (dbp && dbp->number == bpnum)
	b = dbp;
      else
	{
	  char *err_buf;
	  xasprintf (&err_buf, "Breakpoint #%d does not exist.", bpnum);
	  Tcl_SetStringObj (result_ptr->obj_ptr, err_buf, -1);
	  free(err_buf);
	  return TCL_ERROR;
	}
d368 1
a368 2
  struct breakpoint *b;
  extern struct breakpoint *breakpoint_chain;
d377 9
a385 6
  for (b = breakpoint_chain; b; b = b->next)
    if (b->type == bp_breakpoint)
      {
	new_obj = Tcl_NewIntObj (b->number);
	Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr, new_obj);
      }
d559 80
d768 5
a772 13
      /* Hack. Check if this TP is being deleted. See comments
	 around the definition of gdbtk_deleted_bp in
	 gdbtk-hooks.c. */
      struct tracepoint *dtp = (struct tracepoint *) gdbtk_deleted_bp;
      if (dtp != NULL && dtp->number == tpnum)
	tp = dtp;
      else {
	char *buff;
	xasprintf (&buff, "Tracepoint #%d does not exist", tpnum);
	Tcl_SetStringObj (result_ptr->obj_ptr, buff, -1);
	free(buff);
	return TCL_ERROR;
      }
d914 42
@

