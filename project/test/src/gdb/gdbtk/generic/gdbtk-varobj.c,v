head	1.26;
access;
symbols
	insight_7_6-2013-04-10-branchpoint:1.26
	gdb_7_6-branch:1.26.0.8
	gdb_7_5-branch:1.26.0.6
	gdb_7_4-branch:1.26.0.4
	gdb_7_3-branch:1.26.0.2
	gdb_7_1-branch:1.25.0.4
	gdb_7_0-branch:1.25.0.2
	arc-sim-20090309:1.21
	arc-insight_6_8-branch:1.21.0.6
	arc-insight_6_8-branchpoint:1.21
	insight_6_8-branch:1.21.0.4
	insight_6_8-branchpoint:1.21
	gdb_6_8-branch:1.21.0.2
	insight_6_6-20070208-release:1.19
	gdb_6_6-branch:1.19.0.4
	gdb_6_6-2006-11-15-branchpoint:1.19
	insight_6_5-20061003-release:1.19
	gdb_6_5-branch:1.19.0.2
	gdb_6_5-2006-05-14-branchpoint:1.19
	gdb-csl-gxxpro-6_3-branch:1.18.0.4
	gdb-csl-gxxpro-6_3-branchpoint:1.18
	gdb_6_4-branch:1.18.0.2
	gdb_6_4-2005-11-01-branchpoint:1.18
	gdb_6_1-2004-04-05-release:1.17
	gdb_6_1-branch:1.17.0.2
	gdb_6_1-2004-03-01-gmt-branchpoint:1.17
	gdb_6_0-2003-10-04-release:1.16
	gdb_6_0-branch:1.16.0.2
	gdb_6_0-2003-06-23-branchpoint:1.16
	gdb_5_3-2002-12-12-release:1.14
	gdb_5_3-branch:1.14.0.2
	gdb_5_3-2002-09-04-branchpoint:1.14
	gdb_5_2_1-2002-07-23-release:1.13
	gdb_5_2-2002-04-29-release:1.13
	gdb_5_2-branch:1.13.0.2
	gdb_5_2-2002-03-03-branchpoint:1.13
	gdb_5_1_1-2002-01-24-release:1.7
	cygnus_cvs_20020108_pre:1.10
	gdb_5_1_0_1-2002-01-03-branch:1.7.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.7
	gdb_5_1-2001-11-21-release:1.7
	gdb_s390-2001-09-26-branch:1.7.0.6
	gdb_s390-2001-09-26-branchpoint:1.7
	gdb_5_1-2001-07-29-branch:1.7.0.4
	gdb_5_1-2001-07-29-branchpoint:1.7
	dberlin-typesystem-branch:1.7.0.2
	dberlin-typesystem-branchpoint:1.7
	insight-precleanup-2001-01-01:1.5
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.2
	repo-unification-2000-02-06:1.1.1.1
	insight-2000-02-04:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.26
date	2010.04.29.21.00.52;	author kseitz;	state Exp;
branches;
next	1.25;

1.25
date	2009.09.17.07.00.48;	author muller;	state Exp;
branches;
next	1.24;

1.24
date	2009.09.16.09.46.58;	author muller;	state Exp;
branches;
next	1.23;

1.23
date	2009.04.06.23.11.10;	author muller;	state Exp;
branches;
next	1.22;

1.22
date	2008.07.14.23.43.36;	author kseitz;	state Exp;
branches;
next	1.21;

1.21
date	2008.02.05.14.07.06;	author macro;	state Exp;
branches;
next	1.20;

1.20
date	2007.04.27.15.39.50;	author macro;	state Exp;
branches;
next	1.19;

1.19
date	2005.12.23.18.23.16;	author eliz;	state Exp;
branches;
next	1.18;

1.18
date	2005.01.18.00.14.38;	author kseitz;	state Exp;
branches;
next	1.17;

1.17
date	2003.11.25.01.44.06;	author carlton;	state Exp;
branches;
next	1.16;

1.16
date	2003.02.11.16.08.38;	author cagney;	state Exp;
branches;
next	1.15;

1.15
date	2002.11.06.20.29.14;	author hunt;	state Exp;
branches;
next	1.14;

1.14
date	2002.08.03.16.22.07;	author cagney;	state Exp;
branches;
next	1.13;

1.13
date	2002.02.07.05.05.06;	author hunt;	state Exp;
branches;
next	1.12;

1.12
date	2002.01.15.19.41.07;	author kseitz;	state Exp;
branches;
next	1.11;

1.11
date	2002.01.15.19.21.34;	author kseitz;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.05.19.42.48;	author hunt;	state Exp;
branches;
next	1.9;

1.9
date	2001.10.17.20.35.32;	author cagney;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.17.19.10.36;	author kseitz;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.10.18.04.23;	author kseitz;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.29.22.17.45;	author fnasser;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.16.00.50.25;	author fnasser;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.02.20.07.07;	author kevinb;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.17.20.20.59;	author jlarmour;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.13.21.51.45;	author jingham;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.07.00.19.42;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.07.00.19.42;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.26
log
@  insight/347
  * generic/gdbtk-varobj.c (variable_value): Use TRY_CATCH
  when calling varobj_set_value.
  * library/vartree.itb (changeValue): Make note of new
  assumption that input is decimal (unless prefixed to change
  the input radix).
@
text
@/* Variable user interface layer for GDB, the GNU debugger.
   Copyright (C) 1999, 2000, 2001, 2002, 2008, 2010
   Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */

#include "defs.h"
#include "value.h"
#include "gdb_string.h"
#include "varobj.h"
#include "exceptions.h"

#include <tcl.h>
#include "gdbtk.h"
#include "gdbtk-cmds.h"
#include "gdbtk-wrapper.h"

/*
 * Public functions defined in this file
 */

int gdb_variable_init (Tcl_Interp *);

/*
 * Private functions defined in this file
 */

/* Entries into this file */

static int gdb_variable_command (ClientData, Tcl_Interp *, int,
				 Tcl_Obj * CONST[]);

static int variable_obj_command (ClientData, Tcl_Interp *, int,
				 Tcl_Obj * CONST[]);

/* Variable object subcommands */

static int variable_create (Tcl_Interp *, int, Tcl_Obj * CONST[]);

static void variable_delete (Tcl_Interp *, struct varobj *, int);

static Tcl_Obj *variable_children (Tcl_Interp *, struct varobj *);

static int variable_format (Tcl_Interp *, int, Tcl_Obj * CONST[],
			    struct varobj *);

static int variable_type (Tcl_Interp *, int, Tcl_Obj * CONST[],
			  struct varobj *);

static int variable_value (Tcl_Interp *, int, Tcl_Obj * CONST[],
			   struct varobj *);

static Tcl_Obj *variable_update (Tcl_Interp * interp, struct varobj **var);

/* Helper functions for the above subcommands. */

static void install_variable (Tcl_Interp *, char *);

static void uninstall_variable (Tcl_Interp *, char *);

/* String representations of gdb's format codes */
static char *format_string[] =
  {"natural", "binary", "decimal", "hexadecimal", "octal"};


/* Initialize the variable code. This function should be called once
   to install and initialize the variable code into the interpreter. */
int
gdb_variable_init (Tcl_Interp *interp)
{
  Tcl_Command result;
  static int initialized = 0;

  if (!initialized)
    {
      result = Tcl_CreateObjCommand (interp, "gdb_variable", gdbtk_call_wrapper,
				     (ClientData) gdb_variable_command, NULL);
      if (result == NULL)
	return TCL_ERROR;

      initialized = 1;
    }

  return TCL_OK;
}

/* This function defines the "gdb_variable" command which is used to
   create variable objects. Its syntax includes:

   gdb_variable create
   gdb_variable create NAME
   gdb_variable create -expr EXPR
   gdb_variable create -frame FRAME
   (it will also include permutations of the above options)

   NAME  = name of object to create. If no NAME, then automatically create
   a name
   EXPR  = the gdb expression for which to create a variable. This will
   be the most common usage.
   FRAME = the frame defining the scope of the variable.
*/
static int
gdb_variable_command (ClientData clientData, Tcl_Interp *interp,
		      int objc, Tcl_Obj *CONST objv[])
{
  static const char *commands[] =
    {"create", "list", NULL};
  enum commands_enum
    {
      VARIABLE_CREATE, VARIABLE_LIST
    };
  int index, result;

  if (objc < 2)
    {
      Tcl_WrongNumArgs (interp, 1, objv, "option ?arg...?");
      return TCL_ERROR;
    }

  if (Tcl_GetIndexFromObj (interp, objv[1], commands, "options", 0,
			   &index) != TCL_OK)
    {
      return TCL_ERROR;
    }

  switch ((enum commands_enum) index)
    {
    case VARIABLE_CREATE:
      result = variable_create (interp, objc - 2, objv + 2);
      break;

    default:
      return TCL_ERROR;
    }

  return result;
}

/* This function implements the actual object command for each
   variable object that is created (and each of its children).

   Currently the following commands are implemented:
   - delete        delete this object and its children
   - update        update the variable and its children (root vars only)
   - numChildren   how many children does this object have
   - children      create the children and return a list of their objects
   - name          print out the name of this variable
   - format        query/set the display format of this variable
   - type          get the type of this variable
   - value         get/set the value of this variable
   - editable      is this variable editable?
*/
static int
variable_obj_command (ClientData clientData, Tcl_Interp *interp,
		      int objc, Tcl_Obj *CONST objv[])
{
  enum commands_enum
    {
      VARIABLE_DELETE,
      VARIABLE_NUM_CHILDREN,
      VARIABLE_CHILDREN,
      VARIABLE_FORMAT,
      VARIABLE_TYPE,
      VARIABLE_VALUE,
      VARIABLE_NAME,
      VARIABLE_EDITABLE,
      VARIABLE_UPDATE
    };
  static const char *commands[] =
    {
      "delete",
      "numChildren",
      "children",
      "format",
      "type",
      "value",
      "name",
      "editable",
      "update",
      NULL
    };
  struct varobj *var;
  char *varobj_name;
  int index, result;
  
  /* Get the current handle for this variable token (name). */
  varobj_name = Tcl_GetStringFromObj (objv[0], NULL);
  if (varobj_name == NULL)
    return TCL_ERROR;
  var = varobj_get_handle (varobj_name);
  

  if (objc < 2)
    {
      Tcl_WrongNumArgs (interp, 1, objv, "option ?arg...?");
      return TCL_ERROR;
    }

  if (Tcl_GetIndexFromObj (interp, objv[1], commands, "options", 0,
			   &index) != TCL_OK)
    return TCL_ERROR;

  result = TCL_OK;
  switch ((enum commands_enum) index)
    {
    case VARIABLE_DELETE:
      if (objc > 2)
	{
	  int len;
	  char *s = Tcl_GetStringFromObj (objv[2], &len);
	  if (*s == 'c' && strncmp (s, "children", len) == 0)
	    {
	      variable_delete (interp, var, 1 /* only children */ );
	      break;
	    }
	}
      variable_delete (interp, var, 0 /* var and children */ );
      break;

    case VARIABLE_NUM_CHILDREN:
      Tcl_SetObjResult (interp, Tcl_NewIntObj (varobj_get_num_children (var)));
      break;

    case VARIABLE_CHILDREN:
      {
	Tcl_Obj *children = variable_children (interp, var);
	Tcl_SetObjResult (interp, children);
      }
      break;

    case VARIABLE_FORMAT:
      result = variable_format (interp, objc, objv, var);
      break;

    case VARIABLE_TYPE:
      result = variable_type (interp, objc, objv, var);
      break;

    case VARIABLE_VALUE:
      result = variable_value (interp, objc, objv, var);
      break;

    case VARIABLE_NAME:
      {
	char *name = varobj_get_expression (var);
	Tcl_SetObjResult (interp, Tcl_NewStringObj (name, -1));
	xfree (name);
      }
      break;

    case VARIABLE_EDITABLE:
      Tcl_SetObjResult (interp, 
			Tcl_NewIntObj (varobj_get_attributes (var) & 0x00000001 /* Editable? */ ));
      break;

    case VARIABLE_UPDATE:
      /* Only root variables can be updated */
      {
	Tcl_Obj *obj = variable_update (interp, &var);
	Tcl_SetObjResult (interp, obj);
      }
      break;

    default:
      return TCL_ERROR;
    }

  return result;
}

/*
 * Variable object construction/destruction
 */

/* This function is responsible for processing the user's specifications
   and constructing a variable object. */
static int
variable_create (Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
{
  enum create_opts
    {
      CREATE_EXPR, CREATE_FRAME
    };
  static const char *create_options[] =
    {"-expr", "-frame", NULL};
  struct varobj *var;
  char *name;
  char *obj_name;
  int index;
  CORE_ADDR frame = (CORE_ADDR) -1;
  int how_specified = USE_SELECTED_FRAME;

  /* REMINDER: This command may be invoked in the following ways:
     gdb_variable create [NAME] [-expr EXPR] [-frame FRAME]

     NAME  = name of object to create. If no NAME, then automatically create
     a name
     EXPR  = the gdb expression for which to create a variable. This will
     be the most common usage.
     FRAME = the address of the frame defining the variable's scope
  */
  name = NULL;
  if (objc)
    name = Tcl_GetStringFromObj (objv[0], NULL);
  if (name == NULL || *name == '-')
    {
      /* generate a name for this object */
      obj_name = varobj_gen_name ();
    }
  else
    {
      /* specified name for object */
      obj_name = xstrdup (name);
      objv++;
      objc--;
    }

  /* Run through all the possible options for this command */
  name = NULL;
  while (objc > 0)
    {
      if (Tcl_GetIndexFromObj (interp, objv[0], create_options, "options",
			       0, &index) != TCL_OK)
	{
	  xfree (obj_name);
	  result_ptr->flags |= GDBTK_IN_TCL_RESULT;
	  return TCL_ERROR;
	}

      switch ((enum create_opts) index)
	{
	case CREATE_EXPR:
	  name = Tcl_GetStringFromObj (objv[1], NULL);
	  objc--;
	  objv++;
	  break;

	case CREATE_FRAME:
	  {
	    char *str;
	    str = Tcl_GetStringFromObj (objv[1], NULL);
	    frame = string_to_core_addr (str);
	    how_specified = USE_SPECIFIED_FRAME;
	    objc--;
	    objv++;
	  }
	  break;

	default:
	  break;
	}

      objc--;
      objv++;
    }

  /* Create the variable */
  var = varobj_create (obj_name, name, frame, how_specified);

  if (var != NULL)
    {
      /* Install a command into the interpreter that represents this
         object */
      install_variable (interp, obj_name);
      Tcl_SetObjResult (interp, Tcl_NewStringObj (obj_name, -1));
      result_ptr->flags |= GDBTK_IN_TCL_RESULT;

      xfree (obj_name);
      return TCL_OK;
    }

  xfree (obj_name);
  return TCL_ERROR;
}

/* Delete the variable object VAR and its children */
/* If only_children_p, Delete only the children associated with the object. */
static void
variable_delete (Tcl_Interp *interp, struct varobj *var,
		 int only_children_p)
{
  char **dellist;
  char **vc;

  varobj_delete (var, &dellist, only_children_p);

  vc = dellist;
  while (*vc != NULL)
    {
      uninstall_variable (interp, *vc);
      xfree (*vc);
      vc++;
    }

  xfree (dellist);
}

/* Return a list of all the children of VAR, creating them if necessary. */
static Tcl_Obj *
variable_children (Tcl_Interp *interp, struct varobj *var)
{
  Tcl_Obj *list;
  VEC(varobj_p) *children;
  struct varobj *child;
  char *childname;
  int ix, from, to;

  list = Tcl_NewListObj (0, NULL);

  from = -1;
  to = -1;

  children = varobj_list_children (var, &from, &to);

  for (ix = from; ix < to && VEC_iterate (varobj_p, children, ix, child); ++ix)
    {
      childname = varobj_get_objname (child);
      /* Add child to result list and install the Tcl command for it. */
      Tcl_ListObjAppendElement (NULL, list,
				Tcl_NewStringObj (childname, -1));
      install_variable (interp, childname);
    }

  return list;
}

/* Update the values for a variable and its children. */
/* NOTE:   Only root variables can be updated... */

static Tcl_Obj *
variable_update (Tcl_Interp *interp, struct varobj **var)
{
  int i;
  Tcl_Obj *changed;
  VEC (varobj_update_result) *changes;
  varobj_update_result *r;

  if (GDB_varobj_update (var, 1, &changes) != GDB_OK)
    return Tcl_NewStringObj ("-1", -1);

  changed = Tcl_NewListObj (0, NULL);
  for (i = 0; VEC_iterate (varobj_update_result, changes, i, r); ++i)
    {
      switch (r->status)
	{
	case VAROBJ_IN_SCOPE:
	  {
	    Tcl_Obj *var
	      =  Tcl_NewStringObj (varobj_get_objname (r->varobj), -1);
	    Tcl_ListObjAppendElement (NULL, changed, var);
	  }
	  break;

	case VAROBJ_NOT_IN_SCOPE:
	case VAROBJ_INVALID:
	  /* These need to be (re-)implemented in the UI */
	  break;
	}
    }

  return changed;
}

/* This implements the format object command allowing
   the querying or setting of the object's display format. */
static int
variable_format (Tcl_Interp *interp, int objc, 
		 Tcl_Obj *CONST objv[], struct varobj *var)
{
  if (objc > 2)
    {
      /* Set the format of VAR to given format */
      int len;
      char *fmt = Tcl_GetStringFromObj (objv[2], &len);
      if (strncmp (fmt, "natural", len) == 0)
	varobj_set_display_format (var, FORMAT_NATURAL);
      else if (strncmp (fmt, "binary", len) == 0)
	varobj_set_display_format (var, FORMAT_BINARY);
      else if (strncmp (fmt, "decimal", len) == 0)
	varobj_set_display_format (var, FORMAT_DECIMAL);
      else if (strncmp (fmt, "hexadecimal", len) == 0)
	varobj_set_display_format (var, FORMAT_HEXADECIMAL);
      else if (strncmp (fmt, "octal", len) == 0)
	varobj_set_display_format (var, FORMAT_OCTAL);
      else
	{
	  gdbtk_set_result (interp, "unknown display format \"",
			    fmt, "\": must be: \"natural\", \"binary\""
			    ", \"decimal\", \"hexadecimal\", or \"octal\"");
	  return TCL_ERROR;
	}
    }
  else
    {
      /* Report the current format */
      Tcl_Obj *fmt;

      /* FIXME: Use varobj_format_string[] instead */
      fmt = Tcl_NewStringObj (
			      format_string[(int) varobj_get_display_format (var)], -1);
      Tcl_SetObjResult (interp, fmt);
    }

  return TCL_OK;
}

/* This function implements the type object command, which returns the type of a
   variable in the interpreter (or an error). */
static int
variable_type (Tcl_Interp *interp, int objc,
	       Tcl_Obj *CONST objv[], struct varobj *var)
{
  const char *first;
  const char *last;
  char *string;
  Tcl_RegExp regexp;

  /* For the "fake" variables, do not return a type.
     Their type is NULL anyway */
  /* FIXME: varobj_get_type() calls type_print(), so we may have to wrap
     its call here and return TCL_ERROR in the case it errors out */
  if ((string = varobj_get_type (var)) == NULL)
    {
      Tcl_ResetResult (interp);
      return TCL_OK;
    }

  first = string;

  /* gdb will print things out like "struct {...}" for anonymous structs.
     In gui-land, we don't want the {...}, so we strip it here. */
  regexp = Tcl_RegExpCompile (interp, "{...}");
  if (Tcl_RegExpExec (interp, regexp, string, first))
    {
      /* We have an anonymous struct/union/class/enum */
      Tcl_RegExpRange (regexp, 0, &first, &last);
      if (*(first - 1) == ' ')
	first--;
      string[first - string] = '\0';
    }

  Tcl_SetObjResult (interp, Tcl_NewStringObj (string, -1));
  xfree (string);
  return TCL_OK;
}

/* This function implements the value object command, which allows an object's
   value to be queried or set. */
static int
variable_value (Tcl_Interp *interp, int objc,
		Tcl_Obj *CONST objv[], struct varobj *var)
{
  char *r;

  /* If we're setting the value of the variable, objv[2] will contain the
     variable's new value. */
  if (objc > 2)
    {
      /* FIXME: Do we need to test if val->error is set here?
         If so, make it an attribute. */
      if (varobj_get_attributes (var) & 0x00000001 /* Editable? */ )
	{
	  char *s;
	  int ok = 0;
	  struct gdb_exception e;

	  s = Tcl_GetStringFromObj (objv[2], NULL);
	  TRY_CATCH (e, RETURN_MASK_ERROR)
	    {
	      ok = varobj_set_value (var, s);
	    }

	  if (e.reason < 0 || !ok)
            {
	      gdbtk_set_result (interp, "Could not assign expression to variable object");
	      return TCL_ERROR;
            }
	}

      Tcl_ResetResult (interp);
      return TCL_OK;
    }

  r = varobj_get_value (var);

  if (r == NULL)
    {
      gdbtk_set_result (interp, "Could not read variable object value after assignment");
      return TCL_ERROR;
    }
  else
    {
      Tcl_SetObjResult (interp, Tcl_NewStringObj (r, -1));
      xfree (r);
      return TCL_OK;
    }
}

/* Helper functions for the above */

/* Install the given variable VAR into the tcl interpreter with
   the object name NAME. */
static void
install_variable (Tcl_Interp *interp, char *name)
{
  Tcl_CreateObjCommand (interp, name, variable_obj_command,
			NULL, NULL);
}

/* Unistall the object VAR in the tcl interpreter. */
static void
uninstall_variable (Tcl_Interp *interp, char *varname)
{
  Tcl_DeleteCommand (interp, varname);
}

@


1.25
log
@	* generic/gdbtk-varobj.c (variable_children): Initialize new locals
	used in varobj_list_children function call.
@
text
@d2 2
a3 1
   Copyright (C) 1999, 2000, 2001, 2002, 2008 Free Software Foundation, Inc.
d26 1
d579 2
d583 6
a588 1
	  if (!varobj_set_value (var, s))
@


1.24
log
@	* generic/gdbtk-varobj.c (variable_children): Adapt to
	varobj_list_children function change.
@
text
@d423 3
@


1.23
log
@	ARI fixes: xvasprintf and strdup rules.
	* generic/gdbtk-cmds.c (gdbtk_set_result): Replace xvasprintf by
	xstrvprintf.
	* generic/gdbtk-hooks.c (gdbtk_warning): Ditto.
	(gdbtk_readline_begin, gdbtk_query): Ditto.
	* generic/gdbtk.c (TclDebug): Ditto.
	* generic/gdbtk-varobj.c (variable_create): Replace strdup by xstrdup.
@
text
@d419 1
a419 1
  int ix;
d423 1
a423 1
  children = varobj_list_children (var);
d425 1
a425 1
  for (ix = 0; VEC_iterate (varobj_p, children, ix, child); ++ix)
@


1.22
log
@        * generic/gdbtk-stack.c (gdb_block_args): Remove deprecated values
        LOC_LOCAL_ARG, LOC_COMPUTED_ARG, LOC_REGPARM, LOC_BASEARG_ARG, and
        LOC_BASEARG.
        (gdb_get_blocks): Likewise.
        (gdb_get_vars_command): Likewise.
        Fix type-punned pointer error introduced on 03-07.

        * generic/gdbtk-cmds.c (gdbtk_load_asm): Use paddress instead
        of deprecated_print_address_numeric.
        (gdb_stop): Update use of target_stop.

        * generic/gdbtk.h (gdbtk_get_ptid): Declare new function.
        * generic/gdbtk-hooks.c (gdbtk_wait): Save inferior's ptid.
        (gdbtk_get_ptid): Define new function.
        * generic/gdbtk-varobj.c (variable_update): Update for recent
        varobj_update API change.
        * generic/gdbtk-wrapper.h (GDB_varobj_update): Likewise.
        * generic/gdbtk-wrapper.c (GDB_varobj_update): Likewise.
        (wrap_varobj_update): Likewise.

        * library/targetselection.itb (init_target_db): Initialize
        preferences here instead of ...
        (_init): ... here.
        (_init_prefs): Define gdb/load/default-portname, too.
@
text
@d326 1
a326 1
      obj_name = strdup (name);
@


1.21
log
@* generic/gdbtk-varobj.c (variable_children): Adjust
for varobj_list_children change.
@
text
@d443 1
d445 4
a448 8
  struct varobj **changelist;
  struct varobj **vc;
  int result;

  /* varobj_update() throws an error for a non-root variable
     and otherwise it returns a value < 0 if the variable is
     not in scope, not valid anymore or has changed type.  */
  if (GDB_varobj_update (var, &changelist, 1, &result) != GDB_OK || result < 0)
d451 2
a452 3
  changed = Tcl_NewListObj (0, NULL);  
  vc = changelist;
  while (*vc != NULL)
d454 15
a468 4
      /* Add changed variable object to result list */
      Tcl_ListObjAppendElement (NULL, changed,
				Tcl_NewStringObj (varobj_get_objname (*vc), -1));
      vc++;
a470 1
  xfree (changelist);
@


1.20
log
@gdb/:
* Makefile.in (gdbtk-wrapper.o): Update dependencies.
(gdbtk-varobj.o, gdbtk-cmds.o, gdbtk-stack.o): Likewise.

gdb/gdbtk/:
* generic/gdbtk-wrapper.c (GDB_varobj_update): New function.
(wrap_varobj_update): Likewise.
* generic/gdbtk-wrapper.h (GDB_varobj_update): New declaration.
* generic/gdbtk-varobj.c (variable_update): Call
GDB_varobj_update() rather than varobj_update() directly.  Take
the new semantics of the latter into account.
* generic/gdbtk-cmds.c: Include "varobj.h".
* generic/gdbtk-stack.c: Likewise.
@
text
@d2 1
a2 1
   Copyright (C) 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
d416 2
a417 2
  struct varobj **childlist;
  struct varobj **vc;
d419 1
d423 1
a423 1
  varobj_list_children (var, &childlist);
d425 1
a425 2
  vc = childlist;
  while (*vc != NULL)
d427 1
a427 1
      childname = varobj_get_objname (*vc);
a431 1
      vc++;
a433 1
  xfree (childlist);
@


1.19
log
@	* generic/gdbtk.h:
	* generic/gdbtk.c:
	* generic/gdbtk-wrapper.h:
	* generic/gdbtk-wrapper.c:
	* generic/gdbtk-varobj.c:
	* generic/gdbtk-stack.c:
	* generic/gdbtk-register.c:
	* generic/gdbtk-main.c:
	* generic/gdbtk-interp.c:
	* generic/gdbtk-hooks.c:
	* generic/gdbtk-cmds.h:
	* generic/gdbtk-cmds.c:
	* generic/gdbtk-bp.c: Put (C) after Copyright.  Update the FSF
	address.
@
text
@d29 1
d448 1
d450 4
a453 3
  /* varobj_update() can return -1 if the variable is no longer around,
     i.e. we stepped out of the frame in which a local existed. */
  if (varobj_update (var, &changelist) == -1)
@


1.18
log
@        * generic/gdbtk-varobj.c (variable_value): Remove all instances
        of error_last_message. It's gone.

        * generic/gdbtk-wrapper.c: Include exceptions.h
        * generic/gdbtk-cmds.c: Likewise.
        * generic/gdbtk-interp.c: Likewise.
        (gdbtk_interpreter_exec): Change return type to struct
        exception. Return exception_none.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
d18 2
a19 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.17
log
@2003-11-24  David Carlton  <carlton@@kealia.com>

	* generic/gdbtk.c (target_is_native): Replace STREQ by strcmp.
	* generic/gdbtk-cmds.c (gdb_stop): Replace STREQ by strcmp.
	(gdb_search): Replace STREQN by strncmp and DEPRECATED_SYMBOL_NAME
	by SYMBOL_LINKAGE_NAME.
	* generic/gdbtk-varobj.c (variable_format): Replace STREQN by
	strncmp.
@
text
@d570 1
a570 3
	      r = error_last_message();
	      gdbtk_set_result (interp, "%s", r);
	      xfree (r);
d583 1
a583 3
      char *err = error_last_message ();
      gdbtk_set_result (interp, "%s", err);
      xfree (err);
@


1.16
log
@2003-02-10  Andrew Cagney  <ac131313@@redhat.com>

	* generic/gdbtk-varobj.c (gdb_variable_command): Ditto for
	`commands'.
	(variable_type): Ditto for `first'.
	(variable_obj_command): Ditto.
	(variable_create): Ditto for create_options.
	(variable_type): Ditto for `last'.  Use `string' and not `first'
	when modifying the buffer.
	(struct disassembly_client_data ): Ditto for `asm_argv'
	* generic/gdbtk-register.c (gdb_register_info): Ditto for
	`commands'.
	* generic/gdbtk-hooks.c (tk_command_loop): Ditto for `msg'.
	* generic/gdbtk-cmds.c (gdb_search): Ditto for `switches'.
	(gdbtk_load_source): Ditto for `text_argv'.
	(struct disassembly_client_data ): Ditto for `source_argv'.
	(gdbtk_load_asm): Ditto for `text_argv'.
	(struct disassembly_client_data ): Ditto for `asm_argv'
	(gdb_loadfile): Ditto for `text_argv'.
	* generic/gdbtk.c (TclDebug): Make `v' a constant pointer.
	(gdbtk_init): Ditto for `old_chain', `src_path', `msg', and
	`lib_path'.
@
text
@d477 1
a477 1
      if (STREQN (fmt, "natural", len))
d479 1
a479 1
      else if (STREQN (fmt, "binary", len))
d481 1
a481 1
      else if (STREQN (fmt, "decimal", len))
d483 1
a483 1
      else if (STREQN (fmt, "hexadecimal", len))
d485 1
a485 1
      else if (STREQN (fmt, "octal", len))
@


1.15
log
@2002-11-06  Martin M. Hunt  <hunt@@redhat.com>

	* generic/gdbtk-varobj.c: Remove FREEIF and replace with xfree.
	Make format_string static.

	(variable_update): Return an object
	with "-1" in it on error.
@
text
@d117 1
a117 1
  static char *commands[] =
d180 1
a180 1
  static char *commands[] =
d295 1
a295 1
  static char *create_options[] =
d515 3
a517 1
  char *first, *last, *string;
d541 1
a541 1
      *first = '\0';
@


1.14
log
@Index: ChangeLog
2002-08-03  Andrew Cagney  <ac131313@@redhat.com>

* Makefile.in (gdbtk-bp.o): Update dependencies.
(gdbtk-register.o): Ditto.
(gdbtk-varobj.o): Ditto.

Index: gdbtk/ChangeLog
2002-08-03  Andrew Cagney  <ac131313@@redhat.com>

* generic/gdbtk-bp.c: Include "gdb_string.h".
* generic/gdbtk-register.c: Ditto.
* generic/gdbtk-varobj.c: Ditto.
@
text
@d73 1
a73 1
char *format_string[] =
a75 4
#if defined(FREEIF)
#undef FREEIF
#endif
#define FREEIF(x) if (x != NULL) free((char *) (x))
d258 1
a258 1
	FREEIF (name);
d263 2
a264 2
      Tcl_SetObjResult (interp, Tcl_NewIntObj (
					       varobj_get_attributes (var) & 0x00000001 /* Editable? */ ));
d336 1
a336 1
	  free (obj_name);
d379 1
a379 1
      free (obj_name);
d383 1
a383 1
  free (obj_name);
d402 1
a402 1
      free (*vc);
d406 1
a406 1
  FREEIF (dellist);
d433 1
a433 1
  FREEIF (childlist);
a446 2
  changed = Tcl_NewListObj (0, NULL);

d450 1
a450 1
    return changed;
d452 1
d462 1
a462 1
  FREEIF (changelist);
d543 1
a543 1
  FREEIF (string);
d591 1
a591 1
      FREEIF (r);
@


1.13
log
@2002-02-06  Martin M. Hunt  <hunt@@redhat.com>

	* generic/gdbtk.c, generic/gdbtk-bp.c, generic/gdbtk-cmds.c,
	generic/gdbtk-hooks.c, generic/gdbtk-register.c,
	generic/gdbtk-stack.c, generic/gdbtk-varobj.c,
	generic/gdbtk-wrapper.c: Cleanup. Fix indentation. Fix
	function declarations. Remove unused variables. Add 2002
	copyrights.
@
text
@d22 1
a22 1

@


1.12
log
@Update copyright (dates verified against cvs)
@
text
@d74 1
a74 1
{"natural", "binary", "decimal", "hexadecimal", "octal"};
d84 1
a84 2
gdb_variable_init (interp)
     Tcl_Interp *interp;
d92 1
a92 1
				   (ClientData) gdb_variable_command, NULL);
d116 1
a116 1
 */
d118 2
a119 5
gdb_variable_command (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
d122 1
a122 1
  {"create", "list", NULL};
d167 1
a167 1
 */
d169 2
a170 5
variable_obj_command (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
d185 12
a196 12
  {
    "delete",
    "numChildren",
    "children",
    "format",
    "type",
    "value",
    "name",
    "editable",
    "update",
    NULL
  };
d268 1
a268 1
		varobj_get_attributes (var) & 0x00000001 /* Editable? */ ));
d293 1
a293 4
variable_create (interp, objc, objv)
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
d300 1
a300 1
  {"-expr", "-frame", NULL};
d316 1
a316 1
   */
d394 2
a395 4
variable_delete (interp, var, only_children_p)
     Tcl_Interp *interp;
     struct varobj *var;
     int only_children_p;
d415 1
a415 3
variable_children (interp, var)
     Tcl_Interp *interp;
     struct varobj *var;
d445 1
a445 3
variable_update (interp, var)
     Tcl_Interp *interp;
     struct varobj **var;
d463 1
a463 1
			   Tcl_NewStringObj (varobj_get_objname (*vc), -1));
d474 2
a475 5
variable_format (interp, objc, objv, var)
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
     struct varobj *var;
d495 2
a496 2
		      fmt, "\": must be: \"natural\", \"binary\""
		      ", \"decimal\", \"hexadecimal\", or \"octal\"");
d507 1
a507 1
		  format_string[(int) varobj_get_display_format (var)], -1);
d517 2
a518 5
variable_type (interp, objc, objv, var)
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
     struct varobj *var;
d555 2
a556 5
variable_value (interp, objc, objv, var)
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
     struct varobj *var;
d606 1
a606 3
install_variable (interp, name)
     Tcl_Interp *interp;
     char *name;
d614 1
a614 3
uninstall_variable (interp, varname)
     Tcl_Interp *interp;
     char *varname;
@


1.11
log
@	* generic/gdbtk-varobj.c (variable_value): When varobj_get_value
	fails, use error_last_message to return the error to tcl land.
	This allows us to display nice messages about why "0xdeadbeef" is
	not accessible!
@
text
@d2 1
a2 1
   Copyright 1999 Free Software Foundation, Inc.
@


1.10
log
@2001-11-05  Martin M. Hunt  <hunt@@redhat.com>
	* generic/gdbtk-cmds.h (gdbtk_set_result): Declare.
	A printf-like function to return error messages.
	* generic/gdbtk-cmds.c (gdbtk_set_result): New
	function.
	(gdb_cmd): Use gdbtk_set_result.
	(gdb_immediate_command): Ditto.
	(gdb_load_info): Ditto.
	(gdb_find_file_command): Ditto.
	(gdb_listfuncs): Ditto.
	(gdb_load_disassembly): Ditto.
	(gdb_loc): Ditto.
	(gdb_set_mem): Ditto.
	(gdb_get_mem): Ditto.
	(gdb_loadfile): Ditto.
	* generic/gdbtk-varobj.c (variable_format): Ditto.
	(variable_value): Ditto.
	* generic/gdbtk-stack.c (gdb_get_vars_command): Ditto.
	* generic/gdbtk-bp.c (gdb_get_breakpoint_info): Ditto.
	(gdb_set_bp): Ditto.
	(gdb_set_bp_addr): Ditto.
	(gdb_get_tracepoint_info): Ditto.
@
text
@d612 6
a617 1
    return TCL_ERROR;
@


1.9
log
@Functions to convert to/from CORE_ADDR and a string.  Use in Insight.
@
text
@d513 3
a515 5
	  Tcl_Obj *obj = Tcl_NewStringObj (NULL, 0);
	  Tcl_AppendStringsToObj (obj, "unknown display format \"",
				  fmt, "\": must be: \"natural\", \"binary\""
		      ", \"decimal\", \"hexadecimal\", or \"octal\"", NULL);
	  Tcl_SetObjResult (interp, obj);
d598 3
a600 3
              r = error_last_message ();
              Tcl_SetObjResult (interp, Tcl_NewStringObj (r, -1));
              FREEIF (r);
@


1.8
log
@	* generic/gdbtk-varobj.c (variable_obj_command): Pass pointer
	to varobj* when calling variable_update (API changed).
	(variable_create): Don't pass varobj* to install_variable. It's
	not used.
	(variable_children): Likewise.
	(variable_update): Change parameters to accept pointer to
	varobj*. Matches API change in varobj_update.
	(install_variable): Remove unused "var" parameter.
@
text
@d367 1
a367 1
	    frame = parse_and_eval_address (str);
@


1.7
log
@	* generic/gdbtk-cmds.c: Put on diet. All breakpoint-,
	tracepoint-, register-, and stack-related functions moved
	into separate files.
	(call_wrapper): Renamed to "gdbtk_call_wrapper" and export.
	Update all callers.
	* generic/gdbtk.h: Move all breakpoint-related stuff into
	gdbtk-bp.c.
	Remove declaration for "call_wrapper". Now in gdbtk-cmds.h
	(and called "gdbtk_call_wrapper").
	* generic/gdbtk-varobj.c: Include "gdbtk-cmds.h".
	* generic/gdbtk-cmds.h: New file.
	* generic/gdbtk-bp.c: New file.
	* generic/gdbtk-register.c: New file.
	* generic/gdbtk-stack.c: New file.
@
text
@d64 1
a64 1
static Tcl_Obj *variable_update (Tcl_Interp * interp, struct varobj *var);
d68 1
a68 1
static void install_variable (Tcl_Interp *, char *, struct varobj *);
d281 1
a281 1
	Tcl_Obj *obj = variable_update (interp, var);
d389 1
a389 1
      install_variable (interp, obj_name, var);
d447 1
a447 1
      install_variable (interp, childname, *vc);
d461 1
a461 1
     struct varobj *var;
d628 1
a628 1
install_variable (interp, name, var)
a630 1
     struct varobj *var;
d633 1
a633 1
			(ClientData) var, NULL);
@


1.6
log
@2001-03-29  Fernando Nasser  <fnasser@@redhat.com>

	* gdbtk-varobj.c (variable_obj_command): Do not cache varobj handles as
	they may change -- use varobj_get_handle() instead.
@
text
@d27 1
a27 1

d92 1
a92 1
      result = Tcl_CreateObjCommand (interp, "gdb_variable", call_wrapper,
@


1.5
log
@2000-09-15  Fernando Nasser  <fnasser@@totem.to.cygnus.com>

	* gdbtk-varobj.c (variable_value): Send back the error text issued
	by gdb so it can be displayed in a pop-up box.
@
text
@d204 2
a205 1
  struct varobj *var = (struct varobj *) clientData;
d207 7
@


1.4
log
@PARAMS elimination.
@
text
@d591 6
a596 1
	    return TCL_ERROR;
@


1.3
log
@        * ChangeLog-gdbtk: Renamed to ChangeLog
        * ChangeLog: New file
        * gdbtk-cmds.c, gdbtk-hooks.c, gdbtk-variable.c, gdbtk-varobj.c,
        gdbtk-wrapper.h, gdbtk-wrapper.c, gdbtk.h, gdbtk.c: No need for
        changelog-default-name hint for Emacs now
@
text
@d33 1
a33 1
int gdb_variable_init PARAMS ((Tcl_Interp *));
d41 2
a42 2
static int gdb_variable_command PARAMS ((ClientData, Tcl_Interp *, int,
					 Tcl_Obj * CONST[]));
d44 2
a45 2
static int variable_obj_command PARAMS ((ClientData, Tcl_Interp *, int,
					 Tcl_Obj * CONST[]));
d49 1
a49 1
static int variable_create PARAMS ((Tcl_Interp *, int, Tcl_Obj * CONST[]));
d51 1
a51 1
static void variable_delete PARAMS ((Tcl_Interp *, struct varobj *, int));
d53 1
a53 1
static Tcl_Obj *variable_children PARAMS ((Tcl_Interp *, struct varobj *));
d55 2
a56 2
static int variable_format PARAMS ((Tcl_Interp *, int, Tcl_Obj * CONST[],
				    struct varobj *));
d58 2
a59 2
static int variable_type PARAMS ((Tcl_Interp *, int, Tcl_Obj * CONST[],
				  struct varobj *));
d61 2
a62 2
static int variable_value PARAMS ((Tcl_Interp *, int, Tcl_Obj * CONST[],
				   struct varobj *));
d64 1
a64 1
static Tcl_Obj *variable_update PARAMS ((Tcl_Interp * interp, struct varobj * var));
d68 1
a68 1
static void install_variable PARAMS ((Tcl_Interp *, char *, struct varobj *));
d70 1
a70 1
static void uninstall_variable PARAMS ((Tcl_Interp *, char *));
@


1.2
log
@2000-03-13  James Ingham  <jingham@@leda.cygnus.com>

	Add support for a variable object that tries to evaluate itself in
	the currently selected frame, rather than in a fixed frame.

	* wrapper.c,h (gdb_parse_exp_1): Added a wrapper for
 	gdb_parse_exp_1.
	* varobj.h: Added USE_CURRENT_FRAME to varobj_type & changed def'n
	of varobj_create.
	* varobj.c (varobj_list): Return type indicates whether the
	variable's type has changed (for current frame variables).
	(varobj_update): Handle the case where the variable's type has
	changed.
	(delete_variable_1): Allow for deletion of variables that have not
	been installed yet.
	(new_root_variable): Initialize use_selected_frame variable.
	(value_of_root): This is where most of the work to handle "current
	frame" variables was added.  Most of the complexity involves
	handling the case where the type of the variable has changed.
	(varobj_create): Add a "type" argument, to tell if the
	variable is one of these "current frame" variables.  Also protect
	call to parse_exp_1 from long jumping.

	* mi-var-block.exp: The error report from varobj_create changed
	since I am now trapping parse_exp_1 errors.  Change the tests to
	match the new error message.
	* mi-var-child.exp: Ditto.
	* mi-var-cmd.exp: Ditto.

	* lib/gdb.exp: Fix the gdbtk_start routine to correctly find all
	the library directories.

	* gdbtk-varobj.c (variable_create): Pass the correct
	"how_specified" flag to the varobj_create routine.
@
text
@d632 1
a632 4

/* Local variables: */
/* change-log-default-name: "ChangeLog-gdbtk" */
/* End: */
@


1.1
log
@Initial revision
@
text
@d308 1
d360 1
d375 1
a375 1
  var = varobj_create (obj_name, name, frame);
@


1.1.1.1
log
@import insight-2000-02-04 snapshot (2nd try)
@
text
@@
