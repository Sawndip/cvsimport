head	1.42;
access;
symbols
	insight_7_6-2013-04-10-branchpoint:1.41
	gdb_7_6-branch:1.41.0.4
	gdb_7_5-branch:1.41.0.2
	gdb_7_4-branch:1.38.0.2
	gdb_7_3-branch:1.36.0.2
	gdb_7_1-branch:1.34.0.4
	gdb_7_0-branch:1.34.0.2
	arc-sim-20090309:1.27
	arc-insight_6_8-branch:1.27.0.6
	arc-insight_6_8-branchpoint:1.27
	insight_6_8-branch:1.27.0.4
	insight_6_8-branchpoint:1.27
	gdb_6_8-branch:1.27.0.2
	insight_6_6-20070208-release:1.22
	gdb_6_6-branch:1.22.0.4
	gdb_6_6-2006-11-15-branchpoint:1.22
	insight_6_5-20061003-release:1.22
	gdb_6_5-branch:1.22.0.2
	gdb_6_5-2006-05-14-branchpoint:1.22
	gdb-csl-gxxpro-6_3-branch:1.21.0.4
	gdb-csl-gxxpro-6_3-branchpoint:1.21
	gdb_6_4-branch:1.21.0.2
	gdb_6_4-2005-11-01-branchpoint:1.21
	gdb_6_1-2004-04-05-release:1.20
	gdb_6_1-branch:1.20.0.2
	gdb_6_1-2004-03-01-gmt-branchpoint:1.20
	gdb_6_0-2003-10-04-release:1.19
	gdb_6_0-branch:1.19.0.2
	gdb_6_0-2003-06-23-branchpoint:1.19
	gdb_5_3-2002-12-12-release:1.9
	gdb_5_3-branch:1.9.0.2
	gdb_5_3-2002-09-04-branchpoint:1.9
	gdb_5_2_1-2002-07-23-release:1.7
	gdb_5_2-2002-04-29-release:1.7
	gdb_5_2-branch:1.7.0.2
	gdb_5_2-2002-03-03-branchpoint:1.7
	gdb_5_1_1-2002-01-24-release:1.2
	cygnus_cvs_20020108_pre:1.5
	gdb_5_1_0_1-2002-01-03-branch:1.2.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.2
	gdb_5_1-2001-11-21-release:1.2
	gdb_s390-2001-09-26-branch:1.2.0.6
	gdb_s390-2001-09-26-branchpoint:1.2
	gdb_5_1-2001-07-29-branch:1.2.0.4
	gdb_5_1-2001-07-29-branchpoint:1.2
	dberlin-typesystem-branch:1.2.0.2
	dberlin-typesystem-branchpoint:1.2;
locks; strict;
comment	@ * @;


1.42
date	2013.06.05.20.29.37;	author kseitz;	state Exp;
branches;
next	1.41;

1.41
date	2012.05.25.11.36.08;	author rosch;	state Exp;
branches;
next	1.40;

1.40
date	2012.05.25.10.18.19;	author rosch;	state Exp;
branches;
next	1.39;

1.39
date	2012.03.30.07.36.10;	author rosch;	state Exp;
branches;
next	1.38;

1.38
date	2012.02.28.21.50.51;	author kevinb;	state Exp;
branches;
next	1.37;

1.37
date	2011.12.17.19.30.39;	author kseitz;	state Exp;
branches;
next	1.36;

1.36
date	2011.04.12.05.11.08;	author kseitz;	state Exp;
branches;
next	1.35;

1.35
date	2011.04.08.23.32.42;	author kseitz;	state Exp;
branches;
next	1.34;

1.34
date	2009.07.07.12.38.56;	author muller;	state Exp;
branches;
next	1.33;

1.33
date	2009.03.25.23.43.07;	author muller;	state Exp;
branches;
next	1.32;

1.32
date	2009.03.02.22.44.33;	author kevinb;	state Exp;
branches;
next	1.31;

1.31
date	2008.10.27.18.40.12;	author kseitz;	state Exp;
branches;
next	1.30;

1.30
date	2008.10.27.18.18.19;	author kseitz;	state Exp;
branches;
next	1.29;

1.29
date	2008.09.02.17.29.23;	author kseitz;	state Exp;
branches;
next	1.28;

1.28
date	2008.07.14.23.43.36;	author kseitz;	state Exp;
branches;
next	1.27;

1.27
date	2008.03.07.08.03.19;	author kseitz;	state Exp;
branches;
next	1.26;

1.26
date	2007.07.02.18.33.22;	author uweigand;	state Exp;
branches;
next	1.25;

1.25
date	2007.05.22.16.29.38;	author macro;	state Exp;
branches;
next	1.24;

1.24
date	2007.04.27.15.39.50;	author macro;	state Exp;
branches;
next	1.23;

1.23
date	2007.03.13.16.29.14;	author kevinb;	state Exp;
branches;
next	1.22;

1.22
date	2005.12.23.18.23.16;	author eliz;	state Exp;
branches;
next	1.21;

1.21
date	2005.02.17.07.15.50;	author hunt;	state Exp;
branches;
next	1.20;

1.20
date	2004.01.07.18.35.59;	author jjohnstn;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.11.23.29.49;	author carlton;	state Exp;
branches;
next	1.18;

1.18
date	2003.04.11.17.40.23;	author cagney;	state Exp;
branches;
next	1.17;

1.17
date	2003.02.25.21.36.22;	author carlton;	state Exp;
branches;
next	1.16;

1.16
date	2003.02.21.15.23.51;	author drow;	state Exp;
branches;
next	1.15;

1.15
date	2003.02.20.12.12.33;	author muller;	state Exp;
branches;
next	1.14;

1.14
date	2002.11.30.17.49.21;	author cagney;	state Exp;
branches;
next	1.13;

1.13
date	2002.11.27.15.29.54;	author cagney;	state Exp;
branches;
next	1.12;

1.12
date	2002.11.24.18.44.36;	author cagney;	state Exp;
branches;
next	1.11;

1.11
date	2002.11.19.19.33.46;	author cagney;	state Exp;
branches;
next	1.10;

1.10
date	2002.11.12.20.24.04;	author cagney;	state Exp;
branches;
next	1.9;

1.9
date	2002.04.23.00.03.09;	author kseitz;	state Exp;
branches;
next	1.8;

1.8
date	2002.04.05.22.27.30;	author kseitz;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.07.21.56.07;	author hunt;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.07.05.05.06;	author hunt;	state Exp;
branches;
next	1.5;

1.5
date	2001.11.05.19.42.48;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2001.10.17.20.35.32;	author cagney;	state Exp;
branches;
next	1.3;

1.3
date	2001.10.12.23.51.30;	author drow;	state Exp;
branches;
next	1.2;

1.2
date	2001.06.11.20.07.46;	author kseitz;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.10.18.04.23;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.42
log
@	* generic/gdbtk-stack.c (get_frame_name): Change type of 'funname'
	to char * to follow recent API updates in gdb.
	Free 'funname' after appending it to the list.
	Remove check for NULL funname in a branch where it could only
	ever be NULL.
@
text
@/* Tcl/Tk command definitions for Insight - Stack.
   Copyright (C) 2001-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */

#include "defs.h"
#include "target.h"
#include "breakpoint.h"
#include "linespec.h"
#include "block.h"
#include "dictionary.h"
#include "varobj.h"
#include "arch-utils.h"
#include "stack.h"
#include "solib.h"

#include <tcl.h>
#include "gdbtk.h"
#include "gdbtk-cmds.h"
#include "gdbtk-wrapper.h"

static int gdb_block_vars (ClientData clientData,
			   Tcl_Interp * interp, int objc,
			   Tcl_Obj * CONST objv[]);
static int gdb_get_args_command (ClientData, Tcl_Interp *, int,
				 Tcl_Obj * CONST objv[]);
static int gdb_get_blocks (ClientData clientData,
			   Tcl_Interp * interp, int objc,
			   Tcl_Obj * CONST objv[]);
static int gdb_get_locals_command (ClientData, Tcl_Interp *, int,
				   Tcl_Obj * CONST objv[]);
static int gdb_get_vars_command (ClientData, Tcl_Interp *, int,
				 Tcl_Obj * CONST objv[]);
static int gdb_selected_block (ClientData clientData,
			       Tcl_Interp * interp, int argc,
			       Tcl_Obj * CONST objv[]);
static int gdb_selected_frame (ClientData clientData,
			       Tcl_Interp * interp, int argc,
			       Tcl_Obj * CONST objv[]);
static int gdb_stack (ClientData, Tcl_Interp *, int, Tcl_Obj * CONST[]);
static void get_frame_name (Tcl_Interp *interp, Tcl_Obj *list,
			    struct frame_info *fi);

int
Gdbtk_Stack_Init (Tcl_Interp *interp)
{
  Tcl_CreateObjCommand (interp, "gdb_block_variables", gdbtk_call_wrapper,
			gdb_block_vars, NULL);
  Tcl_CreateObjCommand (interp, "gdb_get_blocks", gdbtk_call_wrapper,
			gdb_get_blocks, NULL);
  Tcl_CreateObjCommand (interp, "gdb_get_args", gdbtk_call_wrapper,
			gdb_get_args_command, NULL);
  Tcl_CreateObjCommand (interp, "gdb_get_locals", gdbtk_call_wrapper,
			gdb_get_locals_command, NULL);
  Tcl_CreateObjCommand (interp, "gdb_selected_block", gdbtk_call_wrapper,
			gdb_selected_block, NULL);
  Tcl_CreateObjCommand (interp, "gdb_selected_frame", gdbtk_call_wrapper,
			gdb_selected_frame, NULL);
  Tcl_CreateObjCommand (interp, "gdb_stack", gdbtk_call_wrapper, gdb_stack, NULL);

  return TCL_OK;
}

/* This implements the tcl command gdb_block_vars.
 *
 * Returns all variables valid in the specified block.
 *
 * Arguments:
 *    The start and end addresses which identify the block.
 * Tcl Result:
 *    All variables defined in the given block.
 */
static int
gdb_block_vars (ClientData clientData, Tcl_Interp *interp,
		int objc, Tcl_Obj *CONST objv[])
{
  struct block *block;
  struct block_iterator iter;
  struct symbol *sym;
  CORE_ADDR start, end;

  if (objc < 3)
    {
      Tcl_WrongNumArgs (interp, 1, objv, "startAddr endAddr");
      return TCL_ERROR;
    }

  Tcl_SetListObj (result_ptr->obj_ptr, 0, NULL);
  if (!target_has_registers)
    return TCL_OK;

  start = string_to_core_addr (Tcl_GetStringFromObj (objv[1], NULL));
  end   = string_to_core_addr (Tcl_GetStringFromObj (objv[2], NULL));
  
  block = get_frame_block (get_selected_frame (NULL), 0);

  while (block != 0)
    {
      if (BLOCK_START (block) == start && BLOCK_END (block) == end)
	{
	  ALL_BLOCK_SYMBOLS (block, iter, sym)
	    {
	      switch (SYMBOL_CLASS (sym))
		{
		case LOC_ARG:		  /* argument              */
		case LOC_REF_ARG:	  /* reference arg         */
		case LOC_REGPARM_ADDR:    /* indirect register arg */
		case LOC_LOCAL:	          /* stack local           */
		case LOC_STATIC:	  /* static                */
		case LOC_REGISTER:        /* register              */
		case LOC_COMPUTED:	  /* computed location     */
		  Tcl_ListObjAppendElement (interp, result_ptr->obj_ptr,
					    Tcl_NewStringObj (SYMBOL_PRINT_NAME (sym),
							      -1));
		  break;

		default:
		  break;
		}
	    }

	  return TCL_OK;
	}
      else if (BLOCK_FUNCTION (block))
	break;
      else
	block = BLOCK_SUPERBLOCK (block);
    }

  return TCL_OK;
}

/* This implements the tcl command gdb_get_blocks
 *
 * Returns the start and end addresses for all blocks in
 * the selected frame.
 *
 * Arguments:
 *    None
 * Tcl Result:
 *    A list of all valid blocks in the selected_frame.
 */
static int
gdb_get_blocks (ClientData clientData, Tcl_Interp *interp,
		int objc, Tcl_Obj *CONST objv[])
{
  struct block *block;
  struct block_iterator iter;
  int junk;
  struct symbol *sym;
  CORE_ADDR pc;

  Tcl_SetListObj (result_ptr->obj_ptr, 0, NULL);
  
  if (target_has_registers)
    {
      struct frame_info *frame = get_selected_frame (NULL);

      block = get_frame_block (frame, 0);
      pc = get_frame_pc (frame);
      while (block != 0)
	{
	  junk = 0;
	  ALL_BLOCK_SYMBOLS (block, iter, sym)
	    {
	      switch (SYMBOL_CLASS (sym))
		{
		default:
		case LOC_UNDEF:		  /* catches errors        */
		case LOC_CONST:           /* constant              */
		case LOC_TYPEDEF:	  /* local typedef         */
		case LOC_LABEL:	          /* local label           */
		case LOC_BLOCK:	          /* local function        */
		case LOC_CONST_BYTES:	  /* loc. byte seq.        */
		case LOC_UNRESOLVED:      /* unresolved static     */
		case LOC_OPTIMIZED_OUT:   /* optimized out         */
		  junk = 1;
		  break;

		case LOC_ARG:		  /* argument              */
		case LOC_REF_ARG:	  /* reference arg         */
		case LOC_REGPARM_ADDR:    /* indirect register arg */

		case LOC_LOCAL:	          /* stack local           */
		case LOC_STATIC:	  /* static                */
		case LOC_REGISTER:        /* register              */
		case LOC_COMPUTED:	  /* computed location     */
		  junk = 0;
		  break;
		}
	    }

	  /* If we found a block with locals in it, add it to the list. 
	     Note that the ranges of start and end address for blocks
	     are exclusive, so double-check against the PC */
	  
	  if (!junk && pc < BLOCK_END (block))
	    {
	      char *addr;

	      Tcl_Obj *elt = Tcl_NewListObj (0, NULL);
	      addr = xstrprintf ("%s", paddress (get_current_arch (),
						 BLOCK_START (block)));
	      Tcl_ListObjAppendElement (interp, elt,
					Tcl_NewStringObj (addr, -1));
	      free(addr);
	      addr = xstrprintf ("%s", paddress (get_current_arch (),
						 BLOCK_END (block)));
	      Tcl_ListObjAppendElement (interp, elt,
					Tcl_NewStringObj (addr, -1));
	      Tcl_ListObjAppendElement (interp, result_ptr->obj_ptr, elt);
	      free(addr);
	    }

	  if (BLOCK_FUNCTION (block))
	    break;
	  else
	    block = BLOCK_SUPERBLOCK (block);
	}
    }

  return TCL_OK;
}

/* gdb_get_args -
 * This and gdb_get_locals just call gdb_get_vars_command with the right
 * value of clientData.  We can't use the client data in the definition
 * of the command, because the call wrapper uses this instead...
 */
static int
gdb_get_args_command (ClientData clientData, Tcl_Interp *interp,
		      int objc, Tcl_Obj *CONST objv[])
{
  return gdb_get_vars_command ((ClientData) 1, interp, objc, objv);
}


static int
gdb_get_locals_command (ClientData clientData, Tcl_Interp *interp,
			int objc, Tcl_Obj *CONST objv[])
{
  return gdb_get_vars_command ((ClientData) 0, interp, objc, objv);
}

/* This implements the tcl commands "gdb_get_locals" and "gdb_get_args"

* This function sets the Tcl interpreter's result to a list of variable names
* depending on clientData. If clientData is one, the result is a list of
* arguments; zero returns a list of locals -- all relative to the block
* specified as an argument to the command. Valid commands include
* anything decode_line_1 can handle (like "main.c:2", "*0x02020202",
* and "main").
*
* Tcl Arguments:
*   linespec - the linespec defining the scope of the lookup. Empty string
*              to use the current block in the innermost frame.
* Tcl Result:
*   A list of the locals or args
*/
static int
gdb_get_vars_command (ClientData clientData, Tcl_Interp *interp,
		      int objc, Tcl_Obj *CONST objv[])
{
  struct symtabs_and_lines sals;
  struct symbol *sym;
  struct block *block;
  char *args;
  struct block_iterator iter;
  int i, arguments;

  if (objc > 2)
    {
      Tcl_WrongNumArgs (interp, 1, objv,
			"[function:line|function|line|*addr]");
      return TCL_ERROR;
    }

  arguments = clientData != NULL ? 1 : 0;

  /* Initialize the result pointer to an empty list. */

  Tcl_SetListObj (result_ptr->obj_ptr, 0, NULL);

  if (objc == 2)
    {
      args = Tcl_GetStringFromObj (objv[1], NULL);
      sals = decode_line_1 (&args, DECODE_LINE_FUNFIRSTLINE, NULL, 0);
      if (sals.nelts == 0)
	{
	  gdbtk_set_result (interp, "error decoding line");
	  return TCL_ERROR;
	}

      /* Resolve all line numbers to PC's */
      for (i = 0; i < sals.nelts; i++)
	resolve_sal_pc (&sals.sals[i]);

      block = block_for_pc (sals.sals[0].pc);
    }
  else
    {
      /* Specified currently selected frame */
      if (!target_has_registers)
	return TCL_OK;

      block = get_frame_block (get_selected_frame (NULL), 0);
    }

  while (block != 0)
    {
      ALL_BLOCK_SYMBOLS (block, iter, sym)
	{
	  switch (SYMBOL_CLASS (sym))
	    {
	    default:
	    case LOC_UNDEF:	/* catches errors        */
	    case LOC_CONST:	/* constant              */
	    case LOC_TYPEDEF:	/* local typedef         */
	    case LOC_LABEL:	/* local label           */
	    case LOC_BLOCK:	/* local function        */
	    case LOC_CONST_BYTES:	/* loc. byte seq.        */
	    case LOC_UNRESOLVED:	/* unresolved static     */
	    case LOC_OPTIMIZED_OUT:	/* optimized out         */
	      break;
	    case LOC_ARG:	/* argument              */
	    case LOC_REF_ARG:	/* reference arg         */
	    case LOC_REGPARM_ADDR:	/* indirect register arg */
	      if (arguments)
		Tcl_ListObjAppendElement (interp, result_ptr->obj_ptr,
					  Tcl_NewStringObj (SYMBOL_PRINT_NAME (sym), -1));
	      break;
	    case LOC_LOCAL:	/* stack local           */
	    case LOC_STATIC:	/* static                */
	    case LOC_REGISTER:	/* register              */
	    case LOC_COMPUTED:	/* computed location     */
	      if (!arguments)
		Tcl_ListObjAppendElement (interp, result_ptr->obj_ptr,
					  Tcl_NewStringObj (SYMBOL_PRINT_NAME (sym), -1));
	      break;
	    }
	}
      if (BLOCK_FUNCTION (block))
	break;
      else
	block = BLOCK_SUPERBLOCK (block);
    }

  return TCL_OK;
}

/* This implements the tcl command gdb_selected_block
 *
 * Returns the start and end addresses of the innermost
 * block in the selected frame.
 *
 * Arguments:
 *    None
 * Tcl Result:
 *    The currently selected block's start and end addresses
 */
static int
gdb_selected_block (ClientData clientData, Tcl_Interp *interp,
		    int objc, Tcl_Obj *CONST objv[])
{
  char *start = NULL;
  char *end   = NULL;

  if (!target_has_registers)
    {
      start = xstrprintf ("%s", "");
      end = xstrprintf ("%s", "");
    }
  else
    {
      struct block *block;
      block = get_frame_block (get_selected_frame (NULL), 0);
      start = xstrprintf ("%s", paddress (get_current_arch (),
					  BLOCK_START (block)));
      end = xstrprintf ("%s", paddress (get_current_arch (),
					BLOCK_END (block)));
    }

  Tcl_SetListObj (result_ptr->obj_ptr, 0, NULL);
  Tcl_ListObjAppendElement (interp, result_ptr->obj_ptr,
			    Tcl_NewStringObj (start, -1));
  Tcl_ListObjAppendElement (interp, result_ptr->obj_ptr,
			    Tcl_NewStringObj (end, -1));

  free(start);
  free(end);
  return TCL_OK;
}

/* This implements the tcl command gdb_selected_frame

* Returns the address of the selected frame
* frame.
*
* Arguments:
*    None
* Tcl Result:
*    The currently selected frame's address
*/
static int
gdb_selected_frame (ClientData clientData, Tcl_Interp *interp,
		    int objc, Tcl_Obj *CONST objv[])
{
  char *frame;

  if (!target_has_registers)
    frame = xstrprintf ("%s","");
  else
    /* FIXME: cagney/2002-11-19: This should be using get_frame_id()
       to identify the frame and *NOT* get_frame_base().  */
    frame = xstrprintf ("%s",paddress (get_current_arch (),
			get_frame_base (get_selected_frame (NULL))));

  Tcl_SetStringObj (result_ptr->obj_ptr, frame, -1);

  free(frame);
  return TCL_OK;
}

/* This implements the tcl command gdb_stack.
 * It builds up a list of stack frames.
 *
 * Tcl Arguments:
 *    start  - starting stack frame
 *    count - number of frames to inspect
 * Tcl Result:
 *    A list of function names
 */
static int
gdb_stack (ClientData clientData, Tcl_Interp *interp,
	   int objc, Tcl_Obj *CONST objv[])
{
  int start, count;

  if (objc < 3)
    {
      Tcl_WrongNumArgs (interp, 1, objv, "start count");
      return TCL_ERROR;
    }

  if (Tcl_GetIntFromObj (NULL, objv[1], &start))
    {
      result_ptr->flags |= GDBTK_IN_TCL_RESULT;
      return TCL_ERROR;
    }
  if (Tcl_GetIntFromObj (NULL, objv[2], &count))
    {
      result_ptr->flags |= GDBTK_IN_TCL_RESULT;
      return TCL_ERROR;
    }

  if (target_has_stack)
    {
      gdb_result r;
      struct frame_info *top;
      struct frame_info *fi;

      /* Find the outermost frame */
      r  = GDB_get_current_frame (&fi);
      if (r != GDB_OK)
        return TCL_ERROR;

      while (fi != NULL)
        {
          top = fi;
          r = GDB_get_prev_frame (fi, &fi);
          if (r != GDB_OK)
            fi = NULL;
        }

      result_ptr->obj_ptr = Tcl_NewListObj (0, NULL);

      /* top now points to the top (outermost frame) of the
         stack, so point it to the requested start */
      start = -start;
      r = GDB_find_relative_frame (top, &start, &top);
      if (r != GDB_OK)
        return TCL_OK;

      /* If start != 0, then we have asked to start outputting
         frames beyond the innermost stack frame */
      if (start == 0)
        {
          fi = top; 
          while (fi && count--)
            {
              get_frame_name (interp, result_ptr->obj_ptr, fi);
              r = GDB_get_next_frame (fi, &fi);
              if (r != GDB_OK)
                break;
            }
        }
    }

  return TCL_OK;
}

/* A helper function for get_stack which adds information about
 * the stack frame FI to the caller's LIST.
 *
 * This is stolen from print_frame_info/print_frame in stack.c.
 */

static void
get_frame_name (Tcl_Interp *interp, Tcl_Obj *list, struct frame_info *fi)
{
  struct symbol *func = NULL;
  char *funname = NULL;
  enum language funlang = language_unknown;
  Tcl_Obj *objv[1];

  if (get_frame_type (fi) == DUMMY_FRAME)
    {
      objv[0] = Tcl_NewStringObj ("<function called from gdb>", -1);
      Tcl_ListObjAppendElement (interp, list, objv[0]);
      return;
    }
  if (get_frame_type (fi) == SIGTRAMP_FRAME)
    {
      objv[0] = Tcl_NewStringObj ("<signal handler called>", -1);
      Tcl_ListObjAppendElement (interp, list, objv[0]);
      return;
    }
  if (get_frame_type (fi) == ARCH_FRAME)
    {
      objv[0] = Tcl_NewStringObj ("<cross-architecture call>", -1);
      Tcl_ListObjAppendElement (interp, list, objv[0]);
      return;
    }

  find_frame_funname (fi, &funname, &funlang, &func);

  if (funname)
    {
      objv[0] = Tcl_NewStringObj (funname, -1);
      Tcl_ListObjAppendElement (interp, list, objv[0]);
      xfree (funname);
    }
  else
    {
      char *lib = NULL;
      objv[0] = Tcl_NewStringObj (funname ? funname : "??", -1);
#ifdef PC_SOLIB
      lib = PC_SOLIB (get_frame_pc (fi));
#else
      lib = solib_name_from_address (get_frame_program_space (fi),
                                     get_frame_pc (fi));
#endif
      if (lib)
        Tcl_AppendStringsToObj (objv[0], " from ", lib, (char *) NULL);

      Tcl_ListObjAppendElement (interp, list, objv[0]);
    }
}
@


1.41
log
@2012-05-25  Roland Schwingel  <roland.schwingel@@onevision.com>

	* generic/gdbtk-bp.c (gdb_set_bp): Add new NULL param
	to call to create_breakpoint() due to changes in gdb.
	* generic/gdbtk-cmds.c (gdb_listfuncs): Iterator param
	in call to ALL_BLOCK_SYMBOLS() now is a pointer to
	struct block_iterator instead of struct dict_iterator.
	* generic/gdbtk-stack.c (gdb_block_vars,gdb_get_blocks)
	(gdb_get_vars_command): Likewise.
	* generic/gdbtk-hooks.c (gdbtk_annotate_signal): Change
	function calls: target_signal_to_name -> gdb_signal_to_name
	target_signal_to_string -> gdb_signal_to_string due to
	recent changes in gdb.
@
text
@d2 1
a2 1
   Copyright (C) 2001-2012 Free Software Foundation, Inc.
d527 1
a527 1
  const char *funname = NULL;
d556 1
@


1.40
log
@2012-05-25  Roland Schwingel  <roland.schwingel@@onevision.com>

   * generic/gdbtk-stack.c: Updated copyright informations.
   include "stack.h" and "solib.h".
   (gdb_stack): Some reformatting.
   (get_frame_name): Updated usage of gdb api for
   backtrace generation. Some reformatting. Removed
   dead code. Also handle frame type ARCH_FRAME now.
   * library/stackwin.it[bh]: Remove dead instance
   variable maxwidth. Updated copyright informations.
@
text
@d93 1
a93 1
  struct dict_iterator iter;
d163 1
a163 1
  struct dict_iterator iter;
d283 1
a283 1
  struct dict_iterator iter;
@


1.39
log
@	* generic/gdbtk-register.c: Updated Copyright year to 2001-2012.
	(get_register_types): Cast result of TYPE_FIELD_TYPE to size_t
	instead of long.
	(gdb_regformat): on windows 64bit use strtoll instead of strtol.
	* generic/gdbtk-stack.c: Updated Copyright year to 2001-2012.
	(gdb_get_vars_command): Don't cast clientData to long. Here
	checking of non NULL clientData is enough.
@
text
@d29 2
d480 1
a480 1
	return TCL_ERROR;
d485 3
a487 3
	  r = GDB_get_prev_frame (fi, &fi);
	  if (r != GDB_OK)
	    fi = NULL;
d490 2
a495 2
      
      result_ptr->obj_ptr = Tcl_NewListObj (0, NULL);
d497 1
a497 1
	return TCL_OK;
d508 2
a509 2
	      if (r != GDB_OK)
		break;
d520 1
a520 1
 * This is stolen from print_frame_info in stack.c.
d522 1
a525 1
  struct symtab_and_line sal;
d527 1
a527 1
  const char *funname = 0;
d537 1
a537 1
  if ((get_frame_type (fi) == SIGTRAMP_FRAME))
d543 1
a543 26

  sal =
    find_pc_line (get_frame_pc (fi),
		  get_next_frame (fi) != NULL
		  && !(get_frame_type (fi) == SIGTRAMP_FRAME)
		  && !(get_frame_type (fi) == DUMMY_FRAME));

  func = find_pc_function (get_frame_pc (fi));
  if (func)
    {
      struct minimal_symbol *msymbol = lookup_minimal_symbol_by_pc (get_frame_pc (fi));
      if (msymbol != NULL
	  && (SYMBOL_VALUE_ADDRESS (msymbol)
	      > BLOCK_START (SYMBOL_BLOCK_VALUE (func))))
	{
	  func = 0;
	  funname = GDBTK_SYMBOL_SOURCE_NAME (msymbol);
	  funlang = SYMBOL_LANGUAGE (msymbol);
	}
      else
	{
	  funname = GDBTK_SYMBOL_SOURCE_NAME (func);
	  funlang = SYMBOL_LANGUAGE (func);
	}
    }
  else
d545 3
a547 6
      struct minimal_symbol *msymbol = lookup_minimal_symbol_by_pc (get_frame_pc (fi));
      if (msymbol != NULL)
	{
	  funname = GDBTK_SYMBOL_SOURCE_NAME (msymbol);
	  funlang = SYMBOL_LANGUAGE (msymbol);
	}
d550 3
a552 1
  if (sal.symtab)
d559 2
a560 11
#if 0
      /* we have no convenient way to deal with this yet... */
      if (fi->pc != sal.pc || !sal.symtab)
	{
	  deprecated_print_address_numeric (fi->pc, 1, gdb_stdout);
	  printf_filtered (" in ");
	}
      printf_symbol_filtered (gdb_stdout, funname ? funname : "??", funlang,
			      DMGL_ANSI);
#endif
      objv[0] = Tcl_NewStringObj (funname != NULL ? funname : "??", -1);
d562 4
a565 8
      if (!funname)
	{
	  char *lib = PC_SOLIB (get_frame_pc (fi));
	  if (lib)
	    {
	      Tcl_AppendStringsToObj (objv[0], " from ", lib, (char *) NULL);
	    }
	}
d567 3
@


1.38
log
@	* generic/gdbtk-cmds.h (pc_function_name): Make return type
	const.
	* generic/gdbtk-bp.c (gdb_get_breakpoint_info)
	(gdb_get_tracepoint_info): Make char * variables const to match
	recent GDB API changes.
	* generic/gdbtk-stack.c (get_frame_name): Likewise.
	* generic/gdbtk-cmds.c (gdb_get_function_command, gdb_listfuncs)
	(gdb_loc, perror_with_name_wrapper): Likewise.
	(pc_function_name): Likewise, plus change return type to be const.
@
text
@d2 1
a2 2
   Copyright (C) 2001, 2002, 2003, 2008, 2011
   Free Software Foundation, Inc.
d291 1
a291 1
  arguments = (long) clientData;
@


1.37
log
@	* generic/gdbtk-cmds.c (gdb_listfiles): Update API changes
	for map_partial_symbol_filenames.
	(gdb_get_line_command): Update API changes for decode_line_1 in gdb.
	(gdb_get_file_command): Likewise.
	(gdb_get_function_command): Likewise.
	* generic/gdbtk-stack.c (gdb_get_vars_command): Likewise.
	* generic/gdbtk-bp.c (tracepoint_exists): Likewise.
	(gdb_find_bp_at_line, gdb_get_breakpoint_info): Update breakpoint
	API changes in gdb.
@
text
@d526 1
a526 1
  register char *funname = 0;
@


1.36
log
@	* generic/gdbtk-bp.c (tracepoint_exists): Remove recently
	removed "not_found_ptr" argument from call to decode_line_1.
	* generic/gdbtk-stack.c (gdb_get_vars_command): Likewise.
	* generic/gdbtk-cmds.c (gdb_get_line_command): Likewise.
	(gdb_get_file_command): Likewise.
	(gdb_get_function_command): Likewise.

	From Kevin Buettner  <kevinb@@redhat.com>
	* generic/gdbtk-register.c (): Delete declaration of `buffer'.
	Use `valaddr' in its place.
@
text
@d301 1
a301 1
      sals = decode_line_1 (&args, 1, NULL, 0, NULL);
@


1.35
log
@	* generic/gdbtk-bp.c (tracepoint_exists): Update for
	decode_line_1 API change.
	* generic/gdbtk-cmds.c (gdb_eval): Use comman_val_print
	instead of val_print.
	(gdb_get_line_command): Update for decode_line_1 API
	changes.
	(gdb_get_file_command): Likewise.
	(gdb_get_function_command): Likewise.
	* generic/gdbtk-register.c (get_register_types): Use
	get_frame_register_value instead of frame_register.
	(get_register): Pass valid VALUE to val_print.
	Consolidate calls to get_current_gdbarch.
	* generic/gdbtk-stack.c (gdb_get_vars_command): Update
	for decode_line_1 API change.
@
text
@d301 1
a301 1
      sals = decode_line_1 (&args, 1, NULL, 0, NULL, NULL);
@


1.34
log
@	* generic/gdbtk-bp.c: Include "arch-utils.h".
	(set_raw_breakpoint): Update external definition.
	(gdb_set_bp): Adapt to set_raw_breakpoint change.
	(gdb_set_bp_addr): Likewise.
	* generic/gdbtk-cmds.c: Include "arch-utils.h.
	(gdbtk_load_asm): Adapt to paddress and gdb_print_insn changes.
	(hex2bin): Replace current_gdbarch by get_current_arch call.
	(gdb_update_mem): Adapt to builtin_type changes.
	(gdb_CA_to_TAS): Use paddress to replace removed function paddr_nz.
	* generic/gdbtk-register.c: Include "arch-utils.h".
	(get_register_size): Replace current_gdbarch by get_current_arch call.
	(get_register_types): Likewise.
	(get_register): Likewise.
	(get_register_name): Likewise.
	(map_arg_registers): Likewise.
	(register_changed_p): Likewise.
	(setup_architecture_data): Likewise.
	(gdb_regformat): Likewise.
	(gdb_reggrouplist): Likewise.
	(gdb_reggroup): Likewise.
	* generic/gdbtk-stack.c: Inlcude "arch-utils.h".
	(gdb_get_blocks): Use paddress instead of removed paddr_nz function.
	(gdb_selected_block): Likewise.
	(gdb_selected_frame): Likewise.
@
text
@d2 2
a3 1
   Copyright (C) 2001, 2002, 2003, 2008 Free Software Foundation, Inc.
d281 1
a281 1
  char **canonical, *args;
d301 1
a301 1
      sals = decode_line_1 (&args, 1, NULL, 0, &canonical, NULL);
@


1.33
log
@	ARI fix: "xasprintf" rule.
	* generic/gdbtk-bp.c (gdb_set_bp): Replace xasprintf by xstrprintf.
	(breakpoint_notify, tracepoint_notify):Ditto.
	* generic/gdbtk-cmds.c (gdbtk_load_source, gdbtk_load_asm):Ditto.
	* generic/gdbtk-hooks.c (gdbtk_ignorable_warning): Ditto.
	(gdbtk_set_hook, gdbtk_load_hash): Ditto.
	(gdbtk_selected_frame_changed, gdbtk_annotate_signal): Ditto.
	* generic/gdbtk-register.c (get_register_types):Ditto.
	* generic/gdbtk-stack.c (gdb_get_blocks): Ditto.
	(gdb_selected_block, gdb_selected_frame): Ditto.
	* generic/gdbtk.c (gdbtk_init, view_command): Ditto.
@
text
@d28 1
d215 2
a216 1
	      addr = xstrprintf ("0x%s", paddr_nz (BLOCK_START (block)));
d220 2
a221 1
	      addr = xstrprintf ("0x%s", paddr_nz (BLOCK_END (block)));
d390 4
a393 2
      start = xstrprintf ("0x%s", paddr_nz (BLOCK_START (block)));
      end = xstrprintf ("0x%s", paddr_nz (BLOCK_END (block)));
d428 2
a429 2
    frame = xstrprintf ("0x%s",
	       paddr_nz (get_frame_base (get_selected_frame (NULL))));
@


1.32
log
@	* generic/gdbtk-stack.c (gdb_get_vars_command): Revise cast of
	`clientData' to avoid build error on 64-bit hosts.
@
text
@d214 1
a214 1
	      xasprintf (&addr, "0x%s", paddr_nz (BLOCK_START (block)));
d218 1
a218 1
	      xasprintf (&addr, "0x%s", paddr_nz (BLOCK_END (block)));
d380 2
a381 2
      xasprintf (&start, "%s", "");
      xasprintf (&end, "%s", "");
d387 2
a388 2
      xasprintf (&start, "0x%s", paddr_nz (BLOCK_START (block)));
      xasprintf (&end, "0x%s", paddr_nz (BLOCK_END (block)));
d419 1
a419 1
    xasprintf (&frame, "%s","");
d423 1
a423 1
    xasprintf (&frame, "0x%s",
@


1.31
log
@Replaces my previous bogus patch on this:

        * generic/gdbtk-stack.c (get_gdb_vars_command): clientData is an
        int, not a pointer to int.
@
text
@d288 1
a288 1
  arguments = (int) clientData;
@


1.30
log
@        * generic/gdbtk-stack.c (get_gdb_vars_command): Remove superfluous
        ampersand from assignment.
@
text
@d288 1
a288 1
  arguments = *(int *) clientData;
@


1.29
log
@        * generic/gdbtk-cmds.c (gdb_listfuncs): Use SYMBOL_PRINT_NAME
        instead of DEPRECATED_SYMBOL_NAME.
        * generic/gdbtk-stack.c (gdb_block_vars): Likewise.
        (gdb_get_vars_command): Likewise.
        * generic/gdbtk.h (GDBTK_SYMBOL_SOURCE_NAME): Likewise.
@
text
@d288 1
a288 1
  arguments = *(int*) &clientData;
@


1.28
log
@        * generic/gdbtk-stack.c (gdb_block_args): Remove deprecated values
        LOC_LOCAL_ARG, LOC_COMPUTED_ARG, LOC_REGPARM, LOC_BASEARG_ARG, and
        LOC_BASEARG.
        (gdb_get_blocks): Likewise.
        (gdb_get_vars_command): Likewise.
        Fix type-punned pointer error introduced on 03-07.

        * generic/gdbtk-cmds.c (gdbtk_load_asm): Use paddress instead
        of deprecated_print_address_numeric.
        (gdb_stop): Update use of target_stop.

        * generic/gdbtk.h (gdbtk_get_ptid): Declare new function.
        * generic/gdbtk-hooks.c (gdbtk_wait): Save inferior's ptid.
        (gdbtk_get_ptid): Define new function.
        * generic/gdbtk-varobj.c (variable_update): Update for recent
        varobj_update API change.
        * generic/gdbtk-wrapper.h (GDB_varobj_update): Likewise.
        * generic/gdbtk-wrapper.c (GDB_varobj_update): Likewise.
        (wrap_varobj_update): Likewise.

        * library/targetselection.itb (init_target_db): Initialize
        preferences here instead of ...
        (_init): ... here.
        (_init_prefs): Define gdb/load/default-portname, too.
@
text
@d125 1
a125 1
					    Tcl_NewStringObj (DEPRECATED_SYMBOL_NAME (sym),
d340 1
a340 1
					  Tcl_NewStringObj (DEPRECATED_SYMBOL_NAME (sym), -1));
d348 1
a348 1
					  Tcl_NewStringObj (DEPRECATED_SYMBOL_NAME (sym), -1));
@


1.27
log
@        * generic/gdbtk-register.c (map_arg): New data type
        for passing arguments to mapping functions.
        (map_func): New definition of mapping function.
        Changed all callers to use these new types.
        * generic/gdbtk-stack.c (gdb_get_vars_command): Change
        cast to int to dereference of int *.
        * generic/gdbtk-wrapper.c: Change all casts to char * for
        results and args to use pointer or integer flavor of
        gdb_wrapper_args.results and .args.
        * generic/gdbtk-wrapper.h: struct gdb_wrapper_arguments
        members result and args now return a union of void * and int.
@
text
@d2 1
a2 1
   Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.
a118 1
		case LOC_REGPARM:	  /* register arg          */
a119 2
		case LOC_LOCAL_ARG:	  /* stack arg             */
		case LOC_BASEREG_ARG:	  /* basereg arg           */
a120 1
		case LOC_BASEREG:	  /* basereg local         */
a123 1
		case LOC_COMPUTED_ARG:	  /* computed location arg */
a193 1
		case LOC_REGPARM:	  /* register arg          */
a194 3
		case LOC_LOCAL_ARG:	  /* stack arg             */
		case LOC_BASEREG_ARG:	  /* basereg arg           */
		case LOC_COMPUTED_ARG:	  /* computed location arg */
a196 1
		case LOC_BASEREG:	  /* basereg local         */
d288 1
a288 1
  arguments = *(int*) clientData;
a336 1
	    case LOC_REGPARM:	/* register arg          */
a337 3
	    case LOC_LOCAL_ARG:	/* stack arg             */
	    case LOC_BASEREG_ARG:	/* basereg arg           */
	    case LOC_COMPUTED_ARG:	/* computed location arg */
a342 1
	    case LOC_BASEREG:	/* basereg local         */
@


1.26
log
@2007-07-02  Markus Deuling  <deuling@@de.ibm.com>

	* gdbtk/generic/gdbtk-stack.c (get_frame_name): Remove dead code
	(PC_LOAD_SEGMENT).
@
text
@d298 1
a298 1
  arguments = (int) clientData;
@


1.25
log
@* generic/gdbtk-stack.c (get_frame_name): Remove spurious
newlines from dummy/sigtramp frame names.
@
text
@a603 10
#ifdef PC_LOAD_SEGMENT
      /* If we couldn't print out function name but if can figure out what
         load segment this pc value is from, at least print out some info
         about its load segment. */
      if (!funname)
	{
	  Tcl_AppendStringsToObj (objv[0], " from ", PC_LOAD_SEGMENT (fi->pc),
				  (char *) NULL);
	}
#endif
@


1.24
log
@gdb/:
* Makefile.in (gdbtk-wrapper.o): Update dependencies.
(gdbtk-varobj.o, gdbtk-cmds.o, gdbtk-stack.o): Likewise.

gdb/gdbtk/:
* generic/gdbtk-wrapper.c (GDB_varobj_update): New function.
(wrap_varobj_update): Likewise.
* generic/gdbtk-wrapper.h (GDB_varobj_update): New declaration.
* generic/gdbtk-varobj.c (variable_update): Call
GDB_varobj_update() rather than varobj_update() directly.  Take
the new semantics of the latter into account.
* generic/gdbtk-cmds.c: Include "varobj.h".
* generic/gdbtk-stack.c: Likewise.
@
text
@d541 1
a541 1
      objv[0] = Tcl_NewStringObj ("<function called from gdb>\n", -1);
d547 1
a547 1
      objv[0] = Tcl_NewStringObj ("<signal handler called>\n", -1);
@


1.23
log
@Eliminate use of `deprecated_selected_frame'.
@
text
@d27 1
@


1.22
log
@	* generic/gdbtk.h:
	* generic/gdbtk.c:
	* generic/gdbtk-wrapper.h:
	* generic/gdbtk-wrapper.c:
	* generic/gdbtk-varobj.c:
	* generic/gdbtk-stack.c:
	* generic/gdbtk-register.c:
	* generic/gdbtk-main.c:
	* generic/gdbtk-interp.c:
	* generic/gdbtk-hooks.c:
	* generic/gdbtk-cmds.h:
	* generic/gdbtk-cmds.c:
	* generic/gdbtk-bp.c: Put (C) after Copyright.  Update the FSF
	address.
@
text
@d100 1
a100 1
  if (deprecated_selected_frame == NULL)
d106 1
a106 1
  block = get_frame_block (deprecated_selected_frame, 0);
d171 1
a171 1
  if (deprecated_selected_frame != NULL)
d173 4
a176 2
      block = get_frame_block (deprecated_selected_frame, 0);
      pc = get_frame_pc (deprecated_selected_frame);
d322 1
a322 1
      if (deprecated_selected_frame == NULL)
d325 1
a325 1
      block = get_frame_block (deprecated_selected_frame, 0);
d392 1
a392 1
  if (deprecated_selected_frame == NULL)
d400 1
a400 1
      block = get_frame_block (deprecated_selected_frame, 0);
d432 1
a432 1
  if (deprecated_selected_frame == NULL)
d438 1
a438 1
	       paddr_nz (get_frame_base (deprecated_selected_frame)));
@


1.21
log
@2005-02-16  Martin Hunt  <hunt@@redhat.com>

	* generic/gdbtk-stack.c (get_frame_name): Replace
	print_address_numeric with deprecated_print_address_numeric.
	* generic/gdbtk-cmds.c (gdbtk_load_asm): Ditto.
@
text
@d2 1
a2 1
   Copyright 2001, 2002, 2003 Free Software Foundation, Inc.
d18 2
a19 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.20
log
@
2003-12-17  Jeff Johnston  <jjohnstn@@redhat.com>

        * generic/gdbtk-bp.c: Change calls to decode_line_1 to add
        new NULL parameter.
        * generic/gdbtk-cmds.c: Ditto.
        * generic/gdbtk-stack.c: Ditto.
@
text
@d594 1
a594 1
	  print_address_numeric (fi->pc, 1, gdb_stdout);
@


1.19
log
@2003-06-11  David Carlton  <carlton@@bactrian.org>

	* dictionary.h: New.
	* dictionary.c: New.
	* block.h: Add opaque declaration for struct dictionary.
	(struct block): Add 'dict' member; delete 'hashtable', 'nsyms',
	'sym' members.
	(BLOCK_DICT): New macro.
	Delete macros BLOCK_HASHTABLE, BLOCK_NSYMS, BLOCK_SYM,
	BLOCK_BUCKETS, BLOCK_BUCKET, BLOCK_HASHTABLE_SIZE,
	BLOCK_SHOULD_SORT.
	(ALL_BLOCK_SYMBOLS): Update definition.
	* Makefile.in (SFILES): Add dictionary.c.
	(dictionary_h): New.
	(COMMON_OBS): Add dictionary.o.
	(dictionary.o): New.
	(ada-lang.o): Depend on dictionary_h.
	(buildsym.o, coffread.o, jv-lang.o, mdebugread.o, objfiles.o)
	(stack.o, symmisc.o, symtab.o, tracepoint.o, valops.o)
	(mi-cmd-stack.o): Ditto.
	(gdbtk-cmds.o): Update dependencies.
	(gdbtk-stack.o): Ditto.
	* ada-lang.c: Include dictionary.h.
	(symtab_for_sym): Update uses of ALL_BLOCK_SYMBOLS.
	(fill_in_ada_prototype, debug_print_block): Ditto.
	(ada_add_block_symbols): Update uses of ALL_BLOCK_SYMBOLS; replace
	explicit iteration by use of ALL_BLOCK_SYMBOLS.  Delete variable
	'is_sorted'.
	* mdebugread.c: Include dictionary.h.
	(struct parse_stack): Delete 'maxsyms' member.
	(parse_symbol): Update calls to new_block.  Delete calls to
	shrink_block.  Use dictionary methods.
	(psymtab_to_symtab_1): Delete calls to sort_symtab_syms.
	Update calls to new_symtab.  Don't maintain maxsyms data.
	(mylookup_symbol): Update use of ALL_BLOCK_SYMBOLS.
	(add_symbol): Just call dict_add_symbol.
	(new_symtab): Delete 'maxsyms' argument.
	(new_symtab): Update calls to new_block.
	(new_block): Delete 'maxsyms' argument; add 'function' argument.
	(shrink_block): Delete function.
	(fixup_sigtramp): Update call to new_block.  Add symbol via
	dict_add_symbol.
	* jv-lang.c: Include dictionary.h.
	(get_java_class_symtab): Set the BLOCK_DICT of the blocks
	appropriately.  Set class_symtab->free_func.  Make sure the
	blockvector is big enough to hold two blocks.
	(add_class_symtab_symbol): Use dictionary methods.
	(free_class_block): New function.
	(type_from_class): Replace explicit iteration by
	ALL_BLOCK_SYMBOLS.
	* symtab.h (struct symtab): Replace 'free_ptr' method by
	'free_func'.
	* dwarf2read.c (psymtab_to_symtab_1): Delete call to
	sort_symtab_syms.
	* dwarfread.c (psymtab_to_symtab_1): Delete call to
	sort_symtab_syms.
	* coffread.c (coff_symfile_read): Delete call to sort_symtab_syms.
	Include dictionary.h.
	(patch_opaque_types): Update use of ALL_BLOCK_SYMBOLS.
	* dbxread.c (dbx_psymtab_to_symtab_1): Delete call to
	sort_symtab_syms.
	* objfiles.c: Include dictionary.h.
	(objfile_relocate): Update use of ALL_BLOCK_SYMBOLS.
	* buildsym.c: Include dictionary.h.
	(finish_block): Use dictionary methods.
	(end_symtab): Set free_func to NULL, not free_ptr.
	* tracepoint.c: Include dictionary.h.
	(add_local_symbols): Update use of ALL_BLOCK_SYMBOLS.
	(scope_info): Ditto.
	* stack.c: Include dictionary.h.
	(print_block_frame_locals): Update use of ALL_BLOCK_SYMBOLS.
	(print_block_frame_labels, print_frame_arg_vars)
	(print_frame_args): Ditto.
	* symmisc.c (free_symtab_block): Use dictionary methods.
	(dump_symtab): Ditto.
	(free_symtab): Replace use of 'free_ptr' by 'free_func'.
	Include	dictionary.h.
	* symfile.h: Delete declarations of sort_block_syms,
	sort_symtab_syms.
	* symfile.c (sort_block_syms): Delete.
	(sort_symtab_syms): Delete.
	* symtab.c: Include dictionary.h.
	(lookup_block_symbol): Use dictionary iterators.
	(find_pc_sect_symtab): Update use of ALL_BLOCK_SYMBOLS.
	(search_symbols, make_symbol_completion_list): Ditto.
	(make_symbol_overload_list): Ditto.
	* valops.c (value_of_local): Use dict_empty.
	Include dictionary.h.

2003-06-11  David Carlton  <carlton@@bactrian.org>

	* generic/gdbtk-stack.c: Include dictionary.h.
	(gdb_block_vars): Update use of ALL_BLOCK_SYMBOLS.
	(gdb_get_blocks, gdb_get_vars_command): Ditto.
	* generic/gdbtk-cmds.c: Include dictionary.h.
	(gdb_listfuncs): Update use of ALL_BLOCK_SYMBOLS.

2003-06-11  David Carlton  <carlton@@bactrian.org>

	* mi-cmd-stack.c: Include dictionary.h.
	(list_args_or_locals): Update use of ALL_BLOCK_SYMBOLS.
@
text
@d304 1
a304 1
      sals = decode_line_1 (&args, 1, NULL, 0, &canonical);
@


1.18
log
@2003-04-11  Andrew Cagney  <cagney@@redhat.com>

	* generic/gdbtk-stack.c (get_frame_name): Use get_frame_pc and
	get_next_frame.
@
text
@d26 1
d89 1
a89 1
  int i;
d112 1
a112 1
	  ALL_BLOCK_SYMBOLS (block, i, sym)
d164 2
a165 1
  int i, junk;
d178 1
a178 1
	  ALL_BLOCK_SYMBOLS (block, i, sym)
d285 1
d328 1
a328 1
      ALL_BLOCK_SYMBOLS (block, i, sym)
@


1.17
log
@2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.h (SYMBOL_NATURAL_NAME): New macro.
	(SYMBOL_LINKAGE_NAME): Ditto.
	(SYMBOL_PRINT_NAME): Use SYMBOL_NATURAL_NAME and
	SYMBOL_LINKAGE_NAME.
	(struct general_symbol_info): Expand comment.
	(DEPRECATED_SYMBOL_NAME): Rename from SYMBOL_NAME.
	(SYMBOL_MATCHES_NAME): Use DEPRECATED_SYMBOL_NAME.
	(SYMBOL_MATCHES_REGEXP): Ditto.
	* symtab.c (symbol_natural_name): New function.
	* objfiles.h: Replace all uses of SYMBOL_NAME by
	DEPRECATED_SYMBOL_NAME.
	* xcoffread.c, valops.c, typeprint.c, tracepoint.c: Ditto.
	* symtab.c, symmisc.c, symfile.c, stack.c, stabsread.c: Ditto.
	* somsolib.c, sol-thread.c, rs6000-tdep.c, p-valprint.c: Ditto.
	* printcmd.c, objfiles.c, objc-lang.c, mipsread.c: Ditto.
	* minsyms.c, mdebugread.c, linespec.c, jv-lang.c: Ditto.
	* i386-tdep.c, i386-linux-tdep.c, hpread.c, hppa-tdep.c: Ditto.
	* gnu-v2-abi.c, f-valprint.c, findvar.c, expprint.c: Ditto.
	* dwarfread.c, dwarf2read.c, dbxread.c, c-valprint.c: Ditto.
	* cp-valprint.c, coffread.c, buildsym.c, breakpoint.c: Ditto.
	* blockframe.c, ax-gdb.c, arm-linux-tdep.c, ada-lang.c: Ditto.
	* ada-exp.y: Ditto.
	* ada-exp.y: Update copyright.
	* sol-thread.c, mipsread.c, jv-lang.c, f-valprint.c: Ditto.
	* cp-valprint.c: Ditto.

2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* generic/gdbtk.h: Replace all instances of SYMBOL_NAME by
	DEPRECATED_SYMBOL_NAME.
	* generic/gdbtk-stack.c, generic/gdbtk-cmds.c: Ditto.
	* generic/gdbtk-stack.c, generic/gdbtk-cmds.c: Update copyright.

2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c: Replace all instances of SYMBOL_NAME with
	DEPRECATED_SYMBOL_NAME.  Update copyright.
@
text
@d547 2
a548 2
    find_pc_line (fi->pc,
		  fi->next != NULL
d552 1
a552 1
  func = find_pc_function (fi->pc);
d555 1
a555 1
      struct minimal_symbol *msymbol = lookup_minimal_symbol_by_pc (fi->pc);
d572 1
a572 1
      struct minimal_symbol *msymbol = lookup_minimal_symbol_by_pc (fi->pc);
d611 1
a611 1
	  char *lib = PC_SOLIB (fi->pc);
@


1.16
log
@	* generic/gdbtk-stack.c (gdb_get_blocks, gdb_block_vars)
	(gdb_get_vars_command): Handle LOC_COMPUTED and LOC_COMPUTED_ARG.
@
text
@d2 1
a2 1
   Copyright 2001, 2002 Free Software Foundation, Inc.
d128 1
a128 1
					    Tcl_NewStringObj (SYMBOL_NAME (sym),
d348 1
a348 1
					  Tcl_NewStringObj (SYMBOL_NAME (sym), -1));
d357 1
a357 1
					  Tcl_NewStringObj (SYMBOL_NAME (sym), -1));
@


1.15
log
@
2003-02-20  Pierre Muller  <muller@@ics.u-strasbg.fr>

	* generic/gdbtk-cmds.c: Add missing "block.h" include.
	generic/gdbtk-stack.c: Ditto.
	generic/gdbtk-wrapper.c: Ditto.
@
text
@d125 2
d198 1
d204 1
d345 1
d354 1
@


1.14
log
@2002-11-30  Andrew Cagney  <ac131313@@redhat.com>

	* generic/gdbtk-stack.c: Replace selected_frame with
	deprecated_selected_frame.
	* generic/gdbtk-register.c: Ditto.
	* generic/gdbtk-cmds.c (gdb_loc): Replace selected_frame with
	deprecated_selected_frame.  Use get_frame_pc and find_frame_sal.
@
text
@d25 1
@


1.13
log
@2002-11-27  Andrew Cagney  <cagney@@redhat.com>

	* generic/gdbtk-stack.c (get_frame_name): Use get_frame_type
	instead of deprecated_frame_in_dummy.
	* generic/gdbtk-cmds.c (gdb_loc): Ditto.
@
text
@d98 1
a98 1
  if (selected_frame == NULL)
d104 1
a104 1
  block = get_frame_block (selected_frame, 0);
d166 1
a166 1
  if (selected_frame != NULL)
d168 2
a169 2
      block = get_frame_block (selected_frame, 0);
      pc = get_frame_pc (selected_frame);
d312 1
a312 1
      if (selected_frame == NULL)
d315 1
a315 1
      block = get_frame_block (selected_frame, 0);
d380 1
a380 1
  if (selected_frame == NULL)
d388 1
a388 1
      block = get_frame_block (selected_frame, 0);
d420 1
a420 1
  if (selected_frame == NULL)
d425 2
a426 1
    xasprintf (&frame, "0x%s", paddr_nz (get_frame_base (selected_frame)));
@


1.12
log
@2002-11-19  Andrew Cagney  <ac131313@@redhat.com>

	* generic/gdbtk-stack.c (gdb_selected_frame): Use get_frame_base
	instead of FRAME_FP.  Mention that get_frame_id() should be used.
@
text
@d525 1
a525 1
  if (deprecated_frame_in_dummy (fi))
d542 1
a542 1
		  && !deprecated_frame_in_dummy (fi->next));
@


1.11
log
@2002-11-19  Andrew Cagney  <ac131313@@redhat.com>

	* generic/gdbtk-cmds.c (gdb_loc): Use get_frame_type instead of
	->signal_handler_caller.
	* generic/gdbtk-stack.c (get_frame_name): Ditto.
	(get_frame_name): Ditto.
@
text
@d423 3
a425 1
    xasprintf (&frame, "0x%s", paddr_nz (FRAME_FP (selected_frame)));
@


1.10
log
@From: 2002-11-11  David Carlton  <carlton@@math.stanford.edu>

	* generic/gdbtk-stack.c (get_frame_name): Replace call to
	frame_in_dummy with one to deprecated_frame_in_dummy.
	* generic/gdbtk-cmds.c (gdb_loc): Ditto.
@
text
@d529 1
a529 1
  if (fi->signal_handler_caller)
d539 1
a539 1
		  && !fi->next->signal_handler_caller
@


1.9
log
@        * generic/gdbtk-stack.c (Gdbtk_Stack_Init): Don't link
        selected_frame_level directly.
        * generic/gdbtk-hooks.c (gdbtk_selected_frame_changed): Set
        the global "gdb_selected_frame_level" directly.
@
text
@d523 1
a523 1
  if (frame_in_dummy (fi))
d540 1
a540 1
		  && !frame_in_dummy (fi->next));
@


1.8
log
@        * generic/gdbtk-stack.c (gdb_block_vars): Update get_frame_block to
        match recent gdb changes.
        (gdb_get_blocks): Likewise.
        (gdb_get_vars_command): Likewise.
        (gdb_selected_block): Likewise.
@
text
@a69 4
  Tcl_LinkVar (interp, "gdb_selected_frame_level",
	       (char *) &selected_frame_level,
	       TCL_LINK_INT | TCL_LINK_READ_ONLY);

@


1.7
log
@2002-02-07  Martin M. Hunt  <hunt@@redhat.com>

	* generic/gdbtk.c, generic/gdbtk-bp.c, generic/gdbtk-cmds.c,
	generic/gdbtk-hooks.c, generic/gdbtk-stack.c: Cleanup includes.
@
text
@d108 1
a108 1
  block = get_frame_block (selected_frame);
d172 1
a172 1
      block = get_frame_block (selected_frame);
d319 1
a319 1
      block = get_frame_block (selected_frame);
d392 1
a392 1
      block = get_frame_block (selected_frame);
@


1.6
log
@2002-02-06  Martin M. Hunt  <hunt@@redhat.com>

	* generic/gdbtk.c, generic/gdbtk-bp.c, generic/gdbtk-cmds.c,
	generic/gdbtk-hooks.c, generic/gdbtk-register.c,
	generic/gdbtk-stack.c, generic/gdbtk-varobj.c,
	generic/gdbtk-wrapper.c: Cleanup. Fix indentation. Fix
	function declarations. Remove unused variables. Add 2002
	copyrights.
@
text
@a21 3
#include "symtab.h"
#include "frame.h"
#include "value.h"
@


1.5
log
@2001-11-05  Martin M. Hunt  <hunt@@redhat.com>
	* generic/gdbtk-cmds.h (gdbtk_set_result): Declare.
	A printf-like function to return error messages.
	* generic/gdbtk-cmds.c (gdbtk_set_result): New
	function.
	(gdb_cmd): Use gdbtk_set_result.
	(gdb_immediate_command): Ditto.
	(gdb_load_info): Ditto.
	(gdb_find_file_command): Ditto.
	(gdb_listfuncs): Ditto.
	(gdb_load_disassembly): Ditto.
	(gdb_loc): Ditto.
	(gdb_set_mem): Ditto.
	(gdb_get_mem): Ditto.
	(gdb_loadfile): Ditto.
	* generic/gdbtk-varobj.c (variable_format): Ditto.
	(variable_value): Ditto.
	* generic/gdbtk-stack.c (gdb_get_vars_command): Ditto.
	* generic/gdbtk-bp.c (gdb_get_breakpoint_info): Ditto.
	(gdb_set_bp): Ditto.
	(gdb_set_bp_addr): Ditto.
	(gdb_get_tracepoint_info): Ditto.
@
text
@d2 1
a2 1
   Copyright 2001 Free Software Foundation, Inc.
d90 2
a91 5
gdb_block_vars (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
d163 2
a164 5
gdb_get_blocks (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
d248 2
a249 5
gdb_get_args_command (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
d256 2
a257 5
gdb_get_locals_command (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
d264 13
a276 13
 * This function sets the Tcl interpreter's result to a list of variable names
 * depending on clientData. If clientData is one, the result is a list of
 * arguments; zero returns a list of locals -- all relative to the block
 * specified as an argument to the command. Valid commands include
 * anything decode_line_1 can handle (like "main.c:2", "*0x02020202",
 * and "main").
 *
 * Tcl Arguments:
 *   linespec - the linespec defining the scope of the lookup. Empty string
 *              to use the current block in the innermost frame.
 * Tcl Result:
 *   A list of the locals or args
 */
d278 2
a279 5
gdb_get_vars_command (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
d349 1
a349 1
				  Tcl_NewStringObj (SYMBOL_NAME (sym), -1));
d357 1
a357 1
				  Tcl_NewStringObj (SYMBOL_NAME (sym), -1));
d381 2
a382 5
gdb_selected_block (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
d413 8
a420 8
 * Returns the address of the selected frame
 * frame.
 *
 * Arguments:
 *    None
 * Tcl Result:
 *    The currently selected frame's address
 */
d422 2
a423 5
gdb_selected_frame (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
d448 2
a449 5
gdb_stack (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
@


1.4
log
@Functions to convert to/from CORE_ADDR and a string.  Use in Insight.
@
text
@a103 1
      result_ptr->flags |= GDBTK_IN_TCL_RESULT;
d321 1
a321 2
	  Tcl_SetStringObj (result_ptr->obj_ptr,
			    "error decoding line", -1);
a479 1
      result_ptr->flags |= GDBTK_IN_TCL_RESULT;
@


1.3
log
@2001-10-12  Daniel Jacobowitz  <drow@@mvista.com>

        * symtab.h (struct block): (ALL_BLOCK_SYMBOLS): New macro.

        * symtab.c (find_pc_sect_symtab): Use ALL_BLOCK_SYMBOLS.
        (make_symbol_completion_list): Likewise.
        (make_symbol_overload_list): Likewise.
        * buildsym.c (finish_block): Likewise.
        * breakpoint.c (get_catch_sals):  Likewise.
        * mdebugread.c (mylookup_symbol): Likewise.
        * objfiles.c (objfile_relocate): Likewise.
        * printcmd.c (print_frame_args): Likewise.
        * stack.c (print_block_frame_locals): Likewise.
        (print_block_frame_labels): Likewise.
        (print_frame_arg_vars): Likewise.
        * symmisc.c (dump_symtab): Likewise.
        * tracepoint.c (add_local_symbols): Likewise.
        (scope_info): Likewise.

2001-10-12  Daniel Jacobowitz  <drow@@mvista.com>

        * mi-cmd-stack.c (list_args_or_locals): Use ALL_BLOCK_SYMBOLS.

2001-10-12  Daniel Jacobowitz  <drow@@mvista.com>

        * generic/gdbtk-cmds.c (gdb_listfuncs): Use ALL_BLOCK_SYMBOLS.
        * generic/gdbtk-stack.c (gdb_block_vars): Likewise.
        (gdb_get_blocks): Likewise.
        (gdb_get_vars_command): Likewise.
5~
@
text
@d112 2
a113 2
  start = parse_and_eval_address (Tcl_GetStringFromObj (objv[1], NULL));
  end   = parse_and_eval_address (Tcl_GetStringFromObj (objv[2], NULL));
@


1.2
log
@	* generic/gdbtk-stack.c (gdb_stack): Return TCL_ERROR if
	we are unable to get the current frame. get_current_frame
	may have output an error message.
@
text
@d22 1
d97 1
a97 1
  int nsyms, i;
d121 1
a121 2
	  nsyms = BLOCK_NSYMS (block);
	  for (i = 0; i < nsyms; i++)
a122 1
	      sym = BLOCK_SYM (block, i);
d174 1
a174 1
  int nsyms, i, junk;
a185 1
	  nsyms = BLOCK_NSYMS (block);
d187 1
a187 1
	  for (i = 0; i < nsyms; i++)
a188 1
	      sym = BLOCK_SYM (block, i);
d301 1
a301 1
  int i, nsyms, arguments;
d344 1
a344 2
      nsyms = BLOCK_NSYMS (block);
      for (i = 0; i < nsyms; i++)
a345 1
	  sym = BLOCK_SYM (block, i);
@


1.1
log
@	* generic/gdbtk-cmds.c: Put on diet. All breakpoint-,
	tracepoint-, register-, and stack-related functions moved
	into separate files.
	(call_wrapper): Renamed to "gdbtk_call_wrapper" and export.
	Update all callers.
	* generic/gdbtk.h: Move all breakpoint-related stuff into
	gdbtk-bp.c.
	Remove declaration for "call_wrapper". Now in gdbtk-cmds.h
	(and called "gdbtk_call_wrapper").
	* generic/gdbtk-varobj.c: Include "gdbtk-cmds.h".
	* generic/gdbtk-cmds.h: New file.
	* generic/gdbtk-bp.c: New file.
	* generic/gdbtk-register.c: New file.
	* generic/gdbtk-stack.c: New file.
@
text
@d511 1
a511 1
	return TCL_OK;
@

