head	1.136;
access;
symbols
	insight_7_6-2013-04-10-branchpoint:1.130
	gdb_7_6-branch:1.130.0.2
	gdb_7_5-branch:1.128.0.2
	gdb_7_4-branch:1.124.0.2
	gdb_7_3-branch:1.120.0.2
	gdb_7_1-branch:1.115.0.2
	gdb_7_0-branch:1.113.0.2
	arc-sim-20090309:1.98
	arc-insight_6_8-branch:1.98.0.6
	arc-insight_6_8-branchpoint:1.98
	insight_6_8-branch:1.98.0.4
	insight_6_8-branchpoint:1.98
	gdb_6_8-branch:1.98.0.2
	insight_6_6-20070208-release:1.93
	gdb_6_6-branch:1.93.0.2
	gdb_6_6-2006-11-15-branchpoint:1.93
	insight_6_5-20061003-release:1.92
	gdb_6_5-branch:1.92.0.2
	gdb_6_5-2006-05-14-branchpoint:1.92
	gdb-csl-gxxpro-6_3-branch:1.90.0.4
	gdb-csl-gxxpro-6_3-branchpoint:1.90
	gdb_6_4-branch:1.90.0.2
	gdb_6_4-2005-11-01-branchpoint:1.90
	gdb_6_1-2004-04-05-release:1.79
	gdb_6_1-branch:1.79.0.2
	gdb_6_1-2004-03-01-gmt-branchpoint:1.79
	gdb_6_0-2003-10-04-release:1.75.2.1
	gdb_6_0-branch:1.75.0.2
	gdb_6_0-2003-06-23-branchpoint:1.75
	gdb_5_3-2002-12-12-release:1.57.2.1
	gdb_5_3-branch:1.57.0.2
	gdb_5_3-2002-09-04-branchpoint:1.57
	gdb_5_2_1-2002-07-23-release:1.52.2.1
	gdb_5_2-2002-04-29-release:1.52.2.1
	gdb_5_2-branch:1.52.0.2
	gdb_5_2-2002-03-03-branchpoint:1.52
	gdb_5_1_1-2002-01-24-release:1.36
	cygnus_cvs_20020108_pre:1.47
	gdb_5_1_0_1-2002-01-03-branch:1.36.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.36
	gdb_5_1-2001-11-21-release:1.36
	gdb_s390-2001-09-26-branch:1.36.0.6
	gdb_s390-2001-09-26-branchpoint:1.36
	gdb_5_1-2001-07-29-branch:1.36.0.4
	gdb_5_1-2001-07-29-branchpoint:1.36
	dberlin-typesystem-branch:1.36.0.2
	dberlin-typesystem-branchpoint:1.36
	insight-precleanup-2001-01-01:1.16
	gdb_5_0-2000-05-19-release:1.6
	gdb_4_18_2-2000-05-18-release:1.6
	gdb_4_95_1-2000-05-11-snapshot:1.6
	gdb_4_95_0-2000-04-27-snapshot:1.6
	gdb_5_0-2000-04-10-branch:1.6.0.2
	gdb_5_0-2000-04-10-branchpoint:1.6
	repo-unification-2000-02-06:1.1.1.1
	insight-2000-02-04:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.136
date	2013.08.15.14.26.28;	author kseitz;	state Exp;
branches;
next	1.135;

1.135
date	2013.07.30.23.16.43;	author kseitz;	state Exp;
branches;
next	1.134;

1.134
date	2013.07.02.17.07.29;	author kseitz;	state Exp;
branches;
next	1.133;

1.133
date	2013.06.05.20.26.58;	author kseitz;	state Exp;
branches;
next	1.132;

1.132
date	2013.06.05.20.19.46;	author kseitz;	state Exp;
branches;
next	1.131;

1.131
date	2013.04.13.17.01.11;	author kevinb;	state Exp;
branches;
next	1.130;

1.130
date	2012.11.16.21.05.38;	author kseitz;	state Exp;
branches;
next	1.129;

1.129
date	2012.10.10.17.28.03;	author kseitz;	state Exp;
branches;
next	1.128;

1.128
date	2012.08.08.13.50.32;	author rosch;	state Exp;
branches
	1.128.2.1;
next	1.127;

1.127
date	2012.06.25.12.08.57;	author rosch;	state Exp;
branches;
next	1.126;

1.126
date	2012.05.25.11.36.08;	author rosch;	state Exp;
branches;
next	1.125;

1.125
date	2012.03.30.07.18.10;	author rosch;	state Exp;
branches;
next	1.124;

1.124
date	2012.02.28.21.50.50;	author kevinb;	state Exp;
branches;
next	1.123;

1.123
date	2011.12.17.19.30.39;	author kseitz;	state Exp;
branches;
next	1.122;

1.122
date	2011.09.11.16.33.32;	author kseitz;	state Exp;
branches;
next	1.121;

1.121
date	2011.08.01.22.08.20;	author kseitz;	state Exp;
branches;
next	1.120;

1.120
date	2011.04.12.05.11.08;	author kseitz;	state Exp;
branches;
next	1.119;

1.119
date	2011.04.08.23.32.42;	author kseitz;	state Exp;
branches;
next	1.118;

1.118
date	2010.06.18.22.25.26;	author muller;	state Exp;
branches;
next	1.117;

1.117
date	2010.03.12.18.34.12;	author tromey;	state Exp;
branches;
next	1.116;

1.116
date	2010.03.12.14.19.13;	author muller;	state Exp;
branches;
next	1.115;

1.115
date	2010.01.25.19.59.29;	author kseitz;	state Exp;
branches;
next	1.114;

1.114
date	2010.01.04.20.14.46;	author kseitz;	state Exp;
branches;
next	1.113;

1.113
date	2009.07.07.12.38.56;	author muller;	state Exp;
branches;
next	1.112;

1.112
date	2009.06.19.13.49.38;	author palves;	state Exp;
branches;
next	1.111;

1.111
date	2009.05.28.09.22.13;	author muller;	state Exp;
branches;
next	1.110;

1.110
date	2009.05.06.15.52.11;	author muller;	state Exp;
branches;
next	1.109;

1.109
date	2009.04.06.23.33.32;	author muller;	state Exp;
branches;
next	1.108;

1.108
date	2009.04.06.23.11.10;	author muller;	state Exp;
branches;
next	1.107;

1.107
date	2009.03.25.23.43.07;	author muller;	state Exp;
branches;
next	1.106;

1.106
date	2008.12.15.18.06.12;	author kevinb;	state Exp;
branches;
next	1.105;

1.105
date	2008.09.22.18.32.41;	author kseitz;	state Exp;
branches;
next	1.104;

1.104
date	2008.09.18.18.28.45;	author kseitz;	state Exp;
branches;
next	1.103;

1.103
date	2008.09.02.17.29.23;	author kseitz;	state Exp;
branches;
next	1.102;

1.102
date	2008.08.02.22.08.32;	author kseitz;	state Exp;
branches;
next	1.101;

1.101
date	2008.07.14.23.43.36;	author kseitz;	state Exp;
branches;
next	1.100;

1.100
date	2008.05.12.07.24.54;	author muller;	state Exp;
branches;
next	1.99;

1.99
date	2008.04.21.20.14.48;	author kseitz;	state Exp;
branches;
next	1.98;

1.98
date	2008.03.03.23.25.03;	author kseitz;	state Exp;
branches;
next	1.97;

1.97
date	2007.06.21.15.18.51;	author macro;	state Exp;
branches;
next	1.96;

1.96
date	2007.06.05.00.36.29;	author kseitz;	state Exp;
branches;
next	1.95;

1.95
date	2007.04.27.15.39.50;	author macro;	state Exp;
branches;
next	1.94;

1.94
date	2007.03.13.16.29.14;	author kevinb;	state Exp;
branches;
next	1.93;

1.93
date	2006.08.25.16.09.48;	author macro;	state Exp;
branches;
next	1.92;

1.92
date	2006.03.29.13.49.37;	author briand;	state Exp;
branches;
next	1.91;

1.91
date	2005.12.23.18.23.15;	author eliz;	state Exp;
branches;
next	1.90;

1.90
date	2005.06.07.00.36.59;	author kseitz;	state Exp;
branches;
next	1.89;

1.89
date	2005.05.27.01.30.53;	author kseitz;	state Exp;
branches;
next	1.88;

1.88
date	2005.02.17.07.15.50;	author hunt;	state Exp;
branches;
next	1.87;

1.87
date	2005.02.08.01.13.29;	author kseitz;	state Exp;
branches;
next	1.86;

1.86
date	2005.01.18.00.14.39;	author kseitz;	state Exp;
branches;
next	1.85;

1.85
date	2004.12.13.20.42.20;	author bje;	state Exp;
branches;
next	1.84;

1.84
date	2004.11.19.00.19.56;	author kseitz;	state Exp;
branches;
next	1.83;

1.83
date	2004.07.02.22.00.56;	author hunt;	state Exp;
branches;
next	1.82;

1.82
date	2004.06.25.19.44.22;	author cagney;	state Exp;
branches;
next	1.81;

1.81
date	2004.06.15.01.01.44;	author amodra;	state Exp;
branches;
next	1.80;

1.80
date	2004.06.11.18.49.38;	author hunt;	state Exp;
branches;
next	1.79;

1.79
date	2004.01.07.18.35.59;	author jjohnstn;	state Exp;
branches;
next	1.78;

1.78
date	2003.11.25.01.44.06;	author carlton;	state Exp;
branches;
next	1.77;

1.77
date	2003.09.08.19.27.48;	author cagney;	state Exp;
branches;
next	1.76;

1.76
date	2003.06.27.00.29.16;	author kseitz;	state Exp;
branches;
next	1.75;

1.75
date	2003.06.11.23.29.49;	author carlton;	state Exp;
branches
	1.75.2.1;
next	1.74;

1.74
date	2003.05.14.17.43.45;	author ezannoni;	state Exp;
branches;
next	1.73;

1.73
date	2003.04.30.22.01.38;	author cagney;	state Exp;
branches;
next	1.72;

1.72
date	2003.03.06.21.58.41;	author hunt;	state Exp;
branches;
next	1.71;

1.71
date	2003.03.06.21.28.33;	author hunt;	state Exp;
branches;
next	1.70;

1.70
date	2003.03.06.01.25.49;	author hunt;	state Exp;
branches;
next	1.69;

1.69
date	2003.02.25.21.36.22;	author carlton;	state Exp;
branches;
next	1.68;

1.68
date	2003.02.20.17.55.37;	author kseitz;	state Exp;
branches;
next	1.67;

1.67
date	2003.02.20.12.12.33;	author muller;	state Exp;
branches;
next	1.66;

1.66
date	2003.02.11.16.08.38;	author cagney;	state Exp;
branches;
next	1.65;

1.65
date	2002.12.06.16.26.40;	author cagney;	state Exp;
branches;
next	1.64;

1.64
date	2002.12.04.16.21.21;	author kseitz;	state Exp;
branches;
next	1.63;

1.63
date	2002.11.30.17.49.21;	author cagney;	state Exp;
branches;
next	1.62;

1.62
date	2002.11.27.19.09.17;	author hunt;	state Exp;
branches;
next	1.61;

1.61
date	2002.11.27.15.29.53;	author cagney;	state Exp;
branches;
next	1.60;

1.60
date	2002.11.19.19.33.46;	author cagney;	state Exp;
branches;
next	1.59;

1.59
date	2002.11.12.20.24.04;	author cagney;	state Exp;
branches;
next	1.58;

1.58
date	2002.10.10.23.55.36;	author hunt;	state Exp;
branches;
next	1.57;

1.57
date	2002.05.16.01.08.51;	author hunt;	state Exp;
branches
	1.57.2.1;
next	1.56;

1.56
date	2002.04.04.20.38.23;	author drow;	state Exp;
branches;
next	1.55;

1.55
date	2002.04.01.22.29.21;	author kseitz;	state Exp;
branches;
next	1.54;

1.54
date	2002.03.25.16.45.34;	author aoliva;	state Exp;
branches;
next	1.53;

1.53
date	2002.03.06.23.56.02;	author kseitz;	state Exp;
branches;
next	1.52;

1.52
date	2002.02.11.03.21.55;	author drow;	state Exp;
branches
	1.52.2.1;
next	1.51;

1.51
date	2002.02.07.21.56.07;	author hunt;	state Exp;
branches;
next	1.50;

1.50
date	2002.02.07.05.05.06;	author hunt;	state Exp;
branches;
next	1.49;

1.49
date	2002.02.06.03.47.55;	author ezannoni;	state Exp;
branches;
next	1.48;

1.48
date	2002.01.08.20.21.44;	author kseitz;	state Exp;
branches;
next	1.47;

1.47
date	2002.01.05.04.30.45;	author cagney;	state Exp;
branches;
next	1.46;

1.46
date	2001.12.21.22.31.08;	author tromey;	state Exp;
branches;
next	1.45;

1.45
date	2001.12.16.20.50.02;	author cagney;	state Exp;
branches;
next	1.44;

1.44
date	2001.11.19.18.43.18;	author hunt;	state Exp;
branches;
next	1.43;

1.43
date	2001.11.05.19.42.48;	author hunt;	state Exp;
branches;
next	1.42;

1.42
date	2001.10.29.19.37.05;	author hunt;	state Exp;
branches;
next	1.41;

1.41
date	2001.10.17.20.35.32;	author cagney;	state Exp;
branches;
next	1.40;

1.40
date	2001.10.12.23.51.29;	author drow;	state Exp;
branches;
next	1.39;

1.39
date	2001.08.28.22.22.56;	author kseitz;	state Exp;
branches;
next	1.38;

1.38
date	2001.08.20.17.55.31;	author kseitz;	state Exp;
branches;
next	1.37;

1.37
date	2001.07.31.17.34.56;	author ezannoni;	state Exp;
branches;
next	1.36;

1.36
date	2001.05.25.21.06.18;	author kseitz;	state Exp;
branches;
next	1.35;

1.35
date	2001.05.10.18.04.23;	author kseitz;	state Exp;
branches;
next	1.34;

1.34
date	2001.05.06.21.06.35;	author kevinb;	state Exp;
branches;
next	1.33;

1.33
date	2001.04.23.20.28.28;	author kseitz;	state Exp;
branches;
next	1.32;

1.32
date	2001.04.23.20.27.54;	author kseitz;	state Exp;
branches;
next	1.31;

1.31
date	2001.04.19.22.51.02;	author kseitz;	state Exp;
branches;
next	1.30;

1.30
date	2001.04.18.17.43.59;	author tromey;	state Exp;
branches;
next	1.29;

1.29
date	2001.04.18.16.49.38;	author tromey;	state Exp;
branches;
next	1.28;

1.28
date	2001.04.12.19.46.41;	author nsd;	state Exp;
branches;
next	1.27;

1.27
date	2001.04.05.00.04.27;	author hunt;	state Exp;
branches;
next	1.26;

1.26
date	2001.04.02.23.30.26;	author hunt;	state Exp;
branches;
next	1.25;

1.25
date	2001.03.13.23.31.14;	author cagney;	state Exp;
branches;
next	1.24;

1.24
date	2001.03.10.22.56.42;	author hunt;	state Exp;
branches;
next	1.23;

1.23
date	2001.03.01.01.39.22;	author cagney;	state Exp;
branches;
next	1.22;

1.22
date	2001.02.27.22.25.37;	author kseitz;	state Exp;
branches;
next	1.21;

1.21
date	2001.02.14.19.05.58;	author fnasser;	state Exp;
branches;
next	1.20;

1.20
date	2001.02.07.01.11.18;	author fnasser;	state Exp;
branches;
next	1.19;

1.19
date	2001.01.27.00.50.29;	author fnasser;	state Exp;
branches;
next	1.18;

1.18
date	2001.01.25.16.35.05;	author fnasser;	state Exp;
branches;
next	1.17;

1.17
date	2001.01.25.03.01.38;	author fnasser;	state Exp;
branches;
next	1.16;

1.16
date	2000.12.07.22.33.27;	author tromey;	state Exp;
branches;
next	1.15;

1.15
date	2000.11.30.02.56.29;	author tromey;	state Exp;
branches;
next	1.14;

1.14
date	2000.11.30.02.52.45;	author tromey;	state Exp;
branches;
next	1.13;

1.13
date	2000.11.29.00.27.46;	author fnasser;	state Exp;
branches;
next	1.12;

1.12
date	2000.07.25.20.41.07;	author ezannoni;	state Exp;
branches;
next	1.11;

1.11
date	2000.07.11.03.13.26;	author kevinb;	state Exp;
branches;
next	1.10;

1.10
date	2000.07.02.20.07.07;	author kevinb;	state Exp;
branches;
next	1.9;

1.9
date	2000.06.09.16.28.40;	author fnasser;	state Exp;
branches;
next	1.8;

1.8
date	2000.06.08.08.13.20;	author cagney;	state Exp;
branches;
next	1.7;

1.7
date	2000.04.17.20.20.59;	author jlarmour;	state Exp;
branches;
next	1.6;

1.6
date	2000.04.03.21.29.00;	author jimb;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.28.23.04.02;	author jimb;	state Exp;
branches;
next	1.4;

1.4
date	2000.02.29.22.47.37;	author jingham;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.24.03.11.47;	author kseitz;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.23.02.42.40;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.07.00.19.42;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.128.2.1
date	2012.08.29.22.08.47;	author kevinb;	state Exp;
branches;
next	;

1.75.2.1
date	2003.06.27.00.29.02;	author kseitz;	state Exp;
branches;
next	;

1.57.2.1
date	2002.12.10.20.09.12;	author cagney;	state Exp;
branches;
next	;

1.52.2.1
date	2002.03.25.16.46.19;	author aoliva;	state Exp;
branches;
next	;

1.1.1.1
date	2000.02.07.00.19.42;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.136
log
@	* generic/gdbtk-cmds.c (gdb_search): Update for symbol
	searching API update in gdb.
@
text
@/* Tcl/Tk command definitions for Insight.
   Copyright (C) 1994-2013 Free Software Foundation, Inc.

   Written by Stu Grossman <grossman@@cygnus.com> of Cygnus Support.
   Substantially augmented by Martin Hunt, Keith Seitz & Jim Ingham of
   Cygnus Support.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */

#include "defs.h"
#include "inferior.h"
#include "source.h"
#include "symfile.h"
#include "objfiles.h"
#include "gdbcore.h"
#include "demangle.h"
#include "linespec.h"
#include "top.h"
#include "annotate.h"
#include "block.h"
#include "dictionary.h"
#include "filenames.h"
#include "disasm.h"
#include "value.h"
#include "varobj.h"
#include "exceptions.h"
#include "language.h"
#include "target.h"
#include "valprint.h"
#include "regcache.h"
#include "arch-utils.h"
#include "psymtab.h"
#include <ctype.h>

/* tcl header files includes varargs.h unless HAS_STDARG is defined,
   but gdb uses stdarg.h, so make sure HAS_STDARG is defined.  */
#define HAS_STDARG 1

#include <tcl.h>
#include <tk.h>

#include "guitcl.h"
#include "gdbtk.h"
#include "gdbtk-wrapper.h"
#include "gdbtk-cmds.h"

#include <signal.h>
#include <fcntl.h>
#ifdef HAVE_SYS_IOCTL_H
#include <sys/ioctl.h>
#endif
#include <sys/time.h>
#include "gdb_stat.h"

#include "gdb_string.h"
#include "dis-asm.h"
#include "gdbcmd.h"

#ifdef __CYGWIN__
#include <sys/cygwin.h>		/* for cygwin_conv_to_full_win32_path */
#include <cygwin/version.h>
# if CYGWIN_VERSION_DLL_MAKE_COMBINED(CYGWIN_VERSION_API_MAJOR,CYGWIN_VERSION_API_MINOR) >= 181
#   define __USEWIDE
# else
#   define CCP_POSIX_TO_WIN_A 0 
#   define CCP_POSIX_TO_WIN_W 1
#   define CCP_WIN_A_TO_POSIX 2 
#   define CCP_WIN_W_TO_POSIX 3
#   define cygwin_conv_path(op, from, to, size)  \
         (op == CCP_WIN_A_TO_POSIX) ? \
         cygwin_conv_to_full_posix_path (from, to) : \
         cygwin_conv_to_win32_path (from, to)
#   define CW_SET_DOS_FILE_WARNING -1	/* no-op this for older Cygwin */
# endif
#endif

#ifdef _WIN32
#include <windows.h>    /* For gdb_list_processes() */
#include <tlhelp32.h>
#endif

/* Various globals we reference.  */
extern char *source_path;

/* These two objects hold boolean true and false,
   and are shared by all the list objects that gdb_listfuncs
   returns. */

static Tcl_Obj *mangled, *not_mangled;

/* These two control how the GUI behaves when gdb is either tracing or loading.
   They are used in this file & gdbtk_hooks.c */

int No_Update = 0;
int load_in_progress = 0;

/* This Structure is used in gdb_disassemble_driver.
   We need a different sort of line table from the normal one cuz we can't
   depend upon implicit line-end pc's for lines to do the
   reordering in this function.  */

struct my_line_entry
{
  int line;
  CORE_ADDR start_pc;
  CORE_ADDR end_pc;
};

/* Use this to pass the Tcl Text widget command and the open file
   descriptor to the disassembly load command. */

struct disassembly_client_data 
{
  FILE *fp;
  int file_opened_p;
  int widget_line_no;
  Tcl_Interp *interp;
  char *widget;
  Tcl_Obj *result_obj[3];
  const char *asm_argv[14];
  const char *source_argv[7];
  char *map_arr;
  Tcl_DString src_to_line_prefix;
  Tcl_DString pc_to_line_prefix;
  Tcl_DString line_to_pc_prefix;
  Tcl_CmdInfo cmd;
};

/* This variable determines where memory used for disassembly is read
   from.  See note in gdbtk.h for details.  */
/* NOTE: cagney/2003-09-08: This variable is unused.  */
int disassemble_from_exec = -1;

extern int gdb_variable_init (Tcl_Interp * interp);

/*
 * Declarations for routines exported from this file
 */

int Gdbtk_Init (Tcl_Interp * interp);

/*
 * Declarations for routines used only in this file.
 */

static int compare_lines (const PTR, const PTR);
static int comp_files (const void *, const void *);
static int gdb_clear_file (ClientData, Tcl_Interp * interp, int,
			   Tcl_Obj * CONST[]);
static int gdb_cmd (ClientData, Tcl_Interp *, int, Tcl_Obj * CONST[]);
static int gdb_confirm_quit (ClientData, Tcl_Interp *, int,
			     Tcl_Obj * CONST[]);
static int gdb_entry_point (ClientData, Tcl_Interp *, int, Tcl_Obj * CONST[]);
static int gdb_eval (ClientData, Tcl_Interp *, int, Tcl_Obj * CONST[]);
static int gdb_find_file_command (ClientData, Tcl_Interp *, int,
				  Tcl_Obj * CONST objv[]);
static int gdb_force_quit (ClientData, Tcl_Interp *, int, Tcl_Obj * CONST[]);
static int gdb_get_file_command (ClientData, Tcl_Interp *, int,
				 Tcl_Obj * CONST objv[]);
static int gdb_get_function_command (ClientData, Tcl_Interp *, int,
				     Tcl_Obj * CONST objv[]);
static int gdb_get_line_command (ClientData, Tcl_Interp *, int,
				 Tcl_Obj * CONST objv[]);
static int gdb_update_mem (ClientData, Tcl_Interp *, int, Tcl_Obj * CONST[]);
static int gdb_set_mem (ClientData, Tcl_Interp *, int, Tcl_Obj * CONST[]);
static int gdb_immediate_command (ClientData, Tcl_Interp *, int,
				  Tcl_Obj * CONST[]);
static int gdb_incr_addr (ClientData, Tcl_Interp *, int, Tcl_Obj * CONST[]);
static int gdb_CA_to_TAS (ClientData, Tcl_Interp *, int, Tcl_Obj * CONST[]);
static int gdb_listfiles (ClientData, Tcl_Interp *, int, Tcl_Obj * CONST[]);
static int gdb_listfuncs (ClientData, Tcl_Interp *, int, Tcl_Obj * CONST[]);
static int gdb_loadfile (ClientData, Tcl_Interp *, int,
			 Tcl_Obj * CONST objv[]);
static int gdb_load_disassembly (ClientData clientData, Tcl_Interp
				 * interp, int objc, Tcl_Obj * CONST objv[]);
static int gdb_get_inferior_args (ClientData clientData,
				  Tcl_Interp *interp,
				  int objc, Tcl_Obj * CONST objv[]);
static int gdb_set_inferior_args (ClientData clientData,
				  Tcl_Interp *interp,
				  int objc, Tcl_Obj * CONST objv[]);
static int gdb_load_info (ClientData, Tcl_Interp *, int,
			  Tcl_Obj * CONST objv[]);
static int gdb_loc (ClientData, Tcl_Interp *, int, Tcl_Obj * CONST[]);
static int gdb_path_conv (ClientData, Tcl_Interp *, int, Tcl_Obj * CONST[]);
static int gdb_prompt_command (ClientData, Tcl_Interp *, int,
			       Tcl_Obj * CONST objv[]);
static int gdb_restore_fputs (ClientData, Tcl_Interp *, int,
			      Tcl_Obj * CONST[]);
static int gdb_search (ClientData, Tcl_Interp *, int, Tcl_Obj * CONST objv[]);
static int gdb_stop (ClientData, Tcl_Interp *, int, Tcl_Obj * CONST[]);
static int gdb_target_has_execution_command (ClientData,
					     Tcl_Interp *, int,
					     Tcl_Obj * CONST[]);
static void gdbtk_load_source (ClientData clientData,
			       struct symtab *symtab,
			       int start_line, int end_line);
static CORE_ADDR gdbtk_load_asm (ClientData clientData, CORE_ADDR pc,
				 struct disassemble_info *di);
static int gdb_disassemble_driver (CORE_ADDR low, CORE_ADDR high,
				   int mixed_source_and_assembly,
				   ClientData clientData,
				   void (*print_source_fn) (ClientData, struct
							    symtab *, int,
							    int),
				   CORE_ADDR (*print_asm_fn) (ClientData,
							      CORE_ADDR,
							      struct
							      disassemble_info
							      *));
static int perror_with_name_wrapper (PTR args);
static int wrapped_call (PTR opaque_args);
static int hex2bin (const char *hex, char *bin, int count);
static int fromhex (int a);
static int gdb_list_processes (ClientData,
                               Tcl_Interp *,
                               int,
                               Tcl_Obj * CONST[]);



/* Gdbtk_Init
 *    This loads all the Tcl commands into the Tcl interpreter.
 *
 * Arguments:
 *    interp - The interpreter into which to load the commands.
 *
 * Result:
 *     A standard Tcl result.
 */

int
Gdbtk_Init (Tcl_Interp *interp)
{
  Tcl_CreateObjCommand (interp, "gdb_cmd", gdbtk_call_wrapper, gdb_cmd, NULL);
  Tcl_CreateObjCommand (interp, "gdb_immediate", gdbtk_call_wrapper,
			gdb_immediate_command, NULL);
  Tcl_CreateObjCommand (interp, "gdb_loc", gdbtk_call_wrapper, gdb_loc, NULL);
  Tcl_CreateObjCommand (interp, "gdb_path_conv", gdbtk_call_wrapper, gdb_path_conv,
			NULL);
  Tcl_CreateObjCommand (interp, "gdb_listfiles", gdbtk_call_wrapper, gdb_listfiles,
			NULL);
  Tcl_CreateObjCommand (interp, "gdb_listfuncs", gdbtk_call_wrapper, gdb_listfuncs,
			NULL);
  Tcl_CreateObjCommand (interp, "gdb_entry_point", gdbtk_call_wrapper,
			gdb_entry_point, NULL);
  Tcl_CreateObjCommand (interp, "gdb_update_mem", gdbtk_call_wrapper, gdb_update_mem,
			NULL);
  Tcl_CreateObjCommand (interp, "gdb_set_mem", gdbtk_call_wrapper, gdb_set_mem,
			NULL);
  Tcl_CreateObjCommand (interp, "gdb_stop", gdbtk_call_wrapper, gdb_stop, NULL);
  Tcl_CreateObjCommand (interp, "gdb_restore_fputs", gdbtk_call_wrapper, gdb_restore_fputs,
			NULL);
  Tcl_CreateObjCommand (interp, "gdb_eval", gdbtk_call_wrapper, gdb_eval, NULL);
  Tcl_CreateObjCommand (interp, "gdb_incr_addr", gdbtk_call_wrapper, gdb_incr_addr, NULL);
  Tcl_CreateObjCommand (interp, "gdb_CA_to_TAS", gdbtk_call_wrapper, gdb_CA_to_TAS, NULL);
  Tcl_CreateObjCommand (interp, "gdb_clear_file", gdbtk_call_wrapper,
			gdb_clear_file, NULL);
  Tcl_CreateObjCommand (interp, "gdb_confirm_quit", gdbtk_call_wrapper,
			gdb_confirm_quit, NULL);
  Tcl_CreateObjCommand (interp, "gdb_force_quit", gdbtk_call_wrapper,
			gdb_force_quit, NULL);
  Tcl_CreateObjCommand (interp, "gdb_target_has_execution",
			gdbtk_call_wrapper,
			gdb_target_has_execution_command, NULL);
  Tcl_CreateObjCommand (interp, "gdb_load_info", gdbtk_call_wrapper, gdb_load_info,
			NULL);
  Tcl_CreateObjCommand (interp, "gdb_get_function", gdbtk_call_wrapper,
			gdb_get_function_command, NULL);
  Tcl_CreateObjCommand (interp, "gdb_get_line", gdbtk_call_wrapper,
			gdb_get_line_command, NULL);
  Tcl_CreateObjCommand (interp, "gdb_get_file", gdbtk_call_wrapper,
			gdb_get_file_command, NULL);
  Tcl_CreateObjCommand (interp, "gdb_prompt",
			gdbtk_call_wrapper, gdb_prompt_command, NULL);
  Tcl_CreateObjCommand (interp, "gdb_find_file",
			gdbtk_call_wrapper, gdb_find_file_command, NULL);
  Tcl_CreateObjCommand (interp, "gdb_loadfile", gdbtk_call_wrapper, gdb_loadfile,
			NULL);
  Tcl_CreateObjCommand (interp, "gdb_load_disassembly", gdbtk_call_wrapper,
			gdb_load_disassembly,  NULL);
  Tcl_CreateObjCommand (gdbtk_interp, "gdb_search", gdbtk_call_wrapper,
			gdb_search, NULL);
  Tcl_CreateObjCommand (interp, "gdb_get_inferior_args", gdbtk_call_wrapper,
			gdb_get_inferior_args, NULL);
  Tcl_CreateObjCommand (interp, "gdb_set_inferior_args", gdbtk_call_wrapper,
			gdb_set_inferior_args, NULL);
  Tcl_CreateObjCommand (interp, "gdb_list_processes", gdbtk_call_wrapper,
			gdb_list_processes, NULL);

  /* gdb_context is used for debugging multiple threads or tasks */
  Tcl_LinkVar (interp, "gdb_context_id",
	       (char *) &gdb_context,
	       TCL_LINK_INT | TCL_LINK_READ_ONLY);

  /* Make gdb's notion of the pwd visible.  This is read-only because
     (1) it doesn't make sense to change it directly and (2) it is
     allocated using xmalloc and not Tcl_Alloc.  You might think we
     could just use the Tcl `pwd' command.  However, Tcl (erroneously,
     imho) maintains a cache of the current directory name, and
     doesn't provide a way for gdb to invalidate the cache.  */
  Tcl_LinkVar (interp, "gdb_current_directory",
	       (char *) &current_directory,
	       TCL_LINK_STRING | TCL_LINK_READ_ONLY);

  /* Current gdb source file search path.  This is read-only for
     reasons similar to those for gdb_current_directory.  */
  Tcl_LinkVar (interp, "gdb_source_path",
	       (char *) &source_path,
	       TCL_LINK_STRING | TCL_LINK_READ_ONLY);

  /* Init variable interface... */
  if (gdb_variable_init (interp) != TCL_OK)
    return TCL_ERROR;

  /* Init breakpoint module */
  if (Gdbtk_Breakpoint_Init (interp) != TCL_OK)
    return TCL_ERROR;

  /* Init stack module */
  if (Gdbtk_Stack_Init (interp) != TCL_OK)
    return TCL_ERROR;

  /* Init register module */
  if (Gdbtk_Register_Init (interp) != TCL_OK)
    return TCL_ERROR;

  /* Determine where to disassemble from */
  Tcl_LinkVar (gdbtk_interp, "disassemble-from-exec",
	       (char *) &disassemble_from_exec,
	       TCL_LINK_INT);

  Tcl_PkgProvide (interp, "Gdbtk", GDBTK_VERSION);
  return TCL_OK;
}

/* This routine acts as a top-level for all GDB code called by Tcl/Tk.  It
   handles cleanups, and uses catch_errors to trap calls to return_to_top_level
   (usually via error).
   This is necessary in order to prevent a longjmp out of the bowels of Tk,
   possibly leaving things in a bad state.  Since this routine can be called
   recursively, it needs to save and restore the contents of the result_ptr as
   necessary. */

int
gdbtk_call_wrapper (ClientData clientData, Tcl_Interp *interp,
		    int objc, Tcl_Obj *CONST objv[])
{
  struct wrapped_call_args wrapped_args;
  gdbtk_result new_result, *old_result_ptr;
  int wrapped_returned_error = 0;

  old_result_ptr = result_ptr;
  result_ptr = &new_result;
  result_ptr->obj_ptr = Tcl_NewObj ();
  result_ptr->flags = GDBTK_TO_RESULT;

  wrapped_args.func = (Tcl_ObjCmdProc *) clientData;
  wrapped_args.interp = interp;
  wrapped_args.objc = objc;
  wrapped_args.objv = objv;
  wrapped_args.val = TCL_OK;

  if (!catch_errors (wrapped_call, &wrapped_args, "", RETURN_MASK_ALL))
    {

      wrapped_args.val = TCL_ERROR;	/* Flag an error for TCL */

      /* Make sure the timer interrupts are turned off.  */
      gdbtk_stop_timer ();

      gdb_flush (gdb_stderr);	/* Flush error output */
      gdb_flush (gdb_stdout);	/* Sometimes error output comes here as well */

      /* If we errored out here, and the results were going to the
         console, then gdbtk_fputs will have gathered the result into the
         result_ptr.  We also need to echo them out to the console here */

      gdb_flush (gdb_stderr);	/* Flush error output */
      gdb_flush (gdb_stdout);	/* Sometimes error output comes here as well */

      /* In case of an error, we may need to force the GUI into idle
         mode because gdbtk_call_command may have bombed out while in
         the command routine.  */

      running_now = 0;
      Tcl_Eval (interp, "gdbtk_tcl_idle");

    }
  else
    {
      /* If the wrapped call returned an error directly, then we don't
	 want to reset the result.  */
      wrapped_returned_error = wrapped_args.val == TCL_ERROR;
    }

  /* do not suppress any errors -- a remote target could have errored */
  load_in_progress = 0;

  /*
   * Now copy the result over to the true Tcl result.  If
   * GDBTK_TO_RESULT flag bit is set, this just copies a null object
   * over to the Tcl result, which is fine because we should reset the
   * result in this case anyway.  If the wrapped command returned an
   * error, then we assume that the result is already set correctly.
   */
  if ((result_ptr->flags & GDBTK_IN_TCL_RESULT) || wrapped_returned_error)
    {
      Tcl_DecrRefCount (result_ptr->obj_ptr);
    }
  else
    {
      Tcl_SetObjResult (interp, result_ptr->obj_ptr);
    }

  result_ptr = old_result_ptr;

#ifdef _WIN32
  close_bfds ();
#endif

  return wrapped_args.val;
}

/*
 * This is the wrapper that is passed to catch_errors.
 */

static int
wrapped_call (PTR opaque_args)
{
  struct wrapped_call_args *args = (struct wrapped_call_args *) opaque_args;
  args->val = (*args->func) (args->func, args->interp, args->objc, args->objv);
  return 1;
}


/*
 * This section contains the commands that control execution.
 */

/* This implements the tcl command gdb_clear_file.

* Prepare to accept a new executable file.  This is called when we
* want to clear away everything we know about the old file, without
* asking the user.  The Tcl code will have already asked the user if
* necessary.  After this is called, we should be able to run the
* `file' command without getting any questions.  
*
* Arguments:
*    None
* Tcl Result:
*    None
*/

static int
gdb_clear_file (ClientData clientData, Tcl_Interp *interp,
		int objc, Tcl_Obj *CONST objv[])
{
  if (objc != 1)
    {
      Tcl_WrongNumArgs (interp, 1, objv, NULL);
      return TCL_ERROR;
    }

  if (! ptid_equal (inferior_ptid, null_ptid) && target_has_execution)
    {
      struct inferior *inf = current_inferior ();
      if (inf->attach_flag)
	target_detach (NULL, 0);
      else
	target_kill ();
    }

  delete_command (NULL, 0);
  exec_file_clear (0);
  symbol_file_clear (0);

  return TCL_OK;
}

/* This implements the tcl command gdb_confirm_quit
 * Ask the user to confirm an exit request.
 *
 * Arguments:
 *    None
 * Tcl Result:
 *    A boolean, 1 if the user answered yes, 0 if no.
 */

static int
gdb_confirm_quit (ClientData clientData, Tcl_Interp *interp,
		  int objc, Tcl_Obj *CONST objv[])
{
  int ret;

  if (objc != 1)
    {
      Tcl_WrongNumArgs (interp, 1, objv, NULL);
      return TCL_ERROR;
    }

  ret = quit_confirm ();
  Tcl_SetBooleanObj (result_ptr->obj_ptr, ret);
  return TCL_OK;
}

/* This implements the tcl command gdb_force_quit
 * Quit without asking for confirmation.
 *
 * Arguments:
 *    None
 * Tcl Result:
 *    None
 */

static int
gdb_force_quit (ClientData clientData, Tcl_Interp *interp,
		int objc, Tcl_Obj *CONST objv[])
{
  if (objc != 1)
    {
      Tcl_WrongNumArgs (interp, 1, objv, NULL);
      return TCL_ERROR;
    }

  quit_force ((char *) NULL, 1);
  return TCL_OK;
}

/* Pressing the stop button on the source window should attempt to
 * stop the target. If, after some short time, this fails, a dialog
 * should appear allowing the user to detach.
 *
 * The global GDBTK_FORCE_DETACH is set when we wish to detach from a
 * target. This value is returned by deprecated_ui_loop_hook
 * (x_event), indicating to callers that they should detach.
 *
 * Read the comments before x_event to find out how we (try) to keep
 * gdbtk alive while some other event loop has stolen control from us.
 */

/*
 * This command implements the tcl command gdb_stop, which
 * is used to either stop the target or detach.
 * Note that it is assumed that a simulator or native target
 * can ALWAYS be stopped. Doing a "detach" on them has no effect.
 * 
 * Arguments:
 *    None or "detach"
 * Tcl Result:
 *    None
 */

static int
gdb_stop (ClientData clientData, Tcl_Interp *interp,
	  int objc, Tcl_Obj *CONST objv[])
{
  int force = 0;
  char *s;

  if (objc > 1)
    {
      s = Tcl_GetStringFromObj (objv[1], NULL);
      if (strcmp (s, "detach") == 0)
	force = 1;
    }

  if (force)
    {
      /* Set the "forcibly detach from target" flag. x_event will
         return this value to callers when they should forcibly detach. */
      gdbtk_force_detach = 1;
    }
  else
    {
      if (target_ignore != (void (*) (void)) current_target.to_stop)
	target_stop (gdbtk_get_ptid ());
      else
	set_quit_flag ();		/* hope something sees this */
    }

  return TCL_OK;
}

/*
 * This command lists all processes in a system. Yet only implemented
 * for windows as the *nix part is handled directly from tcl code.
 *
 * Arguments:
 *    None
 * Tcl Result:
 *    A list of 2 elemented lists containing all running processes 
 *    and their pids.
 */
 
static int 
gdb_list_processes (ClientData clientData, Tcl_Interp *interp, 
                    int objc, Tcl_Obj * CONST objv[])
{
  if (objc != 1)
    {
      Tcl_WrongNumArgs (interp, 1, objv, NULL);
      return TCL_ERROR;
    }

  Tcl_SetListObj (result_ptr->obj_ptr, 0, NULL);

  #ifdef _WIN32
    {
      HANDLE processSnap = CreateToolhelp32Snapshot (TH32CS_SNAPPROCESS, 0);
      if (processSnap != INVALID_HANDLE_VALUE)
        {
          PROCESSENTRY32 processEntry;
 
          processEntry.dwSize = sizeof(PROCESSENTRY32);
 
          if (Process32First (processSnap, &processEntry))
            {
              do
                {
                  Tcl_Obj *pidProc[2];
                  pidProc[0] = Tcl_NewIntObj (processEntry.th32ProcessID);
                  pidProc[1] = Tcl_NewStringObj (processEntry.szExeFile, -1);

                  Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr,
                    Tcl_NewListObj (2, pidProc));

                } while(Process32Next (processSnap, &processEntry));
            }

          CloseHandle (processSnap);
        }
    }
  #endif

  return TCL_OK;
}



/*
 * This section contains Tcl commands that are wrappers for invoking
 * the GDB command interpreter.
 */


/* This implements the tcl command `gdb_eval'.
 * It uses the gdb evaluator to return the value of
 * an expression in the current language
 *
 * Tcl Arguments:
 *     expression - the expression to evaluate.
 *     format - optional format character.  Valid chars are:
 *	o - octal
 *	x - hex
 *	d - decimal
 *	u - unsigned decimal
 *	t - binary
 *	f - float
 *	a - address
 *	c - char
 * Tcl Result:
 *     The result of the evaluation.
 */

static int
gdb_eval (ClientData clientData, Tcl_Interp *interp,
	  int objc, Tcl_Obj *CONST objv[])
{
  struct expression *expr;
  struct cleanup *old_chain = NULL;
  int format = 0;
  value_ptr val;
  struct ui_file *stb;
  long dummy;
  char *result;
  struct value_print_options opts;

  if (objc != 2 && objc != 3)
    {
      Tcl_WrongNumArgs (interp, 1, objv, "expression [format]");
      return TCL_ERROR;
    }

  if (objc == 3)
    format = *(Tcl_GetStringFromObj (objv[2], NULL));

  get_formatted_print_options (&opts, format);

  expr = parse_expression (Tcl_GetStringFromObj (objv[1], NULL));
  old_chain = make_cleanup (free_current_contents, &expr);
  val = evaluate_expression (expr);

  /* "Print" the result of the expression evaluation. */
  stb = mem_fileopen ();
  make_cleanup_ui_file_delete (stb);
  common_val_print (val, stb, 0, &opts, current_language);
  result = ui_file_xstrdup (stb, &dummy);
  Tcl_SetObjResult (interp, Tcl_NewStringObj (result, -1));
  xfree (result);
  result_ptr->flags |= GDBTK_IN_TCL_RESULT;

  do_cleanups (old_chain);
  return TCL_OK;
}

/* This implements the tcl command "gdb_cmd".

* It sends its argument to the GDB command scanner for execution. 
* This command will never cause the update, idle and busy hooks to be called
* within the GUI.
* 
* Tcl Arguments:
*    command - The GDB command to execute
*    from_tty - 1 indicates this comes to the console.
*               Pass this to the gdb command.
* Tcl Result:
*    The output from the gdb command (except for the "load" & "while"
*    which dump their output to the console.
*/

static int
gdb_cmd (ClientData clientData, Tcl_Interp *interp,
	 int objc, Tcl_Obj *CONST objv[])
{
  int from_tty = 0;

  if (objc < 2 || objc > 3)
    {
      Tcl_WrongNumArgs (interp, 1, objv, "command ?from_tty?");
      return TCL_ERROR;
    }

  if (objc == 3)
    {
      if (Tcl_GetBooleanFromObj (NULL, objv[2], &from_tty) != TCL_OK)
	{
	  gdbtk_set_result (interp, "from_tty must be a boolean.");
	  return TCL_ERROR;
	}
    }

  if (running_now || load_in_progress)
    return TCL_OK;

  No_Update = 1;

  /* for the load instruction (and possibly others later) we
     set turn off the GDBTK_TO_RESULT flag bit so gdbtk_fputs() 
     will not buffer all the data until the command is finished. */

  if ((strncmp ("load ", Tcl_GetStringFromObj (objv[1], NULL), 5) == 0))
    {
      result_ptr->flags &= ~GDBTK_TO_RESULT;
      load_in_progress = 1;
    }

  execute_command (Tcl_GetStringFromObj (objv[1], NULL), from_tty);

  if (load_in_progress)
    {
      load_in_progress = 0;
      result_ptr->flags |= GDBTK_TO_RESULT;
    }

  bpstat_do_actions ();

  return TCL_OK;
}

/*
 * This implements the tcl command "gdb_immediate"
 *  
 * It does exactly the same thing as gdb_cmd, except NONE of its outut 
 * is buffered.  This will also ALWAYS cause the busy, update, and idle 
 * hooks to be called, contrasted with gdb_cmd, which NEVER calls them.
 * It turns off the GDBTK_TO_RESULT flag, which diverts the result
 * to the console window.
 *
 * Tcl Arguments:
 *    command - The GDB command to execute
 *    from_tty - 1 to indicate this is from the console.
 * Tcl Result:
 *    None.
 */

static int
gdb_immediate_command (ClientData clientData, Tcl_Interp *interp,
		       int objc, Tcl_Obj *CONST objv[])
{
  int from_tty = 0;

  if (objc < 2 || objc > 3)
    {
      Tcl_WrongNumArgs (interp, 1, objv, "command ?from_tty?");
      return TCL_ERROR;
    }

  if (objc == 3)
    {
      if (Tcl_GetBooleanFromObj (NULL, objv[2], &from_tty) != TCL_OK)
	{
	  gdbtk_set_result (interp, "from_tty must be a boolean.");
	  return TCL_ERROR;
	}
    }

  if (running_now || load_in_progress)
    return TCL_OK;

  No_Update = 0;

  result_ptr->flags &= ~GDBTK_TO_RESULT;

  execute_command (Tcl_GetStringFromObj (objv[1], NULL), from_tty);

  bpstat_do_actions ();

  result_ptr->flags |= GDBTK_TO_RESULT;

  return TCL_OK;
}

/* This implements the tcl command "gdb_prompt"

* It returns the gdb interpreter's prompt.
*
* Tcl Arguments:
*    None.
* Tcl Result:
*    The prompt.
*/

static int
gdb_prompt_command (ClientData clientData, Tcl_Interp *interp,
		    int objc, Tcl_Obj *CONST objv[])
{
  Tcl_SetStringObj (result_ptr->obj_ptr, get_prompt (), -1);
  return TCL_OK;
}


/*
 * This section contains general informational commands.
 */

/* This implements the tcl command "gdb_target_has_execution"

* Tells whether the target is executing.
*
* Tcl Arguments:
*    None
* Tcl Result:
*    A boolean indicating whether the target is executing.
*/

static int
gdb_target_has_execution_command (ClientData clientData, Tcl_Interp *interp,
				  int objc, Tcl_Obj *CONST objv[])
{
  int result = 0;

  if (target_has_execution && ! ptid_equal (inferior_ptid, null_ptid))
    result = 1;

  Tcl_SetBooleanObj (result_ptr->obj_ptr, result);
  return TCL_OK;
}

/* This implements the tcl command "gdb_get_inferior_args"

* Returns inferior command line arguments as a string
*
* Tcl Arguments:
*    None
* Tcl Result:
*    A string containing the inferior command line arguments
*/

static int
gdb_get_inferior_args (ClientData clientData, Tcl_Interp *interp,
		       int objc, Tcl_Obj *CONST objv[])
{
  if (objc != 1)
    {
      Tcl_WrongNumArgs (interp, 1, objv, NULL);
      return TCL_ERROR;
    }

  Tcl_SetStringObj (result_ptr->obj_ptr, get_inferior_args (), -1);
  return TCL_OK;
}

/* This implements the tcl command "gdb_set_inferior_args"

* Sets inferior command line arguments
*
* Tcl Arguments:
*    A string containing the inferior command line arguments
* Tcl Result:
*    None
*/

static int
gdb_set_inferior_args (ClientData clientData, Tcl_Interp *interp,
		       int objc, Tcl_Obj *CONST objv[])
{
  char *args;

  if (objc != 2)
    {
      Tcl_WrongNumArgs (interp, 1, objv, "argument");
      return TCL_ERROR;
    }

  args = Tcl_GetStringFromObj (objv[1], NULL);
  set_inferior_args (args);

  return TCL_OK;
}

/* This implements the tcl command "gdb_load_info"

* It returns information about the file about to be downloaded.
*
* Tcl Arguments:
*    filename: The file to open & get the info on.
* Tcl Result:
*    A list consisting of the name and size of each section.
*/

static int
gdb_load_info (ClientData clientData, Tcl_Interp *interp,
	       int objc, Tcl_Obj *CONST objv[])
{
  bfd *loadfile_bfd;
  struct cleanup *old_cleanups;
  asection *s;
  Tcl_Obj *ob[2];

  char *filename = Tcl_GetStringFromObj (objv[1], NULL);

  loadfile_bfd = bfd_openr (filename, gnutarget);
  if (loadfile_bfd == NULL)
    {
      gdbtk_set_result (interp, "Open of %s failed", filename);
      return TCL_ERROR;
    }
  old_cleanups = make_cleanup_bfd_unref (loadfile_bfd);

  if (!bfd_check_format (loadfile_bfd, bfd_object))
    {
      do_cleanups (old_cleanups);
      gdbtk_set_result (interp, "Bad Object File");
      return TCL_ERROR;
    }

  Tcl_SetListObj (result_ptr->obj_ptr, 0, NULL);

  for (s = loadfile_bfd->sections; s; s = s->next)
    {
      if (s->flags & SEC_LOAD)
	{
	  bfd_size_type size = bfd_get_section_size (s);
	  if (size > 0)
	    {
	      ob[0] = Tcl_NewStringObj ((char *)
					bfd_get_section_name (loadfile_bfd, s),
					-1);
	      ob[1] = Tcl_NewLongObj ((long) size);
	      Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr,
					Tcl_NewListObj (2, ob));
	    }
	}
    }

  do_cleanups (old_cleanups);
  return TCL_OK;
}


/* This implements the tcl command "gdb_get_line"

* It returns the linenumber for a given linespec.  It will take any spec
* that can be passed to decode_line_1
*
* Tcl Arguments:
*    linespec - the line specification
* Tcl Result:
*    The line number for that spec.
*/
static int
gdb_get_line_command (ClientData clientData, Tcl_Interp *interp,
		      int objc, Tcl_Obj *CONST objv[])
{
  struct symtabs_and_lines sals;
  char *args;

  if (objc != 2)
    {
      Tcl_WrongNumArgs (interp, 1, objv, "linespec");
      return TCL_ERROR;
    }

  args = Tcl_GetStringFromObj (objv[1], NULL);
  sals = decode_line_1 (&args, DECODE_LINE_FUNFIRSTLINE, NULL, 0);
  if (sals.nelts == 1)
    {
      Tcl_SetIntObj (result_ptr->obj_ptr, sals.sals[0].line);
      return TCL_OK;
    }

  Tcl_SetStringObj (result_ptr->obj_ptr, "N/A", -1);
  return TCL_OK;

}

/* This implements the tcl command "gdb_get_file"

* It returns the file containing a given line spec.
*
* Tcl Arguments:
*    linespec - The linespec to look up
* Tcl Result:
*    The file containing it.
*/

static int
gdb_get_file_command (ClientData clientData, Tcl_Interp *interp,
		      int objc, Tcl_Obj *CONST objv[])
{
  struct symtabs_and_lines sals;
  char *args;

  if (objc != 2)
    {
      Tcl_WrongNumArgs (interp, 1, objv, "linespec");
      return TCL_ERROR;
    }

  args = Tcl_GetStringFromObj (objv[1], NULL);
  sals = decode_line_1 (&args, DECODE_LINE_FUNFIRSTLINE, NULL, 0);
  if (sals.nelts == 1)
    {
      Tcl_SetStringObj (result_ptr->obj_ptr,
			sals.sals[0].symtab->filename, -1);
      return TCL_OK;
    }

  Tcl_SetStringObj (result_ptr->obj_ptr, "N/A", -1);
  return TCL_OK;
}

/* This implements the tcl command "gdb_get_function"

* It finds the function containing the given line spec.
*
* Tcl Arguments:
*    linespec - The line specification
* Tcl Result:
*    The function that contains it, or "N/A" if it is not in a function.
*/
static int
gdb_get_function_command (ClientData clientData, Tcl_Interp *interp,
			  int objc, Tcl_Obj *CONST objv[])
{
  const char *function;
  struct symtabs_and_lines sals;
  char *args;

  if (objc != 2)
    {
      Tcl_WrongNumArgs (interp, 1, objv, "linespec");
      return TCL_ERROR;
    }

  args = Tcl_GetStringFromObj (objv[1], NULL);
  sals = decode_line_1 (&args, DECODE_LINE_FUNFIRSTLINE, NULL, 0);
  if (sals.nelts == 1)
    {
      resolve_sal_pc (&sals.sals[0]);
      function = pc_function_name (sals.sals[0].pc);
      Tcl_SetStringObj (result_ptr->obj_ptr, function, -1);
      return TCL_OK;
    }

  Tcl_SetStringObj (result_ptr->obj_ptr, "N/A", -1);
  return TCL_OK;
}

/* This implements the tcl command "gdb_find_file"

* It searches the symbol tables to get the full pathname to a file.
*
* Tcl Arguments:
*    filename: the file name to search for.
* Tcl Result:
*    The full path to the file, an empty string if the file was not
*    available or an error message if the file is not found in the symtab.
*/

static int
gdb_find_file_command (ClientData clientData, Tcl_Interp *interp,
		       int objc, Tcl_Obj *CONST objv[])
{
  struct symtab *st;
  char *filename, *fullname = NULL;

  if (objc != 2)
    {
      Tcl_WrongNumArgs (interp, 1, objv, "filename");
      return TCL_ERROR;
    }

  filename = Tcl_GetStringFromObj (objv[1], NULL);

  /* Shortcut: There seems to be some mess in gdb dealing with
     files. While we should let gdb sort it out, it doesn't hurt
     to be a little defensive here.

     If the filename is already an absolute filename, just try
     to stat it. If it's not found, then ask gdb to find it for us. */
  if (IS_ABSOLUTE_PATH (filename))
    {
      struct stat st;
      const int status = stat (filename, &st);

      if (status == 0)
	{
	  if (S_ISREG (st.st_mode))
	    fullname = filename;
	}
    }
  else
    {
      /* Ask gdb to find the file for us. */
      st = lookup_symtab (filename);

      /* We should always get a symtab. */
      if (!st)
	{
	  gdbtk_set_result (interp, "File not found in symtab (2)");
	  return TCL_ERROR;
	}

      fullname =
	(st->fullname == NULL ? symtab_to_filename (st) : st->fullname);
    }
  
  /* We may not be able to open the file (not available). */
  if (fullname == NULL)
    {
      Tcl_SetStringObj (result_ptr->obj_ptr, "", -1);
      return TCL_OK;
    }

  Tcl_SetStringObj (result_ptr->obj_ptr, fullname, -1);

  return TCL_OK;
}

/* An object of this type is passed to do_listfiles.  */

struct listfiles_info
{
  int *numfilesp;
  int *files_sizep;
  const char ***filesp;
  int len;
  const char *pathname;
};

/* This is a helper function for gdb_listfiles that is used via
   map_partial_symbol_filenames.  */

static void
do_listfiles (const char *filename, const char *fullname, void *data)
{
  struct listfiles_info *info = data;

  if (*info->numfilesp == *info->files_sizep)
    {
      *info->files_sizep *= 2;
      *info->filesp = xrealloc (*info->filesp,
				*info->files_sizep * sizeof (char *));
    }

  if (filename)
    {
      if (!info->len || !strncmp (info->pathname, filename, info->len)
	  || !strcmp (filename, lbasename (filename)))
	{
	  (*info->filesp)[(*info->numfilesp)++] = lbasename (filename);
	}
    }
}

/* This implements the tcl command "gdb_listfiles"

* This lists all the files in the current executible.
*
* Note that this currently pulls in all sorts of filenames
* that aren't really part of the executable.  It would be
* best if we could check each file to see if it actually
* contains executable lines of code, but we can't do that
* with psymtabs.
*
* Arguments:
*    ?pathname? - If provided, only files which match pathname
*        (up to strlen(pathname)) are included. THIS DOES NOT
*        CURRENTLY WORK BECAUSE PARTIAL_SYMTABS DON'T SUPPLY
*        THE FULL PATHNAME!!!
*
* Tcl Result:
*    A list of all matching files.
*/
static int
gdb_listfiles (ClientData clientData, Tcl_Interp *interp,
	       int objc, Tcl_Obj *CONST objv[])
{
  struct objfile *objfile;
  struct partial_symtab *psymtab;
  struct symtab *symtab;
  const char *lastfile, *pathname = NULL;
  const char **files;
  int files_size;
  int i, numfiles = 0, len = 0;
  struct listfiles_info info;

  files_size = 1000;
  files = (const char **) xmalloc (sizeof (char *) * files_size);

  if (objc > 2)
    {
      Tcl_WrongNumArgs (interp, 1, objv, "?pathname?");
      return TCL_ERROR;
    }
  else if (objc == 2)
    pathname = Tcl_GetStringFromObj (objv[1], &len);

  info.numfilesp = &numfiles;
  info.files_sizep = &files_size;
  info.filesp = &files;
  info.len = len;
  info.pathname = pathname;
  map_partial_symbol_filenames (do_listfiles, &info, 0);

  ALL_SYMTABS (objfile, symtab)
    {
      if (numfiles == files_size)
	{
	  files_size = files_size * 2;
	  files = (const char **) xrealloc (files, sizeof (char *) * files_size);
	}
      if (symtab->filename && symtab->linetable && symtab->linetable->nitems)
	{
	  if (!len || !strncmp (pathname, symtab->filename, len)
	      || !strcmp (symtab->filename, lbasename (symtab->filename)))
	    {
	      files[numfiles++] = lbasename (symtab->filename);
	    }
	}
    }

  qsort (files, numfiles, sizeof (char *), comp_files);

  lastfile = "";

  /* Discard the old result pointer, in case it has accumulated anything
     and set it to a new list object */

  Tcl_SetListObj (result_ptr->obj_ptr, 0, NULL);

  for (i = 0; i < numfiles; i++)
    {
      if (strcmp (files[i], lastfile))
	Tcl_ListObjAppendElement (interp, result_ptr->obj_ptr,
				  Tcl_NewStringObj (files[i], -1));
      lastfile = files[i];
    }

  free (files);
  return TCL_OK;
}

static int
comp_files (const void *file1, const void *file2)
{
  return strcmp (*(char **) file1, *(char **) file2);
}


/* This implements the tcl command "gdb_search"


* Tcl Arguments:
*    option - One of "functions", "variables" or "types"
*    regexp - The regular expression to look for.
* Then, optionally:
*    -files fileList
*    -static 1/0
*    -filename 1/0
* Tcl Result:
*    A list of all the matches found.  Optionally, if -filename is set to 1,
*    then the output is a list of two element lists, with the symbol first,
*    and the file in which it is found second.
*/

static int
gdb_search (ClientData clientData, Tcl_Interp *interp,
	    int objc, Tcl_Obj *CONST objv[])
{
  struct symbol_search *ss = NULL;
  struct symbol_search *p;
  struct cleanup *old_chain = NULL;
  Tcl_Obj *CONST * switch_objv;
  int index, switch_objc, i, show_files = 0;
  domain_enum space = 0;
  char *regexp;
  int static_only, nfiles;
  Tcl_Obj **file_list;
  char **files;
  static const char *search_options[] =
    {"functions", "variables", "types", (char *) NULL};
  static const char *switches[] =
    {"-files", "-filename", "-static", (char *) NULL};
  enum search_opts
    {
      SEARCH_FUNCTIONS, SEARCH_VARIABLES, SEARCH_TYPES
    };
  enum switches_opts
    {
      SWITCH_FILES, SWITCH_FILENAME, SWITCH_STATIC_ONLY
    };

  if (objc < 3)
    {
      Tcl_WrongNumArgs (interp, 1, objv, "option regexp ?arg ...?");
      return TCL_ERROR;
    }

  if (Tcl_GetIndexFromObj (interp, objv[1], search_options, "option", 0,
			   &index) != TCL_OK)
    {
      result_ptr->flags |= GDBTK_IN_TCL_RESULT;
      return TCL_ERROR;
    }

  /* Unfortunately, we cannot teach search_symbols to search on
     multiple regexps, so we have to do a two-tier search for
     any searches which choose to narrow the playing field. */
  switch ((enum search_opts) index)
    {
    case SEARCH_FUNCTIONS:
      space = FUNCTIONS_DOMAIN;
      break;
    case SEARCH_VARIABLES:
      space = VARIABLES_DOMAIN;
      break;
    case SEARCH_TYPES:
      space = TYPES_DOMAIN;
      break;
    }

  regexp = Tcl_GetStringFromObj (objv[2], NULL);
  /* Process any switches that refine the search */
  switch_objc = objc - 3;
  switch_objv = objv + 3;

  static_only = 0;
  nfiles = 0;
  files = (char **) NULL;
  while (switch_objc > 0)
    {
      if (Tcl_GetIndexFromObj (interp, switch_objv[0], switches,
			       "option", 0, &index) != TCL_OK)
	{
	  result_ptr->flags |= GDBTK_IN_TCL_RESULT;
	  return TCL_ERROR;
	}

      switch ((enum switches_opts) index)
	{
	case SWITCH_FILENAME:
	  {
	    if (switch_objc < 2)
	      {
		Tcl_WrongNumArgs (interp, 3, objv,
				  "?-files fileList  -filename 1|0 -static 1|0?");
		result_ptr->flags |= GDBTK_IN_TCL_RESULT;
		return TCL_ERROR;
	      }
	    if (Tcl_GetBooleanFromObj (interp, switch_objv[1], &show_files)
		!= TCL_OK)
	      {
		result_ptr->flags |= GDBTK_IN_TCL_RESULT;
		return TCL_ERROR;
	      }
	    switch_objc--;
	    switch_objv++;
	  }
	  break;
	case SWITCH_FILES:
	  {
	    int result;
	    if (switch_objc < 2)
	      {
		Tcl_WrongNumArgs (interp, 3, objv,
				  "?-files fileList  -filename 1|0 -static 1|0?");
		result_ptr->flags |= GDBTK_IN_TCL_RESULT;
		return TCL_ERROR;
	      }
	    result = Tcl_ListObjGetElements (interp, switch_objv[1],
					     &nfiles, &file_list);
	    if (result != TCL_OK)
	      return result;

	    files = (char **) xmalloc (nfiles * sizeof (char *));
	    for (i = 0; i < nfiles; i++)
	      files[i] = Tcl_GetStringFromObj (file_list[i], NULL);
	    switch_objc--;
	    switch_objv++;
	  }
	  break;
	case SWITCH_STATIC_ONLY:
	  if (switch_objc < 2)
	    {
	      Tcl_WrongNumArgs (interp, 3, objv,
				"?-files fileList  -filename 1|0 -static 1|0?");
	      result_ptr->flags |= GDBTK_IN_TCL_RESULT;
	      return TCL_ERROR;
	    }
	  if (Tcl_GetBooleanFromObj (interp, switch_objv[1], &static_only)
	      != TCL_OK)
	    {
	      result_ptr->flags |= GDBTK_IN_TCL_RESULT;
	      return TCL_ERROR;
	    }
	  switch_objc--;
	  switch_objv++;
	}
      switch_objc--;
      switch_objv++;
    }

  search_symbols (regexp, space, nfiles, files, &ss);
  if (ss != NULL)
    old_chain = make_cleanup_free_search_symbols (&ss);

  Tcl_SetListObj (result_ptr->obj_ptr, 0, NULL);

  for (p = ss; p != NULL; p = p->next)
    {
      Tcl_Obj *elem;

      if (static_only && p->block != STATIC_BLOCK)
	continue;

      /* Strip off some C++ special symbols, like RTTI and global
         constructors/destructors. */
      if ((p->symbol != NULL
	   && strncmp (SYMBOL_LINKAGE_NAME (p->symbol), "__tf", 4) != 0
	   && strncmp (SYMBOL_LINKAGE_NAME (p->symbol), "_GLOBAL_", 8) != 0)
	  || p->msymbol.minsym != NULL)
	{
	  elem = Tcl_NewListObj (0, NULL);

	  if (p->msymbol.minsym == NULL)
	    Tcl_ListObjAppendElement (interp, elem,
				      Tcl_NewStringObj (SYMBOL_PRINT_NAME (p->symbol), -1));
	  else
	    Tcl_ListObjAppendElement (interp, elem,
				      Tcl_NewStringObj (SYMBOL_PRINT_NAME (p->msymbol.minsym), -1));

	  if (show_files)
	    {
	      if ((p->symtab != NULL) && (p->symtab->filename != NULL))
		{
		  Tcl_ListObjAppendElement (interp, elem, Tcl_NewStringObj
					    (p->symtab->filename, -1));
		}
	      else
		{
		  Tcl_ListObjAppendElement (interp, elem,
					    Tcl_NewStringObj ("", 0));
		}
	    }

	  Tcl_ListObjAppendElement (interp, result_ptr->obj_ptr, elem);
	}
    }

  if (ss != NULL)
    do_cleanups (old_chain);

  return TCL_OK;
}

/* This implements the tcl command gdb_listfuncs

* It lists all the functions defined in a given file
* 
* Arguments:
*    file - the file to look in
* Tcl Result:
*    A list of two element lists, the first element is
*    the symbol name, and the second is a boolean indicating
*    whether the symbol is demangled (1 for yes).
*/

static int
gdb_listfuncs (ClientData clientData, Tcl_Interp *interp,
	       int objc, Tcl_Obj *CONST objv[])
{
  struct symtab *symtab;
  struct blockvector *bv;
  struct block *b;
  struct symbol *sym;
  int i;
  struct block_iterator iter;
  Tcl_Obj *funcVals[2];

  if (objc != 2)
    {
      Tcl_WrongNumArgs (interp, 1, objv, "file");
      return TCL_ERROR;
    }

  symtab = lookup_symtab (Tcl_GetStringFromObj (objv[1], NULL));
  if (!symtab)
    {
      gdbtk_set_result (interp, "No such file (%s)", 
			Tcl_GetStringFromObj (objv[1], NULL));
      return TCL_ERROR;
    }
  
  if (mangled == NULL)
    {
      mangled = Tcl_NewBooleanObj (1);
      not_mangled = Tcl_NewBooleanObj (0);
      Tcl_IncrRefCount (mangled);
      Tcl_IncrRefCount (not_mangled);
    }

  Tcl_SetListObj (result_ptr->obj_ptr, 0, NULL);

  bv = BLOCKVECTOR (symtab);
  for (i = GLOBAL_BLOCK; i <= STATIC_BLOCK; i++)
    {
      b = BLOCKVECTOR_BLOCK (bv, i);
      ALL_BLOCK_SYMBOLS (b, iter, sym)
	{
	  if (SYMBOL_CLASS (sym) == LOC_BLOCK)
	    {

	      const char *name = SYMBOL_DEMANGLED_NAME (sym);

	      if (name)
		{
		  /* strip out "global constructors" and
		   * "global destructors"
		   * because we aren't interested in them. */
		  
		  if (strncmp (name, "global ", 7))
		    {
		      /* If the function is overloaded,
		       * print out the functions
		       * declaration, not just its name. */

		      funcVals[0] = Tcl_NewStringObj (name, -1);
		      funcVals[1] = mangled;
		    }
		  else
		    continue;

		}
	      else
		{
		  funcVals[0] = Tcl_NewStringObj (SYMBOL_PRINT_NAME (sym), -1);
		  funcVals[1] = not_mangled;
		}
	      Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr,
					Tcl_NewListObj (2, funcVals));
	    }
	}
    }
  return TCL_OK;
}

/* This implements the TCL command `gdb_restore_fputs'
   It sets the fputs_unfiltered hook back to gdbtk_fputs.
   Its sole reason for being is that sometimes we move the
   fputs hook out of the way to specially trap output, and if
   we get an error which we weren't expecting, it won't get put
   back, so we run this at idle time as insurance.
*/

static int
gdb_restore_fputs (ClientData clientData, Tcl_Interp *interp,
		   int objc, Tcl_Obj *CONST objv[])
{
  gdbtk_disable_fputs = 0;
  return TCL_OK;
}


/* This implements the tcl command gdb_load_disassembly
 *
 * Arguments:
 *    widget - the name of a text widget into which to load the data
 *    source_with_assm - must be "source" or "nosource"
 *    low_address - the CORE_ADDR from which to start disassembly
 *    ?hi_address? - the CORE_ADDR to which to disassemble, defaults
 *                   to the end of the function containing low_address.
 * Tcl Result:
 *    The text widget is loaded with the data, and a list is returned.
 *    The first element of the list is a two element list containing the
 *    real low & high elements, the rest is a mapping between line number
 *    in the text widget, and either the source line number of that line,
 *    if it is a source line, or the assembly address.  You can distinguish
 *    between the two, because the address will start with 0x...
 */

static int
gdb_load_disassembly (ClientData clientData, Tcl_Interp *interp,
		      int objc, Tcl_Obj *CONST objv[])
{
  CORE_ADDR low, high, orig;
  struct disassembly_client_data client_data;
  int mixed_source_and_assembly, ret_val, i;
  char *arg_ptr;
  char *map_name;
  Tcl_WideInt waddr;

  if (objc != 6 && objc != 7)
    {
      Tcl_WrongNumArgs (interp, 1, objv, "[source|nosource] map_arr index_prefix low_address ?hi_address");
      return TCL_ERROR;
    }

  client_data.widget = Tcl_GetStringFromObj (objv[1], NULL);
  if ( Tk_NameToWindow (interp, client_data.widget,
			Tk_MainWindow (interp)) == NULL)
    {
      gdbtk_set_result (interp, "Invalid widget name.");
      return TCL_ERROR;
    }

  if (!Tcl_GetCommandInfo (interp, client_data.widget, &client_data.cmd))
    {
      gdbtk_set_result (interp, "Can't get widget command info");
      return TCL_ERROR;
    }

  arg_ptr = Tcl_GetStringFromObj (objv[2], NULL);
  if (*arg_ptr == 's' && strcmp (arg_ptr, "source") == 0)
    mixed_source_and_assembly = 1;
  else if (*arg_ptr == 'n' && strcmp (arg_ptr, "nosource") == 0)
    mixed_source_and_assembly = 0;
  else
    {
      gdbtk_set_result (interp, "Second arg must be 'source' or 'nosource'");
      return TCL_ERROR;
    }

  /* As we populate the text widget, we will also create an array in the
     caller's scope.  The name is given by objv[3].
     Each source line gets an entry or the form:
     array($prefix,srcline=$src_line_no) = $widget_line_no

     Each assembly line gets two entries of the form:
     array($prefix,pc=$pc) = $widget_line_no
     array($prefix,line=$widget_line_no) = $src_line_no

     Where prefix is objv[4].
  */
    
  map_name = Tcl_GetStringFromObj (objv[3], NULL);

  if (*map_name != '\0')
    {
      char *prefix;
      int prefix_len;
      
      client_data.map_arr = "map_array";
      if (Tcl_UpVar (interp, "1", map_name, client_data.map_arr, 0) != TCL_OK)
	{
	  gdbtk_set_result (interp, "Can't link map array.");
	  return TCL_ERROR;
	}

      prefix = Tcl_GetStringFromObj (objv[4], &prefix_len);
      
      Tcl_DStringInit(&client_data.src_to_line_prefix);
      Tcl_DStringAppend (&client_data.src_to_line_prefix,
			 prefix, prefix_len);
      Tcl_DStringAppend (&client_data.src_to_line_prefix, ",srcline=",
			 sizeof (",srcline=") - 1);
			      
      Tcl_DStringInit(&client_data.pc_to_line_prefix);
      Tcl_DStringAppend (&client_data.pc_to_line_prefix,
			 prefix, prefix_len);
      Tcl_DStringAppend (&client_data.pc_to_line_prefix, ",pc=",
			 sizeof (",pc=") - 1);
      
      Tcl_DStringInit(&client_data.line_to_pc_prefix);
      Tcl_DStringAppend (&client_data.line_to_pc_prefix,
			 prefix, prefix_len);
      Tcl_DStringAppend (&client_data.line_to_pc_prefix, ",line=",
			 sizeof (",line=") - 1);

    }
  else
    {
      client_data.map_arr = "";
    }

  /* Now parse the addresses */
  if (Tcl_GetWideIntFromObj (interp, objv[5], &waddr) != TCL_OK)
    return TCL_ERROR;
  low = waddr;

  orig = low;

  if (objc == 6)
    {
      if (find_pc_partial_function (low, NULL, &low, &high) == 0)
	error ("No function contains address 0x%s", core_addr_to_string (orig));
    }
  else
    {
      if (Tcl_GetWideIntFromObj (interp, objv[6], &waddr) != TCL_OK)
	return TCL_ERROR;
      high = waddr;
    }
  
  /* Setup the client_data structure, and call the driver function. */
  
  client_data.file_opened_p = 0;
  client_data.widget_line_no = 0;
  client_data.interp = interp;
  for (i = 0; i < 3; i++)
    {
      client_data.result_obj[i] = Tcl_NewObj();
      Tcl_IncrRefCount (client_data.result_obj[i]);
    }

  /* Fill up the constant parts of the argv structures */
  client_data.asm_argv[0] = client_data.widget;
  client_data.asm_argv[1] = "insert";
  client_data.asm_argv[2] = "end";
  client_data.asm_argv[3] = "-\t";
  client_data.asm_argv[4] = "break_rgn_tag";
  /* client_data.asm_argv[5] = address; */
  client_data.asm_argv[6] = "break_rgn_tag";
  /* client_data.asm_argv[7] = offset; */
  client_data.asm_argv[8] = "break_rgn_tag";
  client_data.asm_argv[9] = ":\t\t";
  client_data.asm_argv[10] = "source_tag";
  /* client_data.asm_argv[11] = code; */
  client_data.asm_argv[12] = "source_tag";
  client_data.asm_argv[13] = "\n";

  if (mixed_source_and_assembly)
    {
      client_data.source_argv[0] = client_data.widget;
      client_data.source_argv[1] = "insert";
      client_data.source_argv[2] = "end";
      /* client_data.source_argv[3] = line_number; */
      client_data.source_argv[4] = "";
      /* client_data.source_argv[5] = line; */
      client_data.source_argv[6] = "source_tag2";
    }
  
  ret_val = gdb_disassemble_driver (low, high, mixed_source_and_assembly, 
				    (ClientData) &client_data,
				    gdbtk_load_source, gdbtk_load_asm);

  /* Now clean up the opened file, and the Tcl data structures */
  
  if (client_data.file_opened_p == 1) 
    fclose(client_data.fp);
  
  if (*client_data.map_arr != '\0')
    {
      Tcl_DStringFree(&client_data.src_to_line_prefix);
      Tcl_DStringFree(&client_data.pc_to_line_prefix);
      Tcl_DStringFree(&client_data.line_to_pc_prefix);
    }
  
  for (i = 0; i < 3; i++)
    {
      Tcl_DecrRefCount (client_data.result_obj[i]);
    }
  
  /* Finally, if we were successful, stick the low & high addresses
     into the Tcl result. */

  if (ret_val == TCL_OK) 
    {
      Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr,
				Tcl_NewStringObj (core_addr_to_string (low), -1));
      Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr,
				Tcl_NewStringObj (core_addr_to_string (high), -1));
    }
  return ret_val;
}

static void
gdbtk_load_source (ClientData clientData, struct symtab *symtab, 
		   int start_line, int end_line)
{
  struct disassembly_client_data *client_data =
    (struct disassembly_client_data *) clientData;
  char *buffer;
  int index_len;

  index_len = Tcl_DStringLength (&client_data->src_to_line_prefix);
  
  if (client_data->file_opened_p == 1)
    {
      const char **text_argv;
      char line[10000], line_number[18];
      int found_carriage_return = 1;

      /* First do some sanity checks on the requested lines */

      if (start_line < 1
	  || end_line < start_line || end_line > symtab->nlines)
	{
	  return;
	}

      line_number[0] = '\t';
      line[0] = '\t';

      text_argv = client_data->source_argv;
      
      text_argv[3] = line_number;
      text_argv[5] = line;

      if (fseek (client_data->fp, symtab->line_charpos[start_line - 1],
		 SEEK_SET) < 0)
	{
	  fclose(client_data->fp);
	  client_data->file_opened_p = -1;
	  return;
	}
      
      for (; start_line < end_line; start_line++)
	{
	  if (!fgets (line + 1, 9980, client_data->fp))
	    {
	      fclose(client_data->fp);
	      client_data->file_opened_p = -1;
	      return;
	    }

	  client_data->widget_line_no++;
	  
	  sprintf (line_number + 1, "%d", start_line);
	  
	  if (found_carriage_return)
	    {
	      char *p = strrchr(line, '\0') - 2;
	      if (*p == '\r')
		{
		  *p = '\n';
		  *(p + 1) = '\0';
		}
	      else 
		found_carriage_return = 0;
	    }
	  
	  /* Run the command, then add an entry to the map array in
	     the caller's scope, if requested. */
	  
	  client_data->cmd.proc (client_data->cmd.clientData, 
				 client_data->interp, 7, text_argv);
	  
	  if (*client_data->map_arr != '\0')
	    {
	      
	      Tcl_DStringAppend (&client_data->src_to_line_prefix,
				 line_number + 1, -1);
	      
	      /* FIXME: Convert to Tcl_SetVar2Ex when we move to 8.2.  This
		 will allow us avoid converting widget_line_no into a string. */
	      
	      buffer = xstrprintf ("%d", client_data->widget_line_no);
	      
	      Tcl_SetVar2 (client_data->interp, client_data->map_arr,
			   Tcl_DStringValue (&client_data->src_to_line_prefix),
			   buffer, 0);
	      free(buffer);
	      
	      Tcl_DStringSetLength (&client_data->src_to_line_prefix, index_len);
	    }
	}
      
    }
  else if (!client_data->file_opened_p)
    {
      int fdes;
      /* The file is not yet open, try to open it, then print the
	 first line.  If we fail, set FILE_OPEN_P to -1. */
      
      fdes = open_source_file (symtab);
      if (fdes < 0)
	{
	  client_data->file_opened_p = -1;
	}
      else
	{
          /* FIXME: Convert to a Tcl File Channel and read from there.
	     This will allow us to get the line endings and conversion
	     to UTF8 right automatically when we move to 8.2.
	     Need a Cygwin call to convert a file descriptor to the native
	     Windows handler to do this. */
	     
	  client_data->file_opened_p = 1;
	  client_data->fp = fdopen (fdes, FOPEN_RB);
	  clearerr (client_data->fp);
	  
          if (symtab->line_charpos == 0)
            find_source_lines (symtab, fdes);

	  /* We are called with an actual load request, so call ourselves
	     to load the first line. */
	  
	  gdbtk_load_source (clientData, symtab, start_line, end_line);
	}
    }
  else 
    {
      /* If we couldn't open the file, or got some prior error, just exit. */
      return;
    }
}


/* FIXME: cagney/2003-09-08: "di" is not used and unneeded.  */
static CORE_ADDR
gdbtk_load_asm (ClientData clientData, CORE_ADDR pc, 
		struct disassemble_info *di)
{
  struct disassembly_client_data * client_data
    = (struct disassembly_client_data *) clientData;
  const char **text_argv;
  int i, pc_to_line_len, line_to_pc_len;
  gdbtk_result new_result;
  int insn;
  struct cleanup *old_chain = NULL;

  pc_to_line_len = Tcl_DStringLength (&client_data->pc_to_line_prefix);
  line_to_pc_len = Tcl_DStringLength (&client_data->line_to_pc_prefix);
    
  text_argv = client_data->asm_argv;
  
  /* Preserve the current Tcl result object, print out what we need, and then
     suck it out of the result, and replace... */

  old_chain = make_cleanup (gdbtk_restore_result_ptr, (void *) result_ptr);
  result_ptr = &new_result;
  result_ptr->obj_ptr = client_data->result_obj[0];
  result_ptr->flags = GDBTK_TO_RESULT;

  /* Null out the three return objects we will use. */

  for (i = 0; i < 3; i++)
    Tcl_SetObjLength (client_data->result_obj[i], 0);

  fputs_filtered (paddress (get_current_arch (), pc), gdb_stdout);
  gdb_flush (gdb_stdout);

  result_ptr->obj_ptr = client_data->result_obj[1];
  print_address_symbolic (get_current_arch (), pc, gdb_stdout, 1, "\t");
  gdb_flush (gdb_stdout);

  result_ptr->obj_ptr = client_data->result_obj[2];
  /* FIXME: cagney/2003-09-08: This should use gdb_disassembly.  */
  insn = gdb_print_insn (get_current_arch (), pc, gdb_stdout, NULL);
  gdb_flush (gdb_stdout);

  client_data->widget_line_no++;

  text_argv[5] = Tcl_GetStringFromObj (client_data->result_obj[0], NULL);
  text_argv[7] = Tcl_GetStringFromObj (client_data->result_obj[1], NULL);
  text_argv[11] = Tcl_GetStringFromObj (client_data->result_obj[2], NULL);

  client_data->cmd.proc (client_data->cmd.clientData, 
			 client_data->interp, 14, text_argv);

  if (*client_data->map_arr != '\0')
    {
      char *buffer;
      
      /* Run the command, then add an entry to the map array in
	 the caller's scope. */
      
      Tcl_DStringAppend (&client_data->pc_to_line_prefix, core_addr_to_string (pc), -1);
      
      /* FIXME: Convert to Tcl_SetVar2Ex when we move to 8.2.  This
	 will allow us avoid converting widget_line_no into a string. */
      
      buffer = xstrprintf ("%d", client_data->widget_line_no);
      
      Tcl_SetVar2 (client_data->interp, client_data->map_arr,
		   Tcl_DStringValue (&client_data->pc_to_line_prefix),
		   buffer, 0);

      Tcl_DStringAppend (&client_data->line_to_pc_prefix, buffer, -1);
      

      Tcl_SetVar2 (client_data->interp, client_data->map_arr,
		   Tcl_DStringValue (&client_data->line_to_pc_prefix),
		   core_addr_to_string (pc), 0);
      
      /* Restore the prefixes to their initial state. */
      
      Tcl_DStringSetLength (&client_data->pc_to_line_prefix, pc_to_line_len);      
      Tcl_DStringSetLength (&client_data->line_to_pc_prefix, line_to_pc_len);      
      
      xfree (buffer);
    }
  
  do_cleanups (old_chain);

  return pc + insn;
}

static int
gdb_disassemble_driver (CORE_ADDR low, CORE_ADDR high, 
			int mixed_source_and_assembly,
			ClientData clientData, 
			void (*print_source_fn) (ClientData, struct symtab *, int, int),
			CORE_ADDR (*print_asm_fn) (ClientData, CORE_ADDR, struct disassemble_info *))
{
  CORE_ADDR pc;

  /* If just doing straight assembly, all we need to do is disassemble
     everything between low and high.  If doing mixed source/assembly, we've
     got a totally different path to follow.  */

  if (mixed_source_and_assembly)
    {				/* Come here for mixed source/assembly */
      /* The idea here is to present a source-O-centric view of a function to
         the user.  This means that things are presented in source order, with
         (possibly) out of order assembly immediately following.  */
      struct symtab *symtab;
      struct linetable_entry *le;
      int nlines;
      int newlines;
      struct my_line_entry *mle;
      struct symtab_and_line sal;
      int i;
      int out_of_order;
      int next_line;
      
      /* Assume symtab is valid for whole PC range */
      symtab = find_pc_symtab (low); 

      if (!symtab || !symtab->linetable)
        goto assembly_only;

      /* First, convert the linetable to a bunch of my_line_entry's.  */

      le = symtab->linetable->item;
      nlines = symtab->linetable->nitems;

      if (nlines <= 0)
        goto assembly_only;

      mle = (struct my_line_entry *) alloca (nlines *
					     sizeof (struct my_line_entry));

      out_of_order = 0;
      
      /* Copy linetable entries for this function into our data structure,
	 creating end_pc's and setting out_of_order as appropriate.  */

      /* First, skip all the preceding functions.  */

      for (i = 0; i < nlines - 1 && le[i].pc < low; i++) ;

      /* Now, copy all entries before the end of this function.  */

      newlines = 0;
      for (; i < nlines - 1 && le[i].pc < high; i++)
        {
          if (le[i].line == le[i + 1].line
              && le[i].pc == le[i + 1].pc)
            continue;		/* Ignore duplicates */

	  /* Skip any end-of-function markers.  */
	  if (le[i].line == 0)
	    continue;

	  mle[newlines].line = le[i].line;
          if (le[i].line > le[i + 1].line)
            out_of_order = 1;
          mle[newlines].start_pc = le[i].pc;
          mle[newlines].end_pc = le[i + 1].pc;
          newlines++;
        }

      /* If we're on the last line, and it's part of the function, then we 
         need to get the end pc in a special way.  */

      if (i == nlines - 1
          && le[i].pc < high)
        {
          mle[newlines].line = le[i].line;
          mle[newlines].start_pc = le[i].pc;
          sal = find_pc_line (le[i].pc, 0);
          mle[newlines].end_pc = sal.end;
          newlines++;
        }

      /* Now, sort mle by line #s (and, then by addresses within lines). */

      if (out_of_order)
        qsort (mle, newlines, sizeof (struct my_line_entry), compare_lines);

      /* Now, for each line entry, emit the specified lines (unless they have
	 been emitted before), followed by the assembly code for that line.  */

      next_line = 0;		/* Force out first line */
      for (i = 0; i < newlines; i++)
        {
          /* Print out everything from next_line to the current line.  */

          if (mle[i].line >= next_line)
            {
              if (next_line != 0)
                print_source_fn (clientData, symtab, next_line,
				 mle[i].line + 1);
              else
                print_source_fn (clientData, symtab, mle[i].line,
				 mle[i].line + 1);

              next_line = mle[i].line + 1;
            }

          for (pc = mle[i].start_pc; pc < mle[i].end_pc; )
            {
              QUIT;
	      /* FIXME: cagney/2003-09-08: This entire function should
                 be replaced by gdb_disassembly.  */
	      pc = print_asm_fn (clientData, pc, NULL);
            }
        }
    }
  else
    {
    assembly_only:
      for (pc = low; pc < high; )
        {
          QUIT;
	  /* FIXME: cagney/2003-09-08: This entire function should be
	     replaced by gdb_disassembly.  */
	  pc = print_asm_fn (clientData, pc, NULL);
        }
    }

  return TCL_OK;
}

/* This will be passed to qsort to sort the results of the disassembly */

static int
compare_lines (const PTR mle1p, const PTR mle2p)
{
  struct my_line_entry *mle1, *mle2;
  int val;

  mle1 = (struct my_line_entry *) mle1p;
  mle2 = (struct my_line_entry *) mle2p;

  val = mle1->line - mle2->line;

  if (val != 0)
    return val;

  return mle1->start_pc - mle2->start_pc;
}

/* This implements the TCL command `gdb_loc',

* Arguments:
*    ?symbol? The symbol or address to locate - defaults to pc
* Tcl Return:
*    a list consisting of the following:                                  
*       basename, function name, filename, line number, address, current pc
*/

static int
gdb_loc (ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
{
  char *filename;
  struct symtab_and_line sal;
  const char *fname;
  CORE_ADDR pc;

  if (objc == 1)
    {
      /* This function can be called, before the target is properly
         set-up, the following prevents an error, by trying to
         read_pc when there is no pc to read. It defaults pc, 
         before the target is connected to the entry point of the
         program */
      if (!target_has_registers)
        {
          pc = entry_point_address ();
          sal = find_pc_line (pc, 0);
        }  
      else
	{
	  struct frame_info *frame;
	  CORE_ADDR frame_pc, current_pc;

	  frame = get_selected_frame (NULL);
	  current_pc = regcache_read_pc (get_current_regcache ());
	  frame_pc = get_frame_pc (frame);
 
	  if (frame_pc != current_pc)
	    {
	      /* Note - this next line is not correct on all architectures.
		 For a graphical debugger we really want to highlight the 
		 assembly line that called the next function on the stack.
		 Many architectures have the next instruction saved as the
		 pc on the stack, so what happens is the next instruction 
		 is highlighted. FIXME */
	      pc = frame_pc;
	      find_frame_sal (frame, &sal);
	    }
	  else
	    {
	      pc = current_pc;
	      sal = find_pc_line (pc, 0);
	    }
	}
    }
  else if (objc == 2)
    {
      struct symtabs_and_lines sals;
      int nelts;

      sals = decode_line_with_current_source (Tcl_GetStringFromObj (objv[1], NULL), 1);

      nelts = sals.nelts;
      sal = sals.sals[0];
      free (sals.sals);

      if (sals.nelts != 1)
	{
	  gdbtk_set_result (interp, "Ambiguous line spec", -1);
	  return TCL_ERROR;
	}
      resolve_sal_pc (&sal);
      pc = sal.pc;
    }
  else
    {
      Tcl_WrongNumArgs (interp, 1, objv, "?symbol?");
      return TCL_ERROR;
    }

  if (sal.symtab)
    Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr,
			      Tcl_NewStringObj (sal.symtab->filename, -1));
  else
    Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr,
			      Tcl_NewStringObj ("", 0));

  fname = pc_function_name (pc);
  Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr,
			    Tcl_NewStringObj (fname, -1));

  filename = symtab_to_filename (sal.symtab);
  if (filename == NULL)
    filename = "";

  /* file name */
  Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr, Tcl_NewStringObj (filename, -1));
  /* line number */
  Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr, Tcl_NewIntObj (sal.line));
  /* PC in current frame */
  Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr, 
			    Tcl_NewStringObj (core_addr_to_string (pc), -1));
  /* Real PC */
  Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr, 
			    Tcl_NewStringObj (core_addr_to_string (stop_pc), -1));
  /* shared library */
#ifdef PC_SOLIB
  Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr,
			    Tcl_NewStringObj (PC_SOLIB (pc), -1));
#else
  Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr,
			    Tcl_NewStringObj ("", -1));
#endif
  return TCL_OK;
}

/* This implements the TCL command gdb_entry_point.  It returns the current
   entry point address.  */

static int
gdb_entry_point (ClientData clientData, Tcl_Interp *interp,
		 int objc, Tcl_Obj *CONST objv[])
{
  char *addrstr;

  /* If we have not yet loaded an exec file, then we have no
     entry point, so return an empty string.*/
  if ((int) current_target.to_stratum > (int) dummy_stratum)
    {
      addrstr = (char *)core_addr_to_string (entry_point_address ());
      Tcl_SetStringObj (result_ptr->obj_ptr, addrstr, -1);
    }
  else
    Tcl_SetStringObj (result_ptr->obj_ptr, "", -1);

  return TCL_OK;
}

/* Covert hex to binary. Stolen from remote.c,
   but added error handling */
static int
fromhex (int a)
{
  if (a >= '0' && a <= '9')
    return a - '0';
  else if (a >= 'a' && a <= 'f')
    return a - 'a' + 10;
  else if (a >= 'A' && a <= 'F')
    return a - 'A' + 10;

  return -1;
}

static int
hex2bin (const char *hex, char *bin, int count)
{
  int i, m, n;
  int incr = 2;


  if (gdbarch_byte_order (get_current_arch ()) == BFD_ENDIAN_LITTLE)
    {
      /* need to read string in reverse */
      hex += count - 2;
      incr = -2;
    }

  for (i = 0; i < count; i += 2)
    {
      if (hex[0] == 0 || hex[1] == 0)
	{
	  /* Hex string is short, or of uneven length.
	     Return the count that has been converted so far. */
	  return i;
	}
      m = fromhex (hex[0]);
      n = fromhex (hex[1]);
      if (m == -1 || n == -1)
	return -1;
      *bin++ = m * 16 + n;
      hex += incr;
    }

  return i;
}

/* This implements the Tcl command 'gdb_set_mem', which
 * sets some chunk of memory.
 *
 * Arguments:
 *   gdb_set_mem addr hexstr len
 *
 *   addr:   address of data to set
 *   hexstr: ascii string of data to set
 *   len:    number of bytes of data to set
 */
static int
gdb_set_mem (ClientData clientData, Tcl_Interp *interp,
	     int objc, Tcl_Obj *CONST objv[])
{
  CORE_ADDR addr;
  gdb_byte buf[128];
  char *hexstr;
  int len, size;

  if (objc != 4)
    {
      Tcl_WrongNumArgs (interp, 1, objv, "addr hex_data len");
      return TCL_ERROR;
    }

  /* Address to write */
  addr = string_to_core_addr (Tcl_GetStringFromObj (objv[1], NULL));

  /* String value to write: it's in hex */
  hexstr = Tcl_GetStringFromObj (objv[2], NULL);
  if (hexstr == NULL)
    return TCL_ERROR;

  /* Length of buf */
  if (Tcl_GetIntFromObj (interp, objv[3], &len) != TCL_OK)
    return TCL_ERROR;

  /* Convert hexstr to binary and write */
  if (hexstr[0] == '0' && hexstr[1] == 'x')
    hexstr += 2;
  size = hex2bin (hexstr, (char *) buf, strlen (hexstr));
  if (size < 0)
    {
      /* Error in input */
      gdbtk_set_result (interp, "Invalid hexadecimal input: \"0x%s\"", hexstr);
      return TCL_ERROR;
    }

  target_write_memory (addr, buf, len);
  return TCL_OK;
}

/* This implements the Tcl command 'gdb_update_mem', which 
 * updates a block of memory in the memory window
 *
 * Arguments:
 *   gdb_update_mem data addr form size nbytes bpr aschar
 *
 *   1 data: variable that holds table's data
 *   2 addr: address of data to dump
 *   3 mform: a char indicating format
 *   4 size: size of each element; 1,2,4, or 8 bytes
 *   5 nbytes: the number of bytes to read 
 *   6 bpr: bytes per row
 *   7 aschar: if present, an ASCII dump of the row is included.  ASCHAR
 *              used for unprintable characters.
 * 
 * Return:
 * a list of three integers: {border_col_width data_col_width ascii_col_width}
 * which can be used to set the table's column widths. */

static int
gdb_update_mem (ClientData clientData, Tcl_Interp *interp,
		int objc, Tcl_Obj *CONST objv[])
{
  long dummy;
  char index[20];
  CORE_ADDR addr;
  int nbytes, rnum, bpr;
  int size, asize, i, j, bc;
  int max_ascii_len, max_val_len, max_label_len;
  char format, aschar;
  char *data, *tmp;
  char buff[128], *bptr;
  gdb_byte *mbuf, *mptr, *cptr;
  struct ui_file *stb;
  struct type *val_type;
  struct cleanup *old_chain;

  if (objc < 7 || objc > 8)
    {
      Tcl_WrongNumArgs (interp, 1, objv, "data addr format size bytes bytes_per_row ?ascii_char?");
      return TCL_ERROR;
    }

  /* Get table data and link to a local variable */
  data = Tcl_GetStringFromObj (objv[1], NULL);
  if (data == NULL)
    {
      gdbtk_set_result (interp, "could not get data variable");
      return TCL_ERROR;
    }

  if (Tcl_UpVar (interp, "1", data, "data", 0) != TCL_OK)
    {
      gdbtk_set_result (interp, "could not link table data");
      return TCL_ERROR;
    }

  if (Tcl_GetIntFromObj (interp, objv[4], &size) != TCL_OK)
    return TCL_ERROR;
  else if (size <= 0)
    {
      gdbtk_set_result (interp, "Invalid size, must be > 0");
      return TCL_ERROR;
    }

  if (Tcl_GetIntFromObj (interp, objv[5], &nbytes) != TCL_OK)
    return TCL_ERROR;
  else if (nbytes <= 0)
    {
      gdbtk_set_result (interp, "Invalid number of bytes, must be > 0");
      return TCL_ERROR;
    }

  if (Tcl_GetIntFromObj (interp, objv[6], &bpr) != TCL_OK)
    return TCL_ERROR;
  else if (bpr <= 0)
    {
      gdbtk_set_result (interp, "Invalid bytes per row, must be > 0");
      return TCL_ERROR;
    }

  tmp = Tcl_GetStringFromObj (objv[2], NULL);
  if (tmp == NULL)
    {
      gdbtk_set_result (interp, "could not get address");
      return TCL_ERROR;
    }
  addr = string_to_core_addr (tmp);

  format = *(Tcl_GetStringFromObj (objv[3], NULL));
  mbuf = (gdb_byte *) xmalloc (nbytes + 32);
  if (!mbuf)
    {
      gdbtk_set_result (interp, "Out of memory.");
      return TCL_ERROR;
    }

  memset (mbuf, 0, nbytes + 32);
  mptr = cptr = mbuf;

  /* Dispatch memory reads to the topmost target, not the flattened
     current_target.  */
  rnum = target_read (current_target.beneath, TARGET_OBJECT_MEMORY, NULL,
		      mbuf, addr, nbytes);
  if (rnum <= 0)
    {
      gdbtk_set_result (interp, "Unable to read memory.");
      return TCL_ERROR;
    }

  if (objc == 8)
    aschar = *(Tcl_GetStringFromObj (objv[7], NULL));
  else
    aschar = 0;

  switch (size)
    {
    case 1:
      val_type = builtin_type (get_current_arch ())->builtin_int8;
      asize = 'b';
      break;
    case 2:
      val_type = builtin_type (get_current_arch ())->builtin_int16;
      asize = 'h';
      break;
    case 4:
      val_type = builtin_type (get_current_arch ())->builtin_int32;
      asize = 'w';
      break;
    case 8:
      val_type = builtin_type (get_current_arch ())->builtin_int64;
      asize = 'g';
      break;
    default:
      val_type = builtin_type (get_current_arch ())->builtin_int8;
      asize = 'b';
    }

  bc = 0;			/* count of bytes in a row */
  bptr = &buff[0];		/* pointer for ascii dump */

  /* Open a memory ui_file that we can use to print memory values */
  stb = mem_fileopen ();
  old_chain = make_cleanup_ui_file_delete (stb);
  
  /* A little macro to do column indices. As a rule, given the current
     byte, i, of a total nbytes and the bytes per row, bpr, and the size of
     each cell, size, the row and column will be given by:

     row = i/bpr
     col = (i%bpr)/size
  */
#define INDEX(row,col) sprintf (index, "%d,%d",(row),(col))

  /* Fill in address labels */
  max_label_len = 0;
  for (i = 0; i < nbytes; i += bpr)
    {
      char s[130];
      sprintf (s, "%s", core_addr_to_string (addr + i));
      INDEX ((int) i/bpr, -1);
      Tcl_SetVar2 (interp, "data", index, s, 0);

      /* The tcl code in MemWin::update_addr used to track the size
	 of each cell. I don't see how these could change for any given
	 update, so we don't loop over all cells. We just note the first
	 size. */
      if (max_label_len == 0)
	max_label_len = strlen (s);
    }

  /* Fill in memory */
  max_val_len   = 0;		/* Ditto the above comments about max_label_len */
  max_ascii_len = 0;
  for (i = 0; i < nbytes; i += size)
    {
      INDEX ((int) i/bpr, (int) (i%bpr)/size);

      if (i >= rnum)
	{
	  /* Read fewer bytes than requested */
	  tmp = "N/A";

	  if (aschar)
	    {
	      for (j = 0; j < size; j++)
		*bptr++ = 'X';
	    }
	}
      else
	{
	  struct value_print_options opts;

	  get_formatted_print_options (&opts, format);

	  /* print memory to our uiout file and set the table's variable */
	  ui_file_rewind (stb);
	  print_scalar_formatted (mptr, val_type, &opts, asize, stb);
	  tmp = ui_file_xstrdup (stb, &dummy);

	  /* See comments above on max_*_len */
	  if (max_val_len == 0)
	    max_val_len = strlen (tmp);

	  if (aschar)
	    {
	      for (j = 0; j < size; j++)
		{
		  if (isprint (*cptr))
		    *bptr++ = *cptr++;
		  else
		    {
		      *bptr++ = aschar;
		      cptr++;;
		    }
		}
	    }
	}
      Tcl_SetVar2 (interp, "data", index, tmp, 0);

      mptr += size;
      bc += size;

      if (aschar && (bc >= bpr))
	{
	  /* end of row. Add it to the result and reset variables */
	  *bptr = '\000';
	  INDEX (i/bpr, bpr/size);
	  Tcl_SetVar2 (interp, "data", index, buff, 0);

	  /* See comments above on max_*_len */
	  if (max_ascii_len == 0)
	    max_ascii_len = strlen (buff);

	  bc = 0;
	  bptr = &buff[0];
	}
    }

  /* return max_*_len so that column widths can be set */
  Tcl_ListObjAppendElement (interp, result_ptr->obj_ptr, Tcl_NewIntObj (max_label_len + 1));
  Tcl_ListObjAppendElement (interp, result_ptr->obj_ptr, Tcl_NewIntObj (max_val_len + 1));
  Tcl_ListObjAppendElement (interp, result_ptr->obj_ptr, Tcl_NewIntObj (max_ascii_len + 1));
  do_cleanups (old_chain);
  xfree (mbuf);
  return TCL_OK;
#undef INDEX
}


/* This implements the tcl command "gdb_loadfile"
 * It loads a c source file into a text widget.
 *
 * Tcl Arguments:
 *    widget: the name of the text widget to fill
 *    filename: the name of the file to load
 *    linenumbers: A boolean indicating whether or not to display line numbers.
 * Tcl Result:
 *
 */

/* In this routine, we will build up a "line table", i.e. a
 * table of bits showing which lines in the source file are executible.
 * LTABLE_SIZE is the number of bytes to allocate for the line table.
 *
 * Its size limits the maximum number of lines 
 * in a file to 8 * LTABLE_SIZE.  This memory is freed after 
 * the file is loaded, so it is OK to make this very large. 
 * Additional memory will be allocated if needed. */
#define LTABLE_SIZE 20000
static int
gdb_loadfile (ClientData clientData, Tcl_Interp *interp, int objc,
	      Tcl_Obj *CONST objv[])
{
  char *file, *widget;
  int linenumbers, ln, lnum, ltable_size;
  FILE *fp;
  char *ltable;
  struct symtab *symtab;
  struct linetable_entry *le;
  long mtime = 0;
  struct stat st;
  char line[10000], line_num_buf[18];
  const char *text_argv[9];
  Tcl_CmdInfo text_cmd;

 
  if (objc != 4)
    {
      Tcl_WrongNumArgs(interp, 1, objv, "widget filename linenumbers");
      return TCL_ERROR; 
    }

  widget = Tcl_GetStringFromObj (objv[1], NULL);
  if ( Tk_NameToWindow (interp, widget, Tk_MainWindow (interp)) == NULL)
    {
      return TCL_ERROR;
    }

  if (!Tcl_GetCommandInfo (interp, widget, &text_cmd))
    {
      gdbtk_set_result (interp, "Can't get widget command info");
      return TCL_ERROR;
    }
  
  file  = Tcl_GetStringFromObj (objv[2], NULL);
  Tcl_GetBooleanFromObj (interp, objv[3], &linenumbers);

  symtab = lookup_symtab (file);
  if (!symtab)
    {
      gdbtk_set_result (interp, "File not found in symtab");
      return TCL_ERROR;
    }

  file = symtab_to_filename ( symtab );
  if ((fp = fopen ( file, "r" )) == NULL)
    {
      gdbtk_set_result (interp, "Can't open file for reading");
      return TCL_ERROR;
    }

  if (stat (file, &st) < 0)
    {
      catch_errors (perror_with_name_wrapper, "gdbtk: get time stamp", "",
                    RETURN_MASK_ALL);
      return TCL_ERROR;
    }

  if (symtab && symtab->objfile && symtab->objfile->obfd)
    mtime = bfd_get_mtime(symtab->objfile->obfd);
  else if (exec_bfd)
    mtime = bfd_get_mtime(exec_bfd);
 
  if (mtime && mtime < st.st_mtime)
    {
      gdbtk_ignorable_warning("file_times",\
			      "Source file is more recent than executable.\n");
    }
  
  
  /* Source linenumbers don't appear to be in order, and a sort is */
  /* too slow so the fastest solution is just to allocate a huge */
  /* array and set the array entry for each linenumber */

  ltable_size = LTABLE_SIZE;
  ltable = (char *)malloc (LTABLE_SIZE);
  if (ltable == NULL)
    {
      fclose (fp);
      gdbtk_set_result (interp, "Out of memory.");
      return TCL_ERROR;
    }

  memset (ltable, 0, LTABLE_SIZE);

  if (symtab->linetable && symtab->linetable->nitems)
    {
      le = symtab->linetable->item;
      for (ln = symtab->linetable->nitems ;ln > 0; ln--, le++)
        {
          lnum = le->line >> 3;
          if (lnum >= ltable_size)
            {
              char *new_ltable;
              new_ltable = (char *)realloc (ltable, ltable_size*2);
              memset (new_ltable + ltable_size, 0, ltable_size);
              ltable_size *= 2;
              if (new_ltable == NULL)
                {
                  free (ltable);
                  fclose (fp);
		  gdbtk_set_result (interp, "Out of memory.");
                  return TCL_ERROR;
                }
              ltable = new_ltable;
            }
          ltable[lnum] |= 1 << (le->line % 8);
        }
    }
      
  ln = 1;

  line[0] = '\t'; 
  text_argv[0] = widget;
  text_argv[1] = "insert";
  text_argv[2] = "end";
  text_argv[5] = line;
  text_argv[6] = "source_tag";
  text_argv[8] = NULL;
  
  if (linenumbers)
    {
      int found_carriage_return = 1;
      
      line_num_buf[1] = '\t';
       
      text_argv[3] = line_num_buf;
      
      while (fgets (line + 1, 9980, fp))
        {
	  /* Look for DOS style \r\n endings, and if found,
	   * strip off the \r.  We assume (for the sake of
	   * speed) that ALL lines in the file have DOS endings,
	   * or none do.
	   */
	  
	  if (found_carriage_return)
	    {
	      char *p = strrchr(line, '\0') - 2;
	      if (*p == '\r')
		{
		  *p = '\n';
		  *(p + 1) = '\0';
		} 
	      else 
		found_carriage_return = 0;
	    }
	  
          sprintf (line_num_buf+2, "%d", ln);
          if (ltable[ln >> 3] & (1 << (ln % 8)))
            {
	      line_num_buf[0] = '-';
              text_argv[4] = "break_rgn_tag";
            }
          else
            {
	      line_num_buf[0] = ' ';
              text_argv[4] = "";
            }

          text_cmd.proc(text_cmd.clientData, interp, 7, text_argv);
          ln++;
        }
    }
  else
    {
      int found_carriage_return = 1;
            
      while (fgets (line + 1, 9980, fp))
        {
	  if (found_carriage_return)
	    {
	      char *p = strrchr(line, '\0') - 2;
	      if (*p == '\r')
		{
		  *p = '\n';
		  *(p + 1) = '\0';
		} 
	      else
		found_carriage_return = 0;
	    }

          if (ltable[ln >> 3] & (1 << (ln % 8)))
            {
              text_argv[3] = "- ";
              text_argv[4] = "break_rgn_tag";
            }
          else
            {
              text_argv[3] = "  ";
              text_argv[4] = "";
            }

          text_cmd.proc(text_cmd.clientData, interp, 7, text_argv);
          ln++;
	}
    }

  free (ltable);
  fclose (fp);
  return TCL_OK;
}

/*
 * This section contains a bunch of miscellaneous utility commands
 */

/* This implements the tcl command gdb_path_conv

* On Windows, it canonicalizes the pathname,
* On Unix, it is a no op.
*
* Arguments:
*    path
* Tcl Result:
*    The canonicalized path.
*/

static int
gdb_path_conv (ClientData clientData, Tcl_Interp *interp,
	       int objc, Tcl_Obj *CONST objv[])
{
  if (objc != 2)
    {
      Tcl_WrongNumArgs (interp, 1, objv, NULL);
      return TCL_ERROR;
    }

#ifdef __CYGWIN__
  {
    char pathname[256], *ptr;

    cygwin_conv_path (CCP_POSIX_TO_WIN_A, Tcl_GetStringFromObj (objv[1], NULL),
		      pathname, 256);
    for (ptr = pathname; *ptr; ptr++)
      {
	if (*ptr == '\\')
	  *ptr = '/';
      }
    Tcl_SetStringObj (result_ptr->obj_ptr, pathname, -1);
  }
#else
  Tcl_SetStringObj (result_ptr->obj_ptr, Tcl_GetStringFromObj (objv[1], NULL),
		    -1);
#endif

  return TCL_OK;
}

/*
 * This section has utility routines that are not Tcl commands.
 */

static int
perror_with_name_wrapper (PTR args)
{
  perror_with_name (args);
  return 1;
}

/* Look for the function that contains PC and return the source
   (demangled) name for this function.

   If no symbol is found, it returns an empty string. In either
   case, memory is owned by gdb. Do not attempt to free it. */
const char *
pc_function_name (CORE_ADDR pc)
{
  struct symbol *sym;
  const char *funcname = NULL;

  /* First lookup the address in the symbol table... */
  sym = find_pc_function (pc);
  if (sym != NULL)
    funcname = GDBTK_SYMBOL_SOURCE_NAME (sym);
  else
    {
      /* ... if that fails, look it up in the minimal symbols. */
      struct bound_minimal_symbol msym;

      msym = lookup_minimal_symbol_by_pc (pc);
      if (msym.minsym != NULL)
	funcname = GDBTK_SYMBOL_SOURCE_NAME (msym.minsym);
    }

  if (funcname == NULL)
    funcname = "";

  return funcname;
}

void
gdbtk_set_result (Tcl_Interp *interp, const char *fmt,...)
{
  va_list args;
  char *buf;

  va_start (args, fmt);
  buf = xstrvprintf (fmt, args);
  va_end (args);
  Tcl_SetObjResult (interp, Tcl_NewStringObj (buf, -1));
  xfree(buf);
}


/* This implements the tcl command 'gdb_incr_addr'.
 * It does address arithmetic and outputs a proper
 * hex string.  This was originally implemented
 * when tcl did not support 64-bit values, but we keep
 * it because it saves us from having to call incr 
 * followed by format to get the result in hex.
 * Also, it may be true in the future that CORE_ADDRs
 * will have their own ALU to deal properly with
 * architecture-specific address arithmetic.
 *
 * Tcl Arguments:
 *     addr   - CORE_ADDR
 *     number - optional number to add to the address
 *	default is 1.
 *
 * Tcl Result:
 *     hex string containing the result of addr + number
 */

static int
gdb_incr_addr (ClientData clientData, Tcl_Interp *interp,
	       int objc, Tcl_Obj *CONST objv[])
{
  CORE_ADDR address;
  int number = 1;

  if (objc != 2 && objc != 3)
    {
      Tcl_WrongNumArgs (interp, 1, objv, "CORE_ADDR [number]");
      return TCL_ERROR;
    }

  address = string_to_core_addr (Tcl_GetStringFromObj (objv[1], NULL));

  if (objc == 3)
    {
      if (Tcl_GetIntFromObj (interp, objv[2], &number) != TCL_OK)
	return TCL_ERROR;
    }
  
  address += number;

  Tcl_SetStringObj (result_ptr->obj_ptr, (char *)core_addr_to_string (address), -1);
  
  return TCL_OK;
}

/* This implements the tcl command 'gdb_CAS_to_TAS'.
 * It takes a CORE_ADDR and outputs a string suitable
 * for displaying as the target address.
 *
 * Note that CORE_ADDRs are internal addresses which map
 * to target addresses in different ways depending on the 
 * architecture. The target address string is a user-readable
 * string may be quite different than the CORE_ADDR. For example,
 * a CORE_ADDR of 0x02001234 might indicate a data address of
 * 0x1234 which this function might someday output as something
 * like "D:1234".
 *
 * Tcl Arguments:
 *     address   - CORE_ADDR
 *
 * Tcl Result:
 *     string
 */

static int
gdb_CA_to_TAS (ClientData clientData, Tcl_Interp *interp,
	       int objc, Tcl_Obj *CONST objv[])
{
  CORE_ADDR address;
  Tcl_WideInt wide_addr;

  if (objc != 2)
    {
      Tcl_WrongNumArgs (interp, 1, objv, "CORE_ADDR");
      return TCL_ERROR;
    }

  /* Read address into a wideint, which is the largest tcl supports
     then convert to a CORE_ADDR */
  if (Tcl_GetWideIntFromObj (interp, objv[1], &wide_addr) != TCL_OK)
    return TCL_ERROR;
  address = wide_addr;

  /* This is not really correct.  Using paddr_nz() will convert to hex and truncate 
     to 32-bits when required but will otherwise not do what we really want. */
  
  Tcl_SetStringObj (result_ptr->obj_ptr,
		    paddress (get_current_arch (), address),
		    -1);

  return TCL_OK;
}

/* Another function that was removed in GDB and replaced
 * with something similar, but different enough to break
 * Insight.
 */
char *
symtab_to_filename (struct symtab *s)
{
  int r;

  if (!s)
    return NULL;

  /* Don't check s->fullname here, the file could have been 
     deleted/moved/..., look for it again */
  r = open_source_file (s);
  if (r)
    close (r);

  if (s->fullname && *s->fullname)
      return s->fullname;
  return s->filename;
}
@


1.135
log
@	* generic/gdbtk-cmds.c (gdb_clear_file): Remove use of pop_target,
	which was recently removed from gdb.
@
text
@d1464 1
a1464 1
    old_chain = make_cleanup_free_search_symbols (ss);
d1480 1
a1480 1
	  || p->msymbol != NULL)
d1484 1
a1484 1
	  if (p->msymbol == NULL)
d1489 1
a1489 1
				      Tcl_NewStringObj (SYMBOL_PRINT_NAME (p->msymbol), -1));
@


1.134
log
@	* generic/gdbtk-cmds.c (gdb_listfuncs): Update declaration.
	* generic/gdbtk-hooks.c (gdb_two_elem_cmd): Likewise.
	(report_error): Likewise.
	(gdbtk_readline_end, gdbtk_post_add_symbol, gdbtk_error_begin,
	gdbtk_attach): Likewise.
	* generic/gdbtk/gdbtk-register.c (setup_architecture_data):
	Likewise.
	* generic/gdbtk-wrapper.c (GDB_equal_value, GDB_reinit_frame_cache,
	GDB_value-coerce_array): Likewise.
	* generic/gdbtk.c (gdbtk_interactive, gdbtk_start_timer,
	gdbtk_stop_timer, _initialize_gdbtk): Likewise.
@
text
@a489 3
  if (target_has_execution)
    pop_target ();

@


1.133
log
@	* generic/gdbtk-register.c (map_arg_registers): Change type of
	raw_buffer to gdb_byte to follow recent API changes in gdb.
	* generic/gdbtk-cmds.c (gdb_update_mem): Likewise for ' mbfu',
	'mptr', and 'cptr'.
@
text
@d1531 2
a1532 5
gdb_listfuncs (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
@


1.132
log
@	* generic/gdbtk.c (tk_command): Use xfree instead of free.
	* generic/gdbtk-hooks.c (gdbtk_call_command): Remove unused
	cleanup.
	* generic/gdbtk-cmds.c (gdb_load_info): If bfd_check_format
	fails, run the cleanup.
@
text
@d2480 2
a2481 1
  char buff[128], *mbuf, *mptr, *cptr, *bptr;
d2539 1
a2539 1
  mbuf = (char *) xmalloc (nbytes + 32);
@


1.131
log
@	* generic/gdbtk-cmds.c (pc_function_name): Adjust type of
	`msym' to account for change in return type of
	lookup_minimal_symbol_by_pc().
@
text
@d2 1
a2 1
   Copyright (C) 1994-2012 Free Software Foundation, Inc.
d972 1
@


1.130
log
@	From Pierre Muller  <muller@@sourceware.org>
	Adapt to change in gdb/configure.ac
	Don't check for ctype.h, time.h.
	* generic/gdbtk-cmds.c: Don't use HAVE_CTYPE_H.
@
text
@d2996 1
a2996 1
      struct minimal_symbol *msym = NULL;
d2999 2
a3000 2
      if (msym != NULL)
	funcname = GDBTK_SYMBOL_SOURCE_NAME (msym);
@


1.129
log
@	* generic/gdbtk-hooks.c (gdbtk_memory_changed): Change LEN
	from int to ssize_t to match changes in the API.
	(x_event): Use set_quit_flag to set the quit_flag.
	* generic/gdbtk-cmds.c (gdb_stop): Likewise.
@
text
@d48 1
a91 4
#ifdef HAVE_CTYPE_H
#include <ctype.h>		/* for isprint() */
#endif

@


1.128
log
@	* generic/gdbtk-cmds.c (gdb_load_info): Replace call to
	make_cleanup_bfd_close with make_cleanup_bfd_unref due
	to changes in gdb.
	(gdb_loc): Replace call to decode_line_spec with call to
	decode_line_with_current_source due to changes in gdb.
	* generic/gdbtk-wrapper.c: Comment unused functions
	GDB_parse_exp_1 and wrap_parse_exp_1 as parse_exp_1 has
	changed its interface and the code appears to be unused
	anyway.
	* generic/gdbtk-wrapper.h: ditto
@
text
@d601 1
a601 1
	quit_flag = 1;		/* hope something sees this */
@


1.128.2.1
log
@	* generic/gdbtk-cmds.c (gdb_load_info): Revert change
	regarding make_cleanup_bfd_unref for the gdb 7.5 branch.
@
text
@d971 1
a971 1
  old_cleanups = make_cleanup_bfd_close (loadfile_bfd);
@


1.127
log
@   * generic/gdbtk-cmds.c: On windows include
   windows.h/tlhelp32.h. Declare new
   function gdb_list_processes().
   (Gdbtk_Init): Register new tcl function
   "gdb_list_processes".
   (gdb_list_processes): New function.
   * library/attachdlg.itb: Updated copyright.
   (list_pids): Use gdb_list_processes for
   getting the process list. Fallback to
   ps if empty list is returned. Adapt method comment.
   * library/srcbar.itcl: Updated copyright.
   (create_run_menu): Allow "Attach to process" on
   windows, too.
@
text
@d971 1
a971 1
  old_cleanups = make_cleanup_bfd_close (loadfile_bfd);
d2273 1
a2273 1
      sals = decode_line_spec (Tcl_GetStringFromObj (objv[1], NULL), 1);
@


1.126
log
@2012-05-25  Roland Schwingel  <roland.schwingel@@onevision.com>

	* generic/gdbtk-bp.c (gdb_set_bp): Add new NULL param
	to call to create_breakpoint() due to changes in gdb.
	* generic/gdbtk-cmds.c (gdb_listfuncs): Iterator param
	in call to ALL_BLOCK_SYMBOLS() now is a pointer to
	struct block_iterator instead of struct dict_iterator.
	* generic/gdbtk-stack.c (gdb_block_vars,gdb_get_blocks)
	(gdb_get_vars_command): Likewise.
	* generic/gdbtk-hooks.c (gdbtk_annotate_signal): Change
	function calls: target_signal_to_name -> gdb_signal_to_name
	target_signal_to_string -> gdb_signal_to_string due to
	recent changes in gdb.
@
text
@d95 5
d233 5
d306 2
d606 55
@


1.125
log
@	* generic/gdbtk-cmds.c: Updated Copyright year to 1994-2012.
	Remove unneeded include.
@
text
@d1477 1
a1477 1
  struct dict_iterator iter;
@


1.124
log
@	* generic/gdbtk-cmds.h (pc_function_name): Make return type
	const.
	* generic/gdbtk-bp.c (gdb_get_breakpoint_info)
	(gdb_get_tracepoint_info): Make char * variables const to match
	recent GDB API changes.
	* generic/gdbtk-stack.c (get_frame_name): Likewise.
	* generic/gdbtk-cmds.c (gdb_get_function_command, gdb_listfuncs)
	(gdb_loc, perror_with_name_wrapper): Likewise.
	(pc_function_name): Likewise, plus change return type to be const.
@
text
@d2 1
a2 3
   Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2001, 2002, 2003, 2004,
   2007, 2008, 2010, 2011
   Free Software Foundation, Inc.
a32 1
#include "tui/tui-file.h"
@


1.123
log
@	* generic/gdbtk-cmds.c (gdb_listfiles): Update API changes
	for map_partial_symbol_filenames.
	(gdb_get_line_command): Update API changes for decode_line_1 in gdb.
	(gdb_get_file_command): Likewise.
	(gdb_get_function_command): Likewise.
	* generic/gdbtk-stack.c (gdb_get_vars_command): Likewise.
	* generic/gdbtk-bp.c (tracepoint_exists): Likewise.
	(gdb_find_bp_at_line, gdb_get_breakpoint_info): Update breakpoint
	API changes in gdb.
@
text
@d1024 1
a1024 1
  char *function;
d1516 1
a1516 1
	      char *name = SYMBOL_DEMANGLED_NAME (sym);
d2162 1
a2162 1
  char *fname;
d2922 1
a2922 1
char *
d2926 1
a2926 1
  char *funcname = NULL;
@


1.122
log
@	* generic/gdbtk-cmds.c (gdb_prompt_command): get_prompt now
	takes no arguments.
@
text
@d963 1
a963 1
  sals = decode_line_1 (&args, 1, NULL, 0, NULL);
d999 1
a999 1
  sals = decode_line_1 (&args, 1, NULL, 0, NULL);
d1035 1
a1035 1
  sals = decode_line_1 (&args, 1, NULL, 0, NULL);
d1203 1
a1203 1
  map_partial_symbol_filenames (do_listfiles, &info);
@


1.121
log
@	* generic/gdbtk-bp.c (BREAKPOINT_IS_WATCHPOINT): Remove.
	(gdb_get_breakpoint_info): Update with recent GDB API changes.
	(gdb_actions_command): Likewise.
	(gdb_get_tracepoint_info): Likewise.
	(breakpoint_notify): Use get_breakpoint.

	* generic/gdbtk-cmds.c (gdb_prompt_command): Update with recent
	GDB API changes.
@
text
@d796 1
a796 1
  Tcl_SetStringObj (result_ptr->obj_ptr, get_prompt (0), -1);
@


1.120
log
@	* generic/gdbtk-bp.c (tracepoint_exists): Remove recently
	removed "not_found_ptr" argument from call to decode_line_1.
	* generic/gdbtk-stack.c (gdb_get_vars_command): Likewise.
	* generic/gdbtk-cmds.c (gdb_get_line_command): Likewise.
	(gdb_get_file_command): Likewise.
	(gdb_get_function_command): Likewise.

	From Kevin Buettner  <kevinb@@redhat.com>
	* generic/gdbtk-register.c (): Delete declaration of `buffer'.
	Use `valaddr' in its place.
@
text
@a226 1
char *get_prompt (void);
d796 1
a796 1
  Tcl_SetStringObj (result_ptr->obj_ptr, get_prompt (), -1);
@


1.119
log
@	* generic/gdbtk-bp.c (tracepoint_exists): Update for
	decode_line_1 API change.
	* generic/gdbtk-cmds.c (gdb_eval): Use comman_val_print
	instead of val_print.
	(gdb_get_line_command): Update for decode_line_1 API
	changes.
	(gdb_get_file_command): Likewise.
	(gdb_get_function_command): Likewise.
	* generic/gdbtk-register.c (get_register_types): Use
	get_frame_register_value instead of frame_register.
	(get_register): Pass valid VALUE to val_print.
	Consolidate calls to get_current_gdbarch.
	* generic/gdbtk-stack.c (gdb_get_vars_command): Update
	for decode_line_1 API change.
@
text
@d964 1
a964 1
  sals = decode_line_1 (&args, 1, NULL, 0, NULL, NULL);
d1000 1
a1000 1
  sals = decode_line_1 (&args, 1, NULL, 0, NULL, NULL);
d1036 1
a1036 1
  sals = decode_line_1 (&args, 1, NULL, 0, NULL, NULL);
@


1.118
log
@	* generic/gdbtk-cmds.c: Add cygwin macros to allow compilation
	with old or recent cygwin version.
	(gdb_path_conv): Use cygwin_conv_path function.
	(gdb_eval): Adapt to new field in val_print.
	* generic/gdbtk-register.c (get_register): Likewise.
	* generic/gdbtk-wrapper.c (wrap_val_print): Likewise.
	* generic/gdbtk.c (_initialize_gdbtk): Use cygwin_attach_handle_to_fd
	call to allow compilation with old and new cygwin version.
@
text
@d2 2
a3 1
   Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2001, 2002, 2003, 2004, 2007, 2008, 2010
d656 1
a656 3
  val_print (value_type (val), value_contents (val),
	     value_embedded_offset (val), value_address (val),
	     stb, 0, val, &opts, current_language);
d955 1
a955 1
  char *args, **canonical;
d964 1
a964 1
  sals = decode_line_1 (&args, 1, NULL, 0, &canonical, NULL);
d991 1
a991 1
  char *args, **canonical;
d1000 1
a1000 1
  sals = decode_line_1 (&args, 1, NULL, 0, &canonical, NULL);
d1027 1
a1027 1
  char *args, **canonical;
d1036 1
a1036 1
  sals = decode_line_1 (&args, 1, NULL, 0, &canonical, NULL);
@


1.117
log
@	* generic/gdbtk-cmds.c: Include psymtab.h, not psympriv.h.
	(struct listfiles_info): New.
	(do_listfiles): New function.
	(gdb_listfiles): Use it.
@
text
@d77 14
d657 1
a657 1
	     stb, 0, &opts, current_language);
d2891 2
a2892 2
    cygwin_conv_to_full_win32_path (Tcl_GetStringFromObj (objv[1], NULL),
				      pathname);
@


1.116
log
@	* generic/gdbtk-cmds.c: Include psympriv.h.
@
text
@a29 1
#include "psympriv.h"
d49 1
d1107 36
d1173 1
d1186 6
a1191 16
  ALL_PSYMTABS (objfile, psymtab)
    {
      if (numfiles == files_size)
	{
	  files_size = files_size * 2;
	  files = (const char **) xrealloc (files, sizeof (char *) * files_size);
	}
      if (psymtab->filename)
	{
	  if (!len || !strncmp (pathname, psymtab->filename, len)
	      || !strcmp (psymtab->filename, lbasename (psymtab->filename)))
	    {
	      files[numfiles++] = lbasename (psymtab->filename);
	    }
	}
    }
@


1.115
log
@	* generic/gdbtk-cmds.c (gdb_set_inferior_args): set_inferior_args
	now works as expected. Do not strdup/free the argument string.
@
text
@d30 1
@


1.114
log
@	* generic/gdbtk-cmds.c (gdbtk_load_asm): print_address_symbolic
	requires the architecture, too.
@
text
@d862 1
a862 7

  /* The xstrdup/xfree stuff is so that we maintain a coherent picture
     for gdb.  I would expect the accessors to do this, but they
     don't.  */
  args = xstrdup (args);
  args = set_inferior_args (args);
  xfree (args);
@


1.113
log
@	* generic/gdbtk-bp.c: Include "arch-utils.h".
	(set_raw_breakpoint): Update external definition.
	(gdb_set_bp): Adapt to set_raw_breakpoint change.
	(gdb_set_bp_addr): Likewise.
	* generic/gdbtk-cmds.c: Include "arch-utils.h.
	(gdbtk_load_asm): Adapt to paddress and gdb_print_insn changes.
	(hex2bin): Replace current_gdbarch by get_current_arch call.
	(gdb_update_mem): Adapt to builtin_type changes.
	(gdb_CA_to_TAS): Use paddress to replace removed function paddr_nz.
	* generic/gdbtk-register.c: Include "arch-utils.h".
	(get_register_size): Replace current_gdbarch by get_current_arch call.
	(get_register_types): Likewise.
	(get_register): Likewise.
	(get_register_name): Likewise.
	(map_arg_registers): Likewise.
	(register_changed_p): Likewise.
	(setup_architecture_data): Likewise.
	(gdb_regformat): Likewise.
	(gdb_reggrouplist): Likewise.
	(gdb_reggroup): Likewise.
	* generic/gdbtk-stack.c: Inlcude "arch-utils.h".
	(gdb_get_blocks): Use paddress instead of removed paddr_nz function.
	(gdb_selected_block): Likewise.
	(gdb_selected_frame): Likewise.
@
text
@d2 1
a2 1
   Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2001, 2002, 2003, 2004, 2007, 2008
d1903 1
a1903 1
  print_address_symbolic (pc, gdb_stdout, 1, "\t");
@


1.112
log
@	* generic/gdbtk-cmds.c (gdb_update_mem): Dispatch
	TARGET_OBJECT_MEMORY reads to the topmost target, not to the
	flattened current_target.
@
text
@d48 1
d1899 1
a1899 1
  fputs_filtered (paddress (pc), gdb_stdout);
d1908 1
a1908 1
  insn = gdb_print_insn (pc, gdb_stdout, NULL);
d2275 1
a2275 1
  if (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_LITTLE)
d2470 1
a2470 1
      val_type = builtin_type_int8;
d2474 1
a2474 1
      val_type = builtin_type_int16;
d2478 1
a2478 1
      val_type = builtin_type_int32;
d2482 1
a2482 1
      val_type = builtin_type_int64;
d2486 1
a2486 1
      val_type = builtin_type_int8;
d3015 4
a3018 1
  Tcl_SetStringObj (result_ptr->obj_ptr, paddr_nz (address), -1);
@


1.111
log
@	* Adapt to VALUE_ADDRESS removal.
	generic/gdbtk-cmds.c (gdb_eval): Use value_address function instead of
	VALUE_ADDRESS macro.
@
text
@d2451 3
a2453 1
  rnum = target_read (&current_target, TARGET_OBJECT_MEMORY, NULL,
@


1.110
log
@	* Adapt to read_pc function removal.
	* generic/gdbtk-cmds.c: Add "cache.h" include.
	(gdb_loc): Use regcache_read_pc instead of read_pc.
@
text
@d640 1
a640 1
	     value_embedded_offset (val), VALUE_ADDRESS (val),
@


1.109
log
@	ARI fix: Use "gdb_stat.h" header instead of <sys/stat.h>.
	* generic/gdbtk-cmds.c: Apply change.
	* generic/gdbtk.c: Ditto.
@
text
@d47 1
d2145 1
d2148 4
a2151 2

	  if (get_frame_pc (frame) != read_pc ())
d2159 1
a2159 1
	      pc = get_frame_pc (frame);
d2164 1
a2164 1
	      pc = read_pc ();
@


1.108
log
@	ARI fixes: xvasprintf and strdup rules.
	* generic/gdbtk-cmds.c (gdbtk_set_result): Replace xvasprintf by
	xstrvprintf.
	* generic/gdbtk-hooks.c (gdbtk_warning): Ditto.
	(gdbtk_readline_begin, gdbtk_query): Ditto.
	* generic/gdbtk.c (TclDebug): Ditto.
	* generic/gdbtk-varobj.c (variable_create): Replace strdup by xstrdup.
@
text
@d66 1
a66 1
#include <sys/stat.h>
@


1.107
log
@	ARI fix: "xasprintf" rule.
	* generic/gdbtk-bp.c (gdb_set_bp): Replace xasprintf by xstrprintf.
	(breakpoint_notify, tracepoint_notify):Ditto.
	* generic/gdbtk-cmds.c (gdbtk_load_source, gdbtk_load_asm):Ditto.
	* generic/gdbtk-hooks.c (gdbtk_ignorable_warning): Ditto.
	(gdbtk_set_hook, gdbtk_load_hash): Ditto.
	(gdbtk_selected_frame_changed, gdbtk_annotate_signal): Ditto.
	* generic/gdbtk-register.c (get_register_types):Ditto.
	* generic/gdbtk-stack.c (gdb_get_blocks): Ditto.
	(gdb_selected_block, gdb_selected_frame): Ditto.
	* generic/gdbtk.c (gdbtk_init, view_command): Ditto.
@
text
@d2914 1
a2914 1
  xvasprintf (&buf, fmt, args);
@


1.106
log
@	* generic/gdbtk-cmds.c (valprint.h): Include.
	(gdb_eval): Fetch print options via get_formatted_print_options.
	Update call to val_print.
	(gdb_update_mem): Likewise, but for print_scalar_formatted.
	* generic/gdbtk-register.c (valprint.h): Include.
	(get_register): Use get_formatted_print_options.  Update calls
	to val_print.
	* generic/gdbtk-wrapper.c (valprint.h): Include.
	(wrap_val_print): Use get_formatted_print_options.  Delete
	variables deref_ref and pretty; assign to equivalent fields
	in the value_print_options struct instead.  Update call to
	val_print.
@
text
@d1814 1
a1814 1
	      xasprintf (&buffer, "%d", client_data->widget_line_no);
d1930 1
a1930 1
      xasprintf (&buffer, "%d", client_data->widget_line_no);
@


1.105
log
@        * generic/gdbtk-cmds.c (gdb_clear_file): The global "attach_flag"
        is now per-inferior.
@
text
@d46 1
d618 1
d629 2
d640 1
a640 1
	     stb, format, 0, 0, 0, current_language);
d2536 4
d2542 1
a2542 1
	  print_scalar_formatted (mptr, val_type, format, asize, stb);
@


1.104
log
@        From Pedro Alves  <pedro@@codesourcery.com>:
        * generic/gdbtk-cmds.c (gdb_cmd, gdb_immediate_command): Adjust to
        new bpstat_do_actions inferface.
        * generic/gdbtk-hooks.c: Include gdbthread.h.
        (gdbtk_annotate_signal): Get the stop_signal from the current
        thread.
@
text
@d459 2
a460 1
      if (attach_flag)
@


1.103
log
@        * generic/gdbtk-cmds.c (gdb_listfuncs): Use SYMBOL_PRINT_NAME
        instead of DEPRECATED_SYMBOL_NAME.
        * generic/gdbtk-stack.c (gdb_block_vars): Likewise.
        (gdb_get_vars_command): Likewise.
        * generic/gdbtk.h (GDBTK_SYMBOL_SOURCE_NAME): Likewise.
@
text
@d704 1
a704 1
  bpstat_do_actions (&stop_bpstat);
d755 1
a755 1
  bpstat_do_actions (&stop_bpstat);
@


1.102
log
@        * generic/gdbtk-cmds.c: Don't include itcl.h.
        * generic/gdbtk-hooks.c: Likewise.
        * generic/gdbtk.c: Include tcl.h and tk.h instead of itcl.h
        and itk.h.
        (gdbtk_init): Rewrite to accommodate using a system-provided
        Tcl, Tk, Itcl, Itk.
        (gdbtk_source_start_file) [!_WIN32]: Don't call error() when
        we fail to source the start file. Just dump the message to stderr.
        Throw an exception indicating the failure.
        * library/ehandler.itb (GDBEventHander::dispatch): "itcl_info" is
        deprecated: use "itcl::find objects" instead.
        * library/managedwin.itb (window_instance): Ditto.
        (restart): Ditto.
        (shutdown): Ditto.
        (_open): Ditto.
        (find): Ditto.
        * library/globalpref.itb (_build_win): Don't pass config arguments
        for libgui widgets to the constructor. Configure the widget after
        creation.
        * library/srcpref.itb (_build_win): Ditto.
        * library/main.tcl: Update Tcl, Tk, Itcl, Itk, and Iwidgets (just
        added to this loop) version requirements.
        No need to initialize Iwidgets separately.
        * plugins/Make-rules (TCLHDIR): Renamed to TCL_INCLUDES. Change
        all references.
        (TCL_BUILD_LIB_SPEC): Renamed to TCL_LIBRARY. Change all references.
        * plugins/acinclude.m4: Include the standard tcl.m4 instead
        of the sourceware-derived one.
        * plugins/configure.ac: Use Tcl's standard SC_* macros instead of
        the sourceware-derived CYG_AC_* macros.
        Add logic to deal with using a system-supplied Tcl/Tk.
        * plugins/configure: Regenerated.
        * plugins/Makefile.in: Regenerated.
@
text
@d1498 1
a1498 1
		  funcVals[0] = Tcl_NewStringObj (DEPRECATED_SYMBOL_NAME (sym), -1);
@


1.101
log
@        * generic/gdbtk-stack.c (gdb_block_args): Remove deprecated values
        LOC_LOCAL_ARG, LOC_COMPUTED_ARG, LOC_REGPARM, LOC_BASEARG_ARG, and
        LOC_BASEARG.
        (gdb_get_blocks): Likewise.
        (gdb_get_vars_command): Likewise.
        Fix type-punned pointer error introduced on 03-07.

        * generic/gdbtk-cmds.c (gdbtk_load_asm): Use paddress instead
        of deprecated_print_address_numeric.
        (gdb_stop): Update use of target_stop.

        * generic/gdbtk.h (gdbtk_get_ptid): Declare new function.
        * generic/gdbtk-hooks.c (gdbtk_wait): Save inferior's ptid.
        (gdbtk_get_ptid): Define new function.
        * generic/gdbtk-varobj.c (variable_update): Update for recent
        varobj_update API change.
        * generic/gdbtk-wrapper.h (GDB_varobj_update): Likewise.
        * generic/gdbtk-wrapper.c (GDB_varobj_update): Likewise.
        (wrap_varobj_update): Likewise.

        * library/targetselection.itb (init_target_db): Initialize
        preferences here instead of ...
        (_init): ... here.
        (_init_prefs): Define gdb/load/default-portname, too.
@
text
@a50 1
#include <itcl.h>
@


1.100
log
@	* Update uses of val_print functions with additional language argument.
	generic/gdbtk-cmds.c: Add "language.h" include.
	(gdb_eval): Add current_language as new arg of val_print.
	generic/gdbtk-register.c: Add "language.h" include.
	(get_register): Add current_language as new arg of val_print.
	generic/gdbtk-wrapper.c: Add "language.h" include.
	(wrap_val_print): Add current_language as new arg of val_print.
@
text
@d45 1
d571 2
a572 2
      if (target_stop != target_ignore)
	target_stop ();
d1893 1
a1893 1
  deprecated_print_address_numeric (pc, 1, gdb_stdout);
@


1.99
log
@        * generic/gdbtk-cmds.c (symtab_to_filename): Call gdb's
        open_source_file instead of find_and_open_source.
@
text
@d44 1
d635 1
a635 1
	     stb, format, 0, 0, 0);
@


1.98
log
@        From Dave Murphy  <davem@@devkitpro.org>:
        * gdbtk-cmds.c: Guard <sys/ioctl.h> with HAVE_SYS_IOCTL_H.
        * gdbtk-hooks.c: Ditto.
        * gdbtk.c: Ditto.
        * gdbtk-interp.c: Include windows.h under mingw32.
        (gdbtk_start_timer, gdbtk_stop_timer): Remove timer calls under mingw.
        (gdbtk_init): Include windows-specific commands under mingw without
        cygwin path commands.
        * library/download.itb (Download::download_it): Only use ide_cygwin_path
        on cygwin hosts.
        * library/interface.tcl (_open_file): Ditto.
        * library/prefs.tcl (pref_read): Ditto.
        * library/targetselection.itb (TargetSelection::default_port): Default
        to "/dev/com1" under cygwin and "COM1" under mingw.
        (TargetSelection::port_list): Use "/dev/com" under cygwin and
        "COM" under mingw.
@
text
@d2 1
a2 1
   Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2001, 2002, 2003, 2004, 2007
a3006 3
int find_and_open_source (struct objfile *objfile, const char *filename,
			  const char *dirname, char **fullname);

a3009 1

d3017 1
a3017 2
  r = find_and_open_source (s->objfile, s->filename, s->dirname,
			    &s->fullname);
@


1.97
log
@gdb/:
* disasm.c (gdb_print_insn): Return the number of branch delay
slot instructions too.
* disasm.h (gdb_print_insn): Update prototype.
* printcmd.c (branch_delay_insns): New variable to record the
number of delay slot instructions after disassembling a branch.
(print_formatted): Record the number of branch delay slot
instructions.
(do_examine): When disassembling, if the last instruction
disassembled has any branch delay slots, then bump the count so
that they get disassembled too.
* tui/tui-disasm.c (tui_disassemble): Update the call to
gdb_print_insn().
* NEWS: Document the new behaviour.

gdb/doc/:
* gdb.texinfo (Examining Memory): Document the new behaviour.

gdb/gdbtk/:
* generic/gdbtk-cmds.c (gdbtk_load_asm): Update the call to
gdb_print_insn().
@
text
@d60 1
d62 1
@


1.96
log
@        * generic/gdbtk-cmds.c (hex2bin): Use gdbarch_byte_order instead
        of TARGET_BYTE_ORDER.
        * generic/gdbtk-register.c (get_register): Likewise.
        (map_arg_registers): Use gdbarch_num_regs and gdbarch_num_pseduo_regs
        instead of NUM_REGS and NUM_PSEUDO_REGS.
        (setup_architecture_data): Likewise.
        (gdb_regformat): Likewise.
        (gdb_reggroup): Likewise.
@
text
@d1898 1
a1898 1
  insn = gdb_print_insn (pc, gdb_stdout);
@


1.95
log
@gdb/:
* Makefile.in (gdbtk-wrapper.o): Update dependencies.
(gdbtk-varobj.o, gdbtk-cmds.o, gdbtk-stack.o): Likewise.

gdb/gdbtk/:
* generic/gdbtk-wrapper.c (GDB_varobj_update): New function.
(wrap_varobj_update): Likewise.
* generic/gdbtk-wrapper.h (GDB_varobj_update): New declaration.
* generic/gdbtk-varobj.c (variable_update): Call
GDB_varobj_update() rather than varobj_update() directly.  Take
the new semantics of the latter into account.
* generic/gdbtk-cmds.c: Include "varobj.h".
* generic/gdbtk-stack.c: Likewise.
@
text
@d2 1
a2 1
   Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2001, 2002, 2003, 2004
d2262 1
a2262 1
  if (TARGET_BYTE_ORDER == BFD_ENDIAN_LITTLE)
@


1.94
log
@Eliminate use of `deprecated_selected_frame'.
@
text
@d42 1
@


1.93
log
@* generic/gdbtk-cmds.c (gdb_update_mem): Use target_read.
@
text
@d2132 22
a2153 11
      else if (deprecated_selected_frame
	       && (get_frame_pc (deprecated_selected_frame) != read_pc ()))
        {
          /* Note - this next line is not correct on all architectures.
	     For a graphical debugger we really want to highlight the 
	     assembly line that called the next function on the stack.
	     Many architectures have the next instruction saved as the
	     pc on the stack, so what happens is the next instruction 
	     is highlighted. FIXME */
	  pc = get_frame_pc (deprecated_selected_frame);
	  find_frame_sal (deprecated_selected_frame, &sal);
a2154 5
      else
        {
          pc = read_pc ();
          sal = find_pc_line (pc, 0);
        }
@


1.92
log
@	* generic/gdbtk-cmds.c: Include sys/cygwin.h if __CYGWIN__ defined.
	(gdb_path_conv): Call cygwin_conv_to_full_win32_path instead.
@
text
@d2432 3
a2434 2
  rnum = 0;
  while (rnum < nbytes)
d2436 2
a2437 6
      int error;
      int num = target_read_memory_partial (addr + rnum, mbuf + rnum,
					    nbytes - rnum, &error);
      if (num <= 0)
	break;
      rnum += num;
@


1.91
log
@	* generic/gdbtk.h:
	* generic/gdbtk.c:
	* generic/gdbtk-wrapper.h:
	* generic/gdbtk-wrapper.c:
	* generic/gdbtk-varobj.c:
	* generic/gdbtk-stack.c:
	* generic/gdbtk-register.c:
	* generic/gdbtk-main.c:
	* generic/gdbtk-interp.c:
	* generic/gdbtk-hooks.c:
	* generic/gdbtk-cmds.h:
	* generic/gdbtk-cmds.c:
	* generic/gdbtk-bp.c: Put (C) after Copyright.  Update the FSF
	address.
@
text
@d67 4
d2832 1
a2832 1
    cygwin32_conv_to_full_win32_path (Tcl_GetStringFromObj (objv[1], NULL),
@


1.90
log
@        From Steven Johnson  <sjohnson@@sakraindustries.com>:
        * generic/gcbtk-cmds.c (gdb_loc): Hand gdb_loc called before remote
        target connected, where gdb_loc now returns the entry address as $pc.
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2001, 2002, 2003, 2004
d23 2
a24 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.89
log
@        * generic/gdbtk-cmds.c (gdb_set_mem): target_write_memory now takes
        gdb_byte* instead of char*.
        * generic/gdbtk-register.c (get_register): frame_register and val_print
        take gdb_byte* instead of char*.
        * generic/gdbtk-wrapper.c: Ditto the val_print part.

        From Paul Schlie  <schlie@@comcast.net>:
        * generic/gdbtk-bp.c (gdb_set_bp): Use lbasename instead of basename.
        * generic/gdbtk-cmds.c (gdb_listfiles): Likewise.
@
text
@d2118 12
a2129 2
      if (deprecated_selected_frame
	  && (get_frame_pc (deprecated_selected_frame) != read_pc ()))
@


1.88
log
@2005-02-16  Martin Hunt  <hunt@@redhat.com>

	* generic/gdbtk-stack.c (get_frame_name): Replace
	print_address_numeric with deprecated_print_address_numeric.
	* generic/gdbtk-cmds.c (gdbtk_load_asm): Ditto.
@
text
@d1123 2
a1124 1
  char *lastfile, *pathname = NULL, **files;
d1129 1
a1129 1
  files = (char **) xmalloc (sizeof (char *) * files_size);
d1144 1
a1144 1
	  files = (char **) xrealloc (files, sizeof (char *) * files_size);
d1149 1
a1149 1
	      || !strcmp (psymtab->filename, basename (psymtab->filename)))
d1151 1
a1151 1
	      files[numfiles++] = basename (psymtab->filename);
d1161 1
a1161 1
	  files = (char **) xrealloc (files, sizeof (char *) * files_size);
d1166 1
a1166 1
	      || !strcmp (symtab->filename, basename (symtab->filename)))
d1168 1
a1168 1
	      files[numfiles++] = basename (symtab->filename);
d2282 1
a2282 1
  char buf[128];
d2307 1
a2307 1
  size = hex2bin (hexstr, buf, strlen (hexstr));
@


1.87
log
@        * generic/gdbtk-cmds.c (gdb_eval): VALUE_EMBEDDED_OFFSET and
        VALUE_CONTENTS are now functions.
@
text
@d1883 1
a1883 1
  print_address_numeric (pc, 1, gdb_stdout);
@


1.86
log
@        * generic/gdbtk-varobj.c (variable_value): Remove all instances
        of error_last_message. It's gone.

        * generic/gdbtk-wrapper.c: Include exceptions.h
        * generic/gdbtk-cmds.c: Likewise.
        * generic/gdbtk-interp.c: Likewise.
        (gdbtk_interpreter_exec): Change return type to struct
        exception. Return exception_none.
@
text
@d625 2
a626 2
  val_print (value_type (val), VALUE_CONTENTS (val),
	     VALUE_EMBEDDED_OFFSET (val), VALUE_ADDRESS (val),
@


1.85
log
@	Remove some warnings:
	* generic/gdbtk-hooks.c (gdbtk_pre_add_symbol): Cast `name'.
	* generic/gdbtk-cmds.c (gdbtk_dis_asm_read_memory): Remove.
@
text
@d42 1
@


1.84
log
@        * generic/gdbtk-wrapper.c (wrap_type_print): Use value_type instead
        of VALUE_TYPE.
        * generic/gdbtk-cmds.c (gdb_eval): Likewise.
@
text
@a182 2
static int gdbtk_dis_asm_read_memory (bfd_vma, bfd_byte *, unsigned int,
				      disassemble_info *);
a2077 21
/* This is the memory_read_func for gdb_disassemble_driver when we are
   disassembling from the exec file. */

static int
gdbtk_dis_asm_read_memory (bfd_vma memaddr, bfd_byte *myaddr,
			   unsigned int len, disassemble_info *info)
{
  extern struct target_ops exec_ops;
  int res;

  errno = 0;
  res = xfer_memory (memaddr, myaddr, len, 0, 0, &exec_ops);

  if (res == len)
    return 0;
  else if (errno == 0)
    return EIO;
  else
    return errno;
}

@


1.83
log
@2004-07-02  Martin Hunt  <hunt@@redhat.com>

	* generic/gdbtk-cmds.c (symtab_to_filename): New function. Like
	symtab_to_fullname() but returns the filename if the fullname
	cannot be found.

	* generic/gdbtk-cmds.c (gdb_find_file_command): Revert
	patch of 2004-06-11. Use symtab_to_filename() again.
	(gdb_loc): Ditto.
	(gdb_loadfile): Ditto.
	* generic/gdbtk-bp.c (gdb_get_breakpoint_info): Ditto.
	(gdb_get_tracepoint_info): Ditto.

	* generic/gdbtk-cmds.h: Declare symtab_to_filename().
@
text
@d41 1
d626 1
a626 1
  val_print (VALUE_TYPE (val), VALUE_CONTENTS (val),
@


1.82
log
@2004-06-25  Andrew Cagney  <cagney@@gnu.org>

	* generic/gdbtk.h: "ui_loop_hook" was deprecated, update.
	* generic/gdbtk-hooks.c (gdbtk_add_hooks, x_event): Ditto.
	* generic/gdbtk-cmds.c: Ditto.
@
text
@d1082 1
a1082 1
	(st->fullname == NULL ? symtab_to_fullname (st) : st->fullname);
d2192 1
a2192 1
  filename = symtab_to_fullname (sal.symtab);
d2650 1
a2650 1
  file = symtab_to_fullname ( symtab );
d3002 28
@


1.81
log
@	* generic/gdbtk-cmds.c (gdb_load_info): Use bfd_get_section_size
	instead of bfd_get_section_size_before_reloc.
@
text
@d520 3
a522 3
 * The global GDBTK_FORCE_DETACH is set when we wish to detach
 * from a target. This value is returned by ui_loop_hook (x_event),
 * indicating to callers that they should detach.
@


1.80
log
@2004-06-11  Martin Hunt  <hunt@@redhat.com>

	* generic/gdbtk-cmds.c (gdb_find_file_command): Use
	symtab_to_fullname() instead of symtab_to_filename().
	(gdb_loc): Ditto.
	(gdb_loadfile): Ditto.
	* generic/gdbtk-bp.c (gdb_get_breakpoint_info): Ditto.
	(gdb_get_tracepoint_info): Ditto.

	* generic/gdbtk-register.c (get_register): Simplify and remove
	references to DEPRECATED_REGISTER_CONVERT_TO_VIRTUAL.
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2001, 2002, 2003
d899 1
a899 1
	  bfd_size_type size = bfd_get_section_size_before_reloc (s);
@


1.79
log
@
2003-12-17  Jeff Johnston  <jjohnstn@@redhat.com>

        * generic/gdbtk-bp.c: Change calls to decode_line_1 to add
        new NULL parameter.
        * generic/gdbtk-cmds.c: Ditto.
        * generic/gdbtk-stack.c: Ditto.
@
text
@d1082 1
a1082 1
	(st->fullname == NULL ? symtab_to_filename (st) : st->fullname);
d2192 1
a2192 1
  filename = symtab_to_filename (sal.symtab);
d2650 1
a2650 1
  file = symtab_to_filename ( symtab );
@


1.78
log
@2003-11-24  David Carlton  <carlton@@kealia.com>

	* generic/gdbtk.c (target_is_native): Replace STREQ by strcmp.
	* generic/gdbtk-cmds.c (gdb_stop): Replace STREQ by strcmp.
	(gdb_search): Replace STREQN by strncmp and DEPRECATED_SYMBOL_NAME
	by SYMBOL_LINKAGE_NAME.
	* generic/gdbtk-varobj.c (variable_format): Replace STREQN by
	strncmp.
@
text
@d941 1
a941 1
  sals = decode_line_1 (&args, 1, NULL, 0, &canonical);
d977 1
a977 1
  sals = decode_line_1 (&args, 1, NULL, 0, &canonical);
d1013 1
a1013 1
  sals = decode_line_1 (&args, 1, NULL, 0, &canonical);
@


1.77
log
@2003-09-08  Andrew Cagney  <cagney@@redhat.com>

	* generic/gdbtk-cmds.c: Include "disasm.h".
	(gdbtk_load_asm): Use "gdb_print_insn" instead of
	TARGET_PRINT_INSN .
	(gdb_disassemble_driver): Delete code referencing
	"deprecated_tm_print_insn_info".  Delete "di" and "di_initialized"
	and any code initializing those variables.  Pass NULL as "di"
	parameter to "print_asm_fn".
	(disassemble_from_exec): Mention that it is unused.
@
text
@d550 1
a550 1
      if (STREQ (s, "detach"))
d1368 3
a1370 2
      if ((p->symbol != NULL && !STREQN (DEPRECATED_SYMBOL_NAME (p->symbol), "__tf", 4)
	   && !STREQN (DEPRECATED_SYMBOL_NAME (p->symbol), "_GLOBAL_", 8))
@


1.76
log
@        From Roland Schwingel <Roland.Schwingel@@onevision.de>:
        * generic/gdbtk-cmds.c (gdb_find_file_command): If filename
        is already an absolute filename, try stat'ing it before searching
        symtabs.
@
text
@d40 1
d116 3
a118 3
/* This variable determines where memory used for disassembly is read from.
 * See note in gdbtk.h for details.
 */
d1851 1
d1890 2
a1891 1
  insn = TARGET_PRINT_INSN (pc, di);
a1948 61
  static disassemble_info di;
  static int di_initialized;

  if (! di_initialized)
    {
      INIT_DISASSEMBLE_INFO_NO_ARCH (di, gdb_stdout,
                                     (fprintf_ftype) fprintf_unfiltered);
      di.flavour = bfd_target_unknown_flavour;
      /* NOTE: cagney/2003-04: This all goes away, along with this
         function, when insight starts using the "disasm.h"
         disassembler.  */
      di.memory_error_func = deprecated_tm_print_insn_info.memory_error_func;
      di.print_address_func = deprecated_tm_print_insn_info.print_address_func;
      di_initialized = 1;
    }

  di.mach = deprecated_tm_print_insn_info.mach;
  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
    di.endian = BFD_ENDIAN_BIG;
  else
    di.endian = BFD_ENDIAN_LITTLE;

  /* Set the architecture for multi-arch configurations. */
  if (TARGET_ARCHITECTURE != NULL)
    di.mach = TARGET_ARCHITECTURE->mach;

  /* If disassemble_from_exec == -1, then we use the following heuristic to
     determine whether or not to do disassembly from target memory or from the
     exec file:

     If we're debugging a local process, read target memory, instead of the
     exec file.  This makes disassembly of functions in shared libs work
     correctly.  Also, read target memory if we are debugging native threads.

     Else, we're debugging a remote process, and should disassemble from the
     exec file for speed.  However, this is no good if the target modifies its
     code (for relocation, or whatever).

     As an aside, it is fairly bogus that there is not a better way to
     determine where to disassemble from.  There should be a target vector
     entry for this or something.
     
  */

  if (disassemble_from_exec == -1)
    {
      if (strcmp (target_shortname, "child") == 0
          || strcmp (target_shortname, "procfs") == 0
          || strcmp (target_shortname, "vxprocess") == 0
	  || strstr (target_shortname, "thread") != NULL)
	/* It's a child process, read inferior mem */
        disassemble_from_exec = 0; 
      else
	/* It's remote, read the exec file */
        disassemble_from_exec = 1; 
    }

  if (disassemble_from_exec)
    di.read_memory_func = gdbtk_dis_asm_read_memory;
  else
    di.read_memory_func = deprecated_tm_print_insn_info.read_memory_func;
d2057 3
a2059 1
	      pc = print_asm_fn (clientData, pc, &di);
d2069 3
a2071 1
	  pc = print_asm_fn (clientData, pc, &di);
@


1.75
log
@2003-06-11  David Carlton  <carlton@@bactrian.org>

	* dictionary.h: New.
	* dictionary.c: New.
	* block.h: Add opaque declaration for struct dictionary.
	(struct block): Add 'dict' member; delete 'hashtable', 'nsyms',
	'sym' members.
	(BLOCK_DICT): New macro.
	Delete macros BLOCK_HASHTABLE, BLOCK_NSYMS, BLOCK_SYM,
	BLOCK_BUCKETS, BLOCK_BUCKET, BLOCK_HASHTABLE_SIZE,
	BLOCK_SHOULD_SORT.
	(ALL_BLOCK_SYMBOLS): Update definition.
	* Makefile.in (SFILES): Add dictionary.c.
	(dictionary_h): New.
	(COMMON_OBS): Add dictionary.o.
	(dictionary.o): New.
	(ada-lang.o): Depend on dictionary_h.
	(buildsym.o, coffread.o, jv-lang.o, mdebugread.o, objfiles.o)
	(stack.o, symmisc.o, symtab.o, tracepoint.o, valops.o)
	(mi-cmd-stack.o): Ditto.
	(gdbtk-cmds.o): Update dependencies.
	(gdbtk-stack.o): Ditto.
	* ada-lang.c: Include dictionary.h.
	(symtab_for_sym): Update uses of ALL_BLOCK_SYMBOLS.
	(fill_in_ada_prototype, debug_print_block): Ditto.
	(ada_add_block_symbols): Update uses of ALL_BLOCK_SYMBOLS; replace
	explicit iteration by use of ALL_BLOCK_SYMBOLS.  Delete variable
	'is_sorted'.
	* mdebugread.c: Include dictionary.h.
	(struct parse_stack): Delete 'maxsyms' member.
	(parse_symbol): Update calls to new_block.  Delete calls to
	shrink_block.  Use dictionary methods.
	(psymtab_to_symtab_1): Delete calls to sort_symtab_syms.
	Update calls to new_symtab.  Don't maintain maxsyms data.
	(mylookup_symbol): Update use of ALL_BLOCK_SYMBOLS.
	(add_symbol): Just call dict_add_symbol.
	(new_symtab): Delete 'maxsyms' argument.
	(new_symtab): Update calls to new_block.
	(new_block): Delete 'maxsyms' argument; add 'function' argument.
	(shrink_block): Delete function.
	(fixup_sigtramp): Update call to new_block.  Add symbol via
	dict_add_symbol.
	* jv-lang.c: Include dictionary.h.
	(get_java_class_symtab): Set the BLOCK_DICT of the blocks
	appropriately.  Set class_symtab->free_func.  Make sure the
	blockvector is big enough to hold two blocks.
	(add_class_symtab_symbol): Use dictionary methods.
	(free_class_block): New function.
	(type_from_class): Replace explicit iteration by
	ALL_BLOCK_SYMBOLS.
	* symtab.h (struct symtab): Replace 'free_ptr' method by
	'free_func'.
	* dwarf2read.c (psymtab_to_symtab_1): Delete call to
	sort_symtab_syms.
	* dwarfread.c (psymtab_to_symtab_1): Delete call to
	sort_symtab_syms.
	* coffread.c (coff_symfile_read): Delete call to sort_symtab_syms.
	Include dictionary.h.
	(patch_opaque_types): Update use of ALL_BLOCK_SYMBOLS.
	* dbxread.c (dbx_psymtab_to_symtab_1): Delete call to
	sort_symtab_syms.
	* objfiles.c: Include dictionary.h.
	(objfile_relocate): Update use of ALL_BLOCK_SYMBOLS.
	* buildsym.c: Include dictionary.h.
	(finish_block): Use dictionary methods.
	(end_symtab): Set free_func to NULL, not free_ptr.
	* tracepoint.c: Include dictionary.h.
	(add_local_symbols): Update use of ALL_BLOCK_SYMBOLS.
	(scope_info): Ditto.
	* stack.c: Include dictionary.h.
	(print_block_frame_locals): Update use of ALL_BLOCK_SYMBOLS.
	(print_block_frame_labels, print_frame_arg_vars)
	(print_frame_args): Ditto.
	* symmisc.c (free_symtab_block): Use dictionary methods.
	(dump_symtab): Ditto.
	(free_symtab): Replace use of 'free_ptr' by 'free_func'.
	Include	dictionary.h.
	* symfile.h: Delete declarations of sort_block_syms,
	sort_symtab_syms.
	* symfile.c (sort_block_syms): Delete.
	(sort_symtab_syms): Delete.
	* symtab.c: Include dictionary.h.
	(lookup_block_symbol): Use dictionary iterators.
	(find_pc_sect_symtab): Update use of ALL_BLOCK_SYMBOLS.
	(search_symbols, make_symbol_completion_list): Ditto.
	(make_symbol_overload_list): Ditto.
	* valops.c (value_of_local): Use dict_empty.
	Include dictionary.h.

2003-06-11  David Carlton  <carlton@@bactrian.org>

	* generic/gdbtk-stack.c: Include dictionary.h.
	(gdb_block_vars): Update use of ALL_BLOCK_SYMBOLS.
	(gdb_get_blocks, gdb_get_vars_command): Ditto.
	* generic/gdbtk-cmds.c: Include dictionary.h.
	(gdb_listfuncs): Update use of ALL_BLOCK_SYMBOLS.

2003-06-11  David Carlton  <carlton@@bactrian.org>

	* mi-cmd-stack.c: Include dictionary.h.
	(list_args_or_locals): Update use of ALL_BLOCK_SYMBOLS.
@
text
@d39 1
d1041 1
a1041 1
  char *filename, *fullname;
a1049 1
  st = lookup_symtab (filename);
d1051 7
a1057 2
  /* We should always get a symtab. */
  if (!st)
d1059 8
a1066 2
      gdbtk_set_result (interp, "File not found in symtab (2)");
      return TCL_ERROR;
d1068 4
d1073 6
a1078 4
  if (st->fullname == NULL)
    fullname = symtab_to_filename (st);
  else
    fullname = st->fullname;
d1080 4
@


1.75.2.1
log
@        From Roland Schwingel <Roland.Schwingel@@onevision.de>:
        * generic/gdbtk-cmds.c (gdb_find_file_command): If filename
        is already an absolute filename, try stat'ing it before searching
        symtabs.
@
text
@a38 1
#include "filenames.h"
d1040 1
a1040 1
  char *filename, *fullname = NULL;
d1049 1
d1051 2
a1052 7
  /* Shortcut: There seems to be some mess in gdb dealing with
     files. While we should let gdb sort it out, it doesn't hurt
     to be a little defensive here.

     If the filename is already an absolute filename, just try
     to stat it. If it's not found, then ask gdb to find it for us. */
  if (IS_ABSOLUTE_PATH (filename))
d1054 3
a1056 2
      struct stat st;
      const int status = stat (filename, &st);
d1058 2
a1059 6
      if (status == 0)
	{
	  if (S_ISREG (st.st_mode))
	    fullname = filename;
	}
    }
d1061 1
a1061 3
    {
      /* Ask gdb to find the file for us. */
      st = lookup_symtab (filename);
a1062 11
      /* We should always get a symtab. */
      if (!st)
	{
	  gdbtk_set_result (interp, "File not found in symtab (2)");
	  return TCL_ERROR;
	}

      fullname =
	(st->fullname == NULL ? symtab_to_filename (st) : st->fullname);
    }
  
@


1.74
log
@2003-05-12  Elena Zannoni  <ezannoni@@redhat.com>

        * generic/gdbtk-cmds.c (gdb_search): Replace namespace_enum
        with domain_emum, and *_NAMESPACE with *_DOMAIN.
@
text
@d38 1
d1406 2
a1407 1
  int i, j;
d1438 1
a1438 1
      ALL_BLOCK_SYMBOLS (b, j, sym)
@


1.73
log
@2003-04-30  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (deprecated_tm_print_insn_info): Rename
	"tm_print_insn_info".
	(TARGET_PRINT_INSN_INFO): Delete macro.
	(dis_asm_read_memory): Delete function declaration.
	(dis_asm_memory_error, dis_asm_print_address): Ditto.
	(tm_print_insn_info): Delete variable definition.
	(_initialize_gdbarch): Do not initialize "tm_print_insn_info".
	* gdbarch.h, gdbarch.c: Re-generate.
	* d10v-tdep.c (display_trace): Replace "tm_print_insn_info" with
	"deprecated_tm_print_insn_info".
	* mcore-tdep.c (mcore_dump_insn): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* sparc-tdep.c (_initialize_sparc_tdep): Ditto.
	* v850-tdep.c (v850_scan_prologue, v850_gdbarch_init): Ditto.
	* ia64-tdep.c (_initialize_ia64_tdep): Ditto.
	* printcmd.c (print_insn): Use "deprecated_tm_print_insn_info"
	instead of TARGET_PRINT_INSN_INFO, add comment.
	* s390-tdep.c (s390_get_frame_info): Instead of
	"dis_asm_read_memory", use "deprecated_tm_print_insn_info".
	(s390_check_function_end, s390_is_sigreturn): Ditto.
	* corefile.c (dis_asm_read_memory): Move to "disasm.c".
	(dis_asm_memory_error, dis_asm_print_address): Ditto.
	* disasm.c: Include "gdbcore.h".
	(_initialize_disasm): New function, initialize
	"deprecated_tm_print_insn_info".
	(deprecated_tm_print_insn_info): New variable.
	(dis_asm_read_memory): Moved from "corefile.c", made static.
	(dis_asm_print_address, dis_asm_memory_error): Ditto.
	* Makefile.in (disasm.o): Update dependencies.

2003-04-28  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	read_fp, TARGET_READ_FP and FP_REGNUM, with deprecated_read_fp,
	DEPRECATED_TARGET_READ_FP and DEPRECATED_REGNUM.
@
text
@d1202 1
a1202 1
  namespace_enum space = 0;
d1239 1
a1239 1
      space = FUNCTIONS_NAMESPACE;
d1242 1
a1242 1
      space = VARIABLES_NAMESPACE;
d1245 1
a1245 1
      space = TYPES_NAMESPACE;
@


1.72
log
@2003-03-06  Martin M. Hunt  <hunt@@redhat.com>

	* generic/gdbtk-interp.c (gdbtk_interpreter_init): Remove
	unused variable.

	* generic/gdbtk-cmds.c (gdb_update_mem): Remove unused variable.
	(gdbtk_print_source): Deleted.
	(gdbtk_print_asm): Deleted.
@
text
@d1931 5
a1935 2
      di.memory_error_func = dis_asm_memory_error;
      di.print_address_func = dis_asm_print_address;
d1939 1
a1939 1
  di.mach = TARGET_PRINT_INSN_INFO->mach;
d1983 1
a1983 1
    di.read_memory_func = dis_asm_read_memory;
@


1.71
log
@2003-03-06  Martin M. Hunt  <hunt@@redhat.com>

	* generic/gdbtk-cmds.c (gdb_disassemble): Deleted.
	(sprintf_append_element_to_obj): Deleted.

	* generic/gdbtk-bp.c (get_breakpoint_commands): Use
	Tcl_ListObjAppendElement() instead of
	sprintf_append_element_to_obj().
@
text
@a185 5
static void gdbtk_print_source (ClientData clientData,
				struct symtab *symtab,
				int start_line, int end_line);
static CORE_ADDR gdbtk_print_asm (ClientData clientData, CORE_ADDR pc,
				  struct disassemble_info *di);
a1914 21
static void
gdbtk_print_source (ClientData clientData, struct symtab *symtab,
		    int start_line, int end_line)
{
  print_source_lines (symtab, start_line, end_line, 0);
  gdb_flush (gdb_stdout);
}

static CORE_ADDR
gdbtk_print_asm (ClientData clientData, CORE_ADDR pc,
		 struct disassemble_info *di)
{
  fputs_unfiltered ("    ", gdb_stdout);
  print_address (pc, gdb_stdout);
  fputs_unfiltered (":\t    ", gdb_stdout);
  pc += TARGET_PRINT_INSN (pc, di);
  fputs_unfiltered ("\n", gdb_stdout);
  gdb_flush (gdb_stdout);
  return pc;
}

a2400 1
  Tcl_Obj *result;
@


1.70
log
@2003-03-05  Martin M. Hunt  <hunt@@redhat.com>

	* generic/gdbtk-cmds.c (Gdbtk_Init): Create gdb_CA_to_TAS.
	(gdb_load_disassembly): Now takes CORE_ADDRs. Returns CORE_ADDRs
	for low and high.
	(gdbtk_load_asm): Use CORE_ADDRs.
	(gdb_loc): Return CORE_ADDRs.
	(gdb_entry_point): Return CORE_ADDR.
	(gdb_incr_addr): Update description.
	(gdb_CA_to_TAS): New function. Takes a CORE_ADDR and returns
	a target sddress string.

	* generic/gdbtk-bp.c (gdb_find_bp_at_addr): Change to
	take a CORE_ADDR.
	(gdb_get_breakpoint_info): Returns a CORE_ADDR.
	(gdb_set_bp_addr): Takes a CORE_ADDR.

	* library/bpwin.itb (bp_add): Call gdb_CA_to_TAS before
	displaying address.
	(bp_modify): Ditto.

	* library/srcwin.itb (location): Call gdb_CA_to_TAS before
	displaying address. Don't add "0x" in front of address.
	(set_execution_status): Call gdb_CA_to_TAS before
	displaying address. Don't call [gdb_cmd printf] to format
	output. Weird.
@
text
@d81 1
a81 1
/* This Structure is used in gdb_disassemble.
a136 1
static int gdb_disassemble (ClientData, Tcl_Interp *, int, Tcl_Obj * CONST[]);
a240 2
  Tcl_CreateObjCommand (interp, "gdb_disassemble", gdbtk_call_wrapper,
			gdb_disassemble, NULL);
a421 17
/* This is a convenience function to sprintf something(s) into a
 * new element in a Tcl list object.
 */

void
sprintf_append_element_to_obj (Tcl_Obj * objp, char *format,...)
{
  va_list args;
  char *buf;

  va_start (args, format);

  xvasprintf (&buf, format, args);

  Tcl_ListObjAppendElement (NULL, objp, Tcl_NewStringObj (buf, -1));
  free(buf);
}
a1495 54
/*
 * This section has commands that handle source disassembly.
 */
/* This implements the tcl command gdb_disassemble.  It is no longer
 * used in GDBTk, we use gdb_load_disassembly, but I kept it around in
 * case other folks want it.
 *
 * Arguments:
 *    source_with_assm - must be "source" or "nosource"
 *    low_address - the address from which to start disassembly
 *    ?hi_address? - the address to which to disassemble, defaults
 *                   to the end of the function containing low_address.
 * Tcl Result:
 *    The disassembled code is passed to fputs_unfiltered, so it
 *    either goes to the console if result_ptr->obj_ptr is NULL or to
 *    the Tcl result.
 */

static int
gdb_disassemble (ClientData clientData, Tcl_Interp *interp,
		 int objc, Tcl_Obj *CONST objv[])
{
  CORE_ADDR low, high;
  char *arg_ptr;
  int mixed_source_and_assembly;

  if (objc != 3 && objc != 4)
    {
      Tcl_WrongNumArgs (interp, 1, objv, "source lowaddr ?highaddr?");
      return TCL_ERROR;
    }

  arg_ptr = Tcl_GetStringFromObj (objv[1], NULL);
  if (*arg_ptr == 's' && strcmp (arg_ptr, "source") == 0)
    mixed_source_and_assembly = 1;
  else if (*arg_ptr == 'n' && strcmp (arg_ptr, "nosource") == 0)
    mixed_source_and_assembly = 0;
  else
    error ("First arg must be 'source' or 'nosource'");

  low = string_to_core_addr (Tcl_GetStringFromObj (objv[2], NULL));

  if (objc == 3)
    {
      if (find_pc_partial_function (low, NULL, &low, &high) == 0)
        error ("No function contains specified address");
    }
  else
    high = string_to_core_addr (Tcl_GetStringFromObj (objv[3], NULL));

  return gdb_disassemble_driver (low, high, mixed_source_and_assembly, NULL,
				 gdbtk_print_source, gdbtk_print_asm);

}
d2132 1
a2132 1
/* This is the memory_read_func for gdb_disassemble when we are
@


1.69
log
@2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.h (SYMBOL_NATURAL_NAME): New macro.
	(SYMBOL_LINKAGE_NAME): Ditto.
	(SYMBOL_PRINT_NAME): Use SYMBOL_NATURAL_NAME and
	SYMBOL_LINKAGE_NAME.
	(struct general_symbol_info): Expand comment.
	(DEPRECATED_SYMBOL_NAME): Rename from SYMBOL_NAME.
	(SYMBOL_MATCHES_NAME): Use DEPRECATED_SYMBOL_NAME.
	(SYMBOL_MATCHES_REGEXP): Ditto.
	* symtab.c (symbol_natural_name): New function.
	* objfiles.h: Replace all uses of SYMBOL_NAME by
	DEPRECATED_SYMBOL_NAME.
	* xcoffread.c, valops.c, typeprint.c, tracepoint.c: Ditto.
	* symtab.c, symmisc.c, symfile.c, stack.c, stabsread.c: Ditto.
	* somsolib.c, sol-thread.c, rs6000-tdep.c, p-valprint.c: Ditto.
	* printcmd.c, objfiles.c, objc-lang.c, mipsread.c: Ditto.
	* minsyms.c, mdebugread.c, linespec.c, jv-lang.c: Ditto.
	* i386-tdep.c, i386-linux-tdep.c, hpread.c, hppa-tdep.c: Ditto.
	* gnu-v2-abi.c, f-valprint.c, findvar.c, expprint.c: Ditto.
	* dwarfread.c, dwarf2read.c, dbxread.c, c-valprint.c: Ditto.
	* cp-valprint.c, coffread.c, buildsym.c, breakpoint.c: Ditto.
	* blockframe.c, ax-gdb.c, arm-linux-tdep.c, ada-lang.c: Ditto.
	* ada-exp.y: Ditto.
	* ada-exp.y: Update copyright.
	* sol-thread.c, mipsread.c, jv-lang.c, f-valprint.c: Ditto.
	* cp-valprint.c: Ditto.

2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* generic/gdbtk.h: Replace all instances of SYMBOL_NAME by
	DEPRECATED_SYMBOL_NAME.
	* generic/gdbtk-stack.c, generic/gdbtk-cmds.c: Ditto.
	* generic/gdbtk-stack.c, generic/gdbtk-cmds.c: Update copyright.

2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c: Replace all instances of SYMBOL_NAME with
	DEPRECATED_SYMBOL_NAME.  Update copyright.
@
text
@d154 1
d246 1
d1576 2
a1577 2
 *    low_address - the address from which to start disassembly
 *    ?hi_address? - the address to which to disassemble, defaults
d1597 1
d1683 4
a1686 2
  
  low = string_to_core_addr (Tcl_GetStringFromObj (objv[5], NULL));
d1692 1
a1692 2
	error ("No function contains address 0x%s (%s)",
	       paddr_nz (orig), Tcl_GetStringFromObj (objv[5], NULL));
d1695 6
a1700 3
    high = string_to_core_addr (Tcl_GetStringFromObj (objv[6], NULL));


d1765 4
a1768 13
      char *buffer;
      Tcl_Obj *limits_obj[2];
      
      xasprintf (&buffer, "0x%s", paddr_nz (low));
      limits_obj[0] = Tcl_NewStringObj (buffer, -1);
      free(buffer);
      
      xasprintf (&buffer, "0x%s", paddr_nz (high));
      limits_obj[1] = Tcl_NewStringObj (buffer, -1);
      free(buffer);
      
      Tcl_DecrRefCount (result_ptr->obj_ptr);
      result_ptr->obj_ptr = Tcl_NewListObj (2, limits_obj);
d1915 1
d1935 1
a1935 1
  
a1939 1
  
d1944 1
a1944 1
  pc += TARGET_PRINT_INSN (pc, di);
d1963 1
a1963 1
      Tcl_DStringAppend (&client_data->pc_to_line_prefix, text_argv[5], -1);
d1976 1
d1979 2
a1980 2
		   text_argv[5], 0);

d1990 2
a1991 2
    
  return pc;
d2324 1
a2324 2
  Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr,
			    Tcl_NewStringObj (filename, -1));
d2326 1
a2326 2
  Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr,
			    Tcl_NewIntObj (sal.line));
d2328 2
a2329 1
  sprintf_append_element_to_obj (result_ptr->obj_ptr, "0x%s", paddr_nz (pc));
d2331 2
a2332 3
  sprintf_append_element_to_obj (result_ptr->obj_ptr, "0x%s",
				 paddr_nz (stop_pc));

d2357 1
a2357 1
      addrstr = paddr_nz (entry_point_address ());
d3040 8
a3047 2
 * It increments addresses, which must be implemented
 * this way because tcl cannot handle 64-bit values.
d3050 1
a3050 1
 *     addr   - 32 or 64-bit address
d3055 1
a3055 1
 *     addr + number
d3067 1
a3067 1
      Tcl_WrongNumArgs (interp, 1, objv, "address [number]");
d3083 45
@


1.68
log
@        * generic/gdbtk-cmds.c (gdb_search): Change SYMBOL_SOURCE_NAME
        to SYMBOL_PRINT_NAME to track recent changes in gdb.
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2001, 2002
d1368 2
a1369 2
      if ((p->symbol != NULL && !STREQN (SYMBOL_NAME (p->symbol), "__tf", 4)
	   && !STREQN (SYMBOL_NAME (p->symbol), "_GLOBAL_", 8))
d1487 1
a1487 1
		  funcVals[0] = Tcl_NewStringObj (SYMBOL_NAME (sym), -1);
@


1.67
log
@
2003-02-20  Pierre Muller  <muller@@ics.u-strasbg.fr>

	* generic/gdbtk-cmds.c: Add missing "block.h" include.
	generic/gdbtk-stack.c: Ditto.
	generic/gdbtk-wrapper.c: Ditto.
@
text
@d1376 1
a1376 1
				      Tcl_NewStringObj (SYMBOL_SOURCE_NAME (p->symbol), -1));
d1379 1
a1379 1
				      Tcl_NewStringObj (SYMBOL_SOURCE_NAME (p->msymbol), -1));
@


1.66
log
@2003-02-10  Andrew Cagney  <ac131313@@redhat.com>

	* generic/gdbtk-varobj.c (gdb_variable_command): Ditto for
	`commands'.
	(variable_type): Ditto for `first'.
	(variable_obj_command): Ditto.
	(variable_create): Ditto for create_options.
	(variable_type): Ditto for `last'.  Use `string' and not `first'
	when modifying the buffer.
	(struct disassembly_client_data ): Ditto for `asm_argv'
	* generic/gdbtk-register.c (gdb_register_info): Ditto for
	`commands'.
	* generic/gdbtk-hooks.c (tk_command_loop): Ditto for `msg'.
	* generic/gdbtk-cmds.c (gdb_search): Ditto for `switches'.
	(gdbtk_load_source): Ditto for `text_argv'.
	(struct disassembly_client_data ): Ditto for `source_argv'.
	(gdbtk_load_asm): Ditto for `text_argv'.
	(struct disassembly_client_data ): Ditto for `asm_argv'
	(gdb_loadfile): Ditto for `text_argv'.
	* generic/gdbtk.c (TclDebug): Make `v' a constant pointer.
	(gdbtk_init): Ditto for `old_chain', `src_path', `msg', and
	`lib_path'.
@
text
@d37 1
@


1.65
log
@2002-12-06  Andrew Cagney  <ac131313@@redhat.com>

	* generic/gdbtk-cmds.c (gdb_update_mem): Don't add a 0x prefix.
@
text
@d103 2
a104 2
  char *asm_argv[14];
  char *source_argv[7];
d1229 1
a1229 1
  static char *search_options[] =
d1231 1
a1231 1
  static char *switches[] =
d1787 1
a1787 1
      char **text_argv;
d1913 1
a1913 1
  char **text_argv;
d2748 1
a2748 1
  char *text_argv[9];
@


1.64
log
@        * generic/gdbtk-hooks.c: Include tcl.h and tk.h to pull
        in declarations for some Tk functions used in this file.
        * generic/gdbtk-cmds.c: Likewise.
@
text
@d2628 1
a2628 1
      sprintf (s, "0x%s", core_addr_to_string (addr + i));
@


1.63
log
@2002-11-30  Andrew Cagney  <ac131313@@redhat.com>

	* generic/gdbtk-stack.c: Replace selected_frame with
	deprecated_selected_frame.
	* generic/gdbtk-register.c: Ditto.
	* generic/gdbtk-cmds.c (gdb_loc): Replace selected_frame with
	deprecated_selected_frame.  Use get_frame_pc and find_frame_sal.
@
text
@d43 2
@


1.62
log
@2002-11-27  Martin M. Hunt  <hunt@@redhat.com>

	* generic/gdbtk.c (gdbtk_init): Don't call Tix_Init.
	Don't include tix.h

	* generic/gdbtk-hooks.c: Don't include tix.h.

	* generic/gdbtkj-cmds.c: Don't include tix.h.
@
text
@d2263 2
a2264 1
      if (selected_frame && (selected_frame->pc != read_pc ()))
d2272 2
a2273 5
	  pc = selected_frame->pc;
	  sal = find_pc_line (selected_frame->pc,
			      selected_frame->next != NULL
			      && !(get_frame_type (selected_frame->next) == SIGTRAMP_FRAME)
			      && !(get_frame_type (selected_frame->next) == DUMMY_FRAME));
@


1.61
log
@2002-11-27  Andrew Cagney  <cagney@@redhat.com>

	* generic/gdbtk-stack.c (get_frame_name): Use get_frame_type
	instead of deprecated_frame_in_dummy.
	* generic/gdbtk-cmds.c (gdb_loc): Ditto.
@
text
@a41 1
#include <tix.h>
@


1.60
log
@2002-11-19  Andrew Cagney  <ac131313@@redhat.com>

	* generic/gdbtk-cmds.c (gdb_loc): Use get_frame_type instead of
	->signal_handler_caller.
	* generic/gdbtk-stack.c (get_frame_name): Ditto.
	(get_frame_name): Ditto.
@
text
@d2276 1
a2276 1
			      && !deprecated_frame_in_dummy (selected_frame->next));
@


1.59
log
@From: 2002-11-11  David Carlton  <carlton@@math.stanford.edu>

	* generic/gdbtk-stack.c (get_frame_name): Replace call to
	frame_in_dummy with one to deprecated_frame_in_dummy.
	* generic/gdbtk-cmds.c (gdb_loc): Ditto.
@
text
@d2275 1
a2275 1
			      && !selected_frame->next->signal_handler_caller
@


1.58
log
@2002-10-10  Martin M. Hunt  <hunt@@redhat.com>

	* generic/gdbtk-cmds.c (gdb_update_mem): No results
	were being returned. Append results to result_ptr_obj_ptr.
@
text
@d2276 1
a2276 1
			      && !frame_in_dummy (selected_frame->next));
@


1.57
log
@2002-05-15  Martin M. Hunt  <hunt@@redhat.com>

	* generic/gdbtk-cmds.c (gdb_eval): For mem_file stuff, delete
	the file when done and free memory.
@
text
@d2706 3
a2708 6
  result = Tcl_NewListObj (0, NULL);
  Tcl_ListObjAppendElement (interp, result, Tcl_NewIntObj (max_label_len + 1));
  Tcl_ListObjAppendElement (interp, result, Tcl_NewIntObj (max_val_len + 1));
  Tcl_ListObjAppendElement (interp, result, Tcl_NewIntObj (max_ascii_len + 1));
  result_ptr->flags |= GDBTK_IN_TCL_RESULT;

@


1.57.2.1
log
@2002-12-06  Andrew Cagney  <ac131313@@redhat.com>

	* generic/gdbtk-cmds.c (gdb_update_mem): Don't add a 0x prefix.
@
text
@d2629 1
a2629 1
      sprintf (s, "%s", core_addr_to_string (addr + i));
@


1.56
log
@2002-04-04  Daniel Jacobowitz  <drow@@mvista.com>

        * generic/gdbtk-cmds.c (gdb_disassemble_driver): Skip
        end-of-function markers in the line table.
@
text
@d625 1
d642 1
d646 3
a648 1
  Tcl_SetObjResult (interp, Tcl_NewStringObj (ui_file_xstrdup (stb, &dummy), -1));
@


1.55
log
@        * generic/gdbtk-cmds.c (gdb_load_disassembly): Use string_to_core_addr
        instead of parse_and_eval_address.
        Use xfree instead of free.
@
text
@d2131 5
a2135 18
	  /* GCC sometimes emits line directives with a linenumber
	     of 0.  It does this to handle live range splitting.
	     This may be a bug, but we need to be able to handle it.
	     For now, use the previous instructions line number.
	     Since this is a bit of a hack anyway, we will just lose
	     if the bogus sline is the first line of the range.  For
	     functions, I have never seen this to be the case.  */
	  
	  if (le[i].line != 0)
	    {
	      mle[newlines].line = le[i].line;
	    }
	  else
	    {
	      if (newlines > 0)
		mle[newlines].line = mle[newlines - 1].line;
	    }
	  
@


1.54
log
@* generic/gdbtk.c (HAS_STDARG): Define.
* generic/gdbtk-cmds.c (HAS_STDARG): Likewise.
* generic/gdbtk-hooks.c (HAS_STDARG): Likewise.
@
text
@d1675 1
a1675 1
  low = parse_and_eval_address (Tcl_GetStringFromObj (objv[5], NULL));
d1685 1
a1685 1
    high = parse_and_eval_address (Tcl_GetStringFromObj (objv[6], NULL));
d1981 1
a1981 1
      free(buffer);
@


1.53
log
@        * generic/gdbtk-cmds.c: Include "ctype.h" if available.
        (gdb_get_mem): Renamed to gdb_update_mem.
        (gdb_update_mem): Take array as first tcl argument. This
        array will hold the data for the table, which is now stuffed
        in C instead of tcl.
        (gdb_eval): Use our own ui-file instead of gdb_stdout.
        * library/memwin.ith (_update_address): New method.
        (update_address): Address expression is no longer optional.
        * library/memwin.itb (build_win): Use _update_address instead of
        update_address.
        (toggle_enabled): Ditto.
        (newsize): Use _update_address instead of update_addr.
        (update_address_cb): Use _update_address instead of update_address.
        (do_popup): Likewise.
        (goto): Likewise.
        (incr_addr): Use _update_address instead of update_addr.
        (edit): Use gdb_update_mem instead of gdb_get_mem.
        (update_addr): use gdb_update_mem to do all the window updating.
@
text
@d38 4
@


1.52
log
@2002-02-10  Daniel Jacobowitz  <drow@@mvista.com>

        * symtab.c (compare_search_syms): New function.
        (sort_search_symbols): New function.
        (search_symbols): Sort symbols after searching rather than
        before.

2002-02-10  Daniel Jacobowitz  <drow@@mvista.com>

        * generic/gdbtk-cmds.c (gdb_listfuncs): Don't call
        BLOCK_SHOULD_SORT.
        * library/browserwin.itb (BrowserWin::_fill_funcs_combo): Sort
        the output of gdb_listfuncs.
@
text
@d56 4
d143 1
a143 1
static int gdb_get_mem (ClientData, Tcl_Interp *, int, Tcl_Obj * CONST[]);
d228 1
a228 1
  Tcl_CreateObjCommand (interp, "gdb_get_mem", gdbtk_call_wrapper, gdb_get_mem,
d619 2
d635 2
a636 6
  /*
   * Print the result of the expression evaluation.  This will go to
   * eventually go to gdbtk_fputs, and from there be collected into
   * the Tcl result.
   */

d639 3
a641 1
	     gdb_stdout, format, 0, 0, 0);
d2474 3
a2476 2
/* This implements the Tcl command 'gdb_get_mem', which 
 * dumps a block of memory 
d2478 1
a2478 1
 *   gdb_get_mem addr form size nbytes bpr aschar
d2480 8
a2487 7
 *   addr: address of data to dump
 *   form: a char indicating format
 *   size: size of each element; 1,2,4, or 8 bytes
 *   nbytes: the number of bytes to read 
 *   bpr: bytes per row
 *   aschar: if present, an ASCII dump of the row is included.  ASCHAR
 *   used for unprintable characters.
d2490 2
a2491 1
 * a list of elements followed by an optional ASCII dump */
d2494 2
a2495 2
gdb_get_mem (ClientData clientData, Tcl_Interp *interp,
	     int objc, Tcl_Obj *CONST objv[])
d2497 2
a2498 1
  int size, asize, i, j, bc;
d2501 6
a2506 1
  char format, buff[128], aschar, *mbuf, *mptr, *cptr, *bptr;
d2508 2
d2511 1
a2511 1
  if (objc < 6 || objc > 7)
d2513 1
a2513 1
      Tcl_WrongNumArgs (interp, 1, objv, "addr format size bytes bytes_per_row ?ascii_char?");
d2517 3
a2519 1
  if (Tcl_GetIntFromObj (interp, objv[3], &size) != TCL_OK)
d2521 1
a2521 1
      result_ptr->flags |= GDBTK_IN_TCL_RESULT;
d2524 2
a2525 1
  else if (size <= 0)
d2527 1
a2527 1
      gdbtk_set_result (interp, "Invalid size, must be > 0");
d2531 3
a2533 1
  if (Tcl_GetIntFromObj (interp, objv[4], &nbytes) != TCL_OK)
d2535 1
a2535 1
      result_ptr->flags |= GDBTK_IN_TCL_RESULT;
d2538 3
d2547 3
a2549 1
  if (Tcl_GetIntFromObj (interp, objv[5], &bpr) != TCL_OK)
d2551 1
a2551 1
      result_ptr->flags |= GDBTK_IN_TCL_RESULT;
d2554 3
a2556 1
  else if (bpr <= 0)
d2558 1
a2558 1
      gdbtk_set_result (interp, "Invalid bytes per row, must be > 0");
d2561 1
d2563 2
a2564 4
  addr = string_to_core_addr (Tcl_GetStringFromObj (objv[1], NULL));

  format = *(Tcl_GetStringFromObj (objv[2], NULL));
  mbuf = (char *) malloc (nbytes + 32);
d2585 2
a2586 2
  if (objc == 7)
    aschar = *(Tcl_GetStringFromObj (objv[6], NULL));
d2616 3
a2618 1
  /* Build up the result as a list... */
d2620 8
a2627 1
  result_ptr->flags |= GDBTK_MAKES_LIST;	
d2629 20
d2651 2
d2655 3
a2657 2
	  Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr,
				    Tcl_NewStringObj ("N/A", 3));
d2659 4
a2662 2
	    for (j = 0; j < size; j++)
	      *bptr++ = 'X';
d2666 8
a2673 1
	  print_scalar_formatted (mptr, val_type, format, asize, gdb_stdout);
d2679 7
a2685 4
		  *bptr = *cptr++;
		  if (*bptr < 32 || *bptr > 126)
		    *bptr = aschar;
		  bptr++;
d2689 1
d2697 8
a2704 2
	  Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr,
				    Tcl_NewStringObj (buff, bc));
d2710 6
a2715 1
  result_ptr->flags &= ~GDBTK_MAKES_LIST;
d2717 2
a2718 1
  free (mbuf);
d2720 1
@


1.52.2.1
log
@* generic/gdbtk.c (HAS_STDARG): Define.
* generic/gdbtk-cmds.c (HAS_STDARG): Likewise.
* generic/gdbtk-hooks.c (HAS_STDARG): Likewise.
@
text
@a37 4
/* tcl header files includes varargs.h unless HAS_STDARG is defined,
   but gdb uses stdarg.h, so make sure HAS_STDARG is defined.  */
#define HAS_STDARG 1

@


1.51
log
@2002-02-07  Martin M. Hunt  <hunt@@redhat.com>

	* generic/gdbtk.c, generic/gdbtk-bp.c, generic/gdbtk-cmds.c,
	generic/gdbtk-hooks.c, generic/gdbtk-stack.c: Cleanup includes.
@
text
@a1444 3
      /* Skip the sort if this block is always sorted.  */
      if (!BLOCK_SHOULD_SORT (b))
	sort_block_syms (b);
@


1.50
log
@2002-02-06  Martin M. Hunt  <hunt@@redhat.com>

	* generic/gdbtk.c, generic/gdbtk-bp.c, generic/gdbtk-cmds.c,
	generic/gdbtk-hooks.c, generic/gdbtk-register.c,
	generic/gdbtk-stack.c, generic/gdbtk-varobj.c,
	generic/gdbtk-wrapper.c: Cleanup. Fix indentation. Fix
	function declarations. Remove unused variables. Add 2002
	copyrights.
@
text
@a26 1
#include "symtab.h"
a27 1
#include "command.h"
a28 1
#include "bfd.h"
a30 1
#include "target.h"
d35 2
d38 2
a39 1
#include <sys/stat.h>
a40 4
#include <tcl.h>
#include <tk.h>
#include <itcl.h>
#include <tix.h>
a47 1
#include "top.h"
d49 3
a53 1
#include <stdio.h>
a54 3

#include "annotate.h"
#include <sys/time.h>
@


1.49
log
@2002-02-05  Elena Zannoni  <ezannoni@@redhat.com>

        * generic/gdbtk-cmds.c (gdbtk_load_asm, gdbtk_print_asm): Use
        TARGET_PRINT_INSN instead of tm_print_insn.
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2001
d84 5
a88 5
  {
    int line;
    CORE_ADDR start_pc;
    CORE_ADDR end_pc;
  };
d93 2
a94 1
struct disassembly_client_data {
d217 1
a217 2
Gdbtk_Init (interp)
     Tcl_Interp *interp;
d329 2
a330 5
gdbtk_call_wrapper (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
d413 1
a413 2
wrapped_call (opaque_args)
     PTR opaque_args;
d444 11
a454 11
 * Prepare to accept a new executable file.  This is called when we
 * want to clear away everything we know about the old file, without
 * asking the user.  The Tcl code will have already asked the user if
 * necessary.  After this is called, we should be able to run the
 * `file' command without getting any questions.  
 *
 * Arguments:
 *    None
 * Tcl Result:
 *    None
 */
d457 2
a458 5
gdb_clear_file (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
d494 2
a495 5
gdb_confirm_quit (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
d520 2
a521 5
gdb_force_quit (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
d558 2
a559 5
gdb_stop (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
d652 12
a663 12
 * It sends its argument to the GDB command scanner for execution. 
 * This command will never cause the update, idle and busy hooks to be called
 * within the GUI.
 * 
 * Tcl Arguments:
 *    command - The GDB command to execute
 *    from_tty - 1 indicates this comes to the console.
 *               Pass this to the gdb command.
 * Tcl Result:
 *    The output from the gdb command (except for the "load" & "while"
 *    which dump their output to the console.
 */
d666 2
a667 5
gdb_cmd (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
d731 2
a732 5
gdb_immediate_command (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
a733 1

d769 7
a775 7
 * It returns the gdb interpreter's prompt.
 *
 * Tcl Arguments:
 *    None.
 * Tcl Result:
 *    The prompt.
 */
d778 2
a779 5
gdb_prompt_command (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
d792 7
a798 7
 * Tells whether the target is executing.
 *
 * Tcl Arguments:
 *    None
 * Tcl Result:
 *    A boolean indicating whether the target is executing.
 */
d801 2
a802 5
gdb_target_has_execution_command (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
d815 7
a821 7
 * Returns inferior command line arguments as a string
 *
 * Tcl Arguments:
 *    None
 * Tcl Result:
 *    A string containing the inferior command line arguments
 */
d824 2
a825 5
gdb_get_inferior_args (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
d839 7
a845 7
 * Sets inferior command line arguments
 *
 * Tcl Arguments:
 *    A string containing the inferior command line arguments
 * Tcl Result:
 *    None
 */
d848 2
a849 5
gdb_set_inferior_args (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
d873 7
a879 7
 * It returns information about the file about to be downloaded.
 *
 * Tcl Arguments:
 *    filename: The file to open & get the info on.
 * Tcl Result:
 *    A list consisting of the name and size of each section.
 */
d882 2
a883 5
gdb_load_info (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
d932 8
a939 8
 * It returns the linenumber for a given linespec.  It will take any spec
 * that can be passed to decode_line_1
 *
 * Tcl Arguments:
 *    linespec - the line specification
 * Tcl Result:
 *    The line number for that spec.
 */
d941 2
a942 5
gdb_get_line_command (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
d968 7
a974 7
 * It returns the file containing a given line spec.
 *
 * Tcl Arguments:
 *    linespec - The linespec to look up
 * Tcl Result:
 *    The file containing it.
 */
d977 2
a978 5
gdb_get_file_command (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
d1004 7
a1010 7
 * It finds the function containing the given line spec.
 *
 * Tcl Arguments:
 *    linespec - The line specification
 * Tcl Result:
 *    The function that contains it, or "N/A" if it is not in a function.
 */
d1012 2
a1013 5
gdb_get_function_command (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
d1041 8
a1048 8
 * It searches the symbol tables to get the full pathname to a file.
 *
 * Tcl Arguments:
 *    filename: the file name to search for.
 * Tcl Result:
 *    The full path to the file, an empty string if the file was not
 *    available or an error message if the file is not found in the symtab.
 */
d1051 2
a1052 5
gdb_find_file_command (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
d1092 17
a1108 17
 * This lists all the files in the current executible.
 *
 * Note that this currently pulls in all sorts of filenames
 * that aren't really part of the executable.  It would be
 * best if we could check each file to see if it actually
 * contains executable lines of code, but we can't do that
 * with psymtabs.
 *
 * Arguments:
 *    ?pathname? - If provided, only files which match pathname
 *        (up to strlen(pathname)) are included. THIS DOES NOT
 *        CURRENTLY WORK BECAUSE PARTIAL_SYMTABS DON'T SUPPLY
 *        THE FULL PATHNAME!!!
 *
 * Tcl Result:
 *    A list of all matching files.
 */
d1110 2
a1111 5
gdb_listfiles (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
d1132 15
a1146 15
  {
    if (numfiles == files_size)
      {
	files_size = files_size * 2;
	files = (char **) xrealloc (files, sizeof (char *) * files_size);
      }
    if (psymtab->filename)
      {
	if (!len || !strncmp (pathname, psymtab->filename, len)
	    || !strcmp (psymtab->filename, basename (psymtab->filename)))
	  {
	    files[numfiles++] = basename (psymtab->filename);
	  }
      }
  }
d1149 15
a1163 15
  {
    if (numfiles == files_size)
      {
	files_size = files_size * 2;
	files = (char **) xrealloc (files, sizeof (char *) * files_size);
      }
    if (symtab->filename && symtab->linetable && symtab->linetable->nitems)
      {
	if (!len || !strncmp (pathname, symtab->filename, len)
	    || !strcmp (symtab->filename, basename (symtab->filename)))
	  {
	    files[numfiles++] = basename (symtab->filename);
	  }
      }
  }
d1187 1
a1187 2
comp_files (file1, file2)
     const void *file1, *file2;
d1196 12
a1207 12
 * Tcl Arguments:
 *    option - One of "functions", "variables" or "types"
 *    regexp - The regular expression to look for.
 * Then, optionally:
 *    -files fileList
 *    -static 1/0
 *    -filename 1/0
 * Tcl Result:
 *    A list of all the matches found.  Optionally, if -filename is set to 1,
 *    then the output is a list of two element lists, with the symbol first,
 *    and the file in which it is found second.
 */
d1210 2
a1211 5
gdb_search (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
d1224 1
a1224 1
  {"functions", "variables", "types", (char *) NULL};
d1226 1
a1226 1
  {"-files", "-filename", "-static", (char *) NULL};
d1369 1
a1369 1
		     Tcl_NewStringObj (SYMBOL_SOURCE_NAME (p->symbol), -1));
d1372 1
a1372 1
		    Tcl_NewStringObj (SYMBOL_SOURCE_NAME (p->msymbol), -1));
d1400 9
a1408 9
 * It lists all the functions defined in a given file
 * 
 * Arguments:
 *    file - the file to look in
 * Tcl Result:
 *    A list of two element lists, the first element is
 *    the symbol name, and the second is a boolean indicating
 *    whether the symbol is demangled (1 for yes).
 */
d1434 1
a1434 1
		  Tcl_GetStringFromObj (objv[1], NULL));
d1500 1
a1500 1
 */
d1503 2
a1504 5
gdb_restore_fputs (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
d1529 2
a1530 5
gdb_disassemble (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
d1561 1
a1561 1
			  gdbtk_print_source, gdbtk_print_asm);
d1626 1
a1626 1
         array($prefix,srcline=$src_line_no) = $widget_line_no
d1629 2
a1630 2
         array($prefix,pc=$pc) = $widget_line_no
         array($prefix,line=$widget_line_no) = $src_line_no
d1643 5
a1647 4
      if (Tcl_UpVar (interp, "1", map_name, client_data.map_arr, 0) != TCL_OK) {
	gdbtk_set_result (interp, "Can't link map array.");
	return TCL_ERROR;
      }
d1655 1
a1655 1
				 sizeof (",srcline=") - 1);
d1729 2
a1730 2
			  (ClientData) &client_data,
			  gdbtk_load_source, gdbtk_load_asm);
d1734 1
a1734 1
  if (client_data.file_opened_p == 1) {
d1736 1
a1736 1
  }
d1752 16
a1767 16
  if (ret_val == TCL_OK) {
    char *buffer;
    Tcl_Obj *limits_obj[2];

    xasprintf (&buffer, "0x%s", paddr_nz (low));
    limits_obj[0] = Tcl_NewStringObj (buffer, -1);
    free(buffer);
    
    xasprintf (&buffer, "0x%s", paddr_nz (high));
    limits_obj[1] = Tcl_NewStringObj (buffer, -1);
    free(buffer);

    Tcl_DecrRefCount (result_ptr->obj_ptr);
    result_ptr->obj_ptr = Tcl_NewListObj (2, limits_obj);
    
  }
a1768 1

d1772 2
a1773 2
gdbtk_load_source (ClientData clientData, struct symtab *symtab, int
		      start_line, int end_line)
d1825 10
a1834 9
	  if (found_carriage_return) {
	    char *p;
	    
	    p = strrchr(line, '\0') - 2;
	    if (*p == '\r') {
	      *p = '\n';
	      *(p + 1) = '\0';
	    } else {
	      found_carriage_return = 0;
d1836 1
a1836 2
	  }

d1852 1
a1852 1
            xasprintf (&buffer, "%d", client_data->widget_line_no);
d1857 1
a1857 1
            free(buffer);
d1896 5
a1900 6
  else {
    /* If we couldn't open the file, or got some prior error, just exit. */
    
    return;
  }

d1905 2
a1906 4
gdbtk_load_asm (clientData, pc, di)
     ClientData clientData;
     CORE_ADDR pc;
     struct disassemble_info *di;
d1952 1
a1952 1
				     client_data->interp, 14, text_argv);
d1992 2
a1993 5
gdbtk_print_source (clientData, symtab, start_line, end_line)
     ClientData clientData;
     struct symtab *symtab;
     int start_line;
     int end_line;
d2000 2
a2001 4
gdbtk_print_asm (clientData, pc, di)
     ClientData clientData;
     CORE_ADDR pc;
     struct disassemble_info *di;
d2013 5
a2017 9
gdb_disassemble_driver (low, high, mixed_source_and_assembly,
			clientData, print_source_fn, print_asm_fn)
     CORE_ADDR low;
     CORE_ADDR high;
     int mixed_source_and_assembly;
     ClientData clientData; 
     void (*print_source_fn) (ClientData, struct symtab *, int, int);
     CORE_ADDR (*print_asm_fn) (ClientData, CORE_ADDR,
				struct disassemble_info *);
d2059 1
a2059 1
   */
d2220 2
a2221 5
gdbtk_dis_asm_read_memory (memaddr, myaddr, len, info)
     bfd_vma memaddr;
     bfd_byte *myaddr;
     unsigned int len;
     disassemble_info *info;
d2240 1
a2240 3
compare_lines (mle1p, mle2p)
     const PTR mle1p;
     const PTR mle2p;
d2258 6
a2263 6
 * Arguments:
 *    ?symbol? The symbol or address to locate - defaults to pc
 * Tcl Return:
 *    a list consisting of the following:                                  
 *       basename, function name, filename, line number, address, current pc
 */
d2362 2
a2363 5
gdb_entry_point (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
d2439 2
a2440 5
gdb_set_mem (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
d2730 1
a2730 1
      mtime = bfd_get_mtime(symtab->objfile->obfd);
d2732 1
a2732 1
      mtime = bfd_get_mtime(exec_bfd);
d2809 7
a2815 7
	      char *p;
	      
	      p = strrchr(line, '\0') - 2;
	      if (*p == '\r') {
		*p = '\n';
		*(p + 1) = '\0';
	      } else {
a2816 1
	      }
d2841 10
a2850 9
	  if (found_carriage_return) {
	    char *p;
	    
	    p = strrchr(line, '\0') - 2;
	    if (*p == '\r') {
	      *p = '\n';
	      *(p + 1) = '\0';
	    } else {
	      found_carriage_return = 0;
a2851 1
	  }
d2880 8
a2887 8
 * On Windows, it canonicalizes the pathname,
 * On Unix, it is a no op.
 *
 * Arguments:
 *    path
 * Tcl Result:
 *    The canonicalized path.
 */
d2890 2
a2891 5
gdb_path_conv (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
d2925 1
a2925 2
perror_with_name_wrapper (args)
     PTR args;
d2937 1
a2937 2
pc_function_name (pc)
     CORE_ADDR pc;
@


1.48
log
@	* generic/gdbtk-cmds.c (gdb_find_file_command): If the symtab
	doesn't have the filename's fullname, look it up with
	symtab_to_filename.
@
text
@d2008 1
a2008 1
  pc += (*tm_print_insn) (pc, di);
d2077 1
a2077 1
  pc += (*tm_print_insn) (pc, di);
@


1.47
log
@s/BIG_ENDIAN/BFD_ENDIAN_BIG/
@
text
@d1105 1
a1105 1
  char *filename;
d1123 5
d1129 1
a1129 1
  if (!st->fullname)
d1135 1
a1135 1
  Tcl_SetStringObj (result_ptr->obj_ptr, st->fullname, -1);
@


1.46
log
@	* generic/gdbtk-cmds.h (full_lookup_symtab): Don't declare.
	* generic/gdbtk-cmds.c (gdb_find_file_command): Use
	lookup_symtab.
	(gdb_listfuncs): Likewise.
	(gdb_loadfile): Likewise.
	(full_lookup_symtab): Removed.
	* generic/gdbtk-bp.c (gdb_find_bp_at_line): Use lookup_symtab.
	(gdb_set_bp): Likewise.
@
text
@d2104 1
a2104 1
  if (TARGET_BYTE_ORDER == BIG_ENDIAN)
@


1.45
log
@LITTLE_ENDIAN -> BFD_ENDIAN_LITTLE
@
text
@d1114 1
a1114 1
  st = full_lookup_symtab (filename);
d1482 1
a1482 1
  symtab = full_lookup_symtab (Tcl_GetStringFromObj (objv[1], NULL));
d2789 1
a2789 1
  symtab = full_lookup_symtab (file);
a3014 62
}

/* The lookup_symtab() in symtab.c doesn't work correctly */
/* It will not work will full pathnames and if multiple */
/* source files have the same basename, it will return */
/* the first one instead of the correct one. */
/* symtab->fullname will be NULL if the file is not available. */

struct symtab *
full_lookup_symtab (file)
     char *file;
{
  struct symtab *st;
  struct objfile *objfile;
  char *bfile, *fullname;
  struct partial_symtab *pt;

  if (!file)
    return NULL;

  /* first try a direct lookup */
  st = lookup_symtab (file);
  if (st)
    {
      if (!st->fullname)
	symtab_to_filename (st);
      return st;
    }

  /* if the direct approach failed, try */
  /* looking up the basename and checking */
  /* all matches with the fullname */
  bfile = basename (file);
  ALL_SYMTABS (objfile, st)
  {
    if (!strcmp (bfile, basename (st->filename)))
      {
	if (!st->fullname)
	  fullname = symtab_to_filename (st);
	else
	  fullname = st->fullname;

	if (!strcmp (file, fullname))
	  return st;
      }
  }

  /* still no luck?  look at psymtabs */
  ALL_PSYMTABS (objfile, pt)
  {
    if (!strcmp (bfile, basename (pt->filename)))
      {
	st = PSYMTAB_TO_SYMTAB (pt);
	if (st)
	  {
	    fullname = symtab_to_filename (st);
	    if (!strcmp (file, fullname))
	      return st;
	  }
      }
  }
  return NULL;
@


1.44
log
@2001-11-08  Martin M. Hunt  <hunt@@redhat.com>
	* generic/gdbtk-cmds.c (gdb_eval): Add an optional
	format argument.
	(hex2bin): Swap bytes around if target is little endian.
	Fix loop count.
	(gdb_incr_addr): New function to do address arithmetic.
	Needed because some addresses are 64-bits and tcl can't
	deal with them, except as strings.

	* library/memwin.itb (MemWin::build_win): Add a label
	to indicate the target endianess.
	(MemWin::edit): Use gdb_incr_addr.
	(MemWin::busy): The constructor calls gdbtk_busy which
	calls this before the window has finished drawing, so
	don't disable items that don't exist yet.
	(MemWin::update_address): Set a flag, bad_expr, if the
	expression does not evaluate. Call gdb_eval with 'x' flag
	to force the result to be hex.
	(MemWin::BadExpr): Set bad_expr.
	(MemWin::incr_addr): Use gdb_incr_addr.
	(MemWin::update_addr): Return is bad_expr is set. Use
	gdb_incr_addr.
	(MemWin::goto): Call update_address.
	* library/memwin.itb: Declare private variable bad_expr.

	* library/util.tcl (gdbtk_endian): New procedure. Returns
	BIG or LITTLE to indicate target endianess.
@
text
@d2480 1
a2480 1
  if (TARGET_BYTE_ORDER == LITTLE_ENDIAN)
@


1.43
log
@2001-11-05  Martin M. Hunt  <hunt@@redhat.com>
	* generic/gdbtk-cmds.h (gdbtk_set_result): Declare.
	A printf-like function to return error messages.
	* generic/gdbtk-cmds.c (gdbtk_set_result): New
	function.
	(gdb_cmd): Use gdbtk_set_result.
	(gdb_immediate_command): Ditto.
	(gdb_load_info): Ditto.
	(gdb_find_file_command): Ditto.
	(gdb_listfuncs): Ditto.
	(gdb_load_disassembly): Ditto.
	(gdb_loc): Ditto.
	(gdb_set_mem): Ditto.
	(gdb_get_mem): Ditto.
	(gdb_loadfile): Ditto.
	* generic/gdbtk-varobj.c (variable_format): Ditto.
	(variable_value): Ditto.
	* generic/gdbtk-stack.c (gdb_get_vars_command): Ditto.
	* generic/gdbtk-bp.c (gdb_get_breakpoint_info): Ditto.
	(gdb_set_bp): Ditto.
	(gdb_set_bp_addr): Ditto.
	(gdb_get_tracepoint_info): Ditto.
@
text
@d149 1
d241 1
d617 9
d631 2
a632 5
gdb_eval (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
d636 1
d639 1
a639 1
  if (objc != 2)
d641 1
a641 1
      Tcl_WrongNumArgs (interp, 1, objv, "expression");
d645 3
a648 1

a649 1

d660 1
a660 1
	     gdb_stdout, 0, 0, 0, 0);
a662 1

d2476 2
a2477 2
  int i;
  int m, n;
d2479 9
a2487 1
  for (i = 0; i < count; i++)
d2500 1
a2500 1
      hex += 2;
d3122 42
@


1.42
log
@2001-10-29  Martin M. Hunt  <hunt@@redhat.com>

	* generic/gdbtk-bp.c (gdb_find_bp_at_addr): Use
	string_to_core_addr to read address so 64 bits will work.
	(gdb_set_bp): Set error message with Tcl_SetObjResult()
	so it will be displayed.
	(gdb_set_bp_addr):Use string_to_core_addr to read address.
	Set error message with Tcl_SetObjResult().

	* generic/gdbtk-cmds.c (gdb_get_mem): :Use string_to_core_addr
	to read address. Set error message with Tcl_SetObjResult() or
	Tcl_WrongNumArgs.
@
text
@d691 1
a691 2
	  Tcl_SetStringObj (result_ptr->obj_ptr, "from_tty must be a boolean.",
			    -1);
d760 1
a760 2
	  Tcl_SetStringObj (result_ptr->obj_ptr, "from_tty must be a boolean.",
			    -1);
d924 1
a924 1
      Tcl_SetStringObj (result_ptr->obj_ptr, "Open failed", -1);
d931 1
a931 1
      Tcl_SetStringObj (result_ptr->obj_ptr, "Bad Object File", -1);
d1110 1
a1110 2
      Tcl_SetStringObj ( result_ptr->obj_ptr,
                         "File not found in symtab (2)", -1);
a1281 1
      result_ptr->flags |= GDBTK_IN_TCL_RESULT;
d1476 2
a1477 1
      Tcl_SetStringObj (result_ptr->obj_ptr, "No such file", -1);
d1480 1
a1480 1

d1651 1
a1651 1
      Tcl_SetStringObj (result_ptr->obj_ptr, "Invalid widget name.", -1);
d1657 1
a1657 2
      Tcl_SetStringObj (result_ptr->obj_ptr, "Can't get widget command info",
			-1);
d1668 1
a1668 2
      Tcl_SetStringObj (result_ptr->obj_ptr,
			"Second arg must be 'source' or 'nosource'", -1);
d1693 1
a1693 1
	Tcl_SetStringObj (result_ptr->obj_ptr, "Can't link map array.", -1);
d2374 1
a2374 1
	  Tcl_SetStringObj (result_ptr->obj_ptr, "Ambiguous line spec", -1);
d2536 1
a2536 5
      char *res;

      xasprintf (&res, "Invalid hexadecimal input: \"0x%s\"", hexstr);
      Tcl_SetObjResult (interp, Tcl_NewStringObj (res, -1));
      free (res);
d2583 1
a2583 1
      Tcl_SetObjResult (interp, Tcl_NewStringObj ("Invalid size, must be > 0", -1));
d2594 1
a2594 2
      Tcl_SetObjResult (interp, 
			Tcl_NewStringObj ("Invalid number of bytes, must be > 0", -1));
d2605 1
a2605 2
      Tcl_SetObjResult (interp,
			Tcl_NewStringObj ("Invalid bytes per row, must be > 0", -1));
d2615 1
a2615 1
      Tcl_SetObjResult (interp, Tcl_NewStringObj ("Out of memory.", -1));
d2765 1
a2765 2
      Tcl_SetStringObj (result_ptr->obj_ptr, "Can't get widget command info",
			-1);
d2775 1
a2775 1
      Tcl_SetStringObj ( result_ptr->obj_ptr, "File not found in symtab", -1);
d2782 1
a2782 2
      Tcl_SetStringObj ( result_ptr->obj_ptr, "Can't open file for reading",
			 -1);
a2812 1
      Tcl_SetStringObj ( result_ptr->obj_ptr, "Out of memory.", -1);
d2814 1
a2833 2
                  Tcl_SetStringObj ( result_ptr->obj_ptr, "Out of memory.",
				     -1);
d2836 1
d3092 13
@


1.41
log
@Functions to convert to/from CORE_ADDR and a string.  Use in Insight.
@
text
@d2570 2
a2571 5
gdb_get_mem (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
a2575 1
  long tmp;
d2581 1
a2581 3
      Tcl_SetStringObj (result_ptr->obj_ptr,
			"addr format size bytes bytes_per_row ?ascii_char?",
			-1);
d2592 1
a2592 1
      Tcl_SetStringObj (result_ptr->obj_ptr, "Invalid size, must be > 0", -1);
d2603 2
a2604 3
      Tcl_SetStringObj (result_ptr->obj_ptr,
			"Invalid number of bytes, must be > 0",
			-1);
d2615 2
a2616 2
      Tcl_SetStringObj (result_ptr->obj_ptr,
			"Invalid bytes per row, must be > 0", -1);
d2620 1
a2620 4
  if (Tcl_GetLongFromObj (interp, objv[1], &tmp) != TCL_OK)
    return TCL_OK;

  addr = (CORE_ADDR) tmp;
d2626 1
a2626 1
      Tcl_SetStringObj (result_ptr->obj_ptr, "Out of memory.", -1);
@


1.40
log
@2001-10-12  Daniel Jacobowitz  <drow@@mvista.com>

        * symtab.h (struct block): (ALL_BLOCK_SYMBOLS): New macro.

        * symtab.c (find_pc_sect_symtab): Use ALL_BLOCK_SYMBOLS.
        (make_symbol_completion_list): Likewise.
        (make_symbol_overload_list): Likewise.
        * buildsym.c (finish_block): Likewise.
        * breakpoint.c (get_catch_sals):  Likewise.
        * mdebugread.c (mylookup_symbol): Likewise.
        * objfiles.c (objfile_relocate): Likewise.
        * printcmd.c (print_frame_args): Likewise.
        * stack.c (print_block_frame_locals): Likewise.
        (print_block_frame_labels): Likewise.
        (print_frame_arg_vars): Likewise.
        * symmisc.c (dump_symtab): Likewise.
        * tracepoint.c (add_local_symbols): Likewise.
        (scope_info): Likewise.

2001-10-12  Daniel Jacobowitz  <drow@@mvista.com>

        * mi-cmd-stack.c (list_args_or_locals): Use ALL_BLOCK_SYMBOLS.

2001-10-12  Daniel Jacobowitz  <drow@@mvista.com>

        * generic/gdbtk-cmds.c (gdb_listfuncs): Use ALL_BLOCK_SYMBOLS.
        * generic/gdbtk-stack.c (gdb_block_vars): Likewise.
        (gdb_get_blocks): Likewise.
        (gdb_get_vars_command): Likewise.
5~
@
text
@d1602 1
a1602 1
  low = parse_and_eval_address (Tcl_GetStringFromObj (objv[2], NULL));
d1610 1
a1610 1
    high = parse_and_eval_address (Tcl_GetStringFromObj (objv[3], NULL));
d2523 1
a2523 1
  addr = parse_and_eval_address (Tcl_GetStringFromObj (objv[1], NULL));
@


1.39
log
@	* generic/gdbtk-cmds.c (gdb_disassemble_driver): We should be
	looking for "thread", not "threads" to determine if we have
	a multi-threaded child process.
@
text
@d1501 1
a1501 1
      for (j = 0; j < BLOCK_NSYMS (b); j++)
a1502 1
	  sym = BLOCK_SYM (b, j);
@


1.38
log
@	* generic/gdbtk-cmds.c (gdb_load_disassembly): Save the original
	address from parse_and_eval_address: if find_pc_partial_function
	errors, we will lose our original address.
	If find_pc_partial_function does error, print out both
	the address we thought we were disassembling at AND the address
	we actually did disassemble at. This should help elide address-
	to-pointer and pointer-to-address problems in the tdep files.
	* library/srctextwin.itb (FillAssembly): When gdb_load_disassembly
	fails, use its error message instead of the cooked "Unable to
	Read insturctions..." message.
	(UnLoadFromCache): If oldpane is empty, don't try show it,
	don't try to set our view to it, don't do anything but
	erase the given pane.
@
text
@d2133 1
a2133 1
	  || strstr (target_shortname, "threads") != NULL)
@


1.37
log
@2001-07-31  Elena Zannoni  <ezannoni@@redhat.com>

	* generic/gdbtk-cmds.c: Don't include regcache.h.
	* generic/gdbtk-register.c: Include regcache.h.
@
text
@d1639 1
a1639 1
  CORE_ADDR low, high;
d1732 1
d1737 2
a1738 1
        error ("No function contains specified address");
@


1.36
log
@	* generic/gdbtk-cmds.c (bin2hex): New function.
	(fromhex): New function.
	(gdb_set_mem): New function.
	(Gdbtk_Init): Add new command, "gdb_set_mem".
	* library/memwin.itb (edit): Use "gdb_set_mem" to set
	memory, not some gdb_cmd contrivance.
	When sending data to gdb_set_mem, make sure that it
	is properly zero-padded.
@
text
@a36 1
#include "regcache.h"
@


1.35
log
@	* generic/gdbtk-cmds.c: Put on diet. All breakpoint-,
	tracepoint-, register-, and stack-related functions moved
	into separate files.
	(call_wrapper): Renamed to "gdbtk_call_wrapper" and export.
	Update all callers.
	* generic/gdbtk.h: Move all breakpoint-related stuff into
	gdbtk-bp.c.
	Remove declaration for "call_wrapper". Now in gdbtk-cmds.h
	(and called "gdbtk_call_wrapper").
	* generic/gdbtk-varobj.c: Include "gdbtk-cmds.h".
	* generic/gdbtk-cmds.h: New file.
	* generic/gdbtk-bp.c: New file.
	* generic/gdbtk-register.c: New file.
	* generic/gdbtk-stack.c: New file.
@
text
@d147 1
d201 2
d233 2
d2451 99
@


1.34
log
@Make ptid_t related changes.
@
text
@a35 1
#include "tracepoint.h"
a36 1
#include "frame.h"
d50 1
a65 18
extern void *gdbtk_deleted_bp;

static void setup_architecture_data (void);
static int tracepoint_exists (char *args);

/* This structure filled in call_wrapper and passed to
   the wrapped call function.
   It stores the command pointer and arguments 
   run in the wrapper function. */

struct wrapped_call_args
  {
    Tcl_Interp *interp;
    Tcl_ObjCmdProc *func;
    int objc;
    Tcl_Obj *CONST * objv;
    int val;
  };
a78 10
/*
 * This is used in the register fetching routines
 */

#ifndef INVALID_FLOAT
#define INVALID_FLOAT(x, y) (0 != 0)
#endif



a109 31
/* This contains the previous values of the registers, since the last call to
   gdb_changed_register_list.  */

static char *old_regs;

/* These two lookup tables are used to translate the type & disposition fields
   of the breakpoint structure (respectively) into something gdbtk understands.
   They are also used in gdbtk-hooks.c */

char *bptypes[] =
{"none", "breakpoint", "hw breakpoint", "until",
 "finish", "watchpoint", "hw watchpoint",
 "read watchpoint", "acc watchpoint",
 "longjmp", "longjmp resume", "step resume",
 "sigtramp", "watchpoint scope",
 "call dummy", "shlib events", "catch load",
 "catch unload", "catch fork", "catch vfork",
 "catch exec", "catch catch", "catch throw"
};
char *bpdisp[] =
{"delete", "delstop", "disable", "donttouch"};

/*
 * These are routines we need from breakpoint.c.
 * at some point make these static in breakpoint.c and move GUI code there
 */

extern struct breakpoint *set_raw_breakpoint (struct symtab_and_line sal);
extern void set_breakpoint_count (int);
extern int breakpoint_count;

a121 1
int call_wrapper (ClientData, Tcl_Interp *, int, Tcl_Obj * CONST[]);
a128 4
static int gdb_actions_command (ClientData, Tcl_Interp *, int,
				Tcl_Obj * CONST objv[]);
static int gdb_changed_register_list (ClientData, Tcl_Interp *, int,
				      Tcl_Obj * CONST[]);
a136 2
static int gdb_fetch_registers (ClientData, Tcl_Interp *, int,
				Tcl_Obj * CONST[]);
a139 7
static struct symtab *full_lookup_symtab (char *file);
static int gdb_get_args_command (ClientData, Tcl_Interp *, int,
				 Tcl_Obj * CONST objv[]);
static int gdb_get_breakpoint_info (ClientData, Tcl_Interp *, int,
				    Tcl_Obj * CONST[]);
static int gdb_get_breakpoint_list (ClientData, Tcl_Interp *, int,
				    Tcl_Obj * CONST[]);
a145 2
static int gdb_get_locals_command (ClientData, Tcl_Interp *, int,
				   Tcl_Obj * CONST objv[]);
a146 6
static int gdb_get_trace_frame_num (ClientData, Tcl_Interp *, int,
				    Tcl_Obj * CONST objv[]);
static int gdb_get_tracepoint_list (ClientData, Tcl_Interp *, int,
				    Tcl_Obj * CONST objv[]);
static int gdb_get_vars_command (ClientData, Tcl_Interp *, int,
				 Tcl_Obj * CONST objv[]);
a166 1
static int gdb_regnames (ClientData, Tcl_Interp *, int, Tcl_Obj * CONST[]);
a169 7
static int gdb_set_bp (ClientData, Tcl_Interp *, int, Tcl_Obj * CONST objv[]);
static int gdb_set_bp_addr (ClientData, Tcl_Interp *, int,
			    Tcl_Obj * CONST objv[]);
static int gdb_find_bp_at_line (ClientData, Tcl_Interp *, int,
				Tcl_Obj * CONST objv[]);
static int gdb_find_bp_at_addr (ClientData, Tcl_Interp *, int,
				Tcl_Obj * CONST objv[]);
a173 6
static int gdb_trace_status (ClientData, Tcl_Interp *, int,
			     Tcl_Obj * CONST[]);
static int gdb_tracepoint_exists_command (ClientData, Tcl_Interp *,
					  int, Tcl_Obj * CONST objv[]);
static int gdb_get_tracepoint_info (ClientData, Tcl_Interp *, int,
				    Tcl_Obj * CONST objv[]);
a196 14
static int get_pc_register (ClientData, Tcl_Interp *, int, Tcl_Obj * CONST[]);
static int gdb_stack (ClientData, Tcl_Interp *, int, Tcl_Obj * CONST[]);
static int gdb_selected_frame (ClientData clientData,
			       Tcl_Interp * interp, int argc,
			       Tcl_Obj * CONST objv[]);
static int gdb_selected_block (ClientData clientData,
			       Tcl_Interp * interp, int argc,
			       Tcl_Obj * CONST objv[]);
static int gdb_get_blocks (ClientData clientData,
			   Tcl_Interp * interp, int objc,
			   Tcl_Obj * CONST objv[]);
static int gdb_block_vars (ClientData clientData,
			   Tcl_Interp * interp, int objc,
			   Tcl_Obj * CONST objv[]);
a197 4
static void get_register (int, void *);
static void get_register_name (int, void *);
static int map_arg_registers (int, Tcl_Obj * CONST[],
			      void (*)(int, void *), void *);
a198 1
static void register_changed_p (int, void *);
a199 3
static void get_frame_name (Tcl_Interp * interp, Tcl_Obj * list,
			    struct frame_info *fi);
char *pc_function_name (CORE_ADDR pc);
d216 2
a217 2
  Tcl_CreateObjCommand (interp, "gdb_cmd", call_wrapper, gdb_cmd, NULL);
  Tcl_CreateObjCommand (interp, "gdb_immediate", call_wrapper,
d219 2
a220 2
  Tcl_CreateObjCommand (interp, "gdb_loc", call_wrapper, gdb_loc, NULL);
  Tcl_CreateObjCommand (interp, "gdb_path_conv", call_wrapper, gdb_path_conv,
d222 1
a222 1
  Tcl_CreateObjCommand (interp, "gdb_listfiles", call_wrapper, gdb_listfiles,
d224 1
a224 1
  Tcl_CreateObjCommand (interp, "gdb_listfuncs", call_wrapper, gdb_listfuncs,
d226 1
a226 1
  Tcl_CreateObjCommand (interp, "gdb_entry_point", call_wrapper,
d228 1
a228 4
  Tcl_CreateObjCommand (interp, "gdb_get_mem", call_wrapper, gdb_get_mem,
			NULL);
  Tcl_CreateObjCommand (interp, "gdb_stop", call_wrapper, gdb_stop, NULL);
  Tcl_CreateObjCommand (interp, "gdb_regnames", call_wrapper, gdb_regnames,
d230 2
a231 1
  Tcl_CreateObjCommand (interp, "gdb_restore_fputs", call_wrapper, gdb_restore_fputs,
d233 1
a233 5
  Tcl_CreateObjCommand (interp, "gdb_fetch_registers", call_wrapper,
			gdb_fetch_registers, NULL);
  Tcl_CreateObjCommand (interp, "gdb_changed_register_list", call_wrapper,
			gdb_changed_register_list, NULL);
  Tcl_CreateObjCommand (interp, "gdb_disassemble", call_wrapper,
d235 2
a236 6
  Tcl_CreateObjCommand (interp, "gdb_eval", call_wrapper, gdb_eval, NULL);
  Tcl_CreateObjCommand (interp, "gdb_get_breakpoint_list", call_wrapper,
			gdb_get_breakpoint_list, NULL);
  Tcl_CreateObjCommand (interp, "gdb_get_breakpoint_info", call_wrapper,
			gdb_get_breakpoint_info, NULL);
  Tcl_CreateObjCommand (interp, "gdb_clear_file", call_wrapper,
d238 1
a238 1
  Tcl_CreateObjCommand (interp, "gdb_confirm_quit", call_wrapper,
d240 1
a240 1
  Tcl_CreateObjCommand (interp, "gdb_force_quit", call_wrapper,
d243 1
a243 1
			call_wrapper,
d245 1
a245 2
  Tcl_CreateObjCommand (interp, "gdb_is_tracing",
			call_wrapper, gdb_trace_status,
d247 1
a247 7
  Tcl_CreateObjCommand (interp, "gdb_load_info", call_wrapper, gdb_load_info,
			NULL);
  Tcl_CreateObjCommand (interp, "gdb_get_locals", call_wrapper,
			gdb_get_locals_command, NULL);
  Tcl_CreateObjCommand (interp, "gdb_get_args", call_wrapper,
			gdb_get_args_command, NULL);
  Tcl_CreateObjCommand (interp, "gdb_get_function", call_wrapper,
d249 1
a249 1
  Tcl_CreateObjCommand (interp, "gdb_get_line", call_wrapper,
d251 1
a251 1
  Tcl_CreateObjCommand (interp, "gdb_get_file", call_wrapper,
a252 6
  Tcl_CreateObjCommand (interp, "gdb_tracepoint_exists",
			call_wrapper, gdb_tracepoint_exists_command, NULL);
  Tcl_CreateObjCommand (interp, "gdb_get_tracepoint_info",
			call_wrapper, gdb_get_tracepoint_info, NULL);
  Tcl_CreateObjCommand (interp, "gdb_actions",
			call_wrapper, gdb_actions_command, NULL);
d254 1
a254 1
			call_wrapper, gdb_prompt_command, NULL);
d256 2
a257 6
			call_wrapper, gdb_find_file_command, NULL);
  Tcl_CreateObjCommand (interp, "gdb_get_tracepoint_list",
			call_wrapper, gdb_get_tracepoint_list, NULL);
  Tcl_CreateObjCommand (interp, "gdb_pc_reg", call_wrapper, get_pc_register,
			NULL);
  Tcl_CreateObjCommand (interp, "gdb_loadfile", call_wrapper, gdb_loadfile,
d259 1
a259 1
  Tcl_CreateObjCommand (interp, "gdb_load_disassembly", call_wrapper,
d261 1
a261 1
  Tcl_CreateObjCommand (gdbtk_interp, "gdb_search", call_wrapper,
d263 1
a263 19
  Tcl_CreateObjCommand (interp, "gdb_set_bp", call_wrapper, gdb_set_bp, NULL);
  Tcl_CreateObjCommand (interp, "gdb_set_bp_addr", call_wrapper,
			gdb_set_bp_addr, NULL);
  Tcl_CreateObjCommand (interp, "gdb_find_bp_at_line", call_wrapper,
			gdb_find_bp_at_line, NULL);
  Tcl_CreateObjCommand (interp, "gdb_find_bp_at_addr", call_wrapper,
			gdb_find_bp_at_addr, NULL);
  Tcl_CreateObjCommand (interp, "gdb_get_trace_frame_num",
			call_wrapper, gdb_get_trace_frame_num, NULL);
  Tcl_CreateObjCommand (interp, "gdb_stack", call_wrapper, gdb_stack, NULL);
  Tcl_CreateObjCommand (interp, "gdb_selected_frame", call_wrapper,
			gdb_selected_frame, NULL);
  Tcl_CreateObjCommand (interp, "gdb_selected_block", call_wrapper,
			gdb_selected_block, NULL);
  Tcl_CreateObjCommand (interp, "gdb_get_blocks", call_wrapper,
			gdb_get_blocks, NULL);
  Tcl_CreateObjCommand (interp, "gdb_block_variables", call_wrapper,
			gdb_block_vars, NULL);
  Tcl_CreateObjCommand (interp, "gdb_get_inferior_args", call_wrapper,
d265 1
a265 1
  Tcl_CreateObjCommand (interp, "gdb_set_inferior_args", call_wrapper,
a267 4
  Tcl_LinkVar (interp, "gdb_selected_frame_level",
	       (char *) &selected_frame_level,
	       TCL_LINK_INT | TCL_LINK_READ_ONLY);

d292 12
a303 5
  
  /* Register/initialize any architecture specific data */
  setup_architecture_data ();
  register_gdbarch_swap (&old_regs, sizeof (old_regs), NULL);
  register_gdbarch_swap (NULL, 0, setup_architecture_data);
d323 1
a323 1
call_wrapper (clientData, interp, objc, objv)
d422 1
a422 1
static void
a956 145
/* gdb_get_locals -
 * This and gdb_get_locals just call gdb_get_vars_command with the right
 * value of clientData.  We can't use the client data in the definition
 * of the command, because the call wrapper uses this instead...
 */

static int
gdb_get_locals_command (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
{

  return gdb_get_vars_command ((ClientData) 0, interp, objc, objv);

}

static int
gdb_get_args_command (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
{

  return gdb_get_vars_command ((ClientData) 1, interp, objc, objv);

}

/* This implements the tcl commands "gdb_get_locals" and "gdb_get_args"

 * This function sets the Tcl interpreter's result to a list of variable names
 * depending on clientData. If clientData is one, the result is a list of
 * arguments; zero returns a list of locals -- all relative to the block
 * specified as an argument to the command. Valid commands include
 * anything decode_line_1 can handle (like "main.c:2", "*0x02020202",
 * and "main").
 *
 * Tcl Arguments:
 *   linespec - the linespec defining the scope of the lookup. Empty string
 *              to use the current block in the innermost frame.
 * Tcl Result:
 *   A list of the locals or args
 */

static int
gdb_get_vars_command (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
{
  struct symtabs_and_lines sals;
  struct symbol *sym;
  struct block *block;
  char **canonical, *args;
  int i, nsyms, arguments;

  if (objc > 2)
    {
      Tcl_WrongNumArgs (interp, 1, objv,
			"[function:line|function|line|*addr]");
      return TCL_ERROR;
    }

  arguments = (int) clientData;

  /* Initialize the result pointer to an empty list. */

  Tcl_SetListObj (result_ptr->obj_ptr, 0, NULL);

  if (objc == 2)
    {
      args = Tcl_GetStringFromObj (objv[1], NULL);
      sals = decode_line_1 (&args, 1, NULL, 0, &canonical);
      if (sals.nelts == 0)
	{
	  Tcl_SetStringObj (result_ptr->obj_ptr,
			    "error decoding line", -1);
	  return TCL_ERROR;
	}

      /* Resolve all line numbers to PC's */
      for (i = 0; i < sals.nelts; i++)
	resolve_sal_pc (&sals.sals[i]);

      block = block_for_pc (sals.sals[0].pc);
    }
  else
    {
      /* Specified currently selected frame */
      if (selected_frame == NULL)
	return TCL_OK;

      block = get_frame_block (selected_frame);
    }

  while (block != 0)
    {
      nsyms = BLOCK_NSYMS (block);
      for (i = 0; i < nsyms; i++)
	{
	  sym = BLOCK_SYM (block, i);
	  switch (SYMBOL_CLASS (sym))
	    {
	    default:
	    case LOC_UNDEF:	/* catches errors        */
	    case LOC_CONST:	/* constant              */
	    case LOC_TYPEDEF:	/* local typedef         */
	    case LOC_LABEL:	/* local label           */
	    case LOC_BLOCK:	/* local function        */
	    case LOC_CONST_BYTES:	/* loc. byte seq.        */
	    case LOC_UNRESOLVED:	/* unresolved static     */
	    case LOC_OPTIMIZED_OUT:	/* optimized out         */
	      break;
	    case LOC_ARG:	/* argument              */
	    case LOC_REF_ARG:	/* reference arg         */
	    case LOC_REGPARM:	/* register arg          */
	    case LOC_REGPARM_ADDR:	/* indirect register arg */
	    case LOC_LOCAL_ARG:	/* stack arg             */
	    case LOC_BASEREG_ARG:	/* basereg arg           */
	      if (arguments)
		Tcl_ListObjAppendElement (interp, result_ptr->obj_ptr,
				  Tcl_NewStringObj (SYMBOL_NAME (sym), -1));
	      break;
	    case LOC_LOCAL:	/* stack local           */
	    case LOC_BASEREG:	/* basereg local         */
	    case LOC_STATIC:	/* static                */
	    case LOC_REGISTER:	/* register              */
	      if (!arguments)
		Tcl_ListObjAppendElement (interp, result_ptr->obj_ptr,
				  Tcl_NewStringObj (SYMBOL_NAME (sym), -1));
	      break;
	    }
	}
      if (BLOCK_FUNCTION (block))
	break;
      else
	block = BLOCK_SUPERBLOCK (block);
    }

  return TCL_OK;
}

a1536 64

/*
 * This section contains all the commands that act on the registers:
 */

/* This is a sort of mapcar function for operations on registers */

static int
map_arg_registers (objc, objv, func, argp)
     int objc;
     Tcl_Obj *CONST objv[];
     void (*func) (int regnum, void *argp);
     void *argp;
{
  int regnum, numregs;

  /* Note that the test for a valid register must include checking the
     REGISTER_NAME because NUM_REGS may be allocated for the union of
     the register sets within a family of related processors.  In this
     case, some entries of REGISTER_NAME will change depending upon
     the particular processor being debugged.  */

  numregs = NUM_REGS + NUM_PSEUDO_REGS;
  
  if (objc == 0)		/* No args, just do all the regs */
    {
      for (regnum = 0;
	   regnum < numregs;
	   regnum++)
	{
	  if (REGISTER_NAME (regnum) == NULL
	      || *(REGISTER_NAME (regnum)) == '\0')
	    continue;
	  
	  func (regnum, argp);
	}
      
      return TCL_OK;
    }

  /* Else, list of register #s, just do listed regs */
  for (; objc > 0; objc--, objv++)
    {
      if (Tcl_GetIntFromObj (NULL, *objv, &regnum) != TCL_OK)
	{
	  result_ptr->flags |= GDBTK_IN_TCL_RESULT;
	  return TCL_ERROR;
	}

      if (regnum >= 0
	  && regnum < numregs
	  && REGISTER_NAME (regnum) != NULL
	  && *REGISTER_NAME (regnum) != '\000')
	func (regnum, argp);
      else
	{
	  Tcl_SetStringObj (result_ptr->obj_ptr, "bad register number", -1);
	  return TCL_ERROR;
	}
    }

  return TCL_OK;
}

d1555 18
a1572 18

/* This implements the TCL command `gdb_regnames'.  Its syntax is:

   gdb_regnames [-numbers] [REGNUM ...]

   Return a list containing the names of the registers whose numbers
   are given by REGNUM ... .  If no register numbers are given, return
   all the registers' names.

   Note that some processors have gaps in the register numberings:
   even if there is no register numbered N, there may still be a
   register numbered N+1.  So if you call gdb_regnames with no
   arguments, you can't assume that the N'th element of the result is
   register number N.

   Given the -numbers option, gdb_regnames returns, not a list of names,
   but a list of pairs {NAME NUMBER}, where NAME is the register name,
   and NUMBER is its number.  */
d1575 1
a1575 1
gdb_regnames (clientData, interp, objc, objv)
d1581 3
a1583 1
  int numbers = 0;
d1585 1
a1585 4
  objc--;
  objv++;

  if (objc >= 1)
d1587 2
a1588 5
      char *s = Tcl_GetStringFromObj (objv[0], NULL);
      if (STREQ (s, "-numbers"))
	numbers = 1;
      objc--;
      objv++;
d1591 9
a1599 2
  return map_arg_registers (objc, objv, get_register_name, &numbers);
}
d1601 4
a1604 19
static void
get_register_name (regnum, argp)
     int regnum;
     void *argp;
{
  /* Non-zero if the caller wants the register numbers, too.  */
  int numbers = * (int *) argp;
  Tcl_Obj *name = Tcl_NewStringObj (REGISTER_NAME (regnum), -1);
  Tcl_Obj *elt;

  if (numbers)
    {
      /* Build a tuple of the form "{REGNAME NUMBER}", and append it to
	 our result.  */
      Tcl_Obj *array[2];

      array[0] = name;
      array[1] = Tcl_NewIntObj (regnum);
      elt = Tcl_NewListObj (2, array);
d1607 4
a1610 1
    elt = name;
a1611 1
  Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr, elt);
d1614 1
a1614 3
/* This implements the tcl command gdb_fetch_registers
 * Pass it a list of register names, and it will
 * return their values as a list.
d1616 6
a1621 3
 * Tcl Arguments:
 *    format: The format string for printing the values
 *    args: the registers to look for
d1623 6
a1628 1
 *    A list of their values.
d1632 2
a1633 5
gdb_fetch_registers (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
d1635 5
a1639 1
  int format, result;
d1641 1
a1641 1
  if (objc < 2)
d1643 1
a1643 1
      Tcl_WrongNumArgs (interp, 1, objv, "format ?register1 register2 ...?");
a1645 4
  objc -= 2;
  objv++;
  format = *(Tcl_GetStringFromObj (objv[0], NULL));
  objv++;
d1647 6
a1652 34
  if (objc != 1)
    result_ptr->flags |= GDBTK_MAKES_LIST;    /* Output the results as a list */
  result = map_arg_registers (objc, objv, get_register, (void *) format);
  if (objc != 1)
    result_ptr->flags &= ~GDBTK_MAKES_LIST;

  return result;
}

static void
get_register (regnum, fp)
     int regnum;
     void *fp;
{
  struct type *reg_vtype;
  char raw_buffer[MAX_REGISTER_RAW_SIZE];
  char virtual_buffer[MAX_REGISTER_VIRTUAL_SIZE];
  int format = (int) fp;
  int optim;

  if (format == 'N')
    format = 0;

  /* read_relative_register_raw_bytes returns a virtual frame pointer
     (FRAME_FP (selected_frame)) if regnum == FP_REGNUM instead
     of the real contents of the register. To get around this,
     use get_saved_register instead. */
  get_saved_register (raw_buffer, &optim, (CORE_ADDR *) NULL, selected_frame,
		      regnum, (enum lval_type *) NULL);
  if (optim)
    {
      Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr,
				Tcl_NewStringObj ("Optimized out", -1));
      return;
d1655 1
a1655 4
  /* Convert raw data to virtual format if necessary.  */

  reg_vtype = REGISTER_VIRTUAL_TYPE (regnum);
  if (REGISTER_CONVERTIBLE (regnum))
d1657 3
a1659 2
      REGISTER_CONVERT_TO_VIRTUAL (regnum, reg_vtype,
      				   raw_buffer, virtual_buffer);
d1661 6
a1667 3
    memcpy (virtual_buffer, raw_buffer, REGISTER_VIRTUAL_SIZE (regnum));

  if (format == 'r')
d1669 3
a1671 13
      int j;
      char *ptr, buf[1024];

      strcpy (buf, "0x");
      ptr = buf + 2;
      for (j = 0; j < REGISTER_RAW_SIZE (regnum); j++)
	{
	  register int idx = TARGET_BYTE_ORDER == BIG_ENDIAN ? j
	  : REGISTER_RAW_SIZE (regnum) - 1 - j;
	  sprintf (ptr, "%02x", (unsigned char) raw_buffer[idx]);
	  ptr += 2;
	}
      fputs_filtered (buf, gdb_stdout);
a1672 10
  else
    if ((TYPE_CODE (reg_vtype) == TYPE_CODE_UNION)
        && (strcmp (FIELD_NAME (TYPE_FIELD (reg_vtype, 0)), REGISTER_NAME (regnum)) == 0))
      {
        val_print (FIELD_TYPE (TYPE_FIELD (reg_vtype, 0)), virtual_buffer, 0, 0,
	           gdb_stdout, format, 1, 0, Val_pretty_default);
      }
    else
      val_print (REGISTER_VIRTUAL_TYPE (regnum), virtual_buffer, 0, 0,
	         gdb_stdout, format, 1, 0, Val_pretty_default);
d1674 4
a1677 1
}
d1679 3
a1681 8
/* This implements the tcl command get_pc_reg
 * It returns the value of the PC register
 *
 * Tcl Arguments:
 *    None
 * Tcl Result:
 *    The value of the pc register.
 */
d1683 4
a1686 8
static int
get_pc_register (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
{
  char *buff;
d1688 10
a1697 5
  xasprintf (&buff, "0x%llx", (long long) read_register (PC_REGNUM));
  Tcl_SetStringObj (result_ptr->obj_ptr, buff, -1);
  free(buff);
  return TCL_OK;
}
d1699 19
a1717 10
/* This implements the tcl command "gdb_changed_register_list"
 * It takes a list of registers, and returns a list of
 * the registers on that list that have changed since the last
 * time the proc was called.
 *
 * Tcl Arguments:
 *    A list of registers.
 * Tcl Result:
 *    A list of changed registers.
 */
d1719 5
a1723 9
static int
gdb_changed_register_list (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
{
  objc--;
  objv++;
d1725 3
a1727 2
  return map_arg_registers (objc, objv, register_changed_p, NULL);
}
d1729 1
a1729 57
static void
register_changed_p (regnum, argp)
     int regnum;
     void *argp;		/* Ignored */
{
  char raw_buffer[MAX_REGISTER_RAW_SIZE];

  if (read_relative_register_raw_bytes (regnum, raw_buffer))
    return;

  if (memcmp (&old_regs[REGISTER_BYTE (regnum)], raw_buffer,
	      REGISTER_RAW_SIZE (regnum)) == 0)
    return;

  /* Found a changed register.  Save new value and return its number. */

  memcpy (&old_regs[REGISTER_BYTE (regnum)], raw_buffer,
	  REGISTER_RAW_SIZE (regnum));

  Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr, Tcl_NewIntObj (regnum));
}

/*
 * This section contains the commands that deal with tracepoints:
 */

/* return a list of all tracepoint numbers in interpreter */
static int
gdb_get_tracepoint_list (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
{
  struct tracepoint *tp;

  Tcl_SetListObj (result_ptr->obj_ptr, 0, NULL);

  ALL_TRACEPOINTS (tp)
    Tcl_ListObjAppendElement (interp, result_ptr->obj_ptr,
			      Tcl_NewIntObj (tp->number));

  return TCL_OK;
}

/* returns -1 if not found, tracepoint # if found */
static int
tracepoint_exists (char *args)
{
  struct tracepoint *tp;
  char **canonical;
  struct symtabs_and_lines sals;
  char *file = NULL;
  int result = -1;

  sals = decode_line_1 (&args, 1, NULL, 0, &canonical);
  if (sals.nelts == 1)
d1731 2
a1732 21
      resolve_sal_pc (&sals.sals[0]);
      file = xmalloc (strlen (sals.sals[0].symtab->dirname)
		      + strlen (sals.sals[0].symtab->filename) + 1);
      if (file != NULL)
	{
	  strcpy (file, sals.sals[0].symtab->dirname);
	  strcat (file, sals.sals[0].symtab->filename);

	  ALL_TRACEPOINTS (tp)
	  {
	    if (tp->address == sals.sals[0].pc)
	      result = tp->number;
#if 0
	    /* Why is this here? This messes up assembly traces */
	    else if (tp->source_file != NULL
		     && strcmp (tp->source_file, file) == 0
		     && sals.sals[0].line == tp->line_number)
	      result = tp->number;
#endif
	  }
	}
d1734 2
a1735 4
  if (file != NULL)
    free (file);
  return result;
}
a1736 8
static int
gdb_tracepoint_exists_command (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
{
  char *args;
d1738 6
a1743 1
  if (objc != 2)
d1745 2
a1746 3
      Tcl_WrongNumArgs (interp, 1, objv,
			"function:line|function|line|*addr");
      return TCL_ERROR;
d1749 15
a1763 1
  args = Tcl_GetStringFromObj (objv[1], NULL);
d1765 1
a1765 16
  Tcl_SetIntObj (result_ptr->obj_ptr, tracepoint_exists (args));
  return TCL_OK;
}

static int
gdb_get_tracepoint_info (ClientData clientData, Tcl_Interp *interp,
			 int objc, Tcl_Obj *CONST objv[])
{
  struct symtab_and_line sal;
  int tpnum;
  struct tracepoint *tp;
  struct action_line *al;
  Tcl_Obj *action_list;
  char *filename, *funcname;

  if (objc != 2)
d1767 7
a1773 2
      Tcl_WrongNumArgs (interp, 1, objv, "tpnum");
      return TCL_ERROR;
d1775 4
d1780 6
a1785 1
  if (Tcl_GetIntFromObj (NULL, objv[1], &tpnum) != TCL_OK)
d1787 3
a1789 2
      result_ptr->flags |= GDBTK_IN_TCL_RESULT;
      return TCL_ERROR;
d1791 4
a1794 20

  ALL_TRACEPOINTS (tp)
    if (tp->number == tpnum)
    break;

  if (tp == NULL)
    {
      /* Hack. Check if this TP is being deleted. See comments
	 around the definition of gdbtk_deleted_bp in
	 gdbtk-hooks.c. */
      struct tracepoint *dtp = (struct tracepoint *) gdbtk_deleted_bp;
      if (dtp != NULL && dtp->number == tpnum)
	tp = dtp;
      else {
	char *buff;
	xasprintf (&buff, "Tracepoint #%d does not exist", tpnum);
	Tcl_SetStringObj (result_ptr->obj_ptr, buff, -1);
	free(buff);
	return TCL_ERROR;
      }
d1796 3
d1800 3
a1802 7
  Tcl_SetListObj (result_ptr->obj_ptr, 0, NULL);
  sal = find_pc_line (tp->address, 0);
  filename = symtab_to_filename (sal.symtab);
  if (filename == NULL)
    filename = "N/A";
  Tcl_ListObjAppendElement (interp, result_ptr->obj_ptr,
			    Tcl_NewStringObj (filename, -1));
d1804 7
a1810 3
  funcname = pc_function_name (tp->address);
  Tcl_ListObjAppendElement (interp, result_ptr->obj_ptr, Tcl_NewStringObj
			    (funcname, -1));
d1812 3
a1814 8
  Tcl_ListObjAppendElement (interp, result_ptr->obj_ptr,
			    Tcl_NewIntObj (sal.line));
  {
    char *tmp;
    xasprintf (&tmp, "0x%s", paddr_nz (tp->address));
    Tcl_ListObjAppendElement (interp, result_ptr->obj_ptr,
			      Tcl_NewStringObj (tmp, -1));
    free (tmp);
d1816 1
a1816 19
  Tcl_ListObjAppendElement (interp, result_ptr->obj_ptr,
			    Tcl_NewIntObj (tp->enabled));
  Tcl_ListObjAppendElement (interp, result_ptr->obj_ptr,
			    Tcl_NewIntObj (tp->pass_count));
  Tcl_ListObjAppendElement (interp, result_ptr->obj_ptr,
			    Tcl_NewIntObj (tp->step_count));
  Tcl_ListObjAppendElement (interp, result_ptr->obj_ptr,
			    Tcl_NewIntObj (tp->thread));
  Tcl_ListObjAppendElement (interp, result_ptr->obj_ptr,
			    Tcl_NewIntObj (tp->hit_count));

  /* Append a list of actions */
  action_list = Tcl_NewObj ();
  for (al = tp->actions; al != NULL; al = al->next)
    {
      Tcl_ListObjAppendElement (interp, action_list,
				Tcl_NewStringObj (al->action, -1));
    }
  Tcl_ListObjAppendElement (interp, result_ptr->obj_ptr, action_list);
a1817 1
  return TCL_OK;
d1820 8
d1829 7
a1835 8
static int
gdb_trace_status (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
{
  int result = 0;
d1837 1
a1837 2
  if (trace_running_p)
    result = 1;
d1839 5
a1843 3
  Tcl_SetIntObj (result_ptr->obj_ptr, result);
  return TCL_OK;
}
d1845 2
d1848 4
d1853 16
a1868 12
static int
gdb_get_trace_frame_num (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
{
  if (objc != 1)
    {
      Tcl_WrongNumArgs (interp, 1, objv, "linespec");
      return TCL_ERROR;
    }
d1870 15
a1884 2
  Tcl_SetIntObj (result_ptr->obj_ptr, get_traceframe_number ());
  return TCL_OK;
d1886 26
a1911 31
}

/* This implements the tcl command gdb_actions
 * It sets actions for a given tracepoint.
 *
 * Tcl Arguments:
 *    number: the tracepoint in question
 *    actions: the actions to add to this tracepoint
 * Tcl Result:
 *    None.
 */

static int
gdb_actions_command (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
{
  struct tracepoint *tp;
  Tcl_Obj **actions;
  int nactions, i, len;
  char *number, *args, *action;
  long step_count;
  struct action_line *next = NULL, *temp;
  enum actionline_type linetype;

  if (objc != 3)
    {
      Tcl_WrongNumArgs (interp, 1, objv, "number actions");
      return TCL_ERROR;
d1913 1
a1913 4

  args = number = Tcl_GetStringFromObj (objv[1], NULL);
  tp = get_tracepoint_by_number (&args, 0, 0);
  if (tp == NULL)
d1915 6
a1920 24
      Tcl_AppendStringsToObj (result_ptr->obj_ptr, "Tracepoint \"",
			      number, "\" does not exist", NULL);
      return TCL_ERROR;
    }

  /* Free any existing actions */
  if (tp->actions != NULL)
    free_actions (tp);

  step_count = 0;

  Tcl_ListObjGetElements (interp, objv[2], &nactions, &actions);

  /* Add the actions to the tracepoint */
  for (i = 0; i < nactions; i++)
    {
      temp = xmalloc (sizeof (struct action_line));
      temp->next = NULL;
      action = Tcl_GetStringFromObj (actions[i], &len);
      temp->action = savestring (action, len);

      linetype = validate_actionline (&(temp->action), tp);

      if (linetype == BADLINE)
d1922 1
a1922 8
	  free (temp);
	  continue;
	}

      if (next == NULL)
	{
	  tp->actions = temp;
	  next = temp;
d1926 17
a1942 2
	  next->next = temp;
	  next = temp;
d1945 5
a1950 1
  return TCL_OK;
a1951 18

/*
 * This section has commands that handle source disassembly.
 */
/* This implements the tcl command gdb_disassemble.  It is no longer
 * used in GDBTk, we use gdb_load_disassembly, but I kept it around in
 * case other folks want it.
 *
 * Arguments:
 *    source_with_assm - must be "source" or "nosource"
 *    low_address - the address from which to start disassembly
 *    ?hi_address? - the address to which to disassemble, defaults
 *                   to the end of the function containing low_address.
 * Tcl Result:
 *    The disassembled code is passed to fputs_unfiltered, so it
 *    either goes to the console if result_ptr->obj_ptr is NULL or to
 *    the Tcl result.
 */
d1953 3
a1955 2
static int
gdb_disassemble (clientData, interp, objc, objv)
d1957 2
a1958 3
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
d1960 6
a1965 3
  CORE_ADDR low, high;
  char *arg_ptr;
  int mixed_source_and_assembly;
d1967 7
a1973 5
  if (objc != 3 && objc != 4)
    {
      Tcl_WrongNumArgs (interp, 1, objv, "source lowaddr ?highaddr?");
      return TCL_ERROR;
    }
d1975 4
a1978 7
  arg_ptr = Tcl_GetStringFromObj (objv[1], NULL);
  if (*arg_ptr == 's' && strcmp (arg_ptr, "source") == 0)
    mixed_source_and_assembly = 1;
  else if (*arg_ptr == 'n' && strcmp (arg_ptr, "nosource") == 0)
    mixed_source_and_assembly = 0;
  else
    error ("First arg must be 'source' or 'nosource'");
d1980 1
a1980 1
  low = parse_and_eval_address (Tcl_GetStringFromObj (objv[2], NULL));
d1982 5
a1986 7
  if (objc == 3)
    {
      if (find_pc_partial_function (low, NULL, &low, &high) == 0)
        error ("No function contains specified address");
    }
  else
    high = parse_and_eval_address (Tcl_GetStringFromObj (objv[3], NULL));
d1988 4
a1991 2
  return gdb_disassemble_driver (low, high, mixed_source_and_assembly, NULL,
			  gdbtk_print_source, gdbtk_print_asm);
d1993 3
a1995 1
}
d1997 1
a1997 16
/* This implements the tcl command gdb_load_disassembly
 *
 * Arguments:
 *    widget - the name of a text widget into which to load the data
 *    source_with_assm - must be "source" or "nosource"
 *    low_address - the address from which to start disassembly
 *    ?hi_address? - the address to which to disassemble, defaults
 *                   to the end of the function containing low_address.
 * Tcl Result:
 *    The text widget is loaded with the data, and a list is returned.
 *    The first element of the list is a two element list containing the
 *    real low & high elements, the rest is a mapping between line number
 *    in the text widget, and either the source line number of that line,
 *    if it is a source line, or the assembly address.  You can distinguish
 *    between the two, because the address will start with 0x...
 */
d1999 3
a2001 9
static int
gdb_load_disassembly (ClientData clientData, Tcl_Interp *interp,
		      int objc, Tcl_Obj *CONST objv[])
{
  CORE_ADDR low, high;
  struct disassembly_client_data client_data;
  int mixed_source_and_assembly, ret_val, i;
  char *arg_ptr;
  char *map_name;
d2003 2
a2004 5
  if (objc != 6 && objc != 7)
    {
      Tcl_WrongNumArgs (interp, 1, objv, "[source|nosource] map_arr index_prefix low_address ?hi_address");
      return TCL_ERROR;
    }
d2006 1
a2006 3
  client_data.widget = Tcl_GetStringFromObj (objv[1], NULL);
  if ( Tk_NameToWindow (interp, client_data.widget,
			Tk_MainWindow (interp)) == NULL)
d2008 15
a2022 3
      Tcl_SetStringObj (result_ptr->obj_ptr, "Invalid widget name.", -1);
      return TCL_ERROR;
    }
d2024 1
a2024 37
  if (!Tcl_GetCommandInfo (interp, client_data.widget, &client_data.cmd))
    {
      Tcl_SetStringObj (result_ptr->obj_ptr, "Can't get widget command info",
			-1);
      return TCL_ERROR;
    }

  arg_ptr = Tcl_GetStringFromObj (objv[2], NULL);
  if (*arg_ptr == 's' && strcmp (arg_ptr, "source") == 0)
    mixed_source_and_assembly = 1;
  else if (*arg_ptr == 'n' && strcmp (arg_ptr, "nosource") == 0)
    mixed_source_and_assembly = 0;
  else
    {
      Tcl_SetStringObj (result_ptr->obj_ptr,
			"Second arg must be 'source' or 'nosource'", -1);
      return TCL_ERROR;
    }

  /* As we populate the text widget, we will also create an array in the
     caller's scope.  The name is given by objv[3].
     Each source line gets an entry or the form:
         array($prefix,srcline=$src_line_no) = $widget_line_no

     Each assembly line gets two entries of the form:
         array($prefix,pc=$pc) = $widget_line_no
         array($prefix,line=$widget_line_no) = $src_line_no

     Where prefix is objv[4].
  */
    
  map_name = Tcl_GetStringFromObj (objv[3], NULL);

  if (*map_name != '\0')
    {
      char *prefix;
      int prefix_len;
d2026 3
a2028 5
      client_data.map_arr = "map_array";
      if (Tcl_UpVar (interp, "1", map_name, client_data.map_arr, 0) != TCL_OK) {
	Tcl_SetStringObj (result_ptr->obj_ptr, "Can't link map array.", -1);
	return TCL_ERROR;
      }
d2030 1
a2030 1
      prefix = Tcl_GetStringFromObj (objv[4], &prefix_len);
d2032 2
a2033 11
      Tcl_DStringInit(&client_data.src_to_line_prefix);
      Tcl_DStringAppend (&client_data.src_to_line_prefix,
			 prefix, prefix_len);
      Tcl_DStringAppend (&client_data.src_to_line_prefix, ",srcline=",
				 sizeof (",srcline=") - 1);
			      
      Tcl_DStringInit(&client_data.pc_to_line_prefix);
      Tcl_DStringAppend (&client_data.pc_to_line_prefix,
			 prefix, prefix_len);
      Tcl_DStringAppend (&client_data.pc_to_line_prefix, ",pc=",
			 sizeof (",pc=") - 1);
d2035 1
a2035 10
      Tcl_DStringInit(&client_data.line_to_pc_prefix);
      Tcl_DStringAppend (&client_data.line_to_pc_prefix,
			 prefix, prefix_len);
      Tcl_DStringAppend (&client_data.line_to_pc_prefix, ",line=",
			 sizeof (",line=") - 1);

    }
  else
    {
      client_data.map_arr = "";
a2036 2

  /* Now parse the addresses */
d2038 1
a2038 80
  low = parse_and_eval_address (Tcl_GetStringFromObj (objv[5], NULL));

  if (objc == 6)
    {
      if (find_pc_partial_function (low, NULL, &low, &high) == 0)
        error ("No function contains specified address");
    }
  else
    high = parse_and_eval_address (Tcl_GetStringFromObj (objv[6], NULL));


  /* Setup the client_data structure, and call the driver function. */
  
  client_data.file_opened_p = 0;
  client_data.widget_line_no = 0;
  client_data.interp = interp;
  for (i = 0; i < 3; i++)
    {
      client_data.result_obj[i] = Tcl_NewObj();
      Tcl_IncrRefCount (client_data.result_obj[i]);
    }

  /* Fill up the constant parts of the argv structures */
  client_data.asm_argv[0] = client_data.widget;
  client_data.asm_argv[1] = "insert";
  client_data.asm_argv[2] = "end";
  client_data.asm_argv[3] = "-\t";
  client_data.asm_argv[4] = "break_rgn_tag";
  /* client_data.asm_argv[5] = address; */
  client_data.asm_argv[6] = "break_rgn_tag";
  /* client_data.asm_argv[7] = offset; */
  client_data.asm_argv[8] = "break_rgn_tag";
  client_data.asm_argv[9] = ":\t\t";
  client_data.asm_argv[10] = "source_tag";
  /* client_data.asm_argv[11] = code; */
  client_data.asm_argv[12] = "source_tag";
  client_data.asm_argv[13] = "\n";

  if (mixed_source_and_assembly)
    {
      client_data.source_argv[0] = client_data.widget;
      client_data.source_argv[1] = "insert";
      client_data.source_argv[2] = "end";
      /* client_data.source_argv[3] = line_number; */
      client_data.source_argv[4] = "";
      /* client_data.source_argv[5] = line; */
      client_data.source_argv[6] = "source_tag2";
    }
  
  ret_val = gdb_disassemble_driver (low, high, mixed_source_and_assembly, 
			  (ClientData) &client_data,
			  gdbtk_load_source, gdbtk_load_asm);

  /* Now clean up the opened file, and the Tcl data structures */
  
  if (client_data.file_opened_p == 1) {
    fclose(client_data.fp);
  }
  if (*client_data.map_arr != '\0')
    {
      Tcl_DStringFree(&client_data.src_to_line_prefix);
      Tcl_DStringFree(&client_data.pc_to_line_prefix);
      Tcl_DStringFree(&client_data.line_to_pc_prefix);
    }
  
  for (i = 0; i < 3; i++)
    {
      Tcl_DecrRefCount (client_data.result_obj[i]);
    }
  
  /* Finally, if we were successful, stick the low & high addresses
     into the Tcl result. */

  if (ret_val == TCL_OK) {
    char *buffer;
    Tcl_Obj *limits_obj[2];

    xasprintf (&buffer, "0x%s", paddr_nz (low));
    limits_obj[0] = Tcl_NewStringObj (buffer, -1);
    free(buffer);
d2040 2
a2041 3
    xasprintf (&buffer, "0x%s", paddr_nz (high));
    limits_obj[1] = Tcl_NewStringObj (buffer, -1);
    free(buffer);
d2043 10
a2052 5
    Tcl_DecrRefCount (result_ptr->obj_ptr);
    result_ptr->obj_ptr = Tcl_NewListObj (2, limits_obj);
    
  }
  return ret_val;
d2054 13
d2069 10
a2078 3
static void
gdbtk_load_source (ClientData clientData, struct symtab *symtab, int
		      start_line, int end_line)
d2080 3
a2082 4
  struct disassembly_client_data *client_data =
    (struct disassembly_client_data *) clientData;
  char *buffer;
  int index_len;
d2084 1
a2084 3
  index_len = Tcl_DStringLength (&client_data->src_to_line_prefix);
  
  if (client_data->file_opened_p == 1)
d2086 7
a2092 3
      char **text_argv;
      char line[10000], line_number[18];
      int found_carriage_return = 1;
d2094 5
a2098 1
      /* First do some sanity checks on the requested lines */
d2100 3
a2102 5
      if (start_line < 1
	  || end_line < start_line || end_line > symtab->nlines)
	{
	  return;
	}
d2104 3
a2106 821
      line_number[0] = '\t';
      line[0] = '\t';

      text_argv = client_data->source_argv;
      
      text_argv[3] = line_number;
      text_argv[5] = line;

      if (fseek (client_data->fp, symtab->line_charpos[start_line - 1],
		 SEEK_SET) < 0)
	{
	  fclose(client_data->fp);
	  client_data->file_opened_p = -1;
	  return;
	}
      
      for (; start_line < end_line; start_line++)
	{
	  if (!fgets (line + 1, 9980, client_data->fp))
	    {
	      fclose(client_data->fp);
	      client_data->file_opened_p = -1;
	      return;
	    }

	  client_data->widget_line_no++;
	  
	  sprintf (line_number + 1, "%d", start_line);
	  
	  if (found_carriage_return) {
	    char *p;
	    
	    p = strrchr(line, '\0') - 2;
	    if (*p == '\r') {
	      *p = '\n';
	      *(p + 1) = '\0';
	    } else {
	      found_carriage_return = 0;
	    }
	  }

	  /* Run the command, then add an entry to the map array in
	     the caller's scope, if requested. */
	  
	  client_data->cmd.proc (client_data->cmd.clientData, 
				 client_data->interp, 7, text_argv);
	  
	  if (*client_data->map_arr != '\0')
	    {
	      
	      Tcl_DStringAppend (&client_data->src_to_line_prefix,
				 line_number + 1, -1);
	      
	      /* FIXME: Convert to Tcl_SetVar2Ex when we move to 8.2.  This
		 will allow us avoid converting widget_line_no into a string. */
	      
            xasprintf (&buffer, "%d", client_data->widget_line_no);
	      
	      Tcl_SetVar2 (client_data->interp, client_data->map_arr,
			   Tcl_DStringValue (&client_data->src_to_line_prefix),
			   buffer, 0);
            free(buffer);
	      
	      Tcl_DStringSetLength (&client_data->src_to_line_prefix, index_len);
	    }
	}
      
    }
  else if (!client_data->file_opened_p)
    {
      int fdes;
      /* The file is not yet open, try to open it, then print the
	 first line.  If we fail, set FILE_OPEN_P to -1. */
      
      fdes = open_source_file (symtab);
      if (fdes < 0)
	{
	  client_data->file_opened_p = -1;
	}
      else
	{
          /* FIXME: Convert to a Tcl File Channel and read from there.
	     This will allow us to get the line endings and conversion
	     to UTF8 right automatically when we move to 8.2.
	     Need a Cygwin call to convert a file descriptor to the native
	     Windows handler to do this. */
	     
	  client_data->file_opened_p = 1;
	  client_data->fp = fdopen (fdes, FOPEN_RB);
	  clearerr (client_data->fp);
	  
          if (symtab->line_charpos == 0)
            find_source_lines (symtab, fdes);

	  /* We are called with an actual load request, so call ourselves
	     to load the first line. */
	  
	  gdbtk_load_source (clientData, symtab, start_line, end_line);
	}
    }
  else {
    /* If we couldn't open the file, or got some prior error, just exit. */
    
    return;
  }

}


static CORE_ADDR
gdbtk_load_asm (clientData, pc, di)
     ClientData clientData;
     CORE_ADDR pc;
     struct disassemble_info *di;
{
  struct disassembly_client_data * client_data
    = (struct disassembly_client_data *) clientData;
  char **text_argv;
  int i, pc_to_line_len, line_to_pc_len;
  gdbtk_result new_result;
  struct cleanup *old_chain = NULL;

  pc_to_line_len = Tcl_DStringLength (&client_data->pc_to_line_prefix);
  line_to_pc_len = Tcl_DStringLength (&client_data->line_to_pc_prefix);
    
  text_argv = client_data->asm_argv;
  
  /* Preserve the current Tcl result object, print out what we need, and then
     suck it out of the result, and replace... */

  old_chain = make_cleanup (gdbtk_restore_result_ptr, (void *) result_ptr);
  result_ptr = &new_result;
  result_ptr->obj_ptr = client_data->result_obj[0];
  result_ptr->flags = GDBTK_TO_RESULT;

  /* Null out the three return objects we will use. */

  for (i = 0; i < 3; i++)
    Tcl_SetObjLength (client_data->result_obj[i], 0);
  
  print_address_numeric (pc, 1, gdb_stdout);
  gdb_flush (gdb_stdout);

  result_ptr->obj_ptr = client_data->result_obj[1];
  
  print_address_symbolic (pc, gdb_stdout, 1, "\t");
  gdb_flush (gdb_stdout);

  result_ptr->obj_ptr = client_data->result_obj[2];
  pc += (*tm_print_insn) (pc, di);
  gdb_flush (gdb_stdout);

  client_data->widget_line_no++;

  text_argv[5] = Tcl_GetStringFromObj (client_data->result_obj[0], NULL);
  text_argv[7] = Tcl_GetStringFromObj (client_data->result_obj[1], NULL);
  text_argv[11] = Tcl_GetStringFromObj (client_data->result_obj[2], NULL);

  client_data->cmd.proc (client_data->cmd.clientData, 
				     client_data->interp, 14, text_argv);

  if (*client_data->map_arr != '\0')
    {
      char *buffer;
      
      /* Run the command, then add an entry to the map array in
	 the caller's scope. */
      
      Tcl_DStringAppend (&client_data->pc_to_line_prefix, text_argv[5], -1);
      
      /* FIXME: Convert to Tcl_SetVar2Ex when we move to 8.2.  This
	 will allow us avoid converting widget_line_no into a string. */
      
      xasprintf (&buffer, "%d", client_data->widget_line_no);
      
      Tcl_SetVar2 (client_data->interp, client_data->map_arr,
		   Tcl_DStringValue (&client_data->pc_to_line_prefix),
		   buffer, 0);

      Tcl_DStringAppend (&client_data->line_to_pc_prefix, buffer, -1);
      
      Tcl_SetVar2 (client_data->interp, client_data->map_arr,
		   Tcl_DStringValue (&client_data->line_to_pc_prefix),
		   text_argv[5], 0);

      /* Restore the prefixes to their initial state. */
      
      Tcl_DStringSetLength (&client_data->pc_to_line_prefix, pc_to_line_len);      
      Tcl_DStringSetLength (&client_data->line_to_pc_prefix, line_to_pc_len);      
      
      free(buffer);
    }
  
  do_cleanups (old_chain);
    
  return pc;
}

static void
gdbtk_print_source (clientData, symtab, start_line, end_line)
     ClientData clientData;
     struct symtab *symtab;
     int start_line;
     int end_line;
{
  print_source_lines (symtab, start_line, end_line, 0);
  gdb_flush (gdb_stdout);
}

static CORE_ADDR
gdbtk_print_asm (clientData, pc, di)
     ClientData clientData;
     CORE_ADDR pc;
     struct disassemble_info *di;
{
  fputs_unfiltered ("    ", gdb_stdout);
  print_address (pc, gdb_stdout);
  fputs_unfiltered (":\t    ", gdb_stdout);
  pc += (*tm_print_insn) (pc, di);
  fputs_unfiltered ("\n", gdb_stdout);
  gdb_flush (gdb_stdout);
  return pc;
}

static int
gdb_disassemble_driver (low, high, mixed_source_and_assembly,
			clientData, print_source_fn, print_asm_fn)
     CORE_ADDR low;
     CORE_ADDR high;
     int mixed_source_and_assembly;
     ClientData clientData; 
     void (*print_source_fn) (ClientData, struct symtab *, int, int);
     CORE_ADDR (*print_asm_fn) (ClientData, CORE_ADDR,
				struct disassemble_info *);
{
  CORE_ADDR pc;
  static disassemble_info di;
  static int di_initialized;

  if (! di_initialized)
    {
      INIT_DISASSEMBLE_INFO_NO_ARCH (di, gdb_stdout,
                                     (fprintf_ftype) fprintf_unfiltered);
      di.flavour = bfd_target_unknown_flavour;
      di.memory_error_func = dis_asm_memory_error;
      di.print_address_func = dis_asm_print_address;
      di_initialized = 1;
    }

  di.mach = TARGET_PRINT_INSN_INFO->mach;
  if (TARGET_BYTE_ORDER == BIG_ENDIAN)
    di.endian = BFD_ENDIAN_BIG;
  else
    di.endian = BFD_ENDIAN_LITTLE;

  /* Set the architecture for multi-arch configurations. */
  if (TARGET_ARCHITECTURE != NULL)
    di.mach = TARGET_ARCHITECTURE->mach;

  /* If disassemble_from_exec == -1, then we use the following heuristic to
     determine whether or not to do disassembly from target memory or from the
     exec file:

     If we're debugging a local process, read target memory, instead of the
     exec file.  This makes disassembly of functions in shared libs work
     correctly.  Also, read target memory if we are debugging native threads.

     Else, we're debugging a remote process, and should disassemble from the
     exec file for speed.  However, this is no good if the target modifies its
     code (for relocation, or whatever).

     As an aside, it is fairly bogus that there is not a better way to
     determine where to disassemble from.  There should be a target vector
     entry for this or something.
     
   */

  if (disassemble_from_exec == -1)
    {
      if (strcmp (target_shortname, "child") == 0
          || strcmp (target_shortname, "procfs") == 0
          || strcmp (target_shortname, "vxprocess") == 0
	  || strstr (target_shortname, "threads") != NULL)
	/* It's a child process, read inferior mem */
        disassemble_from_exec = 0; 
      else
	/* It's remote, read the exec file */
        disassemble_from_exec = 1; 
    }

  if (disassemble_from_exec)
    di.read_memory_func = gdbtk_dis_asm_read_memory;
  else
    di.read_memory_func = dis_asm_read_memory;

  /* If just doing straight assembly, all we need to do is disassemble
     everything between low and high.  If doing mixed source/assembly, we've
     got a totally different path to follow.  */

  if (mixed_source_and_assembly)
    {				/* Come here for mixed source/assembly */
      /* The idea here is to present a source-O-centric view of a function to
         the user.  This means that things are presented in source order, with
         (possibly) out of order assembly immediately following.  */
      struct symtab *symtab;
      struct linetable_entry *le;
      int nlines;
      int newlines;
      struct my_line_entry *mle;
      struct symtab_and_line sal;
      int i;
      int out_of_order;
      int next_line;
      
      /* Assume symtab is valid for whole PC range */
      symtab = find_pc_symtab (low); 

      if (!symtab || !symtab->linetable)
        goto assembly_only;

      /* First, convert the linetable to a bunch of my_line_entry's.  */

      le = symtab->linetable->item;
      nlines = symtab->linetable->nitems;

      if (nlines <= 0)
        goto assembly_only;

      mle = (struct my_line_entry *) alloca (nlines *
					     sizeof (struct my_line_entry));

      out_of_order = 0;
      
      /* Copy linetable entries for this function into our data structure,
	 creating end_pc's and setting out_of_order as appropriate.  */

      /* First, skip all the preceding functions.  */

      for (i = 0; i < nlines - 1 && le[i].pc < low; i++) ;

      /* Now, copy all entries before the end of this function.  */

      newlines = 0;
      for (; i < nlines - 1 && le[i].pc < high; i++)
        {
          if (le[i].line == le[i + 1].line
              && le[i].pc == le[i + 1].pc)
            continue;		/* Ignore duplicates */

	  /* GCC sometimes emits line directives with a linenumber
	     of 0.  It does this to handle live range splitting.
	     This may be a bug, but we need to be able to handle it.
	     For now, use the previous instructions line number.
	     Since this is a bit of a hack anyway, we will just lose
	     if the bogus sline is the first line of the range.  For
	     functions, I have never seen this to be the case.  */
	  
	  if (le[i].line != 0)
	    {
	      mle[newlines].line = le[i].line;
	    }
	  else
	    {
	      if (newlines > 0)
		mle[newlines].line = mle[newlines - 1].line;
	    }
	  
          if (le[i].line > le[i + 1].line)
            out_of_order = 1;
          mle[newlines].start_pc = le[i].pc;
          mle[newlines].end_pc = le[i + 1].pc;
          newlines++;
        }

      /* If we're on the last line, and it's part of the function, then we 
         need to get the end pc in a special way.  */

      if (i == nlines - 1
          && le[i].pc < high)
        {
          mle[newlines].line = le[i].line;
          mle[newlines].start_pc = le[i].pc;
          sal = find_pc_line (le[i].pc, 0);
          mle[newlines].end_pc = sal.end;
          newlines++;
        }

      /* Now, sort mle by line #s (and, then by addresses within lines). */

      if (out_of_order)
        qsort (mle, newlines, sizeof (struct my_line_entry), compare_lines);

      /* Now, for each line entry, emit the specified lines (unless they have
	 been emitted before), followed by the assembly code for that line.  */

      next_line = 0;		/* Force out first line */
      for (i = 0; i < newlines; i++)
        {
          /* Print out everything from next_line to the current line.  */

          if (mle[i].line >= next_line)
            {
              if (next_line != 0)
                print_source_fn (clientData, symtab, next_line,
				 mle[i].line + 1);
              else
                print_source_fn (clientData, symtab, mle[i].line,
				 mle[i].line + 1);

              next_line = mle[i].line + 1;
            }

          for (pc = mle[i].start_pc; pc < mle[i].end_pc; )
            {
              QUIT;
	      pc = print_asm_fn (clientData, pc, &di);
            }
        }
    }
  else
    {
    assembly_only:
      for (pc = low; pc < high; )
        {
          QUIT;
	  pc = print_asm_fn (clientData, pc, &di);
        }
    }

  return TCL_OK;
}

/* This is the memory_read_func for gdb_disassemble when we are
   disassembling from the exec file. */

static int
gdbtk_dis_asm_read_memory (memaddr, myaddr, len, info)
     bfd_vma memaddr;
     bfd_byte *myaddr;
     unsigned int len;
     disassemble_info *info;
{
  extern struct target_ops exec_ops;
  int res;

  errno = 0;
  res = xfer_memory (memaddr, myaddr, len, 0, 0, &exec_ops);

  if (res == len)
    return 0;
  else if (errno == 0)
    return EIO;
  else
    return errno;
}

/* This will be passed to qsort to sort the results of the disassembly */

static int
compare_lines (mle1p, mle2p)
     const PTR mle1p;
     const PTR mle2p;
{
  struct my_line_entry *mle1, *mle2;
  int val;

  mle1 = (struct my_line_entry *) mle1p;
  mle2 = (struct my_line_entry *) mle2p;

  val = mle1->line - mle2->line;

  if (val != 0)
    return val;

  return mle1->start_pc - mle2->start_pc;
}

/* This implements the TCL command `gdb_loc',

 * Arguments:
 *    ?symbol? The symbol or address to locate - defaults to pc
 * Tcl Return:
 *    a list consisting of the following:                                  
 *       basename, function name, filename, line number, address, current pc
 */

static int
gdb_loc (ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
{
  char *filename;
  struct symtab_and_line sal;
  char *fname;
  CORE_ADDR pc;

  if (objc == 1)
    {
      if (selected_frame && (selected_frame->pc != read_pc ()))
        {
          /* Note - this next line is not correct on all architectures.
	     For a graphical debugger we really want to highlight the 
	     assembly line that called the next function on the stack.
	     Many architectures have the next instruction saved as the
	     pc on the stack, so what happens is the next instruction 
	     is highlighted. FIXME */
	  pc = selected_frame->pc;
	  sal = find_pc_line (selected_frame->pc,
			      selected_frame->next != NULL
			      && !selected_frame->next->signal_handler_caller
			      && !frame_in_dummy (selected_frame->next));
	}
      else
        {
          pc = read_pc ();
          sal = find_pc_line (pc, 0);
        }
    }
  else if (objc == 2)
    {
      struct symtabs_and_lines sals;
      int nelts;

      sals = decode_line_spec (Tcl_GetStringFromObj (objv[1], NULL), 1);

      nelts = sals.nelts;
      sal = sals.sals[0];
      free (sals.sals);

      if (sals.nelts != 1)
	{
	  Tcl_SetStringObj (result_ptr->obj_ptr, "Ambiguous line spec", -1);
	  return TCL_ERROR;
	}
      resolve_sal_pc (&sal);
      pc = sal.pc;
    }
  else
    {
      Tcl_WrongNumArgs (interp, 1, objv, "?symbol?");
      return TCL_ERROR;
    }

  if (sal.symtab)
    Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr,
			      Tcl_NewStringObj (sal.symtab->filename, -1));
  else
    Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr,
			      Tcl_NewStringObj ("", 0));

  fname = pc_function_name (pc);
  Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr,
			    Tcl_NewStringObj (fname, -1));

  filename = symtab_to_filename (sal.symtab);
  if (filename == NULL)
    filename = "";

  /* file name */
  Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr,
			    Tcl_NewStringObj (filename, -1));
  /* line number */
  Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr,
			    Tcl_NewIntObj (sal.line));
  /* PC in current frame */
  sprintf_append_element_to_obj (result_ptr->obj_ptr, "0x%s", paddr_nz (pc));
  /* Real PC */
  sprintf_append_element_to_obj (result_ptr->obj_ptr, "0x%s",
				 paddr_nz (stop_pc));

  /* shared library */
#ifdef PC_SOLIB
  Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr,
			    Tcl_NewStringObj (PC_SOLIB (pc), -1));
#else
  Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr,
			    Tcl_NewStringObj ("", -1));
#endif
  return TCL_OK;
}

/* This implements the TCL command gdb_entry_point.  It returns the current
   entry point address.  */

static int
gdb_entry_point (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
{
  char *addrstr;

  /* If we have not yet loaded an exec file, then we have no
     entry point, so return an empty string.*/
  if ((int) current_target.to_stratum > (int) dummy_stratum)
    {
      addrstr = paddr_nz (entry_point_address ());
      Tcl_SetStringObj (result_ptr->obj_ptr, addrstr, -1);
    }
  else
    Tcl_SetStringObj (result_ptr->obj_ptr, "", -1);

  return TCL_OK;
}

/* This implements the Tcl command 'gdb_get_mem', which 
 * dumps a block of memory 
 * Arguments:
 *   gdb_get_mem addr form size nbytes bpr aschar
 *
 *   addr: address of data to dump
 *   form: a char indicating format
 *   size: size of each element; 1,2,4, or 8 bytes
 *   nbytes: the number of bytes to read 
 *   bpr: bytes per row
 *   aschar: if present, an ASCII dump of the row is included.  ASCHAR
 *   used for unprintable characters.
 * 
 * Return:
 * a list of elements followed by an optional ASCII dump */

static int
gdb_get_mem (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
{
  int size, asize, i, j, bc;
  CORE_ADDR addr;
  int nbytes, rnum, bpr;
  long tmp;
  char format, buff[128], aschar, *mbuf, *mptr, *cptr, *bptr;
  struct type *val_type;

  if (objc < 6 || objc > 7)
    {
      Tcl_SetStringObj (result_ptr->obj_ptr,
			"addr format size bytes bytes_per_row ?ascii_char?",
			-1);
      return TCL_ERROR;
    }

  if (Tcl_GetIntFromObj (interp, objv[3], &size) != TCL_OK)
    {
      result_ptr->flags |= GDBTK_IN_TCL_RESULT;
      return TCL_ERROR;
    }
  else if (size <= 0)
    {
      Tcl_SetStringObj (result_ptr->obj_ptr, "Invalid size, must be > 0", -1);
      return TCL_ERROR;
    }

  if (Tcl_GetIntFromObj (interp, objv[4], &nbytes) != TCL_OK)
    {
      result_ptr->flags |= GDBTK_IN_TCL_RESULT;
      return TCL_ERROR;
    }
  else if (nbytes <= 0)
    {
      Tcl_SetStringObj (result_ptr->obj_ptr,
			"Invalid number of bytes, must be > 0",
			-1);
      return TCL_ERROR;
    }

  if (Tcl_GetIntFromObj (interp, objv[5], &bpr) != TCL_OK)
    {
      result_ptr->flags |= GDBTK_IN_TCL_RESULT;
      return TCL_ERROR;
    }
  else if (bpr <= 0)
    {
      Tcl_SetStringObj (result_ptr->obj_ptr,
			"Invalid bytes per row, must be > 0", -1);
      return TCL_ERROR;
    }

  if (Tcl_GetLongFromObj (interp, objv[1], &tmp) != TCL_OK)
    return TCL_OK;

  addr = (CORE_ADDR) tmp;

  format = *(Tcl_GetStringFromObj (objv[2], NULL));
  mbuf = (char *) malloc (nbytes + 32);
  if (!mbuf)
    {
      Tcl_SetStringObj (result_ptr->obj_ptr, "Out of memory.", -1);
      return TCL_ERROR;
    }

  memset (mbuf, 0, nbytes + 32);
  mptr = cptr = mbuf;

  rnum = 0;
  while (rnum < nbytes)
    {
      int error;
      int num = target_read_memory_partial (addr + rnum, mbuf + rnum,
					    nbytes - rnum, &error);
      if (num <= 0)
	break;
      rnum += num;
    }

  if (objc == 7)
    aschar = *(Tcl_GetStringFromObj (objv[6], NULL));
  else
    aschar = 0;

  switch (size)
    {
    case 1:
      val_type = builtin_type_int8;
      asize = 'b';
      break;
    case 2:
      val_type = builtin_type_int16;
      asize = 'h';
      break;
    case 4:
      val_type = builtin_type_int32;
      asize = 'w';
      break;
    case 8:
      val_type = builtin_type_int64;
      asize = 'g';
      break;
    default:
      val_type = builtin_type_int8;
      asize = 'b';
    }

  bc = 0;			/* count of bytes in a row */
  bptr = &buff[0];		/* pointer for ascii dump */

  /* Build up the result as a list... */
  
  result_ptr->flags |= GDBTK_MAKES_LIST;	

  for (i = 0; i < nbytes; i += size)
    {
      if (i >= rnum)
	{
	  Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr,
				    Tcl_NewStringObj ("N/A", 3));
	  if (aschar)
	    for (j = 0; j < size; j++)
	      *bptr++ = 'X';
	}
      else
	{
	  print_scalar_formatted (mptr, val_type, format, asize, gdb_stdout);

	  if (aschar)
	    {
	      for (j = 0; j < size; j++)
		{
		  *bptr = *cptr++;
		  if (*bptr < 32 || *bptr > 126)
		    *bptr = aschar;
		  bptr++;
		}
	    }
	}

      mptr += size;
      bc += size;

      if (aschar && (bc >= bpr))
	{
	  /* end of row. Add it to the result and reset variables */
	  Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr,
				    Tcl_NewStringObj (buff, bc));
	  bc = 0;
	  bptr = &buff[0];
	}
    }

  result_ptr->flags &= ~GDBTK_MAKES_LIST;

  free (mbuf);
  return TCL_OK;
}


/* This implements the tcl command "gdb_loadfile"
 * It loads a c source file into a text widget.
 *
 * Tcl Arguments:
 *    widget: the name of the text widget to fill
 *    filename: the name of the file to load
 *    linenumbers: A boolean indicating whether or not to display line numbers.
 * Tcl Result:
 *
 */

/* In this routine, we will build up a "line table", i.e. a
 * table of bits showing which lines in the source file are executible.
 * LTABLE_SIZE is the number of bytes to allocate for the line table.
 *
 * Its size limits the maximum number of lines 
 * in a file to 8 * LTABLE_SIZE.  This memory is freed after 
 * the file is loaded, so it is OK to make this very large. 
 * Additional memory will be allocated if needed. */
#define LTABLE_SIZE 20000
static int
gdb_loadfile (ClientData clientData, Tcl_Interp *interp, int objc,
	      Tcl_Obj *CONST objv[])
{
  char *file, *widget;
  int linenumbers, ln, lnum, ltable_size;
  FILE *fp;
  char *ltable;
  struct symtab *symtab;
  struct linetable_entry *le;
  long mtime = 0;
  struct stat st;
  char line[10000], line_num_buf[18];
  char *text_argv[9];
  Tcl_CmdInfo text_cmd;
d2108 3
a2110 6
 
  if (objc != 4)
    {
      Tcl_WrongNumArgs(interp, 1, objv, "widget filename linenumbers");
      return TCL_ERROR; 
    }
d2112 3
a2114 5
  widget = Tcl_GetStringFromObj (objv[1], NULL);
  if ( Tk_NameToWindow (interp, widget, Tk_MainWindow (interp)) == NULL)
    {
      return TCL_ERROR;
    }
d2116 5
a2120 9
  if (!Tcl_GetCommandInfo (interp, widget, &text_cmd))
    {
      Tcl_SetStringObj (result_ptr->obj_ptr, "Can't get widget command info",
			-1);
      return TCL_ERROR;
    }
  
  file  = Tcl_GetStringFromObj (objv[2], NULL);
  Tcl_GetBooleanFromObj (interp, objv[3], &linenumbers);
d2122 1
a2122 2
  symtab = full_lookup_symtab (file);
  if (!symtab)
d2124 9
a2132 2
      Tcl_SetStringObj ( result_ptr->obj_ptr, "File not found in symtab", -1);
      return TCL_ERROR;
d2135 4
a2138 7
  file = symtab_to_filename ( symtab );
  if ((fp = fopen ( file, "r" )) == NULL)
    {
      Tcl_SetStringObj ( result_ptr->obj_ptr, "Can't open file for reading",
			 -1);
      return TCL_ERROR;
    }
d2140 3
a2142 6
  if (stat (file, &st) < 0)
    {
      catch_errors (perror_with_name_wrapper, "gdbtk: get time stamp", "",
                    RETURN_MASK_ALL);
      return TCL_ERROR;
    }
d2144 17
a2160 15
  if (symtab && symtab->objfile && symtab->objfile->obfd)
      mtime = bfd_get_mtime(symtab->objfile->obfd);
  else if (exec_bfd)
      mtime = bfd_get_mtime(exec_bfd);
 
  if (mtime && mtime < st.st_mtime)
    {
      gdbtk_ignorable_warning("file_times",\
			      "Source file is more recent than executable.\n");
    }
  
  
  /* Source linenumbers don't appear to be in order, and a sort is */
  /* too slow so the fastest solution is just to allocate a huge */
  /* array and set the array entry for each linenumber */
d2162 2
a2163 8
  ltable_size = LTABLE_SIZE;
  ltable = (char *)malloc (LTABLE_SIZE);
  if (ltable == NULL)
    {
      Tcl_SetStringObj ( result_ptr->obj_ptr, "Out of memory.", -1);
      fclose (fp);
      return TCL_ERROR;
    }
d2165 1
a2165 1
  memset (ltable, 0, LTABLE_SIZE);
a2166 2
  if (symtab->linetable && symtab->linetable->nitems)
    {
d2168 9
a2176 22
      for (ln = symtab->linetable->nitems ;ln > 0; ln--, le++)
        {
          lnum = le->line >> 3;
          if (lnum >= ltable_size)
            {
              char *new_ltable;
              new_ltable = (char *)realloc (ltable, ltable_size*2);
              memset (new_ltable + ltable_size, 0, ltable_size);
              ltable_size *= 2;
              if (new_ltable == NULL)
                {
                  Tcl_SetStringObj ( result_ptr->obj_ptr, "Out of memory.",
				     -1);
                  free (ltable);
                  fclose (fp);
                  return TCL_ERROR;
                }
              ltable = new_ltable;
            }
          ltable[lnum] |= 1 << (le->line % 8);
        }
    }
d2178 8
a2185 1
  ln = 1;
d2187 2
a2188 17
  line[0] = '\t'; 
  text_argv[0] = widget;
  text_argv[1] = "insert";
  text_argv[2] = "end";
  text_argv[5] = line;
  text_argv[6] = "source_tag";
  text_argv[8] = NULL;
  
  if (linenumbers)
    {
      int found_carriage_return = 1;
      
      line_num_buf[1] = '\t';
       
      text_argv[3] = line_num_buf;
      
      while (fgets (line + 1, 9980, fp))
d2190 11
a2200 5
	  /* Look for DOS style \r\n endings, and if found,
	   * strip off the \r.  We assume (for the sake of
	   * speed) that ALL lines in the file have DOS endings,
	   * or none do.
	   */
d2202 5
a2206 1
	  if (found_carriage_return)
d2208 2
a2209 9
	      char *p;
	      
	      p = strrchr(line, '\0') - 2;
	      if (*p == '\r') {
		*p = '\n';
		*(p + 1) = '\0';
	      } else {
		found_carriage_return = 0;
	      }
d2212 5
a2216 14
          sprintf (line_num_buf+2, "%d", ln);
          if (ltable[ln >> 3] & (1 << (ln % 8)))
            {
	      line_num_buf[0] = '-';
              text_argv[4] = "break_rgn_tag";
            }
          else
            {
	      line_num_buf[0] = ' ';
              text_argv[4] = "";
            }

          text_cmd.proc(text_cmd.clientData, interp, 7, text_argv);
          ln++;
a2217 29
    }
  else
    {
      int found_carriage_return = 1;
            
      while (fgets (line + 1, 9980, fp))
        {
	  if (found_carriage_return) {
	    char *p;
	    
	    p = strrchr(line, '\0') - 2;
	    if (*p == '\r') {
	      *p = '\n';
	      *(p + 1) = '\0';
	    } else {
	      found_carriage_return = 0;
	    }
	  }

          if (ltable[ln >> 3] & (1 << (ln % 8)))
            {
              text_argv[3] = "- ";
              text_argv[4] = "break_rgn_tag";
            }
          else
            {
              text_argv[3] = "  ";
              text_argv[4] = "";
            }
d2219 2
a2220 4
          text_cmd.proc(text_cmd.clientData, interp, 7, text_argv);
          ln++;
	}
    }
d2222 9
a2230 8
  free (ltable);
  fclose (fp);
  return TCL_OK;
}

/*
 *  This section contains commands for manipulation of breakpoints.
 */
d2232 1
d2234 2
a2235 18
/* set a breakpoint by source file and line number */
/* flags are as follows: */
/* least significant 2 bits are disposition, rest is */
/* type (normally 0).

   enum bptype {
   bp_breakpoint,                Normal breakpoint 
   bp_hardware_breakpoint,      Hardware assisted breakpoint
   }

   Disposition of breakpoint.  Ie: what to do after hitting it.
   enum bpdisp {
   del,                         Delete it
   del_at_next_stop,            Delete at next stop, whether hit or not
   disable,                     Disable it 
   donttouch                    Leave it alone 
   };
 */
d2237 2
a2238 11
/* This implements the tcl command "gdb_set_bp"
 * It sets breakpoints, and notifies the GUI.
 *
 * Tcl Arguments:
 *    filename: the file in which to set the breakpoint
 *    line:     the line number for the breakpoint
 *    type:     the type of the breakpoint
 *    thread:   optional thread number
 * Tcl Result:
 *    The return value of the call to gdbtk_tcl_breakpoint.
 */
d2240 4
a2243 13
static int
gdb_set_bp (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
{
  struct symtab_and_line sal;
  int line, thread = -1;
  struct breakpoint *b;
  char *buf, *typestr;
  Tcl_DString cmd;
  enum bpdisp disp;
d2245 8
a2252 5
  if (objc != 4 && objc != 5)
    {
      Tcl_WrongNumArgs (interp, 1, objv, "filename line type ?thread?");
      return TCL_ERROR;
    }
d2254 2
a2255 3
  sal.symtab = full_lookup_symtab (Tcl_GetStringFromObj (objv[1], NULL));
  if (sal.symtab == NULL)
    return TCL_ERROR;
d2257 6
a2262 11
  if (Tcl_GetIntFromObj (interp, objv[2], &line) == TCL_ERROR)
    {
      result_ptr->flags = GDBTK_IN_TCL_RESULT;
      return TCL_ERROR;
    }

  typestr = Tcl_GetStringFromObj (objv[3], NULL);
  if (typestr == NULL)
    {
      result_ptr->flags = GDBTK_IN_TCL_RESULT;
      return TCL_ERROR;
a2263 4
  if (strncmp (typestr, "temp", 4) == 0)
    disp = del;
  else if (strncmp (typestr, "normal", 6) == 0)
    disp = donttouch;
d2266 6
a2271 12
      Tcl_SetStringObj (result_ptr->obj_ptr,
			"type must be \"temp\" or \"normal\"", -1);
      return TCL_ERROR;
    }

  if (objc == 5)
    {
      if (Tcl_GetIntFromObj (interp, objv[4], &thread) == TCL_ERROR)
	{
	  result_ptr->flags = GDBTK_IN_TCL_RESULT;
	  return TCL_ERROR;
	}
a2273 20
  sal.line = line;
  if (!find_line_pc (sal.symtab, sal.line, &sal.pc))
    return TCL_ERROR;

  sal.section = find_pc_overlay (sal.pc);
  b = set_raw_breakpoint (sal);
  set_breakpoint_count (breakpoint_count + 1);
  b->number = breakpoint_count;
  b->type = bp_breakpoint;
  b->disposition = disp;
  b->thread = thread;

  /* FIXME: this won't work for duplicate basenames! */
  xasprintf (&buf, "%s:%d", basename (Tcl_GetStringFromObj (objv[1], NULL)),
	   line);
  b->addr_string = xstrdup (buf);
  free(buf);

  /* now send notification command back to GUI */
  create_breakpoint_hook (b);
d2277 2
a2278 10
/* This implements the tcl command "gdb_set_bp_addr"
 * It sets breakpoints, and notifies the GUI.
 *
 * Tcl Arguments:
 *    addr: the address at which to set the breakpoint
 *    type:     the type of the breakpoint
 *    thread:   optional thread number
 * Tcl Result:
 *    The return value of the call to gdbtk_tcl_breakpoint.
 */
d2281 5
a2285 3
gdb_set_bp_addr (ClientData clientData, Tcl_Interp *interp, int objc,
		 Tcl_Obj *CONST objv[])
     
d2287 2
a2288 7
  struct symtab_and_line sal;
  int thread = -1;
  long addr;
  struct breakpoint *b;
  char *filename, *typestr, *buf;
  Tcl_DString cmd;
  enum bpdisp disp;
d2290 2
a2291 5
  if (objc != 3 && objc != 4)
    {
      Tcl_WrongNumArgs (interp, 1, objv, "address type ?thread?");
      return TCL_ERROR;
    }
d2293 4
a2296 16
  if (Tcl_GetLongFromObj (interp, objv[1], &addr) == TCL_ERROR)
    {
      result_ptr->flags = GDBTK_IN_TCL_RESULT;
      return TCL_ERROR;
    }

  typestr = Tcl_GetStringFromObj (objv[2], NULL);
  if (typestr == NULL)
    {
      result_ptr->flags = GDBTK_IN_TCL_RESULT;
      return TCL_ERROR;
    }
  if (strncmp (typestr, "temp", 4) == 0)
    disp = del;
  else if (strncmp (typestr, "normal", 6) == 0)
    disp = donttouch;
d2298 1
a2298 30
    {
      Tcl_SetStringObj (result_ptr->obj_ptr,
			"type must be \"temp\" or \"normal\"", -1);
      return TCL_ERROR;
    }

  if (objc == 4)
    {
      if (Tcl_GetIntFromObj (interp, objv[3], &thread) == TCL_ERROR)
	{
	  result_ptr->flags = GDBTK_IN_TCL_RESULT;
	  return TCL_ERROR;
	}
    }

  sal = find_pc_line (addr, 0);
  sal.pc = addr;
  b = set_raw_breakpoint (sal);
  set_breakpoint_count (breakpoint_count + 1);
  b->number = breakpoint_count;
  b->type = bp_breakpoint;
  b->disposition = disp;
  b->thread = thread;

  xasprintf (&buf, "*(0x%lx)", addr);
  b->addr_string = xstrdup (buf);

  /* now send notification command back to GUI */
  create_breakpoint_hook (b);
  return TCL_OK;
d2301 1
a2301 8
/* This implements the tcl command "gdb_find_bp_at_line"

 * Tcl Arguments:
 *    filename: the file in which to find the breakpoint
 *    line:     the line number for the breakpoint
 * Tcl Result:
 *    It returns a list of breakpoint numbers
 */
d2304 3
a2306 6
gdb_find_bp_at_line (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];

d2308 2
a2309 4
  struct symtab *s;
  int line;
  struct breakpoint *b;
  extern struct breakpoint *breakpoint_chain;
d2311 2
a2312 5
  if (objc != 3)
    {
      Tcl_WrongNumArgs (interp, 1, objv, "filename line");
      return TCL_ERROR;
    }
d2314 1
a2314 3
  s = full_lookup_symtab (Tcl_GetStringFromObj (objv[1], NULL));
  if (s == NULL)
    return TCL_ERROR;
d2316 2
a2317 5
  if (Tcl_GetIntFromObj (interp, objv[2], &line) == TCL_ERROR)
    {
      result_ptr->flags = GDBTK_IN_TCL_RESULT;
      return TCL_ERROR;
    }
d2319 1
a2319 7
  Tcl_SetListObj (result_ptr->obj_ptr, 0, NULL);
  for (b = breakpoint_chain; b; b = b->next)
    if (b->line_number == line && !strcmp (b->source_file, s->filename))
      Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr,
				Tcl_NewIntObj (b->number));

  return TCL_OK;
d2322 1
d2324 5
a2328 6
/* This implements the tcl command "gdb_find_bp_at_addr"

 * Tcl Arguments:
 *    addr:     address
 * Tcl Result:
 *    It returns a list of breakpoint numbers
d2332 1
a2332 6
gdb_find_bp_at_addr (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];

d2334 4
a2337 3
  long addr;
  struct breakpoint *b;
  extern struct breakpoint *breakpoint_chain;
d2339 1
a2339 1
  if (objc != 2)
d2341 19
a2359 2
      Tcl_WrongNumArgs (interp, 1, objv, "address");
      return TCL_ERROR;
d2361 1
a2361 2

  if (Tcl_GetLongFromObj (interp, objv[1], &addr) == TCL_ERROR)
d2363 2
a2364 3
      result_ptr->flags = GDBTK_IN_TCL_RESULT;
      return TCL_ERROR;
    }
d2366 1
a2366 5
  Tcl_SetListObj (result_ptr->obj_ptr, 0, NULL);
  for (b = breakpoint_chain; b; b = b->next)
    if (b->address == (CORE_ADDR) addr)
      Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr,
				Tcl_NewIntObj (b->number));
d2368 3
a2370 2
  return TCL_OK;
}
d2372 7
a2378 28
/* This implements the tcl command gdb_get_breakpoint_info


 * Tcl Arguments:
 *   breakpoint_number
 * Tcl Result:
 *   A list with {file, function, line_number, address, type, enabled?,
 *                disposition, ignore_count, {list_of_commands},
 *                condition, thread, hit_count}
 */

static int
gdb_get_breakpoint_info (ClientData clientData, Tcl_Interp *interp, int objc,
			 Tcl_Obj *CONST objv[])
{
  struct symtab_and_line sal;
  struct command_line *cmd;
  int bpnum;
  struct breakpoint *b;
  extern struct breakpoint *breakpoint_chain;
  char *funcname, *filename;

  Tcl_Obj *new_obj;

  if (objc != 2)
    {
      Tcl_WrongNumArgs (interp, 1, objv, "breakpoint");
      return TCL_ERROR;
d2380 1
a2380 2

  if (Tcl_GetIntFromObj (NULL, objv[1], &bpnum) != TCL_OK)
d2382 1
a2382 1
      result_ptr->flags = GDBTK_IN_TCL_RESULT;
d2386 6
a2391 21
  for (b = breakpoint_chain; b; b = b->next)
    if (b->number == bpnum)
      break;

  if (!b || b->type != bp_breakpoint)
    {
      /* Hack. Check if this BP is being deleted. See comments
	 around the definition of gdbtk_deleted_bp in
	 gdbtk-hooks.c. */
      struct breakpoint *dbp = (struct breakpoint *) gdbtk_deleted_bp;
      if (dbp && dbp->number == bpnum)
	b = dbp;
      else
	{
	  char *err_buf;
	  xasprintf (&err_buf, "Breakpoint #%d does not exist.", bpnum);
	  Tcl_SetStringObj (result_ptr->obj_ptr, err_buf, -1);
	  free(err_buf);
	  return TCL_ERROR;
	}
    }
d2393 3
a2395 1
  sal = find_pc_line (b->address, 0);
d2401 1
a2401 1
  Tcl_SetListObj (result_ptr->obj_ptr, 0, NULL);
d2404 1
a2404 5

  funcname = pc_function_name (b->address);
  new_obj = Tcl_NewStringObj (funcname, -1);
  Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr, new_obj);

d2406 4
a2409 1
			    Tcl_NewIntObj (b->line_number));
d2411 1
a2411 15
				 paddr_nz (b->address));
  Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr,
			    Tcl_NewStringObj (bptypes[b->type], -1));
  Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr,
			    Tcl_NewBooleanObj (b->enable == enabled));
  Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr,
			    Tcl_NewStringObj (bpdisp[b->disposition], -1));
  Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr,
			    Tcl_NewIntObj (b->ignore_count));

  new_obj = Tcl_NewObj ();
  for (cmd = b->commands; cmd; cmd = cmd->next)
    Tcl_ListObjAppendElement (NULL, new_obj,
			      Tcl_NewStringObj (cmd->line, -1));
  Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr, new_obj);
d2413 2
d2416 2
a2417 2
			    Tcl_NewStringObj (b->cond_string, -1));

d2419 2
a2420 4
			    Tcl_NewIntObj (b->thread));
  Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr,
			    Tcl_NewIntObj (b->hit_count));

d2424 2
a2425 9

/* This implements the tcl command gdb_get_breakpoint_list
 * It builds up a list of the current breakpoints.
 *
 * Tcl Arguments:
 *    None.
 * Tcl Result:
 *    A list of breakpoint numbers.
 */
d2428 1
a2428 1
gdb_get_breakpoint_list (clientData, interp, objc, objv)
d2434 1
a2434 3
  struct breakpoint *b;
  extern struct breakpoint *breakpoint_chain;
  Tcl_Obj *new_obj;
d2436 3
a2438 1
  if (objc != 1)
d2440 2
a2441 2
      Tcl_WrongNumArgs (interp, 1, objv, NULL);
      return TCL_ERROR;
d2443 2
a2444 7

  for (b = breakpoint_chain; b; b = b->next)
    if (b->type == bp_breakpoint)
      {
	new_obj = Tcl_NewIntObj (b->number);
	Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr, new_obj);
      }
a2447 2

/* The functions in this section deal with stacks and backtraces. */
d2449 4
a2452 2
/* This implements the tcl command gdb_stack.
 * It builds up a list of stack frames.
d2454 10
a2463 6
 * Tcl Arguments:
 *    start  - starting stack frame
 *    count - number of frames to inspect
 * Tcl Result:
 *    A list of function names
 */
d2466 1
a2466 1
gdb_stack (clientData, interp, objc, objv)
d2472 14
a2485 1
  int start, count;
d2487 1
a2487 1
  if (objc < 3)
a2488 1
      Tcl_WrongNumArgs (interp, 1, objv, "start count");
d2492 5
d2498 1
a2498 1
  if (Tcl_GetIntFromObj (NULL, objv[1], &start))
d2503 9
a2511 1
  if (Tcl_GetIntFromObj (NULL, objv[2], &count))
d2516 1
a2516 2

  if (target_has_stack)
d2518 3
a2520 39
      gdb_result r;
      struct frame_info *top;
      struct frame_info *fi;

      /* Find the outermost frame */
      r  = GDB_get_current_frame (&fi);
      if (r != GDB_OK)
	return TCL_OK;

      while (fi != NULL)
        {
          top = fi;
	  r = GDB_get_prev_frame (fi, &fi);
	  if (r != GDB_OK)
	    fi = NULL;
        }

      /* top now points to the top (outermost frame) of the
         stack, so point it to the requested start */
      start = -start;
      r = GDB_find_relative_frame (top, &start, &top);
      
      result_ptr->obj_ptr = Tcl_NewListObj (0, NULL);
      if (r != GDB_OK)
	return TCL_OK;

      /* If start != 0, then we have asked to start outputting
         frames beyond the innermost stack frame */
      if (start == 0)
        {
          fi = top; 
          while (fi && count--)
            {
              get_frame_name (interp, result_ptr->obj_ptr, fi);
              r = GDB_get_next_frame (fi, &fi);
	      if (r != GDB_OK)
		break;
            }
        }
d2523 2
a2524 2
  return TCL_OK;
}
d2526 1
a2526 13
/* A helper function for get_stack which adds information about
 * the stack frame FI to the caller's LIST.
 *
 * This is stolen from print_frame_info in stack.c.
 */
static void
get_frame_name (Tcl_Interp *interp, Tcl_Obj *list, struct frame_info *fi)
{
  struct symtab_and_line sal;
  struct symbol *func = NULL;
  register char *funname = 0;
  enum language funlang = language_unknown;
  Tcl_Obj *objv[1];
d2528 3
a2530 1
  if (frame_in_dummy (fi))
d2532 2
a2533 9
      objv[0] = Tcl_NewStringObj ("<function called from gdb>\n", -1);
      Tcl_ListObjAppendElement (interp, list, objv[0]);
      return;
    }
  if (fi->signal_handler_caller)
    {
      objv[0] = Tcl_NewStringObj ("<signal handler called>\n", -1);
      Tcl_ListObjAppendElement (interp, list, objv[0]);
      return;
d2536 2
a2537 5
  sal =
    find_pc_line (fi->pc,
		  fi->next != NULL
		  && !fi->next->signal_handler_caller
		  && !frame_in_dummy (fi->next));
d2539 2
a2540 2
  func = find_pc_function (fi->pc);
  if (func)
d2542 6
a2547 14
      struct minimal_symbol *msymbol = lookup_minimal_symbol_by_pc (fi->pc);
      if (msymbol != NULL
	  && (SYMBOL_VALUE_ADDRESS (msymbol)
	      > BLOCK_START (SYMBOL_BLOCK_VALUE (func))))
	{
	  func = 0;
	  funname = GDBTK_SYMBOL_SOURCE_NAME (msymbol);
	  funlang = SYMBOL_LANGUAGE (msymbol);
	}
      else
	{
	  funname = GDBTK_SYMBOL_SOURCE_NAME (func);
	  funlang = SYMBOL_LANGUAGE (func);
	}
d2549 3
d2553 3
d2557 19
a2575 6
      struct minimal_symbol *msymbol = lookup_minimal_symbol_by_pc (fi->pc);
      if (msymbol != NULL)
	{
	  funname = GDBTK_SYMBOL_SOURCE_NAME (msymbol);
	  funlang = SYMBOL_LANGUAGE (msymbol);
	}
d2578 8
a2585 1
  if (sal.symtab)
d2587 1
a2587 8
      objv[0] = Tcl_NewStringObj (funname, -1);
      Tcl_ListObjAppendElement (interp, list, objv[0]);
    }
  else
    {
#if 0
      /* we have no convenient way to deal with this yet... */
      if (fi->pc != sal.pc || !sal.symtab)
d2589 5
a2593 2
	  print_address_numeric (fi->pc, 1, gdb_stdout);
	  printf_filtered (" in ");
d2595 1
a2595 9
      printf_symbol_filtered (gdb_stdout, funname ? funname : "??", funlang,
			      DMGL_ANSI);
#endif
      objv[0] = Tcl_NewStringObj (funname != NULL ? funname : "??", -1);
#ifdef PC_LOAD_SEGMENT
      /* If we couldn't print out function name but if can figure out what
         load segment this pc value is from, at least print out some info
         about its load segment. */
      if (!funname)
d2597 3
a2599 9
	  Tcl_AppendStringsToObj (objv[0], " from ", PC_LOAD_SEGMENT (fi->pc),
				  (char *) NULL);
	}
#endif
#ifdef PC_SOLIB
      if (!funname)
	{
	  char *lib = PC_SOLIB (fi->pc);
	  if (lib)
d2601 7
a2607 1
	      Tcl_AppendStringsToObj (objv[0], " from ", lib, (char *) NULL);
a2609 4
#endif
      Tcl_ListObjAppendElement (interp, list, objv[0]);
    }
}
d2611 2
a2612 1
/* This implements the tcl command gdb_selected_frame
d2614 8
a2621 61
 * Returns the address of the selected frame
 * frame.
 *
 * Arguments:
 *    None
 * Tcl Result:
 *    The currently selected frame's address
 */

static int
gdb_selected_frame (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
{
  char *frame;

  if (selected_frame == NULL)
    xasprintf (&frame, "%s","");
  else
    xasprintf (&frame, "0x%s", paddr_nz (FRAME_FP (selected_frame)));

  Tcl_SetStringObj (result_ptr->obj_ptr, frame, -1);

  free(frame);
  return TCL_OK;
}

/* This implements the tcl command gdb_selected_block
 *
 * Returns the start and end addresses of the innermost
 * block in the selected frame.
 *
 * Arguments:
 *    None
 * Tcl Result:
 *    The currently selected block's start and end addresses
 */

static int
gdb_selected_block (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
{
  char *start = NULL;
  char *end   = NULL;

  if (selected_frame == NULL)
    {
      xasprintf (&start, "%s", "");
      xasprintf (&end, "%s", "");
    }
  else
    {
      struct block *block;
      block = get_frame_block (selected_frame);
      xasprintf (&start, "0x%s", paddr_nz (BLOCK_START (block)));
      xasprintf (&end, "0x%s", paddr_nz (BLOCK_END (block)));
d2624 1
a2624 5
  Tcl_SetListObj (result_ptr->obj_ptr, 0, NULL);
  Tcl_ListObjAppendElement (interp, result_ptr->obj_ptr,
			    Tcl_NewStringObj (start, -1));
  Tcl_ListObjAppendElement (interp, result_ptr->obj_ptr,
			    Tcl_NewStringObj (end, -1));
d2626 1
a2626 2
  free(start);
  free(end);
d2629 1
d2631 2
a2632 1
/* This implements the tcl command gdb_get_blocks
d2634 5
a2638 2
 * Returns the start and end addresses for all blocks in
 * the selected frame.
a2639 4
 * Arguments:
 *    None
 * Tcl Result:
 *    A list of all valid blocks in the selected_frame.
d2642 9
d2652 2
a2653 5
gdb_get_blocks (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
d2655 11
a2665 4
  struct block *block;
  int nsyms, i, junk;
  struct symbol *sym;
  CORE_ADDR pc;
d2667 2
a2668 3
  Tcl_SetListObj (result_ptr->obj_ptr, 0, NULL);
  
  if (selected_frame != NULL)
d2670 3
a2672 38
      block = get_frame_block (selected_frame);
      pc = get_frame_pc (selected_frame);
      while (block != 0)
	{
	  nsyms = BLOCK_NSYMS (block);
	  junk = 0;
	  for (i = 0; i < nsyms; i++)
	    {
	      sym = BLOCK_SYM (block, i);
	      switch (SYMBOL_CLASS (sym))
		{
		default:
		case LOC_UNDEF:		  /* catches errors        */
		case LOC_CONST:           /* constant              */
		case LOC_TYPEDEF:	  /* local typedef         */
		case LOC_LABEL:	          /* local label           */
		case LOC_BLOCK:	          /* local function        */
		case LOC_CONST_BYTES:	  /* loc. byte seq.        */
		case LOC_UNRESOLVED:      /* unresolved static     */
		case LOC_OPTIMIZED_OUT:   /* optimized out         */
		  junk = 1;
		  break;

		case LOC_ARG:		  /* argument              */
		case LOC_REF_ARG:	  /* reference arg         */
		case LOC_REGPARM:	  /* register arg          */
		case LOC_REGPARM_ADDR:    /* indirect register arg */
		case LOC_LOCAL_ARG:	  /* stack arg             */
		case LOC_BASEREG_ARG:	  /* basereg arg           */

		case LOC_LOCAL:	          /* stack local           */
		case LOC_BASEREG:	  /* basereg local         */
		case LOC_STATIC:	  /* static                */
		case LOC_REGISTER:        /* register              */
		  junk = 0;
		  break;
		}
	    }
d2674 5
a2678 7
	  /* If we found a block with locals in it, add it to the list. 
	     Note that the ranges of start and end address for blocks
	     are exclusive, so double-check against the PC */
	  
	  if (!junk && pc < BLOCK_END (block))
	    {
            char *addr;
d2680 9
a2688 11
	      Tcl_Obj *elt = Tcl_NewListObj (0, NULL);
            xasprintf (&addr, "0x%s", paddr_nz (BLOCK_START (block)));
	      Tcl_ListObjAppendElement (interp, elt,
					Tcl_NewStringObj (addr, -1));
            free(addr);
            xasprintf (&addr, "0x%s", paddr_nz (BLOCK_END (block)));
	      Tcl_ListObjAppendElement (interp, elt,
					Tcl_NewStringObj (addr, -1));
	      Tcl_ListObjAppendElement (interp, result_ptr->obj_ptr, elt);
            free(addr);
	    }
d2690 5
a2694 5
	  if (BLOCK_FUNCTION (block))
	    break;
	  else
	    block = BLOCK_SUPERBLOCK (block);
	}
d2697 7
a2703 2
  return TCL_OK;
}
d2705 6
a2710 9
/* This implements the tcl command gdb_block_vars.
 *
 * Returns all variables valid in the specified block.
 *
 * Arguments:
 *    The start and end addresses which identify the block.
 * Tcl Result:
 *    All variables defined in the given block.
 */
d2712 15
a2726 11
static int
gdb_block_vars (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
{
  struct block *block;
  int nsyms, i;
  struct symbol *sym;
  CORE_ADDR start, end;
d2728 3
a2730 1
  if (objc < 3)
d2732 2
a2733 2
      Tcl_WrongNumArgs (interp, 1, objv, "startAddr endAddr");
      result_ptr->flags |= GDBTK_IN_TCL_RESULT;
d2737 29
a2765 3
  Tcl_SetListObj (result_ptr->obj_ptr, 0, NULL);
  if (selected_frame == NULL)
    return TCL_OK;
d2767 7
a2773 2
  start = parse_and_eval_address (Tcl_GetStringFromObj (objv[1], NULL));
  end   = parse_and_eval_address (Tcl_GetStringFromObj (objv[2], NULL));
d2775 1
a2775 3
  block = get_frame_block (selected_frame);

  while (block != 0)
d2777 15
a2791 4
      if (BLOCK_START (block) == start && BLOCK_END (block) == end)
	{
	  nsyms = BLOCK_NSYMS (block);
	  for (i = 0; i < nsyms; i++)
d2793 22
a2814 17
	      sym = BLOCK_SYM (block, i);
	      switch (SYMBOL_CLASS (sym))
		{
		case LOC_ARG:		  /* argument              */
		case LOC_REF_ARG:	  /* reference arg         */
		case LOC_REGPARM:	  /* register arg          */
		case LOC_REGPARM_ADDR:    /* indirect register arg */
		case LOC_LOCAL_ARG:	  /* stack arg             */
		case LOC_BASEREG_ARG:	  /* basereg arg           */
		case LOC_LOCAL:	          /* stack local           */
		case LOC_BASEREG:	  /* basereg local         */
		case LOC_STATIC:	  /* static                */
		case LOC_REGISTER:        /* register              */
		  Tcl_ListObjAppendElement (interp, result_ptr->obj_ptr,
					    Tcl_NewStringObj (SYMBOL_NAME (sym),
							      -1));
		  break;
d2816 19
a2834 3
		default:
		  break;
		}
d2836 12
d2849 2
a2850 1
	  return TCL_OK;
a2851 4
      else if (BLOCK_FUNCTION (block))
	break;
      else
	block = BLOCK_SUPERBLOCK (block);
d2854 2
d2926 1
a2926 1
static struct symtab *
a3012 9

static void
setup_architecture_data ()
{
  /* don't trust REGISTER_BYTES to be zero. */
  old_regs = xmalloc (REGISTER_BYTES + 1);
  memset (old_regs, 0, REGISTER_BYTES + 1);
}

@


1.33
log
@	* generic/gdbtk-cmds.c (gdb_entry_point): Return an empty
	string when there is no active target (i.e., there is no
	entry point to return yet).
@
text
@d627 1
a627 1
  if (inferior_pid != 0 && target_has_execution)
d984 1
a984 1
  if (target_has_execution && inferior_pid != 0)
@


1.32
log
@	* generic/gdbtk-cmds.c (gdb_get_breakpoint_info): If unable
	to find the requested breakpoint for lookup, check if
	it is about to be deleted and return information about
	that breakpoint.
	(gdb_get_tracepoint_info): Ditto for tracepoints.
	* generic/gdbtk-hooks.c (gdbtk_deleted_bp): New global.
	(gdbtk_delete_breakpoint): Remember the deleted breakpoint
	for gdb_get_breakpoint_info, in case it is called during
	the event notification.
	(gdbtk_delete_tracepoints): Ditto for tracepoints.
@
text
@d3338 10
a3347 2
  addrstr = paddr_nz (entry_point_address ());
  Tcl_SetStringObj (result_ptr->obj_ptr, addrstr, -1);
@


1.31
log
@Breakpoint/tracepoint event notification using new event model...

	* generic/gdbtk-cmds.c (gdb_set_bp): Use create_breakpoint_hook
	to notify gui of changes.
	(gdb_set_bp_addr): Ditto.
	(gdb_get_breakpoint_info): Update comments to match reality.
	* generic/gdbtk-hooks.c (breakpoint_notify): Only pass the
	breakpoint number which generated the event.
	(tracepoint_notify): Ditto for tracepoints.
	* library/interface.tcl (gdb_breakpoint_change_hook): Mark
	as deprecated and comment out definition.
	(gdbtk_tcl_breakpoint): Use new GDBEvent event "breakpoint"
	to notify rest of UI about breakpoint event.
	(gdbtk_tcl_tracepoint): Ditto for "tracepoint" event.
	* library/bpwin.ith (update): Renamed to "breakpoint".
	(breakpoint): New public method.
	(tracepoint): New public method.
	(bp_add): Take event as argument instead of number.
	(bp_modify): Ditto.
	(bp_delete): Ditto.
	* library/bpwin.itb (constructor): Remove
	gdb_breakpoint_changed_hook.
	(destructor): Ditto.
	(build_win): Insert any existing breakpoints by
	making BreakpointEvents for them.
	(breakpoint): Renamed from "update" to handle
	breakpoint events.
	Remove code to deal with tracepoints.
	(tracepoint): New method to handle tracepoint
	events.
	(bp_add): Deal with breakpoint events, not breakpoint
	numbers.
	(bp_modify): Ditto.
	(bp_delete): Ditto.
	* library/srctextwin.ith: Inherit from GDBWin.
	(breakpoint): New public method.
	(tracepoint): New public method.
	* library/srctextwin.itb (constructor): Remove
	gdb_breakpoint_changed_hook.
	(destructor): Ditto.
	(breakpoint): New method to handle breakpoint event.
	(tracepoint): New method to handle tracepoint event.
	(do_bp): Handle duplicate breakpoints for asm, too.
	(remove_bp_at_line): Delete breakpoints by number, not
	linespec. clear_command removes breakpoints from the
	breakpoint_chain BEFORE deleting the breakpoint. delete_command
	does this afterward (so we can call gdb_get_breakpoint_info on
	an about-to-be-deleted breakpoint).
@
text
@d67 1
d2283 13
a2295 5
      char *buff;
      xasprintf (&buff, "Tracepoint #%d does not exist", tpnum);
      Tcl_SetStringObj (result_ptr->obj_ptr, buff, -1);
      free(buff);
      return TCL_ERROR;
d4078 14
a4091 5
      char *err_buf;
      xasprintf (&err_buf, "Breakpoint #%d does not exist.", bpnum);
      Tcl_SetStringObj (result_ptr->obj_ptr, err_buf, -1);
      free(err_buf);
      return TCL_ERROR;
@


1.30
log
@	* library/interface.tcl (run_executable): Use
	gdb_set_inferior_args.
	* library/session.tcl (session_load): Use gdb_set_inferior_args.
	* generic/gdbtk-cmds.c (Gdbtk_Init): Register
	gdb_set_inferior_args.
	(gdb_get_inferior_args): New function.
@
text
@d3769 1
a3769 3
 * It sets breakpoints, and runs the Tcl command
 *     gdbtk_tcl_breakpoint create
 * to register the new breakpoint with the GUI.
d3788 1
a3788 1
  int line, ret, thread = -1;
d3855 2
a3856 23

  Tcl_DStringInit (&cmd);

  Tcl_DStringAppend (&cmd, "gdbtk_tcl_breakpoint create ", -1);
  xasprintf (&buf, "%d", b->number);
  Tcl_DStringAppendElement (&cmd, buf);
  free(buf);
  xasprintf (&buf, "0x%lx", (long) sal.pc);
  Tcl_DStringAppendElement (&cmd, buf);
  Tcl_DStringAppendElement (&cmd, Tcl_GetStringFromObj (objv[2], NULL));
  Tcl_DStringAppendElement (&cmd, Tcl_GetStringFromObj (objv[1], NULL));
  Tcl_DStringAppendElement (&cmd, bpdisp[b->disposition]);
  free(buf);
  xasprintf (&buf, "%d", b->enable);
  Tcl_DStringAppendElement (&cmd, buf);
  free(buf);
  xasprintf (&buf, "%d", b->thread);
  Tcl_DStringAppendElement (&cmd, buf);
  free(buf);

  ret = Tcl_Eval (interp, Tcl_DStringValue (&cmd));
  Tcl_DStringFree (&cmd);
  return ret;
d3860 1
a3860 3
 * It sets breakpoints, and runs the Tcl command
 *     gdbtk_tcl_breakpoint create
 * to register the new breakpoint with the GUI.
d3876 1
a3876 1
  int ret, thread = -1;
d3934 2
a3935 30

  Tcl_DStringInit (&cmd);

  Tcl_DStringAppend (&cmd, "gdbtk_tcl_breakpoint create ", -1);
  free(buf);
  xasprintf (&buf, "%d", b->number);
  Tcl_DStringAppendElement (&cmd, buf);
  free(buf);
  xasprintf (&buf, "0x%lx", addr);
  Tcl_DStringAppendElement (&cmd, buf);
  free(buf);
  xasprintf (&buf, "%d", b->line_number);
  Tcl_DStringAppendElement (&cmd, buf);

  filename = symtab_to_filename (sal.symtab);
  if (filename == NULL)
    filename = "";
  Tcl_DStringAppendElement (&cmd, filename);
  Tcl_DStringAppendElement (&cmd, bpdisp[b->disposition]);
  free(buf);
  xasprintf (&buf, "%d", b->enable);
  Tcl_DStringAppendElement (&cmd, buf);
  free(buf);
  xasprintf (&buf, "%d", b->thread);
  Tcl_DStringAppendElement (&cmd, buf);

  ret = Tcl_Eval (interp, Tcl_DStringValue (&cmd));
  Tcl_DStringFree (&cmd);
  free(buf);
  return ret;
d4035 1
a4035 1
 *                thread, hit_count}
@


1.29
log
@	* library/session.tcl (session_save): Use gdb_get_inferior_args.
	* generic/gdbtk-cmds.c (inferior_args): Removed.
	(Gdbtk_Init): Don't register gdb_inferior_args variable.  Do
	register gdb_get_inferior_args function.
	(gdb_get_inferior_args): New function.
@
text
@d239 3
d427 2
d1014 37
@


1.28
log
@	* generic/gdbtk-cmds.c (gdb_entry_point): New TCL command.
	* library/interface.tcl (gdbtk_locate_main): Try the program's
	entry point if no main function is found.
@
text
@a66 3
/* FIXME: this must be `extern'.  But to do that we need a patch to
   infcmd.c.  */
static char *inferior_args = "";
d236 3
d422 2
a449 6
  /* Current inferior command-line arguments.  This is read-only for
     reasons similar to those for gdb_current_directory.  */
  Tcl_LinkVar (interp, "gdb_inferior_args",
	       (char *) &inferior_args,
	       TCL_LINK_STRING | TCL_LINK_READ_ONLY);

d982 27
@


1.27
log
@2001-04-04  Martin M. Hunt  <hunt@@redhat.com>

	* generic/gdbtk-hooks.c (gdbtk_fileopen): New function.
	Initialize ui_file stuff for gdbtk.
	(gdbtk_fputs): Don't print if gdbtk_disable_fputs. Send
	stdlog and stdtarg to their handler functions.

	* generic/gdbtk.c (Gdbtk_Init): Don't set gdb_stdlog
	and gdb_stdtarg to gdb_stdout,
	(gdbtk_init): Unset gdbtk_disable_fputs
	when ready to accept output from gdb. Remove references to
	fputs_unfiltered_hook.

	* generic/gdbtk.h: Declare new flag gdbtk_disable_fputs.

	* generic/gdbtk-cmds.c (gdb_restore_fputs): Instead of setting
	fputs_unfiltered_hook, set the new flag gdbtk_disable_fputs.

	* library/prefs.tcl (pref_set_defaults): Add defaults
	for log_fg and target_fg.

	* library/interface.tcl (gdbtk_tcl_fputs_error): Use
	err_tag.
	(gdbtk_tcl_fputs_log): New function. Write log messages
	to console.
	(gdbtk_tcl_fputs_target): New function.	Write target
	IO to console.

	* library/console.ith (einsert): Add tag parameter.

	* library/console.itb (_build_win): Add new tags for log
	and target IO.
	(einsert): Add tag parameter.
@
text
@d202 1
d340 2
d3249 17
@


1.26
log
@2001-04-02  Martin M. Hunt  <hunt@@redhat.com>

	* generic/gdbtk-cmds.c (gdb_loadfile): Adjust size of text_argv
	array to prevent writing out of range. Remove unused variables.
	Fix formatting.
	(gdb_get_tracepoint_info): Remove unused variable "fname".
	(gdb_load_disassembly): Remove unused variable "widget".
	(gdb_loc): Remove unused variable "sym".
	(gdb_set_bp_addr): Remove unused variable "line".
	(gdb_get_breakpoint_info): Remove unused variable "sym".
	(get_frame_name): Remove unused variable "name".
@
text
@a454 6
  /* Route GDB internal log messages and target output and through
     stderr instead of stdout.  FIXME: Should have a separate streams
     for handling these two types of output. */
  gdb_stdtarg = gdb_stderr;
  gdb_stdlog = gdb_stderr;

d1852 2
a1853 2
    fputs_unfiltered_hook = gdbtk_fputs;
    return TCL_OK;
@


1.25
log
@Eliminate ARCH_NUM_REGS.
@
text
@d2192 2
a2193 5
gdb_get_tracepoint_info (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
d2200 1
a2200 1
  char *filename, *funcname, *fname;
d2463 2
a2464 5
gdb_load_disassembly (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
a2468 1
  char *widget;
d3163 1
a3163 5
gdb_loc (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
a3166 1
  struct symbol *sym;
d3458 2
a3459 5
gdb_loadfile (clientData, interp, objc, objv)
  ClientData clientData;
  Tcl_Interp *interp;
  int objc;
  Tcl_Obj *CONST objv[];
d3470 1
a3470 2
  int prefix_len_1, prefix_len_2, cur_prefix_len, widget_len;
  char *text_argv[8];
a3590 2
	  char *p;

d3597 11
a3607 9
	  if (found_carriage_return) {
	    char *p;
	    
	    p = strrchr(line, '\0') - 2;
	    if (*p == '\r') {
	      *p = '\n';
	      *(p + 1) = '\0';
	    } else {
	      found_carriage_return = 0;
a3608 1
	  }
d3817 3
a3819 6
gdb_set_bp_addr (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];

d3822 1
a3822 1
  int line, ret, thread = -1;
d4013 2
a4014 5
gdb_get_breakpoint_info (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
d4022 1
a4022 1
  struct symbol *sym;
d4222 1
a4222 4
get_frame_name (interp, list, fi)
     Tcl_Interp *interp;
     Tcl_Obj *list;
     struct frame_info *fi;
a4278 2
      char *name = NULL;

@


1.24
log
@2001-03-10  Martin Hunt  <hunt@@redhat.com>

	* generic/gdbtk-cmds.c: Include linespec.h.
@
text
@d1801 1
a1801 1
  numregs = ARCH_NUM_REGS + NUM_PSEUDO_REGS;
@


1.23
log
@Create new file regcache.h.  Update all uses.
@
text
@d40 1
@


1.22
log
@	* generic/gdbtk-cmds.c (gdb_fetch_registers): Mark
	the result as generating a list only if it really does
	generate a list.
@
text
@d39 1
@


1.21
log
@2001-02-14  Fernando Nasser  <fnasser@@redhat.com>

	From 2001-02-09  Martin Hunt  <hunt@@redhat.com>
	* generic/gdbtk-cmds.c (gdb_load_disassembly): In mixed
	mode, source lines should be tagged with source_tag2.
@
text
@d1958 2
a1959 2

  result_ptr->flags |= GDBTK_MAKES_LIST;    /* Output the results as a list */
d1961 2
a1962 1
  result_ptr->flags &= ~GDBTK_MAKES_LIST;
@


1.20
log
@2001-02-06  Fernando Nasser  <fnasser@@redhat.com>

	Originally from Martin Hunt <hunt@@redhat.com>, with modifications
	* library/srcwin.itb (_name): Check for errors when invoking
	gdb_find_file.
	* library/srctextwin.itb (_mtime_changed, location): Ditto.
	* generic/gdbtk-cmds.c (gdb_find_file_command): Better error checking.
	(full_lookup_symtab): Fix misleading comment.
@
text
@d1 2
a2 2
/* Tcl/Tk command definitions for gdbtk.
   Copyright 1994, 1995, 1996, 1997, 1998, 1999
d2608 1
a2608 1
      client_data.source_argv[6] = "source_tag";
@


1.19
log
@2001-01-26  Fernando Nasser  <fnasser@@redhat.com>

        * generic/gdbtk-cmds.c (gdb_clear_file): Call exec_file_clear() and
        symbol_file_clear() instead of exec_file_command() and
        symbol_file_command().
        (gdb_find_file_command): Return the proper error text.
@
text
@d1322 2
a1323 2
 *    The full path to the file, or an empty string if the file is not
 *    found.
a1332 1
  char *filename = NULL;
d1334 1
d1342 2
a1343 3
  st = full_lookup_symtab (Tcl_GetStringFromObj (objv[1], NULL));
  if (st)
    filename = st->fullname;
d1345 2
a1346 1
  if (filename == NULL)
d1348 2
a1349 1
      Tcl_SetStringObj ( result_ptr->obj_ptr, "File not found in symtab (2)", -1);
d1352 9
a1360 2
  else
    Tcl_SetStringObj (result_ptr->obj_ptr, filename, -1);
d4659 2
a4660 2
/* the first one instead of the correct one.  This version */
/* also always makes sure symtab->fullname is set. */
@


1.18
log
@2001-01-24  Fernando Nasser  <fnasser@@redhat.com>

	From  Martin Hunt  <hunt@@cygnus.com>
	* generic/gdbtk-cmds.c (gdb_set_bp_addr, gdb_set_bp): Change
	strsave() to xstrdup().
@
text
@d638 2
a639 2
  exec_file_command (NULL, 0);
  symbol_file_command (NULL, 0);
d1347 4
a1350 1
    Tcl_SetStringObj (result_ptr->obj_ptr, "", 0);
@


1.17
log
@2001-01-24  Fernando Nasser  <fnasser@@redhat.com>

	From  Martin Hunt  <hunt@@cygnus.com>
	* generic/gdbtk-cmds.c (gdbtk_dis_asm_read_memory): Fix call
	to xfer_memory().
@
text
@d3777 1
a3777 1
  b->addr_string = strsave (buf);
d3883 1
a3883 1
  b->addr_string = strsave (buf);
@


1.16
log
@	* gdbtk-cmds.c (Gdbtk_Init): Create gdb_current_directory,
	gdb_inferior_args, and gdb_source_path variables.
@
text
@d3115 1
a3115 1
  res = xfer_memory (memaddr, myaddr, len, 0, &exec_ops);
@


1.15
log
@	* gdbtk-cmds.c (call_wrapper): Don't reset result if wrapped
	command returned error.
@
text
@d63 6
d426 22
@


1.14
log
@	* gdbtk-cmds.c (gdb_clear_file): Use Tcl_WrongNumArgs.
	(gdb_confirm_quit): Likewise.
	(gdb_force_quit): Likewise.
	(gdb_eval): Likewise.
	(gdb_immediate_command): Likewise.
	(gdb_get_vars_command): Likewise.
	(gdb_get_line_command): Likewise.
	(gdb_get_file_command): Likewise.
	(gdb_get_function_command): Likewise.
	(gdb_cmd): Likewise.  Also, don't allow more than 2 arguments.
	(gdb_listfiles): Corrected usage of Tcl_WrongNumArgs.
	(gdb_listfuncs): Use Tcl_WrongNumArgs.  Return error.
	(gdb_fetch_registers): Likewise.
	(gdb_tracepoint_exists_command): Use Tcl_WrongNumArgs.
	(gdb_get_tracepoint_info): Likewise.
	(gdb_get_trace_frame_num): Likewise.
	(gdb_actions_command): Likewise.
	(gdb_disassemble): Likewise.  Also, return error.
	(gdb_get_breakpoint_list): Likewise.
	(gdb_path_conv): Likewise.
	(gdb_load_disassembly): Use Tcl_WrongNumArgs.
	(gdb_loc): Likewise.
	(gdb_set_bp): Likewise.
	(gdb_set_bp_addr): Likewise.
	(gdb_get_breakpoint_info): Likewise.
@
text
@d462 1
d501 6
d512 5
a516 3
   * Now copy the result over to the true Tcl result.  If GDBTK_TO_RESULT flag
   * bit is set , this just copies a null object over to the Tcl result, 
   * which is fine because we should reset the result in this case anyway.
d518 1
a518 1
  if (result_ptr->flags & GDBTK_IN_TCL_RESULT)
@


1.13
log
@2000-10-23  Fernando Nasser  <fnasser@@redhat.com>

	From 2000-10-19  Steven Johnson  <sbjohnson@@ozemail.com.au>
        Note: The original patch used asprintf/vasprintf.  I changed it to
	use the new xasprintf/xvasprintf gdb functions.
        * gdbtk.c (TclDebug, gdbtk_init): Replaced the vast majority of
	sprintf/vsprintf calls with asprintf and vasprintf respectively.
	Should prevent any possible buffer overruns possible with
	fixed size sprintf buffers. Specifically fixes a problem with long
	filenames and clearing breakpoints overflowing their buffers when
	using sprintf, causing a segfault. Generically should also prevent
	any other similar problems from occuring.
        * gdbtk-cmds.c (sprintf_append_element_to_obj, get_pc_register,
	gdb_get_tracepoint_info, gdb_load_disassembly, gdbtk_load_source,
	gdbtk_load_asm, gdb_set_bp, gdb_set_bp_addr, gdb_get_breakpoint_info,
	gdb_selected_frame, gdb_selected_block, gdb_get_blocks): Ditto.
        * gdbtk-hooks.c (gdbtk_warning, gdbtk_ignorable_warning,
	gdbtk_readline_begin, gdbtk_set_hook, breakpoint_notify,
	gdbtk_query, tracepoint_notify, gdbtk_error_begin,
	gdbtk_annotate_signal): Ditto.
@
text
@d584 4
a587 2
    Tcl_SetStringObj (result_ptr->obj_ptr,
		      "Wrong number of args, none are allowed.", -1);
d627 1
a627 2
      Tcl_SetStringObj (result_ptr->obj_ptr,
			"Wrong number of args, should be none.", -1);
d654 1
a654 2
      Tcl_SetStringObj (result_ptr->obj_ptr,
			"Wrong number of args, should be none.", -1);
d750 1
a750 2
      Tcl_SetStringObj (result_ptr->obj_ptr,
		     "wrong # args, should be \"gdb_eval expression\"", -1);
d799 1
a799 1
  if (objc < 2)
d801 1
a801 1
      Tcl_SetStringObj (result_ptr->obj_ptr, "wrong # args", -1);
d869 1
a869 1
  if (objc < 2)
d871 1
a871 1
      Tcl_SetStringObj (result_ptr->obj_ptr, "wrong # args", -1);
d1076 2
a1077 4
      Tcl_AppendStringsToObj (result_ptr->obj_ptr,
			      "wrong # of args: should be \"",
			      Tcl_GetStringFromObj (objv[0], NULL),
			    " [function:line|function|line|*addr]\"", NULL);
d1182 1
a1182 4
      Tcl_AppendStringsToObj (result_ptr->obj_ptr,
			      "wrong # of args: should be \"",
			      Tcl_GetStringFromObj (objv[0], NULL),
			      " linespec\"", NULL);
d1221 1
a1221 4
      Tcl_AppendStringsToObj (result_ptr->obj_ptr,
			      "wrong # of args: should be \"",
			      Tcl_GetStringFromObj (objv[0], NULL),
			      " linespec\"", NULL);
d1260 1
a1260 4
      Tcl_AppendStringsToObj (result_ptr->obj_ptr,
			      "wrong # of args: should be \"",
			      Tcl_GetStringFromObj (objv[0], NULL),
			      " linespec\"", NULL);
d1355 1
a1355 1
      Tcl_WrongNumArgs (interp, 1, objv, "Usage: gdb_listfiles ?pathname?");
d1661 2
a1662 1
      Tcl_SetStringObj (result_ptr->obj_ptr, "wrong # args", -1);
d1902 2
a1903 2
      Tcl_SetStringObj (result_ptr->obj_ptr,
			"wrong # args, should be gdb_fetch_registers format ?register1 register2 ...?", -1);
d2129 2
a2130 4
      Tcl_AppendStringsToObj (result_ptr->obj_ptr,
			      "wrong # of args: should be \"",
			      Tcl_GetStringFromObj (objv[0], NULL),
			      " function:line|function|line|*addr\"", NULL);
d2156 1
a2156 1
      Tcl_SetStringObj (result_ptr->obj_ptr, "wrong # args", -1);
d2251 1
a2251 4
      Tcl_AppendStringsToObj (result_ptr->obj_ptr,
			      "wrong # of args: should be \"",
			      Tcl_GetStringFromObj (objv[0], NULL),
			      " linespec\"", NULL);
d2287 1
a2287 4
      Tcl_AppendStringsToObj (result_ptr->obj_ptr,
			      "wrong # args: should be: \"",
			      Tcl_GetStringFromObj (objv[0], NULL),
			      " number actions\"", NULL);
d2369 4
a2372 1
    error ("wrong # args");
d2428 5
a2432 4
  if (objc != 6 && objc != 7) {
    Tcl_SetStringObj (result_ptr->obj_ptr, "wrong # args, should be: widget [source|nosource] map_arr index_prefix low_address ?hi_address", -1);
    return TCL_ERROR;
  }
d3174 1
a3174 1
      Tcl_SetStringObj (result_ptr->obj_ptr, "wrong # args", -1);
d3685 1
a3685 2
      Tcl_SetStringObj (result_ptr->obj_ptr,
      "wrong number of args, should be \"filename line type [thread]\"", -1);
d3798 1
a3798 1
  if (objc != 4 && objc != 3)
d3800 1
a3800 2
      Tcl_SetStringObj (result_ptr->obj_ptr,
	   "wrong number of args, should be \"address type [thread]\"", -1);
d3999 1
a3999 2
      Tcl_SetStringObj (result_ptr->obj_ptr,
			"wrong number of args, should be \"breakpoint\"", -1);
d4088 4
a4091 1
    error ("wrong number of args, none are allowed");
d4570 4
a4573 1
    error ("wrong # args");
@


1.12
log
@2000-07-25  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * gdbtk-cmds.c (map_arg_registers): Set numregs to include the
        pseudo regs as well.
@
text
@d548 1
a548 1
  char buf[1024];
d552 1
a552 1
  vsprintf (buf, format, args);
d555 1
d2012 1
a2012 1
  char buff[64];
d2014 1
a2014 1
  sprintf (buff, "0x%llx", (long long) read_register (PC_REGNUM));
d2016 1
d2185 2
a2186 2
      char buff[64];
      sprintf (buff, "Tracepoint #%d does not exist", tpnum);
d2188 1
d2208 1
a2208 1
    asprintf (&tmp, "0x%s", paddr_nz (tp->address));
d2603 1
a2603 1
    char buffer[256];
d2606 1
a2606 1
    sprintf (buffer, "0x%s", paddr_nz (low));
d2608 1
d2610 1
a2610 1
    sprintf (buffer, "0x%s", paddr_nz (high));
d2612 1
d2628 1
a2628 1
  char buffer[18];
d2703 1
a2703 1
	      sprintf (buffer, "%d", client_data->widget_line_no);
d2708 1
d2810 1
a2810 1
      char buffer[16];
d2820 1
a2820 1
      sprintf (buffer, "%d", client_data->widget_line_no);
d2837 1
d3694 1
a3694 1
  char buf[64], *typestr;
d3754 1
a3754 1
  sprintf (buf, "%s:%d", basename (Tcl_GetStringFromObj (objv[1], NULL)),
d3757 1
d3764 1
a3764 1
  sprintf (buf, "%d", b->number);
d3766 2
a3767 1
  sprintf (buf, "0x%lx", (long) sal.pc);
d3772 2
a3773 1
  sprintf (buf, "%d", b->enable);
d3775 2
a3776 1
  sprintf (buf, "%d", b->thread);
d3778 1
a3778 1

d3810 1
a3810 1
  char *filename, *typestr, buf[64];
d3862 1
a3862 1
  sprintf (buf, "*(0x%lx)", addr);
d3870 2
a3871 1
  sprintf (buf, "%d", b->number);
d3873 2
a3874 1
  sprintf (buf, "0x%lx", addr);
d3876 2
a3877 1
  sprintf (buf, "%d", b->line_number);
d3885 2
a3886 1
  sprintf (buf, "%d", b->enable);
d3888 2
a3889 1
  sprintf (buf, "%d", b->thread);
d3894 1
d4033 2
a4034 2
      char err_buf[64];
      sprintf (err_buf, "Breakpoint #%d does not exist.", bpnum);
d4036 1
d4329 1
a4329 1
  char frame[32];
d4332 1
a4332 1
    strcpy (frame, "");
d4334 1
a4334 1
    sprintf (frame, "0x%s", paddr_nz (FRAME_FP (selected_frame)));
d4338 1
d4360 2
a4361 2
  char start[32];
  char end[32];
d4365 2
a4366 2
      strcpy (start, "");
      strcpy (end, "");
d4372 2
a4373 2
      sprintf (start, "0x%s", paddr_nz (BLOCK_START (block)));
      sprintf (end, "0x%s", paddr_nz (BLOCK_END (block)));
d4382 2
d4459 1
a4459 1
	      char addr[32];
d4462 1
a4462 1
	      sprintf (addr, "0x%s", paddr_nz (BLOCK_START (block)));
d4465 2
a4466 1
	      sprintf (addr, "0x%s", paddr_nz (BLOCK_END (block)));
d4470 1
@


1.11
log
@PARAMS elimination.
@
text
@d1761 1
a1761 1
  numregs = ARCH_NUM_REGS;
@


1.10
log
@PARAMS elimination.
@
text
@d1750 1
a1750 1
     void (*func) PARAMS ((int regnum, void *argp));
@


1.9
log
@2000-06-08  Fernando Nasser  <fnasser@@cygnus.com>

        * gdbtk-cmds.c (get_register):  Allow editing of typed registers if
        the type is a union with the first tag equal to the register name.
@
text
@d63 1
a63 1
static void setup_architecture_data PARAMS ((void));
d169 1
a169 1
extern int gdb_variable_init PARAMS ((Tcl_Interp * interp));
d176 1
a176 1
int call_wrapper PARAMS ((ClientData, Tcl_Interp *, int, Tcl_Obj * CONST[]));
d182 119
a300 133
static int compare_lines PARAMS ((const PTR, const PTR));
static int comp_files PARAMS ((const void *, const void *));
static int gdb_actions_command PARAMS ((ClientData, Tcl_Interp *, int,
					Tcl_Obj * CONST objv[]));
static int gdb_changed_register_list PARAMS ((ClientData, Tcl_Interp *, int,
					      Tcl_Obj * CONST[]));
static int gdb_clear_file PARAMS ((ClientData, Tcl_Interp * interp, int,
				   Tcl_Obj * CONST[]));
static int gdb_cmd PARAMS ((ClientData, Tcl_Interp *, int,
			    Tcl_Obj * CONST[]));
static int gdb_confirm_quit PARAMS ((ClientData, Tcl_Interp *, int,
				     Tcl_Obj * CONST[]));
static int gdb_disassemble PARAMS ((ClientData, Tcl_Interp *, int,
				    Tcl_Obj * CONST[]));
static int gdb_eval PARAMS ((ClientData, Tcl_Interp *, int,
			     Tcl_Obj * CONST[]));
static int gdb_fetch_registers PARAMS ((ClientData, Tcl_Interp *, int,
					Tcl_Obj * CONST[]));
static int gdb_find_file_command PARAMS ((ClientData, Tcl_Interp *, int,
					  Tcl_Obj * CONST objv[]));
static int gdb_force_quit PARAMS ((ClientData, Tcl_Interp *, int,
				   Tcl_Obj * CONST[]));
static struct symtab *full_lookup_symtab PARAMS ((char *file));
static int gdb_get_args_command PARAMS ((ClientData, Tcl_Interp *, int,
					 Tcl_Obj * CONST objv[]));
static int gdb_get_breakpoint_info PARAMS ((ClientData, Tcl_Interp *, int,
					    Tcl_Obj * CONST[]));
static int gdb_get_breakpoint_list PARAMS ((ClientData, Tcl_Interp *, int,
					    Tcl_Obj * CONST[]));
static int gdb_get_file_command PARAMS ((ClientData, Tcl_Interp *, int,
					 Tcl_Obj * CONST objv[]));
static int gdb_get_function_command PARAMS ((ClientData, Tcl_Interp *, int,
					     Tcl_Obj * CONST objv[]));
static int gdb_get_line_command PARAMS ((ClientData, Tcl_Interp *, int,
					 Tcl_Obj * CONST objv[]));
static int gdb_get_locals_command PARAMS ((ClientData, Tcl_Interp *, int,
					   Tcl_Obj * CONST objv[]));
static int gdb_get_mem PARAMS ((ClientData, Tcl_Interp *, int,
				Tcl_Obj * CONST[]));
static int gdb_get_trace_frame_num PARAMS ((ClientData, Tcl_Interp *, int,
					    Tcl_Obj * CONST objv[]));
static int gdb_get_tracepoint_list PARAMS ((ClientData, Tcl_Interp *, int,
					    Tcl_Obj * CONST objv[]));
static int gdb_get_vars_command PARAMS ((ClientData, Tcl_Interp *, int,
					 Tcl_Obj * CONST objv[]));
static int gdb_immediate_command PARAMS ((ClientData, Tcl_Interp *, int,
					  Tcl_Obj * CONST[]));
static int gdb_listfiles PARAMS ((ClientData, Tcl_Interp *, int,
				  Tcl_Obj * CONST[]));
static int gdb_listfuncs PARAMS ((ClientData, Tcl_Interp *, int,
				  Tcl_Obj * CONST[]));
static int gdb_loadfile PARAMS ((ClientData, Tcl_Interp *, int,
				 Tcl_Obj * CONST objv[]));
static int gdb_load_disassembly PARAMS ((ClientData clientData, Tcl_Interp
					 *interp,
					 int objc, Tcl_Obj *CONST objv[]));
static int gdb_load_info PARAMS ((ClientData, Tcl_Interp *, int,
				  Tcl_Obj * CONST objv[]));
static int gdb_loc PARAMS ((ClientData, Tcl_Interp *, int,
			    Tcl_Obj * CONST[]));
static int gdb_path_conv PARAMS ((ClientData, Tcl_Interp *, int,
				  Tcl_Obj * CONST[]));
static int gdb_prompt_command PARAMS ((ClientData, Tcl_Interp *, int,
				       Tcl_Obj * CONST objv[]));
static int gdb_regnames PARAMS ((ClientData, Tcl_Interp *, int,
				 Tcl_Obj * CONST[]));
static int gdb_restore_fputs PARAMS ((ClientData, Tcl_Interp *, int,
				 Tcl_Obj * CONST[]));
static int gdb_search PARAMS ((ClientData, Tcl_Interp *, int,
			       Tcl_Obj * CONST objv[]));
static int gdb_set_bp PARAMS ((ClientData, Tcl_Interp *, int,
			       Tcl_Obj * CONST objv[]));
static int gdb_set_bp_addr PARAMS ((ClientData, Tcl_Interp *, int,
				    Tcl_Obj * CONST objv[]));
static int gdb_find_bp_at_line PARAMS ((ClientData, Tcl_Interp *, int,
					Tcl_Obj * CONST objv[]));
static int gdb_find_bp_at_addr PARAMS ((ClientData, Tcl_Interp *, int,
					Tcl_Obj * CONST objv[]));
static int gdb_stop PARAMS ((ClientData, Tcl_Interp *, int,
			     Tcl_Obj * CONST[]));
static int gdb_target_has_execution_command PARAMS ((ClientData,
						     Tcl_Interp *, int,
						     Tcl_Obj * CONST[]));
static int gdb_trace_status PARAMS ((ClientData, Tcl_Interp *, int,
				     Tcl_Obj * CONST[]));
static int gdb_tracepoint_exists_command PARAMS ((ClientData, Tcl_Interp *,
						  int,
						  Tcl_Obj * CONST objv[]));
static int gdb_get_tracepoint_info PARAMS ((ClientData, Tcl_Interp *, int,
					    Tcl_Obj * CONST objv[]));
static int gdbtk_dis_asm_read_memory PARAMS ((bfd_vma, bfd_byte *, unsigned int,
					      disassemble_info *));
static void gdbtk_load_source PARAMS ((ClientData clientData,
				       struct symtab *symtab,
					int start_line, int end_line));
static CORE_ADDR gdbtk_load_asm PARAMS ((ClientData clientData, CORE_ADDR pc,
			 struct disassemble_info *di));
static void gdbtk_print_source PARAMS ((ClientData clientData,
					struct symtab *symtab,
					int start_line, int end_line));
static CORE_ADDR gdbtk_print_asm PARAMS ((ClientData clientData, CORE_ADDR pc,
			 struct disassemble_info *di));
static int gdb_disassemble_driver PARAMS ((CORE_ADDR low, CORE_ADDR high,
				int mixed_source_and_assembly,
				ClientData clientData,
				void (*print_source_fn) (ClientData, struct
							 symtab *, int, int),
				CORE_ADDR (*print_asm_fn) (ClientData,
							   CORE_ADDR,
							   struct disassemble_info *)));
static int get_pc_register PARAMS ((ClientData, Tcl_Interp *, int,
				    Tcl_Obj *CONST []));
static int gdb_stack PARAMS ((ClientData, Tcl_Interp *, int,
			      Tcl_Obj *CONST []));
static int gdb_selected_frame PARAMS ((ClientData clientData,
				       Tcl_Interp *interp, int argc,
				       Tcl_Obj *CONST objv[]));
static int gdb_selected_block PARAMS ((ClientData clientData,
				       Tcl_Interp *interp, int argc,
				       Tcl_Obj *CONST objv[]));
static int gdb_get_blocks PARAMS ((ClientData clientData,
				   Tcl_Interp *interp, int objc,
				   Tcl_Obj *CONST objv[]));
static int gdb_block_vars PARAMS ((ClientData clientData,
				   Tcl_Interp *interp, int objc,
				   Tcl_Obj *CONST objv[]));
char * get_prompt PARAMS ((void));
static void get_register PARAMS ((int, void *));
static void get_register_name PARAMS ((int, void *));
static int map_arg_registers PARAMS ((int, Tcl_Obj * CONST[],
				      void (*)(int, void *), void *));
static int perror_with_name_wrapper PARAMS ((PTR args));
static void register_changed_p PARAMS ((int, void *));
d302 3
a304 3
static void get_frame_name PARAMS ((Tcl_Interp * interp, Tcl_Obj * list,
				    struct frame_info * fi));
char *pc_function_name PARAMS ((CORE_ADDR pc));
@


1.8
log
@Purge all uses of make_cleanup_func in GDBtk.
@
text
@d1947 1
d1971 1
d1974 2
a1975 2
      REGISTER_CONVERT_TO_VIRTUAL (regnum, REGISTER_VIRTUAL_TYPE (regnum),
				   raw_buffer, virtual_buffer);
d1997 9
a2005 2
    val_print (REGISTER_VIRTUAL_TYPE (regnum), virtual_buffer, 0, 0,
	       gdb_stdout, format, 1, 0, Val_pretty_default);
@


1.7
log
@        * ChangeLog-gdbtk: Renamed to ChangeLog
        * ChangeLog: New file
        * gdbtk-cmds.c, gdbtk-hooks.c, gdbtk-variable.c, gdbtk-varobj.c,
        gdbtk-wrapper.h, gdbtk-wrapper.c, gdbtk.h, gdbtk.c: No need for
        changelog-default-name hint for Emacs now
@
text
@d770 1
a770 1
  old_chain = make_cleanup ((make_cleanup_func) free_current_contents, &expr);
d997 1
a997 1
  old_cleanups = make_cleanup ((make_cleanup_func) bfd_close, loadfile_bfd);
d1608 1
a1608 1
    old_chain = make_cleanup ((make_cleanup_func) free_search_symbols, ss);
@


1.6
log
@* gdbtk-hooks.c (gdbtk_restore_result_ptr): New function.
* gdbtk.h (gdbtk_restore_result_ptr): Declare it.
* gdbtk-cmds.c (gdbtk_load_asm): Use it to restore the old value
of result_ptr, in case we get errors while disassembling things.
@
text
@a4702 1

a4703 3
/* Local variables: */
/* change-log-default-name: "ChangeLog-gdbtk" */
/* End: */
@


1.5
log
@Handle the fact that there are holes in the register numbering.
* gdbtk-cmds.c (gdb_regnames): If given the -numbers option,
return the register numbers along with their names.
(get_register_name): Record both the register name and number, if
requested.
@
text
@d2754 1
d2765 2
a2766 1
  gdbtk_result new_result, *old_result_ptr;
d2776 1
a2776 1
  old_result_ptr = result_ptr;
d2838 1
a2838 1
  result_ptr = old_result_ptr;
@


1.4
log
@2000-02-29  James Ingham  <jingham@@leda.cygnus.com>

      * gdbtk-cmds.c (gdb_disassemble_driver): The to_shortname for
      Linux is "linuxthreads", not "linux-threads", so we have to change
      the heuristic to account for this.  This fixes a crash when trying
      to disassemble from shared libraries.
@
text
@d1836 17
a1852 2
/* This implements the TCL command `gdb_regnames', which returns a list of
   all of the register names. */
d1861 2
d1866 10
a1875 1
  return map_arg_registers (objc, objv, get_register_name, NULL);
d1881 1
a1881 1
     void *argp;		/* Ignored */
d1883 19
a1901 2
  Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr,
			    Tcl_NewStringObj (REGISTER_NAME (regnum), -1));
@


1.3
log
@        * gdbtk-wrapper.h: Add declarations for GDB_get_prev_frame, GDB_get_next_frame,
        GDB_find_relative_frame, GDB_get_current_frame.
        * gdbtk-wrapper.c (GDB_get_prev_frame, wrap_get_prev_frame): New functions.
        (GDB_get_next_frame, wrap_get_next_frame): New functions.
        (GDB_find_relative_frame, wrap_find_relative_frame): New functions.
        (GDB_get_current_frame, wrap_get_current_frame): New functions.

        * gdbtk-hooks.c (gdbtk_add_hooks): Use "specify_exec_file_hook" so
        that our hook is added to the list of hooks run instead of overwriting
        all other hooks.

        * gdbtk-cmds.c (gdb_stack): Wrap all calls to internal functions and
        deal with errors more gracefully.
@
text
@d2870 5
d2882 1
a2882 1
	  || strstr (target_shortname, "-threads") != NULL)
@


1.2
log
@Re-sync with ../include/dis-asm.h - LEN param changed to unsigned int.
@
text
@d49 1
a4093 2
  Tcl_SetListObj (result_ptr->obj_ptr, 0, NULL);

d4096 1
d4101 4
a4104 1
      fi = get_current_frame ();
d4106 6
a4111 4
	{
	  top = fi;
	  fi = get_prev_frame (fi);
	}
d4116 5
a4120 1
      top = find_relative_frame (top, &start);
d4125 10
a4134 8
	{
	  fi = top;
	  while (fi && count--)
	    {
	      get_frame_name (interp, result_ptr->obj_ptr, fi);
	      fi = get_next_frame (fi);
	    }
	}
@


1.1
log
@Initial revision
@
text
@d271 1
a271 1
static int gdbtk_dis_asm_read_memory PARAMS ((bfd_vma, bfd_byte *, int,
d3033 1
a3033 1
     int len;
@


1.1.1.1
log
@import insight-2000-02-04 snapshot (2nd try)
@
text
@@
