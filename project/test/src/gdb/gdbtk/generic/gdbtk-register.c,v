head	1.50;
access;
symbols
	insight_7_6-2013-04-10-branchpoint:1.44
	gdb_7_6-branch:1.44.0.2
	gdb_7_5-branch:1.43.0.2
	gdb_7_4-branch:1.41.0.4
	gdb_7_3-branch:1.41.0.2
	gdb_7_1-branch:1.38.0.4
	gdb_7_0-branch:1.38.0.2
	arc-sim-20090309:1.34
	arc-insight_6_8-branch:1.34.0.6
	arc-insight_6_8-branchpoint:1.34
	insight_6_8-branch:1.34.0.4
	insight_6_8-branchpoint:1.34
	gdb_6_8-branch:1.34.0.2
	insight_6_6-20070208-release:1.29
	gdb_6_6-branch:1.29.0.4
	gdb_6_6-2006-11-15-branchpoint:1.29
	insight_6_5-20061003-release:1.29
	gdb_6_5-branch:1.29.0.2
	gdb_6_5-2006-05-14-branchpoint:1.29
	gdb-csl-gxxpro-6_3-branch:1.28.0.4
	gdb-csl-gxxpro-6_3-branchpoint:1.28
	gdb_6_4-branch:1.28.0.2
	gdb_6_4-2005-11-01-branchpoint:1.28
	gdb_6_1-2004-04-05-release:1.23
	gdb_6_1-branch:1.23.0.2
	gdb_6_1-2004-03-01-gmt-branchpoint:1.23
	gdb_6_0-2003-10-04-release:1.19
	gdb_6_0-branch:1.19.0.2
	gdb_6_0-2003-06-23-branchpoint:1.19
	gdb_5_3-2002-12-12-release:1.11
	gdb_5_3-branch:1.11.0.2
	gdb_5_3-2002-09-04-branchpoint:1.11
	gdb_5_2_1-2002-07-23-release:1.7
	gdb_5_2-2002-04-29-release:1.7
	gdb_5_2-branch:1.7.0.2
	gdb_5_2-2002-03-03-branchpoint:1.7
	gdb_5_1_1-2002-01-24-release:1.2.2.1
	cygnus_cvs_20020108_pre:1.5
	gdb_5_1_0_1-2002-01-03-branch:1.2.2.1.0.2
	gdb_5_1_0_1-2002-01-03-branchpoint:1.2.2.1
	gdb_5_1-2001-11-21-release:1.2.2.1
	gdb_s390-2001-09-26-branch:1.2.0.4
	gdb_s390-2001-09-26-branchpoint:1.2
	gdb_5_1-2001-07-29-branch:1.2.0.2
	gdb_5_1-2001-07-29-branchpoint:1.2
	dberlin-typesystem-branch:1.1.0.2
	dberlin-typesystem-branchpoint:1.1;
locks; strict;
comment	@ * @;


1.50
date	2013.09.20.11.49.16;	author aburgess;	state Exp;
branches;
next	1.49;

1.49
date	2013.09.06.09.23.00;	author aburgess;	state Exp;
branches;
next	1.48;

1.48
date	2013.09.05.13.14.28;	author aburgess;	state Exp;
branches;
next	1.47;

1.47
date	2013.07.15.07.42.21;	author rosch;	state Exp;
branches;
next	1.46;

1.46
date	2013.07.02.17.07.29;	author kseitz;	state Exp;
branches;
next	1.45;

1.45
date	2013.06.05.20.26.58;	author kseitz;	state Exp;
branches;
next	1.44;

1.44
date	2012.11.21.16.39.33;	author muller;	state Exp;
branches;
next	1.43;

1.43
date	2012.04.13.15.23.46;	author muller;	state Exp;
branches;
next	1.42;

1.42
date	2012.03.30.07.36.10;	author rosch;	state Exp;
branches;
next	1.41;

1.41
date	2011.04.12.05.11.08;	author kseitz;	state Exp;
branches;
next	1.40;

1.40
date	2011.04.08.23.32.42;	author kseitz;	state Exp;
branches;
next	1.39;

1.39
date	2010.06.18.22.25.26;	author muller;	state Exp;
branches;
next	1.38;

1.38
date	2009.07.07.12.38.56;	author muller;	state Exp;
branches;
next	1.37;

1.37
date	2009.03.25.23.43.07;	author muller;	state Exp;
branches;
next	1.36;

1.36
date	2008.12.15.18.06.12;	author kevinb;	state Exp;
branches;
next	1.35;

1.35
date	2008.05.12.07.24.54;	author muller;	state Exp;
branches;
next	1.34;

1.34
date	2008.03.07.08.03.19;	author kseitz;	state Exp;
branches;
next	1.33;

1.33
date	2007.06.28.03.54.31;	author kseitz;	state Exp;
branches;
next	1.32;

1.32
date	2007.06.09.17.15.01;	author kseitz;	state Exp;
branches;
next	1.31;

1.31
date	2007.06.05.00.36.29;	author kseitz;	state Exp;
branches;
next	1.30;

1.30
date	2007.03.13.16.29.14;	author kevinb;	state Exp;
branches;
next	1.29;

1.29
date	2005.12.23.18.23.16;	author eliz;	state Exp;
branches;
next	1.28;

1.28
date	2005.05.27.01.30.53;	author kseitz;	state Exp;
branches;
next	1.27;

1.27
date	2004.10.31.10.05.09;	author dsl;	state Exp;
branches;
next	1.26;

1.26
date	2004.08.09.23.28.18;	author bje;	state Exp;
branches;
next	1.25;

1.25
date	2004.06.11.18.49.38;	author hunt;	state Exp;
branches;
next	1.24;

1.24
date	2004.03.30.06.05.27;	author hunt;	state Exp;
branches;
next	1.23;

1.23
date	2004.02.17.18.43.56;	author hunt;	state Exp;
branches;
next	1.22;

1.22
date	2003.10.06.16.31.04;	author carlton;	state Exp;
branches;
next	1.21;

1.21
date	2003.09.30.23.10.55;	author carlton;	state Exp;
branches;
next	1.20;

1.20
date	2003.08.05.14.58.29;	author cagney;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.11.21.52.22;	author carlton;	state Exp;
branches;
next	1.18;

1.18
date	2003.05.08.23.30.51;	author cagney;	state Exp;
branches;
next	1.17;

1.17
date	2003.03.25.01.03.42;	author hunt;	state Exp;
branches;
next	1.16;

1.16
date	2003.03.17.22.14.00;	author kseitz;	state Exp;
branches;
next	1.15;

1.15
date	2003.02.12.00.39.46;	author kseitz;	state Exp;
branches;
next	1.14;

1.14
date	2003.02.11.16.08.38;	author cagney;	state Exp;
branches;
next	1.13;

1.13
date	2002.12.17.20.29.11;	author hunt;	state Exp;
branches;
next	1.12;

1.12
date	2002.11.30.17.49.21;	author cagney;	state Exp;
branches;
next	1.11;

1.11
date	2002.08.03.16.22.07;	author cagney;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.16.01.09.36;	author hunt;	state Exp;
branches;
next	1.9;

1.9
date	2002.05.05.18.50.08;	author aoliva;	state Exp;
branches;
next	1.8;

1.8
date	2002.04.12.18.18.58;	author cagney;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.01.19.03.17;	author kseitz;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.07.05.05.06;	author hunt;	state Exp;
branches;
next	1.5;

1.5
date	2002.01.05.04.30.45;	author cagney;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.13.18.53.36;	author kseitz;	state Exp;
branches;
next	1.3;

1.3
date	2001.07.31.17.34.56;	author ezannoni;	state Exp;
branches;
next	1.2;

1.2
date	2001.07.20.22.19.50;	author hunt;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2001.05.10.18.04.23;	author kseitz;	state Exp;
branches;
next	;

1.2.2.1
date	2001.10.21.01.09.46;	author cagney;	state Exp;
branches;
next	;


desc
@@


1.50
log
@Remove use of deprecated_frame_register_read.

  https://sourceware.org/ml/insight/2013-q3/msg00043.html

gdb/gdbtk/ChangeLog

        * generic/gdbtk-register.c (register_changed_p): Replace use of
        deprecated_frame_register_read with get_frame_register_value.
@
text
@/* Tcl/Tk command definitions for Insight - Registers
   Copyright (C) 2001-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */

#include "defs.h"
#include "frame.h"
#include "regcache.h"
#include "reggroups.h"
#include "value.h"
#include "target.h"
#include "gdb_string.h"
#include "language.h"
#include "valprint.h"
#include "arch-utils.h"

#include <tcl.h>
#include "gdbtk.h"
#include "gdbtk-cmds.h"

/* Argument passed to our register-mapping functions */
typedef union
{
  int integer;
  void *ptr;
} map_arg;

/* Type of our mapping functions */
typedef void (*map_func)(int, map_arg);

static int gdb_register_info (ClientData, Tcl_Interp *, int, Tcl_Obj **);
static void get_register (int, map_arg);
static void get_register_name (int, map_arg);
static void get_register_size (int, map_arg);
static int map_arg_registers (Tcl_Interp *, int, Tcl_Obj **,
			      map_func, map_arg);
static void register_changed_p (int, map_arg);
static void setup_architecture_data (void);
static int gdb_regformat (ClientData, Tcl_Interp *, int, Tcl_Obj **);
static int gdb_reggroup (ClientData, Tcl_Interp *, int, Tcl_Obj **);
static int gdb_reggrouplist (ClientData, Tcl_Interp *, int, Tcl_Obj **);

static void get_register_types (int regnum, map_arg);

/* This contains the previous values of the registers, since the last call to
   gdb_changed_register_list.

   It is an array of (NUM_REGS+NUM_PSEUDO_REGS)*MAX_REGISTER_RAW_SIZE bytes. */

static char *old_regs = NULL;
static int old_regs_count = 0;
static int *regformat = (int *)NULL;
static struct type **regtype = (struct type **)NULL;

int
Gdbtk_Register_Init (Tcl_Interp *interp)
{
  Tcl_CreateObjCommand (interp, "gdb_reginfo", gdbtk_call_wrapper,
                        gdb_register_info, NULL);
  Tcl_CreateObjCommand (interp, "gdb_reg_arch_changed", gdbtk_call_wrapper,
			setup_architecture_data, NULL);

  /* Register/initialize any architecture specific data */
  setup_architecture_data ();

  return TCL_OK;
}

/* This implements the tcl command "gdb_reginfo".
 * It returns the requested information about registers.
 *
 * Tcl Arguments:
 *    OPTION    - "changed", "name", "size", "value" (see below)
 *    REGNUM(S) - the register(s) for which info is requested
 *
 * Tcl Result:
 *    The requested information
 *
 * Options:
 * changed
 *    Returns a list of registers whose values have changed since the
 *    last time the proc was called.
 *
 *    usage: gdb_reginfo changed [regnum0, ..., regnumN]
 *
 * name
 *    Return a list containing the names of the registers whose numbers
 *    are given by REGNUM ... .  If no register numbers are given, return
 *    all the registers' names.
 *
 *    usage: gdb_reginfo name [-numbers] [regnum0, ..., regnumN]
 *
 *    Note that some processors have gaps in the register numberings:
 *    even if there is no register numbered N, there may still be a
 *    register numbered N+1.  So if you call gdb_regnames with no
 *    arguments, you can't assume that the N'th element of the result is
 *    register number N.
 *
 *    Given the -numbers option, gdb_regnames returns, not a list of names,
 *    but a list of pairs {NAME NUMBER}, where NAME is the register name,
 *    and NUMBER is its number.
 *
 * size
 *    Returns the raw size of the register(s) in bytes.
 *
 *    usage: gdb_reginfo size [regnum0, ..., regnumN]
 *
 * value
 *    Returns a list of register values.
 *
 *    usage: gdb_reginfo value [regnum0, ..., regnumN]
 */
static int
gdb_register_info (ClientData clientData, Tcl_Interp *interp, int objc,
                   Tcl_Obj **objv)
{
  int index;
  map_arg arg;
  map_func func;
  static const char *commands[] = {"changed", "name", "size", "value", "type", 
			     "format", "group", "grouplist", NULL};
  enum commands_enum { REGINFO_CHANGED, REGINFO_NAME, REGINFO_SIZE, REGINFO_VALUE, 
		       REGINFO_TYPE, REGINFO_FORMAT, REGINFO_GROUP, REGINFO_GROUPLIST };

  if (objc < 2)
    {
      Tcl_WrongNumArgs (interp, 1, objv, "name|size|value|type|format|groups [regnum1 ... regnumN]");
      return TCL_ERROR;
    }

  if (Tcl_GetIndexFromObj (interp, objv[1], commands, "options", 0,
  			   &index) != TCL_OK)
    {
      result_ptr->flags |= GDBTK_IN_TCL_RESULT;
      return TCL_ERROR;
    }
  
  /* Skip the option */
  objc -= 2;
  objv += 2;

  switch ((enum commands_enum) index)
    {
    case REGINFO_CHANGED:
      func = register_changed_p;
      arg.ptr = NULL;
      break;

    case REGINFO_NAME:
      {
	int len;
	char *s = Tcl_GetStringFromObj (objv[0], &len);
	if (objc != 0 && strncmp (s, "-numbers", len) == 0)
	  {
	    arg.integer = 1;
	    objc--;
	    objv++;
	  }
	else
	  arg.ptr = NULL;

	func = get_register_name;
      }
      break;

    case REGINFO_SIZE:
      func = get_register_size;
      arg.ptr = NULL;
      break;

    case REGINFO_VALUE:
      func = get_register;
      arg.ptr = NULL;
      break;

    case REGINFO_TYPE:
      func = get_register_types;
      arg.ptr = NULL;
      break;

    case REGINFO_FORMAT:
      return gdb_regformat (clientData, interp, objc, objv);

    case REGINFO_GROUP:
      return gdb_reggroup (clientData, interp, objc, objv);

    case REGINFO_GROUPLIST:
      return gdb_reggrouplist (clientData, interp, objc, objv);

    default:
      return TCL_ERROR;
    }

  return map_arg_registers (interp, objc, objv, func, arg);
}

static void
get_register_size (int regnum, map_arg arg)
{
  Tcl_ListObjAppendElement (gdbtk_interp, result_ptr->obj_ptr,
			    Tcl_NewIntObj (register_size (get_current_arch (),
							  regnum)));
}

/* returns a list of valid types for a register */
/* Normally this will be only one type, except for SIMD and other */
/* special registers. */

static void
get_register_types (int regnum, map_arg arg)
{ 
  struct type *reg_vtype;
  int i,n;

  reg_vtype = register_type (get_current_arch (), regnum);
  
  if (TYPE_CODE (reg_vtype) == TYPE_CODE_UNION)
    {
      n = TYPE_NFIELDS (reg_vtype);
      /* limit to 16 types */
      if (n > 16) 
	n = 16;
      
      for (i = 0; i < n; i++)
	{
	  Tcl_Obj *ar[3], *list;
	  char *buff;
	  buff = xstrprintf ("%s", host_address_to_string (
				     TYPE_FIELD_TYPE (reg_vtype, i)));
	  ar[0] = Tcl_NewStringObj (TYPE_FIELD_NAME (reg_vtype, i), -1);
	  ar[1] = Tcl_NewStringObj (buff, -1);
	  if (TYPE_CODE (TYPE_FIELD_TYPE (reg_vtype, i)) == TYPE_CODE_FLT)
	    ar[2] = Tcl_NewStringObj ("float", -1);
	  else
	    ar[2] = Tcl_NewStringObj ("int", -1);	    
	  list = Tcl_NewListObj (3, ar);
	  Tcl_ListObjAppendElement (gdbtk_interp, result_ptr->obj_ptr, list);
	  xfree (buff);
	}
    }
  else
    {
      Tcl_Obj *ar[3], *list;
      char *buff;
      buff = xstrprintf ("%s", host_address_to_string (reg_vtype));
      ar[0] = Tcl_NewStringObj (TYPE_NAME(reg_vtype), -1);
      ar[1] = Tcl_NewStringObj (buff, -1);
      if (TYPE_CODE (reg_vtype) == TYPE_CODE_FLT)
	ar[2] = Tcl_NewStringObj ("float", -1);
      else
	ar[2] = Tcl_NewStringObj ("int", -1);	    
      list = Tcl_NewListObj (3, ar);
      xfree (buff);
      Tcl_ListObjAppendElement (gdbtk_interp, result_ptr->obj_ptr, list);
    }
}


static void
get_register (int regnum, map_arg arg)
{
  CORE_ADDR addr;
  enum lval_type lval;
  struct type *reg_vtype;
  int format;
  struct cleanup *old_chain = NULL;
  struct ui_file *stb;
  long dummy;
  char *res;
  struct gdbarch *gdbarch;
  struct value *val;
  struct frame_info *frame;

  format = regformat[regnum];
  if (format == 0)
    format = 'x';
  
  reg_vtype = regtype[regnum];
  if (reg_vtype == NULL)
    reg_vtype = register_type (get_current_arch (), regnum);

  if (!target_has_registers)
    {
      if (result_ptr->flags & GDBTK_MAKES_LIST)
	Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr, Tcl_NewStringObj ("", -1));
      else
	Tcl_SetStringObj (result_ptr->obj_ptr, "", -1);
      return;
    }

  frame = get_selected_frame (NULL);
  gdbarch = get_frame_arch (frame);
  val = get_frame_register_value (frame, regnum);

  if (value_optimized_out (val))
    {
      Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr,
				Tcl_NewStringObj ("Optimized out", -1));
      return;
    }

  stb = mem_fileopen ();
  old_chain = make_cleanup_ui_file_delete (stb);

  if (format == 'r')
    {
      /* shouldn't happen. raw format is deprecated */
      int j;
      char *ptr, buf[1024];
      const gdb_byte *valaddr = value_contents_for_printing (val);

      strcpy (buf, "0x");
      ptr = buf + 2;
      for (j = 0; j < register_size (gdbarch, regnum); j++)
	{
	  int idx = ((gdbarch_byte_order (gdbarch) == BFD_ENDIAN_BIG)
		     ? j : register_size (gdbarch, regnum) - 1 - j);
	  sprintf (ptr, "%02x", (unsigned char) valaddr[idx]);
	  ptr += 2;
	}
      fputs_unfiltered (buf, stb);
    }
  else
    {
      struct value_print_options opts;

      get_formatted_print_options (&opts, format);
      opts.deref_ref = 1;
      opts.prettyformat = Val_prettyformat_default;
      val_print (reg_vtype, value_contents_for_printing (val),
		 value_embedded_offset (val), 0,
		 stb, 0, val, &opts, current_language);
    }
  
  res = ui_file_xstrdup (stb, &dummy);

  if (result_ptr->flags & GDBTK_MAKES_LIST)
    Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr, Tcl_NewStringObj (res, -1));
  else
    Tcl_SetStringObj (result_ptr->obj_ptr, res, -1);

  xfree (res);
  do_cleanups (old_chain);
}

static void
get_register_name (int regnum, map_arg arg)
{
  /* Non-zero if the caller wants the register numbers, too.  */
  int numbers = arg.integer;
  Tcl_Obj *name
    = Tcl_NewStringObj (gdbarch_register_name (get_current_arch (), regnum), -1);
  Tcl_Obj *elt;

  if (numbers)
    {
      /* Build a tuple of the form "{REGNAME NUMBER}", and append it to
	 our result.  */
      Tcl_Obj *array[2];

      array[0] = name;
      array[1] = Tcl_NewIntObj (regnum);
      elt = Tcl_NewListObj (2, array);
    }
  else
    elt = name;

  Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr, elt);
}

/* This is a sort of mapcar function for operations on registers */

static int
map_arg_registers (Tcl_Interp *interp, int objc, Tcl_Obj **objv,
		   map_func func, map_arg arg)
{
  int regnum, numregs;

  /* Note that the test for a valid register must include checking the
     gdbarch_register_name because gdbarch_num_regs may be allocated for
     the union of the register sets within a family of related processors.
     In this case, some entries of gdbarch_register_name will change
     depending upon the particular processor being debugged.  */

  numregs = (gdbarch_num_regs (get_current_arch ())
	     + gdbarch_num_pseudo_regs (get_current_arch ()));

  if (objc == 0)		/* No args, just do all the regs */
    {
      result_ptr->flags |= GDBTK_MAKES_LIST;
      for (regnum = 0; regnum < numregs; regnum++)
	{
	  if (gdbarch_register_name (get_current_arch (), regnum) == NULL
	      || *(gdbarch_register_name (get_current_arch (), regnum)) == '\0')
	    continue;
	  func (regnum, arg);
	}      
      return TCL_OK;
    }

  if (objc == 1)
    if (Tcl_ListObjGetElements (interp, *objv, &objc, &objv ) != TCL_OK)
      return TCL_ERROR;

  if (objc > 1)
    result_ptr->flags |= GDBTK_MAKES_LIST;

  /* Else, list of register #s, just do listed regs */
  for (; objc > 0; objc--, objv++)
    {
      if (Tcl_GetIntFromObj (NULL, *objv, &regnum) != TCL_OK)
	{
	  result_ptr->flags |= GDBTK_IN_TCL_RESULT;
	  return TCL_ERROR;
	}

      if (regnum >= 0  && regnum < numregs)
	func (regnum, arg);
      else
	{
	  Tcl_SetStringObj (result_ptr->obj_ptr, "bad register number", -1);
	  return TCL_ERROR;
	}
    }
  return TCL_OK;
}

static void
register_changed_p (int regnum, map_arg arg)
{
  struct value *val;
  gdb_assert (regnum < old_regs_count);

  if (!target_has_registers)
    return;

  val = get_frame_register_value (get_selected_frame (NULL), regnum);
  if (value_optimized_out (val) || !value_entirely_available (val))
    return;

  if (memcmp (&old_regs[regnum * MAX_REGISTER_SIZE],
	      value_contents_all (val),
	      register_size (get_current_arch (), regnum)) == 0)
    return;

  /* Found a changed register.  Save new value and return its number. */

  memcpy (&old_regs[regnum * MAX_REGISTER_SIZE],
	  value_contents_all (val),
	  register_size (get_current_arch (), regnum));

  Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr, Tcl_NewIntObj (regnum));
}

static void
setup_architecture_data (void)
{
  int numregs;

  xfree (old_regs);
  xfree (regformat);
  xfree (regtype);

  numregs = (gdbarch_num_regs (get_current_arch ())
	     + gdbarch_num_pseudo_regs (get_current_arch ()));
  old_regs_count = numregs;
  old_regs = xcalloc (1, numregs * MAX_REGISTER_SIZE + 1);
  regformat = (int *)xcalloc (numregs, sizeof(int));
  regtype = (struct type **)xcalloc (numregs, sizeof(struct type **));
}

/* gdb_regformat sets the format for a register */
/* This is necessary to allow "gdb_reginfo value" to return a list */
/* of registers and values. */
/* Usage: gdb_reginfo format regno typeaddr format */

static int
gdb_regformat (ClientData clientData, Tcl_Interp *interp,
	       int objc, Tcl_Obj **objv)
{
  int fm, regno, numregs;
  struct type *type;

  if (objc != 3)
    {
      Tcl_WrongNumArgs (interp, 0, objv, "gdb_reginfo regno type format");
      return TCL_ERROR;
    }

  if (Tcl_GetIntFromObj (interp, objv[0], &regno) != TCL_OK)
    return TCL_ERROR;

  #ifdef _WIN64
  type = (struct type *)strtoll (Tcl_GetStringFromObj (objv[1], NULL), NULL, 16);  
  #else
  type = (struct type *)strtol (Tcl_GetStringFromObj (objv[1], NULL), NULL, 16);  
  #endif
  fm = (int)*(Tcl_GetStringFromObj (objv[2], NULL));

  numregs = (gdbarch_num_regs (get_current_arch ())
	     + gdbarch_num_pseudo_regs (get_current_arch ()));
  if (regno >= numregs)
    {
      gdbtk_set_result (interp, "Register number %d too large", regno);
      return TCL_ERROR;
    }
  
  regformat[regno] = fm;
  regtype[regno] = type;

  return TCL_OK;
}


/* gdb_reggrouplist returns the names of the register groups */
/* for the current architecture. */
/* Usage: gdb_reginfo groups */

static int
gdb_reggrouplist (ClientData clientData, Tcl_Interp *interp,
		  int objc, Tcl_Obj **objv)
{
  struct reggroup *group;
  int i = 0;

  if (objc != 0)
    {
      Tcl_WrongNumArgs (interp, 0, objv, "gdb_reginfo grouplist");
      return TCL_ERROR;
    }

  for (group = reggroup_next (get_current_arch (), NULL);
       group != NULL;
       group = reggroup_next (get_current_arch (), group))
    {
      if (reggroup_type (group) == USER_REGGROUP)
	Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr, Tcl_NewStringObj (reggroup_name (group), -1));
    }
  return TCL_OK;
}


/* gdb_reggroup returns the names of the registers in a group. */
/* Usage: gdb_reginfo group groupname */

static int
gdb_reggroup (ClientData clientData, Tcl_Interp *interp,
	      int objc, Tcl_Obj **objv)
{
  struct reggroup *group;
  char *groupname;
  int regnum, num;

  if (objc != 1)
    {
      Tcl_WrongNumArgs (interp, 0, objv, "gdb_reginfo group groupname");
      return TCL_ERROR;
    }
  
  groupname = Tcl_GetStringFromObj (objv[0], NULL);
  if (groupname == NULL)
    {
      gdbtk_set_result (interp, "could not read groupname");
      return TCL_ERROR;
    }

  for (group = reggroup_next (get_current_arch (), NULL);
       group != NULL;
       group = reggroup_next (get_current_arch (), group))
    {
      if (strcmp (groupname, reggroup_name (group)) == 0)
	break;
    }

  if (group == NULL)
    return TCL_ERROR;

  num = (gdbarch_num_regs (get_current_arch ())
	 + gdbarch_num_pseudo_regs (get_current_arch ()));
  for (regnum = 0; regnum < num; regnum++)
    {
      if (gdbarch_register_reggroup_p (get_current_arch (), regnum, group))
	Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr, Tcl_NewIntObj (regnum));
    }
  return TCL_OK;
}

@


1.49
log
@Add an assert that we're not overflowing the register cache.

  https://sourceware.org/ml/insight/2013-q3/msg00035.html

gdb/gdbtk/ChangeLog

        * generic/gdbk-register.c (old_regs_count): New variable.
        (register_changed_p): Add new assert.
        (setup_architecture_data): Initialise old_regs_count.
@
text
@d446 1
a446 1
  gdb_byte raw_buffer[MAX_REGISTER_SIZE];
d449 1
a449 3
  if (!target_has_registers
      || !deprecated_frame_register_read (get_selected_frame (NULL), regnum,
					  raw_buffer))
d452 6
a457 1
  if (memcmp (&old_regs[regnum * MAX_REGISTER_SIZE], raw_buffer,
d463 2
a464 1
  memcpy (&old_regs[regnum * MAX_REGISTER_SIZE], raw_buffer,
@


1.48
log
@Move comment about old_regs next to the definition.

gdb/gdbtk/ChangeLog

        * generic/gdbk-register.c (old_regs): Move the comment about this
        variable next to the definition.
@
text
@d66 1
d447 1
d477 1
@


1.47
log
@2013-07-15  Roland Schwingel  <roland.schwingel@@onevision.com>

   * generic/gdbtk-register.c (get_register): Update
   to reflect changes from upstream gdb. Prettyprinting
   becomes prettyformatting now.
   * generic/gdbtk-wrapper.c (GDB_val_print,wrap_val_print):
   Likewise.
   * generic/gdbtk-wrapper.h (GDB_val_print): Likewise.
@
text
@a45 5
/* This contains the previous values of the registers, since the last call to
   gdb_changed_register_list.

   It is an array of (NUM_REGS+NUM_PSEUDO_REGS)*MAX_REGISTER_RAW_SIZE bytes. */

d60 5
@


1.46
log
@	* generic/gdbtk-cmds.c (gdb_listfuncs): Update declaration.
	* generic/gdbtk-hooks.c (gdb_two_elem_cmd): Likewise.
	(report_error): Likewise.
	(gdbtk_readline_end, gdbtk_post_add_symbol, gdbtk_error_begin,
	gdbtk_attach): Likewise.
	* generic/gdbtk/gdbtk-register.c (setup_architecture_data):
	Likewise.
	* generic/gdbtk-wrapper.c (GDB_equal_value, GDB_reinit_frame_cache,
	GDB_value-coerce_array): Likewise.
	* generic/gdbtk.c (gdbtk_interactive, gdbtk_start_timer,
	gdbtk_stop_timer, _initialize_gdbtk): Likewise.
@
text
@d343 1
a343 1
      opts.pretty = Val_pretty_default;
@


1.45
log
@	* generic/gdbtk-register.c (map_arg_registers): Change type of
	raw_buffer to gdb_byte to follow recent API changes in gdb.
	* generic/gdbtk-cmds.c (gdb_update_mem): Likewise for ' mbfu',
	'mptr', and 'cptr'.
@
text
@d465 1
a465 1
setup_architecture_data ()
@


1.44
log
@	* generic/gdbtk-register.c (register_changed_p): Adapt to
	function name change from frame_register_read to
	deprecated_frame_register_read.
@
text
@d2 1
a2 1
   Copyright (C) 2001-2012 Free Software Foundation, Inc.
d445 1
a445 1
  char raw_buffer[MAX_REGISTER_SIZE];
@


1.43
log
@	* generic/gdbtk-register.c (get_register_types): Use
	host_address_to_string function to avoid use of "%lx" and
	typecasts.
@
text
@d448 2
a449 1
      || !frame_register_read (get_selected_frame (NULL), regnum, raw_buffer))
@


1.42
log
@	* generic/gdbtk-register.c: Updated Copyright year to 2001-2012.
	(get_register_types): Cast result of TYPE_FIELD_TYPE to size_t
	instead of long.
	(gdb_regformat): on windows 64bit use strtoll instead of strtol.
	* generic/gdbtk-stack.c: Updated Copyright year to 2001-2012.
	(gdb_get_vars_command): Don't cast clientData to long. Here
	checking of non NULL clientData is enough.
@
text
@d242 2
a243 1
	  buff = xstrprintf ("%lx", (size_t)TYPE_FIELD_TYPE (reg_vtype, i));
d259 1
a259 1
      buff = xstrprintf ("%lx", (size_t)reg_vtype);
@


1.41
log
@	* generic/gdbtk-bp.c (tracepoint_exists): Remove recently
	removed "not_found_ptr" argument from call to decode_line_1.
	* generic/gdbtk-stack.c (gdb_get_vars_command): Likewise.
	* generic/gdbtk-cmds.c (gdb_get_line_command): Likewise.
	(gdb_get_file_command): Likewise.
	(gdb_get_function_command): Likewise.

	From Kevin Buettner  <kevinb@@redhat.com>
	* generic/gdbtk-register.c (): Delete declaration of `buffer'.
	Use `valaddr' in its place.
@
text
@d2 1
a2 2
   Copyright (C) 2001, 2002, 2004, 2007, 2010, 2011
   Free Software Foundation, Inc.
d242 1
a242 1
	  buff = xstrprintf ("%lx", (long)TYPE_FIELD_TYPE (reg_vtype, i));
d258 1
a258 1
      buff = xstrprintf ("%lx", (long)reg_vtype);
d499 3
d503 1
@


1.40
log
@	* generic/gdbtk-bp.c (tracepoint_exists): Update for
	decode_line_1 API change.
	* generic/gdbtk-cmds.c (gdb_eval): Use comman_val_print
	instead of val_print.
	(gdb_get_line_command): Update for decode_line_1 API
	changes.
	(gdb_get_file_command): Likewise.
	(gdb_get_function_command): Likewise.
	* generic/gdbtk-register.c (get_register_types): Use
	get_frame_register_value instead of frame_register.
	(get_register): Pass valid VALUE to val_print.
	Consolidate calls to get_current_gdbarch.
	* generic/gdbtk-stack.c (gdb_get_vars_command): Update
	for decode_line_1 API change.
@
text
@a278 1
  gdb_byte buffer[MAX_REGISTER_SIZE];
d332 1
a332 1
	  sprintf (ptr, "%02x", (unsigned char) buffer[idx]);
@


1.39
log
@	* generic/gdbtk-cmds.c: Add cygwin macros to allow compilation
	with old or recent cygwin version.
	(gdb_path_conv): Use cygwin_conv_path function.
	(gdb_eval): Adapt to new field in val_print.
	* generic/gdbtk-register.c (get_register): Likewise.
	* generic/gdbtk-wrapper.c (wrap_val_print): Likewise.
	* generic/gdbtk.c (_initialize_gdbtk): Use cygwin_attach_handle_to_fd
	call to allow compilation with old and new cygwin version.
@
text
@d2 2
a3 1
   Copyright (C) 2001, 2002, 2004, 2007 Free Software Foundation, Inc.
a275 1
  int realnum;
d280 1
a280 1
  int optim, format;
d285 4
a288 1
 
d306 3
a308 2
  frame_register (get_selected_frame (NULL), regnum, &optim, &lval, 
		  &addr, &realnum, buffer);
d310 1
a310 1
  if (optim)
d325 1
d329 1
a329 1
      for (j = 0; j < register_size (get_current_arch (), regnum); j++)
d331 2
a332 2
	  int idx = ((gdbarch_byte_order (get_current_arch ()) == BFD_ENDIAN_BIG)
		     ? j : register_size (get_current_arch (), regnum) - 1 - j);
d345 3
a347 11

      if ((TYPE_CODE (reg_vtype) == TYPE_CODE_UNION)
	  && (strcmp (FIELD_NAME (TYPE_FIELD (reg_vtype, 0)), 
		      gdbarch_register_name (get_current_arch (), regnum)) == 0))
	{
	  val_print (FIELD_TYPE (TYPE_FIELD (reg_vtype, 0)), buffer, 0, 0,
		     stb, 0, NULL, &opts, current_language);
	}
      else
	val_print (reg_vtype, buffer, 0, 0,
		   stb, 0, NULL, &opts, current_language);
@


1.38
log
@	* generic/gdbtk-bp.c: Include "arch-utils.h".
	(set_raw_breakpoint): Update external definition.
	(gdb_set_bp): Adapt to set_raw_breakpoint change.
	(gdb_set_bp_addr): Likewise.
	* generic/gdbtk-cmds.c: Include "arch-utils.h.
	(gdbtk_load_asm): Adapt to paddress and gdb_print_insn changes.
	(hex2bin): Replace current_gdbarch by get_current_arch call.
	(gdb_update_mem): Adapt to builtin_type changes.
	(gdb_CA_to_TAS): Use paddress to replace removed function paddr_nz.
	* generic/gdbtk-register.c: Include "arch-utils.h".
	(get_register_size): Replace current_gdbarch by get_current_arch call.
	(get_register_types): Likewise.
	(get_register): Likewise.
	(get_register_name): Likewise.
	(map_arg_registers): Likewise.
	(register_changed_p): Likewise.
	(setup_architecture_data): Likewise.
	(gdb_regformat): Likewise.
	(gdb_reggrouplist): Likewise.
	(gdb_reggroup): Likewise.
	* generic/gdbtk-stack.c: Inlcude "arch-utils.h".
	(gdb_get_blocks): Use paddress instead of removed paddr_nz function.
	(gdb_selected_block): Likewise.
	(gdb_selected_frame): Likewise.
@
text
@d346 1
a346 1
		     stb, 0, &opts, current_language);
d350 1
a350 1
		   stb, 0, &opts, current_language);
@


1.37
log
@	ARI fix: "xasprintf" rule.
	* generic/gdbtk-bp.c (gdb_set_bp): Replace xasprintf by xstrprintf.
	(breakpoint_notify, tracepoint_notify):Ditto.
	* generic/gdbtk-cmds.c (gdbtk_load_source, gdbtk_load_asm):Ditto.
	* generic/gdbtk-hooks.c (gdbtk_ignorable_warning): Ditto.
	(gdbtk_set_hook, gdbtk_load_hash): Ditto.
	(gdbtk_selected_frame_changed, gdbtk_annotate_signal): Ditto.
	* generic/gdbtk-register.c (get_register_types):Ditto.
	* generic/gdbtk-stack.c (gdb_get_blocks): Ditto.
	(gdb_selected_block, gdb_selected_frame): Ditto.
	* generic/gdbtk.c (gdbtk_init, view_command): Ditto.
@
text
@d30 1
d215 2
a216 1
			    Tcl_NewIntObj (register_size (current_gdbarch, regnum)));
d229 1
a229 1
  reg_vtype = register_type (current_gdbarch, regnum);
d292 1
a292 1
    reg_vtype = register_type (current_gdbarch, regnum);
d324 1
a324 1
      for (j = 0; j < register_size (current_gdbarch, regnum); j++)
d326 2
a327 2
	  int idx = ((gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_BIG)
		     ? j : register_size (current_gdbarch, regnum) - 1 - j);
d343 1
a343 1
		      gdbarch_register_name (current_gdbarch, regnum)) == 0))
d370 1
a370 1
    = Tcl_NewStringObj (gdbarch_register_name (current_gdbarch, regnum), -1);
d403 2
a404 2
  numregs = (gdbarch_num_regs (current_gdbarch)
	     + gdbarch_num_pseudo_regs (current_gdbarch));
d411 2
a412 2
	  if (gdbarch_register_name (current_gdbarch, regnum) == NULL
	      || *(gdbarch_register_name (current_gdbarch, regnum)) == '\0')
d456 1
a456 1
	      register_size (current_gdbarch, regnum)) == 0)
d462 1
a462 1
	  register_size (current_gdbarch, regnum));
d476 2
a477 2
  numregs = (gdbarch_num_regs (current_gdbarch)
	     + gdbarch_num_pseudo_regs (current_gdbarch));
d507 2
a508 2
  numregs = (gdbarch_num_regs (current_gdbarch)
	     + gdbarch_num_pseudo_regs (current_gdbarch));
d539 1
a539 1
  for (group = reggroup_next (current_gdbarch, NULL);
d541 1
a541 1
       group = reggroup_next (current_gdbarch, group))
d574 1
a574 1
  for (group = reggroup_next (current_gdbarch, NULL);
d576 1
a576 1
       group = reggroup_next (current_gdbarch, group))
d585 2
a586 2
  num = (gdbarch_num_regs (current_gdbarch)
	 + gdbarch_num_pseudo_regs (current_gdbarch));
d589 1
a589 1
      if (gdbarch_register_reggroup_p (current_gdbarch, regnum, group))
@


1.36
log
@	* generic/gdbtk-cmds.c (valprint.h): Include.
	(gdb_eval): Fetch print options via get_formatted_print_options.
	Update call to val_print.
	(gdb_update_mem): Likewise, but for print_scalar_formatted.
	* generic/gdbtk-register.c (valprint.h): Include.
	(get_register): Use get_formatted_print_options.  Update calls
	to val_print.
	* generic/gdbtk-wrapper.c (valprint.h): Include.
	(wrap_val_print): Use get_formatted_print_options.  Delete
	variables deref_ref and pretty; assign to equivalent fields
	in the value_print_options struct instead.  Update call to
	val_print.
@
text
@d240 1
a240 1
	  xasprintf (&buff, "%lx", (long)TYPE_FIELD_TYPE (reg_vtype, i));
d256 1
a256 1
      xasprintf (&buff, "%lx", (long)reg_vtype);
@


1.35
log
@	* Update uses of val_print functions with additional language argument.
	generic/gdbtk-cmds.c: Add "language.h" include.
	(gdb_eval): Add current_language as new arg of val_print.
	generic/gdbtk-register.c: Add "language.h" include.
	(get_register): Add current_language as new arg of val_print.
	generic/gdbtk-wrapper.c: Add "language.h" include.
	(wrap_val_print): Add current_language as new arg of val_print.
@
text
@d29 1
d333 6
d344 1
a344 1
		     stb, format, 1, 0, Val_pretty_default, current_language);
d348 1
a348 1
		   stb, format, 1, 0, Val_pretty_default, current_language);
@


1.34
log
@        * generic/gdbtk-register.c (map_arg): New data type
        for passing arguments to mapping functions.
        (map_func): New definition of mapping function.
        Changed all callers to use these new types.
        * generic/gdbtk-stack.c (gdb_get_vars_command): Change
        cast to int to dereference of int *.
        * generic/gdbtk-wrapper.c: Change all casts to char * for
        results and args to use pointer or integer flavor of
        gdb_wrapper_args.results and .args.
        * generic/gdbtk-wrapper.h: struct gdb_wrapper_arguments
        members result and args now return a union of void * and int.
@
text
@d28 1
d337 1
a337 1
		     stb, format, 1, 0, Val_pretty_default);
d341 1
a341 1
		   stb, format, 1, 0, Val_pretty_default);
@


1.33
log
@        * generic/gdbtk-register.c (Gdbtk_Register_Init): Remove
        calls to deprecated_register_gdbarch_swap.
        Add "gdb_reg_arch_changed" command.
        * library/regwin.itb (arch_changed): Call gdb_reg_arch_changed.
@
text
@d33 10
d49 3
a51 3
static void get_register (int, void *);
static void get_register_name (int, void *);
static void get_register_size (int regnum, void *arg);
d53 2
a54 2
			      void (*)(int, void *), void *);
static void register_changed_p (int, void *);
d60 1
a60 1
static void get_register_types (int regnum, void *arg);
d129 2
a130 2
  void *argp;
  void (*func)(int, void *);
d157 1
a157 1
      argp = NULL;
d166 1
a166 1
	    argp = (void *) 1;
d171 1
a171 1
	  argp = NULL;
d179 1
a179 1
      argp = NULL;
d184 1
a184 1
      argp = NULL;
d189 1
a189 1
      argp = NULL;
d205 1
a205 1
  return map_arg_registers (interp, objc, objv, func, argp);
d209 1
a209 1
get_register_size (int regnum, void *arg)
d220 1
a220 1
get_register_types (int regnum, void *arg)
d269 1
a269 1
get_register (int regnum, void *arg)
d355 1
a355 1
get_register_name (int regnum, void *argp)
d358 1
a358 1
  int numbers = (int) argp;
d383 1
a383 1
		   void (*func) (int regnum, void *argp), void *argp)
d404 1
a404 1
	  func (regnum, argp);
d426 1
a426 1
	func (regnum, argp);
d437 1
a437 1
register_changed_p (int regnum, void *argp)
@


1.32
log
@        * generic/gdbtk-register.c get_register): Replace REGISTER_NAME
        with gdbarch_register_name.
        (get_register_name): Ditto.
        (map_arg_registers): Ditto.
@
text
@d61 2
a66 5
  deprecated_register_gdbarch_swap (&old_regs, sizeof (old_regs), NULL);
  deprecated_register_gdbarch_swap (&regformat, sizeof (regformat), NULL);
  deprecated_register_gdbarch_swap (&regtype, sizeof (regtype), NULL);
  deprecated_register_gdbarch_swap (NULL, 0, setup_architecture_data);

@


1.31
log
@        * generic/gdbtk-cmds.c (hex2bin): Use gdbarch_byte_order instead
        of TARGET_BYTE_ORDER.
        * generic/gdbtk-register.c (get_register): Likewise.
        (map_arg_registers): Use gdbarch_num_regs and gdbarch_num_pseduo_regs
        instead of NUM_REGS and NUM_PSEUDO_REGS.
        (setup_architecture_data): Likewise.
        (gdb_regformat): Likewise.
        (gdb_reggroup): Likewise.
@
text
@d326 1
a326 1
		      REGISTER_NAME (regnum)) == 0))
d352 2
a353 1
  Tcl_Obj *name = Tcl_NewStringObj (REGISTER_NAME (regnum), -1);
d381 4
a384 4
     REGISTER_NAME because NUM_REGS may be allocated for the union of
     the register sets within a family of related processors.  In this
     case, some entries of REGISTER_NAME will change depending upon
     the particular processor being debugged.  */
d394 2
a395 2
	  if (REGISTER_NAME (regnum) == NULL
	      || *(REGISTER_NAME (regnum)) == '\0')
@


1.30
log
@Eliminate use of `deprecated_selected_frame'.
@
text
@d2 1
a2 1
   Copyright (C) 2001, 2002, 2004 Free Software Foundation, Inc.
d315 2
a316 2
	  int idx = TARGET_BYTE_ORDER == BFD_ENDIAN_BIG ? j
	    : register_size (current_gdbarch, regnum) - 1 - j;
d385 2
a386 1
  numregs = NUM_REGS + NUM_PSEUDO_REGS;
d452 2
d458 5
a462 3
  old_regs = xcalloc (1, (NUM_REGS + NUM_PSEUDO_REGS) * MAX_REGISTER_SIZE + 1);
  regformat = (int *)xcalloc ((NUM_REGS + NUM_PSEUDO_REGS) , sizeof(int));
  regtype = (struct type **)xcalloc ((NUM_REGS + NUM_PSEUDO_REGS), sizeof(struct type **));
d474 1
a474 1
  int fm, regno;
d489 3
a491 1
  if (regno >= NUM_REGS + NUM_PSEUDO_REGS)
d541 1
a541 1
  int regnum;
d567 3
a569 1
  for (regnum = 0; regnum < NUM_REGS + NUM_PSEUDO_REGS; regnum++)
@


1.29
log
@	* generic/gdbtk.h:
	* generic/gdbtk.c:
	* generic/gdbtk-wrapper.h:
	* generic/gdbtk-wrapper.c:
	* generic/gdbtk-varobj.c:
	* generic/gdbtk-stack.c:
	* generic/gdbtk-register.c:
	* generic/gdbtk-main.c:
	* generic/gdbtk-interp.c:
	* generic/gdbtk-hooks.c:
	* generic/gdbtk-cmds.h:
	* generic/gdbtk-cmds.c:
	* generic/gdbtk-bp.c: Put (C) after Copyright.  Update the FSF
	address.
@
text
@d432 2
a433 2
  if (deprecated_selected_frame == NULL
      || !frame_register_read (deprecated_selected_frame, regnum, raw_buffer))
@


1.28
log
@        * generic/gdbtk-cmds.c (gdb_set_mem): target_write_memory now takes
        gdb_byte* instead of char*.
        * generic/gdbtk-register.c (get_register): frame_register and val_print
        take gdb_byte* instead of char*.
        * generic/gdbtk-wrapper.c: Ditto the val_print part.

        From Paul Schlie  <schlie@@comcast.net>:
        * generic/gdbtk-bp.c (gdb_set_bp): Use lbasename instead of basename.
        * generic/gdbtk-cmds.c (gdb_listfiles): Likewise.
@
text
@d2 1
a2 1
   Copyright 2001, 2002, 2004 Free Software Foundation, Inc.
d18 2
a19 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.27
log
@2004-10-31  David Lecomber <dsl@@sources.redhat.com>
	* generic/gdbtk-register.c: Add message parameter
	to call of get_selected_frame.
@
text
@d268 1
a268 1
  char buffer[MAX_REGISTER_SIZE];
@


1.26
log
@Fix build failure.

	* generic/gdbtk-register.c (get_register_size): Use
	register_size() instead of DEPRECATED_REGISTER_RAW_SIZE.
	(get_register): Likewise.
	(register_changed_p): Likewise.
@
text
@d292 1
a292 1
  frame_register (get_selected_frame (), regnum, &optim, &lval, 
@


1.25
log
@2004-06-11  Martin Hunt  <hunt@@redhat.com>

	* generic/gdbtk-cmds.c (gdb_find_file_command): Use
	symtab_to_fullname() instead of symtab_to_filename().
	(gdb_loc): Ditto.
	(gdb_loadfile): Ditto.
	* generic/gdbtk-bp.c (gdb_get_breakpoint_info): Ditto.
	(gdb_get_tracepoint_info): Ditto.

	* generic/gdbtk-register.c (get_register): Simplify and remove
	references to DEPRECATED_REGISTER_CONVERT_TO_VIRTUAL.
@
text
@d205 1
a205 2
			    Tcl_NewIntObj (DEPRECATED_REGISTER_RAW_SIZE
					   (regnum)));
d313 1
a313 1
      for (j = 0; j < DEPRECATED_REGISTER_RAW_SIZE (regnum); j++)
d316 1
a316 1
	    : DEPRECATED_REGISTER_RAW_SIZE (regnum) - 1 - j;
d437 1
a437 1
	      DEPRECATED_REGISTER_RAW_SIZE (regnum)) == 0)
d443 1
a443 1
	  DEPRECATED_REGISTER_RAW_SIZE (regnum));
@


1.24
log
@2004-03-29  Martin Hunt  <hunt@@redhat.com>

	* generic/gdbtk-register.c (map_arg_registers): If a specific
	register was requested, just return it without validating it
	has a name.
	(get_register): Check DEPRECATED_REGISTER_CONVERTIBLE_P ().
@
text
@d269 1
a269 2
  char raw_buffer[MAX_REGISTER_SIZE];
  char virtual_buffer[MAX_REGISTER_SIZE];
d294 1
a294 1
		  &addr, &realnum, raw_buffer);
a302 10
  /* Convert raw data to virtual format if necessary.  */
  if (DEPRECATED_REGISTER_CONVERTIBLE_P () && DEPRECATED_REGISTER_CONVERTIBLE (regnum))
    {
      DEPRECATED_REGISTER_CONVERT_TO_VIRTUAL (regnum, reg_vtype,
      				   raw_buffer, virtual_buffer);
    }
  else
    memcpy (virtual_buffer, raw_buffer,
	    DEPRECATED_REGISTER_VIRTUAL_SIZE (regnum));

d318 1
a318 1
	  sprintf (ptr, "%02x", (unsigned char) raw_buffer[idx]);
d329 1
a329 1
	  val_print (FIELD_TYPE (TYPE_FIELD (reg_vtype, 0)), virtual_buffer, 0, 0,
d333 1
a333 1
	val_print (reg_vtype, virtual_buffer, 0, 0,
@


1.23
log
@2004-02-17  Martin Hunt  <hunt@@redhat.com>

	* generic/gdbtk-register.c (Gdbtk_Register_Init): Replace
	calls to register_gdbarch_swap with deprecated_register_gdbarch_swap.

	* library/srcwin.itb: Remove an apparently redundant call
	to gdbtk_locate_main and location. This actually broken
	situations where no source files were found.
@
text
@d2 1
a2 1
   Copyright 2001, 2002 Free Software Foundation, Inc.
d305 1
a305 1
  if (DEPRECATED_REGISTER_CONVERTIBLE (regnum))
d428 1
a428 3
      if (regnum >= 0  && regnum < numregs
	  && REGISTER_NAME (regnum) != NULL
	  && *REGISTER_NAME (regnum) != '\000')
@


1.22
log
@2003-10-06  David Carlton  <carlton@@kealia.com>

	* generic/gdbtk-register.c (get_register_size): Replace
	REGISTER_RAW_SIZE by DEPRECATED_REGISTER_RAW_SIZE.
	(get_register, register_changed_p): Ditto.
@
text
@d65 4
a68 4
  register_gdbarch_swap (&old_regs, sizeof (old_regs), NULL);
  register_gdbarch_swap (&regformat, sizeof (regformat), NULL);
  register_gdbarch_swap (&regtype, sizeof (regtype), NULL);
  register_gdbarch_swap (NULL, 0, setup_architecture_data);
@


1.21
log
@2003-09-30  David Carlton  <carlton@@kealia.com>

	* generic/gdbtk-register.c (get_register): Replace
	REGISTER_VIRTUAL_SIZE by
	DEPRECATED_REGISTER_VIRTUAL_SIZE.
@
text
@d205 2
a206 1
			    Tcl_NewIntObj (REGISTER_RAW_SIZE (regnum)));
d325 1
a325 1
      for (j = 0; j < REGISTER_RAW_SIZE (regnum); j++)
d328 1
a328 1
	    : REGISTER_RAW_SIZE (regnum) - 1 - j;
d451 1
a451 1
	      REGISTER_RAW_SIZE (regnum)) == 0)
d457 1
a457 1
	  REGISTER_RAW_SIZE (regnum));
@


1.20
log
@2003-08-05  Andrew Cagney  <cagney@@redhat.com>

	* generic/gdbtk-register.c (gdb_reggrouplist): Update, use
	reggroup_next.
	(gdb_reggroup): Ditto.
@
text
@d310 2
a311 1
    memcpy (virtual_buffer, raw_buffer, REGISTER_VIRTUAL_SIZE (regnum));
@


1.19
log
@2003-06-11  David Carlton  <carlton@@bactrian.org>

	* generic/gdbtk-register.c (get_register): REGISTER_CONVERTIBLE
	and REGISTER_CONVERT_TO_VIRTUAL are deprecated.
@
text
@d517 1
a517 1
  struct reggroup *const *groups;
d526 7
a532 7
  groups = reggroups (current_gdbarch);

  while (groups[i] != NULL) {
    if (reggroup_type (groups[i]) == USER_REGGROUP)
      Tcl_ListObjAppendElement (NULL, result_ptr->obj_ptr, Tcl_NewStringObj (reggroup_name(groups[i]), -1));
    i++;
  }
d544 1
a544 1
  struct reggroup *const *group;
d561 3
a563 1
  for (group = reggroups (current_gdbarch); *group != NULL; group++)
d565 1
a565 1
      if (strcmp (groupname, reggroup_name (*group)) == 0)
d569 1
a569 1
  if (*group == NULL)
d574 1
a574 1
      if (gdbarch_register_reggroup_p (current_gdbarch, regnum, *group))
@


1.18
log
@2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* generic/gdbtk-register.c (get_register): Replace
	MAX_REGISTER_VIRTUAL_SIZE and MAX_REGISTER_RAW_SIZE with
	MAX_REGISTER_SIZE.
	(register_changed_p, setup_architecture_data): Ditto.
@
text
@d304 1
a304 1
  if (REGISTER_CONVERTIBLE (regnum))
d306 1
a306 1
      REGISTER_CONVERT_TO_VIRTUAL (regnum, reg_vtype,
@


1.17
log
@2003-03-24  Martin M. Hunt  <hunt@@redhat.com>

	* generic/gdbtk-register.c (get_register_types): Use
	register_type instead of REGISTER_VIRTUAL_TYPE.
	(get_register): Ditto.
@
text
@d268 2
a269 2
  char *raw_buffer = alloca (MAX_REGISTER_RAW_SIZE);
  char *virtual_buffer = alloca (MAX_REGISTER_VIRTUAL_SIZE);
d442 1
a442 1
  char *raw_buffer = alloca (MAX_REGISTER_RAW_SIZE);
d448 1
a448 1
  if (memcmp (&old_regs[regnum * MAX_REGISTER_RAW_SIZE], raw_buffer,
d454 1
a454 1
  memcpy (&old_regs[regnum * MAX_REGISTER_RAW_SIZE], raw_buffer,
d467 1
a467 1
  old_regs = xcalloc (1, (NUM_REGS + NUM_PSEUDO_REGS) * MAX_REGISTER_RAW_SIZE + 1);
@


1.16
log
@        * generic/gdbtk-register.c (get_register): Use frame_register
        instead of get_saved_register (which was deleted from gdb).
@
text
@d218 2
a219 1
  reg_vtype = REGISTER_VIRTUAL_TYPE (regnum);
d282 1
a282 2
    reg_vtype = REGISTER_VIRTUAL_TYPE (regnum);

@


1.15
log
@        * generic/gdbtk-register.c (register_changed_p): If the selected
        frame is NULL, do not call frame_register_read, since that will
        now cause an internal error.
@
text
@d263 3
d293 3
a295 2
  get_saved_register (raw_buffer, &optim, (CORE_ADDR *) NULL, deprecated_selected_frame,
		      regnum, (enum lval_type *) NULL);
@


1.14
log
@2003-02-10  Andrew Cagney  <ac131313@@redhat.com>

	* generic/gdbtk-varobj.c (gdb_variable_command): Ditto for
	`commands'.
	(variable_type): Ditto for `first'.
	(variable_obj_command): Ditto.
	(variable_create): Ditto for create_options.
	(variable_type): Ditto for `last'.  Use `string' and not `first'
	when modifying the buffer.
	(struct disassembly_client_data ): Ditto for `asm_argv'
	* generic/gdbtk-register.c (gdb_register_info): Ditto for
	`commands'.
	* generic/gdbtk-hooks.c (tk_command_loop): Ditto for `msg'.
	* generic/gdbtk-cmds.c (gdb_search): Ditto for `switches'.
	(gdbtk_load_source): Ditto for `text_argv'.
	(struct disassembly_client_data ): Ditto for `source_argv'.
	(gdbtk_load_asm): Ditto for `text_argv'.
	(struct disassembly_client_data ): Ditto for `asm_argv'
	(gdb_loadfile): Ditto for `text_argv'.
	* generic/gdbtk.c (TclDebug): Make `v' a constant pointer.
	(gdbtk_init): Ditto for `old_chain', `src_path', `msg', and
	`lib_path'.
@
text
@d440 2
a441 1
  if (!frame_register_read (deprecated_selected_frame, regnum, raw_buffer))
@


1.13
log
@2002-12-17  Martin M. Hunt  <hunt@@redhat.com>

	* library/regwin.itb (_load_prefs): Get list of registers from
	the group name.
	(_build_win): Remove old menu system.  Replace with an optionmenu
	that contains all the valid group names for this architecture.
	(_layout_table): No need to update old menu.
	(_but3): Add "Close" to popup menu.
	(_delete_from_display): No need to update old menu.
	(_display_all): Ditto.
	(_post_menu): Deleted.
	(_select_group): New method. Callback for group optionmenu.

	* library/regwin.ith: New private variable _group.
	New private method _select_group.  Removed _post_menu.

	* generic/gdbtk-register.c: Include reggroups.h.
	(gdb_register_info): Add "group" and "grouplist".
	(gdb_regformat): Fix Tcl_WrongNumArgs call so it doesn't crash.
	(gdb_reggrouplist): New function. Returns the names of the
	register groups.
	(gdb_reggroup): New function. Returns the register numbers of the
	registers in a group.
@
text
@d124 1
a124 1
  static char *commands[] = {"changed", "name", "size", "value", "type", 
@


1.12
log
@2002-11-30  Andrew Cagney  <ac131313@@redhat.com>

	* generic/gdbtk-stack.c: Replace selected_frame with
	deprecated_selected_frame.
	* generic/gdbtk-register.c: Ditto.
	* generic/gdbtk-cmds.c (gdb_loc): Replace selected_frame with
	deprecated_selected_frame.  Use get_frame_pc and find_frame_sal.
@
text
@d24 1
d47 3
d124 4
a127 3
  static char *commands[] = {"changed", "name", "size", "value", "type", "format", NULL};
  enum commands_enum { REGINFO_CHANGED, REGINFO_NAME, REGINFO_SIZE, 
		       REGINFO_VALUE, REGINFO_TYPE, REGINFO_FORMAT };
d131 1
a131 1
      Tcl_WrongNumArgs (interp, 1, objv, "name|size|value|type|format [regnum1 ... regnumN]");
d188 6
d481 1
a481 1
      Tcl_WrongNumArgs (interp, 1, objv, "regno type format");
d502 71
@


1.11
log
@Index: ChangeLog
2002-08-03  Andrew Cagney  <ac131313@@redhat.com>

* Makefile.in (gdbtk-bp.o): Update dependencies.
(gdbtk-register.o): Ditto.
(gdbtk-varobj.o): Ditto.

Index: gdbtk/ChangeLog
2002-08-03  Andrew Cagney  <ac131313@@redhat.com>

* generic/gdbtk-bp.c: Include "gdb_string.h".
* generic/gdbtk-register.c: Ditto.
* generic/gdbtk-varobj.c: Ditto.
@
text
@d279 1
a279 1
  get_saved_register (raw_buffer, &optim, (CORE_ADDR *) NULL, selected_frame,
d429 1
a429 1
  if (!frame_register_read (selected_frame, regnum, raw_buffer))
@


1.10
log
@2002-05-15  Martin M. Hunt  <hunt@@redhat.com>

	* library/help/register.html: Rewrite docs.

	* library/regwin.ith (_types): New private variable array to save
	the possible types for each register.
	(_type): New private variable array to save the selected type for
	each register.
	(_rows): New private variable. Number of rows in the table.
	(_cols): New private variable. Number of cols in the table.
	(_load_prefs): New private method.
	(_open_memory): New private method.
	(_edit_menu): Deleted:
	(_select): Deleted.
	(_change_format): Add optional type argument.

	* library/regwin.itb (RegWin::_load_prefs): New method. Collects
	all the prefs stuff here instead of in _layout_table. Prefs
	code was all rewritten to handle new types and formats.
	(RegWin::_build_win): Disable Double-1 binding. Bind
	button 1 to edit the cell. Don't make an Edit menu item.
	Remove Natural, Binary, Octal, and Raw formats. Add "Open
	Memory Window" menu item.
	(RegWin::_dimensions): This function was being abused so I removed
	it. Replaced with inline code in _layout_table which saves its
	computed values so it doesn't have to be recalculated unless
	something changes.
	(RegWin::_layout_table): Rewritten to be more efficient. Grabs
	all values in one call to gdb_reginfo instead of one for each register.
	Uses new types and formats.  Calls _load_prefs.
	(RegWin::_accept_edit): Use type information when setting value.
	When done, call _unedit to remove tags.
	(RegWin::_open_memory): Open memory window with initial value
	set to the value of a register.
	(RegWin::_but3): Add types menu items. Limit format options
	to reasonable ones. Add "Open Memory Window". Add "Help"
	(RegWin::_edit): Just call _select_cell.
	(RegWin::_edit_menu): Deleted.
	(RegWin::_move): Don't recompute rows and cols; use _rows and
	_cols computed by _layout_table.
	(RegWin::_post_menu): Update types and formats. Disable "Open Memory
	Window" if register is not integer. Remove Edit.
	(RegWin::_select): Deleted.
	(RegWin::_select_cell):	Tag cell as being edited. Then
	call focus, which is a workaround for a TkTable glitch where
	the insertion bar sometimes disappeared.
	(RegWin::_unedit): Clear selection. Call focus. Don't change
	any bindings.
	(RegWin::_get_value): Eliminate previous crap and just call
	"gdb_reginfo value".
	(RegWin::_change_format): Add optional type arg.  Call
	"gdb_reginfo format".
	(RegWin::_update): Get a list of all the changed registers
	instead of checking one at a time.

	* generic/gdbtk-register.c (Gdbtk_Register_Init): Don't
	create gdb_pc_reg.  It is not used. Call register_gdbarch_swap
	with regformat and regtype.
	(gdb_register_info): Add "type" and "format" options.
	(get_pc_register): Delete.
	(get_register_types): New function.  Returns list of valid types
	for a list of registers.
	(get_register): Use saved format and type for each register. Check if
	there are any registers yet (target not running). Use mem_file
	to collect output. Append output to a list.
	(map_arg_registers): If passed a list, iterate though each element
	and build a list of values to return.
	(setup_architecture_data): Memory was not being initialized, so
	use xcalloc(). Allocate memory for regformat and regtype.
	(gdb_regformat): New function called by "gdb_reginfo format".
@
text
@d26 1
@


1.9
log
@* generic/gdbtk-register.c (get_register, register_changed_p):
Don't depend on variable-sized automatic arrays.
@
text
@d25 1
d36 1
a36 4
static char *old_regs = NULL;

static int get_pc_register (ClientData, Tcl_Interp *, int, Tcl_Obj * CONST[]);
static int gdb_register_info (ClientData, Tcl_Interp *, int, Tcl_Obj * CONST[]);
d40 1
a40 1
static int map_arg_registers (int, Tcl_Obj * CONST[],
d44 6
a55 2
  Tcl_CreateObjCommand (interp, "gdb_pc_reg", gdbtk_call_wrapper, get_pc_register,
			NULL);
d59 1
d61 2
d110 1
a110 2
 *    usage: gdb_reginfo value format [regnum0, ..., regnumN]
 *       format: The format string for printing the values, "N", "x", "d", etc
d114 1
a114 1
                   Tcl_Obj *CONST objv[])
d119 3
a121 2
  static char *commands[] = {"changed", "name", "size", "value", NULL};
  enum commands_enum { REGINFO_CHANGED, REGINFO_NAME, REGINFO_SIZE, REGINFO_VALUE };
d125 1
a125 1
      Tcl_WrongNumArgs (interp, 1, objv, "name|size|value [regnum1 ... regnumN]");
d130 1
a130 1
			   &index) != TCL_OK)
d132 1
d135 1
a135 1

d171 6
a176 3
      argp = (void *) (int) *(Tcl_GetStringFromObj (objv[0], NULL));
      objc--;
      objv++;
d179 3
d186 1
a186 1
  return map_arg_registers (objc, objv, func, argp);
d196 49
a244 17
/* This implements the tcl command get_pc_reg
 * It returns the value of the PC register
 *
 * Tcl Arguments:
 *    None
 * Tcl Result:
 *    The value of the pc register.
 */
static int
get_pc_register (ClientData clientData, Tcl_Interp *interp,
		 int objc, Tcl_Obj *CONST objv[])
{
  char *buff;
  xasprintf (&buff, "0x%s", paddr_nz (read_register (PC_REGNUM)));
  Tcl_SetStringObj (result_ptr->obj_ptr, buff, -1);
  free(buff);
  return TCL_OK;
d247 1
d249 1
a249 1
get_register (int regnum, void *fp)
d254 14
a267 2
  int format = (int) fp;
  int optim;
d269 8
a276 2
  if (format == 'N')
    format = 0;
a287 2

  reg_vtype = REGISTER_VIRTUAL_TYPE (regnum);
d296 3
d301 1
d309 1
a309 1
	  register int idx = TARGET_BYTE_ORDER == BFD_ENDIAN_BIG ? j
d314 14
a327 1
      fputs_filtered (buf, gdb_stdout);
d329 5
d335 1
a335 9
    if ((TYPE_CODE (reg_vtype) == TYPE_CODE_UNION)
        && (strcmp (FIELD_NAME (TYPE_FIELD (reg_vtype, 0)), REGISTER_NAME (regnum)) == 0))
      {
        val_print (FIELD_TYPE (TYPE_FIELD (reg_vtype, 0)), virtual_buffer, 0, 0,
	           gdb_stdout, format, 1, 0, Val_pretty_default);
      }
    else
      val_print (REGISTER_VIRTUAL_TYPE (regnum), virtual_buffer, 0, 0,
	         gdb_stdout, format, 1, 0, Val_pretty_default);
d337 2
d368 2
a369 3
map_arg_registers (int objc, Tcl_Obj *CONST objv[],
		   void (*func) (int regnum, void *argp),
		   void *argp)
a380 3
  if (objc == 0 || objc > 1)
    result_ptr->flags |= GDBTK_MAKES_LIST;

d383 2
a384 3
      for (regnum = 0;
	   regnum < numregs;
	   regnum++)
a388 1
	  
d390 1
a390 2
	}
      
d394 7
d410 1
a410 2
      if (regnum >= 0
	  && regnum < numregs
a419 1

d446 20
a465 2
  if (old_regs != NULL)
    xfree (old_regs);
d467 22
a488 2
  old_regs = xmalloc ((NUM_REGS + NUM_PSEUDO_REGS) * MAX_REGISTER_RAW_SIZE + 1);
  memset (old_regs, 0, sizeof  (old_regs));
a489 1

@


1.8
log
@* defs.h (read_relative_register_raw_bytes): Delete declaration.
* frame.c (frame_register_read): New function.  Return non-zero on
success.
(read_relative_register_raw_bytes_for_frame): Delete.
(read_relative_register_raw_bytes): Delete.
* frame.h (frame_register_read): Declare.
* d30v-tdep.c: Update Copyright.  Use frame_register_read.
* sh-tdep.c: Ditto.
* infcmd.c (do_registers_info): Ditto.
* hppa-tdep.c: Ditto.
* rs6000-tdep.c: Ditto.
* h8500-tdep.c: Ditto.
* mips-tdep.c: Ditto.
* h8300-tdep.c: Ditto.
* z8k-tdep.c: Ditto.
@
text
@d207 2
a208 2
  char raw_buffer[MAX_REGISTER_RAW_SIZE];
  char virtual_buffer[MAX_REGISTER_VIRTUAL_SIZE];
d351 1
a351 1
  char raw_buffer[MAX_REGISTER_RAW_SIZE];
@


1.7
log
@	* generic/gdbtk-register.c (register_changed_p): Don't use REGISTER_BYTES.
	There is no guarantee anymore that REGISTER_BYTES contains
	NUM_REGS+NUM_PSEUDO_REGS registers.
	(setup_architecture_data): Likewise.
@
text
@a214 4
  /* read_relative_register_raw_bytes returns a virtual frame pointer
     (FRAME_FP (selected_frame)) if regnum == FP_REGNUM instead
     of the real contents of the register. To get around this,
     use get_saved_register instead. */
d353 1
a353 1
  if (read_relative_register_raw_bytes (regnum, raw_buffer))
@


1.6
log
@2002-02-06  Martin M. Hunt  <hunt@@redhat.com>

	* generic/gdbtk.c, generic/gdbtk-bp.c, generic/gdbtk-cmds.c,
	generic/gdbtk-hooks.c, generic/gdbtk-register.c,
	generic/gdbtk-stack.c, generic/gdbtk-varobj.c,
	generic/gdbtk-wrapper.c: Cleanup. Fix indentation. Fix
	function declarations. Remove unused variables. Add 2002
	copyrights.
@
text
@d31 3
a33 1
   gdb_changed_register_list.  */
d360 1
a360 1
  if (memcmp (&old_regs[REGISTER_BYTE (regnum)], raw_buffer,
d366 1
a366 1
  memcpy (&old_regs[REGISTER_BYTE (regnum)], raw_buffer,
a374 1
  /* don't trust REGISTER_BYTES to be zero. */
d378 2
a379 2
  old_regs = xmalloc (REGISTER_BYTES + 1);
  memset (old_regs, 0, REGISTER_BYTES + 1);
@


1.5
log
@s/BIG_ENDIAN/BFD_ENDIAN_BIG/
@
text
@d2 1
a2 1
   Copyright 2001 Free Software Foundation, Inc.
d110 1
a110 1
  int regnum, index, result;
d191 2
a192 5
get_pc_register (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
a194 1

d202 1
a202 3
get_register (regnum, fp)
     int regnum;
     void *fp;
d247 1
a247 1
	  : REGISTER_RAW_SIZE (regnum) - 1 - j;
d267 1
a267 3
get_register_name (regnum, argp)
     int regnum;
     void *argp;
d293 3
a295 5
map_arg_registers (objc, objv, func, argp)
     int objc;
     Tcl_Obj *CONST objv[];
     void (*func) (int regnum, void *argp);
     void *argp;
d351 1
a351 3
register_changed_p (regnum, argp)
     int regnum;
     void *argp;		/* Ignored */
@


1.4
log
@	* generic/gdbtk-register.c (gdb_register_info): New function.
	Consolidates all register handling.
	(get_register_size): New function.
	(gdb_changed_register_list, gdb_fetch_registers,
	gdb_regnames): Deprecate.
	(setup_architecture_data): Free old register cache
	when necessary.
@
text
@d252 1
a252 1
	  register int idx = TARGET_BYTE_ORDER == BIG_ENDIAN ? j
@


1.3
log
@2001-07-31  Elena Zannoni  <ezannoni@@redhat.com>

	* generic/gdbtk-cmds.c: Don't include regcache.h.
	* generic/gdbtk-register.c: Include regcache.h.
@
text
@d33 1
a33 1
static char *old_regs;
a34 5
static int gdb_changed_register_list (ClientData, Tcl_Interp *, int,
				      Tcl_Obj * CONST[]);
static int gdb_fetch_registers (ClientData, Tcl_Interp *, int,
				Tcl_Obj * CONST[]);
static int gdb_regnames (ClientData, Tcl_Interp *, int, Tcl_Obj * CONST[]);
d36 1
d39 1
d48 2
a49 6
  Tcl_CreateObjCommand (interp, "gdb_changed_register_list", gdbtk_call_wrapper,
			gdb_changed_register_list, NULL);
  Tcl_CreateObjCommand (interp, "gdb_fetch_registers", gdbtk_call_wrapper,
			gdb_fetch_registers, NULL);
  Tcl_CreateObjCommand (interp, "gdb_regnames", gdbtk_call_wrapper, gdb_regnames,
			NULL);
d61 2
a62 4
/* This implements the tcl command "gdb_changed_register_list"
 * It takes a list of registers, and returns a list of
 * the registers on that list that have changed since the last
 * time the proc was called.
d65 3
a67 1
 *    A list of registers.
d69 33
a101 18
 *    A list of changed registers.
 */
static int
gdb_changed_register_list (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
{
  objc--;
  objv++;

  return map_arg_registers (objc, objv, register_changed_p, NULL);
}

/* This implements the tcl command gdb_fetch_registers
 * Pass it a list of register names, and it will
 * return their values as a list.
d103 2
a104 5
 * Tcl Arguments:
 *    format: The format string for printing the values
 *    args: the registers to look for
 * Tcl Result:
 *    A list of their values.
d107 2
a108 5
gdb_fetch_registers (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
d110 5
a114 1
  int format, result;
d118 1
a118 1
      Tcl_WrongNumArgs (interp, 1, objv, "format ?register1 register2 ...?");
d121 8
d130 1
a130 9
  objv++;
  format = *(Tcl_GetStringFromObj (objv[0], NULL));
  objv++;

  if (objc != 1)
    result_ptr->flags |= GDBTK_MAKES_LIST;    /* Output the results as a list */
  result = map_arg_registers (objc, objv, get_register, (void *) format);
  if (objc != 1)
    result_ptr->flags &= ~GDBTK_MAKES_LIST;
d132 6
a137 2
  return result;
}
d139 12
a150 1
/* This implements the TCL command `gdb_regnames'.  Its syntax is:
d152 3
a154 1
   gdb_regnames [-numbers] [REGNUM ...]
d156 11
a166 21
   Return a list containing the names of the registers whose numbers
   are given by REGNUM ... .  If no register numbers are given, return
   all the registers' names.

   Note that some processors have gaps in the register numberings:
   even if there is no register numbered N, there may still be a
   register numbered N+1.  So if you call gdb_regnames with no
   arguments, you can't assume that the N'th element of the result is
   register number N.

   Given the -numbers option, gdb_regnames returns, not a list of names,
   but a list of pairs {NAME NUMBER}, where NAME is the register name,
   and NUMBER is its number.  */
static int
gdb_regnames (clientData, interp, objc, objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
{
  int numbers = 0;
d168 3
a170 2
  objc--;
  objv++;
d172 2
a173 10
  if (objc >= 1)
    {
      char *s = Tcl_GetStringFromObj (objv[0], NULL);
      if (STREQ (s, "-numbers"))
	{
	  numbers = 1;
	  objc--;
	  objv++;
	}
    }
d175 5
a179 1
  return map_arg_registers (objc, objv, get_register_name, &numbers);
d199 1
a199 1
  xasprintf (&buff, "0x%llx", (long long) read_register (PC_REGNUM));
d278 1
a278 1
  int numbers = * (int *) argp;
d316 4
a319 1
  
d386 3
@


1.2
log
@2001-07-20  Martin M. Hunt  <hunt@@redhat.com>

	* generic/gdbtk-register.c (gdb_regnames): Fix 'if'
	statement so count is decremented only if "-numbers"
	is the first arg.
@
text
@d23 1
@


1.2.2.1
log
@Include "regcache.h".
@
text
@a23 1
#include "regcache.h"
@


1.1
log
@	* generic/gdbtk-cmds.c: Put on diet. All breakpoint-,
	tracepoint-, register-, and stack-related functions moved
	into separate files.
	(call_wrapper): Renamed to "gdbtk_call_wrapper" and export.
	Update all callers.
	* generic/gdbtk.h: Move all breakpoint-related stuff into
	gdbtk-bp.c.
	Remove declaration for "call_wrapper". Now in gdbtk-cmds.h
	(and called "gdbtk_call_wrapper").
	* generic/gdbtk-varobj.c: Include "gdbtk-cmds.h".
	* generic/gdbtk-cmds.h: New file.
	* generic/gdbtk-bp.c: New file.
	* generic/gdbtk-register.c: New file.
	* generic/gdbtk-stack.c: New file.
@
text
@d161 5
a165 3
	numbers = 1;
      objc--;
      objv++;
@

