head	1.47;
access;
symbols
	insight_7_6-2013-04-10-branchpoint:1.47
	gdb_7_6-branch:1.47.0.6
	gdb_7_5-branch:1.47.0.4
	gdb_7_4-branch:1.47.0.2
	gdb_7_3-branch:1.46.0.4
	gdb_7_1-branch:1.46.0.2
	gdb_7_0-branch:1.44.0.2
	arc-sim-20090309:1.43
	arc-insight_6_8-branch:1.43.0.6
	arc-insight_6_8-branchpoint:1.43
	insight_6_8-branch:1.43.0.4
	insight_6_8-branchpoint:1.43
	gdb_6_8-branch:1.43.0.2
	insight_6_6-20070208-release:1.42
	gdb_6_6-branch:1.42.0.4
	gdb_6_6-2006-11-15-branchpoint:1.42
	insight_6_5-20061003-release:1.42
	gdb_6_5-branch:1.42.0.2
	gdb_6_5-2006-05-14-branchpoint:1.42
	gdb-csl-gxxpro-6_3-branch:1.41.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.41
	gdb_6_4-branch:1.41.0.6
	gdb_6_4-2005-11-01-branchpoint:1.41
	gdb_6_1-2004-04-05-release:1.41
	gdb_6_1-branch:1.41.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.41
	gdb_6_0-2003-10-04-release:1.41
	gdb_6_0-branch:1.41.0.2
	gdb_6_0-2003-06-23-branchpoint:1.41
	gdb_5_3-2002-12-12-release:1.35
	gdb_5_3-branch:1.35.0.2
	gdb_5_3-2002-09-04-branchpoint:1.35
	gdb_5_2_1-2002-07-23-release:1.31
	gdb_5_2-2002-04-29-release:1.31
	gdb_5_2-branch:1.31.0.2
	gdb_5_2-2002-03-03-branchpoint:1.31
	gdb_5_1_1-2002-01-24-release:1.26
	cygnus_cvs_20020108_pre:1.29
	gdb_5_1_0_1-2002-01-03-branch:1.26.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.26
	gdb_5_1-2001-11-21-release:1.26
	gdb_s390-2001-09-26-branch:1.26.0.6
	gdb_s390-2001-09-26-branchpoint:1.26
	gdb_5_1-2001-07-29-branch:1.26.0.4
	gdb_5_1-2001-07-29-branchpoint:1.26
	dberlin-typesystem-branch:1.26.0.2
	dberlin-typesystem-branchpoint:1.26
	insight-precleanup-2001-01-01:1.17
	gdb_5_0-2000-05-19-release:1.3
	gdb_4_18_2-2000-05-18-release:1.3
	gdb_4_95_1-2000-05-11-snapshot:1.3
	gdb_4_95_0-2000-04-27-snapshot:1.3
	gdb_5_0-2000-04-10-branch:1.3.0.2
	gdb_5_0-2000-04-10-branchpoint:1.3
	repo-unification-2000-02-06:1.1.1.1
	insight-2000-02-04:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.47
date	2012.02.28.17.32.30;	author kseitz;	state Exp;
branches;
next	1.46;

1.46
date	2009.11.09.19.39.31;	author kseitz;	state Exp;
branches;
next	1.45;

1.45
date	2009.10.09.02.51.47;	author kseitz;	state Exp;
branches;
next	1.44;

1.44
date	2008.12.16.09.07.57;	author denis;	state Exp;
branches;
next	1.43;

1.43
date	2008.02.09.01.23.42;	author kseitz;	state Exp;
branches;
next	1.42;

1.42
date	2005.12.23.18.26.50;	author eliz;	state Exp;
branches;
next	1.41;

1.41
date	2003.03.06.04.34.51;	author hunt;	state Exp;
branches;
next	1.40;

1.40
date	2002.11.11.23.22.22;	author hunt;	state Exp;
branches;
next	1.39;

1.39
date	2002.11.08.05.25.20;	author hunt;	state Exp;
branches;
next	1.38;

1.38
date	2002.10.15.21.19.51;	author hunt;	state Exp;
branches;
next	1.37;

1.37
date	2002.09.24.22.24.20;	author hunt;	state Exp;
branches;
next	1.36;

1.36
date	2002.09.20.06.12.28;	author hunt;	state Exp;
branches;
next	1.35;

1.35
date	2002.06.07.09.22.44;	author hunt;	state Exp;
branches;
next	1.34;

1.34
date	2002.03.07.21.53.39;	author hunt;	state Exp;
branches;
next	1.33;

1.33
date	2002.03.07.20.22.42;	author hunt;	state Exp;
branches;
next	1.32;

1.32
date	2002.03.05.22.22.20;	author hunt;	state Exp;
branches;
next	1.31;

1.31
date	2002.01.15.19.52.01;	author kseitz;	state Exp;
branches;
next	1.30;

1.30
date	2002.01.11.23.28.20;	author hunt;	state Exp;
branches;
next	1.29;

1.29
date	2002.01.03.21.13.03;	author hunt;	state Exp;
branches;
next	1.28;

1.28
date	2001.10.04.15.01.36;	author tromey;	state Exp;
branches;
next	1.27;

1.27
date	2001.08.20.17.55.32;	author kseitz;	state Exp;
branches;
next	1.26;

1.26
date	2001.06.11.23.08.05;	author tromey;	state Exp;
branches;
next	1.25;

1.25
date	2001.05.22.18.24.18;	author kseitz;	state Exp;
branches;
next	1.24;

1.24
date	2001.04.20.18.47.33;	author kseitz;	state Exp;
branches;
next	1.23;

1.23
date	2001.04.19.22.51.02;	author kseitz;	state Exp;
branches;
next	1.22;

1.22
date	2001.03.01.12.30.41;	author nsd;	state Exp;
branches;
next	1.21;

1.21
date	2001.02.07.01.11.18;	author fnasser;	state Exp;
branches;
next	1.20;

1.20
date	2001.01.19.16.09.10;	author fnasser;	state Exp;
branches;
next	1.19;

1.19
date	2001.01.18.22.37.19;	author fnasser;	state Exp;
branches;
next	1.18;

1.18
date	2001.01.17.23.45.06;	author fnasser;	state Exp;
branches;
next	1.17;

1.17
date	2000.12.07.21.56.25;	author tromey;	state Exp;
branches;
next	1.16;

1.16
date	2000.12.07.20.14.02;	author tromey;	state Exp;
branches;
next	1.15;

1.15
date	2000.12.07.20.04.52;	author tromey;	state Exp;
branches;
next	1.14;

1.14
date	2000.12.01.06.37.57;	author tromey;	state Exp;
branches;
next	1.13;

1.13
date	2000.11.30.22.49.46;	author tromey;	state Exp;
branches;
next	1.12;

1.12
date	2000.11.30.22.37.29;	author tromey;	state Exp;
branches;
next	1.11;

1.11
date	2000.10.11.22.37.30;	author fnasser;	state Exp;
branches;
next	1.10;

1.10
date	2000.10.04.20.35.32;	author fnasser;	state Exp;
branches;
next	1.9;

1.9
date	2000.10.04.20.22.17;	author fnasser;	state Exp;
branches;
next	1.8;

1.8
date	2000.08.10.15.55.06;	author fnasser;	state Exp;
branches;
next	1.7;

1.7
date	2000.08.08.22.24.26;	author fnasser;	state Exp;
branches;
next	1.6;

1.6
date	2000.08.08.22.14.16;	author fnasser;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.27.16.46.12;	author jingham;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.14.14.45.37;	author tromey;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.10.18.53.05;	author ezannoni;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.24.03.12.58;	author kseitz;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.07.00.19.42;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.07.00.19.42;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.47
log
@	From Jeffrey Armstrong  <jeffrey.armstrong@@approximatrix.com>:
	* library/srctextwin.itb (lookup_line): Quote the filename
	to gdb_set_bp.
@
text
@# Paned text widget for source code, for Insight
# Copyright (C) 1997, 1998, 1999, 2001, 2002, 2008, 2009 Red Hat, Inc.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License (GPL) as published by
# the Free Software Foundation; either version 2 of the License, or (at
# your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.


# ----------------------------------------------------------------------
# Implements the paned text widget with the source code in it.
# This widget is typically embedded in a SrcWin widget.
#
# ----------------------------------------------------------------------

# ------------------------------------------------------------------
#  CONSTRUCTOR - create new source text window
# ------------------------------------------------------------------
itcl::body SrcTextWin::constructor {args} {
  eval itk_initialize $args
  set top [winfo toplevel $itk_interior]
  if {$parent == {}} {
    set parent [winfo parent $itk_interior]
  }

  if {![info exists break_images(bp)]} {
    set size [font measure [pref get gdb/src/font] "W"]
    set break_images(bp)          [makeBreakDot $size \
				     [pref get gdb/src/bp_fg]]
    set break_images(temp_bp)     [makeBreakDot $size \
				     [pref get gdb/src/temp_bp_fg]]
    set break_images(disabled_bp) [makeBreakDot $size \
				     [pref get gdb/src/disabled_fg]]
    set break_images(tp)          [makeBreakDot $size \
				     [pref get gdb/src/trace_fg]]
    set break_images(thread_bp)   [makeBreakDot $size \
				     [pref get gdb/src/thread_fg]]
    set break_images(bp_and_tp)   [makeBreakDot $size \
				     [list [pref get gdb/src/trace_fg] \
					[pref get gdb/src/bp_fg]]] 
  }

  if {$ignore_var_balloons} {
    set UseVariableBalloons 0
  } else {
    set UseVariableBalloons [pref get gdb/src/variableBalloons]
  }
  
  set Linenums [pref get gdb/src/linenums]
  
  #Initialize state variables
  _initialize_srctextwin

  build_popups  
  build_win
  
  # add hooks
  if {$Tracing} {
    add_hook control_mode_hook "$this set_control_mode"
    add_hook gdb_trace_find_hook "$this trace_find_hook"
  }
  
  if {$UseVariableBalloons} {
    add_hook gdb_idle_hook "$this updateBalloon"
  }
  global ${this}_balloon
  trace variable ${this}_balloon w "$this trace_help"

}

# ------------------------------------------------------------------
#  DESTRUCTOR - destroy window containing widget
# ------------------------------------------------------------------
itcl::body SrcTextWin::destructor {} {
  if {$Tracing} {
    remove_hook control_mode_hook "$this set_control_mode"
  }
  if {$UseVariableBalloons} {
    remove_hook gdb_idle_hook "$this updateBalloon"
  }
}

# ------------------------------------------------------------------
#  METHOD:  trace_find_hook - response to the tfind command.  All we
#  need to do here is to remove the trace tags, if we are exiting
#  trace mode
# ------------------------------------------------------------------
itcl::body SrcTextWin::trace_find_hook {mode from_tty} {
  if {[string compare $mode -1] == 0} {
    if {$Browsing} {
      $twin tag remove STACK_TAG 1.0 end
    }
  } 
}

# ------------------------------------------------------------------
#  METHOD:  set_control_mode- switches the src window between 
#           browsing -> mode = 1
#           controlling -> mode = 0
# ------------------------------------------------------------------
itcl::body SrcTextWin::set_control_mode {mode} {
#  debug "Setting control mode of $twin to $mode"
  if {$mode} {
    set Browsing 1
  } else {
    set Browsing 0
  }
  
  switch $current(mode) {
    SOURCE {
      config_win $twin
    }
    ASSEMBLY {
      config_win $twin A
    }
    MIXED {
      config_win $twin M
    }
    SRC+ASM {
      config_win $twin
      config_win $bwin A
    }
  }      
  
}

# ------------------------------------------------------------------
#  METHOD:  build_popups - build the popups for the source window(s)
# ------------------------------------------------------------------
#
# The popups array holds the data for the breakpoint & tracepoint popup menus.
# The elements are:
# Menus:
#   break_rgn - the popup for clicking in a bare break region
#   bp        - the popup for clicking on a set breakpoint
#   tp        - the popup for clicking on a set tracepoint
#   bp_and_tp - the popup for clicking on the break_region when the
#               line contains both a bp & a tp
#   source    - the popup for clicking on the source region of the window
#
# State:
#    saved_y  - the y value of the mouse click that posted the popup
#    saved_win- the Tk window which recieved the posting click
# 
# Disable info:
#    run_disabled - a list of {menu entry} pairs for all the menus that
#                   should be disabled when you are not running
#    browse_disabled - a similar list for menus that should be disabled
#                      when you are browsing a trace expt.
#
itcl::body SrcTextWin::build_popups {} {
  
  set popups(bp) $itk_interior.bp_menu
  set popups(tp) $itk_interior.tp_menu
  set popups(bp_and_tp) $itk_interior.tp_bp_menu
  set popups(tp_browse) $itk_interior.tp_browse_menu
  set popups(break_rgn) $itk_interior.break_menu
  set popups(source) $itk_interior.src_menu
  set popups(disabled_bp) $itk_interior.disabled_bp_menu

  # This is a scratch popup menu we use when we are not over a bp...
  if {![winfo exists $popups(source)]} {
    menu $popups(source) -tearoff 0
  }
  
  if {![winfo exists $popups(break_rgn)]} {
    # breakpoint popup menu
    # don't enable hardware or conditional breakpoints until they are tested
    menu $popups(break_rgn) -tearoff 0
    
    set bp_fg [pref get gdb/src/bp_fg]
    set tp_fg [pref get gdb/src/trace_fg]
    
    if {[pref get gdb/control_target]} {
      
      addPopup break_rgn "Continue to Here" "$this continue_to_here" \
	[pref get gdb/src/PC_TAG] 0 0
      addPopup break_rgn "Jump to Here" "$this jump_to_here" \
	[pref get gdb/src/PC_TAG] 0 0
      $popups(break_rgn) add separator
      
      addPopup break_rgn "Set Breakpoint" "$this set_bp_at_line" $bp_fg 
      
      lappend popups(break_rgn-browse) 1
      lappend popups(break_rgn-control) 1
      
      addPopup break_rgn "Set Temporary Breakpoint" "$this set_bp_at_line T" \
	[pref get gdb/src/temp_bp_fg]
      
      addPopup break_rgn "Set Breakpoint on Thread(s)..." \
	"$this ask_thread_bp" [pref get gdb/src/thread_fg] 0 0
    }
    
    if {$Tracing} {
      $popups(break_rgn) add separator
      addPopup break_rgn "Set Tracepoint" "$this set_tp_at_line" $tp_fg
    }
    
  }
  
  if {![winfo exists $popups(bp)]} {
    # this popup is used when the line contains a set breakpoint
    menu $popups(bp) -tearoff 0
    
    if {!$Browsing && [pref get gdb/control_target]} {
      addPopup bp "Continue to Here" "$this continue_to_here" {} 0 0
      addPopup bp "Jump to Here" "$this jump_to_here" {} 0 0
      $popups(bp) add separator    

      addPopup bp "Disable Breakpoint" "$this enable_disable_at_line disable" \
	$bp_fg
      $popups(bp) add separator
    }
    
    addPopup bp "Delete Breakpoint" "$this remove_bp_at_line"

    # Currently you cannot set a tracepoint and a breakpoint at the same line...
    #
    #       if {$Tracing} {
    # 	addPopup bp "Set Tracepoint" "$this set_tp_at_line" $tp_fg
    #       }
  }

  if {![winfo exists $popups(tp)]} {
    # This is the popup to use when the line contains a set tracepoint
    
    menu $popups(tp) -tearoff 0
    
    if {[pref get gdb/control_target]} {
      
      addPopup tp "Continue to Here" "$this continue_to_here" green 0 0
      addPopup tp "Jump to Here" "$this jump_to_here" {} 0 0
      #	$popups(tp) add separator    

      # Currently you cannot set a tracepoint and a breakpoint at the same line...
      #      
      # 	addPopup tp "Set Breakpoint" "$this set_bp_at_line" $bp_fg

      # 	addPopup tp "Set Temporary Breakpoint" "$this set_bp_at_line T" \
	# 	  [pref get gdb/src/temp_bp_fg]
      
      # 	addPopup tp "Set Breakpoint on Thread(s)..." \
	# 	  "$this ask_thread_bp" \
	# 	  [pref get gdb/src/thread_fg] 0 0
    }
    
    if {$Tracing} {
      $popups(tp) add separator
      addPopup tp "Modify Tracepoint" "$this set_tp_at_line" $tp_fg
      addPopup tp "Delete Tracepoint" "$this remove_tp_at_line" $tp_fg
    }
  }
  
  # This is not currently used, since you can't set a bp & a tp on the same line.
  # N.B. however, we don't exclude this on the command line, but...

  if {![winfo exists $popups(bp_and_tp)]} {
    
    # this popup is used when the line contains a set breakpoint & tracepoint
    menu $popups(bp_and_tp) -tearoff 0
    
    if {!$Browsing && [pref get gdb/control_target]} {
      addPopup bp_and_tp "Continue to Here" "$this continue_to_here" \
	green 0 0
      addPopup bp_and_tp "Jump to Here" "$this jump_to_here" \
	green 0 0
      $popups(bp_and_tp) add separator    
    }

    addPopup bp_and_tp "Delete Breakpoint" "$this remove_bp_at_line" $bp_fg
    if {$Tracing} {
      addPopup bp_and_tp "Modify Tracepoint" "$this set_tp_at_line" $tp_fg
      addPopup bp_and_tp "Delete Tracepoint" \
	"$this remove_tp_at_line" $tp_fg
    }
  }

  if {![winfo exists $popups(disabled_bp)]} {
    menu $popups(disabled_bp) -tearoff 0

    addPopup disabled_bp "Enable Breakpoint" \
      "$this enable_disable_at_line enable" $bp_fg
    
    $popups(disabled_bp) add separator
    addPopup disabled_bp "Delete Breakpoint" "$this remove_bp_at_line"
  }

  if {![winfo exists $popups(tp_browse)]} {
    
    # this popup is on a tracepoint when browsing.
    
    menu $popups(tp_browse) -tearoff 0
    addPopup tp_browse "Next hit Here" "$this next_hit_at_line" \
      green
  }
}

# ------------------------------------------------------------------
#  METHOD:  build_win - build the main source paned window
# ------------------------------------------------------------------
itcl::body SrcTextWin::build_win {} {
  cyg::panedwindow $itk_interior.p

  set _tpane pane$filenum
  incr filenum
  
  $itk_interior.p add $_tpane
  set pane1 [$itk_interior.p childsite $_tpane]
  set Stwc(gdbtk_scratch_widget:pane) $_tpane
  set Stwc(gdbtk_scratch_widget:dirty) 0

  set twinp [iwidgets::scrolledtext $pane1.st \
	       -hscrollmode dynamic -vscrollmode dynamic]
  set twin [$twinp component text]
  pack $twinp -fill both -expand yes
  pack $itk_interior.p -fill both -expand yes
  config_win $twin
}

# ------------------------------------------------------------------
#  METHOD:  SetRunningState - set state based on if GDB is running or not.
#  This disables the popup menus when GDB is not running yet.
# ------------------------------------------------------------------
itcl::body SrcTextWin::SetRunningState {state} {
#  debug "$state"
  foreach elem $popups(run_disabled) {
    $popups([lindex $elem 0]) entryconfigure [lindex $elem 1] -state $state
  }
}

# ------------------------------------------------------------------
#  METHOD:  enable - enable or disable bindings and change cursor
# ------------------------------------------------------------------
itcl::body SrcTextWin::enable {on} {
  if {$on} {
    set Running 0
    set glyph ""
    set bnd ""
    set status normal
  } else {
    set Running 1
    set glyph watch
    set bnd "break"
    set status disabled
  }

  if {[winfo exists $twin]} {
    bind $twin <B1-Motion> $bnd
    bind $twin <Double-1> $bnd
    bind $twin <Triple-1> $bnd
    enable_disable_src_tags $twin $status
    $twin configure -cursor $glyph
  }

  if {$bwin != ""} {
    bind $bwin <B1-Motion> $bnd
    bind $bwin <Double-1> $bnd
    bind $bwin <Triple-1> $bnd
    enable_disable_src_tags $bwin $status
    $bwin configure -cursor $glyph
  }
}

# ------------------------------------------------------------------
# PROC:  makeBreakDot - make the break dot for the screen
# ------------------------------------------------------------------
itcl::body SrcTextWin::makeBreakDot {size colorList {image {}}} {
  if {$size > 32} {
    set size 32
  } elseif {$size < 1} {
    set size 1
  }

  if {$image == ""} {
    set image [image create photo -width $size -height $size]
  } else {
    $image blank
    $image configure -width $size -height $size
  }

  if {[llength $colorList] == 1} { 
    set x1 1
    set x2 [expr {1 + $size}]
    set y1 1
    set y2 $x2
    $image put $colorList -to 1 1 $x2 $y2
  } else {
    set x1 1
    set x3 [expr {1 + $size}]
    set x2 [expr int((1 + $size)/2)]
    set y1 1
    set y2 $x3
    $image put [lindex $colorList 0] -to 1 1 $x2 $y2
    $image put [lindex $colorList 1] -to [expr $x2 + 1] 1 $x3 $y2
  }
  
  return $image
}

# ------------------------------------------------------------------
# METHOD: setTabs - set the tabs for the assembly/src windows
# ------------------------------------------------------------------
itcl::body SrcTextWin::setTabs {win {asm S}} {
  set fsize [font measure [pref get gdb/src/font] "W"]
  set tsize [pref get gdb/src/tab_size]
  set rest ""
  
  if {[string compare $asm "S"] != 0} {
    set first  [expr {$fsize * 12}]
    set second [expr {$fsize * 13}]
    set third  [expr {$fsize * 34}]
    for {set i 1} {$i < 8} {incr i} {
      lappend rest [expr {(34 + ($i * $tsize)) * $fsize}] left
    }
    set tablist [concat [list $first right $second left $third left] $rest]
  } else {
    # SOURCE window
    # The first tab right-justifies the line numbers and the second
    # tab is the left margin for the start on the source code.  The remaining
    # tabs should be regularly spaced depending on prefs.
    if {$Linenums} {
      set first  [expr {$fsize * 6}]	;# "- " plus 4 digit line number
      set second [expr {$fsize * 7}]	;# plus a space after the number 
      for {set i 1} {$i < 8} {incr i} {
	lappend rest [expr {(7 + ($i * $tsize)) * $fsize}] left
      }
      set tablist [concat [list $first right $second left] $rest]
    } else {
      set first  [expr {$fsize * 2}]
      for {set i 1} {$i < 8} {incr i} {
	lappend rest [expr {(2 + ($i * $tsize)) * $fsize}] left
      }
      set tablist [concat [list $first left] $rest]
    }
  }
  $win configure -tabs $tablist
}

itcl::body SrcTextWin::enable_disable_src_tags {win how} {

  switch $how {
    normal {
      set cur1 dot
      set cur2 xterm
    }
    disabled {
      set cur1 watch
      set cur2 $cur1
    }
    browse {
      set cur1 dot
      set cur2 xterm
    }
  }

  if {[string compare $how browse] == 0} {
    
    $win tag bind break_rgn_tag <Enter> { }
    $win tag bind break_rgn_tag <Leave> { }
    
    foreach type $bp_types {
      $win tag bind ${type}_tag <Enter> { }
      $win tag bind ${type}_tag <Motion> { }
      $win tag bind ${type}_tag <Leave> { }
    }

  } else {
    
    $win tag bind break_rgn_tag <Enter> "$win config -cursor $cur1"
    $win tag bind break_rgn_tag <Leave> "$win config -cursor $cur2"
    
    foreach type $bp_types {
      $win tag bind ${type}_tag <Enter> "$win config -cursor $cur1"
      $win tag bind ${type}_tag <Motion> "$this motion bp %W %x %y"
      $win tag bind ${type}_tag <Leave> \
	"$this cancelMotion;$win config -cursor $cur2"
    }
  }

  $win tag bind tp_tag <Enter> "$win config -cursor $cur1"
  $win tag bind tp_tag <Motion> "$this motion bp %W %x %y"
  $win tag bind tp_tag <Leave> "$this cancelMotion;$win config -cursor $cur2"
}

# ------------------------------------------------------------------
#  METHOD:  config_win - configure the source or assembly text window
# ------------------------------------------------------------------
itcl::body SrcTextWin::config_win {win {asm S}} {
#  debug "$win $asm Tracing=$Tracing Browsing=$Browsing"
  
  $win config -borderwidth 2 -insertwidth 0 -wrap none
  
  # font
  set font [pref get gdb/src/font]
  $win configure -font $font -bg $::Colors(textbg) -fg $::Colors(textfg)
  
  setTabs $win $asm

  # set up some tags.  should probably be done differently
  # !! change bg?
  
  $win tag configure break_rgn_tag
  foreach type $bp_types {
    $win tag configure ${type}_tag 
  }
  $win tag configure tp_tag 
  $win tag configure source_tag2 -foreground [pref get gdb/src/source2_fg]
  $win tag configure PC_TAG -background [pref get gdb/src/PC_TAG]
  $win tag configure STACK_TAG -background [pref get gdb/src/STACK_TAG]
  $win tag configure BROWSE_TAG -background [pref get gdb/src/BROWSE_TAG]
  
  # search tag used to highlight searches
  foreach option [$win tag configure sel] {
    set op [lindex $option 0]
    set val [lindex $option 4]
    eval $win tag configure search $op $val
  }
  
  # bind mouse button 3 to the popup men
  $win tag bind source_tag <Button-3> "$this do_source_popup %X %Y %x %y"
  $win tag bind source_tag2 <Button-3> "$this do_source_popup %X %Y %x %y"
  
  # bind mouse button 3 to the popup menus
  if {!$Browsing} {
    
    $win tag bind break_rgn_tag <Button-3> \
      "$this do_tag_popup break_rgn %X %Y %y; break"
    foreach type $bp_types {
      if {$type == "disabled_bp"} then {
	set tag disabled_bp
      } else {
	set tag bp
      }
      $win tag bind ${type}_tag <Button-3> \
	"$this do_tag_popup $tag %X %Y %y; break"
    }
    $win tag bind tp_tag <Button-3> "$this do_tag_popup tp %X %Y %y; break"
    $win tag bind bp_and_tp_tag <Button-3> "$this do_tag_popup bp_and_tp %X %Y %y; break"
  } else {
    $win tag bind tp_tag <Button-3> "$this do_tag_popup tp_browse %X %Y %y; break"
    $win tag bind break_rgn_tag <Button-3> { }
    foreach type $bp_types {
      $win tag bind ${type}_tag <Button-3> { }
    }
    $win tag bind bp_and_tp_tag <Button-3> "$this do_tag_popup tp_browse %X %Y %y; break"
    
  }
  
  # Disable printing and cut and paste keys; makes the window readonly
  # We do this so we don't have to enable and disable the
  # text widget everytime we want to modify it.
  
  bind $win <Key> {if {"%A" != "{}"} {break}}
  bind $win <Delete> break
  bind $win <ButtonRelease-2> {break}
  
  # GDB key bindings
  # We need to explicitly ignore keys with the Alt modifier, since
  # otherwise they will interfere with selecting menus on Windows.
  
  if {!$Browsing && [pref get gdb/control_target]} {
    bind_plain_key $win c "$this do_key continue; break" 
    bind_plain_key $win r "$this do_key run; break"
    bind_plain_key $win f "$this do_key finish; break"
  } else {
    bind_plain_key $win n "$this do_key tfind_next; break"
    bind_plain_key $win p "$this do_key tfind_prev; break"
    bind_plain_key $win f "$this do_key tfind_start; break"
    bind_plain_key $win l "$this do_key tfind_line; break"
    bind_plain_key $win h "$this do_key tfind_tp; break"
  }
  bind_plain_key $win u "$this do_key up; break"
  bind_plain_key $win d "$this do_key down; break"
  bind_plain_key $win x "$this do_key quit; break"
  
  if {!$Browsing && [pref get gdb/control_target]} {
    if {[string compare $asm "S"] != 0} {
      bind_plain_key $win s "$this do_key stepi; break"
      bind_plain_key $win n "$this do_key nexti; break"
    } else {
      bind_plain_key $win s "$this do_key step; break"
      bind_plain_key $win n "$this do_key next; break"
    }
  }
  
  bind_plain_key $win Control-h "$this do_key thread_list; break"
  bind_plain_key $win Control-f "$this do_key browser; break"
  bind_plain_key $win Control-d "$this do_key download; break"
  bind_plain_key $win Control-p "$this do_key print"
  bind_plain_key $win Control-u "$this do_key debug; break"
  bind_plain_key $win Control-o [list $this do_key open]
  bind_plain_key $win Control-a [list $this do_key attach]
  bind_plain_key $win Control-w [code $this do_key close]

  if {!$Browsing && [pref get gdb/control_target]} {
    # Ctrl+F5 is another accelerator for Run
    bind_plain_key $win Control-F5 "$this do_key run"
  }
  
  bind_plain_key $win Control-F11 "$this do_key debug"
  bind_plain_key $win Alt-v "$win yview scroll -1 pages"
  bind_plain_key $win Control-v [format {
    %s yview scroll 1 pages
    break
  } $win]
  
  # bind mouse button 1 to the breakpoint method or tracepoint, 
  # depending on the settings of the B1_behavior setting.  We don't
  # have to bind to bp_and_tp because that will fall through to either
  # the tp or the bp tag.  We have to put in the break so that we don't
  # both remove & reinsert a BP when we have both a tp & a bp on the same line.
  # If we are browsing, then disable Button-1
  
  if {!$Browsing} {
    if {[pref get gdb/B1_behavior]} {
      $win tag bind break_rgn_tag <Button-1> "$this set_bp_at_line N $win %y; break"
      foreach type $bp_types {
	$win tag bind ${type}_tag <Button-1> "$this remove_bp_at_line $win %y; break"
      }
      $win tag bind tp_tag    <Button-1> "$this set_bp_at_line N $win %y; break"
    } else {
      $win tag bind break_rgn_tag <Button-1> "$this set_tp_at_line $win %y; break"
      foreach type $bp_types {
	$win tag bind ${type}_tag <Button-1> "$this set_tp_at_line $win %y; break"
      }
      $win tag bind tp_tag    <Button-1> "$this set_tp_at_line $win %y; break"
    }
  } else {
    $win tag bind break_rgn_tag <Button-1> { }
    foreach type $bp_types {
      $win tag bind ${type}_tag <Button-1> { }
    }
    $win tag bind tp_tag    <Button-1> { }      
  }
  
  
  # avoid special handling of double and triple clicks in break area
  bind $win <Double-1> [format {
    if {[lsearch [%s tag names @@%%x,%%y] break_rgn_tag] >= 0} {
      break
    }
  } $win $win]
  bind $win <Triple-1> [format {
    if {[lsearch [%s tag names @@%%x,%%y] break_rgn_tag] >= 0} {
      break
    }
  } $win $win]
  
  # bind window shortcuts
  bind_plain_key $win Control-s "$this do_key stack"
  bind_plain_key $win Control-r "$this do_key registers"
  bind_plain_key $win Control-m "$this do_key memory"
  bind_plain_key $win Control-t "$this do_key watch"
  bind_plain_key $win Control-l "$this do_key locals"
  bind_plain_key $win Control-k "$this do_key kod"
  if { !$Tracing } {
    bind_plain_key $win Control-b "$this do_key breakpoints"
  } else {
    bind_plain_key $win Control-t "$this do_key tracepoints"
    bind_plain_key $win Control-u "$this do_key tdump"
  }
  bind_plain_key $win Control-n "$this do_key console"
  
  if {$Browsing} {
    enable_disable_src_tags $win browse
  } else {
    enable_disable_src_tags $win normal
  }      
  
  if {$UseVariableBalloons} {
    $win tag bind source_tag <Motion> "$this motion var %W %x %y"
    $win tag bind source_tag <Leave> "$this cancelMotion"
  }
  
  # Up/Down arrow key bindings
  bind_plain_key $win Up [list %W yview scroll -1 units]
  bind_plain_key $win Down [list %W yview scroll +1 units]

  # After loading a new file, focus sometimes gets lost
  # so point it back to this window if it doesn't already
  # point elsewhere.
  if {[focus -displayof $win] == ""} {focus $win}
}

# ------------------------------------------------------------------
#  METHOD:  addPopup - adds a popup to one of the source popup menus
# ------------------------------------------------------------------
itcl::body SrcTextWin::addPopup {menu label command {abg {}} {browse 1} {run 1}} {
  
  if {$abg == ""} {
    $popups($menu) add command -label $label -command $command 
  } else {
    $popups($menu) add command -label $label -command $command \
      -activebackground $abg
  }
  
  set index [$popups($menu) index last]
  if {!$run} {
    lappend popups(run_disabled) [list $menu $index]
  }
  if {!$browse} {
    lappend popups(browse_disabled) [list $menu $index]
  }
  
}

# ------------------------------------------------------------------
#  PUBLIC METHOD:  set_variable - Handle changes in the gdb variables
#           changed through the "set" gdb command.
# ------------------------------------------------------------------
itcl::body SrcTextWin::set_variable {event} {
  set var [$event get variable]
  set val [$event get value]
  debug "Set hook got called with $var $val"
  switch $var {
    disassembly-flavor {
        disassembly_changed
    } 
  }   
}

# ------------------------------------------------------------------
#  METHOD:  disassembly_changed - The disassembly flavor has changed,
#           mark all the cached assembly windows dirty, and force the
#           visible window to be redisplayed.
# ------------------------------------------------------------------
itcl::body SrcTextWin::disassembly_changed {} {
  foreach name [array names Stwc *:pane] {
    debug "Looking at $name"
      set vals [split $name ,]
      if {([string compare [lindex $vals 1] "A"] == 0)
	  || ([string compare [lindex $vals 1] "M"] == 0)} {
	debug "Setting $name to dirty"
	set Stwc([lindex $vals 0]:dirty) 1
      }
  }

  if {[string compare $current(mode) "SOURCE"] != 0} {
    location $current(tag) $current(filename) $current(funcname) $current(line) \
      $current(addr) $pc(addr) $current(lib)
  }
}

# ------------------------------------------------------------------
#  METHOD:  reconfig - used when preferences change
# ------------------------------------------------------------------
itcl::body SrcTextWin::reconfig {} {
#  debug
  
  # Make sure we redo the break images when we reconfigure
  set size [font measure [pref get gdb/src/font] "W"]
  makeBreakDot $size [pref get gdb/src/bp_fg] $break_images(bp)
  makeBreakDot $size [pref get gdb/src/temp_bp_fg] $break_images(temp_bp)
  makeBreakDot $size [pref get gdb/src/disabled_fg] $break_images(disabled_bp)
  makeBreakDot $size [pref get gdb/src/trace_fg] $break_images(tp)
  makeBreakDot $size \
    [list [pref get gdb/src/trace_fg] [pref get gdb/src/bp_fg]] \
    $break_images(bp_and_tp)
  makeBreakDot $size [pref get gdb/src/thread_fg] $break_images(thread_bp)

  # Tags
  $twin tag configure PC_TAG -background [pref get gdb/src/PC_TAG]
  $twin tag configure STACK_TAG -background [pref get gdb/src/STACK_TAG]
  $twin tag configure BROWSE_TAG -background [pref get gdb/src/BROWSE_TAG]
  switch $current(mode) {
    SOURCE {
      setTabs $twin
    }
    SRC+ASM {
      setTabs $twin 
      setTabs $bwin A
    }
    default {
      setTabs $twin A
    }
  }
  
  # Variable Balloons
  if {$ignore_var_balloons} {
    set balloons 0
  } else {
    set balloons [pref get gdb/src/variableBalloons]
  }
  if {$UseVariableBalloons != $balloons} {
    set UseVariableBalloons $balloons
    if {$UseVariableBalloons} {
      $twin tag bind source_tag <Motion> "$this motion var %W %x %y"
      $twin tag bind source_tag <Leave> "$this cancelMotion"
      add_hook gdb_idle_hook [list $this updateBalloon]
    } else {
      cancelMotion
      $twin tag bind source_tag <Motion> {}
      $twin tag bind source_tag <Leave> {}
      $twin tag remove _show_variable 1.0 end 
      remove_hook gdb_idle_hook [list $this updateBalloon]
    }
  }

  # Tracing Hooks
  catch {remove_hook control_mode_hook "$this set_control_mode"}
  catch {remove_hook gdb_trace_find_hook "$this trace_find_hook"}
  if {$Tracing} {
    add_hook control_mode_hook "$this set_control_mode"
    add_hook gdb_trace_find_hook "$this trace_find_hook"
  }

  # Popup colors

  # need to rewrite because of the new addPopup function
  #    if {$Tracing} {
  #      $twin.bmenu entryconfigure 0 -activebackground [pref get gdb/src/trace_fg]
  #    } else {
  #      $twin.bmenu entryconfigure 0 -activebackground [pref get gdb/src/PC_TAG]
  #      $twin.bmenu entryconfigure 1 -activebackground [pref get gdb/src/bp_fg]
  #      $twin.bmenu entryconfigure 2 -activebackground \
    #	[pref get gdb/src/temp_bp_fg]
  #     $twin.bmenu entryconfigure 3 -activebackground \
    #	[pref get gdb/src/thread_fg]
  #    }
}

# ------------------------------------------------------------------
# METHOD: updateBalloon - we have gone idle, update the balloon
# ------------------------------------------------------------------
itcl::body SrcTextWin::updateBalloon {} {

    set err [catch {$_balloon_var update} changed]
    catch {$_balloon_var name} var

    if {!$err} {
      if {$changed != ""} {
	# The variable's value has changed, so update the
	# balloon with its new value
	balloon register $twin "$var=[balloon_value $_balloon_var]" _show_variable
      }
    }
  }

itcl::body SrcTextWin::balloon_value {variable} {

  catch {$variable value} value
  set value [string trim $value \ \r\t\n]

  # Insert the variable's type for things like ptrs, etc.
  catch {$variable type} type 
  if {$value == "{...}"} {
    set val "$type $value"
  } elseif {[regexp -- {0x([0-9a-fA-F]+) <[a-zA-Z_].*} $value str]} {
    set val $str
  } elseif {[string first * $type] != -1} {
    set val "($type) $value"
  } elseif {[string first \[ $type] != -1} {
    set val "$type"
  } else {
    set val "$value"
  }

  return $val
}

# ------------------------------------------------------------------
# METHOD: ClearTags - clear all tags
# ------------------------------------------------------------------
itcl::body SrcTextWin::ClearTags {} {
  foreach tag {PC_TAG BROWSE_TAG STACK_TAG} {
    catch {
      $twin tag remove $tag $current(line).2 $current(line).end
      $twin tag remove $tag $pc(line).2 $pc(line).end
      $twin tag remove $tag $current(asm_line).2 $current(asm_line).end
      if {$bwin != ""} {
	$bwin tag remove $tag $current(asm_line).2 $current(asm_line).end
      }
    }
  }
}

# ------------------------------------------------------------------
# METHOD: _mtime_changed - check if the modtime for a file
#                          has changed.
# ------------------------------------------------------------------
itcl::body SrcTextWin::_mtime_changed {filename} {
  global gdbtk_platform

  if [catch {gdb_find_file $filename} f] {
    set r 1
  } elseif {$f == ""} {
    set r 1
  } else {
    if {[string compare $gdbtk_platform(os) "cygwin"] == 0} {
      set f [ide_cygwin_path to_win32 $f]
    }
    if {[catch {file mtime $f} mtime]} {
      debug "Could not stat file \"$f\" - \"$mtime\""
      # The return code is not of much significance in this case
      return 1
    }
    if {![info exists Stwc($filename:mtime)]} {
      debug "no mtime. resetting to zero"
      set Stwc($filename:mtime) 0
    }
    # debug "Stwc($filename:mtime)=$Stwc($filename:mtime); mtime=$mtime"

    if {$mtime == $Stwc($filename:mtime)} {
      set r 0
    } else {
      set r 1
      set Stwc($filename:mtime) $mtime
      set Stwc($filename:dirty) 1
    }
  }

  return $r
}

# ------------------------------------------------------------------
# METHOD: FillSource - fill a window with source
# ------------------------------------------------------------------
itcl::body SrcTextWin::FillSource {w tagname filename funcname line addr pc_addr lib} {
  global gdb_running
  upvar ${w}win win

#  debug "$gdb_running $tagname line=$line pc(line)=$pc(line)"
#  debug "current(filename)=$current(filename) filename=$filename"

  if {$filename != ""} {
    # load new file if necessary
    set mtime [_mtime_changed $filename]
    if {[string compare $filename $current(filename)] != 0 \
	  || $mode_changed || $mtime} {
      if {![LoadFile $w $filename $lib $mtime]} {
	# failed to find source file
	dbug W "Changing to ASSEMBLY"
	
	# We have to update this data here (it is also done by the caller)
	# because we want to call mode, which calls mode_set, which calls
	# location using these values.
	set current(line) $line
	set current(tag) $tagname
	set current(addr) $addr
	set current(funcname) $funcname
	set current(filename) $filename
	set current(lib) $lib
	
	set oldmode SOURCE
	$parent mode "" ASSEMBLY
	return
      }
      if {$current(mode) != "SRC+ASM"} {
	# reset this flag in FillAssembly for SRC+ASM mode
	set mode_changed 0
      }
    }

#    debug "cf=$current(filename) pc=$pc(filename) filename=$filename"
    if {$current(filename) != ""} {
      if {$gdb_running && $pc(filename) == $filename} {
	# set the PC tag in this file
	$win tag add PC_TAG $pc(line).2 $pc(line).end
      }
      if {$tagname != "PC_TAG"} {
	if {$gdb_running && ($pc(filename) == $filename) \
	      && ($pc(line) == $line)} {
	  # if the tag is on the same line as the PC, set a PC tag
	  $win tag add PC_TAG $line.2 $line.end
	} else {
	  $win tag add $tagname $line.2 $line.end
	}
      }
      if {$pc(filename) == $filename && $line == 0} {
	# no line specified, so show line with PC
	display_line $win $pc(line)
      } else {
	display_line $win $line
      }
    }
    return
  }
  # no source; switch to assembly
  dbug W "no source file; switch to assembly"
  
  # We have to update this data here (it is also done by the caller)
  # because we want to call mode, which calls mode_set, which calls
  # location using these values.
  set current(line) $line
  set current(tag) $tagname
  set current(addr) $addr
  set current(funcname) $funcname
  set current(filename) $filename
  set current(lib) $lib

  set oldmode $current(mode)
  $parent mode "" ASSEMBLY
}

# ------------------------------------------------------------------
# METHOD: FillAssembly - fill a window with disassembled code
# ------------------------------------------------------------------
itcl::body SrcTextWin::FillAssembly {w tagname filename funcname line addr pc_addr lib} {
  global gdb_running
  upvar ${w}win win
  upvar _${w}pane pane
#  debug "$win $tagname $filename $funcname $line $addr $pc_addr"
#  debug "mode_changed=$mode_changed"
#  debug "funcname=$funcname"
#  debug "current(funcname)=$current(funcname)"
  if {$funcname == ""} {
    set oldpane $pane
    set pane $Stwc(gdbtk_scratch_widget:pane)
    set win [[$itk_interior.p childsite $pane].st component text]
    $win delete 0.0 end
    $win insert 0.0 "Select function name to disassemble"
    if {$oldpane != "" && $oldpane != $pane} {
      $itk_interior.p replace $oldpane $pane
    } else {
      $itk_interior.p show $pane
    }
    return
  } elseif {$funcname != $current(funcname) || $mode_changed
	    || ([info exists Stwc($addr:dirty)] && $Stwc($addr:dirty))} {
    set mode_changed 0
    set oldpane $pane
    set result [LoadFromCache $w $addr A $lib]
    if {$result == 1} {
      #debug "Disassembling at $addr"
      #debug "cf=$current(filename) name=$filename"
      if {[catch {gdb_load_disassembly $win nosource \
			     [scope _map] $Cname $addr} mess]} {
	# print some intelligent error message?
	dbug E "Disassemble failed: $mess"
	UnLoadFromCache $w $oldpane $addr A $lib
	set pane $Stwc(gdbtk_scratch_widget:pane)
	set win [[$itk_interior.p childsite $pane].st component text]
	$win delete 0.0 end
	$win insert 0.0 "$mess"
	if {$oldpane != "" && $oldpane != $pane} {
	  $itk_interior.p replace $oldpane $pane
	} else {
	  $itk_interior.p show $pane
	}
      } else {
        debug "address range is $mess"
      }
    } elseif {$result == 0} {
      debug "LoadFromCache returned 0"
    } else {
      # This branch should not ever happen.  In assembly mode, there
      # are no checks in LoadFromCache that can fail.
      debug "LoadFromCache returned -1"
    }
    set current(filename) $filename
    set do_display_breaks 1
  }
  
  # highlight proper line number
  _highlightAsmLine $win $addr $pc_addr $tagname $filename $funcname

  display_line $win $current(asm_line)
}


# ------------------------------------------------------------------
# METHOD: FillMixed - fill a window with mixed source and assembly
# ------------------------------------------------------------------
itcl::body SrcTextWin::FillMixed {w tagname filename funcname line addr pc_addr lib} {
  global gdb_running
  upvar ${w}win win
  upvar _${w}pane pane
#  debug "$win $tagname $filename $funcname $line $addr $pc_addr"  

  if {$funcname == ""} {
    set oldpane $pane
    set pane $Stwc(gdbtk_scratch_widget:pane)
    set win [[$itk_interior.p childsite $pane].st component text]
    $win delete 0.0 end
    $win insert 0.0 "Select function name to disassemble"
    if {$oldpane != ""} {
      $itk_interior.p replace $oldpane $pane
    } else {
      $itk_interior.p show $pane
    }
  } elseif {$funcname != $current(funcname) || $mode_changed
	    || ([info exists Stwc($funcname:dirty)] && $Stwc($funcname:dirty))} {
    set mode_changed 0
    set oldpane $pane
    if {[LoadFromCache $w $funcname M $lib]} {
      # debug "Disassembling at $addr"
      if {[catch {gdb_load_disassembly $win source \
			     [scope _map] $Cname $addr} mess] } {
	# print some intelligent error message
	dbug W "Disassemble Failed: $mess"
	UnLoadFromCache $w $oldpane $funcname M $lib
	set current(line) $line
	set current(tag) $tagname
	set current(addr) $addr
	set current(funcname) $funcname
	set current(filename) $filename
	set current(lib) $lib
	set oldmode MIXED
	$parent mode "" ASSEMBLY
	return
      } else {
        debug "address range is $mess"
      }
    }
    set current(filename) $filename
    # now set the breakpoints
    set do_display_breaks 1
  }

  # highlight proper line number
  _highlightAsmLine $win $addr $pc_addr $tagname $filename $funcname
  display_line $win $current(asm_line)
}

# ------------------------------------------------------------------
# METHOD: _highlightAsmLine - highlight the current execution line
#         in one of the assembly modes
# ------------------------------------------------------------------
itcl::body SrcTextWin::_highlightAsmLine {win addr pc_addr \
                                    tagname filename funcname} {
  global gdb_running

  # Some architectures allow multiple instructions in each asm source
  # line...
  if {[info exists _map($Cname,pc=$addr)]} {
    set current(asm_line) $_map($Cname,pc=$addr)
  } else {
    set x [gdb_incr_addr $current(addr) -2]
    if {[info exists _map($Cname,pc=$x)]} {
      set current(asm_line) $_map($Cname,pc=$x)
    }
  }

  # if current file has PC, highlight that too
  if {$gdb_running && $tagname != "PC_TAG" && $pc(filename) == $filename
      && $pc(func) == $funcname} {
    set pc(asm_line) $_map($Cname,pc=$pc_addr)
    $win tag add PC_TAG $pc(asm_line).2 $pc(asm_line).end
  }

  # don't set browse tag if it is at PC
  if {$pc_addr != $addr || $tagname == "PC_TAG"} {
    # HACK.  In STACK mode we usually want the previous instruction
    # but not when we are browsing a trace experiment.
    if {[string compare $tagname "STACK_TAG"] == 0 && !$Browsing} {
      incr current(asm_line) -1
    }
    $win tag add $tagname $current(asm_line).2 $current(asm_line).end
  }
}

# ------------------------------------------------------------------
# METHOD: set_tag - update tag to STACK without making other changes
# ------------------------------------------------------------------
itcl::body SrcTextWin::set_tag_to_stack {} {
  foreach window [list $twin $bwin] {
    if {$window == ""} then {
      continue
    }
    foreach {start end} [$window tag ranges PC_TAG] {
      $window tag remove PC_TAG $start $end
      $window tag add STACK_TAG $start $end
    }
  }
  set current(tag) STACK_TAG
}

# ------------------------------------------------------------------
# METHOD: location - display a location in a file
# ------------------------------------------------------------------
itcl::body SrcTextWin::location {tagname filename funcname line addr pc_addr lib} {
#  debug "$tagname $filename $line $addr $pc_addr,  mode=$current(mode) oldmode=$oldmode  cf=$current(filename) lib=$lib"
  
  ClearTags
  
   # It seems odd to do this as a string compare, but on the Alpha,
   # where ints are 32 bit but addresses are 64, a numerical compare
   # will overflow Tcl's ints.

  if {$tagname == "PC_TAG" && [string compare $addr $pc_addr] == 0} {
    set pc(filename) $filename
    set pc(line) $line
    set pc(addr) $addr
    set pc(func) $funcname
    set pc(lib)  $lib
  }
  
  if {$oldmode != "" \
	&& [string compare $filename $current(filename)] != 0} {

    if [catch {gdb_find_file $filename} fullname] {
      dbug W "$filename: $fullname"
      set fullname ""
    }

    if {$fullname != ""} {
      set tmp $oldmode
      set oldmode ""
      $parent mode "" $tmp 0
    }
  }
  
  set oldpane $_tpane

  switch $current(mode) {
    SOURCE {
      FillSource t $tagname $filename $funcname $line $addr $pc_addr $lib
    }
    ASSEMBLY {
      FillAssembly t $tagname $filename $funcname $line $addr $pc_addr $lib
    }
    MIXED {
      FillMixed t $tagname $filename $funcname $line $addr $pc_addr $lib
    }
    SRC+ASM {
      FillSource t $tagname $filename $funcname $line $addr $pc_addr $lib
      # This may seem redundant, but it is NOT.  FillSource can change
      # the mode from SOURCE to ASSEMBLY if sources were not found. If
      # this happens, then MIXED mode is pointless, so forget the bottom
      # pane.
      if {$current(mode) == "SRC+ASM"} {
	FillAssembly b $tagname $filename $funcname $line $addr $pc_addr $lib
      }
    }
  }

  # After switching panes, clear the previous pane's cursor so that it isn't
  # used as the default when no other cursors are set.
  if { "$oldpane" != "$_tpane" } {
    $twin configure -cursor ""
  }

  set current(line) $line
  set current(tag) $tagname
  set current(addr) $addr
  set current(funcname) $funcname
  set current(filename) $filename
  set current(lib) $lib
  if {$do_display_breaks} {
    display_breaks
    set do_display_breaks 0
  }
}

# ------------------------------------------------------------------
#  METHOD:  LoadFile - loads in a new source file
# ------------------------------------------------------------------
itcl::body SrcTextWin::LoadFile {w name lib mtime_changed} {
  debug "$name $current(filename) $current(mode)"
  upvar ${w}win win
  upvar _${w}pane pane

  set oldpane $pane
  set result [LoadFromCache $w $name "S" $lib]
  if {$result == -1} {
    # This is a source file we could not find the source for...
    return 0
  } elseif {$result == 1 || $mtime_changed} {
    $win delete 0.0 end
    debug "READING $name"
    if {[catch {gdb_loadfile $win $name $Linenums} msg]} {
      dbug W "Error opening $name:  $msg"
      #if {$msg != ""} {
      #  tk_messageBox -icon error -title "GDB" -type ok \
	#    -modal task -message $msg
      #}
      UnLoadFromCache $w $oldpane $name "" $lib
      return 0
    }
  }
  set current(filename) $name
  # Display all breaks/traces
  set do_display_breaks 1
  return 1
}

# ------------------------------------------------------------------
#  METHOD:  display_line - make sure a line is displayed and near the center
# ------------------------------------------------------------------

itcl::body SrcTextWin::display_line { win line } {
  ::update idletasks
  # keep line near center of display
  set pixHeight [winfo height $win]
  set topLine [lindex [split [$win index @@0,0] .] 0]
  set botLine [lindex [split [$win index @@0,${pixHeight}] .] 0]    
  set margin [expr {int(0.2*($botLine - $topLine))}]
  if {$line < [expr {$topLine + $margin}]} {
    set num [expr {($topLine - $botLine) / 2}]
  } elseif {$line > [expr {$botLine - $margin}]} {
    set num [expr {($botLine - $topLine) / 2}]
  } else {
    set num 0
  }
  $win yview scroll $num units
  $win see $line.0
}

# ------------------------------------------------------------------
# METHOD: display_breaks - insert all breakpoints and tracepoints
# uses current(filename) in SOURCE mode
# ------------------------------------------------------------------

itcl::body SrcTextWin::display_breaks {} {
#  debug
  
  # clear any previous breakpoints
  foreach type "$bp_types tp" {
    foreach {start stop} [$twin tag ranges ${type}_tag] {
      scan $start "%d." linenum
      removeBreakTag $twin $linenum ${type}_tag
    }
  }
  
  # now do second pane if it exists
  if {[info exists bwin]} {
    foreach type "$bp_types tp" {
      foreach {start stop} [$twin tag ranges ${type}_tag] {
	scan $start "%d." linenum
	removeBreakTag $twin $linenum ${type}_tag
      }
    }
  }
  
  # Display any existing breakpoints.
  foreach bpnum [gdb_get_breakpoint_list] {
    set info [gdb_get_breakpoint_info $bpnum]
    set addr [lindex $info 3]
    set line [lindex $info 2]
    set file [lindex $info 0]
    set type [lindex $info 6]
    set enabled [lindex $info 5]
    bp create $bpnum $addr $line $file $type $enabled
  }
  # Display any existing tracepoints.
  foreach bpnum [gdb_get_tracepoint_list] {
    set info [gdb_get_tracepoint_info $bpnum]
    set addr [lindex $info 3]
    set line [lindex $info 2]
    set file [lindex $info 0]
    bp create $bpnum $addr $line $file tracepoint
  }
}

# ------------------------------------------------------------------
# METHOD: insertBreakTag - insert the right amount of tag chars
#         into the text window WIN, at line linenum.
# ------------------------------------------------------------------
itcl::body SrcTextWin::insertBreakTag {win linenum tag} {
#  debug "$win $linenum $tag"
  
  # Get the tags at the current line.  
  
  # If there is a "break_rgn_tag", then there are currently no other
  # break/trace points at this line.  So replace the break_rgn_tag
  # with this tag.  Otherwise, add the new tag, and then the joint
  # tag.  We will query the length of the previous tag, so we don't have
  # to hard code it here.
  
  # Find the nearest executable line
  for {set i 0} {$i < $ExecutableLineLimit} {incr i} {
    if {[line_is_executable $win [expr {$linenum + $i}]]} {
      incr linenum $i
      break
    }
  }

  set tag_list [$win tag names $linenum.0]
  set img_name [string range $tag 0 [expr [string length $tag] - 5]]
  
  if {[lsearch $tag_list break_rgn_tag] != -1} {
    set stop [lindex [$win tag nextrange break_rgn_tag \
			$linenum.0 "$linenum.0 lineend"] 1]
    $win tag remove break_rgn_tag $linenum.0 "$linenum.0 lineend"
    $win delete $linenum.0

    # Strip the "_tag" off the end of the tag to get the image name.
    $win image create $linenum.0 -image $break_images($img_name)
    $win tag add $tag $linenum.0 $stop
  } else {
    set other_tag [lindex $tag_list \
		     [lsearch -glob $tag_list {*[bt]p_tag}]]
    if {$other_tag == ""} {
      set stop "$linenum.4"
    } else {
      set stop [lindex [$win tag nextrange $other_tag \
			  $linenum.0 "$linenum.0 lineend"] 1]
    }

    $win tag add $tag $linenum.0 $stop
    $win image configure $linenum.0 -image $break_images($img_name)

  }
}

# ------------------------------------------------------------------
# METHOD: removeBreakTag - remove a break tag (breakpoint or tracepoint)
#         from the given line.  If this is the last break tag on the 
#         line reinstall the break_rgn_tag
# ------------------------------------------------------------------
itcl::body SrcTextWin::removeBreakTag {win linenum tag } {
#  debug "$win $linenum $tag"

  set tag_list [$win tag names $linenum.0]

  if {[set pos [lsearch -exact $tag_list $tag]] == -1} {
    debug "Tried to remove non-existant tag $tag"
    return
  } else {
    set tag_list [lreplace $tag_list $pos $pos]
  }

  # Use the range of the removed tag for any insertions, so we don't
  # have to hard code it here.

  set stop [lindex [$win tag nextrange $tag \
		      $linenum.0 "$linenum.0 lineend"] 1]

  $win tag remove $tag $linenum.0 "$linenum.0 lineend"

  # Now check what other tags are on this line.  If there are both bp & tp
  # tags, also remove the joint tag, otherwise install the break_rgn_tag.

  switch -glob $tag {
    *bp_tag {
      set only_one_tag [expr [set next_tag_index \
				[lsearch -glob $tag_list tp_tag]] == -1]
    }
    tp_tag {
      # Got to find out what kind of tag is here...
      set only_one_tag [expr [set next_tag_index \
				[lsearch -glob $tag_list *bp_tag]] == -1]
    }
  }

  if {$only_one_tag} {
    catch {$win image configure $linenum.0 -image {}}
    $win delete $linenum.0
    $win insert $linenum.0 "-"
    $win tag add break_rgn_tag $linenum.0 $stop
  } else {
    set other_tag [lindex $tag_list $next_tag_index]
    set img_name [string range $other_tag 0 \
		    [expr [string length $other_tag] - 5]]
    $win image configure $linenum.0 -image $break_images($img_name)
    $win tag remove bp_and_tp_tag $linenum.0 "$linenum.0 lineend"
  }
}

# ------------------------------------------------------------------
#  PUBLIC METHOD:  breakpoint - Handle a breakpoint create, delete,
#                   or modify event from the backend.
# ------------------------------------------------------------------
itcl::body SrcTextWin::breakpoint {bp_event} {

  bp [$bp_event get action] [$bp_event get number] [$bp_event get address] \
    [$bp_event get line] [$bp_event get file] [$bp_event get disposition]  \
    [$bp_event get enabled] [$bp_event get thread]
}

# ------------------------------------------------------------------
#  PUBLIC METHOD:  tracepoint - Handle a tracepoint create, delete,
#                   modify event from the backend.
# ------------------------------------------------------------------
itcl::body SrcTextWin::tracepoint {tp_event} {

  bp [$tp_event get action] [$tp_event get number] [$tp_event get address] \
    [$tp_event get line] [$tp_event get file] tracepoint                   \
    [$tp_event get pass_count]
}

# ------------------------------------------------------------------
#  METHOD:  bp - set and remove breakpoints
#
#  if $addr is valid, the breakpoint will be set in the assembly or 
#  mixed window at that address.  If $line and $file are valid, 
#  a breakpoint will be set in the source window if appropriate.
# ------------------------------------------------------------------
itcl::body SrcTextWin::bp {action bpnum addr {linenum {}} {file {}} {type 0} {enabled 0}  {thread -1}} {
#  debug "$action addr=$addr line=$linenum file=$file type=$type current(filename)=$current(filename)"

  switch $current(mode) {
    SOURCE {
      if {[string compare $file $current(filename)] == 0 && $linenum != {}} {
	do_bp $twin $action $linenum $type $bpnum $enabled $thread 0
      }
    }

    SRC+ASM {
      if {$addr != {} && [info exists _map($Cname,pc=$addr)]} {
	do_bp $bwin $action $_map($Cname,pc=$addr) $type $bpnum \
	  $enabled $thread 1
      }
      if {[string compare $file $current(filename)] == 0 && $linenum != {}} {
	do_bp $twin $action $linenum $type $bpnum $enabled $thread 0
      }
    }

    ASSEMBLY {
      if {$addr != {} &&[info exists _map($Cname,pc=$addr)]} {
	do_bp $twin $action $_map($Cname,pc=$addr) $type $bpnum \
	  $enabled $thread 1
      }
    }

    MIXED {
      if {$addr != {} && [info exists _map($Cname,pc=$addr)]} {
	do_bp $twin $action $_map($Cname,pc=$addr) $type $bpnum \
	  $enabled $thread 1
      }
    }
  }
}

# ------------------------------------------------------------------
#  METHOD:  do_bp - bp helper function
# ------------------------------------------------------------------
itcl::body SrcTextWin::do_bp { win action linenum type bpnum enabled thread asm} {
#  debug "$action line=$linenum type=$type bpnum=$bpnum enabled=$enabled thread=$thread"

  if {$dont_change_appearance} {
    return
  }

  if {$action == "delete" && [string compare $type tracepoint] != 0} {
    # make sure there are no more breakpoints on
    # this line.
    if {!$asm} {
      set bps [gdb_find_bp_at_line $current(filename) $linenum]
    } else {
      if {[info exists _map($Cname,line=$linenum)]} {
	set bps [gdb_find_bp_at_addr $_map($Cname,line=$linenum)]
      } else {
	set bps {}
      }
    }
    if {[llength $bps] > 0} {
      foreach b $bps {
	if {$b != $bpnum} {
	  # OK we found another BP on this line.
	  # So we really just want to modify whats
	  # displayed on the line instead of deleting it.
	  # Also, for lack of a better solution, we will
	  # just display an image corresponding to the
	  # first found BP.  If you have a temporary and
	  # a perm BP on the same line, the image for the one 
	  # with the lower bpnum will be displayed.
	  set inf [gdb_get_breakpoint_info $b]
	  set action "modify"
	  set type [lindex $inf 6]
	  set bpnum $b
	  break
	}
      }
    }
  }

  if {[string compare $type "tracepoint"] == 0} {
    if {[string compare $action "delete"] != 0
	&& [lindex [gdb_get_tracepoint_info $bpnum] 4] == 0} {
      set type disabled_tracepoint
    }
  } else {
    if {$enabled == "0" } {
      set type disabled_bp
    } elseif {$thread != "-1"} {
      set type thread
    }
  }

  switch $type {
    donttouch {
      set tag_type bp_tag
      set remove_type disabled_bp_tag
    }
    delete {
      set tag_type temp_bp_tag
    }
    disabled_bp {
      set tag_type disabled_bp_tag
      set remove_type bp_tag
    }
    tracepoint {
      set tag_type tp_tag
      set remove_type disabled_tp_tag
    }
    disabled_tracepoint {
      set tag_type disabled_tp_tag
      set remove_type tp_tag
    }
    thread {
      set tag_type thread_bp_tag
    }
    default {
      dbug E "UNKNOWN BP TYPE action=\"$action\" type=\"$type\""
      $win insert $linenum.0 "X" bp_tag
      set tag_type bp_tag
    }
  }

  if {[string compare $action "delete"] == 0} {
    removeBreakTag $win $linenum $tag_type
  } else {
    if {[string compare $action "modify"] == 0 && $remove_type != ""} {
      removeBreakTag $win $linenum $remove_type
    }
    insertBreakTag $win $linenum $tag_type
  }
}


# ------------------------------------------------------------------
#  METHOD:  hasBP - see if a line number has a breakpoint set
# ------------------------------------------------------------------
itcl::body SrcTextWin::hasBP {win line} {
  if {$win == ""} {
    set win $popups(saved_win)
  }

  if {[lsearch -glob [$win tag names $line.0] *bp_tag] >= 0} {
    return 1
  }
  return 0
}

# ------------------------------------------------------------------
#  METHOD:  hasTP - see if a line number has a tracepoint set
# ------------------------------------------------------------------
itcl::body SrcTextWin::hasTP {win line} {
  if {$win == ""} {
    set win $popups(saved_win)
  }

  if {[lsearch -exact [$win tag names $line.0] tp_tag] == 1} {
    return 1
  }
  return 0
}

# ------------------------------------------------------------------
#  METHOD:  report_source_location
#    
#    This function reports the "current" location in the source
#    window, where current means what gdb_loc would return, if 
#    that point is actually visible in the window, or the middle
#    of the current window, if that point is not visible.
#
#  Return:
#    The gdb_loc result for the location found
# ------------------------------------------------------------------
itcl::body SrcTextWin::report_source_location {} {
  
  if {$current(filename) == ""} {
    error "No source file in window"
  }

  # Figure out if the return from gdb_loc is visible.

  set not_visible 1
  if {![catch {gdb_loc} loc_info]} {
    set loc_long_name [lindex $loc_info 2]
    set loc_line [lindex $loc_info 3]
#    debug "Got loc_info: \"$loc_info\" and filename $current(filename) long_name: $loc_long_name"
    if {[string compare $current(filename) $loc_long_name] != 0} {
      set not_visible 1
    } else {
      foreach {name line} [lookup_line $twin 1] {
	break
      }
      if {$line < $loc_line} {
	foreach {name line} [lookup_line $twin [winfo height $twin]] {
	  break
	}
	if {$line > $loc_line} {
	  set not_visible 0
	}
      }
    }
  } else {
    debug "gdb_loc returned $loc_info"
  }

  if {$not_visible} {
    set y [expr int([winfo height $twin] / 2)]
    foreach {name line addr type} [lookup_line $twin $y] {
      break
    }
    switch $type {
      src {
	return [gdb_loc $name:$addr]
      }
      asm {
	return [gdb_loc *$addr]
      }
    }
  } else {
    return $loc_info
  }
}

# ------------------------------------------------------------------
#  METHOD:  lookup_line - translated win & y position line info
#
#    If win is {}, or y is -1, then the saved values from the popup
#    array are used.
#
#  Return:
#    name - the fileName
#    line - the line number in the text widget
#    addr - the source line number, if in source mode, the
#           address if in assembly mode, and if in mixed mode,
#           the line if it is a source line, or the address if it
#           is an assembly line
#    type - src if it is a source line, asm if an assembly line.
#   set_cmd - for convenience, this is the command needed to set a 
#             breakpoint at this address.
# ------------------------------------------------------------------
itcl::body SrcTextWin::lookup_line {win y} {
  #debug "$win $y"
  if {$y == -1} {
    set y $popups(saved_y)
  }

  if {$win == {}} {
    set win $popups(saved_win)
  }

  scan [$win index @@0,$y] "%d." line
  set name [lindex [::file split $current(filename)] end]

  # If we are in the SOURCE window (either because the mode is SOURCE,
  # or SRC+ASM, and we are in the upper pane, then return the 
  if {([string compare $current(mode) SOURCE] == 0)
      || ([string compare $current(mode) SRC+ASM] == 0 
	  && [string compare $win $twin] == 0)} {
    set addr $line
    set type "src"
  } else {
    if {[info exists _map($Cname,line=$line)]} {
      set addr $_map($Cname,line=$line)
      set type "asm"
    } else { 
      # This is a source line in MIXED mode
      set line_contents [$win get $line.0 "$line.0 lineend"]
      #debug "Looking at line: $line contents: \"$line_contents\""
      regexp "^\t(\[0-9\]*)" $line_contents match srcline
      set addr $srcline
      set type "src"
    }
  }

  switch $type {
    asm {
      set set_cmd [list gdb_set_bp "*$addr"]
    }
    src {
      set set_cmd [list gdb_set_bp "\"$current(filename)\":$addr"]
    }
  }

  #debug "Lookup line returning [list $name $line $addr $type $set_cmd]"
  return [list $name $line $addr $type $set_cmd]
}

# ------------------------------------------------------------------
#  METHOD:  continue_to_here - Advance to the line pointed to by the
#  y coordinate in the window win.  If win is {} or y is -1, the values
#  saved in the popups array are used.  
#
#  The threads parameter is not currently used.
# ------------------------------------------------------------------
itcl::body SrcTextWin::continue_to_here {{win {}} {y -1} {threads -1}} {
  
  # Look up the line...  This foreach is an lassign...
  foreach {name line addr type set_cmd} [lookup_line $win $y] {
    break
  }

  set dont_change_appearance 1
  foreach i [gdb_get_breakpoint_list] {
    set enabled($i) [lindex [gdb_get_breakpoint_info $i] 5]
  }	    
  gdb_cmd "disable"
  eval $set_cmd temp $threads
  gdb_immediate "continue"
  gdb_cmd "enable"
  foreach i [gdb_get_breakpoint_list] {
    if {![info exists enabled($i)]} {
      gdb_cmd "delete $i"
    } elseif {!$enabled($i)} {
      gdb_cmd "disable $i"
    }
  }
  set dont_change_appearance 0
}

# ------------------------------------------------------------------
#  METHOD:  jump_to_here - Advance to the line pointed to by the
#  y coordinate in the window win.  If win is {} or y is -1, the values
#  saved in the popups array are used.  
#
#  The threads parameter is not currently used.
# ------------------------------------------------------------------
itcl::body SrcTextWin::jump_to_here {{win {}} {y -1} {threads -1}} {
  
  # Look up the line...  This foreach is an lassign...
  foreach {name line addr type set_cmd} [lookup_line $win $y] {
    break
  }

  # Unfortunately we cant set the pc to a linespec and we have to do a
  # trick with a temporary breakpoint and the jump command.
  # FIXME: Get the address from the linespec.
  # FIXME: Even in the case we do have an address, I was not able to just
  # change the PC and get things updated wright.  While I work on that,
  # I will use the temp breakpoint and jump trick for that case as well.
  
  set dont_change_appearance 1
  
  foreach i [gdb_get_breakpoint_list] {
    set enabled($i) [lindex [gdb_get_breakpoint_info $i] 5]
  }	    
  gdb_cmd "disable"
  
  if {$type == "asm"} {
    gdb_immediate "tbreak *$addr"
    gdb_immediate "jump *$addr"
  } else {
    eval $set_cmd temp $threads
    gdb_immediate "jump $name:$line"
  }
  gdb_cmd "enable"
  foreach i [gdb_get_breakpoint_list] {
    if {![info exists enabled($i)]} {
      gdb_cmd "delete $i"
    } elseif {!$enabled($i)} {
      gdb_cmd "disable $i"
    }
  }
  set dont_change_appearance 0
}

# ------------------------------------------------------------------
#  METHOD:  set_bp_at_line - called when an empty break tag is clicked on
#
# When "threads" is set it means to set a bp on each thread in the list.
# ------------------------------------------------------------------
itcl::body SrcTextWin::set_bp_at_line {{type N} {win {}} {y -1} {threads "-1"}} {
#  debug "$win $y $type $current(filename) Tracing=$Tracing"
  if {$Running} {return}
  
  # Look up the line...  This foreach is an lassign...

  foreach {name line addr addr_type set_cmd} [lookup_line $win $y] {
    break
  }

  foreach th $threads {    
    switch $type {
      N {
	if {[catch {eval $set_cmd normal $th} msg]} {
	  dbug W $msg
	}
      }
      T {
	if {[catch {eval $set_cmd temp $th} msg]} {
	  dbug W $msg
	}
      }
    }    
  }
}

# ------------------------------------------------------------------
#  METHOD:  enable_disable_at_line - Enable or disable breakpoint
# ------------------------------------------------------------------
itcl::body SrcTextWin::enable_disable_at_line {action} {
  if {$Running} {
    return
  }

  # FIXME: should this work on $bwin as well?  In that case we'd need
  # a `win' argument...

  set y $popups(saved_y)

  $twin tag remove _show_variable 1.0 end 
  set line [lindex [split [$twin index @@0,$y] .] 0]
  set bps ""

  switch $current(mode) {
    SRC+ASM {
    }
    ASSEMBLY {
      if {[info exists _map($Cname,line=$line)]} {
	set addr $_map($Cname,line=$line)
	set bps [gdb_find_bp_at_addr $addr]
      } else {
	return
      }
    }
    MIXED {
      if {[info exists _map($Cname,line=$line)]} {
	set addr $_map($Cname,line=$line)
	set bps [gdb_find_bp_at_addr $addr]
      } else {
	return
      }
    }
  }

  if {$bps == ""} {
    set bps [gdb_find_bp_at_line $current(filename) $line]
  }

  # ACTION is `enable' or `disable'
  gdb_cmd "$action $bps"
}

# ------------------------------------------------------------------
#  METHOD:  remove_bp_at_line - called when a bp tag is clicked on
#
# when "threads" is set it means to set a bp on each thread in the list.
# ------------------------------------------------------------------
itcl::body SrcTextWin::remove_bp_at_line {{win {}} {y -1}} {
  
  if {$Running} {return}
  
  # Look up the line...  This foreach is an lassign...

  foreach {name line addr type} [lookup_line $win $y] {
    break
  }

  # FIXME: if there are multiple bp/tp at a single line,
  # we will (right now) always take the first one we find...
  switch $type {
    src { set bps [gdb_find_bp_at_line $name $addr] }
    asm { set bps [gdb_find_bp_at_addr $addr] }
  }

  set number [lindex $bps 0]
  gdb_cmd "delete $number"
}


# ------------------------------------------------------------------
#  METHOD:  set_tp_at_line - called when an empty break region tag is clicked on
#
# when "threads" is set it means to set a bp on each thread in the list.
# ------------------------------------------------------------------
itcl::body SrcTextWin::set_tp_at_line {{win {}} {y -1}} {
#  debug "$win $y $current(filename) Tracing=$Tracing"

  if {$Running} {return}
  
  # Look up the line...  This foreach is an lassign...
  
  foreach {name line addr type} [lookup_line $win $y] {
    break
  }
  
  switch $type {
    src {
      after idle [list ManagedWin::open TraceDlg -File $name -Lines $addr]
    }
    asm {
      after idle [list ManagedWin::open TraceDlg -File $name -Addresses [list $addr]]
    }
  }
}

# ------------------------------------------------------------------
#  METHOD:  next_hit_at_line - Finds the next trace hit at the line
#           given by win & y...
#
# ------------------------------------------------------------------
itcl::body SrcTextWin::next_hit_at_line {{win {}} {y -1}} {
#  debug "$win $y $current(filename) Tracing=$Tracing"

  if {!$Browsing} {return}
  
  # Look up the line...  This foreach is an lassign...
  
  foreach {name line addr type} [lookup_line $win $y] {
    break
  }
  
  # If the line and the addr are the same, then the specification was
  # given by line.  Otherwise is was a memory address.

  switch $type {
    src {
      tfind_cmd "tfind line $name:$addr"
    }
    asm {
      tfind_cmd "tfind line *$addr"
    }
  }
  
}

# ------------------------------------------------------------------
#  METHOD:  remove_tp_at_line - called when a tp tag is clicked on
#
# when "threads" is set it means to set a bp on each thread in the list.
# ------------------------------------------------------------------
itcl::body SrcTextWin::remove_tp_at_line {{win {}} {y -1}} {
  
  if {$Running} {return}
  
  # Look up the line...  This foreach is an lassign...
  
  foreach {name line addr type} [lookup_line $win $y] {
    break
  }
  switch $type {
    src {
      set tp_num [gdb_tracepoint_exists $name:$addr]
    }
    asm {
      set tp_num [gdb_tracepoint_exists *$addr]
    }
  }
  
  if {$tp_num != -1} {
    if {[catch {gdb_cmd "delete tracepoints $tp_num"} errTxt]} {
      tk_messageBox -type error -message "Could not delete tracepoint number $tp_num
Error was: $errTxt"
    }
  } 

}

# ------------------------------------------------------------------
#  METHOD:  do_tag_popup - The tag bind function for breakpoint popups
# ------------------------------------------------------------------

itcl::body SrcTextWin::do_tag_popup {name X Y y} {

#  debug "$name $X $Y $y"

  if {$Running || [winfo ismapped $popups($name)]} { 
    return 
  }  

  set popups(saved_y) $y
  set popups(saved_win) [winfo containing -displayof $itk_interior $X $Y] 

  # Hide variable balloons before showing the popup
  $twin tag remove _show_variable 1.0 end
  balloon withdraw $twin

  tk_popup $popups($name) $X $Y

}

# ------------------------------------------------------------------
#  METHOD:  do_source_popup - tag bind function for source popups
# ------------------------------------------------------------------

itcl::body SrcTextWin::do_source_popup { X Y x y } {
  if {$Running || [winfo ismapped $popups(source)]} { 
    return 
  }

  # Figure out what window we are over...
  set win [winfo containing -displayof $itk_interior $X $Y]

  # Hide variable balloons before showing the popup
  $win tag remove _show_variable 1.0 end
  balloon withdraw $win
  catch {$_balloon_var delete}


  # Try to get the selection.  If you fail, get the word around the
  # click point.  
  # Note that we don't have to worry about the user clicking over the
  # break area, since the break_rgn_tag will override this...
  
  set hit_point [$win index @@$x,$y]
  if {([$win tag ranges sel] != "")
      && ([$win compare sel.first < $hit_point]
	    && [$win compare $hit_point < sel.last])} {
    set sel_first [$win index sel.first]
    set sel_last  [$win index sel.last]

    # If there was a selection, see if it spans multiple lines.
    scan $sel_first "%d.%d" range_low sel_start_char
    scan $sel_last "%d.%d" range_high sel_end_char

    if {$range_low == $range_high} {
      set range -1
      set target_range [$win get sel.first sel.last]
    } else {
      # If the selection encompasses multiple lines, we only care about
      # the start and ending line numbers
      set range 1
    }
  } else {
    set target_range [$win get "$hit_point wordstart" "$hit_point wordend"]
    set range 0
  }
  
  $popups(source) delete 0 end
  
  if {$range && $Tracing} {
    # If the selection spans more than one line, it can't be a variable name...
    # So just insert the tracepoint range item
    $popups(source) add command -label "Set Tracepoint Range" \
      -command "$this tracepoint_range $win $range_low $range_high"
    $popups(source) add separator
  } elseif {$range != 1} {
    # RANGE = -1 means that we have already found the word we want (it was
    #          a selection)...
    # RANGE = 1 means we got the word around the point, and we are just saving
    #          getVariable the trouble of parsing it again.
    if {$range == -1} {
      set variable $target_range
    } else {
      set variable [lindex [getVariable -1 -1 $target_range] 0]
    }
    
    if {$variable != ""} {
      # LAME: check to see if VARIABLE is really a number (constants??)
      set is_var [catch {expr {$variable+1}}]

      if {$is_var} {
	$popups(source) add command -label "Add $variable to Watch" \
	  -command [list $this addToWatch $variable]
	$popups(source) add command -label "Dump Memory at $variable" \
	  -command [list ManagedWin::open MemWin -force -addr_exp $variable]
	$popups(source) add command -label "Set Breakpoint at $variable" \
	  -command [list gdb_cmd "break $variable"]
	$popups(source) add separator
      }
    }
  }

  $popups(source) add command -label "Open Another Source Window" \
    -command {ManagedWin::open SrcWin -force}
  $popups(source) add command -label "Open Source in external editor" \
    -command [code $parent edit]

  tk_popup $popups(source) $X $Y 
}

# ------------------------------------------------------------------
# METHOD:  addToWatch - add a variable to the watch window
# ------------------------------------------------------------------
itcl::body SrcTextWin::addToWatch {var} {
  [ManagedWin::open WatchWin] add $var
}

# ------------------------------------------------------------------
#  METHOD:  do_key  -- wrapper for all key bindings
# ------------------------------------------------------------------
itcl::body SrcTextWin::do_key {key} {    
  if {!$Running} {
    switch $key {
      print        { print $top }
      download     { Download::download_it }
      run          { $parent inferior run }
      stack        { ManagedWin::open StackWin }
      registers    { ManagedWin::open RegWin }
      memory       { ManagedWin::open MemWin }
      watch        { ManagedWin::open WatchWin }
      locals       { ManagedWin::open LocalsWin }
      breakpoints  { ManagedWin::open BpWin }
      console      { ManagedWin::open Console }
      step         { $parent inferior step }
      next         { $parent inferior next }
      finish       { $parent inferior finish }
      continue     { $parent inferior continue }
      stepi        { $parent inferior stepi }
      nexti        { $parent inferior nexti }
      up           { catch {gdb_cmd up} }
      down         { catch {gdb_cmd down} }
      quit         { gdbtk_quit }
      tdump        { ManagedWin::open TdumpWin }
      tracepoints  { ManagedWin::open BpWin -tracepoints 1}
      tfind_next   { catch {gdb_immediate tfind} }
      tfind_prev   { catch {gdb_immediate "tfind -"} }
      tfind_start  { catch {gdb_immediate "tfind start"} }
      tfind_line   { catch {gdb_immediate "tfind line"} }
      tfind_tp     { catch {gdb_immediate "tfind tracepoint"} }
      open         { catch {_open_file} }
      close        { catch {_close_file} }
      browser      { catch {ManagedWin::open BrowserWin} }
      thread_list  { catch {ManagedWin::open ProcessWin} }
      debug	     { catch {ManagedWin::open DebugWin} }
      kod          { catch {ManagedWin::open KodWin} }
      attach       { catch {gdbtk_attach_native} }
      default      {
	dbug E "Unknown key binding: \"$key\""
      }
    }
  } else {
#    debug "ignoring keypress -- running"
  }
}

# ------------------------------------------------------------------
#  METHOD:  mode_get - get the source mode
# ------------------------------------------------------------------
itcl::body SrcTextWin::mode_get {} {
  return $current(mode)
}

# ------------------------------------------------------------------
#  METHOD:  mode_set - change the source mode
# ------------------------------------------------------------------
itcl::body SrcTextWin::mode_set {new_mode {go 1}} {
  debug "$new_mode"

  if {$new_mode != $current(mode)} {

    if {$current(mode) == "SRC+ASM"} {
      if {$_bpane != ""} {$itk_interior.p hide $_bpane}
      set _bpane ""
      set _bwin ""
    }
    
    set current(mode) $new_mode
    set mode_changed 1

    if {$go} {
      location $current(tag) $current(filename) $current(funcname) \
	$current(line) $current(addr) $pc(addr) $current(lib)
    }
  }
}

# ------------------------------------------------------------------
# METHOD:  cancelMotion - cancel any pending motion callbacks for
#          the source window's variable balloons
# ------------------------------------------------------------------
itcl::body SrcTextWin::cancelMotion {} {
  catch {after cancel $timeoutID}
}

# ------------------------------------------------------------------
# METHOD:  motion - callback for mouse motion within the source
#          window's text widget
# ------------------------------------------------------------------
itcl::body SrcTextWin::motion {type win x y} {
  global gdb_running
  cancelMotion

  # The showBalloon method can sometimes raise errors (for instance in
  # assembly code with no sources, and when gdb coughs over a path
  # that contains a space.  These functions should error quietly.
  # but write to the debug window so we can trace problems.

  if {$type == "var"} {
    set cmd_bit ""
  } else {
    set cmd_bit BP
  }
  set cmd_line [format {
    if {[catch {%s show%sBalloon %s %d %d} err]} {
      debug "show%sBalloon got error: $err"
    }
  } $this $cmd_bit $win $x $y $cmd_bit]
  set timeoutID [after $TimeOut $cmd_line]
}


# ------------------------------------------------------------------
# METHOD:  showBPBalloon - show BP information in a balloon
# ------------------------------------------------------------------
itcl::body SrcTextWin::showBPBalloon {win x y} {
  if {$Running} { return }
  $win tag remove _show_variable 1.0 end 
  set line [lindex [split [$win index @@0,$y] .] 0]
  set bps ""

  switch $current(mode) {
    SRC+ASM {
      if {$win == $bwin} {
	if {[info exists _map($Cname,line=$line)]} {
	  set addr $_map($Cname,line=$line)
	  set bps [gdb_find_bp_at_addr $addr]
	} else {
	  return
	}
      }
    }
    ASSEMBLY {
      if {[info exists _map($Cname,line=$line)]} {
	set addr $_map($Cname,line=$line)
	set bps [gdb_find_bp_at_addr $addr]
      } else {
	return
      }
    }
    MIXED {
      if {[info exists _map($Cname,line=$line)]} {
	set addr $_map($Cname,line=$line)
	set bps [gdb_find_bp_at_addr $addr]
      } else {
	return
      }
    }
  }

  if {$bps == ""} {
    set bps [gdb_find_bp_at_line $current(filename) $line]
  }

  set str ""
  set need_lf 0
  foreach b $bps {
    set bpinfo [gdb_get_breakpoint_info $b]
    lassign $bpinfo file func linenum addr type enabled disposition \
      ignore_count commands cond thread hit_count user_specification
    set file [lindex [file split $file] end]
    if {$enabled} {
      set enabled "ENA"
    } else {
      set enabled "DIS"
    }

    if {$need_lf} {append str \n}

    append str [format "breakpoint %d at %s:%d (%s)\n   %s %s %s" \
		  $b $file $linenum $addr $enabled $type $disposition]

    if {$thread != "-1"} {
      append str "\n   threads: $thread"
    }

    if {$ignore_count != 0} {
      append str "\n   ignore: $ignore_count"
    }

    if {$cond != ""} {
      append str "\n   condition: $cond"
    }

    if {$commands != ""} {
      if {[string length $commands] > 50} {
	append str "\n   commands: [string range $commands 0 50] ..."
      } else {
	append str "\n   commands: $commands"
      }
    }
    set need_lf 1
  }

  # Scope out which break type is set here, and use the tag to get
  # the break region range...

  set tag_list [$win tag names $line.0]
  set break_tag [lindex $tag_list [lsearch -glob $tag_list *bp_tag]]
  set end [lindex [$win tag nextrange $break_tag $line.0 $line.end] 1]

  if {$end != ""} {
    $win tag add _show_variable $line.0 $end
    balloon register $win $str _show_variable
    balloon show $win _show_variable 1
  }
}

# ------------------------------------------------------------------
# METHOD:  showBalloon - (possibly) show a variable's value in
#          a balloon-help widget
# ------------------------------------------------------------------
itcl::body SrcTextWin::showBalloon {win x y} {
  if {$Running} { return }

  $twin tag remove _show_variable 1.0 end
  catch {tmp delete}


  if {[catch  {getVariable $x $y} variable]} {
    return
  }

  if {[llength $variable] != 3} {
    return
  }    
  
  # We get the variable name, and its start and stop indices in the text 
  # widget, so all we need to do is set the tag and register the balloon help
  set varName [lindex $variable 0]
  set start   [lindex $variable 1]
  set stop    [lindex $variable 2]

  # Get the address associated with this line
  foreach {file text_line source_line type} [lookup_line $twin $y] {
    break
  }

  # Reduce the areas over which we will show balloons.
  # 1) Only pop up a balloon if we are over the function in
  #    the currently selected frame, or in the static data for
  #    the file.
  # 2) We would also like to exclude cases where the line that 
  #    under the mouse cursor does not contain executable code, 
  #    but we can't since gdb considers continuation lines to not
  #    have executible code so we would lose on these...
  
  set cur_fn [lindex [gdb_loc $file:$source_line] 1]
  set selected_frame_fn [lindex [gdb_loc] 1]

  if {[string compare $cur_fn $selected_frame_fn] == 0} {
    # Create the variable object
    catch {$_balloon_var delete}
    set err [catch {gdb_variable create -expr $varName} _balloon_var]
    if {!$err} {
      set value [balloon_value $_balloon_var]
      if {$value != ""} {
	$win tag add _show_variable $start $stop

	# display variable's value
	balloon register $twin "$varName=$value" _show_variable
	balloon show $win _show_variable
      } else {
	# No value/error. Don't show it.
	catch {$_balloon_var delete}
	set _balloon_var {}
      }
    } else {
      set _balloon_var {}
    }
  } else {
    set _balloon_var {}
  }
}

# ------------------------------------------------------------------
# METHOD:  getVariable - get the name of the 'variable' under the
#          mouse pointer in the text widget
# ------------------------------------------------------------------
itcl::body SrcTextWin::getVariable {x y {line {}}} {
  #debug "$x $y $line"
  set hit_point [$twin index @@$x,$y]

  if {$x != -1 && $y != -1} {
    # If we are over a selection, just report that:
    if {([$twin tag ranges sel] != "")
	&& ([$twin compare sel.first < $hit_point] 
	    && [$twin compare $hit_point < sel.last])} {
      return [list [$twin get sel.first sel.last] [$twin index sel.first] [$twin index sel.last]]
    } 
    # Since we will only be concerned with this line, get it
    set line [$twin get "$hit_point linestart" "$hit_point lineend"]
    # debug "new line=$line"
    set simple 0
  } else {
    # This is not quite right -- still want constants to appear...
    set simple 1
  }

  # The index into LINE that contains the char at which the pointer hangs
  set a [split [$twin index @@$x,$y] .]
  set lineNo [lindex $a 0]
  set index  [lindex $a 1]
  set s [string range $line $index end]
  set last {}
  foreach char [split $s {}] {
    if {[regexp -- {([^a-zA-Z0-9_>.-])} $char dummy]} {
      break
    }
    lappend last $char
  }
  set last [string trimright [join $last {}] ->]

  # Decrement index for string -- will need to increment it later
  incr index -1
  set tmp [string range $line 0 $index]
  set s {}
  foreach char [split $tmp {}] {
    set s [linsert $s 0 $char]
  }

  set first {}
  foreach char $s {
    if {[regexp -- {([^a-zA-Z0-9_>.-])} $char dummy]} {
      break
    }
    set first [linsert $first 0 $char]
  }
  #set first [string trimleft [join $first {}] ->]
  set first [join $first {}]
  #debug "FIRST=$first\nLAST=$last"

  # Validate the variable
  set variable [string trim $first$last \ ]
  if {!$simple && ![regexp {^[a-zA-Z_]} $variable dummy]} {
    #debug "Rejecting: $variable"
    return {}
  }

  incr index
  # Find the boundaries of this word in the text box
  set a [string length $first]
  set b [string length $last]

  # Gag! If there is a breakpoint at a line, this is off by one!
  if {[hasBP $twin $lineNo] || [hasTP $twin $lineNo]} {
    incr a -1
    incr b 1
  }
  set start "$lineNo.[expr {$index - $a}]"
  set end   "$lineNo.[expr {$index + $b}]"
  return [list $variable $start $end]
}

# ------------------------------------------------------------------
#  METHOD:  trace_help - update statusbar with ballon help message
# ------------------------------------------------------------------
itcl::body SrcTextWin::trace_help {args} {
  upvar #0 ${this}_balloon a
  if {$a == ""} {
    $parent set_status
  } else {
    $parent set_status $a 1
  }
}

itcl::body SrcTextWin::line_is_executable {win line} {
  # there should be an image or a "-" on the line
  set res [catch {$win image cget $line.0 -image}]
  if {!$res || [$win get $line.0] == "-"} {
    return 1
  }
  return 0
}

# ------------------------------------------------------------------
# METHOD:   tracepoint_range - create tracepoints at every line in
#           a range of lines on the screen
# ------------------------------------------------------------------
itcl::body SrcTextWin::tracepoint_range {win low high} {
#  debug "$win $low $high"

  switch $current(mode) {
    SOURCE {
      set lines {}
      for {set i $low} {$i <= $high} {incr i} {
	if {[line_is_executable $win $i]} {
	  lappend lines $i
	}
      }
    }

    ASSEMBLY {
      set addrs {}
      for {set i $low} {$i <= $high} {incr i} {
	lappend addrs $_map($Cname,line=$i)
      }
    }

    MIXED {
      set addrs {}
      for {set i $low} {$i <= $high} {incr i} {
	if {[line_is_executable $win $i]} {
	  lappend addrs $_map($Cname,line=$i)
	}
      }
    }

    SRC+ASM {
      if {$win == $awin} {
	# Assembly
	set addrs {}
	for {set i $low} {$i <= $high} {incr i} {
	  lappend addrs $_map($Cname,line=$i)
	}
      } else {
	# Source
	set lines {}
	for {set i $low} {$i <= $high} {incr i} {
	  if {[line_is_executable $win $i]} {
	    lappend lines $i
	  }
	}
      }
    }
  }
  
  if {[info exists lines]} {
#    debug "Got executible lines: $lines"
    if {[llength $lines]} {
      set name [::file tail $current(filename)]
      ManagedWin::open TraceDlg -File $name -Lines $lines
    }
  } elseif {[info exists addrs]} {
#    debug "Got executible addresses: $addrs"
    if {[llength $addrs]} {
      set name [::file tail $current(filename)]
      ManagedWin::open TraceDlg -File $name -Addresses $addrs
    }
  } else {
#    debug "Got no executible lines in the selected range..."
  }

  # Clear the selection -- it looks a lot better.
  $twin tag remove sel 1.0 end
}


# ------------------------------------------------------------------
#  METHOD:  search - search for text or jump to a specific line
#           in source window, going in the specified DIRECTION.
# ------------------------------------------------------------------
itcl::body SrcTextWin::search {exp direction} {
  if {$exp != ""} {
    set result {}
    if {[regexp {^@@([0-9]+)} $exp dummy index]} {
      append index .0
      set end [$twin index "$index lineend"]
    } else {
      set index [$twin search -exact -count len -$direction -- $exp $SearchIndex]
      
      if {$index != ""} {
	set end [split $index .]
	set line [lindex $end 0]
	set char [lindex $end 1]
	set char [expr {$char + $len}]
	set end $line.$char
	set result "Match of \"$exp\" found on line $line"
	if {$direction == "forwards"} {
	  set SearchIndex $end
	} else {
	  set SearchIndex $index
	}
      }
    }
    if {$index != ""} {
      # Highlight word and save index
      $twin tag remove search 1.0 end
      $twin tag add search $index $end
      $twin see $index
    } else {
      set result "No match for \"$exp\" found"
    }
    return $result
  } else {
    $twin tag remove search 1.0 end
  }
}

# -----------------------------------------------------------------------------
# NAME:		SrcTextWin::LoadFromCache
#
# SYNOPSIS:	LoadFromCache {w name asm lib}
#
# DESC:		Looks up $name in the cache.  If $name is cached, replace the
#		pane $w with the cached pane. Otherwise create a new
#		pane and scrolledtext widget and set _${w}pane and _${w}win.
#
# ARGS:		w	"t" or "b" (for Top and Bottom pane)
#		name	name to look for in cache. This will be a filename if
#			we are filling in a source window, or an address 
#			otherwise.
#		asm	'S' for source, 
#                       'A' for assembly mode 
#                       'M' for mixed mode.
#		lib	library name
#
# RETURNS:	0 - read from cache
#		1 - created new (blank) widget
#              -1 - could not find the contents you are trying to load,
#                   so far this only happens for "Source" files.
#
# NOTES:	If you call this and a new widget is created which cannot be
#		filled in later due to errors, call UnLoadFromCache.
# -----------------------------------------------------------------------------

itcl::body SrcTextWin::LoadFromCache {w name asm lib} {
  debug "LoadFromCache $w $name $asm"
  global gdbtk_platform
  upvar ${w}win win
  upvar _${w}pane pane

  if {[string compare gdbtk_scratch_widget $name]} {
    append full_name $name "," $asm "," $lib
  } else {
    set full_name $name
  }

  set loadingSource [expr ![string compare $asm "S"]]

  set oldpane $pane
  if {[info exists Stwc($full_name:pane)]} {
    debug "READING CACHE $full_name->$Stwc($full_name:pane)"
    set pane $Stwc($full_name:pane)
    if {$oldpane != ""} {
      $itk_interior.p replace $oldpane $pane
    } else {
      $itk_interior.p show $pane
    }
    set win [[$itk_interior.p childsite $pane].st component text]
    if {!$loadingSource} {
      set Cname $full_name
    }

    # If the text in this cache file is dirty, clean the window, and
    # return 1, which will tell the caller to refill it.  Otherwise
    # return 0, and the caller will just display the window.
    
    if {$Stwc($name:dirty)} {
      $win delete 0.0 end
      set res 1
      set Stwc($name:dirty) 0
    } else {
      set res 0
    }

  } else {
    debug "name=$name"
    # If we are trying to load a source file, check the time
    # to see if we need to update it.  If we can't stat the
    # file then we probably can't open it either, so error 
    # out.

    if {$loadingSource} {
      if {[string compare $gdbtk_platform(os) "cygwin"] == 0} {
        set f [ide_cygwin_path to_win32 $name]
      } else {
        set f $name
      }
      if {[catch {file mtime $f} file_time]} {
	debug "Could not stat file \"$f\" - \"$file_time\""
	return -1
      } else {
        set Stwc($full_name:pane) pane$filenum
	set Stwc($name:mtime) $file_time
      }    
    } else {
      # FIXME: This is wrong.  For Assembly files we need to
      # check whether the executable is newer than the cached
      # disassembly.  For mixed files, we need to check BOTH
      # the source file mtime, and the executable time.
      
      set Stwc($full_name:pane) pane$filenum
      set Stwc($name:mtime) 0
    }

    set Stwc($full_name:pane) pane$filenum

    set Stwc($name:dirty) 0
    incr filenum

    set pane $Stwc($full_name:pane)
    debug "pane=$pane"
    if {$oldpane != ""} {$itk_interior.p hide $oldpane}
    $itk_interior.p add $pane
    set p [$itk_interior.p childsite $pane]
    set st [iwidgets::scrolledtext $p.st \
	      -hscrollmode dynamic -vscrollmode dynamic]
    set win [$st component text]

    if {!$loadingSource} {
      set Cname $full_name
    }
    pack $st -expand yes -fill both
    set res 1
  }

  # reconfigure in case some preferences have changed
  config_win $win $asm
  return $res
}

# ------------------------------------------------------------------
#  METHOD:  UnLoadFromCache - revert back to previously cached widget
#  This is used when a new widget is created with LoadFromCache but
#  there is a problem with filling the widget.  
# ------------------------------------------------------------------

itcl::body SrcTextWin::UnLoadFromCache {w oldpane name asm lib} {
#  debug "$w $oldpane $name"
  upvar ${w}win win
  upvar _${w}pane pane
#  debug "pane=$pane win=$win"


  set full_name ${name},${asm},${lib}
  $itk_interior.p delete $pane
  foreach elem [array names Stwc $full_name:*] {
    unset Stwc($elem)
  }
  foreach elem [array names Stwc $name:*] {
    unset Stwc($elem)
  }

  if {$oldpane != ""} {
    $itk_interior.p show $oldpane
    set pane $oldpane
    set win [[$itk_interior.p childsite $pane].st component text]
  }
}

# ------------------------------------------------------------------
#  METHOD:  print - print the contents of the text widget
# ------------------------------------------------------------------
itcl::body SrcTextWin::print {top} {
  # FIXME
  send_printer -ascii [$twin get 1.0 end] -parent $top
}

# ------------------------------------------------------------------
#  METHOD:  ask_thread_bp - prompt for thread(s) for BP
# ------------------------------------------------------------------
itcl::body SrcTextWin::ask_thread_bp {} {
#  debug
  if {[catch {gdb_cmd "info thread"} threads]} {
    # failed. Just leave
    return
  }
  set threads [split $threads \n]
  set num_threads [expr {[llength $threads] -  1}]
  if {$num_threads <= 0} {
    show_warning "No threads were found.\nYou may only set breakpoints on threads\nthat have already been created."
    return
  }
  
  set a [toplevel .[gensym]]
  wm title $a "Thread Selection"

  iwidgets::scrolledlistbox $a.slb \
    -vscrollmode dynamic -hscrollmode dynamic \
    -selectmode multiple -textfont global/fixed

  set i [expr $num_threads - 1]
  set width 0
  foreach line $threads {
    # Active line starts with "*"
    if {[string index $line 0] == "*"} {
      # strip off leading "*"
      set line " [string trimleft $line "*"]"
    }
    # scan for GDB ID number at start of line
    if {[scan $line "%d" id($i)] == 1} {
      if {[string length $line] > $width} {
	set width [string length $line]
      }
      $a.slb insert 0 $line 
      incr i -1
    }
  }
  $a.slb configure -visibleitems ${width}x$num_threads 
  [$a.slb component listbox] configure -bg $::Colors(textbg) -fg $::Colors(textfg)

  frame $a.b
  button $a.b.ok -text OK -underline 0 -width 7 \
    -command "$this do_thread_bp $a.slb"
  button $a.b.cancel -text Cancel -width 7 -underline 0 -command "destroy $a"
  pack $a.b.ok $a.b.cancel -side left
  standard_button_box $a.b
  pack $a.b -fill x -expand yes -side bottom -padx 5 -pady 5
  center_window $a -over [winfo toplevel [namespace tail $this]]
  pack $a.slb -side top -fill both -expand yes
  bind $a.b.ok <Return> "$a.b.ok flash; $a.b.ok invoke"
  focus $a.b.ok
}

# ------------------------------------------------------------------
#  METHOD:  do_thread_bp - callback from thread selection
# ------------------------------------------------------------------
itcl::body SrcTextWin::do_thread_bp {listbox} {
#  debug "$listbox [$listbox curselection]"
  set x ""
  foreach i [$listbox curselection] {
    lappend x $id($i)
  }
  $this set_bp_at_line N {} -1 $x
  destroy [winfo toplevel $listbox]
}


# public method for testing use only!
itcl::body SrcTextWin::test_get {var} {
  if {[array exists $var]} {
    return [array get $var]
  } else {
    return [set $var]
  }
}

# ------------------------------------------------------------------
#  METHOD:  get_file - Return name of current file.
# ------------------------------------------------------------------
itcl::body SrcTextWin::get_file {} {
  return $current(filename)
}

# ------------------------------------------------------------------
#  METHOD:  clear_file - Clear out state so that user may load
#              new executable. For the SrcTextWin class, this means:
#
#              Delete all srctextwin caches
#              Delete the variable balloon if it exists.
#              Clear the screen.
# ------------------------------------------------------------------
itcl::body SrcTextWin::clear_file {} {

  debug "In clear_file"
  # delete all caches
  _clear_cache

  set oldpane {}

  # clear window
  # FIXME - We don't do this here, because is causes a wierd error
  # where the "Source file more recent than executible" error gets
  # for no apparent reason.  This only effects the case where the
  # user types just "file" in the command line, then the window will
  # not get cleared.

  # delete variable balloon
  catch {$_balloon_var delete}
  set _balloon_var {}

  # reinit state
  _initialize_srctextwin

  # update the screen
  update idletasks

}

itcl::body SrcTextWin::_initialize_srctextwin {} {
  set pc(filename) ""
  set pc(func) ""
  set pc(line) 0
  set pc(addr) ""
  set pc(asm_line) 0
  set pc(lib) ""
  set current(filename) ""
  set current(funcname) ""
  set current(line) 0
  set current(addr) ""
  set current(asm_line) 0
  set current(tag) "BROWSE_TAG"
  set current(mode) "SOURCE"
  set current(lib) ""  
}

# ------------------------------------------------------------------
#  METHOD:  _clear_cache - Clear the cache
# ------------------------------------------------------------------
itcl::body SrcTextWin::_clear_cache {} {

  # display empty scratch frame
  set pane $Stwc(gdbtk_scratch_widget:pane)
  set win [[$itk_interior.p childsite $pane].st component text]
  $win delete 0.0 end
  $itk_interior.p show $pane

  # delete all cached frames
  foreach p [array names Stwc *:pane] {
    set p [string trimright $p ":pane"]
    if {$p != "gdbtk_scratch_widget"} {
      catch {
	#debug "clearing cache: \"$p\""
	$itk_interior.p delete $Stwc($p:pane)
	unset Stwc($p:pane)
	unset Stwc($p:mtime)
      }
    }
  }

  _initialize_srctextwin
  set filenum 0
  set Cname ""
  set _tpane pane$filenum
  incr filenum
  set _bpane ""
}
@


1.46
log
@	* library/srctextwin.itb (lookup_line): Update parameters
	to gdb_set_bp.
	* generic/gdbtk-bp.c: Remove extern declarations for symbols
	in breakpoint.c.
	(gdb_set_bp_addr): Remove.
	(Gdbtk_Breakpoint_Init): Remove Tcl command "gdb_set_bp_addr".
	(gdb_set_bp): Remove file and line arguments; add "addr" argument.
	Rewrite to use "public" APIs from gdb.
@
text
@d1762 1
a1762 1
      set set_cmd [list gdb_set_bp "$current(filename):$addr"]
@


1.45
log
@	* library/srctextwin.ith (ExecutableLineLimit): Define.
	* library/srctextwin.itb (insertBreakTag): Search for next
	executable line, just in case they changed.
	When there are no tags on a line, the proper index is
	line.4, not just 4.
@
text
@d1759 1
a1759 1
      set set_cmd [list gdb_set_bp_addr $addr]
d1762 1
a1762 1
      set set_cmd [list gdb_set_bp $current(filename) $addr]
@


1.44
log
@- Fix a problem with "File Close" menu that let insight becoming unstable
and unable to reopen a new binary (Linux and Win32 hosts)
- Fix a problem with the source window that, once a binary is closed, is
splitted into 2 part and alway displays the old sources. (Win32 hosts only)

2008-12-16  Denis Pilat  <denis.pilat@@st.com>
	on behalf of Nunzio Raciti  <nunzio.raciti@@st.com>

	* library/srctextwin.itb (_clear_cache): Take care of $p variable that
	could contains ":" for source pane on windows hosts.
	* library/srcwin.itb (choose_and_update): Avoid updating the "source"
	window if target executable name is empty.
@
text
@d2 1
a2 1
# Copyright (C) 1997, 1998, 1999, 2001, 2002, 2008 Red Hat, Inc.
d1365 8
d1389 1
a1389 1
      set stop 4
@


1.43
log
@        * library/main.tcl: Add gdbtk_platform definitions.
        * library/attachdlg.itb (list_pids): Use gdbtk_platform
        instead of tcl_platform.
        * library/bpwin.itb (build_win): Likewise.
        (_bp_add): Likewise.
        (_bp_modify): Likewise.
        * library/download.itb (download_it): Likewise.
        * library/globalpref.itb (_build_win): Likewise.
        * library/helpviewer.tcl (open_help): Likewise.
        * library/interface.tcl (gdbtk_tcl_query): Likewise.
        (show_warning): Likewise.
        (open_file): Likewise.
        (run_executable): Likewise.
        * library/managedwin.itb (reveal): Likewise.
        (_create): Likewise.
        * library/prefs.tcl (pref_read): Likewise.
        (pref_set_defaults): Likewise.
        (pref_set_colors): Likewise.
        * library/session.tcl (_exe_name): Likewise.
        * library/srcbar.itcl (_update_file_menu): Likewise.
        (create_run_menu): Likewise.
        * library/srctextwin.itb (_mtime_changed): Likewise.
        (LoadFromCache): Likewise.
        * library/targetselection.itb (default_port): Likewise.
        (build_win): Likewise.

        * library/memwin.itb (build_win): Remove unused tcl_platform
        declaration.
        * library/pluginwin.itcl (enable_ui): Likewise.
        * library/process.itb (build_win): Likewise.
        * library/srcbar.itcl (enable_ui): Likewise.
        * library/srcwin.itb (location): Likewise.
        * library/stackwin.itb (build_win): Likewise.
        * library/tdump.tcl (build_win): Likewise.
@
text
@d2954 1
a2954 1
    set p [lindex [split $p :] 0]
@


1.42
log
@	* library/attachdlg.itb:
	* library/actiondlg.tcl:
	* library/about.tcl:
	* library/ehandler.itb:
	* library/editor.tcl:
	* library/download.ith:
	* library/download.itb:
	* library/debugwin.ith:
	* library/debugwin.itb:
	* library/cspref.ith:
	* library/cspref.itb:
	* library/console.ith:
	* library/console.itb:
	* library/browserwin.ith:
	* library/browserwin.itb:
	* library/bpwin.ith:
	* library/bpwin.itb:
	* library/blockframe.ith:
	* library/managedwin.ith:
	* library/managedwin.itb:
	* library/main.tcl:
	* library/locals.tcl:
	* library/ipcpref.ith:
	* library/ipcpref.itb:
	* library/ipc.tcl:
	* library/interface.tcl:
	* library/helpviewer.tcl:
	* library/globalpref.ith:
	* library/globalpref.itb:
	* library/gdbwin.ith:
	* library/gdbtoolbar.itcl:
	* library/gdbmenubar.itcl:
	* library/gdbevent.ith:
	* library/gdbevent.itb:
	* library/embeddedwin.ith:
	* library/ehandler.ith:
	* library/srcwin.itb:
	* library/srctextwin.ith:
	* library/srctextwin.itb:
	* library/srcpref.ith:
	* library/srcpref.itb:
	* library/srcbar.itcl:
	* library/session.tcl:
	* library/regwin.ith:
	* library/regwin.itb:
	* library/process.ith:
	* library/process.itb:
	* library/prefs.tcl:
	* library/pluginwin.itcl:
	* library/modal.tcl:
	* library/memwin.ith:
	* library/memwin.itb:
	* library/mempref.ith:
	* library/mempref.itb:
	* library/watch.tcl:
	* library/watch.tcl:
	* library/warning.tcl:
	* library/vartree.ith:
	* library/vartree.itb:
	* library/util.tcl:
	* library/tracedlg.tcl:
	* library/toplevelwin.ith:
	* library/tfind_args.tcl:
	* library/tdump.tcl:
	* library/targetselection.ith:
	* library/targetselection.itb:
	* library/stackwin.ith:
	* library/stackwin.itb:
	* library/srcwin.ith:
@
text
@d2 1
a2 1
# Copyright (C) 1997, 1998, 1999, 2001, 2002 Red Hat, Inc.
d887 1
a887 1
  global tcl_platform
d894 1
a894 1
    if {[string compare $tcl_platform(platform) "windows"] == 0} {
d2672 1
a2672 1
  global tcl_platform
d2718 1
a2718 1
      if {[string compare $tcl_platform(platform) "windows"] == 0} {
@


1.41
log
@2003-03-05  Martin M. Hunt  <hunt@@redhat.com>

	* library/srctextwin.itb (SrcTextWin::FillAssembly):
	Remove unused variables asm_lo_addr and asm_hi_addr.
	(FillMixed): Ditto.
@
text
@d2 1
a2 1
# Copyright 1997, 1998, 1999, 2001, 2002 Red Hat, Inc.
@


1.40
log
@2002-11-11  Martin M. Hunt  <hunt@@redhat.com>

	* library/srctextwin.itb (do_key): Add arg to
	print call.
@
text
@d1046 1
a1046 2
	foreach {asm_lo_addr asm_hi_addr} $mess {break}
        debug "Got low address: $asm_lo_addr and high: $asm_hi_addr"
a1074 2
  set asm_lo_addr ""
  
d1107 1
a1107 2
	foreach {asm_lo_addr asm_hi_addr} $mess {break}
        debug "Got low address: $asm_lo_addr and high: $asm_hi_addr"
@


1.39
log
@2002-11-07  Martin M. Hunt  <hunt@@redhat.com>

	* library/util.tcl (CygScrolledListbox): Delete.

	* library/srctextwin.itb: Change from CygScrolledListbox
	to iwidgets::scrolledlistbox. Set foreground and background.
	Center popup over source window.
@
text
@d2162 1
a2162 1
      print        { print }
@


1.38
log
@2002-10-15  Martin M. Hunt  <hunt@@redhat.com>

	* library/* : auto_mkindex cannot rebuild
	tclIndex because it does not recognize the namespace
	import in main.tcl.  To get it to work again, rename the
	following:
		body -> itcl::body
		configbody -> itcl::configbody
		class -> itcl::class
@
text
@d2825 5
a2829 2
  CygScrolledListbox $a.slb -selectmode multiple -height $num_threads
  
d2843 1
a2843 1
      $a.slb.list insert 0 $line 
d2847 2
a2848 1
  $a.slb.list configure -width $width
d2852 1
a2852 1
    -command "$this do_thread_bp $a.slb.list"
d2857 1
@


1.37
log
@
2002-09-24  Martin M. Hunt  <hunt@@redhat.com>

	* library/srctextwin.itb (FillMixed): Fix debug
	statement for 64-bit.
	(_highlightAsmLine): Fix 64-bit arithmetic.
@
text
@d24 1
a24 1
body SrcTextWin::constructor {args} {
d79 1
a79 1
body SrcTextWin::destructor {} {
d93 1
a93 1
body SrcTextWin::trace_find_hook {mode from_tty} {
d106 1
a106 1
body SrcTextWin::set_control_mode {mode} {
d156 1
a156 1
body SrcTextWin::build_popups {} {
d306 1
a306 1
body SrcTextWin::build_win {} {
d329 1
a329 1
body SrcTextWin::SetRunningState {state} {
d339 1
a339 1
body SrcTextWin::enable {on} {
d372 1
a372 1
body SrcTextWin::makeBreakDot {size colorList {image {}}} {
d408 1
a408 1
body SrcTextWin::setTabs {win {asm S}} {
d444 1
a444 1
body SrcTextWin::enable_disable_src_tags {win how} {
d493 1
a493 1
body SrcTextWin::config_win {win {asm S}} {
d693 1
a693 1
body SrcTextWin::addPopup {menu label command {abg {}} {browse 1} {run 1}} {
d716 1
a716 1
body SrcTextWin::set_variable {event} {
d732 1
a732 1
body SrcTextWin::disassembly_changed {} {
d752 1
a752 1
body SrcTextWin::reconfig {} {
d830 1
a830 1
body SrcTextWin::updateBalloon {} {
d844 1
a844 1
body SrcTextWin::balloon_value {variable} {
d869 1
a869 1
body SrcTextWin::ClearTags {} {
d886 1
a886 1
body SrcTextWin::_mtime_changed {filename} {
d923 1
a923 1
body SrcTextWin::FillSource {w tagname filename funcname line addr pc_addr lib} {
d1003 1
a1003 1
body SrcTextWin::FillAssembly {w tagname filename funcname line addr pc_addr lib} {
d1070 1
a1070 1
body SrcTextWin::FillMixed {w tagname filename funcname line addr pc_addr lib} {
d1128 1
a1128 1
body SrcTextWin::_highlightAsmLine {win addr pc_addr \
d1164 1
a1164 1
body SrcTextWin::set_tag_to_stack {} {
d1180 1
a1180 1
body SrcTextWin::location {tagname filename funcname line addr pc_addr lib} {
d1257 1
a1257 1
body SrcTextWin::LoadFile {w name lib mtime_changed} {
d1290 1
a1290 1
body SrcTextWin::display_line { win line } {
d1313 1
a1313 1
body SrcTextWin::display_breaks {} {
d1358 1
a1358 1
body SrcTextWin::insertBreakTag {win linenum tag} {
d1402 1
a1402 1
body SrcTextWin::removeBreakTag {win linenum tag } {
d1455 1
a1455 1
body SrcTextWin::breakpoint {bp_event} {
d1466 1
a1466 1
body SrcTextWin::tracepoint {tp_event} {
d1480 1
a1480 1
body SrcTextWin::bp {action bpnum addr {linenum {}} {file {}} {type 0} {enabled 0}  {thread -1}} {
d1519 1
a1519 1
body SrcTextWin::do_bp { win action linenum type bpnum enabled thread asm} {
d1616 1
a1616 1
body SrcTextWin::hasBP {win line} {
d1630 1
a1630 1
body SrcTextWin::hasTP {win line} {
d1652 1
a1652 1
body SrcTextWin::report_source_location {} {
d1719 1
a1719 1
body SrcTextWin::lookup_line {win y} {
d1773 1
a1773 1
body SrcTextWin::continue_to_here {{win {}} {y -1} {threads -1}} {
d1805 1
a1805 1
body SrcTextWin::jump_to_here {{win {}} {y -1} {threads -1}} {
d1849 1
a1849 1
body SrcTextWin::set_bp_at_line {{type N} {win {}} {y -1} {threads "-1"}} {
d1878 1
a1878 1
body SrcTextWin::enable_disable_at_line {action} {
d1926 1
a1926 1
body SrcTextWin::remove_bp_at_line {{win {}} {y -1}} {
d1953 1
a1953 1
body SrcTextWin::set_tp_at_line {{win {}} {y -1}} {
d1979 1
a1979 1
body SrcTextWin::next_hit_at_line {{win {}} {y -1}} {
d2009 1
a2009 1
body SrcTextWin::remove_tp_at_line {{win {}} {y -1}} {
d2040 1
a2040 1
body SrcTextWin::do_tag_popup {name X Y y} {
d2063 1
a2063 1
body SrcTextWin::do_source_popup { X Y x y } {
d2152 1
a2152 1
body SrcTextWin::addToWatch {var} {
d2159 1
a2159 1
body SrcTextWin::do_key {key} {    
d2207 1
a2207 1
body SrcTextWin::mode_get {} {
d2214 1
a2214 1
body SrcTextWin::mode_set {new_mode {go 1}} {
d2239 1
a2239 1
body SrcTextWin::cancelMotion {} {
d2247 1
a2247 1
body SrcTextWin::motion {type win x y} {
d2273 1
a2273 1
body SrcTextWin::showBPBalloon {win x y} {
d2370 1
a2370 1
body SrcTextWin::showBalloon {win x y} {
d2437 1
a2437 1
body SrcTextWin::getVariable {x y {line {}}} {
d2515 1
a2515 1
body SrcTextWin::trace_help {args} {
d2524 1
a2524 1
body SrcTextWin::line_is_executable {win line} {
d2537 1
a2537 1
body SrcTextWin::tracepoint_range {win low high} {
d2610 1
a2610 1
body SrcTextWin::search {exp direction} {
d2674 1
a2674 1
body SrcTextWin::LoadFromCache {w name asm lib} {
d2776 1
a2776 1
body SrcTextWin::UnLoadFromCache {w oldpane name asm lib} {
d2802 1
a2802 1
body SrcTextWin::print {top} {
d2810 1
a2810 1
body SrcTextWin::ask_thread_bp {} {
d2861 1
a2861 1
body SrcTextWin::do_thread_bp {listbox} {
d2873 1
a2873 1
body SrcTextWin::test_get {var} {
d2884 1
a2884 1
body SrcTextWin::get_file {} {
d2896 1
a2896 1
body SrcTextWin::clear_file {} {
d2923 1
a2923 1
body SrcTextWin::_initialize_srctextwin {} {
d2943 1
a2943 1
body SrcTextWin::_clear_cache {} {
@


1.36
log
@2002-09-19  Martin M. Hunt  <hunt@@redhat.com>

	* library/srctextwin.itb (FillAssembly): Fix debug
        statement for 64-bit addresses.
        (showBPBalloon): Fix for 64-bit addresses.
@
text
@d1094 1
a1094 1
      # debug [format "Disassembling at %x" $addr]
d1137 1
a1137 1
    set x [format "0x%x" [expr $current(addr)-2]]
@


1.35
log
@2002-06-07  Martin M. Hunt  <hunt@@redhat.com>

	* library/prefs.tcl (pref_set_colors): New function.  Set up colors
	from Windows system colors or X resource database. Save in array.
	(pref_set_defaults): Remove gdb/font/normal_fg, etc.
	(pref_read): Call pref_set_colors.

	* library/main.tcl: Remove call to "tix resetoptions TixGray".

	* library/bpwin.itb, library/browserwin.itb, library/console.itb,
	library/globalpref.itb, library/memwin.itb, library/process.itb,
	library/regwin.itb, library/srcpref.itb, library/srctextwin.itb,
	library/stackwin.itb, library/tdump.tcl, library/tracedlg.tcl,
	library/variables.tcl: Replace calls to [pref get gdb/fonts/*]
	for colors with references to Color array. Remove all tixOptions calls.
	Fix up colors as necessary.
@
text
@d1029 1
a1029 1
      #debug [format "Disassembling at %x" $addr]
d2327 1
a2327 1
    append str [format "breakpoint %d at %s:%d (%#x)\n   %s %s %s" \
@


1.34
log
@2002-03-07  Martin M. Hunt  <hunt@@redhat.com>

	* library/srctextwin.itb (SrcTextWin::showBPBalloon): Put
	linefeeds between multiple breakpoints.
@
text
@d307 1
a307 1
  cyg::panedwindow $itk_interior.p -background white
d317 1
a317 1
  set twinp [iwidgets::scrolledtext $pane1.st -textbackground white \
d496 1
a496 1
  $win config -borderwidth 2 -insertwidth 0 -wrap none -bg white
d500 1
a500 1
  $win configure -font $font
d507 1
a507 1
  $win tag configure break_rgn_tag -foreground [pref get gdb/src/break_fg]
d509 1
a509 1
    $win tag configure ${type}_tag -foreground [pref get gdb/src/break_fg]
d511 1
a511 1
  $win tag configure tp_tag -foreground [pref get gdb/src/break_fg]
@


1.33
log
@2002-03-06  Martin M. Hunt  <hunt@@redhat.com>

	* library/srctextwin.itb (SrcTextWin::showBPBalloon):
	Reformat output. Add conditions, ignore count, commands.

	* library/interface.tcl (gdbtk_tcl_readline): Remove
	call to "command::insert" and instead insert the command
	into the console window.
	(gdbtk_tcl_readline_end): Catch the unsets and do not call
	non-existent function command::end_multi_line_input.
@
text
@d2313 1
d2325 2
d2349 1
@


1.32
log
@2002-03-05  Martin M. Hunt  <hunt@@redhat.com>

	* library/prefs.tcl (pref_read): If a preference specifies
	"src-font", substitute "global/fixed".
	(pref_set_defaults): Change defaults from "src-font" to
	"global/fixed". Do not create font object "src-font". Do
	not add hook to trace its changes.
	(pref_src-font_trace): Remove.

	* library/console.itb (Console::_update_option): Remove
	font update because this happens automatically.

	* library/globalpref.itb: No need to set
	changed flag for fonts; updates happen automatically
	when prefs are updated.

	* library/bpwin.itb: Replaced src-font with global/fixed.
	* library/browserwin.itb: Ditto.
	* library/mempref.itb: Ditto.
	* library/memwin.itb: Ditto.
	* library/process.itb: Ditto.
	* library/regwin.itb: Ditto.
	* library/srcbar.itcl: Ditto.
	* library/srcpref.itb: Ditto.
	* library/srctextwin.itb: Ditto.
	* library/srcwin.itb: Ditto.
	* library/stackwin.itb: Ditto.
	* library/tdump.tcl: Ditto.
	* library/tracedlg.tcl: Ditto.
	* library/variables.tcl: Ditto.
	* library/watch.tcl: Ditto.
@
text
@a2312 1
  set need_lf 0
a2316 1
    if {$thread == "-1"} {set thread "all"}
d2323 22
a2344 5
    if {$cond == ""} {set cond "none"}
    if {$need_lf} {
      append str \n
    } else {
      set need_lf 1
a2345 3
    append str [format "breakpoint %d at %s:%d (%#x)\n\t%s %s %s %s %s" \
		  $b $file $linenum $addr $enabled $type $disposition \
		  threads=$thread cond=$cond]
@


1.31
log
@update copyrights (dates verified with cvs)
@
text
@d409 1
a409 1
  set fsize [font measure src-font "W"]
d756 1
a756 1
  set size [font measure src-font "W"]
@


1.30
log
@2002-01-11  Martin M. Hunt  <hunt@@redhat.com>

	* library/srctextwin.itb: Check for existence of $twin.
@
text
@d2 1
a2 1
# Copyright 1997, 1998, 1999, 2001 Red Hat, Inc.
@


1.29
log
@2002-01-03  Martin M. Hunt  <hunt@@redhat.com>

	* library/srctextwin.itb: Set focus on srcwin only
	if another window doesn't have the focus.
@
text
@d352 8
a359 4
  bind $twin <B1-Motion> $bnd
  bind $twin <Double-1> $bnd
  bind $twin <Triple-1> $bnd
  enable_disable_src_tags $twin $status
a364 4
  }

  $twin configure -cursor $glyph
  if {$bwin != ""} {
@


1.28
log
@	* library/tclIndex: Updated.
	* library/prefs.tcl (pref_set_defaults): Define gdb/editor
	preference.
	* library/srcpref.itb (SrcPref::constructor): Save gdb/editor
	preference.
	(SrcPref::build_win): Added external editor control.
	* library/srctextwin.itb (SrcTextWin::do_source_popup): Always
	enable external editor.  Use `code' instead of `list'.
	* library/srcwin.itb (SrcWin::edit): Use Editor::edit.
	* library/editor.tcl: New file.
	* generic/gdbtk.c (enable_external_editor): Removed.
	(external_editor_command): Default to NULL.
	(gdbtk_init): Don't set enable_external_editor.  Free external
	editor command when finished with it.
@
text
@d503 1
a503 1
  
d684 4
a687 2
  # Make key bindings usable immediately (without mouse click in window).
  focus $win
@


1.27
log
@	* generic/gdbtk-cmds.c (gdb_load_disassembly): Save the original
	address from parse_and_eval_address: if find_pc_partial_function
	errors, we will lose our original address.
	If find_pc_partial_function does error, print out both
	the address we thought we were disassembling at AND the address
	we actually did disassemble at. This should help elide address-
	to-pointer and pointer-to-address problems in the tdep files.
	* library/srctextwin.itb (FillAssembly): When gdb_load_disassembly
	fails, use its error message instead of the cooked "Unable to
	Read insturctions..." message.
	(UnLoadFromCache): If oldpane is empty, don't try show it,
	don't try to set our view to it, don't do anything but
	erase the given pane.
@
text
@d2141 2
a2142 4
  if {[info exists ::enable_external_editor] && $::enable_external_editor} {
    $popups(source) add command -label "Open Source in external editor" \
      -command [list $parent edit]
  }
@


1.26
log
@	* library/session.tcl (session_save): Save breakpoints.
	(SESSION_serialize_bps): New proc.
	(SESSION_recreate_bps): New proc.
	(session_load): Recreate breakpoints.
	* library/util.tcl (bp_exists): Expect user specification in
	breakpoint info.
	* library/srctextwin.itb (SrcTextWin::showBPBalloon): Expect user
	specification in breakpoint info.
	* library/gdbevent.itb (BreakpointEvent::_init): Initialize
	_user_specification.
	(BreakpointEvent::get): Handle user_specification.
	* library/gdbevent.ith (BreakpointEvent): Added
	_user_specification field.
	* library/bpwin.itb (BpWin::bp_store): Expect user specification
	and use it when saving.
	(BpWin::bp_type): Expect user specification.
	* generic/gdbtk-bp.c (BREAKPOINT_IS_WATCHPOINT): New macro.
	(gdb_get_breakpoint_info): Added `user specification' to result.
@
text
@d1037 1
a1037 1
	$win insert 0.0 "Unable to Read Instructions at $addr"
d2776 5
a2780 3
  $itk_interior.p show $oldpane
  set pane $oldpane
  set win [[$itk_interior.p childsite $pane].st component text]
@


1.25
log
@	* library/interface.tcl (gdbtk_tcl_file_changed): Handle
	the case of empty-string files, sent by gdb when the
	user requests to reset the file.
	(_close_file): New proc to deal with closing an exe.
	* library/srcbar.itcl (create_file_menu): Add "Close" menu
	option.
	(create_view_menu): Change key binding for Watch Window to
	Ctrl+T to accomodate "Close" going to Ctrl+W.
	* library/srctextwin.itb (config_win): Update key binding
	for Watch Window.
	Add key binding for Close.
	(do_key): Add "close".
	(_clear_cache): Finally implement. I think this works now.
@
text
@d2317 1
a2317 1
      ignore_count commands cond thread hit_count
@


1.24
log
@Other half of SetVariableEvent:

	* library/srctextwin.ith (handle_set_hook): Rename to set_variable.
	* library/srctextwin.itb (set_variable): Handle SetVariableEvent.
	(constructor): Remove gdb_set_hook.
	(destructor): Ditto.
	* library/srcbar.itcl: Inherit from GDBEventHandler.
	(set_hook): Rename to set_variable and handle SetVariableEvent.
	(constructor): Remove gdb_set_hook.
	(destructor): Ditto.
	* library/regwin.ith (handle_set_hook): Renamed to set_variable.
	* library/regwin.itb (set_variable): Handle SetVariableEvent.
	(constructor): Remove gdb_set_hook.
	(destructor): Ditto.
	* library/kod.ith (set_os): Renamed to "set_variable".
	* library/kod.itb (set_variable): Handle SetVariableEvent.
	(constructor): Remove gdb_set_hook.
	(destructor): Ditto.
	* library/tclIndex: Regenerated.
@
text
@d598 2
a599 1
  
d658 1
a658 1
  bind_plain_key $win Control-w "$this do_key watch"
d2189 1
a2925 3
  # This doesn't work, and it's so darn entangled that it's nearly
  # impossible.
  return
d2937 6
a2942 3
      catch {$itk_interior.p delete $Stwc($p:pane)}
      unset Stwc($p:pane)
      unset Stwc($p:mtime)
d2945 7
@


1.23
log
@Breakpoint/tracepoint event notification using new event model...

	* generic/gdbtk-cmds.c (gdb_set_bp): Use create_breakpoint_hook
	to notify gui of changes.
	(gdb_set_bp_addr): Ditto.
	(gdb_get_breakpoint_info): Update comments to match reality.
	* generic/gdbtk-hooks.c (breakpoint_notify): Only pass the
	breakpoint number which generated the event.
	(tracepoint_notify): Ditto for tracepoints.
	* library/interface.tcl (gdb_breakpoint_change_hook): Mark
	as deprecated and comment out definition.
	(gdbtk_tcl_breakpoint): Use new GDBEvent event "breakpoint"
	to notify rest of UI about breakpoint event.
	(gdbtk_tcl_tracepoint): Ditto for "tracepoint" event.
	* library/bpwin.ith (update): Renamed to "breakpoint".
	(breakpoint): New public method.
	(tracepoint): New public method.
	(bp_add): Take event as argument instead of number.
	(bp_modify): Ditto.
	(bp_delete): Ditto.
	* library/bpwin.itb (constructor): Remove
	gdb_breakpoint_changed_hook.
	(destructor): Ditto.
	(build_win): Insert any existing breakpoints by
	making BreakpointEvents for them.
	(breakpoint): Renamed from "update" to handle
	breakpoint events.
	Remove code to deal with tracepoints.
	(tracepoint): New method to handle tracepoint
	events.
	(bp_add): Deal with breakpoint events, not breakpoint
	numbers.
	(bp_modify): Ditto.
	(bp_delete): Ditto.
	* library/srctextwin.ith: Inherit from GDBWin.
	(breakpoint): New public method.
	(tracepoint): New public method.
	* library/srctextwin.itb (constructor): Remove
	gdb_breakpoint_changed_hook.
	(destructor): Ditto.
	(breakpoint): New method to handle breakpoint event.
	(tracepoint): New method to handle tracepoint event.
	(do_bp): Handle duplicate breakpoints for asm, too.
	(remove_bp_at_line): Delete breakpoints by number, not
	linespec. clear_command removes breakpoints from the
	breakpoint_chain BEFORE deleting the breakpoint. delete_command
	does this afterward (so we can call gdb_get_breakpoint_info on
	an about-to-be-deleted breakpoint).
@
text
@a67 4
  if {[get_disassembly_flavor] != ""} {
    add_hook gdb_set_hook [code $this handle_set_hook]
  }

a85 3
  if {[get_disassembly_flavor] != ""} {
    remove_hook gdb_set_hook [code $this handle_set_hook]
  }
d710 1
a710 1
#  METHOD:  handle_set_hook - Handle changes in the gdb variables
d713 3
a715 1
body SrcTextWin::handle_set_hook {var val} {
@


1.22
log
@	* library/srctextwin.itb (config_win): Give focus to $win.
@
text
@d1 2
a2 2
 # Paned text widget for source code, for GDBtk.
# Copyright 1997, 1998, 1999 Cygnus Solutions
a62 2
  add_hook gdb_breakpoint_change_hook "$this bp"
  
a83 1
  remove_hook gdb_breakpoint_change_hook "$this bp"
d1454 22
d1484 1
a1484 1
  
d1523 1
a1523 1
  
d1528 1
a1528 1
  if {!$asm && $action == "delete" && [string compare $type tracepoint] != 0} {
d1531 9
a1539 1
    set bps [gdb_find_bp_at_line $current(filename) $linenum]
d1598 1
a1598 1
      dbug E "UNKNOWN BP TYPE $action $type"
d1933 1
a1933 1
  
d1937 6
a1942 5
  
  if {[string compare $type src] == 0} {
    gdb_cmd "clear $name:$addr"
  } else {
    gdb_cmd "clear *$addr"
d1944 3
@


1.21
log
@2001-02-06  Fernando Nasser  <fnasser@@redhat.com>

	Originally from Martin Hunt <hunt@@redhat.com>, with modifications
	* library/srcwin.itb (_name): Check for errors when invoking
	gdb_find_file.
	* library/srctextwin.itb (_mtime_changed, location): Ditto.
	* generic/gdbtk-cmds.c (gdb_find_file_command): Better error checking.
	(full_lookup_symtab): Fix misleading comment.
@
text
@d692 3
d1217 2
d1240 7
@


1.20
log
@Fix previous checkout of this:
2001-01-18  Fernando Nasser  <fnasser@@redhat.com>

        * library/srctextwin.itb (_highlightAsmLine): Add missing FUNCNAME
	parameter.
        (FillAssembly, FillMixed): Pass the FUNCNAME parameter that is
        needed by the above method.
        * library/srctextwin.ith (_highlightAsmLine): Add FUNCNAME parameter
	to method definition.
@
text
@d891 3
a893 3
  set f [gdb_find_file $filename]

  if {$f == ""} {
d1201 7
a1207 1
    if {[gdb_find_file $filename] != ""} {
@


1.19
log
@2001-01-18  Fernando Nasser  <fnasser@@redhat.com>

        * library/srctextwin.itb (_highlightAsmLine): Add missing FUNCNAME
	parameter.
        (FillAssembly, FillMixed): Pass the FUNCNAME parameter that is
        needed by the above method.
        * library/srctextwin.ith (_highlightAsmLine): Add FUNCNAME parameter
	to method definition.
@
text
@d1130 2
a1131 1
body SrcTextWin::_highlightAsmLine {win addr pc_addr tagname filename funcname} {
@


1.18
log
@2001-01-17  Fernando Nasser  <fnasser@@redhat.com>

        * library/srctextwin.itb (_highlightAsmLine): Add missing FILENAME
	parameter.
        (FillAssembly, FillMixed): Pass the FILENAME parameter that is
        needed by the above method.
        * library/srctextwin.ith (_highlightAsmLine): Add FILENAME parameter
	to method definition.
@
text
@d1063 1
a1063 1
  _highlightAsmLine $win $addr $pc_addr $tagname $filename
d1122 1
a1122 1
  _highlightAsmLine $win $addr $pc_addr $tagname $filename
d1130 1
a1130 1
body SrcTextWin::_highlightAsmLine {win addr pc_addr tagname filename} {
@


1.17
log
@	* tclIndex: Rebuilt.
	* interface.tcl (set_exe_name): Save session.
	(gdbtk_quit_check): Save session.
	* session.tcl: New file.
	* srcbar.tcl (create_menu_items): Add menu items to recall old
	sessions.
@
text
@d1063 1
a1063 1
  _highlightAsmLine $win $addr $pc_addr $tagname
d1122 1
a1122 1
  _highlightAsmLine $win $addr $pc_addr $tagname
d1130 1
a1130 1
body SrcTextWin::_highlightAsmLine {win addr pc_addr tagname} {
@


1.16
log
@	* bpwin.itb (BpWin::goto_bp): Handle multiple source windows.
	* srctextwin.itb (SrcTextWin::get_file): New method.
	(SrcTextWin::set_tag_to_stack): New method.
	* srctextwin.ith (get_file): Declare.
	* srcwin.ith (update_hook_init, window_list, pc_window): New
	common variables.
	(_choose_window, choose_and_update, is_fixed, get_file): Declare.
	* srcwin.itb (SrcWin::_choose_window): New method.
	(SrcWin::choose_and_update): Likewise.
	(SrcWin::_update): Renamed from update.  Now private.  Added `loc'
	argument.
	(SrcWin::get_file): New method.
	(SrcWin::is_fixed): Likewise.
	(SrcWin::constructor): Only add update hook once.  Append this
	object to window list.
	(SrcWin::destructor): Don't add update hook.  Remove this object
	from window list.  Clear pc_window if necessary.
	(SrcWin::get_top): New method.
	(SrcWin::_set_tag_to_stack): New method.
	(SrcWin::choose_and_display): New method.
@
text
@d2099 1
a2099 1
  
@


1.15
log
@	* srctextwin.itb (SrcTextWin::do_source_popup): Added "Set
	Breakpoint" to popup menu.
@
text
@d1163 16
d1598 1
a1598 1
#  METHOD:  report_current_location  
d2817 7
a2898 2


@


1.14
log
@	* srctextwin.ith (enable_disable_at_line): Declare.
	* srctextwin.itb (SrcTextWin::build_popups): Create popup for
	disabled breakpoint.  Add "disable" to breakpoint menu.
	(enable_disable_at_line): New method.
	(SrcTextWin::do_bp): Don't remove the tag we are adding -- remove
	the "opposite" tag.
@
text
@d2070 2
@


1.13
log
@Reverted erroneous checkin.  Sorry about that.
@
text
@d174 2
a175 1
  
d224 4
d284 1
a284 1
    
d292 11
a302 1
  
a310 1
  
d544 7
a550 1
      $win tag bind ${type}_tag <Button-3> "$this do_tag_popup bp %X %Y %y; break"
d715 1
d1347 1
a1347 1
    
a1351 1
    
d1511 1
a1511 1
  
d1515 1
d1522 1
d1526 1
d1530 1
d1541 1
a1541 1
  
d1545 2
a1546 2
    if {[string compare $action "modify"] == 0} {
      removeBreakTag $win $linenum $tag_type
d1813 46
@


1.12
log
@	* prefs.tcl (pref_save): Put version number into file.  Added
	`session' to list of top-level keys.  Allow keys with many `/'s.
	(pref_read): Recognize version number.
	(escape_value): Generate URL-style encoding.
	(unescape_value): Added `version' argument.  Handle URL decoding.
@
text
@a694 1

a1141 16
# METHOD: set_tag - update tag to STACK without making other changes
# ------------------------------------------------------------------
body SrcTextWin::set_tag_to_stack {} {
  foreach window [list $twin $bwin] {
    if {$window == ""} then {
      continue
    }
    foreach {start end} [$window tag ranges PC_TAG] {
      $window tag remove PC_TAG $start $end
      $window tag add STACK_TAG $start $end
    }
  }
  set current(tag) STACK_TAG
}

# ------------------------------------------------------------------
d1558 1
a1558 1
#  METHOD:  report_source_location
a2728 7
#  METHOD:  get_file - Return name of current file.
# ------------------------------------------------------------------
body SrcTextWin::get_file {} {
  return $current(filename)
}

# ------------------------------------------------------------------
d2804 2
@


1.11
log
@2000-10-11  Fernando Nasser  <fnasser@@cygnus.com>

	* srctextwin.itb (build_popups): Fix typos that caused duplicate
	"Jump to Here" menu entries in the breakpoint-set right-click pop-up
	menu.
@
text
@d695 1
d1143 16
d1575 1
a1575 1
#  METHOD:  report_current_location  
d2746 7
a2827 2


@


1.10
log
@2000-10-04  Fernando Nasser  <fnasser@@totem.to.cygnus.com>

	* download.itb (download_it): Fix previous changes for non-windows
	hosts.
	* srctextwin.itb (LoadFromCache): Ditto.
@
text
@d242 1
a242 1
      addPopup bp "Jump to Here" "$this jump_to_here" {} 0 0
d275 1
a275 1
      addPopup bp "Jump to Here" "$this jump_to_here" \
@


1.9
log
@2000-10-04  Fernando Nasser  <fnasser@@totem.to.cygnus.com>

	* download.itb (download_it): Convert filename to native before
	passing it to a Tcl command.
	* srctextwin.itb (_mtime_changed): Ditto.
	(LoadFromCache): Ditto.
@
text
@d2573 2
@


1.8
log
@2000-08-10  Fernando Nasser  <fnasser@@cygnus.com>

	* srctextwin.itb (jump_to_here): New method. Implements the
	"Jump to Here" popup menu option.
	(build_popups): Add the "Jump to Here" option to the popup menu.
	* srctextwin.ith: Add declaration of jump_to_here().
@
text
@d868 2
d875 8
a882 1
    set mtime [file mtime $f]
d965 1
a965 1
#  debug "no source file; switch to assembly"
d1218 1
a1218 1
#    debug "READING $name"
d2080 1
a2080 1
#  debug "$new_mode"
d2522 1
d2525 1
d2539 1
a2539 1
    #debug "READING CACHE $full_name->$Stwc($full_name:pane)"
d2571 5
a2575 2
      if {[catch {file mtime $name} file_time]} {
	debug "Could not stat file \"$name\" - \"$file_time\""
@


1.7
log
@2000-08-08  Fernando Nasser  <fnasser@@cygnus.com>

	* srctxtwin.itb (FillSource): Add comments.
@
text
@d192 2
d221 1
d242 1
d275 2
d1694 46
@


1.6
log
@2000-08-08  Fernando Nasser  <fnasser@@cygnus.com>

	* srctxtwin.itb (LoadFromCache): Do not cache if cannot stat the file.
	This lead to problems trying to access a incomplete cache entry later.
@
text
@d904 4
d914 1
d951 4
d961 1
@


1.5
log
@2000-04-27  James Ingham  <jingham@@leda.cygnus.com>

	These changes allow Insight to handle the case where there are
	symbols for the source files, but the source files are not in the
	location pointed to by the symbol.

	* srctextwin.itb (SrcTextWin::setTabs): Make the "asm" type for
	the source display "S" not "", which is not very clear.
        (SrcTextWin::configWin): ditto.
	(SrcTextWin::FillAssembly): Handle all return values from
	LoadFromCache.
	* (SrcTextWin::LoadFile): Handle "couldn't find file" return from
	LoadFromCache.
	* (SrcTextWin::LoadFromCache): If the source file could not be
	found, return -1 rather than choking.
	Also change "asm" type for source from "" to "S".
	* srctextwin.ith: Change the defaults for the "asm" type from ""
	to "S" for Source display.  This is just cosmetic, but clearer.
@
text
@a2491 1
    set Stwc($full_name:pane) pane$filenum
d2502 1
d2510 2
a2511 1

@


1.4
log
@	* console.itb (Console::_complete): Dequoted first argument to
	switch.  Window name is `$_twin', not `_twin'.
@
text
@d398 1
a398 1
body SrcTextWin::setTabs {win {asm ""}} {
d403 1
a403 1
  if {$asm != ""} {
d483 1
a483 1
body SrcTextWin::config_win {win {asm ""}} {
d566 1
a566 1
    if {$asm != ""} {
d983 2
a984 1
    if {[LoadFromCache $w $addr A $lib]} {
d1005 6
d1182 1
a1182 1
#  debug "$name $current(filename) $current(mode)"
d1187 5
a1191 1
  if {[LoadFromCache $w $name "" $lib] || $mtime_changed} {
d2438 3
a2440 1
#		asm	'A' for assembly mode, 'M' for mixed mode.
d2445 2
d2462 2
d2474 1
a2474 1
    if {$asm != ""} {
d2491 1
a2491 1
    #debug "name=$name"
d2493 18
a2510 4
    # Sometimes we get in here with no source file, in which case
    # name is a hex address.  Catch the error from this.
    if {[catch {file mtime $name} file_time]} {
      debug "Could not stat file: $name in LoadFromCache: $file_time"
a2511 2
    } else {
      set Stwc($name:mtime) $file_time
d2514 2
d2528 1
a2528 1
    if {$asm != ""} {
d2552 2
a2553 1
  append name "," $asm "," $lib
d2555 7
a2561 3
  unset Stwc($name:pane)
  unset Stwc($name:dirty)
  unset Stwc($name:mtime)
@


1.3
log
@2000-03-10  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

	* srcbar.tcl (do_attach): Just call gdbtk_attach_native.
        (do_connect): Replace gdbtk_attach_target call with
        gdbtk_attach_remote call.

	* interface.tcl (gdbtk_attach_native): Renamed from do_attach method
        and moved from srcbar.tcl.
        (gdbtk_attach_remote): New proc. Renamed from gdb_attach_target,
	to better distinguish from the native version.
        (run_executable): Change gdbtk_attach_target call into
        gdbtk_attach_remote.

        * srctextwin.itb: Add keyboard accelerator for Attach command.

        * tclIndex: Rebuild.
@
text
@d218 1
a218 1
      addPopup bp "Continue to Here" "$this continue_to_here" green 0 0
d222 1
a222 1
    addPopup bp "Delete Breakpoint" "$this remove_bp_at_line" $bp_fg 
@


1.2
log
@        * srctextwin.ith (_highlightAsmLine): Define new method.
        * srctextwin.itb (_highlightAsmLine): New method.
        (FillAssembly, FillMixed): Use _highlightAsmLine to highlight
        the current assembly line.
@
text
@d581 1
d1977 1
@


1.1
log
@Initial revision
@
text
@d1009 2
a1010 18
  if {[info exists _map($Cname,pc=$addr)]} {
    # if current file has PC, highlight that too
    if {$gdb_running && $tagname != "PC_TAG" && $pc(filename) == $filename
	&& $pc(func) == $funcname} {
      set pc(asm_line) $_map($Cname,pc=$pc_addr)
      $win tag add PC_TAG $pc(asm_line).2 $pc(asm_line).end
    }
    set current(asm_line) $_map($Cname,pc=$addr)
    # don't set browse tag if it is at PC
    if {$pc_addr != $addr || $tagname == "PC_TAG"} {
      # HACK.  In STACK mode we usually want the previous instruction
      # but not when we are browsing a trace experiment.
      if {[string compare $tagname "STACK_TAG"] == 0 && !$Browsing} {
	incr current(asm_line) -1
      }
      $win tag add $tagname $current(asm_line).2 $current(asm_line).end
    }
  }
d1066 1
d1068 13
d1082 5
a1086 5
    # if current file has PC, highlight that too
    if {$gdb_running && $tagname != "PC_TAG" && $pc(filename) == $filename
	&& $pc(func) == $funcname} {
      set pc(asm_line) $_map($Cname,pc=$pc_addr)
      $win tag add PC_TAG $pc(asm_line).2 $pc(asm_line).end
d1088 15
a1102 8
    set current(asm_line) $_map($Cname,pc=$addr)
#    debug "current(asm_line) = $current(asm_line)"
    if {$pc_addr != $addr || $tagname == "PC_TAG"} {
      # HACK.  In STACK mode we usually want the previous instruction
      if {$tagname == "STACK_TAG"} {
	incr current(asm_line) -1
      }
      $win tag add $tagname $current(asm_line).2 $current(asm_line).end
d1104 1
a1105 1
  display_line $win $current(asm_line)
@


1.1.1.1
log
@import insight-2000-02-04 snapshot (2nd try)
@
text
@@
