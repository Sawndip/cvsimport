head	1.26;
access;
symbols
	insight_7_6-2013-04-10-branchpoint:1.26
	gdb_7_6-branch:1.26.0.22
	gdb_7_5-branch:1.26.0.20
	gdb_7_4-branch:1.26.0.18
	gdb_7_3-branch:1.26.0.16
	gdb_7_1-branch:1.26.0.14
	gdb_7_0-branch:1.26.0.12
	arc-sim-20090309:1.26
	arc-insight_6_8-branch:1.26.0.10
	arc-insight_6_8-branchpoint:1.26
	insight_6_8-branch:1.26.0.8
	insight_6_8-branchpoint:1.26
	gdb_6_8-branch:1.26.0.6
	insight_6_6-20070208-release:1.26
	gdb_6_6-branch:1.26.0.4
	gdb_6_6-2006-11-15-branchpoint:1.26
	insight_6_5-20061003-release:1.26
	gdb_6_5-branch:1.26.0.2
	gdb_6_5-2006-05-14-branchpoint:1.26
	gdb-csl-gxxpro-6_3-branch:1.25.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.25
	gdb_6_4-branch:1.25.0.6
	gdb_6_4-2005-11-01-branchpoint:1.25
	gdb_6_1-2004-04-05-release:1.25
	gdb_6_1-branch:1.25.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.25
	gdb_6_0-2003-10-04-release:1.25
	gdb_6_0-branch:1.25.0.2
	gdb_6_0-2003-06-23-branchpoint:1.25
	gdb_5_3-2002-12-12-release:1.21
	gdb_5_3-branch:1.21.0.2
	gdb_5_3-2002-09-04-branchpoint:1.21
	gdb_5_2_1-2002-07-23-release:1.19
	gdb_5_2-2002-04-29-release:1.19
	gdb_5_2-branch:1.19.0.2
	gdb_5_2-2002-03-03-branchpoint:1.19
	gdb_5_1_1-2002-01-24-release:1.11
	cygnus_cvs_20020108_pre:1.17
	gdb_5_1_0_1-2002-01-03-branch:1.11.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.11
	gdb_5_1-2001-11-21-release:1.11
	gdb_s390-2001-09-26-branch:1.11.0.6
	gdb_s390-2001-09-26-branchpoint:1.11
	gdb_5_1-2001-07-29-branch:1.11.0.4
	gdb_5_1-2001-07-29-branchpoint:1.11
	dberlin-typesystem-branch:1.11.0.2
	dberlin-typesystem-branchpoint:1.11
	insight-precleanup-2001-01-01:1.7
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	insight-2000-02-04:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.26
date	2005.12.23.18.26.50;	author eliz;	state Exp;
branches;
next	1.25;

1.25
date	2003.01.21.21.58.21;	author hunt;	state Exp;
branches;
next	1.24;

1.24
date	2002.12.18.19.35.54;	author hunt;	state Exp;
branches;
next	1.23;

1.23
date	2002.10.15.21.19.50;	author hunt;	state Exp;
branches;
next	1.22;

1.22
date	2002.09.19.02.35.06;	author kseitz;	state Exp;
branches;
next	1.21;

1.21
date	2002.06.07.09.22.44;	author hunt;	state Exp;
branches;
next	1.20;

1.20
date	2002.03.05.22.22.19;	author hunt;	state Exp;
branches;
next	1.19;

1.19
date	2002.01.18.17.24.29;	author kseitz;	state Exp;
branches;
next	1.18;

1.18
date	2002.01.15.19.52.01;	author kseitz;	state Exp;
branches;
next	1.17;

1.17
date	2002.01.03.00.03.46;	author kseitz;	state Exp;
branches;
next	1.16;

1.16
date	2002.01.02.23.42.49;	author kseitz;	state Exp;
branches;
next	1.15;

1.15
date	2001.12.05.17.08.06;	author kseitz;	state Exp;
branches;
next	1.14;

1.14
date	2001.10.17.20.30.29;	author tromey;	state Exp;
branches;
next	1.13;

1.13
date	2001.10.13.00.16.17;	author tromey;	state Exp;
branches;
next	1.12;

1.12
date	2001.09.28.16.36.50;	author tromey;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.01.20.05.55;	author kseitz;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.31.20.32.57;	author kseitz;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.31.15.21.40;	author kseitz;	state Exp;
branches;
next	1.8;

1.8
date	2001.04.05.00.04.28;	author hunt;	state Exp;
branches;
next	1.7;

1.7
date	2000.12.08.20.17.03;	author tromey;	state Exp;
branches;
next	1.6;

1.6
date	2000.12.07.19.49.40;	author spolk;	state Exp;
branches;
next	1.5;

1.5
date	2000.12.04.19.29.01;	author tromey;	state Exp;
branches;
next	1.4;

1.4
date	2000.11.01.22.15.37;	author lsmith;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.14.14.45.37;	author tromey;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.10.16.49.30;	author jingham;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.07.00.19.42;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.07.00.19.42;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.26
log
@	* library/attachdlg.itb:
	* library/actiondlg.tcl:
	* library/about.tcl:
	* library/ehandler.itb:
	* library/editor.tcl:
	* library/download.ith:
	* library/download.itb:
	* library/debugwin.ith:
	* library/debugwin.itb:
	* library/cspref.ith:
	* library/cspref.itb:
	* library/console.ith:
	* library/console.itb:
	* library/browserwin.ith:
	* library/browserwin.itb:
	* library/bpwin.ith:
	* library/bpwin.itb:
	* library/blockframe.ith:
	* library/managedwin.ith:
	* library/managedwin.itb:
	* library/main.tcl:
	* library/locals.tcl:
	* library/ipcpref.ith:
	* library/ipcpref.itb:
	* library/ipc.tcl:
	* library/interface.tcl:
	* library/helpviewer.tcl:
	* library/globalpref.ith:
	* library/globalpref.itb:
	* library/gdbwin.ith:
	* library/gdbtoolbar.itcl:
	* library/gdbmenubar.itcl:
	* library/gdbevent.ith:
	* library/gdbevent.itb:
	* library/embeddedwin.ith:
	* library/ehandler.ith:
	* library/srcwin.itb:
	* library/srctextwin.ith:
	* library/srctextwin.itb:
	* library/srcpref.ith:
	* library/srcpref.itb:
	* library/srcbar.itcl:
	* library/session.tcl:
	* library/regwin.ith:
	* library/regwin.itb:
	* library/process.ith:
	* library/process.itb:
	* library/prefs.tcl:
	* library/pluginwin.itcl:
	* library/modal.tcl:
	* library/memwin.ith:
	* library/memwin.itb:
	* library/mempref.ith:
	* library/mempref.itb:
	* library/watch.tcl:
	* library/watch.tcl:
	* library/warning.tcl:
	* library/vartree.ith:
	* library/vartree.itb:
	* library/util.tcl:
	* library/tracedlg.tcl:
	* library/toplevelwin.ith:
	* library/tfind_args.tcl:
	* library/tdump.tcl:
	* library/targetselection.ith:
	* library/targetselection.itb:
	* library/stackwin.ith:
	* library/stackwin.itb:
	* library/srcwin.ith:
@
text
@# Console window for Insight
# Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003 Red Hat, Inc.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License (GPL) as published by
# the Free Software Foundation; either version 2 of the License, or (at
# your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.


itcl::body Console::constructor {args} {
  global gdbtk_state
  window_name "Console Window"

  debug "$args"
  _build_win
  eval itk_initialize $args
  add_hook gdb_no_inferior_hook [list $this idle dummy]
  
  # There are a bunch of console prefs that have no UI
  # for the user to modify them.  In the event that the user
  # really wants to change them, they will have to be modified
  # in prefs.tcl or by editing .gdbtkinit.  When these prefs
  # gain a prefs UI, the user may change them dynamically
  # and the console window will need notification that they
  # have changed.  Add them to the following list and
  # Console::_update_option.
  foreach option {gdb/console/wrap} {
    pref add_hook $option [code $this _update_option]
  }

  set gdbtk_state(console) $this
}

itcl::body Console::destructor {} {
  global gdbtk_state
  set gdbtk_state(console) ""
  remove_hook gdb_no_inferior_hook [list $this idle dummy]
}

itcl::body Console::_build_win {} {
  iwidgets::scrolledtext $itk_interior.stext \
    -vscrollmode dynamic -textbackground white

  set _twin [$itk_interior.stext component text]

  _set_wrap [pref get gdb/console/wrap]

  $_twin tag configure prompt_tag -foreground [pref get gdb/console/prompt_fg]
  $_twin tag configure err_tag -foreground [pref get gdb/console/error_fg]
  $_twin tag configure log_tag -foreground [pref get gdb/console/log_fg]
  $_twin tag configure target_tag -foreground [pref get gdb/console/target_fg]
  $_twin configure -font [pref get gdb/console/font] \
    -bg $::Colors(textbg) -fg $::Colors(textfg)
  
  #
  # bind editing keys for console window
  #
  bind $_twin <Return> "$this invoke; break"
  bind_plain_key $_twin Control-m "$this invoke; break"
  bind_plain_key $_twin Control-j "$this invoke; break"

  # History control.
  bind_plain_key $_twin Control-p "[code $this _previous]; break"
  bind $_twin <Up> "[code $this _previous]; break"
  bind_plain_key $_twin Control-n "[code $this _next]; break"
  bind $_twin <Down> "[code $this _next]; break"
  bind $_twin <Meta-less> "[code $this _first]; break"
  bind $_twin <Home> "[code $this _first]; break"
  bind $_twin <Meta-greater> "[code $this _last]; break"
  bind $_twin <End> "[code $this _last]; break"
  bind_plain_key $_twin Control-o "[code $this _operate_and_get_next]; break"

  # Tab completion
  bind_plain_key $_twin KeyPress-Tab "[code $this _complete]; break"
  
  # Don't let left arrow or ^B go over the prompt
  bind_plain_key $_twin Control-b {
    if {[%W compare insert <= {cmdmark + 1 char}]} {
      break
    }
  }
  bind $_twin <Left> [bind $_twin <Control-b>]

  # Don't let Control-h, Delete, or Backspace back up over the prompt.
  bind_plain_key $_twin Control-h "[code $this _delete]; break"

  bind $_twin <BackSpace> "[code $this _delete]; break"
  
  bind $_twin <Delete> "[code $this _delete 1]; break"

  # Control-a moves to start of line.
  bind_plain_key $_twin Control-a {
    %W mark set insert {cmdmark + 1 char}
    %W see {insert linestart}
    break
  }

  # Control-u deletes to start of line.
  bind_plain_key $_twin Control-u {
    %W delete {cmdmark + 1 char} insert
    %W see {insert linestart}
  }

  # Control-w deletes previous word.
  bind_plain_key $_twin Control-w {
    if {[%W compare {insert -1c wordstart} > cmdmark]} {
      %W delete {insert -1c wordstart} insert
      %W see insert
    }
  }

  bind $_twin <Control-Up> "[code $this _search_history]; break"
  bind $_twin <Shift-Up> "[code $this _search_history]; break"
  bind $_twin <Control-Down> "[code $this _rsearch_history]; break"
  bind $_twin <Shift-Down> "[code $this _rsearch_history]; break"

  # Don't allow key motion to move insertion point outside the command
  # area.  This is done by fixing up the insertion point after any key
  # movement.  We only need to do this after events we do not
  # explicitly override.  Note that since the edit line is always the
  # last line, we can't possibly go past it, so we don't bother
  # checking that.  Note also that we check for a binding which is
  # simply `;'; this lets us handle keys already bound via
  # bind_plain_key.
  foreach event [bind Text] {
    if {[string match *Key* $event]
	&& ([bind $_twin $event] == ""
	    || [bind $_twin $event] == ";")} {
      bind $_twin $event [bind Text $event]
      bind $_twin $event {+
	if {[%W compare insert <= {cmdmark + 1 char}]} {
	  %W mark set insert {cmdmark + 1 char}
	}
	break
      }
    }
  }

  # Don't allow mouse to put cursor outside command line.  For some
  # events we do this by noticing when the cursor is outside the
  # range, and then saving the insertion point.  For others we notice
  # the saved insertion point.
  set pretag pre-$_twin
  bind $_twin <1> [format {
    if {[%%W compare [tk::TextClosestGap %%W %%x %%y] <= cmdmark]} {
      %s _insertion [%%W index insert]
    } else {
      %s _insertion {}
    }
  } $this $this]
  bind $_twin <B1-Motion> [format {
    if {[%s _insertion] != ""} {
      %%W mark set insert [%s _insertion]
    }
  } $this $this $this]
  # FIXME: has inside information.
  bind $_twin <ButtonRelease-1> [format {
    tk::CancelRepeat
    if {[%s _insertion] != ""} {
      %%W mark set insert [%s _insertion]
    }
    %s _insertion {}
    break
  } $this $this $this]

  # Don't allow inserting text outside the command line.  FIXME:
  # requires inside information.
  # Also make it a little easier to paste by making the button
  # drags a little "fuzzy".
  bind $_twin <B2-Motion> {
    if {!$tk_strictMotif} {
      if {($tk::Priv(x) - 2 < %x < $tk::Priv(x) + 2) \
	    || ($tk::Priv(y) - 2 < %y < $tk::Priv(y) + 2)} {
	set tk::Priv(mouseMoved) 1
      }
      if {$tk::Priv(mouseMoved)} {
	%W scan dragto %x %y
      }
    }
    break
  }
  bind $_twin <ButtonRelease-2> [format {
    if {!$tk::Priv(mouseMoved) || $tk_strictMotif} {
      %s
      break
    }
  } [code $this _paste 1]]
  bind $_twin <<Paste>> "[code $this _paste 0]; break"
  bind $_twin <<PasteSelection>> "[code $this _paste 0]; break"
  bind_plain_key $_twin Control-c "event generate $_twin <<Copy>>"
  bind_plain_key $_twin Control-v "[code $this _paste 1]; break"

  _setprompt
  pack $itk_interior.stext -expand yes -fill both
    
  focus $_twin

}

itcl::body Console::idle {event} {
  set _running 0
  $_top configure -cursor {}
}

# ------------------------------------------------------------------
#  METHOD: busy - busy event handler
# ------------------------------------------------------------------
itcl::body Console::busy {event} {
  set _running 1
  $_top configure -cursor watch
}

# ------------------------------------------------------------------
#  METHOD:  insert - insert new text in the text widget
# ------------------------------------------------------------------
itcl::body Console::insert {line {tag ""}} {
  if {$_needNL} {
    $_twin insert {insert linestart} "\n"
  }
  # Remove all \r characters from line.
  set line [join [split $line \r] {}]
  $_twin insert {insert -1 line lineend} $line $tag

  set nlines [lindex [split [$_twin index end] .] 0]
  if {$nlines > $throttle} {
    set delta [expr {$nlines - $throttle}]
    $_twin delete 1.0 ${delta}.0
  }

  $_twin see insert
  set _needNL 0
  ::update idletasks
}

# ------------------------------------------------------------------
#  NAME:         ConsoleWin::_operate_and_get_next
#  DESCRIPTION:  Invokes the current command and, if this
#                command came from the history, arrange for
#                the next history command to be inserted once this
#                command is finished.
#
#  ARGUMENTS:    None
#  RETURNS:      Nothing
# ------------------------------------------------------------------
itcl::body Console::_operate_and_get_next {} {
  if {$_histElement >= 0} {
    # _pendingHistElement will be used after the new history element
    # is pushed.  So we must increment it.
    set _pendingHistElement [expr {$_histElement + 1}]
  }
  invoke
}

#-------------------------------------------------------------------
#  METHOD:  _previous - recall the previous command
# ------------------------------------------------------------------
itcl::body Console::_previous {} {
  if {$_histElement == -1} {
    # Save partial command.
    set _partialCommand [$_twin get {cmdmark + 1 char} {cmdmark lineend}]
  }
  incr _histElement
  set text [lindex $_history $_histElement]
  if {$text == ""} {
    # No dice.
    incr _histElement -1
    # FIXME flash window.
  } else {
    $_twin delete {cmdmark + 1 char} {cmdmark lineend}
    $_twin insert {cmdmark + 1 char} $text
  }
}

#-------------------------------------------------------------------
#  METHOD:  _search_history - search history for match
# ------------------------------------------------------------------
itcl::body Console::_search_history {} {
  set str [$_twin get {cmdmark + 1 char} {cmdmark lineend}]

  if {$_histElement == -1} {
    # Save partial command.
    set _partialCommand $str
    set ix [lsearch $_history ${str}*]
  } else {
    set str $_partialCommand
    set num [expr $_histElement + 1]
    set ix [lsearch [lrange $_history $num end] ${str}*]
    incr ix $num
  }

  set text [lindex $_history $ix]
  if {$text != ""} {
    set _histElement $ix
    $_twin delete {cmdmark + 1 char} {cmdmark lineend}
    $_twin insert {cmdmark + 1 char} $text
  }
}

#-------------------------------------------------------------------
#  METHOD:  _rsearch_history - search history in reverse for match
# ------------------------------------------------------------------
itcl::body Console::_rsearch_history {} {
  if {$_histElement != -1} {
    set str $_partialCommand
    set num [expr $_histElement - 1]
    set ix $num
    while {$ix >= 0} {
      if {[string match ${str}* [lindex $_history $ix]]} {
	break
      }
      incr ix -1
    }

    set text ""
    if {$ix >= 0} {
      set text [lindex $_history $ix]
      set _histElement $ix
    } else {
      set text $_partialCommand
      set _histElement -1
    }
    $_twin delete {cmdmark + 1 char} {cmdmark lineend}
    $_twin insert {cmdmark + 1 char} $text
  }
}

#-------------------------------------------------------------------
#  METHOD:  _next - recall the next command (scroll forward)
# ------------------------------------------------------------------
itcl::body Console::_next {} {
  if {$_histElement == -1} {
    # FIXME flash window.
    return
  }
  incr _histElement -1
  if {$_histElement == -1} {
    set text $_partialCommand
  } else {
    set text [lindex $_history $_histElement]
  }
  $_twin delete {cmdmark + 1 char} {cmdmark lineend}
  $_twin insert {cmdmark + 1 char} $text
}

#-------------------------------------------------------------------
#  METHOD:  _last - get the last history element
# ------------------------------------------------------------------
itcl::body Console::_last {} {
  set _histElement 0
  _next
}

#-------------------------------------------------------------------
#  METHOD:  _first - get the first (earliest) history element
# ------------------------------------------------------------------
itcl::body Console::_first {} {
  set _histElement [expr {[llength $_history] - 1}]
  _previous
}



#-------------------------------------------------------------------
#  METHOD:  _setprompt - put a prompt at the beginning of a line
# ------------------------------------------------------------------
itcl::body Console::_setprompt {{prompt {}}} {
  if {$prompt == ""} {
    #set prompt [pref get gdb/console/prompt]
    set prompt [gdb_prompt]
  } elseif {$prompt == "none"} {
    set prompt ""
  }
  
  $_twin delete {insert linestart} {insert lineend}
  $_twin insert {insert linestart} $prompt prompt_tag
  $_twin mark set cmdmark "insert -1 char"
  $_twin see insert

  if {$_pendingHistElement >= 0} {
    set _histElement $_pendingHistElement
    set _pendingHistElement -1
    _next
  }
}

#-------------------------------------------------------------------
#  METHOD:  gets - get a line of input from the console
# ------------------------------------------------------------------
itcl::body Console::gets {} {
  set _input_mode 1
#  _setprompt "(input) "
  _setprompt none
  $_twin delete insert end
  $_twin mark set cmdmark {insert -1 char}

  bind_plain_key $_twin Control-d "$this invoke 1; break"
  bind_plain_key $_twin Control-c "[code $this _cancel]; break"

  vwait [scope _input_result]
  set _input_mode 0
  bind_plain_key $_twin Control-c "event generate $_twin <<Copy>>"
  activate
  if {$_input_error} {
    set _input_error 0
    return -code error ""
  }
  return $_input_result
}

#-------------------------------------------------------------------
#  METHOD:  cancel - cancel input when ^C is hit
# ------------------------------------------------------------------
itcl::body Console::_cancel {} {
  if {$_input_mode} {
    set _needNL 1
    $_twin mark set insert {insert lineend}
    $_twin insert {insert lineend} "^C\n"
    incr _invoking
    set _input_error 1
    set _input_result ""
  }
}

#-------------------------------------------------------------------
#  METHOD:  activate - run this after a command is run
# ------------------------------------------------------------------
itcl::body Console::activate {{prompt {}}} {
  if {$_invoking > 0} {
    incr _invoking -1
    _setprompt $prompt
  }
}

#-------------------------------------------------------------------
#  METHOD:  invoke - invoke a command
# ------------------------------------------------------------------
itcl::body Console::invoke {{controld 0}} {
  global gdbtk_state

  set text [$_twin get {cmdmark + 1 char} end ]

  if { "[string range $text 0 1]" == "tk" } {
    if {! [info complete $text] } {
      $_twin insert {insert lineend} " \\\n"
      $_twin see insert
      return
    }
  }

  incr _invoking

  set text [string trimright $text \n]
  if {$text == ""} {
    set text [lindex $_history 0]
    $_twin insert {insert lineend} $text
  }
  $_twin mark set insert {insert lineend}
  $_twin insert {insert lineend} "\n"

  set ok 0
  if {$_running} {
    if {[string index $text 0] == "!"} {
      set text [string range $text 1 end]
      set ok 1
    }
  }

  if {$_input_mode} {
    if {!$controld} {append text \n}
    set _input_result $text
    set _needNL 1
    return
  }
  
  # Only push new nonempty history items.
  if {$text != "" && [lindex $_history 0] != $text} {
    lvarpush _history $text
  }
  
  set index [$_twin index insert]
  
  # Clear current history element, and current partial element.
  set _histElement -1
  set _partialCommand ""
  
  # Need a newline before next insert.
  set _needNL 1
  
  # run command
  if {$gdbtk_state(readline)} {
    set gdbtk_state(readline_response) $text
    return
  }

  if {!$_running || $ok} {
    set result [catch {gdb_immediate "$text" 1} message]
  } else {
    set result 1
    set message "The debugger is busy."
  }

  # gdb_immediate may take a while to finish.  Exit if
  # our window has gone away.
  if {![winfo exists $_twin]} { return }

  if {$result} {
    global errorInfo
    dbug W "Error: $errorInfo\n"
    $_twin insert end "Error: $message\n" err_tag
  } elseif {$message != ""} {
    $_twin insert $index "$message\n"
  }
  
  # Make the prompt visible again.
  activate
  
  # Make sure the insertion point is visible.
  $_twin see insert
}

#-------------------------------------------------------------------
#  PRIVATE METHOD:  _delete - Handle a Delete of some sort.
# ------------------------------------------------------------------
itcl::body Console::_delete {{right 0}} {

  # If we are deleting to the right, and we have this turned off,
  # delete to the right.
  
  if {$right && ![pref get gdb/console/deleteLeft]} {
    set right 0
  }
  
  if {!$right} {
    set insert_valid [$_twin compare insert > {cmdmark + 1 char}]
    set delete_loc "insert-1c"
  } else {
    set insert_valid [$_twin compare insert > cmdmark]
    set delete_loc "insert"
  }
  
  # If there is a selection on the command line, delete it,
  # If there is a selection above the command line, do a
  # regular delete, but don't delete the prompt.
  # If there is no selection, do the delete.
  
  if {![catch {$_twin index sel.first}]} {
    if {[$_twin compare sel.first <= cmdmark]} {
      if {$insert_valid} {
	$_twin delete $delete_loc
      }
    } else {
      $_twin delete sel.first sel.last
    }
  } elseif {$insert_valid} {
    $_twin delete $delete_loc
  }
}

#-------------------------------------------------------------------
#  PRIVATE METHOD:  _insertion - Set or get saved insertion point
# ------------------------------------------------------------------
itcl::body Console::_insertion {args} {
  if {! [llength $args]} {
    return $_saved_insertion
  } else {
    set _saved_insertion [lindex $args 0]
  }
}

# ------------------------------------------------------------------
#  METHOD:  _paste - paste the selection into the console window
# ------------------------------------------------------------------
itcl::body Console::_paste {{check_primary 1}} {
  set sel {}

  if {!$check_primary || [catch {selection get} sel] || $sel == ""} {
    if {[catch {selection get -selection CLIPBOARD} sel] || $sel == ""} {
      return
    }
  }

  #if there is a selection, insert over it:
  if {![catch {$_twin index sel.first}] 
      && [$_twin compare sel.first > {cmdmark + 1 char}]} {
    set point [$_twin index sel.first]
    $_twin delete sel.first sel.last
    $_twin insert $point $sel
  } else {
    $_twin insert insert $sel
  }
}

# ------------------------------------------------------------------
#  METHOD:  _find_lcp - Return the longest common prefix in SLIST.
#              Can be empty string.
# ------------------------------------------------------------------
itcl::body Console::_find_lcp {slist} {
  # Handle trivial cases where list is empty or length 1
  if {[llength $slist] <= 1} {return [lindex $slist 0]}

  set prefix [lindex $slist 0]
  set prefixlast [expr [string length $prefix] - 1]

  foreach str [lrange $slist 1 end] {
    set test_str [string range $str 0 $prefixlast]
    while {[string compare $test_str $prefix] != 0} {
      incr prefixlast -1
      set prefix [string range $prefix 0 $prefixlast]
      set test_str [string range $str 0 $prefixlast]
    }
    if {$prefixlast < 0} break
  }
  return $prefix
}

# ------------------------------------------------------------------
#  METHOD:  _find_completion - Look through COMPLETIONS to generate
#             the suffix needed to do command
# ------------------------------------------------------------------
itcl::body Console::_find_completion {cmd completions} {
  # Get longest common prefix
  set lcp [_find_lcp $completions]
  set cmd_len [string length $cmd]
  # Return suffix beyond end of cmd
  return [string range $lcp $cmd_len end]
}

# ------------------------------------------------------------------
#  METHOD: _complete - Command line completion
# ------------------------------------------------------------------
itcl::body Console::_complete {} {

  set command_line [$_twin get {cmdmark + 1 char} {cmdmark lineend}]
  set choices [gdb_cmd "complete $command_line" 1]
  set choices [string trimright $choices \n]
  set choices [split $choices \n]

  # Just do completion if this is the first tab
  if {!$_saw_tab} {
    set _saw_tab 1
    set completion [_find_completion $command_line $choices]

    # Here is where the completion is actually done.  If there
    # is one match, complete the command and print a space.
    # If two or more matches, complete the command and beep.
    # If no match, just beep.
    switch [llength $choices] {
      0 {}
      1 {
	$_twin insert end "$completion "
	set _saw_tab 0
	return
      }

      default {
	$_twin insert end $completion
      }
    }
    bell
    $_twin see end
    bind $_twin <KeyPress> [code $this _reset_tab]
  } else {
    # User hit another consecutive tab.  List the choices.
    # Note that at this point, choices may contain commands
    # with spaces.  We have to lop off everything before (and
    # including) the last space so that the completion list
    # only shows the possibilities for the last token.
    set choices [lsort $choices]
    if {[regexp ".* " $command_line prefix]} {
      regsub -all $prefix $choices {} choices
    }
    if {[llength choices] != 0} {
      insert "\nCompletions:\n[join $choices \ ]\n"
      $_twin see end
      bind $_twin <KeyPress> [code $this _reset_tab]
    }
  }
}

# ------------------------------------------------------------------
#  METHOD:  _reset_tab - Helper method for tab completion. Used
#             to reset the tab when a key is pressed.
# ------------------------------------------------------------------
itcl::body Console::_reset_tab {} {
  bind $_twin <KeyPress> {}
  set _saw_tab 0
}


# ------------------------------------------------------------------
#  METHOD:  _set_wrap - Set wrap mode
# ------------------------------------------------------------------
itcl::body Console::_set_wrap {wrap} {
  if { $wrap } {
    set hsm none
    set wv char
  } else {
    set hsm dynamic
    set wv none
  }

  $itk_interior.stext configure -hscrollmode $hsm
  $_twin configure -wrap $wv
}

# ------------------------------------------------------------------
#  METHOD:  _update_option - Update in response to preference change
# ------------------------------------------------------------------
itcl::body Console::_update_option {name value} {
  switch -- $name {
    gdb/console/wrap {
      _set_wrap $value
    }

    gdb/console/prompt_fg {
      $_twin tag configure prompt_tag -foreground $value
    }

    gdb/console/error_fg {
      $_twin tag configure err_tag -foreground $value
    }
  }
}

# ------------------------------------------------------------------
#  NAME:         public method Console::test
#  DESCRIPTION:  Executes the given command
#
#  ARGUMENTS:    Command to run
#  RETURNS:      Return value of command
#
#  NOTES:        This will only run if env(GDBTK_TEST_RUNNING)==1.
#                FOR TESTING ONLY
# ------------------------------------------------------------------
itcl::body Console::test {args} {
  global env

  if {[info exists env(GDBTK_TEST_RUNNING)] && $env(GDBTK_TEST_RUNNING) == 1} {
    return [eval $args]
  }
}

@


1.25
log
@2003-01-21  Martin M. Hunt  <hunt@@redhat.com>
	* library/main.tcl: Don't require iwidgets 3.0.

	* library/console.itb (Console::_build_win): Rename
	tkTextClosestGap to tk::TextClosestGap. Rename tkCancelRepeat
	to tk::CancelRepeat. Rename tkPriv to tk::Priv. Needed for tk 8.4.1.

	* library/bpwin.itb (BpWin::build_win): Don't
	create sizebox.
	* library/locals.tcl (build_win): Ditto.
	* library/regwin.itb (RegWin::_build_win): Ditto.
	* library/srcwin.itb (SrcWin::constructor): Ditto.
	* library/stackwin.itb (StackWin::build_win): Ditto.
	* library/watch.tcl (build_win): Ditto.
@
text
@d2 1
a2 1
# Copyright 1998, 1999, 2000, 2001, 2002, 2003 Red Hat, Inc.
@


1.24
log
@2002-12-17  Martin M. Hunt  <hunt@@redhat.com>

	* library/interface.tcl (gdbtk_tcl_fputs_target_err):
 	New function.
	(gdbtk_tcl_fputs_target): Open console window if it is
	not already open.
	(gdbtk_gets): New function.
	Opens a console window if necessary and calls Console::gets.

	* library/console.ith (gets): Declare method.
	(_input_mode): New private variable.
	(_input_result): Ditto.
	(_input_error): Ditto.
	(_cancel): New private method
	(invoke): Add arg.

	* library/console.itb (_setprompt): Allow setting prompt
	to nothing.  Delete to beginning of line before writing prompt.
	(gets): New public method to prompt user for input.
	(_cancel): New private method to handle ^C when inputting data.
	(invoke): Check for ^d when in input mode.
@
text
@d2 1
a2 1
# Copyright 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
d150 1
a150 1
    if {[%%W compare [tkTextClosestGap %%W %%x %%y] <= cmdmark]} {
d163 1
a163 1
    tkCancelRepeat
d177 3
a179 3
      if {($tkPriv(x) - 2 < %x < $tkPriv(x) + 2) \
	    || ($tkPriv(y) - 2 < %y < $tkPriv(y) + 2)} {
	set tkPriv(mouseMoved) 1
d181 1
a181 1
      if {$tkPriv(mouseMoved)} {
d188 1
a188 1
    if {!$tkPriv(mouseMoved) || $tk_strictMotif} {
@


1.23
log
@2002-10-15  Martin M. Hunt  <hunt@@redhat.com>

	* library/* : auto_mkindex cannot rebuild
	tclIndex because it does not recognize the namespace
	import in main.tcl.  To get it to work again, rename the
	following:
		body -> itcl::body
		configbody -> itcl::configbody
		class -> itcl::class
@
text
@d372 1
a372 5
  if {$_invoking} {
    set prompt ""
  } elseif {"$prompt" != ""} {
    # nothing
  } else {
d375 2
d378 2
a379 1

d392 38
d442 1
a442 1
itcl::body Console::invoke {} {
d473 7
@


1.22
log
@        * library/console.itb (_build_win): Bind control-c and control-v
        to copy and paste.
@
text
@d15 1
a15 1
body Console::constructor {args} {
d39 1
a39 1
body Console::destructor {} {
d45 1
a45 1
body Console::_build_win {} {
d205 1
a205 1
body Console::idle {event} {
d213 1
a213 1
body Console::busy {event} {
d221 1
a221 1
body Console::insert {line {tag ""}} {
d250 1
a250 1
body Console::_operate_and_get_next {} {
d262 1
a262 1
body Console::_previous {} {
d282 1
a282 1
body Console::_search_history {} {
d307 1
a307 1
body Console::_rsearch_history {} {
d335 1
a335 1
body Console::_next {} {
d353 1
a353 1
body Console::_last {} {
d361 1
a361 1
body Console::_first {} {
d371 1
a371 1
body Console::_setprompt {{prompt {}}} {
d395 1
a395 1
body Console::activate {{prompt {}}} {
d405 1
a405 1
body Console::invoke {} {
d485 1
a485 1
body Console::_delete {{right 0}} {
d523 1
a523 1
body Console::_insertion {args} {
d534 1
a534 1
body Console::_paste {{check_primary 1}} {
d558 1
a558 1
body Console::_find_lcp {slist} {
d581 1
a581 1
body Console::_find_completion {cmd completions} {
d592 1
a592 1
body Console::_complete {} {
d645 1
a645 1
body Console::_reset_tab {} {
d654 1
a654 1
body Console::_set_wrap {wrap} {
d670 1
a670 1
body Console::_update_option {name value} {
d696 1
a696 1
body Console::test {args} {
@


1.21
log
@2002-06-07  Martin M. Hunt  <hunt@@redhat.com>

	* library/prefs.tcl (pref_set_colors): New function.  Set up colors
	from Windows system colors or X resource database. Save in array.
	(pref_set_defaults): Remove gdb/font/normal_fg, etc.
	(pref_read): Call pref_set_colors.

	* library/main.tcl: Remove call to "tix resetoptions TixGray".

	* library/bpwin.itb, library/browserwin.itb, library/console.itb,
	library/globalpref.itb, library/memwin.itb, library/process.itb,
	library/regwin.itb, library/srcpref.itb, library/srctextwin.itb,
	library/stackwin.itb, library/tdump.tcl, library/tracedlg.tcl,
	library/variables.tcl: Replace calls to [pref get gdb/fonts/*]
	for colors with references to Color array. Remove all tixOptions calls.
	Fix up colors as necessary.
@
text
@d195 3
a197 1
  
@


1.20
log
@2002-03-05  Martin M. Hunt  <hunt@@redhat.com>

	* library/prefs.tcl (pref_read): If a preference specifies
	"src-font", substitute "global/fixed".
	(pref_set_defaults): Change defaults from "src-font" to
	"global/fixed". Do not create font object "src-font". Do
	not add hook to trace its changes.
	(pref_src-font_trace): Remove.

	* library/console.itb (Console::_update_option): Remove
	font update because this happens automatically.

	* library/globalpref.itb: No need to set
	changed flag for fonts; updates happen automatically
	when prefs are updated.

	* library/bpwin.itb: Replaced src-font with global/fixed.
	* library/browserwin.itb: Ditto.
	* library/mempref.itb: Ditto.
	* library/memwin.itb: Ditto.
	* library/process.itb: Ditto.
	* library/regwin.itb: Ditto.
	* library/srcbar.itcl: Ditto.
	* library/srcpref.itb: Ditto.
	* library/srctextwin.itb: Ditto.
	* library/srcwin.itb: Ditto.
	* library/stackwin.itb: Ditto.
	* library/tdump.tcl: Ditto.
	* library/tracedlg.tcl: Ditto.
	* library/variables.tcl: Ditto.
	* library/watch.tcl: Ditto.
@
text
@d57 3
a59 2
  $_twin configure -font [pref get gdb/console/font]

@


1.19
log
@        * library/console.ith (get_text): Delete.
        (test): New public method.
        * library/console.itb (get_text): Delete.
        (test): New public method.
@
text
@d23 12
a34 11

  # Right now the preferences window directly uses preference
  # variables.  This means that if we track the preference changes
  # here, things will appear weird to the user -- the console window
  # will change before the user chooses Accpet in the prefs window.
  # Until the preference window is fixed we can't enable this
  # dynamic tracking.  FIXME.
  # foreach option {gdb/console/wrap gdb/console/prompt_fg \
  #		    gdb/console/error_fg gdb/console/font} {
  #  pref add_hook $option [code $this _update_option]
  # }
a42 5

  # foreach option {gdb/console/wrap gdb/console/prompt_fg \
  # 		    gdb/console/error_fg gdb/console/font} {
  #   pref remove_hook $option [code $this _update_option]
  # }
a678 4
    }

    gdb/console/font {
      $_twin configure -font $value
@


1.18
log
@update copyrights (dates verified with cvs)
@
text
@a554 5
# public method for testing only
body Console::get_text {} {
  return $_twin
}

d690 19
@


1.17
log
@Update copyright.
@
text
@d2 1
a2 1
# Copyright 1998, 1999, 2001, 2002 Red Hat, Inc.
@


1.16
log
@	* library/console.ith (insert): Add tag parameter.
	(einsert): Delete.
	* library/console.itb: (insert): Add tag parameter.
	(einsert): Delete.
	* library/interface.tcl (gdbtk_tcl_fputs): Use Console::insert.
	(gdbtk_tcl_fputs_error): Likewise.
	(gdbtk_tcl_fputs_log): Likewise.
	(gdbtk_tcl_fputs_target): Likewise.
	(set_target): Likewise.
@
text
@d2 1
a2 1
# Copyright 1998, 1999, 2001 Cygnus Solutions
@


1.15
log
@	* library/console.itb (busy): Set the cursor to the watch.
	(idle): Reset cursor to normal.
@
text
@d222 1
a222 1
body Console::insert {line} {
d228 1
a228 1
  $_twin insert {insert -1 line lineend} $line
a238 13
}

#-------------------------------------------------------------------
#  METHOD:  einsert - insert error text in the text widget
# ------------------------------------------------------------------
body Console::einsert {line tag} {
  debug $line
  if {$_needNL} {
    $_twin insert end "\n"
  }
  $_twin insert end $line $tag
  $_twin see insert
  set _needNL 0
@


1.14
log
@	* console.itb (Console::_build_win): Handle bindings which
	are ";".  Also, completely override underlying Text binding.
@
text
@d208 1
d216 1
@


1.13
log
@	* library/console.itb (Console::_build_win): Bind Control-m and
	Control-j.
@
text
@d111 1
a111 1
  
d130 3
a132 1
  # checking that.
d134 5
a138 2
    if {[string match *Key* $event] && [bind $_twin $event] == ""} {
      bind $_twin $event {
d142 1
@


1.12
log
@	* library/console.itb (Console::_operate_and_get_next): New method.
	(Console::_setprompt): Insert next history element if requested.
	(Console::_build_win): Bind C-o to _operate_and_get_next.
	* library/console.ith (_operate_and_get_next): Declare.
	(_pendingHistElement): New variable.
@
text
@d67 2
@


1.11
log
@	* library/console.itb (constructor): Pass dummy argument
	to idle method.
	(destructor): Ditto.
@
text
@a67 3
  # disable this
  bind_plain_key $_twin Control-o "break"

d77 2
a78 1
  
d244 19
d388 6
@


1.10
log
@	* library/interface.tcl (gdb_idle_hook): Mark as deprecated.
	(gdbtk_idle): Dispatch an IdleEvent. gdb_idle_hook is gone.
	* library/ehandler.ith (idle): New event handler.
	* library/gdbevent.ith (IdleEvent): New event.
	* library/console.ith (idle): Match event handler definition.
	* library/console.itb (idle): Ditto.
	(constructor): Remove gdb_idle_hook.
	(destructor): Ditto.
	* library/kod.ith (idle): Match event handler definition.
	* library/kod.itb (idle): Ditto.
	(constructor): Remove gdb_idle_hook.
	(destructor): Ditto.
	* library/memwin.ith (idle): Match event handler definition.
	* library/memwin.itb (idle): Ditto.
	(constructor): Remove gdb_idle_hook.
	(destructor): Ditto.
	* library/pluginwin.itcl (stopped): Rename to "idle" and
	match event handler definition.
	Fix misleading comments.
	* library/process.ith (idle): Match event handler definition.
	* library/process.itb (idle): Ditto.
	(constructor): Remove gdb_idle_hook.
	(destructor): Ditto.
	* library/regwin.ith (idle): Match event handler definition.
	* library/regwin.itb (idle): Ditto.
	(constructor): Remove gdb_idle_hook.
	(destructor): Ditto.
	* library/srcbar.itcl (idle): New method.
	(constructor): Remove gdb_idle_hook.
	(destructor): Ditto.
	* library/srcwin.ith (idle): Match event handler definition.
	* library/srcwin.itb (idle): Ditto.
	(constructor): Remove gdb_idle_hook.
	(destructor): Ditto.
	* library/stackwin.ith (idle): Match event handler definition.
	* library/stackwin.itb (idle): Ditto.
	(constructor): Remove gdb_idle_hook.
	(destructor): Ditto.
	* library/variables.tcl (idle): Match event handler definition.
	(constructor): Remove gdb_idle_hook.
	(destructor): Ditto.
	* library/plugins/rhabout/rhabout.itcl (stopped): Rename
	to "idle" and match new event handler definition.
	* library/tclIndex: Regenerated.
@
text
@d22 1
a22 1
  add_hook gdb_no_inferior_hook [list $this idle]
d41 1
a41 1
  remove_hook gdb_no_inferior_hook [list $this idle]
@


1.9
log
@	* library/interface.tcl (gdb_busy_hook): Deprecate.
	(gdbtk_busy): Create and dispatch a BusyEvent instead
	of running hooks.
	* library/ehandler.ith (busy): New event handler.
	* library/gdbevent.ith (BusyEvent): New event class.
	* library/console.ith: Inherit from GDBEventHandler.
	(busy): Match event handler definition.
	* library/console.itb (busy): Ditto.
	(constructor): Remove gdb_busy_event.
	(destructor): Ditto.
	* library/kod.ith (busy): Match event handler definition.
	* library/kod.itb (busy): Ditto.
	(constructor): Remove gdb_busy_hook.
	(destructor): Ditto.
	* library/memwin.ith (busy): Match event handler definition.
	* library/memwin.itb (busy): Ditto.
	(constructor): Remove gdb_busy_hook.
	(destructor): Ditto.
	* library/pluginwin.itcl (running): Rename to "busy" and
	match event handler definition.
	(consturctor): Remove gdb_busy_hook.
	(destructor): Ditto.
	* library/process.ith (busy): Match event handler definition.
	* library/process.itb (busy): Ditto.
	(constructor): Remove gdb_busy_hook.
	(destructor): Ditto.
	* library/regwin.ith (busy): Match event handler definition.
	* library/regwin.itb (busy): Ditto.
	(constructor): Remove gdb_busy_hook.
	(destructor): Ditto.
	* library/srcbar.itcl (constructor): Remove gdb_busy_hook.
	(destructor): Ditto.
	(busy): New method.
	* library/srcwin.ith (busy): Match event handler definition.
	* library/srcwin.itb (busy): Ditto.
	Only do the "busy" stuff if do_updates is set.
	(toggle_updates): Remove gdb_busy_hook.
	(constructor): Ditto.
	(destructor): Ditto.
	* library/stackwin.ith (busy): Match event handler definition.
	* library/stackwin.itb (busy): Ditto.
	(constructor): Remove gdb_busy_hook.
	(destructor): Ditto.
	* library/variables.tcl (constructor): Ditto.
	(destructor): Ditto.
	(disable_ui): Rename to "busy" and match event handler
	definition.
	* library/plugins/rhabout/rhabout.itcl (running): Rename
	to "busy" and match new event handler definition.
	* library/tclIndex: Regenerated.
@
text
@a21 1
  add_hook gdb_idle_hook [list $this idle]
a40 1
  remove_hook gdb_idle_hook [list $this idle]
d200 1
a200 1
body Console::idle {} {
@


1.8
log
@2001-04-04  Martin M. Hunt  <hunt@@redhat.com>

	* generic/gdbtk-hooks.c (gdbtk_fileopen): New function.
	Initialize ui_file stuff for gdbtk.
	(gdbtk_fputs): Don't print if gdbtk_disable_fputs. Send
	stdlog and stdtarg to their handler functions.

	* generic/gdbtk.c (Gdbtk_Init): Don't set gdb_stdlog
	and gdb_stdtarg to gdb_stdout,
	(gdbtk_init): Unset gdbtk_disable_fputs
	when ready to accept output from gdb. Remove references to
	fputs_unfiltered_hook.

	* generic/gdbtk.h: Declare new flag gdbtk_disable_fputs.

	* generic/gdbtk-cmds.c (gdb_restore_fputs): Instead of setting
	fputs_unfiltered_hook, set the new flag gdbtk_disable_fputs.

	* library/prefs.tcl (pref_set_defaults): Add defaults
	for log_fg and target_fg.

	* library/interface.tcl (gdbtk_tcl_fputs_error): Use
	err_tag.
	(gdbtk_tcl_fputs_log): New function. Write log messages
	to console.
	(gdbtk_tcl_fputs_target): New function.	Write target
	IO to console.

	* library/console.ith (einsert): Add tag parameter.

	* library/console.itb (_build_win): Add new tags for log
	and target IO.
	(einsert): Add tag parameter.
@
text
@a21 1
  add_hook gdb_busy_hook [list $this busy]
a41 1
  remove_hook gdb_busy_hook [list $this busy]
d206 4
a209 1
body Console::busy {} {
@


1.7
log
@	* console.itb (Console::invoke): Trim trailing newlines from
	text.
@
text
@d1 2
a2 2
# Console window for GDBtk
# Copyright 1998, 1999 Cygnus Solutions
d63 2
d237 1
a237 1
body Console::einsert {line} {
d242 1
a242 1
  $_twin insert end $line err_tag
@


1.6
log
@2000-12-01  Larry Smith <lsmith@@redhat.com>

        * console.itb (invoke): Added logic to allow user to build
        up multiline "tk" commands based on results from checking
        command with [info complete $cmd]s.
@
text
@d400 1
@


1.5
log
@	* console.ith (_set_wrap): Declare.
	(_update_option): Likewise.
	* console.itb (Console::constructor): Install preference hooks
	(commented out pending a bug fix).
	(Console::destructor): Remove preference hooks.
	(Console::_set_wrap): New method.
	(Console::_update_option): New method.
	(Console::_build_win): Use _set_wrap.
@
text
@d388 10
d399 1
a399 1
  set text [$_twin get {cmdmark + 1 char} {cmdmark lineend}]
@


1.4
log
@


Fixed the partial implementation of the text wrapping option
in the console window, and added a way to select the new
option from the globalprefs.
@
text
@d25 12
d46 5
d52 1
a52 1
  
d54 1
a54 8
  set wrap [pref get gdb/console/wrap]

  if { $wrap } {
    set hsm none
  } else {
    set hsm dynamic
  }
  iwidgets::scrolledtext $itk_interior.stext -hscrollmode $hsm \
d59 1
a59 5
  if {$wrap} {
    $_twin configure -wrap word
  } else {
    $_twin configure -wrap none
  }
d622 40
@


1.3
log
@	* console.itb (Console::_complete): Dequoted first argument to
	switch.  Window name is `$_twin', not `_twin'.
@
text
@d37 8
a44 1
  iwidgets::scrolledtext $itk_interior.stext -hscrollmode dynamic \
d49 1
a49 1
  if {[pref get gdb/console/wrap]} {
@


1.2
log
@2000-04-08  Tom Tromey  <tromey@@cygnus.com>

	* console.itb (Console::_build_win): Make Control-a, Control-u,
	and Control-w bindings show the insertion point.
@
text
@d569 1
a569 1
    switch {[llength $choices]} {
d572 1
a572 1
	_twin insert end "$completion "
@


1.1
log
@Initial revision
@
text
@d91 1
d98 1
d105 1
@


1.1.1.1
log
@import insight-2000-02-04 snapshot (2nd try)
@
text
@@
