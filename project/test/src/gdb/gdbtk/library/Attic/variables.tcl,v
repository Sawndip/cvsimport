head	1.18;
access;
symbols
	gdb_5_3-2002-12-12-release:1.16
	gdb_5_3-branch:1.16.0.2
	gdb_5_3-2002-09-04-branchpoint:1.16
	gdb_5_2_1-2002-07-23-release:1.14
	gdb_5_2-2002-04-29-release:1.14
	gdb_5_2-branch:1.14.0.2
	gdb_5_2-2002-03-03-branchpoint:1.14
	gdb_5_1_1-2002-01-24-release:1.13
	cygnus_cvs_20020108_pre:1.14
	gdb_5_1_0_1-2002-01-03-branch:1.13.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.13
	gdb_5_1-2001-11-21-release:1.13
	gdb_s390-2001-09-26-branch:1.13.0.4
	gdb_s390-2001-09-26-branchpoint:1.13
	gdb_5_1-2001-07-29-branch:1.13.0.2
	gdb_5_1-2001-07-29-branchpoint:1.13
	dberlin-typesystem-branch:1.12.0.2
	dberlin-typesystem-branchpoint:1.12
	insight-precleanup-2001-01-01:1.4
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.2
	repo-unification-2000-02-06:1.1.1.1
	insight-2000-02-04:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.18
date	2002.11.06.21.05.24;	author hunt;	state dead;
branches;
next	1.17;

1.17
date	2002.10.15.21.19.51;	author hunt;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.07.09.22.44;	author hunt;	state Exp;
branches;
next	1.15;

1.15
date	2002.03.05.22.22.20;	author hunt;	state Exp;
branches;
next	1.14;

1.14
date	2001.08.09.20.43.54;	author kseitz;	state Exp;
branches;
next	1.13;

1.13
date	2001.07.21.18.43.34;	author hunt;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.04.15.49.53;	author kseitz;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.31.20.32.58;	author kseitz;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.31.15.21.40;	author kseitz;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.22.15.46.03;	author kseitz;	state Exp;
branches;
next	1.8;

1.8
date	2001.04.17.16.14.23;	author fnasser;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.29.22.42.17;	author fnasser;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.29.22.33.29;	author fnasser;	state Exp;
branches;
next	1.5;

1.5
date	2001.02.08.19.26.31;	author fnasser;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.22.15.33.06;	author fnasser;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.03.19.48.48;	author fnasser;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.30.22.14.24;	author fnasser;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.07.00.19.42;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.07.00.19.42;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.18
log
@2002-11-06  Martin M. Hunt  <hunt@@redhat.com>

	* library/watch.tcl: Completely rewritten to use VarTree.
	* library/locals.tcl: Completely rewritten to use VarTree.
	* library/variables.tcl: Deleted.
	* library/vartree.ith: New file.
	* library/vartree.itb: New file. Implements a variable
	tree.
	* library/tclIndex: Rebuilt.
@
text
@# Variable display window for Insight.
# Copyright 1997, 1998, 1999, 2001, 2002 Red Hat
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License (GPL) as published by
# the Free Software Foundation; either version 2 of the License, or (at
# your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.


# ----------------------------------------------------------------------
# Implements variable windows for gdb. LocalsWin and WatchWin both
# inherit from this class. You need only override the method 
# 'getVariablesBlankPath' and a few other things...
# ----------------------------------------------------------------------

itcl::class VariableWin {
    inherit EmbeddedWin GDBWin
    protected variable Sizebox 1

    # ------------------------------------------------------------------
    #  CONSTRUCTOR - create new watch window
    # ------------------------------------------------------------------
    constructor {args} {
	#
	#  Create a window with the same name as this object
	#
	gdbtk_busy
	set _queue [Queue \#auto]
	build_win $itk_interior
	gdbtk_idle

	add_hook gdb_no_inferior_hook "$this no_inferior"
	add_hook gdb_clear_file_hook [code $this clear_file]
        # FIXME: This is too harsh.  We must add to varobj a method
        # to re-parse the expressions and compute new types so we can
	# keep the contents of the window whenever possible.
	add_hook file_changed_hook [code $this clear_file]
    }

    # ------------------------------------------------------------------
    #  METHOD:  build_win - build the watch window
    # ------------------------------------------------------------------
    method build_win {f} {
	global tcl_platform Display
	#    debug
	set width [font measure global/fixed "W"]
	# Choose the default width to be...
	set width [expr {40 * $width}]
	if {$tcl_platform(platform) == "windows"} {
	    set scrollmode both
	} else {
	    set scrollmode auto
	}

	debug "tree=$f.tree"
	set Tree [tixTree $f.tree        \
		      -opencmd  "$this open"  \
		      -closecmd "$this close" \
		      -ignoreinvoke 1         \
		      -width $width           \
		      -browsecmd [list $this selectionChanged] \
		      -scrollbar $scrollmode \
		      -sizebox $Sizebox]
	if {![pref get gdb/mode]} {
	    $Tree configure -command [list $this editEntry]
	}
	set Hlist [$Tree subwidget hlist]

        # FIXME: probably should use columns instead.
        $Hlist configure -header 1 

	set l [expr {$EntryLength - $Length - [string length "Name"]}]
	# Ok, this is as hack as it gets
	set blank "                                                                                                                                                             "
      $Hlist header create 0 -itemtype text -headerbackground $::Colors(bg) \
	    -text "Name[string range $blank 0 $l]Value"

	# Configure the look of the tree
	set width [font measure global/fixed $LengthString]
	$Hlist configure -indent $width \
	  -bg $::Colors(textbg) -fg $::Colors(textfg) \
	  -selectforeground $::Colors(textfg) -selectbackground $::Colors(textbg) \
	  -selectborderwidth 0 -separator . -font global/fixed

	# Get display styles
	set normal_fg    [$Hlist cget -fg]
	set highlight_fg $::Colors(sfg)
	set disabled_fg  red
	set NormalTextStyle [tixDisplayStyle text -refwindow $Hlist \
			       -bg $::Colors(textbg) -font global/fixed]
        set HighlightTextStyle [tixDisplayStyle text -refwindow $Hlist \
				  -bg $::Colors(hbg) -font global/fixed]
	set DisabledTextStyle [tixDisplayStyle text -refwindow $Hlist \
				   -bg green -fg red -font global/fixed]

	if {[catch {gdb_cmd "show output-radix"} msg]} {
	    set Radix 10
	} else {
	    regexp {[0-9]+} $msg Radix
	}


	# Update the tree display
	update dummy
	pack $Tree -expand yes -fill both

	# Create the popup menu for this widget
	bind $Hlist <3> "$this postMenu %X %Y"
	bind $Hlist <KeyPress-space> [code $this toggleView]

	# Do not use the tixPopup widget... 
	set Popup [menu $f.menu -tearoff 0]
	set disabled_foreground red
	$Popup configure -disabledforeground $disabled_foreground
	set ViewMenu [menu $Popup.view]

	# Populate the view menu
	$ViewMenu add radiobutton -label "Hex" -variable Display($this) \
	    -value hexadecimal
	$ViewMenu add radiobutton -label "Decimal" -variable Display($this) \
	    -value decimal
	$ViewMenu add radiobutton -label "Binary" -variable Display($this) \
	    -value binary
	$ViewMenu add radiobutton -label "Octal" -variable Display($this) \
	    -value octal
	$ViewMenu add radiobutton -label "Natural" -variable Display($this) \
	    -value natural

	$Popup add command -label "dummy" -state disabled
	$Popup add separator
	$Popup add cascade -label "Format" -menu $ViewMenu
	#    $Popup add checkbutton -label "Auto Update"
	#    $Popup add command -label "Update Now"
	if {![pref get gdb/mode]} {
	    $Popup add command -label "Edit"
	}

	# Make sure to update menu info.
	selectionChanged ""

	window_name "Local Variables" "Locals"
    }

    # ------------------------------------------------------------------
    #  DESTRUCTOR - destroy window containing widget
    # ------------------------------------------------------------------
    destructor {
	#    debug
	# Make sure to clean up the frame
	catch {destroy $_frame}
	
	# Delete the display styles used with this window
	destroy $NormalTextStyle
	destroy $HighlightTextStyle
	destroy $DisabledTextStyle

	# Remove this window and all hooks
	remove_hook gdb_no_inferior_hook "$this no_inferior"
	remove_hook gdb_clear_file_hook [code $this clear_file]
	remove_hook file_changed_hook [code $this clear_file]
    }

    # ------------------------------------------------------------------
    #  METHOD:  clear_file - Clear out state and prepare for loading
    #              a new executable.
    # ------------------------------------------------------------------
    method clear_file {} {
	no_inferior
    }

    # ------------------------------------------------------------------
    #  METHOD:  reconfig - used when preferences change
    # ------------------------------------------------------------------
    method reconfig {} {
	#    debug
	foreach win [winfo children $itk_interior] { 
	    destroy $win
	}

	build_win $itk_interior
    }

    # ------------------------------------------------------------------
    #  METHOD:  build_menu_helper - Create the menu for a subclass.
    # ------------------------------------------------------------------
    method build_menu_helper {first} {
	global Display
	menu [namespace tail $this].mmenu

	[namespace tail $this].mmenu add cascade -label $first -underline 0 -menu [namespace tail $this].mmenu.var

	menu [namespace tail $this].mmenu.var
	if {![pref get gdb/mode]} {
	    [namespace tail $this].mmenu.var add command -label Edit -underline 0 -state disabled \
		-command [format {
		    %s editEntry [%s getSelection]
		} $this $this]
	}
	[namespace tail $this].mmenu.var add cascade -label Format -underline 0 -state disabled \
	    -menu [namespace tail $this].mmenu.var.format

	menu [namespace tail $this].mmenu.var.format
	foreach label {Hex Decimal Binary Octal Natural} fmt {hexadecimal decimal binary octal natural} {
	    [namespace tail $this].mmenu.var.format add radiobutton \
		-label $label -underline 0 \
		-value $fmt -variable Display($this) \
		-command [format {
		    %s setDisplay [%s getSelection] %s
		} $this $this $fmt]
	}

	#    [namespace tail $this].mmenu add cascade -label Update -underline 0 -menu [namespace tail $this].mmenu.update
	#    menu [namespace tail $this].mmenu.update

	# The -variable is set when a selection is made in the tree.
	#    [namespace tail $this].mmenu.update add checkbutton -label "Auto Update" -underline 0 \
	    #      -command [format {
	#	%s toggleUpdate [%s getSelection]
	#      } $this $this]
	#    [namespace tail $this].mmenu.update add command -label "Update Now" -underline 0 \
	    #      -accelerator "Ctrl+U" -command [format {
	#	%s updateNow [%s getSelection]
	#      } $this $this]

	set top [winfo toplevel [namespace tail $this]]
	$top configure -menu [namespace tail $this].mmenu
	bind_plain_key $top Control-u [format {
	    if {!$Running} {
		if {[%s getSelection] != ""} {
		    %s updateNow [%s getSelection]
		}
	    }
	} $this $this $this]

	return [namespace tail $this].mmenu.var
    }

    # Return the current selection, or the empty string if none.
    method getSelection {} {
	return [$Hlist info selection]
    }

    # This is called when a selection is made.  It updates the main
    # menu.
    method selectionChanged {variable} {
	global Display

	if {$Running} {
	    # Clear the selection, too
	    $Hlist selection clear
	    return
	}

	# if something is being edited, cancel it
	if {[info exists EditEntry]} {
	    UnEdit
	}

	if {$variable == ""} {
	    set state disabled
	} else {
	    set state normal
	}

	foreach menu [list [namespace tail $this].mmenu.var [namespace tail $this].mmenu.var.format ] {
	    set i [$menu index last]
	    while {$i >= 0} {
		if {[$menu type $i] != "cascade"} {
		    $menu entryconfigure $i -state $state
		}
		incr i -1
	    }
	}

	if {$variable != "" && [$variable editable]} {
	    set state normal
	} else {
	    set state disabled
	}

	if {$variable != ""} {
	    set Display($this) [$variable format]
	}

	foreach label {Hex Decimal Binary Octal Natural} {
	    [namespace tail $this].mmenu.var.format entryconfigure $label
	    if {$label != "Hex"} {
		[namespace tail $this].mmenu.var.format entryconfigure $label -state $state
	    }
	}
	#    [namespace tail $this].mmenu.update entryconfigure 0 -variable Update($this,$name)
    }

    method updateNow {variable} {
	# debug "$variable"

	if {!$Running} {
	    set text [label $variable]
	    $Hlist entryconfigure $variable -itemtype text -text $text
	}
    }

    method getEntry {x y} {
	set realY [expr {$y - [winfo rooty $Hlist]}]

	# Get the tree entry which we are over
	return [$Hlist nearest $realY]
    }

    method editEntry {variable} {
	if {!$Running} {
	    if {$variable != "" && [$variable editable]} {
		edit $variable
	    }
	}
    }

    method postMenu {X Y} {
	global Update Display
	#    debug

	# Quicky for menu posting problems.. How to unpost and post??

	if {[winfo ismapped $Popup] || $Running} {
	    return
	}

	set variable [getEntry $X $Y]
	if {[string length $variable] > 0} {
	  # First things first: highlight the variable we just selected
	  $Hlist selection set $variable

	    # Configure menu items
	    # the title is always first..
	    #set labelIndex [$Popup index "dummy"]
	    set viewIndex [$Popup index "Format"]
	    #      set autoIndex [$Popup index "Auto Update"]
	    #      set updateIndex [$Popup index "Update Now"]
	    set noEdit [catch {$Popup index "Edit"} editIndex]

	    # Retitle and set update commands
	    $Popup entryconfigure 0 -label "[$variable name]"
	    #      $Popup entryconfigure $autoIndex -command "$this toggleUpdate \{$entry\}" \
		-variable Update($this,$entry) 
	    #      $Popup entryconfigure $updateIndex -command "$this updateNow \{$entry\}"

	    # Edit pane
	    if {$variable != "" && [$variable editable]} {
		if {!$noEdit} {
		    $Popup delete $editIndex
		}
		if {![pref get gdb/mode]} {
		    $Popup  add command -label Edit -command "$this edit \{$variable\}"
		}
	    } else {
		if {!$noEdit} {
		    $Popup delete $editIndex
		}
	    }

	    # Set view menu
	    set Display($this) [$variable format]
	    foreach i {0 1 2 3 4} fmt {hexadecimal decimal binary octal natural} {
		debug "configuring entry $i ([$ViewMenu entrycget $i -label]) to $fmt"
		$ViewMenu entryconfigure $i \
		    -command "$this setDisplay \{$variable\} $fmt"
	    }

	    if {$::tcl_platform(platform) == "windows"} {
	      # Don't ask me why this works, but it does work around
	      # a Win98/2000 Tcl bug with deleting entries from popups...
	      set no [$Popup index end]
	      for { set k 1 } { $k < $no } { incr k } {
		$Popup insert 1 command 
	      }
	      $Popup delete 1 [expr {$no - 1}]
	    }

	    tk_popup $Popup $X $Y
	}
    }

    # ------------------------------------------------------------------
    # METHOD edit -- edit a variable
    # ------------------------------------------------------------------
    method edit {variable} {
	global Update

	# disable menus
	selectionChanged ""
        debug "editing \"$variable\""

	set fg   [$Hlist cget -foreground]
	set bg   [$Hlist cget -background]

	if {$Editing == ""} {
	    # Must create the frame
	    set Editing [frame $Hlist.frame -bg $bg -bd 0 -relief flat]
	    set lbl [::label $Editing.lbl -fg $fg -bg $bg -font global/fixed]
	    set ent [entry $Editing.ent -bg $::Colors(bg) -fg $::Colors(fg) -font global/fixed]
	    pack $lbl $ent -side left
	}

	if {[info exists EditEntry]} {
	    # We already are editing something... So reinstall it first
	    # I guess we discard any changes?
	    UnEdit
	}

	# Update the label/entry widgets for this instance
	set Update($this,$variable) 1
	set EditEntry $variable
	set label [label $variable 1];	# do not append value
	$Editing.lbl configure -text "$label  "
	$Editing.ent delete 0 end

	# Strip the pointer type, text, etc, from pointers, and such
	set err [catch {$variable value} text]
	if {$err} {return}
	if {[$variable format] == "natural"} {
	    # Natural formats must be stripped. They often contain
	    # things like strings and characters after them.
	    set index [string first \  $text]
	    if {$index != -1} {
		set text [string range $text 0 [expr {$index - 1}]]
	    }
	}
	$Editing.ent insert 0 $text

	# Find out what the previous entry is
	set previous [getPrevious $variable]

	$Hlist delete entry $variable

	set cmd [format { \
			      %s add {%s} %s -itemtype window -window %s \
			  } $Hlist $variable $previous $Editing]
	eval $cmd

	if {[$variable numChildren] > 0} {
	    $Tree setmode $variable open
	}

	# Set focus to entry
	focus $Editing.ent
	$Editing.ent selection to end

	# Setup key bindings
	bind $Editing.ent <Return> "$this changeValue"
	bind $Hlist <Return> "$this changeValue"
	bind $Editing.ent <Escape> "$this UnEdit"
	bind $Hlist <Escape> "$this UnEdit"
    }

    method getPrevious {variable} {
	set prev [$Hlist info prev $variable]
	set parent [$Hlist info parent $variable]

	if {$prev != ""} {
	    # A problem occurs with PREV if its parent is not the same as the entry's
	    # parent. For example, consider these variables in the window:
	    # + foo        struct {...}
	    # - bar        struct {...}
	    #     a        1
	    #     b        2
	    # local        0
	    # if you attempt to edit "local", previous will be set at "bar.b", not
	    # "struct bar"...
	    if {[$Hlist info parent $prev] != $parent} {
		# This is the problem!
		# Find this object's sibling in that parent and place it there.
		set children [$Hlist info children $parent]
		set p {}
		foreach child $children {
		    if {$child == $variable} {
			break
		    }
		    set p $child
		}

		if {$p == {}} {
		    # This is the topmost child
		    set previous "-before [lindex $children 1]"
		} else {
		    set previous "-after $p"
		}
	    } else {
		set previous "-after \{$prev\}"
	    }
	} else {
	    # this is the first!
	    set previous "-at 0"
	}
	
	if {$prev == "$parent"} {
	    # This is the topmost-member of a sub-grouping..
	    set previous "-at 0"
	}

	return $previous
    }

    method UnEdit {} {
	set previous [getPrevious $EditEntry]
	
	$Hlist delete entry $EditEntry
	set cmd [format {\
			     %s add {%s} %s -itemtype text -text {%s} \
			 } $Hlist $EditEntry $previous [label $EditEntry]]
	eval $cmd
	if {[$EditEntry numChildren] > 0} {
	    $Tree setmode $EditEntry open
	}
	
	# Unbind
	bind $Hlist <Return> {}
	bind $Hlist <Escape> {}
	if {$Editing != ""} {
	    bind $Editing.ent <Return> {}
	    bind $Editing.ent <Escape> {}
	}
	
	unset EditEntry
	selectionChanged ""
    }

    method changeValue {} {
	# Get the old value
	set new [string trim [$Editing.ent get] \ \r\n]
	if {$new == ""} {
	    UnEdit
	    return
	}

	if {[catch {$EditEntry value $new} errTxt]} {
	    tk_messageBox -icon error -type ok -message $errTxt \
		-title "Error in Expression" -parent [winfo toplevel $itk_interior]
	    focus $Editing.ent
	    $Editing.ent selection to end
	} else {
	    UnEdit

            # We may have changed a register or something else that is 
            # being displayed in another window
            gdbtk_update
	    
	    # Get rid of entry... and replace it with new value
	    focus $Tree
	}
    }


    # ------------------------------------------------------------------
    #  METHOD:  toggleView: Toggle open/close the current selection.
    # ------------------------------------------------------------------  
    method toggleView {} {

	set v [getSelection]
	set mode [$Tree getmode $v]

	# In the tixTree widget, "open" means "openable", not that it is open...

	debug "mode=$mode"
	switch $mode {
	    open {
		$Tree setmode $v close
		open $v
	    }

	    close {
		$Tree setmode $v open
		close $v
	    }

	    default {
		dbug E "What happened?"
	    }
	}
    }

    method toggleUpdate {variable} {
	global Update
      debug $variable
	if {$Update($this,$variable)} {
	  debug NORMAL
	    # Must update value
	    $Hlist entryconfigure $variable \
		-style $NormalTextStyle    \
		-text [label $variable]
	} else {
	  debug DISABLED
	    $Hlist entryconfigure $variable \
		-style $DisabledTextStyle
	}
	::update
    }

    method setDisplay {variable format} {
	debug "$variable $format"
	if {!$Running} {
	    $variable format $format
	    set ::Display($this) $format
	    $Hlist entryconfigure $variable -text [label $variable]
	}
    }
    
    # ------------------------------------------------------------------
    # METHOD:   label - used to label the entries in the tree
    # ------------------------------------------------------------------
    method label {variable {noValue 0}} {
	# Ok, this is as hack as it gets
	set blank "                                                                                                                                                             "
	# Use protected data Length to determine how big variable
	# name should be. This should clean the display up a little
	set name [$variable name]
	set indent [llength [split $variable .]]
	set indent [expr {$indent * $Length}]
	set len [string length $name]
	set l [expr {$EntryLength - $len - $indent}]
	set label "$name[string range $blank 0 $l]"
	#debug "label=$label $noValue"
	if {$noValue} {
	    return $label
	}

	set err [catch {$variable value} value]
	set value [string trim $value \ \r\t\n]
	#debug "err=$err value=$value"

	# Insert the variable's type for things like ptrs, etc.
	set type [$variable type]
	if {!$err} {
	    if {$value == "{...}"} {
		set val " $type $value"
	    } elseif {[string first * $type] != -1} {
		set val " ($type) $value"
	    } elseif {[string first \[ $type] != -1} {
		set val " $type"
	    } else {
		set val " $value"
	    }
	} else {
	    set val " $value"
	}

	return "$label $val"
    }

    # ------------------------------------------------------------------
    # METHOD:   open - used to open an entry in the variable tree
    # ------------------------------------------------------------------
    method open {path} {
	global Update
	# We must lookup all the variables for this struct
	#    debug "$path"

	# Cancel any edits
	if {[info exists EditEntry]} {
	    UnEdit
	}

	if {!$Running} {
	    # Do not open disabled paths
	    if {$Update($this,$path)} {
		cursor watch
		populate $path
		cursor {}
	    }
	} else {
	    $Tree setmode $path open
	}
    }

    # ------------------------------------------------------------------
    # METHOD:   close - used to close an entry in the variable tree
    # ------------------------------------------------------------------
    method close {path} {
	global Update
	debug "$path"
	# Close the path and destroy all the entry widgets

	# Cancel any edits
	if {[info exists EditEntry]} {
	    UnEdit
	}

	if {!$Running} {
	    # Only update when we we are not disabled
	    if {$Update($this,$path)} {

		# Delete the offspring of this entry
		$Hlist delete offspring $path
	    }
	} else {
	    $Tree setmode $path close
	}
    }

    method isVariable {var} {

	set err [catch {gdb_cmd "output $var"} msg]
	if {$err 
	    || [regexp -nocase "no symbol|syntax error" $msg]} {
	    return 0
	}

	return 1
    }

    # OVERRIDE THIS METHOD
    method getVariablesBlankPath {} {
	dbug -W "You forgot to override getVariablesBlankPath!!"
	return {}
    }

    method cmd {cmd} {
	eval $cmd
    }
    
    # ------------------------------------------------------------------
    # METHOD:   populate - populate an entry in the tree
    # ------------------------------------------------------------------
    method populate {parent} {
	global Update
	debug "$parent"

	if {[string length $parent] == 0} {
	    set variables [getVariablesBlankPath]
	} else {
	    set variables [$parent children]
	}

	debug "variables=$variables"
	eval $_queue push $variables
	for {set variable [$_queue pop]} {$variable != ""} {set variable [$_queue pop]} {
	    debug "inserting variable: $variable"
	    set Update($this,$variable) 1

	    $Hlist add $variable          \
		-itemtype text              \
		-text [label $variable]
	    if {[$variable numChildren] > 0} {
		# Make sure we get this labeled as openable
		$Tree setmode $variable open
	    }

	    # Special case: If we see "public" with no value or type, then we
	    # have one of our special c++/java children. Open it automagically
	    # for the user.
	    if {[string compare [$variable name] "public"] == 0
		&& [$variable type] == "" && [$variable value] == ""} {
		eval $_queue push [$variable children]
		$Tree setmode $variable close
	    }
	}

	debug "done with populate"
    }

    # Get all current locals
    proc getLocals {} {

	set vars {}
	set err [catch {gdb_get_args} v]
	if {!$err} {
	    set vars [concat $vars $v]
	}

	set err [catch {gdb_get_locals} v]
	if {!$err} {
	    set vars [concat $vars $v]
	}

	debug "--getLocals:\n$vars\n--getLocals"
	return [lsort $vars]
    }

    method context_switch {} {
	set err [catch {gdb_selected_frame} current_frame]
	debug "1: err=$err; _frame=\"$_frame\"; current_frame=\"$current_frame\""
	if {$err && $_frame != ""} {
	    # No current frame
	    debug "no current frame"
	    catch {destroy $_frame}
	    set _frame {}
	    return 1
	} elseif {$current_frame == "" && $_frame == ""} {
	    debug "2"
	    return 0
	} elseif {$_frame == "" || $current_frame != [$_frame address]} {
	    # We've changed frames. If we knew something about
	    # the stack layout, we could be more intelligent about
	    # destroying variables, but we don't know that here (yet).
	    debug "switching to frame at $current_frame"

	    # Destroy the old frame and create the new one
	    catch {destroy $_frame}
	    set _frame [Frame ::\#auto $current_frame]
	    debug "created new frame: $_frame at [$_frame address]"
	    return 1
	}

	# Nothing changed
	debug "3"
	return 0
    }

    # ------------------------------------------------------------------
    # METHOD:   update
    # OVERRIDE THIS METHOD and call it from there
    # ------------------------------------------------------------------
    method update {event} {
      global Update
      debug

      # First, reset color on label to normal
      foreach w $ChangeList {
	catch {
	  $Hlist entryconfigure $w -style $NormalTextStyle
	}
      }
      
	# Tell toplevel variables to update themselves. This will
	# give us a list of all the variables in the table that
	# have changed values.
	set ChangeList {}
	set variables [$Hlist info children {}]
	foreach var $variables {
	    # debug "VARIABLE: $var ($Update($this,$var))"
            set numchild [$var numChildren]
	    set UpdatedList [$var update]
            # FIXME: For now, we can only infer that the type has changed
            # if the variable is not a scalar; the varobj code will have to
            # give us an indication that this happened.
            if {([lindex $UpdatedList 0] == $var)
                && ($numchild > 0)} {
              debug "Type changed."
              # We must fix the tree entry to correspond to the new type
              $Hlist delete offsprings $var
              $Hlist entryconfigure $var -text [label $var]
              if {[$var numChildren] > 0} {
                $Tree setmode $var open
              } else {
                $Tree setmode $var none
              }
            } else {
	      set ChangeList [concat $ChangeList $UpdatedList]
	      # debug "ChangeList=$ChangeList"
            }
	}

	foreach var $ChangeList {
	  debug "$var HIGHLIGHT"
	    $Hlist entryconfigure $var \
		-style  $HighlightTextStyle   \
		-text [label $var]
	}
    }

    method idle {event} {
	# Re-enable the UI
	enable_ui
    }

    # RECURSION!!
    method displayedVariables {top} {
	#    debug
	set variableList {}
	set variables [$Hlist info children $top]
	foreach var $variables {
	    set mode [$Tree getmode $var]
	    if {$mode == "close"} {
		set moreVars [displayedVariables $var]
		lappend variableList [join $moreVars]
	    }
	    lappend variableList $var
	}

	return [join $variableList]
    }

    method deleteTree {} {
	global Update
	debug
#	set variables [displayedVariables {}]

	# Delete all HList entries
	$Hlist delete all

	# Delete the variable objects
#	foreach i [array names Variables] {
#	    $Variables($i) delete
#	    unset Variables($i)
#	    catch {unset Update($this,$i)}
#	}
    }

    # ------------------------------------------------------------------
    # METHOD:   enable_ui
    #           Enable all ui elements.
    # ------------------------------------------------------------------
    method enable_ui {} {
	
	# Clear fencepost
	set Running 0
	cursor {}
    }

    # ------------------------------------------------------------------
    #   PUBLIC METHOD:  busy - BusyEvent handler
    #           Disable all ui elements that could affect gdb's state
    # ------------------------------------------------------------------
    method busy {event} {

	# Set fencepost
	set Running 1

	# Cancel any edits
	if {[info exists EditEntry]} {
	    UnEdit
	}

	# Change cursor
	cursor watch
    }

    # ------------------------------------------------------------------
    # METHOD:   no_inferior
    #           Reset this object.
    # ------------------------------------------------------------------
    method no_inferior {} {

	# Clear out the Hlist
	deleteTree

	# Clear fencepost
	set Running 0
	set _frame {}
	cursor {}
    }

    # ------------------------------------------------------------------
    #  METHOD:  cursor - change the toplevel's cursor
    # ------------------------------------------------------------------
    method cursor {what} {
	[winfo toplevel [namespace tail $this]] configure -cursor $what
	::update idletasks
    }

    #
    # PUBLIC DATA
    #

    #
    #  PROTECTED DATA
    #

    # the tixTree widget for this class
    protected variable Tree  {}

    # the hlist of this widget
    protected variable Hlist {}

    # entry widgets which need to have their color changed back to black
    # when idle (used in conjunction with update)
    protected variable ChangeList {}

    protected variable ViewMenu
    protected variable Popup

    # These are for setting the indent level to an number of characters.
    # This will help clean the tree a little
    common EntryLength 15
    common Length 1
    common LengthString " "

    # These should be common... but deletion?
    # Display styles for HList
    protected variable HighlightTextStyle
    protected variable NormalTextStyle
    protected variable DisabledTextStyle
    
    protected variable Radix

    # Frame object for the selected frame
    protected variable _frame {}

    protected variable Editing {}
    protected variable EditEntry

    # Fencepost for enable/disable_ui and idle/busy hooks.
    protected variable Running 0

    # little queue for convenience
    protected variable _queue {}
}
@


1.17
log
@2002-10-15  Martin M. Hunt  <hunt@@redhat.com>

	* library/* : auto_mkindex cannot rebuild
	tclIndex because it does not recognize the namespace
	import in main.tcl.  To get it to work again, rename the
	following:
		body -> itcl::body
		configbody -> itcl::configbody
		class -> itcl::class
@
text
@@


1.16
log
@2002-06-07  Martin M. Hunt  <hunt@@redhat.com>

	* library/prefs.tcl (pref_set_colors): New function.  Set up colors
	from Windows system colors or X resource database. Save in array.
	(pref_set_defaults): Remove gdb/font/normal_fg, etc.
	(pref_read): Call pref_set_colors.

	* library/main.tcl: Remove call to "tix resetoptions TixGray".

	* library/bpwin.itb, library/browserwin.itb, library/console.itb,
	library/globalpref.itb, library/memwin.itb, library/process.itb,
	library/regwin.itb, library/srcpref.itb, library/srctextwin.itb,
	library/stackwin.itb, library/tdump.tcl, library/tracedlg.tcl,
	library/variables.tcl: Replace calls to [pref get gdb/fonts/*]
	for colors with references to Color array. Remove all tixOptions calls.
	Fix up colors as necessary.
@
text
@d21 1
a21 1
class VariableWin {
d818 2
a819 2
	global Update
	debug
d821 4
a824 5
	# First, reset color on label to normal
	foreach w $ChangeList {
	    catch {
		$Hlist entryconfigure $w -style $NormalTextStyle
	    }
d826 2
a827 1

@


1.15
log
@2002-03-05  Martin M. Hunt  <hunt@@redhat.com>

	* library/prefs.tcl (pref_read): If a preference specifies
	"src-font", substitute "global/fixed".
	(pref_set_defaults): Change defaults from "src-font" to
	"global/fixed". Do not create font object "src-font". Do
	not add hook to trace its changes.
	(pref_src-font_trace): Remove.

	* library/console.itb (Console::_update_option): Remove
	font update because this happens automatically.

	* library/globalpref.itb: No need to set
	changed flag for fonts; updates happen automatically
	when prefs are updated.

	* library/bpwin.itb: Replaced src-font with global/fixed.
	* library/browserwin.itb: Ditto.
	* library/mempref.itb: Ditto.
	* library/memwin.itb: Ditto.
	* library/process.itb: Ditto.
	* library/regwin.itb: Ditto.
	* library/srcbar.itcl: Ditto.
	* library/srcpref.itb: Ditto.
	* library/srctextwin.itb: Ditto.
	* library/srcwin.itb: Ditto.
	* library/stackwin.itb: Ditto.
	* library/tdump.tcl: Ditto.
	* library/tracedlg.tcl: Ditto.
	* library/variables.tcl: Ditto.
	* library/watch.tcl: Ditto.
@
text
@d49 1
a49 1
	global tixOption tcl_platform Display
d74 2
a75 2
	# FIXME: probably should use columns instead.
	$Hlist configure -header 1
d80 1
a80 1
	$Hlist header create 0 -itemtype text \
a83 3
	set sbg [$Hlist cget -bg]
	set fg [$Hlist cget -fg]
	set bg $tixOption(input1_bg)
d85 4
a88 3
	$Hlist configure -indent $width -bg $bg \
	    -selectforeground $fg -selectbackground $sbg \
	    -selectborderwidth 0 -separator . -font global/fixed
d92 2
a93 2
	set highlight_fg [pref get gdb/font/highlight_fg]
	set disabled_fg  [pref get gdb/variable/disabled_fg]
d95 3
a97 3
				 -bg $bg -fg $normal_fg -font global/fixed]
	set HighlightTextStyle [tixDisplayStyle text -refwindow $Hlist \
				    -bg $bg -fg $highlight_fg -font global/fixed]
d99 1
a99 1
				   -bg $bg -fg $disabled_fg -font global/fixed]
d118 1
a118 1
	set disabled_foreground [$Popup cget -foreground]
d392 1
a392 1
	global Update tixOption
d405 1
a405 1
	    set ent [entry $Editing.ent -bg $tixOption(bg) -font global/fixed]
d588 1
a588 1

d590 1
d596 1
d821 1
a821 1
	# First, reset color on label to black
d858 1
@


1.14
log
@	* library/prefs.tcl (pref_set_defaults): Add new font
	color defaults for highlighting, headers, selecting, and "normal".
	Get rid of gdb/variable/highlight_fg and gdb/reg/highlight_fg.
	* library/variables.tcl (build_win): Use gdb/font/highlight_fg
	and gdb/font/highilght_bg to set highlight style.
	* library/memwin.itb (build_win): Use header_fg and header_bg.
@
text
@d2 1
a2 1
# Copyright 1997, 1998, 1999, 2001 Red Hat
d51 1
a51 1
	set width [font measure src-font "W"]
d87 1
a87 1
	set width [font measure src-font $LengthString]
d90 1
a90 1
	    -selectborderwidth 0 -separator . -font src-font
d97 1
a97 1
				 -bg $bg -fg $normal_fg -font src-font]
d99 1
a99 1
				    -bg $bg -fg $highlight_fg -font src-font]
d101 1
a101 1
				   -bg $bg -fg $disabled_fg -font src-font]
d406 2
a407 2
	    set lbl [::label $Editing.lbl -fg $fg -bg $bg -font src-font]
	    set ent [entry $Editing.ent -bg $tixOption(bg) -font src-font]
@


1.13
log
@2001-07-21  Martin M. Hunt  <hunt@@redhat.com>

	* library/variables.tcl (build_menu_helper): Set
	the Format menu option to "disabled" initially.
@
text
@d94 1
a94 1
	set highlight_fg [pref get gdb/variable/highlight_fg]
@


1.12
log
@	* library/interface.tcl (gdb_update_hook): Mark as deprecated.
	(gdbtk_update): Dispatch and UpdateEvent, too.
	* library/ehandler.ith (update): New event handler.
	* library/gdbevent.ith (UpdateEvent): New event.
	* library/gdbevent.itb (UpdateEvent::constructor): New method.
	(UpdateEvent::get): New method.
	* library/kod.ith (udpate): Match event handler definition.
	* library/kod.itb (update): Ditto.
	(build_win): Pass dummy argument to update method.
	(top): Ditto.
	(up): Ditto.
	(set_variable): Ditto.
	* library/memwin.ith (update): Match event handler definition.
	* library/memwin.itb (update): Ditto.
	(constructor): Remove gdb_update_hook.
	(destructor): Ditto.
	* library/process.ith (update): Match event handler definition.
	* library/process.itb (update): Ditto.
	(constructor): Remove gdb_update_hook.
	(destructor): Ditto.
	(build_win): Pass dummy argument to update method.
	* library/regwin.ith (update): Match event handler definition.
	* library/regwin.itb (update): Ditto.
	(constructor): Remove gdb_update_hook.
	(destructor): Ditto.
	(build_win): Pass dummy argument to update method.
	(but3): Ditto.
	(unedit): Ditto.
	* library/stackwin.ith (update): Match event handler definition.
	* library/stackwin.itb (update): Ditto.
	(constructor): Remove gdb_update_hook.
	(destructor): Ditto.
	(build_win): Pass dummy argument to update method.
	* library/tdump.tcl (update): Match event handler definition.
	(constructor): Remove gdb_update_hook.
	(destructor): Ditto.
	(build_win): Pass dummy argument to update method.
	* library/variables.tcl (update): Match event handler definition.
	(build_win): Pass dummy argument to update method.
	* library/locals.tcl (update): Match event handler definition.
	(constructor): Pass dummy argument to update method.
	* library/watch.tcl (update): Match event handler definition.
	Pass dummy argument to VariableWin::update.
	(add): Pass dummy argument to update method.
	* library/srcwin.ith (update): New method.
	(update_hook_init): Remove.
	* library/srcwin.itb (update): New method.
	(constructor): Remove gdb_update_hook.
	(destructor): Ditto.
	* tclIndex: Regenerate.
@
text
@d206 1
a206 1
	[namespace tail $this].mmenu.var add cascade -label Format -underline 0 \
@


1.11
log
@	* library/interface.tcl (gdb_idle_hook): Mark as deprecated.
	(gdbtk_idle): Dispatch an IdleEvent. gdb_idle_hook is gone.
	* library/ehandler.ith (idle): New event handler.
	* library/gdbevent.ith (IdleEvent): New event.
	* library/console.ith (idle): Match event handler definition.
	* library/console.itb (idle): Ditto.
	(constructor): Remove gdb_idle_hook.
	(destructor): Ditto.
	* library/kod.ith (idle): Match event handler definition.
	* library/kod.itb (idle): Ditto.
	(constructor): Remove gdb_idle_hook.
	(destructor): Ditto.
	* library/memwin.ith (idle): Match event handler definition.
	* library/memwin.itb (idle): Ditto.
	(constructor): Remove gdb_idle_hook.
	(destructor): Ditto.
	* library/pluginwin.itcl (stopped): Rename to "idle" and
	match event handler definition.
	Fix misleading comments.
	* library/process.ith (idle): Match event handler definition.
	* library/process.itb (idle): Ditto.
	(constructor): Remove gdb_idle_hook.
	(destructor): Ditto.
	* library/regwin.ith (idle): Match event handler definition.
	* library/regwin.itb (idle): Ditto.
	(constructor): Remove gdb_idle_hook.
	(destructor): Ditto.
	* library/srcbar.itcl (idle): New method.
	(constructor): Remove gdb_idle_hook.
	(destructor): Ditto.
	* library/srcwin.ith (idle): Match event handler definition.
	* library/srcwin.itb (idle): Ditto.
	(constructor): Remove gdb_idle_hook.
	(destructor): Ditto.
	* library/stackwin.ith (idle): Match event handler definition.
	* library/stackwin.itb (idle): Ditto.
	(constructor): Remove gdb_idle_hook.
	(destructor): Ditto.
	* library/variables.tcl (idle): Match event handler definition.
	(constructor): Remove gdb_idle_hook.
	(destructor): Ditto.
	* library/plugins/rhabout/rhabout.itcl (stopped): Rename
	to "idle" and match new event handler definition.
	* library/tclIndex: Regenerated.
@
text
@a36 1
	add_hook gdb_update_hook "$this update"
d111 1
a111 1
	update
a164 1
	remove_hook gdb_update_hook "$this update"
d817 1
a817 1
    method update {} {
@


1.10
log
@	* library/interface.tcl (gdb_busy_hook): Deprecate.
	(gdbtk_busy): Create and dispatch a BusyEvent instead
	of running hooks.
	* library/ehandler.ith (busy): New event handler.
	* library/gdbevent.ith (BusyEvent): New event class.
	* library/console.ith: Inherit from GDBEventHandler.
	(busy): Match event handler definition.
	* library/console.itb (busy): Ditto.
	(constructor): Remove gdb_busy_event.
	(destructor): Ditto.
	* library/kod.ith (busy): Match event handler definition.
	* library/kod.itb (busy): Ditto.
	(constructor): Remove gdb_busy_hook.
	(destructor): Ditto.
	* library/memwin.ith (busy): Match event handler definition.
	* library/memwin.itb (busy): Ditto.
	(constructor): Remove gdb_busy_hook.
	(destructor): Ditto.
	* library/pluginwin.itcl (running): Rename to "busy" and
	match event handler definition.
	(consturctor): Remove gdb_busy_hook.
	(destructor): Ditto.
	* library/process.ith (busy): Match event handler definition.
	* library/process.itb (busy): Ditto.
	(constructor): Remove gdb_busy_hook.
	(destructor): Ditto.
	* library/regwin.ith (busy): Match event handler definition.
	* library/regwin.itb (busy): Ditto.
	(constructor): Remove gdb_busy_hook.
	(destructor): Ditto.
	* library/srcbar.itcl (constructor): Remove gdb_busy_hook.
	(destructor): Ditto.
	(busy): New method.
	* library/srcwin.ith (busy): Match event handler definition.
	* library/srcwin.itb (busy): Ditto.
	Only do the "busy" stuff if do_updates is set.
	(toggle_updates): Remove gdb_busy_hook.
	(constructor): Ditto.
	(destructor): Ditto.
	* library/stackwin.ith (busy): Match event handler definition.
	* library/stackwin.itb (busy): Ditto.
	(constructor): Remove gdb_busy_hook.
	(destructor): Ditto.
	* library/variables.tcl (constructor): Ditto.
	(destructor): Ditto.
	(disable_ui): Rename to "busy" and match event handler
	definition.
	* library/plugins/rhabout/rhabout.itcl (running): Rename
	to "busy" and match new event handler definition.
	* library/tclIndex: Regenerated.
@
text
@a38 1
	add_hook gdb_idle_hook [list $this idle]
a167 1
	remove_hook gdb_idle_hook [list $this idle]
d866 1
a866 1
    method idle {} {
@


1.9
log
@	* library/variables.tcl (postMenu): Add mysterious workaround
	for popup menu bug in Tk for windows.
	Highlight the selection, too.
@
text
@a37 1
	add_hook gdb_busy_hook "$this disable_ui"
a167 1
	remove_hook gdb_busy_hook "$this disable_ui"
d918 1
a918 1
    # METHOD:   disable_ui
d921 1
a921 1
    method disable_ui {} {
@


1.8
log
@2001-04-17  Fernando Nasser  <fnasser@@redhat.com>

	* library/variables.tcl (update): Temporary fix to the detection of
	"type_changed" condition.  Proper fix will require that this condition
	is properly reported by the underlying code.
@
text
@d343 3
d380 10
@


1.7
log
@2001-03-29  Fernando Nasser  <fnasser@@redhat.com>

	* library/variable.tcl (update): Cope with varobj type changes.
@
text
@d828 1
d830 5
a834 1
            if {[lindex $UpdatedList 0] == $var} {
@


1.6
log
@2001-03-29  Fernando Nasser  <fnasser@@redhat.com>

	* library/variable.tcl (destructor): Remove file_changed_hook hook.
@
text
@d806 2
d809 1
d827 16
a842 2
	    #      debug "VARIABLE: $var ($Update($this,$var))"
	    set ChangeList [concat $ChangeList [$var update]]
@


1.5
log
@2001-02-08  Fernando Nasser  <fnasser@@redhat.com>

	From 2001-02-06  Martin Hunt  <hunt@@redhat.com>
	* library/debugwin.itb: Change window name to "Insight Debug"
	* library/embeddedwin.ith: Fix debug messages.
	* library/locals.tcl: Ditto.
	* library/watch.tcl (postMenu): Ditto.
	* library/variables.tcl: Ditto.
	* library/interface.tcl: Ditto.
	* library/regwin.itb: Ditto.
	* library/gdbwin.ith: Ditto.
	* library/srcbar.itcl: Ditto.
@
text
@d173 1
@


1.4
log
@2000-12-13  Fernando Nasser  <fnasser@@redhat.com>

        * variables.tcl (constructor): Use the  file_changed_hook to remove
        all variables if the exec file changes.  This prevents the Watch
        Window to dump core because the "types" are not valid anymore.
@
text
@d1 2
a2 2
# Variable display window for GDBtk.
# Copyright 1997, 1998, 1999 Cygnus Solutions
d53 1
a53 1
	#    debug "VariableWin::build_win"
d158 1
a158 1
	#    debug "VariableWin::destructor"
d187 1
a187 1
	#    debug "VariableWin::reconfig"
d307 1
a307 1
	# debug "VariableWin::updateNow $variable"
d332 1
a332 1
	#    debug "VariableWin::postMenu"
d652 1
a652 1
	#    debug "VariableWin::open $path"
d676 1
a676 1
	debug "VariableWin::close $path"
d709 1
a709 1
	debug "You forgot to override getVariablesBlankPath!!"
d722 1
a722 1
	debug "VariableWin::populate \"$parent\""
d808 1
a808 1
	debug "VariableWin::update"
d841 1
a841 1
	#    debug "VariableWin::displayedVariables"
d858 1
a858 2
	debug "deleteTree"
	#    debug "VariableWin::deleteTree"
@


1.3
log
@2000-05-01  Fernando Nasser  <fnasser@@cygnus.com>

	* regwin.itb (build_win): Adjust size of columns independently, force
	typed registers to raw mode and check if values can be edited.
	Also, add "Add to Watch" option to the menu.
	(update): Similar changes to similar code.
	(init_reg_display_vars): Initialize new variables used above.
	(reg_select): Deactivate menu options when action is not possible.
	(but3): Ditto.
	(edit): Do not edit if it is not editable.
	(acceptEdit): Fix bug is error message box display.
	(addToWatch): New mwthod.  Add a register to the Watch window.
	* regwin.ith: Add addToWatch to the class.
	* tclIndex: Regenerate.
@
text
@d42 4
@


1.2
log
@2000-03-30  Fernando Nasser  <fnasser@@totem.to.cygnus.com>

	* variables.tcl (edit): Remove call to close, which caused editing
	of variables to fail.
	Note: I don't know why we would need to do this here as it seems
	that the "delete entry" operation will do that.
	Perhaps this was to account to some old widget bug.
	But we cannot call close here because it calls UnEdit,
	which unsets some of the edit state.
        (open): Make sure to abort any ongoing edit.  This was causing problems
	when someone tried to expand an structure while editing its pointer.
@
text
@d537 4
@


1.1
log
@Initial revision
@
text
@a427 1
	close $variable
d645 5
@


1.1.1.1
log
@import insight-2000-02-04 snapshot (2nd try)
@
text
@@
