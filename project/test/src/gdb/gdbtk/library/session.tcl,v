head	1.17;
access;
symbols
	insight_7_6-2013-04-10-branchpoint:1.17
	gdb_7_6-branch:1.17.0.18
	gdb_7_5-branch:1.17.0.16
	gdb_7_4-branch:1.17.0.14
	gdb_7_3-branch:1.17.0.12
	gdb_7_1-branch:1.17.0.10
	gdb_7_0-branch:1.17.0.8
	arc-sim-20090309:1.17
	arc-insight_6_8-branch:1.17.0.6
	arc-insight_6_8-branchpoint:1.17
	insight_6_8-branch:1.17.0.4
	insight_6_8-branchpoint:1.17
	gdb_6_8-branch:1.17.0.2
	insight_6_6-20070208-release:1.16
	gdb_6_6-branch:1.16.0.4
	gdb_6_6-2006-11-15-branchpoint:1.16
	insight_6_5-20061003-release:1.16
	gdb_6_5-branch:1.16.0.2
	gdb_6_5-2006-05-14-branchpoint:1.16
	gdb-csl-gxxpro-6_3-branch:1.15.0.4
	gdb-csl-gxxpro-6_3-branchpoint:1.15
	gdb_6_4-branch:1.15.0.2
	gdb_6_4-2005-11-01-branchpoint:1.15
	gdb_6_1-2004-04-05-release:1.14
	gdb_6_1-branch:1.14.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.14
	gdb_6_0-2003-10-04-release:1.14
	gdb_6_0-branch:1.14.0.2
	gdb_6_0-2003-06-23-branchpoint:1.14
	gdb_5_3-2002-12-12-release:1.12
	gdb_5_3-branch:1.12.0.2
	gdb_5_3-2002-09-04-branchpoint:1.12
	gdb_5_2_1-2002-07-23-release:1.11
	gdb_5_2-2002-04-29-release:1.11
	gdb_5_2-branch:1.11.0.2
	gdb_5_2-2002-03-03-branchpoint:1.11
	gdb_5_1_1-2002-01-24-release:1.7
	cygnus_cvs_20020108_pre:1.10
	gdb_5_1_0_1-2002-01-03-branch:1.7.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.7
	gdb_5_1-2001-11-21-release:1.7
	gdb_s390-2001-09-26-branch:1.7.0.6
	gdb_s390-2001-09-26-branchpoint:1.7
	gdb_5_1-2001-07-29-branch:1.7.0.4
	gdb_5_1-2001-07-29-branchpoint:1.7
	dberlin-typesystem-branch:1.7.0.2
	dberlin-typesystem-branchpoint:1.7
	insight-precleanup-2001-01-01:1.4;
locks; strict;
comment	@# @;


1.17
date	2008.02.09.01.23.42;	author kseitz;	state Exp;
branches
	1.17.6.1;
next	1.16;

1.16
date	2005.12.23.18.26.50;	author eliz;	state Exp;
branches;
next	1.15;

1.15
date	2004.04.05.20.36.52;	author hunt;	state Exp;
branches;
next	1.14;

1.14
date	2003.02.04.07.15.49;	author hunt;	state Exp;
branches;
next	1.13;

1.13
date	2002.10.10.19.39.28;	author hunt;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.07.05.11.09;	author hunt;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.18.17.19.44;	author tromey;	state Exp;
branches;
next	1.10;

1.10
date	2002.01.03.21.42.32;	author hunt;	state Exp;
branches;
next	1.9;

1.9
date	2001.10.28.20.08.39;	author tromey;	state Exp;
branches;
next	1.8;

1.8
date	2001.10.06.18.10.50;	author tromey;	state Exp;
branches;
next	1.7;

1.7
date	2001.06.11.23.08.05;	author tromey;	state Exp;
branches;
next	1.6;

1.6
date	2001.04.18.17.44.00;	author tromey;	state Exp;
branches;
next	1.5;

1.5
date	2001.04.18.16.49.38;	author tromey;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.13.22.59.03;	author fnasser;	state Exp;
branches;
next	1.3;

1.3
date	2000.12.07.21.56.25;	author tromey;	state Exp;
branches;
next	1.2;

1.2
date	2000.11.30.22.49.46;	author tromey;	state dead;
branches;
next	1.1;

1.1
date	2000.11.30.22.37.29;	author tromey;	state Exp;
branches;
next	;

1.17.6.1
date	2009.09.11.04.45.50;	author amylaar;	state Exp;
branches;
next	;


desc
@@


1.17
log
@        * library/main.tcl: Add gdbtk_platform definitions.
        * library/attachdlg.itb (list_pids): Use gdbtk_platform
        instead of tcl_platform.
        * library/bpwin.itb (build_win): Likewise.
        (_bp_add): Likewise.
        (_bp_modify): Likewise.
        * library/download.itb (download_it): Likewise.
        * library/globalpref.itb (_build_win): Likewise.
        * library/helpviewer.tcl (open_help): Likewise.
        * library/interface.tcl (gdbtk_tcl_query): Likewise.
        (show_warning): Likewise.
        (open_file): Likewise.
        (run_executable): Likewise.
        * library/managedwin.itb (reveal): Likewise.
        (_create): Likewise.
        * library/prefs.tcl (pref_read): Likewise.
        (pref_set_defaults): Likewise.
        (pref_set_colors): Likewise.
        * library/session.tcl (_exe_name): Likewise.
        * library/srcbar.itcl (_update_file_menu): Likewise.
        (create_run_menu): Likewise.
        * library/srctextwin.itb (_mtime_changed): Likewise.
        (LoadFromCache): Likewise.
        * library/targetselection.itb (default_port): Likewise.
        (build_win): Likewise.

        * library/memwin.itb (build_win): Remove unused tcl_platform
        declaration.
        * library/pluginwin.itcl (enable_ui): Likewise.
        * library/process.itb (build_win): Likewise.
        * library/srcbar.itcl (enable_ui): Likewise.
        * library/srcwin.itb (location): Likewise.
        * library/stackwin.itb (build_win): Likewise.
        * library/tdump.tcl (build_win): Likewise.
@
text
@# Local preferences functions for Insight.
# Copyright (C) 2000, 2001, 2002, 2004, 2008 Red Hat, Inc.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License (GPL) as published by
# the Free Software Foundation; either version 2 of the License, or (at
# your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

namespace eval Session {
  namespace export save load notice_file_change delete list_names

  # An internal function for canonicalizing path names.  This probably
  # should use `realpath', but that is more work.  So for now we neglect
  # the possibility of symlinks.
  proc _exe_name {path} {

    # Get real directory.
    if {[string compare $::gdbtk_platform(os) "cygwin"] == 0} {
      set path [ide_cygwin_path to_win32 $path]
    }
    set save [pwd]
    cd [file dirname $path]
    set dir [pwd]
    cd $save
    return [file join $dir [file tail $path]]
  }

  # An internal function used when saving sessions.  Returns a string
  # that can be used to recreate all pertinent breakpoint state.
  proc _serialize_bps {} {
    set result {}

    # HACK.  When debugging gdb with itself in the build
    # directory, there is a ".gdbinit" file that will set
    # breakpoints on internal_error() and info_command().
    # If we then save and set them, they will accumulate.
    # Possible fixes are to modify GDB so we can tell which 
    # breakpoints were set from .gdbinit, or modify 
    # _recreate_bps to record which breakpoints were
    # set before it was called.  For now, we simply detect the
    # most common case and fix it.
    set basename [string tolower [file tail $::gdb_exe_name]]
    if {[string match "gdb*" $basename] 
	|| [string match "insight*" $basename]} {
      set debugging_gdb 1
    } else {
      set debugging_gdb 0
    }
    
    foreach bp_num [gdb_get_breakpoint_list] {
      lassign [gdb_get_breakpoint_info $bp_num] file function line_number \
	address type enabled disposition ignore_count command_list \
	condition thread hit_count user_specification

      # These breakpoints are set when debugging GDB with itself.
      # Ignore them so they don't accumulate. They get set again
      # by .gdbinit anyway. 
      if {$debugging_gdb} {
	if {$function == "internal_error" || $function == "info_command"} {
	  continue
	}
      }
      
      switch -glob -- $type {
	"breakpoint" -
	"hw breakpoint" {
	  if {$disposition == "delete"} {
	    set cmd tbreak
	  } else {
	    set cmd break
	  }

	  append cmd " "
	  if {$user_specification != ""} {
	    append cmd "$user_specification"
	  } elseif {$file != ""} {
	    # BpWin::bp_store uses file tail here, but I think that is
	    # wrong.
	    append cmd "$file:$line_number"
	  } else {
	    append cmd "*$address"
	  }
	}
	"watchpoint" -
	"hw watchpoint" {
	  set cmd watch
	  if {$user_specification != ""} {
	    append cmd " $user_specification"
	  } else {
	    # There's nothing sensible to do.
	    continue
	  }
	}

	"catch*" {
	  # FIXME: Don't know what to do.
	  continue
	}

	default {
	  # Can't serialize anything other than those listed above.
	  continue
	}
      }

      lappend result [list $cmd $enabled $condition $command_list]
    }
    
    return $result
  }

  # An internal function used when loading sessions.  It takes a
  # breakpoint string and recreates all the breakpoints.
  proc _recreate_bps {specs} {  
    foreach spec $specs {
      lassign $spec create enabled condition commands

      # Create the breakpoint
      if {[catch {gdb_cmd $create} txt]} {
	dbug W $txt
      }

      # Below we use `\$bpnum'.  This means we don't have to figure out
      # the number of the breakpoint when doing further manipulations.

      if {! $enabled} {
	gdb_cmd "disable \$bpnum"
      }

      if {$condition != ""} {
	gdb_cmd "cond \$bpnum $condition"
      }

      if {[llength $commands]} {
	lappend commands end
	eval gdb_run_readline_command_no_output [list "commands \$bpnum"] \
	  $commands
      }
    }
  }

  #
  # This procedure decides what makes up a gdb `session'.  Roughly a
  # session is whatever the user found useful when debugging a certain
  # executable.
  #
  # Eventually we should expand this procedure to know how to save
  # window placement and contents.  That requires more work.
  #
  proc save {} {
    global gdb_exe_name gdb_target_name
    global gdb_current_directory gdb_source_path

    # gdb sessions are named after the executable.
    set name [_exe_name $gdb_exe_name]
    set key gdb/session/$name

    # We fill a hash and then use that to set the actual preferences.

    # Always set the exe. name in case we later decide to change the
    # interpretation of the session key.  Use the full path to the
    # executable.
    set values(executable) $name

    # Some simple state the user wants.
    set values(args) [gdb_get_inferior_args]
    set values(dirs) $gdb_source_path
    set values(pwd) $gdb_current_directory
    set values(target) $gdb_target_name
    set values(hostname) [pref getd gdb/load/$gdb_target_name-hostname]
    set values(port) [pref getd gdb/load/$gdb_target_name-portname]
    set values(target_cmd) $::gdb_target_cmd
    set values(bg) $::gdb_bg_num

    # these prefs need to be made session-dependent
    set values(run_attach) [pref get gdb/src/run_attach]
    set values(run_load) [pref get gdb/src/run_load]
    set values(run_run) [pref get gdb/src/run_run]
    set values(run_cont) [pref get gdb/src/run_cont]
    
    # Breakpoints.
    set values(breakpoints) [_serialize_bps]

    # Recompute list of recent sessions.  Trim to no more than 20 sessions.
    set recent [concat [list $name] \
		  [lremove [pref getd gdb/recent-projects] $name]]
    if {[llength $recent] > 20} {
      set recent [lreplace $recent 20 end]
    }
    pref setd gdb/recent-projects $recent

    foreach k [array names values] {
      pref setd $key/$k $values($k)
    }
    pref setd $key/all-keys [array names values]
  }

  #
  # Load a session saved with Session::save.  NAME is the pretty name of
  # the session, as returned by Session::list_names.
  #
  proc load {name} {
    # gdb sessions are named after the executable.
    set key gdb/session/$name

    # Fetch all keys for this session into an array.
    foreach k [pref getd $key/all-keys] {
      set values($k) [pref getd $key/$k]
    }

    if {[info exists values(executable)]} {
      gdb_clear_file
      set_exe_name $values(executable)
      set_exe
    }
  }

  #
  # This is called from file_changed_hook.  It does all the work of
  # loading a session, if one exists with the same name as the current
  # executable.
  #
  proc notice_file_change {} {
    global gdb_exe_name gdb_target_name

    debug "noticed file change event for $gdb_exe_name"

    # gdb sessions are named after the executable.
    set name [_exe_name $gdb_exe_name]
    set key gdb/session/$name

    # Fetch all keys for this session into an array.
    foreach k [pref getd $key/all-keys] {
      set values($k) [pref getd $key/$k]
    }

    # reset these back to their defaults
    pref set gdb/src/run_attach          0
    pref set gdb/src/run_load            0
    pref set gdb/src/run_run             1
    pref set gdb/src/run_cont            0

    if {! [info exists values(executable)] || $values(executable) != $name} {
      # No such session.
      return
    }

    debug "reloading session for $name"

    if {[info exists values(dirs)]} {
      # FIXME: short-circuit confirmation.
      gdb_cmd "directory"
      gdb_cmd "directory $values(dirs)"
    }

    if {[info exists values(pwd)]} {
      catch {gdb_cmd "cd $values(pwd)"}
    }

    if {[info exists values(args)]} {
      gdb_set_inferior_args $values(args)
    }

    if {[info exists values(breakpoints)]} {
      _recreate_bps $values(breakpoints)
    }

    if {[info exists values(target)]} {
      #debug "Restoring Target: $values(target)"
      set gdb_target_name $values(target)

      if {[info exists values(hostname)]} {
	pref setd gdb/load/$gdb_target_name-hostname $values(hostname)
	#debug "Restoring Hostname: $values(hostname)"
      }

      if {[info exists values(port)]} {
	pref setd gdb/load/$gdb_target_name-portname $values(port)
	#debug "Restoring Port: $values(port)"
      }

      #debug "Restoring Target_Cmd: $values(target_cmd)"
      set ::gdb_target_cmd $values(target_cmd)
      set_baud
    }
    
    if {[info exists values(run_attach)]} {
      pref set gdb/src/run_attach $values(run_attach)
      pref set gdb/src/run_load $values(run_load)
      pref set gdb/src/run_run $values(run_run)
      pref set gdb/src/run_cont $values(run_cont)
    }

    if {[info exists values(bg)] && [pref get gdb/use_color_schemes]} {
      set_bg_colors $values(bg)
    }
  }

  #
  # Delete a session.  NAME is the internal name of the session.
  #
  proc delete {name} {
    # FIXME: we can't yet fully define this because the libgui
    # preference code doesn't supply a delete method.
    set recent [lremove [pref getd gdb/recent-projects] $name]
    pref setd gdb/recent-projects $recent
  }

  #
  # Return a list of all known sessions.  This returns the `pretty name'
  # of the session -- something suitable for a menu.
  #
  proc list_names {} {
    set newlist {}
    set result {}
    foreach name [pref getd gdb/recent-projects] {
      set exe [pref getd gdb/session/$name/executable]
      # Take this opportunity to prune the list.
      if {[file exists $exe]} then {
	lappend newlist $name
	lappend result $exe
      } else {
	# FIXME: if we could delete keys we would delete all keys
	# associated with NAME now.
      }
    }
    pref setd gdb/recent-projects $newlist
    return $result
  }
}
@


1.17.6.1
log
@gdb/insight for ARCompact (from Richard Stuckey)
@
text
@a175 1
    set values(filename) [pref getd gdb/load/$gdb_target_name-filename]
a281 5
      if {[info exists values(filename)]} {
	pref setd gdb/load/$gdb_target_name-filename $values(filename)
	#debug "Restoring Hostname: $values(filename)"
      }

@


1.16
log
@	* library/attachdlg.itb:
	* library/actiondlg.tcl:
	* library/about.tcl:
	* library/ehandler.itb:
	* library/editor.tcl:
	* library/download.ith:
	* library/download.itb:
	* library/debugwin.ith:
	* library/debugwin.itb:
	* library/cspref.ith:
	* library/cspref.itb:
	* library/console.ith:
	* library/console.itb:
	* library/browserwin.ith:
	* library/browserwin.itb:
	* library/bpwin.ith:
	* library/bpwin.itb:
	* library/blockframe.ith:
	* library/managedwin.ith:
	* library/managedwin.itb:
	* library/main.tcl:
	* library/locals.tcl:
	* library/ipcpref.ith:
	* library/ipcpref.itb:
	* library/ipc.tcl:
	* library/interface.tcl:
	* library/helpviewer.tcl:
	* library/globalpref.ith:
	* library/globalpref.itb:
	* library/gdbwin.ith:
	* library/gdbtoolbar.itcl:
	* library/gdbmenubar.itcl:
	* library/gdbevent.ith:
	* library/gdbevent.itb:
	* library/embeddedwin.ith:
	* library/ehandler.ith:
	* library/srcwin.itb:
	* library/srctextwin.ith:
	* library/srctextwin.itb:
	* library/srcpref.ith:
	* library/srcpref.itb:
	* library/srcbar.itcl:
	* library/session.tcl:
	* library/regwin.ith:
	* library/regwin.itb:
	* library/process.ith:
	* library/process.itb:
	* library/prefs.tcl:
	* library/pluginwin.itcl:
	* library/modal.tcl:
	* library/memwin.ith:
	* library/memwin.itb:
	* library/mempref.ith:
	* library/mempref.itb:
	* library/watch.tcl:
	* library/watch.tcl:
	* library/warning.tcl:
	* library/vartree.ith:
	* library/vartree.itb:
	* library/util.tcl:
	* library/tracedlg.tcl:
	* library/toplevelwin.ith:
	* library/tfind_args.tcl:
	* library/tdump.tcl:
	* library/targetselection.ith:
	* library/targetselection.itb:
	* library/stackwin.ith:
	* library/stackwin.itb:
	* library/srcwin.ith:
@
text
@d2 1
a2 1
# Copyright (C) 2000, 2001, 2002, 2004 Red Hat, Inc.
a20 1
    global tcl_platform
d23 1
a23 1
    if {[string compare $tcl_platform(platform) "windows"] == 0} {
@


1.15
log
@2004-04-05  Martin Hunt  <hunt@@redhat.com>

	* library/session.tcl: Make hostname and portname
	session-dependent. Add gdb_bg_num (the color
	scheme number) as a per-session variable.

	* library/prefs.tcl (pref_read): If color schemes are in use,
	set colors based on the current scheme.
	(pref_save): Add "bg" section.
	(pref_set_defaults): Define new variable gdb/use_color_schemes
	and define 16 default background colors.

	* library/managedwin.itb (ManagedWin::window_name): Append
	window "instance" string to window name.
	(ManagedWin::window_instance): Set window instance string.

	* library/debugwin.itb: Add a reconfig method to restore
	unique black textbackground, overriding color scheme.

	* library/csprefs.itb:
	* library/csprefs.ith: New files. Implement color scheme
	preferences.

	* library/util.tcl (set_bg_colors): New function.
	(r_setcolors): New function.

	* library/regwin.itb (_prefs_changed): Deleted.
	(reconfig): New function.  Updates tkTable color tags
	if color scheme changes.
	* library/regwin.ith: Update to reflect above changes.

	* library/srcbar.itcl (create_pref_menu): Add pulldown
	menus for "Edit Color Schemes..." and "Use Color Schemes".
	(reconfig): Fix up menu items for color schemes.

	* library/globalpref.itb (_init_var): Add
	gdb/use_color_schemes to variable list.
	(_build_win): Add a checkbutton to enable/disable
	color schemes.

	* library/gdbmenubar.itcl (menubar_add_cascade): Add a class
	argument so cascade menus can be managed by class too.

	* library/interface.tcl (gdbtk_tcl_fputs): Check for
	existence of gdbtk_state(console).  Stops annoying error
	messages.
	(gdbtk_tcl_fputs_error): Ditto.
	(gdbtk_tcl_fputs_log): Ditto.
@
text
@d2 1
a2 1
# Copyright 2000, 2001, 2002, 2004 Red Hat, Inc.
@


1.14
log
@2003-02-03  Martin M. Hunt  <hunt@@redhat.com>

	* library/session.tcl (_recreate_bps): Catch errors.
@
text
@d1 2
a2 2
# Local preferences functions for GDBtk.
# Copyright 2000, 2001, 2002 Red Hat, Inc.
d176 2
d179 1
d190 1
a190 1
    # Recompute list of recent sessions.  Trim to no more than 5 sessions.
d193 2
a194 2
    if {[llength $recent] > 5} then {
      set recent [lreplace $recent 5 end]
d254 1
a254 1
    debug "reloading session for $gdb_exe_name"
d275 1
a275 1
      debug "Restoring Target: $values(target)"
d277 12
a288 1
      debug "Restoring Target_Cmd: $values(target_cmd)"
d298 5
a302 1
    } 
@


1.13
log
@2002-10-10  Martin M. Hunt  <hunt@@redhat.com>

	* library/session.tcl (save): Save target_cmd,
	attach, load, run, and cont as session prefs.
	(notice_file_change): Load in above session
	prefs.

	* library/interface.tcl (set_target): Set icons busy
	before attempting target command and set back to idle after.
	(run_executable): Return on ATTACH_ERROR.
	(gdbtk_run): If run button is hit when a program
	is currently being debugged, put up a dialog allowing
	user to continue or cancel.
@
text
@d125 3
a127 1
      gdb_cmd $create
@


1.12
log
@2002-05-06  Martin M. Hunt  <hunt@@redhat.com>

	* library/session.tcl (notice_file_change): Catch the
	directory change, in case the directory no longer exists.
@
text
@d174 1
d176 6
a203 2
    global gdb_target_name

d238 6
d272 11
a282 1
    }
@


1.11
log
@	* library/tclIndex: Updated.
	* library/srcbar.itcl (SrcBar): Use new Session namespace.
	* library/main.tcl: Use new Session namespace.
	* library/interface.tcl (gdbtk_tcl_preloop): Use new Session
	namespace.
	(gdbtk_cleanup): Likewise.
	(_close_file): Likewise.
	* library/session.tcl: Use a namespace.  Renamed all functions.
@
text
@d247 1
a247 1
      gdb_cmd "cd $values(pwd)"
@


1.10
log
@2002-01-03  Martin M. Hunt  <hunt@@redhat.com>

	* library/session.tcl (SESSION_serialize_bps): Ignore
	breakpoints set on internal_error and info_command because
	these are set by .gdbinit and will be recreated by it.
	This is a bit of a hack and should be fixed properly
	someday.
@
text
@d14 40
a53 51
# An internal function for canonicalizing path names.  This probably
# should use `realpath', but that is more work.  So for now we neglect
# the possibility of symlinks.
proc SESSION_exe_name {path} {
  global tcl_platform

  # Get real directory.
  if {[string compare $tcl_platform(platform) "windows"] == 0} {
    set path [ide_cygwin_path to_win32 $path]
  }
  set save [pwd]
  cd [file dirname $path]
  set dir [pwd]
  cd $save
  return [file join $dir [file tail $path]]
}

# An internal function used when saving sessions.  Returns a string
# that can be used to recreate all pertinent breakpoint state.
proc SESSION_serialize_bps {} {
  set result {}

  # HACK.  When debugging gdb with itself in the build
  # directory, there is a ".gdbinit" file that will set
  # breakpoints on internal_error() and info_command().
  # If we then save and set them, they will accumulate.
  # Possible fixes are to modify GDB so we can tell which 
  # breakpoints were set from .gdbinit, or modify 
  # SESSION_recreate_bps to record which breakpoints were
  # set before it was called.  For now, we simply detect the
  # most common case and fix it.
  set basename [string tolower [file tail $::gdb_exe_name]]
  if {[string match "gdb*" $basename] 
      || [string match "insight*" $basename]} {
    set debugging_gdb 1
  } else {
    set debugging_gdb 0
  }
  
  foreach bp_num [gdb_get_breakpoint_list] {
    lassign [gdb_get_breakpoint_info $bp_num] file function line_number \
      address type enabled disposition ignore_count command_list \
      condition thread hit_count user_specification

    # These breakpoints are set when debugging GDB with itself.
    # Ignore them so they don't accumulate. They get set again
    # by .gdbinit anyway. 
    if {$debugging_gdb} {
      if {$function == "internal_error" || $function == "info_command"} {
	continue
      }
d56 43
a98 7
    switch -glob -- $type {
      "breakpoint" -
      "hw breakpoint" {
	if {$disposition == "delete"} {
	  set cmd tbreak
	} else {
	  set cmd break
d101 3
a103 9
	append cmd " "
	if {$user_specification != ""} {
	  append cmd "$user_specification"
	} elseif {$file != ""} {
	  # BpWin::bp_store uses file tail here, but I think that is
	  # wrong.
	  append cmd "$file:$line_number"
	} else {
	  append cmd "*$address"
d105 3
a107 8
      }
      "watchpoint" -
      "hw watchpoint" {
	set cmd watch
	if {$user_specification != ""} {
	  append cmd " $user_specification"
	} else {
	  # There's nothing sensible to do.
d112 1
a112 9
      "catch*" {
	# FIXME: Don't know what to do.
	continue
      }

      default {
	# Can't serialize anything other than those listed above.
	continue
      }
d114 2
a115 2

    lappend result [list $cmd $enabled $condition $command_list]
a116 3
  
  return $result
}
d118 5
a122 5
# An internal function used when loading sessions.  It takes a
# breakpoint string and recreates all the breakpoints.
proc SESSION_recreate_bps {specs} {  
  foreach spec $specs {
    lassign $spec create enabled condition commands
d124 2
a125 2
    # Create the breakpoint
    gdb_cmd $create
d127 2
a128 2
    # Below we use `\$bpnum'.  This means we don't have to figure out
    # the number of the breakpoint when doing further manipulations.
d130 3
a132 3
    if {! $enabled} {
      gdb_cmd "disable \$bpnum"
    }
d134 3
a136 3
    if {$condition != ""} {
      gdb_cmd "cond \$bpnum $condition"
    }
d138 5
a142 4
    if {[llength $commands]} {
      lappend commands end
      eval gdb_run_readline_command_no_output [list "commands \$bpnum"] \
	$commands
a144 17
}

#
# This procedure decides what makes up a gdb `session'.  Roughly a
# session is whatever the user found useful when debugging a certain
# executable.
#
# Eventually we should expand this procedure to know how to save
# window placement and contents.  That requires more work.
#
proc session_save {} {
  global gdb_exe_name gdb_target_name
  global gdb_current_directory gdb_source_path

  # gdb sessions are named after the executable.
  set name [SESSION_exe_name $gdb_exe_name]
  set key gdb/session/$name
d146 3
a148 4
  # We fill a hash and then use that to set the actual preferences.

  # Always set the exe. name in case we later decide to change the
  # interpretation of the session key.  Use the full path to the
d150 35
a184 1
  set values(executable) $name
d186 4
a189 14
  # Some simple state the user wants.
  set values(args) [gdb_get_inferior_args]
  set values(dirs) $gdb_source_path
  set values(pwd) $gdb_current_directory
  set values(target) $gdb_target_name

  # Breakpoints.
  set values(breakpoints) [SESSION_serialize_bps]

  # Recompute list of recent sessions.  Trim to no more than 5 sessions.
  set recent [concat [list $name] \
		[lremove [pref getd gdb/recent-projects] $name]]
  if {[llength $recent] > 5} then {
    set recent [lreplace $recent 5 end]
a190 1
  pref setd gdb/recent-projects $recent
d192 14
a205 5
  foreach k [array names values] {
    pref setd $key/$k $values($k)
  }
  pref setd $key/all-keys [array names values]
}
d207 5
a211 13
#
# Load a session saved with session_save.  NAME is the pretty name of
# the session, as returned by session_list.
#
proc session_load {name} {
  global gdb_target_name

  # gdb sessions are named after the executable.
  set key gdb/session/$name

  # Fetch all keys for this session into an array.
  foreach k [pref getd $key/all-keys] {
    set values($k) [pref getd $key/$k]
d214 18
a231 6
  if {[info exists values(executable)]} {
    gdb_clear_file
    set_exe_name $values(executable)
    set_exe
  }
}
d233 4
a236 23
#
# This is called from file_changed_hook.  It does all the work of
# loading a session, if one exists with the same name as the current
# executable.
#
proc session_notice_file_change {} {
  global gdb_exe_name gdb_target_name

  debug "noticed file change event for $gdb_exe_name"

  # gdb sessions are named after the executable.
  set name [SESSION_exe_name $gdb_exe_name]
  set key gdb/session/$name

  # Fetch all keys for this session into an array.
  foreach k [pref getd $key/all-keys] {
    set values($k) [pref getd $key/$k]
  }

  if {! [info exists values(executable)] || $values(executable) != $name} {
    # No such session.
    return
  }
d238 1
a238 1
  debug "reloading session for $gdb_exe_name"
d240 5
a244 5
  if {[info exists values(dirs)]} {
    # FIXME: short-circuit confirmation.
    gdb_cmd "directory"
    gdb_cmd "directory $values(dirs)"
  }
d246 3
a248 3
  if {[info exists values(pwd)]} {
    gdb_cmd "cd $values(pwd)"
  }
d250 3
a252 3
  if {[info exists values(args)]} {
    gdb_set_inferior_args $values(args)
  }
d254 3
a256 3
  if {[info exists values(breakpoints)]} {
    SESSION_recreate_bps $values(breakpoints)
  }
d258 4
a261 3
  if {[info exists values(target)]} {
    debug "Restoring Target: $values(target)"
    set gdb_target_name $values(target)
a262 1
}
d264 27
a290 26
#
# Delete a session.  NAME is the internal name of the session.
#
proc session_delete {name} {
  # FIXME: we can't yet fully define this because the libgui
  # preference code doesn't supply a delete method.
  set recent [lremove [pref getd gdb/recent-projects] $name]
  pref setd gdb/recent-projects $recent
}

#
# Return a list of all known sessions.  This returns the `pretty name'
# of the session -- something suitable for a menu.
#
proc session_list {} {
  set newlist {}
  set result {}
  foreach name [pref getd gdb/recent-projects] {
    set exe [pref getd gdb/session/$name/executable]
    # Take this opportunity to prune the list.
    if {[file exists $exe]} then {
      lappend newlist $name
      lappend result $exe
    } else {
      # FIXME: if we could delete keys we would delete all keys
      # associated with NAME now.
d292 2
a294 2
  pref setd gdb/recent-projects $newlist
  return $result
@


1.9
log
@	* tclIndex: Updated.
	* library/main.tcl: Add session_notice_file_change to
	file_changed_hook.
	* library/session.tcl (session_load): Only load the executable.
	(session_notice_file_change): New proc.
	(SESSION_exe_name): New proc.
	(session_save): Use it.
	(session_notice_file_change): Likewise.
	* library/interface.tcl (gdbtk_tcl_exec_file_display): Don't call
	session_save.
	(gdbtk_tcl_preloop): Don't set executable name or try to find
	main.  Notice a new session if required.
@
text
@d2 1
a2 1
# Copyright 2000 Red Hat, Inc.
d36 17
d58 9
d111 1
a111 1

d117 1
a117 1
proc SESSION_recreate_bps {specs} {
@


1.8
log
@	* library/session.tcl (SESSION_recreate_bps): Use
	gdb_run_readline_command_no_output to recreate breakpoints.
	* library/interface.tcl (gdb_run_readline_command): Set
	readlineShowUser element of gdbtk_state.
	(gdb_run_readline_command_no_output): New proc.
	(initialize_gdbtk): Initialize readlineShowUser element.
	(gdbtk_tcl_readline_begin): Use readlineShowUser element.
	(gdbtk_tcl_readline): Likewise.
@
text
@d14 17
d130 1
a130 1
  set name $gdb_exe_name
d136 3
a138 2
  # interpretation of the session key.
  set values(executable) $gdb_exe_name
d178 33
a222 6
  }

  if {[info exists values(executable)]} {
    gdb_clear_file
    set_exe_name $values(executable)
    set_exe
@


1.7
log
@	* library/session.tcl (session_save): Save breakpoints.
	(SESSION_serialize_bps): New proc.
	(SESSION_recreate_bps): New proc.
	(session_load): Recreate breakpoints.
	* library/util.tcl (bp_exists): Expect user specification in
	breakpoint info.
	* library/srctextwin.itb (SrcTextWin::showBPBalloon): Expect user
	specification in breakpoint info.
	* library/gdbevent.itb (BreakpointEvent::_init): Initialize
	_user_specification.
	(BreakpointEvent::get): Handle user_specification.
	* library/gdbevent.ith (BreakpointEvent): Added
	_user_specification field.
	* library/bpwin.itb (BpWin::bp_store): Expect user specification
	and use it when saving.
	(BpWin::bp_type): Expect user specification.
	* generic/gdbtk-bp.c (BREAKPOINT_IS_WATCHPOINT): New macro.
	(gdb_get_breakpoint_info): Added `user specification' to result.
@
text
@d94 2
a95 1
      gdb_cmd "commands \$bpnum\n[join $commands \n]"
@


1.6
log
@	* library/interface.tcl (run_executable): Use
	gdb_set_inferior_args.
	* library/session.tcl (session_load): Use gdb_set_inferior_args.
	* generic/gdbtk-cmds.c (Gdbtk_Init): Register
	gdb_set_inferior_args.
	(gdb_get_inferior_args): New function.
@
text
@d14 85
d127 3
d177 4
@


1.5
log
@	* library/session.tcl (session_save): Use gdb_get_inferior_args.
	* generic/gdbtk-cmds.c (inferior_args): Removed.
	(Gdbtk_Init): Don't register gdb_inferior_args variable.  Do
	register gdb_get_inferior_args function.
	(gdb_get_inferior_args): New function.
@
text
@d82 1
a82 1
    gdb_cmd "set args $values(args)"
@


1.4
log
@2000-12-13  Fernando Nasser  <fnasser@@redhat.com>

	* session.tcl (session_save): Save target name.
	(session_load): Restore target name.
@
text
@d24 1
a24 1
  global gdb_current_directory gdb_source_path gdb_inferior_args
d37 1
a37 1
  set values(args) $gdb_inferior_args
@


1.3
log
@	* tclIndex: Rebuilt.
	* interface.tcl (set_exe_name): Save session.
	(gdbtk_quit_check): Save session.
	* session.tcl: New file.
	* srcbar.tcl (create_menu_items): Add menu items to recall old
	sessions.
@
text
@d61 2
d91 4
a94 1
  # FIXME: handle target
@


1.2
log
@Reverted erroneous checkin.  Sorry about that.
@
text
@d36 1
a36 2
  # Some simple state the user wants.  FIXME: these should have
  # dedicated commands instead of using `gdb_cmd'.
a39 1

@


1.1
log
@	* prefs.tcl (pref_save): Put version number into file.  Added
	`session' to list of top-level keys.  Allow keys with many `/'s.
	(pref_read): Recognize version number.
	(escape_value): Generate URL-style encoding.
	(unescape_value): Added `version' argument.  Handle URL decoding.
@
text
@@

