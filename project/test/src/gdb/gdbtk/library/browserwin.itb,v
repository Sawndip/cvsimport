head	1.10;
access;
symbols
	insight_7_6-2013-04-10-branchpoint:1.10
	gdb_7_6-branch:1.10.0.22
	gdb_7_5-branch:1.10.0.20
	gdb_7_4-branch:1.10.0.18
	gdb_7_3-branch:1.10.0.16
	gdb_7_1-branch:1.10.0.14
	gdb_7_0-branch:1.10.0.12
	arc-sim-20090309:1.10
	arc-insight_6_8-branch:1.10.0.10
	arc-insight_6_8-branchpoint:1.10
	insight_6_8-branch:1.10.0.8
	insight_6_8-branchpoint:1.10
	gdb_6_8-branch:1.10.0.6
	insight_6_6-20070208-release:1.10
	gdb_6_6-branch:1.10.0.4
	gdb_6_6-2006-11-15-branchpoint:1.10
	insight_6_5-20061003-release:1.10
	gdb_6_5-branch:1.10.0.2
	gdb_6_5-2006-05-14-branchpoint:1.10
	gdb-csl-gxxpro-6_3-branch:1.9.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.9
	gdb_6_4-branch:1.9.0.6
	gdb_6_4-2005-11-01-branchpoint:1.9
	gdb_6_1-2004-04-05-release:1.9
	gdb_6_1-branch:1.9.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.9
	gdb_6_0-2003-10-04-release:1.9
	gdb_6_0-branch:1.9.0.2
	gdb_6_0-2003-06-23-branchpoint:1.9
	gdb_5_3-2002-12-12-release:1.6
	gdb_5_3-branch:1.6.0.2
	gdb_5_3-2002-09-04-branchpoint:1.6
	gdb_5_2_1-2002-07-23-release:1.3
	gdb_5_2-2002-04-29-release:1.3
	gdb_5_2-branch:1.3.0.2
	gdb_5_2-2002-03-03-branchpoint:1.3
	gdb_5_1_1-2002-01-24-release:1.2
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.2.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.2
	gdb_5_1-2001-11-21-release:1.2
	gdb_s390-2001-09-26-branch:1.2.0.6
	gdb_s390-2001-09-26-branchpoint:1.2
	gdb_5_1-2001-07-29-branch:1.2.0.4
	gdb_5_1-2001-07-29-branchpoint:1.2
	dberlin-typesystem-branch:1.2.0.2
	dberlin-typesystem-branchpoint:1.2
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	insight-2000-02-04:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.10
date	2005.12.23.18.26.50;	author eliz;	state Exp;
branches;
next	1.9;

1.9
date	2003.02.10.20.12.23;	author hunt;	state Exp;
branches;
next	1.8;

1.8
date	2003.02.10.09.47.52;	author hunt;	state Exp;
branches;
next	1.7;

1.7
date	2002.10.15.21.19.50;	author hunt;	state Exp;
branches;
next	1.6;

1.6
date	2002.08.01.01.19.02;	author kseitz;	state Exp;
branches;
next	1.5;

1.5
date	2002.06.07.09.22.44;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.05.22.22.19;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.02.11.03.21.56;	author drow;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.15.19.44.30;	author hunt;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.07.00.19.42;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.07.00.19.42;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.10
log
@	* library/attachdlg.itb:
	* library/actiondlg.tcl:
	* library/about.tcl:
	* library/ehandler.itb:
	* library/editor.tcl:
	* library/download.ith:
	* library/download.itb:
	* library/debugwin.ith:
	* library/debugwin.itb:
	* library/cspref.ith:
	* library/cspref.itb:
	* library/console.ith:
	* library/console.itb:
	* library/browserwin.ith:
	* library/browserwin.itb:
	* library/bpwin.ith:
	* library/bpwin.itb:
	* library/blockframe.ith:
	* library/managedwin.ith:
	* library/managedwin.itb:
	* library/main.tcl:
	* library/locals.tcl:
	* library/ipcpref.ith:
	* library/ipcpref.itb:
	* library/ipc.tcl:
	* library/interface.tcl:
	* library/helpviewer.tcl:
	* library/globalpref.ith:
	* library/globalpref.itb:
	* library/gdbwin.ith:
	* library/gdbtoolbar.itcl:
	* library/gdbmenubar.itcl:
	* library/gdbevent.ith:
	* library/gdbevent.itb:
	* library/embeddedwin.ith:
	* library/ehandler.ith:
	* library/srcwin.itb:
	* library/srctextwin.ith:
	* library/srctextwin.itb:
	* library/srcpref.ith:
	* library/srcpref.itb:
	* library/srcbar.itcl:
	* library/session.tcl:
	* library/regwin.ith:
	* library/regwin.itb:
	* library/process.ith:
	* library/process.itb:
	* library/prefs.tcl:
	* library/pluginwin.itcl:
	* library/modal.tcl:
	* library/memwin.ith:
	* library/memwin.itb:
	* library/mempref.ith:
	* library/mempref.itb:
	* library/watch.tcl:
	* library/watch.tcl:
	* library/warning.tcl:
	* library/vartree.ith:
	* library/vartree.itb:
	* library/util.tcl:
	* library/tracedlg.tcl:
	* library/toplevelwin.ith:
	* library/tfind_args.tcl:
	* library/tdump.tcl:
	* library/targetselection.ith:
	* library/targetselection.itb:
	* library/stackwin.ith:
	* library/stackwin.itb:
	* library/srcwin.ith:
@
text
@# Browswer window for Insight.
# Copyright (C) 1998, 1999, 2001, 2002, 2003 Red Hat, Inc.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License (GPL) as published by
# the Free Software Foundation; either version 2 of the License, or (at
# your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.


# ----------------------------------------------------------------------
# Implements Browser window for Insight
#
# ----------------------------------------------------------------------

option add *BrowserWin.textBackground  $::Colors(textbg)

# ------------------------------------------------------------------
#  CONSTRUCTOR - create new browser window
# ------------------------------------------------------------------
itcl::body BrowserWin::constructor {args} {
  debug
  #eval itk_initialize $args 
  window_name "Function Browser"

  set _layout [pref get gdb/browser/layout]
  set Current(filename) {}
  set Current(function) {}
  _build_win

  eval itk_initialize $args
  add_hook file_changed_hook [code $this _fill_file_box]
}

# ------------------------------------------------------------------
#  DESTRUCTOR - destroy window containing widget
# ------------------------------------------------------------------
itcl::body BrowserWin::destructor {} {
  debug
  if {$filter_trace_after != ""} {
    after cancel $filter_trace_after
  }

  remove_hook file_changed_hook [code $this _fill_file_box]
  trace vdelete [pref varname gdb/search/last_symbol] \
    w [code $this _filter_trace_proc]
}

# ------------------------------------------------------------------
#  METHOD:  _build_win - build the main browser window
# ------------------------------------------------------------------
itcl::body BrowserWin::_build_win {} {
  debug

  # popup menu
  itk_component add popup {
    menu $itk_interior.pop -tearoff 0
  } {}
  set pop $itk_component(popup)
  $pop add command -label "Toggle Layout" -command [code $this _switch_layout]
  $pop add command -label "Help" -command "open_help browser.html"
  $pop add separator
  $pop add command -label "Close" -command "destroy [winfo toplevel $itk_interior]"
  bind [winfo toplevel $itk_interior] <3> "tk_popup $itk_component(popup) %X %Y"

  # Four Main Frames: filter, files, functions, and view (source)
  # Their layout depends on _layout

  if {$_layout == 1} {
    set p [cyg::panedwindow $itk_interior.p -orient vertical -height 5i \
	     -width 5i]
    $p add left
    set p2 [cyg::panedwindow [$p childsite left].p]
   
    $p2 add file
    _build_file_frame [$p2 childsite file]

    $p2 add filter
    set f [frame [$p2 childsite filter].f]
    _build_filter_frame $f
    _build_function_frame $f
    pack $f -fill both -expand yes
    pack $p2 -fill both -expand yes

    $p add view
    _build_view_frame [$p childsite view]

  } else {
    set p [cyg::panedwindow $itk_interior.p -height 5i -width 5i]
    $p add top
    set f [frame [$p childsite top].f]
    _build_filter_frame $f

    set browser [cyg::panedwindow $f.p -orient vertical]
    $browser add file
    _build_file_frame [$browser childsite file]
    $browser add function
    _build_function_frame [$browser childsite function]

    pack $browser -fill both -expand yes
    pack $f -fill both -expand yes

    $p add view
    _build_view_frame [$p childsite view]
  }
  
  # Fill file box
  _fill_file_box

  pack $p -fill both -expand yes
}

# ------------------------------------------------------------------
#  METHOD:  _filter_trace_proc
#           This is called when something is entered in the filter
#           box.  The actual filtering is done in an after to avoid
#           flashing too much if the user is typing quickly.
# ------------------------------------------------------------------
itcl::body BrowserWin::_filter_trace_proc {v1 v2 mode} {
  if {$filter_trace_after != ""} {
    after cancel $filter_trace_after
  }
  set filter_trace_after [after 100 [code $this _filter_trace_after]]
}

# ------------------------------------------------------------------
#  METHOD:  _filter_trace_after
#           This is a wrapper around search, needed to pass to trace
# ------------------------------------------------------------------
itcl::body BrowserWin::_filter_trace_after {} {
  set filter_trace_after ""
  search
}

# ------------------------------------------------------------------
#  METHOD:  _search_src
#           Search for text or jump to a specific line
#           in source window, going in the specified DIRECTION.
# ------------------------------------------------------------------
itcl::body BrowserWin::_search_src {direction} {
  set exp [$itk_component(view_search) get]
  $itk_component(view_src) search $exp $direction
}

# ------------------------------------------------------------------
#  METHOD:  search
#           Search for functions matching regexp/pattern
#           in specified files
# ------------------------------------------------------------------
itcl::body BrowserWin::search {} {

  set files [$itk_component(file_box) getcurselection]

  if {[llength $files] == 0} {
    return
  }

  _freeze_me

  set filt_pat [format $filter_regexp($cur_filter_mode) \
		  [pref get gdb/search/last_symbol]]

  if {[llength $files] == [$itk_component(file_box) size]} {
    set err [catch {gdb_search functions $filt_pat \
		    -filename 1} matches]
  } else {
    set err [catch {gdb_search functions $filt_pat \
		      -files $files -filename 1} matches]
  }

  if {$err} {
    debug "ERROR searching for [pref get gdb/search/last_symbol]: $matches"
    _thaw_me
    return
  }

  $itk_component(func_box) delete 0 end

  set i -1
  catch {unset index_to_file}

  foreach func [lsort -command "list_element_strcmp 0" $matches] {
    $itk_component(func_box) insert end [lindex $func 0]
    set index_to_file([incr i]) [lindex $func 1]
  }
  _thaw_me
}

# ------------------------------------------------------------------
#  METHOD:  _process_file_selection
#            This fills the func combo, and the more window if it
#            is currently open with the hit in the File combobox.
# ------------------------------------------------------------------
itcl::body BrowserWin::_process_file_selection {y} {

  set curIndex [$itk_component(file_box) nearest $y]
  set curSelection [$itk_component(file_box) curselection]

  # We got a button-release - First make sure the click selected the item...

  if {[lsearch $curIndex $curSelection] >= 0} {
    _fill_source [$itk_component(file_box) get $curIndex] 0
  } else {
    # If the item was deselected, go back to the first one in the list...
    # It would be better to keep a stack of the clicked items, and go to the
    # last one on the stack.  But in extended mode, this is tricky.  FIXME

    if {[llength $curSelection] > 0} {
      _fill_source [$itk_component(file_box) get [lindex $curSelection 0]] 0
    } else {
      _fill_source ""
    }
  }

  search
}

# ------------------------------------------------------------------
#  METHOD:  _process_func_selection
#            This points the  more window to the hit in the Func combobox
#            if it is currently open.
# ------------------------------------------------------------------
itcl::body BrowserWin::_process_func_selection {y} {

  set curIndex [$itk_component(func_box) nearest $y]
  set curSelection [$itk_component(func_box) curselection]

  # We got a button-release - First make sure the click selected the item...

  if {[lsearch $curIndex $curSelection] >= 0} {
    set funcName [$itk_component(func_box) get $curIndex]
    set fileName $index_to_file($curIndex)
    _fill_source $funcName 1 $fileName
  }
}

# ------------------------------------------------------------------
#  METHOD:  do_all_bp
#           Toggle a bp at every selected function in FuncLB
# ------------------------------------------------------------------
itcl::body BrowserWin::do_all_bp {onp} {

  set funcs [$itk_component(func_box) getcurselection]
  _freeze_me

  foreach f $funcs {
    if {[catch {gdb_loc $f} linespec]} {
      dbug W "Could not gdb_loc \"$f\""
      return
    }
    set bpnum [bp_exists $linespec]
    if {$bpnum == -1 && $onp} {

      # FIXME: gdb_set_bp is the preferred method, but it requires
      # a file and line number. This doesn't work very well for
      # templates...
      gdb_cmd "break $f"
    } elseif {!$onp} {
      catch {gdb_cmd "delete $bpnum"}
    }
  }
  _thaw_me
}

# ------------------------------------------------------------------
#  METHOD:  _toggle_bp
#           Toggle bp at function specified by the given Y
#           coordinate in the listbox
# ------------------------------------------------------------------
itcl::body BrowserWin::_toggle_bp {y} {

  set f [$itk_component(func_box) get [$itk_component(func_box) nearest $y]]
  if {$f != ""} {
    if {[catch {gdb_loc $f} linespec]} {
      return
    }
    set bpnum [bp_exists $linespec]
    if {$bpnum == -1} {	
      # FIXME: gdb_set_bp is the preferred method, but it requires
      # a file and line number. This doesn't work very well for
      # templates...
      gdb_cmd "break $f"
    } else {
      catch {gdb_cmd "delete $bpnum"}
    }
  }
}

# ------------------------------------------------------------------  
#  METHOD:  _select
#           Un/Highlight all files in the files list
# ------------------------------------------------------------------  
itcl::body BrowserWin::_select {highlight} {
  if {$highlight} {
    $itk_component(file_box) selection set 0 end
  } else {
    $itk_component(file_box) selection clear 0 end
  }
  search
}

# ------------------------------------------------------------------  
#  METHOD:  _set_filter_mode
#           React to changes in the filter mode
# ------------------------------------------------------------------  
itcl::body BrowserWin::_set_filter_mode {w mode} {
  if {[string compare $mode $cur_filter_mode] != 0} {
    set cur_filter_mode $mode
    pref set gdb/search/filter_mode $mode
    search
  }
}

# ------------------------------------------------------------------
#  METHOD:  _file_hide_h
#           Run when the "Hide .h files" preference is chosen.
# ------------------------------------------------------------------
itcl::body BrowserWin::_file_hide_h {} {
  _fill_file_box
  search
}

# ------------------------------------------------------------------
#  METHOD:  _fill_source
#           Helper function to fill the srctextwin
#           when needed.
# ------------------------------------------------------------------
itcl::body BrowserWin::_fill_source {f {funcp 1} {filename ""}} {
  if {($funcp && [string compare $f $Current(function)]) \
	|| [string compare $f $Current(filename)]} {
    if {!$funcp} {
      if {$filename == ""} {
	set f $f:1
      } else {
	set f $f:$filename
      }
    }

    if {[catch {gdb_loc $f} linespec]} {
      return
    }

    lassign $linespec foo funcname name line addr pc_addr lib
    set file_changed [string compare $Current(filename) $name]

    if {$file_changed} {
      # Set the file name label:
      $itk_component(view_name) configure -text $name:
      _freeze_me
    }

    # fill srctextwin
    $itk_component(view_src) location BROWSE_TAG $name $funcname \
      $line $addr $pc_addr lib

    if {$file_changed} {
      _thaw_me
    }

    set Current(function) $funcname
    # fill func combo
    if {$file_changed} {
      set Current(filename) $name
      _fill_funcs_combo $name
    }
    # Set current function in combo box
    $itk_component(view_func) entryset $f
  }
}

# ------------------------------------------------------------------
#  METHOD:  mode
#           Function called by srctextwin when the display
#           mode changes
# ------------------------------------------------------------------
itcl::body BrowserWin::mode {w {mode ""} {go 1}} {
  if {$mode != ""} {
    $itk_component(view_src) mode_set $mode $go
    $itk_component(view_mode) entryset $mode
  }
}

# ------------------------------------------------------------------
# METHOD:  _goto_func
#          Callback for the function combo box which
#          sets the srctextwin looking at the given function (VAL)
# ------------------------------------------------------------------
itcl::body BrowserWin::_goto_func {w {val ""}} {
  if {$val != ""} {
    set mang 0
    if {[info exists _mangled_func($val)]} {
      set mang $_mangled_func($val)
    }
    if {$mang} {
      set loc $val
    } else {
      set fn [lindex [::file split $Current(filename)] end]
      set loc $fn:$val
    }
    debug "GOTO \"$loc\""
    if {![catch {gdb_loc $loc} result]} {
      lassign $result foo funcname name line addr pc_addr lib
      $itk_component(view_src) location BROWSE_TAG $name $funcname \
	$line $addr $pc_addr lib
    } else {
      dbug W "gdb_loc returned \"$result\""
    }
  }
}

# ------------------------------------------------------------------
#  METHOD:  _fill_file_box
#           This private method fills the file listbox
# ------------------------------------------------------------------
itcl::body BrowserWin::_fill_file_box {} {
  # It would be cool if gdb_listfiles took a regexp to match,
  # but it doesn't...

  $itk_component(file_box) clear
  set allFiles [gdb_listfiles]

  if {[pref get gdb/browser/hide_h]} {
    foreach file $allFiles {
      if {[string compare [file extension $file] ".h"]} {
	$itk_component(file_box) insert end $file
      }
    }
  } else {
    foreach file $allFiles {
      $itk_component(file_box) insert end $file
    } 
  }
  search
}

# ------------------------------------------------------------------
#  METHOD:  _fill_funcs_combo
#           This private method fills the functions combo box
#           with all the functions in NAME.
# ------------------------------------------------------------------
itcl::body BrowserWin::_fill_funcs_combo {name} {

  $itk_component(view_func) list delete 0 end
  if {$name != ""} {
    set maxlen 10
    if {[catch {gdb_listfuncs $name} listfuncs]} {
      tk_messageBox -icon error -default ok \
	-title "GDB" -type ok \
	-message "This file can not be found or does not contain\ndebugging information."
      return
    }
    foreach f [lsort $listfuncs] {
      lassign $f func mang
      if {$func == "global constructors keyed to main"} {continue}
      set _mangled_func($func) $mang
      $itk_component(view_func) list insert end $func
      if {[string length $func] > $maxlen} {
	set maxlen [string length $func]
      }
    }
    # limit size to 40 chars because if we don't set a reasonable limit
    # then the combobox can be wider than the screen
    if {$maxlen > 40} {set maxlen 40}

    $itk_component(view_func) configure -width [expr {$maxlen + 1}]
  }
}

# ------------------------------------------------------------------
#  METHOD:  _build_filter_frame
#	This private method builds the filter frame
# ------------------------------------------------------------------
itcl::body BrowserWin::_build_filter_frame {parent} {
  
  itk_component add filter {
    iwidgets::labeledframe $parent.filter -labeltext "Function Filter" \
      -relief groove -borderwidth 2 -ipadx 6 -ipady 4
  }

  # Set up the contents of the Filter frame
  if {$_layout == 2} {
    itk_component add filt_label {
      label [$itk_component(filter) childsite].lbl -text "Show if function " \
	-font global/fixed
    }
  }

  itk_component add filt_type {
    combobox::combobox [$itk_component(filter) childsite].type -height 4 \
      -width 15 -editable 0 \
      -command [code $this _set_filter_mode] \
      -font global/fixed
  } { 
    rename -background -textbackground textBackground Background
  }

  # Fill the filter mode combo-box
  foreach elem $filter_modes {
    $itk_component(filt_type) list insert end $elem
  }

  set cur_filter_mode [pref get gdb/search/filter_mode]
  if {[lsearch $filter_modes $cur_filter_mode] < 0} {
    set cur_filter_mode [lindex $filter_modes 0]
  }
  $itk_component(filt_type) entryset $cur_filter_mode

  itk_component add filt_entry {
    entry [$itk_component(filter) childsite].ent -font global/fixed \
      -textvariable [pref varname gdb/search/last_symbol] 
  } {}
  bind_plain_key $itk_component(filt_entry) Return [list $this search]

  # Watch keystrokes into the entry box and filter on them...
  trace variable [pref varname gdb/search/last_symbol] w \
    [code $this _filter_trace_proc]

  if {$_layout == 2} {
    pack $itk_component(filt_label) -side left 
  }
  pack $itk_component(filt_type) -side left -padx 4 -fill y -pady 5
  pack $itk_component(filt_entry) -side right -fill both -expand 1 \
    -padx 6 -pady 5

  pack $itk_component(filter) -fill x -anchor n -pady 3
}

# ------------------------------------------------------------------
#  METHOD:  _build_file_frame
#	This private method builds the files frame
# ------------------------------------------------------------------
itcl::body BrowserWin::_build_file_frame {parent} {

  # Labeled Frame
  itk_component add file_frame {
    iwidgets::labeledframe $parent.file -labeltext "Files" \
      -relief groove -borderwidth 2 -ipadx 6 -ipady 4
  }

  # Listbox with files
  itk_component add file_box {
    iwidgets::scrolledlistbox  [$itk_component(file_frame) childsite].listbox \
      -selectmode extended -exportselection false \
      -hscrollmode dynamic -vscrollmode dynamic -foreground $::Colors(textfg) \
      -textbackground $::Colors(textbg)
  } {}

  bind [$itk_component(file_box) component listbox] <ButtonRelease-1> \
    [code $this _process_file_selection %y]

  itk_component add file_sep {
    frame [$itk_component(file_frame) childsite].sep -relief raised -height 2 \
      -borderwidth 1
  }

  itk_component add file_hide {
    checkbutton [$itk_component(file_frame) childsite].hide \
      -text "Hide .h files" \
      -variable [pref varname gdb/browser/hide_h] \
      -command [code $this _file_hide_h]
  }

  itk_component add file_all {
    button [$itk_component(file_frame) childsite].sel \
      -text "Select All" \
      -command [code $this _select 1]
  }

  # pack all the pieces
  grid $itk_component(file_box) -column 0 -row 0 -columnspan 2 \
    -sticky news
  grid $itk_component(file_sep) -column 0 -row 1 -columnspan 2 \
    -sticky ew -pady 8
  grid $itk_component(file_hide) -column 0 -row 2 -padx 5 -sticky w
  grid $itk_component(file_all) -column 1 -row 2 -padx 5 -sticky e

  grid columnconfigure [$itk_component(file_frame) childsite] 0 -weight 1
  grid rowconfigure [$itk_component(file_frame) childsite] 0 -weight 1

  # finally pack the main frame
  pack $itk_component(file_frame) -side left -fill both -expand yes
}

# ------------------------------------------------------------------
#  METHOD:  _build_function_frame
#	This private method builds the functions frame
# ------------------------------------------------------------------
itcl::body BrowserWin::_build_function_frame {parent} {

  # Labeled Frame
  itk_component add func_frame {
    iwidgets::labeledframe $parent.file -labeltext "Function" \
      -relief groove -borderwidth 2 -ipadx 6 -ipady 4
  }

  # Functions Listbox
  itk_component add func_box {
    iwidgets::scrolledlistbox [$itk_component(func_frame) childsite].listbox \
      -selectmode extended -hscrollmode dynamic -vscrollmode dynamic \
      -exportselection false -foreground $::Colors(textfg) \
      -textbackground $::Colors(textbg)
  } {}
	    
  bind [$itk_component(func_box) component listbox] <ButtonRelease-1> \
    [code $this _process_func_selection %y]
  bind $itk_component(func_box) <3> [code $this _toggle_bp %y]

  itk_component add func_sep {
    frame [$itk_component(func_frame) childsite].sep -relief raised \
      -height 2 -borderwidth 1
  }
	
  itk_component add func_add_bp {   
    button [$itk_component(func_frame) childsite].abp -text "Set BP" \
      -command [code $this do_all_bp 1]
  }

  itk_component add func_remove_bp {
    button [$itk_component(func_frame) childsite].rbp -text "Delete BP" \
      -command [code $this do_all_bp 0]
  }

  # pack all the pieces
  grid $itk_component(func_box) -column 0 -row 0 -columnspan 2 -sticky news
  grid $itk_component(func_sep) -row 1 -column 0 -columnspan 2 \
    -sticky ew -pady 8
  grid $itk_component(func_remove_bp) -row 2 -column 0 -padx 5 -sticky w
  grid $itk_component(func_add_bp) -row 2 -column 1  -padx 5 -sticky e

  grid columnconfigure [$itk_component(func_frame) childsite] 0 -weight 1
  grid rowconfigure [$itk_component(func_frame) childsite] 0 -weight 1

  # finally pack the main frame
  pack $itk_component(func_frame) -fill both -expand yes
}

# ------------------------------------------------------------------
#  METHOD:  _build_view_frame
#	This private method builds the view frame
# ------------------------------------------------------------------
itcl::body BrowserWin::_build_view_frame {parent} {
  itk_component add view {
    frame $parent.view
  }

  itk_component add view_src {
    SrcTextWin $itk_component(view).src -Tracing 0 \
      -parent $this -ignore_var_balloons 0
  } {
    rename -background -textbackground textBackground Background
  }

  itk_component add view_bottom {
    frame $itk_component(view).bottom
  }

  itk_component add view_name {
    label $itk_component(view).name -font global/fixed
  }

  itk_component add view_func {
    combobox::combobox $itk_component(view_bottom).combo -maxheight 15\
      -font global/fixed -command [code $this _goto_func]
  } {
    rename -background -textbackground textBackground Background
  }
  
  itk_component add view_mode {
    combobox::combobox $itk_component(view_bottom).mode -width 9 \
      -font global/fixed -command [code $this mode]
  } {
    rename -background -textbackground textBackground Background
  }

  itk_component add view_search {
    entry $itk_component(view_bottom).search -borderwidth 2 \
      -font global/fixed -width 10 -background $::Colors(textbg)
  } {}

  # Pack all the components of view into the frame:
  pack $itk_component(view_func) -side left -anchor w
  pack $itk_component(view_mode) -side left -padx 5
  pack $itk_component(view_search) -side right -padx 5 -expand 1 -anchor e
  pack $itk_component(view_name) -side top -fill x -padx 5 -pady 3
  pack $itk_component(view_bottom) -side bottom -fill x -pady 3 -padx 5
  pack $itk_component(view_src) -fill both -expand 1 -padx 5 -pady 3
  
  # Fill combo boxes
  $itk_component(view_mode) list insert end SOURCE
  $itk_component(view_mode) list insert end ASSEMBLY
  $itk_component(view_mode) list insert end MIXED
  # don't allow SRC+ASM mode... $itk_component(view_mode) insert end SRC+ASM
  $itk_component(view_mode) entryset [$itk_component(view_src) mode_get]

  # Key bindings
  bind_plain_key $itk_component(view_search) Return \
    [code $this _search_src forwards]
  bind_plain_key $itk_component(view_search) Shift-Return \
    [code $this _search_src backwards]

  pack  $itk_component(view) -fill both -expand yes
}

# ------------------------------------------------------------------
#  METHOD:  _switch_layout
#           Switch between different layouts
#
# ------------------------------------------------------------------
itcl::body BrowserWin::_switch_layout {} {
  # only 2 right now, so toggle
  if {$_layout == 1} {
    set _layout 2
  } else {
    set _layout 1
  }
  pref set gdb/browser/layout $_layout
  destroy $itk_interior.p
  destroy $itk_component(popup)
  set Current(filename) {}
  set Current(function) {}
  if {$filter_trace_after != ""} {
    after cancel $filter_trace_after
  }
  trace vdelete [pref varname gdb/search/last_symbol] \
    w [code $this _filter_trace_proc]
  _build_win
}
@


1.9
log
@2003-02-10  Martin M. Hunt  <hunt@@redhat.com>
	* library/browserwin.itb: Set textbackground option to
	$::Colors(textbg) instead of "white".
@
text
@d2 1
a2 1
# Copyright 1998, 1999, 2001, 2002, 2003 Red Hat, Inc.
@


1.8
log
@2003-02-10  Martin M. Hunt  <hunt@@redhat.com>

	* library/prefs.tcl (pref_set_defaults): Remove prefs
	gdb/browser/width, gdb/browser/top_height, gdb/browser/view_height,
	gdb/browser/view_is_open. Add gdb/browser/layout.

	* library/browserwin.ith: Update declarations to match
	changes in browserwin.itb.

	* library/browserwin.itb (constructor): Don't set toplevel
	bindings. Set _layout from prefs.
	(destructor): Don't check $resize_after. Don't save view_is_open.
	(_build_win): Create a popup menu and bind to button 3.
	Split the rest into 4 functions; _build_file_frame,
	_build_filter_frame, _build_function_frame, and _build_view_frame.
	Pack these 4 frames according to $_layout.
	(_toggle_more): Deleted.
	(_bind_toplevel): Deleted.
	(_do_resize): Deleted.
	(_resize): Deleted.
	(_fill_source): Always fill because source is always visible.
	(_fill_funcs_combo): Limit width of combo to 40 chars.
	(_build_filter_frame): New function.
	(_build_file_frame): New function.
	(_build_function_frame): New function.
	(_build_view_frame): New function.
	(_switch_layout): New function. Toggle between layouts.

	* library/tclIndex: Rebuilt.

	* library/help/browser.html: Rewrite.
@
text
@d20 1
a20 1
option add *BrowserWin.textBackground  white
@


1.7
log
@2002-10-15  Martin M. Hunt  <hunt@@redhat.com>

	* library/* : auto_mkindex cannot rebuild
	tclIndex because it does not recognize the namespace
	import in main.tcl.  To get it to work again, rename the
	following:
		body -> itcl::body
		configbody -> itcl::configbody
		class -> itcl::class
@
text
@d2 1
a2 1
# Copyright 1998, 1999, 2001, 2002 Red Hat
d16 1
a16 1
# Implements Browser window for gdb
d20 2
a24 3

option add *BrowserWin.textBackground  white

d26 1
d30 1
a35 4

  # Create the toplevel binding for this class
  bind Configure_Browser_$this <Configure> [code $this _resize]

d43 1
a43 4

  if {$resize_after != ""} {
    after cancel $resize_after
  }
a47 6
  if {$MoreVisible} {
    pref set gdb/browser/view_is_open 1
  } else {
    pref set gdb/browser/view_is_open 0
  }

d57 1
a57 25
  global PREFS_state gdb_ImageDir

  # Three frames: regexp, listboxes, and drop-down pane

  itk_component add filter {
    iwidgets::labeledframe $itk_interior.filter -labeltext "Filter" \
      -labelrelief groove -labelborderwidth 2 -ipadx 6 -ipady 4
  }

  append labelUpdateCode [$itk_component(filter) clientHandlesConfigure 1] "\n"

  itk_component add browser {
    frame $itk_interior.browser
  }

  itk_component add view {
    frame $itk_interior.view
  }

  # Set up the contents of the Filter frame

  itk_component add filt_label {
    label [$itk_component(filter) childsite].lbl -text {Show if function } \
      -font global/fixed
  }
d59 3
a61 22
  itk_component add filt_type {
    combobox::combobox [$itk_component(filter) childsite].type -height 4 \
      -width 15 -editable 0 \
      -command [code $this _set_filter_mode] \
      -font global/fixed
  } { }

  # Fill the filter mode combo-box

  foreach elem $filter_modes {
    $itk_component(filt_type) list insert end $elem
  }

  set cur_filter_mode [pref get gdb/search/filter_mode]
  if {[lsearch $filter_modes $cur_filter_mode] < 0} {
    set cur_filter_mode [lindex $filter_modes 0]
  }
  $itk_component(filt_type) entryset $cur_filter_mode

  itk_component add filt_entry {
    entry [$itk_component(filter) childsite].ent -font global/fixed \
      -textvariable [pref varname gdb/search/last_symbol] 
d63 25
d89 2
d92 11
a102 201
  # Watch keystrokes into the entry box and filter on them...

  trace variable [pref varname gdb/search/last_symbol] w \
    [code $this _filter_trace_proc]

  pack $itk_component(filt_label) -side left 
  pack $itk_component(filt_type) -side left -padx 4 -fill y -pady 5
  pack $itk_component(filt_entry) -side right -fill both -expand 1 \
    -padx 6 -pady 5

  # Files Listbox for the Browser frame
  itk_component add file_box {
    iwidgets::scrolledlistbox $itk_component(browser).files \
      -selectmode extended -exportselection false \
      -labeltext "Files" -labelpos nw -labelrelief groove \
      -labelborderwidth 2 -ipadx 8 -ipady 6 -foreground $::Colors(textfg) \
      -childsitepos s -hscrollmode none -textbackground $::Colors(textbg)
  } {}

  append labelUpdateCode [$itk_component(file_box) clientHandlesConfigure 1] \
    "\n"

  bind [$itk_component(file_box) component listbox] <ButtonRelease-1> \
    [code $this _process_file_selection %y]

  itk_component add file_sep {
    frame [$itk_component(file_box) childsite].sep -relief raised -height 2 \
      -borderwidth 1
  }
	
  itk_component add file_hide {
    checkbutton [$itk_component(file_box) childsite].hide \
      -text {Hide .h files} \
      -variable [pref varname gdb/browser/hide_h] \
      -command [code $this _file_hide_h]
  }

  itk_component add file_all {
    button [$itk_component(file_box) childsite].sel \
      -text {Select All} -width 12 \
      -command [code $this _select 1]
  }

  # Pack the file box in, and grid in the separate bits of the child-site.

  pack $itk_component(file_box) -side left -fill both -expand yes \
    -padx 5 -pady 5

  grid $itk_component(file_sep) -column 0 -row 0 -columnspan 2 \
    -sticky ew -pady 8
  grid $itk_component(file_hide) -column 0 -row 1 -padx 5 -sticky w
  grid $itk_component(file_all) -column 1 -row 1 -padx 5 -sticky e

  grid columnconfigure [$itk_component(file_box) childsite] 0 -weight 1

  # Functions Listbox for the Browser frame

  itk_component add func_box {
    iwidgets::scrolledlistbox $itk_component(browser).funcs \
      -selectmode extended \
      -exportselection false \
      -labeltext "Functions" -labelpos nw -labelrelief groove \
      -labelborderwidth 2 -ipadx 8 -ipady 6 -foreground $::Colors(textfg) \
      -childsitepos s -hscrollmode none -textbackground $::Colors(textbg)
  } {}
	    
  append labelUpdateCode [$itk_component(func_box) clientHandlesConfigure 1] \
    "\n"

  bind [$itk_component(func_box) component listbox] <ButtonRelease-1> \
    [code $this _process_func_selection %y]

  itk_component add func_sep {
    frame [$itk_component(func_box) childsite].sep -relief raised \
      -height 2 -borderwidth 1
  }
	
  itk_component add func_bp_label {   
    label [$itk_component(func_box) childsite].bpl -text {Breakpoints:}
  }

  itk_component add func_add_bp {   
    button [$itk_component(func_box) childsite].abp -text {Set} \
      -command [code $this do_all_bp 1]
  }

  itk_component add func_remove_bp {
    button [$itk_component(func_box) childsite].rbp -text {Delete} \
      -command [code $this do_all_bp 0]
  }

  # Pack in the Function box, and grid in the bits of the child-site

  pack $itk_component(func_box) -side right -fill both -expand yes \
    -padx 5 -pady 5

  grid $itk_component(func_sep) -row 0 -column 0 -columnspan 3 \
    -sticky ew -pady 8
  grid $itk_component(func_bp_label) -row 1 -column 0 -padx 5
  grid $itk_component(func_remove_bp) -row 1 -column 1  -padx 5
  grid $itk_component(func_add_bp) -row 1 -column 2  -padx 5

  grid columnconfigure [$itk_component(func_box) childsite] 1 -weight 1
  grid columnconfigure [$itk_component(func_box) childsite] 2 -weight 1

  # "More" frame for viewing source

  if {[lsearch [image names] _MORE_] == -1} {
    image create photo _MORE_ -file [file join $gdb_ImageDir more.gif]
    image create photo _LESS_ -file [file join $gdb_ImageDir less.gif]
  }

  itk_component add view_vis {
    frame $itk_interior.view.visible
  }

  itk_component add view_more {
    button $itk_component(view_vis).btn -image _MORE_ -relief flat \
		    -command [code $this _toggle_more]
  }

  itk_component add view_label {
    label $itk_component(view_vis).lbl -text {View Source}
  }

  itk_component add view_sep {
    frame $itk_component(view_vis).sep -relief raised -borderwidth 1 -height 2
  }

  pack $itk_component(view_more) -side left -padx 10 -pady 10
  pack $itk_component(view_label) -side left -padx 10 -pady 10
  pack $itk_component(view_sep) -padx 4 -pady 10 -fill x -expand 1

  grid columnconfigure $itk_component(view_vis) 2 -weight 1

  pack $itk_component(view_vis) -side top -fill x -expand yes

  # Key bindings for "visible" frames
  bind_plain_key $itk_component(filt_entry) Return [list $this search]
  bind $itk_component(func_box) <3> [code $this _toggle_bp %y]

  # Construct hidden frame

  itk_component add view_hidden {
    frame $itk_interior.hidden
  }

  itk_component add view_src {
    SrcTextWin $itk_component(view_hidden).src -Tracing 0 \
      -parent $this -ignore_var_balloons 1 
  } {
    rename -background -textbackground textBackground Background
  }    

  $itk_component(view_src) configure -textheight 2i

  itk_component add view_bottom {
    frame $itk_component(view_hidden).bottom
  }

  itk_component add view_name {
    label $itk_component(view_hidden).name -font global/fixed
  }

  itk_component add view_func {
    combobox::combobox $itk_component(view_bottom).combo -maxheight 15 \
      -font global/fixed -command [code $this _goto_func]
  } {
    # Should be able to do this, but can't cause the combobox doesn't
    # fake up a MegaWidget well enough
    #rename -background -textbackground textBackground Background
  }
  
  itk_component add view_mode {
    combobox::combobox $itk_component(view_bottom).mode -width 9 \
      -font global/fixed -command [code $this mode]
  } {
    #rename -background -textbackground textBackground Background
  }

  itk_component add view_search {
    entry $itk_component(view_bottom).search -borderwidth 2 \
      -font global/fixed -width 10 -background $::Colors(textbg)
  } {}

  # Pack all the components of view_hidden into the frame:

  pack $itk_component(view_search) -side right -padx 5 -fill none \
    -expand 1 -anchor e
  pack $itk_component(view_mode) -side right -padx 5
  pack $itk_component(view_func) -side left

  pack $itk_component(view_name) -side top -fill x -padx 5 -pady 3
  pack $itk_component(view_bottom) -side bottom -fill x -pady 3 -padx 5
  pack $itk_component(view_src) -fill both -expand 1 -padx 5 -pady 3

  
  # Fill combo boxes
  $itk_component(view_mode) list insert end SOURCE
  $itk_component(view_mode) list insert end ASSEMBLY
  $itk_component(view_mode) list insert end MIXED
d104 2
a105 8
  # don't allow SRC+ASM mode... $itk_component(view_mode) insert end SRC+ASM
  $itk_component(view_mode) entryset [$itk_component(view_src) mode_get]

  # Key bindings for hidden frame
  bind_plain_key $itk_component(view_search) Return \
    [code $this _search_src forwards]
  bind_plain_key $itk_component(view_search) Shift-Return \
    [code $this _search_src backwards]
d107 2
a108 14
  # Now map everything onto the screen
  grid $itk_component(filter) -column 0 -row 0 -padx 6 -pady 4 -sticky ew
  grid $itk_component(browser) -column 0 -row 1 -sticky nsew
  grid $itk_component(view)  -column 0 -row 2 -pady 4 -padx 6 -sticky ew

  # Now set up any initial values:

  set MoreVisible [pref get gdb/browser/view_is_open]
  set BrowserHeight [pref get gdb/browser/top_height]
  set Width [pref get gdb/browser/width]

  if {$BrowserHeight > 0} {
    grid rowconfigure $itk_component(hull) $componentToRow(browser) \
      -minsize $BrowserHeight
a110 16
  if {$Width > 0} {
    grid columnconfigure $itk_component(hull) 0 -minsize $Width
  }

  grid rowconfigure $itk_component(hull) 1 -weight 1 
  grid columnconfigure $itk_component(hull) 0 -weight 1

  update idletasks
  eval $labelUpdateCode

  if {$MoreVisible} {
    debug "Got moreVisible at 1"
    set MoreVisible 0
    _toggle_more 1
  }

d114 1
a114 9
  after idle "
    update idletasks
    grid rowconfigure $itk_component(hull) 2 \
        -minsize \[winfo height $itk_component(view)\]
  "

  # Finally set up the top level bindings:
  _bind_toplevel 1

a193 183
#  METHOD:  _toggle_more
#           Toggle display of source listing
# ------------------------------------------------------------------   
itcl::body BrowserWin::_toggle_more {{in_constructor 0}} {

  debug "Running toggle_more with MoreVisible: $MoreVisible"
  # Temporarily disable the resize bindings before opening the window.
  _bind_toplevel 0

  set topHeight [winfo height $_top]
  set topWidth  [winfo width $_top]

  if {!$MoreVisible} {

    $itk_component(view_label) configure -text {Hide Source}
    $itk_component(view_more) configure -image _LESS_
    grid $itk_component(view_hidden) -row 3 -column 0 -sticky nsew \
      -padx 6 -pady 4
    
    # Check the stored height.  Restore the view to this if it will fit on the
    # screen.  Otherwise, figure out how big to make it...

    set height [pref get gdb/browser/view_height]
    set bottom [expr {[winfo y $_top] + $topHeight}]

    set extra [expr {[winfo screenheight $_top] - $bottom - 20}]
    
    if {$height < 0} {
      set default [winfo pixels $_top 3i]
      set height [expr {$extra > $default ? $default : $extra}]
    } else {
      set height [expr {$extra > $height ? $height : $extra}]
    }

    wm geometry $_top ${topWidth}x[expr {$topHeight + $height}]
    grid rowconfigure $itk_component(hull) $componentToRow(view_hidden) \
      -weight 1
    grid rowconfigure $itk_component(hull) $componentToRow(browser) -weight 0

    pref set gdb/browser/view_height $height

    set MoreVisible 1
    update idletasks

    # If we have a selected function, display it in the window

    set f [$itk_component(func_box) getcurselection]

    if {$f != ""} {
      # FIXME - If there is more than 1 function selected, I just load the
      # first.  It would probably be better to load the one nearest to the
      # middle of the current window on the listbox.  But I am running out
      # of time for this round...

      if {[llength $f] > 1} {
	set f [lindex $f 0]
      }
      
      _fill_source $f
    } else {
      # If no function was chosen, try the file box...

      set f [$itk_component(file_box) getcurselection]
      if { $f != "" } {
	if {[llength $f] > 1} {
	  set f [lindex $f 0]
	}
	_fill_source $f 0
      }
    }
  } else {
    if {!$in_constructor} {
      pref set gdb/browser/view_height \
	[winfo height $itk_component(view_hidden)]
    }

    $itk_component(view_label) configure -text {View Source}
    $itk_component(view_more) configure -image _MORE_

    grid propagate $itk_component(func_box) 0
    grid propagate $itk_component(file_box) 0

    set newTopHeight [expr {$topHeight - \
			      [winfo height $itk_component(view_hidden)]}]
    wm geometry $_top ${topWidth}x$newTopHeight

    if {!$in_constructor} {
      grid rowconfigure $itk_component(hull) $componentToRow(browser) -weight 1
      grid forget $itk_component(view_hidden)
      grid rowconfigure $itk_component(hull) $componentToRow(view_hidden) \
	-minsize 0 -weight 0
    }

    set MoreVisible 0

    # Flush the changes

    update idletasks

    grid propagate $itk_component(func_box) 1
    grid propagate $itk_component(file_box) 1

  }

  # restore the bindings

  _bind_toplevel 1

}

# ------------------------------------------------------------------
#  METHOD:  _bind_toplevel
#            Setup the bindings for the toplevel.
# ------------------------------------------------------------------
itcl::body BrowserWin::_bind_toplevel {install} {

  set bindings [bindtags $_top]
  if {$install} {
    bindtags $_top [linsert $bindings 0 Configure_Browser_$this]
  } else {
    set bindLoc [lsearch $bindings Configure_Browser_$this]
    bindtags $_top [lreplace $bindings $bindLoc $bindLoc]
  }
}

# ------------------------------------------------------------------
#  METHOD:  _do_resize
#            Does the actual work of the resize.
# ------------------------------------------------------------------
itcl::body BrowserWin::_do_resize {} {

  update idletasks
  debug "Running _do_resize"

  set width [winfo width $itk_component(hull)]
  pref set gdb/browser/width      $width
  grid columnconfigure $itk_component(hull) 0 -minsize $width

  if {$MoreVisible} {
    set v_height [winfo height $itk_component(view_hidden)]
    pref set gdb/browser/view_height $v_height
    grid rowconfigure $itk_component(hull) $componentToRow(view_hidden) \
      -minsize $v_height
    grid rowconfigure $itk_component(hull) $componentToRow(browser)
  } else {    
    set b_height [winfo height $itk_component(browser)]
    pref set gdb/browser/top_height $b_height
    grid rowconfigure $itk_component(hull) $componentToRow(browser) \
      -minsize $b_height
  }

  eval $labelUpdateCode
  pack propagate $_top 1

  set resize_after ""

}

# ------------------------------------------------------------------
#  METHOD:  _resize
#            Resize "itk_component(view_hidden)" after all configure events
# ------------------------------------------------------------------
itcl::body BrowserWin::_resize {} {

  pack propagate $_top 0

  if {$MoreVisible} {
    grid rowconfigure $itk_component(hull) $componentToRow(view_hidden) \
      -minsize 0
  } else {
    grid rowconfigure $itk_component(hull) 1 -minsize 0
  }

  grid columnconfigure $itk_component(hull) 0 -minsize 0

  if {$resize_after != ""} {
    after cancel $resize_after
  }
  set resize_after [after 100 "[code $this _do_resize]"]

}

# ------------------------------------------------------------------
a219 1

a238 1

d295 1
a295 1
#           (Un/Highlight all files in the files list
a322 1

a324 1

a332 5

  if {!$MoreVisible } {
    return
  }

a348 1
    # fill srctextwin
d356 1
a371 1
    
d414 1
d439 1
d456 1
a456 1
    foreach f [lsort -increasing $listfuncs] {
d465 4
d471 260
@


1.6
log
@        * library/browserwin.itb (_full_funcs_combo): Remove "-modal"
        option from tk_messageBox call. It was redhat-local in tk8.0,
        but is no longer in tk8.3.
        * library/download.itb (download_it): Likewise.
        * library/interface.tcl (gdbtk_tcl_query): Likewise.
        (show_warning): Likewise.
        (set_exe): Likewise.
        (set_target): Likewise.
        * library/memwin.itb (error_dialog): Likewise.
        * library/srcwin.itb (fillFuncCB): Likewise.
        * library/util.tcl (tfind_cmd): Likewise.
@
text
@d26 1
a26 1
body BrowserWin::constructor {args} {
d45 1
a45 1
body BrowserWin::destructor {} {
d68 1
a68 1
body BrowserWin::_build_win {} {
d383 1
a383 1
body BrowserWin::_filter_trace_proc {v1 v2 mode} {
d394 1
a394 1
body BrowserWin::_filter_trace_after {} {
d404 1
a404 1
body BrowserWin::_search_src {direction} {
d414 1
a414 1
body BrowserWin::search {} {
d457 1
a457 1
body BrowserWin::_toggle_more {{in_constructor 0}} {
d568 1
a568 1
body BrowserWin::_bind_toplevel {install} {
d583 1
a583 1
body BrowserWin::_do_resize {} {
d616 1
a616 1
body BrowserWin::_resize {} {
d641 1
a641 1
body BrowserWin::_process_file_selection {y} {
d671 1
a671 1
body BrowserWin::_process_func_selection {y} {
d690 1
a690 1
body BrowserWin::do_all_bp {onp} {
d719 1
a719 1
body BrowserWin::_toggle_bp {y} {
d742 1
a742 1
body BrowserWin::_select {highlight} {
d755 1
a755 1
body BrowserWin::_set_filter_mode {w mode} {
d767 1
a767 1
body BrowserWin::_file_hide_h {} {
d779 1
a779 1
body BrowserWin::_fill_source {f {funcp 1} {filename ""}} {
d833 1
a833 1
body BrowserWin::mode {w {mode ""} {go 1}} {
d845 1
a845 1
body BrowserWin::_goto_func {w {val ""}} {
d871 1
a871 1
body BrowserWin::_fill_file_box {} {
d896 1
a896 1
body BrowserWin::_fill_funcs_combo {name} {
@


1.5
log
@2002-06-07  Martin M. Hunt  <hunt@@redhat.com>

	* library/prefs.tcl (pref_set_colors): New function.  Set up colors
	from Windows system colors or X resource database. Save in array.
	(pref_set_defaults): Remove gdb/font/normal_fg, etc.
	(pref_read): Call pref_set_colors.

	* library/main.tcl: Remove call to "tix resetoptions TixGray".

	* library/bpwin.itb, library/browserwin.itb, library/console.itb,
	library/globalpref.itb, library/memwin.itb, library/process.itb,
	library/regwin.itb, library/srcpref.itb, library/srctextwin.itb,
	library/stackwin.itb, library/tdump.tcl, library/tracedlg.tcl,
	library/variables.tcl: Replace calls to [pref get gdb/fonts/*]
	for colors with references to Color array. Remove all tixOptions calls.
	Fix up colors as necessary.
@
text
@d903 1
a903 1
	-title "GDB" -type ok -modal system \
@


1.4
log
@2002-03-05  Martin M. Hunt  <hunt@@redhat.com>

	* library/prefs.tcl (pref_read): If a preference specifies
	"src-font", substitute "global/fixed".
	(pref_set_defaults): Change defaults from "src-font" to
	"global/fixed". Do not create font object "src-font". Do
	not add hook to trace its changes.
	(pref_src-font_trace): Remove.

	* library/console.itb (Console::_update_option): Remove
	font update because this happens automatically.

	* library/globalpref.itb: No need to set
	changed flag for fonts; updates happen automatically
	when prefs are updated.

	* library/bpwin.itb: Replaced src-font with global/fixed.
	* library/browserwin.itb: Ditto.
	* library/mempref.itb: Ditto.
	* library/memwin.itb: Ditto.
	* library/process.itb: Ditto.
	* library/regwin.itb: Ditto.
	* library/srcbar.itcl: Ditto.
	* library/srcpref.itb: Ditto.
	* library/srctextwin.itb: Ditto.
	* library/srcwin.itb: Ditto.
	* library/stackwin.itb: Ditto.
	* library/tdump.tcl: Ditto.
	* library/tracedlg.tcl: Ditto.
	* library/variables.tcl: Ditto.
	* library/watch.tcl: Ditto.
@
text
@d116 3
a118 5
      -textvariable [pref varname gdb/search/last_symbol] -background white
  } {
    usual Entry
    rename -background -textbackground textBackground Background
  }
d135 3
a137 3
      -labelborderwidth 2 -ipadx 8 -ipady 6 \
      -childsitepos s -hscrollmode none -textbackground white
  }
d182 3
a184 3
      -labelborderwidth 2 -ipadx 8 -ipady 6 \
      -childsitepos s -hscrollmode none -textbackground white
  }
d302 2
a303 4
      -font global/fixed -width 10 -background white
  } {
    rename -background -textbackground textBackground Background
  }
@


1.3
log
@2002-02-10  Daniel Jacobowitz  <drow@@mvista.com>

        * symtab.c (compare_search_syms): New function.
        (sort_search_symbols): New function.
        (search_symbols): Sort symbols after searching rather than
        before.

2002-02-10  Daniel Jacobowitz  <drow@@mvista.com>

        * generic/gdbtk-cmds.c (gdb_listfuncs): Don't call
        BLOCK_SHOULD_SORT.
        * library/browserwin.itb (BrowserWin::_fill_funcs_combo): Sort
        the output of gdb_listfuncs.
@
text
@d2 1
a2 1
# Copyright 1998, 1999, 2001 Red Hat
d92 1
a92 1
      -font src-font
d99 1
a99 1
      -font src-font
d115 1
a115 1
    entry [$itk_component(filter) childsite].ent -font src-font \
d283 1
a283 1
    label $itk_component(view_hidden).name -font src-font
d288 1
a288 2
      -font src-font \
      -command [code $this _goto_func]
d297 1
a297 2
      -font src-font \
      -command [code $this mode]
d304 1
a304 2
      -font src-font -width 10 \
      -background white
@


1.2
log
@2001-03-15  Martin Hunt  <hunt@@redhat.com>
	* library/browserwin.itb: Change all references to freeze_me,
	thaw_me and Top to _freeze_me, _thaw_me, and _top to match
	changes to managedwin.

	* library/kod.itb: Ditto.
@
text
@d914 1
a914 1
    foreach f $listfuncs {
@


1.1
log
@Initial revision
@
text
@d1 2
a2 2
# Browswer window for GDBtk.
# Copyright 1998, 1999 Cygnus Solutions
d429 1
a429 1
  freeze_me
d444 1
a444 1
    thaw_me
d457 1
a457 1
  thaw_me
d470 2
a471 2
  set topHeight [winfo height $Top]
  set topWidth  [winfo width $Top]
d484 1
a484 1
    set bottom [expr {[winfo y $Top] + $topHeight}]
d486 1
a486 1
    set extra [expr {[winfo screenheight $Top] - $bottom - 20}]
d489 1
a489 1
      set default [winfo pixels $Top 3i]
d495 1
a495 1
    wm geometry $Top ${topWidth}x[expr {$topHeight + $height}]
d545 1
a545 1
    wm geometry $Top ${topWidth}x$newTopHeight
d577 1
a577 1
  set bindings [bindtags $Top]
d579 1
a579 1
    bindtags $Top [linsert $bindings 0 Configure_Browser_$this]    
d582 1
a582 1
    bindtags $Top [lreplace $bindings $bindLoc $bindLoc]
d613 1
a613 1
  pack propagate $Top 1
d625 1
a625 1
  pack propagate $Top 0
d700 1
a700 1
  freeze_me
d718 1
a718 1
  thaw_me
d813 1
a813 1
      freeze_me
d820 1
a820 1
      thaw_me
@


1.1.1.1
log
@import insight-2000-02-04 snapshot (2nd try)
@
text
@@
