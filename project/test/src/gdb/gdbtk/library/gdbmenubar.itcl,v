head	1.13;
access;
symbols
	insight_7_6-2013-04-10-branchpoint:1.13
	gdb_7_6-branch:1.13.0.22
	gdb_7_5-branch:1.13.0.20
	gdb_7_4-branch:1.13.0.18
	gdb_7_3-branch:1.13.0.16
	gdb_7_1-branch:1.13.0.14
	gdb_7_0-branch:1.13.0.12
	arc-sim-20090309:1.13
	arc-insight_6_8-branch:1.13.0.10
	arc-insight_6_8-branchpoint:1.13
	insight_6_8-branch:1.13.0.8
	insight_6_8-branchpoint:1.13
	gdb_6_8-branch:1.13.0.6
	insight_6_6-20070208-release:1.13
	gdb_6_6-branch:1.13.0.4
	gdb_6_6-2006-11-15-branchpoint:1.13
	insight_6_5-20061003-release:1.13
	gdb_6_5-branch:1.13.0.2
	gdb_6_5-2006-05-14-branchpoint:1.13
	gdb-csl-gxxpro-6_3-branch:1.12.0.4
	gdb-csl-gxxpro-6_3-branchpoint:1.12
	gdb_6_4-branch:1.12.0.2
	gdb_6_4-2005-11-01-branchpoint:1.12
	gdb_6_1-2004-04-05-release:1.10
	gdb_6_1-branch:1.10.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.10
	gdb_6_0-2003-10-04-release:1.10
	gdb_6_0-branch:1.10.0.2
	gdb_6_0-2003-06-23-branchpoint:1.10
	gdb_5_3-2002-12-12-release:1.9
	gdb_5_3-branch:1.9.0.2
	gdb_5_3-2002-09-04-branchpoint:1.9
	gdb_5_2_1-2002-07-23-release:1.8
	gdb_5_2-2002-04-29-release:1.8
	gdb_5_2-branch:1.8.0.2
	gdb_5_2-2002-03-03-branchpoint:1.8
	gdb_5_1_1-2002-01-24-release:1.7
	cygnus_cvs_20020108_pre:1.8
	gdb_5_1_0_1-2002-01-03-branch:1.7.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.7
	gdb_5_1-2001-11-21-release:1.7
	gdb_s390-2001-09-26-branch:1.7.0.6
	gdb_s390-2001-09-26-branchpoint:1.7
	gdb_5_1-2001-07-29-branch:1.7.0.4
	gdb_5_1-2001-07-29-branchpoint:1.7
	dberlin-typesystem-branch:1.7.0.2
	dberlin-typesystem-branchpoint:1.7;
locks; strict;
comment	@# @;


1.13
date	2005.12.23.18.26.50;	author eliz;	state Exp;
branches;
next	1.12;

1.12
date	2004.08.27.23.13.14;	author hunt;	state Exp;
branches;
next	1.11;

1.11
date	2004.04.05.20.36.41;	author hunt;	state Exp;
branches;
next	1.10;

1.10
date	2002.10.15.21.19.51;	author hunt;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.13.00.06.44;	author kseitz;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.03.18.46.41;	author kseitz;	state Exp;
branches;
next	1.7;

1.7
date	2001.02.01.21.03.43;	author fnasser;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.28.18.39.00;	author fnasser;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.28.18.08.58;	author fnasser;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.28.18.06.29;	author fnasser;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.25.18.29.09;	author fnasser;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.04.17.27.02;	author fnasser;	state Exp;
branches;
next	1.1;

1.1
date	2001.01.03.05.34.04;	author fnasser;	state Exp;
branches;
next	;


desc
@@


1.13
log
@	* library/attachdlg.itb:
	* library/actiondlg.tcl:
	* library/about.tcl:
	* library/ehandler.itb:
	* library/editor.tcl:
	* library/download.ith:
	* library/download.itb:
	* library/debugwin.ith:
	* library/debugwin.itb:
	* library/cspref.ith:
	* library/cspref.itb:
	* library/console.ith:
	* library/console.itb:
	* library/browserwin.ith:
	* library/browserwin.itb:
	* library/bpwin.ith:
	* library/bpwin.itb:
	* library/blockframe.ith:
	* library/managedwin.ith:
	* library/managedwin.itb:
	* library/main.tcl:
	* library/locals.tcl:
	* library/ipcpref.ith:
	* library/ipcpref.itb:
	* library/ipc.tcl:
	* library/interface.tcl:
	* library/helpviewer.tcl:
	* library/globalpref.ith:
	* library/globalpref.itb:
	* library/gdbwin.ith:
	* library/gdbtoolbar.itcl:
	* library/gdbmenubar.itcl:
	* library/gdbevent.ith:
	* library/gdbevent.itb:
	* library/embeddedwin.ith:
	* library/ehandler.ith:
	* library/srcwin.itb:
	* library/srctextwin.ith:
	* library/srctextwin.itb:
	* library/srcpref.ith:
	* library/srcpref.itb:
	* library/srcbar.itcl:
	* library/session.tcl:
	* library/regwin.ith:
	* library/regwin.itb:
	* library/process.ith:
	* library/process.itb:
	* library/prefs.tcl:
	* library/pluginwin.itcl:
	* library/modal.tcl:
	* library/memwin.ith:
	* library/memwin.itb:
	* library/mempref.ith:
	* library/mempref.itb:
	* library/watch.tcl:
	* library/watch.tcl:
	* library/warning.tcl:
	* library/vartree.ith:
	* library/vartree.itb:
	* library/util.tcl:
	* library/tracedlg.tcl:
	* library/toplevelwin.ith:
	* library/tfind_args.tcl:
	* library/tdump.tcl:
	* library/targetselection.ith:
	* library/targetselection.itb:
	* library/stackwin.ith:
	* library/stackwin.itb:
	* library/srcwin.ith:
@
text
@# GDBMenuBar
# Copyright (C) 2000, 2004 Red Hat, Inc.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License (GPL) as published by
# the Free Software Foundation; either version 2 of the License, or (at
# your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# ----------------------------------------------------------------------
# Implements a GDB menubar.
#
#   PUBLIC ATTRIBUTES:
#
#
#   METHODS:
#
#     configure ....... used to change public attributes
#
#   PRIVATE METHODS
#
#   X11 OPTION DATABASE ATTRIBUTES
#
#
# ----------------------------------------------------------------------

itcl::class GDBMenuBar {
  inherit itk::Widget

  # ------------------------------------------------------------------
  #  CONSTRUCTOR - create widget
  # ------------------------------------------------------------------
  constructor {args} {

    set Menu [menu $itk_interior.m -tearoff 0]

    eval itk_initialize $args
  }

  # ------------------------------------------------------------------
  #  DESTRUCTOR - destroy window containing widget
  # ------------------------------------------------------------------
  destructor {

    #destroy $this
  }

  # ------------------------------------------------------------------
  #  METHOD:  show - attach menu to the toplevel window
  # ------------------------------------------------------------------
  public method show {} {
      [winfo toplevel $itk_interior] configure -menu $Menu
  }

  # ------------------------------------------------------------------
  #  METHOD:  set_class_state - standard method to control state by class
  # ------------------------------------------------------------------
  public method set_class_state {enable_list} {
    debug "Enable list is: $enable_list"

    foreach {type state} $enable_list {
      # debug $type
      if {[info exists menu_classes($type)]} {
        set class_list $menu_classes($type)
        if {[llength $class_list]} {
          # debug "$type $state \{$class_list\}"
          foreach menu $class_list {
            # debug "$type $menu $state"
            menubar_change_menu_state $menu $state
          }
        }
      }
    }
  }

  ####################################################################
  # Methods that deal with menus.
  #
  # The next set of methods control the menubar associated with the
  # toolbar.  Currently, only sequential addition of submenu's and menu
  # entries is allowed.  Here's what you do.  First, create a submenu
  # with the "new_menu" command.  This submenu is the targeted menu. 
  # Subsequent calls to add_menu_separator, and add_menu_command add
  # separators and commands to the end of this submenu.
  # If you need to edit a submenu, call clear_menu and then add all the
  # items again.
  #
  # Each menu command also has a class list.  Transitions between states
  #  of gdb will enable and disable different classes of menus.
  #
  # FIXME - support insert_command, and also cascade menus, whenever
  # we need it...
  ####################################################################

  # ------------------------------------------------------------------
  #  METHOD:  add - Add something.
  #                 It can be a menubutton for the main menu,
  #                 a separator or a command.
  #
  #  type - what we want to add
  #  args - arguments appropriate to what is being added
  #
  #  RETURNS: the cascade menu widget path.
  # ------------------------------------------------------------------
  method add {type args} {

    switch $type {
      menubutton {
        eval menubar_new_menu $args
      }
      command {
        eval menubar_add_menu_command $args
      }
      separator {
        menubar_add_menu_separator
      }
      cascade {
	eval menubar_add_cascade $args
      }
      default {
        error "Invalid item type: $type"
      }
    }

    return $current_menu
  }

  # ------------------------------------------------------------------
  #  NAME:         private method GDBMenuBar::menubar_add_cascade
  #  DESCRIPTION:  Create a new cascading menu in the current menu
  #
  #  ARGUMENTS:    menu_name - the name of the menu to be created
  #                label     - label to be displayed for the menu
  #                underline - which element to underline for shortcuts
  #  RETURNS:      Nothing
  # ------------------------------------------------------------------
  private method menubar_add_cascade {menu_name class label underline} {
    set m [menu $current_menu.$menu_name -tearoff false]
    $current_menu add cascade -menu $m -label $label \
      -underline $underline
    incr item_number
    switch $class {
      None {}
      default {
        foreach elem $class {
	  lappend menu_classes($elem) [list $current_menu $item_number]
	}
      }
    }
    set current_menu $m
  }

  # ------------------------------------------------------------------
  #  PRIVATE METHOD:  menubar_new_menu - Add a new menu to the main
  #                      menu.
  #                      Also target this menu for subsequent
  #                      menubar_add_menu_command calls.
  #
  #  name - the token for the new menu
  #  label - The label used for the label
  #  underline - the index of the underlined character for this menu item.
  #
  # ------------------------------------------------------------------
  private method menubar_new_menu {name label underline args} {

    set current_menu $Menu.$name
    $Menu add cascade -menu  $current_menu -label $label \
      -underline $underline
    eval menu $current_menu -tearoff 0 $args

    # Save the index number of this menu. It is always the last one.
    set menu_list($name) [$Menu index end]
    set menu_list($name,label) $label
    set item_number -1
  }

  # ------------------------------------------------------------------
  #  PRIVATE METHOD:  menubar_add_menu_command - Adds a menu command item
  #                   to the currently targeted submenu of the main menu.
  #
  #  class - The class of the command, used for disabling entries.
  #  label - The text for the command.
  #  command - The command for the menu entry
  #  args  - Passed to the menu entry creation command (eval'ed) 
  # ------------------------------------------------------------------
  private method menubar_add_menu_command {class label command args} {

    eval $current_menu add command -label \$label -command \$command \
	  $args
      
    incr item_number

    switch $class {
      None {}
      default {
        foreach elem $class {
	  lappend menu_classes($elem) [list $current_menu $item_number]
	}
      }
    }
  }

  # ------------------------------------------------------------------
  #  PRIVATE METHOD:  menubar_add_menu_separator - Adds a menu separator
  #                   to the currently targeted submenu of the main menu.
  # 
  # ------------------------------------------------------------------
  private method menubar_add_menu_separator {} {
    incr item_number
    $current_menu add separator
  }

  # ------------------------------------------------------------------
  #  METHOD:  exists - Report whether a menu keyed by NAME exists.
  # 
  #  name - the token for the menu sought
  #
  #  RETURNS: 1 if the menu exists, 0 otherwise.
  # ------------------------------------------------------------------
  method exists {name} {
    return [info exists menu_list($name)]

  }

  # ------------------------------------------------------------------
  #  METHOD:  clear - Deletes the items from one of the
  #                   main menu cascade menus. Also makes this menu
  #                   the target menu.
  # 
  #  name - the token for the new menu
  #
  #  RETURNS: then item number of the menu, or "" if the menu is not found.
  #
  #  FIXME: Does not remove the deleted menus from their class lists.
  # ------------------------------------------------------------------
  method clear {name} {
    if {[info exists menu_list($name)]} {
      set current_menu [$Menu entrycget $menu_list($name) -menu]
      $current_menu delete 0 end
      set item_number -1
      return $current_menu
    } else {
      return ""
    }
  }

  # ------------------------------------------------------------------
  #  METHOD:  delete - Deletes one of the main menu
  #                    cascade menus. Also makes the previous menu the
  #                    target menu.
  # 
  #  name - the token for the new menu
  #
  #  RETURNS: then item number of the menu, or "" if the menu is not found.
  #
  #  FIXME: Does not remove the deleted menus from their class lists.
  # ------------------------------------------------------------------
  method delete {name} {
    if {[info exists menu_list($name)]} {
      $Menu delete $menu_list($name,label)
      set current_menu {}
      unset menu_list($name,label)
      unset menu_list($name)
    }
  }

  # ------------------------------------------------------------------
  # PRIVATE METHOD:  menubar_change_menu_state - Does the actual job of
  #                  enabling menus...
  #
  # INPUT:  Pass normal or disabled for the state.
  # ------------------------------------------------------------------
  private method menubar_change_menu_state {menu state} {

    [lindex $menu 0] entryconfigure [lindex $menu 1] -state $state
  }

  # ------------------------------------------------------------------
  # METHOD:  menubar_set_current_menu - Change the current_menu pointer.
  #          Returns the current value so it can be restored.
  # ------------------------------------------------------------------
  method menubar_set_current_menu {menup} {
    set saved_menu $current_menu
    set current_menu $menup
    return $saved_menu
  }

  # ------------------------------------------------------------------
  # METHOD:  menubar_get_current_menu - Get the current_menu pointer.
  #          Returns the current value so it can be restored.
  # ------------------------------------------------------------------
  method menubar_get_current_menu {} {
    return $current_menu
  }

  ####################################################################
  #
  #  PRIVATE DATA
  #
  ####################################################################

  # This array holds the menu classes.  The key is the class name,
  # and the value is the list of menus belonging to this class.
  private variable menu_classes

  # This array holds the pathname that corresponds to a menu name
  private variable menu_list

  private variable item_number -1
  private variable current_menu {}

  ####################################################################
  #
  #  PROTECTED DATA
  #
  ####################################################################

  # The menu Tk widget
  protected variable Menu

  ####################################################################
  #
  #  PUBLIC DATA
  #
  ####################################################################

  # None
}
@


1.12
log
@2004-08-27  Martin Hunt  <hunt@@redhat.com>

	* library/ipc.tcl: New file.
	* library/ipcpref.ith: New file.
	* library/ipcpref.itb: New file.

	* library/srcwin.itb (SrcWin::inferior): Call ipc
	send if enabled.

	* library/prefs.tcl (pref_set_defaults): Enable color
	schemes by default. Add IPC defaults.

	* library/srcbar.itcl (create_pref_menu): Create
	"Advanced" cascade menu and put "Edit Color Schemes"
	and "IPC Support" under it.

	* library/managedwin.itb (ManagedWin::destructor):
	If IPC enabled then send "quit" on exit.

	* library/main.tcl: Start IPC if enabled.

	* library/prefs.tcl (pref_set_defaults): Add IPC defaults.

	* library/gdbmenubar.itcl (menubar_get_current_menu):
	New method.
@
text
@d2 1
a2 1
# Copyright 2000, 2004 Red Hat, Inc.
@


1.11
log
@2004-04-05  Martin Hunt  <hunt@@redhat.com>

	* library/session.tcl: Make hostname and portname
	session-dependent. Add gdb_bg_num (the color
	scheme number) as a per-session variable.

	* library/prefs.tcl (pref_read): If color schemes are in use,
	set colors based on the current scheme.
	(pref_save): Add "bg" section.
	(pref_set_defaults): Define new variable gdb/use_color_schemes
	and define 16 default background colors.

	* library/managedwin.itb (ManagedWin::window_name): Append
	window "instance" string to window name.
	(ManagedWin::window_instance): Set window instance string.

	* library/debugwin.itb: Add a reconfig method to restore
	unique black textbackground, overriding color scheme.

	* library/csprefs.itb:
	* library/csprefs.ith: New files. Implement color scheme
	preferences.

	* library/util.tcl (set_bg_colors): New function.
	(r_setcolors): New function.

	* library/regwin.itb (_prefs_changed): Deleted.
	(reconfig): New function.  Updates tkTable color tags
	if color scheme changes.
	* library/regwin.ith: Update to reflect above changes.

	* library/srcbar.itcl (create_pref_menu): Add pulldown
	menus for "Edit Color Schemes..." and "Use Color Schemes".
	(reconfig): Fix up menu items for color schemes.

	* library/globalpref.itb (_init_var): Add
	gdb/use_color_schemes to variable list.
	(_build_win): Add a checkbutton to enable/disable
	color schemes.

	* library/gdbmenubar.itcl (menubar_add_cascade): Add a class
	argument so cascade menus can be managed by class too.

	* library/interface.tcl (gdbtk_tcl_fputs): Check for
	existence of gdbtk_state(console).  Stops annoying error
	messages.
	(gdbtk_tcl_fputs_error): Ditto.
	(gdbtk_tcl_fputs_log): Ditto.
@
text
@d291 8
@


1.10
log
@2002-10-15  Martin M. Hunt  <hunt@@redhat.com>

	* library/* : auto_mkindex cannot rebuild
	tclIndex because it does not recognize the namespace
	import in main.tcl.  To get it to work again, rename the
	following:
		body -> itcl::body
		configbody -> itcl::configbody
		class -> itcl::class
@
text
@d2 1
a2 1
# Copyright 2000 Red Hat, Inc.
d141 1
a141 1
  private method menubar_add_cascade {menu_name label underline} {
d145 9
@


1.9
log
@        * library/gdbmenubar.itcl (add): Add new "cascade" type.
        (menubar_add_cascade): New method to build cascading menus.
@
text
@d31 1
a31 1
class GDBMenuBar {
@


1.8
log
@	* library/srcbar.itcl (_post): New method.
	(_update_file_menu): New method.
	(create_file_menu): Move the guts to _update_file_menu.
	Add a post command to the menu.
	* library/interface.tcl (gdbtk_tcl_file_changed): Catch the
	call to run_hooks.
	(gdbtk_tcl_exec_file_display): Save the new session, too.
	(set_exe_name): Don't bother saving the session here.
	(_close_file): Save the session here, too.
	(gdbtk_clear_file): Catch the call to run_hooks, too.
	* library/gdbmenubar.itcl (menubar_new_menu): Allow caller
	to specify optional arguments to be passed to Tk when
	creating the menu.
	Tk's "menu add" command returns an empty string. Save the
	menu's index in the parent instead. This is what all
	the menu subcommands want.
@
text
@d121 3
d133 18
a150 2
  #  PRIVATE METHOD:  menubar_new_menu - Add a new cascade menu to the
  #                      main menu.
@


1.7
log
@2001-02-01  Fernando Nasser  <fnasser@@redhat.com>

	* library/gdbmenubar.itcl (constructor): Remove unused code.
	(add): New method.  Emulate the style of the menubar iwidget commands.
	(menubar_show): Old name.
	(show): New name.
	(menubar_menu_exists): Old name.
	(exists): New name.
	(menubar_clear_menu): Old name.
	(clear): New name.
	(menubar_delete_menu): Old name.
        (delete): New name.
	(menubar_new_menu): Make private.  Does not return anything.
	(menubar_add_menu_command): Make private.
	(menubar_add_menu_separator): Ditto.
	(menubar_change_menu_state): Ditto.
	* library/srcbar.itcl: Adjust to the above syntax.
	* library/plugins/plugins.tcl: Ditto.
	* library/plugins/rhabout/rhabout.itcl: Ditto.
@
text
@d140 2
a141 1
  private method menubar_new_menu {name label underline} {
d143 6
a148 3
    set menu_list($name) [$Menu add cascade -menu  $current_menu \
			     -label $label -underline $underline]
    menu $current_menu -tearoff 0
a149 1

@


1.6
log
@2001-01-28  Fernando Nasser  <fnasser@@redhat.com>

	* library/gdbmenubar.itcl (menubar_new_menu): Save lable of a menu to
	use as index.
	(menubar_delete_menu): New function.  Delete a menu.
@
text
@a38 3
    set OtherMenus {}
    set ControlMenus {}

d53 1
a53 1
  #  METHOD:  menubar_show - attach menu to the toplevel window
d55 1
a55 1
  public method menubar_show {} {
d100 32
a131 1
  #  METHOD:  menubar_new_menu - Add a new cascade menu to the main menu.
a138 1
  #  RETURNS: the cascade menu widget path.
d140 1
a140 1
  method menubar_new_menu {name label underline} {
a147 1
    return $current_menu
d151 37
a187 2
  #  METHOD:  menubar_menu_exists - Report whether a menu keyed by
  #           NAME exists.
d193 1
a193 1
  method menubar_menu_exists {name} {
d199 1
a199 1
  #  METHOD:  menubar_clear_menu - Deletes the items from one of the
d209 1
a209 1
  method menubar_clear_menu {name} {
d221 3
a223 3
  #  METHOD:  menubar_delete_menu - Deletes one of the main menu
  #                   cascade menus. Also makes the previous menu the
  #                   target menu.
d231 1
a231 1
  method menubar_delete_menu {name} {
d241 1
a241 37
  #  METHOD:  menubar_add_menu_separator - Adds a menu separator to
  #                   the currently targeted submenu of the main menu.
  # 
  # ------------------------------------------------------------------
  method menubar_add_menu_separator {} {
    incr item_number
    $current_menu add separator
  }

  # ------------------------------------------------------------------
  #  METHOD:  menubar_add_menu_command - Adds a menu command item to
  #                   the currently targeted submenu of the main menu.
  #
  #  class - The class of the command, used for disabling entries.
  #  label - The text for the command.
  #  command - The command for the menu entry
  #  args  - Passed to the menu entry creation command (eval'ed) 
  # ------------------------------------------------------------------
  method menubar_add_menu_command {class label command args} {

    eval $current_menu add command -label \$label -command \$command \
	  $args
      
    incr item_number

    switch $class {
      None {}
      default {
        foreach elem $class {
	  lappend menu_classes($elem) [list $current_menu $item_number]
	}
      }
    }
  }

  # ------------------------------------------------------------------
  # METHOD:  menubar_change_menu_state - Does the actual job of
d246 1
a246 1
  method menubar_change_menu_state {menu state} {
@


1.5
log
@2001-01-28  Fernando Nasser  <fnasser@@redhat.com>

	* library/gdbmenubar.itcl (menu_list): Add missing declararion for
	global variable.
@
text
@d118 1
d156 20
@


1.4
log
@2001-01-28  Fernando Nasser  <fnasser@@redhat.com>

	* library/gdbmenubar.itcl (set_class_state): Turn off verbose debug
	messages.
	* library/gdbtoolbar.itcl (set_class_state): Ditto.
@
text
@d225 3
@


1.3
log
@2001-01-25  Fernando Nasser  <fnasser@@redhat.com>

	* library/srcbar.itcl: New file. Implement SrcBar, a menu and toolbar
	for the Source Window (code previously in srcmenubar.itcl and
	srctoolbar.itcl).
	* library/srcmenubar.itcl: Remove obsolete file.
	* library/srctoolbar.itcl: Remove obsolete file.
	* library/srcbar.tcl: Remove obsolete file.
	* library/gdbmenubar.itcl (menubar_show): New method. Associate the
	menu with the toplevel window.
        * library/srcwin.itb (_build_win): Use SrcBar.
	* library/tclIndex: Regenerate.
@
text
@d69 1
a69 1
      dbug W $type
d73 1
a73 1
          dbug W "$type $state \{$class_list\}"
d75 1
a75 1
            dbug W "$type $menu $state"
@


1.2
log
@2001-01-04  Fernando Nasser  <fnasser@@totem.toronto.redhat.com>

	* library/gdbmenubar.itcl (set_class_state): New public method.
	Standard method to control state by class.
	(menubar_menu_class_find): Delete public accessor method.
	(menubar_change_menu_state): Change the state of a menu item
	not of a whole class list.
	* library/srcmenubar.itcl (enable_ui): Use set_class_state instead
	of prying into base class internal data.
        * library/gdbtoolbar.itcl (set_class_state): New public method.
        Standard method to control state by class.
        (toolbar_button_class_find): Delete public accessor method.
	* library/srctoolbar.itcl (enable_ui): Use set_class_state instead
	of prying into base class internal data.
@
text
@d56 7
@


1.1
log
@2001-01-02  Fernando Nasser  <fnasser@@totem.toronto.redhat.com>

	* library/gdbmenubar.itcl: New file. Define the GDBMenuBar class,
	a generic menubar building facility for Insight windows (WIP).
	* library/gdbtoolbar.itcl: New file. Define the GDBToolBar class,
	a generic toolbar building facility for Insight windows (WIP).
	* library/srcmenubar.itcl: New file. Define the SrcMenuBar class,
	which implements the Source Window menubar (inherits GDBMenuBar).
	* library/srctoolbar.itcl: New file. Define the SrcToolBar class,
	which implements the Source Window toolbar (inherits GDBToolBar).
	* library/srcwin.itb (_build_win): Use SrcMenuBar and SrcToolBar
	instead of the obsolete GDBSrcBar.
	* library/srcbar.tcl: Mark as OBSOLETE.
	* library/toolbar.tcl: Mark as OBSOLETE. Rename class GDBToolBar
	to avoid conflict with new class with the same name.
	* library/Makefile (TCL): Include .itcl files.
	* library/tclIndex: Regenerate.
@
text
@d54 21
a129 16
  #  METHOD:  menubar_menu_class_find - Find a menu class and returns
  #                   its members.
  # 
  #  type - the token for the menu class sought
  #
  #  RETURNS: class members (list) if the class exists, {} otherwise.
  # ------------------------------------------------------------------
  method menubar_menu_class_find {type} {
    if {[info exists menu_classes($type)]} {
      return $menu_classes($type)
    } else {
      return {}
    }
  }

  # ------------------------------------------------------------------
d193 1
a193 1
  method menubar_change_menu_state {state menuList} {
d195 1
a195 3
    foreach elem $menuList {
      [lindex $elem 0] entryconfigure [lindex $elem 1] -state $state
    }	
@

