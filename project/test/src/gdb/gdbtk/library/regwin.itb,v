head	1.31;
access;
symbols
	insight_7_6-2013-04-10-branchpoint:1.30
	gdb_7_6-branch:1.30.0.4
	gdb_7_5-branch:1.30.0.2
	gdb_7_4-branch:1.29.0.14
	gdb_7_3-branch:1.29.0.12
	gdb_7_1-branch:1.29.0.10
	gdb_7_0-branch:1.29.0.8
	arc-sim-20090309:1.29
	arc-insight_6_8-branch:1.29.0.6
	arc-insight_6_8-branchpoint:1.29
	insight_6_8-branch:1.29.0.4
	insight_6_8-branchpoint:1.29
	gdb_6_8-branch:1.29.0.2
	insight_6_6-20070208-release:1.28
	gdb_6_6-branch:1.28.0.4
	gdb_6_6-2006-11-15-branchpoint:1.28
	insight_6_5-20061003-release:1.28
	gdb_6_5-branch:1.28.0.2
	gdb_6_5-2006-05-14-branchpoint:1.28
	gdb-csl-gxxpro-6_3-branch:1.27.0.4
	gdb-csl-gxxpro-6_3-branchpoint:1.27
	gdb_6_4-branch:1.27.0.2
	gdb_6_4-2005-11-01-branchpoint:1.27
	gdb_6_1-2004-04-05-release:1.26
	gdb_6_1-branch:1.26.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.26
	gdb_6_0-2003-10-04-release:1.26
	gdb_6_0-branch:1.26.0.2
	gdb_6_0-2003-06-23-branchpoint:1.26
	gdb_5_3-2002-12-12-release:1.17
	gdb_5_3-branch:1.17.0.2
	gdb_5_3-2002-09-04-branchpoint:1.17
	gdb_5_2_1-2002-07-23-release:1.14
	gdb_5_2-2002-04-29-release:1.14
	gdb_5_2-branch:1.14.0.2
	gdb_5_2-2002-03-03-branchpoint:1.14
	gdb_5_1_1-2002-01-24-release:1.13
	cygnus_cvs_20020108_pre:1.14
	gdb_5_1_0_1-2002-01-03-branch:1.13.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.13
	gdb_5_1-2001-11-21-release:1.13
	gdb_s390-2001-09-26-branch:1.13.0.4
	gdb_s390-2001-09-26-branchpoint:1.13
	gdb_5_1-2001-07-29-branch:1.13.0.2
	gdb_5_1-2001-07-29-branchpoint:1.13
	dberlin-typesystem-branch:1.12.0.2
	dberlin-typesystem-branchpoint:1.12
	insight-precleanup-2001-01-01:1.7
	gdb_5_0-2000-05-19-release:1.4
	gdb_4_18_2-2000-05-18-release:1.4
	gdb_4_95_1-2000-05-11-snapshot:1.4
	gdb_4_95_0-2000-04-27-snapshot:1.4
	gdb_5_0-2000-04-10-branch:1.4.0.2
	gdb_5_0-2000-04-10-branchpoint:1.4
	repo-unification-2000-02-06:1.1.1.1
	insight-2000-02-04:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.31
date	2013.09.06.09.35.25;	author aburgess;	state Exp;
branches;
next	1.30;

1.30
date	2012.05.25.10.34.32;	author rosch;	state Exp;
branches;
next	1.29;

1.29
date	2007.06.27.20.50.50;	author kseitz;	state Exp;
branches;
next	1.28;

1.28
date	2005.12.23.18.26.50;	author eliz;	state Exp;
branches;
next	1.27;

1.27
date	2004.04.05.20.36.47;	author hunt;	state Exp;
branches;
next	1.26;

1.26
date	2003.03.27.18.02.08;	author kseitz;	state Exp;
branches;
next	1.25;

1.25
date	2003.01.21.21.58.34;	author hunt;	state Exp;
branches;
next	1.24;

1.24
date	2002.12.19.01.09.09;	author hunt;	state Exp;
branches;
next	1.23;

1.23
date	2002.12.17.20.29.12;	author hunt;	state Exp;
branches;
next	1.22;

1.22
date	2002.12.05.18.32.10;	author hunt;	state Exp;
branches;
next	1.21;

1.21
date	2002.12.04.20.46.04;	author hunt;	state Exp;
branches;
next	1.20;

1.20
date	2002.12.03.22.52.23;	author hunt;	state Exp;
branches;
next	1.19;

1.19
date	2002.11.06.20.45.53;	author hunt;	state Exp;
branches;
next	1.18;

1.18
date	2002.10.15.21.19.51;	author hunt;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.07.09.22.44;	author hunt;	state Exp;
branches;
next	1.16;

1.16
date	2002.05.16.01.09.37;	author hunt;	state Exp;
branches;
next	1.15;

1.15
date	2002.03.05.22.22.19;	author hunt;	state Exp;
branches;
next	1.14;

1.14
date	2001.08.13.18.58.36;	author kseitz;	state Exp;
branches;
next	1.13;

1.13
date	2001.07.16.18.05.08;	author nsd;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.04.15.49.53;	author kseitz;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.31.20.32.58;	author kseitz;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.31.15.21.40;	author kseitz;	state Exp;
branches;
next	1.9;

1.9
date	2001.04.20.18.47.33;	author kseitz;	state Exp;
branches;
next	1.8;

1.8
date	2001.02.08.19.26.31;	author fnasser;	state Exp;
branches;
next	1.7;

1.7
date	2000.11.29.22.06.49;	author lsmith;	state Exp;
branches;
next	1.6;

1.6
date	2000.05.04.16.08.37;	author fnasser;	state Exp;
branches;
next	1.5;

1.5
date	2000.05.03.19.48.48;	author fnasser;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.05.23.53.12;	author jingham;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.04.00.17.47;	author jingham;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.28.23.04.13;	author jimb;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.07.00.19.42;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.07.00.19.42;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.31
log
@Notice architecture changes even when the register window is not open.

  https://sourceware.org/ml/insight/2013-q3/msg00036.html

gdb/gdbtk/ChangeLog

        * library/interface.tcl (gdbtk_tcl_architecture_changed): Add call
        to gdb_reg_arch_changed.
        * library/regwin.itb (arch_changed): Remove call to
        gdb_reg_arch_changed.
@
text
@# Register display window for Insight.
# Copyright (C) 1998-2012 Red Hat, Inc.
#
# Written by Keith Seitz (keiths@@redhat.com)
#        and Martin Hunt (hunt@@redhat.com)
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License (GPL) as published by
# the Free Software Foundation; either version 2 of the License, or (at
# your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# TODO
#
# Must fix:
# o Edit menus -- weirdo interaction with tkTable. Seems okay on windows.
#                 Needs more testing on unix (popup edit menu item).
#
# Want really badly:
# o Multiple selections
# o Multiple displays
# o Better resizing
# o Register groups (gdb and user-defined)
# o format register values before inserting into table?
#   (Instead of displaying "0x0", we should use "0x00000000" on
#    machines with 32-bit regs, "0x0000000000000000" on machines
#    with 64-bit regs, etc. Maybe user-defined formats, i.e.,
#    "0x0000 0000 0000 0000 0000 0000"?)

# ------------------------------------------------------------------
#  NAME:         RegWin::constructor
#  DESCRIPTION:  Create a new register window
#
#  ARGUMENTS:    None
#  RETURNS:      Nothing
# ------------------------------------------------------------------
itcl::body RegWin::constructor {args} {

  eval itk_initialize $args    

  gdbtk_busy

  window_name "Registers" "Regs"
  _build_win
  _layout_table

  # Clear gdb's changed list
  catch {gdb_reginfo changed}

  gdbtk_idle
}

# ------------------------------------------------------------------
#  NAME:         RegWin::destructor
#  DESCRIPTION:  Destroys the register window
#
#  ARGUMENTS:    None
#  RETURNS:      Nothing
# ------------------------------------------------------------------
itcl::body RegWin::destructor {} {
  debug
}

# ------------------------------------------------------------------
#  NAME:         RegWin::_load_prefs
#  DESCRIPTION:  Load register preferences
#
#  ARGUMENTS:    None
#  RETURNS:      Nothing
# ------------------------------------------------------------------
itcl::body RegWin::_load_prefs {} {
  debug

  # Find out largest register name length.
  set _max_label_width 0;	# for reg labels
  set _reg_display_list {}
  set _register(hidden) {}

  set regs [gdb_reginfo group $_group]
  foreach r [gdb_reginfo name -numbers $regs] {
    set nm [lindex $r 0]
    set rn [lindex $r 1]
    set size [string length $nm]
    if {$size > $_max_label_width} {
      set _max_label_width $size
    }

    # Set type from prefs or default to first in list of types
    set _types($rn) [gdb_reginfo type $rn]
    set tp [pref getd gdb/reg/${nm}-type]
    set _type($rn,name) ""
    if {$tp != ""} {
      foreach t $_types($rn) {
	if {[lindex $t 0] == $tp} {
	  set _type($rn,name) $tp
	  set _type($rn,addr) [lindex $t 1]
	  set _type($rn,code) [lindex $t 2]
	  break
	}
      }
    }
    if {$_type($rn,name) == ""} {
      # either not set or couldn't find it in list of types
      set _type($rn,name) [lindex [lindex $_types($rn) 0] 0]
      set _type($rn,addr) [lindex [lindex $_types($rn) 0] 1]
      set _type($rn,code) [lindex [lindex $_types($rn) 0] 2]
    }

    # Check preferences for format
    set _format($rn) [pref getd gdb/reg/${nm}-format]
    if {$_format($rn) == ""} {
      # no preference set.  Set it to hex or float
      if {$_type($rn,code) == "int"} {
	set _format($rn) "x"
      } else {
	set _format($rn) "f"
      }
      pref setd gdb/reg/${nm}-format $_format($rn)
    }
    
    gdb_reginfo format $rn $_type($rn,addr) $_format($rn)

    # Check if the user prefers not to show this register
    if {[pref getd gdb/reg/$nm] == "no"} {
      set _cell($rn) hidden
      lappend _register(hidden) $rn
    } else {
      lappend _reg_display_list $rn
    }

    # assume editable, for now
    set _editable($rn) 1
  }

  incr _max_label_width 2;	# padding
}


#
# Table layout/display methods
#

# ------------------------------------------------------------------
#  NAME:         private method RegWin::_build_win
#  DESCRIPTION:  Builds the register window from widgets
#
#  ARGUMENTS:    None
#  RETURNS:      Nothing
#
#  NOTES:        This method should only be called once for
#                each RegWin. To change the layout of the table
#                in the window, use RegWin::_layout_table.
# ------------------------------------------------------------------
itcl::body RegWin::_build_win {} {
 
  # Create scrollbars and table
  itk_component add vscroll {
    scrollbar $itk_interior.vs -orient vertical
  }
  itk_component add hscroll {
    scrollbar $itk_interior.hs -orient horizontal
  }

  itk_component add table {
    ::table $itk_interior.tbl -variable [scope _data] \
      -browsecmd [code $this _select_cell %S] -font global/fixed \
      -colstretch unset -rowstretch unset -selectmode single \
      -resizeborders none -multiline false -colwidth 18 \
      -autoclear 0 -bg $::Colors(bg) \
      -padx 5 -xscrollcommand [code $itk_component(hscroll) set] \
      -yscrollcommand [code $itk_component(vscroll) set]
  } {
    keep -foreground
    keep -insertbackground
    keep -highlightcolor
    keep -highlightbackground
  }
  bind $itk_component(table) <Up>       \
    [format "%s; break" [code $this _move up]]
  bind $itk_component(table) <Down>     \
    [format "%s; break" [code $this _move down]]
  bind $itk_component(table) <Left>     \
    [format "%s; break" [code $this _move left]]
  bind $itk_component(table) <Right>    \
    [format "%s; break" [code $this _move right]]
  bind $itk_component(table) <3>        \
    [code $this _but3 %x %y %X %Y]
  bind $itk_component(table) <Double-1> break 
  bind $itk_component(table) <1> \
    [code $this _edit %x %y]
  bind $itk_component(table) <Return>   \
    [format "%s; break" [code $this _accept_edit]]
  bind $itk_component(table) <KP_Enter>   \
    [format "%s; break" [code $this _accept_edit]]
  bind $itk_component(table) <Escape>   \
    [code $this _unedit]

  $itk_component(hscroll) configure -command [code $itk_component(table) xview]
  $itk_component(vscroll) configure -command [code $itk_component(table) yview]


  # Create/configure tags for various display styles
  # normal    - the "normal" display style
  # highlight - changed registers are highlighted
  # sel       - the selection fg/bg should conform to standard
  # header    - used on the register name cells and empty cells
  # edit      - used on a cell being edited
  $itk_component(table) tag configure normal  \
    -state disabled -bg $::Colors(textbg) -fg $::Colors(textfg)
  $itk_component(table) tag configure sel -bg $::Colors(sbg) -fg $::Colors(sfg)
  $itk_component(table) tag configure highlight -bg $::Colors(change) -fg black
  $itk_component(table) tag raise highlight
  $itk_component(table) tag configure header \
    -anchor w -state disabled -relief raised
  $itk_component(table) tag configure disabled \
    -state disabled
  $itk_component(table) tag raise active
  $itk_component(table) tag configure edit \
    -state normal 
  $itk_component(table) tag raise edit
  $itk_component(table) tag raise sel

  itk_component add frame {
    frame $itk_interior.m
  }
  iwidgets::optionmenu $itk_component(frame).opt -labeltext "Group:" \
    -labelpos w -command [code $this _select_group]
  eval $itk_component(frame).opt insert end [gdb_reginfo grouplist]
  $itk_component(frame).opt select "all"
  
  pack $itk_component(frame).opt -anchor nw
  grid $itk_component(frame) -row 0 -columnspan 2 -sticky news
  grid $itk_component(table) -row 1 -column 0 -sticky news
  grid $itk_component(vscroll) -row 1 -column 1 -sticky ns
  grid $itk_component(hscroll) -row 2 -column 0 -sticky ew
  grid columnconfigure $itk_interior 0 -weight 1
  grid rowconfigure $itk_interior 0 -weight 0
  grid rowconfigure $itk_interior 1 -weight 1

  # Add popup menu - we populate it in the event handler
  itk_component add popup {
    menu $itk_interior.pop -tearoff 0
  } {}
}

# ------------------------------------------------------------------
#  NAME:         private method RegWin::_layout_table
#  DESCRIPTION:  Configures and lays out the table
#
#  ARGUMENTS:    None
#  RETURNS:      Nothing
#
#  NOTES:        Uses preferences to determine if/how a register
#                is displayed
# ------------------------------------------------------------------
itcl::body RegWin::_layout_table {} {
  debug

  if {[info exists _cell]} {
    unset _cell
    unset _register
  }
  # Clear any column spans
  foreach span [$itk_component(table) spans] {
    $itk_component(table) spans $span 0,0
  }

  _load_prefs

  # Fill data array with register names.
  # 
  # The table is indexed by (row,col). All odd columns will contain
  # register values and all even columns will contain the labels.
  #
  set x 0
  set y 0

  # get register list
  set regs [gdb_reginfo name -numbers $_reg_display_list]

  # Set table dimensions
  set num [llength $regs]
  set _rows [pref get gdb/reg/rows]
  set _cols [expr $num / $_rows]
  if {[expr $num % $_rows] != 0} { incr _cols }
  set _cols [expr 2 * $_cols]
  $itk_component(table) configure -cols $_cols -rows $_rows

  # get values
  if {[catch {gdb_reginfo value $_reg_display_list} values]} {
    dbug W "values=$values"
    set values ""
  }
  set i 0

  # now build table
  foreach r $regs {
    set name [lindex $r 0]
    set rn [lindex $r 1]

    set _cell($rn) "$y,[expr {$x+1}]"
    set _register($_cell($rn)) $rn
    set _data($y,$x) $name
    set _data($_cell($rn)) [lindex $values $i]
    incr i

    # Go to next row/column
    incr y
    if {$y == $_rows} {
      set _col_size([expr {$x+1}]) 0
      
      # Size the column
      if {$::gdb_running} {
	_size_column [expr {$x+1}] 1
      }

      $itk_component(table) width $x $_max_label_width
      $itk_component(table) tag col header $x
      $itk_component(table) tag col normal [expr {$x+1}]
      
      set y 0
      incr x 2
    }
  }

  # Mark empty cells
  while {$y != $_rows && $x != $_cols} {
    set _data($y,$x) ""
    set _data($y,[expr {$x+1}]) ""
    $itk_component(table) spans $y,$x 0,1
    $itk_component(table) tag cell header $y,$x
    set _col_size([expr {$x+1}]) 0

    incr y
    if {$y == $_rows} {
      # Size the column
      if {$::gdb_running} {
	_size_column [expr {$x+1}] 1
      }
      $itk_component(table) width $x $_max_label_width
      $itk_component(table) tag col header $x
      $itk_component(table) tag col normal [expr {$x+1}]

      set y 0
      incr x 2
    }
  }
}

# ------------------------------------------------------------------
#  NAME:         private method RegWin::_size_cell_column
#  DESCRIPTION:  Resize the column for a given cell.
#
#  ARGUMENTS:
#                cell  - the cell whose column is to be resized
#                down  - whether the resizing should size the column
#                        down or just up.
#  RETURNS:      Nothing
#
#  NOTES:        See _size_column for the reasoning for the "down"
#                option.
# ------------------------------------------------------------------
itcl::body RegWin::_size_cell_column {cell down} {

  set col [string trim [lindex [split $cell ,] 1] ()]
  _size_column $col $down
}

# ------------------------------------------------------------------
#  NAME:         private method RegWin::_size_column
#  DESCRIPTION:  Resize the given column
#
#  ARGUMENTS:
#                col  - the column to be resized
#                down - whether the resizing should size the column
#  RETURNS:             down or just up.
#
#  NOTES:        The down option allows column sizes to change down
#                as well as up. For most cases, this is what is
#                wanted. However, when the user is stepping, it is
#                really annoying to see the column sizes changing.
#                It's bad enough we must size up, but going down
#                is just too much. Consequently, when updating the
#                contents of the table, we specify that the columns
#                should not downsize. This helps mitigate the
#                annoyance.
# ------------------------------------------------------------------
itcl::body RegWin::_size_column {col down} {

  set max 0
  foreach cell [array names _data *,$col] {
    set len [string length $_data($cell)]
    if {$len > $max} { set max $len }
  }

  if {($down && $max != $_col_size($col))
      || (!$down && $max > $_col_size($col))} {
    set _col_size($col) $max
    $itk_component(table) width $col [expr {$max + 2}]

    # Force the table to update itself
    after idle event generate $itk_component(table) <Configure> \
      -width [winfo width $itk_component(table)]
  }
}

# ------------------------------------------------------------------
#  NAME:         private method RegWin::reconfig
#  DESCRIPTION:  Reconfigures register window when a preference
#                changes.
#
#  ARGUMENTS:	 None
#  RETURNS:      Nothing
#
# ------------------------------------------------------------------
itcl::body RegWin::reconfig {} {
  $itk_component(table) tag configure normal  \
    -state disabled -bg $::Colors(textbg) -fg $::Colors(textfg)
  $itk_component(table) tag configure highlight -bg $::Colors(change) -fg black
}


#
# Table event handlers and related methods
#

# ------------------------------------------------------------------
#  NAME:         private method RegWin::_accept_edit
#  DESCRIPTION:  Change a register's value
#
#  ARGUMENTS:    None
#  RETURNS:      Nothing
#
#  NOTES:        Event handler for <Enter> and <KP_Enter>
#                in table
# ------------------------------------------------------------------
itcl::body RegWin::_accept_edit {} {
  debug
  set cell [$itk_component(table) tag cell edit]
  if {[llength $cell] == 1 && [info exists _register($cell)]} {
    # Select the same cell again. This forces the table
    # to keep this value. Otherwise, we'll never see it...
    _select_cell $cell
    set rn $_register($cell)
    set n [gdb_reginfo name $rn]
    if {[llength $_types($rn)] > 1} {
      append n ".$_type($rn,name)"
    }
    set v [string trim [$itk_component(table) curvalue] \ \r\n]
    debug "n=$n v=$v"
    if {$v != ""} {
      if {[catch {gdb_cmd "set \$${n}=$v"} result]} {
	tk_messageBox -icon error -type ok -message $result \
	  -title "Error in Expression" -parent $_top
      }
    }

    # Always update the register, even for error conditions. This
    # will ensure that the cell's old value is restored to the table.
    _update_register $_register($cell)
    _size_cell_column $cell 1
  }

  _unedit
}

# ------------------------------------------------------------------
#  NAME:         private method RegWin::_add_to_watch
#  DESCRIPTION:  Add a register to the watch window
#
#  ARGUMENTS:    rn  - the register number to add to the WatchWin
#  RETURNS:      Nothing
#
#  NOTES:        Only works with one WatchWin...
# ------------------------------------------------------------------
itcl::body RegWin::_add_to_watch {rn} {
  [ManagedWin::open WatchWin] add "\$[gdb_reginfo name $rn]"
}

# ------------------------------------------------------------------
#  NAME:         private method RegWin::_add_to_watch
#  DESCRIPTION:  Add a register to the watch window
#
#  ARGUMENTS:    rn  - the register number to add to the WatchWin
#  RETURNS:      Nothing
#
#  NOTES:        Only works with one WatchWin...
# ------------------------------------------------------------------
itcl::body RegWin::_open_memory {rn} {
  ManagedWin::open MemWin -force -addr_exp $_data($_cell($rn))
}

# ------------------------------------------------------------------
#  NAME:         private method RegWin::_but3
#  DESCRIPTION:  Configure the popup menu before posting it
#
#  ARGUMENTS:    x  - x-coordinate of buttonpress
#                y  - y-coordinate
#                X  - x-root coordinate
#                Y  - y-root coordinate
#  RETURNS:      Nothing
# ------------------------------------------------------------------
itcl::body RegWin::_but3 {x y X Y} {

  # Only post the menu when we're not executing the inferior,
  # the inferior is in a runnable state, and we're not in a disabled
  # cell.
  if {!$_running && $::gdb_running} {

    # Select the register
    set cell [_select_cell [$itk_component(table) index @@$x,$y]]
    if {[info exists _register($cell)]} {
      set rn $_register($cell)
      set name [gdb_reginfo name $rn]
      $itk_component(popup) delete 0 end
      $itk_component(popup) add command -label $name -state disabled
      $itk_component(popup) add separator
      if {[llength $_types($rn)] > 1} {
	foreach t $_types($rn) {
	  $itk_component(popup) add radio -label [lindex $t 0] \
	    -variable [scope _type($rn,addr)] \
	    -value [lindex $t 1] \
	    -command [code $this _change_format $rn [lindex $t 0]]
	}
	$itk_component(popup) add separator
      }

      $itk_component(popup) add radio -label "Hex"            \
	-variable [scope _format($rn)] -value x               \
	-command [code $this _change_format $rn]

      if {$_type($rn,code) == "int"} {
	$itk_component(popup) add radio -label "Decimal"        \
	  -variable [scope _format($rn)] -value d               \
	  -command [code $this _change_format $rn]
	$itk_component(popup) add radio -label "Unsigned"       \
	  -variable [scope _format($rn)] -value u               \
	  -command [code $this _change_format $rn]
      } elseif {$_type($rn,code) == "float"} {
	$itk_component(popup) add radio -label "Floating Point" \
	  -variable [scope _format($rn)] -value f               \
	  -command [code $this _change_format $rn]
      }
      $itk_component(popup) add separator

      if {$_editable($rn)} {
	set state normal
      } else {
	set state disabled
      }
      
      if {$_type($rn,code) == "int"} {
	$itk_component(popup) add command    \
	  -label "Open Memory Window" -command [code $this _open_memory $rn]
      }
      $itk_component(popup) add command    \
	-label "Add to Watch" -command [code $this _add_to_watch $rn]
      $itk_component(popup) add separator
      $itk_component(popup) add command    \
	-label "Remove from Display" \
	-command [code $this _delete_from_display $rn]
      if {[llength $_register(hidden)] != 0} {
	$itk_component(popup) add command -label "Display all Registers" \
	  -command [code $this _display_all]
      }

      # Help
      $itk_component(popup) add separator
      $itk_component(popup) add command    \
	-label "Help" -command {open_help register.html}

      # Close
      $itk_component(popup) add separator
      $itk_component(popup) add command -label "Close" \
	-underline 0 -command [code delete object $this]

      tk_popup $itk_component(popup) $X $Y
    }
  }
}

# ------------------------------------------------------------------
#  NAME:         private method RegWin::_delete_from_display
#  DESCRIPTION:  Remove a register from the display
#
#  ARGUMENTS:    rn  - the register number to remove
#  RETURNS:      Nothing
# ------------------------------------------------------------------
itcl::body RegWin::_delete_from_display {rn} {

  # Mark the cell as hidden
  set index [lsearch $_reg_display_list $rn]
  if {$index != -1} {
    pref setd gdb/reg/[gdb_reginfo name $rn] no
    set _reg_display_list [lreplace $_reg_display_list $index $index]

    # Relayout table
    _layout_table
  }
}

# ------------------------------------------------------------------
#  NAME:         private method RegWin::_display_all
#  DESCRIPTION:  Display all registers in the window
#
#  ARGUMENTS:    None
#  RETURNS:      Nothing
# ------------------------------------------------------------------
itcl::body RegWin::_display_all {} {

  # Unhide all hidden registers
  foreach r $_register(hidden) {
    pref setd gdb/reg/[gdb_reginfo name $r] {}
  }

  # Note which register is active and restore it
  if {[catch {$itk_component(table) index active} cell]} {
    set active {}
  } else {
    set active $_register($cell)
  }
  _layout_table
  if {$active != ""} {
    $itk_component(table) activate $_cell($active)
  }
}

# ------------------------------------------------------------------
#  NAME:         private method RegWin::_edit
#  DESCRIPTION:  Enables a cell for editing
#
#  ARGUMENTS:
#                x  - the x coordinate of the button press
#                y  - the y coordinate of the button press
#  RETURNS:      Nothing
#
#  NOTES:        Event handler for <1> in table.
#                
# ------------------------------------------------------------------
itcl::body RegWin::_edit {x y} {
  _select_cell [$itk_component(table) index @@$x,$y]
}


# ------------------------------------------------------------------
#  NAME:         private method _move
#  DESCRIPTION:  Handle arrow key events in table
#
#  ARGUMENTS:    direction  - "up", "down", "left", "right"
#  RETURNS:      Nothing
#
#  NOTES:        Event handler for <Up>, <Down>, <Left>, <Right>
#                in table. This is needed because the table
#                has some rather strange bindings for moving
#                the insertion cursor when editing a cell.
#                This method will move to the next cell when
#                we're not editing, or it will move the icursor
#                if we are editing.
# ------------------------------------------------------------------
itcl::body RegWin::_move {direction} {

  debug $direction

  # If there is no active cell, the table will call error
  if {[catch {$itk_component(table) index active row} row]} {
    return
  }

  if {[$itk_component(table) tag cell edit] != ""} {
    # Editing

    switch $direction {
      up {
	# Go to beginning
	$itk_component(table) icursor 0
      }

      down {
	# Go to end
	$itk_component(table) icursor end
      }

      left {
	# Go left one character
	set ic [$itk_component(table) icursor]
	if {$ic > 0} {
	  $itk_component(table) icursor [expr {$ic - 1}]
	}
      }

      right {
	# Go right one character
	set ic [$itk_component(table) icursor]
	if {$ic < [$itk_component(table) icursor end] } {
	  $itk_component(table) icursor [expr {$ic + 1}]
	}
      }
    }

  } else {
    # Not editing

    set col [$itk_component(table) index active col]

    switch $direction {
      up {
	incr row -1
	if {$row < 0} {
	  # go to bottom
	  set row $_rows
	}
      }

      down {
	incr row 1
	if {$row == $_rows} {
	  # go to top
	  set row 0
	}
      }

      left {
	incr col -2
	if {$col < 0} {
	  # go to right
	  set col [expr {$_cols -1}]
	}
      }

      right {
	incr col 2
	if {$col > $_cols} {
	  # go to left
	  set col 0
	}
      }
    }

    # clear the selection
    # FIXME: multiple selections?
    $itk_component(table) selection clear all

    _select_cell $row,$col
  }
}


# ------------------------------------------------------------------
#  NAME:         private method RegWin::_select_cell
#  DESCRIPTION:  Selects a given cell in the table
#
#  ARGUMENTS:
#                cell  - the table index to select
#  RETURNS:      The actual cell selected
#
#  NOTES:        Adjusts the cell index so that it always
#                selects the value cell for a register
# ------------------------------------------------------------------
itcl::body RegWin::_select_cell {cell} {

  # Abort an edit
  _unedit

  # check if going to label. If so, highlight next
  set row [lindex [split $cell ,] 0]
  set col [lindex [split $cell ,] 1]
  if {[expr {$col % 2}] == 0} {
    # going onto a label
    incr col 1
  }
  set cell "$row,$col"

  # Make the selected cell the active one
  $itk_component(table) activate $row,$col
  $itk_component(table) see active

  # Select this cell and its label
  # FIXME: multiple selections?
  $itk_component(table) selection clear all
  $itk_component(table) selection set $cell $row,[expr {$col-1}]

  # Now mark the cell as being edited.
  if {$::gdb_running && [info exists _register($cell)]} {
    $itk_component(table) tag cell edit $cell
  }

  focus $itk_component(table)

  return $cell
}

# ------------------------------------------------------------------
#  NAME:         private method RegWin::_unedit
#  DESCRIPTION:  Cancels an edit
#
#  ARGUMENTS:    None
#  RETURNS:      Nothing
# ------------------------------------------------------------------
itcl::body RegWin::_unedit {} {

  # clear the tag
  set cell [$itk_component(table) tag cell edit]

  if {$cell != ""} {
    $itk_component(table) selection clear all
    $itk_component(table) tag cell normal $cell 
    focus $itk_component(table)
  }
}

#
# Register operations
#

# ------------------------------------------------------------------
#  NAME:         private method RegWin::_get_value
#  DESCRIPTION:  Get the value of a register
#
#  ARGUMENTS:    rn  - the register number whose value should be
#                      fetched
#  RETURNS:      The register's value or ""
#
#  NOTES:        
# ------------------------------------------------------------------
itcl::body RegWin::_get_value {rn} {
  if {[catch {gdb_reginfo value $rn} value]} {
    dbug W "\"gdb_reginfo value $rn\" returned $value"
    set value ""
  } else {
    set value [string trim $value \ ]
  }
  return $value
}

# ------------------------------------------------------------------
#  NAME:         private method RegWin::_change_format
#  DESCRIPTION:  Change the display format of the register
#
#  ARGUMENTS:    rn  - the register number to change
#		 newtype - type name (optional if just format changed)
#
#  RETURNS:      Nothing
#
#  NOTES:        
# ------------------------------------------------------------------
itcl::body RegWin::_change_format {rn {newtype {}}} {

  set name [gdb_reginfo name $rn]

  if {$newtype != ""} {
    set _type($rn,name) $newtype
    pref setd gdb/reg/${name}-type $newtype
  }
  
  gdb_reginfo format $rn $_type($rn,addr) $_format($rn)

  # Set the new format in prefs. 
  pref setd gdb/reg/${name}-format $_format($rn)

  _update_register $rn
  _size_cell_column $_cell($rn) 1

  # Show the active cell in case it's moved as a result
  # of resizing the columns.
  $itk_component(table) see active
}

# ------------------------------------------------------------------
#  NAME:         private_method RegWin::_update_register
#  DESCRIPTION:  Updates the value of a register and refreshes
#                the table
#
#  ARGUMENTS:
#                rn  - the register number to update
#  RETURNS:      Nothing
# ------------------------------------------------------------------
itcl::body RegWin::_update_register {rn} {
  set _data($_cell($rn)) [_get_value $rn]
}

# ------------------------------------------------------------------
#  NAME:         private_method RegWin::_select_group
#  DESCRIPTION:  Changes the register group. Callback
#
#  ARGUMENTS:
#                
#  RETURNS:      Nothing
# ------------------------------------------------------------------
itcl::body RegWin::_select_group {} {
  set gr [$itk_component(frame).opt get]
  debug $gr
  if {$gr == ""} {
    return
  }

  # Change anything on the old change list back to normal
  foreach r $_change_list {
    if {[info exists _cell($r)] && $_cell($r) != "hidden"} {
      $itk_component(table) tag cell normal $_cell($r)
    }
  }

  set _group $gr
  _layout_table

  # highlight changed registers if they still exist in the new group
  foreach r $_change_list {
    if {[info exists _cell($r)] && $_cell($r) != "hidden" && $_data($_cell($r)) != ""} {
      $itk_component(table) tag cell highlight $_cell($r)
    }
  }

  # Clear gdb's change list
  catch {gdb_reginfo changed}
}


#
# Gdb Events
#

# ------------------------------------------------------------------
#  NAME:         public method RegWin::arch_changed
#  DESCRIPTION:  ArchChangedEvent handler
#
#  ARGUMENTS:    event  - the ArchChangedEvent (not used)
#  RETURNS:      Nothing
# ------------------------------------------------------------------
itcl::body RegWin::arch_changed {event} {

  # Relayout the table
  _layout_table

  # Clear gdb's change list
  catch {gdb_reginfo changed}
}

# ------------------------------------------------------------------
#  NAME:         public method RegWin::busy
#  DESCRIPTION:  BusyEvent handler
#
#  ARGUMENTS:    event  - the BusyEvent (not used)
#  RETURNS:      Nothing
# ------------------------------------------------------------------
itcl::body RegWin::busy {event} {

  # Abort any edit. Need to check if the table is constructed,
  # since we call gdbtk_busy when we're created...
  if {[info exists itk_component(table)]} {
    _unedit
  }

  # Set fencepost
  set _running 1

  # Set cursor
  $_top configure -cursor watch
}

# ------------------------------------------------------------------
#  NAME:         public method RegWin::idle
#  DESCRIPTION:  IdleEvent handler
#
#  ARGUMENTS:    event  - the IdleEvent (not used)
#  RETURNS:      Nothing
# ------------------------------------------------------------------
itcl::body RegWin::idle {event} {

  # Clear fencepost
  set _running 0

  # Reset cursor
  $_top configure -cursor {}
}

# ------------------------------------------------------------------
#  NAME:         public method RegWin::set_variable
#  DESCRIPTION:  SetVariableEvent handler
#
#  ARGUMENTS:    None
#  RETURNS:      Nothing
# ------------------------------------------------------------------
itcl::body RegWin::set_variable {event} {
  switch [$event get variable] {
    disassembly-flavor {
      _layout_table
    } 
  }
}

# ------------------------------------------------------------------
#  NAME:         public method RegWin::update
#  DESCRIPTION:  UpdateEvent handler
#
#  ARGUMENTS:    event  - the UpdateEvent (not used)
#  RETURNS:      Nothing
# ------------------------------------------------------------------
itcl::body RegWin::update {event} {
  debug

  # Change anything on the old change list back to normal
  foreach r $_change_list {
    if {[info exists _cell($r)] && $_cell($r) != "hidden"} {
      $itk_component(table) tag cell normal $_cell($r)
    }
  }

  # Now update and highlight the newly changed values
  set _change_list {}
  if {![catch {gdb_reginfo changed $_reg_display_list} changed]} {
    set _change_list $changed
  }

  # Problem: if the register was invalid (i.e, we were not running),
  # its old value will probably be "0x0". Now if we run and its real
  # value is "0x0", then it will appear as a blank in the register
  # window. Safegaurd against that here by adding any such register
  # which is not already in the change list.
  foreach r $_reg_display_list {
    if {$_data($_cell($r)) == "" && [lsearch $_change_list $r] == -1} {
      lappend _change_list $r
    }
  }

  # Tag the changed cells and resize the columns
  set cols {}
  foreach r $_change_list {
    _update_register $r

    if {$_data($_cell($r)) != ""} {
      $itk_component(table) tag cell highlight $_cell($r)
    }
    set col [lindex [split $_cell($r) ,] 1]
    if {[lsearch $cols $col] == -1} {
      lappend cols $col
    }
  }
  
  foreach col $cols {
    set col [string trim $col ()]
    _size_column $col 0
  }

  debug "END REGISTER UPDATE CALLBACK" 
}
@


1.30
log
@2012-05-25  Roland Schwingel  <roland.schwingel@@onevision.com>

   * library/locals.tcl: Updated copyright.
   (reconfig): New method for getting prefs updates.
   * library/prefs.tcl: Updated copyright.
   (pref_read): Moved comment. Take color for changed
   fields from gdb/src/PC_TAG prefs value.
   (pref_set_defaults): Change default of
   PC_TAG color to a somewhat darker green.
   (pref_set_colors): Call pref_load_default in central place.
   (pref_set_option_db): Remove hard wired old color for
   changed values.
   * library/regwin.itb: Update copyright.
   (reconfig): Update highlight color of register table.
   * library/srcpref.itb: Update copyright.
   (_build_win): Change text of PC color chooser.
   (_apply): Update global changed fields color from PC_TAG color.
   * library/vartree.itb (update_var): use changed field color from
   global colors list.
   (_init_data): Remove local copy of changed vars color.
@
text
@a934 3
  # Update internal register caches
  gdb_reg_arch_changed

@


1.29
log
@        * generic/gdbtk-register.c (Gdbtk_Register_Init): Remove
        calls to deprecated_register_gdbarch_swap.
        Add "gdb_reg_arch_changed" command.
        * library/regwin.itb (arch_changed): Call gdb_reg_arch_changed.
@
text
@d2 1
a2 1
# Copyright (C) 1998, 1999, 2001, 2002, 2003, 2004, 2007 Red Hat, Inc.
d423 1
@


1.28
log
@	* library/attachdlg.itb:
	* library/actiondlg.tcl:
	* library/about.tcl:
	* library/ehandler.itb:
	* library/editor.tcl:
	* library/download.ith:
	* library/download.itb:
	* library/debugwin.ith:
	* library/debugwin.itb:
	* library/cspref.ith:
	* library/cspref.itb:
	* library/console.ith:
	* library/console.itb:
	* library/browserwin.ith:
	* library/browserwin.itb:
	* library/bpwin.ith:
	* library/bpwin.itb:
	* library/blockframe.ith:
	* library/managedwin.ith:
	* library/managedwin.itb:
	* library/main.tcl:
	* library/locals.tcl:
	* library/ipcpref.ith:
	* library/ipcpref.itb:
	* library/ipc.tcl:
	* library/interface.tcl:
	* library/helpviewer.tcl:
	* library/globalpref.ith:
	* library/globalpref.itb:
	* library/gdbwin.ith:
	* library/gdbtoolbar.itcl:
	* library/gdbmenubar.itcl:
	* library/gdbevent.ith:
	* library/gdbevent.itb:
	* library/embeddedwin.ith:
	* library/ehandler.ith:
	* library/srcwin.itb:
	* library/srctextwin.ith:
	* library/srctextwin.itb:
	* library/srcpref.ith:
	* library/srcpref.itb:
	* library/srcbar.itcl:
	* library/session.tcl:
	* library/regwin.ith:
	* library/regwin.itb:
	* library/process.ith:
	* library/process.itb:
	* library/prefs.tcl:
	* library/pluginwin.itcl:
	* library/modal.tcl:
	* library/memwin.ith:
	* library/memwin.itb:
	* library/mempref.ith:
	* library/mempref.itb:
	* library/watch.tcl:
	* library/watch.tcl:
	* library/warning.tcl:
	* library/vartree.ith:
	* library/vartree.itb:
	* library/util.tcl:
	* library/tracedlg.tcl:
	* library/toplevelwin.ith:
	* library/tfind_args.tcl:
	* library/tdump.tcl:
	* library/targetselection.ith:
	* library/targetselection.itb:
	* library/stackwin.ith:
	* library/stackwin.itb:
	* library/srcwin.ith:
@
text
@d2 1
a2 1
# Copyright (C) 1998, 1999, 2001, 2002, 2003, 2004 Red Hat, Inc.
d934 4
a937 3
  # When the arch changes, gdb will callback into gdbtk-register.c
  # to swap out the old register set, so we need only redraw the
  # window, updating the register names and numbers.
@


1.27
log
@2004-04-05  Martin Hunt  <hunt@@redhat.com>

	* library/session.tcl: Make hostname and portname
	session-dependent. Add gdb_bg_num (the color
	scheme number) as a per-session variable.

	* library/prefs.tcl (pref_read): If color schemes are in use,
	set colors based on the current scheme.
	(pref_save): Add "bg" section.
	(pref_set_defaults): Define new variable gdb/use_color_schemes
	and define 16 default background colors.

	* library/managedwin.itb (ManagedWin::window_name): Append
	window "instance" string to window name.
	(ManagedWin::window_instance): Set window instance string.

	* library/debugwin.itb: Add a reconfig method to restore
	unique black textbackground, overriding color scheme.

	* library/csprefs.itb:
	* library/csprefs.ith: New files. Implement color scheme
	preferences.

	* library/util.tcl (set_bg_colors): New function.
	(r_setcolors): New function.

	* library/regwin.itb (_prefs_changed): Deleted.
	(reconfig): New function.  Updates tkTable color tags
	if color scheme changes.
	* library/regwin.ith: Update to reflect above changes.

	* library/srcbar.itcl (create_pref_menu): Add pulldown
	menus for "Edit Color Schemes..." and "Use Color Schemes".
	(reconfig): Fix up menu items for color schemes.

	* library/globalpref.itb (_init_var): Add
	gdb/use_color_schemes to variable list.
	(_build_win): Add a checkbutton to enable/disable
	color schemes.

	* library/gdbmenubar.itcl (menubar_add_cascade): Add a class
	argument so cascade menus can be managed by class too.

	* library/interface.tcl (gdbtk_tcl_fputs): Check for
	existence of gdbtk_state(console).  Stops annoying error
	messages.
	(gdbtk_tcl_fputs_error): Ditto.
	(gdbtk_tcl_fputs_log): Ditto.
@
text
@d2 1
a2 1
# Copyright 1998, 1999, 2001, 2002, 2003, 2004 Red Hat, Inc.
@


1.26
log
@        From Nick Kelsey <nickk@@ubicom.com>:
        * process.itb (build_win): Removed ide_sizebox instantiation that is
        no longer required and is causing errors for win hosts.
        * tdump.tcl (build_win): Ditto.
        * locals.tcl (build_win): Removed ide_sizebox instantiation that is
        no longer required and already commented out.
        * regwin.itb (build_win): Ditto.
        * srcwin.itb (constructor): Ditto.
        * stackwin.itb (constructor): Ditto.
        * watch.tcl (constructor): Ditto.
@
text
@d2 1
a2 1
# Copyright 1998, 1999, 2001, 2002, 2003 Red Hat, Inc.
d412 1
a412 1
#  NAME:         private method RegWin::_prefs_changed
d416 1
a416 3
#  ARGUMENTS:
#                pref   - the preference which changed
#                value  - preference's new value
a418 1
#  NOTES:        Callback from pref system
d420 3
a422 4
itcl::body RegWin::_prefs_changed {pref value} {
  debug "$pref $value"
  # do nothing for now.  With proper iwidgets this would not
  # be required anyway.
@


1.25
log
@2003-01-21  Martin M. Hunt  <hunt@@redhat.com>
	* library/main.tcl: Don't require iwidgets 3.0.

	* library/console.itb (Console::_build_win): Rename
	tkTextClosestGap to tk::TextClosestGap. Rename tkCancelRepeat
	to tk::CancelRepeat. Rename tkPriv to tk::Priv. Needed for tk 8.4.1.

	* library/bpwin.itb (BpWin::build_win): Don't
	create sizebox.
	* library/locals.tcl (build_win): Ditto.
	* library/regwin.itb (RegWin::_build_win): Ditto.
	* library/srcwin.itb (SrcWin::constructor): Ditto.
	* library/stackwin.itb (StackWin::build_win): Ditto.
	* library/watch.tcl (build_win): Ditto.
@
text
@a243 6
# Add sizebox for windows
#  if {[string compare $::tcl_platform(platform) "windows"] == 0} {
#    ide_sizebox $itk_interior.sbox
#    place $itk_interior.sbox -relx 1.0 -rely 1.0 -anchor se
#  }

@


1.24
log
@2002-12-18  Martin M. Hunt  <hunt@@redhat.com>

	* library/regwin.itb (RegWin::update): When updating, check
	that a cell still exists before checking its value.
	(RegWin::_select_group): Clear cells with changed values before
	changing group.  After new group is selected, highlight any changed
	values still visible.
@
text
@d2 1
a2 1
# Copyright 1998, 1999, 2001, 2002 Red Hat, Inc.
d244 5
a248 5
  # Add sizebox for windows
  if {[string compare $::tcl_platform(platform) "windows"] == 0} {
    ide_sizebox $itk_interior.sbox
    place $itk_interior.sbox -relx 1.0 -rely 1.0 -anchor se
  }
@


1.23
log
@2002-12-17  Martin M. Hunt  <hunt@@redhat.com>

	* library/regwin.itb (_load_prefs): Get list of registers from
	the group name.
	(_build_win): Remove old menu system.  Replace with an optionmenu
	that contains all the valid group names for this architecture.
	(_layout_table): No need to update old menu.
	(_but3): Add "Close" to popup menu.
	(_delete_from_display): No need to update old menu.
	(_display_all): Ditto.
	(_post_menu): Deleted.
	(_select_group): New method. Callback for group optionmenu.

	* library/regwin.ith: New private variable _group.
	New private method _select_group.  Removed _post_menu.

	* generic/gdbtk-register.c: Include reggroups.h.
	(gdb_register_info): Add "group" and "grouplist".
	(gdb_regformat): Fix Tcl_WrongNumArgs call so it doesn't crash.
	(gdb_reggrouplist): New function. Returns the names of the
	register groups.
	(gdb_reggroup): New function. Returns the register numbers of the
	registers in a group.
@
text
@d904 1
d908 8
d917 9
a927 2
  update ""
  _layout_table
d1018 1
a1018 1
    if {$_cell($r) != "hidden"} {
@


1.22
log
@2002-12-05  Martin M. Hunt  <hunt@@redhat.com>

	* library/regwin.itb (update): Revert previous patch to this
	function. But also don't tag blank cells.
	(_but3): Fix help call.
@
text
@d83 2
a84 1
  foreach r [gdb_reginfo name -numbers] {
a86 1

a204 11
  grid $itk_component(table) -row 0 -column 0 -sticky news
  grid $itk_component(vscroll) -row 0 -column 1 -sticky ns
  grid $itk_component(hscroll) -row 1 -column 0 -sticky ew
  grid columnconfigure $itk_interior 0 -weight 1
  grid rowconfigure $itk_interior 0 -weight 1

  # Add sizebox for windows
  if {[string compare $::tcl_platform(platform) "windows"] == 0} {
    ide_sizebox $itk_interior.sbox
    place $itk_interior.sbox -relx 1.0 -rely 1.0 -anchor se
  }
d227 2
a228 12
  # Register to receive notifications on preference changes
  # (Note that these are not supported by the preference dialogs, but...)
  #foreach opt [list highlight select header] {
  #  pref add_hook gdb/font/${opt}_fg [code $this _prefs_changed]
  #  pref add_hook gdb/font/${opt}_bg [code $this _prefs_changed]
  #}

  # Create toplevel menubar
  itk_component add menubar {
    menu $itk_interior.m -tearoff false
  } {
    ignore -tearoff
d230 13
a242 1
  $_top configure -menu $itk_component(menubar)
d244 4
a247 15
  # Create register menu
  itk_component add reg_menu {
    menu $itk_component(menubar).reg -tearoff false \
      -postcommand [code $this _post_menu]
  } {
    ignore -tearoff
  }
  $itk_component(menubar) add cascade -menu $itk_component(reg_menu) \
    -label "Register" -underline 0

  # Create register->format cascade menu
  itk_component add reg_format {
    menu $itk_component(reg_menu).format -tearoff false
  } {
    ignore -tearoff
a249 27
  $itk_component(reg_menu) add cascade -menu $itk_component(reg_format) \
    -label "Format" -underline 0
  $itk_component(reg_format) add radio -label "Hex" -value x \
    -underline 0 -state disabled -command [code $this update dummy]
  $itk_component(reg_format) add radio -label "Decimal" -value d \
    -underline 0 -state disabled -command [code $this update dummy]
  $itk_component(reg_format) add radio -label "Unsigned" -value u \
    -underline 0 -state disabled -command [code $this update dummy]
  $itk_component(reg_format) add radio -label "Floating Point" -value f \
    -underline 0 -state disabled -command [code $this update dummy]
  $itk_component(reg_menu) add command -label "Open Memory Window" \
    -underline 7 -state disabled
  set _menuitems(open_memory) [$itk_component(reg_menu) index last]
  $itk_component(reg_menu) add command -label "Add to Watch" \
    -underline 7 -state disabled
  set _menuitems(add_to_watch) [$itk_component(reg_menu) index last]
  $itk_component(reg_menu) add separator
  $itk_component(reg_menu) add command -label "Remove from Display" \
    -underline 0 -state disabled
  set _menuitems(remove_from_display) [$itk_component(reg_menu) index last]
  $itk_component(reg_menu) add command -label "Display all Registers" \
    -underline 0 -state disabled -command [code $this _display_all]
  set _menuitems(display_all_registers) [$itk_component(reg_menu) index last]
  $itk_component(reg_menu) add separator
  $itk_component(reg_menu) add command -label "Close" \
    -underline 0 -command [code delete object $this]

a253 2
  $itk_component(popup) configure \
    -disabledforeground [$itk_component(menubar) cget -fg]
a357 6

  # Update register menu
  if {[llength $_register(hidden)] != 0} {
    $itk_component(reg_menu) entryconfigure $_menuitems(display_all_registers) \
      -state normal
  }
d585 5
a611 3

    $itk_component(reg_menu) entryconfigure $_menuitems(display_all_registers) \
      -state normal
a623 3
  $itk_component(reg_menu) entryconfigure $_menuitems(display_all_registers) \
    -state disabled

a628 2
  set _register(hidden) {}

a759 73
# ------------------------------------------------------------------
#  NAME:         private method RegWin::_post_menu
#  DESCRIPTION:  Configures the Register menu before it is posted
#
#  ARGUMENTS:    None
#  RETURNS:      Nothing
# ------------------------------------------------------------------
itcl::body RegWin::_post_menu {} {
  global gdb_running

  # Configure the menu for the active cell
  if {![catch {$itk_component(table) index active} cell]
      && [info exists _register($cell)] && $gdb_running} {

    set code $_type($_register($cell),code)

    $itk_component(reg_menu) entryconfigure $_menuitems(remove_from_display) \
      -state normal -command [code $this _delete_from_display $_register($cell)]

    set state normal

    for {set i 0} {$i <= [$itk_component(reg_format) index end]} {incr i} {
      $itk_component(reg_format) entryconfigure $i \
	-state $state \
	-variable [scope _format($_register($cell))] \
	-command [code $this _change_format $_register($cell)]
    }

    if {$code == "float"} {
      # disable decimal and unsigned
      $itk_component(reg_format) entryconfigure 1 -state disabled
      $itk_component(reg_format) entryconfigure 2 -state disabled
    } elseif {$code == "int"} {
      # disable float
      $itk_component(reg_format) entryconfigure 3 -state disabled
    }

    # memory window
    if {$code == "int"} {
      $itk_component(reg_menu) entryconfigure $_menuitems(open_memory) \
	-state normal -command [code $this _open_memory $_register($cell)]
    } else {
      $itk_component(reg_menu) entryconfigure $_menuitems(open_memory) \
	-state disabled
    }

    # add to watch
    $itk_component(reg_menu) entryconfigure $_menuitems(add_to_watch) \
      -state normal -command [code $this _add_to_watch $_register($cell)]

  } else {
    # Disable everything
    $itk_component(reg_menu) entryconfigure $_menuitems(remove_from_display) \
      -state disabled -command {}

    for {set i 0} {$i <= [$itk_component(reg_format) index end]} {incr i} {
      $itk_component(reg_format) entryconfigure $i -state disabled \
	-variable {}
    }

    $itk_component(reg_menu) entryconfigure $_menuitems(open_memory) \
      -state disabled -command {}

    $itk_component(reg_menu) entryconfigure $_menuitems(add_to_watch) \
      -state disabled -command {}

    if {0} {
      $itk_component(reg_menu) entryconfigure $_menuitems(edit) \
	-state disabled -command {}
    }
  }
}

d892 20
@


1.21
log
@2002-12-04  Martin M. Hunt  <hunt@@redhat.com>

	* library/regwin.itb (update): Remove some old code
	that marked registers as changed when the target started.
	(_build_win): Make changed registers more visible by
	changing their bg to Colors(change).

	* library/prefs.tcl (pref_set_option_db): Create a new
	Color(change) which is the color of text indicating a change.
	Current default is green.

	* library/vartree.itb (_init_data): Make changed values
	Color(change). Can't change bg, so we change fill color.
@
text
@d638 1
a638 2
	-label "Help" \
	-command {ManagedWin::open HtmlViewer -force -file register.html}
d1124 11
d1139 4
a1142 1
    $itk_component(table) tag cell highlight $_cell($r)
d1148 1
a1148 1

@


1.20
log
@2002-12-03  Martin M. Hunt  <hunt@@redhat.com>

	* library/srcpref.itb: Latest tk doesn't support
	"-col" as a grid option.  Use "-column".

	* library/regwin.itb: Ditto.
@
text
@d226 1
a226 1
  $itk_component(table) tag configure highlight -bg $::Colors(bg)
d1110 1
a1110 2

  dbug I "START REGISTER UPDATE CALLBACK"
a1124 11
  # Problem: if the register was invalid (i.e, we were not running),
  # its old value will probably be "0x0". Now if we run and its real
  # value is "0x0", then it will appear as a blank in the register
  # window. Safegaurd against that here by adding any such register
  # which is not already in the change list.
  foreach r $_reg_display_list {
    if {$_data($_cell($r)) == "" && [lsearch $_change_list $r] == -1} {
      lappend _change_list $r
    }
  }

d1141 1
a1141 2

  dbug I "END REGISTER UPDATE CALLBACK" 
@


1.19
log
@2002-11-06  Martin M. Hunt  <hunt@@redhat.com>

	* library/globalpref.itb (_build_win): Add radiobox
	to select KDE/GNOME/default for pref gdb/compat. Remove
	browser option.

	* library/regwin.itb (build_win): Colors(hbg) has been
	removed so use Colors(bg) instead.

	* library/prefs.tcl (pref_set_defaults): Add a new
	preference "gdb/compat" which can be set to KDE, GNOME,
	Windows or default. This allows us to change Insight's
	behavior based on windowing system.
	(pref_set_colors): Attempt to read in .gtkrc files.
	Do different things for KDE vs GNOME.
	(pref_load_default): New function. Load default colors.
	(pref_load_gnome): New function. Find and open GNOME file.
	(load_gnome_file): New function. Loads GNOME file.
	(pref_set_option_db): New function.  Set option database.
@
text
@d205 3
a207 3
  grid $itk_component(table) -row 0 -col 0 -sticky news
  grid $itk_component(vscroll) -row 0 -col 1 -sticky ns
  grid $itk_component(hscroll) -row 1 -col 0 -sticky ew
@


1.18
log
@2002-10-15  Martin M. Hunt  <hunt@@redhat.com>

	* library/* : auto_mkindex cannot rebuild
	tclIndex because it does not recognize the namespace
	import in main.tcl.  To get it to work again, rename the
	following:
		body -> itcl::body
		configbody -> itcl::configbody
		class -> itcl::class
@
text
@d226 1
a226 1
  $itk_component(table) tag configure highlight -bg $::Colors(hbg)
@


1.17
log
@2002-06-07  Martin M. Hunt  <hunt@@redhat.com>

	* library/prefs.tcl (pref_set_colors): New function.  Set up colors
	from Windows system colors or X resource database. Save in array.
	(pref_set_defaults): Remove gdb/font/normal_fg, etc.
	(pref_read): Call pref_set_colors.

	* library/main.tcl: Remove call to "tix resetoptions TixGray".

	* library/bpwin.itb, library/browserwin.itb, library/console.itb,
	library/globalpref.itb, library/memwin.itb, library/process.itb,
	library/regwin.itb, library/srcpref.itb, library/srctextwin.itb,
	library/stackwin.itb, library/tdump.tcl, library/tracedlg.tcl,
	library/variables.tcl: Replace calls to [pref get gdb/fonts/*]
	for colors with references to Color array. Remove all tixOptions calls.
	Fix up colors as necessary.
@
text
@d41 1
a41 1
body RegWin::constructor {args} {
d64 1
a64 1
body RegWin::destructor {} {
d75 1
a75 1
body RegWin::_load_prefs {} {
d158 1
a158 1
body RegWin::_build_win {} {
d315 1
a315 1
body RegWin::_layout_table {} {
d428 1
a428 1
body RegWin::_size_cell_column {cell down} {
d453 1
a453 1
body RegWin::_size_column {col down} {
d484 1
a484 1
body RegWin::_prefs_changed {pref value} {
d505 1
a505 1
body RegWin::_accept_edit {} {
d544 1
a544 1
body RegWin::_add_to_watch {rn} {
d557 1
a557 1
body RegWin::_open_memory {rn} {
d571 1
a571 1
body RegWin::_but3 {x y X Y} {
d653 1
a653 1
body RegWin::_delete_from_display {rn} {
d676 1
a676 1
body RegWin::_display_all {} {
d712 1
a712 1
body RegWin::_edit {x y} {
d732 1
a732 1
body RegWin::_move {direction} {
d826 1
a826 1
body RegWin::_post_menu {} {
d904 1
a904 1
body RegWin::_select_cell {cell} {
d944 1
a944 1
body RegWin::_unedit {} {
d970 1
a970 1
body RegWin::_get_value {rn} {
d991 1
a991 1
body RegWin::_change_format {rn {newtype {}}} {
d1022 1
a1022 1
body RegWin::_update_register {rn} {
d1038 1
a1038 1
body RegWin::arch_changed {event} {
d1056 1
a1056 1
body RegWin::busy {event} {
d1078 1
a1078 1
body RegWin::idle {event} {
d1094 1
a1094 1
body RegWin::set_variable {event} {
d1109 1
a1109 1
body RegWin::update {event} {
@


1.16
log
@2002-05-15  Martin M. Hunt  <hunt@@redhat.com>

	* library/help/register.html: Rewrite docs.

	* library/regwin.ith (_types): New private variable array to save
	the possible types for each register.
	(_type): New private variable array to save the selected type for
	each register.
	(_rows): New private variable. Number of rows in the table.
	(_cols): New private variable. Number of cols in the table.
	(_load_prefs): New private method.
	(_open_memory): New private method.
	(_edit_menu): Deleted:
	(_select): Deleted.
	(_change_format): Add optional type argument.

	* library/regwin.itb (RegWin::_load_prefs): New method. Collects
	all the prefs stuff here instead of in _layout_table. Prefs
	code was all rewritten to handle new types and formats.
	(RegWin::_build_win): Disable Double-1 binding. Bind
	button 1 to edit the cell. Don't make an Edit menu item.
	Remove Natural, Binary, Octal, and Raw formats. Add "Open
	Memory Window" menu item.
	(RegWin::_dimensions): This function was being abused so I removed
	it. Replaced with inline code in _layout_table which saves its
	computed values so it doesn't have to be recalculated unless
	something changes.
	(RegWin::_layout_table): Rewritten to be more efficient. Grabs
	all values in one call to gdb_reginfo instead of one for each register.
	Uses new types and formats.  Calls _load_prefs.
	(RegWin::_accept_edit): Use type information when setting value.
	When done, call _unedit to remove tags.
	(RegWin::_open_memory): Open memory window with initial value
	set to the value of a register.
	(RegWin::_but3): Add types menu items. Limit format options
	to reasonable ones. Add "Open Memory Window". Add "Help"
	(RegWin::_edit): Just call _select_cell.
	(RegWin::_edit_menu): Deleted.
	(RegWin::_move): Don't recompute rows and cols; use _rows and
	_cols computed by _layout_table.
	(RegWin::_post_menu): Update types and formats. Disable "Open Memory
	Window" if register is not integer. Remove Edit.
	(RegWin::_select): Deleted.
	(RegWin::_select_cell):	Tag cell as being edited. Then
	call focus, which is a workaround for a TkTable glitch where
	the insertion bar sometimes disappeared.
	(RegWin::_unedit): Clear selection. Call focus. Don't change
	any bindings.
	(RegWin::_get_value): Eliminate previous crap and just call
	"gdb_reginfo value".
	(RegWin::_change_format): Add optional type arg.  Call
	"gdb_reginfo format".
	(RegWin::_update): Get a list of all the changed registers
	instead of checking one at a time.

	* generic/gdbtk-register.c (Gdbtk_Register_Init): Don't
	create gdb_pc_reg.  It is not used. Call register_gdbarch_swap
	with regformat and regtype.
	(gdb_register_info): Add "type" and "format" options.
	(get_pc_register): Delete.
	(get_register_types): New function.  Returns list of valid types
	for a list of registers.
	(get_register): Use saved format and type for each register. Check if
	there are any registers yet (target not running). Use mem_file
	to collect output. Append output to a list.
	(map_arg_registers): If passed a list, iterate though each element
	and build a list of values to return.
	(setup_architecture_data): Memory was not being initialized, so
	use xcalloc(). Allocate memory for regformat and regtype.
	(gdb_regformat): New function called by "gdb_reginfo format".
@
text
@d163 1
a163 1
  } {}
d166 1
a166 1
  } {}
a169 1
      -bg [pref get gdb/font/normal_bg] -fg [pref get gdb/font/normal_fg] \
d173 1
a173 1
      -autoclear 0 -bg [pref get gdb/font/normal_bg] \
d176 6
a181 1
  } {}
d224 3
a226 6
    -foreground [pref get gdb/font/normal_fg] \
    -background [pref get gdb/font/normal_bg] \
    -state disabled
  $itk_component(table) tag configure highlight  \
    -foreground [pref get gdb/font/highlight_fg] \
    -background [pref get gdb/font/highlight_bg]
d228 1
a228 5
  $itk_component(table) tag configure sel     \
    -foreground [pref get gdb/font/select_fg]
  $itk_component(table) tag configure header  \
    -foreground [pref get gdb/font/header_fg] \
    -background [pref get gdb/font/header_bg] \
d234 1
a234 1
    -state normal
d240 4
a243 4
  foreach opt [list highlight select header] {
    pref add_hook gdb/font/${opt}_fg [code $this _prefs_changed]
    pref add_hook gdb/font/${opt}_bg [code $this _prefs_changed]
  }
d485 3
a487 26

  switch $pref {
    gdb/font/highlight_fg {
      $itk_component(table) tag configure highlight -fg $value
    }

    gdb/font/highlight_bg {
      $itk_component(table) tag configure highlight -bg $value
    }

    gdb/font/select_fg {
      $itk_component(table) tag configure sel -bg $value
    }

    gdb/font/select_bg {
      $itk_component(table) tag configure sel -bg $value
    }

    gdb/font/header_fg {
      $itk_component(table) tag configure header -bg $value
    }

    gdb/font/header_bg {
      $itk_component(table) tag configure header -bg $value
    }
  }
@


1.15
log
@2002-03-05  Martin M. Hunt  <hunt@@redhat.com>

	* library/prefs.tcl (pref_read): If a preference specifies
	"src-font", substitute "global/fixed".
	(pref_set_defaults): Change defaults from "src-font" to
	"global/fixed". Do not create font object "src-font". Do
	not add hook to trace its changes.
	(pref_src-font_trace): Remove.

	* library/console.itb (Console::_update_option): Remove
	font update because this happens automatically.

	* library/globalpref.itb: No need to set
	changed flag for fonts; updates happen automatically
	when prefs are updated.

	* library/bpwin.itb: Replaced src-font with global/fixed.
	* library/browserwin.itb: Ditto.
	* library/mempref.itb: Ditto.
	* library/memwin.itb: Ditto.
	* library/process.itb: Ditto.
	* library/regwin.itb: Ditto.
	* library/srcbar.itcl: Ditto.
	* library/srcpref.itb: Ditto.
	* library/srctextwin.itb: Ditto.
	* library/srcwin.itb: Ditto.
	* library/stackwin.itb: Ditto.
	* library/tdump.tcl: Ditto.
	* library/tracedlg.tcl: Ditto.
	* library/variables.tcl: Ditto.
	* library/watch.tcl: Ditto.
@
text
@d5 1
a5 1
# based on work by Martin Hunt (hunt@@redhat.com)
d25 2
d68 74
d188 2
a189 1
  bind $itk_component(table) <Double-1> \
a265 6
  if {![pref get gdb/mode]} {
    $itk_component(reg_menu) add command -label "Edit" \
      -underline 0 -state disabled
    set _menuitems(edit) [$itk_component(reg_menu) index last]
  }

a280 8
  $itk_component(reg_format) add radio -label "Natural" -value {} \
    -underline 0 -state disabled -command [code $this update dummy]
  $itk_component(reg_format) add radio -label "Binary" -value t \
    -underline 0 -state disabled -command [code $this update dummy]
  $itk_component(reg_format) add radio -label "Octal" -value o \
    -underline 0 -state disabled -command [code $this update dummy]
  $itk_component(reg_format) add radio -label "Raw" -value r \
    -underline 0 -state disabled -command [code $this update dummy]
d283 3
a285 1

a308 24
#  NAME:         private method RegWin::_dimensions
#  DESCRIPTION:  Determine dimensions for the table
#
#  ARGUMENTS:    None
#  RETURNS:      A list of {cols,rows} which may be used to
#                configure the table
#
#  NOTES:        I don't like this. (KRS 20010718)
# ------------------------------------------------------------------
body RegWin::_dimensions {} {

  # Always layout the table based on the TOTAL number
  # of registers (not just the shown ones).
  set num [llength [gdb_reginfo name]]
  set rows [pref get gdb/reg/rows]
  set cols [expr {$num / $rows}]
  if {[expr {$num % $rows}] != 0} {
    incr cols
  }

  return [list [expr {2 * $cols}] $rows]
}

# ------------------------------------------------------------------
d319 1
a319 4

  # Set table dimensions
  lassign [_dimensions] cols rows
  $itk_component(table) configure -cols $cols -rows $rows
a324 24
  set _register(hidden) {}

  # Find out largest register name length and register size length.
  set width 0;				# for reg values
  set max_width 0;			# for reg labels
  foreach r [gdb_reginfo name -numbers] {
    set nm [lindex $r 0]
    set rn [lindex $r 1]

    set size [string length $nm]
    if {$size > $max_width} {
      set max_width $size
    }

    set size [gdb_reginfo size $rn]
    if {$size > $width} {
      set width $size
    }
  }
  incr max_width 2;			# padding

  # Minwidth = size * 2 (hex) + 2 ("0x") + 2 (padding, one space each side)
  set minwidth [expr {$size * 2 + 2 + 2}]

d330 2
a336 1
  # This loop will also initialize _typed and _editable arrays.
a338 2
  set _reg_display_list {}
  foreach r [gdb_reginfo name -numbers] {
d340 20
d363 5
a367 9
    # All registers shall be considered editable
    # and non-typed until proved otherwise
    set _typed($rn) 0
    set _editable($rn) 0

    # If user has no preference, show register in hex (if we can)
    set format [pref getd gdb/reg/${name}-format]
    if {$format == ""} { set format x }
    set _format($rn) $format
d369 9
a377 10
    # Check if the user prefers not to show this register
    if {[pref getd gdb/reg/$name] == "no"} {
      set _cell($rn) hidden
      lappend _register(hidden) $rn
    } else {
      lappend _reg_display_list $rn
      set _cell($rn) "$y,[expr {$x+1}]"
      set _register($_cell($rn)) $rn
      set _data($y,$x) $name
      _update_register $rn
d379 1
a379 2
      $itk_component(table) width $x $max_width
      $itk_component(table) width [expr {$x+1}] $width
d382 3
a384 14

      # Go to next row/column
      incr y
      if {$y == $rows} {
	set _col_size([expr {$x+1}]) 0

	# Size the column
	if {$::gdb_running} {
	  _size_column [expr {$x+1}] 1
	}

	set y 0
	incr x 2
      }
d389 1
a389 1
  while {$y != $rows && $x != $cols} {
d397 1
a397 1
    if {$y == $rows} {
d402 3
d532 1
a532 1

d538 5
a542 1
    set n [gdb_reginfo name $_register($cell)]
d544 1
d558 1
a558 3
  # Reset the table bindings (see RegWin::_edit comments)
  bind $itk_component(table) <1> {}
  bind $itk_component(table) <ButtonRelease-1> {}
d575 13
d612 15
a626 4
      if {!$_typed($rn)} {
	$itk_component(popup) add radio -label "Hex"            \
	  -variable [scope _format($rn)] -value x               \
	  -command [code $this _change_format $rn]
d633 1
a633 12
	$itk_component(popup) add radio -label "Natural"        \
	  -variable [scope _format($rn)] -value {}              \
	  -command [code $this _change_format $rn]
	$itk_component(popup) add radio -label "Binary"         \
	  -variable [scope _format($rn)] -value t               \
	  -command [code $this _change_format $rn]
	$itk_component(popup) add radio -label "Octal"          \
	  -variable [scope _format($rn)] -value o               \
	  -command [code $this _change_format $rn]
	$itk_component(popup) add radio -label "Raw"            \
	  -variable [scope _format($rn)] -value r               \
	  -command [code $this _change_format $rn]
a636 1
	$itk_component(popup) add separator
d638 2
d646 3
a648 6
      # I'm disabling this, since it doesn't work very well.
      # All kinds of goofy interactions with the insertion cursor
      # and focus when editing is invoked from a menu. (KRS 20010717)
      if {1} {
	$itk_component(popup) add command  \
	  -label "Edit" -command "after idle [code $this _edit $x $y]" -state $state
d660 7
d711 1
d735 2
a736 2
#  NOTES:        Event handler for <Double-1> in table.
#                Sets special bindings for <1> and <ButtonRelease-1>.
d739 1
a739 18
  global gdb_running

  focus $itk_component(table)

  # Get and select the cell and set the edit tag on it
  set cell [_select_cell [$itk_component(table) index @@$x,$y]]

  # Ugh. In order to click on the label and keep the value
  # focused, we need to disrupt the ButtonRelease-1 event.
  bind $itk_component(table) <ButtonRelease-1> break
  
  # Disable the <1> binding while editing
  bind $itk_component(table) <1> break

  # Now mark the cell as being edited.
  if {$gdb_running && [info exists _register($cell)]} {
    $itk_component(table) tag cell edit $cell
  }
a741 17
# ------------------------------------------------------------------
#  NAME:         private method RegWin::_edit_menu
#  DESCRIPTION:  Enables a cell for editing when invoked from
#                a menu
#
#  ARGUMENTS:
#                rn  - the register to edit
#  RETURNS:      Nothing
#
#  NOTES:        
# ------------------------------------------------------------------
body RegWin::_edit_menu {rn} {

  set bbox [$itk_component(table) bbox $_cell($rn)]
  _edit [lindex $bbox 0] [lindex $bbox 1]
  event generate $_top <Enter>
}
d760 2
a801 1
    lassign [_dimensions] cols rows
d808 1
a808 1
	  set row $rows
d814 1
a814 1
	if {$row == $rows} {
d824 1
a824 1
	  set col [expr {$cols -1}]
d830 1
a830 1
	if {$col > $cols} {
d858 3
d864 2
a865 5
    if {$_typed($_register($cell))} {
      set state disabled
    } else {
      set state normal
    }
d873 19
a894 6
    # This doesn't seem to work on my linux box. It works fine on
    # Cygwin, though... (KRS 010806)
    if {$_editable($_register($cell))} {
      $itk_component(reg_menu) entryconfigure $_menuitems(edit) \
	-state normal -command [code $this _edit_menu $_register($cell)]
    }
d905 3
a917 12
# ------------------------------------------------------------------
#  NAME:         private method RegWin::_select
#  DESCRIPTION:  Selects the cell with the given coordinates
#
#  ARGUMENTS:
#                x - the x-coordinate of the cell to select
#                y - the y-coordinate of the cell to select
#  RETURNS:      The actual cell selected
# ------------------------------------------------------------------
body RegWin::_select {x y} {
  return [_select_cell [$itk_component(table) index @@$x,$y]]
}
d942 1
d951 6
a956 1
  $itk_component(table) selection set $row,$col $row,[expr {$col-1}]
d958 3
a960 1
  return $row,$col
a973 1
  $itk_component(table) tag cell normal $cell
d975 5
a979 3
  # Reset the table binding (see RegWin::_edit comments)
  bind $itk_component(table) <ButtonRelease-1> {}
  bind $itk_component(table) <1> {}
d994 1
a994 3
#  NOTES:        This function uses RegWin::_format to determine
#                how the value is returned
#                It also does some other weird stuff...
d997 2
a998 3

  # Typed registers natural values start with a brace (escaped by a slash)
  if {[catch {gdb_reginfo value {} $rn} valtest]} {
d1001 1
a1001 15
    if {[string index $valtest 1] == "\{"} {
      # If it is a typed register, we print it raw
      set format r
      set _format($rn) r
      set _typed($rn) 1
      set _editable($rn) 0
    } else {
      set format $_format($rn)
      set _editable($rn) 1
    }
    if {[catch {gdb_reginfo value $format $rn} value]} {
      set value ""
    } else {
      set value [string trim $value \ ]
    }
a1002 1

d1011 2
d1015 1
a1015 1
#  NOTES:        Assumes that hex, "x", is the default
d1017 1
a1017 1
body RegWin::_change_format {rn} {
a1018 1
  # Set the new format. Hex (x) is the default.
d1020 4
a1023 4
  if {$_format($rn) == "x"} {
    set fmt ""
  } else {
    set fmt $_format($rn)
d1025 5
a1030 1
  pref setd gdb/reg/${name}-format $fmt
a1048 1

d1148 1
a1148 1
  if {![catch {eval gdb_reginfo changed $_reg_display_list} changed]} {
@


1.14
log
@	* library/regwin.ith: Rewrite.
	* library/regwin.itb: Rewrite.
	* library/tclIndex: Regenerate.
@
text
@d2 1
a2 1
# Copyright 1998, 1999, 2001 Red Hat, Inc.
d95 1
a95 1
      -browsecmd [code $this _select_cell %S] -font src-font \
@


1.13
log
@	* library/regwin.itb (RegWin::build_win): Add radio button
	for unsigned register format.
	(RegWin::reg_select): Iterate through 8 rather than 7 formats.
	(RegWin::but3): Add menu option for unsigned register format.
@
text
@d4 3
d17 15
d33 5
a37 1
#  CONSTRUCTOR - create new register window
d40 3
a42 3
  global tixOption
  debug
  wm withdraw [winfo toplevel $itk_interior]
d44 8
a51 12
  
  set NormalForeground $tixOption(fg)
  set HighlightForeground [pref get gdb/reg/highlight_fg]
  
  if {[pref getd gdb/reg/menu] != ""} {
    set mbar 0
  }
  
  init_reg_display_vars 1
  build_win
  eval itk_initialize $args    
  
d56 5
a60 1
#  DESTRUCTOR - destroy window containing widget
a63 1
  save_reg_display_vars
d65 177
a241 1
  
d244 8
a251 1
#  METHOD:  build_win - build the main register window
d253 9
a261 10
body RegWin::build_win {} {
  global reg_display tixOption tcl_platform
  
  set dim [dimensions]
  set nRows [lindex $dim 0]
  set nCols [lindex $dim 1]
  if {$tcl_platform(platform) == "windows"} {
    tixScrolledWindow $itk_interior.scrolled -scrollbar both -sizebox 1
  } else {
    tixScrolledWindow $itk_interior.scrolled -scrollbar auto
d263 23
a285 9
  set ScrolledWin [$itk_interior.scrolled subwidget window]
  
  # Calculate the maximum length of a register name
  set regMaxLen 0
  foreach r [gdb_regnames] {
    set l [string length $r]
    if {$l > $regMaxLen} {
      set regMaxLen $l
    }
d287 8
a294 9
  
  # Calculate the minimum size for each column so that the register values fit.
  set row 0
  set col 0
  foreach r $reg_display_list {
    if {$row == 0} {
      # A minimum of 10 so the appearence is nice
      set vmax($col) 10
    }
d296 3
a298 19
    # Typed registers natural values start with a brace (escaped by a slash)
    if {[catch {gdb_fetch_registers {} $r} valtest]} {
      set values($r) ""
    } else {
      if {[string index $valtest 1] == "\{"} {
        # If it is a typed register, we print it raw
        set format r
        set reg_display($r,format) r
        set reg_display($r,typed) 1
        set reg_display($r,editable) 0
      } else {
        set format $reg_display($r,format)
        set reg_display($r,editable) 1
      }
      if {[catch {gdb_fetch_registers $format $r} values($r)]} {
        set values($r) ""
      } else {
        set values($r) [string trim $values($r) \ ]
      }
d301 3
a303 8
    set l [string length $values($r)]
    if {$l > $vmax($col)} {
      set vmax($col) $l
    }
    incr row
    if {$row == $nRows} {
      set row 0
      incr col
d306 4
a309 76
  
  # Create labels
  set row 0
  set col 0
  foreach r $reg_display_list {
    if {$row == $nRows} {
      grid columnconfigure $ScrolledWin $col -weight 1
      set row 0
      incr col
    }
    
    frame $ScrolledWin.$r -takefocus 1
    bind $ScrolledWin.$r <Up> "$this reg_select_up"
    bind $ScrolledWin.$r <Down> "$this reg_select_down"
    bind $ScrolledWin.$r <Tab> "$this reg_select_down"
    bind $ScrolledWin.$r <Left> "$this reg_select_left"
    bind $ScrolledWin.$r <Right> "$this reg_select_right"
    if {![pref get gdb/mode]} {
      bind $ScrolledWin.$r <Return> "$this edit $r"
    }
    
    label $ScrolledWin.$r.lbl -text [fixLength $reg_display($r,name) $regMaxLen left] \
      -relief solid -bd 1 -font src-font 
    label $ScrolledWin.$r.val -anchor e -text [fixLength $values($r) $vmax($col) right] \
      -relief ridge -bd 1 -font src-font -bg $tixOption(input1_bg)
    
    grid $ScrolledWin.$r.lbl $ScrolledWin.$r.val -sticky nsew
    grid columnconfigure $ScrolledWin.$r 1 -weight 1
    grid $ScrolledWin.$r -colum $col -row $row -sticky nsew
    #      grid rowconfigure $ScrolledWin $row -weight 1
    bind $ScrolledWin.$r.val <1> "$this reg_select $r"
    bind $ScrolledWin.$r.lbl <1> "$this reg_select $r"
    bind $ScrolledWin.$r.val <3> "$this but3 $r %X %Y"
    bind $ScrolledWin.$r.lbl <3> "$this but3 $r %X %Y"
    if {![pref get gdb/mode]} {
      bind $ScrolledWin.$r.lbl <Double-1> "$this edit $r"
      bind $ScrolledWin.$r.val <Double-1> "$this edit $r"
    }
    incr row
  }
  grid columnconfigure $ScrolledWin $col -weight 1
  
  
  if { $mbar } {
    menu $itk_interior.m -tearoff 0
    [winfo toplevel $itk_interior] configure -menu $itk_interior.m
    $itk_interior.m add cascade -menu $itk_interior.m.reg -label "Register" -underline 0
    set m [menu $itk_interior.m.reg]
    if {![pref get gdb/mode]} {
      $m add command -label "Edit" -underline 0 -state disabled
    }
    $m add cascade -menu $itk_interior.m.reg.format -label "Format" -underline 0
    set f [menu $itk_interior.m.reg.format]
    $f add radio -label "Hex" -value x -underline 0 -state disabled \
      -command "$this update dummy"
    $f add radio -label "Decimal" -value d -underline 0 -state disabled \
      -command "$this update dummy"
    $f add radio -label "Unsigned" -value u -underline 0 -state disabled \
      -command "$this update dummy"
    $f add radio -label "Natural" -value {} -underline 0 -state disabled \
      -command "$this update dummy"
    $f add radio -label "Binary" -value t -underline 0 -state disabled \
      -command "$this update dummy"
    $f add radio -label "Octal" -value o -underline 0 -state disabled \
      -command "$this update dummy"
    $f add radio -label "Raw" -value r -underline 0 -state disabled \
      -command "$this update dummy"
    $f add radio -label "Floating Point" -value f -underline 0 -state disabled \
      -command "$this update dummy"
    $m add command -label "Remove from Display" -underline 0 -state disabled
    $m add separator
    $m add command -label "Add to Watch" -underline 7 -state disabled
    $m add separator
    $m add command -label "Display All Registers" -underline 0 -state disabled \
			      -command "$this display_all"
    set disp_all_menu_item [$m index last]
d311 3
a313 3
    if {!$all_regs_shown} {
      $m entryconfigure $disp_all_menu_item -state normal
    }
a314 12
  
  set Menu [menu $ScrolledWin.pop -tearoff 0]
  set disabled_fg [$Menu cget -fg]
  $Menu configure -disabledforeground $disabled_fg
  
  # Clear gdb's changed list
  catch {gdb_changed_register_list}
  
  pack $itk_interior.scrolled -anchor nw -fill both -expand yes
  
  window_name "Registers" "Regs"
}
d316 10
a325 11
# ------------------------------------------------------------------------------
# NAME: init_reg_display_vars
# DESC: Initialize the list of registers displayed.
#	args - not used
# RETURNS:
# NOTES:
# ------------------------------------------------------------------------------
body RegWin::init_reg_display_vars {args} {
  global reg_display max_regs
  set reg_display_list {}
  set regnames [gdb_regnames -numbers]
a326 4
  set i 1
  set x 0
  foreach r $regnames {
    incr x
d328 1
a328 2
    set rn   [lindex $r 1]
    set reg_display($rn,name) $name
d332 2
a333 2
    set reg_display($rn,typed) 0
    set reg_display($rn,editable) 0
d336 1
a336 1
    set format [pref getd gdb/reg/$name-format]
d338 1
a338 1
    set reg_display($rn,format) $format
d341 3
a343 3
    if {$args != "" && [pref getd gdb/reg/$name] == "no"} {
      set all_regs_shown 0
      set reg_display($rn,line) 0
d345 44
a388 3
      set reg_display($rn,line) $i
      lappend reg_display_list $rn
      incr i
d392 24
a415 3
  set num_regs [expr {$i - 1}]
  set max_regs $x
  set reg_names_dirty 0
d418 114
a531 5
body RegWin::set_variable {event} {
  switch [$event get variable] {
    disassembly-flavor {
        disassembly_changed
    } 
d533 4
d539 11
a549 2
body RegWin::disassembly_changed {} {
  set reg_names_dirty 1
d551 55
a605 12
# ------------------------------------------------------------------------------
# NAME: save_reg_display_vars
# DESC: save the list of displayed registers to the preferences file.
# ------------------------------------------------------------------------------
body RegWin::save_reg_display_vars {} {
  global reg_display max_regs
  set regnames [gdb_regnames -numbers]
  foreach r $regnames {
    set rn   [lindex $r 1]
    set name $reg_display($rn,name)
    if {$reg_display($rn,line) == 0} {
      pref setd gdb/reg/$name no
d607 19
a625 1
	pref setd gdb/reg/$name {}
d627 1
a627 4
    if {$reg_display($rn,format) != "x"} {
      pref setd gdb/reg/$name-format $reg_display($rn,format)
    } else {
      pref setd gdb/reg/$name-format {}
a629 1
  pref_save ""
d633 5
a637 1
#  PUBLIC METHOD:  reg_select_up
d639 13
a651 8
body RegWin::reg_select_up { } {
  if { $selected == -1 || $Running} {
    return
  }
  set current_index [lsearch -exact $reg_display_list $selected]
  set new_reg [lindex $reg_display_list [expr {$current_index - 1}]]
  if { $new_reg != {} } {
    $this reg_select $new_reg
d656 5
a660 1
#  PUBLIC METHOD:  reg_select_down
d662 16
a677 3
body RegWin::reg_select_down { } {
  if { $selected == -1 || $Running} {
    return
d679 3
a681 4
  set current_index [lsearch -exact $reg_display_list $selected]
  set new_reg [lindex $reg_display_list [expr {$current_index + 1}]]
  if { $new_reg != {} } {
      $this reg_select $new_reg
d686 10
a695 1
#  PUBLIC METHOD:  reg_select_right
d697 18
a714 8
body RegWin::reg_select_right { } {
  if { $selected == -1 || $Running} {
    return
  }
  set current_index [lsearch -exact $reg_display_list $selected]
  set new_reg [lindex $reg_display_list [expr {$current_index + $nRows}]]
  if { $new_reg != {} } {
    $this reg_select $new_reg
d719 31
a749 1
#  PUBLIC METHOD:  reg_select_left
d751 4
a754 2
body RegWin::reg_select_left { } {
  if { $selected == -1 || $Running} {
d757 77
a833 4
  set current_index [lsearch -exact $reg_display_list $selected]
  set new_reg [lindex $reg_display_list [expr {$current_index - $nRows}]]
  if { $new_reg != {} } {
    $this reg_select $new_reg
d838 5
a842 1
#  PUBLIC METHOD:  reg_select - select a register
d844 29
a872 17
body RegWin::reg_select { r } {
  global reg_display tixOption 
  
  if {$Running} { return }
  if {$selected != -1} {
    catch {$ScrolledWin.$selected.lbl configure -fg $tixOption(fg) -bg $tixOption(bg)}
    catch {$ScrolledWin.$selected.val configure -fg $tixOption(fg) \
	     -bg $tixOption(input1_bg)}
  }
  
  # if we click on the same line, unselect it and return
  if {$selected == $r} {
    set selected -1
    $itk_interior.m.reg entryconfigure 0 -state disabled
    $itk_interior.m.reg entryconfigure 2 -state disabled
    for {set i 0} {$i < 8} {incr i} {
      $itk_interior.m.reg.format entryconfigure $i -state disabled
a873 17
    return
  }
  
  if {$Editing != -1} {
    unedit
  }
  
  $ScrolledWin.$r.lbl configure -fg $tixOption(select_fg) -bg $tixOption(select_bg)
  $ScrolledWin.$r.val configure -fg $tixOption(fg) -bg $tixOption(bg)
  
  if {![pref get gdb/mode] && $reg_display($r,editable)} {
    $itk_interior.m.reg entryconfigure 0 -state normal -command "$this edit $r"
  }
  $itk_interior.m.reg entryconfigure 2 -state normal \
    -command "$this delete_from_display_list $r"
  if {$reg_display($r,typed)} {
    set state disabled
d875 16
a890 6
    set state normal
  }
  for {set i 0} {$i < 8} {incr i} {
    debug "format $i $state"
    $itk_interior.m.reg.format entryconfigure $i -state $state \
      -variable reg_display($r,format)
a891 4
  $itk_interior.m.reg entryconfigure 4 -state normal \
    -command "$this addToWatch $r"
  focus -force $ScrolledWin.$r
  set selected $r
d895 7
a901 2
# PRIVATE METHOD:  dimensions - determine square-like dimensions for
#          register window
d903 2
a904 6
body RegWin::dimensions {} {
  set rows [pref get gdb/reg/rows]
  #    set rows [expr int(floor(sqrt($num_regs)))]
  set cols [expr {int(ceil(sqrt($num_regs)))}]
  
  return [list $rows $cols]
d907 22
a928 31
# ------------------------------------------------------------------------------
# NAME: 
#	private method RegWin::fixLength
#
# SYNOPSIS:
#	fixLength {s size where}
#	
# DESC: 
#	Makes a string into a fixed-length string, inserting spaces as
#	necessary. If 'where' is "left" spaces will be added to the left,
#	if 'where' is "right" spaces will be added to the right.
# ARGS:
#	s - input string
#	size - size of string to output
#	where - "left" or "right"
#
# RETURNS: 
#	Padded string of length 'size'
#
# NOTES: 
#	This should really be a proc, not a method.
# ------------------------------------------------------------------------------
body RegWin::fixLength {s size where} {
  set blank "                                                                   "
  set len [string length $s]
  set bl  [expr {$size - $len}]
  set b [string range $blank 0 $bl]
  
  switch $where {
    left  { set fl "$s$b"}
    right { set fl "$b$s"}
d930 11
a940 1
  return $fl
d944 5
a948 2
#  PUBLIC METHOD:  but3 - generate and display a popup window on button 3 
#  over the register value
d950 9
a958 71
body RegWin::but3 {rn X Y} {
  global reg_display max_regs
  
  if {!$Running} {
    $Menu delete 0 end
    $Menu add command -label $reg_display($rn,name) -state disabled
    $Menu add separator
    if {!$reg_display($rn,typed)} {
      $Menu add radio -label "Hex" -command "$this update dummy" \
        -value x -variable reg_display($rn,format)
      $Menu add radio -label "Decimal" -command "$this update dummy" \
        -value d -variable reg_display($rn,format)
      $Menu add radio -label "Unsigned" -command "$this update dummy" \
        -value u -variable reg_display($rn,format)
      $Menu add radio -label "Natural" -command "$this update dummy" \
        -value {} -variable reg_display($rn,format)
      $Menu add radio -label "Binary" -command "$this update dummy" \
        -value t -variable reg_display($rn,format) -underline 0
      $Menu add radio -label "Octal" -command "$this update dummy" \
        -value o -variable reg_display($rn,format)
      $Menu add radio -label "Raw" -command "$this update dummy" \
        -value r -variable reg_display($rn,format)
      $Menu add radio -label "Floating Point" -command "$this update dummy" \
        -value f -variable reg_display($rn,format)
      $Menu add separator
    }
    $Menu add command  -command "$this addToWatch $rn" \
      -label "Add $reg_display($rn,name) to Watch"
    $Menu add separator
    $Menu add command  -command "$this delete_from_display_list $rn" \
      -label "Remove $reg_display($rn,name) from Display"
    if {$max_regs != $num_regs} {
      $Menu add separator
      $Menu add command -command "$this display_all" \
	-label "Display all registers"
    }
    tk_popup $Menu $X $Y
  }
}

# ------------------------------------------------------------------
#  PUBLIC METHOD:  display_all - add all registers to the display list
# ------------------------------------------------------------------
body RegWin::display_all {} {
  init_reg_display_vars
  $itk_interior.m.reg entryconfigure $disp_all_menu_item -state disabled
  set all_regs_shown 1
  reconfig
}

# ------------------------------------------------------------------
#  PUBLIC METHOD:  delete_from_display_list - remove a register from the
#  display list
# ------------------------------------------------------------------
body RegWin::delete_from_display_list {rn} {
  global reg_display max_regs
  set reg_display($rn,line) 0
  set reg_display_list {}
  set regnames [gdb_regnames -numbers]
  set i 0
  foreach r $regnames {
    set rnx [lindex $r 1]
    if {$reg_display($rnx,line) > 0} {
      lappend reg_display_list $rnx
      incr i
      set reg_display($rnx,line) $i
    }
  }
  set num_regs $i
  reconfig
  $itk_interior.m.reg entryconfigure 6 -state normal
d961 3
d965 34
d1000 1
a1000 21
# ------------------------------------------------------------------
#  PUBLIC METHOD:  edit - edit a cell
# ------------------------------------------------------------------
body RegWin::edit {r} {
  global reg_display
  if {$Running} { return }
  if {!$reg_display($r,editable)} {return}
  unedit
  
  set Editing $r
  set txt [$ScrolledWin.$r.val cget -text]
  set len [string length $txt]
  set entry [entry $ScrolledWin.$r.ent -width $len -bd 0 -font src-font]
  $entry insert 0 $txt
  
  grid remove $ScrolledWin.$r.val
  grid $entry -row 0 -col 1
  bind $entry <Return> "$this acceptEdit $r"
  bind $entry <Escape> "$this unedit"
  $entry selection to end
  focus $entry    
d1004 7
a1010 2
# PUBLIC METHOD:  acceptEdit - callback invoked when enter key pressed
#          in an editing entry
d1012 6
a1017 13
body RegWin::acceptEdit {r} {
  global reg_display
  
  set value [string trimleft [$ScrolledWin.$r.ent get]]
  debug "value=${value}="
  if {$value == ""} {
    set value 0
  }
  if {[catch {gdb_cmd "set \$$reg_display($r,name)=$value"} result]} {
    tk_messageBox -icon error -type ok -message $result \
      -title "Error in Expression" -parent [winfo toplevel $itk_interior]
    focus $ScrolledWin.$r.ent
    $ScrolledWin.$r.ent selection to end
d1019 1
a1019 2
    unedit
    gdbtk_update
d1021 8
d1032 7
a1038 1
# PUBLIC METHOD:  addToWatch - add a register to the watch window
d1040 3
a1042 3
body RegWin::addToWatch {reg} {
  global reg_display
  [ManagedWin::open WatchWin] add "\$$reg_display($reg,name)"
d1045 5
d1051 5
a1055 1
# PUBLIC METHOD:  unedit - clear any editing entry on the screen
d1057 9
a1065 10
body RegWin::unedit {} {
  if {$Editing != -1} {
    destroy $ScrolledWin.$Editing.ent
    
    # Fill the entry with the old label, updating value
    grid $ScrolledWin.$Editing.val -column 1 -row 0
    focus -force $ScrolledWin.$Editing
    set Editing -1
    update dummy
  }
d1069 5
a1073 1
#  PRIVATE METHOD:  update - update widget when PC changes
d1075 6
a1080 6
body RegWin::update {event} {
  global reg_display
  debug "START REGISTER UPDATE CALLBACK"
  if {$reg_display_list == ""
      || [catch {eval gdb_changed_register_list $reg_display_list} changed_reg_list]} {
    set changed_reg_list {}
a1081 8
  
  set row 0
  set col 0
  foreach r $reg_display_list {
    if {$row == 0} {
      # A minimum of 10 so the appearence is nice
      set vmax($col) 10
    }
d1083 2
a1084 20
    # Typed registers natural values start with a brace (escaped by a slash)
    if {[catch {gdb_fetch_registers {} $r} valtest]} {
      set values($r) ""
    } else {
      if {[string index $valtest 1] == "\{"} {
        # If it is a typed register, we print it raw
        set format r
        set reg_display($r,format) r
        set reg_display($r,typed) 1
        set reg_display($r,editable) 0
      } else {
        set format $reg_display($r,format)
        set reg_display($r,editable) 1
      }
      if {[catch {gdb_fetch_registers $format $r} values($r)]} {
        set values($r) ""
      } else {
        set values($r) [string trim $values($r) \ ]
      }
    }
d1086 2
a1087 28
    set l [string length $values($r)]
    if {$l > $vmax($col)} {
      set vmax($col) $l
    }
    incr row
    if {$row == $nRows} {
      set row 0
      incr col
    }
  }
  
  set row 0
  set col 0
  foreach r $reg_display_list {
    if {[lsearch -exact $changed_reg_list $r] != -1} {
      set fg $HighlightForeground
    } else {
      set fg $NormalForeground
    }
    $ScrolledWin.$r.val configure -text [fixLength $values($r) $vmax($col) right] \
      -fg $fg
    incr row
    if {$row == $nRows} {
      set row 0
      incr col
    }
  }
  debug "END REGISTER UPDATE CALLBACK" 
d1090 7
d1098 6
a1103 2
  [winfo toplevel $itk_interior] configure -cursor {}
  set Running 0
d1107 5
a1111 1
#  PRIVATE METHOD:  reconfig - used when preferences change
d1113 5
a1117 3
body RegWin::reconfig {} {
  if {$reg_names_dirty} {
    init_reg_display_vars
a1118 4
  destroy $Menu $itk_interior.g $itk_interior.scrolled $itk_interior.m
  gdbtk_busy
  build_win
  gdbtk_idle
d1120 1
a1120 1
  
d1122 5
a1126 1
#  PUBLIC METHOD:  busy - BusyEvent handler
d1128 46
a1173 9
body RegWin::busy {event} {
  # Cancel edits
  unedit
  
  # Fencepost
  set Running 1
  
  # cursor
  [winfo toplevel $itk_interior] configure -cursor watch
@


1.12
log
@	* library/interface.tcl (gdb_update_hook): Mark as deprecated.
	(gdbtk_update): Dispatch and UpdateEvent, too.
	* library/ehandler.ith (update): New event handler.
	* library/gdbevent.ith (UpdateEvent): New event.
	* library/gdbevent.itb (UpdateEvent::constructor): New method.
	(UpdateEvent::get): New method.
	* library/kod.ith (udpate): Match event handler definition.
	* library/kod.itb (update): Ditto.
	(build_win): Pass dummy argument to update method.
	(top): Ditto.
	(up): Ditto.
	(set_variable): Ditto.
	* library/memwin.ith (update): Match event handler definition.
	* library/memwin.itb (update): Ditto.
	(constructor): Remove gdb_update_hook.
	(destructor): Ditto.
	* library/process.ith (update): Match event handler definition.
	* library/process.itb (update): Ditto.
	(constructor): Remove gdb_update_hook.
	(destructor): Ditto.
	(build_win): Pass dummy argument to update method.
	* library/regwin.ith (update): Match event handler definition.
	* library/regwin.itb (update): Ditto.
	(constructor): Remove gdb_update_hook.
	(destructor): Ditto.
	(build_win): Pass dummy argument to update method.
	(but3): Ditto.
	(unedit): Ditto.
	* library/stackwin.ith (update): Match event handler definition.
	* library/stackwin.itb (update): Ditto.
	(constructor): Remove gdb_update_hook.
	(destructor): Ditto.
	(build_win): Pass dummy argument to update method.
	* library/tdump.tcl (update): Match event handler definition.
	(constructor): Remove gdb_update_hook.
	(destructor): Ditto.
	(build_win): Pass dummy argument to update method.
	* library/variables.tcl (update): Match event handler definition.
	(build_win): Pass dummy argument to update method.
	* library/locals.tcl (update): Match event handler definition.
	(constructor): Pass dummy argument to update method.
	* library/watch.tcl (update): Match event handler definition.
	Pass dummy argument to VariableWin::update.
	(add): Pass dummy argument to update method.
	* library/srcwin.ith (update): New method.
	(update_hook_init): Remove.
	* library/srcwin.itb (update): New method.
	(constructor): Remove gdb_update_hook.
	(destructor): Ditto.
	* tclIndex: Regenerate.
@
text
@d168 2
d360 1
a360 1
    for {set i 0} {$i < 7} {incr i} {
d383 1
a383 1
  for {set i 0} {$i < 7} {incr i} {
d457 2
@


1.11
log
@	* library/interface.tcl (gdb_idle_hook): Mark as deprecated.
	(gdbtk_idle): Dispatch an IdleEvent. gdb_idle_hook is gone.
	* library/ehandler.ith (idle): New event handler.
	* library/gdbevent.ith (IdleEvent): New event.
	* library/console.ith (idle): Match event handler definition.
	* library/console.itb (idle): Ditto.
	(constructor): Remove gdb_idle_hook.
	(destructor): Ditto.
	* library/kod.ith (idle): Match event handler definition.
	* library/kod.itb (idle): Ditto.
	(constructor): Remove gdb_idle_hook.
	(destructor): Ditto.
	* library/memwin.ith (idle): Match event handler definition.
	* library/memwin.itb (idle): Ditto.
	(constructor): Remove gdb_idle_hook.
	(destructor): Ditto.
	* library/pluginwin.itcl (stopped): Rename to "idle" and
	match event handler definition.
	Fix misleading comments.
	* library/process.ith (idle): Match event handler definition.
	* library/process.itb (idle): Ditto.
	(constructor): Remove gdb_idle_hook.
	(destructor): Ditto.
	* library/regwin.ith (idle): Match event handler definition.
	* library/regwin.itb (idle): Ditto.
	(constructor): Remove gdb_idle_hook.
	(destructor): Ditto.
	* library/srcbar.itcl (idle): New method.
	(constructor): Remove gdb_idle_hook.
	(destructor): Ditto.
	* library/srcwin.ith (idle): Match event handler definition.
	* library/srcwin.itb (idle): Ditto.
	(constructor): Remove gdb_idle_hook.
	(destructor): Ditto.
	* library/stackwin.ith (idle): Match event handler definition.
	* library/stackwin.itb (idle): Ditto.
	(constructor): Remove gdb_idle_hook.
	(destructor): Ditto.
	* library/variables.tcl (idle): Match event handler definition.
	(constructor): Remove gdb_idle_hook.
	(destructor): Ditto.
	* library/plugins/rhabout/rhabout.itcl (stopped): Rename
	to "idle" and match new event handler definition.
	* library/tclIndex: Regenerated.
@
text
@a34 1
  add_hook gdb_update_hook "$this update"
a42 1
  remove_hook gdb_update_hook "$this update"
d165 1
a165 1
      -command "$this update"
d167 1
a167 1
      -command "$this update"
d169 1
a169 1
      -command "$this update"
d171 1
a171 1
      -command "$this update"
d173 1
a173 1
      -command "$this update"
d175 1
a175 1
      -command "$this update"
d177 1
a177 1
      -command "$this update"
d451 1
a451 1
      $Menu add radio -label "Hex" -command "$this update" \
d453 1
a453 1
      $Menu add radio -label "Decimal" -command "$this update" \
d455 1
a455 1
      $Menu add radio -label "Natural" -command "$this update" \
d457 1
a457 1
      $Menu add radio -label "Binary" -command "$this update" \
d459 1
a459 1
      $Menu add radio -label "Octal" -command "$this update" \
d461 1
a461 1
      $Menu add radio -label "Raw" -command "$this update" \
d463 1
a463 1
      $Menu add radio -label "Floating Point" -command "$this update" \
d581 1
a581 1
    update
d588 1
a588 1
body RegWin::update {} {
@


1.10
log
@	* library/interface.tcl (gdb_busy_hook): Deprecate.
	(gdbtk_busy): Create and dispatch a BusyEvent instead
	of running hooks.
	* library/ehandler.ith (busy): New event handler.
	* library/gdbevent.ith (BusyEvent): New event class.
	* library/console.ith: Inherit from GDBEventHandler.
	(busy): Match event handler definition.
	* library/console.itb (busy): Ditto.
	(constructor): Remove gdb_busy_event.
	(destructor): Ditto.
	* library/kod.ith (busy): Match event handler definition.
	* library/kod.itb (busy): Ditto.
	(constructor): Remove gdb_busy_hook.
	(destructor): Ditto.
	* library/memwin.ith (busy): Match event handler definition.
	* library/memwin.itb (busy): Ditto.
	(constructor): Remove gdb_busy_hook.
	(destructor): Ditto.
	* library/pluginwin.itcl (running): Rename to "busy" and
	match event handler definition.
	(consturctor): Remove gdb_busy_hook.
	(destructor): Ditto.
	* library/process.ith (busy): Match event handler definition.
	* library/process.itb (busy): Ditto.
	(constructor): Remove gdb_busy_hook.
	(destructor): Ditto.
	* library/regwin.ith (busy): Match event handler definition.
	* library/regwin.itb (busy): Ditto.
	(constructor): Remove gdb_busy_hook.
	(destructor): Ditto.
	* library/srcbar.itcl (constructor): Remove gdb_busy_hook.
	(destructor): Ditto.
	(busy): New method.
	* library/srcwin.ith (busy): Match event handler definition.
	* library/srcwin.itb (busy): Ditto.
	Only do the "busy" stuff if do_updates is set.
	(toggle_updates): Remove gdb_busy_hook.
	(constructor): Ditto.
	(destructor): Ditto.
	* library/stackwin.ith (busy): Match event handler definition.
	* library/stackwin.itb (busy): Ditto.
	(constructor): Remove gdb_busy_hook.
	(destructor): Ditto.
	* library/variables.tcl (constructor): Ditto.
	(destructor): Ditto.
	(disable_ui): Rename to "busy" and match event handler
	definition.
	* library/plugins/rhabout/rhabout.itcl (running): Rename
	to "busy" and match new event handler definition.
	* library/tclIndex: Regenerated.
@
text
@a35 1
  add_hook gdb_idle_hook [list $this idle]
a44 1
  remove_hook gdb_idle_hook [list $this idle]
d657 1
a657 1
body RegWin::idle {} {
@


1.9
log
@Other half of SetVariableEvent:

	* library/srctextwin.ith (handle_set_hook): Rename to set_variable.
	* library/srctextwin.itb (set_variable): Handle SetVariableEvent.
	(constructor): Remove gdb_set_hook.
	(destructor): Ditto.
	* library/srcbar.itcl: Inherit from GDBEventHandler.
	(set_hook): Rename to set_variable and handle SetVariableEvent.
	(constructor): Remove gdb_set_hook.
	(destructor): Ditto.
	* library/regwin.ith (handle_set_hook): Renamed to set_variable.
	* library/regwin.itb (set_variable): Handle SetVariableEvent.
	(constructor): Remove gdb_set_hook.
	(destructor): Ditto.
	* library/kod.ith (set_os): Renamed to "set_variable".
	* library/kod.itb (set_variable): Handle SetVariableEvent.
	(constructor): Remove gdb_set_hook.
	(destructor): Ditto.
	* library/tclIndex: Regenerated.
@
text
@a35 1
  add_hook gdb_busy_hook [list $this busy]
a45 1
  remove_hook gdb_busy_hook [list $this busy]
d678 1
a678 1
#  PRIVATE METHOD:  busy - gdb_busy_hook
d680 1
a680 1
body RegWin::busy {} {
@


1.8
log
@2001-02-08  Fernando Nasser  <fnasser@@redhat.com>

	From 2001-02-06  Martin Hunt  <hunt@@redhat.com>
	* library/debugwin.itb: Change window name to "Insight Debug"
	* library/embeddedwin.ith: Fix debug messages.
	* library/locals.tcl: Ditto.
	* library/watch.tcl (postMenu): Ditto.
	* library/variables.tcl: Ditto.
	* library/interface.tcl: Ditto.
	* library/regwin.itb: Ditto.
	* library/gdbwin.ith: Ditto.
	* library/srcbar.itcl: Ditto.
@
text
@d2 1
a2 1
# Copyright 1998, 1999, 2001 Red Hat
a37 3
  if {[get_disassembly_flavor] != ""} {
    add_hook gdb_set_hook [code $this handle_set_hook]
  }
a48 3
  if {[get_disassembly_flavor] != ""} {
    remove_hook gdb_set_hook [code $this handle_set_hook]
  }
d255 2
a256 2
body RegWin::handle_set_hook {var value} {
  switch $var {
@


1.7
log
@

Added "Floating Point" as a display format option for registers
@
text
@d1 2
a2 2
# Register display window for GDBtk.
# Copyright 1998, 1999 Cygnus Solutions
d19 1
a19 1
  debug "RegWin::constructor"
d47 1
a47 1
  debug "RegWin::destructor"
d394 1
a394 1
    debug "RegWin format $i $state"
@


1.6
log
@2000-05-04  Fernando Nasser  <fnasser@@cygnus.com>

	* regwin.itb (build_win, update): Safer test for editable.
@
text
@d188 2
d370 1
a370 1
    for {set i 0} {$i < 6} {incr i} {
d393 1
a393 1
  for {set i 0} {$i < 6} {incr i} {
d475 2
@


1.5
log
@2000-05-01  Fernando Nasser  <fnasser@@cygnus.com>

	* regwin.itb (build_win): Adjust size of columns independently, force
	typed registers to raw mode and check if values can be edited.
	Also, add "Add to Watch" option to the menu.
	(update): Similar changes to similar code.
	(init_reg_display_vars): Initialize new variables used above.
	(reg_select): Deactivate menu options when action is not possible.
	(but3): Ditto.
	(edit): Do not edit if it is not editable.
	(acceptEdit): Fix bug is error message box display.
	(addToWatch): New mwthod.  Add a register to the Watch window.
	* regwin.ith: Add addToWatch to the class.
	* tclIndex: Regenerate.
@
text
@d101 1
d104 1
a112 12
    # Check if we can edit this value
    if {[catch {gdb_cmd "set \$$reg_display($r,name)=$valtest"} rst]} {
      set reg_display($r,editable) 0
    } else {
      set reg_display($r,editable) 1
    }
    catch {gdb_fetch_registers {} $r} valtest2
    if {$valtest2 != $valtest} {
      tk_messageBox -icon error -type ok -message "Register value clobbered!" \
        -title "Internal Error" -parent [winfo toplevel $itk_interior]
    }

d621 1
d624 1
a630 13
    }

    # Check if we can edit this value
    if {[catch {gdb_cmd "set \$$reg_display($r,name)=$valtest"} rst]} {
      set reg_display($r,editable) 0
    } else {
      set reg_display($r,editable) 1
    }
    # Make sure we did not changed the original value with the test above
    catch {gdb_fetch_registers {} $r} valtest2
    if {$valtest2 != $valtest} {
      tk_messageBox -icon error -type ok -message "Register value clobbered!" \
        -title "Internal Error" -parent [winfo toplevel $itk_interior]
@


1.4
log
@2000-04-05  James Ingham  <jingham@@leda.cygnus.com>

	* regwin.itb (RegWin::build_win): Enable the "Display all
	registers" menu at startup if any registers have been removed.
	(RegWin::save_reg_display_vars): Handle cases where the register
	set is not contiguous.
	(RegWin::destructor): Actually save away the removed registers.
	The latter two are Steve Johnson's change.

	* regwin.ith (RegWin): Added "all_regs_shown" and
	"disp_all_menu_item" to handle tracking whether any registers have
	been removed from the display.
@
text
@a72 3
  # Create labels
  set row 0
  set col 0
d74 1
d83 3
a85 1
  set vmax 0
d87 7
a93 1
    if {[catch {gdb_fetch_registers $reg_display($r,format) $r} values($r)]} {
d96 20
a115 1
      set values($r) [string trim $values($r) \ ]
d117 6
d124 7
a130 2
    if {$l > $vmax} {
      set vmax $l
d134 3
d156 1
a156 1
    label $ScrolledWin.$r.val -anchor e -text [fixLength $values($r) $vmax right] \
d200 2
d234 1
d242 7
d252 2
d263 1
d364 1
a364 1
  global tixOption 
d391 1
a391 1
  if {![pref get gdb/mode]} {
d396 5
d402 2
a403 1
    $itk_interior.m.reg.format entryconfigure $i -state normal \
d406 2
d470 17
a486 12
    $Menu add radio -label "Hex" -command "$this update" \
      -value x -variable reg_display($rn,format)
    $Menu add radio -label "Decimal" -command "$this update" \
      -value d -variable reg_display($rn,format)
    $Menu add radio -label "Natural" -command "$this update" \
      -value {} -variable reg_display($rn,format)
    $Menu add radio -label "Binary" -command "$this update" \
      -value t -variable reg_display($rn,format) -underline 0
    $Menu add radio -label "Octal" -command "$this update" \
      -value o -variable reg_display($rn,format)
    $Menu add radio -label "Raw" -command "$this update" \
      -value r -variable reg_display($rn,format)
d529 1
a529 1
  $itk_interior.m.reg entryconfigure 4 -state normal
d540 1
d571 1
a571 1
      -title "Error in Expression" -parent $this
d581 8
d614 2
a615 1
  set vmax 0
d617 7
a623 1
    if {[catch {gdb_fetch_registers $reg_display($r,format) $r} values($r)]} {
d626 20
a645 1
      set values($r) [string trim $values($r) \ ]
d647 7
d655 7
a661 2
    if {$l > $vmax} {
      set vmax $l
d665 2
d673 1
a673 1
    $ScrolledWin.$r.val configure -text [fixLength $values($r) $vmax right] \
d675 5
@


1.3
log
@2000-04-03  Steve Johnson  <sbjohnson@@ozemail.com.au>

	* regwin.itb (dimensions): Use rows from preference file rather
	than hard-coding a preference.
	* prefs.tcl (pref_set_defaults): Add gdb/reg/rows preference.
@
text
@a13 1

d48 1
a57 1

d162 6
a167 1
      -command "$this display_all"
d194 1
d196 1
d204 1
d213 1
a213 1
  set max_regs $rn
d234 3
a236 2
  set rn 0
  while {$rn < $max_regs} {
a247 1
    incr rn
d439 2
a440 1
  $itk_interior.m.reg entryconfigure 4 -state disabled
d452 1
a452 1
  set rn 0
d454 4
a457 3
  while {$rn < $max_regs} {
    if {$reg_display($rn,line) > 0} {
      lappend reg_display_list $rn
d459 1
a459 1
      set reg_display($rn,line) $i
a460 1
    incr rn
d466 2
@


1.2
log
@Handle the fact that there are holes in the register numbering.
* regwin.itb (RegWin::init_reg_display_vars): Ask gdb_regnames to
provide the register numbers, too; don't just assume that the Nth
element is register N.
@
text
@d350 1
a350 1
  set rows 16
@


1.1
log
@Initial revision
@
text
@d188 1
a188 1
  set regnames [gdb_regnames]
a189 1
  set rn 0
d191 4
a194 2
    set reg_display($rn,name) $r
    set format [pref getd gdb/reg/$r-format]
d197 1
a197 1
    if {$args != "" && [pref getd gdb/reg/$r] == "no"} {
a203 1
    incr rn
@


1.1.1.1
log
@import insight-2000-02-04 snapshot (2nd try)
@
text
@@
