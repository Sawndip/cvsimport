head	1.7;
access;
symbols
	insight_7_6-2013-04-10-branchpoint:1.7
	gdb_7_6-branch:1.7.0.22
	gdb_7_5-branch:1.7.0.20
	gdb_7_4-branch:1.7.0.18
	gdb_7_3-branch:1.7.0.16
	gdb_7_1-branch:1.7.0.14
	gdb_7_0-branch:1.7.0.12
	arc-sim-20090309:1.7
	arc-insight_6_8-branch:1.7.0.10
	arc-insight_6_8-branchpoint:1.7
	insight_6_8-branch:1.7.0.8
	insight_6_8-branchpoint:1.7
	gdb_6_8-branch:1.7.0.6
	insight_6_6-20070208-release:1.7
	gdb_6_6-branch:1.7.0.4
	gdb_6_6-2006-11-15-branchpoint:1.7
	insight_6_5-20061003-release:1.7
	gdb_6_5-branch:1.7.0.2
	gdb_6_5-2006-05-14-branchpoint:1.7
	gdb-csl-gxxpro-6_3-branch:1.6.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.6
	gdb_6_4-branch:1.6.0.6
	gdb_6_4-2005-11-01-branchpoint:1.6
	gdb_6_1-2004-04-05-release:1.6
	gdb_6_1-branch:1.6.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.6
	gdb_6_0-2003-10-04-release:1.6
	gdb_6_0-branch:1.6.0.2
	gdb_6_0-2003-06-23-branchpoint:1.6
	gdb_5_3-2002-12-12-release:1.5
	gdb_5_3-branch:1.5.0.4
	gdb_5_3-2002-09-04-branchpoint:1.5
	gdb_5_2_1-2002-07-23-release:1.5
	gdb_5_2-2002-04-29-release:1.5
	gdb_5_2-branch:1.5.0.2
	gdb_5_2-2002-03-03-branchpoint:1.5
	gdb_5_1_1-2002-01-24-release:1.4
	cygnus_cvs_20020108_pre:1.5
	gdb_5_1_0_1-2002-01-03-branch:1.4.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.4
	gdb_5_1-2001-11-21-release:1.4
	gdb_s390-2001-09-26-branch:1.4.0.6
	gdb_s390-2001-09-26-branchpoint:1.4
	gdb_5_1-2001-07-29-branch:1.4.0.4
	gdb_5_1-2001-07-29-branchpoint:1.4
	dberlin-typesystem-branch:1.4.0.2
	dberlin-typesystem-branchpoint:1.4;
locks; strict;
comment	@# @;


1.7
date	2005.12.23.18.26.50;	author eliz;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.15.21.19.51;	author hunt;	state Exp;
branches;
next	1.5;

1.5
date	2001.10.11.06.14.05;	author irox;	state Exp;
branches;
next	1.4;

1.4
date	2001.02.01.22.56.27;	author fnasser;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.28.18.06.29;	author fnasser;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.04.17.27.02;	author fnasser;	state Exp;
branches;
next	1.1;

1.1
date	2001.01.03.05.34.04;	author fnasser;	state Exp;
branches;
next	;


desc
@@


1.7
log
@	* library/attachdlg.itb:
	* library/actiondlg.tcl:
	* library/about.tcl:
	* library/ehandler.itb:
	* library/editor.tcl:
	* library/download.ith:
	* library/download.itb:
	* library/debugwin.ith:
	* library/debugwin.itb:
	* library/cspref.ith:
	* library/cspref.itb:
	* library/console.ith:
	* library/console.itb:
	* library/browserwin.ith:
	* library/browserwin.itb:
	* library/bpwin.ith:
	* library/bpwin.itb:
	* library/blockframe.ith:
	* library/managedwin.ith:
	* library/managedwin.itb:
	* library/main.tcl:
	* library/locals.tcl:
	* library/ipcpref.ith:
	* library/ipcpref.itb:
	* library/ipc.tcl:
	* library/interface.tcl:
	* library/helpviewer.tcl:
	* library/globalpref.ith:
	* library/globalpref.itb:
	* library/gdbwin.ith:
	* library/gdbtoolbar.itcl:
	* library/gdbmenubar.itcl:
	* library/gdbevent.ith:
	* library/gdbevent.itb:
	* library/embeddedwin.ith:
	* library/ehandler.ith:
	* library/srcwin.itb:
	* library/srctextwin.ith:
	* library/srctextwin.itb:
	* library/srcpref.ith:
	* library/srcpref.itb:
	* library/srcbar.itcl:
	* library/session.tcl:
	* library/regwin.ith:
	* library/regwin.itb:
	* library/process.ith:
	* library/process.itb:
	* library/prefs.tcl:
	* library/pluginwin.itcl:
	* library/modal.tcl:
	* library/memwin.ith:
	* library/memwin.itb:
	* library/mempref.ith:
	* library/mempref.itb:
	* library/watch.tcl:
	* library/watch.tcl:
	* library/warning.tcl:
	* library/vartree.ith:
	* library/vartree.itb:
	* library/util.tcl:
	* library/tracedlg.tcl:
	* library/toplevelwin.ith:
	* library/tfind_args.tcl:
	* library/tdump.tcl:
	* library/targetselection.ith:
	* library/targetselection.itb:
	* library/stackwin.ith:
	* library/stackwin.itb:
	* library/srcwin.ith:
@
text
@# GDBToolBar
# Copyright (C) 2000 Red Hat, Inc.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License (GPL) as published by
# the Free Software Foundation; either version 2 of the License, or (at
# your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# ----------------------------------------------------------------------
# Implements a toolbar.
#
#   PUBLIC ATTRIBUTES:
#
#
#   METHODS:
#
#     configure ....... used to change public attributes
#
#   PRIVATE METHODS
#
#   X11 OPTION DATABASE ATTRIBUTES
#
#
# ----------------------------------------------------------------------

itcl::class GDBToolBar {
  inherit itk::Widget

  # ------------------------------------------------------------------
  #  CONSTRUCTOR - create widget
  # ------------------------------------------------------------------
  constructor {args} {

    # Make a subframe so that the menu can't accidentally conflict
    # with a name created by some subclass.
    set ButtonFrame [frame $itk_interior.t]

    pack $ButtonFrame $itk_interior -fill both -expand true

    eval itk_initialize $args
  }

  # ------------------------------------------------------------------
  #  DESTRUCTOR - destroy window containing widget
  # ------------------------------------------------------------------
  destructor {

    #destroy $this
  }

  # ------------------------------------------------------------------
  #  METHOD:  show - show the toolbar
  # ------------------------------------------------------------------
  public method show {} {

    if {[llength $button_list]} {
      eval standard_toolbar $ButtonFrame $button_list
    }
  }

  # ------------------------------------------------------------------
  #  METHOD:  set_class_state - standard method to control state by class
  # ------------------------------------------------------------------
  public method set_class_state {enable_list} {
    debug "Enable list is: $enable_list"

    foreach {type state} $enable_list {
      # debug $type
      if {[info exists button_classes($type)]} {
        set class_list $button_classes($type)
        if {[llength $class_list]} {
          # debug "$type $state \{$class_list\}"
	  foreach button $class_list {
            # debug "$type $button $state"
	    itemconfigure $button -state $state
	  }
        }
      }
    }
  }

  ####################################################################
  # Methods that deal with buttons.
  ####################################################################

  # ------------------------------------------------------------------
  #  METHOD:  add - Add something.
  #                 It can be a button a separator or a label.
  #
  #  type - what we want to add
  #  args - arguments appropriate to what is being added
  #
  # ------------------------------------------------------------------
  method add {type args} {

    switch $type {
      button {
        eval toolbar_add_button $args
      }
      label {
        eval toolbar_add_label $args
      }
      separator {
        toolbar_add_button_separator
      }
      custom {
        eval toolbar_add_custom $args
      }
      default {
        error "Invalid item type: $type"
      }
    }
  }

  # ------------------------------------------------------------------
  #  PRIVATE METHOD:  toolbar_add_button - Creates a button, and inserts
  #                      it at the end of the button list.  Call this when
  #                      the toolbar is being set up, but has not yet been
  #                      made.
  # ------------------------------------------------------------------
  private method toolbar_add_button {name class command balloon args} {
    
    lappend button_list \
            [eval _register_button 1 \$name \$class \$command \$balloon $args]
    
  }

  # ------------------------------------------------------------------
  #  PRIVATE METHOD:  toolbar_add_label - Create a label to be inserted
  #                        in the toolbar.
  # ------------------------------------------------------------------

  private method toolbar_add_label {name text balloon args} {
    set lname $ButtonFrame.$name
    set Buttons($name) $lname
    set Buttons($lname,align) $button_align
    eval label $lname -text \$text $args
    balloon register $lname $balloon
    lappend button_list $lname    
  }

  # ------------------------------------------------------------------
  #  PRIVATE METHOD:  toolbar_add_custom - Create a user defined widget
  #                   to be inserted in the toolbar.
  # ------------------------------------------------------------------

  private method toolbar_add_custom {name createCmd balloon args} {
    set wname $ButtonFrame.$name
    set Buttons($name) $wname
    set Buttons($wname,align) $button_align

    eval $createCmd $wname $args
    balloon register $wname $balloon

    lappend button_list $wname
  }

  # ------------------------------------------------------------------
  #  PRIVATE METHOD:  toolbar_add_button_separator - 
  # ------------------------------------------------------------------

  private method toolbar_add_button_separator {} {
    lappend button_list -
  }
 
  # ------------------------------------------------------------------
  #  PRIVATE METHOD:  _register_button - Creates all the bookkeeping
  #           for a button,  without actually inserting it in the toolbar.
  #           If the button will not be immediately inserted (INS == 0),
  #           sets its bindings and appearences to the same of a
  #           standard_toolbar button.
  # ------------------------------------------------------------------
  private method _register_button {ins name class command balloon args} {
    set bname $ButtonFrame.$name
    set Buttons($name) $bname
    set Buttons($bname,align) $button_align

    eval button $bname -command \$command $args
    balloon register $bname $balloon
    foreach elem $class {
      switch $elem {
	None {}
	default { 
	  lappend button_classes($elem) $name
	}
      }
    }

   # If the button is not going to be inserted now...
   if {! $ins} {
     # This is a bit of a hack, but I need to bind the standard_toolbar bindings
     # and appearances to these externally, since I am not inserting them in 
     # the original toolbar...
     # FIXME:  Have to add a method to the libgui toolbar to do this.

     # Make sure the button acts the way we want, not the default Tk way.
     $bname configure -takefocus 0 -highlightthickness 0 \
                      -relief flat -borderwidth 1	
     set index [lsearch -exact [bindtags $bname] Button]
     bindtags $bname [lreplace [bindtags $bname] $index $index ToolbarButton]
    }

    return $bname
  }
 
  # ------------------------------------------------------------------
  #  METHOD:  create - Creates all the bookkeeping for a button,
  #           without actually inserting it in the toolbar.
  # ------------------------------------------------------------------
  method create {name class command balloon args} {

    return [eval _register_button 0 \$name \$class \$command \$balloon $args]
  }

  # ------------------------------------------------------------------
  #  METHOD:  itemconfigure - 
  # ------------------------------------------------------------------
  
  method itemconfigure {button args} {
    eval $Buttons($button) configure $args
  }

  # ------------------------------------------------------------------
  #  METHOD:  itembind - 
  # ------------------------------------------------------------------
  
  method itembind {button key cmd} {
    eval [list bind $Buttons($button) $key $cmd]
  }

  # ------------------------------------------------------------------
  #  METHOD:  itemballoon - 
  # ------------------------------------------------------------------
  
  method itemballoon {button text} {
    eval [list balloon register $Buttons($button) $text]
  }

  # ------------------------------------------------------------------
  #  PRIVATE METHOD:  toolbar_insert_button - Inserts button "name" before
  #           button "before".
  #           The toolbar must be made, and the buttons must have been
  #           created before you run this.
  # ------------------------------------------------------------------
  private method toolbar_insert_button {name before} {

    if {[string first "-" $name] == 0} {
      set name [string range $name 1 end]
      set add_sep 1
    } else {
      set add_sep 0
    }

    if {![info exists Buttons($name)] || ![info exists Buttons($before)]} {
      error "toolbar_insert_buttons called with non-existant button"
    }

    set before_col [gridCGet $Buttons($before) -column]
    set before_row [gridCGet $Buttons($before) -row]

    set slaves [grid slaves $ButtonFrame]

    set incr [expr 1 + $add_sep]
    foreach slave $slaves {
      set slave_col [gridCGet $slave -column]
      if {$slave_col >= $before_col} {
	grid configure $slave -column [expr $slave_col + $incr]
      }
    }
    if {$add_sep} {
      grid $Buttons(-$name) -column $before_col -row $before_row
    }

    # Now grid our button.  Have to put in the pady since this button
    # may not have been originally inserted by the libgui toolbar
    # proc.

    grid $Buttons($name) -column [expr $before_col + $add_sep] \
      -row $before_row -pady 2
    
  }

  # ------------------------------------------------------------------
  #  PRIVATE METHOD:  toolbar_remove_button -
  # ------------------------------------------------------------------

  private method toolbar_remove_button {name} {

    if {[string first "-" $name] == 0} {
      set name [string range $name 1 end]
      set remove_sep 1
    } else {
      set remove_sep 0
    }

    if {![info exists Buttons($name)] } {
      error "toolbar_remove_buttons called with non-existant button $name"
    }

    set name_col [gridCGet $Buttons($name) -column]
    set name_row [gridCGet $Buttons($name) -row]
    
    grid remove $Buttons($name)
    if {$remove_sep} {
      set Buttons(-$name) [grid slaves $ButtonFrame \
			     -column [expr $name_col - 1] \
			    -row $name_row]
      grid remove $Buttons(-$name)
    }

    set slaves [grid slaves $ButtonFrame -row $name_row]
    foreach slave $slaves {
      set slave_col [gridCGet $slave -column]
      if {($slave_col > $name_col)
          && ! ([info exists Buttons($slave,align)]
              && $Buttons($slave,align) == "right")} {
	grid configure $slave -column [expr $slave_col - 1 - $remove_sep]
      }
    }    
  }

  # ------------------------------------------------------------------
  #  METHOD:  toolbar_button_right_justify - 
  # ------------------------------------------------------------------
  
  method toolbar_button_right_justify {} {
    lappend button_list --
    set button_align "right"
  }

  # ------------------------------------------------------------------
  #  METHOD:  toolbar_swap_button_lists - 
  # ------------------------------------------------------------------

  method toolbar_swap_button_lists {in_list out_list} {
    # Now swap out the buttons...
    set first_out [lindex $out_list 0]
    if {[info exists Buttons($first_out)] && [grid info $Buttons($first_out)] != ""} {
      foreach button $in_list {
	toolbar_insert_button $button $first_out
      }
      foreach button $out_list {
	toolbar_remove_button $button
      }
    } elseif {[info exists Buttons($first_out)]} {
      debug "Error in swap_button_list - $first_out not gridded..."
    } else {
      debug "Button $first_out is not in button list"
    }
  }

  ####################################################################
  #
  #  PRIVATE DATA
  #
  ####################################################################

  # This is the list of buttons that are being built up
  #
  private variable button_list {}

  # This is an array of buttons names -> Tk Window names
  # and also of Tk Window names -> column position in grid
  private variable Buttons

  # This array holds the button classes.  The key is the class name,
  # and the value is the list of buttons belonging to this class.
  private variable button_classes

  # Tell if we are inserting buttons left or right justified
  private variable button_align "left"

  #The frame to contain the buttons:
  private variable ButtonFrame

  ####################################################################
  #
  #  PROTECTED DATA
  #
  ####################################################################

  # None.

  ####################################################################
  #
  #  PUBLIC DATA
  #
  ####################################################################

  # None.
}
@


1.6
log
@2002-10-15  Martin M. Hunt  <hunt@@redhat.com>

	* library/* : auto_mkindex cannot rebuild
	tclIndex because it does not recognize the namespace
	import in main.tcl.  To get it to work again, rename the
	following:
		body -> itcl::body
		configbody -> itcl::configbody
		class -> itcl::class
@
text
@d2 1
a2 1
# Copyright 2000 Red Hat, Inc.
@


1.5
log
@	* library/gdbtoolbar.itcl (GDBToolBar::add): Add option
	for "custom" type.
	(GDBToolBar::toolbar_add_custom): new method.
@
text
@d31 1
a31 1
class GDBToolBar {
@


1.4
log
@2001-02-01  Fernando Nasser  <fnasser@@redhat.com>

	* library/gdbtoolbar.itcl (add): New method.  Emulate the style of the
	toolbar iwidget commands.
	(toolbar_show): Old name.
        (show): New name.
	(toolbar_create_button): Old name.
        (create): New name.
	(toolbar_configure_button): Old name.
        (itemconfigure): New name.
        (toolbar_bind_button): Old name.
        (itembind): New name.
        (toolbar_set_button_balloon): Old name.
        (itemballoon): New name.
        (toolbar_add_button): Make private.
        (toolbar_add_label): Ditto.
        (toolbar_add_button_separator): Ditto.
	(toolbar_remove_button): Ditto.
	(tollbar_insert_button): Ditto.
	* library/srcbar.itcl: Adjust to the above syntax.
	* library/plugins/rhabout/rhabout.itcl: Ditto.
@
text
@d111 3
d145 16
@


1.3
log
@2001-01-28  Fernando Nasser  <fnasser@@redhat.com>

	* library/gdbmenubar.itcl (set_class_state): Turn off verbose debug
	messages.
	* library/gdbtoolbar.itcl (set_class_state): Ditto.
@
text
@d57 1
a57 1
  #  METHOD:  toolbar_show - show the toolbar
d59 1
a59 1
  public method toolbar_show {} {
d80 1
a80 1
	    toolbar_configure_button $button -state $state
d90 61
d193 1
a193 1
  #  METHOD:  toolbar_create_button - Creates all the bookkeeping for a button,
d196 1
a196 1
  method toolbar_create_button {name class command balloon args} {
d202 1
a202 3
  #  METHOD:  toolbar_add_button - Creates a button, and inserts it at the end
  #           of the button list.  Call this when the toolbar is being
  #           set up, but has not yet been made.
d204 3
a206 5
  method toolbar_add_button {name class command balloon args} {
    
    lappend button_list \
            [eval _register_button 1 \$name \$class \$command \$balloon $args]
    
d210 1
a210 1
  #  METHOD:  toolbar_add_button_separator - 
d212 3
a214 3

  method toolbar_add_button_separator {} {
    lappend button_list -
d218 1
a218 1
  #  METHOD:  toolbar_button_right_justify - 
d221 2
a222 17
  method toolbar_button_right_justify {} {
    lappend button_list --
    set button_align "right"
  }

  # ------------------------------------------------------------------
  #  METHOD:  toolbar_add_label - Create a label to be inserted in the
  #                               toolbar.
  # ------------------------------------------------------------------

  method toolbar_add_label {name text balloon args} {
    set lname $ButtonFrame.$name
    set Buttons($name) $lname
    set Buttons($lname,align) $button_align
    eval label $lname -text \$text $args
    balloon register $lname $balloon
    lappend button_list $lname    
d226 1
a226 1
  #  METHOD:  toolbar_insert_button - Inserts button "name" before
d231 1
a231 1
  method toolbar_insert_button {name before} {
d270 1
a270 1
  #  METHOD:  toolbar_remove_button - 
d273 1
a273 1
  method toolbar_remove_button {name} {
d309 1
a309 1
  #  METHOD:  toolbar_configure_button - 
d312 3
a314 18
  method toolbar_configure_button {button args} {
    eval $Buttons($button) configure $args
  }

  # ------------------------------------------------------------------
  #  METHOD:  toolbar_bind_button - 
  # ------------------------------------------------------------------
  
  method toolbar_bind_button {button key cmd} {
    eval [list bind $Buttons($button) $key $cmd]
  }

  # ------------------------------------------------------------------
  #  METHOD:  toolbar_set_button_balloon - 
  # ------------------------------------------------------------------
  
  method toolbar_set_button_balloon {button text} {
    eval [list balloon register $Buttons($button) $text]
@


1.2
log
@2001-01-04  Fernando Nasser  <fnasser@@totem.toronto.redhat.com>

	* library/gdbmenubar.itcl (set_class_state): New public method.
	Standard method to control state by class.
	(menubar_menu_class_find): Delete public accessor method.
	(menubar_change_menu_state): Change the state of a menu item
	not of a whole class list.
	* library/srcmenubar.itcl (enable_ui): Use set_class_state instead
	of prying into base class internal data.
        * library/gdbtoolbar.itcl (set_class_state): New public method.
        Standard method to control state by class.
        (toolbar_button_class_find): Delete public accessor method.
	* library/srctoolbar.itcl (enable_ui): Use set_class_state instead
	of prying into base class internal data.
@
text
@d73 1
a73 1
      dbug W $type
d77 1
a77 1
          dbug W "$type $state \{$class_list\}"
d79 1
a79 1
            dbug W "$type $button $state"
@


1.1
log
@2001-01-02  Fernando Nasser  <fnasser@@totem.toronto.redhat.com>

	* library/gdbmenubar.itcl: New file. Define the GDBMenuBar class,
	a generic menubar building facility for Insight windows (WIP).
	* library/gdbtoolbar.itcl: New file. Define the GDBToolBar class,
	a generic toolbar building facility for Insight windows (WIP).
	* library/srcmenubar.itcl: New file. Define the SrcMenuBar class,
	which implements the Source Window menubar (inherits GDBMenuBar).
	* library/srctoolbar.itcl: New file. Define the SrcToolBar class,
	which implements the Source Window toolbar (inherits GDBToolBar).
	* library/srcwin.itb (_build_win): Use SrcMenuBar and SrcToolBar
	instead of the obsolete GDBSrcBar.
	* library/srcbar.tcl: Mark as OBSOLETE.
	* library/toolbar.tcl: Mark as OBSOLETE. Rename class GDBToolBar
	to avoid conflict with new class with the same name.
	* library/Makefile (TCL): Include .itcl files.
	* library/tclIndex: Regenerate.
@
text
@d65 21
a307 16
    }
  }

  # ------------------------------------------------------------------
  #  METHOD:  toolbar_button_class_find - Find a button class and returns
  #                   its members.
  # 
  #  type - the token for the button class sought
  #
  #  RETURNS: class members (list) if the class exists, {} otherwise.
  # ------------------------------------------------------------------
  method toolbar_button_class_find {type} {
    if {[info exists button_classes($type)]} {
      return $button_classes($type)
    } else {
      return {}
@

