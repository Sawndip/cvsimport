head	1.20;
access;
symbols
	insight_7_6-2013-04-10-branchpoint:1.20
	gdb_7_6-branch:1.20.0.18
	gdb_7_5-branch:1.20.0.16
	gdb_7_4-branch:1.20.0.14
	gdb_7_3-branch:1.20.0.12
	gdb_7_1-branch:1.20.0.10
	gdb_7_0-branch:1.20.0.8
	arc-sim-20090309:1.20
	arc-insight_6_8-branch:1.20.0.6
	arc-insight_6_8-branchpoint:1.20
	insight_6_8-branch:1.20.0.4
	insight_6_8-branchpoint:1.20
	gdb_6_8-branch:1.20.0.2
	insight_6_6-20070208-release:1.19
	gdb_6_6-branch:1.19.0.4
	gdb_6_6-2006-11-15-branchpoint:1.19
	insight_6_5-20061003-release:1.19
	gdb_6_5-branch:1.19.0.2
	gdb_6_5-2006-05-14-branchpoint:1.19
	gdb-csl-gxxpro-6_3-branch:1.18.0.4
	gdb-csl-gxxpro-6_3-branchpoint:1.18
	gdb_6_4-branch:1.18.0.2
	gdb_6_4-2005-11-01-branchpoint:1.18
	gdb_6_1-2004-04-05-release:1.17
	gdb_6_1-branch:1.17.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.17
	gdb_6_0-2003-10-04-release:1.17
	gdb_6_0-branch:1.17.0.2
	gdb_6_0-2003-06-23-branchpoint:1.17
	gdb_5_3-2002-12-12-release:1.14
	gdb_5_3-branch:1.14.0.2
	gdb_5_3-2002-09-04-branchpoint:1.14
	gdb_5_2_1-2002-07-23-release:1.10
	gdb_5_2-2002-04-29-release:1.10
	gdb_5_2-branch:1.10.0.2
	gdb_5_2-2002-03-03-branchpoint:1.10
	gdb_5_1_1-2002-01-24-release:1.6
	cygnus_cvs_20020108_pre:1.10
	gdb_5_1_0_1-2002-01-03-branch:1.6.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.6
	gdb_5_1-2001-11-21-release:1.6
	gdb_s390-2001-09-26-branch:1.6.0.6
	gdb_s390-2001-09-26-branchpoint:1.6
	gdb_5_1-2001-07-29-branch:1.6.0.4
	gdb_5_1-2001-07-29-branchpoint:1.6
	dberlin-typesystem-branch:1.6.0.2
	dberlin-typesystem-branchpoint:1.6
	insight-precleanup-2001-01-01:1.4
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	insight-2000-02-04:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.20
date	2008.02.09.01.23.42;	author kseitz;	state Exp;
branches;
next	1.19;

1.19
date	2005.12.23.18.26.50;	author eliz;	state Exp;
branches;
next	1.18;

1.18
date	2005.09.01.04.05.47;	author kseitz;	state Exp;
branches;
next	1.17;

1.17
date	2003.03.06.01.25.50;	author hunt;	state Exp;
branches;
next	1.16;

1.16
date	2003.01.21.21.58.20;	author hunt;	state Exp;
branches;
next	1.15;

1.15
date	2002.10.15.21.19.50;	author hunt;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.07.09.22.44;	author hunt;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.14.17.12.10;	author kseitz;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.07.06.06.18;	author hunt;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.05.22.22.19;	author hunt;	state Exp;
branches;
next	1.10;

1.10
date	2001.12.21.21.36.21;	author kseitz;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.05.19.15.17;	author hunt;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.29.00.23.30;	author kseitz;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.28.21.20.20;	author kseitz;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.11.23.08.05;	author tromey;	state Exp;
branches;
next	1.5;

1.5
date	2001.04.19.22.51.02;	author kseitz;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.07.20.14.02;	author tromey;	state Exp;
branches;
next	1.3;

1.3
date	2000.11.30.22.49.46;	author tromey;	state Exp;
branches;
next	1.2;

1.2
date	2000.11.30.22.37.29;	author tromey;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.07.00.19.42;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.07.00.19.42;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.20
log
@        * library/main.tcl: Add gdbtk_platform definitions.
        * library/attachdlg.itb (list_pids): Use gdbtk_platform
        instead of tcl_platform.
        * library/bpwin.itb (build_win): Likewise.
        (_bp_add): Likewise.
        (_bp_modify): Likewise.
        * library/download.itb (download_it): Likewise.
        * library/globalpref.itb (_build_win): Likewise.
        * library/helpviewer.tcl (open_help): Likewise.
        * library/interface.tcl (gdbtk_tcl_query): Likewise.
        (show_warning): Likewise.
        (open_file): Likewise.
        (run_executable): Likewise.
        * library/managedwin.itb (reveal): Likewise.
        (_create): Likewise.
        * library/prefs.tcl (pref_read): Likewise.
        (pref_set_defaults): Likewise.
        (pref_set_colors): Likewise.
        * library/session.tcl (_exe_name): Likewise.
        * library/srcbar.itcl (_update_file_menu): Likewise.
        (create_run_menu): Likewise.
        * library/srctextwin.itb (_mtime_changed): Likewise.
        (LoadFromCache): Likewise.
        * library/targetselection.itb (default_port): Likewise.
        (build_win): Likewise.

        * library/memwin.itb (build_win): Remove unused tcl_platform
        declaration.
        * library/pluginwin.itcl (enable_ui): Likewise.
        * library/process.itb (build_win): Likewise.
        * library/srcbar.itcl (enable_ui): Likewise.
        * library/srcwin.itb (location): Likewise.
        * library/stackwin.itb (build_win): Likewise.
        * library/tdump.tcl (build_win): Likewise.
@
text
@# Breakpoint window for Insight.
# Copyright (C) 1997, 1998, 1999, 2001, 2002, 2003, 2008 Red Hat, Inc.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License (GPL) as published by
# the Free Software Foundation; either version 2 of the License, or (at
# your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.


# ------------------------------------------------------------------
#  CONSTRUCTOR:  create the main breakpoint window
# ------------------------------------------------------------------
itcl::body BpWin::constructor {args} {
  window_name "Breakpoints" "BPs"
  
  if {[pref getd gdb/bp/menu] != ""} {
    set mbar 0
  }
  set show_threads [pref get gdb/bp/show_threads]
  debug "Ready to build"
  build_win
  eval itk_initialize $args 

  # The scrolledframe uses a canvas, which doesn't properly
  # calculate an initial size, so we must set a default
  # window size here. ManagedWin could override this still
  # if there is a user preference for the geometry.
  wm geometry $_top 350x165
  debug "done building"
}

# ------------------------------------------------------------------
#  DESTRUCTOR:  destroy the breakpoint window
# ------------------------------------------------------------------
itcl::body BpWin::destructor {} {}


# ------------------------------------------------------------------
#  METHOD:  build_win - build the main breakpoint window
# ------------------------------------------------------------------
itcl::body BpWin::build_win {} {
  global _bp_en _bp_disp
  set bg1 $::Colors(bg)

  set hsmode dynamic
  set vsmode dynamic

  # FIXME: The iwidgets scrolled frame is pretty useless.
  # When we get BLT, use its hiertable to do this.
  itk_component add sframe {
    iwidgets::scrolledframe $itk_interior.sf \
      -hscrollmode $hsmode -vscrollmode $vsmode
  }

  set twin [$itk_component(sframe) childsite]

  # write header
  if {$tracepoints} {
    label $twin.num0 -text "Num" -relief raised -bd 2 -anchor center \
      -font global/fixed
  } 
  label $twin.thread0 -text "Thread" -relief raised -bd 2 -anchor center \
    -font global/fixed
  label $twin.addr0 -text "Address" -relief raised -bd 2 -anchor center \
    -font global/fixed
  label $twin.file0 -text "File" -relief raised -bd 2 -anchor center \
    -font global/fixed
  label $twin.line0 -text "Line" -relief raised -bd 2 -anchor center \
    -font global/fixed
  label $twin.func0 -text "Function" -relief raised -bd 2 -anchor center \
    -font global/fixed

  if {$tracepoints} {
    label $twin.pass0 -text "PassCount" -relief raised -borderwidth 2 \
      -anchor center -font global/fixed
    grid x $twin.num0 $twin.addr0 $twin.file0 $twin.line0 $twin.func0 $twin.pass0 \
      -sticky new
  } else {
    if {$show_threads} {
      grid x $twin.thread0 $twin.addr0 $twin.file0 $twin.line0 $twin.func0 -sticky new
      # Let the File and Function columns expand; no others.
      grid columnconfigure $twin 3 -weight 1
      grid columnconfigure $twin 5 -weight 1
    } else {
      grid x $twin.addr0 $twin.file0 $twin.line0 $twin.func0 -sticky new
      # Let the File and Function columns expand; no others.
      grid columnconfigure $twin 2 -weight 1
      grid columnconfigure $twin 4 -weight 1
    }
  }


  # The last row must always suck up all the leftover vertical
  # space.
  set next_row 1
  grid rowconfigure $twin $next_row -weight 1

  if { $mbar } {
    menu $itk_interior.m -tearoff 0
    [winfo toplevel $itk_interior] configure -menu $itk_interior.m
    if { $tracepoints == 0 } {
      $itk_interior.m add cascade -menu $itk_interior.m.bp -label "Breakpoint" -underline 0
    } else {
      $itk_interior.m add cascade -menu $itk_interior.m.bp -label "Tracepoint" -underline 0
    }
    set m [menu $itk_interior.m.bp]
    if { $tracepoints == 0 } {
      $m add radio -label "Normal" -variable _bp_disp($selected) \
	-value donttouch -underline 0 -state disabled
      $m add radio -label "Temporary" -variable _bp_disp($selected) \
	-value delete -underline 0 -state disabled
    } else {
      $m add command -label "Actions" -underline 0 -state disabled
    }

    $m add separator
    $m add radio -label "Enabled" -variable _bp_en($selected) -value 1 \
      -underline 0 -state disabled
    $m add radio -label "Disabled" -variable _bp_en($selected) -value 0 \
      -underline 0 -state disabled
    $m add separator
    $m add command -label "Remove" -underline 0 -state disabled
    $itk_interior.m add cascade -menu $itk_interior.m.all -label "Global" \
      -underline 0
    set m [menu $itk_interior.m.all]
    $m add check -label " Show Threads" \
      -variable [pref varname gdb/bp/show_threads] \
      -underline 1 -command "$this toggle_threads"
    $m add separator
    $m add command -label "Disable All" -underline 0 \
      -command "$this bp_all disable"
    $m add command -label "Enable All" -underline 0 \
      -command "$this bp_all enable"
    $m add separator
    $m add command -label "Remove All" -underline 0 \
      -command "$this bp_all delete"
    $m add separator
    $m add command -label "Store Breakpoints..." -underline 0 \
      -command [code $this bp_store]
    $m add command -label "Restore Breakpoints..." -underline 3 \
      -command [code $this bp_restore]
  }

  set Menu [menu $itk_interior.pop -tearoff 0]
  
  if { $tracepoints == 0 } {
    $Menu add radio -label "Normal" -variable _bp_disp($selected) \
      -value donttouch -underline 0
    $Menu add radio -label "Temporary" -variable _bp_disp($selected) \
      -value delete -underline 0
  } else {
    $Menu add command -label "Actions" -underline 0 
  }
  $Menu add separator
  $Menu add radio -label "Enabled" -variable _bp_en($selected) -value 1 -underline 0
  $Menu add radio -label "Disabled" -variable _bp_en($selected) -value 0 -underline 0
  $Menu add separator
  $Menu add command -label "Remove" -underline 0
  $Menu add cascade -menu $Menu.all -label "Global" -underline 0
  set m [menu $Menu.all]
  $m add check -label " Show Threads" -variable [pref varname gdb/bp/show_threads] \
    -underline 1 -command "$this toggle_threads"
  $m add separator
  $m add command -label "Disable All" -underline 0 -command "$this bp_all disable"
  $m add command -label "Enable All" -underline 0 -command "$this bp_all enable"
  $m add separator
  $m add command -label "Remove All" -underline 0 -command "$this bp_all delete"

  if { $tracepoints == 0 } {
    # insert all breakpoints
    foreach i [gdb_get_breakpoint_list] {
      set e [BreakpointEvent \#auto -action create -number $i]
      bp_add $e
      delete object $e
    }
  } else {
    # insert all tracepoints
    foreach i [gdb_get_tracepoint_list] {
      set e [TracepointEvent \#auto -action create -number $i]
      bp_add $e 1
      delete object $e
    }
  }

  pack $itk_component(sframe) -side left -expand true -fill both
}

# ------------------------------------------------------------------
#  METHOD:  bp_add - add a breakpoint entry
# ------------------------------------------------------------------
itcl::body BpWin::bp_add {bp_event {tracepoint 0}} {
  global _bp_en _bp_disp gdbtk_platform _files

  set number [$bp_event get number]
  set thread [$bp_event get thread]
  set disposition [$bp_event get disposition]
  set file [$bp_event get file]

  if {$tracepoint} {
    set diposition tracepoint
    set bptype tracepoint
  } else {
    set bptype breakpoint
  }

  debug "bp_add bpnum=$number thread=$thread show=$show_threads"
  set i $next_row
  set _bp_en($i) [$bp_event get enabled]
  set _bp_disp($i) $disposition
  set temp($i) ""
  switch $disposition {
    donttouch { set color [pref get gdb/src/bp_fg] }
    delete { 
      set color [pref get gdb/src/temp_bp_fg]
      set temp($i) delete
    }
    tracepoint {
      set color [pref get gdb/src/trace_fg]
    }
    default { set color yellow }
  }
  
  if {$thread != "-1"} {set color [pref get gdb/src/thread_fg]}

  if {$gdbtk_platform(platform) == "windows"} {
    checkbutton $twin.en$i -relief flat -variable _bp_en($i) \
      -activebackground $bg1 -command "$this bp_able $i" -fg $color 
  } else {
    checkbutton $twin.en$i -relief flat -variable _bp_en($i) \
      -command "$this bp_able $i" -activebackground $bg1 \
      -selectcolor $color -highlightbackground $bg1
  }

  if {$tracepoints} {
    label $twin.num$i -text "$number " -relief flat -anchor w -font global/fixed
  }
  label $twin.addr$i -text "[gdb_CA_to_TAS [$bp_event get address]] " -relief flat -anchor w -font global/fixed -bg $bg1
  if {[info exists _files(short,$file)]} {
    set file $_files(short,$file)
  } else {
    # FIXME.  Really need to do better than this.
    set file [::file tail $file]
  }
  if {$show_threads} {
    if {$thread == "-1"} {set thread "ALL"}
    label $twin.thread$i -text "$thread " -relief flat -anchor w -font global/fixed
  }
  label $twin.file$i -text "$file " -relief flat -anchor w -font global/fixed 
  label $twin.line$i -text "[$bp_event get line] " -relief flat -anchor w -font global/fixed
  label $twin.func$i -text "[$bp_event get function] " -relief flat -anchor w -font global/fixed 
  if {$tracepoints} {
    label $twin.pass$i -text "[$bp_event get pass_count] " -relief flat -anchor w -font global/fixed
  }

  if {$mbar} {
    set zz [list addr file func line]
    if {$tracepoints} {lappend zz num pass}
    if {$show_threads} {lappend zz thread}
    foreach thing $zz {
      bind $twin.${thing}${i} <1> "$this bp_select $i"
      bind $twin.${thing}${i} <Double-1> "$this goto_bp $i"
      bind $twin.${thing}${i} <3> [code $this _select_and_popup $i %X %Y]
    }
  }

  if {$tracepoints} {
    grid $twin.en$i $twin.num$i $twin.addr$i $twin.file$i $twin.line$i \
      $twin.func$i $twin.pass$i -sticky new -ipadx 4 -ipady 2
  } else {
    if {$show_threads} {
      grid $twin.en$i $twin.thread$i $twin.addr$i $twin.file$i $twin.line$i \
	$twin.func$i -sticky new -ipadx 4 -ipady 2
    } else {
      grid $twin.en$i $twin.addr$i $twin.file$i $twin.line$i \
	$twin.func$i -sticky new -ipadx 4 -ipady 2
    }
  }

  # This used to be the last row.  Fix it vertically again.
  grid rowconfigure $twin $i -weight 0

  set index_to_bpnum($i) $number
  set Index_to_bptype($i) $bptype
  incr i
  set next_row $i
  grid rowconfigure $twin $i -weight 1
}

# ------------------------------------------------------------------
#  METHOD:  bp_store - stores away the breakpoints in a file of gdb
#                      commands
# ------------------------------------------------------------------
itcl::body BpWin::bp_store {} {
  set out_file [tk_getSaveFile]
  if {$out_file == ""} {
    return
  }
  if {[catch {::open $out_file w} outH]} {
    tk_messageBox -message "Could not open $out_file: $outH"
    return
  }
  foreach breakpoint [gdb_get_breakpoint_list] {
    # This is an lassign
    foreach {file function line_no address type \
	       enable_p disp ignore cmds cond thread hit_count user_spec} \
      [gdb_get_breakpoint_info $breakpoint] {
	break
      }

    if {$user_spec != ""} {
      set bp_specifier $user_spec
    } elseif {$file != ""} {
      set filename [file tail $file]
      set bp_specifier $filename:$line_no
    } else {
      set bp_specifier *$address
    }

    # FIXME: doesn't handle watchpoints.
    if {[string compare $disp "delete"] == 0} {
      puts $outH "tbreak $bp_specifier"
    } else {
      puts $outH "break $bp_specifier"
    }
      
    if {!$enable_p} {
      puts $outH "disable \$bpnum"
    }
    if {$ignore > 0} {
      puts $outH "ignore \$bpnum $ignore"
    }
  }
  close $outH
}

# ------------------------------------------------------------------
#  METHOD:  bp_restore - restore the breakpoints from a file of gdb
#                      commands
# ------------------------------------------------------------------
itcl::body BpWin::bp_restore {} {
  set inH [tk_getOpenFile]
  if {$inH == ""} {
    return
  }
  bp_all delete
  if {[catch {gdb_cmd "source $inH"} err]} {
    tk_messageBox -message "Error sourcing in BP file $inH: \"$err\""
  }
}

# ------------------------------------------------------------------
#  METHOD:  bp_select - select a row in the grid
# ------------------------------------------------------------------
itcl::body BpWin::bp_select { r } {
  global _bp_en _bp_disp

  set zz [list addr file func line]
  if {$tracepoints} {lappend zz num pass}
  if {$show_threads} {lappend zz thread}
  
  if {$selected} {
    set i $selected
    
    foreach thing $zz {
      $twin.${thing}${i}  configure -fg $::Colors(fg) -bg $bg1
    }
  }

  # if we click on the same line, unselect it and return
  if {$selected == $r} {
    set selected 0

    if {$tracepoints == 0} {
      $itk_interior.m.bp entryconfigure "Normal" -state disabled
      $itk_interior.m.bp entryconfigure "Temporary" -state disabled
    } else {
      $itk_interior.m.bp entryconfigure "Actions" -state disabled
    }
    $itk_interior.m.bp entryconfigure "Enabled" -state disabled
    $itk_interior.m.bp entryconfigure "Disabled" -state disabled
    $itk_interior.m.bp entryconfigure "Remove" -state disabled
    
    return
  }

  foreach thing $zz {
    $twin.${thing}${r} configure -fg $::Colors(sfg) -bg $::Colors(sbg)
  }
  
  if {$tracepoints == 0} {
    $itk_interior.m.bp entryconfigure "Normal" -variable _bp_disp($r) \
      -command "$this bp_type $r" -state normal
    $itk_interior.m.bp entryconfigure "Temporary" -variable _bp_disp($r) \
      -command "$this bp_type $r" -state normal
    $Menu entryconfigure "Normal" -variable _bp_disp($r)      \
      -command "$this bp_type $r" -state normal
    $Menu entryconfigure "Temporary" -variable _bp_disp($r)      \
      -command "$this bp_type $r" -state normal
  } else {
    $itk_interior.m.bp entryconfigure "Actions" -command "$this get_actions $r" -state normal
    $Menu entryconfigure "Actions" -command "$this get_actions $r" -state normal
  }
  $itk_interior.m.bp entryconfigure "Enabled" -variable _bp_en($r)   \
    -command "$this bp_able $r" -state normal
  $itk_interior.m.bp entryconfigure "Disabled" -variable _bp_en($r)   \
    -command "$this bp_able $r" -state normal
  $itk_interior.m.bp entryconfigure "Remove" -command "$this bp_remove $r" -state normal
  $Menu entryconfigure "Enabled" -variable _bp_en($r)        \
    -command "$this bp_able $r" -state normal
  $Menu entryconfigure "Disabled" -variable _bp_en($r)        \
    -command "$this bp_able $r" -state normal
  $Menu entryconfigure "Remove" -command "$this bp_remove $r" -state normal
  
  set selected $r
}

# ------------------------------------------------------------------
#  NAME:         private method BpWin::_select_and_popup
#  DESCRIPTION:  Select the given breakpoint and popup the options
#                menu at the given location.
#
#  ARGUMENTS:    None
#  RETURNS:      Nothing
# ------------------------------------------------------------------
itcl::body BpWin::_select_and_popup {bp X Y} {
  if {$selected != $bp} {
    bp_select $bp
  }
  tk_popup $Menu $X $Y
}

# ------------------------------------------------------------------
#  METHOD:  bp_modify - modify a breakpoint entry
# ------------------------------------------------------------------
itcl::body BpWin::bp_modify {bp_event {tracepoint 0}} {
  global _bp_en _bp_disp gdbtk_platform _files

  set number [$bp_event get number]
  set thread [$bp_event get thread]
  set disposition [$bp_event get disposition]
  set file [$bp_event get file]

  if {$tracepoint} {
    set disposition tracepoint
    set bptype tracepoint
  } else {
    set bptype breakpoint
  }

  set found 0
  for {set i 1} {$i < $next_row} {incr i} {
    if { $number == $index_to_bpnum($i)
	 && "$Index_to_bptype($i)" == "$bptype"} {
      incr found
      break
    }
  }

  if {!$found} {
    debug "ERROR: breakpoint number $number not found!"
    return
  }

  if {$_bp_en($i) != [$bp_event get enabled]} {
    set _bp_en($i) [$bp_event get enabled]
  }

  if {$_bp_disp($i) != $disposition} {
    set _bp_disp($i) $disposition
  }

  switch $disposition {
    donttouch { set color [pref get gdb/src/bp_fg] }
    delete { 
      set color [pref get gdb/src/temp_bp_fg]
    }
    tracepoint { set color [pref get gdb/src/trace_fg] }
    default { set color yellow}
  }

  if {$thread != "-1"} {set color [pref get gdb/src/thread_fg]}

  if {$gdbtk_platform(platform) == "windows"} then {
    $twin.en$i configure -fg $color 
  } else {
    $twin.en$i configure -selectcolor $color
  }
  if {$tracepoints} {
    $twin.num$i configure  -text "$number "
  }
  $twin.addr$i configure -text "[gdb_CA_to_TAS [$bp_event get address]] "
  if {[info exists _files(short,$file)]} {
    set file $_files(short,$file)
  } else {
    # FIXME.  Really need to do better than this.
    set file [::file tail $file]
  }
  if {$show_threads} {
    if {$thread == "-1"} {set thread "ALL"}
    $twin.thread$i configure -text "$thread "
  }
  $twin.file$i configure -text "$file "
  $twin.line$i configure  -text "[$bp_event get line] "
  $twin.func$i configure  -text "[$bp_event get function] "
  if {$tracepoints} {
    $twin.pass$i configure  -text "[$bp_event get pass_count] "
  }
}

# ------------------------------------------------------------------
#  METHOD:  bp_able - enable/disable a breakpoint
# ------------------------------------------------------------------
itcl::body BpWin::bp_able { i } {
  global _bp_en
  
  bp_select $i

  switch $Index_to_bptype($i) {
    breakpoint {set type {}}
    tracepoint {set type "tracepoint"}
  }

  if {$_bp_en($i) == "1"} {
    set command "enable $type $temp($i) "
  } else {
    set command "disable $type "
  }

  append command  "$index_to_bpnum($i)"
  gdb_cmd "$command"
}

# ------------------------------------------------------------------
#  METHOD:  bp_remove - remove a breakpoint
# ------------------------------------------------------------------
itcl::body BpWin::bp_remove { i } {

  bp_select $i

  switch $Index_to_bptype($i) {
    breakpoint { set type {} }
    tracepoint { set type "tracepoint" }
  }

  gdb_cmd "delete $type $index_to_bpnum($i)"
}

# ------------------------------------------------------------------
#  METHOD:  bp_type - change the breakpoint type (disposition)
# ------------------------------------------------------------------
itcl::body BpWin::bp_type { i } {
  
  if {$Index_to_bptype($i) != "breakpoint"} {
    return
  }

  set bpnum $index_to_bpnum($i)
  #debug "bp_type $i $bpnum"
  set bpinfo [gdb_get_breakpoint_info $bpnum]
  lassign $bpinfo file func line pc type enabled disposition \
    ignore_count commands cond thread hit_count user_spec
  bp_select $i
  switch $disposition {
    delete {  
      gdb_cmd "delete $bpnum"
      gdb_cmd "break *$pc"
    }
    donttouch {
      gdb_cmd "delete $bpnum"
      gdb_cmd "tbreak *$pc"
    }
    default { debug "Unknown breakpoint disposition: $disposition" }
  }
}

# ------------------------------------------------------------------
#  METHOD:  bp_delete - delete a breakpoint
# ------------------------------------------------------------------
itcl::body BpWin::bp_delete {bp_event} {
  set number [$bp_event get number]
  for {set i 1} {$i < $next_row} {incr i} {
    if { $number == $index_to_bpnum($i) } {
      if {$tracepoints} {
	grid forget $twin.en$i $twin.num$i $twin.addr$i $twin.file$i \
	  $twin.line$i $twin.func$i $twin.pass$i
	destroy $twin.en$i $twin.num$i $twin.addr$i $twin.file$i \
	  $twin.line$i $twin.func$i $twin.pass$i
      } else {
	if {$show_threads} {
	  grid forget $twin.thread$i
	  destroy $twin.thread$i
	}
	grid forget $twin.en$i $twin.addr$i $twin.file$i $twin.line$i $twin.func$i
	destroy $twin.en$i $twin.addr$i $twin.file$i $twin.line$i $twin.func$i
      }
      if {$selected == $i} {
	set selected 0
      }
      return
    }
  }
}

# ------------------------------------------------------------------
#  PUBLIC METHOD:  breakpoint - Update widget when a breakpoint
#                   event is received from the backend.
# ------------------------------------------------------------------
itcl::body BpWin::breakpoint {bp_event} {

  set action [$bp_event get action]
  #debug "bp update $action [$bp_event get number] [$bp_event get type]"

  switch $action {
    modify  { bp_modify $bp_event 0 }
    create  { bp_add $bp_event 0 }
    delete  { bp_delete $bp_event }
    default { dbug E "Unknown breakpoint action: $action" }
  }
}

# ------------------------------------------------------------------
#  METHOD:  tracepoint - Update widget when a tracepoint event
#            is received from the backend.
# ------------------------------------------------------------------
itcl::body BpWin::tracepoint {tp_event} {

  set action [$tp_event get action]
  #debug "tp update $action [$tp_event get number]"

  switch $action {
    modify  { bp_modify $tp_event 1 }
    create  { bp_add $tp_event 1 }
    delete  { bp_delete $tp_event }
    default { dbug E "Unknown tracepoint action: $action" }
  }
}

# ------------------------------------------------------------------
#  METHOD:  bp_all - perform a command on all breakpoints
# ------------------------------------------------------------------
itcl::body BpWin::bp_all { command } {

  if {!$tracepoints} {
    # Do all breakpoints
    foreach bpnum [gdb_get_breakpoint_list] {
      if { $command == "enable"} {
	for {set i 1} {$i < $next_row} {incr i} {
	  if { $bpnum == $index_to_bpnum($i)
	       && "$Index_to_bptype($i)" == "breakpoint"} {
	    gdb_cmd "enable $temp($i) $bpnum"
	    break
	  }
	}
      } else {
	gdb_cmd "$command $bpnum"
      }
    }
  } else {
    # Do all tracepoints
    foreach bpnum [gdb_get_tracepoint_list] {
      if { $command == "enable"} {
	for {set i 1} {$i < $next_row} {incr i} {
	  if { $bpnum == $index_to_bpnum($i)
	       && "$Index_to_bptype($i)" == "tracepoint"} {
	    gdb_cmd "enable tracepoint $bpnum"
	    break
	  }
	}
      } else {
	gdb_cmd "$command tracepoint $bpnum"
      }
    }
  }
}

# ------------------------------------------------------------------
#  METHOD:  get_actions - pops up the add trace dialog on a selected 
#                         tracepoint
# ------------------------------------------------------------------
itcl::body BpWin::get_actions {bpnum} {
  set bpnum $index_to_bpnum($bpnum)
  set bpinfo [gdb_get_tracepoint_info $bpnum]
  lassign $bpinfo file func line pc enabled pass_count \
    step_count thread hit_count actions

  set filename [::file tail $file]
  ManagedWin::open TraceDlg -File $filename -Lines $line
}

# ------------------------------------------------------------------
#  METHOD:  toggle_threads - callback when show_threads is toggled
# ------------------------------------------------------------------
itcl::body BpWin::toggle_threads {} {
  set show_threads [pref get gdb/bp/show_threads]
  reconfig
}

# ------------------------------------------------------------------
#  METHOD:  reconfig - used when preferences change
# ------------------------------------------------------------------
itcl::body BpWin::reconfig {} {
  if {[winfo exists $itk_interior.f]} { destroy $itk_interior.f }
  if {[winfo exists $itk_interior.m]} { destroy $itk_interior.m }
  if {[winfo exists $itk_interior.sbox]} { destroy $itk_interior.sbox }
  if {[winfo exists $itk_interior.sf]} { destroy $itk_interior.sf }
  if {[winfo exists $itk_interior.pop]} { destroy $itk_interior.pop }
  build_win
}

# ------------------------------------------------------------------
#  METHOD:  goto_bp - show bp in source window
# ------------------------------------------------------------------
itcl::body BpWin::goto_bp {r} {
  set bpnum $index_to_bpnum($r)
  if {$tracepoints} {
    set bpinfo [gdb_get_tracepoint_info $bpnum]
  } else {
    set bpinfo [gdb_get_breakpoint_info $bpnum]
  }
  set pc [lindex $bpinfo 3]

  SrcWin::choose_and_display BROWSE_TAG [gdb_loc *$pc]
}
@


1.19
log
@	* library/attachdlg.itb:
	* library/actiondlg.tcl:
	* library/about.tcl:
	* library/ehandler.itb:
	* library/editor.tcl:
	* library/download.ith:
	* library/download.itb:
	* library/debugwin.ith:
	* library/debugwin.itb:
	* library/cspref.ith:
	* library/cspref.itb:
	* library/console.ith:
	* library/console.itb:
	* library/browserwin.ith:
	* library/browserwin.itb:
	* library/bpwin.ith:
	* library/bpwin.itb:
	* library/blockframe.ith:
	* library/managedwin.ith:
	* library/managedwin.itb:
	* library/main.tcl:
	* library/locals.tcl:
	* library/ipcpref.ith:
	* library/ipcpref.itb:
	* library/ipc.tcl:
	* library/interface.tcl:
	* library/helpviewer.tcl:
	* library/globalpref.ith:
	* library/globalpref.itb:
	* library/gdbwin.ith:
	* library/gdbtoolbar.itcl:
	* library/gdbmenubar.itcl:
	* library/gdbevent.ith:
	* library/gdbevent.itb:
	* library/embeddedwin.ith:
	* library/ehandler.ith:
	* library/srcwin.itb:
	* library/srctextwin.ith:
	* library/srctextwin.itb:
	* library/srcpref.ith:
	* library/srcpref.itb:
	* library/srcbar.itcl:
	* library/session.tcl:
	* library/regwin.ith:
	* library/regwin.itb:
	* library/process.ith:
	* library/process.itb:
	* library/prefs.tcl:
	* library/pluginwin.itcl:
	* library/modal.tcl:
	* library/memwin.ith:
	* library/memwin.itb:
	* library/mempref.ith:
	* library/mempref.itb:
	* library/watch.tcl:
	* library/watch.tcl:
	* library/warning.tcl:
	* library/vartree.ith:
	* library/vartree.itb:
	* library/util.tcl:
	* library/tracedlg.tcl:
	* library/toplevelwin.ith:
	* library/tfind_args.tcl:
	* library/tdump.tcl:
	* library/targetselection.ith:
	* library/targetselection.itb:
	* library/stackwin.ith:
	* library/stackwin.itb:
	* library/srcwin.ith:
@
text
@d2 1
a2 1
# Copyright (C) 1997, 1998, 1999, 2001, 2002, 2003 Red Hat, Inc.
d47 1
a47 1
  global _bp_en _bp_disp tcl_platform
d197 1
a197 1
  global _bp_en _bp_disp tcl_platform _files
d230 1
a230 1
  if {$tcl_platform(platform) == "windows"} {
d441 1
a441 1
  global _bp_en _bp_disp tcl_platform _files
d488 1
a488 1
  if {$tcl_platform(platform) == "windows"} then {
@


1.18
log
@        * library/bpwin.itb (bp_store): gdb_get_breakpoint_info outputs
        the breakpoint condition, too -- include it in the lassign.
@
text
@d2 1
a2 1
# Copyright 1997, 1998, 1999, 2001, 2002, 2003 Red Hat, Inc.
@


1.17
log
@2003-03-05  Martin M. Hunt  <hunt@@redhat.com>

	* generic/gdbtk-cmds.c (Gdbtk_Init): Create gdb_CA_to_TAS.
	(gdb_load_disassembly): Now takes CORE_ADDRs. Returns CORE_ADDRs
	for low and high.
	(gdbtk_load_asm): Use CORE_ADDRs.
	(gdb_loc): Return CORE_ADDRs.
	(gdb_entry_point): Return CORE_ADDR.
	(gdb_incr_addr): Update description.
	(gdb_CA_to_TAS): New function. Takes a CORE_ADDR and returns
	a target sddress string.

	* generic/gdbtk-bp.c (gdb_find_bp_at_addr): Change to
	take a CORE_ADDR.
	(gdb_get_breakpoint_info): Returns a CORE_ADDR.
	(gdb_set_bp_addr): Takes a CORE_ADDR.

	* library/bpwin.itb (bp_add): Call gdb_CA_to_TAS before
	displaying address.
	(bp_modify): Ditto.

	* library/srcwin.itb (location): Call gdb_CA_to_TAS before
	displaying address. Don't add "0x" in front of address.
	(set_execution_status): Call gdb_CA_to_TAS before
	displaying address. Don't call [gdb_cmd printf] to format
	output. Weird.
@
text
@d310 1
a310 1
	       enable_p disp ignore cmds thread hit_count user_spec} \
@


1.16
log
@2003-01-21  Martin M. Hunt  <hunt@@redhat.com>
	* library/main.tcl: Don't require iwidgets 3.0.

	* library/console.itb (Console::_build_win): Rename
	tkTextClosestGap to tk::TextClosestGap. Rename tkCancelRepeat
	to tk::CancelRepeat. Rename tkPriv to tk::Priv. Needed for tk 8.4.1.

	* library/bpwin.itb (BpWin::build_win): Don't
	create sizebox.
	* library/locals.tcl (build_win): Ditto.
	* library/regwin.itb (RegWin::_build_win): Ditto.
	* library/srcwin.itb (SrcWin::constructor): Ditto.
	* library/stackwin.itb (StackWin::build_win): Ditto.
	* library/watch.tcl (build_win): Ditto.
@
text
@d242 1
a242 1
  label $twin.addr$i -text "[$bp_event get address] " -relief flat -anchor w -font global/fixed -bg $bg1
d496 1
a496 1
  $twin.addr$i configure -text "[$bp_event get address] " 
@


1.15
log
@2002-10-15  Martin M. Hunt  <hunt@@redhat.com>

	* library/* : auto_mkindex cannot rebuild
	tclIndex because it does not recognize the namespace
	import in main.tcl.  To get it to work again, rename the
	following:
		body -> itcl::body
		configbody -> itcl::configbody
		class -> itcl::class
@
text
@d2 1
a2 1
# Copyright 1997, 1998, 1999, 2001, 2002 Red Hat, Inc.
d50 2
a51 10
  if {$tcl_platform(platform) == "windows"} {
    # Add a sizebox and set scroll modes to static
    ide_sizebox $itk_interior.sbox
    place $itk_interior.sbox -relx 1.0 -rely 1.0 -anchor se
    set hsmode static
    set vsmode static
  } else {
    set hsmode dynamic
    set vsmode dynamic
  }
@


1.14
log
@2002-06-07  Martin M. Hunt  <hunt@@redhat.com>

	* library/prefs.tcl (pref_set_colors): New function.  Set up colors
	from Windows system colors or X resource database. Save in array.
	(pref_set_defaults): Remove gdb/font/normal_fg, etc.
	(pref_read): Call pref_set_colors.

	* library/main.tcl: Remove call to "tix resetoptions TixGray".

	* library/bpwin.itb, library/browserwin.itb, library/console.itb,
	library/globalpref.itb, library/memwin.itb, library/process.itb,
	library/regwin.itb, library/srcpref.itb, library/srctextwin.itb,
	library/stackwin.itb, library/tdump.tcl, library/tracedlg.tcl,
	library/variables.tcl: Replace calls to [pref get gdb/fonts/*]
	for colors with references to Color array. Remove all tixOptions calls.
	Fix up colors as necessary.
@
text
@d18 1
a18 1
body BpWin::constructor {args} {
d40 1
a40 1
body BpWin::destructor {} {}
d46 1
a46 1
body BpWin::build_win {} {
d204 1
a204 1
body BpWin::bp_add {bp_event {tracepoint 0}} {
d306 1
a306 1
body BpWin::bp_store {} {
d353 1
a353 1
body BpWin::bp_restore {} {
d367 1
a367 1
body BpWin::bp_select { r } {
d438 1
a438 1
body BpWin::_select_and_popup {bp X Y} {
d448 1
a448 1
body BpWin::bp_modify {bp_event {tracepoint 0}} {
d526 1
a526 1
body BpWin::bp_able { i } {
d549 1
a549 1
body BpWin::bp_remove { i } {
d564 1
a564 1
body BpWin::bp_type { i } {
d592 1
a592 1
body BpWin::bp_delete {bp_event} {
d621 1
a621 1
body BpWin::breakpoint {bp_event} {
d638 1
a638 1
body BpWin::tracepoint {tp_event} {
d654 1
a654 1
body BpWin::bp_all { command } {
d693 1
a693 1
body BpWin::get_actions {bpnum} {
d706 1
a706 1
body BpWin::toggle_threads {} {
d714 1
a714 1
body BpWin::reconfig {} {
d726 1
a726 1
body BpWin::goto_bp {r} {
@


1.13
log
@	* library/bpwin.itb (constructor): Set some sane initial
	size.
@
text
@d48 1
a48 1
  set bg1 [pref get gdb/font/normal_bg]
d64 1
a64 1
    iwidgets::scrolledframe $itk_interior.sf -background $bg1 \
d66 1
a66 1
  } {}
d239 1
a239 1
    checkbutton $twin.en$i -relief flat -variable _bp_en($i) -bg $bg1 \
d242 3
a244 2
    checkbutton $twin.en$i -relief flat -variable _bp_en($i) -selectcolor $color \
      -command "$this bp_able $i" -bg $bg1 -activebackground $bg1
d248 1
a248 1
    label $twin.num$i -text "$number " -relief flat -anchor w -font global/fixed -bg $bg1
d259 1
a259 1
    label $twin.thread$i -text "$thread " -relief flat -anchor w -font global/fixed -bg $bg1
d261 3
a263 3
  label $twin.file$i -text "$file " -relief flat -anchor w -font global/fixed -bg $bg1 
  label $twin.line$i -text "[$bp_event get line] " -relief flat -anchor w -font global/fixed -bg $bg1
  label $twin.func$i -text "[$bp_event get function] " -relief flat -anchor w -font global/fixed -bg $bg1 
d265 1
a265 1
    label $twin.pass$i -text "[$bp_event get pass_count] " -relief flat -anchor w -font global/fixed -bg $bg1
d378 1
a378 1
      $twin.${thing}${i}  configure -fg [pref get gdb/font/select_fg] -bg $bg1
d400 1
a400 2
    $twin.${thing}${r} configure -fg [pref get gdb/font/select_fg] \
      -bg [pref get gdb/font/select_bg]
@


1.12
log
@2002-03-06  Martin M. Hunt  <hunt@@redhat.com>

	* library/bpwin.itb: Left-justify the labels in
	the table.
@
text
@d28 6
@


1.11
log
@2002-03-05  Martin M. Hunt  <hunt@@redhat.com>

	* library/prefs.tcl (pref_read): If a preference specifies
	"src-font", substitute "global/fixed".
	(pref_set_defaults): Change defaults from "src-font" to
	"global/fixed". Do not create font object "src-font". Do
	not add hook to trace its changes.
	(pref_src-font_trace): Remove.

	* library/console.itb (Console::_update_option): Remove
	font update because this happens automatically.

	* library/globalpref.itb: No need to set
	changed flag for fonts; updates happen automatically
	when prefs are updated.

	* library/bpwin.itb: Replaced src-font with global/fixed.
	* library/browserwin.itb: Ditto.
	* library/mempref.itb: Ditto.
	* library/memwin.itb: Ditto.
	* library/process.itb: Ditto.
	* library/regwin.itb: Ditto.
	* library/srcbar.itcl: Ditto.
	* library/srcpref.itb: Ditto.
	* library/srctextwin.itb: Ditto.
	* library/srcwin.itb: Ditto.
	* library/stackwin.itb: Ditto.
	* library/tdump.tcl: Ditto.
	* library/tracedlg.tcl: Ditto.
	* library/variables.tcl: Ditto.
	* library/watch.tcl: Ditto.
@
text
@d241 1
a241 1
    label $twin.num$i -text "$number " -relief flat -anchor e -font global/fixed -bg $bg1
d243 1
a243 1
  label $twin.addr$i -text "[$bp_event get address] " -relief flat -anchor e -font global/fixed -bg $bg1
d252 1
a252 1
    label $twin.thread$i -text "$thread " -relief flat -anchor e -font global/fixed -bg $bg1
d254 3
a256 3
  label $twin.file$i -text "$file " -relief flat -anchor e -font global/fixed -bg $bg1
  label $twin.line$i -text "[$bp_event get line] " -relief flat -anchor e -font global/fixed -bg $bg1
  label $twin.func$i -text "[$bp_event get function] " -relief flat -anchor e -font global/fixed -bg $bg1
d258 1
a258 1
    label $twin.pass$i -text "[$bp_event get pass_count] " -relief flat -anchor e -font global/fixed -bg $bg1
@


1.10
log
@	* library/bpwin.ith (_select_and_popup): New private method.
	* library/bpwin.itb (bp_select): Don't bind to Button-3.
	(build_win): Bind Button-3 to _select_and_popup.
	(_select_and_popup): New private method.
@
text
@d1 2
a2 2
# Breakpoint window for GDBtk.
# Copyright 1997, 1998, 1999, 2001 Red Hat, Inc.
d67 1
a67 1
      -font src-font
d70 1
a70 1
    -font src-font
d72 1
a72 1
    -font src-font
d74 1
a74 1
    -font src-font
d76 1
a76 1
    -font src-font
d78 1
a78 1
    -font src-font
d82 1
a82 1
      -anchor center -font src-font
d241 1
a241 1
    label $twin.num$i -text "$number " -relief flat -anchor e -font src-font -bg $bg1
d243 1
a243 1
  label $twin.addr$i -text "[$bp_event get address] " -relief flat -anchor e -font src-font -bg $bg1
d252 1
a252 1
    label $twin.thread$i -text "$thread " -relief flat -anchor e -font src-font -bg $bg1
d254 3
a256 3
  label $twin.file$i -text "$file " -relief flat -anchor e -font src-font -bg $bg1
  label $twin.line$i -text "[$bp_event get line] " -relief flat -anchor e -font src-font -bg $bg1
  label $twin.func$i -text "[$bp_event get function] " -relief flat -anchor e -font src-font -bg $bg1
d258 1
a258 1
    label $twin.pass$i -text "[$bp_event get pass_count] " -relief flat -anchor e -font src-font -bg $bg1
@


1.9
log
@2001-11-05  Martin M. Hunt  <hunt@@redhat.com>

	* library/stackwin.itb (StcakWin::reconfig): Destroy sbox
	if it exists.

	* library/process.itb (ProcessWin::reconfig): Destroy sbox
	if it exists. This fixes reconfig failures on Windows. Also
	destroy slbox.

	* library/bpwin.itb (BpWin::reconfig): Destroy sbox if
	it exists.This fixes reconfig failures on Windows. Also
	destroy sf

	* library/tdump.tcl (TdumpWin::reconfig): Delete sbox
	and stext then rebuild window.
@
text
@d268 1
a371 1
      bind $twin.${thing}${i} <3> break
a388 4
    foreach thing $zz {
      bind $twin.${thing}${r} <3> break
    }

a394 1
    bind $twin.${thing}${r}  <3> "tk_popup $Menu %X %Y"
d422 15
@


1.8
log
@	* library/bpwin.itb (bp_select): Use standard preferences
	for selection fg & bg, not tixOption database.

	* process.itb, tracedlg.tcl: Remove all traces of those
	three evil little letters, "t", "i", "x".
@
text
@d701 2
@


1.7
log
@	* library/bpwin.itb (build_win): Get rid of tixScrolledWindow
	and use iwidgets::scrolledframe until something better comes
	along.
@
text
@d360 1
a360 1
  global tixOption _bp_en _bp_disp
d370 1
a370 1
      $twin.${thing}${i}  configure -fg $tixOption(fg) -bg $bg1
d397 2
a398 1
    $twin.${thing}${r}  configure -fg $tixOption(select_fg) -bg $tixOption(select_bg)
@


1.6
log
@	* library/session.tcl (session_save): Save breakpoints.
	(SESSION_serialize_bps): New proc.
	(SESSION_recreate_bps): New proc.
	(session_load): Recreate breakpoints.
	* library/util.tcl (bp_exists): Expect user specification in
	breakpoint info.
	* library/srctextwin.itb (SrcTextWin::showBPBalloon): Expect user
	specification in breakpoint info.
	* library/gdbevent.itb (BreakpointEvent::_init): Initialize
	_user_specification.
	(BreakpointEvent::get): Handle user_specification.
	* library/gdbevent.ith (BreakpointEvent): Added
	_user_specification field.
	* library/bpwin.itb (BpWin::bp_store): Expect user specification
	and use it when saving.
	(BpWin::bp_type): Expect user specification.
	* generic/gdbtk-bp.c (BREAKPOINT_IS_WATCHPOINT): New macro.
	(gdb_get_breakpoint_info): Added `user specification' to result.
@
text
@d41 2
a42 2
  global _bp_en _bp_disp tixOption tcl_platform
  set bg1 $tixOption(input1_bg)
a43 1
  frame $itk_interior.f -bg $bg1
d45 5
a49 1
    tixScrolledWindow $itk_interior.f.sw -scrollbar both -sizebox 1
d51 2
a52 1
    tixScrolledWindow $itk_interior.f.sw -scrollbar auto
d54 9
a62 2
  set twin [$itk_interior.f.sw subwidget window]
  $twin configure -bg $bg1
d192 1
a192 3
  pack $itk_interior.f.sw -side left -expand true -fill both
  pack $itk_interior.f -side top -expand true -fill both

@


1.5
log
@Breakpoint/tracepoint event notification using new event model...

	* generic/gdbtk-cmds.c (gdb_set_bp): Use create_breakpoint_hook
	to notify gui of changes.
	(gdb_set_bp_addr): Ditto.
	(gdb_get_breakpoint_info): Update comments to match reality.
	* generic/gdbtk-hooks.c (breakpoint_notify): Only pass the
	breakpoint number which generated the event.
	(tracepoint_notify): Ditto for tracepoints.
	* library/interface.tcl (gdb_breakpoint_change_hook): Mark
	as deprecated and comment out definition.
	(gdbtk_tcl_breakpoint): Use new GDBEvent event "breakpoint"
	to notify rest of UI about breakpoint event.
	(gdbtk_tcl_tracepoint): Ditto for "tracepoint" event.
	* library/bpwin.ith (update): Renamed to "breakpoint".
	(breakpoint): New public method.
	(tracepoint): New public method.
	(bp_add): Take event as argument instead of number.
	(bp_modify): Ditto.
	(bp_delete): Ditto.
	* library/bpwin.itb (constructor): Remove
	gdb_breakpoint_changed_hook.
	(destructor): Ditto.
	(build_win): Insert any existing breakpoints by
	making BreakpointEvents for them.
	(breakpoint): Renamed from "update" to handle
	breakpoint events.
	Remove code to deal with tracepoints.
	(tracepoint): New method to handle tracepoint
	events.
	(bp_add): Deal with breakpoint events, not breakpoint
	numbers.
	(bp_modify): Ditto.
	(bp_delete): Ditto.
	* library/srctextwin.ith: Inherit from GDBWin.
	(breakpoint): New public method.
	(tracepoint): New public method.
	* library/srctextwin.itb (constructor): Remove
	gdb_breakpoint_changed_hook.
	(destructor): Ditto.
	(breakpoint): New method to handle breakpoint event.
	(tracepoint): New method to handle tracepoint event.
	(do_bp): Handle duplicate breakpoints for asm, too.
	(remove_bp_at_line): Delete breakpoints by number, not
	linespec. clear_command removes breakpoints from the
	breakpoint_chain BEFORE deleting the breakpoint. delete_command
	does this afterward (so we can call gdb_get_breakpoint_info on
	an about-to-be-deleted breakpoint).
@
text
@d301 1
a301 1
	       enable_p disp ignore cmds thread hit_count} \
d306 3
a308 1
    if {$file != ""} {
d315 1
d548 1
a548 1
    ignore_count commands cond thread hit_count
@


1.4
log
@	* bpwin.itb (BpWin::goto_bp): Handle multiple source windows.
	* srctextwin.itb (SrcTextWin::get_file): New method.
	(SrcTextWin::set_tag_to_stack): New method.
	* srctextwin.ith (get_file): Declare.
	* srcwin.ith (update_hook_init, window_list, pc_window): New
	common variables.
	(_choose_window, choose_and_update, is_fixed, get_file): Declare.
	* srcwin.itb (SrcWin::_choose_window): New method.
	(SrcWin::choose_and_update): Likewise.
	(SrcWin::_update): Renamed from update.  Now private.  Added `loc'
	argument.
	(SrcWin::get_file): New method.
	(SrcWin::is_fixed): Likewise.
	(SrcWin::constructor): Only add update hook once.  Append this
	object to window list.
	(SrcWin::destructor): Don't add update hook.  Remove this object
	from window list.  Clear pc_window if necessary.
	(SrcWin::get_top): New method.
	(SrcWin::_set_tag_to_stack): New method.
	(SrcWin::choose_and_display): New method.
@
text
@d2 1
a2 1
# Copyright 1997, 1998, 1999 Cygnus Solutions
a20 1
  add_hook gdb_breakpoint_change_hook "$this update"
d34 1
a34 3
body BpWin::destructor {} {
  remove_hook gdb_breakpoint_change_hook "$this update"
}
d168 3
a170 1
      bp_add $i
d175 3
a177 1
      bp_add $i 1
d189 1
a189 1
body BpWin::bp_add { bpnum {tracepoint 0}} {
d191 6
a196 1
  
d198 1
a198 4
    set bpinfo [gdb_get_tracepoint_info $bpnum]
    lassign $bpinfo file func line pc enabled pass_count \
      step_count thread hit_count actions
    set disposition tracepoint
a200 3
    set bpinfo [gdb_get_breakpoint_info $bpnum]
    lassign $bpinfo file func line pc type enabled disposition \
      ignore_count commands cond thread hit_count
d204 1
a204 1
  debug "bp_add bpnum=$bpnum thread=$thread show=$show_threads"
d206 1
a206 1
  set _bp_en($i) $enabled
d232 1
a232 1
    label $twin.num$i -text "$bpnum " -relief flat -anchor e -font src-font -bg $bg1
d234 1
a234 1
  label $twin.addr$i -text "$pc " -relief flat -anchor e -font src-font -bg $bg1
d246 2
a247 3
  label $twin.line$i -text "$line " -relief flat -anchor e -font src-font -bg $bg1
  label $twin.func$i -text "$func " -relief flat -anchor e -font src-font -bg $bg1
  
d249 1
a249 1
    label $twin.pass$i -text "$pass_count " -relief flat -anchor e -font src-font -bg $bg1
d278 1
a278 1
  set index_to_bpnum($i) $bpnum
d419 1
a419 1
body BpWin::bp_modify { bpnum {tracepoint 0} } {
d422 5
a427 3
    set bpinfo [gdb_get_tracepoint_info $bpnum]
    lassign $bpinfo file func line pc enabled pass_count \
      step_count thread hit_count actions
a430 3
    set bpinfo [gdb_get_breakpoint_info $bpnum]
    lassign $bpinfo file func line pc type enabled disposition \
      ignore_count commands cond thread hit_count
d436 1
a436 1
    if { $bpnum == $index_to_bpnum($i)
d444 1
a444 1
    debug "ERROR: breakpoint number $bpnum not found!"
d448 2
a449 2
  if {$_bp_en($i) != $enabled} {
    set _bp_en($i) $enabled
d473 1
a473 1
    $twin.num$i configure  -text "$bpnum "
d475 1
a475 1
  $twin.addr$i configure -text "$pc " 
d487 2
a488 2
  $twin.line$i configure  -text "$line "
  $twin.func$i configure  -text "$func "
d490 1
a490 1
    $twin.pass$i configure  -text "$pass_count "
d563 2
a564 1
body BpWin::bp_delete { bpnum } {
d566 1
a566 1
    if { $bpnum == $index_to_bpnum($i) } {
d589 2
a590 1
#  METHOD:  update - update widget when a breakpoint changes
d592 4
a595 2
body BpWin::update {action bpnum addr {linenum {}} {file {}} {type 0} args} {
  #debug "bp update $action $bpnum $type"
d597 5
a601 4
  if {$type == "tracepoint"} {
    set tp 1
  } else {
    set tp 0
d603 10
d615 4
a618 4
    modify { bp_modify $bpnum $tp}
    create { bp_add $bpnum $tp}
    delete { bp_delete $bpnum }
    default { debug "Unknown breakpoint action: $action" }
@


1.3
log
@Reverted erroneous checkin.  Sorry about that.
@
text
@d691 1
a691 4
  # !! FIXME: multiple source windows?
  set src [lindex [ManagedWin::find SrcWin] 0]
  set info [gdb_loc *$pc]
  $src location BROWSE_TAG $info
a692 2


@


1.2
log
@	* prefs.tcl (pref_save): Put version number into file.  Added
	`session' to list of top-level keys.  Allow keys with many `/'s.
	(pref_read): Recognize version number.
	(escape_value): Generate URL-style encoding.
	(unescape_value): Added `version' argument.  Handle URL decoding.
@
text
@d691 4
a694 1
  SrcWin::choose_and_display BROWSE_TAG [gdb_loc *$pc]
d696 2
@


1.1
log
@Initial revision
@
text
@d691 1
a691 4
  # !! FIXME: multiple source windows?
  set src [lindex [ManagedWin::find SrcWin] 0]
  set info [gdb_loc *$pc]
  $src location BROWSE_TAG $info
a692 2


@


1.1.1.1
log
@import insight-2000-02-04 snapshot (2nd try)
@
text
@@
