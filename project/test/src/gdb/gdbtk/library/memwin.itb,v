head	1.26;
access;
symbols
	insight_7_6-2013-04-10-branchpoint:1.26
	gdb_7_6-branch:1.26.0.12
	gdb_7_5-branch:1.26.0.10
	gdb_7_4-branch:1.26.0.8
	gdb_7_3-branch:1.26.0.6
	gdb_7_1-branch:1.26.0.4
	gdb_7_0-branch:1.26.0.2
	arc-sim-20090309:1.25
	arc-insight_6_8-branch:1.25.0.6
	arc-insight_6_8-branchpoint:1.25
	insight_6_8-branch:1.25.0.4
	insight_6_8-branchpoint:1.25
	gdb_6_8-branch:1.25.0.2
	insight_6_6-20070208-release:1.24
	gdb_6_6-branch:1.24.0.4
	gdb_6_6-2006-11-15-branchpoint:1.24
	insight_6_5-20061003-release:1.24
	gdb_6_5-branch:1.24.0.2
	gdb_6_5-2006-05-14-branchpoint:1.24
	gdb-csl-gxxpro-6_3-branch:1.23.0.4
	gdb-csl-gxxpro-6_3-branchpoint:1.23
	gdb_6_4-branch:1.23.0.2
	gdb_6_4-2005-11-01-branchpoint:1.23
	gdb_6_1-2004-04-05-release:1.22
	gdb_6_1-branch:1.22.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.22
	gdb_6_0-2003-10-04-release:1.22
	gdb_6_0-branch:1.22.0.2
	gdb_6_0-2003-06-23-branchpoint:1.22
	gdb_5_3-2002-12-12-release:1.19
	gdb_5_3-branch:1.19.0.2
	gdb_5_3-2002-09-04-branchpoint:1.19
	gdb_5_2_1-2002-07-23-release:1.15
	gdb_5_2-2002-04-29-release:1.15
	gdb_5_2-branch:1.15.0.2
	gdb_5_2-2002-03-03-branchpoint:1.15
	gdb_5_1_1-2002-01-24-release:1.9
	cygnus_cvs_20020108_pre:1.13
	gdb_5_1_0_1-2002-01-03-branch:1.9.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.9
	gdb_5_1-2001-11-21-release:1.9
	gdb_s390-2001-09-26-branch:1.9.0.4
	gdb_s390-2001-09-26-branchpoint:1.9
	gdb_5_1-2001-07-29-branch:1.9.0.2
	gdb_5_1-2001-07-29-branchpoint:1.9
	dberlin-typesystem-branch:1.8.0.2
	dberlin-typesystem-branchpoint:1.8
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	insight-2000-02-04:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.26
date	2009.04.24.03.28.12;	author kseitz;	state Exp;
branches;
next	1.25;

1.25
date	2008.02.09.01.23.42;	author kseitz;	state Exp;
branches;
next	1.24;

1.24
date	2005.12.23.18.26.50;	author eliz;	state Exp;
branches;
next	1.23;

1.23
date	2005.09.01.03.16.03;	author kseitz;	state Exp;
branches;
next	1.22;

1.22
date	2002.11.13.20.17.10;	author hunt;	state Exp;
branches;
next	1.21;

1.21
date	2002.10.15.21.19.51;	author hunt;	state Exp;
branches;
next	1.20;

1.20
date	2002.09.20.06.03.19;	author hunt;	state Exp;
branches;
next	1.19;

1.19
date	2002.08.01.01.19.02;	author kseitz;	state Exp;
branches;
next	1.18;

1.18
date	2002.06.07.09.22.44;	author hunt;	state Exp;
branches;
next	1.17;

1.17
date	2002.03.06.23.56.03;	author kseitz;	state Exp;
branches;
next	1.16;

1.16
date	2002.03.05.22.22.19;	author hunt;	state Exp;
branches;
next	1.15;

1.15
date	2002.01.15.19.52.01;	author kseitz;	state Exp;
branches;
next	1.14;

1.14
date	2002.01.11.23.58.10;	author hunt;	state Exp;
branches;
next	1.13;

1.13
date	2001.12.18.21.35.56;	author kseitz;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.19.18.43.19;	author hunt;	state Exp;
branches;
next	1.11;

1.11
date	2001.11.01.20.49.21;	author kseitz;	state Exp;
branches;
next	1.10;

1.10
date	2001.08.09.20.43.54;	author kseitz;	state Exp;
branches;
next	1.9;

1.9
date	2001.07.20.23.26.00;	author hunt;	state Exp;
branches;
next	1.8;

1.8
date	2001.06.04.15.49.53;	author kseitz;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.31.20.32.58;	author kseitz;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.31.15.21.40;	author kseitz;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.25.21.06.18;	author kseitz;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.22.19.10.06;	author kseitz;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.22.19.02.54;	author kseitz;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.15.18.31.38;	author tromey;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.07.00.19.42;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.07.00.19.42;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.26
log
@	* library/mempref.itb (build_win): Replace libgui's "Labelledframe"
	with the iwidget's LabeledFrame. Replaced all occurrances.
	* libarary/memwin.itb (create_prefs): Use ManagedWin::open_dlg
	instead of ManagedWin::open.
@
text
@# Memory display window class definition for Insight.
# Copyright (C) 1998, 1999, 2001, 2002, 2005, 2008, 2009 Red Hat, Inc.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License (GPL) as published by
# the Free Software Foundation; either version 2 of the License, or (at
# your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# ------------------------------------------------------------------
#  METHOD:  constructor - build the dialog
# ------------------------------------------------------------------
itcl::body MemWin::constructor {args} {
  global _mem
  debug $args
  eval itk_initialize $args

  set top [winfo toplevel $itk_interior]
  gdbtk_busy

  set _mem($this,enabled) 1

  if {![info exists type(1)]} {
    set type(1) char
    set type(2) short
    set type(4) int
    set type(8) "long long"
  }

  if {[pref getd gdb/mem/menu] != ""} {
    set mbar 0
  }

  # Load defaults from preferences.
  set size [pref getd gdb/mem/size]
  set numbytes [pref getd gdb/mem/numbytes]
  set format [pref getd gdb/mem/format]
  set ascii [pref getd gdb/mem/ascii]
  set ascii_char [pref getd gdb/mem/ascii_char]
  set bytes_per_row [pref getd gdb/mem/bytes_per_row]
  set color [pref getd gdb/mem/color]

  init_addr_exp
  build_win
  gdbtk_idle
}

# ------------------------------------------------------------------
#  METHOD:  destructor - destroy the dialog
# ------------------------------------------------------------------
itcl::body MemWin::destructor {} {
  if {[winfo exists $prefs_win]} {
    $prefs_win cancel
  }
}


# ------------------------------------------------------------------
#  METHOD:  build_win - build the main memory window
# ------------------------------------------------------------------
itcl::body MemWin::build_win {} {
  global gdb_ImageDir _mem ${this}_memval

  set maxlen 0
  set maxalen 0
  set saved_value ""

  if { $mbar } {
    menu $itk_interior.m -tearoff 0
    $top configure -menu $itk_interior.m
    $itk_interior.m add cascade -menu $itk_interior.m.addr \
      -label "Addresses" -underline 0
    set m [menu $itk_interior.m.addr]
    $m add check -label " Auto Update" -variable _mem($this,enabled) \
      -underline 1 -command "after idle $this toggle_enabled"
    $m add command -label " Update Now" -underline 1 \
      -command [code $this _update_address 1] -accelerator {Ctrl+U}
    $m add separator
    $m add command -label " Preferences..." -underline 1 \
      -command "$this create_prefs"
  }

  # Numcols = number of columns of data
  # numcols = number of columns in table (data plus headings plus ASCII)
  # if numbytes are 0, then use window size to determine how many to read
  if {$numbytes == 0} {
    set Numrows 8
  } else {
    set Numrows [expr {$numbytes / $bytes_per_row}]
  }
  set numrows [expr {$Numrows + 1}]

  set Numcols [expr {$bytes_per_row / $size}]
  if {$ascii} {
    set numcols [expr {$Numcols + 2}]
  } else {
    set numcols [expr {$Numcols + 1}]
  }

  itk_component add table {
    ::table $itk_interior.t -titlerows 1 -titlecols 1 -variable ${this}_memval \
      -roworigin -1 -colorigin -1 -bg $::Colors(textbg) -fg $::Colors(textfg) \
      -browsecmd "$this changed_cell %s %S" -font global/fixed\
      -colstretch unset -rowstretch unset -selectmode single \
      -xscrollcommand "$itk_interior.sx set" -resizeborders none \
      -cols $numcols -rows $numrows -autoclear 1
  } {
    keep -foreground
    keep -insertbackground
    keep -highlightcolor
    keep -highlightbackground
  }
  
  if {$numbytes} {
    $itk_component(table) configure -yscrollcommand "$itk_interior.sy set"
    scrollbar $itk_interior.sy -command [list $itk_component(table) yview]
  } else {
    $itk_component(table) configure -rowstretchmode none
  }
  scrollbar $itk_interior.sx -command [list $itk_component(table) xview] -orient horizontal
  $itk_component(table) tag config sel -bg [$itk_component(table) cget -bg] -relief sunken
  $itk_component(table) tag config active -relief sunken -wrap 0 \
    -bg $::Colors(sbg) -fg $::Colors(sfg)
  $itk_component(table) tag config title -bg $::Colors(bg) -fg $::Colors(fg)

  # rebind all events that use tkTableMoveCell to our local version
  # because we don't want to move into the ASCII column if it exists
  bind $itk_component(table) <Up>		"$this memMoveCell %W -1  0; break"
  bind $itk_component(table) <Down>		"$this memMoveCell %W  1  0; break"
  bind $itk_component(table) <Left>		"$this memMoveCell %W  0 -1; break"
  bind $itk_component(table) <Right>	"$this memMoveCell %W  0  1; break"
  bind $itk_component(table) <Return>	"$this memMoveCell %W 0 1; break"
  bind $itk_component(table) <KP_Enter>	"$this memMoveCell %W 0 1; break"

  # bind button 3 to popup
  bind $itk_component(table) <3> "$this do_popup %X %Y"

  # bind Paste and button2 to the paste function
  # this is necessary because we want to not just paste the
  # data into the cell, but we also have to write it
  # out to real memory
  bind $itk_component(table) <ButtonRelease-2> [format {after idle %s paste %s %s} $this %x %y]
  bind $itk_component(table) <<Paste>> [format {after idle %s paste %s %s} $this %x %y]

  menu $itk_component(table).menu -tearoff 0
  bind_plain_key $top Control-u [code $this _update_address 1]

  # bind resize events
  bind $itk_interior <Configure> "$this newsize %h"

  frame $itk_interior.f
  iwidgets::spinint $itk_interior.f.cntl -labeltext " Address " -width 20 \
    -command "after idle $this update_address_cb" \
    -increment "after idle $this incr_addr -1" \
    -decrement "after idle $this incr_addr 1" -foreground  $::Colors(textfg) \
    -validate {}  -textbackground $::Colors(textbg) 
  $itk_interior.f.cntl delete 0 end
  $itk_interior.f.cntl insert end $addr_exp

  label $itk_interior.f.endian -text "Target is [gdbtk_endian] endian"

  balloon register [$itk_interior.f.cntl childsite].uparrow \
    "Scroll Up (Decrement Address)"
  balloon register [$itk_interior.f.cntl childsite].downarrow \
    "Scroll Down (Increment Address)"
  if {!$mbar} {
    button $itk_interior.f.upd -command [code $this _update_address 1] \
      -image [image create photo -file [::file join $gdb_ImageDir check.gif]]
    balloon register $itk_interior.f.upd "Update Now"
    checkbutton $itk_interior.cb -variable _mem($this,enabled) -command "$this toggle_enabled"
    balloon register $itk_interior.cb "Toggles Automatic Display Updates"
    grid $itk_interior.f.upd $itk_interior.f.cntl $itk_interior.f.endian -sticky ew -padx 5
  } else {
    grid $itk_interior.f.cntl x $itk_interior.f.endian -sticky e
    grid columnconfigure $itk_interior.f 1 -weight 1
  }

  # draw top border
  set col 0
  for {set i 0} {$i < $bytes_per_row} { incr i $size} {
    set ${this}_memval(-1,$col) [format " %X" $i]
    incr col
  }

  if {$ascii} {
    set ${this}_memval(-1,$col) ASCII
  }

  # fill initial display
  if {$nb} {
    _update_address 0
  }

  if {!$mbar} {
    grid $itk_interior.f x -row 0 -column 0 -sticky nws
    grid $itk_interior.cb -row 0 -column 1 -sticky news
  } else {
    grid $itk_interior.f -row 0 -column 0 -sticky news
  }
  grid $itk_component(table) -row 1 -column 0 -sticky news
  if {$numbytes} { grid $itk_interior.sy -row 1 -column 1 -sticky ns }
  grid $itk_interior.sx -sticky ew
  grid columnconfig  $itk_interior 0 -weight 1
  grid rowconfig  $itk_interior 1 -weight 1
  focus $itk_interior.f.cntl

  window_name "Memory"
}

# ------------------------------------------------------------------
#  METHOD:  paste - paste callback. Update cell contents after paste
# ------------------------------------------------------------------
itcl::body MemWin::paste {x y} {
  edit [$itk_component(table) index @@$x,$y]
}

# ------------------------------------------------------------------
#  METHOD:  validate - because the control widget wants this
# ------------------------------------------------------------------
itcl::body MemWin::validate {val} {
  return $val
}

# ------------------------------------------------------------------
#  METHOD:  create_prefs - create memory preferences dialog
# ------------------------------------------------------------------
itcl::body MemWin::create_prefs {} {
  if {$Running} { return }

  # make sure row height is set
  if {$rheight == ""} {
    set rheight [lindex [$itk_component(table) bbox 0,0] 3]
  }

  set prefs_win [ManagedWin::open_dlg MemPref -force -over $this\
		   -transient -win $this \
		   -size $size -format $format -numbytes $numbytes \
		   -bpr $bytes_per_row -ascii $ascii \
		   -ascii_char $ascii_char -color $color]
}

# ------------------------------------------------------------------
#  METHOD:  changed_cell - called when moving from one cell to another
# ------------------------------------------------------------------
itcl::body MemWin::changed_cell {from to} {
  #debug "moved from $from to $to"
  #debug "value = [$itk_component(table) get $from]"
  if {$saved_value != ""} {
    if {$saved_value != [$itk_component(table) get $from]} {
      edit $from
    }
  }
  set saved_value [$itk_component(table) get $to]
}

# ------------------------------------------------------------------
#  METHOD:  edit - edit a cell
# ------------------------------------------------------------------
itcl::body MemWin::edit { cell } {
  global _mem ${this}_memval

  #debug "edit $cell"

  if {$Running || $cell == ""} { return }
  set rc [split $cell ,]
  set row [lindex $rc 0]
  set col [lindex $rc 1]
  set val [$itk_component(table) get $cell]

  if {$col == $Numcols} { 
    # editing the ASCII field
    set addr [gdb_incr_addr $current_addr [expr {$bytes_per_row * $row}]]
    set start_addr $addr

    # calculate number of rows to modify
    set len [string length $val]
    set rows 0
    while {$len > 0} { 
      incr rows
      set len [expr {$len - $bytes_per_row}]
    }
    set nb [expr {$rows * $bytes_per_row}]

    # now process each char, one at a time
    foreach c [split $val ""] {
      if {$c != $ascii_char} {
	scan $c %c char
	if {[catch {gdb_set_mem $addr [format %02x $char] 1} res]} {
	  error_dialog $res

	  # reset value
	  set ${this}_memval($row,$col) $saved_value
	  return
	}
      }
      set addr [gdb_incr_addr $addr]
    }
    set addr $start_addr
    set nextval 0
    # now read back the data and update the widget
    catch {gdb_update_mem ${this}_memval $addr $format $size $nb $bytes_per_row $ascii_char} vals
    return
  }

  # calculate address based on row and column
  set addr [gdb_incr_addr $current_addr [expr {$bytes_per_row * $row + $size * $col}]]
  #debug "  edit $row,$col         $addr = $val"

  # Pad the value with zeros, if necessary
  set s [expr {$size * 2}]
  set val [format "0x%0${s}x" $val]

  # set memory
  #debug "set_mem $addr $val $size"
  if {[catch {gdb_set_mem $addr $val $size} res]} {
    error_dialog $res

    # reset value
    set ${this}_memval($row,$col) $saved_value
    return
  }

  # read it back
  # FIXME - HACK ALERT - This call causes trouble with remotes on Windows. 
  # This routine is in fact called from within an idle handler triggered by
  # memMoveCell.  Something evil happens in that handler that causes gdb to
  # start writing this changed value into all the visible cells...
  # I have not figured out the cause of this, so for now I commented this
  # line out.  It will only matter if the write did not succeed, and this was
  # not a very good way to tell the user about that anyway...
  #
  # catch {gdb_update_mem $addr $format $size $size $size ""} val
  # delete whitespace in response
  set val [string trimright $val]
  set val [string trimleft $val]
  set ${this}_memval($row,$col) $val
}


# ------------------------------------------------------------------
#  METHOD:  toggle_enabled - called when enable is toggled
# ------------------------------------------------------------------
itcl::body MemWin::toggle_enabled {} {
  global _mem

  if {$Running} { return }
  if {$_mem($this,enabled)} {
    _update_address 1
    set state normal
    set bg $::Colors(textbg)
  } else {
    set bg $::Colors(bg)
    set state disabled
  }
  $itk_component(table) config -background $bg -state $state
}

# ------------------------------------------------------------------
#  METHOD:  update - update widget after every PC change
# ------------------------------------------------------------------
itcl::body MemWin::update {event} {
  global _mem
  if {$_mem($this,enabled)} {
    _update_address 0
  }
}

# ------------------------------------------------------------------
#  METHOD:  idle - memory window is idle, so enable menus
# ------------------------------------------------------------------
itcl::body MemWin::idle {event} {
  # Fencepost
  set Running 0

  # Cursor
  cursor {}

  if {[winfo exists $itk_interior.m.addr]} {
    # Enable menus
    if {$mbar} {
      for {set i 0} {$i <= [$itk_interior.m.addr index last]} {incr i} {
	if {[$itk_interior.m.addr type $i] != "separator"} {
	  $itk_interior.m.addr entryconfigure $i -state normal
	}
    }
    }
    
    # Enable control
    $itk_interior.f.cntl configure -state normal
  }
}


# ------------------------------------------------------------------
#  METHOD: busy - BusyEvent handler
#                 Disable menus 'cause we're busy updating things.
# ------------------------------------------------------------------
itcl::body MemWin::busy {event} {
  # Fencepost
  set Running 1

  # cursor
  cursor watch

  # go away if window is not finished drawing
  if {![winfo exists $itk_interior.f.cntl]} { return }
  
  # Disable menus
  if {$mbar} {
    for {set i 0} {$i <= [$itk_interior.m.addr index last]} {incr i} {
      if {[$itk_interior.m.addr type $i] != "separator"} {
	$itk_interior.m.addr entryconfigure $i -state disabled
      }
    }
  }

  # Disable control
  $itk_interior.f.cntl configure -state disabled
}

# ------------------------------------------------------------------
#  METHOD: newsize - calculate how many rows to display when the
#  window is resized.
# ------------------------------------------------------------------
itcl::body MemWin::newsize {height} {

  if {$dont_size || $Running} {
    return 
  }
  
  # only add rows if numbytes is zero
  if {$numbytes == 0} {
    ::update idletasks

    # make sure row height is set
    if {$rheight == ""} {
      set rheight [lindex [$itk_component(table) bbox 0,0] 3]
    }

    set theight [winfo height $itk_component(table)]
    set Numrows [expr {$theight / $rheight}]
    $itk_component(table) configure -rows $Numrows
    _update_address 1
  }
}

itcl::body MemWin::_update_address {make_busy} {
  if {$make_busy} {
    gdbtk_busy
  }
  update_address [string trimleft [$itk_interior.f.cntl get]]
  if {$make_busy} {
    gdbtk_idle
  }
}

# ------------------------------------------------------------------
#  METHOD: update_address_cb - address entry widget callback
# ------------------------------------------------------------------
itcl::body MemWin::update_address_cb {} {
  set new_entry 1
  _update_address 1
}

# ------------------------------------------------------------------
#  METHOD: update_address - update address and data displayed
# ------------------------------------------------------------------
itcl::body MemWin::update_address {addr} {

  set bad_expr 0
  set saved_addr $current_addr
  if {[string match {[a-zA-Z_&0-9\*]*} $addr]} {
    # Looks like an expression
    set retVal [catch {gdb_eval "$addr" x} current_addr]
    #debug "retVal=$retVal current_addr=$current_addr"
    if {$retVal || [string match "No symbol*" $current_addr] || \
	  [string match "Invalid *" $current_addr]} {
      BadExpr $current_addr
      return
    }
    if {[string match {\{*} $current_addr]} {
      set current_addr [lindex $current_addr 1]
      if {$current_addr == ""} {
	return
      }
    }
  } elseif {[regexp {\$[a-zA-Z_]} $addr]} {
    # Looks like a local variable
    set retVal [catch {gdb_eval "$addr" x} current_addr]
    #debug "retVal=$retVal current_addr=$current_addr"
    if {$retVal} {
      BadExpr $current_addr
      return
    }
    if {$current_addr == "void"} {
      BadExpr "No Local Variable Named \"$addr\""
      return
    }
  } else {
    # something really strange, like "0.1" or ""
    BadExpr "Can't Evaluate \"$addr\""
    return
  }

  # Check for spaces - this can happen with gdb_eval and $pc, for example.
  set index [string first \  $current_addr]
  if {$index != -1} {
    incr index -1
    set current_addr [string range $current_addr 0 $index]
  }
  
  set addr_exp $addr

  # set table background
  $itk_component(table) config -bg $::Colors(textbg) -state normal
  catch {update_addr}
}

# ------------------------------------------------------------------
#  METHOD:  BadExpr - handle a bad expression
# ------------------------------------------------------------------
itcl::body MemWin::BadExpr {errTxt} {
  if {$new_entry} {
    tk_messageBox -type ok -icon error -message $errTxt
    set new_entry 0
  }
  # set table background to gray
  $itk_component(table) config -bg $::Colors(bg) -state disabled
  set current_addr $saved_addr
  set saved_addr ""
  set bad_expr 1
}

# ------------------------------------------------------------------
#  METHOD:  incr_addr - callback from control widget to increment
#  the current address.
# ------------------------------------------------------------------
itcl::body MemWin::incr_addr {num} {
  if {$current_addr == ""} {
    return
  }
  set old_addr $current_addr
  set current_addr [gdb_incr_addr $current_addr [expr {$bytes_per_row * $num}]]

  # A memory address less than zero is probably not a good thing...
  #

  if {($num < 0 && [gdb_eval "$current_addr > $old_addr"]) \
      ||($num > 0 && [gdb_eval "$current_addr < $old_addr"]) } {
    bell
    set current_addr $old_addr
    return
  }
  $itk_component(table) config -bg $::Colors(textbg) -state normal
  $itk_interior.f.cntl clear
  $itk_interior.f.cntl insert 0 $current_addr
  _update_address 1
}


# ------------------------------------------------------------------
#  METHOD:  update_addr - read in data starting at $current_addr
#  This is just a helper function for update_address. 
# ------------------------------------------------------------------
itcl::body MemWin::update_addr {} {
  global _mem ${this}_memval

    set row 0

  if {$numbytes == 0} {
    set nb [expr {$Numrows * $bytes_per_row}]
  } else {
    set nb $numbytes
  }
  if {$ascii} {
    set retVal [catch {gdb_update_mem ${this}_memval $current_addr $format $size $nb $bytes_per_row $ascii_char} vals]

  } else {
    set retVal [catch {gdb_update_mem ${this}_memval $current_addr $format $size $nb $bytes_per_row} vals]
  }


  if {$retVal || [llength $vals] != 3}  {
    BadExpr "Couldn't get memory at address: \"$addr\""
      debug "gdb_update_mem returned return code: $retVal and value: \"$vals\""
    return    
  }
  # set default column width to the max in the data columns
  $itk_component(table) configure -colwidth [lindex $vals 1]

  # set border column width
  $itk_component(table) width -1 [lindex $vals 0]

  # set ascii column width
  if {$ascii} {
    $itk_component(table) width $Numcols [lindex $vals 2]
  }
}

# ------------------------------------------------------------------
#  METHOD:  hidemb - hide the menubar.  NOT CURRENTLY USED
# ------------------------------------------------------------------
itcl::body MemWin::hidemb {} {
  set mbar 0
  reconfig
}

# ------------------------------------------------------------------
#  METHOD:  reconfig - used when preferences change
# ------------------------------------------------------------------
itcl::body MemWin::reconfig {} {
  debug
  set addr_exp [string trimright [string trimleft $addr_exp]]
  set wh [winfo height $top]

  if [winfo exists $itk_interior.m] { destroy $itk_interior.m }
  if [winfo exists $itk_interior.cb] { destroy $itk_interior.cb }
  if [winfo exists $itk_interior.f.upd] { destroy $itk_interior.f.upd }
  if [winfo exists $itk_interior.sy] { destroy $itk_interior.sy }  
  destroy $itk_interior.f.cntl $itk_interior.f $itk_component(table) \
    $itk_interior.sx 

  set dont_size 1

  # If the fonts change, then you will need to recompute the 
  # row height.  Ditto for switch from fixed number of rows to
  # depends on size.

  set rheight ""

  # Update preferences to reflect new reality
  pref setd gdb/mem/size $size
  pref setd gdb/mem/numbytes $numbytes
  pref setd gdb/mem/format $format
  pref setd gdb/mem/ascii $ascii
  pref setd gdb/mem/ascii_char $ascii_char
  pref setd gdb/mem/bytes_per_row $bytes_per_row
  pref setd gdb/mem/color $color

  build_win
  set dont_size 0
  ::update
  
  if {$numbytes == 0} {
    newsize $wh
  }
}

# ------------------------------------------------------------------
#  METHOD:  do_popup - Display popup menu
# ------------------------------------------------------------------
itcl::body MemWin::do_popup {X Y} {
  if {$Running} { return }
  $itk_component(table).menu delete 0 end
  $itk_component(table).menu add check -label "Auto Update" -variable _mem($this,enabled) \
    -underline 0 -command "$this toggle_enabled"
  $itk_component(table).menu add command -label "Update Now" -underline 0 \
    -command [code $this _update_address 1]
  $itk_component(table).menu add command -label "Go To [$itk_component(table) curvalue]" -underline 0 \
    -command "$this goto [$itk_component(table) curvalue]"
  $itk_component(table).menu add command -label "Open New Window at [$itk_component(table) curvalue]" -underline 0 \
    -command [list ManagedWin::open MemWin -force -addr_exp [$itk_component(table) curvalue]]
  $itk_component(table).menu add separator
  $itk_component(table).menu add command -label "Preferences..." -underline 0 \
    -command "$this create_prefs"
  tk_popup $itk_component(table).menu $X $Y 
}

# ------------------------------------------------------------------
#  METHOD:  goto - change the address of the current memory window
# ------------------------------------------------------------------
itcl::body MemWin::goto { addr } {
  set current_addr $addr
  $itk_interior.f.cntl delete 0 end
  $itk_interior.f.cntl insert end $addr
  _update_address 1
}

# ------------------------------------------------------------------
#  METHOD:  init_addr_exp - initialize address expression
#  On startup, if the public variable "addr_exp" was not set,
#  then set it to the start of ".data" if found, otherwise "$pc"
# ------------------------------------------------------------------
itcl::body MemWin::init_addr_exp {} {
  if {$addr_exp == ""} {
    set err [catch {gdb_cmd "info file"} result]
    if {!$err} {
      foreach line [split [string trim $result] \n] { 
	if {[scan $line {%x - %x is %s} start stop section] == 3} {
	  if {$section == ".data"} {
	    set addr_exp [format "%#08x" $start]
	    break
	  }
	}
      }
    }
    if {$addr_exp == ""} {
      set addr_exp \$pc
    }
  }
}

# ------------------------------------------------------------------
#  METHOD:  cursor - set the cursor
# ------------------------------------------------------------------
itcl::body MemWin::cursor {glyph} {
  # Set cursor for all labels
  # for {set i 0} {$i < $bytes_per_row} {incr i $size} {
  #   $itk_component(table).h.$i configure -cursor $glyph
  # }
  $top configure -cursor $glyph
}

# memMoveCell --
#
# Moves the location cursor (active element) by the specified number
# of cells and changes the selection if we're in browse or extended
# selection mode.
#
# Don't allow movement into the ASCII column.
#
# Arguments:
# w - The table widget.
# x - +1 to move down one cell, -1 to move up one cell.
# y - +1 to move right one cell, -1 to move left one cell.

itcl::body MemWin::memMoveCell {w x y} {
  if {[catch {$w index active row} r]} return
  set c [$w index active col]
  if {$ascii && ($c == $Numcols)} {
    # we're in the ASCII column so behave differently
    if {$y == 1} {set x 1}
    if {$y == -1} {set x -1}
    incr r $x
  } else {
    incr r $x
    incr c $y
    if { $c < 0 } {
      if {$r == 0} {
	set c 0
      } else {
	set c [expr {$Numcols - 1}]
	incr r -1
      }
    } elseif { $c >= $Numcols } {
      if {$r >= [expr {$Numrows - 1}]} {
	set c [expr {$Numcols - 1}]
      } else {
	set c 0
	incr r
      }
    }
  }
  if { $r < 0 } { set r 0 }
  $w activate $r,$c
  $w see active
}

# ------------------------------------------------------------
#  PUBLIC METHOD:  error_dialog - Open and error dialog.
#    Arguments:
#        msg      - The message to display in the dialog
#        modality - The dialog modailty. Default: task
#        type     - The dialog type (tk_messageBox).
#                    Default: ok
# ------------------------------------------------------------
itcl::body MemWin::error_dialog {msg {modality task} {type ok}} {
  set parent [winfo toplevel [namespace tail $this]]
  tk_messageBox -icon error -title Error -type $type \
    -message $msg -parent $parent
}

@


1.25
log
@        * library/main.tcl: Add gdbtk_platform definitions.
        * library/attachdlg.itb (list_pids): Use gdbtk_platform
        instead of tcl_platform.
        * library/bpwin.itb (build_win): Likewise.
        (_bp_add): Likewise.
        (_bp_modify): Likewise.
        * library/download.itb (download_it): Likewise.
        * library/globalpref.itb (_build_win): Likewise.
        * library/helpviewer.tcl (open_help): Likewise.
        * library/interface.tcl (gdbtk_tcl_query): Likewise.
        (show_warning): Likewise.
        (open_file): Likewise.
        (run_executable): Likewise.
        * library/managedwin.itb (reveal): Likewise.
        (_create): Likewise.
        * library/prefs.tcl (pref_read): Likewise.
        (pref_set_defaults): Likewise.
        (pref_set_colors): Likewise.
        * library/session.tcl (_exe_name): Likewise.
        * library/srcbar.itcl (_update_file_menu): Likewise.
        (create_run_menu): Likewise.
        * library/srctextwin.itb (_mtime_changed): Likewise.
        (LoadFromCache): Likewise.
        * library/targetselection.itb (default_port): Likewise.
        (build_win): Likewise.

        * library/memwin.itb (build_win): Remove unused tcl_platform
        declaration.
        * library/pluginwin.itcl (enable_ui): Likewise.
        * library/process.itb (build_win): Likewise.
        * library/srcbar.itcl (enable_ui): Likewise.
        * library/srcwin.itb (location): Likewise.
        * library/stackwin.itb (build_win): Likewise.
        * library/tdump.tcl (build_win): Likewise.
@
text
@d2 1
a2 1
# Copyright (C) 1998, 1999, 2001, 2002, 2005, 2008 Red Hat, Inc.
d239 1
a239 1
  set prefs_win [ManagedWin::open MemPref -force -over $this\
@


1.24
log
@	* library/attachdlg.itb:
	* library/actiondlg.tcl:
	* library/about.tcl:
	* library/ehandler.itb:
	* library/editor.tcl:
	* library/download.ith:
	* library/download.itb:
	* library/debugwin.ith:
	* library/debugwin.itb:
	* library/cspref.ith:
	* library/cspref.itb:
	* library/console.ith:
	* library/console.itb:
	* library/browserwin.ith:
	* library/browserwin.itb:
	* library/bpwin.ith:
	* library/bpwin.itb:
	* library/blockframe.ith:
	* library/managedwin.ith:
	* library/managedwin.itb:
	* library/main.tcl:
	* library/locals.tcl:
	* library/ipcpref.ith:
	* library/ipcpref.itb:
	* library/ipc.tcl:
	* library/interface.tcl:
	* library/helpviewer.tcl:
	* library/globalpref.ith:
	* library/globalpref.itb:
	* library/gdbwin.ith:
	* library/gdbtoolbar.itcl:
	* library/gdbmenubar.itcl:
	* library/gdbevent.ith:
	* library/gdbevent.itb:
	* library/embeddedwin.ith:
	* library/ehandler.ith:
	* library/srcwin.itb:
	* library/srctextwin.ith:
	* library/srctextwin.itb:
	* library/srcpref.ith:
	* library/srcpref.itb:
	* library/srcbar.itcl:
	* library/session.tcl:
	* library/regwin.ith:
	* library/regwin.itb:
	* library/process.ith:
	* library/process.itb:
	* library/prefs.tcl:
	* library/pluginwin.itcl:
	* library/modal.tcl:
	* library/memwin.ith:
	* library/memwin.itb:
	* library/mempref.ith:
	* library/mempref.itb:
	* library/watch.tcl:
	* library/watch.tcl:
	* library/warning.tcl:
	* library/vartree.ith:
	* library/vartree.itb:
	* library/util.tcl:
	* library/tracedlg.tcl:
	* library/toplevelwin.ith:
	* library/tfind_args.tcl:
	* library/tdump.tcl:
	* library/targetselection.ith:
	* library/targetselection.itb:
	* library/stackwin.ith:
	* library/stackwin.itb:
	* library/srcwin.ith:
@
text
@d2 1
a2 1
# Copyright (C) 1998, 1999, 2001, 2002, 2005 Red Hat, Inc.
d66 1
a66 1
  global tcl_platform gdb_ImageDir _mem ${this}_memval
@


1.23
log
@        From Dieter Ruppert <dieter_ruppert@@siemens.com>:
        * library/memwin.itb (update_address): Change parameter name
        so that it does not shadow a member variable.
        Save the updated address internally.
@
text
@d2 1
a2 1
# Copyright 1998, 1999, 2001, 2002, 2005 Red Hat, Inc.
@


1.22
log
@2002-11-11  Martin M. Hunt  <hunt@@redhat.com>

	* library/memwin.itb: Supply arg to _update_address.
@
text
@d2 1
a2 1
# Copyright 1998, 1999, 2001, 2002 Red Hat, Inc.
d472 1
a472 1
itcl::body MemWin::update_address {addr_exp} {
d476 1
a476 1
  if {[string match {[a-zA-Z_&0-9\*]*} $addr_exp]} {
d478 1
a478 1
    set retVal [catch {gdb_eval "$addr_exp" x} current_addr]
d491 1
a491 1
  } elseif {[regexp {\$[a-zA-Z_]} $addr_exp]} {
d493 1
a493 1
    set retVal [catch {gdb_eval "$addr_exp" x} current_addr]
d500 1
a500 1
      BadExpr "No Local Variable Named \"$addr_exp\""
d505 1
a505 1
    BadExpr "Can't Evaluate \"$addr_exp\""
d516 2
@


1.21
log
@2002-10-15  Martin M. Hunt  <hunt@@redhat.com>

	* library/* : auto_mkindex cannot rebuild
	tclIndex because it does not recognize the namespace
	import in main.tcl.  To get it to work again, rename the
	following:
		body -> itcl::body
		configbody -> itcl::configbody
		class -> itcl::class
@
text
@d678 1
a678 1
  _update_address
@


1.20
log
@2002-09-19  Martin M. Hunt  <hunt@@redhat.com>

	* library/memwin.itb (incr_addr): Fix 64-bit addresses.
@
text
@d17 1
a17 1
body MemWin::constructor {args} {
d55 1
a55 1
body MemWin::destructor {} {
d65 1
a65 1
body MemWin::build_win {} {
d217 1
a217 1
body MemWin::paste {x y} {
d224 1
a224 1
body MemWin::validate {val} {
d231 1
a231 1
body MemWin::create_prefs {} {
d249 1
a249 1
body MemWin::changed_cell {from to} {
d263 1
a263 1
body MemWin::edit { cell } {
d347 1
a347 1
body MemWin::toggle_enabled {} {
d365 1
a365 1
body MemWin::update {event} {
d375 1
a375 1
body MemWin::idle {event} {
d402 1
a402 1
body MemWin::busy {event} {
d429 1
a429 1
body MemWin::newsize {height} {
d451 1
a451 1
body MemWin::_update_address {make_busy} {
d464 1
a464 1
body MemWin::update_address_cb {} {
d472 1
a472 1
body MemWin::update_address {addr_exp} {
d524 1
a524 1
body MemWin::BadExpr {errTxt} {
d540 1
a540 1
body MemWin::incr_addr {num} {
d567 1
a567 1
body MemWin::update_addr {} {
d605 1
a605 1
body MemWin::hidemb {} {
d613 1
a613 1
body MemWin::reconfig {} {
d654 1
a654 1
body MemWin::do_popup {X Y} {
d674 1
a674 1
body MemWin::goto { addr } {
d686 1
a686 1
body MemWin::init_addr_exp {} {
d708 1
a708 1
body MemWin::cursor {glyph} {
d729 1
a729 1
body MemWin::memMoveCell {w x y} {
d769 1
a769 1
body MemWin::error_dialog {msg {modality task} {type ok}} {
@


1.19
log
@        * library/browserwin.itb (_full_funcs_combo): Remove "-modal"
        option from tk_messageBox call. It was redhat-local in tk8.0,
        but is no longer in tk8.3.
        * library/download.itb (download_it): Likewise.
        * library/interface.tcl (gdbtk_tcl_query): Likewise.
        (show_warning): Likewise.
        (set_exe): Likewise.
        (set_target): Likewise.
        * library/memwin.itb (error_dialog): Likewise.
        * library/srcwin.itb (fillFuncCB): Likewise.
        * library/util.tcl (tfind_cmd): Likewise.
@
text
@d558 1
a558 1
  $itk_interior.f.cntl insert 0 [format "0x%x" $current_addr]
@


1.18
log
@2002-06-07  Martin M. Hunt  <hunt@@redhat.com>

	* library/prefs.tcl (pref_set_colors): New function.  Set up colors
	from Windows system colors or X resource database. Save in array.
	(pref_set_defaults): Remove gdb/font/normal_fg, etc.
	(pref_read): Call pref_set_colors.

	* library/main.tcl: Remove call to "tix resetoptions TixGray".

	* library/bpwin.itb, library/browserwin.itb, library/console.itb,
	library/globalpref.itb, library/memwin.itb, library/process.itb,
	library/regwin.itb, library/srcpref.itb, library/srctextwin.itb,
	library/stackwin.itb, library/tdump.tcl, library/tracedlg.tcl,
	library/variables.tcl: Replace calls to [pref get gdb/fonts/*]
	for colors with references to Color array. Remove all tixOptions calls.
	Fix up colors as necessary.
@
text
@d772 1
a772 1
    -modal $modality -message $msg -parent $parent
@


1.17
log
@        * generic/gdbtk-cmds.c: Include "ctype.h" if available.
        (gdb_get_mem): Renamed to gdb_update_mem.
        (gdb_update_mem): Take array as first tcl argument. This
        array will hold the data for the table, which is now stuffed
        in C instead of tcl.
        (gdb_eval): Use our own ui-file instead of gdb_stdout.
        * library/memwin.ith (_update_address): New method.
        (update_address): Address expression is no longer optional.
        * library/memwin.itb (build_win): Use _update_address instead of
        update_address.
        (toggle_enabled): Ditto.
        (newsize): Use _update_address instead of update_addr.
        (update_address_cb): Use _update_address instead of update_address.
        (do_popup): Likewise.
        (goto): Likewise.
        (incr_addr): Use _update_address instead of update_addr.
        (edit): Use gdb_update_mem instead of gdb_get_mem.
        (update_addr): use gdb_update_mem to do all the window updating.
@
text
@a25 1
  set bg white 
d104 13
a116 6
  table $itk_interior.t -titlerows 1 -titlecols 1 -variable ${this}_memval \
    -roworigin -1 -colorigin -1 -bg $bg \
    -browsecmd "$this changed_cell %s %S" -font global/fixed\
    -colstretch unset -rowstretch unset -selectmode single \
    -xscrollcommand "$itk_interior.sx set" -resizeborders none \
    -cols $numcols -rows $numrows -autoclear 1
d119 2
a120 2
    $itk_interior.t configure -yscrollcommand "$itk_interior.sy set"
    scrollbar $itk_interior.sy -command [list $itk_interior.t yview]
d122 1
a122 1
    $itk_interior.t configure -rowstretchmode none
d124 5
a128 5
  scrollbar $itk_interior.sx -command [list $itk_interior.t xview] -orient horizontal
  $itk_interior.t tag config sel -bg [$itk_interior.t cget -bg] -relief sunken
  $itk_interior.t tag config active -bg lightgray -relief sunken -wrap 0
  $itk_interior.t tag config title -bg [pref get gdb/font/header_bg] \
    -fg [pref get gdb/font/header_fg]
d132 6
a137 6
  bind $itk_interior.t <Up>		"$this memMoveCell %W -1  0; break"
  bind $itk_interior.t <Down>		"$this memMoveCell %W  1  0; break"
  bind $itk_interior.t <Left>		"$this memMoveCell %W  0 -1; break"
  bind $itk_interior.t <Right>	"$this memMoveCell %W  0  1; break"
  bind $itk_interior.t <Return>	"$this memMoveCell %W 0 1; break"
  bind $itk_interior.t <KP_Enter>	"$this memMoveCell %W 0 1; break"
d140 1
a140 1
  bind $itk_interior.t <3> "$this do_popup %X %Y"
d146 2
a147 2
  bind $itk_interior.t <ButtonRelease-2> [format {after idle %s paste %s %s} $this %x %y]
  bind $itk_interior.t <<Paste>> [format {after idle %s paste %s %s} $this %x %y]
d149 1
a149 1
  menu $itk_interior.t.menu -tearoff 0
d159 2
a160 3
    -decrement "after idle $this incr_addr 1" \
    -validate {} \
    -textbackground white
a169 1

d204 1
a204 1
  grid $itk_interior.t -row 1 -column 0 -sticky news
d218 1
a218 1
  edit [$itk_interior.t index @@$x,$y]
d236 1
a236 1
    set rheight [lindex [$itk_interior.t bbox 0,0] 3]
d251 1
a251 1
  #debug "value = [$itk_interior.t get $from]"
d253 1
a253 1
    if {$saved_value != [$itk_interior.t get $from]} {
d257 1
a257 1
  set saved_value [$itk_interior.t get $to]
d272 1
a272 1
  set val [$itk_interior.t get $cell]
a352 1
    set bg white
d354 1
d356 1
a356 1
    set bg gray
d359 1
a359 1
  $itk_interior.t config -background $bg -state $state
d441 1
a441 1
      set rheight [lindex [$itk_interior.t bbox 0,0] 3]
d444 1
a444 1
    set theight [winfo height $itk_interior.t]
d446 1
a446 1
    $itk_interior.t configure -rows $Numrows
d517 1
a517 1
  $itk_interior.t config -bg white -state normal
d530 1
a530 1
  $itk_interior.t config -bg gray -state disabled
d556 1
a556 1
  $itk_interior.t config -background white -state normal
d591 1
a591 1
  $itk_interior.t configure -colwidth [lindex $vals 1]
d594 1
a594 1
  $itk_interior.t width -1 [lindex $vals 0]
d598 1
a598 1
    $itk_interior.t width $Numcols [lindex $vals 2]
d622 1
a622 1
  destroy $itk_interior.f.cntl $itk_interior.f $itk_interior.t \
d656 2
a657 2
  $itk_interior.t.menu delete 0 end
  $itk_interior.t.menu add check -label "Auto Update" -variable _mem($this,enabled) \
d659 1
a659 1
  $itk_interior.t.menu add command -label "Update Now" -underline 0 \
d661 6
a666 6
  $itk_interior.t.menu add command -label "Go To [$itk_interior.t curvalue]" -underline 0 \
    -command "$this goto [$itk_interior.t curvalue]"
  $itk_interior.t.menu add command -label "Open New Window at [$itk_interior.t curvalue]" -underline 0 \
    -command [list ManagedWin::open MemWin -force -addr_exp [$itk_interior.t curvalue]]
  $itk_interior.t.menu add separator
  $itk_interior.t.menu add command -label "Preferences..." -underline 0 \
d668 1
a668 1
  tk_popup $itk_interior.t.menu $X $Y 
d711 1
a711 1
  #   $itk_interior.t.h.$i configure -cursor $glyph
d774 1
@


1.16
log
@2002-03-05  Martin M. Hunt  <hunt@@redhat.com>

	* library/prefs.tcl (pref_read): If a preference specifies
	"src-font", substitute "global/fixed".
	(pref_set_defaults): Change defaults from "src-font" to
	"global/fixed". Do not create font object "src-font". Do
	not add hook to trace its changes.
	(pref_src-font_trace): Remove.

	* library/console.itb (Console::_update_option): Remove
	font update because this happens automatically.

	* library/globalpref.itb: No need to set
	changed flag for fonts; updates happen automatically
	when prefs are updated.

	* library/bpwin.itb: Replaced src-font with global/fixed.
	* library/browserwin.itb: Ditto.
	* library/mempref.itb: Ditto.
	* library/memwin.itb: Ditto.
	* library/process.itb: Ditto.
	* library/regwin.itb: Ditto.
	* library/srcbar.itcl: Ditto.
	* library/srcpref.itb: Ditto.
	* library/srctextwin.itb: Ditto.
	* library/srcwin.itb: Ditto.
	* library/stackwin.itb: Ditto.
	* library/tdump.tcl: Ditto.
	* library/tracedlg.tcl: Ditto.
	* library/variables.tcl: Ditto.
	* library/watch.tcl: Ditto.
@
text
@d82 1
a82 1
      -command "$this update_address" -accelerator {Ctrl+U}
d144 1
a144 1
  bind_plain_key $top Control-u "$this update_address"
d167 1
a167 1
    button $itk_interior.f.upd -command "$this update_address" \
d191 1
a191 1
    update_address
d301 1
a301 12
    catch {gdb_get_mem $addr $format $size $nb $bytes_per_row $ascii_char} vals
    for {set n 0} {$n < $nb} {incr n $bytes_per_row} {
      set ${this}_memval($row,-1) [format "0x%x" $addr]
      for { set col 0 } { $col < [expr {$bytes_per_row / $size}] } { incr col } {
	set ${this}_memval($row,$col) [lindex $vals $nextval]
	incr nextval
      }
      set ${this}_memval($row,$col) [lindex $vals $nextval]
      incr nextval
      set addr [gdb_incr_addr $addr $bytes_per_row]
      incr row
    }
d332 1
a332 1
  # catch {gdb_get_mem $addr $format $size $size $size ""} val
d348 1
a348 1
    update_address
d364 1
a364 1
    update_address
d443 11
a453 1
    update_addr
d462 1
a462 1
  update_address [$itk_interior.f.cntl get]
d468 1
a468 7
body MemWin::update_address { {ae ""} } {
  debug $ae
  if {$ae == ""} {
    set addr_exp [string trimleft [$itk_interior.f.cntl get]]
  } else {
    set addr_exp $ae
  }
d504 2
a505 2
  
  # Check for spaces
a552 1
  update_addr
d555 1
d566 1
a566 7
  if {$bad_expr} {
    return
  }

  gdbtk_busy
  set addr $current_addr
  set row 0
a572 2
  set nextval 0
  set num [expr {$bytes_per_row / $size}]
d574 2
a575 1
    set asc $ascii_char
d577 1
a577 1
    set asc ""
d580 2
a581 6
  #debug "get_mem $addr $format $size $nb $bytes_per_row $asc"
  set retVal [catch {gdb_get_mem $addr $format \
		       $size $nb $bytes_per_row $asc} vals]
  #debug "retVal=$retVal vals=$vals"
  if {$retVal || [llength $vals] == 0}  {
    # FIXME gdb_get_mem does not always return an error when addr is invalid.
d583 2
a584 26
    gdbtk_idle 
    dbug W "gdb_get_mem returned return code: $retVal and value: \"$vals\""
    return
  }
  
  set mlen 0
  for {set n 0} {$n < $nb} {incr n $bytes_per_row} {
    set x $addr
    if {[string length $x] > $mlen} {
      set mlen [string length $x]
    }
    set ${this}_memval($row,-1) $x
    for { set col 0 } { $col < $num } { incr col } {
      set x [lindex $vals $nextval]
      if {[string length $x] > $maxlen} {set maxlen [string length $x]}
      set ${this}_memval($row,$col) $x
      incr nextval
    }
    if {$ascii} {
      set x [lindex $vals $nextval]
      if {[string length $x] > $maxalen} {set maxalen [string length $x]}
      set ${this}_memval($row,$col) $x
      incr nextval
    }
    set addr [gdb_incr_addr $addr $bytes_per_row]
    incr row
d587 2
a588 1
  $itk_interior.t configure -colwidth [expr {$maxlen + 1}]
d590 3
a592 1
  $itk_interior.t width -1 [expr {$mlen + 1}]
d594 1
a594 2
    # set ascii column width
    $itk_interior.t width $Numcols [expr {$maxalen + 1}]
a595 2

  gdbtk_idle
d656 1
a656 1
    -command "$this update_address"
d674 1
a674 1
  update_address
@


1.15
log
@update copyrights (dates verified with cvs)
@
text
@d107 1
a107 1
    -browsecmd "$this changed_cell %s %S" -font src-font\
@


1.14
log
@2002-01-11  Martin M. Hunt  <hunt@@redhat.com>

	* library/memwin.itb (idle): Check for existence of window.
	Prevents race-condition error.
@
text
@d2 1
a2 1
# Copyright 1998, 1999, 2001 Red Hat, Inc.
@


1.13
log
@	* library/memwin.itb (incr_addr): Fix typo.
@
text
@d389 7
a395 6
  # Enable menus
  if {$mbar} {
    for {set i 0} {$i <= [$itk_interior.m.addr index last]} {incr i} {
      if {[$itk_interior.m.addr type $i] != "separator"} {
	$itk_interior.m.addr entryconfigure $i -state normal
      }
d397 4
a401 3

  # Enable control
  $itk_interior.f.cntl configure -state normal
@


1.12
log
@2001-11-08  Martin M. Hunt  <hunt@@redhat.com>
	* generic/gdbtk-cmds.c (gdb_eval): Add an optional
	format argument.
	(hex2bin): Swap bytes around if target is little endian.
	Fix loop count.
	(gdb_incr_addr): New function to do address arithmetic.
	Needed because some addresses are 64-bits and tcl can't
	deal with them, except as strings.

	* library/memwin.itb (MemWin::build_win): Add a label
	to indicate the target endianess.
	(MemWin::edit): Use gdb_incr_addr.
	(MemWin::busy): The constructor calls gdbtk_busy which
	calls this before the window has finished drawing, so
	don't disable items that don't exist yet.
	(MemWin::update_address): Set a flag, bad_expr, if the
	expression does not evaluate. Call gdb_eval with 'x' flag
	to force the result to be hex.
	(MemWin::BadExpr): Set bad_expr.
	(MemWin::incr_addr): Use gdb_incr_addr.
	(MemWin::update_addr): Return is bad_expr is set. Use
	gdb_incr_addr.
	(MemWin::goto): Call update_address.
	* library/memwin.itb: Declare private variable bad_expr.

	* library/util.tcl (gdbtk_endian): New procedure. Returns
	BIG or LITTLE to indicate target endianess.
@
text
@d272 1
a272 1
    set addr [gdb_incr_addr $current_addr + [expr {$bytes_per_row * $row}]]
d546 1
a546 1
  set current_addr [gdb_incr_addr $current_addr + [expr {$bytes_per_row * $num}]]
@


1.11
log
@	* library/memwin.itb (update_addr): Evaluate the address
	to be sent to gdb_get_mem to prevent passing error strings
	to string_to_coreaddr in gdb_get_mem.
@
text
@a155 1

d159 2
d172 1
a172 1
    grid $itk_interior.f.upd $itk_interior.f.cntl -sticky ew -padx 5
d174 1
a174 1
    grid $itk_interior.f.cntl x -sticky w
d272 1
a272 1
    set addr [expr {$current_addr + $bytes_per_row * $row}]
d296 1
a296 1
      incr addr
d310 1
a310 1
      incr addr $bytes_per_row
d317 2
a318 2
  set addr [expr {$current_addr + $bytes_per_row * $row + $size * $col}]
  #debug "  edit $row,$col         [format "%x" $addr] = $val"
d325 1
d414 3
d435 1
d468 1
d475 1
d479 2
a480 1
    set retVal [catch {gdb_eval "$addr_exp"} current_addr]
d494 5
a498 4
    catch {gdb_eval "$addr_exp"} current_addr
    if {$current_addr == "No registers.\n"} { 
      # we asked for a register value and debugging hasn't started yet
      return 
d501 1
a501 1
      BadExpr "No Local Variable Named \"$addr_ex\""
d509 1
a509 1

d534 1
a541 1

d546 1
a546 6

  # You have to be careful with address calculations here, since the memory
  # space of the target may be bigger than a long, which will cause Tcl to
  # overflow.  Let gdb do the calculations instead.

  set current_addr [gdb_cmd "printf \"%u\", $current_addr + $num * $bytes_per_row"]
d566 1
a566 1
#  This is just a helper function for update_address.
d571 4
a576 1

d592 24
a615 34
  # Last chance to verify addr
  if {![catch {gdb_eval $addr}]} {
    set retVal [catch {gdb_get_mem $addr $format \
			 $size $nb $bytes_per_row $asc} vals]
 
    if {$retVal || [llength $vals] == 0}  {
      # FIXME gdb_get_mem does not always return an error when addr is invalid.
      BadExpr "Couldn't get memory at address: \"$addr\""
      gdbtk_idle 
      debug "gdb_get_mem returned return code: $retVal and value: \"$vals\""
      return
    }

    set mlen 0
    for {set n 0} {$n < $nb} {incr n $bytes_per_row} {
      set x [format "0x%x" $addr]
      if {[string length $x] > $mlen} {
	set mlen [string length $x]
      }
      set ${this}_memval($row,-1) $x
      for { set col 0 } { $col < $num } { incr col } {
	set x [lindex $vals $nextval]
	if {[string length $x] > $maxlen} {set maxlen [string length $x]}
	set ${this}_memval($row,$col) $x
	incr nextval
      }
      if {$ascii} {
	set x [lindex $vals $nextval]
	if {[string length $x] > $maxalen} {set maxalen [string length $x]}
	set ${this}_memval($row,$col) $x
	incr nextval
      }
      incr addr $bytes_per_row
      incr row
a616 4
    # set default column width to the max in the data columns
    $itk_interior.t configure -colwidth [expr {$maxlen + 1}]
    # set border column width
    $itk_interior.t width -1 [expr {$mlen + 1}]
d618 4
a621 2
      # set ascii column width
      $itk_interior.t width $Numcols [expr {$maxalen + 1}]
d623 10
d714 1
@


1.10
log
@	* library/prefs.tcl (pref_set_defaults): Add new font
	color defaults for highlighting, headers, selecting, and "normal".
	Get rid of gdb/variable/highlight_fg and gdb/reg/highlight_fg.
	* library/variables.tcl (build_win): Use gdb/font/highlight_fg
	and gdb/font/highilght_bg to set highlight style.
	* library/memwin.itb (build_win): Use header_fg and header_bg.
@
text
@d483 1
a483 1
  } elseif {[string match {\$*} $addr_exp]} {
d496 1
a496 1
    BadExpr "Can't Evaluate \"$addr_expr\""
d584 4
a587 2
  set retVal [catch {gdb_get_mem $addr $format \
		       $size $nb $bytes_per_row $asc} vals]
d589 7
a595 7
  if {$retVal || [llength $vals] == 0}  {
    # FIXME gdb_get_mem does not always return an error when addr is invalid.
    BadExpr "Couldn't get memory at address: \"$addr\""
    gdbtk_idle 
    debug "gdb_get_mem returned return code: $retVal and value: \"$vals\""
    return    
  }
d597 21
a617 12
  set mlen 0
  for {set n 0} {$n < $nb} {incr n $bytes_per_row} {
    set x [format "0x%x" $addr]
    if {[string length $x] > $mlen} {
      set mlen [string length $x]
    }
    set ${this}_memval($row,-1) $x
    for { set col 0 } { $col < $num } { incr col } {
      set x [lindex $vals $nextval]
      if {[string length $x] > $maxlen} {set maxlen [string length $x]}
      set ${this}_memval($row,$col) $x
      incr nextval
d619 4
d624 2
a625 4
      set x [lindex $vals $nextval]
      if {[string length $x] > $maxalen} {set maxalen [string length $x]}
      set ${this}_memval($row,$col) $x
      incr nextval
a626 10
    incr addr $bytes_per_row
    incr row
  }
  # set default column width to the max in the data columns
  $itk_interior.t configure -colwidth [expr {$maxlen + 1}]
  # set border column width
  $itk_interior.t width -1 [expr {$mlen + 1}]
  if {$ascii} {
    # set ascii column width
    $itk_interior.t width $Numcols [expr {$maxalen + 1}]
@


1.9
log
@2001-07-20  Martin M. Hunt  <hunt@@redhat.com>

	* library/memwin.itb: Fix syntax to open a new window
	using the "-force" flag.
@
text
@d121 2
@


1.8
log
@	* library/interface.tcl (gdb_update_hook): Mark as deprecated.
	(gdbtk_update): Dispatch and UpdateEvent, too.
	* library/ehandler.ith (update): New event handler.
	* library/gdbevent.ith (UpdateEvent): New event.
	* library/gdbevent.itb (UpdateEvent::constructor): New method.
	(UpdateEvent::get): New method.
	* library/kod.ith (udpate): Match event handler definition.
	* library/kod.itb (update): Ditto.
	(build_win): Pass dummy argument to update method.
	(top): Ditto.
	(up): Ditto.
	(set_variable): Ditto.
	* library/memwin.ith (update): Match event handler definition.
	* library/memwin.itb (update): Ditto.
	(constructor): Remove gdb_update_hook.
	(destructor): Ditto.
	* library/process.ith (update): Match event handler definition.
	* library/process.itb (update): Ditto.
	(constructor): Remove gdb_update_hook.
	(destructor): Ditto.
	(build_win): Pass dummy argument to update method.
	* library/regwin.ith (update): Match event handler definition.
	* library/regwin.itb (update): Ditto.
	(constructor): Remove gdb_update_hook.
	(destructor): Ditto.
	(build_win): Pass dummy argument to update method.
	(but3): Ditto.
	(unedit): Ditto.
	* library/stackwin.ith (update): Match event handler definition.
	* library/stackwin.itb (update): Ditto.
	(constructor): Remove gdb_update_hook.
	(destructor): Ditto.
	(build_win): Pass dummy argument to update method.
	* library/tdump.tcl (update): Match event handler definition.
	(constructor): Remove gdb_update_hook.
	(destructor): Ditto.
	(build_win): Pass dummy argument to update method.
	* library/variables.tcl (update): Match event handler definition.
	(build_win): Pass dummy argument to update method.
	* library/locals.tcl (update): Match event handler definition.
	(constructor): Pass dummy argument to update method.
	* library/watch.tcl (update): Match event handler definition.
	Pass dummy argument to VariableWin::update.
	(add): Pass dummy argument to update method.
	* library/srcwin.ith (update): New method.
	(update_hook_init): Remove.
	* library/srcwin.itb (update): New method.
	(constructor): Remove gdb_update_hook.
	(destructor): Ditto.
	* tclIndex: Regenerate.
@
text
@d689 1
a689 1
    -command [list ManagedWin::open -force MemWin -addr_exp [$itk_interior.t curvalue]]
@


1.7
log
@	* library/interface.tcl (gdb_idle_hook): Mark as deprecated.
	(gdbtk_idle): Dispatch an IdleEvent. gdb_idle_hook is gone.
	* library/ehandler.ith (idle): New event handler.
	* library/gdbevent.ith (IdleEvent): New event.
	* library/console.ith (idle): Match event handler definition.
	* library/console.itb (idle): Ditto.
	(constructor): Remove gdb_idle_hook.
	(destructor): Ditto.
	* library/kod.ith (idle): Match event handler definition.
	* library/kod.itb (idle): Ditto.
	(constructor): Remove gdb_idle_hook.
	(destructor): Ditto.
	* library/memwin.ith (idle): Match event handler definition.
	* library/memwin.itb (idle): Ditto.
	(constructor): Remove gdb_idle_hook.
	(destructor): Ditto.
	* library/pluginwin.itcl (stopped): Rename to "idle" and
	match event handler definition.
	Fix misleading comments.
	* library/process.ith (idle): Match event handler definition.
	* library/process.itb (idle): Ditto.
	(constructor): Remove gdb_idle_hook.
	(destructor): Ditto.
	* library/regwin.ith (idle): Match event handler definition.
	* library/regwin.itb (idle): Ditto.
	(constructor): Remove gdb_idle_hook.
	(destructor): Ditto.
	* library/srcbar.itcl (idle): New method.
	(constructor): Remove gdb_idle_hook.
	(destructor): Ditto.
	* library/srcwin.ith (idle): Match event handler definition.
	* library/srcwin.itb (idle): Ditto.
	(constructor): Remove gdb_idle_hook.
	(destructor): Ditto.
	* library/stackwin.ith (idle): Match event handler definition.
	* library/stackwin.itb (idle): Ditto.
	(constructor): Remove gdb_idle_hook.
	(destructor): Ditto.
	* library/variables.tcl (idle): Match event handler definition.
	(constructor): Remove gdb_idle_hook.
	(destructor): Ditto.
	* library/plugins/rhabout/rhabout.itcl (stopped): Rename
	to "idle" and match new event handler definition.
	* library/tclIndex: Regenerated.
@
text
@a50 2

  add_hook gdb_update_hook "$this update"
a59 1
  remove_hook gdb_update_hook "$this update"
d368 1
a368 1
body MemWin::update {} {
@


1.6
log
@	* library/interface.tcl (gdb_busy_hook): Deprecate.
	(gdbtk_busy): Create and dispatch a BusyEvent instead
	of running hooks.
	* library/ehandler.ith (busy): New event handler.
	* library/gdbevent.ith (BusyEvent): New event class.
	* library/console.ith: Inherit from GDBEventHandler.
	(busy): Match event handler definition.
	* library/console.itb (busy): Ditto.
	(constructor): Remove gdb_busy_event.
	(destructor): Ditto.
	* library/kod.ith (busy): Match event handler definition.
	* library/kod.itb (busy): Ditto.
	(constructor): Remove gdb_busy_hook.
	(destructor): Ditto.
	* library/memwin.ith (busy): Match event handler definition.
	* library/memwin.itb (busy): Ditto.
	(constructor): Remove gdb_busy_hook.
	(destructor): Ditto.
	* library/pluginwin.itcl (running): Rename to "busy" and
	match event handler definition.
	(consturctor): Remove gdb_busy_hook.
	(destructor): Ditto.
	* library/process.ith (busy): Match event handler definition.
	* library/process.itb (busy): Ditto.
	(constructor): Remove gdb_busy_hook.
	(destructor): Ditto.
	* library/regwin.ith (busy): Match event handler definition.
	* library/regwin.itb (busy): Ditto.
	(constructor): Remove gdb_busy_hook.
	(destructor): Ditto.
	* library/srcbar.itcl (constructor): Remove gdb_busy_hook.
	(destructor): Ditto.
	(busy): New method.
	* library/srcwin.ith (busy): Match event handler definition.
	* library/srcwin.itb (busy): Ditto.
	Only do the "busy" stuff if do_updates is set.
	(toggle_updates): Remove gdb_busy_hook.
	(constructor): Ditto.
	(destructor): Ditto.
	* library/stackwin.ith (busy): Match event handler definition.
	* library/stackwin.itb (busy): Ditto.
	(constructor): Remove gdb_busy_hook.
	(destructor): Ditto.
	* library/variables.tcl (constructor): Ditto.
	(destructor): Ditto.
	(disable_ui): Rename to "busy" and match event handler
	definition.
	* library/plugins/rhabout/rhabout.itcl (running): Rename
	to "busy" and match new event handler definition.
	* library/tclIndex: Regenerated.
@
text
@a52 1
  add_hook gdb_idle_hook [list $this idle]
a62 1
  remove_hook gdb_idle_hook [list $this idle]
d381 1
a381 1
body MemWin::idle {} {
@


1.5
log
@	* generic/gdbtk-cmds.c (bin2hex): New function.
	(fromhex): New function.
	(gdb_set_mem): New function.
	(Gdbtk_Init): Add new command, "gdb_set_mem".
	* library/memwin.itb (edit): Use "gdb_set_mem" to set
	memory, not some gdb_cmd contrivance.
	When sending data to gdb_set_mem, make sure that it
	is properly zero-padded.
@
text
@a52 1
  add_hook gdb_busy_hook [list $this busy]
a63 1
  remove_hook gdb_busy_hook [list $this busy]
d405 2
a406 1
#  METHOD: busy - disable menus 'cause we're busy updating things
d408 1
a408 1
body MemWin::busy {} {
@


1.4
log
@	Update copyright info.
@
text
@d291 3
a293 4
	if {$c == "'"} {set c "\\'"}
	set err [catch {gdb_cmd "set *(char *)($addr) = '$c'"} res]
	if {$err} {
	  error_dialog [winfo toplevel $itk_interior] $res
d323 8
a330 4
  #set memory
  set err [catch {gdb_cmd "set *($type($size) *)($addr) = $val"} res]
  if {$err} {
    error_dialog [winfo toplevel $itk_interior] $res
@


1.3
log
@
	* memwin.ith (error_dialog): Declare public method.
	* memwin.itb (error_dialog): Define.
	(edit): When attempting to set memory, post an error dialog
	if gdb told us an error occurred while writing the memory.
@
text
@d1 2
a2 2
# Memory display window class definition for GDBtk.
# Copyright 1998, 1999 Cygnus Solutions
@


1.2
log
@	* library/mempref.itb (MemPref::build_win): Correctly set initial
	value of combobox.
	* library/memwin.itb: Added copyright header.
	(MemWin::constructor): Set defaults from preference database.
	(MemWin::reconfig): Update preference database.
	* library/prefs.tcl (pref_save): Save `mem' preferences.
	(pref_set_defaults): Define default memory preferences.
@
text
@d292 8
a299 1
	catch {gdb_cmd "set *(char *)($addr) = '$c'"}
d325 9
a333 1
  catch {gdb_cmd "set *($type($size) *)($addr) = $val"} res
d786 14
@


1.1
log
@Initial revision
@
text
@d1 13
d21 1
a21 1
  
d24 1
a24 1
  
d27 1
a27 1
  
d34 1
a34 1
  
d38 10
a47 1
  
d51 1
a51 1
  
d83 2
a84 1
    $itk_interior.m add cascade -menu $itk_interior.m.addr -label "Addresses" -underline 0
d104 1
a104 1
  
d630 1
a630 1
  
d635 3
a637 2
  destroy $itk_interior.f.cntl $itk_interior.f $itk_interior.t $itk_interior.sx 
  
d646 9
a771 1

@


1.1.1.1
log
@import insight-2000-02-04 snapshot (2nd try)
@
text
@@
