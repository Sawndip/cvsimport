head	1.61;
access;
symbols
	insight_7_6-2013-04-10-branchpoint:1.60
	gdb_7_6-branch:1.60.0.10
	gdb_7_5-branch:1.60.0.8
	gdb_7_4-branch:1.60.0.6
	gdb_7_3-branch:1.60.0.4
	gdb_7_1-branch:1.60.0.2
	gdb_7_0-branch:1.59.0.8
	arc-sim-20090309:1.59
	arc-insight_6_8-branch:1.59.0.6
	arc-insight_6_8-branchpoint:1.59
	insight_6_8-branch:1.59.0.4
	insight_6_8-branchpoint:1.59
	gdb_6_8-branch:1.59.0.2
	insight_6_6-20070208-release:1.57
	gdb_6_6-branch:1.57.0.4
	gdb_6_6-2006-11-15-branchpoint:1.57
	insight_6_5-20061003-release:1.57
	gdb_6_5-branch:1.57.0.2
	gdb_6_5-2006-05-14-branchpoint:1.57
	gdb-csl-gxxpro-6_3-branch:1.56.0.4
	gdb-csl-gxxpro-6_3-branchpoint:1.56
	gdb_6_4-branch:1.56.0.2
	gdb_6_4-2005-11-01-branchpoint:1.56
	gdb_6_1-2004-04-05-release:1.48
	gdb_6_1-branch:1.48.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.48
	gdb_6_0-2003-10-04-release:1.48
	gdb_6_0-branch:1.48.0.2
	gdb_6_0-2003-06-23-branchpoint:1.48
	gdb_5_3-2002-12-12-release:1.44
	gdb_5_3-branch:1.44.0.2
	gdb_5_3-2002-09-04-branchpoint:1.44
	gdb_5_2_1-2002-07-23-release:1.41
	gdb_5_2-2002-04-29-release:1.41
	gdb_5_2-branch:1.41.0.2
	gdb_5_2-2002-03-03-branchpoint:1.41
	gdb_5_1_1-2002-01-24-release:1.27
	cygnus_cvs_20020108_pre:1.38
	gdb_5_1_0_1-2002-01-03-branch:1.27.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.27
	gdb_5_1-2001-11-21-release:1.27
	gdb_s390-2001-09-26-branch:1.27.0.4
	gdb_s390-2001-09-26-branchpoint:1.27
	gdb_5_1-2001-07-29-branch:1.27.0.2
	gdb_5_1-2001-07-29-branchpoint:1.27
	dberlin-typesystem-branch:1.26.0.2
	dberlin-typesystem-branchpoint:1.26
	insight-precleanup-2001-01-01:1.11
	gdb_5_0-2000-05-19-release:1.4
	gdb_4_18_2-2000-05-18-release:1.4
	gdb_4_95_1-2000-05-11-snapshot:1.4
	gdb_4_95_0-2000-04-27-snapshot:1.4
	gdb_5_0-2000-04-10-branch:1.4.0.2
	gdb_5_0-2000-04-10-branchpoint:1.4
	repo-unification-2000-02-06:1.1.1.1
	insight-2000-02-04:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.61
date	2013.09.06.09.35.25;	author aburgess;	state Exp;
branches;
next	1.60;

1.60
date	2009.10.09.01.23.55;	author kseitz;	state Exp;
branches;
next	1.59;

1.59
date	2008.03.03.23.25.03;	author kseitz;	state Exp;
branches
	1.59.6.1;
next	1.58;

1.58
date	2008.02.09.01.23.42;	author kseitz;	state Exp;
branches;
next	1.57;

1.57
date	2005.12.23.18.26.50;	author eliz;	state Exp;
branches;
next	1.56;

1.56
date	2005.06.14.00.19.42;	author kseitz;	state Exp;
branches;
next	1.55;

1.55
date	2005.06.07.01.16.07;	author kseitz;	state Exp;
branches;
next	1.54;

1.54
date	2005.06.07.01.10.42;	author kseitz;	state Exp;
branches;
next	1.53;

1.53
date	2004.08.27.23.13.14;	author hunt;	state Exp;
branches;
next	1.52;

1.52
date	2004.07.02.23.09.33;	author hunt;	state Exp;
branches;
next	1.51;

1.51
date	2004.06.25.19.44.22;	author cagney;	state Exp;
branches;
next	1.50;

1.50
date	2004.06.24.22.07.46;	author cagney;	state Exp;
branches;
next	1.49;

1.49
date	2004.04.05.20.36.42;	author hunt;	state Exp;
branches;
next	1.48;

1.48
date	2003.02.10.20.10.56;	author hunt;	state Exp;
branches;
next	1.47;

1.47
date	2003.02.04.07.12.25;	author hunt;	state Exp;
branches;
next	1.46;

1.46
date	2002.12.18.19.35.55;	author hunt;	state Exp;
branches;
next	1.45;

1.45
date	2002.10.10.19.39.28;	author hunt;	state Exp;
branches;
next	1.44;

1.44
date	2002.08.01.01.19.02;	author kseitz;	state Exp;
branches;
next	1.43;

1.43
date	2002.04.26.21.09.54;	author hunt;	state Exp;
branches;
next	1.42;

1.42
date	2002.03.07.20.22.41;	author hunt;	state Exp;
branches;
next	1.41;

1.41
date	2002.02.18.17.19.44;	author tromey;	state Exp;
branches;
next	1.40;

1.40
date	2002.01.11.22.00.15;	author hunt;	state Exp;
branches;
next	1.39;

1.39
date	2002.01.08.19.34.48;	author tromey;	state Exp;
branches;
next	1.38;

1.38
date	2002.01.03.00.03.46;	author kseitz;	state Exp;
branches;
next	1.37;

1.37
date	2002.01.02.23.49.42;	author kseitz;	state Exp;
branches;
next	1.36;

1.36
date	2002.01.02.23.42.50;	author kseitz;	state Exp;
branches;
next	1.35;

1.35
date	2001.12.11.08.55.52;	author irox;	state Exp;
branches;
next	1.34;

1.34
date	2001.11.30.23.31.15;	author hunt;	state Exp;
branches;
next	1.33;

1.33
date	2001.11.22.00.26.12;	author tromey;	state Exp;
branches;
next	1.32;

1.32
date	2001.11.19.18.43.19;	author hunt;	state Exp;
branches;
next	1.31;

1.31
date	2001.10.28.20.08.38;	author tromey;	state Exp;
branches;
next	1.30;

1.30
date	2001.10.06.18.10.50;	author tromey;	state Exp;
branches;
next	1.29;

1.29
date	2001.08.13.18.30.36;	author kseitz;	state Exp;
branches;
next	1.28;

1.28
date	2001.08.03.18.46.41;	author kseitz;	state Exp;
branches;
next	1.27;

1.27
date	2001.07.21.18.44.03;	author hunt;	state Exp;
branches;
next	1.26;

1.26
date	2001.06.04.15.49.53;	author kseitz;	state Exp;
branches;
next	1.25;

1.25
date	2001.05.31.22.11.27;	author kseitz;	state Exp;
branches;
next	1.24;

1.24
date	2001.05.31.20.32.57;	author kseitz;	state Exp;
branches;
next	1.23;

1.23
date	2001.05.31.15.21.40;	author kseitz;	state Exp;
branches;
next	1.22;

1.22
date	2001.05.22.18.24.18;	author kseitz;	state Exp;
branches;
next	1.21;

1.21
date	2001.05.14.18.21.54;	author kseitz;	state Exp;
branches;
next	1.20;

1.20
date	2001.05.09.17.03.15;	author kseitz;	state Exp;
branches;
next	1.19;

1.19
date	2001.04.20.17.20.02;	author kseitz;	state Exp;
branches;
next	1.18;

1.18
date	2001.04.19.22.51.02;	author kseitz;	state Exp;
branches;
next	1.17;

1.17
date	2001.04.18.17.44.00;	author tromey;	state Exp;
branches;
next	1.16;

1.16
date	2001.04.12.19.46.43;	author nsd;	state Exp;
branches;
next	1.15;

1.15
date	2001.04.05.00.04.28;	author hunt;	state Exp;
branches;
next	1.14;

1.14
date	2001.02.08.19.26.31;	author fnasser;	state Exp;
branches;
next	1.13;

1.13
date	2001.01.04.16.36.48;	author fnasser;	state Exp;
branches;
next	1.12;

1.12
date	2001.01.03.03.42.19;	author fnasser;	state Exp;
branches;
next	1.11;

1.11
date	2000.12.07.21.56.25;	author tromey;	state Exp;
branches;
next	1.10;

1.10
date	2000.12.06.18.30.01;	author tromey;	state Exp;
branches;
next	1.9;

1.9
date	2000.12.06.18.27.15;	author tromey;	state Exp;
branches;
next	1.8;

1.8
date	2000.11.30.22.49.46;	author tromey;	state Exp;
branches;
next	1.7;

1.7
date	2000.11.30.22.37.29;	author tromey;	state Exp;
branches;
next	1.6;

1.6
date	2000.11.06.22.40.16;	author fnasser;	state Exp;
branches;
next	1.5;

1.5
date	2000.10.23.21.39.28;	author fnasser;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.28.01.59.39;	author jingham;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.10.18.53.05;	author ezannoni;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.02.01.42.32;	author jingham;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.07.00.19.42;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.59.6.1
date	2009.09.11.04.45.50;	author amylaar;	state Exp;
branches;
next	;

1.1.1.1
date	2000.02.07.00.19.42;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.61
log
@Notice architecture changes even when the register window is not open.

  https://sourceware.org/ml/insight/2013-q3/msg00036.html

gdb/gdbtk/ChangeLog

        * library/interface.tcl (gdbtk_tcl_architecture_changed): Add call
        to gdb_reg_arch_changed.
        * library/regwin.itb (arch_changed): Remove call to
        gdb_reg_arch_changed.
@
text
@# Interface between GDB and Insight.
# Copyright (C) 1997, 1998, 1999, 2001, 2002, 2004, 2008 Red Hat, Inc.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License (GPL) as published by
# the Free Software Foundation; either version 2 of the License, or (at
# your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.


# This variable is reserved for this module.  Ensure it is an array.
global gdbtk_state
set gdbtk_state(busyCount) 0

# *** DEPRECATED: Use GDBEventHandler::breakpoint instead.
# This is run when a breakpoint changes.  The arguments are the
# action, the breakpoint number, and the breakpoint info.
#define_hook gdb_breakpoint_change_hook

# *** DEPRECATED: Use GDBEventHandler::set_variable instead.
# This is run when a `set' command successfully completes in gdb.  The
# first argument is the gdb variable name (as a Tcl list).  The second
# argument is the new value.
#define_hook gdb_set_hook

# ------------------------------------------------------------
#  PROC:  gdbtk_tcl_set_variable - A "set" command was issued
#          in gdb to change an internal variable. Notify
#          gui.
# ------------------------------------------------------------
proc gdbtk_tcl_set_variable {var val} {
  set e [SetVariableEvent \#auto -variable $var -value $val]
  GDBEventHandler::dispatch $e
  delete object $e
}

####################################################################
#                                                                  #
#                        GUI STATE HOOKS                           #
#                                                                  #
####################################################################
# !!!!!   NOTE   !!!!!
# For debugging purposes, please put debug statements at the very
# beginning and ends of all GUI state hooks.

# *** DEPRECATED: Use GDBEventHandler::busy instead.
# GDB_BUSY_HOOK
#   This hook is used to register a callback when the UI should
#   be disabled because the debugger is either busy or talking
#   to the target.
#
#   All callbacks should disable ALL user input which could cause
#   any state changes in either the target or the debugger.
#define_hook gdb_busy_hook

# *** DEPRECATED: Use GDBEventHandler::idle instead.
# GDB_IDLE_HOOK
#   This hook is used to register a callback when the UI should
#   be enabled because the debugger is no longer busy.
#
#   All callbacks should enable user input. These callbacks
#   should also be as fast as possible to avoid any significant
#   time delays when enabling the UI.
define_hook gdb_idle_hook

# *** DEPRECATED: Use GDBEventHandler::update instead.
# GDB_UPDATE_HOOK
#   This hook is used to register a callback to update the widget
#   when debugger state has changed.
#define_hook gdb_update_hook

# GDB_NO_INFERIOR_HOOK
#   This hook is used to register a callback which should be invoked
#   whenever there is no inferior (either at startup time or when
#   an inferior is killed).
#
#   All callbacks should reset their windows to a known, "startup"
#   state.
define_hook gdb_no_inferior_hook

# GDB_DISPLAY_CHANGE_HOOK
# This is run when a display changes.  The arguments are the action,
# the breakpoint number, and (optionally) the value.
define_hook gdb_display_change_hook

# GDB_TRACE_FIND_HOOK
#    This hook is run by the trace find command.  It is used to switch
#    from control to browse mode when the user runs tfind commands...
#
define_hook gdb_trace_find_hook

# ------------------------------------------------------------------
#  gdbtk_tcl_preloop - This function is called after gdb is initialized
#  but before the mainloop is started.  It sets the app name, and
#  opens the first source window.
# ------------------------------------------------------------------

proc gdbtk_tcl_preloop { } {
  global gdb_exe_name gdb_current_directory

  set_baud

  tk appname gdbtk
  # If there was an error loading an executible specified on the command line
  # then we will have called pre_add_symbol, which would set us to busy,
  # but not the corresponding post_add_symbol.  Do this here just in case...
  after idle gdbtk_idle 
  ManagedWin::startup

  if {$gdb_exe_name != ""} {
    # At startup, file_changed_hook is called too late for us, so we
    # must notice the initial session by hand.  If the arguments exist
    # -- if the user used `gdb --args' -- then we want the new
    # arguments and pwd to override what is set in the session.
    set current_args [gdb_get_inferior_args]
    set current_dir $gdb_current_directory
    Session::notice_file_change
    set_baud
    if {[string length $current_args] > 0} {
      gdb_set_inferior_args $current_args
      gdb_cmd "cd $current_dir"
    }
  }
  
  gdbtk_update
}


# ------------------------------------------------------------------
#  PROCEDURE:  gdbtk_busy - Dispatch a busy event
#
#         Use this procedure from within GUI code to indicate that
#         the debugger is busy, either running the inferior or
#         talking to the target.
# ------------------------------------------------------------------
proc gdbtk_busy {} {

  set e [BusyEvent \#auto]
  GDBEventHandler::dispatch $e
  delete object $e

  # Force the screen to update
  update
}

# ------------------------------------------------------------------
#   PROCEDURE:  gdbtk_update - run all update hooks
#
#          Use this procedure to force all widgets to update
#          themselves. This hook is usually run after command
#          that could change target state.
# ------------------------------------------------------------------
proc gdbtk_update {} {

  set e [UpdateEvent \#auto]
  GDBEventHandler::dispatch $e
  delete object $e
  
  # Force the screen to update
  update
}

# ------------------------------------------------------------------
#   PROCEDURE:  gdbtk_update_safe - run all update hooks in a safe way
#
#          Use this procedure to force all widgets to update
#          themselves. This hook is usually run after command
#          that could change target state.
#          Like gdbtk_update but safe to be used in "after idle"
#          which is used in update hooks.
# ------------------------------------------------------------------
proc gdbtk_update_safe {} {
  global gdb_running

  # Fencepost: Do not update if we are running the target
  # We get here because script commands may have changed memory or
  # registers and "after idle" events registered as a consequence
  # If we try to update while the target is running we are doomed.
  if {!$gdb_running} {
    gdbtk_update
  }
}

# ------------------------------------------------------------------
#   PROCEDURE: gdbtk_idle - dispatch IdleEvent
#
#          Use this procedure to free the UI for more user input.
#          This should only be run AFTER all communication with
#          the target has halted, otherwise the risk of two (or
#          more) widgets talking to the target arises.
# ------------------------------------------------------------------
proc gdbtk_idle {} {
  global gdb_running

  # Put the unfiltered hook back in place, just in case
  # somebody swapped it out, and then died before they
  # could replace it.
  gdb_restore_fputs

  set err [catch {run_hooks gdb_idle_hook}]
  if {$err} {
    dbug E "Error running gdb_idle_hook: $::errorInfo"
  }

  set e [IdleEvent \#auto]
  GDBEventHandler::dispatch $e
  delete object $e

  if {!$gdb_running} {
    set err [catch {run_hooks gdb_no_inferior_hook} txt]
    if {$err} { 
      dbug E "no_inferior_hook error: $txt" 
    }
  }

  # Force the screen to update
  update
}

define_hook download_progress_hook

# ------------------------------------------------------------------
#  PROCEDURE:  gdbtk_quit_check - Ask if the user really wants to quit.
# ------------------------------------------------------------------
proc gdbtk_quit_check {} {
  global gdb_downloading gdb_running gdb_exe_name
  
  if {$gdb_downloading} {
    set msg "Downloading to target,\n really close the debugger?"
    if {![gdbtk_tcl_query $msg no]} {
      return 0
    }
  } elseif {$gdb_running} {
    # While we are running the inferior, gdb_cmd is fenceposted and
    # returns immediately. Therefore, we need to ask here. Do we need
    # to stop the target, too?
    set msg "A debugging session is active.\n"
    append msg "Do you still want to close the debugger?"
    if {![gdbtk_tcl_query $msg no]} {
      return 0
    }
  }
  
  return 1
}

# ------------------------------------------------------------------
#  PROCEDURE:  gdbtk_quit - Quit the debugger
#         Call this procedure anywhere the user can request to quit.
#         This procedure will ask all the right questions before
#         exiting.
# ------------------------------------------------------------------
proc gdbtk_quit {} {
  if {[gdbtk_quit_check]} {
    gdbtk_force_quit
  }
}

# ------------------------------------------------------------------
#  PROCEDURE:  gdbtk_force_quit - Quit the debugger immediately
# ------------------------------------------------------------------
proc gdbtk_force_quit {} {
  # If we don't delete source windows, GDB hooks will
  # try to update them as we exit
  foreach win [ManagedWin::find SrcWin] {
    delete object $win
  }
  # Calling gdb_force_quit is probably not necessary here
  # because it should have been called when the source window(s)
  # were deleted, but just in case...
  gdb_force_quit
}

# ------------------------------------------------------------------
#  PROCEDURE:  gdbtk_cleanup - called by GDB immediately
#         before exiting.  Last chance to cleanup!
# ------------------------------------------------------------------
proc gdbtk_cleanup {} {
  global gdb_exe_name

  # Save the session
  if {$gdb_exe_name != ""} {
    Session::save
  }

  # This is a sign that it is too late to be doing updates, etc...
  set ::gdb_shutting_down 1

  # Shutdown the window manager and save all preferences
  # This way a "quit" in the console window will cause
  # preferences to be saved.
  ManagedWin::shutdown
  pref_save
}

# ------------------------------------------------------------------
# PROC: gdbtk_tcl_query -
# ------------------------------------------------------------------
proc gdbtk_tcl_query {message {default yes}} {
  global gdb_checking_for_exit gdbtk_state gdbtk_platform

  # FIXME We really want a Help button here.  But Tk's brain-damaged
  # modal dialogs won't really allow it.  Should have async dialog
  # here.

  set title "GDB"
  set modal "task"

  # If we are checking whether to exit gdb, we want a system modal
  # box.  Otherwise it may be hidden by some other program, and the
  # user will have no idea what is going on.
  if {[info exists gdb_checking_for_exit] && $gdb_checking_for_exit} {
    set modal "system"
  }
  
  if {$gdbtk_platform(platform) == "windows"} {
    # On Windows, we want to only ask each question once.
    # If we're already asking the question, just wait for the answer
    # to come back.
    set ans [list answer $message]
    set pending [list pending $message]

    if {[info exists gdbtk_state($pending)]} {
      incr gdbtk_state($pending)
    } else {
      set gdbtk_state($pending) 1
      set gdbtk_state($ans) {}

      ide_messageBox [list set gdbtk_state($ans)] -icon warning \
	-default $default -message $message -title $title \
	-type yesno -modal $modal -parent .
    }

    vwait gdbtk_state($ans)
    set r $gdbtk_state($ans)
    if {[incr gdbtk_state($pending) -1] == 0} {
      # Last call waiting for this answer, so clear it.
      unset gdbtk_state($pending)
      unset gdbtk_state($ans)
    }
  } else {
    # On Unix, apparently it doesn't matter how many times we ask a
    # question.
    set r [tk_messageBox -icon warning -default $default \
	     -message $message -title $title \
	     -type yesno -parent .]
  }

  update idletasks
  return [expr {$r == "yes"}]
}

# ------------------------------------------------------------------
# PROC: gdbtk_tcl_warning -
# ------------------------------------------------------------------
proc gdbtk_tcl_warning {message} {
  debug "$message"

# ADD a warning message here if the gui must NOT display it
# add the message at the beginning of the switch followed by - 

  switch -regexp $message {
        "Unable to find dynamic linker breakpoint function.*" {return}
	"Internal error.*" { gdbtk_tcl_fputs_error $message }
        "incomplete CFI.*" { gdbtk_tcl_fputs_error $message }
	"RTTI symbol not found for class.*" { gdbtk_tcl_fputs_error $message }
        "DW_AT.*" { gdbtk_tcl_fputs_error $message }
        "unsupported tag.*" { gdbtk_tcl_fputs_error $message }
        default {show_warning $message}
       }
}

# ------------------------------------------------------------------
# PROC: show_warning -
# ------------------------------------------------------------------
proc show_warning {message} {
  global gdbtk_platform

  # FIXME We really want a Help button here.  But Tk's brain-damaged
  # modal dialogs won't really allow it.  Should have async dialog
  # here.
  set title "GDB"
  set modal "task"

# On Windows, we use ide_messageBox which runs the Win32 MessageBox function
# in another thread.  This permits a program which handles IDE requests from
# other programs to not return from the request until the MessageBox completes.
# This is not possible without using another thread, since the MessageBox
# function call will be running its own event loop, and will be higher on the
# stack than the IDE request.
#
# On Unix tk_messageBox runs in the regular Tk event loop, so
# another thread is not required.

 
  if {$gdbtk_platform(platform) == "windows"} {
      ide_messageBox [list set r] -icon warning \
        -default ok -message $message -title $title \
        -type ok -modal $modal -parent .
  } else {
    set r [tk_messageBox -icon warning -default ok \
             -message $message -title $title \
             -type ok -parent .]
  }
} 

# ------------------------------------------------------------------
# PROC: gdbtk_tcl_ignorable_warning -
# ------------------------------------------------------------------
proc gdbtk_tcl_ignorable_warning {class message} {
  catch {ManagedWin::open WarningDlg -center -transient \
	   -message [list $message] -ignorable $class}
}

# ------------------------------------------------------------------
# PROC: gdbtk_tcl_fputs -
# ------------------------------------------------------------------
proc gdbtk_tcl_fputs {message} {
  global gdbtk_state
  # Restore the fputs hook, in case anyone forgot to put it back...
  gdb_restore_fputs

  if {[info exists gdbtk_state(console)] &&   $gdbtk_state(console) != ""} {
    $gdbtk_state(console) insert $message
  }
}

# ------------------------------------------------------------------
# PROC: echo -
# ------------------------------------------------------------------
proc echo {args} {
  gdbtk_tcl_fputs [concat $args]\n
}

# ------------------------------------------------------------------
# PROC: gdbtk_tcl_fputs_error - write an error message
# ------------------------------------------------------------------
proc gdbtk_tcl_fputs_error {message} {
  if {[info exists ::gdbtk_state(console)] && $::gdbtk_state(console) != ""} {
    $::gdbtk_state(console) insert $message err_tag
    update
  }
}

# ------------------------------------------------------------------
# PROC: gdbtk_tcl_fputs_log - write a log message
# ------------------------------------------------------------------
proc gdbtk_tcl_fputs_log {message} {
  if {[info exists ::gdbtk_state(console)] && $::gdbtk_state(console) != ""} {
    $::gdbtk_state(console) insert $message log_tag
    update
  }
}

# ------------------------------------------------------------------
# PROC: gdbtk_tcl_fputs_target - write target output
# ------------------------------------------------------------------
proc gdbtk_tcl_fputs_target {message} {
  if {$::gdbtk_state(console) == ""} {
    ManagedWin::open Console -force
  }
  $::gdbtk_state(console) insert $message target_tag
  update
}


# ------------------------------------------------------------------
# PROC: gdbtk_tcl_fputs_target_err - write target error output
# ------------------------------------------------------------------
proc gdbtk_tcl_fputs_target_err {message} {
  if {$::gdbtk_state(console) == ""} {
    ManagedWin::open Console -force
  }  
  $::gdbtk_state(console) insert $message err_tag
}

# ------------------------------------------------------------------
# PROC: gdbtk_tcl_flush -
# ------------------------------------------------------------------
proc gdbtk_tcl_flush {} {
  debug [info level 0]
}

# ------------------------------------------------------------------
# PROC: gdbtk_tcl_start_variable_annotation -
# ------------------------------------------------------------------
proc gdbtk_tcl_start_variable_annotation {valaddr ref_type stor_cl
					  cum_expr field type_cast} {
  debug [info level 0]
}

# ------------------------------------------------------------------
# PROC: gdbtk_tcl_end_variable_annotation -
# ------------------------------------------------------------------
proc gdbtk_tcl_end_variable_annotation {} {
  debug [info level 0]
}

# ------------------------------------------------------------------
# PROC: gdbtk_tcl_breakpoint - A breakpoint was changed -- notify
#                               gui.
# ------------------------------------------------------------------
proc gdbtk_tcl_breakpoint {action bpnum} {
#  debug "BREAKPOINT: $action $bpnum"
  set e [BreakpointEvent \#auto -action $action -number $bpnum]
  GDBEventHandler::dispatch $e
  delete object $e
}

# ------------------------------------------------------------------
# PROC: gdbtk_tcl_tracepoint - A tracepoint was changed -- notify
#                               gui.
# ------------------------------------------------------------------
proc gdbtk_tcl_tracepoint {action tpnum} {
#  debug "TRACEPOINT: $action $tpnum"
  set e [TracepointEvent \#auto -action $action -number $tpnum]
  GDBEventHandler::dispatch $e
  delete object $e
}

# ------------------------------------------------------------------
# PROC: gdbtk_tcl_trace_find_hook -
# ------------------------------------------------------------------
proc gdbtk_tcl_trace_find_hook {arg from_tty} {
#  debug "$arg $from_tty"
  run_hooks gdb_trace_find_hook $arg $from_tty
}

################################################################
#
# Handle `readline' interface.
#

# Run a command that is known to use the "readline" interface.  We set
# up the appropriate buffer, and then run the actual command via
# gdb_cmd.  Calls into the "readline" callbacks just return values
# from our list.

# ------------------------------------------------------------------
# PROC: gdb_run_readline_command -
# ------------------------------------------------------------------
proc gdb_run_readline_command {command args} {
  global gdbtk_state
  debug "$command $args"
  set gdbtk_state(readlineArgs) $args
  set gdbtk_state(readlineShowUser) 1
  gdb_cmd $command
}

# ------------------------------------------------------------------
# PROC: gdb_run_readline_command_no_output
# Run a readline command, but don't show the commands to the user.
# ------------------------------------------------------------------
proc gdb_run_readline_command_no_output {command args} {
  global gdbtk_state
  debug "$command $args"
  set gdbtk_state(readlineArgs) $args
  set gdbtk_state(readlineShowUser) 0
  gdb_cmd $command
}

# ------------------------------------------------------------------
# PROC: gdbtk_tcl_readline_begin -
# ------------------------------------------------------------------
proc gdbtk_tcl_readline_begin {message} {
  global gdbtk_state
#  debug
  set gdbtk_state(readline) 0
  if {$gdbtk_state(console) != "" && $gdbtk_state(readlineShowUser)} {
    $gdbtk_state(console) insert $message
  }
}

# ------------------------------------------------------------------
# PROC: gdbtk_tcl_readline -
# ------------------------------------------------------------------
proc gdbtk_tcl_readline {prompt} {
  global gdbtk_state
#  debug "prompt=$prompt"
  if {[info exists gdbtk_state(readlineArgs)]} {
    # Not interactive, so pop the list, and print element.
    set cmd [lvarpop gdbtk_state(readlineArgs)]
    if {$gdbtk_state(console) != "" && $gdbtk_state(readlineShowUser)} {
      $gdbtk_state(console) insert $cmd
    }
  } else {
    # Interactive.
#    debug "interactive"
    set gdbtk_state(readline) 1
    $gdbtk_state(console) activate $prompt
    vwait gdbtk_state(readline_response)
    set cmd $gdbtk_state(readline_response)
#    debug "got response: $cmd"
    unset gdbtk_state(readline_response)
    set gdbtk_state(readline) 0
  }
  return $cmd
}

# ------------------------------------------------------------------
# PROC: gdbtk_tcl_readline_end -
# ------------------------------------------------------------------
proc gdbtk_tcl_readline_end {} {
  global gdbtk_state
#  debug
  catch {unset gdbtk_state(readlineArgs)}
  catch {unset gdbtk_state(readlineActive)}
}

# ------------------------------------------------------------------
# PROC: gdbtk_tcl_busy - this is called immediately before gdb 
#    executes a command.
#
# ------------------------------------------------------------------
proc gdbtk_tcl_busy {} {
  global gdbtk_state
  if {[incr gdbtk_state(busyCount)] == 1} {
    gdbtk_busy
  }
}

################################################################
#
# 
#

# ------------------------------------------------------------------
# PROC: gdbtk_tcl_idle - this is called immediately after gdb 
#    executes a command.
# ------------------------------------------------------------------
proc gdbtk_tcl_idle {} {
  global gdbtk_state
  if {$gdbtk_state(busyCount) > 0
      && [incr gdbtk_state(busyCount) -1] == 0} {
    gdbtk_update
    gdbtk_idle
  }
}

# ------------------------------------------------------------------
# PROC: gdbtk_tcl_tstart -
# ------------------------------------------------------------------
proc gdbtk_tcl_tstart {} {
  set srcwin [lindex [manage find src] 0]
  $srcwin.toolbar do_tstop 0
  
}

# ------------------------------------------------------------------
# PROC: gdbtk_tcl_tstop -
# ------------------------------------------------------------------
proc gdbtk_tcl_tstop {} {
  set srcwin [lindex [manage find src] 0]
  $srcwin.toolbar do_tstop 0
  
}


# ------------------------------------------------------------------
# PROC: gdbtk_tcl_display -
#
# A display changed.  ACTION is `enable', `disable', `delete',
# `create', or `update'.  VALUE is only meaningful in the `update'
# case.
# ------------------------------------------------------------------
proc gdbtk_tcl_display {action number {value {}}} {
  # Handle create explicitly.
  if {$action == "create"} {
    manage create_if_never data
  }
  run_hooks gdb_display_change_hook $action $number $value
}

# ------------------------------------------------------------------
#  PROCEDURE: gdbtk_register_changed
#         This hook is called from value_assign to inform us that
#         the user has changed the contents of a register.
# ------------------------------------------------------------------
proc gdbtk_register_changed {} {
  after idle gdbtk_update_safe
}

# ------------------------------------------------------------------
#  PROCEDURE: gdbtk_memory_changed
#         This hook is called from value_assign to inform us that
#         the user has changed the contents of memory (including
#         the program's variables).
# ------------------------------------------------------------------
proc gdbtk_memory_changed {} {
  after idle gdbtk_update_safe
}

####################################################################
#                                                                  #
#                           FILE HOOKS                             #
#                                                                  #
#    There are a number of hooks that are installed in gdb to      #
#    aid with file-like commands (selecting an exectuable and      #
#    loading symbols):                                             #
#         - exec_file_display_hook                                 #
#            Called in exec_file_command. The tcl hook is          #
#            "gdbtk_tcl_exec_file_display"                         #
#         - file_changed_hook                                      #
#            Called in file_command. The tcl hook is               #
#            "gdbtk_tcl_file_changed"                              #
#         - deprecated_pre_add_symbol_hook                         #
#            Called in symbol_file_add before loading. The tcl     #
#            hook is "gdbtk_tcl_pre_add_symbol"                    #
#         - deprecated_post_add_symbol_hook                        #
#            Called in symbol_file_add when finished loading       #
#            a symbol file. The tcl hook is                        #
#            "gdbtk_tcl_post_add_symbol"                           #
#                                                                  #
#  Together, these hooks should give the gui enough information    #
#  to cover the two most common uses of file commands:             #
#  1. executable with symbols                                      #
#  2. separate executable and symbol file(s)                       #
#                                                                  #
####################################################################
define_hook file_changed_hook

# ------------------------------------------------------------------
#  PROCEDURE:  gdbtk_tcl_pre_add_symbol
#         This hook is called before any symbol files
#         are loaded so that we can inform the user.
# ------------------------------------------------------------------
proc gdbtk_tcl_pre_add_symbol {file} {

  gdbtk_busy

  # Display some feedback to the user
  set srcs [ManagedWin::find SrcWin]
  foreach w $srcs {
    $w set_status "Reading symbols from $file..."
  }
  update idletasks
}

# ------------------------------------------------------------------
#   PROCEDURE: gdbtk_tcl_post_add_symbol
#          This hook is called after we finish reading a symbol
#          file, so the source windows' combo boxes need filling.
# ------------------------------------------------------------------
proc gdbtk_tcl_post_add_symbol {} {

  set srcs [ManagedWin::find SrcWin]
  foreach w $srcs {
    $w fillNameCB
  }
  gdbtk_idle
}

# ------------------------------------------------------------------
#  PROCEDURE: gdbtk_tcl_file_changed
#         This hook is called whenever the exec file changes.
#         This is called AFTER symbol reading, so it is
#         ok to point to main when we get called.
# ------------------------------------------------------------------
proc gdbtk_tcl_file_changed {filename} {

  if {$filename == ""} {
    gdb_clear_file
    catch {run_hooks gdb_clear_file_hook}
    set ::gdb_exe_name ""
    set ::gdb_loaded 0
    set ::gdb_running 0
    gdbtk_update
  } else {
    SrcWin::point_to_main
    run_hooks file_changed_hook
  }
}

# ------------------------------------------------------------------
#  PROCEDURE: gdbtk_tcl_exec_file_display 
#         This hook is called from exec_file_command. It's purpose
#         is to setup the gui for a new file. Note that we cannot
#         look for main, since this hook is called BEFORE we
#         read symbols. If the user used the "file" command,
#         gdbtk_tcl_file_changed will set the source window to
#         look at main. If the user used "exec-file" and "add-symbol"
#         commands, then we cannot look for main.
# ------------------------------------------------------------------
proc gdbtk_tcl_exec_file_display {filename} {
  global gdb_exe_changed

  # DO NOT CALL set_exe here! 

  # Clear out the GUI, don't do it if filename is "" so that
  # you avoid distracting flashes in the source window.

  if {$filename != ""} {
    gdbtk_clear_file
  }

  # set_exe calls file command with the filename in
  # quotes, so we need to strip them here.
  # We need to make sure that we turn filename into
  # an absolute path or sessions won't work.
  if {[file tail $filename] == $filename} {
    # want full pathname
    set filename [file join $::gdb_current_directory $filename]
  }
  set_exe_name $filename
  set gdb_exe_changed 0

  SrcWin::point_to_main
}

# ------------------------------------------------------------------
#  PROCEDURE: gdbtk_locate_main 
#         This proc tries to locate a suitable main function from
#         a list of names defined in the gdb/main_names preference; 
#         returns the linespec (see below) if found, or a null string
#         if not.
#
#  The return linespec looks like this:
#  0: basename of the file
#  1: function name
#  2: full filename
#  3: source line number
#  4: address
#  5: current PC - which will often be the same as address, but not when
#  we are browsing, or walking the stack.
#  6: shared library name if the pc is in a shared lib
#
# ------------------------------------------------------------------
proc gdbtk_locate_main {{init ""}} {
  global _main_cache gdb_exe_name
  debug

  if {$init == "" && $_main_cache != ""} {
    #debug "returning $_main_cache from cache"
    return $_main_cache
  }
  set _main_cache {}

  set main_names [pref get gdb/main_names]
  foreach main $main_names {
    if {![catch {gdb_loc $main} linespec]} {
      set _main_cache $linespec
      break
    }
  }
  if {$_main_cache == {} 
      && ![catch gdb_entry_point entry_point]
      && ![catch {gdb_loc "*$entry_point"} linespec]} {
    set _main_cache $linespec
  }
  
  # need to see if result is valid
  lassign $_main_cache file func ffile line addr rest
  if {$addr == 0x0 && $func == {}} { set _main_cache {} }

  #debug "returning $_main_cache"
  return $_main_cache
}

##############################################
#  The rest of this file is an assortment of Tcl wrappers
#  for various bits of gdb functionality.
#
#############################################

# ------------------------------------------------------------------
# PROC: set_exe_name - Update the executable name
# ------------------------------------------------------------------
proc set_exe_name {exe} {
  global gdb_exe_name gdb_exe_changed
  #debug "exe=$exe  gdb_exe_name=$gdb_exe_name"

  set gdb_exe_name $exe
  set gdb_exe_changed 1    
}


# ------------------------------------------------------------------
# PROC: set_exe -
# ------------------------------------------------------------------ 
proc set_exe {} {
  global gdb_exe_name gdb_exe_changed gdb_target_changed gdb_loaded file_done
#  debug "gdb_exe_changed=$gdb_exe_changed gdb_exe_name=$gdb_exe_name"
  if {$gdb_exe_changed} {
    set gdb_exe_changed 0
    if {$gdb_exe_name == ""} { return }
    set err [catch {gdb_cmd "file '$gdb_exe_name'" 1} msg]
    if {$err} {
      dbug E "$msg"
      set l [split $msg :]
      set errtxt [join [lrange $l 1 end] :]
      set msg "Error loading \"$gdb_exe_name\":\n"
      append msg $errtxt
      tk_messageBox -title "Error" -message $msg -icon error \
	-type ok
      set gdb_exe_name {}
      set file_done 0
      return
    } elseif {[string match {*no debugging symbols found*} $msg]} {
      tk_messageBox -icon error -default ok \
	-title "GDB" -type ok \
	-message "This executable has no debugging information."
    }

    # force new target command
    set gdb_target_changed 1
    set gdb_loaded 0
    set file_done 1
  }
}

# ------------------------------------------------------------------
#  _open_file - open a file dialog to select a file for debugging.
#  If filename is not "", then open this file.
# ------------------------------------------------------------------

proc _open_file {{file ""}} {
  global gdb_running gdb_downloading gdbtk_platform
  
  if {$gdb_running || $gdb_downloading} {
    # We are already running/downloading something..
    if {$gdb_running} {
      set msg "A debugging session is active.\nAbort session and load new file?"
    } else {
      set msg "A download is in progress.\nAbort download and load new file?"
    }
    if {![gdbtk_tcl_query $msg no]} {
      return 0
    }
  }

  if {[string compare $file ""] == 0} {
    set curFocus [focus]
    
    # Make sure that this is really a modal dialog...
    # FIXME: Add a disable_all to ide_grab_support.
    
    ide_grab_support disable_except {}
    
    set file [tk_getOpenFile -parent . -title "Load New Executable"]
  
    ide_grab_support enable_all
    
    # If no one had the focus before, leave it that way (since I
    # am not sure how this could happen...  Also, the vwait in 
    # tk_getOpenFile could have allowed the curFocus window to actually
    # be destroyed, so make sure it is still around.
    
    if {$curFocus != "" && [winfo exists $curFocus]} {
      raise [winfo toplevel $curFocus]
      focus $curFocus
    }
  } elseif {![file exists $file]} {
    tk_messageBox -message "File \"$file\" does not exist"
    return 0
  }
    

  if {$file == ""} {
    return 0
  }
  # Add the base dir for this file to the source search path.
  set root [file dirname $file]
  if {$gdbtk_platform(os) == "cygwin"} {
    set root [ide_cygwin_path to_posix $root]
    set file [ide_cygwin_path to_posix $file]
  }
  
  catch {gdb_cmd "cd $root"}

  # Clear out gdb's internal state, so that it will allow us
  # (the gui) to ask the user questions.
  gdb_clear_file

  # The gui needs to set this...
  set_exe_name $file
  
  # set_exe needs to be called anywhere the gui does a file_command...
  if {[set_exe] == "cancel"} {
    gdbtk_update
    gdbtk_idle
    return 0
  }

  return 1
}

# ------------------------------------------------------------------
#  _close_file - close the current executable and prepare for
#    another executable.
# ------------------------------------------------------------------
proc _close_file {} {

  # If there is already an inferior, ask him if he wants to close
  # the file. If there is already an exec file loaded (and not run)
  # also ask, but don't ask twice.
  set okay 1
  if {[gdb_target_has_execution]} {
    set okay [gdbtk_tcl_query "Program is already running.\nClose file anyway?"]
  } elseif {$::gdb_exe_name != ""} {
    set okay [gdbtk_tcl_query "Program already loaded.\nClose file anyway?"]
  } else {
    # No exec file yet
    return
  }

  if {$okay} {
    Session::save
    gdb_clear_file
    gdbtk_tcl_file_changed ""

    # Print out a little message to all console windows
    foreach cw [ManagedWin::find Console] {
      $cw insert "No executable file now.\n"
    }
  }
}

# ------------------------------------------------------------------
# PROC: set_target_name - Update the target name.  
#
# This function will prompt for a new target and update
# all variables.
#
# If $prompt is 0 it will just update gdb_target_cmd from gdb_target.
#
# RETURN:
#     1 if successful, 
#     0 if the not (the user canceled the target selection dialog)
# ------------------------------------------------------------------
proc set_target_name {{prompt 1}} {
  global gdb_target_name gdb_target_changed gdb_exe_changed
  global gdb_target_cmd gdb_pretty_name
#  debug
  set cmd_tmp $gdb_target_cmd
  set name_tmp $gdb_target_name

#  debug "gdb_target_name=$gdb_target_name; name_tmp=$name_tmp"
  if {$prompt} {
    set win [ManagedWin::open TargetSelection -exportcancel 1 -center \
	       -transient]
    # need to call update here so the target selection dialog can take over
    update idletasks
  }

#  debug "gdb_target_name=$gdb_target_name"
  if {$gdb_target_name == "CANCEL"} {
    set gdb_target_cmd $cmd_tmp
    set gdb_target_name $name_tmp
    return 0
  }
  set target $gdb_target_name
  set targ [TargetSelection::getname $target cmd]
  set gdb_target_cmd $cmd_tmp
  set gdb_pretty_name [TargetSelection::getname $target pretty-name]

#  debug "target=$target pretty_name=$gdb_pretty_name"
  set targ_opts ""
  switch -regexp -- $gdb_target_name {
    sim|ice {
      set targ $gdb_target_name
      set targ_opts [pref getd gdb/load/${gdb_target_name}-opts]
    }
    default {
      set port [pref getd gdb/load/$target-port]
      if {$port == ""} {
	set port [pref get gdb/load/default-port]
      }
      set portnum [pref getd gdb/load/$target-portname]
      if {$portnum == ""} {
	set portnum [pref get gdb/load/default-portname]
      }
      set hostname [pref getd gdb/load/$target-hostname]
      if {$hostname == ""} {
	set hostname [pref getd gdb/load/default-hostname]
      }
      # replace "com1" with the real port name
      set targ [lrep $targ "com1" $port]
      # replace "tcpX" with hostname:portnum
      set targ [lrep $targ "tcpX" ${hostname}:${portnum}]
      # replace "ethX" with hostname
      set targ [lrep $targ "ethX" e=${hostname}]
    }
  }
  
#  debug "targ=$targ gdb_target_cmd=$gdb_target_cmd"
  if {$gdb_target_cmd != $targ || $gdb_target_changed} {
    set gdb_target_changed 1
    set gdb_target_cmd "$targ $targ_opts"
  }
  return 1
}

# ------------------------------------------------------------------
# PROC: set_target - Change the target
# ------------------------------------------------------------------
proc set_target {} {
  global gdb_target_cmd gdb_target_changed gdb_pretty_name gdb_target_name
  #debug "gdb_target_changed=$gdb_target_changed gdb_target_cmd=\"$gdb_target_cmd\""
  #debug "gdb_target_name=$gdb_target_name"
  if {$gdb_target_cmd == "" && ![TargetSelection::native_debugging]} {
    if {$gdb_target_name == ""} {
      set prompt 1

      # get the default
      #set gdb_target_name [pref getd gdb/load/target]
    } else {
      set prompt 0
    }
    if {![set_target_name $prompt]} {
      set gdb_target_name ""
      return CANCELED
    }
  }
  
  if {$gdb_target_changed} {
    set srcWin [lindex [ManagedWin::find SrcWin] 0]

    $srcWin set_status "Trying to communicate with target $gdb_pretty_name" 1
    update
    catch {gdb_cmd "detach"}
    debug "CONNECTING TO TARGET: $gdb_target_cmd"
    gdbtk_busy
    set err [catch {gdb_immediate "target $gdb_target_cmd"} msg ]
    $srcWin set_status
    gdbtk_idle

    if {$err} {
      if {[string first "Program not killed" $msg] != -1} {
	return CANCELED
      }
      update
      set dialog_title "GDB"
      set debugger_name "GDB"
      tk_messageBox -icon error -title $dialog_title -type ok \
	-message "$msg\n\n$debugger_name cannot connect to the target board\
using [lindex $gdb_target_cmd 1].\nVerify that the board is securely connected and, if\
necessary,\nmodify the port setting with the debugger preferences."
      return ERROR
    }
    
    if {![catch {pref get gdb/load/$gdb_target_name-after_attaching} aa] && $aa != ""} {
      if {[catch {gdb_cmd $aa} err]} {
	catch {[ManagedWin::find Console] insert $err err_tag}
      }
    }
    set gdb_target_changed 0
    return TARGET_CHANGED
  }
  return TARGET_UNCHANGED
}

# ------------------------------------------------------------------
# PROC: run_executable -
#
# This procedure is used to run an executable.  It is called when the 
# run button is used.
# ------------------------------------------------------------------
proc run_executable { {auto_start 1} } {
  global gdb_loaded gdb_downloading gdb_target_name
  global gdb_exe_changed gdb_target_changed gdb_program_has_run
  global gdb_running gdb_exe_name gdbtk_platform

#  debug "auto_start=$auto_start gdb_target_name=$gdb_target_name"

  set gdb_running_saved $gdb_running
  set gdb_running 0

  # No executable was specified.  Prompt the user for one.
  if {$gdb_exe_name == ""} {
    if {[_open_file]} {
      run_executable $auto_start
      return
    } else {
      # The user canceled the load of a new executable.
      return
    }
  }

  if {$gdb_downloading} { return }
  if {[pref get gdb/control_target]} {
    # Breakpoint mode
    set_exe

    # Attach
    if {$gdb_target_name == "" || [pref get gdb/src/run_attach]} {
      set r [gdbtk_attach_remote]
      if {$r == "ATTACH_CANCELED" || $r == "ATTACH_ERROR"} {
	return
      }
    }

    # Download
    if {[pref get gdb/src/run_load] && $gdb_target_name != "exec"} {
      debug "Downloading..."
      set gdb_loaded 0
      
      # if the app has not been downloaded or the app has already
      # started, we need to redownload before running
      if {!$gdb_loaded} {
	if {[Download::download_it]} {
	  # user cancelled the command
#	  debug "user cancelled the command $gdb_running"
	  set gdb_loaded 0
	  gdbtk_update
	  gdbtk_idle
	}
	if {!$gdb_loaded} {
	  # The user cancelled the download after it started
#	  debug "User cancelled the download after it started $gdb_running"
	  gdbtk_update
	  gdbtk_idle
	  return
	}
      }
    }

    # _Now_ set/clear breakpoints
    if {[pref get gdb/load/exit] && ![TargetSelection::native_debugging]} {
      debug "Setting new BP at exit"
      catch {gdb_cmd "clear exit"}
      catch {gdb_cmd "break exit"}
    }
      
    if {[pref get gdb/load/main]} {
      set main "main"
      if {[set linespec [gdbtk_locate_main]] != ""} {
        set main [lindex $linespec 1]
      }
      debug "Setting new BP at $main"
      catch {gdb_cmd "clear $main"}
      catch {gdb_cmd "break $main"}
    }

    # set BP at user-specified function
    if {[pref get gdb/load/bp_at_func]} {
      foreach bp [pref get gdb/load/bp_func] {
	debug "Setting BP at $bp"
	catch {gdb_cmd "clear $bp"}
	catch {gdb_cmd "break $bp"}
      }
    }

    # This is a hack.  If the target is "sim" the opts are appended
    # to the target command. Otherwise they are assumed to be command line
    # args.  What about simulators that accept command line args?
    if {$gdb_target_name != "sim"} {
      # set args
      set gdb_args [pref getd gdb/load/$gdb_target_name-opts]
      if { $gdb_args != ""} {
	debug "set args $gdb_args"
	gdb_set_inferior_args $gdb_args
      }
    }

    # If the user requested it, start an xterm for use as the
    # inferior's tty.
    if {$gdbtk_platform(platform) != "windows"
	&& [pref getd gdb/process/xtermtty] == "yes"} {
      tty::create
    }

    # 
    # Run

    if {$auto_start} {
      if {[pref get gdb/src/run_run]} {
	debug "Runnning target..."
	set run run
      } else {
	debug "Continuing target..."
	set run cont
      }
      if {$gdb_target_name == "exec"} {
	set run run
      }
      if {[catch {gdb_immediate $run} msg]} {
	dbug W "msg=$msg"
	gdbtk_idle
	if {[string match "*help target*" $msg]} {
	  set_target_name
	  run_executable $auto_start
	  return
	}
	if {[string match "No executable*" $msg]} {
	  # No executable was specified.  Prompt the user for one.
	  if {[_open_file]} {
	    run_executable $auto_start
	  } else {
	    debug "CANCELLED"
	  }
	  return
	}
	set gdb_running $gdb_running_saved
      } else {
	debug RUNNING
	set gdb_running 1
      }
    } else {
      SrcWin::point_to_main
    }
    
    gdbtk_update
    gdbtk_idle
  } elseif {[pref get gdb/mode]} {
    # tracepoint -- need to tstart
    set gdb_running 1
    tstart
  }
  return
}

# ------------------------------------------------------------------
#  PROC: gdbtk_attach_remote - attach to the target
#        This proc returns the following status messages:
#
#        ATTACH_ERROR: An error occurred connecting to target.
#        ATTACH_CANCELED: The attach was canceled.
#        ATTACH_TARGET_CHANGED: Successfully attached, target changed.
#        ATTACH_TARGET_UNCHANGED: Successfully attached, target unchanged.
#        UNKNOWN: An unknown error occurred.
# ------------------------------------------------------------------
proc gdbtk_attach_remote {} {
  global gdb_loaded

  debug "Attaching...."
  set r UNKNOWN
  while {1} {

    switch [set_target] {

      ERROR {
	# target command failed, ask for a new target name
	if {![set_target_name]} {
	  # canceled again
	  set r ATTACH_ERROR
	  break
	}
      }

      TARGET_CHANGED {
	# success -- target changed
	set gdb_loaded 0
	set r ATTACH_TARGET_CHANGED
	break
      }

      CANCELED {
	# command cancelled by user
	set r ATTACH_CANCELED
	break
      }

      TARGET_UNCHANGED {
	# success -- target NOT changed (i.e., rerun)
	set r ATTACH_TARGET_UNCHANGED
	break
      }
    }
  }

#  debug "Attach returning: \"$r\""
  return $r
}

# ------------------------------------------------------------------
# PROC:  gdbtk_connect: connect to a remote target 
#                      in asynch mode if async is 1
# ------------------------------------------------------------------
proc gdbtk_connect {{async 0}} {
  global file_done

  debug "async=$async"

  gdbtk_busy

  set result [gdbtk_attach_remote]
  switch $result {
    ATTACH_ERROR {
      set successful 0
    }

    ATTACH_TARGET_CHANGED {
	if {[pref get gdb/load/check] && $file_done} {
	  set err [catch {gdb_cmd "compare-sections"} errTxt]
	  if {$err} {
	    set successful 0
	    tk_messageBox -title "Error" -message $errTxt \
	      -icon error -type ok
	    break
	  }
	}

	tk_messageBox -title "GDB" -message "Successfully connected" \
	  -icon info -type ok
	set successful 1
    }

    ATTACH_CANCELED {
	tk_messageBox -title "GDB" -message "Connection Canceled" -icon info \
	  -type ok
	set successful 0
    }

    ATTACH_TARGET_UNCHANGED {
	tk_messageBox -title "GDB" -message "Successfully connected" \
	  -icon info -type ok
	set successful 1
    }

    default {
	dbug E "Unhandled response from gdbtk_attach_remote: \"$result\""
	set successful 0
    }
  }

  gdbtk_idle

  # Whenever we attach, we need to do an update
  if {$successful} {
    gdbtk_attached
  }
  return $successful
}

# ------------------------------------------------------------------
#  PROC: gdbtk_step - step the target
# ------------------------------------------------------------------
proc gdbtk_step {} {
  catch {gdb_immediate step}
}

# ------------------------------------------------------------------
#  PROC: gdbtk_next
# ------------------------------------------------------------------
proc gdbtk_next {} {
  catch {gdb_immediate next}
}

# ------------------------------------------------------------------
#  PROC: gdbtk_finish
# ------------------------------------------------------------------
proc gdbtk_finish {} {
  catch {gdb_immediate finish}
}

# ------------------------------------------------------------------
#  PROC: gdbtk_continue
# ------------------------------------------------------------------
proc gdbtk_continue {} {
  catch {gdb_immediate continue}
}

# ------------------------------------------------------------------
#  PROC: gdbtk_stepi
# ------------------------------------------------------------------
proc gdbtk_stepi {} {
  catch {gdb_immediate stepi}
}

# ------------------------------------------------------------------
#  PROC: gdbtk_nexti
# ------------------------------------------------------------------
proc gdbtk_nexti {} {
  catch {gdb_immediate nexti}
}

# ------------------------------------------------------------------
#  PROC: gdbtk_attached
# ------------------------------------------------------------------
#
# This is called AFTER gdb has successfully done an attach.  Use it to 
# bring the GUI up to a current state...
proc gdbtk_attached {} {
  gdbtk_update
}

# ------------------------------------------------------------------
#  PROC: gdbtk_detached
# ------------------------------------------------------------------
#
# This is called AFTER gdb has successfully done an detach.  Use it to 
# bring the GUI up to a current state...
proc gdbtk_detached {} {
  if {!$::gdb_shutting_down} {
    run_hooks gdb_no_inferior_hook
  }
}

# ------------------------------------------------------------------
#  PROC: gdbtk_stop
# ------------------------------------------------------------------
#
# The stop button is tricky. In order to use the stop button,
# the debugger must be able to keep gui alive while target_wait is
# blocking (so that the user can interrupt or detach from it).
# 
# The best solution for this is to capture gdb deep down where it can
# block. For _any_ target board, this will be in either serial or
# socket code. These places call deprecated_ui_loop_hook to keep us
# alive. For native unix, we use an interval timer.  Simulators either
# call deprecated_ui_loop_hook directly (older sims, at least) or they
# call gdb's os_poll_quit callback, where we insert a call to
# deprecated_ui_loop_hook. Some targets (like v850ice and windows
# native) require a call to deprecated_ui_loop_hook directly in
# target_wait. See comments before gdb_stop and x_event to find out
# more about how this is accomplished.
#
# The stop button's behavior:
# Pressing the stop button should attempt to stop the target. If, after
# some time (like 3 seconds), gdb fails to fall out of target_wait (i.e.,
# the gui's idle hooks are run), then open a dialog asking the user if
# he'd like to detach.
proc gdbtk_stop {} {
  global _gdbtk_stop

  if {$_gdbtk_stop(timer) == ""} {
    add_hook gdb_idle_hook gdbtk_stop_idle_callback
    set _gdbtk_stop(timer) [after 15000 gdbtk_detach]
    catch {gdb_stop}
  }
}

# ------------------------------------------------------------------
#  PROC: gdbtk_stop_idle_callback
# ------------------------------------------------------------------
# This callback normally does nothing. When the stop button has
# been pressed, though, and gdb has successfully stopped the target,
# this callback will clean up after gdbtk_stop, removing the "Detach"
# dialog (if it's open) and gettingg rid of any outstanding timers
# and hooks.
proc gdbtk_stop_idle_callback {} {
  global _gdbtk_stop gdbtk_state

  # Check if the dialog asking if user wants to detach is open
  # and unpost it if it exists.
  if {$_gdbtk_stop(msg) != ""} {
    set ans [list answer $_gdbtk_stop(msg)]
    set gdbtk_state($ans) no
  }

  if {$_gdbtk_stop(timer) != ""} {
    # Cancel the timer callback
    after cancel $_gdbtk_stop(timer)
    set _gdbtk_stop(timer) ""
    catch {remove_hook gdb_idle_hook gdbtk_stop_idle_callback}
  }
}

# ------------------------------------------------------------------
#  PROC: gdbtk_detach
# ------------------------------------------------------------------
# This proc is installed as a timer event when the stop button
# is pressed. If target_wait doesn't return (we were unable to stop
# the target), then this proc is called.
#
# Open a dialog box asking if the user would like to detach. If so,
# try to detach. If not, do nothing and go away.
proc gdbtk_detach {} {
  global _gdbtk_stop

  set _gdbtk_stop(msg) "No response from target. Detach from target\n(and stop debugging it)?"
  if {[gdbtk_tcl_query  $_gdbtk_stop(msg) no]} {
    catch {gdb_stop detach}
  }

  set _gdbtk_stop(timer) ""
  set _gdbtk_stop(msg) ""
  remove_hook gdb_idle_hook gdbtk_stop_idle_callback
}

# ------------------------------------------------------------------
#  PROC: gdbtk_run
# ------------------------------------------------------------------
proc gdbtk_run {} {
  if {$::gdb_running == 1} {
    set msg "A program is currently being debugged.\n"
    append msg "Do you want to restart?"
    if {![gdbtk_tcl_query $msg no]} {
      # NO
      return
    }
  }
  run_executable
}

# ------------------------------------------------------------------
# PROC:  gdbtk_attach_native: attach to a running target
# ------------------------------------------------------------------
proc gdbtk_attach_native {} {
    ManagedWin::open_dlg AttachDlg ;#-transient

    debug "ManagedWin got [AttachDlg::last_button] [AttachDlg::pid]"

    if {[AttachDlg::last_button]} {
	set pid [AttachDlg::pid]
	set symbol_file [AttachDlg::symbol_file]
	if {$symbol_file != "" && ![_open_file $symbol_file]} {
	    ManagedWin::open WarningDlg -transient \
		    -message "Could not load symbols from $symbol_file."
	    return
	}
	
	if {[catch {gdb_cmd "attach $pid"} result]} {
	    ManagedWin::open WarningDlg -transient \
		    -message [list "Could not attach to $pid:\n$result"]
	    return
	}
    }
}

# ------------------------------------------------------------------
# PROC: set_baud -  Tell GDB the baud rate.
# ------------------------------------------------------------------
proc set_baud {} {
  global gdb_target_name
  #set target [ide_property get target-internal-name]
  set baud [pref getd gdb/load/${gdb_target_name}-baud]
  if {$baud == ""} {
    set baud [pref get gdb/load/baud]
  }
#  debug "setting baud to $baud"
  catch {gdb_cmd "set remotebaud $baud"}
}

# ------------------------------------------------------------------
# PROC: do_state_hook -
# ------------------------------------------------------------------
proc do_state_hook {varname ind op} {
  run_hooks state_hook $varname
}

# ------------------------------------------------------------------
# PROC: gdbtk_disconnect -
# ------------------------------------------------------------------
proc gdbtk_disconnect {{async 0}} {
   global gdb_loaded gdb_target_changed
   catch {gdb_cmd "detach"}
   # force a new target command to do something
   set gdb_loaded 0
   set gdb_target_changed 1
   set gdb_running 0
   gdbtk_idle
   gdbtk_update
 }

# ------------------------------------------------------------------
# PROC: tstart -
# ------------------------------------------------------------------
proc tstart {} {
   if {[catch {gdb_cmd "tstart"} errTxt]} {
     tk_messageBox -title "Error" -message $errTxt -icon error \
       -type ok
    gdbtk_idle
     return 0
   }
  return 1
}

# ------------------------------------------------------------------
# PROC: tstop -
# ------------------------------------------------------------------
proc tstop {} {

   if {[catch {gdb_cmd "tstop"} errTxt]} {
     tk_messageBox -title "Error" -message $errTxt -icon error \
       -type ok
     gdbtk_idle
     return 0
   }
   return 1
 }

# ------------------------------------------------------------------
# PROC: source_file -
# ------------------------------------------------------------------
proc source_file {} {
  set file_name [tk_getOpenFile -title "Choose GDB Command file"]
  if {$file_name != ""} {
    gdb_cmd "source $file_name"
  }
}


# -----------------------------------------------------------------------------
# NAME:		gdbtk_signal
#
# SYNOPSIS:	gdbtk_signal {name longname}
#
# DESC:		This procedure is called from GDB when a signal	
#		is generated, for example, a SIGSEGV.
#
# ARGS:		name - The name of the signal, as returned by
#			target_signal_to_name().
#		longname - A description of the signal.
# -----------------------------------------------------------------------------
proc gdbtk_signal {name {longname ""}} {
  dbug W "caught signal $name $longname"
  set longname
  set message "Program received signal $name, $longname"
  set srcs [ManagedWin::find SrcWin]
  foreach w $srcs {
    $w set_status $message
  }
  gdbtk_tcl_ignorable_warning signal $message
  update idletasks
}

# Hook for clearing out executable state. Widgets should register a callback
# for this hook if they have anything that may need cleaning if the user
# requests to re-load an executable.
define_hook gdb_clear_file_hook

# -----------------------------------------------------------------------------
# NAME:       gdbtk_clear_file
#
# SYNOPSIS:   gdbtk_clear_file
#
# DESC:       This procedure is called when the user requests a new exec
#             file load. It runs the gdb_clear_file_hook, which tells
#             all widgets to clear state. It CANNOT call gdb_clear_file,
#             since this hook runs AFTER we load a new exec file (i.e.,
#             gdb_clear_file would clear the file name).
#
# ARGS:       none
# -----------------------------------------------------------------------------
proc gdbtk_clear_file {} {
  global gdb_target_name

  debug
  # Give widgets a chance to clean up
  catch {run_hooks gdb_clear_file_hook}

  # Save the target name in case the user has already selected a
  # target. No need to force the user to select it again.
  set old_target $gdb_target_name

  # Finally, reset our state
  initialize_gdbtk

  set gdb_target_name $old_target
}

# ------------------------------------------------------------------
#  PROC: intialize_gdbtk - (re)initialize gdbtk's state
# ------------------------------------------------------------------
proc initialize_gdbtk {} {
  global gdb_exe_changed gdb_target_changed gdb_running gdb_downloading \
    gdb_loaded gdb_program_has_run file_done gdb_pretty_name gdb_exec \
    gdb_target_cmd download_dialog gdb_pretty_name gdb_exe_name _gdbtk_stop \
    gdb_target_name gdb_target_changed gdbtk_state gdb_kod_cmd gdb_shutting_down

  # initialize state variables
  set gdb_exe_changed 0
  set gdb_target_changed 0
  set gdb_running 0
  set gdb_downloading 0
  set gdb_loaded 0
  set gdb_program_has_run 0
  set file_done 0
  set gdb_pretty_name {}
  set gdb_exec {}
  set gdb_target_cmd ""
  set gdb_running 0
  set gdb_shutting_down 0

  set download_dialog ""

  # gdb_pretty_name is the name of the GDB target as it should be
  # displayed to the user.
  set gdb_pretty_name ""

  # gdb_exe_name is the name of the executable we are debugging.  
  set gdb_exe_name ""

  # Initialize readline
  if {![info exists gdbtk_state(readline)]} {
    # Only do this once...
    set gdbtk_state(readline) 0
    set gdbtk_state(console) ""
    set gdbtk_state(readlineShowUser) 1
  }

  # flush cache for gdbtk_locate_main
  gdbtk_locate_main 1

  # check for existence of a kod command and get it's name and
  # text for menu entry
  set gdb_kod_cmd ""
  set msg ""
  if {![catch {gdb_cmd "show os"} msg] && ($msg != "")} {
    set line1 [string range $msg 0 [expr [string first \n $msg] -1]]
    if {[regexp -- \"(.*)\" $line1 dummy cmd]} {
      set gdb_kod_cmd $cmd
    }
  }
#  debug "kod_cmd=$gdb_kod_cmd"

  # setup stop button
  set _gdbtk_stop(timer) ""
  set _gdbtk_stop(msg) ""

  # gdb_target_name is the name of the GDB target; that is, the argument
  # to the GDB target command.
  set gdb_target_name ""

  # By setting gdb_target_changed, we force a target dialog
  # to be displayed on the first "run"
  set gdb_target_changed 1
}

# The architecture changed. Inform the UI.
proc gdbtk_tcl_architecture_changed {} {
  set e [ArchChangedEvent \#auto]
  # First perform global actions as a result of the architecture change.
  gdb_reg_arch_changed $e 
  # Now dispatch to all the other event handlers.
  GDBEventHandler::dispatch $e
  delete object $e
}

proc gdbtk_console_read {} {
  if {$::gdbtk_state(console) == ""} {
    ManagedWin::open Console -force
  } else {
    raise [namespace tail $::gdbtk_state(console)]
  }
  set result [$::gdbtk_state(console) gets]
  debug "result=$result"
  return $result
}

# This is based on TIP 171 to enable better default behavior
# with the MouseWheel event. I don't know why this is not in 
# Tk yet (at least 8.5), but this allows all of our windows to
# scroll without having to do anything.
proc ::tk::MouseWheel {wFired X Y D {shifted 0}} {
    # Set event to check based on call
    set evt "<[expr {$shifted?{Shift-}:{}}]MouseWheel>"
    # do not double-fire in case the class already has a binding
    if {[bind [winfo class $wFired] $evt] ne ""} { return }
    # obtain the window the mouse is over
    set w [winfo containing $X $Y]
    # if we are outside the app, try and scroll the focus widget
    if {![winfo exists $w]} { catch {set w [focus]} }
    if {[winfo exists $w]} {
	if {[bind $w $evt] ne ""} {
	    # Awkward ... this widget has a MouseWheel binding, but to
	    # trigger successfully in it, we must give it focus.
	    catch {focus} old
	    if {$w ne $old} { focus $w }
	    event generate $w $evt -rootx $X -rooty $Y -delta $D
	    if {$w ne $old} { focus $old }
	    return
	}
	# aqua and x11/win32 have different delta handling
	if {[tk windowingsystem] ne "aqua"} {
	    set delta [expr {- ($D / 30)}]
	} else {
	    set delta [expr {- ($D)}]
	}
	# scrollbars have different call conventions
	if {[string match "*Scrollbar" [winfo class $w]]} {
	    catch {tk::ScrollByUnits $w \
		       [string index [$w cget -orient] 0] $delta}
	} else {
	    # Walking up to find the proper widget handles cases like
	    # embedded widgets in a canvas

	    # 20091008-keiths: This cannot possibly work the way it
	    # was written in the TIP, so I've rewritten it to work the
	    # way the comments say it should.
	    set cmd [list "%W" [expr {$shifted ? "xview" : "yview"}] \
			 scroll $delta units]
	    while {[catch [regsub "%W" $cmd $w]] && [winfo toplevel $w] ne $w} {
		set w [winfo parent $w]
	    }
	}
    }
}

bind all <MouseWheel> [list ::tk::MouseWheel %W %X %Y %D 0]
bind all <Shift-MouseWheel> [list ::tk::MouseWheel %W %X %Y %D 1]
if {[tk windowingsystem] eq "x11"} {
    # Support for mousewheels on Linux/Unix commonly comes through
    # mapping the wheel to the extended buttons.
    bind all <4> [list ::tk::MouseWheel %W %X %Y 120]
    bind all <5> [list ::tk::MouseWheel %W %X %Y -120]
}

set mw_classes [list Text Listbox Table TreeCtrl]
foreach class $mw_classes { bind $class <MouseWheel> {} }
if {[tk windowingsystem] eq "x11"} {
    foreach class $mw_classes {
	 bind $class <4> {}
	 bind $class <5> {}
    }
}

@


1.60
log
@	* library/interface.tcl (gdbtk_tcl_warning): Add warnings for some
	too frequently occurring DWARF complaints.

	(::tk::MouseWheel): New function based on TIP 171.
@
text
@d1818 3
@


1.59
log
@        From Dave Murphy  <davem@@devkitpro.org>:
        * gdbtk-cmds.c: Guard <sys/ioctl.h> with HAVE_SYS_IOCTL_H.
        * gdbtk-hooks.c: Ditto.
        * gdbtk.c: Ditto.
        * gdbtk-interp.c: Include windows.h under mingw32.
        (gdbtk_start_timer, gdbtk_stop_timer): Remove timer calls under mingw.
        (gdbtk_init): Include windows-specific commands under mingw without
        cygwin path commands.
        * library/download.itb (Download::download_it): Only use ide_cygwin_path
        on cygwin hosts.
        * library/interface.tcl (_open_file): Ditto.
        * library/prefs.tcl (pref_read): Ditto.
        * library/targetselection.itb (TargetSelection::default_port): Default
        to "/dev/com1" under cygwin and "COM1" under mingw.
        (TargetSelection::port_list): Use "/dev/com" under cygwin and
        "COM" under mingw.
@
text
@d371 2
d1832 68
@


1.59.6.1
log
@gdb/insight for ARCompact (from Richard Stuckey)
@
text
@a1077 4
      set filename [pref getd gdb/load/$target-filename]
      if {$filename == ""} {
	set filename [pref getd gdb/load/default-filename]
      }
a1083 2
      # replace "fileX" with filename
      set targ [lrep $targ "fileX" ${filename}]
d1136 3
a1138 18
# ARC 24/11/08
# change 1 to 0 in lindex
# check for target being simulator
      set target [lindex $gdb_target_cmd 0]
      if {$target == "arcjtag" } {
           set message "$msg\n\n$debugger_name cannot connect to the target board\
using $target.\nVerify that the board is securely connected and that\nyou have\
the GPIO driver installed upon your machine."
      } elseif {$target == "arcxiss" } {
           set message "$msg\n\n$debugger_name cannot connect to the ARC Fast\
Instruction Set Simulator (xISS) using $target.\nVerify that the xISS is\
installed upon your machine."
      } elseif {$target == "sim" } {
        set message "$msg\n\n$debugger_name cannot connect to the simulator.\
\nSelect an executable file to be debugged first."
      } else {
           set message "$msg\n\n$debugger_name cannot connect to the target board\
using $target.\nVerify that the board is securely connected and, if\
a1139 2
      }
      tk_messageBox -icon error -title $dialog_title -type ok -message $message
d1142 1
a1142 1

@


1.58
log
@        * library/main.tcl: Add gdbtk_platform definitions.
        * library/attachdlg.itb (list_pids): Use gdbtk_platform
        instead of tcl_platform.
        * library/bpwin.itb (build_win): Likewise.
        (_bp_add): Likewise.
        (_bp_modify): Likewise.
        * library/download.itb (download_it): Likewise.
        * library/globalpref.itb (_build_win): Likewise.
        * library/helpviewer.tcl (open_help): Likewise.
        * library/interface.tcl (gdbtk_tcl_query): Likewise.
        (show_warning): Likewise.
        (open_file): Likewise.
        (run_executable): Likewise.
        * library/managedwin.itb (reveal): Likewise.
        (_create): Likewise.
        * library/prefs.tcl (pref_read): Likewise.
        (pref_set_defaults): Likewise.
        (pref_set_colors): Likewise.
        * library/session.tcl (_exe_name): Likewise.
        * library/srcbar.itcl (_update_file_menu): Likewise.
        (create_run_menu): Likewise.
        * library/srctextwin.itb (_mtime_changed): Likewise.
        (LoadFromCache): Likewise.
        * library/targetselection.itb (default_port): Likewise.
        (build_win): Likewise.

        * library/memwin.itb (build_win): Remove unused tcl_platform
        declaration.
        * library/pluginwin.itcl (enable_ui): Likewise.
        * library/process.itb (build_win): Likewise.
        * library/srcbar.itcl (enable_ui): Likewise.
        * library/srcwin.itb (location): Likewise.
        * library/stackwin.itb (build_win): Likewise.
        * library/tdump.tcl (build_win): Likewise.
@
text
@d965 1
a965 1
  if {$gdbtk_platform(platform) == "windows"} {
@


1.57
log
@	* library/attachdlg.itb:
	* library/actiondlg.tcl:
	* library/about.tcl:
	* library/ehandler.itb:
	* library/editor.tcl:
	* library/download.ith:
	* library/download.itb:
	* library/debugwin.ith:
	* library/debugwin.itb:
	* library/cspref.ith:
	* library/cspref.itb:
	* library/console.ith:
	* library/console.itb:
	* library/browserwin.ith:
	* library/browserwin.itb:
	* library/bpwin.ith:
	* library/bpwin.itb:
	* library/blockframe.ith:
	* library/managedwin.ith:
	* library/managedwin.itb:
	* library/main.tcl:
	* library/locals.tcl:
	* library/ipcpref.ith:
	* library/ipcpref.itb:
	* library/ipc.tcl:
	* library/interface.tcl:
	* library/helpviewer.tcl:
	* library/globalpref.ith:
	* library/globalpref.itb:
	* library/gdbwin.ith:
	* library/gdbtoolbar.itcl:
	* library/gdbmenubar.itcl:
	* library/gdbevent.ith:
	* library/gdbevent.itb:
	* library/embeddedwin.ith:
	* library/ehandler.ith:
	* library/srcwin.itb:
	* library/srctextwin.ith:
	* library/srctextwin.itb:
	* library/srcpref.ith:
	* library/srcpref.itb:
	* library/srcbar.itcl:
	* library/session.tcl:
	* library/regwin.ith:
	* library/regwin.itb:
	* library/process.ith:
	* library/process.itb:
	* library/prefs.tcl:
	* library/pluginwin.itcl:
	* library/modal.tcl:
	* library/memwin.ith:
	* library/memwin.itb:
	* library/mempref.ith:
	* library/mempref.itb:
	* library/watch.tcl:
	* library/watch.tcl:
	* library/warning.tcl:
	* library/vartree.ith:
	* library/vartree.itb:
	* library/util.tcl:
	* library/tracedlg.tcl:
	* library/toplevelwin.ith:
	* library/tfind_args.tcl:
	* library/tdump.tcl:
	* library/targetselection.ith:
	* library/targetselection.itb:
	* library/stackwin.ith:
	* library/stackwin.itb:
	* library/srcwin.ith:
@
text
@d2 1
a2 1
# Copyright (C) 1997, 1998, 1999, 2001, 2002, 2004 Red Hat, Inc.
d304 1
a304 1
  global gdb_checking_for_exit gdbtk_state tcl_platform
d320 1
a320 1
  if {$tcl_platform(platform) == "windows"} {
d379 1
a379 1
  global tcl_platform
d398 1
a398 1
  if {$tcl_platform(platform) == "windows"} {
d919 1
a919 1
  global gdb_running gdb_downloading tcl_platform
d965 1
a965 1
  if {$tcl_platform(platform) == "windows"} {
d1163 1
a1163 1
  global gdb_running gdb_exe_name tcl_platform
d1259 1
a1259 1
    if {$tcl_platform(platform) != "windows"
@


1.56
log
@        From Charles Brockman <mr hyphen chuck at att dot net>:
        * library/interface.tcl (gdbtk_tcl_warning): Filter "RTTI symbol not found"
        "warnings", too.
@
text
@d2 1
a2 1
# Copyright 1997, 1998, 1999, 2001, 2002, 2004 Red Hat, Inc.
@


1.55
log
@Grrr. Remove debugging lines from previous patch.
@
text
@d370 1
@


1.54
log
@        * library/interface.tcl (gdbtk_tcl_fputs_error): gdbtk_state is in the global
        namespace. Fix references.
        (gdbtk_tcl_fputs_log): Likewise.

        From Steven Johnson  <johnson@@sakuraindustries.com>:
        * library/interface.tcl (gdbtk_tcl_warning): Filter some basic warnings
        from gdb - "incomplete CFI.." and "Internal error".
@
text
@d369 1
a369 4
        "incomplete CFI.*" {
	    puts "here i am"
	    gdbtk_tcl_fputs_error $message
	}
a440 1
      puts "I am here, too"
@


1.53
log
@2004-08-27  Martin Hunt  <hunt@@redhat.com>

	* library/ipc.tcl: New file.
	* library/ipcpref.ith: New file.
	* library/ipcpref.itb: New file.

	* library/srcwin.itb (SrcWin::inferior): Call ipc
	send if enabled.

	* library/prefs.tcl (pref_set_defaults): Enable color
	schemes by default. Add IPC defaults.

	* library/srcbar.itcl (create_pref_menu): Create
	"Advanced" cascade menu and put "Edit Color Schemes"
	and "IPC Support" under it.

	* library/managedwin.itb (ManagedWin::destructor):
	If IPC enabled then send "quit" on exit.

	* library/main.tcl: Start IPC if enabled.

	* library/prefs.tcl (pref_set_defaults): Add IPC defaults.

	* library/gdbmenubar.itcl (menubar_get_current_menu):
	New method.
@
text
@d368 5
d443 2
a444 1
  if {[info exists gdbtk_state(console)] && $::gdbtk_state(console) != ""} {
d454 1
a454 1
  if {[info exists gdbtk_state(console)] && $::gdbtk_state(console) != ""} {
@


1.52
log
@2004-07-02  Martin Hunt  <hunt@@redhat.com>

	* library/targetselection.itb: Use /dev/comX for
	cygwin instead of just comX.

	* library/interface.tcl (gdbtk_tcl_preloop): Set baud rate.
@
text
@d1300 1
a1300 1

@


1.51
log
@2004-06-25  Andrew Cagney  <cagney@@gnu.org>

	* generic/gdbtk.h: "ui_loop_hook" was deprecated, update.
	* generic/gdbtk-hooks.c (gdbtk_add_hooks, x_event): Ditto.
	* generic/gdbtk-cmds.c: Ditto.
@
text
@d122 1
@


1.50
log
@2004-06-24  Andrew Cagney  <cagney@@gnu.org>

	* generic/gdbtk-hooks.c (gdbtk_add_hooks): Update references to
	pre_add_symbol_hook and post_add_symbol_hook, both deprecated.
	* library/interface.tcl (gdbtk_memory_changed): Update comments.
@
text
@d1495 10
a1504 9
# The best solution for this is to capture gdb deep down where it
# can block. For _any_ target board, this will be in either
# serial or socket code. These places call ui_loop_hook to 
# keep us alive. For native unix, we use an interval timer.
# Simulators either call ui_loop_hook directly (older sims, at least)
# or they call gdb's os_poll_quit callback, where we insert a call
# to ui_loop_hook. Some targets (like v850ice and windows native)
# require a call to ui_loop_hook directly in target_wait. See comments
# before gdb_stop and x_event to find out more about how this is accomplished.
@


1.49
log
@2004-04-05  Martin Hunt  <hunt@@redhat.com>

	* library/session.tcl: Make hostname and portname
	session-dependent. Add gdb_bg_num (the color
	scheme number) as a per-session variable.

	* library/prefs.tcl (pref_read): If color schemes are in use,
	set colors based on the current scheme.
	(pref_save): Add "bg" section.
	(pref_set_defaults): Define new variable gdb/use_color_schemes
	and define 16 default background colors.

	* library/managedwin.itb (ManagedWin::window_name): Append
	window "instance" string to window name.
	(ManagedWin::window_instance): Set window instance string.

	* library/debugwin.itb: Add a reconfig method to restore
	unique black textbackground, overriding color scheme.

	* library/csprefs.itb:
	* library/csprefs.ith: New files. Implement color scheme
	preferences.

	* library/util.tcl (set_bg_colors): New function.
	(r_setcolors): New function.

	* library/regwin.itb (_prefs_changed): Deleted.
	(reconfig): New function.  Updates tkTable color tags
	if color scheme changes.
	* library/regwin.ith: Update to reflect above changes.

	* library/srcbar.itcl (create_pref_menu): Add pulldown
	menus for "Edit Color Schemes..." and "Use Color Schemes".
	(reconfig): Fix up menu items for color schemes.

	* library/globalpref.itb (_init_var): Add
	gdb/use_color_schemes to variable list.
	(_build_win): Add a checkbutton to enable/disable
	color schemes.

	* library/gdbmenubar.itcl (menubar_add_cascade): Add a class
	argument so cascade menus can be managed by class too.

	* library/interface.tcl (gdbtk_tcl_fputs): Check for
	existence of gdbtk_state(console).  Stops annoying error
	messages.
	(gdbtk_tcl_fputs_error): Ditto.
	(gdbtk_tcl_fputs_log): Ditto.
@
text
@d704 1
a704 1
#         - pre_add_symbol_hook                                    #
d707 1
a707 1
#         - post_add_symbol_hook                                   #
@


1.48
log
@2003-02-10  Martin M. Hunt  <hunt@@redhat.com>

	* library/interface.tcl (gdbtk_attach_native): Don't force the user
	to choose an exec file when attaching.

	* library/attachdlg.itb: Some fixes to work with latest iwidgets.
@
text
@d2 1
a2 1
# Copyright 1997, 1998, 1999, 2001, 2002 Red Hat, Inc.
d421 1
a421 1
  if {$gdbtk_state(console) != ""} {
d437 1
a437 1
  if {$::gdbtk_state(console) != ""} {
d447 1
a447 1
  if {$::gdbtk_state(console) != ""} {
d1515 1
a1515 1
    set _gdbtk_stop(timer) [after 3000 gdbtk_detach]
@


1.47
log
@2003-02-03  Martin M. Hunt  <hunt@@redhat.com>

	* library/interface.tcl (gdbtk_locate_main): Rewrite for efficiency.
	No longer uses gdb_search.  Caches result.
	(initialize_gdbtk): Initialize gdb_locate_main cache.
	* library/main.tcl: Call initialize_gdbtk after loading prefs.
@
text
@d1594 1
a1594 1
	if {![_open_file $symbol_file]} {
@


1.46
log
@2002-12-17  Martin M. Hunt  <hunt@@redhat.com>

	* library/interface.tcl (gdbtk_tcl_fputs_target_err):
 	New function.
	(gdbtk_tcl_fputs_target): Open console window if it is
	not already open.
	(gdbtk_gets): New function.
	Opens a console window if necessary and calls Console::gets.

	* library/console.ith (gets): Declare method.
	(_input_mode): New private variable.
	(_input_result): Ditto.
	(_input_error): Ditto.
	(_cancel): New private method
	(invoke): Add arg.

	* library/console.itb (_setprompt): Allow setting prompt
	to nothing.  Delete to beginning of line before writing prompt.
	(gets): New public method to prompt user for input.
	(_cancel): New private method to handle ^C when inputting data.
	(invoke): Check for ^d when in input mode.
@
text
@d826 10
a835 2
proc gdbtk_locate_main {} {
  set result {}
a836 2
  debug "Searching $main_names"

d838 2
a839 3
    if {![catch {gdb_search functions $main -static 1}] \
        && ![catch {gdb_loc $main} linespec]} {
      set result $linespec
d843 1
a843 1
  if {$result == {} 
d846 1
a846 1
    set result $linespec
d850 2
a851 2
  lassign $result file func ffile line addr rest
  if {$addr == 0x0 && $func == {}} { set result {} }
d853 2
a854 1
  return $result
d1779 3
@


1.45
log
@2002-10-10  Martin M. Hunt  <hunt@@redhat.com>

	* library/session.tcl (save): Save target_cmd,
	attach, load, run, and cont as session prefs.
	(notice_file_change): Load in above session
	prefs.

	* library/interface.tcl (set_target): Set icons busy
	before attempting target command and set back to idle after.
	(run_executable): Return on ATTACH_ERROR.
	(gdbtk_run): If run button is hit when a program
	is currently being debugged, put up a dialog allowing
	user to continue or cancel.
@
text
@d457 2
a458 3
  if {$::gdbtk_state(console) != ""} {
    $::gdbtk_state(console) insert $message target_tag
    update
d460 13
d1804 11
@


1.44
log
@        * library/browserwin.itb (_full_funcs_combo): Remove "-modal"
        option from tk_messageBox call. It was redhat-local in tk8.0,
        but is no longer in tk8.3.
        * library/download.itb (download_it): Likewise.
        * library/interface.tcl (gdbtk_tcl_query): Likewise.
        (show_warning): Likewise.
        (set_exe): Likewise.
        (set_target): Likewise.
        * library/memwin.itb (error_dialog): Likewise.
        * library/srcwin.itb (fillFuncCB): Likewise.
        * library/util.tcl (tfind_cmd): Likewise.
@
text
@d1078 2
a1079 2
#  debug "gdb_target_changed=$gdb_target_changed gdb_target_cmd=\"$gdb_target_cmd\""
#  debug "gdb_target_name=$gdb_target_name"
d1102 1
d1105 1
d1166 2
a1167 1
      if {[gdbtk_attach_remote] == "ATTACH_CANCELED"} {
d1554 8
@


1.43
log
@2002-04-26  Martin M. Hunt  <hunt@@redhat.com>

	* library/interface.tcl (gdbtk_force_quit): New function.
	Closes source windows then calls gdb_force_quit.
	(gdbtk_quit): Call gdbtk_force_quit.
@
text
@d349 1
a349 1
	     -type yesno -modal $modal -parent .]
d401 1
a401 1
             -type ok -modal $modal -parent .]
d880 1
a880 1
	-title "GDB" -type ok -modal system \
d1113 1
a1113 1
	-modal task -message "$msg\n\n$debugger_name cannot connect to the target board\
@


1.42
log
@2002-03-06  Martin M. Hunt  <hunt@@redhat.com>

	* library/srctextwin.itb (SrcTextWin::showBPBalloon):
	Reformat output. Add conditions, ignore count, commands.

	* library/interface.tcl (gdbtk_tcl_readline): Remove
	call to "command::insert" and instead insert the command
	into the console window.
	(gdbtk_tcl_readline_end): Catch the unsets and do not call
	non-existent function command::end_multi_line_input.
@
text
@d258 1
a258 1
    gdb_force_quit
d260 15
@


1.41
log
@	* library/tclIndex: Updated.
	* library/srcbar.itcl (SrcBar): Use new Session namespace.
	* library/main.tcl: Use new Session namespace.
	* library/interface.tcl (gdbtk_tcl_preloop): Use new Session
	namespace.
	(gdbtk_cleanup): Likewise.
	(_close_file): Likewise.
	* library/session.tcl: Use a namespace.  Renamed all functions.
@
text
@d515 1
a515 1
#  debug "$command $args"
d527 1
a527 1
#  debug "$command $args"
d538 1
a538 1
#  debug "readline begin"
d550 1
a550 1
#  debug "$prompt"
d554 2
a555 2
    if {$gdbtk_state(readlineShowUser)} {
      command::insert_command $cmd
d576 1
a576 1
#  debug "readline_end"
d578 1
a578 2
  unset gdbtk_state(readlineActive)
  command::end_multi_line_input
@


1.40
log
@2002-01-11  Martin M. Hunt  <hunt@@redhat.com>

	* library/interface.tcl (gdbtk_tcl_exec_file_display):
	Set pathname in host-independent manner using "file" and
	gdb_current_directory.
@
text
@d121 1
a121 1
    session_notice_file_change
d271 1
a271 1
    session_save
d973 1
a973 1
    session_save
@


1.39
log
@	* library/interface.tcl (gdbtk_tcl_preloop): Use current directory
	when `--args' given.
@
text
@d772 3
a774 4
  set filename [string trim $filename \']
  if {[string index $filename 0] != "/"} {
    set pwd [pwd]
    set filename "$pwd/$filename"
@


1.38
log
@Update copyright.
@
text
@d103 1
a103 1
  global gdb_exe_name
d118 1
a118 1
    # arguments to override the session's arguments.
d120 1
d124 1
@


1.37
log
@	* library/interface.tcl (set_exe): Allow users to debug
	executables with no debug information.
@
text
@d2 1
a2 1
# Copyright 1997, 1998, 1999, 2001 Red Hat, Inc.
@


1.36
log
@	* library/console.ith (insert): Add tag parameter.
	(einsert): Delete.
	* library/console.itb: (insert): Add tag parameter.
	(einsert): Delete.
	* library/interface.tcl (gdbtk_tcl_fputs): Use Console::insert.
	(gdbtk_tcl_fputs_error): Likewise.
	(gdbtk_tcl_fputs_log): Likewise.
	(gdbtk_tcl_fputs_target): Likewise.
	(set_target): Likewise.
@
text
@a866 3
      set gdb_exe_name {}
      set file_done 0
      return
@


1.35
log
@	* library/interface.tcl (set_target_name): Call "pref getd"
	instead of "pref get" to avoid undefined preference error
	message for default-hostname.
@
text
@d421 1
a421 1
    $::gdbtk_state(console) einsert $message err_tag
d431 1
a431 1
    $::gdbtk_state(console) einsert $message log_tag
d441 1
a441 1
    $::gdbtk_state(console) einsert $message target_tag
d1109 1
a1109 1
	catch {[ManagedWin::find Console] einsert $err err_tag}
d1432 1
a1432 1
  # ------------------------------------------------------------------
@


1.34
log
@2001-11-30  Martin M. Hunt  <hunt@@redhat.com>

	* library/interface.tcl (gdbtk_eval): Remove
	undocumented debug function.
@
text
@d1042 1
a1042 1
	set hostname [pref get gdb/load/default-hostname]
@


1.33
log
@	* library/interface.tcl (gdbtk_tcl_preloop): Override session's
	command-line arguments if required.
@
text
@a1769 18

proc gdbtk_eval {exp} {
  debug $exp
  set ret [catch {gdb_cmd "p/x $exp"} val]
  if {$ret} {
    return "" 
  }

  debug "val=\"$val\""
  # response looks like "$1 = value\n"
  set ind [string first "=" $val]
  if { $ind == -1 } { return "" }
  set val [string range $val [expr $ind + 1] [string length $val]]
  set val [string trimleft $val]
  set val [string trimright $val "\n"]
  debug "returning \"$val\""
  return $val
}@


1.32
log
@2001-11-08  Martin M. Hunt  <hunt@@redhat.com>
	* generic/gdbtk-cmds.c (gdb_eval): Add an optional
	format argument.
	(hex2bin): Swap bytes around if target is little endian.
	Fix loop count.
	(gdb_incr_addr): New function to do address arithmetic.
	Needed because some addresses are 64-bits and tcl can't
	deal with them, except as strings.

	* library/memwin.itb (MemWin::build_win): Add a label
	to indicate the target endianess.
	(MemWin::edit): Use gdb_incr_addr.
	(MemWin::busy): The constructor calls gdbtk_busy which
	calls this before the window has finished drawing, so
	don't disable items that don't exist yet.
	(MemWin::update_address): Set a flag, bad_expr, if the
	expression does not evaluate. Call gdb_eval with 'x' flag
	to force the result to be hex.
	(MemWin::BadExpr): Set bad_expr.
	(MemWin::incr_addr): Use gdb_incr_addr.
	(MemWin::update_addr): Return is bad_expr is set. Use
	gdb_incr_addr.
	(MemWin::goto): Call update_address.
	* library/memwin.itb: Declare private variable bad_expr.

	* library/util.tcl (gdbtk_endian): New procedure. Returns
	BIG or LITTLE to indicate target endianess.
@
text
@d116 4
a119 1
    # must notice the initial session by hand.
d121 3
@


1.31
log
@	* tclIndex: Updated.
	* library/main.tcl: Add session_notice_file_change to
	file_changed_hook.
	* library/session.tcl (session_load): Only load the executable.
	(session_notice_file_change): New proc.
	(SESSION_exe_name): New proc.
	(session_save): Use it.
	(session_notice_file_change): Likewise.
	* library/interface.tcl (gdbtk_tcl_exec_file_display): Don't call
	session_save.
	(gdbtk_tcl_preloop): Don't set executable name or try to find
	main.  Notice a new session if required.
@
text
@d1764 18
@


1.30
log
@	* library/session.tcl (SESSION_recreate_bps): Use
	gdb_run_readline_command_no_output to recreate breakpoints.
	* library/interface.tcl (gdb_run_readline_command): Set
	readlineShowUser element of gdbtk_state.
	(gdb_run_readline_command_no_output): New proc.
	(initialize_gdbtk): Initialize readlineShowUser element.
	(gdbtk_tcl_readline_begin): Use readlineShowUser element.
	(gdbtk_tcl_readline): Likewise.
@
text
@d114 4
a117 6
  SrcWin::point_to_main
  set msg ""
  catch {gdb_cmd "info files"} msg
  set line1 [string range $msg 0 [string first \n $msg]]  
  if {[regexp {Symbols from "(.*)"\.} $line1 dummy name]} {
    set gdb_exe_name $name
a118 1

a770 3

  # Add this new session to the session list
  session_save
@


1.29
log
@	* generic/gdbtk-hooks.c (gdbtk_add_hooks): Register
	architecture_changed event handler.
	(gdbtk_architecture_changed): New function.
	* library/gdbevent.ith (class ArchChangdEvent): New event.
	* library/ehandler.ith (arch_changed): New method. Handler
	for ArchChangedEvents.
	* library/interface.tcl (gdbtk_tcl_architecture_changed): New
	proc to handle architecture change events.
@
text
@d512 13
d535 1
a535 1
  if {$gdbtk_state(console) != ""} {
d549 3
a551 1
    command::insert_command $cmd
d1736 1
@


1.28
log
@	* library/srcbar.itcl (_post): New method.
	(_update_file_menu): New method.
	(create_file_menu): Move the guts to _update_file_menu.
	Add a post command to the menu.
	* library/interface.tcl (gdbtk_tcl_file_changed): Catch the
	call to run_hooks.
	(gdbtk_tcl_exec_file_display): Save the new session, too.
	(set_exe_name): Don't bother saving the session here.
	(_close_file): Save the session here, too.
	(gdbtk_clear_file): Catch the call to run_hooks, too.
	* library/gdbmenubar.itcl (menubar_new_menu): Allow caller
	to specify optional arguments to be passed to Tk when
	creating the menu.
	Tk's "menu add" command returns an empty string. Save the
	menu's index in the parent instead. This is what all
	the menu subcommands want.
@
text
@d1748 6
@


1.27
log
@2001-07-21  Martin M. Hunt  <hunt@@redhat.com>

	* library/interface.tcl (gdbtk_locate_main): Fix function
	so that it returns either a null string or a valid location,
	as documented.
@
text
@d715 1
a715 1
    run_hooks gdb_clear_file_hook
d760 3
a821 4
  if {$gdb_exe_name != ""} then {
    session_save
  }

d936 1
a936 1
  
d960 1
d1672 1
a1672 1
  run_hooks gdb_clear_file_hook
@


1.26
log
@	* library/interface.tcl (gdb_update_hook): Mark as deprecated.
	(gdbtk_update): Dispatch and UpdateEvent, too.
	* library/ehandler.ith (update): New event handler.
	* library/gdbevent.ith (UpdateEvent): New event.
	* library/gdbevent.itb (UpdateEvent::constructor): New method.
	(UpdateEvent::get): New method.
	* library/kod.ith (udpate): Match event handler definition.
	* library/kod.itb (update): Ditto.
	(build_win): Pass dummy argument to update method.
	(top): Ditto.
	(up): Ditto.
	(set_variable): Ditto.
	* library/memwin.ith (update): Match event handler definition.
	* library/memwin.itb (update): Ditto.
	(constructor): Remove gdb_update_hook.
	(destructor): Ditto.
	* library/process.ith (update): Match event handler definition.
	* library/process.itb (update): Ditto.
	(constructor): Remove gdb_update_hook.
	(destructor): Ditto.
	(build_win): Pass dummy argument to update method.
	* library/regwin.ith (update): Match event handler definition.
	* library/regwin.itb (update): Ditto.
	(constructor): Remove gdb_update_hook.
	(destructor): Ditto.
	(build_win): Pass dummy argument to update method.
	(but3): Ditto.
	(unedit): Ditto.
	* library/stackwin.ith (update): Match event handler definition.
	* library/stackwin.itb (update): Ditto.
	(constructor): Remove gdb_update_hook.
	(destructor): Ditto.
	(build_win): Pass dummy argument to update method.
	* library/tdump.tcl (update): Match event handler definition.
	(constructor): Remove gdb_update_hook.
	(destructor): Ditto.
	(build_win): Pass dummy argument to update method.
	* library/variables.tcl (update): Match event handler definition.
	(build_win): Pass dummy argument to update method.
	* library/locals.tcl (update): Match event handler definition.
	(constructor): Pass dummy argument to update method.
	* library/watch.tcl (update): Match event handler definition.
	Pass dummy argument to VariableWin::update.
	(add): Pass dummy argument to update method.
	* library/srcwin.ith (update): New method.
	(update_hook_init): Remove.
	* library/srcwin.itb (update): New method.
	(constructor): Remove gdb_update_hook.
	(destructor): Ditto.
	* tclIndex: Regenerate.
@
text
@d777 1
a778 1
#  we are browsing, or walking the stack.
d782 1
d785 1
d789 2
a790 1
      return $linespec
d793 2
a794 1
  if {![catch gdb_entry_point entry_point]
d796 1
a796 1
    return $linespec
d798 6
a803 1
  return {}
@


1.25
log
@	* library/interface.tcl (gdbtk_idle): Run hooks, too,
	until they're all gone.
@
text
@d70 1
d74 1
a74 1
define_hook gdb_update_hook
d152 4
a155 4
  set err [catch {run_hooks gdb_update_hook} txt]
  if {$err} { 
    dbug E "$txt" 
  }
@


1.24
log
@	* library/interface.tcl (gdb_idle_hook): Mark as deprecated.
	(gdbtk_idle): Dispatch an IdleEvent. gdb_idle_hook is gone.
	* library/ehandler.ith (idle): New event handler.
	* library/gdbevent.ith (IdleEvent): New event.
	* library/console.ith (idle): Match event handler definition.
	* library/console.itb (idle): Ditto.
	(constructor): Remove gdb_idle_hook.
	(destructor): Ditto.
	* library/kod.ith (idle): Match event handler definition.
	* library/kod.itb (idle): Ditto.
	(constructor): Remove gdb_idle_hook.
	(destructor): Ditto.
	* library/memwin.ith (idle): Match event handler definition.
	* library/memwin.itb (idle): Ditto.
	(constructor): Remove gdb_idle_hook.
	(destructor): Ditto.
	* library/pluginwin.itcl (stopped): Rename to "idle" and
	match event handler definition.
	Fix misleading comments.
	* library/process.ith (idle): Match event handler definition.
	* library/process.itb (idle): Ditto.
	(constructor): Remove gdb_idle_hook.
	(destructor): Ditto.
	* library/regwin.ith (idle): Match event handler definition.
	* library/regwin.itb (idle): Ditto.
	(constructor): Remove gdb_idle_hook.
	(destructor): Ditto.
	* library/srcbar.itcl (idle): New method.
	(constructor): Remove gdb_idle_hook.
	(destructor): Ditto.
	* library/srcwin.ith (idle): Match event handler definition.
	* library/srcwin.itb (idle): Ditto.
	(constructor): Remove gdb_idle_hook.
	(destructor): Ditto.
	* library/stackwin.ith (idle): Match event handler definition.
	* library/stackwin.itb (idle): Ditto.
	(constructor): Remove gdb_idle_hook.
	(destructor): Ditto.
	* library/variables.tcl (idle): Match event handler definition.
	(constructor): Remove gdb_idle_hook.
	(destructor): Ditto.
	* library/plugins/rhabout/rhabout.itcl (stopped): Rename
	to "idle" and match new event handler definition.
	* library/tclIndex: Regenerated.
@
text
@d197 5
d205 1
a205 1
  
d211 2
a212 1
  }    
@


1.23
log
@	* library/interface.tcl (gdb_busy_hook): Deprecate.
	(gdbtk_busy): Create and dispatch a BusyEvent instead
	of running hooks.
	* library/ehandler.ith (busy): New event handler.
	* library/gdbevent.ith (BusyEvent): New event class.
	* library/console.ith: Inherit from GDBEventHandler.
	(busy): Match event handler definition.
	* library/console.itb (busy): Ditto.
	(constructor): Remove gdb_busy_event.
	(destructor): Ditto.
	* library/kod.ith (busy): Match event handler definition.
	* library/kod.itb (busy): Ditto.
	(constructor): Remove gdb_busy_hook.
	(destructor): Ditto.
	* library/memwin.ith (busy): Match event handler definition.
	* library/memwin.itb (busy): Ditto.
	(constructor): Remove gdb_busy_hook.
	(destructor): Ditto.
	* library/pluginwin.itcl (running): Rename to "busy" and
	match event handler definition.
	(consturctor): Remove gdb_busy_hook.
	(destructor): Ditto.
	* library/process.ith (busy): Match event handler definition.
	* library/process.itb (busy): Ditto.
	(constructor): Remove gdb_busy_hook.
	(destructor): Ditto.
	* library/regwin.ith (busy): Match event handler definition.
	* library/regwin.itb (busy): Ditto.
	(constructor): Remove gdb_busy_hook.
	(destructor): Ditto.
	* library/srcbar.itcl (constructor): Remove gdb_busy_hook.
	(destructor): Ditto.
	(busy): New method.
	* library/srcwin.ith (busy): Match event handler definition.
	* library/srcwin.itb (busy): Ditto.
	Only do the "busy" stuff if do_updates is set.
	(toggle_updates): Remove gdb_busy_hook.
	(constructor): Ditto.
	(destructor): Ditto.
	* library/stackwin.ith (busy): Match event handler definition.
	* library/stackwin.itb (busy): Ditto.
	(constructor): Remove gdb_busy_hook.
	(destructor): Ditto.
	* library/variables.tcl (constructor): Ditto.
	(destructor): Ditto.
	(disable_ui): Rename to "busy" and match event handler
	definition.
	* library/plugins/rhabout/rhabout.itcl (running): Rename
	to "busy" and match new event handler definition.
	* library/tclIndex: Regenerated.
@
text
@d60 1
d182 1
a182 1
#   PROCEDURE: gdbtk_idle - run all idle hooks
d184 2
a185 3
#          Use this procedure to run all the gdb_idle_hook's,
#          which should free the UI for more user input. This
#          hook should only be run AFTER all communication with
d195 1
d197 3
a199 5
  gdb_restore_fputs
  set err [catch {run_hooks gdb_idle_hook} txt]
  if {$err} { 
    dbug E "idle_hook error: $txt" 
  }
@


1.22
log
@	* library/interface.tcl (gdbtk_tcl_file_changed): Handle
	the case of empty-string files, sent by gdb when the
	user requests to reset the file.
	(_close_file): New proc to deal with closing an exe.
	* library/srcbar.itcl (create_file_menu): Add "Close" menu
	option.
	(create_view_menu): Change key binding for Watch Window to
	Ctrl+T to accomodate "Close" going to Ctrl+W.
	* library/srctextwin.itb (config_win): Update key binding
	for Watch Window.
	Add key binding for Close.
	(do_key): Add "close".
	(_clear_cache): Finally implement. I think this works now.
@
text
@d50 1
d58 1
a58 1
define_hook gdb_busy_hook
d126 1
a126 1
#  PROCEDURE:  gdbtk_busy - run all busy hooks
d130 1
a130 2
#         talking to the target. This will call all the registered
#         gdb_busy_hook's.
d134 3
a136 4
  set err [catch {run_hooks gdb_busy_hook} txt]
  if {$err} { 
    dbug E "$txt" 
  }
@


1.21
log
@	* library/interface.tcl (gdbtk_quit_check): Don't save sessions
	here. It doesn't work for the Console Window.
	(gdbtk_cleanup): Save session information here.
	(gdbtk_tcl_exec_file_display): When files are loaded,
	get the full pathname to the exe.
@
text
@d708 11
a718 2
  SrcWin::point_to_main
  run_hooks file_changed_hook
d925 30
@


1.20
log
@	* library/interface.tcl (gdb_quit_hook): Remove. It's unused.
	(gdbtk_quit): Do no shutdown window manager and save
	preferences here.
	(gdbtk_cleanup): This is the proper place to do those
	things.
@
text
@a236 4
  # If we have an executable file loaded, save a session associated to it
  if {$gdb_exe_name != ""} {
    session_save
  }
d257 7
d723 1
a723 1
  global gdb_loaded gdb_running gdb_exe_name gdb_target_changed
d736 9
a744 1
  set gdb_exe_name [string trim $filename \']
@


1.19
log
@Event model revamp for "gdb_set_hook".

	* library/interface.tcl (gdbtk_tcl_set_variable): New proc.
	* library/gdbevent.ith (SetVariableEvent): New event.
	* library/gdbevent.itb (SetVariableEvent::get): Override
	GDBEvent::get.
	* library/ehandler.ith (set_variable): New public method.
	* generic/gdbtk-hooks.c (gdbtk_set_hook): Let inteface function
	gdbtk_tcl_set_variable do all the work.
	* tclIndex: Regenerated.
@
text
@a214 3
# Random hook of procs to call just before exiting.
define_hook gdb_quit_hook

d247 2
a248 2
#         This procedure will ask all the right questions and run
#         all the gdb_quit_hooks before exiting. 
a251 2
    ManagedWin::shutdown
    pref_save
d261 8
a268 2
   # This is a sign that it is too late to be doing updates, etc...
   set ::gdb_shutting_down 1
@


1.18
log
@Breakpoint/tracepoint event notification using new event model...

	* generic/gdbtk-cmds.c (gdb_set_bp): Use create_breakpoint_hook
	to notify gui of changes.
	(gdb_set_bp_addr): Ditto.
	(gdb_get_breakpoint_info): Update comments to match reality.
	* generic/gdbtk-hooks.c (breakpoint_notify): Only pass the
	breakpoint number which generated the event.
	(tracepoint_notify): Ditto for tracepoints.
	* library/interface.tcl (gdb_breakpoint_change_hook): Mark
	as deprecated and comment out definition.
	(gdbtk_tcl_breakpoint): Use new GDBEvent event "breakpoint"
	to notify rest of UI about breakpoint event.
	(gdbtk_tcl_tracepoint): Ditto for "tracepoint" event.
	* library/bpwin.ith (update): Renamed to "breakpoint".
	(breakpoint): New public method.
	(tracepoint): New public method.
	(bp_add): Take event as argument instead of number.
	(bp_modify): Ditto.
	(bp_delete): Ditto.
	* library/bpwin.itb (constructor): Remove
	gdb_breakpoint_changed_hook.
	(destructor): Ditto.
	(build_win): Insert any existing breakpoints by
	making BreakpointEvents for them.
	(breakpoint): Renamed from "update" to handle
	breakpoint events.
	Remove code to deal with tracepoints.
	(tracepoint): New method to handle tracepoint
	events.
	(bp_add): Deal with breakpoint events, not breakpoint
	numbers.
	(bp_modify): Ditto.
	(bp_delete): Ditto.
	* library/srctextwin.ith: Inherit from GDBWin.
	(breakpoint): New public method.
	(tracepoint): New public method.
	* library/srctextwin.itb (constructor): Remove
	gdb_breakpoint_changed_hook.
	(destructor): Ditto.
	(breakpoint): New method to handle breakpoint event.
	(tracepoint): New method to handle tracepoint event.
	(do_bp): Handle duplicate breakpoints for asm, too.
	(remove_bp_at_line): Delete breakpoints by number, not
	linespec. clear_command removes breakpoints from the
	breakpoint_chain BEFORE deleting the breakpoint. delete_command
	does this afterward (so we can call gdb_get_breakpoint_info on
	an about-to-be-deleted breakpoint).
@
text
@d24 1
d28 12
a39 1
define_hook gdb_set_hook
d457 2
a458 1
# PROC: gdbtk_tcl_breakpoint -
d468 2
a469 1
# PROC: gdbtk_tcl_tracepoint -
@


1.17
log
@	* library/interface.tcl (run_executable): Use
	gdb_set_inferior_args.
	* library/session.tcl (session_load): Use gdb_set_inferior_args.
	* generic/gdbtk-cmds.c (Gdbtk_Init): Register
	gdb_set_inferior_args.
	(gdb_get_inferior_args): New function.
@
text
@d2 1
a2 1
# Copyright 1997, 1998, 1999 Cygnus Solutions
d19 1
d22 1
a22 1
define_hook gdb_breakpoint_change_hook
d447 5
a451 3
proc gdbtk_tcl_breakpoint {action bpnum addr line file bp_type enabled thread} {
#  debug "BREAKPOINT: $action $bpnum $addr $line $file $bp_type $enabled $thread "
  run_hooks gdb_breakpoint_change_hook $action $bpnum $addr $line $file $bp_type $enabled $thread
d457 5
a461 3
proc gdbtk_tcl_tracepoint {action tpnum addr line file pass_count} {
#  debug "TRACEPOINT: $action $tpnum $addr $line $file $pass_count"
  run_hooks gdb_breakpoint_change_hook $action $tpnum $addr $line $file tracepoint
@


1.16
log
@	* generic/gdbtk-cmds.c (gdb_entry_point): New TCL command.
	* library/interface.tcl (gdbtk_locate_main): Try the program's
	entry point if no main function is found.
@
text
@d1117 1
a1117 1
	catch {gdb_cmd "set args $gdb_args"}
@


1.15
log
@2001-04-04  Martin M. Hunt  <hunt@@redhat.com>

	* generic/gdbtk-hooks.c (gdbtk_fileopen): New function.
	Initialize ui_file stuff for gdbtk.
	(gdbtk_fputs): Don't print if gdbtk_disable_fputs. Send
	stdlog and stdtarg to their handler functions.

	* generic/gdbtk.c (Gdbtk_Init): Don't set gdb_stdlog
	and gdb_stdtarg to gdb_stdout,
	(gdbtk_init): Unset gdbtk_disable_fputs
	when ready to accept output from gdb. Remove references to
	fputs_unfiltered_hook.

	* generic/gdbtk.h: Declare new flag gdbtk_disable_fputs.

	* generic/gdbtk-cmds.c (gdb_restore_fputs): Instead of setting
	fputs_unfiltered_hook, set the new flag gdbtk_disable_fputs.

	* library/prefs.tcl (pref_set_defaults): Add defaults
	for log_fg and target_fg.

	* library/interface.tcl (gdbtk_tcl_fputs_error): Use
	err_tag.
	(gdbtk_tcl_fputs_log): New function. Write log messages
	to console.
	(gdbtk_tcl_fputs_target): New function.	Write target
	IO to console.

	* library/console.ith (einsert): Add tag parameter.

	* library/console.itb (_build_win): Add new tags for log
	and target IO.
	(einsert): Add tag parameter.
@
text
@d745 4
@


1.14
log
@2001-02-08  Fernando Nasser  <fnasser@@redhat.com>

	From 2001-02-06  Martin Hunt  <hunt@@redhat.com>
	* library/debugwin.itb: Change window name to "Insight Debug"
	* library/embeddedwin.ith: Fix debug messages.
	* library/locals.tcl: Ditto.
	* library/watch.tcl (postMenu): Ditto.
	* library/variables.tcl: Ditto.
	* library/interface.tcl: Ditto.
	* library/regwin.itb: Ditto.
	* library/gdbwin.ith: Ditto.
	* library/srcbar.itcl: Ditto.
@
text
@d392 1
a392 1
# PROC: gdbtk_tcl_fputs_error -
d395 15
a409 3
  global gdbtk_state
  # Restore the fputs hook, in case anyone forgot to put it back...
  gdb_restore_fputs
d411 6
a416 2
  if {$gdbtk_state(console) != ""} {
    $gdbtk_state(console) einsert $message
d1006 1
a1006 1
	catch {[ManagedWin::find Console] einsert $err}
@


1.13
log
@2001-01-04  Fernando Nasser  <fnasser@@totem.toronto.redhat.com>

	* library/interface.tcl (gdbtk_connect): New proc. Connects to ai
	 remote target (code previously at library/gdbmenubar.itcl).
	(disconnect): Rename to...
	(gdbtk_disconnect): New name for proc disconnect.
	* library/gdbmenubar.itcl (do_connect): Remove the code mentioned
	above and call the new interface proc gdbtk_connect.
	Also, call ::update idletasks after changing the state of the
	menu entries.
	(do_detach): Call gdbtk_disconnect, not ::disconnect (old name).
	(do_disconnect): Call gdbtk_disconnect, not disconnect (old name).
@
text
@d123 1
a123 1
    debug "gdbtk_busy ERROR: $txt" 
d140 1
a140 1
    debug "gdbtk_update ERROR: $txt" 
d187 1
a187 1
    debug "gdbtk_idle 1 ERROR: $txt" 
d193 1
a193 1
      debug "gdbtk_idle 2 ERROR: $txt" 
d447 1
a447 1
#  debug "Running trace find hook with $arg $from_tty"
d466 1
a466 1
#  debug "run readline_command $command $args"
d488 1
a488 1
#  debug "gdbtk_tcl_readline $prompt"
d722 1
a722 1
  debug "gdbtk_locate_main: Searching $main_names"
d743 1
a743 1
  #debug "set_exe_name: exe=$exe  gdb_exe_name=$gdb_exe_name"
d765 1
a765 1
      debug "set_exe ERROR: $msg"
d1566 1
a1566 1
  dbug W "GDBTK_CLEAR_FILE"
@


1.12
log
@2001-01-02  Fernando Nasser  <fnasser@@totem.toronto.redhat.com>

	* library/interface.tcl (gdbtk_quit_check): Save session whenever
	possible.
@
text
@d1212 60
d1470 1
a1470 1
# PROC: disconnect -
d1472 1
a1472 1
proc disconnect {{async 0}} {
@


1.11
log
@	* tclIndex: Rebuilt.
	* interface.tcl (set_exe_name): Save session.
	(gdbtk_quit_check): Save session.
	* session.tcl: New file.
	* srcbar.tcl (create_menu_items): Add menu items to recall old
	sessions.
@
text
@d225 4
a228 1
  } elseif {$gdb_exe_name != ""} {
@


1.10
log
@Backed out erroneously-committed hunk
@
text
@d225 2
d741 4
@


1.9
log
@	* targetselection.itb (TargetSelection::build_win): Add option to
	start xterm.
	* interface.tcl (run_executable): Call tty::create if requested.
	* tty.tcl: New file.
@
text
@a224 2
  } elseif {$gdb_exe_name != ""} {
    session_save
a738 4

  if {$gdb_exe_name != ""} then {
    session_save
  }
@


1.8
log
@Reverted erroneous checkin.  Sorry about that.
@
text
@d209 1
a209 1
  global gdb_downloading gdb_running
d217 3
a219 3
    # While we are running the inferior, gdb_cmd is fenceposted and returns
    # immediately. Therefore, we need to ask here. Do we need to stop the target,
    # too?
d225 2
d741 5
d1005 1
a1005 1
  global gdb_running gdb_exe_name
d1096 7
@


1.7
log
@	* prefs.tcl (pref_save): Put version number into file.  Added
	`session' to list of top-level keys.  Allow keys with many `/'s.
	(pref_read): Recognize version number.
	(escape_value): Generate URL-style encoding.
	(unescape_value): Added `version' argument.  Handle URL decoding.
@
text
@d209 1
a209 1
  global gdb_downloading gdb_running gdb_exe_name
d217 3
a219 3
    # While we are running the inferior, gdb_cmd is fenceposted and
    # returns immediately. Therefore, we need to ask here. Do we need
    # to stop the target, too?
a224 2
  } elseif {$gdb_exe_name != ""} {
    session_save
a738 5

  if {$gdb_exe_name != ""} then {
    session_save
  }

@


1.6
log
@2000-11-06  Fernando Nasser  <fnasser@@cygnus.com>

        * interface.tcl (show_warning): Add missing argument to ide_messageBox
        and add comments explaining why we use it for windows.
@
text
@d209 1
a209 1
  global gdb_downloading gdb_running
d217 3
a219 3
    # While we are running the inferior, gdb_cmd is fenceposted and returns
    # immediately. Therefore, we need to ask here. Do we need to stop the target,
    # too?
d225 2
d741 5
@


1.5
log
@2000-10-13  Fernando Nasser  <fnasser@@cygnus.com>

        With Steven Johnson <sbjohnson@@ozemail.com.au>
        This change fixes part of the possible scenarios where a race condition
        would cause core dumps if there were commands changing registers or
        other target resources in a startup script.
        The remaining scenarios are fixed by a patch to generic.gdbtk.c
        * interface.tcl (gdbtk_update_safe): New function. Like gdbtk_update
        but does nothing if target is running.
        (gdbtk_register_changed): Call the above safe version.
        (gdbtk_memory_changed): Likewise.
@
text
@d335 11
d348 1
a348 1
      ide_messageBox -icon warning \
@


1.4
log
@Reintroduce the code that saves away window state, and restores it
when you restart gdbtk.

2000-03-27  James Ingham  <jingham@@leda.cygnus.com>

	* interface.tcl (gdbtk_quit): Let the window manager store away
	the list of active windows before quitting.
	(gdbtk_tcl_preloop): Open all the windows that were active in the
	former session.
	* prefs.tcl (pref_set_defaults): Set the default value of the
	"gdb/window/active" pref.  Stores the list of active windows.
	* managedwin.itb (ManagedWin::pickle): New method - store away
	instructions to recreate this window.
	(ManagedWin::shutdown): New Method - run through the active windows
	pickling them all.
	(ManagedWin::startup): Restore all the saved active windows.
	* managedwin.ith: Declare pickle, shutdown & startup.
	* tclIndex: regenerate.
@
text
@d148 21
d572 1
a572 1
  after idle gdbtk_update
d582 1
a582 1
  after idle gdbtk_update
@


1.3
log
@2000-03-10  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

	* srcbar.tcl (do_attach): Just call gdbtk_attach_native.
        (do_connect): Replace gdbtk_attach_target call with
        gdbtk_attach_remote call.

	* interface.tcl (gdbtk_attach_native): Renamed from do_attach method
        and moved from srcbar.tcl.
        (gdbtk_attach_remote): New proc. Renamed from gdb_attach_target,
	to better distinguish from the native version.
        (run_executable): Change gdbtk_attach_target call into
        gdbtk_attach_remote.

        * srctextwin.itb: Add keyboard accelerator for Attach command.

        * tclIndex: Rebuild.
@
text
@d96 2
a97 2
  set src [ManagedWin::open SrcWin]
  debug "In preloop, with src: \"$src\" & error: \"$::errorInfo\""
d105 2
d216 1
d1059 1
@


1.2
log
@2000-03-01  James Ingham  <jingham@@leda.cygnus.com>

	* interface.tcl (_open_file): The window which had the focus could
	get deleted by the vwait implicit in the tk_getOpenFile call.  So
	check and make sure it is still around before raising it...
@
text
@d988 1
a988 1
      if {[gdbtk_attach_target] == "ATTACH_CANCELED"} {
d1106 1
a1106 1
#  PROC: gdbtk_attach_target - attach to the target
d1115 1
a1115 1
proc gdbtk_attach_target {} {
d1308 25
@


1.1
log
@Initial revision
@
text
@d779 3
a781 1
    # am not sure how this could happen...
d783 1
a783 1
    if {$curFocus != ""} {
@


1.1.1.1
log
@import insight-2000-02-04 snapshot (2nd try)
@
text
@@
