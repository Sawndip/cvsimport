head	1.31;
access;
symbols
	insight_7_6-2013-04-10-branchpoint:1.31
	gdb_7_6-branch:1.31.0.12
	gdb_7_5-branch:1.31.0.10
	gdb_7_4-branch:1.31.0.8
	gdb_7_3-branch:1.31.0.6
	gdb_7_1-branch:1.31.0.4
	gdb_7_0-branch:1.31.0.2
	arc-sim-20090309:1.30
	arc-insight_6_8-branch:1.30.0.6
	arc-insight_6_8-branchpoint:1.30
	insight_6_8-branch:1.30.0.4
	insight_6_8-branchpoint:1.30
	gdb_6_8-branch:1.30.0.2
	insight_6_6-20070208-release:1.29
	gdb_6_6-branch:1.29.0.4
	gdb_6_6-2006-11-15-branchpoint:1.29
	insight_6_5-20061003-release:1.29
	gdb_6_5-branch:1.29.0.2
	gdb_6_5-2006-05-14-branchpoint:1.29
	gdb-csl-gxxpro-6_3-branch:1.28.0.4
	gdb-csl-gxxpro-6_3-branchpoint:1.28
	gdb_6_4-branch:1.28.0.2
	gdb_6_4-2005-11-01-branchpoint:1.28
	gdb_6_1-2004-04-05-release:1.26
	gdb_6_1-branch:1.26.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.26
	gdb_6_0-2003-10-04-release:1.26
	gdb_6_0-branch:1.26.0.2
	gdb_6_0-2003-06-23-branchpoint:1.26
	gdb_5_3-2002-12-12-release:1.25
	gdb_5_3-branch:1.25.0.2
	gdb_5_3-2002-09-04-branchpoint:1.25
	gdb_5_2_1-2002-07-23-release:1.24
	gdb_5_2-2002-04-29-release:1.24
	gdb_5_2-branch:1.24.0.2
	gdb_5_2-2002-03-03-branchpoint:1.24
	gdb_5_1_1-2002-01-24-release:1.17
	cygnus_cvs_20020108_pre:1.23
	gdb_5_1_0_1-2002-01-03-branch:1.17.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.17
	gdb_5_1-2001-11-21-release:1.17
	gdb_s390-2001-09-26-branch:1.17.0.4
	gdb_s390-2001-09-26-branchpoint:1.17
	gdb_5_1-2001-07-29-branch:1.17.0.2
	gdb_5_1-2001-07-29-branchpoint:1.17
	dberlin-typesystem-branch:1.16.0.2
	dberlin-typesystem-branchpoint:1.16
	insight-precleanup-2001-01-01:1.8
	gdb_5_0-2000-05-19-release:1.4
	gdb_4_18_2-2000-05-18-release:1.4
	gdb_4_95_1-2000-05-11-snapshot:1.4
	gdb_4_95_0-2000-04-27-snapshot:1.4
	gdb_5_0-2000-04-10-branch:1.4.0.2
	gdb_5_0-2000-04-10-branchpoint:1.4
	repo-unification-2000-02-06:1.1.1.1
	insight-2000-02-04:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.31
date	2008.08.02.22.08.32;	author kseitz;	state Exp;
branches;
next	1.30;

1.30
date	2008.02.09.01.23.42;	author kseitz;	state Exp;
branches;
next	1.29;

1.29
date	2005.12.23.18.26.50;	author eliz;	state Exp;
branches;
next	1.28;

1.28
date	2004.08.27.23.13.14;	author hunt;	state Exp;
branches;
next	1.27;

1.27
date	2004.04.05.20.36.44;	author hunt;	state Exp;
branches;
next	1.26;

1.26
date	2002.10.15.21.19.51;	author hunt;	state Exp;
branches;
next	1.25;

1.25
date	2002.04.24.17.11.19;	author kseitz;	state Exp;
branches;
next	1.24;

1.24
date	2002.02.14.02.39.14;	author kseitz;	state Exp;
branches;
next	1.23;

1.23
date	2002.01.03.00.03.46;	author kseitz;	state Exp;
branches;
next	1.22;

1.22
date	2002.01.02.22.09.00;	author irox;	state Exp;
branches;
next	1.21;

1.21
date	2001.12.07.21.19.04;	author kseitz;	state Exp;
branches;
next	1.20;

1.20
date	2001.11.08.18.31.40;	author hunt;	state Exp;
branches;
next	1.19;

1.19
date	2001.11.05.19.14.00;	author hunt;	state Exp;
branches;
next	1.18;

1.18
date	2001.10.30.04.41.44;	author hunt;	state Exp;
branches;
next	1.17;

1.17
date	2001.07.21.18.49.18;	author hunt;	state Exp;
branches;
next	1.16;

1.16
date	2001.07.05.23.24.10;	author kseitz;	state Exp;
branches;
next	1.15;

1.15
date	2001.06.18.17.13.30;	author kseitz;	state Exp;
branches;
next	1.14;

1.14
date	2001.05.18.22.57.30;	author kseitz;	state Exp;
branches;
next	1.13;

1.13
date	2001.04.10.15.49.06;	author kseitz;	state Exp;
branches;
next	1.12;

1.12
date	2001.04.09.17.35.31;	author hunt;	state Exp;
branches;
next	1.11;

1.11
date	2001.03.01.20.00.12;	author kseitz;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.01.12.43.58;	author nsd;	state Exp;
branches;
next	1.9;

1.9
date	2001.01.04.17.55.48;	author fnasser;	state Exp;
branches;
next	1.8;

1.8
date	2000.12.11.18.40.12;	author tromey;	state Exp;
branches;
next	1.7;

1.7
date	2000.12.07.22.40.36;	author tromey;	state Exp;
branches;
next	1.6;

1.6
date	2000.11.30.22.49.46;	author tromey;	state Exp;
branches;
next	1.5;

1.5
date	2000.11.30.22.37.29;	author tromey;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.29.03.18.16;	author jingham;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.28.01.59.40;	author jingham;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.10.23.39.10;	author jingham;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.07.00.19.42;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.07.00.19.42;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.31
log
@        * generic/gdbtk-cmds.c: Don't include itcl.h.
        * generic/gdbtk-hooks.c: Likewise.
        * generic/gdbtk.c: Include tcl.h and tk.h instead of itcl.h
        and itk.h.
        (gdbtk_init): Rewrite to accommodate using a system-provided
        Tcl, Tk, Itcl, Itk.
        (gdbtk_source_start_file) [!_WIN32]: Don't call error() when
        we fail to source the start file. Just dump the message to stderr.
        Throw an exception indicating the failure.
        * library/ehandler.itb (GDBEventHander::dispatch): "itcl_info" is
        deprecated: use "itcl::find objects" instead.
        * library/managedwin.itb (window_instance): Ditto.
        (restart): Ditto.
        (shutdown): Ditto.
        (_open): Ditto.
        (find): Ditto.
        * library/globalpref.itb (_build_win): Don't pass config arguments
        for libgui widgets to the constructor. Configure the widget after
        creation.
        * library/srcpref.itb (_build_win): Ditto.
        * library/main.tcl: Update Tcl, Tk, Itcl, Itk, and Iwidgets (just
        added to this loop) version requirements.
        No need to initialize Iwidgets separately.
        * plugins/Make-rules (TCLHDIR): Renamed to TCL_INCLUDES. Change
        all references.
        (TCL_BUILD_LIB_SPEC): Renamed to TCL_LIBRARY. Change all references.
        * plugins/acinclude.m4: Include the standard tcl.m4 instead
        of the sourceware-derived one.
        * plugins/configure.ac: Use Tcl's standard SC_* macros instead of
        the sourceware-derived CYG_AC_* macros.
        Add logic to deal with using a system-supplied Tcl/Tk.
        * plugins/configure: Regenerated.
        * plugins/Makefile.in: Regenerated.
@
text
@# Managed window for Insight.
# Copyright (C) 1998, 1999, 2000, 2001, 2002, 2004, 2008 Red Hat, Inc.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License (GPL) as published by
# the Free Software Foundation; either version 2 of the License, or (at
# your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.


# ------------------------------------------------------------
#  PUBLIC METHOD:  constructor
# ------------------------------------------------------------
itcl::body ManagedWin::constructor {args} {
  #debug "$this args=$args"
  set _top [winfo toplevel $itk_interior]
}

# ------------------------------------------------------------
#  PUBLIC METHOD: destructor
# ------------------------------------------------------------
itcl::body ManagedWin::destructor {} {
  # If no toplevels remain, quit.  However, check the quit_if_last
  # flag since we might be doing something like displaying a 
  # splash screen at startup...

  if {!$numTopWins && [quit_if_last]} {
    if {$::iipc && [pref get gdb/ipc/exit]} {
      $::insight_ipc send quit
    }
    gdb_force_quit
  } else {
    destroy_toplevel
  }
}

# ------------------------------------------------------------
#  PUBLIC METHOD:  window_name - Set the name of the window
#   (and optionally its icon's name).
# ------------------------------------------------------------
itcl::body ManagedWin::window_name {wname {iname ""}} {

  if {$wname != ""} {
    set _wname $wname
  } else {
    set wname $_wname
  }
  if {$iname != ""} {
    set _iname $iname
  } else {
    set iname $_iname
  }

  if {$win_instance != ""} {
    append wname " \[$win_instance\]"
    if {$iname != ""} {
      append iname " \[$win_instance\]"
    }
  }
  wm title $_top $wname
  if {$iname != ""} {
    wm iconname $_top $iname
  } else {
    wm iconname $_top $wname
  }
}

# ------------------------------------------------------------
#  PUBLIC METHOD:  window_instance - Set the string to be
#   appended to each window title for this instance of Insight
# ------------------------------------------------------------
itcl::body ManagedWin::window_instance {ins} {
  set win_instance $ins
  foreach obj [itcl::find objects -isa ManagedWin] {
    debug "$obj ManagedWin::_wname"
    $obj window_name ""
  }
}

# ------------------------------------------------------------
#  PUBLIC METHOD: pickle - This is the base class pickle
#   method.  It returns a command that can be used to recreate
#   this particular window.  
# ------------------------------------------------------------
itcl::body ManagedWin::pickle {} {
  return [list ManagedWin::open [namespace tail [info class]]]
}

# ------------------------------------------------------------
#  PUBLIC METHOD:  reveal
# ------------------------------------------------------------
itcl::body ManagedWin::reveal {} {
  # Do this update to flush all changes before deiconifying the window.
  update idletasks
  
  raise $_top
  wm deiconify $_top

  # Some window managers (on unix) fail to honor the geometry unless
  # the window is visible.
  if {[info exists ::$_top._init_geometry]} {
    upvar ::$_top._init_geometry gm
    if {$::gdbtk_platform(platform) == "unix"} {
      wm geometry $_top $gm
    }
    unset ::$_top._init_geometry
  }
  
  # There used to be a `focus -force' here, but using -force is
  # unfriendly, so it was removed.  It was then replaced with a simple
  # `focus $top'.  However, this has no useful effect -- it just
  # resets the subwindow of $top which has the `potential' focus.
  # This can actually be confusing to the user.

  # NOT for Windows, though. Without the focus, we get, eg. a
  # register window on top of the source window, but the source window
  # will have the focus. This is not the proper model for Windows.
  if {$::gdbtk_platform(platform) == "windows"} {
    focus -force [focus -lastfor $_top]
  }
}

# ------------------------------------------------------------
#  PUBLIC PROC:  restart
# ------------------------------------------------------------
itcl::body ManagedWin::restart {} {
  # This is needed in case we've called "gdbtk_busy" before the restart.
  # This will configure the stop/run button as necessary
  after idle gdbtk_idle
  
  # call the reconfig method for each object
  foreach obj [itcl::find objects -isa ManagedWin] {
    if {[catch {$obj reconfig} msg]} {
      dbug W "reconfig failed for $obj - $msg"
    } 
  }
}

# ------------------------------------------------------------------
#  PUBLIC PROC:  shutdown - This writes all the active windows to
#   the preferences file, so they can be restored at startup.
#   FIXME: Currently assumes only ONE window per type...
# ------------------------------------------------------------------
itcl::body ManagedWin::shutdown {} {
  set activeWins {}
  foreach win [itcl::find objects -isa ManagedWin] {
    if {![$win isa ModalDialog] && ![$win _ignore_on_save]} {
      set g [wm geometry [winfo toplevel [namespace tail $win]]]
      pref setd gdb/geometry/[namespace tail $win] $g
      lappend activeWins [$win pickle]
    }
  }
  pref set gdb/window/active $activeWins
}

# ------------------------------------------------------------------
#  PUBLIC PROC:  startup - This restores all the windows that were
#   opened at shutdown.
#   FIXME: Currently assumes only ONE window per type...
# ------------------------------------------------------------------
itcl::body ManagedWin::startup {} {
  debug "Got active list [pref get gdb/window/active]"

  foreach cmd [pref get gdb/window/active] {
    eval $cmd
  }
  # If we open the source window, and a source window already exists,
  # then we end up raising it twice during startup.  This yields an
  # annoying effect for the user: if the user tries the bury the
  # source window during startup, it will raise itself again.  This
  # explains why we first check to see if a source window exists
  # before trying to create it -- raising the window is an inevitable
  # side effect of the creation process.
  if {[llength [find SrcWin]] == 0} {
    ManagedWin::open SrcWin
  }
}

# ------------------------------------------------------------
#  PUBLIC PROC:  open_dlg
# ------------------------------------------------------------
itcl::body ManagedWin::open_dlg {class args} {
  
  set newwin [eval _open $class $args]
  if {$newwin != ""} {
    $newwin reveal
    $newwin post
  }
}

# ------------------------------------------------------------
#  PUBLIC PROC:  open
# ------------------------------------------------------------
itcl::body ManagedWin::open {class args} {
  
  set newwin [eval _open $class $args]
  if {$newwin != ""} {
    if {[$newwin isa ModalDialog]} {
      parse_args [list {expire 0}]
      after idle "$newwin reveal; $newwin post 0 $expire"
    } else {
      after idle "$newwin reveal"
    }
  }
  
  return $newwin
}

# ------------------------------------------------------------
#  PRIVATE PROC:  _open
# ------------------------------------------------------------
itcl::body ManagedWin::_open { class args } {
  debug "$class $args"
  
  parse_args force

  if {!$force} {
    # check all windows for one of this type
    foreach obj [itcl::find objects -isa ManagedWin] {
      if {[$obj isa $class]} {
	$obj reveal
	return $obj
      }
    }
    
  }
  # need to create a new window
  return [eval _create $class $args]
}

# ------------------------------------------------------------
#  PRIVATE PROC:  _create
# ------------------------------------------------------------
itcl::body ManagedWin::_create { class args } {
  
  set win [string tolower $class]
  debug "win=$win args=$args"
  
  parse_args {center transient {over ""}} 
  
  # increment window numbers until we get an unused one
  set i 0
  while {[winfo exists .$win$i]} { incr i }
  
  while { 1 } {
    set top [toplevel .$win$i]
    wm withdraw $top
    wm protocol $top WM_DELETE_WINDOW "destroy $top"
    wm group $top .
    set newwin $top.$win
    if {[catch {uplevel \#0 eval $class $newwin $args} msg]} {
      dbug E "object creation of $class failed: $msg"
      dbug E $::errorInfo
      if {[string first "object already exists" $msg] != -1} {
	# sometimes an object is still really around even though
	# [winfo exists] said it didn't exist.  Check for this case
	# and increment the window number again.
	catch {destroy $top}
	incr i
      } else {
	return ""
      }
    } else {
      break
    }
  }
  
  if {[catch {pack $newwin -expand yes -fill both}]} {
    dbug W "packing of $newwin failed: $::errorInfo"
    return ""
  }
  
  wm maxsize $top $_screenwidth $_screenheight
  wm minsize $top 20 20
  update idletasks

  if {$over != ""} {
    # center new window
    center_window $top -over [winfo toplevel [namespace tail $over]]
  } elseif {$center} {
    center_window $top
  }

  if {$transient} {
    wm resizable $top 0 0

    # If a SrcWin is around, use its toplevel as the master for
    # the transient. Otherwise use ".". (The splash screen will
    # need ".", for example.)
    set srcs [ManagedWin::find SrcWin]
    if {[llength $srcs] > 0} {
      set w [winfo toplevel [namespace tail [lindex $srcs 0]]]
    } else {
      set w .
    }
    wm transient $top $w
  } elseif {$::gdbtk_platform(platform) == "unix"} {
    # Modal dialogs DONT get Icons...
    if {[pref get gdb/use_icons] && ![$newwin isa ModalDialog]} {
      set icon [_make_icon_window ${top}_icon]
      wm iconwindow $top $icon
      bind $icon <Double-1> "$newwin reveal"
    }
  }
  
  if {[info exists ::env(GDBTK_TEST_RUNNING)] && $::env(GDBTK_TEST_RUNNING)} {
    set g "+100+100"
    wm geometry $top $g
    wm positionfrom $top user
  } else {
    set g [pref getd gdb/geometry/$newwin]
    if {$g == "1x1+0+0"} { 
      dbug E "bad geometry"
      set g ""
    }
    if {$g != ""} {
      # OK. We have a requested geometry. We know that it fits on the screen
      # because we set the maxsize.  Now we have to make sure it will not be
      # displayed off the screen.
      set w 0; set h 0; set x 0; set y 0
      if {![catch {scan $g  "%dx%d%d%d" w h x y} res]} {
	if {$x < 0} {
	  set x [expr $_screenwidth + $x]
	}
	if {$y < 0} {
	  set y [expr $_screenheight + $y]
	}
	
	# If the window is transient, then don't reset its size, since
	# the user didn't set this anyway, and in some cases where the
	# size can change dynamically, like the Global Preferences
	# dialog, this can hide parts of the dialog with no recourse...
	
	# if dont_remember_size is true, don't set size, just like
	# transients
	
	if {$transient || [dont_remember_size]} {
	  set g "+${x}+${y}"
	} else {
	  set g "${w}x${h}+${x}+${y}"
	}
	if {[expr $x+50] < $_screenwidth && [expr $y+20] < $_screenheight} {
	  wm positionfrom $top user
	  wm geometry $top $g
	  set ::$top._init_geometry $g
	}
      }
    }
  }

  bind $top <Alt-F4> [list delete object $newwin]

  return $newwin
}

# ------------------------------------------------------------
#  PUBLIC PROC:  find
# ------------------------------------------------------------
itcl::body ManagedWin::find { win } {
  debug "$win"
  set res ""
  foreach obj [itcl::find objects -isa ManagedWin] {
    if {[$obj isa $win]} {
      lappend res $obj
    }
  }
  return $res
}

# ------------------------------------------------------------
#  PUBLIC PROC:  init
# ------------------------------------------------------------
itcl::body ManagedWin::init {} {
  wm withdraw .
  set _screenheight [winfo screenheight .]
  set _screenwidth [winfo screenwidth .]
}

# ------------------------------------------------------------
#  PUBLIC METHOD:  destroy_toplevel
# ------------------------------------------------------------
itcl::body ManagedWin::destroy_toplevel {} {
  after idle "update idletasks;destroy $_top"
}

# ------------------------------------------------------------
#  PROTECTED METHOD:  _freeze_me
# ------------------------------------------------------------
itcl::body ManagedWin::_freeze_me {} {
  $_top configure -cursor watch
  ::update idletasks
}

# ------------------------------------------------------------
#  PROTECTED METHOD: _thaw_me
# ------------------------------------------------------------
itcl::body ManagedWin::_thaw_me {} {

  $_top configure -cursor {}
  ::update idletasks
}

# ------------------------------------------------------------------
#  PRIVATE PROC: _make_icon_window - create a small window with an
#   icon in it for use by certain Unix window managers.
# ------------------------------------------------------------------
itcl::body ManagedWin::_make_icon_window {name {file "gdbtk_icon"}} {
  if {![winfo exists $name]} {
    toplevel $name
    label $name.im -image \
      [image create photo icon_photo -file [file join $::gdb_ImageDir $file.gif]]
  }
  pack $name.im
  return $name
}
@


1.30
log
@        * library/main.tcl: Add gdbtk_platform definitions.
        * library/attachdlg.itb (list_pids): Use gdbtk_platform
        instead of tcl_platform.
        * library/bpwin.itb (build_win): Likewise.
        (_bp_add): Likewise.
        (_bp_modify): Likewise.
        * library/download.itb (download_it): Likewise.
        * library/globalpref.itb (_build_win): Likewise.
        * library/helpviewer.tcl (open_help): Likewise.
        * library/interface.tcl (gdbtk_tcl_query): Likewise.
        (show_warning): Likewise.
        (open_file): Likewise.
        (run_executable): Likewise.
        * library/managedwin.itb (reveal): Likewise.
        (_create): Likewise.
        * library/prefs.tcl (pref_read): Likewise.
        (pref_set_defaults): Likewise.
        (pref_set_colors): Likewise.
        * library/session.tcl (_exe_name): Likewise.
        * library/srcbar.itcl (_update_file_menu): Likewise.
        (create_run_menu): Likewise.
        * library/srctextwin.itb (_mtime_changed): Likewise.
        (LoadFromCache): Likewise.
        * library/targetselection.itb (default_port): Likewise.
        (build_win): Likewise.

        * library/memwin.itb (build_win): Remove unused tcl_platform
        declaration.
        * library/pluginwin.itcl (enable_ui): Likewise.
        * library/process.itb (build_win): Likewise.
        * library/srcbar.itcl (enable_ui): Likewise.
        * library/srcwin.itb (location): Likewise.
        * library/stackwin.itb (build_win): Likewise.
        * library/tdump.tcl (build_win): Likewise.
@
text
@d78 1
a78 1
  foreach obj [itcl_info objects -isa ManagedWin] {
d136 1
a136 1
  foreach obj [itcl_info objects -isa ManagedWin] {
d150 1
a150 1
  foreach win [itcl_info objects -isa ManagedWin] {
d223 1
a223 1
    foreach obj [itcl_info objects -isa ManagedWin] {
d366 1
a366 1
  foreach obj [itcl_info objects -isa ManagedWin] {
@


1.29
log
@	* library/attachdlg.itb:
	* library/actiondlg.tcl:
	* library/about.tcl:
	* library/ehandler.itb:
	* library/editor.tcl:
	* library/download.ith:
	* library/download.itb:
	* library/debugwin.ith:
	* library/debugwin.itb:
	* library/cspref.ith:
	* library/cspref.itb:
	* library/console.ith:
	* library/console.itb:
	* library/browserwin.ith:
	* library/browserwin.itb:
	* library/bpwin.ith:
	* library/bpwin.itb:
	* library/blockframe.ith:
	* library/managedwin.ith:
	* library/managedwin.itb:
	* library/main.tcl:
	* library/locals.tcl:
	* library/ipcpref.ith:
	* library/ipcpref.itb:
	* library/ipc.tcl:
	* library/interface.tcl:
	* library/helpviewer.tcl:
	* library/globalpref.ith:
	* library/globalpref.itb:
	* library/gdbwin.ith:
	* library/gdbtoolbar.itcl:
	* library/gdbmenubar.itcl:
	* library/gdbevent.ith:
	* library/gdbevent.itb:
	* library/embeddedwin.ith:
	* library/ehandler.ith:
	* library/srcwin.itb:
	* library/srctextwin.ith:
	* library/srctextwin.itb:
	* library/srcpref.ith:
	* library/srcpref.itb:
	* library/srcbar.itcl:
	* library/session.tcl:
	* library/regwin.ith:
	* library/regwin.itb:
	* library/process.ith:
	* library/process.itb:
	* library/prefs.tcl:
	* library/pluginwin.itcl:
	* library/modal.tcl:
	* library/memwin.ith:
	* library/memwin.itb:
	* library/mempref.ith:
	* library/mempref.itb:
	* library/watch.tcl:
	* library/watch.tcl:
	* library/warning.tcl:
	* library/vartree.ith:
	* library/vartree.itb:
	* library/util.tcl:
	* library/tracedlg.tcl:
	* library/toplevelwin.ith:
	* library/tfind_args.tcl:
	* library/tdump.tcl:
	* library/targetselection.ith:
	* library/targetselection.itb:
	* library/stackwin.ith:
	* library/stackwin.itb:
	* library/srcwin.ith:
@
text
@d2 1
a2 1
# Copyright (C) 1998, 1999, 2000, 2001, 2002, 2004 Red Hat, Inc.
d107 1
a107 1
    if {$::tcl_platform(platform) == "unix"} {
d122 1
a122 1
  if {$::tcl_platform(platform) == "windows"} {
d301 1
a301 1
  } elseif {$::tcl_platform(platform) == "unix"} {
@


1.28
log
@2004-08-27  Martin Hunt  <hunt@@redhat.com>

	* library/ipc.tcl: New file.
	* library/ipcpref.ith: New file.
	* library/ipcpref.itb: New file.

	* library/srcwin.itb (SrcWin::inferior): Call ipc
	send if enabled.

	* library/prefs.tcl (pref_set_defaults): Enable color
	schemes by default. Add IPC defaults.

	* library/srcbar.itcl (create_pref_menu): Create
	"Advanced" cascade menu and put "Edit Color Schemes"
	and "IPC Support" under it.

	* library/managedwin.itb (ManagedWin::destructor):
	If IPC enabled then send "quit" on exit.

	* library/main.tcl: Start IPC if enabled.

	* library/prefs.tcl (pref_set_defaults): Add IPC defaults.

	* library/gdbmenubar.itcl (menubar_get_current_menu):
	New method.
@
text
@d2 1
a2 1
# Copyright 1998, 1999, 2000, 2001, 2002, 2004 Red Hat, Inc.
@


1.27
log
@2004-04-05  Martin Hunt  <hunt@@redhat.com>

	* library/session.tcl: Make hostname and portname
	session-dependent. Add gdb_bg_num (the color
	scheme number) as a per-session variable.

	* library/prefs.tcl (pref_read): If color schemes are in use,
	set colors based on the current scheme.
	(pref_save): Add "bg" section.
	(pref_set_defaults): Define new variable gdb/use_color_schemes
	and define 16 default background colors.

	* library/managedwin.itb (ManagedWin::window_name): Append
	window "instance" string to window name.
	(ManagedWin::window_instance): Set window instance string.

	* library/debugwin.itb: Add a reconfig method to restore
	unique black textbackground, overriding color scheme.

	* library/csprefs.itb:
	* library/csprefs.ith: New files. Implement color scheme
	preferences.

	* library/util.tcl (set_bg_colors): New function.
	(r_setcolors): New function.

	* library/regwin.itb (_prefs_changed): Deleted.
	(reconfig): New function.  Updates tkTable color tags
	if color scheme changes.
	* library/regwin.ith: Update to reflect above changes.

	* library/srcbar.itcl (create_pref_menu): Add pulldown
	menus for "Edit Color Schemes..." and "Use Color Schemes".
	(reconfig): Fix up menu items for color schemes.

	* library/globalpref.itb (_init_var): Add
	gdb/use_color_schemes to variable list.
	(_build_win): Add a checkbutton to enable/disable
	color schemes.

	* library/gdbmenubar.itcl (menubar_add_cascade): Add a class
	argument so cascade menus can be managed by class too.

	* library/interface.tcl (gdbtk_tcl_fputs): Check for
	existence of gdbtk_state(console).  Stops annoying error
	messages.
	(gdbtk_tcl_fputs_error): Ditto.
	(gdbtk_tcl_fputs_log): Ditto.
@
text
@d32 3
@


1.26
log
@2002-10-15  Martin M. Hunt  <hunt@@redhat.com>

	* library/* : auto_mkindex cannot rebuild
	tclIndex because it does not recognize the namespace
	import in main.tcl.  To get it to work again, rename the
	following:
		body -> itcl::body
		configbody -> itcl::configbody
		class -> itcl::class
@
text
@d2 1
a2 1
# Copyright 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
d43 18
d66 12
@


1.25
log
@        * library/managedwin.ith (_ignore_on_save): New protected method.
        * library/managedwin.itb (shutdown): If _ignore_on_save, don't
        save this window to the active window list in the preferences
        file.
        * library/debugwin.ith (DebugWin::_ignore_on_save): Don't save
        this window to preferences active list.
        (DebugWinDOpts::_ignore_on_save): Likewise.
        * library/pluginwin.itcl (_ignore_on_save): Likewise.
        * library/download.ith (_ignore_on_save): Likewise.
@
text
@d18 1
a18 1
body ManagedWin::constructor {args} {
d26 1
a26 1
body ManagedWin::destructor {} {
d42 1
a42 1
body ManagedWin::window_name {wname {iname ""}} {
d56 1
a56 1
body ManagedWin::pickle {} {
d63 1
a63 1
body ManagedWin::reveal {} {
d97 1
a97 1
body ManagedWin::restart {} {
d115 1
a115 1
body ManagedWin::shutdown {} {
d132 1
a132 1
body ManagedWin::startup {} {
d153 1
a153 1
body ManagedWin::open_dlg {class args} {
d165 1
a165 1
body ManagedWin::open {class args} {
d183 1
a183 1
body ManagedWin::_open { class args } {
d205 1
a205 1
body ManagedWin::_create { class args } {
d330 1
a330 1
body ManagedWin::find { win } {
d344 1
a344 1
body ManagedWin::init {} {
d353 1
a353 1
body ManagedWin::destroy_toplevel {} {
d360 1
a360 1
body ManagedWin::_freeze_me {} {
d368 1
a368 1
body ManagedWin::_thaw_me {} {
d378 1
a378 1
body ManagedWin::_make_icon_window {name {file "gdbtk_icon"}} {
@


1.24
log
@	* library/managedwin.itb (_create): If given a transient window,
	make sure that the SrcWin that is to become its master exists;
	otherwise, use ".".
@
text
@d118 1
a118 2
    if {![$win isa ModalDialog] && ![$win isa DebugWin] &&
	![$win isa DebugWinDOpts] && ![$win isa PluginWindow]} {
@


1.23
log
@Update copyright.
@
text
@d258 11
a268 1
    wm transient $top [winfo toplevel [namespace tail [lindex [ManagedWin::find SrcWin] 0]]]
@


1.22
log
@       * library/managedwin.itb (ManagedWin::_create):  When
       making a modal window transient, use the source window
       as the master and not ".".
@
text
@d2 1
a2 1
# Copyright 1998, 1999, 2000, 2001 Red Hat, Inc.
@


1.21
log
@        * library/managedwin.itb (shutdown): Don't save geometry for                                    plugins, either.
@
text
@d258 1
a258 1
    wm transient $top .
@


1.20
log
@2001-11-08  Martin M. Hunt  <hunt@@redhat.com>

	* library/managedwin.itb (ManagedWin::shutdown): Fix
	typo in class name DebugWinDOpts.

	* library/debugwin.itb: Add MemWin to _classes.
@
text
@d119 1
a119 1
	![$win isa DebugWinDOpts]} {
@


1.19
log
@2001-11-05  Martin M. Hunt  <hunt@@redhat.com>

	* library/debugwin.itb (DebugWin::build_win):
	Initialize gdbtk_de(ERRORS_ONLY) and gdbtk_de(filter_var)
	(DebugWin::puts): Rewrite filter to handle new options.
	(DebugWinDOpts::build_win): Update list of classes. Change
	filter dialog so we can not display only errors and warnings
	or choose between displaying ALL classes except those selected
	or only selected classes. Fix "OK" button to apply
	changes before closing dialog.
	DebugWinOpts::_apply): Now takes an agrument that
	indicates if dialog should exit after applying filter.

	* library/debugwin.ith (_apply): Now takes an arg.

	* library/main.tcl: If GDBTK_DEBUGFILE is not set,
	use "insight.log" as the default. If GDBTK_DEBUG is set
	and nonzero, start logging debug messages to
	GDBTK_DEBUGFILE immediately. Never open the debug window
	automatically.

	* library/managedwin.itb (ManagedWin::shutdown): Don't
	save debug window options dialog on active list

	* library/srcwin.itb: Remove troublesome debug line.
@
text
@d119 1
a119 1
	! [$win isa DebugWinDopts]} {
@


1.18
log
@2001-10-29  Martin M. Hunt  <hunt@@redhat.com>

	* library/debugwin.itb: Don't increment number of
	TopLevelWins.

	* library/managedwin.itb: Don't save DebugWins to
	active list.
@
text
@d118 2
a119 1
    if {![$win isa ModalDialog] && ![$win isa DebugWin]} {
@


1.17
log
@2001-07-20  Martin M. Hunt  <hunt@@redhat.com>

	* library/managedwin.itb: Revert to global to properly
	initialize geometry with some window managers.
	* library/managedwin.ith (shutdown): Remove _geometry.
@
text
@a26 1

d118 1
a118 1
    if {![$win isa ModalDialog]} {
@


1.16
log
@	* library/managedwin.itb (_create): Don't pass "-over"
	to center_window unless we really are asked to put the
	window over another!
@
text
@d70 1
d73 6
a78 3
  if {$_geometry != "" && $::tcl_platform(platform) == "unix"} {
    wm geometry $_top $_geometry
    set _geometry ""
d80 1
a80 3

  #debug "$_top geometry=[wm geometry $_top] state=[wm state $_top]"

@


1.15
log
@	* library/managedwin.itb (_create): When creating a
	window over another, be sure to center on the window,
	not the object.
@
text
@d247 1
a247 1
  if {$over != "" || $center} {
d250 2
d253 1
a253 1
  
@


1.14
log
@	* library/managedwin.ith (_geometry): Use a protected variable
	instead of a global from ManagedWin::reveal.
	(open): Make arg list reflect managedwin.itb.
	* library/managedwin.itb (window_name): Use class variable
	_top instead of recomputing the toplevel every time.
	(reveal): Ditto.
	Use class variable "_geometry" instead of global variable.
	(shutdown): Do not save ModalDialogs.
	(_create): If centering the new window, use libgui's
	center_window to do it.
@
text
@d249 1
a249 1
    center_window $top -over $over
@


1.13
log
@	From Tom Tromey (tromey@@redhat.com):
	* library/managedwin.itb (reveal): We actually do want to force
	the focus for Windows.
@
text
@d41 1
a41 1
#   (and optionally it's icon's name).
d44 1
a44 2
  set top [winfo toplevel [namespace tail $this]]
  wm title $top $wname
d46 1
a46 1
    wm iconname $top $iname
d48 1
a48 1
    wm iconname $top $wname
d68 7
a74 11
  set top [winfo toplevel [namespace tail $this]]
  set g [wm geometry $top]
  #debug "$top geometry=$g state=[wm state $top]"
  raise $top
  wm deiconify $top
  if {[info exists ::$top._init_geometry]} {
    upvar ::$top._init_geometry gm
    if {$::tcl_platform(platform) == "unix"} {
      wm geometry $top $gm
    }
    unset ::$top._init_geometry
d76 2
a77 1
  #debug "$top geometry=[wm geometry $top] state=[wm state $top]"
d89 1
a89 1
    focus -force [focus -lastfor $top]
d117 5
a121 3
    set g [wm geometry [winfo toplevel [namespace tail $win]]]
    pref setd gdb/geometry/[namespace tail $win] $g
    lappend activeWins [$win pickle]
d245 5
a249 14
  
  if {$over != ""} {
    # center new window over widget
    set t [winfo toplevel [namespace tail $over]]
    set cx [expr {[winfo rootx $t] + [winfo width $t] / 2}]
    set cy [expr {[winfo rooty $t] + [winfo height $t] / 2}]
    set x [expr {$cx - [winfo reqwidth $top] / 2}]
    set y [expr {$cy - [winfo reqheight $top] / 2}]
    wm geometry $top +$x+$y    
  } elseif {$center} {
    # center the window on the screen
    set x [expr {[winfo screenwidth $top] / 2 - [winfo reqwidth $top] / 2}]
    set y [expr {[winfo screenheight $top] / 2 - [winfo reqheight $top] / 2}]
    wm geometry $top +$x+$y
d345 1
a345 1
#  PRIVATE METHOD:  _freeze_me
d353 1
a353 1
#  PRIVATE METHOD: _thaw_me
@


1.12
log
@2001-04-09  Martin M. Hunt  <hunt@@redhat.com>

	* library/managedwin.itb (ManagedWin::reveal): After
	deiconifying window for the first time, set its geometry
	again, if the platform is unix. This fixes a problem with kde.
	(ManagedWin::_create): Set a variable with the initial
	geometry.
@
text
@d88 7
@


1.11
log
@Cleanup of managedwin.ith and managedwin.itb

	* library/managedwin.ith: Move all implementations into
	managedwin.itb.
	(public variable nosize): Delete.
	(freeze_me, thaw_me, make_icon_window): Prepend with
	underscore to remind people these are not public
	methods/procs.
	(protected variable Top, screenwidth, screenheight): Ditto
	for these variables.
	(protected common manage_active, mainwindow): Delete.
	(enable): Delete.
	(reconfig): Add empty body.
	* library/managedwin.itb: Move all implementations from
	header here.
	Update all references to renamed variables/methods/procs.
	(destructor, restart, shutdown, _open, find) Let
	Itcl tell us which ManagedWins we have lying around.
	(enable): Delete.
	(reconfig): It's empty. Moved empty body to header.
@
text
@d1 1
a1 1
# Managed window for GDBtk.
d70 2
d74 8
d305 1
d307 1
a307 1
	  wm positionfrom $top user
a335 1
  debug
@


1.10
log
@	* library/managedwin.itb (ManagedWin::shutdown): Save each
	managed window's geometry as a preference.
	* library/managedwin.ith (ManagedWin::destructor): Don't save
	managed windows' geometries as preferences.
@
text
@d2 1
a2 1
# Copyright 1998, 1999 Cygnus Solutions
d15 12
a26 1
body ManagedWin::reconfig {} {}
d28 3
d32 11
d54 3
a56 2
# pickle - This is the base class pickle method.  It returns a
#  a command that can be used to recreate this particular window.  
d62 3
d80 3
d89 1
a89 1
  foreach obj $manage_active {
d97 3
a99 3
#  shutdown - This writes all the active windows to the preferences file,
#  so they can be restored at startup.
#  FIXME: Currently assumes only ONE window per type...
a100 1

d103 4
a106 6
  foreach win $manage_active {
    if {[$win isa ManagedWin]} {
      set g [wm geometry [winfo toplevel [namespace tail $win]]]
      pref setd gdb/geometry/[namespace tail $win] $g
      lappend activeWins [$win pickle]
    }
d112 3
a114 2
#  startup - This restores all the windows that were opened at shutdown.
#  FIXME: Currently assumes only ONE window per type...
a115 1

d134 3
d146 3
a148 1

d164 3
d174 1
a174 1
    foreach obj $manage_active {
d186 3
d228 1
a228 1
  wm maxsize $top $screenwidth $screenheight
d252 1
a252 1
      set icon [make_icon_window ${top}_icon]
d275 1
a275 1
	  set x [expr $screenwidth + $x]
d278 1
a278 1
	  set y [expr $screenheight + $y]
d294 1
a294 1
	if {[expr $x+50] < $screenwidth && [expr $y+20] < $screenheight} {
d307 3
d313 1
a313 1
  foreach obj $manage_active {
d321 3
a323 4
body ManagedWin::enable { on } {
}


d327 2
a328 2
  set screenheight [winfo screenheight .]
  set screenwidth [winfo screenwidth .]
d331 3
d335 1
a335 1
  after idle "update idletasks;destroy $Top"
d338 5
a342 2
body ManagedWin::freeze_me {} {
  $Top configure -cursor watch
d346 4
a349 1
body ManagedWin::thaw_me {} {
d351 1
a351 1
  $Top configure -cursor {}
d356 2
a357 2
#  make_icon_window - create a small window with an icon in
#  it for use by certain Unix window managers.
d359 1
a359 2

body ManagedWin::make_icon_window {name {file "gdbtk_icon"}} {
@


1.9
log
@2001-01-04  Fernando Nasser  <fnasser@@redhat.com>

	The following changes fix the problem of having to click on a splash
	window to make it disapear.
	* modal.tcl (post): Take as an argument "expire", the time a modal
	window is displayed.
	* managedwin.itb (open): Check for an "expire" argument and pass the
	value down to modal post method.
@
text
@d74 2
@


1.8
log
@	* managedwin.itb (ManagedWin::startup): Only open source window
	if it doesn't already exist.
@
text
@d118 2
a119 1
      after idle "$newwin reveal; $newwin post"
@


1.7
log
@	* managedwin.itb (ManagedWin::reveal): Don't set focus.
@
text
@d91 10
a100 1
  ManagedWin::open SrcWin
d131 1
a131 1
  
@


1.6
log
@Reverted erroneous checkin.  Sorry about that.
@
text
@d43 6
a48 5
  
  # I don't understand this next line and no one commented it, so it's gone.
  #focus -force [focus -lastfor $top]
  
  focus $top
@


1.5
log
@	* prefs.tcl (pref_save): Put version number into file.  Added
	`session' to list of top-level keys.  Allow keys with many `/'s.
	(pref_read): Recognize version number.
	(escape_value): Generate URL-style encoding.
	(unescape_value): Added `version' argument.  Handle URL decoding.
@
text
@d43 5
@


1.4
log
@2000-03-28  James Ingham  <jingham@@leda.cygnus.com>

	* managedwin.itb (ManagedWin::startup): Open the SrcWin, this does
	two things, 1) Makes sure that there IS a SrcWin, and 2) brings
	the first such window to the foreground...
@
text
@a42 5
  
  # I don't understand this next line and no one commented it, so it's gone.
  #focus -force [focus -lastfor $top]
  
  focus $top
@


1.3
log
@Reintroduce the code that saves away window state, and restores it
when you restart gdbtk.

2000-03-27  James Ingham  <jingham@@leda.cygnus.com>

	* interface.tcl (gdbtk_quit): Let the window manager store away
	the list of active windows before quitting.
	(gdbtk_tcl_preloop): Open all the windows that were active in the
	former session.
	* prefs.tcl (pref_set_defaults): Set the default value of the
	"gdb/window/active" pref.  Stores the list of active windows.
	* managedwin.itb (ManagedWin::pickle): New method - store away
	instructions to recreate this window.
	(ManagedWin::shutdown): New Method - run through the active windows
	pickling them all.
	(ManagedWin::startup): Restore all the saved active windows.
	* managedwin.ith: Declare pickle, shutdown & startup.
	* tclIndex: regenerate.
@
text
@d89 2
a90 1
  }  
@


1.2
log
@2000-03-10  James Ingham  <jingham@@leda.cygnus.com>

	* util.tcl (keep_raised): For some reason raising a window, then
	deiconifying it is MUCH faster on "e" & WindowMaker under XFree.
	Go figure.  Other WM's don't seem to care, so do it this way...
	* managedwin.itb (ManagedWin::reveal): Ditto...
@
text
@d28 7
d61 29
@


1.1
log
@Initial revision
@
text
@d34 1
a40 1
  raise $top
@


1.1.1.1
log
@import insight-2000-02-04 snapshot (2nd try)
@
text
@@
