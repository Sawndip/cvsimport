head	1.119;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.112
	gdb_7_6-2013-04-26-release:1.112
	gdb_7_6-branch:1.112.0.2
	gdb_7_6-2013-03-12-branchpoint:1.112
	gdb_7_5_1-2012-11-29-release:1.97
	gdb_7_5-2012-08-17-release:1.97
	gdb_7_5-branch:1.97.0.2
	gdb_7_5-2012-07-18-branchpoint:1.97
	gdb_7_4_1-2012-04-26-release:1.84.2.1
	gdb_7_4-2012-01-24-release:1.84.2.1
	gdb_7_4-branch:1.84.0.2
	gdb_7_4-2011-12-13-branchpoint:1.84
	gdb_7_3_1-2011-09-04-release:1.81
	gdb_7_3-2011-07-26-release:1.81
	gdb_7_3-branch:1.81.0.2
	gdb_7_3-2011-04-01-branchpoint:1.81
	gdb_7_2-2010-09-02-release:1.76.2.1
	gdb_7_2-branch:1.76.0.2
	gdb_7_2-2010-07-07-branchpoint:1.76
	gdb_7_1-2010-03-18-release:1.70
	gdb_7_1-branch:1.70.0.2
	gdb_7_1-2010-02-18-branchpoint:1.70
	gdb_7_0_1-2009-12-22-release:1.61
	gdb_7_0-2009-10-06-release:1.61
	gdb_7_0-branch:1.61.0.2
	gdb_7_0-2009-09-16-branchpoint:1.61
	arc-sim-20090309:1.42
	msnyder-checkpoint-072509-branch:1.59.0.2
	msnyder-checkpoint-072509-branchpoint:1.59
	arc-insight_6_8-branch:1.42.0.6
	arc-insight_6_8-branchpoint:1.42
	insight_6_8-branch:1.42.0.4
	insight_6_8-branchpoint:1.42
	reverse-20081226-branch:1.51.0.2
	reverse-20081226-branchpoint:1.51
	multiprocess-20081120-branch:1.49.0.2
	multiprocess-20081120-branchpoint:1.49
	reverse-20080930-branch:1.48.0.2
	reverse-20080930-branchpoint:1.48
	reverse-20080717-branch:1.46.0.2
	reverse-20080717-branchpoint:1.46
	msnyder-reverse-20080609-branch:1.45.0.2
	msnyder-reverse-20080609-branchpoint:1.45
	drow-reverse-20070409-branch:1.36.0.2
	drow-reverse-20070409-branchpoint:1.36
	gdb_6_8-2008-03-27-release:1.42
	gdb_6_8-branch:1.42.0.2
	gdb_6_8-2008-02-26-branchpoint:1.42
	gdb_6_7_1-2007-10-29-release:1.39
	gdb_6_7-2007-10-10-release:1.39
	gdb_6_7-branch:1.39.0.2
	gdb_6_7-2007-09-07-branchpoint:1.39
	insight_6_6-20070208-release:1.35
	gdb_6_6-2006-12-18-release:1.35
	gdb_6_6-branch:1.35.0.2
	gdb_6_6-2006-11-15-branchpoint:1.35
	insight_6_5-20061003-release:1.34
	gdb-csl-symbian-6_4_50_20060226-12:1.34
	gdb-csl-sourcerygxx-3_4_4-25:1.30
	nickrob-async-20060828-mergepoint:1.35
	gdb-csl-symbian-6_4_50_20060226-11:1.34
	gdb-csl-sourcerygxx-4_1-17:1.34
	gdb-csl-20060226-branch-local-2:1.34
	gdb-csl-sourcerygxx-4_1-14:1.34
	gdb-csl-sourcerygxx-4_1-13:1.34
	gdb-csl-sourcerygxx-4_1-12:1.34
	gdb-csl-sourcerygxx-3_4_4-21:1.34
	gdb_6_5-20060621-release:1.34
	gdb-csl-sourcerygxx-4_1-9:1.34
	gdb-csl-sourcerygxx-4_1-8:1.34
	gdb-csl-sourcerygxx-4_1-7:1.34
	gdb-csl-arm-2006q1-6:1.34
	gdb-csl-sourcerygxx-4_1-6:1.34
	gdb-csl-symbian-6_4_50_20060226-10:1.34
	gdb-csl-symbian-6_4_50_20060226-9:1.34
	gdb-csl-symbian-6_4_50_20060226-8:1.34
	gdb-csl-coldfire-4_1-11:1.34
	gdb-csl-sourcerygxx-3_4_4-19:1.34
	gdb-csl-coldfire-4_1-10:1.34
	gdb_6_5-branch:1.34.0.16
	gdb_6_5-2006-05-14-branchpoint:1.34
	gdb-csl-sourcerygxx-4_1-5:1.34
	nickrob-async-20060513-branch:1.34.0.14
	nickrob-async-20060513-branchpoint:1.34
	gdb-csl-sourcerygxx-4_1-4:1.34
	msnyder-reverse-20060502-branch:1.34.0.12
	msnyder-reverse-20060502-branchpoint:1.34
	gdb-csl-morpho-4_1-4:1.34
	gdb-csl-sourcerygxx-3_4_4-17:1.34
	readline_5_1-import-branch:1.34.0.10
	readline_5_1-import-branchpoint:1.34
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.34
	gdb-csl-symbian-20060226-branch:1.34.0.8
	gdb-csl-symbian-20060226-branchpoint:1.34
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.34
	msnyder-reverse-20060331-branch:1.34.0.6
	msnyder-reverse-20060331-branchpoint:1.34
	gdb-csl-available-20060303-branch:1.34.0.4
	gdb-csl-available-20060303-branchpoint:1.34
	gdb-csl-20060226-branch:1.34.0.2
	gdb-csl-20060226-branchpoint:1.34
	gdb_6_4-20051202-release:1.30
	msnyder-fork-checkpoint-branch:1.30.0.8
	msnyder-fork-checkpoint-branchpoint:1.30
	gdb-csl-gxxpro-6_3-branch:1.30.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.30
	gdb_6_4-branch:1.30.0.4
	gdb_6_4-2005-11-01-branchpoint:1.30
	gdb-csl-arm-20051020-branch:1.30.0.2
	gdb-csl-arm-20051020-branchpoint:1.30
	msnyder-tracepoint-checkpoint-branch:1.29.0.4
	msnyder-tracepoint-checkpoint-branchpoint:1.29
	gdb-csl-arm-20050325-2005-q1b:1.29
	gdb-csl-arm-20050325-2005-q1a:1.29
	csl-arm-20050325-branch:1.29.0.2
	csl-arm-20050325-branchpoint:1.29
	gdb-post-i18n-errorwarning-20050211:1.28
	gdb-pre-i18n-errorwarning-20050211:1.28
	gdb_6_3-20041109-release:1.28
	gdb_6_3-branch:1.28.0.2
	gdb_6_3-20041019-branchpoint:1.28
	drow_intercu-merge-20040921:1.28
	drow_intercu-merge-20040915:1.28
	jimb-gdb_6_2-e500-branch:1.26.0.6
	jimb-gdb_6_2-e500-branchpoint:1.26
	gdb_6_2-20040730-release:1.26
	gdb_6_2-branch:1.26.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.26
	gdb_6_1_1-20040616-release:1.25
	gdb_6_1-2004-04-05-release:1.25
	drow_intercu-merge-20040402:1.25
	drow_intercu-merge-20040327:1.25
	ezannoni_pie-20040323-branch:1.25.0.12
	ezannoni_pie-20040323-branchpoint:1.25
	cagney_tramp-20040321-mergepoint:1.25
	cagney_tramp-20040309-branch:1.25.0.10
	cagney_tramp-20040309-branchpoint:1.25
	gdb_6_1-branch:1.25.0.8
	gdb_6_1-2004-03-01-gmt-branchpoint:1.25
	drow_intercu-20040221-branch:1.25.0.6
	drow_intercu-20040221-branchpoint:1.25
	cagney_bfdfile-20040213-branch:1.25.0.4
	cagney_bfdfile-20040213-branchpoint:1.25
	drow-cplus-merge-20040208:1.25
	carlton_dictionary-20040126-merge:1.25
	cagney_bigcore-20040122-branch:1.25.0.2
	cagney_bigcore-20040122-branchpoint:1.25
	drow-cplus-merge-20040113:1.24
	drow-cplus-merge-20031224:1.24
	drow-cplus-merge-20031220:1.24
	carlton_dictionary-20031215-merge:1.24
	drow-cplus-merge-20031214:1.24
	carlton-dictionary-20031111-merge:1.24
	gdb_6_0-2003-10-04-release:1.21
	kettenis_sparc-20030918-branch:1.21.0.16
	kettenis_sparc-20030918-branchpoint:1.21
	carlton_dictionary-20030917-merge:1.21
	ezannoni_pie-20030916-branchpoint:1.21
	ezannoni_pie-20030916-branch:1.21.0.14
	cagney_x86i386-20030821-branch:1.21.0.12
	cagney_x86i386-20030821-branchpoint:1.21
	carlton_dictionary-20030805-merge:1.21
	carlton_dictionary-20030627-merge:1.21
	gdb_6_0-branch:1.21.0.10
	gdb_6_0-2003-06-23-branchpoint:1.21
	jimb-ppc64-linux-20030613-branch:1.21.0.8
	jimb-ppc64-linux-20030613-branchpoint:1.21
	cagney_convert-20030606-branch:1.21.0.6
	cagney_convert-20030606-branchpoint:1.21
	cagney_writestrings-20030508-branch:1.19.0.20
	cagney_writestrings-20030508-branchpoint:1.19
	jimb-ppc64-linux-20030528-branch:1.21.0.4
	jimb-ppc64-linux-20030528-branchpoint:1.21
	carlton_dictionary-20030523-merge:1.21
	cagney_fileio-20030521-branch:1.21.0.2
	cagney_fileio-20030521-branchpoint:1.21
	kettenis_i386newframe-20030517-mergepoint:1.20
	jimb-ppc64-linux-20030509-branch:1.19.0.18
	jimb-ppc64-linux-20030509-branchpoint:1.19
	kettenis_i386newframe-20030504-mergepoint:1.19
	carlton_dictionary-20030430-merge:1.19
	kettenis_i386newframe-20030419-branch:1.19.0.16
	kettenis_i386newframe-20030419-branchpoint:1.19
	carlton_dictionary-20030416-merge:1.19
	cagney_frameaddr-20030409-mergepoint:1.19
	kettenis_i386newframe-20030406-branch:1.19.0.14
	kettenis_i386newframe-20030406-branchpoint:1.19
	cagney_frameaddr-20030403-branchpoint:1.19
	cagney_frameaddr-20030403-branch:1.19.0.12
	cagney_framebase-20030330-mergepoint:1.19
	cagney_framebase-20030326-branch:1.19.0.10
	cagney_framebase-20030326-branchpoint:1.19
	cagney_lazyid-20030317-branch:1.19.0.8
	cagney_lazyid-20030317-branchpoint:1.19
	kettenis-i386newframe-20030316-mergepoint:1.19
	offbyone-20030313-branch:1.19.0.6
	offbyone-20030313-branchpoint:1.19
	kettenis-i386newframe-20030308-branch:1.19.0.4
	kettenis-i386newframe-20030308-branchpoint:1.19
	carlton_dictionary-20030305-merge:1.19
	cagney_offbyone-20030303-branch:1.19.0.2
	cagney_offbyone-20030303-branchpoint:1.19
	carlton_dictionary-20030207-merge:1.18
	interps-20030203-mergepoint:1.18
	interps-20030202-branch:1.18.0.2
	interps-20030202-branchpoint:1.18
	cagney-unwind-20030108-branch:1.17.0.2
	cagney-unwind-20030108-branchpoint:1.17
	carlton_dictionary-20021223-merge:1.17
	gdb_5_3-2002-12-12-release:1.12.2.1
	carlton_dictionary-20021115-merge:1.17
	kseitz_interps-20021105-merge:1.16
	kseitz_interps-20021103-merge:1.16
	drow-cplus-merge-20021020:1.16
	drow-cplus-merge-20021025:1.16
	carlton_dictionary-20021025-merge:1.16
	carlton_dictionary-20021011-merge:1.16
	drow-cplus-branch:1.15.0.4
	drow-cplus-branchpoint:1.15
	kseitz_interps-20020930-merge:1.15
	carlton_dictionary-20020927-merge:1.15
	carlton_dictionary-branch:1.15.0.2
	carlton_dictionary-20020920-branchpoint:1.15
	gdb_5_3-branch:1.12.0.2
	gdb_5_3-2002-09-04-branchpoint:1.12
	kseitz_interps-20020829-merge:1.11
	cagney_sysregs-20020825-branch:1.11.0.4
	cagney_sysregs-20020825-branchpoint:1.11
	readline_4_3-import-branch:1.11.0.2
	readline_4_3-import-branchpoint:1.11
	gdb_5_2_1-2002-07-23-release:1.7
	kseitz_interps-20020528-branch:1.10.0.2
	kseitz_interps-20020528-branchpoint:1.10
	cagney_regbuf-20020515-branch:1.9.0.4
	cagney_regbuf-20020515-branchpoint:1.9
	jimb-macro-020506-branch:1.9.0.2
	jimb-macro-020506-branchpoint:1.9
	gdb_5_2-2002-04-29-release:1.7
	gdb_5_2-branch:1.7.0.2
	gdb_5_2-2002-03-03-branchpoint:1.7
	gdb_5_1_1-2002-01-24-release:1.4
	gdb_5_1_0_1-2002-01-03-release:1.4
	cygnus_cvs_20020108_pre:1.7
	gdb_5_1_0_1-2002-01-03-branchpoint:1.4
	gdb_5_1_0_1-2002-01-03-branch:1.4.0.8
	gdb_5_1-2001-11-21-release:1.4
	gdb_s390-2001-09-26-branch:1.4.0.6
	gdb_s390-2001-09-26-branchpoint:1.4
	gdb_5_1-2001-07-29-branch:1.4.0.4
	gdb_5_1-2001-07-29-branchpoint:1.4
	dberlin-typesystem-branch:1.4.0.2
	dberlin-typesystem-branchpoint:1.4
	gdb-post-ptid_t-2001-05-03:1.4
	gdb-pre-ptid_t-2001-05-03:1.4
	insight-precleanup-2001-01-01:1.3
	gdb-post-protoization-2000-07-29:1.3
	gdb-pre-protoization-2000-07-29:1.3
	gdb-premipsmulti-2000-06-06-branch:1.3.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.3
	gdb-post-params-removal-2000-06-04:1.2
	gdb-pre-params-removal-2000-06-04:1.2
	gdb-post-params-removal-2000-05-28:1.2
	gdb-pre-params-removal-2000-05-28:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.4
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	insight-2000-02-04:1.1.1.1
	gdb-2000-02-04:1.1.1.1
	gdb-2000-02-02:1.1.1.1
	gdb-2000-02-01:1.1.1.1
	gdb-2000-01-31:1.1.1.1
	gdb-2000-01-26:1.1.1.1
	gdb-2000-01-24:1.1.1.1
	gdb-2000-01-17:1.1.1.1
	gdb-2000-01-10:1.1.1.1
	gdb-2000-01-05:1.1.1.1
	gdb-1999-12-21:1.1.1.1
	gdb-1999-12-13:1.1.1.1
	gdb-1999-12-07:1.1.1.1
	gdb-1999-12-06:1.1.1.1
	gdb-1999-11-16:1.1.1.1
	gdb-1999-11-08:1.1.1.1
	gdb-1999-11-01:1.1.1.1
	gdb-1999-10-25:1.1.1.1
	gdb-1999-10-18:1.1.1.1
	gdb-1999-10-11:1.1.1.1
	gdb-1999-10-04:1.1.1.1
	gdb-1999-09-28:1.1.1.1
	gdb-1999-09-21:1.1.1.1
	gdb-1999-09-13:1.1.1.1
	gdb-1999-09-08:1.1.1.1
	gdb-1999-08-30:1.1.1.1
	gdb-1999-08-23:1.1.1.1
	gdb-1999-08-16:1.1.1.1
	gdb-1999-08-09:1.1.1.1
	gdb-1999-08-02:1.1.1.1
	gdb-1999-07-26:1.1.1.1
	gdb-1999-07-19:1.1.1.1
	gdb-1999-07-12:1.1.1.1
	gdb-post-reformat-19990707:1.1.1.1
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.1
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.119
date	2013.10.02.00.46.06;	author kseitz;	state Exp;
branches;
next	1.118;

1.118
date	2013.08.05.15.51.02;	author tromey;	state Exp;
branches;
next	1.117;

1.117
date	2013.04.15.17.36.13;	author tromey;	state Exp;
branches;
next	1.116;

1.116
date	2013.03.25.17.28.03;	author tromey;	state Exp;
branches;
next	1.115;

1.115
date	2013.03.21.15.19.32;	author tromey;	state Exp;
branches;
next	1.114;

1.114
date	2013.03.21.15.01.55;	author tromey;	state Exp;
branches;
next	1.113;

1.113
date	2013.03.21.14.41.28;	author tromey;	state Exp;
branches;
next	1.112;

1.112
date	2013.02.12.20.27.36;	author tromey;	state Exp;
branches;
next	1.111;

1.111
date	2013.01.31.18.46.11;	author aristovski;	state Exp;
branches;
next	1.110;

1.110
date	2013.01.25.17.34.03;	author tromey;	state Exp;
branches;
next	1.109;

1.109
date	2013.01.01.06.32.40;	author brobecke;	state Exp;
branches;
next	1.108;

1.108
date	2012.12.14.21.19.09;	author tromey;	state Exp;
branches;
next	1.107;

1.107
date	2012.12.14.17.47.38;	author tromey;	state Exp;
branches;
next	1.106;

1.106
date	2012.12.07.20.09.08;	author tromey;	state Exp;
branches;
next	1.105;

1.105
date	2012.12.07.20.05.14;	author tromey;	state Exp;
branches;
next	1.104;

1.104
date	2012.12.03.19.59.13;	author tromey;	state Exp;
branches;
next	1.103;

1.103
date	2012.11.12.17.14.54;	author tromey;	state Exp;
branches;
next	1.102;

1.102
date	2012.07.27.19.22.17;	author tromey;	state Exp;
branches;
next	1.101;

1.101
date	2012.07.26.20.11.09;	author tromey;	state Exp;
branches;
next	1.100;

1.100
date	2012.07.19.15.38.16;	author tromey;	state Exp;
branches;
next	1.99;

1.99
date	2012.07.19.15.34.38;	author tromey;	state Exp;
branches;
next	1.98;

1.98
date	2012.07.19.15.33.24;	author tromey;	state Exp;
branches;
next	1.97;

1.97
date	2012.07.09.14.20.51;	author tromey;	state Exp;
branches;
next	1.96;

1.96
date	2012.07.06.14.48.47;	author tromey;	state Exp;
branches;
next	1.95;

1.95
date	2012.07.06.14.46.59;	author tromey;	state Exp;
branches;
next	1.94;

1.94
date	2012.07.06.14.44.21;	author tromey;	state Exp;
branches;
next	1.93;

1.93
date	2012.07.06.14.40.30;	author tromey;	state Exp;
branches;
next	1.92;

1.92
date	2012.06.19.19.49.41;	author tromey;	state Exp;
branches;
next	1.91;

1.91
date	2012.06.18.20.23.38;	author tromey;	state Exp;
branches;
next	1.90;

1.90
date	2012.06.13.16.10.07;	author jkratoch;	state Exp;
branches;
next	1.89;

1.89
date	2012.05.18.21.02.47;	author sergiodj;	state Exp;
branches;
next	1.88;

1.88
date	2012.04.09.17.07.43;	author kettenis;	state Exp;
branches;
next	1.87;

1.87
date	2012.01.11.10.34.20;	author hilfingr;	state Exp;
branches;
next	1.86;

1.86
date	2012.01.10.19.29.12;	author jkratoch;	state Exp;
branches;
next	1.85;

1.85
date	2012.01.04.08.16.59;	author brobecke;	state Exp;
branches;
next	1.84;

1.84
date	2011.10.11.15.24.10;	author jkratoch;	state Exp;
branches
	1.84.2.1;
next	1.83;

1.83
date	2011.10.09.19.41.16;	author jkratoch;	state Exp;
branches;
next	1.82;

1.82
date	2011.05.06.14.12.17;	author jkratoch;	state Exp;
branches;
next	1.81;

1.81
date	2011.03.18.13.51.41;	author muller;	state Exp;
branches;
next	1.80;

1.80
date	2011.01.01.15.32.58;	author brobecke;	state Exp;
branches;
next	1.79;

1.79
date	2010.11.05.14.31.26;	author kwerner;	state Exp;
branches;
next	1.78;

1.78
date	2010.09.13.20.41.04;	author swagiaal;	state Exp;
branches;
next	1.77;

1.77
date	2010.08.19.13.33.12;	author devans;	state Exp;
branches;
next	1.76;

1.76
date	2010.06.28.20.18.26;	author jkratoch;	state Exp;
branches
	1.76.2.1;
next	1.75;

1.75
date	2010.05.07.14.46.25;	author swagiaal;	state Exp;
branches;
next	1.74;

1.74
date	2010.05.06.00.08.44;	author msnyder;	state Exp;
branches;
next	1.73;

1.73
date	2010.03.15.17.26.46;	author tromey;	state Exp;
branches;
next	1.72;

1.72
date	2010.02.23.17.03.54;	author palves;	state Exp;
branches;
next	1.71;

1.71
date	2010.02.19.20.22.03;	author tromey;	state Exp;
branches;
next	1.70;

1.70
date	2010.02.10.18.57.21;	author tromey;	state Exp;
branches;
next	1.69;

1.69
date	2010.01.18.20.54.33;	author tromey;	state Exp;
branches;
next	1.68;

1.68
date	2010.01.11.17.58.15;	author jkratoch;	state Exp;
branches;
next	1.67;

1.67
date	2010.01.01.07.31.30;	author brobecke;	state Exp;
branches;
next	1.66;

1.66
date	2009.11.25.20.43.29;	author drow;	state Exp;
branches;
next	1.65;

1.65
date	2009.11.11.16.45.46;	author kseitz;	state Exp;
branches;
next	1.64;

1.64
date	2009.11.10.22.17.58;	author kseitz;	state Exp;
branches;
next	1.63;

1.63
date	2009.10.06.22.47.19;	author muller;	state Exp;
branches;
next	1.62;

1.62
date	2009.09.21.19.23.46;	author kseitz;	state Exp;
branches;
next	1.61;

1.61
date	2009.08.25.18.40.45;	author kseitz;	state Exp;
branches;
next	1.60;

1.60
date	2009.08.25.00.23.07;	author kseitz;	state Exp;
branches;
next	1.59;

1.59
date	2009.07.07.21.33.48;	author tromey;	state Exp;
branches;
next	1.58;

1.58
date	2009.07.02.17.25.53;	author uweigand;	state Exp;
branches;
next	1.57;

1.57
date	2009.06.17.18.46.25;	author uweigand;	state Exp;
branches;
next	1.56;

1.56
date	2009.06.05.17.18.37;	author tromey;	state Exp;
branches;
next	1.55;

1.55
date	2009.04.28.01.03.23;	author tromey;	state Exp;
branches;
next	1.54;

1.54
date	2009.03.20.23.04.29;	author tromey;	state Exp;
branches;
next	1.53;

1.53
date	2009.03.18.08.51.10;	author nathan;	state Exp;
branches;
next	1.52;

1.52
date	2009.01.03.05.57.51;	author brobecke;	state Exp;
branches;
next	1.51;

1.51
date	2008.12.22.14.21.00;	author tromey;	state Exp;
branches;
next	1.50;

1.50
date	2008.12.11.18.30.27;	author tromey;	state Exp;
branches;
next	1.49;

1.49
date	2008.10.22.16.38.08;	author tromey;	state Exp;
branches
	1.49.2.1;
next	1.48;

1.48
date	2008.09.11.14.09.37;	author uweigand;	state Exp;
branches;
next	1.47;

1.47
date	2008.09.11.14.08.33;	author uweigand;	state Exp;
branches;
next	1.46;

1.46
date	2008.06.25.15.49.20;	author jkratoch;	state Exp;
branches;
next	1.45;

1.45
date	2008.06.09.19.25.14;	author tromey;	state Exp;
branches;
next	1.44;

1.44
date	2008.06.06.20.58.08;	author tromey;	state Exp;
branches;
next	1.43;

1.43
date	2008.05.19.15.50.09;	author uweigand;	state Exp;
branches;
next	1.42;

1.42
date	2008.01.09.19.27.15;	author bauermann;	state Exp;
branches;
next	1.41;

1.41
date	2008.01.01.22.53.09;	author drow;	state Exp;
branches;
next	1.40;

1.40
date	2007.10.25.18.01.58;	author bauermann;	state Exp;
branches;
next	1.39;

1.39
date	2007.08.17.23.27.42;	author msnyder;	state Exp;
branches;
next	1.38;

1.38
date	2007.06.12.15.33.03;	author uweigand;	state Exp;
branches;
next	1.37;

1.37
date	2007.06.05.22.47.50;	author uweigand;	state Exp;
branches;
next	1.36;

1.36
date	2007.01.09.17.58.50;	author drow;	state Exp;
branches;
next	1.35;

1.35
date	2006.08.02.03.13.20;	author drow;	state Exp;
branches;
next	1.34;

1.34
date	2006.02.23.18.43.41;	author drow;	state Exp;
branches
	1.34.14.1;
next	1.33;

1.33
date	2006.02.14.19.05.40;	author aoliva;	state Exp;
branches;
next	1.32;

1.32
date	2006.02.14.18.45.14;	author aoliva;	state Exp;
branches;
next	1.31;

1.31
date	2005.12.17.22.33.59;	author eliz;	state Exp;
branches;
next	1.30;

1.30
date	2005.09.20.08.55.55;	author woodzltc;	state Exp;
branches;
next	1.29;

1.29
date	2005.03.08.14.35.17;	author nathan;	state Exp;
branches;
next	1.28;

1.28
date	2004.08.07.19.45.45;	author cagney;	state Exp;
branches;
next	1.27;

1.27
date	2004.07.28.15.49.03;	author cagney;	state Exp;
branches;
next	1.26;

1.26
date	2004.04.08.21.18.12;	author cagney;	state Exp;
branches;
next	1.25;

1.25
date	2004.01.14.16.54.40;	author carlton;	state Exp;
branches
	1.25.6.1;
next	1.24;

1.24
date	2003.11.06.22.54.00;	author cagney;	state Exp;
branches;
next	1.23;

1.23
date	2003.09.25.16.50.38;	author carlton;	state Exp;
branches;
next	1.22;

1.22
date	2003.09.25.16.39.38;	author carlton;	state Exp;
branches;
next	1.21;

1.21
date	2003.05.18.17.39.45;	author schwab;	state Exp;
branches;
next	1.20;

1.20
date	2003.05.14.17.43.16;	author ezannoni;	state Exp;
branches;
next	1.19;

1.19
date	2003.02.20.00.01.05;	author carlton;	state Exp;
branches
	1.19.16.1
	1.19.20.1;
next	1.18;

1.18
date	2003.01.31.23.22.07;	author cagney;	state Exp;
branches;
next	1.17;

1.17
date	2002.11.06.22.48.25;	author troth;	state Exp;
branches;
next	1.16;

1.16
date	2002.10.11.14.02.37;	author drow;	state Exp;
branches;
next	1.15;

1.15
date	2002.09.20.00.24.01;	author kevinb;	state Exp;
branches
	1.15.2.1
	1.15.4.1;
next	1.14;

1.14
date	2002.09.19.03.58.41;	author cagney;	state Exp;
branches;
next	1.13;

1.13
date	2002.09.19.01.34.51;	author msnyder;	state Exp;
branches;
next	1.12;

1.12
date	2002.09.03.02.45.56;	author thorpej;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2002.06.21.14.32.10;	author muller;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.17.17.57.48;	author jimb;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2002.04.24.22.26.32;	author msnyder;	state Exp;
branches
	1.9.2.1
	1.9.4.1;
next	1.8;

1.8
date	2002.04.23.02.06.54;	author hjl;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.15.01.55.59;	author msnyder;	state Exp;
branches;
next	1.6;

1.6
date	2001.09.27.21.16.43;	author msnyder;	state Exp;
branches;
next	1.5;

1.5
date	2001.09.27.21.14.48;	author msnyder;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.06.08.21.06;	author kevinb;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2000.06.05.20.49.53;	author dberlin;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.28.01.12.26;	author kevinb;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.33.58;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.84.2.1
date	2012.01.06.04.43.05;	author brobecke;	state Exp;
branches;
next	;

1.76.2.1
date	2010.08.19.15.50.00;	author devans;	state Exp;
branches;
next	;

1.49.2.1
date	2008.11.21.02.31.57;	author shebs;	state Exp;
branches;
next	;

1.34.14.1
date	2006.08.28.07.48.50;	author nickrob;	state Exp;
branches;
next	;

1.25.6.1
date	2004.09.16.17.00.54;	author drow;	state Exp;
branches;
next	;

1.19.16.1
date	2003.05.18.09.43.59;	author kettenis;	state Exp;
branches;
next	;

1.19.20.1
date	2003.06.03.20.54.33;	author cagney;	state Exp;
branches;
next	;

1.15.2.1
date	2002.10.11.22.22.53;	author carlton;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2002.10.18.23.42.57;	author carlton;	state Exp;
branches;
next	1.15.2.3;

1.15.2.3
date	2002.11.15.19.18.37;	author carlton;	state Exp;
branches;
next	1.15.2.4;

1.15.2.4
date	2002.11.23.00.42.54;	author carlton;	state Exp;
branches;
next	1.15.2.5;

1.15.2.5
date	2002.12.18.00.45.41;	author carlton;	state Exp;
branches;
next	1.15.2.6;

1.15.2.6
date	2003.01.21.01.02.29;	author carlton;	state Exp;
branches;
next	1.15.2.7;

1.15.2.7
date	2003.02.07.19.17.45;	author carlton;	state Exp;
branches;
next	1.15.2.8;

1.15.2.8
date	2003.03.06.00.56.24;	author carlton;	state Exp;
branches;
next	1.15.2.9;

1.15.2.9
date	2003.03.07.22.52.53;	author carlton;	state Exp;
branches;
next	1.15.2.10;

1.15.2.10
date	2003.05.08.01.10.52;	author carlton;	state Exp;
branches;
next	1.15.2.11;

1.15.2.11
date	2003.05.23.18.40.35;	author carlton;	state Exp;
branches;
next	1.15.2.12;

1.15.2.12
date	2003.09.20.00.32.31;	author carlton;	state Exp;
branches;
next	1.15.2.13;

1.15.2.13
date	2003.09.30.18.16.06;	author carlton;	state Exp;
branches;
next	1.15.2.14;

1.15.2.14
date	2003.11.11.23.50.38;	author carlton;	state Exp;
branches;
next	1.15.2.15;

1.15.2.15
date	2004.01.26.19.11.15;	author carlton;	state Exp;
branches;
next	;

1.15.4.1
date	2002.10.26.17.12.04;	author drow;	state Exp;
branches;
next	1.15.4.2;

1.15.4.2
date	2003.12.14.20.27.07;	author drow;	state Exp;
branches;
next	1.15.4.3;

1.15.4.3
date	2004.02.09.19.43.31;	author drow;	state Exp;
branches;
next	;

1.12.2.1
date	2002.11.06.22.55.32;	author troth;	state Exp;
branches;
next	;

1.10.2.1
date	2002.07.22.21.46.56;	author kseitz;	state Exp;
branches;
next	1.10.2.2;

1.10.2.2
date	2002.10.01.00.46.03;	author kseitz;	state Exp;
branches;
next	1.10.2.3;

1.10.2.3
date	2002.11.04.00.17.29;	author ezannoni;	state Exp;
branches;
next	;

1.9.2.1
date	2002.05.10.16.43.34;	author jimb;	state Exp;
branches;
next	;

1.9.4.1
date	2002.06.15.16.42.51;	author cagney;	state Exp;
branches;
next	1.9.4.2;

1.9.4.2
date	2002.06.21.16.46.51;	author cagney;	state Exp;
branches;
next	;

1.4.2.1
date	2001.07.06.19.16.57;	author dberlin;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.33.58;	author shebs;	state Exp;
branches;
next	;


desc
@@


1.119
log
@Constification of parse_linespec and fallout:
https://sourceware.org/ml/gdb-patches/2013-09/msg01017.html
https://sourceware.org/ml/gdb-patches/2013-09/msg01018.html
https://sourceware.org/ml/gdb-patches/2013-09/msg01019.html
https://sourceware.org/ml/gdb-patches/2013-09/msg01020.html
@
text
@/* YACC parser for C expressions, for GDB.
   Copyright (C) 1986-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/* Parse a C expression from text in a string,
   and return the result as a  struct expression  pointer.
   That structure contains arithmetic operations in reverse polish,
   with constants represented by operations that are followed by special data.
   See expression.h for the details of the format.
   What is important here is that it can be built up sequentially
   during the process of parsing; the lower levels of the tree always
   come first in the result.

   Note that malloc's and realloc's in this file are transformed to
   xmalloc and xrealloc respectively by the same sed command in the
   makefile that remaps any other malloc/realloc inserted by the parser
   generator.  Doing this with #defines and trying to control the interaction
   with include files (<malloc.h> and <stdlib.h> for example) just became
   too messy, particularly when such includes can be inserted at random
   times by the parser generator.  */
   
%{

#include "defs.h"
#include "gdb_string.h"
#include <ctype.h>
#include "expression.h"
#include "value.h"
#include "parser-defs.h"
#include "language.h"
#include "c-lang.h"
#include "bfd.h" /* Required by objfiles.h.  */
#include "symfile.h" /* Required by objfiles.h.  */
#include "objfiles.h" /* For have_full_symbols and have_partial_symbols */
#include "charset.h"
#include "block.h"
#include "cp-support.h"
#include "dfp.h"
#include "gdb_assert.h"
#include "macroscope.h"
#include "objc-lang.h"
#include "typeprint.h"
#include "cp-abi.h"

#define parse_type builtin_type (parse_gdbarch)

/* Remap normal yacc parser interface names (yyparse, yylex, yyerror, etc),
   as well as gratuitiously global symbol names, so we can have multiple
   yacc generated parsers in gdb.  Note that these are only the variables
   produced by yacc.  If other parser generators (bison, byacc, etc) produce
   additional global names that conflict at link time, then those parser
   generators need to be fixed instead of adding those names to this list. */

#define	yymaxdepth c_maxdepth
#define	yyparse	c_parse_internal
#define	yylex	c_lex
#define	yyerror	c_error
#define	yylval	c_lval
#define	yychar	c_char
#define	yydebug	c_debug
#define	yypact	c_pact	
#define	yyr1	c_r1			
#define	yyr2	c_r2			
#define	yydef	c_def		
#define	yychk	c_chk		
#define	yypgo	c_pgo		
#define	yyact	c_act		
#define	yyexca	c_exca
#define yyerrflag c_errflag
#define yynerrs	c_nerrs
#define	yyps	c_ps
#define	yypv	c_pv
#define	yys	c_s
#define	yy_yys	c_yys
#define	yystate	c_state
#define	yytmp	c_tmp
#define	yyv	c_v
#define	yy_yyv	c_yyv
#define	yyval	c_val
#define	yylloc	c_lloc
#define yyreds	c_reds		/* With YYDEBUG defined */
#define yytoks	c_toks		/* With YYDEBUG defined */
#define yyname	c_name		/* With YYDEBUG defined */
#define yyrule	c_rule		/* With YYDEBUG defined */
#define yylhs	c_yylhs
#define yylen	c_yylen
#define yydefred c_yydefred
#define yydgoto	c_yydgoto
#define yysindex c_yysindex
#define yyrindex c_yyrindex
#define yygindex c_yygindex
#define yytable	 c_yytable
#define yycheck	 c_yycheck
#define yyss	c_yyss
#define yysslim	c_yysslim
#define yyssp	c_yyssp
#define yystacksize c_yystacksize
#define yyvs	c_yyvs
#define yyvsp	c_yyvsp

#ifndef YYDEBUG
#define	YYDEBUG 1		/* Default to yydebug support */
#endif

#define YYFPRINTF parser_fprintf

int yyparse (void);

static int yylex (void);

void yyerror (char *);

%}

/* Although the yacc "value" of an expression is not used,
   since the result is stored in the structure being created,
   other node types do have values.  */

%union
  {
    LONGEST lval;
    struct {
      LONGEST val;
      struct type *type;
    } typed_val_int;
    struct {
      DOUBLEST dval;
      struct type *type;
    } typed_val_float;
    struct {
      gdb_byte val[16];
      struct type *type;
    } typed_val_decfloat;
    struct type *tval;
    struct stoken sval;
    struct typed_stoken tsval;
    struct ttype tsym;
    struct symtoken ssym;
    int voidval;
    struct block *bval;
    enum exp_opcode opcode;

    struct stoken_vector svec;
    VEC (type_ptr) *tvec;

    struct type_stack *type_stack;

    struct objc_class_str class;
  }

%{
/* YYSTYPE gets defined by %union */
static int parse_number (const char *, int, int, YYSTYPE *);
static struct stoken operator_stoken (const char *);
static void check_parameter_typelist (VEC (type_ptr) *);
static void write_destructor_name (struct stoken);

static void c_print_token (FILE *file, int type, YYSTYPE value);
#define YYPRINT(FILE, TYPE, VALUE) c_print_token (FILE, TYPE, VALUE)
%}

%type <voidval> exp exp1 type_exp start variable qualified_name lcurly
%type <lval> rcurly
%type <tval> type typebase
%type <tvec> nonempty_typelist func_mod parameter_typelist
/* %type <bval> block */

/* Fancy type parsing.  */
%type <tval> ptype
%type <lval> array_mod
%type <tval> conversion_type_id

%type <type_stack> ptr_operator_ts abs_decl direct_abs_decl

%token <typed_val_int> INT
%token <typed_val_float> FLOAT
%token <typed_val_decfloat> DECFLOAT

/* Both NAME and TYPENAME tokens represent symbols in the input,
   and both convey their data as strings.
   But a TYPENAME is a string that happens to be defined as a typedef
   or builtin type name (such as int or char)
   and a NAME is any other symbol.
   Contexts where this distinction is not important can use the
   nonterminal "name", which matches either NAME or TYPENAME.  */

%token <tsval> STRING
%token <sval> NSSTRING		/* ObjC Foundation "NSString" literal */
%token SELECTOR			/* ObjC "@@selector" pseudo-operator   */
%token <tsval> CHAR
%token <ssym> NAME /* BLOCKNAME defined below to give it higher precedence. */
%token <ssym> UNKNOWN_CPP_NAME
%token <voidval> COMPLETE
%token <tsym> TYPENAME
%token <class> CLASSNAME	/* ObjC Class name */
%type <sval> name
%type <svec> string_exp
%type <ssym> name_not_typename
%type <tsym> typename

 /* This is like a '[' token, but is only generated when parsing
    Objective C.  This lets us reuse the same parser without
    erroneously parsing ObjC-specific expressions in C.  */
%token OBJC_LBRAC

/* A NAME_OR_INT is a symbol which is not known in the symbol table,
   but which would parse as a valid number in the current input radix.
   E.g. "c" when input_radix==16.  Depending on the parse, it will be
   turned into a name or into a number.  */

%token <ssym> NAME_OR_INT 

%token OPERATOR
%token STRUCT CLASS UNION ENUM SIZEOF UNSIGNED COLONCOLON
%token TEMPLATE
%token ERROR
%token NEW DELETE
%type <sval> operator
%token REINTERPRET_CAST DYNAMIC_CAST STATIC_CAST CONST_CAST
%token ENTRY
%token TYPEOF
%token DECLTYPE
%token TYPEID

/* Special type cases, put in to allow the parser to distinguish different
   legal basetypes.  */
%token SIGNED_KEYWORD LONG SHORT INT_KEYWORD CONST_KEYWORD VOLATILE_KEYWORD DOUBLE_KEYWORD

%token <sval> VARIABLE

%token <opcode> ASSIGN_MODIFY

/* C++ */
%token TRUEKEYWORD
%token FALSEKEYWORD


%left ','
%left ABOVE_COMMA
%right '=' ASSIGN_MODIFY
%right '?'
%left OROR
%left ANDAND
%left '|'
%left '^'
%left '&'
%left EQUAL NOTEQUAL
%left '<' '>' LEQ GEQ
%left LSH RSH
%left '@@'
%left '+' '-'
%left '*' '/' '%'
%right UNARY INCREMENT DECREMENT
%right ARROW ARROW_STAR '.' DOT_STAR '[' OBJC_LBRAC '('
%token <ssym> BLOCKNAME 
%token <bval> FILENAME
%type <bval> block
%left COLONCOLON

%token DOTDOTDOT


%%

start   :	exp1
	|	type_exp
	;

type_exp:	type
			{ write_exp_elt_opcode(OP_TYPE);
			  write_exp_elt_type($1);
			  write_exp_elt_opcode(OP_TYPE);}
	|	TYPEOF '(' exp ')'
			{
			  write_exp_elt_opcode (OP_TYPEOF);
			}
	|	TYPEOF '(' type ')'
			{
			  write_exp_elt_opcode (OP_TYPE);
			  write_exp_elt_type ($3);
			  write_exp_elt_opcode (OP_TYPE);
			}
	|	DECLTYPE '(' exp ')'
			{
			  write_exp_elt_opcode (OP_DECLTYPE);
			}
	;

/* Expressions, including the comma operator.  */
exp1	:	exp
	|	exp1 ',' exp
			{ write_exp_elt_opcode (BINOP_COMMA); }
	;

/* Expressions, not including the comma operator.  */
exp	:	'*' exp    %prec UNARY
			{ write_exp_elt_opcode (UNOP_IND); }
	;

exp	:	'&' exp    %prec UNARY
			{ write_exp_elt_opcode (UNOP_ADDR); }
	;

exp	:	'-' exp    %prec UNARY
			{ write_exp_elt_opcode (UNOP_NEG); }
	;

exp	:	'+' exp    %prec UNARY
			{ write_exp_elt_opcode (UNOP_PLUS); }
	;

exp	:	'!' exp    %prec UNARY
			{ write_exp_elt_opcode (UNOP_LOGICAL_NOT); }
	;

exp	:	'~' exp    %prec UNARY
			{ write_exp_elt_opcode (UNOP_COMPLEMENT); }
	;

exp	:	INCREMENT exp    %prec UNARY
			{ write_exp_elt_opcode (UNOP_PREINCREMENT); }
	;

exp	:	DECREMENT exp    %prec UNARY
			{ write_exp_elt_opcode (UNOP_PREDECREMENT); }
	;

exp	:	exp INCREMENT    %prec UNARY
			{ write_exp_elt_opcode (UNOP_POSTINCREMENT); }
	;

exp	:	exp DECREMENT    %prec UNARY
			{ write_exp_elt_opcode (UNOP_POSTDECREMENT); }
	;

exp	:	TYPEID '(' exp ')' %prec UNARY
			{ write_exp_elt_opcode (OP_TYPEID); }
	;

exp	:	TYPEID '(' type_exp ')' %prec UNARY
			{ write_exp_elt_opcode (OP_TYPEID); }
	;

exp	:	SIZEOF exp       %prec UNARY
			{ write_exp_elt_opcode (UNOP_SIZEOF); }
	;

exp	:	exp ARROW name
			{ write_exp_elt_opcode (STRUCTOP_PTR);
			  write_exp_string ($3);
			  write_exp_elt_opcode (STRUCTOP_PTR); }
	;

exp	:	exp ARROW name COMPLETE
			{ mark_struct_expression ();
			  write_exp_elt_opcode (STRUCTOP_PTR);
			  write_exp_string ($3);
			  write_exp_elt_opcode (STRUCTOP_PTR); }
	;

exp	:	exp ARROW COMPLETE
			{ struct stoken s;
			  mark_struct_expression ();
			  write_exp_elt_opcode (STRUCTOP_PTR);
			  s.ptr = "";
			  s.length = 0;
			  write_exp_string (s);
			  write_exp_elt_opcode (STRUCTOP_PTR); }
	;

exp	:	exp ARROW '~' name
			{ write_exp_elt_opcode (STRUCTOP_PTR);
			  write_destructor_name ($4);
			  write_exp_elt_opcode (STRUCTOP_PTR); }
	;

exp	:	exp ARROW '~' name COMPLETE
			{ mark_struct_expression ();
			  write_exp_elt_opcode (STRUCTOP_PTR);
			  write_destructor_name ($4);
			  write_exp_elt_opcode (STRUCTOP_PTR); }
	;

exp	:	exp ARROW qualified_name
			{ /* exp->type::name becomes exp->*(&type::name) */
			  /* Note: this doesn't work if name is a
			     static member!  FIXME */
			  write_exp_elt_opcode (UNOP_ADDR);
			  write_exp_elt_opcode (STRUCTOP_MPTR); }
	;

exp	:	exp ARROW_STAR exp
			{ write_exp_elt_opcode (STRUCTOP_MPTR); }
	;

exp	:	exp '.' name
			{ write_exp_elt_opcode (STRUCTOP_STRUCT);
			  write_exp_string ($3);
			  write_exp_elt_opcode (STRUCTOP_STRUCT); }
	;

exp	:	exp '.' name COMPLETE
			{ mark_struct_expression ();
			  write_exp_elt_opcode (STRUCTOP_STRUCT);
			  write_exp_string ($3);
			  write_exp_elt_opcode (STRUCTOP_STRUCT); }
	;

exp	:	exp '.' COMPLETE
			{ struct stoken s;
			  mark_struct_expression ();
			  write_exp_elt_opcode (STRUCTOP_STRUCT);
			  s.ptr = "";
			  s.length = 0;
			  write_exp_string (s);
			  write_exp_elt_opcode (STRUCTOP_STRUCT); }
	;

exp	:	exp '.' '~' name
			{ write_exp_elt_opcode (STRUCTOP_STRUCT);
			  write_destructor_name ($4);
			  write_exp_elt_opcode (STRUCTOP_STRUCT); }
	;

exp	:	exp '.' '~' name COMPLETE
			{ mark_struct_expression ();
			  write_exp_elt_opcode (STRUCTOP_STRUCT);
			  write_destructor_name ($4);
			  write_exp_elt_opcode (STRUCTOP_STRUCT); }
	;

exp	:	exp '.' qualified_name
			{ /* exp.type::name becomes exp.*(&type::name) */
			  /* Note: this doesn't work if name is a
			     static member!  FIXME */
			  write_exp_elt_opcode (UNOP_ADDR);
			  write_exp_elt_opcode (STRUCTOP_MEMBER); }
	;

exp	:	exp DOT_STAR exp
			{ write_exp_elt_opcode (STRUCTOP_MEMBER); }
	;

exp	:	exp '[' exp1 ']'
			{ write_exp_elt_opcode (BINOP_SUBSCRIPT); }
	;

exp	:	exp OBJC_LBRAC exp1 ']'
			{ write_exp_elt_opcode (BINOP_SUBSCRIPT); }
	;

/*
 * The rules below parse ObjC message calls of the form:
 *	'[' target selector {':' argument}* ']'
 */

exp	: 	OBJC_LBRAC TYPENAME
			{
			  CORE_ADDR class;

			  class = lookup_objc_class (parse_gdbarch,
						     copy_name ($2.stoken));
			  if (class == 0)
			    error (_("%s is not an ObjC Class"),
				   copy_name ($2.stoken));
			  write_exp_elt_opcode (OP_LONG);
			  write_exp_elt_type (parse_type->builtin_int);
			  write_exp_elt_longcst ((LONGEST) class);
			  write_exp_elt_opcode (OP_LONG);
			  start_msglist();
			}
		msglist ']'
			{ write_exp_elt_opcode (OP_OBJC_MSGCALL);
			  end_msglist();
			  write_exp_elt_opcode (OP_OBJC_MSGCALL);
			}
	;

exp	:	OBJC_LBRAC CLASSNAME
			{
			  write_exp_elt_opcode (OP_LONG);
			  write_exp_elt_type (parse_type->builtin_int);
			  write_exp_elt_longcst ((LONGEST) $2.class);
			  write_exp_elt_opcode (OP_LONG);
			  start_msglist();
			}
		msglist ']'
			{ write_exp_elt_opcode (OP_OBJC_MSGCALL);
			  end_msglist();
			  write_exp_elt_opcode (OP_OBJC_MSGCALL);
			}
	;

exp	:	OBJC_LBRAC exp
			{ start_msglist(); }
		msglist ']'
			{ write_exp_elt_opcode (OP_OBJC_MSGCALL);
			  end_msglist();
			  write_exp_elt_opcode (OP_OBJC_MSGCALL);
			}
	;

msglist :	name
			{ add_msglist(&$1, 0); }
	|	msgarglist
	;

msgarglist :	msgarg
	|	msgarglist msgarg
	;

msgarg	:	name ':' exp
			{ add_msglist(&$1, 1); }
	|	':' exp	/* Unnamed arg.  */
			{ add_msglist(0, 1);   }
	|	',' exp	/* Variable number of args.  */
			{ add_msglist(0, 0);   }
	;

exp	:	exp '(' 
			/* This is to save the value of arglist_len
			   being accumulated by an outer function call.  */
			{ start_arglist (); }
		arglist ')'	%prec ARROW
			{ write_exp_elt_opcode (OP_FUNCALL);
			  write_exp_elt_longcst ((LONGEST) end_arglist ());
			  write_exp_elt_opcode (OP_FUNCALL); }
	;

exp	:	UNKNOWN_CPP_NAME '('
			{
			  /* This could potentially be a an argument defined
			     lookup function (Koenig).  */
			  write_exp_elt_opcode (OP_ADL_FUNC);
			  write_exp_elt_block (expression_context_block);
			  write_exp_elt_sym (NULL); /* Placeholder.  */
			  write_exp_string ($1.stoken);
			  write_exp_elt_opcode (OP_ADL_FUNC);

			/* This is to save the value of arglist_len
			   being accumulated by an outer function call.  */

			  start_arglist ();
			}
		arglist ')'	%prec ARROW
			{
			  write_exp_elt_opcode (OP_FUNCALL);
			  write_exp_elt_longcst ((LONGEST) end_arglist ());
			  write_exp_elt_opcode (OP_FUNCALL);
			}
	;

lcurly	:	'{'
			{ start_arglist (); }
	;

arglist	:
	;

arglist	:	exp
			{ arglist_len = 1; }
	;

arglist	:	arglist ',' exp   %prec ABOVE_COMMA
			{ arglist_len++; }
	;

exp     :       exp '(' parameter_typelist ')' const_or_volatile
			{ int i;
			  VEC (type_ptr) *type_list = $3;
			  struct type *type_elt;
			  LONGEST len = VEC_length (type_ptr, type_list);

			  write_exp_elt_opcode (TYPE_INSTANCE);
			  write_exp_elt_longcst (len);
			  for (i = 0;
			       VEC_iterate (type_ptr, type_list, i, type_elt);
			       ++i)
			    write_exp_elt_type (type_elt);
			  write_exp_elt_longcst(len);
			  write_exp_elt_opcode (TYPE_INSTANCE);
			  VEC_free (type_ptr, type_list);
			}
	;

rcurly	:	'}'
			{ $$ = end_arglist () - 1; }
	;
exp	:	lcurly arglist rcurly	%prec ARROW
			{ write_exp_elt_opcode (OP_ARRAY);
			  write_exp_elt_longcst ((LONGEST) 0);
			  write_exp_elt_longcst ((LONGEST) $3);
			  write_exp_elt_opcode (OP_ARRAY); }
	;

exp	:	lcurly type_exp rcurly exp  %prec UNARY
			{ write_exp_elt_opcode (UNOP_MEMVAL_TYPE); }
	;

exp	:	'(' type_exp ')' exp  %prec UNARY
			{ write_exp_elt_opcode (UNOP_CAST_TYPE); }
	;

exp	:	'(' exp1 ')'
			{ }
	;

/* Binary operators in order of decreasing precedence.  */

exp	:	exp '@@' exp
			{ write_exp_elt_opcode (BINOP_REPEAT); }
	;

exp	:	exp '*' exp
			{ write_exp_elt_opcode (BINOP_MUL); }
	;

exp	:	exp '/' exp
			{ write_exp_elt_opcode (BINOP_DIV); }
	;

exp	:	exp '%' exp
			{ write_exp_elt_opcode (BINOP_REM); }
	;

exp	:	exp '+' exp
			{ write_exp_elt_opcode (BINOP_ADD); }
	;

exp	:	exp '-' exp
			{ write_exp_elt_opcode (BINOP_SUB); }
	;

exp	:	exp LSH exp
			{ write_exp_elt_opcode (BINOP_LSH); }
	;

exp	:	exp RSH exp
			{ write_exp_elt_opcode (BINOP_RSH); }
	;

exp	:	exp EQUAL exp
			{ write_exp_elt_opcode (BINOP_EQUAL); }
	;

exp	:	exp NOTEQUAL exp
			{ write_exp_elt_opcode (BINOP_NOTEQUAL); }
	;

exp	:	exp LEQ exp
			{ write_exp_elt_opcode (BINOP_LEQ); }
	;

exp	:	exp GEQ exp
			{ write_exp_elt_opcode (BINOP_GEQ); }
	;

exp	:	exp '<' exp
			{ write_exp_elt_opcode (BINOP_LESS); }
	;

exp	:	exp '>' exp
			{ write_exp_elt_opcode (BINOP_GTR); }
	;

exp	:	exp '&' exp
			{ write_exp_elt_opcode (BINOP_BITWISE_AND); }
	;

exp	:	exp '^' exp
			{ write_exp_elt_opcode (BINOP_BITWISE_XOR); }
	;

exp	:	exp '|' exp
			{ write_exp_elt_opcode (BINOP_BITWISE_IOR); }
	;

exp	:	exp ANDAND exp
			{ write_exp_elt_opcode (BINOP_LOGICAL_AND); }
	;

exp	:	exp OROR exp
			{ write_exp_elt_opcode (BINOP_LOGICAL_OR); }
	;

exp	:	exp '?' exp ':' exp	%prec '?'
			{ write_exp_elt_opcode (TERNOP_COND); }
	;
			  
exp	:	exp '=' exp
			{ write_exp_elt_opcode (BINOP_ASSIGN); }
	;

exp	:	exp ASSIGN_MODIFY exp
			{ write_exp_elt_opcode (BINOP_ASSIGN_MODIFY);
			  write_exp_elt_opcode ($2);
			  write_exp_elt_opcode (BINOP_ASSIGN_MODIFY); }
	;

exp	:	INT
			{ write_exp_elt_opcode (OP_LONG);
			  write_exp_elt_type ($1.type);
			  write_exp_elt_longcst ((LONGEST)($1.val));
			  write_exp_elt_opcode (OP_LONG); }
	;

exp	:	CHAR
			{
			  struct stoken_vector vec;
			  vec.len = 1;
			  vec.tokens = &$1;
			  write_exp_string_vector ($1.type, &vec);
			}
	;

exp	:	NAME_OR_INT
			{ YYSTYPE val;
			  parse_number ($1.stoken.ptr, $1.stoken.length, 0, &val);
			  write_exp_elt_opcode (OP_LONG);
			  write_exp_elt_type (val.typed_val_int.type);
			  write_exp_elt_longcst ((LONGEST)val.typed_val_int.val);
			  write_exp_elt_opcode (OP_LONG);
			}
	;


exp	:	FLOAT
			{ write_exp_elt_opcode (OP_DOUBLE);
			  write_exp_elt_type ($1.type);
			  write_exp_elt_dblcst ($1.dval);
			  write_exp_elt_opcode (OP_DOUBLE); }
	;

exp	:	DECFLOAT
			{ write_exp_elt_opcode (OP_DECFLOAT);
			  write_exp_elt_type ($1.type);
			  write_exp_elt_decfloatcst ($1.val);
			  write_exp_elt_opcode (OP_DECFLOAT); }
	;

exp	:	variable
	;

exp	:	VARIABLE
			{
			  write_dollar_variable ($1);
			}
	;

exp	:	SELECTOR '(' name ')'
			{
			  write_exp_elt_opcode (OP_OBJC_SELECTOR);
			  write_exp_string ($3);
			  write_exp_elt_opcode (OP_OBJC_SELECTOR); }
	;

exp	:	SIZEOF '(' type ')'	%prec UNARY
			{ write_exp_elt_opcode (OP_LONG);
			  write_exp_elt_type (lookup_signed_typename
					      (parse_language, parse_gdbarch,
					       "int"));
			  CHECK_TYPEDEF ($3);
			  write_exp_elt_longcst ((LONGEST) TYPE_LENGTH ($3));
			  write_exp_elt_opcode (OP_LONG); }
	;

exp	:	REINTERPRET_CAST '<' type_exp '>' '(' exp ')' %prec UNARY
			{ write_exp_elt_opcode (UNOP_REINTERPRET_CAST); }
	;

exp	:	STATIC_CAST '<' type_exp '>' '(' exp ')' %prec UNARY
			{ write_exp_elt_opcode (UNOP_CAST_TYPE); }
	;

exp	:	DYNAMIC_CAST '<' type_exp '>' '(' exp ')' %prec UNARY
			{ write_exp_elt_opcode (UNOP_DYNAMIC_CAST); }
	;

exp	:	CONST_CAST '<' type_exp '>' '(' exp ')' %prec UNARY
			{ /* We could do more error checking here, but
			     it doesn't seem worthwhile.  */
			  write_exp_elt_opcode (UNOP_CAST_TYPE); }
	;

string_exp:
		STRING
			{
			  /* We copy the string here, and not in the
			     lexer, to guarantee that we do not leak a
			     string.  Note that we follow the
			     NUL-termination convention of the
			     lexer.  */
			  struct typed_stoken *vec = XNEW (struct typed_stoken);
			  $$.len = 1;
			  $$.tokens = vec;

			  vec->type = $1.type;
			  vec->length = $1.length;
			  vec->ptr = malloc ($1.length + 1);
			  memcpy (vec->ptr, $1.ptr, $1.length + 1);
			}

	|	string_exp STRING
			{
			  /* Note that we NUL-terminate here, but just
			     for convenience.  */
			  char *p;
			  ++$$.len;
			  $$.tokens = realloc ($$.tokens,
					       $$.len * sizeof (struct typed_stoken));

			  p = malloc ($2.length + 1);
			  memcpy (p, $2.ptr, $2.length + 1);

			  $$.tokens[$$.len - 1].type = $2.type;
			  $$.tokens[$$.len - 1].length = $2.length;
			  $$.tokens[$$.len - 1].ptr = p;
			}
		;

exp	:	string_exp
			{
			  int i;
			  enum c_string_type type = C_STRING;

			  for (i = 0; i < $1.len; ++i)
			    {
			      switch ($1.tokens[i].type)
				{
				case C_STRING:
				  break;
				case C_WIDE_STRING:
				case C_STRING_16:
				case C_STRING_32:
				  if (type != C_STRING
				      && type != $1.tokens[i].type)
				    error (_("Undefined string concatenation."));
				  type = $1.tokens[i].type;
				  break;
				default:
				  /* internal error */
				  internal_error (__FILE__, __LINE__,
						  "unrecognized type in string concatenation");
				}
			    }

			  write_exp_string_vector (type, &$1);
			  for (i = 0; i < $1.len; ++i)
			    free ($1.tokens[i].ptr);
			  free ($1.tokens);
			}
	;

exp     :	NSSTRING	/* ObjC NextStep NSString constant
				 * of the form '@@' '"' string '"'.
				 */
			{ write_exp_elt_opcode (OP_OBJC_NSSTRING);
			  write_exp_string ($1);
			  write_exp_elt_opcode (OP_OBJC_NSSTRING); }
	;

/* C++.  */
exp     :       TRUEKEYWORD    
                        { write_exp_elt_opcode (OP_LONG);
                          write_exp_elt_type (parse_type->builtin_bool);
                          write_exp_elt_longcst ((LONGEST) 1);
                          write_exp_elt_opcode (OP_LONG); }
	;

exp     :       FALSEKEYWORD   
                        { write_exp_elt_opcode (OP_LONG);
                          write_exp_elt_type (parse_type->builtin_bool);
                          write_exp_elt_longcst ((LONGEST) 0);
                          write_exp_elt_opcode (OP_LONG); }
	;

/* end of C++.  */

block	:	BLOCKNAME
			{
			  if ($1.sym)
			    $$ = SYMBOL_BLOCK_VALUE ($1.sym);
			  else
			    error (_("No file or function \"%s\"."),
				   copy_name ($1.stoken));
			}
	|	FILENAME
			{
			  $$ = $1;
			}
	;

block	:	block COLONCOLON name
			{ struct symbol *tem
			    = lookup_symbol (copy_name ($3), $1,
					     VAR_DOMAIN, NULL);
			  if (!tem || SYMBOL_CLASS (tem) != LOC_BLOCK)
			    error (_("No function \"%s\" in specified context."),
				   copy_name ($3));
			  $$ = SYMBOL_BLOCK_VALUE (tem); }
	;

variable:	name_not_typename ENTRY
			{ struct symbol *sym = $1.sym;

			  if (sym == NULL || !SYMBOL_IS_ARGUMENT (sym)
			      || !symbol_read_needs_frame (sym))
			    error (_("@@entry can be used only for function "
				     "parameters, not for \"%s\""),
				   copy_name ($1.stoken));

			  write_exp_elt_opcode (OP_VAR_ENTRY_VALUE);
			  write_exp_elt_sym (sym);
			  write_exp_elt_opcode (OP_VAR_ENTRY_VALUE);
			}
	;

variable:	block COLONCOLON name
			{ struct symbol *sym;
			  sym = lookup_symbol (copy_name ($3), $1,
					       VAR_DOMAIN, NULL);
			  if (sym == 0)
			    error (_("No symbol \"%s\" in specified context."),
				   copy_name ($3));
			  if (symbol_read_needs_frame (sym))
			    {
			      if (innermost_block == 0
				  || contained_in (block_found,
						   innermost_block))
				innermost_block = block_found;
			    }

			  write_exp_elt_opcode (OP_VAR_VALUE);
			  /* block_found is set by lookup_symbol.  */
			  write_exp_elt_block (block_found);
			  write_exp_elt_sym (sym);
			  write_exp_elt_opcode (OP_VAR_VALUE); }
	;

qualified_name:	TYPENAME COLONCOLON name
			{
			  struct type *type = $1.type;
			  CHECK_TYPEDEF (type);
			  if (TYPE_CODE (type) != TYPE_CODE_STRUCT
			      && TYPE_CODE (type) != TYPE_CODE_UNION
			      && TYPE_CODE (type) != TYPE_CODE_NAMESPACE)
			    error (_("`%s' is not defined as an aggregate type."),
				   TYPE_SAFE_NAME (type));

			  write_exp_elt_opcode (OP_SCOPE);
			  write_exp_elt_type (type);
			  write_exp_string ($3);
			  write_exp_elt_opcode (OP_SCOPE);
			}
	|	TYPENAME COLONCOLON '~' name
			{
			  struct type *type = $1.type;
			  struct stoken tmp_token;
			  char *buf;

			  CHECK_TYPEDEF (type);
			  if (TYPE_CODE (type) != TYPE_CODE_STRUCT
			      && TYPE_CODE (type) != TYPE_CODE_UNION
			      && TYPE_CODE (type) != TYPE_CODE_NAMESPACE)
			    error (_("`%s' is not defined as an aggregate type."),
				   TYPE_SAFE_NAME (type));
			  buf = alloca ($4.length + 2);
			  tmp_token.ptr = buf;
			  tmp_token.length = $4.length + 1;
			  buf[0] = '~';
			  memcpy (buf+1, $4.ptr, $4.length);
			  buf[tmp_token.length] = 0;

			  /* Check for valid destructor name.  */
			  destructor_name_p (tmp_token.ptr, $1.type);
			  write_exp_elt_opcode (OP_SCOPE);
			  write_exp_elt_type (type);
			  write_exp_string (tmp_token);
			  write_exp_elt_opcode (OP_SCOPE);
			}
	|	TYPENAME COLONCOLON name COLONCOLON name
			{
			  char *copy = copy_name ($3);
			  error (_("No type \"%s\" within class "
				   "or namespace \"%s\"."),
				 copy, TYPE_SAFE_NAME ($1.type));
			}
	;

variable:	qualified_name
	|	COLONCOLON name_not_typename
			{
			  char *name = copy_name ($2.stoken);
			  struct symbol *sym;
			  struct bound_minimal_symbol msymbol;

			  sym =
			    lookup_symbol (name, (const struct block *) NULL,
					   VAR_DOMAIN, NULL);
			  if (sym)
			    {
			      write_exp_elt_opcode (OP_VAR_VALUE);
			      write_exp_elt_block (NULL);
			      write_exp_elt_sym (sym);
			      write_exp_elt_opcode (OP_VAR_VALUE);
			      break;
			    }

			  msymbol = lookup_bound_minimal_symbol (name);
			  if (msymbol.minsym != NULL)
			    write_exp_msymbol (msymbol);
			  else if (!have_full_symbols () && !have_partial_symbols ())
			    error (_("No symbol table is loaded.  Use the \"file\" command."));
			  else
			    error (_("No symbol \"%s\" in current context."), name);
			}
	;

variable:	name_not_typename
			{ struct symbol *sym = $1.sym;

			  if (sym)
			    {
			      if (symbol_read_needs_frame (sym))
				{
				  if (innermost_block == 0
				      || contained_in (block_found, 
						       innermost_block))
				    innermost_block = block_found;
				}

			      write_exp_elt_opcode (OP_VAR_VALUE);
			      /* We want to use the selected frame, not
				 another more inner frame which happens to
				 be in the same block.  */
			      write_exp_elt_block (NULL);
			      write_exp_elt_sym (sym);
			      write_exp_elt_opcode (OP_VAR_VALUE);
			    }
			  else if ($1.is_a_field_of_this)
			    {
			      /* C++: it hangs off of `this'.  Must
			         not inadvertently convert from a method call
				 to data ref.  */
			      if (innermost_block == 0
				  || contained_in (block_found,
						   innermost_block))
				innermost_block = block_found;
			      write_exp_elt_opcode (OP_THIS);
			      write_exp_elt_opcode (OP_THIS);
			      write_exp_elt_opcode (STRUCTOP_PTR);
			      write_exp_string ($1.stoken);
			      write_exp_elt_opcode (STRUCTOP_PTR);
			    }
			  else
			    {
			      struct bound_minimal_symbol msymbol;
			      char *arg = copy_name ($1.stoken);

			      msymbol =
				lookup_bound_minimal_symbol (arg);
			      if (msymbol.minsym != NULL)
				write_exp_msymbol (msymbol);
			      else if (!have_full_symbols () && !have_partial_symbols ())
				error (_("No symbol table is loaded.  Use the \"file\" command."));
			      else
				error (_("No symbol \"%s\" in current context."),
				       copy_name ($1.stoken));
			    }
			}
	;

space_identifier : '@@' NAME
		{ insert_type_address_space (copy_name ($2.stoken)); }
	;

const_or_volatile: const_or_volatile_noopt
	|
	;

cv_with_space_id : const_or_volatile space_identifier const_or_volatile
	;

const_or_volatile_or_space_identifier_noopt: cv_with_space_id
	| const_or_volatile_noopt 
	;

const_or_volatile_or_space_identifier: 
		const_or_volatile_or_space_identifier_noopt
	|
	;

ptr_operator:
		ptr_operator '*'
			{ insert_type (tp_pointer); }
		const_or_volatile_or_space_identifier
	|	'*' 
			{ insert_type (tp_pointer); }
		const_or_volatile_or_space_identifier
	|	'&'
			{ insert_type (tp_reference); }
	|	'&' ptr_operator
			{ insert_type (tp_reference); }
	;

ptr_operator_ts: ptr_operator
			{
			  $$ = get_type_stack ();
			  /* This cleanup is eventually run by
			     c_parse.  */
			  make_cleanup (type_stack_cleanup, $$);
			}
	;

abs_decl:	ptr_operator_ts direct_abs_decl
			{ $$ = append_type_stack ($2, $1); }
	|	ptr_operator_ts 
	|	direct_abs_decl
	;

direct_abs_decl: '(' abs_decl ')'
			{ $$ = $2; }
	|	direct_abs_decl array_mod
			{
			  push_type_stack ($1);
			  push_type_int ($2);
			  push_type (tp_array);
			  $$ = get_type_stack ();
			}
	|	array_mod
			{
			  push_type_int ($1);
			  push_type (tp_array);
			  $$ = get_type_stack ();
			}

	| 	direct_abs_decl func_mod
			{
			  push_type_stack ($1);
			  push_typelist ($2);
			  $$ = get_type_stack ();
			}
	|	func_mod
			{
			  push_typelist ($1);
			  $$ = get_type_stack ();
			}
	;

array_mod:	'[' ']'
			{ $$ = -1; }
	|	OBJC_LBRAC ']'
			{ $$ = -1; }
	|	'[' INT ']'
			{ $$ = $2.val; }
	|	OBJC_LBRAC INT ']'
			{ $$ = $2.val; }
	;

func_mod:	'(' ')'
			{ $$ = NULL; }
	|	'(' parameter_typelist ')'
			{ $$ = $2; }
	;

/* We used to try to recognize pointer to member types here, but
   that didn't work (shift/reduce conflicts meant that these rules never
   got executed).  The problem is that
     int (foo::bar::baz::bizzle)
   is a function type but
     int (foo::bar::baz::bizzle::*)
   is a pointer to member type.  Stroustrup loses again!  */

type	:	ptype
	;

typebase  /* Implements (approximately): (type-qualifier)* type-specifier */
	:	TYPENAME
			{ $$ = $1.type; }
	|	INT_KEYWORD
			{ $$ = lookup_signed_typename (parse_language,
						       parse_gdbarch,
						       "int"); }
	|	LONG
			{ $$ = lookup_signed_typename (parse_language,
						       parse_gdbarch,
						       "long"); }
	|	SHORT
			{ $$ = lookup_signed_typename (parse_language,
						       parse_gdbarch,
						       "short"); }
	|	LONG INT_KEYWORD
			{ $$ = lookup_signed_typename (parse_language,
						       parse_gdbarch,
						       "long"); }
	|	LONG SIGNED_KEYWORD INT_KEYWORD
			{ $$ = lookup_signed_typename (parse_language,
						       parse_gdbarch,
						       "long"); }
	|	LONG SIGNED_KEYWORD
			{ $$ = lookup_signed_typename (parse_language,
						       parse_gdbarch,
						       "long"); }
	|	SIGNED_KEYWORD LONG INT_KEYWORD
			{ $$ = lookup_signed_typename (parse_language,
						       parse_gdbarch,
						       "long"); }
	|	UNSIGNED LONG INT_KEYWORD
			{ $$ = lookup_unsigned_typename (parse_language,
							 parse_gdbarch,
							 "long"); }
	|	LONG UNSIGNED INT_KEYWORD
			{ $$ = lookup_unsigned_typename (parse_language,
							 parse_gdbarch,
							 "long"); }
	|	LONG UNSIGNED
			{ $$ = lookup_unsigned_typename (parse_language,
							 parse_gdbarch,
							 "long"); }
	|	LONG LONG
			{ $$ = lookup_signed_typename (parse_language,
						       parse_gdbarch,
						       "long long"); }
	|	LONG LONG INT_KEYWORD
			{ $$ = lookup_signed_typename (parse_language,
						       parse_gdbarch,
						       "long long"); }
	|	LONG LONG SIGNED_KEYWORD INT_KEYWORD
			{ $$ = lookup_signed_typename (parse_language,
						       parse_gdbarch,
						       "long long"); }
	|	LONG LONG SIGNED_KEYWORD
			{ $$ = lookup_signed_typename (parse_language,
						       parse_gdbarch,
						       "long long"); }
	|	SIGNED_KEYWORD LONG LONG
			{ $$ = lookup_signed_typename (parse_language,
						       parse_gdbarch,
						       "long long"); }
	|	SIGNED_KEYWORD LONG LONG INT_KEYWORD
			{ $$ = lookup_signed_typename (parse_language,
						       parse_gdbarch,
						       "long long"); }
	|	UNSIGNED LONG LONG
			{ $$ = lookup_unsigned_typename (parse_language,
							 parse_gdbarch,
							 "long long"); }
	|	UNSIGNED LONG LONG INT_KEYWORD
			{ $$ = lookup_unsigned_typename (parse_language,
							 parse_gdbarch,
							 "long long"); }
	|	LONG LONG UNSIGNED
			{ $$ = lookup_unsigned_typename (parse_language,
							 parse_gdbarch,
							 "long long"); }
	|	LONG LONG UNSIGNED INT_KEYWORD
			{ $$ = lookup_unsigned_typename (parse_language,
							 parse_gdbarch,
							 "long long"); }
	|	SHORT INT_KEYWORD
			{ $$ = lookup_signed_typename (parse_language,
						       parse_gdbarch,
						       "short"); }
	|	SHORT SIGNED_KEYWORD INT_KEYWORD
			{ $$ = lookup_signed_typename (parse_language,
						       parse_gdbarch,
						       "short"); }
	|	SHORT SIGNED_KEYWORD
			{ $$ = lookup_signed_typename (parse_language,
						       parse_gdbarch,
						       "short"); }
	|	UNSIGNED SHORT INT_KEYWORD
			{ $$ = lookup_unsigned_typename (parse_language,
							 parse_gdbarch,
							 "short"); }
	|	SHORT UNSIGNED 
			{ $$ = lookup_unsigned_typename (parse_language,
							 parse_gdbarch,
							 "short"); }
	|	SHORT UNSIGNED INT_KEYWORD
			{ $$ = lookup_unsigned_typename (parse_language,
							 parse_gdbarch,
							 "short"); }
	|	DOUBLE_KEYWORD
			{ $$ = lookup_typename (parse_language, parse_gdbarch,
						"double", (struct block *) NULL,
						0); }
	|	LONG DOUBLE_KEYWORD
			{ $$ = lookup_typename (parse_language, parse_gdbarch,
						"long double",
						(struct block *) NULL, 0); }
	|	STRUCT name
			{ $$ = lookup_struct (copy_name ($2),
					      expression_context_block); }
	|	STRUCT COMPLETE
			{
			  mark_completion_tag (TYPE_CODE_STRUCT, "", 0);
			  $$ = NULL;
			}
	|	STRUCT name COMPLETE
			{
			  mark_completion_tag (TYPE_CODE_STRUCT, $2.ptr,
					       $2.length);
			  $$ = NULL;
			}
	|	CLASS name
			{ $$ = lookup_struct (copy_name ($2),
					      expression_context_block); }
	|	CLASS COMPLETE
			{
			  mark_completion_tag (TYPE_CODE_CLASS, "", 0);
			  $$ = NULL;
			}
	|	CLASS name COMPLETE
			{
			  mark_completion_tag (TYPE_CODE_CLASS, $2.ptr,
					       $2.length);
			  $$ = NULL;
			}
	|	UNION name
			{ $$ = lookup_union (copy_name ($2),
					     expression_context_block); }
	|	UNION COMPLETE
			{
			  mark_completion_tag (TYPE_CODE_UNION, "", 0);
			  $$ = NULL;
			}
	|	UNION name COMPLETE
			{
			  mark_completion_tag (TYPE_CODE_UNION, $2.ptr,
					       $2.length);
			  $$ = NULL;
			}
	|	ENUM name
			{ $$ = lookup_enum (copy_name ($2),
					    expression_context_block); }
	|	ENUM COMPLETE
			{
			  mark_completion_tag (TYPE_CODE_ENUM, "", 0);
			  $$ = NULL;
			}
	|	ENUM name COMPLETE
			{
			  mark_completion_tag (TYPE_CODE_ENUM, $2.ptr,
					       $2.length);
			  $$ = NULL;
			}
	|	UNSIGNED typename
			{ $$ = lookup_unsigned_typename (parse_language,
							 parse_gdbarch,
							 TYPE_NAME($2.type)); }
	|	UNSIGNED
			{ $$ = lookup_unsigned_typename (parse_language,
							 parse_gdbarch,
							 "int"); }
	|	SIGNED_KEYWORD typename
			{ $$ = lookup_signed_typename (parse_language,
						       parse_gdbarch,
						       TYPE_NAME($2.type)); }
	|	SIGNED_KEYWORD
			{ $$ = lookup_signed_typename (parse_language,
						       parse_gdbarch,
						       "int"); }
                /* It appears that this rule for templates is never
                   reduced; template recognition happens by lookahead
                   in the token processing code in yylex. */         
	|	TEMPLATE name '<' type '>'
			{ $$ = lookup_template_type(copy_name($2), $4,
						    expression_context_block);
			}
	| const_or_volatile_or_space_identifier_noopt typebase 
			{ $$ = follow_types ($2); }
	| typebase const_or_volatile_or_space_identifier_noopt 
			{ $$ = follow_types ($1); }
	;

typename:	TYPENAME
	|	INT_KEYWORD
		{
		  $$.stoken.ptr = "int";
		  $$.stoken.length = 3;
		  $$.type = lookup_signed_typename (parse_language,
						    parse_gdbarch,
						    "int");
		}
	|	LONG
		{
		  $$.stoken.ptr = "long";
		  $$.stoken.length = 4;
		  $$.type = lookup_signed_typename (parse_language,
						    parse_gdbarch,
						    "long");
		}
	|	SHORT
		{
		  $$.stoken.ptr = "short";
		  $$.stoken.length = 5;
		  $$.type = lookup_signed_typename (parse_language,
						    parse_gdbarch,
						    "short");
		}
	;

parameter_typelist:
		nonempty_typelist
			{ check_parameter_typelist ($1); }
	|	nonempty_typelist ',' DOTDOTDOT
			{
			  VEC_safe_push (type_ptr, $1, NULL);
			  check_parameter_typelist ($1);
			  $$ = $1;
			}
	;

nonempty_typelist
	:	type
		{
		  VEC (type_ptr) *typelist = NULL;
		  VEC_safe_push (type_ptr, typelist, $1);
		  $$ = typelist;
		}
	|	nonempty_typelist ',' type
		{
		  VEC_safe_push (type_ptr, $1, $3);
		  $$ = $1;
		}
	;

ptype	:	typebase
	|	ptype abs_decl
		{
		  push_type_stack ($2);
		  $$ = follow_types ($1);
		}
	;

conversion_type_id: typebase conversion_declarator
		{ $$ = follow_types ($1); }
	;

conversion_declarator:  /* Nothing.  */
	| ptr_operator conversion_declarator
	;

const_and_volatile: 	CONST_KEYWORD VOLATILE_KEYWORD
	| 		VOLATILE_KEYWORD CONST_KEYWORD
	;

const_or_volatile_noopt:  	const_and_volatile 
			{ insert_type (tp_const);
			  insert_type (tp_volatile); 
			}
	| 		CONST_KEYWORD
			{ insert_type (tp_const); }
	| 		VOLATILE_KEYWORD
			{ insert_type (tp_volatile); }
	;

operator:	OPERATOR NEW
			{ $$ = operator_stoken (" new"); }
	|	OPERATOR DELETE
			{ $$ = operator_stoken (" delete"); }
	|	OPERATOR NEW '[' ']'
			{ $$ = operator_stoken (" new[]"); }
	|	OPERATOR DELETE '[' ']'
			{ $$ = operator_stoken (" delete[]"); }
	|	OPERATOR NEW OBJC_LBRAC ']'
			{ $$ = operator_stoken (" new[]"); }
	|	OPERATOR DELETE OBJC_LBRAC ']'
			{ $$ = operator_stoken (" delete[]"); }
	|	OPERATOR '+'
			{ $$ = operator_stoken ("+"); }
	|	OPERATOR '-'
			{ $$ = operator_stoken ("-"); }
	|	OPERATOR '*'
			{ $$ = operator_stoken ("*"); }
	|	OPERATOR '/'
			{ $$ = operator_stoken ("/"); }
	|	OPERATOR '%'
			{ $$ = operator_stoken ("%"); }
	|	OPERATOR '^'
			{ $$ = operator_stoken ("^"); }
	|	OPERATOR '&'
			{ $$ = operator_stoken ("&"); }
	|	OPERATOR '|'
			{ $$ = operator_stoken ("|"); }
	|	OPERATOR '~'
			{ $$ = operator_stoken ("~"); }
	|	OPERATOR '!'
			{ $$ = operator_stoken ("!"); }
	|	OPERATOR '='
			{ $$ = operator_stoken ("="); }
	|	OPERATOR '<'
			{ $$ = operator_stoken ("<"); }
	|	OPERATOR '>'
			{ $$ = operator_stoken (">"); }
	|	OPERATOR ASSIGN_MODIFY
			{ const char *op = "unknown";
			  switch ($2)
			    {
			    case BINOP_RSH:
			      op = ">>=";
			      break;
			    case BINOP_LSH:
			      op = "<<=";
			      break;
			    case BINOP_ADD:
			      op = "+=";
			      break;
			    case BINOP_SUB:
			      op = "-=";
			      break;
			    case BINOP_MUL:
			      op = "*=";
			      break;
			    case BINOP_DIV:
			      op = "/=";
			      break;
			    case BINOP_REM:
			      op = "%=";
			      break;
			    case BINOP_BITWISE_IOR:
			      op = "|=";
			      break;
			    case BINOP_BITWISE_AND:
			      op = "&=";
			      break;
			    case BINOP_BITWISE_XOR:
			      op = "^=";
			      break;
			    default:
			      break;
			    }

			  $$ = operator_stoken (op);
			}
	|	OPERATOR LSH
			{ $$ = operator_stoken ("<<"); }
	|	OPERATOR RSH
			{ $$ = operator_stoken (">>"); }
	|	OPERATOR EQUAL
			{ $$ = operator_stoken ("=="); }
	|	OPERATOR NOTEQUAL
			{ $$ = operator_stoken ("!="); }
	|	OPERATOR LEQ
			{ $$ = operator_stoken ("<="); }
	|	OPERATOR GEQ
			{ $$ = operator_stoken (">="); }
	|	OPERATOR ANDAND
			{ $$ = operator_stoken ("&&"); }
	|	OPERATOR OROR
			{ $$ = operator_stoken ("||"); }
	|	OPERATOR INCREMENT
			{ $$ = operator_stoken ("++"); }
	|	OPERATOR DECREMENT
			{ $$ = operator_stoken ("--"); }
	|	OPERATOR ','
			{ $$ = operator_stoken (","); }
	|	OPERATOR ARROW_STAR
			{ $$ = operator_stoken ("->*"); }
	|	OPERATOR ARROW
			{ $$ = operator_stoken ("->"); }
	|	OPERATOR '(' ')'
			{ $$ = operator_stoken ("()"); }
	|	OPERATOR '[' ']'
			{ $$ = operator_stoken ("[]"); }
	|	OPERATOR OBJC_LBRAC ']'
			{ $$ = operator_stoken ("[]"); }
	|	OPERATOR conversion_type_id
			{ char *name;
			  long length;
			  struct ui_file *buf = mem_fileopen ();

			  c_print_type ($2, NULL, buf, -1, 0,
					&type_print_raw_options);
			  name = ui_file_xstrdup (buf, &length);
			  ui_file_delete (buf);
			  $$ = operator_stoken (name);
			  free (name);
			}
	;



name	:	NAME { $$ = $1.stoken; }
	|	BLOCKNAME { $$ = $1.stoken; }
	|	TYPENAME { $$ = $1.stoken; }
	|	NAME_OR_INT  { $$ = $1.stoken; }
	|	UNKNOWN_CPP_NAME  { $$ = $1.stoken; }
	|	operator { $$ = $1; }
	;

name_not_typename :	NAME
	|	BLOCKNAME
/* These would be useful if name_not_typename was useful, but it is just
   a fake for "variable", so these cause reduce/reduce conflicts because
   the parser can't tell whether NAME_OR_INT is a name_not_typename (=variable,
   =exp) or just an exp.  If name_not_typename was ever used in an lvalue
   context where only a name could occur, this might be useful.
  	|	NAME_OR_INT
 */
	|	operator
			{
			  struct field_of_this_result is_a_field_of_this;

			  $$.stoken = $1;
			  $$.sym = lookup_symbol ($1.ptr,
						  expression_context_block,
						  VAR_DOMAIN,
						  &is_a_field_of_this);
			  $$.is_a_field_of_this
			    = is_a_field_of_this.type != NULL;
			}
	|	UNKNOWN_CPP_NAME
	;

%%

/* Like write_exp_string, but prepends a '~'.  */

static void
write_destructor_name (struct stoken token)
{
  char *copy = alloca (token.length + 1);

  copy[0] = '~';
  memcpy (&copy[1], token.ptr, token.length);

  token.ptr = copy;
  ++token.length;

  write_exp_string (token);
}

/* Returns a stoken of the operator name given by OP (which does not
   include the string "operator").  */ 
static struct stoken
operator_stoken (const char *op)
{
  static const char *operator_string = "operator";
  struct stoken st = { NULL, 0 };
  char *buf;

  st.length = strlen (operator_string) + strlen (op);
  buf = malloc (st.length + 1);
  strcpy (buf, operator_string);
  strcat (buf, op);
  st.ptr = buf;

  /* The toplevel (c_parse) will free the memory allocated here.  */
  make_cleanup (free, buf);
  return st;
};

/* Validate a parameter typelist.  */

static void
check_parameter_typelist (VEC (type_ptr) *params)
{
  struct type *type;
  int ix;

  for (ix = 0; VEC_iterate (type_ptr, params, ix, type); ++ix)
    {
      if (type != NULL && TYPE_CODE (check_typedef (type)) == TYPE_CODE_VOID)
	{
	  if (ix == 0)
	    {
	      if (VEC_length (type_ptr, params) == 1)
		{
		  /* Ok.  */
		  break;
		}
	      VEC_free (type_ptr, params);
	      error (_("parameter types following 'void'"));
	    }
	  else
	    {
	      VEC_free (type_ptr, params);
	      error (_("'void' invalid as parameter type"));
	    }
	}
    }
}

/* Take care of parsing a number (anything that starts with a digit).
   Set yylval and return the token type; update lexptr.
   LEN is the number of characters in it.  */

/*** Needs some error checking for the float case ***/

static int
parse_number (const char *buf, int len, int parsed_float, YYSTYPE *putithere)
{
  /* FIXME: Shouldn't these be unsigned?  We don't deal with negative values
     here, and we do kind of silly things like cast to unsigned.  */
  LONGEST n = 0;
  LONGEST prevn = 0;
  ULONGEST un;

  int i = 0;
  int c;
  int base = input_radix;
  int unsigned_p = 0;

  /* Number of "L" suffixes encountered.  */
  int long_p = 0;

  /* We have found a "L" or "U" suffix.  */
  int found_suffix = 0;

  ULONGEST high_bit;
  struct type *signed_type;
  struct type *unsigned_type;
  char *p;

  p = alloca (len);
  memcpy (p, buf, len);

  if (parsed_float)
    {
      /* If it ends at "df", "dd" or "dl", take it as type of decimal floating
         point.  Return DECFLOAT.  */

      if (len >= 2 && p[len - 2] == 'd' && p[len - 1] == 'f')
	{
	  p[len - 2] = '\0';
	  putithere->typed_val_decfloat.type
	    = parse_type->builtin_decfloat;
	  decimal_from_string (putithere->typed_val_decfloat.val, 4,
			       gdbarch_byte_order (parse_gdbarch), p);
	  p[len - 2] = 'd';
	  return DECFLOAT;
	}

      if (len >= 2 && p[len - 2] == 'd' && p[len - 1] == 'd')
	{
	  p[len - 2] = '\0';
	  putithere->typed_val_decfloat.type
	    = parse_type->builtin_decdouble;
	  decimal_from_string (putithere->typed_val_decfloat.val, 8,
			       gdbarch_byte_order (parse_gdbarch), p);
	  p[len - 2] = 'd';
	  return DECFLOAT;
	}

      if (len >= 2 && p[len - 2] == 'd' && p[len - 1] == 'l')
	{
	  p[len - 2] = '\0';
	  putithere->typed_val_decfloat.type
	    = parse_type->builtin_declong;
	  decimal_from_string (putithere->typed_val_decfloat.val, 16,
			       gdbarch_byte_order (parse_gdbarch), p);
	  p[len - 2] = 'd';
	  return DECFLOAT;
	}

      if (! parse_c_float (parse_gdbarch, p, len,
			   &putithere->typed_val_float.dval,
			   &putithere->typed_val_float.type))
	return ERROR;
      return FLOAT;
    }

  /* Handle base-switching prefixes 0x, 0t, 0d, 0 */
  if (p[0] == '0')
    switch (p[1])
      {
      case 'x':
      case 'X':
	if (len >= 3)
	  {
	    p += 2;
	    base = 16;
	    len -= 2;
	  }
	break;

      case 'b':
      case 'B':
	if (len >= 3)
	  {
	    p += 2;
	    base = 2;
	    len -= 2;
	  }
	break;

      case 't':
      case 'T':
      case 'd':
      case 'D':
	if (len >= 3)
	  {
	    p += 2;
	    base = 10;
	    len -= 2;
	  }
	break;

      default:
	base = 8;
	break;
      }

  while (len-- > 0)
    {
      c = *p++;
      if (c >= 'A' && c <= 'Z')
	c += 'a' - 'A';
      if (c != 'l' && c != 'u')
	n *= base;
      if (c >= '0' && c <= '9')
	{
	  if (found_suffix)
	    return ERROR;
	  n += i = c - '0';
	}
      else
	{
	  if (base > 10 && c >= 'a' && c <= 'f')
	    {
	      if (found_suffix)
		return ERROR;
	      n += i = c - 'a' + 10;
	    }
	  else if (c == 'l')
	    {
	      ++long_p;
	      found_suffix = 1;
	    }
	  else if (c == 'u')
	    {
	      unsigned_p = 1;
	      found_suffix = 1;
	    }
	  else
	    return ERROR;	/* Char not a digit */
	}
      if (i >= base)
	return ERROR;		/* Invalid digit in this base */

      /* Portably test for overflow (only works for nonzero values, so make
	 a second check for zero).  FIXME: Can't we just make n and prevn
	 unsigned and avoid this?  */
      if (c != 'l' && c != 'u' && (prevn >= n) && n != 0)
	unsigned_p = 1;		/* Try something unsigned */

      /* Portably test for unsigned overflow.
	 FIXME: This check is wrong; for example it doesn't find overflow
	 on 0x123456789 when LONGEST is 32 bits.  */
      if (c != 'l' && c != 'u' && n != 0)
	{	
	  if ((unsigned_p && (ULONGEST) prevn >= (ULONGEST) n))
	    error (_("Numeric constant too large."));
	}
      prevn = n;
    }

  /* An integer constant is an int, a long, or a long long.  An L
     suffix forces it to be long; an LL suffix forces it to be long
     long.  If not forced to a larger size, it gets the first type of
     the above that it fits in.  To figure out whether it fits, we
     shift it right and see whether anything remains.  Note that we
     can't shift sizeof (LONGEST) * HOST_CHAR_BIT bits or more in one
     operation, because many compilers will warn about such a shift
     (which always produces a zero result).  Sometimes gdbarch_int_bit
     or gdbarch_long_bit will be that big, sometimes not.  To deal with
     the case where it is we just always shift the value more than
     once, with fewer bits each time.  */

  un = (ULONGEST)n >> 2;
  if (long_p == 0
      && (un >> (gdbarch_int_bit (parse_gdbarch) - 2)) == 0)
    {
      high_bit = ((ULONGEST)1) << (gdbarch_int_bit (parse_gdbarch) - 1);

      /* A large decimal (not hex or octal) constant (between INT_MAX
	 and UINT_MAX) is a long or unsigned long, according to ANSI,
	 never an unsigned int, but this code treats it as unsigned
	 int.  This probably should be fixed.  GCC gives a warning on
	 such constants.  */

      unsigned_type = parse_type->builtin_unsigned_int;
      signed_type = parse_type->builtin_int;
    }
  else if (long_p <= 1
	   && (un >> (gdbarch_long_bit (parse_gdbarch) - 2)) == 0)
    {
      high_bit = ((ULONGEST)1) << (gdbarch_long_bit (parse_gdbarch) - 1);
      unsigned_type = parse_type->builtin_unsigned_long;
      signed_type = parse_type->builtin_long;
    }
  else
    {
      int shift;
      if (sizeof (ULONGEST) * HOST_CHAR_BIT 
	  < gdbarch_long_long_bit (parse_gdbarch))
	/* A long long does not fit in a LONGEST.  */
	shift = (sizeof (ULONGEST) * HOST_CHAR_BIT - 1);
      else
	shift = (gdbarch_long_long_bit (parse_gdbarch) - 1);
      high_bit = (ULONGEST) 1 << shift;
      unsigned_type = parse_type->builtin_unsigned_long_long;
      signed_type = parse_type->builtin_long_long;
    }

   putithere->typed_val_int.val = n;

   /* If the high bit of the worked out type is set then this number
      has to be unsigned. */

   if (unsigned_p || (n & high_bit)) 
     {
       putithere->typed_val_int.type = unsigned_type;
     }
   else 
     {
       putithere->typed_val_int.type = signed_type;
     }

   return INT;
}

/* Temporary obstack used for holding strings.  */
static struct obstack tempbuf;
static int tempbuf_init;

/* Parse a C escape sequence.  The initial backslash of the sequence
   is at (*PTR)[-1].  *PTR will be updated to point to just after the
   last character of the sequence.  If OUTPUT is not NULL, the
   translated form of the escape sequence will be written there.  If
   OUTPUT is NULL, no output is written and the call will only affect
   *PTR.  If an escape sequence is expressed in target bytes, then the
   entire sequence will simply be copied to OUTPUT.  Return 1 if any
   character was emitted, 0 otherwise.  */

int
c_parse_escape (const char **ptr, struct obstack *output)
{
  const char *tokptr = *ptr;
  int result = 1;

  /* Some escape sequences undergo character set conversion.  Those we
     translate here.  */
  switch (*tokptr)
    {
      /* Hex escapes do not undergo character set conversion, so keep
	 the escape sequence for later.  */
    case 'x':
      if (output)
	obstack_grow_str (output, "\\x");
      ++tokptr;
      if (!isxdigit (*tokptr))
	error (_("\\x escape without a following hex digit"));
      while (isxdigit (*tokptr))
	{
	  if (output)
	    obstack_1grow (output, *tokptr);
	  ++tokptr;
	}
      break;

      /* Octal escapes do not undergo character set conversion, so
	 keep the escape sequence for later.  */
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
      {
	int i;
	if (output)
	  obstack_grow_str (output, "\\");
	for (i = 0;
	     i < 3 && isdigit (*tokptr) && *tokptr != '8' && *tokptr != '9';
	     ++i)
	  {
	    if (output)
	      obstack_1grow (output, *tokptr);
	    ++tokptr;
	  }
      }
      break;

      /* We handle UCNs later.  We could handle them here, but that
	 would mean a spurious error in the case where the UCN could
	 be converted to the target charset but not the host
	 charset.  */
    case 'u':
    case 'U':
      {
	char c = *tokptr;
	int i, len = c == 'U' ? 8 : 4;
	if (output)
	  {
	    obstack_1grow (output, '\\');
	    obstack_1grow (output, *tokptr);
	  }
	++tokptr;
	if (!isxdigit (*tokptr))
	  error (_("\\%c escape without a following hex digit"), c);
	for (i = 0; i < len && isxdigit (*tokptr); ++i)
	  {
	    if (output)
	      obstack_1grow (output, *tokptr);
	    ++tokptr;
	  }
      }
      break;

      /* We must pass backslash through so that it does not
	 cause quoting during the second expansion.  */
    case '\\':
      if (output)
	obstack_grow_str (output, "\\\\");
      ++tokptr;
      break;

      /* Escapes which undergo conversion.  */
    case 'a':
      if (output)
	obstack_1grow (output, '\a');
      ++tokptr;
      break;
    case 'b':
      if (output)
	obstack_1grow (output, '\b');
      ++tokptr;
      break;
    case 'f':
      if (output)
	obstack_1grow (output, '\f');
      ++tokptr;
      break;
    case 'n':
      if (output)
	obstack_1grow (output, '\n');
      ++tokptr;
      break;
    case 'r':
      if (output)
	obstack_1grow (output, '\r');
      ++tokptr;
      break;
    case 't':
      if (output)
	obstack_1grow (output, '\t');
      ++tokptr;
      break;
    case 'v':
      if (output)
	obstack_1grow (output, '\v');
      ++tokptr;
      break;

      /* GCC extension.  */
    case 'e':
      if (output)
	obstack_1grow (output, HOST_ESCAPE_CHAR);
      ++tokptr;
      break;

      /* Backslash-newline expands to nothing at all.  */
    case '\n':
      ++tokptr;
      result = 0;
      break;

      /* A few escapes just expand to the character itself.  */
    case '\'':
    case '\"':
    case '?':
      /* GCC extensions.  */
    case '(':
    case '{':
    case '[':
    case '%':
      /* Unrecognized escapes turn into the character itself.  */
    default:
      if (output)
	obstack_1grow (output, *tokptr);
      ++tokptr;
      break;
    }
  *ptr = tokptr;
  return result;
}

/* Parse a string or character literal from TOKPTR.  The string or
   character may be wide or unicode.  *OUTPTR is set to just after the
   end of the literal in the input string.  The resulting token is
   stored in VALUE.  This returns a token value, either STRING or
   CHAR, depending on what was parsed.  *HOST_CHARS is set to the
   number of host characters in the literal.  */
static int
parse_string_or_char (const char *tokptr, const char **outptr,
		      struct typed_stoken *value, int *host_chars)
{
  int quote;
  enum c_string_type type;
  int is_objc = 0;

  /* Build the gdb internal form of the input string in tempbuf.  Note
     that the buffer is null byte terminated *only* for the
     convenience of debugging gdb itself and printing the buffer
     contents when the buffer contains no embedded nulls.  Gdb does
     not depend upon the buffer being null byte terminated, it uses
     the length string instead.  This allows gdb to handle C strings
     (as well as strings in other languages) with embedded null
     bytes */

  if (!tempbuf_init)
    tempbuf_init = 1;
  else
    obstack_free (&tempbuf, NULL);
  obstack_init (&tempbuf);

  /* Record the string type.  */
  if (*tokptr == 'L')
    {
      type = C_WIDE_STRING;
      ++tokptr;
    }
  else if (*tokptr == 'u')
    {
      type = C_STRING_16;
      ++tokptr;
    }
  else if (*tokptr == 'U')
    {
      type = C_STRING_32;
      ++tokptr;
    }
  else if (*tokptr == '@@')
    {
      /* An Objective C string.  */
      is_objc = 1;
      type = C_STRING;
      ++tokptr;
    }
  else
    type = C_STRING;

  /* Skip the quote.  */
  quote = *tokptr;
  if (quote == '\'')
    type |= C_CHAR;
  ++tokptr;

  *host_chars = 0;

  while (*tokptr)
    {
      char c = *tokptr;
      if (c == '\\')
	{
	  ++tokptr;
	  *host_chars += c_parse_escape (&tokptr, &tempbuf);
	}
      else if (c == quote)
	break;
      else
	{
	  obstack_1grow (&tempbuf, c);
	  ++tokptr;
	  /* FIXME: this does the wrong thing with multi-byte host
	     characters.  We could use mbrlen here, but that would
	     make "set host-charset" a bit less useful.  */
	  ++*host_chars;
	}
    }

  if (*tokptr != quote)
    {
      if (quote == '"')
	error (_("Unterminated string in expression."));
      else
	error (_("Unmatched single quote."));
    }
  ++tokptr;

  value->type = type;
  value->ptr = obstack_base (&tempbuf);
  value->length = obstack_object_size (&tempbuf);

  *outptr = tokptr;

  return quote == '"' ? (is_objc ? NSSTRING : STRING) : CHAR;
}

/* This is used to associate some attributes with a token.  */

enum token_flags
{
  /* If this bit is set, the token is C++-only.  */

  FLAG_CXX = 1,

  /* If this bit is set, the token is conditional: if there is a
     symbol of the same name, then the token is a symbol; otherwise,
     the token is a keyword.  */

  FLAG_SHADOW = 2
};

struct token
{
  char *operator;
  int token;
  enum exp_opcode opcode;
  enum token_flags flags;
};

static const struct token tokentab3[] =
  {
    {">>=", ASSIGN_MODIFY, BINOP_RSH, 0},
    {"<<=", ASSIGN_MODIFY, BINOP_LSH, 0},
    {"->*", ARROW_STAR, BINOP_END, FLAG_CXX},
    {"...", DOTDOTDOT, BINOP_END, 0}
  };

static const struct token tokentab2[] =
  {
    {"+=", ASSIGN_MODIFY, BINOP_ADD, 0},
    {"-=", ASSIGN_MODIFY, BINOP_SUB, 0},
    {"*=", ASSIGN_MODIFY, BINOP_MUL, 0},
    {"/=", ASSIGN_MODIFY, BINOP_DIV, 0},
    {"%=", ASSIGN_MODIFY, BINOP_REM, 0},
    {"|=", ASSIGN_MODIFY, BINOP_BITWISE_IOR, 0},
    {"&=", ASSIGN_MODIFY, BINOP_BITWISE_AND, 0},
    {"^=", ASSIGN_MODIFY, BINOP_BITWISE_XOR, 0},
    {"++", INCREMENT, BINOP_END, 0},
    {"--", DECREMENT, BINOP_END, 0},
    {"->", ARROW, BINOP_END, 0},
    {"&&", ANDAND, BINOP_END, 0},
    {"||", OROR, BINOP_END, 0},
    /* "::" is *not* only C++: gdb overrides its meaning in several
       different ways, e.g., 'filename'::func, function::variable.  */
    {"::", COLONCOLON, BINOP_END, 0},
    {"<<", LSH, BINOP_END, 0},
    {">>", RSH, BINOP_END, 0},
    {"==", EQUAL, BINOP_END, 0},
    {"!=", NOTEQUAL, BINOP_END, 0},
    {"<=", LEQ, BINOP_END, 0},
    {">=", GEQ, BINOP_END, 0},
    {".*", DOT_STAR, BINOP_END, FLAG_CXX}
  };

/* Identifier-like tokens.  */
static const struct token ident_tokens[] =
  {
    {"unsigned", UNSIGNED, OP_NULL, 0},
    {"template", TEMPLATE, OP_NULL, FLAG_CXX},
    {"volatile", VOLATILE_KEYWORD, OP_NULL, 0},
    {"struct", STRUCT, OP_NULL, 0},
    {"signed", SIGNED_KEYWORD, OP_NULL, 0},
    {"sizeof", SIZEOF, OP_NULL, 0},
    {"double", DOUBLE_KEYWORD, OP_NULL, 0},
    {"false", FALSEKEYWORD, OP_NULL, FLAG_CXX},
    {"class", CLASS, OP_NULL, FLAG_CXX},
    {"union", UNION, OP_NULL, 0},
    {"short", SHORT, OP_NULL, 0},
    {"const", CONST_KEYWORD, OP_NULL, 0},
    {"enum", ENUM, OP_NULL, 0},
    {"long", LONG, OP_NULL, 0},
    {"true", TRUEKEYWORD, OP_NULL, FLAG_CXX},
    {"int", INT_KEYWORD, OP_NULL, 0},
    {"new", NEW, OP_NULL, FLAG_CXX},
    {"delete", DELETE, OP_NULL, FLAG_CXX},
    {"operator", OPERATOR, OP_NULL, FLAG_CXX},

    {"and", ANDAND, BINOP_END, FLAG_CXX},
    {"and_eq", ASSIGN_MODIFY, BINOP_BITWISE_AND, FLAG_CXX},
    {"bitand", '&', OP_NULL, FLAG_CXX},
    {"bitor", '|', OP_NULL, FLAG_CXX},
    {"compl", '~', OP_NULL, FLAG_CXX},
    {"not", '!', OP_NULL, FLAG_CXX},
    {"not_eq", NOTEQUAL, BINOP_END, FLAG_CXX},
    {"or", OROR, BINOP_END, FLAG_CXX},
    {"or_eq", ASSIGN_MODIFY, BINOP_BITWISE_IOR, FLAG_CXX},
    {"xor", '^', OP_NULL, FLAG_CXX},
    {"xor_eq", ASSIGN_MODIFY, BINOP_BITWISE_XOR, FLAG_CXX},

    {"const_cast", CONST_CAST, OP_NULL, FLAG_CXX },
    {"dynamic_cast", DYNAMIC_CAST, OP_NULL, FLAG_CXX },
    {"static_cast", STATIC_CAST, OP_NULL, FLAG_CXX },
    {"reinterpret_cast", REINTERPRET_CAST, OP_NULL, FLAG_CXX },

    {"__typeof__", TYPEOF, OP_TYPEOF, 0 },
    {"__typeof", TYPEOF, OP_TYPEOF, 0 },
    {"typeof", TYPEOF, OP_TYPEOF, FLAG_SHADOW },
    {"__decltype", DECLTYPE, OP_DECLTYPE, FLAG_CXX },
    {"decltype", DECLTYPE, OP_DECLTYPE, FLAG_CXX | FLAG_SHADOW },

    {"typeid", TYPEID, OP_TYPEID, FLAG_CXX}
  };

/* When we find that lexptr (the global var defined in parse.c) is
   pointing at a macro invocation, we expand the invocation, and call
   scan_macro_expansion to save the old lexptr here and point lexptr
   into the expanded text.  When we reach the end of that, we call
   end_macro_expansion to pop back to the value we saved here.  The
   macro expansion code promises to return only fully-expanded text,
   so we don't need to "push" more than one level.

   This is disgusting, of course.  It would be cleaner to do all macro
   expansion beforehand, and then hand that to lexptr.  But we don't
   really know where the expression ends.  Remember, in a command like

     (gdb) break *ADDRESS if CONDITION

   we evaluate ADDRESS in the scope of the current frame, but we
   evaluate CONDITION in the scope of the breakpoint's location.  So
   it's simply wrong to try to macro-expand the whole thing at once.  */
static const char *macro_original_text;

/* We save all intermediate macro expansions on this obstack for the
   duration of a single parse.  The expansion text may sometimes have
   to live past the end of the expansion, due to yacc lookahead.
   Rather than try to be clever about saving the data for a single
   token, we simply keep it all and delete it after parsing has
   completed.  */
static struct obstack expansion_obstack;

static void
scan_macro_expansion (char *expansion)
{
  char *copy;

  /* We'd better not be trying to push the stack twice.  */
  gdb_assert (! macro_original_text);

  /* Copy to the obstack, and then free the intermediate
     expansion.  */
  copy = obstack_copy0 (&expansion_obstack, expansion, strlen (expansion));
  xfree (expansion);

  /* Save the old lexptr value, so we can return to it when we're done
     parsing the expanded text.  */
  macro_original_text = lexptr;
  lexptr = copy;
}


static int
scanning_macro_expansion (void)
{
  return macro_original_text != 0;
}


static void 
finished_macro_expansion (void)
{
  /* There'd better be something to pop back to.  */
  gdb_assert (macro_original_text);

  /* Pop back to the original text.  */
  lexptr = macro_original_text;
  macro_original_text = 0;
}


static void
scan_macro_cleanup (void *dummy)
{
  if (macro_original_text)
    finished_macro_expansion ();

  obstack_free (&expansion_obstack, NULL);
}

/* Return true iff the token represents a C++ cast operator.  */

static int
is_cast_operator (const char *token, int len)
{
  return (! strncmp (token, "dynamic_cast", len)
	  || ! strncmp (token, "static_cast", len)
	  || ! strncmp (token, "reinterpret_cast", len)
	  || ! strncmp (token, "const_cast", len));
}

/* The scope used for macro expansion.  */
static struct macro_scope *expression_macro_scope;

/* This is set if a NAME token appeared at the very end of the input
   string, with no whitespace separating the name from the EOF.  This
   is used only when parsing to do field name completion.  */
static int saw_name_at_eof;

/* This is set if the previously-returned token was a structure
   operator -- either '.' or ARROW.  This is used only when parsing to
   do field name completion.  */
static int last_was_structop;

/* Read one token, getting characters through lexptr.  */

static int
lex_one_token (void)
{
  int c;
  int namelen;
  unsigned int i;
  const char *tokstart;
  int saw_structop = last_was_structop;
  char *copy;

  last_was_structop = 0;

 retry:

  /* Check if this is a macro invocation that we need to expand.  */
  if (! scanning_macro_expansion ())
    {
      char *expanded = macro_expand_next (&lexptr,
                                          standard_macro_lookup,
                                          expression_macro_scope);

      if (expanded)
        scan_macro_expansion (expanded);
    }

  prev_lexptr = lexptr;

  tokstart = lexptr;
  /* See if it is a special token of length 3.  */
  for (i = 0; i < sizeof tokentab3 / sizeof tokentab3[0]; i++)
    if (strncmp (tokstart, tokentab3[i].operator, 3) == 0)
      {
	if ((tokentab3[i].flags & FLAG_CXX) != 0
	    && parse_language->la_language != language_cplus)
	  break;

	lexptr += 3;
	yylval.opcode = tokentab3[i].opcode;
	return tokentab3[i].token;
      }

  /* See if it is a special token of length 2.  */
  for (i = 0; i < sizeof tokentab2 / sizeof tokentab2[0]; i++)
    if (strncmp (tokstart, tokentab2[i].operator, 2) == 0)
      {
	if ((tokentab2[i].flags & FLAG_CXX) != 0
	    && parse_language->la_language != language_cplus)
	  break;

	lexptr += 2;
	yylval.opcode = tokentab2[i].opcode;
	if (parse_completion && tokentab2[i].token == ARROW)
	  last_was_structop = 1;
	return tokentab2[i].token;
      }

  switch (c = *tokstart)
    {
    case 0:
      /* If we were just scanning the result of a macro expansion,
         then we need to resume scanning the original text.
	 If we're parsing for field name completion, and the previous
	 token allows such completion, return a COMPLETE token.
         Otherwise, we were already scanning the original text, and
         we're really done.  */
      if (scanning_macro_expansion ())
        {
          finished_macro_expansion ();
          goto retry;
        }
      else if (saw_name_at_eof)
	{
	  saw_name_at_eof = 0;
	  return COMPLETE;
	}
      else if (saw_structop)
	return COMPLETE;
      else
        return 0;

    case ' ':
    case '\t':
    case '\n':
      lexptr++;
      goto retry;

    case '[':
    case '(':
      paren_depth++;
      lexptr++;
      if (parse_language->la_language == language_objc && c == '[')
	return OBJC_LBRAC;
      return c;

    case ']':
    case ')':
      if (paren_depth == 0)
	return 0;
      paren_depth--;
      lexptr++;
      return c;

    case ',':
      if (comma_terminates
          && paren_depth == 0
          && ! scanning_macro_expansion ())
	return 0;
      lexptr++;
      return c;

    case '.':
      /* Might be a floating point number.  */
      if (lexptr[1] < '0' || lexptr[1] > '9')
	{
	  if (parse_completion)
	    last_was_structop = 1;
	  goto symbol;		/* Nope, must be a symbol. */
	}
      /* FALL THRU into number case.  */

    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
      {
	/* It's a number.  */
	int got_dot = 0, got_e = 0, toktype;
	const char *p = tokstart;
	int hex = input_radix > 10;

	if (c == '0' && (p[1] == 'x' || p[1] == 'X'))
	  {
	    p += 2;
	    hex = 1;
	  }
	else if (c == '0' && (p[1]=='t' || p[1]=='T' || p[1]=='d' || p[1]=='D'))
	  {
	    p += 2;
	    hex = 0;
	  }

	for (;; ++p)
	  {
	    /* This test includes !hex because 'e' is a valid hex digit
	       and thus does not indicate a floating point number when
	       the radix is hex.  */
	    if (!hex && !got_e && (*p == 'e' || *p == 'E'))
	      got_dot = got_e = 1;
	    /* This test does not include !hex, because a '.' always indicates
	       a decimal floating point number regardless of the radix.  */
	    else if (!got_dot && *p == '.')
	      got_dot = 1;
	    else if (got_e && (p[-1] == 'e' || p[-1] == 'E')
		     && (*p == '-' || *p == '+'))
	      /* This is the sign of the exponent, not the end of the
		 number.  */
	      continue;
	    /* We will take any letters or digits.  parse_number will
	       complain if past the radix, or if L or U are not final.  */
	    else if ((*p < '0' || *p > '9')
		     && ((*p < 'a' || *p > 'z')
				  && (*p < 'A' || *p > 'Z')))
	      break;
	  }
	toktype = parse_number (tokstart, p - tokstart, got_dot|got_e, &yylval);
        if (toktype == ERROR)
	  {
	    char *err_copy = (char *) alloca (p - tokstart + 1);

	    memcpy (err_copy, tokstart, p - tokstart);
	    err_copy[p - tokstart] = 0;
	    error (_("Invalid number \"%s\"."), err_copy);
	  }
	lexptr = p;
	return toktype;
      }

    case '@@':
      {
	const char *p = &tokstart[1];
	size_t len = strlen ("entry");

	if (parse_language->la_language == language_objc)
	  {
	    size_t len = strlen ("selector");

	    if (strncmp (p, "selector", len) == 0
		&& (p[len] == '\0' || isspace (p[len])))
	      {
		lexptr = p + len;
		return SELECTOR;
	      }
	    else if (*p == '"')
	      goto parse_string;
	  }

	while (isspace (*p))
	  p++;
	if (strncmp (p, "entry", len) == 0 && !isalnum (p[len])
	    && p[len] != '_')
	  {
	    lexptr = &p[len];
	    return ENTRY;
	  }
      }
      /* FALLTHRU */
    case '+':
    case '-':
    case '*':
    case '/':
    case '%':
    case '|':
    case '&':
    case '^':
    case '~':
    case '!':
    case '<':
    case '>':
    case '?':
    case ':':
    case '=':
    case '{':
    case '}':
    symbol:
      lexptr++;
      return c;

    case 'L':
    case 'u':
    case 'U':
      if (tokstart[1] != '"' && tokstart[1] != '\'')
	break;
      /* Fall through.  */
    case '\'':
    case '"':

    parse_string:
      {
	int host_len;
	int result = parse_string_or_char (tokstart, &lexptr, &yylval.tsval,
					   &host_len);
	if (result == CHAR)
	  {
	    if (host_len == 0)
	      error (_("Empty character constant."));
	    else if (host_len > 2 && c == '\'')
	      {
		++tokstart;
		namelen = lexptr - tokstart - 1;
		goto tryname;
	      }
	    else if (host_len > 1)
	      error (_("Invalid character constant."));
	  }
	return result;
      }
    }

  if (!(c == '_' || c == '$'
	|| (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')))
    /* We must have come across a bad character (e.g. ';').  */
    error (_("Invalid character '%c' in expression."), c);

  /* It's a name.  See how long it is.  */
  namelen = 0;
  for (c = tokstart[namelen];
       (c == '_' || c == '$' || (c >= '0' && c <= '9')
	|| (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '<');)
    {
      /* Template parameter lists are part of the name.
	 FIXME: This mishandles `print $a<4&&$a>3'.  */

      if (c == '<')
	{
	  if (! is_cast_operator (tokstart, namelen))
	    {
	      /* Scan ahead to get rest of the template specification.  Note
		 that we look ahead only when the '<' adjoins non-whitespace
		 characters; for comparison expressions, e.g. "a < b > c",
		 there must be spaces before the '<', etc. */
               
	      const char *p = find_template_name_end (tokstart + namelen);

	      if (p)
		namelen = p - tokstart;
	    }
	  break;
	}
      c = tokstart[++namelen];
    }

  /* The token "if" terminates the expression and is NOT removed from
     the input stream.  It doesn't count if it appears in the
     expansion of a macro.  */
  if (namelen == 2
      && tokstart[0] == 'i'
      && tokstart[1] == 'f'
      && ! scanning_macro_expansion ())
    {
      return 0;
    }

  /* For the same reason (breakpoint conditions), "thread N"
     terminates the expression.  "thread" could be an identifier, but
     an identifier is never followed by a number without intervening
     punctuation.  "task" is similar.  Handle abbreviations of these,
     similarly to breakpoint.c:find_condition_and_thread.  */
  if (namelen >= 1
      && (strncmp (tokstart, "thread", namelen) == 0
	  || strncmp (tokstart, "task", namelen) == 0)
      && (tokstart[namelen] == ' ' || tokstart[namelen] == '\t')
      && ! scanning_macro_expansion ())
    {
      const char *p = tokstart + namelen + 1;

      while (*p == ' ' || *p == '\t')
	p++;
      if (*p >= '0' && *p <= '9')
	return 0;
    }

  lexptr += namelen;

  tryname:

  yylval.sval.ptr = tokstart;
  yylval.sval.length = namelen;

  /* Catch specific keywords.  */
  copy = copy_name (yylval.sval);
  for (i = 0; i < sizeof ident_tokens / sizeof ident_tokens[0]; i++)
    if (strcmp (copy, ident_tokens[i].operator) == 0)
      {
	if ((ident_tokens[i].flags & FLAG_CXX) != 0
	    && parse_language->la_language != language_cplus)
	  break;

	if ((ident_tokens[i].flags & FLAG_SHADOW) != 0)
	  {
	    struct field_of_this_result is_a_field_of_this;

	    if (lookup_symbol (copy, expression_context_block,
			       VAR_DOMAIN,
			       (parse_language->la_language == language_cplus
				? &is_a_field_of_this
				: NULL))
		!= NULL)
	      {
		/* The keyword is shadowed.  */
		break;
	      }
	  }

	/* It is ok to always set this, even though we don't always
	   strictly need to.  */
	yylval.opcode = ident_tokens[i].opcode;
	return ident_tokens[i].token;
      }

  if (*tokstart == '$')
    return VARIABLE;

  if (parse_completion && *lexptr == '\0')
    saw_name_at_eof = 1;

  yylval.ssym.stoken = yylval.sval;
  yylval.ssym.sym = NULL;
  yylval.ssym.is_a_field_of_this = 0;
  return NAME;
}

/* An object of this type is pushed on a FIFO by the "outer" lexer.  */
typedef struct
{
  int token;
  YYSTYPE value;
} token_and_value;

DEF_VEC_O (token_and_value);

/* A FIFO of tokens that have been read but not yet returned to the
   parser.  */
static VEC (token_and_value) *token_fifo;

/* Non-zero if the lexer should return tokens from the FIFO.  */
static int popping;

/* Temporary storage for c_lex; this holds symbol names as they are
   built up.  */
static struct obstack name_obstack;

/* Classify a NAME token.  The contents of the token are in `yylval'.
   Updates yylval and returns the new token type.  BLOCK is the block
   in which lookups start; this can be NULL to mean the global
   scope.  */
static int
classify_name (const struct block *block)
{
  struct symbol *sym;
  char *copy;
  struct field_of_this_result is_a_field_of_this;

  copy = copy_name (yylval.sval);

  /* Initialize this in case we *don't* use it in this call; that way
     we can refer to it unconditionally below.  */
  memset (&is_a_field_of_this, 0, sizeof (is_a_field_of_this));

  sym = lookup_symbol (copy, block, VAR_DOMAIN, 
		       parse_language->la_name_of_this
		       ? &is_a_field_of_this : NULL);

  if (sym && SYMBOL_CLASS (sym) == LOC_BLOCK)
    {
      yylval.ssym.sym = sym;
      yylval.ssym.is_a_field_of_this = is_a_field_of_this.type != NULL;
      return BLOCKNAME;
    }
  else if (!sym)
    {
      /* See if it's a file name. */
      struct symtab *symtab;

      symtab = lookup_symtab (copy);
      if (symtab)
	{
	  yylval.bval = BLOCKVECTOR_BLOCK (BLOCKVECTOR (symtab), STATIC_BLOCK);
	  return FILENAME;
	}

      /* If we found a field of 'this', we might have erroneously
	 found a constructor where we wanted a type name.  Handle this
	 case by noticing that we found a constructor and then look up
	 the type tag instead.  */
      if (is_a_field_of_this.type != NULL
	  && is_a_field_of_this.fn_field != NULL
	  && TYPE_FN_FIELD_CONSTRUCTOR (is_a_field_of_this.fn_field->fn_fields,
					0))
	{
	  struct field_of_this_result inner_is_a_field_of_this;

	  sym = lookup_symbol (copy, block, STRUCT_DOMAIN,
			       &inner_is_a_field_of_this);
	  if (sym != NULL)
	    {
	      yylval.tsym.type = SYMBOL_TYPE (sym);
	      return TYPENAME;
	    }
	}
    }

  if (sym && SYMBOL_CLASS (sym) == LOC_TYPEDEF)
    {
      yylval.tsym.type = SYMBOL_TYPE (sym);
      return TYPENAME;
    }

  yylval.tsym.type
    = language_lookup_primitive_type_by_name (parse_language,
					      parse_gdbarch, copy);
  if (yylval.tsym.type != NULL)
    return TYPENAME;

  /* See if it's an ObjC classname.  */
  if (parse_language->la_language == language_objc && !sym)
    {
      CORE_ADDR Class = lookup_objc_class (parse_gdbarch, copy);
      if (Class)
	{
	  yylval.class.class = Class;
	  sym = lookup_struct_typedef (copy, expression_context_block, 1);
	  if (sym)
	    yylval.class.type = SYMBOL_TYPE (sym);
	  return CLASSNAME;
	}
    }

  /* Input names that aren't symbols but ARE valid hex numbers, when
     the input radix permits them, can be names or numbers depending
     on the parse.  Note we support radixes > 16 here.  */
  if (!sym
      && ((copy[0] >= 'a' && copy[0] < 'a' + input_radix - 10)
	  || (copy[0] >= 'A' && copy[0] < 'A' + input_radix - 10)))
    {
      YYSTYPE newlval;	/* Its value is ignored.  */
      int hextype = parse_number (copy, yylval.sval.length, 0, &newlval);
      if (hextype == INT)
	{
	  yylval.ssym.sym = sym;
	  yylval.ssym.is_a_field_of_this = is_a_field_of_this.type != NULL;
	  return NAME_OR_INT;
	}
    }

  /* Any other kind of symbol */
  yylval.ssym.sym = sym;
  yylval.ssym.is_a_field_of_this = is_a_field_of_this.type != NULL;

  if (sym == NULL
      && parse_language->la_language == language_cplus
      && is_a_field_of_this.type == NULL
      && !lookup_minimal_symbol (copy, NULL, NULL))
    return UNKNOWN_CPP_NAME;

  return NAME;
}

/* Like classify_name, but used by the inner loop of the lexer, when a
   name might have already been seen.  CONTEXT is the context type, or
   NULL if this is the first component of a name.  */

static int
classify_inner_name (const struct block *block, struct type *context)
{
  struct type *type;
  char *copy;

  if (context == NULL)
    return classify_name (block);

  type = check_typedef (context);
  if (TYPE_CODE (type) != TYPE_CODE_STRUCT
      && TYPE_CODE (type) != TYPE_CODE_UNION
      && TYPE_CODE (type) != TYPE_CODE_NAMESPACE)
    return ERROR;

  copy = copy_name (yylval.ssym.stoken);
  yylval.ssym.sym = cp_lookup_nested_symbol (type, copy, block);
  if (yylval.ssym.sym == NULL)
    return ERROR;

  switch (SYMBOL_CLASS (yylval.ssym.sym))
    {
    case LOC_BLOCK:
    case LOC_LABEL:
      return ERROR;

    case LOC_TYPEDEF:
      yylval.tsym.type = SYMBOL_TYPE (yylval.ssym.sym);;
      return TYPENAME;

    default:
      return NAME;
    }
  internal_error (__FILE__, __LINE__, _("not reached"));
}

/* The outer level of a two-level lexer.  This calls the inner lexer
   to return tokens.  It then either returns these tokens, or
   aggregates them into a larger token.  This lets us work around a
   problem in our parsing approach, where the parser could not
   distinguish between qualified names and qualified types at the
   right point.
   
   This approach is still not ideal, because it mishandles template
   types.  See the comment in lex_one_token for an example.  However,
   this is still an improvement over the earlier approach, and will
   suffice until we move to better parsing technology.  */
static int
yylex (void)
{
  token_and_value current;
  int first_was_coloncolon, last_was_coloncolon;
  struct type *context_type = NULL;
  int last_to_examine, next_to_examine, checkpoint;
  const struct block *search_block;

  if (popping && !VEC_empty (token_and_value, token_fifo))
    goto do_pop;
  popping = 0;

  /* Read the first token and decide what to do.  Most of the
     subsequent code is C++-only; but also depends on seeing a "::" or
     name-like token.  */
  current.token = lex_one_token ();
  if (current.token == NAME)
    current.token = classify_name (expression_context_block);
  if (parse_language->la_language != language_cplus
      || (current.token != TYPENAME && current.token != COLONCOLON
	  && current.token != FILENAME))
    return current.token;

  /* Read any sequence of alternating "::" and name-like tokens into
     the token FIFO.  */
  current.value = yylval;
  VEC_safe_push (token_and_value, token_fifo, &current);
  last_was_coloncolon = current.token == COLONCOLON;
  while (1)
    {
      current.token = lex_one_token ();
      current.value = yylval;
      VEC_safe_push (token_and_value, token_fifo, &current);

      if ((last_was_coloncolon && current.token != NAME)
	  || (!last_was_coloncolon && current.token != COLONCOLON))
	break;
      last_was_coloncolon = !last_was_coloncolon;
    }
  popping = 1;

  /* We always read one extra token, so compute the number of tokens
     to examine accordingly.  */
  last_to_examine = VEC_length (token_and_value, token_fifo) - 2;
  next_to_examine = 0;

  current = *VEC_index (token_and_value, token_fifo, next_to_examine);
  ++next_to_examine;

  obstack_free (&name_obstack, obstack_base (&name_obstack));
  checkpoint = 0;
  if (current.token == FILENAME)
    search_block = current.value.bval;
  else if (current.token == COLONCOLON)
    search_block = NULL;
  else
    {
      gdb_assert (current.token == TYPENAME);
      search_block = expression_context_block;
      obstack_grow (&name_obstack, current.value.sval.ptr,
		    current.value.sval.length);
      context_type = current.value.tsym.type;
      checkpoint = 1;
    }

  first_was_coloncolon = current.token == COLONCOLON;
  last_was_coloncolon = first_was_coloncolon;

  while (next_to_examine <= last_to_examine)
    {
      token_and_value *next;

      next = VEC_index (token_and_value, token_fifo, next_to_examine);
      ++next_to_examine;

      if (next->token == NAME && last_was_coloncolon)
	{
	  int classification;

	  yylval = next->value;
	  classification = classify_inner_name (search_block, context_type);
	  /* We keep going until we either run out of names, or until
	     we have a qualified name which is not a type.  */
	  if (classification != TYPENAME && classification != NAME)
	    break;

	  /* Accept up to this token.  */
	  checkpoint = next_to_examine;

	  /* Update the partial name we are constructing.  */
	  if (context_type != NULL)
	    {
	      /* We don't want to put a leading "::" into the name.  */
	      obstack_grow_str (&name_obstack, "::");
	    }
	  obstack_grow (&name_obstack, next->value.sval.ptr,
			next->value.sval.length);

	  yylval.sval.ptr = obstack_base (&name_obstack);
	  yylval.sval.length = obstack_object_size (&name_obstack);
	  current.value = yylval;
	  current.token = classification;

	  last_was_coloncolon = 0;
	  
	  if (classification == NAME)
	    break;

	  context_type = yylval.tsym.type;
	}
      else if (next->token == COLONCOLON && !last_was_coloncolon)
	last_was_coloncolon = 1;
      else
	{
	  /* We've reached the end of the name.  */
	  break;
	}
    }

  /* If we have a replacement token, install it as the first token in
     the FIFO, and delete the other constituent tokens.  */
  if (checkpoint > 0)
    {
      current.value.sval.ptr = obstack_copy0 (&expansion_obstack,
					      current.value.sval.ptr,
					      current.value.sval.length);

      VEC_replace (token_and_value, token_fifo, 0, &current);
      if (checkpoint > 1)
	VEC_block_remove (token_and_value, token_fifo, 1, checkpoint - 1);
    }

 do_pop:
  current = *VEC_index (token_and_value, token_fifo, 0);
  VEC_ordered_remove (token_and_value, token_fifo, 0);
  yylval = current.value;
  return current.token;
}

int
c_parse (void)
{
  int result;
  struct cleanup *back_to = make_cleanup (free_current_contents,
					  &expression_macro_scope);

  /* Set up the scope for macro expansion.  */
  expression_macro_scope = NULL;

  if (expression_context_block)
    expression_macro_scope
      = sal_macro_scope (find_pc_line (expression_context_pc, 0));
  else
    expression_macro_scope = default_macro_scope ();
  if (! expression_macro_scope)
    expression_macro_scope = user_macro_scope ();

  /* Initialize macro expansion code.  */
  obstack_init (&expansion_obstack);
  gdb_assert (! macro_original_text);
  make_cleanup (scan_macro_cleanup, 0);

  make_cleanup_restore_integer (&yydebug);
  yydebug = parser_debug;

  /* Initialize some state used by the lexer.  */
  last_was_structop = 0;
  saw_name_at_eof = 0;

  VEC_free (token_and_value, token_fifo);
  popping = 0;
  obstack_init (&name_obstack);
  make_cleanup_obstack_free (&name_obstack);

  result = yyparse ();
  do_cleanups (back_to);
  return result;
}

/* This is called via the YYPRINT macro when parser debugging is
   enabled.  It prints a token's value.  */

static void
c_print_token (FILE *file, int type, YYSTYPE value)
{
  switch (type)
    {
    case INT:
      fprintf (file, "typed_val_int<%s, %s>",
	       TYPE_SAFE_NAME (value.typed_val_int.type),
	       pulongest (value.typed_val_int.val));
      break;

    case CHAR:
    case STRING:
      {
	char *copy = alloca (value.tsval.length + 1);

	memcpy (copy, value.tsval.ptr, value.tsval.length);
	copy[value.tsval.length] = '\0';

	fprintf (file, "tsval<type=%d, %s>", value.tsval.type, copy);
      }
      break;

    case NSSTRING:
    case VARIABLE:
      fprintf (file, "sval<%s>", copy_name (value.sval));
      break;

    case TYPENAME:
      fprintf (file, "tsym<type=%s, name=%s>",
	       TYPE_SAFE_NAME (value.tsym.type),
	       copy_name (value.tsym.stoken));
      break;

    case NAME:
    case UNKNOWN_CPP_NAME:
    case NAME_OR_INT:
    case BLOCKNAME:
      fprintf (file, "ssym<name=%s, sym=%s, field_of_this=%d>",
	       copy_name (value.ssym.stoken),
	       (value.ssym.sym == NULL
		? "(null)" : SYMBOL_PRINT_NAME (value.ssym.sym)),
	       value.ssym.is_a_field_of_this);
      break;

    case FILENAME:
      fprintf (file, "bval<%s>", host_address_to_string (value.bval));
      break;
    }
}

void
yyerror (char *msg)
{
  if (prev_lexptr)
    lexptr = prev_lexptr;

  error (_("A %s in expression, near `%s'."), (msg ? msg : "error"), lexptr);
}
@


1.118
log
@remove msymbol_objfile

This is another patch in my ongoing series to "split" objfile to share
more read-only data across inferiors.  See

    http://sourceware.org/gdb/wiki/ObjfileSplitting

When symbols are finally shared, there will be no back-link from the
symbol to its containing objfile, because there may be more than one
such objfile.  So, all such back-links must be removed.

One hidden back-link is the msymbol_objfile function.  Since
(eventually) a symbol may appear in more than one objfile, trying to
look up the objfile given just a symbol cannot work.

This patch removes msymbol_objfile in favor of using a bound minimal
symbol.  It introduces a new function to make this conversion simpler
in some spots.

The bonus of this patch is that using msymbol_objfile is slower than
simply looking up the owning objfile in the first place.

Built and regtested on x86-64 Fedora 18.

	* ada-exp.y (write_var_or_type): Use bound_minimal_symbol.
	* ada-lang.c (ada_lookup_simple_minsym): Return
	bound_minimal_symbol.
	* ada-lang.h (ada_lookup_simple_minsym): Update.
	* c-exp.y (variable): Use lookup_bound_minimal_symbol.
	* f-exp.y (variable): Use lookup_bound_minimal_symbol.
	* go-exp.y (variable): Use lookup_bound_minimal_symbol.
	* jv-exp.y (push_expression_name): Use lookup_bound_minimal_symbol.
	* m2-exp.y (variable): Use lookup_bound_minimal_symbol.
	* minsyms.c (msymbol_objfile): Remove.
	(lookup_minimal_symbol_internal): New function, from
	lookup_minimal_symbol.
	(lookup_minimal_symbol): Rewrite using
	lookup_minimal_symbol_internal.
	(lookup_bound_minimal_symbol): New function.
	* minsyms.h (msymbol_objfile): Remove.
	(lookup_bound_minimal_symbol): Declare.
	* p-exp.y (variable): Use lookup_bound_minimal_symbol.
	* parse.c (write_exp_msymbol): Change parameter to a
	bound_minimal_symbol.
	(write_dollar_variable): Use lookup_bound_minimal_symbol.
	* parser-defs.h (write_exp_msymbol): Update.
	* printcmd.c (address_info): Use lookup_bound_minimal_symbol.
	* symfile.c (simple_read_overlay_table): Use
	lookup_bound_minimal_symbol.
	* symtab.c (skip_prologue_sal): Don't use msymbol_objfile.
	(search_symbols): Likewise.
	(print_msymbol_info): Take a bound_minimal_symbol argument.
	(symtab_symbol_info, rbreak_command): Update.
	* symtab.h (struct symbol_search) <msymbol>: Change type
	to bound_minimal_symbol.
	* valops.c (find_function_in_inferior): Use
	lookup_bound_minimal_symbol.
	* value.c (value_fn_field): Use lookup_bound_minimal_symbol.
@
text
@d167 1
a167 1
static int parse_number (char *, int, int, YYSTYPE *);
d973 2
d981 2
a982 2

			  tmp_token.ptr = (char*) alloca ($4.length + 2);
d984 3
a986 3
			  tmp_token.ptr[0] = '~';
			  memcpy (tmp_token.ptr+1, $4.ptr, $4.length);
			  tmp_token.ptr[tmp_token.length] = 0;
d1656 2
d1659 4
a1662 3
  st.ptr = malloc (st.length + 1);
  strcpy (st.ptr, operator_string);
  strcat (st.ptr, op);
d1665 1
a1665 1
  make_cleanup (free, st.ptr);
d1707 1
a1707 1
parse_number (char *p, int len, int parsed_float, YYSTYPE *putithere)
d1729 4
d1953 1
a1953 1
c_parse_escape (char **ptr, struct obstack *output)
d1955 1
a1955 1
  char *tokptr = *ptr;
d2114 2
a2115 2
parse_string_or_char (char *tokptr, char **outptr, struct typed_stoken *value,
		      int *host_chars)
d2333 1
a2333 1
static char *macro_original_text;
d2423 1
a2423 1
  char *tokstart;
d2550 1
a2550 1
	char *p = tokstart;
d2602 1
a2602 1
	char *p = &tokstart[1];
d2704 2
a2705 1
	      char * p = find_template_name_end (tokstart + namelen);
d2736 2
a2737 1
      char *p = tokstart + namelen + 1;
@


1.117
log
@	PR c++/9065:
	* NEWS: Update.
	* breakpoint.c (watchpoint_exp_is_const): Add OP_TYPEID.
	* c-exp.y (TYPEID): New token.
	(exp): Add new TYPEID productions.
	(ident_tokens): Add "typeid".
	* cp-abi.c (cplus_typeid, cplus_typeid_type): New functions.
	* cp-abi.h (cplus_typeid, cplus_typeid_type): Declare.
	(struct cp_abi_ops) <get_typeid, get_typeid_type>: New fields.
	* eval.c (evaluate_subexp_standard) <OP_TYPEID>: New case.
	* expprint.c (dump_subexp_body_standard) <OP_TYPEID>: New
	case.
	* gnu-v3-abi.c (std_type_info_gdbarch_data): New global.
	(build_std_type_info_type, gnuv3_get_typeid_type)
	(gnuv3_get_typeid): New functions.
	(init_gnuv3_ops): Initialize std_type_info_gdbarch_data.  Set
	new fields on ABI object.
	* parse.c (operator_length_standard) <OP_TYPEID>: New case.
	* std-operator.def (OP_TYPEID): New.
gdb/testsuite
	* gdb.cp/typeid.cc: New file.
	* gdb.cp/typeid.exp: New file.
@
text
@d1007 1
a1007 1
			  struct minimal_symbol *msymbol;
d1021 2
a1022 2
			  msymbol = lookup_minimal_symbol (name, NULL, NULL);
			  if (msymbol != NULL)
d1069 1
a1069 1
			      struct minimal_symbol *msymbol;
d1073 2
a1074 2
				lookup_minimal_symbol (arg, NULL, NULL);
			      if (msymbol != NULL)
@


1.116
log
@	PR symtab/11462:
	* c-exp.y (exp): Add new productions for destructors after '.' and
	'->'.
	(write_destructor_name): New function.
gdb/testsuite
	* gdb.cp/m-static.exp: Add destructor-printing tests.
@
text
@d237 1
d350 8
d2302 3
a2304 1
    {"decltype", DECLTYPE, OP_DECLTYPE, FLAG_CXX | FLAG_SHADOW }
@


1.115
log
@	PR exp/15109:
	* c-exp.y (yylex): Rewrite to push all tokens onto the FIFO.
	Handle FILENAME token.
gdb/testsuite
	* gdb.cp/cpexprs.exp: Add test for FILENAME:: case.
	* gdb.cp/misc.exp: Add test for FILENAME:: case.
@
text
@d170 1
d376 13
d424 13
d1622 16
@


1.114
log
@	* c-exp.y (YYPRINT): Define.
	(c_print_token): New function.
@
text
@d2920 1
a2920 1
  int first_was_coloncolon, last_was_coloncolon, first_iter;
d2922 2
d2926 1
a2926 6
    {
      token_and_value tv = *VEC_index (token_and_value, token_fifo, 0);
      VEC_ordered_remove (token_and_value, token_fifo, 0);
      yylval = tv.value;
      return tv.token;
    }
d2929 3
d2936 2
a2937 1
      || (current.token != TYPENAME && current.token != COLONCOLON))
d2940 26
a2965 2
  first_was_coloncolon = current.token == COLONCOLON;
  last_was_coloncolon = first_was_coloncolon;
d2967 6
a2972 1
  if (!last_was_coloncolon)
d2974 6
a2979 2
      obstack_grow (&name_obstack, yylval.sval.ptr, yylval.sval.length);
      context_type = yylval.tsym.type;
d2981 5
a2985 3
  current.value = yylval;
  first_iter = 1;
  while (1)
d2987 1
a2987 1
      token_and_value next;
d2989 2
a2990 2
      next.token = lex_one_token ();
      next.value = yylval;
d2992 1
a2992 1
      if (next.token == NAME && last_was_coloncolon)
d2996 2
a2997 4
	  classification = classify_inner_name (first_was_coloncolon
						? NULL
						: expression_context_block,
						context_type);
d3001 4
a3004 5
	    {
	      /* Push the final component and leave the loop.  */
	      VEC_safe_push (token_and_value, token_fifo, &next);
	      break;
	    }
d3012 2
a3013 2
	  obstack_grow (&name_obstack, next.value.sval.ptr,
			next.value.sval.length);
d3027 1
a3027 1
      else if (next.token == COLONCOLON && !last_was_coloncolon)
a3031 1
	  VEC_safe_push (token_and_value, token_fifo, &next);
a3033 2

      first_iter = 0;
d3036 3
a3038 4
  popping = 1;

  /* If we ended with a "::", insert it too.  */
  if (last_was_coloncolon)
d3040 7
a3046 9
      token_and_value cc;
      memset (&cc, 0, sizeof (token_and_value));
      if (first_was_coloncolon && first_iter)
	{
	  yylval = cc.value;
	  return COLONCOLON;
	}
      cc.token = COLONCOLON;
      VEC_safe_insert (token_and_value, token_fifo, 0, &cc);
d3049 3
a3052 3
  yylval.sval.ptr = obstack_copy0 (&expansion_obstack,
				   yylval.sval.ptr,
				   yylval.sval.length);
@


1.113
log
@	* c-exp.y (%union) <sym, ivar, ivec>: Remove.
@
text
@d170 3
d3069 53
@


1.112
log
@	PR symtab/11464:
	* c-exp.y (lex_one_token): Initialize other fields of yylval on
	NAME return.
	(classify_inner_name): Remove 'first_name' argument, add
	'context'.  Remove unused variable.
	(yylex): Explicitly maintain the context type.  Exit loop earlier
	if NAME result is seen.
gdb/testsuite
	* gdb.cp/m-static.cc (gnu_obj_1::~gnu_obj_1): New destructor.
	* gdb.cp/m-static.exp: Add tests to print quoted destructor.
@
text
@a147 1
    struct symbol *sym;
a155 1
    struct internalvar *ivar;
a158 1
    int *ivec;
@


1.111
log
@2013-01-31  Aleksandar Ristovski  <aristovski@@qnx.com>

	* c-exp.y (classify_inner_name): Remove unused type.
	* c-lang.c (c_printstr): Remove unused byte_order, i, things_printed,
	in_quotes, need_comma, wchar_buf, output, cleanup, iter, finished,
	need_escape.
	(c_get_string): Remove unused kind.
	* c-typeprint.c (c_type_print_args): Remove unused i, len, args, table2.

Reference: http://sourceware.org/ml/gdb-patches/2013-01/msg00759.html
@
text
@d2722 4
d2866 2
a2867 2
   name might have already been seen.  FIRST_NAME is true if the token
   in `yylval' is the first component of a name, false otherwise.  */
d2870 1
a2870 1
classify_inner_name (const struct block *block, int first_name)
d2875 1
a2875 1
  if (first_name)
d2878 1
a2878 1
  type = check_typedef (yylval.tsym.type);
d2884 2
a2885 2
  copy = copy_name (yylval.tsym.stoken);
  yylval.ssym.sym = cp_lookup_nested_symbol (yylval.tsym.type, copy, block);
a2899 1
      yylval.ssym.is_a_field_of_this = 0;
d2921 1
d2943 4
a2946 1
    obstack_grow (&name_obstack, yylval.sval.ptr, yylval.sval.length);
d2963 1
a2963 1
						first_iter);
d2974 1
a2974 1
	  if (!first_iter)
d2988 5
@


1.110
log
@	* c-exp.y (qualified_name): Use TYPE_SAFE_NAME.
@
text
@d2868 1
a2868 1
  struct type *type, *new_type;
@


1.109
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d926 1
a926 1
				   TYPE_NAME (type));
d942 1
a942 1
				   TYPE_NAME (type));
d962 1
a962 1
				 copy, TYPE_NAME ($1.type));
@


1.108
log
@	PR c++/8888:
	* symtab.c (lookup_symbol_aux): If constructor is found, consider
	returning the type instead.
	* c-exp.y (classify_name): Check STRUCT_DOMAIN if a constructor is
	found.
testsuite
	* gdb.cp/member-name.exp: New file.
	* gdb.cp/member-name.cc: New file.
@
text
@d2 1
a2 2
   Copyright (C) 1986, 1989-2000, 2003-2004, 2006-2012 Free Software
   Foundation, Inc.
@


1.107
log
@	* c-exp.y (block, variable, name_not_typename, lex_one_token,
	classify_name): Update.
	* c-valprint.c (c_val_print): Update.
	* f-exp.y (yylex): Update.
	* go-exp.y (package_name_p, classify_packaged_name)
	(classify_name): Update.
	* jv-exp.y (push_variable): Update.
	* m2-exp.y (variable): Update.
	* mi/mi-cmd-stack.c (list_args_or_locals): Update.
	* p-exp.y (block, variable, yylex): Update.
	* p-valprint.c (pascal_val_print): Update.
	* parse.c (write_dollar_variable): Update.
	* printcmd.c (address_info): Update.
	* python/py-symbol.c (gdbpy_lookup_symbol): Update.
	* symtab.c (lookup_symbol_aux, lookup_symbol_in_language)
	(lookup_symbol): Change type of 'is_a_field_of_this'.
	(check_field): Add 'is_a_field_of_this' argument.
	* symtab.h (struct field_of_this_result): New.
	(lookup_symbol, lookup_symbol_in_language): Update.
@
text
@d58 1
d2784 20
@


1.106
log
@	* ada-lang.c (ada_make_symbol_completion_list): Add 'code'
	argument, assertion.
	* c-exp.y (typebase): Add completion productions.
	* completer.c (expression_completer): Handle tag completion.
	* expression.h (parse_expression_for_completion): Add argument.
	* f-lang.c (f_make_symbol_completion_list): Add 'code'
	argument.
	* language.h (struct language_defn)
	<la_make_symbol_completion_list>: Add 'code' argument.
	* parse.c (expout_tag_completion_type, expout_completion_name):
	New globals.
	(mark_struct_expression): Add assertion.
	(mark_completion_tag): New function.
	(parse_exp_in_context): Initialize new globals.
	(parse_expression_for_completion): Add 'code' argument.  Handle
	tag completion.
	* parser-defs.h (mark_completion_tag): Declare.
	* symtab.c (default_make_symbol_completion_list_break_on): Add
	'code' argument.  Update.
	(default_make_symbol_completion_list): Add 'code' argument.
	(make_symbol_completion_list): Update.
	(make_symbol_completion_type): New function.
	* symtab.h (default_make_symbol_completion_list_break_on)
	(default_make_symbol_completion_list): Update.
	(make_symbol_completion_type): Declare.
testsuite
	* gdb.base/break1.c (enum some_enum, union some_union): New.
	(some_enum_global, some_union_global, some_value): New globals.
	* gdb.base/completion.exp: Add tag completion tests.
@
text
@d874 1
a874 1
					     VAR_DOMAIN, (int *) NULL);
d899 1
a899 1
					       VAR_DOMAIN, (int *) NULL);
d975 1
a975 1
					   VAR_DOMAIN, (int *) NULL);
d1580 2
d1586 3
a1588 1
						  &$$.is_a_field_of_this);
d2697 1
a2697 1
	    int is_a_field_of_this = 0;
d2754 1
a2754 1
  int is_a_field_of_this = 0;
d2758 4
d2764 1
a2764 1
		       ? &is_a_field_of_this : (int *) NULL);
d2769 1
a2769 1
      yylval.ssym.is_a_field_of_this = is_a_field_of_this;
d2823 1
a2823 1
	  yylval.ssym.is_a_field_of_this = is_a_field_of_this;
d2830 1
a2830 1
  yylval.ssym.is_a_field_of_this = is_a_field_of_this;
d2834 1
a2834 1
      && !is_a_field_of_this
@


1.105
log
@	* expression.h (parse_expression_for_completion): Rename
	from parse_field_expression.
	(parse_completion): Rename from in_parse_field.
	* c-exp.y (lex_one_token): Update.
	* completer.c (expression_completer): Update.
	* go-exp.y (lex_one_token): Update.
	* p-exp.y (yylex): Update.
	* parse.c (parse_completion): Rename from in_parse_field.
	(parse_exp_in_context): Update.
	(parse_expression_for_completion): Rename from
	parse_field_expression.  Update.
@
text
@d1271 11
d1285 11
d1299 11
d1313 11
@


1.104
log
@	* ada-exp.y (write_object_renaming, write_var_or_type)
	(write_ambiguous_var, write_var_from_sym): Make blocks const.
	* ada-lang.c (replace_operator_with_call)
	(find_old_style_renaming_symbol): Make blocks const.
	* ada-lang.h (ada_find_renaming_symbol): Update.
	(struct ada_symbol_info) <block>: Now const.
	* breakpoint.c (watch_command_1): Update.
	* breakpoint.h (struct watchpoint) <exp_valid_block,
	cond_exp_valid_block>: Now const.
	* c-exp.y (classify_inner_name, classify_name): Make block
	argument const.
	* expprint.c (print_subexp_standard) <OP_VAR_VALUE>: Make 'b'
	const.
	* expression.h (innermost_block, parse_exp_1): Update.
	(union exp_element) <block>: Now const.
	* gdbtypes.c (lookup_template_type, lookup_enum, lookup_union)
	(lookup_struct): Make block argument const.
	* gdbtypes.h (lookup_template_type): Update.
	* go-exp.y (classify_name, classify_packaged_name)
	(package_name_p): Make block argument const.
	* objc-lang.c (lookup_struct_typedef): Make block argument const.
	* objc-lang.h (lookup_struct_typedef): Update.
	* parse.c (parse_exp_in_context, parse_exp_1)
	(write_exp_elt_block): Make block arguments const.
	(expression_context_block, innermost_block): Now const.
	* parser-defs.h (write_exp_elt_block): Update.
	(expression_context_block, innermost_block, block_found): Now
	const.
	* printcmd.c (struct display) <block>: Now const.
	* symtab.h (lookup_struct, lookup_union, lookup_enum): Update.
	* valops.c (address_of_variable): Make block argument const.
	* value.h (value_of_variable): Update.
	* varobj.c (struct varobj_root) <valid_block>: Now const.
@
text
@d2357 1
a2357 1
	if (in_parse_field && tokentab2[i].token == ARROW)
d2420 1
a2420 1
	  if (in_parse_field)
d2672 1
a2672 1
  if (in_parse_field && *lexptr == '\0')
@


1.103
log
@	* ada-lang.c (user_select_syms, ada_print_subexp): Pass flags
	to type-printing functions.
	* ada-lang.h (ada_print_type): Add argument.
	* ada-typeprint.c (print_array_type, print_variant_clauses,
	print_variant_part, print_selected_record_field_types,
	print_record_field_types, print_unchecked_union_type,
	print_func_type, ada_print_type): Add flags argument.
	(ada_print_typedef): Update.
	* c-exp.y (OPERATOR conversion_type_id): Update.
	* c-lang.h (c_print_type, c_type_print_base): Update.
	* c-typeprint.c (c_print_type, c_type_print_varspec_prefix,
	c_type_print_modifier, c_type_print_args,
	c_type_print_varspec_suffix, c_type_print_base): Add flags
	argument.
	* cp-valprint.c (cp_print_class_member): Update.
	* dwarf2read.c (dwarf2_compute_name): Update.
	* f-lang.h (f_print_type): Add argument.
	* f-typeprint.c (f_print_type): Add flags argument.
	* gnu-v3-abi.c (gnuv3_print_method_ptr): Update.
	* go-lang.h (go_print_type): Add argument.
	* go-typeprint.c (go_print_type): Add flags argument.
	* jv-lang.h (java_print_type): Add argument.
	* jv-typeprint.c (java_type_print_base, java_print_type): Add
	flags argument.
	* language.c (unk_lang_print_type): Add flags argument.
	* language.h (struct language_defn) <la_print_type>: Add flags
	argument.
	(LA_PRINT_TYPE): Likewise.
	* m2-lang.h (m2_print_type): Add argument.
	* m2-typeprint.c (m2_print_type, m2_range, m2_typedef,
	m2_array, m2_pointer, m2_ref, m2_procedure, m2_long_set,
	m2_unbounded_array, m2_record_fields): Add flags argument.
	* p-lang.h (pascal_print_type, pascal_type_print_base,
	pascal_type_print_varspec_prefix): Add argument.
	* p-typeprint.c (pascal_print_type,
	pascal_type_print_varspec_prefix, pascal_print_func_args,
	pascal_type_print_varspec_suffix, pascal_type_print_base): Add
	flags argument.
	* symmisc.c (print_symbol): Update.
	* typeprint.c (type_print_raw_options, default_ptype_flags):
	New globals.
	(type_print): Update.
	* typeprint.h (struct type_print_options): New.
	(type_print_raw_options): Declare.
	(c_type_print_varspec_suffix, c_type_print_args): Add argument.
@
text
@d2702 1
a2702 1
classify_name (struct block *block)
d2794 1
a2794 1
classify_inner_name (struct block *block, int first_name)
@


1.102
log
@	* c-exp.y (classify_name): Avoid assignment in condition.
@
text
@d57 1
d1506 2
a1507 1
			  c_print_type ($2, NULL, buf, -1, 0);
@


1.101
log
@    	* Makefile.in (SFILES): Remove objc-exp.y.
    	(YYFILES): Remove objc-exp.c.
    	(YYOBJ): Remove objc-exp.o.
    	(local-maintainer-clean): Don't mention objc-exp.c.
    	* c-exp.y: Include objc-lang.h.
    	(%union) <class>: New field.
    	(NSSTRING, SELECTOR, CLASSNAME, OBJC_LBRAC): New tokens.
    	(exp): Clone subscript production for OBJC_LBRAC.  Add various
    	Objective C productions.
    	(msglist, msgarglist, msgarg): New productions.
    	(array_mod, func_mod, operator): Clone productions for
    	OBJC_LBRAC.
    	(parse_string_or_char): Handle '@@' strings.
    	(lex_one_token): Return OBJC_LBRAC.  Recognize @@selector.
    	(classify_name): Check la_name_of_this.  Recognize ObjC class
    	names.
    	* objc-exp.y: Remove.
    	* objc-lang.c (objc_language_defn): Use c_parse, c_error.
    	* objc-lang.h (objc_parse, objc_error): Don't declare.
gdb/testsuite
    	* gdb.objc/print.exp (test_float_accepted): Remove kfails.
@
text
@d2750 2
a2751 2
	  if ((sym = lookup_struct_typedef (copy, expression_context_block,
					    1)))
@


1.100
log
@	PR exp/13206:
	* ax-gdb.c (gen_expr) <OP_TYPEOF, OP_DECLTYPE>: New cases.
	* breakpoint.c (watchpoint_exp_is_const) <OP_TYPEOF,
	OP_DECLTYPE>: New cases.
	* c-exp.y (TYPEOF, DECLTYPE): New tokens.
	(type_exp): Add new productions.
	(ident_tokens): Add __typeof__, typeof, __typeof, __decltype,
	and decltype.
	* eval.c (evaluate_subexp_standard) <OP_TYPEOF, OP_DECLTYPE>:
	New case.
	* expprint.c (dump_subexp_body_standard) <OP_TYPEOF,
	OP_DECLTYPE>: New case.
	* parse.c (operator_length_standard) <OP_TYPEOF, OP_DECLTYPE>:
	New case.
	* std-operator.def (OP_TYPEOF, OP_DECLTYPE): New constants.
	* varobj.c (varobj_create): Handle OP_TYPEOF, OP_DECLTYPE.
gdb/testsuite
	* gdb.cp/casts.exp: Add tests for typeof and decltype.
	* gdb.cp/casts.cc (decltype): New function.
	(main): Use it.
@
text
@d56 1
d163 2
d200 2
d207 1
d213 5
d265 1
a265 1
%right ARROW ARROW_STAR '.' DOT_STAR '[' '('
d425 72
d727 7
d831 8
d1127 2
d1131 2
d1398 4
d1498 2
d2008 1
d2041 7
d2095 1
a2095 1
  return quote == '"' ? STRING : CHAR;
d2394 2
d2492 14
d2545 2
d2709 1
a2709 1
		       parse_language->la_language == language_cplus
d2743 14
@


1.99
log
@	* c-exp.y (enum token_flags): New.
	(struct token) <cxx_only>: Remove.
	<flags>: New field.
	(tokentab3, tokentab2, ident_tokens): Update.
	(lex_one_token): Update.  Handle FLAG_SHADOW.
@
text
@d222 2
d273 14
d2078 7
a2084 1
    {"reinterpret_cast", REINTERPRET_CAST, OP_NULL, FLAG_CXX }
@


1.98
log
@	* ax-gdb.c (gen_expr): Handle UNOP_CAST_TYPE, UNOP_MEMVAL_TYPE.
	* breakpoint.c (watchpoint_exp_is_const): Handle UNOP_CAST_TYPE,
	UNOP_REINTERPRET_CAST, UNOP_DYNAMIC_CAST.
	* c-exp.y (exp): Emit UNOP_MEMVAL_TYPE, UNOP_CAST_TYPE.  Update
	for changes to UNOP_REINTERPRET_CAST, UNOP_DYNAMIC_CAST.  Use
	type_exp production where appropriate.
	* eval.c (evaluate_subexp_standard) <UNOP_CAST_TYPE>: New case.
	<UNOP_DYNAMIC_CAST, UNOP_REINTERPRET_CAST>: Update.
	<UNOP_MEMVAL_TYPE>: New case.
	(evaluate_subexp_for_address) <UNOP_MEMVAL_TYPE>: New case.
	(evaluate_subexp_for_sizeof) <UNOP_MEMVAL_TYPE>: New case.
	* expprint.c (print_subexp_standard) <UNOP_CAST_TYPE>: New case.
	<UNOP_MEMVAL_TYPE>: New case.
	(dump_subexp_body_standard) <UNOP_DYNAMIC_CAST,
	UNOP_REINTERPRET_CAST>: Update.
	<UNOP_CAST_TYPE, UNOP_MEMVAL_TYPE>: New cases.
	* parse.c (operator_length_standard) <UNOP_DYNAMIC_CAST,
	UNOP_REINTERPRET_CAST>: Update.
	<UNOP_CAST_TYPE, UNOP_MEMVAL_TYPE>: New cases.
	* stack.c (return_command): Also check for UNOP_CAST_TYPE.
	* std-operator.def (UNOP_CAST_TYPE, UNOP_MEMVAL_TYPE): New
	constants.
@
text
@d1966 15
d1986 1
a1986 1
  int cxx_only;
d1993 1
a1993 1
    {"->*", ARROW_STAR, BINOP_END, 1},
d2021 1
a2021 1
    {".*", DOT_STAR, BINOP_END, 1}
d2028 1
a2028 1
    {"template", TEMPLATE, OP_NULL, 1},
d2034 2
a2035 2
    {"false", FALSEKEYWORD, OP_NULL, 1},
    {"class", CLASS, OP_NULL, 1},
d2041 1
a2041 1
    {"true", TRUEKEYWORD, OP_NULL, 1},
d2043 20
a2062 20
    {"new", NEW, OP_NULL, 1},
    {"delete", DELETE, OP_NULL, 1},
    {"operator", OPERATOR, OP_NULL, 1},

    {"and", ANDAND, BINOP_END, 1},
    {"and_eq", ASSIGN_MODIFY, BINOP_BITWISE_AND, 1},
    {"bitand", '&', OP_NULL, 1},
    {"bitor", '|', OP_NULL, 1},
    {"compl", '~', OP_NULL, 1},
    {"not", '!', OP_NULL, 1},
    {"not_eq", NOTEQUAL, BINOP_END, 1},
    {"or", OROR, BINOP_END, 1},
    {"or_eq", ASSIGN_MODIFY, BINOP_BITWISE_IOR, 1},
    {"xor", '^', OP_NULL, 1},
    {"xor_eq", ASSIGN_MODIFY, BINOP_BITWISE_XOR, 1},

    {"const_cast", CONST_CAST, OP_NULL, 1 },
    {"dynamic_cast", DYNAMIC_CAST, OP_NULL, 1 },
    {"static_cast", STATIC_CAST, OP_NULL, 1 },
    {"reinterpret_cast", REINTERPRET_CAST, OP_NULL, 1 }
d2198 1
a2198 1
	if (tokentab3[i].cxx_only
d2211 1
a2211 1
	if (tokentab2[i].cxx_only
d2485 1
a2485 1
	if (ident_tokens[i].cxx_only
d2489 16
@


1.97
log
@	* c-exp.y (check_parameter_typelist): New function.
	(parameter_typelist): Call it.
	* eval.c (make_params): Handle '(void)' case.
	* gdbtypes.c (lookup_function_type_with_arguments): Handle
	'(void)' case.
testsuite
	* gdb.base/whatis.exp: Add error checks for improper 'void' uses.
	* gdb.base/callfuncs.exp: Add cast-based test.
	* gdb.base/callfuncs.c (voidfunc): New function.
@
text
@d474 2
a475 4
exp	:	lcurly type rcurly exp  %prec UNARY
			{ write_exp_elt_opcode (UNOP_MEMVAL);
			  write_exp_elt_type ($2);
			  write_exp_elt_opcode (UNOP_MEMVAL); }
d478 2
a479 4
exp	:	'(' type ')' exp  %prec UNARY
			{ write_exp_elt_opcode (UNOP_CAST);
			  write_exp_elt_type ($2);
			  write_exp_elt_opcode (UNOP_CAST); }
d638 2
a639 4
exp	:	REINTERPRET_CAST '<' type '>' '(' exp ')' %prec UNARY
			{ write_exp_elt_opcode (UNOP_REINTERPRET_CAST);
			  write_exp_elt_type ($3);
			  write_exp_elt_opcode (UNOP_REINTERPRET_CAST); }
d642 2
a643 4
exp	:	STATIC_CAST '<' type '>' '(' exp ')' %prec UNARY
			{ write_exp_elt_opcode (UNOP_CAST);
			  write_exp_elt_type ($3);
			  write_exp_elt_opcode (UNOP_CAST); }
d646 2
a647 4
exp	:	DYNAMIC_CAST '<' type '>' '(' exp ')' %prec UNARY
			{ write_exp_elt_opcode (UNOP_DYNAMIC_CAST);
			  write_exp_elt_type ($3);
			  write_exp_elt_opcode (UNOP_DYNAMIC_CAST); }
d650 1
a650 1
exp	:	CONST_CAST '<' type '>' '(' exp ')' %prec UNARY
d653 1
a653 3
			  write_exp_elt_opcode (UNOP_CAST);
			  write_exp_elt_type ($3);
			  write_exp_elt_opcode (UNOP_CAST); }
@


1.96
log
@	* c-exp.y (DOTDOTDOT): New token.
	(func_mod, exp): Use parameter_typelist.
	(parameter_typelist): New production.
	(tokentab3): Add "..." token.
	* eval.c (make_params): Handle varargs.
	* gdbtypes.c (lookup_function_type_with_arguments): Handle
	varargs.
testsuite
	* gdb.base/whatis.exp: Add test.
@
text
@d168 1
d1231 1
d1235 1
d1450 31
@


1.95
log
@	PR exp/9608:
	* c-exp.y (%union) <tvec>: Change type.
	(func_mod): Now uses <tvec> type.
	(exp): Update for tvec change.
	(direct_abs_decl): Push the typelist.
	(func_mod): Return a typelist.
	(nonempty_typelist): Update for tvec change.
	* gdbtypes.c (lookup_function_type_with_arguments): New function.
	* gdbtypes.h (lookup_function_type_with_arguments): Declare.
	* parse.c (pop_type_list): New function.
	(push_typelist): New function.
	(follow_types): Handle tp_function_with_arguments.
	* parser-defs.h (type_ptr): New typedef.  Define a VEC.
	(enum type_pieces) <tp_function_with_arguments>: New constant.
	(union type_stack_elt) <typelist_val>: New field.
	(push_typelist): Declare.
testsuite
	* gdb.base/whatis.exp: Add regression test.
@
text
@d173 1
a173 1
%type <tvec> nonempty_typelist func_mod
d257 2
d445 1
a445 1
exp     :       exp '(' nonempty_typelist ')' const_or_volatile
d1030 1
a1030 1
	|	'(' nonempty_typelist ')'
d1228 9
d1956 2
a1957 1
    {"->*", ARROW_STAR, BINOP_END, 1}
@


1.94
log
@	* c-exp.y (%union) <type_stack>: New field.
	(abs_decl, direct_abs_decl): Use <type_stack> type.  Update.
	(ptr_operator_ts): New production.
	(ptype): Update.
	* parse.c (type_stack_reserve): New function.
	(check_type_stack_depth): Use it.
	(pop_type_stack, append_type_stack, push_type_stack)
	(get_type_stack, type_stack_cleanup): New functions.
	(follow_types): Handle tp_type_stack.
	(_initialize_parse): Simplify initialization.
	* parser-defs.h (enum type_pieces) <tp_type_stack>: New
	constant.
	(union type_stack_elt) <stack_val>: New field.
	(get_type_stack, append_type_stack, push_type_stack)
	(type_stack_cleanup): Declare.
testsuite
	* gdb.base/whatis.exp: Add tests.
@
text
@d158 1
a158 1
    struct type **tvec;
d173 1
a173 1
%type <tvec> nonempty_typelist
d445 4
d450 6
a455 4
			  write_exp_elt_longcst ((LONGEST) $<ivec>3[0]);
			  for (i = 0; i < $<ivec>3[0]; ++i)
			    write_exp_elt_type ($<tvec>3[i + 1]);
			  write_exp_elt_longcst((LONGEST) $<ivec>3[0]);
d457 1
a457 1
			  free ($3);
d1010 1
a1010 1
			  push_type (tp_function);
d1015 1
a1015 1
			  push_type (tp_function);
d1027 1
d1029 1
a1029 1
			{ free ($2); }
d1228 4
a1231 3
		{ $$ = (struct type **) malloc (sizeof (struct type *) * 2);
		  $<ivec>$[0] = 1;	/* Number of types in vector */
		  $$[1] = $1;
d1234 3
a1236 3
		{ int len = sizeof (struct type *) * (++($<ivec>1[0]) + 1);
		  $$ = (struct type **) realloc ((char *) $1, len);
		  $$[$<ivec>$[0]] = $3;
@


1.93
log
@	* c-exp.y (func_mod, direct_abs_decl, abs_decl, ptr_operator):
	Remove %type.
@
text
@d160 2
d181 2
d970 12
a981 2
abs_decl:	ptr_operator direct_abs_decl
	|	ptr_operator
d986 1
d989 1
d992 1
d998 1
d1002 5
a1006 1
			{ push_type (tp_function); }
d1008 4
a1011 1
			{ push_type (tp_function); }
d1234 4
a1237 1
		{ $$ = follow_types ($1); }
@


1.92
log
@	PR exp/9514:
	* parser-defs.h (insert_type, insert_type_address_space): Declare.
	(push_type_address_space): Remove.
	* parse.c (insert_into_type_stack): New function.
	(insert_type): Likewise.
	(insert_type_address_space): Rename from push_type_address_space.
	Insert tp_space_identifier.
	* c-exp.y (ptr_operator): New production.
	(abs_decl): Use ptr_operator.
	(space_identifier): Call insert_type_address_space.
	(ptype): Don't use const_or_volatile_or_space_identifier.
	(const_or_volatile_noopt): Call insert_type.
	(conversion_type_id, conversion_declarator): New productions.
	(operator): Use conversion_type_id.
testsuite
	* gdb.base/whatis.exp: Add tests.
@
text
@a174 1
%type <voidval> func_mod direct_abs_decl abs_decl ptr_operator
a956 1
			{ $$ = 0; }
a959 1
			{ $$ = 0; }
d961 1
a961 1
			{ insert_type (tp_reference); $$ = 0; }
d963 1
a963 1
			{ insert_type (tp_reference); $$ = 0; }
a971 1
			{ $$ = $2; }
a980 1
			  $$ = 0;
a995 1
			{ $$ = 0; }
d997 1
a997 1
			{ free ($2); $$ = 0; }
@


1.91
log
@	* c-exp.y (operator): Remove trailing space after "delete" and
	"delete[]".
@
text
@d175 1
a175 1
%type <voidval> func_mod direct_abs_decl abs_decl
d178 1
d935 1
a935 3
		{ push_type_address_space (copy_name ($2.stoken));
		  push_type (tp_space_identifier);
		}
d954 9
a962 4
abs_decl:	'*'
			{ push_type (tp_pointer); $$ = 0; }
	|	'*' abs_decl
			{ push_type (tp_pointer); $$ = $2; }
d964 7
a970 3
			{ push_type (tp_reference); $$ = 0; }
	|	'&' abs_decl
			{ push_type (tp_reference); $$ = $2; }
d1214 1
a1214 1
	|	ptype const_or_volatile_or_space_identifier abs_decl const_or_volatile_or_space_identifier
d1218 8
d1231 2
a1232 2
			{ push_type (tp_const);
			  push_type (tp_volatile); 
d1235 1
a1235 1
			{ push_type (tp_const); }
d1237 1
a1237 1
			{ push_type (tp_volatile); }
d1344 1
a1344 1
	|	OPERATOR ptype
@


1.90
log
@gdb/
	PR c++/14177 - Fix parsing TYPENAME:: in parentheses.
	* c-exp.y (classify_inner_name): Remove caller assumptions in the
	function comment.  Return ERROR for unresolved cases.  Implement
	returning proper NAME.
	(yylex): Accept also NAME from classify_inner_name.
	* cp-namespace.c (cp_lookup_nested_type): Rename to ...
	(cp_lookup_nested_symbol): ... here.  Return any found symbol, not just
	LOC_TYPEDEF type.
	* cp-support.h (cp_lookup_nested_type): Update its declaration.

gdb/testsuite/
	PR c++/14177 - Fix parsing TYPENAME:: in parentheses.
	* gdb.cp/cpexprs.cc (class CV, CV::i, ATTRIBUTE_USED, CV_f): New.
	(test_function): Call CV_f.
	* gdb.cp/cpexprs.exp (p 'CV::m(int)', p CV::m(int))
	(p 'CV::m(int) const', p CV::m(int) const, p 'CV::m(int) volatile')
	(p CV::m(int) volatile, p 'CV::m(int) const volatile')
	(p CV::m(int) const volatile, p CV_f(int), p CV_f(CV::t))
	(p CV_f(CV::i)): New tests.
@
text
@d1227 1
a1227 1
			{ $$ = operator_stoken (" delete "); }
d1231 1
a1231 1
			{ $$ = operator_stoken (" delete[] "); }
@


1.89
log
@2012-05-18  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c:
	* avr-tdep.c:
	* ax-gdb.c:
	* bfin-linux-tdep.c:
	* breakpoint.c:
	* c-valprint.c:
	* cli/cli-cmds.c:
	* coffread.c:
	* cp-support.c:
	* cris-tdep.c:
	* dwarf2-frame-tailcall.c:
	* dwarf2-frame.c:
	* dwarf2expr.c:
	* dwarf2loc.c:
	* dwarf2read.c:
	* elfread.c:
	* eval.c:
	* expprint.c:
	* f-valprint.c:
	* frv-tdep.c:
	* h8300-tdep.c:
	* hppa-hpux-tdep.c:
	* hppa-tdep.c:
	* hppanbsd-tdep.c:
	* i386-nto-tdep.c:
	* i386-tdep.c:
	* i387-tdep.c:
	* ia64-tdep.c:
	* jit.c:
	* linespec.c:
	* linux-tdep.c:
	* lm32-tdep.c:
	* m2-valprint.c:
	* m32c-tdep.c:
	* m32r-rom.c:
	* m32r-tdep.c:
	* m68k-tdep.c:
	* m68klinux-tdep.c:
	* mi/mi-main.c:
	* microblaze-tdep.c:
	* mips-linux-tdep.c:
	* mips-tdep.c:
	* mn10300-tdep.c:
	* p-valprint.c:
	* parse.c:
	* ppc-linux-tdep.c:
	* ppc-sysv-tdep.c:
	* printcmd.c:
	* python/py-finishbreakpoint.c:
	* python/py-inferior.c:
	* python/py-infthread.c:
	* python/py-type.c:
	* python/python.c:
	* remote-fileio.c:
	* remote-m32r-sdi.c:
	* remote-mips.c:
	* reverse.c:
	* rl78-tdep.c:
	* rs6000-aix-tdep.c:
	* rs6000-tdep.c:
	* s390-tdep.c:
	* score-tdep.c:
	* sh64-tdep.c:
	* skip.c:
	* solib-darwin.c:
	* solib-dsbt.c:
	* solib-frv.c:
	* sparc-tdep.c:
	* spu-multiarch.c:
	* spu-tdep.c:
	* stack.c:
	* symfile.c:
	* symtab.c:
	* tic6x-tdep.c:
	* tracepoint.c:
	* v850-tdep.c:
	* valarith.c:
	* valprint.c:
	* value.c:
	* xcoffread.c:
	* xtensa-tdep.c:
	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c: Delete unused variables.
@
text
@d2508 2
a2509 3
   in `yylval' is the first component of a name, false otherwise.  If
   this function returns NAME, it might not have updated `yylval'.
   This is ok because the caller only cares about TYPENAME.  */
d2523 1
a2523 2
    /* We know the caller won't expect us to update yylval.  */
    return NAME;
d2526 3
a2528 1
  new_type = cp_lookup_nested_type (yylval.tsym.type, copy, block);
d2530 15
a2544 6
  if (new_type == NULL)
    /* We know the caller won't expect us to update yylval.  */
    return NAME;

  yylval.tsym.type = new_type;
  return TYPENAME;
d2604 1
a2604 1
	  if (classification != TYPENAME)
@


1.88
log
@* ada-exp.y (yyss, yysslim, yyssp, yystacksize, yyvs, yyvsp): New
defines.
* c-exp.y (yyss, yysslim, yyssp, yystacksize, yyvs, yyvsp): New
defines.
* cp-name-parser.y (yyss, yysslim, yyssp, yystacksize, yyvs)
(yyvsp): New defines.
* f-exp.y (yyss, yysslim, yyssp, yystacksize, yyvs, yyvsp): New
defines.
* jv-exp.y (yyss, yysslim, yyssp, yystacksize, yyvs, yyvsp): New
defines.
* m2-exp.y (yyss, yysslim, yyssp, yystacksize, yyvs, yyvsp): New
defines.
* objc-exp.y (yyss, yysslim, yyssp, yystacksize, yyvs, yyvsp): New
defines.
* p-exp.y (yyss, yysslim, yyssp, yystacksize, yyvs, yyvsp): New
defines.
@
text
@a1421 3
      const char *suffix;
      int suffix_len;

@


1.87
log
@Have block_innermost_frame start from selected frame and document.

GDB used to search for the frame containing variables in a particular
lexical block starting from the current (top) frame, ignoring any
currently selected frame.  It is not clear why this is desirable for
variables that require a frame; why would a user deliberately select
one frame and then expect to see the value of a variable in a more
recent frame?  This change causes block_innermost_frame to start
looking from the selected frame, if there is one.  It may be
unnecessarily conservative: we use get_selected_frame_if_set rather
than get_selected_frame in order to avoid the side effect of calling
select_frame, which would probably be harmless.

Expression-parsing routines previously made the unwarranted assumption
that all block-qualified variables (written with the GDB extension
<block>::<variable>) are static.  As a result, they failed to update
innermost_block, which confused the watch commands about when
variables in watched expressions went out of scope, and also caused
the wrong variables to be watched.  This patch also modifies these
routines to treat all local variables the same whether or not they are
block-qualified.

Finally, we add a paragraph to the "Program Variables" section of the texinfo
documentation concerning the use of "::" for accessing non-static variables.

2012-01-11  Paul Hilfinger  <hilfingr@@adacore.com>

	* gdb/blockframe.c (block_innermost_frame): Start search from selected
	frame, if present, or otherwise the current frame.

	* gdb/c-exp.y (variable): Update innermost_block for
	'block COLONCOLON NAME' clause.
	* gdb/m2-exp.y (variable): Ditto.
	* gdb/objc-exp.y (variable): Ditto.

	* gdb/doc/gdb.texinfo (Variables): Document use of :: for non-static
	variables.
@
text
@d106 6
@


1.86
log
@gdb/
	Fix regression after libiberty/ update for GCC PR 6057 and others.
	* c-exp.y (operator) <OPERATOR DELETE>
	(operator) <OPERATOR DELETE '[' ']'>: Add trailing space.
	* cp-name-parser.y (fill_comp, make_operator, make_dtor)
	(make_builtin_type, make_name): New variable i, add gdb_assert.
	(operator) <OPERATOR NEW>: Update ARGS to 3.
	(operator) <OPERATOR DELETE>: Add trailing space.
	(operator) <OPERATOR NEW '[' ']'>: Update ARGS to 3.
	(operator) <OPERATOR DELETE '[' ']'>: Add trailing space.
	* cp-support.c (cp_canonicalize_string): Check NULL from
	cp_comp_to_string, call warning and return.
@
text
@d781 7
@


1.85
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d1214 1
a1214 1
			{ $$ = operator_stoken (" delete"); }
d1218 1
a1218 1
			{ $$ = operator_stoken (" delete[]"); }
@


1.84
log
@gdb/
	Revert this part of:
	2011-10-09  Jan Kratochvil  <jan.kratochvil@@redhat.com>
	Support @@entry in input expressions.
	* c-exp.y (ENTRY, unknown_cpp_name): New.
	(exp: UNKNOWN_CPP_NAME): Change to `exp: unknown_cpp_name'.
	(unknown_cpp_name: UNKNOWN_CPP_NAME, unknown_cpp_name: ENTRY)
	(variable: name_not_typename '@@' ENTRY, name: ENTRY)
	(name_not_typename: ENTRY): New.
	(yylex): Recognize ENTRY.

	Reimplement @@entry in input expressions.
	* c-exp.y (ENTRY): New.
	(variable: name_not_typename ENTRY): New.
	(lex_one_token): Optionally return ENTRY instead of the '@@' lex.

gdb/testsuite/
	Reimplement @@entry in input expressions.
	* gdb.base/exprs.c (v_int_array_init): New variable.
	* gdb.base/exprs.exp (print v_int_array_init)
	(print *v_int_array_init@@1, print *v_int_array_init@@2)
	(print v_int_array_init[0]@@1, print v_int_array_init[0]@@2)
	(print v_int_array_init[1]@@1): New tests.
@
text
@d2 2
a3 3
   Copyright (C) 1986, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997,
   1998, 1999, 2000, 2003, 2004, 2006, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.84.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 3
a4 2
   Copyright (C) 1986, 1989-2000, 2003-2004, 2006-2012 Free Software
   Foundation, Inc.
@


1.83
log
@gdb/
	Support @@entry in input expressions.
	* c-exp.y (ENTRY, unknown_cpp_name): New.
	(exp: UNKNOWN_CPP_NAME): Change to `exp: unknown_cpp_name'.
	(unknown_cpp_name: UNKNOWN_CPP_NAME, unknown_cpp_name: ENTRY)
	(variable: name_not_typename '@@' ENTRY, name: ENTRY)
	(name_not_typename: ENTRY): New.
	(yylex): Recognize ENTRY.
	* eval.c (evaluate_subexp_standard): Support also OP_VAR_ENTRY_VALUE.
	* expprint.c (print_subexp_standard, dump_subexp_body_standard):
	Likewise.
	* parse.c (operator_length_standard): Likewise.
	* std-operator.def: New operator OP_VAR_ENTRY_VALUE.

gdb/doc/
	Support @@entry in input expressions.
	* gdb.texinfo (Variables): Describe @@entry names suffix.
	(Print Settings): Add anchor for `set print entry-values'.

gdb/testsuite/
	Support @@entry in input expressions.
	* gdb.arch/amd64-entry-value.exp (entry: p i@@entry, entry: p j@@entry)
	(entry_stack: p s1@@entry, entry_stack: p s2@@entry)
	(entry_stack: p d9@@entry, entry_stack: p da@@entry, tailcall: p i@@entry)
	(tailcall: p j@@entry): New tests.
	* gdb.cp/koenig.cc (A::entry): New function.
	(main): Call it.
	* gdb.cp/koenig.exp (p entry (c)): New test.
@
text
@a188 1
%token <ssym> ENTRY
a196 3
/* It is UNKNOWN_CPP_NAME or ENTRY, depending on the context.  */
%type <ssym> unknown_cpp_name

d211 1
d396 1
a396 1
exp	:	unknown_cpp_name '('
a418 4
unknown_cpp_name	: UNKNOWN_CPP_NAME
			| ENTRY
			;

d760 1
a760 1
variable:	name_not_typename '@@' ENTRY
a1335 1
	|	ENTRY { $$ = $1.stoken; }
a1340 1
	|	ENTRY
d2243 15
a2267 1
    case '@@':
a2557 5
  if ((current.token == NAME || current.token == UNKNOWN_CPP_NAME)
      && yylval.sval.length == strlen ("entry")
      && strncmp (yylval.sval.ptr, "entry", strlen ("entry")) == 0)
    current.token = ENTRY;

@


1.82
log
@gdb/
	* c-exp.y (qualified_name): Call destructor_name_p with $1.type.
	(classify_inner_name): Call cp_lookup_nested_type with
	yylval.tsym.type.
	* cp-namespace.c (cp_lookup_nested_type): New variable
	saved_parent_type.  Call CHECK_TYPEDEF for parent_type.  Call
	type_name_no_tag_or_error with saved_parent_type.
	* dwarf2read.c (load_partial_dies): Read in any children of
	DW_TAG_typedef with complaint in such case.
	* gdbtypes.c (type_name_no_tag_or_error): New function.
	* gdbtypes.h (type_name_no_tag_or_error): New prototype.
	* valops.c (destructor_name_p): New comment for parameter type.  Remove
	type const.  Make dname and cp const.  Call type_name_no_tag_or_error.
	* value.h (destructor_name_p): Remove type const.
@
text
@d189 1
d198 3
d399 1
a399 1
exp	:	UNKNOWN_CPP_NAME '('
d422 4
d767 15
d1343 1
d1349 1
d2553 5
@


1.81
log
@	ARI fixes: Add missing internationalization markups throughout
	yacc files.
	* c-exp.y: Ditto.
	* cp-name-parser.y: Ditto.
	* f-exp.y: Ditto.
	* m2-exp.y: Ditto.
	* objc-exp.y: Ditto.
	* p-exp.y: Ditto.
@
text
@d807 1
a807 1
			  destructor_name_p (tmp_token.ptr, type);
d2489 1
a2489 1
  new_type = cp_lookup_nested_type (type, copy, block);
@


1.80
log
@run copyright.sh for 2011.
@
text
@d701 1
a701 1
				    error ("Undefined string concatenation.");
d740 1
a740 1
			    error ("No file or function \"%s\".",
d754 1
a754 1
			    error ("No function \"%s\" in specified context.",
d764 1
a764 1
			    error ("No symbol \"%s\" in specified context.",
d781 1
a781 1
			    error ("`%s' is not defined as an aggregate type.",
d797 1
a797 1
			    error ("`%s' is not defined as an aggregate type.",
d845 1
a845 1
			    error ("No symbol table is loaded.  Use the \"file\" command.");
d847 1
a847 1
			    error ("No symbol \"%s\" in current context.", name);
d897 1
a897 1
				error ("No symbol table is loaded.  Use the \"file\" command.");
d899 1
a899 1
				error ("No symbol \"%s\" in current context.",
d1530 1
a1530 1
	    error ("Numeric constant too large.");
d1847 1
a1847 1
	error ("Unterminated string in expression.");
d1849 1
a1849 1
	error ("Unmatched single quote.");
d2221 1
a2221 1
	    error ("Invalid number \"%s\".", err_copy);
d2264 1
a2264 1
	      error ("Empty character constant.");
d2272 1
a2272 1
	      error ("Invalid character constant.");
d2281 1
a2281 1
    error ("Invalid character '%c' in expression.", c);
d2661 1
a2661 1
  error ("A %s in expression, near `%s'.", (msg ? msg : "error"), lexptr);
@


1.79
log
@gdb:
	* NEWS: Mention OpenCL C language support.
	* Makefile.in (SFILES): Add opencl-lang.c.
	(COMMON_OBS): Add opencl-lang.o.
	* opencl-lang.c: New File
	* defs.h (enum language): Add language_opencl.
	* dwarf2read.c (read_file_scope): Handle DW_AT_producer for the
	IBM XL C OpenCL compiler.
	* c-lang.h: Include "parser-defs.h".
	(evaluate_subexp_c): Declare.
	* c-lang.c (evaluate_subexp_c): Remove the static qualifier.
	(c_op_print_tab): Add declaration.
	* eval.c (binop_promote): Handle language_opencl.
	* c-exp.y: Lookup the primitive types instead of referring to the
	builtins.

gdb/testsuite:
	* Makefile.in (ALL_SUBDIRS): Add gdb.opencl.
	* configure.ac (AC_OUTPUT): Add gdb.opencl/Makefile.
	* configure: Regenerate.
	* gdb.opencl/Makefile.in: New File.
	* gdb.opencl/datatypes.exp: Likewise.
	* gdb.opencl/datatypes.cl: Likewise.
	* gdb.opencl/operators.exp: Likewise.
	* gdb.opencl/operators.cl: Likewise.
	* gdb.opencl/vec_comps.exp: Likewise.
	* gdb.opencl/vec_comps.cl: Likewise.
	* gdb.opencl/convs_casts.exp: Likewise.
	* gdb.opencl/convs_casts.cl: Likewise.
	* lib/opencl.exp: Likewise.
	* lib/opencl_hostapp.c: Likewise.
	* lib/opencl_kernel.cl: Likewise.
	* lib/cl_util.c: Likewise.
	* lib/cl_util.c: Likewise.
	* gdb.base/default.exp (set language): Add "opencl" to the list of
	languages.

gdb/doc:
	* gdb.texinfo: (Summary) Add mention about OpenCL C language support.
	(OpenCL C): New node.
@
text
@d3 1
a3 1
   1998, 1999, 2000, 2003, 2004, 2006, 2007, 2008, 2009, 2010
@


1.78
log
@Fix PR 11992: C++ 'this' scope sometimes does not work

2010-09-13  Sami Wagiaalla  <swagiaal@@redhat.com>

	PR symtab/11992:
	* c-exp.y (classify_name): Check is_a_member_of_this before returning
	UNKNOWN_CPP_NAME.

2010-09-13  Sami Wagiaalla  <swagiaal@@redhat.com>

	* gdb.cp/koenig.cc: created class for testing member lookup.
	* gdb.cp/koenig.exp: Added test for member lookup.
@
text
@d615 3
a617 1
			  write_exp_elt_type (parse_type->builtin_int);
d985 3
a987 1
			{ $$ = parse_type->builtin_int; }
d989 3
a991 1
			{ $$ = parse_type->builtin_long; }
d993 3
a995 1
			{ $$ = parse_type->builtin_short; }
d997 3
a999 1
			{ $$ = parse_type->builtin_long; }
d1001 3
a1003 1
			{ $$ = parse_type->builtin_long; }
d1005 3
a1007 1
			{ $$ = parse_type->builtin_long; }
d1009 3
a1011 1
			{ $$ = parse_type->builtin_long; }
d1013 3
a1015 1
			{ $$ = parse_type->builtin_unsigned_long; }
d1017 3
a1019 1
			{ $$ = parse_type->builtin_unsigned_long; }
d1021 3
a1023 1
			{ $$ = parse_type->builtin_unsigned_long; }
d1025 3
a1027 1
			{ $$ = parse_type->builtin_long_long; }
d1029 3
a1031 1
			{ $$ = parse_type->builtin_long_long; }
d1033 3
a1035 1
			{ $$ = parse_type->builtin_long_long; }
d1037 3
a1039 1
			{ $$ = parse_type->builtin_long_long; }
d1041 3
a1043 1
			{ $$ = parse_type->builtin_long_long; }
d1045 3
a1047 1
			{ $$ = parse_type->builtin_long_long; }
d1049 3
a1051 1
			{ $$ = parse_type->builtin_unsigned_long_long; }
d1053 3
a1055 1
			{ $$ = parse_type->builtin_unsigned_long_long; }
d1057 3
a1059 1
			{ $$ = parse_type->builtin_unsigned_long_long; }
d1061 3
a1063 1
			{ $$ = parse_type->builtin_unsigned_long_long; }
d1065 3
a1067 1
			{ $$ = parse_type->builtin_short; }
d1069 3
a1071 1
			{ $$ = parse_type->builtin_short; }
d1073 3
a1075 1
			{ $$ = parse_type->builtin_short; }
d1077 3
a1079 1
			{ $$ = parse_type->builtin_unsigned_short; }
d1081 3
a1083 1
			{ $$ = parse_type->builtin_unsigned_short; }
d1085 3
a1087 1
			{ $$ = parse_type->builtin_unsigned_short; }
d1089 3
a1091 1
			{ $$ = parse_type->builtin_double; }
d1093 3
a1095 1
			{ $$ = parse_type->builtin_long_double; }
d1113 3
a1115 1
			{ $$ = parse_type->builtin_unsigned_int; }
d1121 3
a1123 1
			{ $$ = parse_type->builtin_int; }
d1142 3
a1144 1
		  $$.type = parse_type->builtin_int;
d1150 3
a1152 1
		  $$.type = parse_type->builtin_long;
d1158 3
a1160 1
		  $$.type = parse_type->builtin_short;
@


1.77
log
@	PR exp/11926
	* parser-defs.h (parse_float, parse_c_float): Declare.
	* parse.c (parse_float, parse_c_float): New function.
	* c-exp.y (parse_number): Call parse_c_float.
	* objc-exp.y (parse_number): Ditto.
	* p-exp.y (parse_number): Ditto.  Use ANSI/ISO-style definition.
	* jv-exp.y (parse_number): Call parse_float, fix suffix handling.

	testsuite/
	* gdb.base/printcmds.exp (test_float_accepted): New function.
	Move existing float tests there.  Add tests for floats with suffixes.
	(test_float_rejected): New function.
	* gdb.java/jv-print.exp (test_float_accepted): New function.
	(test_float_rejected): New function.
	* gdb.objc/print.exp: New file.
	* gdb.pascal/print.exp: New file.
	* lib/objc.exp: New file.
@
text
@d2392 1
@


1.76
log
@gdb/
	Fix PR c++/11703 and PR gdb/1448.
	* c-exp.y (yylex) <last_was_coloncolon && first_was_coloncolon>: Add
	FIRST_ITER check.

gdb/testsuite/
	Test PR c++/11703 and PR gdb/1448.
	* gdb.cp/namespace.exp (ptype ::C::NestedClass): Remove KFAIL for
	gdb/1448.
@
text
@d1326 2
a1327 4
      /* It's a float since it contains a point or an exponent.  */
      char *s;
      int num;	/* number of tokens scanned by scanf */
      char saved_char;
d1365 4
a1368 29
      s = malloc (len);
      saved_char = p[len];
      p[len] = 0;	/* null-terminate the token */
      num = sscanf (p, "%" DOUBLEST_SCAN_FORMAT "%s",
		    &putithere->typed_val_float.dval, s);
      p[len] = saved_char;	/* restore the input stream */

      if (num == 1)
	putithere->typed_val_float.type = 
	  parse_type->builtin_double;

      if (num == 2 )
	{
	  /* See if it has any float suffix: 'f' for float, 'l' for long 
	     double.  */
	  if (!strcasecmp (s, "f"))
	    putithere->typed_val_float.type = 
	      parse_type->builtin_float;
	  else if (!strcasecmp (s, "l"))
	    putithere->typed_val_float.type = 
	      parse_type->builtin_long_double;
	  else
	    {
	      free (s);
	      return ERROR;
	    }
	}

      free (s);
@


1.76.2.1
log
@	PR exp/11926
	* c-exp.y (parse_number): Handle 0 return from sscanf.

	testsuite/
	* gdb.base/printcmds.exp (test_integer_literals_rejected): Add
	test of "p 0x1.1".
@
text
@a1373 6
      if (num == 0)
	{
	  free (s);
	  return ERROR;
	}

@


1.75
log
@Add ADL support

2010-05-07  Sami Wagiaalla  <swagiaal@@redhat.com>

	PR C++/7943:
	* valops.c (find_overload_match): Handle fsym == NULL case.
	Add int no_adl argument.
	(find_oload_champ_namespace_loop): Call make_symbol_overload_list_adl
	when appropriate.
	Add int no_adl argument.
	(find_oload_champ_namespace): 	Add int no_adl argument.
	* parse.c (operator_length_standard): Return length for OP_ADL_FUNC
	expression.
	* expprint.c (op_name_standard): Added string for OP_ADL_FUNC case.
	* eval.c (evaluate_subexp_standard): Added OP_ADL_FUNC case.
	Evaluate arguments and use them to perform ADL lookup.
	Pass no_adl argument to find_overload_match.
	Disable adl lookup when evaluating a fully qualified OP_FUNCALL.
	* cp-support.h: Added prototype for
	make_symbol_overload_list_namespace.
	* cp-support.c (make_symbol_overload_list_namespace): New function.
	(make_symbol_overload_list_adl_namespace): New function.
	(make_symbol_overload_list_adl): New function.
	(make_symbol_overload_list_using): Moved code to add function to
	overload set to make_symbol_overload_list_namespace.
	* c-exp.y: create UNKNOWN_CPP_NAME token.
	Add parse rule for ADL functions.
	(classify_name): Recognize an UNKNOWN_CPP_NAME.

2010-05-07  Sami Wagiaalla  <swagiaal@@redhat.com>

	* gdb.cp/koenig.exp: New test.
	* gdb.cp/koenig.cc: New test program.
@
text
@d2556 1
a2556 1
      if (first_was_coloncolon)
@


1.74
log
@2010-05-05  Michael Snyder  <msnyder@@vmware.com>

	* c-exp.y (parse_string_or_char): Delete unused variable.
	(c_lex): Delete unused variable.
	* cp-name-parser.y (cpname_lex): Delete unused variable.
	* ada-exp.y (find_primitive_type): Delete unused variable.
	(write_var_or_type): Delete unused variable.
	* jv-exp.y (java_parse): Delete unused variable.
	(push_expression_name): Delete unused variable.
	* p-exp.y (pascal_lex): Delete unused variable.
@
text
@d189 1
d395 23
d1251 1
d1272 1
d2416 6
@


1.73
log
@gdb
	* c-exp.y (name_not_typename): Add 'operator' clause.
gdb/testsuite
	* gdb.cp/userdef.exp: Add tests for explicit calls to operator==.
	* gdb.cp/userdef.cc (operator==): New function.
	(main): New locals mem1, mem2.
@
text
@d1711 1
a1711 1
  int quote, i;
a2439 1
  char *name;
@


1.72
log
@2010-02-23  Harald Koenig  <H.Koenig@@science-computing.de>

	* c-exp.y (token_and_value): s/union YYSTYPE/YYSTYPE.
@
text
@d1239 8
@


1.71
log
@gdb
	PR c++/8693, PR c++/9496:
	* cp-namespace.c (cp_lookup_nested_type): Handle TYPE_CODE_UNION.
	* c-exp.y (lex_one_token): Rename from yylex.  Don't call
	write_dollar_variable.  Don't try to classify NAME tokens.
	(token_and_value): New type.
	(token_fifo, popping, name_obstack): New globals.
	(classify_name): New function.
	(classify_inner_name): Likewise.
	(yylex): Likewise.
	(VARIABLE): Now has type sval.
	(exp : VARIABLE): Call write_dollar_variable.
	(qualified_name): Use TYPENAME, not typebase.  Add production for
	multiple "::" instances.
	(variable): Use name_not_typename.
	(qualified_type): Remove.
	(typebase): Update.
gdb/testsuite
	PR c++/8693, PR c++/9496:
	* gdb.cp/namespace.exp: Remove some setup_kfail calls.  Added
	regression tests.
@
text
@d2298 1
a2298 1
  union YYSTYPE value;
@


1.70
log
@gdb
	* parser-defs.h (parser_debug): Declare.
	* parse.c (_initialize_parse): Install "debug parser" set/show
	command.
	(parser_debug): New global.
	(show_parserdebug): New function.
	* c-exp.y (c_parse): Set yydebug.
gdb/testsuite
	* gdb.texinfo (Debugging Output): Document set debug parser and
	show debug parser.
@
text
@d165 1
a165 1
%type <tval> type typebase qualified_type
d215 1
a215 1
%token <voidval> VARIABLE
d584 3
a586 1
			/* Already written by write_dollar_variable. */
d748 1
a748 1
qualified_name:	typebase COLONCOLON name
d750 1
a750 1
			  struct type *type = $1;
d763 1
a763 1
	|	typebase COLONCOLON '~' name
d765 1
a765 1
			  struct type *type = $1;
d787 7
d797 1
a797 1
	|	COLONCOLON name
d799 1
a799 1
			  char *name = copy_name ($2);
a1048 71
	| qualified_type
	;

/* FIXME: carlton/2003-09-25: This next bit leads to lots of
   reduce-reduce conflicts, because the parser doesn't know whether or
   not to use qualified_name or qualified_type: the rules are
   identical.  If the parser is parsing 'A::B::x', then, when it sees
   the second '::', it knows that the expression to the left of it has
   to be a type, so it uses qualified_type.  But if it is parsing just
   'A::B', then it doesn't have any way of knowing which rule to use,
   so there's a reduce-reduce conflict; it picks qualified_name, since
   that occurs earlier in this file than qualified_type.

   There's no good way to fix this with the grammar as it stands; as
   far as I can tell, some of the problems arise from ambiguities that
   GDB introduces ('start' can be either an expression or a type), but
   some of it is inherent to the nature of C++ (you want to treat the
   input "(FOO)" fairly differently depending on whether FOO is an
   expression or a type, and if FOO is a complex expression, this can
   be hard to determine at the right time).  Fortunately, it works
   pretty well in most cases.  For example, if you do 'ptype A::B',
   where A::B is a nested type, then the parser will mistakenly
   misidentify it as an expression; but evaluate_subexp will get
   called with 'noside' set to EVAL_AVOID_SIDE_EFFECTS, and everything
   will work out anyways.  But there are situations where the parser
   will get confused: the most common one that I've run into is when
   you want to do

     print *((A::B *) x)"

   where the parser doesn't realize that A::B has to be a type until
   it hits the first right paren, at which point it's too late.  (The
   workaround is to type "print *(('A::B' *) x)" instead.)  (And
   another solution is to fix our symbol-handling code so that the
   user never wants to type something like that in the first place,
   because we get all the types right without the user's help!)

   Perhaps we could fix this by making the lexer smarter.  Some of
   this functionality used to be in the lexer, but in a way that
   worked even less well than the current solution: that attempt
   involved having the parser sometimes handle '::' and having the
   lexer sometimes handle it, and without a clear division of
   responsibility, it quickly degenerated into a big mess.  Probably
   the eventual correct solution will give more of a role to the lexer
   (ideally via code that is shared between the lexer and
   decode_line_1), but I'm not holding my breath waiting for somebody
   to get around to cleaning this up...  */

qualified_type: typebase COLONCOLON name
		{
		  struct type *type = $1;
		  struct type *new_type;
		  char *ncopy = alloca ($3.length + 1);

		  memcpy (ncopy, $3.ptr, $3.length);
		  ncopy[$3.length] = '\0';

		  if (TYPE_CODE (type) != TYPE_CODE_STRUCT
		      && TYPE_CODE (type) != TYPE_CODE_UNION
		      && TYPE_CODE (type) != TYPE_CODE_NAMESPACE)
		    error ("`%s' is not defined as an aggregate type.",
			   TYPE_NAME (type));

		  new_type = cp_lookup_nested_type (type, ncopy,
						    expression_context_block);
		  if (new_type == NULL)
		    error ("No type \"%s\" within class or namespace \"%s\".",
			   ncopy, TYPE_NAME (type));
		  
		  $$ = new_type;
		}
d1972 1
a1972 1
yylex (void)
d2287 81
d2369 8
a2376 2
      write_dollar_variable (yylval.sval);
      return VARIABLE;
a2377 27
  
  /* Use token-type BLOCKNAME for symbols that happen to be defined as
     functions or symtabs.  If this is not so, then ...
     Use token-type TYPENAME for symbols that happen to be defined
     currently as names of types; NAME for other symbols.
     The caller is not constrained to care about the distinction.  */
  {
    struct symbol *sym;
    int is_a_field_of_this = 0;
    int hextype;

    sym = lookup_symbol (copy, expression_context_block,
			 VAR_DOMAIN,
			 parse_language->la_language == language_cplus
			 ? &is_a_field_of_this : (int *) NULL);
    /* Call lookup_symtab, not lookup_partial_symtab, in case there are
       no psymtabs (coff, xcoff, or some future change to blow away the
       psymtabs once once symbols are read).  */
    if (sym && SYMBOL_CLASS (sym) == LOC_BLOCK)
      {
	yylval.ssym.sym = sym;
	yylval.ssym.is_a_field_of_this = is_a_field_of_this;
	return BLOCKNAME;
      }
    else if (!sym)
      {				/* See if it's a file name. */
	struct symtab *symtab;
d2379 16
a2394 1
	symtab = lookup_symtab (copy);
d2396 2
a2397 6
	if (symtab)
	  {
	    yylval.bval = BLOCKVECTOR_BLOCK (BLOCKVECTOR (symtab), STATIC_BLOCK);
	    return FILENAME;
	  }
      }
d2399 6
a2404 13
    if (sym && SYMBOL_CLASS (sym) == LOC_TYPEDEF)
        {
	  /* NOTE: carlton/2003-09-25: There used to be code here to
	     handle nested types.  It didn't work very well.  See the
	     comment before qualified_type for more info.  */
	  yylval.tsym.type = SYMBOL_TYPE (sym);
	  return TYPENAME;
        }
    yylval.tsym.type
      = language_lookup_primitive_type_by_name (parse_language,
						parse_gdbarch, copy);
    if (yylval.tsym.type != NULL)
      return TYPENAME;
d2406 2
a2407 16
    /* Input names that aren't symbols but ARE valid hex numbers,
       when the input radix permits them, can be names or numbers
       depending on the parse.  Note we support radixes > 16 here.  */
    if (!sym 
        && ((tokstart[0] >= 'a' && tokstart[0] < 'a' + input_radix - 10)
	    || (tokstart[0] >= 'A' && tokstart[0] < 'A' + input_radix - 10)))
      {
 	YYSTYPE newlval;	/* Its value is ignored.  */
	hextype = parse_number (tokstart, namelen, 0, &newlval);
	if (hextype == INT)
	  {
	    yylval.ssym.sym = sym;
	    yylval.ssym.is_a_field_of_this = is_a_field_of_this;
	    return NAME_OR_INT;
	  }
      }
d2409 2
a2410 5
    /* Any other kind of symbol */
    yylval.ssym.sym = sym;
    yylval.ssym.is_a_field_of_this = is_a_field_of_this;
    if (in_parse_field && *lexptr == '\0')
      saw_name_at_eof = 1;
d2412 119
a2530 1
  }
d2563 5
@


1.69
log
@gdb
	PR c++/9680:
	* c-exp.y (REINTERPRET_CAST, DYNAMIC_CAST, STATIC_CAST)
	(CONST_CAST): New tokens.
	(exp): Add new productions.
	(ident_tokens): Add const_cast, dynamic_cast, static_cast, and
	reinterpret_cast.
	(is_cast_operator): New function.
	(yylex): Handle cast operators specially.
	* eval.c (evaluate_subexp_standard) <UNOP_DYNAMIC_CAST,
	UNOP_REINTERPRET_CAST>: New cases.
	* expprint.c (print_subexp_standard): Likewise.
	(op_name_standard): Likewise.
	(dump_subexp_body_standard): Likewise.
	* parse.c (operator_length_standard): Likewise.
	* expression.h (enum exp_opcode): New constants UNOP_DYNAMIC_CAST,
	UNOP_REINTERPRET_CAST.
	* gdbtypes.c (class_types_same_p): New function.
	(is_ancestor): Use it.
	(is_public_ancestor): New function.
	(is_unique_ancestor_worker): Likewise.
	(is_unique_ancestor): Likewise.
	* gdbtypes.h (class_types_same_p, is_public_ancestor)
	(is_unique_ancestor): Declare.
	* valops.c (value_reinterpret_cast): New function.
	(dynamic_cast_check_1): Likewise.
	(dynamic_cast_check_2): Likewise.
	(value_dynamic_cast): Likewise.
	* value.h (value_reinterpret_cast, value_dynamic_cast): Declare.
gdb/testsuite
	PR c++/9680:
	* gdb.cp/casts.cc: Add new classes and variables.
	* gdb.cp/casts.exp: Test new operators.
@
text
@d2453 3
@


1.68
log
@gdb/
	Implement binary numbers parsing.
	* c-exp.y (parse_number): New case 'b' and 'B'.

gdb/testsuite/
	Implement binary numbers parsing.
	* gdb.base/printcmds.exp (test_integer_literals_accepted)
	(test_integer_literals_rejected): New binary tests.
@
text
@d209 1
d595 26
d1924 6
a1929 1
    {"xor_eq", ASSIGN_MODIFY, BINOP_BITWISE_XOR, 1}
d2007 10
d2280 7
a2286 5
	{ 
               /* Scan ahead to get rest of the template specification.  Note
                  that we look ahead only when the '<' adjoins non-whitespace
                  characters; for comparison expressions, e.g. "a < b > c",
                  there must be spaces before the '<', etc. */
d2288 5
a2292 4
               char * p = find_template_name_end (tokstart + namelen);
               if (p)
                 namelen = p - tokstart;
               break;
@


1.67
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d1414 10
@


1.66
log
@	PR gdb/8704

	* breakpoint.c (find_condition_and_thread): Correct task error message.
	* c-exp.y (yylex): Stop before "thread N", "task N", or abbreviations
	of those.

	doc/
	* gdb.texinfo (Thread-Specific Breakpoints): Thread specifiers
	are allowed after the breakpoint condition.

	testsuite/
	* gdb.base/condbreak.exp: Test combinations of "break *EXP",
	"if", and "thread".  Correct matching in the previous test.
@
text
@d3 1
a3 1
   1998, 1999, 2000, 2003, 2004, 2006, 2007, 2008, 2009
@


1.65
log
@	* c-expy. (operator_stoken): New function.
	(OPERATOR): New token.
	(NEW): New token.
	(DELETE): New token.
	(operator): New rule.
	(name): Add operator.
	(ident_tokens): Add "new", "delete", and "operator".
	* gdbtypes.c (rank_one_type): Don't complain about
	void pointer conversion badness if both types are
	void pointers.
@
text
@d2253 18
@


1.64
log
@	* c-exp.y: Add new rule for resolving method overloads.
	* eval.c (make_params): New function.
	(free_param_types): New function.
	(evaluate_subexp_standard): Pass expect_type to value_aggregate_elt.
	Handle case TYPE_INSTANCE.
	(evaluate_subexp_for_address): Pass expect_type to value_aggregate_elt.
	* expression.h (enum exp_opcode): Add TYPE_INSTANCE.
	(compare_parameters): Add declaration.
	* parse.c (operator_length_standard): Add TYPE_INSTANCE.
	* valops.c (value_aggregate_elt): Add new expect_type parameter.
	Pass expect_type to value_struct_elt_for_reference.
	(value_struct_elt_for_reference): Add expect_type parameter and use
	compare_parameters.
	Check for overload matches with and without artificial parameters.
	Skip artificial methods.
	(compare_parameters): New function.
	* value.h (value_aggregate_elt): Add new expect_type parameter.
@
text
@d160 1
d203 1
d207 2
d1139 119
d1262 1
d1278 17
d1873 3
@


1.63
log
@	ARI fix: OP eol rule.
	* blockframe.c (find_pc_partial_function): Avoid operator at end of
	line.
	* buildsym.c (find_symbol_in_list): Idem.
	(start_subfile, patch_subfile_names): Idem.
	* c-exp.y (variable, yylex): Idem.
	* c-typeprint.c (c_print_type, c_type_print_base): Idem.
	* c-valprint.c (c_val_print): Idem.
	* coffread.c (patch_opaque_types, process_coff_symbol): Idem.
	* corelow.c (core_open): Idem.
	* cris-tdep.c (move_reg_to_mem_movem_op): Idem.
	* cli/cli-decode.c (help_cmd_list, find_command_name_length): Idem.
@
text
@d404 12
@


1.62
log
@	* c-exp.y (qualified_name): Call CHECK_TYPEDEF before deciding
	that a type is not an aggregate type.
@
text
@d780 3
a782 3
				  if (innermost_block == 0 ||
				      contained_in (block_found, 
						    innermost_block))
d799 3
a801 2
			      if (innermost_block == 0 || 
				  contained_in (block_found, innermost_block))
d2178 3
a2180 3
    if (!sym && 
        ((tokstart[0] >= 'a' && tokstart[0] < 'a' + input_radix - 10) ||
         (tokstart[0] >= 'A' && tokstart[0] < 'A' + input_radix - 10)))
@


1.61
log
@	* c-exp.y (yylex): Add cxx_only check for tokentab2 and tokentab3
	searches.
	(tokentab3): Add cxx_only for DOT_STAR.
@
text
@d706 1
d722 1
@


1.60
log
@	* c-exp.y (tokentab3): Add new token, ARROW_STAR. Changed all users.
	(tokentab2): Add new token, DOT_STAR. Changed all users.
@
text
@d1686 2
d1695 1
a1695 1
    {".*", DOT_STAR, BINOP_END, 0}
d1854 4
d1867 4
@


1.59
log
@gdb
	* c-lang.c (convert_octal): Only allow 3 octal digits.
	(print_wchar): Prefer 3-digit octal form.  Fall back to hex if
	needed.
	* c-exp.y (c_parse_escape): Only allow 3 octal digits.
gdb/testsuite
	* gdb.base/call-rt-st.exp: Update for change to escape output.
	* gdb.base/callfuncs.exp: Likewise.
	* gdb.base/charset.exp: Likewise.
	* gdb.base/constvars.exp: Likewise.
	* gdb.base/long_long.exp: Likewise.
	* gdb.base/pointers.exp: Likewise.
	* gdb.base/printcmds.exp: Likewise.
	* gdb.base/setvar.exp: Likewise.
	* gdb.base/store.exp: Likewise.
	* gdb.cp/ref-types.exp: Likewise.
	* gdb.mi/mi-var-child.exp: Likewise.
	* gdb.mi/mi-var-display.exp: Likewise.
	* gdb.mi/mi2-var-display.exp: Likewise.
	* gdb.base/charset.exp: Test octal escape sequence length.
	Update for change to escape output.
@
text
@d235 1
a235 1
%right ARROW '.' '[' '('
d336 1
a336 1
exp	:	exp ARROW '*' exp
d371 1
a371 1
exp	:	exp '.' '*' exp
d1667 2
a1668 1
    {"<<=", ASSIGN_MODIFY, BINOP_LSH, 0}
d1692 2
a1693 1
    {">=", GEQ, BINOP_END, 0}
@


1.58
log
@	* defs.h (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.
	* findvar.c (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.

	* gdbcore.h (read_memory_integer, safe_read_memory_integer,
	read_memory_unsigned_integer, write_memory_signed_integer,
	write_memory_unsigned_integer): Add BYTE_ORDER parameter.
	* corefile.c (struct captured_read_memory_integer_arguments): Add
	BYTE_ORDER member.
	(safe_read_memory_integer): Add BYTE_ORDER parameter.  Store it into
	struct captured_read_memory_integer_arguments.
	(do_captured_read_memory_integer): Pass it to read_memory_integer.
	(read_memory_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_signed_integer.
	(read_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_unsigned_integer.
	(write_memory_signed_integer): Add BYTE_ORDER parameter.  Pass it
	to store_signed_integer.
	(write_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it
	to store_unsigned_integer.

	* target.h (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	* target.c (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	Pass it to extract_unsigned_integer.


	Update calls to extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer, read_memory_integer,
	read_memory_unsigned_integer, safe_read_memory_integer,
	write_memory_signed_integer, write_memory_unsigned_integer, and
	get_target_memory_unsigned to pass byte order:
	* ada-lang.c (ada_value_binop): Update.
	* ada-valprint.c (char_at): Update.
	* alpha-osf1-tdep.c (alpha_osf1_sigcontext_addr): Update.
	* alpha-tdep.c (alpha_lds, alpha_sts, alpha_push_dummy_call,
	alpha_extract_return_value, alpha_read_insn,
	alpha_get_longjmp_target): Update.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Update.
	* amd64obsd-tdep.c (amd64obsd_supply_uthread,
	amd64obsd_collect_uthread, amd64obsd_trapframe_cache): Update.
	* amd64-tdep.c (amd64_push_dummy_call, amd64_analyze_prologue,
	amd64_frame_cache, amd64_sigtramp_frame_cache, fixup_riprel,
	amd64_displaced_step_fixup): Update.
	* arm-linux-tdep.c (arm_linux_sigreturn_init,
	arm_linux_rt_sigreturn_init, arm_linux_supply_gregset): Update.
	* arm-tdep.c (thumb_analyze_prologue, arm_skip_prologue,
	arm_scan_prologue, arm_push_dummy_call, thumb_get_next_pc,
	arm_get_next_pc, arm_extract_return_value, arm_store_return_value,
	arm_return_value): Update.
	* arm-wince-tdep.c (arm_pe_skip_trampoline_code): Update.
	* auxv.c (default_auxv_parse): Update.
	* avr-tdep.c (avr_address_to_pointer, avr_pointer_to_address,
	avr_scan_prologue, avr_extract_return_value,
	avr_frame_prev_register, avr_push_dummy_call): Update.
	* bsd-uthread.c (bsd_uthread_check_magic, bsd_uthread_lookup_offset,
	bsd_uthread_wait, bsd_uthread_thread_alive,
	bsd_uthread_extra_thread_info): Update.
	* c-lang.c (c_printstr, print_wchar): Update.
	* cp-valprint.c (cp_print_class_member): Update.
	* cris-tdep.c (cris_sigcontext_addr, cris_sigtramp_frame_unwind_cache,
	cris_push_dummy_call, cris_scan_prologue, cris_store_return_value,
	cris_extract_return_value, find_step_target, dip_prefix,
	sixteen_bit_offset_branch_op, none_reg_mode_jump_op,
	move_mem_to_reg_movem_op, get_data_from_address): Update.
	* dwarf2expr.c (dwarf2_read_address, execute_stack_op): Update.
	* dwarf2-frame.c (execute_cfa_program): Update.
	* dwarf2loc.c (find_location_expression): Update.
	* dwarf2read.c (dwarf2_const_value): Update.
	* expprint.c (print_subexp_standard): Update.
	* findvar.c (unsigned_pointer_to_address, signed_pointer_to_address,
	unsigned_address_to_pointer, address_to_signed_pointer,
	read_var_value): Update.
	* frame.c (frame_unwind_register_signed,
	frame_unwind_register_unsigned, get_frame_memory_signed,
	get_frame_memory_unsigned): Update.
	* frame-unwind.c (frame_unwind_got_constant): Update.
	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp,
	frv_linux_sigcontext_reg_addr, frv_linux_sigtramp_frame_cache):
	Update.
	* frv-tdep.c (frv_analyze_prologue, frv_skip_main_prologue,
	frv_extract_return_value, find_func_descr,
	frv_convert_from_func_ptr_addr, frv_push_dummy_call): Update.
	* f-valprint.c (f_val_print): Update.
	* gnu-v3-abi.c (gnuv3_decode_method_ptr, gnuv3_make_method_ptr):
	Update.
	* h8300-tdep.c (h8300_is_argument_spill, h8300_analyze_prologue,
	h8300_push_dummy_call, h8300_extract_return_value,
	h8300h_extract_return_value, h8300_store_return_value,
	h8300h_store_return_value): Update.
	* hppabsd-tdep.c (hppabsd_find_global_pointer): Update.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register, hppa_hpux_store_register):
	Update.
	* hppa-hpux-tdep.c (hppa32_hpux_in_solib_call_trampoline,
	hppa64_hpux_in_solib_call_trampoline,
	hppa_hpux_in_solib_return_trampoline, hppa_hpux_skip_trampoline_code,
	hppa_hpux_sigtramp_frame_unwind_cache,
	hppa_hpux_sigtramp_unwind_sniffer, hppa32_hpux_find_global_pointer,
	hppa64_hpux_find_global_pointer, hppa_hpux_search_pattern,
	hppa32_hpux_search_dummy_call_sequence,
	hppa64_hpux_search_dummy_call_sequence, hppa_hpux_supply_save_state,
	hppa_hpux_unwind_adjust_stub): Update.
	* hppa-linux-tdep.c (insns_match_pattern,
	hppa_linux_find_global_pointer): Update.
	* hppa-tdep.c (hppa_in_function_epilogue_p, hppa32_push_dummy_call,
	hppa64_convert_code_addr_to_fptr, hppa64_push_dummy_call,
	skip_prologue_hard_way, hppa_frame_cache, hppa_fallback_frame_cache,
	hppa_pseudo_register_read, hppa_frame_prev_register_helper,
	hppa_match_insns): Update.
	* hpux-thread.c (hpux_thread_fetch_registers): Update.
	* i386-tdep.c (i386bsd_sigcontext_addr): Update.
	* i386-cygwin-tdep.c (core_process_module_section): Update.
	* i386-darwin-nat.c (i386_darwin_sstep_at_sigreturn,
	amd64_darwin_sstep_at_sigreturn): Update.
	* i386-darwin-tdep.c (i386_darwin_sigcontext_addr,
	amd64_darwin_sigcontext_addr): Likewise.
	* i386-linux-nat.c (i386_linux_sigcontext_addr): Update.
	* i386nbsd-tdep.c (i386nbsd_sigtramp_cache_init): Update.
	* i386-nto-tdep.c (i386nto_sigcontext_addr): Update.
	* i386obsd-nat.c (i386obsd_supply_pcb): Update.
	* i386obsd-tdep.c (i386obsd_supply_uthread, i386obsd_collect_uthread,
	i386obsd_trapframe_cache): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_follow_jump,
	i386_analyze_frame_setup, i386_analyze_prologue,
	i386_skip_main_prologue, i386_frame_cache, i386_sigtramp_frame_cache,
	i386_get_longjmp_target, i386_push_dummy_call,
	i386_pe_skip_trampoline_code, i386_svr4_sigcontext_addr,
	i386_fetch_pointer_argument): Update.
	* i387-tdep.c (i387_supply_fsave): Update.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Update.
	* ia64-tdep.c (ia64_pseudo_register_read, ia64_pseudo_register_write,
	examine_prologue, ia64_frame_cache, ia64_frame_prev_register,
	ia64_sigtramp_frame_cache, ia64_sigtramp_frame_prev_register,
	ia64_access_reg, ia64_access_rse_reg, ia64_libunwind_frame_this_id,
	ia64_libunwind_frame_prev_register,
	ia64_libunwind_sigtramp_frame_this_id,
	ia64_libunwind_sigtramp_frame_prev_register, ia64_find_global_pointer,
	find_extant_func_descr, find_func_descr,
	ia64_convert_from_func_ptr_addr, ia64_push_dummy_call, ia64_dummy_id,
	ia64_unwind_pc): Update.
	* iq2000-tdep.c (iq2000_pointer_to_address, iq2000_address_to_pointer,
	iq2000_scan_prologue, iq2000_extract_return_value,
	iq2000_push_dummy_call): Update.
	* irix5nat.c (fill_gregset): Update.
	* jv-lang.c (evaluate_subexp_java): Update.
	* jv-valprint.c (java_value_print): Update.
	* lm32-tdep.c (lm32_analyze_prologue, lm32_push_dummy_call,
	lm32_extract_return_value, lm32_store_return_value): Update.
	* m32c-tdep.c (m32c_push_dummy_call, m32c_return_value,
	m32c_skip_trampoline_code, m32c_m16c_address_to_pointer,
	m32c_m16c_pointer_to_address): Update.
	* m32r-tdep.c (m32r_store_return_value, decode_prologue,
	m32r_skip_prologue, m32r_push_dummy_call, m32r_extract_return_value):
	Update.
	* m68hc11-tdep.c (m68hc11_pseudo_register_read,
	m68hc11_pseudo_register_write, m68hc11_analyze_instruction,
	m68hc11_push_dummy_call): Update.
	* m68linux-tdep.c (m68k_linux_pc_in_sigtramp,
	m68k_linux_get_sigtramp_info, m68k_linux_sigtramp_frame_cache):
	Update.
	* m68k-tdep.c (m68k_push_dummy_call, m68k_analyze_frame_setup,
	m68k_analyze_register_saves, m68k_analyze_prologue, m68k_frame_cache,
	m68k_get_longjmp_target): Update.
	* m88k-tdep.c (m88k_fetch_instruction): Update.
	* mep-tdep.c (mep_pseudo_cr32_read, mep_pseudo_csr_write,
	mep_pseudo_cr32_write, mep_get_insn, mep_push_dummy_call): Update.
	* mi/mi-main.c (mi_cmd_data_write_memory): Update.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target, supply_32bit_reg,
	mips64_linux_get_longjmp_target, mips64_fill_gregset,
	mips64_fill_fpregset, mips_linux_in_dynsym_stub): Update.
	* mipsnbdsd-tdep.c (mipsnbsd_get_longjmp_target): Update.
	* mips-tdep.c (mips_fetch_instruction, fetch_mips_16,
	mips_eabi_push_dummy_call, mips_n32n64_push_dummy_call,
	mips_o32_push_dummy_call, mips_o64_push_dummy_call,
	mips_single_step_through_delay, mips_skip_pic_trampoline_code,
	mips_integer_to_address): Update.
	* mn10300-tdep.c (mn10300_analyze_prologue, mn10300_push_dummy_call):
	Update.
	* monitor.c (monitor_supply_register, monitor_write_memory,
	monitor_read_memory_single): Update.
	* moxie-tdep.c (moxie_store_return_value, moxie_extract_return_value,
	moxie_analyze_prologue): Update.
	* mt-tdep.c (mt_return_value, mt_skip_prologue, mt_select_coprocessor,
	mt_pseudo_register_read, mt_pseudo_register_write, mt_registers_info,
	mt_push_dummy_call): Update.
	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class, find_implementation_from_class): Update.
	* ppc64-linux-tdep.c (ppc64_desc_entry_point,
	ppc64_linux_convert_from_func_ptr_addr, ppc_linux_sigtramp_cache):
	Update.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_sniffer,
	ppcobsd_sigtramp_frame_cache): Update.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call,
	do_ppc_sysv_return_value, ppc64_sysv_abi_push_dummy_call,
	ppc64_sysv_abi_return_value): Update.
	* ppc-linux-nat.c (ppc_linux_auxv_parse): Update.
	* procfs.c (procfs_auxv_parse): Update.
	* p-valprint.c (pascal_val_print): Update.
	* regcache.c (regcache_raw_read_signed, regcache_raw_read_unsigned,
	regcache_raw_write_signed, regcache_raw_write_unsigned,
	regcache_cooked_read_signed, regcache_cooked_read_unsigned,
	regcache_cooked_write_signed, regcache_cooked_write_unsigned): Update.
	* remote-m32r-sdi.c (m32r_fetch_register): Update.
	* remote-mips.c (mips_wait, mips_fetch_registers, mips_xfer_memory):
	Update.
	* rs6000-aix-tdep.c (rs6000_push_dummy_call, rs6000_return_value,
	rs6000_convert_from_func_ptr_addr, branch_dest,
	rs6000_software_single_step): Update.
	* rs6000-tdep.c (rs6000_in_function_epilogue_p,
	ppc_displaced_step_fixup, ppc_deal_with_atomic_sequence,
	bl_to_blrl_insn_p, rs6000_fetch_instruction, skip_prologue,
	rs6000_skip_main_prologue, rs6000_skip_trampoline_code,
	rs6000_frame_cache): Update.
	* s390-tdep.c (s390_pseudo_register_read, s390_pseudo_register_write,
	s390x_pseudo_register_read, s390x_pseudo_register_write, s390_load,
	s390_backchain_frame_unwind_cache, s390_sigtramp_frame_unwind_cache,
	extend_simple_arg, s390_push_dummy_call, s390_return_value): Update.
	* scm-exp.c (scm_lreadr): Update.
	* scm-lang.c (scm_get_field, scm_unpack): Update.
	* scm-valprint.c (scm_val_print): Update.
	* score-tdep.c (score_breakpoint_from_pc, score_push_dummy_call,
	score_fetch_inst): Update.
	* sh64-tdep.c (look_for_args_moves, sh64_skip_prologue_hard_way,
	sh64_analyze_prologue, sh64_push_dummy_call, sh64_extract_return_value,
	sh64_pseudo_register_read, sh64_pseudo_register_write,
	sh64_frame_prev_register): Update:
	* sh-tdep.c (sh_analyze_prologue, sh_push_dummy_call_fpu,
	sh_push_dummy_call_nofpu, sh_extract_return_value_nofpu,
	sh_store_return_value_nofpu, sh_in_function_epilogue_p): Update.
	* solib-darwin.c (darwin_load_image_infos): Update.
	* solib-frv.c (fetch_loadmap, lm_base, frv_current_sos, enable_break2,
	find_canonical_descriptor_in_load_object): Update.
	* solib-irix.c (extract_mips_address, fetch_lm_info, irix_current_sos,
	irix_open_symbol_file_object): Update.
	* solib-som.c (som_solib_create_inferior_hook, link_map_start,
	som_current_sos, som_open_symbol_file_object): Update.
	* solib-sunos.c (SOLIB_EXTRACT_ADDRESS, LM_ADDR, LM_NEXT, LM_NAME):
	Update.
	* solib-svr4.c (read_program_header, scan_dyntag_auxv,
	solib_svr4_r_ldsomap): Update.
	* sparc64-linux-tdep.c (sparc64_linux_step_trap): Update.
	* sparc64obsd-tdep.c (sparc64obsd_supply_uthread,
	sparc64obsd_collect_uthread): Update.
	* sparc64-tdep.c (sparc64_pseudo_register_read,
	sparc64_pseudo_register_write, sparc64_supply_gregset,
	sparc64_collect_gregset): Update.
	* sparc-linux-tdep.c (sparc32_linux_step_trap): Update.
	* sparcobsd-tdep.c (sparc32obsd_supply_uthread,
	sparc32obsd_collect_uthread): Update.
	* sparc-tdep.c (sparc_fetch_wcookie, sparc32_push_dummy_code,
	sparc32_store_arguments, sparc32_return_value, sparc_supply_rwindow,
	sparc_collect_rwindow): Update.
	* spu-linux-nat.c (parse_spufs_run): Update.
	* spu-tdep.c (spu_pseudo_register_read_spu,
	spu_pseudo_register_write_spu, spu_pointer_to_address,
	spu_analyze_prologue, spu_in_function_epilogue_p,
	spu_frame_unwind_cache, spu_push_dummy_call, spu_software_single_step,
	spu_get_longjmp_target, spu_get_overlay_table, spu_overlay_update_osect,
	info_spu_signal_command, info_spu_mailbox_list, info_spu_dma_cmdlist,
	info_spu_dma_command, info_spu_proxydma_command): Update.
	* stack.c (print_frame_nameless_args, frame_info): Update.
	* symfile.c (read_target_long_array, simple_read_overlay_table,
	simple_read_overlay_region_table): Update.
	* target.c (debug_print_register): Update.
	* tramp-frame.c (tramp_frame_start): Update.
	* v850-tdep.c (v850_analyze_prologue, v850_push_dummy_call,
	v850_extract_return_value, v850_store_return_value,
	* valarith.c (value_binop, value_bit_index): Update.
	* valops.c (value_cast): Update.
	* valprint.c (val_print_type_code_int, val_print_string,
	read_string): Update.
	* value.c (unpack_long, unpack_double, unpack_field_as_long,
	modify_field, pack_long): Update.
	* vax-tdep.c (vax_store_arguments, vax_push_dummy_call,
	vax_skip_prologue): Update.
	* xstormy16-tdep.c (xstormy16_push_dummy_call,
	xstormy16_analyze_prologue, xstormy16_in_function_epilogue_p,
	xstormy16_resolve_jmp_table_entry, xstormy16_find_jmp_table_entry,
	xstormy16_pointer_to_address, xstormy16_address_to_pointer): Update.
	* xtensa-tdep.c (extract_call_winsize, xtensa_pseudo_register_read,
	xtensa_pseudo_register_write, xtensa_frame_cache,
	xtensa_push_dummy_call, call0_track_op, call0_frame_cache): Update.


	* dfp.h (decimal_to_string, decimal_from_string, decimal_from_integral,
	decimal_from_floating, decimal_to_doublest, decimal_is_zero): Add
	BYTE_ORDER parameter.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	* dfp.c (match_endianness): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.
	(decimal_to_string, decimal_from_integral, decimal_from_floating,
	decimal_to_doublest, decimal_is_zero): Add BYTE_ORDER parameter.
	Pass it to match_endianness.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.  Pass them to match_endianness.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	Pass them to match_endianness.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	Pass them to match_endianness.
	* valarith.c (value_args_as_decimal): Add BYTE_ORDER_X and
	BYTE_ORDER_Y output parameters.
	(value_binop): Update call to value_args_as_decimal.

	Update calls to decimal_to_string, decimal_from_string,
	decimal_from_integral, decimal_from_floating, decimal_to_doublest,
	decimal_is_zero, decimal_binop, decimal_compare and decimal_convert
	to pass/receive byte order:
	* c-exp.y (parse_number): Update.
	* printcmd.c (printf_command): Update.
	* valarith.c (value_args_as_decimal, value_binop, value_logical_not,
	value_equal, value_less): Update.
	* valops.c (value_cast, value_one): Update.
	* valprint.c (print_decimal_floating): Update.
	* value.c (unpack_long, unpack_double): Update.
	* python/python-value.c (valpy_nonzero): Update.


	* ada-valprint.c (char_at): Add BYTE_ORDER parameter.
	(printstr): Update calls to char_at.
	(ada_val_print_array): Likewise.
	* valprint.c (read_string): Add BYTE_ORDER parameter.
	(val_print_string): Update call to read_string.
	* c-lang.c (c_get_string): Likewise.
	* charset.h (target_wide_charset): Add BYTE_ORDER parameter.
	* charset.c (target_wide_charset): Add BYTE_ORDER parameter.
	Use it instead of current_gdbarch.
	* printcmd.c (printf_command): Update calls to target_wide_charset.
	* c-lang.c (charset_for_string_type): Add BYTE_ORDER parameter.
	Pass to target_wide_charset.  Use it instead of current_gdbarch.
	(classify_type): Add BYTE_ORDER parameter.  Pass to
	charset_for_string_type.  Allow NULL encoding pointer.
	(print_wchar): Add BYTE_ORDER parameter.
	(c_emit_char): Update calls to classify_type and print_wchar.
	(c_printchar, c_printstr): Likewise.


	* gdbarch.sh (in_solib_return_trampoline): Convert to type "m".
	* gdbarch.c, gdbarch.h: Regenerate.
	* arch-utils.h (generic_in_solib_return_trampoline): Add GDBARCH
	parameter.
	* arch-utils.c (generic_in_solib_return_trampoline): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_in_solib_return_trampoline): Likewise.
	* rs6000-tdep.c (rs6000_in_solib_return_trampoline): Likewise.
	(rs6000_skip_trampoline_code): Update call.

	* alpha-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	dynamic_sigtramp_offset and pc_in_sigtramp callbacks.
	(alpha_read_insn): Add GDBARCH parameter.
	* alpha-tdep.c (alpha_lds, alpha_sts): Add GDBARCH parameter.
	(alpha_register_to_value): Pass architecture to alpha_sts.
	(alpha_extract_return_value): Likewise.
	(alpha_value_to_register): Pass architecture to alpha_lds.
	(alpha_store_return_value): Likewise.
	(alpha_read_insn): Add GDBARCH parameter.
	(alpha_skip_prologue): Pass architecture to alpha_read_insn.
	(alpha_heuristic_proc_start): Likewise.
	(alpha_heuristic_frame_unwind_cache): Likewise.
	(alpha_next_pc): Likewise.
	(alpha_sigtramp_frame_this_id): Pass architecture to
	tdep->dynamic_sigtramp_offset callback.
	(alpha_sigtramp_frame_sniffer): Pass architecture to
	tdep->pc_in_sigtramp callback.
	* alphafbsd-tdep.c (alphafbsd_pc_in_sigtramp): Add GDBARCH parameter.
	(alphafbsd_sigtramp_offset): Likewise.
	* alpha-linux-tdep.c (alpha_linux_sigtramp_offset_1): Add GDBARCH
	parameter.  Pass to alpha_read_insn.
	(alpha_linux_sigtramp_offset): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset_1.
	(alpha_linux_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset.
	(alpha_linux_sigcontext_addr): Pass architecture to alpha_read_insn
	and alpha_linux_sigtramp_offset.
	* alphanbsd-tdep.c (alphanbsd_sigtramp_offset): Add GDBARCH parameter.
	(alphanbsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alphanbsd_sigtramp_offset.
	* alphaobsd-tdep.c (alphaobsd_sigtramp_offset): Add GDBARCH parameter.
	(alphaobsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_read_insn.
	(alphaobsd_sigcontext_addr): Pass architecture to
	alphaobsd_sigtramp_offset.
	* alpha-osf1-tdep.c (alpha_osf1_pc_in_sigtramp): Add GDBARCH
	parameter.

	* amd64-tdep.c (amd64_analyze_prologue): Add GDBARCH parameter.
	(amd64_skip_prologue): Pass architecture to amd64_analyze_prologue.
	(amd64_frame_cache): Likewise.

	* arm-tdep.c (SWAP_SHORT, SWAP_INT): Remove.
	(thumb_analyze_prologue, arm_skip_prologue, arm_scan_prologue,
	thumb_get_next_pc, arm_get_next_pc): Do not use SWAP_ macros.
	* arm-wince-tdep.c: Include "frame.h".

	* avr-tdep.c (EXTRACT_INSN): Remove.
	(avr_scan_prologue): Add GDBARCH argument, inline EXTRACT_INSN.
	(avr_skip_prologue): Pass architecture to avr_scan_prologue.
	(avr_frame_unwind_cache): Likewise.

	* cris-tdep.c (struct instruction_environment): Add BYTE_ORDER member.
	(find_step_target): Initialize it.
	(get_data_from_address): Add BYTE_ORDER parameter.
	(bdap_prefix): Pass byte order to get_data_from_address.
	(handle_prefix_assign_mode_for_aritm_op): Likewise.
	(three_operand_add_sub_cmp_and_or_op): Likewise.
	(handle_inc_and_index_mode_for_aritm_op): Likewise.

	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp): Add GDBARCH parameter.
	(frv_linux_sigcontext_reg_addr): Pass architecture to
	frv_linux_pc_in_sigtramp.
	(frv_linux_sigtramp_frame_sniffer): Likewise.

	* h8300-tdep.c (h8300_is_argument_spill): Add GDBARCH parameter.
	(h8300_analyze_prologue): Add GDBARCH parameter.  Pass to
	h8300_is_argument_spill.
	(h8300_frame_cache, h8300_skip_prologue): Pass architecture
	to h8300_analyze_prologue.

	* hppa-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	in_solib_call_trampoline callback.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.
	* hppa-tdep.c (hppa64_convert_code_addr_to_fptr): Add GDBARCH
	parameter.
	(hppa64_push_dummy_call): Pass architecture to
	hppa64_convert_code_addr_to_fptr.
	(hppa_match_insns): Add GDBARCH parameter.
	(hppa_match_insns_relaxed): Add GDBARCH parameter.  Pass to
	hppa_match_insns.
	(hppa_skip_trampoline_code): Pass architecture to hppa_match_insns.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.  Pass to
	hppa_match_insns_relaxed.
	(hppa_stub_unwind_sniffer): Pass architecture to
	tdep->in_solib_call_trampoline callback.
	* hppa-hpux-tdep.c (hppa_hpux_search_pattern): Add GDBARCH parameter.
	(hppa32_hpux_search_dummy_call_sequence): Pass architecture to
	hppa_hpux_search_pattern.
	* hppa-linux-tdep.c (insns_match_pattern): Add GDBARCH parameter.
	(hppa_linux_sigtramp_find_sigcontext): Add GDBARCH parameter.
	Pass to insns_match_pattern.
	(hppa_linux_sigtramp_frame_unwind_cache): Pass architecture to
	hppa_linux_sigtramp_find_sigcontext.
	(hppa_linux_sigtramp_frame_sniffer): Likewise.
	(hppa32_hpux_in_solib_call_trampoline): Add GDBARCH parameter.
	(hppa64_hpux_in_solib_call_trampoline): Likewise.

	* i386-tdep.c (i386_follow_jump): Add GDBARCH parameter.
	(i386_analyze_frame_setup): Add GDBARCH parameter.
	(i386_analyze_prologue): Add GDBARCH parameter.  Pass to
	i386_follow_jump and i386_analyze_frame_setup.
	(i386_skip_prologue): Pass architecture to i386_analyze_prologue
	and i386_follow_jump.
	(i386_frame_cache): Pass architecture to i386_analyze_prologue.
	(i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-tdep.h (i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-cygwin-tdep.c (i386_cygwin_skip_trampoline_code): Pass
	frame to i386_pe_skip_trampoline_code.

	* ia64-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter
	to sigcontext_register_address callback.
	* ia64-tdep.c (ia64_find_global_pointer): Add GDBARCH parameter.
	(ia64_find_unwind_table): Pass architecture to
	ia64_find_global_pointer.
	(find_extant_func_descr): Add GDBARCH parameter.
	(find_func_descr): Pass architecture to find_extant_func_descr
	and ia64_find_global_pointer.
	(ia64_sigtramp_frame_init_saved_regs): Pass architecture to
	tdep->sigcontext_register_address callback.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Add
	GDBARCH parameter.

	* iq2000-tdep.c (iq2000_scan_prologue): Add GDBARCH parameter.
	(iq2000_frame_cache): Pass architecture to iq2000_scan_prologue.

	* lm32-tdep.c (lm32_analyze_prologue): Add GDBARCH parameter.
	(lm32_skip_prologue, lm32_frame_cache): Pass architecture to
	lm32_analyze_prologue.

	* m32r-tdep.c (decode_prologue): Add GDBARCH parameter.
	(m32r_skip_prologue): Pass architecture to decode_prologue.

	* m68hc11-tdep.c (m68hc11_analyze_instruction): Add GDBARCH parameter.
	(m68hc11_scan_prologue): Pass architecture to
	m68hc11_analyze_instruction.

	* m68k-tdep.c (m68k_analyze_frame_setup): Add GDBARCH parameter.
	(m68k_analyze_prologue): Pass architecture to
	m68k_analyze_frame_setup.

	* m88k-tdep.c (m88k_fetch_instruction): Add BYTE_ORDER parameter.
	(m88k_analyze_prologue): Add GDBARCH parameter.  Pass byte order
	to m88k_fetch_instruction.
	(m88k_skip_prologue): Pass architecture to m88k_analyze_prologue.
	(m88k_frame_cache): Likewise.

	* mep-tdep.c (mep_get_insn): Add GDBARCH parameter.
	(mep_analyze_prologue): Pass architecture to mep_get_insn.

	* mips-tdep.c (mips_fetch_instruction): Add GDBARCH parameter.
	(mips32_next_pc): Pass architecture to mips_fetch_instruction.
	(deal_with_atomic_sequence): Likewise.
	(unpack_mips16): Add GDBARCH parameter, pass to mips_fetch_instruction.
	(mips16_scan_prologue): Likewise.
	(mips32_scan_prologue): Likewise.
	(mips16_in_function_epilogue_p): Likewise.
	(mips32_in_function_epilogue_p): Likewise.
	(mips_about_to_return): Likewise.
	(mips_insn16_frame_cache): Pass architecture to mips16_scan_prologue.
	(mips_insn32_frame_cache): Pass architecture to mips32_scan_prologue.
	(mips_skip_prologue): Pass architecture to mips16_scan_prologue
	and mips32_scan_prologue.
	(mips_in_function_epilogue_p): Pass architecture to
	mips16_in_function_epilogue_p and
	mips32_in_function_epilogue_p.
	(heuristic_proc_start): Pass architecture to mips_fetch_instruction
	and mips_about_to_return.
	(mips_skip_mips16_trampoline_code): Pass architecture to
	mips_fetch_instruction.
	(fetch_mips_16): Add GDBARCH parameter.
	(mips16_next_pc): Pass architecture to fetch_mips_16.
	(extended_mips16_next_pc): Pass architecture to unpack_mips16 and
	fetch_mips_16.

	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class): Add GDBARCH parameter.
	(find_implementation_from_class): Add GDBARCH parameter, pass
	to read_objc_class, read_objc_methlist_nmethods, and
	read_objc_methlist_method.
	(find_implementation): Add GDBARCH parameter, pass to
	read_objc_object and find_implementation_from_class.
	(resolve_msgsend, resolve_msgsend_stret): Pass architecture
	to find_implementation.
	(resolve_msgsend_super, resolve_msgsend_super_stret): Pass
	architecture to read_objc_super and find_implementation_from_class.

	* ppc64-linux-tdep.c (ppc64_desc_entry_point): Add GDBARCH parameter.
	(ppc64_standard_linkage1_target, ppc64_standard_linkage2_target,
	ppc64_standard_linkage3_target): Pass architecture to
	ppc64_desc_entry_point.
	* rs6000-tdep.c (bl_to_blrl_insn_p): Add BYTE_ORDER parameter.
	(skip_prologue): Pass byte order to bl_to_blrl_insn_p.
	(rs6000_fetch_instruction): Add GDBARCH parameter.
	(rs6000_skip_stack_check): Add GDBARCH parameter, pass to
	rs6000_fetch_instruction.
	(skip_prologue): Pass architecture to rs6000_fetch_instruction.

	* remote-mips.c (mips_store_word): Return old_contents as host
	integer value instead of target bytes.

	* s390-tdep.c (struct s390_prologue_data): Add BYTE_ORDER member.
	(s390_analyze_prologue): Initialize it.
	(extend_simple_arg): Add GDBARCH parameter.
	(s390_push_dummy_call): Pass architecture to extend_simple_arg.

	* scm-lang.c (scm_get_field): Add BYTE_ORDER parameter.
	* scm-lang.h (scm_get_field): Add BYTE_ORDER parameter.
	(SCM_CAR, SCM_CDR): Pass SCM_BYTE_ORDER to scm_get_field.
	* scm-valprint.c (scm_scmval_print): Likewise.
	(scm_scmlist_print, scm_ipruk, scm_scmval_print): Define
	SCM_BYTE_ORDER.

	* sh64-tdep.c (look_for_args_moves): Add GDBARCH parameter.
	(sh64_skip_prologue_hard_way): Add GDBARCH parameter, pass to
	look_for_args_moves.
	(sh64_skip_prologue): Pass architecture to
	sh64_skip_prologue_hard_way.
	* sh-tdep.c (sh_analyze_prologue): Add GDBARCH parameter.
	(sh_skip_prologue): Pass architecture to sh_analyze_prologue.
	(sh_frame_cache): Likewise.

	* solib-irix.c (extract_mips_address): Add GDBARCH parameter.
	(fetch_lm_info, irix_current_sos, irix_open_symbol_file_object):
	Pass architecture to extract_mips_address.

	* sparc-tdep.h (sparc_fetch_wcookie): Add GDBARCH parameter.
	* sparc-tdep.c (sparc_fetch_wcookie): Add GDBARCH parameter.
	(sparc_supply_rwindow, sparc_collect_rwindow): Pass architecture
	to sparc_fetch_wcookie.
	(sparc32_frame_prev_register): Likewise.
	* sparc64-tdep.c (sparc64_frame_prev_register): Likewise.
	* sparc32nbsd-tdep.c (sparc32nbsd_sigcontext_saved_regs): Likewise.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_saved_regs): Likewise.

	* spu-tdep.c (spu_analyze_prologue): Add GDBARCH parameter.
	(spu_skip_prologue): Pass architecture to spu_analyze_prologue.
	(spu_virtual_frame_pointer): Likewise.
	(spu_frame_unwind_cache): Likewise.
	(info_spu_mailbox_list): Add BYTE_ORER parameter.
	(info_spu_mailbox_command): Pass byte order to info_spu_mailbox_list.
	(info_spu_dma_cmdlist): Add BYTE_ORER parameter.
	(info_spu_dma_command, info_spu_proxydma_command): Pass byte order
	to info_spu_dma_cmdlist.

	* symfile.c (read_target_long_array): Add GDBARCH parameter.
	(simple_read_overlay_table, simple_read_overlay_region_table,
	simple_overlay_update_1): Pass architecture to read_target_long_array.

	* v850-tdep.c (v850_analyze_prologue): Add GDBARCH parameter.
	(v850_frame_cache): Pass architecture to v850_analyze_prologue.

	* xstormy16-tdep.c (xstormy16_analyze_prologue): Add GDBARCH
	parameter.
	(xstormy16_skip_prologue, xstormy16_frame_cache): Pass architecture
	to xstormy16_analyze_prologue.
	(xstormy16_resolve_jmp_table_entry): Add GDBARCH parameter.
	(xstormy16_find_jmp_table_entry): Likewise.
	(xstormy16_skip_trampoline_code): Pass architecture to
	xstormy16_resolve_jmp_table_entry.
	(xstormy16_pointer_to_address): Likewise.
	(xstormy16_address_to_pointer): Pass architecture to
	xstormy16_find_jmp_table_entry.

	* xtensa-tdep.c (call0_track_op): Add GDBARCH parameter.
	(call0_analyze_prologue): Add GDBARCH parameter, pass to
	call0_track_op.
	(call0_frame_cache): Pass architecture to call0_analyze_prologue.
	(xtensa_skip_prologue): Likewise.
@
text
@d1443 13
a1455 8
      if (output)
	obstack_grow_str (output, "\\");
      while (isdigit (*tokptr) && *tokptr != '8' && *tokptr != '9')
	{
	  if (output)
	    obstack_1grow (output, *tokptr);
	  ++tokptr;
	}
@


1.57
log
@	* gdbtypes.h (struct language_defn): Add forward declaration.
	(lookup_typename): Add LANGUAGE and GDBARCH parameters.
	(lookup_unsigned_typename): Likewise.
	(lookup_signed_typename): Likewise.
	* gdbtypes.c (lookup_typename): Add LANGUAGE and GDBARCH parameters.
	Use them instead of current_language and current_gdbarch.
	(lookup_unsigned_typename): Add LANGUAGE and GDBARCH parameters.
	Pass them to lookup_typename.
	(lookup_signed_typename): Likewise.

	* c-exp.y: Pass parse_language and parse_gdbarch to
	lookup_unsigned_typename and lookup_signed_typename.
	* objc-exp.y: Likewise.
	* m2-exp.y: Pass parse_language and parse_gdbarch to lookup_typename.

	* c-lang.c (evaluate_subexp_c): Pass expression language and
	gdbarch to lookup_typename.
	* printcmd.c (printf_command): Pass current language and
	gdbarch to lookup_typename.
	* python/python-type.c (typy_lookup_typename): Likewise.
	Include "language.h".
@
text
@d1184 2
a1185 1
	  decimal_from_string (putithere->typed_val_decfloat.val, 4, p);
d1195 2
a1196 1
	  decimal_from_string (putithere->typed_val_decfloat.val, 8, p);
d1206 2
a1207 1
	  decimal_from_string (putithere->typed_val_decfloat.val, 16, p);
@


1.56
log
@	* c-exp.y (parse_number): Don't use K&R definition.
	(yylex): Likewise.
	(yyerror): Likewise.
@
text
@d972 3
a974 1
			{ $$ = lookup_unsigned_typename (TYPE_NAME($2.type)); }
d978 3
a980 1
			{ $$ = lookup_signed_typename (TYPE_NAME($2.type)); }
@


1.55
log
@gdb
	* c-exp.y (yylex): Handle '[' and ']' like '(' and ')'.
gdb/testsuite
	* gdb.base/printcmds.exp (test_printf): Test comma operator in [].
@
text
@d1142 1
a1142 5
parse_number (p, len, parsed_float, putithere)
     char *p;
     int len;
     int parsed_float;
     YYSTYPE *putithere;
d1807 1
a1807 1
yylex ()
d2208 1
a2208 2
yyerror (msg)
     char *msg;
@


1.54
log
@gdb:
2009-03-19  Tom Tromey  <tromey@@redhat.com>
	    Julian Brown  <julian@@codesourcery.com>

	PR i18n/7220, PR i18n/7821, PR exp/8815, PR exp/9103,
	PR i18n/9401, PR exp/9613:
	* NEWS: Update
	* value.h (value_typed_string): Declare.
	(val_print_string): Update.
	* valprint.h (print_char_chars): Update.
	* valprint.c (print_char_chars): Add type argument.  Update.
	(val_print_string): Likewise.
	* valops.c (value_typed_string): New function.
	* utils.c (host_char_to_target): New function.
	(parse_escape): Use host_char_to_target, host_hex_value.  Update.
	Remove '^' case.
	(no_control_char_error): Remove.
	* typeprint.c (print_type_scalar): Update.
	* scm-valprint.c (scm_scmval_print): Update.
	* scm-lang.h (scm_printchar, scm_printstr): Update.
	* scm-lang.c (scm_printchar): Add type argument.
	(scm_printstr): Likewise.
	* printcmd.c (print_formatted): Update.
	(print_scalar_formatted): Update.
	(printf_command) <wide_string_arg, wide_char_arg>: New constants.
	Handle '%lc' and '%ls'.
	* parser-defs.h (struct typed_stoken): New type.
	(struct stoken_vector): Likewise.
	(write_exp_string_vector): Declare.
	* parse.c (write_exp_string_vector): New function.
	* p-valprint.c (pascal_val_print): Update.
	* p-lang.h (is_pascal_string_type, pascal_printchar,
	pascal_printstr): Update.
	* p-lang.c (is_pascal_string_type): Remove 'char_size' argument.
	Add 'char_type' argument.
	(pascal_emit_char): Add type argument.
	(pascal_printchar): Likewise.
	(pascal_printstr): Likewise.
	* objc-lang.c (objc_emit_char): Add type argument.
	(objc_printchar): Likewise.
	(objc_printstr): Likewise.
	* macroexp.c (get_character_constant): Handle unicode characters.
	Use c_parse_escape.
	(get_string_literal): Handle unicode strings.  Use
	c_parse_escape.
	* m2-valprint.c (print_unpacked_pointer): Update.
	(m2_print_array_contents): Update.
	(m2_val_print): Update.
	* m2-lang.c (m2_emit_char): Add type argument.
	(m2_printchar): Likewise.
	(m2_printstr): Likewise.
	* language.h (struct language_defn) <la_printchar>: Add type
	argument.
	<la_printstr, la_emitchar>: Likewise.
	(LA_PRINT_CHAR): Likewise.
	(LA_PRINT_STRING): Likewise.
	(LA_EMIT_CHAR): Likewise.
	* language.c (unk_lang_emit_char): Add type argument.
	(unk_lang_printchar): Likewise.
	(unk_lang_printstr): Likewise.
	* jv-valprint.c (java_val_print): Update.
	* jv-lang.c (java_emit_char): Add type argument.
	* f-valprint.c (f_val_print): Update.
	* f-lang.c (f_emit_char): Add type argument.
	(f_printchar): Likewise.
	(f_printstr): Likewise.
	* expprint.c (print_subexp_standard): Update.
	* charset.h (target_wide_charset): Declare.
	(c_target_char_has_backslash_escape, c_parse_backslash,
	host_char_print_literally, host_char_to_target,
	target_char_to_host, target_char_to_control_char): Remove.
	(enum transliterations): New type.
	(convert_between_encodings): Declare.
	(HOST_ESCAPE_CHAR): New define.
	(host_letter_to_control_character, host_hex_value): Declare.
	(enum wchar_iterate_result): New enum.
	(struct wchar_iterator): Declare.
	(make_wchar_iterator, make_cleanup_wchar_iterator, wchar_iterator,
	wchar_push_back): Declare.
	* charset-list.h: New file.
	* c-valprint.c (textual_name): New function.
	(textual_element_type): Handle wide character types.
	(c_val_print): Pass original type to textual_element_type.  Handle
	wide character types.
	(c_value_print): Use textual_element_type.  Pass original type of
	value to val_print.
	* c-lang.h (enum c_string_type): New type.
	(c_printchar, c_printstr): Update.
	* c-lang.c (classify_type): New function.
	(print_wchar): Likewise.
	(c_emit_char): Add type argument.  Handle wide characters.
	(c_printchar): Likewise.
	(c_printstr): Add type argument.  Handle wide and multibyte
	character sets.
	(convert_ucn): New function.
	(emit_numeric_character): Likewise.
	(convert_octal): Likewise.
	(convert_hex): Likewise.
	(ADVANCE): New macro.
	(convert_escape): New function.
	(parse_one_string): Likewise.
	(evaluate_subexp_c): Likewise.
	(exp_descriptor_c): New global.
	(c_language_defn): Use exp_descriptor_c.
	(cplus_language_defn): Likewise.
	(asm_language_defn): Likewise.
	(minimal_language_defn): Likewise.
	(charset_for_string_type): New function.
	* c-exp.y (%union): Add 'svec' and 'tsval'.
	(CHAR): New token.
	(exp): Add CHAR production.
	(string_exp): Rewrite.
	(exp) <string_exp>: Rewrite.
	(tempbuf): Now global.
	(tempbuf_init): New global.
	(parse_string_or_char): New function.
	(yylex) <tempbuf>: Now global.
	<tokptr, tempbufindex, tempbufsize, token_string, class_prefix>:
	Remove.
	Handle 'u', 'U', and 'L' prefixes.  Call parse_string_or_char.
	(c_parse_escape): New function.
	* auxv.c (fprint_target_auxv): Update.
	* ada-valprint.c (ada_emit_char): Add type argument.
	(ada_printchar): Likewise.
	(ada_print_scalar): Update.
	(printstr): Add type argument.  Update calls to ada_emit_char.
	(ada_printstr): Add type argument.
	(ada_val_print_array): Update.
	(ada_val_print_1): Likewise.
	* ada-lang.c (emit_char): Add type argument.
	* ada-lang.h (ada_emit_char, ada_printchar, ada_printstr): Add
	type arguments.
	* gdb_locale.h: Include langinfo.h.
	* charset.c (_initialize_charset): Set default host charset from
	the locale.  Don't register charsets.  Add target-wide-charset
	commands.  Call find_charset_names.
	(struct charset, struct translation): Remove.
	(GDB_DEFAULT_HOST_CHARSET): Remove.
	(GDB_DEFAULT_TARGET_WIDE_CHARSET): New define.
	(target_wide_charset_name): New global.
	(show_host_charset_name): Handle "auto".
	(show_target_wide_charset_name): New function.
	(host_charset_enum, target_charset_enum): Remove.
	(charset_enum): New global.
	(all_charsets, register_charset, lookup_charset, all_translations,
	register_translation, lookup_translation): Remove.
	(simple_charset, ascii_print_literally, ascii_to_control): Remove.
	(iso_8859_print_literally, iso_8859_to_control,
	iso_8859_family_charset): Remove.
	(ebcdic_print_literally, ebcdic_to_control,
	ebcdic_family_charset): Remove.
	(struct cached_iconv, check_iconv_cache, cached_iconv_convert,
	register_iconv_charsets): Remove.
	(target_wide_charset_be_name, target_wide_charset_le_name): New
	globals.
	(identity_either_char_to_other): Remove.
	(set_be_le_names, validate): New functions.
	(backslashable, backslashed, represented): Remove.
	(default_c_target_char_has_backslash_escape): Remove.
	(default_c_parse_backslash, iconv_convert): Remove.
	(ascii_to_iso_8859_1_table, ascii_to_ebcdic_us_table,
	ascii_to_ibm1047_table, iso_8859_1_to_ascii_table,
	iso_8859_1_to_ebcdic_us_table, iso_8859_1_to_ibm1047_table,
	ebcdic_us_to_ascii_table, ebcdic_us_to_iso_8859_1_table,
	ebcdic_us_to_ibm1047_table, ibm1047_to_ascii_table,
	ibm1047_to_iso_8859_1_table, ibm1047_to_ebcdic_us_table): Remove.
	(table_convert_char, table_translation, simple_table_translation):
	Remove.
	(current_host_charset, current_target_charset,
	c_target_char_has_backslash_escape_func,
	c_target_char_has_backslash_escape_baton): Remove.
	(c_parse_backslash_func, c_parse_backslash_baton): Remove.
	(host_char_to_target_func, host_char_to_target_baton): Remove.
	(target_char_to_host_func, target_char_to_host_baton): Remove.
	(cached_iconv_host_to_target, cached_iconv_target_to_host):
	Remove.
	(lookup_charset_or_error, check_valid_host_charset): Remove.
	(set_host_and_target_charsets): Remove.
	(set_host_charset, set_target_charset): Remove.
	(set_host_charset_sfunc, set_target_charset_sfunc): Rewrite.
	(set_target_wide_charset_sfunc): New function.
	(show_charset): Print target wide character set.
	(host_charset, target_charset): Rewrite.
	(target_wide_charset): New function.
	(c_target_char_has_backslash_escape): Remove.
	(c_parse_backslash): Remove.
	(host_letter_to_control_character): New function.
	(host_char_print_literally): Remove.
	(host_hex_value): New function.
	(target_char_to_control_char): Remove.
	(cleanup_iconv): New function.
	(convert_between_encodings): New function.
	(target_char_to_host): Remove.
	(struct wchar_iterator): Define.
	(make_wchar_iterator, make_cleanup_wchar_iterator, wchar_iterator,
	wchar_push_back): New functions.
	(do_cleanup_iterator): New function.
	(char_ptr): New typedef.
	(charsets): New global.
	(add_one, find_charset_names): New functions.
	(default_charset_names): New global.
	(auto_host_charset_name): Likewise.
	* aclocal.m4, config.in, configure: Rebuild.
	* configure.ac: Call AM_LANGINFO_CODESET.
	(GDB_DEFAULT_HOST_CHARSET): Default to UTF-8.
	(AM_ICONV): Invoke earlier.
	* acinclude.m4: Include codeset.m4.  Subst LIBICONV_INCLUDE and
	LIBICONV_LIBDIR.  Check for libiconv in build tree.
	* Makefile.in (LIBICONV_LIBDIR, LIBICONV_INCLUDE): New macros.
	(INTERNAL_CFLAGS_BASE): Add LIBICONV_INCLUDE.
	(INTERNAL_LDFLAGS): Add LIBICONV_LIBDIR.
	* gdb_obstack.h (obstack_grow_wstr): New define.
        * gdb_wchar.h: New file.
        * defs.h: Include it.
gdb/testsuite:
	* gdb.base/store.exp: Update for change to escape output.
	* gdb.base/callfuncs.exp (fetch_all_registers): Update for change
	to escape output.
	* gdb.base/pointers.exp: Update for change to escape output.
	* gdb.base/long_long.exp (gdb_test_long_long): Update for change
	to escape output.
	* gdb.base/constvars.exp (do_constvar_tests): Update for change to
	escape output.
	* gdb.base/call-rt-st.exp (print_struct_call): Update for change
	to escape output.
	* gdb.cp/ref-types.exp (gdb_start_again): Update for change to
	escape output.
	* gdb.base/setvar.exp: Update for change to escape output.
	* lib/gdb.exp (default_gdb_start): Set LC_CTYPE to C.
	* gdb.base/printcmds.exp (test_print_all_chars): Update for change
	to escape output.
	(test_print_string_constants): Likewise.
	* gdb.base/charset.exp (valid_host_charset): Check size of
	wchar_t.  Handle UCS-2 and UCS-4.  Add tests for wide and unicode
	cases.  Handle "auto"-related output.
	* gdb.base/charset.c (char16_t, char32_t): New typedefs.
	(uvar, Uvar): New globals.
gdb/doc:
	* gdb.texinfo (Character Sets): Remove obsolete text.  Document
	set target-wide-charset.
	(Requirements): Mention iconv.
@
text
@d1888 1
d1894 1
a1995 2
    case '[':
    case ']':
@


1.53
log
@	* Makefile.in: Update license to GPLv3.
	* ada-exp.y: Update license to GPLv3.
	* ada-lex.l: Update license to GPLv3.
	* c-exp.y: Update license to GPLv3.
	* cp-name-parser.y: Update license to GPLv3.
	* darwin-nat-info.c: Update license to GPLv3.
	* f-exp.y: Update license to GPLv3.
	* gdb_thread_db.h: Update license to GPLv3.
	* hppanbsd-nat.c: Update license to GPLv3.
	* hppanbsd-tdep.c: Update license to GPLv3.
	* hppaobsd-tdep.c: Update license to GPLv3.
	* jv-exp.y: Update license to GPLv3.
	* m2-exp.y: Update license to GPLv3.
	* objc-exp.y: Update license to GPLv3.
	* p-exp.y: Update license to GPLv3.
	* reply_mig_hack.awk: Update license to GPLv3.
	* reverse.c: Update license to GPLv3.
	* xtensa-xtregs.c: Update license to GPLv3.
@
text
@d144 1
d152 1
d185 2
a186 1
%token <sval> STRING
d190 2
a191 1
%type <sval> name string_exp
d529 9
d586 8
a593 3
			  $$.length = $1.length;
			  $$.ptr = malloc ($1.length + 1);
			  memcpy ($$.ptr, $1.ptr, $1.length + 1);
d600 11
a610 7
			  struct stoken t;
			  t.length = $1.length + $2.length;
			  t.ptr = malloc (t.length + 1);
			  memcpy (t.ptr, $1.ptr, $1.length);
			  memcpy (t.ptr + $1.length, $2.ptr, $2.length + 1);
			  free ($1.ptr);
			  $$ = t;
d615 5
a619 7
			{ /* C strings are converted into array constants with
			     an explicit null byte added at the end.  Thus
			     the array upper bound is the string length.
			     There is no such thing in C as a completely empty
			     string. */
			  char *sp = $1.ptr; int count = $1.length;
			  while (count-- > 0)
d621 17
a637 4
			      write_exp_elt_opcode (OP_LONG);
			      write_exp_elt_type (parse_type->builtin_char);
			      write_exp_elt_longcst ((LONGEST)(*sp++));
			      write_exp_elt_opcode (OP_LONG);
d639 5
a643 9
			  write_exp_elt_opcode (OP_LONG);
			  write_exp_elt_type (parse_type->builtin_char);
			  write_exp_elt_longcst ((LONGEST)'\0');
			  write_exp_elt_opcode (OP_LONG);
			  write_exp_elt_opcode (OP_ARRAY);
			  write_exp_elt_longcst ((LONGEST) 0);
			  write_exp_elt_longcst ((LONGEST) ($1.length));
			  write_exp_elt_opcode (OP_ARRAY);
			  free ($1.ptr);
d1391 257
a1816 6
  char *tokptr;
  int tempbufindex;
  static char *tempbuf;
  static int tempbufsize;
  char * token_string = NULL;
  int class_prefix = 0;
a1887 40
    case '\'':
      /* We either have a character constant ('0' or '\177' for example)
	 or we have a quoted symbol reference ('foo(int,int)' in C++
	 for example). */
      lexptr++;
      c = *lexptr++;
      if (c == '\\')
	c = parse_escape (&lexptr);
      else if (c == '\'')
	error ("Empty character constant.");
      else if (! host_char_to_target (c, &c))
        {
          int toklen = lexptr - tokstart + 1;
          char *tok = alloca (toklen + 1);
          memcpy (tok, tokstart, toklen);
          tok[toklen] = '\0';
          error ("There is no character corresponding to %s in the target "
                 "character set `%s'.", tok, target_charset ());
        }

      yylval.typed_val_int.val = c;
      yylval.typed_val_int.type = parse_type->builtin_char;

      c = *lexptr++;
      if (c != '\'')
	{
	  namelen = skip_quoted (tokstart) - tokstart;
	  if (namelen > 2)
	    {
	      lexptr = tokstart + namelen;
	      if (lexptr[-1] != '\'')
		error ("Unmatched single quote.");
	      namelen -= 2;
	      tokstart++;
	      goto tryname;
	    }
	  error ("Invalid character constant.");
	}
      return INT;

d2005 7
d2013 5
a2017 23

      /* Build the gdb internal form of the input string in tempbuf,
	 translating any standard C escape forms seen.  Note that the
	 buffer is null byte terminated *only* for the convenience of
	 debugging gdb itself and printing the buffer contents when
	 the buffer contains no embedded nulls.  Gdb does not depend
	 upon the buffer being null byte terminated, it uses the length
	 string instead.  This allows gdb to handle C strings (as well
	 as strings in other languages) with embedded null bytes */

      tokptr = ++tokstart;
      tempbufindex = 0;

      do {
        char *char_start_pos = tokptr;

	/* Grow the static temp buffer if necessary, including allocating
	   the first one on demand. */
	if (tempbufindex + 1 >= tempbufsize)
	  {
	    tempbuf = (char *) realloc (tempbuf, tempbufsize += 64);
	  }
	switch (*tokptr)
d2019 3
a2021 8
	  case '\0':
	  case '"':
	    /* Do nothing, loop will terminate. */
	    break;
	  case '\\':
	    tokptr++;
	    c = parse_escape (&tokptr);
	    if (c == -1)
d2023 3
a2025 1
		continue;
d2027 2
a2028 17
	    tempbuf[tempbufindex++] = c;
	    break;
	  default:
	    c = *tokptr++;
            if (! host_char_to_target (c, &c))
              {
                int len = tokptr - char_start_pos;
                char *copy = alloca (len + 1);
                memcpy (copy, char_start_pos, len);
                copy[len] = '\0';

                error ("There is no character corresponding to `%s' "
                       "in the target character set `%s'.",
                       copy, target_charset ());
              }
            tempbuf[tempbufindex++] = c;
	    break;
d2030 2
a2031 10
      } while ((*tokptr != '"') && (*tokptr != '\0'));
      if (*tokptr++ != '"')
	{
	  error ("Unterminated string in expression.");
	}
      tempbuf[tempbufindex] = '\0';	/* See note above */
      yylval.sval.ptr = tempbuf;
      yylval.sval.length = tempbufindex;
      lexptr = tokptr;
      return (STRING);
@


1.52
log
@        Updated copyright notices for most files.
@
text
@d6 1
a6 1
This file is part of GDB.
d8 12
a19 14
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor,
Boston, MA 02110-1301, USA.  */
@


1.51
log
@gdb
	* c-exp.y (ident_tokens): New global.
	(struct token) <cxx_only>: New field.
	(tokentab3): Update.
	(tokentab2): Update.
	(yylex): Use ident_tokens.
gdb/testsuite
	* gdb.cp/punctuator.exp: New file.
@
text
@d3 1
a3 1
   1998, 1999, 2000, 2003, 2004, 2006, 2007, 2008
@


1.50
log
@gdb
	PR macros/2564:
	* c-exp.y (macro_original_text, expansion_obstack,
	expression_macro_scope): New globals.
	(scan_macro_expansion): New function.
	(scanning_macro_expansion): Likewise.
	(finished_macro_expansion): Likewise.
	(scan_macro_cleanup): Likewise.
	(c_parse): Find macro scope.  Initialize obstack.
	* c-lang.h (scan_macro_expansion, scanning_macro_expansion,
	finished_macro_expansion, expression_macro_lookup_func,
	expression_macro_lookup_baton): Remove.
	* c-lang.c (scan_macro_expansion, scanning_macro_expansion,
	finished_macro_expansion, expression_macro_lookup_func,
	expression_macro_lookup_baton): Remove.
	(macro_original_text, macro_expanded_text,
	c_preprocess_and_parse): Remove.
	(c_language_defn, cplus_language_defn, asm_language_defn,
	minimal_language_defn): Use c_parse.
gdb/testsuite
	* gdb.base/macscp.exp: Print "address.addr".
	* gdb.base/macscp1.c (struct outer): New struct.
	(address): New global.
@
text
@d1369 1
d1374 2
a1375 2
    {">>=", ASSIGN_MODIFY, BINOP_RSH},
    {"<<=", ASSIGN_MODIFY, BINOP_LSH}
d1380 53
a1432 20
    {"+=", ASSIGN_MODIFY, BINOP_ADD},
    {"-=", ASSIGN_MODIFY, BINOP_SUB},
    {"*=", ASSIGN_MODIFY, BINOP_MUL},
    {"/=", ASSIGN_MODIFY, BINOP_DIV},
    {"%=", ASSIGN_MODIFY, BINOP_REM},
    {"|=", ASSIGN_MODIFY, BINOP_BITWISE_IOR},
    {"&=", ASSIGN_MODIFY, BINOP_BITWISE_AND},
    {"^=", ASSIGN_MODIFY, BINOP_BITWISE_XOR},
    {"++", INCREMENT, BINOP_END},
    {"--", DECREMENT, BINOP_END},
    {"->", ARROW, BINOP_END},
    {"&&", ANDAND, BINOP_END},
    {"||", OROR, BINOP_END},
    {"::", COLONCOLON, BINOP_END},
    {"<<", LSH, BINOP_END},
    {">>", RSH, BINOP_END},
    {"==", EQUAL, BINOP_END},
    {"!=", NOTEQUAL, BINOP_END},
    {"<=", LEQ, BINOP_END},
    {">=", GEQ, BINOP_END}
d1540 1
a1876 56
  /* Catch specific keywords.  Should be done with a data structure.  */
  switch (namelen)
    {
    case 8:
      if (strncmp (tokstart, "unsigned", 8) == 0)
	return UNSIGNED;
      if (parse_language->la_language == language_cplus
	  && strncmp (tokstart, "template", 8) == 0)
	return TEMPLATE;
      if (strncmp (tokstart, "volatile", 8) == 0)
	return VOLATILE_KEYWORD;
      break;
    case 6:
      if (strncmp (tokstart, "struct", 6) == 0)
	return STRUCT;
      if (strncmp (tokstart, "signed", 6) == 0)
	return SIGNED_KEYWORD;
      if (strncmp (tokstart, "sizeof", 6) == 0)
	return SIZEOF;
      if (strncmp (tokstart, "double", 6) == 0)
	return DOUBLE_KEYWORD;
      break;
    case 5:
      if (parse_language->la_language == language_cplus)
        {
          if (strncmp (tokstart, "false", 5) == 0)
            return FALSEKEYWORD;
          if (strncmp (tokstart, "class", 5) == 0)
            return CLASS;
        }
      if (strncmp (tokstart, "union", 5) == 0)
	return UNION;
      if (strncmp (tokstart, "short", 5) == 0)
	return SHORT;
      if (strncmp (tokstart, "const", 5) == 0)
	return CONST_KEYWORD;
      break;
    case 4:
      if (strncmp (tokstart, "enum", 4) == 0)
	return ENUM;
      if (strncmp (tokstart, "long", 4) == 0)
	return LONG;
      if (parse_language->la_language == language_cplus)
          {
            if (strncmp (tokstart, "true", 4) == 0)
              return TRUEKEYWORD;
          }
      break;
    case 3:
      if (strncmp (tokstart, "int", 3) == 0)
	return INT_KEYWORD;
      break;
    default:
      break;
    }

d1880 15
a1906 1
    char *tmp = copy_name (yylval.sval);
d1911 1
a1911 1
    sym = lookup_symbol (tmp, expression_context_block,
d1928 1
a1928 1
	symtab = lookup_symtab (tmp);
d1947 1
a1947 1
						parse_gdbarch, tmp);
@


1.49
log
@gdb
	PR gdb/2506:
	* c-exp.y (string_exp): New production.
	(exp): Use it.
gdb/testsuite
	* gdb.base/exprs.exp (test_expr): Add test for string
	concatenation.
@
text
@d57 2
d1401 79
d1515 2
a1516 2
                                          expression_macro_lookup_func,
                                          expression_macro_lookup_baton);
d1987 21
d2010 4
a2013 1
  return yyparse ();
d2016 1
@


1.49.2.1
log
@2008-11-20  Stan Shebs  <stan@@codesourcery.com>

	Multi-process (primarily multi-exec) support.

	2008-10-14  Stan Shebs  <stan@@codesourcery.com>

	* blockframe.c (get_frame_block): Get inferior from frame.
	* block.c (block_for_pc_inf): New function.
	* block.h (block_for_pc_inf): Declare.
	* symfile.c (find_pc_inf_sect): New function.
	* symfile.h (find_pc_inf_sect): Declare.
	* symtab.c (find_pc_inf_line): New function.
	* symtab.h (find_pc_inf_line): Declare.
	* frame.c (struct frame_info) New field inferior.
	(fprint_frame_id): Display inferior.
	(get_frame_id): Set inferior_num from inferior.
	(frame_id_eq): Compare inferiors.
	(create_sentinel_frame): Set inferior.
	(create_new_frame): Copy inferior from sentinel.
	(get_prev_frame_raw): Copy inferior from next frame.
	(find_frame_sal): Use find_pc_inf_line.
	(get_frame_inferior): New function.
	* frame.h (struct frame_id): New field inferior_num.

	* breakpoint.c (expand_sals_by_inferiors): Copy section from input
	sal to expanded sals.
	* symtab.c (expand_line_sal): Ditto.

	2008-10-10  Stan Shebs  <stan@@codesourcery.com>

	* remote.c (discard_pending_stop_replies): Initialize prev.
	* infrun.c (infrun_thread_stop_requested): Ditto.

	2008-10-08  Stan Shebs  <stan@@codesourcery.com>

	* inferior.h (struct inferior): Rename environ field to inf_environ.
	* inferior.c (print_inferior): Ditto.

	2008-10-01  Stan Shebs  <stan@@codesourcery.com>

	* inferior.h (detach_fork): Declare here...
	* linux-fork.h (detach_fork): ...instead of here.
	* linux-fork.c (detach_fork): Move to...
	* infrun.c (detach_fork): ...here.
	* remote.c (detach_fork): Remove decl.

	2008-09-30  Stan Shebs  <stan@@codesourcery.com>

	* linespec.c (decode_line_1): Better default for one-exec case.
	* remote (remote_start_remote): Use the exec in the one-exec case.

	2008-09-29  Stan Shebs  <stan@@codesourcery.com>

	* infcmd.c (attach_command): If only one exec, assume it is the
	attached inferior's exec.
	(attach_command_post_wait): Set inferior's exec from
	the one that was found.
	* inf-ptrace.c (inf_ptrace_attach): Only report exec file if
	if there is just one present.
	(inf_ptrace_detach): Use inferior to get correct exec name.

	2008-09-29  Stan Shebs  <stan@@codesourcery.com>

	* inferior.c (print_inferior): Use exec short names, and drop
	unused address space display.

	2008-09-26  Stan Shebs  <stan@@codesourcery.com>

	* breakpoint.c (should_be_inserted): Test for no inferior.
	(clone_breakpoint_location): New function, broken out from...
	(update_breakpoint_inferiors): ...here, also tweak conditions
	for adding a location.
	(insert_breakpoint_location): Don't count non-running inferiors.
	(remove_breakpoint): Set tmp_inf.
	(print_one_breakpoint_location): Add allflag arg, use to always
	show inf.
	(print_one_breakpoint): Add allflag arg.
	(do_captured_breakpoint_query): Fix caller.
	(breakpoint_1): Ditto.
	* exec.c (create_exec): Save full pathname as exec name.
	(find_exec_by_name): Use find_exec_by_substr.
	* fork-child.c (fork_inferior): Warn if exec not found for new
	inferior.

	2008-09-25  Stan Shebs  <stan@@codesourcery.com>

	* breakpoint.c (should_be_inserted): Don't insert in inferiors
	that are not running.
	(update_breakpoint_inferiors): New function.
	(insert_breakpoints): Call it.
	(insert_breakpoint_locations): Don't insert in inferiors that are
	not running.
	(set_raw_breakpoint_without_location): Set trigger set from
	current itset here...
	(set_raw_breakpoint): Instead of here. Also add default fillins
	for the location's inferior.
	(add_location_to_breakpoint): Similarly.
	(expand_sals_by_inferiors): New function.
	(breakpoint_re_set_one): Call it.
	(resolve_sal_pc): Don't set sal inferior.
	* breakpoint.h (struct breakpoint): Remove exec field, never used.
	* inferior.h (inferior_list): Declare.
	* inferior.c (inferior_list): Make public.
	(add_inferior_to_itset): Auto-add inferiors after exec's inferior.
	(first_inferior_in_set): Check for zero-length vector.
	* exec.c (xfer_memory): Use tmp_inf as inferior if set.
	* infcmd.c (focus_command): Improve user feedback.
	* linespec.c (build_canonical_line_spec): Record exec name as part
	of canonical spec.
	(symbol_found): Canonicalize specs more.
	(decode_indirect): Revert rewrite from 2008-09-14.
	(decode_sharp): Use find_exec_by_substr, better error messages.
	* minsyms.c (lookup_minimal_symbol_in_exec): New function.
	(lookup_minimal_symbol_in_exec_1): New function, body of
	lookup_minimal_symbol.
	* symtab.h (lookup_minimal_symbol_in_exec): Declare.
	* symtab.c (find_function_start_sal): Set inferior to use.
	(append_expanded_sal): Return pointer to the new sal.
	* remote.c (remote_xfer_memory): Better parms to ptid_build, remove
	debug print.
	(remote_xfer_partial): Ditto.

	2008-09-22  Pedro Alves  <pedro@@codesourcery.com>

	* inferior.c (itset_member): Fix typo.

	2008-09-22  Stan Shebs  <stan@@codesourcery.com>

	* inferior.h (current_inf): Remove declaration.
	(tmp_inf): Declare.
	* inferior.c (current_inf): Remove.
	(tmp_inf): New global, hack to bypass passing inferior throughout
	target stack.
	(print_inferior): Don't report current_inf.
	(add_inferior_command): Don't use current_inf.
	(name_inferior_command): Use first inferior of current_itset.
	(update_itset): Handle NULL case.
	(add_inferior_itset): Recursively add all inferiors derived from
	an exec if the exec's own inferior is present.
	(first_inferior_in_set): New function.
	(free_inferior): Comment out until references cleared reliably.
	* infcmd.c (focus_command): Don't set current_inf.
	(get_inferior_args): Use first_inferior_in_set instead of
	current_inf.
	(set_inferior_args): Ditto.
	(set_inferior_args_vector): Ditto.
	(notice_args_set): Ditto.
	* breakpoint.c (insert_breakpoint_locations): Remove insertion test
	using current_inf, set tmp_inf.
	(reattach_breakpoints): Set tmp_inf.
	(bpstat_check_breakpoint_conditions): Test trigger set here...
	(bpstat_stop_status): ... instead of here.
	(bpstat_check_trigger_set): Add special case for exec's own
	inferior.
	(print_one_breakpoint_location): Also test for multiple inferiors
	before displaying location's inferior, flag trigger set with "i/t"
	instead of "focus".
	(check_duplicates): Pass location's inferior to...
	(check_duplicates_for): Add inferior arg and use.
	(set_raw_breakpoint): Override sal inferior with one from the
	trigger set.
	(add_location_to_breakpoint): Ditto.
	* remote.c (remote_xfer_memory): Switch inferiors if tmp_inf is
	set to something different from inferior_ptid.
	(remote_xfer_partial): Ditto.
	* top.c (execute_command): Always update the current itset.

	2008-09-19  Stan Shebs  <stan@@codesourcery.com>

	* inferior.c (set_inferior_exec): New function.
	(set_inferior_exec_command): New command.
	* inferior.h: Declare set_inferior_exec.
	* fork-child.c (fork_inferior): Set the inferior's exec.
	* remote.c (extended_remote_create_inferior_1): Ditto.
	gdb/doc/
	* gdb.texinfo (Debugging Multiple Programs): Describe set-exec.

	2008-09-18  Stan Shebs  <stan@@codesourcery.com>

	* target.c (target_resize_to_sections): Adjust execs' section
	tables too.

	2008-09-17  Stan Shebs  <stan@@codesourcery.com>

	gdb/doc/
	* gdb.texinfo (Invoking GDB): Describe multiple program args.
	(File Options): Describe multi-program effects.
	(Multiple Programs): New section, multi-program debugging.
	(Forks): Rename section from "Processes".
	(Specify Location): Describe the #-syntax.
	(Variables): Describe the #-syntax.
	(Files): Describe add-file and add-exec-file.
	(Maintenance Commands): Describe maint print execs.

	2008-09-15  Stan Shebs  <stan@@codesourcery.com>

	* exec.c (addr_space_info_command): Don't try to display host address.

	2008-09-14  Stan Shebs  <stan@@codesourcery.com>

	* c-exp.y: (yylex): Accept '#' in identifiers.
	* linespec.c (decode_sharp): New function.
	(decode_line_1): Use it for #-syntax.
	(decode_indirect): Rewrite to accept exec arg and iterate over
	inferiors.
	(struct d_i_data): New struct for inferior iteration.
	(decode_indirect_callback): New function.
	(decode_variable): Pass in exec, use in symbol lookup.

	2008-09-14  Stan Shebs  <stan@@codesourcery.com>

	* breakpoint.h (struct bp_location): Add inferior field instead
	of address space field.
	* breakpoint.c (insert_breakpoint_locations): Only insert in
	appropriate inferior.
	(bpstat_check_trigger_set): New function.
	(bpstat_stop_status): Call it, check location's inferior also.
	(print_one_breakpoint_location): Report location's inferior.
	(set_raw_breakpoint): Set location inferior, clear an experiment.
	(add_location_to_breakpoint): Ditto.
	(expand_line_sal_maybe): Check for non-NULL original function.
	(resolve_sal_pc): Set sal inferior.
	(clear_command): Be careful to not clear anything twice.
	* symtab.h: Update declarations of symbol lookups.
	(struct symtab_and_line): Change address space to inferior field.
	* symtab.c (init_sal): Clear inferior field.
	(append_expanded_sal): Set inferior.
	(lookup_symbol_in_language_1): New function.
	(lookup_symbol_in_language): Call it.
	(lookup_symbol_in_exec_in_language): New function.
	(lookup_symbol): Detect #-syntax and find exec to use.
	(lookup_symbol_aux): Add exec argument and use it.
	(lookup_symbol_aux_symtabs): Ditto.
	(lookup_symbol_aux_psymtabs): Ditto.
	(basic_lookup_symbol_nonlocal): Ditto.
	(lookup_symbol_static): Ditto.
	(lookup_symbol_global): Ditto.
	* ada-lang.c (cp_lookup_symbol_nonlocal): Ditto.
	* cp-support.h (cp_lookup_symbol_nonlocal): Ditto.
	* cp-namespace.c (cp_lookup_symbol_nonlocal): Ditto.
	* language.h (struct language_defn): Ditto.
	* scm-valprint.c (scm_inferior_print): Add exec arg to
	lookup_symbol_global.
	* source.c (select_source_symtab): Use current_exec.
	* addrspace.h (struct addr_space): New field num.
	* exec.h (struct exec): New fields sections and sections_end.
	* exec.c (exec_file_attach_1): Set them from exec_ops, set
	inferior's address space name from exec.
	(find_exec_by_substr): New function.
	(build_section_table): Don't free old table.
	(print_section_info): Use exec's section table.
	(next_address_space_num): New global, numbering for address spaces.
	(new_address_space): Use it.
	(addr_space_info_command): Display it.
	* infcmd.c (set_current_exec): Set exec_ops section table.
	* inferior.h (update_itset): Declare.
	* inferior.c (add_inferior_silent): Set address space.
	(print_inferior): Display it.
	(number_of_inferiors): New function.
	(itset_member): New function.

	2008-09-04  Stan Shebs  <stan@@codesourcery.com>

	* corefile.c (close_exec_file): Remove #if 0 block.
	(validate_files): Use first_exec instead of exec_bfd.
	(get_exec_file): Ditto.
	* corelow.c (core_open): Ditto.
	* utils.c (string_to_core_addr): Ditto.
	* arch-utils.c (gdbarch_update_p): Ditto.
	* linux-thread-db.c (enable_thread_event): Ditto.
	(thread_db_get_thread_local_address ): Ditto.
	* exec.c (find_exec_by_name): Test short name also.
	(file_command): Set current exec.

	2008-09-03  Stan Shebs  <stan@@codesourcery.com>

	* inferior.c (add_threads_to_itset): Default to including all
	of an inferior's threads.

	2008-08-31  Stan Shebs  <stan@@codesourcery.com>

	Parsing for i/t sets.
	* inferior.h (struct itset_entry): New struct.
	(struct itset): Make thread lists be per-inferior, add parse state
	variables.
	* inferior.c: (add_inferior_command): Add error checking and
	confirmation.
	(remove_inferior_command): Update for itset restructuring.
	(new_itset): Don't pass in dynamic-ness, call parse_itset_spec.
	(update_itset): Similarly.
	(parse_itset_spec): New, parsing of itset spec.
	(parse_itset_list, parse_itset_range, etc): New.
	(make_itset_from_spec): Rewrite.
	(dump_itset): Rewrite to reflect itset structure.
	* infcmd.c (focus_command): Similarly.

	2008-08-25  Stan Shebs  <stan@@codesourcery.com>

	First part of multiprocess support.
	* Makefile.in (COMMON_OBS): Add inferior.o.
	* addrspace.h: New file.
	* breakpoints.h (struct bp_location): Add address space field.
	(struct breakpoint): Add trigger set and exec fields.
	* breakpoints.c (print_one_breakpoint_location): Display trigger
	set.
	(set_raw_breakpoint): Set trigger set from current itset.
	* corefile.c (reopen_exec_file): Rewrite for multiple execs.
	(get_exec_file): Add case for current_exec.
	* corelow.c (is_core_file): New function.
	(core_files_info): Pass additional arg to print_section_info.
	* exec.h (struct exec): New struct.
	* exec.c (execs): New global.
	(exec_bfd_mtime): Remove.
	(last_exec_created, current_exec, first_exec): New globals.
	(exec_close): Clear all exec objects.
	(exec_file_clear): Tweak user message.
	(exec_file_add): New function.
	(exec_file_attach_1): New function, body of exec_file_attach,
	plus new code to handle multiple execs.
	(exec_file_attach): Call it.
	(exec_file_update): New function.
	(create_exec, find_exec_by_name, number_of_execs): New functions.
	(exec_file_command): Rephrase query, set current exec.
	(add_exec_file_command): New command.
	(add_file_command): New command.
	(print_section_info): Add exec argument.
	(exec_files_info): Rewrite for multiple execs.
	(maintenance_print_execs): New function.
	(new_address_space): New function.
	(addr_space_info_command): New command.
	* gdbcore.h (exec_bfd_mtime): Remove decl.
	(exec_file_add): Declare.
	* infcmd.c: Include exec.h.
	(current_itset): New global.
	(set_current_exec): New function.
	(focus_command): New command.
	(get_inferior_args): Maybe get from the current inferior.
	(set_inferior_args): Also set in current inferior.
	(set_inferior_args_vector): Similarly.
	(notice_args_set): Similarly.
	(attach_command): Rephrase query.
	* inferior.h (struct inferior): New struct.
	(struct itset): New struct.
	* inferior.c: New file, management of multiple inferiors.
	* main.c (captured_main): Rewrite to allow multiple executables,
	pids, and corefiles on the command line.
	* maint.c (maintenance_info_sections): Rewrite for multiple execs.
	* objfiles.h (struct objfile): New field for exec.
	(ALL_OBJFILES_FOR_EXEC, ALL_PRIMARY_SYMTABS_FOR_EXEC,
	ALL_PSYMTABS_FOR_EXEC): New macros.
	* objfiles.c (allocate_objfile): Clear exec field.
	* solib.c (clear_solib): Use first_exec instead of exec_bfd.
	* source.c (select_source_symtab): Use ALL_OBJFILES_FOR_EXEC.
	(find_source_lines): Use mtime from exec.
	* symfile.c (syms_from_objfile): Don't clear objfile if multiple
	execs.
	(new_symfile_objfile): Get objfile's exec from last_exec_created.
	(symbol_file_clear): Rephrase messages.
	(reread_symbols): Update objfile's exec if necessary.
	* symmisc.c (dump_objfile): Dump objfile's exec also.
	(maintenance_print_objfiles): Report symfile_objfile.
	* symtab.h (struct symtab_and_line): Add address space field.
	* symtab.c (find_pc_sect_psymtab): Look for a plausible exec, and
	then use it.
	(lookup_symbol_aux_symtabs): Use current exec.
	(lookup_symbol_aux_symtabs): Ditto.
	(basic_lookup_transparent_type): Ditto.
	(find_pc_sect_symtab): Ditto.
	* target.h (print_section_info): Add arg to decl.
	* tui/tui-win.c: Rename "focus" command to "ffocus".

gdb/testsuite:

2008-11-20  Stan Shebs  <stan@@codesourcery.com>

	2008-09-14  Stan Shebs  <stan@@codesourcery.com>

	* gdb.gdb/selftest.exp: Update to reflect current sources.
	* Makefile.in (ALL_SUBDIRS): Add gdb.multi.
	* configure.ac (AC_OUTPUT): Add gdb.multi/Makefile.
	* configure: Regenerate.

	* gdb.multi/Makefile.in: New.
	* gdb.multi/hello.c, hangout.c, goodbye.c: New source files.
	* gdb.multi/base.exp: New file, basic multiprocess tests.

	2008-08-25  Stan Shebs  <stan@@codesourcery.com>

	* config/monitor.exp: Match on rephrased message.
	* gdb.base/attach.exp: Ditto.
	* gdb.base/default.exp: Ditto.
	* lib/gdb.exp: Ditto.
@
text
@d1717 1
a1717 1
  if (!(c == '_' || c == '$' || c == '#'
d1725 1
a1725 1
       (c == '_' || c == '$' || c == '#' || (c >= '0' && c <= '9')
@


1.48
log
@	* expression.h (struct expression): New member GDBARCH.
	* parse.c (parse_exp_in_context): Initialize it.
	* parser-def.h (parse_gdbarch, parse_language): New macros.

	* ada-exp.y (parse_type): New macro.
	Replace builtin_type_ macros by using parse_type.
	Replace current_language by parse_language.
	* ada-lex.l (processInt): Replace current_gdbarch by parse_gdbarch.
	Replace builtin_type_ macros.

	* c-exp.y (parse_type): New macro.
	Replace builtin_type_ macros by using parse_type.
	(parse_number): Replace current_gdbarch by parse_gdbarch.
	(yylex): Replace current_language by parse_language.

	* f-exp.y (parse_type, parse_f_type): New macros.
	Replace builtin_type_ macros by using parse_{f_,}type.
	(parse_number): Replace current_gdbarch by parse_gdbarch.
	(yylex): Replace current_language by parse_language.

	* jv-exp.y (parse_type): New macro.
	(parse_number): Replace builtin_type_ macros by using parse_type.

	* m2-exp.y (parse_type, parse_m2_type): New macros.
	Replace builtin_type_ macros by using parse_{m2_,}type.

	* objc-exp.y (parse_type): New macro.
	Replace builtin_type_ macros by using parse_type.
	(parse_number): Replace current_gdbarch by parse_gdbarch.
	(yylex): Replace current_language by parse_language.

	* p-exp.y (parse_type): New macro.
	Replace builtin_type_ macros by using parse_type.
	(parse_number): Replace current_gdbarch by parse_gdbarch.
	(yylex): Replace current_language by parse_language.
@
text
@d187 1
a187 1
%type <sval> name
d565 28
a592 1
exp	:	STRING
d613 3
a615 1
			  write_exp_elt_opcode (OP_ARRAY); }
@


1.47
log
@	* parser-defs.h (write_exp_msymbol): Remove TEXT_SYMBOL_TYPE
	and DATA_SYMBOL_TYPE arguments.
	* parse.c (write_exp_msymbol): Remove TEXT_SYMBOL_TYPE and
	DATA_SYMBOL_TYPE arguments.  Replace use of builtin_type_CORE_ADDR.
	(write_dollar_variable): Update call.

	* ada-exp.y (write_var_or_type): Update call.
	* c-exp.y: Likewise.
	* f-exp.y: Likewise.
	* jv-exp.y: Likewise.
	* m2-exp.y: Likewise.
	* objc-exp.y: Likewise.
	* p-exp.y: Likewise.
@
text
@d58 2
d559 1
a559 1
			  write_exp_elt_type (builtin_type (current_gdbarch)->builtin_int);
d575 1
a575 1
			      write_exp_elt_type (builtin_type (current_gdbarch)->builtin_char);
d580 1
a580 1
			  write_exp_elt_type (builtin_type (current_gdbarch)->builtin_char);
d592 1
a592 1
                          write_exp_elt_type (builtin_type (current_gdbarch)->builtin_bool);
d599 1
a599 1
                          write_exp_elt_type (builtin_type (current_gdbarch)->builtin_bool);
d846 1
a846 1
			{ $$ = builtin_type (current_gdbarch)->builtin_int; }
d848 1
a848 1
			{ $$ = builtin_type (current_gdbarch)->builtin_long; }
d850 1
a850 1
			{ $$ = builtin_type (current_gdbarch)->builtin_short; }
d852 1
a852 1
			{ $$ = builtin_type (current_gdbarch)->builtin_long; }
d854 1
a854 1
			{ $$ = builtin_type (current_gdbarch)->builtin_long; }
d856 1
a856 1
			{ $$ = builtin_type (current_gdbarch)->builtin_long; }
d858 1
a858 1
			{ $$ = builtin_type (current_gdbarch)->builtin_long; }
d860 1
a860 1
			{ $$ = builtin_type (current_gdbarch)->builtin_unsigned_long; }
d862 1
a862 1
			{ $$ = builtin_type (current_gdbarch)->builtin_unsigned_long; }
d864 1
a864 1
			{ $$ = builtin_type (current_gdbarch)->builtin_unsigned_long; }
d866 1
a866 1
			{ $$ = builtin_type (current_gdbarch)->builtin_long_long; }
d868 1
a868 1
			{ $$ = builtin_type (current_gdbarch)->builtin_long_long; }
d870 1
a870 1
			{ $$ = builtin_type (current_gdbarch)->builtin_long_long; }
d872 1
a872 1
			{ $$ = builtin_type (current_gdbarch)->builtin_long_long; }
d874 1
a874 1
			{ $$ = builtin_type (current_gdbarch)->builtin_long_long; }
d876 1
a876 1
			{ $$ = builtin_type (current_gdbarch)->builtin_long_long; }
d878 1
a878 1
			{ $$ = builtin_type (current_gdbarch)->builtin_unsigned_long_long; }
d880 1
a880 1
			{ $$ = builtin_type (current_gdbarch)->builtin_unsigned_long_long; }
d882 1
a882 1
			{ $$ = builtin_type (current_gdbarch)->builtin_unsigned_long_long; }
d884 1
a884 1
			{ $$ = builtin_type (current_gdbarch)->builtin_unsigned_long_long; }
d886 1
a886 1
			{ $$ = builtin_type (current_gdbarch)->builtin_short; }
d888 1
a888 1
			{ $$ = builtin_type (current_gdbarch)->builtin_short; }
d890 1
a890 1
			{ $$ = builtin_type (current_gdbarch)->builtin_short; }
d892 1
a892 1
			{ $$ = builtin_type (current_gdbarch)->builtin_unsigned_short; }
d894 1
a894 1
			{ $$ = builtin_type (current_gdbarch)->builtin_unsigned_short; }
d896 1
a896 1
			{ $$ = builtin_type (current_gdbarch)->builtin_unsigned_short; }
d898 1
a898 1
			{ $$ = builtin_type (current_gdbarch)->builtin_double; }
d900 1
a900 1
			{ $$ = builtin_type (current_gdbarch)->builtin_long_double; }
d916 1
a916 1
			{ $$ = builtin_type (current_gdbarch)->builtin_unsigned_int; }
d920 1
a920 1
			{ $$ = builtin_type (current_gdbarch)->builtin_int; }
d1010 1
a1010 1
		  $$.type = builtin_type (current_gdbarch)->builtin_int;
d1016 1
a1016 1
		  $$.type = builtin_type (current_gdbarch)->builtin_long;
d1022 1
a1022 1
		  $$.type = builtin_type (current_gdbarch)->builtin_short;
d1125 1
a1125 1
	    = builtin_type (current_gdbarch)->builtin_decfloat;
d1135 1
a1135 1
	    = builtin_type (current_gdbarch)->builtin_decdouble;
d1145 1
a1145 1
	    = builtin_type (current_gdbarch)->builtin_declong;
d1160 1
a1160 1
	  builtin_type (current_gdbarch)->builtin_double;
d1168 1
a1168 1
	      builtin_type (current_gdbarch)->builtin_float;
d1171 1
a1171 1
	      builtin_type (current_gdbarch)->builtin_long_double;
d1282 1
a1282 1
      && (un >> (gdbarch_int_bit (current_gdbarch) - 2)) == 0)
d1284 1
a1284 1
      high_bit = ((ULONGEST)1) << (gdbarch_int_bit (current_gdbarch) - 1);
d1292 2
a1293 2
      unsigned_type = builtin_type (current_gdbarch)->builtin_unsigned_int;
      signed_type = builtin_type (current_gdbarch)->builtin_int;
d1296 1
a1296 1
	   && (un >> (gdbarch_long_bit (current_gdbarch) - 2)) == 0)
d1298 3
a1300 3
      high_bit = ((ULONGEST)1) << (gdbarch_long_bit (current_gdbarch) - 1);
      unsigned_type = builtin_type (current_gdbarch)->builtin_unsigned_long;
      signed_type = builtin_type (current_gdbarch)->builtin_long;
d1306 1
a1306 1
	  < gdbarch_long_long_bit (current_gdbarch))
d1310 1
a1310 1
	shift = (gdbarch_long_long_bit (current_gdbarch) - 1);
d1312 2
a1313 2
      unsigned_type = builtin_type (current_gdbarch)->builtin_unsigned_long_long;
      signed_type = builtin_type (current_gdbarch)->builtin_long_long;
d1486 1
a1486 1
      yylval.typed_val_int.type = builtin_type (current_gdbarch)->builtin_char;
d1738 1
a1738 1
      if (current_language->la_language == language_cplus
d1755 1
a1755 1
      if (current_language->la_language == language_cplus)
d1774 1
a1774 1
      if (current_language->la_language == language_cplus)
d1810 1
a1810 1
			 current_language->la_language == language_cplus
d1843 2
a1844 2
      = language_lookup_primitive_type_by_name (current_language,
						current_gdbarch, tmp);
@


1.46
log
@	Fix a memory leak found by Hui Zhu <teawater@@gmail.com>.
	* c-exp.y (parse_number): Move the S and SAVED_CHAR initialization
	after the DECFLOAT detection to fix a memory leak.  Remove the
	redundant NUM initialization.  Protect the DECFLOAT detection memory
	access before the P block.  Restore the P memory content for the
	DECFLOAT detection.
@
text
@d703 3
a705 5
			    {
			      write_exp_msymbol (msymbol,
						 lookup_function_type (builtin_type (current_gdbarch)->builtin_int),
						 builtin_type (current_gdbarch)->builtin_int);
			    }
d707 1
a707 4
			    if (!have_full_symbols () && !have_partial_symbols ())
			      error ("No symbol table is loaded.  Use the \"file\" command.");
			    else
			      error ("No symbol \"%s\" in current context.", name);
d754 1
a754 5
				{
				  write_exp_msymbol (msymbol,
						     lookup_function_type (builtin_type (current_gdbarch)->builtin_int),
						     builtin_type (current_gdbarch)->builtin_int);
				}
@


1.45
log
@gdb
	* completer.c (complete_line): Don't special-case
	expression_completer.
	(expression_completer): Only pass last word to
	location_completer.
	* c-exp.y (yylex): Check 'token', not 'operator'.
gdb/testsuite
	* gdb.base/completion.exp: New tests for field name completion
	with spaces, and field name completion with '->'.
@
text
@d1121 3
a1123 5
      char *s = malloc (len);
      int num = 0;	/* number of tokens scanned by scanf */
      char saved_char = p[len];

      p[len] = 0;	/* null-terminate the token */
d1128 1
a1128 1
      if (p[len - 2] == 'd' && p[len - 1] == 'f')
d1134 2
a1135 2
	  p[len] = saved_char;
	  return (DECFLOAT);
d1138 1
a1138 1
      if (p[len - 2] == 'd' && p[len - 1] == 'd')
d1144 2
a1145 2
	  p[len] = saved_char;
	  return (DECFLOAT);
d1148 1
a1148 1
      if (p[len - 2] == 'd' && p[len - 1] == 'l')
d1154 2
a1155 2
	  p[len] = saved_char;
	  return (DECFLOAT);
d1158 3
@


1.44
log
@gdb
	* value.h (evaluate_subexpression_type, extract_field_op):
	Declare.
	* printcmd.c (_initialize_printcmd): Use expression_completer for
	'p', 'inspect', 'call'.
	* parser-defs.h (parse_field_expression): Declare.
	* parse.c: Include exceptions.h.
	(in_parse_field, expout_last_struct): New globals.
	(mark_struct_expression): New function.
	(prefixify_expression): Return int.
	(prefixify_subexp): Return int.  Use expout_last_struct.
	(parse_exp_1): Update.
	(parse_exp_in_context): Add 'out_subexp' argument.  Handle
	in_parse_field.
	(parse_field_expression): New function.
	* expression.h (parse_field_expression): Declare.
	(in_parse_field): Likewise.
	* eval.c (evaluate_subexpression_type): New function.
	(extract_field_op): Likewise.
	* completer.h (expression_completer): Declare.
	* completer.c (expression_completer): New function.
	(count_struct_fields, add_struct_fields): New functions.
	* c-exp.y (yyparse): Redefine.
	(COMPLETE): New token.
	(exp): New productions.
	(saw_name_at_eof, last_was_structop): New globals.
	(yylex): Return COMPLETE when needed.  Recognize in_parse_field.
	(c_parse): New function.
	* breakpoint.c (_initialize_breakpoint): Use expression_completer
	for watch, awatch, and rwatch.
	* Makefile.in (parse.o): Depend on exceptions_h.
gdb/testsuite
	* gdb.base/break1.c (struct some_struct): New struct.
	(values): New global.
	* gdb.base/completion.exp: Add field name completion test.
gdb/doc
	* gdb.texinfo (Completion): Add field name example.
@
text
@d1436 1
a1436 1
	if (in_parse_field && tokentab2[i].opcode == ARROW)
@


1.43
log
@	* symtab.h (lookup_symbol_in_language): Remove SYMTAB parameter.
	(lookup_symbol): Likewise.
	* symtab.c (lookup_symbol_in_language): Remove SYMTAB parameter.
	(lookup_symbol): Likewise.
	(search_symbols): Update.

	* linespec.c (find_methods, collect_methods): Update.
	(add_matching_methods, add_constructors): Update.
	(decode_compound, decode_dollar, decode_variable): Update.
	(lookup_prefix_sym): Update.

	(symbol_found): Remove SYM_SYMTAB parameter.
	Use SYMBOL_SYMTAB (sym) instead.

	* gdbtypes.c (lookup_typename): Update.
	(lookup_struct, lookup_union, lookup_enum): Update.
	(lookup_template_type): Update.
	(check_typedef): Update.
	* language.c (lang_bool_type): Update.
	* mdebugread.c (parse_procedure): Update.
	* mi/mi-cmd-stack.c (list_args_or_locals): Update.
	* parse.c (write_dollar_variable): Update.
	* printcmd.c (address_info): Update.
	* source.c (select_source_symtab): Update.
	* stack.c (print_frame_args, print_frame_arg_vars): Update.
	* valops.c (find_function_in_inferior): Update.
	(value_struct_elt_for_reference): Update.
	* value.c (value_static_field, value_fn_field): Update.

	* alpha-mdebug-tdep.c (find_proc_desc): Update.
	* arm-tdep.c (arm_skip_prologue): Update.
	* mt-tdep.c (mt_skip_prologue): Update.
	* xstormy16-tdep.c (xstormy16_skip_prologue): Update.

	* ada-lang.h (struct ada_symbol_info): Remove SYMTAB member.
	* ada-lang.c (ada_add_block_symbols): Remove SYMTAB parameter.
	(add_defn_to_vec): Likewise.
	(ada_add_block_symbols): Likewise.
	(lookup_cached_symbol, cache_symbol): Likewise.
	(standard_lookup): Update.
	(ada_lookup_symbol_list): Update.

	* c-valprint.c (c_val_print): Update.
	* cp-support.c (cp_lookup_rtti_type): Update.
	* jv-lang.c (java_lookup_class, get_java_object_type): Update.
	* objc-lang.c (lookup_struct_typedef, find_imps): Update.
	* p-valprint.c (pascal_val_print): Update.
	* scm-lang.c (scm_lookup_name): Update.

	* c-exp.y: Update.
	* f-exp.y: Update.
	* jv-exp.y: Update.
	* m2-exp.y: Update.
	* objc-exp.y: Update.
	* p-exp.y: Update.
@
text
@d66 1
a66 1
#define	yyparse	c_parse
d183 1
d305 17
d340 17
d1376 10
d1401 4
a1404 1
   
d1436 2
d1446 2
d1455 7
d1534 5
a1538 1
	goto symbol;		/* Nope, must be a symbol. */
d1874 2
d1880 8
@


1.42
log
@	* doublest.h (DOUBLEST_PRINT_FORMAT): Remove % from string.
	(DOUBLEST_SCAN_FORMAT): Likewise.
	* dfp.c (decimal_from_floating): Use DOUBLEST_PRINT_FORMAT.
	* ada-lex.l (processReal): Prepend "%" to use of DOUBLEST_SCAN_FORMAT.
	* c-exp.y (parse_number): Likewise.
	* jv-exp.y (parse_number): Likewise.
	* objc-exp.y (parse_number): Likewise.
	* p-exp.y (parse_number): Likewise.
@
text
@d586 1
a586 2
					     VAR_DOMAIN, (int *) NULL,
					     (struct symtab **) NULL);
d596 1
a596 2
					       VAR_DOMAIN, (int *) NULL,
					       (struct symtab **) NULL);
d656 1
a656 2
					   VAR_DOMAIN, (int *) NULL,
					   (struct symtab **) NULL);
d1754 1
a1754 2
			 ? &is_a_field_of_this : (int *) NULL,
			 (struct symtab **) NULL);
@


1.41
log
@	Updated copyright notices for most files.
@
text
@d1128 1
a1128 1
      num = sscanf (p, DOUBLEST_SCAN_FORMAT "%s",
@


1.40
log
@2007-10-25  Wu Zhou  <woodzltc@@cn.ibm.com>
	    Thiago Jung Bauermann  <bauerman@@br.ibm.com>

	* c-exp.y (YYSTYPE): Add typed_val_decfloat for decimal
	floating point in YYSTYPE union.
	(DECFLOAT) Add token and expression element handling code.
	(parse_number): Parse DFP constants, which end with suffix 'df',
	'dd' or 'dl'.  Return DECFLOAT.
	* eval.c (evaluate_subexp_standard): Call value_from_decfloat to
	handle OP_DECFLOAT.
	* expression.h (enum exp_opcode): Add an opcode (OP_DECFLOAT)
	for DFP constants.
	(union exp_element): Add decfloatconst to represent DFP
	elements, which is 16 bytes by default.
	* parse.c (write_exp_elt_decfloatcst): New function to write a
	decimal float const into the expression.
	(operator_length_standard): Set operator length for OP_DECFLOAT
	to 4.
	* parser-defs.h (write_exp_elt_decfloatcst): Prototype.
	* valarith.c (value_neg): Add code to handle the negation
	operation of DFP values.
	* value.c (value_from_decfloat): New function to get the value
	from a decimal floating point.
	* value.h (value_from_decfloat): Prototype.
@
text
@d3 2
a4 1
   1998, 1999, 2000, 2003, 2004, 2006, 2007 Free Software Foundation, Inc.
@


1.39
log
@2007-08-17  Michael Snyder  <msnyder@@access-company.com>

	* c-exp.y (parse_number): Memory leak.
@
text
@d55 1
d134 4
d170 1
d505 7
d1093 34
@


1.38
log
@2007-06-12  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (TARGET_SHORT_BIT): Replace by gdbarch_int_bit.
	* ada-lang.c (ada_create_fundamental_type)
	(ada_language_arch_info): Likewise.
	* c-lang.c (c_create_fundamental_type): Likewise.
	* f-lang.c (f_create_fundamental_type, build_fortran_types): Likewise.
	* gdbtypes.c (build_gdbtypes, gdbtypes_post_init): Likewise.
	* m2-lang.c (m2_create_fundamental_type): Likewise.
	* objc-lang.c (objc_create_fundamental_type): Likewise.
	* p-lang.c (pascal_create_fundamental_type): Likewise.
	* gdbarch.sh (TARGET_INT_BIT): Replace by gdbarch_int_bit.
	* c-exp.y (parse_number): Likewise.
	* objc-exp.y (parse_number): Likewise.
	* ada-lex.l (processInt): Likewise.
	* f-exp.y (parse_number): Likewise.
	* p-exp.y (parse_number): Likewise.
	* ada-lang.c (ada_create_fundamental_type, ada_language_arch_info)
	(gdbtypes_post_init, build_gdbtypes): Likewise.
	* p-lang.c (pascal_create_fundamental_type): Likewise.
	* parse.c (build_parse): Likewise.
	* xcoffread.c (_initialize_xcoffread): Likewise.
	* stabsread.c (define_symbol, read_one_struct_field, read_enum_type)
	(read_range_type): Likewise.
	* objc-lang.c (objc_create_fundamental_type): Likewise.
	* f-lang.c (build_fortran_types, f_create_fundamental_type): Likewise.
	* m2-lang.c (m2_create_fundamental_type, _initialize_m2_language)
	(m2_create_fundamental_type): Likewise.
	* c-lang.c (c_create_fundamental_type): Likewise.
	* coffread.c (coff_read_enum_type): Likewise.
	* mdebugread.c (parse_symbol, _initialize_mdebugread): Likewise.
	* dwarf2read.c (new_symbol): Likewise.
	* gdbarch.sh (TARGET_LONG_BIT): Replace by gdbarch_long_bit.
	* c-exp.y (parse_number): Likewise.
	* objc-exp.y (parse_number): Likewise.
	* ada-lex.l (processInt): Likewise.
	* f-exp.y (parse_number): Likewise.
	* p-exp.y (parse_number): Likewise.
	* valarith.c (value_binop): Likewise.
	* symfile.c (read_target_long_array, simple_overlay_update_1): Likewise.
	* ada-lang.c (ada_create_fundamental_type)
	(ada_language_arch_info): Likewise.
	* gdbtypes.c (build_gdbtypes, gdbtypes_post_init): Likewise.
	* symfile.c (TARGET_LONG_BYTES): Likewise.
	* p-lang.c (pascal_create_fundamental_type): Likewise.
	* objc-lang.c (objc_create_fundamental_type): Likewise.
	* m2-lang.c (m2_create_fundamental_type): Likewise.
	* f-lang.c (f_create_fundamental_type): Likewise.
	* c-lang.c (c_create_fundamental_type): Likewise.
	* coffread.c (decode_base_type): Likewise.
	* gdbarch.sh (TARGET_LONG_LONG_BIT): Replace by gdbarch_long_long_bit.
	* c-exp.y (parse_number): Likewise.
	* objc-exp.y (parse_number): Likewise.
	* p-exp.y (parse_number): Likewise.
	* ada-lang.c (ada_create_fundamental_type)
	(ada_language_arch_info): Likewise.
	* gdbtypes.c (gdbtypes_post_init, build_gdbtypes): Likewise.
	* stabsread.c (read_range_type): Likewise.
	* p-lang.c (pascal_create_fundamental_type): Likewise.
	* objc-lang.c (objc_create_fundamental_type): Likewise.
	* m2-lang.c (m2_create_fundamental_type): Likewise.
	* f-lang.c (f_create_fundamental_type): Likewise.
	* c-lang.c (c_create_fundamental_type): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d1099 4
a1102 1
	    return ERROR;
d1105 1
@


1.37
log
@	* hppa-hpux-tdep.c (args_for_find_stub, HP_ACC_EH_notify_hook,
	HP_ACC_EH_set_hook_value, HP_ACC_EH_notify_callback, HP_ACC_EH_break,
	HP_ACC_EH_catch_throw, HP_ACC_EH_catch_catch, __eh_notification,
	hp_cxx_exception_support, hp_cxx_exception_support_initialized,
	eh_notify_hook_addr, eh_notify_callback_addr, eh_break_addr,
	eh_catch_throw_addr, break_callback_sal, setup_d_pid_in_inferior,
	find_stub_with_shl_get, cover_find_stub_with_shl_get,
	initialize_hp_cxx_exception_support, child_enable_exception_callback,
	current_ex_event, child_get_current_exception_event): Remove.
	(hppa_hpux_inferior_created): Remove.
	(hppa_hpux_init_abi): Do not install hppa_hpux_inferior_created.

	* breakpoint.h (deprecated_exception_catchpoints_are_fragile): Remove.
	(deprecated_exception_support_initialized): Remove.
	* breakpoint.c (deprecated_exception_catchpoints_are_fragile): Remove.
	(deprecated_exception_support_initialized): Remove.
	(breakpoint_init_inferior): Remove handling of non-zero
	deprecated_exception_catchpoints_are_fragile.

	* symtab.h (deprecated_hp_som_som_object_present): Remove.
	* symtab.c (deprecated_hp_som_som_object_present): Remove.
	* c-typeprint.c (c_type_print_base): Remove handling of non-zero
	deprecated_hp_som_som_object_present.
	* eval.c (evaluate_subexp_standard): Likewise.
	* valops.c (value_cast): Likewise.

	* parse.c (parse_nested_classes_for_hpacc, coloncolon): Remove.
	* parser-defs.h (parse_nested_classes_for_hpacc): Remove.
	* c-exp.y (yylex): Do not call parse_nested_classes_for_hpacc.
@
text
@d1197 2
a1198 2
     (which always produces a zero result).  Sometimes TARGET_INT_BIT
     or TARGET_LONG_BIT will be that big, sometimes not.  To deal with
d1204 1
a1204 1
      && (un >> (TARGET_INT_BIT - 2)) == 0)
d1206 1
a1206 1
      high_bit = ((ULONGEST)1) << (TARGET_INT_BIT-1);
d1218 1
a1218 1
	   && (un >> (TARGET_LONG_BIT - 2)) == 0)
d1220 1
a1220 1
      high_bit = ((ULONGEST)1) << (TARGET_LONG_BIT-1);
d1227 2
a1228 1
      if (sizeof (ULONGEST) * HOST_CHAR_BIT < TARGET_LONG_LONG_BIT)
d1232 1
a1232 1
	shift = (TARGET_LONG_LONG_BIT - 1);
@


1.36
log
@Copyright updates for 2007.
@
text
@a1303 1
  struct symbol * sym_class = NULL;
a1305 1
  int unquoted_expr;
a1320 1
  unquoted_expr = 1;
a1391 1
              unquoted_expr = 0;
a1689 24
  /* Look ahead and see if we can consume more of the input
     string to get a reasonable class/namespace spec or a
     fully-qualified name.  This is a kludge to get around the
     HP aCC compiler's generation of symbol names with embedded
     colons for namespace and nested classes. */

  /* NOTE: carlton/2003-09-24: I don't entirely understand the
     HP-specific code, either here or in linespec.  Having said that,
     I suspect that we're actually moving towards their model: we want
     symbols whose names are fully qualified, which matches the
     description above.  */
  if (unquoted_expr)
    {
      /* Only do it if not inside single quotes */ 
      sym_class = parse_nested_classes_for_hpacc (yylval.sval.ptr, yylval.sval.length,
                                                  &token_string, &class_prefix, &lexptr);
      if (sym_class)
        {
          /* Replace the current token with the bigger one we found */ 
          yylval.sval.ptr = token_string;
          yylval.sval.length = strlen (token_string);
        }
    }
  
@


1.35
log
@	* c-exp.y (type): Remove incorrect pointer to member case.
	* objc-exp.y (type): Likewise.
	* p-exp.y (type): Likewise.
@
text
@d3 1
a3 2
   1998, 1999, 2000, 2003, 2004, 2006
   Free Software Foundation, Inc.
@


1.34
log
@	* doublest.h: Conditionalize DOUBLEST on PRINTF_HAS_LONG_DOUBLE
	also.
	(DOUBLEST_FORMAT): Rename to DOUBLEST_PRINT_FORMAT.
	(DOUBLEST_SCAN_FORMAT): New.
	* ada-lex.l (PRINTF_HAS_LONG_DOUBLE): Remove redefinitions.
	(processReal): Use DOUBLEST_SCAN_FORMAT.
	* c-exp.y (parse_number): Likewise.
	* jv-exp.y (parse_number): Likewise.
	* objc-exp.y (parse_number): Likewise.
	* p-exp.y (parse_number): Likewise.
@
text
@d793 1
a793 1
/* We used to try to recognize more pointer to member types here, but
a801 2
	|	typebase COLONCOLON '*'
			{ $$ = lookup_member_type (builtin_type (current_gdbarch)->builtin_int, $1); }
@


1.34.14.1
log
@Changes from nickrob-async-20060828-mergepoint.
@
text
@d793 1
a793 1
/* We used to try to recognize pointer to member types here, but
d802 2
@


1.33
log
@Update copyright notice
@
text
@d1083 1
a1083 1
      num = sscanf (p, DOUBLEST_FORMAT "%s",
@


1.32
log
@* doublest.h (DOUBLEST): Use long double only if we can scan
it in.  Undefine HAVE_LONG_DOUBLE otherwise.
(DOUBLEST_FORMAT): New.
* c-exp.y (parse_number): Use it.
* jv-exp.y (parse_number): Likewise.
* objc-exp.y (parse_number): Likewise.
* p-exp.y (parse_number): Likewise.
* varobj.c (free_variable): Silence type-punning warnings.
* tui/tui-data.h (struct tui_list): Change type of list member.
* tui/tui-data.c: Remove no-longer-needed type casts.
(source_windows): Silence type-punning warnings.
* tui/tui-stack.c, tui/tui-win.c, tui/tui-winsource.c: Likewise.
@
text
@d3 1
a3 1
   1998, 1999, 2000, 2003, 2004
@


1.31
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d1083 2
a1084 18

      if (sizeof (putithere->typed_val_float.dval) <= sizeof (float))
	num = sscanf (p, "%g%s", (float *) &putithere->typed_val_float.dval,s);
      else if (sizeof (putithere->typed_val_float.dval) <= sizeof (double))
	num = sscanf (p, "%lg%s", (double *) &putithere->typed_val_float.dval,s);
      else
	{
#ifdef SCANF_HAS_LONG_DOUBLE
	  num = sscanf (p, "%Lg%s", &putithere->typed_val_float.dval,s);
#else
	  /* Scan it into a double, then assign it to the long double.
	     This at least wins with values representable in the range
	     of doubles. */
	  double temp;
	  num = sscanf (p, "%lg%s", &temp,s);
	  putithere->typed_val_float.dval = temp;
#endif
	}
@


1.30
log
@* c-exp.y (parse-number): Modify the float parsing logic to let it
recognize a suffix.
@
text
@d2 1
a2 1
   Copyright 1986, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997,
d20 2
a21 1
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.29
log
@	* ax-gdb.c (gen_expr): Add UNOP_PLUS case.
	* c-exp.y (exp): Add unary plus.
	* eval.c (evaluate_subexp_standard): Add UNOP_PLUS case.
	* valarith.c (value_x_unop): Add UNOP_PLUS case.
	(value_pos): New.
	* value.h (value_pos): Declare.

	* gdb.cp/userdef.cc (A1::operator+): New unary plus.
	(A2): New class.
	(main): Test operator+.
	* gdb.cp/userdef.exp: Test unary plus.  Use A2::operator+ for
	breakpoint test.
@
text
@d1077 1
a1077 1
      char c;
d1082 1
d1084 1
a1084 1
	num = sscanf (p, "%g%c", (float *) &putithere->typed_val_float.dval,&c);
d1086 1
a1086 1
	num = sscanf (p, "%lg%c", (double *) &putithere->typed_val_float.dval,&c);
d1090 1
a1090 1
	  num = sscanf (p, "%Lg%c", &putithere->typed_val_float.dval,&c);
d1096 1
a1096 1
	  num = sscanf (p, "%lg%c", &temp,&c);
d1101 18
a1118 14
      if (num != 1) 		/* check scanf found ONLY a float ... */
	return ERROR;
      /* See if it has `f' or `l' suffix (float or long double).  */

      c = tolower (p[len - 1]);

      if (c == 'f')
	putithere->typed_val_float.type = builtin_type (current_gdbarch)->builtin_float;
      else if (c == 'l')
	putithere->typed_val_float.type = builtin_type (current_gdbarch)->builtin_long_double;
      else if (isdigit (c) || c == '.')
	putithere->typed_val_float.type = builtin_type (current_gdbarch)->builtin_double;
      else
	return ERROR;
@


1.28
log
@2004-08-07  Andrew Cagney  <cagney@@gnu.org>

	* c-exp.y: Use builtin_type function to obtain builtin types.
@
text
@d259 4
@


1.27
log
@2004-07-28  Andrew Cagney  <cagney@@gnu.org>

	* gdbtypes.c (lookup_primitive_typename): Delete function.
	* gdbtypes.h (lookup_primitive_typename): Delete declaration.
	* ada-lex.l: Use language_lookup_primitive_type_by_name.
	* gdbtypes.c (lookup_typename): Ditto.
	* f-exp.y (yylex): Ditto.
	* c-exp.y (yylex): Ditto, eliminate assignment in "if".
@
text
@d504 1
a504 1
			  write_exp_elt_type (builtin_type_int);
d520 1
a520 1
			      write_exp_elt_type (builtin_type_char);
d525 1
a525 1
			  write_exp_elt_type (builtin_type_char);
d537 1
a537 1
                          write_exp_elt_type (builtin_type_bool);
d544 1
a544 1
                          write_exp_elt_type (builtin_type_bool);
d655 2
a656 2
						 lookup_function_type (builtin_type_int),
						 builtin_type_int);
d711 2
a712 2
						     lookup_function_type (builtin_type_int),
						     builtin_type_int);
d798 1
a798 1
			{ $$ = lookup_member_type (builtin_type_int, $1); }
d805 1
a805 1
			{ $$ = builtin_type_int; }
d807 1
a807 1
			{ $$ = builtin_type_long; }
d809 1
a809 1
			{ $$ = builtin_type_short; }
d811 1
a811 1
			{ $$ = builtin_type_long; }
d813 1
a813 1
			{ $$ = builtin_type_long; }
d815 1
a815 1
			{ $$ = builtin_type_long; }
d817 1
a817 1
			{ $$ = builtin_type_long; }
d819 1
a819 1
			{ $$ = builtin_type_unsigned_long; }
d821 1
a821 1
			{ $$ = builtin_type_unsigned_long; }
d823 1
a823 1
			{ $$ = builtin_type_unsigned_long; }
d825 1
a825 1
			{ $$ = builtin_type_long_long; }
d827 1
a827 1
			{ $$ = builtin_type_long_long; }
d829 1
a829 1
			{ $$ = builtin_type_long_long; }
d831 1
a831 1
			{ $$ = builtin_type_long_long; }
d833 1
a833 1
			{ $$ = builtin_type_long_long; }
d835 1
a835 1
			{ $$ = builtin_type_long_long; }
d837 1
a837 1
			{ $$ = builtin_type_unsigned_long_long; }
d839 1
a839 1
			{ $$ = builtin_type_unsigned_long_long; }
d841 1
a841 1
			{ $$ = builtin_type_unsigned_long_long; }
d843 1
a843 1
			{ $$ = builtin_type_unsigned_long_long; }
d845 1
a845 1
			{ $$ = builtin_type_short; }
d847 1
a847 1
			{ $$ = builtin_type_short; }
d849 1
a849 1
			{ $$ = builtin_type_short; }
d851 1
a851 1
			{ $$ = builtin_type_unsigned_short; }
d853 1
a853 1
			{ $$ = builtin_type_unsigned_short; }
d855 1
a855 1
			{ $$ = builtin_type_unsigned_short; }
d857 1
a857 1
			{ $$ = builtin_type_double; }
d859 1
a859 1
			{ $$ = builtin_type_long_double; }
d875 1
a875 1
			{ $$ = builtin_type_unsigned_int; }
d879 1
a879 1
			{ $$ = builtin_type_int; }
d969 1
a969 1
		  $$.type = builtin_type_int;
d975 1
a975 1
		  $$.type = builtin_type_long;
d981 1
a981 1
		  $$.type = builtin_type_short;
d1103 1
a1103 1
	putithere->typed_val_float.type = builtin_type_float;
d1105 1
a1105 1
	putithere->typed_val_float.type = builtin_type_long_double;
d1107 1
a1107 1
	putithere->typed_val_float.type = builtin_type_double;
d1223 2
a1224 2
      unsigned_type = builtin_type_unsigned_int;
      signed_type = builtin_type_int;
d1230 2
a1231 2
      unsigned_type = builtin_type_unsigned_long;
      signed_type = builtin_type_long;
d1242 2
a1243 2
      unsigned_type = builtin_type_unsigned_long_long;
      signed_type = builtin_type_long_long;
d1395 1
a1395 1
      yylval.typed_val_int.type = builtin_type_char;
@


1.26
log
@2004-04-08  Andrew Cagney  <cagney@@redhat.com>

	* breakpoint.h (deprecated_exception_catchpoints_are_fragile)
	(deprecated_exception_support_initialized): Declare.
	* hppa-hpux-tdep.c (initialize_hp_cxx_exception_support)
	(initialize_hp_cxx_exception_support)
	(child_enable_exception_callback): Update.
	* breakpoint.c (deprecated_exception_catchpoints_are_fragile)
	(deprecated_exception_support_initialized): Rename
	deprecated_exception_catchpoints_are_fragile and
	deprecated_exception_support_initialized.
	(breakpoint_init_inferior, breakpoint_init_inferior): Update.

	* symtab.c (deprecated_hp_som_som_object_present): Rename
	hp_som_som_object_present.
	* symtab.h (deprecated_hp_som_som_object_present): Declare.
	* symfile.c (hp_som_som_object_present, RESET_HP_UX_GLOBALS):
	Update.  Delete extern declaration.
	* valops.c (hp_som_som_object_present): Ditto.
	* parse.c (deprecated_hp_som_som_object_present)
	(parse_nested_classes_for_hpacc): Ditto.
	* hpread.c (hp_som_som_object_present, hpread_expand_symtab): Ditto.
	* hppa-hpux-tdep.c (hp_som_som_object_present)
	(initialize_hp_cxx_exception_support): Ditto.
	* eval.c (hp_som_som_object_present, evaluate_subexp_standard): Ditto.
	* cp-valprint.c (hp_som_som_object_present)
	(cp_print_class_method): Ditto.
	* c-typeprint.c (hp_som_som_object_present):
	(c_type_print_base): Ditto.
	* c-exp.y (hp_som_som_object_present): Ditto.
@
text
@d1773 4
a1776 1
    if ((yylval.tsym.type = lookup_primitive_typename (tmp)) != 0)
@


1.25
log
@2004-01-14  David Carlton  <carlton@@kealia.com>

	Change symbols for C++ nested types to contain the fully qualified
	name, if possible.  (At least in the DWARF-2 case.)  Partial fix
	for PR's c++/57, c++/488, c++/539, c++/573, c++/609, c++/832,
	c++/895.
	* c-exp.y: Update copyright:
	(qualified_type): Handle types nested within classes.
	* cp-namespace.c: Update comments.
	(cp_set_block_scope): Delete #if 0.
	(cp_lookup_nested_type): Handle types nested within classes.
	* dwarf2read.c: (scan_partial_symbols): Call add_partial_structure
	when appropriate.
	(add_partial_symbol): Add the name of the enclosing namespace to
	types.
	(pdi_needs_namespace): New.
	(add_partial_namespace): Tweak comment.
	(add_partial_structure): New.
	(psymtab_to_symtab_1): Initialize processing_current_prefix
	here...
	(process_die): instead of here.
	(read_structure_scope): Try to figure out the name of the class or
	namespace that the structure might be defined within.
	(read_enumeration): Generate fully-qualified names, if possible.
	(read_namespace): Don't set name to NULL.
	(die_specification): New.
	(new_symbol): Generate fully-qualified names for types.
	(read_type_die): Determine appropriate prefix.
	(determine_prefix): New.
	(typename_concat): New.
	(class_name): New.
	* valops.c: Update copyright.
	(value_aggregate_elt): Pass NOSIDE to
	value_struct_elt_for_reference.
	(value_struct_elt_for_reference): Make static, add NOSIDE
	parameter, call value_maybe_namespace_elt as a last resort.
	(value_namespace_elt): Break out code into
	value_maybe_namespace_elt.
	(value_maybe_namespace_elt): New.

2004-01-14  David Carlton  <carlton@@kealia.com>

	* gdb.cp/namespace.exp: Add tests involving classes defined within
	namespaces.
	* gdb.cp/namespace.cc (C::CClass): New.
	* gdb.cp/namespace1.cc: Update copyright.
	(C::OtherFileClass): New.
@
text
@a55 3
/* Flag indicating we're dealing with HP-compiled objects */ 
extern int hp_som_som_object_present;

@


1.25.6.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d56 3
d507 1
a507 1
			  write_exp_elt_type (builtin_type (current_gdbarch)->builtin_int);
d523 1
a523 1
			      write_exp_elt_type (builtin_type (current_gdbarch)->builtin_char);
d528 1
a528 1
			  write_exp_elt_type (builtin_type (current_gdbarch)->builtin_char);
d540 1
a540 1
                          write_exp_elt_type (builtin_type (current_gdbarch)->builtin_bool);
d547 1
a547 1
                          write_exp_elt_type (builtin_type (current_gdbarch)->builtin_bool);
d658 2
a659 2
						 lookup_function_type (builtin_type (current_gdbarch)->builtin_int),
						 builtin_type (current_gdbarch)->builtin_int);
d714 2
a715 2
						     lookup_function_type (builtin_type (current_gdbarch)->builtin_int),
						     builtin_type (current_gdbarch)->builtin_int);
d801 1
a801 1
			{ $$ = lookup_member_type (builtin_type (current_gdbarch)->builtin_int, $1); }
d808 1
a808 1
			{ $$ = builtin_type (current_gdbarch)->builtin_int; }
d810 1
a810 1
			{ $$ = builtin_type (current_gdbarch)->builtin_long; }
d812 1
a812 1
			{ $$ = builtin_type (current_gdbarch)->builtin_short; }
d814 1
a814 1
			{ $$ = builtin_type (current_gdbarch)->builtin_long; }
d816 1
a816 1
			{ $$ = builtin_type (current_gdbarch)->builtin_long; }
d818 1
a818 1
			{ $$ = builtin_type (current_gdbarch)->builtin_long; }
d820 1
a820 1
			{ $$ = builtin_type (current_gdbarch)->builtin_long; }
d822 1
a822 1
			{ $$ = builtin_type (current_gdbarch)->builtin_unsigned_long; }
d824 1
a824 1
			{ $$ = builtin_type (current_gdbarch)->builtin_unsigned_long; }
d826 1
a826 1
			{ $$ = builtin_type (current_gdbarch)->builtin_unsigned_long; }
d828 1
a828 1
			{ $$ = builtin_type (current_gdbarch)->builtin_long_long; }
d830 1
a830 1
			{ $$ = builtin_type (current_gdbarch)->builtin_long_long; }
d832 1
a832 1
			{ $$ = builtin_type (current_gdbarch)->builtin_long_long; }
d834 1
a834 1
			{ $$ = builtin_type (current_gdbarch)->builtin_long_long; }
d836 1
a836 1
			{ $$ = builtin_type (current_gdbarch)->builtin_long_long; }
d838 1
a838 1
			{ $$ = builtin_type (current_gdbarch)->builtin_long_long; }
d840 1
a840 1
			{ $$ = builtin_type (current_gdbarch)->builtin_unsigned_long_long; }
d842 1
a842 1
			{ $$ = builtin_type (current_gdbarch)->builtin_unsigned_long_long; }
d844 1
a844 1
			{ $$ = builtin_type (current_gdbarch)->builtin_unsigned_long_long; }
d846 1
a846 1
			{ $$ = builtin_type (current_gdbarch)->builtin_unsigned_long_long; }
d848 1
a848 1
			{ $$ = builtin_type (current_gdbarch)->builtin_short; }
d850 1
a850 1
			{ $$ = builtin_type (current_gdbarch)->builtin_short; }
d852 1
a852 1
			{ $$ = builtin_type (current_gdbarch)->builtin_short; }
d854 1
a854 1
			{ $$ = builtin_type (current_gdbarch)->builtin_unsigned_short; }
d856 1
a856 1
			{ $$ = builtin_type (current_gdbarch)->builtin_unsigned_short; }
d858 1
a858 1
			{ $$ = builtin_type (current_gdbarch)->builtin_unsigned_short; }
d860 1
a860 1
			{ $$ = builtin_type (current_gdbarch)->builtin_double; }
d862 1
a862 1
			{ $$ = builtin_type (current_gdbarch)->builtin_long_double; }
d878 1
a878 1
			{ $$ = builtin_type (current_gdbarch)->builtin_unsigned_int; }
d882 1
a882 1
			{ $$ = builtin_type (current_gdbarch)->builtin_int; }
d972 1
a972 1
		  $$.type = builtin_type (current_gdbarch)->builtin_int;
d978 1
a978 1
		  $$.type = builtin_type (current_gdbarch)->builtin_long;
d984 1
a984 1
		  $$.type = builtin_type (current_gdbarch)->builtin_short;
d1106 1
a1106 1
	putithere->typed_val_float.type = builtin_type (current_gdbarch)->builtin_float;
d1108 1
a1108 1
	putithere->typed_val_float.type = builtin_type (current_gdbarch)->builtin_long_double;
d1110 1
a1110 1
	putithere->typed_val_float.type = builtin_type (current_gdbarch)->builtin_double;
d1226 2
a1227 2
      unsigned_type = builtin_type (current_gdbarch)->builtin_unsigned_int;
      signed_type = builtin_type (current_gdbarch)->builtin_int;
d1233 2
a1234 2
      unsigned_type = builtin_type (current_gdbarch)->builtin_unsigned_long;
      signed_type = builtin_type (current_gdbarch)->builtin_long;
d1245 2
a1246 2
      unsigned_type = builtin_type (current_gdbarch)->builtin_unsigned_long_long;
      signed_type = builtin_type (current_gdbarch)->builtin_long_long;
d1398 1
a1398 1
      yylval.typed_val_int.type = builtin_type (current_gdbarch)->builtin_char;
d1776 1
a1776 4
    yylval.tsym.type
      = language_lookup_primitive_type_by_name (current_language,
						current_gdbarch, tmp);
    if (yylval.tsym.type != NULL)
@


1.24
log
@2003-11-06  Andrew Cagney  <cagney@@redhat.com>

	* valops.c (destructor_name_p): Replace STREQN with strncmp.
	* top.c (command_line_input): Ditto.
	* objc-exp.y (yylex): Ditto.
	* minsyms.c (prim_record_minimal_symbol_and_info): Ditto.
	* jv-exp.y (yylex): Ditto.
	* f-exp.y (yylex): Ditto.
	* event-top.c (command_line_handler): Ditto.
	* environ.c (get_in_environ): Ditto.
	(set_in_environ): Ditto.
	* dwarfread.c (handle_producer): Ditto.
	* dbxread.c (process_one_symbol): Ditto.
	* c-typeprint.c (c_type_print_base): Ditto.
	* c-exp.y (yylex): Ditto.

2003-11-06  Andrew Cagney  <cagney@@redhat.com>

	* mi-cmd-var.c (mi_cmd_var_set_format): Replace STREQN with
	strncmp.
@
text
@d3 1
a3 1
   1998, 1999, 2000, 2003
a941 5
/* FIXME: carlton/2003-09-25: Currently, the only qualified type
   symbols that we generate are nested namespaces.  Next on my TODO
   list is to generate all nested type names properly (or at least as
   well as possible, assuming that we're using DWARF-2).  */

d951 4
a954 2
		  if (TYPE_CODE (type) != TYPE_CODE_NAMESPACE)
		    error ("`%s' is not defined as a namespace.",
d960 1
a960 1
		    error ("No type \"%s\" in namespace \"%s\".",
@


1.23
log
@2003-09-25  David Carlton  <carlton@@kealia.com>

	* c-exp.y: Remove 'register' declarations.
	* f-exp.y, jv-exp.y, m2-exp.y, objc-exp.y, p-exp.y: Ditto.
@
text
@d1343 1
a1343 1
    if (STREQN (tokstart, tokentab3[i].operator, 3))
d1352 1
a1352 1
    if (STREQN (tokstart, tokentab2[i].operator, 2))
d1648 1
a1648 1
      if (STREQN (tokstart, "unsigned", 8))
d1651 1
a1651 1
	  && STREQN (tokstart, "template", 8))
d1653 1
a1653 1
      if (STREQN (tokstart, "volatile", 8))
d1657 1
a1657 1
      if (STREQN (tokstart, "struct", 6))
d1659 1
a1659 1
      if (STREQN (tokstart, "signed", 6))
d1661 1
a1661 1
      if (STREQN (tokstart, "sizeof", 6))      
d1663 1
a1663 1
      if (STREQN (tokstart, "double", 6))      
d1669 1
a1669 1
          if (STREQN (tokstart, "false", 5))
d1671 1
a1671 1
          if (STREQN (tokstart, "class", 5))
d1674 1
a1674 1
      if (STREQN (tokstart, "union", 5))
d1676 1
a1676 1
      if (STREQN (tokstart, "short", 5))
d1678 1
a1678 1
      if (STREQN (tokstart, "const", 5))
d1682 1
a1682 1
      if (STREQN (tokstart, "enum", 4))
d1684 1
a1684 1
      if (STREQN (tokstart, "long", 4))
d1688 1
a1688 1
            if (STREQN (tokstart, "true", 4))
d1693 1
a1693 1
      if (STREQN (tokstart, "int", 3))
@


1.22
log
@2003-09-25  David Carlton  <carlton@@kealia.com>

	* c-exp.y: Include cp-support.h.  Add qualified_type.
	(yylex): Delete nested type hack; add comments.
	* cp-namespace.c (cp_lookup_nested_type): New function.
	* cp-support.h: Declare cp_lookup_nested_type.
	* eval.c (evaluate_subexp_standard): Call value_aggregate_elt
	instead of value_struct_elt_for_reference.
	* valops.c: Include cp-support.h.
	(value_aggregate_elt): New function.
	(value_namespace_elt): Ditto.
	(value_struct_elt_for_reference): Make static.
	* value.h: Delete declaration of value_struct_elt_for_reference;
	add declaration for value_aggregate_elt.
	* Makefile.in (c-exp.tab.o): Depend on $(cp_support_h).
	(valops.o): Ditto.

2003-09-25  David Carlton  <carlton@@kealia.com>

	* gdb.cp/namespace.exp: Tweak comments.  Add non-quoted versions
	of some print tests, where appropriate.  Add tests for C::D::cd,
	E::ce, F::cXfX, G::XgX.
	* gdb.cp/namespace.cc: Add XgX, cXfX, ce.
@
text
@d707 1
a707 1
			      register char *arg = copy_name ($1.stoken);
d1050 2
a1051 2
     register char *p;
     register int len;
d1057 2
a1058 2
  register LONGEST n = 0;
  register LONGEST prevn = 0;
d1061 3
a1063 3
  register int i = 0;
  register int c;
  register int base = input_radix;
d1460 1
a1460 1
	register char *p = tokstart;
@


1.21
log
@	* c-exp.y (typebase): Remove duplicate occurence of
	`SIGNED_KEYWORD LONG LONG'.  Use builtin_type_long_long instead
	of lookup_signed_typename.
@
text
@d54 1
d157 1
a157 1
%type <tval> type typebase
d599 2
a600 1
			      && TYPE_CODE (type) != TYPE_CODE_UNION)
d614 2
a615 1
			      && TYPE_CODE (type) != TYPE_CODE_UNION)
d894 74
d1713 7
a1719 1
     colons for namespace and nested classes. */ 
d1773 3
a1775 84
#if 1
	  /* Despite the following flaw, we need to keep this code enabled.
	     Because we can get called from check_stub_method, if we don't
	     handle nested types then it screws many operations in any
	     program which uses nested types.  */
	  /* In "A::x", if x is a member function of A and there happens
	     to be a type (nested or not, since the stabs don't make that
	     distinction) named x, then this code incorrectly thinks we
	     are dealing with nested types rather than a member function.  */

	  char *p;
	  char *namestart;
	  struct symbol *best_sym;

	  /* Look ahead to detect nested types.  This probably should be
	     done in the grammar, but trying seemed to introduce a lot
	     of shift/reduce and reduce/reduce conflicts.  It's possible
	     that it could be done, though.  Or perhaps a non-grammar, but
	     less ad hoc, approach would work well.  */

	  /* Since we do not currently have any way of distinguishing
	     a nested type from a non-nested one (the stabs don't tell
	     us whether a type is nested), we just ignore the
	     containing type.  */

	  p = lexptr;
	  best_sym = sym;
	  while (1)
	    {
	      /* Skip whitespace.  */
	      while (*p == ' ' || *p == '\t' || *p == '\n')
		++p;
	      if (*p == ':' && p[1] == ':')
		{
		  /* Skip the `::'.  */
		  p += 2;
		  /* Skip whitespace.  */
		  while (*p == ' ' || *p == '\t' || *p == '\n')
		    ++p;
		  namestart = p;
		  while (*p == '_' || *p == '$' || (*p >= '0' && *p <= '9')
			 || (*p >= 'a' && *p <= 'z')
			 || (*p >= 'A' && *p <= 'Z'))
		    ++p;
		  if (p != namestart)
		    {
		      struct symbol *cur_sym;
		      /* As big as the whole rest of the expression, which is
			 at least big enough.  */
		      char *ncopy = alloca (strlen (tmp)+strlen (namestart)+3);
		      char *tmp1;

		      tmp1 = ncopy;
		      memcpy (tmp1, tmp, strlen (tmp));
		      tmp1 += strlen (tmp);
		      memcpy (tmp1, "::", 2);
		      tmp1 += 2;
		      memcpy (tmp1, namestart, p - namestart);
		      tmp1[p - namestart] = '\0';
		      cur_sym = lookup_symbol (ncopy, expression_context_block,
					       VAR_DOMAIN, (int *) NULL,
					       (struct symtab **) NULL);
		      if (cur_sym)
			{
			  if (SYMBOL_CLASS (cur_sym) == LOC_TYPEDEF)
			    {
			      best_sym = cur_sym;
			      lexptr = p;
			    }
			  else
			    break;
			}
		      else
			break;
		    }
		  else
		    break;
		}
	      else
		break;
	    }

	  yylval.tsym.type = SYMBOL_TYPE (best_sym);
#else /* not 0 */
a1776 1
#endif /* not 0 */
@


1.20
log
@2003-05-14  Elena Zannoni  <ezannoni@@redhat.com>

	* symtab.h (enum domain_enum): Rename from namespace_enum.
	(UNDEF_DOMAIN, VAR_DOMAIN, STRUCT_DOMAIN, LABEL_DOMAIN,
	VARIABLES_DOMAIN, FUNCTIONS_DOMAIN, TYPES_DOMAIN, METHODS_DOMAIN):
	Rename from UNDEF_NAMESPACE, VAR_NAMESPACE, STRUCT_NAMESPACE,
	LABEL_NAMESPACE, VARIABLES_NAMESPACE, FUNCTIONS_NAMESPACE,
	TYPES_NAMESPACE, METHODS_NAMESPACE.
	(SYMBOL_NAMESPACE): Rename to SYMBOL_DOMAIN.
	(struct symbol, struct partial_symbol): Rename field
	'namespace_enum namespace' to 'domain_enum domain'.
	(PSYMBOL_NAMESPACE): Rename to PSYMBOL_DOMAIN.
	Delete old define kludge for namespace.

	* ada-exp.y, ada-lang.c, ada-lang.h, alpha-tdep.c, arm-tdep.c,
	blockframe.c, c-exp.y, c-valprint.c, coffread.c, dbxread.c,
	dwarf2read.c, dwarfread.c, f-exp.y, gdbtypes.c, gdbtypes.h,
	gnu-v3-abi.c, hppa-tdep.c, hpread.c, jv-exp.y, jv-lang.c,
	language.c, linespec.c, m2-exp.y, m3-nat.c, mdebugread.c,
	mips-tdep.c, nlmread.c, objc-exp.y, objc-lang.c, objfiles.c,
	p-exp.y, p-valprint.c, parse.c, printcmd.c, scm-lang.c, source.c,
	stabsread.c, stack.c, symfile.c, symfile.h, symmisc.c, symtab.c,
	valops.c, values.c, xcoffread.c, xstormy16-tdep.c: Replace all
	occurrences of the above.

2003-05-12  Elena Zannoni  <ezannoni@@redhat.com>

	* mi-mi-cmd-stack.c (list_args_or_locals): Rename VAR_NAMESPACE to
	VAR_DOMAIN.
@
text
@d3 1
a3 1
   1998, 1999, 2000
d834 2
a843 4
	|	SIGNED_KEYWORD LONG LONG
			{ $$ = lookup_signed_typename ("long long"); }
	|	SIGNED_KEYWORD LONG LONG INT_KEYWORD
			{ $$ = lookup_signed_typename ("long long"); }
@


1.19
log
@2003-02-19  David Carlton  <carlton@@math.stanford.edu>

	* Makefile.in (SFILES): Add block.c.
	(block_h): New.
	(COMMON_OBS): Add block.o.
	(block.o): New.
	(x86-64-tdep.o): Add $(block_h).
	(values.o, valops.o, tracepoint.o, symtab.o, symmisc.o, symfile.o)
	(stack.o, printcmd.o, p-exp.tab.o, parse.o, objfiles.o)
	(objc-exp.tab.o, objc-lang.o, nlmread.o, mips-tdep.o, mdebugread.o)
	(m2-exp.tab.o, linespec.o, jv-lang.o, jv-exp.tab.o, infcmd.o)
	(f-valprint.o, findvar.o, f-exp.tab.o, expprint.o, coffread.o)
	(c-exp.tab.o, buildsym.o, breakpoint.o, blockframe.o, ax-gdb.o)
	(alpha-tdep.o, ada-lang.o, ada-exp.tab.o, mi-cmd-stack.o): Ditto.
	* value.h: Add opaque declaration for struct block.
	* parser-defs.h, objc-lang.h, buildsym.h, breakpoint.h: Ditto.
	* ada-lang.h: Ditto.
	* x86-64-tdep.c: #include "block.h"
	* values.c, valops.c, tracepoint.c, symtab.c, symmisc.c: Ditto.
	* symfile.c, stack.c, printcmd.c, p-exp.y, parse.c: Ditto.
	* objfiles.c, objc-exp.y, objc-lang.c, nlmread.c: Ditto.
	* mips-tdep.c, mdebugread.c, m2-exp.y, linespec.c: Ditto.
	* jv-lang.c, jv-exp.y, infcmd.c, f-valprint.c: Ditto.
	* findvar.c, f-exp.y, expprint.c, coffread.c, c-exp.y: Ditto.
	* buildsym.c, breakpoint.c, blockframe.c, ax-gdb.c: Ditto.
	* alpha-tdep.c, ada-lang.c, ada-exp.y: Ditto.
	* blockframe.c (blockvector_for_pc_sect): Move to "block.c".
	(blockvector_for_pc, block_for_pc_sect, block_for_pc): Ditto.
	* symtab.c (block_function): Ditto.
	(contained_in): Ditto.
	* frame.h: Move block_for_pc and block_for_pc_sect declarations to
	block.h.  Add opaque declaration for struct block.
	* symtab.h: Move block_function and contained_in declarations to
	block.h.  Add opaque declarations for struct block, struct
	blockvector.
	(struct block): Move to block.h.
	(struct blockvector): Ditto.
	(BLOCK_START, BLOCK_END, BLOCK_FUNCTION, BLOCK_SUPERBLOCK)
	(BLOCK_GCC_COMPILED, BLOCK_HASHTABLE, BLOCK_NSYMS, BLOCK_SYM)
	(BLOCK_BUCKETS, BLOCK_BUCKET, BLOCK_HASHTABLE_SIZE)
	(ALL_BLOCK_SYMBOLS, BLOCK_SHOULD_SORT, BLOCKVECTOR_NBLOCKS)
	(BLOCKVECTOR_BLOCK, GLOBAL_BLOCK, STATIC_BLOCK, FIRST_LOCAL_BLOCK):
	Ditto.
	* block.c: New file.
	* block.h: New file.

2003-02-19  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c: #include "block.h"
@
text
@d570 1
a570 1
					     VAR_NAMESPACE, (int *) NULL,
d581 1
a581 1
					       VAR_NAMESPACE, (int *) NULL,
d640 1
a640 1
					   VAR_NAMESPACE, (int *) NULL,
d1664 1
a1664 1
			 VAR_NAMESPACE,
d1752 1
a1752 1
					       VAR_NAMESPACE, (int *) NULL,
@


1.19.20.1
log
@Snap const char * mess.
@
text
@d1546 1
a1546 1
               const char *p = find_template_name_end (tokstart + namelen);
@


1.19.16.1
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d570 1
a570 1
					     VAR_DOMAIN, (int *) NULL,
d581 1
a581 1
					       VAR_DOMAIN, (int *) NULL,
d640 1
a640 1
					   VAR_DOMAIN, (int *) NULL,
d1664 1
a1664 1
			 VAR_DOMAIN,
d1752 1
a1752 1
					       VAR_DOMAIN, (int *) NULL,
@


1.18
log
@2003-01-31  Andrew Cagney  <ac131313@@redhat.com>

	* objc-exp.y, c-exp.y, f-exp.y: Remove PTR casts.
	* utils.c: Update comments documenting legitimate uses of PTR.
@
text
@d53 1
@


1.17
log
@* c-exp.y: Add missing semi-colons.
* f-exp.y: Add missing semi-colons.
* m2-exp.y: Add missing semi-colons.
* p-exp.y: Add missing semi-colons.
Add empty action to start rule to avoid a type clash error when
building with bison >= 1.50.
@
text
@d784 1
a784 1
			{ free ((PTR)$2); $$ = 0; }
@


1.16
log
@        * c-exp.y (THIS): Delete token and grammar rule.
        (yylex): Don't return THIS.
        * cp-valprint.c (vtbl_ptr_name_old): Delete.
        (cp_is_vtbl_ptr_type): Don't check vtbl_ptr_name_old.
        * demangle.c (cplus_markers): Update comment.  Put '$'
        first.  Remove CPLUS_MARKER.
        (_initialize_demangler): Don't call set_cplus_marker_for_demangling.
        * jv-exp.y (THIS): Delete token and grammar rule.
        (yylex): Don't return THIS.
        * mips-tdep.c (mips_dump_tdep): Don't dump CPLUS_MARKER.
        * objc-exp.y (THIS): Delete token and grammar rule.
        (yylex): Don't return THIS.
        * p-exp.y (yylex): Remove reference to CPLUS_MARKER.
        * stabsread.c (vptr_name, vb_name): Replace CPLUS_MARKER with '$'.
        (read_member_functions): Likewise for opname.
        (read_tilde_fields): Use is_cplus_marker.

        * defs.h (CPLUS_MARKER): Don't define.
        * config/tm-sysv4.h (CPLUS_MARKER): Likewise.
        * config/i386/xm-i386sco.h (CPLUS_MARKER): Likewise.
        * config/mips/tm-irix3.h (CPLUS_MARKER): Likewise.
        * config/mips/tm-irix6.h (CPLUS_MARKER): Likewise.
        * config/rs6000/tm-rs6000.h (CPLUS_MARKER): Likewise.

        * config/i386/tm-i386v4.h: Delete file.
        * config/djgpp/fnchange.lst: Delete tm-i386v4.h.
        * config/i386/tm-i386sol2.h: Include "i386/tm-i386.h" instead.
        * config/i386/tm-i386v42mp.h: Include "i386/tm-i386.h" instead.
        * config/i386/tm-ptx.h: Include "i386/tm-i386.h" instead.
        * config/i386/i386gnu.mt (TM_FILE): Use tm-i386.h.
        * config/i386/i386sco5.mt (TM_FILE): Likewise.
        * config/i386/i386v4.mt (TM_FILE): Likewise.
        * config/i386/ncr3000.mt (TM_FILE): Likewise.
@
text
@d250 1
d254 1
@


1.15
log
@Add support for distinct host and target character sets.
@
text
@a201 1
%token THIS
a533 5
exp	:	THIS
			{ write_exp_elt_opcode (OP_THIS);
			  write_exp_elt_opcode (OP_THIS); }
	;

a1611 11

            if (STREQN (tokstart, "this", 4))
              {
                static const char this_name[] =
                { CPLUS_MARKER, 't', 'h', 'i', 's', '\0' };
                
                if (lookup_symbol (this_name, expression_context_block,
                                   VAR_NAMESPACE, (int *) NULL,
                                   (struct symtab **) NULL))
                  return THIS;
              }
@


1.15.4.1
log
@Merge drow-cplus-merge-20021025 to drow-cplus-branch.
@
text
@d202 1
d535 5
d1618 11
@


1.15.4.2
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d3 1
a3 1
   1998, 1999, 2000, 2003
a52 2
#include "block.h"
#include "cp-support.h"
d155 1
a155 1
%type <tval> type typebase qualified_type
a249 1
	;
a252 1
	;
d567 1
a567 1
					     VAR_DOMAIN, (int *) NULL,
d578 1
a578 1
					       VAR_DOMAIN, (int *) NULL,
d595 1
a595 2
			      && TYPE_CODE (type) != TYPE_CODE_UNION
			      && TYPE_CODE (type) != TYPE_CODE_NAMESPACE)
d609 1
a609 2
			      && TYPE_CODE (type) != TYPE_CODE_UNION
			      && TYPE_CODE (type) != TYPE_CODE_NAMESPACE)
d637 1
a637 1
					   VAR_DOMAIN, (int *) NULL,
d701 1
a701 1
			      char *arg = copy_name ($1.stoken);
d782 1
a782 1
			{ free ($2); $$ = 0; }
a830 2
	|	SIGNED_KEYWORD LONG LONG INT_KEYWORD
			{ $$ = builtin_type_long_long; }
d839 4
a889 74
	| qualified_type
	;

/* FIXME: carlton/2003-09-25: This next bit leads to lots of
   reduce-reduce conflicts, because the parser doesn't know whether or
   not to use qualified_name or qualified_type: the rules are
   identical.  If the parser is parsing 'A::B::x', then, when it sees
   the second '::', it knows that the expression to the left of it has
   to be a type, so it uses qualified_type.  But if it is parsing just
   'A::B', then it doesn't have any way of knowing which rule to use,
   so there's a reduce-reduce conflict; it picks qualified_name, since
   that occurs earlier in this file than qualified_type.

   There's no good way to fix this with the grammar as it stands; as
   far as I can tell, some of the problems arise from ambiguities that
   GDB introduces ('start' can be either an expression or a type), but
   some of it is inherent to the nature of C++ (you want to treat the
   input "(FOO)" fairly differently depending on whether FOO is an
   expression or a type, and if FOO is a complex expression, this can
   be hard to determine at the right time).  Fortunately, it works
   pretty well in most cases.  For example, if you do 'ptype A::B',
   where A::B is a nested type, then the parser will mistakenly
   misidentify it as an expression; but evaluate_subexp will get
   called with 'noside' set to EVAL_AVOID_SIDE_EFFECTS, and everything
   will work out anyways.  But there are situations where the parser
   will get confused: the most common one that I've run into is when
   you want to do

     print *((A::B *) x)"

   where the parser doesn't realize that A::B has to be a type until
   it hits the first right paren, at which point it's too late.  (The
   workaround is to type "print *(('A::B' *) x)" instead.)  (And
   another solution is to fix our symbol-handling code so that the
   user never wants to type something like that in the first place,
   because we get all the types right without the user's help!)

   Perhaps we could fix this by making the lexer smarter.  Some of
   this functionality used to be in the lexer, but in a way that
   worked even less well than the current solution: that attempt
   involved having the parser sometimes handle '::' and having the
   lexer sometimes handle it, and without a clear division of
   responsibility, it quickly degenerated into a big mess.  Probably
   the eventual correct solution will give more of a role to the lexer
   (ideally via code that is shared between the lexer and
   decode_line_1), but I'm not holding my breath waiting for somebody
   to get around to cleaning this up...  */

/* FIXME: carlton/2003-09-25: Currently, the only qualified type
   symbols that we generate are nested namespaces.  Next on my TODO
   list is to generate all nested type names properly (or at least as
   well as possible, assuming that we're using DWARF-2).  */

qualified_type: typebase COLONCOLON name
		{
		  struct type *type = $1;
		  struct type *new_type;
		  char *ncopy = alloca ($3.length + 1);

		  memcpy (ncopy, $3.ptr, $3.length);
		  ncopy[$3.length] = '\0';

		  if (TYPE_CODE (type) != TYPE_CODE_NAMESPACE)
		    error ("`%s' is not defined as a namespace.",
			   TYPE_NAME (type));

		  new_type = cp_lookup_nested_type (type, ncopy,
						    expression_context_block);
		  if (new_type == NULL)
		    error ("No type \"%s\" in namespace \"%s\".",
			   ncopy, TYPE_NAME (type));
		  
		  $$ = new_type;
		}
d972 2
a973 2
     char *p;
     int len;
d979 2
a980 2
  LONGEST n = 0;
  LONGEST prevn = 0;
d983 3
a985 3
  int i = 0;
  int c;
  int base = input_radix;
d1265 1
a1265 1
    if (strncmp (tokstart, tokentab3[i].operator, 3) == 0)
d1274 1
a1274 1
    if (strncmp (tokstart, tokentab2[i].operator, 2) == 0)
d1382 1
a1382 1
	char *p = tokstart;
d1570 1
a1570 1
      if (strncmp (tokstart, "unsigned", 8) == 0)
d1573 1
a1573 1
	  && strncmp (tokstart, "template", 8) == 0)
d1575 1
a1575 1
      if (strncmp (tokstart, "volatile", 8) == 0)
d1579 1
a1579 1
      if (strncmp (tokstart, "struct", 6) == 0)
d1581 1
a1581 1
      if (strncmp (tokstart, "signed", 6) == 0)
d1583 1
a1583 1
      if (strncmp (tokstart, "sizeof", 6) == 0)
d1585 1
a1585 1
      if (strncmp (tokstart, "double", 6) == 0)
d1591 1
a1591 1
          if (strncmp (tokstart, "false", 5) == 0)
d1593 1
a1593 1
          if (strncmp (tokstart, "class", 5) == 0)
d1596 1
a1596 1
      if (strncmp (tokstart, "union", 5) == 0)
d1598 1
a1598 1
      if (strncmp (tokstart, "short", 5) == 0)
d1600 1
a1600 1
      if (strncmp (tokstart, "const", 5) == 0)
d1604 1
a1604 1
      if (strncmp (tokstart, "enum", 4) == 0)
d1606 1
a1606 1
      if (strncmp (tokstart, "long", 4) == 0)
d1610 1
a1610 1
            if (strncmp (tokstart, "true", 4) == 0)
d1615 1
a1615 1
      if (strncmp (tokstart, "int", 3) == 0)
d1635 1
a1635 7
     colons for namespace and nested classes. */

  /* NOTE: carlton/2003-09-24: I don't entirely understand the
     HP-specific code, either here or in linespec.  Having said that,
     I suspect that we're actually moving towards their model: we want
     symbols whose names are fully qualified, which matches the
     description above.  */
d1661 1
a1661 1
			 VAR_DOMAIN,
d1689 84
a1772 3
	  /* NOTE: carlton/2003-09-25: There used to be code here to
	     handle nested types.  It didn't work very well.  See the
	     comment before qualified_type for more info.  */
d1774 1
@


1.15.4.3
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d3 1
a3 1
   1998, 1999, 2000, 2003, 2004
d942 5
d956 2
a957 4
		  if (TYPE_CODE (type) != TYPE_CODE_STRUCT
		      && TYPE_CODE (type) != TYPE_CODE_UNION
		      && TYPE_CODE (type) != TYPE_CODE_NAMESPACE)
		    error ("`%s' is not defined as an aggregate type.",
d963 1
a963 1
		    error ("No type \"%s\" within class or namespace \"%s\".",
@


1.15.2.1
log
@Merge with mainline; merge tag carlton_dictionary-20021011-merge.
@
text
@d202 1
d535 5
d1618 11
@


1.15.2.2
log
@2002-10-18  David Carlton  <carlton@@math.stanford.edu>

	* Makefile.in (block_h): New variable.
	Updated dependencies to reflect it.
	* parse.c (parse_exp_1): Use BLOCK_START.
	#include "block.h"
	* p-exp.tab.c: Regenerated.
	* m2-exp.tab.c: Ditto.
	* jv-exp.tab.c: Ditto.
	* f-exp.tab.c: Ditto.
	* c-exp.tab.c: Ditto.
	* ada-exp.tab.c: Ditto.
	* ada-lang.c: #include "block.h"
	* p-exp.y: Ditto.
	* objc-exp.y: Ditto.
	* m2-exp.y: Ditto.
	* jv-exp.y: Ditto.
	* f-exp.y: Ditto.
	* c-exp.y: Ditto.
	* ada-exp.y: Ditto.
	* values.c: Ditto.
	* valops.c: Ditto.
	* tracepoint.c: Ditto.
	* symtab.c: Ditto.
	* symmisc.c: Ditto.
	* symfile.c: Ditto.
	* stack.c: Ditto.
	* printcmd.c: Ditto.
	* objfiles.c: Ditto.
	* objc-lang.c: Ditto.
	* nlmread.c: Ditto.
	* mips-tdep.c: Ditto.
	* mdebugread.c: Ditto.
	* linespec.c: Ditto.
	* jv-lang.c: Ditto.
	* infcmd.c: Ditto.
	* f-valprint.c: Ditto.
	* findvar.c: Ditto.
	* expprint.c: Ditto.
	* coffread.c: Ditto.
	* buildsym.c: Ditto.
	* breakpoint.c: Ditto.
	* blockframe.c: Ditto.
	* ax-gdb.c: Ditto.
	* alpha-tdep.c: Ditto.
	* block.h: New file.
	* symtab.h: Moved struct block, struct blockvector, and related
	macros and function declarations to block.h.
	* dwarf2read.c (process_die): Set processing_has_namespace_info if
	we run into DW_TAG_namespace, DW_TAG_imported_declaration, or
	DW_TAG_imported_module.
	New variable current_namespace.
	(psymtab_to_symtab_1): Set current_namespace to "".
	(dwarf2_name): New function.
	(dwarf2_add_member_fn): Get name via dwarf2_name.
	(read_typedef): Ditto.
	(read_file_scope): Ditto.
	(dwarf2_add_field): Ditto.
	(read_structure_scope): Ditto.
	(read_enumeration): Ditto.
	(dwarf2_extension): New function.
	(read_namespace): Set current_namespace correctly; also, if we're
	entering an anonymous namespace, add an appropriate using
	directive.
	* buildsym.c (start_symtab): Reset processing_has_namespace_info
	to 0.
	(add_symbol_to_list): Only scan for anonymous namespaces if
	!processing_has_namespace_info.
	* buildsym.h: Add new flag processing_has_namespace_info.

2002-10-18  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c: #include "block.h"
@
text
@a45 1
#include "block.h"
@


1.15.2.3
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@a250 1
	;
a253 1
	;
@


1.15.2.4
log
@2002-11-22  David Carlton  <carlton@@math.stanford.edu>

	* linespec.c (examine_compound_token): Rewrite as switch
	statement, and add FIXME comment.
	* frame.h: Make arg of block_innermost_frame const.
	* blockframe.c (block_innermost_frame): Make arg const.
	* block.h: Make args to block_function, contained_in const.
	* block.c (block_function): Make arg const.
	(contained_in): Ditto.
	* value.h: Make arg of symbol_read_needs_frame const.
	* findvar.c (symbol_read_needs_frame): Make arg const.
	* symtab.h: Make first arg of symbol_demangled_name const.
	* symtab.c (symbol_demangled_name): Make arg const.
	* value.h: Make first arg of read_var_value const.
	* findvar.c (read_var_value): Make first arg const.
	* Makefile.in (valops.o): Depend on cp_support_h.
	* valops.c: #include "cp-support.h"
	* symtab.h: Add FIXME about name of namespace_enum.
	Add opaque declaration of struct using_direct_node.
	* symtab.c (lookup_symbol_namespace): Make extern; rename args.
	* symtab.h: Declare lookup_symbol_namespace.
	* valops.c (value_struct_elt_for_reference): Make 'name' a const
	char *.
	(value_namespace_elt): New function.
	* expprint.c (print_subexp): Ditto.
	(dump_subexp): Ditto.
	* parse.c (length_of_subexp): Ditto.
	(prefixify_subexp): Ditto.
	* expression.h: Update comment to reflect the block in OP_SCOPE.
	* c-exp.y: Set block in OP_SCOPE expression.
	* jv-exp.y (push_qualified_expression_name): Put a NULL block in
	OP_SCOPE expression.
	* objc-exp.y: Ditto.
	* p-exp.y: Ditto.
	* eval.c (evaluate_subexp_standard): Handle OP_SCOPE via
	value_aggregate_elt.
	* value.h: Add declaration for value_aggregate_elt; delete
	declaration for value_struct_elt_for_reference.
	* valops.c (value_aggregate_elt): New function.
	(value_struct_elt_for_reference): Make static.  Don't check type
	of curtype.
	* c-exp.y: Accept TYPE_CODE_NAMESPACE in qualified_name.
	* cp-support.c (cp_check_namespace_symbol): Set TYPE_NAME (type).

2002-11-22  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Change a couple of tests to not use
	single quotes.
@
text
@d598 1
a598 2
			      && TYPE_CODE (type) != TYPE_CODE_UNION
			      && TYPE_CODE (type) != TYPE_CODE_NAMESPACE)
a603 3
			  /* If it's a namespace, we need to know the
			     block.  */
			  write_exp_elt_block (expression_context_block);
d612 1
a612 2
			      && TYPE_CODE (type) != TYPE_CODE_UNION
			      && TYPE_CODE (type) != TYPE_CODE_NAMESPACE)
a625 1
			  write_exp_elt_block (expression_context_block);
@


1.15.2.5
log
@2002-12-17  David Carlton  <carlton@@math.stanford.edu>

	* c-exp.y (yylex): Modify the #if 1 block to handle nested types
	in a more honest manner.
	* symtab.c (lookup_nested_type): New function.
	* symtab.h: Declare lookup_nested_type.

2002-12-16  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_partial_symbol): Don't search past the end of
	the partial symbols.
	* Makefile.in (f-exp.tab.c): Don't depend on c-exp.tab.c.
	* dwarf2read.c (new_symbol): Only make global symbols associated
	to structures, etc. if the current language is C++.
	(add_partial_symbol): Ditto (for partial symbols).

2002-12-17  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/m-data.cc: Whitespace cleanup, to match mainline patch.
	* gdb.c++/m-static.cc: Ditto.
	* gdb.c++/namespace.exp: Fix comment.  Delete third argument to
	all the gdb_tests.

2002-12-16  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Change KFAIL messages to point to c++/XXX
	instead of gdb/XXX.
@
text
@d3 1
a3 1
   1998, 1999, 2000, 2001, 2002
d1644 1
a1644 8
     colons for namespace and nested classes. */

  /* NOTE: carlton/2002-12-17: I really don't understand this
     HP-specific stuff (here or in linespec), but it has to go away.
     It's actually possible that it would be best to start from the
     current HP case than from the current non-HP case: the
     description of HP symbol names sounds like what I'm trying to get
     symbol names to look like.  */
d1699 9
d1710 1
a1710 1
	  struct type *best_type;
d1718 4
a1721 18
	  /* NOTE: carlton/2002-12-17: The idea of doing this in the
	     lexer rather than the grammar seems awful to me.
	     Unfortunately, there currently seems to be no way around
	     it that I can see: the grammar is for either expressions
	     or types (see the 'start' rule), so it can be used for
	     the commands 'print' and 'ptype', and furthermore it's
	     the parser's job to evaluate types whereas it's
	     evaluate_expression's job to evaluate other expressions,
	     which combine to make an awful mess.

	     So, for now, we 'handle' nested types here.  Sigh.  But I
	     really don't think this setup is a good idea: it papers
	     over :: issues, and should fall flat on its face when
	     dealing with initial :: operators.

	     An earlier version of this code was even worse: it
	     'dealt' with nested types by pretending they weren't
	     nested, because of stabs limitations.  Sigh.  */
d1724 1
a1724 1
	  best_type = SYMBOL_TYPE (sym);
d1744 17
a1760 8
		      struct type *cur_type;
		      char *ncopy = alloca (p - namestart + 1);
		      memcpy (ncopy, namestart, p - namestart);
		      ncopy[p - namestart] = '\0';
		      cur_type = lookup_nested_type (best_type,
						     ncopy,
						     expression_context_block);
		      if (cur_type != NULL)
d1762 7
a1768 2
			  best_type = cur_type;
			  lexptr = p;
d1780 2
a1781 2
	  yylval.tsym.type = best_type;
#else /* not 1 */
d1783 1
a1783 1
#endif /* not 1 */
@


1.15.2.6
log
@2003-01-20  David Carlton  <carlton@@math.stanford.edu>

	* p-exp.y: Add block to OP_FUNCALL.
	* objc-exp.y: Add block to OP_FUNCALL.
	* m2-exp.y: Add block to OP_FUNCALL.
	* c-exp.y: Add block to OP_FUNCALL.
	* ada-exp.y: Add block to OP_FUNCALL.
	(write_object_renaming): Ditto.
	* parse.c (length_of_subexp): Split off OP_FUNCALL.
	(prefixify_subexp): Ditto.
	* expprint.c (print_subexp): Change offset for OP_FUNCALL.
	(dump_subexp): Ditto.
	* eval.c (evaluate_subexp_standard): Change offset for
	OP_FUNCALL.
	* ada-lang.c (ada_resolve_subexp): Add comment on OP_FUNCALL.
	(replace_operator_with_call): Add block to OP_FUNCALL.
	(ada_evaluate_subexp): Change offset for OP_FUNCALL.
	* expression.h (exp_opcode): Change comments before OP_FUNCALL and
	OP_F77_UNDETERMINED_ARGLIST.

2003-01-14  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (search_symbols): Add comment.
	(lookup_symbol_aux_using): Function name should start line.
	(lookup_symbol_aux_using_loop): Ditto.
	(lookup_block_symbol): Add comment.

2003-01-13  David Carlton  <carlton@@math.stanford.edu>

	* dwarf2read.c (read_structure_scope): Add comment.
	(add_partial_structure): Ditto.
	* symtab.c (lookup_transparent_type): Add comment.
@
text
@a335 1
			  write_exp_elt_block (expression_context_block);
@


1.15.2.7
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d792 1
a792 1
			{ free ($2); $$ = 0; }
@


1.15.2.8
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d46 1
a53 1
#include "block.h"
@


1.15.2.9
log
@2003-03-07  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_partial_symbol): Replace uses of
	SYMBOL_MATCHES_NATURAL_NAME by equivalent uses of
	SYMBOL_NATURAL_NAME, strcmp_iw.
	* symtab.h (SYMBOL_MATCHES_NATURAL_NAME): Delete.
	* minsyms.c (lookup_minimal_symbol_linkage): Make static.
	(lookup_minimal_symbol_natural): Ditto.
	(lookup_minimal_symbol): Only search on linkage names; rename
	first argument to 'linkage_name'.
	(lookup_minimal_symbol_linkage): Delete.
	(lookup_minimal_symbol_natural): Delete.
	(add_minsym_to_demangled_hash_table): Go back to using
	SYMBOL_DEMANGLED_NAME instead of SYMBOL_NATURAL_NAME.
	(lookup_minimal_symbol_aux): Don't use
	SYMBOL_MATCHES_NATURAL_NAME: do a strcmp_iw on
	SYMBOL_DEMANGLED_NAME instead.  Add comment.
	(build_minimal_symbol_hash_tables): Go back to only adding to
	demangled has table if SYMBOL_DEMANGLED_NAME is non-NULL.
	* symtab.h: Delete declarations for lookup_minimal_symbol_linkage
	and lookup_minimal_symbol_natural.
	* valops.c (find_function_in_inferior): Use lookup_symbol_linkage
	instead of lookup_symbol.  Change comment.
	* remote.c (remote_check_symbols): Use
	lookup_minimal_symbol_linkage_or_natural instead of
	lookup_minimal_symbol, but add FIXME comment as well.
	* objc-lang.c: Ditto.
	* c-exp.y: Use lookup_minimal_symbol_linkage_or_natural instead of
	lookup_minimal_symbol.
	* p-exp.y: Ditto.
	* objc-exp.y: Ditto.
	* m2-exp.y: Ditto.
	* jv-exp.y (push_expression_name): Ditto.
	* f-exp.y: Ditto.
	* printcmd.c (address_info): Ditto.
	* symtab.h: Declare lookup_minimal_symbol_linkage_or_natural.
	* minsyms.c (lookup_minimal_symbol_linkage_or_natural): New.
	* ax-gdb.c (gen_var_ref): Use SYMBOL_LINKAGE_NAME instead of
	DEPRECATED_SYMBOL_NAME.
	* tracepoint.c (scope_info): Ditto.
	* symtab.c (find_pc_sect_line): Ditto.
	* stabsread.c (define_symbol): Ditto.
	* sol-thread.c (info_cb): Ditto.
	* printcmd.c (address_info): Ditto.
	* hppa-tdep.c (hppa_fix_call_dummy): Ditto.
	(hppa_in_solib_call_trampoline): Ditto.
	* findvar.c (read_var_value): Ditto.
@
text
@d658 1
a658 2
			  msymbol
			    = lookup_minimal_symbol_linkage_or_natural (name);
d714 1
a714 1
				lookup_minimal_symbol_linkage_or_natural (arg);
@


1.15.2.10
log
@2003-05-07  David Carlton  <carlton@@bactrian.org>

	* valops.c (value_aggregate_elt): Add 'noside' argument.
	(value_struct_elt_for_reference): Add 'block', 'noside'
	arguments.  Call value_maybe_namespace_elt.
	(value_namespace_elt): Add 'noside' argument.  Break out code into
	value_maybe_namespace_elt.
	(value_maybe_namespace_elt): New.  Handle types.
	* value.h: Update declaration for value_aggregate_elt.
	* eval.c (evaluate_subexp_standard): Pass 'noside' to
	value_aggregate_elt.
	* c-exp.y: Added 'qualified_type'.
	(yylex): Comment out nested type stuff.

2003-05-07  David Carlton  <carlton@@bactrian.org>

	* gdb.c++/namespace.exp: Update messages to match new parser
	changes.
@
text
@d156 1
a156 1
%type <tval> type typebase qualified_type
a900 26
	| qualified_type
	;

qualified_type: typebase COLONCOLON name
		{
		  struct type *type = $1;
		  struct type *new_type;
		  char *ncopy = alloca ($3.length + 1);

		  memcpy (ncopy, $3.ptr, $3.length);
		  ncopy[$3.length] = '\0';

		  if (TYPE_CODE (type) != TYPE_CODE_STRUCT
		      && TYPE_CODE (type) != TYPE_CODE_UNION
		      && TYPE_CODE (type) != TYPE_CODE_NAMESPACE)
		    error ("`%s' is not defined as an aggregate type.",
			   TYPE_NAME (type));

		  new_type = lookup_nested_type (type, ncopy,
						 expression_context_block);
		  if (new_type == NULL)
		    error ("No type \"%s\" within class or namespace \"%s\".",
			   ncopy, TYPE_NAME (type));
		  
		  $$ = new_type;
		}
d1707 1
a1707 1
#if 0
@


1.15.2.11
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d3 1
a3 1
   1998, 1999, 2000, 2003
d571 1
a571 1
					     VAR_DOMAIN, (int *) NULL,
d582 1
a582 1
					       VAR_DOMAIN, (int *) NULL,
d647 1
a647 1
					   VAR_DOMAIN, (int *) NULL,
a841 2
	|	SIGNED_KEYWORD LONG LONG INT_KEYWORD
			{ $$ = builtin_type_long_long; }
d850 4
d1705 1
a1705 1
			 VAR_DOMAIN,
@


1.15.2.12
log
@2003-09-19  David Carlton  <carlton@@kealia.com>

	* expression.h (enum exp_opcode): Revert to mainline's OP_FUNCALL,
	OP_SCOPE.
	* ada-exp.y, m2-exp.y, objc-exp.y, p-exp.y: Ditto.
	* jv-exp.y (push_qualified_expression_name): Ditto.
	* ada-lang.c (ada_resolve_subexp, replace_operator_with_call)
	(ada_evaluate_subexp): Ditto.
	* eval.c (evaluate_subexp_standard): Ditto.
	* expprint.c (print_subexp, dump_subexp): Ditto.
	* parse.c (length_of_subexp, prefixify_subexp): Ditto.
	* c-exp.y: Ditto, and add comment.
	* cp-support.c (make_symbol_overload_list): Delete 'block'
	argument; change calls to make_symbol_overload_list_using
	appropriately.
	(make_symbol_overload_list_using): Delete 'block' argument;
	replace it by get_selected_block (0).
	* cp-support.h: Delete 'block' argument from
	make_symbol_overload_list.
	* valops.c (find_overload_match): Delete 'block' argument, and
	update calls using it.
	(find_oload_champ_namespace, find_oload_champ_namespace_loop)
	(value_aggregate_elt, value_struct_elt_for_reference)
	(value_namespace_elt): Ditto.
	(value_maybe_namespace_elt): Delete 'block' argument, and use
	get_selected_block (0) instead.
	* value.h: Delete 'block' argument from value_struct_elt,
	value_find_oload.
@
text
@d336 1
d606 3
d632 1
a900 18

/* FIXME: carlton/2003-09-19: This leads to lots of reduce-reduce
   conflicts, because the parser doesn't know whether or not to use
   qualified_name or qualified_type.  There's no good way to fix this
   with the grammar as it stands; as far as I can tell, some of the
   problems arise from ambiguities that GDB introduces ('start' can be
   either an expression or a type), but some of it is inherent to the
   nature of C++ (you want to treat the input "(FOO)" fairly
   differently depending on whether FOO is an expression or a type,
   and if FOO is a complex expression, this can be hard to determine
   at the right time.

   Perhaps we could fix this by making the lexer smarter.  (Some of
   this functionality used to be in the lexer, but in a way that
   worked even less well than the current solution.)  Ideally, the
   code in question could be shared by the lexer and by decode_line_1.
   I'm not holding my breath waiting for somebody to get around to
   cleaning this up, however...  */
@


1.15.2.13
log
@2003-09-30  David Carlton  <carlton@@kealia.com>

	* Makefile.in (c-exp.tab.o): Depend on cp_support_h.
	* c-exp.y: Include c-exp.y.  Update comments, replace
	lookup_nested_type by cp_lookup_nested_type.
	(yylex): Update comments, remove #if 0 block.
	* cp-namespace.c (cp_lookup_nested_type): Move here from symtab.c;
	rename from lookup_nested_type.
	* cp-support.h: Add cp_lookup_nested_type declaration.
	* dwarf2read.c (read_die_and_children): Update comment.
	(read_die_and_siblings): Update comment, move declaration of
	'die'.
	(read_full_die): Update comment, tweak formatting.
	* symtab.c (lookup_nested_type): Move to cp-namespace.c, rename to
	cp_lookup_nested_type.
	* symtab.h: Delete declaration of lookup_nested_type.
@
text
@a53 1
#include "cp-support.h"
d897 10
a906 33
/* FIXME: carlton/2003-09-25: This next bit leads to lots of
   reduce-reduce conflicts, because the parser doesn't know whether or
   not to use qualified_name or qualified_type: the rules are
   identical.  If the parser is parsing 'A::B::x', then, when it sees
   the second '::', it knows that the expression to the left of it has
   to be a type, so it uses qualified_type.  But if it is parsing just
   'A::B', then it doesn't have any way of knowing which rule to use,
   so there's a reduce-reduce conflict; it picks qualified_name, since
   that occurs earlier in this file than qualified_type.

   There's no good way to fix this with the grammar as it stands; as
   far as I can tell, some of the problems arise from ambiguities that
   GDB introduces ('start' can be either an expression or a type), but
   some of it is inherent to the nature of C++ (you want to treat the
   input "(FOO)" fairly differently depending on whether FOO is an
   expression or a type, and if FOO is a complex expression, this can
   be hard to determine at the right time).  Fortunately, it works
   pretty well in most cases.  For example, if you do 'ptype A::B',
   where A::B is a nested type, then the parser will mistakenly
   misidentify it as an expression; but evaluate_subexp will get
   called with 'noside' set to EVAL_AVOID_SIDE_EFFECTS, and everything
   will work out anyways.  But there are situations where the parser
   will get confused: the most common one that I've run into is when
   you want to do

     print *((A::B *) x)"

   where the parser doesn't realize that A::B has to be a type until
   it hits the first right paren, at which point it's too late.  (The
   workaround is to type "print *(('A::B' *) x)" instead.)  (And
   another solution is to fix our symbol-handling code so that the
   user never wants to type something like that in the first place,
   because we get all the types right without the user's help!)
d908 1
a908 1
   Perhaps we could fix this by making the lexer smarter.  Some of
d910 4
a913 8
   worked even less well than the current solution: that attempt
   involved having the parser sometimes handle '::' and having the
   lexer sometimes handle it, and without a clear division of
   responsibility, it quickly degenerated into a big mess.  Probably
   the eventual correct solution will give more of a role to the lexer
   (ideally via code that is shared between the lexer and
   decode_line_1), but I'm not holding my breath waiting for somebody
   to get around to cleaning this up...  */
d930 2
a931 2
		  new_type = cp_lookup_nested_type (type, ncopy,
						    expression_context_block);
d1685 6
a1690 5
  /* NOTE: carlton/2003-09-24: I don't entirely understand the
     HP-specific code, either here or in linespec.  Having said that,
     I suspect that we're actually moving towards their model: we want
     symbols whose names are fully qualified, which matches the
     description above.  */
d1744 75
a1818 3
	  /* NOTE: carlton/2003-09-25: There used to be code here to
	     handle nested types.  It didn't work very well.  See the
	     comment before qualified_type for more info.  */
d1820 1
@


1.15.2.14
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d708 1
a708 1
			      char *arg = copy_name ($1.stoken);
d1048 2
a1049 2
     char *p;
     int len;
d1055 2
a1056 2
  LONGEST n = 0;
  LONGEST prevn = 0;
d1059 3
a1061 3
  int i = 0;
  int c;
  int base = input_radix;
d1341 1
a1341 1
    if (strncmp (tokstart, tokentab3[i].operator, 3) == 0)
d1350 1
a1350 1
    if (strncmp (tokstart, tokentab2[i].operator, 2) == 0)
d1458 1
a1458 1
	char *p = tokstart;
d1646 1
a1646 1
      if (strncmp (tokstart, "unsigned", 8) == 0)
d1649 1
a1649 1
	  && strncmp (tokstart, "template", 8) == 0)
d1651 1
a1651 1
      if (strncmp (tokstart, "volatile", 8) == 0)
d1655 1
a1655 1
      if (strncmp (tokstart, "struct", 6) == 0)
d1657 1
a1657 1
      if (strncmp (tokstart, "signed", 6) == 0)
d1659 1
a1659 1
      if (strncmp (tokstart, "sizeof", 6) == 0)
d1661 1
a1661 1
      if (strncmp (tokstart, "double", 6) == 0)
d1667 1
a1667 1
          if (strncmp (tokstart, "false", 5) == 0)
d1669 1
a1669 1
          if (strncmp (tokstart, "class", 5) == 0)
d1672 1
a1672 1
      if (strncmp (tokstart, "union", 5) == 0)
d1674 1
a1674 1
      if (strncmp (tokstart, "short", 5) == 0)
d1676 1
a1676 1
      if (strncmp (tokstart, "const", 5) == 0)
d1680 1
a1680 1
      if (strncmp (tokstart, "enum", 4) == 0)
d1682 1
a1682 1
      if (strncmp (tokstart, "long", 4) == 0)
d1686 1
a1686 1
            if (strncmp (tokstart, "true", 4) == 0)
d1691 1
a1691 1
      if (strncmp (tokstart, "int", 3) == 0)
@


1.15.2.15
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d3 1
a3 1
   1998, 1999, 2000, 2003, 2004
@


1.14
log
@Revert previous change.  Not obvious.
@
text
@d52 1
d1318 9
d1477 2
d1501 13
a1513 1
	    tempbuf[tempbufindex++] = *tokptr++;
@


1.13
log
@2002-09-18  Michael Snyder  <msnyder@@redhat.com>

	Preliminary support for Objective-C:
	* defs.h (language_objc): New enum value.
	(puts_filtered_tabular): Declaration only, exported from utils.c.
	(skip_quoted): Delete, declared in completer.h.
	* c-exp.y: Include completer.h.
	* p-exp.y: Ditto.
	* jv-exp.y: Ditto.
	* expression.h (OP_MSGCALL, OP_SELECTOR, OP_SELF, OP_NSSTRING):
	New operator enum values.
	* language.h (CAST_IS_CONVERSION): Test for language_objc.
	* language.c (binop_result_type): Handle language_objc case.
	(integral_type, character_type, string_type, boolean_type,
	structured_type, binop_type_check): Ditto.
	* symtab.h (SYMBOL_OBJC_DEMANGLED_NAME): Define.
	(struct objc_specific): Add to general_symbol_info.
	(SYMBOL_INIT_LANGUAGE_SPECIFIC): Add objc initialization.
	(SYMBOL_DEMANGLED_NAME): Handle objc case.
	* parser-defs.h (struct objc_class_str): New struct type.
	(start_msglist, end_msglist, add_msglist): Declaration only,
	exported from objc-lang.c.
	* value.h (value_of_local, value_nsstring,
	call_function_by_hand_expecting_type): Exported from valops.c.
	* valops.c (find_function_addr): Export.
	(call_function_by_hand_expecting_type): New function.
	(value_of_local): New function.
	* symfile.c (init_filename_language_table): Add ".m" extension
	for Objective-C.
	* utils.c (puts_filtered_tabular): New function.
	(fprintf_symbol_filtered): Add objc demangling support (disabled).
	(set/show demangle): Extend help-string to refer to ObjC.
	* elfread.c (elf_symtab_read): Skip Objective-C special symbols.
	* stabsread.c (symbol_reference_defined): Objective-C symbols
	may contain colons: make allowances when scanning stabs strings
	for colons.
	(objc_find_colon): New function.
	* printcmd.c (address_info): If language == objc then print
	"self" instead of "this".
	* parse.c (length_of_subexp): Handle new operators OP_MSGCALL,
	OP_NSSTRING, and OP_SELF.
	(prefixify_subexp): Ditto.
	* source.c (print_source_lines): Mention objc in comment.
	* breakpoint.c (parse_breakpoint_sals): Recognize Objective-C
	method names.
@
text
@a51 1
#include "completer.h" /* For skip_quoted().  */
@


1.12
log
@* ada-exp.y (yyname, yyrule): Remap global variables that appear
when YYDEBUG is set to 1.
* c-exp.y: Likewise.
* f-exp.y: Likewise.
* jv-exp.y: Likewise.
* m2-exp.y: Likewise.
* p-exp.y: Likewise.
@
text
@d52 1
@


1.12.2.1
log
@* c-exp.y: Add missing semi-colons.
* f-exp.y: Add missing semi-colons.
* m2-exp.y: Add missing semi-colons.
* p-exp.y: Add missing semi-colons.
Add empty action to start rule to avoid a type clash error when
building with bison >= 1.50.
@
text
@a249 1
	;
a252 1
	;
@


1.11
log
@2002-06-19  Pierre Muller  <muller@@ics.u-strasbg.fr>

	* parse.c (parse_fprintf): New function used to avoid calls to
	fprintf in bison parser generated debug code.
	* parser-defs.h: Declaration of new parse_fprintf function.
	* ada-exp.y, c-exp.y, f-exp.y, jv-exp.y, m2-exp.y, p-exp.y:
	Set YYDEBUG to 1 by default.
	Set YYFPRINTF as parse_fprintf.
@
text
@d92 2
@


1.10
log
@Expand preprocessor macros in C expressions.
* c-lang.h: #include "macroexp.h", for macro_lookup_ftype.
(scan_macro_expansion, scanning_macro_expansion,
finished_macro_expansion): New function declarations.
(expression_macro_lookup_func, expression_macro_lookup_baton): New
variable declarations.
* parser-defs.h (expression_context_pc): New declaration.
* parse.c (expression_context_pc): New variable.
(parse_exp_1): Set expression_context_pc, as well as
expression_context_block.
* c-exp.y (yylex): If we're not already reading the result of a
macro expansion, try to macro-expand the next token.  When we're
done scanning a macro expansion, switch back to the mainline text.
Commas and `if's in a macro's expansion don't terminate the input.
* c-lang.c: #include "macroscope.h" and "gdb_assert.h".
(macro_original_text, macro_expanded_text,
expression_macro_lookup_func, expression_macro_lookup_baton): New
variables.
(scan_macro_expansion, scanning_macro_expansion,
finished_macro_expansion, scan_macro_cleanup, null_macro_lookup,
c_preprocess_and_parse): New functions.
(c_language_defn, cplus_language_defn, asm_language_defn): Call
c_preprocess_and_parse, instead of c_parse.
* Makefile.in (c_lang_h): Note that this #includes macroexp.h.
(c-lang.o): Note dependency on macroscope.h and gdb_assert.h.
@
text
@d103 1
a103 1
#define	YYDEBUG	0		/* Default to no yydebug support */
d105 2
@


1.10.2.1
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d103 1
a103 1
#define	YYDEBUG 1		/* Default to yydebug support */
a104 2

#define YYFPRINTF parser_fprintf
@


1.10.2.2
log
@Merge with kseitz_interps-20020930-merge.
@
text
@a51 1
#include "charset.h"
a91 2
#define yyname	c_name		/* With YYDEBUG defined */
#define yyrule	c_rule		/* With YYDEBUG defined */
a1314 9
      else if (! host_char_to_target (c, &c))
        {
          int toklen = lexptr - tokstart + 1;
          char *tok = alloca (toklen + 1);
          memcpy (tok, tokstart, toklen);
          tok[toklen] = '\0';
          error ("There is no character corresponding to %s in the target "
                 "character set `%s'.", tok, target_charset ());
        }
a1464 2
        char *char_start_pos = tokptr;

d1487 1
a1487 13
	    c = *tokptr++;
            if (! host_char_to_target (c, &c))
              {
                int len = tokptr - char_start_pos;
                char *copy = alloca (len + 1);
                memcpy (copy, char_start_pos, len);
                copy[len] = '\0';

                error ("There is no character corresponding to `%s' "
                       "in the target character set `%s'.",
                       copy, target_charset ());
              }
            tempbuf[tempbufindex++] = c;
@


1.10.2.3
log
@merge from mainline
@
text
@d202 1
d535 5
d1618 11
@


1.9
log
@2002-04-24  Michael Snyder  <msnyder@@redhat.com>

	* parser-defs.h (prev_lexptr): New external variable.
	* parse.c (parse_exp_1): Set prev_lexptr to null before
	calling the language-specific parser.
	* c-exp.y (yylex): Set prev_lexptr to start of current token.
	(yyerror): Use prev_lexptr in error reporting.
@
text
@d1249 11
d1285 11
a1295 1
      return 0;
d1348 3
a1350 1
      if (comma_terminates && paren_depth == 0)
d1529 7
a1535 3
  /* The token "if" terminates the expression and is NOT 
     removed from the input stream.  */
  if (namelen == 2 && tokstart[0] == 'i' && tokstart[1] == 'f')
@


1.9.4.1
log
@merge from trunk
@
text
@a1248 11
  /* Check if this is a macro invocation that we need to expand.  */
  if (! scanning_macro_expansion ())
    {
      char *expanded = macro_expand_next (&lexptr,
                                          expression_macro_lookup_func,
                                          expression_macro_lookup_baton);

      if (expanded)
        scan_macro_expansion (expanded);
    }

d1274 1
a1274 11
      /* If we were just scanning the result of a macro expansion,
         then we need to resume scanning the original text.
         Otherwise, we were already scanning the original text, and
         we're really done.  */
      if (scanning_macro_expansion ())
        {
          finished_macro_expansion ();
          goto retry;
        }
      else
        return 0;
d1327 1
a1327 3
      if (comma_terminates
          && paren_depth == 0
          && ! scanning_macro_expansion ())
d1506 3
a1508 7
  /* The token "if" terminates the expression and is NOT removed from
     the input stream.  It doesn't count if it appears in the
     expansion of a macro.  */
  if (namelen == 2
      && tokstart[0] == 'i'
      && tokstart[1] == 'f'
      && ! scanning_macro_expansion ())
@


1.9.4.2
log
@More merging.
@
text
@d103 1
a103 1
#define	YYDEBUG 1		/* Default to yydebug support */
a104 2

#define YYFPRINTF parser_fprintf
@


1.9.2.1
log
@Expand preprocessor macros in C expressions.
* c-lang.h: #include "macroexp.h", for macro_lookup_ftype.
(scan_macro_expansion, scanning_macro_expansion,
finished_macro_expansion): New function declarations.
(expression_macro_lookup_func, expression_macro_lookup_baton): New
variable declarations.
* parser-defs.h (expression_context_pc): New declaration.
* parse.c (expression_context_pc): New variable.
(parse_exp_1): Set expression_context_pc, as well as
expression_context_block.
* c-exp.y (yylex): If we're not already reading the result of a
macro expansion, try to macro-expand the next token.  When we're
done scanning a macro expansion, switch back to the mainline text.
Commas and `if's in a macro's expansion don't terminate the input.
* c-lang.c: #include "macroscope.h" and "gdb_assert.h".
(macro_original_text, macro_expanded_text,
expression_macro_lookup_func, expression_macro_lookup_baton): New
variables.
(scan_macro_expansion, scanning_macro_expansion,
finished_macro_expansion, scan_macro_cleanup, null_macro_lookup,
c_preprocess_and_parse): New functions.
(c_language_defn, cplus_language_defn, asm_language_defn): Call
c_preprocess_and_parse, instead of c_parse.
* Makefile.in (c_lang_h): Note that this #includes macroexp.h.
(c-lang.o): Note dependency on macroscope.h and gdb_assert.h.
@
text
@a1248 11
  /* Check if this is a macro invocation that we need to expand.  */
  if (! scanning_macro_expansion ())
    {
      char *expanded = macro_expand_next (&lexptr,
                                          expression_macro_lookup_func,
                                          expression_macro_lookup_baton);

      if (expanded)
        scan_macro_expansion (expanded);
    }

d1274 1
a1274 11
      /* If we were just scanning the result of a macro expansion,
         then we need to resume scanning the original text.
         Otherwise, we were already scanning the original text, and
         we're really done.  */
      if (scanning_macro_expansion ())
        {
          finished_macro_expansion ();
          goto retry;
        }
      else
        return 0;
d1327 1
a1327 3
      if (comma_terminates
          && paren_depth == 0
          && ! scanning_macro_expansion ())
d1506 3
a1508 7
  /* The token "if" terminates the expression and is NOT removed from
     the input stream.  It doesn't count if it appears in the
     expansion of a macro.  */
  if (namelen == 2
      && tokstart[0] == 'i'
      && tokstart[1] == 'f'
      && ! scanning_macro_expansion ())
@


1.8
log
@2002-04-22  H.J. Lu  (hjl@@gnu.org)

	* c-exp.y (typebase): Support

	[long|long long|short] [signed|unsigned] [int|]

	and

	signed [long|long long|short] int
@
text
@d1249 1
d1770 3
@


1.7
log
@2001-11-14  Michael Snyder  <msnyder@@redhat.com>
	Add address space identifiers to expression language for types.
	* c-exp.y (space_identifier, cv_with_space_id,
	const_or_volatile_or_space_identifier_noopt,
	const_or_volatile_or_space_identifier): New terminals.
	(ptype): Accept const_or_volatile_or_space_identifier.
	(typebase): Accept const_or_volatile_or_space_identifier.
	* c-typeprint.c (c_type_print_cv_qualifier): Rename to
	c_type_print_modifier.  Handle address space modified types.
	* gdbtypes.h (TYPE_FLAG_CODE_SPACE, TYPE_FLAG_DATA_SPACE):
	New type flags.
	(struct type): Add new field as_type for addr-space qualified types.
	(TYPE_AS_TYPE): New macro, retrieves the chain of types that are
	identical to this one except for address-space qualification.
	* gdbtypes.c (alloc_type): Initialize new field 'as_type'.
	(address_space_name_to_int): New function.
	(address_space_int_to_name): New function.
	(make_type_with_address_space): New function.
	(make_cv_type): Handle as_type field of new struct type object.
	* parse.c (check_type_stack_depth): New function.
	(push_type_address_space): New function.
	(follow_types): Handle types with address-space qualifier.
	* parser-defs.h (enum type_pieces): Add enum tp_space_identifier.
@
text
@d810 6
d818 4
d826 6
d836 4
d846 4
d851 4
@


1.6
log
@2001-09-20  Michael Snyder  <msnyder@@redhat.com>
	Changes by Daniel Berlin  <dan@@cgsoftware.com>, to support
	better parsing of const and volatile type expressions.
	* c-exp.y (const_and_volatile, const_or_volatile_noopt,
	const_or_volatile): New non-terminals.
	(ptype): Use new rule for const_or_volatile.
	(typebase): Use new rule for const_or_volatile_noopt.
	* parser-defs.h (enum type_pieces): New values tp_const, tp_volatile.
	* parse.c (follow_types): Handle tp_const and tp_volatile on the
        type stack: call make_cv_type to create new const/volatile type.
@
text
@d721 5
d727 2
a728 3
ptype	:	typebase
	|	ptype const_or_volatile abs_decl const_or_volatile
		{ $$ = follow_types ($1); }
d730 2
a731 2
const_and_volatile: 	CONST_KEYWORD VOLATILE_KEYWORD
	| 		VOLATILE_KEYWORD CONST_KEYWORD
d733 3
a735 6
const_or_volatile_noopt:  	const_and_volatile 
			{ push_type (tp_const); push_type (tp_volatile);}
	| 		CONST_KEYWORD
			{ push_type (tp_const);}
	| 		VOLATILE_KEYWORD
			{ push_type (tp_volatile); }
d737 4
a740 2
const_or_volatile: const_or_volatile_noopt
	| 
d742 1
d859 4
a862 2
	| const_or_volatile_noopt typebase { $$ = follow_types ($2); }
	| typebase const_or_volatile_noopt { $$ = follow_types ($1); }
d899 19
d1711 1
a1711 1
	return TYPENAME;
@


1.5
log
@2001-09-21  Michael Snyder  <msnyder@@redhat.com>

	* c-exp.y (typebase): Accept (signed long long) as a type expr.
@
text
@d723 1
a723 12
	/* "const" and "volatile" are curently ignored.  A type qualifier
	   before the type is currently handled in the typebase rule.
	   The reason for recognizing these here (shift/reduce conflicts)
	   might be obsolete now that some pointer to member rules have
	   been deleted.  */
	|	typebase CONST_KEYWORD
	|	typebase VOLATILE_KEYWORD
	|	typebase abs_decl
		{ $$ = follow_types ($1); }
	|	typebase CONST_KEYWORD abs_decl
		{ $$ = follow_types ($1); }
	|	typebase VOLATILE_KEYWORD abs_decl
d726 13
a738 1

d855 2
a856 5
	/* "const" and "volatile" are curently ignored.  A type qualifier
	   after the type is handled in the ptype rule.  I think these could
	   be too.  */
	|	CONST_KEYWORD typebase { $$ = $2; }
	|	VOLATILE_KEYWORD typebase { $$ = $2; }
@


1.4
log
@Update/correct copyright notices.
@
text
@d815 4
@


1.4.2.1
log
@Typesystem work initial import.
Note that this currently isn't building, i'm in the middle of converting make_function_type/lookup_function_type
@
text
@d2 2
a3 1
   Copyright (C) 1986, 1989, 1990, 1991, 1993, 1994, 1996, 1997
d52 3
a54 1
#include "inferior.h"
d103 1
a103 1
#define	YYDEBUG	1		/* Default to no yydebug support */
d653 1
a653 1
						 (struct type *) make_function_type (NULL, builtin_type_int, 0, NULL, 0),
d709 1
a709 1
						     (struct type *)make_function_type (NULL, builtin_type_int, 0, NULL, 0),
d1215 1
a1215 1
  switch ( (c = *tokstart))
a1546 92

      /* Some compilers generate a fully qualified name for a nested
         class. If the program counter is inside a nested class, no sym_class
         can be found for an expression like 'inner::x' as the full class name
         is like 'outer::inner'.
         
         If the program counter is within a function of a nested class,
         construct an expression as 'outer::inner::x' to find the sym_class.
      */   
      if (!sym_class && (*lexptr == ':') && (*(lexptr+1) == ':'))
      {
         char * symname, * last_colon;
         int fieldlen, tokenlen;

         symname = 0;

         /* Find the symbol name that can used to construct a full name. */
         if (yylval.ssym.sym != 0 &&
             (SYMBOL_CLASS (yylval.ssym.sym) == LOC_ARG ||
              SYMBOL_CLASS (yylval.ssym.sym) == LOC_LOCAL ||
              SYMBOL_CLASS (yylval.ssym.sym) == LOC_STATIC ||
              SYMBOL_CLASS (yylval.ssym.sym) == LOC_LOCAL_ARG ||
              SYMBOL_CLASS (yylval.ssym.sym) == LOC_REGISTER))
           {
             /* The previous token is a local variable or parameter. Use its
                type name to construct a full name. */
             symname = TYPE_TAG_NAME(SYMBOL_TYPE(yylval.ssym.sym));
           }
         else
           {
             /* Use the function name of the current program counter to
                construct a full name. */ 
             struct symbol * sym = find_pc_function(read_pc());
             if (sym)
               symname = SYMBOL_DEMANGLED_NAME(sym);
           }

         /* Find the last colon of yylval.sval.ptr. */
         last_colon = strrchr(yylval.sval.ptr, ':');

         /* If the symbol name is 'outer::inner::func', we need to check
            if yylval.sval.ptr points to 'inner::x'. I.e., the symbol name
            and yylval.sval.ptr must have a common nested class name 'inner'.
            must have a common class name 'inner'.
         */
         if (symname != 0 && *(--last_colon) == ':')
           {
             boolean found = false;
             char *cur_index, *fullname_index, *i;
             tokenlen = strlen(yylval.sval.ptr);
             /* Calculate the length of the field, e.g., ::x. */
             fieldlen = tokenlen - (last_colon - yylval.sval.ptr);


             /*Set the full name index to the beginning to the symbol name.*/
             fullname_index = symname;

             /* Search for the name after each '::' until a match is found. */
             for (cur_index = symname; !found && cur_index;)
             {
               /* Search for "::". */
               cur_index = strstr (cur_index, "::");

               /* Move the index after "::'. */
               if (cur_index)
	         {
		   cur_index += 2;

		   /* Compare the nested class names. */
		   if (!strncmp (cur_index, yylval.sval.ptr,
				 tokenlen - fieldlen))
		     {
		       /* Reconstruct the fully qualified name. */
		       char *fullname = alloca (strlen (symname) + fieldlen);
  
		       /* Copy 'outer::' to the full name. */
		       strncpy (fullname, fullname_index,
				(cur_index - fullname_index));
		       fullname[cur_index - fullname_index] = '\0';
  
		       /* Append 'inner::x' to the full name. */
		       strcat (fullname, yylval.sval.ptr);
		       sym_class = parse_nested_classes_for_hpacc (
                               fullname, strlen(fullname) - fieldlen,
                               &token_string, &class_prefix, &lexptr);
		       found = true;
		     }
		 }
	     }
	 }
      }

a1570 10

    /* If no symbol is found, and the symbol is within a class, try
       to look for the symbol one more time without checking if the name
       is a field of 'this'. */
    if ((*lexptr == ':') && (*(lexptr+1) == ':') && !sym && sym_class)
      sym = lookup_symbol (tmp, expression_context_block,
                           VAR_NAMESPACE,
                           (int *) NULL,
                           (struct symtab **) NULL);

a1662 3

                              /* Update tmp to be used in the next iteration.*/
				tmp = ncopy;
a1675 18

          /* If the best symbol found contains '::', the previous token is
             a local variable or parameter, and the type names of the current
             and the best symbol do not match, return NAME. */
	  if (yylval.ssym.sym)
          if (strstr (SYMBOL_NAME(best_sym), "::") != 0 &&
              (TYPE_CODE (SYMBOL_TYPE (yylval.ssym.sym)) == TYPE_CODE_STRUCT) &&
              (TYPE_CODE (SYMBOL_TYPE (best_sym)) == TYPE_CODE_STRUCT) &&
              (SYMBOL_CLASS (yylval.ssym.sym) == LOC_ARG ||
               SYMBOL_CLASS (yylval.ssym.sym) == LOC_LOCAL ||
               SYMBOL_CLASS (yylval.ssym.sym) == LOC_STATIC ||
               SYMBOL_CLASS (yylval.ssym.sym) == LOC_LOCAL_ARG ||
               SYMBOL_CLASS (yylval.ssym.sym) == LOC_REGISTER) &&
               strcmp (TYPE_TAG_NAME (SYMBOL_TYPE (yylval.ssym.sym)),
                    TYPE_TAG_NAME (SYMBOL_TYPE (best_sym))) != 0)
            {
              return NAME; 
            }
@


1.3
log
@C++ improvements
@
text
@d2 2
a3 1
   Copyright (C) 1986, 1989, 1990, 1991, 1993, 1994, 1996, 1997
@


1.2
log
@PARAMS removal.
@
text
@a1435 2
           if (hp_som_som_object_present)
             {
a1444 20
             }
           else
             { 
	       int i = namelen;
	       int nesting_level = 1;
	       while (tokstart[++i])
		 {
		   if (tokstart[i] == '<')
		     nesting_level++;
		   else if (tokstart[i] == '>')
		     {
		       if (--nesting_level == 0)
			 break;
		     }
		 }
	       if (tokstart[i] == '>')
		 namelen = i;
	       else
		 break;
	     }
@


1.1
log
@Initial revision
@
text
@d105 1
a105 2
int
yyparse PARAMS ((void));
d107 1
a107 2
static int
yylex PARAMS ((void));
d109 1
a109 2
void
yyerror PARAMS ((char *));
d144 1
a144 2
static int
parse_number PARAMS ((char *, int, int, YYSTYPE *));
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@

