head	1.10;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.8
	gdb_7_6-2013-04-26-release:1.8
	gdb_7_6-branch:1.8.0.2
	gdb_7_6-2013-03-12-branchpoint:1.8
	gdb_7_5_1-2012-11-29-release:1.6
	gdb_7_5-2012-08-17-release:1.6
	gdb_7_5-branch:1.6.0.2
	gdb_7_5-2012-07-18-branchpoint:1.6;
locks; strict;
comment	@ * @;


1.10
date	2013.08.16.04.30.23;	author kevinb;	state Exp;
branches;
next	1.9;

1.9
date	2013.05.04.06.14.53;	author kevinb;	state Exp;
branches;
next	1.8;

1.8
date	2013.01.01.06.32.50;	author brobecke;	state Exp;
branches;
next	1.7;

1.7
date	2012.11.09.19.58.00;	author tromey;	state Exp;
branches;
next	1.6;

1.6
date	2012.05.18.21.02.50;	author sergiodj;	state Exp;
branches;
next	1.5;

1.5
date	2012.05.16.14.35.06;	author macro;	state Exp;
branches;
next	1.4;

1.4
date	2012.03.02.00.06.13;	author jkratoch;	state Exp;
branches;
next	1.3;

1.3
date	2012.02.14.20.15.44;	author kevinb;	state Exp;
branches;
next	1.2;

1.2
date	2012.02.14.20.07.26;	author kevinb;	state Exp;
branches;
next	1.1;

1.1
date	2012.02.04.06.05.50;	author kevinb;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Make RL78_PC_REGNUM a pseudo-register in rl78-tdep.c.
@
text
@/* Target-dependent code for the Renesas RL78 for GDB, the GNU debugger.

   Copyright (C) 2011-2013 Free Software Foundation, Inc.

   Contributed by Red Hat, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "arch-utils.h"
#include "prologue-value.h"
#include "target.h"
#include "regcache.h"
#include "opcode/rl78.h"
#include "dis-asm.h"
#include "gdbtypes.h"
#include "frame.h"
#include "frame-unwind.h"
#include "frame-base.h"
#include "value.h"
#include "gdbcore.h"
#include "dwarf2-frame.h"
#include "reggroups.h"

#include "elf/rl78.h"
#include "elf-bfd.h"

/* Register Banks.  */

enum
{
  RL78_BANK0 = 0,
  RL78_BANK1 = 1,
  RL78_BANK2 = 2,
  RL78_BANK3 = 3,
  RL78_NUMBANKS = 4,
  RL78_REGS_PER_BANK = 8
};

/* Register Numbers.  */

enum
{
  /* All general purpose registers are 8 bits wide.  */
  RL78_RAW_BANK0_R0_REGNUM = 0,
  RL78_RAW_BANK0_R1_REGNUM,
  RL78_RAW_BANK0_R2_REGNUM,
  RL78_RAW_BANK0_R3_REGNUM,
  RL78_RAW_BANK0_R4_REGNUM,
  RL78_RAW_BANK0_R5_REGNUM,
  RL78_RAW_BANK0_R6_REGNUM,
  RL78_RAW_BANK0_R7_REGNUM,

  RL78_RAW_BANK1_R0_REGNUM,
  RL78_RAW_BANK1_R1_REGNUM,
  RL78_RAW_BANK1_R2_REGNUM,
  RL78_RAW_BANK1_R3_REGNUM,
  RL78_RAW_BANK1_R4_REGNUM,
  RL78_RAW_BANK1_R5_REGNUM,
  RL78_RAW_BANK1_R6_REGNUM,
  RL78_RAW_BANK1_R7_REGNUM,

  RL78_RAW_BANK2_R0_REGNUM,
  RL78_RAW_BANK2_R1_REGNUM,
  RL78_RAW_BANK2_R2_REGNUM,
  RL78_RAW_BANK2_R3_REGNUM,
  RL78_RAW_BANK2_R4_REGNUM,
  RL78_RAW_BANK2_R5_REGNUM,
  RL78_RAW_BANK2_R6_REGNUM,
  RL78_RAW_BANK2_R7_REGNUM,

  RL78_RAW_BANK3_R0_REGNUM,
  RL78_RAW_BANK3_R1_REGNUM,
  RL78_RAW_BANK3_R2_REGNUM,
  RL78_RAW_BANK3_R3_REGNUM,
  RL78_RAW_BANK3_R4_REGNUM,
  RL78_RAW_BANK3_R5_REGNUM,
  RL78_RAW_BANK3_R6_REGNUM,
  RL78_RAW_BANK3_R7_REGNUM,

  RL78_PSW_REGNUM,	/* 8 bits */
  RL78_ES_REGNUM,	/* 8 bits */
  RL78_CS_REGNUM,	/* 8 bits */
  RL78_RAW_PC_REGNUM,	/* 20 bits; we'll use 32 bits for it.  */

  /* Fixed address SFRs (some of those above are SFRs too.) */
  RL78_SPL_REGNUM,	/* 8 bits; lower half of SP */
  RL78_SPH_REGNUM,	/* 8 bits; upper half of SP */
  RL78_PMC_REGNUM,	/* 8 bits */
  RL78_MEM_REGNUM,	/* 8 bits ?? */

  RL78_NUM_REGS,

  /* Pseudo registers.  */
  RL78_PC_REGNUM = RL78_NUM_REGS,
  RL78_SP_REGNUM,

  RL78_X_REGNUM,
  RL78_A_REGNUM,
  RL78_C_REGNUM,
  RL78_B_REGNUM,
  RL78_E_REGNUM,
  RL78_D_REGNUM,
  RL78_L_REGNUM,
  RL78_H_REGNUM,

  RL78_AX_REGNUM,
  RL78_BC_REGNUM,
  RL78_DE_REGNUM,
  RL78_HL_REGNUM,

  RL78_BANK0_R0_REGNUM,
  RL78_BANK0_R1_REGNUM,
  RL78_BANK0_R2_REGNUM,
  RL78_BANK0_R3_REGNUM,
  RL78_BANK0_R4_REGNUM,
  RL78_BANK0_R5_REGNUM,
  RL78_BANK0_R6_REGNUM,
  RL78_BANK0_R7_REGNUM,

  RL78_BANK1_R0_REGNUM,
  RL78_BANK1_R1_REGNUM,
  RL78_BANK1_R2_REGNUM,
  RL78_BANK1_R3_REGNUM,
  RL78_BANK1_R4_REGNUM,
  RL78_BANK1_R5_REGNUM,
  RL78_BANK1_R6_REGNUM,
  RL78_BANK1_R7_REGNUM,

  RL78_BANK2_R0_REGNUM,
  RL78_BANK2_R1_REGNUM,
  RL78_BANK2_R2_REGNUM,
  RL78_BANK2_R3_REGNUM,
  RL78_BANK2_R4_REGNUM,
  RL78_BANK2_R5_REGNUM,
  RL78_BANK2_R6_REGNUM,
  RL78_BANK2_R7_REGNUM,

  RL78_BANK3_R0_REGNUM,
  RL78_BANK3_R1_REGNUM,
  RL78_BANK3_R2_REGNUM,
  RL78_BANK3_R3_REGNUM,
  RL78_BANK3_R4_REGNUM,
  RL78_BANK3_R5_REGNUM,
  RL78_BANK3_R6_REGNUM,
  RL78_BANK3_R7_REGNUM,

  RL78_BANK0_RP0_REGNUM,
  RL78_BANK0_RP1_REGNUM,
  RL78_BANK0_RP2_REGNUM,
  RL78_BANK0_RP3_REGNUM,

  RL78_BANK1_RP0_REGNUM,
  RL78_BANK1_RP1_REGNUM,
  RL78_BANK1_RP2_REGNUM,
  RL78_BANK1_RP3_REGNUM,

  RL78_BANK2_RP0_REGNUM,
  RL78_BANK2_RP1_REGNUM,
  RL78_BANK2_RP2_REGNUM,
  RL78_BANK2_RP3_REGNUM,

  RL78_BANK3_RP0_REGNUM,
  RL78_BANK3_RP1_REGNUM,
  RL78_BANK3_RP2_REGNUM,
  RL78_BANK3_RP3_REGNUM,

  RL78_NUM_TOTAL_REGS,
  RL78_NUM_PSEUDO_REGS = RL78_NUM_TOTAL_REGS - RL78_NUM_REGS
};

/* Architecture specific data.  */

struct gdbarch_tdep
{
  /* The ELF header flags specify the multilib used.  */
  int elf_flags;

  struct type *rl78_void,
              *rl78_uint8,
	      *rl78_int8,
	      *rl78_uint16,
	      *rl78_int16,
	      *rl78_uint32,
	      *rl78_int32,
	      *rl78_data_pointer,
	      *rl78_code_pointer;
};

/* This structure holds the results of a prologue analysis.  */

struct rl78_prologue
{
  /* The offset from the frame base to the stack pointer --- always
     zero or negative.

     Calling this a "size" is a bit misleading, but given that the
     stack grows downwards, using offsets for everything keeps one
     from going completely sign-crazy: you never change anything's
     sign for an ADD instruction; always change the second operand's
     sign for a SUB instruction; and everything takes care of
     itself.  */
  int frame_size;

  /* Non-zero if this function has initialized the frame pointer from
     the stack pointer, zero otherwise.  */
  int has_frame_ptr;

  /* If has_frame_ptr is non-zero, this is the offset from the frame
     base to where the frame pointer points.  This is always zero or
     negative.  */
  int frame_ptr_offset;

  /* The address of the first instruction at which the frame has been
     set up and the arguments are where the debug info says they are
     --- as best as we can tell.  */
  CORE_ADDR prologue_end;

  /* reg_offset[R] is the offset from the CFA at which register R is
     saved, or 1 if register R has not been saved.  (Real values are
     always zero or negative.)  */
  int reg_offset[RL78_NUM_TOTAL_REGS];
};

/* Implement the "register_type" gdbarch method.  */

static struct type *
rl78_register_type (struct gdbarch *gdbarch, int reg_nr)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  if (reg_nr == RL78_PC_REGNUM)
    return tdep->rl78_code_pointer;
  else if (reg_nr == RL78_RAW_PC_REGNUM)
    return tdep->rl78_uint32;
  else if (reg_nr <= RL78_MEM_REGNUM
           || (RL78_X_REGNUM <= reg_nr && reg_nr <= RL78_H_REGNUM)
	   || (RL78_BANK0_R0_REGNUM <= reg_nr
	       && reg_nr <= RL78_BANK3_R7_REGNUM))
    return tdep->rl78_int8;
  else
    return tdep->rl78_data_pointer;
}

/* Implement the "register_name" gdbarch method.  */

static const char *
rl78_register_name (struct gdbarch *gdbarch, int regnr)
{
  static const char *const reg_names[] =
  {
    "",		/* bank0_r0 */
    "",		/* bank0_r1 */
    "",		/* bank0_r2 */
    "",		/* bank0_r3 */
    "",		/* bank0_r4 */
    "",		/* bank0_r5 */
    "",		/* bank0_r6 */
    "",		/* bank0_r7 */

    "",		/* bank1_r0 */
    "",		/* bank1_r1 */
    "",		/* bank1_r2 */
    "",		/* bank1_r3 */
    "",		/* bank1_r4 */
    "",		/* bank1_r5 */
    "",		/* bank1_r6 */
    "",		/* bank1_r7 */

    "",		/* bank2_r0 */
    "",		/* bank2_r1 */
    "",		/* bank2_r2 */
    "",		/* bank2_r3 */
    "",		/* bank2_r4 */
    "",		/* bank2_r5 */
    "",		/* bank2_r6 */
    "",		/* bank2_r7 */

    "",		/* bank3_r0 */
    "",		/* bank3_r1 */
    "",		/* bank3_r2 */
    "",		/* bank3_r3 */
    "",		/* bank3_r4 */
    "",		/* bank3_r5 */
    "",		/* bank3_r6 */
    "",		/* bank3_r7 */

    "psw",
    "es",
    "cs",
    "",

    "",		/* spl */
    "",		/* sph */
    "pmc",
    "mem",

    "pc",
    "sp",

    "x",
    "a",
    "c",
    "b",
    "e",
    "d",
    "l",
    "h",

    "ax",
    "bc",
    "de",
    "hl",

    "bank0_r0",
    "bank0_r1",
    "bank0_r2",
    "bank0_r3",
    "bank0_r4",
    "bank0_r5",
    "bank0_r6",
    "bank0_r7",

    "bank1_r0",
    "bank1_r1",
    "bank1_r2",
    "bank1_r3",
    "bank1_r4",
    "bank1_r5",
    "bank1_r6",
    "bank1_r7",

    "bank2_r0",
    "bank2_r1",
    "bank2_r2",
    "bank2_r3",
    "bank2_r4",
    "bank2_r5",
    "bank2_r6",
    "bank2_r7",

    "bank3_r0",
    "bank3_r1",
    "bank3_r2",
    "bank3_r3",
    "bank3_r4",
    "bank3_r5",
    "bank3_r6",
    "bank3_r7",

    "bank0_rp0",
    "bank0_rp1",
    "bank0_rp2",
    "bank0_rp3",

    "bank1_rp0",
    "bank1_rp1",
    "bank1_rp2",
    "bank1_rp3",

    "bank2_rp0",
    "bank2_rp1",
    "bank2_rp2",
    "bank2_rp3",

    "bank3_rp0",
    "bank3_rp1",
    "bank3_rp2",
    "bank3_rp3"
  };

  return reg_names[regnr];
}

/* Implement the "register_reggroup_p" gdbarch method.  */

static int
rl78_register_reggroup_p (struct gdbarch *gdbarch, int regnum,
			  struct reggroup *group)
{
  if (group == all_reggroup)
    return 1;

  /* All other registers are saved and restored.  */
  if (group == save_reggroup || group == restore_reggroup)
    {
      if ((regnum < RL78_NUM_REGS
	   && regnum != RL78_SPL_REGNUM
	   && regnum != RL78_SPH_REGNUM
	   && regnum != RL78_RAW_PC_REGNUM)
	  || regnum == RL78_SP_REGNUM
	  || regnum == RL78_PC_REGNUM)
	return 1;
      else
	return 0;
    }

  if ((RL78_BANK0_R0_REGNUM <= regnum && regnum <= RL78_BANK3_R7_REGNUM)
      || regnum == RL78_ES_REGNUM
      || regnum == RL78_CS_REGNUM
      || regnum == RL78_SPL_REGNUM
      || regnum == RL78_SPH_REGNUM
      || regnum == RL78_PMC_REGNUM
      || regnum == RL78_MEM_REGNUM
      || regnum == RL78_RAW_PC_REGNUM
      || (RL78_BANK0_RP0_REGNUM <= regnum && regnum <= RL78_BANK3_RP3_REGNUM))
    return group == system_reggroup;

  return group == general_reggroup;
}

/* Strip bits to form an instruction address.  (When fetching a
   32-bit address from the stack, the high eight bits are garbage.
   This function strips off those unused bits.)  */

static CORE_ADDR
rl78_make_instruction_address (CORE_ADDR addr)
{
  return addr & 0xffffff;
}

/* Set / clear bits necessary to make a data address.  */

static CORE_ADDR
rl78_make_data_address (CORE_ADDR addr)
{
  return (addr & 0xffff) | 0xf0000;
}

/* Implement the "pseudo_register_read" gdbarch method.  */

static enum register_status
rl78_pseudo_register_read (struct gdbarch *gdbarch,
                           struct regcache *regcache,
                           int reg, gdb_byte *buffer)
{
  enum register_status status;

  if (RL78_BANK0_R0_REGNUM <= reg && reg <= RL78_BANK3_R7_REGNUM)
    {
      int raw_regnum = RL78_RAW_BANK0_R0_REGNUM
                       + (reg - RL78_BANK0_R0_REGNUM);

      status = regcache_raw_read (regcache, raw_regnum, buffer);
    }
  else if (RL78_BANK0_RP0_REGNUM <= reg && reg <= RL78_BANK3_RP3_REGNUM)
    {
      int raw_regnum = 2 * (reg - RL78_BANK0_RP0_REGNUM)
                       + RL78_RAW_BANK0_R0_REGNUM;

      status = regcache_raw_read (regcache, raw_regnum, buffer);
      if (status == REG_VALID)
	status = regcache_raw_read (regcache, raw_regnum + 1, buffer + 1);
    }
  else if (reg == RL78_SP_REGNUM)
    {
      status = regcache_raw_read (regcache, RL78_SPL_REGNUM, buffer);
      if (status == REG_VALID)
	status = regcache_raw_read (regcache, RL78_SPH_REGNUM, buffer + 1);
    }
  else if (reg == RL78_PC_REGNUM)
    {
      gdb_byte rawbuf[4];

      status = regcache_raw_read (regcache, RL78_RAW_PC_REGNUM, rawbuf);
      memcpy (buffer, rawbuf, 3);
    }
  else if (RL78_X_REGNUM <= reg && reg <= RL78_H_REGNUM)
    {
      ULONGEST psw;

      status = regcache_raw_read_unsigned (regcache, RL78_PSW_REGNUM, &psw);
      if (status == REG_VALID)
	{
	  /* RSB0 is at bit 3; RSBS1 is at bit 5.  */
	  int bank = ((psw >> 3) & 1) | ((psw >> 4) & 1);
	  int raw_regnum = RL78_RAW_BANK0_R0_REGNUM + bank * RL78_REGS_PER_BANK
	                   + (reg - RL78_X_REGNUM);
	  status = regcache_raw_read (regcache, raw_regnum, buffer);
	}
    }
  else if (RL78_AX_REGNUM <= reg && reg <= RL78_HL_REGNUM)
    {
      ULONGEST psw;

      status = regcache_raw_read_unsigned (regcache, RL78_PSW_REGNUM, &psw);
      if (status == REG_VALID)
	{
	  /* RSB0 is at bit 3; RSBS1 is at bit 5.  */
	  int bank = ((psw >> 3) & 1) | ((psw >> 4) & 1);
	  int raw_regnum = RL78_RAW_BANK0_R0_REGNUM + bank * RL78_REGS_PER_BANK
	                   + 2 * (reg - RL78_AX_REGNUM);
	  status = regcache_raw_read (regcache, raw_regnum, buffer);
	  if (status == REG_VALID)
	    status = regcache_raw_read (regcache, raw_regnum + 1,
	                                buffer + 1);
	}
    }
  else
    gdb_assert_not_reached ("invalid pseudo register number");
  return status;
}

/* Implement the "pseudo_register_write" gdbarch method.  */

static void
rl78_pseudo_register_write (struct gdbarch *gdbarch,
                            struct regcache *regcache,
                            int reg, const gdb_byte *buffer)
{
  if (RL78_BANK0_R0_REGNUM <= reg && reg <= RL78_BANK3_R7_REGNUM)
    {
      int raw_regnum = RL78_RAW_BANK0_R0_REGNUM
                       + (reg - RL78_BANK0_R0_REGNUM);

      regcache_raw_write (regcache, raw_regnum, buffer);
    }
  else if (RL78_BANK0_RP0_REGNUM <= reg && reg <= RL78_BANK3_RP3_REGNUM)
    {
      int raw_regnum = 2 * (reg - RL78_BANK0_RP0_REGNUM)
                       + RL78_RAW_BANK0_R0_REGNUM;

      regcache_raw_write (regcache, raw_regnum, buffer);
      regcache_raw_write (regcache, raw_regnum + 1, buffer + 1);
    }
  else if (reg == RL78_SP_REGNUM)
    {
      regcache_raw_write (regcache, RL78_SPL_REGNUM, buffer);
      regcache_raw_write (regcache, RL78_SPH_REGNUM, buffer + 1);
    }
  else if (reg == RL78_PC_REGNUM)
    {
      gdb_byte rawbuf[4];

      memcpy (rawbuf, buffer, 3);
      rawbuf[3] = 0;
      regcache_raw_write (regcache, RL78_RAW_PC_REGNUM, rawbuf);
    }
  else if (RL78_X_REGNUM <= reg && reg <= RL78_H_REGNUM)
    {
      ULONGEST psw;
      int bank;
      int raw_regnum;

      regcache_raw_read_unsigned (regcache, RL78_PSW_REGNUM, &psw);
      bank = ((psw >> 3) & 1) | ((psw >> 4) & 1);
      /* RSB0 is at bit 3; RSBS1 is at bit 5.  */
      raw_regnum = RL78_RAW_BANK0_R0_REGNUM + bank * RL78_REGS_PER_BANK
	           + (reg - RL78_X_REGNUM);
      regcache_raw_write (regcache, raw_regnum, buffer);
    }
  else if (RL78_AX_REGNUM <= reg && reg <= RL78_HL_REGNUM)
    {
      ULONGEST psw;
      int bank, raw_regnum;

      regcache_raw_read_unsigned (regcache, RL78_PSW_REGNUM, &psw);
      bank = ((psw >> 3) & 1) | ((psw >> 4) & 1);
      /* RSB0 is at bit 3; RSBS1 is at bit 5.  */
      raw_regnum = RL78_RAW_BANK0_R0_REGNUM + bank * RL78_REGS_PER_BANK
		   + 2 * (reg - RL78_AX_REGNUM);
      regcache_raw_write (regcache, raw_regnum, buffer);
      regcache_raw_write (regcache, raw_regnum + 1, buffer + 1);
    }
  else
    gdb_assert_not_reached ("invalid pseudo register number");
}

/* Implement the "breakpoint_from_pc" gdbarch method.  */

static const gdb_byte *
rl78_breakpoint_from_pc (struct gdbarch *gdbarch, CORE_ADDR *pcptr,
                         int *lenptr)
{
  /* The documented BRK instruction is actually a two byte sequence,
     {0x61, 0xcc}, but instructions may be as short as one byte.
     Correspondence with Renesas revealed that the one byte sequence
     0xff is used when a one byte breakpoint instruction is required.  */
  static gdb_byte breakpoint[] = { 0xff };

  *lenptr = sizeof breakpoint;
  return breakpoint;
}

/* Define a "handle" struct for fetching the next opcode.  */

struct rl78_get_opcode_byte_handle
{
  CORE_ADDR pc;
};

/* Fetch a byte on behalf of the opcode decoder.  HANDLE contains
   the memory address of the next byte to fetch.  If successful,
   the address in the handle is updated and the byte fetched is
   returned as the value of the function.  If not successful, -1
   is returned.  */

static int
rl78_get_opcode_byte (void *handle)
{
  struct rl78_get_opcode_byte_handle *opcdata = handle;
  int status;
  gdb_byte byte;

  status = target_read_memory (opcdata->pc, &byte, 1);
  if (status == 0)
    {
      opcdata->pc += 1;
      return byte;
    }
  else
    return -1;
}

/* Function for finding saved registers in a 'struct pv_area'; this
   function is passed to pv_area_scan.

   If VALUE is a saved register, ADDR says it was saved at a constant
   offset from the frame base, and SIZE indicates that the whole
   register was saved, record its offset.  */

static void
check_for_saved (void *result_untyped, pv_t addr, CORE_ADDR size,
                 pv_t value)
{
  struct rl78_prologue *result = (struct rl78_prologue *) result_untyped;

  if (value.kind == pvk_register
      && value.k == 0
      && pv_is_register (addr, RL78_SP_REGNUM)
      && size == register_size (target_gdbarch (), value.reg))
    result->reg_offset[value.reg] = addr.k;
}

/* Analyze a prologue starting at START_PC, going no further than
   LIMIT_PC.  Fill in RESULT as appropriate.  */

static void
rl78_analyze_prologue (CORE_ADDR start_pc,
		       CORE_ADDR limit_pc, struct rl78_prologue *result)
{
  CORE_ADDR pc, next_pc;
  int rn;
  pv_t reg[RL78_NUM_TOTAL_REGS];
  struct pv_area *stack;
  struct cleanup *back_to;
  CORE_ADDR after_last_frame_setup_insn = start_pc;
  int bank = 0;

  memset (result, 0, sizeof (*result));

  for (rn = 0; rn < RL78_NUM_TOTAL_REGS; rn++)
    {
      reg[rn] = pv_register (rn, 0);
      result->reg_offset[rn] = 1;
    }

  stack = make_pv_area (RL78_SP_REGNUM, gdbarch_addr_bit (target_gdbarch ()));
  back_to = make_cleanup_free_pv_area (stack);

  /* The call instruction has saved the return address on the stack.  */
  reg[RL78_SP_REGNUM] = pv_add_constant (reg[RL78_SP_REGNUM], -4);
  pv_area_store (stack, reg[RL78_SP_REGNUM], 4, reg[RL78_PC_REGNUM]);

  pc = start_pc;
  while (pc < limit_pc)
    {
      int bytes_read;
      struct rl78_get_opcode_byte_handle opcode_handle;
      RL78_Opcode_Decoded opc;

      opcode_handle.pc = pc;
      bytes_read = rl78_decode_opcode (pc, &opc, rl78_get_opcode_byte,
				     &opcode_handle);
      next_pc = pc + bytes_read;

      if (opc.id == RLO_sel)
	{
	  bank = opc.op[1].addend;
	}
      else if (opc.id == RLO_mov
               && opc.op[0].type == RL78_Operand_PreDec
               && opc.op[0].reg == RL78_Reg_SP
	       && opc.op[1].type == RL78_Operand_Register)
	{
	  int rsrc = (bank * RL78_REGS_PER_BANK) 
	           + 2 * (opc.op[1].reg - RL78_Reg_AX);

	  reg[RL78_SP_REGNUM] = pv_add_constant (reg[RL78_SP_REGNUM], -1);
	  pv_area_store (stack, reg[RL78_SP_REGNUM], 1, reg[rsrc]);
	  reg[RL78_SP_REGNUM] = pv_add_constant (reg[RL78_SP_REGNUM], -1);
	  pv_area_store (stack, reg[RL78_SP_REGNUM], 1, reg[rsrc + 1]);
	  after_last_frame_setup_insn = next_pc;
	}
      else if (opc.id == RLO_sub
               && opc.op[0].type == RL78_Operand_Register
	       && opc.op[0].reg == RL78_Reg_SP
	       && opc.op[1].type == RL78_Operand_Immediate)
	{
	  int addend = opc.op[1].addend;

	  reg[RL78_SP_REGNUM] = pv_add_constant (reg[RL78_SP_REGNUM],
	                                         -addend);
	  after_last_frame_setup_insn = next_pc;
	}
      else
	{
	  /* Terminate the prologue scan.  */
	  break;
	}

      pc = next_pc;
    }

  /* Is the frame size (offset, really) a known constant?  */
  if (pv_is_register (reg[RL78_SP_REGNUM], RL78_SP_REGNUM))
    result->frame_size = reg[RL78_SP_REGNUM].k;

  /* Record where all the registers were saved.  */
  pv_area_scan (stack, check_for_saved, (void *) result);

  result->prologue_end = after_last_frame_setup_insn;

  do_cleanups (back_to);
}

/* Implement the "addr_bits_remove" gdbarch method.  */

static CORE_ADDR
rl78_addr_bits_remove (struct gdbarch *gdbarch, CORE_ADDR addr)
{
  return addr & 0xffffff;
}

/* Implement the "address_to_pointer" gdbarch method.  */

static void
rl78_address_to_pointer (struct gdbarch *gdbarch,
			 struct type *type, gdb_byte *buf, CORE_ADDR addr)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);

  store_unsigned_integer (buf, TYPE_LENGTH (type), byte_order,
                          addr & 0xffffff);
}

/* Implement the "pointer_to_address" gdbarch method.  */

static CORE_ADDR
rl78_pointer_to_address (struct gdbarch *gdbarch,
                         struct type *type, const gdb_byte *buf)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  CORE_ADDR addr
    = extract_unsigned_integer (buf, TYPE_LENGTH (type), byte_order);

  /* Is it a code address?  */
  if (TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_FUNC
      || TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_METHOD
      || TYPE_CODE_SPACE (TYPE_TARGET_TYPE (type))
      || TYPE_LENGTH (type) == 4)
    return rl78_make_instruction_address (addr);
  else
    return rl78_make_data_address (addr);
}

/* Implement the "skip_prologue" gdbarch method.  */

static CORE_ADDR
rl78_skip_prologue (struct gdbarch *gdbarch, CORE_ADDR pc)
{
  const char *name;
  CORE_ADDR func_addr, func_end;
  struct rl78_prologue p;

  /* Try to find the extent of the function that contains PC.  */
  if (!find_pc_partial_function (pc, &name, &func_addr, &func_end))
    return pc;

  rl78_analyze_prologue (pc, func_end, &p);
  return p.prologue_end;
}

/* Implement the "unwind_pc" gdbarch method.  */

static CORE_ADDR
rl78_unwind_pc (struct gdbarch *arch, struct frame_info *next_frame)
{
  return rl78_addr_bits_remove
           (arch, frame_unwind_register_unsigned (next_frame,
	                                          RL78_PC_REGNUM));
}

/* Implement the "unwind_sp" gdbarch method.  */

static CORE_ADDR
rl78_unwind_sp (struct gdbarch *arch, struct frame_info *next_frame)
{
  return frame_unwind_register_unsigned (next_frame, RL78_SP_REGNUM);
}

/* Given a frame described by THIS_FRAME, decode the prologue of its
   associated function if there is not cache entry as specified by
   THIS_PROLOGUE_CACHE.  Save the decoded prologue in the cache and
   return that struct as the value of this function.  */

static struct rl78_prologue *
rl78_analyze_frame_prologue (struct frame_info *this_frame,
			   void **this_prologue_cache)
{
  if (!*this_prologue_cache)
    {
      CORE_ADDR func_start, stop_addr;

      *this_prologue_cache = FRAME_OBSTACK_ZALLOC (struct rl78_prologue);

      func_start = get_frame_func (this_frame);
      stop_addr = get_frame_pc (this_frame);

      /* If we couldn't find any function containing the PC, then
         just initialize the prologue cache, but don't do anything.  */
      if (!func_start)
	stop_addr = func_start;

      rl78_analyze_prologue (func_start, stop_addr, *this_prologue_cache);
    }

  return *this_prologue_cache;
}

/* Given a frame and a prologue cache, return this frame's base.  */

static CORE_ADDR
rl78_frame_base (struct frame_info *this_frame, void **this_prologue_cache)
{
  struct rl78_prologue *p
    = rl78_analyze_frame_prologue (this_frame, this_prologue_cache);
  CORE_ADDR sp = get_frame_register_unsigned (this_frame, RL78_SP_REGNUM);

  return rl78_make_data_address (sp - p->frame_size);
}

/* Implement the "frame_this_id" method for unwinding frames.  */

static void
rl78_this_id (struct frame_info *this_frame,
	      void **this_prologue_cache, struct frame_id *this_id)
{
  *this_id = frame_id_build (rl78_frame_base (this_frame,
                                              this_prologue_cache),
			     get_frame_func (this_frame));
}

/* Implement the "frame_prev_register" method for unwinding frames.  */

static struct value *
rl78_prev_register (struct frame_info *this_frame,
                    void **this_prologue_cache, int regnum)
{
  struct rl78_prologue *p
    = rl78_analyze_frame_prologue (this_frame, this_prologue_cache);
  CORE_ADDR frame_base = rl78_frame_base (this_frame, this_prologue_cache);

  if (regnum == RL78_SP_REGNUM)
    return frame_unwind_got_constant (this_frame, regnum, frame_base);

  else if (regnum == RL78_SPL_REGNUM)
    return frame_unwind_got_constant (this_frame, regnum,
                                      (frame_base & 0xff));

  else if (regnum == RL78_SPH_REGNUM)
    return frame_unwind_got_constant (this_frame, regnum,
                                      ((frame_base >> 8) & 0xff));

  /* If prologue analysis says we saved this register somewhere,
     return a description of the stack slot holding it.  */
  else if (p->reg_offset[regnum] != 1)
    {
      struct value *rv =
        frame_unwind_got_memory (this_frame, regnum,
				 frame_base + p->reg_offset[regnum]);

      if (regnum == RL78_PC_REGNUM)
	{
	  ULONGEST pc = rl78_make_instruction_address (value_as_long (rv));

	  return frame_unwind_got_constant (this_frame, regnum, pc);
	}
      return rv;
    }

  /* Otherwise, presume we haven't changed the value of this
     register, and get it from the next frame.  */
  else
    return frame_unwind_got_register (this_frame, regnum, regnum);
}

static const struct frame_unwind rl78_unwind =
{
  NORMAL_FRAME,
  default_frame_unwind_stop_reason,
  rl78_this_id,
  rl78_prev_register,
  NULL,
  default_frame_sniffer
};

/* Implement the "dwarf_reg_to_regnum" gdbarch method.  */

static int
rl78_dwarf_reg_to_regnum (struct gdbarch *gdbarch, int reg)
{
  if (0 <= reg && reg <= 31)
    {
      if ((reg & 1) == 0)
        /* Map even registers to their 16-bit counterparts.  This
	   is usually what is required from the DWARF info.  */
	return (reg >> 1) + RL78_BANK0_RP0_REGNUM;
      else
	return reg;
    }
  else if (reg == 32)
    return RL78_SP_REGNUM;
  else if (reg == 33)
    return -1;			/* ap */
  else if (reg == 34)
    return RL78_PSW_REGNUM;
  else if (reg == 35)
    return RL78_ES_REGNUM;
  else if (reg == 36)
    return RL78_CS_REGNUM;
  else if (reg == 37)
    return RL78_PC_REGNUM;
  else
    internal_error (__FILE__, __LINE__,
                    _("Undefined dwarf2 register mapping of reg %d"),
		    reg);
}

/* Implement the `register_sim_regno' gdbarch method.  */

static int
rl78_register_sim_regno (struct gdbarch *gdbarch, int regnum)
{
  gdb_assert (regnum < RL78_NUM_REGS);

  /* So long as regnum is in [0, RL78_NUM_REGS), it's valid.  We
     just want to override the default here which disallows register
     numbers which have no names.  */
  return regnum;
}

/* Implement the "return_value" gdbarch method.  */

static enum return_value_convention
rl78_return_value (struct gdbarch *gdbarch,
		   struct value *function,
		   struct type *valtype,
		   struct regcache *regcache,
		   gdb_byte *readbuf, const gdb_byte *writebuf)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  ULONGEST valtype_len = TYPE_LENGTH (valtype);

  if (valtype_len > 8)
    return RETURN_VALUE_STRUCT_CONVENTION;

  if (readbuf)
    {
      ULONGEST u;
      int argreg = RL78_RAW_BANK1_R0_REGNUM;
      int offset = 0;

      while (valtype_len > 0)
	{
	  regcache_cooked_read_unsigned (regcache, argreg, &u);
	  store_unsigned_integer (readbuf + offset, 1, byte_order, u);
	  valtype_len -= 1;
	  offset += 1;
	  argreg++;
	}
    }

  if (writebuf)
    {
      ULONGEST u;
      int argreg = RL78_RAW_BANK1_R0_REGNUM;
      int offset = 0;

      while (valtype_len > 0)
	{
	  u = extract_unsigned_integer (writebuf + offset, 1, byte_order);
	  regcache_cooked_write_unsigned (regcache, argreg, u);
	  valtype_len -= 1;
	  offset += 1;
	  argreg++;
	}
    }

  return RETURN_VALUE_REGISTER_CONVENTION;
}


/* Implement the "frame_align" gdbarch method.  */

static CORE_ADDR
rl78_frame_align (struct gdbarch *gdbarch, CORE_ADDR sp)
{
  return rl78_make_data_address (align_down (sp, 2));
}


/* Implement the "dummy_id" gdbarch method.  */

static struct frame_id
rl78_dummy_id (struct gdbarch *gdbarch, struct frame_info *this_frame)
{
  return
    frame_id_build (rl78_make_data_address
                      (get_frame_register_unsigned
		        (this_frame, RL78_SP_REGNUM)),
		    get_frame_pc (this_frame));
}


/* Implement the "push_dummy_call" gdbarch method.  */

static CORE_ADDR
rl78_push_dummy_call (struct gdbarch *gdbarch, struct value *function,
		      struct regcache *regcache, CORE_ADDR bp_addr,
		      int nargs, struct value **args, CORE_ADDR sp,
		      int struct_return, CORE_ADDR struct_addr)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  gdb_byte buf[4];
  int i;

  /* Push arguments in reverse order.  */
  for (i = nargs - 1; i >= 0; i--)
    {
      struct type *value_type = value_enclosing_type (args[i]);
      int len = TYPE_LENGTH (value_type);
      int container_len = (len + 1) & ~1;

      sp -= container_len;
      write_memory (rl78_make_data_address (sp),
                    value_contents_all (args[i]), len);
    }

  /* Store struct value address.  */
  if (struct_return)
    {
      store_unsigned_integer (buf, 2, byte_order, struct_addr);
      sp -= 2;
      write_memory (rl78_make_data_address (sp), buf, 2);
    }

  /* Store return address.  */
  sp -= 4;
  store_unsigned_integer (buf, 4, byte_order, bp_addr);
  write_memory (rl78_make_data_address (sp), buf, 4);

  /* Finally, update the stack pointer...  */
  regcache_cooked_write_unsigned (regcache, RL78_SP_REGNUM, sp);

  /* DWARF2/GCC uses the stack address *before* the function call as a
     frame's CFA.  */
  return rl78_make_data_address (sp + 4);
}

/* Allocate and initialize a gdbarch object.  */

static struct gdbarch *
rl78_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
{
  struct gdbarch *gdbarch;
  struct gdbarch_tdep *tdep;
  int elf_flags;

  /* Extract the elf_flags if available.  */
  if (info.abfd != NULL
      && bfd_get_flavour (info.abfd) == bfd_target_elf_flavour)
    elf_flags = elf_elfheader (info.abfd)->e_flags;
  else
    elf_flags = 0;


  /* Try to find the architecture in the list of already defined
     architectures.  */
  for (arches = gdbarch_list_lookup_by_info (arches, &info);
       arches != NULL;
       arches = gdbarch_list_lookup_by_info (arches->next, &info))
    {
      if (gdbarch_tdep (arches->gdbarch)->elf_flags != elf_flags)
	continue;

      return arches->gdbarch;
    }

  /* None found, create a new architecture from the information
     provided.  */
  tdep = (struct gdbarch_tdep *) xmalloc (sizeof (struct gdbarch_tdep));
  gdbarch = gdbarch_alloc (&info, tdep);
  tdep->elf_flags = elf_flags;

  /* Initialize types.  */
  tdep->rl78_void = arch_type (gdbarch, TYPE_CODE_VOID, 1, "void");
  tdep->rl78_uint8 = arch_integer_type (gdbarch, 8, 1, "uint8_t");
  tdep->rl78_int8 = arch_integer_type (gdbarch, 8, 0, "int8_t");
  tdep->rl78_uint16 = arch_integer_type (gdbarch, 16, 1, "uint16_t");
  tdep->rl78_int16 = arch_integer_type (gdbarch, 16, 0, "int16_t");
  tdep->rl78_uint32 = arch_integer_type (gdbarch, 32, 1, "uint32_t");
  tdep->rl78_int32 = arch_integer_type (gdbarch, 32, 0, "int32_t");

  tdep->rl78_data_pointer
    = arch_type (gdbarch, TYPE_CODE_PTR, 16 / TARGET_CHAR_BIT,
                 xstrdup ("rl78_data_addr_t"));
  TYPE_TARGET_TYPE (tdep->rl78_data_pointer) = tdep->rl78_void;
  TYPE_UNSIGNED (tdep->rl78_data_pointer) = 1;

  tdep->rl78_code_pointer
    = arch_type (gdbarch, TYPE_CODE_PTR, 32 / TARGET_CHAR_BIT,
                 xstrdup ("rl78_code_addr_t"));
  TYPE_TARGET_TYPE (tdep->rl78_code_pointer) = tdep->rl78_void;
  TYPE_UNSIGNED (tdep->rl78_code_pointer) = 1;

  /* Registers.  */
  set_gdbarch_num_regs (gdbarch, RL78_NUM_REGS);
  set_gdbarch_num_pseudo_regs (gdbarch, RL78_NUM_PSEUDO_REGS);
  set_gdbarch_register_name (gdbarch, rl78_register_name);
  set_gdbarch_register_type (gdbarch, rl78_register_type);
  set_gdbarch_pc_regnum (gdbarch, RL78_PC_REGNUM);
  set_gdbarch_sp_regnum (gdbarch, RL78_SP_REGNUM);
  set_gdbarch_pseudo_register_read (gdbarch, rl78_pseudo_register_read);
  set_gdbarch_pseudo_register_write (gdbarch, rl78_pseudo_register_write);
  set_gdbarch_dwarf2_reg_to_regnum (gdbarch, rl78_dwarf_reg_to_regnum);
  set_gdbarch_register_reggroup_p (gdbarch, rl78_register_reggroup_p);
  set_gdbarch_register_sim_regno (gdbarch, rl78_register_sim_regno);

  /* Data types.  */
  set_gdbarch_char_signed (gdbarch, 0);
  set_gdbarch_short_bit (gdbarch, 16);
  set_gdbarch_int_bit (gdbarch, 16);
  set_gdbarch_long_bit (gdbarch, 32);
  set_gdbarch_long_long_bit (gdbarch, 64);
  set_gdbarch_ptr_bit (gdbarch, 16);
  set_gdbarch_addr_bit (gdbarch, 32);
  set_gdbarch_dwarf2_addr_size (gdbarch, 4);
  set_gdbarch_float_bit (gdbarch, 32);
  set_gdbarch_float_format (gdbarch, floatformats_ieee_single);
  set_gdbarch_double_bit (gdbarch, 32);
  set_gdbarch_long_double_bit (gdbarch, 64);
  set_gdbarch_double_format (gdbarch, floatformats_ieee_single);
  set_gdbarch_long_double_format (gdbarch, floatformats_ieee_double);
  set_gdbarch_pointer_to_address (gdbarch, rl78_pointer_to_address);
  set_gdbarch_address_to_pointer (gdbarch, rl78_address_to_pointer);
  set_gdbarch_addr_bits_remove (gdbarch, rl78_addr_bits_remove);

  /* Breakpoints.  */
  set_gdbarch_breakpoint_from_pc (gdbarch, rl78_breakpoint_from_pc);
  set_gdbarch_decr_pc_after_break (gdbarch, 1);

  /* Disassembly.  */
  set_gdbarch_print_insn (gdbarch, print_insn_rl78);

  /* Frames, prologues, etc.  */
  set_gdbarch_inner_than (gdbarch, core_addr_lessthan);
  set_gdbarch_skip_prologue (gdbarch, rl78_skip_prologue);
  set_gdbarch_unwind_pc (gdbarch, rl78_unwind_pc);
  set_gdbarch_unwind_sp (gdbarch, rl78_unwind_sp);
  set_gdbarch_frame_align (gdbarch, rl78_frame_align);

  dwarf2_append_unwinders (gdbarch);
  frame_unwind_append_unwinder (gdbarch, &rl78_unwind);

  /* Dummy frames, return values.  */
  set_gdbarch_dummy_id (gdbarch, rl78_dummy_id);
  set_gdbarch_push_dummy_call (gdbarch, rl78_push_dummy_call);
  set_gdbarch_return_value (gdbarch, rl78_return_value);

  /* Virtual tables.  */
  set_gdbarch_vbit_in_delta (gdbarch, 1);

  return gdbarch;
}

/* -Wmissing-prototypes */
extern initialize_file_ftype _initialize_rl78_tdep;

/* Register the above initialization routine.  */

void
_initialize_rl78_tdep (void)
{
  register_gdbarch_init (bfd_arch_rl78, rl78_gdbarch_init);
}
@


1.9
log
@	* rl78-tdep.c (rl78_register_reggroup_p): Include SP in the
	`save' and `restore' register groups.  Don't include SPL
	or SPH in these groups.
	(rl78_dwarf_reg_to_regnum):  Adjust mapping for
	RL78_PC_REGNUM.  Add mappings for RL78_PSW_REGNUM,
	RL78_ES_REGNUM, and RL78_CS_REGNUM.
	(rl78_gdbarch_init): Set `dwarf2_addr_size' to 4.  Invoke
	dwarf2_append_unwinders().
@
text
@d97 1
a97 1
  RL78_PC_REGNUM,	/* 20 bits; we'll use 32 bits for it.  */
d108 2
a109 1
  RL78_SP_REGNUM = RL78_NUM_REGS,
d247 2
d304 1
a304 1
    "pc",
d311 1
d401 5
a405 3
           && regnum != RL78_SPL_REGNUM
	   && regnum != RL78_SPH_REGNUM)
          || regnum == RL78_SP_REGNUM)
d418 1
d474 7
d544 8
@


1.8
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d396 4
a399 1
      if (regnum < RL78_NUM_REGS)
d916 8
d1139 1
d1163 2
@


1.7
log
@	* gdbarch.sh (target_gdbarch): Remove macro.
	(get_target_gdbarch): Rename to target_gdbarch.
	* gdbarch.c, gdbarch.h: Rebuild.
	* ada-tasks.c, aix-thread.c, amd64-linux-nat.c, arch-utils.c,
	arm-tdep.c, auxv.c, breakpoint.c, bsd-uthread.c, corefile.c,
	darwin-nat-info.c, dcache.c, dsrec.c, exec.c, fbsd-nat.c,
	filesystem.c, gcore.c, gnu-nat.c, i386-darwin-nat.c, i386-nat.c,
	ia64-vms-tdep.c, inf-ptrace.c, infcmd.c, jit.c, linux-nat.c,
	linux-tdep.c, linux-thread-db.c, m32r-rom.c, memattr.c,
	mep-tdep.c, microblaze-tdep.c, mips-linux-nat.c,
	mips-linux-tdep.c, mips-tdep.c, monitor.c, moxie-tdep.c,
	nto-procfs.c, nto-tdep.c, ppc-linux-nat.c, proc-service.c,
	procfs.c, progspace.c, ravenscar-thread.c, record.c,
	remote-m32r-sdi.c, remote-mips.c, remote-sim.c, remote.c,
	rl78-tdep.c, rs6000-nat.c, rx-tdep.c, s390-nat.c, sol-thread.c,
	solib-darwin.c, solib-dsbt.c, solib-frv.c, solib-ia64-hpux.c,
	solib-irix.c, solib-pa64.c, solib-som.c, solib-spu.c,
	solib-sunos.c, solib-svr4.c, solib.c, spu-linux-nat.c,
	spu-multiarch.c, spu-tdep.c, symfile-mem.c, symfile.c, symtab.c,
	target-descriptions.c, target.c, target.h, tracepoint.c,
	windows-nat.c, windows-tdep.c, xcoffsolib.c, cli/cli-dump.c,
	common/agent.c, mi/mi-interp.c, python/py-finishbreakpoint.c,
	python/py-inferior.c, python/python.c: Update.
@
text
@d3 1
a3 1
   Copyright (C) 2011-2012 Free Software Foundation, Inc.
@


1.6
log
@2012-05-18  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c:
	* avr-tdep.c:
	* ax-gdb.c:
	* bfin-linux-tdep.c:
	* breakpoint.c:
	* c-valprint.c:
	* cli/cli-cmds.c:
	* coffread.c:
	* cp-support.c:
	* cris-tdep.c:
	* dwarf2-frame-tailcall.c:
	* dwarf2-frame.c:
	* dwarf2expr.c:
	* dwarf2loc.c:
	* dwarf2read.c:
	* elfread.c:
	* eval.c:
	* expprint.c:
	* f-valprint.c:
	* frv-tdep.c:
	* h8300-tdep.c:
	* hppa-hpux-tdep.c:
	* hppa-tdep.c:
	* hppanbsd-tdep.c:
	* i386-nto-tdep.c:
	* i386-tdep.c:
	* i387-tdep.c:
	* ia64-tdep.c:
	* jit.c:
	* linespec.c:
	* linux-tdep.c:
	* lm32-tdep.c:
	* m2-valprint.c:
	* m32c-tdep.c:
	* m32r-rom.c:
	* m32r-tdep.c:
	* m68k-tdep.c:
	* m68klinux-tdep.c:
	* mi/mi-main.c:
	* microblaze-tdep.c:
	* mips-linux-tdep.c:
	* mips-tdep.c:
	* mn10300-tdep.c:
	* p-valprint.c:
	* parse.c:
	* ppc-linux-tdep.c:
	* ppc-sysv-tdep.c:
	* printcmd.c:
	* python/py-finishbreakpoint.c:
	* python/py-inferior.c:
	* python/py-infthread.c:
	* python/py-type.c:
	* python/python.c:
	* remote-fileio.c:
	* remote-m32r-sdi.c:
	* remote-mips.c:
	* reverse.c:
	* rl78-tdep.c:
	* rs6000-aix-tdep.c:
	* rs6000-tdep.c:
	* s390-tdep.c:
	* score-tdep.c:
	* sh64-tdep.c:
	* skip.c:
	* solib-darwin.c:
	* solib-dsbt.c:
	* solib-frv.c:
	* sparc-tdep.c:
	* spu-multiarch.c:
	* spu-tdep.c:
	* stack.c:
	* symfile.c:
	* symtab.c:
	* tic6x-tdep.c:
	* tracepoint.c:
	* v850-tdep.c:
	* valarith.c:
	* valprint.c:
	* value.c:
	* xcoffread.c:
	* xtensa-tdep.c:
	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c: Delete unused variables.
@
text
@d619 1
a619 1
      && size == register_size (target_gdbarch, value.reg))
d646 1
a646 1
  stack = make_pv_area (RL78_SP_REGNUM, gdbarch_addr_bit (target_gdbarch));
@


1.5
log
@	gdb/
	* breakpoint.h (bp_location): Add related_address member.
	* inferior.h (get_return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	* value.h (using_struct_return): Likewise.
	* gdbarch.sh (return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	* breakpoint.c (set_breakpoint_location_function): Initialize
	related_address for bp_gnu_ifunc_resolver breakpoints.
	* elfread.c (elf_gnu_ifunc_resolver_return_stop): Pass the
	requested function's address to gdbarch_return_value.
	* eval.c (evaluate_subexp_standard): Pass the requested
	function's address to using_struct_return.
	* infcall.c (call_function_by_hand): Pass the requested
	function's address to using_struct_return and
	gdbarch_return_value.
	* infcmd.c (get_return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	(print_return_value): Update accordingly.
	(finish_command_continuation): Likewise.
	* stack.c (return_command): Pass the requested function's
	address to using_struct_return and gdbarch_return_value.
	* value.c (using_struct_return): Take a pointer to struct value
	instead of struct type for the function requested.  Pass the
	requested function's address to gdbarch_return_value.
	* python/py-finishbreakpoint.c (finish_breakpoint_object):
	New function_value member, replacing function_type.
	(bpfinishpy_dealloc): Update accordingly.
	(bpfinishpy_pre_stop_hook): Likewise.
	(bpfinishpy_init): Likewise.  Record the requested function's
	address.
	* mips-tdep.c (mips_fval_reg): New enum.
	(mips_o32_push_dummy_call): For MIPS16 FP doubles do not swap
	words put in GP registers.
	(mips_o64_push_dummy_call): Update a comment.
	(mips_o32_return_value): Take a pointer to struct value instead
	of struct type for the function requested and use it to check if
	using the MIPS16 calling convention.  Return the designated
	general purpose registers for floating-point values returned in
	MIPS16 mode.
	(mips_o64_return_value): Likewise.
	* ppc-tdep.h (ppc_sysv_abi_return_value): Update prototype.
	(ppc_sysv_abi_broken_return_value): Likewise.
	(ppc64_sysv_abi_return_value): Likewise.
	* alpha-tdep.c (alpha_return_value): Take a pointer to struct
	value instead of struct type for the function requested.
	* amd64-tdep.c (amd64_return_value): Likewise.
	* amd64-windows-tdep.c (amd64_windows_return_value): Likewise.
	* arm-tdep.c (arm_return_value): Likewise.
	* avr-tdep.c (avr_return_value): Likewise.
	* bfin-tdep.c (bfin_return_value): Likewise.
	* cris-tdep.c (cris_return_value): Likewise.
	* frv-tdep.c (frv_return_value): Likewise.
	* h8300-tdep.c (h8300_return_value): Likewise.
	(h8300h_return_value): Likewise.
	* hppa-tdep.c (hppa32_return_value): Likewise.
	(hppa64_return_value): Likewise.
	* i386-tdep.c (i386_return_value): Likewise.
	* ia64-tdep.c (ia64_return_value): Likewise.
	* iq2000-tdep.c (iq2000_return_value): Likewise.
	* lm32-tdep.c (lm32_return_value): Likewise.
	* m32c-tdep.c (m32c_return_value): Likewise.
	* m32r-tdep.c (m32r_return_value): Likewise.
	* m68hc11-tdep.c (m68hc11_return_value): Likewise.
	* m68k-tdep.c (m68k_return_value): Likewise.
	(m68k_svr4_return_value): Likewise.
	* m88k-tdep.c (m88k_return_value): Likewise.
	* mep-tdep.c (mep_return_value): Likewise.
	* microblaze-tdep.c (microblaze_return_value): Likewise.
	* mn10300-tdep.c (mn10300_return_value): Likewise.
	* moxie-tdep.c (moxie_return_value): Likewise.
	* mt-tdep.c (mt_return_value): Likewise.
	* ppc-linux-tdep.c (ppc_linux_return_value): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_return_value): Likewise.
	(ppc_sysv_abi_broken_return_value): Likewise.
	(ppc64_sysv_abi_return_value): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_return_value): Likewise.
	* rl78-tdep.c (rl78_return_value): Likewise.
	* rs6000-aix-tdep.c (rs6000_return_value): Likewise.
	* rx-tdep.c (rx_return_value): Likewise.
	* s390-tdep.c (s390_return_value): Likewise.
	* score-tdep.c (score_return_value): Likewise.
	* sh-tdep.c (sh_return_value_nofpu): Likewise.
	(sh_return_value_fpu): Likewise.
	* sh64-tdep.c (sh64_return_value): Likewise.
	* sparc-tdep.c (sparc32_return_value): Likewise.
	* sparc64-tdep.c (sparc64_return_value): Likewise.
	* spu-tdep.c (spu_return_value): Likewise.
	* tic6x-tdep.c (tic6x_return_value): Likewise.
	* v850-tdep.c (v850_return_value): Likewise.
	* vax-tdep.c (vax_return_value): Likewise.
	* xstormy16-tdep.c (xstormy16_return_value): Likewise.
	* xtensa-tdep.c (xtensa_return_value): Likewise.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.

	gdb/testsuite/
	* gdb.base/return-nodebug.exp: Also test float and double types.
@
text
@a1023 1
      int offset;
@


1.4
log
@gdb/
	Fix -Wmissing-prototypes build.
	* alpha-tdep.c (alpha_deal_with_atomic_sequence): Make it static.
	* amd64-darwin-tdep.c (_initialize_amd64_darwin_tdep): New prototype.
	* amd64-windows-tdep.c (_initialize_amd64_windows_tdep): Likewise.
	* arm-symbian-tdep.c (arm_symbian_skip_trampoline_code): Make it static.
	(_initialize_arm_symbian_tdep): New prototype.
	* arm-wince-tdep.c (arm_wince_skip_main_prologue): Make it static.
	* i386-darwin-tdep.c (_initialize_i386_darwin_tdep): New prototype.
	* i386-linux-tdep.c (i386_linux_displaced_step_copy_insn): Make it
	static.
	* lm32-tdep.c (_initialize_lm32_tdep): New prototype.
	* microblaze-linux-tdep.c (_initialize_microblaze_linux_tdep): New
	prototype.
	* microblaze-tdep.c (microblaze_debug, microblaze_fetch_instruction)
	(microblaze_skip_prologue, microblaze_frame_cache): Make them static.
	* mips-linux-tdep.c (mips_linux_regset_from_core_section): Make it
	static.
	* moxie-tdep.c (moxie_process_record): Likewise.
	* remote-mips.c (mips_can_use_watchpoint, mips_insert_watchpoint)
	(mips_remove_watchpoint, mips_stopped_by_watchpoint): Make them static.
	* rl78-tdep.c (rl78_breakpoint_from_pc): Make it static.
	(_initialize_rl78_tdep): New prototype.
	* rx-tdep.c (rx_breakpoint_from_pc): Make it static.
	(_initialize_rx_tdep): New prototype.
	* solib-darwin.c (darwin_in_dynsym_resolve_code): Make it static.
	(_initialize_darwin_solib): New prototype.
	* solib-spu.c: Include solib-spu.h.
	(_initialize_spu_solib): New prototype.
	* spu-multiarch.c (_initialize_spu_multiarch): New prototype.
	* tic6x-tdep.c (tic6x_analyze_prologue, tic6x_skip_prologue)
	(tic6x_breakpoint_from_pc, tic6x_frame_unwind_cache)
	(tic6x_software_single_step): Make it static.
	(_initialize_tic6x_tdep): New prototype.
@
text
@d937 1
a937 1
		   struct type *func_type,
@


1.3
log
@rl78-tdep.c: Rearrange order in which registers are displayed.
@
text
@d559 1
a559 1
const gdb_byte *
d1165 3
@


1.2
log
@	* rl78-tdep.c (rl78_skip_prologue): Make `const' the type of
	the name parameter being passed to find_pc_partial_function().
@
text
@d36 1
d58 67
a124 1
  RL78_BANK0_R0_REGNUM = 0,
d160 1
a160 15
  RL78_PSW_REGNUM,	/* 8 bits */
  RL78_ES_REGNUM,	/* 8 bits */
  RL78_CS_REGNUM,	/* 8 bits */
  RL78_PC_REGNUM,	/* 20 bits; we'll use 32 bits for it.  */

  /* Fixed address SFRs (some of those above are SFRs too.) */
  RL78_SPL_REGNUM,	/* 8 bits; lower half of SP */
  RL78_SPH_REGNUM,	/* 8 bits; upper half of SP */
  RL78_PMC_REGNUM,	/* 8 bits */
  RL78_MEM_REGNUM,	/* 8 bits ?? */

  RL78_NUM_REGS,

  /* Pseudo registers.  */
  RL78_BANK0_RP0_REGNUM = RL78_NUM_REGS,
a179 15
  RL78_SP_REGNUM,

  RL78_X_REGNUM,
  RL78_A_REGNUM,
  RL78_C_REGNUM,
  RL78_B_REGNUM,
  RL78_E_REGNUM,
  RL78_D_REGNUM,
  RL78_L_REGNUM,
  RL78_H_REGNUM,

  RL78_AX_REGNUM,
  RL78_BC_REGNUM,
  RL78_DE_REGNUM,
  RL78_HL_REGNUM,
d247 3
a249 1
           || (RL78_X_REGNUM <= reg_nr && reg_nr <= RL78_H_REGNUM))
d262 62
a359 10
    "psw",
    "es",
    "cs",
    "pc",

    "spl",
    "sph",
    "pmc",
    "mem",

d378 5
a382 1
    "bank3_rp3",
d384 8
a391 1
    "sp",
d393 8
a400 8
    "x",
    "a",
    "c",
    "b",
    "e",
    "d",
    "l",
    "h",
d402 9
a410 5
    "ax",
    "bc",
    "de",
    "hl"
  };
d412 1
a412 1
  return reg_names[regnr];
d442 8
a449 1
  if (RL78_BANK0_RP0_REGNUM <= reg && reg <= RL78_BANK3_RP3_REGNUM)
d452 1
a452 1
                       + RL78_BANK0_R0_REGNUM;
d473 1
a473 1
	  int raw_regnum = RL78_BANK0_R0_REGNUM + bank * RL78_REGS_PER_BANK
d487 1
a487 1
	  int raw_regnum = RL78_BANK0_R0_REGNUM + bank * RL78_REGS_PER_BANK
d507 8
a514 1
  if (RL78_BANK0_RP0_REGNUM <= reg && reg <= RL78_BANK3_RP3_REGNUM)
d517 1
a517 1
                       + RL78_BANK0_R0_REGNUM;
d536 1
a536 1
      raw_regnum = RL78_BANK0_R0_REGNUM + bank * RL78_REGS_PER_BANK
d548 1
a548 1
      raw_regnum = RL78_BANK0_R0_REGNUM + bank * RL78_REGS_PER_BANK
d920 13
d951 1
a951 1
      int argreg = RL78_BANK1_R0_REGNUM;
d967 1
a967 1
      int argreg = RL78_BANK1_R0_REGNUM;
d1118 2
@


1.1
log
@Add support to GDB for the Renesas rl78 architecture.
@
text
@d639 1
a639 1
  char *name;
@

