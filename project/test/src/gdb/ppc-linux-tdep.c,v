head	1.147;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.144
	gdb_7_6-2013-04-26-release:1.144
	gdb_7_6-branch:1.144.0.2
	gdb_7_6-2013-03-12-branchpoint:1.144
	gdb_7_5_1-2012-11-29-release:1.137.2.2
	gdb_7_5-2012-08-17-release:1.137.2.1
	gdb_7_5-branch:1.137.0.2
	gdb_7_5-2012-07-18-branchpoint:1.137
	gdb_7_4_1-2012-04-26-release:1.129.2.4
	gdb_7_4-2012-01-24-release:1.129.2.4
	gdb_7_4-branch:1.129.0.2
	gdb_7_4-2011-12-13-branchpoint:1.129
	gdb_7_3_1-2011-09-04-release:1.128.2.1
	gdb_7_3-2011-07-26-release:1.128.2.1
	gdb_7_3-branch:1.128.0.2
	gdb_7_3-2011-04-01-branchpoint:1.128
	gdb_7_2-2010-09-02-release:1.122
	gdb_7_2-branch:1.122.0.2
	gdb_7_2-2010-07-07-branchpoint:1.122
	gdb_7_1-2010-03-18-release:1.120
	gdb_7_1-branch:1.120.0.2
	gdb_7_1-2010-02-18-branchpoint:1.120
	gdb_7_0_1-2009-12-22-release:1.117
	gdb_7_0-2009-10-06-release:1.117
	gdb_7_0-branch:1.117.0.2
	gdb_7_0-2009-09-16-branchpoint:1.117
	arc-sim-20090309:1.94
	msnyder-checkpoint-072509-branch:1.113.0.2
	msnyder-checkpoint-072509-branchpoint:1.113
	arc-insight_6_8-branch:1.94.0.6
	arc-insight_6_8-branchpoint:1.94
	insight_6_8-branch:1.94.0.4
	insight_6_8-branchpoint:1.94
	reverse-20081226-branch:1.108.0.4
	reverse-20081226-branchpoint:1.108
	multiprocess-20081120-branch:1.108.0.2
	multiprocess-20081120-branchpoint:1.108
	reverse-20080930-branch:1.107.0.2
	reverse-20080930-branchpoint:1.107
	reverse-20080717-branch:1.104.0.4
	reverse-20080717-branchpoint:1.104
	msnyder-reverse-20080609-branch:1.104.0.2
	msnyder-reverse-20080609-branchpoint:1.104
	drow-reverse-20070409-branch:1.81.0.2
	drow-reverse-20070409-branchpoint:1.81
	gdb_6_8-2008-03-27-release:1.94
	gdb_6_8-branch:1.94.0.2
	gdb_6_8-2008-02-26-branchpoint:1.94
	gdb_6_7_1-2007-10-29-release:1.88
	gdb_6_7-2007-10-10-release:1.88
	gdb_6_7-branch:1.88.0.2
	gdb_6_7-2007-09-07-branchpoint:1.88
	insight_6_6-20070208-release:1.80
	gdb_6_6-2006-12-18-release:1.80
	gdb_6_6-branch:1.80.0.2
	gdb_6_6-2006-11-15-branchpoint:1.80
	insight_6_5-20061003-release:1.78
	gdb-csl-symbian-6_4_50_20060226-12:1.77.8.1
	gdb-csl-sourcerygxx-3_4_4-25:1.75
	nickrob-async-20060828-mergepoint:1.78
	gdb-csl-symbian-6_4_50_20060226-11:1.77.8.1
	gdb-csl-sourcerygxx-4_1-17:1.77
	gdb-csl-20060226-branch-local-2:1.77
	gdb-csl-sourcerygxx-4_1-14:1.77
	gdb-csl-sourcerygxx-4_1-13:1.77
	gdb-csl-sourcerygxx-4_1-12:1.77
	gdb-csl-sourcerygxx-3_4_4-21:1.77
	gdb_6_5-20060621-release:1.78
	gdb-csl-sourcerygxx-4_1-9:1.77
	gdb-csl-sourcerygxx-4_1-8:1.77
	gdb-csl-sourcerygxx-4_1-7:1.77
	gdb-csl-arm-2006q1-6:1.77
	gdb-csl-sourcerygxx-4_1-6:1.77
	gdb-csl-symbian-6_4_50_20060226-10:1.77.8.1
	gdb-csl-symbian-6_4_50_20060226-9:1.77.8.1
	gdb-csl-symbian-6_4_50_20060226-8:1.77.8.1
	gdb-csl-coldfire-4_1-11:1.77
	gdb-csl-sourcerygxx-3_4_4-19:1.77
	gdb-csl-coldfire-4_1-10:1.77
	gdb_6_5-branch:1.78.0.8
	gdb_6_5-2006-05-14-branchpoint:1.78
	gdb-csl-sourcerygxx-4_1-5:1.77
	nickrob-async-20060513-branch:1.78.0.6
	nickrob-async-20060513-branchpoint:1.78
	gdb-csl-sourcerygxx-4_1-4:1.77
	msnyder-reverse-20060502-branch:1.78.0.4
	msnyder-reverse-20060502-branchpoint:1.78
	gdb-csl-morpho-4_1-4:1.77
	gdb-csl-sourcerygxx-3_4_4-17:1.77
	readline_5_1-import-branch:1.78.0.2
	readline_5_1-import-branchpoint:1.78
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.77
	gdb-csl-symbian-20060226-branch:1.77.0.8
	gdb-csl-symbian-20060226-branchpoint:1.77
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.77
	msnyder-reverse-20060331-branch:1.77.0.6
	msnyder-reverse-20060331-branchpoint:1.77
	gdb-csl-available-20060303-branch:1.77.0.4
	gdb-csl-available-20060303-branchpoint:1.77
	gdb-csl-20060226-branch:1.77.0.2
	gdb-csl-20060226-branchpoint:1.77
	gdb_6_4-20051202-release:1.75
	msnyder-fork-checkpoint-branch:1.75.0.8
	msnyder-fork-checkpoint-branchpoint:1.75
	gdb-csl-gxxpro-6_3-branch:1.75.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.75
	gdb_6_4-branch:1.75.0.4
	gdb_6_4-2005-11-01-branchpoint:1.75
	gdb-csl-arm-20051020-branch:1.75.0.2
	gdb-csl-arm-20051020-branchpoint:1.75
	msnyder-tracepoint-checkpoint-branch:1.74.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.74
	gdb-csl-arm-20050325-2005-q1b:1.72
	gdb-csl-arm-20050325-2005-q1a:1.72
	csl-arm-20050325-branch:1.72.0.2
	csl-arm-20050325-branchpoint:1.72
	gdb-post-i18n-errorwarning-20050211:1.72
	gdb-pre-i18n-errorwarning-20050211:1.71
	gdb_6_3-20041109-release:1.66
	gdb_6_3-branch:1.66.0.2
	gdb_6_3-20041019-branchpoint:1.66
	drow_intercu-merge-20040921:1.66
	drow_intercu-merge-20040915:1.66
	jimb-gdb_6_2-e500-branch:1.63.2.1.2.1.0.2
	jimb-gdb_6_2-e500-branchpoint:1.63.2.1
	gdb_6_2-20040730-release:1.63.2.1
	gdb_6_2-branch:1.63.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.63
	gdb_6_1_1-20040616-release:1.50
	gdb_6_1-2004-04-05-release:1.50
	drow_intercu-merge-20040402:1.55
	drow_intercu-merge-20040327:1.55
	ezannoni_pie-20040323-branch:1.54.0.2
	ezannoni_pie-20040323-branchpoint:1.54
	cagney_tramp-20040321-mergepoint:1.53
	cagney_tramp-20040309-branch:1.50.0.6
	cagney_tramp-20040309-branchpoint:1.50
	gdb_6_1-branch:1.50.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.50
	drow_intercu-20040221-branch:1.50.0.2
	drow_intercu-20040221-branchpoint:1.50
	cagney_bfdfile-20040213-branch:1.49.0.4
	cagney_bfdfile-20040213-branchpoint:1.49
	drow-cplus-merge-20040208:1.49
	carlton_dictionary-20040126-merge:1.49
	cagney_bigcore-20040122-branch:1.49.0.2
	cagney_bigcore-20040122-branchpoint:1.49
	drow-cplus-merge-20040113:1.49
	drow-cplus-merge-20031224:1.49
	drow-cplus-merge-20031220:1.49
	carlton_dictionary-20031215-merge:1.49
	drow-cplus-merge-20031214:1.49
	carlton-dictionary-20031111-merge:1.47
	gdb_6_0-2003-10-04-release:1.33.2.4
	kettenis_sparc-20030918-branch:1.40.0.2
	kettenis_sparc-20030918-branchpoint:1.40
	carlton_dictionary-20030917-merge:1.40
	ezannoni_pie-20030916-branchpoint:1.39
	ezannoni_pie-20030916-branch:1.39.0.2
	cagney_x86i386-20030821-branch:1.37.0.2
	cagney_x86i386-20030821-branchpoint:1.37
	carlton_dictionary-20030805-merge:1.37
	carlton_dictionary-20030627-merge:1.37
	gdb_6_0-branch:1.33.0.2
	gdb_6_0-2003-06-23-branchpoint:1.33
	jimb-ppc64-linux-20030613-branch:1.32.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.32
	cagney_convert-20030606-branch:1.30.0.2
	cagney_convert-20030606-branchpoint:1.30
	cagney_writestrings-20030508-branch:1.28.0.10
	cagney_writestrings-20030508-branchpoint:1.28
	jimb-ppc64-linux-20030528-branch:1.28.0.8
	jimb-ppc64-linux-20030528-branchpoint:1.28
	carlton_dictionary-20030523-merge:1.28
	cagney_fileio-20030521-branch:1.28.0.6
	cagney_fileio-20030521-branchpoint:1.28
	kettenis_i386newframe-20030517-mergepoint:1.28
	jimb-ppc64-linux-20030509-branch:1.28.0.4
	jimb-ppc64-linux-20030509-branchpoint:1.28
	kettenis_i386newframe-20030504-mergepoint:1.28
	carlton_dictionary-20030430-merge:1.28
	kettenis_i386newframe-20030419-branch:1.28.0.2
	kettenis_i386newframe-20030419-branchpoint:1.28
	carlton_dictionary-20030416-merge:1.28
	cagney_frameaddr-20030409-mergepoint:1.27
	kettenis_i386newframe-20030406-branch:1.27.0.6
	kettenis_i386newframe-20030406-branchpoint:1.27
	cagney_frameaddr-20030403-branchpoint:1.27
	cagney_frameaddr-20030403-branch:1.27.0.4
	cagney_framebase-20030330-mergepoint:1.27
	cagney_framebase-20030326-branch:1.27.0.2
	cagney_framebase-20030326-branchpoint:1.27
	cagney_lazyid-20030317-branch:1.26.0.4
	cagney_lazyid-20030317-branchpoint:1.26
	kettenis-i386newframe-20030316-mergepoint:1.26
	offbyone-20030313-branch:1.26.0.2
	offbyone-20030313-branchpoint:1.26
	kettenis-i386newframe-20030308-branch:1.25.0.4
	kettenis-i386newframe-20030308-branchpoint:1.25
	carlton_dictionary-20030305-merge:1.25
	cagney_offbyone-20030303-branch:1.25.0.2
	cagney_offbyone-20030303-branchpoint:1.25
	carlton_dictionary-20030207-merge:1.23
	interps-20030203-mergepoint:1.22
	interps-20030202-branch:1.22.0.4
	interps-20030202-branchpoint:1.22
	cagney-unwind-20030108-branch:1.22.0.2
	cagney-unwind-20030108-branchpoint:1.22
	carlton_dictionary-20021223-merge:1.21
	gdb_5_3-2002-12-12-release:1.19
	carlton_dictionary-20021115-merge:1.19
	kseitz_interps-20021105-merge:1.19
	kseitz_interps-20021103-merge:1.19
	drow-cplus-merge-20021020:1.19
	drow-cplus-merge-20021025:1.19
	carlton_dictionary-20021025-merge:1.19
	carlton_dictionary-20021011-merge:1.19
	drow-cplus-branch:1.19.0.10
	drow-cplus-branchpoint:1.19
	kseitz_interps-20020930-merge:1.19
	carlton_dictionary-20020927-merge:1.19
	carlton_dictionary-branch:1.19.0.8
	carlton_dictionary-20020920-branchpoint:1.19
	gdb_5_3-branch:1.19.0.6
	gdb_5_3-2002-09-04-branchpoint:1.19
	kseitz_interps-20020829-merge:1.19
	cagney_sysregs-20020825-branch:1.19.0.4
	cagney_sysregs-20020825-branchpoint:1.19
	readline_4_3-import-branch:1.19.0.2
	readline_4_3-import-branchpoint:1.19
	gdb_5_2_1-2002-07-23-release:1.13
	kseitz_interps-20020528-branch:1.17.0.6
	kseitz_interps-20020528-branchpoint:1.17
	cagney_regbuf-20020515-branch:1.17.0.4
	cagney_regbuf-20020515-branchpoint:1.17
	jimb-macro-020506-branch:1.17.0.2
	jimb-macro-020506-branchpoint:1.17
	gdb_5_2-2002-04-29-release:1.13
	gdb_5_2-branch:1.13.0.2
	gdb_5_2-2002-03-03-branchpoint:1.13
	gdb_5_1_1-2002-01-24-release:1.9
	gdb_5_1_0_1-2002-01-03-release:1.9
	cygnus_cvs_20020108_pre:1.12
	gdb_5_1_0_1-2002-01-03-branchpoint:1.9
	gdb_5_1_0_1-2002-01-03-branch:1.9.0.6
	gdb_5_1-2001-11-21-release:1.9
	gdb_s390-2001-09-26-branch:1.9.0.4
	gdb_s390-2001-09-26-branchpoint:1.9
	gdb_5_1-2001-07-29-branch:1.9.0.2
	gdb_5_1-2001-07-29-branchpoint:1.9
	dberlin-typesystem-branch:1.8.0.2
	dberlin-typesystem-branchpoint:1.8
	gdb-post-ptid_t-2001-05-03:1.8
	gdb-pre-ptid_t-2001-05-03:1.8
	insight-precleanup-2001-01-01:1.6
	gdb-post-protoization-2000-07-29:1.5
	gdb-pre-protoization-2000-07-29:1.4
	gdb-premipsmulti-2000-06-06-branch:1.4.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.4
	gdb-post-params-removal-2000-06-04:1.4
	gdb-pre-params-removal-2000-06-04:1.4
	gdb-post-params-removal-2000-05-28:1.4
	gdb-pre-params-removal-2000-05-28:1.4
	gdb_5_0-2000-05-19-release:1.4
	gdb_4_18_2-2000-05-18-release:1.4
	gdb_4_95_1-2000-05-11-snapshot:1.4
	gdb_4_95_0-2000-04-27-snapshot:1.4
	gdb_5_0-2000-04-10-branch:1.4.0.2
	gdb_5_0-2000-04-10-branchpoint:1.4;
locks; strict;
comment	@ * @;


1.147
date	2013.06.04.02.44.35;	author amodra;	state Exp;
branches;
next	1.146;

1.146
date	2013.04.19.15.22.14;	author palves;	state Exp;
branches;
next	1.145;

1.145
date	2013.04.08.19.59.09;	author tromey;	state Exp;
branches;
next	1.144;

1.144
date	2013.02.22.23.24.24;	author amodra;	state Exp;
branches;
next	1.143;

1.143
date	2013.02.04.18.40.41;	author sergiodj;	state Exp;
branches;
next	1.142;

1.142
date	2013.02.01.20.54.18;	author andreast;	state Exp;
branches;
next	1.141;

1.141
date	2013.01.01.06.32.49;	author brobecke;	state Exp;
branches;
next	1.140;

1.140
date	2012.11.08.14.16.33;	author emachado;	state Exp;
branches;
next	1.139;

1.139
date	2012.10.06.21.10.32;	author jkratoch;	state Exp;
branches;
next	1.138;

1.138
date	2012.07.31.19.46.51;	author schwab;	state Exp;
branches;
next	1.137;

1.137
date	2012.05.18.21.02.49;	author sergiodj;	state Exp;
branches
	1.137.2.1;
next	1.136;

1.136
date	2012.05.16.14.35.06;	author macro;	state Exp;
branches;
next	1.135;

1.135
date	2012.04.27.20.47.55;	author sergiodj;	state Exp;
branches;
next	1.134;

1.134
date	2012.01.30.17.09.40;	author eager;	state Exp;
branches;
next	1.133;

1.133
date	2012.01.04.13.51.36;	author jkratoch;	state Exp;
branches;
next	1.132;

1.132
date	2012.01.04.08.17.09;	author brobecke;	state Exp;
branches;
next	1.131;

1.131
date	2012.01.02.02.52.20;	author jkratoch;	state Exp;
branches;
next	1.130;

1.130
date	2011.12.14.14.55.27;	author palves;	state Exp;
branches;
next	1.129;

1.129
date	2011.05.06.20.48.48;	author uweigand;	state Exp;
branches
	1.129.2.1;
next	1.128;

1.128
date	2011.03.18.18.52.31;	author palves;	state Exp;
branches
	1.128.2.1;
next	1.127;

1.127
date	2011.02.27.16.25.37;	author msnyder;	state Exp;
branches;
next	1.126;

1.126
date	2011.02.26.02.07.08;	author msnyder;	state Exp;
branches;
next	1.125;

1.125
date	2011.01.10.20.38.50;	author msnyder;	state Exp;
branches;
next	1.124;

1.124
date	2011.01.01.15.33.12;	author brobecke;	state Exp;
branches;
next	1.123;

1.123
date	2010.08.04.15.27.57;	author palves;	state Exp;
branches;
next	1.122;

1.122
date	2010.07.07.12.28.32;	author uweigand;	state Exp;
branches;
next	1.121;

1.121
date	2010.04.15.20.19.24;	author palves;	state Exp;
branches;
next	1.120;

1.120
date	2010.01.28.22.07.58;	author drow;	state Exp;
branches;
next	1.119;

1.119
date	2010.01.04.14.57.44;	author uweigand;	state Exp;
branches;
next	1.118;

1.118
date	2010.01.01.07.31.38;	author brobecke;	state Exp;
branches;
next	1.117;

1.117
date	2009.09.15.03.30.06;	author sergiodj;	state Exp;
branches;
next	1.116;

1.116
date	2009.07.31.15.31.08;	author uweigand;	state Exp;
branches;
next	1.115;

1.115
date	2009.07.31.15.28.27;	author uweigand;	state Exp;
branches;
next	1.114;

1.114
date	2009.07.31.15.23.20;	author uweigand;	state Exp;
branches;
next	1.113;

1.113
date	2009.07.02.17.25.58;	author uweigand;	state Exp;
branches;
next	1.112;

1.112
date	2009.06.17.18.48.26;	author uweigand;	state Exp;
branches;
next	1.111;

1.111
date	2009.05.22.23.49.13;	author palves;	state Exp;
branches;
next	1.110;

1.110
date	2009.02.22.01.02.19;	author palves;	state Exp;
branches;
next	1.109;

1.109
date	2009.01.03.05.57.53;	author brobecke;	state Exp;
branches;
next	1.108;

1.108
date	2008.11.18.21.39.47;	author bauermann;	state Exp;
branches;
next	1.107;

1.107
date	2008.08.26.15.16.41;	author luisgpm;	state Exp;
branches;
next	1.106;

1.106
date	2008.08.21.19.54.34;	author uweigand;	state Exp;
branches;
next	1.105;

1.105
date	2008.08.15.15.18.33;	author luisgpm;	state Exp;
branches;
next	1.104;

1.104
date	2008.05.24.16.32.01;	author cseo;	state Exp;
branches;
next	1.103;

1.103
date	2008.05.16.12.51.21;	author uweigand;	state Exp;
branches;
next	1.102;

1.102
date	2008.05.16.12.49.47;	author uweigand;	state Exp;
branches;
next	1.101;

1.101
date	2008.05.16.12.48.59;	author uweigand;	state Exp;
branches;
next	1.100;

1.100
date	2008.05.14.18.28.59;	author uweigand;	state Exp;
branches;
next	1.99;

1.99
date	2008.05.03.23.50.43;	author uweigand;	state Exp;
branches;
next	1.98;

1.98
date	2008.05.03.17.16.43;	author uweigand;	state Exp;
branches;
next	1.97;

1.97
date	2008.04.30.21.28.57;	author drow;	state Exp;
branches;
next	1.96;

1.96
date	2008.04.22.11.03.42;	author corinna;	state Exp;
branches;
next	1.95;

1.95
date	2008.03.13.12.22.13;	author drow;	state Exp;
branches;
next	1.94;

1.94
date	2008.02.20.14.31.40;	author deuling;	state Exp;
branches;
next	1.93;

1.93
date	2008.01.01.22.53.12;	author drow;	state Exp;
branches;
next	1.92;

1.92
date	2007.11.16.04.53.46;	author deuling;	state Exp;
branches;
next	1.91;

1.91
date	2007.11.08.00.08.47;	author jsm28;	state Exp;
branches;
next	1.90;

1.90
date	2007.10.31.23.45.10;	author uweigand;	state Exp;
branches;
next	1.89;

1.89
date	2007.10.29.20.26.42;	author cseo;	state Exp;
branches;
next	1.88;

1.88
date	2007.08.30.13.13.59;	author amodra;	state Exp;
branches;
next	1.87;

1.87
date	2007.08.23.18.08.36;	author brobecke;	state Exp;
branches;
next	1.86;

1.86
date	2007.07.03.15.58.42;	author drow;	state Exp;
branches;
next	1.85;

1.85
date	2007.06.18.17.45.26;	author uweigand;	state Exp;
branches;
next	1.84;

1.84
date	2007.06.15.22.39.52;	author uweigand;	state Exp;
branches;
next	1.83;

1.83
date	2007.06.13.17.38.43;	author uweigand;	state Exp;
branches;
next	1.82;

1.82
date	2007.06.01.13.05.54;	author uweigand;	state Exp;
branches;
next	1.81;

1.81
date	2007.01.09.17.58.55;	author drow;	state Exp;
branches;
next	1.80;

1.80
date	2006.11.13.18.50.11;	author pgilliam;	state Exp;
branches;
next	1.79;

1.79
date	2006.11.13.17.37.36;	author pgilliam;	state Exp;
branches;
next	1.78;

1.78
date	2006.04.18.19.20.06;	author drow;	state Exp;
branches;
next	1.77;

1.77
date	2006.01.15.18.28.58;	author kettenis;	state Exp;
branches
	1.77.8.1;
next	1.76;

1.76
date	2005.12.17.22.34.01;	author eliz;	state Exp;
branches;
next	1.75;

1.75
date	2005.07.13.16.29.04;	author drow;	state Exp;
branches;
next	1.74;

1.74
date	2005.05.25.03.12.12;	author cagney;	state Exp;
branches;
next	1.73;

1.73
date	2005.03.31.19.58.25;	author kevinb;	state Exp;
branches;
next	1.72;

1.72
date	2005.02.11.04.06.01;	author cagney;	state Exp;
branches;
next	1.71;

1.71
date	2005.02.08.22.31.53;	author cagney;	state Exp;
branches;
next	1.70;

1.70
date	2005.01.25.22.43.45;	author cagney;	state Exp;
branches;
next	1.69;

1.69
date	2005.01.25.22.06.59;	author cagney;	state Exp;
branches;
next	1.68;

1.68
date	2004.10.31.20.24.32;	author cagney;	state Exp;
branches;
next	1.67;

1.67
date	2004.10.31.19.52.46;	author cagney;	state Exp;
branches;
next	1.66;

1.66
date	2004.07.31.21.53.17;	author cagney;	state Exp;
branches;
next	1.65;

1.65
date	2004.07.22.01.31.49;	author cagney;	state Exp;
branches;
next	1.64;

1.64
date	2004.07.17.14.15.30;	author cagney;	state Exp;
branches;
next	1.63;

1.63
date	2004.05.13.19.36.05;	author jimb;	state Exp;
branches
	1.63.2.1;
next	1.62;

1.62
date	2004.05.13.19.27.07;	author jimb;	state Exp;
branches;
next	1.61;

1.61
date	2004.05.11.04.55.31;	author jimb;	state Exp;
branches;
next	1.60;

1.60
date	2004.05.10.18.58.44;	author jimb;	state Exp;
branches;
next	1.59;

1.59
date	2004.05.10.17.07.02;	author jimb;	state Exp;
branches;
next	1.58;

1.58
date	2004.05.05.01.46.55;	author jimb;	state Exp;
branches;
next	1.57;

1.57
date	2004.05.01.16.52.29;	author cagney;	state Exp;
branches;
next	1.56;

1.56
date	2004.04.08.16.46.27;	author kevinb;	state Exp;
branches;
next	1.55;

1.55
date	2004.03.26.20.59.38;	author jimb;	state Exp;
branches;
next	1.54;

1.54
date	2004.03.23.14.47.56;	author cagney;	state Exp;
branches;
next	1.53;

1.53
date	2004.03.20.04.58.13;	author kevinb;	state Exp;
branches;
next	1.52;

1.52
date	2004.03.20.04.51.21;	author kevinb;	state Exp;
branches;
next	1.51;

1.51
date	2004.03.15.21.35.25;	author cagney;	state Exp;
branches;
next	1.50;

1.50
date	2004.02.16.21.49.22;	author cagney;	state Exp;
branches
	1.50.2.1
	1.50.6.1;
next	1.49;

1.49
date	2003.11.14.14.16.29;	author cagney;	state Exp;
branches;
next	1.48;

1.48
date	2003.11.13.18.08.57;	author cagney;	state Exp;
branches;
next	1.47;

1.47
date	2003.11.07.20.44.51;	author cagney;	state Exp;
branches;
next	1.46;

1.46
date	2003.10.29.19.24.52;	author cagney;	state Exp;
branches;
next	1.45;

1.45
date	2003.10.24.20.24.06;	author cagney;	state Exp;
branches;
next	1.44;

1.44
date	2003.10.22.23.54.11;	author cagney;	state Exp;
branches;
next	1.43;

1.43
date	2003.10.21.22.56.38;	author ezannoni;	state Exp;
branches;
next	1.42;

1.42
date	2003.10.03.20.50.56;	author cagney;	state Exp;
branches;
next	1.41;

1.41
date	2003.09.25.20.44.01;	author cagney;	state Exp;
branches;
next	1.40;

1.40
date	2003.09.16.23.33.17;	author cagney;	state Exp;
branches;
next	1.39;

1.39
date	2003.09.09.03.14.02;	author cagney;	state Exp;
branches;
next	1.38;

1.38
date	2003.08.28.02.53.08;	author cagney;	state Exp;
branches;
next	1.37;

1.37
date	2003.06.24.23.09.22;	author jimb;	state Exp;
branches;
next	1.36;

1.36
date	2003.06.24.23.06.04;	author jimb;	state Exp;
branches;
next	1.35;

1.35
date	2003.06.24.23.03.31;	author jimb;	state Exp;
branches;
next	1.34;

1.34
date	2003.06.24.23.02.10;	author jimb;	state Exp;
branches;
next	1.33;

1.33
date	2003.06.17.16.06.18;	author jimb;	state Exp;
branches
	1.33.2.1;
next	1.32;

1.32
date	2003.06.13.00.06.11;	author jimb;	state Exp;
branches
	1.32.2.1;
next	1.31;

1.31
date	2003.06.12.23.58.07;	author jimb;	state Exp;
branches;
next	1.30;

1.30
date	2003.06.02.02.09.39;	author cagney;	state Exp;
branches;
next	1.29;

1.29
date	2003.05.30.03.44.04;	author jimb;	state Exp;
branches;
next	1.28;

1.28
date	2003.04.14.02.29.40;	author cagney;	state Exp;
branches
	1.28.4.1
	1.28.8.1;
next	1.27;

1.27
date	2003.03.24.03.54.48;	author cagney;	state Exp;
branches;
next	1.26;

1.26
date	2003.03.12.16.50.45;	author cagney;	state Exp;
branches;
next	1.25;

1.25
date	2003.03.02.04.02.24;	author cagney;	state Exp;
branches
	1.25.4.1;
next	1.24;

1.24
date	2003.03.02.00.11.42;	author cagney;	state Exp;
branches;
next	1.23;

1.23
date	2003.02.04.18.21.29;	author drow;	state Exp;
branches;
next	1.22;

1.22
date	2003.01.04.23.38.45;	author drow;	state Exp;
branches;
next	1.21;

1.21
date	2002.12.21.19.58.07;	author kettenis;	state Exp;
branches;
next	1.20;

1.20
date	2002.11.18.22.19.29;	author cagney;	state Exp;
branches;
next	1.19;

1.19
date	2002.07.30.19.03.49;	author drow;	state Exp;
branches
	1.19.8.1
	1.19.10.1;
next	1.18;

1.18
date	2002.05.30.01.21.51;	author thorpej;	state Exp;
branches;
next	1.17;

1.17
date	2002.04.29.15.10.06;	author ezannoni;	state Exp;
branches
	1.17.4.1
	1.17.6.1;
next	1.16;

1.16
date	2002.04.24.16.28.16;	author cagney;	state Exp;
branches;
next	1.15;

1.15
date	2002.04.18.18.09.06;	author cagney;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.22.21.58.16;	author ezannoni;	state Exp;
branches;
next	1.13;

1.13
date	2002.02.24.22.31.19;	author cagney;	state Exp;
branches;
next	1.12;

1.12
date	2001.12.09.21.39.53;	author ezannoni;	state Exp;
branches;
next	1.11;

1.11
date	2001.12.01.00.23.37;	author kevinb;	state Exp;
branches;
next	1.10;

1.10
date	2001.10.21.17.19.37;	author cagney;	state Exp;
branches;
next	1.9;

1.9
date	2001.07.15.20.10.02;	author cagney;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.06.08.21.11;	author kevinb;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.01.01.39.21;	author cagney;	state Exp;
branches;
next	1.6;

1.6
date	2000.07.31.20.56.43;	author kevinb;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.30.01.48.26;	author kevinb;	state Exp;
branches;
next	1.4;

1.4
date	2000.02.26.09.25.50;	author kevinb;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.24.23.06.48;	author kevinb;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.22.18.47.41;	author kevinb;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.22.01.19.11;	author kevinb;	state Exp;
branches;
next	;

1.137.2.1
date	2012.07.31.19.51.02;	author schwab;	state Exp;
branches;
next	1.137.2.2;

1.137.2.2
date	2012.10.06.21.10.56;	author jkratoch;	state Exp;
branches;
next	;

1.129.2.1
date	2011.12.14.14.56.23;	author palves;	state Exp;
branches;
next	1.129.2.2;

1.129.2.2
date	2012.01.02.02.53.34;	author jkratoch;	state Exp;
branches;
next	1.129.2.3;

1.129.2.3
date	2012.01.04.13.55.41;	author jkratoch;	state Exp;
branches;
next	1.129.2.4;

1.129.2.4
date	2012.01.06.04.43.22;	author brobecke;	state Exp;
branches;
next	;

1.128.2.1
date	2011.05.06.20.51.00;	author uweigand;	state Exp;
branches;
next	;

1.77.8.1
date	2006.04.11.21.58.24;	author drow;	state Exp;
branches;
next	;

1.63.2.1
date	2004.07.17.14.16.14;	author cagney;	state Exp;
branches
	1.63.2.1.2.1;
next	;

1.63.2.1.2.1
date	2004.09.01.18.09.58;	author jimb;	state Exp;
branches;
next	;

1.50.2.1
date	2004.03.27.17.37.50;	author drow;	state Exp;
branches;
next	1.50.2.2;

1.50.2.2
date	2004.09.16.17.01.16;	author drow;	state Exp;
branches;
next	;

1.50.6.1
date	2004.03.16.16.05.55;	author cagney;	state Exp;
branches;
next	1.50.6.2;

1.50.6.2
date	2004.03.21.23.57.34;	author cagney;	state Exp;
branches;
next	;

1.33.2.1
date	2003.06.28.00.16.24;	author jimb;	state Exp;
branches;
next	1.33.2.2;

1.33.2.2
date	2003.06.28.00.22.10;	author jimb;	state Exp;
branches;
next	1.33.2.3;

1.33.2.3
date	2003.06.28.00.24.47;	author jimb;	state Exp;
branches;
next	1.33.2.4;

1.33.2.4
date	2003.09.13.00.54.44;	author jimb;	state Exp;
branches;
next	;

1.32.2.1
date	2003.06.13.23.03.59;	author jimb;	state Exp;
branches;
next	1.32.2.2;

1.32.2.2
date	2003.06.13.23.07.19;	author jimb;	state Exp;
branches;
next	1.32.2.3;

1.32.2.3
date	2003.06.13.23.10.03;	author jimb;	state Exp;
branches;
next	1.32.2.4;

1.32.2.4
date	2003.06.13.23.20.44;	author jimb;	state Exp;
branches;
next	1.32.2.5;

1.32.2.5
date	2003.06.13.23.25.44;	author jimb;	state Exp;
branches;
next	1.32.2.6;

1.32.2.6
date	2003.06.18.22.48.40;	author jimb;	state Exp;
branches;
next	;

1.28.4.1
date	2003.05.13.00.08.58;	author jimb;	state Exp;
branches;
next	;

1.28.8.1
date	2003.05.29.18.59.38;	author jimb;	state Exp;
branches;
next	1.28.8.2;

1.28.8.2
date	2003.06.05.22.29.02;	author jimb;	state Exp;
branches;
next	1.28.8.3;

1.28.8.3
date	2003.06.05.22.51.45;	author jimb;	state Exp;
branches;
next	1.28.8.4;

1.28.8.4
date	2003.06.05.23.53.03;	author jimb;	state Exp;
branches;
next	1.28.8.5;

1.28.8.5
date	2003.06.07.00.06.05;	author jimb;	state Exp;
branches;
next	1.28.8.6;

1.28.8.6
date	2003.06.07.00.16.57;	author jimb;	state Exp;
branches;
next	1.28.8.7;

1.28.8.7
date	2003.06.10.17.23.06;	author jimb;	state Exp;
branches;
next	1.28.8.8;

1.28.8.8
date	2003.06.10.17.31.48;	author jimb;	state Exp;
branches;
next	1.28.8.9;

1.28.8.9
date	2003.06.10.17.40.22;	author jimb;	state Exp;
branches;
next	1.28.8.10;

1.28.8.10
date	2003.06.10.17.54.08;	author jimb;	state Exp;
branches;
next	1.28.8.11;

1.28.8.11
date	2003.06.10.17.58.52;	author jimb;	state Exp;
branches;
next	1.28.8.12;

1.28.8.12
date	2003.06.10.17.59.50;	author jimb;	state Exp;
branches;
next	1.28.8.13;

1.28.8.13
date	2003.06.10.18.00.30;	author jimb;	state Exp;
branches;
next	1.28.8.14;

1.28.8.14
date	2003.06.11.06.46.17;	author jimb;	state Exp;
branches;
next	1.28.8.15;

1.28.8.15
date	2003.06.11.08.54.54;	author jimb;	state Exp;
branches;
next	1.28.8.16;

1.28.8.16
date	2003.06.12.21.05.18;	author jimb;	state Exp;
branches;
next	1.28.8.17;

1.28.8.17
date	2003.06.12.21.09.22;	author jimb;	state Exp;
branches;
next	1.28.8.18;

1.28.8.18
date	2003.06.12.21.25.50;	author jimb;	state Exp;
branches;
next	1.28.8.19;

1.28.8.19
date	2003.06.12.23.13.40;	author jimb;	state Exp;
branches;
next	1.28.8.20;

1.28.8.20
date	2003.06.13.19.58.44;	author jimb;	state Exp;
branches;
next	;

1.25.4.1
date	2003.03.16.14.01.50;	author kettenis;	state Exp;
branches;
next	;

1.19.8.1
date	2002.12.23.19.38.38;	author carlton;	state Exp;
branches;
next	1.19.8.2;

1.19.8.2
date	2003.02.07.19.17.51;	author carlton;	state Exp;
branches;
next	1.19.8.3;

1.19.8.3
date	2003.03.06.00.56.31;	author carlton;	state Exp;
branches;
next	1.19.8.4;

1.19.8.4
date	2003.04.16.19.56.53;	author carlton;	state Exp;
branches;
next	1.19.8.5;

1.19.8.5
date	2003.06.27.21.50.07;	author carlton;	state Exp;
branches;
next	1.19.8.6;

1.19.8.6
date	2003.09.17.21.28.27;	author carlton;	state Exp;
branches;
next	1.19.8.7;

1.19.8.7
date	2003.11.11.23.50.52;	author carlton;	state Exp;
branches;
next	1.19.8.8;

1.19.8.8
date	2003.12.16.00.00.45;	author carlton;	state Exp;
branches;
next	;

1.19.10.1
date	2003.12.14.20.27.27;	author drow;	state Exp;
branches;
next	;

1.17.4.1
date	2002.06.15.16.42.54;	author cagney;	state Exp;
branches;
next	;

1.17.6.1
date	2002.06.20.01.32.50;	author kseitz;	state Exp;
branches;
next	1.17.6.2;

1.17.6.2
date	2002.08.09.18.34.26;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.147
log
@	* ppc-tdep.h (ppc_insns_match_pattern): Update prototype.
	* rs6000-tdep.c (read_insn): Add frame param, don't assume big-endian.
	(ppc_insns_match_pattern): Add frame param.  Avoid multiple
	target mem reads on optional insns.
	* ppc-linux-tdep.c (ppc_skip_trampoline_code): Update
	ppc_insns_match_pattern calls.
	* ppc64-tdep.c (ppc64_standard_linkage2, ppc64_standard_linkage3):
	Add match for power7 thread safety insns, and new order of
	std 2,40(1) insn.  Correct code shown for _dl_runtime_resolve
	invocation in comment, and update rest of comment.
	(PPC64_STANDARD_LINKAGE1_LEN, PPC64_STANDARD_LINKAGE2_LEN,
	PPC64_STANDARD_LINKAGE3_LEN): Delete.
	(ppc64_standard_linkage2_target): Update insn offsets.
	(ppc64_skip_trampoline_code): Use a single insn buffer.  Match newer
	stubs first.  Update calls.
@
text
@/* Target-dependent code for GDB, the GNU debugger.

   Copyright (C) 1986-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "frame.h"
#include "inferior.h"
#include "symtab.h"
#include "target.h"
#include "gdbcore.h"
#include "gdbcmd.h"
#include "symfile.h"
#include "objfiles.h"
#include "regcache.h"
#include "value.h"
#include "osabi.h"
#include "regset.h"
#include "solib-svr4.h"
#include "solib-spu.h"
#include "solib.h"
#include "solist.h"
#include "ppc-tdep.h"
#include "ppc64-tdep.h"
#include "ppc-linux-tdep.h"
#include "glibc-tdep.h"
#include "trad-frame.h"
#include "frame-unwind.h"
#include "tramp-frame.h"
#include "observer.h"
#include "auxv.h"
#include "elf/common.h"
#include "exceptions.h"
#include "arch-utils.h"
#include "spu-tdep.h"
#include "xml-syscall.h"
#include "linux-tdep.h"

#include "stap-probe.h"
#include "ax.h"
#include "ax-gdb.h"
#include "cli/cli-utils.h"
#include "parser-defs.h"
#include "user-regs.h"
#include <ctype.h>
#include "elf-bfd.h"            /* for elfcore_write_* */

#include "features/rs6000/powerpc-32l.c"
#include "features/rs6000/powerpc-altivec32l.c"
#include "features/rs6000/powerpc-cell32l.c"
#include "features/rs6000/powerpc-vsx32l.c"
#include "features/rs6000/powerpc-isa205-32l.c"
#include "features/rs6000/powerpc-isa205-altivec32l.c"
#include "features/rs6000/powerpc-isa205-vsx32l.c"
#include "features/rs6000/powerpc-64l.c"
#include "features/rs6000/powerpc-altivec64l.c"
#include "features/rs6000/powerpc-cell64l.c"
#include "features/rs6000/powerpc-vsx64l.c"
#include "features/rs6000/powerpc-isa205-64l.c"
#include "features/rs6000/powerpc-isa205-altivec64l.c"
#include "features/rs6000/powerpc-isa205-vsx64l.c"
#include "features/rs6000/powerpc-e500l.c"

/* Shared library operations for PowerPC-Linux.  */
static struct target_so_ops powerpc_so_ops;

/* The syscall's XML filename for PPC and PPC64.  */
#define XML_SYSCALL_FILENAME_PPC "syscalls/ppc-linux.xml"
#define XML_SYSCALL_FILENAME_PPC64 "syscalls/ppc64-linux.xml"

/* ppc_linux_memory_remove_breakpoints attempts to remove a breakpoint
   in much the same fashion as memory_remove_breakpoint in mem-break.c,
   but is careful not to write back the previous contents if the code
   in question has changed in between inserting the breakpoint and
   removing it.

   Here is the problem that we're trying to solve...

   Once upon a time, before introducing this function to remove
   breakpoints from the inferior, setting a breakpoint on a shared
   library function prior to running the program would not work
   properly.  In order to understand the problem, it is first
   necessary to understand a little bit about dynamic linking on
   this platform.

   A call to a shared library function is accomplished via a bl
   (branch-and-link) instruction whose branch target is an entry
   in the procedure linkage table (PLT).  The PLT in the object
   file is uninitialized.  To gdb, prior to running the program, the
   entries in the PLT are all zeros.

   Once the program starts running, the shared libraries are loaded
   and the procedure linkage table is initialized, but the entries in
   the table are not (necessarily) resolved.  Once a function is
   actually called, the code in the PLT is hit and the function is
   resolved.  In order to better illustrate this, an example is in
   order; the following example is from the gdb testsuite.
	    
	We start the program shmain.

	    [kev@@arroyo testsuite]$ ../gdb gdb.base/shmain
	    [...]

	We place two breakpoints, one on shr1 and the other on main.

	    (gdb) b shr1
	    Breakpoint 1 at 0x100409d4
	    (gdb) b main
	    Breakpoint 2 at 0x100006a0: file gdb.base/shmain.c, line 44.

	Examine the instruction (and the immediatly following instruction)
	upon which the breakpoint was placed.  Note that the PLT entry
	for shr1 contains zeros.

	    (gdb) x/2i 0x100409d4
	    0x100409d4 <shr1>:      .long 0x0
	    0x100409d8 <shr1+4>:    .long 0x0

	Now run 'til main.

	    (gdb) r
	    Starting program: gdb.base/shmain 
	    Breakpoint 1 at 0xffaf790: file gdb.base/shr1.c, line 19.

	    Breakpoint 2, main ()
		at gdb.base/shmain.c:44
	    44        g = 1;

	Examine the PLT again.  Note that the loading of the shared
	library has initialized the PLT to code which loads a constant
	(which I think is an index into the GOT) into r11 and then
	branchs a short distance to the code which actually does the
	resolving.

	    (gdb) x/2i 0x100409d4
	    0x100409d4 <shr1>:      li      r11,4
	    0x100409d8 <shr1+4>:    b       0x10040984 <sg+4>
	    (gdb) c
	    Continuing.

	    Breakpoint 1, shr1 (x=1)
		at gdb.base/shr1.c:19
	    19        l = 1;

	Now we've hit the breakpoint at shr1.  (The breakpoint was
	reset from the PLT entry to the actual shr1 function after the
	shared library was loaded.) Note that the PLT entry has been
	resolved to contain a branch that takes us directly to shr1.
	(The real one, not the PLT entry.)

	    (gdb) x/2i 0x100409d4
	    0x100409d4 <shr1>:      b       0xffaf76c <shr1>
	    0x100409d8 <shr1+4>:    b       0x10040984 <sg+4>

   The thing to note here is that the PLT entry for shr1 has been
   changed twice.

   Now the problem should be obvious.  GDB places a breakpoint (a
   trap instruction) on the zero value of the PLT entry for shr1.
   Later on, after the shared library had been loaded and the PLT
   initialized, GDB gets a signal indicating this fact and attempts
   (as it always does when it stops) to remove all the breakpoints.

   The breakpoint removal was causing the former contents (a zero
   word) to be written back to the now initialized PLT entry thus
   destroying a portion of the initialization that had occurred only a
   short time ago.  When execution continued, the zero word would be
   executed as an instruction an illegal instruction trap was
   generated instead.  (0 is not a legal instruction.)

   The fix for this problem was fairly straightforward.  The function
   memory_remove_breakpoint from mem-break.c was copied to this file,
   modified slightly, and renamed to ppc_linux_memory_remove_breakpoint.
   In tm-linux.h, MEMORY_REMOVE_BREAKPOINT is defined to call this new
   function.

   The differences between ppc_linux_memory_remove_breakpoint () and
   memory_remove_breakpoint () are minor.  All that the former does
   that the latter does not is check to make sure that the breakpoint
   location actually contains a breakpoint (trap instruction) prior
   to attempting to write back the old contents.  If it does contain
   a trap instruction, we allow the old contents to be written back.
   Otherwise, we silently do nothing.

   The big question is whether memory_remove_breakpoint () should be
   changed to have the same functionality.  The downside is that more
   traffic is generated for remote targets since we'll have an extra
   fetch of a memory word each time a breakpoint is removed.

   For the time being, we'll leave this self-modifying-code-friendly
   version in ppc-linux-tdep.c, but it ought to be migrated somewhere
   else in the event that some other platform has similar needs with
   regard to removing breakpoints in some potentially self modifying
   code.  */
static int
ppc_linux_memory_remove_breakpoint (struct gdbarch *gdbarch,
				    struct bp_target_info *bp_tgt)
{
  CORE_ADDR addr = bp_tgt->placed_address;
  const unsigned char *bp;
  int val;
  int bplen;
  gdb_byte old_contents[BREAKPOINT_MAX];
  struct cleanup *cleanup;

  /* Determine appropriate breakpoint contents and size for this address.  */
  bp = gdbarch_breakpoint_from_pc (gdbarch, &addr, &bplen);
  if (bp == NULL)
    error (_("Software breakpoints not implemented for this target."));

  /* Make sure we see the memory breakpoints.  */
  cleanup = make_show_memory_breakpoints_cleanup (1);
  val = target_read_memory (addr, old_contents, bplen);

  /* If our breakpoint is no longer at the address, this means that the
     program modified the code on us, so it is wrong to put back the
     old value.  */
  if (val == 0 && memcmp (bp, old_contents, bplen) == 0)
    val = target_write_raw_memory (addr, bp_tgt->shadow_contents, bplen);

  do_cleanups (cleanup);
  return val;
}

/* For historic reasons, PPC 32 GNU/Linux follows PowerOpen rather
   than the 32 bit SYSV R4 ABI structure return convention - all
   structures, no matter their size, are put in memory.  Vectors,
   which were added later, do get returned in a register though.  */

static enum return_value_convention
ppc_linux_return_value (struct gdbarch *gdbarch, struct value *function,
			struct type *valtype, struct regcache *regcache,
			gdb_byte *readbuf, const gdb_byte *writebuf)
{  
  if ((TYPE_CODE (valtype) == TYPE_CODE_STRUCT
       || TYPE_CODE (valtype) == TYPE_CODE_UNION)
      && !((TYPE_LENGTH (valtype) == 16 || TYPE_LENGTH (valtype) == 8)
	   && TYPE_VECTOR (valtype)))
    return RETURN_VALUE_STRUCT_CONVENTION;
  else
    return ppc_sysv_abi_return_value (gdbarch, function, valtype, regcache,
				      readbuf, writebuf);
}

static struct core_regset_section ppc_linux_vsx_regset_sections[] =
{
  { ".reg", 48 * 4, "general-purpose" },
  { ".reg2", 264, "floating-point" },
  { ".reg-ppc-vmx", 544, "ppc Altivec" },
  { ".reg-ppc-vsx", 256, "POWER7 VSX" },
  { NULL, 0}
};

static struct core_regset_section ppc_linux_vmx_regset_sections[] =
{
  { ".reg", 48 * 4, "general-purpose" },
  { ".reg2", 264, "floating-point" },
  { ".reg-ppc-vmx", 544, "ppc Altivec" },
  { NULL, 0}
};

static struct core_regset_section ppc_linux_fp_regset_sections[] =
{
  { ".reg", 48 * 4, "general-purpose" },
  { ".reg2", 264, "floating-point" },
  { NULL, 0}
};

static struct core_regset_section ppc64_linux_vsx_regset_sections[] =
{
  { ".reg", 48 * 8, "general-purpose" },
  { ".reg2", 264, "floating-point" },
  { ".reg-ppc-vmx", 544, "ppc Altivec" },
  { ".reg-ppc-vsx", 256, "POWER7 VSX" },
  { NULL, 0}
};

static struct core_regset_section ppc64_linux_vmx_regset_sections[] =
{
  { ".reg", 48 * 8, "general-purpose" },
  { ".reg2", 264, "floating-point" },
  { ".reg-ppc-vmx", 544, "ppc Altivec" },
  { NULL, 0}
};

static struct core_regset_section ppc64_linux_fp_regset_sections[] =
{
  { ".reg", 48 * 8, "general-purpose" },
  { ".reg2", 264, "floating-point" },
  { NULL, 0}
};

/* PLT stub in executable.  */
static struct ppc_insn_pattern powerpc32_plt_stub[] =
  {
    { 0xffff0000, 0x3d600000, 0 },	/* lis   r11, xxxx	 */
    { 0xffff0000, 0x816b0000, 0 },	/* lwz   r11, xxxx(r11)  */
    { 0xffffffff, 0x7d6903a6, 0 },	/* mtctr r11		 */
    { 0xffffffff, 0x4e800420, 0 },	/* bctr			 */
    {          0,          0, 0 }
  };

/* PLT stub in shared library.  */
static struct ppc_insn_pattern powerpc32_plt_stub_so[] =
  {
    { 0xffff0000, 0x817e0000, 0 },	/* lwz   r11, xxxx(r30)  */
    { 0xffffffff, 0x7d6903a6, 0 },	/* mtctr r11		 */
    { 0xffffffff, 0x4e800420, 0 },	/* bctr			 */
    { 0xffffffff, 0x60000000, 0 },	/* nop			 */
    {          0,          0, 0 }
  };
#define POWERPC32_PLT_STUB_LEN 	ARRAY_SIZE (powerpc32_plt_stub)

/* Check if PC is in PLT stub.  For non-secure PLT, stub is in .plt
   section.  For secure PLT, stub is in .text and we need to check
   instruction patterns.  */

static int
powerpc_linux_in_dynsym_resolve_code (CORE_ADDR pc)
{
  struct bound_minimal_symbol sym;

  /* Check whether PC is in the dynamic linker.  This also checks
     whether it is in the .plt section, used by non-PIC executables.  */
  if (svr4_in_dynsym_resolve_code (pc))
    return 1;

  /* Check if we are in the resolver.  */
  sym = lookup_minimal_symbol_by_pc (pc);
  if (sym.minsym != NULL
      && (strcmp (SYMBOL_LINKAGE_NAME (sym.minsym), "__glink") == 0
	  || strcmp (SYMBOL_LINKAGE_NAME (sym.minsym),
		     "__glink_PLTresolve") == 0))
    return 1;

  return 0;
}

/* Follow PLT stub to actual routine.  */

static CORE_ADDR
ppc_skip_trampoline_code (struct frame_info *frame, CORE_ADDR pc)
{
  unsigned int insnbuf[POWERPC32_PLT_STUB_LEN];
  struct gdbarch *gdbarch = get_frame_arch (frame);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  CORE_ADDR target = 0;

  if (ppc_insns_match_pattern (frame, pc, powerpc32_plt_stub, insnbuf))
    {
      /* Insn pattern is
		lis   r11, xxxx
		lwz   r11, xxxx(r11)
	 Branch target is in r11.  */

      target = (ppc_insn_d_field (insnbuf[0]) << 16)
	| ppc_insn_d_field (insnbuf[1]);
      target = read_memory_unsigned_integer (target, 4, byte_order);
    }

  if (ppc_insns_match_pattern (frame, pc, powerpc32_plt_stub_so, insnbuf))
    {
      /* Insn pattern is
		lwz   r11, xxxx(r30)
	 Branch target is in r11.  */

      target = get_frame_register_unsigned (frame, tdep->ppc_gp0_regnum + 30)
	       + ppc_insn_d_field (insnbuf[0]);
      target = read_memory_unsigned_integer (target, 4, byte_order);
    }

  return target;
}

/* Wrappers to handle Linux-only registers.  */

static void
ppc_linux_supply_gregset (const struct regset *regset,
			  struct regcache *regcache,
			  int regnum, const void *gregs, size_t len)
{
  const struct ppc_reg_offsets *offsets = regset->descr;

  ppc_supply_gregset (regset, regcache, regnum, gregs, len);

  if (ppc_linux_trap_reg_p (get_regcache_arch (regcache)))
    {
      /* "orig_r3" is stored 2 slots after "pc".  */
      if (regnum == -1 || regnum == PPC_ORIG_R3_REGNUM)
	ppc_supply_reg (regcache, PPC_ORIG_R3_REGNUM, gregs,
			offsets->pc_offset + 2 * offsets->gpr_size,
			offsets->gpr_size);

      /* "trap" is stored 8 slots after "pc".  */
      if (regnum == -1 || regnum == PPC_TRAP_REGNUM)
	ppc_supply_reg (regcache, PPC_TRAP_REGNUM, gregs,
			offsets->pc_offset + 8 * offsets->gpr_size,
			offsets->gpr_size);
    }
}

static void
ppc_linux_collect_gregset (const struct regset *regset,
			   const struct regcache *regcache,
			   int regnum, void *gregs, size_t len)
{
  const struct ppc_reg_offsets *offsets = regset->descr;

  /* Clear areas in the linux gregset not written elsewhere.  */
  if (regnum == -1)
    memset (gregs, 0, len);

  ppc_collect_gregset (regset, regcache, regnum, gregs, len);

  if (ppc_linux_trap_reg_p (get_regcache_arch (regcache)))
    {
      /* "orig_r3" is stored 2 slots after "pc".  */
      if (regnum == -1 || regnum == PPC_ORIG_R3_REGNUM)
	ppc_collect_reg (regcache, PPC_ORIG_R3_REGNUM, gregs,
			 offsets->pc_offset + 2 * offsets->gpr_size,
			 offsets->gpr_size);

      /* "trap" is stored 8 slots after "pc".  */
      if (regnum == -1 || regnum == PPC_TRAP_REGNUM)
	ppc_collect_reg (regcache, PPC_TRAP_REGNUM, gregs,
			 offsets->pc_offset + 8 * offsets->gpr_size,
			 offsets->gpr_size);
    }
}

/* Regset descriptions.  */
static const struct ppc_reg_offsets ppc32_linux_reg_offsets =
  {
    /* General-purpose registers.  */
    /* .r0_offset = */ 0,
    /* .gpr_size = */ 4,
    /* .xr_size = */ 4,
    /* .pc_offset = */ 128,
    /* .ps_offset = */ 132,
    /* .cr_offset = */ 152,
    /* .lr_offset = */ 144,
    /* .ctr_offset = */ 140,
    /* .xer_offset = */ 148,
    /* .mq_offset = */ 156,

    /* Floating-point registers.  */
    /* .f0_offset = */ 0,
    /* .fpscr_offset = */ 256,
    /* .fpscr_size = */ 8,

    /* AltiVec registers.  */
    /* .vr0_offset = */ 0,
    /* .vscr_offset = */ 512 + 12,
    /* .vrsave_offset = */ 528
  };

static const struct ppc_reg_offsets ppc64_linux_reg_offsets =
  {
    /* General-purpose registers.  */
    /* .r0_offset = */ 0,
    /* .gpr_size = */ 8,
    /* .xr_size = */ 8,
    /* .pc_offset = */ 256,
    /* .ps_offset = */ 264,
    /* .cr_offset = */ 304,
    /* .lr_offset = */ 288,
    /* .ctr_offset = */ 280,
    /* .xer_offset = */ 296,
    /* .mq_offset = */ 312,

    /* Floating-point registers.  */
    /* .f0_offset = */ 0,
    /* .fpscr_offset = */ 256,
    /* .fpscr_size = */ 8,

    /* AltiVec registers.  */
    /* .vr0_offset = */ 0,
    /* .vscr_offset = */ 512 + 12,
    /* .vrsave_offset = */ 528
  };

static const struct regset ppc32_linux_gregset = {
  &ppc32_linux_reg_offsets,
  ppc_linux_supply_gregset,
  ppc_linux_collect_gregset,
  NULL
};

static const struct regset ppc64_linux_gregset = {
  &ppc64_linux_reg_offsets,
  ppc_linux_supply_gregset,
  ppc_linux_collect_gregset,
  NULL
};

static const struct regset ppc32_linux_fpregset = {
  &ppc32_linux_reg_offsets,
  ppc_supply_fpregset,
  ppc_collect_fpregset,
  NULL
};

static const struct regset ppc32_linux_vrregset = {
  &ppc32_linux_reg_offsets,
  ppc_supply_vrregset,
  ppc_collect_vrregset,
  NULL
};

static const struct regset ppc32_linux_vsxregset = {
  &ppc32_linux_reg_offsets,
  ppc_supply_vsxregset,
  ppc_collect_vsxregset,
  NULL
};

const struct regset *
ppc_linux_gregset (int wordsize)
{
  return wordsize == 8 ? &ppc64_linux_gregset : &ppc32_linux_gregset;
}

const struct regset *
ppc_linux_fpregset (void)
{
  return &ppc32_linux_fpregset;
}

static const struct regset *
ppc_linux_regset_from_core_section (struct gdbarch *core_arch,
				    const char *sect_name, size_t sect_size)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (core_arch);
  if (strcmp (sect_name, ".reg") == 0)
    {
      if (tdep->wordsize == 4)
	return &ppc32_linux_gregset;
      else
	return &ppc64_linux_gregset;
    }
  if (strcmp (sect_name, ".reg2") == 0)
    return &ppc32_linux_fpregset;
  if (strcmp (sect_name, ".reg-ppc-vmx") == 0)
    return &ppc32_linux_vrregset;
  if (strcmp (sect_name, ".reg-ppc-vsx") == 0)
    return &ppc32_linux_vsxregset;
  return NULL;
}

static void
ppc_linux_sigtramp_cache (struct frame_info *this_frame,
			  struct trad_frame_cache *this_cache,
			  CORE_ADDR func, LONGEST offset,
			  int bias)
{
  CORE_ADDR base;
  CORE_ADDR regs;
  CORE_ADDR gpregs;
  CORE_ADDR fpregs;
  int i;
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);

  base = get_frame_register_unsigned (this_frame,
				      gdbarch_sp_regnum (gdbarch));
  if (bias > 0 && get_frame_pc (this_frame) != func)
    /* See below, some signal trampolines increment the stack as their
       first instruction, need to compensate for that.  */
    base -= bias;

  /* Find the address of the register buffer pointer.  */
  regs = base + offset;
  /* Use that to find the address of the corresponding register
     buffers.  */
  gpregs = read_memory_unsigned_integer (regs, tdep->wordsize, byte_order);
  fpregs = gpregs + 48 * tdep->wordsize;

  /* General purpose.  */
  for (i = 0; i < 32; i++)
    {
      int regnum = i + tdep->ppc_gp0_regnum;
      trad_frame_set_reg_addr (this_cache,
			       regnum, gpregs + i * tdep->wordsize);
    }
  trad_frame_set_reg_addr (this_cache,
			   gdbarch_pc_regnum (gdbarch),
			   gpregs + 32 * tdep->wordsize);
  trad_frame_set_reg_addr (this_cache, tdep->ppc_ctr_regnum,
			   gpregs + 35 * tdep->wordsize);
  trad_frame_set_reg_addr (this_cache, tdep->ppc_lr_regnum,
			   gpregs + 36 * tdep->wordsize);
  trad_frame_set_reg_addr (this_cache, tdep->ppc_xer_regnum,
			   gpregs + 37 * tdep->wordsize);
  trad_frame_set_reg_addr (this_cache, tdep->ppc_cr_regnum,
			   gpregs + 38 * tdep->wordsize);

  if (ppc_linux_trap_reg_p (gdbarch))
    {
      trad_frame_set_reg_addr (this_cache, PPC_ORIG_R3_REGNUM,
			       gpregs + 34 * tdep->wordsize);
      trad_frame_set_reg_addr (this_cache, PPC_TRAP_REGNUM,
			       gpregs + 40 * tdep->wordsize);
    }

  if (ppc_floating_point_unit_p (gdbarch))
    {
      /* Floating point registers.  */
      for (i = 0; i < 32; i++)
	{
	  int regnum = i + gdbarch_fp0_regnum (gdbarch);
	  trad_frame_set_reg_addr (this_cache, regnum,
				   fpregs + i * tdep->wordsize);
	}
      trad_frame_set_reg_addr (this_cache, tdep->ppc_fpscr_regnum,
                         fpregs + 32 * tdep->wordsize);
    }
  trad_frame_set_id (this_cache, frame_id_build (base, func));
}

static void
ppc32_linux_sigaction_cache_init (const struct tramp_frame *self,
				  struct frame_info *this_frame,
				  struct trad_frame_cache *this_cache,
				  CORE_ADDR func)
{
  ppc_linux_sigtramp_cache (this_frame, this_cache, func,
			    0xd0 /* Offset to ucontext_t.  */
			    + 0x30 /* Offset to .reg.  */,
			    0);
}

static void
ppc64_linux_sigaction_cache_init (const struct tramp_frame *self,
				  struct frame_info *this_frame,
				  struct trad_frame_cache *this_cache,
				  CORE_ADDR func)
{
  ppc_linux_sigtramp_cache (this_frame, this_cache, func,
			    0x80 /* Offset to ucontext_t.  */
			    + 0xe0 /* Offset to .reg.  */,
			    128);
}

static void
ppc32_linux_sighandler_cache_init (const struct tramp_frame *self,
				   struct frame_info *this_frame,
				   struct trad_frame_cache *this_cache,
				   CORE_ADDR func)
{
  ppc_linux_sigtramp_cache (this_frame, this_cache, func,
			    0x40 /* Offset to ucontext_t.  */
			    + 0x1c /* Offset to .reg.  */,
			    0);
}

static void
ppc64_linux_sighandler_cache_init (const struct tramp_frame *self,
				   struct frame_info *this_frame,
				   struct trad_frame_cache *this_cache,
				   CORE_ADDR func)
{
  ppc_linux_sigtramp_cache (this_frame, this_cache, func,
			    0x80 /* Offset to struct sigcontext.  */
			    + 0x38 /* Offset to .reg.  */,
			    128);
}

static struct tramp_frame ppc32_linux_sigaction_tramp_frame = {
  SIGTRAMP_FRAME,
  4,
  { 
    { 0x380000ac, -1 }, /* li r0, 172 */
    { 0x44000002, -1 }, /* sc */
    { TRAMP_SENTINEL_INSN },
  },
  ppc32_linux_sigaction_cache_init
};
static struct tramp_frame ppc64_linux_sigaction_tramp_frame = {
  SIGTRAMP_FRAME,
  4,
  {
    { 0x38210080, -1 }, /* addi r1,r1,128 */
    { 0x380000ac, -1 }, /* li r0, 172 */
    { 0x44000002, -1 }, /* sc */
    { TRAMP_SENTINEL_INSN },
  },
  ppc64_linux_sigaction_cache_init
};
static struct tramp_frame ppc32_linux_sighandler_tramp_frame = {
  SIGTRAMP_FRAME,
  4,
  { 
    { 0x38000077, -1 }, /* li r0,119 */
    { 0x44000002, -1 }, /* sc */
    { TRAMP_SENTINEL_INSN },
  },
  ppc32_linux_sighandler_cache_init
};
static struct tramp_frame ppc64_linux_sighandler_tramp_frame = {
  SIGTRAMP_FRAME,
  4,
  { 
    { 0x38210080, -1 }, /* addi r1,r1,128 */
    { 0x38000077, -1 }, /* li r0,119 */
    { 0x44000002, -1 }, /* sc */
    { TRAMP_SENTINEL_INSN },
  },
  ppc64_linux_sighandler_cache_init
};


/* Address to use for displaced stepping.  When debugging a stand-alone
   SPU executable, entry_point_address () will point to an SPU local-store
   address and is thus not usable as displaced stepping location.  We use
   the auxiliary vector to determine the PowerPC-side entry point address
   instead.  */

static CORE_ADDR ppc_linux_entry_point_addr = 0;

static void
ppc_linux_inferior_created (struct target_ops *target, int from_tty)
{
  ppc_linux_entry_point_addr = 0;
}

static CORE_ADDR
ppc_linux_displaced_step_location (struct gdbarch *gdbarch)
{
  if (ppc_linux_entry_point_addr == 0)
    {
      CORE_ADDR addr;

      /* Determine entry point from target auxiliary vector.  */
      if (target_auxv_search (&current_target, AT_ENTRY, &addr) <= 0)
	error (_("Cannot find AT_ENTRY auxiliary vector entry."));

      /* Make certain that the address points at real code, and not a
	 function descriptor.  */
      addr = gdbarch_convert_from_func_ptr_addr (gdbarch, addr,
						 &current_target);

      /* Inferior calls also use the entry point as a breakpoint location.
	 We don't want displaced stepping to interfere with those
	 breakpoints, so leave space.  */
      ppc_linux_entry_point_addr = addr + 2 * PPC_INSN_SIZE;
    }

  return ppc_linux_entry_point_addr;
}


/* Return 1 if PPC_ORIG_R3_REGNUM and PPC_TRAP_REGNUM are usable.  */
int
ppc_linux_trap_reg_p (struct gdbarch *gdbarch)
{
  /* If we do not have a target description with registers, then
     the special registers will not be included in the register set.  */
  if (!tdesc_has_registers (gdbarch_target_desc (gdbarch)))
    return 0;

  /* If we do, then it is safe to check the size.  */
  return register_size (gdbarch, PPC_ORIG_R3_REGNUM) > 0
         && register_size (gdbarch, PPC_TRAP_REGNUM) > 0;
}

/* Return the current system call's number present in the
   r0 register.  When the function fails, it returns -1.  */
static LONGEST
ppc_linux_get_syscall_number (struct gdbarch *gdbarch,
                              ptid_t ptid)
{
  struct regcache *regcache = get_thread_regcache (ptid);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  struct cleanup *cleanbuf;
  /* The content of a register */
  gdb_byte *buf;
  /* The result */
  LONGEST ret;

  /* Make sure we're in a 32- or 64-bit machine */
  gdb_assert (tdep->wordsize == 4 || tdep->wordsize == 8);

  buf = (gdb_byte *) xmalloc (tdep->wordsize * sizeof (gdb_byte));

  cleanbuf = make_cleanup (xfree, buf);

  /* Getting the system call number from the register.
     When dealing with PowerPC architecture, this information
     is stored at 0th register.  */
  regcache_cooked_read (regcache, tdep->ppc_gp0_regnum, buf);

  ret = extract_signed_integer (buf, tdep->wordsize, byte_order);
  do_cleanups (cleanbuf);

  return ret;
}

static void
ppc_linux_write_pc (struct regcache *regcache, CORE_ADDR pc)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);

  regcache_cooked_write_unsigned (regcache, gdbarch_pc_regnum (gdbarch), pc);

  /* Set special TRAP register to -1 to prevent the kernel from
     messing with the PC we just installed, if we happen to be
     within an interrupted system call that the kernel wants to
     restart.

     Note that after we return from the dummy call, the TRAP and
     ORIG_R3 registers will be automatically restored, and the
     kernel continues to restart the system call at this point.  */
  if (ppc_linux_trap_reg_p (gdbarch))
    regcache_cooked_write_unsigned (regcache, PPC_TRAP_REGNUM, -1);
}

static int
ppc_linux_spu_section (bfd *abfd, asection *asect, void *user_data)
{
  return strncmp (bfd_section_name (abfd, asect), "SPU/", 4) == 0;
}

static const struct target_desc *
ppc_linux_core_read_description (struct gdbarch *gdbarch,
				 struct target_ops *target,
				 bfd *abfd)
{
  asection *cell = bfd_sections_find_if (abfd, ppc_linux_spu_section, NULL);
  asection *altivec = bfd_get_section_by_name (abfd, ".reg-ppc-vmx");
  asection *vsx = bfd_get_section_by_name (abfd, ".reg-ppc-vsx");
  asection *section = bfd_get_section_by_name (abfd, ".reg");
  if (! section)
    return NULL;

  switch (bfd_section_size (abfd, section))
    {
    case 48 * 4:
      if (cell)
	return tdesc_powerpc_cell32l;
      else if (vsx)
	return tdesc_powerpc_vsx32l;
      else if (altivec)
	return tdesc_powerpc_altivec32l;
      else
	return tdesc_powerpc_32l;

    case 48 * 8:
      if (cell)
	return tdesc_powerpc_cell64l;
      else if (vsx)
	return tdesc_powerpc_vsx64l;
      else if (altivec)
	return tdesc_powerpc_altivec64l;
      else
	return tdesc_powerpc_64l;

    default:
      return NULL;
    }
}

/* Implementation of `gdbarch_stap_is_single_operand', as defined in
   gdbarch.h.  */

static int
ppc_stap_is_single_operand (struct gdbarch *gdbarch, const char *s)
{
  return (*s == 'i' /* Literal number.  */
	  || (isdigit (*s) && s[1] == '('
	      && isdigit (s[2])) /* Displacement.  */
	  || (*s == '(' && isdigit (s[1])) /* Register indirection.  */
	  || isdigit (*s)); /* Register value.  */
}

/* Implementation of `gdbarch_stap_parse_special_token', as defined in
   gdbarch.h.  */

static int
ppc_stap_parse_special_token (struct gdbarch *gdbarch,
			      struct stap_parse_info *p)
{
  if (isdigit (*p->arg))
    {
      /* This temporary pointer is needed because we have to do a lookahead.
	  We could be dealing with a register displacement, and in such case
	  we would not need to do anything.  */
      const char *s = p->arg;
      char *regname;
      int len;
      struct stoken str;

      while (isdigit (*s))
	++s;

      if (*s == '(')
	{
	  /* It is a register displacement indeed.  Returning 0 means we are
	     deferring the treatment of this case to the generic parser.  */
	  return 0;
	}

      len = s - p->arg;
      regname = alloca (len + 2);
      regname[0] = 'r';

      strncpy (regname + 1, p->arg, len);
      ++len;
      regname[len] = '\0';

      if (user_reg_map_name_to_regnum (gdbarch, regname, len) == -1)
	error (_("Invalid register name `%s' on expression `%s'."),
	       regname, p->saved_arg);

      write_exp_elt_opcode (OP_REGISTER);
      str.ptr = regname;
      str.length = len;
      write_exp_string (str);
      write_exp_elt_opcode (OP_REGISTER);

      p->arg = s;
    }
  else
    {
      /* All the other tokens should be handled correctly by the generic
	 parser.  */
      return 0;
    }

  return 1;
}

/* Cell/B.E. active SPE context tracking support.  */

static struct objfile *spe_context_objfile = NULL;
static CORE_ADDR spe_context_lm_addr = 0;
static CORE_ADDR spe_context_offset = 0;

static ptid_t spe_context_cache_ptid;
static CORE_ADDR spe_context_cache_address;

/* Hook into inferior_created, solib_loaded, and solib_unloaded observers
   to track whether we've loaded a version of libspe2 (as static or dynamic
   library) that provides the __spe_current_active_context variable.  */
static void
ppc_linux_spe_context_lookup (struct objfile *objfile)
{
  struct minimal_symbol *sym;

  if (!objfile)
    {
      spe_context_objfile = NULL;
      spe_context_lm_addr = 0;
      spe_context_offset = 0;
      spe_context_cache_ptid = minus_one_ptid;
      spe_context_cache_address = 0;
      return;
    }

  sym = lookup_minimal_symbol ("__spe_current_active_context", NULL, objfile);
  if (sym)
    {
      spe_context_objfile = objfile;
      spe_context_lm_addr = svr4_fetch_objfile_link_map (objfile);
      spe_context_offset = SYMBOL_VALUE_ADDRESS (sym);
      spe_context_cache_ptid = minus_one_ptid;
      spe_context_cache_address = 0;
      return;
    }
}

static void
ppc_linux_spe_context_inferior_created (struct target_ops *t, int from_tty)
{
  struct objfile *objfile;

  ppc_linux_spe_context_lookup (NULL);
  ALL_OBJFILES (objfile)
    ppc_linux_spe_context_lookup (objfile);
}

static void
ppc_linux_spe_context_solib_loaded (struct so_list *so)
{
  if (strstr (so->so_original_name, "/libspe") != NULL)
    {
      solib_read_symbols (so, 0);
      ppc_linux_spe_context_lookup (so->objfile);
    }
}

static void
ppc_linux_spe_context_solib_unloaded (struct so_list *so)
{
  if (so->objfile == spe_context_objfile)
    ppc_linux_spe_context_lookup (NULL);
}

/* Retrieve contents of the N'th element in the current thread's
   linked SPE context list into ID and NPC.  Return the address of
   said context element, or 0 if not found.  */
static CORE_ADDR
ppc_linux_spe_context (int wordsize, enum bfd_endian byte_order,
		       int n, int *id, unsigned int *npc)
{
  CORE_ADDR spe_context = 0;
  gdb_byte buf[16];
  int i;

  /* Quick exit if we have not found __spe_current_active_context.  */
  if (!spe_context_objfile)
    return 0;

  /* Look up cached address of thread-local variable.  */
  if (!ptid_equal (spe_context_cache_ptid, inferior_ptid))
    {
      struct target_ops *target = &current_target;
      volatile struct gdb_exception ex;

      while (target && !target->to_get_thread_local_address)
	target = find_target_beneath (target);
      if (!target)
	return 0;

      TRY_CATCH (ex, RETURN_MASK_ERROR)
	{
	  /* We do not call target_translate_tls_address here, because
	     svr4_fetch_objfile_link_map may invalidate the frame chain,
	     which must not do while inside a frame sniffer.

	     Instead, we have cached the lm_addr value, and use that to
	     directly call the target's to_get_thread_local_address.  */
	  spe_context_cache_address
	    = target->to_get_thread_local_address (target, inferior_ptid,
						   spe_context_lm_addr,
						   spe_context_offset);
	  spe_context_cache_ptid = inferior_ptid;
	}

      if (ex.reason < 0)
	return 0;
    }

  /* Read variable value.  */
  if (target_read_memory (spe_context_cache_address, buf, wordsize) == 0)
    spe_context = extract_unsigned_integer (buf, wordsize, byte_order);

  /* Cyle through to N'th linked list element.  */
  for (i = 0; i < n && spe_context; i++)
    if (target_read_memory (spe_context + align_up (12, wordsize),
			    buf, wordsize) == 0)
      spe_context = extract_unsigned_integer (buf, wordsize, byte_order);
    else
      spe_context = 0;

  /* Read current context.  */
  if (spe_context
      && target_read_memory (spe_context, buf, 12) != 0)
    spe_context = 0;

  /* Extract data elements.  */
  if (spe_context)
    {
      if (id)
	*id = extract_signed_integer (buf, 4, byte_order);
      if (npc)
	*npc = extract_unsigned_integer (buf + 4, 4, byte_order);
    }

  return spe_context;
}


/* Cell/B.E. cross-architecture unwinder support.  */

struct ppu2spu_cache
{
  struct frame_id frame_id;
  struct regcache *regcache;
};

static struct gdbarch *
ppu2spu_prev_arch (struct frame_info *this_frame, void **this_cache)
{
  struct ppu2spu_cache *cache = *this_cache;
  return get_regcache_arch (cache->regcache);
}

static void
ppu2spu_this_id (struct frame_info *this_frame,
		 void **this_cache, struct frame_id *this_id)
{
  struct ppu2spu_cache *cache = *this_cache;
  *this_id = cache->frame_id;
}

static struct value *
ppu2spu_prev_register (struct frame_info *this_frame,
		       void **this_cache, int regnum)
{
  struct ppu2spu_cache *cache = *this_cache;
  struct gdbarch *gdbarch = get_regcache_arch (cache->regcache);
  gdb_byte *buf;

  buf = alloca (register_size (gdbarch, regnum));

  if (regnum < gdbarch_num_regs (gdbarch))
    regcache_raw_read (cache->regcache, regnum, buf);
  else
    gdbarch_pseudo_register_read (gdbarch, cache->regcache, regnum, buf);

  return frame_unwind_got_bytes (this_frame, regnum, buf);
}

struct ppu2spu_data
{
  struct gdbarch *gdbarch;
  int id;
  unsigned int npc;
  gdb_byte gprs[128*16];
};

static int
ppu2spu_unwind_register (void *src, int regnum, gdb_byte *buf)
{
  struct ppu2spu_data *data = src;
  enum bfd_endian byte_order = gdbarch_byte_order (data->gdbarch);

  if (regnum >= 0 && regnum < SPU_NUM_GPRS)
    memcpy (buf, data->gprs + 16*regnum, 16);
  else if (regnum == SPU_ID_REGNUM)
    store_unsigned_integer (buf, 4, byte_order, data->id);
  else if (regnum == SPU_PC_REGNUM)
    store_unsigned_integer (buf, 4, byte_order, data->npc);
  else
    return REG_UNAVAILABLE;

  return REG_VALID;
}

static int
ppu2spu_sniffer (const struct frame_unwind *self,
		 struct frame_info *this_frame, void **this_prologue_cache)
{
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  struct ppu2spu_data data;
  struct frame_info *fi;
  CORE_ADDR base, func, backchain, spe_context;
  gdb_byte buf[8];
  int n = 0;

  /* Count the number of SPU contexts already in the frame chain.  */
  for (fi = get_next_frame (this_frame); fi; fi = get_next_frame (fi))
    if (get_frame_type (fi) == ARCH_FRAME
	&& gdbarch_bfd_arch_info (get_frame_arch (fi))->arch == bfd_arch_spu)
      n++;

  base = get_frame_sp (this_frame);
  func = get_frame_pc (this_frame);
  if (target_read_memory (base, buf, tdep->wordsize))
    return 0;
  backchain = extract_unsigned_integer (buf, tdep->wordsize, byte_order);

  spe_context = ppc_linux_spe_context (tdep->wordsize, byte_order,
				       n, &data.id, &data.npc);
  if (spe_context && base <= spe_context && spe_context < backchain)
    {
      char annex[32];

      /* Find gdbarch for SPU.  */
      struct gdbarch_info info;
      gdbarch_info_init (&info);
      info.bfd_arch_info = bfd_lookup_arch (bfd_arch_spu, bfd_mach_spu);
      info.byte_order = BFD_ENDIAN_BIG;
      info.osabi = GDB_OSABI_LINUX;
      info.tdep_info = (void *) &data.id;
      data.gdbarch = gdbarch_find_by_info (info);
      if (!data.gdbarch)
	return 0;

      xsnprintf (annex, sizeof annex, "%d/regs", data.id);
      if (target_read (&current_target, TARGET_OBJECT_SPU, annex,
		       data.gprs, 0, sizeof data.gprs)
	  == sizeof data.gprs)
	{
	  struct ppu2spu_cache *cache
	    = FRAME_OBSTACK_CALLOC (1, struct ppu2spu_cache);

	  struct address_space *aspace = get_frame_address_space (this_frame);
	  struct regcache *regcache = regcache_xmalloc (data.gdbarch, aspace);
	  struct cleanup *cleanups = make_cleanup_regcache_xfree (regcache);
	  regcache_save (regcache, ppu2spu_unwind_register, &data);
	  discard_cleanups (cleanups);

	  cache->frame_id = frame_id_build (base, func);
	  cache->regcache = regcache;
	  *this_prologue_cache = cache;
	  return 1;
	}
    }

  return 0;
}

static void
ppu2spu_dealloc_cache (struct frame_info *self, void *this_cache)
{
  struct ppu2spu_cache *cache = this_cache;
  regcache_xfree (cache->regcache);
}

static const struct frame_unwind ppu2spu_unwind = {
  ARCH_FRAME,
  default_frame_unwind_stop_reason,
  ppu2spu_this_id,
  ppu2spu_prev_register,
  NULL,
  ppu2spu_sniffer,
  ppu2spu_dealloc_cache,
  ppu2spu_prev_arch,
};


static void
ppc_linux_init_abi (struct gdbarch_info info,
                    struct gdbarch *gdbarch)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  struct tdesc_arch_data *tdesc_data = (void *) info.tdep_info;

  linux_init_abi (info, gdbarch);

  /* PPC GNU/Linux uses either 64-bit or 128-bit long doubles; where
     128-bit, they are IBM long double, not IEEE quad long double as
     in the System V ABI PowerPC Processor Supplement.  We can safely
     let them default to 128-bit, since the debug info will give the
     size of type actually used in each case.  */
  set_gdbarch_long_double_bit (gdbarch, 16 * TARGET_CHAR_BIT);
  set_gdbarch_long_double_format (gdbarch, floatformats_ibm_long_double);

  /* Handle inferior calls during interrupted system calls.  */
  set_gdbarch_write_pc (gdbarch, ppc_linux_write_pc);

  /* Get the syscall number from the arch's register.  */
  set_gdbarch_get_syscall_number (gdbarch, ppc_linux_get_syscall_number);

  /* SystemTap functions.  */
  set_gdbarch_stap_integer_prefix (gdbarch, "i");
  set_gdbarch_stap_register_indirection_prefix (gdbarch, "(");
  set_gdbarch_stap_register_indirection_suffix (gdbarch, ")");
  set_gdbarch_stap_gdb_register_prefix (gdbarch, "r");
  set_gdbarch_stap_is_single_operand (gdbarch, ppc_stap_is_single_operand);
  set_gdbarch_stap_parse_special_token (gdbarch,
					ppc_stap_parse_special_token);

  if (tdep->wordsize == 4)
    {
      /* Until November 2001, gcc did not comply with the 32 bit SysV
	 R4 ABI requirement that structures less than or equal to 8
	 bytes should be returned in registers.  Instead GCC was using
	 the AIX/PowerOpen ABI - everything returned in memory
	 (well ignoring vectors that is).  When this was corrected, it
	 wasn't fixed for GNU/Linux native platform.  Use the
	 PowerOpen struct convention.  */
      set_gdbarch_return_value (gdbarch, ppc_linux_return_value);

      set_gdbarch_memory_remove_breakpoint (gdbarch,
                                            ppc_linux_memory_remove_breakpoint);

      /* Shared library handling.  */
      set_gdbarch_skip_trampoline_code (gdbarch, ppc_skip_trampoline_code);
      set_solib_svr4_fetch_link_map_offsets
        (gdbarch, svr4_ilp32_fetch_link_map_offsets);

      /* Setting the correct XML syscall filename.  */
      set_xml_syscall_file_name (XML_SYSCALL_FILENAME_PPC);

      /* Trampolines.  */
      tramp_frame_prepend_unwinder (gdbarch,
				    &ppc32_linux_sigaction_tramp_frame);
      tramp_frame_prepend_unwinder (gdbarch,
				    &ppc32_linux_sighandler_tramp_frame);

      /* BFD target for core files.  */
      if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_LITTLE)
	set_gdbarch_gcore_bfd_target (gdbarch, "elf32-powerpcle");
      else
	set_gdbarch_gcore_bfd_target (gdbarch, "elf32-powerpc");

      /* Supported register sections.  */
      if (tdesc_find_feature (info.target_desc,
			      "org.gnu.gdb.power.vsx"))
	set_gdbarch_core_regset_sections (gdbarch,
					  ppc_linux_vsx_regset_sections);
      else if (tdesc_find_feature (info.target_desc,
			       "org.gnu.gdb.power.altivec"))
	set_gdbarch_core_regset_sections (gdbarch,
					  ppc_linux_vmx_regset_sections);
      else
	set_gdbarch_core_regset_sections (gdbarch,
					  ppc_linux_fp_regset_sections);

      if (powerpc_so_ops.in_dynsym_resolve_code == NULL)
	{
	  powerpc_so_ops = svr4_so_ops;
	  /* Override dynamic resolve function.  */
	  powerpc_so_ops.in_dynsym_resolve_code =
	    powerpc_linux_in_dynsym_resolve_code;
	}
      set_solib_ops (gdbarch, &powerpc_so_ops);

      set_gdbarch_skip_solib_resolver (gdbarch, glibc_skip_solib_resolver);
    }
  
  if (tdep->wordsize == 8)
    {
      /* Handle PPC GNU/Linux 64-bit function pointers (which are really
	 function descriptors).  */
      set_gdbarch_convert_from_func_ptr_addr
	(gdbarch, ppc64_convert_from_func_ptr_addr);

      set_gdbarch_elf_make_msymbol_special (gdbarch,
					    ppc64_elf_make_msymbol_special);

      /* Shared library handling.  */
      set_gdbarch_skip_trampoline_code (gdbarch, ppc64_skip_trampoline_code);
      set_solib_svr4_fetch_link_map_offsets
        (gdbarch, svr4_lp64_fetch_link_map_offsets);

      /* Setting the correct XML syscall filename.  */
      set_xml_syscall_file_name (XML_SYSCALL_FILENAME_PPC64);

      /* Trampolines.  */
      tramp_frame_prepend_unwinder (gdbarch,
				    &ppc64_linux_sigaction_tramp_frame);
      tramp_frame_prepend_unwinder (gdbarch,
				    &ppc64_linux_sighandler_tramp_frame);

      /* BFD target for core files.  */
      if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_LITTLE)
	set_gdbarch_gcore_bfd_target (gdbarch, "elf64-powerpcle");
      else
	set_gdbarch_gcore_bfd_target (gdbarch, "elf64-powerpc");

      /* Supported register sections.  */
      if (tdesc_find_feature (info.target_desc,
			      "org.gnu.gdb.power.vsx"))
	set_gdbarch_core_regset_sections (gdbarch,
					  ppc64_linux_vsx_regset_sections);
      else if (tdesc_find_feature (info.target_desc,
			       "org.gnu.gdb.power.altivec"))
	set_gdbarch_core_regset_sections (gdbarch,
					  ppc64_linux_vmx_regset_sections);
      else
	set_gdbarch_core_regset_sections (gdbarch,
					  ppc64_linux_fp_regset_sections);
    }

  /* PPC32 uses a different prpsinfo32 compared to most other Linux
     archs.  */
  if (tdep->wordsize == 4)
    set_gdbarch_elfcore_write_linux_prpsinfo (gdbarch,
					      elfcore_write_ppc_linux_prpsinfo32);

  set_gdbarch_regset_from_core_section (gdbarch,
					ppc_linux_regset_from_core_section);
  set_gdbarch_core_read_description (gdbarch, ppc_linux_core_read_description);

  /* Enable TLS support.  */
  set_gdbarch_fetch_tls_load_module_address (gdbarch,
                                             svr4_fetch_objfile_link_map);

  if (tdesc_data)
    {
      const struct tdesc_feature *feature;

      /* If we have target-described registers, then we can safely
         reserve a number for PPC_ORIG_R3_REGNUM and PPC_TRAP_REGNUM
	 (whether they are described or not).  */
      gdb_assert (gdbarch_num_regs (gdbarch) <= PPC_ORIG_R3_REGNUM);
      set_gdbarch_num_regs (gdbarch, PPC_TRAP_REGNUM + 1);

      /* If they are present, then assign them to the reserved number.  */
      feature = tdesc_find_feature (info.target_desc,
                                    "org.gnu.gdb.power.linux");
      if (feature != NULL)
	{
	  tdesc_numbered_register (feature, tdesc_data,
				   PPC_ORIG_R3_REGNUM, "orig_r3");
	  tdesc_numbered_register (feature, tdesc_data,
				   PPC_TRAP_REGNUM, "trap");
	}
    }

  /* Enable Cell/B.E. if supported by the target.  */
  if (tdesc_compatible_p (info.target_desc,
			  bfd_lookup_arch (bfd_arch_spu, bfd_mach_spu)))
    {
      /* Cell/B.E. multi-architecture support.  */
      set_spu_solib_ops (gdbarch);

      /* Cell/B.E. cross-architecture unwinder support.  */
      frame_unwind_prepend_unwinder (gdbarch, &ppu2spu_unwind);

      /* The default displaced_step_at_entry_point doesn't work for
	 SPU stand-alone executables.  */
      set_gdbarch_displaced_step_location (gdbarch,
					   ppc_linux_displaced_step_location);
    }

  set_gdbarch_get_siginfo_type (gdbarch, linux_get_siginfo_type);
}

/* Provide a prototype to silence -Wmissing-prototypes.  */
extern initialize_file_ftype _initialize_ppc_linux_tdep;

void
_initialize_ppc_linux_tdep (void)
{
  /* Register for all sub-familes of the POWER/PowerPC: 32-bit and
     64-bit PowerPC, and the older rs6k.  */
  gdbarch_register_osabi (bfd_arch_powerpc, bfd_mach_ppc, GDB_OSABI_LINUX,
                         ppc_linux_init_abi);
  gdbarch_register_osabi (bfd_arch_powerpc, bfd_mach_ppc64, GDB_OSABI_LINUX,
                         ppc_linux_init_abi);
  gdbarch_register_osabi (bfd_arch_rs6000, bfd_mach_rs6k, GDB_OSABI_LINUX,
                         ppc_linux_init_abi);

  /* Attach to inferior_created observer.  */
  observer_attach_inferior_created (ppc_linux_inferior_created);

  /* Attach to observers to track __spe_current_active_context.  */
  observer_attach_inferior_created (ppc_linux_spe_context_inferior_created);
  observer_attach_solib_loaded (ppc_linux_spe_context_solib_loaded);
  observer_attach_solib_unloaded (ppc_linux_spe_context_solib_unloaded);

  /* Initialize the Linux target descriptions.  */
  initialize_tdesc_powerpc_32l ();
  initialize_tdesc_powerpc_altivec32l ();
  initialize_tdesc_powerpc_cell32l ();
  initialize_tdesc_powerpc_vsx32l ();
  initialize_tdesc_powerpc_isa205_32l ();
  initialize_tdesc_powerpc_isa205_altivec32l ();
  initialize_tdesc_powerpc_isa205_vsx32l ();
  initialize_tdesc_powerpc_64l ();
  initialize_tdesc_powerpc_altivec64l ();
  initialize_tdesc_powerpc_cell64l ();
  initialize_tdesc_powerpc_vsx64l ();
  initialize_tdesc_powerpc_isa205_64l ();
  initialize_tdesc_powerpc_isa205_altivec64l ();
  initialize_tdesc_powerpc_isa205_vsx64l ();
  initialize_tdesc_powerpc_e500l ();
}
@


1.146
log
@ppc-linux-tdep.c: Wrong signness for buffer holding instructions.

There seems to be no reason for this buffer to be signed.  We pass it
around to functions expecting it to be unsigned (which triggers
-Wpointer-sign warnings).

gdb/
2013-04-19  Pedro Alves  <palves@@redhat.com>

	* ppc-linux-tdep.c (ppc_skip_trampoline_code): Change local
	'insnbuf' buffer type to unsigned int[].
@
text
@d364 1
a364 1
  if (ppc_insns_match_pattern (pc, powerpc32_plt_stub, insnbuf))
d376 1
a376 1
  if (ppc_insns_match_pattern (pc, powerpc32_plt_stub_so, insnbuf))
@


1.145
log
@	* minsyms.h (struct bound_minimal_symbol): New.
	(lookup_minimal_symbol_and_objfile): Return bound_minimal_symbol.
	Remove objfile argument.
	(lookup_minimal_symbol_by_pc_section, lookup_minimal_symbol_by_pc):
	Return bound_minimal_symbol.
	* minsyms.c (lookup_minimal_symbol_by_pc_1)
	(lookup_minimal_symbol_by_pc_section, lookup_minimal_symbol_by_pc):
	Return bound_minimal_symbol.
	(in_gnu_ifunc_stub): Update.
	(lookup_minimal_symbol_and_objfile): Return bound_minimal_symbol.
	Remove 'objfile_p' argument.
	(lookup_solib_trampoline_symbol_by_pc): Update.
	* ada-tasks.c, amd64-windows-tdep.c, arm-tdep.c,
	arm-wince-tdep.c, block.c, blockframe.c, breakpoint.c, btrace.c,
	c-valprint.c, dwarf2loc.c, elfread.c, frame.c, frv-tdep.c,
	glibc-tdep.c, gnu-v2-abi.c, gnu-v3-abi.c, hppa-hpux-tdep.c,
	i386-tdep.c, ia64-tdep.c, infcall.c, infcmd.c, jit.c,
	linux-fork.c, m32c-tdep.c, m68hc11-tdep.c, maint.c,
	mips-tdep.c, p-valprint.c, parse.c, ppc-linux-tdep.c,
	ppc-sysv-tdep.c, printcmd.c, rs6000-tdep.c, sh64-tdep.c,
	stack.c, symtab.c, tui/tui-disasm.c: Update.
@
text
@d358 1
a358 1
  int insnbuf[POWERPC32_PLT_STUB_LEN];
@


1.144
log
@	* elfread.c (elf_symtab_read): Do not use udata.p here to find
	symbol size.
	* ppc64-tdep.c (ppc64_elf_make_msymbol_special): New function.
	* ppc64-tdep.h (ppc64_elf_make_msymbol_special): Declare.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Set up to use the above.
	* ppcfbsd-tdep.c (ppcfbsd_init_abi): Likewise.
@
text
@d335 1
a335 1
  struct minimal_symbol *sym;
d344 4
a347 3
  if (sym != NULL
      && (strcmp (SYMBOL_LINKAGE_NAME (sym), "__glink") == 0
	  || strcmp (SYMBOL_LINKAGE_NAME (sym), "__glink_PLTresolve") == 0))
@


1.143
log
@2013-02-04  Sergio Durigan Junior  <sergiodj@@redhat.com>
	    Denys Vlasenko  <dvlasenk@@redhat.com>
	    Pedro Alves  <palves@@redhat.com>

	* gdbarch.sh (elfcore_write_linux_prpsinfo): New F hook.
	(struct elf_internal_linux_prpsinfo): Forward declare.
	* gdbarch.h, gdbarch.c: Regenerate.
	* linux-tdep.c: Include `cli/cli-utils.h'.
	(linux_fill_prpsinfo): New function.
	(linux_make_corefile_notes): Use linux_fill_prpsinfo.  If there's
	an elfcore_write_linux_prpsinfo hook, use it, otherwise, use
	elfcore_write_linux_prpsinfo32 or elfcore_write_linux_prpsinfo64
	depending on gdbarch pointer bitness.
	* ppc-linux-tdep.c: Include elf-bfd.h.
	(ppc_linux_init_abi): Hook in elfcore_write_ppc_linux_prpsinfo32
	on 32-bit.
@
text
@d1339 3
@


1.142
log
@2013-02-01  Andreas Tobler  <andreast@@fgznet.ch>

	* Makefile.in (ALL_TARGET_OBS): Add ppc64-tdep.o.
	(HFILES_NO_SRCDIR): Add ppc64-tdep.h.
	(ALLDEPFILES): Add ppc64-tdep.c.
	* configure.tgt (powerpc-*-linux* | powerpc64-*-linux*): Add
	ppc64-tdep.o to gdb_target_obs.
	* ppc64-tdep.h: New file.
	* ppc64-tdep.c: New file.
	(insn_d, insn_ds, insn_xfx, ppc64_desc_entry_point): Move from
	ppc-linux-tdep.c to here.
	(PPC64_STANDARD_LINKAGE1_LEN, PPC64_STANDARD_LINKAGE2_LEN)
	(PPC64_STANDARD_LINKAGE2_LEN): Likewise and use ARRAY_SIZE macro.
	(ppc64_standard_linkage1_target, ppc64_standard_linkage2_target)
	(ppc64_standard_linkage3_target, ppc64_skip_trampoline_code): Move
	from ppc-linux-tdep.c to here.
	(ppc64_convert_from_func_ptr_addr): Rename from
	ppc64_linux_convert_from_func_ptr_addr to
	ppc64_convert_from_func_ptr_addr and move from ppc-linux-tdep.c to
	here.
	* rs6000-tdep.c:
	(read_insn): Move from ppc-linux-tdep.c to here.
	(insns_match_pattern, insn_d_field, insn_ds_field): Move
	from ppc-linux-tdep.c to here and rename them with the ppc_ prefix.
	* ppc-linux-tdep.c: Include ppc64-tdep.h.
	Removed above functions.
	(ppc_linux_init_abi): Adjust.
@
text
@d60 1
d1372 7
@


1.141
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d38 1
a257 271
/* Macros for matching instructions.  Note that, since all the
   operands are masked off before they're or-ed into the instruction,
   you can use -1 to make masks.  */

#define insn_d(opcd, rts, ra, d)                \
  ((((opcd) & 0x3f) << 26)                      \
   | (((rts) & 0x1f) << 21)                     \
   | (((ra) & 0x1f) << 16)                      \
   | ((d) & 0xffff))

#define insn_ds(opcd, rts, ra, d, xo)           \
  ((((opcd) & 0x3f) << 26)                      \
   | (((rts) & 0x1f) << 21)                     \
   | (((ra) & 0x1f) << 16)                      \
   | ((d) & 0xfffc)                             \
   | ((xo) & 0x3))

#define insn_xfx(opcd, rts, spr, xo)            \
  ((((opcd) & 0x3f) << 26)                      \
   | (((rts) & 0x1f) << 21)                     \
   | (((spr) & 0x1f) << 16)                     \
   | (((spr) & 0x3e0) << 6)                     \
   | (((xo) & 0x3ff) << 1))

/* Read a PPC instruction from memory.  PPC instructions are always
   big-endian, no matter what endianness the program is running in, so
   we can't use read_memory_integer or one of its friends here.  */
static unsigned int
read_insn (CORE_ADDR pc)
{
  unsigned char buf[4];

  read_memory (pc, buf, 4);
  return (buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | buf[3];
}


/* An instruction to match.  */
struct insn_pattern
{
  unsigned int mask;            /* mask the insn with this...  */
  unsigned int data;            /* ...and see if it matches this.  */
  int optional;                 /* If non-zero, this insn may be absent.  */
};

/* Return non-zero if the instructions at PC match the series
   described in PATTERN, or zero otherwise.  PATTERN is an array of
   'struct insn_pattern' objects, terminated by an entry whose mask is
   zero.

   When the match is successful, fill INSN[i] with what PATTERN[i]
   matched.  If PATTERN[i] is optional, and the instruction wasn't
   present, set INSN[i] to 0 (which is not a valid PPC instruction).
   INSN should have as many elements as PATTERN.  Note that, if
   PATTERN contains optional instructions which aren't present in
   memory, then INSN will have holes, so INSN[i] isn't necessarily the
   i'th instruction in memory.  */
static int
insns_match_pattern (CORE_ADDR pc,
                     struct insn_pattern *pattern,
                     unsigned int *insn)
{
  int i;

  for (i = 0; pattern[i].mask; i++)
    {
      insn[i] = read_insn (pc);
      if ((insn[i] & pattern[i].mask) == pattern[i].data)
        pc += 4;
      else if (pattern[i].optional)
        insn[i] = 0;
      else
        return 0;
    }

  return 1;
}


/* Return the 'd' field of the d-form instruction INSN, properly
   sign-extended.  */
static CORE_ADDR
insn_d_field (unsigned int insn)
{
  return ((((CORE_ADDR) insn & 0xffff) ^ 0x8000) - 0x8000);
}


/* Return the 'ds' field of the ds-form instruction INSN, with the two
   zero bits concatenated at the right, and properly
   sign-extended.  */
static CORE_ADDR
insn_ds_field (unsigned int insn)
{
  return ((((CORE_ADDR) insn & 0xfffc) ^ 0x8000) - 0x8000);
}


/* If DESC is the address of a 64-bit PowerPC GNU/Linux function
   descriptor, return the descriptor's entry point.  */
static CORE_ADDR
ppc64_desc_entry_point (struct gdbarch *gdbarch, CORE_ADDR desc)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  /* The first word of the descriptor is the entry point.  */
  return (CORE_ADDR) read_memory_unsigned_integer (desc, 8, byte_order);
}


/* Pattern for the standard linkage function.  These are built by
   build_plt_stub in elf64-ppc.c, whose GLINK argument is always
   zero.  */
static struct insn_pattern ppc64_standard_linkage1[] =
  {
    /* addis r12, r2, <any> */
    { insn_d (-1, -1, -1, 0), insn_d (15, 12, 2, 0), 0 },

    /* std r2, 40(r1) */
    { -1, insn_ds (62, 2, 1, 40, 0), 0 },

    /* ld r11, <any>(r12) */
    { insn_ds (-1, -1, -1, 0, -1), insn_ds (58, 11, 12, 0, 0), 0 },

    /* addis r12, r12, 1 <optional> */
    { insn_d (-1, -1, -1, -1), insn_d (15, 12, 12, 1), 1 },

    /* ld r2, <any>(r12) */
    { insn_ds (-1, -1, -1, 0, -1), insn_ds (58, 2, 12, 0, 0), 0 },

    /* addis r12, r12, 1 <optional> */
    { insn_d (-1, -1, -1, -1), insn_d (15, 12, 12, 1), 1 },

    /* mtctr r11 */
    { insn_xfx (-1, -1, -1, -1), insn_xfx (31, 11, 9, 467), 0 },

    /* ld r11, <any>(r12) <optional> */
    { insn_ds (-1, -1, -1, 0, -1), insn_ds (58, 11, 12, 0, 0), 1 },
      
    /* bctr */
    { -1, 0x4e800420, 0 },

    { 0, 0, 0 }
  };
#define PPC64_STANDARD_LINKAGE1_LEN \
  (sizeof (ppc64_standard_linkage1) / sizeof (ppc64_standard_linkage1[0]))

static struct insn_pattern ppc64_standard_linkage2[] =
  {
    /* addis r12, r2, <any> */
    { insn_d (-1, -1, -1, 0), insn_d (15, 12, 2, 0), 0 },

    /* std r2, 40(r1) */
    { -1, insn_ds (62, 2, 1, 40, 0), 0 },

    /* ld r11, <any>(r12) */
    { insn_ds (-1, -1, -1, 0, -1), insn_ds (58, 11, 12, 0, 0), 0 },

    /* addi r12, r12, <any> <optional> */
    { insn_d (-1, -1, -1, 0), insn_d (14, 12, 12, 0), 1 },

    /* mtctr r11 */
    { insn_xfx (-1, -1, -1, -1), insn_xfx (31, 11, 9, 467), 0 },

    /* ld r2, <any>(r12) */
    { insn_ds (-1, -1, -1, 0, -1), insn_ds (58, 2, 12, 0, 0), 0 },

    /* ld r11, <any>(r12) <optional> */
    { insn_ds (-1, -1, -1, 0, -1), insn_ds (58, 11, 12, 0, 0), 1 },
      
    /* bctr */
    { -1, 0x4e800420, 0 },

    { 0, 0, 0 }
  };
#define PPC64_STANDARD_LINKAGE2_LEN \
  (sizeof (ppc64_standard_linkage2) / sizeof (ppc64_standard_linkage2[0]))

static struct insn_pattern ppc64_standard_linkage3[] =
  {
    /* std r2, 40(r1) */
    { -1, insn_ds (62, 2, 1, 40, 0), 0 },

    /* ld r11, <any>(r2) */
    { insn_ds (-1, -1, -1, 0, -1), insn_ds (58, 11, 2, 0, 0), 0 },

    /* addi r2, r2, <any> <optional> */
    { insn_d (-1, -1, -1, 0), insn_d (14, 2, 2, 0), 1 },

    /* mtctr r11 */
    { insn_xfx (-1, -1, -1, -1), insn_xfx (31, 11, 9, 467), 0 },

    /* ld r11, <any>(r2) <optional> */
    { insn_ds (-1, -1, -1, 0, -1), insn_ds (58, 11, 2, 0, 0), 1 },
      
    /* ld r2, <any>(r2) */
    { insn_ds (-1, -1, -1, 0, -1), insn_ds (58, 2, 2, 0, 0), 0 },

    /* bctr */
    { -1, 0x4e800420, 0 },

    { 0, 0, 0 }
  };
#define PPC64_STANDARD_LINKAGE3_LEN \
  (sizeof (ppc64_standard_linkage3) / sizeof (ppc64_standard_linkage3[0]))


/* When the dynamic linker is doing lazy symbol resolution, the first
   call to a function in another object will go like this:

   - The user's function calls the linkage function:

     100007c4:	4b ff fc d5 	bl	10000498
     100007c8:	e8 41 00 28 	ld	r2,40(r1)

   - The linkage function loads the entry point (and other stuff) from
     the function descriptor in the PLT, and jumps to it:

     10000498:	3d 82 00 00 	addis	r12,r2,0
     1000049c:	f8 41 00 28 	std	r2,40(r1)
     100004a0:	e9 6c 80 98 	ld	r11,-32616(r12)
     100004a4:	e8 4c 80 a0 	ld	r2,-32608(r12)
     100004a8:	7d 69 03 a6 	mtctr	r11
     100004ac:	e9 6c 80 a8 	ld	r11,-32600(r12)
     100004b0:	4e 80 04 20 	bctr

   - But since this is the first time that PLT entry has been used, it
     sends control to its glink entry.  That loads the number of the
     PLT entry and jumps to the common glink0 code:

     10000c98:	38 00 00 00 	li	r0,0
     10000c9c:	4b ff ff dc 	b	10000c78

   - The common glink0 code then transfers control to the dynamic
     linker's fixup code:

     10000c78:	e8 41 00 28 	ld	r2,40(r1)
     10000c7c:	3d 82 00 00 	addis	r12,r2,0
     10000c80:	e9 6c 80 80 	ld	r11,-32640(r12)
     10000c84:	e8 4c 80 88 	ld	r2,-32632(r12)
     10000c88:	7d 69 03 a6 	mtctr	r11
     10000c8c:	e9 6c 80 90 	ld	r11,-32624(r12)
     10000c90:	4e 80 04 20 	bctr

   Eventually, this code will figure out how to skip all of this,
   including the dynamic linker.  At the moment, we just get through
   the linkage function.  */

/* If the current thread is about to execute a series of instructions
   at PC matching the ppc64_standard_linkage pattern, and INSN is the result
   from that pattern match, return the code address to which the
   standard linkage function will send them.  (This doesn't deal with
   dynamic linker lazy symbol resolution stubs.)  */
static CORE_ADDR
ppc64_standard_linkage1_target (struct frame_info *frame,
				CORE_ADDR pc, unsigned int *insn)
{
  struct gdbarch *gdbarch = get_frame_arch (frame);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  /* The address of the function descriptor this linkage function
     references.  */
  CORE_ADDR desc
    = ((CORE_ADDR) get_frame_register_unsigned (frame,
						tdep->ppc_gp0_regnum + 2)
       + (insn_d_field (insn[0]) << 16)
       + insn_ds_field (insn[2]));

  /* The first word of the descriptor is the entry point.  Return that.  */
  return ppc64_desc_entry_point (gdbarch, desc);
}

a305 37
static CORE_ADDR
ppc64_standard_linkage2_target (struct frame_info *frame,
				CORE_ADDR pc, unsigned int *insn)
{
  struct gdbarch *gdbarch = get_frame_arch (frame);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  /* The address of the function descriptor this linkage function
     references.  */
  CORE_ADDR desc
    = ((CORE_ADDR) get_frame_register_unsigned (frame,
						tdep->ppc_gp0_regnum + 2)
       + (insn_d_field (insn[0]) << 16)
       + insn_ds_field (insn[2]));

  /* The first word of the descriptor is the entry point.  Return that.  */
  return ppc64_desc_entry_point (gdbarch, desc);
}

static CORE_ADDR
ppc64_standard_linkage3_target (struct frame_info *frame,
				CORE_ADDR pc, unsigned int *insn)
{
  struct gdbarch *gdbarch = get_frame_arch (frame);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  /* The address of the function descriptor this linkage function
     references.  */
  CORE_ADDR desc
    = ((CORE_ADDR) get_frame_register_unsigned (frame,
						tdep->ppc_gp0_regnum + 2)
       + insn_ds_field (insn[1]));

  /* The first word of the descriptor is the entry point.  Return that.  */
  return ppc64_desc_entry_point (gdbarch, desc);
}

d307 1
a307 1
static struct insn_pattern powerpc32_plt_stub[] =
d317 1
a317 1
static struct insn_pattern powerpc32_plt_stub_so[] =
d362 1
a362 1
  if (insns_match_pattern (pc, powerpc32_plt_stub, insnbuf))
d369 2
a370 1
      target = (insn_d_field (insnbuf[0]) << 16) | insn_d_field (insnbuf[1]);
d374 1
a374 1
  if (insns_match_pattern (pc, powerpc32_plt_stub_so, insnbuf))
d381 1
a381 1
	       + insn_d_field (insnbuf[0]);
a387 103
/* Given that we've begun executing a call trampoline at PC, return
   the entry point of the function the trampoline will go to.  */
static CORE_ADDR
ppc64_skip_trampoline_code (struct frame_info *frame, CORE_ADDR pc)
{
  unsigned int ppc64_standard_linkage1_insn[PPC64_STANDARD_LINKAGE1_LEN];
  unsigned int ppc64_standard_linkage2_insn[PPC64_STANDARD_LINKAGE2_LEN];
  unsigned int ppc64_standard_linkage3_insn[PPC64_STANDARD_LINKAGE3_LEN];
  CORE_ADDR target;

  if (insns_match_pattern (pc, ppc64_standard_linkage1,
                           ppc64_standard_linkage1_insn))
    pc = ppc64_standard_linkage1_target (frame, pc,
					 ppc64_standard_linkage1_insn);
  else if (insns_match_pattern (pc, ppc64_standard_linkage2,
				ppc64_standard_linkage2_insn))
    pc = ppc64_standard_linkage2_target (frame, pc,
					 ppc64_standard_linkage2_insn);
  else if (insns_match_pattern (pc, ppc64_standard_linkage3,
				ppc64_standard_linkage3_insn))
    pc = ppc64_standard_linkage3_target (frame, pc,
					 ppc64_standard_linkage3_insn);
  else
    return 0;

  /* The PLT descriptor will either point to the already resolved target
     address, or else to a glink stub.  As the latter carry synthetic @@plt
     symbols, find_solib_trampoline_target should be able to resolve them.  */
  target = find_solib_trampoline_target (frame, pc);
  return target? target : pc;
}


/* Support for convert_from_func_ptr_addr (ARCH, ADDR, TARG) on PPC64
   GNU/Linux.

   Usually a function pointer's representation is simply the address
   of the function.  On GNU/Linux on the PowerPC however, a function
   pointer may be a pointer to a function descriptor.

   For PPC64, a function descriptor is a TOC entry, in a data section,
   which contains three words: the first word is the address of the
   function, the second word is the TOC pointer (r2), and the third word
   is the static chain value.

   Throughout GDB it is currently assumed that a function pointer contains
   the address of the function, which is not easy to fix.  In addition, the
   conversion of a function address to a function pointer would
   require allocation of a TOC entry in the inferior's memory space,
   with all its drawbacks.  To be able to call C++ virtual methods in
   the inferior (which are called via function pointers),
   find_function_addr uses this function to get the function address
   from a function pointer.

   If ADDR points at what is clearly a function descriptor, transform
   it into the address of the corresponding function, if needed.  Be
   conservative, otherwise GDB will do the transformation on any
   random addresses such as occur when there is no symbol table.  */

static CORE_ADDR
ppc64_linux_convert_from_func_ptr_addr (struct gdbarch *gdbarch,
					CORE_ADDR addr,
					struct target_ops *targ)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  struct target_section *s = target_section_by_addr (targ, addr);

  /* Check if ADDR points to a function descriptor.  */
  if (s && strcmp (s->the_bfd_section->name, ".opd") == 0)
    {
      /* There may be relocations that need to be applied to the .opd 
	 section.  Unfortunately, this function may be called at a time
	 where these relocations have not yet been performed -- this can
	 happen for example shortly after a library has been loaded with
	 dlopen, but ld.so has not yet applied the relocations.

	 To cope with both the case where the relocation has been applied,
	 and the case where it has not yet been applied, we do *not* read
	 the (maybe) relocated value from target memory, but we instead
	 read the non-relocated value from the BFD, and apply the relocation
	 offset manually.

	 This makes the assumption that all .opd entries are always relocated
	 by the same offset the section itself was relocated.  This should
	 always be the case for GNU/Linux executables and shared libraries.
	 Note that other kind of object files (e.g. those added via
	 add-symbol-files) will currently never end up here anyway, as this
	 function accesses *target* sections only; only the main exec and
	 shared libraries are ever added to the target.  */

      gdb_byte buf[8];
      int res;

      res = bfd_get_section_contents (s->bfd, s->the_bfd_section,
				      &buf, addr - s->addr, 8);
      if (res != 0)
	return extract_unsigned_integer (buf, 8, byte_order)
		- bfd_section_vma (s->bfd, s->the_bfd_section) + s->addr;
   }

  return addr;
}

d1336 1
a1336 1
	(gdbarch, ppc64_linux_convert_from_func_ptr_addr);
@


1.140
log
@	* ppc-linux-tdep.c (ppc64_standard_linkage1, ppc64_standard_linkage2,
	ppc64_standard_linkage3): Mark ld r11 instructions as optional,
	following the change in PLT call stubs on linker.
@
text
@d3 1
a3 2
   Copyright (C) 1986-1987, 1989, 1991-1997, 2000-2012 Free Software
   Foundation, Inc.
@


1.139
log
@gdb/
	Fix crash during stepping on ppc32.
	* ppc-linux-tdep.c (powerpc_linux_in_dynsym_resolve_code): Test NULL
	SYM.

gdb/testsuite/
	Fix crash during stepping on ppc32.
	* gdb.base/step-symless.c: New file.
	* gdb.base/step-symless.exp: New file.
@
text
@d393 2
a394 2
    /* ld r11, <any>(r12) */
    { insn_ds (-1, -1, -1, 0, -1), insn_ds (58, 11, 12, 0, 0), 0 },
d424 2
a425 2
    /* ld r11, <any>(r12) */
    { insn_ds (-1, -1, -1, 0, -1), insn_ds (58, 11, 12, 0, 0), 0 },
d449 2
a450 2
    /* ld r11, <any>(r2) */
    { insn_ds (-1, -1, -1, 0, -1), insn_ds (58, 11, 2, 0, 0), 0 },
@


1.138
log
@* ppc-linux-tdep.c (ppc_linux_init_abi): Register
linux_get_siginfo_type.
@
text
@d651 3
a653 2
  if ((strcmp (SYMBOL_LINKAGE_NAME (sym), "__glink") == 0)
      || (strcmp (SYMBOL_LINKAGE_NAME (sym), "__glink_PLTresolve") == 0))
@


1.137
log
@2012-05-18  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c:
	* avr-tdep.c:
	* ax-gdb.c:
	* bfin-linux-tdep.c:
	* breakpoint.c:
	* c-valprint.c:
	* cli/cli-cmds.c:
	* coffread.c:
	* cp-support.c:
	* cris-tdep.c:
	* dwarf2-frame-tailcall.c:
	* dwarf2-frame.c:
	* dwarf2expr.c:
	* dwarf2loc.c:
	* dwarf2read.c:
	* elfread.c:
	* eval.c:
	* expprint.c:
	* f-valprint.c:
	* frv-tdep.c:
	* h8300-tdep.c:
	* hppa-hpux-tdep.c:
	* hppa-tdep.c:
	* hppanbsd-tdep.c:
	* i386-nto-tdep.c:
	* i386-tdep.c:
	* i387-tdep.c:
	* ia64-tdep.c:
	* jit.c:
	* linespec.c:
	* linux-tdep.c:
	* lm32-tdep.c:
	* m2-valprint.c:
	* m32c-tdep.c:
	* m32r-rom.c:
	* m32r-tdep.c:
	* m68k-tdep.c:
	* m68klinux-tdep.c:
	* mi/mi-main.c:
	* microblaze-tdep.c:
	* mips-linux-tdep.c:
	* mips-tdep.c:
	* mn10300-tdep.c:
	* p-valprint.c:
	* parse.c:
	* ppc-linux-tdep.c:
	* ppc-sysv-tdep.c:
	* printcmd.c:
	* python/py-finishbreakpoint.c:
	* python/py-inferior.c:
	* python/py-infthread.c:
	* python/py-type.c:
	* python/python.c:
	* remote-fileio.c:
	* remote-m32r-sdi.c:
	* remote-mips.c:
	* reverse.c:
	* rl78-tdep.c:
	* rs6000-aix-tdep.c:
	* rs6000-tdep.c:
	* s390-tdep.c:
	* score-tdep.c:
	* sh64-tdep.c:
	* skip.c:
	* solib-darwin.c:
	* solib-dsbt.c:
	* solib-frv.c:
	* sparc-tdep.c:
	* spu-multiarch.c:
	* spu-tdep.c:
	* stack.c:
	* symfile.c:
	* symtab.c:
	* tic6x-tdep.c:
	* tracepoint.c:
	* v850-tdep.c:
	* valarith.c:
	* valprint.c:
	* value.c:
	* xcoffread.c:
	* xtensa-tdep.c:
	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c: Delete unused variables.
@
text
@d1825 2
@


1.137.2.1
log
@* ppc-linux-tdep.c (ppc_linux_init_abi): Register
linux_get_siginfo_type.
@
text
@a1824 2

  set_gdbarch_get_siginfo_type (gdbarch, linux_get_siginfo_type);
@


1.137.2.2
log
@gdb/
	Fix crash during stepping on ppc32.
	* ppc-linux-tdep.c (powerpc_linux_in_dynsym_resolve_code): Test NULL
	SYM.

gdb/testsuite/
	Fix crash during stepping on ppc32.
	* gdb.base/step-symless.c: New file.
	* gdb.base/step-symless.exp: New file.
@
text
@d651 2
a652 3
  if (sym != NULL
      && (strcmp (SYMBOL_LINKAGE_NAME (sym), "__glink") == 0
	  || strcmp (SYMBOL_LINKAGE_NAME (sym), "__glink_PLTresolve") == 0))
@


1.136
log
@	gdb/
	* breakpoint.h (bp_location): Add related_address member.
	* inferior.h (get_return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	* value.h (using_struct_return): Likewise.
	* gdbarch.sh (return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	* breakpoint.c (set_breakpoint_location_function): Initialize
	related_address for bp_gnu_ifunc_resolver breakpoints.
	* elfread.c (elf_gnu_ifunc_resolver_return_stop): Pass the
	requested function's address to gdbarch_return_value.
	* eval.c (evaluate_subexp_standard): Pass the requested
	function's address to using_struct_return.
	* infcall.c (call_function_by_hand): Pass the requested
	function's address to using_struct_return and
	gdbarch_return_value.
	* infcmd.c (get_return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	(print_return_value): Update accordingly.
	(finish_command_continuation): Likewise.
	* stack.c (return_command): Pass the requested function's
	address to using_struct_return and gdbarch_return_value.
	* value.c (using_struct_return): Take a pointer to struct value
	instead of struct type for the function requested.  Pass the
	requested function's address to gdbarch_return_value.
	* python/py-finishbreakpoint.c (finish_breakpoint_object):
	New function_value member, replacing function_type.
	(bpfinishpy_dealloc): Update accordingly.
	(bpfinishpy_pre_stop_hook): Likewise.
	(bpfinishpy_init): Likewise.  Record the requested function's
	address.
	* mips-tdep.c (mips_fval_reg): New enum.
	(mips_o32_push_dummy_call): For MIPS16 FP doubles do not swap
	words put in GP registers.
	(mips_o64_push_dummy_call): Update a comment.
	(mips_o32_return_value): Take a pointer to struct value instead
	of struct type for the function requested and use it to check if
	using the MIPS16 calling convention.  Return the designated
	general purpose registers for floating-point values returned in
	MIPS16 mode.
	(mips_o64_return_value): Likewise.
	* ppc-tdep.h (ppc_sysv_abi_return_value): Update prototype.
	(ppc_sysv_abi_broken_return_value): Likewise.
	(ppc64_sysv_abi_return_value): Likewise.
	* alpha-tdep.c (alpha_return_value): Take a pointer to struct
	value instead of struct type for the function requested.
	* amd64-tdep.c (amd64_return_value): Likewise.
	* amd64-windows-tdep.c (amd64_windows_return_value): Likewise.
	* arm-tdep.c (arm_return_value): Likewise.
	* avr-tdep.c (avr_return_value): Likewise.
	* bfin-tdep.c (bfin_return_value): Likewise.
	* cris-tdep.c (cris_return_value): Likewise.
	* frv-tdep.c (frv_return_value): Likewise.
	* h8300-tdep.c (h8300_return_value): Likewise.
	(h8300h_return_value): Likewise.
	* hppa-tdep.c (hppa32_return_value): Likewise.
	(hppa64_return_value): Likewise.
	* i386-tdep.c (i386_return_value): Likewise.
	* ia64-tdep.c (ia64_return_value): Likewise.
	* iq2000-tdep.c (iq2000_return_value): Likewise.
	* lm32-tdep.c (lm32_return_value): Likewise.
	* m32c-tdep.c (m32c_return_value): Likewise.
	* m32r-tdep.c (m32r_return_value): Likewise.
	* m68hc11-tdep.c (m68hc11_return_value): Likewise.
	* m68k-tdep.c (m68k_return_value): Likewise.
	(m68k_svr4_return_value): Likewise.
	* m88k-tdep.c (m88k_return_value): Likewise.
	* mep-tdep.c (mep_return_value): Likewise.
	* microblaze-tdep.c (microblaze_return_value): Likewise.
	* mn10300-tdep.c (mn10300_return_value): Likewise.
	* moxie-tdep.c (moxie_return_value): Likewise.
	* mt-tdep.c (mt_return_value): Likewise.
	* ppc-linux-tdep.c (ppc_linux_return_value): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_return_value): Likewise.
	(ppc_sysv_abi_broken_return_value): Likewise.
	(ppc64_sysv_abi_return_value): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_return_value): Likewise.
	* rl78-tdep.c (rl78_return_value): Likewise.
	* rs6000-aix-tdep.c (rs6000_return_value): Likewise.
	* rx-tdep.c (rx_return_value): Likewise.
	* s390-tdep.c (s390_return_value): Likewise.
	* score-tdep.c (score_return_value): Likewise.
	* sh-tdep.c (sh_return_value_nofpu): Likewise.
	(sh_return_value_fpu): Likewise.
	* sh64-tdep.c (sh64_return_value): Likewise.
	* sparc-tdep.c (sparc32_return_value): Likewise.
	* sparc64-tdep.c (sparc64_return_value): Likewise.
	* spu-tdep.c (spu_return_value): Likewise.
	* tic6x-tdep.c (tic6x_return_value): Likewise.
	* v850-tdep.c (v850_return_value): Likewise.
	* vax-tdep.c (vax_return_value): Likewise.
	* xstormy16-tdep.c (xstormy16_return_value): Likewise.
	* xtensa-tdep.c (xtensa_return_value): Likewise.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.

	gdb/testsuite/
	* gdb.base/return-nodebug.exp: Also test float and double types.
@
text
@a641 1
  struct objfile *objfile;
@


1.135
log
@2012-04-27  Sergio Durigan Junior  <sergiodj@@redhat.com>
	    Tom Tromey  <tromey@@redhat.com>
	    Jan Kratochvil  <jan.kratochvil@@redhat.com>

	* Makefile.in (SFILES): Add `probe' and `stap-probe'.
	(COMMON_OBS): Likewise.
	(HFILES_NO_SRCDIR): Add `probe'.
	* NEWS: Mention support for static and SystemTap probes.
	* amd64-tdep.c (amd64_init_abi): Initializing proper fields used by
	SystemTap probes' arguments parser.
	* arm-linux-tdep.c: Including headers needed to perform the parsing
	of SystemTap probes' arguments.
	(arm_stap_is_single_operand): New function.
	(arm_stap_parse_special_token): Likewise.
	(arm_linux_init_abi): Initializing proper fields used by SystemTap
	probes' arguments parser.
	* ax-gdb.c (require_rvalue): Removing static declaration.
	(gen_expr): Likewise.
	* ax-gdb.h (gen_expr): Declaring function.
	(require_rvalue): Likewise.
	* breakpoint.c: Include `gdb_regex.h' and `probe.h'.
	(bkpt_probe_breakpoint_ops): New variable.
	(momentary_breakpoint_from_master): Set the `probe' value.
	(add_location_to_breakpoint): Likewise.
	(break_command_1): Using proper breakpoint_ops according to the
	argument passed by the user in the command line.
	(bkpt_probe_insert_location): New function.
	(bkpt_probe_remove_location): Likewise.
	(bkpt_probe_create_sals_from_address): Likewise.
	(bkpt_probe_decode_linespec): Likewise.
	(tracepoint_probe_create_sals_from_address): Likewise.
	(tracepoint_probe_decode_linespec): Likewise.
	(tracepoint_probe_breakpoint_ops): New variable.
	(trace_command): Using proper breakpoint_ops according to the
	argument passed by the user in the command line.
	(initialize_breakpoint_ops): Initializing breakpoint_ops for
	static probes on breakpoints and tracepoints.
	* breakpoint.h (struct bp_location) <probe>: New field.
	* cli-utils.c (skip_spaces_const): New function.
	(extract_arg): Likewise.
	* cli-utils.h (skip_spaces_const): Likewise.
	(extract_arg): Likewise.
	* coffread.c (coff_sym_fns): Add `sym_probe_fns' value.
	* configure.ac: Append `stap-probe.o' to be generated when ELF
	support is present.
	* configure: Regenerate.
	* dbxread.c (aout_sym_fns): Add `sym_probe_fns' value.
	* elfread.c: Include `probe.h' and `arch-utils.h'.
	(probe_key): New variable.
	(elf_get_probes): New function.
	(elf_get_probe_argument_count): Likewise.
	(elf_evaluate_probe_argument): Likewise.
	(elf_compile_to_ax): Likewise.
	(elf_symfile_relocate_probe): Likewise.
	(stap_probe_key_free): Likewise.
	(elf_probe_fns): New variable.
	(elf_sym_fns): Add `sym_probe_fns' value.
	(elf_sym_fns_lazy_psyms): Likewise.
	(elf_sym_fns_gdb_index): Likewise.
	(_initialize_elfread): Initialize objfile cache for static
	probes.
	* gdb_vecs.h (struct probe): New forward declaration.
	(probe_p): New VEC declaration.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* gdbarch.sh (stap_integer_prefix): New variable.
	(stap_integer_suffix): Likewise.
	(stap_register_prefix): Likewise.
	(stap_register_suffix): Likewise.
	(stap_register_indirection_prefix): Likewise.
	(stap_register_indirection_suffix): Likewise.
	(stap_gdb_register_prefix): Likewise.
	(stap_gdb_register_suffix): Likewise.
	(stap_is_single_operand): New function.
	(stap_parse_special_token): Likewise.
	(struct stap_parse_info): Forward declaration.
	* i386-tdep.c: Including headers needed to perform the parsing
	of SystemTap probes' arguments.
	(i386_stap_is_single_operand): New function.
	(i386_stap_parse_special_token): Likewise.
	(i386_elf_init_abi): Initializing proper fields used by SystemTap
	probes' arguments parser.
	* i386-tdep.h (i386_stap_is_single_operand): New function.
	(i386_stap_parse_special_token): Likewise.
	* machoread.c (macho_sym_fns): Add `sym_probe_fns' value.
	* mipsread.c (ecoff_sym_fns): Likewise.
	* objfiles.c (objfile_relocate1): Support relocation for static
	probes.
	* parse.c (prefixify_expression): Remove static declaration.
	(initialize_expout): Likewise.
	(reallocate_expout): Likewise.
	* parser-defs.h (initialize_expout): Declare function.
	(reallocate_expout): Likewise.
	(prefixify_expression): Likewise.
	* ppc-linux-tdep.c: Including headers needed to perform the parsing
	of SystemTap probes' arguments.
	(ppc_stap_is_single_operand): New function.
	(ppc_stap_parse_special_token): Likewise.
	(ppc_linux_init_abi): Initializing proper fields used by SystemTap
	probes' arguments parser.
	* probe.c: New file, for generic statically defined probe support.
	* probe.h: Likewise.
	* s390-tdep.c: Including headers needed to perform the parsing of
	SystemTap probes' arguments.
	(s390_stap_is_single_operand): New function.
	(s390_gdbarch_init): Initializing proper fields used by SystemTap
	probes' arguments parser.
	* somread.c (som_sym_fns): Add `sym_probe_fns' value.
	* stap-probe.c: New file, for SystemTap probe support.
	* stap-probe.h: Likewise.
	* symfile.h: Include `gdb_vecs.h'.
	(struct sym_probe_fns): New struct.
	(struct sym_fns) <sym_probe_fns>: New field.
	* symtab.c (init_sal): Initialize `probe' field.
	* symtab.h (struct probe): Forward declaration.
	(struct symtab_and_line) <probe>: New field.
	* tracepoint.c (start_tracing): Adjust semaphore on breakpoints
	locations.
	(stop_tracing): Likewise.
	* xcoffread.c (xcoff_sym_fns): Add `sym_probe_fns' value.
@
text
@d244 1
a244 1
ppc_linux_return_value (struct gdbarch *gdbarch, struct type *func_type,
d254 1
a254 1
    return ppc_sysv_abi_return_value (gdbarch, func_type, valtype, regcache,
@


1.134
log
@Support stepping through PPC PLT with securePLT.

	* configure.tgt (powerpc-*-linux*): Add glibc-tdep.o.
	* ppc-linux-tdep.c: Include glibc-tdep.h.
	(powerpc32_plt_stub, powerpc32_plt_stub_so): Add PLT stub templates.
	(powerpc_linux_in_plt_stub): New function.
	(powerpc_linux_in_dynsym_resolve_code): New function.
	(ppc_skip_trampoline_code): New function.
	(ppc_linux_init_abi): Use PPC specific functions rather than generic.
	Use glibc_skip_solib_resolver.
@
text
@d53 8
d1287 69
d1673 9
@


1.133
log
@gdb/
	Revert:
	2012-01-02  Jan Kratochvil  <jan.kratochvil@@redhat.com>
		    Joel Brobecker  <brobecker@@adacore.com>
	Fix regression for gdb.cp/gdb2495.exp with gcc-4.7.
	* arch-utils.c (displaced_step_at_entry_point): Incrase BP_LEN skip to
	3 times.
	* infcall.c (call_function_by_hand) <AT_SYMBOL>: Move it upwards and
	fall through into AT_ENTRY_POINT.
	(call_function_by_hand) <AT_ENTRY_POINT>: New variable bp_len.  Adjust
	DUMMY_ADDR with it.
	* ppc-linux-tdep.c (ppc_linux_displaced_step_location): Increase
	PPC_INSN_SIZE skip to 3 times.
@
text
@d40 1
d69 3
d606 80
d1611 1
a1611 1
      set_gdbarch_skip_trampoline_code (gdbarch, find_solib_trampoline_target);
d1642 11
@


1.132
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d1077 1
a1077 1
      ppc_linux_entry_point_addr = addr + 3 * PPC_INSN_SIZE;
@


1.131
log
@gdb/
	Fix regression for gdb.cp/gdb2495.exp with gcc-4.7.
	* arch-utils.c (displaced_step_at_entry_point): Incrase BP_LEN skip to
	3 times.
	* infcall.c (call_function_by_hand) <AT_SYMBOL>: Move it upwards and
	fall through into AT_ENTRY_POINT.
	(call_function_by_hand) <AT_ENTRY_POINT>: New variable bp_len.  Adjust
	DUMMY_ADDR with it.
	* ppc-linux-tdep.c (ppc_linux_displaced_step_location): Increase
	PPC_INSN_SIZE skip to 3 times.
@
text
@d3 2
a4 3
   Copyright (C) 1986, 1987, 1989, 1991, 1992, 1993, 1994, 1995, 1996, 1997,
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.130
log
@2011-12-14  Pedro Alves  <pedro@@codesourcery.com>

	* ia64-tdep.c (ia64_memory_remove_breakpoint): Use
	target_write_raw_memory.
	* m32r-tdep.c (m32r_memory_remove_breakpoint): Use
	target_write_raw_memory.
	* microblaze-linux-tdep.c
	(microblaze_linux_memory_remove_breakpoint): Use
	target_write_raw_memory.
	* ppc-linux-tdep.c (ppc_linux_memory_remove_breakpoint): Use
	target_write_raw_memory.
@
text
@d1078 1
a1078 1
      ppc_linux_entry_point_addr = addr + 2 * PPC_INSN_SIZE;
@


1.129
log
@ChangeLog:

	* ppc-linux-tdep.c (ppu2spu_prev_register): Handle pseudo registers.
	(ppu2spu_unwind_register): Mark pseudo registers unavailable.
	* spu-tdep.c (op_selb): Use correct value.

testsuite/ChangeLog:

	* gdb.cell/bt.exp: Delete breakpoints before running to signal
	to avoid race condition.
	* gdb.cell/coremaker.c: Use small stack size.
	* gdb.cell/ea-standalone.exp: Use file name without path as
	argument to c_to.
	* gdb.cell/fork.exp: Allow other output when continuing to end.
@
text
@d221 1
a221 1
    val = target_write_memory (addr, bp_tgt->shadow_contents, bplen);
@


1.129.2.1
log
@2011-12-14  Pedro Alves  <pedro@@codesourcery.com>

	* ia64-tdep.c (ia64_memory_remove_breakpoint): Use
	target_write_raw_memory.
	* m32r-tdep.c (m32r_memory_remove_breakpoint): Use
	target_write_raw_memory.
	* microblaze-linux-tdep.c
	(microblaze_linux_memory_remove_breakpoint): Use
	target_write_raw_memory.
	* ppc-linux-tdep.c (ppc_linux_memory_remove_breakpoint): Use
	target_write_raw_memory.
@
text
@d221 1
a221 1
    val = target_write_raw_memory (addr, bp_tgt->shadow_contents, bplen);
@


1.129.2.2
log
@gdb/
	Fix regression for gdb.cp/gdb2495.exp with gcc-4.7.
	* arch-utils.c (displaced_step_at_entry_point): Incrase BP_LEN skip to
	3 times.
	* infcall.c (call_function_by_hand) <AT_SYMBOL>: Move it upwards and
	fall through into AT_ENTRY_POINT.
	(call_function_by_hand) <AT_ENTRY_POINT>: New variable bp_len.  Adjust
	DUMMY_ADDR with it.
	* ppc-linux-tdep.c (ppc_linux_displaced_step_location): Increase
	PPC_INSN_SIZE skip to 3 times.
@
text
@d1078 1
a1078 1
      ppc_linux_entry_point_addr = addr + 3 * PPC_INSN_SIZE;
@


1.129.2.3
log
@gdb/
	Revert:
	2012-01-02  Jan Kratochvil  <jan.kratochvil@@redhat.com>
		    Joel Brobecker  <brobecker@@adacore.com>
	Fix regression for gdb.cp/gdb2495.exp with gcc-4.7.
	* arch-utils.c (displaced_step_at_entry_point): Incrase BP_LEN skip to
	3 times.
	* infcall.c (call_function_by_hand) <AT_SYMBOL>: Move it upwards and
	fall through into AT_ENTRY_POINT.
	(call_function_by_hand) <AT_ENTRY_POINT>: New variable bp_len.  Adjust
	DUMMY_ADDR with it.
	* ppc-linux-tdep.c (ppc_linux_displaced_step_location): Increase
	PPC_INSN_SIZE skip to 3 times.
@
text
@d1078 1
a1078 1
      ppc_linux_entry_point_addr = addr + 2 * PPC_INSN_SIZE;
@


1.129.2.4
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 3
a5 2
   Copyright (C) 1986-1987, 1989, 1991-1997, 2000-2012 Free Software
   Foundation, Inc.
@


1.128
log
@	gdb/
	* frame.c (frame_unwind_register): Throw an error if unwinding the
	register failed.
	* get_prev_frame_1 (get_prev_frame_1): Ask the unwinder if there's
	an unwind stop reason.
	(frame_stop_reason_string): Handle UNWIND_UNAVAILABLE.
	* frame.h (enum unwind_stop_reason) <UNWIND_OUTERMOST,
	UNWIND_UNAVAILABLE>: New.
	* inline-frame.c (inline_frame_unwind): Install
	default_frame_unwind_stop_reason.
	* frame-unwind.c: Include "exceptions.h".
	(frame_unwind_find_by_frame): Swallow NOT_AVAILABLE_ERROR errors.
	(default_frame_unwind_stop_reason): New.
	* frame-unwind.h (frame_unwind_stop_reason_ftype): New typedef.
	(default_frame_unwind_stop_reason): Declare.
	(struct frame_unwind) <stop_reason>: New function pointer.

	* dummy-frame.c: Install default_frame_unwind_stop_reason.
	* dwarf2-frame.c: Include exceptions.h.
	(struct dwarf2_frame_cache) <unavailable_retaddr>: New field.
	(dwarf2_frame_cache): Swallow NOT_AVAILABLE_ERROR errors when
	computing the CFA.  If such an error was thrown, set
	unavailable_retaddr.
	(dwarf2_frame_unwind_stop_reason): New.
	(dwarf2_frame_this_id): Don't build a frame id if the CFA was
	unavailable.
	(dwarf2_frame_unwind): Install dwarf2_frame_unwind_stop_reason.
	(dwarf2_signal_frame_unwind): Ditto.

	* amd64-tdep.c: Include "exceptions.h".
	(struct amd64_frame_cache): New field "base_p".
	(amd64_init_frame_cache): Clear it.
	(amd64_frame_cache_1): New, factored out from amd64_frame_cache.
	Avoid reading registers with functions that throw if the register
	is not necessary to compute the frame base.
	(amd64_frame_cache): Reimplement wrapping amd64_frame_cache_1, and
	swallowing NOT_AVAILABLE_ERROR.
	(amd64_frame_unwind_stop_reason): New.
	(amd64_frame_this_id): Don't build a frame id if the frame base
	was unavailable.
	(amd64_frame_unwind): Install amd64_frame_unwind_stop_reason.
	(amd64_sigtramp_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(amd64_sigtramp_frame_unwind_stop_reason): New.
	(amd64_sigtramp_frame_this_id): Don't build a frame id if the
	frame base was unavailable.
	(amd64_sigtramp_frame_unwind): Install
	amd64_sigtramp_frame_unwind_stop_reason.
	(amd64_epilogue_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(amd64_epilogue_frame_unwind_stop_reason): New.
	(amd64_epilogue_frame_this_id): Don't build a frame id if the
	frame base was unavailable.
	(amd64_epilogue_frame_unwind): Install
	amd64_epilogue_frame_unwind_stop_reason.
	* i386-tdep.c: Include "exceptions.h".
	(struct i386_frame_cache): New field "base_p".
	(i386_init_frame_cache): Clear it.
	(i386_frame_cache_1): New, factored out from amd64_frame_cache.
	Avoid reading registers with functions that throw if the register
	is not necessary to compute the frame base.
	(i386_frame_cache): Reimplement wrapping amd64_frame_cache_1, and
	swallowing NOT_AVAILABLE_ERROR.
	(i386_frame_unwind_stop_reason): New.
	(i386_frame_this_id): Don't build a frame id if the frame base was
	unavailable.
	(i386_frame_prev_register): Handle unavailable SP.
	(i386_frame_unwind): Install i386_frame_unwind_stop_reason.
	(i386_epilogue_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(i386_epilogue_frame_unwind_stop_reason): New.
	(i386_epilogue_frame_this_id): Don't build a frame id if the frame
	base was unavailable.
	(i386_epilogue_frame_unwind): Install
	i386_epilogue_frame_unwind_stop_reason.
	(i386_sigtramp_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(i386_sigtramp_frame_unwind_stop_reason): New.
	(i386_sigtramp_frame_this_id): Don't build a frame id if the frame
	base was unavailable.
	(i386_sigtramp_frame_unwind): Install
	i386_sigtramp_frame_unwind_stop_reason.
	* sentinel-frame.c (sentinel_frame_prev_register): Use the value
	type's size, not the register's.
	(sentinel_frame_unwind): Install default_frame_unwind_stop_reason.

	* alpha-mdebug-tdep.c (alpha_mdebug_frame_unwind): Install
	default_frame_unwind_stop_reason.
	* alpha-tdep.c (alpha_sigtramp_frame_unwind)
	(alpha_heuristic_frame_unwind): Ditto.
	* amd64obsd-tdep.c (amd64obsd_trapframe_unwind): Ditto.
	* arm-tdep.c (arm_prologue_unwind, arm_stub_unwind): Ditto.
	* avr-tdep.c (avr_frame_unwind): Ditto.
	* cris-tdep.c (cris_sigtramp_frame_unwind, cris_frame_unwind):
	Ditto.
	* frv-linux-tdep.c (frv_linux_sigtramp_frame_unwind): Ditto.
	* frv-tdep.c (frv_frame_unwind): Ditto.
	* h8300-tdep.c (h8300_frame_unwind): Ditto.
	* hppa-hpux-tdep.c (hppa_hpux_sigtramp_frame_unwind): Ditto.
	* hppa-linux-tdep.c (hppa_linux_sigtramp_frame_unwind): Ditto.
	* hppa-tdep.c (hppa_frame_unwind, hppa_fallback_frame_unwind)
	(hppa_stub_frame_unwind): Ditto.
	* i386obsd-tdep.c (i386obsd_trapframe_unwind): Ditto.
	* ia64-tdep.c (ia64_frame_unwind, ia64_sigtramp_frame_unwind)
	(ia64_libunwind_frame_unwind)
	(ia64_libunwind_sigtramp_frame_unwind): Ditto.
	* iq2000-tdep.c (iq2000_frame_unwind): Ditto.
	* lm32-tdep.c (lm32_frame_unwind): Ditto.
	* m32c-tdep.c (m32c_unwind): Ditto.
	* m32r-linux-tdep.c (m32r_linux_sigtramp_frame_unwind): Ditto.
	* m32r-tdep.c (m32r_frame_unwind): Ditto.
	* m68hc11-tdep.c (m68hc11_frame_unwind): Ditto.
	* m68k-tdep.c (m68k_frame_unwind): Ditto.
	* m68klinux-tdep.c (m68k_linux_sigtramp_frame_unwind): Ditto.
	* m88k-tdep.c (m88k_frame_unwind): Ditto.
	* mep-tdep.c (mep_frame_unwind): Ditto.
	* microblaze-tdep.c (microblaze_frame_unwind): Ditto.
	* mips-tdep.c (mips_insn16_frame_unwind, mips_insn32_frame_unwind)
	(mips_stub_frame_unwind): Ditto.
	* mn10300-tdep.c (mn10300_frame_unwind): Ditto.
	* moxie-tdep.c (moxie_frame_unwind): Ditto.
	* mt-tdep.c (mt_frame_unwind): Ditto.
	* ppc-linux-tdep.c (ppu2spu_unwind): Ditto.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_unwind): Ditto.
	* rs6000-tdep.c (rs6000_frame_unwind): Ditto.
	* s390-tdep.c (s390_frame_unwind, s390_stub_frame_unwind)
	(s390_sigtramp_frame_unwind): Ditto.
	* score-tdep.c (score_prologue_unwind): Ditto.
	* sh-tdep.c (sh_frame_unwind): Ditto.
	* sh64-tdep.c (sh64_frame_unwind): Ditto.
	* sparc-sol2-tdep.c (sparc32_sol2_sigtramp_frame_unwind): Ditto.
	* sparc-tdep.c (sparc32_frame_unwind): Ditto.
	* sparc64-sol2-tdep.c (sparc64_sol2_sigtramp_frame_unwind): Ditto.
	* sparc64-tdep.c (sparc64_frame_unwind): Ditto.
	* sparc64fbsd-tdep.c (sparc64fbsd_sigtramp_frame_unwind): Ditto.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_frame_unwind): Ditto.
	* sparc64obsd-tdep.c (sparc64obsd_frame_unwind)
	(sparc64obsd_trapframe_unwind): Ditto.
	* sparcnbsd-tdep.c (sparc32nbsd_sigcontext_frame_unwind): Ditto.
	* sparcobsd-tdep.c (sparc32obsd_sigtramp_frame_unwind): Ditto.
	* spu-tdep.c (spu_frame_unwind, spu2ppu_unwind): Ditto.
	* v850-tdep.c (v850_frame_unwind): Ditto.
	* vax-tdep.c (vax_frame_unwind): Ditto.
	* vaxobsd-tdep.c (vaxobsd_sigtramp_frame_unwind): Ditto.
	* xstormy16-tdep.c (frame_unwind xstormy16_frame_unwind): Ditto.
	* xtensa-tdep.c (xtensa_unwind): Ditto.
@
text
@d1370 6
a1375 1
  regcache_cooked_read (cache->regcache, regnum, buf);
d1400 1
a1400 1
    return 0;
d1402 1
a1402 1
  return 1;
@


1.128.2.1
log
@ChangeLog:

	* ppc-linux-tdep.c (ppu2spu_prev_register): Handle pseudo registers.
	(ppu2spu_unwind_register): Mark pseudo registers unavailable.
	* spu-tdep.c (op_selb): Use correct value.

testsuite/ChangeLog:

	* gdb.cell/bt.exp: Delete breakpoints before running to signal
	to avoid race condition.
	* gdb.cell/coremaker.c: Use small stack size.
	* gdb.cell/ea-standalone.exp: Use file name without path as
	argument to c_to.
	* gdb.cell/fork.exp: Allow other output when continuing to end.
@
text
@d1370 1
a1370 6

  if (regnum < gdbarch_num_regs (gdbarch))
    regcache_raw_read (cache->regcache, regnum, buf);
  else
    gdbarch_pseudo_register_read (gdbarch, cache->regcache, regnum, buf);

d1395 1
a1395 1
    return REG_UNAVAILABLE;
d1397 1
a1397 1
  return REG_VALID;
@


1.127
log
@2011-02-27  Michael Snyder  <msnyder@@vmware.com>

	* darwin-nat-info.c: Fix comment typo.
	* dwarf2expr.h: Ditto.
	* fbsd-nat.c: Ditto.
	* fbsd-nat.h: Ditto.
	* frame-unwind.h: Ditto.
	* frame.h: Ditto.
	* hppa-hpux-tdep.c: Ditto.
	* i386-linux-nat.c: Ditto.
	* linux-nat.c: Ditto.
	* nbsd-nat.c: Ditto.
	* nbsd-nat.h: Ditto.
	* ppc-linux-tdep.c: Ditto.
	* serial.c: Ditto.
	* ui-file.h: Ditto.
	* tui/tui-winsource.c: Ditto.
@
text
@d1475 1
@


1.126
log
@2011-02-25  Michael Snyder  <msnyder@@vmware.com>

	* arm-tdep.c: Fix typos in comments.
	* bsd-uthread.c: Ditto.
	* completer.c: Ditto.
	* corelow.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* cris-tdep.c: Ditto.
	* dbxread.c: Ditto.
	* dwarf2read.c: Ditto.
	* frame.h: Ditto.
	* gdbtypes.h: Ditto.
	* inferior.h: Ditto.
	* mdebugread.c: Ditto.
	* mips-tdep.c: Ditto.
	* ppc-linux-nat.c: Ditto.
	* ppc-linux-tdep.c: Ditto.
	* printcmd.c: Ditto.
	* sol-thread.c: Ditto.
	* solib-frv.c: Ditto.
	* solist.h: Ditto.
	* sparc64-tdep.c: Ditto.
	* spu-tdep.c: Ditto.
	* stabsread.c: Ditto.
	* symfile.c: Ditto.
	* valops.c: Ditto.
	* varobj.c: Ditto.
	* vax-nat.c: Ditto.
	* python/py-block.c: Ditto.
	* python/py-symbol.c: Ditto.
	* python/py-symtab.c: Ditto.
	* python/py-value.c: Ditto.
	* tui/tui-win.c: Ditto.
@
text
@d170 1
a170 1
   executed as an instruction an an illegal instruction trap was
@


1.125
log
@2011-01-10  Michael Snyder  <msnyder@@vmware.com>

	* nto-procfs.c: Comment cleanup, mostly periods and spaces.
	* nto-tdep.c: Ditto.
	* nto-tdep.h: Ditto.
	* objc-exp.y: Ditto.
	* objc-lang.c: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* observer.c: Ditto.
	* opencl-lang.c: Ditto.
	* osabi.c: Ditto.
	* parse.c: Ditto.
	* parser-defs.h: Ditto.
	* p-exp.y: Ditto.
	* p-lang.c: Ditto.
	* posix-hdep.c: Ditto.
	* ppcbug-rom.c: Ditto.
	* ppc-linux-nat.c: Ditto.
	* ppc-linux-tdep.c: Ditto.
	* ppc-linux-tdep.h: Ditto.
	* ppcnbsd-tdep.c: Ditto.
	* ppcobsd-tdep.c: Ditto.
	* ppcobsd-tdep.h: Ditto.
	* ppc-sysv-tdep.c: Ditto.
	* ppc-tdep.h: Ditto.
	* printcmd.c: Ditto.
	* proc-abi.c: Ditto.
	* proc-flags.c: Ditto.
	* procfs.c: Ditto.
	* proc-utils.h: Ditto.
	* progspace.h: Ditto.
	* prologue-value.c: Ditto.
	* prologue-value.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* ravenscar-sparc-thread.c: Ditto.
	* ravenscar-thread.c: Ditto.
	* ravenscar-thread.h: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote.c: Ditto.
	* remote-fileio.c: Ditto.
	* remote-fileio.h: Ditto.
	* remote.h: Ditto.
	* remote-m32r-sdi.c: Ditto.
	* remote-mips.c: Ditto.
	* remote-sim.c: Ditto.
	* rs6000-aix-tdep.c: Ditto.
	* rs6000-nat.c: Ditto.
	* rs6000-tdep.c: Ditto.
@
text
@d1512 1
a1512 1
	 the the AIX/PowerOpen ABI - everything returned in memory
@


1.124
log
@run copyright.sh for 2011.
@
text
@d150 1
a150 1
	resolved to contain a branch that takes us directly to shr1. 
d161 1
a161 1
   trap instruction) on the zero value of the PLT entry for shr1. 
d184 1
a184 1
   a trap instruction, we allow the old contents to be written back. 
d219 1
a219 1
     old value */
d287 2
a288 2
  unsigned int mask;            /* mask the insn with this... */
  unsigned int data;            /* ...and see if it matches this. */
d915 2
a916 1
      trad_frame_set_reg_addr (this_cache, regnum, gpregs + i * tdep->wordsize);
d1530 4
a1533 2
      tramp_frame_prepend_unwinder (gdbarch, &ppc32_linux_sigaction_tramp_frame);
      tramp_frame_prepend_unwinder (gdbarch, &ppc32_linux_sighandler_tramp_frame);
d1571 4
a1574 2
      tramp_frame_prepend_unwinder (gdbarch, &ppc64_linux_sigaction_tramp_frame);
      tramp_frame_prepend_unwinder (gdbarch, &ppc64_linux_sighandler_tramp_frame);
d1595 2
a1596 1
  set_gdbarch_regset_from_core_section (gdbarch, ppc_linux_regset_from_core_section);
@


1.123
log
@	* corelow.c (core_pid_to_str): Default to using normal_pid_to_str
	instead of printing "Thread" here.
	* linux-tdep.c: Include inferior.h.
	(linux_core_pid_to_str): New.
	(linux_init_abi): New.
	* linux-tdep.h (linux_init_abi): Declare.
	* alpha-linux-tdep.c: Include linux-tdep.h.
	(alpha_linux_init_abi): Call linux_init_abi.
	* amd64-linux-tdep.c (amd64_linux_init_abi): Call linux_init_abi.
	* arm-linux-tdep.c (arm_linux_init_abi): Call linux_init_abi.
	* frv-linux-tdep.c: Include linux-tdep.h
	(frv_linux_init_abi): Call linux_init_abi.
	* hppa-linux-tdep.c: Include linux-tdep.h
	(hppa_linux_init_abi): Call linux_init_abi.
	* i386-linux-tdep.c (i386_linux_init_abi): Call linux_init_abi.
	* ia64-linux-tdep.c: Include linux-tdep.h.
	(ia64_linux_init_abi): Call linux_init_abi.
	* m32r-linux-tdep.c: Include linux-tdep.h.
	(m32r_linux_init_abi): Call linux_init_abi.
	* m68klinux-tdep.c: Include linux-tdep.h.
	(m68k_linux_init_abi): Call linux_init_abi.
	* microblaze-linux-tdep.c: Include linux-tdep.h.
	(microblaze_linux_init_abi): Call linux_init_abi.
	* mips-linux-tdep.c: Include linux-tdep.h.
	(mips_linux_init_abi): Call linux_init_abi.
	* mn10300-linux-tdep.c: Include linux-tdep.h.
	(am33_linux_init_osabi): Call linux_init_abi.  Rename the
	'gdbinfo' parameter to 'info'.
	* ppc-linux-tdep.c: Include linux-tdep.h.
	(ppc_linux_init_abi): Call linux_init_abi.
	* sh-linux-tdep.c: Include linux-tdep.h.
	(sh_linux_init_abi): Call linux_init_abi.
	* sparc-linux-tdep.c: Include linux-tdep.h.
	(sparc32_linux_init_abi): Call linux_init_abi.
	* sparc64-linux-tdep.c: Include linux-tdep.h.
	(sparc64_linux_init_abi): Call linux_init_abi.
	* xtensa-linux-tdep.c: Include linux-tdep.h.
	(xtensa_linux_init_abi): Call linux_init_abi.
	* i386-cygwin-tdep.c (i386_windows_core_pid_to_str): New.
	(i386_cygwin_init_abi): Install it as gdbarch_core_pid_to_str
	callback.
@
text
@d4 1
a4 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
@


1.122
log
@	* linux-nat.c (linux_nat_do_thread_registers): Use section size
	from gdbarch_core_regset_sections also for .reg if present.

	* amd64-linux-tdep.c (amd64_linux_regset_sections): Fix incorrect
	section size for .reg.
	* ppc-linux-tdep.c (ppc_linux_vsx_regset_sections): Likewise.
	(ppc_linux_vmx_regset_sections): Likewise.
	(ppc_linux_fp_regset_sections): Likewise.
	(ppc64_linux_vsx_regset_sections): New variable.
	(ppc64_linux_vmx_regset_sections): Likewise.
	(ppc64_linux_fp_regset_sections): Likewise.
	(ppc_linux_init_abi): Install core_regset_section lists appropriate
	for current word size.
@
text
@d51 1
d1490 2
@


1.121
log
@	* ppc-linux-tdep.c (bsd_uthread_solib_loaded): Always pass 0 for
	flags.
	* solib-spu.c (spu_solib_loaded): Always pass 0 for flags.
@
text
@d519 1
a519 1
  { ".reg", 268, "general-purpose" },
d528 1
a528 1
  { ".reg", 268, "general-purpose" },
d536 25
a560 1
  { ".reg", 268, "general-purpose" },
d1534 13
d1573 13
a1589 10
  /* Supported register sections.  */
  if (tdesc_find_feature (info.target_desc,
			  "org.gnu.gdb.power.vsx"))
    set_gdbarch_core_regset_sections (gdbarch, ppc_linux_vsx_regset_sections);
  else if (tdesc_find_feature (info.target_desc,
			       "org.gnu.gdb.power.altivec"))
    set_gdbarch_core_regset_sections (gdbarch, ppc_linux_vmx_regset_sections);
  else
    set_gdbarch_core_regset_sections (gdbarch, ppc_linux_fp_regset_sections);

@


1.120
log
@	* regcache.c (regcache_xmalloc): Add aspace argument.  Use it
	for the new regcache.  All callers updated.
	(regcache_cpy, regcache_cpy_no_passthrough): Do not set aspace here.
	(get_thread_arch_regcache): Do not set aspace here.
	* regcache.h (regcache_xmalloc): Update declaration.

	* frame.c, infcall.c, ppc-linux-tdep.c: Calls to
	regcache_xmalloc updated.
@
text
@d1225 1
a1225 1
      solib_read_symbols (so, so->from_tty ? SYMFILE_VERBOSE : 0);
@


1.119
log
@	* regset.h (struct core_regset_section): Add HUMAN_NAME.
	* i386-linux-tdep.c (i386_linux_regset_sections): Fill in HUMAN_NAME.
	* ppc-linux-tdep.c (ppc_linux_vsx_regset_sections): Likewise.
	(ppc_linux_vmx_regset_sections): Likewise.
	(ppc_linux_fp_regset_sections): Likewise.

	* corelow.c (get_core_register_section): Constify arguments.
	(get_core_registers): Use gdbarch_core_regset_sections instead
	of hard-coded platform-specific register section names.
@
text
@d1424 2
a1425 1
	  struct regcache *regcache = regcache_xmalloc (data.gdbarch);
@


1.118
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d519 4
a522 4
  { ".reg", 268 },
  { ".reg2", 264 },
  { ".reg-ppc-vmx", 544 },
  { ".reg-ppc-vsx", 256 },
d528 3
a530 3
  { ".reg", 268 },
  { ".reg2", 264 },
  { ".reg-ppc-vmx", 544 },
d536 2
a537 2
  { ".reg", 268 },
  { ".reg2", 264 },
@


1.117
log
@Implementing catch syscall.

* amd64-linux-tdep.c: Include xml-syscall.h header, define the XML
syscall name for the architecture.
(amd64_linux_get_syscall_number): New function.
(amd64_linux_init_abi): Register the correct functions for syscall
catchpoint; set the correct syscall file name.
* breakpoint.c: New include: xml-syscall.h.
(set_raw_breakpoint_without_location): Setting the parameters
for the catch syscall feature.
(insert_catch_syscall): New.
(remove_catch_syscall): New.
(breakpoint_hit_catch_syscall): New.
(print_it_catch_syscall): New.
(print_one_catch_syscall): New.
(print_mention_catch_syscall): New.
(catch_syscall_breakpoint_ops): New.
(syscall_catchpoint_p): New.
(create_catchpoint_without_mention): New.
(create_catchpoint): Modified in order to use
create_catchpoint_without_mention.
(create_syscall_event_catchpoint): New.
(clean_up_filters): New.
(catch_syscall_split_args): New.
(catch_syscall_command_1): New.
(delete_breakpoint): Add cleanup for catch syscall.
(is_syscall_catchpoint_enabled): New.
(catch_syscall_enabled): New.
(catching_syscall_number): New.
(catch_syscall_completer): New completer function.
(add_catch_command): Add the completer function for catchpoints.
* breakpoint.h (syscalls_to_be_caught): New vector.
(catch_syscall_enabled): New.
(catching_syscall_number): New.
* gdbarch.c: Regenerated.
* gdbarch.h: Regenerated.
* gdbarch.sh: Add syscall catchpoint functions and structures.
(get_syscall_number): New.
(UNKNOWN_SYSCALL): New definition.
* i386-linux-nat.c (i386_linux_resume): Select the proper request
to be made for ptrace() considering if we are catching syscalls
or not.
* i386-linux-tdep.c: Include xml-syscall.h header, define the XML
syscall name for the architecture.
(i386_linux_get_syscall_number): New.
(i386_linux_init_abi): Register the correct functions for syscall
catchpoint; set the correct syscall file name.
* inf-child.c (inf_child_set_syscall_catchpoint): New.
(inf_child_target): Assign default values to target_ops.
* inf-ptrace.c (inf_ptrace_resume): Select the proper request
to be made for ptrace() considering if we are catching syscalls
or not.
* inferior.h (struct inferior): Included new variables
any_syscall_count, syscalls_counts and total_syscalls_count,
used to keep track of requested syscall catchpoints.
* infrun.c (resume): Add syscall catchpoint.
(deal_with_syscall_event): New.
(handle_inferior_event): Add syscall entry/return events.
(inferior_has_called_syscall): New.
* linux-nat.c: Define some helpful variables to track wether we have
support for the needed ptrace option.
(linux_test_for_tracesysgood): New.
(linux_supports_tracesysgood): New.
(linux_enable_tracesysgood): New.
(linux_enable_event_reporting): Save the current used ptrace
options.
(linux_child_post_attach): Calling linux_enable_tracesysgood.
(linux_child_post_startup_inferior): Likewise.
(linux_child_set_syscall_catchpoint): New function.
(linux_handle_extended_wait): Handle the case which the inferior stops
because it has called or returned from a syscall.
(linux_target_install_ops): Install the necessary functions to handle
syscall catchpoints.
* linux-nat.h (struct lwp_info): Include syscall_state into the
structure, which indicates if we are in a syscall entry or return.
* ppc-linux-tdep.c: Include xml-syscall.h header, define the XML
syscall filename for the arch.
(ppc_linux_get_syscall_number): New.
(ppc_linux_init_abi): Register the correct functions for syscall
catchpoint; setting the correct name for the XML syscall file.
* target.c (update_current_target): Update/copy functions related to
syscall catchpoint.
(target_waitstatus_to_string): Add syscall catchpoint entry/return
events.
* target.h (struct target_waitstatus): Add syscall number.
(struct syscall): New struct to hold information about syscalls
in the system.
(struct target_ops): Add ops for syscall catchpoint.
(inferior_has_called_syscall): New.
(target_set_syscall_catchpoint): New.
* xml-support.c (xml_fetch_content_from_file): New function,
transferred from xml-tdesc.c.
* xml-support.h (xml_fetch_content_from_file): New.
* xml-tdesc.c (fetch_xml_from_file): Function removed;
transferred to xml-support.c.
(file_read_description_xml): Updated to use the new
xml_fetch_content_from_file function.
* syscalls/gdb-syscalls.dtd: New definition file for syscall's XML
support.
* syscalls/amd64-linux.xml: New file containing information about
syscalls for GNU/Linux systems that use amd64 architecture.
* syscalls/i386-linux.xml: New file containing information about
syscalls for GNU/Linux systems that use i386 architecture.
* syscalls/ppc-linux.xml: New file containing information about
syscalls for GNU/Linux systems that use PPC architecture.
* syscalls/ppc64-linux.xml: New file containing information about
syscalls for GNU/Linux systems that use PPC64 architecture.
* xml-syscall.c: New file containing functions for manipulating
syscall's XML files.
* xml-syscall.h: New file, exporting the functions above mentioned.
* Makefile.in: Support for relocatable GDB datadir and XML
syscall.
* NEWS: Added information about the catch syscall feature.
* doc/gdb.texinfo (Set Catchpoints): Documentation about the new
feature.
* testsuite/Makefile.in: Inclusion of catch-syscall object.
* testsuite/gdb.base/catch-syscall.c: New file.
* testsuite/gdb.base/catch-syscall.exp: New file.
@
text
@d4 1
a4 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
@


1.116
log
@	* ppc-linux-tdep.c: Include "solib.h", "solist.h", "exceptions.h",
	"arch-utils.h", and "spu-tdep.h".
	(spu_context_objfile, spe_context_lm_addr, spe_context_offset):
	New static variables.
	(spe_context_cache_ptid, spe_context_cache_address): Likewise.
	(ppc_linux_spe_context_lookup): New function.
	(ppc_linux_spe_context_inferior_created): Likewise.
	(ppc_linux_spe_context_solib_loaded): Likewise.
	(ppc_linux_spe_context_solib_unloaded): Likewise.
	(ppc_linux_spe_context): Likewise.
	(struct ppu2spu_cache, struct ppu2spu_data): New data types.
	(ppu2spu_prev_arch, ppu2spu_this_id, ppu2spu_prev_register,
	ppu2spu_unwind_register, ppu2spu_sniffer,
	ppu2spu_dealloc_cache): New functions.
	(ppu2spu_unwind): New static variable.
	(ppc_linux_init_abi): Install cross-architecture unwinder.
	(_initialize_ppc_linux_tdep): Attach to observers.

	* spu-tdep.c (struct spu2ppu_cache): New data type.
	(spu2ppu_prev_arch, spu2ppu_this_id, spu2ppu_prev_register,
	spu2ppu_sniffer, spu2ppu_dealloc_cache): New functions.
	(spu2ppu_unwind): New static variable.
	(spu_gdbarch_init): Install cross-architecture unwinder.
@
text
@d50 1
d68 3
d1073 33
d1475 3
d1497 3
d1523 3
@


1.115
log
@ChangeLog:

	* target.h (enum strata): New value arch_stratum.
	* target.c (target_require_runnable): Skip arch_stratum targets.

	* configure.tgt (powerpc-*-linux* | powerpc64-*-linux*): Add
	solib-spu.o and spu-multiarch.o to gdb_target_obs.
	* Makefile.in (ALL_TARGET_OBS): Add solib-spu.o and spu-multiarch.o.
	(ALLDEPFILES): Add solib-spu.c and spu-multiarch.c.

	* solib-spu.c: New file.
	* solib-spu.h: New file.
	* spu-multiarch.c: New file.

	* spu-tdep.h (SPUADDR, SPUADDR_SPU, SPUADDR_ADDR): New macros.

	* spu-tdep.c (struct gdbarch_tdep): New member id.
	(spu_gdbarch_id): New function.
	(spu_lslr): New function.

	(spu_address_to_pointer): New function.
	(spu_pointer_to_address): Support SPU ID address encoding.  Use
	spu_gdbarch_id and spu_lslr.
	(spu_integer_to_address): Likewise.
	(spu_frame_unwind_cache): Update for encoded addresses.
	(spu_unwind_pc, spu_unwind_sp): Likewise.
	(spu_read_pc, spu_write_pc): Likewise.
	(spu_push_dummy_call): Likewise.
	(spu_software_single_step): Likewise.
	(spu_get_longjmp_target): Likewise.
	(spu_overlay_update_osect): Likewise.

	(spu_dis_asm_print_address): New function.
	(gdb_print_insn_spu): Likewise.

	(spu_gdbarch_init): Store SPU ID in tdep structure.
	Install spu_address_to_pointer and gdb_print_insn_spu.

	* ppc-linux-tdep.c: Include "observer.h", "auxv.h", "elf/common.h"
	and "solib-spu.h".
	(ppc_linux_entry_point_addr): New static variable.
	(ppc_linux_inferior_created): New function.
	(ppc_linux_displaced_step_location): Likewise.
	(ppc_linux_init_abi): Enable Cell/B.E. support if supported
	by the target.
	(_initialize_ppc_linux_tdep): Attach to inferior_created observer.

	* NEWS: Mention multi-architecture and Cell/B.E. debugging
	capabilities.

testsuite/ChangeLog:

	* gdb.xml/tdesc-regs.exp: Skip for SPU targets.
@
text
@d37 2
d47 3
d1133 287
d1536 3
d1564 5
@


1.114
log
@ChangeLog:

	* features/Makefile: Allow sub-platform specific expedite settings.
	(WHICH): Add rs6000/powerpc-cell32l and rs6000/powerpc-cell64l.
	(rs6000/powerpc-cell32l-expedite): Define.
	(rs6000/powerpc-cell64l-expedite): Likewise.
	* features/rs6000/powerpc-cell32l.xml: New file.
	* features/rs6000/powerpc-cell64l.xml: New file.
	* features/rs6000/powerpc-cell32l.c: New generated file.
	* features/rs6000/powerpc-cell64l.c: New generated file.

	* regformats/rs6000/powerpc-cell32l.dat: New generated file.
	* regformats/rs6000/powerpc-cell64l.dat: New generated file.

	* config/djgpp/fnchange.lst: Add mappings for new files.

	* ppc-linux-tdep.h (tdesc_powerpc_cell32l): Add prototype.
	(tdesc_powerpc_cell64l): Likewise.
	* ppc-linux-tdep.c: Include "features/rs6000/powerpc-cell32l.c"
	and "features/rs6000/powerpc-cell64l.c".
	(_initialize_ppc_linux_tdep): Initialize target descriptions.
	(ppc_linux_spu_section): New function.
	(ppc_linux_core_read_description): Detect Cell/B.E. core files.
	* ppc-linux-nat.c (PPC_FEATURE_CELL): Define.
	(ppc_linux_read_description): Detect Cell/B.E. architecture.

	* rs6000-tdep.c (rs6000_gdbarch_init): Do not trust BFD wordsize
	if exec file is not PowerPC architecture.

gdbserver/ChangeLog:

	* configure.srv (powerpc*-*-linux*): Add powerpc-cell32l.o
	and powerpc-cell64l.o to srv_regobj.  Add rs6000/powerpc-cell32l.xml
	and rs6000/powerpc-cell64l.xml to srv_xmlfiles.
	* Makefile.in (powerpc-cell32l.o, powerpc-cell32l.c): New rules.
	(powerpc-cell64l.o, powerpc-cell64l.c): Likewise.
	(clean): Handle powerpc-cell32l.c and powerpc-cell64l.c.
	* linux-ppc-low.c (PPC_FEATURE_CELL): Define.
	(init_registers_powerpc_cell32l): Add prototype.
	(init_registers_powerpc_cell64l): Likewise.
	(ppc_arch_setup): Detect Cell/B.E. architecture.
@
text
@d36 1
d42 3
d1010 40
d1236 13
d1266 3
@


1.113
log
@	* defs.h (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.
	* findvar.c (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.

	* gdbcore.h (read_memory_integer, safe_read_memory_integer,
	read_memory_unsigned_integer, write_memory_signed_integer,
	write_memory_unsigned_integer): Add BYTE_ORDER parameter.
	* corefile.c (struct captured_read_memory_integer_arguments): Add
	BYTE_ORDER member.
	(safe_read_memory_integer): Add BYTE_ORDER parameter.  Store it into
	struct captured_read_memory_integer_arguments.
	(do_captured_read_memory_integer): Pass it to read_memory_integer.
	(read_memory_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_signed_integer.
	(read_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_unsigned_integer.
	(write_memory_signed_integer): Add BYTE_ORDER parameter.  Pass it
	to store_signed_integer.
	(write_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it
	to store_unsigned_integer.

	* target.h (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	* target.c (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	Pass it to extract_unsigned_integer.


	Update calls to extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer, read_memory_integer,
	read_memory_unsigned_integer, safe_read_memory_integer,
	write_memory_signed_integer, write_memory_unsigned_integer, and
	get_target_memory_unsigned to pass byte order:
	* ada-lang.c (ada_value_binop): Update.
	* ada-valprint.c (char_at): Update.
	* alpha-osf1-tdep.c (alpha_osf1_sigcontext_addr): Update.
	* alpha-tdep.c (alpha_lds, alpha_sts, alpha_push_dummy_call,
	alpha_extract_return_value, alpha_read_insn,
	alpha_get_longjmp_target): Update.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Update.
	* amd64obsd-tdep.c (amd64obsd_supply_uthread,
	amd64obsd_collect_uthread, amd64obsd_trapframe_cache): Update.
	* amd64-tdep.c (amd64_push_dummy_call, amd64_analyze_prologue,
	amd64_frame_cache, amd64_sigtramp_frame_cache, fixup_riprel,
	amd64_displaced_step_fixup): Update.
	* arm-linux-tdep.c (arm_linux_sigreturn_init,
	arm_linux_rt_sigreturn_init, arm_linux_supply_gregset): Update.
	* arm-tdep.c (thumb_analyze_prologue, arm_skip_prologue,
	arm_scan_prologue, arm_push_dummy_call, thumb_get_next_pc,
	arm_get_next_pc, arm_extract_return_value, arm_store_return_value,
	arm_return_value): Update.
	* arm-wince-tdep.c (arm_pe_skip_trampoline_code): Update.
	* auxv.c (default_auxv_parse): Update.
	* avr-tdep.c (avr_address_to_pointer, avr_pointer_to_address,
	avr_scan_prologue, avr_extract_return_value,
	avr_frame_prev_register, avr_push_dummy_call): Update.
	* bsd-uthread.c (bsd_uthread_check_magic, bsd_uthread_lookup_offset,
	bsd_uthread_wait, bsd_uthread_thread_alive,
	bsd_uthread_extra_thread_info): Update.
	* c-lang.c (c_printstr, print_wchar): Update.
	* cp-valprint.c (cp_print_class_member): Update.
	* cris-tdep.c (cris_sigcontext_addr, cris_sigtramp_frame_unwind_cache,
	cris_push_dummy_call, cris_scan_prologue, cris_store_return_value,
	cris_extract_return_value, find_step_target, dip_prefix,
	sixteen_bit_offset_branch_op, none_reg_mode_jump_op,
	move_mem_to_reg_movem_op, get_data_from_address): Update.
	* dwarf2expr.c (dwarf2_read_address, execute_stack_op): Update.
	* dwarf2-frame.c (execute_cfa_program): Update.
	* dwarf2loc.c (find_location_expression): Update.
	* dwarf2read.c (dwarf2_const_value): Update.
	* expprint.c (print_subexp_standard): Update.
	* findvar.c (unsigned_pointer_to_address, signed_pointer_to_address,
	unsigned_address_to_pointer, address_to_signed_pointer,
	read_var_value): Update.
	* frame.c (frame_unwind_register_signed,
	frame_unwind_register_unsigned, get_frame_memory_signed,
	get_frame_memory_unsigned): Update.
	* frame-unwind.c (frame_unwind_got_constant): Update.
	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp,
	frv_linux_sigcontext_reg_addr, frv_linux_sigtramp_frame_cache):
	Update.
	* frv-tdep.c (frv_analyze_prologue, frv_skip_main_prologue,
	frv_extract_return_value, find_func_descr,
	frv_convert_from_func_ptr_addr, frv_push_dummy_call): Update.
	* f-valprint.c (f_val_print): Update.
	* gnu-v3-abi.c (gnuv3_decode_method_ptr, gnuv3_make_method_ptr):
	Update.
	* h8300-tdep.c (h8300_is_argument_spill, h8300_analyze_prologue,
	h8300_push_dummy_call, h8300_extract_return_value,
	h8300h_extract_return_value, h8300_store_return_value,
	h8300h_store_return_value): Update.
	* hppabsd-tdep.c (hppabsd_find_global_pointer): Update.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register, hppa_hpux_store_register):
	Update.
	* hppa-hpux-tdep.c (hppa32_hpux_in_solib_call_trampoline,
	hppa64_hpux_in_solib_call_trampoline,
	hppa_hpux_in_solib_return_trampoline, hppa_hpux_skip_trampoline_code,
	hppa_hpux_sigtramp_frame_unwind_cache,
	hppa_hpux_sigtramp_unwind_sniffer, hppa32_hpux_find_global_pointer,
	hppa64_hpux_find_global_pointer, hppa_hpux_search_pattern,
	hppa32_hpux_search_dummy_call_sequence,
	hppa64_hpux_search_dummy_call_sequence, hppa_hpux_supply_save_state,
	hppa_hpux_unwind_adjust_stub): Update.
	* hppa-linux-tdep.c (insns_match_pattern,
	hppa_linux_find_global_pointer): Update.
	* hppa-tdep.c (hppa_in_function_epilogue_p, hppa32_push_dummy_call,
	hppa64_convert_code_addr_to_fptr, hppa64_push_dummy_call,
	skip_prologue_hard_way, hppa_frame_cache, hppa_fallback_frame_cache,
	hppa_pseudo_register_read, hppa_frame_prev_register_helper,
	hppa_match_insns): Update.
	* hpux-thread.c (hpux_thread_fetch_registers): Update.
	* i386-tdep.c (i386bsd_sigcontext_addr): Update.
	* i386-cygwin-tdep.c (core_process_module_section): Update.
	* i386-darwin-nat.c (i386_darwin_sstep_at_sigreturn,
	amd64_darwin_sstep_at_sigreturn): Update.
	* i386-darwin-tdep.c (i386_darwin_sigcontext_addr,
	amd64_darwin_sigcontext_addr): Likewise.
	* i386-linux-nat.c (i386_linux_sigcontext_addr): Update.
	* i386nbsd-tdep.c (i386nbsd_sigtramp_cache_init): Update.
	* i386-nto-tdep.c (i386nto_sigcontext_addr): Update.
	* i386obsd-nat.c (i386obsd_supply_pcb): Update.
	* i386obsd-tdep.c (i386obsd_supply_uthread, i386obsd_collect_uthread,
	i386obsd_trapframe_cache): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_follow_jump,
	i386_analyze_frame_setup, i386_analyze_prologue,
	i386_skip_main_prologue, i386_frame_cache, i386_sigtramp_frame_cache,
	i386_get_longjmp_target, i386_push_dummy_call,
	i386_pe_skip_trampoline_code, i386_svr4_sigcontext_addr,
	i386_fetch_pointer_argument): Update.
	* i387-tdep.c (i387_supply_fsave): Update.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Update.
	* ia64-tdep.c (ia64_pseudo_register_read, ia64_pseudo_register_write,
	examine_prologue, ia64_frame_cache, ia64_frame_prev_register,
	ia64_sigtramp_frame_cache, ia64_sigtramp_frame_prev_register,
	ia64_access_reg, ia64_access_rse_reg, ia64_libunwind_frame_this_id,
	ia64_libunwind_frame_prev_register,
	ia64_libunwind_sigtramp_frame_this_id,
	ia64_libunwind_sigtramp_frame_prev_register, ia64_find_global_pointer,
	find_extant_func_descr, find_func_descr,
	ia64_convert_from_func_ptr_addr, ia64_push_dummy_call, ia64_dummy_id,
	ia64_unwind_pc): Update.
	* iq2000-tdep.c (iq2000_pointer_to_address, iq2000_address_to_pointer,
	iq2000_scan_prologue, iq2000_extract_return_value,
	iq2000_push_dummy_call): Update.
	* irix5nat.c (fill_gregset): Update.
	* jv-lang.c (evaluate_subexp_java): Update.
	* jv-valprint.c (java_value_print): Update.
	* lm32-tdep.c (lm32_analyze_prologue, lm32_push_dummy_call,
	lm32_extract_return_value, lm32_store_return_value): Update.
	* m32c-tdep.c (m32c_push_dummy_call, m32c_return_value,
	m32c_skip_trampoline_code, m32c_m16c_address_to_pointer,
	m32c_m16c_pointer_to_address): Update.
	* m32r-tdep.c (m32r_store_return_value, decode_prologue,
	m32r_skip_prologue, m32r_push_dummy_call, m32r_extract_return_value):
	Update.
	* m68hc11-tdep.c (m68hc11_pseudo_register_read,
	m68hc11_pseudo_register_write, m68hc11_analyze_instruction,
	m68hc11_push_dummy_call): Update.
	* m68linux-tdep.c (m68k_linux_pc_in_sigtramp,
	m68k_linux_get_sigtramp_info, m68k_linux_sigtramp_frame_cache):
	Update.
	* m68k-tdep.c (m68k_push_dummy_call, m68k_analyze_frame_setup,
	m68k_analyze_register_saves, m68k_analyze_prologue, m68k_frame_cache,
	m68k_get_longjmp_target): Update.
	* m88k-tdep.c (m88k_fetch_instruction): Update.
	* mep-tdep.c (mep_pseudo_cr32_read, mep_pseudo_csr_write,
	mep_pseudo_cr32_write, mep_get_insn, mep_push_dummy_call): Update.
	* mi/mi-main.c (mi_cmd_data_write_memory): Update.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target, supply_32bit_reg,
	mips64_linux_get_longjmp_target, mips64_fill_gregset,
	mips64_fill_fpregset, mips_linux_in_dynsym_stub): Update.
	* mipsnbdsd-tdep.c (mipsnbsd_get_longjmp_target): Update.
	* mips-tdep.c (mips_fetch_instruction, fetch_mips_16,
	mips_eabi_push_dummy_call, mips_n32n64_push_dummy_call,
	mips_o32_push_dummy_call, mips_o64_push_dummy_call,
	mips_single_step_through_delay, mips_skip_pic_trampoline_code,
	mips_integer_to_address): Update.
	* mn10300-tdep.c (mn10300_analyze_prologue, mn10300_push_dummy_call):
	Update.
	* monitor.c (monitor_supply_register, monitor_write_memory,
	monitor_read_memory_single): Update.
	* moxie-tdep.c (moxie_store_return_value, moxie_extract_return_value,
	moxie_analyze_prologue): Update.
	* mt-tdep.c (mt_return_value, mt_skip_prologue, mt_select_coprocessor,
	mt_pseudo_register_read, mt_pseudo_register_write, mt_registers_info,
	mt_push_dummy_call): Update.
	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class, find_implementation_from_class): Update.
	* ppc64-linux-tdep.c (ppc64_desc_entry_point,
	ppc64_linux_convert_from_func_ptr_addr, ppc_linux_sigtramp_cache):
	Update.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_sniffer,
	ppcobsd_sigtramp_frame_cache): Update.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call,
	do_ppc_sysv_return_value, ppc64_sysv_abi_push_dummy_call,
	ppc64_sysv_abi_return_value): Update.
	* ppc-linux-nat.c (ppc_linux_auxv_parse): Update.
	* procfs.c (procfs_auxv_parse): Update.
	* p-valprint.c (pascal_val_print): Update.
	* regcache.c (regcache_raw_read_signed, regcache_raw_read_unsigned,
	regcache_raw_write_signed, regcache_raw_write_unsigned,
	regcache_cooked_read_signed, regcache_cooked_read_unsigned,
	regcache_cooked_write_signed, regcache_cooked_write_unsigned): Update.
	* remote-m32r-sdi.c (m32r_fetch_register): Update.
	* remote-mips.c (mips_wait, mips_fetch_registers, mips_xfer_memory):
	Update.
	* rs6000-aix-tdep.c (rs6000_push_dummy_call, rs6000_return_value,
	rs6000_convert_from_func_ptr_addr, branch_dest,
	rs6000_software_single_step): Update.
	* rs6000-tdep.c (rs6000_in_function_epilogue_p,
	ppc_displaced_step_fixup, ppc_deal_with_atomic_sequence,
	bl_to_blrl_insn_p, rs6000_fetch_instruction, skip_prologue,
	rs6000_skip_main_prologue, rs6000_skip_trampoline_code,
	rs6000_frame_cache): Update.
	* s390-tdep.c (s390_pseudo_register_read, s390_pseudo_register_write,
	s390x_pseudo_register_read, s390x_pseudo_register_write, s390_load,
	s390_backchain_frame_unwind_cache, s390_sigtramp_frame_unwind_cache,
	extend_simple_arg, s390_push_dummy_call, s390_return_value): Update.
	* scm-exp.c (scm_lreadr): Update.
	* scm-lang.c (scm_get_field, scm_unpack): Update.
	* scm-valprint.c (scm_val_print): Update.
	* score-tdep.c (score_breakpoint_from_pc, score_push_dummy_call,
	score_fetch_inst): Update.
	* sh64-tdep.c (look_for_args_moves, sh64_skip_prologue_hard_way,
	sh64_analyze_prologue, sh64_push_dummy_call, sh64_extract_return_value,
	sh64_pseudo_register_read, sh64_pseudo_register_write,
	sh64_frame_prev_register): Update:
	* sh-tdep.c (sh_analyze_prologue, sh_push_dummy_call_fpu,
	sh_push_dummy_call_nofpu, sh_extract_return_value_nofpu,
	sh_store_return_value_nofpu, sh_in_function_epilogue_p): Update.
	* solib-darwin.c (darwin_load_image_infos): Update.
	* solib-frv.c (fetch_loadmap, lm_base, frv_current_sos, enable_break2,
	find_canonical_descriptor_in_load_object): Update.
	* solib-irix.c (extract_mips_address, fetch_lm_info, irix_current_sos,
	irix_open_symbol_file_object): Update.
	* solib-som.c (som_solib_create_inferior_hook, link_map_start,
	som_current_sos, som_open_symbol_file_object): Update.
	* solib-sunos.c (SOLIB_EXTRACT_ADDRESS, LM_ADDR, LM_NEXT, LM_NAME):
	Update.
	* solib-svr4.c (read_program_header, scan_dyntag_auxv,
	solib_svr4_r_ldsomap): Update.
	* sparc64-linux-tdep.c (sparc64_linux_step_trap): Update.
	* sparc64obsd-tdep.c (sparc64obsd_supply_uthread,
	sparc64obsd_collect_uthread): Update.
	* sparc64-tdep.c (sparc64_pseudo_register_read,
	sparc64_pseudo_register_write, sparc64_supply_gregset,
	sparc64_collect_gregset): Update.
	* sparc-linux-tdep.c (sparc32_linux_step_trap): Update.
	* sparcobsd-tdep.c (sparc32obsd_supply_uthread,
	sparc32obsd_collect_uthread): Update.
	* sparc-tdep.c (sparc_fetch_wcookie, sparc32_push_dummy_code,
	sparc32_store_arguments, sparc32_return_value, sparc_supply_rwindow,
	sparc_collect_rwindow): Update.
	* spu-linux-nat.c (parse_spufs_run): Update.
	* spu-tdep.c (spu_pseudo_register_read_spu,
	spu_pseudo_register_write_spu, spu_pointer_to_address,
	spu_analyze_prologue, spu_in_function_epilogue_p,
	spu_frame_unwind_cache, spu_push_dummy_call, spu_software_single_step,
	spu_get_longjmp_target, spu_get_overlay_table, spu_overlay_update_osect,
	info_spu_signal_command, info_spu_mailbox_list, info_spu_dma_cmdlist,
	info_spu_dma_command, info_spu_proxydma_command): Update.
	* stack.c (print_frame_nameless_args, frame_info): Update.
	* symfile.c (read_target_long_array, simple_read_overlay_table,
	simple_read_overlay_region_table): Update.
	* target.c (debug_print_register): Update.
	* tramp-frame.c (tramp_frame_start): Update.
	* v850-tdep.c (v850_analyze_prologue, v850_push_dummy_call,
	v850_extract_return_value, v850_store_return_value,
	* valarith.c (value_binop, value_bit_index): Update.
	* valops.c (value_cast): Update.
	* valprint.c (val_print_type_code_int, val_print_string,
	read_string): Update.
	* value.c (unpack_long, unpack_double, unpack_field_as_long,
	modify_field, pack_long): Update.
	* vax-tdep.c (vax_store_arguments, vax_push_dummy_call,
	vax_skip_prologue): Update.
	* xstormy16-tdep.c (xstormy16_push_dummy_call,
	xstormy16_analyze_prologue, xstormy16_in_function_epilogue_p,
	xstormy16_resolve_jmp_table_entry, xstormy16_find_jmp_table_entry,
	xstormy16_pointer_to_address, xstormy16_address_to_pointer): Update.
	* xtensa-tdep.c (extract_call_winsize, xtensa_pseudo_register_read,
	xtensa_pseudo_register_write, xtensa_frame_cache,
	xtensa_push_dummy_call, call0_track_op, call0_frame_cache): Update.


	* dfp.h (decimal_to_string, decimal_from_string, decimal_from_integral,
	decimal_from_floating, decimal_to_doublest, decimal_is_zero): Add
	BYTE_ORDER parameter.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	* dfp.c (match_endianness): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.
	(decimal_to_string, decimal_from_integral, decimal_from_floating,
	decimal_to_doublest, decimal_is_zero): Add BYTE_ORDER parameter.
	Pass it to match_endianness.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.  Pass them to match_endianness.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	Pass them to match_endianness.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	Pass them to match_endianness.
	* valarith.c (value_args_as_decimal): Add BYTE_ORDER_X and
	BYTE_ORDER_Y output parameters.
	(value_binop): Update call to value_args_as_decimal.

	Update calls to decimal_to_string, decimal_from_string,
	decimal_from_integral, decimal_from_floating, decimal_to_doublest,
	decimal_is_zero, decimal_binop, decimal_compare and decimal_convert
	to pass/receive byte order:
	* c-exp.y (parse_number): Update.
	* printcmd.c (printf_command): Update.
	* valarith.c (value_args_as_decimal, value_binop, value_logical_not,
	value_equal, value_less): Update.
	* valops.c (value_cast, value_one): Update.
	* valprint.c (print_decimal_floating): Update.
	* value.c (unpack_long, unpack_double): Update.
	* python/python-value.c (valpy_nonzero): Update.


	* ada-valprint.c (char_at): Add BYTE_ORDER parameter.
	(printstr): Update calls to char_at.
	(ada_val_print_array): Likewise.
	* valprint.c (read_string): Add BYTE_ORDER parameter.
	(val_print_string): Update call to read_string.
	* c-lang.c (c_get_string): Likewise.
	* charset.h (target_wide_charset): Add BYTE_ORDER parameter.
	* charset.c (target_wide_charset): Add BYTE_ORDER parameter.
	Use it instead of current_gdbarch.
	* printcmd.c (printf_command): Update calls to target_wide_charset.
	* c-lang.c (charset_for_string_type): Add BYTE_ORDER parameter.
	Pass to target_wide_charset.  Use it instead of current_gdbarch.
	(classify_type): Add BYTE_ORDER parameter.  Pass to
	charset_for_string_type.  Allow NULL encoding pointer.
	(print_wchar): Add BYTE_ORDER parameter.
	(c_emit_char): Update calls to classify_type and print_wchar.
	(c_printchar, c_printstr): Likewise.


	* gdbarch.sh (in_solib_return_trampoline): Convert to type "m".
	* gdbarch.c, gdbarch.h: Regenerate.
	* arch-utils.h (generic_in_solib_return_trampoline): Add GDBARCH
	parameter.
	* arch-utils.c (generic_in_solib_return_trampoline): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_in_solib_return_trampoline): Likewise.
	* rs6000-tdep.c (rs6000_in_solib_return_trampoline): Likewise.
	(rs6000_skip_trampoline_code): Update call.

	* alpha-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	dynamic_sigtramp_offset and pc_in_sigtramp callbacks.
	(alpha_read_insn): Add GDBARCH parameter.
	* alpha-tdep.c (alpha_lds, alpha_sts): Add GDBARCH parameter.
	(alpha_register_to_value): Pass architecture to alpha_sts.
	(alpha_extract_return_value): Likewise.
	(alpha_value_to_register): Pass architecture to alpha_lds.
	(alpha_store_return_value): Likewise.
	(alpha_read_insn): Add GDBARCH parameter.
	(alpha_skip_prologue): Pass architecture to alpha_read_insn.
	(alpha_heuristic_proc_start): Likewise.
	(alpha_heuristic_frame_unwind_cache): Likewise.
	(alpha_next_pc): Likewise.
	(alpha_sigtramp_frame_this_id): Pass architecture to
	tdep->dynamic_sigtramp_offset callback.
	(alpha_sigtramp_frame_sniffer): Pass architecture to
	tdep->pc_in_sigtramp callback.
	* alphafbsd-tdep.c (alphafbsd_pc_in_sigtramp): Add GDBARCH parameter.
	(alphafbsd_sigtramp_offset): Likewise.
	* alpha-linux-tdep.c (alpha_linux_sigtramp_offset_1): Add GDBARCH
	parameter.  Pass to alpha_read_insn.
	(alpha_linux_sigtramp_offset): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset_1.
	(alpha_linux_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset.
	(alpha_linux_sigcontext_addr): Pass architecture to alpha_read_insn
	and alpha_linux_sigtramp_offset.
	* alphanbsd-tdep.c (alphanbsd_sigtramp_offset): Add GDBARCH parameter.
	(alphanbsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alphanbsd_sigtramp_offset.
	* alphaobsd-tdep.c (alphaobsd_sigtramp_offset): Add GDBARCH parameter.
	(alphaobsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_read_insn.
	(alphaobsd_sigcontext_addr): Pass architecture to
	alphaobsd_sigtramp_offset.
	* alpha-osf1-tdep.c (alpha_osf1_pc_in_sigtramp): Add GDBARCH
	parameter.

	* amd64-tdep.c (amd64_analyze_prologue): Add GDBARCH parameter.
	(amd64_skip_prologue): Pass architecture to amd64_analyze_prologue.
	(amd64_frame_cache): Likewise.

	* arm-tdep.c (SWAP_SHORT, SWAP_INT): Remove.
	(thumb_analyze_prologue, arm_skip_prologue, arm_scan_prologue,
	thumb_get_next_pc, arm_get_next_pc): Do not use SWAP_ macros.
	* arm-wince-tdep.c: Include "frame.h".

	* avr-tdep.c (EXTRACT_INSN): Remove.
	(avr_scan_prologue): Add GDBARCH argument, inline EXTRACT_INSN.
	(avr_skip_prologue): Pass architecture to avr_scan_prologue.
	(avr_frame_unwind_cache): Likewise.

	* cris-tdep.c (struct instruction_environment): Add BYTE_ORDER member.
	(find_step_target): Initialize it.
	(get_data_from_address): Add BYTE_ORDER parameter.
	(bdap_prefix): Pass byte order to get_data_from_address.
	(handle_prefix_assign_mode_for_aritm_op): Likewise.
	(three_operand_add_sub_cmp_and_or_op): Likewise.
	(handle_inc_and_index_mode_for_aritm_op): Likewise.

	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp): Add GDBARCH parameter.
	(frv_linux_sigcontext_reg_addr): Pass architecture to
	frv_linux_pc_in_sigtramp.
	(frv_linux_sigtramp_frame_sniffer): Likewise.

	* h8300-tdep.c (h8300_is_argument_spill): Add GDBARCH parameter.
	(h8300_analyze_prologue): Add GDBARCH parameter.  Pass to
	h8300_is_argument_spill.
	(h8300_frame_cache, h8300_skip_prologue): Pass architecture
	to h8300_analyze_prologue.

	* hppa-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	in_solib_call_trampoline callback.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.
	* hppa-tdep.c (hppa64_convert_code_addr_to_fptr): Add GDBARCH
	parameter.
	(hppa64_push_dummy_call): Pass architecture to
	hppa64_convert_code_addr_to_fptr.
	(hppa_match_insns): Add GDBARCH parameter.
	(hppa_match_insns_relaxed): Add GDBARCH parameter.  Pass to
	hppa_match_insns.
	(hppa_skip_trampoline_code): Pass architecture to hppa_match_insns.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.  Pass to
	hppa_match_insns_relaxed.
	(hppa_stub_unwind_sniffer): Pass architecture to
	tdep->in_solib_call_trampoline callback.
	* hppa-hpux-tdep.c (hppa_hpux_search_pattern): Add GDBARCH parameter.
	(hppa32_hpux_search_dummy_call_sequence): Pass architecture to
	hppa_hpux_search_pattern.
	* hppa-linux-tdep.c (insns_match_pattern): Add GDBARCH parameter.
	(hppa_linux_sigtramp_find_sigcontext): Add GDBARCH parameter.
	Pass to insns_match_pattern.
	(hppa_linux_sigtramp_frame_unwind_cache): Pass architecture to
	hppa_linux_sigtramp_find_sigcontext.
	(hppa_linux_sigtramp_frame_sniffer): Likewise.
	(hppa32_hpux_in_solib_call_trampoline): Add GDBARCH parameter.
	(hppa64_hpux_in_solib_call_trampoline): Likewise.

	* i386-tdep.c (i386_follow_jump): Add GDBARCH parameter.
	(i386_analyze_frame_setup): Add GDBARCH parameter.
	(i386_analyze_prologue): Add GDBARCH parameter.  Pass to
	i386_follow_jump and i386_analyze_frame_setup.
	(i386_skip_prologue): Pass architecture to i386_analyze_prologue
	and i386_follow_jump.
	(i386_frame_cache): Pass architecture to i386_analyze_prologue.
	(i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-tdep.h (i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-cygwin-tdep.c (i386_cygwin_skip_trampoline_code): Pass
	frame to i386_pe_skip_trampoline_code.

	* ia64-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter
	to sigcontext_register_address callback.
	* ia64-tdep.c (ia64_find_global_pointer): Add GDBARCH parameter.
	(ia64_find_unwind_table): Pass architecture to
	ia64_find_global_pointer.
	(find_extant_func_descr): Add GDBARCH parameter.
	(find_func_descr): Pass architecture to find_extant_func_descr
	and ia64_find_global_pointer.
	(ia64_sigtramp_frame_init_saved_regs): Pass architecture to
	tdep->sigcontext_register_address callback.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Add
	GDBARCH parameter.

	* iq2000-tdep.c (iq2000_scan_prologue): Add GDBARCH parameter.
	(iq2000_frame_cache): Pass architecture to iq2000_scan_prologue.

	* lm32-tdep.c (lm32_analyze_prologue): Add GDBARCH parameter.
	(lm32_skip_prologue, lm32_frame_cache): Pass architecture to
	lm32_analyze_prologue.

	* m32r-tdep.c (decode_prologue): Add GDBARCH parameter.
	(m32r_skip_prologue): Pass architecture to decode_prologue.

	* m68hc11-tdep.c (m68hc11_analyze_instruction): Add GDBARCH parameter.
	(m68hc11_scan_prologue): Pass architecture to
	m68hc11_analyze_instruction.

	* m68k-tdep.c (m68k_analyze_frame_setup): Add GDBARCH parameter.
	(m68k_analyze_prologue): Pass architecture to
	m68k_analyze_frame_setup.

	* m88k-tdep.c (m88k_fetch_instruction): Add BYTE_ORDER parameter.
	(m88k_analyze_prologue): Add GDBARCH parameter.  Pass byte order
	to m88k_fetch_instruction.
	(m88k_skip_prologue): Pass architecture to m88k_analyze_prologue.
	(m88k_frame_cache): Likewise.

	* mep-tdep.c (mep_get_insn): Add GDBARCH parameter.
	(mep_analyze_prologue): Pass architecture to mep_get_insn.

	* mips-tdep.c (mips_fetch_instruction): Add GDBARCH parameter.
	(mips32_next_pc): Pass architecture to mips_fetch_instruction.
	(deal_with_atomic_sequence): Likewise.
	(unpack_mips16): Add GDBARCH parameter, pass to mips_fetch_instruction.
	(mips16_scan_prologue): Likewise.
	(mips32_scan_prologue): Likewise.
	(mips16_in_function_epilogue_p): Likewise.
	(mips32_in_function_epilogue_p): Likewise.
	(mips_about_to_return): Likewise.
	(mips_insn16_frame_cache): Pass architecture to mips16_scan_prologue.
	(mips_insn32_frame_cache): Pass architecture to mips32_scan_prologue.
	(mips_skip_prologue): Pass architecture to mips16_scan_prologue
	and mips32_scan_prologue.
	(mips_in_function_epilogue_p): Pass architecture to
	mips16_in_function_epilogue_p and
	mips32_in_function_epilogue_p.
	(heuristic_proc_start): Pass architecture to mips_fetch_instruction
	and mips_about_to_return.
	(mips_skip_mips16_trampoline_code): Pass architecture to
	mips_fetch_instruction.
	(fetch_mips_16): Add GDBARCH parameter.
	(mips16_next_pc): Pass architecture to fetch_mips_16.
	(extended_mips16_next_pc): Pass architecture to unpack_mips16 and
	fetch_mips_16.

	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class): Add GDBARCH parameter.
	(find_implementation_from_class): Add GDBARCH parameter, pass
	to read_objc_class, read_objc_methlist_nmethods, and
	read_objc_methlist_method.
	(find_implementation): Add GDBARCH parameter, pass to
	read_objc_object and find_implementation_from_class.
	(resolve_msgsend, resolve_msgsend_stret): Pass architecture
	to find_implementation.
	(resolve_msgsend_super, resolve_msgsend_super_stret): Pass
	architecture to read_objc_super and find_implementation_from_class.

	* ppc64-linux-tdep.c (ppc64_desc_entry_point): Add GDBARCH parameter.
	(ppc64_standard_linkage1_target, ppc64_standard_linkage2_target,
	ppc64_standard_linkage3_target): Pass architecture to
	ppc64_desc_entry_point.
	* rs6000-tdep.c (bl_to_blrl_insn_p): Add BYTE_ORDER parameter.
	(skip_prologue): Pass byte order to bl_to_blrl_insn_p.
	(rs6000_fetch_instruction): Add GDBARCH parameter.
	(rs6000_skip_stack_check): Add GDBARCH parameter, pass to
	rs6000_fetch_instruction.
	(skip_prologue): Pass architecture to rs6000_fetch_instruction.

	* remote-mips.c (mips_store_word): Return old_contents as host
	integer value instead of target bytes.

	* s390-tdep.c (struct s390_prologue_data): Add BYTE_ORDER member.
	(s390_analyze_prologue): Initialize it.
	(extend_simple_arg): Add GDBARCH parameter.
	(s390_push_dummy_call): Pass architecture to extend_simple_arg.

	* scm-lang.c (scm_get_field): Add BYTE_ORDER parameter.
	* scm-lang.h (scm_get_field): Add BYTE_ORDER parameter.
	(SCM_CAR, SCM_CDR): Pass SCM_BYTE_ORDER to scm_get_field.
	* scm-valprint.c (scm_scmval_print): Likewise.
	(scm_scmlist_print, scm_ipruk, scm_scmval_print): Define
	SCM_BYTE_ORDER.

	* sh64-tdep.c (look_for_args_moves): Add GDBARCH parameter.
	(sh64_skip_prologue_hard_way): Add GDBARCH parameter, pass to
	look_for_args_moves.
	(sh64_skip_prologue): Pass architecture to
	sh64_skip_prologue_hard_way.
	* sh-tdep.c (sh_analyze_prologue): Add GDBARCH parameter.
	(sh_skip_prologue): Pass architecture to sh_analyze_prologue.
	(sh_frame_cache): Likewise.

	* solib-irix.c (extract_mips_address): Add GDBARCH parameter.
	(fetch_lm_info, irix_current_sos, irix_open_symbol_file_object):
	Pass architecture to extract_mips_address.

	* sparc-tdep.h (sparc_fetch_wcookie): Add GDBARCH parameter.
	* sparc-tdep.c (sparc_fetch_wcookie): Add GDBARCH parameter.
	(sparc_supply_rwindow, sparc_collect_rwindow): Pass architecture
	to sparc_fetch_wcookie.
	(sparc32_frame_prev_register): Likewise.
	* sparc64-tdep.c (sparc64_frame_prev_register): Likewise.
	* sparc32nbsd-tdep.c (sparc32nbsd_sigcontext_saved_regs): Likewise.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_saved_regs): Likewise.

	* spu-tdep.c (spu_analyze_prologue): Add GDBARCH parameter.
	(spu_skip_prologue): Pass architecture to spu_analyze_prologue.
	(spu_virtual_frame_pointer): Likewise.
	(spu_frame_unwind_cache): Likewise.
	(info_spu_mailbox_list): Add BYTE_ORER parameter.
	(info_spu_mailbox_command): Pass byte order to info_spu_mailbox_list.
	(info_spu_dma_cmdlist): Add BYTE_ORER parameter.
	(info_spu_dma_command, info_spu_proxydma_command): Pass byte order
	to info_spu_dma_cmdlist.

	* symfile.c (read_target_long_array): Add GDBARCH parameter.
	(simple_read_overlay_table, simple_read_overlay_region_table,
	simple_overlay_update_1): Pass architecture to read_target_long_array.

	* v850-tdep.c (v850_analyze_prologue): Add GDBARCH parameter.
	(v850_frame_cache): Pass architecture to v850_analyze_prologue.

	* xstormy16-tdep.c (xstormy16_analyze_prologue): Add GDBARCH
	parameter.
	(xstormy16_skip_prologue, xstormy16_frame_cache): Pass architecture
	to xstormy16_analyze_prologue.
	(xstormy16_resolve_jmp_table_entry): Add GDBARCH parameter.
	(xstormy16_find_jmp_table_entry): Likewise.
	(xstormy16_skip_trampoline_code): Pass architecture to
	xstormy16_resolve_jmp_table_entry.
	(xstormy16_pointer_to_address): Likewise.
	(xstormy16_address_to_pointer): Pass architecture to
	xstormy16_find_jmp_table_entry.

	* xtensa-tdep.c (call0_track_op): Add GDBARCH parameter.
	(call0_analyze_prologue): Add GDBARCH parameter, pass to
	call0_track_op.
	(call0_frame_cache): Pass architecture to call0_analyze_prologue.
	(xtensa_skip_prologue): Likewise.
@
text
@d44 1
d51 1
d1039 6
d1050 1
d1060 3
a1062 1
      if (vsx)
d1070 3
a1072 1
      if (vsx)
d1212 1
d1219 1
@


1.112
log
@	* gdbarch.sh (gcore_bfd_target): New gdbarch callback.
	* gdbarch.h, gdbarch.c: Regenerate.

	* gcore.c (default_gcore_target): Make return value const.
	Call gdbarch_gcore_bfd_target if present.
	(default_gcore_arch, default_gcore_mach): Use target_gdbarch.

	* corelow.c (core_read_description): Call gdbarch_core_read_description
	on core_gdbarch instead of current_gdbarch.

	* ppc-linux-tdep.c (ppc_linux_init_abi): Install gcore_bfd_target.
@
text
@d332 1
a332 1
ppc64_desc_entry_point (CORE_ADDR desc)
d334 1
d336 1
a336 1
  return (CORE_ADDR) read_memory_unsigned_integer (desc, 8);
d487 2
a488 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (get_frame_arch (frame));
d499 1
a499 1
  return ppc64_desc_entry_point (desc);
d530 2
a531 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (get_frame_arch (frame));
d542 1
a542 1
  return ppc64_desc_entry_point (desc);
d549 2
a550 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (get_frame_arch (frame));
d560 1
a560 1
  return ppc64_desc_entry_point (desc);
d628 1
d660 1
a660 1
	return extract_unsigned_integer (buf, 8)
d855 1
d868 1
a868 1
  gpregs = read_memory_unsigned_integer (regs, tdep->wordsize);
@


1.111
log
@	* target.h (struct section_table): Rename to ...
	(struct target_section): ... this.
	* exec.c: Adjust all references.
	* exec.h: Adjust all references.
	* nto-tdep.c: Adjust all references.
	* nto-tdep.h: Adjust all references.
	* ppc-linux-tdep.c: Adjust all references.
	* rs6000-nat.c: Adjust all references.
	* s390-tdep.c: Adjust all references.
	* solib-darwin.c: Adjust all references.
	* solib-frv.c: Adjust all references.
	* solib-irix.c: Adjust all references.
	* solib-null.c: Adjust all references.
	* solib-osf.c: Adjust all references.
	* solib-pa64.c: Adjust all references.
	* solib-som.c: Adjust all references.
	* solib-sunos.c: Adjust all references.
	* solib-svr4.c: Adjust all references.
	* solib-target.c: Adjust all references.
	* solib.c: Adjust all references.
	* solist.h: Adjust all references.
	* symfile.c: Adjust all references.
	* symfile.h: Adjust all references.
	* target.c: Adjust all references.
@
text
@d1105 6
d1128 6
@


1.110
log
@	Silence a few -Wmissing-prototypes warnings.

	PR build/9877:
        * alpha-linux-tdep.c (alpha_linux_regset_from_core_section): Make
	it static.
        * alpha-osf1-tdep.c (_initialize_alpha_osf1_tdep): Declare.
        * amd64fbsd-tdep.c (amd64fbsd_init_abi): Make it static.
        * amd64nbsd-tdep.c (_initialize_amd64nbsd_ndep): Rename to ...
	(_initialize_amd64nbsd_tdep): ... this.
	* arm-linux-tdep.c (arm_linux_software_single_step): Make it static.
	(_initialize_arm_linux_tdep): Declare.
	* armbsd-tdep.c (armbsd_fpreg_offset): Make it static.
	* armnbsd-tdep.c (_initialize_arm_netbsd_tdep): Declare.
	* armobsd-tdep.c (_initialize_armobsd_tdep): Declare.
	* avr-tdep.c (avr_return_value): Make it static.
	(avr_frame_unwind_cache): Ditto.
	* bsd-uthread.c (bsd_uthread_inferior_created): Ditto.
	(bsd_uthread_solib_loaded): Ditto.
	(bsd_uthread_solib_unloaded): Ditto.
	(bsd_uthread_target): Ditto.
	(_initialize_bsd_uthread): Declare.
	* cris-tdep.c (crisv32_single_step_through_delay): Make it static.
	(cris_frame_unwind_cache): Ditto.
	* frv-tdep.c (frv_return_value): Ditto.
	* h8300-tdep.c (h8300_use_struct_convention): Ditto.
	(h8300h_use_struct_convention): Ditto.
	* hppa-tdep.c (hppa_sign_extend, hppa_low_hppa_sign_extend):
	Ditto.
	* hppa-tdep.h (hppa_low_sign_extend, hppa_sign_extend): Delete
	declarations.
	* hppabsd-tdep.c: Include hppabsd-tdep.h.
	(hppabsd_find_global_pointer): Make it static.
	* hppabsd-tdep.h: New.
	* hppanbsd-tdep.c: Include hppabsd-tdep.h.
	(hppabsd_init_abi): Remove declaration.
	(_initialize_hppabsd_tdep): Remove declaration.
	(_initialize_hppanbsd_tdep): Declare.
	* hppaobsd-tdep.c: Include hppabsd-tdep.h.
	(hppabsd_init_abi): Delete declaration.
	(hppaobsd_init_abi): Make it static.
	* i386-nto-tdep.c (_initialize_i386nto_tdep): Declare.
	* i386nbsd-tdep.c (_initialize_i386nbsd_tdep): Declare.
	* ia64-linux-tdep.c (_initialize_ia64_linux_tdep): Declare.
	* ia64-tdep.c (ia64_register_reggroup_p): Make it static.
	* iq2000-tdep.c (_initialize_iq2000_tdep): Declare.
	* m32c-tdep.c (m32c_register_reggroup_p): Make it static.
	(m32c_analyze_prologue, m32c_virtual_frame_pointer): Ditto.
	(_initialize_m32c_tdep): Declare.
	* m32r-rom.c (_initialize_m32r_rom): Declare.
	* m32r-tdep.c (m32r_skip_prologue): Make it static.
	(m32r_return_value): Ditto.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache): Make it static.
	(m68hc11_return_value): Ditto.
	* m68klinux-tdep.c (_initialize_m68k_linux_tdep): Declare.
	* m88k-tdep.c (m88k_frame_cache): Make it static.
	* mep-tdep.c (mep_gdb_print_insn): Ditto.
	(mep_return_value): Ditto.
	(_initialize_mep_tdep): Declare.
	* mips-irix-tdep.c (_initialize_mips_irix_tdep): Declare.
	* mips-linux-tdep.c (supply_64bit_reg): Make it static.
	(mips_linux_syscall_next_pc): Ditto.
	(_initialize_mips_linux_tdep): Declare.
	* mips-tdep.c (mips_single_step_through_delay): Make it static.
	* mipsnbsd-tdep.c (_initialize_mipsnbsd_tdep): Declare.
	* mn10300-linux-tdep.c (_initialize_mn10300_linux_tdep): Declare.
	* mn10300-tdep.c (_initialize_mn10300_tdep): Declare.
	* mt-tdep.c (_initialize_mt_tdep): Declare.
	* nbsd-tdep.c: Include nbsd-tdep.h.
	* nto-tdep.c (find_load_phdr): Make it static.
	(_initialize_nto_tdep): Declare.
	* ppc-linux-tdep.c (ppc_linux_memory_remove_breakpoint): Make it
	static.
	(_initialize_ppc_linux_tdep): Declare.
	* remote-m32r-sdi.c (m32r_can_use_hw_watchpoint)
	(m32r_insert_watchpoint, m32r_remove_watchpoint)
	(m32r_stopped_data_address, m32r_stopped_by_watchpoint): Make
	static.
	* rs6000-aix-tdep.c (_initialize_rs6000_aix_tdep): Declare.
	* rs6000-nat.c: Include xcoffread.h.
	(find_toc_address): Don't extern declare get_toc_offset.  Adjust
	to call xcoff_get_to_offset.
	* rs6000-tdep.c (ppc_vsx_support_p, ppc_displaced_step_fixup)
	(rs6000_skip_main_prologue, rs6000_in_solib_return_trampoline)
	(rs6000_skip_trampoline_code): Make static.
	* s390-tdep.c (s390_regset_from_core_section): Ditto.
	* sh-tdep.c (sh_register_reggroup_p): Ditto.
	* shnbsd-tdep.c (shnbsd_regset_from_core_section): Ditto.
	(_initialize_shnbsd_tdep): Declare.
	* solib-frv.c (displacement_from_map): Make static.
	(_initialize_frv_solib): Declare.
	* solib-irix.c (fetch_lm_info): Make static.
	(_initialize_irix_solib): Declare.
	* solib-som.c: Include solib-som.h.
	(som_solib_select): Line break.
	* sparc-tdep.c (sparc_regset_from_core_section): Make static.
	* sparcnbsd-tdep.c (_initialize_sparnbsd_tdep): Rename to ...
	(_initialize_sparcnbsd_tdep): ... this.
	* spu-tdep.c (spu_software_single_step): Make it static.
	(_initialize_spu_tdep): Declare.
	* vax-tdep.c (vax_frame_cache): Make it static.
	* xcoffread.c: Include xcoffread.h.
	(get_toc_offset): Rename to ...
	(xcoff_get_toc_offset): ... this.
	(_initialize_xcoffread): Declare.
	* xcoffread.h: New.
	* xtensa-linux-tdep.c (_initialize_xtensa_linux_tdep): Declare.
	* xtensa-tdep.c (xtensa_skip_prologue, xtensa_derive_tdep): Make
	static.
	(_initialize_xtensa_tdep): Declare.
@
text
@d624 1
a624 1
  struct section_table *s = target_section_by_addr (targ, addr);
@


1.109
log
@        Updated copyright notices for most files.
@
text
@d181 1
a181 1
int
d1163 3
@


1.108
log
@gdb/
	* ppc-linux-nat.c (ppc_register_u_addr): Add special case to return
	offset for full 64-bit slot of FPSCR when in 32-bits.
	(ppc_linux_read_description): Return target description with 64-bit
	FPSCR when inferior is running on an ISA 2.05 or later processor.
	* ppc-linux-tdep.c (_initialize_ppc_linux_tdep): Call
	initialize_tdec_powerpc_isa205_32l,
	initialize_tdec_powerpc_isa205_altivec32l,
	initialize_tdec_powerpc_isa205_vsx32l,
	initialize_tdec_powerpc_isa205_64l,
	initialize_tdec_powerpc_isa205_altivec64l and
	initialize_tdec_powerpc_isa205_vsx64l.
	* ppc-linux-tdep.h: Add external declaration for
	tdesc_powerpc_isa205_32l, tdesc_powerpc_isa205_altivec32l,
	tdesc_powerpc_isa205_vsx32l, tdesc_powerpc_isa205_64l,
	tdesc_powerpc_isa205_altivec64l and tdesc_powerpc_isa205_vsx64l.
	* features/rs600/powerpc-fpu-isa205.xml: New file.
	* features/rs600/powerpc-isa205-32l.xml: New file.
	* features/rs600/powerpc-isa205-64l.xml: New file.
	* features/rs600/powerpc-isa205-altivec32l.xml: New file.
	* features/rs600/powerpc-isa205-altivec64l.xml: New file.
	* features/rs600/powerpc-isa205-vsx32l.xml: New file.
	* features/rs600/powerpc-isa205-vsx64l.xml: New file.
	* features/rs600/powerpc-isa205-32l.c: Generate.
	* features/rs600/powerpc-isa205-64l.c: Generate.
	* features/rs600/powerpc-isa205-altivec32l.c: Generate.
	* features/rs600/powerpc-isa205-altivec64l.c: Generate.
	* features/rs600/powerpc-isa205-vsx32l.c: Generate.
	* features/rs600/powerpc-isa205-vsx64l.c: Generate.

gdb/testsuite/
	* gdb.arch/ppc-dfp.exp: New file.
	* gdb.arch/ppc-dfp.c: New file.
@
text
@d4 1
a4 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
@


1.107
log
@	* ppc-linux-tdep.c (ppc_linux_vsx_regset_sections) New structure.
	(ppc_linux_vmx_regset_sections): New structure.
	(ppc_linux_fp_regset_sections): New structure.
	(ppc_linux_init_abi): Select core-file regset  based on target
	features.
@
text
@d45 3
d51 3
d1179 3
d1185 3
@


1.106
log
@	* ppc-linux-tdep.c (ppc64_linux_convert_from_func_ptr_addr): Read
	and manually relocate .opd contents from BFD instead of reading
	them from target memory.
@
text
@d494 1
a494 1
static struct core_regset_section ppc_linux_regset_sections[] =
d503 15
d1121 8
a1128 1
  set_gdbarch_core_regset_sections (gdbarch, ppc_linux_regset_sections);
@


1.105
log
@	* rs6000-tdep: Include "features/rs6000/powerpc-vsx32.c".
	Include "features/rs6000/powerpc-vsx64.c".
	(ppc_supply_vsxregset): New function.
	(ppc_collect_vsxregset): New function.
	(IS_VSX_PSEUDOREG): New macro.
	(IS_EFP_PSEUDOREG): New macro.
	(vsx_register_p): New function.
	(ppc_vsx_support_p): New function.
	(rs6000_builtin_type_vec128): New function.
	(rs6000_register_name): Hide upper halves of vs0~vs31.  Return
	correct names for VSX registers and EFPR registers.
	(rs6000_pseudo_register_type): Return correct types for VSX
	and EFPR registers.
	(rs6000_pseudo_register_reggroup_p): Return correct group for
	VSX and EFPR registers.
	(ppc_pseudo_register_read): Rename to dfp_pseudo_register_read.
	(ppc_pseudo_register_write): Rename to dfp_pseudo_register_write.
	(vsx_pseudo_register_read): New function.
	(vsx_pseudo_register_write): New function.
	(efpr_pseudo_register_read): New function.
	(efpr_pseudo_register_write): New function.
	(rs6000_pseudo_register_read): Call new VSX and EFPR read functions.
	(rs6000_pseudo_register_write): Call new VSX and EFPR write functions.
	(rs6000_gdbarch_init): Declare have_vsx.
	Initialize new upper half VSX registers.
	Initialize VSX-related and EFPR-related pseudo-registers variables.
	Adjust the number of pseudo registers accordingly.

	* ppc-linux-nat.c: Define PTRACE_GETVSXREGS, PTRACE_SETVSXREGS
	and SIZEOF_VSRREGS.
	(gdb_vsxregset_t): New type.
	(have_ptrace_getsetvsxregs): New variable.
	(fetch_vsx_register): New function.
	(fetch_register): Handle VSX registers.
	(fetch_vsx_registers): New function.
	(fetch_ppc_registers): Handle VSX registers.
	(store_ppc_registers): Handle VSX registers.
	(store_vsx_register): New function.
	(store_register): Handle VSX registers.
	(store_vsx_registers): New function.
	(ppc_linux_read_description): Handle VSX-enabled inferiors.
	(gdb_vsxregset_t): New type.
	(supply_vsxregset): New function.
	(fill_vsxregset): New function.

	* ppc-tdep.h (vsx_register_p): New prototype.
	(vsx_support_p): New prototype.
	(ppc_vsr0_regnum): New variable.
	(ppc_vsr0_upper_regnum): Likewise.
	(ppc_efpr0_regnum): Likewise.
	(ppc_builtin_type_vec128): New type.
	(ppc_num_vsrs): New constant.
	(ppc_num_vshrs): New constant.
	(ppc_num_efprs): Likewise.
	Define POWERPC_VEC_VSX PPC_VSR0_UPPER_REGNUM and PPC_VSR31_UPPER_REGNUM.
	(ppc_supply_vsxregset): New prototype.
	(ppc_collect_vsxregset): New prototype.

	* ppc-linux-tdep.c: Include "features/rs6000/powerpc-vsx32l.c"
	Include "features/rs6000/powerpc-vsx64l.c".
	(_initialize_ppc_linux_tdep): Initialize VSX-enabled targets.
	(ppc_linux_regset_sections): Add new ".reg-ppc-vsx" field.
	(ppc32_linux_vsxregset): New 32-bit VSX-enabled regset.
	(ppc_linux_regset_from_core_section): Handle VSX core section.
	(ppc_linux_core_read_description): Support VSX-enabled core files.

	* ppc-linux-tdep.h: Declare *tdesc_powerpc_vsx32l
	Declare tdesc_powerpc_vsx64l

	* corelow.c (get_core_register_section): Support VSX-enabled
	core files.

	* features/rs6000/power-vsx.xml: New VSX descriptions.
	* features/rs6000/powerpc-vsx32.xml: New file.
	* features/rs6000/powerpc-vsx32l.xml: New file.
	* features/rs6000/powerpc-vsx64.xml: New file.
	* features/rs6000/powerpc-vsx64l.xml: New file.
	* features/rs6000/powerpc-vsx32.c: New file (generated).
	* features/rs6000/powerpc-vsx32l.c: New file (generated).
	* features/rs6000/powerpc-vsx64.c: New file (generated).
	* features/rs6000/powerpc-vsx64l.c: New file (generated).
	* features/Makefile: Updated with new descriptions.
	* regformats/rs6000/powerpc-vsx32l.dat: New file (generated).
	* regformats/rs6000/powerpc-vsx64l.dat: New file (generated).

	* testsuite/gdb.arch/vsx-regs.c: New source file.
	* testsuite/gdb.arch/vsx-regs.exp: New testcase.
	* testsuite/lib/gdb.exp (skip_vsx_tests): New function.
@
text
@d607 30
a636 1
    return get_target_memory_unsigned (targ, addr, 8);
@


1.104
log
@
	* gdbarch.sh: Added new gdbarch struct
	core_regset_sections.
	* gdbarch.c: Refreshed.
	* gdbarch.h: Refreshed.
	* regset.h (core_regset_section): Declared.
	* linux-nat.c (linux_nat_do_thread_registers): Added
	support for the new gdbarch struct core_regset_sections.
	* utils.c (host_address_to_string): New function.
	* defs.h (host_address_to_string): New prototype.
	* i386-linux-tdep.c (i386_regset_rections): New register
	sections list for i386.
	  (i386_linux_init_abi): Initialized new gdbarch struct
	  core_regset_sections.
	* Makefile.in: Updated to reflect dependency changes.
	* ppc-linux-tdep.c (ppc_regset_sections): Register
	sections list for ppc.
	  (ppc_linux_init_abi): Initialized new gdbarch struct
	  core_regset_sections
@
text
@d44 1
d47 1
d499 1
d747 7
d782 2
d987 1
d995 6
a1000 1
      return altivec? tdesc_powerpc_altivec32l : tdesc_powerpc_32l;
d1003 6
a1008 1
      return altivec? tdesc_powerpc_altivec64l : tdesc_powerpc_64l;
d1121 1
d1124 1
@


1.103
log
@	* minsyms.c: Include "target.h".
	(find_solib_trampoline_target): Handle minimal symbols pointing
	to function descriptors as well.
	* Makefile.in (minsyms.o): Update dependencies.

	* ppc-linux-tdep.c (ppc64_standard_linkage): Rename to ...
	(ppc64_standard_linkage1): ... this.  Fix optional instructions.
	(PPC64_STANDARD_LINKAGE_LEN): Rename to ...
	(PPC64_STANDARD_LINKAGE1_LEN): ... this.
	(ppc64_standard_linkage2, ppc64_standard_linkage3): New.
	(PPC64_STANDARD_LINKAGE2_LEN, PPC64_STANDARD_LINKAGE3_LEN): New.
	(ppc64_standard_linkage_target): Rename to ...
	(ppc64_standard_linkage1_target): ... this.
	(ppc64_standard_linkage2_target, ppc64_standard_linkage3_target): New.
	(ppc64_skip_trampoline_code): Support three variants of standard
	linkage stubs.  Call find_solib_trampoline_target to handle
	glink stubs.
@
text
@d492 8
d1053 3
@


1.102
log
@	* ppc-linux-tdep.c (ppc_linux_init_abi): Do not install
	ppc64_sysv_abi_adjust_breakpoint_address.
	* ppc-sysv-tdep.c (ppc64_sysv_abi_adjust_breakpoint_address): Remove.
	* ppc-tdep.h (ppc64_sysv_abi_adjust_breakpoint_address): Remove.
@
text
@d334 1
a334 1
static struct insn_pattern ppc64_standard_linkage[] =
d346 1
a346 1
    { insn_d (-1, -1, -1, -1), insn_d (15, 12, 2, 1), 1 },
d352 1
a352 1
    { insn_d (-1, -1, -1, -1), insn_d (15, 12, 2, 1), 1 },
d355 1
a355 2
    { insn_xfx (-1, -1, -1, -1), insn_xfx (31, 11, 9, 467),
      0 },
d365 62
a426 2
#define PPC64_STANDARD_LINKAGE_LEN \
  (sizeof (ppc64_standard_linkage) / sizeof (ppc64_standard_linkage[0]))
d475 2
a476 2
ppc64_standard_linkage_target (struct frame_info *frame,
			       CORE_ADDR pc, unsigned int *insn)
d492 35
d533 17
a549 6
  unsigned int ppc64_standard_linkage_insn[PPC64_STANDARD_LINKAGE_LEN];

  if (insns_match_pattern (pc, ppc64_standard_linkage,
                           ppc64_standard_linkage_insn))
    return ppc64_standard_linkage_target (frame, pc,
					  ppc64_standard_linkage_insn);
d552 6
@


1.101
log
@	* ppc-linux-tdep.c (ppc_linux_skip_trampoline_code): Remove.
	(ppc_linux_init_abi): Install find_solib_trampoline_target instead
	of ppc_linux_skip_trampoline_code.
@
text
@a916 9
       /* Handle the 64-bit SVR4 minimal-symbol convention of using "FN"
	  for the descriptor and ".FN" for the entry-point -- a user
	  specifying "break FN" will unexpectedly end up with a breakpoint
	  on the descriptor and not the function.  This architecture method
	  transforms any breakpoints on descriptors into breakpoints on the
	  corresponding entry point.  */
      set_gdbarch_adjust_breakpoint_address
	(gdbarch, ppc64_sysv_abi_adjust_breakpoint_address);

@


1.100
log
@	* ppc-linux-tdep.c (ppc_linux_convert_from_func_ptr_addr): Rename ...
	(ppc64_linux_convert_from_func_ptr_addr): ... to this.  No longer try
	to handle ppc32 PLT entries.
	(ppc_linux_init_abi): Install ppc64_linux_convert_from_func_ptr_addr
	only on ppc64.
@
text
@a47 109
static CORE_ADDR
ppc_linux_skip_trampoline_code (struct frame_info *frame, CORE_ADDR pc)
{
  gdb_byte buf[4];
  struct obj_section *sect;
  struct objfile *objfile;
  unsigned long insn;
  CORE_ADDR plt_start = 0;
  CORE_ADDR symtab = 0;
  CORE_ADDR strtab = 0;
  int num_slots = -1;
  int reloc_index = -1;
  CORE_ADDR plt_table;
  CORE_ADDR reloc;
  CORE_ADDR sym;
  long symidx;
  char symname[1024];
  struct minimal_symbol *msymbol;

  /* Find the section pc is in; if not in .plt, try the default method.  */
  sect = find_pc_section (pc);
  if (!sect || strcmp (sect->the_bfd_section->name, ".plt") != 0)
    return find_solib_trampoline_target (frame, pc);

  objfile = sect->objfile;

  /* Pick up the instruction at pc.  It had better be of the
     form
     li r11, IDX

     where IDX is an index into the plt_table.  */

  if (target_read_memory (pc, buf, 4) != 0)
    return 0;
  insn = extract_unsigned_integer (buf, 4);

  if ((insn & 0xffff0000) != 0x39600000 /* li r11, VAL */ )
    return 0;

  reloc_index = (insn << 16) >> 16;

  /* Find the objfile that pc is in and obtain the information
     necessary for finding the symbol name. */
  for (sect = objfile->sections; sect < objfile->sections_end; ++sect)
    {
      const char *secname = sect->the_bfd_section->name;
      if (strcmp (secname, ".plt") == 0)
	plt_start = sect->addr;
      else if (strcmp (secname, ".rela.plt") == 0)
	num_slots = ((int) sect->endaddr - (int) sect->addr) / 12;
      else if (strcmp (secname, ".dynsym") == 0)
	symtab = sect->addr;
      else if (strcmp (secname, ".dynstr") == 0)
	strtab = sect->addr;
    }

  /* Make sure we have all the information we need. */
  if (plt_start == 0 || num_slots == -1 || symtab == 0 || strtab == 0)
    return 0;

  /* Compute the value of the plt table */
  plt_table = plt_start + 72 + 8 * num_slots;

  /* Get address of the relocation entry (Elf32_Rela) */
  if (target_read_memory (plt_table + reloc_index, buf, 4) != 0)
    return 0;
  reloc = extract_unsigned_integer (buf, 4);

  sect = find_pc_section (reloc);
  if (!sect)
    return 0;

  if (strcmp (sect->the_bfd_section->name, ".text") == 0)
    return reloc;

  /* Now get the r_info field which is the relocation type and symbol
     index. */
  if (target_read_memory (reloc + 4, buf, 4) != 0)
    return 0;
  symidx = extract_unsigned_integer (buf, 4);

  /* Shift out the relocation type leaving just the symbol index */
  /* symidx = ELF32_R_SYM(symidx); */
  symidx = symidx >> 8;

  /* compute the address of the symbol */
  sym = symtab + symidx * 4;

  /* Fetch the string table index */
  if (target_read_memory (sym, buf, 4) != 0)
    return 0;
  symidx = extract_unsigned_integer (buf, 4);

  /* Fetch the string; we don't know how long it is.  Is it possible
     that the following will fail because we're trying to fetch too
     much? */
  if (target_read_memory (strtab + symidx, (gdb_byte *) symname,
			  sizeof (symname)) != 0)
    return 0;

  /* This might not work right if we have multiple symbols with the
     same name; the only way to really get it right is to perform
     the same sort of lookup as the dynamic linker. */
  msymbol = lookup_minimal_symbol_text (symname, NULL);
  if (!msymbol)
    return 0;

  return SYMBOL_VALUE_ADDRESS (msymbol);
}
d906 1
a906 2
      set_gdbarch_skip_trampoline_code (gdbarch,
                                        ppc_linux_skip_trampoline_code);
@


1.99
log
@	* rs6000-tdep.c: Do not include "rs6000-tdep.h".
	(rs6000_find_toc_address_hook): Move to rs6000-aix-tdep.c.
	(SIG_FRAME_PC_OFFSET): Likewise.
	(SIG_FRAME_LR_OFFSET): Likewise.
	(SIG_FRAME_FP_OFFSET): Likewise.
	(rs6000_push_dummy_call): Likewise.
	(rs6000_return_value): Likewise.
	(rs6000_convert_from_func_ptr_addr): Likewise.
	(branch_dest, rs6000_software_single_step): Likewise.
	(deal_with_atomic_sequence): Rename to ...
	(ppc_deal_with_atomic_sequence): ... this.  Adapt all callers.
	Do not call branch_dest; inline required parts of that function.
	(rs6000_skip_trampoline_code): Replace DEPRECATED_SYMBOL_NAME
	with SYMBOL_LINKAGE_NAME.
	(struct reg, regsize): Delete.
	(read_memory_addr): Delete; inline into callers.
	(rs6000_skip_prologue): Move after skip_prologue.
	(skip_prologue): Remove prototype.
	(rs6000_gdbarch_init): Remove sysv_abi variable; perform all
	initialization as if this variable were true.  Do not install
	ppc64_sysv_abi_adjust_breakpoint_address.

	* rs6000-aix-tdep.c: Include "gdb_assert.h", "gdbtypes.h",
	"gdbcore.h", "target.h", "value.h", "infcall.h", "objfiles.h",
	and "breakpoint.h".
	(rs6000_find_toc_address_hook): Move here from rs6000-tdep.c.
	(SIG_FRAME_PC_OFFSET): Likewise.
	(SIG_FRAME_LR_OFFSET): Likewise.
	(SIG_FRAME_FP_OFFSET): Likewise.
	(rs6000_push_dummy_call): Likewise.
	(rs6000_return_value): Likewise.
	(rs6000_convert_from_func_ptr_addr): Likewise.
	(branch_dest, rs6000_software_single_step): Likewise.  Replace
	tdep->text_segment_base by AIX_TEXT_SEGMENT_BASE.
	(rs6000_aix_init_osabi): Install rs6000_push_dummy_call,
	rs6000_return_value, and rs6000_convert_from_func_ptr_addr.
	Call set_gdbarch_long_double_bit and set_gdbarch_frame_red_zone_size.
	Set tdep->lr_frame_offset.  Do not set tdep->text_segment_base.

	* rs6000-tdep.h (rs6000_software_single_step): Remove prototype.
	(AIX_TEXT_SEGMENT_BASE): New macro.
	* rs6000-nat.c (exec_one_dummy_insn): Replace tdep->text_segment_base
	by AIX_TEXT_SEGMENT_BASE.

	* ppc-tdep.h (ppc_deal_with_atomic_sequence): Add prototype.
	(struct gdbarch_tdep): Remove text_segment_base member.
	* ppc-linux-tdep.c (ppc_linux_init_abi): On 64-bit, install
	ppc64_sysv_abi_adjust_breakpoint_address.

	* Makefile.in (rs6000-tdep.o): Update dependencies.
	(rs6000-aix-tdep.o): Likewise.
@
text
@d559 1
a559 1
/* Support for convert_from_func_ptr_addr (ARCH, ADDR, TARG) on PPC
a570 6
   For PPC32, there are two kinds of function pointers: non-secure and
   secure.  Non-secure function pointers point directly to the
   function in a code section and thus need no translation.  Secure
   ones (from GCC's -msecure-plt option) are in a data section and
   contain one word: the address of the function.

d586 3
a588 3
ppc_linux_convert_from_func_ptr_addr (struct gdbarch *gdbarch,
				      CORE_ADDR addr,
				      struct target_ops *targ)
a589 1
  struct gdbarch_tdep *tdep;
a590 19
  char *sect_name = NULL;

  if (!s)
    return addr;

  tdep = gdbarch_tdep (gdbarch);

  switch (tdep->wordsize)
    {
      case 4:
	sect_name = ".plt";
	break;
      case 8:
	sect_name = ".opd";
	break;
      default:
	internal_error (__FILE__, __LINE__,
			_("failed internal consistency check"));
    }
d593 2
a594 7

  /* NOTE: this depends on the coincidence that the address of a functions
     entry point is contained in the first word of its function descriptor
     for both PPC-64 and for PPC-32 with secure PLTs.  */
  if ((strcmp (s->the_bfd_section->name, sect_name) == 0)
      && s->the_bfd_section->flags & SEC_DATA)
    return get_target_memory_unsigned (targ, addr, tdep->wordsize);
a996 5
  /* Handle PPC GNU/Linux 64-bit function pointers (which are really
     function descriptors) and 32-bit secure PLT entries.  */
  set_gdbarch_convert_from_func_ptr_addr
    (gdbarch, ppc_linux_convert_from_func_ptr_addr);

d1036 5
@


1.98
log
@ChangeLog:

	* Makefile.in (ppc_linux_tdep_h): New macro.
	(powerpc_32l_c, powerpc_altivec32_c, powerpc_altivec32l_c): Likewise.
	(powerpc_64l_c, powerpc_altivec64_c, powerpc_altivec64l_c): Likewise.
	(powerpc_e500l_c): Likewise.
	(ppc-linux-nat.o): Update dependencies.
	(ppc-linux-tdep.o): Update dependencies.
	(rs6000-tdep.o): Update dependencies.

	* ppc-tdep.h (ppc_linux_memory_remove_breakpoint): Remove.
	(ppc_linux_svr4_fetch_link_map_offsets): Remove.
	(ppc_linux_gregset, ppc_linux_fpregset): Move to ppc-linux-tdep.h
	(ppc_supply_reg, ppc_collect_reg): Add prototypes.
	(tdesc_powerpc_e500): Remove.

	* rs6000.c: Include "features/rs6000/powerpc-altivec32.c"
	and "features/rs6000/powerpc-altivec64.c".
	(ppc_supply_reg, ppc_collect_reg): Make global.
	(variants): Use tdesc_powerpc_32 for "powerpc" and
	tdesc_powerpc_altivec64 for "powerpc64".
	(_initialize_rs6000_tdep): Initialize AltiVec descriptions.

	* ppc-linux-tdep.h: New file.

	* ppc-linux-tdep.c: Include "ppc-linux-tdep.c".
	Include "features/rs6000/powerpc-32l.c".
	Include "features/rs6000/powerpc-altivec32l.c".
	Include "features/rs6000/powerpc-64l.c".
	Include "features/rs6000/powerpc-altivec64l.c".
	Include "features/rs6000/powerpc-e500l.c".
	(ppc_linux_supply_gregset): New function.
	(ppc_linux_collect_gregset): Handle orig_r3 and trap registers.
	(ppc32_linux_gregset): Use ppc_linux_supply_gregset.
	(ppc64_linux_gregset): Likewise.
	(ppc_linux_sigtramp_cache): Handle orig_r3 and trap registers.
	(ppc_linux_trap_reg_p): New function.
	(ppc_linux_write_pc): New function.
	(ppc_linux_core_read_description): New function.
	(ppc_linux_init_abi): Install ppc_linux_write_pc and
	ppc_linux_core_read_description.  Install orig_r3 and trap
	registers if present in the target description.
	(_initialize_ppc_linux_tdep): Initialize Linux target descriptions.

	* ppc-linux-nat.c: Include "ppc-linux-tdep.h".
	(PT_ORIG_R3, PT_TRAP): Define if necessary.
	(ppc_register_u_addr): Handle orig_r3 and trap registers.
	(fetch_ppc_registers): Likewise.
	(store_ppc_registers): Likewise.
	(store_register): Likewise.
	(ppc_linux_read_description): Check whether AltiVec is supported.
	Check whether inferior is 32-bit or 64-bit.  Return the appropriate
	Linux target description.

	* features/Makefile (WHICH): Use rs6000/powerpc-32l and
	rs6000/powerpc-altivec32l instead of rs6000/powerpc-32.
	Use rs6000/powerpc-64l and rs6000/powerpc-altivec64l instead
	of rs6000/powerpc-64.  Use rs6000/powerpc-e500l instead of
	rs6000/powerpc-e500.  Update -expedite variables accordingly.

	* features/rs6000/power-spe.xml: Use regnum 73 for "acc".
	* features/rs6000/powerpc-32.xml: Do not include power-altivec.xml.
	* features/rs6000/powerpc-64.xml: Do not include power-altivec.xml.
	* features/rs6000/powerpc-e500.c: Regenerate.
	* features/rs6000/powerpc-32.c: Regenerate.
	* features/rs6000/powerpc-64.c: Regenerate.

	* features/rs6000/power-linux.xml: New file.
	* features/rs6000/power64-linux.xml: New file.
	* features/rs6000/powerpc-32l.xml: New file.
	* features/rs6000/powerpc-altivec32l.xml: New file.
	* features/rs6000/powerpc-64l.xml: New file.
	* features/rs6000/powerpc-altivec64l.xml: New file.
	* features/rs6000/powerpc-e500l.xml: New file.
	* features/rs6000/powerpc-32l.c: New (generated) file.
	* features/rs6000/powerpc-altivec32l.c: New (generated) file.
	* features/rs6000/powerpc-64l.c: New (generated) file.
	* features/rs6000/powerpc-altivec64l.c: New (generated) file.
	* features/rs6000/powerpc-e500l.xml: New (generated) file.

	* regformats/reg-ppc.dat: Remove.
	* regformats/reg-ppc64.dat: Remove.
	* regformats/rs6000/powerpc-32.dat: Remove.
	* regformats/rs6000/powerpc-64.dat: Remove.
	* regformats/rs6000/powerpc-e500.dat: Remove.
	* regformats/rs6000/powerpc-32l.dat: New (generated) file.
	* regformats/rs6000/powerpc-altivec32l.dat: New (generated) file.
	* regformats/rs6000/powerpc-64l.dat: New (generated) file.
	* regformats/rs6000/powerpc-altivec64l.dat: New (generated) file.
	* regformats/rs6000/powerpc-e500l.dat: New (generated) file.

gdbserver/ChangeLog:

	* configure.srv (powerpc*-*-linux*): Set srv_regobj to
	powerpc-32l.o, powerpc-altivec32l.o, powerpc-e500l.o,
	powerpc-64l.o, and powerpc-altivec64l.o.
	Remove rs6000/powerpc-32.xml, rs6000/powerpc-64.xml, and
	rs6000/powerpc-e500.xml; add rs6000/powerpc-32l.xml,
	rs6000/powerpc-altivec32l.xml, rs6000/powerpc-e500l.xml,
	rs6000/powerpc-64l.xml, rs6000/powerpc-altivec64l.xml,
	rs6000/power-linux.xml, and rs6000/power64-linux.xml
	to srv_xmlfiles.

	* Makefile.in (reg-ppc.o, reg-ppc.c): Remove, replace by ...
	(powerpc-32l.o, powerpc-32l.c): ... these new rules.
	(powerpc-32.o, powerpc-32.c): Remove, replace by ...
	(powerpc-altivec32l.o, powerpc-altivec32l.c): ... these new rules.
	(powerpc-e500.o, powerpc-e500.c): Remove, replace by ...
	(powerpc-e500l.o, powerpc-e500l.c): ... these new rules.
	(reg-ppc64.o, reg-ppc64.c): Remove, replace by ...
	(powerpc-64l.o, powerpc-64l.c): ... these new rules.
	(powerpc-64.o, powerpc-64.c): Remove, replace by ...
	(powerpc-altivec64l.o, powerpc-altivec64l.c): ... these new rules.
	(clean): Update.

	* linux-ppc-low.c (init_registers_ppc): Remove, replace by ...
	(init_registers_powerpc_32l): ... this new prototype.
	(init_registers_powerpc_32): Remove, replace by ...
	(init_registers_powerpc_altivec32l): ... this new prototype.
	(init_registers_powerpc_e500): Remove, replace by ...
	(init_registers_powerpc_e500l): ... this new prototype.
	(init_registers_ppc64): Remove, replace by ...
	(init_registers_powerpc_64l): ... this new prototype.
	(init_registers_powerpc_64): Remove, replace by ...
	(init_registers_powerpc_altivec64l): ... this new prototype.
	(ppc_num_regs): Set to 73.
	(PT_ORIG_R3, PT_TRAP): Define if necessary.
	(ppc_regmap, ppc_regmap_e500): Add values for orig_r3 and trap.
	(ppc_cannot_store_register): Handle orig_r3 and trap.
	(ppc_arch_setup): Update init_registers_... calls.
	(ppc_fill_gregset): Handle orig_r3 and trap.

	* inferiors.c (clear_inferiors): Reset current_inferior.
@
text
@d1063 9
@


1.97
log
@	* hppanbsd-tdep.c, m68kbsd-tdep.c, mn10300-linux-tdep.c,
	ppc-linux-tdep.c, ppcnbsd-tdep.c, sparc-linux-tdep.c,
	sparc64-linux-tdep.c: Update for unwinder changes.
@
text
@d37 1
d42 6
d630 26
a655 2
/* This wrapper clears areas in the linux gregset not written by
   ppc_collect_gregset.  */
d662 3
d667 1
d669 15
d739 1
a739 1
  ppc_supply_gregset,
d746 1
a746 1
  ppc_supply_gregset,
d842 8
d956 57
d1018 1
d1033 3
d1073 1
d1078 22
d1113 7
@


1.96
log
@doc/ChangeLog:
--------------

	* gdb.texinfo (Set SH Calling convention): New @@item.
	(Show SH Calling convention): Ditto.

ChangeLog:
----------

	* NEWS: Add information on calling convention and new SH CLI options.

	* sh-tdep.c (sh_cc_gcc): New static string.
	(sh_cc_renesas): Ditto.
	(sh_cc_enum): New static string array.
	(sh_active_calling_convention): New static string pointer denoting
	active user chosen ABI.
	(sh_is_renesas_calling_convention): New function to return function
	specific ABI, or user choice if necessary.
	(sh_use_struct_convention): Rename first argument and turn around its
	meaning.  Check for renesas ABI and return accordingly.
	(sh_use_struct_convention_nofpu): New function.
	(sh_next_flt_argreg): Get function type as third parameter.  Check
	for renesas ABI and choose floating registers accordingly.
	(sh_push_dummy_call_fpu): Check for ABI and choose argument slot and
	struct return slot accordingly.
	(sh_push_dummy_call_nofpu): Ditto.
	(sh_return_value_nofpu): Call sh_use_struct_convention_nofpu from here.
	Evaluate ABI and give to sh_use_struct_convention_nofpu.
	(sh_return_value_fpu):  Evaluate ABI and give to
	sh_use_struct_convention.
	(show_sh_command): New function.
	(set_sh_command): Ditto.
	(_initialize_sh_tdep): Initialize `set/show sh calling-convention
	CLI command.

	* gdbarch.sh (return_value): Add func_type argument.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Ditto.
	* eval.c (evaluate_subexp_standard): Rename local variable value_type to
	val_type so as not to collide with value_type function.  Call
	using_struct_return with additional function type argument.
	* infcall.c (call_function_by_hand): Call using_struct_return and
	gdbarch_return_value with additional function type argument.
	* infcmd.c (print_return_value): Take addition func_type argument.
	Call gdbarch_return_value with additional function type argument.
	(finish_command_continuation): Call print_return_value with additional
	function type argument.
	(finish_command): Ditto.
	* sparc-tdep.c (sparc32_push_dummy_code): Call using_struct_return with
	additional function type argument.
	* stack.c (return_command): Call using_struct_return and
	gdbarch_return_value with additional function type argument.
	* value.c (using_struct_return): Take additional function type argument.
	* value.h (using_struct_return): Accommodate declaration.
	* alpha-tdep.c (alpha_return_value): Add func_type argument.
	* amd64-tdep.c (amd64_return_value): Ditto.
	* arm-tdep.c (arm_return_value): Ditto.
	* avr-tdep.c (avr_return_value): Ditto.
	* cris-tdep.c (cris_return_value): Ditto.
	* frv-tdep.c (frv_return_value): Ditto.
	* h8300-tdep.c (h8300_return_value): Ditto.
	(h8300h_return_value): Ditto.
	* hppa-tdep.c (hppa32_return_value): Ditto.
	(hppa64_return_value): Ditto.
	* i386-tdep.c (i386_return_value): Ditto.
	* ia64-tdep.c (ia64_return_value): Ditto.
	* iq2000-tdep.c (iq2000_return_value): Ditto.
	* m32c-tdep.c (m32c_return_value): Ditto.
	* m32r-tdep.c (m32r_return_value): Ditto.
	* m68hc11-tdep.c (m68hc11_return_value): Ditto.
	* m68k-tdep.c (m68k_return_value): Ditto.
	(m68k_svr4_return_value): Ditto.
	* m88k-tdep.c  (m88k_return_value): Ditto.
	* mep-tdep.c (mep_return_value): Ditto.
	* mips-tdep.c (mips_eabi_return_value): Ditto.
	(mips_n32n64_return_value): Ditto.
	(mips_o32_return_value): Ditto.
	(mips_o64_return_value): Ditto.
	* mn10300-tdep.c (mn10300_return_value): Ditto.
	* mt-tdep.c (mt_return_value): Ditto.
	* ppc-linux-tdep.c (ppc_linux_return_value): Ditto.
	* ppc-sysv-tdep.c (ppc_sysv_abi_return_value): Ditto.
	(ppc_sysv_abi_broken_return_value): Ditto.
	(ppc64_sysv_abi_return_value): Ditto.
	* ppc-tdep.h (ppc_sysv_abi_return_value): Ditto.
	(ppc_sysv_abi_broken_return_value): Ditto.
	(ppc64_sysv_abi_return_value): Ditto.
	* ppcnbsd-tdep.c (ppcnbsd_return_value): Ditto.
	* rs6000-tdep.c (rs6000_return_value): Ditto.
	* s390-tdep.c (s390_return_value): Ditto.
	* score-tdep.c (score_return_value): Ditto.
	* sh-tdep.c (sh_return_value_nofpu): Ditto.
	(sh_return_value_fpu): Ditto.
	* sh64-tdep.c (sh64_return_value): Ditto.
	* sparc-tdep.c (sparc32_return_value): Ditto.
	* sparc64-tdep.c (sparc64_return_value): Ditto.
	* spu-tdep.c (spu_return_value): Ditto.
	* v850-tdep.c (v850_return_value): Ditto.
	* vax-tdep.c (vax_return_value): Ditto.
	* xstormy16-tdep.c (xstormy16_return_value): Ditto.
	* xtensa-tdep.c (xtensa_return_value): Ditto.

	* gdbtypes.h (struct type): Add calling_convention member.
	* dwarf2read.c (read_subroutine_type): Add calling convention read
	from DW_AT_calling_convention attribute to function type.
@
text
@d747 1
a747 1
ppc_linux_sigtramp_cache (struct frame_info *next_frame,
d757 1
a757 1
  struct gdbarch *gdbarch = get_frame_arch (next_frame);
d760 3
a762 3
  base = frame_unwind_register_unsigned (next_frame,
					 gdbarch_sp_regnum (gdbarch));
  if (bias > 0 && frame_pc_unwind (next_frame) != func)
d809 1
a809 1
				  struct frame_info *next_frame,
d813 1
a813 1
  ppc_linux_sigtramp_cache (next_frame, this_cache, func,
d821 1
a821 1
				  struct frame_info *next_frame,
d825 1
a825 1
  ppc_linux_sigtramp_cache (next_frame, this_cache, func,
d833 1
a833 1
				   struct frame_info *next_frame,
d837 1
a837 1
  ppc_linux_sigtramp_cache (next_frame, this_cache, func,
d845 1
a845 1
				   struct frame_info *next_frame,
d849 1
a849 1
  ppc_linux_sigtramp_cache (next_frame, this_cache, func,
@


1.95
log
@	* breakpoint.h (breakpoint_restore_shadows): New
	declaration.
	* breakpoint.c (breakpoint_restore_shadows): New.
	(read_memory_nobpt): Delete.
	* gdbcore.h (read_memory_nobpt): Delete declaration.
	* target.c (memory_xfer_partial): Call
	breakpoint_restore_shadows.
	(restore_show_memory_breakpoints)
	(make_show_memory_beakpoints_cleanup): New.
	(show_memory_breakpoints): New.
	* target.h (make_show_memory_beakpoints_cleanup): Declare.
	* ppc-linux-tdep.c (ppc_linux_memory_remove_breakpoint):
	Make sure we see memory breakpoints when checking if
	breakpoint is still there.
	* alpha-tdep.c, alphanbsd-tdep.c, frame.c, frv-tdep.c,
	hppa-linux-tdep.c, hppa-tdep.c, i386-linux-nat.c, i386-tdep.c,
	m68klinux-tdep.c, mips-tdep.c, mn10300-tdep.c, s390-tdep.c,
	sparc-tdep.c: Use target_read_memory instead of read_memory_nobpt.
@
text
@d311 3
a313 3
ppc_linux_return_value (struct gdbarch *gdbarch, struct type *valtype,
			struct regcache *regcache, gdb_byte *readbuf,
			const gdb_byte *writebuf)
d321 2
a322 2
    return ppc_sysv_abi_return_value (gdbarch, valtype, regcache, readbuf,
				      writebuf);
@


1.94
log
@
	* gdbarch.sh (memory_insert_breakpoint, memory_remove_breakpoint): Add
	gdbarch as parameter.

	* gdbarch.{c,h}: Regenerate.

	* ppc-tdep.h (ppc_linux_memory_remove_breakpoint): Add gdbarch as
	parameter.
	* mem-break.c (default_memory_insert_breakpoint)
	(default_memory_remove_breakpoint): Likewise.
	* target.h (default_memory_remove_breakpoint)
	(default_memory_insert_breakpoint): Likewise.

	* ppc-linux-tdep.c (ppc_linux_memory_remove_breakpoint): Add gdbarch as
	parameter. Replace current_gdbarch by gdbarch.
	* m32r-tdep.c (m32r_memory_insert_breakpoint)
	(m32r_memory_remove_breakpoint): Likewise.
@
text
@d284 1
d291 2
d301 1
@


1.93
log
@	Updated copyright notices for most files.
@
text
@d276 2
a277 1
ppc_linux_memory_remove_breakpoint (struct bp_target_info *bp_tgt)
d286 1
a286 1
  bp = gdbarch_breakpoint_from_pc (current_gdbarch, &addr, &bplen);
@


1.92
log
@2007-11-16  Markus Deuling  <deuling@@de.ibm.com>

	* m32r-rom.c (m32r_supply_register): Use get_regcache_arch to get at
	the current architecture by regcache.
	* ppcnbsd-nat.c (ppcnbsd_supply_pcb): Likewise.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_spe_register)
	(fetch_register, supply_vrregset, fetch_ppc_registers)
	(store_altivec_register, store_spe_register, store_register)
	(fill_vrregset, store_ppc_registers): Likewise.
	* ppcobsd-nat.c (ppcobsd_supply_pcb): Likewise.
	* win32-nat.c (do_win32_fetch_inferior_registers)
	(do_win32_store_inferior_registers): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* remote-m32r-sdi.c (m32r_fetch_registers)
	(m32r_store_registers): Likewise.
	* remote-sim.c (gdbsim_fetch_register, gdbsim_store_register): Likewise.

	* trad-frame.c (trad_frame_alloc_saved_regs): Replace current_gdbarch by
	gdbarch.
	* user-regs.c (user_reg_map_name_to_regnum): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call)
	(do_ppc_sysv_return_value, ppc64_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_return_value): Likewise.
	* m32c-tdep.c (m32c_register_reggroup_p): Likewise.
	* m2-lang.c (build_m2_types): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache
	* ppcnbsd-tdep.c (ppcnbsd_sigtramp_cache_init): Likewise.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_cache): Likewise.
	* rs6000-tdep.c (ppc_dwarf2_frame_init_reg): Likewise.

	* m68hc11-tdep.c (m68hc11_frame_unwind_cache): Use get_frame_arch to
	get at the current architecture by frame_info.
	* gcore.c (derive_stack_segment): Likewise.

	* shnbsd-nat.c (GETREGS_SUPPLIES): Add gdbarch parameter.
	(shnbsd_fetch_inferior_registers, shnbsd_store_inferior_registers): Add
	gdbarch to GETREGS_SUPPLIES call.
@
text
@d4 1
a4 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
@


1.91
log
@include:
2007-11-07  Joseph Myers  <joseph@@codesourcery.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>

	* floatformat.h (struct floatformat): Add split_half field.
	(floatformat_ibm_long_double): New.

libiberty:
2007-11-07  Joseph Myers  <joseph@@codesourcery.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>

	* floatformat.c (mant_bits_set): New.
	(floatformat_to_double): Use it.  Note no special handling of
	split formats.
	(floatformat_from_double): Note no special handing of split
	formats.
	(floatformat_ibm_long_double_is_valid,
	floatformat_ibm_long_double): New.
	(floatformat_ieee_single_big, floatformat_ieee_single_little,
	floatformat_ieee_double_big, floatformat_ieee_double_little,
	floatformat_ieee_double_littlebyte_bigword, floatformat_vax_f,
	floatformat_vax_d, floatformat_vax_g, floatformat_i387_ext,
	floatformat_m68881_ext, floatformat_i960_ext,
	floatformat_m88110_ext, floatformat_m88110_harris_ext,
	floatformat_arm_ext_big, floatformat_arm_ext_littlebyte_bigword,
	floatformat_ia64_spill_big, floatformat_ia64_spill_little,
	floatformat_ia64_quad_big, floatformat_ia64_quad_little): Update
	for addition of split_half field.

gdb:
2007-11-07  Joseph Myers  <joseph@@codesourcery.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>

	* gdbtypes.c (floatformats_ibm_long_double): New.
	* gdbtypes.h (floatformats_ibm_long_double): Declare.
	* ia64-tdep.c (floatformat_ia64_ext): Update for addition of
	split_half field.
	* mips-tdep.c (n32n64_floatformat_always_valid,
	floatformat_n32n64_long_double_big, floatformats_n32n64_long):
	Remove.
	(mips_gdbarch_init): Use floatformats_ibm_long_double instead of
	floatformats_n32n64_long.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Use 128-bit IBM long
	double.
	* doublest.c (convert_floatformat_to_doublest,
	convert_doublest_to_floatformat): Handle split floating-point
	formats.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call): Handle IBM long
	double arguments.
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	(do_ppc_sysv_return_value): Handle IBM long double return.
@
text
@d756 1
a756 1
					 gdbarch_sp_regnum (current_gdbarch));
d776 1
a776 1
			   gdbarch_pc_regnum (current_gdbarch),
d792 1
a792 1
	  int regnum = i + gdbarch_fp0_regnum (current_gdbarch);
@


1.90
log
@	* ppc-linux-tdep.c (ppc_linux_skip_trampoline_code): Fall back to
	find_solib_trampoline_target if PC is not in .plt section.
@
text
@d899 7
a905 9
  /* NOTE: jimb/2004-03-26: The System V ABI PowerPC Processor
     Supplement says that long doubles are sixteen bytes long.
     However, as one of the known warts of its ABI, PPC GNU/Linux uses
     eight-byte long doubles.  GCC only recently got 128-bit long
     double support on PPC, so it may be changing soon.  The
     Linux[sic] Standards Base says that programs that use 'long
     double' on PPC GNU/Linux are non-conformant.  */
  /* NOTE: cagney/2005-01-25: True for both 32- and 64-bit.  */
  set_gdbarch_long_double_bit (gdbarch, 8 * TARGET_CHAR_BIT);
@


1.89
log
@	* ppc-linux-tdep.c (ppc32_linux_reg_offsets): Corrected
	swapped offsets and VRSAVE offset.
	(ppc64_linux_reg_offsets): Corrected swapped offsets.
	(ppc32_linux_vrregset): Added.
	(ppc_linux_regset_from_core_section): Added support for
	.reg-ppc-vmx section.
	* ppc-tdep.h (ppc_altivec_support_p): Declare.
	(ppc_supply_vrregset): Declare.
	(ppc_collect_vrregset): Declare.
	* rs6000-tdep.c (ppc_altivec_support_p): Added.
	(ppc_supply_vrregset): Added.
	(ppc_collect_vrregset): Added.
	* corelow.c (get_core_registers): Added support for
	.reg-ppc-vmx section.
@
text
@d60 1
a60 1
  /* Find the section pc is in; return if not in .plt */
d63 1
a63 1
    return 0;
@


1.88
log
@	* ppc-linux-nat.c (right_fill_reg): Delete.
	(supply_gregset): Use ppc_supply_gregset.
	(supply_fpregset): Use ppc_supply_fpregset.
	(fill_gregset): Use ppc_collect_gregset.
	(fill_fpregset): Use ppc_collect_fpregset.
	* ppc-linux-tdep.c (PPC_LINUX_PT_*): Don't define.
	(right_supply_register, ppc_linux_supply_gregset): Delete.
	(ppc32_linux_supply_gregset, ppc64_linux_supply_gregset): Delete.
	(ppc_linux_supply_fpregset): Delete.
	(ppc_linux_collect_gregset): New function.
	(ppc32_linux_reg_offsets, ppc64_linux_reg_offsets): New.
	(ppc32_linux_gregset, ppc64_linux_gregset): Update to use reg offsets,
	ppc_linux_supply_gregset, and ppc_collect_gregset.
	(ppc_linux_fpregset): Rename to ppc32_linux_fpregset and update.
	(ppc_linux_gregset, ppc_linux_fpregset): New functions.
	(ppc_linux_regset_from_core_section): Update.
	* ppc-tdep.h (ppc_linux_gregset, ppc_linux_fpregset): Declare.
	(ppc_linux_supply_gregset, ppc_linux_supply_fpregset): Delete.
	(struct ppc_reg_offsets): Add gpr_size, xr_size, fpscr_size fields.
	* ppcobsd-tdep.c (ppcobsd_supply_gregset): Delete FIXME and assert.
	(ppcobsd_collect_gregset): Likewise.
	(_initialize_ppcnbsd_tdep): Init gpr_size, xr_size, fpscr_size.
	* ppcnbsd-tdep.c (_initialize_ppcobsd_tdep): Likewise.
	* ppcobsd-nat.c (_initialize_ppcobsd_nat): Likewise.
	* rs6000-aix-tdep.c (rs6000_aix32_reg_offsets): Likewise.
	(rs6000_aix64_reg_offsets): Likewise.
	(rs6000_aix_supply_regset): Call ppc_supply_fpregset without testing
	ppc_floating_point_unit_p.
	(rs6000_aix_collect_regset): Similarly.
	* rs6000-tdep.c (ppc_supply_reg): Add regsize param.  Adjust offset
	when regsize is larger than regcache register size.
	(ppc_collect_reg): Similarly zero pad when regsize is larger than
	regcache register size.
	(ppc_greg_offset): New function, split out from..
	(ppc_supply_gregset): ..here.  Separate code handling all regs from
	single reg case.  Correct xer offset.
	(ppc_fpreg_offset): New function, split out from..
	(ppc_supply_fpregset): ..here.  Separate code handling all regs from
	single reg case.
	(ppc_collect_gregset, ppc_collect_fpregset): Likewise.
	(ppc_supply_fpregset, ppc_collect_fpregset): Don't assert we have
	a fp unit, instead return if no fp.
@
text
@d653 2
a654 2
    /* .vrsave_offset = */ 512,
    /* .vscr_offset = */ 512 + 12
d678 2
a679 2
    /* .vrsave_offset = */ 528,
    /* .vscr_offset = */ 512 + 12
d703 7
d736 2
@


1.87
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@a40 45
/* From <asm/ptrace.h>, values for PT_NIP, PT_R1, and PT_LNK */
#define PPC_LINUX_PT_R0		0
#define PPC_LINUX_PT_R1		1
#define PPC_LINUX_PT_R2		2
#define PPC_LINUX_PT_R3		3
#define PPC_LINUX_PT_R4		4
#define PPC_LINUX_PT_R5		5
#define PPC_LINUX_PT_R6		6
#define PPC_LINUX_PT_R7		7
#define PPC_LINUX_PT_R8		8
#define PPC_LINUX_PT_R9		9
#define PPC_LINUX_PT_R10	10
#define PPC_LINUX_PT_R11	11
#define PPC_LINUX_PT_R12	12
#define PPC_LINUX_PT_R13	13
#define PPC_LINUX_PT_R14	14
#define PPC_LINUX_PT_R15	15
#define PPC_LINUX_PT_R16	16
#define PPC_LINUX_PT_R17	17
#define PPC_LINUX_PT_R18	18
#define PPC_LINUX_PT_R19	19
#define PPC_LINUX_PT_R20	20
#define PPC_LINUX_PT_R21	21
#define PPC_LINUX_PT_R22	22
#define PPC_LINUX_PT_R23	23
#define PPC_LINUX_PT_R24	24
#define PPC_LINUX_PT_R25	25
#define PPC_LINUX_PT_R26	26
#define PPC_LINUX_PT_R27	27
#define PPC_LINUX_PT_R28	28
#define PPC_LINUX_PT_R29	29
#define PPC_LINUX_PT_R30	30
#define PPC_LINUX_PT_R31	31
#define PPC_LINUX_PT_NIP	32
#define PPC_LINUX_PT_MSR	33
#define PPC_LINUX_PT_CTR	35
#define PPC_LINUX_PT_LNK	36
#define PPC_LINUX_PT_XER	37
#define PPC_LINUX_PT_CCR	38
#define PPC_LINUX_PT_MQ		39
#define PPC_LINUX_PT_FPR0	48	/* each FP reg occupies 2 slots in this space */
#define PPC_LINUX_PT_FPR31 (PPC_LINUX_PT_FPR0 + 2*31)
#define PPC_LINUX_PT_FPSCR (PPC_LINUX_PT_FPR0 + 2*32 + 1)


d618 3
d622 3
a624 2
right_supply_register (struct regcache *regcache, int wordsize, int regnum,
		       const bfd_byte *buf)
d626 3
a628 2
  regcache_raw_supply (regcache, regnum,
		       (buf + wordsize - register_size (current_gdbarch, regnum)));
d631 25
a655 3
/* Extract the register values found in the WORDSIZED ABI GREGSET,
   storing their values in REGCACHE.  Note that some are left-aligned,
   while others are right aligned.  */
d657 31
a687 31
void
ppc_linux_supply_gregset (struct regcache *regcache,
			  int regnum, const void *gregs, size_t size,
			  int wordsize)
{
  int regi;
  struct gdbarch *regcache_arch = get_regcache_arch (regcache); 
  struct gdbarch_tdep *regcache_tdep = gdbarch_tdep (regcache_arch);
  const bfd_byte *buf = gregs;

  for (regi = 0; regi < ppc_num_gprs; regi++)
    right_supply_register (regcache, wordsize,
                           regcache_tdep->ppc_gp0_regnum + regi,
                           buf + wordsize * regi);

  right_supply_register (regcache, wordsize, gdbarch_pc_regnum (regcache_arch),
			 buf + wordsize * PPC_LINUX_PT_NIP);
  right_supply_register (regcache, wordsize, regcache_tdep->ppc_lr_regnum,
			 buf + wordsize * PPC_LINUX_PT_LNK);
  regcache_raw_supply (regcache, regcache_tdep->ppc_cr_regnum,
		       buf + wordsize * PPC_LINUX_PT_CCR);
  regcache_raw_supply (regcache, regcache_tdep->ppc_xer_regnum,
		       buf + wordsize * PPC_LINUX_PT_XER);
  regcache_raw_supply (regcache, regcache_tdep->ppc_ctr_regnum,
		       buf + wordsize * PPC_LINUX_PT_CTR);
  if (regcache_tdep->ppc_mq_regnum != -1)
    right_supply_register (regcache, wordsize, regcache_tdep->ppc_mq_regnum,
			   buf + wordsize * PPC_LINUX_PT_MQ);
  right_supply_register (regcache, wordsize, regcache_tdep->ppc_ps_regnum,
			 buf + wordsize * PPC_LINUX_PT_MSR);
}
d689 6
a694 7
static void
ppc32_linux_supply_gregset (const struct regset *regset,
			    struct regcache *regcache,
			    int regnum, const void *gregs, size_t size)
{
  ppc_linux_supply_gregset (regcache, regnum, gregs, size, 4);
}
d696 5
a700 2
static struct regset ppc32_linux_gregset = {
  NULL, ppc32_linux_supply_gregset
d703 2
a704 4
static void
ppc64_linux_supply_gregset (const struct regset *regset,
			    struct regcache * regcache,
			    int regnum, const void *gregs, size_t size)
d706 1
a706 1
  ppc_linux_supply_gregset (regcache, regnum, gregs, size, 8);
d709 4
a712 26
static struct regset ppc64_linux_gregset = {
  NULL, ppc64_linux_supply_gregset
};

void
ppc_linux_supply_fpregset (const struct regset *regset,
			   struct regcache * regcache,
			   int regnum, const void *fpset, size_t size)
{
  int regi;
  struct gdbarch *regcache_arch = get_regcache_arch (regcache); 
  struct gdbarch_tdep *regcache_tdep = gdbarch_tdep (regcache_arch);
  const bfd_byte *buf = fpset;

  if (! ppc_floating_point_unit_p (regcache_arch))
    return;

  for (regi = 0; regi < ppc_num_fprs; regi++)
    regcache_raw_supply (regcache, 
                         regcache_tdep->ppc_fp0_regnum + regi,
                         buf + 8 * regi);

  /* The FPSCR is stored in the low order word of the last
     doubleword in the fpregset.  */
  regcache_raw_supply (regcache, regcache_tdep->ppc_fpscr_regnum,
                       buf + 8 * 32 + 4);
a714 2
static struct regset ppc_linux_fpregset = { NULL, ppc_linux_supply_fpregset };

d728 1
a728 1
    return &ppc_linux_fpregset;
@


1.86
log
@2007-07-03  Paul Gilliam  <pgilliam@@us.ibm.com>
	    Thiago Bauermann  <bauerman@@br.ibm.com>
	    Joseph S. Myers  <joseph@@codesourcery.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>

	gdb/
	* remote.c (remote_check_symbols): Use
	gdbarch_convert_from_func_ptr_addr.
	* infcall.c (find_function_addr): Handle function descriptors
	without debugging information.
	* ppc-linux-tdep.c (ppc_linux_convert_from_func_ptr_addr): Renamed
	from ppc64_linux_convert_from_func_ptr_addr.  Handle -msecure-plt.
	(ppc_linux_init_abi): Always set convert_from_func_ptr_addr.
	* solib-svr4.c (solib_break_names): Remove "._dl_debug_state".
	(bfd_lookup_symbol): Do not take a SECT_FLAGS argument.  Always
	allow SEC_CODE and SEC_DATA.
	(enable_break): Update calls.  Pass current_target to solib_add.
	Use gdbarch_convert_from_func_ptr_addr.

	gdb/gdbserver/
	* remote-utils.c (look_up_one_symbol): Handle 'm' packets.
@
text
@d11 1
a11 1
   the Free Software Foundation; either version 2 of the License, or
d20 1
a20 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.85
log
@2007-06-18  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (SP_REGNUM): Replace by gdbarch_sp_regnum.
	* v850-tdep.c (v850_unwind_sp): Likewise.
	* std-regs.c (value_of_builtin_frame_sp_reg): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh-tdep.c (sh_push_dummy_call_fpu, sh_push_dummy_call_nofpu)
	(sh_dwarf2_frame_init_reg, sh_frame_cache, sh_frame_prev_register)
	(sh_unwind_sp): Likewise.
	* sh64-tdep.c (sh64_push_dummy_call, sh64_frame_cache)
	(sh64_frame_prev_register, sh64_unwind_sp): Likewise.
	* rs6000-tdep.c (rs6000_push_dummy_call, rs6000_unwind_dummy_id)
	(rs6000_frame_cache): Likewise.
	* rs6000-nat.c (store_register): Likewise.
	* remote-mips.c (mips_wait): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_cache): Likewise.
	* ppcobsd-nat.c (ppcobsd_supply_pcb): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_sigtramp_cache_init): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* m32r-rom.c (m32r_supply_register): Likewise.
	* frame.c (frame_sp_unwind): Likewise.
	* mips-tdep.c (mips_insn16_frame_cache)
	(mips_insn32_frame_cache): Likewise (comment).
	* m68klinux-nat.c (supply_gregset): Likewise.
	* m68k-tdep.c (m68k_get_longjmp_target): Likewise.
	* ia64-tdep.c (ia64_frame_prev_register): Likewise.
	* i386-tdep.c (i386_get_longjmp_target): Likewise.
	* dwarf2-frame.c (dwarf2_frame_default_init_reg): Likewise.
	* cris-tdep.c (cris_regnums, cris_sigcontext_addr)
	(cris_sigtramp_frame_unwind_cache, cris_push_dummy_call)
	(cris_scan_prologue, crisv32_scan_prologue, cris_unwind_sp)
	(cris_register_type, crisv32_register_type)
	(cris_dwarf2_frame_init_reg): Likewise.
	* arch-utils.c (legacy_virtual_frame_pointer): Likewise.
	* amd64-tdep.c (amd64_frame_prev_register): Likewise.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Likewise.
	* libunwind-frame.c (libunwind_frame_cache): Likewise.

	* gdbarch.sh (PC_REGNUM): Replace by gdbarch_pc_regnum.
	* regcache.c (read_pc_pid, generic_target_write_pc): Likewise.
	* xtensa-tdep.c (xtensa_register_type, xtensa_supply_gregset)
	(xtensa_unwind_pc, xtensa_frame_cache, xtensa_frame_prev_register)
	(xtensa_extract_return_value, xtensa_store_return_value): Likewise.
	* v850-tdep.c (v850_unwind_pc): Likewise.
	* stack.c (frame_info): Likewise.
	* sh-tdep.c (sh_generic_show_regs, sh3_show_regs, sh2e_show_regs)
	(sh2a_show_regs, sh2a_nofpu_show_regs, sh3e_show_regs)
	(sh3_dsp_show_regs, sh4_show_regs, sh4_nofpu_show_regs)
	(sh_dwarf2_frame_init_reg, sh_frame_prev_register, sh_unwind_pc)
	(sh_dsp_show_regs): Likewise.
	* shnbsd-tdep.c (shnbsd_supply_gregset)
	(shnbsd_collect_gregset): Likewise.
	* shnbsd-nat.c (GETREGS_SUPPLIES): Likewise.
	* sh64-tdep.c (sh64_compact_reg_base_num, sh64_show_media_regs)
	(sh64_frame_prev_register, sh64_unwind_pc): Likewise.
	* rs6000-tdep.c (ppc_supply_gregset, ppc_collect_gregset)
	(6000_register_reggroup_p, rs6000_unwind_pc)
	(rs6000_frame_cache): Likewise.
	* rs6000-nat.c (regmap, rs6000_fetch_inferior_registers)
	(rs6000_store_inferior_registers): Likewise.
	* remote-mips.c (mips_wait, mips_load): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_cache): Likewise.
	* ppcobsd-nat.c (ppcobsd_supply_pcb): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_sigtramp_cache_init): Likewise.
	* ppcnbsd-nat.c (getregs_supplies, ppcnbsd_supply_pcb): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* ppc-linux-nat.c (ppc_register_u_addr, fetch_ppc_registers)
	(store_ppc_registers, fill_gregset): Likewise.
	* mips-tdep.c (mips_stub_frame_cache, mips_gdbarch_init): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_supply_reg, mipsnbsd_fill_reg): Likewise.
	* mipsnbsd-nat.c (getregs_supplies): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_unwind_pc): Likewise.
	* m68klinux-nat.c (supply_gregset): Likewise.
	* irix5-nat.c (fill_gregset): Likewise.
	* i386-tdep.c (i386_unwind_pc): Likewise.
	* i386-linux-nat.c (i386_linux_resume): Likewise.
	* frame.c (get_prev_frame_1): Likewise.
	* dwarf2-frame.c (dwarf2_frame_default_init_reg): Likewise.
	* dbug-rom.c (dbug_supply_register): Likewise.
	* cris-tdep.c (cris_sigtramp_frame_unwind_cache, cris_scan_prologue)
	(crisv32_scan_prologue, cris_unwind_pc, cris_register_size)
	(cris_register_type, crisv32_register_type, crisv32_register_name)
	(cris_dwarf2_frame_init_reg, find_step_target)
	(cris_software_single_step, cris_supply_gregset)
	(cris_regnums): Likewise.
	* alpha-linux-nat.c (alpha_linux_register_u_offset): Likewise.
	* aix-thread.c (special_register_p, supply_sprs64, supply_sprs32)
	(fill_sprs64, fill_sprs32, store_regs_user_thread): Likewise.
	* mips-linux-tdep.c (mips_linux_write_pc): Likewise.

	* gdbarch.sh (PS_REGNUM): Replace by gdbarch_ps_regnum.
	* dbug-rom.c (dbug_supply_register): Likewise.
	* xtensa-tdep.c (xtensa_supply_gregset, xtensa_frame_cache)
	(xtensa_frame_prev_register, xtensa_push_dummy_call): Likewise.
	* win32-nat.c (win32_resume): Likewise.
	* std-regs.c (value_of_builtin_frame_ps_reg)
	(value_of_builtin_frame_pc_reg): Likewise.
	* m68k-tdep.c (m68k_register_type): Likewise.
	* m68klinux-nat.c (supply_gregset): Likewise.

	* gdbarch.sh (FP0_REGNUM): Replace by gdbarch_fp0_regnum.
	* sh-tdep.c (sh_extract_return_value_fpu, sh_store_return_value_fpu)
	(sh2e_show_regs, sh2a_show_regs, sh3e_show_regs, sh4_show_regs)
	(sh_sh2a_register_type, sh_sh3e_register_type, sh_sh4_register_type)
	(fv_reg_base_num, dr_reg_base_num): Likewise.
	* sh64-tdep.c (sh64_fv_reg_base_num, sh64_dr_reg_base_num)
	(sh64_fpp_reg_base_num, sh64_compact_reg_base_num, sh64_push_dummy_call)
	(sh64_extract_return_value, sh64_store_return_value)
	(sh64_show_media_regs, sh64_show_compact_regs, sh64_register_type)
	(sh64_do_fp_register, sh64_media_print_registers_info): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers)
	(invalidate_cache): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_supply_fpreg)
	(mipsnbsd_fill_fpreg): Likewise.
	* mipsnbsd-nat.c (mipsnbsd_fetch_inferior_registers)
	(mipsnbsd_store_inferior_registers): Likewise.
	* mips-linux-tdep.c (mips_supply_fpregset, mips_fill_fpregset)
	(mips64_supply_fpregset, mips64_fill_fpregset): Likewise.
	* mips-linux-nat.c (mips64_linux_register_addr): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_convert_register_p): Likewise.
	* m68klinux-nat.c (getfpregs_supplies, supply_fpregset)
	(fill_fpregset): Likewise.
	* irix5-nat.c (supply_fpregset, fill_fpregset): Likewise.
	* i386-tdep.h (struct_return): Likewise (comment).
	* i386-nto-tdep.c (i386nto_register_area): Likewise.
	* go32-nat.c (fetch_register, go32_fetch_registers, store_register)
	(go32_store_registers): Likewise.
	* alpha-tdep.c (alpha_next_pc): Likewise.
	* alpha-linux-nat.c (alpha_linux_register_u_offset): Likewise.
	* alphabsd-nat.c (alphabsd_fetch_inferior_registers)
	(alphabsd_store_inferior_registers): Likewise.
	* core-regset.c (fetch_core_registers): Likewise.
	* i386v4-nat.c (supply_fpregset, fill_fpregset): Likewise.

	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d594 1
a594 1
/* Support for CONVERT_FROM_FUNC_PTR_ADDR (ARCH, ADDR, TARG) on PPC64
d598 16
a613 7
   of the function. On GNU/Linux on the 64-bit PowerPC however, a
   function pointer is represented by a pointer to a TOC entry. This
   TOC entry contains three words, the first word is the address of
   the function, the second word is the TOC pointer (r2), and the
   third word is the static chain value.  Throughout GDB it is
   currently assumed that a function pointer contains the address of
   the function, which is not easy to fix.  In addition, the
d619 1
a619 1
   from a function pointer.  */
d621 4
a624 4
/* If ADDR points at what is clearly a function descriptor, transform
   it into the address of the corresponding function.  Be
   conservative, otherwize GDB will do the transformation on any
   random addresses such as occures when there is no symbol table.  */
d627 3
a629 3
ppc64_linux_convert_from_func_ptr_addr (struct gdbarch *gdbarch,
					CORE_ADDR addr,
					struct target_ops *targ)
d631 1
d633 19
d654 7
a660 2
  if (s && strcmp (s->the_bfd_section->name, ".opd") == 0)
    return get_target_memory_unsigned (targ, addr, 8);
d944 5
d976 1
a976 4
      /* Handle PPC64 GNU/Linux function pointers (which are really
         function descriptors).  */
      set_gdbarch_convert_from_func_ptr_addr
        (gdbarch, ppc64_linux_convert_from_func_ptr_addr);
a977 2

      /* Shared library handling.  */
@


1.84
log
@	* gdbarch.sh (skip_trampoline_code): Add FRAME argument.
	* gdbarch.c, gdbarch.h: Regenerate.
	* arch-utils.c (generic_skip_trampoline_code): Add FRAME argument.
	* arch-utils.h (generic_skip_trampoline_code): Likewise.
	* infrun.c (handle_inferior_event): Pass current frame to
	gdbarch_skip_trampoline_code and skip_language_trampoline.

	* language.c (unk_lang_trampoline): Add FRAME argument.
	(skip_language_trampoline): Add FRAME argument.  Pass it to
	skip_trampoline callback.
	* language.h: Add forward declaration of struct frame_info.
	(struct language_defn): Add FRAME argument to skip_trampoline.
	(skip_language_trampoline): Add FRAME argument.
	* cp-abi.c (cplus_skip_trampoline): Add FRAME argument.  Pass it
	to skip_trampoline callback.
	* cp-abi.h: Add forward declaration of struct frame_info.
	(cplus_skip_trampoline): Add FRAME argument.
	(struct cp_abi_ops): Add FRAME argument to skip_trampoline callback.
	* gnu-v3-abi.c (gnuv3_skip_trampoline): Add FRAME argument.  Pass it
	to gdbarch_skip_trampoline_code.
	* objc-lang.c (objc_skip_trampoline): Add FRAME argument.  Pass it
	to gdbarch_skip_trampoline_code.

	* minsyms.c (find_solib_trampoline_target): Add FRAME argument.
	* symtab.h (find_solib_trampoline_target): Likewise.
	* obsd-tdep.c (obsd_skip_solib_resolver): Pass current frame to
	find_solib_trampoline_target.

	* arm-tdep.c (arm_skip_stub): Add FRAME argument.  Read registers
	from FRAME instead of calling read_register.

	* hppa-hpux-tdep.c (hppa_hpux_skip_trampoline_code): Add FRAME
	argument.  Read registers from FRAME instead of using read_register.
	* hppa-tdep.c (hppa_skip_trampoline_code): Likewise.
	* hppa-tdep.h (hppa_skip_trampoline_code): Add FRAME argument.

	* i386-cygwin-tdep.c (i386_cygwin_skip_trampoline_code): Add FRAME
	argument.

	* m32c-tdep.c (m32c_skip_trampoline_code): Add FRAME argument.

	* mips-tdep.c (mips_skip_trampoline_code): Add FRAME argument.  Read
	registers from FRAME instead of using read_signed_register.

	* ppc-linux-tdep.c (ppc_linux_skip_trampoline_code): Add FRAME
	argument.
	(ppc64_standard_linkage_target): Likewise.  Read registers from FRAME
	instead of using read_register.
	(ppc64_skip_trampoline_code): Add FRAME argument.  Pass it to
	ppc64_standard_linkage_target.
	* rs6000-tdep.c (rs6000_skip_trampoline_code): Add FRAME argument.
	Pass it to find_solib_trampoline_target.  Read registers from FRAME
	instead of using read_register.

	* xstormy16-tdep.c (xstormy16_skip_trampoline_code): Add FRAME
	argument.
@
text
@d756 2
a757 1
  base = frame_unwind_register_unsigned (next_frame, SP_REGNUM);
d776 3
a778 1
  trad_frame_set_reg_addr (this_cache, PC_REGNUM, gpregs + 32 * tdep->wordsize);
d793 1
a793 1
	  int regnum = i + FP0_REGNUM;
@


1.83
log
@2007-06-13  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (BREAKPOINT_FROM_PC): Replace by
	gdbarch_breakpoint_from_pc.
	* s390-tdep.c (s390_gdbarch_init): Likewise (comment).
	* remote.c (remote_insert_breakpoint)
	(remote_insert_hw_breakpoint): Likewise.
	* ppc-linux-tdep.c (ppc_linux_memory_remove_breakpoint): Likewise.
	* mips-tdep.c (mips_breakpoint_from_pc): Likewise (comment).
	* breakpoint.h (bp_target_info): Likewise (comment).
	* breakpoint.c (read_memory_nobpt): Likewise.
	* mem-break.c (default_memory_insert_breakpoint): Likewise.
	(symtab.h, breakpoint.h): Remove include. Remove unnecessary comment.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d89 1
a89 1
ppc_linux_skip_trampoline_code (CORE_ADDR pc)
d560 2
a561 1
ppc64_standard_linkage_target (CORE_ADDR pc, unsigned int *insn)
d563 1
a563 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d568 2
a569 1
    = ((CORE_ADDR) read_register (tdep->ppc_gp0_regnum + 2)
d581 1
a581 1
ppc64_skip_trampoline_code (CORE_ADDR pc)
d587 2
a588 1
    return ppc64_standard_linkage_target (pc, ppc64_standard_linkage_insn);
@


1.82
log
@	* ppc-linux-tdep.c (INSTR_SC, INSTR_LI_R0_0x6666, INSTR_LI_R0_0x7777,
	INSTR_LI_R0_NR_sigreturn, INSTR_LI_R0_NR_rt_sigreturn): Remove.
	(PPC_LINUX_SIGNAL_FRAMESIZE, PPC_LINUX_REGS_PTR_OFFSET,
	PPC_LINUX_HANDLER_PTR_OFFSET): Remove.
	(ppc_linux_in_sigtramp, insn_is_sigreturn,
	ppc_linux_at_sigtramp_return_path): Remove.
@
text
@d332 1
a332 1
  bp = BREAKPOINT_FROM_PC (&addr, &bplen);
@


1.81
log
@Copyright updates for 2007.
@
text
@a42 27
/* The following instructions are used in the signal trampoline code
   on GNU/Linux PPC. The kernel used to use magic syscalls 0x6666 and
   0x7777 but now uses the sigreturn syscalls.  We check for both.  */
#define INSTR_LI_R0_0x6666		0x38006666
#define INSTR_LI_R0_0x7777		0x38007777
#define INSTR_LI_R0_NR_sigreturn	0x38000077
#define INSTR_LI_R0_NR_rt_sigreturn	0x380000AC

#define INSTR_SC			0x44000002

/* Since the *-tdep.c files are platform independent (i.e, they may be
   used to build cross platform debuggers), we can't include system
   headers.  Therefore, details concerning the sigcontext structure
   must be painstakingly rerecorded.  What's worse, if these details
   ever change in the header files, they'll have to be changed here
   as well. */

/* __SIGNAL_FRAMESIZE from <asm/ptrace.h> */
#define PPC_LINUX_SIGNAL_FRAMESIZE 64

/* From <asm/sigcontext.h>, offsetof(struct sigcontext_struct, regs) == 0x1c */
#define PPC_LINUX_REGS_PTR_OFFSET (PPC_LINUX_SIGNAL_FRAMESIZE + 0x1c)

/* From <asm/sigcontext.h>, 
   offsetof(struct sigcontext_struct, handler) == 0x14 */
#define PPC_LINUX_HANDLER_PTR_OFFSET (PPC_LINUX_SIGNAL_FRAMESIZE + 0x14)

a86 110
static int ppc_linux_at_sigtramp_return_path (CORE_ADDR pc);

/* Determine if pc is in a signal trampoline...

   Ha!  That's not what this does at all.  wait_for_inferior in
   infrun.c calls get_frame_type() in order to detect entry into a
   signal trampoline just after delivery of a signal.  But on
   GNU/Linux, signal trampolines are used for the return path only.
   The kernel sets things up so that the signal handler is called
   directly.

   If we use in_sigtramp2() in place of in_sigtramp() (see below)
   we'll (often) end up with stop_pc in the trampoline and prev_pc in
   the (now exited) handler.  The code there will cause a temporary
   breakpoint to be set on prev_pc which is not very likely to get hit
   again.

   If this is confusing, think of it this way...  the code in
   wait_for_inferior() needs to be able to detect entry into a signal
   trampoline just after a signal is delivered, not after the handler
   has been run.

   So, we define in_sigtramp() below to return 1 if the following is
   true:

   1) The previous frame is a real signal trampoline.

   - and -

   2) pc is at the first or second instruction of the corresponding
   handler.

   Why the second instruction?  It seems that wait_for_inferior()
   never sees the first instruction when single stepping.  When a
   signal is delivered while stepping, the next instruction that
   would've been stepped over isn't, instead a signal is delivered and
   the first instruction of the handler is stepped over instead.  That
   puts us on the second instruction.  (I added the test for the first
   instruction long after the fact, just in case the observed behavior
   is ever fixed.)  */

int
ppc_linux_in_sigtramp (CORE_ADDR pc, char *func_name)
{
  CORE_ADDR lr;
  CORE_ADDR sp;
  CORE_ADDR tramp_sp;
  gdb_byte buf[4];
  CORE_ADDR handler;

  lr = read_register (gdbarch_tdep (current_gdbarch)->ppc_lr_regnum);
  if (!ppc_linux_at_sigtramp_return_path (lr))
    return 0;

  sp = read_register (SP_REGNUM);

  if (target_read_memory (sp, buf, sizeof (buf)) != 0)
    return 0;

  tramp_sp = extract_unsigned_integer (buf, 4);

  if (target_read_memory (tramp_sp + PPC_LINUX_HANDLER_PTR_OFFSET, buf,
			  sizeof (buf)) != 0)
    return 0;

  handler = extract_unsigned_integer (buf, 4);

  return (pc == handler || pc == handler + 4);
}

static int
insn_is_sigreturn (unsigned long pcinsn)
{
  switch(pcinsn)
    {
    case INSTR_LI_R0_0x6666:
    case INSTR_LI_R0_0x7777:
    case INSTR_LI_R0_NR_sigreturn:
    case INSTR_LI_R0_NR_rt_sigreturn:
      return 1;
    default:
      return 0;
    }
}

/*
 * The signal handler trampoline is on the stack and consists of exactly
 * two instructions.  The easiest and most accurate way of determining
 * whether the pc is in one of these trampolines is by inspecting the
 * instructions.  It'd be faster though if we could find a way to do this
 * via some simple address comparisons.
 */
static int
ppc_linux_at_sigtramp_return_path (CORE_ADDR pc)
{
  gdb_byte buf[12];
  unsigned long pcinsn;
  if (target_read_memory (pc - 4, buf, sizeof (buf)) != 0)
    return 0;

  /* extract the instruction at the pc */
  pcinsn = extract_unsigned_integer (buf + 4, 4);

  return (
	   (insn_is_sigreturn (pcinsn)
	    && extract_unsigned_integer (buf + 8, 4) == INSTR_SC)
	   ||
	   (pcinsn == INSTR_SC
	    && insn_is_sigreturn (extract_unsigned_integer (buf, 4))));
}
@


1.80
log
@Fixed up some indentation introduced by my last pactch.
@
text
@d3 2
a4 2
   Copyright (C) 1986, 1987, 1989, 1991, 1992, 1993, 1994, 1995, 1996,
   1997, 2000, 2001, 2002, 2003, 2004, 2005, 2006
@


1.79
log
@Fix sigtramp cache code so that PPC register are read only if there is H/W.
@
text
@d919 10
a928 8
  if (ppc_floating_point_unit_p (gdbarch)) {
         /* Floating point registers.  */
         for (i = 0; i < 32; i++)
         {
                 int regnum = i + FP0_REGNUM;
                 trad_frame_set_reg_addr (this_cache, regnum, fpregs + i * tdep->wordsize);
         }
         trad_frame_set_reg_addr (this_cache, tdep->ppc_fpscr_regnum,
d930 1
a930 1
  }
@


1.78
log
@gdb/
	* breakpoint.c (deprecated_read_memory_nobpt): Update to use
	shadow_len.
	(insert_bp_location, reattach_breakpoints, remove_breakpoint)
	(delete_breakpoint): Update calls to changed methods.
	(deprecated_insert_raw_breakpoint, deprecated_remove_raw_breakpoint)
	(single_step_breakpoints, insert_single_step_breakpoint)
	(remove_single_step_breakpoints): New.
	* breakpoint.h (struct bp_target_info): New.
	(struct bp_location): Replace shadow_contents with
	target_info and overlay_target_info.
	(deprecated_insert_raw_breakpoint, deprecated_remove_raw_breakpoint)
	(insert_single_step_breakpoint, remove_single_step_breakpoints): New
	prototypes.
	* gdbarch.sh: Forward declare struct bp_target_info in gdbarch.h.
	(memory_insert_breakpoint, memory_remove_breakpoint): Update second
	argument.
	* mem-break.c (default_memory_insert_breakpoint): Update.  Set
	placed_address, placed_size, and shadow_len.
	(default_memory_remove_breakpoint): Update.  Don't use
	BREAKPOINT_FROM_PC.
	(memory_insert_breakpoint, memory_remove_breakpoint): Update.
	* target.c (update_current_target): Update prototypes for changed
	functions.
	(debug_to_insert_breakpoint, debug_to_remove_breakpoint)
	(debug_to_insert_hw_breakpoint, debug_to_remove_hw_breakpoint):
	Update.
	* target.h: Forward declare struct bp_target_info.
	(struct target_ops): Use a bp_target_info argument for
	to_insert_breakpoint, to_remove_breakpoint,
	to_insert_hw_breakpoint, and to_remove_hw_breakpoint.
	(target_insert_breakpoint, target_remove_breakpoint)
	(target_insert_hw_breakpoint, target_remove_hw_breakpoint)
	(memory_insert_breakpoint, memory_remove_breakpoint)
	(default_memory_insert_breakpoint, default_memory_remove_breakpoint):
	Update.
	* config/i386/nm-i386.h: Forward declare struct bp_target_info.
	(i386_insert_hw_breakpoint, i386_remove_hw_breakpoint): Update.
	(target_insert_hw_breakpoint, target_remove_hw_breakpoint): Likewise.

	* gdbarch.c, gdbarch.h: Regenerated.

	* alpha-tdep.c (alpha_software_single_step): Use
	insert_single_step_breakpoint and remove_single_step_breakpoints.
	Remove unused statics.
	* arm-tdep.c (arm_software_single_step): Likewise.  Add a note.
	* cris-tdep.c (cris_software_single_step): Likewise.
	* mips-tdep.c (mips_software_single_step): Likewise.
	* rs6000-tdep.c (rs6000_software_single_step): Likewise.
	* sparc-tdep.c (sparc_software_single_step): Likewise.
	* wince.c (struct thread_info_struct): Remove step_prev.
	(undoSStep): Use remove_single_step_breakpoints.
	(wince_software_single_step): Use insert_single_step_breakpoint.

	* corelow.c (ignore): Remove unneeded prototype.  Update arguments.
	* exec.c (ignore): Likewise.
	* sol-thread.c (ignore): Likewise.

	* procfs.c (dbx_link_shadow_contents): Delete.
	(dbx_link_bpt): New.
	(procfs_mourn_inferior): Remove it if necessary.
	(remove_dbx_link_breakpoint): Use it.
	(insert_dbx_link_bpt_in_file): Set it.
	(procfs_init_inferior): Don't update dbx_link_bpt_addr.
	* rs6000-nat.c (exec_one_dummy_insn): Use
	deprecated_insert_raw_breakpoint and
	deprecated_remove_raw_breakpoint.
	* solib-irix.c (shadow_contents, breakpoint_addr): Delete.
	(base_breakpoint): New.
	(disable_break): Use it.
	(enable_break): Set it.

	* i386-nat.c (i386_insert_hw_breakpoint, i386_remove_hw_breakpoint):
	Update.
	* ia64-tdep.c (ia64_memory_insert_breakpoint)
	(ia64_memory_remove_breakpoint): Likewise.
	* m32r-tdep.c (m32r_memory_insert_breakpoint)
	(m32r_memory_remove_breakpoint): Likewise.
	* monitor.c (monitor_insert_breakpoint, monitor_remove_breakpoint):
	Likewise.  Remove unnecessary prototypes.  Use placed_address
	and placed_size.  Removed useless read from memory.
	* nto-procfs.c (procfs_insert_breakpoint)
	(procfs_remove_breakpoint, procfs_insert_hw_breakpoint)
	(procfs_remove_hw_breakpoint): Update.
	* ocd.c (ocd_insert_breakpoint, ocd_remove_breakpoint): Likewise.
	* ocd.h (ocd_insert_breakpoint, ocd_remove_breakpoint): Likewise.
	* ppc-linux-tdep.c (ppc_linux_memory_remove_breakpoint): Likewise.
	* ppc-tdep.h (ppc_linux_memory_remove_breakpoint): Likewise.
	* remote-e7000.c (e7000_insert_breakpoint)
	(e7000_remove_breakpoint): Likewise.
	* remote-m32r-sdi.c (m32r_insert_breakpoint)
	(m32r_remove_breakpoint): Likewise.
	* remote-mips.c (mips_insert_breakpoint)
	(mips_remove_breakpoint): Likewise.
	* remote-rdp.c (remote_rdp_insert_breakpoint)
	(remote_rdp_remove_breakpoint): Likewise.
	(rdp_step): Use deprecated_insert_raw_breakpoint and
	deprecated_remove_raw_breakpoint.
	* remote-sds.c (sds_insert_breakpoint, sds_remove_breakpoint):
	Update.
	* remote-sim.c (gdbsim_insert_breakpoint, gdbsim_remove_breakpoint):
	Delete.
	(init_gdbsim_ops): Use memory_insert_breakpoint and
	memory_remove_breakpoint.
	* remote-st.c (st2000_insert_breakpoint)
	(st2000_remove_breakpoint): Update.  Remove unused
	BREAKPOINT_FROM_PC.
	* remote.c (remote_insert_breakpoint, remote_remove_breakpoint):
	Update.  Use placed_address and placed_size.
	(remote_insert_hw_breakpoint, remote_remove_hw_breakpoint): Likewise.
gdb/doc/
	* gdbint.texinfo (x86 Watchpoints, Target Conditionals): Update insert
	and remove breakpoint prototypes.
	(Watchpoints): Move description of target_insert_hw_breakpoint and
	target_remove_hw_breakpoint ...
	(Breakpoints): ... to here.  Document target_insert_breakpoint and
	target_remove_breakpoint.
@
text
@d919 10
a928 8
  /* Floating point registers.  */
  for (i = 0; i < 32; i++)
    {
      int regnum = i + FP0_REGNUM;
      trad_frame_set_reg_addr (this_cache, regnum, fpregs + i * tdep->wordsize);
    }
  trad_frame_set_reg_addr (this_cache, tdep->ppc_fpscr_regnum,
			   fpregs + 32 * tdep->wordsize);
@


1.77
log
@* arm-linux-tdep.c (arm_linux_svr4_fetch_link_map_offsets):
Remove.
(arm_linux_init_abi): Set solib_svr4_fetch_link_map_offsets to
svr4_ilp32_fetch_link_map_offsets.
* cris-tdep.c (cris_linux_svr4_fetch_link_map_offsets): Remove
function.
(cris_gdbarch_init): Set solib_svr4_fetch_link_map_offsets to
svr4_ilp32_fetch_link_map_offsets.
* mips-linux-tdep.c (mips_linux_svr4_fetch_link_map_offsets)
(mips64_linux_svr4_fetch_link_map_offsets): Remove functions.
(mips_linux_init_abi): Set solib_svr4_fetch_link_map_offsets to
svr4_ilp32_fetch_link_map_offsets or svr4_lp64_fetch_link_map_offsets
where appropriate.
* nbsd-tdep.c (nbsd_ilp32_solib_svr4_fetch_link_map_offsets):
Simply call svr4_ilp32_fetch_link_map_offsets.
(nbsd_lp64_solib_svr4_fetch_link_map_offsets): Simply call
svr4_lp64_fetch_link_map_offsets.
* ppc-linux-tdep.c (ppc_linux_svr4_fetch_link_map_offsets): Remove
function.
(ppc_linux_init_abi): Set solib_svr4_fetch_link_map_offsets to
svr4_ilp32_fetch_link_map_offsets.
* s390-tdep.c (s390_svr4_fetch_link_map_offsets)
(s390x_svr4_fetch_link_map_offsets): Remove functions.
(s390_gdbarch_init): Set solib_svr4_fetch_link_map_offsets to
svr4_ilp32_fetch_link_map_offsets or svr4_lp64_fetch_link_map_offsets
where appropriate.
@
text
@d460 1
a460 2
ppc_linux_memory_remove_breakpoint (CORE_ADDR addr,
				    gdb_byte *contents_cache)
d462 1
d479 1
a479 1
    val = target_write_memory (addr, contents_cache, bplen);
@


1.77.8.1
log
@Merge to branch:
  http://sourceware.org/ml/gdb-patches/2006-04/msg00139.html
@
text
@d460 2
a461 1
ppc_linux_memory_remove_breakpoint (CORE_ADDR addr, struct bp_location *bpt)
d479 1
a479 1
    val = target_write_memory (addr, bpt->shadow_contents, bplen);
@


1.76
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d4 2
a5 1
   1997, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
a503 42
/* Fetch (and possibly build) an appropriate link_map_offsets
   structure for GNU/Linux PPC targets using the struct offsets
   defined in link.h (but without actual reference to that file).

   This makes it possible to access GNU/Linux PPC shared libraries
   from a GDB that was not built on an GNU/Linux PPC host (for cross
   debugging).  */

struct link_map_offsets *
ppc_linux_svr4_fetch_link_map_offsets (void)
{
  static struct link_map_offsets lmo;
  static struct link_map_offsets *lmp = NULL;

  if (lmp == NULL)
    {
      lmp = &lmo;

      lmo.r_debug_size = 8;	/* The actual size is 20 bytes, but
				   this is all we need.  */
      lmo.r_map_offset = 4;
      lmo.r_map_size   = 4;

      lmo.link_map_size = 20;	/* The actual size is 560 bytes, but
				   this is all we need.  */
      lmo.l_addr_offset = 0;
      lmo.l_addr_size   = 4;

      lmo.l_name_offset = 4;
      lmo.l_name_size   = 4;

      lmo.l_next_offset = 12;
      lmo.l_next_size   = 4;

      lmo.l_prev_offset = 16;
      lmo.l_prev_size   = 4;
    }

  return lmp;
}


d1055 1
a1055 1
        (gdbarch, ppc_linux_svr4_fetch_link_map_offsets);
@


1.75
log
@	* ppc-linux-tdep.c (ppc_linux_init_abi): Set 64-bit link map offsets.
@
text
@d3 1
a3 1
   Copyright 1986, 1987, 1989, 1991, 1992, 1993, 1994, 1995, 1996,
d20 2
a21 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.74
log
@2005-05-24  Andrew Cagney  <cagney@@gnu.org>

	* rs6000-tdep.c (ppc_supply_reg, ppc_collect_reg): Use gdb_byte
	for byte buffers.
	(rs6000_fetch_pointer_argument): Use get_frame_register_unsigned.
	(rs6000_software_single_step, sstep_breaks, skip_prologue)
	(rs6000_push_dummy_call, rs6000_push_dummy_call)
	(rs6000_push_dummy_call, rs6000_push_dummy_call)
	(rs6000_register_to_value, e500_pseudo_register_read)
	(rs6000_store_return_value, e500_pseudo_register_write)
	(rs6000_frame_prev_register, rs6000_extract_return_value): Ditto.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call)
	(ppc_sysv_abi_push_dummy_call, do_ppc_sysv_return_value)
	(do_ppc_sysv_return_value, ppc_sysv_abi_return_value)
	(ppc_sysv_abi_broken_return_value)
	(ppc64_sysv_abi_push_dummy_call, ppc64_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_push_dummy_call, ppc64_sysv_abi_return_value)
	(ppc64_sysv_abi_return_value, ppc64_sysv_abi_return_value): Ditto.
	* ppc-linux-tdep.c (ppc_linux_in_sigtramp)
	(ppc_linux_at_sigtramp_return_path)
	(ppc_linux_skip_trampoline_code)
	(ppc_linux_memory_remove_breakpoint, ppc_linux_return_value):
	* rs6000-tdep.c (rs6000_value_to_register)
	(rs6000_register_to_value): Ditto.
	* ppc-tdep.h (ppc_sysv_abi_return_value)
	(ppc64_sysv_abi_return_value, ppc_sysv_abi_broken_return_value)
	(ppc_linux_memory_remove_breakpoint): Ditto.
@
text
@d4 1
a4 1
   1997, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
d1111 4
@


1.73
log
@	* gdbarch.sh (fetch_tls_load_module_address): New architecture method.
	* gdbarch.c, gdbarch.h: Regenerate.
	* dwarf2loc.c (dwarf_expr_tls_address): Fetch TLS load module
	address and pass this address, instead of the objfile address, to
	target_get_thread_local_address().
	* linux-thread-db.c (thread_db_get_thread_local_address): Change
	second parameter from type ``struct objfile *'' to CORE_ADDR.  Do
	not call svr4_fetch_objfile_link_map() to fetch the load module
	address.
	* target.h (struct target_ops): Change second parameter of
	``to_get_thread_local_address'' from ``struct objfile *'' to
	``CORE_ADDR''.
	* alpha-linux-tdep.c (solib-svr4.h): Include.
	(alpha_linux_init_abi): Register TLS load module fetcher.
	* amd64-linux-tdep.c (amd64_linux_init_abi): Likewise.
	* hppa-linux-tdep.c (hppa_linux_init_abi): Likewise.
	* i386-linux-tdep.c (i386_linux_init_abi): Likewise.
	* ia64-linux-tdep.c (solib-svr4.h): Include.
	(ia64_linux_init_abi): Register TLS load module fetcher.
	* m32r-linux-tdep.c (m32r_linux_init_abi): Likewise.
	* m68klinux-tdep.c (m68k_linux_init_abi): Likewise.
	* mips-linux-tdep.c (mips_linux_init_abi): Likewise.
	* s390-tdep.c (s390_gdbarch_init): Likewise.
	* sparc-linux-tdep.c (sparc32_linux_init_abi): Likewise.
	* sparc64-linux-tdep.c (solib-svr4.h): Include.
	(sparc64_linux_init_abi): Register TLS load module fetcher.
	* Makefile.in (alpha-linux-tdep.o, ia64-linux-tdep.o)
	(sparc-linux-tdep.o): Update dependencies.
@
text
@d160 1
a160 1
  char buf[4];
d208 1
a208 1
  char buf[12];
d227 1
a227 1
  char buf[4];
d320 2
a321 1
  if (target_read_memory (strtab + symidx, symname, sizeof (symname)) != 0)
d459 2
a460 1
ppc_linux_memory_remove_breakpoint (CORE_ADDR addr, char *contents_cache)
d465 1
a465 1
  char old_contents[BREAKPOINT_MAX];
d490 2
a491 2
			struct regcache *regcache, void *readbuf,
			const void *writebuf)
@


1.72
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d1114 4
@


1.71
log
@2005-02-08  Andrew Cagney  <cagney@@gnu.org>

	* ppc-linux-tdep.c (ppc_linux_init_abi): Do not set malloc name,
	no longer needed.
@
text
@d468 1
a468 1
    error ("Software breakpoints not implemented for this target.");
@


1.70
log
@2005-01-25  Andrew Cagney  <cagney@@gnu.org>

	* ppc-linux-tdep.c: Include "tramp-frame.h"
	(struct ppc_linux_sigtramp_cache)
	(ppc_linux_sigtramp_this_id, ppc_linux_sigtramp_prev_register)
	(ppc_linux_sigtramp_unwind, ppc_linux_sigtramp_sniffer)
	(ppc_linux_sigtramp_cache): Delete.
	(ppc32_linux_sigaction_cache_init)
	(ppc64_linux_sigaction_cache_init)
	(ppc32_linux_sighandler_cache_init)
	(ppc64_linux_sighandler_cache_init)
	(ppc32_linux_sigaction_tramp_frame)
	(ppc64_linux_sigaction_tramp_frame)
	(ppc32_linux_sighandler_tramp_frame)
	(ppc64_linux_sighandler_tramp_frame)
	(ppc_linux_sigtramp_cache, ppc_linux_init_abi): Implement 32 and
	64-bit, sigaction and siginfo tramp-frame unwinders.
@
text
@a1108 3
      /* PPC64 malloc's entry-point is called ".malloc".  */
      set_gdbarch_name_of_malloc (gdbarch, ".malloc");

@


1.69
log
@2005-01-25  Andrew Cagney  <cagney@@gnu.org>

	* ppc-linux-tdep.c (ppc_linux_init_abi): Always set
        long_double_bit to 8.
@
text
@d40 1
a859 108
struct ppc_linux_sigtramp_cache
{
  CORE_ADDR base;
  struct trad_frame_saved_reg *saved_regs;
};

static struct ppc_linux_sigtramp_cache *
ppc_linux_sigtramp_cache (struct frame_info *next_frame, void **this_cache)
{
  CORE_ADDR regs;
  CORE_ADDR gpregs;
  CORE_ADDR fpregs;
  int i;
  struct ppc_linux_sigtramp_cache *cache;
  struct gdbarch *gdbarch = get_frame_arch (next_frame);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  if ((*this_cache) != NULL)
    return (*this_cache);
  cache = FRAME_OBSTACK_ZALLOC (struct ppc_linux_sigtramp_cache);
  (*this_cache) = cache;
  cache->saved_regs = trad_frame_alloc_saved_regs (next_frame);

  cache->base = frame_unwind_register_unsigned (next_frame, SP_REGNUM);

  /* Find the register pointer, which gives the address of the
     register buffers.  */
  if (tdep->wordsize == 4)
    regs = (cache->base
	    + 0xd0 /* Offset to ucontext_t.  */
	    + 0x30 /* Offset to .reg.  */);
  else
    regs = (cache->base
	    + 0x80 /* Offset to ucontext_t.  */
	    + 0xe0 /* Offset to .reg.  */);
  /* And the corresponding register buffers.  */
  gpregs = read_memory_unsigned_integer (regs, tdep->wordsize);
  fpregs = gpregs + 48 * tdep->wordsize;

  /* General purpose.  */
  for (i = 0; i < ppc_num_gprs; i++)
    {
      int regnum = i + tdep->ppc_gp0_regnum;
      cache->saved_regs[regnum].addr = gpregs + i * tdep->wordsize;
    }
  cache->saved_regs[PC_REGNUM].addr = gpregs + 32 * tdep->wordsize;
  cache->saved_regs[tdep->ppc_ctr_regnum].addr = gpregs + 35 * tdep->wordsize;
  cache->saved_regs[tdep->ppc_lr_regnum].addr = gpregs + 36 * tdep->wordsize;
  cache->saved_regs[tdep->ppc_xer_regnum].addr = gpregs + 37 * tdep->wordsize;
  cache->saved_regs[tdep->ppc_cr_regnum].addr = gpregs + 38 * tdep->wordsize;

  /* Floating point registers.  */
  if (ppc_floating_point_unit_p (gdbarch))
    {
      for (i = 0; i < ppc_num_fprs; i++)
        {
          int regnum = i + tdep->ppc_fp0_regnum;
          cache->saved_regs[regnum].addr = fpregs + i * tdep->wordsize;
        }
      cache->saved_regs[tdep->ppc_fpscr_regnum].addr
        = fpregs + 32 * tdep->wordsize;
    }

  return cache;
}

static void
ppc_linux_sigtramp_this_id (struct frame_info *next_frame, void **this_cache,
			  struct frame_id *this_id)
{
  struct ppc_linux_sigtramp_cache *info
    = ppc_linux_sigtramp_cache (next_frame, this_cache);
  (*this_id) = frame_id_build (info->base, frame_pc_unwind (next_frame));
}

static void
ppc_linux_sigtramp_prev_register (struct frame_info *next_frame,
				void **this_cache,
				int regnum, int *optimizedp,
				enum lval_type *lvalp, CORE_ADDR *addrp,
				int *realnump, void *valuep)
{
  struct ppc_linux_sigtramp_cache *info
    = ppc_linux_sigtramp_cache (next_frame, this_cache);
  trad_frame_get_prev_register (next_frame, info->saved_regs, regnum,
				optimizedp, lvalp, addrp, realnump, valuep);
}

static const struct frame_unwind ppc_linux_sigtramp_unwind =
{
  SIGTRAMP_FRAME,
  ppc_linux_sigtramp_this_id,
  ppc_linux_sigtramp_prev_register
};

static const struct frame_unwind *
ppc_linux_sigtramp_sniffer (struct frame_info *next_frame)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (get_frame_arch (next_frame));
  if (frame_pc_unwind (next_frame)
      > frame_unwind_register_unsigned (next_frame, SP_REGNUM))
    /* Assume anything that is vaguely on the stack is a signal
       trampoline.  */
    return &ppc_linux_sigtramp_unwind;
  else
    return NULL;
}

d916 145
d1095 4
d1111 4
a1116 1
  frame_unwind_append_sniffer (gdbarch, ppc_linux_sigtramp_sniffer);
@


1.68
log
@2004-10-31  Andrew Cagney  <cagney@@gnu.org>

	* armnbsd-tdep.c (arm_netbsd_aout_init_abi)
	(arm_netbsd_aout_in_solib_call_trampoline): Do not set
	in_solib_call_trampoline, delete corresponding unused function.
	* vaxnbsd-tdep.c (vaxnbsd_aout_in_solib_call_trampoline)
	(vaxnbsd_aout_init_abi): Ditto.
	* sparcnbsd-tdep.c (sparcnbsd_aout_in_solib_call_trampoline)
	(sparc32nbsd_aout_init_abi): Ditto.
	* ppc-linux-tdep.c (ppc64_in_solib_call_trampoline)
	(ppc_linux_init_abi): Ditto.
	* ns32knbsd-tdep.c (ns32knbsd_aout_in_solib_call_trampoline)
	(ns32knbsd_init_abi_aout): Ditto.
	* mips-tdep.c (mips_in_call_stub, mips_gdbarch_init): Ditto.
	* mips-linux-tdep.c (mips_linux_init_abi): Ditto.
	* m68kbsd-tdep.c (m68kbsd_aout_in_solib_call_trampoline)
	(m68kbsd_aout_init_abi): Ditto.
	* i386-cygwin-tdep.c (i386_cygwin_in_solib_call_trampoline)
	(i386_cygwin_init_abi): Ditto.
	* i386bsd-tdep.c (i386bsd_aout_in_solib_call_trampoline)
	(i386bsd_init_abi): Ditto.
@
text
@d1028 10
a1039 9
      /* NOTE: jimb/2004-03-26: The System V ABI PowerPC Processor
         Supplement says that long doubles are sixteen bytes long.
         However, as one of the known warts of its ABI, PPC GNU/Linux
         uses eight-byte long doubles.  GCC only recently got 128-bit
         long double support on PPC, so it may be changing soon.  The
         Linux[sic] Standards Base says that programs that use 'long
         double' on PPC GNU/Linux are non-conformant.  */
      set_gdbarch_long_double_bit (gdbarch, 8 * TARGET_CHAR_BIT);

@


1.67
log
@2004-10-31  Andrew Cagney  <cagney@@gnu.org>

	* sparc-sol2-tdep.c (sparc32_sol2_init_abi): Do not set
	in_solib_call_trampoline to in_plt_entry, IN_SOLIB_CALL_TRAMPOLINE
	isn't used by this architecture.
	* sparc64-sol2-tdep.c (sparc64_sol2_init_abi): Ditto.
	* sparc64obsd-tdep.c (sparc64obsd_init_abi): Ditto.
	* sparc64nbsd-tdep.c (sparc64nbsd_init_abi): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Ditto.
	* m68klinux-tdep.c (m68k_linux_init_abi): Ditto.
	* i386-tdep.c (i386_svr4_init_abi): Ditto.
	* i386-nto-tdep.c (i386nto_init_abi): Ditto.
	* arm-linux-tdep.c (arm_linux_init_abi): Ditto.
	* amd64-tdep.c (amd64_init_abi): Ditto.
@
text
@a687 37

/* Recognize a 64-bit PowerPC GNU/Linux linkage function --- what GDB
   calls a "solib trampoline".  */
static int
ppc64_in_solib_call_trampoline (CORE_ADDR pc, char *name)
{
  /* Detecting solib call trampolines on PPC64 GNU/Linux is a pain.

     It's not specifically solib call trampolines that are the issue.
     Any call from one function to another function that uses a
     different TOC requires a trampoline, to save the caller's TOC
     pointer and then load the callee's TOC.  An executable or shared
     library may have more than one TOC, so even intra-object calls
     may require a trampoline.  Since executable and shared libraries
     will all have their own distinct TOCs, every inter-object call is
     also an inter-TOC call, and requires a trampoline --- so "solib
     call trampolines" are just a special case.

     The 64-bit PowerPC GNU/Linux ABI calls these call trampolines
     "linkage functions".  Since they need to be near the functions
     that call them, they all appear in .text, not in any special
     section.  The .plt section just contains an array of function
     descriptors, from which the linkage functions load the callee's
     entry point, TOC value, and environment pointer.  So
     in_plt_section is useless.  The linkage functions don't have any
     special linker symbols to name them, either.

     The only way I can see to recognize them is to actually look at
     their code.  They're generated by ppc_build_one_stub and some
     other functions in bfd/elf64-ppc.c, so that should show us all
     the instruction sequences we need to recognize.  */
  unsigned int insn[PPC64_STANDARD_LINKAGE_LEN];

  return insns_match_pattern (pc, ppc64_standard_linkage, insn);
}


a1063 3

      set_gdbarch_in_solib_call_trampoline
        (gdbarch, ppc64_in_solib_call_trampoline);
@


1.66
log
@2004-07-31  Andrew Cagney  <cagney@@gnu.org>

	* trad-frame.c (trad_frame_get_prev_register): Rename
	trad_frame_get_prev_register.
	* vax-tdep.c (vax_frame_prev_register): Update.
	* trad-frame.h: Update.
	* trad-frame.c (trad_frame_get_register): Update.
	* sparcobsd-tdep.c (sparc32obsd_frame_prev_register): Update.
	* sparcnbsd-tdep.c (sparc32nbsd_sigcontext_frame_prev_register):
	Update.
	* sparc64obsd-tdep.c (sparc64obsd_frame_prev_register): Update.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_frame_prev_register):
	Update.
	* sparc64fbsd-tdep.c (sparc64fbsd_sigtramp_frame_prev_register):
	Update.
	* sparc64-sol2-tdep.c (sparc64_sol2_sigtramp_frame_prev_register):
	Update.
	* sparc-sol2-tdep.c (sparc32_sol2_sigtramp_frame_prev_register):
	Update.
	* sparc-linux-tdep.c (sparc32_linux_sigtramp_frame_prev_register):
	Update.
	* s390-tdep.c (s390_frame_prev_register)
	(s390_stub_frame_prev_register)
	(s390_sigtramp_frame_prev_register): Update.
	* rs6000-tdep.c (rs6000_frame_prev_register): Update.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_prev_register): Update.
	* mips-tdep.c (mips_mdebug_frame_prev_register): Update.
	* m88k-tdep.c (m88k_frame_prev_register)
	* m68hc11-tdep.c (m68hc11_frame_prev_register)
	* m32r-tdep.c (m32r_frame_prev_register): Update.
	* hppa-tdep.c (hppa_frame_prev_register_helper)
	* frv-tdep.c (frv_frame_prev_register): Update.
	* d10v-tdep.c (d10v_frame_prev_register): Update.
	* cris-tdep.c (cris_frame_prev_register): Update.
	* avr-tdep.c (avr_frame_prev_register): Update.
	* arm-tdep.c (arm_prologue_prev_register)
	(arm_sigtramp_prev_register): Update.
@
text
@a1088 1
      set_gdbarch_in_solib_call_trampoline (gdbarch, in_plt_section);
@


1.65
log
@2004-07-21  Andrew Cagney  <cagney@@gnu.org>

	Use regcache_raw_supply instead of supply_register.
	* regcache.h (supply_register): Delete declaration.
	* regcache.c (supply_register): Delete function.
	* wince.c (do_child_fetch_inferior_registers): Update.
	* win32-nat.c (do_child_fetch_inferior_registers)
	(fetch_elf_core_registers): Update.
	* v850ice.c (v850ice_fetch_registers): Update.
	* thread-db.c (thread_db_store_registers): Update.
	* sol-thread.c (sol_thread_store_registers): Update.
	* shnbsd-tdep.c (shnbsd_supply_reg): Update.
	* rs6000-nat.c (fetch_register): Update.
	* rom68k-rom.c (rom68k_supply_one_register): Update.
	* remote.c (remote_wait, remote_async_wait): Update.
	* remote-st.c (get_hex_regs): Update.
	* remote-sim.c (gdbsim_fetch_register): Update.
	* remote-sds.c (sds_fetch_registers): Update.
	* remote-rdp.c (remote_rdp_fetch_register): Update.
	* remote-rdi.c (arm_rdi_fetch_registers): Update.
	* remote-mips.c (mips_wait, mips_fetch_registers): Update.
	* remote-m32r-sdi.c (m32r_fetch_register): Update.
	* remote-hms.c (init_hms_cmds): Update.
	* remote-est.c (init_est_cmds): Update.
	* remote-e7000.c (get_hex_regs, fetch_regs_from_dump)
	(e7000_fetch_registers, sub2_from_pc, e7000_wait): Update.
	* ppcnbsd-tdep.c (ppcnbsd_supply_reg, ppcnbsd_supply_fpreg): Update.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_spe_register)
	(fetch_register, supply_vrregset, supply_vrregset)
	(fetch_spe_registers): Update.
	* ppc-bdm.c (bdm_ppc_fetch_registers): Update.
	* monitor.c (monitor_supply_register): Update.
	* mipsv4-nat.c (supply_gregset, supply_fpregset): Update.
	* mipsnbsd-tdep.c (mipsnbsd_supply_reg)
	(mipsnbsd_supply_fpreg): Update.
	* mips-nat.c (fetch_inferior_registers)
	(fetch_core_registers): Update.
	* mips-linux-tdep.c (supply_32bit_reg, supply_gregset)
	(supply_fpregset, mips64_supply_gregset)
	(mips64_supply_fpregset): Update.
	* m68klinux-nat.c (fetch_register, supply_gregset)
	(supply_fpregset): Update.
	* m68k-tdep.c (supply_gregset, supply_fpregset): Update.
	* m32r-rom.c (init_m32r_cmds, init_mon2000_cmds): Update.
	* lynx-nat.c (fetch_inferior_registers, fetch_core_registers): Update.
	* irix5-nat.c (supply_gregset, supply_fpregset): Update.
	* infptrace.c (fetch_register): Update.
	* ia64-linux-nat.c (supply_gregset, supply_fpregset): Update.
	* ia64-aix-nat.c (supply_gregset, supply_fpregset): Update.
	* i386gnu-nat.c (fetch_fpregs, supply_gregset)
	(gnu_fetch_registers, gnu_store_registers): Update.
	* i386-nto-tdep.c (i386nto_supply_gregset): Update.
	* i386-linux-nat.c (fetch_register, supply_gregset)
	(dummy_sse_values): Update.
	* hpux-thread.c (hpux_thread_fetch_registers): Update.
	* hppah-nat.c (fetch_register): Update.
	* hppa-linux-nat.c (fetch_register, supply_gregset)
	(supply_fpregset): Update.
	* go32-nat.c (fetch_register): Update.
	* dve3900-rom.c (fetch_bitmapped_register)
	(_initialize_r3900_rom): Update.
	* cris-tdep.c (supply_gregset): Update.
	* abug-rom.c (init_abug_cmds): Update.
	* core-aout.c (fetch_core_registers): Update.
	* armnbsd-nat.c (supply_gregset, supply_fparegset)
	(fetch_register, fetch_fp_register): Update.
	* arm-linux-nat.c (fetch_nwfpe_single, fetch_nwfpe_none)
	(fetch_nwfpe_extended, fetch_fpregister, fetch_fpregs)
	(fetch_register, fetch_regs, supply_gregset, supply_fpregset): Update.
	* alphanbsd-tdep.c (fetch_core_registers): Update.
	* alpha-tdep.c (alpha_supply_int_regs, alpha_supply_fp_regs): Update.
	* alpha-nat.c (fetch_osf_core_registers)
	(fetch_osf_core_registers, fetch_osf_core_registers): Update.
	* aix-thread.c (supply_gprs64, supply_reg32, supply_fprs)
	(supply_sprs64, supply_sprs32, fetch_regs_kernel_thread): Update.
@
text
@d980 2
a981 2
  trad_frame_prev_register (next_frame, info->saved_regs, regnum,
			    optimizedp, lvalp, addrp, realnump, valuep);
@


1.64
log
@2004-07-17  Andrew Cagney  <cagney@@gnu.org>

	* ppc-linux-tdep.c (ppc_linux_init_abi): Add [sic] to Linux.
	* ppc-linux-nat.c: Use "Linux kernel".
	* hppa-linux-tdep.c: Use GNU/Linux.
	* hppa-linux-nat.c: Use GNU/Linux.
	* dwarfread.c: Add [sic] to use of Linux.
@
text
@d845 1
a845 2
		       (buf + wordsize
			- register_size (current_gdbarch, regnum)));
@


1.63
log
@* aix-thread.c (pdc_read_regs, supply_gprs64, supply_fprs)
(fetch_regs_user_thread, fetch_regs_kernel_thread)
(store_regs_user_thread, store_regs_kernel_thread): Use
ppc_num_gprs and ppc_num_fprs instead of '32' and '31'.
* ppc-linux-nat.c (fill_gregset): Same.
* ppc-linux-tdep.c (ppc_linux_supply_gregset)
(ppc_linux_sigtramp_cache): Same.
* ppcnbsd-tdep.c (ppcnbsd_supply_reg, ppcnbsd_fill_reg)
(ppcnbsd_sigtramp_cache_init): Same.
* rs6000-nat.c (fetch_core_registers): Same.
* rs6000-tdep.c (ppc_supply_gregset, ppc_collect_gregset)
(rs6000_frame_cache): Same.
@
text
@d4 1
a4 1
   1997, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d1073 1
a1073 1
         Linux Standards Base says that programs that use 'long
@


1.63.2.1
log
@2004-07-17  Andrew Cagney  <cagney@@gnu.org>

	* ppc-linux-tdep.c (ppc_linux_init_abi): Add [sic] to Linux.
	* ppc-linux-nat.c: Use "Linux kernel".
	* hppa-linux-tdep.c: Use GNU/Linux.
	* hppa-linux-nat.c: Use GNU/Linux.
	* dwarfread.c: Add [sic] to use of Linux.
@
text
@d4 1
a4 1
   1997, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
d1073 1
a1073 1
         Linux[sic] Standards Base says that programs that use 'long
@


1.63.2.1.2.1
log
@Allow access to all 64 bits of the SPE GPR's in multi-threaded
programs.
* ppc-tdep.h (struct speregset): New struct type.
* ppc-linux-tdep.c: #include "gdb_assert.h".
(ppc_linux_supply_speregset, ppc_linux_collect_speregset): New
functions.
(ppc_linux_speregset): New structure.
(ppc_linux_init_abi): Describe how to pass the full 64-bit values
of the SPE GPRs across the thread-db interface.
* ppc-linux-nat.c (struct gdb_evrregset_t): Doc fix.
* Makefile.in (ppc-linux-tdep.o): Update dependencies.

Allow targets to specify an extended register set, to be passed
through libthread_db via its 'xregs' functions.
* gdbarch.sh (XREGS_REGSET, XREGS_SIZE, XREGS_NAME): New gdbarch
members.
* gdbarch.c, gdbarch.h: Regenerated.
* proc-service.c: #include "regset.h" and "regcache.h".
(ps_lgetxregsize, ps_lgetxregs, ps_lsetxregs): Fill in real
implementations of these functions.
* thread-db.c: #include "regset.h".
(td_thr_getxregsize_p, td_thr_getxregs_p, td_thr_setxregs_p): New
variables.
(thread_db_load): Initialize them.
(warned_xregs_not_implemented): New variable.
(thread_db_new_objfile): Clear it here.
(thread_db_fetch_registers, thread_db_store_registers): Supply and
collect the xregset, too, if the architecture says it has one, and
libthread_db seems to be able to support it.
* Makefile.in (proc-service.o, thread-db.o): Update dependencies.
@
text
@a39 1
#include "gdb_assert.h"
a1060 92
ppc_linux_supply_speregset (const struct regset *regset,
                            struct regcache *regcache,
                            int regnum,
                            const void *buf,
                            size_t len)
{
  struct gdbarch *arch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep = gdbarch_tdep (arch);
  const struct speregset *speregset = buf;

  gdb_assert (len == sizeof (*speregset));
  gdb_assert (register_size (arch, tdep->ppc_ev0_regnum)
              == sizeof (speregset->gpr[0]));
  gdb_assert (register_size (arch, tdep->ppc_acc_regnum)
              == sizeof (speregset->acc));
  gdb_assert (register_size (arch, tdep->ppc_spefscr_regnum)
              == sizeof (speregset->spefscr));

  if (regnum == -1)
    {
      int i;

      for (i = 0; i < 32; i++)
        regcache_raw_supply (regcache, tdep->ppc_ev0_regnum + i,
                             &speregset->gpr[i]);
    }
  else if (tdep->ppc_ev0_regnum <= regnum
           && regnum <= tdep->ppc_ev31_regnum)
    regcache_raw_supply (regcache,  tdep->ppc_ev0_regnum + regnum,
                         &speregset->gpr[regnum - tdep->ppc_ev0_regnum]);

  if (regnum == tdep->ppc_acc_regnum
      || regnum == -1)
    regcache_raw_supply (regcache, tdep->ppc_acc_regnum,
                         &speregset->acc);

  if (regnum == tdep->ppc_spefscr_regnum
      || regnum == -1)
    regcache_raw_supply (regcache, tdep->ppc_spefscr_regnum,
                         &speregset->spefscr);
}

static void
ppc_linux_collect_speregset (const struct regset *regset,
                             const struct regcache *regcache,
                             int regnum,
                             void *buf,
                             size_t len)
{
  struct gdbarch *arch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep = gdbarch_tdep (arch);
  struct speregset *speregset = buf;

  gdb_assert (len == sizeof (*speregset));
  gdb_assert (register_size (arch, tdep->ppc_ev0_regnum)
              == sizeof (speregset->gpr[0]));
  gdb_assert (register_size (arch, tdep->ppc_acc_regnum)
              == sizeof (speregset->acc));
  gdb_assert (register_size (arch, tdep->ppc_spefscr_regnum)
              == sizeof (speregset->spefscr));

  if (regnum == -1)
    {
      int i;

      for (i = 0; i < 32; i++)
        regcache_raw_collect (regcache, tdep->ppc_ev0_regnum + i,
                              &speregset->gpr[i]);
    }
  else if (tdep->ppc_ev0_regnum <= regnum
           && regnum <= tdep->ppc_ev31_regnum)
    regcache_raw_collect (regcache, regnum,
                          &speregset->gpr[regnum - tdep->ppc_ev0_regnum]);

  if (regnum == tdep->ppc_acc_regnum
      || regnum == -1)
    regcache_raw_collect (regcache, tdep->ppc_acc_regnum, &speregset->acc);
    
  if (regnum == tdep->ppc_spefscr_regnum
      || regnum == -1)
    regcache_raw_collect (regcache, tdep->ppc_spefscr_regnum,
                          &speregset->spefscr);
}

static const struct regset ppc_linux_speregset =
{
  0,
  ppc_linux_supply_speregset,
  ppc_linux_collect_speregset
};

static void
a1095 12

  if (info.bfd_arch_info->arch == bfd_arch_powerpc
      && info.bfd_arch_info->mach == bfd_mach_ppc_e500)
    {
      /* On the e500, the GPR's are really 64 bits long.  However, we
         continue to treat the gpr's as if they were 32 bits long, and
         handle the upper haves separately.  This means that we need a
         special way to pass the upper halves through thread_db.  */
      set_gdbarch_xregs_regset (gdbarch, &ppc_linux_speregset);
      set_gdbarch_xregs_size (gdbarch, sizeof (struct speregset));
      set_gdbarch_xregs_name (gdbarch, "SPE vector");
    }
@


1.62
log
@* aix-thread.c (supply_gprs64, fetch_regs_user_thread)
(store_regs_user_thread): Use tdep->ppc_gp0_regnum, instead
of assuming that the gprs are numbered starting with zero.
* ppc-linux-nat.c (fill_gregset): Same.
* ppc-linux-tdep.c (ppc_linux_supply_gregset): Same.
* ppcnbsd-nat.c (getregs_supplies): Same.
* ppcnbsd-tdep.c (ppcnbsd_supply_reg, ppcnbsd_fill_reg): Same.
* rs6000-nat.c (fetch_core_registers): Same.
* rs6000-tdep.c (ppc_supply_gregset, ppc_collect_gregset): Same.
@
text
@d863 1
a863 1
  for (regi = 0; regi < 32; regi++)
d937 1
a937 1
  for (i = 0; i < 32; i++)
@


1.61
log
@* ppc-tdep.h (struct gdbarch_tdep): Change definition of
ppc_fp0_regnum and ppc_fpscr_regnum: if they are -1, then this
processor variant lacks those registers.
(ppc_floating_point_unit_p): Change description to make it clear
that this returns info about the ISA, not the ABI.
* rs6000-tdep.c (ppc_floating_point_unit_p): Decide whether to
return true or false by checking tdep->ppc_fp0_regnum and
tdep->ppc_fpscr_regnum.  The original code replicated the BFD
arch/mach switching done in rs6000_gdbarch_init; it's better to
keep that logic there, and just check the results here.
(rs6000_gdbarch_init): On the E500, set tdep->ppc_fp0_regnum and
tdep->ppc_fpscr_regnum to -1 to indicate that we have no
floating-point registers.
(ppc_supply_fpregset, ppc_collect_fpregset)
(rs6000_push_dummy_call, rs6000_extract_return_value)
(rs6000_store_return_value): Assert that we have floating-point
registers.
(rs6000_dwarf2_stab_reg_to_regnum): Add FIXME.
(rs6000_frame_cache): Don't note the locations at which
floating-point registers were saved if we have no fprs.
* aix-thread.c (supply_fprs, fill_fprs): Assert that we have FP
registers.
(fetch_regs_user_thread, fetch_regs_kernel_thread)
(store_regs_user_thread, store_regs_kernel_thread): Only call
supply_fprs / fill_fprs if we actually have floating-point
registers.
(special_register_p): Check ppc_fpscr_regnum before matching
against it.
(supply_sprs64, supply_sprs32, fill_sprs64, fill_sprs32): Don't
supply / collect fpscr if we don't have it.
* ppc-bdm.c: #include "gdb_assert.h".
(bdm_ppc_fetch_registers, bdm_ppc_store_registers): Assert that we
have floating-point registers, since I can't test this code on
FP-free systems to adapt it.
* ppc-linux-nat.c (ppc_register_u_addr): Don't match against the
fpscr and floating point register numbers if they don't exist.
(fetch_register): Assert that we have floating-point registers
before we reach the code that handles them.
(store_register): Same.  And use tdep instead of calling
gdbarch_tdep again.
(fill_fpregset): Don't try to collect FP registers and fpscr if we
don't have them.
(ppc_linux_sigtramp_cache): Don't record the saved locations of
fprs and fpscr if we don't have them.
(ppc_linux_supply_fpregset): Don't supply fp regs and fpscr if we
don't have them.
* ppcnbsd-nat.c: #include "gdb_assert.h".
(getfpregs_supplies): Assert that we have floating-point registers.
* ppcnbsd-tdep.c (ppcnbsd_supply_fpreg, ppcnbsd_fill_fpreg): Same.
* ppcobsd-tdep.c: #include "gdb_assert.h".
(ppcobsd_supply_gregset, ppcobsd_collect_gregset): Assert that we
have floating-point registers.
* rs6000-nat.c (regmap): Don't match against the fpscr and
floating point register numbers if they don't exist.
(fetch_inferior_registers, store_inferior_registers,
fetch_core_registers): Only fetch / store / supply the
floating-point registers and the fpscr if we have them.
* Makefile.in (ppc-bdm.o, ppc-linux-nat.o, ppcnbsd-nat.o)
(ppcobsd-tdep.o): Update dependencies.
@
text
@d864 3
a866 1
    right_supply_register (regcache, wordsize, regi, buf + wordsize * regi);
@


1.60
log
@Back out change.  The NetBSD changes need Jason Thorpe's approval, but
he hasn't reviewed it yet.
@
text
@d947 1
a947 1
  for (i = 0; i < 32; i++)
d949 7
a955 2
      int regnum = i + tdep->ppc_fp0_regnum;
      cache->saved_regs[regnum].addr = fpregs + i * tdep->wordsize;
a956 1
  cache->saved_regs[tdep->ppc_fpscr_regnum].addr = fpregs + 32 * tdep->wordsize;
d1025 4
a1028 1
  for (regi = 0; regi < 32; regi++)
d1033 2
a1034 2
  /* The FPSCR is stored in the low order word of the last doubleword in the
     fpregset.  */
d1036 1
a1036 1
		       buf + 8 * 32 + 4);
@


1.59
log
@* ppc-tdep.h (struct gdbarch_tdep): Change definition of
ppc_fp0_regnum and ppc_fpscr_regnum: if they are -1, then this
processor variant lacks those registers.
(ppc_floating_point_unit_p): Change description to make it clear
that this returns info about the ISA, not the ABI.
* rs6000-tdep.c (ppc_floating_point_unit_p): Decide whether to
return true or false by checking tdep->ppc_fp0_regnum and
tdep->ppc_fpscr_regnum.  The original code replicated the BFD
arch/mach switching done in rs6000_gdbarch_init; it's better to
keep that logic there, and just check the results here.
(rs6000_gdbarch_init): On the E500, set tdep->ppc_fp0_regnum and
tdep->ppc_fpscr_regnum to -1 to indicate that we have no
floating-point registers.
(ppc_supply_fpregset, ppc_collect_fpregset)
(rs6000_push_dummy_call, rs6000_extract_return_value)
(rs6000_store_return_value): Assert that we have floating-point
registers.
(rs6000_dwarf2_stab_reg_to_regnum): Add FIXME.
(rs6000_frame_cache): Don't note the locations at which
floating-point registers were saved if we have no fprs.
* aix-thread.c (supply_fprs, fill_fprs): Assert that we have FP
registers.
(fetch_regs_user_thread, fetch_regs_kernel_thread)
(store_regs_user_thread, store_regs_kernel_thread): Only call
supply_fprs / fill_fprs if we actually have floating-point
registers.
(special_register_p): Check ppc_fpscr_regnum before matching
against it.
(supply_sprs64, supply_sprs32, fill_sprs64, fill_sprs32): Don't
supply / collect fpscr if we don't have it.
* ppc-bdm.c: #include "gdb_assert.h".
(bdm_ppc_fetch_registers, bdm_ppc_store_registers): Assert that we
have floating-point registers, since I can't test this code on
FP-free systems to adapt it.
* ppc-linux-nat.c (ppc_register_u_addr): Don't match against the
fpscr and floating point register numbers if they don't exist.
(fetch_register): Assert that we have floating-point registers
before we reach the code that handles them.
(store_register): Same.  And use tdep instead of calling
gdbarch_tdep again.
(fill_fpregset): Don't try to collect FP registers and fpscr if we
don't have them.
(ppc_linux_sigtramp_cache): Don't record the saved locations of
fprs and fpscr if we don't have them.
(ppc_linux_supply_fpregset): Don't supply fp regs and fpscr if we
don't have them.
* ppcnbsd-nat.c: #include "gdb_assert.h".
(getfpregs_supplies): Assert that we have floating-point registers.
* ppcnbsd-tdep.c (ppcnbsd_supply_fpreg, ppcnbsd_fill_fpreg): Same.
* ppcobsd-tdep.c: #include "gdb_assert.h".
(ppcobsd_supply_gregset, ppcobsd_collect_gregset): Assert that we
have floating-point registers.
* rs6000-nat.c (regmap): Don't match against the fpscr and
floating point register numbers if they don't exist.
(fetch_inferior_registers, store_inferior_registers,
fetch_core_registers): Only fetch / store / supply the
floating-point registers and the fpscr if we have them.
* Makefile.in (ppc-bdm.o, ppc-linux-nat.o, ppcnbsd-nat.o)
(ppcobsd-tdep.o): Update dependencies.
@
text
@d947 1
a947 1
  if (ppc_floating_point_unit_p (gdbarch))
d949 2
a950 7
      for (i = 0; i < ppc_num_fprs; i++)
        {
          int regnum = i + tdep->ppc_fp0_regnum;
          cache->saved_regs[regnum].addr = fpregs + i * tdep->wordsize;
        }
      cache->saved_regs[tdep->ppc_fpscr_regnum].addr
        = fpregs + 32 * tdep->wordsize;
d952 1
d1021 1
a1021 4
  if (! ppc_floating_point_unit_p (regcache_arch))
    return;

  for (regi = 0; regi < ppc_num_fprs; regi++)
d1026 2
a1027 2
  /* The FPSCR is stored in the low order word of the last
     doubleword in the fpregset.  */
d1029 1
a1029 1
                       buf + 8 * 32 + 4);
@


1.58
log
@* config/rs6000/tm-rs6000.h (FP0_REGNUM): Document that this
should no longer be used in code specific to the RS6000 and its
derivatives.
* ppc-tdep.h (struct gdbarch_tdep): Add 'ppc_fp0_regnum' member.
* rs6000-tdep.c (rs6000_gdbarch_init): Initialize
tdep->ppc_fp0_regnum.
(ppc_supply_fpregset, ppc_collect_fpregset)
(rs6000_push_dummy_call, rs6000_extract_return_value)
(rs6000_dwarf2_stab_reg_to_regnum, rs6000_store_return_value)
(rs6000_frame_cache): Use tdep->ppc_fp0_regnum instead of
FP0_REGNUM.
* aix-thread.c (supply_fprs, fetch_regs_kernel_thread)
(fill_gprs64, fill_gprs32, fill_fprs, store_regs_kernel_thread):
Same.
* ppc-bdm.c (bdm_ppc_fetch_registers, bdm_ppc_fetch_registers,
bdm_ppc_store_registers): Same.
* ppc-linux-nat.c (ppc_register_u_addr, fetch_register)
(store_register, fill_fpregset): Same.
* ppc-linux-tdep.c (ppc_linux_sigtramp_cache)
(ppc_linux_supply_fpregset): Same.
* ppcnbsd-nat.c (getfpregs_supplies): Same.
* ppcnbsd-tdep.c (ppcnbsd_supply_fpreg, ppcnbsd_fill_fpreg):
Same.
* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call,
do_ppc_sysv_return_value, ppc64_sysv_abi_push_dummy_call,
ppc64_sysv_abi_return_value): Same.
* rs6000-nat.c (regmap, fetch_inferior_registers)
(store_inferior_registers, fetch_core_registers): Same.
@
text
@d947 1
a947 1
  for (i = 0; i < 32; i++)
d949 7
a955 2
      int regnum = i + tdep->ppc_fp0_regnum;
      cache->saved_regs[regnum].addr = fpregs + i * tdep->wordsize;
a956 1
  cache->saved_regs[tdep->ppc_fpscr_regnum].addr = fpregs + 32 * tdep->wordsize;
d1025 4
a1028 1
  for (regi = 0; regi < 32; regi++)
d1033 2
a1034 2
  /* The FPSCR is stored in the low order word of the last doubleword in the
     fpregset.  */
d1036 1
a1036 1
		       buf + 8 * 32 + 4);
@


1.57
log
@2004-05-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_PC_IN_SIGTRAMP): Delete.
	* gdbarch.h, gdbarch.c: Re-generate.
	* shnbsd-tdep.c (shnbsd_init_abi): Do not set pc_in_sigtramp.
	(shnbsd_pc_in_sigtramp): Delete.
	* i386-interix-tdep.c (i386_interix_init_abi): Do not set
	pc_in_sigtramp.
	* hppa-hpux-tdep.c (hppa_hpux_init_abi): Do not set
	pc_in_sigtramp.
	* frame.h: Update comments.
	* ppc-linux-tdep.c: Update comments.
	* breakpoint.c (bpstat_what): Update comments.

Index: doc/ChangeLog
2004-05-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	description of DEPRECATED_PC_IN_SIGTRAMP.
@
text
@d949 1
a949 1
      int regnum = i + FP0_REGNUM;
d1022 3
a1024 1
    regcache_raw_supply (regcache, FP0_REGNUM + regi, buf + 8 * regi);
@


1.56
log
@	* ppc-linux-tdep.c (ELF_NREG, ELF_NFPREG, ELF_NVRREG)
	(ELF_FPREGSET_SIZE):  Delete constants formerly used in core
	file support.
@
text
@d117 2
a118 2
   infrun.c calls DEPRECATED_PC_IN_SIGTRAMP in order to detect entry
   into a signal trampoline just after delivery of a signal.  But on
d149 3
a151 14
   puts us on the second instruction.  (I added the test for the
   first instruction long after the fact, just in case the observed
   behavior is ever fixed.)

   DEPRECATED_PC_IN_SIGTRAMP is called from blockframe.c as well in
   order to set the frame's type (if a SIGTRAMP_FRAME).  Because of
   our strange definition of in_sigtramp below, we can't rely on the
   frame's type getting set correctly from within blockframe.c.  This
   is why we take pains to set it in init_extra_frame_info().

   NOTE: cagney/2002-11-10: I suspect the real problem here is that
   the get_prev_frame() only initializes the frame's type after the
   call to INIT_FRAME_INFO.  get_prev_frame() should be fixed, this
   code shouldn't be working its way around a bug :-(.  */
@


1.55
log
@* ppc-linux-tdep.c (ppc_linux_init_abi): Long doubles are eight
bytes long on PPC GNU/Linux.
@
text
@a850 11

enum {
  ELF_NGREG = 48,
  ELF_NFPREG = 33,
  ELF_NVRREG = 33
};

enum {
  ELF_FPREGSET_SIZE = (ELF_NFPREG * 8)
};

@


1.54
log
@2004-03-23  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (PC_IN_SIGTRAMP): Change to a function with
	predicate, deprecate.
	* gdbarch.h, gdbarch.c: Re-generate.
	* alpha-linux-tdep.c (alpha_linux_init_abi): Update.
	* alpha-osf1-tdep.c (alpha_osf1_init_abi): Update.
	* alpha-tdep.c (alpha_sigtramp_frame_sniffer): Update.
	* alphafbsd-tdep.c (alphafbsd_init_abi): Update.
	* alphanbsd-tdep.c (alphanbsd_init_abi): Update.
	* amd64-linux-tdep.c (amd64_linux_init_abi): Update.
	* amd64-tdep.c (amd64_sigtramp_frame_sniffer): Update.
	* amd64nbsd-tdep.c (amd64nbsd_init_abi): Update.
	* amd64obsd-tdep.c (amd64obsd_init_abi): Update.
	* arm-tdep.c (arm_sigtramp_unwind_sniffer): Update.
	* blockframe.c (find_pc_partial_function): Update.
	* breakpoint.c (bpstat_what): Update.
	* frame.c (frame_type_from_pc, legacy_get_prev_frame): Update.
	* frv-linux-tdep.c (frv_linux_init_abi): Update.
	* frv-tdep.c (frv_sigtramp_frame_sniffer): Update.
	* hppa-hpux-tdep.c (hppa_hpux_init_abi): Update.
	* i386-interix-tdep.c (i386_interix_init_abi): Update.
	* i386-linux-tdep.c (i386_linux_init_abi): Update.
	* i386-nto-tdep.c (i386nto_init_abi): Update.
	* i386-sol2-tdep.c (i386_sol2_init_abi): Update.
	* i386-tdep.c (i386_sigtramp_frame_sniffer)
	(i386_svr4_init_abi, i386_go32_init_abi, i386_gdbarch_init): Update.
	* i386bsd-tdep.c (i386bsd_init_abi): Update.
	* i386nbsd-tdep.c (i386nbsd_init_abi): Update.
	* i386obsd-tdep.c (i386obsd_init_abi): Update.
	* ia64-tdep.c (ia64_sigtramp_frame_sniffer): Update.
	* infrun.c (pc_in_sigtramp): Update.
	* m68k-tdep.c (m68k_sigtramp_frame_sniffer): Update.
	* m68klinux-tdep.c (m68k_linux_init_abi): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mipsnbsd-tdep.c (mipsnbsd_init_abi): Update.
	* ppc-linux-tdep.c: Update comment.
	* ppcnbsd-tdep.c (ppcnbsd_init_abi): Update.
	* shnbsd-tdep.c (shnbsd_init_abi): Update.
	* sparc-linux-tdep.c (sparc32_linux_init_abi): Update.
	* sparc-sol2-tdep.c (sparc32_sol2_init_abi): Update.
	* sparc64-sol2-tdep.c (sparc64_sol2_init_abi): Update.
	* sparc64fbsd-tdep.c (sparc64fbsd_init_abi): Update.
	* sparc64nbsd-tdep.c (sparc64nbsd_init_abi): Update.
	* sparc64obsd-tdep.c (sparc64obsd_init_abi): Update.
	* sparcnbsd-tdep.c (sparc32nbsd_init_abi): Update.
	* sparcobsd-tdep.c (sparc32obsd_init_abi): Update.

Index: doc/ChangeLog
2004-03-23  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Deprecate
	references to PC_IN_SIGTRAMP.
@
text
@d1079 9
@


1.53
log
@Remove old frame code.  Enable new frame code for AIX.
@
text
@d117 2
a118 2
   infrun.c calls PC_IN_SIGTRAMP in order to detect entry into a
   signal trampoline just after delivery of a signal.  But on
d153 5
a157 5
   PC_IN_SIGTRAMP is called from blockframe.c as well in order to set
   the frame's type (if a SIGTRAMP_FRAME).  Because of our strange
   definition of in_sigtramp below, we can't rely on the frame's type
   getting set correctly from within blockframe.c.  This is why we
   take pains to set it in init_extra_frame_info().
@


1.52
log
@Commit Andrew Cagney's rs6000 / PPC framification patch.
@
text
@a342 105
/* The rs6000 version of FRAME_SAVED_PC will almost work for us.  The
   signal handler details are different, so we'll handle those here
   and call the rs6000 version to do the rest. */
CORE_ADDR
ppc_linux_frame_saved_pc (struct frame_info *fi)
{
  if ((get_frame_type (fi) == SIGTRAMP_FRAME))
    {
      CORE_ADDR regs_addr =
	read_memory_integer (get_frame_base (fi)
			     + PPC_LINUX_REGS_PTR_OFFSET, 4);
      /* return the NIP in the regs array */
      return read_memory_integer (regs_addr + 4 * PPC_LINUX_PT_NIP, 4);
    }
  else if (get_next_frame (fi)
	   && (get_frame_type (get_next_frame (fi)) == SIGTRAMP_FRAME))
    {
      CORE_ADDR regs_addr =
	read_memory_integer (get_frame_base (get_next_frame (fi))
			     + PPC_LINUX_REGS_PTR_OFFSET, 4);
      /* return LNK in the regs array */
      return read_memory_integer (regs_addr + 4 * PPC_LINUX_PT_LNK, 4);
    }
  else
    return rs6000_frame_saved_pc (fi);
}

void
ppc_linux_init_extra_frame_info (int fromleaf, struct frame_info *fi)
{
  rs6000_init_extra_frame_info (fromleaf, fi);

  if (get_next_frame (fi) != 0)
    {
      /* We're called from get_prev_frame_info; check to see if
         this is a signal frame by looking to see if the pc points
         at trampoline code */
      if (ppc_linux_at_sigtramp_return_path (get_frame_pc (fi)))
	deprecated_set_frame_type (fi, SIGTRAMP_FRAME);
      else
	/* FIXME: cagney/2002-11-10: Is this double bogus?  What
           happens if the frame has previously been marked as a dummy?  */
	deprecated_set_frame_type (fi, NORMAL_FRAME);
    }
}

int
ppc_linux_frameless_function_invocation (struct frame_info *fi)
{
  /* We'll find the wrong thing if we let 
     rs6000_frameless_function_invocation () search for a signal trampoline */
  if (ppc_linux_at_sigtramp_return_path (get_frame_pc (fi)))
    return 0;
  else
    return rs6000_frameless_function_invocation (fi);
}

void
ppc_linux_frame_init_saved_regs (struct frame_info *fi)
{
  if ((get_frame_type (fi) == SIGTRAMP_FRAME))
    {
      CORE_ADDR regs_addr;
      int i;
      if (deprecated_get_frame_saved_regs (fi))
	return;

      frame_saved_regs_zalloc (fi);

      regs_addr =
	read_memory_integer (get_frame_base (fi)
			     + PPC_LINUX_REGS_PTR_OFFSET, 4);
      deprecated_get_frame_saved_regs (fi)[PC_REGNUM] = regs_addr + 4 * PPC_LINUX_PT_NIP;
      deprecated_get_frame_saved_regs (fi)[gdbarch_tdep (current_gdbarch)->ppc_ps_regnum] =
        regs_addr + 4 * PPC_LINUX_PT_MSR;
      deprecated_get_frame_saved_regs (fi)[gdbarch_tdep (current_gdbarch)->ppc_cr_regnum] =
        regs_addr + 4 * PPC_LINUX_PT_CCR;
      deprecated_get_frame_saved_regs (fi)[gdbarch_tdep (current_gdbarch)->ppc_lr_regnum] =
        regs_addr + 4 * PPC_LINUX_PT_LNK;
      deprecated_get_frame_saved_regs (fi)[gdbarch_tdep (current_gdbarch)->ppc_ctr_regnum] =
        regs_addr + 4 * PPC_LINUX_PT_CTR;
      deprecated_get_frame_saved_regs (fi)[gdbarch_tdep (current_gdbarch)->ppc_xer_regnum] =
        regs_addr + 4 * PPC_LINUX_PT_XER;
      deprecated_get_frame_saved_regs (fi)[gdbarch_tdep (current_gdbarch)->ppc_mq_regnum] =
	regs_addr + 4 * PPC_LINUX_PT_MQ;
      for (i = 0; i < 32; i++)
	deprecated_get_frame_saved_regs (fi)[gdbarch_tdep (current_gdbarch)->ppc_gp0_regnum + i] =
	  regs_addr + 4 * PPC_LINUX_PT_R0 + 4 * i;
      for (i = 0; i < 32; i++)
	deprecated_get_frame_saved_regs (fi)[FP0_REGNUM + i] = regs_addr + 4 * PPC_LINUX_PT_FPR0 + 8 * i;
    }
  else
    rs6000_frame_init_saved_regs (fi);
}

CORE_ADDR
ppc_linux_frame_chain (struct frame_info *thisframe)
{
  /* Kernel properly constructs the frame chain for the handler */
  if ((get_frame_type (thisframe) == SIGTRAMP_FRAME))
    return read_memory_integer (get_frame_base (thisframe), 4);
  else
    return rs6000_frame_chain (thisframe);
}

a1086 13

#if 0
      /* Note: kevinb/2002-04-12: See note in rs6000_gdbarch_init regarding
	 *_push_arguments().  The same remarks hold for the methods below.  */
      set_gdbarch_deprecated_frameless_function_invocation (gdbarch, ppc_linux_frameless_function_invocation);
      set_gdbarch_deprecated_frame_chain (gdbarch, ppc_linux_frame_chain);
      set_gdbarch_deprecated_frame_saved_pc (gdbarch, ppc_linux_frame_saved_pc);

      set_gdbarch_deprecated_frame_init_saved_regs (gdbarch,
                                         ppc_linux_frame_init_saved_regs);
      set_gdbarch_deprecated_init_extra_frame_info (gdbarch,
                                         ppc_linux_init_extra_frame_info);
#endif
@


1.51
log
@2004-03-15  Andrew Cagney  <cagney@@redhat.com>

	* ppc-tdep.h: Update copyright.
	(ppc_linux_supply_gregset, ppc_linux_supply_fpregset): Change
	function signatures to match "regsets.h".
	* ppc-linux-tdep.c: Include "regset.h".
	(ELF_GREGSET_SIZE): Delete.
	(right_supply_register): New function.
	(ppc_linux_supply_fpregset, ppc_linux_supply_gregset): Rewrite
	using right_supply_register.
	(ppc32_linux_supply_gregset, ppc64_linux_supply_gregset): New
	functions.
	(ppc64_linux_gregset, ppc32_linux_gregset): Define.
	(ppc_linux_init_abi): Register ppc_linux_regset_from_core_section.
	(_initialize_ppc_linux_tdep): Do not register
	ppc_linux_regset_core_fns.
	(ppc_linux_regset_from_core_section): Replace
	fetch_core_registers.
	(ppc_linux_regset_core_fns): Delete.
	* ppc-linux-nat.c: (right_fill_reg): New function.
	(supply_gregset): Update call to ppc_linux_supply_gregset.
	(fill_gregset): Clear the register set, use right_fill_reg.
	(supply_fpregset): Update call to ppc_linux_supply_fpregset.
	(fill_fpregset): Use right_fill_reg, correctly compute FP offsets.

Index: ppc-linux-nat.c
===================================================================
RCS file: /cvs/src/src/gdb/ppc-linux-nat.c,v
retrieving revision 1.28
diff -u -r1.28 ppc-linux-nat.c
--- ppc-linux-nat.c	8 Mar 2004 01:45:02 -0000	1.28
+++ ppc-linux-nat.c	15 Mar 2004 21:28:31 -0000
@@@@ -507,7 +507,24 @@@@
 void
 supply_gregset (gdb_gregset_t *gregsetp)
 {
-  ppc_linux_supply_gregset ((char *) gregsetp);
+  /* NOTE: cagney/2003-11-25: This is the word size used by the ptrace
+     interface, and not the wordsize of the program's ABI.  */
+  int wordsize = sizeof (PTRACE_XFER_TYPE);
+  ppc_linux_supply_gregset (current_regcache, -1, gregsetp,
+			    sizeof (gdb_gregset_t), wordsize);
+}
+
+static void
+right_fill_reg (int regnum, void *reg)
+{
+  /* NOTE: cagney/2003-11-25: This is the word size used by the ptrace
+     interface, and not the wordsize of the program's ABI.  */
+  int wordsize = sizeof (PTRACE_XFER_TYPE);
+  /* Right fill the register.  */
+  regcache_raw_collect (current_regcache, regnum,
+			((bfd_byte *) reg
+			 + wordsize
+			 - register_size (current_gdbarch, regnum)));
 }

 void
@@@@ -516,36 +533,42 @@@@
   int regi;
   elf_greg_t *regp = (elf_greg_t *) gregsetp;
   struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
+  const int elf_ngreg = 48;
+
+
+  /* Start with zeros.  */
+  memset (regp, 0, elf_ngreg * sizeof (*regp));

   for (regi = 0; regi < 32; regi++)
     {
       if ((regno == -1) || regno == regi)
-        regcache_collect (regi, regp + PT_R0 + regi);
+	right_fill_reg (regi, (regp + PT_R0 + regi));
     }

   if ((regno == -1) || regno == PC_REGNUM)
-    regcache_collect (PC_REGNUM, regp + PT_NIP);
+    right_fill_reg (PC_REGNUM, regp + PT_NIP);
   if ((regno == -1) || regno == tdep->ppc_lr_regnum)
-    regcache_collect (tdep->ppc_lr_regnum, regp + PT_LNK);
+    right_fill_reg (tdep->ppc_lr_regnum, regp + PT_LNK);
   if ((regno == -1) || regno == tdep->ppc_cr_regnum)
     regcache_collect (tdep->ppc_cr_regnum, regp + PT_CCR);
   if ((regno == -1) || regno == tdep->ppc_xer_regnum)
     regcache_collect (tdep->ppc_xer_regnum, regp + PT_XER);
   if ((regno == -1) || regno == tdep->ppc_ctr_regnum)
-    regcache_collect (tdep->ppc_ctr_regnum, regp + PT_CTR);
+    right_fill_reg (tdep->ppc_ctr_regnum, regp + PT_CTR);
 #ifdef PT_MQ
   if (((regno == -1) || regno == tdep->ppc_mq_regnum)
       && (tdep->ppc_mq_regnum != -1))
-    regcache_collect (tdep->ppc_mq_regnum, regp + PT_MQ);
+    right_fill_reg (tdep->ppc_mq_regnum, regp + PT_MQ);
 #endif
   if ((regno == -1) || regno == tdep->ppc_ps_regnum)
-    regcache_collect (tdep->ppc_ps_regnum, regp + PT_MSR);
+    right_fill_reg (tdep->ppc_ps_regnum, regp + PT_MSR);
 }

 void
 supply_fpregset (gdb_fpregset_t * fpregsetp)
 {
-  ppc_linux_supply_fpregset ((char *) fpregsetp);
+  ppc_linux_supply_fpregset (NULL, current_regcache, -1, fpregsetp,
+			     sizeof (gdb_fpregset_t));
 }

 /* Given a pointer to a floating point register set in /proc format
@@@@ -557,12 +580,13 @@@@
 {
   int regi;
   struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
+  bfd_byte *fpp = (void *) fpregsetp;

   for (regi = 0; regi < 32; regi++)
     {
       if ((regno == -1) || (regno == FP0_REGNUM + regi))
-	regcache_collect (FP0_REGNUM + regi, (char *) (*fpregsetp + regi));
+	regcache_collect (FP0_REGNUM + regi, fpp + 8 * regi);
     }
   if ((regno == -1) || regno == tdep->ppc_fpscr_regnum)
-    regcache_collect (tdep->ppc_fpscr_regnum, (char *) (*fpregsetp + regi));
+    right_fill_reg (tdep->ppc_fpscr_regnum, (fpp + 8 * 32));
 }
Index: ppc-linux-tdep.c
===================================================================
RCS file: /cvs/src/src/gdb/ppc-linux-tdep.c,v
retrieving revision 1.50
diff -u -r1.50 ppc-linux-tdep.c
--- ppc-linux-tdep.c	16 Feb 2004 21:49:22 -0000	1.50
+++ ppc-linux-tdep.c	15 Mar 2004 21:28:31 -0000
@@@@ -32,7 +32,7 @@@@
 #include "regcache.h"
 #include "value.h"
 #include "osabi.h"
-
+#include "regset.h"
 #include "solib-svr4.h"
 #include "ppc-tdep.h"

@@@@ -959,81 +959,114 @@@@
 };

 enum {
-  ELF_GREGSET_SIZE = (ELF_NGREG * 4),
   ELF_FPREGSET_SIZE = (ELF_NFPREG * 8)
 };

+static void
+right_supply_register (struct regcache *regcache, int wordsize, int regnum,
+		       const bfd_byte *buf)
+{
+  regcache_raw_supply (regcache, regnum,
+		       (buf + wordsize
+			- register_size (current_gdbarch, regnum)));
+}
+
+/* Extract the register values found in the WORDSIZED ABI GREGSET,
+   storing their values in REGCACHE.  Note that some are left-aligned,
+   while others are right aligned.  */
+
 void
-ppc_linux_supply_gregset (char *buf)
+ppc_linux_supply_gregset (struct regcache *regcache,
+			  int regnum, const void *gregs, size_t size,
+			  int wordsize)
 {
   int regi;
-  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
+  struct gdbarch *regcache_arch = get_regcache_arch (regcache);
+  struct gdbarch_tdep *regcache_tdep = gdbarch_tdep (regcache_arch);
+  const bfd_byte *buf = gregs;

   for (regi = 0; regi < 32; regi++)
-    supply_register (regi, buf + 4 * regi);
+    right_supply_register (regcache, wordsize, regi, buf + wordsize * regi);
+
+  right_supply_register (regcache, wordsize, gdbarch_pc_regnum (regcache_arch),
+			 buf + wordsize * PPC_LINUX_PT_NIP);
+  right_supply_register (regcache, wordsize, regcache_tdep->ppc_lr_regnum,
+			 buf + wordsize * PPC_LINUX_PT_LNK);
+  regcache_raw_supply (regcache, regcache_tdep->ppc_cr_regnum,
+		       buf + wordsize * PPC_LINUX_PT_CCR);
+  regcache_raw_supply (regcache, regcache_tdep->ppc_xer_regnum,
+		       buf + wordsize * PPC_LINUX_PT_XER);
+  regcache_raw_supply (regcache, regcache_tdep->ppc_ctr_regnum,
+		       buf + wordsize * PPC_LINUX_PT_CTR);
+  if (regcache_tdep->ppc_mq_regnum != -1)
+    right_supply_register (regcache, wordsize, regcache_tdep->ppc_mq_regnum,
+			   buf + wordsize * PPC_LINUX_PT_MQ);
+  right_supply_register (regcache, wordsize, regcache_tdep->ppc_ps_regnum,
+			 buf + wordsize * PPC_LINUX_PT_MSR);
+}

-  supply_register (PC_REGNUM, buf + 4 * PPC_LINUX_PT_NIP);
-  supply_register (tdep->ppc_lr_regnum, buf + 4 * PPC_LINUX_PT_LNK);
-  supply_register (tdep->ppc_cr_regnum, buf + 4 * PPC_LINUX_PT_CCR);
-  supply_register (tdep->ppc_xer_regnum, buf + 4 * PPC_LINUX_PT_XER);
-  supply_register (tdep->ppc_ctr_regnum, buf + 4 * PPC_LINUX_PT_CTR);
-  if (tdep->ppc_mq_regnum != -1)
-    supply_register (tdep->ppc_mq_regnum, buf + 4 * PPC_LINUX_PT_MQ);
-  supply_register (tdep->ppc_ps_regnum, buf + 4 * PPC_LINUX_PT_MSR);
+static void
+ppc32_linux_supply_gregset (const struct regset *regset,
+			    struct regcache *regcache,
+			    int regnum, const void *gregs, size_t size)
+{
+  ppc_linux_supply_gregset (regcache, regnum, gregs, size, 4);
 }

+static struct regset ppc32_linux_gregset = {
+  NULL, ppc32_linux_supply_gregset
+};
+
+static void
+ppc64_linux_supply_gregset (const struct regset *regset,
+			    struct regcache * regcache,
+			    int regnum, const void *gregs, size_t size)
+{
+  ppc_linux_supply_gregset (regcache, regnum, gregs, size, 8);
+}
+
+static struct regset ppc64_linux_gregset = {
+  NULL, ppc64_linux_supply_gregset
+};
+
 void
-ppc_linux_supply_fpregset (char *buf)
+ppc_linux_supply_fpregset (const struct regset *regset,
+			   struct regcache * regcache,
+			   int regnum, const void *fpset, size_t size)
 {
   int regi;
-  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
+  struct gdbarch *regcache_arch = get_regcache_arch (regcache);
+  struct gdbarch_tdep *regcache_tdep = gdbarch_tdep (regcache_arch);
+  const bfd_byte *buf = fpset;

   for (regi = 0; regi < 32; regi++)
-    supply_register (FP0_REGNUM + regi, buf + 8 * regi);
+    regcache_raw_supply (regcache, FP0_REGNUM + regi, buf + 8 * regi);

   /* The FPSCR is stored in the low order word of the last doubleword in the
      fpregset.  */
-  supply_register (tdep->ppc_fpscr_regnum, buf + 8 * 32 + 4);
+  regcache_raw_supply (regcache, regcache_tdep->ppc_fpscr_regnum,
+		       buf + 8 * 32 + 4);
 }

-/*
-  Use a local version of this function to get the correct types for regsets.
-*/
+static struct regset ppc_linux_fpregset = { NULL, ppc_linux_supply_fpregset };

-static void
-fetch_core_registers (char *core_reg_sect,
-		      unsigned core_reg_size,
-		      int which,
-		      CORE_ADDR reg_addr)
+static const struct regset *
+ppc_linux_regset_from_core_section (struct gdbarch *core_arch,
+				    const char *sect_name, size_t sect_size)
 {
-  if (which == 0)
+  struct gdbarch_tdep *tdep = gdbarch_tdep (core_arch);
+  if (strcmp (sect_name, ".reg") == 0)
     {
-      if (core_reg_size == ELF_GREGSET_SIZE)
-	ppc_linux_supply_gregset (core_reg_sect);
+      if (tdep->wordsize == 4)
+	return &ppc32_linux_gregset;
       else
-	warning ("wrong size gregset struct in core file");
-    }
-  else if (which == 2)
-    {
-      if (core_reg_size == ELF_FPREGSET_SIZE)
-	ppc_linux_supply_fpregset (core_reg_sect);
-      else
-	warning ("wrong size fpregset struct in core file");
+	return &ppc64_linux_gregset;
     }
+  if (strcmp (sect_name, ".reg2") == 0)
+    return &ppc_linux_fpregset;
+  return NULL;
 }

-/* Register that we are able to handle ELF file formats using standard
-   procfs "regset" structures.  */
-
-static struct core_fns ppc_linux_regset_core_fns =
-{
-  bfd_target_elf_flavour,	/* core_flavour */
-  default_check_format,		/* check_format */
-  default_core_sniffer,		/* core_sniffer */
-  fetch_core_registers,		/* core_read_registers */
-  NULL				/* next */
-};
-
 static void
 ppc_linux_init_abi (struct gdbarch_info info,
                     struct gdbarch *gdbarch)
@@@@ -1086,6 +1119,7 @@@@
       /* PPC64 malloc's entry-point is called ".malloc".  */
       set_gdbarch_name_of_malloc (gdbarch, ".malloc");
     }
+  set_gdbarch_regset_from_core_section (gdbarch, ppc_linux_regset_from_core_section);
 }

 void
@@@@ -1099,5 +1133,4 @@@@
                          ppc_linux_init_abi);
   gdbarch_register_osabi (bfd_arch_rs6000, bfd_mach_rs6k, GDB_OSABI_LINUX,
                          ppc_linux_init_abi);
-  add_core_fns (&ppc_linux_regset_core_fns);
 }
Index: ppc-tdep.h
===================================================================
RCS file: /cvs/src/src/gdb/ppc-tdep.h,v
retrieving revision 1.25
diff -u -r1.25 ppc-tdep.h
--- ppc-tdep.h	10 Nov 2003 22:47:28 -0000	1.25
+++ ppc-tdep.h	15 Mar 2004 21:28:31 -0000
@@@@ -1,6 +1,7 @@@@
 /* Target-dependent code for GDB, the GNU debugger.
-   Copyright 2000, 2001, 2002, 2003
-   Free Software Foundation, Inc.
+
+   Copyright 2000, 2001, 2002, 2003, 2004 Free Software Foundation,
+   Inc.

    This file is part of GDB.

@@@@ -62,8 +63,12 @@@@
 						    CORE_ADDR bpaddr);
 int ppc_linux_memory_remove_breakpoint (CORE_ADDR addr, char *contents_cache);
 struct link_map_offsets *ppc_linux_svr4_fetch_link_map_offsets (void);
-void ppc_linux_supply_gregset (char *buf);
-void ppc_linux_supply_fpregset (char *buf);
+void ppc_linux_supply_gregset (struct regcache *regcache,
+			       int regnum, const void *gregs, size_t size,
+			       int wordsize);
+void ppc_linux_supply_fpregset (const struct regset *regset,
+				struct regcache *regcache,
+				int regnum, const void *gregs, size_t size);

 enum return_value_convention ppc64_sysv_abi_return_value (struct gdbarch *gdbarch,
 							  struct type *valtype,
@
text
@d38 2
d1022 104
d1193 1
d1204 1
d1208 1
d1232 1
@


1.50
log
@2004-02-09  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_FRAMELESS_FUNCTION_INVOCATION): Predicate
	and function replacing FRAMELESS_FUNCTION_INVOCATION.
	* blockframe.c (legacy_frameless_look_for_prologue): Rename
	frameless_look_for_prologue.
	* frame.h (legacy_frameless_look_for_prologue): Rename
	frameless_look_for_prologue.
	* gdbarch.h, gdbarch.c: Re-generate.
	* sh64-tdep.c (sh64_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	(delta68_frame_args_address): Update.
	* m32r-tdep.c (m32r_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	(frv_frameless_function_invocation): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	(cris_frameless_function_invocation): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* stack.c (frame_info): Update, call predicate.
	* rs6000-tdep.c (rs6000_frame_chain): Update, call predicate..
	* frame.c (legacy_get_prev_frame): Update, call predicate..
	* arch-utils.c (generic_frameless_function_invocation_not): Delete.
	* arch-utils.h (generic_frameless_function_invocation_not): Delete.
	* alpha-tdep.c (alpha_gdbarch_init): Do not set frameless function
	invocation.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
@
text
@d35 1
a35 1

a961 1
  ELF_GREGSET_SIZE = (ELF_NGREG * 4),
d965 13
d979 3
a981 1
ppc_linux_supply_gregset (char *buf)
d984 3
a986 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 
d989 18
a1006 1
    supply_register (regi, buf + 4 * regi);
d1008 6
a1013 8
  supply_register (PC_REGNUM, buf + 4 * PPC_LINUX_PT_NIP);
  supply_register (tdep->ppc_lr_regnum, buf + 4 * PPC_LINUX_PT_LNK);
  supply_register (tdep->ppc_cr_regnum, buf + 4 * PPC_LINUX_PT_CCR);
  supply_register (tdep->ppc_xer_regnum, buf + 4 * PPC_LINUX_PT_XER);
  supply_register (tdep->ppc_ctr_regnum, buf + 4 * PPC_LINUX_PT_CTR);
  if (tdep->ppc_mq_regnum != -1)
    supply_register (tdep->ppc_mq_regnum, buf + 4 * PPC_LINUX_PT_MQ);
  supply_register (tdep->ppc_ps_regnum, buf + 4 * PPC_LINUX_PT_MSR);
d1016 16
d1033 3
a1035 1
ppc_linux_supply_fpregset (char *buf)
d1038 3
a1040 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 
d1043 1
a1043 1
    supply_register (FP0_REGNUM + regi, buf + 8 * regi);
d1047 2
a1048 1
  supply_register (tdep->ppc_fpscr_regnum, buf + 8 * 32 + 4);
d1051 1
a1051 3
/*
  Use a local version of this function to get the correct types for regsets.
*/
d1053 3
a1055 5
static void
fetch_core_registers (char *core_reg_sect,
		      unsigned core_reg_size,
		      int which,
		      CORE_ADDR reg_addr)
d1057 2
a1058 1
  if (which == 0)
d1060 2
a1061 2
      if (core_reg_size == ELF_GREGSET_SIZE)
	ppc_linux_supply_gregset (core_reg_sect);
d1063 1
a1063 8
	warning ("wrong size gregset struct in core file");
    }
  else if (which == 2)
    {
      if (core_reg_size == ELF_FPREGSET_SIZE)
	ppc_linux_supply_fpregset (core_reg_sect);
      else
	warning ("wrong size fpregset struct in core file");
d1065 3
a1069 12
/* Register that we are able to handle ELF file formats using standard
   procfs "regset" structures.  */

static struct core_fns ppc_linux_regset_core_fns =
{
  bfd_target_elf_flavour,	/* core_flavour */
  default_check_format,		/* check_format */
  default_core_sniffer,		/* core_sniffer */
  fetch_core_registers,		/* core_read_registers */
  NULL				/* next */
};

d1122 1
a1135 1
  add_core_fns (&ppc_linux_regset_core_fns);
@


1.50.2.1
log
@Merge mainline to intercu branch.
@
text
@d35 1
a35 1
#include "regset.h"
a37 2
#include "trad-frame.h"
#include "frame-unwind.h"
d115 2
a116 2
   infrun.c calls DEPRECATED_PC_IN_SIGTRAMP in order to detect entry
   into a signal trampoline just after delivery of a signal.  But on
d151 5
a155 5
   DEPRECATED_PC_IN_SIGTRAMP is called from blockframe.c as well in
   order to set the frame's type (if a SIGTRAMP_FRAME).  Because of
   our strange definition of in_sigtramp below, we can't rely on the
   frame's type getting set correctly from within blockframe.c.  This
   is why we take pains to set it in init_extra_frame_info().
d341 105
d962 1
a965 13
static void
right_supply_register (struct regcache *regcache, int wordsize, int regnum,
		       const bfd_byte *buf)
{
  regcache_raw_supply (regcache, regnum,
		       (buf + wordsize
			- register_size (current_gdbarch, regnum)));
}

/* Extract the register values found in the WORDSIZED ABI GREGSET,
   storing their values in REGCACHE.  Note that some are left-aligned,
   while others are right aligned.  */

d967 1
a967 3
ppc_linux_supply_gregset (struct regcache *regcache,
			  int regnum, const void *gregs, size_t size,
			  int wordsize)
d970 1
a970 3
  struct gdbarch *regcache_arch = get_regcache_arch (regcache); 
  struct gdbarch_tdep *regcache_tdep = gdbarch_tdep (regcache_arch);
  const bfd_byte *buf = gregs;
d973 1
a973 30
    right_supply_register (regcache, wordsize, regi, buf + wordsize * regi);

  right_supply_register (regcache, wordsize, gdbarch_pc_regnum (regcache_arch),
			 buf + wordsize * PPC_LINUX_PT_NIP);
  right_supply_register (regcache, wordsize, regcache_tdep->ppc_lr_regnum,
			 buf + wordsize * PPC_LINUX_PT_LNK);
  regcache_raw_supply (regcache, regcache_tdep->ppc_cr_regnum,
		       buf + wordsize * PPC_LINUX_PT_CCR);
  regcache_raw_supply (regcache, regcache_tdep->ppc_xer_regnum,
		       buf + wordsize * PPC_LINUX_PT_XER);
  regcache_raw_supply (regcache, regcache_tdep->ppc_ctr_regnum,
		       buf + wordsize * PPC_LINUX_PT_CTR);
  if (regcache_tdep->ppc_mq_regnum != -1)
    right_supply_register (regcache, wordsize, regcache_tdep->ppc_mq_regnum,
			   buf + wordsize * PPC_LINUX_PT_MQ);
  right_supply_register (regcache, wordsize, regcache_tdep->ppc_ps_regnum,
			 buf + wordsize * PPC_LINUX_PT_MSR);
}

static void
ppc32_linux_supply_gregset (const struct regset *regset,
			    struct regcache *regcache,
			    int regnum, const void *gregs, size_t size)
{
  ppc_linux_supply_gregset (regcache, regnum, gregs, size, 4);
}

static struct regset ppc32_linux_gregset = {
  NULL, ppc32_linux_supply_gregset
};
d975 8
a982 60
struct ppc_linux_sigtramp_cache
{
  CORE_ADDR base;
  struct trad_frame_saved_reg *saved_regs;
};

static struct ppc_linux_sigtramp_cache *
ppc_linux_sigtramp_cache (struct frame_info *next_frame, void **this_cache)
{
  CORE_ADDR regs;
  CORE_ADDR gpregs;
  CORE_ADDR fpregs;
  int i;
  struct ppc_linux_sigtramp_cache *cache;
  struct gdbarch *gdbarch = get_frame_arch (next_frame);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  if ((*this_cache) != NULL)
    return (*this_cache);
  cache = FRAME_OBSTACK_ZALLOC (struct ppc_linux_sigtramp_cache);
  (*this_cache) = cache;
  cache->saved_regs = trad_frame_alloc_saved_regs (next_frame);

  cache->base = frame_unwind_register_unsigned (next_frame, SP_REGNUM);

  /* Find the register pointer, which gives the address of the
     register buffers.  */
  if (tdep->wordsize == 4)
    regs = (cache->base
	    + 0xd0 /* Offset to ucontext_t.  */
	    + 0x30 /* Offset to .reg.  */);
  else
    regs = (cache->base
	    + 0x80 /* Offset to ucontext_t.  */
	    + 0xe0 /* Offset to .reg.  */);
  /* And the corresponding register buffers.  */
  gpregs = read_memory_unsigned_integer (regs, tdep->wordsize);
  fpregs = gpregs + 48 * tdep->wordsize;

  /* General purpose.  */
  for (i = 0; i < 32; i++)
    {
      int regnum = i + tdep->ppc_gp0_regnum;
      cache->saved_regs[regnum].addr = gpregs + i * tdep->wordsize;
    }
  cache->saved_regs[PC_REGNUM].addr = gpregs + 32 * tdep->wordsize;
  cache->saved_regs[tdep->ppc_ctr_regnum].addr = gpregs + 35 * tdep->wordsize;
  cache->saved_regs[tdep->ppc_lr_regnum].addr = gpregs + 36 * tdep->wordsize;
  cache->saved_regs[tdep->ppc_xer_regnum].addr = gpregs + 37 * tdep->wordsize;
  cache->saved_regs[tdep->ppc_cr_regnum].addr = gpregs + 38 * tdep->wordsize;

  /* Floating point registers.  */
  for (i = 0; i < 32; i++)
    {
      int regnum = i + FP0_REGNUM;
      cache->saved_regs[regnum].addr = fpregs + i * tdep->wordsize;
    }
  cache->saved_regs[tdep->ppc_fpscr_regnum].addr = fpregs + 32 * tdep->wordsize;

  return cache;
a984 54
static void
ppc_linux_sigtramp_this_id (struct frame_info *next_frame, void **this_cache,
			  struct frame_id *this_id)
{
  struct ppc_linux_sigtramp_cache *info
    = ppc_linux_sigtramp_cache (next_frame, this_cache);
  (*this_id) = frame_id_build (info->base, frame_pc_unwind (next_frame));
}

static void
ppc_linux_sigtramp_prev_register (struct frame_info *next_frame,
				void **this_cache,
				int regnum, int *optimizedp,
				enum lval_type *lvalp, CORE_ADDR *addrp,
				int *realnump, void *valuep)
{
  struct ppc_linux_sigtramp_cache *info
    = ppc_linux_sigtramp_cache (next_frame, this_cache);
  trad_frame_prev_register (next_frame, info->saved_regs, regnum,
			    optimizedp, lvalp, addrp, realnump, valuep);
}

static const struct frame_unwind ppc_linux_sigtramp_unwind =
{
  SIGTRAMP_FRAME,
  ppc_linux_sigtramp_this_id,
  ppc_linux_sigtramp_prev_register
};

static const struct frame_unwind *
ppc_linux_sigtramp_sniffer (struct frame_info *next_frame)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (get_frame_arch (next_frame));
  if (frame_pc_unwind (next_frame)
      > frame_unwind_register_unsigned (next_frame, SP_REGNUM))
    /* Assume anything that is vaguely on the stack is a signal
       trampoline.  */
    return &ppc_linux_sigtramp_unwind;
  else
    return NULL;
}

static void
ppc64_linux_supply_gregset (const struct regset *regset,
			    struct regcache * regcache,
			    int regnum, const void *gregs, size_t size)
{
  ppc_linux_supply_gregset (regcache, regnum, gregs, size, 8);
}

static struct regset ppc64_linux_gregset = {
  NULL, ppc64_linux_supply_gregset
};

d986 1
a986 3
ppc_linux_supply_fpregset (const struct regset *regset,
			   struct regcache * regcache,
			   int regnum, const void *fpset, size_t size)
d989 1
a989 3
  struct gdbarch *regcache_arch = get_regcache_arch (regcache); 
  struct gdbarch_tdep *regcache_tdep = gdbarch_tdep (regcache_arch);
  const bfd_byte *buf = fpset;
d992 1
a992 1
    regcache_raw_supply (regcache, FP0_REGNUM + regi, buf + 8 * regi);
d996 1
a996 2
  regcache_raw_supply (regcache, regcache_tdep->ppc_fpscr_regnum,
		       buf + 8 * 32 + 4);
d999 3
a1001 1
static struct regset ppc_linux_fpregset = { NULL, ppc_linux_supply_fpregset };
d1003 5
a1007 3
static const struct regset *
ppc_linux_regset_from_core_section (struct gdbarch *core_arch,
				    const char *sect_name, size_t sect_size)
d1009 8
a1016 2
  struct gdbarch_tdep *tdep = gdbarch_tdep (core_arch);
  if (strcmp (sect_name, ".reg") == 0)
d1018 2
a1019 2
      if (tdep->wordsize == 4)
	return &ppc32_linux_gregset;
d1021 1
a1021 1
	return &ppc64_linux_gregset;
a1022 3
  if (strcmp (sect_name, ".reg2") == 0)
    return &ppc_linux_fpregset;
  return NULL;
d1025 12
a1044 9
      /* NOTE: jimb/2004-03-26: The System V ABI PowerPC Processor
         Supplement says that long doubles are sixteen bytes long.
         However, as one of the known warts of its ABI, PPC GNU/Linux
         uses eight-byte long doubles.  GCC only recently got 128-bit
         long double support on PPC, so it may be changing soon.  The
         Linux Standards Base says that programs that use 'long
         double' on PPC GNU/Linux are non-conformant.  */
      set_gdbarch_long_double_bit (gdbarch, 8 * TARGET_CHAR_BIT);

d1054 11
a1066 1

a1088 2
  set_gdbarch_regset_from_core_section (gdbarch, ppc_linux_regset_from_core_section);
  frame_unwind_append_sniffer (gdbarch, ppc_linux_sigtramp_sniffer);
d1102 1
@


1.50.2.2
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d4 1
a4 1
   1997, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
d117 2
a118 2
   infrun.c calls get_frame_type() in order to detect entry into a
   signal trampoline just after delivery of a signal.  But on
d149 14
a162 3
   puts us on the second instruction.  (I added the test for the first
   instruction long after the fact, just in case the observed behavior
   is ever fixed.)  */
d851 11
d867 2
a868 1
		       (buf + wordsize - register_size (current_gdbarch, regnum)));
d885 2
a886 4
  for (regi = 0; regi < ppc_num_gprs; regi++)
    right_supply_register (regcache, wordsize,
                           regcache_tdep->ppc_gp0_regnum + regi,
                           buf + wordsize * regi);
d957 1
a957 1
  for (i = 0; i < ppc_num_gprs; i++)
d969 1
a969 1
  if (ppc_floating_point_unit_p (gdbarch))
d971 2
a972 7
      for (i = 0; i < ppc_num_fprs; i++)
        {
          int regnum = i + tdep->ppc_fp0_regnum;
          cache->saved_regs[regnum].addr = fpregs + i * tdep->wordsize;
        }
      cache->saved_regs[tdep->ppc_fpscr_regnum].addr
        = fpregs + 32 * tdep->wordsize;
d974 1
d997 2
a998 2
  trad_frame_get_prev_register (next_frame, info->saved_regs, regnum,
				optimizedp, lvalp, addrp, realnump, valuep);
d1043 2
a1044 7
  if (! ppc_floating_point_unit_p (regcache_arch))
    return;

  for (regi = 0; regi < ppc_num_fprs; regi++)
    regcache_raw_supply (regcache, 
                         regcache_tdep->ppc_fp0_regnum + regi,
                         buf + 8 * regi);
d1046 2
a1047 2
  /* The FPSCR is stored in the low order word of the last
     doubleword in the fpregset.  */
d1049 1
a1049 1
                       buf + 8 * 32 + 4);
d1084 1
a1084 1
         Linux[sic] Standards Base says that programs that use 'long
@


1.50.6.1
log
@Dump of tramp-frame stuff.
@
text
@d35 1
a35 2
#include "trad-frame.h"
#include "tramp-frame.h"
a1037 138
ppc_linux_sigtramp_cache (struct frame_info *next_frame,
			  struct trad_frame_cache *this_cache,
			  CORE_ADDR func, LONGEST offset,
			  int bias)
{
  CORE_ADDR base;
  CORE_ADDR regs;
  CORE_ADDR gpregs;
  CORE_ADDR fpregs;
  int i;
  struct gdbarch *gdbarch = get_frame_arch (next_frame);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  base = frame_unwind_register_unsigned (next_frame, SP_REGNUM);
  if (bias > 0 && frame_pc_unwind (next_frame) != func)
    /* See below, some signal trampolines increment the stack as their
       first instruction, need to compensate for that.  */
    base -= bias;

  /* Find the address of the register buffer pointer.  */
  regs = base + offset;
  /* Use that to find the address of the corresponding register
     buffers.  */
  gpregs = read_memory_unsigned_integer (regs, tdep->wordsize);
  fpregs = gpregs + 48 * tdep->wordsize;

  /* General purpose.  */
  for (i = 0; i < 32; i++)
    {
      int regnum = i + tdep->ppc_gp0_regnum;
      trad_frame_set_addr (this_cache, regnum, gpregs + i * tdep->wordsize);
    }
  trad_frame_set_addr (this_cache, PC_REGNUM, gpregs + 32 * tdep->wordsize);
  trad_frame_set_addr (this_cache, tdep->ppc_ctr_regnum,
		       gpregs + 35 * tdep->wordsize);
  trad_frame_set_addr (this_cache, tdep->ppc_lr_regnum,
		       gpregs + 36 * tdep->wordsize);
  trad_frame_set_addr (this_cache, tdep->ppc_xer_regnum,
		       gpregs + 37 * tdep->wordsize);
  trad_frame_set_addr (this_cache, tdep->ppc_cr_regnum,
		       gpregs + 38 * tdep->wordsize);

  /* Floating point registers.  */
  for (i = 0; i < 32; i++)
    {
      int regnum = i + FP0_REGNUM;
      trad_frame_set_addr (this_cache, regnum, fpregs + i * tdep->wordsize);
    }
  trad_frame_set_addr (this_cache, tdep->ppc_fpscr_regnum,
		       fpregs + 32 * tdep->wordsize);

  this_cache->this_id = frame_id_build (base, func);
}

static void
ppc32_linux_sigaction_cache_init (const struct tramp_frame *self,
				  struct frame_info *next_frame,
				  struct trad_frame_cache *this_cache,
				  CORE_ADDR func)
{
  ppc_linux_sigtramp_cache (next_frame, this_cache, func,
			    0xd0 /* Offset to ucontext_t.  */
			    + 0x30 /* Offset to .reg.  */,
			    0);
}

static void
ppc64_linux_sigaction_cache_init (const struct tramp_frame *self,
				  struct frame_info *next_frame,
				  struct trad_frame_cache *this_cache,
				  CORE_ADDR func)
{
  ppc_linux_sigtramp_cache (next_frame, this_cache, func,
			    0x80 /* Offset to ucontext_t.  */
			    + 0xe0 /* Offset to .reg.  */,
			    128);
}

static void
ppc32_linux_sighandler_cache_init (const struct tramp_frame *self,
				   struct frame_info *next_frame,
				   struct trad_frame_cache *this_cache,
				   CORE_ADDR func)
{
  ppc_linux_sigtramp_cache (next_frame, this_cache, func,
			    0x40 /* Offset to ucontext_t.  */
			    + 0x1c /* Offset to .reg.  */,
			    0);
}

static void
ppc64_linux_sighandler_cache_init (const struct tramp_frame *self,
				   struct frame_info *next_frame,
				   struct trad_frame_cache *this_cache,
				   CORE_ADDR func)
{
  ppc_linux_sigtramp_cache (next_frame, this_cache, func,
			    0x80 /* Offset to struct sigcontext.  */
			    + 0x38 /* Offset to .reg.  */,
			    128);
}

static struct tramp_frame ppc32_linux_sigaction_tramp_frame = {
  4,
  { 0x380000ac, /* li r0, 172 */
    0x44000002, /* sc */
    0
  },
  ppc32_linux_sigaction_cache_init
};
static struct tramp_frame ppc64_linux_sigaction_tramp_frame = {
  4,
  { 0x38210080, /* addi r1,r1,128 */
    0x380000ac, /* li r0, 172 */
    0x44000002, /* sc */
    0
  },
  ppc64_linux_sigaction_cache_init
};
static struct tramp_frame ppc32_linux_sighandler_tramp_frame = {
  4,
  { 0x38000077, /* li r0,119 */
    0x44000002, /* sc */
    0
  },
  ppc32_linux_sighandler_cache_init
};
static struct tramp_frame ppc64_linux_sighandler_tramp_frame = {
  4,
  { 0x38210080, /* addi r1,r1,128 */
    0x38000077, /* li r0,119 */
    0x44000002, /* sc */
    0
  },
  ppc64_linux_sighandler_cache_init
};

static void
a1072 4

      /* Trampolines.  */
      tramp_frame_append (gdbarch, &ppc32_linux_sigaction_tramp_frame);
      tramp_frame_append (gdbarch, &ppc32_linux_sighandler_tramp_frame);
a1087 3

      tramp_frame_append (gdbarch, &ppc64_linux_sigaction_tramp_frame);
      tramp_frame_append (gdbarch, &ppc64_linux_sighandler_tramp_frame);
@


1.50.6.2
log
@Merge with mainline cagney_tramp-20040321-mergepoint.
@
text
@a36 1
#include "regset.h"
a38 2
#include "trad-frame.h"
#include "frame-unwind.h"
d342 105
d963 1
a966 13
static void
right_supply_register (struct regcache *regcache, int wordsize, int regnum,
		       const bfd_byte *buf)
{
  regcache_raw_supply (regcache, regnum,
		       (buf + wordsize
			- register_size (current_gdbarch, regnum)));
}

/* Extract the register values found in the WORDSIZED ABI GREGSET,
   storing their values in REGCACHE.  Note that some are left-aligned,
   while others are right aligned.  */

d968 1
a968 3
ppc_linux_supply_gregset (struct regcache *regcache,
			  int regnum, const void *gregs, size_t size,
			  int wordsize)
d971 1
a971 3
  struct gdbarch *regcache_arch = get_regcache_arch (regcache); 
  struct gdbarch_tdep *regcache_tdep = gdbarch_tdep (regcache_arch);
  const bfd_byte *buf = gregs;
d974 1
a974 18
    right_supply_register (regcache, wordsize, regi, buf + wordsize * regi);

  right_supply_register (regcache, wordsize, gdbarch_pc_regnum (regcache_arch),
			 buf + wordsize * PPC_LINUX_PT_NIP);
  right_supply_register (regcache, wordsize, regcache_tdep->ppc_lr_regnum,
			 buf + wordsize * PPC_LINUX_PT_LNK);
  regcache_raw_supply (regcache, regcache_tdep->ppc_cr_regnum,
		       buf + wordsize * PPC_LINUX_PT_CCR);
  regcache_raw_supply (regcache, regcache_tdep->ppc_xer_regnum,
		       buf + wordsize * PPC_LINUX_PT_XER);
  regcache_raw_supply (regcache, regcache_tdep->ppc_ctr_regnum,
		       buf + wordsize * PPC_LINUX_PT_CTR);
  if (regcache_tdep->ppc_mq_regnum != -1)
    right_supply_register (regcache, wordsize, regcache_tdep->ppc_mq_regnum,
			   buf + wordsize * PPC_LINUX_PT_MQ);
  right_supply_register (regcache, wordsize, regcache_tdep->ppc_ps_regnum,
			 buf + wordsize * PPC_LINUX_PT_MSR);
}
d976 8
a983 6
static void
ppc32_linux_supply_gregset (const struct regset *regset,
			    struct regcache *regcache,
			    int regnum, const void *gregs, size_t size)
{
  ppc_linux_supply_gregset (regcache, regnum, gregs, size, 4);
a985 120
static struct regset ppc32_linux_gregset = {
  NULL, ppc32_linux_supply_gregset
};

struct ppc_linux_sigtramp_cache
{
  CORE_ADDR base;
  struct trad_frame_saved_reg *saved_regs;
};

static struct ppc_linux_sigtramp_cache *
ppc_linux_sigtramp_cache (struct frame_info *next_frame, void **this_cache)
{
  CORE_ADDR regs;
  CORE_ADDR gpregs;
  CORE_ADDR fpregs;
  int i;
  struct ppc_linux_sigtramp_cache *cache;
  struct gdbarch *gdbarch = get_frame_arch (next_frame);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  if ((*this_cache) != NULL)
    return (*this_cache);
  cache = FRAME_OBSTACK_ZALLOC (struct ppc_linux_sigtramp_cache);
  (*this_cache) = cache;
  cache->saved_regs = trad_frame_alloc_saved_regs (next_frame);

  cache->base = frame_unwind_register_unsigned (next_frame, SP_REGNUM);

  /* Find the register pointer, which gives the address of the
     register buffers.  */
  if (tdep->wordsize == 4)
    regs = (cache->base
	    + 0xd0 /* Offset to ucontext_t.  */
	    + 0x30 /* Offset to .reg.  */);
  else
    regs = (cache->base
	    + 0x80 /* Offset to ucontext_t.  */
	    + 0xe0 /* Offset to .reg.  */);
  /* And the corresponding register buffers.  */
  gpregs = read_memory_unsigned_integer (regs, tdep->wordsize);
  fpregs = gpregs + 48 * tdep->wordsize;

  /* General purpose.  */
  for (i = 0; i < 32; i++)
    {
      int regnum = i + tdep->ppc_gp0_regnum;
      cache->saved_regs[regnum].addr = gpregs + i * tdep->wordsize;
    }
  cache->saved_regs[PC_REGNUM].addr = gpregs + 32 * tdep->wordsize;
  cache->saved_regs[tdep->ppc_ctr_regnum].addr = gpregs + 35 * tdep->wordsize;
  cache->saved_regs[tdep->ppc_lr_regnum].addr = gpregs + 36 * tdep->wordsize;
  cache->saved_regs[tdep->ppc_xer_regnum].addr = gpregs + 37 * tdep->wordsize;
  cache->saved_regs[tdep->ppc_cr_regnum].addr = gpregs + 38 * tdep->wordsize;

  /* Floating point registers.  */
  for (i = 0; i < 32; i++)
    {
      int regnum = i + FP0_REGNUM;
      cache->saved_regs[regnum].addr = fpregs + i * tdep->wordsize;
    }
  cache->saved_regs[tdep->ppc_fpscr_regnum].addr = fpregs + 32 * tdep->wordsize;

  return cache;
}

static void
ppc_linux_sigtramp_this_id (struct frame_info *next_frame, void **this_cache,
			  struct frame_id *this_id)
{
  struct ppc_linux_sigtramp_cache *info
    = ppc_linux_sigtramp_cache (next_frame, this_cache);
  (*this_id) = frame_id_build (info->base, frame_pc_unwind (next_frame));
}

static void
ppc_linux_sigtramp_prev_register (struct frame_info *next_frame,
				void **this_cache,
				int regnum, int *optimizedp,
				enum lval_type *lvalp, CORE_ADDR *addrp,
				int *realnump, void *valuep)
{
  struct ppc_linux_sigtramp_cache *info
    = ppc_linux_sigtramp_cache (next_frame, this_cache);
  trad_frame_prev_register (next_frame, info->saved_regs, regnum,
			    optimizedp, lvalp, addrp, realnump, valuep);
}

static const struct frame_unwind ppc_linux_sigtramp_unwind =
{
  SIGTRAMP_FRAME,
  ppc_linux_sigtramp_this_id,
  ppc_linux_sigtramp_prev_register
};

static const struct frame_unwind *
ppc_linux_sigtramp_sniffer (struct frame_info *next_frame)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (get_frame_arch (next_frame));
  if (frame_pc_unwind (next_frame)
      > frame_unwind_register_unsigned (next_frame, SP_REGNUM))
    /* Assume anything that is vaguely on the stack is a signal
       trampoline.  */
    return &ppc_linux_sigtramp_unwind;
  else
    return NULL;
}

static void
ppc64_linux_supply_gregset (const struct regset *regset,
			    struct regcache * regcache,
			    int regnum, const void *gregs, size_t size)
{
  ppc_linux_supply_gregset (regcache, regnum, gregs, size, 8);
}

static struct regset ppc64_linux_gregset = {
  NULL, ppc64_linux_supply_gregset
};

d987 1
a987 3
ppc_linux_supply_fpregset (const struct regset *regset,
			   struct regcache * regcache,
			   int regnum, const void *fpset, size_t size)
d990 1
a990 3
  struct gdbarch *regcache_arch = get_regcache_arch (regcache); 
  struct gdbarch_tdep *regcache_tdep = gdbarch_tdep (regcache_arch);
  const bfd_byte *buf = fpset;
d993 1
a993 1
    regcache_raw_supply (regcache, FP0_REGNUM + regi, buf + 8 * regi);
d997 1
a997 2
  regcache_raw_supply (regcache, regcache_tdep->ppc_fpscr_regnum,
		       buf + 8 * 32 + 4);
d1000 3
a1002 1
static struct regset ppc_linux_fpregset = { NULL, ppc_linux_supply_fpregset };
d1004 5
a1008 3
static const struct regset *
ppc_linux_regset_from_core_section (struct gdbarch *core_arch,
				    const char *sect_name, size_t sect_size)
d1010 8
a1017 2
  struct gdbarch_tdep *tdep = gdbarch_tdep (core_arch);
  if (strcmp (sect_name, ".reg") == 0)
d1019 2
a1020 2
      if (tdep->wordsize == 4)
	return &ppc32_linux_gregset;
d1022 1
a1022 1
	return &ppc64_linux_gregset;
a1023 3
  if (strcmp (sect_name, ".reg2") == 0)
    return &ppc_linux_fpregset;
  return NULL;
d1026 12
d1193 11
a1205 1

a1234 2
  set_gdbarch_regset_from_core_section (gdbarch, ppc_linux_regset_from_core_section);
  frame_unwind_append_sniffer (gdbarch, ppc_linux_sigtramp_sniffer);
d1248 1
@


1.49
log
@2003-11-13  Andrew Cagney  <cagney@@redhat.com>

	* ppc-linux-tdep.c (ppc_linux_init_abi): Set PPC64's
	"name_of_malloc" to ".malloc".
@
text
@d1056 1
a1056 2
      set_gdbarch_frameless_function_invocation (gdbarch,
        ppc_linux_frameless_function_invocation);
@


1.48
log
@2003-11-13  Andrew Cagney  <cagney@@redhat.com>

	* ppc-linux-tdep.c (ppc_linux_return_value): Fix parameter order.
@
text
@d1086 3
@


1.47
log
@2003-11-07  Andrew Cagney  <cagney@@redhat.com>

	* ppc-linux-tdep.c (ppc_linux_init_abi): When 32-bit GNU/Linux,
	set "return_value" instead of "use_struct_convention".
	(ppc_linux_use_struct_convention): Delete function.
	(ppc_linux_return_value): New function.
	* ppc-sysv-tdep.c (ppc_sysv_abi_return_value): New function.
	(ppc_sysv_abi_broken_return_value): New function.
	(do_ppc_sysv_return_value): Add "gdbarch" parameter.
	(ppc64_sysv_abi_push_dummy_call): Add "gdbarch" parameter, drop
	static.
	(ppc_sysv_abi_extract_return_value): Delete function.
	(ppc_sysv_abi_broken_extract_return_value): Delete function.
	(ppc_sysv_abi_store_return_value): Delete function.
	(ppc_sysv_abi_broken_store_return_value): Delete function.
	(ppc_sysv_abi_use_struct_convention): Delete function.
	(ppc64_sysv_abi_use_struct_convention): Delete function.
	(ppc64_sysv_abi_extract_return_value): Delete function.
	(ppc64_sysv_abi_store_return_value): Delete function.
	* ppcnbsd-tdep.c (ppcnbsd_return_value): New function.
	(ppcnbsd_init_abi): Set "return_value", instead of
	"use_struct_convention", "extract_return_value", and
	"store_return_value".
	(ppcnbsd_use_struct_convention): Delete function.
	* ppc-tdep.h (ppc64_sysv_abi_return_value): Declare.
	(ppc_sysv_abi_return_value): Declare.
	(ppc_sysv_abi_broken_return_value): Declare.
	(ppc_sysv_abi_use_struct_convention): Delete.
	(ppc_sysv_abi_store_return_value): Delete.
	(ppc_sysv_abi_extract_return_value): Delete.
	(ppc_sysv_abi_broken_store_return_value): Delete.
	(ppc_sysv_abi_broken_extract_return_value): Delete.
	(ppc64_sysv_abi_use_struct_convention): Delete.
	(ppc64_sysv_abi_extract_return_value): Delete.
	(ppc64_sysv_abi_store_return_value): Delete.
	* rs6000-tdep.c (rs6000_gdbarch_init): For 32-bit and 64-bit SYSV,
	set "return_value" instead of "extract_return_value",
	"store_return_value", and "use_struct_convention".
@
text
@d601 2
a602 1
			struct regcache *regcache, const void *inval, void *outval)
d610 2
a611 1
    return ppc_sysv_abi_return_value (gdbarch, valtype, regcache, inval, outval);
@


1.46
log
@2003-10-29  Andrew Cagney  <cagney@@redhat.com>

	* ppc-linux-tdep.c (_initialize_ppc_linux_tdep): Instead of the
	default PPC machine, register 32-bit and 64-bit PPC, and rs6k.
@
text
@d599 3
a601 2
static int     
ppc_linux_use_struct_convention (int gcc_p, struct type *value_type)
d603 7
a609 4
  if ((TYPE_LENGTH (value_type) == 16 || TYPE_LENGTH (value_type) == 8)
      && TYPE_VECTOR (value_type))
    return 0;                            
  return 1;
d1050 1
a1050 1
      set_gdbarch_use_struct_convention (gdbarch, ppc_linux_use_struct_convention);
@


1.45
log
@2003-10-24  Andrew Cagney  <cagney@@redhat.com>

	* target.c: Include "gdbcore.h".
	(get_target_memory, get_target_memory_unsigned): New functions.
	* target.h (get_target_memory, get_target_memory_unsigned): Declare.
	* ppc-linux-tdep.c (ppc64_linux_convert_from_func_ptr_addr):
	Use get_target_memory_unsigned.
	* Makefile.in (target.o): Update dependencies.
@
text
@d1086 8
a1093 2
  gdbarch_register_osabi (bfd_arch_powerpc, 0, GDB_OSABI_LINUX,
			  ppc_linux_init_abi);
@


1.44
log
@2003-10-22  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (convert_from_func_ptr_addr): Convert to a pure
	multi-arch method, add "targ" parameter.
	(struct target_ops): Declare.
	* gdbarch.h, gdbarch.c: Re-generate.
	* Makefile.in (c-valprint.o): Update dependencies.
	* arch-utils.h: Update copyright.
	(convert_from_func_ptr_addr_identity): Declare.
	* arch-utils.c (convert_from_func_ptr_addr_identity): New function.
	* ia64-tdep.c (ia64_convert_from_func_ptr_addr): Update.
	* rs6000-tdep.c (rs6000_convert_from_func_ptr_addr): Upate.
	* ppc-linux-tdep.c (ppc64_linux_convert_from_func_ptr_addr): Update.
	* infcall.c (find_function_addr, call_function_by_hand): Update.
	* c-valprint.c: Include "target.h".
	(print_function_pointer_address): Update.
@
text
@d939 1
a939 3
  struct obj_section *s;

  s = find_pc_section (addr);
d943 1
a943 1
    return read_memory_unsigned_integer (addr, 8);
@


1.43
log
@2003-10-21  Elena Zannoni  <ezannoni@@redhat.com>

	* minsyms.c (lookup_minimal_symbol_text): Remove unused parameter.
	Remove SOFUN_ADDRESS_MAYBE_MISSING ifdeffed code.
	* symtab.h (lookup_minimal_symbol_text): Update.
 	* breakpoint.c (create_overlay_event_breakpoint,
 	create_longjmp_breakpoint): Update callers.
	* ppc-linux-tdep.c (ppc_linux_skip_trampoline_code): Update caller.
	* symtab.c (find_pc_sect_line): Ditto.
@
text
@d911 2
a912 1
/* Support for CONVERT_FROM_FUNC_PTR_ADDR(ADDR) on PPC64 GNU/Linux.
d935 3
a937 1
ppc64_linux_convert_from_func_ptr_addr (CORE_ADDR addr)
@


1.42
log
@2003-10-03  Andrew Cagney  <cagney@@redhat.com>

	* ppc-linux-tdep.c (ppc64_linux_convert_from_func_ptr_addr): Only
	convert a descriptor to a function when it's in the ".opd"
	section.
@
text
@d334 1
a334 1
  msymbol = lookup_minimal_symbol_text (symname, NULL, NULL);
@


1.41
log
@2003-09-25  Andrew Cagney  <cagney@@redhat.com>

	* frame.h (deprecated_frame_saved_regs): Rename
	get_frame_saved_regs.
	* cris-tdep.c, frame.c, h8300-tdep.c, hppa-tdep.c: Update.
	* mcore-tdep.c, mips-tdep.c, mn10300-tdep.c: Update.
	* ns32k-tdep.c, ppc-linux-tdep.c, rs6000-tdep.c: Update.
	* s390-tdep.c, sh64-tdep.c, stack.c: Update.
	* v850-tdep.c, vax-tdep.c, xstormy16-tdep.c: Update.
@
text
@d928 4
a931 2
/* Return real function address if ADDR (a function pointer) is in the data
   space and is therefore a special function pointer.  */
a938 2
  if (s && s->the_bfd_section->flags & SEC_CODE)
    return addr;
d940 5
a944 3
  /* ADDR is in the data space, so it's a pointer to a descriptor, not
     the entry point.  */
  return ppc64_desc_entry_point (addr);
@


1.40
log
@2003-09-16  Andrew Cagney  <cagney@@redhat.com>

	* ppc-linux-tdep.c (ppc_linux_init_abi): Set the 32 bit
	"use_struct_convention" to "ppc_linux_use_struct_convention".
	(ppc_linux_use_struct_convention): New function.
	* rs6000-tdep.c (rs6000_use_struct_convention): New function.
	(rs6000_gdbarch_init): For AIX, set "use_struct_convention" to
	"rs6000_use_struct_convention".
	* ppc-tdep.h (ppc_sysv_abi_broken_use_struct_convention): Delete
	declaration.
	* ppc-sysv-tdep.c (ppc_sysv_abi_broken_use_struct_convention):
	Delete function.
@
text
@d405 1
a405 1
      if (get_frame_saved_regs (fi))
d413 2
a414 2
      get_frame_saved_regs (fi)[PC_REGNUM] = regs_addr + 4 * PPC_LINUX_PT_NIP;
      get_frame_saved_regs (fi)[gdbarch_tdep (current_gdbarch)->ppc_ps_regnum] =
d416 1
a416 1
      get_frame_saved_regs (fi)[gdbarch_tdep (current_gdbarch)->ppc_cr_regnum] =
d418 1
a418 1
      get_frame_saved_regs (fi)[gdbarch_tdep (current_gdbarch)->ppc_lr_regnum] =
d420 1
a420 1
      get_frame_saved_regs (fi)[gdbarch_tdep (current_gdbarch)->ppc_ctr_regnum] =
d422 1
a422 1
      get_frame_saved_regs (fi)[gdbarch_tdep (current_gdbarch)->ppc_xer_regnum] =
d424 1
a424 1
      get_frame_saved_regs (fi)[gdbarch_tdep (current_gdbarch)->ppc_mq_regnum] =
d427 1
a427 1
	get_frame_saved_regs (fi)[gdbarch_tdep (current_gdbarch)->ppc_gp0_regnum + i] =
d430 1
a430 1
	get_frame_saved_regs (fi)[FP0_REGNUM + i] = regs_addr + 4 * PPC_LINUX_PT_FPR0 + 8 * i;
@


1.39
log
@2003-09-08  Andrew Cagney  <cagney@@redhat.com>

	* gnu-nat.c: Remove "inline" function attribute.
	* alpha-tdep.c, ppc-linux-tdep.c, macroexp.c: Ditto.
@
text
@d594 14
a1033 7
  /* Until November 2001, gcc was not complying to the SYSV ABI for
     returning structures less than or equal to 8 bytes in size. It was
     returning everything in memory. When this was corrected, it wasn't
     fixed for native platforms.  */
  set_gdbarch_use_struct_convention (gdbarch,
                                   ppc_sysv_abi_broken_use_struct_convention);

d1036 9
@


1.38
log
@2003-08-27  Andrew Cagney  <cagney@@redhat.com>

	* ppc-linux-tdep.c (ppc64_call_dummy_address): Delete function.
	(ppc_linux_init_abi): For PPC64, do not set call_dummy_address.
	* infcall.c (call_function_by_hand): Convert the entry point
	address into a code address.
@
text
@d191 1
a191 1
static inline int
@


1.37
log
@* ppc-linux-tdep.c: More "Linux" -> "GNU/Linux".
@
text
@a931 12
/* On 64-bit PowerPC GNU/Linux, the ELF header's e_entry field is the
   address of a function descriptor for the entry point function, not
   the actual entry point itself.  So to find the actual address at
   which execution should begin, we need to fetch the function's entry
   point from that descriptor.  */
static CORE_ADDR
ppc64_call_dummy_address (void)
{
  return ppc64_desc_entry_point (entry_point_address ());
}


a1056 2

      set_gdbarch_call_dummy_address (gdbarch, ppc64_call_dummy_address);
@


1.36
log
@* ppc-linux-tdep.c (ppc64_linux_convert_from_func_ptr_addr): New
function.
(ppc_linux_init_abi): Register it as the
CONVERT_FROM_FUNC_PTR_ADDR method under the PPC64 Linux ABI.
@
text
@d734 1
a734 1
/* If DESC is the address of a 64-bit PowerPC Linux function
d897 1
a897 1
/* Support for CONVERT_FROM_FUNC_PTR_ADDR(ADDR) on PPC64 Linux.
d900 13
a912 13
   of the function. On Linux on the 64-bit PowerPC however, a function
   pointer is represented by a pointer to a TOC entry. This TOC entry
   contains three words, the first word is the address of the
   function, the second word is the TOC pointer (r2), and the third
   word is the static chain value.  Throughout GDB it is currently
   assumed that a function pointer contains the address of the
   function, which is not easy to fix.  In addition, the conversion of
   a function address to a function pointer would require allocation
   of a TOC entry in the inferior's memory space, with all its
   drawbacks.  To be able to call C++ virtual methods in the inferior
   (which are called via function pointers), find_function_addr uses
   this function to get the function address from a function
   pointer.  */
d932 1
a932 1
/* On 64-bit PowerPC Linux, the ELF header's e_entry field is the
d1065 1
a1065 1
      /* Handle PPC64 Linux function pointers (which are really
@


1.35
log
@* ppc-linux-tdep.c (ppc64_call_dummy_address): New function.
(ppc_linux_init_abi): Set it as the gdbarch's call_dummy_address
method.
@
text
@d897 35
d1065 5
@


1.34
log
@* ppc-linux-tdep.c (ppc64_desc_entry_point): New function.
(ppc64_standard_linkage_target): Use it.
@
text
@d897 12
d1030 2
@


1.33
log
@* ppc-linux-tdep.c: "Linux" -> "GNU/Linux"
@
text
@d734 10
d878 1
a878 1
  return (CORE_ADDR) read_memory_unsigned_integer (desc, 8);
@


1.33.2.1
log
@* ppc-linux-tdep.c (ppc64_desc_entry_point): New function.
(ppc64_standard_linkage_target): Use it.
@
text
@a733 10
/* If DESC is the address of a 64-bit PowerPC Linux function
   descriptor, return the descriptor's entry point.  */
static CORE_ADDR
ppc64_desc_entry_point (CORE_ADDR desc)
{
  /* The first word of the descriptor is the entry point.  */
  return (CORE_ADDR) read_memory_unsigned_integer (desc, 8);
}


d868 1
a868 1
  return ppc64_desc_entry_point (desc);
@


1.33.2.2
log
@* ppc-linux-tdep.c (ppc64_call_dummy_address): New function.
(ppc_linux_init_abi): Set it as the gdbarch's call_dummy_address
method.
@
text
@a896 12
/* On 64-bit PowerPC Linux, the ELF header's e_entry field is the
   address of a function descriptor for the entry point function, not
   the actual entry point itself.  So to find the actual address at
   which execution should begin, we need to fetch the function's entry
   point from that descriptor.  */
static CORE_ADDR
ppc64_call_dummy_address (void)
{
  return ppc64_desc_entry_point (entry_point_address ());
}


a1017 2
      set_gdbarch_call_dummy_address (gdbarch, ppc64_call_dummy_address);

@


1.33.2.3
log
@* ppc-linux-tdep.c (ppc64_linux_convert_from_func_ptr_addr): New
function.
(ppc_linux_init_abi): Register it as the
CONVERT_FROM_FUNC_PTR_ADDR method under the PPC64 Linux ABI.
@
text
@a896 35
/* Support for CONVERT_FROM_FUNC_PTR_ADDR(ADDR) on PPC64 Linux.

   Usually a function pointer's representation is simply the address
   of the function. On Linux on the 64-bit PowerPC however, a function
   pointer is represented by a pointer to a TOC entry. This TOC entry
   contains three words, the first word is the address of the
   function, the second word is the TOC pointer (r2), and the third
   word is the static chain value.  Throughout GDB it is currently
   assumed that a function pointer contains the address of the
   function, which is not easy to fix.  In addition, the conversion of
   a function address to a function pointer would require allocation
   of a TOC entry in the inferior's memory space, with all its
   drawbacks.  To be able to call C++ virtual methods in the inferior
   (which are called via function pointers), find_function_addr uses
   this function to get the function address from a function
   pointer.  */

/* Return real function address if ADDR (a function pointer) is in the data
   space and is therefore a special function pointer.  */

static CORE_ADDR
ppc64_linux_convert_from_func_ptr_addr (CORE_ADDR addr)
{
  struct obj_section *s;

  s = find_pc_section (addr);
  if (s && s->the_bfd_section->flags & SEC_CODE)
    return addr;

  /* ADDR is in the data space, so it's a pointer to a descriptor, not
     the entry point.  */
  return ppc64_desc_entry_point (addr);
}


a1029 5
      /* Handle PPC64 Linux function pointers (which are really
         function descriptors).  */
      set_gdbarch_convert_from_func_ptr_addr
        (gdbarch, ppc64_linux_convert_from_func_ptr_addr);

@


1.33.2.4
log
@* ppc-linux-tdep.c: More "Linux" -> "GNU/Linux".
@
text
@d734 1
a734 1
/* If DESC is the address of a 64-bit PowerPC GNU/Linux function
d897 1
a897 1
/* Support for CONVERT_FROM_FUNC_PTR_ADDR(ADDR) on PPC64 GNU/Linux.
d900 13
a912 13
   of the function. On GNU/Linux on the 64-bit PowerPC however, a
   function pointer is represented by a pointer to a TOC entry. This
   TOC entry contains three words, the first word is the address of
   the function, the second word is the TOC pointer (r2), and the
   third word is the static chain value.  Throughout GDB it is
   currently assumed that a function pointer contains the address of
   the function, which is not easy to fix.  In addition, the
   conversion of a function address to a function pointer would
   require allocation of a TOC entry in the inferior's memory space,
   with all its drawbacks.  To be able to call C++ virtual methods in
   the inferior (which are called via function pointers),
   find_function_addr uses this function to get the function address
   from a function pointer.  */
d932 1
a932 1
/* On 64-bit PowerPC GNU/Linux, the ELF header's e_entry field is the
d1065 1
a1065 1
      /* Handle PPC64 GNU/Linux function pointers (which are really
@


1.32
log
@Recognize and skip 64-bit PowerPC Linux linkage functions.
* ppc-linux-tdep.c (insn_d, insn_ds, insn_xfx, read_insn, struct
insn_pattern, insns_match_pattern, d_field, ds_field): New
functions, macros, and types for working with PPC instructions.
(ppc64_standard_linkage, PPC64_STANDARD_LINKAGE_LEN,
ppc64_in_solib_call_trampoline, ppc64_standard_linkage_target,
ppc64_skip_trampoline_code): New functions, variables, and macros
for recognizing and skipping linkage functions.
(ppc_linux_init_abi): Use ppc64_in_solib_call_trampoline and
ppc64_skip_trampoline_code for the 64-bit PowerPC Linux ABI.
@
text
@d773 1
a773 1
/* Recognize a 64-bit PowerPC Linux linkage function --- what GDB
d778 1
a778 1
  /* Detecting solib call trampolines on PPC64 Linux is a pain.
d790 1
a790 1
     The 64-bit PowerPC Linux ABI calls these call trampolines
@


1.32.2.1
log
@* ppc-linux-tdep.c (ppc64_desc_entry_point): New function.
(ppc64_standard_linkage_target): Use it.
@
text
@a733 10
/* If DESC is the address of a 64-bit PowerPC Linux function
   descriptor, return the descriptor's entry point.  */
static CORE_ADDR
ppc64_desc_entry_point (CORE_ADDR desc)
{
  /* The first word of the descriptor is the entry point.  */
  return (CORE_ADDR) read_memory_unsigned_integer (desc, 8);
}


d868 1
a868 1
  return ppc64_desc_entry_point (desc);
@


1.32.2.2
log
@* ppc-linux-tdep.c (ppc64_call_dummy_address): New function.
(ppc_linux_init_abi): Set it as the gdbarch's call_dummy_address
method.
@
text
@a896 12
/* On 64-bit PowerPC Linux, the ELF header's e_entry field is the
   address of a function descriptor for the entry point function, not
   the actual entry point itself.  So to find the actual address at
   which execution should begin, we need to fetch the function's entry
   point from that descriptor.  */
static CORE_ADDR
ppc64_call_dummy_address (void)
{
  return ppc64_desc_entry_point (entry_point_address ());
}


a1017 2
      set_gdbarch_call_dummy_address (gdbarch, ppc64_call_dummy_address);

@


1.32.2.3
log
@* ppc-linux-tdep.c (ppc64_linux_convert_from_func_ptr_addr): New
function.
(ppc_linux_init_abi): Register it as the
CONVERT_FROM_FUNC_PTR_ADDR method under the PPC64 Linux ABI.
@
text
@a896 35
/* Support for CONVERT_FROM_FUNC_PTR_ADDR(ADDR) on PPC64 Linux.

   Usually a function pointer's representation is simply the address
   of the function. On Linux on the 64-bit PowerPC however, a function
   pointer is represented by a pointer to a TOC entry. This TOC entry
   contains three words, the first word is the address of the
   function, the second word is the TOC pointer (r2), and the third
   word is the static chain value.  Throughout GDB it is currently
   assumed that a function pointer contains the address of the
   function, which is not easy to fix.  In addition, the conversion of
   a function address to a function pointer would require allocation
   of a TOC entry in the inferior's memory space, with all its
   drawbacks.  To be able to call C++ virtual methods in the inferior
   (which are called via function pointers), find_function_addr uses
   this function to get the function address from a function
   pointer.  */

/* Return real function address if ADDR (a function pointer) is in the data
   space and is therefore a special function pointer.  */

static CORE_ADDR
ppc64_linux_convert_from_func_ptr_addr (CORE_ADDR addr)
{
  struct obj_section *s;

  s = find_pc_section (addr);
  if (s && s->the_bfd_section->flags & SEC_CODE)
    return addr;

  /* ADDR is in the data space, so it's a pointer to a descriptor, not
     the entry point.  */
  return ppc64_desc_entry_point (addr);
}


a1029 5
      /* Handle PPC64 Linux function pointers (which are really
         function descriptors).  */
      set_gdbarch_convert_from_func_ptr_addr
        (gdbarch, ppc64_linux_convert_from_func_ptr_addr);

@


1.32.2.4
log
@* ppc-linux-tdep.c (ppc64_linux_bfd_entry_point): New function.
(ppc_linux_init_abi): Register it as our bfd_entry_point method.
@
text
@a943 46
/* Return the unrelocated code address at which execution begins for
   ABFD, under the 64-bit PowerPC Linux ABI.

   On that system, the ELF header's e_entry field (which is what
   bfd_get_start_address gives you) is not the address of the actual
   machine instruction you need to jump to, as it is on almost every
   other target.  Instead, it's the address of a function descriptor
   for the start function.  A function descriptor is a structure
   containing three addresses: the entry point, the TOC pointer for
   the function, and an environment pointer for the function.  The
   first field is what we want to return.

   So all we do is find the section containing the start address, read
   the address-sized word there out of the BFD, and return that.  */
static CORE_ADDR
ppc64_linux_bfd_entry_point (struct gdbarch *gdbarch, bfd *abfd)
{
  CORE_ADDR start_address = bfd_get_start_address (abfd);
  CORE_ADDR addr_size = (bfd_arch_bits_per_address (abfd)
                         / bfd_arch_bits_per_byte (abfd));
  unsigned char *entry_pt_buf = alloca (addr_size);
  asection *sec;

  /* Find a data section containing an address word at the start
     address.  */
  for (sec = abfd->sections; sec; sec = sec->next)
    if (bfd_get_section_vma (sec) <= start_address
        && ((start_address + addr_size)
            <= (bfd_get_section_vma (sec) + bfd_section_size (sec))))
      break;
  if (! sec)
    return 0;

  /* Seek to the start address, and read the address word there.  */
  if (bfd_seek (abfd, 
                sec->filepos + (start_address - bfd_get_section_vma (sec)),
                SEEK_SET)
      || bfd_bread (entry_pt_buf, addr_size, abfd) != addr_size)
    return 0;
      
  /* That's the actual code entry point.  */
  return (CORE_ADDR) bfd_get (bfd_arch_bits_per_address (abfd),
                              abfd, entry_pt_buf);
}


a1074 2
      
      set_gdbarch_bfd_entry_point (gdbarch, ppc64_linux_bfd_entry_point);
@


1.32.2.5
log
@Revert patch for revision.
@
text
@d944 46
d1121 2
@


1.32.2.6
log
@* ppc-linux-tdep.c (ppc64_linux_bfd_entry_point): New function.
(ppc_linux_init_abi): Register it as our bfd_entry_point method.
@
text
@a943 54
/* Return the unrelocated code address at which execution begins for
   ABFD, under the 64-bit PowerPC Linux ABI.

   On that system, the ELF header's e_entry field (which is what
   bfd_get_start_address gives you) is not the address of the actual
   machine instruction you need to jump to, as it is on almost every
   other target.  Instead, it's the address of a function descriptor
   for the start function.  A function descriptor is a structure
   containing three addresses: the entry point, the TOC pointer for
   the function, and an environment pointer for the function.  The
   first field is what we want to return.

   So all we do is find the section containing the start address, read
   the address-sized word there out of the BFD, and return that.  */
static CORE_ADDR
ppc64_linux_bfd_entry_point (struct gdbarch *gdbarch, bfd *abfd)
{
  bfd_vma start_address = bfd_get_start_address (abfd);
  unsigned int addr_size = (bfd_arch_bits_per_address (abfd)
                            / bfd_arch_bits_per_byte (abfd));
  unsigned char *entry_pt_buf = alloca (addr_size);
  asection *sec;
  file_ptr desc_offset;

  /* Find a data section containing an address-sized word at
     start_address.  */
  for (sec = abfd->sections; sec; sec = sec->next)
    {
      CORE_ADDR sec_vma = bfd_get_section_vma (abfd, sec);
      CORE_ADDR sec_end_vma = sec_vma + bfd_section_size (abfd, sec);

      if (sec_vma <= start_address
          && start_address + addr_size <= sec_end_vma)
        break;
    }
  if (! sec)
    return 0;

  /* Okay, we've found the section.  What is the function descriptor's
     offset within that section?  */
  desc_offset = start_address - bfd_get_section_vma (abfd, sec);

  /* Seek to the descriptor, and read the first address-sized word it
     contains.  */
  if (bfd_seek (abfd, sec->filepos + desc_offset, SEEK_SET)
      || bfd_bread (entry_pt_buf, addr_size, abfd) != addr_size)
    return 0;
      
  /* That's the actual code entry point.  */
  return (CORE_ADDR) bfd_get (bfd_arch_bits_per_address (abfd),
                              abfd, entry_pt_buf);
}


a1074 2
      
      set_gdbarch_bfd_entry_point (gdbarch, ppc64_linux_bfd_entry_point);
@


1.31
log
@Actually finish the job started by my change of 2003-05-29.
* config/powerpc/tm-linux.h (SKIP_TRAMPOLINE_CODE): Remove the
other #definition of this.
(ppc_linux_skip_trampoline_code): Remove declaration.
* ppc-linux-tdep.c (ppc_linux_skip_trampoline_code): Make this
static.
(ppc_linux_init_abi): Register it as the skip_trampoline_code
method for GDBARCH.
@
text
@d635 252
d998 4
d1005 7
a1011 4

  /* Shared library handling.  */
  set_gdbarch_in_solib_call_trampoline (gdbarch, in_plt_section);
  set_gdbarch_skip_trampoline_code (gdbarch, ppc_linux_skip_trampoline_code);
@


1.30
log
@2003-06-01  Andrew Cagney  <cagney@@redhat.com>

	* defs.h (extract_address): Delete declaration.
	* findvar.c (extract_address): Delete function.
	* xstormy16-tdep.c (xstormy16_extract_return_value): Replace
	extract_address with the inline equivalent,
	extract_unsigned_integer.
	(xstormy16_extract_struct_value_address): Ditto.
	(xstormy16_pointer_to_address): Ditto.
	* vax-tdep.c (vax_extract_struct_value_address): Ditto.
	* v850-tdep.c (v850_push_arguments): Ditto.
	(v850_extract_return_value): Ditto.
	(v850_extract_struct_value_address): Ditto.
	* sparcnbsd-tdep.c (sparcnbsd_get_longjmp_target_32): Ditto.
	(sparcnbsd_get_longjmp_target_64): Ditto.
	* sparc-tdep.c (sparc_frame_saved_pc): Ditto.
	(get_longjmp_target): Ditto.
	* sh-tdep.c (sh_extract_struct_value_address): Ditto.
	(sh64_extract_struct_value_address): Ditto.
	(sh_push_arguments): Ditto.
	(sh64_push_arguments): Ditto.
	* remote-vxsparc.c (vx_read_register): Ditto.
	* ppc-linux-tdep.c (ppc_linux_skip_trampoline_code): Ditto.
	* ns32k-tdep.c (ns32k_extract_struct_value_address): Ditto.
	* mn10300-tdep.c (mn10300_extract_struct_value_address): Ditto.
	* mipsv4-nat.c (get_longjmp_target): Ditto.
	* mipsnbsd-tdep.c (mipsnbsd_get_longjmp_target): Ditto.
	* mips-nat.c (get_longjmp_target): Ditto.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target): Ditto.
	* mcore-tdep.c (mcore_extract_struct_value_address): Ditto.
	* m68k-tdep.c (m68k_get_longjmp_target): Ditto.
	* m68hc11-tdep.c (m68hc11_extract_struct_value_address): Ditto.
	* irix5-nat.c (get_longjmp_target): Ditto.
	* irix4-nat.c (get_longjmp_target): Ditto.
	* ia64-tdep.c (generic_elf_find_global_pointer): Ditto.
	(ia64_push_arguments): Ditto.
	* hpux-thread.c (hpux_thread_store_registers): Ditto.
	* h8300-tdep.c (h8300_push_arguments): Ditto.
	(h8300_store_return_value): Ditto.
	(h8300_extract_struct_value_address): Ditto.
	* frv-tdep.c (frv_extract_struct_value_address): Ditto.
	(frv_push_arguments): Ditto.
	* avr-tdep.c (avr_pointer_to_address): Ditto.
	(avr_push_arguments): Ditto.
	* arm-tdep.c (arm_push_dummy_call): Ditto.
	(arm_get_longjmp_target): Ditto.
	* arm-linux-tdep.c (arm_linux_push_arguments): Ditto.
	* alpha-tdep.c (alpha_extract_struct_value_address): Ditto.
	(alpha_get_longjmp_target): Ditto.
@
text
@d232 1
a232 1
CORE_ADDR
d752 1
a752 1
  set_gdbarch_skip_trampoline_code (gdbarch, find_solib_trampoline_target);
@


1.29
log
@Use gdbarch methods for solib stuff on PowerPC Linux.
* config/powerpc/tm-linux.h (IN_SOLIB_CALL_TRAMPOLINE,
SKIP_TRAMPOLINE_CODE): #undef these, so the gdbarch methods will
show through.
* ppc-linux-tdep.c (ppc_linux_init_abi): Register
IN_SOLIB_CALL_TRAMPOLINE and SKIP_TRAMPOLINE_CODE methods here,
giving the same effect as the #definitions above.
@
text
@d298 1
a298 1
  reloc = extract_address (buf, 4);
@


1.28
log
@2003-04-13  Andrew Cagney  <cagney@@redhat.com>

	* ppc-linux-tdep.c: Use get_frame_base, get_frame_pc,
	get_next_frame and get_frame_saved_regs.
@
text
@d749 4
@


1.28.8.1
log
@Use gdbarch methods for solib stuff on PowerPC Linux.
* config/powerpc/tm-linux.h (IN_SOLIB_CALL_TRAMPOLINE,
SKIP_TRAMPOLINE_CODE): #undef these, so the gdbarch methods will
show through.
* ppc-linux-tdep.c (ppc_linux_init_abi): Register
IN_SOLIB_CALL_TRAMPOLINE and SKIP_TRAMPOLINE_CODE methods here,
giving the same effect as the #definitions above.
@
text
@a748 4

  /* Shared library handling.  */
  set_gdbarch_in_solib_call_trampoline (gdbarch, in_plt_section);
  set_gdbarch_skip_trampoline_code (gdbarch, find_solib_trampoline_target);
@


1.28.8.2
log
@Revert patch for revision.
@
text
@d749 4
@


1.28.8.3
log
@Use gdbarch methods for solib stuff on PowerPC Linux.
* config/powerpc/tm-linux.h (IN_SOLIB_CALL_TRAMPOLINE,
SKIP_TRAMPOLINE_CODE): #undef these, so the gdbarch methods will
show through.  Remove later #definition of SKIP_TRAMPOLINE_CODE.
(ppc_linux_skip_trampoline_code): Delete declaration.
* ppc-linux-tdep.c (ppc_linux_init_abi): Register
IN_SOLIB_CALL_TRAMPOLINE and SKIP_TRAMPOLINE_CODE methods here,
giving the same effect as the #definitions above.
(ppc_linux_skip_trampoline_code): Make this static.
@
text
@d232 1
a232 1
static CORE_ADDR
a748 4

  /* Shared library handling.  */
  set_gdbarch_in_solib_call_trampoline (gdbarch, in_plt_section);
  set_gdbarch_skip_trampoline_code (gdbarch, ppc_linux_skip_trampoline_code);
@


1.28.8.4
log
@Recognize and skip 64-bit PowerPC Linux linkage functions.
* ppc-linux-tdep.c (insn_d, insn_ds, insn_xfx, read_insn, struct
insn_pattern, insns_match_pattern, d_field, ds_field): New
functions, macros, and types for working with PPC instructions.
(ppc64_standard_linkage, PPC64_STANDARD_LINKAGE_LEN,
ppc64_in_solib_call_trampoline, ppc64_standard_linkage_target,
ppc64_skip_trampoline_code): New functions, variables, and macros
for recognizing and skipping linkage functions.
(ppc_linux_init_abi): Use ppc64_in_solib_call_trampoline and
ppc64_skip_trampoline_code for the 64-bit PowerPC Linux ABI.

Use gdbarch methods for solib stuff on PowerPC Linux.
* config/powerpc/tm-linux.h (IN_SOLIB_CALL_TRAMPOLINE,
SKIP_TRAMPOLINE_CODE): #undef these, so the gdbarch methods will
show through.  Remove later #definition of SKIP_TRAMPOLINE_CODE.
(ppc_linux_skip_trampoline_code): Delete declaration.
* ppc-linux-tdep.c (ppc_linux_init_abi): Register
IN_SOLIB_CALL_TRAMPOLINE and SKIP_TRAMPOLINE_CODE methods here,
giving the same effect as the #definitions above.
(ppc_linux_skip_trampoline_code): Make this static.
@
text
@a634 251

/* Macros for matching instructions.  Note that, since all the
   operands are masked off before they're or-ed into the instruction,
   you can use -1 to make masks.  */

#define insn_d(opcd, rts, ra, d)                \
  ((((opcd) & 0x3f) << 26)                      \
   | (((rts) & 0x1f) << 21)                     \
   | (((ra) & 0x1f) << 16)                      \
   | ((d) & 0xffff))

#define insn_ds(opcd, rts, ra, d, xo)           \
  ((((opcd) & 0x3f) << 26)                      \
   | (((rts) & 0x1f) << 21)                     \
   | (((ra) & 0x1f) << 16)                      \
   | ((d) & 0xfffc)                             \
   | ((xo) & 0x3))

#define insn_xfx(opcd, rts, spr, xo)            \
  ((((opcd) & 0x3f) << 26)                      \
   | (((rts) & 0x1f) << 21)                     \
   | (((spr) & 0x1f) << 16)                     \
   | (((spr) & 0x3e0) << 6)                     \
   | (((xo) & 0x3ff) << 1))

/* Read a PPC instruction from memory.  PPC instructions are always
   big-endian, no matter what endianness the program is running in, so
   we can't use read_memory_integer or one of its friends here.  */
static unsigned int
read_insn (CORE_ADDR pc)
{
  unsigned char buf[4];

  read_memory (pc, buf, 4);
  return (buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | buf[3];
}


/* An instruction to match.  */
struct insn_pattern
{
  unsigned int mask;            /* mask the insn with this... */
  unsigned int data;            /* ...and see if it matches this. */
  int optional;                 /* If non-zero, this insn may be absent.  */
};

/* Return non-zero if the instructions at PC match the series
   described in PATTERN, or zero otherwise.  PATTERN is an array of
   'struct insn_pattern' objects, terminated by an entry whose mask is
   zero.

   When the match is successful, fill INSN[i] with what PATTERN[i]
   matched.  If PATTERN[i] is optional, and the instruction wasn't
   present, set INSN[i] to -1.  INSN should have as many elements as
   PATTERN.  Note that, if PATTERN contains optional instructions
   which aren't present in memory, then INSN will have holes, so
   INSN[i] isn't necessarily the i'th instruction in memory.  */
static int
insns_match_pattern (CORE_ADDR pc,
                     struct insn_pattern *pattern,
                     unsigned int *insn)
{
  int i;

  for (i = 0; pattern[i].mask; i++)
    {
      insn[i] = read_insn (pc);
      if ((insn[i] & pattern[i].mask) == pattern[i].data)
        pc += 4;
      else if (pattern[i].optional)
        insn[i] = 0;
      else
        return 0;
    }

  return 1;
}


/* Return the 'd' field of the d-form instruction INSN, properly
   sign-extended.  */
static CORE_ADDR
insn_d_field (unsigned int insn)
{
  return ((((CORE_ADDR) insn & 0xffff) ^ 0x8000) - 0x8000);
}


/* Return the 'ds' field of the ds-form instruction INSN, with the two
   zero bits concatenated at the right, and properly
   sign-extended.  */
static CORE_ADDR
insn_ds_field (unsigned int insn)
{
  return ((((CORE_ADDR) insn & 0xfffc) ^ 0x8000) - 0x8000);
}


/* Pattern for the standard linkage function.  These are built by
   build_plt_stub in elf64-ppc.c, whose GLINK argument is always
   zero.  */
static struct insn_pattern ppc64_standard_linkage[] =
  {
    /* addis r12, r2, <any> */
    { insn_d (-1, -1, -1, 0), insn_d (15, 12, 2, 0), 0 },

    /* std r2, 40(r1) */
    { -1, insn_ds (62, 2, 1, 40, 0), 0 },

    /* ld r11, <any>(r12) */
    { insn_ds (-1, -1, -1, 0, -1), insn_ds (58, 11, 12, 0, 0), 0 },

    /* addis r12, r12, 1 <optional> */
    { insn_d (-1, -1, -1, -1), insn_d (15, 12, 2, 1), 1 },

    /* ld r2, <any>(r12) */
    { insn_ds (-1, -1, -1, 0, -1), insn_ds (58, 2, 12, 0, 0), 0 },

    /* addis r12, r12, 1 <optional> */
    { insn_d (-1, -1, -1, -1), insn_d (15, 12, 2, 1), 1 },

    /* mtctr r11 */
    { insn_xfx (-1, -1, -1, -1), insn_xfx (31, 11, 9, 467),
      0 },

    /* ld r11, <any>(r12) */
    { insn_ds (-1, -1, -1, 0, -1), insn_ds (58, 11, 12, 0, 0), 0 },
      
    /* bctr */
    { -1, 0x4e800420, 0 },

    { 0, 0, 0 }
  };
#define PPC64_STANDARD_LINKAGE_LEN \
  (sizeof (ppc64_standard_linkage) / sizeof (ppc64_standard_linkage[0]))


/* Recognize a 64-bit PowerPC Linux linkage function --- what GDB
   calls a "solib trampoline".  */
static int
ppc64_in_solib_call_trampoline (CORE_ADDR pc, char *name)
{
  /* Detecting solib call trampolines on PPC64 Linux is a pain.

     It's not specifically solib call trampolines that are the issue.
     Any call from one function to another function that uses a
     different TOC requires a trampoline, to save the caller's TOC
     pointer and then load the callee's TOC.  An executable or shared
     library may have more than one TOC, so even intra-object calls
     may require a trampoline.  Since executable and shared libraries
     will all have their own distinct TOCs, every inter-object call is
     also an inter-TOC call, and requires a trampoline --- so "solib
     call trampolines" are just a special case.

     The 64-bit PowerPC Linux ABI calls these call trampolines
     "linkage functions".  Since they need to be near the functions
     that call them, they all appear in .text, not in any special
     section.  The .plt section just contains an array of function
     descriptors, from which the linkage functions load the callee's
     entry point, TOC value, and environment pointer.  So
     in_plt_section is useless.  The linkage functions don't have any
     special linker symbols to name them, either.

     The only way I can see to recognize them is to actually look at
     their code.  They're generated by ppc_build_one_stub and some
     other functions in bfd/elf64-ppc.c, so that should show us all
     the instruction sequences we need to recognize.  */
  unsigned int insn[PPC64_STANDARD_LINKAGE_LEN];

  return insns_match_pattern (pc, ppc64_standard_linkage, insn);
}


/* When the dynamic linker is doing lazy symbol resolution, the first
   call to a function in another object will go like this:

   - The user's function calls the linkage function:

     100007c4:	4b ff fc d5 	bl	10000498
     100007c8:	e8 41 00 28 	ld	r2,40(r1)

   - The linkage function loads the entry point (and other stuff) from
     the function descriptor in the PLT, and jumps to it:

     10000498:	3d 82 00 00 	addis	r12,r2,0
     1000049c:	f8 41 00 28 	std	r2,40(r1)
     100004a0:	e9 6c 80 98 	ld	r11,-32616(r12)
     100004a4:	e8 4c 80 a0 	ld	r2,-32608(r12)
     100004a8:	7d 69 03 a6 	mtctr	r11
     100004ac:	e9 6c 80 a8 	ld	r11,-32600(r12)
     100004b0:	4e 80 04 20 	bctr

   - But since this is the first time that PLT entry has been used, it
     sends control to its glink entry.  That loads the number of the
     PLT entry and jumps to the common glink0 code:

     10000c98:	38 00 00 00 	li	r0,0
     10000c9c:	4b ff ff dc 	b	10000c78

   - The common glink0 code then transfers control to the dynamic
     linker's fixup code:

     10000c78:	e8 41 00 28 	ld	r2,40(r1)
     10000c7c:	3d 82 00 00 	addis	r12,r2,0
     10000c80:	e9 6c 80 80 	ld	r11,-32640(r12)
     10000c84:	e8 4c 80 88 	ld	r2,-32632(r12)
     10000c88:	7d 69 03 a6 	mtctr	r11
     10000c8c:	e9 6c 80 90 	ld	r11,-32624(r12)
     10000c90:	4e 80 04 20 	bctr

   Eventually, this code will figure out how to skip all of this,
   including the dynamic linker.  At the moment, we just get through
   the linkage function.  */

/* If the current thread is about to execute a series of instructions
   at PC matching the ppc64_standard_linkage pattern, and INSN is the result
   from that pattern match, return the code address to which the
   standard linkage function will send them.  (This doesn't deal with
   dynamic linker lazy symbol resolution stubs.)  */
static CORE_ADDR
ppc64_standard_linkage_target (CORE_ADDR pc, unsigned int *insn)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

  /* The address of the function descriptor this linkage function
     references.  */
  CORE_ADDR desc
    = ((CORE_ADDR) read_register (tdep->ppc_gp0_regnum + 2)
       + (insn_d_field (insn[0]) << 16)
       + insn_ds_field (insn[2]));

  /* The first word of the descriptor is the entry point.  Return that.  */
  return (CORE_ADDR) read_memory_unsigned_integer (desc, 8);
}


/* Given that we've begun executing a call trampoline at PC, return
   the entry point of the function the trampoline will go to.  */
static CORE_ADDR
ppc64_skip_trampoline_code (CORE_ADDR pc)
{
  unsigned int ppc64_standard_linkage_insn[PPC64_STANDARD_LINKAGE_LEN];

  if (insns_match_pattern (pc, ppc64_standard_linkage,
                           ppc64_standard_linkage_insn))
    return ppc64_standard_linkage_target (pc, ppc64_standard_linkage_insn);
  else
    return 0;
}


a745 4
      /* Shared library handling.  */
      set_gdbarch_in_solib_call_trampoline (gdbarch, in_plt_section);
      set_gdbarch_skip_trampoline_code (gdbarch,
                                        ppc_linux_skip_trampoline_code);
d749 4
a752 7
  
  if (tdep->wordsize == 8)
    {
      set_gdbarch_in_solib_call_trampoline
        (gdbarch, ppc64_in_solib_call_trampoline);
      set_gdbarch_skip_trampoline_code (gdbarch, ppc64_skip_trampoline_code);
    }
@


1.28.8.5
log
@* ppc-linux-tdep.c (ppc64_desc_entry_point): New function.
(ppc64_standard_linkage_target): Use it.
@
text
@a732 10
/* If DESC is the address of a 64-bit PowerPC Linux function
   descriptor, return the descriptor's entry point.  */
static CORE_ADDR
ppc64_desc_entry_point (CORE_ADDR desc)
{
  /* The first word of the descriptor is the entry point.  */
  return (CORE_ADDR) read_memory_unsigned_integer (desc, 8);
}


d867 1
a867 1
  return ppc64_desc_entry_point (desc);
@


1.28.8.6
log
@* ppc-linux-tdep.c (ppc64_call_dummy_address): New function.
(ppc_linux_init_abi): Set it as the gdbarch's call_dummy_address
method.
@
text
@a895 12
/* On 64-bit PowerPC Linux, the ELF header's e_entry field is the
   address of a function descriptor for the entry point function, not
   the actual entry point itself.  So to find the actual address at
   which execution should begin, we need to fetch the function's entry
   point from that descriptor.  */
static CORE_ADDR
ppc64_call_dummy_address (void)
{
  return ppc64_desc_entry_point (entry_point_address ());
}


a1016 2
      set_gdbarch_call_dummy_address (gdbarch, ppc64_call_dummy_address);

@


1.28.8.7
log
@Revert change for revision.
@
text
@d688 4
a691 5
   present, set INSN[i] to 0 (an invalid instruction on the PPC).
   INSN should have as many elements as PATTERN.  Note that, if
   PATTERN contains optional instructions which aren't present in
   memory, then INSN will have holes, so INSN[i] isn't necessarily the
   i'th instruction in memory.  */
d733 10
d877 1
a877 1
  return (CORE_ADDR) read_memory_unsigned_integer (desc, 8);
d896 12
d1029 2
@


1.28.8.8
log
@Finish the reversion.
@
text
@d998 4
d1005 7
a1011 4

  /* Shared library handling.  */
  set_gdbarch_in_solib_call_trampoline (gdbarch, in_plt_section);
  set_gdbarch_skip_trampoline_code (gdbarch, ppc_linux_skip_trampoline_code);
@


1.28.8.9
log
@*** empty log message ***
@
text
@d688 5
a692 4
   present, set INSN[i] to -1.  INSN should have as many elements as
   PATTERN.  Note that, if PATTERN contains optional instructions
   which aren't present in memory, then INSN will have holes, so
   INSN[i] isn't necessarily the i'th instruction in memory.  */
a733 10
/* If DESC is the address of a 64-bit PowerPC Linux function
   descriptor, return the descriptor's entry point.  */
static CORE_ADDR
ppc64_desc_entry_point (CORE_ADDR desc)
{
  /* The first word of the descriptor is the entry point.  */
  return (CORE_ADDR) read_memory_unsigned_integer (desc, 8);
}


d868 1
a868 1
  return ppc64_desc_entry_point (desc);
a886 12
/* On 64-bit PowerPC Linux, the ELF header's e_entry field is the
   address of a function descriptor for the entry point function, not
   the actual entry point itself.  So to find the actual address at
   which execution should begin, we need to fetch the function's entry
   point from that descriptor.  */
static CORE_ADDR
ppc64_call_dummy_address (void)
{
  return ppc64_desc_entry_point (entry_point_address ());
}


a997 4
      /* Shared library handling.  */
      set_gdbarch_in_solib_call_trampoline (gdbarch, in_plt_section);
      set_gdbarch_skip_trampoline_code (gdbarch,
                                        ppc_linux_skip_trampoline_code);
a1000 4
  
  if (tdep->wordsize == 8)
    {
      set_gdbarch_call_dummy_address (gdbarch, ppc64_call_dummy_address);
d1002 3
a1004 4
      set_gdbarch_in_solib_call_trampoline
        (gdbarch, ppc64_in_solib_call_trampoline);
      set_gdbarch_skip_trampoline_code (gdbarch, ppc64_skip_trampoline_code);
    }
@


1.28.8.10
log
@*** empty log message ***
@
text
@d635 273
d1019 4
d1026 4
d1031 4
a1034 3
  /* Shared library handling.  */
  set_gdbarch_in_solib_call_trampoline (gdbarch, in_plt_section);
  set_gdbarch_skip_trampoline_code (gdbarch, ppc_linux_skip_trampoline_code);
@


1.28.8.11
log
@Recognize and skip 64-bit PowerPC Linux linkage functions.
* ppc-linux-tdep.c (insn_d, insn_ds, insn_xfx, read_insn, struct
insn_pattern, insns_match_pattern, d_field, ds_field): New
functions, macros, and types for working with PPC instructions.
(ppc64_standard_linkage, PPC64_STANDARD_LINKAGE_LEN,
ppc64_in_solib_call_trampoline, ppc64_standard_linkage_target,
ppc64_skip_trampoline_code): New functions, variables, and macros
for recognizing and skipping linkage functions.
(ppc_linux_init_abi): Use ppc64_in_solib_call_trampoline and
ppc64_skip_trampoline_code for the 64-bit PowerPC Linux ABI.
@
text
@a634 252

/* Macros for matching instructions.  Note that, since all the
   operands are masked off before they're or-ed into the instruction,
   you can use -1 to make masks.  */

#define insn_d(opcd, rts, ra, d)                \
  ((((opcd) & 0x3f) << 26)                      \
   | (((rts) & 0x1f) << 21)                     \
   | (((ra) & 0x1f) << 16)                      \
   | ((d) & 0xffff))

#define insn_ds(opcd, rts, ra, d, xo)           \
  ((((opcd) & 0x3f) << 26)                      \
   | (((rts) & 0x1f) << 21)                     \
   | (((ra) & 0x1f) << 16)                      \
   | ((d) & 0xfffc)                             \
   | ((xo) & 0x3))

#define insn_xfx(opcd, rts, spr, xo)            \
  ((((opcd) & 0x3f) << 26)                      \
   | (((rts) & 0x1f) << 21)                     \
   | (((spr) & 0x1f) << 16)                     \
   | (((spr) & 0x3e0) << 6)                     \
   | (((xo) & 0x3ff) << 1))

/* Read a PPC instruction from memory.  PPC instructions are always
   big-endian, no matter what endianness the program is running in, so
   we can't use read_memory_integer or one of its friends here.  */
static unsigned int
read_insn (CORE_ADDR pc)
{
  unsigned char buf[4];

  read_memory (pc, buf, 4);
  return (buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | buf[3];
}


/* An instruction to match.  */
struct insn_pattern
{
  unsigned int mask;            /* mask the insn with this... */
  unsigned int data;            /* ...and see if it matches this. */
  int optional;                 /* If non-zero, this insn may be absent.  */
};

/* Return non-zero if the instructions at PC match the series
   described in PATTERN, or zero otherwise.  PATTERN is an array of
   'struct insn_pattern' objects, terminated by an entry whose mask is
   zero.

   When the match is successful, fill INSN[i] with what PATTERN[i]
   matched.  If PATTERN[i] is optional, and the instruction wasn't
   present, set INSN[i] to 0 (which is not a valid PPC instruction).
   INSN should have as many elements as PATTERN.  Note that, if
   PATTERN contains optional instructions which aren't present in
   memory, then INSN will have holes, so INSN[i] isn't necessarily the
   i'th instruction in memory.  */
static int
insns_match_pattern (CORE_ADDR pc,
                     struct insn_pattern *pattern,
                     unsigned int *insn)
{
  int i;

  for (i = 0; pattern[i].mask; i++)
    {
      insn[i] = read_insn (pc);
      if ((insn[i] & pattern[i].mask) == pattern[i].data)
        pc += 4;
      else if (pattern[i].optional)
        insn[i] = 0;
      else
        return 0;
    }

  return 1;
}


/* Return the 'd' field of the d-form instruction INSN, properly
   sign-extended.  */
static CORE_ADDR
insn_d_field (unsigned int insn)
{
  return ((((CORE_ADDR) insn & 0xffff) ^ 0x8000) - 0x8000);
}


/* Return the 'ds' field of the ds-form instruction INSN, with the two
   zero bits concatenated at the right, and properly
   sign-extended.  */
static CORE_ADDR
insn_ds_field (unsigned int insn)
{
  return ((((CORE_ADDR) insn & 0xfffc) ^ 0x8000) - 0x8000);
}


/* Pattern for the standard linkage function.  These are built by
   build_plt_stub in elf64-ppc.c, whose GLINK argument is always
   zero.  */
static struct insn_pattern ppc64_standard_linkage[] =
  {
    /* addis r12, r2, <any> */
    { insn_d (-1, -1, -1, 0), insn_d (15, 12, 2, 0), 0 },

    /* std r2, 40(r1) */
    { -1, insn_ds (62, 2, 1, 40, 0), 0 },

    /* ld r11, <any>(r12) */
    { insn_ds (-1, -1, -1, 0, -1), insn_ds (58, 11, 12, 0, 0), 0 },

    /* addis r12, r12, 1 <optional> */
    { insn_d (-1, -1, -1, -1), insn_d (15, 12, 2, 1), 1 },

    /* ld r2, <any>(r12) */
    { insn_ds (-1, -1, -1, 0, -1), insn_ds (58, 2, 12, 0, 0), 0 },

    /* addis r12, r12, 1 <optional> */
    { insn_d (-1, -1, -1, -1), insn_d (15, 12, 2, 1), 1 },

    /* mtctr r11 */
    { insn_xfx (-1, -1, -1, -1), insn_xfx (31, 11, 9, 467),
      0 },

    /* ld r11, <any>(r12) */
    { insn_ds (-1, -1, -1, 0, -1), insn_ds (58, 11, 12, 0, 0), 0 },
      
    /* bctr */
    { -1, 0x4e800420, 0 },

    { 0, 0, 0 }
  };
#define PPC64_STANDARD_LINKAGE_LEN \
  (sizeof (ppc64_standard_linkage) / sizeof (ppc64_standard_linkage[0]))


/* Recognize a 64-bit PowerPC Linux linkage function --- what GDB
   calls a "solib trampoline".  */
static int
ppc64_in_solib_call_trampoline (CORE_ADDR pc, char *name)
{
  /* Detecting solib call trampolines on PPC64 Linux is a pain.

     It's not specifically solib call trampolines that are the issue.
     Any call from one function to another function that uses a
     different TOC requires a trampoline, to save the caller's TOC
     pointer and then load the callee's TOC.  An executable or shared
     library may have more than one TOC, so even intra-object calls
     may require a trampoline.  Since executable and shared libraries
     will all have their own distinct TOCs, every inter-object call is
     also an inter-TOC call, and requires a trampoline --- so "solib
     call trampolines" are just a special case.

     The 64-bit PowerPC Linux ABI calls these call trampolines
     "linkage functions".  Since they need to be near the functions
     that call them, they all appear in .text, not in any special
     section.  The .plt section just contains an array of function
     descriptors, from which the linkage functions load the callee's
     entry point, TOC value, and environment pointer.  So
     in_plt_section is useless.  The linkage functions don't have any
     special linker symbols to name them, either.

     The only way I can see to recognize them is to actually look at
     their code.  They're generated by ppc_build_one_stub and some
     other functions in bfd/elf64-ppc.c, so that should show us all
     the instruction sequences we need to recognize.  */
  unsigned int insn[PPC64_STANDARD_LINKAGE_LEN];

  return insns_match_pattern (pc, ppc64_standard_linkage, insn);
}


/* When the dynamic linker is doing lazy symbol resolution, the first
   call to a function in another object will go like this:

   - The user's function calls the linkage function:

     100007c4:	4b ff fc d5 	bl	10000498
     100007c8:	e8 41 00 28 	ld	r2,40(r1)

   - The linkage function loads the entry point (and other stuff) from
     the function descriptor in the PLT, and jumps to it:

     10000498:	3d 82 00 00 	addis	r12,r2,0
     1000049c:	f8 41 00 28 	std	r2,40(r1)
     100004a0:	e9 6c 80 98 	ld	r11,-32616(r12)
     100004a4:	e8 4c 80 a0 	ld	r2,-32608(r12)
     100004a8:	7d 69 03 a6 	mtctr	r11
     100004ac:	e9 6c 80 a8 	ld	r11,-32600(r12)
     100004b0:	4e 80 04 20 	bctr

   - But since this is the first time that PLT entry has been used, it
     sends control to its glink entry.  That loads the number of the
     PLT entry and jumps to the common glink0 code:

     10000c98:	38 00 00 00 	li	r0,0
     10000c9c:	4b ff ff dc 	b	10000c78

   - The common glink0 code then transfers control to the dynamic
     linker's fixup code:

     10000c78:	e8 41 00 28 	ld	r2,40(r1)
     10000c7c:	3d 82 00 00 	addis	r12,r2,0
     10000c80:	e9 6c 80 80 	ld	r11,-32640(r12)
     10000c84:	e8 4c 80 88 	ld	r2,-32632(r12)
     10000c88:	7d 69 03 a6 	mtctr	r11
     10000c8c:	e9 6c 80 90 	ld	r11,-32624(r12)
     10000c90:	4e 80 04 20 	bctr

   Eventually, this code will figure out how to skip all of this,
   including the dynamic linker.  At the moment, we just get through
   the linkage function.  */

/* If the current thread is about to execute a series of instructions
   at PC matching the ppc64_standard_linkage pattern, and INSN is the result
   from that pattern match, return the code address to which the
   standard linkage function will send them.  (This doesn't deal with
   dynamic linker lazy symbol resolution stubs.)  */
static CORE_ADDR
ppc64_standard_linkage_target (CORE_ADDR pc, unsigned int *insn)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

  /* The address of the function descriptor this linkage function
     references.  */
  CORE_ADDR desc
    = ((CORE_ADDR) read_register (tdep->ppc_gp0_regnum + 2)
       + (insn_d_field (insn[0]) << 16)
       + insn_ds_field (insn[2]));

  /* The first word of the descriptor is the entry point.  Return that.  */
  return (CORE_ADDR) read_memory_unsigned_integer (desc, 8);
}


/* Given that we've begun executing a call trampoline at PC, return
   the entry point of the function the trampoline will go to.  */
static CORE_ADDR
ppc64_skip_trampoline_code (CORE_ADDR pc)
{
  unsigned int ppc64_standard_linkage_insn[PPC64_STANDARD_LINKAGE_LEN];

  if (insns_match_pattern (pc, ppc64_standard_linkage,
                           ppc64_standard_linkage_insn))
    return ppc64_standard_linkage_target (pc, ppc64_standard_linkage_insn);
  else
    return 0;
}


a745 4
      /* Shared library handling.  */
      set_gdbarch_in_solib_call_trampoline (gdbarch, in_plt_section);
      set_gdbarch_skip_trampoline_code (gdbarch,
                                        ppc_linux_skip_trampoline_code);
d749 4
a752 7
  
  if (tdep->wordsize == 8)
    {
      set_gdbarch_in_solib_call_trampoline
        (gdbarch, ppc64_in_solib_call_trampoline);
      set_gdbarch_skip_trampoline_code (gdbarch, ppc64_skip_trampoline_code);
    }
@


1.28.8.12
log
@* ppc-linux-tdep.c (ppc64_desc_entry_point): New function.
(ppc64_standard_linkage_target): Use it.
@
text
@a733 10
/* If DESC is the address of a 64-bit PowerPC Linux function
   descriptor, return the descriptor's entry point.  */
static CORE_ADDR
ppc64_desc_entry_point (CORE_ADDR desc)
{
  /* The first word of the descriptor is the entry point.  */
  return (CORE_ADDR) read_memory_unsigned_integer (desc, 8);
}


d868 1
a868 1
  return ppc64_desc_entry_point (desc);
@


1.28.8.13
log
@* ppc-linux-tdep.c (ppc64_call_dummy_address): New function.
(ppc_linux_init_abi): Set it as the gdbarch's call_dummy_address
method.
@
text
@a896 12
/* On 64-bit PowerPC Linux, the ELF header's e_entry field is the
   address of a function descriptor for the entry point function, not
   the actual entry point itself.  So to find the actual address at
   which execution should begin, we need to fetch the function's entry
   point from that descriptor.  */
static CORE_ADDR
ppc64_call_dummy_address (void)
{
  return ppc64_desc_entry_point (entry_point_address ());
}


a1017 2
      set_gdbarch_call_dummy_address (gdbarch, ppc64_call_dummy_address);

@


1.28.8.14
log
@* ppc-linux-tdep.c (ppc_linux_init_abi): long doubles are 16 bytes
long.
@
text
@a1029 2
      set_gdbarch_long_double_bit (gdbarch, 16 * TARGET_CHAR_BIT);

@


1.28.8.15
log
@* ppc-linux-tdep.c (ppc64_linux_convert_from_func_ptr_addr): New
function.
(ppc_linux_init_abi): Register it as the
CONVERT_FROM_FUNC_PTR_ADDR method under the PPC64 Linux ABI.
@
text
@a896 33
/* Support for CONVERT_FROM_FUNC_PTR_ADDR(ADDR).

   Usually a function pointer's representation is simply the address
   of the function. On the RS/6000 however, a function pointer is
   represented by a pointer to a TOC entry. This TOC entry contains
   three words, the first word is the address of the function, the
   second word is the TOC pointer (r2), and the third word is the
   static chain value.  Throughout GDB it is currently assumed that a
   function pointer contains the address of the function, which is not
   easy to fix.  In addition, the conversion of a function address to
   a function pointer would require allocation of a TOC entry in the
   inferior's memory space, with all its drawbacks.  To be able to
   call C++ virtual methods in the inferior (which are called via
   function pointers), find_function_addr uses this function to get the
   function address from a function pointer.  */

/* Return real function address if ADDR (a function pointer) is in the data
   space and is therefore a special function pointer.  */

static CORE_ADDR
ppc64_linux_convert_from_func_ptr_addr (CORE_ADDR addr)
{
  struct obj_section *s;

  s = find_pc_section (addr);
  if (s && s->the_bfd_section->flags & SEC_CODE)
    return addr;

  /* ADDR is in the data space, so it's a special function pointer. */
  return ppc64_desc_entry_point (addr);
}


a1030 5

      /* Handle PPC64 Linux function pointers (which are really
         function descriptors).  */
      set_gdbarch_convert_from_func_ptr_addr
        (gdbarch, ppc64_linux_convert_from_func_ptr_addr);
@


1.28.8.16
log
@Revert call to set_gdbarch_long_double_bit; rs6000-tdep.c handles this
correctly.
@
text
@d1063 2
@


1.28.8.17
log
@Revert for revision.
@
text
@d897 33
d1063 5
@


1.28.8.18
log
@* ppc-linux-tdep.c (ppc64_linux_convert_from_func_ptr_addr): New
function.
(ppc_linux_init_abi): Register it as the
CONVERT_FROM_FUNC_PTR_ADDR method under the PPC64 Linux ABI.
@
text
@a896 35
/* Support for CONVERT_FROM_FUNC_PTR_ADDR(ADDR) on PPC64 Linux.

   Usually a function pointer's representation is simply the address
   of the function. On Linux on the 64-bit PowerPC however, a function
   pointer is represented by a pointer to a TOC entry. This TOC entry
   contains three words, the first word is the address of the
   function, the second word is the TOC pointer (r2), and the third
   word is the static chain value.  Throughout GDB it is currently
   assumed that a function pointer contains the address of the
   function, which is not easy to fix.  In addition, the conversion of
   a function address to a function pointer would require allocation
   of a TOC entry in the inferior's memory space, with all its
   drawbacks.  To be able to call C++ virtual methods in the inferior
   (which are called via function pointers), find_function_addr uses
   this function to get the function address from a function
   pointer.  */

/* Return real function address if ADDR (a function pointer) is in the data
   space and is therefore a special function pointer.  */

static CORE_ADDR
ppc64_linux_convert_from_func_ptr_addr (CORE_ADDR addr)
{
  struct obj_section *s;

  s = find_pc_section (addr);
  if (s && s->the_bfd_section->flags & SEC_CODE)
    return addr;

  /* ADDR is in the data space, so it's a pointer to a descriptor, not
     the entry point.  */
  return ppc64_desc_entry_point (addr);
}


a1029 5
      /* Handle PPC64 Linux function pointers (which are really
         function descriptors).  */
      set_gdbarch_convert_from_func_ptr_addr
        (gdbarch, ppc64_linux_convert_from_func_ptr_addr);

@


1.28.8.19
log
@* ppc-linux-tdep.c (ppc64_linux_bfd_entry_point): New function.
(ppc_linux_init_abi): Register it as our bfd_entry_point address.
@
text
@a943 100
/* Return the unrelocated code address at which execution begins for
   ABFD, under the 64-bit PowerPC Linux ABI.  On that system, the ELF
   header e_entry field (which is what bfd_get_start_address gives
   you) is the address of the function descriptor for the startup
   function, not the address of the actual machine instruction you
   jump to.

   This function doesn't just go and read the entry point from the
   function descriptor.  We need it to work when ABFD is the dynamic
   linker, immediately after an exec.  But ld.so is a dynamic
   executable itself on PPC64 Linux, so it appears in memory whereever
   the kernel drops it; this means that bfd_get_start_address's result
   needs to be adjusted --- by some offset we don't know.  So we can't
   find the descriptor's address in memory to read the entry point
   from it.

   Instead, we do it all based on ABFD's symbol table.  We take the
   address from bfd_get_start_address, find each symbol at that
   address, stick a '.' on the front of its name to get the entry
   point symbol name, try to look that up, and return the value of
   what we find, if anything.  We never touch memory, or talk with the
   kernel about the inferior at all.

   Now, this address we return is straight from the symbol table, so
   it hasn't been adjusted to take into account where ABFD was loaded.
   But that's okay --- our job is just to return the unrelocated code
   address.  */
static CORE_ADDR
ppc64_linux_bfd_entry_point (struct gdbarch *gdbarch, bfd *abfd)
{
  long storage_needed;

  storage_needed = bfd_get_symtab_upper_bound (abfd);

  if (storage_needed > 0)
    {
      asymbol **symbol_table;
      unsigned int symbol_table_len;
      struct cleanup *back_to;
      unsigned int i;
      CORE_ADDR start_address;

      symbol_table = (asymbol **) xmalloc (storage_needed);
      back_to = make_cleanup (xfree, symbol_table);
      symbol_table_len = bfd_canonicalize_symtab (abfd, symbol_table);

      /* Find the symbol naming the start function's descriptor.  Its
         value must be the BFD's start address, and it must be in a
         data section.

         Also, the symbol's name must be non-empty.  A lot of symtabs
         seem to contain a bunch of symbols with no name whose value
         is zero relative to the start of the data section; if the
         start function descriptor is the first thing in the data
         section, we'll get more false positives than we'd like.  */
      start_address = bfd_get_start_address (abfd);
      for (i = 0; i < symbol_table_len; i++)
        if (bfd_asymbol_value (symbol_table[i]) == start_address
            && symbol_table[i]->section->flags & SEC_DATA
            && bfd_asymbol_name (symbol_table[i])[0] != '\0')
          {
            /* Okay, we've found a symbol whose value and section are
               right.  Construct the name of the corresponding entry
               point symbol and see if we can find a symbol with that
               name in a code section.  */
            const char *desc_name = bfd_asymbol_name (symbol_table[i]);
            char *entry_pt_name = alloca (strlen (desc_name) + 2);
            int j;

            entry_pt_name[0] = '.';
            strcpy (entry_pt_name + 1, desc_name);

            for (j = 0; j < symbol_table_len; j++)
              if ((strcmp (bfd_asymbol_name (symbol_table[j]), entry_pt_name)
                   == 0)
                  && symbol_table[j]->section->flags & SEC_CODE)
                /* Yay!  What a coincidence.  Let's assume this is the
                   entry point symbol.  */
                {
                  CORE_ADDR entry_point = bfd_asymbol_value (symbol_table[j]);
                  do_cleanups (back_to);
                  return entry_point;
                }
            
            /* No good --- there's no symbol by that name.  Perhaps
               symbol_table[i] is just coincidentally equal to the
               start address; after all, there could be many symbols
               with the same value.  Continue the search.  */
          }

      /* No good --- there's no symbol pointing at the start
         address.  */
      do_cleanups (back_to);
    }
  
  /* No good --- this BFD has no symbols at all.  We give up!  */
  return 0;
}


a1070 2
      
      set_gdbarch_bfd_entry_point (gdbarch, ppc64_linux_bfd_entry_point);
@


1.28.8.20
log
@Revert change for revision.
@
text
@d944 100
d1171 2
@


1.28.4.1
log
@Patch from Will Schmidt <willschm@@us.ibm.com>:

These changes enable support of PPC64 architecture.
* config/powerpc/ppc64linux.mh: New file.
* config/powerpc/ppc64linux.mt: New file.
* config/powerpc/tm-ppc64linux.h: New file.
* ppc64-linux-tdep.c: New file.
* configure.host: Add clause for powerpc64-*-linux*
* configure.tgt: Add clause for powerpc64-*-linux*
* elfread.c (record_minimal_symbol_and_info): If
DROP_TEXT_NAME_PREFIX_CHAR is #defined, then drop a leading
instance of that char from the names of text symbols.
(elf_symtab_read): If SKIP_DATA_IN_OPD is #defined, ignore data
symbols in the .opd section.
* ppc-linux-nat.c (PTRACE_XFER_TYPE): Change the default for this
to 'long'.
(PPC_PTRACE_POKEUSR_3264, PPC_PTRACE_PEEKUSR_3264,
PPC_PTRACE_POKEDATA_3264, PPC_PTRACE_PEEKDATA_3264): Provide
default definitions for these.
(ARCH64): New macro.
(ppc_wordsize_pid): New function.
(kernel_u_size): Handle 64-bit case.
(ppc_register_u_addr): Same.
(fetch_register): Use the *_3264 requests when
debugging a 64-bit process from a 32-bit GDB.
(store_register): Same.
(GDB_MAX_ALLOCA, child_xfer_memory, udot_info): Copied from
infptrace.c.
(_initialize_ppc_linux_nat): New function, to register our copy of
the udot_info command.
* ppc-linux-tdep.c (TDEP): New macro.
(ppc64_linux_svr4_fetch_link_map_offsets): New function.
(read_memory_addr): Copied from rs6000-tdep.c.
(ppc64_linux_convert_from_func_ptr_addr): New function.
* rs6000-tdep.c (skip_prologue): Recognize more instructions for
saving the 'lr' and 'cr' registers; don't just pre-emptively mask
in the 'st' opcode as soon as we see an 'mflr' or 'mfcr' opcode.
Recognize more instructions for updating the stack pointer, and
loading the TOC pointer.
(registers_powerpc64, registers_a35): New register tables.
(rs6000_gdbarch_init): Register the 64-bit solib functions.
* solib-svr4.c (solib_break_names): If SOLIB_BREAK_NAME is
#defined, include an entry for it.
(enable_break): Call CONVERT_FROM_FUNC_PTR_ADDR when trying to
guess the linker's base address.
* config/powerpc/tm-linux.h
(ppc64_linux_svr4_fetch_link_map_offsets,
ppc64_linux_convert_from_func_ptr_addr): New declarations.
@
text
@a65 2
#define TDEP	gdbarch_tdep (current_gdbarch)
	
a756 61
}

struct link_map_offsets *
	ppc64_linux_svr4_fetch_link_map_offsets (void)
{
    static struct link_map_offsets lmo;
    static struct link_map_offsets *lmp = NULL;

    if (lmp == NULL)
    {
	lmp = &lmo;

	lmo.r_debug_size = 16;/* The actual size is xx bytes, but
					   this is all we need.  */
	lmo.r_map_offset = 8;
	lmo.r_map_size   = 8; 
	lmo.link_map_size = 40;  /* The actual size is xxx bytes, but
					   this is all we need.  */
	lmo.l_addr_offset = 0;
	lmo.l_addr_size   = 8;
	lmo.l_name_offset = 8; 
	lmo.l_name_size   = 8;
	lmo.l_next_offset = 24;
	lmo.l_next_size   = 8;
	lmo.l_prev_offset = 32;
	lmo.l_prev_size   = 8;
    }

    return lmp;
}


/* Support for CONVERT_FROM_FUNC_PTR_ADDR(ADDR).
	   Duplicate of RS6000 function, except ppc64_linux requires relocated address. */
static CORE_ADDR
read_memory_addr (CORE_ADDR memaddr, int len)
{
    return read_memory_unsigned_integer (memaddr, len);
}
	
	
CORE_ADDR
ppc64_linux_convert_from_func_ptr_addr (CORE_ADDR addr)
{
    long long my_adder;
    struct obj_section *s;
    CORE_ADDR retval;
    extern struct obj_section *find_pc_section(CORE_ADDR);

	/* this should be the base address that the object (containing the func_ptr_addr) is loaded at. */
    my_adder = 0x7fe0000000; 

    s = find_pc_section (my_adder + addr);
    if (s && s->the_bfd_section->flags & SEC_CODE)
	return addr;

	  /* ADDR is in the data space, so it's a special function pointer. */
    retval = read_memory_addr (my_adder + addr, TDEP->wordsize);
	/*  printf("reading 0x%lx ",my_adder+addr); */
	/*  printf("ppc64...convert_func_ptr addr:0x%lx  new:0x%lx\n",addr,retval); */
    return retval;
@


1.27
log
@Index: ChangeLog
2003-03-23  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_FRAME_CHAIN): Replace FRAME_CHAIN.
	(DEPRECATED_FRAME_CHAIN_VALID): Replace FRAME_CHAIN_VALID.
	* gdbarch.h, gdbarch.c: Regenerate.
	* valops.c (hand_function_call): Update.
	* objfiles.h (DEPRECATED_FRAME_CHAIN_VALID): Update.
	* frame.c (legacy_saved_regs_this_id): Update.
	(legacy_get_prev_frame, get_prev_frame, legacy_frame_p): Update.
	* dummy-frame.h: Update.
	* config/sparc/tm-sparc.h (DEPRECATED_FRAME_CHAIN): Update.
	* config/pa/tm-hppa.h (DEPRECATED_FRAME_CHAIN_VALID): Update.
	* config/m68k/tm-vx68.h (DEPRECATED_FRAME_CHAIN): Update.
	* config/m68k/tm-os68k.h (DEPRECATED_FRAME_CHAIN): Update.
	* config/m68k/tm-sun3.h: Update.
	* blockframe.c (inside_main_func, frame_chain_valid): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_frame_chain, sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_frame_saved_pc): Update.
	(rs6000_gdbarch_init, rs6000_frame_saved_pc): Update.
	(frame_get_saved_regs): Update.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_frame_num_args, i386_gdbarch_init): Update.
	* i386-interix-tdep.c (i386_interix_init_abi): Update.
	(i386_interix_back_one_frame): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	(hppa_init_extra_frame_info): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

Index: doc/ChangeLog
2003-03-23  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Algorithms, Target Architecture Definition):
	Deprecate FRAME_CHAIN and FRAME_CHAIN_VALID.
@
text
@d350 2
a351 1
	read_memory_integer (fi->frame + PPC_LINUX_REGS_PTR_OFFSET, 4);
d355 2
a356 1
  else if (fi->next && (get_frame_type (fi->next) == SIGTRAMP_FRAME))
d359 2
a360 1
	read_memory_integer (fi->next->frame + PPC_LINUX_REGS_PTR_OFFSET, 4);
d373 1
a373 1
  if (fi->next != 0)
d378 1
a378 1
      if (ppc_linux_at_sigtramp_return_path (fi->pc))
d392 1
a392 1
  if (ppc_linux_at_sigtramp_return_path (fi->pc))
d405 1
a405 1
      if (fi->saved_regs)
d411 4
a414 3
	read_memory_integer (fi->frame + PPC_LINUX_REGS_PTR_OFFSET, 4);
      fi->saved_regs[PC_REGNUM] = regs_addr + 4 * PPC_LINUX_PT_NIP;
      fi->saved_regs[gdbarch_tdep (current_gdbarch)->ppc_ps_regnum] =
d416 1
a416 1
      fi->saved_regs[gdbarch_tdep (current_gdbarch)->ppc_cr_regnum] =
d418 1
a418 1
      fi->saved_regs[gdbarch_tdep (current_gdbarch)->ppc_lr_regnum] =
d420 1
a420 1
      fi->saved_regs[gdbarch_tdep (current_gdbarch)->ppc_ctr_regnum] =
d422 1
a422 1
      fi->saved_regs[gdbarch_tdep (current_gdbarch)->ppc_xer_regnum] =
d424 1
a424 1
      fi->saved_regs[gdbarch_tdep (current_gdbarch)->ppc_mq_regnum] =
d427 1
a427 1
	fi->saved_regs[gdbarch_tdep (current_gdbarch)->ppc_gp0_regnum + i] =
d430 1
a430 1
	fi->saved_regs[FP0_REGNUM + i] = regs_addr + 4 * PPC_LINUX_PT_FPR0 + 8 * i;
d441 1
a441 1
    return read_memory_integer ((thisframe)->frame, 4);
@


1.26
log
@2003-03-12  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_FRAME_SAVED_PC): Replace FRAME_SAVED_PC.
	* gdbarch.h, gdbarch.c: Re-generate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.h: Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* i386-interix-tdep.c (i386_interix_init_abi): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* sh-tdep.c (sh_init_extra_frame_info): Update.
	(sh64_init_extra_frame_info): Update.
	* ns32knbsd-nat.c (frame_num_args): Update.
	* m68hc11-tdep.c (m68hc11_init_extra_frame_info): Update.
	* xstormy16-tdep.c (xstormy16_pop_frame): Update.
	(xstormy16_frame_chain_valid): Update.
	* vax-tdep.c (vax_saved_pc_after_call): Update.
	* v850-tdep.c (v850_frame_chain): Update.
	(v850_pop_frame): Update.
	(v850_init_extra_frame_info): Update.
	* sparc-tdep.c (setup_arbitrary_frame): Update.
	* ns32k-tdep.c (umax_frame_num_args): Update.
	* s390-tdep.c (s390_pop_frame_regular): Update.
	* mn10300-tdep.c (mn10300_frame_chain): Update.
	(mn10300_pop_frame_regular): Update.
	(mn10300_init_extra_frame_info): Update.
	* mips-tdep.c (mips_init_frame_pc_first): Update.
	(mips_frame_chain): Update.
	(mips_pop_frame): Update.
	* mcore-tdep.c (mcore_frame_chain): Update.
	(mcore_pop_frame): Update.
	(mcore_init_extra_frame_info): Update.
	* arch-utils.c (init_frame_pc_default): Update.
	* m68k-tdep.c (isi_frame_num_args): Update.
	(delta68_frame_num_args): Update.
	(news_frame_num_args): Update.
	* ia64-tdep.c (ia64_pop_frame_regular): Update.
	* alpha-tdep.c (alpha_init_frame_pc_first): Update.
	(alpha_frame_chain): Update.
	(alpha_pop_frame): Update.
	* hppa-tdep.c (hppa_saved_pc_after_call): Update.
	(hppa_init_extra_frame_info): Update.
	(hppa_frame_chain): Update.
	(hppa_frame_chain_valid): Update.
	* cris-tdep.c (cris_init_extra_frame_info): Update.
	* avr-tdep.c (avr_init_extra_frame_info): Update.
	* arm-tdep.c (arm_frame_chain_valid): Update.
	(arm_init_extra_frame_info): Update.
	(arm_pop_frame): Update.
	* frame.c (frame_pc_unwind): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_FRAME_SAVED_PC): Update.
	(DEPRECATED_INIT_FRAME_PC_FIRST): Update.
	* config/rs6000/tm-rs6000.h (DEPRECATED_INIT_FRAME_PC_FIRST): Update.
	* config/pa/tm-hppa.h (DEPRECATED_FRAME_SAVED_PC): Update.
	* config/m68k/tm-delta68.h (DEPRECATED_FRAME_SAVED_PC): Update.
	* config/m68k/tm-linux.h (DEPRECATED_FRAME_SAVED_PC): Update.

2003-03-12  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	FRAME_SAVED_PC to DEPRECATED_FRAME_SAVED_PC.
@
text
@d732 1
a732 1
      set_gdbarch_frame_chain (gdbarch, ppc_linux_frame_chain);
@


1.25
log
@2003-03-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_FRAME_INIT_SAVED_REGS): Rename
	FRAME_INIT_SAVED_REGS.
	* gdbarch.h, gdbarch.c: Regenerate.
	* stack.c (frame_info): Update.
	* sh-tdep.c (sh_find_callers_reg, sh64_get_saved_pr): Update.
	(sh_init_extra_frame_info, sh64_init_extra_frame_info): Update.
	(sh64_get_saved_register, sh_pop_frame, sh64_pop_frame): Update.
	* ns32k-tdep.c (ns32k_pop_frame): Update.
	* mips-tdep.c (mips_pop_frame): Update.
	* m68hc11-tdep.c (m68hc11_pop_frame): Update.
	* ia64-tdep.c (ia64_frame_chain): Update.
	(ia64_frame_saved_pc, ia64_get_saved_register): Update.
	(ia64_frameless_function_invocation): Update.
	(ia64_init_extra_frame_info): Update.
	(ia64_pop_frame_regular): Update.
	* frame.h (struct frame_info): Update comment.
	(DEPRECATED_FRAME_INIT_SAVED_REGS): Rename macro.
	* frame.c (frame_saved_regs_register_unwind): Update.
	(frame_saved_regs_register_unwind): Update.
	(deprecated_generic_get_saved_register): Update.
	* cris-tdep.c: Update comment.
	* config/sparc/tm-sparc.h (DEPRECATED_FRAME_INIT_SAVED_REGS):
	Rename macro.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

2003-03-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	FRAME_INIT_SAVED_REGS to DEPRECATED_FRAME_INIT_SAVED_REGS.
@
text
@d733 1
a733 1
      set_gdbarch_frame_saved_pc (gdbarch, ppc_linux_frame_saved_pc);
@


1.25.4.1
log
@2003-03-16  Mark Kettenis  <kettenis@@gnu.org>

	Merge with mainline.  Tag is kettenis-i386newframe-20030316-mergepoint.
@
text
@d733 1
a733 1
      set_gdbarch_deprecated_frame_saved_pc (gdbarch, ppc_linux_frame_saved_pc);
@


1.24
log
@2003-03-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_INIT_EXTRA_FRAME_INFO): Rename
	INIT_EXTRA_FRAME_INFO.
	* gdbarch.h, gdbarch.c: Regenerate.
	* arm-tdep.c: Update comments.
	* sh-tdep.c, mcore-tdep.c, m68hc11-tdep.c: Ditto.
	* i386-interix-tdep.c, hppa-tdep.c, h8300-tdep.c: Ditto.
	* frame.h, avr-tdep.c: Ditto.
	* frame.c (get_prev_frame): DEPRECATED_INIT_EXTRA_FRAME_INFO.
	(create_new_frame, legacy_get_prev_frame): Ditto.
	* config/sparc/tm-sparc.h (DEPRECATED_INIT_EXTRA_FRAME_INFO): Rename.
	* config/pa/tm-hppa.h (DEPRECATED_INIT_EXTRA_FRAME_INFO): Rename.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Initialize
	deprecated_init_extra_frame_info instead of init_extra_frame_info.
	* x86-64-tdep.c (x86_64_init_abi): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-interix-tdep.c (i386_interix_init_abi): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.

Index: doc/ChangeLog
2003-02-26  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo: Rename INIT_EXTRA_FRAME_INFO to
	DEPRECATED_INIT_EXTRA_FRAME_INFO.
@
text
@d735 1
a735 1
      set_gdbarch_frame_init_saved_regs (gdbarch,
@


1.23
log
@	Pointed out by Anton Blanchard <anton@@samba.org>.
	* ppc-linux-tdep.c (insn_is_sigreturn): New function.
	(ppc_linux_at_sigtramp_return_path): Use it.
@
text
@d737 1
a737 1
      set_gdbarch_init_extra_frame_info (gdbarch,
@


1.22
log
@	* arch-utils.c (gdbarch_info_init): Set osabi to
	GDB_OSABI_UNINITIALIZED.
	* gdbarch.sh: Add osabi to struct gdbarch and to struct
	gdbarch_info.  Include "osabi.h" in gdbarch.c.  Check osabi
	in gdbarch_list_lookup_by_info and in gdbarch_update_p.
	* gdbarch.c: Regenerated.
	* gdbarch.h: Regenerated.
	* osabi.c (gdbarch_lookup_osabi): Return GDB_OSABI_UNINITIALIZED if
	there's no BFD.
	(gdbarch_init_osabi): Remove osabi argument; use info.osabi.
	* osabi.h (enum gdb_osabi): Move to defs.h.
	(gdbarch_init_osabi): Update prototype.
	* defs.h (enum gdb_osabi): Moved here.
	* Makefile.in: Update dependencies.

Plus updates to alpha, arm, hppa, i386, mips, ns32k, ppc, sh, sparc, and vax
ports to match.
@
text
@d39 9
a47 4
/* The following two instructions are used in the signal trampoline
   code on GNU/Linux PPC.  */
#define INSTR_LI_R0_0x7777	0x38007777
#define INSTR_SC		0x44000002
d191 15
d225 1
a225 1
	   (pcinsn == INSTR_LI_R0_0x7777
d229 1
a229 1
	    && extract_unsigned_integer (buf, 4) == INSTR_LI_R0_0x7777));
@


1.21
log
@* osabi.c: Include "gdb_assert.h" and "gdb_string.h".
(struct gdb_osabi_handler): Remove member `arch'.  Add member
`arch_info'.
(gdbarch_register_osabi): Add new argument `machine'.  Use ot to
construct a `struct bfd_arch_info' and store it in the `struct
gdb_osabi_handler' that is created.
(gdbarch_init_osabi): Check for compatibility based on machine
type and architecture.
* osabi.h (gdbarch_register_osabi): Adjust prototype and update
comment.
* alpha-linux-tdep.c (_initialize_alpha_linux_tdep): Add 0 as
second argument in call to gdbarch_register_osabi.
* alpha-osf1-tdep.c (_initialize_alpha_osf1_tdep): Likewise.
* alphafbsd-tdep.c (_initialize_alphafbsd_tdep): Likewise.
* alphanbsd-tdep.c (_initialize_alphanbsd_tdep): Likewise.
* arm-linux-tdep.c (_initialize_arm_linux_tdep): Likewise.
* arm-tdep.c (_initialize_arm_tdep): Likewise.
* armnbsd-tdep.c (_initialize_armnbsd_tdep): Likewise.
* hppa-hpux-tdep.c (_initialize_hppa_hpux_tdep): Likewise.
* i386-interix-tdep.c (_initialize_i386_interix_tdep): Likewise.
* i386-linux-tdep.c (_initialize_i386_linux_tdep): Likewise.
* i386-sol2-tdep.c (_initialize_i386_sol2_tdep): Likewise.
* i386-tdep.c (_initialize_i386_tdep): Likewise.
* i386bsd-tdep.c (_initialize_i386bsd_tdep): Likewise.
* i386gnu-tdep.c (_initialize_i386gnu_tdep): Likewise.
* i386ly-tdep.c (_initialize_i386lynx_tdep): Renamed from
_initialize_i386bsd_tdep and updated likewise.
* i386nbsd-tdep.c (_initialize_i386nbsd_tdep): Likewise.
* i386obsd-tdep.c (_initialize_i386obsd_tdep): Likewise.
* mips-irix-tdep.c (_initialize_mips_irix_tdep): Likewise.
* mips-linux-tdep.c (_initialize_mips_linux_tdep): Likewise.
* mipsnbsd-tdep.c (_initialize_mipsnbsd__tdep): Likewise.
* ns32knbsd-tdep.c (_initialize_ns32kmnsd_tdep): Likewise.
* ppc-linux-tdep.c (_initialize_ppc_linux_tdep): Likewise.
* ppcnbsd-tdep.c (_initialize_ppcnbsd_tdep): Likewise.
* shnbsd-tdep.c (_initialize_shnbsd_tdep): Likewise.
* sparcnbsd-tdep.c (_initialize_sparcnbsd_tdep): Likewise.
@
text
@d4 1
a4 1
   1997, 2000, 2001, 2002 Free Software Foundation, Inc.
d34 1
@


1.20
log
@2002-11-18  Andrew Cagney  <ac131313@@redhat.com>

	* frame.h (enum frame_type): Define.
	(get_frame_type): Declare.
	(struct frame_info): Add field `type'.  Delete field
	signal_handler_caller.
	(deprecated_set_frame_signal_handler_caller): Declare.
	* frame.c (get_frame_type): New function.
	(deprecated_set_frame_type): New function.
	(create_new_frame): Set the frame's type.
	(get_prev_frame): Similar.
	* sparc-tdep.c: Use get_frame_type instead of signal_handler_caller.
	* s390-tdep.c: Ditto.
	* m68klinux-nat.c: Ditto.
	* ns32k-tdep.c: Ditto.
	* x86-64-linux-tdep.c: Ditto.
	* vax-tdep.c: Ditto.
	* rs6000-tdep.c: Ditto.
	* ppc-linux-tdep.c: Ditto.
	* i386-interix-tdep.c: Ditto.
	* mips-tdep.c: Ditto.
	* m68k-tdep.c: Ditto.
	* hppa-tdep.c: Ditto.
	* ia64-tdep.c: Ditto.
	* cris-tdep.c: Ditto.
	* arm-tdep.c: Ditto.
	* alpha-tdep.c: Ditto.
	* i386-tdep.c: Ditto.
	* stack.c: Ditto.
	* ada-lang.c: Ditto.
	* blockframe.c: Update.
	* i386-interix-tdep.c (i386_interix_back_one_frame): Use
	deprecated_set_frame_type instead of signal_handler_caller.
	* ppc-linux-tdep.c (ppc_linux_init_extra_frame_info): Ditto.
	* rs6000-tdep.c (rs6000_init_extra_frame_info): Ditto.
	* breakpoint.h: Delete FIXME suggesting get_frame_type.

Index: tui/ChangeLog
2002-11-18  Andrew Cagney  <ac131313@@redhat.com>

	* tuiStack.c (tuiShowFrameInfo): Use get_frame_type instead of
	signal_handler_caller.
@
text
@d729 1
a729 1
  gdbarch_register_osabi (bfd_arch_powerpc, GDB_OSABI_LINUX,
@


1.19
log
@        * ppc-linux-tdep.c (ELF_NGREG, ELF_NFPREG, ELF_NVRREG)
        (ELF_FPREGSET_SIZE, ELF_GREGSET_SIZE): New enums.
        (fetch_core_registers, ppc_linux_supply_gregset)
        (ppc_linux_supply_fpregset): New functions.
        (ppc_linux_regset_core_fns): New.
        (_initialize_ppc_linux_tdep): Call add_core_fns.
        * ppc-tdep.h: Add prototypes for ppc_linux_supply_fpregset
        and ppc_linux_supply_gregset.
        * ppc-linux-nat.c (supply_gregset): Call ppc_linux_supply_gregset.
        (supply_fpregset): Call ppc_linux_supply_fpregset.
        * config/powerpc/linux.mh (NATDEPFILES): Remove core-regset.o and
        corelow.o.
        * config/powerpc/linux.mt (TDEPFILES): Add corelow.o.
@
text
@d146 2
a147 2
   the signal_handler_caller flag.  Because of our strange definition
   of in_sigtramp below, we can't rely on signal_handler_caller
d149 6
a154 1
   take pains to set it in init_extra_frame_info().  */
d326 1
a326 1
  if (fi->signal_handler_caller)
d333 1
a333 1
  else if (fi->next && fi->next->signal_handler_caller)
d355 1
a355 1
	fi->signal_handler_caller = 1;
d357 3
a359 1
	fi->signal_handler_caller = 0;
d377 1
a377 1
  if (fi->signal_handler_caller)
d415 1
a415 1
  if (thisframe->signal_handler_caller)
@


1.19.10.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d4 1
a4 1
   1997, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
a33 1
#include "osabi.h"
d38 4
a41 9
/* The following instructions are used in the signal trampoline code
   on GNU/Linux PPC. The kernel used to use magic syscalls 0x6666 and
   0x7777 but now uses the sigreturn syscalls.  We check for both.  */
#define INSTR_LI_R0_0x6666		0x38006666
#define INSTR_LI_R0_0x7777		0x38007777
#define INSTR_LI_R0_NR_sigreturn	0x38000077
#define INSTR_LI_R0_NR_rt_sigreturn	0x380000AC

#define INSTR_SC			0x44000002
d146 2
a147 2
   the frame's type (if a SIGTRAMP_FRAME).  Because of our strange
   definition of in_sigtramp below, we can't rely on the frame's type
d149 1
a149 6
   take pains to set it in init_extra_frame_info().

   NOTE: cagney/2002-11-10: I suspect the real problem here is that
   the get_prev_frame() only initializes the frame's type after the
   call to INIT_FRAME_INFO.  get_prev_frame() should be fixed, this
   code shouldn't be working its way around a bug :-(.  */
a179 15
static int
insn_is_sigreturn (unsigned long pcinsn)
{
  switch(pcinsn)
    {
    case INSTR_LI_R0_0x6666:
    case INSTR_LI_R0_0x7777:
    case INSTR_LI_R0_NR_sigreturn:
    case INSTR_LI_R0_NR_rt_sigreturn:
      return 1;
    default:
      return 0;
    }
}

d199 1
a199 1
	   (insn_is_sigreturn (pcinsn)
d203 1
a203 1
	    && insn_is_sigreturn (extract_unsigned_integer (buf, 4))));
d206 1
a206 1
static CORE_ADDR
d272 1
a272 1
  reloc = extract_unsigned_integer (buf, 4);
d308 1
a308 1
  msymbol = lookup_minimal_symbol_text (symname, NULL);
d321 1
a321 1
  if ((get_frame_type (fi) == SIGTRAMP_FRAME))
d324 1
a324 2
	read_memory_integer (get_frame_base (fi)
			     + PPC_LINUX_REGS_PTR_OFFSET, 4);
d328 1
a328 2
  else if (get_next_frame (fi)
	   && (get_frame_type (get_next_frame (fi)) == SIGTRAMP_FRAME))
d331 1
a331 2
	read_memory_integer (get_frame_base (get_next_frame (fi))
			     + PPC_LINUX_REGS_PTR_OFFSET, 4);
d344 1
a344 1
  if (get_next_frame (fi) != 0)
d349 2
a350 2
      if (ppc_linux_at_sigtramp_return_path (get_frame_pc (fi)))
	deprecated_set_frame_type (fi, SIGTRAMP_FRAME);
d352 1
a352 3
	/* FIXME: cagney/2002-11-10: Is this double bogus?  What
           happens if the frame has previously been marked as a dummy?  */
	deprecated_set_frame_type (fi, NORMAL_FRAME);
d361 1
a361 1
  if (ppc_linux_at_sigtramp_return_path (get_frame_pc (fi)))
d370 1
a370 1
  if ((get_frame_type (fi) == SIGTRAMP_FRAME))
d374 1
a374 1
      if (deprecated_get_frame_saved_regs (fi))
d380 3
a382 4
	read_memory_integer (get_frame_base (fi)
			     + PPC_LINUX_REGS_PTR_OFFSET, 4);
      deprecated_get_frame_saved_regs (fi)[PC_REGNUM] = regs_addr + 4 * PPC_LINUX_PT_NIP;
      deprecated_get_frame_saved_regs (fi)[gdbarch_tdep (current_gdbarch)->ppc_ps_regnum] =
d384 1
a384 1
      deprecated_get_frame_saved_regs (fi)[gdbarch_tdep (current_gdbarch)->ppc_cr_regnum] =
d386 1
a386 1
      deprecated_get_frame_saved_regs (fi)[gdbarch_tdep (current_gdbarch)->ppc_lr_regnum] =
d388 1
a388 1
      deprecated_get_frame_saved_regs (fi)[gdbarch_tdep (current_gdbarch)->ppc_ctr_regnum] =
d390 1
a390 1
      deprecated_get_frame_saved_regs (fi)[gdbarch_tdep (current_gdbarch)->ppc_xer_regnum] =
d392 1
a392 1
      deprecated_get_frame_saved_regs (fi)[gdbarch_tdep (current_gdbarch)->ppc_mq_regnum] =
d395 1
a395 1
	deprecated_get_frame_saved_regs (fi)[gdbarch_tdep (current_gdbarch)->ppc_gp0_regnum + i] =
d398 1
a398 1
	deprecated_get_frame_saved_regs (fi)[FP0_REGNUM + i] = regs_addr + 4 * PPC_LINUX_PT_FPR0 + 8 * i;
d408 2
a409 2
  if ((get_frame_type (thisframe) == SIGTRAMP_FRAME))
    return read_memory_integer (get_frame_base (thisframe), 4);
a561 20
/* For historic reasons, PPC 32 GNU/Linux follows PowerOpen rather
   than the 32 bit SYSV R4 ABI structure return convention - all
   structures, no matter their size, are put in memory.  Vectors,
   which were added later, do get returned in a register though.  */

static enum return_value_convention
ppc_linux_return_value (struct gdbarch *gdbarch, struct type *valtype,
			struct regcache *regcache, void *readbuf,
			const void *writebuf)
{  
  if ((TYPE_CODE (valtype) == TYPE_CODE_STRUCT
       || TYPE_CODE (valtype) == TYPE_CODE_UNION)
      && !((TYPE_LENGTH (valtype) == 16 || TYPE_LENGTH (valtype) == 8)
	   && TYPE_VECTOR (valtype)))
    return RETURN_VALUE_STRUCT_CONVENTION;
  else
    return ppc_sysv_abi_return_value (gdbarch, valtype, regcache, readbuf,
				      writebuf);
}

a602 300

/* Macros for matching instructions.  Note that, since all the
   operands are masked off before they're or-ed into the instruction,
   you can use -1 to make masks.  */

#define insn_d(opcd, rts, ra, d)                \
  ((((opcd) & 0x3f) << 26)                      \
   | (((rts) & 0x1f) << 21)                     \
   | (((ra) & 0x1f) << 16)                      \
   | ((d) & 0xffff))

#define insn_ds(opcd, rts, ra, d, xo)           \
  ((((opcd) & 0x3f) << 26)                      \
   | (((rts) & 0x1f) << 21)                     \
   | (((ra) & 0x1f) << 16)                      \
   | ((d) & 0xfffc)                             \
   | ((xo) & 0x3))

#define insn_xfx(opcd, rts, spr, xo)            \
  ((((opcd) & 0x3f) << 26)                      \
   | (((rts) & 0x1f) << 21)                     \
   | (((spr) & 0x1f) << 16)                     \
   | (((spr) & 0x3e0) << 6)                     \
   | (((xo) & 0x3ff) << 1))

/* Read a PPC instruction from memory.  PPC instructions are always
   big-endian, no matter what endianness the program is running in, so
   we can't use read_memory_integer or one of its friends here.  */
static unsigned int
read_insn (CORE_ADDR pc)
{
  unsigned char buf[4];

  read_memory (pc, buf, 4);
  return (buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | buf[3];
}


/* An instruction to match.  */
struct insn_pattern
{
  unsigned int mask;            /* mask the insn with this... */
  unsigned int data;            /* ...and see if it matches this. */
  int optional;                 /* If non-zero, this insn may be absent.  */
};

/* Return non-zero if the instructions at PC match the series
   described in PATTERN, or zero otherwise.  PATTERN is an array of
   'struct insn_pattern' objects, terminated by an entry whose mask is
   zero.

   When the match is successful, fill INSN[i] with what PATTERN[i]
   matched.  If PATTERN[i] is optional, and the instruction wasn't
   present, set INSN[i] to 0 (which is not a valid PPC instruction).
   INSN should have as many elements as PATTERN.  Note that, if
   PATTERN contains optional instructions which aren't present in
   memory, then INSN will have holes, so INSN[i] isn't necessarily the
   i'th instruction in memory.  */
static int
insns_match_pattern (CORE_ADDR pc,
                     struct insn_pattern *pattern,
                     unsigned int *insn)
{
  int i;

  for (i = 0; pattern[i].mask; i++)
    {
      insn[i] = read_insn (pc);
      if ((insn[i] & pattern[i].mask) == pattern[i].data)
        pc += 4;
      else if (pattern[i].optional)
        insn[i] = 0;
      else
        return 0;
    }

  return 1;
}


/* Return the 'd' field of the d-form instruction INSN, properly
   sign-extended.  */
static CORE_ADDR
insn_d_field (unsigned int insn)
{
  return ((((CORE_ADDR) insn & 0xffff) ^ 0x8000) - 0x8000);
}


/* Return the 'ds' field of the ds-form instruction INSN, with the two
   zero bits concatenated at the right, and properly
   sign-extended.  */
static CORE_ADDR
insn_ds_field (unsigned int insn)
{
  return ((((CORE_ADDR) insn & 0xfffc) ^ 0x8000) - 0x8000);
}


/* If DESC is the address of a 64-bit PowerPC GNU/Linux function
   descriptor, return the descriptor's entry point.  */
static CORE_ADDR
ppc64_desc_entry_point (CORE_ADDR desc)
{
  /* The first word of the descriptor is the entry point.  */
  return (CORE_ADDR) read_memory_unsigned_integer (desc, 8);
}


/* Pattern for the standard linkage function.  These are built by
   build_plt_stub in elf64-ppc.c, whose GLINK argument is always
   zero.  */
static struct insn_pattern ppc64_standard_linkage[] =
  {
    /* addis r12, r2, <any> */
    { insn_d (-1, -1, -1, 0), insn_d (15, 12, 2, 0), 0 },

    /* std r2, 40(r1) */
    { -1, insn_ds (62, 2, 1, 40, 0), 0 },

    /* ld r11, <any>(r12) */
    { insn_ds (-1, -1, -1, 0, -1), insn_ds (58, 11, 12, 0, 0), 0 },

    /* addis r12, r12, 1 <optional> */
    { insn_d (-1, -1, -1, -1), insn_d (15, 12, 2, 1), 1 },

    /* ld r2, <any>(r12) */
    { insn_ds (-1, -1, -1, 0, -1), insn_ds (58, 2, 12, 0, 0), 0 },

    /* addis r12, r12, 1 <optional> */
    { insn_d (-1, -1, -1, -1), insn_d (15, 12, 2, 1), 1 },

    /* mtctr r11 */
    { insn_xfx (-1, -1, -1, -1), insn_xfx (31, 11, 9, 467),
      0 },

    /* ld r11, <any>(r12) */
    { insn_ds (-1, -1, -1, 0, -1), insn_ds (58, 11, 12, 0, 0), 0 },
      
    /* bctr */
    { -1, 0x4e800420, 0 },

    { 0, 0, 0 }
  };
#define PPC64_STANDARD_LINKAGE_LEN \
  (sizeof (ppc64_standard_linkage) / sizeof (ppc64_standard_linkage[0]))


/* Recognize a 64-bit PowerPC GNU/Linux linkage function --- what GDB
   calls a "solib trampoline".  */
static int
ppc64_in_solib_call_trampoline (CORE_ADDR pc, char *name)
{
  /* Detecting solib call trampolines on PPC64 GNU/Linux is a pain.

     It's not specifically solib call trampolines that are the issue.
     Any call from one function to another function that uses a
     different TOC requires a trampoline, to save the caller's TOC
     pointer and then load the callee's TOC.  An executable or shared
     library may have more than one TOC, so even intra-object calls
     may require a trampoline.  Since executable and shared libraries
     will all have their own distinct TOCs, every inter-object call is
     also an inter-TOC call, and requires a trampoline --- so "solib
     call trampolines" are just a special case.

     The 64-bit PowerPC GNU/Linux ABI calls these call trampolines
     "linkage functions".  Since they need to be near the functions
     that call them, they all appear in .text, not in any special
     section.  The .plt section just contains an array of function
     descriptors, from which the linkage functions load the callee's
     entry point, TOC value, and environment pointer.  So
     in_plt_section is useless.  The linkage functions don't have any
     special linker symbols to name them, either.

     The only way I can see to recognize them is to actually look at
     their code.  They're generated by ppc_build_one_stub and some
     other functions in bfd/elf64-ppc.c, so that should show us all
     the instruction sequences we need to recognize.  */
  unsigned int insn[PPC64_STANDARD_LINKAGE_LEN];

  return insns_match_pattern (pc, ppc64_standard_linkage, insn);
}


/* When the dynamic linker is doing lazy symbol resolution, the first
   call to a function in another object will go like this:

   - The user's function calls the linkage function:

     100007c4:	4b ff fc d5 	bl	10000498
     100007c8:	e8 41 00 28 	ld	r2,40(r1)

   - The linkage function loads the entry point (and other stuff) from
     the function descriptor in the PLT, and jumps to it:

     10000498:	3d 82 00 00 	addis	r12,r2,0
     1000049c:	f8 41 00 28 	std	r2,40(r1)
     100004a0:	e9 6c 80 98 	ld	r11,-32616(r12)
     100004a4:	e8 4c 80 a0 	ld	r2,-32608(r12)
     100004a8:	7d 69 03 a6 	mtctr	r11
     100004ac:	e9 6c 80 a8 	ld	r11,-32600(r12)
     100004b0:	4e 80 04 20 	bctr

   - But since this is the first time that PLT entry has been used, it
     sends control to its glink entry.  That loads the number of the
     PLT entry and jumps to the common glink0 code:

     10000c98:	38 00 00 00 	li	r0,0
     10000c9c:	4b ff ff dc 	b	10000c78

   - The common glink0 code then transfers control to the dynamic
     linker's fixup code:

     10000c78:	e8 41 00 28 	ld	r2,40(r1)
     10000c7c:	3d 82 00 00 	addis	r12,r2,0
     10000c80:	e9 6c 80 80 	ld	r11,-32640(r12)
     10000c84:	e8 4c 80 88 	ld	r2,-32632(r12)
     10000c88:	7d 69 03 a6 	mtctr	r11
     10000c8c:	e9 6c 80 90 	ld	r11,-32624(r12)
     10000c90:	4e 80 04 20 	bctr

   Eventually, this code will figure out how to skip all of this,
   including the dynamic linker.  At the moment, we just get through
   the linkage function.  */

/* If the current thread is about to execute a series of instructions
   at PC matching the ppc64_standard_linkage pattern, and INSN is the result
   from that pattern match, return the code address to which the
   standard linkage function will send them.  (This doesn't deal with
   dynamic linker lazy symbol resolution stubs.)  */
static CORE_ADDR
ppc64_standard_linkage_target (CORE_ADDR pc, unsigned int *insn)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

  /* The address of the function descriptor this linkage function
     references.  */
  CORE_ADDR desc
    = ((CORE_ADDR) read_register (tdep->ppc_gp0_regnum + 2)
       + (insn_d_field (insn[0]) << 16)
       + insn_ds_field (insn[2]));

  /* The first word of the descriptor is the entry point.  Return that.  */
  return ppc64_desc_entry_point (desc);
}


/* Given that we've begun executing a call trampoline at PC, return
   the entry point of the function the trampoline will go to.  */
static CORE_ADDR
ppc64_skip_trampoline_code (CORE_ADDR pc)
{
  unsigned int ppc64_standard_linkage_insn[PPC64_STANDARD_LINKAGE_LEN];

  if (insns_match_pattern (pc, ppc64_standard_linkage,
                           ppc64_standard_linkage_insn))
    return ppc64_standard_linkage_target (pc, ppc64_standard_linkage_insn);
  else
    return 0;
}


/* Support for CONVERT_FROM_FUNC_PTR_ADDR (ARCH, ADDR, TARG) on PPC64
   GNU/Linux.

   Usually a function pointer's representation is simply the address
   of the function. On GNU/Linux on the 64-bit PowerPC however, a
   function pointer is represented by a pointer to a TOC entry. This
   TOC entry contains three words, the first word is the address of
   the function, the second word is the TOC pointer (r2), and the
   third word is the static chain value.  Throughout GDB it is
   currently assumed that a function pointer contains the address of
   the function, which is not easy to fix.  In addition, the
   conversion of a function address to a function pointer would
   require allocation of a TOC entry in the inferior's memory space,
   with all its drawbacks.  To be able to call C++ virtual methods in
   the inferior (which are called via function pointers),
   find_function_addr uses this function to get the function address
   from a function pointer.  */

/* If ADDR points at what is clearly a function descriptor, transform
   it into the address of the corresponding function.  Be
   conservative, otherwize GDB will do the transformation on any
   random addresses such as occures when there is no symbol table.  */

static CORE_ADDR
ppc64_linux_convert_from_func_ptr_addr (struct gdbarch *gdbarch,
					CORE_ADDR addr,
					struct target_ops *targ)
{
  struct section_table *s = target_section_by_addr (targ, addr);

  /* Check if ADDR points to a function descriptor.  */
  if (s && strcmp (s->the_bfd_section->name, ".opd") == 0)
    return get_target_memory_unsigned (targ, addr, 8);

  return addr;
}


d691 7
a699 9
      /* Until November 2001, gcc did not comply with the 32 bit SysV
	 R4 ABI requirement that structures less than or equal to 8
	 bytes should be returned in registers.  Instead GCC was using
	 the the AIX/PowerOpen ABI - everything returned in memory
	 (well ignoring vectors that is).  When this was corrected, it
	 wasn't fixed for GNU/Linux native platform.  Use the
	 PowerOpen struct convention.  */
      set_gdbarch_return_value (gdbarch, ppc_linux_return_value);

d704 2
a705 2
      set_gdbarch_deprecated_frame_chain (gdbarch, ppc_linux_frame_chain);
      set_gdbarch_deprecated_frame_saved_pc (gdbarch, ppc_linux_frame_saved_pc);
d707 1
a707 1
      set_gdbarch_deprecated_frame_init_saved_regs (gdbarch,
d709 1
a709 1
      set_gdbarch_deprecated_init_extra_frame_info (gdbarch,
a713 4
      /* Shared library handling.  */
      set_gdbarch_in_solib_call_trampoline (gdbarch, in_plt_section);
      set_gdbarch_skip_trampoline_code (gdbarch,
                                        ppc_linux_skip_trampoline_code);
a716 15
  
  if (tdep->wordsize == 8)
    {
      /* Handle PPC64 GNU/Linux function pointers (which are really
         function descriptors).  */
      set_gdbarch_convert_from_func_ptr_addr
        (gdbarch, ppc64_linux_convert_from_func_ptr_addr);

      set_gdbarch_in_solib_call_trampoline
        (gdbarch, ppc64_in_solib_call_trampoline);
      set_gdbarch_skip_trampoline_code (gdbarch, ppc64_skip_trampoline_code);

      /* PPC64 malloc's entry-point is called ".malloc".  */
      set_gdbarch_name_of_malloc (gdbarch, ".malloc");
    }
d722 2
a723 8
  /* Register for all sub-familes of the POWER/PowerPC: 32-bit and
     64-bit PowerPC, and the older rs6k.  */
  gdbarch_register_osabi (bfd_arch_powerpc, bfd_mach_ppc, GDB_OSABI_LINUX,
                         ppc_linux_init_abi);
  gdbarch_register_osabi (bfd_arch_powerpc, bfd_mach_ppc64, GDB_OSABI_LINUX,
                         ppc_linux_init_abi);
  gdbarch_register_osabi (bfd_arch_rs6000, bfd_mach_rs6k, GDB_OSABI_LINUX,
                         ppc_linux_init_abi);
@


1.19.8.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d146 2
a147 2
   the frame's type (if a SIGTRAMP_FRAME).  Because of our strange
   definition of in_sigtramp below, we can't rely on the frame's type
d149 1
a149 6
   take pains to set it in init_extra_frame_info().

   NOTE: cagney/2002-11-10: I suspect the real problem here is that
   the get_prev_frame() only initializes the frame's type after the
   call to INIT_FRAME_INFO.  get_prev_frame() should be fixed, this
   code shouldn't be working its way around a bug :-(.  */
d321 1
a321 1
  if ((get_frame_type (fi) == SIGTRAMP_FRAME))
d328 1
a328 1
  else if (fi->next && (get_frame_type (fi->next) == SIGTRAMP_FRAME))
d350 1
a350 1
	deprecated_set_frame_type (fi, SIGTRAMP_FRAME);
d352 1
a352 3
	/* FIXME: cagney/2002-11-10: Is this double bogus?  What
           happens if the frame has previously been marked as a dummy?  */
	deprecated_set_frame_type (fi, NORMAL_FRAME);
d370 1
a370 1
  if ((get_frame_type (fi) == SIGTRAMP_FRAME))
d408 1
a408 1
  if ((get_frame_type (thisframe) == SIGTRAMP_FRAME))
d722 1
a722 1
  gdbarch_register_osabi (bfd_arch_powerpc, 0, GDB_OSABI_LINUX,
@


1.19.8.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d4 1
a4 1
   1997, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
a33 1
#include "osabi.h"
d38 4
a41 9
/* The following instructions are used in the signal trampoline code
   on GNU/Linux PPC. The kernel used to use magic syscalls 0x6666 and
   0x7777 but now uses the sigreturn syscalls.  We check for both.  */
#define INSTR_LI_R0_0x6666		0x38006666
#define INSTR_LI_R0_0x7777		0x38007777
#define INSTR_LI_R0_NR_sigreturn	0x38000077
#define INSTR_LI_R0_NR_rt_sigreturn	0x380000AC

#define INSTR_SC			0x44000002
a184 15
static inline int
insn_is_sigreturn (unsigned long pcinsn)
{
  switch(pcinsn)
    {
    case INSTR_LI_R0_0x6666:
    case INSTR_LI_R0_0x7777:
    case INSTR_LI_R0_NR_sigreturn:
    case INSTR_LI_R0_NR_rt_sigreturn:
      return 1;
    default:
      return 0;
    }
}

d204 1
a204 1
	   (insn_is_sigreturn (pcinsn)
d208 1
a208 1
	    && insn_is_sigreturn (extract_unsigned_integer (buf, 4))));
@


1.19.8.3
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d735 1
a735 1
      set_gdbarch_deprecated_frame_init_saved_regs (gdbarch,
d737 1
a737 1
      set_gdbarch_deprecated_init_extra_frame_info (gdbarch,
@


1.19.8.4
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d350 1
a350 2
	read_memory_integer (get_frame_base (fi)
			     + PPC_LINUX_REGS_PTR_OFFSET, 4);
d354 1
a354 2
  else if (get_next_frame (fi)
	   && (get_frame_type (get_next_frame (fi)) == SIGTRAMP_FRAME))
d357 1
a357 2
	read_memory_integer (get_frame_base (get_next_frame (fi))
			     + PPC_LINUX_REGS_PTR_OFFSET, 4);
d370 1
a370 1
  if (get_next_frame (fi) != 0)
d375 1
a375 1
      if (ppc_linux_at_sigtramp_return_path (get_frame_pc (fi)))
d389 1
a389 1
  if (ppc_linux_at_sigtramp_return_path (get_frame_pc (fi)))
d402 1
a402 1
      if (get_frame_saved_regs (fi))
d408 3
a410 4
	read_memory_integer (get_frame_base (fi)
			     + PPC_LINUX_REGS_PTR_OFFSET, 4);
      get_frame_saved_regs (fi)[PC_REGNUM] = regs_addr + 4 * PPC_LINUX_PT_NIP;
      get_frame_saved_regs (fi)[gdbarch_tdep (current_gdbarch)->ppc_ps_regnum] =
d412 1
a412 1
      get_frame_saved_regs (fi)[gdbarch_tdep (current_gdbarch)->ppc_cr_regnum] =
d414 1
a414 1
      get_frame_saved_regs (fi)[gdbarch_tdep (current_gdbarch)->ppc_lr_regnum] =
d416 1
a416 1
      get_frame_saved_regs (fi)[gdbarch_tdep (current_gdbarch)->ppc_ctr_regnum] =
d418 1
a418 1
      get_frame_saved_regs (fi)[gdbarch_tdep (current_gdbarch)->ppc_xer_regnum] =
d420 1
a420 1
      get_frame_saved_regs (fi)[gdbarch_tdep (current_gdbarch)->ppc_mq_regnum] =
d423 1
a423 1
	get_frame_saved_regs (fi)[gdbarch_tdep (current_gdbarch)->ppc_gp0_regnum + i] =
d426 1
a426 1
	get_frame_saved_regs (fi)[FP0_REGNUM + i] = regs_addr + 4 * PPC_LINUX_PT_FPR0 + 8 * i;
d437 1
a437 1
    return read_memory_integer (get_frame_base (thisframe), 4);
d732 2
a733 2
      set_gdbarch_deprecated_frame_chain (gdbarch, ppc_linux_frame_chain);
      set_gdbarch_deprecated_frame_saved_pc (gdbarch, ppc_linux_frame_saved_pc);
@


1.19.8.5
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d232 1
a232 1
static CORE_ADDR
d298 1
a298 1
  reloc = extract_unsigned_integer (buf, 4);
a634 309

/* Macros for matching instructions.  Note that, since all the
   operands are masked off before they're or-ed into the instruction,
   you can use -1 to make masks.  */

#define insn_d(opcd, rts, ra, d)                \
  ((((opcd) & 0x3f) << 26)                      \
   | (((rts) & 0x1f) << 21)                     \
   | (((ra) & 0x1f) << 16)                      \
   | ((d) & 0xffff))

#define insn_ds(opcd, rts, ra, d, xo)           \
  ((((opcd) & 0x3f) << 26)                      \
   | (((rts) & 0x1f) << 21)                     \
   | (((ra) & 0x1f) << 16)                      \
   | ((d) & 0xfffc)                             \
   | ((xo) & 0x3))

#define insn_xfx(opcd, rts, spr, xo)            \
  ((((opcd) & 0x3f) << 26)                      \
   | (((rts) & 0x1f) << 21)                     \
   | (((spr) & 0x1f) << 16)                     \
   | (((spr) & 0x3e0) << 6)                     \
   | (((xo) & 0x3ff) << 1))

/* Read a PPC instruction from memory.  PPC instructions are always
   big-endian, no matter what endianness the program is running in, so
   we can't use read_memory_integer or one of its friends here.  */
static unsigned int
read_insn (CORE_ADDR pc)
{
  unsigned char buf[4];

  read_memory (pc, buf, 4);
  return (buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | buf[3];
}


/* An instruction to match.  */
struct insn_pattern
{
  unsigned int mask;            /* mask the insn with this... */
  unsigned int data;            /* ...and see if it matches this. */
  int optional;                 /* If non-zero, this insn may be absent.  */
};

/* Return non-zero if the instructions at PC match the series
   described in PATTERN, or zero otherwise.  PATTERN is an array of
   'struct insn_pattern' objects, terminated by an entry whose mask is
   zero.

   When the match is successful, fill INSN[i] with what PATTERN[i]
   matched.  If PATTERN[i] is optional, and the instruction wasn't
   present, set INSN[i] to 0 (which is not a valid PPC instruction).
   INSN should have as many elements as PATTERN.  Note that, if
   PATTERN contains optional instructions which aren't present in
   memory, then INSN will have holes, so INSN[i] isn't necessarily the
   i'th instruction in memory.  */
static int
insns_match_pattern (CORE_ADDR pc,
                     struct insn_pattern *pattern,
                     unsigned int *insn)
{
  int i;

  for (i = 0; pattern[i].mask; i++)
    {
      insn[i] = read_insn (pc);
      if ((insn[i] & pattern[i].mask) == pattern[i].data)
        pc += 4;
      else if (pattern[i].optional)
        insn[i] = 0;
      else
        return 0;
    }

  return 1;
}


/* Return the 'd' field of the d-form instruction INSN, properly
   sign-extended.  */
static CORE_ADDR
insn_d_field (unsigned int insn)
{
  return ((((CORE_ADDR) insn & 0xffff) ^ 0x8000) - 0x8000);
}


/* Return the 'ds' field of the ds-form instruction INSN, with the two
   zero bits concatenated at the right, and properly
   sign-extended.  */
static CORE_ADDR
insn_ds_field (unsigned int insn)
{
  return ((((CORE_ADDR) insn & 0xfffc) ^ 0x8000) - 0x8000);
}


/* If DESC is the address of a 64-bit PowerPC GNU/Linux function
   descriptor, return the descriptor's entry point.  */
static CORE_ADDR
ppc64_desc_entry_point (CORE_ADDR desc)
{
  /* The first word of the descriptor is the entry point.  */
  return (CORE_ADDR) read_memory_unsigned_integer (desc, 8);
}


/* Pattern for the standard linkage function.  These are built by
   build_plt_stub in elf64-ppc.c, whose GLINK argument is always
   zero.  */
static struct insn_pattern ppc64_standard_linkage[] =
  {
    /* addis r12, r2, <any> */
    { insn_d (-1, -1, -1, 0), insn_d (15, 12, 2, 0), 0 },

    /* std r2, 40(r1) */
    { -1, insn_ds (62, 2, 1, 40, 0), 0 },

    /* ld r11, <any>(r12) */
    { insn_ds (-1, -1, -1, 0, -1), insn_ds (58, 11, 12, 0, 0), 0 },

    /* addis r12, r12, 1 <optional> */
    { insn_d (-1, -1, -1, -1), insn_d (15, 12, 2, 1), 1 },

    /* ld r2, <any>(r12) */
    { insn_ds (-1, -1, -1, 0, -1), insn_ds (58, 2, 12, 0, 0), 0 },

    /* addis r12, r12, 1 <optional> */
    { insn_d (-1, -1, -1, -1), insn_d (15, 12, 2, 1), 1 },

    /* mtctr r11 */
    { insn_xfx (-1, -1, -1, -1), insn_xfx (31, 11, 9, 467),
      0 },

    /* ld r11, <any>(r12) */
    { insn_ds (-1, -1, -1, 0, -1), insn_ds (58, 11, 12, 0, 0), 0 },
      
    /* bctr */
    { -1, 0x4e800420, 0 },

    { 0, 0, 0 }
  };
#define PPC64_STANDARD_LINKAGE_LEN \
  (sizeof (ppc64_standard_linkage) / sizeof (ppc64_standard_linkage[0]))


/* Recognize a 64-bit PowerPC GNU/Linux linkage function --- what GDB
   calls a "solib trampoline".  */
static int
ppc64_in_solib_call_trampoline (CORE_ADDR pc, char *name)
{
  /* Detecting solib call trampolines on PPC64 GNU/Linux is a pain.

     It's not specifically solib call trampolines that are the issue.
     Any call from one function to another function that uses a
     different TOC requires a trampoline, to save the caller's TOC
     pointer and then load the callee's TOC.  An executable or shared
     library may have more than one TOC, so even intra-object calls
     may require a trampoline.  Since executable and shared libraries
     will all have their own distinct TOCs, every inter-object call is
     also an inter-TOC call, and requires a trampoline --- so "solib
     call trampolines" are just a special case.

     The 64-bit PowerPC GNU/Linux ABI calls these call trampolines
     "linkage functions".  Since they need to be near the functions
     that call them, they all appear in .text, not in any special
     section.  The .plt section just contains an array of function
     descriptors, from which the linkage functions load the callee's
     entry point, TOC value, and environment pointer.  So
     in_plt_section is useless.  The linkage functions don't have any
     special linker symbols to name them, either.

     The only way I can see to recognize them is to actually look at
     their code.  They're generated by ppc_build_one_stub and some
     other functions in bfd/elf64-ppc.c, so that should show us all
     the instruction sequences we need to recognize.  */
  unsigned int insn[PPC64_STANDARD_LINKAGE_LEN];

  return insns_match_pattern (pc, ppc64_standard_linkage, insn);
}


/* When the dynamic linker is doing lazy symbol resolution, the first
   call to a function in another object will go like this:

   - The user's function calls the linkage function:

     100007c4:	4b ff fc d5 	bl	10000498
     100007c8:	e8 41 00 28 	ld	r2,40(r1)

   - The linkage function loads the entry point (and other stuff) from
     the function descriptor in the PLT, and jumps to it:

     10000498:	3d 82 00 00 	addis	r12,r2,0
     1000049c:	f8 41 00 28 	std	r2,40(r1)
     100004a0:	e9 6c 80 98 	ld	r11,-32616(r12)
     100004a4:	e8 4c 80 a0 	ld	r2,-32608(r12)
     100004a8:	7d 69 03 a6 	mtctr	r11
     100004ac:	e9 6c 80 a8 	ld	r11,-32600(r12)
     100004b0:	4e 80 04 20 	bctr

   - But since this is the first time that PLT entry has been used, it
     sends control to its glink entry.  That loads the number of the
     PLT entry and jumps to the common glink0 code:

     10000c98:	38 00 00 00 	li	r0,0
     10000c9c:	4b ff ff dc 	b	10000c78

   - The common glink0 code then transfers control to the dynamic
     linker's fixup code:

     10000c78:	e8 41 00 28 	ld	r2,40(r1)
     10000c7c:	3d 82 00 00 	addis	r12,r2,0
     10000c80:	e9 6c 80 80 	ld	r11,-32640(r12)
     10000c84:	e8 4c 80 88 	ld	r2,-32632(r12)
     10000c88:	7d 69 03 a6 	mtctr	r11
     10000c8c:	e9 6c 80 90 	ld	r11,-32624(r12)
     10000c90:	4e 80 04 20 	bctr

   Eventually, this code will figure out how to skip all of this,
   including the dynamic linker.  At the moment, we just get through
   the linkage function.  */

/* If the current thread is about to execute a series of instructions
   at PC matching the ppc64_standard_linkage pattern, and INSN is the result
   from that pattern match, return the code address to which the
   standard linkage function will send them.  (This doesn't deal with
   dynamic linker lazy symbol resolution stubs.)  */
static CORE_ADDR
ppc64_standard_linkage_target (CORE_ADDR pc, unsigned int *insn)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

  /* The address of the function descriptor this linkage function
     references.  */
  CORE_ADDR desc
    = ((CORE_ADDR) read_register (tdep->ppc_gp0_regnum + 2)
       + (insn_d_field (insn[0]) << 16)
       + insn_ds_field (insn[2]));

  /* The first word of the descriptor is the entry point.  Return that.  */
  return ppc64_desc_entry_point (desc);
}


/* Given that we've begun executing a call trampoline at PC, return
   the entry point of the function the trampoline will go to.  */
static CORE_ADDR
ppc64_skip_trampoline_code (CORE_ADDR pc)
{
  unsigned int ppc64_standard_linkage_insn[PPC64_STANDARD_LINKAGE_LEN];

  if (insns_match_pattern (pc, ppc64_standard_linkage,
                           ppc64_standard_linkage_insn))
    return ppc64_standard_linkage_target (pc, ppc64_standard_linkage_insn);
  else
    return 0;
}


/* Support for CONVERT_FROM_FUNC_PTR_ADDR(ADDR) on PPC64 GNU/Linux.

   Usually a function pointer's representation is simply the address
   of the function. On GNU/Linux on the 64-bit PowerPC however, a
   function pointer is represented by a pointer to a TOC entry. This
   TOC entry contains three words, the first word is the address of
   the function, the second word is the TOC pointer (r2), and the
   third word is the static chain value.  Throughout GDB it is
   currently assumed that a function pointer contains the address of
   the function, which is not easy to fix.  In addition, the
   conversion of a function address to a function pointer would
   require allocation of a TOC entry in the inferior's memory space,
   with all its drawbacks.  To be able to call C++ virtual methods in
   the inferior (which are called via function pointers),
   find_function_addr uses this function to get the function address
   from a function pointer.  */

/* Return real function address if ADDR (a function pointer) is in the data
   space and is therefore a special function pointer.  */

static CORE_ADDR
ppc64_linux_convert_from_func_ptr_addr (CORE_ADDR addr)
{
  struct obj_section *s;

  s = find_pc_section (addr);
  if (s && s->the_bfd_section->flags & SEC_CODE)
    return addr;

  /* ADDR is in the data space, so it's a pointer to a descriptor, not
     the entry point.  */
  return ppc64_desc_entry_point (addr);
}


/* On 64-bit PowerPC GNU/Linux, the ELF header's e_entry field is the
   address of a function descriptor for the entry point function, not
   the actual entry point itself.  So to find the actual address at
   which execution should begin, we need to fetch the function's entry
   point from that descriptor.  */
static CORE_ADDR
ppc64_call_dummy_address (void)
{
  return ppc64_desc_entry_point (entry_point_address ());
}


a745 4
      /* Shared library handling.  */
      set_gdbarch_in_solib_call_trampoline (gdbarch, in_plt_section);
      set_gdbarch_skip_trampoline_code (gdbarch,
                                        ppc_linux_skip_trampoline_code);
a747 14
    }
  
  if (tdep->wordsize == 8)
    {
      /* Handle PPC64 GNU/Linux function pointers (which are really
         function descriptors).  */
      set_gdbarch_convert_from_func_ptr_addr
        (gdbarch, ppc64_linux_convert_from_func_ptr_addr);

      set_gdbarch_call_dummy_address (gdbarch, ppc64_call_dummy_address);

      set_gdbarch_in_solib_call_trampoline
        (gdbarch, ppc64_in_solib_call_trampoline);
      set_gdbarch_skip_trampoline_code (gdbarch, ppc64_skip_trampoline_code);
@


1.19.8.6
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d191 1
a191 1
static int
a593 14
/* For historic reasons, PPC 32 GNU/Linux follows PowerOpen rather
   than the 32 bit SYSV R4 ABI structure return convention - all
   structures, no matter their size, are put in memory.  Vectors,
   which were added later, do get returned in a register though.  */

static int     
ppc_linux_use_struct_convention (int gcc_p, struct type *value_type)
{  
  if ((TYPE_LENGTH (value_type) == 16 || TYPE_LENGTH (value_type) == 8)
      && TYPE_VECTOR (value_type))
    return 0;                            
  return 1;
}

d932 12
d1032 7
a1040 9
      /* Until November 2001, gcc did not comply with the 32 bit SysV
	 R4 ABI requirement that structures less than or equal to 8
	 bytes should be returned in registers.  Instead GCC was using
	 the the AIX/PowerOpen ABI - everything returned in memory
	 (well ignoring vectors that is).  When this was corrected, it
	 wasn't fixed for GNU/Linux native platform.  Use the
	 PowerOpen struct convention.  */
      set_gdbarch_use_struct_convention (gdbarch, ppc_linux_use_struct_convention);

d1069 2
@


1.19.8.7
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d334 1
a334 1
  msymbol = lookup_minimal_symbol_text (symname, NULL);
d405 1
a405 1
      if (deprecated_get_frame_saved_regs (fi))
d413 2
a414 2
      deprecated_get_frame_saved_regs (fi)[PC_REGNUM] = regs_addr + 4 * PPC_LINUX_PT_NIP;
      deprecated_get_frame_saved_regs (fi)[gdbarch_tdep (current_gdbarch)->ppc_ps_regnum] =
d416 1
a416 1
      deprecated_get_frame_saved_regs (fi)[gdbarch_tdep (current_gdbarch)->ppc_cr_regnum] =
d418 1
a418 1
      deprecated_get_frame_saved_regs (fi)[gdbarch_tdep (current_gdbarch)->ppc_lr_regnum] =
d420 1
a420 1
      deprecated_get_frame_saved_regs (fi)[gdbarch_tdep (current_gdbarch)->ppc_ctr_regnum] =
d422 1
a422 1
      deprecated_get_frame_saved_regs (fi)[gdbarch_tdep (current_gdbarch)->ppc_xer_regnum] =
d424 1
a424 1
      deprecated_get_frame_saved_regs (fi)[gdbarch_tdep (current_gdbarch)->ppc_mq_regnum] =
d427 1
a427 1
	deprecated_get_frame_saved_regs (fi)[gdbarch_tdep (current_gdbarch)->ppc_gp0_regnum + i] =
d430 1
a430 1
	deprecated_get_frame_saved_regs (fi)[FP0_REGNUM + i] = regs_addr + 4 * PPC_LINUX_PT_FPR0 + 8 * i;
d599 2
a600 3
static enum return_value_convention
ppc_linux_return_value (struct gdbarch *gdbarch, struct type *valtype,
			struct regcache *regcache, const void *inval, void *outval)
d602 4
a605 7
  if ((TYPE_CODE (valtype) == TYPE_CODE_STRUCT
       || TYPE_CODE (valtype) == TYPE_CODE_UNION)
      && !((TYPE_LENGTH (valtype) == 16 || TYPE_LENGTH (valtype) == 8)
	   && TYPE_VECTOR (valtype)))
    return RETURN_VALUE_STRUCT_CONVENTION;
  else
    return ppc_sysv_abi_return_value (gdbarch, valtype, regcache, inval, outval);
d911 1
a911 2
/* Support for CONVERT_FROM_FUNC_PTR_ADDR (ARCH, ADDR, TARG) on PPC64
   GNU/Linux.
d928 2
a929 4
/* If ADDR points at what is clearly a function descriptor, transform
   it into the address of the corresponding function.  Be
   conservative, otherwize GDB will do the transformation on any
   random addresses such as occures when there is no symbol table.  */
d932 1
a932 3
ppc64_linux_convert_from_func_ptr_addr (struct gdbarch *gdbarch,
					CORE_ADDR addr,
					struct target_ops *targ)
d934 1
a934 1
  struct section_table *s = target_section_by_addr (targ, addr);
d936 3
a938 3
  /* Check if ADDR points to a function descriptor.  */
  if (s && strcmp (s->the_bfd_section->name, ".opd") == 0)
    return get_target_memory_unsigned (targ, addr, 8);
d940 3
a942 1
  return addr;
d1043 1
a1043 1
      set_gdbarch_return_value (gdbarch, ppc_linux_return_value);
d1083 2
a1084 8
  /* Register for all sub-familes of the POWER/PowerPC: 32-bit and
     64-bit PowerPC, and the older rs6k.  */
  gdbarch_register_osabi (bfd_arch_powerpc, bfd_mach_ppc, GDB_OSABI_LINUX,
                         ppc_linux_init_abi);
  gdbarch_register_osabi (bfd_arch_powerpc, bfd_mach_ppc64, GDB_OSABI_LINUX,
                         ppc_linux_init_abi);
  gdbarch_register_osabi (bfd_arch_rs6000, bfd_mach_rs6k, GDB_OSABI_LINUX,
                         ppc_linux_init_abi);
@


1.19.8.8
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d601 1
a601 2
			struct regcache *regcache, void *readbuf,
			const void *writebuf)
d609 1
a609 2
    return ppc_sysv_abi_return_value (gdbarch, valtype, regcache, readbuf,
				      writebuf);
a1083 3

      /* PPC64 malloc's entry-point is called ".malloc".  */
      set_gdbarch_name_of_malloc (gdbarch, ".malloc");
@


1.18
log
@* Makefile.in (ppc_tdep_h): Define.
(ppc-linux-nat.o)
(ppc-linux-tdep.o)
(rs6000-tdep.o): Use $(ppc_tdep_h).
(ppc-sysv-tdep.o)
(ppcnbsd-nat.o)
(ppcnbsd-tdep.o): New dependency lists.
* ppc-tdep.h: Use generic OS ABI framework.
* ppc-linux-tdep.c (_initialize_ppc_linux_tdep,
ppc_linux_init_abi): New functions.
(ppc_sysv_abi_broken_use_struct_convention)
(ppc_sysv_abi_use_struct_convention)
(ppc_sysv_abi_push_arguments): Move to...
* ppc-sysv-tdep.c: ...here.
* ppcnbsd-nat.c: Don't include gdbcore.h and regcache.h.
* rs6000-tdep.c (process_note_abi_tag_sections)
(get_elfosabi): Remove.
(rs6000_gdbarch_init): Use generic OS ABI framework.
(rs6000_dump_tdep): New function.
(_initialize_rs6000_tdep): Use gdbarch_register.
* config/powerpc/linux.mt (TDEPFILES): Add ppc-sysv-tdep.o.
* config/powerpc/nbsd.mh (NATDEPFILES): Remove solib-legacy.o.
* config/powerpc/aix.mt (TDEPFILES): Use ppc-sysv-tdep.o instead
of ppc-linux-tdep.o.
* config/powerpc/nbsd.mt (TDEPFILES): Likewise.
* config/powerpc/ppc-eabi.mt (TDEPFILES): Likewise.
* config/powerpc/ppc-sim.mt (TDEPFILES): Likewise.
* config/powerpc/ppcle-eabi.mt (TDEPFILES): Likewise.
* config/powerpc/ppcle-sim.mt (TDEPFILES): Likewise.
* config/powerpc/vxworks.mt (TDEPFILES): Likewise.
@
text
@d603 82
d724 1
@


1.17
log
@2002-04-29  Elena Zannoni  <ezannoni@@redhat.com>

	* rs6000-tdep.c (rs6000_extract_return_value,
	rs6000_store_return_value): Handle returning vectors.
	(rs6000_gdbarch_init): Use
	ppc_sysv_abi_broken_use_struct_convention for native sysv cases.
	* ppc-linux-tdep.c (ppc_sysv_abi_broken_use_struct_convention):
	New function.
	(ppc_sysv_abi_use_struct_convention): Deal with functions returning
	vectors.
	(ppc_sysv_abi_push_arguments): Handle vector parameters.
	* ppc-tdep.h (ppc_sysv_abi_broken_use_struct_convention): Export.
@
text
@a413 287
/* FIXME: Move the following to rs6000-tdep.c (or some other file where
   it may be used generically by ports which use either the SysV ABI or
   the EABI */

/* Until November 2001, gcc was not complying to the SYSV ABI for
   returning structures less than or equal to 8 bytes in size.  It was
   returning everything in memory.  When this was corrected, it wasn't
   fixed for native platforms.  */
int
ppc_sysv_abi_broken_use_struct_convention (int gcc_p, struct type *value_type)
{
  if (TYPE_LENGTH (value_type) == 16
      && TYPE_VECTOR (value_type))
    return 0;

  return generic_use_struct_convention (gcc_p, value_type);
}

/* Structures 8 bytes or less long are returned in the r3 & r4
   registers, according to the SYSV ABI. */
int
ppc_sysv_abi_use_struct_convention (int gcc_p, struct type *value_type)
{
  if (TYPE_LENGTH (value_type) == 16
      && TYPE_VECTOR (value_type))
    return 0;

  return (TYPE_LENGTH (value_type) > 8);
}

/* round2 rounds x up to the nearest multiple of s assuming that s is a
   power of 2 */

#undef round2
#define round2(x,s) ((((long) (x) - 1) & ~(long)((s)-1)) + (s))

/* Pass the arguments in either registers, or in the stack. Using the
   ppc sysv ABI, the first eight words of the argument list (that might
   be less than eight parameters if some parameters occupy more than one
   word) are passed in r3..r10 registers.  float and double parameters are
   passed in fpr's, in addition to that. Rest of the parameters if any
   are passed in user stack. 

   If the function is returning a structure, then the return address is passed
   in r3, then the first 7 words of the parametes can be passed in registers,
   starting from r4. */

CORE_ADDR
ppc_sysv_abi_push_arguments (int nargs, struct value **args, CORE_ADDR sp,
			     int struct_return, CORE_ADDR struct_addr)
{
  int argno;
  /* Next available general register for non-float, non-vector arguments. */
  int greg;
  /* Next available floating point register for float arguments. */
  int freg;
  /* Next available vector register for vector arguments. */
  int vreg;
  int argstkspace;
  int structstkspace;
  int argoffset;
  int structoffset;
  struct value *arg;
  struct type *type;
  int len;
  char old_sp_buf[4];
  CORE_ADDR saved_sp;

  greg = struct_return ? 4 : 3;
  freg = 1;
  vreg = 2;
  argstkspace = 0;
  structstkspace = 0;

  /* Figure out how much new stack space is required for arguments
     which don't fit in registers.  Unlike the PowerOpen ABI, the
     SysV ABI doesn't reserve any extra space for parameters which
     are put in registers. */
  for (argno = 0; argno < nargs; argno++)
    {
      arg = args[argno];
      type = check_typedef (VALUE_TYPE (arg));
      len = TYPE_LENGTH (type);

      if (TYPE_CODE (type) == TYPE_CODE_FLT)
	{
	  if (freg <= 8)
	    freg++;
	  else
	    {
	      /* SysV ABI converts floats to doubles when placed in
	         memory and requires 8 byte alignment */
	      if (argstkspace & 0x4)
		argstkspace += 4;
	      argstkspace += 8;
	    }
	}
      else if (TYPE_CODE (type) == TYPE_CODE_INT && len == 8)	/* long long */
	{
	  if (greg > 9)
	    {
	      greg = 11;
	      if (argstkspace & 0x4)
		argstkspace += 4;
	      argstkspace += 8;
	    }
	  else
	    {
	      if ((greg & 1) == 0)
		greg++;
	      greg += 2;
	    }
	}
      else if (!TYPE_VECTOR (type))
        {
	  if (len > 4
	      || TYPE_CODE (type) == TYPE_CODE_STRUCT
	      || TYPE_CODE (type) == TYPE_CODE_UNION)
	    {
	      /* Rounding to the nearest multiple of 8 may not be necessary,
		 but it is safe.  Particularly since we don't know the
		 field types of the structure */
	      structstkspace += round2 (len, 8);
	    }
	  if (greg <= 10)
	    greg++;
	  else
	    argstkspace += 4;
    	}
      else
        {
          if (len == 16
	      && TYPE_CODE (type) == TYPE_CODE_ARRAY
	      && TYPE_VECTOR (type))
	    {
	      if (vreg <= 13)
		vreg++;
	      else
		{
		  /* Vector arguments must be aligned to 16 bytes on
                     the stack. */
		  argstkspace += round2 (argstkspace, 16);
		  argstkspace += 16;
		}
	    }
	}
    }

  /* Get current SP location */
  saved_sp = read_sp ();

  sp -= argstkspace + structstkspace;

  /* Allocate space for backchain and callee's saved lr */
  sp -= 8;

  /* Make sure that we maintain 16 byte alignment */
  sp &= ~0x0f;

  /* Update %sp before proceeding any further */
  write_register (SP_REGNUM, sp);

  /* write the backchain */
  store_address (old_sp_buf, 4, saved_sp);
  write_memory (sp, old_sp_buf, 4);

  argoffset = 8;
  structoffset = argoffset + argstkspace;
  freg = 1;
  greg = 3;
  vreg = 2;
  /* Fill in r3 with the return structure, if any */
  if (struct_return)
    {
      char val_buf[4];
      store_address (val_buf, 4, struct_addr);
      memcpy (&registers[REGISTER_BYTE (greg)], val_buf, 4);
      greg++;
    }
  /* Now fill in the registers and stack... */
  for (argno = 0; argno < nargs; argno++)
    {
      arg = args[argno];
      type = check_typedef (VALUE_TYPE (arg));
      len = TYPE_LENGTH (type);

      if (TYPE_CODE (type) == TYPE_CODE_FLT)
	{
	  if (freg <= 8)
	    {
	      if (len > 8)
		printf_unfiltered (
				   "Fatal Error: a floating point parameter #%d with a size > 8 is found!\n", argno);
	      memcpy (&registers[REGISTER_BYTE (FP0_REGNUM + freg)],
		      VALUE_CONTENTS (arg), len);
	      freg++;
	    }
	  else
	    {
	      /* SysV ABI converts floats to doubles when placed in
	         memory and requires 8 byte alignment */
	      /* FIXME: Convert floats to doubles */
	      if (argoffset & 0x4)
		argoffset += 4;
	      write_memory (sp + argoffset, (char *) VALUE_CONTENTS (arg), len);
	      argoffset += 8;
	    }
	}
      else if (TYPE_CODE (type) == TYPE_CODE_INT && len == 8)	/* long long */
	{
	  if (greg > 9)
	    {
	      greg = 11;
	      if (argoffset & 0x4)
		argoffset += 4;
	      write_memory (sp + argoffset, (char *) VALUE_CONTENTS (arg), len);
	      argoffset += 8;
	    }
	  else
	    {
	      if ((greg & 1) == 0)
		greg++;

	      memcpy (&registers[REGISTER_BYTE (greg)],
		      VALUE_CONTENTS (arg), 4);
	      memcpy (&registers[REGISTER_BYTE (greg + 1)],
		      VALUE_CONTENTS (arg) + 4, 4);
	      greg += 2;
	    }
	}
      else if (!TYPE_VECTOR (type))
	{
	  char val_buf[4];
	  if (len > 4
	      || TYPE_CODE (type) == TYPE_CODE_STRUCT
	      || TYPE_CODE (type) == TYPE_CODE_UNION)
	    {
	      write_memory (sp + structoffset, VALUE_CONTENTS (arg), len);
	      store_address (val_buf, 4, sp + structoffset);
	      structoffset += round2 (len, 8);
	    }
	  else
	    {
	      memset (val_buf, 0, 4);
	      memcpy (val_buf, VALUE_CONTENTS (arg), len);
	    }
	  if (greg <= 10)
	    {
	      memcpy (&registers[REGISTER_BYTE (greg)], val_buf, 4);
	      greg++;
	    }
	  else
	    {
	      write_memory (sp + argoffset, val_buf, 4);
	      argoffset += 4;
	    }
	}
      else
	{
	  if (len == 16
	      && TYPE_CODE (type) == TYPE_CODE_ARRAY
	      && TYPE_VECTOR (type))
	    {
	      struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
	      char *v_val_buf = alloca (16);
	      memset (v_val_buf, 0, 16);
	      memcpy (v_val_buf, VALUE_CONTENTS (arg), len);
	      if (vreg <= 13)
		{
		  memcpy (&registers[REGISTER_BYTE (tdep->ppc_vr0_regnum
						    + vreg)],
			  v_val_buf, 16);
		  vreg++;
		}
	      else
		{
		  write_memory (sp + argoffset, v_val_buf, 16);
		  argoffset += 16;
		}
	    }
        }
    }

  target_store_registers (-1);
  return sp;
}

d601 41
@


1.17.6.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d414 287
a887 41
}

static void
ppc_linux_init_abi (struct gdbarch_info info,
                    struct gdbarch *gdbarch)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  /* Until November 2001, gcc was not complying to the SYSV ABI for
     returning structures less than or equal to 8 bytes in size. It was
     returning everything in memory. When this was corrected, it wasn't
     fixed for native platforms.  */
  set_gdbarch_use_struct_convention (gdbarch,
                                   ppc_sysv_abi_broken_use_struct_convention);

  if (tdep->wordsize == 4)
    {
      /* Note: kevinb/2002-04-12: See note in rs6000_gdbarch_init regarding
	 *_push_arguments().  The same remarks hold for the methods below.  */
      set_gdbarch_frameless_function_invocation (gdbarch,
        ppc_linux_frameless_function_invocation);
      set_gdbarch_frame_chain (gdbarch, ppc_linux_frame_chain);
      set_gdbarch_frame_saved_pc (gdbarch, ppc_linux_frame_saved_pc);

      set_gdbarch_frame_init_saved_regs (gdbarch,
                                         ppc_linux_frame_init_saved_regs);
      set_gdbarch_init_extra_frame_info (gdbarch,
                                         ppc_linux_init_extra_frame_info);

      set_gdbarch_memory_remove_breakpoint (gdbarch,
                                            ppc_linux_memory_remove_breakpoint);
      set_solib_svr4_fetch_link_map_offsets
        (gdbarch, ppc_linux_svr4_fetch_link_map_offsets);
    }
}

void
_initialize_ppc_linux_tdep (void)
{
  gdbarch_register_osabi (bfd_arch_powerpc, GDB_OSABI_LINUX,
			  ppc_linux_init_abi);
@


1.17.6.2
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@a602 82
enum {
  ELF_NGREG = 48,
  ELF_NFPREG = 33,
  ELF_NVRREG = 33
};

enum {
  ELF_GREGSET_SIZE = (ELF_NGREG * 4),
  ELF_FPREGSET_SIZE = (ELF_NFPREG * 8)
};

void
ppc_linux_supply_gregset (char *buf)
{
  int regi;
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 

  for (regi = 0; regi < 32; regi++)
    supply_register (regi, buf + 4 * regi);

  supply_register (PC_REGNUM, buf + 4 * PPC_LINUX_PT_NIP);
  supply_register (tdep->ppc_lr_regnum, buf + 4 * PPC_LINUX_PT_LNK);
  supply_register (tdep->ppc_cr_regnum, buf + 4 * PPC_LINUX_PT_CCR);
  supply_register (tdep->ppc_xer_regnum, buf + 4 * PPC_LINUX_PT_XER);
  supply_register (tdep->ppc_ctr_regnum, buf + 4 * PPC_LINUX_PT_CTR);
  if (tdep->ppc_mq_regnum != -1)
    supply_register (tdep->ppc_mq_regnum, buf + 4 * PPC_LINUX_PT_MQ);
  supply_register (tdep->ppc_ps_regnum, buf + 4 * PPC_LINUX_PT_MSR);
}

void
ppc_linux_supply_fpregset (char *buf)
{
  int regi;
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 

  for (regi = 0; regi < 32; regi++)
    supply_register (FP0_REGNUM + regi, buf + 8 * regi);

  /* The FPSCR is stored in the low order word of the last doubleword in the
     fpregset.  */
  supply_register (tdep->ppc_fpscr_regnum, buf + 8 * 32 + 4);
}

/*
  Use a local version of this function to get the correct types for regsets.
*/

static void
fetch_core_registers (char *core_reg_sect,
		      unsigned core_reg_size,
		      int which,
		      CORE_ADDR reg_addr)
{
  if (which == 0)
    {
      if (core_reg_size == ELF_GREGSET_SIZE)
	ppc_linux_supply_gregset (core_reg_sect);
      else
	warning ("wrong size gregset struct in core file");
    }
  else if (which == 2)
    {
      if (core_reg_size == ELF_FPREGSET_SIZE)
	ppc_linux_supply_fpregset (core_reg_sect);
      else
	warning ("wrong size fpregset struct in core file");
    }
}

/* Register that we are able to handle ELF file formats using standard
   procfs "regset" structures.  */

static struct core_fns ppc_linux_regset_core_fns =
{
  bfd_target_elf_flavour,	/* core_flavour */
  default_check_format,		/* check_format */
  default_core_sniffer,		/* core_sniffer */
  fetch_core_registers,		/* core_read_registers */
  NULL				/* next */
};

a641 1
  add_core_fns (&ppc_linux_regset_core_fns);
@


1.17.4.1
log
@merge from trunk
@
text
@d414 287
a887 41
}

static void
ppc_linux_init_abi (struct gdbarch_info info,
                    struct gdbarch *gdbarch)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  /* Until November 2001, gcc was not complying to the SYSV ABI for
     returning structures less than or equal to 8 bytes in size. It was
     returning everything in memory. When this was corrected, it wasn't
     fixed for native platforms.  */
  set_gdbarch_use_struct_convention (gdbarch,
                                   ppc_sysv_abi_broken_use_struct_convention);

  if (tdep->wordsize == 4)
    {
      /* Note: kevinb/2002-04-12: See note in rs6000_gdbarch_init regarding
	 *_push_arguments().  The same remarks hold for the methods below.  */
      set_gdbarch_frameless_function_invocation (gdbarch,
        ppc_linux_frameless_function_invocation);
      set_gdbarch_frame_chain (gdbarch, ppc_linux_frame_chain);
      set_gdbarch_frame_saved_pc (gdbarch, ppc_linux_frame_saved_pc);

      set_gdbarch_frame_init_saved_regs (gdbarch,
                                         ppc_linux_frame_init_saved_regs);
      set_gdbarch_init_extra_frame_info (gdbarch,
                                         ppc_linux_init_extra_frame_info);

      set_gdbarch_memory_remove_breakpoint (gdbarch,
                                            ppc_linux_memory_remove_breakpoint);
      set_solib_svr4_fetch_link_map_offsets
        (gdbarch, ppc_linux_svr4_fetch_link_map_offsets);
    }
}

void
_initialize_ppc_linux_tdep (void)
{
  gdbarch_register_osabi (bfd_arch_powerpc, GDB_OSABI_LINUX,
			  ppc_linux_init_abi);
@


1.16
log
@* arch-utils.h: Update copyright.

* gdbarch.sh (PC_IN_SIGTRAMP): Add.
* gdbarch.h, gdbarch.c: Re-generate.

* inferior.h (IN_SIGTRAMP): Delete definition.
* arch-utils.c (legacy_pc_in_sigtramp): New function.
* arch-utils.h (legacy_pc_in_sigtramp): Declare.

* mips-tdep.c (mips_init_extra_frame_info): Use PC_IN_SIGTRAMP.
(mips_dump_tdep): Do not print value of IN_SIGTRAMP.
* hppa-tdep.c (pc_in_interrupt_handler):  Use PC_IN_SIGTRAMP.
(find_proc_framesize): Ditto.
* alpha-tdep.c (alpha_osf_skip_sigtramp_frame): Ditto.
(alpha_init_extra_frame_info): Ditto.
* infrun.c (handle_inferior_event): Ditto.
(handle_inferior_event): Ditto.
(check_sigtramp2): Ditto.
* blockframe.c (create_new_frame): Ditto.
(get_prev_frame): Ditto.
* ppc-linux-tdep.c: Update comments.
* i386-linux-tdep.c: Update comments.
* breakpoint.c (bpstat_what): Update comment.

* gdbint.texinfo (Target Architecture Definition): Replace
IN_SIGTRAMP with PC_IN_SIGTRAMP.
@
text
@d418 14
d437 4
d466 6
a471 1
  int greg, freg;
d484 1
d527 2
a528 2
      else
	{
d534 2
a535 2
	         but it is safe.  Particularly since we don't know the
	         field types of the structure */
d542 17
d584 1
d606 1
a606 1
				    "Fatal Error: a floating point parameter #%d with a size > 8 is found!\n", argno);
d644 1
a644 1
      else
a661 1
	      *(int *) &registers[REGISTER_BYTE (greg)] = 0;
d671 24
@


1.15
log
@* gdbarch.sh (BREAKPOINT_FROM_PC): Return a const buffer.
* gdbarch.h, gdbarch.c: Regenerate.

* defs.h (breakpoint_from_pc_fn): Delete type definition.
* target.h (memory_breakpoint_from_pc): Update declaration.
* config/mcore/tm-mcore.h (mcore_breakpoint_from_p): Ditto.

* arch-utils.c (legacy_breakpoint_from_pc): Update return type.
* mcore-tdep.c (mcore_breakpoint_from_pc): Ditto.
* mem-break.c (memory_breakpoint_from_pc): Ditto.
* rs6000-tdep.c (rs6000_breakpoint_from_pc): Ditto.
* s390-tdep.c (s390_breakpoint_from_pc): Ditto
* xstormy16-tdep.c (xstormy16_breakpoint_from_pc): Ditto.
* mn10300-tdep.c (mn10300_breakpoint_from_pc): Ditto.
* mips-tdep.c (mips_breakpoint_from_pc): Ditto.
* m68hc11-tdep.c (m68hc11_breakpoint_from_pc): Ditto.
* ia64-tdep.c (ia64_breakpoint_from_pc): Ditto.
* d10v-tdep.c (d10v_breakpoint_from_pc): Ditto.
* arch-utils.c (legacy_breakpoint_from_pc): Ditto..

* mem-break.c (default_memory_insert_breakpoint): Make `bp' a
const pointer.
* monitor.c (monitor_insert_breakpoint): Ditto.
* rs6000-tdep.c (rs6000_software_single_step): Ditto for `breakp'.

* config/mcore/tm-mcore.h: Update copyright.
* mem-break.c: Ditto.
* xstormy16-tdep.c: Ditto.
@
text
@d109 5
a113 4
   infrun.c calls IN_SIGTRAMP in order to detect entry into a signal
   trampoline just after delivery of a signal.  But on GNU/Linux,
   signal trampolines are used for the return path only.  The kernel
   sets things up so that the signal handler is called directly.
d145 1
a145 1
   IN_SIGTRAMP is called from blockframe.c as well in order to set
d147 3
a149 3
   of in_sigtramp below, we can't rely on signal_handler_caller getting
   set correctly from within blockframe.c.  This is why we take pains
   to set it in init_extra_frame_info().  */
@


1.14
log
@2002-03-22  Elena Zannoni  <ezannoni@@redhat.com>

        * ppc-linux-tdep.c (ppc_sysv_abi_use_struct_convention): New
        function.
	* ppc-tdep.h (ppc_sysv_abi_use_struct_convention): Export.
        * rs6000-tdep.c (rs6000_gdbarch_init): Use different
        structure returning convention for SYSV ABI case, but not
        for GNU/Linux, FreeBSD, or NetBSD.
@
text
@d762 1
a762 1
  unsigned char *bp;
@


1.13
log
@s/Linux/.../
Fix PR gdb/378.
@
text
@d417 8
@


1.12
log
@2001-12-09  Elena Zannoni  <ezannoni@@redhat.com>

	* config/rs6000/tm-rs6000.h (STAB_REG_TO_REGNUM): Remove
	definition, it is now multiarched.
	* ppc-tdep.h (struct gdbarch_tdep): Move from rs6000-tdep.c.  Add
	fields for special register numbers.
	* rs6000-tdep.c (rs6000_gdbarch_init): Initialize new tdep special
	regnum fields.
	(rs6000_saved_pc_after_call): Use gdbarch_tdep registers fields
	instead of hardcoded macros.
	(branch_dest, rs6000_pop_frame, rs6000_fix_call_dummy,
	ppc_push_return_address, rs6000_frame_saved_pc,
	frame_get_saved_regs, rs6000_frame_chain,
	rs6000_store_return_value): Ditto.
	(rs6000_stab_reg_to_regnum): New function.
	* ppcnbsd-nat.c (fetch_inferior_registers,
	store_inferior_registers, fetch_core_registers): Ditto.
	* ppc-linux-tdep.c (ppc_linux_in_sigtramp,
	ppc_linux_frame_init_saved_regs): Ditto.
	* ppc-linux-nat.c (ppc_register_u_addr, supply_gregset,
	fill_gregset): Ditto.
	* ppc-bdm.c (bdm_ppc_fetch_registers, bdm_ppc_store_registers):
	Ditto.
@
text
@d3 2
a4 2
   Copyright 1986, 1987, 1989, 1991, 1992, 1993, 1994, 1995, 1996, 1997,
   2000, 2001 Free Software Foundation, Inc.
d39 1
a39 1
   code on linux/ppc */
d108 5
a112 5
   Ha!  That's not what this does at all.  wait_for_inferior in infrun.c
   calls IN_SIGTRAMP in order to detect entry into a signal trampoline
   just after delivery of a signal.  But on linux, signal trampolines
   are used for the return path only.  The kernel sets things up so that
   the signal handler is called directly.
d776 1
a776 1
   structure for Linux/PPC targets using the struct offsets
d779 3
a781 2
   This makes it possible to access Linux/PPC shared libraries from a
   GDB that was not built on an Linux/PPC host (for cross debugging).  */
@


1.11
log
@Add cross platform SVR4 shared library support for PowerPC.
@
text
@d159 1
a159 1
  lr = read_register (PPC_LR_REGNUM);
d381 12
a392 6
      fi->saved_regs[PPC_PS_REGNUM] = regs_addr + 4 * PPC_LINUX_PT_MSR;
      fi->saved_regs[PPC_CR_REGNUM] = regs_addr + 4 * PPC_LINUX_PT_CCR;
      fi->saved_regs[PPC_LR_REGNUM] = regs_addr + 4 * PPC_LINUX_PT_LNK;
      fi->saved_regs[PPC_CTR_REGNUM] = regs_addr + 4 * PPC_LINUX_PT_CTR;
      fi->saved_regs[PPC_XER_REGNUM] = regs_addr + 4 * PPC_LINUX_PT_XER;
      fi->saved_regs[PPC_MQ_REGNUM] = regs_addr + 4 * PPC_LINUX_PT_MQ;
d394 2
a395 1
	fi->saved_regs[PPC_GP0_REGNUM + i] = regs_addr + 4 * PPC_LINUX_PT_R0 + 4 * i;
@


1.10
log
@Add explicit #include of "value.h".
@
text
@d35 1
d766 40
@


1.9
log
@s/value_ptr/struct value */
@
text
@d33 1
@


1.8
log
@Update/correct copyright notices.
@
text
@d426 1
a426 1
ppc_sysv_abi_push_arguments (int nargs, value_ptr *args, CORE_ADDR sp,
d435 1
a435 1
  value_ptr arg;
@


1.7
log
@Create new file regcache.h.  Update all uses.
@
text
@d3 2
a4 2
   Copyright 1986, 1987, 1989, 1991, 1992, 1993, 1994, 1995, 1996,
   1997, 2000, 2001 Free Software Foundation, Inc.
@


1.6
log
@Make GNU/Linux/PPC work again.
@
text
@d2 3
a4 2
   Copyright 1986, 1987, 1989, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 2000
   Free Software Foundation, Inc.
d32 1
@


1.5
log
@Protoization.
@
text
@d32 2
d100 1
a100 1
int ppc_linux_at_sigtramp_return_path (CORE_ADDR pc);
d155 1
a155 1
  lr = read_register (LR_REGNUM);
d182 1
a182 1
int
d313 1
a313 1
unsigned long
d377 6
a382 6
      fi->saved_regs[PS_REGNUM] = regs_addr + 4 * PPC_LINUX_PT_MSR;
      fi->saved_regs[CR_REGNUM] = regs_addr + 4 * PPC_LINUX_PT_CCR;
      fi->saved_regs[LR_REGNUM] = regs_addr + 4 * PPC_LINUX_PT_LNK;
      fi->saved_regs[CTR_REGNUM] = regs_addr + 4 * PPC_LINUX_PT_CTR;
      fi->saved_regs[XER_REGNUM] = regs_addr + 4 * PPC_LINUX_PT_XER;
      fi->saved_regs[MQ_REGNUM] = regs_addr + 4 * PPC_LINUX_PT_MQ;
d384 1
a384 1
	fi->saved_regs[GP0_REGNUM + i] = regs_addr + 4 * PPC_LINUX_PT_R0 + 4 * i;
@


1.4
log
@Add comment explaining ppc_linux_memory_remove_breakpoint ().
@
text
@d422 2
a423 6
ppc_sysv_abi_push_arguments (nargs, args, sp, struct_return, struct_addr)
     int nargs;
     value_ptr *args;
     CORE_ADDR sp;
     int struct_return;
     CORE_ADDR struct_addr;
@


1.3
log
@Shared library, function calling fixes for GNU/Linux PPC port.
@
text
@d618 124
a741 2
/* This version of ppc_linux_memory_remove_breakpoints handles the
   case of self modifying code */
@


1.2
log
@Cleanups and signal handler backtrace fix for GNU/Linux PPC port.
@
text
@d525 8
d616 26
@


1.1
log
@Changes for GNU/Linux PPC native port of gdb.
@
text
@d98 2
d317 1
a317 1
      read_memory_integer (fi->frame + PPC_LINUX_REGS_PTR_OFFSET, 4);
d321 9
a329 2

  return rs6000_frame_saved_pc (fi);
@
