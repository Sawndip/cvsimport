head	1.62;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.62
	gdb_7_6-2013-04-26-release:1.62
	gdb_7_6-branch:1.62.0.2
	gdb_7_6-2013-03-12-branchpoint:1.62
	gdb_7_5_1-2012-11-29-release:1.60
	gdb_7_5-2012-08-17-release:1.60
	gdb_7_5-branch:1.60.0.2
	gdb_7_5-2012-07-18-branchpoint:1.60
	gdb_7_4_1-2012-04-26-release:1.56.2.1
	gdb_7_4-2012-01-24-release:1.56.2.1
	gdb_7_4-branch:1.56.0.2
	gdb_7_4-2011-12-13-branchpoint:1.56
	gdb_7_3_1-2011-09-04-release:1.53
	gdb_7_3-2011-07-26-release:1.53
	gdb_7_3-branch:1.53.0.2
	gdb_7_3-2011-04-01-branchpoint:1.53
	gdb_7_2-2010-09-02-release:1.47
	gdb_7_2-branch:1.47.0.2
	gdb_7_2-2010-07-07-branchpoint:1.47
	gdb_7_1-2010-03-18-release:1.46
	gdb_7_1-branch:1.46.0.2
	gdb_7_1-2010-02-18-branchpoint:1.46
	gdb_7_0_1-2009-12-22-release:1.45
	gdb_7_0-2009-10-06-release:1.45
	gdb_7_0-branch:1.45.0.4
	gdb_7_0-2009-09-16-branchpoint:1.45
	arc-sim-20090309:1.36
	msnyder-checkpoint-072509-branch:1.45.0.2
	msnyder-checkpoint-072509-branchpoint:1.45
	arc-insight_6_8-branch:1.36.0.6
	arc-insight_6_8-branchpoint:1.36
	insight_6_8-branch:1.36.0.4
	insight_6_8-branchpoint:1.36
	reverse-20081226-branch:1.40.0.6
	reverse-20081226-branchpoint:1.40
	multiprocess-20081120-branch:1.40.0.4
	multiprocess-20081120-branchpoint:1.40
	reverse-20080930-branch:1.40.0.2
	reverse-20080930-branchpoint:1.40
	reverse-20080717-branch:1.39.0.4
	reverse-20080717-branchpoint:1.39
	msnyder-reverse-20080609-branch:1.39.0.2
	msnyder-reverse-20080609-branchpoint:1.39
	drow-reverse-20070409-branch:1.29.0.2
	drow-reverse-20070409-branchpoint:1.29
	gdb_6_8-2008-03-27-release:1.36
	gdb_6_8-branch:1.36.0.2
	gdb_6_8-2008-02-26-branchpoint:1.36
	gdb_6_7_1-2007-10-29-release:1.31
	gdb_6_7-2007-10-10-release:1.31
	gdb_6_7-branch:1.31.0.2
	gdb_6_7-2007-09-07-branchpoint:1.31
	insight_6_6-20070208-release:1.27
	gdb_6_6-2006-12-18-release:1.27
	gdb_6_6-branch:1.27.0.2
	gdb_6_6-2006-11-15-branchpoint:1.27
	insight_6_5-20061003-release:1.26
	gdb-csl-symbian-6_4_50_20060226-12:1.25
	gdb-csl-sourcerygxx-3_4_4-25:1.24
	nickrob-async-20060828-mergepoint:1.27
	gdb-csl-symbian-6_4_50_20060226-11:1.25
	gdb-csl-sourcerygxx-4_1-17:1.25
	gdb-csl-20060226-branch-local-2:1.25
	gdb-csl-sourcerygxx-4_1-14:1.25
	gdb-csl-sourcerygxx-4_1-13:1.25
	gdb-csl-sourcerygxx-4_1-12:1.25
	gdb-csl-sourcerygxx-3_4_4-21:1.25
	gdb_6_5-20060621-release:1.26
	gdb-csl-sourcerygxx-4_1-9:1.25
	gdb-csl-sourcerygxx-4_1-8:1.25
	gdb-csl-sourcerygxx-4_1-7:1.25
	gdb-csl-arm-2006q1-6:1.25
	gdb-csl-sourcerygxx-4_1-6:1.25
	gdb-csl-symbian-6_4_50_20060226-10:1.25
	gdb-csl-symbian-6_4_50_20060226-9:1.25
	gdb-csl-symbian-6_4_50_20060226-8:1.25
	gdb-csl-coldfire-4_1-11:1.25
	gdb-csl-sourcerygxx-3_4_4-19:1.25
	gdb-csl-coldfire-4_1-10:1.25
	gdb_6_5-branch:1.26.0.8
	gdb_6_5-2006-05-14-branchpoint:1.26
	gdb-csl-sourcerygxx-4_1-5:1.25
	nickrob-async-20060513-branch:1.26.0.6
	nickrob-async-20060513-branchpoint:1.26
	gdb-csl-sourcerygxx-4_1-4:1.25
	msnyder-reverse-20060502-branch:1.26.0.4
	msnyder-reverse-20060502-branchpoint:1.26
	gdb-csl-morpho-4_1-4:1.25
	gdb-csl-sourcerygxx-3_4_4-17:1.25
	readline_5_1-import-branch:1.26.0.2
	readline_5_1-import-branchpoint:1.26
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.25
	gdb-csl-symbian-20060226-branch:1.25.0.8
	gdb-csl-symbian-20060226-branchpoint:1.25
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.25
	msnyder-reverse-20060331-branch:1.25.0.6
	msnyder-reverse-20060331-branchpoint:1.25
	gdb-csl-available-20060303-branch:1.25.0.4
	gdb-csl-available-20060303-branchpoint:1.25
	gdb-csl-20060226-branch:1.25.0.2
	gdb-csl-20060226-branchpoint:1.25
	gdb_6_4-20051202-release:1.24
	msnyder-fork-checkpoint-branch:1.24.0.8
	msnyder-fork-checkpoint-branchpoint:1.24
	gdb-csl-gxxpro-6_3-branch:1.24.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.24
	gdb_6_4-branch:1.24.0.4
	gdb_6_4-2005-11-01-branchpoint:1.24
	gdb-csl-arm-20051020-branch:1.24.0.2
	gdb-csl-arm-20051020-branchpoint:1.24
	msnyder-tracepoint-checkpoint-branch:1.23.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.23
	gdb-csl-arm-20050325-2005-q1b:1.20
	gdb-csl-arm-20050325-2005-q1a:1.20
	csl-arm-20050325-branch:1.20.0.2
	csl-arm-20050325-branchpoint:1.20
	gdb-post-i18n-errorwarning-20050211:1.18
	gdb-pre-i18n-errorwarning-20050211:1.18
	gdb_6_3-20041109-release:1.14
	gdb_6_3-branch:1.14.0.4
	gdb_6_3-20041019-branchpoint:1.14
	drow_intercu-merge-20040921:1.14
	drow_intercu-merge-20040915:1.14
	jimb-gdb_6_2-e500-branch:1.14.0.6
	jimb-gdb_6_2-e500-branchpoint:1.14
	gdb_6_2-20040730-release:1.14
	gdb_6_2-branch:1.14.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.14
	gdb_6_1_1-20040616-release:1.10
	gdb_6_1-2004-04-05-release:1.10
	drow_intercu-merge-20040402:1.10
	drow_intercu-merge-20040327:1.10
	ezannoni_pie-20040323-branch:1.10.0.12
	ezannoni_pie-20040323-branchpoint:1.10
	cagney_tramp-20040321-mergepoint:1.10
	cagney_tramp-20040309-branch:1.10.0.10
	cagney_tramp-20040309-branchpoint:1.10
	gdb_6_1-branch:1.10.0.8
	gdb_6_1-2004-03-01-gmt-branchpoint:1.10
	drow_intercu-20040221-branch:1.10.0.6
	drow_intercu-20040221-branchpoint:1.10
	cagney_bfdfile-20040213-branch:1.10.0.4
	cagney_bfdfile-20040213-branchpoint:1.10
	drow-cplus-merge-20040208:1.10
	carlton_dictionary-20040126-merge:1.10
	cagney_bigcore-20040122-branch:1.10.0.2
	cagney_bigcore-20040122-branchpoint:1.10
	drow-cplus-merge-20040113:1.9
	drow-cplus-merge-20031224:1.3
	drow-cplus-merge-20031220:1.3
	carlton_dictionary-20031215-merge:1.3
	drow-cplus-branch:1.3.0.6
	drow-cplus-merge-20031214:1.3
	carlton-dictionary-20031111-merge:1.3
	kettenis_sparc-20030918-branch:1.3.0.4
	kettenis_sparc-20030918-branchpoint:1.3
	carlton_dictionary-branch:1.3.0.2
	carlton_dictionary-20030917-merge:1.3
	ezannoni_pie-20030916-branchpoint:1.2
	ezannoni_pie-20030916-branch:1.2.0.2;
locks; strict;
comment	@ * @;


1.62
date	2013.01.01.06.32.51;	author brobecke;	state Exp;
branches;
next	1.61;

1.61
date	2012.11.23.20.30.22;	author davem;	state Exp;
branches;
next	1.60;

1.60
date	2012.05.16.14.35.07;	author macro;	state Exp;
branches;
next	1.59;

1.59
date	2012.04.09.09.16.58;	author kettenis;	state Exp;
branches;
next	1.58;

1.58
date	2012.04.08.05.42.53;	author kettenis;	state Exp;
branches;
next	1.57;

1.57
date	2012.01.04.08.17.12;	author brobecke;	state Exp;
branches;
next	1.56;

1.56
date	2011.09.28.17.59.42;	author davem;	state Exp;
branches
	1.56.2.1;
next	1.55;

1.55
date	2011.06.27.16.36.00;	author brobecke;	state Exp;
branches;
next	1.54;

1.54
date	2011.05.21.19.19.45;	author kettenis;	state Exp;
branches;
next	1.53;

1.53
date	2011.03.18.18.52.32;	author palves;	state Exp;
branches;
next	1.52;

1.52
date	2011.03.18.18.38.44;	author palves;	state Exp;
branches;
next	1.51;

1.51
date	2011.02.26.02.07.08;	author msnyder;	state Exp;
branches;
next	1.50;

1.50
date	2011.01.11.21.53.24;	author msnyder;	state Exp;
branches;
next	1.49;

1.49
date	2011.01.01.15.33.15;	author brobecke;	state Exp;
branches;
next	1.48;

1.48
date	2010.10.01.15.55.14;	author brobecke;	state Exp;
branches;
next	1.47;

1.47
date	2010.05.05.16.58.59;	author brobecke;	state Exp;
branches;
next	1.46;

1.46
date	2010.01.01.07.31.42;	author brobecke;	state Exp;
branches;
next	1.45;

1.45
date	2009.07.02.17.25.58;	author uweigand;	state Exp;
branches;
next	1.44;

1.44
date	2009.07.02.12.55.30;	author uweigand;	state Exp;
branches;
next	1.43;

1.43
date	2009.07.02.12.52.52;	author uweigand;	state Exp;
branches;
next	1.42;

1.42
date	2009.07.02.12.46.19;	author uweigand;	state Exp;
branches;
next	1.41;

1.41
date	2009.01.03.05.57.53;	author brobecke;	state Exp;
branches;
next	1.40;

1.40
date	2008.09.11.14.23.15;	author uweigand;	state Exp;
branches;
next	1.39;

1.39
date	2008.05.07.19.30.04;	author brobecke;	state Exp;
branches;
next	1.38;

1.38
date	2008.04.30.21.18.28;	author drow;	state Exp;
branches;
next	1.37;

1.37
date	2008.04.22.11.03.42;	author corinna;	state Exp;
branches;
next	1.36;

1.36
date	2008.01.11.14.43.15;	author deuling;	state Exp;
branches;
next	1.35;

1.35
date	2008.01.11.13.20.02;	author deuling;	state Exp;
branches;
next	1.34;

1.34
date	2008.01.01.22.53.13;	author drow;	state Exp;
branches;
next	1.33;

1.33
date	2007.11.02.14.27.15;	author uweigand;	state Exp;
branches;
next	1.32;

1.32
date	2007.10.10.17.05.31;	author uweigand;	state Exp;
branches;
next	1.31;

1.31
date	2007.08.23.18.08.38;	author brobecke;	state Exp;
branches;
next	1.30;

1.30
date	2007.06.16.17.24.18;	author uweigand;	state Exp;
branches;
next	1.29;

1.29
date	2007.01.09.17.58.58;	author drow;	state Exp;
branches;
next	1.28;

1.28
date	2006.12.26.05.03.11;	author brobecke;	state Exp;
branches;
next	1.27;

1.27
date	2006.08.22.20.57.56;	author kettenis;	state Exp;
branches;
next	1.26;

1.26
date	2006.04.05.20.01.19;	author davem;	state Exp;
branches
	1.26.6.1;
next	1.25;

1.25
date	2005.12.17.22.34.02;	author eliz;	state Exp;
branches;
next	1.24;

1.24
date	2005.06.12.11.10.56;	author kettenis;	state Exp;
branches;
next	1.23;

1.23
date	2005.05.14.13.45.22;	author kettenis;	state Exp;
branches;
next	1.22;

1.22
date	2005.04.23.15.40.54;	author kettenis;	state Exp;
branches;
next	1.21;

1.21
date	2005.03.28.13.42.49;	author kettenis;	state Exp;
branches;
next	1.20;

1.20
date	2005.03.09.22.08.13;	author kettenis;	state Exp;
branches;
next	1.19;

1.19
date	2005.03.05.20.58.14;	author kettenis;	state Exp;
branches;
next	1.18;

1.18
date	2005.02.07.00.09.55;	author cagney;	state Exp;
branches;
next	1.17;

1.17
date	2005.01.16.20.08.20;	author kettenis;	state Exp;
branches;
next	1.16;

1.16
date	2004.11.13.02.15.33;	author cagney;	state Exp;
branches;
next	1.15;

1.15
date	2004.10.29.14.00.57;	author cagney;	state Exp;
branches;
next	1.14;

1.14
date	2004.06.24.19.36.41;	author kettenis;	state Exp;
branches;
next	1.13;

1.13
date	2004.06.24.19.32.37;	author kettenis;	state Exp;
branches;
next	1.12;

1.12
date	2004.06.07.02.02.55;	author tausq;	state Exp;
branches;
next	1.11;

1.11
date	2004.04.09.12.30.02;	author kettenis;	state Exp;
branches;
next	1.10;

1.10
date	2004.01.17.22.45.44;	author cagney;	state Exp;
branches
	1.10.6.1;
next	1.9;

1.9
date	2004.01.11.20.47.53;	author kettenis;	state Exp;
branches;
next	1.8;

1.8
date	2004.01.04.12.18.25;	author kettenis;	state Exp;
branches;
next	1.7;

1.7
date	2004.01.03.23.24.57;	author kettenis;	state Exp;
branches;
next	1.6;

1.6
date	2004.01.03.20.46.30;	author kettenis;	state Exp;
branches;
next	1.5;

1.5
date	2004.01.03.15.00.10;	author kettenis;	state Exp;
branches;
next	1.4;

1.4
date	2004.01.03.10.08.44;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2003.09.17.15.42.21;	author cagney;	state Exp;
branches
	1.3.2.1
	1.3.4.1
	1.3.6.1;
next	1.2;

1.2
date	2003.08.22.18.52.50;	author kettenis;	state Exp;
branches;
next	1.1;

1.1
date	2003.08.21.20.38.46;	author kettenis;	state Exp;
branches;
next	;

1.56.2.1
date	2012.01.06.04.43.30;	author brobecke;	state Exp;
branches;
next	;

1.26.6.1
date	2006.08.28.07.48.47;	author nickrob;	state Exp;
branches;
next	;

1.10.6.1
date	2004.09.16.17.01.22;	author drow;	state Exp;
branches;
next	;

1.3.2.1
date	2003.09.17.21.28.32;	author carlton;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2004.01.26.19.11.31;	author carlton;	state Exp;
branches;
next	;

1.3.4.1
date	2003.10.18.18.25.46;	author kettenis;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2003.11.02.20.26.32;	author kettenis;	state Exp;
branches;
next	1.3.4.3;

1.3.4.3
date	2003.12.15.20.41.41;	author kettenis;	state Exp;
branches;
next	1.3.4.4;

1.3.4.4
date	2003.12.21.23.13.59;	author kettenis;	state Exp;
branches;
next	1.3.4.5;

1.3.4.5
date	2003.12.26.21.12.07;	author kettenis;	state Exp;
branches;
next	1.3.4.6;

1.3.4.6
date	2004.01.01.20.51.54;	author kettenis;	state Exp;
branches;
next	1.3.4.7;

1.3.4.7
date	2004.01.01.21.06.17;	author kettenis;	state Exp;
branches;
next	;

1.3.6.1
date	2003.12.14.20.27.30;	author drow;	state Exp;
branches;
next	1.3.6.2;

1.3.6.2
date	2004.01.13.16.12.00;	author drow;	state Exp;
branches;
next	1.3.6.3;

1.3.6.3
date	2004.02.09.19.43.48;	author drow;	state Exp;
branches;
next	;


desc
@@


1.62
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@/* Target-dependent code for UltraSPARC.

   Copyright (C) 2003-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "arch-utils.h"
#include "dwarf2-frame.h"
#include "floatformat.h"
#include "frame.h"
#include "frame-base.h"
#include "frame-unwind.h"
#include "gdbcore.h"
#include "gdbtypes.h"
#include "inferior.h"
#include "symtab.h"
#include "objfiles.h"
#include "osabi.h"
#include "regcache.h"
#include "target.h"
#include "value.h"

#include "gdb_assert.h"
#include "gdb_string.h"

#include "sparc64-tdep.h"

/* This file implements the SPARC 64-bit ABI as defined by the
   section "Low-Level System Information" of the SPARC Compliance
   Definition (SCD) 2.4.1, which is the 64-bit System V psABI for
   SPARC.  */

/* Please use the sparc32_-prefix for 32-bit specific code, the
   sparc64_-prefix for 64-bit specific code and the sparc_-prefix for
   code can handle both.  */

/* The functions on this page are intended to be used to classify
   function arguments.  */

/* Check whether TYPE is "Integral or Pointer".  */

static int
sparc64_integral_or_pointer_p (const struct type *type)
{
  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_INT:
    case TYPE_CODE_BOOL:
    case TYPE_CODE_CHAR:
    case TYPE_CODE_ENUM:
    case TYPE_CODE_RANGE:
      {
	int len = TYPE_LENGTH (type);
	gdb_assert (len == 1 || len == 2 || len == 4 || len == 8);
      }
      return 1;
    case TYPE_CODE_PTR:
    case TYPE_CODE_REF:
      {
	int len = TYPE_LENGTH (type);
	gdb_assert (len == 8);
      }
      return 1;
    default:
      break;
    }

  return 0;
}

/* Check whether TYPE is "Floating".  */

static int
sparc64_floating_p (const struct type *type)
{
  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_FLT:
      {
	int len = TYPE_LENGTH (type);
	gdb_assert (len == 4 || len == 8 || len == 16);
      }
      return 1;
    default:
      break;
    }

  return 0;
}

/* Check whether TYPE is "Complex Floating".  */

static int
sparc64_complex_floating_p (const struct type *type)
{
  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_COMPLEX:
      {
	int len = TYPE_LENGTH (type);
	gdb_assert (len == 8 || len == 16 || len == 32);
      }
      return 1;
    default:
      break;
    }

  return 0;
}

/* Check whether TYPE is "Structure or Union".

   In terms of Ada subprogram calls, arrays are treated the same as
   struct and union types.  So this function also returns non-zero
   for array types.  */

static int
sparc64_structure_or_union_p (const struct type *type)
{
  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_STRUCT:
    case TYPE_CODE_UNION:
    case TYPE_CODE_ARRAY:
      return 1;
    default:
      break;
    }

  return 0;
}


/* Construct types for ISA-specific registers.  */

static struct type *
sparc64_pstate_type (struct gdbarch *gdbarch)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  if (!tdep->sparc64_pstate_type)
    {
      struct type *type;

      type = arch_flags_type (gdbarch, "builtin_type_sparc64_pstate", 8);
      append_flags_type_flag (type, 0, "AG");
      append_flags_type_flag (type, 1, "IE");
      append_flags_type_flag (type, 2, "PRIV");
      append_flags_type_flag (type, 3, "AM");
      append_flags_type_flag (type, 4, "PEF");
      append_flags_type_flag (type, 5, "RED");
      append_flags_type_flag (type, 8, "TLE");
      append_flags_type_flag (type, 9, "CLE");
      append_flags_type_flag (type, 10, "PID0");
      append_flags_type_flag (type, 11, "PID1");

      tdep->sparc64_pstate_type = type;
    }

  return tdep->sparc64_pstate_type;
}

static struct type *
sparc64_fsr_type (struct gdbarch *gdbarch)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  if (!tdep->sparc64_fsr_type)
    {
      struct type *type;

      type = arch_flags_type (gdbarch, "builtin_type_sparc64_fsr", 8);
      append_flags_type_flag (type, 0, "NXA");
      append_flags_type_flag (type, 1, "DZA");
      append_flags_type_flag (type, 2, "UFA");
      append_flags_type_flag (type, 3, "OFA");
      append_flags_type_flag (type, 4, "NVA");
      append_flags_type_flag (type, 5, "NXC");
      append_flags_type_flag (type, 6, "DZC");
      append_flags_type_flag (type, 7, "UFC");
      append_flags_type_flag (type, 8, "OFC");
      append_flags_type_flag (type, 9, "NVC");
      append_flags_type_flag (type, 22, "NS");
      append_flags_type_flag (type, 23, "NXM");
      append_flags_type_flag (type, 24, "DZM");
      append_flags_type_flag (type, 25, "UFM");
      append_flags_type_flag (type, 26, "OFM");
      append_flags_type_flag (type, 27, "NVM");

      tdep->sparc64_fsr_type = type;
    }

  return tdep->sparc64_fsr_type;
}

static struct type *
sparc64_fprs_type (struct gdbarch *gdbarch)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  if (!tdep->sparc64_fprs_type)
    {
      struct type *type;

      type = arch_flags_type (gdbarch, "builtin_type_sparc64_fprs", 8);
      append_flags_type_flag (type, 0, "DL");
      append_flags_type_flag (type, 1, "DU");
      append_flags_type_flag (type, 2, "FEF");

      tdep->sparc64_fprs_type = type;
    }

  return tdep->sparc64_fprs_type;
}


/* Register information.  */

static const char *sparc64_register_names[] =
{
  "g0", "g1", "g2", "g3", "g4", "g5", "g6", "g7",
  "o0", "o1", "o2", "o3", "o4", "o5", "sp", "o7",
  "l0", "l1", "l2", "l3", "l4", "l5", "l6", "l7",
  "i0", "i1", "i2", "i3", "i4", "i5", "fp", "i7",

  "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7",
  "f8", "f9", "f10", "f11", "f12", "f13", "f14", "f15",
  "f16", "f17", "f18", "f19", "f20", "f21", "f22", "f23",
  "f24", "f25", "f26", "f27", "f28", "f29", "f30", "f31",
  "f32", "f34", "f36", "f38", "f40", "f42", "f44", "f46",
  "f48", "f50", "f52", "f54", "f56", "f58", "f60", "f62",

  "pc", "npc",
  
  /* FIXME: Give "state" a name until we start using register groups.  */
  "state",
  "fsr",
  "fprs",
  "y",
};

/* Total number of registers.  */
#define SPARC64_NUM_REGS ARRAY_SIZE (sparc64_register_names)

/* We provide the aliases %d0..%d62 and %q0..%q60 for the floating
   registers as "psuedo" registers.  */

static const char *sparc64_pseudo_register_names[] =
{
  "cwp", "pstate", "asi", "ccr",

  "d0", "d2", "d4", "d6", "d8", "d10", "d12", "d14",
  "d16", "d18", "d20", "d22", "d24", "d26", "d28", "d30",
  "d32", "d34", "d36", "d38", "d40", "d42", "d44", "d46",
  "d48", "d50", "d52", "d54", "d56", "d58", "d60", "d62",

  "q0", "q4", "q8", "q12", "q16", "q20", "q24", "q28",
  "q32", "q36", "q40", "q44", "q48", "q52", "q56", "q60",
};

/* Total number of pseudo registers.  */
#define SPARC64_NUM_PSEUDO_REGS ARRAY_SIZE (sparc64_pseudo_register_names)

/* Return the name of register REGNUM.  */

static const char *
sparc64_register_name (struct gdbarch *gdbarch, int regnum)
{
  if (regnum >= 0 && regnum < SPARC64_NUM_REGS)
    return sparc64_register_names[regnum];

  if (regnum >= SPARC64_NUM_REGS
      && regnum < SPARC64_NUM_REGS + SPARC64_NUM_PSEUDO_REGS)
    return sparc64_pseudo_register_names[regnum - SPARC64_NUM_REGS];

  return NULL;
}

/* Return the GDB type object for the "standard" data type of data in
   register REGNUM.  */

static struct type *
sparc64_register_type (struct gdbarch *gdbarch, int regnum)
{
  /* Raw registers.  */

  if (regnum == SPARC_SP_REGNUM || regnum == SPARC_FP_REGNUM)
    return builtin_type (gdbarch)->builtin_data_ptr;
  if (regnum >= SPARC_G0_REGNUM && regnum <= SPARC_I7_REGNUM)
    return builtin_type (gdbarch)->builtin_int64;
  if (regnum >= SPARC_F0_REGNUM && regnum <= SPARC_F31_REGNUM)
    return builtin_type (gdbarch)->builtin_float;
  if (regnum >= SPARC64_F32_REGNUM && regnum <= SPARC64_F62_REGNUM)
    return builtin_type (gdbarch)->builtin_double;
  if (regnum == SPARC64_PC_REGNUM || regnum == SPARC64_NPC_REGNUM)
    return builtin_type (gdbarch)->builtin_func_ptr;
  /* This raw register contains the contents of %cwp, %pstate, %asi
     and %ccr as laid out in a %tstate register.  */
  if (regnum == SPARC64_STATE_REGNUM)
    return builtin_type (gdbarch)->builtin_int64;
  if (regnum == SPARC64_FSR_REGNUM)
    return sparc64_fsr_type (gdbarch);
  if (regnum == SPARC64_FPRS_REGNUM)
    return sparc64_fprs_type (gdbarch);
  /* "Although Y is a 64-bit register, its high-order 32 bits are
     reserved and always read as 0."  */
  if (regnum == SPARC64_Y_REGNUM)
    return builtin_type (gdbarch)->builtin_int64;

  /* Pseudo registers.  */

  if (regnum == SPARC64_CWP_REGNUM)
    return builtin_type (gdbarch)->builtin_int64;
  if (regnum == SPARC64_PSTATE_REGNUM)
    return sparc64_pstate_type (gdbarch);
  if (regnum == SPARC64_ASI_REGNUM)
    return builtin_type (gdbarch)->builtin_int64;
  if (regnum == SPARC64_CCR_REGNUM)
    return builtin_type (gdbarch)->builtin_int64;
  if (regnum >= SPARC64_D0_REGNUM && regnum <= SPARC64_D62_REGNUM)
    return builtin_type (gdbarch)->builtin_double;
  if (regnum >= SPARC64_Q0_REGNUM && regnum <= SPARC64_Q60_REGNUM)
    return builtin_type (gdbarch)->builtin_long_double;

  internal_error (__FILE__, __LINE__, _("invalid regnum"));
}

static enum register_status
sparc64_pseudo_register_read (struct gdbarch *gdbarch,
			      struct regcache *regcache,
			      int regnum, gdb_byte *buf)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  enum register_status status;

  gdb_assert (regnum >= SPARC64_NUM_REGS);

  if (regnum >= SPARC64_D0_REGNUM && regnum <= SPARC64_D30_REGNUM)
    {
      regnum = SPARC_F0_REGNUM + 2 * (regnum - SPARC64_D0_REGNUM);
      status = regcache_raw_read (regcache, regnum, buf);
      if (status == REG_VALID)
	status = regcache_raw_read (regcache, regnum + 1, buf + 4);
      return status;
    }
  else if (regnum >= SPARC64_D32_REGNUM && regnum <= SPARC64_D62_REGNUM)
    {
      regnum = SPARC64_F32_REGNUM + (regnum - SPARC64_D32_REGNUM);
      return regcache_raw_read (regcache, regnum, buf);
    }
  else if (regnum >= SPARC64_Q0_REGNUM && regnum <= SPARC64_Q28_REGNUM)
    {
      regnum = SPARC_F0_REGNUM + 4 * (regnum - SPARC64_Q0_REGNUM);

      status = regcache_raw_read (regcache, regnum, buf);
      if (status == REG_VALID)
	status = regcache_raw_read (regcache, regnum + 1, buf + 4);
      if (status == REG_VALID)
	status = regcache_raw_read (regcache, regnum + 2, buf + 8);
      if (status == REG_VALID)
	status = regcache_raw_read (regcache, regnum + 3, buf + 12);

      return status;
    }
  else if (regnum >= SPARC64_Q32_REGNUM && regnum <= SPARC64_Q60_REGNUM)
    {
      regnum = SPARC64_F32_REGNUM + 2 * (regnum - SPARC64_Q32_REGNUM);

      status = regcache_raw_read (regcache, regnum, buf);
      if (status == REG_VALID)
	status = regcache_raw_read (regcache, regnum + 1, buf + 8);

      return status;
    }
  else if (regnum == SPARC64_CWP_REGNUM
	   || regnum == SPARC64_PSTATE_REGNUM
	   || regnum == SPARC64_ASI_REGNUM
	   || regnum == SPARC64_CCR_REGNUM)
    {
      ULONGEST state;

      status = regcache_raw_read_unsigned (regcache, SPARC64_STATE_REGNUM, &state);
      if (status != REG_VALID)
	return status;

      switch (regnum)
	{
	case SPARC64_CWP_REGNUM:
	  state = (state >> 0) & ((1 << 5) - 1);
	  break;
	case SPARC64_PSTATE_REGNUM:
	  state = (state >> 8) & ((1 << 12) - 1);
	  break;
	case SPARC64_ASI_REGNUM:
	  state = (state >> 24) & ((1 << 8) - 1);
	  break;
	case SPARC64_CCR_REGNUM:
	  state = (state >> 32) & ((1 << 8) - 1);
	  break;
	}
      store_unsigned_integer (buf, 8, byte_order, state);
    }

  return REG_VALID;
}

static void
sparc64_pseudo_register_write (struct gdbarch *gdbarch,
			       struct regcache *regcache,
			       int regnum, const gdb_byte *buf)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  gdb_assert (regnum >= SPARC64_NUM_REGS);

  if (regnum >= SPARC64_D0_REGNUM && regnum <= SPARC64_D30_REGNUM)
    {
      regnum = SPARC_F0_REGNUM + 2 * (regnum - SPARC64_D0_REGNUM);
      regcache_raw_write (regcache, regnum, buf);
      regcache_raw_write (regcache, regnum + 1, buf + 4);
    }
  else if (regnum >= SPARC64_D32_REGNUM && regnum <= SPARC64_D62_REGNUM)
    {
      regnum = SPARC64_F32_REGNUM + (regnum - SPARC64_D32_REGNUM);
      regcache_raw_write (regcache, regnum, buf);
    }
  else if (regnum >= SPARC64_Q0_REGNUM && regnum <= SPARC64_Q28_REGNUM)
    {
      regnum = SPARC_F0_REGNUM + 4 * (regnum - SPARC64_Q0_REGNUM);
      regcache_raw_write (regcache, regnum, buf);
      regcache_raw_write (regcache, regnum + 1, buf + 4);
      regcache_raw_write (regcache, regnum + 2, buf + 8);
      regcache_raw_write (regcache, regnum + 3, buf + 12);
    }
  else if (regnum >= SPARC64_Q32_REGNUM && regnum <= SPARC64_Q60_REGNUM)
    {
      regnum = SPARC64_F32_REGNUM + 2 * (regnum - SPARC64_Q32_REGNUM);
      regcache_raw_write (regcache, regnum, buf);
      regcache_raw_write (regcache, regnum + 1, buf + 8);
    }
  else if (regnum == SPARC64_CWP_REGNUM
	   || regnum == SPARC64_PSTATE_REGNUM
	   || regnum == SPARC64_ASI_REGNUM
	   || regnum == SPARC64_CCR_REGNUM)
    {
      ULONGEST state, bits;

      regcache_raw_read_unsigned (regcache, SPARC64_STATE_REGNUM, &state);
      bits = extract_unsigned_integer (buf, 8, byte_order);
      switch (regnum)
	{
	case SPARC64_CWP_REGNUM:
	  state |= ((bits & ((1 << 5) - 1)) << 0);
	  break;
	case SPARC64_PSTATE_REGNUM:
	  state |= ((bits & ((1 << 12) - 1)) << 8);
	  break;
	case SPARC64_ASI_REGNUM:
	  state |= ((bits & ((1 << 8) - 1)) << 24);
	  break;
	case SPARC64_CCR_REGNUM:
	  state |= ((bits & ((1 << 8) - 1)) << 32);
	  break;
	}
      regcache_raw_write_unsigned (regcache, SPARC64_STATE_REGNUM, state);
    }
}


/* Return PC of first real instruction of the function starting at
   START_PC.  */

static CORE_ADDR
sparc64_skip_prologue (struct gdbarch *gdbarch, CORE_ADDR start_pc)
{
  struct symtab_and_line sal;
  CORE_ADDR func_start, func_end;
  struct sparc_frame_cache cache;

  /* This is the preferred method, find the end of the prologue by
     using the debugging information.  */
  if (find_pc_partial_function (start_pc, NULL, &func_start, &func_end))
    {
      sal = find_pc_line (func_start, 0);

      if (sal.end < func_end
	  && start_pc <= sal.end)
	return sal.end;
    }

  return sparc_analyze_prologue (gdbarch, start_pc, 0xffffffffffffffffULL,
				 &cache);
}

/* Normal frames.  */

static struct sparc_frame_cache *
sparc64_frame_cache (struct frame_info *this_frame, void **this_cache)
{
  return sparc_frame_cache (this_frame, this_cache);
}

static void
sparc64_frame_this_id (struct frame_info *this_frame, void **this_cache,
		       struct frame_id *this_id)
{
  struct sparc_frame_cache *cache =
    sparc64_frame_cache (this_frame, this_cache);

  /* This marks the outermost frame.  */
  if (cache->base == 0)
    return;

  (*this_id) = frame_id_build (cache->base, cache->pc);
}

static struct value *
sparc64_frame_prev_register (struct frame_info *this_frame, void **this_cache,
			     int regnum)
{
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  struct sparc_frame_cache *cache =
    sparc64_frame_cache (this_frame, this_cache);

  if (regnum == SPARC64_PC_REGNUM || regnum == SPARC64_NPC_REGNUM)
    {
      CORE_ADDR pc = (regnum == SPARC64_NPC_REGNUM) ? 4 : 0;

      regnum =
	(cache->copied_regs_mask & 0x80) ? SPARC_I7_REGNUM : SPARC_O7_REGNUM;
      pc += get_frame_register_unsigned (this_frame, regnum) + 8;
      return frame_unwind_got_constant (this_frame, regnum, pc);
    }

  /* Handle StackGhost.  */
  {
    ULONGEST wcookie = sparc_fetch_wcookie (gdbarch);

    if (wcookie != 0 && !cache->frameless_p && regnum == SPARC_I7_REGNUM)
      {
        CORE_ADDR addr = cache->base + (regnum - SPARC_L0_REGNUM) * 8;
        ULONGEST i7;

        /* Read the value in from memory.  */
        i7 = get_frame_memory_unsigned (this_frame, addr, 8);
        return frame_unwind_got_constant (this_frame, regnum, i7 ^ wcookie);
      }
  }

  /* The previous frame's `local' and `in' registers may have been saved
     in the register save area.  */
  if (regnum >= SPARC_L0_REGNUM && regnum <= SPARC_I7_REGNUM
      && (cache->saved_regs_mask & (1 << (regnum - SPARC_L0_REGNUM))))
    {
      CORE_ADDR addr = cache->base + (regnum - SPARC_L0_REGNUM) * 8;

      return frame_unwind_got_memory (this_frame, regnum, addr);
    }

  /* The previous frame's `out' registers may be accessible as the current
     frame's `in' registers.  */
  if (regnum >= SPARC_O0_REGNUM && regnum <= SPARC_O7_REGNUM
      && (cache->copied_regs_mask & (1 << (regnum - SPARC_O0_REGNUM))))
    regnum += (SPARC_I0_REGNUM - SPARC_O0_REGNUM);

  return frame_unwind_got_register (this_frame, regnum, regnum);
}

static const struct frame_unwind sparc64_frame_unwind =
{
  NORMAL_FRAME,
  default_frame_unwind_stop_reason,
  sparc64_frame_this_id,
  sparc64_frame_prev_register,
  NULL,
  default_frame_sniffer
};


static CORE_ADDR
sparc64_frame_base_address (struct frame_info *this_frame, void **this_cache)
{
  struct sparc_frame_cache *cache =
    sparc64_frame_cache (this_frame, this_cache);

  return cache->base;
}

static const struct frame_base sparc64_frame_base =
{
  &sparc64_frame_unwind,
  sparc64_frame_base_address,
  sparc64_frame_base_address,
  sparc64_frame_base_address
};

/* Check whether TYPE must be 16-byte aligned.  */

static int
sparc64_16_byte_align_p (struct type *type)
{
  if (sparc64_floating_p (type) && TYPE_LENGTH (type) == 16)
    return 1;

  if (sparc64_structure_or_union_p (type))
    {
      int i;

      for (i = 0; i < TYPE_NFIELDS (type); i++)
	{
	  struct type *subtype = check_typedef (TYPE_FIELD_TYPE (type, i));

	  if (sparc64_16_byte_align_p (subtype))
	    return 1;
	}
    }

  return 0;
}

/* Store floating fields of element ELEMENT of an "parameter array"
   that has type TYPE and is stored at BITPOS in VALBUF in the
   apropriate registers of REGCACHE.  This function can be called
   recursively and therefore handles floating types in addition to
   structures.  */

static void
sparc64_store_floating_fields (struct regcache *regcache, struct type *type,
			       const gdb_byte *valbuf, int element, int bitpos)
{
  int len = TYPE_LENGTH (type);

  gdb_assert (element < 16);

  if (sparc64_floating_p (type)
      || (sparc64_complex_floating_p (type) && len <= 16))
    {
      int regnum;

      if (len == 16)
	{
	  gdb_assert (bitpos == 0);
	  gdb_assert ((element % 2) == 0);

	  regnum = SPARC64_Q0_REGNUM + element / 2;
	  regcache_cooked_write (regcache, regnum, valbuf);
	}
      else if (len == 8)
	{
	  gdb_assert (bitpos == 0 || bitpos == 64);

	  regnum = SPARC64_D0_REGNUM + element + bitpos / 64;
	  regcache_cooked_write (regcache, regnum, valbuf + (bitpos / 8));
	}
      else
	{
	  gdb_assert (len == 4);
	  gdb_assert (bitpos % 32 == 0 && bitpos >= 0 && bitpos < 128);

	  regnum = SPARC_F0_REGNUM + element * 2 + bitpos / 32;
	  regcache_cooked_write (regcache, regnum, valbuf + (bitpos / 8));
	}
    }
  else if (sparc64_structure_or_union_p (type))
    {
      int i;

      for (i = 0; i < TYPE_NFIELDS (type); i++)
	{
	  struct type *subtype = check_typedef (TYPE_FIELD_TYPE (type, i));
	  int subpos = bitpos + TYPE_FIELD_BITPOS (type, i);

	  sparc64_store_floating_fields (regcache, subtype, valbuf,
					 element, subpos);
	}

      /* GCC has an interesting bug.  If TYPE is a structure that has
         a single `float' member, GCC doesn't treat it as a structure
         at all, but rather as an ordinary `float' argument.  This
         argument will be stored in %f1, as required by the psABI.
         However, as a member of a structure the psABI requires it to
         be stored in %f0.  This bug is present in GCC 3.3.2, but
         probably in older releases to.  To appease GCC, if a
         structure has only a single `float' member, we store its
         value in %f1 too (we already have stored in %f0).  */
      if (TYPE_NFIELDS (type) == 1)
	{
	  struct type *subtype = check_typedef (TYPE_FIELD_TYPE (type, 0));

	  if (sparc64_floating_p (subtype) && TYPE_LENGTH (subtype) == 4)
	    regcache_cooked_write (regcache, SPARC_F1_REGNUM, valbuf);
	}
    }
}

/* Fetch floating fields from a variable of type TYPE from the
   appropriate registers for BITPOS in REGCACHE and store it at BITPOS
   in VALBUF.  This function can be called recursively and therefore
   handles floating types in addition to structures.  */

static void
sparc64_extract_floating_fields (struct regcache *regcache, struct type *type,
				 gdb_byte *valbuf, int bitpos)
{
  if (sparc64_floating_p (type))
    {
      int len = TYPE_LENGTH (type);
      int regnum;

      if (len == 16)
	{
	  gdb_assert (bitpos == 0 || bitpos == 128);

	  regnum = SPARC64_Q0_REGNUM + bitpos / 128;
	  regcache_cooked_read (regcache, regnum, valbuf + (bitpos / 8));
	}
      else if (len == 8)
	{
	  gdb_assert (bitpos % 64 == 0 && bitpos >= 0 && bitpos < 256);

	  regnum = SPARC64_D0_REGNUM + bitpos / 64;
	  regcache_cooked_read (regcache, regnum, valbuf + (bitpos / 8));
	}
      else
	{
	  gdb_assert (len == 4);
	  gdb_assert (bitpos % 32 == 0 && bitpos >= 0 && bitpos < 256);

	  regnum = SPARC_F0_REGNUM + bitpos / 32;
	  regcache_cooked_read (regcache, regnum, valbuf + (bitpos / 8));
	}
    }
  else if (sparc64_structure_or_union_p (type))
    {
      int i;

      for (i = 0; i < TYPE_NFIELDS (type); i++)
	{
	  struct type *subtype = check_typedef (TYPE_FIELD_TYPE (type, i));
	  int subpos = bitpos + TYPE_FIELD_BITPOS (type, i);

	  sparc64_extract_floating_fields (regcache, subtype, valbuf, subpos);
	}
    }
}

/* Store the NARGS arguments ARGS and STRUCT_ADDR (if STRUCT_RETURN is
   non-zero) in REGCACHE and on the stack (starting from address SP).  */

static CORE_ADDR
sparc64_store_arguments (struct regcache *regcache, int nargs,
			 struct value **args, CORE_ADDR sp,
			 int struct_return, CORE_ADDR struct_addr)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  /* Number of extended words in the "parameter array".  */
  int num_elements = 0;
  int element = 0;
  int i;

  /* Take BIAS into account.  */
  sp += BIAS;

  /* First we calculate the number of extended words in the "parameter
     array".  While doing so we also convert some of the arguments.  */

  if (struct_return)
    num_elements++;

  for (i = 0; i < nargs; i++)
    {
      struct type *type = value_type (args[i]);
      int len = TYPE_LENGTH (type);

      if (sparc64_structure_or_union_p (type)
	  || (sparc64_complex_floating_p (type) && len == 32))
	{
	  /* Structure or Union arguments.  */
	  if (len <= 16)
	    {
	      if (num_elements % 2 && sparc64_16_byte_align_p (type))
		num_elements++;
	      num_elements += ((len + 7) / 8);
	    }
	  else
	    {
	      /* The psABI says that "Structures or unions larger than
		 sixteen bytes are copied by the caller and passed
		 indirectly; the caller will pass the address of a
		 correctly aligned structure value.  This sixty-four
		 bit address will occupy one word in the parameter
		 array, and may be promoted to an %o register like any
		 other pointer value."  Allocate memory for these
		 values on the stack.  */
	      sp -= len;

	      /* Use 16-byte alignment for these values.  That's
                 always correct, and wasting a few bytes shouldn't be
                 a problem.  */
	      sp &= ~0xf;

	      write_memory (sp, value_contents (args[i]), len);
	      args[i] = value_from_pointer (lookup_pointer_type (type), sp);
	      num_elements++;
	    }
	}
      else if (sparc64_floating_p (type) || sparc64_complex_floating_p (type))
	{
	  /* Floating arguments.  */
	  if (len == 16)
	    {
	      /* The psABI says that "Each quad-precision parameter
                 value will be assigned to two extended words in the
                 parameter array.  */
	      num_elements += 2;

	      /* The psABI says that "Long doubles must be
                 quad-aligned, and thus a hole might be introduced
                 into the parameter array to force alignment."  Skip
                 an element if necessary.  */
	      if (num_elements % 2)
		num_elements++;
	    }
	  else
	    num_elements++;
	}
      else
	{
	  /* Integral and pointer arguments.  */
	  gdb_assert (sparc64_integral_or_pointer_p (type));

	  /* The psABI says that "Each argument value of integral type
	     smaller than an extended word will be widened by the
	     caller to an extended word according to the signed-ness
	     of the argument type."  */
	  if (len < 8)
	    args[i] = value_cast (builtin_type (gdbarch)->builtin_int64,
				  args[i]);
	  num_elements++;
	}
    }

  /* Allocate the "parameter array".  */
  sp -= num_elements * 8;

  /* The psABI says that "Every stack frame must be 16-byte aligned."  */
  sp &= ~0xf;

  /* Now we store the arguments in to the "paramater array".  Some
     Integer or Pointer arguments and Structure or Union arguments
     will be passed in %o registers.  Some Floating arguments and
     floating members of structures are passed in floating-point
     registers.  However, for functions with variable arguments,
     floating arguments are stored in an %0 register, and for
     functions without a prototype floating arguments are stored in
     both a floating-point and an %o registers, or a floating-point
     register and memory.  To simplify the logic here we always pass
     arguments in memory, an %o register, and a floating-point
     register if appropriate.  This should be no problem since the
     contents of any unused memory or registers in the "parameter
     array" are undefined.  */

  if (struct_return)
    {
      regcache_cooked_write_unsigned (regcache, SPARC_O0_REGNUM, struct_addr);
      element++;
    }

  for (i = 0; i < nargs; i++)
    {
      const gdb_byte *valbuf = value_contents (args[i]);
      struct type *type = value_type (args[i]);
      int len = TYPE_LENGTH (type);
      int regnum = -1;
      gdb_byte buf[16];

      if (sparc64_structure_or_union_p (type)
	  || (sparc64_complex_floating_p (type) && len == 32))
	{
	  /* Structure or Union arguments.  */
	  gdb_assert (len <= 16);
	  memset (buf, 0, sizeof (buf));
	  valbuf = memcpy (buf, valbuf, len);

	  if (element % 2 && sparc64_16_byte_align_p (type))
	    element++;

	  if (element < 6)
	    {
	      regnum = SPARC_O0_REGNUM + element;
	      if (len > 8 && element < 5)
		regcache_cooked_write (regcache, regnum + 1, valbuf + 8);
	    }

	  if (element < 16)
	    sparc64_store_floating_fields (regcache, type, valbuf, element, 0);
	}
      else if (sparc64_floating_p (type) || sparc64_complex_floating_p (type))
	{
	  /* Floating arguments.  */
	  if (len == 16)
	    {
	      if (element % 2)
		element++;
	      if (element < 16)
		regnum = SPARC64_Q0_REGNUM + element / 2;
	    }
	  else if (len == 8)
	    {
	      if (element < 16)
		regnum = SPARC64_D0_REGNUM + element;
	    }
	  else if (len == 4)
	    {
	      /* The psABI says "Each single-precision parameter value
                 will be assigned to one extended word in the
                 parameter array, and right-justified within that
                 word; the left half (even float register) is
                 undefined."  Even though the psABI says that "the
                 left half is undefined", set it to zero here.  */
	      memset (buf, 0, 4);
	      memcpy (buf + 4, valbuf, 4);
	      valbuf = buf;
	      len = 8;
	      if (element < 16)
		regnum = SPARC64_D0_REGNUM + element;
	    }
	}
      else
	{
	  /* Integral and pointer arguments.  */
	  gdb_assert (len == 8);
	  if (element < 6)
	    regnum = SPARC_O0_REGNUM + element;
	}

      if (regnum != -1)
	{
	  regcache_cooked_write (regcache, regnum, valbuf);

	  /* If we're storing the value in a floating-point register,
             also store it in the corresponding %0 register(s).  */
	  if (regnum >= SPARC64_D0_REGNUM && regnum <= SPARC64_D10_REGNUM)
	    {
	      gdb_assert (element < 6);
	      regnum = SPARC_O0_REGNUM + element;
	      regcache_cooked_write (regcache, regnum, valbuf);
	    }
	  else if (regnum >= SPARC64_Q0_REGNUM && regnum <= SPARC64_Q8_REGNUM)
	    {
	      gdb_assert (element < 5);
	      regnum = SPARC_O0_REGNUM + element;
	      regcache_cooked_write (regcache, regnum, valbuf);
	      regcache_cooked_write (regcache, regnum + 1, valbuf + 8);
	    }
	}

      /* Always store the argument in memory.  */
      write_memory (sp + element * 8, valbuf, len);
      element += ((len + 7) / 8);
    }

  gdb_assert (element == num_elements);

  /* Take BIAS into account.  */
  sp -= BIAS;
  return sp;
}

static CORE_ADDR
sparc64_frame_align (struct gdbarch *gdbarch, CORE_ADDR address)
{
  /* The ABI requires 16-byte alignment.  */
  return address & ~0xf;
}

static CORE_ADDR
sparc64_push_dummy_call (struct gdbarch *gdbarch, struct value *function,
			 struct regcache *regcache, CORE_ADDR bp_addr,
			 int nargs, struct value **args, CORE_ADDR sp,
			 int struct_return, CORE_ADDR struct_addr)
{
  /* Set return address.  */
  regcache_cooked_write_unsigned (regcache, SPARC_O7_REGNUM, bp_addr - 8);

  /* Set up function arguments.  */
  sp = sparc64_store_arguments (regcache, nargs, args, sp,
				struct_return, struct_addr);

  /* Allocate the register save area.  */
  sp -= 16 * 8;

  /* Stack should be 16-byte aligned at this point.  */
  gdb_assert ((sp + BIAS) % 16 == 0);

  /* Finally, update the stack pointer.  */
  regcache_cooked_write_unsigned (regcache, SPARC_SP_REGNUM, sp);

  return sp + BIAS;
}


/* Extract from an array REGBUF containing the (raw) register state, a
   function return value of TYPE, and copy that into VALBUF.  */

static void
sparc64_extract_return_value (struct type *type, struct regcache *regcache,
			      gdb_byte *valbuf)
{
  int len = TYPE_LENGTH (type);
  gdb_byte buf[32];
  int i;

  if (sparc64_structure_or_union_p (type))
    {
      /* Structure or Union return values.  */
      gdb_assert (len <= 32);

      for (i = 0; i < ((len + 7) / 8); i++)
	regcache_cooked_read (regcache, SPARC_O0_REGNUM + i, buf + i * 8);
      if (TYPE_CODE (type) != TYPE_CODE_UNION)
	sparc64_extract_floating_fields (regcache, type, buf, 0);
      memcpy (valbuf, buf, len);
    }
  else if (sparc64_floating_p (type) || sparc64_complex_floating_p (type))
    {
      /* Floating return values.  */
      for (i = 0; i < len / 4; i++)
	regcache_cooked_read (regcache, SPARC_F0_REGNUM + i, buf + i * 4);
      memcpy (valbuf, buf, len);
    }
  else if (TYPE_CODE (type) == TYPE_CODE_ARRAY)
    {
      /* Small arrays are returned the same way as small structures.  */
      gdb_assert (len <= 32);

      for (i = 0; i < ((len + 7) / 8); i++)
	regcache_cooked_read (regcache, SPARC_O0_REGNUM + i, buf + i * 8);
      memcpy (valbuf, buf, len);
    }
  else
    {
      /* Integral and pointer return values.  */
      gdb_assert (sparc64_integral_or_pointer_p (type));

      /* Just stripping off any unused bytes should preserve the
         signed-ness just fine.  */
      regcache_cooked_read (regcache, SPARC_O0_REGNUM, buf);
      memcpy (valbuf, buf + 8 - len, len);
    }
}

/* Write into the appropriate registers a function return value stored
   in VALBUF of type TYPE.  */

static void
sparc64_store_return_value (struct type *type, struct regcache *regcache,
			    const gdb_byte *valbuf)
{
  int len = TYPE_LENGTH (type);
  gdb_byte buf[16];
  int i;

  if (sparc64_structure_or_union_p (type))
    {
      /* Structure or Union return values.  */
      gdb_assert (len <= 32);

      /* Simplify matters by storing the complete value (including
         floating members) into %o0 and %o1.  Floating members are
         also store in the appropriate floating-point registers.  */
      memset (buf, 0, sizeof (buf));
      memcpy (buf, valbuf, len);
      for (i = 0; i < ((len + 7) / 8); i++)
	regcache_cooked_write (regcache, SPARC_O0_REGNUM + i, buf + i * 8);
      if (TYPE_CODE (type) != TYPE_CODE_UNION)
	sparc64_store_floating_fields (regcache, type, buf, 0, 0);
    }
  else if (sparc64_floating_p (type) || sparc64_complex_floating_p (type))
    {
      /* Floating return values.  */
      memcpy (buf, valbuf, len);
      for (i = 0; i < len / 4; i++)
	regcache_cooked_write (regcache, SPARC_F0_REGNUM + i, buf + i * 4);
    }
  else if (TYPE_CODE (type) == TYPE_CODE_ARRAY)
    {
      /* Small arrays are returned the same way as small structures.  */
      gdb_assert (len <= 32);

      memset (buf, 0, sizeof (buf));
      memcpy (buf, valbuf, len);
      for (i = 0; i < ((len + 7) / 8); i++)
	regcache_cooked_write (regcache, SPARC_O0_REGNUM + i, buf + i * 8);
    }
  else
    {
      /* Integral and pointer return values.  */
      gdb_assert (sparc64_integral_or_pointer_p (type));

      /* ??? Do we need to do any sign-extension here?  */
      memset (buf, 0, 8);
      memcpy (buf + 8 - len, valbuf, len);
      regcache_cooked_write (regcache, SPARC_O0_REGNUM, buf);
    }
}

static enum return_value_convention
sparc64_return_value (struct gdbarch *gdbarch, struct value *function,
		      struct type *type, struct regcache *regcache,
		      gdb_byte *readbuf, const gdb_byte *writebuf)
{
  if (TYPE_LENGTH (type) > 32)
    return RETURN_VALUE_STRUCT_CONVENTION;

  if (readbuf)
    sparc64_extract_return_value (type, regcache, readbuf);
  if (writebuf)
    sparc64_store_return_value (type, regcache, writebuf);

  return RETURN_VALUE_REGISTER_CONVENTION;
}


static void
sparc64_dwarf2_frame_init_reg (struct gdbarch *gdbarch, int regnum,
			       struct dwarf2_frame_state_reg *reg,
			       struct frame_info *this_frame)
{
  switch (regnum)
    {
    case SPARC_G0_REGNUM:
      /* Since %g0 is always zero, there is no point in saving it, and
	 people will be inclined omit it from the CFI.  Make sure we
	 don't warn about that.  */
      reg->how = DWARF2_FRAME_REG_SAME_VALUE;
      break;
    case SPARC_SP_REGNUM:
      reg->how = DWARF2_FRAME_REG_CFA;
      break;
    case SPARC64_PC_REGNUM:
      reg->how = DWARF2_FRAME_REG_RA_OFFSET;
      reg->loc.offset = 8;
      break;
    case SPARC64_NPC_REGNUM:
      reg->how = DWARF2_FRAME_REG_RA_OFFSET;
      reg->loc.offset = 12;
      break;
    }
}

void
sparc64_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  tdep->pc_regnum = SPARC64_PC_REGNUM;
  tdep->npc_regnum = SPARC64_NPC_REGNUM;

  /* This is what all the fuss is about.  */
  set_gdbarch_long_bit (gdbarch, 64);
  set_gdbarch_long_long_bit (gdbarch, 64);
  set_gdbarch_ptr_bit (gdbarch, 64);

  set_gdbarch_num_regs (gdbarch, SPARC64_NUM_REGS);
  set_gdbarch_register_name (gdbarch, sparc64_register_name);
  set_gdbarch_register_type (gdbarch, sparc64_register_type);
  set_gdbarch_num_pseudo_regs (gdbarch, SPARC64_NUM_PSEUDO_REGS);
  set_gdbarch_pseudo_register_read (gdbarch, sparc64_pseudo_register_read);
  set_gdbarch_pseudo_register_write (gdbarch, sparc64_pseudo_register_write);

  /* Register numbers of various important registers.  */
  set_gdbarch_pc_regnum (gdbarch, SPARC64_PC_REGNUM); /* %pc */

  /* Call dummy code.  */
  set_gdbarch_frame_align (gdbarch, sparc64_frame_align);
  set_gdbarch_call_dummy_location (gdbarch, AT_ENTRY_POINT);
  set_gdbarch_push_dummy_code (gdbarch, NULL);
  set_gdbarch_push_dummy_call (gdbarch, sparc64_push_dummy_call);

  set_gdbarch_return_value (gdbarch, sparc64_return_value);
  set_gdbarch_stabs_argument_has_addr
    (gdbarch, default_stabs_argument_has_addr);

  set_gdbarch_skip_prologue (gdbarch, sparc64_skip_prologue);

  /* Hook in the DWARF CFI frame unwinder.  */
  dwarf2_frame_set_init_reg (gdbarch, sparc64_dwarf2_frame_init_reg);
  /* FIXME: kettenis/20050423: Don't enable the unwinder until the
     StackGhost issues have been resolved.  */

  frame_unwind_append_unwinder (gdbarch, &sparc64_frame_unwind);
  frame_base_set_default (gdbarch, &sparc64_frame_base);
}


/* Helper functions for dealing with register sets.  */

#define TSTATE_CWP	0x000000000000001fULL
#define TSTATE_ICC	0x0000000f00000000ULL
#define TSTATE_XCC	0x000000f000000000ULL

#define PSR_S		0x00000080
#define PSR_ICC		0x00f00000
#define PSR_VERS	0x0f000000
#define PSR_IMPL	0xf0000000
#define PSR_V8PLUS	0xff000000
#define PSR_XCC		0x000f0000

void
sparc64_supply_gregset (const struct sparc_gregset *gregset,
			struct regcache *regcache,
			int regnum, const void *gregs)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  int sparc32 = (gdbarch_ptr_bit (gdbarch) == 32);
  const gdb_byte *regs = gregs;
  gdb_byte zero[8] = { 0 };
  int i;

  if (sparc32)
    {
      if (regnum == SPARC32_PSR_REGNUM || regnum == -1)
	{
	  int offset = gregset->r_tstate_offset;
	  ULONGEST tstate, psr;
	  gdb_byte buf[4];

	  tstate = extract_unsigned_integer (regs + offset, 8, byte_order);
	  psr = ((tstate & TSTATE_CWP) | PSR_S | ((tstate & TSTATE_ICC) >> 12)
		 | ((tstate & TSTATE_XCC) >> 20) | PSR_V8PLUS);
	  store_unsigned_integer (buf, 4, byte_order, psr);
	  regcache_raw_supply (regcache, SPARC32_PSR_REGNUM, buf);
	}

      if (regnum == SPARC32_PC_REGNUM || regnum == -1)
	regcache_raw_supply (regcache, SPARC32_PC_REGNUM,
			     regs + gregset->r_pc_offset + 4);

      if (regnum == SPARC32_NPC_REGNUM || regnum == -1)
	regcache_raw_supply (regcache, SPARC32_NPC_REGNUM,
			     regs + gregset->r_npc_offset + 4);

      if (regnum == SPARC32_Y_REGNUM || regnum == -1)
	{
	  int offset = gregset->r_y_offset + 8 - gregset->r_y_size;
	  regcache_raw_supply (regcache, SPARC32_Y_REGNUM, regs + offset);
	}
    }
  else
    {
      if (regnum == SPARC64_STATE_REGNUM || regnum == -1)
	regcache_raw_supply (regcache, SPARC64_STATE_REGNUM,
			     regs + gregset->r_tstate_offset);

      if (regnum == SPARC64_PC_REGNUM || regnum == -1)
	regcache_raw_supply (regcache, SPARC64_PC_REGNUM,
			     regs + gregset->r_pc_offset);

      if (regnum == SPARC64_NPC_REGNUM || regnum == -1)
	regcache_raw_supply (regcache, SPARC64_NPC_REGNUM,
			     regs + gregset->r_npc_offset);

      if (regnum == SPARC64_Y_REGNUM || regnum == -1)
	{
	  gdb_byte buf[8];

	  memset (buf, 0, 8);
	  memcpy (buf + 8 - gregset->r_y_size,
		  regs + gregset->r_y_offset, gregset->r_y_size);
	  regcache_raw_supply (regcache, SPARC64_Y_REGNUM, buf);
	}

      if ((regnum == SPARC64_FPRS_REGNUM || regnum == -1)
	  && gregset->r_fprs_offset != -1)
	regcache_raw_supply (regcache, SPARC64_FPRS_REGNUM,
			     regs + gregset->r_fprs_offset);
    }

  if (regnum == SPARC_G0_REGNUM || regnum == -1)
    regcache_raw_supply (regcache, SPARC_G0_REGNUM, &zero);

  if ((regnum >= SPARC_G1_REGNUM && regnum <= SPARC_O7_REGNUM) || regnum == -1)
    {
      int offset = gregset->r_g1_offset;

      if (sparc32)
	offset += 4;

      for (i = SPARC_G1_REGNUM; i <= SPARC_O7_REGNUM; i++)
	{
	  if (regnum == i || regnum == -1)
	    regcache_raw_supply (regcache, i, regs + offset);
	  offset += 8;
	}
    }

  if ((regnum >= SPARC_L0_REGNUM && regnum <= SPARC_I7_REGNUM) || regnum == -1)
    {
      /* Not all of the register set variants include Locals and
         Inputs.  For those that don't, we read them off the stack.  */
      if (gregset->r_l0_offset == -1)
	{
	  ULONGEST sp;

	  regcache_cooked_read_unsigned (regcache, SPARC_SP_REGNUM, &sp);
	  sparc_supply_rwindow (regcache, sp, regnum);
	}
      else
	{
	  int offset = gregset->r_l0_offset;

	  if (sparc32)
	    offset += 4;

	  for (i = SPARC_L0_REGNUM; i <= SPARC_I7_REGNUM; i++)
	    {
	      if (regnum == i || regnum == -1)
		regcache_raw_supply (regcache, i, regs + offset);
	      offset += 8;
	    }
	}
    }
}

void
sparc64_collect_gregset (const struct sparc_gregset *gregset,
			 const struct regcache *regcache,
			 int regnum, void *gregs)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  int sparc32 = (gdbarch_ptr_bit (gdbarch) == 32);
  gdb_byte *regs = gregs;
  int i;

  if (sparc32)
    {
      if (regnum == SPARC32_PSR_REGNUM || regnum == -1)
	{
	  int offset = gregset->r_tstate_offset;
	  ULONGEST tstate, psr;
	  gdb_byte buf[8];

	  tstate = extract_unsigned_integer (regs + offset, 8, byte_order);
	  regcache_raw_collect (regcache, SPARC32_PSR_REGNUM, buf);
	  psr = extract_unsigned_integer (buf, 4, byte_order);
	  tstate |= (psr & PSR_ICC) << 12;
	  if ((psr & (PSR_VERS | PSR_IMPL)) == PSR_V8PLUS)
	    tstate |= (psr & PSR_XCC) << 20;
	  store_unsigned_integer (buf, 8, byte_order, tstate);
	  memcpy (regs + offset, buf, 8);
	}

      if (regnum == SPARC32_PC_REGNUM || regnum == -1)
	regcache_raw_collect (regcache, SPARC32_PC_REGNUM,
			      regs + gregset->r_pc_offset + 4);

      if (regnum == SPARC32_NPC_REGNUM || regnum == -1)
	regcache_raw_collect (regcache, SPARC32_NPC_REGNUM,
			      regs + gregset->r_npc_offset + 4);

      if (regnum == SPARC32_Y_REGNUM || regnum == -1)
	{
	  int offset = gregset->r_y_offset + 8 - gregset->r_y_size;
	  regcache_raw_collect (regcache, SPARC32_Y_REGNUM, regs + offset);
	}
    }
  else
    {
      if (regnum == SPARC64_STATE_REGNUM || regnum == -1)
	regcache_raw_collect (regcache, SPARC64_STATE_REGNUM,
			      regs + gregset->r_tstate_offset);

      if (regnum == SPARC64_PC_REGNUM || regnum == -1)
	regcache_raw_collect (regcache, SPARC64_PC_REGNUM,
			      regs + gregset->r_pc_offset);

      if (regnum == SPARC64_NPC_REGNUM || regnum == -1)
	regcache_raw_collect (regcache, SPARC64_NPC_REGNUM,
			      regs + gregset->r_npc_offset);

      if (regnum == SPARC64_Y_REGNUM || regnum == -1)
	{
	  gdb_byte buf[8];

	  regcache_raw_collect (regcache, SPARC64_Y_REGNUM, buf);
	  memcpy (regs + gregset->r_y_offset,
		  buf + 8 - gregset->r_y_size, gregset->r_y_size);
	}

      if ((regnum == SPARC64_FPRS_REGNUM || regnum == -1)
	  && gregset->r_fprs_offset != -1)
	regcache_raw_collect (regcache, SPARC64_FPRS_REGNUM,
			      regs + gregset->r_fprs_offset);

    }

  if ((regnum >= SPARC_G1_REGNUM && regnum <= SPARC_O7_REGNUM) || regnum == -1)
    {
      int offset = gregset->r_g1_offset;

      if (sparc32)
	offset += 4;

      /* %g0 is always zero.  */
      for (i = SPARC_G1_REGNUM; i <= SPARC_O7_REGNUM; i++)
	{
	  if (regnum == i || regnum == -1)
	    regcache_raw_collect (regcache, i, regs + offset);
	  offset += 8;
	}
    }

  if ((regnum >= SPARC_L0_REGNUM && regnum <= SPARC_I7_REGNUM) || regnum == -1)
    {
      /* Not all of the register set variants include Locals and
         Inputs.  For those that don't, we read them off the stack.  */
      if (gregset->r_l0_offset != -1)
	{
	  int offset = gregset->r_l0_offset;

	  if (sparc32)
	    offset += 4;

	  for (i = SPARC_L0_REGNUM; i <= SPARC_I7_REGNUM; i++)
	    {
	      if (regnum == i || regnum == -1)
		regcache_raw_collect (regcache, i, regs + offset);
	      offset += 8;
	    }
	}
    }
}

void
sparc64_supply_fpregset (const struct sparc_fpregset *fpregset,
			 struct regcache *regcache,
			 int regnum, const void *fpregs)
{
  int sparc32 = (gdbarch_ptr_bit (get_regcache_arch (regcache)) == 32);
  const gdb_byte *regs = fpregs;
  int i;

  for (i = 0; i < 32; i++)
    {
      if (regnum == (SPARC_F0_REGNUM + i) || regnum == -1)
	regcache_raw_supply (regcache, SPARC_F0_REGNUM + i,
			     regs + fpregset->r_f0_offset + (i * 4));
    }

  if (sparc32)
    {
      if (regnum == SPARC32_FSR_REGNUM || regnum == -1)
	regcache_raw_supply (regcache, SPARC32_FSR_REGNUM,
			     regs + fpregset->r_fsr_offset);
    }
  else
    {
      for (i = 0; i < 16; i++)
	{
	  if (regnum == (SPARC64_F32_REGNUM + i) || regnum == -1)
	    regcache_raw_supply (regcache, SPARC64_F32_REGNUM + i,
				 (regs + fpregset->r_f0_offset
				  + (32 * 4) + (i * 8)));
	}

      if (regnum == SPARC64_FSR_REGNUM || regnum == -1)
	regcache_raw_supply (regcache, SPARC64_FSR_REGNUM,
			     regs + fpregset->r_fsr_offset);
    }
}

void
sparc64_collect_fpregset (const struct sparc_fpregset *fpregset,
			  const struct regcache *regcache,
			  int regnum, void *fpregs)
{
  int sparc32 = (gdbarch_ptr_bit (get_regcache_arch (regcache)) == 32);
  gdb_byte *regs = fpregs;
  int i;

  for (i = 0; i < 32; i++)
    {
      if (regnum == (SPARC_F0_REGNUM + i) || regnum == -1)
	regcache_raw_collect (regcache, SPARC_F0_REGNUM + i,
			      regs + fpregset->r_f0_offset + (i * 4));
    }

  if (sparc32)
    {
      if (regnum == SPARC32_FSR_REGNUM || regnum == -1)
	regcache_raw_collect (regcache, SPARC32_FSR_REGNUM,
			      regs + fpregset->r_fsr_offset);
    }
  else
    {
      for (i = 0; i < 16; i++)
	{
	  if (regnum == (SPARC64_F32_REGNUM + i) || regnum == -1)
	    regcache_raw_collect (regcache, SPARC64_F32_REGNUM + i,
				  (regs + fpregset->r_f0_offset
				   + (32 * 4) + (i * 8)));
	}

      if (regnum == SPARC64_FSR_REGNUM || regnum == -1)
	regcache_raw_collect (regcache, SPARC64_FSR_REGNUM,
			      regs + fpregset->r_fsr_offset);
    }
}

const struct sparc_fpregset sparc64_bsd_fpregset =
{
  0 * 8,			/* %f0 */
  32 * 8,			/* %fsr */
};
@


1.61
log
@Fix Sparc %fsr regset offset for BSD and Linux.

gdb/

	* sparc-tdep.h (struct sparc_fpregset): New data structure.
	(sparc32_sunos4_fpregset, sparc32_bsd_fpregset,
	sparc32_sol2_fpregset): Declare new globals.
	(sparc32_supply_fpregset, sparc32_collect_fpregset): Add new
	'fpregset' argument.
	* sparc64-tdep.h (sparc64_supply_fpregset,
	sparc64_collect_fpregset): Likewise.
	(sparc64_sol2_fpregset, sparc64_bsd_fpregset): Declare new
	globals.
	* sparc-nat.h (struct sparc_fpregset): Add forward declaration.
	(sparc_fpregset): Declare new global.
	(sparc_supply_fpregset, sparc_collect_fpregset): Add new
	'fpregset' argument.
	* sparc-linux-nat.c (supply_fpregset): Pass sparc_fpregset down
	into handler.
	(fill_fpregset): Likewise.
	(_initialize_sparc_linux_nat): Set sparc_fpregset to
	sparc32_bsd_fpregset.
	* sparc-linux-tdep.c (sparc32_linux_supply_core_fpregset): Pass
	sparc32_bsd_fpregset down into handler.
	(sparc32_linux_collect_core_fpregset): Likewise.
	* sparc-nat.c (sparc_fpregset): Define.
	(sparc_supply_fpregset): Add 'fpregset' argument.
	(sparc_collect_fpregset): Likewise.
	(sparc_fetch_inferior_registers): Pass sparc_fpregset down
	into fpregset handler.
	(sparc_store_inferior_registers): Likewise.
	(_initialize_sparc_nat): Set sparc_fpregset to
	sparc32_sunos4_fpregset if NULL.
	* sparc-sol2-nat.c (supply_gregset): Pass sparc_sol2_fpregset
	down into handler.
	(fill_fpregset): Likewise.
	* sparc-sol2-tdep.c (sparc32_sol2_fpregset): Define.
	* sparc-tdep.c (sparc32_supply_fpregset): Add fpregset arg and
	use it to compute offsets.
	(sparc32_collect_fpregset): Likewise.
	(sparc32_sunos4_fpregset, sparc32_bsd_fpregset): Define.
	* sparc64-linux-nat.c (supply_fpregset): Pass sparc64_bsd_fpregset
	down into handler.
	(fill_fpregset): Likewise.
	* sparc64-linux-tdep.c (sparc64_linux_supply_core_fpregset):
	Likewise.
	(sparc64_linux_collect_core_fpregset): Likewise.
	* sparc64-sol2-tdep.c (sparc64_sol2_fpregset): Define.
	* sparc64-tdep.c (sparc64_supply_fpregset): Add fpregset arg and
	use it to compute offsets.
	(sparc64_collect_fpregset): Likewise.
	(sparc64_bsd_fpregset): Define.
	* sparc64fbsd-tdep.c (sparc64fbsd_supply_fpregset): Padd
	sparc64_bsd_fpregset down into handler.
	(sparc64fbsd_collect_fpregset): Likewise.
	* sparc64nbsd-nat.c (sparc64nbsd_supply_fpregset): Add fpregset arg
	and pass sparc{32,64}_bsd_fpregset down into handler.
	(sparc64nbsd_collect_fpregset): Likewise.
	* sparc64nbsd-tdep.c (sparc64nbsd_supply_fpregset): Pass
	sparc64_bsd_fpregset down into handler.
	* sparc64obsd-tdep.c (sparc64obsd_supply_gregset): Likewise.
	* sparcnbsd-nat.c (_initialize_sparcnbsd_nat): Set sparc_fpregset
	to sparc32_bsd_fpregset.
	* sparcnbsd-tdep.c (sparc32nbsd_supply_gregset): Pass
	sparc32_bsd_fpregset down into sparc32_supply_fpregset.
	(sparc32nbsd_supply_fpregset): Likewise.
@
text
@d3 1
a3 1
   Copyright (C) 2003-2012 Free Software Foundation, Inc.
@


1.60
log
@	gdb/
	* breakpoint.h (bp_location): Add related_address member.
	* inferior.h (get_return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	* value.h (using_struct_return): Likewise.
	* gdbarch.sh (return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	* breakpoint.c (set_breakpoint_location_function): Initialize
	related_address for bp_gnu_ifunc_resolver breakpoints.
	* elfread.c (elf_gnu_ifunc_resolver_return_stop): Pass the
	requested function's address to gdbarch_return_value.
	* eval.c (evaluate_subexp_standard): Pass the requested
	function's address to using_struct_return.
	* infcall.c (call_function_by_hand): Pass the requested
	function's address to using_struct_return and
	gdbarch_return_value.
	* infcmd.c (get_return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	(print_return_value): Update accordingly.
	(finish_command_continuation): Likewise.
	* stack.c (return_command): Pass the requested function's
	address to using_struct_return and gdbarch_return_value.
	* value.c (using_struct_return): Take a pointer to struct value
	instead of struct type for the function requested.  Pass the
	requested function's address to gdbarch_return_value.
	* python/py-finishbreakpoint.c (finish_breakpoint_object):
	New function_value member, replacing function_type.
	(bpfinishpy_dealloc): Update accordingly.
	(bpfinishpy_pre_stop_hook): Likewise.
	(bpfinishpy_init): Likewise.  Record the requested function's
	address.
	* mips-tdep.c (mips_fval_reg): New enum.
	(mips_o32_push_dummy_call): For MIPS16 FP doubles do not swap
	words put in GP registers.
	(mips_o64_push_dummy_call): Update a comment.
	(mips_o32_return_value): Take a pointer to struct value instead
	of struct type for the function requested and use it to check if
	using the MIPS16 calling convention.  Return the designated
	general purpose registers for floating-point values returned in
	MIPS16 mode.
	(mips_o64_return_value): Likewise.
	* ppc-tdep.h (ppc_sysv_abi_return_value): Update prototype.
	(ppc_sysv_abi_broken_return_value): Likewise.
	(ppc64_sysv_abi_return_value): Likewise.
	* alpha-tdep.c (alpha_return_value): Take a pointer to struct
	value instead of struct type for the function requested.
	* amd64-tdep.c (amd64_return_value): Likewise.
	* amd64-windows-tdep.c (amd64_windows_return_value): Likewise.
	* arm-tdep.c (arm_return_value): Likewise.
	* avr-tdep.c (avr_return_value): Likewise.
	* bfin-tdep.c (bfin_return_value): Likewise.
	* cris-tdep.c (cris_return_value): Likewise.
	* frv-tdep.c (frv_return_value): Likewise.
	* h8300-tdep.c (h8300_return_value): Likewise.
	(h8300h_return_value): Likewise.
	* hppa-tdep.c (hppa32_return_value): Likewise.
	(hppa64_return_value): Likewise.
	* i386-tdep.c (i386_return_value): Likewise.
	* ia64-tdep.c (ia64_return_value): Likewise.
	* iq2000-tdep.c (iq2000_return_value): Likewise.
	* lm32-tdep.c (lm32_return_value): Likewise.
	* m32c-tdep.c (m32c_return_value): Likewise.
	* m32r-tdep.c (m32r_return_value): Likewise.
	* m68hc11-tdep.c (m68hc11_return_value): Likewise.
	* m68k-tdep.c (m68k_return_value): Likewise.
	(m68k_svr4_return_value): Likewise.
	* m88k-tdep.c (m88k_return_value): Likewise.
	* mep-tdep.c (mep_return_value): Likewise.
	* microblaze-tdep.c (microblaze_return_value): Likewise.
	* mn10300-tdep.c (mn10300_return_value): Likewise.
	* moxie-tdep.c (moxie_return_value): Likewise.
	* mt-tdep.c (mt_return_value): Likewise.
	* ppc-linux-tdep.c (ppc_linux_return_value): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_return_value): Likewise.
	(ppc_sysv_abi_broken_return_value): Likewise.
	(ppc64_sysv_abi_return_value): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_return_value): Likewise.
	* rl78-tdep.c (rl78_return_value): Likewise.
	* rs6000-aix-tdep.c (rs6000_return_value): Likewise.
	* rx-tdep.c (rx_return_value): Likewise.
	* s390-tdep.c (s390_return_value): Likewise.
	* score-tdep.c (score_return_value): Likewise.
	* sh-tdep.c (sh_return_value_nofpu): Likewise.
	(sh_return_value_fpu): Likewise.
	* sh64-tdep.c (sh64_return_value): Likewise.
	* sparc-tdep.c (sparc32_return_value): Likewise.
	* sparc64-tdep.c (sparc64_return_value): Likewise.
	* spu-tdep.c (spu_return_value): Likewise.
	* tic6x-tdep.c (tic6x_return_value): Likewise.
	* v850-tdep.c (v850_return_value): Likewise.
	* vax-tdep.c (vax_return_value): Likewise.
	* xstormy16-tdep.c (xstormy16_return_value): Likewise.
	* xtensa-tdep.c (xtensa_return_value): Likewise.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.

	gdb/testsuite/
	* gdb.base/return-nodebug.exp: Also test float and double types.
@
text
@d1451 2
a1452 1
sparc64_supply_fpregset (struct regcache *regcache,
d1462 2
a1463 1
	regcache_raw_supply (regcache, SPARC_F0_REGNUM + i, regs + (i * 4));
d1470 1
a1470 1
			     regs + (32 * 4) + (16 * 8) + 4);
d1478 2
a1479 1
				 regs + (32 * 4) + (i * 8));
d1484 1
a1484 1
			     regs + (32 * 4) + (16 * 8));
d1489 2
a1490 1
sparc64_collect_fpregset (const struct regcache *regcache,
d1500 2
a1501 1
	regcache_raw_collect (regcache, SPARC_F0_REGNUM + i, regs + (i * 4));
d1508 1
a1508 1
			      regs + (32 * 4) + (16 * 8) + 4);
d1516 2
a1517 1
				  regs + (32 * 4) + (i * 8));
d1522 1
a1522 1
			      regs + (32 * 4) + (16 * 8));
d1526 5
@


1.59
log
@* sparc64-tdep.c (sparc64_store_arguments)
(sparc64_store_arguments): Fix coding style.
@
text
@d1122 1
a1122 1
sparc64_return_value (struct gdbarch *gdbarch, struct type *func_type,
@


1.58
log
@* sparc64-tdep.c (sparc64_store_arguments): Fix handling of
complex floats, adjust some related comments and tighten a related
assertion.
(sparc64_extract_return_value): Handle complex floats.
@
text
@d788 2
a789 2
      if (sparc64_structure_or_union_p (type) ||
	  (sparc64_complex_floating_p (type) && len == 32))
d890 2
a891 2
      if (sparc64_structure_or_union_p (type) ||
	  (sparc64_complex_floating_p (type) && len == 32))
@


1.57
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d788 2
a789 1
      if (sparc64_structure_or_union_p (type))
d820 1
a820 1
      else if (sparc64_floating_p (type))
a822 1

d890 2
a891 1
      if (sparc64_structure_or_union_p (type))
d931 1
a931 1
                 word; the left half (even floatregister) is
d964 1
a964 1
	      gdb_assert (element < 6);
d1038 1
a1038 1
  else if (sparc64_floating_p (type))
@


1.56
log
@Fix complex floats on sparc.

	* sparc-tdep.h (SPARC_F2_REGNUM, SPARC_F3_REGNUM, SPARC_F4_REGNUM,
	SPARC_F5_REGNUM, SPARC_F6_REGNUM, SPARC_F7_REGNUM): New enums.
	* sparc-tdep.c (sparc_complex_floating_p): New function.
	(sparc32_store_arguments): Handle complex floats.
	(sparc32_extract_return_value): Likewise.
	(sparc32_store_return_value): Likewise.
	(sparc32_stabs_argument_has_addr): Likewise.
	* sparc64-tdep.c (sparc64_complex_floating_p): New function.
	(sparc64_store_floating_fields): Handle complex floats.
	(sparc64_store_arguments): Likewise.
	(sparc64_store_return_value): Likewise.
@
text
@d3 1
a3 2
   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.56.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 2
a4 1
   Copyright (C) 2003-2012 Free Software Foundation, Inc.
@


1.55
log
@Add support for single register window model on SPARC

        2011-06-27  Eric Botcazou  <ebotcazou@@adacore.com>
        * sparc-tdep.h (struct sparc_frame_cache): Add frame_offset,
        saved_regs_mask and copied_regs_mask fields.
        (sparc_record_save_insn): New prototype.
        * sparc-tdep.c (sparc_alloc_frame_cache): Initialize the new fields.
        (sparc_record_save_insn): New function.
        (sparc_analyze_prologue): Add head comment.  Recognize store insns
        of call-saved registers.  Use OFFSET consistently.  Recognize flat
        frames and cache their settings.
        (sparc32_skip_prologue): Handle flat frames.
        (sparc_frame_cache): Add frame_offset to the base address.
        (sparc32_frame_cache): Adjust to new frame description.
        (sparc32_frame_prev_register): Likewise.
        * sparc64-tdep.c (sparc64_frame_prev_register): Likewise.
        * sparc-sol2-tdep.c (sparc32_sol2_sigtramp_frame_cache): Likewise.
        * sparc64-sol2-tdep.c (sparc64_sol2_sigtramp_frame_cache): Likewise.
        * sparcnbsd-tdep.c (sparc32nbsd_sigcontext_frame_cache): Force the
        frame by calling sparc_record_save_insn.
        * sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_frame_cache): Likewise.
        * sparcobsd-tdep.c (sparc32obsd_sigtramp_frame_cache): Likewise.
        * sparc64obsd-tdep.c (sparc64obsd_frame_cache): Likewise.
@
text
@d106 20
d645 2
d649 2
a650 1
  if (sparc64_floating_p (type))
a651 1
      int len = TYPE_LENGTH (type);
d911 1
a911 1
      else if (sparc64_floating_p (type))
d926 1
a926 1
	  else
d1092 1
a1092 1
  else if (sparc64_floating_p (type))
@


1.54
log
@* sparc-nat.c (sparc_fetch_inferior_registers): Explicitly supply
zero as the value for %g0 in the register cache.
* sparc-tdep.c (sparc32_supply_gregset): Likewise.
* sparc64-tdep.c (sparc64_supply_gregset): Likewise.
@
text
@d523 2
a524 1
      regnum = cache->frameless_p ? SPARC_O7_REGNUM : SPARC_I7_REGNUM;
d544 1
a544 1
  /* The previous frame's `local' and `in' registers have been saved
d546 2
a547 2
  if (!cache->frameless_p
      && regnum >= SPARC_L0_REGNUM && regnum <= SPARC_I7_REGNUM)
d554 4
a557 4
  /* The previous frame's `out' registers are accessable as the
     current frame's `in' registers.  */
  if (!cache->frameless_p
      && regnum >= SPARC_O0_REGNUM && regnum <= SPARC_O7_REGNUM)
@


1.53
log
@	gdb/
	* frame.c (frame_unwind_register): Throw an error if unwinding the
	register failed.
	* get_prev_frame_1 (get_prev_frame_1): Ask the unwinder if there's
	an unwind stop reason.
	(frame_stop_reason_string): Handle UNWIND_UNAVAILABLE.
	* frame.h (enum unwind_stop_reason) <UNWIND_OUTERMOST,
	UNWIND_UNAVAILABLE>: New.
	* inline-frame.c (inline_frame_unwind): Install
	default_frame_unwind_stop_reason.
	* frame-unwind.c: Include "exceptions.h".
	(frame_unwind_find_by_frame): Swallow NOT_AVAILABLE_ERROR errors.
	(default_frame_unwind_stop_reason): New.
	* frame-unwind.h (frame_unwind_stop_reason_ftype): New typedef.
	(default_frame_unwind_stop_reason): Declare.
	(struct frame_unwind) <stop_reason>: New function pointer.

	* dummy-frame.c: Install default_frame_unwind_stop_reason.
	* dwarf2-frame.c: Include exceptions.h.
	(struct dwarf2_frame_cache) <unavailable_retaddr>: New field.
	(dwarf2_frame_cache): Swallow NOT_AVAILABLE_ERROR errors when
	computing the CFA.  If such an error was thrown, set
	unavailable_retaddr.
	(dwarf2_frame_unwind_stop_reason): New.
	(dwarf2_frame_this_id): Don't build a frame id if the CFA was
	unavailable.
	(dwarf2_frame_unwind): Install dwarf2_frame_unwind_stop_reason.
	(dwarf2_signal_frame_unwind): Ditto.

	* amd64-tdep.c: Include "exceptions.h".
	(struct amd64_frame_cache): New field "base_p".
	(amd64_init_frame_cache): Clear it.
	(amd64_frame_cache_1): New, factored out from amd64_frame_cache.
	Avoid reading registers with functions that throw if the register
	is not necessary to compute the frame base.
	(amd64_frame_cache): Reimplement wrapping amd64_frame_cache_1, and
	swallowing NOT_AVAILABLE_ERROR.
	(amd64_frame_unwind_stop_reason): New.
	(amd64_frame_this_id): Don't build a frame id if the frame base
	was unavailable.
	(amd64_frame_unwind): Install amd64_frame_unwind_stop_reason.
	(amd64_sigtramp_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(amd64_sigtramp_frame_unwind_stop_reason): New.
	(amd64_sigtramp_frame_this_id): Don't build a frame id if the
	frame base was unavailable.
	(amd64_sigtramp_frame_unwind): Install
	amd64_sigtramp_frame_unwind_stop_reason.
	(amd64_epilogue_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(amd64_epilogue_frame_unwind_stop_reason): New.
	(amd64_epilogue_frame_this_id): Don't build a frame id if the
	frame base was unavailable.
	(amd64_epilogue_frame_unwind): Install
	amd64_epilogue_frame_unwind_stop_reason.
	* i386-tdep.c: Include "exceptions.h".
	(struct i386_frame_cache): New field "base_p".
	(i386_init_frame_cache): Clear it.
	(i386_frame_cache_1): New, factored out from amd64_frame_cache.
	Avoid reading registers with functions that throw if the register
	is not necessary to compute the frame base.
	(i386_frame_cache): Reimplement wrapping amd64_frame_cache_1, and
	swallowing NOT_AVAILABLE_ERROR.
	(i386_frame_unwind_stop_reason): New.
	(i386_frame_this_id): Don't build a frame id if the frame base was
	unavailable.
	(i386_frame_prev_register): Handle unavailable SP.
	(i386_frame_unwind): Install i386_frame_unwind_stop_reason.
	(i386_epilogue_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(i386_epilogue_frame_unwind_stop_reason): New.
	(i386_epilogue_frame_this_id): Don't build a frame id if the frame
	base was unavailable.
	(i386_epilogue_frame_unwind): Install
	i386_epilogue_frame_unwind_stop_reason.
	(i386_sigtramp_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(i386_sigtramp_frame_unwind_stop_reason): New.
	(i386_sigtramp_frame_this_id): Don't build a frame id if the frame
	base was unavailable.
	(i386_sigtramp_frame_unwind): Install
	i386_sigtramp_frame_unwind_stop_reason.
	* sentinel-frame.c (sentinel_frame_prev_register): Use the value
	type's size, not the register's.
	(sentinel_frame_unwind): Install default_frame_unwind_stop_reason.

	* alpha-mdebug-tdep.c (alpha_mdebug_frame_unwind): Install
	default_frame_unwind_stop_reason.
	* alpha-tdep.c (alpha_sigtramp_frame_unwind)
	(alpha_heuristic_frame_unwind): Ditto.
	* amd64obsd-tdep.c (amd64obsd_trapframe_unwind): Ditto.
	* arm-tdep.c (arm_prologue_unwind, arm_stub_unwind): Ditto.
	* avr-tdep.c (avr_frame_unwind): Ditto.
	* cris-tdep.c (cris_sigtramp_frame_unwind, cris_frame_unwind):
	Ditto.
	* frv-linux-tdep.c (frv_linux_sigtramp_frame_unwind): Ditto.
	* frv-tdep.c (frv_frame_unwind): Ditto.
	* h8300-tdep.c (h8300_frame_unwind): Ditto.
	* hppa-hpux-tdep.c (hppa_hpux_sigtramp_frame_unwind): Ditto.
	* hppa-linux-tdep.c (hppa_linux_sigtramp_frame_unwind): Ditto.
	* hppa-tdep.c (hppa_frame_unwind, hppa_fallback_frame_unwind)
	(hppa_stub_frame_unwind): Ditto.
	* i386obsd-tdep.c (i386obsd_trapframe_unwind): Ditto.
	* ia64-tdep.c (ia64_frame_unwind, ia64_sigtramp_frame_unwind)
	(ia64_libunwind_frame_unwind)
	(ia64_libunwind_sigtramp_frame_unwind): Ditto.
	* iq2000-tdep.c (iq2000_frame_unwind): Ditto.
	* lm32-tdep.c (lm32_frame_unwind): Ditto.
	* m32c-tdep.c (m32c_unwind): Ditto.
	* m32r-linux-tdep.c (m32r_linux_sigtramp_frame_unwind): Ditto.
	* m32r-tdep.c (m32r_frame_unwind): Ditto.
	* m68hc11-tdep.c (m68hc11_frame_unwind): Ditto.
	* m68k-tdep.c (m68k_frame_unwind): Ditto.
	* m68klinux-tdep.c (m68k_linux_sigtramp_frame_unwind): Ditto.
	* m88k-tdep.c (m88k_frame_unwind): Ditto.
	* mep-tdep.c (mep_frame_unwind): Ditto.
	* microblaze-tdep.c (microblaze_frame_unwind): Ditto.
	* mips-tdep.c (mips_insn16_frame_unwind, mips_insn32_frame_unwind)
	(mips_stub_frame_unwind): Ditto.
	* mn10300-tdep.c (mn10300_frame_unwind): Ditto.
	* moxie-tdep.c (moxie_frame_unwind): Ditto.
	* mt-tdep.c (mt_frame_unwind): Ditto.
	* ppc-linux-tdep.c (ppu2spu_unwind): Ditto.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_unwind): Ditto.
	* rs6000-tdep.c (rs6000_frame_unwind): Ditto.
	* s390-tdep.c (s390_frame_unwind, s390_stub_frame_unwind)
	(s390_sigtramp_frame_unwind): Ditto.
	* score-tdep.c (score_prologue_unwind): Ditto.
	* sh-tdep.c (sh_frame_unwind): Ditto.
	* sh64-tdep.c (sh64_frame_unwind): Ditto.
	* sparc-sol2-tdep.c (sparc32_sol2_sigtramp_frame_unwind): Ditto.
	* sparc-tdep.c (sparc32_frame_unwind): Ditto.
	* sparc64-sol2-tdep.c (sparc64_sol2_sigtramp_frame_unwind): Ditto.
	* sparc64-tdep.c (sparc64_frame_unwind): Ditto.
	* sparc64fbsd-tdep.c (sparc64fbsd_sigtramp_frame_unwind): Ditto.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_frame_unwind): Ditto.
	* sparc64obsd-tdep.c (sparc64obsd_frame_unwind)
	(sparc64obsd_trapframe_unwind): Ditto.
	* sparcnbsd-tdep.c (sparc32nbsd_sigcontext_frame_unwind): Ditto.
	* sparcobsd-tdep.c (sparc32obsd_sigtramp_frame_unwind): Ditto.
	* spu-tdep.c (spu_frame_unwind, spu2ppu_unwind): Ditto.
	* v850-tdep.c (v850_frame_unwind): Ditto.
	* vax-tdep.c (vax_frame_unwind): Ditto.
	* vaxobsd-tdep.c (vaxobsd_sigtramp_frame_unwind): Ditto.
	* xstormy16-tdep.c (frame_unwind xstormy16_frame_unwind): Ditto.
	* xtensa-tdep.c (xtensa_unwind): Ditto.
@
text
@d1209 1
d1272 1
a1272 1
    regcache_raw_supply (regcache, SPARC_G0_REGNUM, NULL);
@


1.52
log
@	gdb/
	* regcache.h (regcache_raw_read, regcache_raw_read_signed)
	(regcache_raw_read_unsigned, regcache_raw_read_signed)
	(regcache_raw_read_unsigned, regcache_raw_read_part)
	(regcache_cooked_read, regcache_cooked_read_signed)
	(regcache_cooked_read_unsigned, regcache_cooked_read_part)
	(regcache_cooked_read_ftype): Change return to enum
	register_status.
	* regcache.c: Include exceptions.h
	(regcache_save): Adjust to handle REG_UNAVAILABLE registers.
	(do_cooked_read): Change return to enum register_status.  Always
	forward to regcache_cooked_read.
	(regcache_raw_read): Change return to enum register_status.  If
	the register is not REG_VALID, memset the buffer.  Return the
	register's status.
	(regcache_raw_read_signed): Handle non-REG_VALID registers and
	return the register's status.
	(regcache_raw_read_unsigned): Ditto.
	(regcache_cooked_read): Change return to enum register_status.
	Assert that with read-only regcaches, the register's status must
	be known.  If the regcache is read-only, and the register is not
	REG_VALID, memset the buffer.  Return the register's status.
	(regcache_cooked_read_signed): Change return to enum
	register_status.  Handle non-REG_VALID registers and return the
	register's status.
	(regcache_cooked_read_unsigned): Change return to enum
	register_status.  Handle non-REG_VALID registers and return the
	register's status.
	(regcache_xfer_part, regcache_raw_read_part)
	(regcache_cooked_read_part): Change return to enum
	register_status.  Return the register's status.
	(regcache_read_pc): Throw NOT_AVAILABLE_ERROR if the register is
	unavailable.
	(regcache_dump): Handle unavailable cooked registers.
	* frame.c (do_frame_register_read): Adjust interface to match
	regcache_cooked_read_ftype.
	* gdbarch.sh (pseudo_register_read): Change return to enum
	register_status.
	* gdbarch.h, gdbarch.c: Regenerate.

	* i386-tdep.h (i386_pseudo_register_read): Change return to enum
	register_status.
	* i386-tdep.c (i386_pseudo_register_read): Change return to enum
	register_status.  If reading a raw register indicates the raw
	register is not valid, return the raw register's status,
	otherwise, return REG_VALID.
	* amd64-tdep.c (amd64_pseudo_register_read): Change return to enum
	register_status.  Handle non-REG_VALID raw registers and return
	the register's status.
	* arm-tdep.c (arm_neon_quad_read)
	(arm_pseudo_read): Change return to enum register_status.  Handle
	non-REG_VALID raw registers and return the register's status.
	* avr-tdep.c (avr_pseudo_register_read): Ditto.
	* frv-tdep.c (frv_pseudo_register_read): Ditto.
	* h8300-tdep.c (h8300_pseudo_register_read): Ditto.
	* hppa-tdep.c (hppa_pseudo_register_read): Ditto.
	* m32c-tdep.c (m32c_move_reg_t): Change return to enum
	register_status.
	(m32c_raw_read, m32c_raw_write, m32c_banked_read)
	(m32c_banked_write, m32c_sb_read, m32c_sb_write, m32c_part_read)
	(m32c_part_write, m32c_cat_read, m32c_cat_write)
	(m32c_r3r2r1r0_read, m32c_r3r2r1r0_write)
	(m32c_pseudo_register_read): Change return to enum
	register_status.  Adjust.
	* m68hc11-tdep.c (m68hc11_pseudo_register_read): Change return to
	enum register_status.  Return the register's status.
	* mep-tdep.c (mep_pseudo_cr32_read): Change return to enum
	register_status.  Return the register's status.
	(mep_pseudo_cr64_read, mep_pseudo_register_read): Ditto.
	* mips-tdep.c (mips_pseudo_register_read): Ditto.
	* mt-tdep.c (mt_pseudo_register_read): Ditto.
	* rs6000-tdep.c (move_ev_register_func): New typedef.
	(e500_move_ev_register): Use it.  Change return to enum
	register_status.  Return the register's status.
	(do_regcache_raw_read): New function.
	(do_regcache_raw_write): New function.
	(e500_pseudo_register_read): Change return to enum
	register_status.  Return the register's status.  Use
	do_regcache_raw_read.
	(e500_pseudo_register_write): Adjust.  Use do_regcache_raw_write.
	(dfp_pseudo_register_read): Change return to enum register_status.
	Return the register's status.
	(vsx_pseudo_register_read): Ditto.
	(efpr_pseudo_register_read): Ditto.
	(rs6000_pseudo_register_read): Ditto.
	* s390-tdep.c (s390_pseudo_register_read): Change return to enum
	register_status.  Return the register's status.
	* sh64-tdep.c (pseudo_register_read_portions): New function.
	(sh64_pseudo_register_read): Change return to enum
	register_status.  Use pseudo_register_read_portions.  Return the
	register's status.
	* ia64-tdep.c (ia64_pseudo_register_read): Change return to enum
	register_status.  Return the register's status.
	* sh-tdep.c (pseudo_register_read_portions): New function.
	(sh_pseudo_register_read): Change return to enum register_status.
	Use pseudo_register_read_portions.  Return the register's status.
	* sparc-tdep.c (sparc32_pseudo_register_read): Change return to
	enum register_status.  Return the register's status.
	* sparc64-tdep.c (sparc64_pseudo_register_read): Ditto.
	* spu-tdep.c (spu_pseudo_register_read_spu)
	(spu_pseudo_register_read): Ditto.
	* xtensa-tdep.c (xtensa_register_read_masked)
	(xtensa_pseudo_register_read): Ditto.
	* bfin-tdep.c (bfin_pseudo_register_read): Ditto.
@
text
@d565 1
@


1.51
log
@2011-02-25  Michael Snyder  <msnyder@@vmware.com>

	* arm-tdep.c: Fix typos in comments.
	* bsd-uthread.c: Ditto.
	* completer.c: Ditto.
	* corelow.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* cris-tdep.c: Ditto.
	* dbxread.c: Ditto.
	* dwarf2read.c: Ditto.
	* frame.h: Ditto.
	* gdbtypes.h: Ditto.
	* inferior.h: Ditto.
	* mdebugread.c: Ditto.
	* mips-tdep.c: Ditto.
	* ppc-linux-nat.c: Ditto.
	* ppc-linux-tdep.c: Ditto.
	* printcmd.c: Ditto.
	* sol-thread.c: Ditto.
	* solib-frv.c: Ditto.
	* solist.h: Ditto.
	* sparc64-tdep.c: Ditto.
	* spu-tdep.c: Ditto.
	* stabsread.c: Ditto.
	* symfile.c: Ditto.
	* valops.c: Ditto.
	* varobj.c: Ditto.
	* vax-nat.c: Ditto.
	* python/py-block.c: Ditto.
	* python/py-symbol.c: Ditto.
	* python/py-symtab.c: Ditto.
	* python/py-value.c: Ditto.
	* tui/tui-win.c: Ditto.
@
text
@d323 1
a323 1
static void
d329 2
d336 4
a339 2
      regcache_raw_read (regcache, regnum, buf);
      regcache_raw_read (regcache, regnum + 1, buf + 4);
d344 1
a344 1
      regcache_raw_read (regcache, regnum, buf);
d349 10
a358 4
      regcache_raw_read (regcache, regnum, buf);
      regcache_raw_read (regcache, regnum + 1, buf + 4);
      regcache_raw_read (regcache, regnum + 2, buf + 8);
      regcache_raw_read (regcache, regnum + 3, buf + 12);
d363 6
a368 2
      regcache_raw_read (regcache, regnum, buf);
      regcache_raw_read (regcache, regnum + 1, buf + 8);
d377 4
a380 1
      regcache_raw_read_unsigned (regcache, SPARC64_STATE_REGNUM, &state);
d398 2
@


1.50
log
@2011-01-11  Michael Snyder  <msnyder@@vmware.com>

	* s390-tdep.c: Comment cleanup, mostly periods and spaces.
	* score-tdep.c: Ditto.
	* score-tdep.h: Ditto.
	* ser-base.c: Ditto.
	* ser-go32.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* ser-mingw.c: Ditto.
	* ser-pipe.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* sh64-tdep.c: Ditto.
	* shnbsd-nat.c: Ditto.
	* sh-tdep.c: Ditto.
	* sh-tdep.h: Ditto.
	* solib.c: Ditto.
	* solib-darwin.c: Ditto.
	* solib-frv.c: Ditto.
	* solib.h: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-spu.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solist.h: Ditto.
	* sol-thread.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* source.h: Ditto.
	* sparc64-linux-tdep.c: Ditto.
	* sparc64-tdep.c: Ditto.
	* sparc-linux-nat.c: Ditto.
	* sparc-linux-tdep.c: Ditto.
	* sparc-sol2-nat.c: Ditto.
	* sparc-sol2-tdep.c: Ditto.
	* sparc-tdep.c: Ditto.
	* sparc-tdep.h: Ditto.
	* spu-tdep.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.h: Ditto.
	* stack.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target.c: Ditto.
	* target-descriptions.c: Ditto.
	* target-descriptions.h: Ditto.
	* target.h: Ditto.
	* target-memory.c: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* trad-frame.h: Ditto.
	* typeprint.c: Ditto.
@
text
@d43 1
a43 1
/* This file implements the The SPARC 64-bit ABI as defined by the
@


1.49
log
@run copyright.sh for 2011.
@
text
@d275 1
a275 1
   register REGNUM. */
@


1.48
log
@[sparc] inferior SEGV while calling Ada subprogram

gdb/ChangeLog:

        * sparc-tdep.c (sparc32_frame_align): New function.
        (sparc32_gdbarch_init): Set the frame_align gdbarch method.
        * sparc64-tdep.c (sparc64_frame_align): New function.
        (sparc64_gdbarch_init): Set the frame_align gdbarch method.
@
text
@d3 1
a3 1
   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
@


1.47
log
@"finish" does not work on sparc if function returns array.

ChangeLog:

        * sparc-tdep.c (sparc_structure_or_union_p): Return non-zero
        for array types.
        * sparc64-tdep.c (sparc64_structure_or_union_p): Likewise.
@
text
@d941 7
d1146 1
@


1.46
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d106 5
a110 1
/* Check whether TYPE is "Structure or Union".  */
d119 1
@


1.45
log
@	* defs.h (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.
	* findvar.c (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.

	* gdbcore.h (read_memory_integer, safe_read_memory_integer,
	read_memory_unsigned_integer, write_memory_signed_integer,
	write_memory_unsigned_integer): Add BYTE_ORDER parameter.
	* corefile.c (struct captured_read_memory_integer_arguments): Add
	BYTE_ORDER member.
	(safe_read_memory_integer): Add BYTE_ORDER parameter.  Store it into
	struct captured_read_memory_integer_arguments.
	(do_captured_read_memory_integer): Pass it to read_memory_integer.
	(read_memory_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_signed_integer.
	(read_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_unsigned_integer.
	(write_memory_signed_integer): Add BYTE_ORDER parameter.  Pass it
	to store_signed_integer.
	(write_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it
	to store_unsigned_integer.

	* target.h (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	* target.c (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	Pass it to extract_unsigned_integer.


	Update calls to extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer, read_memory_integer,
	read_memory_unsigned_integer, safe_read_memory_integer,
	write_memory_signed_integer, write_memory_unsigned_integer, and
	get_target_memory_unsigned to pass byte order:
	* ada-lang.c (ada_value_binop): Update.
	* ada-valprint.c (char_at): Update.
	* alpha-osf1-tdep.c (alpha_osf1_sigcontext_addr): Update.
	* alpha-tdep.c (alpha_lds, alpha_sts, alpha_push_dummy_call,
	alpha_extract_return_value, alpha_read_insn,
	alpha_get_longjmp_target): Update.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Update.
	* amd64obsd-tdep.c (amd64obsd_supply_uthread,
	amd64obsd_collect_uthread, amd64obsd_trapframe_cache): Update.
	* amd64-tdep.c (amd64_push_dummy_call, amd64_analyze_prologue,
	amd64_frame_cache, amd64_sigtramp_frame_cache, fixup_riprel,
	amd64_displaced_step_fixup): Update.
	* arm-linux-tdep.c (arm_linux_sigreturn_init,
	arm_linux_rt_sigreturn_init, arm_linux_supply_gregset): Update.
	* arm-tdep.c (thumb_analyze_prologue, arm_skip_prologue,
	arm_scan_prologue, arm_push_dummy_call, thumb_get_next_pc,
	arm_get_next_pc, arm_extract_return_value, arm_store_return_value,
	arm_return_value): Update.
	* arm-wince-tdep.c (arm_pe_skip_trampoline_code): Update.
	* auxv.c (default_auxv_parse): Update.
	* avr-tdep.c (avr_address_to_pointer, avr_pointer_to_address,
	avr_scan_prologue, avr_extract_return_value,
	avr_frame_prev_register, avr_push_dummy_call): Update.
	* bsd-uthread.c (bsd_uthread_check_magic, bsd_uthread_lookup_offset,
	bsd_uthread_wait, bsd_uthread_thread_alive,
	bsd_uthread_extra_thread_info): Update.
	* c-lang.c (c_printstr, print_wchar): Update.
	* cp-valprint.c (cp_print_class_member): Update.
	* cris-tdep.c (cris_sigcontext_addr, cris_sigtramp_frame_unwind_cache,
	cris_push_dummy_call, cris_scan_prologue, cris_store_return_value,
	cris_extract_return_value, find_step_target, dip_prefix,
	sixteen_bit_offset_branch_op, none_reg_mode_jump_op,
	move_mem_to_reg_movem_op, get_data_from_address): Update.
	* dwarf2expr.c (dwarf2_read_address, execute_stack_op): Update.
	* dwarf2-frame.c (execute_cfa_program): Update.
	* dwarf2loc.c (find_location_expression): Update.
	* dwarf2read.c (dwarf2_const_value): Update.
	* expprint.c (print_subexp_standard): Update.
	* findvar.c (unsigned_pointer_to_address, signed_pointer_to_address,
	unsigned_address_to_pointer, address_to_signed_pointer,
	read_var_value): Update.
	* frame.c (frame_unwind_register_signed,
	frame_unwind_register_unsigned, get_frame_memory_signed,
	get_frame_memory_unsigned): Update.
	* frame-unwind.c (frame_unwind_got_constant): Update.
	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp,
	frv_linux_sigcontext_reg_addr, frv_linux_sigtramp_frame_cache):
	Update.
	* frv-tdep.c (frv_analyze_prologue, frv_skip_main_prologue,
	frv_extract_return_value, find_func_descr,
	frv_convert_from_func_ptr_addr, frv_push_dummy_call): Update.
	* f-valprint.c (f_val_print): Update.
	* gnu-v3-abi.c (gnuv3_decode_method_ptr, gnuv3_make_method_ptr):
	Update.
	* h8300-tdep.c (h8300_is_argument_spill, h8300_analyze_prologue,
	h8300_push_dummy_call, h8300_extract_return_value,
	h8300h_extract_return_value, h8300_store_return_value,
	h8300h_store_return_value): Update.
	* hppabsd-tdep.c (hppabsd_find_global_pointer): Update.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register, hppa_hpux_store_register):
	Update.
	* hppa-hpux-tdep.c (hppa32_hpux_in_solib_call_trampoline,
	hppa64_hpux_in_solib_call_trampoline,
	hppa_hpux_in_solib_return_trampoline, hppa_hpux_skip_trampoline_code,
	hppa_hpux_sigtramp_frame_unwind_cache,
	hppa_hpux_sigtramp_unwind_sniffer, hppa32_hpux_find_global_pointer,
	hppa64_hpux_find_global_pointer, hppa_hpux_search_pattern,
	hppa32_hpux_search_dummy_call_sequence,
	hppa64_hpux_search_dummy_call_sequence, hppa_hpux_supply_save_state,
	hppa_hpux_unwind_adjust_stub): Update.
	* hppa-linux-tdep.c (insns_match_pattern,
	hppa_linux_find_global_pointer): Update.
	* hppa-tdep.c (hppa_in_function_epilogue_p, hppa32_push_dummy_call,
	hppa64_convert_code_addr_to_fptr, hppa64_push_dummy_call,
	skip_prologue_hard_way, hppa_frame_cache, hppa_fallback_frame_cache,
	hppa_pseudo_register_read, hppa_frame_prev_register_helper,
	hppa_match_insns): Update.
	* hpux-thread.c (hpux_thread_fetch_registers): Update.
	* i386-tdep.c (i386bsd_sigcontext_addr): Update.
	* i386-cygwin-tdep.c (core_process_module_section): Update.
	* i386-darwin-nat.c (i386_darwin_sstep_at_sigreturn,
	amd64_darwin_sstep_at_sigreturn): Update.
	* i386-darwin-tdep.c (i386_darwin_sigcontext_addr,
	amd64_darwin_sigcontext_addr): Likewise.
	* i386-linux-nat.c (i386_linux_sigcontext_addr): Update.
	* i386nbsd-tdep.c (i386nbsd_sigtramp_cache_init): Update.
	* i386-nto-tdep.c (i386nto_sigcontext_addr): Update.
	* i386obsd-nat.c (i386obsd_supply_pcb): Update.
	* i386obsd-tdep.c (i386obsd_supply_uthread, i386obsd_collect_uthread,
	i386obsd_trapframe_cache): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_follow_jump,
	i386_analyze_frame_setup, i386_analyze_prologue,
	i386_skip_main_prologue, i386_frame_cache, i386_sigtramp_frame_cache,
	i386_get_longjmp_target, i386_push_dummy_call,
	i386_pe_skip_trampoline_code, i386_svr4_sigcontext_addr,
	i386_fetch_pointer_argument): Update.
	* i387-tdep.c (i387_supply_fsave): Update.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Update.
	* ia64-tdep.c (ia64_pseudo_register_read, ia64_pseudo_register_write,
	examine_prologue, ia64_frame_cache, ia64_frame_prev_register,
	ia64_sigtramp_frame_cache, ia64_sigtramp_frame_prev_register,
	ia64_access_reg, ia64_access_rse_reg, ia64_libunwind_frame_this_id,
	ia64_libunwind_frame_prev_register,
	ia64_libunwind_sigtramp_frame_this_id,
	ia64_libunwind_sigtramp_frame_prev_register, ia64_find_global_pointer,
	find_extant_func_descr, find_func_descr,
	ia64_convert_from_func_ptr_addr, ia64_push_dummy_call, ia64_dummy_id,
	ia64_unwind_pc): Update.
	* iq2000-tdep.c (iq2000_pointer_to_address, iq2000_address_to_pointer,
	iq2000_scan_prologue, iq2000_extract_return_value,
	iq2000_push_dummy_call): Update.
	* irix5nat.c (fill_gregset): Update.
	* jv-lang.c (evaluate_subexp_java): Update.
	* jv-valprint.c (java_value_print): Update.
	* lm32-tdep.c (lm32_analyze_prologue, lm32_push_dummy_call,
	lm32_extract_return_value, lm32_store_return_value): Update.
	* m32c-tdep.c (m32c_push_dummy_call, m32c_return_value,
	m32c_skip_trampoline_code, m32c_m16c_address_to_pointer,
	m32c_m16c_pointer_to_address): Update.
	* m32r-tdep.c (m32r_store_return_value, decode_prologue,
	m32r_skip_prologue, m32r_push_dummy_call, m32r_extract_return_value):
	Update.
	* m68hc11-tdep.c (m68hc11_pseudo_register_read,
	m68hc11_pseudo_register_write, m68hc11_analyze_instruction,
	m68hc11_push_dummy_call): Update.
	* m68linux-tdep.c (m68k_linux_pc_in_sigtramp,
	m68k_linux_get_sigtramp_info, m68k_linux_sigtramp_frame_cache):
	Update.
	* m68k-tdep.c (m68k_push_dummy_call, m68k_analyze_frame_setup,
	m68k_analyze_register_saves, m68k_analyze_prologue, m68k_frame_cache,
	m68k_get_longjmp_target): Update.
	* m88k-tdep.c (m88k_fetch_instruction): Update.
	* mep-tdep.c (mep_pseudo_cr32_read, mep_pseudo_csr_write,
	mep_pseudo_cr32_write, mep_get_insn, mep_push_dummy_call): Update.
	* mi/mi-main.c (mi_cmd_data_write_memory): Update.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target, supply_32bit_reg,
	mips64_linux_get_longjmp_target, mips64_fill_gregset,
	mips64_fill_fpregset, mips_linux_in_dynsym_stub): Update.
	* mipsnbdsd-tdep.c (mipsnbsd_get_longjmp_target): Update.
	* mips-tdep.c (mips_fetch_instruction, fetch_mips_16,
	mips_eabi_push_dummy_call, mips_n32n64_push_dummy_call,
	mips_o32_push_dummy_call, mips_o64_push_dummy_call,
	mips_single_step_through_delay, mips_skip_pic_trampoline_code,
	mips_integer_to_address): Update.
	* mn10300-tdep.c (mn10300_analyze_prologue, mn10300_push_dummy_call):
	Update.
	* monitor.c (monitor_supply_register, monitor_write_memory,
	monitor_read_memory_single): Update.
	* moxie-tdep.c (moxie_store_return_value, moxie_extract_return_value,
	moxie_analyze_prologue): Update.
	* mt-tdep.c (mt_return_value, mt_skip_prologue, mt_select_coprocessor,
	mt_pseudo_register_read, mt_pseudo_register_write, mt_registers_info,
	mt_push_dummy_call): Update.
	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class, find_implementation_from_class): Update.
	* ppc64-linux-tdep.c (ppc64_desc_entry_point,
	ppc64_linux_convert_from_func_ptr_addr, ppc_linux_sigtramp_cache):
	Update.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_sniffer,
	ppcobsd_sigtramp_frame_cache): Update.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call,
	do_ppc_sysv_return_value, ppc64_sysv_abi_push_dummy_call,
	ppc64_sysv_abi_return_value): Update.
	* ppc-linux-nat.c (ppc_linux_auxv_parse): Update.
	* procfs.c (procfs_auxv_parse): Update.
	* p-valprint.c (pascal_val_print): Update.
	* regcache.c (regcache_raw_read_signed, regcache_raw_read_unsigned,
	regcache_raw_write_signed, regcache_raw_write_unsigned,
	regcache_cooked_read_signed, regcache_cooked_read_unsigned,
	regcache_cooked_write_signed, regcache_cooked_write_unsigned): Update.
	* remote-m32r-sdi.c (m32r_fetch_register): Update.
	* remote-mips.c (mips_wait, mips_fetch_registers, mips_xfer_memory):
	Update.
	* rs6000-aix-tdep.c (rs6000_push_dummy_call, rs6000_return_value,
	rs6000_convert_from_func_ptr_addr, branch_dest,
	rs6000_software_single_step): Update.
	* rs6000-tdep.c (rs6000_in_function_epilogue_p,
	ppc_displaced_step_fixup, ppc_deal_with_atomic_sequence,
	bl_to_blrl_insn_p, rs6000_fetch_instruction, skip_prologue,
	rs6000_skip_main_prologue, rs6000_skip_trampoline_code,
	rs6000_frame_cache): Update.
	* s390-tdep.c (s390_pseudo_register_read, s390_pseudo_register_write,
	s390x_pseudo_register_read, s390x_pseudo_register_write, s390_load,
	s390_backchain_frame_unwind_cache, s390_sigtramp_frame_unwind_cache,
	extend_simple_arg, s390_push_dummy_call, s390_return_value): Update.
	* scm-exp.c (scm_lreadr): Update.
	* scm-lang.c (scm_get_field, scm_unpack): Update.
	* scm-valprint.c (scm_val_print): Update.
	* score-tdep.c (score_breakpoint_from_pc, score_push_dummy_call,
	score_fetch_inst): Update.
	* sh64-tdep.c (look_for_args_moves, sh64_skip_prologue_hard_way,
	sh64_analyze_prologue, sh64_push_dummy_call, sh64_extract_return_value,
	sh64_pseudo_register_read, sh64_pseudo_register_write,
	sh64_frame_prev_register): Update:
	* sh-tdep.c (sh_analyze_prologue, sh_push_dummy_call_fpu,
	sh_push_dummy_call_nofpu, sh_extract_return_value_nofpu,
	sh_store_return_value_nofpu, sh_in_function_epilogue_p): Update.
	* solib-darwin.c (darwin_load_image_infos): Update.
	* solib-frv.c (fetch_loadmap, lm_base, frv_current_sos, enable_break2,
	find_canonical_descriptor_in_load_object): Update.
	* solib-irix.c (extract_mips_address, fetch_lm_info, irix_current_sos,
	irix_open_symbol_file_object): Update.
	* solib-som.c (som_solib_create_inferior_hook, link_map_start,
	som_current_sos, som_open_symbol_file_object): Update.
	* solib-sunos.c (SOLIB_EXTRACT_ADDRESS, LM_ADDR, LM_NEXT, LM_NAME):
	Update.
	* solib-svr4.c (read_program_header, scan_dyntag_auxv,
	solib_svr4_r_ldsomap): Update.
	* sparc64-linux-tdep.c (sparc64_linux_step_trap): Update.
	* sparc64obsd-tdep.c (sparc64obsd_supply_uthread,
	sparc64obsd_collect_uthread): Update.
	* sparc64-tdep.c (sparc64_pseudo_register_read,
	sparc64_pseudo_register_write, sparc64_supply_gregset,
	sparc64_collect_gregset): Update.
	* sparc-linux-tdep.c (sparc32_linux_step_trap): Update.
	* sparcobsd-tdep.c (sparc32obsd_supply_uthread,
	sparc32obsd_collect_uthread): Update.
	* sparc-tdep.c (sparc_fetch_wcookie, sparc32_push_dummy_code,
	sparc32_store_arguments, sparc32_return_value, sparc_supply_rwindow,
	sparc_collect_rwindow): Update.
	* spu-linux-nat.c (parse_spufs_run): Update.
	* spu-tdep.c (spu_pseudo_register_read_spu,
	spu_pseudo_register_write_spu, spu_pointer_to_address,
	spu_analyze_prologue, spu_in_function_epilogue_p,
	spu_frame_unwind_cache, spu_push_dummy_call, spu_software_single_step,
	spu_get_longjmp_target, spu_get_overlay_table, spu_overlay_update_osect,
	info_spu_signal_command, info_spu_mailbox_list, info_spu_dma_cmdlist,
	info_spu_dma_command, info_spu_proxydma_command): Update.
	* stack.c (print_frame_nameless_args, frame_info): Update.
	* symfile.c (read_target_long_array, simple_read_overlay_table,
	simple_read_overlay_region_table): Update.
	* target.c (debug_print_register): Update.
	* tramp-frame.c (tramp_frame_start): Update.
	* v850-tdep.c (v850_analyze_prologue, v850_push_dummy_call,
	v850_extract_return_value, v850_store_return_value,
	* valarith.c (value_binop, value_bit_index): Update.
	* valops.c (value_cast): Update.
	* valprint.c (val_print_type_code_int, val_print_string,
	read_string): Update.
	* value.c (unpack_long, unpack_double, unpack_field_as_long,
	modify_field, pack_long): Update.
	* vax-tdep.c (vax_store_arguments, vax_push_dummy_call,
	vax_skip_prologue): Update.
	* xstormy16-tdep.c (xstormy16_push_dummy_call,
	xstormy16_analyze_prologue, xstormy16_in_function_epilogue_p,
	xstormy16_resolve_jmp_table_entry, xstormy16_find_jmp_table_entry,
	xstormy16_pointer_to_address, xstormy16_address_to_pointer): Update.
	* xtensa-tdep.c (extract_call_winsize, xtensa_pseudo_register_read,
	xtensa_pseudo_register_write, xtensa_frame_cache,
	xtensa_push_dummy_call, call0_track_op, call0_frame_cache): Update.


	* dfp.h (decimal_to_string, decimal_from_string, decimal_from_integral,
	decimal_from_floating, decimal_to_doublest, decimal_is_zero): Add
	BYTE_ORDER parameter.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	* dfp.c (match_endianness): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.
	(decimal_to_string, decimal_from_integral, decimal_from_floating,
	decimal_to_doublest, decimal_is_zero): Add BYTE_ORDER parameter.
	Pass it to match_endianness.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.  Pass them to match_endianness.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	Pass them to match_endianness.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	Pass them to match_endianness.
	* valarith.c (value_args_as_decimal): Add BYTE_ORDER_X and
	BYTE_ORDER_Y output parameters.
	(value_binop): Update call to value_args_as_decimal.

	Update calls to decimal_to_string, decimal_from_string,
	decimal_from_integral, decimal_from_floating, decimal_to_doublest,
	decimal_is_zero, decimal_binop, decimal_compare and decimal_convert
	to pass/receive byte order:
	* c-exp.y (parse_number): Update.
	* printcmd.c (printf_command): Update.
	* valarith.c (value_args_as_decimal, value_binop, value_logical_not,
	value_equal, value_less): Update.
	* valops.c (value_cast, value_one): Update.
	* valprint.c (print_decimal_floating): Update.
	* value.c (unpack_long, unpack_double): Update.
	* python/python-value.c (valpy_nonzero): Update.


	* ada-valprint.c (char_at): Add BYTE_ORDER parameter.
	(printstr): Update calls to char_at.
	(ada_val_print_array): Likewise.
	* valprint.c (read_string): Add BYTE_ORDER parameter.
	(val_print_string): Update call to read_string.
	* c-lang.c (c_get_string): Likewise.
	* charset.h (target_wide_charset): Add BYTE_ORDER parameter.
	* charset.c (target_wide_charset): Add BYTE_ORDER parameter.
	Use it instead of current_gdbarch.
	* printcmd.c (printf_command): Update calls to target_wide_charset.
	* c-lang.c (charset_for_string_type): Add BYTE_ORDER parameter.
	Pass to target_wide_charset.  Use it instead of current_gdbarch.
	(classify_type): Add BYTE_ORDER parameter.  Pass to
	charset_for_string_type.  Allow NULL encoding pointer.
	(print_wchar): Add BYTE_ORDER parameter.
	(c_emit_char): Update calls to classify_type and print_wchar.
	(c_printchar, c_printstr): Likewise.


	* gdbarch.sh (in_solib_return_trampoline): Convert to type "m".
	* gdbarch.c, gdbarch.h: Regenerate.
	* arch-utils.h (generic_in_solib_return_trampoline): Add GDBARCH
	parameter.
	* arch-utils.c (generic_in_solib_return_trampoline): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_in_solib_return_trampoline): Likewise.
	* rs6000-tdep.c (rs6000_in_solib_return_trampoline): Likewise.
	(rs6000_skip_trampoline_code): Update call.

	* alpha-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	dynamic_sigtramp_offset and pc_in_sigtramp callbacks.
	(alpha_read_insn): Add GDBARCH parameter.
	* alpha-tdep.c (alpha_lds, alpha_sts): Add GDBARCH parameter.
	(alpha_register_to_value): Pass architecture to alpha_sts.
	(alpha_extract_return_value): Likewise.
	(alpha_value_to_register): Pass architecture to alpha_lds.
	(alpha_store_return_value): Likewise.
	(alpha_read_insn): Add GDBARCH parameter.
	(alpha_skip_prologue): Pass architecture to alpha_read_insn.
	(alpha_heuristic_proc_start): Likewise.
	(alpha_heuristic_frame_unwind_cache): Likewise.
	(alpha_next_pc): Likewise.
	(alpha_sigtramp_frame_this_id): Pass architecture to
	tdep->dynamic_sigtramp_offset callback.
	(alpha_sigtramp_frame_sniffer): Pass architecture to
	tdep->pc_in_sigtramp callback.
	* alphafbsd-tdep.c (alphafbsd_pc_in_sigtramp): Add GDBARCH parameter.
	(alphafbsd_sigtramp_offset): Likewise.
	* alpha-linux-tdep.c (alpha_linux_sigtramp_offset_1): Add GDBARCH
	parameter.  Pass to alpha_read_insn.
	(alpha_linux_sigtramp_offset): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset_1.
	(alpha_linux_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset.
	(alpha_linux_sigcontext_addr): Pass architecture to alpha_read_insn
	and alpha_linux_sigtramp_offset.
	* alphanbsd-tdep.c (alphanbsd_sigtramp_offset): Add GDBARCH parameter.
	(alphanbsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alphanbsd_sigtramp_offset.
	* alphaobsd-tdep.c (alphaobsd_sigtramp_offset): Add GDBARCH parameter.
	(alphaobsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_read_insn.
	(alphaobsd_sigcontext_addr): Pass architecture to
	alphaobsd_sigtramp_offset.
	* alpha-osf1-tdep.c (alpha_osf1_pc_in_sigtramp): Add GDBARCH
	parameter.

	* amd64-tdep.c (amd64_analyze_prologue): Add GDBARCH parameter.
	(amd64_skip_prologue): Pass architecture to amd64_analyze_prologue.
	(amd64_frame_cache): Likewise.

	* arm-tdep.c (SWAP_SHORT, SWAP_INT): Remove.
	(thumb_analyze_prologue, arm_skip_prologue, arm_scan_prologue,
	thumb_get_next_pc, arm_get_next_pc): Do not use SWAP_ macros.
	* arm-wince-tdep.c: Include "frame.h".

	* avr-tdep.c (EXTRACT_INSN): Remove.
	(avr_scan_prologue): Add GDBARCH argument, inline EXTRACT_INSN.
	(avr_skip_prologue): Pass architecture to avr_scan_prologue.
	(avr_frame_unwind_cache): Likewise.

	* cris-tdep.c (struct instruction_environment): Add BYTE_ORDER member.
	(find_step_target): Initialize it.
	(get_data_from_address): Add BYTE_ORDER parameter.
	(bdap_prefix): Pass byte order to get_data_from_address.
	(handle_prefix_assign_mode_for_aritm_op): Likewise.
	(three_operand_add_sub_cmp_and_or_op): Likewise.
	(handle_inc_and_index_mode_for_aritm_op): Likewise.

	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp): Add GDBARCH parameter.
	(frv_linux_sigcontext_reg_addr): Pass architecture to
	frv_linux_pc_in_sigtramp.
	(frv_linux_sigtramp_frame_sniffer): Likewise.

	* h8300-tdep.c (h8300_is_argument_spill): Add GDBARCH parameter.
	(h8300_analyze_prologue): Add GDBARCH parameter.  Pass to
	h8300_is_argument_spill.
	(h8300_frame_cache, h8300_skip_prologue): Pass architecture
	to h8300_analyze_prologue.

	* hppa-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	in_solib_call_trampoline callback.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.
	* hppa-tdep.c (hppa64_convert_code_addr_to_fptr): Add GDBARCH
	parameter.
	(hppa64_push_dummy_call): Pass architecture to
	hppa64_convert_code_addr_to_fptr.
	(hppa_match_insns): Add GDBARCH parameter.
	(hppa_match_insns_relaxed): Add GDBARCH parameter.  Pass to
	hppa_match_insns.
	(hppa_skip_trampoline_code): Pass architecture to hppa_match_insns.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.  Pass to
	hppa_match_insns_relaxed.
	(hppa_stub_unwind_sniffer): Pass architecture to
	tdep->in_solib_call_trampoline callback.
	* hppa-hpux-tdep.c (hppa_hpux_search_pattern): Add GDBARCH parameter.
	(hppa32_hpux_search_dummy_call_sequence): Pass architecture to
	hppa_hpux_search_pattern.
	* hppa-linux-tdep.c (insns_match_pattern): Add GDBARCH parameter.
	(hppa_linux_sigtramp_find_sigcontext): Add GDBARCH parameter.
	Pass to insns_match_pattern.
	(hppa_linux_sigtramp_frame_unwind_cache): Pass architecture to
	hppa_linux_sigtramp_find_sigcontext.
	(hppa_linux_sigtramp_frame_sniffer): Likewise.
	(hppa32_hpux_in_solib_call_trampoline): Add GDBARCH parameter.
	(hppa64_hpux_in_solib_call_trampoline): Likewise.

	* i386-tdep.c (i386_follow_jump): Add GDBARCH parameter.
	(i386_analyze_frame_setup): Add GDBARCH parameter.
	(i386_analyze_prologue): Add GDBARCH parameter.  Pass to
	i386_follow_jump and i386_analyze_frame_setup.
	(i386_skip_prologue): Pass architecture to i386_analyze_prologue
	and i386_follow_jump.
	(i386_frame_cache): Pass architecture to i386_analyze_prologue.
	(i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-tdep.h (i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-cygwin-tdep.c (i386_cygwin_skip_trampoline_code): Pass
	frame to i386_pe_skip_trampoline_code.

	* ia64-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter
	to sigcontext_register_address callback.
	* ia64-tdep.c (ia64_find_global_pointer): Add GDBARCH parameter.
	(ia64_find_unwind_table): Pass architecture to
	ia64_find_global_pointer.
	(find_extant_func_descr): Add GDBARCH parameter.
	(find_func_descr): Pass architecture to find_extant_func_descr
	and ia64_find_global_pointer.
	(ia64_sigtramp_frame_init_saved_regs): Pass architecture to
	tdep->sigcontext_register_address callback.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Add
	GDBARCH parameter.

	* iq2000-tdep.c (iq2000_scan_prologue): Add GDBARCH parameter.
	(iq2000_frame_cache): Pass architecture to iq2000_scan_prologue.

	* lm32-tdep.c (lm32_analyze_prologue): Add GDBARCH parameter.
	(lm32_skip_prologue, lm32_frame_cache): Pass architecture to
	lm32_analyze_prologue.

	* m32r-tdep.c (decode_prologue): Add GDBARCH parameter.
	(m32r_skip_prologue): Pass architecture to decode_prologue.

	* m68hc11-tdep.c (m68hc11_analyze_instruction): Add GDBARCH parameter.
	(m68hc11_scan_prologue): Pass architecture to
	m68hc11_analyze_instruction.

	* m68k-tdep.c (m68k_analyze_frame_setup): Add GDBARCH parameter.
	(m68k_analyze_prologue): Pass architecture to
	m68k_analyze_frame_setup.

	* m88k-tdep.c (m88k_fetch_instruction): Add BYTE_ORDER parameter.
	(m88k_analyze_prologue): Add GDBARCH parameter.  Pass byte order
	to m88k_fetch_instruction.
	(m88k_skip_prologue): Pass architecture to m88k_analyze_prologue.
	(m88k_frame_cache): Likewise.

	* mep-tdep.c (mep_get_insn): Add GDBARCH parameter.
	(mep_analyze_prologue): Pass architecture to mep_get_insn.

	* mips-tdep.c (mips_fetch_instruction): Add GDBARCH parameter.
	(mips32_next_pc): Pass architecture to mips_fetch_instruction.
	(deal_with_atomic_sequence): Likewise.
	(unpack_mips16): Add GDBARCH parameter, pass to mips_fetch_instruction.
	(mips16_scan_prologue): Likewise.
	(mips32_scan_prologue): Likewise.
	(mips16_in_function_epilogue_p): Likewise.
	(mips32_in_function_epilogue_p): Likewise.
	(mips_about_to_return): Likewise.
	(mips_insn16_frame_cache): Pass architecture to mips16_scan_prologue.
	(mips_insn32_frame_cache): Pass architecture to mips32_scan_prologue.
	(mips_skip_prologue): Pass architecture to mips16_scan_prologue
	and mips32_scan_prologue.
	(mips_in_function_epilogue_p): Pass architecture to
	mips16_in_function_epilogue_p and
	mips32_in_function_epilogue_p.
	(heuristic_proc_start): Pass architecture to mips_fetch_instruction
	and mips_about_to_return.
	(mips_skip_mips16_trampoline_code): Pass architecture to
	mips_fetch_instruction.
	(fetch_mips_16): Add GDBARCH parameter.
	(mips16_next_pc): Pass architecture to fetch_mips_16.
	(extended_mips16_next_pc): Pass architecture to unpack_mips16 and
	fetch_mips_16.

	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class): Add GDBARCH parameter.
	(find_implementation_from_class): Add GDBARCH parameter, pass
	to read_objc_class, read_objc_methlist_nmethods, and
	read_objc_methlist_method.
	(find_implementation): Add GDBARCH parameter, pass to
	read_objc_object and find_implementation_from_class.
	(resolve_msgsend, resolve_msgsend_stret): Pass architecture
	to find_implementation.
	(resolve_msgsend_super, resolve_msgsend_super_stret): Pass
	architecture to read_objc_super and find_implementation_from_class.

	* ppc64-linux-tdep.c (ppc64_desc_entry_point): Add GDBARCH parameter.
	(ppc64_standard_linkage1_target, ppc64_standard_linkage2_target,
	ppc64_standard_linkage3_target): Pass architecture to
	ppc64_desc_entry_point.
	* rs6000-tdep.c (bl_to_blrl_insn_p): Add BYTE_ORDER parameter.
	(skip_prologue): Pass byte order to bl_to_blrl_insn_p.
	(rs6000_fetch_instruction): Add GDBARCH parameter.
	(rs6000_skip_stack_check): Add GDBARCH parameter, pass to
	rs6000_fetch_instruction.
	(skip_prologue): Pass architecture to rs6000_fetch_instruction.

	* remote-mips.c (mips_store_word): Return old_contents as host
	integer value instead of target bytes.

	* s390-tdep.c (struct s390_prologue_data): Add BYTE_ORDER member.
	(s390_analyze_prologue): Initialize it.
	(extend_simple_arg): Add GDBARCH parameter.
	(s390_push_dummy_call): Pass architecture to extend_simple_arg.

	* scm-lang.c (scm_get_field): Add BYTE_ORDER parameter.
	* scm-lang.h (scm_get_field): Add BYTE_ORDER parameter.
	(SCM_CAR, SCM_CDR): Pass SCM_BYTE_ORDER to scm_get_field.
	* scm-valprint.c (scm_scmval_print): Likewise.
	(scm_scmlist_print, scm_ipruk, scm_scmval_print): Define
	SCM_BYTE_ORDER.

	* sh64-tdep.c (look_for_args_moves): Add GDBARCH parameter.
	(sh64_skip_prologue_hard_way): Add GDBARCH parameter, pass to
	look_for_args_moves.
	(sh64_skip_prologue): Pass architecture to
	sh64_skip_prologue_hard_way.
	* sh-tdep.c (sh_analyze_prologue): Add GDBARCH parameter.
	(sh_skip_prologue): Pass architecture to sh_analyze_prologue.
	(sh_frame_cache): Likewise.

	* solib-irix.c (extract_mips_address): Add GDBARCH parameter.
	(fetch_lm_info, irix_current_sos, irix_open_symbol_file_object):
	Pass architecture to extract_mips_address.

	* sparc-tdep.h (sparc_fetch_wcookie): Add GDBARCH parameter.
	* sparc-tdep.c (sparc_fetch_wcookie): Add GDBARCH parameter.
	(sparc_supply_rwindow, sparc_collect_rwindow): Pass architecture
	to sparc_fetch_wcookie.
	(sparc32_frame_prev_register): Likewise.
	* sparc64-tdep.c (sparc64_frame_prev_register): Likewise.
	* sparc32nbsd-tdep.c (sparc32nbsd_sigcontext_saved_regs): Likewise.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_saved_regs): Likewise.

	* spu-tdep.c (spu_analyze_prologue): Add GDBARCH parameter.
	(spu_skip_prologue): Pass architecture to spu_analyze_prologue.
	(spu_virtual_frame_pointer): Likewise.
	(spu_frame_unwind_cache): Likewise.
	(info_spu_mailbox_list): Add BYTE_ORER parameter.
	(info_spu_mailbox_command): Pass byte order to info_spu_mailbox_list.
	(info_spu_dma_cmdlist): Add BYTE_ORER parameter.
	(info_spu_dma_command, info_spu_proxydma_command): Pass byte order
	to info_spu_dma_cmdlist.

	* symfile.c (read_target_long_array): Add GDBARCH parameter.
	(simple_read_overlay_table, simple_read_overlay_region_table,
	simple_overlay_update_1): Pass architecture to read_target_long_array.

	* v850-tdep.c (v850_analyze_prologue): Add GDBARCH parameter.
	(v850_frame_cache): Pass architecture to v850_analyze_prologue.

	* xstormy16-tdep.c (xstormy16_analyze_prologue): Add GDBARCH
	parameter.
	(xstormy16_skip_prologue, xstormy16_frame_cache): Pass architecture
	to xstormy16_analyze_prologue.
	(xstormy16_resolve_jmp_table_entry): Add GDBARCH parameter.
	(xstormy16_find_jmp_table_entry): Likewise.
	(xstormy16_skip_trampoline_code): Pass architecture to
	xstormy16_resolve_jmp_table_entry.
	(xstormy16_pointer_to_address): Likewise.
	(xstormy16_address_to_pointer): Pass architecture to
	xstormy16_find_jmp_table_entry.

	* xtensa-tdep.c (call0_track_op): Add GDBARCH parameter.
	(call0_analyze_prologue): Add GDBARCH parameter, pass to
	call0_track_op.
	(call0_frame_cache): Pass architecture to call0_analyze_prologue.
	(xtensa_skip_prologue): Likewise.
@
text
@d3 1
a3 1
   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009
@


1.44
log
@	* gdbtypes.h (TYPE_OBJFILE_OWNED, TYPE_OWNER): New macros.
	(TYPE_OBJFILE, TYPE_ALLOC, TYPE_ZALLOC): Reimplement.
	(alloc_type_arch): Add prototype.
	(alloc_type_copy): Likewise.
	(get_type_arch): Likewise.
	(arch_type): Likewise.
	(arch_integer_type): Likewise.
	(arch_character_type): Likewise.
	(arch_boolean_type): Likewise.
	(init_float_type): Remove, replace by ...
	(arch_float_type): ... this.
	(init_complex_type): Remove, replace by ...
	(arch_complex_type): ... this.
	(init_flags_type): Remove, replace by ...
	(arch_flags_type): ... this.
	(init_composite_type): Remove, replace by ...
	(arch_composite_type): ... this.

	* gdbtypes.c (alloc_type): No longer support NULL objfile.
	(init_type): Likewise.
	(alloc_type_arch): New function.
	(alloc_type_copy): New function.
	(get_type_arch): New function.

	(smash_type): Preserve type ownership information.
	(make_pointer_type, make_reference_type, make_function_type,
	smash_to_memberptr_type, smash_to_method_type): No longer
	preserve OBJFILE across smash_type calls.
	(make_pointer_type, make_reference_type, make_function_type,
	lookup_memberptr_type, lookup_methodptr_type, allocate_stub_method,
	create_range_type, create_array_type, create_set_type, copy_type):
	Use alloc_type_copy when allocating types.
	(check_typedef): Use alloc_type_arch.
	(copy_type_recursive): Likewise.  Preserve type ownership data
	after copying type.
	(recursive_dump_type): Dump type ownership data.
	(alloc_type_instance): Update type ownership check.
	(copy_type, copy_type_recursive): Likewise.

	(arch_type): New function.
	(arch_integer_type): Likewise.
	(arch_character_type): Likewise.
	(arch_boolean_type): Likewise.
	(init_float_type): Remove, replace by ...
	(arch_float_type): ... this.
	(init_complex_type): Remove, replace by ...
	(arch_complex_type): ... this.
	(init_flags_type): Remove, replace by ...
	(arch_flags_type): ... this.
	(append_flags_type_flag): Move down.
	(init_composite_type): Remove, replace by ...
	(arch_composite_type): ... this.
	(append_composite_type_field_aligned,
	append_composite_type_field): Move down.

	* gdbarch.c (gdbtypes_post_init): Allocate all types
	using per-architecture routines.
	* ada-lang.c (ada_language_arch_info): Likewise.
	* f-lang.c (build_fortran_types): Likewise.
	* jv-lang.c (build_java_types): Likewise.
	* m2-lang.c (build_m2_types): Likewise.
	* scm-lang.c (build_scm_types): Likewise.

	* ada-lang.c (ada_type_of_array): Use alloc_type_copy.
	(packed_array_type): Likewise.
	(ada_template_to_fixed_record_type_1): Likewise.
	(template_to_static_fixed_type): Likewise.
	(to_record_with_fixed_variant_part): Likewise.
	(to_fixed_variant_branch_type): Likewise.
	(to_fixed_array_type): Likewise.
	(to_fixed_range_type): Likewise.
	(empty_record): Use type instead of objfile argument.
	Use alloc_type_copy.
	(to_fixed_variant_branch_type): Update call to empty_record.
	* jv-lang.c (type_from_class): Use alloc_type_arch.

	* arm-tdep.c (arm_ext_type): Allocate per-architecture type.
	* i386-tdep.c (i386_eflags_type, i386_mxcsr_type, i387_ext_type,
	i386_mmx_type, i386_sse_type): Likewise.
	* ia64-tdep.c (ia64_ext_type): Likewise.
	* m32c-tdep.c (make_types): Likewise.
	* m68k-tdep.c (m68k_ps_type, m68881_ext_type): Likewise.
	* rs6000-tdep.c (rs6000_builtin_type_vec64,
	rs6000_builtin_type_vec128): Likewise.
	* sparc-tdep.c (sparc_psr_type, sparc_fsr_type): Likewise.
	* sparc64-tdep.c (sparc64_pstate_type, sparc64_fsr_type,
	sparc64_fprs_type): Likewise.
	* spu-tdep.c (spu_builtin_type_vec128): Likewise.
	* xtensa-tdep.c (xtensa_register_type): Likewise.
	* linux-tdep.c (linux_get_siginfo_type): Likewise.
	* target-descriptions.c (tdesc_gdb_type): Likewise.
	* gnu-v3-abi.c (build_gdb_vtable_type): Likewise.
@
text
@d323 1
d374 1
a374 1
      store_unsigned_integer (buf, 8, state);
d383 1
d419 1
a419 1
      bits = extract_unsigned_integer (buf, 8);
d491 1
d506 1
a506 1
    ULONGEST wcookie = sparc_fetch_wcookie ();
d1172 3
a1174 1
  int sparc32 = (gdbarch_ptr_bit (get_regcache_arch (regcache)) == 32);
d1186 1
a1186 1
	  tstate = extract_unsigned_integer (regs + offset, 8);
d1189 1
a1189 1
	  store_unsigned_integer (buf, 4, psr);
d1288 3
a1290 1
  int sparc32 = (gdbarch_ptr_bit (get_regcache_arch (regcache)) == 32);
d1302 1
a1302 1
	  tstate = extract_unsigned_integer (regs + offset, 8);
d1304 1
a1304 1
	  psr = extract_unsigned_integer (buf, 4);
d1308 1
a1308 1
	  store_unsigned_integer (buf, 8, tstate);
@


1.43
log
@	* i386-tdep.h (struct gdbarch_tdep): Add i386_eflags_type and
	i386_mxcsr_type members.
	(i386_eflags_type): Make into function.
	(i386_mxcsr_type): Likewise.
	* i386-tdep.c (i386_eflags_type): Make into function.
	(i386_mxcsr_type): Likewise.
	(i386_register_type): Update uses.
	(i386_init_types): Remove.
	(_initialize_i386_tdep): Do not call it.
	* amd64-tdep.c (amd64_register_type): Update uses.

	* m68k-tdep.h (struct gdbarch_tdep): Add m68k_ps_type member.
	* m68k-tdep.c (m68k_ps_type): Make into function.
	(m68k_register_type): Update use.
	(m68k_init_types): Remove.
	(_initialize_m68k_tdep): Do not call it.

	* sparc-tdep.h (struct gdbarch_tdep): Add sparc_psr_type,
	sparc_fsr_type, sparc64_pstate_type, sparc64_fsr_type, and
	sparc64_fprs_type members.
	* sparc-tdep.c (sparc_psr_type): Make into function.
	(sparc_fsr_type): Likewise.
	(sparc32_register_type): Update uses.
	(sparc_init_types): Remove.
	(_initialize_sparc_tdep): Do not call it.
	* sparc64-tdep.c (sparc64_pstate_type): Make into function.
	(sparc64_fsr_type): Likewise.
	(sparc64_fprs_type): Likewise.
	(sparc64_register_type): Update uses.
	(sparc64_init_types): Remove.
	(_initialize_sparc64_tdep): Likewise.
@
text
@d135 1
a135 1
      type = init_flags_type ("builtin_type_sparc64_pstate", 8);
d162 1
a162 1
      type = init_flags_type ("builtin_type_sparc64_fsr", 8);
d195 1
a195 1
      type = init_flags_type ("builtin_type_sparc64_fprs", 8);
@


1.42
log
@	* gdbtypes.h (builtin_type_int0, builtin_type_int8, builtin_type_uint8,
	builtin_type_int16, builtin_type_uint16, builtin_type_int32,
	builtin_type_uint32, builtin_type_int64, builtin_type_uint64,
	builtin_type_int128, builtin_type_uint128): Remove.
	(struct builtin_type): New members builtin_int0, builtin_int8,
	builtin_uint8, builtin_int16, builtin_uint16, builtin_int32,
	builtin_uint32, builtin_int64, builtin_uint64, builtin_int128,
	and builtin_uint128.
	* gdbtypes.c (builtin_type_int0, builtin_type_int8, builtin_type_uint8,
	builtin_type_int16, builtin_type_uint16, builtin_type_int32,
	builtin_type_uint32, builtin_type_int64, builtin_type_uint64,
	builtin_type_int128, builtin_type_uint128): Remove.
	(_initialize_gdbtypes): Do not initialize them.
	(gdbtypes_post_init): Initialize fixed-size integer types.

	* dwarf2expr.c (unsigned_address_type, signed_address_type): Add
	GDBARCH argument.  Return platform-specific type.
	(dwarf2_read_address, execute_stack_op): Update calls.

	* target-descriptions.c (tdesc_gdb_type): Use platform-specific types
	instead of global builtin_int_... variables.
	* mi/mi-main.c (mi_cmd_data_read_memory): Likewise.
	* printcmd.c (do_examine): Likewise.
	* jv-exp.y (parse_number): Likewise.

	* alpha-tdep.c (alpha_register_type, alpha_push_dummy_call,
	alpha_store_return_value): Likewise.
	* amd64-linux-tdep.c (amd64_linux_register_type): Likewise.
	* amd64-tdep.c (amd64_register_type): Likewise.
	* arm-tdep.c (arm_register_type): Likewise.
	* avr-tdep.c (avr_register_type): Likewise.
	* cris-tdep.c (cris_register_type, crisv32_register_type): Likewise.
	* frv-tdep.c (frv_register_type): Likewise.
	* h8300-tdep.c h8300_register_type): Likewise.
	* hppa-tdep.c (hppa64_push_dummy_call, hppa32_register_type,
	hppa64_register_type): Likewise.
	* i386-tdep.c (i386_mmx_type, i386_sse_type): Likewise.
	* iq2000-tdep.c (iq2000_register_type): Likewise.
	* lm32-tdep.c (lm32_register_type, lm32_push_dummy_call): Likewise.
	* m32r-tdep.c (m32r_register_type): Likewise.
	* m68hc11-tdep.c (m68hc11_register_type, m68hc11_pseudo_register_read,
	m68hc11_pseudo_register_write): Likewise.
	* m68k-tdep.c (m68k_register_type): Likewise.
	* m88k-tdep.c (m88k_register_type, m88k_store_arguments): Likewise.
	* mep-tdep.c (mep_register_type): Likewise.
	* mips-tdep.c (mips_register_type, mips_pseudo_register_type,
	mips_print_fp_register): Likewise.
	* moxie-tdep.c (moxie_register_type): Likewise.
	* mt-tdep.c (mt_copro_register_type, mt_register_type): Likewise.
	* rs6000-tdep.c (rs6000_builtin_type_vec64,
	rs6000_builtin_type_vec128): Likewise.
	* score-tdep.c (score_register_type): Likewise.
	* sparc-tdep.c (sparc32_register_type, sparc32_store_arguments):
	Likewise.
	* sparc64-tdep.c (sparc64_register_type, sparc64_store_arguments):
	Likewise.
	* spu-tdep.c (spu_builtin_type_vec128, spu_register_type): Likewise.
	* v850-tdep.c (v850_register_type): Likewise.
	* xstormy16-tdep.c (xstormy16_register_type): Likewise.
	* xtensa-tdep.c (xtensa_register_type): Likewise.

	* mt-tdep.c (struct gdbarch_tdep): New data structure.
	(mt_gdbarch_init): Alloc TDEP structures.
	(mt_register_type): Cache coprocessor type in TDEP instead of
	static global variable.

	* xtensa-tdep.h (struct gdbarch_tdep): Add type_entries member.
	* xtensa-tdep.c (type_entries): Remove.
	(xtensa_register_type): Cache fixed-size types in TDEP instead
	of in global variable.
@
text
@d124 25
a148 2
/* Type for %pstate.  */
struct type *sparc64_pstate_type;
d150 2
a151 2
/* Type for %fsr.  */
struct type *sparc64_fsr_type;
d153 4
a156 2
/* Type for %fprs.  */
struct type *sparc64_fprs_type;
d158 27
a184 1
/* Construct types for ISA-specific registers.  */
d186 2
a187 2
static void
sparc64_init_types (void)
d189 10
a198 1
  struct type *type;
d200 4
a203 37
  type = init_flags_type ("builtin_type_sparc64_pstate", 8);
  append_flags_type_flag (type, 0, "AG");
  append_flags_type_flag (type, 1, "IE");
  append_flags_type_flag (type, 2, "PRIV");
  append_flags_type_flag (type, 3, "AM");
  append_flags_type_flag (type, 4, "PEF");
  append_flags_type_flag (type, 5, "RED");
  append_flags_type_flag (type, 8, "TLE");
  append_flags_type_flag (type, 9, "CLE");
  append_flags_type_flag (type, 10, "PID0");
  append_flags_type_flag (type, 11, "PID1");
  sparc64_pstate_type = type;

  type = init_flags_type ("builtin_type_sparc64_fsr", 8);
  append_flags_type_flag (type, 0, "NXA");
  append_flags_type_flag (type, 1, "DZA");
  append_flags_type_flag (type, 2, "UFA");
  append_flags_type_flag (type, 3, "OFA");
  append_flags_type_flag (type, 4, "NVA");
  append_flags_type_flag (type, 5, "NXC");
  append_flags_type_flag (type, 6, "DZC");
  append_flags_type_flag (type, 7, "UFC");
  append_flags_type_flag (type, 8, "OFC");
  append_flags_type_flag (type, 9, "NVC");
  append_flags_type_flag (type, 22, "NS");
  append_flags_type_flag (type, 23, "NXM");
  append_flags_type_flag (type, 24, "DZM");
  append_flags_type_flag (type, 25, "UFM");
  append_flags_type_flag (type, 26, "OFM");
  append_flags_type_flag (type, 27, "NVM");
  sparc64_fsr_type = type;

  type = init_flags_type ("builtin_type_sparc64_fprs", 8);
  append_flags_type_flag (type, 0, "DL");
  append_flags_type_flag (type, 1, "DU");
  append_flags_type_flag (type, 2, "FEF");
  sparc64_fprs_type = type;
d206 1
d292 1
a292 1
    return sparc64_fsr_type;
d294 1
a294 1
    return sparc64_fprs_type;
d305 1
a305 1
    return sparc64_pstate_type;
a1455 10

/* Provide a prototype to silence -Wmissing-prototypes.  */
void _initialize_sparc64_tdep (void);

void
_initialize_sparc64_tdep (void)
{
  /* Initialize the UltraSPARC-specific register types.  */
  sparc64_init_types();
}
@


1.41
log
@        Updated copyright notices for most files.
@
text
@d252 1
a252 1
    return builtin_type_int64;
d262 1
a262 1
    return builtin_type_int64;
d270 1
a270 1
    return builtin_type_int64;
d275 1
a275 1
    return builtin_type_int64;
d279 1
a279 1
    return builtin_type_int64;
d281 1
a281 1
    return builtin_type_int64;
d690 1
d772 2
a773 1
	    args[i] = value_cast (builtin_type_int64, args[i]);
@


1.40
log
@	* alpha-tdep.c (alpha_register_type): Use builtin_type (gdbarch)
	instead of builtin_type_ macros.
	* amd64-tdep.c (amd64_register_type): Likewise.
	(amd64_get_longjmp_target): Likewise.
	* arm-tdep.c (arm_register_type): Likewise.
	* avr-tdep.c (avr_register_type): Likewise.
	* cris-tdep.c (cris_register_type, crisv32_register_type): Likewise.
	* frv-tdep.c (frv_register_type): Likewise.
	* h8300-tdep.c (h8300_register_type): Likewise.
	* hppa-tdep.c (hppa32_convert_from_func_ptr_addr,
	hppa_skip_trampoline_code): Likewise.
	* i386-tdep.c (i386_register_type): Likewise.
	(i386_unwind_pc, i386_sse_type): Likewise.
	* ia64-tdep.c (ia64_register_type): Likewise.
	* m32r-tdep.c (m32r_register_type): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_unwind_pc): Likewise.
	* m88k-tdep.c (m88k_register_type): Likewise.
	* mep-tdep.c (mep_register_type): Likewise.
	* mips-tdep.c (mips_pseudo_register_type): Likewise.
	* mn10300-tdep.c (mn10300_register_type): Likewise.
	* mt-tdep.c (mt_copro_register_type): Likewise.
	* rs6000-tdep.c (rs6000_builtin_type_vec64): Likewise.
	(rs6000_convert_register_p, rs6000_register_to_value,
	rs6000_value_to_register): Likewise.
	* s390-tdep.c (s390_register_type): Likewise.
	* sh64-tdep.c (sh64_register_type): Likewise.
	(sh64_build_float_register_type, sh64_do_fp_register): Likewise.
	* sh-tdep.c (sh_sh2a_register_type, sh_sh3e_register_type,
	sh_sh4_build_float_register_type, sh_sh4_register_type,
	sh_default_register_type): Likewise.
	* sparc64-tdep.c (sparc64_register_type): Likewise.
	* sparc-tdep.c (sparc32_register_type): Likewise.
	* spu-tdep.c (spu_builtin_type_vec128, spu_register_type): Likewise.
	* v850-tdep.c (v850_register_type): Likewise.
	* vax-tdep.c (vax_register_type): Likewise.
	* xtensa-tdep.c (xtensa_register_type, xtensa_unwind_pc,
	xtensa_push_dummy_call): Likewise.

	* std-regs.c (value_of_builtin_frame_fp_reg,
	value_of_builtin_frame_pc_reg): Likewise.
	* target-descriptions.c (tdesc_register_type): Likewise.
@
text
@d3 1
a3 1
   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008
@


1.39
log
@        * sparc-tdep.c, sparc-tdep.h, sparc-sol2-tdep.c, sparc64-tdep.c,
        sparc64-sol2-tdep.c: Update for unwinder changes.
@
text
@d250 1
a250 1
    return builtin_type_void_data_ptr;
d254 1
a254 1
    return builtin_type_float;
d256 1
a256 1
    return builtin_type_double;
d258 1
a258 1
    return builtin_type_void_func_ptr;
d283 1
a283 1
    return builtin_type_double;
d285 1
a285 1
    return builtin_type_long_double;
@


1.38
log
@	* dwarf2-frame.c (read_reg): Expect this_frame in the baton.
	(execute_stack_op): Put this_frame in the baton.
	(execute_cfa_program): Take this_frame.
	(struct dwarf2_frame_ops): Update comment for signal_frame_p.
	(dwarf2_frame_default_init_reg, dwarf2_frame_init_reg)
	(dwarf2_frame_signal_frame_p, dwarf2_frame_cache)
	(dwarf2_frame_this_id): Adjust to work on this_frame.
	(dwarf2_signal_frame_this_id): Delete.
	(dwarf2_frame_prev_register): Update signature.  Use new frame
	unwind methods.
	(dwarf2_frame_sniffer): Update signature.  Expect this_frame.
	(dwarf2_frame_unwind, dwarf2_signal_frame_unwind): Add
	dwarf2_frame_sniffer.
	(dwarf2_append_unwinders): New.
	(dwarf2_frame_base_address, dwarf2_frame_base_sniffer): Expect
	this_frame.
	* sparc-tdep.c (sparc32_dwarf2_struct_return_p)
	(sparc32_dwarf2_frame_init_reg): Expect this_frame.
	* cris-tdep.c (cris_dwarf2_frame_init_reg): Likewise.
	* rs6000-tdep.c (ppc_dwarf2_frame_init_reg): Likewise.
	* s390-tdep.c (s390_dwarf2_frame_init_reg): Likewise.
	* sh-tdep.c (sh_dwarf2_frame_init_reg): Likewise.
	* sparc64-tdep.c (sparc64_dwarf2_frame_init_reg): Likewise.
	* dwarf2-frame.h (dwarf2_frame_sniffer): Delete declaration.
	(dwarf2_append_unwinders): Declare.
	(dwarf2_frame_base_sniffer): Update declaration.
	* i386-linux-tdep.c (i386_linux_dwarf_signal_frame_p): Expect
	this_frame.
@
text
@d438 1
a438 1
sparc64_frame_cache (struct frame_info *next_frame, void **this_cache)
d440 1
a440 1
  return sparc_frame_cache (next_frame, this_cache);
d444 1
a444 1
sparc64_frame_this_id (struct frame_info *next_frame, void **this_cache,
d448 1
a448 1
    sparc64_frame_cache (next_frame, this_cache);
d457 3
a459 5
static void
sparc64_frame_prev_register (struct frame_info *next_frame, void **this_cache,
			     int regnum, int *optimizedp,
			     enum lval_type *lvalp, CORE_ADDR *addrp,
			     int *realnump, gdb_byte *valuep)
d462 1
a462 1
    sparc64_frame_cache (next_frame, this_cache);
d466 5
a470 13
      *optimizedp = 0;
      *lvalp = not_lval;
      *addrp = 0;
      *realnump = -1;
      if (valuep)
	{
	  CORE_ADDR pc = (regnum == SPARC64_NPC_REGNUM) ? 4 : 0;

	  regnum = cache->frameless_p ? SPARC_O7_REGNUM : SPARC_I7_REGNUM;
	  pc += frame_unwind_register_unsigned (next_frame, regnum) + 8;
	  store_unsigned_integer (valuep, 8, pc);
	}
      return;
d479 6
a484 14
	*optimizedp = 0;
	*lvalp = not_lval;
	*addrp = 0;
	*realnump = -1;
	if (valuep)
	  {
	    CORE_ADDR addr = cache->base + (regnum - SPARC_L0_REGNUM) * 8;
	    ULONGEST i7;

	    /* Read the value in from memory.  */
	    i7 = get_frame_memory_unsigned (next_frame, addr, 8);
	    store_unsigned_integer (valuep, 8, i7 ^ wcookie);
	  }
	return;
d493 1
a493 7
      *optimizedp = 0;
      *lvalp = lval_memory;
      *addrp = cache->base + (regnum - SPARC_L0_REGNUM) * 8;
      *realnump = -1;
      if (valuep)
	{
	  struct gdbarch *gdbarch = get_frame_arch (next_frame);
d495 1
a495 4
	  /* Read the value in from memory.  */
	  read_memory (*addrp, valuep, register_size (gdbarch, regnum));
	}
      return;
d504 1
a504 6
  *optimizedp = 0;
  *lvalp = lval_register;
  *addrp = 0;
  *realnump = regnum;
  if (valuep)
    frame_unwind_register (next_frame, regnum, valuep);
d511 3
a513 1
  sparc64_frame_prev_register
a514 6

static const struct frame_unwind *
sparc64_frame_sniffer (struct frame_info *next_frame)
{
  return &sparc64_frame_unwind;
}
d518 1
a518 1
sparc64_frame_base_address (struct frame_info *next_frame, void **this_cache)
d521 1
a521 1
    sparc64_frame_cache (next_frame, this_cache);
d1116 1
a1116 1
  frame_unwind_append_sniffer (gdbarch, sparc64_frame_sniffer);
@


1.37
log
@doc/ChangeLog:
--------------

	* gdb.texinfo (Set SH Calling convention): New @@item.
	(Show SH Calling convention): Ditto.

ChangeLog:
----------

	* NEWS: Add information on calling convention and new SH CLI options.

	* sh-tdep.c (sh_cc_gcc): New static string.
	(sh_cc_renesas): Ditto.
	(sh_cc_enum): New static string array.
	(sh_active_calling_convention): New static string pointer denoting
	active user chosen ABI.
	(sh_is_renesas_calling_convention): New function to return function
	specific ABI, or user choice if necessary.
	(sh_use_struct_convention): Rename first argument and turn around its
	meaning.  Check for renesas ABI and return accordingly.
	(sh_use_struct_convention_nofpu): New function.
	(sh_next_flt_argreg): Get function type as third parameter.  Check
	for renesas ABI and choose floating registers accordingly.
	(sh_push_dummy_call_fpu): Check for ABI and choose argument slot and
	struct return slot accordingly.
	(sh_push_dummy_call_nofpu): Ditto.
	(sh_return_value_nofpu): Call sh_use_struct_convention_nofpu from here.
	Evaluate ABI and give to sh_use_struct_convention_nofpu.
	(sh_return_value_fpu):  Evaluate ABI and give to
	sh_use_struct_convention.
	(show_sh_command): New function.
	(set_sh_command): Ditto.
	(_initialize_sh_tdep): Initialize `set/show sh calling-convention
	CLI command.

	* gdbarch.sh (return_value): Add func_type argument.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Ditto.
	* eval.c (evaluate_subexp_standard): Rename local variable value_type to
	val_type so as not to collide with value_type function.  Call
	using_struct_return with additional function type argument.
	* infcall.c (call_function_by_hand): Call using_struct_return and
	gdbarch_return_value with additional function type argument.
	* infcmd.c (print_return_value): Take addition func_type argument.
	Call gdbarch_return_value with additional function type argument.
	(finish_command_continuation): Call print_return_value with additional
	function type argument.
	(finish_command): Ditto.
	* sparc-tdep.c (sparc32_push_dummy_code): Call using_struct_return with
	additional function type argument.
	* stack.c (return_command): Call using_struct_return and
	gdbarch_return_value with additional function type argument.
	* value.c (using_struct_return): Take additional function type argument.
	* value.h (using_struct_return): Accommodate declaration.
	* alpha-tdep.c (alpha_return_value): Add func_type argument.
	* amd64-tdep.c (amd64_return_value): Ditto.
	* arm-tdep.c (arm_return_value): Ditto.
	* avr-tdep.c (avr_return_value): Ditto.
	* cris-tdep.c (cris_return_value): Ditto.
	* frv-tdep.c (frv_return_value): Ditto.
	* h8300-tdep.c (h8300_return_value): Ditto.
	(h8300h_return_value): Ditto.
	* hppa-tdep.c (hppa32_return_value): Ditto.
	(hppa64_return_value): Ditto.
	* i386-tdep.c (i386_return_value): Ditto.
	* ia64-tdep.c (ia64_return_value): Ditto.
	* iq2000-tdep.c (iq2000_return_value): Ditto.
	* m32c-tdep.c (m32c_return_value): Ditto.
	* m32r-tdep.c (m32r_return_value): Ditto.
	* m68hc11-tdep.c (m68hc11_return_value): Ditto.
	* m68k-tdep.c (m68k_return_value): Ditto.
	(m68k_svr4_return_value): Ditto.
	* m88k-tdep.c  (m88k_return_value): Ditto.
	* mep-tdep.c (mep_return_value): Ditto.
	* mips-tdep.c (mips_eabi_return_value): Ditto.
	(mips_n32n64_return_value): Ditto.
	(mips_o32_return_value): Ditto.
	(mips_o64_return_value): Ditto.
	* mn10300-tdep.c (mn10300_return_value): Ditto.
	* mt-tdep.c (mt_return_value): Ditto.
	* ppc-linux-tdep.c (ppc_linux_return_value): Ditto.
	* ppc-sysv-tdep.c (ppc_sysv_abi_return_value): Ditto.
	(ppc_sysv_abi_broken_return_value): Ditto.
	(ppc64_sysv_abi_return_value): Ditto.
	* ppc-tdep.h (ppc_sysv_abi_return_value): Ditto.
	(ppc_sysv_abi_broken_return_value): Ditto.
	(ppc64_sysv_abi_return_value): Ditto.
	* ppcnbsd-tdep.c (ppcnbsd_return_value): Ditto.
	* rs6000-tdep.c (rs6000_return_value): Ditto.
	* s390-tdep.c (s390_return_value): Ditto.
	* score-tdep.c (score_return_value): Ditto.
	* sh-tdep.c (sh_return_value_nofpu): Ditto.
	(sh_return_value_fpu): Ditto.
	* sh64-tdep.c (sh64_return_value): Ditto.
	* sparc-tdep.c (sparc32_return_value): Ditto.
	* sparc64-tdep.c (sparc64_return_value): Ditto.
	* spu-tdep.c (spu_return_value): Ditto.
	* v850-tdep.c (v850_return_value): Ditto.
	* vax-tdep.c (vax_return_value): Ditto.
	* xstormy16-tdep.c (xstormy16_return_value): Ditto.
	* xtensa-tdep.c (xtensa_return_value): Ditto.

	* gdbtypes.h (struct type): Add calling_convention member.
	* dwarf2read.c (read_subroutine_type): Add calling convention read
	from DW_AT_calling_convention attribute to function type.
@
text
@d1089 1
a1089 1
			       struct frame_info *next_frame)
@


1.36
log
@	* alpha-tdep.c (alpha_heuristic_proc_start)
	(alpha_sigtramp_register_address): Add gdbarch as parameter. Replace
	current_gdbarch by gdbarch.

	(alpha_heuristic_frame_unwind_cache): Use get_frame_arch to get at the
	current architecture by frame_info. Update alpha_heuristic_proc_start
	call.

	(alpha_sigtramp_frame_this_id, alpha_sigtramp_frame_prev_register): Use
	get_frame_arch to get at the current architecture by frame_info. Update
	alpha_sigtramp_register_address call.

	* arm-tdep.c (thumb_scan_prologue): Add gdbarch as parameter and replace
	current_gdbarch by gdbarch. Update caller.
	(convert_to_extended, convert_from_extended): Add endianess parameter
	for comparison. Update caller.
	(arm_extract_return_value, arm_store_return_value): Use
	get_regcache_arch to get at the current	architecture.

	* cris-tdep.c (cris_register_size): Add gdbarch as parameter. Replace
	current_gdbarch by gdbarch. Update caller.
	(cris_gdb_func, move_to_preg_op, none_reg_mode_move_from_preg_op): Add
	gdbarch as parameter. Update caller. Replace current_gdbarch by gdbarch.

	* h8300-tdep.c (E_PSEUDO_CCR_REGNUM, E_PSEUDO_EXR_REGNUM, BINWORD): Add
	gdbarch	as parameter. Update caller.
	(h8300_init_frame_cache): Add gdbarch as parameter. Replace
	current_gdbarch by gdbarch. Update caller.

	* hppa-tdep.c (skip_prologue_hard_way): Add gdbarch as parameter and
	update caller. Replace current_gdbarch by gdbarch.

	* m32c-tdep.c (m32c_skip_trampoline_code): Use get_frame_arch to get at
	the current architecture. Replace current_gdbarch by gdbarch.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache): Likewise.
	(STACK_CORRECTION, USE_PAGE_REGISTER): Replace M6811_TDEP by its
	expression. Add gdbarch as parameter and replace current_gdbarch with
	it. Update caller.
	(M6811_TDEP): Remove.
	(m68hc11_frame_prev_register): Use get_frame_arch to get at the current
	architecture.
	(m68hc11_scan_prologue): Add gdbarch as parameter. Replace
	current_gdbarch by gdbarch. Update caller.

	* m68k-tdep.c (m68k_analyze_prologue): Add gdbarch as parameter and
	update caller.
	(m68k_analyze_register_saves): Likewise. Also replace current_gdbarch
	by gdbarch.

	* rs6000-tdep.c (skip_prologue): Add gdbarch as parameter and update
	caller. Relace current_gdbarch by gdbarch.
	(altivec_register_p, spe_register_p): Likewise.
	* ppc-tdep.h (altivec_register_p, spe_register_p): Add gdbarch as
	parameter.
	* ppc-linux-nat.c (fetch_register, store_register): Update caller of
	altivec_register_p and spe_register_p.

	* score-tdep.c (score_fetch_inst): Add gdbarch as parameter. Update
	caller. Replace current_gdbarch by gdbarch.
	(score_analyze_prologue): use get_frame_arch to get at the current
	architecture.

	* sparc-tdep.h (sparc_analyze_prologue): Add gdbarch as parameter.
	* sparc-tdep.c (sparc_analyze_prologue): Likewise. Replace
	current_gdbarch by gdbarch. Update caller.
	(sparc_frame_cache): Use get_frame_arch to get at the current
	architecture.
	* sparce64-tdep.c (sparc64_skip_prologue): Update call of
	sparc_analyze_prologue.

	* mn10300-tdep.c (mn10300_dwarf2_reg_to_regnum): Add gdbarch as
	parameter.
@
text
@d1070 3
a1072 3
sparc64_return_value (struct gdbarch *gdbarch, struct type *type,
		      struct regcache *regcache, gdb_byte *readbuf,
		      const gdb_byte *writebuf)
@


1.35
log
@
	* gdbarch.sh (skip_prologue): Add gdbarch
	as parameter.
	* gdbarch.{c,h}: Regenerate.

	* alpha-tdep.c (alpha_skip_prologue): Add gdbarch as parameter.
	* amd64-tdep.c (amd64_skip_prologue): Likewise.
	* avr-tdep.c (avr_skip_prologue): Likewise.
	* cris-tdep.c (cris_skip_prologue): Likewise.
	* frv-tdep.c (frv_skip_prologue): Likewise.
	* h8300-tdep.c (h8300_skip_prologue): Likewise.
	* hppa-tdep.c (hppa_skip_prologue): Likewise.
	* i386-tdep.c (i386_skip_prologue): Likewise.
	* ia64-tdep.c (ia64_skip_prologue): Likewise.
	* iq2000-tdep.c (iq2000_skip_prologue): Likewise.
	* m32r-tdep.c (m32r_skip_prologue): Likewise.
	* m68hc11-tdep.c (m68hc11_skip_prologue): Likewise.
	* m68k-tdep.c (m68k_skip_prologue): Likewise.
	* m88k-tdep.c (m88k_skip_prologue): Likewise.
	* mep-tdep.c (mep_skip_prologue): Likewise.
	* mips-tdep.c (mips_skip_prologue): Likewise.
	* mn10300-tdep.c (mn10300_skip_prologue): Likewise.
	* mt-tdep.c (mt_skip_prologue): Likewise.
	* rs6000-tdep.c (rs6000_skip_prologue): Likewise.
	* score-tdep.c (score_skip_prologue): Likewise.
	* sh64-tdep.c (sh64_skip_prologue): Likewise.
	* sh-tdep.c (sh_skip_prologue): Likewise.
	* sparc64-tdep.c (sparc64_skip_prologue): Likewise.
	* sparc-tdep.c (sparc32_skip_prologue): Likewise.
	* spu-tdep.c (spu_skip_prologue): Likewise.
	* v850-tdep.c (v850_skip_prologue): Likewise.
	* vax-tdep.c (vax_skip_prologue): Likewise.
	* xstormy16-tdep.c (xstormy16_skip_prologue): Likewise.
	* xtensa-tdep.c (xtensa_skip_prologue): Likewise.

	* arm-tdep.c (arm_skip_prologue): Add gdbarch as parameter. Replace
	current_gdbarch by gdbarch.
	* m32c-tdep.c (m32c_skip_prologue): Likewise.
	* s390-tdep.c (s390_skip_prologue): Likewise.
@
text
@d431 2
a432 1
  return sparc_analyze_prologue (start_pc, 0xffffffffffffffffULL, &cache);
@


1.34
log
@	Updated copyright notices for most files.
@
text
@d414 1
a414 1
sparc64_skip_prologue (CORE_ADDR start_pc)
@


1.33
log
@2007-11-02  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (register_name): Add gdbarch parameter.
	* gdbarch.{c,h}: Regenerate.

	* target-descriptions.c (tdesc_register_name): Add gdbarch parameter.
	(tdesc_register_name): Replace current_gdbarch by gdbarch.
	* target-descriptions.h (tdesc_register_name): Add gdbarch parameter.

	* xstormy16-tdep.c (xstormy16_register_name): Add gdbarch parameter.
	* vax-tdep.c (vax_register_name): Add gdbarch parameter.
	* spu-tdep.c (spu_register_name): Add gdbarch parameter.
	* s390-tdep.c (s390_register_name): Add gdbarch parameter.
	* mt-tdep.c (mt_register_name): Add gdbarch parameter.
	(mt_registers_info): Replace current_gdbarch by gdbarch.
	(mt_register_reggroup_p): Add gdbarch to mt_register_name call.
	* mips-tdep.c (mips_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(mips_register_name): Add gdbarch to tdesc_register_name call.
	* mep-tdep.c (mep_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(mep_register_reggroup_p): Add gdbarch to mep_register_name call.
	* m32c-tdep.c (m32c_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	* m88k-tdep.c (m88k_register_name): Add gdbarch parameter.
	* m68k-tdep.c (m68k_register_name): Add gdbarch parameter.
	* m32r-tdep.c (m32r_register_name): Add gdbarch parameter.
	(m32r_frame_unwind_cache): Use get_frame_arch to get at the current
	architecture by frame_info.
	* iq2000-tdep.c (iq2000_register_name): Add gdbarch parameter.
	* ia64-tdep.c (ia64_register_name): Add gdbarch parameter.
	* hppa-tdep.c (hppa32_register_name, hppa64_register_name): Add gdbarch
	parameter.
	* h8300-tdep.c (h8300_register_name, h8300s_register_name)
	(h8300sx_register_name): Add gdbarch parameter.
	* cris-tdep.c (cris_register_name, crisv32_register_name): Add
	gdbarch parameter. Replace current_gdbarch by gdbarch.
	(cris_gdbarch_init): Replace current_gdbarch by gdbarch (comment).
	* avr-tdep.c (avr_register_name): Add gdbarch parameter.
	* arm-tdep.c (arm_register_name): Add gdbarch paramete
	* amd64-tdep.c (amd64_register_name): Add gdbarch parameter. Update
	caller.
	* amd64-tdep.h (amd64_register_name): Add gdbarch parameter.
	* amd64-linux-tdep.c (amd64_linux_register_name): Add gdbarch parameter.
	* alpha-tdep.c (alpha_register_name): Add gdbarch parameter.
	(alpha_cannot_fetch_register, alpha_cannot_store_register): Update call
	of alpha_register_name.
	* frv-tdep.c (frv_register_name): Add gdbarch parameter.
	* i386-tdep.c (i386_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(i386_register_type): Replace ?current_gdbarch by gdbarch.
	* i386-tdep.h (i386_register_name): Add gdbarch parameter.
	* i386-linux-tdep.c (i386_linux_register_name): Add gdbarch parameter.

	* m68hc11-tdep.c (m68hc11_register_name): Add gdbarch parameter.
	(m68hc11_register_reggroup_p): Add gdbarch to call of
	m68hc11_register_name.
	* mn10300-tdep.c (mn10300_generic_register_name, am33_register_name)
	(am33_2_register_name): Add gdbarch parameter.
	(mn10300_frame_unwind_cache): Use get_frame_arch to get at the current
	architecture by frame_info.
	(mn10300_dump_tdep): Replace current_gdbarch by gdbarch.
	* rs6000-tdep.c (rs6000_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	* score-tdep.c (score_register_name): Add gdbarch parameter.
	(score_return_value, score_push_dummy_call): Replace current_gdbarch
	by gdbarch.
	* sh64-tdep.c (sh64_register_name): Add gdbarch parameter.
	(sh64_compact_reg_base_num, sh64_register_convert_to_virtual)
	(sh64_register_convert_to_raw, sh64_fv_reg_base_num)
	(sh64_dr_reg_base_num, sh64_fpp_reg_base_num): Add gdbarch parameter
	and update caller. Replace current_gdbarch by gdbarch.
	(sh64_extract_return_value, sh64_store_return_value): Use
	get_regcache_arch to get at the current architecture by regcache.
	* sh-tdep.c (sh_sh_register_name, sh_sh3_register_name)
	(sh_sh3e_register_name, sh_sh2e_register_name, sh_sh2a_register_name)
	(sh_sh2a_nofpu_register_name, sh_sh_dsp_register_name)
	(sh_sh3_dsp_register_name, sh_sh4_register_name)
	(sh_sh4_nofpu_register_name, sh_sh4al_dsp_register_name): Add gdbarch
	parameter.
	(fv_reg_base_num, dr_reg_base_num, sh_justify_value_in_reg)
	(sh_next_flt_argreg): Add gdbarch parameter and update caller. Replace
	current_gdbarch by gdbarch.
	(sh_extract_return_value_fpu, sh_store_return_value_fpu): Use
	get_regcache_arch to get at the current architecture by regcache.
	* sparc-tdep.c (sparc32_register_name): Add gdbarch parameter.
	* sparc64-tdep.c (sparc64_register_name): Add gdbarch parameter.
	* v850-tdep.c (v850_register_name, v850e_register_name): Add gdbarch
	parameter.
	(v850_unwind_sp, v850_unwind_pc): Replace current_gdbarch by gdbarch.
	* xtensa-tdep.c (xtensa_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(xtensa_pseudo_register_read, xtensa_pseudo_register_write)
	(xtensa_frame_prev_register): Add gdbarch parameter to
	xtensa_register_name call.
@
text
@d3 2
a4 1
   Copyright (C) 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.
@


1.32
log
@2007-10-10  Markus Deuling  <deuling@@de.ibm.com>

	* sparc-tdep.c (sparc_supply_rwindow, sparc_collect_rwindow): Use
	get_regcache_arch to get at the current architecture by regcache.

	* sparc64-tdep.c (sparc64_supply_gregset, sparc64_collect_gregset)
	(sparc64_supply_fpregset, sparc64_collect_fpregset): Use
	get_regcache_arch to get at the current architecture by regcache.

	* sparc64nbsd-nat. (sparc64nbsd_supply_gregset)
	(sparc64nbsd_collect_gregset, sparc64nbsd_supply_fpregset)
	(sparc64nbsd_collect_fpregset): Use get_regcache_arch to get at the
	current architecture by regcache.
@
text
@d228 1
a228 1
sparc64_register_name (int regnum)
@


1.31
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d1173 1
a1173 1
  int sparc32 = (gdbarch_ptr_bit (current_gdbarch) == 32);
d1287 1
a1287 1
  int sparc32 = (gdbarch_ptr_bit (current_gdbarch) == 32);
d1394 1
a1394 1
  int sparc32 = (gdbarch_ptr_bit (current_gdbarch) == 32);
d1429 1
a1429 1
  int sparc32 = (gdbarch_ptr_bit (current_gdbarch) == 32);
@


1.30
log
@	* amd64-tdep.c (struct amd64_register_info): Remove.
	(amd64_register_info): Remove.
	(amd64_register_names): New static variable.
	(AMD64_NUM_REGS): Use amd64_register_names instead of
	amd64_register_info.
	(amd64_register_name): Likewise.
	(amd64_register_type): Do not refer to amd64_register_info.

	* s390-tdep.c (struct s390_register_info): Remove.
	(s390_register_info): Remove.
	(s390_register_name): Do not refer to s390_register_info.
	(s390_register_type): Likewise.

	* sparc64-tdep.c (struct sparc64_register_info): Remove.
	(sparc64_register_info, sparc64_pseudo_register_info): Remove.
	(sparc64_register_names, sparc64_pseudo_register_names): New.
	(SPARC64_NUM_REGS, SPARC64_NUM_PSEUDO_REGS): Use
	sparc64_register_names and sparc64_pseudo_register_names instead of
	sparc64_register_info and sparc64_pseudo_register_info.
	(sparc64_register_name): Likewise.
	(sparc64_register_type): Do not refer to sparc64_register_info
	and sparc64_pseudo_register_info.
@
text
@d9 1
a9 1
   the Free Software Foundation; either version 2 of the License, or
d18 1
a18 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.29
log
@Copyright updates for 2007.
@
text
@d182 1
a182 1
struct sparc64_register_info
d184 11
a194 90
  char *name;
  struct type **type;
};

static struct sparc64_register_info sparc64_register_info[] =
{
  { "g0", &builtin_type_int64 },
  { "g1", &builtin_type_int64 },
  { "g2", &builtin_type_int64 },
  { "g3", &builtin_type_int64 },
  { "g4", &builtin_type_int64 },
  { "g5", &builtin_type_int64 },
  { "g6", &builtin_type_int64 },
  { "g7", &builtin_type_int64 },

  { "o0", &builtin_type_int64 },
  { "o1", &builtin_type_int64 },
  { "o2", &builtin_type_int64 },
  { "o3", &builtin_type_int64 },
  { "o4", &builtin_type_int64 },
  { "o5", &builtin_type_int64 },
  { "sp", &builtin_type_void_data_ptr },
  { "o7", &builtin_type_int64 },

  { "l0", &builtin_type_int64 },
  { "l1", &builtin_type_int64 },
  { "l2", &builtin_type_int64 },
  { "l3", &builtin_type_int64 },
  { "l4", &builtin_type_int64 },
  { "l5", &builtin_type_int64 },
  { "l6", &builtin_type_int64 },
  { "l7", &builtin_type_int64 },

  { "i0", &builtin_type_int64 },
  { "i1", &builtin_type_int64 },
  { "i2", &builtin_type_int64 },
  { "i3", &builtin_type_int64 },
  { "i4", &builtin_type_int64 },
  { "i5", &builtin_type_int64 },
  { "fp", &builtin_type_void_data_ptr },
  { "i7", &builtin_type_int64 },

  { "f0", &builtin_type_float },
  { "f1", &builtin_type_float },
  { "f2", &builtin_type_float },
  { "f3", &builtin_type_float },
  { "f4", &builtin_type_float },
  { "f5", &builtin_type_float },
  { "f6", &builtin_type_float },
  { "f7", &builtin_type_float },
  { "f8", &builtin_type_float },
  { "f9", &builtin_type_float },
  { "f10", &builtin_type_float },
  { "f11", &builtin_type_float },
  { "f12", &builtin_type_float },
  { "f13", &builtin_type_float },
  { "f14", &builtin_type_float },
  { "f15", &builtin_type_float },
  { "f16", &builtin_type_float },
  { "f17", &builtin_type_float },
  { "f18", &builtin_type_float },
  { "f19", &builtin_type_float },
  { "f20", &builtin_type_float },
  { "f21", &builtin_type_float },
  { "f22", &builtin_type_float },
  { "f23", &builtin_type_float },
  { "f24", &builtin_type_float },
  { "f25", &builtin_type_float },
  { "f26", &builtin_type_float },
  { "f27", &builtin_type_float },
  { "f28", &builtin_type_float },
  { "f29", &builtin_type_float },
  { "f30", &builtin_type_float },
  { "f31", &builtin_type_float },
  { "f32", &builtin_type_double },
  { "f34", &builtin_type_double },
  { "f36", &builtin_type_double },
  { "f38", &builtin_type_double },
  { "f40", &builtin_type_double },
  { "f42", &builtin_type_double },
  { "f44", &builtin_type_double },
  { "f46", &builtin_type_double },
  { "f48", &builtin_type_double },
  { "f50", &builtin_type_double },
  { "f52", &builtin_type_double },
  { "f54", &builtin_type_double },
  { "f56", &builtin_type_double },
  { "f58", &builtin_type_double },
  { "f60", &builtin_type_double },
  { "f62", &builtin_type_double },
d196 1
a196 2
  { "pc", &builtin_type_void_func_ptr },
  { "npc", &builtin_type_void_func_ptr },
d198 5
a202 11
  /* This raw register contains the contents of %cwp, %pstate, %asi
     and %ccr as laid out in a %tstate register.  */
  /* FIXME: Give it a name until we start using register groups.  */
  { "state", &builtin_type_int64 },

  { "fsr", &sparc64_fsr_type },
  { "fprs", &sparc64_fprs_type },

  /* "Although Y is a 64-bit register, its high-order 32 bits are
     reserved and always read as 0."  */
  { "y", &builtin_type_int64 }
d206 1
a206 1
#define SPARC64_NUM_REGS ARRAY_SIZE (sparc64_register_info)
d211 1
a211 1
static struct sparc64_register_info sparc64_pseudo_register_info[] =
d213 9
a221 54
  { "cwp", &builtin_type_int64 },
  { "pstate", &sparc64_pstate_type },
  { "asi", &builtin_type_int64 },
  { "ccr", &builtin_type_int64 },

  { "d0", &builtin_type_double },
  { "d2", &builtin_type_double },
  { "d4", &builtin_type_double },
  { "d6", &builtin_type_double },
  { "d8", &builtin_type_double },
  { "d10", &builtin_type_double },
  { "d12", &builtin_type_double },
  { "d14", &builtin_type_double },
  { "d16", &builtin_type_double },
  { "d18", &builtin_type_double },
  { "d20", &builtin_type_double },
  { "d22", &builtin_type_double },
  { "d24", &builtin_type_double },
  { "d26", &builtin_type_double },
  { "d28", &builtin_type_double },
  { "d30", &builtin_type_double },
  { "d32", &builtin_type_double },
  { "d34", &builtin_type_double },
  { "d36", &builtin_type_double },
  { "d38", &builtin_type_double },
  { "d40", &builtin_type_double },
  { "d42", &builtin_type_double },
  { "d44", &builtin_type_double },
  { "d46", &builtin_type_double },
  { "d48", &builtin_type_double },
  { "d50", &builtin_type_double },
  { "d52", &builtin_type_double },
  { "d54", &builtin_type_double },
  { "d56", &builtin_type_double },
  { "d58", &builtin_type_double },
  { "d60", &builtin_type_double },
  { "d62", &builtin_type_double },

  { "q0", &builtin_type_long_double },
  { "q4", &builtin_type_long_double },
  { "q8", &builtin_type_long_double },
  { "q12", &builtin_type_long_double },
  { "q16", &builtin_type_long_double },
  { "q20", &builtin_type_long_double },
  { "q24", &builtin_type_long_double },
  { "q28", &builtin_type_long_double },
  { "q32", &builtin_type_long_double },
  { "q36", &builtin_type_long_double },
  { "q40", &builtin_type_long_double },
  { "q44", &builtin_type_long_double },
  { "q48", &builtin_type_long_double },
  { "q52", &builtin_type_long_double },
  { "q56", &builtin_type_long_double },
  { "q60", &builtin_type_long_double }
d225 1
a225 1
#define SPARC64_NUM_PSEUDO_REGS ARRAY_SIZE (sparc64_pseudo_register_info)
d233 1
a233 1
    return sparc64_register_info[regnum].name;
d237 1
a237 1
    return sparc64_pseudo_register_info[regnum - SPARC64_NUM_REGS].name;
d248 39
a286 3
  if (regnum >= SPARC64_NUM_REGS
      && regnum < SPARC64_NUM_REGS + SPARC64_NUM_PSEUDO_REGS)
    return *sparc64_pseudo_register_info[regnum - SPARC64_NUM_REGS].type;
d288 1
a288 2
  gdb_assert (regnum >= 0 && regnum < SPARC64_NUM_REGS);
  return *sparc64_register_info[regnum].type;
@


1.28
log
@        * sparc64-tdep.c (sparc64_extract_return_value): Add handling
        for array types.
        (sparc64_store_return_value): Likewise.
@
text
@d3 1
a3 1
   Copyright (C) 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
@


1.27
log
@* sparc64-tdep.c (sparc64_pstate_type, sparc64_fsr_type)
(sparc64_fprs_type): New variables.
(sparc64_init_types): New function.:
(sparc64_register_info): Use appropriate flag types for %fsr and
%fprs.
(sparc64_pseudo_register_info): Use appropriate type for %pstate.
(_initialize_sparc64_tdep): New function.
@
text
@d1089 9
d1143 10
@


1.26
log
@	* dwarf2-frame.c (dwarf2_frame_ops init_reg): Add "next_frame"
	argument.
	(dwarf2_frame_default_init_reg): Likewise.
	(dwarf2_frame_set_init_reg): Update init_reg arg.
	(dwarf2_frame_init_reg): Take "next_frame" and pass it to
	ops->init_reg().
	(dwarf2_frame_cache): Pass next_frame to dwarf2_frame_init_reg.
	* dwarf2-frame.h (dwarf2-frame_set_init_reg): Update declaration.
	* cris-tdep.c (cris_dwarf2_frame_init_reg): Add next_frame arg.
	* s390-tdep.c (s390_dwarf2_frame_init_reg): Likewise.
	* sh-tdep.c (sh_dwarf2_frame_init_reg): Likewise.
	* sparc64-tdep.c (sparc64_dwarf2_frame_init_reg): Likewise.
	* sparc-tdep.c (sparc32_struct_return_from_sym): New function.
	(sparc32_frame_cache): Call it.
	(sparc32_dwarf2_struct_return_p): New function.
	(sparc_dwarf2_frame_init_reg): Use it to determine if the function
	returns a structure and thus we have to indicate the return PC and
	NPC are 4 bytes later than usual.
@
text
@d3 1
a3 1
   Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.
d123 56
d283 2
a284 2
  { "fsr", &builtin_type_int64 },
  { "fprs", &builtin_type_int64 },
d300 1
a300 1
  { "pstate", &builtin_type_int64 },
d1538 11
@


1.26.6.1
log
@Changes from nickrob-async-20060828-mergepoint.
@
text
@d3 1
a3 1
   Copyright (C) 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
a122 56


/* Type for %pstate.  */
struct type *sparc64_pstate_type;

/* Type for %fsr.  */
struct type *sparc64_fsr_type;

/* Type for %fprs.  */
struct type *sparc64_fprs_type;

/* Construct types for ISA-specific registers.  */

static void
sparc64_init_types (void)
{
  struct type *type;

  type = init_flags_type ("builtin_type_sparc64_pstate", 8);
  append_flags_type_flag (type, 0, "AG");
  append_flags_type_flag (type, 1, "IE");
  append_flags_type_flag (type, 2, "PRIV");
  append_flags_type_flag (type, 3, "AM");
  append_flags_type_flag (type, 4, "PEF");
  append_flags_type_flag (type, 5, "RED");
  append_flags_type_flag (type, 8, "TLE");
  append_flags_type_flag (type, 9, "CLE");
  append_flags_type_flag (type, 10, "PID0");
  append_flags_type_flag (type, 11, "PID1");
  sparc64_pstate_type = type;

  type = init_flags_type ("builtin_type_sparc64_fsr", 8);
  append_flags_type_flag (type, 0, "NXA");
  append_flags_type_flag (type, 1, "DZA");
  append_flags_type_flag (type, 2, "UFA");
  append_flags_type_flag (type, 3, "OFA");
  append_flags_type_flag (type, 4, "NVA");
  append_flags_type_flag (type, 5, "NXC");
  append_flags_type_flag (type, 6, "DZC");
  append_flags_type_flag (type, 7, "UFC");
  append_flags_type_flag (type, 8, "OFC");
  append_flags_type_flag (type, 9, "NVC");
  append_flags_type_flag (type, 22, "NS");
  append_flags_type_flag (type, 23, "NXM");
  append_flags_type_flag (type, 24, "DZM");
  append_flags_type_flag (type, 25, "UFM");
  append_flags_type_flag (type, 26, "OFM");
  append_flags_type_flag (type, 27, "NVM");
  sparc64_fsr_type = type;

  type = init_flags_type ("builtin_type_sparc64_fprs", 8);
  append_flags_type_flag (type, 0, "DL");
  append_flags_type_flag (type, 1, "DU");
  append_flags_type_flag (type, 2, "FEF");
  sparc64_fprs_type = type;
}
d227 2
a228 2
  { "fsr", &sparc64_fsr_type },
  { "fprs", &sparc64_fprs_type },
d244 1
a244 1
  { "pstate", &sparc64_pstate_type },
a1481 11


/* Provide a prototype to silence -Wmissing-prototypes.  */
void _initialize_sparc64_tdep (void);

void
_initialize_sparc64_tdep (void)
{
  /* Initialize the UltraSPARC-specific register types.  */
  sparc64_init_types();
}
@


1.25
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d1109 2
a1110 1
			       struct dwarf2_frame_state_reg *reg)
@


1.24
log
@* sparc-tdep.c (sparc32_frame_prev_register): Change type of last
argument to `gdb_byte *'.
* sparcnbsd-tdep.c (sparc32nbsd_sigcontext_frame_prev_register):
Likewise.
* sparcobsd-tdep.c (sparc32obsd_frame_prev_register): Likewise.
* sparc-sol2-tdep.c (sparc32_sol2_sigtramp_frame_prev_register):
Likewise.
* sparc64-tdep.c (sparc64_frame_prev_register): Likewise.
* sparc64fbsd-tdep.c (sparc64fbsd_sigtramp_frame_prev_register):
Likewise.
* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_frame_prev_register):
Likewise.
* sparc64obsd-tdep.c (sparc64obsd_frame_prev_register): Likewise.
* sparc64-sol2-tdep.c (sparc64_sol2_sigtramp_frame_unwind):
Likewise.
@
text
@d3 1
a3 1
   Copyright 2003, 2004, 2005 Free Software Foundation, Inc.
d19 2
a20 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.23
log
@* sparc-tdep.c (sparc_fetch_instruction, sparc_fetch_wcookie): Use
gdb_byte for buf.
(sparc32_pseudo_register_read, sparc32_pseudo_register_write):
Change type of last argument to `gdb_byte *'.  Remove casts that
are no longer needed.
(sparc32_push_dummy_code, sparc32_store_arguments): Use gdb_byte
for buf.
(sparc_breakpoint_from_pc): Change return type to `const gdb_byte
*'.  Use gdb_byte for break_insn.
(sparc32_extract_return_value, sparc32_store_return_value): Change
type of last argument to `gdb_byte *'.  Use gdb_byte for buf.
(sparc32_return_value): Change type of readbuf and writebuf
arguments to `gdb_byte *'.
(sparc_software_single_step): Use gdb_byte for npc_save and
nnpc_save.
(sparc_supply_rwindow, sparc_collect_rwindow): Use gdb_byte for
buf.
(sparc32_supply_gregset, sparc32_collect_gregset)
(sparc32_supply_fpregset, sparc32_collect_fpregset): Use `gdb_byte
*' for regs.
* sparc64-tdep.c (sparc64_pseudo_register_read)
(sparc64_pseudo_register_write): Change type of last argument to
`gdb_byte *'.  Remove casts that are no longer needed.
(sparc64_store_floating_fields, sparc64_extract_floating_fields):
Change type of valbuf argument to `gfd_byte *'.
(sparc64_store_arguments): Use `gdb_byte *' for valbuf.  use
gdb_byte for buf.
(sparc64_extract_return_value, sparc64_store_return_value): Change
type of last argument to `gdb_byte *'.  Use gdb_byte for buf.
(sparc64_return_value): Change type of readbuf and writebuf
arguments to `gdb_byte *'.
(sparc64_supply_gregset, sparc64_collect_gregset)
(sparc64_supply_fpregset, sparc64_collect_fpregset): Use `gdb_byte
*' for regs.
@
text
@d501 1
a501 1
			     int *realnump, void *valuep)
@


1.22
log
@* sparc64-tdep.c: Include "dwarf2-frame.h".
(sparc64_dwarf2_frame_init_reg): New function.
* Makefile.in (sparc64-tdep.o): Update dependencies.
@
text
@d334 1
a334 1
			      int regnum, void *buf)
d342 1
a342 1
      regcache_raw_read (regcache, regnum + 1, ((char *)buf) + 4);
d353 3
a355 3
      regcache_raw_read (regcache, regnum + 1, ((char *)buf) + 4);
      regcache_raw_read (regcache, regnum + 2, ((char *)buf) + 8);
      regcache_raw_read (regcache, regnum + 3, ((char *)buf) + 12);
d361 1
a361 1
      regcache_raw_read (regcache, regnum + 1, ((char *)buf) + 8);
d393 1
a393 1
			       int regnum, const void *buf)
d401 1
a401 1
      regcache_raw_write (regcache, regnum + 1, ((const char *)buf) + 4);
d412 3
a414 3
      regcache_raw_write (regcache, regnum + 1, ((const char *)buf) + 4);
      regcache_raw_write (regcache, regnum + 2, ((const char *)buf) + 8);
      regcache_raw_write (regcache, regnum + 3, ((const char *)buf) + 12);
d420 1
a420 1
      regcache_raw_write (regcache, regnum + 1, ((const char *)buf) + 8);
d642 1
a642 1
			       const char *valbuf, int element, int bitpos)
d714 1
a714 1
				 char *valbuf, int bitpos)
d880 1
a880 1
      const char *valbuf = value_contents (args[i]);
d884 1
a884 1
      char buf[16];
d1009 1
a1009 1
			      void *valbuf)
d1012 1
a1012 1
  char buf[32];
d1050 1
a1050 1
			    const void *valbuf)
d1053 1
a1053 1
  char buf[16];
d1092 2
a1093 2
		      struct regcache *regcache, void *readbuf,
		      const void *writebuf)
d1196 1
a1196 1
  const char *regs = gregs;
d1205 1
a1205 1
	  char buf[4];
d1244 1
a1244 1
	  char buf[8];
d1310 1
a1310 1
  char *regs = gregs;
d1319 1
a1319 1
	  char buf[8];
d1361 1
a1361 1
	  char buf[8];
d1417 1
a1417 1
  const char *regs = fpregs;
d1452 1
a1452 1
  char *regs = fpregs;
@


1.21
log
@* sparc-tdep.c (sparc_supply_rwindow, sparc_collect_rwindow):
Handle StackGhost in 64-bit code.
* sparc64-tdep.c (sparc64_frame_prev_register): Handle StackGhost.
@
text
@d24 1
d1107 26
d1167 5
@


1.20
log
@* sparc-tdep.c (sparc_frame_cache): Adjust cached frame base
address for 64-bit code.
(sparc_unwind_dummy_id): Likewise.
* sparc64-tdep.c (sparc64_frame_prev_register): Adjust for new
frame base address convention.
(sparc64_push_dummy_call): Likewise.
* sparc64nbsd-tdep.c: Update copyright year.
(sparc64nbsd_sigcontext_frame_cache): Adjust cached frame base
address for 64-bit code.
(sparc64nbsd_init_abi): Tweak comment.
* sparc64obsd-tdep.c: Update copyright year.
(sparc64obsd_frame_cache): Adjust cached frame base address for
64-bit code.
(sparc64obsd_init_abi): Tweak comment.
@
text
@d522 23
@


1.19
log
@* sparc64-tdep.c (sparc64_store_floating_fields): Constify third
argument.
(sparc64_store_arguments): Constify.
@
text
@d529 1
a529 1
      *addrp = cache->base + BIAS + (regnum - SPARC_L0_REGNUM) * 8;
d575 1
a575 1
  return cache->base + BIAS;
d976 1
a976 1
  return sp;
@


1.18
log
@2005-02-06  Andrew Cagney  <cagney@@gnu.org>

	* value.c (value_contents, value_contents_writeable): New
	functions.
	* value.h (VALUE_CONTENTS): Delete macro.
	(value_contents, value_contents_writeable): Declare.
	* xstormy16-tdep.c, value.c, valops.c, valarith.c: Update.
	* stack.c, sparc-tdep.c, sparc64-tdep.c, sh-tdep.c: Update.
	* sh64-tdep.c, scm-valprint.c, scm-exp.c, s390-tdep.c: Update.
	* rs6000-tdep.c, p-valprint.c, printcmd.c: Update.
	* ppc-sysv-tdep.c, mips-tdep.c, mi/mi-main.c: Update.
	* m88k-tdep.c, m68hc11-tdep.c, m32r-tdep.c: Update.
	* jv-valprint.c, ia64-tdep.c, hppa-tdep.c: Update.
	* hpacc-abi.c, f-valprint.c, frv-tdep.c, eval.c: Update.
	* c-valprint.c, cris-tdep.c, cp-valprint.c: Update.
	* cli/cli-dump.c, breakpoint.c, avr-tdep.c, arm-tdep.c: Update.
	* arm-linux-tdep.c, amd64-tdep.c, alpha-tdep.c: Update.
	* ada-valprint.c, ada-lang.c: Update.
@
text
@d618 1
a618 1
			       char *valbuf, int element, int bitpos)
d856 1
a856 1
      char *valbuf = value_contents (args[i]);
@


1.17
log
@* sparc64-tdep.c (sparc64_store_arguments): Fix typo.
@
text
@d3 1
a3 1
   Copyright 2003, 2004 Free Software Foundation, Inc.
d787 1
a787 1
	      write_memory (sp, VALUE_CONTENTS (args[i]), len);
d856 1
a856 1
      char *valbuf = VALUE_CONTENTS (args[i]);
@


1.16
log
@2004-11-12  Andrew Cagney  <cagney@@gnu.org>

	* sparc-tdep.c: Replace VALUE_TYPE with value_type.
	* v850-tdep.c, sparc64-tdep.c, sh-tdep.c: Ditto.
	* sh64-tdep.c, s390-tdep.c, mcore-tdep.c: Ditto.
	* h8300-tdep.c, arm-linux-tdep.c, amd64-tdep.c: Ditto.
	* hppa-tdep.c, mips-tdep.c, m88k-tdep.c: Ditto.
	* m68hc11-tdep.c, m32r-tdep.c, ia64-tdep.c: Ditto.
	* frv-tdep.c, cris-tdep.c, avr-tdep.c, alpha-tdep.c: Ditto.
@
text
@d942 1
a942 1
      /* Always store the argument in memeory.  */
@


1.15
log
@2004-10-27  Andrew Cagney  <cagney@@gnu.org>

	* trad-frame.c (trad_frame_get_prev_register): Use
	frame_unwind_register instead of frame_register_unwind, do not
	recurse the register's location.
	* xstormy16-tdep.c (xstormy16_frame_prev_register):
	* sparc-tdep.c (sparc32_frame_prev_register): Ditto.
	* sparc64-tdep.c (sparc64_frame_prev_register): Ditto.
	* sh-tdep.c (sh_frame_prev_register): Ditto.
	* m68k-tdep.c (m68k_frame_prev_register): Ditto.
	* i386-tdep.c (i386_frame_prev_register): Ditto.
	* dwarf2-frame.c (dwarf2_frame_prev_register): Ditto.
	* amd64-tdep.c (amd64_frame_prev_register): Ditto.
@
text
@d758 1
a758 1
      struct type *type = VALUE_TYPE (args[i]);
d857 1
a857 1
      struct type *type = VALUE_TYPE (args[i]);
@


1.14
log
@* sparc64-tdep.c (sparc64_store_arguments): Fix passing
quad-precision floating point arguments in registers.
@
text
@d547 6
a552 2
  frame_register_unwind (next_frame, regnum,
			 optimizedp, lvalp, addrp, realnump, valuep);
@


1.13
log
@From Michael Mueller <m.mueller99@@kay-mueller.de>:
* sparc64-tdep.c (sparc64_frame_base_address): Take BIAS into
account.
@
text
@d934 1
a934 1
	      regcache_cooked_write (regcache, regnum + 1, valbuf);
@


1.12
log
@2004-06-06  Randolph Chung  <tausq@@debian.org>

	* gdbarch.sh (PUSH_DUMMY_CALL): Change CORE_ADDR func_addr argument
	to struct value *function.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Likewise.
	* infcall.c (call_function_by_hand): Pass entire function value
	to push_dummy_call.

	* Makefile.in (alpha-tdep.o, frv-tdep.o, ia64-tdep.o, mips-tdep.o)
	(ppc-sysv-tdep.o, rs6000-tdep.o): Update dependencies.
	* alpha-tdep.c (alpha_push_dummy_call): Update call signature.
	* amd64-tdep.c (amd64_push_dummy_call): Likewise.
	* arm-tdep.c (arm_push_dummy_call): Likewise.
	* avr-tdep.c (avr_push_dummy_call): Likewise.
	* cris-tdep.c (cris_push_dummy_call): Likewise.
	* d10v-tdep.c (d10v_push_dummy_call): Likewise.
	* frv-tdep.c (frv_push_dummy_call): Likewise.
	* h8300-tdep.c (h8300_push_dummy_call): Likewise.
	* hppa-tdep.c (hppa32_push_dummy_call)
	(hppa64_push_dummy_call): Likewise.
	* i386-tdep.c (i386_push_dummy_call): Likewise.
	* ia64-tdep.c (ia64_push_dummy_call): Likewise.
	* m32r-tdep.c (m32r_push_dummy_call): Likewise.
	* m68hc11-tdep.c (m68hc11_push_dummy_call): Likewise.
	* m68k-tdep.c (m68k_push_dummy_call): Likewise.
	* m88k-tdep.c (m88k_push_dummy_call): Likewise.
	* mips-tdep.c (mips_eabi_push_dummy_call, mips_n32n64_push_dummy_call)
	(mips_o32_push_dummy_call, mips_o64_push_dummy_call): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	* ppc-tdep.h (ppc_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	* rs6000-tdep.c (rs6000_push_dummy_call): Likewise.
	* s390-tdep.c (s390_push_dummy_call): Likewise.
	* sh-tdep.c (sh_push_dummy_call_fpu)
	(sh_push_dummy_call_nofpu): Likewise.
	* sparc-tdep.c (sparc32_push_dummy_call): Likewise.
	* sparc64-tdep.c (sparc64_push_dummy_call): Likewise.
	* vax-tdep.c (vax_push_dummy_call): Likewise.
@
text
@d571 1
a571 2
  /* ??? Should we take BIAS into account here?  */
  return cache->base;
@


1.11
log
@* sparc64-tdep.c (sparc_address_from_register): Remove function.
@
text
@d952 1
a952 1
sparc64_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
@


1.10
log
@2004-01-17  Andrew Cagney  <cagney@@redhat.com>

	* x86-64-tdep.c (x86_64_init_abi): No need to clear
	extract_struct_value_address, i386 does not set it.
	* sparc64-tdep.c (sparc64_init_abi): Do not set
	extract_struct_value_address, never called.
	(sparc64_extract_struct_value_address): Delete function.
	* m68hc11-tdep.c: Update copyright.
	(m68hc11_gdbarch_init): Delete redundant assignment of
	extract_struct_value_address.
	* i386-tdep.c: Update copyright.
	(i386_gdbarch_init): Do not set extract_struct_value_address,
	never called.
	(i386_extract_struct_value_address): Delete function.
	* sparc-tdep.c (sparc32_gdbarch_init): Do not set
	extract_struct_value_address, never called.
	(sparc32_extract_struct_value_address): #if 0 function.
@
text
@a54 11
/* Return the contents if register REGNUM as an address.  */

static CORE_ADDR
sparc_address_from_register (int regnum)
{
  ULONGEST addr;

  regcache_cooked_read_unsigned (current_regcache, regnum, &addr);
  return addr;
}

@


1.10.6.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d55 11
d582 2
a583 1
  return cache->base + BIAS;
d946 1
a946 1
	      regcache_cooked_write (regcache, regnum + 1, valbuf + 8);
d963 1
a963 1
sparc64_push_dummy_call (struct gdbarch *gdbarch, struct value *function,
@


1.9
log
@* sparc-tdep.c (sparc32_extract_struct_value_address): Rename from
sparc_extract_struct_value_address.
(sparc32_gdbarch_init): Set extract_struct_value_address.
* sparc64-tdep.c (sparc64_extract_struct_value_address): New
function.
(sparc64_init_abi): Set extract_struct_value_address.  Don't set
return_value_on_stack.
@
text
@a1088 13

/* Extract from REGCACHE, which contains the (raw) register state, the
   address in which a function should return its structure value, as a
   CORE_ADDR.  */

static CORE_ADDR
sparc64_extract_struct_value_address (struct regcache *regcache)
{
  ULONGEST addr;

  regcache_cooked_read_unsigned (regcache, SPARC_O0_REGNUM, &addr);
  return addr;
}
a1119 2
  set_gdbarch_extract_struct_value_address
    (gdbarch, sparc64_extract_struct_value_address);
@


1.8
log
@* sparc64-tdep.c (sparc64_store_arguments): Fix handling of
`float' arguments.
@
text
@d1089 13
d1133 2
a1134 2
  set_gdbarch_return_value_on_stack
    (gdbarch, generic_return_value_on_stack_not);
@


1.7
log
@* sparc64-tdep.c (sparc64_store_floating_fields): Update comment
such that it mentions a specific version of GCC that exhibits this
bug.
@
text
@d914 2
a915 1
	      valbuf = memcpy (buf + 4, valbuf, 4);
d918 1
a918 1
		regnum = SPARC64_D0_REGNUM;
@


1.6
log
@* sparc64-tdep.c (sparc64_store_floating_fields): If TYPE is a
structure that has a single `float' member, store it in %f1 in
addition to %f0.
@
text
@d677 4
a680 2
         be stored in.  To appease GCC, if a structure has only a
         single `float' member, we store its value in %f1 too.  */
@


1.5
log
@* sparc64-tdep.c (sparc64_16_byte_align_p)
(sparc64_store_floating_fields, sparc64_store_floating_fields):
Use check_typedef to get subtypes of structures and unions.
(sparc64_store_return_value): Fix calculation of the appropriate
offset into VALBUF when storing a structure or union.
(sparc64_return_value): New function.
(sparc64_use_struct_convention): Remove function.
(sparc64_init_abi): Set return_value, don't set
extract_return_value, store_return_value and
use_struct_convention.
@
text
@d671 15
@


1.4
log
@* Makefile.in (ALLDEPFILES): Remove sparc-linux-nat.c and
sparcl-tdep.c.  Add sparc-linux-tdep.c, sparc-sol2-nat.c,
sparc-sol2-tdep.c, sparc-sol2-nat.c, sparc-sol2-tdep.c,
sparc64-linux-nat.c, sparc64-linux-tdep.c, sparc64-nat.c,
sparc64-sol2-tdep.c, sparc64-tdep.c, sparc64fbsd-nat.c,
sparc64fbsd-tdep.c, sparcnbsd-nat.c, sparcnbsd-tdep.c.
(sparc_nat_h): New variable.
(sparcbsd_nat_h, sparcnbsd_tdep_h): Remove variables.
(tm-sun4os4.h): Remove dependency.
(sparcbsd-nat.o, sparc-linux-nat.o): Remove dependencies.
(sparc64fbsd-nat.o, sparc64fbsd-tdep.o, sparc64nbsd-nat.o,
sparc64-tdep.o, sparc-nat.o, sparcnbsd-nat.o, sparcnbsd-tdep.o,
sparc-tdep.o): Update dependencies.
(sparc-linux-tdep.o, sparc-sol2-nat.o, sparc-sol2-tdep.o,
sparc64-linux-nat.o, sparc64-linux-tdep.o, sparc64-nat.o,
sparc64-sol2-tdep.o, sparc64-tdep.o, sparc64nbsd-tdep.o): New
dependencies.
* configure.host: Remove existing sparc-*-lynxos*,
sparc-*-solaris*, sparc-*-sunos4*, sparc-*-sunos5*, sparc-*-*,
ultrasparc-*-freebsd, sparcv9-*-freebsd, sparc64-*-linux*,
sparcv9-*-* and sparc64-*-* triplets.  Add new sparc64-*-linux*,
sparc-*-solaris2*, sparcv9-*-solaris2* and sparc64-*-solaris2*
triplets.
* configure.tgt: Remove exitsing sparc-*-aout*, sparc-*-coff*,
sparc-*-elf*, sparc*-lynxos*, sparc-*-solars2*, sparc-*-sunos4*,
sparc-*-sunos5*, sparc-*-vxworks*, sparc64-*linux*, sparc64-*-*,
sparcv9-*-* and commented out sparc64-*-solars2* triplets.  Add
new sparc-*-solaris2.[0-6], sparc-*-solaris2.[0-6].*,
sparc64-*-linux, sparc-*-solaris2*, sparcv9-*-solaris*,
sparc64-*-solaris2* and sparc64-*-* triplets.
* sparc64-tdep.c: Update copyright year.  Include "inferior.h",
"symtab.h" and "objfiles.h".
(BIAS): Remove define.
(X_OP, X_RD, X_A, X_COND, X_OP2, X_IMM22, X_OP3, X_I, X_DISP22)
(X_DISP19): Remove macros.
(sparc_fetch_instruction): Remove function.
(struct gdbarch_tdep): Remove definition.
(SPARC64_NUM_REGS, SPARC64_NUM_PSEUDO_REGS): Use ARRAY_SIZE.
(sparc_breakpoint_from_pc): Remove function.
(struct sparc64_frame_cache): Remove definition.
(sparc64_alloc_frame_cache, sparc64_analyze_prologue,
sparc64_unwind_pc): Remove functions.
(sparc64_skip_prologue): Use `struct sparc_frame_cache' instead of
`struct sparc64_frame_cache.  Call sparc_analyze_prologue instead
of sparc64_analyze_prologue.  Mark constant as ULL instead of UL.
(sparc64_frame_cache): Change return type to `struct
sparc_frame_cache *'.  Simply call sparc_frame_cache.
(sparc64_frame_this_id, sparc64_frame_prev_register,
sparc64_frame_base_address): Use `struct sparc_frame_cache'
instead of `struct sparc64_frame_cache.
(sparc_unwind_dummy_id, sparc_extract_struct_value_address,
sparc_analyze_control_transfer, sparc_software_single_step,
sparc64_gdbarch_init, sparc_supply_rwindow, sparc_fill_rwindow,
_initialize_sparc64_tdep): Remove functions.
(TSTATE_CWP, TSTATE_ICC, TSTATE_XCC): New macros.
(PSR_S, PSR_ICC, PSR_VERS, PSR_IMPL, PSR_V8PLUS, PSR_XCC): New
macros.
(sparc64_supply_gregset, sparc64_collect_gregset,
sparc64_supply_fpregset, sparc64_collect_fpregset): New functions.
(sparc64_init_abi): New function.
* sparc64-tdep.h: Update copyright year.  Fix typo in multiple
inclusion guard.  Include "sparc-tdep.h".
(BIAS): Define.
(r_tstate_offset, r_fprs_offset): New defines.
(enum sparc_regnum): Remove defenition.
(enum sparc64_regnum): Reformat.
(sparc_supply_rwindow, sparc_fill_rwindow): Remove prototypes.
(sparc64_init_abi, sparc64_supply_gregset,
sparc64_collect_gregset, sparc64_supply_fpregset,
sparc64_collect_fpregset): New prototypes.
(sparc64_sol2_gregset, sparc64nbsd_gregset, sparc64fbsd_gregset):
Add extern declarations.
(sparc64_sol2_init_abi): New prototype.
(sparc64fbsd_supply_reg, sparc64fbsd_fill_reg)
(sparc64fbsd_supply_fpreg, sparc64fbsd_fill_fpreg): Remove
prototypes.
* sparc64fbsd-nat.c: Include "sparc-nat.h", don't include
"sparnbsd-nat.h".
(sparc64fbsd_reg_supplies_p, sparc64fbsd_fpreg_supplies_p): Remove
functions.
(_initialize_sparc64fbsd_nat): Remove initialization of
sparcbsd_supply_reg, sparcbsd_fill_reg, sparcbsd_supply_fpreg,
sparcbsd_fill_fpreg, sparcbsd_reg_supplies_p,
sparcbsd_fpreg_supplies_p.  Initialize sparc_gregset.
* sparc64fbsd-tdep.c: Update copyright year.  Include "frame.h",
"frame-unwind.h", "trad-frame.h" and "gdb_assert.h".
(sparc64fbsd_r_global_offset, sparc64fbsd_r_out_offset)
(sparc64fbsd_r_fprs_offset, sparc64fbsd_r_tnpc_offset)
(sparc64fbsd_r_tpc_offset, sparc64fbsd_r_tstate_offset)
(sparc64fbsd_r_y_offset): Remove variables.
(sparc64fbsd_sizeof_struct_reg, sparc64fbsd_sizeof_struct_fpreg):
Make static and const.
(sparc64fbsd_supply_reg, sparc64fbsd_fill_reg)
(sparc64fbsd_supply_fpreg, sparc64fbsd_fill_fpreg): Remove
functions.
(sparc64fbsd_gregset): New variable.
(fetch_core_registers): Replace calls to sparc64fbsd_supply_reg
and sparc64fbsd_supply_fpreg with calls to sparc64_supply_gregset
and sparc64_supply_fpregset.
(sparc64fbsd_pc_in_sigtramp, sparc64fbsd_sigtramp_frame_cache)
(sparc64fbsd_sigtramp_frame_this_id)
(sparc64fbsd_sigtramp_frame_prev_register): New functions.
(sparc64fbsd_sigtramp_frame_unwind): New variable.
(sparc64fbsd_sigtramp_frame_sniffer): New function.
(sparc64fbsd_init_abi): Set pc_in_sigtramp, append
sparc64fbsd_sigtramp_frame_sniffer.  Call sparc64_init_abi.
* sparcnbsd-tdep.c: Update copyright year.  Include
"floatformat.h", "frame.h", "frame-unwind.h", "symtab.h",
"trad-frame.h" and "gdb_assert.h", don't include "target.h",
"value.h" and "sparcnbsd-tdep.h".
(REG32_OFFSET_PSR, REG32_OFFSET_PC, REG32_OFFSET_NPC)
(REG32_OFFSET_Y, REG32_OFFSET_GLOBAL, REG32_OFFSET_OUT)
(REG64_OFFSET_TSTATE, REG64_OFFSET_PC, REG64_OFFSET_NPC)
(REG64_OFFSET_Y, REG64_OFFSET_GLOBAL, REG64_OFFSET_OUT): Remove
defines.
(sparcnbsd_gregset): New variable.
(sparcnbsd_supply_reg32, sparcnbsd_supply_reg64)
(sparcnbsd_fill_reg32, sparcnbsd_fill_reg64)
(sparcnbsd_supply_fpreg32, sparcnbsd_supply_fpreg64)
(sparcnbsd_fill_reg32, sparcnbsd_fill_reg64): Remove functions.
(sparc32nbsd_sigtramp_start, sparc32nbsd_sigtramp_end): New
variables.
(sparc32nbsd_pc_in_sigtramp, sparc32nbsd_sigcontext_frame_cache)
(sparc32nbsd_sigcontext_frame_this_id)
(sparc32nbsd_sigcontext_frame_prev_register): New functions.
(sparc32nbsd_sigcontext_frame_unwind): New variable.
(sparc32nbsd_sigtramp_frame_sniffer): New function.
(sparcnbsd_get_longjmp_target_32,
sparcnbsd_get_longjmp_target_64): Remove functions.
(sparcnbsd_aout_in_solib_call_trampoline): Rewrite.
(sparcnbsd_init_abi_common, sparcnbsd_init_aout,
sparcnbsd_init_elf): Remove.
(sparcnbsd_init_abi, sparcnbsd_aout_init_abi)
(sparcnbsd_elf_init_abi): New functions.
(_initialize_sparcnbsd_tdep): New prototype.
(_initialize_sparnbsd_tdep): Update.
* config/sparc/fbsd.mh (NATDEPFILES): Remove sparcbsd-nat.o and
corelow.o.  Add sparc64-nat.o and sparc-nat.o.
* config/sparc/fbsd.mt (TDEPFILES): Add sparc-tdep.o and corelow.o.
* config/sparc/linux.mh: Update comment.
(XM_FILE, HOST_IPC): Remove variables.
(NATDEPFILES): Add sparc-sol2-nat.o and core-regset.o.  Remove
sparc-linux-nat.o.
* config/sparc/linux.mt: Update comment.
(TDEPFILES): Add sparc-sol2-tdep.o and sparc-linux-tdep.o.
* config/sparc/nbsd.mt: Reformat.
* config/sparc/nbsd64.mh: Update comment.
(NATDEPFILES): Add sparc-nat.o.
* config/sparc/nbsd64.mt: Update comment.
(TDEPFILES): Add sparc64-tdep.o and sparc64nbsd-tdep.o.
(TM_FILE): Set to tm-nbsd.h.
* config/sparc/nbsdelf.mh: Update comment.
(NATDEPFILES): Add sparc-nat.o.
(XM_FILE): Delete.
* config/sparc/nbsdaout.mh: Update comment.
(NATDEPFILES): Add sparc-nat.o
(XM_FILE): Delete.
* config/sparc/nm-linux.h: Update copyright year.  Don't include
"config/nm-svr4.h" and "solib.h".  Add protection against multiple
inclusion.
(KERNEL_U_SIZE): Remove define.
(kernel_u_size): Remove prototype.
(PTRACE_ARG3_TYPE, PTRACE_XFER_TYPE): Define.
* config/sparc/nm-nbsd.h: Update copyright.  Don't include
"regcache.h".
(CHILD_PREPARE_TO_STORE): Remove define.
* config/sparc/nm-nbsdaout.h: Tweak some comments.
* sparc-nat.c, sparc-tdep.c, sparc-tdep.h, sparc64nbsd-nat.c,
sparcnbsd-nat.c: Rewrite files.
* config/sparc/tm-linux.h, config/sparc/tm-nbsd.h: Rewrite files.
* sparc-linux-nat.c, sparcbsd-nat.c, sparcbsd-nat.h,
sparcnbsd-tdep.h: Remove files.
* config/sparc/nm-sparclynx.h, config/sparc/nm-sun4os4.h,
config/sparc/nm-sun4sol2.h, config/sparc/sp64.mt,
config/sparc/sp64linux.mt, config/sparc/sp64sol2.mt,
config/sparc/sparc-em.mt, config/sparc/sparclynx.mh,
config/sparc/sparclynx.mt, config/sparc/sun4os4.mh,
config/sparc/sun4os4.mt, config/sparc/sun4sol2.mh,
config/sparc/sun4sol2.mt, config/sparc/tm-sp64.h,
config/sparc/tm-sp64linux.h, config/sparc/tm-sparc.h,
config/sparc/tm-sparclynx.h, config/sparc/tm-spc-em.h,
config/sparc/tm-sun4os4.h, config/sparc/tm-sun4sol2.h,
config/sparc/tm-vxsparc.h, config/sparc/vxsparc.mt,
config/sparc/xm-linux.h, config/sparc/xm-sun4sol2.h: Remove files.
* sparc-linux-tdep.c, sparc-nat.h, sparc-sol2-nat.c,
sparc-sol2-tdep.c, sparc64-linux-nat.c, sparc64-linux-t dep.c,
sparc64-nat.c, sparc64-sol2-tdep.c, sparc64nbsd-tdep.c: New files.
* config/sparc/linux64.mh, config/sparc/linux64.mt,
config/sparc/nm-sol2.h, config/sparc/sol2-64.mt,
config/sparc/sol2.mh, config/sparc/sol2.mt, config/sparc/sparc.mt,
config/sparc/sparc64.mt, config/sparc/tm-sol2.h: New files.
@
text
@d607 6
a612 2
	if (sparc64_16_byte_align_p (TYPE_FIELD_TYPE (type, i)))
	  return 1;
d664 7
a670 3
	sparc64_store_floating_fields (regcache, TYPE_FIELD_TYPE (type, i),
				       valbuf, element,
				       bitpos + TYPE_FIELD_BITPOS (type, i));
d716 6
a721 3
	sparc64_extract_floating_fields (regcache, TYPE_FIELD_TYPE (type, i),
					 valbuf,
					 bitpos + TYPE_FIELD_BITPOS (type, i));
d1033 1
a1033 1
	regcache_cooked_write (regcache, SPARC_O0_REGNUM + i, buf + i * 4);
d1056 4
a1059 2
static int
sparc64_use_struct_convention (int gcc_p, struct type *type)
d1061 9
a1069 3
  /* Structure and union types up to 32 bytes in size are returned in
     registers.  */
  return (TYPE_LENGTH (type) > 32);
d1101 1
a1101 3
  set_gdbarch_extract_return_value (gdbarch, sparc64_extract_return_value);
  set_gdbarch_store_return_value (gdbarch, sparc64_store_return_value);
  set_gdbarch_use_struct_convention (gdbarch, sparc64_use_struct_convention);
@


1.3
log
@2003-09-17  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_NPC_REGNUM): Deprecate NPC_REGNUM.
	* gdbarch.h, gdbarch.c: Regenerate.
	* core-sol2.c, hppa-tdep.c, lynx-nat.c, procfs.c: Update.
	* regcache.c, remote-vxsparc.c, sparc-linux-nat.c: Update.
	* sparc-nat.c, sparc-tdep.c, sparc64-tdep.c: Update.
	* sparcnbsd-tdep.c: Update.
@
text
@d3 1
a3 1
   Copyright 2003 Free Software Foundation, Inc.
d30 3
a50 35

/* The stack pointer is offset from the stack frame by a BIAS of 2047
   (0x7ff) for 64-bit code.  BIAS is likely to be defined on SPARC
   hosts, so undefine it first.  */
#undef BIAS
#define BIAS 2047

/* Macros to extract fields from SPARC instructions.  */
#define X_OP(i) (((i) >> 30) & 0x3)
#define X_A(i) (((i) >> 29) & 1)
#define X_COND(i) (((i) >> 25) & 0xf)
#define X_OP2(i) (((i) >> 22) & 0x7)
#define X_IMM22(i) ((i) & 0x3fffff)
#define X_OP3(i) (((i) >> 19) & 0x3f)
/* Sign extension macros.  */
#define X_DISP22(i) ((X_IMM22 (i) ^ 0x200000) - 0x200000)
#define X_DISP19(i) ((((i) & 0x7ffff) ^ 0x40000) - 0x40000)

/* Fetch the instruction at PC.  Instructions are always big-endian
   even if the processor operates in little-endian mode.  */

static unsigned long
sparc_fetch_instruction (CORE_ADDR pc)
{
  unsigned char buf[4];
  unsigned long insn;
  int i;

  read_memory (pc, buf, sizeof (buf));

  insn = 0;
  for (i = 0; i < sizeof (buf); i++)
    insn = (insn << 8) | buf[i];
  return insn;
}
a133 8
/* UltraSPARC architecture specific information.  */

struct gdbarch_tdep
{
  /* Offset of saved PC in jmp_buf.  */
  int jb_pc_offset;
};

d246 1
a246 2
#define SPARC64_NUM_REGS \
  (sizeof (sparc64_register_info) / sizeof (sparc64_register_info[0]))
d310 1
a310 3
#define SPARC64_NUM_PSEUDO_REGS \
  (sizeof (sparc64_pseudo_register_info) \
   / sizeof (sparc64_pseudo_register_info[0]))
a458 15

/* Use the program counter to determine the contents and size of a
   breakpoint instruction.  Return a pointer to a string of bytes that
   encode a breakpoint instruction, store the length of the string in
   *LEN and optionally adjust *PC to point to the correct memory
   location for inserting the breakpoint.  */
   
static const unsigned char *
sparc_breakpoint_from_pc (CORE_ADDR *pc, int *len)
{
  static unsigned char break_insn[] = { 0x91, 0xd0, 0x20, 0x01 };

  *len = sizeof (break_insn);
  return break_insn;
}
a460 56
struct sparc64_frame_cache
{
  /* Base address.  */
  CORE_ADDR base;
  CORE_ADDR pc;

  /* Do we have a frame?  */
  int frameless_p;
};

/* Allocate and initialize a frame cache.  */

static struct sparc64_frame_cache *
sparc64_alloc_frame_cache (void)
{
  struct sparc64_frame_cache *cache;
  int i;

  cache = FRAME_OBSTACK_ZALLOC (struct sparc64_frame_cache);

  /* Base address.  */
  cache->base = 0;
  cache->pc = 0;

  /* Frameless until proven otherwise.  */
  cache->frameless_p = 1;

  return cache;
}

static CORE_ADDR
sparc64_analyze_prologue (CORE_ADDR pc, CORE_ADDR current_pc,
			  struct sparc64_frame_cache *cache)
{
  unsigned long insn;

  if (current_pc <= pc)
    return current_pc;

  /* Check whether the function starts with a SAVE instruction.  */
  insn = sparc_fetch_instruction (pc);
  if (X_OP (insn) == 2 && X_OP3 (insn) == 0x3c)
    {
      cache->frameless_p = 0;
      return pc + 4;
    }

  return pc;
}

static CORE_ADDR
sparc64_unwind_pc (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  return frame_unwind_register_unsigned (next_frame, SPARC64_PC_REGNUM);
}

d469 1
a469 1
  struct sparc64_frame_cache cache;
d482 1
a482 1
  return sparc64_analyze_prologue (start_pc, 0xffffffffffffffffUL, &cache);
d487 1
a487 1
static struct sparc64_frame_cache *
d490 1
a490 29
  struct sparc64_frame_cache *cache;

  if (*this_cache)
    return *this_cache;

  cache = sparc64_alloc_frame_cache ();
  *this_cache = cache;

  /* In priciple, for normal frames, %fp (%i6) holds the frame
     pointer, which holds the base address for the current stack
     frame.  */

  cache->base = frame_unwind_register_unsigned (next_frame, SPARC_FP_REGNUM);
  if (cache->base == 0)
    return cache;

  cache->pc = frame_func_unwind (next_frame);
  if (cache->pc != 0)
    sparc64_analyze_prologue (cache->pc, frame_pc_unwind (next_frame), cache);

  if (cache->frameless_p)
    {
      /* We didn't find a valid frame, which means that CACHE->base
	 currently holds the frame pointer for our calling frame.  */
      cache->base = frame_unwind_register_unsigned (next_frame,
						    SPARC_SP_REGNUM);
    }

  return cache;
d497 1
a497 1
  struct sparc64_frame_cache *cache =
d513 1
a513 1
  struct sparc64_frame_cache *cache =
d579 1
a579 1
  struct sparc64_frame_cache *cache =
a592 9

static struct frame_id
sparc_unwind_dummy_id (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  CORE_ADDR sp;

  sp = frame_unwind_register_unsigned (next_frame, SPARC_SP_REGNUM);
  return frame_id_build (sp, frame_pc_unwind (next_frame));
}
a1044 13
/* Extract from REGCACHE, which contains the (raw) register state, the
   address in which a function should return its structure value, as a
   CORE_ADDR.  */

static CORE_ADDR
sparc_extract_struct_value_address (struct regcache *regcache)
{
  ULONGEST addr;

  regcache_cooked_read_unsigned (regcache, SPARC_O0_REGNUM, &addr);
  return addr;
}

a1051 1

a1052 74
/* The SPARC Architecture doesn't have hardware single-step support,
   and most operating systems don't implement it either, so we provide
   software single-step mechanism.  */

static CORE_ADDR
sparc_analyze_control_transfer (CORE_ADDR pc, CORE_ADDR *npc)
{
  unsigned long insn = sparc_fetch_instruction (pc);
  int conditional_p = X_COND (insn) & 0x7;
  int branch_p = 0;
  long offset = 0;			/* Must be signed for sign-extend.  */

  if (X_OP (insn) == 0 && X_OP2 (insn) == 3 && (insn & 0x1000000) == 0)
    {
      /* Branch on Integer Register with Prediction (BPr).  */
      branch_p = 1;
      conditional_p = 1;
    }
  else if (X_OP (insn) == 0 && X_OP2 (insn) == 6)
    {
      /* Branch on Floating-Point Condition Codes (FBfcc).  */
      branch_p = 1;
      offset = 4 * X_DISP22 (insn);
    }
  else if (X_OP (insn) == 0 && X_OP2 (insn) == 5)
    {
      /* Branch on Floating-Point Condition Codes with Prediction
         (FBPfcc).  */
      branch_p = 1;
      offset = 4 * X_DISP19 (insn);
    }
  else if (X_OP (insn) == 0 && X_OP2 (insn) == 2)
    {
      /* Branch on Integer Condition Codes (Bicc).  */
      branch_p = 1;
      offset = 4 * X_DISP22 (insn);
    }
  else if (X_OP (insn) == 0 && X_OP2 (insn) == 1)
    {
      /* Branch on Integer Condition Codes with Prediction (BPcc).  */
      branch_p = 1;
      offset = 4 * X_DISP19 (insn);
    }

  /* FIXME: Handle DONE and RETRY instructions.  */

  /* FIXME: Handle the Trap instruction.  */

  if (branch_p)
    {
      if (conditional_p)
	{
	  /* For conditional branches, return nPC + 4 iff the annul
	     bit is 1.  */
	  return (X_A (insn) ? *npc + 4 : 0);
	}
      else
	{
	  /* For unconditional branches, return the target if its
	     specified condition is "always" and return nPC + 4 if the
	     condition is "never".  If the annul bit is 1, set *NPC to
	     zero.  */
	  if (X_COND (insn) == 0x0)
	    pc = *npc, offset = 4;
	  if (X_A (insn))
	    *npc = 0;

	  gdb_assert (offset != 0);
	  return pc + offset;
	}
    }

  return 0;
}
d1055 1
a1055 1
sparc_software_single_step (enum target_signal sig, int insert_breakpoints_p)
d1057 1
a1057 9
  static CORE_ADDR npc, nnpc;
  static char npc_save[4], nnpc_save[4];

  if (insert_breakpoints_p)
    {
      CORE_ADDR pc;

      pc = sparc_address_from_register (SPARC64_PC_REGNUM);
      npc = sparc_address_from_register (SPARC64_NPC_REGNUM);
d1059 2
a1060 37
      /* Analyze the instruction at PC.  */
      nnpc = sparc_analyze_control_transfer (pc, &npc);
      if (npc != 0)
	target_insert_breakpoint (npc, npc_save);
      if (nnpc != 0)
	target_insert_breakpoint (nnpc, nnpc_save);

      /* Assert that we have set at least one breakpoint.  */
      gdb_assert (npc != 0 || nnpc != 0);
    }
  else
    {
      if (npc != 0)
	target_remove_breakpoint (npc, npc_save);
      if (nnpc != 0)
	target_remove_breakpoint (nnpc, nnpc_save);

      npc = 0;
      nnpc = 0;
    }
}


static struct gdbarch *
sparc64_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
{
  struct gdbarch_tdep *tdep;
  struct gdbarch *gdbarch;

  /* If there is already a candidate, use it.  */
  arches = gdbarch_list_lookup_by_info (arches, &info);
  if (arches != NULL)
    return arches->gdbarch;

  /* Allocate space for the new architecture.  */
  tdep = XMALLOC (struct gdbarch_tdep);
  gdbarch = gdbarch_alloc (&info, tdep);
d1062 1
a1065 1
  set_gdbarch_long_double_bit (gdbarch, 128);
a1074 1
  set_gdbarch_sp_regnum (gdbarch, SPARC_SP_REGNUM); /* %sp */
a1075 2
  set_gdbarch_deprecated_npc_regnum (gdbarch, SPARC64_NPC_REGNUM);
  set_gdbarch_fp0_regnum (gdbarch, SPARC_F0_REGNUM); /* %f0 */
d1078 2
a1083 2
  set_gdbarch_extract_struct_value_address
    (gdbarch, sparc_extract_struct_value_address);
d1085 4
d1092 34
a1125 2
  /* Stack grows downward.  */
  set_gdbarch_inner_than (gdbarch, core_addr_lessthan);
d1127 6
a1132 3
  set_gdbarch_breakpoint_from_pc (gdbarch, sparc_breakpoint_from_pc);
  set_gdbarch_decr_pc_after_break (gdbarch, 0);
  set_gdbarch_function_start_offset (gdbarch, 0);
d1134 3
a1136 1
  set_gdbarch_frame_args_skip (gdbarch, 8);
d1138 3
a1140 1
  set_gdbarch_print_insn (gdbarch, print_insn_sparc);
d1142 15
a1156 1
  set_gdbarch_software_single_step (gdbarch, sparc_software_single_step);
d1158 3
a1160 1
  set_gdbarch_unwind_dummy_id (gdbarch, sparc_unwind_dummy_id);
d1162 3
a1164 1
  set_gdbarch_unwind_pc (gdbarch, sparc64_unwind_pc);
d1166 37
a1202 1
  frame_base_set_default (gdbarch, &sparc64_frame_base);
d1204 6
a1209 2
  /* Hook in ABI-specific overrides, if they have been registered.  */
  gdbarch_init_osabi (info, gdbarch);
d1211 2
a1212 1
  frame_unwind_append_sniffer (gdbarch, sparc64_frame_sniffer);
d1214 8
a1221 1
  return gdbarch;
a1222 2

/* Helper functions for dealing with register windows.  */
d1225 3
a1227 1
sparc_supply_rwindow (CORE_ADDR sp, int regnum)
d1229 2
a1230 2
  int offset = 0;
  char buf[8];
d1233 1
a1233 1
  if (sp & 1)
d1235 19
a1253 2
      /* Registers are 64-bit.  */
      sp += BIAS;
d1255 5
a1259 1
      for (i = SPARC_L0_REGNUM; i <= SPARC_I7_REGNUM; i++)
d1261 2
a1262 5
	  if (regnum == i || regnum == -1)
	    {
	      target_read_memory (sp + ((i - SPARC_L0_REGNUM) * 8), buf, 8);
	      supply_register (i, buf);
	    }
d1267 11
a1277 3
      /* Registers are 32-bit.  Toss any sign-extension of the stack
	 pointer.  */
      sp &= 0xffffffffUL;
d1279 1
a1279 3
      /* Clear out the top half of the temporary buffer, and put the
	 register value in the bottom half if we're in 64-bit mode.  */
      if (gdbarch_ptr_bit (current_gdbarch) == 64)
d1281 5
a1285 2
	  memset (buf, 0, 4);
	  offset = 4;
d1288 16
a1303 1
      for (i = SPARC_L0_REGNUM; i <= SPARC_I7_REGNUM; i++)
d1306 17
d1324 3
a1326 3
	      target_read_memory (sp + ((i - SPARC_L0_REGNUM) * 4),
				  buf + offset, 4);
	      supply_register (i, buf);
d1333 2
a1334 1
sparc_fill_rwindow (CORE_ADDR sp, int regnum)
d1336 2
a1337 2
  int offset = 0;
  char buf[8];
d1340 1
a1340 1
  if (sp & 1)
d1342 3
a1344 2
      /* Registers are 64-bit.  */
      sp += BIAS;
d1346 5
a1350 8
      for (i = SPARC_L0_REGNUM; i <= SPARC_I7_REGNUM; i++)
	{
	  if (regnum == -1 || regnum == SPARC_SP_REGNUM || regnum == i)
	    {
	      regcache_collect (i, buf);
	      target_write_memory (sp + ((i - SPARC_L0_REGNUM) * 8), buf, 8);
	    }
	}
d1354 1
a1354 9
      /* Registers are 32-bit.  Toss any sign-extension of the stack
	 pointer.  */
      sp &= 0xffffffffUL;

      /* Only use the bottom half if we're in 64-bit mode.  */
      if (gdbarch_ptr_bit (current_gdbarch) == 64)
	offset = 4;

      for (i = SPARC_L0_REGNUM; i <= SPARC_I7_REGNUM; i++)
d1356 3
a1358 6
	  if (regnum == -1 || regnum == SPARC_SP_REGNUM || regnum == i)
	    {
	      regcache_collect (i, buf);
	      target_write_memory (sp + ((i - SPARC_L0_REGNUM) * 4),
				   buf + offset, 4);
	    }
d1360 4
a1365 4


/* Provide a prototype to silence -Wmissing-prototypes.  */
void _initialize_sparc64_tdep (void);
d1368 2
a1369 1
_initialize_sparc64_tdep (void)
d1371 29
a1399 1
  register_gdbarch_init (bfd_arch_sparc, sparc64_gdbarch_init);
@


1.3.6.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.3.6.2
log
@Merge mainline to branch.  GDB is broken until I update cp-names.y.
@
text
@d3 1
a3 1
   Copyright 2003, 2004 Free Software Foundation, Inc.
a29 3
#include "inferior.h"
#include "symtab.h"
#include "objfiles.h"
d48 35
d166 8
d286 2
a287 1
#define SPARC64_NUM_REGS ARRAY_SIZE (sparc64_register_info)
d351 3
a353 1
#define SPARC64_NUM_PSEUDO_REGS ARRAY_SIZE (sparc64_pseudo_register_info)
d502 15
d519 56
d583 1
a583 1
  struct sparc_frame_cache cache;
d596 1
a596 1
  return sparc_analyze_prologue (start_pc, 0xffffffffffffffffULL, &cache);
d601 1
a601 1
static struct sparc_frame_cache *
d604 29
a632 1
  return sparc_frame_cache (next_frame, this_cache);
d639 1
a639 1
  struct sparc_frame_cache *cache =
d655 1
a655 1
  struct sparc_frame_cache *cache =
d721 1
a721 1
  struct sparc_frame_cache *cache =
d735 9
d758 2
a759 6
	{
	  struct type *subtype = check_typedef (TYPE_FIELD_TYPE (type, i));

	  if (sparc64_16_byte_align_p (subtype))
	    return 1;
	}
d811 3
a813 24
	{
	  struct type *subtype = check_typedef (TYPE_FIELD_TYPE (type, i));
	  int subpos = bitpos + TYPE_FIELD_BITPOS (type, i);

	  sparc64_store_floating_fields (regcache, subtype, valbuf,
					 element, subpos);
	}

      /* GCC has an interesting bug.  If TYPE is a structure that has
         a single `float' member, GCC doesn't treat it as a structure
         at all, but rather as an ordinary `float' argument.  This
         argument will be stored in %f1, as required by the psABI.
         However, as a member of a structure the psABI requires it to
         be stored in %f0.  This bug is present in GCC 3.3.2, but
         probably in older releases to.  To appease GCC, if a
         structure has only a single `float' member, we store its
         value in %f1 too (we already have stored in %f0).  */
      if (TYPE_NFIELDS (type) == 1)
	{
	  struct type *subtype = check_typedef (TYPE_FIELD_TYPE (type, 0));

	  if (sparc64_floating_p (subtype) && TYPE_LENGTH (subtype) == 4)
	    regcache_cooked_write (regcache, SPARC_F1_REGNUM, valbuf);
	}
d859 3
a861 6
	{
	  struct type *subtype = check_typedef (TYPE_FIELD_TYPE (type, i));
	  int subpos = bitpos + TYPE_FIELD_BITPOS (type, i);

	  sparc64_extract_floating_fields (regcache, subtype, valbuf, subpos);
	}
d1037 1
a1037 2
	      memcpy (buf + 4, valbuf, 4);
	      valbuf = buf;
d1040 1
a1040 1
		regnum = SPARC64_D0_REGNUM + element;
d1173 1
a1173 1
	regcache_cooked_write (regcache, SPARC_O0_REGNUM + i, buf + i * 8);
a1195 16
static enum return_value_convention
sparc64_return_value (struct gdbarch *gdbarch, struct type *type,
		      struct regcache *regcache, void *readbuf,
		      const void *writebuf)
{
  if (TYPE_LENGTH (type) > 32)
    return RETURN_VALUE_STRUCT_CONVENTION;

  if (readbuf)
    sparc64_extract_return_value (type, regcache, readbuf);
  if (writebuf)
    sparc64_store_return_value (type, regcache, writebuf);

  return RETURN_VALUE_REGISTER_CONVENTION;
}

d1201 1
a1201 1
sparc64_extract_struct_value_address (struct regcache *regcache)
d1208 9
d1218 74
d1294 37
a1330 1
sparc64_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
d1332 2
a1333 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
d1335 8
a1342 2
  tdep->pc_regnum = SPARC64_PC_REGNUM;
  tdep->npc_regnum = SPARC64_NPC_REGNUM;
a1343 1
  /* This is what all the fuss is about.  */
d1347 1
d1357 1
d1359 2
a1362 2
  set_gdbarch_call_dummy_location (gdbarch, AT_ENTRY_POINT);
  set_gdbarch_push_dummy_code (gdbarch, NULL);
d1365 2
a1366 1
  set_gdbarch_return_value (gdbarch, sparc64_return_value);
d1368 2
a1369 3
    (gdbarch, sparc64_extract_struct_value_address);
  set_gdbarch_stabs_argument_has_addr
    (gdbarch, default_stabs_argument_has_addr);
d1373 2
a1374 4
  frame_unwind_append_sniffer (gdbarch, sparc64_frame_sniffer);
  frame_base_set_default (gdbarch, &sparc64_frame_base);
}

d1376 3
a1378 1
/* Helper functions for dealing with register sets.  */
d1380 1
a1380 10
#define TSTATE_CWP	0x000000000000001fULL
#define TSTATE_ICC	0x0000000f00000000ULL
#define TSTATE_XCC	0x000000f000000000ULL

#define PSR_S		0x00000080
#define PSR_ICC		0x00f00000
#define PSR_VERS	0x0f000000
#define PSR_IMPL	0xf0000000
#define PSR_V8PLUS	0xff000000
#define PSR_XCC		0x000f0000
d1382 1
a1382 8
void
sparc64_supply_gregset (const struct sparc_gregset *gregset,
			struct regcache *regcache,
			int regnum, const void *gregs)
{
  int sparc32 = (gdbarch_ptr_bit (current_gdbarch) == 32);
  const char *regs = gregs;
  int i;
d1384 1
a1384 7
  if (sparc32)
    {
      if (regnum == SPARC32_PSR_REGNUM || regnum == -1)
	{
	  int offset = gregset->r_tstate_offset;
	  ULONGEST tstate, psr;
	  char buf[4];
d1386 1
a1386 6
	  tstate = extract_unsigned_integer (regs + offset, 8);
	  psr = ((tstate & TSTATE_CWP) | PSR_S | ((tstate & TSTATE_ICC) >> 12)
		 | ((tstate & TSTATE_XCC) >> 20) | PSR_V8PLUS);
	  store_unsigned_integer (buf, 4, psr);
	  regcache_raw_supply (regcache, SPARC32_PSR_REGNUM, buf);
	}
d1388 1
a1388 3
      if (regnum == SPARC32_PC_REGNUM || regnum == -1)
	regcache_raw_supply (regcache, SPARC32_PC_REGNUM,
			     regs + gregset->r_pc_offset + 4);
d1390 1
a1390 15
      if (regnum == SPARC32_NPC_REGNUM || regnum == -1)
	regcache_raw_supply (regcache, SPARC32_NPC_REGNUM,
			     regs + gregset->r_npc_offset + 4);

      if (regnum == SPARC32_Y_REGNUM || regnum == -1)
	{
	  int offset = gregset->r_y_offset + 8 - gregset->r_y_size;
	  regcache_raw_supply (regcache, SPARC32_Y_REGNUM, regs + offset);
	}
    }
  else
    {
      if (regnum == SPARC64_STATE_REGNUM || regnum == -1)
	regcache_raw_supply (regcache, SPARC64_STATE_REGNUM,
			     regs + gregset->r_tstate_offset);
d1392 2
a1393 3
      if (regnum == SPARC64_PC_REGNUM || regnum == -1)
	regcache_raw_supply (regcache, SPARC64_PC_REGNUM,
			     regs + gregset->r_pc_offset);
d1395 1
a1395 3
      if (regnum == SPARC64_NPC_REGNUM || regnum == -1)
	regcache_raw_supply (regcache, SPARC64_NPC_REGNUM,
			     regs + gregset->r_npc_offset);
d1397 4
a1400 3
      if (regnum == SPARC64_Y_REGNUM || regnum == -1)
	{
	  char buf[8];
d1402 6
a1407 5
	  memset (buf, 0, 8);
	  memcpy (buf + 8 - gregset->r_y_size,
		  regs + gregset->r_y_offset, gregset->r_y_size);
	  regcache_raw_supply (regcache, SPARC64_Y_REGNUM, buf);
	}
d1409 1
a1409 10
      if ((regnum == SPARC64_FPRS_REGNUM || regnum == -1)
	  && gregset->r_fprs_offset != -1)
	regcache_raw_supply (regcache, SPARC64_FPRS_REGNUM,
			     regs + gregset->r_fprs_offset);
    }

  if (regnum == SPARC_G0_REGNUM || regnum == -1)
    regcache_raw_supply (regcache, SPARC_G0_REGNUM, NULL);

  if ((regnum >= SPARC_G1_REGNUM && regnum <= SPARC_O7_REGNUM) || regnum == -1)
d1411 2
a1412 4
      int offset = gregset->r_g1_offset;

      if (sparc32)
	offset += 4;
d1414 1
a1414 1
      for (i = SPARC_G1_REGNUM; i <= SPARC_O7_REGNUM; i++)
d1417 4
a1420 2
	    regcache_raw_supply (regcache, i, regs + offset);
	  offset += 8;
d1423 5
d1429 3
a1431 5
  if ((regnum >= SPARC_L0_REGNUM && regnum <= SPARC_I7_REGNUM) || regnum == -1)
    {
      /* Not all of the register set variants include Locals and
         Inputs.  For those that don't, we read them off the stack.  */
      if (gregset->r_l0_offset == -1)
d1433 3
a1435 1
	  ULONGEST sp;
d1437 1
a1437 4
	  regcache_cooked_read_unsigned (regcache, SPARC_SP_REGNUM, &sp);
	  sparc_supply_rwindow (regcache, sp, regnum);
	}
      else
d1439 1
a1439 6
	  int offset = gregset->r_l0_offset;

	  if (sparc32)
	    offset += 4;

	  for (i = SPARC_L0_REGNUM; i <= SPARC_I7_REGNUM; i++)
d1441 3
a1443 3
	      if (regnum == i || regnum == -1)
		regcache_raw_supply (regcache, i, regs + offset);
	      offset += 8;
d1450 1
a1450 3
sparc64_collect_gregset (const struct sparc_gregset *gregset,
			 const struct regcache *regcache,
			 int regnum, void *gregs)
d1452 2
a1453 2
  int sparc32 = (gdbarch_ptr_bit (current_gdbarch) == 32);
  char *regs = gregs;
d1456 1
a1456 1
  if (sparc32)
d1458 2
a1459 19
      if (regnum == SPARC32_PSR_REGNUM || regnum == -1)
	{
	  int offset = gregset->r_tstate_offset;
	  ULONGEST tstate, psr;
	  char buf[8];

	  tstate = extract_unsigned_integer (regs + offset, 8);
	  regcache_raw_collect (regcache, SPARC32_PSR_REGNUM, buf);
	  psr = extract_unsigned_integer (buf, 4);
	  tstate |= (psr & PSR_ICC) << 12;
	  if ((psr & (PSR_VERS | PSR_IMPL)) == PSR_V8PLUS)
	    tstate |= (psr & PSR_XCC) << 20;
	  store_unsigned_integer (buf, 8, tstate);
	  memcpy (regs + offset, buf, 8);
	}

      if (regnum == SPARC32_PC_REGNUM || regnum == -1)
	regcache_raw_collect (regcache, SPARC32_PC_REGNUM,
			      regs + gregset->r_pc_offset + 4);
d1461 1
a1461 5
      if (regnum == SPARC32_NPC_REGNUM || regnum == -1)
	regcache_raw_collect (regcache, SPARC32_NPC_REGNUM,
			      regs + gregset->r_npc_offset + 4);

      if (regnum == SPARC32_Y_REGNUM || regnum == -1)
d1463 5
a1467 2
	  int offset = gregset->r_y_offset + 8 - gregset->r_y_size;
	  regcache_raw_collect (regcache, SPARC32_Y_REGNUM, regs + offset);
d1472 3
a1474 7
      if (regnum == SPARC64_STATE_REGNUM || regnum == -1)
	regcache_raw_collect (regcache, SPARC64_STATE_REGNUM,
			      regs + gregset->r_tstate_offset);

      if (regnum == SPARC64_PC_REGNUM || regnum == -1)
	regcache_raw_collect (regcache, SPARC64_PC_REGNUM,
			      regs + gregset->r_pc_offset);
d1476 3
a1478 3
      if (regnum == SPARC64_NPC_REGNUM || regnum == -1)
	regcache_raw_collect (regcache, SPARC64_NPC_REGNUM,
			      regs + gregset->r_npc_offset);
d1480 1
a1480 1
      if (regnum == SPARC64_Y_REGNUM || regnum == -1)
d1482 1
a1482 42
	  char buf[8];

	  regcache_raw_collect (regcache, SPARC64_Y_REGNUM, buf);
	  memcpy (regs + gregset->r_y_offset,
		  buf + 8 - gregset->r_y_size, gregset->r_y_size);
	}

      if ((regnum == SPARC64_FPRS_REGNUM || regnum == -1)
	  && gregset->r_fprs_offset != -1)
	regcache_raw_collect (regcache, SPARC64_FPRS_REGNUM,
			      regs + gregset->r_fprs_offset);

    }

  if ((regnum >= SPARC_G1_REGNUM && regnum <= SPARC_O7_REGNUM) || regnum == -1)
    {
      int offset = gregset->r_g1_offset;

      if (sparc32)
	offset += 4;

      /* %g0 is always zero.  */
      for (i = SPARC_G1_REGNUM; i <= SPARC_O7_REGNUM; i++)
	{
	  if (regnum == i || regnum == -1)
	    regcache_raw_collect (regcache, i, regs + offset);
	  offset += 8;
	}
    }

  if ((regnum >= SPARC_L0_REGNUM && regnum <= SPARC_I7_REGNUM) || regnum == -1)
    {
      /* Not all of the register set variants include Locals and
         Inputs.  For those that don't, we read them off the stack.  */
      if (gregset->r_l0_offset != -1)
	{
	  int offset = gregset->r_l0_offset;

	  if (sparc32)
	    offset += 4;

	  for (i = SPARC_L0_REGNUM; i <= SPARC_I7_REGNUM; i++)
d1484 3
a1486 3
	      if (regnum == i || regnum == -1)
		regcache_raw_collect (regcache, i, regs + offset);
	      offset += 8;
d1491 1
d1493 2
a1494 34
void
sparc64_supply_fpregset (struct regcache *regcache,
			 int regnum, const void *fpregs)
{
  int sparc32 = (gdbarch_ptr_bit (current_gdbarch) == 32);
  const char *regs = fpregs;
  int i;

  for (i = 0; i < 32; i++)
    {
      if (regnum == (SPARC_F0_REGNUM + i) || regnum == -1)
	regcache_raw_supply (regcache, SPARC_F0_REGNUM + i, regs + (i * 4));
    }

  if (sparc32)
    {
      if (regnum == SPARC32_FSR_REGNUM || regnum == -1)
	regcache_raw_supply (regcache, SPARC32_FSR_REGNUM,
			     regs + (32 * 4) + (16 * 8) + 4);
    }
  else
    {
      for (i = 0; i < 16; i++)
	{
	  if (regnum == (SPARC64_F32_REGNUM + i) || regnum == -1)
	    regcache_raw_supply (regcache, SPARC64_F32_REGNUM + i,
				 regs + (32 * 4) + (i * 8));
	}

      if (regnum == SPARC64_FSR_REGNUM || regnum == -1)
	regcache_raw_supply (regcache, SPARC64_FSR_REGNUM,
			     regs + (32 * 4) + (16 * 8));
    }
}
d1497 1
a1497 2
sparc64_collect_fpregset (const struct regcache *regcache,
			  int regnum, void *fpregs)
d1499 1
a1499 29
  int sparc32 = (gdbarch_ptr_bit (current_gdbarch) == 32);
  char *regs = fpregs;
  int i;

  for (i = 0; i < 32; i++)
    {
      if (regnum == (SPARC_F0_REGNUM + i) || regnum == -1)
	regcache_raw_collect (regcache, SPARC_F0_REGNUM + i, regs + (i * 4));
    }

  if (sparc32)
    {
      if (regnum == SPARC32_FSR_REGNUM || regnum == -1)
	regcache_raw_collect (regcache, SPARC32_FSR_REGNUM,
			      regs + (32 * 4) + (16 * 8) + 4);
    }
  else
    {
      for (i = 0; i < 16; i++)
	{
	  if (regnum == (SPARC64_F32_REGNUM + i) || regnum == -1)
	    regcache_raw_collect (regcache, SPARC64_F32_REGNUM + i,
				  regs + (32 * 4) + (i * 8));
	}

      if (regnum == SPARC64_FSR_REGNUM || regnum == -1)
	regcache_raw_collect (regcache, SPARC64_FSR_REGNUM,
			      regs + (32 * 4) + (16 * 8));
    }
@


1.3.6.3
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d1089 13
d1133 2
@


1.3.4.1
log
@Integrate SPARC and UltraSPARC targets.
* sparc-tdep.h (struct sparc32_frame_cache): Add pc_regnum and
npc_regnum members.
* sparc-tdep.c (sparc_unwind_pc): Rename from sparc32_unwind_pc.
Get register numbers for %pc from `struct gdbarch_tdep' instead of
using 32-bit specific constants.
(sparc_software_single_step): Get register numbers from %pc and
%npc from `struct gdbarch_tdep'.
(sparc_write_pc): Rename from sparc32_write_pc.  Get register
numbers from %pc and %npc from `struct gdbarch_tdep'.
(sparc32_gdbarch_init): Initialize TDEP->pc_regnum,
TDEP->npc_regnum and TDEP->plt_entry_size.  Set write_pc to
sparc_write_pc, set unwind_pc to sparc_unwind_pc.
* sparc64-tdep.h: Fix typo in multiple inclusion guard.  Include
"sparc-tdep.h".
(enum sparc_regnum): Remove.
(sparc_supply_rwindow, sparc_fill_rwindow): Remove prototypes.
(sparc64_init_abi): New prototype.
* sparc64-tdep.c: Include "inferior.h" and "sparc-tdep.h".
(struct gdbarch_tdep): Remove definition.
(SPARC64_NUM_REGS, SPARC64_NUM_PSEUDO_REGS): Use ARRAY_SIZE.
(sparc_breakpoint_from_pc, sparc64_unwind_pc,
sparc_unwind_dummy_id, sparc_extract_struct_value_address,
sparc_analyze_control_transfer, sparc_software_single_step,
sparc64_gdbarch_init, sparc_supply_rwindow, sparc_fill_rwindow,
_initialize_sparc64_tdep): Remove functions.
(sparc64_init_abi): New function.
* sparc64fbsd-tdep.c (sparc64fbsd_supply_reg): Call
sparc_supply_rwindow with correct number of arguments.
(sparc64fbsd_init_abi): Call sparc64_init_abi.
* sparcbsd-nat.c (store_inferior_registers): Call
sparc_collect_rwindow instead sparc_fill_rwindow.
* config/sparc/fbsd.mt (TDEPFILES): Add sparc-tdep.o and corelow.o.
* config/sparc/fbsd.mh (NATDEPFILES): Remove corelow.o.
* Makefile.in (sparc64_tdep_h): Add dependency on sparc-tdep.h.
(sparc64-tdep.o): Update dependencies.
@
text
@a29 1
#include "inferior.h"
a37 1
#include "sparc-tdep.h"
d166 8
d286 2
a287 1
#define SPARC64_NUM_REGS ARRAY_SIZE (sparc64_register_info)
d351 3
a353 1
#define SPARC64_NUM_PSEUDO_REGS ARRAY_SIZE (sparc64_pseudo_register_info)
d502 15
d569 6
d735 9
d1196 13
d1216 1
d1218 74
d1294 37
a1330 1
sparc64_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
d1332 2
a1333 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
d1335 8
a1342 2
  tdep->pc_regnum = SPARC64_PC_REGNUM;
  tdep->npc_regnum = SPARC64_NPC_REGNUM;
a1343 1
  /* This is what all the fuss is about.  */
d1347 1
d1357 1
d1359 2
a1362 2
  set_gdbarch_call_dummy_location (gdbarch, AT_ENTRY_POINT);
  set_gdbarch_push_dummy_code (gdbarch, NULL);
d1367 2
a1369 4
  set_gdbarch_return_value_on_stack
    (gdbarch, generic_return_value_on_stack_not);
  set_gdbarch_stabs_argument_has_addr
    (gdbarch, default_stabs_argument_has_addr);
d1373 22
d1396 104
a1499 1
  frame_base_set_default (gdbarch, &sparc64_frame_base);
@


1.3.4.2
log
@* sparc64-tdep.h (r_tstate_offset): New define.
(sparc64_supply_gregset, sparc64_collect_gregset,
sparc64_supply_fpregset, sparc64_collect_fpregset): New
prototypes.
(sparc64_sol2_gregset): New extern declaration.
(sparc64_sol2_init_abi): New prototype.
* sparc64-tdep.c: Include "symtab.h" and "objfiles.h".  Don't
include "sparc-tdep.h".
(X_RD, X_I): New macros.
(sparc64_analyze_prologue): Sync with implementation in
sparc-tdep.c.
(TSTATE_CWP, TSTATE_ICC, TSTATE_XCC): New macros.
(PSR_S, PSR_ICC, PSR_VERS, PSR_IMPL, PSR_V8PLUS, PSR_XCC): New
macros.
(sparc64_supply_gregset, sparc64_collect_gregset,
sparc64_supply_fpregset, sparc64_collect_fpregset): New functions.
* sparc64-nat.c: New file.
* sparc64-sol2-nat.c: New file.
* sparc64-sol2-tdep.c: New file.
* sparc64-linux-nat.c: New file.
* sparc64-linux-tdep.c: New file.
* Makefile.in (sparc_tdep_h): New variable.
(ALLDEPFILES): Add sparc64-sol2-tdep.c, sparc64-linux-tdep.c,
sparc64-nat.c sparc64-sol2-nat.c and sparc64-linux-nat.c
(sparc-nat.o, sparc-linux-tdep.o, sparc64-tdep.o): Update
dependencies.
(sparc64-nat.o, sparc64-linux-nat.o, sparc64-linux-tdep.o,
sparc64-sol2-nat.o, sparc64-sol2-tdep.o): New dependencies.
* configure.tgt: Add sparc64-*-linux*.
* configure.host: Add sparc64-*-linux*.
* config/sparc/linux64.mt: New file.
* config/sparc/linux64.mh: New file.
@
text
@a30 2
#include "symtab.h"
#include "objfiles.h"
d39 1
a58 1
#define X_RD(i) (((i) >> 25) & 0x1f)
a63 1
#define X_I(i) (((i) >> 13) & 1)
a528 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
a529 2
  int offset = 0;
  int dest = -1;
d534 1
a534 13
  /* We have to handle to "Procedure Linkage Table" (PLT) special.  On
     SPARC the linker usually defines a symbol (typically
     _PROCEDURE_LINKAGE_TABLE_) at the start of the .plt section.
     This symbol makes us end up here with PC pointing at the start of
     the PLT and CURRENT_PC probably pointing at a PLT entry.  If we
     would do our normal prologue analysis, we would probably conclude
     that we've got a frame when in reality we don't, since the
     dynamic linker patches up the first PLT with some code that
     starts with a SAVE instruction.  Patch up PC such that it points
     at the start of our PLT entry.  */
  if (tdep->plt_entry_size > 0 && in_plt_section (current_pc, NULL))
    pc = current_pc - ((current_pc - pc) % tdep->plt_entry_size);

a535 20

  /* Recognize a SETHI insn and record its destination.  */
  if (X_OP (insn) == 0 && X_OP2 (insn) == 0x04)
    {
      dest = X_RD (insn);
      offset += 4;

      insn = sparc_fetch_instruction (pc + 4);
    }

  /* Allow for an arithmetic operation on DEST or %g1.  */
  if (X_OP (insn) == 2 && X_I (insn)
      && (X_RD (insn) == 1 || X_RD (insn) == dest))
    {
      offset += 4;

      insn = sparc_fetch_instruction (pc + 8);
    }

  /* Check for the SAVE instruction that sets up the frame.  */
d539 1
a539 1
      return pc + offset + 4;
a1205 295
}


/* Helper functions for dealing with register sets.  */

#define TSTATE_CWP	0x000000000000001f
#define TSTATE_ICC	0x0000000f00000000
#define TSTATE_XCC	0x000000f000000000

#define PSR_S		0x00000080
#define PSR_ICC		0x00f00000
#define PSR_VERS	0x0f000000
#define PSR_IMPL	0xf0000000
#define PSR_V8PLUS	0xff000000
#define PSR_XCC		0x000f0000

void
sparc64_supply_gregset (const struct sparc_gregset *gregset,
			struct regcache *regcache,
			int regnum, const void *gregs)
{
  int sparc32 = (gdbarch_ptr_bit (current_gdbarch) == 32);
  const char *regs = gregs;
  int i;

  if (sparc32)
    {
      if (regnum == SPARC32_PSR_REGNUM || regnum == -1)
	{
	  int offset = gregset->r_tstate_offset;
	  ULONGEST tstate, psr;
	  char buf[4];

	  tstate = extract_unsigned_integer (regs + offset, 8);
	  psr = ((tstate & TSTATE_CWP) | PSR_S | ((tstate & TSTATE_ICC) >> 12)
		 | ((tstate & TSTATE_XCC) >> 20) | PSR_V8PLUS);
	  store_unsigned_integer (buf, 4, psr);
	  regcache_raw_supply (regcache, SPARC32_PSR_REGNUM, buf);
	}

      if (regnum == SPARC32_PC_REGNUM || regnum == -1)
	regcache_raw_supply (regcache, SPARC32_PC_REGNUM,
			     regs + gregset->r_pc_offset + 4);

      if (regnum == SPARC32_NPC_REGNUM || regnum == -1)
	regcache_raw_supply (regcache, SPARC32_NPC_REGNUM,
			     regs + gregset->r_npc_offset + 4);

      if (regnum == SPARC32_Y_REGNUM || regnum == -1)
	{
	  int offset = gregset->r_y_offset + 8 - gregset->r_y_size;
	  regcache_raw_supply (regcache, SPARC32_Y_REGNUM, regs + offset);
	}
    }
  else
    {
      if (regnum == SPARC64_STATE_REGNUM || regnum == -1)
	regcache_raw_supply (regcache, SPARC64_STATE_REGNUM,
			     regs + gregset->r_tstate_offset);

      if (regnum == SPARC64_PC_REGNUM || regnum == -1)
	regcache_raw_supply (regcache, SPARC64_PC_REGNUM,
			     regs + gregset->r_pc_offset);

      if (regnum == SPARC64_NPC_REGNUM || regnum == -1)
	regcache_raw_supply (regcache, SPARC64_NPC_REGNUM,
			     regs + gregset->r_npc_offset);

      if (regnum == SPARC64_Y_REGNUM || regnum == -1)
	{
	  char buf[8];

	  memset (buf, 0, 8);
	  memcpy (buf + 8 - gregset->r_y_size,
		  regs + gregset->r_y_offset, gregset->r_y_size);
	  regcache_raw_supply (regcache, SPARC64_Y_REGNUM, buf);
	}
    }

  if (regnum == SPARC_G0_REGNUM || regnum == -1)
    regcache_raw_supply (regcache, SPARC_G0_REGNUM, NULL);

  if ((regnum >= SPARC_G1_REGNUM && regnum <= SPARC_O7_REGNUM) || regnum == -1)
    {
      int offset = gregset->r_g1_offset;

      if (sparc32)
	offset += 4;

      for (i = SPARC_G1_REGNUM; i <= SPARC_O7_REGNUM; i++)
	{
	  if (regnum == i || regnum == -1)
	    regcache_raw_supply (regcache, i, regs + offset);
	  offset += 8;
	}
    }

  if ((regnum >= SPARC_L0_REGNUM && regnum <= SPARC_I7_REGNUM) || regnum == -1)
    {
      /* Not all of the register set variants include Locals and
         Inputs.  For those that don't, we read them off the stack.  */
      if (gregset->r_l0_offset == -1)
	{
	  ULONGEST sp;

	  regcache_cooked_read_unsigned (regcache, SPARC_SP_REGNUM, &sp);
	  sparc_supply_rwindow (regcache, sp, regnum);
	}
      else
	{
	  int offset = gregset->r_l0_offset;

	  if (sparc32)
	    offset += 4;

	  for (i = SPARC_L0_REGNUM; i <= SPARC_I7_REGNUM; i++)
	    {
	      if (regnum == i || regnum == -1)
		regcache_raw_supply (regcache, i, regs + offset);
	      offset += 8;
	    }
	}
    }
}

void
sparc64_collect_gregset (const struct sparc_gregset *gregset,
			 const struct regcache *regcache,
			 int regnum, void *gregs)
{
  int sparc32 = (gdbarch_ptr_bit (current_gdbarch) == 32);
  char *regs = gregs;
  int i;

  if (sparc32)
    {
      if (regnum == SPARC32_PSR_REGNUM || regnum == -1)
	{
	  int offset = gregset->r_tstate_offset;
	  ULONGEST tstate, psr;
	  char buf[8];

	  tstate = extract_unsigned_integer (regs + offset, 8);
	  regcache_raw_collect (regcache, SPARC32_PSR_REGNUM, buf);
	  psr = extract_unsigned_integer (buf, 4);
	  tstate |= (psr & PSR_ICC) << 12;
	  if ((psr & (PSR_VERS | PSR_IMPL)) == PSR_V8PLUS)
	    tstate |= (psr & PSR_XCC) << 20;
	  store_unsigned_integer (buf, 8, tstate);
	  memcpy (regs + offset, buf, 8);
	}

      if (regnum == SPARC32_PC_REGNUM || regnum == -1)
	regcache_raw_collect (regcache, SPARC32_PC_REGNUM,
			      regs + gregset->r_pc_offset + 4);

      if (regnum == SPARC32_NPC_REGNUM || regnum == -1)
	regcache_raw_collect (regcache, SPARC32_NPC_REGNUM,
			      regs + gregset->r_npc_offset + 4);

      if (regnum == SPARC32_Y_REGNUM || regnum == -1)
	{
	  int offset = gregset->r_y_offset + 8 - gregset->r_y_size;
	  regcache_raw_collect (regcache, SPARC32_Y_REGNUM, regs + offset);
	}
    }
  else
    {
      if (regnum == SPARC64_STATE_REGNUM || regnum == -1)
	regcache_raw_collect (regcache, SPARC64_STATE_REGNUM,
			      regs + gregset->r_tstate_offset);

      if (regnum == SPARC64_PC_REGNUM || regnum == -1)
	regcache_raw_collect (regcache, SPARC64_PC_REGNUM,
			      regs + gregset->r_pc_offset);

      if (regnum == SPARC64_NPC_REGNUM || regnum == -1)
	regcache_raw_collect (regcache, SPARC64_NPC_REGNUM,
			      regs + gregset->r_npc_offset);

      if (regnum == SPARC64_Y_REGNUM || regnum == -1)
	{
	  char buf[8];

	  regcache_raw_collect (regcache, SPARC64_Y_REGNUM, buf);
	  memcpy (regs + gregset->r_y_offset,
		  buf + 8 - gregset->r_y_size, gregset->r_y_size);
	}
    }

  if ((regnum >= SPARC_G1_REGNUM && regnum <= SPARC_O7_REGNUM) || regnum == -1)
    {
      int offset = gregset->r_g1_offset;

      if (sparc32)
	offset += 4;

      /* %g0 is always zero.  */
      for (i = SPARC_G1_REGNUM; i <= SPARC_O7_REGNUM; i++)
	{
	  if (regnum == i || regnum == -1)
	    regcache_raw_collect (regcache, i, regs + offset);
	  offset += 8;
	}
    }

  if ((regnum >= SPARC_L0_REGNUM && regnum <= SPARC_I7_REGNUM) || regnum == -1)
    {
      /* Not all of the register set variants include Locals and
         Inputs.  For those that don't, we read them off the stack.  */
      if (gregset->r_l0_offset != -1)
	{
	  int offset = gregset->r_l0_offset;

	  if (sparc32)
	    offset += 4;

	  for (i = SPARC_L0_REGNUM; i <= SPARC_I7_REGNUM; i++)
	    {
	      if (regnum == i || regnum == -1)
		regcache_raw_collect (regcache, i, regs + offset);
	      offset += 8;
	    }
	}
    }
}

void
sparc64_supply_fpregset (struct regcache *regcache,
			 int regnum, const void *fpregs)
{
  int sparc32 = (gdbarch_ptr_bit (current_gdbarch) == 32);
  const char *regs = fpregs;
  int i;

  for (i = 0; i < 32; i++)
    {
      if (regnum == (SPARC_F0_REGNUM + i) || regnum == -1)
	regcache_raw_supply (regcache, SPARC_F0_REGNUM + i, regs + (i * 4));
    }

  if (sparc32)
    {
      if (regnum == SPARC32_FSR_REGNUM || regnum == -1)
	regcache_raw_supply (regcache, SPARC32_FSR_REGNUM,
			     regs + (32 * 4) + (16 * 8) + 4);
    }
  else
    {
      for (i = 0; i < 16; i++)
	{
	  if (regnum == (SPARC64_F32_REGNUM + i) || regnum == -1)
	    regcache_raw_supply (regcache, SPARC64_F32_REGNUM + i,
				 regs + (32 * 4) + (i * 8));
	}

      if (regnum == SPARC64_FSR_REGNUM || regnum == -1)
	regcache_raw_supply (regcache, SPARC64_FSR_REGNUM,
			     regs + (32 * 4) + (16 * 8));
    }
}

void
sparc64_collect_fpregset (const struct regcache *regcache,
			  int regnum, void *fpregs)
{
  int sparc32 = (gdbarch_ptr_bit (current_gdbarch) == 32);
  char *regs = fpregs;
  int i;

  for (i = 0; i < 32; i++)
    {
      if (regnum == (SPARC_F0_REGNUM + i) || regnum == -1)
	regcache_raw_collect (regcache, SPARC_F0_REGNUM + i, regs + (i * 4));
    }

  if (sparc32)
    {
      if (regnum == SPARC32_FSR_REGNUM || regnum == -1)
	regcache_raw_collect (regcache, SPARC32_FSR_REGNUM,
			      regs + (32 * 4) + (16 * 8) + 4);
    }
  else
    {
      for (i = 0; i < 16; i++)
	{
	  if (regnum == (SPARC64_F32_REGNUM + i) || regnum == -1)
	    regcache_raw_collect (regcache, SPARC64_F32_REGNUM + i,
				  regs + (32 * 4) + (i * 8));
	}

      if (regnum == SPARC64_FSR_REGNUM || regnum == -1)
	regcache_raw_collect (regcache, SPARC64_FSR_REGNUM,
			      regs + (32 * 4) + (16 * 8));
    }
@


1.3.4.3
log
@* sparc-tdep.c (sparc32_frame_cache): Use
frame_unwind_address_in_block to obtain the current PC for use in
call to sparc32_analyze_prologue.
* sparc64-tdep.c (sparc64_frame_cache): Likewise.
@
text
@d630 1
a630 4
    {
      CORE_ADDR addr_in_block = frame_unwind_address_in_block (next_frame);
      sparc64_analyze_prologue (cache->pc, addr_in_block, cache);
    }
@


1.3.4.4
log
@* sparc-tdep.h (struct sparc_frame_cache): Rename from `struct
sparc32_frame_cache'.
(sparc_analyze_prologue, sparc_frame_cache): New prototypes.
(sparc32_frame_cache): Adjust prototype.
* sparc-tdep.c (sparc_alloc_frame_cache): Rename from
sparc32_alloc_frame_cache.  Use `struct sparc_frame_cache' instead
of `struct sparc32_frame_cache'.
(sparc_analyze_prologue): Rename from sparc32_analyze_prologue.
Use `struct sparc_frame_cache' instead of `struct
sparc32_frame_cache'.
(sparc32_skip_prologue): Use `struct sparc_frame_cache' instead of
`struct sparc32_frame_cache'.  Call sparc_analyze_prologue instead
of sparc32_analyze_prologue.
(sparc_frame_cache): New function with generic code from...
(sparc32_frame_cache): ...here.
(sparc32_frame_this_id, sparc32_frame_prev_register)
(sparc32_frame_base_address): Use `struct sparc_frame_cache'
instead of `struct sparc32_frame_cache'.
* sparc-sol2-tdep.c (sparc32_sol2_sigtramp_frame_cache)
(sparc32_sol2_sigtramp_frame_this_id)
(sparc32_sol2_sigtramp_frame_prev_register): Change return type to
`struct sparc_frame_cache *'.
* sparc-linux-tdep.c (sparc32_linux_sigtramp_frame_cache)
(sparc32_linux_sigtramp_frame_this_id)
(sparc32_linux_sigtramp_frame_prev_register): Change return type
to `struct sparc_frame_cache *'.
* sparc64-tdep.c (X_OP, X_RD, X_A, X_COND, X_OP2, X_IMM22, X_OP3)
(X_I, X_DISP22, X_DISP19): Remove macros.
(struct sparc64_frame_cache): Remove.
(sparc64_alloc_frame_cache, sparc64_analyze_prologue): Remove
functions.
(sparc64_skip_prologue): Use `struct sparc_frame_cache' instead of
`struct sparc64_frame_cache.  Call sparc_analyze_prologue instead
of sparc64_analuze_prologue.
(sparc64_frame_this_id, sparc64_frame_prev_register,
sparc64_frame_base_address): Use `struct sparc_frame_cache'
instead of `struct sparc64_frame_cache.
(sparc64_frame_cache): Change return type to `struct
sparc_frame_cache *'.  Simply call sparc_frame_cache.
@
text
@d498 85
d591 1
a591 1
  struct sparc_frame_cache cache;
d604 1
a604 1
  return sparc_analyze_prologue (start_pc, 0xffffffffffffffffUL, &cache);
d609 1
a609 1
static struct sparc_frame_cache *
d612 32
a643 1
  return sparc_frame_cache (next_frame, this_cache);
d650 1
a650 1
  struct sparc_frame_cache *cache =
d666 1
a666 1
  struct sparc_frame_cache *cache =
d732 1
a732 1
  struct sparc_frame_cache *cache =
@


1.3.4.5
log
@* sparc64-nat.c (sparc64_gregset_supplies_p): Return non-zero if
REGNUM is SPARC64_FPRS_REGNUM.
* sparc64-tdep.c (sparc64_supply_gregset): Deal with
SPARC64_FPRS_REGNUM.
(sparc64_collect_gregset): Likewise.
* sparc64-tdep.h (r_fprs_offset): New define.
(sparc64fbsd_gregset): Add define.
(sparc64fbsd_supply_reg, sparc64fbsd_fill_reg)
(sparc64fbsd_supply_fpreg, sparc64fbsd_fill_fpreg): Remove
declarations.
* sparc64fbsd-nat.c (sparc64fbsd_reg_supplies_p)
(sparc64fbsd_fpreg_supplies_p): Remove functions.
(_initialize_sparc64fbsd_nat): Remove initialization of
sparcbsd_supply_reg, sparcbsd_fill_reg, sparcbsd_supply_fpreg,
sparcbsd_fill_fpreg, sparcbsd_reg_supplies_p,
sparcbsd_fpreg_supplies_p.  Initialize sparc_gregset.
* sparc64fbsd-tdep.c (sparc64fbsd_gregset): New variable.
(sparc64fbsd_r_global_offset, sparc64fbsd_r_out_offset)
(sparc64fbsd_r_fprs_offset, sparc64fbsd_r_tnpc_offset)
(sparc64fbsd_r_tpc_offset, sparc64fbsd_r_tstate_offset)
(sparc64fbsd_r_y_offset): Remove variables.
(sparc64fbsd_sizeof_struct_reg, sparc64fbsd_sizeof_struct_fpreg):
Make static and const.
(sparc64fbsd_supply_reg, sparc64fbsd_fill_reg)
(sparc64fbsd_supply_fpreg, sparc64fbsd_fill_fpreg): Remove
functions.
(fetch_core_registers): Replace calls to sparc64fbsd_supply_reg
and sparc64fbsd_supply_fpreg with calls to sparc64_supply_gregset
and sparc64_supply_fpregset.
* Makefile.in (sparc64fbsd-nat.o): Update dependencies.
* config/sparc/fbsd.mh (NATDEPFILES): Remove sparcbsd-nat.o.  Add
sparc64-nat.o and sparc-nat.o.
@
text
@a1207 5

      if ((regnum == SPARC64_FPRS_REGNUM || regnum == -1)
	  && gregset->r_fprs_offset != -1)
	regcache_raw_supply (regcache, SPARC64_FPRS_REGNUM,
			     regs + gregset->r_fprs_offset);
a1318 6

      if ((regnum == SPARC64_FPRS_REGNUM || regnum == -1)
	  && gregset->r_fprs_offset != -1)
	regcache_raw_collect (regcache, SPARC64_FPRS_REGNUM,
			      regs + gregset->r_fprs_offset);

@


1.3.4.6
log
@* sparc64-tdep.c (BIAS): Remove define.
* sparc64-sol2-tdep.c (BIAS): Remove define.
* sparc64fbsd-tdep.c: Likewise.
@
text
@d52 6
@


1.3.4.7
log
@* sparc-tdep.h: Update copyright year.
(sparc_fetch_instruction): New prototype.
* sparc-tdep.c: Update copyright year.
(sparc_fetch_instruction): Make global.
* sparc64-tdep.c: Update copyright year.
(sparc_fetch_instruction): Remove function.
(X_OP, X_RD, X_A, X_COND, X_OP2, X_IMM22, X_OP3, X_I, X_DISP22)
(X_DISP19): Really remove macros.
* sparc64-sol2-tdep.c: Update copyright year.
* sparc64fbsd-tdep.c: Likewise.
@
text
@d3 1
a3 1
   Copyright 2003, 2004 Free Software Foundation, Inc.
d51 31
@


1.3.2.1
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@@


1.3.2.2
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d3 1
a3 1
   Copyright 2003, 2004 Free Software Foundation, Inc.
a29 3
#include "inferior.h"
#include "symtab.h"
#include "objfiles.h"
d48 35
d166 8
d286 2
a287 1
#define SPARC64_NUM_REGS ARRAY_SIZE (sparc64_register_info)
d351 3
a353 1
#define SPARC64_NUM_PSEUDO_REGS ARRAY_SIZE (sparc64_pseudo_register_info)
d502 15
d519 56
d583 1
a583 1
  struct sparc_frame_cache cache;
d596 1
a596 1
  return sparc_analyze_prologue (start_pc, 0xffffffffffffffffULL, &cache);
d601 1
a601 1
static struct sparc_frame_cache *
d604 29
a632 1
  return sparc_frame_cache (next_frame, this_cache);
d639 1
a639 1
  struct sparc_frame_cache *cache =
d655 1
a655 1
  struct sparc_frame_cache *cache =
d721 1
a721 1
  struct sparc_frame_cache *cache =
d735 9
d758 2
a759 6
	{
	  struct type *subtype = check_typedef (TYPE_FIELD_TYPE (type, i));

	  if (sparc64_16_byte_align_p (subtype))
	    return 1;
	}
d811 3
a813 24
	{
	  struct type *subtype = check_typedef (TYPE_FIELD_TYPE (type, i));
	  int subpos = bitpos + TYPE_FIELD_BITPOS (type, i);

	  sparc64_store_floating_fields (regcache, subtype, valbuf,
					 element, subpos);
	}

      /* GCC has an interesting bug.  If TYPE is a structure that has
         a single `float' member, GCC doesn't treat it as a structure
         at all, but rather as an ordinary `float' argument.  This
         argument will be stored in %f1, as required by the psABI.
         However, as a member of a structure the psABI requires it to
         be stored in %f0.  This bug is present in GCC 3.3.2, but
         probably in older releases to.  To appease GCC, if a
         structure has only a single `float' member, we store its
         value in %f1 too (we already have stored in %f0).  */
      if (TYPE_NFIELDS (type) == 1)
	{
	  struct type *subtype = check_typedef (TYPE_FIELD_TYPE (type, 0));

	  if (sparc64_floating_p (subtype) && TYPE_LENGTH (subtype) == 4)
	    regcache_cooked_write (regcache, SPARC_F1_REGNUM, valbuf);
	}
d859 3
a861 6
	{
	  struct type *subtype = check_typedef (TYPE_FIELD_TYPE (type, i));
	  int subpos = bitpos + TYPE_FIELD_BITPOS (type, i);

	  sparc64_extract_floating_fields (regcache, subtype, valbuf, subpos);
	}
d1037 1
a1037 2
	      memcpy (buf + 4, valbuf, 4);
	      valbuf = buf;
d1040 1
a1040 1
		regnum = SPARC64_D0_REGNUM + element;
d1173 1
a1173 1
	regcache_cooked_write (regcache, SPARC_O0_REGNUM + i, buf + i * 8);
d1196 3
a1198 12
static enum return_value_convention
sparc64_return_value (struct gdbarch *gdbarch, struct type *type,
		      struct regcache *regcache, void *readbuf,
		      const void *writebuf)
{
  if (TYPE_LENGTH (type) > 32)
    return RETURN_VALUE_STRUCT_CONVENTION;

  if (readbuf)
    sparc64_extract_return_value (type, regcache, readbuf);
  if (writebuf)
    sparc64_store_return_value (type, regcache, writebuf);
d1200 7
a1206 1
  return RETURN_VALUE_REGISTER_CONVENTION;
d1208 9
d1218 74
d1294 37
a1330 1
sparc64_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
d1332 2
a1333 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
d1335 8
a1342 2
  tdep->pc_regnum = SPARC64_PC_REGNUM;
  tdep->npc_regnum = SPARC64_NPC_REGNUM;
a1343 1
  /* This is what all the fuss is about.  */
d1347 1
d1357 1
d1359 2
a1362 2
  set_gdbarch_call_dummy_location (gdbarch, AT_ENTRY_POINT);
  set_gdbarch_push_dummy_code (gdbarch, NULL);
d1365 5
a1369 3
  set_gdbarch_return_value (gdbarch, sparc64_return_value);
  set_gdbarch_stabs_argument_has_addr
    (gdbarch, default_stabs_argument_has_addr);
d1373 2
a1374 4
  frame_unwind_append_sniffer (gdbarch, sparc64_frame_sniffer);
  frame_base_set_default (gdbarch, &sparc64_frame_base);
}

d1376 3
a1378 1
/* Helper functions for dealing with register sets.  */
d1380 1
a1380 10
#define TSTATE_CWP	0x000000000000001fULL
#define TSTATE_ICC	0x0000000f00000000ULL
#define TSTATE_XCC	0x000000f000000000ULL

#define PSR_S		0x00000080
#define PSR_ICC		0x00f00000
#define PSR_VERS	0x0f000000
#define PSR_IMPL	0xf0000000
#define PSR_V8PLUS	0xff000000
#define PSR_XCC		0x000f0000
d1382 1
a1382 8
void
sparc64_supply_gregset (const struct sparc_gregset *gregset,
			struct regcache *regcache,
			int regnum, const void *gregs)
{
  int sparc32 = (gdbarch_ptr_bit (current_gdbarch) == 32);
  const char *regs = gregs;
  int i;
d1384 1
a1384 7
  if (sparc32)
    {
      if (regnum == SPARC32_PSR_REGNUM || regnum == -1)
	{
	  int offset = gregset->r_tstate_offset;
	  ULONGEST tstate, psr;
	  char buf[4];
d1386 1
a1386 6
	  tstate = extract_unsigned_integer (regs + offset, 8);
	  psr = ((tstate & TSTATE_CWP) | PSR_S | ((tstate & TSTATE_ICC) >> 12)
		 | ((tstate & TSTATE_XCC) >> 20) | PSR_V8PLUS);
	  store_unsigned_integer (buf, 4, psr);
	  regcache_raw_supply (regcache, SPARC32_PSR_REGNUM, buf);
	}
d1388 1
a1388 3
      if (regnum == SPARC32_PC_REGNUM || regnum == -1)
	regcache_raw_supply (regcache, SPARC32_PC_REGNUM,
			     regs + gregset->r_pc_offset + 4);
d1390 1
a1390 3
      if (regnum == SPARC32_NPC_REGNUM || regnum == -1)
	regcache_raw_supply (regcache, SPARC32_NPC_REGNUM,
			     regs + gregset->r_npc_offset + 4);
d1392 2
a1393 11
      if (regnum == SPARC32_Y_REGNUM || regnum == -1)
	{
	  int offset = gregset->r_y_offset + 8 - gregset->r_y_size;
	  regcache_raw_supply (regcache, SPARC32_Y_REGNUM, regs + offset);
	}
    }
  else
    {
      if (regnum == SPARC64_STATE_REGNUM || regnum == -1)
	regcache_raw_supply (regcache, SPARC64_STATE_REGNUM,
			     regs + gregset->r_tstate_offset);
d1395 1
a1395 3
      if (regnum == SPARC64_PC_REGNUM || regnum == -1)
	regcache_raw_supply (regcache, SPARC64_PC_REGNUM,
			     regs + gregset->r_pc_offset);
d1397 4
a1400 3
      if (regnum == SPARC64_NPC_REGNUM || regnum == -1)
	regcache_raw_supply (regcache, SPARC64_NPC_REGNUM,
			     regs + gregset->r_npc_offset);
d1402 6
a1407 9
      if (regnum == SPARC64_Y_REGNUM || regnum == -1)
	{
	  char buf[8];

	  memset (buf, 0, 8);
	  memcpy (buf + 8 - gregset->r_y_size,
		  regs + gregset->r_y_offset, gregset->r_y_size);
	  regcache_raw_supply (regcache, SPARC64_Y_REGNUM, buf);
	}
d1409 1
a1409 10
      if ((regnum == SPARC64_FPRS_REGNUM || regnum == -1)
	  && gregset->r_fprs_offset != -1)
	regcache_raw_supply (regcache, SPARC64_FPRS_REGNUM,
			     regs + gregset->r_fprs_offset);
    }

  if (regnum == SPARC_G0_REGNUM || regnum == -1)
    regcache_raw_supply (regcache, SPARC_G0_REGNUM, NULL);

  if ((regnum >= SPARC_G1_REGNUM && regnum <= SPARC_O7_REGNUM) || regnum == -1)
d1411 2
a1412 4
      int offset = gregset->r_g1_offset;

      if (sparc32)
	offset += 4;
d1414 1
a1414 1
      for (i = SPARC_G1_REGNUM; i <= SPARC_O7_REGNUM; i++)
d1417 4
a1420 2
	    regcache_raw_supply (regcache, i, regs + offset);
	  offset += 8;
d1423 5
d1429 3
a1431 5
  if ((regnum >= SPARC_L0_REGNUM && regnum <= SPARC_I7_REGNUM) || regnum == -1)
    {
      /* Not all of the register set variants include Locals and
         Inputs.  For those that don't, we read them off the stack.  */
      if (gregset->r_l0_offset == -1)
d1433 3
a1435 1
	  ULONGEST sp;
d1437 1
a1437 4
	  regcache_cooked_read_unsigned (regcache, SPARC_SP_REGNUM, &sp);
	  sparc_supply_rwindow (regcache, sp, regnum);
	}
      else
d1439 1
a1439 6
	  int offset = gregset->r_l0_offset;

	  if (sparc32)
	    offset += 4;

	  for (i = SPARC_L0_REGNUM; i <= SPARC_I7_REGNUM; i++)
d1441 3
a1443 3
	      if (regnum == i || regnum == -1)
		regcache_raw_supply (regcache, i, regs + offset);
	      offset += 8;
d1450 1
a1450 3
sparc64_collect_gregset (const struct sparc_gregset *gregset,
			 const struct regcache *regcache,
			 int regnum, void *gregs)
d1452 2
a1453 2
  int sparc32 = (gdbarch_ptr_bit (current_gdbarch) == 32);
  char *regs = gregs;
d1456 1
a1456 1
  if (sparc32)
d1458 2
a1459 5
      if (regnum == SPARC32_PSR_REGNUM || regnum == -1)
	{
	  int offset = gregset->r_tstate_offset;
	  ULONGEST tstate, psr;
	  char buf[8];
d1461 1
a1461 19
	  tstate = extract_unsigned_integer (regs + offset, 8);
	  regcache_raw_collect (regcache, SPARC32_PSR_REGNUM, buf);
	  psr = extract_unsigned_integer (buf, 4);
	  tstate |= (psr & PSR_ICC) << 12;
	  if ((psr & (PSR_VERS | PSR_IMPL)) == PSR_V8PLUS)
	    tstate |= (psr & PSR_XCC) << 20;
	  store_unsigned_integer (buf, 8, tstate);
	  memcpy (regs + offset, buf, 8);
	}

      if (regnum == SPARC32_PC_REGNUM || regnum == -1)
	regcache_raw_collect (regcache, SPARC32_PC_REGNUM,
			      regs + gregset->r_pc_offset + 4);

      if (regnum == SPARC32_NPC_REGNUM || regnum == -1)
	regcache_raw_collect (regcache, SPARC32_NPC_REGNUM,
			      regs + gregset->r_npc_offset + 4);

      if (regnum == SPARC32_Y_REGNUM || regnum == -1)
d1463 5
a1467 2
	  int offset = gregset->r_y_offset + 8 - gregset->r_y_size;
	  regcache_raw_collect (regcache, SPARC32_Y_REGNUM, regs + offset);
d1472 3
a1474 7
      if (regnum == SPARC64_STATE_REGNUM || regnum == -1)
	regcache_raw_collect (regcache, SPARC64_STATE_REGNUM,
			      regs + gregset->r_tstate_offset);

      if (regnum == SPARC64_PC_REGNUM || regnum == -1)
	regcache_raw_collect (regcache, SPARC64_PC_REGNUM,
			      regs + gregset->r_pc_offset);
d1476 3
a1478 3
      if (regnum == SPARC64_NPC_REGNUM || regnum == -1)
	regcache_raw_collect (regcache, SPARC64_NPC_REGNUM,
			      regs + gregset->r_npc_offset);
d1480 1
a1480 1
      if (regnum == SPARC64_Y_REGNUM || regnum == -1)
d1482 1
a1482 42
	  char buf[8];

	  regcache_raw_collect (regcache, SPARC64_Y_REGNUM, buf);
	  memcpy (regs + gregset->r_y_offset,
		  buf + 8 - gregset->r_y_size, gregset->r_y_size);
	}

      if ((regnum == SPARC64_FPRS_REGNUM || regnum == -1)
	  && gregset->r_fprs_offset != -1)
	regcache_raw_collect (regcache, SPARC64_FPRS_REGNUM,
			      regs + gregset->r_fprs_offset);

    }

  if ((regnum >= SPARC_G1_REGNUM && regnum <= SPARC_O7_REGNUM) || regnum == -1)
    {
      int offset = gregset->r_g1_offset;

      if (sparc32)
	offset += 4;

      /* %g0 is always zero.  */
      for (i = SPARC_G1_REGNUM; i <= SPARC_O7_REGNUM; i++)
	{
	  if (regnum == i || regnum == -1)
	    regcache_raw_collect (regcache, i, regs + offset);
	  offset += 8;
	}
    }

  if ((regnum >= SPARC_L0_REGNUM && regnum <= SPARC_I7_REGNUM) || regnum == -1)
    {
      /* Not all of the register set variants include Locals and
         Inputs.  For those that don't, we read them off the stack.  */
      if (gregset->r_l0_offset != -1)
	{
	  int offset = gregset->r_l0_offset;

	  if (sparc32)
	    offset += 4;

	  for (i = SPARC_L0_REGNUM; i <= SPARC_I7_REGNUM; i++)
d1484 3
a1486 3
	      if (regnum == i || regnum == -1)
		regcache_raw_collect (regcache, i, regs + offset);
	      offset += 8;
d1491 1
d1493 2
a1494 34
void
sparc64_supply_fpregset (struct regcache *regcache,
			 int regnum, const void *fpregs)
{
  int sparc32 = (gdbarch_ptr_bit (current_gdbarch) == 32);
  const char *regs = fpregs;
  int i;

  for (i = 0; i < 32; i++)
    {
      if (regnum == (SPARC_F0_REGNUM + i) || regnum == -1)
	regcache_raw_supply (regcache, SPARC_F0_REGNUM + i, regs + (i * 4));
    }

  if (sparc32)
    {
      if (regnum == SPARC32_FSR_REGNUM || regnum == -1)
	regcache_raw_supply (regcache, SPARC32_FSR_REGNUM,
			     regs + (32 * 4) + (16 * 8) + 4);
    }
  else
    {
      for (i = 0; i < 16; i++)
	{
	  if (regnum == (SPARC64_F32_REGNUM + i) || regnum == -1)
	    regcache_raw_supply (regcache, SPARC64_F32_REGNUM + i,
				 regs + (32 * 4) + (i * 8));
	}

      if (regnum == SPARC64_FSR_REGNUM || regnum == -1)
	regcache_raw_supply (regcache, SPARC64_FSR_REGNUM,
			     regs + (32 * 4) + (16 * 8));
    }
}
d1497 1
a1497 2
sparc64_collect_fpregset (const struct regcache *regcache,
			  int regnum, void *fpregs)
d1499 1
a1499 29
  int sparc32 = (gdbarch_ptr_bit (current_gdbarch) == 32);
  char *regs = fpregs;
  int i;

  for (i = 0; i < 32; i++)
    {
      if (regnum == (SPARC_F0_REGNUM + i) || regnum == -1)
	regcache_raw_collect (regcache, SPARC_F0_REGNUM + i, regs + (i * 4));
    }

  if (sparc32)
    {
      if (regnum == SPARC32_FSR_REGNUM || regnum == -1)
	regcache_raw_collect (regcache, SPARC32_FSR_REGNUM,
			      regs + (32 * 4) + (16 * 8) + 4);
    }
  else
    {
      for (i = 0; i < 16; i++)
	{
	  if (regnum == (SPARC64_F32_REGNUM + i) || regnum == -1)
	    regcache_raw_collect (regcache, SPARC64_F32_REGNUM + i,
				  regs + (32 * 4) + (i * 8));
	}

      if (regnum == SPARC64_FSR_REGNUM || regnum == -1)
	regcache_raw_collect (regcache, SPARC64_FSR_REGNUM,
			      regs + (32 * 4) + (16 * 8));
    }
@


1.2
log
@* sparc64-tdep.h (sparc64_regnum): Fix comment.
(sparc64_supply_rwindow, sparc64_fill_rwindow): Remove prototypes.
(sparc_supply_rwindow, sparc_fill_rwindow): New prototypes.
* sparc64-tdep.c (sparc64_pseudo_register_read): Add missing
`case' keyword.
(sparc64_register_info): Give the reister with number
SPARC64_STATE_REGNUM a name.
(sparc64_pseudo_register_write): Add support for %cwp, %pstate,
%asi and %ccr.
(sparc64_push_dummy_call): Take BIAS into account when checking
stcak alignment.
(sparc_software_single_step): Remove assertions that check whether
NPC and NNPC were zero.
(sparc_supply_rwindow): Make public.  Merge functionality with
sparc64_supply_rwindow.
(sparc_fill_rwindow): Make public.  Merge functionality with
sparc64_fill_rwindow.
(sparc64_supply_rwindow, sparc64_fill_rwindow): Remove.
* sparc64fbsd-nat.c (_initialize_sparc64fbsd_nat): Set
SPARCBSD_FPREG_SUPPLIES_P to sparc64fbsd_fpreg_supplies_p.
* sparc64fbsd-tdep.c (sparc64fbsd_supply_reg): Call
sparc_supply_rwindow instead of sparc64_supply_rwindow.
@
text
@d1359 1
a1359 1
  set_gdbarch_npc_regnum (gdbarch, SPARC64_NPC_REGNUM);
@


1.1
log
@Rewrite FreeBSD/sparc64 native configuration.
* sparcbsd-nat.c, sparcbsd-nat.h: New files.
* sparc64fbsd-nat.c: New file.
* sparc64fbsd-tdep.c: New file.
* sparc64-tdep.c sparc64-tdep.h: New files.
* Makefile.in (sparcbsd-nat.o, sparc64fbsd-nat.o, sparc64-tdep.o,
sparc64fbsd-tdep.o): New dependencies.
(SFILES): Add sparcbsd-nat.c, sparc64fbsd-nat.c, sparc64-tdep.c
and sparc64fbsd-tdep.c.
(sparc64_tdep_h, sparcbsd_nat_h): New variables.
* config/sparc/fbsd.mh: Remove copyright notice.
(NATDEPFILES): Remove sparc-nat.o, add sparc64fbsd-nat.o and
sparcbsd-nat.o.
* config/sparc/fbsd.mt: Remove copyright notice.
(TDEPFILES): Remove sparc-tdep.o, solib.o solib-svr4.o,
solib-legacy.o.  Add sparc64-tdep.o and sparc64fbsd-tdep.o.
* config/sparc/nm-fbsd.h: Don't include "elf/common.h".
(SVR4_SHARED_LIBS, PTRACE_GETREGS, PTRACE_SETREGS,
PTRACE_GETFPREGS, PTRACE_SETFPREGS, GDB_GREGSET_T, GDB_FPREGSET_T,
regs, r_g1, r_ps, r_pc, r_npc, r_y, FPU_FSR_TYPE, fp_status, fpu,
fpu_regs, fp_fr, fpu_fsr, Fpu_fsr): Remove defines.
* config/sparc/tm-fbsd.h: Don't include "solib.h" and
"sparc/tm-sp64.h".
(SVR4_SHARED_LIBS, START_INFERIOR_TRAPS_EXPECTED): Remove defines.
(GDB_MULTI_ARCH): Define to GDB_MULTI_ARCH_TM.
@
text
@d274 2
a275 1
  { NULL, &builtin_type_int64 },
d426 1
a426 1
	SPARC64_CWP_REGNUM:
d429 1
a429 1
	SPARC64_PSTATE_REGNUM:
d432 1
a432 1
	SPARC64_ASI_REGNUM:
d435 1
a435 1
	SPARC64_CCR_REGNUM:
d475 26
d1101 1
a1101 1
  gdb_assert (sp % 16 == 0);
a1302 3
      gdb_assert (npc == 0);
      gdb_assert (nnpc == 0);

d1402 1
a1402 1
static void
a1408 22
  /* Clear out the top half of the temporary buffer, and put the
     register value in the bottom half if we're in 64-bit mode.  */
  if (gdbarch_ptr_bit (current_gdbarch) == 64)
    {
      memset (buf, 0, 4);
      offset = 4;
    }

  for (i = SPARC_L0_REGNUM; i <= SPARC_I7_REGNUM; i++)
    {
      if (regnum == i || regnum == -1)
	{
	  target_read_memory (sp + ((i - SPARC_L0_REGNUM) * 4),
			      buf + offset, 4);
	  supply_register (i, buf);
	}
    }
}

void
sparc64_supply_rwindow (CORE_ADDR sp, int regnum)
{
a1410 3
      char buf[8];
      int i;

d1418 1
a1418 2
	      target_read_memory (sp + ((i - SPARC_L0_REGNUM) * 8),
				  buf, sizeof (buf));
d1427 19
a1445 1
      sparc_supply_rwindow (sp & 0xffffffffUL, regnum);
d1449 1
a1449 1
static void
a1455 17
  /* Only use the bottom half if we're in 64-bit mode.  */
  if (gdbarch_ptr_bit (current_gdbarch) == 64)
    offset = 4;

  for (i = SPARC_L0_REGNUM; i <= SPARC_I7_REGNUM; i++)
    {
      if (regnum == -1 || regnum == SPARC_SP_REGNUM || regnum == i)
	{
	  regcache_collect (i, buf);
	  target_write_memory (sp + ((i - SPARC_L0_REGNUM) * 4), buf, 4);
	}
    }
}

void
sparc64_fill_rwindow (CORE_ADDR sp, int regnum)
{
a1457 3
      char buf[8];
      int i;

d1466 1
a1466 2
	      target_write_memory (sp + ((i - SPARC_L0_REGNUM) * 8),
				   buf, sizeof (buf));
d1474 15
a1488 1
      sparc_fill_rwindow (sp & 0xffffffffUL, regnum);
@

