head	1.233;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.232
	gdb_7_6-2013-04-26-release:1.232
	gdb_7_6-branch:1.232.0.2
	gdb_7_6-2013-03-12-branchpoint:1.232
	gdb_7_5_1-2012-11-29-release:1.227
	gdb_7_5-2012-08-17-release:1.227
	gdb_7_5-branch:1.227.0.2
	gdb_7_5-2012-07-18-branchpoint:1.227
	gdb_7_4_1-2012-04-26-release:1.223.2.1
	gdb_7_4-2012-01-24-release:1.223.2.1
	gdb_7_4-branch:1.223.0.2
	gdb_7_4-2011-12-13-branchpoint:1.223
	gdb_7_3_1-2011-09-04-release:1.219
	gdb_7_3-2011-07-26-release:1.219
	gdb_7_3-branch:1.219.0.2
	gdb_7_3-2011-04-01-branchpoint:1.219
	gdb_7_2-2010-09-02-release:1.213
	gdb_7_2-branch:1.213.0.2
	gdb_7_2-2010-07-07-branchpoint:1.213
	gdb_7_1-2010-03-18-release:1.211
	gdb_7_1-branch:1.211.0.2
	gdb_7_1-2010-02-18-branchpoint:1.211
	gdb_7_0_1-2009-12-22-release:1.209
	gdb_7_0-2009-10-06-release:1.209
	gdb_7_0-branch:1.209.0.2
	gdb_7_0-2009-09-16-branchpoint:1.209
	arc-sim-20090309:1.193
	msnyder-checkpoint-072509-branch:1.208.0.2
	msnyder-checkpoint-072509-branchpoint:1.208
	arc-insight_6_8-branch:1.193.0.6
	arc-insight_6_8-branchpoint:1.193
	insight_6_8-branch:1.193.0.4
	insight_6_8-branchpoint:1.193
	reverse-20081226-branch:1.200.0.6
	reverse-20081226-branchpoint:1.200
	multiprocess-20081120-branch:1.200.0.4
	multiprocess-20081120-branchpoint:1.200
	reverse-20080930-branch:1.200.0.2
	reverse-20080930-branchpoint:1.200
	reverse-20080717-branch:1.198.0.4
	reverse-20080717-branchpoint:1.198
	msnyder-reverse-20080609-branch:1.198.0.2
	msnyder-reverse-20080609-branchpoint:1.198
	drow-reverse-20070409-branch:1.178.0.2
	drow-reverse-20070409-branchpoint:1.178
	gdb_6_8-2008-03-27-release:1.193
	gdb_6_8-branch:1.193.0.2
	gdb_6_8-2008-02-26-branchpoint:1.193
	gdb_6_7_1-2007-10-29-release:1.185
	gdb_6_7-2007-10-10-release:1.185
	gdb_6_7-branch:1.185.0.2
	gdb_6_7-2007-09-07-branchpoint:1.185
	insight_6_6-20070208-release:1.174
	gdb_6_6-2006-12-18-release:1.174
	gdb_6_6-branch:1.174.0.2
	gdb_6_6-2006-11-15-branchpoint:1.174
	insight_6_5-20061003-release:1.172
	gdb-csl-symbian-6_4_50_20060226-12:1.168.2.1.2.1
	gdb-csl-sourcerygxx-3_4_4-25:1.165
	nickrob-async-20060828-mergepoint:1.173
	gdb-csl-symbian-6_4_50_20060226-11:1.168.2.1.2.1
	gdb-csl-sourcerygxx-4_1-17:1.168.2.1
	gdb-csl-20060226-branch-local-2:1.168.2.1
	gdb-csl-sourcerygxx-4_1-14:1.168.2.1
	gdb-csl-sourcerygxx-4_1-13:1.168.2.1
	gdb-csl-sourcerygxx-4_1-12:1.168.2.1
	gdb-csl-sourcerygxx-3_4_4-21:1.168.2.1
	gdb_6_5-20060621-release:1.172
	gdb-csl-sourcerygxx-4_1-9:1.168.2.1
	gdb-csl-sourcerygxx-4_1-8:1.168.2.1
	gdb-csl-sourcerygxx-4_1-7:1.168.2.1
	gdb-csl-arm-2006q1-6:1.168.2.1
	gdb-csl-sourcerygxx-4_1-6:1.168.2.1
	gdb-csl-symbian-6_4_50_20060226-10:1.168.2.1.2.1
	gdb-csl-symbian-6_4_50_20060226-9:1.168.2.1.2.1
	gdb-csl-symbian-6_4_50_20060226-8:1.168.2.1.2.1
	gdb-csl-coldfire-4_1-11:1.168.2.1
	gdb-csl-sourcerygxx-3_4_4-19:1.168.2.1
	gdb-csl-coldfire-4_1-10:1.168.2.1
	gdb_6_5-branch:1.172.0.8
	gdb_6_5-2006-05-14-branchpoint:1.172
	gdb-csl-sourcerygxx-4_1-5:1.168.2.1
	nickrob-async-20060513-branch:1.172.0.6
	nickrob-async-20060513-branchpoint:1.172
	gdb-csl-sourcerygxx-4_1-4:1.168.2.1
	msnyder-reverse-20060502-branch:1.172.0.4
	msnyder-reverse-20060502-branchpoint:1.172
	gdb-csl-morpho-4_1-4:1.168.2.1
	gdb-csl-sourcerygxx-3_4_4-17:1.168.2.1
	readline_5_1-import-branch:1.172.0.2
	readline_5_1-import-branchpoint:1.172
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.168.2.1
	gdb-csl-symbian-20060226-branch:1.168.2.1.0.2
	gdb-csl-symbian-20060226-branchpoint:1.168.2.1
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.168.2.1
	msnyder-reverse-20060331-branch:1.168.0.6
	msnyder-reverse-20060331-branchpoint:1.168
	gdb-csl-available-20060303-branch:1.168.0.4
	gdb-csl-available-20060303-branchpoint:1.168
	gdb-csl-20060226-branch:1.168.0.2
	gdb-csl-20060226-branchpoint:1.168
	gdb_6_4-20051202-release:1.165
	msnyder-fork-checkpoint-branch:1.165.0.8
	msnyder-fork-checkpoint-branchpoint:1.165
	gdb-csl-gxxpro-6_3-branch:1.165.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.165
	gdb_6_4-branch:1.165.0.4
	gdb_6_4-2005-11-01-branchpoint:1.165
	gdb-csl-arm-20051020-branch:1.165.0.2
	gdb-csl-arm-20051020-branchpoint:1.165
	msnyder-tracepoint-checkpoint-branch:1.163.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.163
	gdb-csl-arm-20050325-2005-q1b:1.161
	gdb-csl-arm-20050325-2005-q1a:1.161
	csl-arm-20050325-branch:1.161.0.2
	csl-arm-20050325-branchpoint:1.161
	gdb-post-i18n-errorwarning-20050211:1.160
	gdb-pre-i18n-errorwarning-20050211:1.160
	gdb_6_3-20041109-release:1.153
	gdb_6_3-branch:1.153.0.4
	gdb_6_3-20041019-branchpoint:1.153
	drow_intercu-merge-20040921:1.153
	drow_intercu-merge-20040915:1.153
	jimb-gdb_6_2-e500-branch:1.153.0.6
	jimb-gdb_6_2-e500-branchpoint:1.153
	gdb_6_2-20040730-release:1.153
	gdb_6_2-branch:1.153.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.153
	gdb_6_1_1-20040616-release:1.149.6.1
	gdb_6_1-2004-04-05-release:1.149.6.1
	drow_intercu-merge-20040402:1.152
	drow_intercu-merge-20040327:1.152
	ezannoni_pie-20040323-branch:1.152.0.4
	ezannoni_pie-20040323-branchpoint:1.152
	cagney_tramp-20040321-mergepoint:1.152
	cagney_tramp-20040309-branch:1.152.0.2
	cagney_tramp-20040309-branchpoint:1.152
	gdb_6_1-branch:1.149.0.6
	gdb_6_1-2004-03-01-gmt-branchpoint:1.149
	drow_intercu-20040221-branch:1.149.0.4
	drow_intercu-20040221-branchpoint:1.149
	cagney_bfdfile-20040213-branch:1.149.0.2
	cagney_bfdfile-20040213-branchpoint:1.149
	drow-cplus-merge-20040208:1.149
	carlton_dictionary-20040126-merge:1.145
	cagney_bigcore-20040122-branch:1.142.0.2
	cagney_bigcore-20040122-branchpoint:1.142
	drow-cplus-merge-20040113:1.139
	drow-cplus-merge-20031224:1.134
	drow-cplus-merge-20031220:1.134
	carlton_dictionary-20031215-merge:1.134
	drow-cplus-merge-20031214:1.134
	carlton-dictionary-20031111-merge:1.133
	gdb_6_0-2003-10-04-release:1.113.4.2
	kettenis_sparc-20030918-branch:1.127.0.2
	kettenis_sparc-20030918-branchpoint:1.127
	carlton_dictionary-20030917-merge:1.127
	ezannoni_pie-20030916-branchpoint:1.125
	ezannoni_pie-20030916-branch:1.125.0.2
	cagney_x86i386-20030821-branch:1.118.0.2
	cagney_x86i386-20030821-branchpoint:1.118
	carlton_dictionary-20030805-merge:1.118
	carlton_dictionary-20030627-merge:1.113
	gdb_6_0-branch:1.113.0.4
	gdb_6_0-2003-06-23-branchpoint:1.113
	jimb-ppc64-linux-20030613-branch:1.113.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.113
	cagney_convert-20030606-branch:1.107.0.2
	cagney_convert-20030606-branchpoint:1.107
	cagney_writestrings-20030508-branch:1.98.0.4
	cagney_writestrings-20030508-branchpoint:1.98
	jimb-ppc64-linux-20030528-branch:1.103.0.2
	jimb-ppc64-linux-20030528-branchpoint:1.103
	carlton_dictionary-20030523-merge:1.101
	cagney_fileio-20030521-branch:1.101.0.2
	cagney_fileio-20030521-branchpoint:1.101
	kettenis_i386newframe-20030517-mergepoint:1.101
	jimb-ppc64-linux-20030509-branch:1.98.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.98
	kettenis_i386newframe-20030504-mergepoint:1.95
	carlton_dictionary-20030430-merge:1.94
	kettenis_i386newframe-20030419-branch:1.89.0.2
	kettenis_i386newframe-20030419-branchpoint:1.89
	carlton_dictionary-20030416-merge:1.89
	cagney_frameaddr-20030409-mergepoint:1.87
	kettenis_i386newframe-20030406-branch:1.86.0.2
	kettenis_i386newframe-20030406-branchpoint:1.86
	cagney_frameaddr-20030403-branchpoint:1.85
	cagney_frameaddr-20030403-branch:1.85.0.2
	cagney_framebase-20030330-mergepoint:1.81
	cagney_framebase-20030326-branch:1.77.0.2
	cagney_framebase-20030326-branchpoint:1.77
	cagney_lazyid-20030317-branch:1.73.0.2
	cagney_lazyid-20030317-branchpoint:1.73
	kettenis-i386newframe-20030316-mergepoint:1.73
	offbyone-20030313-branch:1.70.0.2
	offbyone-20030313-branchpoint:1.70
	kettenis-i386newframe-20030308-branch:1.69.0.4
	kettenis-i386newframe-20030308-branchpoint:1.69
	carlton_dictionary-20030305-merge:1.69
	cagney_offbyone-20030303-branch:1.69.0.2
	cagney_offbyone-20030303-branchpoint:1.69
	carlton_dictionary-20030207-merge:1.64
	interps-20030203-mergepoint:1.64
	interps-20030202-branch:1.64.0.2
	interps-20030202-branchpoint:1.64
	cagney-unwind-20030108-branch:1.63.0.2
	cagney-unwind-20030108-branchpoint:1.63
	carlton_dictionary-20021223-merge:1.53
	gdb_5_3-2002-12-12-release:1.39
	carlton_dictionary-20021115-merge:1.44
	kseitz_interps-20021105-merge:1.40
	kseitz_interps-20021103-merge:1.40
	drow-cplus-merge-20021020:1.39
	drow-cplus-merge-20021025:1.39
	carlton_dictionary-20021025-merge:1.39
	carlton_dictionary-20021011-merge:1.39
	drow-cplus-branch:1.39.0.10
	drow-cplus-branchpoint:1.39
	kseitz_interps-20020930-merge:1.39
	carlton_dictionary-20020927-merge:1.39
	carlton_dictionary-branch:1.39.0.8
	carlton_dictionary-20020920-branchpoint:1.39
	gdb_5_3-branch:1.39.0.6
	gdb_5_3-2002-09-04-branchpoint:1.39
	kseitz_interps-20020829-merge:1.39
	cagney_sysregs-20020825-branch:1.39.0.4
	cagney_sysregs-20020825-branchpoint:1.39
	readline_4_3-import-branch:1.39.0.2
	readline_4_3-import-branchpoint:1.39
	gdb_5_2_1-2002-07-23-release:1.23
	kseitz_interps-20020528-branch:1.34.0.6
	kseitz_interps-20020528-branchpoint:1.34
	cagney_regbuf-20020515-branch:1.34.0.4
	cagney_regbuf-20020515-branchpoint:1.34
	jimb-macro-020506-branch:1.34.0.2
	jimb-macro-020506-branchpoint:1.34
	gdb_5_2-2002-04-29-release:1.23
	gdb_5_2-branch:1.23.0.2
	gdb_5_2-2002-03-03-branchpoint:1.23
	gdb_5_1_1-2002-01-24-release:1.18
	gdb_5_1_0_1-2002-01-03-release:1.18
	cygnus_cvs_20020108_pre:1.20
	gdb_5_1_0_1-2002-01-03-branchpoint:1.18
	gdb_5_1_0_1-2002-01-03-branch:1.18.0.6
	gdb_5_1-2001-11-21-release:1.18
	gdb_s390-2001-09-26-branch:1.18.0.4
	gdb_s390-2001-09-26-branchpoint:1.18
	gdb_5_1-2001-07-29-branch:1.18.0.2
	gdb_5_1-2001-07-29-branchpoint:1.18
	dberlin-typesystem-branch:1.17.0.2
	dberlin-typesystem-branchpoint:1.17
	gdb-post-ptid_t-2001-05-03:1.16
	gdb-pre-ptid_t-2001-05-03:1.16
	insight-precleanup-2001-01-01:1.9
	gdb-post-protoization-2000-07-29:1.6
	gdb-pre-protoization-2000-07-29:1.5
	gdb-premipsmulti-2000-06-06-branch:1.5.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.5
	gdb-post-params-removal-2000-06-04:1.5
	gdb-pre-params-removal-2000-06-04:1.5
	gdb-post-params-removal-2000-05-28:1.5
	gdb-pre-params-removal-2000-05-28:1.5
	gdb_5_0-2000-05-19-release:1.1.1.7
	gdb_4_18_2-2000-05-18-release:1.1.1.7
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.7
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.7
	gdb_5_0-2000-04-10-branch:1.1.1.7.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.7
	repo-unification-2000-02-06:1.1.1.7
	insight-2000-02-04:1.1.1.7
	gdb-2000-02-04:1.1.1.7
	gdb-2000-02-02:1.1.1.7
	gdb-2000-02-01:1.1.1.7
	gdb-2000-01-31:1.1.1.7
	gdb-2000-01-26:1.1.1.7
	gdb-2000-01-24:1.1.1.7
	gdb-2000-01-17:1.1.1.7
	gdb-2000-01-10:1.1.1.7
	gdb-2000-01-05:1.1.1.7
	gdb-1999-12-21:1.1.1.7
	gdb-1999-12-13:1.1.1.7
	gdb-1999-12-07:1.1.1.7
	gdb-1999-12-06:1.1.1.7
	gdb-1999-11-16:1.1.1.7
	gdb-1999-11-08:1.1.1.7
	gdb-1999-11-01:1.1.1.7
	gdb-1999-10-25:1.1.1.7
	gdb-1999-10-18:1.1.1.7
	gdb-1999-10-11:1.1.1.7
	gdb-1999-10-04:1.1.1.7
	gdb-1999-09-28:1.1.1.6
	gdb-1999-09-21:1.1.1.6
	gdb-1999-09-13:1.1.1.6
	gdb-1999-09-08:1.1.1.6
	gdb-1999-08-30:1.1.1.6
	gdb-1999-08-23:1.1.1.6
	gdb-1999-08-16:1.1.1.6
	gdb-1999-08-09:1.1.1.6
	gdb-1999-08-02:1.1.1.5
	gdb-1999-07-26:1.1.1.5
	gdb-1999-07-19:1.1.1.5
	gdb-1999-07-12:1.1.1.5
	gdb-post-reformat-19990707:1.1.1.5
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.5
	gdb-pre-reformat-19990707:1.1.1.4
	gdb-1999-07-07:1.1.1.4
	gdb-1999-07-05:1.1.1.3
	gdb-1999-06-28:1.1.1.3
	gdb-1999-06-21:1.1.1.3
	gdb-1999-06-14:1.1.1.3
	gdb-1999-06-07:1.1.1.3
	gdb-1999-06-01:1.1.1.3
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.3
	gdb-1999-05-19:1.1.1.3
	gdb-1999-05-10:1.1.1.3
	gdb-19990504:1.1.1.3
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.233
date	2013.06.24.22.18.32;	author macro;	state Exp;
branches;
next	1.232;

1.232
date	2013.02.06.19.40.04;	author davem;	state Exp;
branches;
next	1.231;

1.231
date	2013.01.01.06.32.51;	author brobecke;	state Exp;
branches;
next	1.230;

1.230
date	2012.12.15.14.29.00;	author brobecke;	state Exp;
branches;
next	1.229;

1.229
date	2012.12.15.14.27.56;	author brobecke;	state Exp;
branches;
next	1.228;

1.228
date	2012.11.23.20.30.22;	author davem;	state Exp;
branches;
next	1.227;

1.227
date	2012.05.18.21.02.50;	author sergiodj;	state Exp;
branches;
next	1.226;

1.226
date	2012.05.16.14.35.07;	author macro;	state Exp;
branches;
next	1.225;

1.225
date	2012.04.21.19.03.52;	author davem;	state Exp;
branches;
next	1.224;

1.224
date	2012.01.04.08.17.11;	author brobecke;	state Exp;
branches;
next	1.223;

1.223
date	2011.09.28.17.59.42;	author davem;	state Exp;
branches
	1.223.2.1;
next	1.222;

1.222
date	2011.06.27.16.36.00;	author brobecke;	state Exp;
branches;
next	1.221;

1.221
date	2011.05.23.16.38.05;	author guitton;	state Exp;
branches;
next	1.220;

1.220
date	2011.05.21.19.19.45;	author kettenis;	state Exp;
branches;
next	1.219;

1.219
date	2011.03.18.18.52.32;	author palves;	state Exp;
branches;
next	1.218;

1.218
date	2011.03.18.18.38.44;	author palves;	state Exp;
branches;
next	1.217;

1.217
date	2011.01.11.21.53.24;	author msnyder;	state Exp;
branches;
next	1.216;

1.216
date	2011.01.01.15.33.15;	author brobecke;	state Exp;
branches;
next	1.215;

1.215
date	2010.12.12.17.41.19;	author kettenis;	state Exp;
branches;
next	1.214;

1.214
date	2010.10.01.15.55.14;	author brobecke;	state Exp;
branches;
next	1.213;

1.213
date	2010.05.05.16.58.59;	author brobecke;	state Exp;
branches;
next	1.212;

1.212
date	2010.04.21.20.13.41;	author vapier;	state Exp;
branches;
next	1.211;

1.211
date	2010.01.01.07.31.42;	author brobecke;	state Exp;
branches;
next	1.210;

1.210
date	2009.10.19.09.51.42;	author palves;	state Exp;
branches;
next	1.209;

1.209
date	2009.09.07.17.52.41;	author jkratoch;	state Exp;
branches;
next	1.208;

1.208
date	2009.07.02.17.25.58;	author uweigand;	state Exp;
branches;
next	1.207;

1.207
date	2009.07.02.17.12.27;	author uweigand;	state Exp;
branches;
next	1.206;

1.206
date	2009.07.02.12.55.30;	author uweigand;	state Exp;
branches;
next	1.205;

1.205
date	2009.07.02.12.52.52;	author uweigand;	state Exp;
branches;
next	1.204;

1.204
date	2009.07.02.12.46.19;	author uweigand;	state Exp;
branches;
next	1.203;

1.203
date	2009.06.17.18.43.24;	author uweigand;	state Exp;
branches;
next	1.202;

1.202
date	2009.02.22.01.02.20;	author palves;	state Exp;
branches;
next	1.201;

1.201
date	2009.01.03.05.57.53;	author brobecke;	state Exp;
branches;
next	1.200;

1.200
date	2008.09.11.14.23.15;	author uweigand;	state Exp;
branches;
next	1.199;

1.199
date	2008.08.20.09.43.16;	author kettenis;	state Exp;
branches;
next	1.198;

1.198
date	2008.05.07.19.30.04;	author brobecke;	state Exp;
branches;
next	1.197;

1.197
date	2008.04.30.21.18.28;	author drow;	state Exp;
branches;
next	1.196;

1.196
date	2008.04.29.16.06.07;	author brobecke;	state Exp;
branches;
next	1.195;

1.195
date	2008.04.22.11.03.42;	author corinna;	state Exp;
branches;
next	1.194;

1.194
date	2008.03.13.12.22.13;	author drow;	state Exp;
branches;
next	1.193;

1.193
date	2008.01.11.14.43.15;	author deuling;	state Exp;
branches;
next	1.192;

1.192
date	2008.01.11.13.20.02;	author deuling;	state Exp;
branches;
next	1.191;

1.191
date	2008.01.01.22.53.13;	author drow;	state Exp;
branches;
next	1.190;

1.190
date	2007.11.07.06.33.01;	author deuling;	state Exp;
branches;
next	1.189;

1.189
date	2007.11.02.14.27.15;	author uweigand;	state Exp;
branches;
next	1.188;

1.188
date	2007.10.19.12.23.20;	author uweigand;	state Exp;
branches;
next	1.187;

1.187
date	2007.10.12.15.34.45;	author uweigand;	state Exp;
branches;
next	1.186;

1.186
date	2007.10.10.17.05.31;	author uweigand;	state Exp;
branches;
next	1.185;

1.185
date	2007.08.23.18.08.38;	author brobecke;	state Exp;
branches;
next	1.184;

1.184
date	2007.06.15.22.44.56;	author uweigand;	state Exp;
branches;
next	1.183;

1.183
date	2007.06.15.22.42.22;	author uweigand;	state Exp;
branches;
next	1.182;

1.182
date	2007.06.15.22.37.35;	author uweigand;	state Exp;
branches;
next	1.181;

1.181
date	2007.04.14.18.10.54;	author uweigand;	state Exp;
branches;
next	1.180;

1.180
date	2007.04.12.14.52.20;	author uweigand;	state Exp;
branches;
next	1.179;

1.179
date	2007.04.11.07.10.08;	author brobecke;	state Exp;
branches;
next	1.178;

1.178
date	2007.02.27.20.17.19;	author drow;	state Exp;
branches;
next	1.177;

1.177
date	2007.01.29.17.31.06;	author drow;	state Exp;
branches;
next	1.176;

1.176
date	2007.01.09.17.58.58;	author drow;	state Exp;
branches;
next	1.175;

1.175
date	2006.12.29.21.00.47;	author kettenis;	state Exp;
branches;
next	1.174;

1.174
date	2006.11.09.16.36.58;	author brobecke;	state Exp;
branches;
next	1.173;

1.173
date	2006.07.12.18.13.45;	author drow;	state Exp;
branches;
next	1.172;

1.172
date	2006.04.18.19.20.06;	author drow;	state Exp;
branches
	1.172.6.1;
next	1.171;

1.171
date	2006.04.09.08.22.43;	author davem;	state Exp;
branches;
next	1.170;

1.170
date	2006.04.05.20.01.19;	author davem;	state Exp;
branches;
next	1.169;

1.169
date	2006.04.05.18.35.39;	author davem;	state Exp;
branches;
next	1.168;

1.168
date	2006.01.22.20.07.38;	author kettenis;	state Exp;
branches
	1.168.2.1
	1.168.4.1;
next	1.167;

1.167
date	2006.01.22.16.33.34;	author kettenis;	state Exp;
branches;
next	1.166;

1.166
date	2005.12.17.22.34.02;	author eliz;	state Exp;
branches;
next	1.165;

1.165
date	2005.08.13.22.12.24;	author kettenis;	state Exp;
branches;
next	1.164;

1.164
date	2005.06.12.11.10.56;	author kettenis;	state Exp;
branches;
next	1.163;

1.163
date	2005.05.14.13.45.22;	author kettenis;	state Exp;
branches;
next	1.162;

1.162
date	2005.03.28.13.42.49;	author kettenis;	state Exp;
branches;
next	1.161;

1.161
date	2005.03.09.22.08.12;	author kettenis;	state Exp;
branches;
next	1.160;

1.160
date	2005.02.07.00.09.55;	author cagney;	state Exp;
branches;
next	1.159;

1.159
date	2005.01.16.20.06.54;	author kettenis;	state Exp;
branches;
next	1.158;

1.158
date	2004.11.29.19.52.44;	author kettenis;	state Exp;
branches;
next	1.157;

1.157
date	2004.11.23.18.59.13;	author brobecke;	state Exp;
branches;
next	1.156;

1.156
date	2004.11.21.20.11.09;	author drow;	state Exp;
branches;
next	1.155;

1.155
date	2004.11.13.02.15.33;	author cagney;	state Exp;
branches;
next	1.154;

1.154
date	2004.10.29.14.00.57;	author cagney;	state Exp;
branches;
next	1.153;

1.153
date	2004.06.07.02.02.55;	author tausq;	state Exp;
branches;
next	1.152;

1.152
date	2004.03.05.20.58.00;	author kettenis;	state Exp;
branches;
next	1.151;

1.151
date	2004.03.05.15.34.29;	author kettenis;	state Exp;
branches;
next	1.150;

1.150
date	2004.03.04.10.10.33;	author kettenis;	state Exp;
branches;
next	1.149;

1.149
date	2004.02.07.20.40.35;	author kettenis;	state Exp;
branches
	1.149.4.1
	1.149.6.1;
next	1.148;

1.148
date	2004.02.04.21.49.55;	author kettenis;	state Exp;
branches;
next	1.147;

1.147
date	2004.01.31.15.42.24;	author kettenis;	state Exp;
branches;
next	1.146;

1.146
date	2004.01.26.20.52.12;	author cagney;	state Exp;
branches;
next	1.145;

1.145
date	2004.01.25.12.10.55;	author kettenis;	state Exp;
branches;
next	1.144;

1.144
date	2004.01.25.00.58.53;	author kettenis;	state Exp;
branches;
next	1.143;

1.143
date	2004.01.24.21.34.45;	author kettenis;	state Exp;
branches;
next	1.142;

1.142
date	2004.01.17.22.45.44;	author cagney;	state Exp;
branches;
next	1.141;

1.141
date	2004.01.17.15.34.12;	author cagney;	state Exp;
branches;
next	1.140;

1.140
date	2004.01.13.21.38.47;	author cagney;	state Exp;
branches;
next	1.139;

1.139
date	2004.01.11.20.47.53;	author kettenis;	state Exp;
branches;
next	1.138;

1.138
date	2004.01.10.23.43.25;	author kettenis;	state Exp;
branches;
next	1.137;

1.137
date	2004.01.05.20.38.57;	author kettenis;	state Exp;
branches;
next	1.136;

1.136
date	2004.01.03.17.59.04;	author kettenis;	state Exp;
branches;
next	1.135;

1.135
date	2004.01.03.10.08.44;	author kettenis;	state Exp;
branches;
next	1.134;

1.134
date	2003.11.23.20.41.17;	author cagney;	state Exp;
branches;
next	1.133;

1.133
date	2003.10.06.19.27.12;	author cagney;	state Exp;
branches;
next	1.132;

1.132
date	2003.10.02.20.28.30;	author cagney;	state Exp;
branches;
next	1.131;

1.131
date	2003.09.30.19.12.19;	author cagney;	state Exp;
branches;
next	1.130;

1.130
date	2003.09.30.13.29.44;	author cagney;	state Exp;
branches;
next	1.129;

1.129
date	2003.09.28.22.32.19;	author cagney;	state Exp;
branches;
next	1.128;

1.128
date	2003.09.18.22.39.21;	author cagney;	state Exp;
branches;
next	1.127;

1.127
date	2003.09.17.15.42.21;	author cagney;	state Exp;
branches
	1.127.2.1;
next	1.126;

1.126
date	2003.09.17.14.24.31;	author cagney;	state Exp;
branches;
next	1.125;

1.125
date	2003.09.14.16.32.14;	author cagney;	state Exp;
branches;
next	1.124;

1.124
date	2003.09.13.23.25.41;	author kettenis;	state Exp;
branches;
next	1.123;

1.123
date	2003.09.11.15.17.15;	author cagney;	state Exp;
branches;
next	1.122;

1.122
date	2003.09.09.04.41.32;	author cagney;	state Exp;
branches;
next	1.121;

1.121
date	2003.09.09.03.58.18;	author cagney;	state Exp;
branches;
next	1.120;

1.120
date	2003.08.28.03.03.44;	author cagney;	state Exp;
branches;
next	1.119;

1.119
date	2003.08.24.11.47.18;	author cagney;	state Exp;
branches;
next	1.118;

1.118
date	2003.07.17.18.49.35;	author cagney;	state Exp;
branches;
next	1.117;

1.117
date	2003.07.07.15.56.04;	author drow;	state Exp;
branches;
next	1.116;

1.116
date	2003.07.03.22.14.42;	author cagney;	state Exp;
branches;
next	1.115;

1.115
date	2003.06.30.16.55.31;	author brobecke;	state Exp;
branches;
next	1.114;

1.114
date	2003.06.29.21.15.24;	author drow;	state Exp;
branches;
next	1.113;

1.113
date	2003.06.13.04.40.34;	author cagney;	state Exp;
branches
	1.113.4.1;
next	1.112;

1.112
date	2003.06.11.13.16.29;	author cagney;	state Exp;
branches;
next	1.111;

1.111
date	2003.06.09.17.35.58;	author cagney;	state Exp;
branches;
next	1.110;

1.110
date	2003.06.07.22.38.56;	author cagney;	state Exp;
branches;
next	1.109;

1.109
date	2003.06.07.18.08.25;	author cagney;	state Exp;
branches;
next	1.108;

1.108
date	2003.06.07.16.23.12;	author cagney;	state Exp;
branches;
next	1.107;

1.107
date	2003.06.03.21.02.49;	author cagney;	state Exp;
branches;
next	1.106;

1.106
date	2003.06.03.01.24.42;	author cagney;	state Exp;
branches;
next	1.105;

1.105
date	2003.06.02.02.54.35;	author fedor;	state Exp;
branches;
next	1.104;

1.104
date	2003.06.02.02.09.39;	author cagney;	state Exp;
branches;
next	1.103;

1.103
date	2003.05.25.15.47.26;	author kettenis;	state Exp;
branches;
next	1.102;

1.102
date	2003.05.25.11.58.08;	author kettenis;	state Exp;
branches;
next	1.101;

1.101
date	2003.05.17.05.59.59;	author cagney;	state Exp;
branches;
next	1.100;

1.100
date	2003.05.15.22.58.38;	author cagney;	state Exp;
branches;
next	1.99;

1.99
date	2003.05.13.19.27.28;	author cagney;	state Exp;
branches;
next	1.98;

1.98
date	2003.05.08.20.52.48;	author cagney;	state Exp;
branches
	1.98.4.1;
next	1.97;

1.97
date	2003.05.08.18.46.48;	author cagney;	state Exp;
branches;
next	1.96;

1.96
date	2003.05.05.17.56.56;	author cagney;	state Exp;
branches;
next	1.95;

1.95
date	2003.05.03.19.39.23;	author cagney;	state Exp;
branches;
next	1.94;

1.94
date	2003.04.30.22.01.37;	author cagney;	state Exp;
branches;
next	1.93;

1.93
date	2003.04.30.18.17.58;	author cagney;	state Exp;
branches;
next	1.92;

1.92
date	2003.04.29.01.49.47;	author cagney;	state Exp;
branches;
next	1.91;

1.91
date	2003.04.28.16.17.28;	author cagney;	state Exp;
branches;
next	1.90;

1.90
date	2003.04.21.16.48.39;	author cagney;	state Exp;
branches;
next	1.89;

1.89
date	2003.04.16.14.32.21;	author cagney;	state Exp;
branches
	1.89.2.1;
next	1.88;

1.88
date	2003.04.11.18.15.39;	author cagney;	state Exp;
branches;
next	1.87;

1.87
date	2003.04.06.18.36.23;	author cagney;	state Exp;
branches;
next	1.86;

1.86
date	2003.04.06.01.13.59;	author cagney;	state Exp;
branches;
next	1.85;

1.85
date	2003.04.01.17.17.29;	author cagney;	state Exp;
branches
	1.85.2.1;
next	1.84;

1.84
date	2003.04.01.14.38.50;	author cagney;	state Exp;
branches;
next	1.83;

1.83
date	2003.03.31.21.58.23;	author cagney;	state Exp;
branches;
next	1.82;

1.82
date	2003.03.31.19.01.21;	author cagney;	state Exp;
branches;
next	1.81;

1.81
date	2003.03.30.14.59.01;	author cagney;	state Exp;
branches;
next	1.80;

1.80
date	2003.03.30.14.32.09;	author cagney;	state Exp;
branches;
next	1.79;

1.79
date	2003.03.27.15.29.44;	author cagney;	state Exp;
branches;
next	1.78;

1.78
date	2003.03.26.22.39.52;	author cagney;	state Exp;
branches;
next	1.77;

1.77
date	2003.03.25.22.56.40;	author cagney;	state Exp;
branches
	1.77.2.1;
next	1.76;

1.76
date	2003.03.25.20.38.46;	author cagney;	state Exp;
branches;
next	1.75;

1.75
date	2003.03.25.18.54.16;	author cagney;	state Exp;
branches;
next	1.74;

1.74
date	2003.03.24.03.54.49;	author cagney;	state Exp;
branches;
next	1.73;

1.73
date	2003.03.14.17.07.00;	author cagney;	state Exp;
branches;
next	1.72;

1.72
date	2003.03.14.16.05.36;	author cagney;	state Exp;
branches;
next	1.71;

1.71
date	2003.03.13.21.45.41;	author cagney;	state Exp;
branches;
next	1.70;

1.70
date	2003.03.12.16.50.45;	author cagney;	state Exp;
branches;
next	1.69;

1.69
date	2003.03.03.20.50.20;	author cagney;	state Exp;
branches
	1.69.4.1;
next	1.68;

1.68
date	2003.03.02.04.02.24;	author cagney;	state Exp;
branches;
next	1.67;

1.67
date	2003.03.02.00.11.43;	author cagney;	state Exp;
branches;
next	1.66;

1.66
date	2003.02.27.17.48.47;	author cagney;	state Exp;
branches;
next	1.65;

1.65
date	2003.02.18.22.46.15;	author kevinb;	state Exp;
branches;
next	1.64;

1.64
date	2003.01.15.19.35.27;	author cagney;	state Exp;
branches;
next	1.63;

1.63
date	2003.01.08.17.21.30;	author cagney;	state Exp;
branches;
next	1.62;

1.62
date	2003.01.08.15.56.37;	author cagney;	state Exp;
branches;
next	1.61;

1.61
date	2003.01.08.01.53.37;	author cagney;	state Exp;
branches;
next	1.60;

1.60
date	2003.01.07.14.51.10;	author cagney;	state Exp;
branches;
next	1.59;

1.59
date	2003.01.06.20.04.11;	author cagney;	state Exp;
branches;
next	1.58;

1.58
date	2003.01.05.01.39.55;	author drow;	state Exp;
branches;
next	1.57;

1.57
date	2003.01.04.23.38.46;	author drow;	state Exp;
branches;
next	1.56;

1.56
date	2003.01.04.22.37.47;	author drow;	state Exp;
branches;
next	1.55;

1.55
date	2003.01.03.18.23.01;	author cagney;	state Exp;
branches;
next	1.54;

1.54
date	2003.01.02.22.20.46;	author cagney;	state Exp;
branches;
next	1.53;

1.53
date	2002.12.11.20.35.43;	author cagney;	state Exp;
branches;
next	1.52;

1.52
date	2002.12.01.19.07.15;	author cagney;	state Exp;
branches;
next	1.51;

1.51
date	2002.11.29.19.15.15;	author cagney;	state Exp;
branches;
next	1.50;

1.50
date	2002.11.28.21.38.43;	author cagney;	state Exp;
branches;
next	1.49;

1.49
date	2002.11.28.18.15.59;	author cagney;	state Exp;
branches;
next	1.48;

1.48
date	2002.11.26.19.01.29;	author cagney;	state Exp;
branches;
next	1.47;

1.47
date	2002.11.24.19.48.13;	author cagney;	state Exp;
branches;
next	1.46;

1.46
date	2002.11.23.01.39.25;	author cagney;	state Exp;
branches;
next	1.45;

1.45
date	2002.11.18.22.19.30;	author cagney;	state Exp;
branches;
next	1.44;

1.44
date	2002.11.14.20.37.29;	author cagney;	state Exp;
branches;
next	1.43;

1.43
date	2002.11.14.00.25.03;	author cagney;	state Exp;
branches;
next	1.42;

1.42
date	2002.11.10.15.36.26;	author cagney;	state Exp;
branches;
next	1.41;

1.41
date	2002.11.05.20.43.35;	author cagney;	state Exp;
branches;
next	1.40;

1.40
date	2002.11.02.14.59.10;	author cagney;	state Exp;
branches;
next	1.39;

1.39
date	2002.08.24.00.21.35;	author cagney;	state Exp;
branches
	1.39.8.1
	1.39.10.1;
next	1.38;

1.38
date	2002.07.29.16.34.07;	author cagney;	state Exp;
branches;
next	1.37;

1.37
date	2002.06.17.23.32.33;	author cagney;	state Exp;
branches;
next	1.36;

1.36
date	2002.06.14.22.55.40;	author cagney;	state Exp;
branches;
next	1.35;

1.35
date	2002.05.31.00.19.47;	author thorpej;	state Exp;
branches;
next	1.34;

1.34
date	2002.05.05.01.55.37;	author cagney;	state Exp;
branches
	1.34.4.1
	1.34.6.1;
next	1.33;

1.33
date	2002.04.26.23.37.33;	author cagney;	state Exp;
branches;
next	1.32;

1.32
date	2002.04.26.01.56.04;	author davem;	state Exp;
branches;
next	1.31;

1.31
date	2002.04.24.07.12.27;	author davem;	state Exp;
branches;
next	1.30;

1.30
date	2002.04.22.03.51.34;	author davem;	state Exp;
branches;
next	1.29;

1.29
date	2002.04.22.01.02.02;	author davem;	state Exp;
branches;
next	1.28;

1.28
date	2002.04.22.00.27.38;	author davem;	state Exp;
branches;
next	1.27;

1.27
date	2002.04.20.03.09.28;	author cagney;	state Exp;
branches;
next	1.26;

1.26
date	2002.04.12.18.18.57;	author cagney;	state Exp;
branches;
next	1.25;

1.25
date	2002.04.06.00.19.44;	author cagney;	state Exp;
branches;
next	1.24;

1.24
date	2002.04.05.23.38.07;	author cagney;	state Exp;
branches;
next	1.23;

1.23
date	2002.02.20.10.42.59;	author rearnsha;	state Exp;
branches;
next	1.22;

1.22
date	2002.01.20.19.26.48;	author cagney;	state Exp;
branches;
next	1.21;

1.21
date	2002.01.20.18.05.51;	author cagney;	state Exp;
branches;
next	1.20;

1.20
date	2001.12.30.17.00.43;	author msnyder;	state Exp;
branches;
next	1.19;

1.19
date	2001.12.15.16.53.23;	author cagney;	state Exp;
branches;
next	1.18;

1.18
date	2001.07.15.20.10.02;	author cagney;	state Exp;
branches;
next	1.17;

1.17
date	2001.05.15.11.38.26;	author kettenis;	state Exp;
branches;
next	1.16;

1.16
date	2001.03.28.21.42.31;	author cagney;	state Exp;
branches;
next	1.15;

1.15
date	2001.03.06.08.21.17;	author kevinb;	state Exp;
branches;
next	1.14;

1.14
date	2001.03.01.01.39.21;	author cagney;	state Exp;
branches;
next	1.13;

1.13
date	2001.02.08.06.03.53;	author cagney;	state Exp;
branches;
next	1.12;

1.12
date	2001.01.02.20.37.11;	author msnyder;	state Exp;
branches;
next	1.11;

1.11
date	2001.01.02.20.32.50;	author msnyder;	state Exp;
branches;
next	1.10;

1.10
date	2001.01.02.20.21.53;	author msnyder;	state Exp;
branches;
next	1.9;

1.9
date	2000.10.24.20.05.35;	author kevinb;	state Exp;
branches;
next	1.8;

1.8
date	2000.10.16.17.19.47;	author schauer;	state Exp;
branches;
next	1.7;

1.7
date	2000.08.10.23.53.45;	author cagney;	state Exp;
branches;
next	1.6;

1.6
date	2000.07.30.01.48.27;	author kevinb;	state Exp;
branches;
next	1.5;

1.5
date	2000.05.26.23.22.41;	author msnyder;	state Exp;
branches;
next	1.4;

1.4
date	2000.05.24.17.17.46;	author msnyder;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.10.20.07.24;	author msnyder;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.10.17.38.16;	author msnyder;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.05;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.223.2.1
date	2012.01.06.04.43.30;	author brobecke;	state Exp;
branches;
next	;

1.172.6.1
date	2006.08.28.07.48.47;	author nickrob;	state Exp;
branches;
next	;

1.168.2.1
date	2006.04.03.00.47.40;	author drow;	state Exp;
branches
	1.168.2.1.2.1;
next	;

1.168.2.1.2.1
date	2006.04.11.21.58.24;	author drow;	state Exp;
branches;
next	;

1.168.4.1
date	2006.03.03.20.46.37;	author drow;	state Exp;
branches;
next	;

1.149.4.1
date	2004.03.27.17.37.53;	author drow;	state Exp;
branches;
next	1.149.4.2;

1.149.4.2
date	2004.09.16.17.01.22;	author drow;	state Exp;
branches;
next	;

1.149.6.1
date	2004.03.05.15.30.17;	author kettenis;	state Exp;
branches;
next	;

1.127.2.1
date	2003.09.18.20.14.17;	author kettenis;	state Exp;
branches;
next	1.127.2.2;

1.127.2.2
date	2003.10.18.18.25.46;	author kettenis;	state Exp;
branches;
next	1.127.2.3;

1.127.2.3
date	2003.10.25.18.42.28;	author kettenis;	state Exp;
branches;
next	1.127.2.4;

1.127.2.4
date	2003.11.02.17.05.07;	author kettenis;	state Exp;
branches;
next	1.127.2.5;

1.127.2.5
date	2003.11.07.21.46.10;	author kettenis;	state Exp;
branches;
next	1.127.2.6;

1.127.2.6
date	2003.11.15.17.56.45;	author kettenis;	state Exp;
branches;
next	1.127.2.7;

1.127.2.7
date	2003.11.15.20.48.40;	author kettenis;	state Exp;
branches;
next	1.127.2.8;

1.127.2.8
date	2003.12.15.20.41.41;	author kettenis;	state Exp;
branches;
next	1.127.2.9;

1.127.2.9
date	2003.12.21.23.13.59;	author kettenis;	state Exp;
branches;
next	1.127.2.10;

1.127.2.10
date	2003.12.31.20.20.07;	author kettenis;	state Exp;
branches;
next	1.127.2.11;

1.127.2.11
date	2003.12.31.20.46.51;	author kettenis;	state Exp;
branches;
next	1.127.2.12;

1.127.2.12
date	2004.01.01.21.06.17;	author kettenis;	state Exp;
branches;
next	;

1.113.4.1
date	2003.06.29.21.15.29;	author drow;	state Exp;
branches;
next	1.113.4.2;

1.113.4.2
date	2003.07.07.15.57.29;	author drow;	state Exp;
branches;
next	;

1.98.4.1
date	2003.06.03.20.54.39;	author cagney;	state Exp;
branches;
next	;

1.89.2.1
date	2003.05.04.11.37.45;	author kettenis;	state Exp;
branches;
next	1.89.2.2;

1.89.2.2
date	2003.05.18.09.44.21;	author kettenis;	state Exp;
branches;
next	;

1.85.2.1
date	2003.04.10.21.33.50;	author cagney;	state Exp;
branches;
next	;

1.77.2.1
date	2003.03.30.16.35.22;	author cagney;	state Exp;
branches;
next	;

1.69.4.1
date	2003.03.16.14.01.51;	author kettenis;	state Exp;
branches;
next	;

1.39.8.1
date	2002.11.15.19.18.56;	author carlton;	state Exp;
branches;
next	1.39.8.2;

1.39.8.2
date	2002.12.23.19.38.44;	author carlton;	state Exp;
branches;
next	1.39.8.3;

1.39.8.3
date	2003.02.07.19.17.52;	author carlton;	state Exp;
branches;
next	1.39.8.4;

1.39.8.4
date	2003.03.06.00.56.32;	author carlton;	state Exp;
branches;
next	1.39.8.5;

1.39.8.5
date	2003.04.16.19.56.54;	author carlton;	state Exp;
branches;
next	1.39.8.6;

1.39.8.6
date	2003.05.01.00.46.52;	author carlton;	state Exp;
branches;
next	1.39.8.7;

1.39.8.7
date	2003.05.23.18.40.45;	author carlton;	state Exp;
branches;
next	1.39.8.8;

1.39.8.8
date	2003.06.27.21.50.10;	author carlton;	state Exp;
branches;
next	1.39.8.9;

1.39.8.9
date	2003.08.05.17.13.14;	author carlton;	state Exp;
branches;
next	1.39.8.10;

1.39.8.10
date	2003.09.17.21.28.32;	author carlton;	state Exp;
branches;
next	1.39.8.11;

1.39.8.11
date	2003.11.11.23.50.56;	author carlton;	state Exp;
branches;
next	1.39.8.12;

1.39.8.12
date	2003.12.16.00.00.48;	author carlton;	state Exp;
branches;
next	1.39.8.13;

1.39.8.13
date	2004.01.26.19.11.31;	author carlton;	state Exp;
branches;
next	;

1.39.10.1
date	2003.12.14.20.27.30;	author drow;	state Exp;
branches;
next	1.39.10.2;

1.39.10.2
date	2004.01.13.16.12.00;	author drow;	state Exp;
branches;
next	1.39.10.3;

1.39.10.3
date	2004.02.09.19.43.48;	author drow;	state Exp;
branches;
next	;

1.34.4.1
date	2002.06.15.16.42.55;	author cagney;	state Exp;
branches;
next	1.34.4.2;

1.34.4.2
date	2002.06.21.16.19.32;	author cagney;	state Exp;
branches;
next	;

1.34.6.1
date	2002.06.20.01.33.02;	author kseitz;	state Exp;
branches;
next	1.34.6.2;

1.34.6.2
date	2002.08.09.18.34.27;	author kseitz;	state Exp;
branches;
next	1.34.6.3;

1.34.6.3
date	2002.08.30.22.52.45;	author kseitz;	state Exp;
branches;
next	1.34.6.4;

1.34.6.4
date	2002.11.04.00.17.33;	author ezannoni;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.05;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.25.22;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.05.05.14.42.57;	author shebs;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.07.07.17.23.13;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.07.07.20.10.09;	author jsm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.08.09.21.33.55;	author jsm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	99.10.05.23.08.51;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.233
log
@	* objfiles.h (pc_in_section): New prototype.
	(in_plt_section): Remove name argument, replace prototype with
	static inline function.
	* mips-tdep.h: Include "objfiles.h".
	(in_mips_stubs_section): New function.
	* hppa-tdep.h (gdbarch_tdep): Remove name argument of
	in_solib_call_trampoline member.
	(hppa_in_solib_call_trampoline): Remove name argument.
	* objfiles.c (pc_in_section): New function.
	(in_plt_section): Remove function.
	* mips-linux-tdep.c: Include "objfiles.h".
	(mips_linux_in_dynsym_stub): Call in_mips_stubs_section.  Remove
	name argument.  Return 1 rather than the low 16-bit halfword of
	any instruction examined.
	(mips_linux_in_dynsym_resolve_code): Update
	mips_linux_in_dynsym_stub call accordingly.
	* mips-tdep.c (mips_stub_frame_sniffer): Use in_mips_stubs_section
	rather than an equivalent hand-coded sequence.
	* hppa-hpux-tdep.c (in_opd_section): Remove function.
	(hppa32_hpux_in_solib_call_trampoline): Remove name argument.
	(hppa64_hpux_in_solib_call_trampoline): Likewise.
	(hppa64_hpux_find_global_pointer): Use pc_in_section rather than
	in_opd_section.
	* hppa-tdep.c (hppa_stub_unwind_sniffer): Remove name argument
	on call to tdep->in_solib_call_trampoline.
	(hppa_in_solib_call_trampoline): Remove name argument, update
	according to in_plt_section change.
	(hppa_skip_trampoline_code): Update according to in_plt_section
	change.
	* aarch64-tdep.c (aarch64_stub_unwind_sniffer): Likewise.
	* arm-symbian-tdep.c (arm_symbian_skip_trampoline_code):
	Likewise.
	* arm-tdep.c (arm_stub_unwind_sniffer): Likewise.
	* hppa-linux-tdep.c (hppa_linux_find_global_pointer): Likewise.
	* hppabsd-tdep.c (hppabsd_find_global_pointer): Likewise.
	* nios2-tdep.c (nios2_stub_frame_sniffer): Likewise.
	* nto-tdep.c (nto_relocate_section_addresses): Likewise.
	* s390-tdep.c (s390_stub_frame_sniffer): Likewise.
	* sh-tdep.c (sh_stub_unwind_sniffer): Likewise.
	* solib-dsbt.c (dsbt_in_dynsym_resolve_code): Likewise.
	* solib-frv.c (frv_in_dynsym_resolve_code): Likewise.
	* solib-svr4.c (svr4_in_dynsym_resolve_code): Likewise.
	* solib-target.c (solib_target_in_dynsym_resolve_code): Likewise.
	* sparc-tdep.c (sparc_analyze_prologue): Likewise.
	* tic6x-tdep.c (tic6x_stub_unwind_sniffer): Likewise.
@
text
@/* Target-dependent code for SPARC.

   Copyright (C) 2003-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "arch-utils.h"
#include "dis-asm.h"
#include "dwarf2-frame.h"
#include "floatformat.h"
#include "frame.h"
#include "frame-base.h"
#include "frame-unwind.h"
#include "gdbcore.h"
#include "gdbtypes.h"
#include "inferior.h"
#include "symtab.h"
#include "objfiles.h"
#include "osabi.h"
#include "regcache.h"
#include "target.h"
#include "value.h"

#include "gdb_assert.h"
#include "gdb_string.h"

#include "sparc-tdep.h"
#include "sparc-ravenscar-thread.h"

struct regset;

/* This file implements the SPARC 32-bit ABI as defined by the section
   "Low-Level System Information" of the SPARC Compliance Definition
   (SCD) 2.4.1, which is the 32-bit System V psABI for SPARC.  The SCD
   lists changes with respect to the original 32-bit psABI as defined
   in the "System V ABI, SPARC Processor Supplement".

   Note that if we talk about SunOS, we mean SunOS 4.x, which was
   BSD-based, which is sometimes (retroactively?) referred to as
   Solaris 1.x.  If we talk about Solaris we mean Solaris 2.x and
   above (Solaris 7, 8 and 9 are nothing but Solaris 2.7, 2.8 and 2.9
   suffering from severe version number inflation).  Solaris 2.x is
   also known as SunOS 5.x, since that's what uname(1) says.  Solaris
   2.x is SVR4-based.  */

/* Please use the sparc32_-prefix for 32-bit specific code, the
   sparc64_-prefix for 64-bit specific code and the sparc_-prefix for
   code that can handle both.  The 64-bit specific code lives in
   sparc64-tdep.c; don't add any here.  */

/* The SPARC Floating-Point Quad-Precision format is similar to
   big-endian IA-64 Quad-Precision format.  */
#define floatformats_sparc_quad floatformats_ia64_quad

/* The stack pointer is offset from the stack frame by a BIAS of 2047
   (0x7ff) for 64-bit code.  BIAS is likely to be defined on SPARC
   hosts, so undefine it first.  */
#undef BIAS
#define BIAS 2047

/* Macros to extract fields from SPARC instructions.  */
#define X_OP(i) (((i) >> 30) & 0x3)
#define X_RD(i) (((i) >> 25) & 0x1f)
#define X_A(i) (((i) >> 29) & 1)
#define X_COND(i) (((i) >> 25) & 0xf)
#define X_OP2(i) (((i) >> 22) & 0x7)
#define X_IMM22(i) ((i) & 0x3fffff)
#define X_OP3(i) (((i) >> 19) & 0x3f)
#define X_RS1(i) (((i) >> 14) & 0x1f)
#define X_RS2(i) ((i) & 0x1f)
#define X_I(i) (((i) >> 13) & 1)
/* Sign extension macros.  */
#define X_DISP22(i) ((X_IMM22 (i) ^ 0x200000) - 0x200000)
#define X_DISP19(i) ((((i) & 0x7ffff) ^ 0x40000) - 0x40000)
#define X_DISP10(i) ((((((i) >> 11) && 0x300) | (((i) >> 5) & 0xff)) ^ 0x200) - 0x200)
#define X_SIMM13(i) ((((i) & 0x1fff) ^ 0x1000) - 0x1000)

/* Fetch the instruction at PC.  Instructions are always big-endian
   even if the processor operates in little-endian mode.  */

unsigned long
sparc_fetch_instruction (CORE_ADDR pc)
{
  gdb_byte buf[4];
  unsigned long insn;
  int i;

  /* If we can't read the instruction at PC, return zero.  */
  if (target_read_memory (pc, buf, sizeof (buf)))
    return 0;

  insn = 0;
  for (i = 0; i < sizeof (buf); i++)
    insn = (insn << 8) | buf[i];
  return insn;
}


/* Return non-zero if the instruction corresponding to PC is an "unimp"
   instruction.  */

static int
sparc_is_unimp_insn (CORE_ADDR pc)
{
  const unsigned long insn = sparc_fetch_instruction (pc);
  
  return ((insn & 0xc1c00000) == 0);
}

/* OpenBSD/sparc includes StackGhost, which according to the author's
   website http://stackghost.cerias.purdue.edu "... transparently and
   automatically protects applications' stack frames; more
   specifically, it guards the return pointers.  The protection
   mechanisms require no application source or binary modification and
   imposes only a negligible performance penalty."

   The same website provides the following description of how
   StackGhost works:

   "StackGhost interfaces with the kernel trap handler that would
   normally write out registers to the stack and the handler that
   would read them back in.  By XORing a cookie into the
   return-address saved in the user stack when it is actually written
   to the stack, and then XOR it out when the return-address is pulled
   from the stack, StackGhost can cause attacker corrupted return
   pointers to behave in a manner the attacker cannot predict.
   StackGhost can also use several unused bits in the return pointer
   to detect a smashed return pointer and abort the process."

   For GDB this means that whenever we're reading %i7 from a stack
   frame's window save area, we'll have to XOR the cookie.

   More information on StackGuard can be found on in:

   Mike Frantzen and Mike Shuey.  "StackGhost: Hardware Facilitated
   Stack Protection."  2001.  Published in USENIX Security Symposium
   '01.  */

/* Fetch StackGhost Per-Process XOR cookie.  */

ULONGEST
sparc_fetch_wcookie (struct gdbarch *gdbarch)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  struct target_ops *ops = &current_target;
  gdb_byte buf[8];
  int len;

  len = target_read (ops, TARGET_OBJECT_WCOOKIE, NULL, buf, 0, 8);
  if (len == -1)
    return 0;

  /* We should have either an 32-bit or an 64-bit cookie.  */
  gdb_assert (len == 4 || len == 8);

  return extract_unsigned_integer (buf, len, byte_order);
}


/* The functions on this page are intended to be used to classify
   function arguments.  */

/* Check whether TYPE is "Integral or Pointer".  */

static int
sparc_integral_or_pointer_p (const struct type *type)
{
  int len = TYPE_LENGTH (type);

  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_INT:
    case TYPE_CODE_BOOL:
    case TYPE_CODE_CHAR:
    case TYPE_CODE_ENUM:
    case TYPE_CODE_RANGE:
      /* We have byte, half-word, word and extended-word/doubleword
	 integral types.  The doubleword is an extension to the
	 original 32-bit ABI by the SCD 2.4.x.  */
      return (len == 1 || len == 2 || len == 4 || len == 8);
    case TYPE_CODE_PTR:
    case TYPE_CODE_REF:
      /* Allow either 32-bit or 64-bit pointers.  */
      return (len == 4 || len == 8);
    default:
      break;
    }

  return 0;
}

/* Check whether TYPE is "Floating".  */

static int
sparc_floating_p (const struct type *type)
{
  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_FLT:
      {
	int len = TYPE_LENGTH (type);
	return (len == 4 || len == 8 || len == 16);
      }
    default:
      break;
    }

  return 0;
}

/* Check whether TYPE is "Complex Floating".  */

static int
sparc_complex_floating_p (const struct type *type)
{
  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_COMPLEX:
      {
	int len = TYPE_LENGTH (type);
	return (len == 8 || len == 16 || len == 32);
      }
    default:
      break;
    }

  return 0;
}

/* Check whether TYPE is "Structure or Union".

   In terms of Ada subprogram calls, arrays are treated the same as
   struct and union types.  So this function also returns non-zero
   for array types.  */

static int
sparc_structure_or_union_p (const struct type *type)
{
  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_STRUCT:
    case TYPE_CODE_UNION:
    case TYPE_CODE_ARRAY:
      return 1;
    default:
      break;
    }

  return 0;
}

/* Register information.  */

static const char *sparc32_register_names[] =
{
  "g0", "g1", "g2", "g3", "g4", "g5", "g6", "g7",
  "o0", "o1", "o2", "o3", "o4", "o5", "sp", "o7",
  "l0", "l1", "l2", "l3", "l4", "l5", "l6", "l7",
  "i0", "i1", "i2", "i3", "i4", "i5", "fp", "i7",

  "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7",
  "f8", "f9", "f10", "f11", "f12", "f13", "f14", "f15",
  "f16", "f17", "f18", "f19", "f20", "f21", "f22", "f23",
  "f24", "f25", "f26", "f27", "f28", "f29", "f30", "f31",

  "y", "psr", "wim", "tbr", "pc", "npc", "fsr", "csr"
};

/* Total number of registers.  */
#define SPARC32_NUM_REGS ARRAY_SIZE (sparc32_register_names)

/* We provide the aliases %d0..%d30 for the floating registers as
   "psuedo" registers.  */

static const char *sparc32_pseudo_register_names[] =
{
  "d0", "d2", "d4", "d6", "d8", "d10", "d12", "d14",
  "d16", "d18", "d20", "d22", "d24", "d26", "d28", "d30"
};

/* Total number of pseudo registers.  */
#define SPARC32_NUM_PSEUDO_REGS ARRAY_SIZE (sparc32_pseudo_register_names)

/* Return the name of register REGNUM.  */

static const char *
sparc32_register_name (struct gdbarch *gdbarch, int regnum)
{
  if (regnum >= 0 && regnum < SPARC32_NUM_REGS)
    return sparc32_register_names[regnum];

  if (regnum < SPARC32_NUM_REGS + SPARC32_NUM_PSEUDO_REGS)
    return sparc32_pseudo_register_names[regnum - SPARC32_NUM_REGS];

  return NULL;
}

/* Construct types for ISA-specific registers.  */

static struct type *
sparc_psr_type (struct gdbarch *gdbarch)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  if (!tdep->sparc_psr_type)
    {
      struct type *type;

      type = arch_flags_type (gdbarch, "builtin_type_sparc_psr", 4);
      append_flags_type_flag (type, 5, "ET");
      append_flags_type_flag (type, 6, "PS");
      append_flags_type_flag (type, 7, "S");
      append_flags_type_flag (type, 12, "EF");
      append_flags_type_flag (type, 13, "EC");

      tdep->sparc_psr_type = type;
    }

  return tdep->sparc_psr_type;
}

static struct type *
sparc_fsr_type (struct gdbarch *gdbarch)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  if (!tdep->sparc_fsr_type)
    {
      struct type *type;

      type = arch_flags_type (gdbarch, "builtin_type_sparc_fsr", 4);
      append_flags_type_flag (type, 0, "NXA");
      append_flags_type_flag (type, 1, "DZA");
      append_flags_type_flag (type, 2, "UFA");
      append_flags_type_flag (type, 3, "OFA");
      append_flags_type_flag (type, 4, "NVA");
      append_flags_type_flag (type, 5, "NXC");
      append_flags_type_flag (type, 6, "DZC");
      append_flags_type_flag (type, 7, "UFC");
      append_flags_type_flag (type, 8, "OFC");
      append_flags_type_flag (type, 9, "NVC");
      append_flags_type_flag (type, 22, "NS");
      append_flags_type_flag (type, 23, "NXM");
      append_flags_type_flag (type, 24, "DZM");
      append_flags_type_flag (type, 25, "UFM");
      append_flags_type_flag (type, 26, "OFM");
      append_flags_type_flag (type, 27, "NVM");

      tdep->sparc_fsr_type = type;
    }

  return tdep->sparc_fsr_type;
}

/* Return the GDB type object for the "standard" data type of data in
   register REGNUM.  */

static struct type *
sparc32_register_type (struct gdbarch *gdbarch, int regnum)
{
  if (regnum >= SPARC_F0_REGNUM && regnum <= SPARC_F31_REGNUM)
    return builtin_type (gdbarch)->builtin_float;

  if (regnum >= SPARC32_D0_REGNUM && regnum <= SPARC32_D30_REGNUM)
    return builtin_type (gdbarch)->builtin_double;

  if (regnum == SPARC_SP_REGNUM || regnum == SPARC_FP_REGNUM)
    return builtin_type (gdbarch)->builtin_data_ptr;

  if (regnum == SPARC32_PC_REGNUM || regnum == SPARC32_NPC_REGNUM)
    return builtin_type (gdbarch)->builtin_func_ptr;

  if (regnum == SPARC32_PSR_REGNUM)
    return sparc_psr_type (gdbarch);

  if (regnum == SPARC32_FSR_REGNUM)
    return sparc_fsr_type (gdbarch);

  return builtin_type (gdbarch)->builtin_int32;
}

static enum register_status
sparc32_pseudo_register_read (struct gdbarch *gdbarch,
			      struct regcache *regcache,
			      int regnum, gdb_byte *buf)
{
  enum register_status status;

  gdb_assert (regnum >= SPARC32_D0_REGNUM && regnum <= SPARC32_D30_REGNUM);

  regnum = SPARC_F0_REGNUM + 2 * (regnum - SPARC32_D0_REGNUM);
  status = regcache_raw_read (regcache, regnum, buf);
  if (status == REG_VALID)
    status = regcache_raw_read (regcache, regnum + 1, buf + 4);
  return status;
}

static void
sparc32_pseudo_register_write (struct gdbarch *gdbarch,
			       struct regcache *regcache,
			       int regnum, const gdb_byte *buf)
{
  gdb_assert (regnum >= SPARC32_D0_REGNUM && regnum <= SPARC32_D30_REGNUM);

  regnum = SPARC_F0_REGNUM + 2 * (regnum - SPARC32_D0_REGNUM);
  regcache_raw_write (regcache, regnum, buf);
  regcache_raw_write (regcache, regnum + 1, buf + 4);
}


static CORE_ADDR
sparc32_frame_align (struct gdbarch *gdbarch, CORE_ADDR address)
{
  /* The ABI requires double-word alignment.  */
  return address & ~0x7;
}

static CORE_ADDR
sparc32_push_dummy_code (struct gdbarch *gdbarch, CORE_ADDR sp,
			 CORE_ADDR funcaddr,
			 struct value **args, int nargs,
			 struct type *value_type,
			 CORE_ADDR *real_pc, CORE_ADDR *bp_addr,
			 struct regcache *regcache)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);

  *bp_addr = sp - 4;
  *real_pc = funcaddr;

  if (using_struct_return (gdbarch, NULL, value_type))
    {
      gdb_byte buf[4];

      /* This is an UNIMP instruction.  */
      store_unsigned_integer (buf, 4, byte_order,
			      TYPE_LENGTH (value_type) & 0x1fff);
      write_memory (sp - 8, buf, 4);
      return sp - 8;
    }

  return sp - 4;
}

static CORE_ADDR
sparc32_store_arguments (struct regcache *regcache, int nargs,
			 struct value **args, CORE_ADDR sp,
			 int struct_return, CORE_ADDR struct_addr)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  /* Number of words in the "parameter array".  */
  int num_elements = 0;
  int element = 0;
  int i;

  for (i = 0; i < nargs; i++)
    {
      struct type *type = value_type (args[i]);
      int len = TYPE_LENGTH (type);

      if (sparc_structure_or_union_p (type)
	  || (sparc_floating_p (type) && len == 16)
	  || sparc_complex_floating_p (type))
	{
	  /* Structure, Union and Quad-Precision Arguments.  */
	  sp -= len;

	  /* Use doubleword alignment for these values.  That's always
             correct, and wasting a few bytes shouldn't be a problem.  */
	  sp &= ~0x7;

	  write_memory (sp, value_contents (args[i]), len);
	  args[i] = value_from_pointer (lookup_pointer_type (type), sp);
	  num_elements++;
	}
      else if (sparc_floating_p (type))
	{
	  /* Floating arguments.  */
	  gdb_assert (len == 4 || len == 8);
	  num_elements += (len / 4);
	}
      else
	{
	  /* Integral and pointer arguments.  */
	  gdb_assert (sparc_integral_or_pointer_p (type));

	  if (len < 4)
	    args[i] = value_cast (builtin_type (gdbarch)->builtin_int32,
				  args[i]);
	  num_elements += ((len + 3) / 4);
	}
    }

  /* Always allocate at least six words.  */
  sp -= max (6, num_elements) * 4;

  /* The psABI says that "Software convention requires space for the
     struct/union return value pointer, even if the word is unused."  */
  sp -= 4;

  /* The psABI says that "Although software convention and the
     operating system require every stack frame to be doubleword
     aligned."  */
  sp &= ~0x7;

  for (i = 0; i < nargs; i++)
    {
      const bfd_byte *valbuf = value_contents (args[i]);
      struct type *type = value_type (args[i]);
      int len = TYPE_LENGTH (type);

      gdb_assert (len == 4 || len == 8);

      if (element < 6)
	{
	  int regnum = SPARC_O0_REGNUM + element;

	  regcache_cooked_write (regcache, regnum, valbuf);
	  if (len > 4 && element < 5)
	    regcache_cooked_write (regcache, regnum + 1, valbuf + 4);
	}

      /* Always store the argument in memory.  */
      write_memory (sp + 4 + element * 4, valbuf, len);
      element += len / 4;
    }

  gdb_assert (element == num_elements);

  if (struct_return)
    {
      gdb_byte buf[4];

      store_unsigned_integer (buf, 4, byte_order, struct_addr);
      write_memory (sp, buf, 4);
    }

  return sp;
}

static CORE_ADDR
sparc32_push_dummy_call (struct gdbarch *gdbarch, struct value *function,
			 struct regcache *regcache, CORE_ADDR bp_addr,
			 int nargs, struct value **args, CORE_ADDR sp,
			 int struct_return, CORE_ADDR struct_addr)
{
  CORE_ADDR call_pc = (struct_return ? (bp_addr - 12) : (bp_addr - 8));

  /* Set return address.  */
  regcache_cooked_write_unsigned (regcache, SPARC_O7_REGNUM, call_pc);

  /* Set up function arguments.  */
  sp = sparc32_store_arguments (regcache, nargs, args, sp,
				struct_return, struct_addr);

  /* Allocate the 16-word window save area.  */
  sp -= 16 * 4;

  /* Stack should be doubleword aligned at this point.  */
  gdb_assert (sp % 8 == 0);

  /* Finally, update the stack pointer.  */
  regcache_cooked_write_unsigned (regcache, SPARC_SP_REGNUM, sp);

  return sp;
}


/* Use the program counter to determine the contents and size of a
   breakpoint instruction.  Return a pointer to a string of bytes that
   encode a breakpoint instruction, store the length of the string in
   *LEN and optionally adjust *PC to point to the correct memory
   location for inserting the breakpoint.  */
   
static const gdb_byte *
sparc_breakpoint_from_pc (struct gdbarch *gdbarch, CORE_ADDR *pc, int *len)
{
  static const gdb_byte break_insn[] = { 0x91, 0xd0, 0x20, 0x01 };

  *len = sizeof (break_insn);
  return break_insn;
}


/* Allocate and initialize a frame cache.  */

static struct sparc_frame_cache *
sparc_alloc_frame_cache (void)
{
  struct sparc_frame_cache *cache;

  cache = FRAME_OBSTACK_ZALLOC (struct sparc_frame_cache);

  /* Base address.  */
  cache->base = 0;
  cache->pc = 0;

  /* Frameless until proven otherwise.  */
  cache->frameless_p = 1;
  cache->frame_offset = 0;
  cache->saved_regs_mask = 0;
  cache->copied_regs_mask = 0;
  cache->struct_return_p = 0;

  return cache;
}

/* GCC generates several well-known sequences of instructions at the begining
   of each function prologue when compiling with -fstack-check.  If one of
   such sequences starts at START_PC, then return the address of the
   instruction immediately past this sequence.  Otherwise, return START_PC.  */
   
static CORE_ADDR
sparc_skip_stack_check (const CORE_ADDR start_pc)
{
  CORE_ADDR pc = start_pc;
  unsigned long insn;
  int offset_stack_checking_sequence = 0;
  int probing_loop = 0;

  /* With GCC, all stack checking sequences begin with the same two
     instructions, plus an optional one in the case of a probing loop:

         sethi <some immediate>, %g1
         sub %sp, %g1, %g1

     or:

         sethi <some immediate>, %g1
         sethi <some immediate>, %g4
         sub %sp, %g1, %g1

     or:

         sethi <some immediate>, %g1
         sub %sp, %g1, %g1
         sethi <some immediate>, %g4

     If the optional instruction is found (setting g4), assume that a
     probing loop will follow.  */

  /* sethi <some immediate>, %g1 */
  insn = sparc_fetch_instruction (pc);
  pc = pc + 4;
  if (!(X_OP (insn) == 0 && X_OP2 (insn) == 0x4 && X_RD (insn) == 1))
    return start_pc;

  /* optional: sethi <some immediate>, %g4 */
  insn = sparc_fetch_instruction (pc);
  pc = pc + 4;
  if (X_OP (insn) == 0 && X_OP2 (insn) == 0x4 && X_RD (insn) == 4)
    {
      probing_loop = 1;
      insn = sparc_fetch_instruction (pc);
      pc = pc + 4;
    }

  /* sub %sp, %g1, %g1 */
  if (!(X_OP (insn) == 2 && X_OP3 (insn) == 0x4 && !X_I(insn)
        && X_RD (insn) == 1 && X_RS1 (insn) == 14 && X_RS2 (insn) == 1))
    return start_pc;

  insn = sparc_fetch_instruction (pc);
  pc = pc + 4;

  /* optional: sethi <some immediate>, %g4 */
  if (X_OP (insn) == 0 && X_OP2 (insn) == 0x4 && X_RD (insn) == 4)
    {
      probing_loop = 1;
      insn = sparc_fetch_instruction (pc);
      pc = pc + 4;
    }

  /* First possible sequence:
         [first two instructions above]
         clr [%g1 - some immediate]  */

  /* clr [%g1 - some immediate]  */
  if (X_OP (insn) == 3 && X_OP3(insn) == 0x4 && X_I(insn)
      && X_RS1 (insn) == 1 && X_RD (insn) == 0)
    {
      /* Valid stack-check sequence, return the new PC.  */
      return pc;
    }

  /* Second possible sequence: A small number of probes.
         [first two instructions above]
         clr [%g1]
         add   %g1, -<some immediate>, %g1
         clr [%g1]
         [repeat the two instructions above any (small) number of times]
         clr [%g1 - some immediate]  */

  /* clr [%g1] */
  else if (X_OP (insn) == 3 && X_OP3(insn) == 0x4 && !X_I(insn)
      && X_RS1 (insn) == 1 && X_RD (insn) == 0)
    {
      while (1)
        {
          /* add %g1, -<some immediate>, %g1 */
          insn = sparc_fetch_instruction (pc);
          pc = pc + 4;
          if (!(X_OP (insn) == 2  && X_OP3(insn) == 0 && X_I(insn)
                && X_RS1 (insn) == 1 && X_RD (insn) == 1))
            break;

          /* clr [%g1] */
          insn = sparc_fetch_instruction (pc);
          pc = pc + 4;
          if (!(X_OP (insn) == 3 && X_OP3(insn) == 0x4 && !X_I(insn)
                && X_RD (insn) == 0 && X_RS1 (insn) == 1))
            return start_pc;
        }

      /* clr [%g1 - some immediate] */
      if (!(X_OP (insn) == 3 && X_OP3(insn) == 0x4 && X_I(insn)
            && X_RS1 (insn) == 1 && X_RD (insn) == 0))
        return start_pc;

      /* We found a valid stack-check sequence, return the new PC.  */
      return pc;
    }
  
  /* Third sequence: A probing loop.
         [first three instructions above]
         sub  %g1, %g4, %g4
         cmp  %g1, %g4
         be  <disp>
         add  %g1, -<some immediate>, %g1
         ba  <disp>
         clr  [%g1]

     And an optional last probe for the remainder:

         clr [%g4 - some immediate]  */

  if (probing_loop)
    {
      /* sub  %g1, %g4, %g4 */
      if (!(X_OP (insn) == 2 && X_OP3 (insn) == 0x4 && !X_I(insn)
            && X_RD (insn) == 4 && X_RS1 (insn) == 1 && X_RS2 (insn) == 4))
        return start_pc;

      /* cmp  %g1, %g4 */
      insn = sparc_fetch_instruction (pc);
      pc = pc + 4;
      if (!(X_OP (insn) == 2 && X_OP3 (insn) == 0x14 && !X_I(insn)
            && X_RD (insn) == 0 && X_RS1 (insn) == 1 && X_RS2 (insn) == 4))
        return start_pc;

      /* be  <disp> */
      insn = sparc_fetch_instruction (pc);
      pc = pc + 4;
      if (!(X_OP (insn) == 0 && X_COND (insn) == 0x1))
        return start_pc;

      /* add  %g1, -<some immediate>, %g1 */
      insn = sparc_fetch_instruction (pc);
      pc = pc + 4;
      if (!(X_OP (insn) == 2  && X_OP3(insn) == 0 && X_I(insn)
            && X_RS1 (insn) == 1 && X_RD (insn) == 1))
        return start_pc;

      /* ba  <disp> */
      insn = sparc_fetch_instruction (pc);
      pc = pc + 4;
      if (!(X_OP (insn) == 0 && X_COND (insn) == 0x8))
        return start_pc;

      /* clr  [%g1] (st %g0, [%g1] or st %g0, [%g1+0]) */
      insn = sparc_fetch_instruction (pc);
      pc = pc + 4;
      if (!(X_OP (insn) == 3 && X_OP3(insn) == 0x4
            && X_RD (insn) == 0 && X_RS1 (insn) == 1
	    && (!X_I(insn) || X_SIMM13 (insn) == 0)))
        return start_pc;

      /* We found a valid stack-check sequence, return the new PC.  */

      /* optional: clr [%g4 - some immediate]  */
      insn = sparc_fetch_instruction (pc);
      pc = pc + 4;
      if (!(X_OP (insn) == 3 && X_OP3(insn) == 0x4 && X_I(insn)
            && X_RS1 (insn) == 4 && X_RD (insn) == 0))
        return pc - 4;
      else
	return pc;
    }

  /* No stack check code in our prologue, return the start_pc.  */
  return start_pc;
}

/* Record the effect of a SAVE instruction on CACHE.  */

void
sparc_record_save_insn (struct sparc_frame_cache *cache)
{
  /* The frame is set up.  */
  cache->frameless_p = 0;

  /* The frame pointer contains the CFA.  */
  cache->frame_offset = 0;

  /* The `local' and `in' registers are all saved.  */
  cache->saved_regs_mask = 0xffff;

  /* The `out' registers are all renamed.  */
  cache->copied_regs_mask = 0xff;
}

/* Do a full analysis of the prologue at PC and update CACHE accordingly.
   Bail out early if CURRENT_PC is reached.  Return the address where
   the analysis stopped.

   We handle both the traditional register window model and the single
   register window (aka flat) model.  */

CORE_ADDR
sparc_analyze_prologue (struct gdbarch *gdbarch, CORE_ADDR pc,
			CORE_ADDR current_pc, struct sparc_frame_cache *cache)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  unsigned long insn;
  int offset = 0;
  int dest = -1;

  pc = sparc_skip_stack_check (pc);

  if (current_pc <= pc)
    return current_pc;

  /* We have to handle to "Procedure Linkage Table" (PLT) special.  On
     SPARC the linker usually defines a symbol (typically
     _PROCEDURE_LINKAGE_TABLE_) at the start of the .plt section.
     This symbol makes us end up here with PC pointing at the start of
     the PLT and CURRENT_PC probably pointing at a PLT entry.  If we
     would do our normal prologue analysis, we would probably conclude
     that we've got a frame when in reality we don't, since the
     dynamic linker patches up the first PLT with some code that
     starts with a SAVE instruction.  Patch up PC such that it points
     at the start of our PLT entry.  */
  if (tdep->plt_entry_size > 0 && in_plt_section (current_pc))
    pc = current_pc - ((current_pc - pc) % tdep->plt_entry_size);

  insn = sparc_fetch_instruction (pc);

  /* Recognize store insns and record their sources.  */
  while (X_OP (insn) == 3
	 && (X_OP3 (insn) == 0x4     /* stw */
	     || X_OP3 (insn) == 0x7  /* std */
	     || X_OP3 (insn) == 0xe) /* stx */
	 && X_RS1 (insn) == SPARC_SP_REGNUM)
    {
      int regnum = X_RD (insn);

      /* Recognize stores into the corresponding stack slots.  */
      if (regnum >= SPARC_L0_REGNUM && regnum <= SPARC_I7_REGNUM
	  && ((X_I (insn)
	       && X_SIMM13 (insn) == (X_OP3 (insn) == 0xe
				      ? (regnum - SPARC_L0_REGNUM) * 8 + BIAS
				      : (regnum - SPARC_L0_REGNUM) * 4))
	      || (!X_I (insn) && regnum == SPARC_L0_REGNUM)))
	{
	  cache->saved_regs_mask |= (1 << (regnum - SPARC_L0_REGNUM));
	  if (X_OP3 (insn) == 0x7)
	    cache->saved_regs_mask |= (1 << (regnum + 1 - SPARC_L0_REGNUM));
	}

      offset += 4;

      insn = sparc_fetch_instruction (pc + offset);
    }

  /* Recognize a SETHI insn and record its destination.  */
  if (X_OP (insn) == 0 && X_OP2 (insn) == 0x04)
    {
      dest = X_RD (insn);
      offset += 4;

      insn = sparc_fetch_instruction (pc + offset);
    }

  /* Allow for an arithmetic operation on DEST or %g1.  */
  if (X_OP (insn) == 2 && X_I (insn)
      && (X_RD (insn) == 1 || X_RD (insn) == dest))
    {
      offset += 4;

      insn = sparc_fetch_instruction (pc + offset);
    }

  /* Check for the SAVE instruction that sets up the frame.  */
  if (X_OP (insn) == 2 && X_OP3 (insn) == 0x3c)
    {
      sparc_record_save_insn (cache);
      offset += 4;
      return pc + offset;
    }

  /* Check for an arithmetic operation on %sp.  */
  if (X_OP (insn) == 2
      && (X_OP3 (insn) == 0 || X_OP3 (insn) == 0x4)
      && X_RS1 (insn) == SPARC_SP_REGNUM
      && X_RD (insn) == SPARC_SP_REGNUM)
    {
      if (X_I (insn))
	{
	  cache->frame_offset = X_SIMM13 (insn);
	  if (X_OP3 (insn) == 0)
	    cache->frame_offset = -cache->frame_offset;
	}
      offset += 4;

      insn = sparc_fetch_instruction (pc + offset);

      /* Check for an arithmetic operation that sets up the frame.  */
      if (X_OP (insn) == 2
	  && (X_OP3 (insn) == 0 || X_OP3 (insn) == 0x4)
	  && X_RS1 (insn) == SPARC_SP_REGNUM
	  && X_RD (insn) == SPARC_FP_REGNUM)
	{
	  cache->frameless_p = 0;
	  cache->frame_offset = 0;
	  /* We could check that the amount subtracted to %sp above is the
	     same as the one added here, but this seems superfluous.  */
	  cache->copied_regs_mask |= 0x40;
	  offset += 4;

	  insn = sparc_fetch_instruction (pc + offset);
	}

      /* Check for a move (or) operation that copies the return register.  */
      if (X_OP (insn) == 2
	  && X_OP3 (insn) == 0x2
	  && !X_I (insn)
	  && X_RS1 (insn) == SPARC_G0_REGNUM
	  && X_RS2 (insn) == SPARC_O7_REGNUM
	  && X_RD (insn) == SPARC_I7_REGNUM)
	{
	   cache->copied_regs_mask |= 0x80;
	   offset += 4;
	}

      return pc + offset;
    }

  return pc;
}

static CORE_ADDR
sparc_unwind_pc (struct gdbarch *gdbarch, struct frame_info *this_frame)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  return frame_unwind_register_unsigned (this_frame, tdep->pc_regnum);
}

/* Return PC of first real instruction of the function starting at
   START_PC.  */

static CORE_ADDR
sparc32_skip_prologue (struct gdbarch *gdbarch, CORE_ADDR start_pc)
{
  struct symtab_and_line sal;
  CORE_ADDR func_start, func_end;
  struct sparc_frame_cache cache;

  /* This is the preferred method, find the end of the prologue by
     using the debugging information.  */
  if (find_pc_partial_function (start_pc, NULL, &func_start, &func_end))
    {
      sal = find_pc_line (func_start, 0);

      if (sal.end < func_end
	  && start_pc <= sal.end)
	return sal.end;
    }

  start_pc = sparc_analyze_prologue (gdbarch, start_pc, 0xffffffffUL, &cache);

  /* The psABI says that "Although the first 6 words of arguments
     reside in registers, the standard stack frame reserves space for
     them.".  It also suggests that a function may use that space to
     "write incoming arguments 0 to 5" into that space, and that's
     indeed what GCC seems to be doing.  In that case GCC will
     generate debug information that points to the stack slots instead
     of the registers, so we should consider the instructions that
     write out these incoming arguments onto the stack.  */

  while (1)
    {
      unsigned long insn = sparc_fetch_instruction (start_pc);

      /* Recognize instructions that store incoming arguments into the
	 corresponding stack slots.  */
      if (X_OP (insn) == 3 && (X_OP3 (insn) & 0x3c) == 0x04
	  && X_I (insn) && X_RS1 (insn) == SPARC_FP_REGNUM)
	{
	  int regnum = X_RD (insn);

	  /* Case of arguments still in %o[0..5].  */
	  if (regnum >= SPARC_O0_REGNUM && regnum <= SPARC_O5_REGNUM
	      && !(cache.copied_regs_mask & (1 << (regnum - SPARC_O0_REGNUM)))
	      && X_SIMM13 (insn) == 68 + (regnum - SPARC_O0_REGNUM) * 4)
	    {
	      start_pc += 4;
	      continue;
	    }

	  /* Case of arguments copied into %i[0..5].  */
	  if (regnum >= SPARC_I0_REGNUM && regnum <= SPARC_I5_REGNUM
	      && (cache.copied_regs_mask & (1 << (regnum - SPARC_I0_REGNUM)))
	      && X_SIMM13 (insn) == 68 + (regnum - SPARC_I0_REGNUM) * 4)
	    {
	      start_pc += 4;
	      continue;
	    }
	}

      break;
    }

  return start_pc;
}

/* Normal frames.  */

struct sparc_frame_cache *
sparc_frame_cache (struct frame_info *this_frame, void **this_cache)
{
  struct sparc_frame_cache *cache;

  if (*this_cache)
    return *this_cache;

  cache = sparc_alloc_frame_cache ();
  *this_cache = cache;

  cache->pc = get_frame_func (this_frame);
  if (cache->pc != 0)
    sparc_analyze_prologue (get_frame_arch (this_frame), cache->pc,
			    get_frame_pc (this_frame), cache);

  if (cache->frameless_p)
    {
      /* This function is frameless, so %fp (%i6) holds the frame
         pointer for our calling frame.  Use %sp (%o6) as this frame's
         base address.  */
      cache->base =
        get_frame_register_unsigned (this_frame, SPARC_SP_REGNUM);
    }
  else
    {
      /* For normal frames, %fp (%i6) holds the frame pointer, the
         base address for the current stack frame.  */
      cache->base =
	get_frame_register_unsigned (this_frame, SPARC_FP_REGNUM);
    }

  cache->base += cache->frame_offset;

  if (cache->base & 1)
    cache->base += BIAS;

  return cache;
}

static int
sparc32_struct_return_from_sym (struct symbol *sym)
{
  struct type *type = check_typedef (SYMBOL_TYPE (sym));
  enum type_code code = TYPE_CODE (type);

  if (code == TYPE_CODE_FUNC || code == TYPE_CODE_METHOD)
    {
      type = check_typedef (TYPE_TARGET_TYPE (type));
      if (sparc_structure_or_union_p (type)
	  || (sparc_floating_p (type) && TYPE_LENGTH (type) == 16))
	return 1;
    }

  return 0;
}

struct sparc_frame_cache *
sparc32_frame_cache (struct frame_info *this_frame, void **this_cache)
{
  struct sparc_frame_cache *cache;
  struct symbol *sym;

  if (*this_cache)
    return *this_cache;

  cache = sparc_frame_cache (this_frame, this_cache);

  sym = find_pc_function (cache->pc);
  if (sym)
    {
      cache->struct_return_p = sparc32_struct_return_from_sym (sym);
    }
  else
    {
      /* There is no debugging information for this function to
         help us determine whether this function returns a struct
         or not.  So we rely on another heuristic which is to check
         the instruction at the return address and see if this is
         an "unimp" instruction.  If it is, then it is a struct-return
         function.  */
      CORE_ADDR pc;
      int regnum =
	(cache->copied_regs_mask & 0x80) ? SPARC_I7_REGNUM : SPARC_O7_REGNUM;

      pc = get_frame_register_unsigned (this_frame, regnum) + 8;
      if (sparc_is_unimp_insn (pc))
        cache->struct_return_p = 1;
    }

  return cache;
}

static void
sparc32_frame_this_id (struct frame_info *this_frame, void **this_cache,
		       struct frame_id *this_id)
{
  struct sparc_frame_cache *cache =
    sparc32_frame_cache (this_frame, this_cache);

  /* This marks the outermost frame.  */
  if (cache->base == 0)
    return;

  (*this_id) = frame_id_build (cache->base, cache->pc);
}

static struct value *
sparc32_frame_prev_register (struct frame_info *this_frame,
			     void **this_cache, int regnum)
{
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  struct sparc_frame_cache *cache =
    sparc32_frame_cache (this_frame, this_cache);

  if (regnum == SPARC32_PC_REGNUM || regnum == SPARC32_NPC_REGNUM)
    {
      CORE_ADDR pc = (regnum == SPARC32_NPC_REGNUM) ? 4 : 0;

      /* If this functions has a Structure, Union or Quad-Precision
	 return value, we have to skip the UNIMP instruction that encodes
	 the size of the structure.  */
      if (cache->struct_return_p)
	pc += 4;

      regnum =
	(cache->copied_regs_mask & 0x80) ? SPARC_I7_REGNUM : SPARC_O7_REGNUM;
      pc += get_frame_register_unsigned (this_frame, regnum) + 8;
      return frame_unwind_got_constant (this_frame, regnum, pc);
    }

  /* Handle StackGhost.  */
  {
    ULONGEST wcookie = sparc_fetch_wcookie (gdbarch);

    if (wcookie != 0 && !cache->frameless_p && regnum == SPARC_I7_REGNUM)
      {
        CORE_ADDR addr = cache->base + (regnum - SPARC_L0_REGNUM) * 4;
        ULONGEST i7;

        /* Read the value in from memory.  */
        i7 = get_frame_memory_unsigned (this_frame, addr, 4);
        return frame_unwind_got_constant (this_frame, regnum, i7 ^ wcookie);
      }
  }

  /* The previous frame's `local' and `in' registers may have been saved
     in the register save area.  */
  if (regnum >= SPARC_L0_REGNUM && regnum <= SPARC_I7_REGNUM
      && (cache->saved_regs_mask & (1 << (regnum - SPARC_L0_REGNUM))))
    {
      CORE_ADDR addr = cache->base + (regnum - SPARC_L0_REGNUM) * 4;

      return frame_unwind_got_memory (this_frame, regnum, addr);
    }

  /* The previous frame's `out' registers may be accessible as the current
     frame's `in' registers.  */
  if (regnum >= SPARC_O0_REGNUM && regnum <= SPARC_O7_REGNUM
      && (cache->copied_regs_mask & (1 << (regnum - SPARC_O0_REGNUM))))
    regnum += (SPARC_I0_REGNUM - SPARC_O0_REGNUM);

  return frame_unwind_got_register (this_frame, regnum, regnum);
}

static const struct frame_unwind sparc32_frame_unwind =
{
  NORMAL_FRAME,
  default_frame_unwind_stop_reason,
  sparc32_frame_this_id,
  sparc32_frame_prev_register,
  NULL,
  default_frame_sniffer
};


static CORE_ADDR
sparc32_frame_base_address (struct frame_info *this_frame, void **this_cache)
{
  struct sparc_frame_cache *cache =
    sparc32_frame_cache (this_frame, this_cache);

  return cache->base;
}

static const struct frame_base sparc32_frame_base =
{
  &sparc32_frame_unwind,
  sparc32_frame_base_address,
  sparc32_frame_base_address,
  sparc32_frame_base_address
};

static struct frame_id
sparc_dummy_id (struct gdbarch *gdbarch, struct frame_info *this_frame)
{
  CORE_ADDR sp;

  sp = get_frame_register_unsigned (this_frame, SPARC_SP_REGNUM);
  if (sp & 1)
    sp += BIAS;
  return frame_id_build (sp, get_frame_pc (this_frame));
}


/* Extract a function return value of TYPE from REGCACHE, and copy
   that into VALBUF.  */

static void
sparc32_extract_return_value (struct type *type, struct regcache *regcache,
			      gdb_byte *valbuf)
{
  int len = TYPE_LENGTH (type);
  gdb_byte buf[32];

  gdb_assert (!sparc_structure_or_union_p (type));
  gdb_assert (!(sparc_floating_p (type) && len == 16));

  if (sparc_floating_p (type) || sparc_complex_floating_p (type))
    {
      /* Floating return values.  */
      regcache_cooked_read (regcache, SPARC_F0_REGNUM, buf);
      if (len > 4)
	regcache_cooked_read (regcache, SPARC_F1_REGNUM, buf + 4);
      if (len > 8)
	{
	  regcache_cooked_read (regcache, SPARC_F2_REGNUM, buf + 8);
	  regcache_cooked_read (regcache, SPARC_F3_REGNUM, buf + 12);
	}
      if (len > 16)
	{
	  regcache_cooked_read (regcache, SPARC_F4_REGNUM, buf + 16);
	  regcache_cooked_read (regcache, SPARC_F5_REGNUM, buf + 20);
	  regcache_cooked_read (regcache, SPARC_F6_REGNUM, buf + 24);
	  regcache_cooked_read (regcache, SPARC_F7_REGNUM, buf + 28);
	}
      memcpy (valbuf, buf, len);
    }
  else
    {
      /* Integral and pointer return values.  */
      gdb_assert (sparc_integral_or_pointer_p (type));

      regcache_cooked_read (regcache, SPARC_O0_REGNUM, buf);
      if (len > 4)
	{
	  regcache_cooked_read (regcache, SPARC_O1_REGNUM, buf + 4);
	  gdb_assert (len == 8);
	  memcpy (valbuf, buf, 8);
	}
      else
	{
	  /* Just stripping off any unused bytes should preserve the
	     signed-ness just fine.  */
	  memcpy (valbuf, buf + 4 - len, len);
	}
    }
}

/* Store the function return value of type TYPE from VALBUF into
   REGCACHE.  */

static void
sparc32_store_return_value (struct type *type, struct regcache *regcache,
			    const gdb_byte *valbuf)
{
  int len = TYPE_LENGTH (type);
  gdb_byte buf[8];

  gdb_assert (!sparc_structure_or_union_p (type));
  gdb_assert (!(sparc_floating_p (type) && len == 16));
  gdb_assert (len <= 8);

  if (sparc_floating_p (type) || sparc_complex_floating_p (type))
    {
      /* Floating return values.  */
      memcpy (buf, valbuf, len);
      regcache_cooked_write (regcache, SPARC_F0_REGNUM, buf);
      if (len > 4)
	regcache_cooked_write (regcache, SPARC_F1_REGNUM, buf + 4);
      if (len > 8)
	{
	  regcache_cooked_write (regcache, SPARC_F2_REGNUM, buf + 8);
	  regcache_cooked_write (regcache, SPARC_F3_REGNUM, buf + 12);
	}
      if (len > 16)
	{
	  regcache_cooked_write (regcache, SPARC_F4_REGNUM, buf + 16);
	  regcache_cooked_write (regcache, SPARC_F5_REGNUM, buf + 20);
	  regcache_cooked_write (regcache, SPARC_F6_REGNUM, buf + 24);
	  regcache_cooked_write (regcache, SPARC_F7_REGNUM, buf + 28);
	}
    }
  else
    {
      /* Integral and pointer return values.  */
      gdb_assert (sparc_integral_or_pointer_p (type));

      if (len > 4)
	{
	  gdb_assert (len == 8);
	  memcpy (buf, valbuf, 8);
	  regcache_cooked_write (regcache, SPARC_O1_REGNUM, buf + 4);
	}
      else
	{
	  /* ??? Do we need to do any sign-extension here?  */
	  memcpy (buf + 4 - len, valbuf, len);
	}
      regcache_cooked_write (regcache, SPARC_O0_REGNUM, buf);
    }
}

static enum return_value_convention
sparc32_return_value (struct gdbarch *gdbarch, struct value *function,
		      struct type *type, struct regcache *regcache,
		      gdb_byte *readbuf, const gdb_byte *writebuf)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);

  /* The psABI says that "...every stack frame reserves the word at
     %fp+64.  If a function returns a structure, union, or
     quad-precision value, this word should hold the address of the
     object into which the return value should be copied."  This
     guarantees that we can always find the return value, not just
     before the function returns.  */

  if (sparc_structure_or_union_p (type)
      || (sparc_floating_p (type) && TYPE_LENGTH (type) == 16))
    {
      ULONGEST sp;
      CORE_ADDR addr;

      if (readbuf)
	{
	  regcache_cooked_read_unsigned (regcache, SPARC_SP_REGNUM, &sp);
	  addr = read_memory_unsigned_integer (sp + 64, 4, byte_order);
	  read_memory (addr, readbuf, TYPE_LENGTH (type));
	}
      if (writebuf)
	{
	  regcache_cooked_read_unsigned (regcache, SPARC_SP_REGNUM, &sp);
	  addr = read_memory_unsigned_integer (sp + 64, 4, byte_order);
	  write_memory (addr, writebuf, TYPE_LENGTH (type));
	}

      return RETURN_VALUE_ABI_PRESERVES_ADDRESS;
    }

  if (readbuf)
    sparc32_extract_return_value (type, regcache, readbuf);
  if (writebuf)
    sparc32_store_return_value (type, regcache, writebuf);

  return RETURN_VALUE_REGISTER_CONVENTION;
}

static int
sparc32_stabs_argument_has_addr (struct gdbarch *gdbarch, struct type *type)
{
  return (sparc_structure_or_union_p (type)
	  || (sparc_floating_p (type) && TYPE_LENGTH (type) == 16)
	  || sparc_complex_floating_p (type));
}

static int
sparc32_dwarf2_struct_return_p (struct frame_info *this_frame)
{
  CORE_ADDR pc = get_frame_address_in_block (this_frame);
  struct symbol *sym = find_pc_function (pc);

  if (sym)
    return sparc32_struct_return_from_sym (sym);
  return 0;
}

static void
sparc32_dwarf2_frame_init_reg (struct gdbarch *gdbarch, int regnum,
			       struct dwarf2_frame_state_reg *reg,
			       struct frame_info *this_frame)
{
  int off;

  switch (regnum)
    {
    case SPARC_G0_REGNUM:
      /* Since %g0 is always zero, there is no point in saving it, and
	 people will be inclined omit it from the CFI.  Make sure we
	 don't warn about that.  */
      reg->how = DWARF2_FRAME_REG_SAME_VALUE;
      break;
    case SPARC_SP_REGNUM:
      reg->how = DWARF2_FRAME_REG_CFA;
      break;
    case SPARC32_PC_REGNUM:
    case SPARC32_NPC_REGNUM:
      reg->how = DWARF2_FRAME_REG_RA_OFFSET;
      off = 8;
      if (sparc32_dwarf2_struct_return_p (this_frame))
	off += 4;
      if (regnum == SPARC32_NPC_REGNUM)
	off += 4;
      reg->loc.offset = off;
      break;
    }
}


/* The SPARC Architecture doesn't have hardware single-step support,
   and most operating systems don't implement it either, so we provide
   software single-step mechanism.  */

static CORE_ADDR
sparc_analyze_control_transfer (struct frame_info *frame,
				CORE_ADDR pc, CORE_ADDR *npc)
{
  unsigned long insn = sparc_fetch_instruction (pc);
  int conditional_p = X_COND (insn) & 0x7;
  int branch_p = 0, fused_p = 0;
  long offset = 0;			/* Must be signed for sign-extend.  */

  if (X_OP (insn) == 0 && X_OP2 (insn) == 3)
    {
      if ((insn & 0x10000000) == 0)
	{
	  /* Branch on Integer Register with Prediction (BPr).  */
	  branch_p = 1;
	  conditional_p = 1;
	}
      else
	{
	  /* Compare and Branch  */
	  branch_p = 1;
	  fused_p = 1;
	  offset = 4 * X_DISP10 (insn);
	}
    }
  else if (X_OP (insn) == 0 && X_OP2 (insn) == 6)
    {
      /* Branch on Floating-Point Condition Codes (FBfcc).  */
      branch_p = 1;
      offset = 4 * X_DISP22 (insn);
    }
  else if (X_OP (insn) == 0 && X_OP2 (insn) == 5)
    {
      /* Branch on Floating-Point Condition Codes with Prediction
         (FBPfcc).  */
      branch_p = 1;
      offset = 4 * X_DISP19 (insn);
    }
  else if (X_OP (insn) == 0 && X_OP2 (insn) == 2)
    {
      /* Branch on Integer Condition Codes (Bicc).  */
      branch_p = 1;
      offset = 4 * X_DISP22 (insn);
    }
  else if (X_OP (insn) == 0 && X_OP2 (insn) == 1)
    {
      /* Branch on Integer Condition Codes with Prediction (BPcc).  */
      branch_p = 1;
      offset = 4 * X_DISP19 (insn);
    }
  else if (X_OP (insn) == 2 && X_OP3 (insn) == 0x3a)
    {
      /* Trap instruction (TRAP).  */
      return gdbarch_tdep (get_frame_arch (frame))->step_trap (frame, insn);
    }

  /* FIXME: Handle DONE and RETRY instructions.  */

  if (branch_p)
    {
      if (fused_p)
	{
	  /* Fused compare-and-branch instructions are non-delayed,
	     and do not have an annuling capability.  So we need to
	     always set a breakpoint on both the NPC and the branch
	     target address.  */
	  gdb_assert (offset != 0);
	  return pc + offset;
	}
      else if (conditional_p)
	{
	  /* For conditional branches, return nPC + 4 iff the annul
	     bit is 1.  */
	  return (X_A (insn) ? *npc + 4 : 0);
	}
      else
	{
	  /* For unconditional branches, return the target if its
	     specified condition is "always" and return nPC + 4 if the
	     condition is "never".  If the annul bit is 1, set *NPC to
	     zero.  */
	  if (X_COND (insn) == 0x0)
	    pc = *npc, offset = 4;
	  if (X_A (insn))
	    *npc = 0;

	  gdb_assert (offset != 0);
	  return pc + offset;
	}
    }

  return 0;
}

static CORE_ADDR
sparc_step_trap (struct frame_info *frame, unsigned long insn)
{
  return 0;
}

int
sparc_software_single_step (struct frame_info *frame)
{
  struct gdbarch *arch = get_frame_arch (frame);
  struct gdbarch_tdep *tdep = gdbarch_tdep (arch);
  struct address_space *aspace = get_frame_address_space (frame);
  CORE_ADDR npc, nnpc;

  CORE_ADDR pc, orig_npc;

  pc = get_frame_register_unsigned (frame, tdep->pc_regnum);
  orig_npc = npc = get_frame_register_unsigned (frame, tdep->npc_regnum);

  /* Analyze the instruction at PC.  */
  nnpc = sparc_analyze_control_transfer (frame, pc, &npc);
  if (npc != 0)
    insert_single_step_breakpoint (arch, aspace, npc);

  if (nnpc != 0)
    insert_single_step_breakpoint (arch, aspace, nnpc);

  /* Assert that we have set at least one breakpoint, and that
     they're not set at the same spot - unless we're going
     from here straight to NULL, i.e. a call or jump to 0.  */
  gdb_assert (npc != 0 || nnpc != 0 || orig_npc == 0);
  gdb_assert (nnpc != npc || orig_npc == 0);

  return 1;
}

static void
sparc_write_pc (struct regcache *regcache, CORE_ADDR pc)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (get_regcache_arch (regcache));

  regcache_cooked_write_unsigned (regcache, tdep->pc_regnum, pc);
  regcache_cooked_write_unsigned (regcache, tdep->npc_regnum, pc + 4);
}


/* Return the appropriate register set for the core section identified
   by SECT_NAME and SECT_SIZE.  */

static const struct regset *
sparc_regset_from_core_section (struct gdbarch *gdbarch,
				const char *sect_name, size_t sect_size)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  if (strcmp (sect_name, ".reg") == 0 && sect_size >= tdep->sizeof_gregset)
    return tdep->gregset;

  if (strcmp (sect_name, ".reg2") == 0 && sect_size >= tdep->sizeof_fpregset)
    return tdep->fpregset;

  return NULL;
}


static struct gdbarch *
sparc32_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
{
  struct gdbarch_tdep *tdep;
  struct gdbarch *gdbarch;

  /* If there is already a candidate, use it.  */
  arches = gdbarch_list_lookup_by_info (arches, &info);
  if (arches != NULL)
    return arches->gdbarch;

  /* Allocate space for the new architecture.  */
  tdep = XZALLOC (struct gdbarch_tdep);
  gdbarch = gdbarch_alloc (&info, tdep);

  tdep->pc_regnum = SPARC32_PC_REGNUM;
  tdep->npc_regnum = SPARC32_NPC_REGNUM;
  tdep->step_trap = sparc_step_trap;

  set_gdbarch_long_double_bit (gdbarch, 128);
  set_gdbarch_long_double_format (gdbarch, floatformats_sparc_quad);

  set_gdbarch_num_regs (gdbarch, SPARC32_NUM_REGS);
  set_gdbarch_register_name (gdbarch, sparc32_register_name);
  set_gdbarch_register_type (gdbarch, sparc32_register_type);
  set_gdbarch_num_pseudo_regs (gdbarch, SPARC32_NUM_PSEUDO_REGS);
  set_gdbarch_pseudo_register_read (gdbarch, sparc32_pseudo_register_read);
  set_gdbarch_pseudo_register_write (gdbarch, sparc32_pseudo_register_write);

  /* Register numbers of various important registers.  */
  set_gdbarch_sp_regnum (gdbarch, SPARC_SP_REGNUM); /* %sp */
  set_gdbarch_pc_regnum (gdbarch, SPARC32_PC_REGNUM); /* %pc */
  set_gdbarch_fp0_regnum (gdbarch, SPARC_F0_REGNUM); /* %f0 */

  /* Call dummy code.  */
  set_gdbarch_frame_align (gdbarch, sparc32_frame_align);
  set_gdbarch_call_dummy_location (gdbarch, ON_STACK);
  set_gdbarch_push_dummy_code (gdbarch, sparc32_push_dummy_code);
  set_gdbarch_push_dummy_call (gdbarch, sparc32_push_dummy_call);

  set_gdbarch_return_value (gdbarch, sparc32_return_value);
  set_gdbarch_stabs_argument_has_addr
    (gdbarch, sparc32_stabs_argument_has_addr);

  set_gdbarch_skip_prologue (gdbarch, sparc32_skip_prologue);

  /* Stack grows downward.  */
  set_gdbarch_inner_than (gdbarch, core_addr_lessthan);

  set_gdbarch_breakpoint_from_pc (gdbarch, sparc_breakpoint_from_pc);

  set_gdbarch_frame_args_skip (gdbarch, 8);

  set_gdbarch_print_insn (gdbarch, print_insn_sparc);

  set_gdbarch_software_single_step (gdbarch, sparc_software_single_step);
  set_gdbarch_write_pc (gdbarch, sparc_write_pc);

  set_gdbarch_dummy_id (gdbarch, sparc_dummy_id);

  set_gdbarch_unwind_pc (gdbarch, sparc_unwind_pc);

  frame_base_set_default (gdbarch, &sparc32_frame_base);

  /* Hook in the DWARF CFI frame unwinder.  */
  dwarf2_frame_set_init_reg (gdbarch, sparc32_dwarf2_frame_init_reg);
  /* FIXME: kettenis/20050423: Don't enable the unwinder until the
     StackGhost issues have been resolved.  */

  /* Hook in ABI-specific overrides, if they have been registered.  */
  gdbarch_init_osabi (info, gdbarch);

  frame_unwind_append_unwinder (gdbarch, &sparc32_frame_unwind);

  /* If we have register sets, enable the generic core file support.  */
  if (tdep->gregset)
    set_gdbarch_regset_from_core_section (gdbarch,
					  sparc_regset_from_core_section);

  register_sparc_ravenscar_ops (gdbarch);

  return gdbarch;
}

/* Helper functions for dealing with register windows.  */

void
sparc_supply_rwindow (struct regcache *regcache, CORE_ADDR sp, int regnum)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  int offset = 0;
  gdb_byte buf[8];
  int i;

  if (sp & 1)
    {
      /* Registers are 64-bit.  */
      sp += BIAS;

      for (i = SPARC_L0_REGNUM; i <= SPARC_I7_REGNUM; i++)
	{
	  if (regnum == i || regnum == -1)
	    {
	      target_read_memory (sp + ((i - SPARC_L0_REGNUM) * 8), buf, 8);

	      /* Handle StackGhost.  */
	      if (i == SPARC_I7_REGNUM)
		{
		  ULONGEST wcookie = sparc_fetch_wcookie (gdbarch);
		  ULONGEST i7;

		  i7 = extract_unsigned_integer (buf + offset, 8, byte_order);
		  store_unsigned_integer (buf + offset, 8, byte_order,
					  i7 ^ wcookie);
		}

	      regcache_raw_supply (regcache, i, buf);
	    }
	}
    }
  else
    {
      /* Registers are 32-bit.  Toss any sign-extension of the stack
	 pointer.  */
      sp &= 0xffffffffUL;

      /* Clear out the top half of the temporary buffer, and put the
	 register value in the bottom half if we're in 64-bit mode.  */
      if (gdbarch_ptr_bit (get_regcache_arch (regcache)) == 64)
	{
	  memset (buf, 0, 4);
	  offset = 4;
	}

      for (i = SPARC_L0_REGNUM; i <= SPARC_I7_REGNUM; i++)
	{
	  if (regnum == i || regnum == -1)
	    {
	      target_read_memory (sp + ((i - SPARC_L0_REGNUM) * 4),
				  buf + offset, 4);

	      /* Handle StackGhost.  */
	      if (i == SPARC_I7_REGNUM)
		{
		  ULONGEST wcookie = sparc_fetch_wcookie (gdbarch);
		  ULONGEST i7;

		  i7 = extract_unsigned_integer (buf + offset, 4, byte_order);
		  store_unsigned_integer (buf + offset, 4, byte_order,
					  i7 ^ wcookie);
		}

	      regcache_raw_supply (regcache, i, buf);
	    }
	}
    }
}

void
sparc_collect_rwindow (const struct regcache *regcache,
		       CORE_ADDR sp, int regnum)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  int offset = 0;
  gdb_byte buf[8];
  int i;

  if (sp & 1)
    {
      /* Registers are 64-bit.  */
      sp += BIAS;

      for (i = SPARC_L0_REGNUM; i <= SPARC_I7_REGNUM; i++)
	{
	  if (regnum == -1 || regnum == SPARC_SP_REGNUM || regnum == i)
	    {
	      regcache_raw_collect (regcache, i, buf);

	      /* Handle StackGhost.  */
	      if (i == SPARC_I7_REGNUM)
		{
		  ULONGEST wcookie = sparc_fetch_wcookie (gdbarch);
		  ULONGEST i7;

		  i7 = extract_unsigned_integer (buf + offset, 8, byte_order);
		  store_unsigned_integer (buf, 8, byte_order, i7 ^ wcookie);
		}

	      target_write_memory (sp + ((i - SPARC_L0_REGNUM) * 8), buf, 8);
	    }
	}
    }
  else
    {
      /* Registers are 32-bit.  Toss any sign-extension of the stack
	 pointer.  */
      sp &= 0xffffffffUL;

      /* Only use the bottom half if we're in 64-bit mode.  */
      if (gdbarch_ptr_bit (get_regcache_arch (regcache)) == 64)
	offset = 4;

      for (i = SPARC_L0_REGNUM; i <= SPARC_I7_REGNUM; i++)
	{
	  if (regnum == -1 || regnum == SPARC_SP_REGNUM || regnum == i)
	    {
	      regcache_raw_collect (regcache, i, buf);

	      /* Handle StackGhost.  */
	      if (i == SPARC_I7_REGNUM)
		{
		  ULONGEST wcookie = sparc_fetch_wcookie (gdbarch);
		  ULONGEST i7;

		  i7 = extract_unsigned_integer (buf + offset, 4, byte_order);
		  store_unsigned_integer (buf + offset, 4, byte_order,
					  i7 ^ wcookie);
		}

	      target_write_memory (sp + ((i - SPARC_L0_REGNUM) * 4),
				   buf + offset, 4);
	    }
	}
    }
}

/* Helper functions for dealing with register sets.  */

void
sparc32_supply_gregset (const struct sparc_gregset *gregset,
			struct regcache *regcache,
			int regnum, const void *gregs)
{
  const gdb_byte *regs = gregs;
  gdb_byte zero[4] = { 0 };
  int i;

  if (regnum == SPARC32_PSR_REGNUM || regnum == -1)
    regcache_raw_supply (regcache, SPARC32_PSR_REGNUM,
			 regs + gregset->r_psr_offset);

  if (regnum == SPARC32_PC_REGNUM || regnum == -1)
    regcache_raw_supply (regcache, SPARC32_PC_REGNUM,
			 regs + gregset->r_pc_offset);

  if (regnum == SPARC32_NPC_REGNUM || regnum == -1)
    regcache_raw_supply (regcache, SPARC32_NPC_REGNUM,
			 regs + gregset->r_npc_offset);

  if (regnum == SPARC32_Y_REGNUM || regnum == -1)
    regcache_raw_supply (regcache, SPARC32_Y_REGNUM,
			 regs + gregset->r_y_offset);

  if (regnum == SPARC_G0_REGNUM || regnum == -1)
    regcache_raw_supply (regcache, SPARC_G0_REGNUM, &zero);

  if ((regnum >= SPARC_G1_REGNUM && regnum <= SPARC_O7_REGNUM) || regnum == -1)
    {
      int offset = gregset->r_g1_offset;

      for (i = SPARC_G1_REGNUM; i <= SPARC_O7_REGNUM; i++)
	{
	  if (regnum == i || regnum == -1)
	    regcache_raw_supply (regcache, i, regs + offset);
	  offset += 4;
	}
    }

  if ((regnum >= SPARC_L0_REGNUM && regnum <= SPARC_I7_REGNUM) || regnum == -1)
    {
      /* Not all of the register set variants include Locals and
         Inputs.  For those that don't, we read them off the stack.  */
      if (gregset->r_l0_offset == -1)
	{
	  ULONGEST sp;

	  regcache_cooked_read_unsigned (regcache, SPARC_SP_REGNUM, &sp);
	  sparc_supply_rwindow (regcache, sp, regnum);
	}
      else
	{
	  int offset = gregset->r_l0_offset;

	  for (i = SPARC_L0_REGNUM; i <= SPARC_I7_REGNUM; i++)
	    {
	      if (regnum == i || regnum == -1)
		regcache_raw_supply (regcache, i, regs + offset);
	      offset += 4;
	    }
	}
    }
}

void
sparc32_collect_gregset (const struct sparc_gregset *gregset,
			 const struct regcache *regcache,
			 int regnum, void *gregs)
{
  gdb_byte *regs = gregs;
  int i;

  if (regnum == SPARC32_PSR_REGNUM || regnum == -1)
    regcache_raw_collect (regcache, SPARC32_PSR_REGNUM,
			  regs + gregset->r_psr_offset);

  if (regnum == SPARC32_PC_REGNUM || regnum == -1)
    regcache_raw_collect (regcache, SPARC32_PC_REGNUM,
			  regs + gregset->r_pc_offset);

  if (regnum == SPARC32_NPC_REGNUM || regnum == -1)
    regcache_raw_collect (regcache, SPARC32_NPC_REGNUM,
			  regs + gregset->r_npc_offset);

  if (regnum == SPARC32_Y_REGNUM || regnum == -1)
    regcache_raw_collect (regcache, SPARC32_Y_REGNUM,
			  regs + gregset->r_y_offset);

  if ((regnum >= SPARC_G1_REGNUM && regnum <= SPARC_O7_REGNUM) || regnum == -1)
    {
      int offset = gregset->r_g1_offset;

      /* %g0 is always zero.  */
      for (i = SPARC_G1_REGNUM; i <= SPARC_O7_REGNUM; i++)
	{
	  if (regnum == i || regnum == -1)
	    regcache_raw_collect (regcache, i, regs + offset);
	  offset += 4;
	}
    }

  if ((regnum >= SPARC_L0_REGNUM && regnum <= SPARC_I7_REGNUM) || regnum == -1)
    {
      /* Not all of the register set variants include Locals and
         Inputs.  For those that don't, we read them off the stack.  */
      if (gregset->r_l0_offset != -1)
	{
	  int offset = gregset->r_l0_offset;

	  for (i = SPARC_L0_REGNUM; i <= SPARC_I7_REGNUM; i++)
	    {
	      if (regnum == i || regnum == -1)
		regcache_raw_collect (regcache, i, regs + offset);
	      offset += 4;
	    }
	}
    }
}

void
sparc32_supply_fpregset (const struct sparc_fpregset *fpregset,
			 struct regcache *regcache,
			 int regnum, const void *fpregs)
{
  const gdb_byte *regs = fpregs;
  int i;

  for (i = 0; i < 32; i++)
    {
      if (regnum == (SPARC_F0_REGNUM + i) || regnum == -1)
	regcache_raw_supply (regcache, SPARC_F0_REGNUM + i,
			     regs + fpregset->r_f0_offset + (i * 4));
    }

  if (regnum == SPARC32_FSR_REGNUM || regnum == -1)
    regcache_raw_supply (regcache, SPARC32_FSR_REGNUM,
			 regs + fpregset->r_fsr_offset);
}

void
sparc32_collect_fpregset (const struct sparc_fpregset *fpregset,
			  const struct regcache *regcache,
			  int regnum, void *fpregs)
{
  gdb_byte *regs = fpregs;
  int i;

  for (i = 0; i < 32; i++)
    {
      if (regnum == (SPARC_F0_REGNUM + i) || regnum == -1)
	regcache_raw_collect (regcache, SPARC_F0_REGNUM + i,
			      regs + fpregset->r_f0_offset + (i * 4));
    }

  if (regnum == SPARC32_FSR_REGNUM || regnum == -1)
    regcache_raw_collect (regcache, SPARC32_FSR_REGNUM,
			  regs + fpregset->r_fsr_offset);
}


/* SunOS 4.  */

/* From <machine/reg.h>.  */
const struct sparc_gregset sparc32_sunos4_gregset =
{
  0 * 4,			/* %psr */
  1 * 4,			/* %pc */
  2 * 4,			/* %npc */
  3 * 4,			/* %y */
  -1,				/* %wim */
  -1,				/* %tbr */
  4 * 4,			/* %g1 */
  -1				/* %l0 */
};

const struct sparc_fpregset sparc32_sunos4_fpregset =
{
  0 * 4,			/* %f0 */
  33 * 4,			/* %fsr */
};

const struct sparc_fpregset sparc32_bsd_fpregset =
{
  0 * 4,			/* %f0 */
  32 * 4,			/* %fsr */
};


/* Provide a prototype to silence -Wmissing-prototypes.  */
void _initialize_sparc_tdep (void);

void
_initialize_sparc_tdep (void)
{
  register_gdbarch_init (bfd_arch_sparc, sparc32_gdbarch_init);
}
@


1.232
log
@Allow struct 'return' on 32-bit sparc.

gdb/

	* sparc-tdep.c (sparc32_return_value): Handle writing return value when
	using RETURN_VALUE_ABI_PRESERVES_ADDRESS.
	* value.c (struct_return_convention): New function.
	(using_struct_return): Implement in terms of struct_return_convention.
	* value.h (struct_return_convention): Declare.
	* stack.c (return_command): Allow successful overriding of the return
	value when RETURN_VALUE_ABI_PRESERVES_ADDRESS.
@
text
@d858 1
a858 1
  if (tdep->plt_entry_size > 0 && in_plt_section (current_pc, NULL))
@


1.231
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d1373 3
a1377 3
	  ULONGEST sp;
	  CORE_ADDR addr;

d1382 6
@


1.230
log
@Rename ravenscar-sparc-thread.[hc] into sparc-ravenscar-thread.[hc].

gdb/ChangeLog:

        * sparc-ravenscar-thread.h: Renames ravenscar-sparc-thread.h.
        * sparc-ravenscar-thread.c: Renames ravenscar-sparc-thread.c.
        Adjust sparc-ravenscar-thread.h #include.
        * sparc-tdep.c: Adjust sparc-ravenscar-thread.h #include
        accordingly.
        * Makefile.in: Replace ravenscar-sparc-thread with
        sparc-ravenscar-thread throughout.
        * configure.tgt: Likewise.
@
text
@d3 1
a3 1
   Copyright (C) 2003-2012 Free Software Foundation, Inc.
@


1.229
log
@gdbarch-ification of ravenscar-thread support.

gdb/ChangeLog:

        * gdbarch.sh: Add "struct ravenscar_arch_ops" advance
        declaration.
        (ravenscar_ops): New gdbarch variable.
        * gdbarch.h, gdbarch.c: Regenerate.
        * ravenscar-thread.h (ravenscar_register_arch_ops): Delete.
        * ravenscar-thread.c (current_arch_ops): Delete.
        (ravenscar_fetch_registers): Get the ravenscar_arch_ops
        from the gdbarch.
        (ravenscar_store_registers, ravenscar_prepare_to_store): Likewise.
        (ravenscar_inferior_created): Add gdbarch_ravenscar_ops check.
        (ravenscar_register_arch_ops): Delete.
        * ravenscar-sparc-thread.h: New file.
        * ravenscar-sparc-thread.c: #include "ravenscar-sparc-thread.h".
        (ravenscar_sparc_ops): Define value statically.
        (_initialize_ravenscar_sparc): Delete.
        (register_sparc_ravenscar_ops): New function.
        * sparc-tdep.c: #include "ravenscar-sparc-thread.h".
        (sparc32_gdbarch_init): Add call to register_sparc_ravenscar_ops.
        * Makefile.in (ALL_TARGET_OBS): Add ravenscar-thread.o and
        ravenscar-sparc-thread.o.
        (SFILES): Add ravenscar-thread.c.
        (HFILES_NO_SRCDIR): Add ravenscar-sparc-thread.h.
        (ALLDEPFILES): ravenscar-sparc-thread.c.
        * configure.tgt: Add ravenscar-thread.o and ravenscar-sparc-thread.o
        to gdb_target_obs
        for all the targets that use sparc-tdep.o.
@
text
@d42 1
a42 1
#include "ravenscar-sparc-thread.h"
@


1.228
log
@Fix Sparc %fsr regset offset for BSD and Linux.

gdb/

	* sparc-tdep.h (struct sparc_fpregset): New data structure.
	(sparc32_sunos4_fpregset, sparc32_bsd_fpregset,
	sparc32_sol2_fpregset): Declare new globals.
	(sparc32_supply_fpregset, sparc32_collect_fpregset): Add new
	'fpregset' argument.
	* sparc64-tdep.h (sparc64_supply_fpregset,
	sparc64_collect_fpregset): Likewise.
	(sparc64_sol2_fpregset, sparc64_bsd_fpregset): Declare new
	globals.
	* sparc-nat.h (struct sparc_fpregset): Add forward declaration.
	(sparc_fpregset): Declare new global.
	(sparc_supply_fpregset, sparc_collect_fpregset): Add new
	'fpregset' argument.
	* sparc-linux-nat.c (supply_fpregset): Pass sparc_fpregset down
	into handler.
	(fill_fpregset): Likewise.
	(_initialize_sparc_linux_nat): Set sparc_fpregset to
	sparc32_bsd_fpregset.
	* sparc-linux-tdep.c (sparc32_linux_supply_core_fpregset): Pass
	sparc32_bsd_fpregset down into handler.
	(sparc32_linux_collect_core_fpregset): Likewise.
	* sparc-nat.c (sparc_fpregset): Define.
	(sparc_supply_fpregset): Add 'fpregset' argument.
	(sparc_collect_fpregset): Likewise.
	(sparc_fetch_inferior_registers): Pass sparc_fpregset down
	into fpregset handler.
	(sparc_store_inferior_registers): Likewise.
	(_initialize_sparc_nat): Set sparc_fpregset to
	sparc32_sunos4_fpregset if NULL.
	* sparc-sol2-nat.c (supply_gregset): Pass sparc_sol2_fpregset
	down into handler.
	(fill_fpregset): Likewise.
	* sparc-sol2-tdep.c (sparc32_sol2_fpregset): Define.
	* sparc-tdep.c (sparc32_supply_fpregset): Add fpregset arg and
	use it to compute offsets.
	(sparc32_collect_fpregset): Likewise.
	(sparc32_sunos4_fpregset, sparc32_bsd_fpregset): Define.
	* sparc64-linux-nat.c (supply_fpregset): Pass sparc64_bsd_fpregset
	down into handler.
	(fill_fpregset): Likewise.
	* sparc64-linux-tdep.c (sparc64_linux_supply_core_fpregset):
	Likewise.
	(sparc64_linux_collect_core_fpregset): Likewise.
	* sparc64-sol2-tdep.c (sparc64_sol2_fpregset): Define.
	* sparc64-tdep.c (sparc64_supply_fpregset): Add fpregset arg and
	use it to compute offsets.
	(sparc64_collect_fpregset): Likewise.
	(sparc64_bsd_fpregset): Define.
	* sparc64fbsd-tdep.c (sparc64fbsd_supply_fpregset): Padd
	sparc64_bsd_fpregset down into handler.
	(sparc64fbsd_collect_fpregset): Likewise.
	* sparc64nbsd-nat.c (sparc64nbsd_supply_fpregset): Add fpregset arg
	and pass sparc{32,64}_bsd_fpregset down into handler.
	(sparc64nbsd_collect_fpregset): Likewise.
	* sparc64nbsd-tdep.c (sparc64nbsd_supply_fpregset): Pass
	sparc64_bsd_fpregset down into handler.
	* sparc64obsd-tdep.c (sparc64obsd_supply_gregset): Likewise.
	* sparcnbsd-nat.c (_initialize_sparcnbsd_nat): Set sparc_fpregset
	to sparc32_bsd_fpregset.
	* sparcnbsd-tdep.c (sparc32nbsd_supply_gregset): Pass
	sparc32_bsd_fpregset down into sparc32_supply_fpregset.
	(sparc32nbsd_supply_fpregset): Likewise.
@
text
@d42 1
d1687 2
@


1.227
log
@2012-05-18  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c:
	* avr-tdep.c:
	* ax-gdb.c:
	* bfin-linux-tdep.c:
	* breakpoint.c:
	* c-valprint.c:
	* cli/cli-cmds.c:
	* coffread.c:
	* cp-support.c:
	* cris-tdep.c:
	* dwarf2-frame-tailcall.c:
	* dwarf2-frame.c:
	* dwarf2expr.c:
	* dwarf2loc.c:
	* dwarf2read.c:
	* elfread.c:
	* eval.c:
	* expprint.c:
	* f-valprint.c:
	* frv-tdep.c:
	* h8300-tdep.c:
	* hppa-hpux-tdep.c:
	* hppa-tdep.c:
	* hppanbsd-tdep.c:
	* i386-nto-tdep.c:
	* i386-tdep.c:
	* i387-tdep.c:
	* ia64-tdep.c:
	* jit.c:
	* linespec.c:
	* linux-tdep.c:
	* lm32-tdep.c:
	* m2-valprint.c:
	* m32c-tdep.c:
	* m32r-rom.c:
	* m32r-tdep.c:
	* m68k-tdep.c:
	* m68klinux-tdep.c:
	* mi/mi-main.c:
	* microblaze-tdep.c:
	* mips-linux-tdep.c:
	* mips-tdep.c:
	* mn10300-tdep.c:
	* p-valprint.c:
	* parse.c:
	* ppc-linux-tdep.c:
	* ppc-sysv-tdep.c:
	* printcmd.c:
	* python/py-finishbreakpoint.c:
	* python/py-inferior.c:
	* python/py-infthread.c:
	* python/py-type.c:
	* python/python.c:
	* remote-fileio.c:
	* remote-m32r-sdi.c:
	* remote-mips.c:
	* reverse.c:
	* rl78-tdep.c:
	* rs6000-aix-tdep.c:
	* rs6000-tdep.c:
	* s390-tdep.c:
	* score-tdep.c:
	* sh64-tdep.c:
	* skip.c:
	* solib-darwin.c:
	* solib-dsbt.c:
	* solib-frv.c:
	* sparc-tdep.c:
	* spu-multiarch.c:
	* spu-tdep.c:
	* stack.c:
	* symfile.c:
	* symtab.c:
	* tic6x-tdep.c:
	* tracepoint.c:
	* v850-tdep.c:
	* valarith.c:
	* valprint.c:
	* value.c:
	* xcoffread.c:
	* xtensa-tdep.c:
	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c: Delete unused variables.
@
text
@d1956 2
a1957 1
sparc32_supply_fpregset (struct regcache *regcache,
d1966 2
a1967 1
	regcache_raw_supply (regcache, SPARC_F0_REGNUM + i, regs + (i * 4));
d1971 2
a1972 1
    regcache_raw_supply (regcache, SPARC32_FSR_REGNUM, regs + (32 * 4) + 4);
d1976 2
a1977 1
sparc32_collect_fpregset (const struct regcache *regcache,
d1986 2
a1987 1
	regcache_raw_collect (regcache, SPARC_F0_REGNUM + i, regs + (i * 4));
d1991 2
a1992 1
    regcache_raw_collect (regcache, SPARC32_FSR_REGNUM, regs + (32 * 4) + 4);
d2010 12
@


1.226
log
@	gdb/
	* breakpoint.h (bp_location): Add related_address member.
	* inferior.h (get_return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	* value.h (using_struct_return): Likewise.
	* gdbarch.sh (return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	* breakpoint.c (set_breakpoint_location_function): Initialize
	related_address for bp_gnu_ifunc_resolver breakpoints.
	* elfread.c (elf_gnu_ifunc_resolver_return_stop): Pass the
	requested function's address to gdbarch_return_value.
	* eval.c (evaluate_subexp_standard): Pass the requested
	function's address to using_struct_return.
	* infcall.c (call_function_by_hand): Pass the requested
	function's address to using_struct_return and
	gdbarch_return_value.
	* infcmd.c (get_return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	(print_return_value): Update accordingly.
	(finish_command_continuation): Likewise.
	* stack.c (return_command): Pass the requested function's
	address to using_struct_return and gdbarch_return_value.
	* value.c (using_struct_return): Take a pointer to struct value
	instead of struct type for the function requested.  Pass the
	requested function's address to gdbarch_return_value.
	* python/py-finishbreakpoint.c (finish_breakpoint_object):
	New function_value member, replacing function_type.
	(bpfinishpy_dealloc): Update accordingly.
	(bpfinishpy_pre_stop_hook): Likewise.
	(bpfinishpy_init): Likewise.  Record the requested function's
	address.
	* mips-tdep.c (mips_fval_reg): New enum.
	(mips_o32_push_dummy_call): For MIPS16 FP doubles do not swap
	words put in GP registers.
	(mips_o64_push_dummy_call): Update a comment.
	(mips_o32_return_value): Take a pointer to struct value instead
	of struct type for the function requested and use it to check if
	using the MIPS16 calling convention.  Return the designated
	general purpose registers for floating-point values returned in
	MIPS16 mode.
	(mips_o64_return_value): Likewise.
	* ppc-tdep.h (ppc_sysv_abi_return_value): Update prototype.
	(ppc_sysv_abi_broken_return_value): Likewise.
	(ppc64_sysv_abi_return_value): Likewise.
	* alpha-tdep.c (alpha_return_value): Take a pointer to struct
	value instead of struct type for the function requested.
	* amd64-tdep.c (amd64_return_value): Likewise.
	* amd64-windows-tdep.c (amd64_windows_return_value): Likewise.
	* arm-tdep.c (arm_return_value): Likewise.
	* avr-tdep.c (avr_return_value): Likewise.
	* bfin-tdep.c (bfin_return_value): Likewise.
	* cris-tdep.c (cris_return_value): Likewise.
	* frv-tdep.c (frv_return_value): Likewise.
	* h8300-tdep.c (h8300_return_value): Likewise.
	(h8300h_return_value): Likewise.
	* hppa-tdep.c (hppa32_return_value): Likewise.
	(hppa64_return_value): Likewise.
	* i386-tdep.c (i386_return_value): Likewise.
	* ia64-tdep.c (ia64_return_value): Likewise.
	* iq2000-tdep.c (iq2000_return_value): Likewise.
	* lm32-tdep.c (lm32_return_value): Likewise.
	* m32c-tdep.c (m32c_return_value): Likewise.
	* m32r-tdep.c (m32r_return_value): Likewise.
	* m68hc11-tdep.c (m68hc11_return_value): Likewise.
	* m68k-tdep.c (m68k_return_value): Likewise.
	(m68k_svr4_return_value): Likewise.
	* m88k-tdep.c (m88k_return_value): Likewise.
	* mep-tdep.c (mep_return_value): Likewise.
	* microblaze-tdep.c (microblaze_return_value): Likewise.
	* mn10300-tdep.c (mn10300_return_value): Likewise.
	* moxie-tdep.c (moxie_return_value): Likewise.
	* mt-tdep.c (mt_return_value): Likewise.
	* ppc-linux-tdep.c (ppc_linux_return_value): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_return_value): Likewise.
	(ppc_sysv_abi_broken_return_value): Likewise.
	(ppc64_sysv_abi_return_value): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_return_value): Likewise.
	* rl78-tdep.c (rl78_return_value): Likewise.
	* rs6000-aix-tdep.c (rs6000_return_value): Likewise.
	* rx-tdep.c (rx_return_value): Likewise.
	* s390-tdep.c (s390_return_value): Likewise.
	* score-tdep.c (score_return_value): Likewise.
	* sh-tdep.c (sh_return_value_nofpu): Likewise.
	(sh_return_value_fpu): Likewise.
	* sh64-tdep.c (sh64_return_value): Likewise.
	* sparc-tdep.c (sparc32_return_value): Likewise.
	* sparc64-tdep.c (sparc64_return_value): Likewise.
	* spu-tdep.c (spu_return_value): Likewise.
	* tic6x-tdep.c (tic6x_return_value): Likewise.
	* v850-tdep.c (v850_return_value): Likewise.
	* vax-tdep.c (vax_return_value): Likewise.
	* xstormy16-tdep.c (xstormy16_return_value): Likewise.
	* xtensa-tdep.c (xtensa_return_value): Likewise.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.

	gdb/testsuite/
	* gdb.base/return-nodebug.exp: Also test float and double types.
@
text
@a604 1
  int i;
@


1.225
log
@Handle sparc compare-and-branch

SPARC-T4 adds a "compare and branch" instruction which fuses
a compare and a branch instruction into one.  The branch
is non-delayed, there are no anulling facilities, and the
displacement is 10-bits.

This also corrects the existing bit test for Branch on
Integer Register.  The distinguising characteristic between
Branch on Integer Register and Compare-and-Branch is bit
28.  The existing code was checking bit 24 for zero, but
that's pointless because bit 24 is already covered by
the "X_OP2 (insn) == 3" test.

gdb/

	* sparc-tdep.c (X_DISP10): Define.
	(sparc_analyze_control_transfer): Handle compare-and-branch.
@
text
@d1357 1
a1357 1
sparc32_return_value (struct gdbarch *gdbarch, struct type *func_type,
@


1.224
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d88 1
d1455 1
a1455 1
  int branch_p = 0;
d1458 1
a1458 1
  if (X_OP (insn) == 0 && X_OP2 (insn) == 3 && (insn & 0x1000000) == 0)
d1460 13
a1472 3
      /* Branch on Integer Register with Prediction (BPr).  */
      branch_p = 1;
      conditional_p = 1;
d1509 10
a1518 1
      if (conditional_p)
@


1.223
log
@Fix complex floats on sparc.

	* sparc-tdep.h (SPARC_F2_REGNUM, SPARC_F3_REGNUM, SPARC_F4_REGNUM,
	SPARC_F5_REGNUM, SPARC_F6_REGNUM, SPARC_F7_REGNUM): New enums.
	* sparc-tdep.c (sparc_complex_floating_p): New function.
	(sparc32_store_arguments): Handle complex floats.
	(sparc32_extract_return_value): Likewise.
	(sparc32_store_return_value): Likewise.
	(sparc32_stabs_argument_has_addr): Likewise.
	* sparc64-tdep.c (sparc64_complex_floating_p): New function.
	(sparc64_store_floating_fields): Handle complex floats.
	(sparc64_store_arguments): Likewise.
	(sparc64_store_return_value): Likewise.
@
text
@d3 1
a3 2
   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.223.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 2
a4 1
   Copyright (C) 2003-2012 Free Software Foundation, Inc.
@


1.222
log
@Add support for single register window model on SPARC

        2011-06-27  Eric Botcazou  <ebotcazou@@adacore.com>
        * sparc-tdep.h (struct sparc_frame_cache): Add frame_offset,
        saved_regs_mask and copied_regs_mask fields.
        (sparc_record_save_insn): New prototype.
        * sparc-tdep.c (sparc_alloc_frame_cache): Initialize the new fields.
        (sparc_record_save_insn): New function.
        (sparc_analyze_prologue): Add head comment.  Recognize store insns
        of call-saved registers.  Use OFFSET consistently.  Recognize flat
        frames and cache their settings.
        (sparc32_skip_prologue): Handle flat frames.
        (sparc_frame_cache): Add frame_offset to the base address.
        (sparc32_frame_cache): Adjust to new frame description.
        (sparc32_frame_prev_register): Likewise.
        * sparc64-tdep.c (sparc64_frame_prev_register): Likewise.
        * sparc-sol2-tdep.c (sparc32_sol2_sigtramp_frame_cache): Likewise.
        * sparc64-sol2-tdep.c (sparc64_sol2_sigtramp_frame_cache): Likewise.
        * sparcnbsd-tdep.c (sparc32nbsd_sigcontext_frame_cache): Force the
        frame by calling sparc_record_save_insn.
        * sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_frame_cache): Likewise.
        * sparcobsd-tdep.c (sparc32obsd_sigtramp_frame_cache): Likewise.
        * sparc64obsd-tdep.c (sparc64obsd_frame_cache): Likewise.
@
text
@d224 19
d476 2
a477 1
	  || (sparc_floating_p (type) && len == 16))
d1256 1
a1256 1
  gdb_byte buf[8];
d1261 1
a1261 1
  if (sparc_floating_p (type))
d1267 12
d1316 1
a1316 1
  if (sparc_floating_p (type))
d1323 12
d1398 2
a1399 1
	  || (sparc_floating_p (type) && TYPE_LENGTH (type) == 16));
@


1.221
log
@	* sparc-tdep.c (sparc_skip_stack_check): Recognize a new instruction
	sequence for probing loops.
@
text
@d595 3
a597 1

d789 25
d843 27
d876 1
a876 1
      insn = sparc_fetch_instruction (pc + 4);
d885 1
a885 1
      insn = sparc_fetch_instruction (pc + 8);
d891 50
a940 2
      cache->frameless_p = 0;
      return pc + offset + 4;
d983 1
a983 2
     write out these incoming arguments onto the stack.  Of course we
     only need to do this if we have a stack frame.  */
d985 1
a985 1
  while (!cache.frameless_p)
d989 4
a992 5
      /* Recognize instructions that store incoming arguments in
         %i0...%i5 into the corresponding stack slot.  */
      if (X_OP (insn) == 3 && (X_OP3 (insn) & 0x3c) == 0x04 && X_I (insn)
	  && (X_RD (insn) >= 24 && X_RD (insn) <= 29) && X_RS1 (insn) == 30
	  && X_SIMM13 (insn) == 68 + (X_RD (insn) - 24) * 4)
d994 19
a1012 2
	  start_pc += 4;
	  continue;
d1055 2
d1105 2
a1106 1
      int regnum = cache->frameless_p ? SPARC_O7_REGNUM : SPARC_I7_REGNUM;
d1148 2
a1149 1
      regnum = cache->frameless_p ? SPARC_O7_REGNUM : SPARC_I7_REGNUM;
d1169 1
a1169 1
  /* The previous frame's `local' and `in' registers have been saved
d1171 2
a1172 2
  if (!cache->frameless_p
      && regnum >= SPARC_L0_REGNUM && regnum <= SPARC_I7_REGNUM)
d1179 4
a1182 4
  /* The previous frame's `out' registers are accessible as the
     current frame's `in' registers.  */
  if (!cache->frameless_p
      && regnum >= SPARC_O0_REGNUM && regnum <= SPARC_O7_REGNUM)
@


1.220
log
@* sparc-nat.c (sparc_fetch_inferior_registers): Explicitly supply
zero as the value for %g0 in the register cache.
* sparc-tdep.c (sparc32_supply_gregset): Likewise.
* sparc64-tdep.c (sparc64_supply_gregset): Likewise.
@
text
@d612 1
d615 1
a615 1
     instructions.  */
d617 19
a635 1
  /* sethi <some immediate>,%g1 */
d641 1
a641 1
  /* sub %sp, %g1, %g1 */
d644 8
d659 8
d718 1
a718 2
         [first two instructions above]
         sethi  <some immediate>, %g4
d725 3
d730 1
a730 2
  /* sethi  <some immediate>, %g4 */
  else if (X_OP (insn) == 0 && X_OP2 (insn) == 0x4 && X_RD (insn) == 4)
a732 2
      insn = sparc_fetch_instruction (pc);
      pc = pc + 4;
d763 1
a763 1
      /* clr  [%g1] */
d766 3
a768 2
      if (!(X_OP (insn) == 3 && X_OP3(insn) == 0x4 && !X_I(insn)
            && X_RD (insn) == 0 && X_RS1 (insn) == 1))
d771 3
a773 1
      /* clr [%g4 - some immediate]  */
d778 3
a780 4
        return start_pc;

      /* We found a valid stack-check sequence, return the new PC.  */
      return pc;
@


1.219
log
@	gdb/
	* frame.c (frame_unwind_register): Throw an error if unwinding the
	register failed.
	* get_prev_frame_1 (get_prev_frame_1): Ask the unwinder if there's
	an unwind stop reason.
	(frame_stop_reason_string): Handle UNWIND_UNAVAILABLE.
	* frame.h (enum unwind_stop_reason) <UNWIND_OUTERMOST,
	UNWIND_UNAVAILABLE>: New.
	* inline-frame.c (inline_frame_unwind): Install
	default_frame_unwind_stop_reason.
	* frame-unwind.c: Include "exceptions.h".
	(frame_unwind_find_by_frame): Swallow NOT_AVAILABLE_ERROR errors.
	(default_frame_unwind_stop_reason): New.
	* frame-unwind.h (frame_unwind_stop_reason_ftype): New typedef.
	(default_frame_unwind_stop_reason): Declare.
	(struct frame_unwind) <stop_reason>: New function pointer.

	* dummy-frame.c: Install default_frame_unwind_stop_reason.
	* dwarf2-frame.c: Include exceptions.h.
	(struct dwarf2_frame_cache) <unavailable_retaddr>: New field.
	(dwarf2_frame_cache): Swallow NOT_AVAILABLE_ERROR errors when
	computing the CFA.  If such an error was thrown, set
	unavailable_retaddr.
	(dwarf2_frame_unwind_stop_reason): New.
	(dwarf2_frame_this_id): Don't build a frame id if the CFA was
	unavailable.
	(dwarf2_frame_unwind): Install dwarf2_frame_unwind_stop_reason.
	(dwarf2_signal_frame_unwind): Ditto.

	* amd64-tdep.c: Include "exceptions.h".
	(struct amd64_frame_cache): New field "base_p".
	(amd64_init_frame_cache): Clear it.
	(amd64_frame_cache_1): New, factored out from amd64_frame_cache.
	Avoid reading registers with functions that throw if the register
	is not necessary to compute the frame base.
	(amd64_frame_cache): Reimplement wrapping amd64_frame_cache_1, and
	swallowing NOT_AVAILABLE_ERROR.
	(amd64_frame_unwind_stop_reason): New.
	(amd64_frame_this_id): Don't build a frame id if the frame base
	was unavailable.
	(amd64_frame_unwind): Install amd64_frame_unwind_stop_reason.
	(amd64_sigtramp_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(amd64_sigtramp_frame_unwind_stop_reason): New.
	(amd64_sigtramp_frame_this_id): Don't build a frame id if the
	frame base was unavailable.
	(amd64_sigtramp_frame_unwind): Install
	amd64_sigtramp_frame_unwind_stop_reason.
	(amd64_epilogue_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(amd64_epilogue_frame_unwind_stop_reason): New.
	(amd64_epilogue_frame_this_id): Don't build a frame id if the
	frame base was unavailable.
	(amd64_epilogue_frame_unwind): Install
	amd64_epilogue_frame_unwind_stop_reason.
	* i386-tdep.c: Include "exceptions.h".
	(struct i386_frame_cache): New field "base_p".
	(i386_init_frame_cache): Clear it.
	(i386_frame_cache_1): New, factored out from amd64_frame_cache.
	Avoid reading registers with functions that throw if the register
	is not necessary to compute the frame base.
	(i386_frame_cache): Reimplement wrapping amd64_frame_cache_1, and
	swallowing NOT_AVAILABLE_ERROR.
	(i386_frame_unwind_stop_reason): New.
	(i386_frame_this_id): Don't build a frame id if the frame base was
	unavailable.
	(i386_frame_prev_register): Handle unavailable SP.
	(i386_frame_unwind): Install i386_frame_unwind_stop_reason.
	(i386_epilogue_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(i386_epilogue_frame_unwind_stop_reason): New.
	(i386_epilogue_frame_this_id): Don't build a frame id if the frame
	base was unavailable.
	(i386_epilogue_frame_unwind): Install
	i386_epilogue_frame_unwind_stop_reason.
	(i386_sigtramp_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(i386_sigtramp_frame_unwind_stop_reason): New.
	(i386_sigtramp_frame_this_id): Don't build a frame id if the frame
	base was unavailable.
	(i386_sigtramp_frame_unwind): Install
	i386_sigtramp_frame_unwind_stop_reason.
	* sentinel-frame.c (sentinel_frame_prev_register): Use the value
	type's size, not the register's.
	(sentinel_frame_unwind): Install default_frame_unwind_stop_reason.

	* alpha-mdebug-tdep.c (alpha_mdebug_frame_unwind): Install
	default_frame_unwind_stop_reason.
	* alpha-tdep.c (alpha_sigtramp_frame_unwind)
	(alpha_heuristic_frame_unwind): Ditto.
	* amd64obsd-tdep.c (amd64obsd_trapframe_unwind): Ditto.
	* arm-tdep.c (arm_prologue_unwind, arm_stub_unwind): Ditto.
	* avr-tdep.c (avr_frame_unwind): Ditto.
	* cris-tdep.c (cris_sigtramp_frame_unwind, cris_frame_unwind):
	Ditto.
	* frv-linux-tdep.c (frv_linux_sigtramp_frame_unwind): Ditto.
	* frv-tdep.c (frv_frame_unwind): Ditto.
	* h8300-tdep.c (h8300_frame_unwind): Ditto.
	* hppa-hpux-tdep.c (hppa_hpux_sigtramp_frame_unwind): Ditto.
	* hppa-linux-tdep.c (hppa_linux_sigtramp_frame_unwind): Ditto.
	* hppa-tdep.c (hppa_frame_unwind, hppa_fallback_frame_unwind)
	(hppa_stub_frame_unwind): Ditto.
	* i386obsd-tdep.c (i386obsd_trapframe_unwind): Ditto.
	* ia64-tdep.c (ia64_frame_unwind, ia64_sigtramp_frame_unwind)
	(ia64_libunwind_frame_unwind)
	(ia64_libunwind_sigtramp_frame_unwind): Ditto.
	* iq2000-tdep.c (iq2000_frame_unwind): Ditto.
	* lm32-tdep.c (lm32_frame_unwind): Ditto.
	* m32c-tdep.c (m32c_unwind): Ditto.
	* m32r-linux-tdep.c (m32r_linux_sigtramp_frame_unwind): Ditto.
	* m32r-tdep.c (m32r_frame_unwind): Ditto.
	* m68hc11-tdep.c (m68hc11_frame_unwind): Ditto.
	* m68k-tdep.c (m68k_frame_unwind): Ditto.
	* m68klinux-tdep.c (m68k_linux_sigtramp_frame_unwind): Ditto.
	* m88k-tdep.c (m88k_frame_unwind): Ditto.
	* mep-tdep.c (mep_frame_unwind): Ditto.
	* microblaze-tdep.c (microblaze_frame_unwind): Ditto.
	* mips-tdep.c (mips_insn16_frame_unwind, mips_insn32_frame_unwind)
	(mips_stub_frame_unwind): Ditto.
	* mn10300-tdep.c (mn10300_frame_unwind): Ditto.
	* moxie-tdep.c (moxie_frame_unwind): Ditto.
	* mt-tdep.c (mt_frame_unwind): Ditto.
	* ppc-linux-tdep.c (ppu2spu_unwind): Ditto.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_unwind): Ditto.
	* rs6000-tdep.c (rs6000_frame_unwind): Ditto.
	* s390-tdep.c (s390_frame_unwind, s390_stub_frame_unwind)
	(s390_sigtramp_frame_unwind): Ditto.
	* score-tdep.c (score_prologue_unwind): Ditto.
	* sh-tdep.c (sh_frame_unwind): Ditto.
	* sh64-tdep.c (sh64_frame_unwind): Ditto.
	* sparc-sol2-tdep.c (sparc32_sol2_sigtramp_frame_unwind): Ditto.
	* sparc-tdep.c (sparc32_frame_unwind): Ditto.
	* sparc64-sol2-tdep.c (sparc64_sol2_sigtramp_frame_unwind): Ditto.
	* sparc64-tdep.c (sparc64_frame_unwind): Ditto.
	* sparc64fbsd-tdep.c (sparc64fbsd_sigtramp_frame_unwind): Ditto.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_frame_unwind): Ditto.
	* sparc64obsd-tdep.c (sparc64obsd_frame_unwind)
	(sparc64obsd_trapframe_unwind): Ditto.
	* sparcnbsd-tdep.c (sparc32nbsd_sigcontext_frame_unwind): Ditto.
	* sparcobsd-tdep.c (sparc32obsd_sigtramp_frame_unwind): Ditto.
	* spu-tdep.c (spu_frame_unwind, spu2ppu_unwind): Ditto.
	* v850-tdep.c (v850_frame_unwind): Ditto.
	* vax-tdep.c (vax_frame_unwind): Ditto.
	* vaxobsd-tdep.c (vaxobsd_sigtramp_frame_unwind): Ditto.
	* xstormy16-tdep.c (frame_unwind xstormy16_frame_unwind): Ditto.
	* xtensa-tdep.c (xtensa_unwind): Ditto.
@
text
@d1621 1
d1641 1
a1641 1
    regcache_raw_supply (regcache, SPARC_G0_REGNUM, NULL);
@


1.218
log
@	gdb/
	* regcache.h (regcache_raw_read, regcache_raw_read_signed)
	(regcache_raw_read_unsigned, regcache_raw_read_signed)
	(regcache_raw_read_unsigned, regcache_raw_read_part)
	(regcache_cooked_read, regcache_cooked_read_signed)
	(regcache_cooked_read_unsigned, regcache_cooked_read_part)
	(regcache_cooked_read_ftype): Change return to enum
	register_status.
	* regcache.c: Include exceptions.h
	(regcache_save): Adjust to handle REG_UNAVAILABLE registers.
	(do_cooked_read): Change return to enum register_status.  Always
	forward to regcache_cooked_read.
	(regcache_raw_read): Change return to enum register_status.  If
	the register is not REG_VALID, memset the buffer.  Return the
	register's status.
	(regcache_raw_read_signed): Handle non-REG_VALID registers and
	return the register's status.
	(regcache_raw_read_unsigned): Ditto.
	(regcache_cooked_read): Change return to enum register_status.
	Assert that with read-only regcaches, the register's status must
	be known.  If the regcache is read-only, and the register is not
	REG_VALID, memset the buffer.  Return the register's status.
	(regcache_cooked_read_signed): Change return to enum
	register_status.  Handle non-REG_VALID registers and return the
	register's status.
	(regcache_cooked_read_unsigned): Change return to enum
	register_status.  Handle non-REG_VALID registers and return the
	register's status.
	(regcache_xfer_part, regcache_raw_read_part)
	(regcache_cooked_read_part): Change return to enum
	register_status.  Return the register's status.
	(regcache_read_pc): Throw NOT_AVAILABLE_ERROR if the register is
	unavailable.
	(regcache_dump): Handle unavailable cooked registers.
	* frame.c (do_frame_register_read): Adjust interface to match
	regcache_cooked_read_ftype.
	* gdbarch.sh (pseudo_register_read): Change return to enum
	register_status.
	* gdbarch.h, gdbarch.c: Regenerate.

	* i386-tdep.h (i386_pseudo_register_read): Change return to enum
	register_status.
	* i386-tdep.c (i386_pseudo_register_read): Change return to enum
	register_status.  If reading a raw register indicates the raw
	register is not valid, return the raw register's status,
	otherwise, return REG_VALID.
	* amd64-tdep.c (amd64_pseudo_register_read): Change return to enum
	register_status.  Handle non-REG_VALID raw registers and return
	the register's status.
	* arm-tdep.c (arm_neon_quad_read)
	(arm_pseudo_read): Change return to enum register_status.  Handle
	non-REG_VALID raw registers and return the register's status.
	* avr-tdep.c (avr_pseudo_register_read): Ditto.
	* frv-tdep.c (frv_pseudo_register_read): Ditto.
	* h8300-tdep.c (h8300_pseudo_register_read): Ditto.
	* hppa-tdep.c (hppa_pseudo_register_read): Ditto.
	* m32c-tdep.c (m32c_move_reg_t): Change return to enum
	register_status.
	(m32c_raw_read, m32c_raw_write, m32c_banked_read)
	(m32c_banked_write, m32c_sb_read, m32c_sb_write, m32c_part_read)
	(m32c_part_write, m32c_cat_read, m32c_cat_write)
	(m32c_r3r2r1r0_read, m32c_r3r2r1r0_write)
	(m32c_pseudo_register_read): Change return to enum
	register_status.  Adjust.
	* m68hc11-tdep.c (m68hc11_pseudo_register_read): Change return to
	enum register_status.  Return the register's status.
	* mep-tdep.c (mep_pseudo_cr32_read): Change return to enum
	register_status.  Return the register's status.
	(mep_pseudo_cr64_read, mep_pseudo_register_read): Ditto.
	* mips-tdep.c (mips_pseudo_register_read): Ditto.
	* mt-tdep.c (mt_pseudo_register_read): Ditto.
	* rs6000-tdep.c (move_ev_register_func): New typedef.
	(e500_move_ev_register): Use it.  Change return to enum
	register_status.  Return the register's status.
	(do_regcache_raw_read): New function.
	(do_regcache_raw_write): New function.
	(e500_pseudo_register_read): Change return to enum
	register_status.  Return the register's status.  Use
	do_regcache_raw_read.
	(e500_pseudo_register_write): Adjust.  Use do_regcache_raw_write.
	(dfp_pseudo_register_read): Change return to enum register_status.
	Return the register's status.
	(vsx_pseudo_register_read): Ditto.
	(efpr_pseudo_register_read): Ditto.
	(rs6000_pseudo_register_read): Ditto.
	* s390-tdep.c (s390_pseudo_register_read): Change return to enum
	register_status.  Return the register's status.
	* sh64-tdep.c (pseudo_register_read_portions): New function.
	(sh64_pseudo_register_read): Change return to enum
	register_status.  Use pseudo_register_read_portions.  Return the
	register's status.
	* ia64-tdep.c (ia64_pseudo_register_read): Change return to enum
	register_status.  Return the register's status.
	* sh-tdep.c (pseudo_register_read_portions): New function.
	(sh_pseudo_register_read): Change return to enum register_status.
	Use pseudo_register_read_portions.  Return the register's status.
	* sparc-tdep.c (sparc32_pseudo_register_read): Change return to
	enum register_status.  Return the register's status.
	* sparc64-tdep.c (sparc64_pseudo_register_read): Ditto.
	* spu-tdep.c (spu_pseudo_register_read_spu)
	(spu_pseudo_register_read): Ditto.
	* xtensa-tdep.c (xtensa_register_read_masked)
	(xtensa_pseudo_register_read): Ditto.
	* bfin-tdep.c (bfin_pseudo_register_read): Ditto.
@
text
@d1034 1
@


1.217
log
@2011-01-11  Michael Snyder  <msnyder@@vmware.com>

	* s390-tdep.c: Comment cleanup, mostly periods and spaces.
	* score-tdep.c: Ditto.
	* score-tdep.h: Ditto.
	* ser-base.c: Ditto.
	* ser-go32.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* ser-mingw.c: Ditto.
	* ser-pipe.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* sh64-tdep.c: Ditto.
	* shnbsd-nat.c: Ditto.
	* sh-tdep.c: Ditto.
	* sh-tdep.h: Ditto.
	* solib.c: Ditto.
	* solib-darwin.c: Ditto.
	* solib-frv.c: Ditto.
	* solib.h: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-spu.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solist.h: Ditto.
	* sol-thread.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* source.h: Ditto.
	* sparc64-linux-tdep.c: Ditto.
	* sparc64-tdep.c: Ditto.
	* sparc-linux-nat.c: Ditto.
	* sparc-linux-tdep.c: Ditto.
	* sparc-sol2-nat.c: Ditto.
	* sparc-sol2-tdep.c: Ditto.
	* sparc-tdep.c: Ditto.
	* sparc-tdep.h: Ditto.
	* spu-tdep.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.h: Ditto.
	* stack.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target.c: Ditto.
	* target-descriptions.c: Ditto.
	* target-descriptions.h: Ditto.
	* target.h: Ditto.
	* target-memory.c: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* trad-frame.h: Ditto.
	* typeprint.c: Ditto.
@
text
@d376 1
a376 1
static void
d381 2
d386 4
a389 2
  regcache_raw_read (regcache, regnum, buf);
  regcache_raw_read (regcache, regnum + 1, buf + 4);
@


1.216
log
@run copyright.sh for 2011.
@
text
@d148 1
a148 1
   Mike Frantzen and Mike Shuey. "StackGhost: Hardware Facilitated
d350 1
a350 1
   register REGNUM. */
@


1.215
log
@* sparc-tdep.c: Fix typo in comment.
@
text
@d3 1
a3 1
   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
@


1.214
log
@[sparc] inferior SEGV while calling Ada subprogram

gdb/ChangeLog:

        * sparc-tdep.c (sparc32_frame_align): New function.
        (sparc32_gdbarch_init): Set the frame_align gdbarch method.
        * sparc64-tdep.c (sparc64_frame_align): New function.
        (sparc64_gdbarch_init): Set the frame_align gdbarch method.
@
text
@d66 1
a66 1
   big-endian IA-64 Quad-recision format.  */
@


1.213
log
@"finish" does not work on sparc if function returns array.

ChangeLog:

        * sparc-tdep.c (sparc_structure_or_union_p): Return non-zero
        for array types.
        * sparc64-tdep.c (sparc64_structure_or_union_p): Likewise.
@
text
@d402 7
d1417 1
@


1.212
log
@gdb: workaround sparc memcpy fortify error

Building on an x86_64-linux system with --enable-targets=all fails on the
sparc code with a fortify error:

cc1: warnings being treated as errors
In file included from /usr/include/string.h:640,
                 from gnulib/string.h:23,
                 from ../../gdb/gdb_string.h:25,
                 from ../../gdb/vec.h:25,
                 from ../../gdb/memattr.h:24,
                 from ../../gdb/target.h:60,
                 from ../../gdb/exec.h:23,
                 from ../../gdb/gdbcore.h:31,
                 from ../../gdb/sparc-tdep.c:29:
In function 'memcpy',
    inlined from 'sparc32_store_return_value' at ../../gdb/sparc-tdep.c:1112,
    inlined from 'sparc32_return_value' at ../../gdb/sparc-tdep.c:1170:
/usr/include/bits/string3.h:52: error: call to __builtin___memcpy_chk will
        always overflow destination buffer
make: *** [sparc-tdep.o] Error 1

This is due to the gcc optimizer bug PR37060, so tweak the gdb_assert ()
to avoid the issue.

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d224 5
a228 1
/* Check whether TYPE is "Structure or Union".  */
d237 1
@


1.211
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d1108 1
@


1.210
log
@2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	Add base multi-executable/process support to GDB.

	gdb/
	* Makefile.in (SFILES): Add progspace.c.
	(COMMON_OBS): Add progspace.o.
	* progspace.h: New.
	* progspace.c: New.

	* breakpoint.h (struct bp_target_info) <placed_address_space>: New
	field.
	(struct bp_location) <pspace>: New field.
	(struct breakpoint) <pspace>: New field.
	(bpstat_stop_status, breakpoint_here_p)
	(moribund_breakpoint_here_p, breakpoint_inserted_here_p)
	(regular_breakpoint_inserted_here_p)
	(software_breakpoint_inserted_here_p, breakpoint_thread_match)
	(set_default_breakpoint): Adjust prototypes.
	(remove_breakpoints_pid, breakpoint_program_space_exit): Declare.
	(insert_single_step_breakpoint, deprecated_insert_raw_breakpoint):
	Adjust prototypes.
	* breakpoint.c (executing_startup): Delete.
	(default_breakpoint_sspace): New.
	(breakpoint_restore_shadows): Skip if the address space doesn't
	match.
	(update_watchpoint): Record the frame's program space in the
	breakpoint location.
	(insert_bp_location): Record the address space in target_info.
	Adjust to pass the symbol space to solib_name_from_address.
	(breakpoint_program_space_exit): New.
	(insert_breakpoint_locations): Switch the symbol space and thread
	when inserting breakpoints.  Don't insert breakpoints in a vfork
	parent waiting for vfork done if we're not attached to the vfork
	child.
	(remove_breakpoints_pid): New.
	(reattach_breakpoints): Switch to a thread of PID.  Ignore
	breakpoints of other symbol spaces.
	(create_internal_breakpoint): Store the symbol space in the sal.
	(create_longjmp_master_breakpoint): Iterate over all symbol
	spaces.
	(update_breakpoints_after_exec): Ignore breakpoints for other
	symbol spaces.
	(remove_breakpoint): Rename to ...
	(remove_breakpoint_1): ... this.  Pass the breakpoints symbol
	space to solib_name_from_address.
	(remove_breakpoint): New.
	(mark_breakpoints_out): Ignore breakpoints from other symbol
	spaces.
	(breakpoint_init_inferior): Ditto.
	(breakpoint_here_p): Add an address space argument and adjust to
	use breakpoint_address_match.
	(moribund_breakpoint_here_p): Ditto.
	(regular_breakpoint_inserted_here_p): Ditto.
	(breakpoint_inserted_here_p): Ditto.
	(software_breakpoint_inserted_here_p): Ditto.
	(breakpoint_thread_match): Ditto.
	(bpstat_check_location): Ditto.
	(bpstat_stop_status): Ditto.
	(print_breakpoint_location): If there's a location to print,
	switch the current symbol space.
	(print_one_breakpoint_location): Add `allflag' argument.
	(print_one_breakpoint): Ditto.	Adjust.
	(do_captured_breakpoint_query): Adjust.
	(breakpoint_1): Adjust.
	(breakpoint_has_pc): Also match the symbol space.
	(describe_other_breakpoints): Add a symbol space argument and
	adjust.
	(set_default_breakpoint): Add a symbol space argument.	Set
	default_breakpoint_sspace.
	(breakpoint_address_match): New.
	(check_duplicates_for): Add an address space argument, and adjust.
	(set_raw_breakpoint): Record the symbol space in the location and
	in the breakpoint.
	(set_longjmp_breakpoint): Skip longjmp master breakpoints from
	other symbol spaces.
	(remove_thread_event_breakpoints, remove_solib_event_breakpoints)
	(disable_breakpoints_in_shlibs): Skip breakpoints from other
	symbol spaces.
	(disable_breakpoints_in_unloaded_shlib): Match symbol spaces.
	(create_catchpoint): Set the symbol space in the sal.
	(disable_breakpoints_before_startup): Skip breakpoints from other
	symbol spaces.	Set executing_startup in the current symbol space.
	(enable_breakpoints_after_startup): Clear executing_startup in the
	current symbol space.  Skip breakpoints from other symbol spaces.
	(clone_momentary_breakpoint): Also copy the symbol space.
	(add_location_to_breakpoint): Set the location's symbol space.
	(bp_loc_is_permanent): Switch thread and symbol space.
	(create_breakpoint): Adjust.
	(expand_line_sal_maybe): Expand comment to mention symbol spaces.
	Switch thread and symbol space when reading memory.
	(parse_breakpoint_sals): Set the symbol space in the sal.
	(break_command_really): Ditto.
	(skip_prologue_sal): Switch and space.
	(resolve_sal_pc): Ditto.
	(watch_command_1): Record the symbol space in the sal.
	(create_ada_exception_breakpoint): Adjust.
	(clear_command): Adjust.  Match symbol spaces.
	(update_global_location_list): Use breakpoint_address_match.
	(breakpoint_re_set_one): Switch thread and space.
	(breakpoint_re_set): Save symbol space.
	(breakpoint_re_set_thread): Also reset the symbol space.
	(deprecated_insert_raw_breakpoint): Add an address space argument.
	Adjust.
	(insert_single_step_breakpoint): Ditto.
	(single_step_breakpoint_inserted_here_p): Ditto.
	(clear_syscall_counts): New.
	(_initialize_breakpoint): Install it as inferior_exit observer.

	* exec.h: Include "progspace.h".
	(exec_bfd, exec_bfd_mtime): New defines.
	(exec_close): Declare.
	* exec.c: Include "gdbthread.h" and "progspace.h".
	(exec_bfd, exec_bfd_mtime, current_target_sections_1): Delete.
	(using_exec_ops): New.
	(exec_close_1): Rename to exec_close, and make public.
	(exec_close): Rename to exec_close_1, and adjust all callers.  Add
	description.  Remove target sections and close executables from
	all program spaces.
	(exec_file_attach): Add comment.
	(add_target_sections): Check on `using_exec_ops' to check if the
	target should be pushed.
	(remove_target_sections): Only unpush the target if there are no
	more target sections in any symbol space.
	* gdbcore.h: Include "exec.h".
	(exec_bfd, exec_bfd_mtime): Remove declarations.

	* frame.h (get_frame_program_space, get_frame_address_space)
	(frame_unwind_program_space): Declare.
	* frame.c (struct frame_info) <pspace, aspace>: New fields.
	(create_sentinel_frame): Add program space argument.  Set the
	pspace and aspace fields of the frame object.
	(get_current_frame, create_new_frame): Adjust.
	(get_frame_program_space): New.
	(frame_unwind_program_space): New.
	(get_frame_address_space): New.
	* stack.c (print_frame_info): Adjust.
	(print_frame): Use the frame's program space.

	* gdbthread.h (any_live_thread_of_process): Declare.
	* thread.c (any_live_thread_of_process): New.
	(switch_to_thread): Switch the program space as well.
	(restore_selected_frame): Don't warn if trying to restore frame
	level 0.

	* inferior.h: Include "progspace.h".
	(detach_fork): Declare.
	(struct inferior) <removable, aspace, pspace>
	<vfork_parent, vfork_child, pending_detach>
	<waiting_for_vfork_done>: New fields.
	<terminal_info>: Remove field.
	<data, num_data>: New fields.
	(register_inferior_data, register_inferior_data_with_cleanup)
	(clear_inferior_data, set_inferior_data, inferior_data): Declare.
	(exit_inferior, exit_inferior_silent, exit_inferior_num_silent)
	(inferior_appeared): Declare.
	(find_inferior_pid): Typo.
	(find_inferior_id, find_inferior_for_program_space): Declare.
	(set_current_inferior, save_current_inferior, prune_inferiors)
	(number_of_inferiors): Declare.
	(inferior_list): Declare.
	* inferior.c: Include "gdbcore.h" and "symfile.h".
	(inferior_list): Make public.
	(delete_inferior_1): Always delete thread silently.
	(find_inferior_id): Make public.
	(current_inferior_): New.
	(current_inferior): Use it.
	(set_current_inferior): New.
	(restore_inferior): New.
	(save_current_inferior): New.
	(free_inferior): Free the per-inferior data.
	(add_inferior_silent): Allocate per-inferior data.
	Call inferior_appeared.
	(delete_threads_of_inferior): New.
	(delete_inferior_1): Adjust interface to take an inferior pointer.
	(delete_inferior): Adjust.
	(delete_inferior_silent): Adjust.
	(exit_inferior_1): New.
	(exit_inferior): New.
	(exit_inferior_silent): New.
	(exit_inferior_num_silent): New.
	(detach_inferior): Adjust.
	(inferior_appeared): New.
	(discard_all_inferiors): Adjust.
	(find_inferior_id): Make public.  Assert pid is not zero.
	(find_inferior_for_program_space): New.
	(have_inferiors): Check if we have any inferior with pid not zero.
	(have_live_inferiors): Go over all pushed targets looking for
	process_stratum.
	(prune_inferiors): New.
	(number_of_inferiors): New.
	(print_inferior): Add executable column.  Print vfork parent/child
	relationships.
	(inferior_command): Adjust to cope with not running inferiors.
	(remove_inferior_command): New.
	(add_inferior_command): New.
	(clone_inferior_command): New.
	(struct inferior_data): New.
	(struct inferior_data_registration): New.
	(struct inferior_data_registry): New.
	(inferior_data_registry): New.
	(register_inferior_data_with_cleanup): New.
	(register_inferior_data): New.
	(inferior_alloc_data): New.
	(inferior_free_data): New.
	(clear_inferior_data): New.
	(set_inferior_data): New.
	(inferior_data): New.
	(initialize_inferiors): New.
	(_initialize_inferiors): Register "add-inferior",
	"remove-inferior" and "clone-inferior" commands.

	* objfiles.h: Include "progspace.h".
	(struct objfile) <pspace>: New field.
	(symfile_objfile, object_files): Don't declare.
	(ALL_PSPACE_OBJFILES): New.
	(ALL_PSPACE_OBJFILES_SAFE): New.
	(ALL_OBJFILES, ALL_OBJFILES_SAFE): Adjust.
	(ALL_PSPACE_SYMTABS): New.
	(ALL_PRIMARY_SYMTABS): Adjust.
	(ALL_PSPACE_PRIMARY_SYMTABS): New.
	(ALL_PSYMTABS): Adjust.
	(ALL_PSPACE_PSYMTABS): New.
	* objfiles.c (object_files, symfile_objfile): Delete.
	(struct objfile_sspace_info): New.
	(objfiles_pspace_data): New.
	(objfiles_pspace_data_cleanup): New.
	(get_objfile_pspace_data): New.
	(objfiles_changed_p): Delete.
	(allocate_objfile): Set the objfile's program space.  Adjust to
	reference objfiles_changed_p in pspace data.
	(free_objfile): Adjust to reference objfiles_changed_p in pspace
	data.
	(objfile_relocate): Ditto.
	(update_section_map): Add pspace argument.  Adjust to iterate over
	objfiles in the passed in pspace.
	(find_pc_section): Delete sections and num_sections statics.
	Adjust to refer to program space's objfiles_changed_p.	Adjust to
	refer to sections and num_sections store in the objfile's pspace
	data.
	(objfiles_changed): Adjust to reference objfiles_changed_p in
	pspace data.
	(_initialize_objfiles): New.
	* linespec.c (decode_all_digits, decode_dollar): Set the sal's
	program space.
	* source.c (current_source_pspace): New.
	(get_current_source_symtab_and_line): Set the sal's program space.
	(set_current_source_symtab_and_line): Set current_source_pspace.
	(select_source_symtab): Ditto.	Use ALL_OBJFILES.
	(forget_cached_source_info): Iterate over all program spaces.
	* symfile.c (clear_symtab_users): Adjust.
	* symmisc.c (print_symbol_bcache_statistics): Iterate over all
	program spaces.
	(print_objfile_statistics): Ditto.
	(maintenance_print_msymbols): Ditto.
	(maintenance_print_objfiles): Ditto.
	(maintenance_info_symtabs): Ditto.
	(maintenance_info_psymtabs): Ditto.
	* symtab.h (SYMTAB_PSPACE): New.
	(struct symtab_and_line) <pspace>: New field.
	* symtab.c (init_sal): Clear the sal's program space.
	(find_pc_sect_symtab): Set the sal's program space.  Switch thread
	and space.
	(append_expanded_sal): Add program space argument.  Iterate over
	all program spaces.
	(expand_line_sal): Iterate over all program spaces.  Switch
	program space.

	* target.h (enum target_waitkind) <TARGET_WAITKIND_VFORK_DONE>: New.
	(struct target_ops) <to_thread_address_space>: New field.
	(target_thread_address_space): Define.
	* target.c (target_detach): Only remove breakpoints from the
	inferior we're detaching.
	(target_thread_address_space): New.

	* defs.h (initialize_progspace): Declare.
	* top.c (gdb_init): Call it.

	* solist.h (struct so_list) <sspace>: New field.
	* solib.h (struct program_space): Forward declare.
	(solib_name_from_address): Adjust prototype.
	* solib.c (so_list_head): Replace with a macro referencing the
	program space.
	(update_solib_list): Set the so's program space.
	(solib_name_from_address): Add a program space argument and adjust.

	* solib-svr4.c (struct svr4_info) <pid>: Delete field.
	<interp_text_sect_low, interp_text_sect_high, interp_plt_sect_low>
	<interp_plt_sect_high>: New fields.
	(svr4_info_p, svr4_info): Delete.
	(solib_svr4_sspace_data): New.
	(get_svr4_info): Rewrite.
	(svr4_sspace_data_cleanup): New.
	(open_symbol_file_object): Adjust.
	(svr4_default_sos): Adjust.
	(svr4_fetch_objfile_link_map): Adjust.
	(interp_text_sect_low, interp_text_sect_high, interp_plt_sect_low)
	(interp_plt_sect_high): Delete.
	(svr4_in_dynsym_resolve_code): Adjust.
	(enable_break): Adjust.
	(svr4_clear_solib): Revert bit that removed the svr4_info here,
	and reinstate clearing debug_base, debug_loader_offset_p,
	debug_loader_offset and debug_loader_name.
	(_initialize_svr4_solib): Register solib_svr4_pspace_data.  Don't
	install an inferior_exit observer anymore.

	* printcmd.c (struct display) <pspace>: New field.
	(display_command): Set the display's sspace.
	(do_one_display): Match the display's sspace.
	(display_uses_solib_p): Ditto.

	* linux-fork.c (detach_fork): Moved to infrun.c.
	(_initialize_linux_fork): Moved "detach-on-fork" command to
	infrun.c.
	* infrun.c (detach_fork): Moved from linux-fork.c.
	(proceed_after_vfork_done): New.
	(handle_vfork_child_exec_or_exit): New.
	(follow_exec_mode_replace, follow_exec_mode_keep)
	(follow_exec_mode_names, follow_exec_mode_string)
	(show_follow_exec_mode_string): New.
	(follow_exec): New.  Reinstate the mark_breakpoints_out call.
	Remove shared libraries before attaching new executable.  If user
	wants to keep the inferior, keep it.
	(displaced_step_fixup): Adjust to pass an address space to the
	breakpoints module.
	(resume): Ditto.
	(clear_proceed_status): In all-stop mode, always clear the proceed
	status of all threads.
	(prepare_to_proceed): Adjust to pass an address space to the
	breakpoints module.
	(proceed): Ditto.
	(adjust_pc_after_break): Ditto.
	(handle_inferior_event): When handling a process exit, switch the
	program space to the inferior's that had exited.  Call
	handle_vfork_child_exec_or_exit.  Adjust to pass an address space
	to the breakpoints module.  In non-stop mode, when following a
	fork and detach-fork is off, also resume the other branch.  Handle
	TARGET_WAITKIND_VFORK_DONE.  Set the program space in sals.
	(normal_stop): Prune inferiors.
	(_initialize_infrun): Install the new "follow-exec-mode" command.
	"detach-on-fork" moved here.

	* regcache.h (get_regcache_aspace): Declare.
	* regcache.c (struct regcache) <aspace>: New field.
	(regcache_xmalloc): Clear the aspace.
	(get_regcache_aspace): New.
	(regcache_cpy): Copy the aspace field.
	(regcache_cpy_no_passthrough): Ditto.
	(get_thread_regcache): Fetch the thread's address space from the
	target, and store it in the regcache.

	* infcall.c (call_function_by_hand): Set the sal's pspace.

	* arch-utils.c (default_has_shared_address_space): New.
	* arch-utils.h (default_has_shared_address_space): Declare.

	* gdbarch.sh (has_shared_address_space): New.
	* gdbarch.h, gdbarch.c: Regenerate.

	* linux-tdep.c: Include auxv.h, target.h, elf/common.h.
	(linux_has_shared_address_space): New.
	(_initialize_linux_tdep): Declare.

	* arm-tdep.c (arm_software_single_step): Pass the frame's address
	space to insert_single_step_breakpoint.
	* arm-linux-tdep.c (arm_linux_software_single_step): Pass the
	frame's pspace to breakpoint functions.
	* cris-tdep.c (crisv32_single_step_through_delay): Ditto.
	(cris_software_single_step): Ditto.
	* mips-tdep.c (deal_with_atomic_sequence): Add frame argument.
	Pass the frame's pspace to breakpoint functions.
	(mips_software_single_step): Adjust.
	(mips_single_step_through_delay): Adjust.
	* rs6000-aix-tdep.c (rs6000_software_single_step): Adjust.
	* rs6000-tdep.c (ppc_deal_with_atomic_sequence): Adjust.
	* solib-irix.c (enable_break): Adjust to pass the current frame's
	address space to breakpoint functions.
	* sparc-tdep.c (sparc_software_single_step): Ditto.
	* spu-tdep.c (spu_software_single_step): Ditto.
	* alpha-tdep.c (alpha_software_single_step): Ditto.
	* record.c (record_wait): Adjust to pass an address space to the
	breakpoints module.

	* fork-child.c (fork_inferior): Set the new inferior's program and
	address spaces.
	* inf-ptrace.c (inf_ptrace_follow_fork): Copy the parent's program
	and address spaces.
	(inf_ptrace_attach): Set the inferior's program and address spaces.
	* linux-nat.c: Include "solib.h".
	(linux_child_follow_fork): Manage parent and child's program and
	address spaces.	 Clone the parent's program space if necessary.
	Don't wait for the vfork to be done here.  Refuse to resume if
	following the vfork parent while leaving the child stopped.
	(resume_callback): Don't resume a vfork parent.
	(linux_nat_resume): Also check for pending events in the
	lp->waitstatus field.
	(linux_handle_extended_wait): Report TARGET_WAITKIND_VFORK_DONE
	events to the core.
	(stop_wait_callback): Don't wait for SIGSTOP on vfork parents.
	(cancel_breakpoint): Adjust.
	* linux-thread-db.c (thread_db_wait): Don't remove thread event
	breakpoints here.
	(thread_db_mourn_inferior): Don't mark breakpoints out here.
	Remove thread event breakpoints after mourning.
	* corelow.c: Include progspace.h.
	(core_open): Set the inferior's program and address spaces.
	* remote.c (remote_add_inferior): Set the new inferior's program
	and address spaces.
	(remote_start_remote): Update address spaces.
	(extended_remote_create_inferior_1): Don't init the thread list if
	we already debugging other inferiors.
	* darwin-nat.c (darwin_attach): Set the new inferior's program and
	address spaces.
	* gnu-nat.c (gnu_attach): Ditto.
	* go32-nat.c (go32_create_inferior): Ditto.
	* inf-ttrace.c (inf_ttrace_follow_fork, inf_ttrace_attach): Ditto.
	* monitor.c (monitor_open): Ditto.
	* nto-procfs.c (procfs_attach, procfs_create_inferior): Ditto.
	* procfs.c (do_attach): Ditto.
	* windows-nat.c (do_initial_windows_stuff): Ditto.

	* inflow.c (inferior_process_group)
	(terminal_init_inferior_with_pgrp, terminal_inferior,
	(terminal_ours_1, inflow_inferior_exit, copy_terminal_info)
	(child_terminal_info, new_tty_postfork, set_sigint_trap): Adjust
	to use per-inferior data instead of inferior->terminal_info.
	(inflow_inferior_data): New.
	(inflow_new_inferior): Delete.
	(inflow_inferior_data_cleanup): New.
	(get_inflow_inferior_data): New.

	* mi/mi-interp.c (mi_new_inferior): Rename to...
	(mi_inferior_appeared): ... this.
	(mi_interpreter_init): Adjust.

	* tui/tui-disasm.c: Include "progspace.h".
	(tui_set_disassem_content): Pass an address space to
	breakpoint_here_p.

	* NEWS: Mention multi-program debugging support.  Mention new
	commands "add-inferior", "clone-inferior", "remove-inferior",
	"maint info program-spaces", and new option "set
	follow-exec-mode".

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/doc/
	* observer.texi (new_inferior): Rename to...
	(inferior_appeared): ... this.

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/testsuite/
	* gdb.base/foll-vfork.exp: Adjust to spell out "follow-fork".
	* gdb.base/foll-exec.exp: Adjust to expect a process id before
	"Executing new program".
	* gdb.base/foll-fork.exp: Adjust to spell out "follow-fork".
	* gdb.base/multi-forks.exp: Ditto.  Adjust to the inferior being
	left listed after having been killed.
	* gdb.base/attach.exp: Adjust to spell out "symbol-file".
	* gdb.base/maint.exp: Adjust test.

	* Makefile.in (ALL_SUBDIRS): Add gdb.multi.
	* gdb.multi/Makefile.in: New.
	* gdb.multi/base.exp: New.
	* gdb.multi/goodbye.c: New.
	* gdb.multi/hangout.c: New.
	* gdb.multi/hello.c: New.
	* gdb.multi/bkpt-multi-exec.c: New.
	* gdb.multi/bkpt-multi-exec.exp: New.
	* gdb.multi/crashme.c: New.

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/doc/
	* gdb.texinfo (Inferiors): Rename node to ...
	(Inferiors and Programs): ... this.  Mention running multiple
	programs in the same debug session.
	<info inferiors>: Mention the new 'Executable' column if "info
	inferiors".  Update examples.  Document the "add-inferior",
	"clone-inferior", "remove-inferior" and "maint info
	program-spaces" commands.
	(Process): Rename node to...
	(Forks): ... this.  Document "set|show follow-exec-mode".
@
text
@d3 1
a3 1
   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009
@


1.209
log
@gdb/
	* m68k-tdep.c (m68k_gdbarch_init): Allocate TDEP as cleared.
	* sparc-tdep.c (sparc32_gdbarch_init): Allocate TDEP as cleared.
	Remove explicit clearing of TDEP fields.
@
text
@d1315 1
d1326 1
a1326 1
    insert_single_step_breakpoint (arch, npc);
d1329 1
a1329 1
    insert_single_step_breakpoint (arch, nnpc);
@


1.208
log
@	* defs.h (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.
	* findvar.c (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.

	* gdbcore.h (read_memory_integer, safe_read_memory_integer,
	read_memory_unsigned_integer, write_memory_signed_integer,
	write_memory_unsigned_integer): Add BYTE_ORDER parameter.
	* corefile.c (struct captured_read_memory_integer_arguments): Add
	BYTE_ORDER member.
	(safe_read_memory_integer): Add BYTE_ORDER parameter.  Store it into
	struct captured_read_memory_integer_arguments.
	(do_captured_read_memory_integer): Pass it to read_memory_integer.
	(read_memory_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_signed_integer.
	(read_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_unsigned_integer.
	(write_memory_signed_integer): Add BYTE_ORDER parameter.  Pass it
	to store_signed_integer.
	(write_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it
	to store_unsigned_integer.

	* target.h (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	* target.c (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	Pass it to extract_unsigned_integer.


	Update calls to extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer, read_memory_integer,
	read_memory_unsigned_integer, safe_read_memory_integer,
	write_memory_signed_integer, write_memory_unsigned_integer, and
	get_target_memory_unsigned to pass byte order:
	* ada-lang.c (ada_value_binop): Update.
	* ada-valprint.c (char_at): Update.
	* alpha-osf1-tdep.c (alpha_osf1_sigcontext_addr): Update.
	* alpha-tdep.c (alpha_lds, alpha_sts, alpha_push_dummy_call,
	alpha_extract_return_value, alpha_read_insn,
	alpha_get_longjmp_target): Update.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Update.
	* amd64obsd-tdep.c (amd64obsd_supply_uthread,
	amd64obsd_collect_uthread, amd64obsd_trapframe_cache): Update.
	* amd64-tdep.c (amd64_push_dummy_call, amd64_analyze_prologue,
	amd64_frame_cache, amd64_sigtramp_frame_cache, fixup_riprel,
	amd64_displaced_step_fixup): Update.
	* arm-linux-tdep.c (arm_linux_sigreturn_init,
	arm_linux_rt_sigreturn_init, arm_linux_supply_gregset): Update.
	* arm-tdep.c (thumb_analyze_prologue, arm_skip_prologue,
	arm_scan_prologue, arm_push_dummy_call, thumb_get_next_pc,
	arm_get_next_pc, arm_extract_return_value, arm_store_return_value,
	arm_return_value): Update.
	* arm-wince-tdep.c (arm_pe_skip_trampoline_code): Update.
	* auxv.c (default_auxv_parse): Update.
	* avr-tdep.c (avr_address_to_pointer, avr_pointer_to_address,
	avr_scan_prologue, avr_extract_return_value,
	avr_frame_prev_register, avr_push_dummy_call): Update.
	* bsd-uthread.c (bsd_uthread_check_magic, bsd_uthread_lookup_offset,
	bsd_uthread_wait, bsd_uthread_thread_alive,
	bsd_uthread_extra_thread_info): Update.
	* c-lang.c (c_printstr, print_wchar): Update.
	* cp-valprint.c (cp_print_class_member): Update.
	* cris-tdep.c (cris_sigcontext_addr, cris_sigtramp_frame_unwind_cache,
	cris_push_dummy_call, cris_scan_prologue, cris_store_return_value,
	cris_extract_return_value, find_step_target, dip_prefix,
	sixteen_bit_offset_branch_op, none_reg_mode_jump_op,
	move_mem_to_reg_movem_op, get_data_from_address): Update.
	* dwarf2expr.c (dwarf2_read_address, execute_stack_op): Update.
	* dwarf2-frame.c (execute_cfa_program): Update.
	* dwarf2loc.c (find_location_expression): Update.
	* dwarf2read.c (dwarf2_const_value): Update.
	* expprint.c (print_subexp_standard): Update.
	* findvar.c (unsigned_pointer_to_address, signed_pointer_to_address,
	unsigned_address_to_pointer, address_to_signed_pointer,
	read_var_value): Update.
	* frame.c (frame_unwind_register_signed,
	frame_unwind_register_unsigned, get_frame_memory_signed,
	get_frame_memory_unsigned): Update.
	* frame-unwind.c (frame_unwind_got_constant): Update.
	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp,
	frv_linux_sigcontext_reg_addr, frv_linux_sigtramp_frame_cache):
	Update.
	* frv-tdep.c (frv_analyze_prologue, frv_skip_main_prologue,
	frv_extract_return_value, find_func_descr,
	frv_convert_from_func_ptr_addr, frv_push_dummy_call): Update.
	* f-valprint.c (f_val_print): Update.
	* gnu-v3-abi.c (gnuv3_decode_method_ptr, gnuv3_make_method_ptr):
	Update.
	* h8300-tdep.c (h8300_is_argument_spill, h8300_analyze_prologue,
	h8300_push_dummy_call, h8300_extract_return_value,
	h8300h_extract_return_value, h8300_store_return_value,
	h8300h_store_return_value): Update.
	* hppabsd-tdep.c (hppabsd_find_global_pointer): Update.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register, hppa_hpux_store_register):
	Update.
	* hppa-hpux-tdep.c (hppa32_hpux_in_solib_call_trampoline,
	hppa64_hpux_in_solib_call_trampoline,
	hppa_hpux_in_solib_return_trampoline, hppa_hpux_skip_trampoline_code,
	hppa_hpux_sigtramp_frame_unwind_cache,
	hppa_hpux_sigtramp_unwind_sniffer, hppa32_hpux_find_global_pointer,
	hppa64_hpux_find_global_pointer, hppa_hpux_search_pattern,
	hppa32_hpux_search_dummy_call_sequence,
	hppa64_hpux_search_dummy_call_sequence, hppa_hpux_supply_save_state,
	hppa_hpux_unwind_adjust_stub): Update.
	* hppa-linux-tdep.c (insns_match_pattern,
	hppa_linux_find_global_pointer): Update.
	* hppa-tdep.c (hppa_in_function_epilogue_p, hppa32_push_dummy_call,
	hppa64_convert_code_addr_to_fptr, hppa64_push_dummy_call,
	skip_prologue_hard_way, hppa_frame_cache, hppa_fallback_frame_cache,
	hppa_pseudo_register_read, hppa_frame_prev_register_helper,
	hppa_match_insns): Update.
	* hpux-thread.c (hpux_thread_fetch_registers): Update.
	* i386-tdep.c (i386bsd_sigcontext_addr): Update.
	* i386-cygwin-tdep.c (core_process_module_section): Update.
	* i386-darwin-nat.c (i386_darwin_sstep_at_sigreturn,
	amd64_darwin_sstep_at_sigreturn): Update.
	* i386-darwin-tdep.c (i386_darwin_sigcontext_addr,
	amd64_darwin_sigcontext_addr): Likewise.
	* i386-linux-nat.c (i386_linux_sigcontext_addr): Update.
	* i386nbsd-tdep.c (i386nbsd_sigtramp_cache_init): Update.
	* i386-nto-tdep.c (i386nto_sigcontext_addr): Update.
	* i386obsd-nat.c (i386obsd_supply_pcb): Update.
	* i386obsd-tdep.c (i386obsd_supply_uthread, i386obsd_collect_uthread,
	i386obsd_trapframe_cache): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_follow_jump,
	i386_analyze_frame_setup, i386_analyze_prologue,
	i386_skip_main_prologue, i386_frame_cache, i386_sigtramp_frame_cache,
	i386_get_longjmp_target, i386_push_dummy_call,
	i386_pe_skip_trampoline_code, i386_svr4_sigcontext_addr,
	i386_fetch_pointer_argument): Update.
	* i387-tdep.c (i387_supply_fsave): Update.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Update.
	* ia64-tdep.c (ia64_pseudo_register_read, ia64_pseudo_register_write,
	examine_prologue, ia64_frame_cache, ia64_frame_prev_register,
	ia64_sigtramp_frame_cache, ia64_sigtramp_frame_prev_register,
	ia64_access_reg, ia64_access_rse_reg, ia64_libunwind_frame_this_id,
	ia64_libunwind_frame_prev_register,
	ia64_libunwind_sigtramp_frame_this_id,
	ia64_libunwind_sigtramp_frame_prev_register, ia64_find_global_pointer,
	find_extant_func_descr, find_func_descr,
	ia64_convert_from_func_ptr_addr, ia64_push_dummy_call, ia64_dummy_id,
	ia64_unwind_pc): Update.
	* iq2000-tdep.c (iq2000_pointer_to_address, iq2000_address_to_pointer,
	iq2000_scan_prologue, iq2000_extract_return_value,
	iq2000_push_dummy_call): Update.
	* irix5nat.c (fill_gregset): Update.
	* jv-lang.c (evaluate_subexp_java): Update.
	* jv-valprint.c (java_value_print): Update.
	* lm32-tdep.c (lm32_analyze_prologue, lm32_push_dummy_call,
	lm32_extract_return_value, lm32_store_return_value): Update.
	* m32c-tdep.c (m32c_push_dummy_call, m32c_return_value,
	m32c_skip_trampoline_code, m32c_m16c_address_to_pointer,
	m32c_m16c_pointer_to_address): Update.
	* m32r-tdep.c (m32r_store_return_value, decode_prologue,
	m32r_skip_prologue, m32r_push_dummy_call, m32r_extract_return_value):
	Update.
	* m68hc11-tdep.c (m68hc11_pseudo_register_read,
	m68hc11_pseudo_register_write, m68hc11_analyze_instruction,
	m68hc11_push_dummy_call): Update.
	* m68linux-tdep.c (m68k_linux_pc_in_sigtramp,
	m68k_linux_get_sigtramp_info, m68k_linux_sigtramp_frame_cache):
	Update.
	* m68k-tdep.c (m68k_push_dummy_call, m68k_analyze_frame_setup,
	m68k_analyze_register_saves, m68k_analyze_prologue, m68k_frame_cache,
	m68k_get_longjmp_target): Update.
	* m88k-tdep.c (m88k_fetch_instruction): Update.
	* mep-tdep.c (mep_pseudo_cr32_read, mep_pseudo_csr_write,
	mep_pseudo_cr32_write, mep_get_insn, mep_push_dummy_call): Update.
	* mi/mi-main.c (mi_cmd_data_write_memory): Update.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target, supply_32bit_reg,
	mips64_linux_get_longjmp_target, mips64_fill_gregset,
	mips64_fill_fpregset, mips_linux_in_dynsym_stub): Update.
	* mipsnbdsd-tdep.c (mipsnbsd_get_longjmp_target): Update.
	* mips-tdep.c (mips_fetch_instruction, fetch_mips_16,
	mips_eabi_push_dummy_call, mips_n32n64_push_dummy_call,
	mips_o32_push_dummy_call, mips_o64_push_dummy_call,
	mips_single_step_through_delay, mips_skip_pic_trampoline_code,
	mips_integer_to_address): Update.
	* mn10300-tdep.c (mn10300_analyze_prologue, mn10300_push_dummy_call):
	Update.
	* monitor.c (monitor_supply_register, monitor_write_memory,
	monitor_read_memory_single): Update.
	* moxie-tdep.c (moxie_store_return_value, moxie_extract_return_value,
	moxie_analyze_prologue): Update.
	* mt-tdep.c (mt_return_value, mt_skip_prologue, mt_select_coprocessor,
	mt_pseudo_register_read, mt_pseudo_register_write, mt_registers_info,
	mt_push_dummy_call): Update.
	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class, find_implementation_from_class): Update.
	* ppc64-linux-tdep.c (ppc64_desc_entry_point,
	ppc64_linux_convert_from_func_ptr_addr, ppc_linux_sigtramp_cache):
	Update.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_sniffer,
	ppcobsd_sigtramp_frame_cache): Update.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call,
	do_ppc_sysv_return_value, ppc64_sysv_abi_push_dummy_call,
	ppc64_sysv_abi_return_value): Update.
	* ppc-linux-nat.c (ppc_linux_auxv_parse): Update.
	* procfs.c (procfs_auxv_parse): Update.
	* p-valprint.c (pascal_val_print): Update.
	* regcache.c (regcache_raw_read_signed, regcache_raw_read_unsigned,
	regcache_raw_write_signed, regcache_raw_write_unsigned,
	regcache_cooked_read_signed, regcache_cooked_read_unsigned,
	regcache_cooked_write_signed, regcache_cooked_write_unsigned): Update.
	* remote-m32r-sdi.c (m32r_fetch_register): Update.
	* remote-mips.c (mips_wait, mips_fetch_registers, mips_xfer_memory):
	Update.
	* rs6000-aix-tdep.c (rs6000_push_dummy_call, rs6000_return_value,
	rs6000_convert_from_func_ptr_addr, branch_dest,
	rs6000_software_single_step): Update.
	* rs6000-tdep.c (rs6000_in_function_epilogue_p,
	ppc_displaced_step_fixup, ppc_deal_with_atomic_sequence,
	bl_to_blrl_insn_p, rs6000_fetch_instruction, skip_prologue,
	rs6000_skip_main_prologue, rs6000_skip_trampoline_code,
	rs6000_frame_cache): Update.
	* s390-tdep.c (s390_pseudo_register_read, s390_pseudo_register_write,
	s390x_pseudo_register_read, s390x_pseudo_register_write, s390_load,
	s390_backchain_frame_unwind_cache, s390_sigtramp_frame_unwind_cache,
	extend_simple_arg, s390_push_dummy_call, s390_return_value): Update.
	* scm-exp.c (scm_lreadr): Update.
	* scm-lang.c (scm_get_field, scm_unpack): Update.
	* scm-valprint.c (scm_val_print): Update.
	* score-tdep.c (score_breakpoint_from_pc, score_push_dummy_call,
	score_fetch_inst): Update.
	* sh64-tdep.c (look_for_args_moves, sh64_skip_prologue_hard_way,
	sh64_analyze_prologue, sh64_push_dummy_call, sh64_extract_return_value,
	sh64_pseudo_register_read, sh64_pseudo_register_write,
	sh64_frame_prev_register): Update:
	* sh-tdep.c (sh_analyze_prologue, sh_push_dummy_call_fpu,
	sh_push_dummy_call_nofpu, sh_extract_return_value_nofpu,
	sh_store_return_value_nofpu, sh_in_function_epilogue_p): Update.
	* solib-darwin.c (darwin_load_image_infos): Update.
	* solib-frv.c (fetch_loadmap, lm_base, frv_current_sos, enable_break2,
	find_canonical_descriptor_in_load_object): Update.
	* solib-irix.c (extract_mips_address, fetch_lm_info, irix_current_sos,
	irix_open_symbol_file_object): Update.
	* solib-som.c (som_solib_create_inferior_hook, link_map_start,
	som_current_sos, som_open_symbol_file_object): Update.
	* solib-sunos.c (SOLIB_EXTRACT_ADDRESS, LM_ADDR, LM_NEXT, LM_NAME):
	Update.
	* solib-svr4.c (read_program_header, scan_dyntag_auxv,
	solib_svr4_r_ldsomap): Update.
	* sparc64-linux-tdep.c (sparc64_linux_step_trap): Update.
	* sparc64obsd-tdep.c (sparc64obsd_supply_uthread,
	sparc64obsd_collect_uthread): Update.
	* sparc64-tdep.c (sparc64_pseudo_register_read,
	sparc64_pseudo_register_write, sparc64_supply_gregset,
	sparc64_collect_gregset): Update.
	* sparc-linux-tdep.c (sparc32_linux_step_trap): Update.
	* sparcobsd-tdep.c (sparc32obsd_supply_uthread,
	sparc32obsd_collect_uthread): Update.
	* sparc-tdep.c (sparc_fetch_wcookie, sparc32_push_dummy_code,
	sparc32_store_arguments, sparc32_return_value, sparc_supply_rwindow,
	sparc_collect_rwindow): Update.
	* spu-linux-nat.c (parse_spufs_run): Update.
	* spu-tdep.c (spu_pseudo_register_read_spu,
	spu_pseudo_register_write_spu, spu_pointer_to_address,
	spu_analyze_prologue, spu_in_function_epilogue_p,
	spu_frame_unwind_cache, spu_push_dummy_call, spu_software_single_step,
	spu_get_longjmp_target, spu_get_overlay_table, spu_overlay_update_osect,
	info_spu_signal_command, info_spu_mailbox_list, info_spu_dma_cmdlist,
	info_spu_dma_command, info_spu_proxydma_command): Update.
	* stack.c (print_frame_nameless_args, frame_info): Update.
	* symfile.c (read_target_long_array, simple_read_overlay_table,
	simple_read_overlay_region_table): Update.
	* target.c (debug_print_register): Update.
	* tramp-frame.c (tramp_frame_start): Update.
	* v850-tdep.c (v850_analyze_prologue, v850_push_dummy_call,
	v850_extract_return_value, v850_store_return_value,
	* valarith.c (value_binop, value_bit_index): Update.
	* valops.c (value_cast): Update.
	* valprint.c (val_print_type_code_int, val_print_string,
	read_string): Update.
	* value.c (unpack_long, unpack_double, unpack_field_as_long,
	modify_field, pack_long): Update.
	* vax-tdep.c (vax_store_arguments, vax_push_dummy_call,
	vax_skip_prologue): Update.
	* xstormy16-tdep.c (xstormy16_push_dummy_call,
	xstormy16_analyze_prologue, xstormy16_in_function_epilogue_p,
	xstormy16_resolve_jmp_table_entry, xstormy16_find_jmp_table_entry,
	xstormy16_pointer_to_address, xstormy16_address_to_pointer): Update.
	* xtensa-tdep.c (extract_call_winsize, xtensa_pseudo_register_read,
	xtensa_pseudo_register_write, xtensa_frame_cache,
	xtensa_push_dummy_call, call0_track_op, call0_frame_cache): Update.


	* dfp.h (decimal_to_string, decimal_from_string, decimal_from_integral,
	decimal_from_floating, decimal_to_doublest, decimal_is_zero): Add
	BYTE_ORDER parameter.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	* dfp.c (match_endianness): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.
	(decimal_to_string, decimal_from_integral, decimal_from_floating,
	decimal_to_doublest, decimal_is_zero): Add BYTE_ORDER parameter.
	Pass it to match_endianness.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.  Pass them to match_endianness.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	Pass them to match_endianness.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	Pass them to match_endianness.
	* valarith.c (value_args_as_decimal): Add BYTE_ORDER_X and
	BYTE_ORDER_Y output parameters.
	(value_binop): Update call to value_args_as_decimal.

	Update calls to decimal_to_string, decimal_from_string,
	decimal_from_integral, decimal_from_floating, decimal_to_doublest,
	decimal_is_zero, decimal_binop, decimal_compare and decimal_convert
	to pass/receive byte order:
	* c-exp.y (parse_number): Update.
	* printcmd.c (printf_command): Update.
	* valarith.c (value_args_as_decimal, value_binop, value_logical_not,
	value_equal, value_less): Update.
	* valops.c (value_cast, value_one): Update.
	* valprint.c (print_decimal_floating): Update.
	* value.c (unpack_long, unpack_double): Update.
	* python/python-value.c (valpy_nonzero): Update.


	* ada-valprint.c (char_at): Add BYTE_ORDER parameter.
	(printstr): Update calls to char_at.
	(ada_val_print_array): Likewise.
	* valprint.c (read_string): Add BYTE_ORDER parameter.
	(val_print_string): Update call to read_string.
	* c-lang.c (c_get_string): Likewise.
	* charset.h (target_wide_charset): Add BYTE_ORDER parameter.
	* charset.c (target_wide_charset): Add BYTE_ORDER parameter.
	Use it instead of current_gdbarch.
	* printcmd.c (printf_command): Update calls to target_wide_charset.
	* c-lang.c (charset_for_string_type): Add BYTE_ORDER parameter.
	Pass to target_wide_charset.  Use it instead of current_gdbarch.
	(classify_type): Add BYTE_ORDER parameter.  Pass to
	charset_for_string_type.  Allow NULL encoding pointer.
	(print_wchar): Add BYTE_ORDER parameter.
	(c_emit_char): Update calls to classify_type and print_wchar.
	(c_printchar, c_printstr): Likewise.


	* gdbarch.sh (in_solib_return_trampoline): Convert to type "m".
	* gdbarch.c, gdbarch.h: Regenerate.
	* arch-utils.h (generic_in_solib_return_trampoline): Add GDBARCH
	parameter.
	* arch-utils.c (generic_in_solib_return_trampoline): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_in_solib_return_trampoline): Likewise.
	* rs6000-tdep.c (rs6000_in_solib_return_trampoline): Likewise.
	(rs6000_skip_trampoline_code): Update call.

	* alpha-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	dynamic_sigtramp_offset and pc_in_sigtramp callbacks.
	(alpha_read_insn): Add GDBARCH parameter.
	* alpha-tdep.c (alpha_lds, alpha_sts): Add GDBARCH parameter.
	(alpha_register_to_value): Pass architecture to alpha_sts.
	(alpha_extract_return_value): Likewise.
	(alpha_value_to_register): Pass architecture to alpha_lds.
	(alpha_store_return_value): Likewise.
	(alpha_read_insn): Add GDBARCH parameter.
	(alpha_skip_prologue): Pass architecture to alpha_read_insn.
	(alpha_heuristic_proc_start): Likewise.
	(alpha_heuristic_frame_unwind_cache): Likewise.
	(alpha_next_pc): Likewise.
	(alpha_sigtramp_frame_this_id): Pass architecture to
	tdep->dynamic_sigtramp_offset callback.
	(alpha_sigtramp_frame_sniffer): Pass architecture to
	tdep->pc_in_sigtramp callback.
	* alphafbsd-tdep.c (alphafbsd_pc_in_sigtramp): Add GDBARCH parameter.
	(alphafbsd_sigtramp_offset): Likewise.
	* alpha-linux-tdep.c (alpha_linux_sigtramp_offset_1): Add GDBARCH
	parameter.  Pass to alpha_read_insn.
	(alpha_linux_sigtramp_offset): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset_1.
	(alpha_linux_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset.
	(alpha_linux_sigcontext_addr): Pass architecture to alpha_read_insn
	and alpha_linux_sigtramp_offset.
	* alphanbsd-tdep.c (alphanbsd_sigtramp_offset): Add GDBARCH parameter.
	(alphanbsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alphanbsd_sigtramp_offset.
	* alphaobsd-tdep.c (alphaobsd_sigtramp_offset): Add GDBARCH parameter.
	(alphaobsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_read_insn.
	(alphaobsd_sigcontext_addr): Pass architecture to
	alphaobsd_sigtramp_offset.
	* alpha-osf1-tdep.c (alpha_osf1_pc_in_sigtramp): Add GDBARCH
	parameter.

	* amd64-tdep.c (amd64_analyze_prologue): Add GDBARCH parameter.
	(amd64_skip_prologue): Pass architecture to amd64_analyze_prologue.
	(amd64_frame_cache): Likewise.

	* arm-tdep.c (SWAP_SHORT, SWAP_INT): Remove.
	(thumb_analyze_prologue, arm_skip_prologue, arm_scan_prologue,
	thumb_get_next_pc, arm_get_next_pc): Do not use SWAP_ macros.
	* arm-wince-tdep.c: Include "frame.h".

	* avr-tdep.c (EXTRACT_INSN): Remove.
	(avr_scan_prologue): Add GDBARCH argument, inline EXTRACT_INSN.
	(avr_skip_prologue): Pass architecture to avr_scan_prologue.
	(avr_frame_unwind_cache): Likewise.

	* cris-tdep.c (struct instruction_environment): Add BYTE_ORDER member.
	(find_step_target): Initialize it.
	(get_data_from_address): Add BYTE_ORDER parameter.
	(bdap_prefix): Pass byte order to get_data_from_address.
	(handle_prefix_assign_mode_for_aritm_op): Likewise.
	(three_operand_add_sub_cmp_and_or_op): Likewise.
	(handle_inc_and_index_mode_for_aritm_op): Likewise.

	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp): Add GDBARCH parameter.
	(frv_linux_sigcontext_reg_addr): Pass architecture to
	frv_linux_pc_in_sigtramp.
	(frv_linux_sigtramp_frame_sniffer): Likewise.

	* h8300-tdep.c (h8300_is_argument_spill): Add GDBARCH parameter.
	(h8300_analyze_prologue): Add GDBARCH parameter.  Pass to
	h8300_is_argument_spill.
	(h8300_frame_cache, h8300_skip_prologue): Pass architecture
	to h8300_analyze_prologue.

	* hppa-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	in_solib_call_trampoline callback.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.
	* hppa-tdep.c (hppa64_convert_code_addr_to_fptr): Add GDBARCH
	parameter.
	(hppa64_push_dummy_call): Pass architecture to
	hppa64_convert_code_addr_to_fptr.
	(hppa_match_insns): Add GDBARCH parameter.
	(hppa_match_insns_relaxed): Add GDBARCH parameter.  Pass to
	hppa_match_insns.
	(hppa_skip_trampoline_code): Pass architecture to hppa_match_insns.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.  Pass to
	hppa_match_insns_relaxed.
	(hppa_stub_unwind_sniffer): Pass architecture to
	tdep->in_solib_call_trampoline callback.
	* hppa-hpux-tdep.c (hppa_hpux_search_pattern): Add GDBARCH parameter.
	(hppa32_hpux_search_dummy_call_sequence): Pass architecture to
	hppa_hpux_search_pattern.
	* hppa-linux-tdep.c (insns_match_pattern): Add GDBARCH parameter.
	(hppa_linux_sigtramp_find_sigcontext): Add GDBARCH parameter.
	Pass to insns_match_pattern.
	(hppa_linux_sigtramp_frame_unwind_cache): Pass architecture to
	hppa_linux_sigtramp_find_sigcontext.
	(hppa_linux_sigtramp_frame_sniffer): Likewise.
	(hppa32_hpux_in_solib_call_trampoline): Add GDBARCH parameter.
	(hppa64_hpux_in_solib_call_trampoline): Likewise.

	* i386-tdep.c (i386_follow_jump): Add GDBARCH parameter.
	(i386_analyze_frame_setup): Add GDBARCH parameter.
	(i386_analyze_prologue): Add GDBARCH parameter.  Pass to
	i386_follow_jump and i386_analyze_frame_setup.
	(i386_skip_prologue): Pass architecture to i386_analyze_prologue
	and i386_follow_jump.
	(i386_frame_cache): Pass architecture to i386_analyze_prologue.
	(i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-tdep.h (i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-cygwin-tdep.c (i386_cygwin_skip_trampoline_code): Pass
	frame to i386_pe_skip_trampoline_code.

	* ia64-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter
	to sigcontext_register_address callback.
	* ia64-tdep.c (ia64_find_global_pointer): Add GDBARCH parameter.
	(ia64_find_unwind_table): Pass architecture to
	ia64_find_global_pointer.
	(find_extant_func_descr): Add GDBARCH parameter.
	(find_func_descr): Pass architecture to find_extant_func_descr
	and ia64_find_global_pointer.
	(ia64_sigtramp_frame_init_saved_regs): Pass architecture to
	tdep->sigcontext_register_address callback.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Add
	GDBARCH parameter.

	* iq2000-tdep.c (iq2000_scan_prologue): Add GDBARCH parameter.
	(iq2000_frame_cache): Pass architecture to iq2000_scan_prologue.

	* lm32-tdep.c (lm32_analyze_prologue): Add GDBARCH parameter.
	(lm32_skip_prologue, lm32_frame_cache): Pass architecture to
	lm32_analyze_prologue.

	* m32r-tdep.c (decode_prologue): Add GDBARCH parameter.
	(m32r_skip_prologue): Pass architecture to decode_prologue.

	* m68hc11-tdep.c (m68hc11_analyze_instruction): Add GDBARCH parameter.
	(m68hc11_scan_prologue): Pass architecture to
	m68hc11_analyze_instruction.

	* m68k-tdep.c (m68k_analyze_frame_setup): Add GDBARCH parameter.
	(m68k_analyze_prologue): Pass architecture to
	m68k_analyze_frame_setup.

	* m88k-tdep.c (m88k_fetch_instruction): Add BYTE_ORDER parameter.
	(m88k_analyze_prologue): Add GDBARCH parameter.  Pass byte order
	to m88k_fetch_instruction.
	(m88k_skip_prologue): Pass architecture to m88k_analyze_prologue.
	(m88k_frame_cache): Likewise.

	* mep-tdep.c (mep_get_insn): Add GDBARCH parameter.
	(mep_analyze_prologue): Pass architecture to mep_get_insn.

	* mips-tdep.c (mips_fetch_instruction): Add GDBARCH parameter.
	(mips32_next_pc): Pass architecture to mips_fetch_instruction.
	(deal_with_atomic_sequence): Likewise.
	(unpack_mips16): Add GDBARCH parameter, pass to mips_fetch_instruction.
	(mips16_scan_prologue): Likewise.
	(mips32_scan_prologue): Likewise.
	(mips16_in_function_epilogue_p): Likewise.
	(mips32_in_function_epilogue_p): Likewise.
	(mips_about_to_return): Likewise.
	(mips_insn16_frame_cache): Pass architecture to mips16_scan_prologue.
	(mips_insn32_frame_cache): Pass architecture to mips32_scan_prologue.
	(mips_skip_prologue): Pass architecture to mips16_scan_prologue
	and mips32_scan_prologue.
	(mips_in_function_epilogue_p): Pass architecture to
	mips16_in_function_epilogue_p and
	mips32_in_function_epilogue_p.
	(heuristic_proc_start): Pass architecture to mips_fetch_instruction
	and mips_about_to_return.
	(mips_skip_mips16_trampoline_code): Pass architecture to
	mips_fetch_instruction.
	(fetch_mips_16): Add GDBARCH parameter.
	(mips16_next_pc): Pass architecture to fetch_mips_16.
	(extended_mips16_next_pc): Pass architecture to unpack_mips16 and
	fetch_mips_16.

	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class): Add GDBARCH parameter.
	(find_implementation_from_class): Add GDBARCH parameter, pass
	to read_objc_class, read_objc_methlist_nmethods, and
	read_objc_methlist_method.
	(find_implementation): Add GDBARCH parameter, pass to
	read_objc_object and find_implementation_from_class.
	(resolve_msgsend, resolve_msgsend_stret): Pass architecture
	to find_implementation.
	(resolve_msgsend_super, resolve_msgsend_super_stret): Pass
	architecture to read_objc_super and find_implementation_from_class.

	* ppc64-linux-tdep.c (ppc64_desc_entry_point): Add GDBARCH parameter.
	(ppc64_standard_linkage1_target, ppc64_standard_linkage2_target,
	ppc64_standard_linkage3_target): Pass architecture to
	ppc64_desc_entry_point.
	* rs6000-tdep.c (bl_to_blrl_insn_p): Add BYTE_ORDER parameter.
	(skip_prologue): Pass byte order to bl_to_blrl_insn_p.
	(rs6000_fetch_instruction): Add GDBARCH parameter.
	(rs6000_skip_stack_check): Add GDBARCH parameter, pass to
	rs6000_fetch_instruction.
	(skip_prologue): Pass architecture to rs6000_fetch_instruction.

	* remote-mips.c (mips_store_word): Return old_contents as host
	integer value instead of target bytes.

	* s390-tdep.c (struct s390_prologue_data): Add BYTE_ORDER member.
	(s390_analyze_prologue): Initialize it.
	(extend_simple_arg): Add GDBARCH parameter.
	(s390_push_dummy_call): Pass architecture to extend_simple_arg.

	* scm-lang.c (scm_get_field): Add BYTE_ORDER parameter.
	* scm-lang.h (scm_get_field): Add BYTE_ORDER parameter.
	(SCM_CAR, SCM_CDR): Pass SCM_BYTE_ORDER to scm_get_field.
	* scm-valprint.c (scm_scmval_print): Likewise.
	(scm_scmlist_print, scm_ipruk, scm_scmval_print): Define
	SCM_BYTE_ORDER.

	* sh64-tdep.c (look_for_args_moves): Add GDBARCH parameter.
	(sh64_skip_prologue_hard_way): Add GDBARCH parameter, pass to
	look_for_args_moves.
	(sh64_skip_prologue): Pass architecture to
	sh64_skip_prologue_hard_way.
	* sh-tdep.c (sh_analyze_prologue): Add GDBARCH parameter.
	(sh_skip_prologue): Pass architecture to sh_analyze_prologue.
	(sh_frame_cache): Likewise.

	* solib-irix.c (extract_mips_address): Add GDBARCH parameter.
	(fetch_lm_info, irix_current_sos, irix_open_symbol_file_object):
	Pass architecture to extract_mips_address.

	* sparc-tdep.h (sparc_fetch_wcookie): Add GDBARCH parameter.
	* sparc-tdep.c (sparc_fetch_wcookie): Add GDBARCH parameter.
	(sparc_supply_rwindow, sparc_collect_rwindow): Pass architecture
	to sparc_fetch_wcookie.
	(sparc32_frame_prev_register): Likewise.
	* sparc64-tdep.c (sparc64_frame_prev_register): Likewise.
	* sparc32nbsd-tdep.c (sparc32nbsd_sigcontext_saved_regs): Likewise.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_saved_regs): Likewise.

	* spu-tdep.c (spu_analyze_prologue): Add GDBARCH parameter.
	(spu_skip_prologue): Pass architecture to spu_analyze_prologue.
	(spu_virtual_frame_pointer): Likewise.
	(spu_frame_unwind_cache): Likewise.
	(info_spu_mailbox_list): Add BYTE_ORER parameter.
	(info_spu_mailbox_command): Pass byte order to info_spu_mailbox_list.
	(info_spu_dma_cmdlist): Add BYTE_ORER parameter.
	(info_spu_dma_command, info_spu_proxydma_command): Pass byte order
	to info_spu_dma_cmdlist.

	* symfile.c (read_target_long_array): Add GDBARCH parameter.
	(simple_read_overlay_table, simple_read_overlay_region_table,
	simple_overlay_update_1): Pass architecture to read_target_long_array.

	* v850-tdep.c (v850_analyze_prologue): Add GDBARCH parameter.
	(v850_frame_cache): Pass architecture to v850_analyze_prologue.

	* xstormy16-tdep.c (xstormy16_analyze_prologue): Add GDBARCH
	parameter.
	(xstormy16_skip_prologue, xstormy16_frame_cache): Pass architecture
	to xstormy16_analyze_prologue.
	(xstormy16_resolve_jmp_table_entry): Add GDBARCH parameter.
	(xstormy16_find_jmp_table_entry): Likewise.
	(xstormy16_skip_trampoline_code): Pass architecture to
	xstormy16_resolve_jmp_table_entry.
	(xstormy16_pointer_to_address): Likewise.
	(xstormy16_address_to_pointer): Pass architecture to
	xstormy16_find_jmp_table_entry.

	* xtensa-tdep.c (call0_track_op): Add GDBARCH parameter.
	(call0_analyze_prologue): Add GDBARCH parameter, pass to
	call0_track_op.
	(call0_frame_cache): Pass architecture to call0_analyze_prologue.
	(xtensa_skip_prologue): Likewise.
@
text
@d1380 1
a1380 1
  tdep = XMALLOC (struct gdbarch_tdep);
a1384 5
  tdep->gregset = NULL;
  tdep->sizeof_gregset = 0;
  tdep->fpregset = NULL;
  tdep->sizeof_fpregset = 0;
  tdep->plt_entry_size = 0;
@


1.207
log
@	* breakpoint.h (struct breakpoint): New member GDBARCH.
	* breakpoint.c: Include "arch-utils.h".
	(set_raw_breakpoint_without_location): Add GDBARCH parameter.
	Use it to set breakpoint architecture.
	(set_raw_breakpoint): Add GDBARCH parameter.
	(create_internal_breakpoint): Likewise.
	(create_catchpoint): Likewise.
	(create_fork_vfork_event_catchpoint): Likewise.
	(create_breakpoint): Likewise.
	(create_breakpoints): Likewise.
	(break_command_really): Likewise.
	(create_ada_exception_breakpoint): Likewise.
	Update local callers to pass architecture:
	(create_internal_breakpoint): Update.
	(create_overlay_event_breakpoint): Update.
	(create_longjmp_master_breakpoint): Update.
	(create_thread_event_breakpoint): Update.
	(create_solib_event_breakpoint): Update.
	(create_catchpoint): Update.
	(create_fork_vfork_event_catchpoint): Update.
	(set_momentary_breakpoint): Update.
	(clone_momentary_breakpoint): Update.
	(create_breakpoint): Update.
	(create_breakpoints): Update.
	(break_command_really): Update.
	(break_command_1): Update.
	(set_breakpoint): Update.
	(watch_command_1): Update.
	(catch_fork_command_1): Update.
	(catch_exec_commnd_1): Update.
	(handle_gnu_v3_exceptions): Update.
	(create_ada_exception_breakpoint): Update.
	(catch_ada_exception_command): Update.
	(catch_assert_command): Update.
	(trace_command): Update.

	* breakpoint.h (struct bp_location): New member GDBARCH.
	* breakpoint.c (get_sal_arch): New function.
	(set_raw_breakpoint): Set location architecture.
	(add_location_to_breakpoint): Likewise.
	(clone_momentary_breakpoint): Likewise.
	(watch_command_1): Likewise.
	(update_watchpoint): Likewise.
	(bp_loc_is_permanent): Use location architecture instead of
	current_gdbarch.
	(adjust_breakpoint_address): Add GDBARCH parameter; use it
	instead of current_gdbarch.
	Update callers of adjust_breakpoint_address to pass
	breakpoint location architecture:
	(set_raw_breakpoint): Update.
	(watch_command_1): Update.

        * tracepoint.c: (collect_symbol): Add GDBARCH parameter, use instead
	of current_gdbarch.
	(add_local_symbols): Add GDBARCH parameter.  Pass to collect_symbol.
	(encode_actions): Pass tracepoint architecture to add_local_symbols
	(encode_actions): Use tracepoint architecture instead of
	current_gdbarch.  Pass it to add_local_symbols and collect_symbol.

	* breakpoint.h (struct breakpoint_ops): Replace last_addr parameter
	of print_one callback with last_loc.
	* breakpoint.c (print_one_breakpoint_location): Replace last_addr
	parameter with last_loc.
	(print_one_breakpoint): Likewise.
	(do_captured_breakpoint_query): Update call.
	(breakpoint_1): Pass last_loc instead of last_addr to
	print_one_breakpoint.  Pass last location architecture instead of
	current_gdbarch to set_next_address.
	Update all implementations of the print_one callback:
	* breakpoint.c (print_one_catch_fork): Update.
	(print_one_catch_vfork): Update.
	(print_one_catch_exec): Update.
	(print_one_exception_catchpoint): Update.
	* ada-lang.c (print_one_exception): Update.
	(print_one_catch_exception): Update.
	(print_one_catch_exception_unhandled): Update.
	(print_one_catch_assert): Update.

	* breakpoint.c (print_one_breakpoint_location): Add PRINT_ADDRESS_BITS
	parameter.  Use it instead of gdbarch_addr_bit (current_gdbarch).
	(print_one_breakpoint): Add PRINT_ADDRESS_BITS parameter and pass it
	to print_one_breakpoint_location.
	(breakpoint_address_bits): New function.
	(do_captured_breakpoint_query): Compute number of address bits to print
	and pass it to print_one_breakpoint.
	(breakpoint_1): Likewise.  Use it instead of current_gdbarch.

	* breakpoint.h (create_thread_event_breakpoint): Add GDBARCH.
	* breakpoint.c (create_thread_event_breakpoint): Likewise.
	Update callers to create_thread_event_breakpoint:
	* aix-thread.c (pd_enable): Update.
	* linux-thread-db.c (enable_thread_event): Update.

	* breakpoint.h (create_solib_event_breakpoint): Add GDBARCH.
	* breakpoint.c (create_solib_event_breakpoint): Likewise.
	Update callers to create_solib_event_breakpoint:
	* solib-frv.c (enable_break, enable_break2): Update.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Update.
	* solib-som.c (som_solib_create_inferior_hook): Update.
	* solib-darwin.c (darwin_solib_create_inferior_hook): Update.
	* solib-svr4.c (enable_break): Update.

	* breakpoint.h (insert_single_step_breakpoint): Add GDBARCH.
	* breakpoint.c (insert_single_step_breakpoint): Likewise.
	Update callers to insert_single_step_breakpoint:
	* alpha-tdep.c (alpha_software_single_step): Update.
	* arm-linux-tdep.c (arm_linux_software_single_step): Update.
	* arm-tdep.c (arm_software_single_step): Update.
	* cris-tdep.c (cris_software_single_step): Update.
	* rs6000-aix-tdep.c (rs6000_software_single_step): Update.
	* rs6000-tdep.c (ppc_deal_with_atomic_sequence): Update.
	* sparc-tdep.c (sparc_software_single_step): Update.
	* spu-tdep.c (spu_software_single_step): Update.
	* mips-tdep.c (deal_with_atomic_sequence): Add GDBARCH parameter.
	Pass it to insert_single_step_breakpoint.
	(mips_software_single_step): Pass architecture to
	deal_with_atomic_sequence and insert_single_step_breakpoint.

	* breakpoint.h (deprecated_insert_raw_breakpoint): Add GDBARCH.
	(deprecated_remove_raw_breakpoint): Likewise.
	* breakpoint.c (deprecated_insert_raw_breakpoint): Add GDBARCH.
	(deprecated_remove_raw_breakpoint): Likewise.
	Update callers to deprecated_insert_raw_breakpoint and
	deprecated_remove_raw_breakpoint:
	* breakpoint.c (single_step_gdbarch): New static variable.
	(insert_single_step_breakpoint): Pass GDBARCH parameter to
	deprecated_insert_raw_breakpoint.  Store it in single_step_gdbarch.
	(remove_single_step_breakpoints): Pass architecture stored in
	single_step_gdbarch to deprecated_remove_raw_breakpoint.
	* rs6000-nat.c (exec_one_dummy_insn): Update.
	* solib-irix.c (enable_break, disable_break): Update.
	* procfs.c (procfs_mourn_inferior): Update.
	(remove_dbx_link_breakpoint): Update.

	* breakpoint.h (set_breakpoint): Add GDBARCH parameter.
	(set_momentary_breakpoint, set_momentary_breakpoint_at_pc): Likewise.
	* breakpoint.c (set_breakpoint): Add GDBARCH parameter.
	(set_momentary_breakpoint, set_momentary_breakpoint_at_pc): Likewise.
	Update callers to set_breakpoint, set_momentary_breakpoint and
	set_momentary_breakpoint_at_pc:
	* breakpoint.c (set_momentary_breakpoint_at_pc): Update.
	(until_break_command): Update.
	* infcall.c (call_function_by_hand): Update.
	* infcmd.c (finish_backward, finish_forward): Update.
	* infrun.c (insert_step_resume_breakpoint_at_sal): Add GDBARCH
	parameter.  Pass it to set_momentary_breakpoint.
	(insert_longjmp_resume_breakpoint): Add GDBARCH parameter.
	Pass it to set_momentary_breakpoint_at_pc.
	(handle_inferior_event): Update.
	(insert_step_resume_breakpoint_at_frame): Update.
	(insert_step_resume_breakpoint_at_caller): Update..
	* mi/mi-cmd-break.c: Include "arch-utils.h".
	(mi_cmd_break_insert): Update.

	* target.h (struct target_ops): Add GDBARCH parameter to
	to_insert_breakpoint, to_remove_breakpoint, to_insert_hw_breakpoint,
	and to_remove_hw_breakpoint members.
	(target_insert_breakpoint, target_remove_breakpoint,
	target_insert_hw_breakpoint, target_remove_hw_breakpoint): Add GDBARCH
	parameter, pass to target routine.
	(memory_remove_breakpoint, memory_insert_breakpoint): Add GDBARCH
	parameter.
	* target.c (debug_to_insert_breakpoint, debug_to_remove_breakpoint,
	debug_to_insert_hw_breakpoint, debug_to_remove_hw_breakpoint): Add
	GDBARCH parameter, pass to target routine.
	(update_current_target): Update function signature.
	* breakpoint.c (insert_bp_location, remove_breakpoint,
	deprecated_insert_raw_breakpoint, deprecated_remove_raw_breakpoint):
	Pass architecture to target_ routines.
	Update all implementations of the target breakpoint routines to take
	GDBARCH parameter and use it instead of GDBARCH as appropriate:
	* corelow.c (ignore): Update.
	* exec.c (ignore): Update.
	* mem-break.c (memory_insert_breakpoint): Update.
	(memory_remove_breakpoint): Update.
	* monitor.c (monitor_insert_breakpoint): Update.
	(monitor_remove_breakpoint): Update.
	* record.c (record_insert_breakpoint): Update.
	(record_beneath_to_insert_breakpoint): Update.
	(record_remove_breakpoint): Update.
	(record_beneath_to_remove_breakpoint): Update.
	* remote.c (remote_insert_breakpoint): Update.
	(remote_remove_breakpoint): Update.
	(remote_insert_hw_breakpoint): Update.
	(remote_remove_hw_breakpoint): Update.
	* remote-m32r-sdi.c (m32r_insert_breakpoint): Update.
	(m32r_remove_breakpoint): Update.
	* remote-mips.c (mips_insert_breakpoint): Update.
	(mips_remove_breakpoint): Update.
	* i386-nat.c (i386_insert_hw_breakpoint): Update.
	(i386_remove_hw_breakpoint): Update.
	* nto-procfs.c (procfs_insert_breakpoint):  Update.
	(procfs_remove_breakpoint): Update.
	(procfs_insert_hw_breakpoint): Update.
	(procfs_remove_hw_breakpoint): Update.

doc/ChangeLog:

	* gdbint.texi (Examples of Use of @@code{ui_out} functions):
	Update example code extrated from breakpoint.c.
@
text
@d155 1
a155 1
sparc_fetch_wcookie (void)
d157 1
d169 1
a169 1
  return extract_unsigned_integer (buf, len);
d404 2
d414 2
a415 1
      store_unsigned_integer (buf, 4, TYPE_LENGTH (value_type) & 0x1fff);
d429 1
d512 1
a512 1
      store_unsigned_integer (buf, 4, struct_addr);
d962 1
d983 1
a983 1
    ULONGEST wcookie = sparc_fetch_wcookie ();
d1142 2
d1160 1
a1160 1
	  addr = read_memory_unsigned_integer (sp + 64, 4);
d1459 2
d1479 2
a1480 2
		  ULONGEST wcookie = sparc_fetch_wcookie ();
		  ULONGEST i7 = extract_unsigned_integer (buf + offset, 8);
d1482 3
a1484 1
		  store_unsigned_integer (buf + offset, 8, i7 ^ wcookie);
d1515 2
a1516 2
		  ULONGEST wcookie = sparc_fetch_wcookie ();
		  ULONGEST i7 = extract_unsigned_integer (buf + offset, 4);
d1518 3
a1520 1
		  store_unsigned_integer (buf + offset, 4, i7 ^ wcookie);
d1533 2
d1553 2
a1554 2
		  ULONGEST wcookie = sparc_fetch_wcookie ();
		  ULONGEST i7 = extract_unsigned_integer (buf + offset, 8);
d1556 2
a1557 1
		  store_unsigned_integer (buf, 8, i7 ^ wcookie);
d1583 2
a1584 2
		  ULONGEST wcookie = sparc_fetch_wcookie ();
		  ULONGEST i7 = extract_unsigned_integer (buf + offset, 4);
d1586 3
a1588 1
		  store_unsigned_integer (buf + offset, 4, i7 ^ wcookie);
@


1.206
log
@	* gdbtypes.h (TYPE_OBJFILE_OWNED, TYPE_OWNER): New macros.
	(TYPE_OBJFILE, TYPE_ALLOC, TYPE_ZALLOC): Reimplement.
	(alloc_type_arch): Add prototype.
	(alloc_type_copy): Likewise.
	(get_type_arch): Likewise.
	(arch_type): Likewise.
	(arch_integer_type): Likewise.
	(arch_character_type): Likewise.
	(arch_boolean_type): Likewise.
	(init_float_type): Remove, replace by ...
	(arch_float_type): ... this.
	(init_complex_type): Remove, replace by ...
	(arch_complex_type): ... this.
	(init_flags_type): Remove, replace by ...
	(arch_flags_type): ... this.
	(init_composite_type): Remove, replace by ...
	(arch_composite_type): ... this.

	* gdbtypes.c (alloc_type): No longer support NULL objfile.
	(init_type): Likewise.
	(alloc_type_arch): New function.
	(alloc_type_copy): New function.
	(get_type_arch): New function.

	(smash_type): Preserve type ownership information.
	(make_pointer_type, make_reference_type, make_function_type,
	smash_to_memberptr_type, smash_to_method_type): No longer
	preserve OBJFILE across smash_type calls.
	(make_pointer_type, make_reference_type, make_function_type,
	lookup_memberptr_type, lookup_methodptr_type, allocate_stub_method,
	create_range_type, create_array_type, create_set_type, copy_type):
	Use alloc_type_copy when allocating types.
	(check_typedef): Use alloc_type_arch.
	(copy_type_recursive): Likewise.  Preserve type ownership data
	after copying type.
	(recursive_dump_type): Dump type ownership data.
	(alloc_type_instance): Update type ownership check.
	(copy_type, copy_type_recursive): Likewise.

	(arch_type): New function.
	(arch_integer_type): Likewise.
	(arch_character_type): Likewise.
	(arch_boolean_type): Likewise.
	(init_float_type): Remove, replace by ...
	(arch_float_type): ... this.
	(init_complex_type): Remove, replace by ...
	(arch_complex_type): ... this.
	(init_flags_type): Remove, replace by ...
	(arch_flags_type): ... this.
	(append_flags_type_flag): Move down.
	(init_composite_type): Remove, replace by ...
	(arch_composite_type): ... this.
	(append_composite_type_field_aligned,
	append_composite_type_field): Move down.

	* gdbarch.c (gdbtypes_post_init): Allocate all types
	using per-architecture routines.
	* ada-lang.c (ada_language_arch_info): Likewise.
	* f-lang.c (build_fortran_types): Likewise.
	* jv-lang.c (build_java_types): Likewise.
	* m2-lang.c (build_m2_types): Likewise.
	* scm-lang.c (build_scm_types): Likewise.

	* ada-lang.c (ada_type_of_array): Use alloc_type_copy.
	(packed_array_type): Likewise.
	(ada_template_to_fixed_record_type_1): Likewise.
	(template_to_static_fixed_type): Likewise.
	(to_record_with_fixed_variant_part): Likewise.
	(to_fixed_variant_branch_type): Likewise.
	(to_fixed_array_type): Likewise.
	(to_fixed_range_type): Likewise.
	(empty_record): Use type instead of objfile argument.
	Use alloc_type_copy.
	(to_fixed_variant_branch_type): Update call to empty_record.
	* jv-lang.c (type_from_class): Use alloc_type_arch.

	* arm-tdep.c (arm_ext_type): Allocate per-architecture type.
	* i386-tdep.c (i386_eflags_type, i386_mxcsr_type, i387_ext_type,
	i386_mmx_type, i386_sse_type): Likewise.
	* ia64-tdep.c (ia64_ext_type): Likewise.
	* m32c-tdep.c (make_types): Likewise.
	* m68k-tdep.c (m68k_ps_type, m68881_ext_type): Likewise.
	* rs6000-tdep.c (rs6000_builtin_type_vec64,
	rs6000_builtin_type_vec128): Likewise.
	* sparc-tdep.c (sparc_psr_type, sparc_fsr_type): Likewise.
	* sparc64-tdep.c (sparc64_pstate_type, sparc64_fsr_type,
	sparc64_fprs_type): Likewise.
	* spu-tdep.c (spu_builtin_type_vec128): Likewise.
	* xtensa-tdep.c (xtensa_register_type): Likewise.
	* linux-tdep.c (linux_get_siginfo_type): Likewise.
	* target-descriptions.c (tdesc_gdb_type): Likewise.
	* gnu-v3-abi.c (build_gdb_vtable_type): Likewise.
@
text
@d1317 1
a1317 1
    insert_single_step_breakpoint (npc);
d1320 1
a1320 1
    insert_single_step_breakpoint (nnpc);
@


1.205
log
@	* i386-tdep.h (struct gdbarch_tdep): Add i386_eflags_type and
	i386_mxcsr_type members.
	(i386_eflags_type): Make into function.
	(i386_mxcsr_type): Likewise.
	* i386-tdep.c (i386_eflags_type): Make into function.
	(i386_mxcsr_type): Likewise.
	(i386_register_type): Update uses.
	(i386_init_types): Remove.
	(_initialize_i386_tdep): Do not call it.
	* amd64-tdep.c (amd64_register_type): Update uses.

	* m68k-tdep.h (struct gdbarch_tdep): Add m68k_ps_type member.
	* m68k-tdep.c (m68k_ps_type): Make into function.
	(m68k_register_type): Update use.
	(m68k_init_types): Remove.
	(_initialize_m68k_tdep): Do not call it.

	* sparc-tdep.h (struct gdbarch_tdep): Add sparc_psr_type,
	sparc_fsr_type, sparc64_pstate_type, sparc64_fsr_type, and
	sparc64_fprs_type members.
	* sparc-tdep.c (sparc_psr_type): Make into function.
	(sparc_fsr_type): Likewise.
	(sparc32_register_type): Update uses.
	(sparc_init_types): Remove.
	(_initialize_sparc_tdep): Do not call it.
	* sparc64-tdep.c (sparc64_pstate_type): Make into function.
	(sparc64_fsr_type): Likewise.
	(sparc64_fprs_type): Likewise.
	(sparc64_register_type): Update uses.
	(sparc64_init_types): Remove.
	(_initialize_sparc64_tdep): Likewise.
@
text
@d297 1
a297 1
      type = init_flags_type ("builtin_type_sparc_psr", 4);
d319 1
a319 1
      type = init_flags_type ("builtin_type_sparc_fsr", 4);
@


1.204
log
@	* gdbtypes.h (builtin_type_int0, builtin_type_int8, builtin_type_uint8,
	builtin_type_int16, builtin_type_uint16, builtin_type_int32,
	builtin_type_uint32, builtin_type_int64, builtin_type_uint64,
	builtin_type_int128, builtin_type_uint128): Remove.
	(struct builtin_type): New members builtin_int0, builtin_int8,
	builtin_uint8, builtin_int16, builtin_uint16, builtin_int32,
	builtin_uint32, builtin_int64, builtin_uint64, builtin_int128,
	and builtin_uint128.
	* gdbtypes.c (builtin_type_int0, builtin_type_int8, builtin_type_uint8,
	builtin_type_int16, builtin_type_uint16, builtin_type_int32,
	builtin_type_uint32, builtin_type_int64, builtin_type_uint64,
	builtin_type_int128, builtin_type_uint128): Remove.
	(_initialize_gdbtypes): Do not initialize them.
	(gdbtypes_post_init): Initialize fixed-size integer types.

	* dwarf2expr.c (unsigned_address_type, signed_address_type): Add
	GDBARCH argument.  Return platform-specific type.
	(dwarf2_read_address, execute_stack_op): Update calls.

	* target-descriptions.c (tdesc_gdb_type): Use platform-specific types
	instead of global builtin_int_... variables.
	* mi/mi-main.c (mi_cmd_data_read_memory): Likewise.
	* printcmd.c (do_examine): Likewise.
	* jv-exp.y (parse_number): Likewise.

	* alpha-tdep.c (alpha_register_type, alpha_push_dummy_call,
	alpha_store_return_value): Likewise.
	* amd64-linux-tdep.c (amd64_linux_register_type): Likewise.
	* amd64-tdep.c (amd64_register_type): Likewise.
	* arm-tdep.c (arm_register_type): Likewise.
	* avr-tdep.c (avr_register_type): Likewise.
	* cris-tdep.c (cris_register_type, crisv32_register_type): Likewise.
	* frv-tdep.c (frv_register_type): Likewise.
	* h8300-tdep.c h8300_register_type): Likewise.
	* hppa-tdep.c (hppa64_push_dummy_call, hppa32_register_type,
	hppa64_register_type): Likewise.
	* i386-tdep.c (i386_mmx_type, i386_sse_type): Likewise.
	* iq2000-tdep.c (iq2000_register_type): Likewise.
	* lm32-tdep.c (lm32_register_type, lm32_push_dummy_call): Likewise.
	* m32r-tdep.c (m32r_register_type): Likewise.
	* m68hc11-tdep.c (m68hc11_register_type, m68hc11_pseudo_register_read,
	m68hc11_pseudo_register_write): Likewise.
	* m68k-tdep.c (m68k_register_type): Likewise.
	* m88k-tdep.c (m88k_register_type, m88k_store_arguments): Likewise.
	* mep-tdep.c (mep_register_type): Likewise.
	* mips-tdep.c (mips_register_type, mips_pseudo_register_type,
	mips_print_fp_register): Likewise.
	* moxie-tdep.c (moxie_register_type): Likewise.
	* mt-tdep.c (mt_copro_register_type, mt_register_type): Likewise.
	* rs6000-tdep.c (rs6000_builtin_type_vec64,
	rs6000_builtin_type_vec128): Likewise.
	* score-tdep.c (score_register_type): Likewise.
	* sparc-tdep.c (sparc32_register_type, sparc32_store_arguments):
	Likewise.
	* sparc64-tdep.c (sparc64_register_type, sparc64_store_arguments):
	Likewise.
	* spu-tdep.c (spu_builtin_type_vec128, spu_register_type): Likewise.
	* v850-tdep.c (v850_register_type): Likewise.
	* xstormy16-tdep.c (xstormy16_register_type): Likewise.
	* xtensa-tdep.c (xtensa_register_type): Likewise.

	* mt-tdep.c (struct gdbarch_tdep): New data structure.
	(mt_gdbarch_init): Alloc TDEP structures.
	(mt_register_type): Cache coprocessor type in TDEP instead of
	static global variable.

	* xtensa-tdep.h (struct gdbarch_tdep): Add type_entries member.
	* xtensa-tdep.c (type_entries): Remove.
	(xtensa_register_type): Cache fixed-size types in TDEP instead
	of in global variable.
@
text
@d286 6
d293 10
a302 2
/* Type for %psr.  */
struct type *sparc_psr_type;
d304 2
a305 2
/* Type for %fsr.  */
struct type *sparc_fsr_type;
d307 2
a308 1
/* Construct types for ISA-specific registers.  */
d310 2
a311 2
static void
sparc_init_types (void)
d313 5
a317 1
  struct type *type;
d319 22
a340 26
  type = init_flags_type ("builtin_type_sparc_psr", 4);
  append_flags_type_flag (type, 5, "ET");
  append_flags_type_flag (type, 6, "PS");
  append_flags_type_flag (type, 7, "S");
  append_flags_type_flag (type, 12, "EF");
  append_flags_type_flag (type, 13, "EC");
  sparc_psr_type = type;

  type = init_flags_type ("builtin_type_sparc_fsr", 4);
  append_flags_type_flag (type, 0, "NXA");
  append_flags_type_flag (type, 1, "DZA");
  append_flags_type_flag (type, 2, "UFA");
  append_flags_type_flag (type, 3, "OFA");
  append_flags_type_flag (type, 4, "NVA");
  append_flags_type_flag (type, 5, "NXC");
  append_flags_type_flag (type, 6, "DZC");
  append_flags_type_flag (type, 7, "UFC");
  append_flags_type_flag (type, 8, "OFC");
  append_flags_type_flag (type, 9, "NVC");
  append_flags_type_flag (type, 22, "NS");
  append_flags_type_flag (type, 23, "NXM");
  append_flags_type_flag (type, 24, "DZM");
  append_flags_type_flag (type, 25, "UFM");
  append_flags_type_flag (type, 26, "OFM");
  append_flags_type_flag (type, 27, "NVM");
  sparc_fsr_type = type;
d362 1
a362 1
    return sparc_psr_type;
d365 1
a365 1
    return sparc_fsr_type;
a1757 3

  /* Initialize the SPARC-specific register types.  */
  sparc_init_types();
@


1.203
log
@	* dummy-frame.c (deprecated_pc_in_call_dummy): Add GDBARCH parameter,
	use it instead of current_gdbarch.
	* frame.h (deprecated_pc_in_call_dummy): Add GDBARCH parameter.
	* arm-tdep.c (arm_skip_prologue): Pass architecture to
	deprecated_pc_in_call_dummy.

	* symtab.c (skip_prologue_using_sal): Add GDBARCH parameter.
	Use it instead of current_gdbarch.
	* symtab.h (skip_prologue_using_sal): Add GDBARCH parameter.
	* breakpoint.c (expand_line_sal_maybe): Pass architecture to
	skip_prologue_using_sal.
	* arm-tdep.c (skip_prologue_using_sal): Likewise.
	* lm32-tdep.c (lm32_skip_prologue): Likewise.
	* m32-tdep.c (m32c_skip_prologue): Likewise.
	* mips-tdep.c (mips_skip_prologue): Likewise.
	* moxie-tdep.c (moxie_skip_prologue): Likewise.
	* mt-tdep.c (mt_frame_unwind_cache): Likewise.
	* rs6000-tdep.c (rs6000_skip_prologue): Likewise.
	* frv-tdep.c (frv_analyze_prologue): Add GDBARCH parameter, pass
	it to skip_prologue_using_sal.  Update call sites ...
	(frv_skip_prologue, frv_frame_unwind_cache): ... here.

	* mn10300-tdep.c (struct mn10300_prologue): Add GDBARCH member.
	(check_for_saved): Use it instead of current_gdbarch.
	(mn10300_analyze_prologue): Set it.

	* value.c (using_struct_return): Add GDBARCH parameter.  Use it
	instead of current_gdbarch.
	* value.h (using_struct_return): Add GDBARCH parameter.
	* eval.c (evaluate_subexp_standard): Pass architecture to
	using_struct_return.
	* infcall.c (call_function_by_hand): Likewise.
	* stack.c (return_command): Likewise.
	* sparc-tdep.c (sparc32_push_dummy_code): Likewise.

	* symtab.c (in_prologue): Add GDBARCH parameter.  Use it instead of
	current_gdbarch.
	* symtab.h (in_prologue): Add GDBARCH parameter.
	* infrun.c (handle_inferior_event): Pass architecture to in_prologue.

	* eval.c (evaluate_subexp_standard): Use expression architecture
	instead of current_gdbarch.

	* c-lang.c (evaluate_subexp_c): Use expression architecture and
	language instead of current_gdbarch and current_language.

	* printcmd.c (do_one_display): Use expression architecture instead
	of current_gdbarch.

	* infcmd.c (print_return_value): Use architecture of stop_regcache
	instead of current_gdbarch.
	(print_vector_info, print_float_info): Remove GDBARCH argument,
	use frame architecture instead.
	(vector_info, float_info): Update calls.

	* objc-lang.c (objc_skip_trampoline): Use frame architecture
	instead of current_gdbarch.

	* parse.c (write_dollar_variable): Use parse architecture instead
	of current_gdbarch.

	* source.c (line_info): Use objfile architecture instead of
	current_gdbarch.

	* symtab.c (find_function_start_sal): Use gdbarch instead of
	current_gdbarch.
	(print_msymbol_info): Use objfile architecture instead of
	current_gdbarch.

	* valops.c (value_assign): Use frame architecture instead of
	current_gdbarch.
@
text
@d352 1
a352 1
  return builtin_type_int32;
d409 1
d446 2
a447 1
	    args[i] = value_cast (builtin_type_int32, args[i]);
@


1.202
log
@	Silence a few -Wmissing-prototypes warnings.

	PR build/9877:
        * alpha-linux-tdep.c (alpha_linux_regset_from_core_section): Make
	it static.
        * alpha-osf1-tdep.c (_initialize_alpha_osf1_tdep): Declare.
        * amd64fbsd-tdep.c (amd64fbsd_init_abi): Make it static.
        * amd64nbsd-tdep.c (_initialize_amd64nbsd_ndep): Rename to ...
	(_initialize_amd64nbsd_tdep): ... this.
	* arm-linux-tdep.c (arm_linux_software_single_step): Make it static.
	(_initialize_arm_linux_tdep): Declare.
	* armbsd-tdep.c (armbsd_fpreg_offset): Make it static.
	* armnbsd-tdep.c (_initialize_arm_netbsd_tdep): Declare.
	* armobsd-tdep.c (_initialize_armobsd_tdep): Declare.
	* avr-tdep.c (avr_return_value): Make it static.
	(avr_frame_unwind_cache): Ditto.
	* bsd-uthread.c (bsd_uthread_inferior_created): Ditto.
	(bsd_uthread_solib_loaded): Ditto.
	(bsd_uthread_solib_unloaded): Ditto.
	(bsd_uthread_target): Ditto.
	(_initialize_bsd_uthread): Declare.
	* cris-tdep.c (crisv32_single_step_through_delay): Make it static.
	(cris_frame_unwind_cache): Ditto.
	* frv-tdep.c (frv_return_value): Ditto.
	* h8300-tdep.c (h8300_use_struct_convention): Ditto.
	(h8300h_use_struct_convention): Ditto.
	* hppa-tdep.c (hppa_sign_extend, hppa_low_hppa_sign_extend):
	Ditto.
	* hppa-tdep.h (hppa_low_sign_extend, hppa_sign_extend): Delete
	declarations.
	* hppabsd-tdep.c: Include hppabsd-tdep.h.
	(hppabsd_find_global_pointer): Make it static.
	* hppabsd-tdep.h: New.
	* hppanbsd-tdep.c: Include hppabsd-tdep.h.
	(hppabsd_init_abi): Remove declaration.
	(_initialize_hppabsd_tdep): Remove declaration.
	(_initialize_hppanbsd_tdep): Declare.
	* hppaobsd-tdep.c: Include hppabsd-tdep.h.
	(hppabsd_init_abi): Delete declaration.
	(hppaobsd_init_abi): Make it static.
	* i386-nto-tdep.c (_initialize_i386nto_tdep): Declare.
	* i386nbsd-tdep.c (_initialize_i386nbsd_tdep): Declare.
	* ia64-linux-tdep.c (_initialize_ia64_linux_tdep): Declare.
	* ia64-tdep.c (ia64_register_reggroup_p): Make it static.
	* iq2000-tdep.c (_initialize_iq2000_tdep): Declare.
	* m32c-tdep.c (m32c_register_reggroup_p): Make it static.
	(m32c_analyze_prologue, m32c_virtual_frame_pointer): Ditto.
	(_initialize_m32c_tdep): Declare.
	* m32r-rom.c (_initialize_m32r_rom): Declare.
	* m32r-tdep.c (m32r_skip_prologue): Make it static.
	(m32r_return_value): Ditto.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache): Make it static.
	(m68hc11_return_value): Ditto.
	* m68klinux-tdep.c (_initialize_m68k_linux_tdep): Declare.
	* m88k-tdep.c (m88k_frame_cache): Make it static.
	* mep-tdep.c (mep_gdb_print_insn): Ditto.
	(mep_return_value): Ditto.
	(_initialize_mep_tdep): Declare.
	* mips-irix-tdep.c (_initialize_mips_irix_tdep): Declare.
	* mips-linux-tdep.c (supply_64bit_reg): Make it static.
	(mips_linux_syscall_next_pc): Ditto.
	(_initialize_mips_linux_tdep): Declare.
	* mips-tdep.c (mips_single_step_through_delay): Make it static.
	* mipsnbsd-tdep.c (_initialize_mipsnbsd_tdep): Declare.
	* mn10300-linux-tdep.c (_initialize_mn10300_linux_tdep): Declare.
	* mn10300-tdep.c (_initialize_mn10300_tdep): Declare.
	* mt-tdep.c (_initialize_mt_tdep): Declare.
	* nbsd-tdep.c: Include nbsd-tdep.h.
	* nto-tdep.c (find_load_phdr): Make it static.
	(_initialize_nto_tdep): Declare.
	* ppc-linux-tdep.c (ppc_linux_memory_remove_breakpoint): Make it
	static.
	(_initialize_ppc_linux_tdep): Declare.
	* remote-m32r-sdi.c (m32r_can_use_hw_watchpoint)
	(m32r_insert_watchpoint, m32r_remove_watchpoint)
	(m32r_stopped_data_address, m32r_stopped_by_watchpoint): Make
	static.
	* rs6000-aix-tdep.c (_initialize_rs6000_aix_tdep): Declare.
	* rs6000-nat.c: Include xcoffread.h.
	(find_toc_address): Don't extern declare get_toc_offset.  Adjust
	to call xcoff_get_to_offset.
	* rs6000-tdep.c (ppc_vsx_support_p, ppc_displaced_step_fixup)
	(rs6000_skip_main_prologue, rs6000_in_solib_return_trampoline)
	(rs6000_skip_trampoline_code): Make static.
	* s390-tdep.c (s390_regset_from_core_section): Ditto.
	* sh-tdep.c (sh_register_reggroup_p): Ditto.
	* shnbsd-tdep.c (shnbsd_regset_from_core_section): Ditto.
	(_initialize_shnbsd_tdep): Declare.
	* solib-frv.c (displacement_from_map): Make static.
	(_initialize_frv_solib): Declare.
	* solib-irix.c (fetch_lm_info): Make static.
	(_initialize_irix_solib): Declare.
	* solib-som.c: Include solib-som.h.
	(som_solib_select): Line break.
	* sparc-tdep.c (sparc_regset_from_core_section): Make static.
	* sparcnbsd-tdep.c (_initialize_sparnbsd_tdep): Rename to ...
	(_initialize_sparcnbsd_tdep): ... this.
	* spu-tdep.c (spu_software_single_step): Make it static.
	(_initialize_spu_tdep): Declare.
	* vax-tdep.c (vax_frame_cache): Make it static.
	* xcoffread.c: Include xcoffread.h.
	(get_toc_offset): Rename to ...
	(xcoff_get_toc_offset): ... this.
	(_initialize_xcoffread): Declare.
	* xcoffread.h: New.
	* xtensa-linux-tdep.c (_initialize_xtensa_linux_tdep): Declare.
	* xtensa-tdep.c (xtensa_skip_prologue, xtensa_derive_tdep): Make
	static.
	(_initialize_xtensa_tdep): Declare.
@
text
@d391 1
a391 1
  if (using_struct_return (NULL, value_type))
@


1.201
log
@        Updated copyright notices for most files.
@
text
@d1327 1
a1327 1
const struct regset *
@


1.200
log
@	* alpha-tdep.c (alpha_register_type): Use builtin_type (gdbarch)
	instead of builtin_type_ macros.
	* amd64-tdep.c (amd64_register_type): Likewise.
	(amd64_get_longjmp_target): Likewise.
	* arm-tdep.c (arm_register_type): Likewise.
	* avr-tdep.c (avr_register_type): Likewise.
	* cris-tdep.c (cris_register_type, crisv32_register_type): Likewise.
	* frv-tdep.c (frv_register_type): Likewise.
	* h8300-tdep.c (h8300_register_type): Likewise.
	* hppa-tdep.c (hppa32_convert_from_func_ptr_addr,
	hppa_skip_trampoline_code): Likewise.
	* i386-tdep.c (i386_register_type): Likewise.
	(i386_unwind_pc, i386_sse_type): Likewise.
	* ia64-tdep.c (ia64_register_type): Likewise.
	* m32r-tdep.c (m32r_register_type): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_unwind_pc): Likewise.
	* m88k-tdep.c (m88k_register_type): Likewise.
	* mep-tdep.c (mep_register_type): Likewise.
	* mips-tdep.c (mips_pseudo_register_type): Likewise.
	* mn10300-tdep.c (mn10300_register_type): Likewise.
	* mt-tdep.c (mt_copro_register_type): Likewise.
	* rs6000-tdep.c (rs6000_builtin_type_vec64): Likewise.
	(rs6000_convert_register_p, rs6000_register_to_value,
	rs6000_value_to_register): Likewise.
	* s390-tdep.c (s390_register_type): Likewise.
	* sh64-tdep.c (sh64_register_type): Likewise.
	(sh64_build_float_register_type, sh64_do_fp_register): Likewise.
	* sh-tdep.c (sh_sh2a_register_type, sh_sh3e_register_type,
	sh_sh4_build_float_register_type, sh_sh4_register_type,
	sh_default_register_type): Likewise.
	* sparc64-tdep.c (sparc64_register_type): Likewise.
	* sparc-tdep.c (sparc32_register_type): Likewise.
	* spu-tdep.c (spu_builtin_type_vec128, spu_register_type): Likewise.
	* v850-tdep.c (v850_register_type): Likewise.
	* vax-tdep.c (vax_register_type): Likewise.
	* xtensa-tdep.c (xtensa_register_type, xtensa_unwind_pc,
	xtensa_push_dummy_call): Likewise.

	* std-regs.c (value_of_builtin_frame_fp_reg,
	value_of_builtin_frame_pc_reg): Likewise.
	* target-descriptions.c (tdesc_register_type): Likewise.
@
text
@d3 1
a3 1
   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008
@


1.199
log
@* sparc-tdep.c: Make some comments catch up with reality.
@
text
@d335 1
a335 1
    return builtin_type_float;
d338 1
a338 1
    return builtin_type_double;
d341 1
a341 1
    return builtin_type_void_data_ptr;
d344 1
a344 1
    return builtin_type_void_func_ptr;
@


1.198
log
@        * sparc-tdep.c, sparc-tdep.h, sparc-sol2-tdep.c, sparc64-tdep.c,
        sparc64-sol2-tdep.c: Update for unwinder changes.
@
text
@d1031 2
a1032 2
/* Extract from an array REGBUF containing the (raw) register state, a
   function return value of TYPE, and copy that into VALBUF.  */
d1073 2
a1074 2
/* Write into the appropriate registers a function return value stored
   in VALBUF of type TYPE.  */
@


1.197
log
@	* dwarf2-frame.c (read_reg): Expect this_frame in the baton.
	(execute_stack_op): Put this_frame in the baton.
	(execute_cfa_program): Take this_frame.
	(struct dwarf2_frame_ops): Update comment for signal_frame_p.
	(dwarf2_frame_default_init_reg, dwarf2_frame_init_reg)
	(dwarf2_frame_signal_frame_p, dwarf2_frame_cache)
	(dwarf2_frame_this_id): Adjust to work on this_frame.
	(dwarf2_signal_frame_this_id): Delete.
	(dwarf2_frame_prev_register): Update signature.  Use new frame
	unwind methods.
	(dwarf2_frame_sniffer): Update signature.  Expect this_frame.
	(dwarf2_frame_unwind, dwarf2_signal_frame_unwind): Add
	dwarf2_frame_sniffer.
	(dwarf2_append_unwinders): New.
	(dwarf2_frame_base_address, dwarf2_frame_base_sniffer): Expect
	this_frame.
	* sparc-tdep.c (sparc32_dwarf2_struct_return_p)
	(sparc32_dwarf2_frame_init_reg): Expect this_frame.
	* cris-tdep.c (cris_dwarf2_frame_init_reg): Likewise.
	* rs6000-tdep.c (ppc_dwarf2_frame_init_reg): Likewise.
	* s390-tdep.c (s390_dwarf2_frame_init_reg): Likewise.
	* sh-tdep.c (sh_dwarf2_frame_init_reg): Likewise.
	* sparc64-tdep.c (sparc64_dwarf2_frame_init_reg): Likewise.
	* dwarf2-frame.h (dwarf2_frame_sniffer): Delete declaration.
	(dwarf2_append_unwinders): Declare.
	(dwarf2_frame_base_sniffer): Update declaration.
	* i386-linux-tdep.c (i386_linux_dwarf_signal_frame_p): Expect
	this_frame.
@
text
@d771 1
a771 1
sparc_unwind_pc (struct gdbarch *gdbarch, struct frame_info *next_frame)
d774 1
a774 1
  return frame_unwind_register_unsigned (next_frame, tdep->pc_regnum);
d833 1
a833 1
sparc_frame_cache (struct frame_info *next_frame, void **this_cache)
d843 1
a843 1
  cache->pc = frame_func_unwind (next_frame, NORMAL_FRAME);
d845 2
a846 2
    sparc_analyze_prologue (get_frame_arch (next_frame), cache->pc,
			    frame_pc_unwind (next_frame), cache);
d854 1
a854 1
	frame_unwind_register_unsigned (next_frame, SPARC_SP_REGNUM);
d861 1
a861 1
	frame_unwind_register_unsigned (next_frame, SPARC_FP_REGNUM);
d888 1
a888 1
sparc32_frame_cache (struct frame_info *next_frame, void **this_cache)
d896 1
a896 1
  cache = sparc_frame_cache (next_frame, this_cache);
d914 1
a914 1
      pc = frame_unwind_register_unsigned (next_frame, regnum) + 8;
d923 1
a923 1
sparc32_frame_this_id (struct frame_info *next_frame, void **this_cache,
d927 1
a927 1
    sparc32_frame_cache (next_frame, this_cache);
d936 3
a938 5
static void
sparc32_frame_prev_register (struct frame_info *next_frame, void **this_cache,
			     int regnum, int *optimizedp,
			     enum lval_type *lvalp, CORE_ADDR *addrp,
			     int *realnump, gdb_byte *valuep)
d941 1
a941 1
    sparc32_frame_cache (next_frame, this_cache);
d945 11
a955 19
      *optimizedp = 0;
      *lvalp = not_lval;
      *addrp = 0;
      *realnump = -1;
      if (valuep)
	{
	  CORE_ADDR pc = (regnum == SPARC32_NPC_REGNUM) ? 4 : 0;

	  /* If this functions has a Structure, Union or
             Quad-Precision return value, we have to skip the UNIMP
             instruction that encodes the size of the structure.  */
	  if (cache->struct_return_p)
	    pc += 4;

	  regnum = cache->frameless_p ? SPARC_O7_REGNUM : SPARC_I7_REGNUM;
	  pc += frame_unwind_register_unsigned (next_frame, regnum) + 8;
	  store_unsigned_integer (valuep, 4, pc);
	}
      return;
d964 6
a969 14
	*optimizedp = 0;
	*lvalp = not_lval;
	*addrp = 0;
	*realnump = -1;
	if (valuep)
	  {
	    CORE_ADDR addr = cache->base + (regnum - SPARC_L0_REGNUM) * 4;
	    ULONGEST i7;

	    /* Read the value in from memory.  */
	    i7 = get_frame_memory_unsigned (next_frame, addr, 4);
	    store_unsigned_integer (valuep, 4, i7 ^ wcookie);
	  }
	return;
d978 1
a978 7
      *optimizedp = 0;
      *lvalp = lval_memory;
      *addrp = cache->base + (regnum - SPARC_L0_REGNUM) * 4;
      *realnump = -1;
      if (valuep)
	{
	  struct gdbarch *gdbarch = get_frame_arch (next_frame);
d980 1
a980 4
	  /* Read the value in from memory.  */
	  read_memory (*addrp, valuep, register_size (gdbarch, regnum));
	}
      return;
d983 1
a983 1
  /* The previous frame's `out' registers are accessable as the
d989 1
a989 6
  *optimizedp = 0;
  *lvalp = lval_register;
  *addrp = 0;
  *realnump = regnum;
  if (valuep)
    frame_unwind_register (next_frame, (*realnump), valuep);
d996 3
a998 1
  sparc32_frame_prev_register
a999 6

static const struct frame_unwind *
sparc32_frame_sniffer (struct frame_info *next_frame)
{
  return &sparc32_frame_unwind;
}
d1003 1
a1003 1
sparc32_frame_base_address (struct frame_info *next_frame, void **this_cache)
d1006 1
a1006 1
    sparc32_frame_cache (next_frame, this_cache);
d1020 1
a1020 1
sparc_unwind_dummy_id (struct gdbarch *gdbarch, struct frame_info *next_frame)
d1024 1
a1024 1
  sp = frame_unwind_register_unsigned (next_frame, SPARC_SP_REGNUM);
d1027 1
a1027 1
  return frame_id_build (sp, frame_pc_unwind (next_frame));
d1160 1
a1160 1
  CORE_ADDR pc = get_frame_address_in_block (this_frame, NORMAL_FRAME);
d1405 1
a1405 1
  set_gdbarch_unwind_dummy_id (gdbarch, sparc_unwind_dummy_id);
d1419 1
a1419 1
  frame_unwind_append_sniffer (gdbarch, sparc32_frame_sniffer);
@


1.196
log
@        * gdbarch.sh: Document the return_value method. Explain that
        the FUNCTYPE parameter might be NULL.
        * gdbarch.h: Regenerated.
        * sparc-tdep.c (sparc32_push_dummy_code): Do not pass the function
        type when calling using_struct_return, as this is unnecessary
        on this target.
@
text
@d1194 1
a1194 1
sparc32_dwarf2_struct_return_p (struct frame_info *next_frame)
d1196 1
a1196 1
  CORE_ADDR pc = frame_unwind_address_in_block (next_frame, NORMAL_FRAME);
d1207 1
a1207 1
			       struct frame_info *next_frame)
d1226 1
a1226 1
      if (sparc32_dwarf2_struct_return_p (next_frame))
@


1.195
log
@doc/ChangeLog:
--------------

	* gdb.texinfo (Set SH Calling convention): New @@item.
	(Show SH Calling convention): Ditto.

ChangeLog:
----------

	* NEWS: Add information on calling convention and new SH CLI options.

	* sh-tdep.c (sh_cc_gcc): New static string.
	(sh_cc_renesas): Ditto.
	(sh_cc_enum): New static string array.
	(sh_active_calling_convention): New static string pointer denoting
	active user chosen ABI.
	(sh_is_renesas_calling_convention): New function to return function
	specific ABI, or user choice if necessary.
	(sh_use_struct_convention): Rename first argument and turn around its
	meaning.  Check for renesas ABI and return accordingly.
	(sh_use_struct_convention_nofpu): New function.
	(sh_next_flt_argreg): Get function type as third parameter.  Check
	for renesas ABI and choose floating registers accordingly.
	(sh_push_dummy_call_fpu): Check for ABI and choose argument slot and
	struct return slot accordingly.
	(sh_push_dummy_call_nofpu): Ditto.
	(sh_return_value_nofpu): Call sh_use_struct_convention_nofpu from here.
	Evaluate ABI and give to sh_use_struct_convention_nofpu.
	(sh_return_value_fpu):  Evaluate ABI and give to
	sh_use_struct_convention.
	(show_sh_command): New function.
	(set_sh_command): Ditto.
	(_initialize_sh_tdep): Initialize `set/show sh calling-convention
	CLI command.

	* gdbarch.sh (return_value): Add func_type argument.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Ditto.
	* eval.c (evaluate_subexp_standard): Rename local variable value_type to
	val_type so as not to collide with value_type function.  Call
	using_struct_return with additional function type argument.
	* infcall.c (call_function_by_hand): Call using_struct_return and
	gdbarch_return_value with additional function type argument.
	* infcmd.c (print_return_value): Take addition func_type argument.
	Call gdbarch_return_value with additional function type argument.
	(finish_command_continuation): Call print_return_value with additional
	function type argument.
	(finish_command): Ditto.
	* sparc-tdep.c (sparc32_push_dummy_code): Call using_struct_return with
	additional function type argument.
	* stack.c (return_command): Call using_struct_return and
	gdbarch_return_value with additional function type argument.
	* value.c (using_struct_return): Take additional function type argument.
	* value.h (using_struct_return): Accommodate declaration.
	* alpha-tdep.c (alpha_return_value): Add func_type argument.
	* amd64-tdep.c (amd64_return_value): Ditto.
	* arm-tdep.c (arm_return_value): Ditto.
	* avr-tdep.c (avr_return_value): Ditto.
	* cris-tdep.c (cris_return_value): Ditto.
	* frv-tdep.c (frv_return_value): Ditto.
	* h8300-tdep.c (h8300_return_value): Ditto.
	(h8300h_return_value): Ditto.
	* hppa-tdep.c (hppa32_return_value): Ditto.
	(hppa64_return_value): Ditto.
	* i386-tdep.c (i386_return_value): Ditto.
	* ia64-tdep.c (ia64_return_value): Ditto.
	* iq2000-tdep.c (iq2000_return_value): Ditto.
	* m32c-tdep.c (m32c_return_value): Ditto.
	* m32r-tdep.c (m32r_return_value): Ditto.
	* m68hc11-tdep.c (m68hc11_return_value): Ditto.
	* m68k-tdep.c (m68k_return_value): Ditto.
	(m68k_svr4_return_value): Ditto.
	* m88k-tdep.c  (m88k_return_value): Ditto.
	* mep-tdep.c (mep_return_value): Ditto.
	* mips-tdep.c (mips_eabi_return_value): Ditto.
	(mips_n32n64_return_value): Ditto.
	(mips_o32_return_value): Ditto.
	(mips_o64_return_value): Ditto.
	* mn10300-tdep.c (mn10300_return_value): Ditto.
	* mt-tdep.c (mt_return_value): Ditto.
	* ppc-linux-tdep.c (ppc_linux_return_value): Ditto.
	* ppc-sysv-tdep.c (ppc_sysv_abi_return_value): Ditto.
	(ppc_sysv_abi_broken_return_value): Ditto.
	(ppc64_sysv_abi_return_value): Ditto.
	* ppc-tdep.h (ppc_sysv_abi_return_value): Ditto.
	(ppc_sysv_abi_broken_return_value): Ditto.
	(ppc64_sysv_abi_return_value): Ditto.
	* ppcnbsd-tdep.c (ppcnbsd_return_value): Ditto.
	* rs6000-tdep.c (rs6000_return_value): Ditto.
	* s390-tdep.c (s390_return_value): Ditto.
	* score-tdep.c (score_return_value): Ditto.
	* sh-tdep.c (sh_return_value_nofpu): Ditto.
	(sh_return_value_fpu): Ditto.
	* sh64-tdep.c (sh64_return_value): Ditto.
	* sparc-tdep.c (sparc32_return_value): Ditto.
	* sparc64-tdep.c (sparc64_return_value): Ditto.
	* spu-tdep.c (spu_return_value): Ditto.
	* v850-tdep.c (v850_return_value): Ditto.
	* vax-tdep.c (vax_return_value): Ditto.
	* xstormy16-tdep.c (xstormy16_return_value): Ditto.
	* xtensa-tdep.c (xtensa_return_value): Ditto.

	* gdbtypes.h (struct type): Add calling_convention member.
	* dwarf2read.c (read_subroutine_type): Add calling convention read
	from DW_AT_calling_convention attribute to function type.
@
text
@d391 1
a391 2
  if (using_struct_return (SYMBOL_TYPE (find_pc_function (funcaddr)),
			   value_type))
@


1.194
log
@	* breakpoint.h (breakpoint_restore_shadows): New
	declaration.
	* breakpoint.c (breakpoint_restore_shadows): New.
	(read_memory_nobpt): Delete.
	* gdbcore.h (read_memory_nobpt): Delete declaration.
	* target.c (memory_xfer_partial): Call
	breakpoint_restore_shadows.
	(restore_show_memory_breakpoints)
	(make_show_memory_beakpoints_cleanup): New.
	(show_memory_breakpoints): New.
	* target.h (make_show_memory_beakpoints_cleanup): Declare.
	* ppc-linux-tdep.c (ppc_linux_memory_remove_breakpoint):
	Make sure we see memory breakpoints when checking if
	breakpoint is still there.
	* alpha-tdep.c, alphanbsd-tdep.c, frame.c, frv-tdep.c,
	hppa-linux-tdep.c, hppa-tdep.c, i386-linux-nat.c, i386-tdep.c,
	m68klinux-tdep.c, mips-tdep.c, mn10300-tdep.c, s390-tdep.c,
	sparc-tdep.c: Use target_read_memory instead of read_memory_nobpt.
@
text
@d391 2
a392 1
  if (using_struct_return (value_type))
d1152 3
a1154 3
sparc32_return_value (struct gdbarch *gdbarch, struct type *type,
		      struct regcache *regcache, gdb_byte *readbuf,
		      const gdb_byte *writebuf)
@


1.193
log
@	* alpha-tdep.c (alpha_heuristic_proc_start)
	(alpha_sigtramp_register_address): Add gdbarch as parameter. Replace
	current_gdbarch by gdbarch.

	(alpha_heuristic_frame_unwind_cache): Use get_frame_arch to get at the
	current architecture by frame_info. Update alpha_heuristic_proc_start
	call.

	(alpha_sigtramp_frame_this_id, alpha_sigtramp_frame_prev_register): Use
	get_frame_arch to get at the current architecture by frame_info. Update
	alpha_sigtramp_register_address call.

	* arm-tdep.c (thumb_scan_prologue): Add gdbarch as parameter and replace
	current_gdbarch by gdbarch. Update caller.
	(convert_to_extended, convert_from_extended): Add endianess parameter
	for comparison. Update caller.
	(arm_extract_return_value, arm_store_return_value): Use
	get_regcache_arch to get at the current	architecture.

	* cris-tdep.c (cris_register_size): Add gdbarch as parameter. Replace
	current_gdbarch by gdbarch. Update caller.
	(cris_gdb_func, move_to_preg_op, none_reg_mode_move_from_preg_op): Add
	gdbarch as parameter. Update caller. Replace current_gdbarch by gdbarch.

	* h8300-tdep.c (E_PSEUDO_CCR_REGNUM, E_PSEUDO_EXR_REGNUM, BINWORD): Add
	gdbarch	as parameter. Update caller.
	(h8300_init_frame_cache): Add gdbarch as parameter. Replace
	current_gdbarch by gdbarch. Update caller.

	* hppa-tdep.c (skip_prologue_hard_way): Add gdbarch as parameter and
	update caller. Replace current_gdbarch by gdbarch.

	* m32c-tdep.c (m32c_skip_trampoline_code): Use get_frame_arch to get at
	the current architecture. Replace current_gdbarch by gdbarch.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache): Likewise.
	(STACK_CORRECTION, USE_PAGE_REGISTER): Replace M6811_TDEP by its
	expression. Add gdbarch as parameter and replace current_gdbarch with
	it. Update caller.
	(M6811_TDEP): Remove.
	(m68hc11_frame_prev_register): Use get_frame_arch to get at the current
	architecture.
	(m68hc11_scan_prologue): Add gdbarch as parameter. Replace
	current_gdbarch by gdbarch. Update caller.

	* m68k-tdep.c (m68k_analyze_prologue): Add gdbarch as parameter and
	update caller.
	(m68k_analyze_register_saves): Likewise. Also replace current_gdbarch
	by gdbarch.

	* rs6000-tdep.c (skip_prologue): Add gdbarch as parameter and update
	caller. Relace current_gdbarch by gdbarch.
	(altivec_register_p, spe_register_p): Likewise.
	* ppc-tdep.h (altivec_register_p, spe_register_p): Add gdbarch as
	parameter.
	* ppc-linux-nat.c (fetch_register, store_register): Update caller of
	altivec_register_p and spe_register_p.

	* score-tdep.c (score_fetch_inst): Add gdbarch as parameter. Update
	caller. Replace current_gdbarch by gdbarch.
	(score_analyze_prologue): use get_frame_arch to get at the current
	architecture.

	* sparc-tdep.h (sparc_analyze_prologue): Add gdbarch as parameter.
	* sparc-tdep.c (sparc_analyze_prologue): Likewise. Replace
	current_gdbarch by gdbarch. Update caller.
	(sparc_frame_cache): Use get_frame_arch to get at the current
	architecture.
	* sparce64-tdep.c (sparc64_skip_prologue): Update call of
	sparc_analyze_prologue.

	* mn10300-tdep.c (mn10300_dwarf2_reg_to_regnum): Add gdbarch as
	parameter.
@
text
@d102 1
a102 1
  if (read_memory_nobpt (pc, buf, sizeof (buf)))
@


1.192
log
@
	* gdbarch.sh (skip_prologue): Add gdbarch
	as parameter.
	* gdbarch.{c,h}: Regenerate.

	* alpha-tdep.c (alpha_skip_prologue): Add gdbarch as parameter.
	* amd64-tdep.c (amd64_skip_prologue): Likewise.
	* avr-tdep.c (avr_skip_prologue): Likewise.
	* cris-tdep.c (cris_skip_prologue): Likewise.
	* frv-tdep.c (frv_skip_prologue): Likewise.
	* h8300-tdep.c (h8300_skip_prologue): Likewise.
	* hppa-tdep.c (hppa_skip_prologue): Likewise.
	* i386-tdep.c (i386_skip_prologue): Likewise.
	* ia64-tdep.c (ia64_skip_prologue): Likewise.
	* iq2000-tdep.c (iq2000_skip_prologue): Likewise.
	* m32r-tdep.c (m32r_skip_prologue): Likewise.
	* m68hc11-tdep.c (m68hc11_skip_prologue): Likewise.
	* m68k-tdep.c (m68k_skip_prologue): Likewise.
	* m88k-tdep.c (m88k_skip_prologue): Likewise.
	* mep-tdep.c (mep_skip_prologue): Likewise.
	* mips-tdep.c (mips_skip_prologue): Likewise.
	* mn10300-tdep.c (mn10300_skip_prologue): Likewise.
	* mt-tdep.c (mt_skip_prologue): Likewise.
	* rs6000-tdep.c (rs6000_skip_prologue): Likewise.
	* score-tdep.c (score_skip_prologue): Likewise.
	* sh64-tdep.c (sh64_skip_prologue): Likewise.
	* sh-tdep.c (sh_skip_prologue): Likewise.
	* sparc64-tdep.c (sparc64_skip_prologue): Likewise.
	* sparc-tdep.c (sparc32_skip_prologue): Likewise.
	* spu-tdep.c (spu_skip_prologue): Likewise.
	* v850-tdep.c (v850_skip_prologue): Likewise.
	* vax-tdep.c (vax_skip_prologue): Likewise.
	* xstormy16-tdep.c (xstormy16_skip_prologue): Likewise.
	* xtensa-tdep.c (xtensa_skip_prologue): Likewise.

	* arm-tdep.c (arm_skip_prologue): Add gdbarch as parameter. Replace
	current_gdbarch by gdbarch.
	* m32c-tdep.c (m32c_skip_prologue): Likewise.
	* s390-tdep.c (s390_skip_prologue): Likewise.
@
text
@d714 2
a715 2
sparc_analyze_prologue (CORE_ADDR pc, CORE_ADDR current_pc,
			struct sparc_frame_cache *cache)
d717 1
a717 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d798 1
a798 1
  start_pc = sparc_analyze_prologue (start_pc, 0xffffffffUL, &cache);
d845 2
a846 1
    sparc_analyze_prologue (cache->pc, frame_pc_unwind (next_frame), cache);
@


1.191
log
@	Updated copyright notices for most files.
@
text
@d781 1
a781 1
sparc32_skip_prologue (CORE_ADDR start_pc)
@


1.190
log
@*** empty log message ***
@
text
@d3 2
a4 1
   Copyright (C) 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.
@


1.189
log
@2007-11-02  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (register_name): Add gdbarch parameter.
	* gdbarch.{c,h}: Regenerate.

	* target-descriptions.c (tdesc_register_name): Add gdbarch parameter.
	(tdesc_register_name): Replace current_gdbarch by gdbarch.
	* target-descriptions.h (tdesc_register_name): Add gdbarch parameter.

	* xstormy16-tdep.c (xstormy16_register_name): Add gdbarch parameter.
	* vax-tdep.c (vax_register_name): Add gdbarch parameter.
	* spu-tdep.c (spu_register_name): Add gdbarch parameter.
	* s390-tdep.c (s390_register_name): Add gdbarch parameter.
	* mt-tdep.c (mt_register_name): Add gdbarch parameter.
	(mt_registers_info): Replace current_gdbarch by gdbarch.
	(mt_register_reggroup_p): Add gdbarch to mt_register_name call.
	* mips-tdep.c (mips_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(mips_register_name): Add gdbarch to tdesc_register_name call.
	* mep-tdep.c (mep_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(mep_register_reggroup_p): Add gdbarch to mep_register_name call.
	* m32c-tdep.c (m32c_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	* m88k-tdep.c (m88k_register_name): Add gdbarch parameter.
	* m68k-tdep.c (m68k_register_name): Add gdbarch parameter.
	* m32r-tdep.c (m32r_register_name): Add gdbarch parameter.
	(m32r_frame_unwind_cache): Use get_frame_arch to get at the current
	architecture by frame_info.
	* iq2000-tdep.c (iq2000_register_name): Add gdbarch parameter.
	* ia64-tdep.c (ia64_register_name): Add gdbarch parameter.
	* hppa-tdep.c (hppa32_register_name, hppa64_register_name): Add gdbarch
	parameter.
	* h8300-tdep.c (h8300_register_name, h8300s_register_name)
	(h8300sx_register_name): Add gdbarch parameter.
	* cris-tdep.c (cris_register_name, crisv32_register_name): Add
	gdbarch parameter. Replace current_gdbarch by gdbarch.
	(cris_gdbarch_init): Replace current_gdbarch by gdbarch (comment).
	* avr-tdep.c (avr_register_name): Add gdbarch parameter.
	* arm-tdep.c (arm_register_name): Add gdbarch paramete
	* amd64-tdep.c (amd64_register_name): Add gdbarch parameter. Update
	caller.
	* amd64-tdep.h (amd64_register_name): Add gdbarch parameter.
	* amd64-linux-tdep.c (amd64_linux_register_name): Add gdbarch parameter.
	* alpha-tdep.c (alpha_register_name): Add gdbarch parameter.
	(alpha_cannot_fetch_register, alpha_cannot_store_register): Update call
	of alpha_register_name.
	* frv-tdep.c (frv_register_name): Add gdbarch parameter.
	* i386-tdep.c (i386_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(i386_register_type): Replace ?current_gdbarch by gdbarch.
	* i386-tdep.h (i386_register_name): Add gdbarch parameter.
	* i386-linux-tdep.c (i386_linux_register_name): Add gdbarch parameter.

	* m68hc11-tdep.c (m68hc11_register_name): Add gdbarch parameter.
	(m68hc11_register_reggroup_p): Add gdbarch to call of
	m68hc11_register_name.
	* mn10300-tdep.c (mn10300_generic_register_name, am33_register_name)
	(am33_2_register_name): Add gdbarch parameter.
	(mn10300_frame_unwind_cache): Use get_frame_arch to get at the current
	architecture by frame_info.
	(mn10300_dump_tdep): Replace current_gdbarch by gdbarch.
	* rs6000-tdep.c (rs6000_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	* score-tdep.c (score_register_name): Add gdbarch parameter.
	(score_return_value, score_push_dummy_call): Replace current_gdbarch
	by gdbarch.
	* sh64-tdep.c (sh64_register_name): Add gdbarch parameter.
	(sh64_compact_reg_base_num, sh64_register_convert_to_virtual)
	(sh64_register_convert_to_raw, sh64_fv_reg_base_num)
	(sh64_dr_reg_base_num, sh64_fpp_reg_base_num): Add gdbarch parameter
	and update caller. Replace current_gdbarch by gdbarch.
	(sh64_extract_return_value, sh64_store_return_value): Use
	get_regcache_arch to get at the current architecture by regcache.
	* sh-tdep.c (sh_sh_register_name, sh_sh3_register_name)
	(sh_sh3e_register_name, sh_sh2e_register_name, sh_sh2a_register_name)
	(sh_sh2a_nofpu_register_name, sh_sh_dsp_register_name)
	(sh_sh3_dsp_register_name, sh_sh4_register_name)
	(sh_sh4_nofpu_register_name, sh_sh4al_dsp_register_name): Add gdbarch
	parameter.
	(fv_reg_base_num, dr_reg_base_num, sh_justify_value_in_reg)
	(sh_next_flt_argreg): Add gdbarch parameter and update caller. Replace
	current_gdbarch by gdbarch.
	(sh_extract_return_value_fpu, sh_store_return_value_fpu): Use
	get_regcache_arch to get at the current architecture by regcache.
	* sparc-tdep.c (sparc32_register_name): Add gdbarch parameter.
	* sparc64-tdep.c (sparc64_register_name): Add gdbarch parameter.
	* v850-tdep.c (v850_register_name, v850e_register_name): Add gdbarch
	parameter.
	(v850_unwind_sp, v850_unwind_pc): Replace current_gdbarch by gdbarch.
	* xtensa-tdep.c (xtensa_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(xtensa_pseudo_register_read, xtensa_pseudo_register_write)
	(xtensa_frame_prev_register): Add gdbarch parameter to
	xtensa_register_name call.
@
text
@d531 1
a531 1
sparc_breakpoint_from_pc (CORE_ADDR *pc, int *len)
@


1.188
log
@	* gdbarch.sh (static_transform_name): New gdbarch callback.
	* gdbarch.c, gdbarch.h: Regenerate.
	* dbxread.c (read_dbx_symtab): Use gdbarch_static_transform_name
	instead of STATIC_TRANSFORM_NAME.
	* mdebugread.c (parse_partial_symbols): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* xcoffread.c (scan_xcoff_symtab): Likewise.

	* config/i368/tm-i386sol2.h (STATIC_TRANSFORM_NAME): Remove.
	(IS_STATIC_TRANSFORM_NAME): Remove.
	* i386-tdep.c (sunpro_static_transform_name): Remove, move to ...
	* i386-sol2-tdep.c (i386_sol2_static_transform_name): ... here.
	(i386_sol2_init_abi): Install it.

	* config/sparc/tm-sol2.h (STATIC_TRANSFORM_NAME): Remove.
	(IS_STATIC_TRANSFORM_NAME): Remove.
	* sparc-tdep.c (sparc_stabs_unglobalize_name): Remove, move to ...
	* sparc-sol2-tdep.c (sparc_sol2_static_transform_name): ... here.
	(sparc32_sol2_init_abi): Install it.
	* sparc64-sol2-tdep.c (sparc64_sol2_init_abi): Likewise.
	* sparc-tdep.h (sparc_sol2_static_transform_name): Add prototype.
@
text
@d274 1
a274 1
sparc32_register_name (int regnum)
@


1.187
log
@	* block.h (struct block): Remove "gcc_compile_flag" member.
	(BLOCK_GCC_COMPILED): Remove.
	* block.c (allocate_block): Do not clear BLOCK_GCC_COMPILED.
	* buildsym.c (finish_block): Do not set it.
	* symmisc.c (dump_symtab_1): Do not dump it.

	* value.h (using_struct_return): Remove "gcc_p" argument.
	* value.c (using_struct_return): Likewise.
	* eval.c (evaluate_subexp_standard): Adapt callers.
	* infcall.c (call_function_by_hand): Likewise.
	* stack.c (return_command): Likewise.
	* sparc-tdep.c (sparc32_push_dummy_code): Likewise.

	* gdbarch.sh (push_dummy_code): Remove "using_gcc" parameter.
	* gdbarch.c, gdbarch.h: Regenerate.
	* cris-tdep.c (cris_push_dummy_code): Adapt prototype.
	* hppa-hpux-tdep.c (hppa_hpux_push_dummy_code): Likewise.
	* sparc-tdep.c (sparc32_push_dummy_code): Likewise.
	* infcall.c (generic_push_dummy_code, push_dummy_code): Likewise.
	(push_dummy_code, call_function_by_hand): Adapt callers.
@
text
@a1356 31
/* Unglobalize NAME.  */

char *
sparc_stabs_unglobalize_name (char *name)
{
  /* The Sun compilers (Sun ONE Studio, Forte Developer, Sun WorkShop,
     SunPRO) convert file static variables into global values, a
     process known as globalization.  In order to do this, the
     compiler will create a unique prefix and prepend it to each file
     static variable.  For static variables within a function, this
     globalization prefix is followed by the function name (nested
     static variables within a function are supposed to generate a
     warning message, and are left alone).  The procedure is
     documented in the Stabs Interface Manual, which is distrubuted
     with the compilers, although version 4.0 of the manual seems to
     be incorrect in some places, at least for SPARC.  The
     globalization prefix is encoded into an N_OPT stab, with the form
     "G=<prefix>".  The globalization prefix always seems to start
     with a dollar sign '$'; a dot '.' is used as a seperator.  So we
     simply strip everything up until the last dot.  */

  if (name[0] == '$')
    {
      char *p = strrchr (name, '.');
      if (p)
	return p + 1;
    }

  return name;
}

@


1.186
log
@2007-10-10  Markus Deuling  <deuling@@de.ibm.com>

	* sparc-tdep.c (sparc_supply_rwindow, sparc_collect_rwindow): Use
	get_regcache_arch to get at the current architecture by regcache.

	* sparc64-tdep.c (sparc64_supply_gregset, sparc64_collect_gregset)
	(sparc64_supply_fpregset, sparc64_collect_fpregset): Use
	get_regcache_arch to get at the current architecture by regcache.

	* sparc64nbsd-nat. (sparc64nbsd_supply_gregset)
	(sparc64nbsd_collect_gregset, sparc64nbsd_supply_fpregset)
	(sparc64nbsd_collect_fpregset): Use get_regcache_arch to get at the
	current architecture by regcache.
@
text
@d381 1
a381 1
			 CORE_ADDR funcaddr, int using_gcc,
d390 1
a390 1
  if (using_struct_return (value_type, using_gcc))
@


1.185
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d1535 1
a1535 1
      if (gdbarch_ptr_bit (current_gdbarch) == 64)
d1602 1
a1602 1
      if (gdbarch_ptr_bit (current_gdbarch) == 64)
@


1.184
log
@	* gdbarch.sh (read_pc): Add REGCACHE argument.  Remove PTID argument.
	(write_pc): Likewise.  Remove default implementation, add predicate.
	* gdbarch.c, gdbarch.h: Regenerate.
	* regcache.c (read_pc_pid): Use current regcache instead of calling
	read_register_pid.
	(write_pc_pid): Check gdbarch_write_pc predicate, implement default
	case inline.
	(generic_target_write_pc): Remove.
	* inferior.h (generic_target_write_pc): Remove.
	* frv-tdep.c (frv_gdbarch_init): Do not install it.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Likewise.
	* rs6000-tdep.c (rs6000_gdbarch_init): Likewise.
	* sh64-tdep.c (sh64_gdbarch_init): Likewise.
	* sh-tdep.c (sh_gdbarch_init): Likewise.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Likewise.

	* avr-tdep.c (avr_read_pc): Add REGCACHE argument.  Remove PTID
	argument.  Use REGCACHE instead of calling read_register_pid.
	* hppa-hpux-tdep.c (hppa_hpux_read_pc): Likewise.
	* hppa-tdep.c (hppa_read_pc): Likewise.
	* hppa-tdep.h (hppa_read_pc): Likewise.
	* ia64-tdep.c (ia64_read_pc): Likewise.
	* m32r-tdep.c (m32r_read_pc): Likewise.
	* mep-tdep.c (mep_read_pc): Likewise.
	* mn10300-tdep.c (mn10300_read_pc): Likewise.
	* spu-tdep.c (spu_read_pc): Likewise.

	* arm-tdep.c (arm_write_pc): Add REGCACHE argument.  Remove PTID
	argument.  Use REGCACHE instead of calling write_register_pid.
	* avr-tdep.c (avr_write_pc): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_write_pc): Likewise.
	* hppa-tdep.c (hppa_write_pc): Likewise.
	* hppa-tdep.h (hppa_write_pc): Likewise.
	* i386-linux-tdep.c (i386_linux_write_pc): Likewise.
	* amd64-linux-tdep.c (amd64_linux_write_pc): Likewise.
	* ia64-linux-tdep.c (ia64_linux_write_pc): Likewise.
	* ia64-tdep.c (ia64_write_pc): Likewise.
	* ia64-tdep.h (ia64_write_pc): Likewise.
	* m32r-tdep.c (m32r_write_pc): Likewise.
	* m88k-tdep.c (m88k_write_pc): Likewise.
	* mep-tdep.c (mep_write_pc): Likewise.
	* mips-tdep.c (mips_write_pc): Likewise.
	* mips-linux-tdep.c (mips_linux_write_pc): Likewise.
	* mn10300-tdep.c (mn10300_write_pc): Likewise.
	* sparc-tdep.c (sparc_write_pc): Likewise.
	* spu-tdep.c (spu_write_pc): Likewise.

	* mips-tdep.c (read_signed_register): Remove.
	(read_signed_register_pid): Likewise.
	(mips_read_pc): Add REGCACHE argument.  Remove PTID argument.
	Use REGCACHE instead of calling read_signed_register_pid.
@
text
@d9 1
a9 1
   the Free Software Foundation; either version 2 of the License, or
d18 1
a18 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.183
log
@	* gdbarch.sh (push_dummy_code): Add REGCACHE argument.
	* gdbarch.c, gdbarch.h: Regenerate.
	* infcall.c (generic_push_dummy_code): Add REGCACHE argument.
	(push_dummy_code): Likewise.  Pass it to callee.
	(call_function_by_hand): Pass current regcache to push_dummy_code.

	* hppa-hpux-tdep.c (hppa_hpux_push_dummy_code): Add REGCACHE
	argument.  Use it instead of current_regcache.

	* cris-tdep.c (cris_push_dummy_code): Add REGCACHE argument.
	* sparc-tdep.c (sparc32_push_dummy_code): Likewise.
@
text
@d1351 1
a1351 1
sparc_write_pc (CORE_ADDR pc, ptid_t ptid)
d1353 1
a1353 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d1355 2
a1356 2
  write_register_pid (tdep->pc_regnum, pc, ptid);
  write_register_pid (tdep->npc_regnum, pc + 4, ptid);
@


1.182
log
@	* gdbarch.sh (software_single_step): Replace REGCACHE argument by
	FRAME argument.
	* gdbarch.c, gdbarch.h: Regenerate.
	* infrun.c (resume): Pass current frame to SOFTWARE_SINGLE_STEP.

	* alpha-tdep.c (alpha_next_pc): Add FRAME argument.  Retrieve
	registers from FRAME instead of using read_register.
	(alpha_software_single_step): Replace REGCACHE by FRAME.  Pass FRAME
	to alpha_next_pc.  Use get_frame_pc instead of read_pc.
	* alpha-tdep.h (alpha_software_single_step): Replace REGCACHE
	argument by FRAME.

	* arm-tdep.c (shifted_reg_val): Add FRAME argument.  Read registers
	from FRAME instead of using read_register.
	(thumb_get_next_pc): Likewise.
	(arm_get_next_pc): Likewise.
	(arm_software_single_step): Replace REGCACHE by FRAME.  Pass FRAME
	to arm_get_next_pc.  Use get_frame_pc instead of read_register.
	* arm-tdep.h (arm_software_single_step): Replace REGCACHE
	argument by FRAME.

	* cris-tdep.c (find_step_target): Add FRAME argument.  Read registers
	from FRAME instead of using read_register.
	(cris_software_single_step): Replace REGCACHE by FRAME.  Pass FRAME
	to find_step_target.

	* mips-tdep.c (mips32_next_pc): Add FRAME argument.  Read registers
	from FRAME instead of using read_register / read_signed_register.
	(extended_mips16_next_pc): Likewise.
	(mips16_next_pc): Likewise.
	(mips_next_pc): Likewise.
	(mips_software_single_step): Replace REGCACHE by FRAME.  Pass FRAME
	to mips_next_pc.  Use get_frame_pc instead of read_pc.
	* mips-tdep.h (mips_software_single_step): Replace REGCACHE
	argument by FRAME.

	* rs6000-tdep.c (branch_dest): Add FRAME argument.  Use it instead
	of current frame.  Read registers from FRAME.
	(deal_with_atomic_sequence): Add FRAME argument.  Pass it to
	branch_dest.  Use get_frame_pc instead of read_pc.
	(rs6000_software_single_step): Likewise.
	(bl_to_blrl_insn_p): Do not call branch_dest.
	* rs6000-tdep.h (rs6000_software_single_step): Replace REGCACHE
	argument by FRAME.

	* sparc64-linux-tdep.c (sparc64_linux_step_trap): Add FRAME argument.
	Read registers from FRAME instead of current regcache.
	* sparc-linux-tdep.c (sparc32_linux_step_trap): Likewise.
	* sparcnbsd-tdep.c (sparcnbsd_step_trap): Likewise.
	* sparc-tdep.c (sparc_address_from_register): Remove.
	(sparc_analyze_control_transfer): Pass FRAME argument instead of
	GDBARCH.  Pass FRAME to step_trap callback.
	(sparc_step_trap): Add FRAME argument.
	(space_software_single_step): Replace REGCACHE by FRAME.  Pass FRAME
	to sparc_analyze_control_transfer.  Read registers from FRAME instead
	of calling sparc_address_from_register.
	* sparc-tdep.h (struct gdbarch_tdep): Add FRAME argument to
	step_trap callback.
	(sparc_address_from_register): Remove prototype.
	(sparc_software_single_step): Replace REGCACHE argument by FRAME.
	(sparcnbsd_step_trap): Add FRAME argument.

	* spu-tdep.c (spu_software_single_step): Replace REGCACHE argument
	by FRAME.  Read registers from FRAME instead of REGCACHE.
@
text
@d386 2
a387 1
			 CORE_ADDR *real_pc, CORE_ADDR *bp_addr)
@


1.181
log
@	* gdbarch.sh (software_single_step): Remove "insert_breakpoints_p" and
	"sig" arguments, add "regcache" argument.
	* gdbarch.c, gdbarch.h: Regenerate.

	* infrun.c (resume): Update SOFTWARE_SINGLE_STEP call arguments.
	(handle_inferior_event): Call remove_single_step_breakpoints directly
	instead of calling SOFTWARE_SINGLE_STEP to remove breakpoints.

	* alpha-tdep.c (alpha_software_single_step): Update argument list.
	Remove handling of !insert_breakpoints_p case.
	* arm-tdep.c (arm_software_single_step): Likewise.
	* cris-tdep.c (cris_software_single_step): Likewise.
	* mips-tdep.c (mips_software_single_step): Likewise.
	* rs6000-tdep.c (rs6000_software_single_step): Likewise.
	* sparc-tdep.c (sparc_software_single_step): Likewise.
	* spu-tdep.c (spu_software_single_step): Likewise.

	* alpha-tdep.h (alpha_software_single_step): Update prototype.
	* mips-tdep.h (mips_software_single_step): Likewise.
	* rs6000-tdep.h (rs6000_software_single_step): Likewise.
	* sparc-tdep.h (sparc_software_single_step): Likewise.
@
text
@a172 12
/* Return the contents if register REGNUM as an address.  */

CORE_ADDR
sparc_address_from_register (int regnum)
{
  ULONGEST addr;

  regcache_cooked_read_unsigned (current_regcache, regnum, &addr);
  return addr;
}


d1240 1
a1240 1
sparc_analyze_control_transfer (struct gdbarch *arch,
d1282 1
a1282 1
      return gdbarch_tdep (arch)->step_trap (insn);
d1315 1
a1315 1
sparc_step_trap (unsigned long insn)
d1321 1
a1321 1
sparc_software_single_step (struct regcache *regcache)
d1323 1
a1323 1
  struct gdbarch *arch = current_gdbarch;
d1329 2
a1330 2
  pc = sparc_address_from_register (tdep->pc_regnum);
  orig_npc = npc = sparc_address_from_register (tdep->npc_regnum);
d1333 1
a1333 1
  nnpc = sparc_analyze_control_transfer (arch, pc, &npc);
@


1.180
log
@2007-04-12  Luis Machado  <luisgpm@@br.ibm.com>

	* gdbarch.sh (software_single_step): Change the return type
	from void to int and reformatted some comments to <= 80
	columns.
	* gdbarch.c, gdbarch.h: Regenerated.
	* alpha-tdep.c (alpha_software_single_step): Likewise.
	* alpha-tdep.h (alpha_software_single_step): Likewise.
	* arm-tdep.c (arm_software_single_step): Likewise.
	* cris-tdep.c (cris_software_single_step): Likewise.
	* mips-tdep.c (mips_software_single_step): Likewise.
	* mips-tdep.h (mips_software_single_step): Likewise.
	* rs6000-tdep.c (rs6000_software_single_step): Likewise.
	* rs6000-tdep.h (rs6000_software_single_step): Likewise.
	* sparc-tdep.c (sparc_software_single_step): Likewise.
	* sparc-tdep.h (sparc_software_single_step): Likewise.
	* spu-tdep.c (spu_software_single_step): Likewise.
	* infrun.c (resume): Check the return value from SOFTWARE_SINGLE_STEP
	and act accordingly.
@
text
@d1333 1
a1333 1
sparc_software_single_step (enum target_signal sig, int insert_breakpoints_p)
d1339 1
a1339 3
  if (insert_breakpoints_p)
    {
      CORE_ADDR pc, orig_npc;
d1341 2
a1342 2
      pc = sparc_address_from_register (tdep->pc_regnum);
      orig_npc = npc = sparc_address_from_register (tdep->npc_regnum);
d1344 13
a1356 16
      /* Analyze the instruction at PC.  */
      nnpc = sparc_analyze_control_transfer (arch, pc, &npc);
      if (npc != 0)
	insert_single_step_breakpoint (npc);

      if (nnpc != 0)
	insert_single_step_breakpoint (nnpc);

      /* Assert that we have set at least one breakpoint, and that
	 they're not set at the same spot - unless we're going
	 from here straight to NULL, i.e. a call or jump to 0.  */
      gdb_assert (npc != 0 || nnpc != 0 || orig_npc == 0);
      gdb_assert (nnpc != npc || orig_npc == 0);
    }
  else
    remove_single_step_breakpoints ();
@


1.179
log
@        * sparc-tdep.c (X_RS2): New macro.
        (sparc_skip_stack_check): New function.
        (sparc_analyze_prologue): Adjust PC past stack probing
        sequence if necessary.
@
text
@d1332 1
a1332 1
void
d1362 2
@


1.178
log
@	* dwarf2-frame.c (dwarf2_frame_cache, dwarf2_frame_this_id)
	(dwarf2_frame_sniffer): Update.
	(dwarf2_signal_frame_this_id): New function.
	(dwarf2_signal_frame_unwind): Use it.
	(dwarf2_frame_base_sniffer): Use frame_unwind_address_in_block.
	* frame.c (frame_func_unwind): Add this_type argument.
	(get_frame_func): Update.
	(frame_unwind_address_in_block): Add this_type argument and check it.
	Fix a typo.
	(get_frame_address_in_block): Update.
	* frame.h (enum frame_type): Move higher in the file.
	(frame_unwind_address_in_block, frame_func_unwind): Add enum frame_type
	argument.

	* alpha-mdebug-tdep.c, alpha-tdep.c, amd64-tdep.c, amd64obsd-tdep.c,
	arm-tdep.c, avr-tdep.c, cris-tdep.c, frv-tdep.c, h8300-tdep.c,
	hppa-tdep.c, i386-tdep.c, i386obsd-tdep.c, ia64-tdep.c,
	libunwind-frame.c, m32c-tdep.c, m32r-linux-tdep.c, m32r-tdep.c,
	m68hc11-tdep.c, m68k-tdep.c, m88k-tdep.c, mips-mdebug-tdep.c,
	mips-tdep.c, mn10300-tdep.c, mt-tdep.c, rs6000-tdep.c, s390-tdep.c,
	score-tdep.c, sh-tdep.c, sh64-tdep.c, sparc-tdep.c,
	sparc64obsd-tdep.c, spu-tdep.c, v850-tdep.c, vax-tdep.c,
	xstormy16-tdep.c, xtensa-tdep.c: Update calls to
	frame_func_unwind and frame_unwind_address_in_block to specify
	the frame type.  Use frame_unwind_address_in_block instead of
	frame_pc_unwind in sniffers.

	* gdb.arch/i386-signal.c, gdb.arch/i386-signal.exp: New files.
@
text
@d85 1
d575 150
d734 2
@


1.177
log
@	* doublest.c (floatformat_from_length): Use the right element from
	gdbarch floatformats.
	(floatformat_from_type, extract_typed_floating)
	(store_typed_floating): Likewise.
	* doublest.h: Remove declarations for undefined floatformat arrays.
	* gdbarch.sh (float_format, double_format, long_double_format): Change
	to pairs.
	(pformat): Update for pairs.
	* gdbarch.c, gdbarch.h: Regenerated.
	* gdbtypes.c (floatformats_ieee_single, floatformats_ieee_double)
	(floatformats_ieee_double_littlebyte_bigword)
	(floatformats_i387_ext, floatformats_m68881_ext, floatformats_arm_ext)
	(floatformats_ia64_spill, floatformats_ia64_quad, floatformats_vax_f)
	(floatformats_vax_d): New variables.
	(builtin_type_ieee_single, builtin_type_ieee_double)
	(builtin_type_arm_ext, builtin_type_ia64_spill)
	(builtin_type_ia64_quad): Replace arrays with individual types.
	(builtin_type_ieee_single_big, builtin_type_ieee_single_little)
	(builtin_type_ieee_double_big, builtin_type_ieee_double_little)
	(builtin_type_ieee_double_littlebyte_bigword, builtin_type_i960_ext)
	(builtin_type_m88110_ext, builtin_type_m88110_harris_ext)
	(builtin_type_arm_ext_big, builtin_type_arm_ext_littlebyte_bigword)
	(builtin_type_ia64_spill_big, builtin_type_ia64_spill_little)
	(builtin_type_ia64_quad_big, builtin_type_ia64_quad_little): Delete
	unused and endian-specific types.
	(recursive_dump_type): Update for floatformat pairs.
	(build_flt): Move higher.  Handle bit == -1.  Take a floatformat pair.
	(build_gdbtypes): Use build_flt.
	(_initialize_gdbtypes): Update set of initialized types.
	* gdbtypes.h: Update declarations to match gdbtypes.c.
	(struct main_type): Store a pointer to two floatformats.
	* arch-utils.c (default_float_format, default_double_format): Delete.
	* arch-utils.h (default_float_format, default_double_format): Delete.

	* arm-tdep.c, avr-tdep.c, hppa-tdep.c, hppabsd-tdep.c, i386-tdep.c,
	ia64-tdep.c,  iq2000-tdep.c, m68k-tdep.c, m88k-tdep.c,
	mips-linux-tdep.c, mips-tdep.c, mt-tdep.c, ppcobsd-tdep.c,
	sparc-linux-tdep.c, sparc-tdep.c, sparcnbsd-tdep.c, spu-tdep.c,
	vax-tdep.c, alpha-tdep.c, ppc-sysv-tdep.c: Update.
@
text
@d702 1
a702 1
  cache->pc = frame_func_unwind (next_frame);
d704 1
a704 4
    {
      CORE_ADDR addr_in_block = frame_unwind_address_in_block (next_frame);
      sparc_analyze_prologue (cache->pc, addr_in_block, cache);
    }
d1054 1
a1054 1
  CORE_ADDR pc = frame_unwind_address_in_block (next_frame);
@


1.176
log
@Copyright updates for 2007.
@
text
@d68 1
a68 1
#define floatformat_sparc_quad floatformat_ia64_quad_big
d1299 1
a1299 1
  set_gdbarch_long_double_format (gdbarch, &floatformat_sparc_quad);
@


1.175
log
@* sparc-tdep.c (sparc_psr_type, sparc_fsr_type): New variables.
(sparc_init_types): New function.
(sparc32_register_type): Use appropriate flag types for %fsr and
%prs.
(_initialize_sparc_tdep): Call sparc_init_types.
@
text
@d3 1
a3 1
   Copyright (C) 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
@


1.174
log
@        * sparc-tdep.c (sparc_fetch_instruction): Read instruction
        using read_memory_nobpt.
@
text
@d297 42
d358 6
d1672 3
@


1.173
log
@	* target.c (target_read): Stop if target_read_partial returns 0
	when some bytes have already been read.
	(target_write): Likewise for target_write_partial.
	(target_read_partial, target_write_partial): Make static.
	(target_read_alloc): New.
	* target.h: Doc fixes.
	(target_read_partial, target_write_partial): Delete prototypes.
	(target_read_alloc): New prototype.

	* auxv.c (target_auxv_read): Delete.
	(target_auxv_search, fprint_target_auxv): Use target_read_alloc.
	* auxv.h (target_auxv_read): Delete prototype.
	* avr-tdep.c (avr_io_reg_read_command): Use target_read_alloc.
	* ia64-tdep.c (getunwind_table, get_kernel_table): Likewise.
	* linux-nat.c (linux_nat_make_corefile_notes): Likewise.
	* procfs.c (procfs_make_note_section): Likewise.
	* remote.c (remote_xfer_partial): Don't loop here.
	* sparc-tdep.c (sparc_fetch_wcookie): Use target_read.
@
text
@d102 1
a102 1
  if (target_read_memory (pc, buf, sizeof (buf)))
@


1.172
log
@gdb/
	* breakpoint.c (deprecated_read_memory_nobpt): Update to use
	shadow_len.
	(insert_bp_location, reattach_breakpoints, remove_breakpoint)
	(delete_breakpoint): Update calls to changed methods.
	(deprecated_insert_raw_breakpoint, deprecated_remove_raw_breakpoint)
	(single_step_breakpoints, insert_single_step_breakpoint)
	(remove_single_step_breakpoints): New.
	* breakpoint.h (struct bp_target_info): New.
	(struct bp_location): Replace shadow_contents with
	target_info and overlay_target_info.
	(deprecated_insert_raw_breakpoint, deprecated_remove_raw_breakpoint)
	(insert_single_step_breakpoint, remove_single_step_breakpoints): New
	prototypes.
	* gdbarch.sh: Forward declare struct bp_target_info in gdbarch.h.
	(memory_insert_breakpoint, memory_remove_breakpoint): Update second
	argument.
	* mem-break.c (default_memory_insert_breakpoint): Update.  Set
	placed_address, placed_size, and shadow_len.
	(default_memory_remove_breakpoint): Update.  Don't use
	BREAKPOINT_FROM_PC.
	(memory_insert_breakpoint, memory_remove_breakpoint): Update.
	* target.c (update_current_target): Update prototypes for changed
	functions.
	(debug_to_insert_breakpoint, debug_to_remove_breakpoint)
	(debug_to_insert_hw_breakpoint, debug_to_remove_hw_breakpoint):
	Update.
	* target.h: Forward declare struct bp_target_info.
	(struct target_ops): Use a bp_target_info argument for
	to_insert_breakpoint, to_remove_breakpoint,
	to_insert_hw_breakpoint, and to_remove_hw_breakpoint.
	(target_insert_breakpoint, target_remove_breakpoint)
	(target_insert_hw_breakpoint, target_remove_hw_breakpoint)
	(memory_insert_breakpoint, memory_remove_breakpoint)
	(default_memory_insert_breakpoint, default_memory_remove_breakpoint):
	Update.
	* config/i386/nm-i386.h: Forward declare struct bp_target_info.
	(i386_insert_hw_breakpoint, i386_remove_hw_breakpoint): Update.
	(target_insert_hw_breakpoint, target_remove_hw_breakpoint): Likewise.

	* gdbarch.c, gdbarch.h: Regenerated.

	* alpha-tdep.c (alpha_software_single_step): Use
	insert_single_step_breakpoint and remove_single_step_breakpoints.
	Remove unused statics.
	* arm-tdep.c (arm_software_single_step): Likewise.  Add a note.
	* cris-tdep.c (cris_software_single_step): Likewise.
	* mips-tdep.c (mips_software_single_step): Likewise.
	* rs6000-tdep.c (rs6000_software_single_step): Likewise.
	* sparc-tdep.c (sparc_software_single_step): Likewise.
	* wince.c (struct thread_info_struct): Remove step_prev.
	(undoSStep): Use remove_single_step_breakpoints.
	(wince_software_single_step): Use insert_single_step_breakpoint.

	* corelow.c (ignore): Remove unneeded prototype.  Update arguments.
	* exec.c (ignore): Likewise.
	* sol-thread.c (ignore): Likewise.

	* procfs.c (dbx_link_shadow_contents): Delete.
	(dbx_link_bpt): New.
	(procfs_mourn_inferior): Remove it if necessary.
	(remove_dbx_link_breakpoint): Use it.
	(insert_dbx_link_bpt_in_file): Set it.
	(procfs_init_inferior): Don't update dbx_link_bpt_addr.
	* rs6000-nat.c (exec_one_dummy_insn): Use
	deprecated_insert_raw_breakpoint and
	deprecated_remove_raw_breakpoint.
	* solib-irix.c (shadow_contents, breakpoint_addr): Delete.
	(base_breakpoint): New.
	(disable_break): Use it.
	(enable_break): Set it.

	* i386-nat.c (i386_insert_hw_breakpoint, i386_remove_hw_breakpoint):
	Update.
	* ia64-tdep.c (ia64_memory_insert_breakpoint)
	(ia64_memory_remove_breakpoint): Likewise.
	* m32r-tdep.c (m32r_memory_insert_breakpoint)
	(m32r_memory_remove_breakpoint): Likewise.
	* monitor.c (monitor_insert_breakpoint, monitor_remove_breakpoint):
	Likewise.  Remove unnecessary prototypes.  Use placed_address
	and placed_size.  Removed useless read from memory.
	* nto-procfs.c (procfs_insert_breakpoint)
	(procfs_remove_breakpoint, procfs_insert_hw_breakpoint)
	(procfs_remove_hw_breakpoint): Update.
	* ocd.c (ocd_insert_breakpoint, ocd_remove_breakpoint): Likewise.
	* ocd.h (ocd_insert_breakpoint, ocd_remove_breakpoint): Likewise.
	* ppc-linux-tdep.c (ppc_linux_memory_remove_breakpoint): Likewise.
	* ppc-tdep.h (ppc_linux_memory_remove_breakpoint): Likewise.
	* remote-e7000.c (e7000_insert_breakpoint)
	(e7000_remove_breakpoint): Likewise.
	* remote-m32r-sdi.c (m32r_insert_breakpoint)
	(m32r_remove_breakpoint): Likewise.
	* remote-mips.c (mips_insert_breakpoint)
	(mips_remove_breakpoint): Likewise.
	* remote-rdp.c (remote_rdp_insert_breakpoint)
	(remote_rdp_remove_breakpoint): Likewise.
	(rdp_step): Use deprecated_insert_raw_breakpoint and
	deprecated_remove_raw_breakpoint.
	* remote-sds.c (sds_insert_breakpoint, sds_remove_breakpoint):
	Update.
	* remote-sim.c (gdbsim_insert_breakpoint, gdbsim_remove_breakpoint):
	Delete.
	(init_gdbsim_ops): Use memory_insert_breakpoint and
	memory_remove_breakpoint.
	* remote-st.c (st2000_insert_breakpoint)
	(st2000_remove_breakpoint): Update.  Remove unused
	BREAKPOINT_FROM_PC.
	* remote.c (remote_insert_breakpoint, remote_remove_breakpoint):
	Update.  Use placed_address and placed_size.
	(remote_insert_hw_breakpoint, remote_remove_hw_breakpoint): Likewise.
gdb/doc/
	* gdbint.texinfo (x86 Watchpoints, Target Conditionals): Update insert
	and remove breakpoint prototypes.
	(Watchpoints): Move description of target_insert_hw_breakpoint and
	target_remove_hw_breakpoint ...
	(Breakpoints): ... to here.  Document target_insert_breakpoint and
	target_remove_breakpoint.
@
text
@d161 1
a161 1
  len = target_read_partial (ops, TARGET_OBJECT_WCOOKIE, NULL, buf, 0, 8);
@


1.172.6.1
log
@Changes from nickrob-async-20060828-mergepoint.
@
text
@d161 1
a161 1
  len = target_read (ops, TARGET_OBJECT_WCOOKIE, NULL, buf, 0, 8);
@


1.171
log
@	* sparc64-linux-tdep.c (sparc64_linux_init_abi): Append dwarf2
	frame sniffer.
	* sparc-tdep.c (sparc32_gdbarch_init): Make sure to call
	dwarf2_frame_set_init_reg() before gdbarch_init_osabi() so
	that the latter can override.
	* Makefile.in (sparc64-linux-tdep.o): Update dependencies.
@
text
@d1139 1
a1139 2
  static CORE_ADDR npc, nnpc;
  static gdb_byte npc_save[4], nnpc_save[4];
d1151 2
a1152 1
	target_insert_breakpoint (npc, npc_save);
d1154 1
a1154 1
	target_insert_breakpoint (nnpc, nnpc_save);
d1163 1
a1163 6
    {
      if (npc != 0)
	target_remove_breakpoint (npc, npc_save);
      if (nnpc != 0)
	target_remove_breakpoint (nnpc, nnpc_save);
    }
@


1.170
log
@	* dwarf2-frame.c (dwarf2_frame_ops init_reg): Add "next_frame"
	argument.
	(dwarf2_frame_default_init_reg): Likewise.
	(dwarf2_frame_set_init_reg): Update init_reg arg.
	(dwarf2_frame_init_reg): Take "next_frame" and pass it to
	ops->init_reg().
	(dwarf2_frame_cache): Pass next_frame to dwarf2_frame_init_reg.
	* dwarf2-frame.h (dwarf2-frame_set_init_reg): Update declaration.
	* cris-tdep.c (cris_dwarf2_frame_init_reg): Add next_frame arg.
	* s390-tdep.c (s390_dwarf2_frame_init_reg): Likewise.
	* sh-tdep.c (sh_dwarf2_frame_init_reg): Likewise.
	* sparc64-tdep.c (sparc64_dwarf2_frame_init_reg): Likewise.
	* sparc-tdep.c (sparc32_struct_return_from_sym): New function.
	(sparc32_frame_cache): Call it.
	(sparc32_dwarf2_struct_return_p): New function.
	(sparc_dwarf2_frame_init_reg): Use it to determine if the function
	returns a structure and thus we have to indicate the return PC and
	NPC are 4 bytes later than usual.
@
text
@a1298 3
  /* Hook in ABI-specific overrides, if they have been registered.  */
  gdbarch_init_osabi (info, gdbarch);

d1304 3
@


1.169
log
@	* sparc-tdep.c (sparc32_dwarf2_frame_init_reg): New.
	(sparc32_gdbarch_init): Pass it to dwarf2_frame_set_init_reg.
	* Makefile.in (sparc-tdep.o): Update dependencies.
@
text
@d683 17
d714 1
a714 10
      struct type *type = check_typedef (SYMBOL_TYPE (sym));
      enum type_code code = TYPE_CODE (type);

      if (code == TYPE_CODE_FUNC || code == TYPE_CODE_METHOD)
	{
	  type = check_typedef (TYPE_TARGET_TYPE (type));
	  if (sparc_structure_or_union_p (type)
	      || (sparc_floating_p (type) && TYPE_LENGTH (type) == 16))
	    cache->struct_return_p = 1;
	}
d1006 11
d1019 2
a1020 1
			       struct dwarf2_frame_state_reg *reg)
d1022 2
a1035 3
      reg->how = DWARF2_FRAME_REG_RA_OFFSET;
      reg->loc.offset = 8;
      break;
d1038 6
a1043 1
      reg->loc.offset = 12;
@


1.168
log
@* sparc-tdep.h (struct gdbarch_tdep): Add step_trap member.
(sparc_address_from_register): New prototype.
(sparcnbsd_step_trap): New prototype.
* sparc-tdep.c (sparc_address_from_register): Make globally
visible.
(sparc_analyze_control_transfer): Change prototype to accept
`struct gdbarch *' as first argument.  Allow for optional hnadling
for trap instructions.
(sparc_step_trap): New function.
(sparc_software_single_step): Adjust call to
sparc_analyze_control_trabsfer.
(sparc32_gdbarch_init): Initialize TDEP->step_trap.
* sparcnbsd-tdep.c (sparcnbsd_step_trap): New function.
(sparc32nbsd_init_abi): Set TDEP->step_trap.
* sparc64obsd-tdep.c (sparc64obsd_init_abi): Set TDEP->step_trap.
* sparc64nbsd-tdep.c (sparc64nbsd_init_abi): Set TDEP->step_trap.
@
text
@d25 1
d998 26
d1278 5
@


1.168.2.1
log
@Merge XML and VFP support to this branch.
@
text
@d160 1
a160 1
  len = target_read (ops, TARGET_OBJECT_WCOOKIE, NULL, buf, 0, 8);
@


1.168.2.1.2.1
log
@Merge to branch:
  http://sourceware.org/ml/gdb-patches/2006-04/msg00139.html
@
text
@d1088 2
a1089 1
  CORE_ADDR npc, nnpc;
d1101 1
a1101 2
	insert_single_step_breakpoint (npc);

d1103 1
a1103 1
	insert_single_step_breakpoint (nnpc);
d1112 6
a1117 1
    remove_single_step_breakpoints ();
@


1.168.4.1
log
@Initial version of available features support.
@
text
@d160 1
a160 1
  len = target_read (ops, TARGET_OBJECT_WCOOKIE, NULL, buf, 0, 8);
@


1.167
log
@* sparc-tdep.c (sparc32_return_value): Convert to use
RETURN_VALUE_ABI_PRESERVES_ADDRESS instead of
RETURN_VALUE_STRUCT_CONVENTION.
(sparc32_extract_struct_value_address): Remove.
@
text
@d173 1
a173 1
static CORE_ADDR
d1003 2
a1004 1
sparc_analyze_control_transfer (CORE_ADDR pc, CORE_ADDR *npc)
d1042 5
a1049 2
  /* FIXME: Handle the Trap instruction.  */

d1077 6
d1086 2
a1087 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d1099 1
a1099 1
      nnpc = sparc_analyze_control_transfer (pc, &npc);
d1202 1
@


1.166
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d3 1
a3 1
   Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.
d959 7
d968 13
a980 1
    return RETURN_VALUE_STRUCT_CONVENTION;
a989 26
#if 0
/* NOTE: cagney/2004-01-17: For the moment disable this method.  The
   architecture and CORE-gdb will need new code (and a replacement for
   DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS) before this can be made to
   work robustly.  Here is a possible function signature: */
/* NOTE: cagney/2004-01-17: So far only the 32-bit SPARC ABI has been
   identifed as having a way to robustly recover the address of a
   struct-convention return-value (after the function has returned).
   For all other ABIs so far examined, the calling convention makes no
   guarenteed that the register containing the return-value will be
   preserved and hence that the return-value's address can be
   recovered.  */
/* Extract from REGCACHE, which contains the (raw) register state, the
   address in which a function should return its structure value, as a
   CORE_ADDR.  */

static CORE_ADDR
sparc32_extract_struct_value_address (struct regcache *regcache)
{
  ULONGEST sp;

  regcache_cooked_read_unsigned (regcache, SPARC_SP_REGNUM, &sp);
  return read_memory_unsigned_integer (sp + 64, 4);
}
#endif

@


1.165
log
@* sparc-tdep.c (sparc_breakpoint_from_pc): Constify break_insn.
@
text
@d3 1
a3 1
   Copyright 2003, 2004, 2005 Free Software Foundation, Inc.
d19 2
a20 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.164
log
@* sparc-tdep.c (sparc32_frame_prev_register): Change type of last
argument to `gdb_byte *'.
* sparcnbsd-tdep.c (sparc32nbsd_sigcontext_frame_prev_register):
Likewise.
* sparcobsd-tdep.c (sparc32obsd_frame_prev_register): Likewise.
* sparc-sol2-tdep.c (sparc32_sol2_sigtramp_frame_prev_register):
Likewise.
* sparc64-tdep.c (sparc64_frame_prev_register): Likewise.
* sparc64fbsd-tdep.c (sparc64fbsd_sigtramp_frame_prev_register):
Likewise.
* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_frame_prev_register):
Likewise.
* sparc64obsd-tdep.c (sparc64obsd_frame_prev_register): Likewise.
* sparc64-sol2-tdep.c (sparc64_sol2_sigtramp_frame_unwind):
Likewise.
@
text
@d496 1
a496 1
  static gdb_byte break_insn[] = { 0x91, 0xd0, 0x20, 0x01 };
@


1.163
log
@* sparc-tdep.c (sparc_fetch_instruction, sparc_fetch_wcookie): Use
gdb_byte for buf.
(sparc32_pseudo_register_read, sparc32_pseudo_register_write):
Change type of last argument to `gdb_byte *'.  Remove casts that
are no longer needed.
(sparc32_push_dummy_code, sparc32_store_arguments): Use gdb_byte
for buf.
(sparc_breakpoint_from_pc): Change return type to `const gdb_byte
*'.  Use gdb_byte for break_insn.
(sparc32_extract_return_value, sparc32_store_return_value): Change
type of last argument to `gdb_byte *'.  Use gdb_byte for buf.
(sparc32_return_value): Change type of readbuf and writebuf
arguments to `gdb_byte *'.
(sparc_software_single_step): Use gdb_byte for npc_save and
nnpc_save.
(sparc_supply_rwindow, sparc_collect_rwindow): Use gdb_byte for
buf.
(sparc32_supply_gregset, sparc32_collect_gregset)
(sparc32_supply_fpregset, sparc32_collect_fpregset): Use `gdb_byte
*' for regs.
* sparc64-tdep.c (sparc64_pseudo_register_read)
(sparc64_pseudo_register_write): Change type of last argument to
`gdb_byte *'.  Remove casts that are no longer needed.
(sparc64_store_floating_fields, sparc64_extract_floating_fields):
Change type of valbuf argument to `gfd_byte *'.
(sparc64_store_arguments): Use `gdb_byte *' for valbuf.  use
gdb_byte for buf.
(sparc64_extract_return_value, sparc64_store_return_value): Change
type of last argument to `gdb_byte *'.  Use gdb_byte for buf.
(sparc64_return_value): Change type of readbuf and writebuf
arguments to `gdb_byte *'.
(sparc64_supply_gregset, sparc64_collect_gregset)
(sparc64_supply_fpregset, sparc64_collect_fpregset): Use `gdb_byte
*' for regs.
@
text
@d744 1
a744 1
			     int *realnump, void *valuep)
@


1.162
log
@* sparc-tdep.c (sparc_supply_rwindow, sparc_collect_rwindow):
Handle StackGhost in 64-bit code.
* sparc64-tdep.c (sparc64_frame_prev_register): Handle StackGhost.
@
text
@d96 1
a96 1
  unsigned char buf[4];
d157 1
a157 1
  char buf[8];
d321 1
a321 1
			      int regnum, void *buf)
d327 1
a327 1
  regcache_raw_read (regcache, regnum + 1, ((char *)buf) + 4);
d333 1
a333 1
			       int regnum, const void *buf)
d339 1
a339 1
  regcache_raw_write (regcache, regnum + 1, ((const char *)buf) + 4);
d355 1
a355 1
      char buf[4];
d450 1
a450 1
      char buf[4];
d493 1
a493 1
static const unsigned char *
d496 1
a496 1
  static unsigned char break_insn[] = { 0x91, 0xd0, 0x20, 0x01 };
d876 1
a876 1
			      void *valbuf)
d879 1
a879 1
  char buf[8];
d918 1
a918 1
			    const void *valbuf)
d921 1
a921 1
  char buf[8];
d956 2
a957 2
		      struct regcache *regcache, void *readbuf,
		      const void *writebuf)
d1085 1
a1085 1
  static char npc_save[4], nnpc_save[4];
d1262 1
a1262 1
  char buf[8];
d1330 1
a1330 1
  char buf[8];
d1396 1
a1396 1
  const char *regs = gregs;
d1460 1
a1460 1
  char *regs = gregs;
d1514 1
a1514 1
  const char *regs = fpregs;
d1531 1
a1531 1
  char *regs = fpregs;
@


1.161
log
@* sparc-tdep.c (sparc_frame_cache): Adjust cached frame base
address for 64-bit code.
(sparc_unwind_dummy_id): Likewise.
* sparc64-tdep.c (sparc64_frame_prev_register): Adjust for new
frame base address convention.
(sparc64_push_dummy_call): Likewise.
* sparc64nbsd-tdep.c: Update copyright year.
(sparc64nbsd_sigcontext_frame_cache): Adjust cached frame base
address for 64-bit code.
(sparc64nbsd_init_abi): Tweak comment.
* sparc64obsd-tdep.c: Update copyright year.
(sparc64obsd_frame_cache): Adjust cached frame base address for
64-bit code.
(sparc64obsd_init_abi): Tweak comment.
@
text
@d1275 10
d1343 10
@


1.160
log
@2005-02-06  Andrew Cagney  <cagney@@gnu.org>

	* value.c (value_contents, value_contents_writeable): New
	functions.
	* value.h (VALUE_CONTENTS): Delete macro.
	(value_contents, value_contents_writeable): Declare.
	* xstormy16-tdep.c, value.c, valops.c, valarith.c: Update.
	* stack.c, sparc-tdep.c, sparc64-tdep.c, sh-tdep.c: Update.
	* sh64-tdep.c, scm-valprint.c, scm-exp.c, s390-tdep.c: Update.
	* rs6000-tdep.c, p-valprint.c, printcmd.c: Update.
	* ppc-sysv-tdep.c, mips-tdep.c, mi/mi-main.c: Update.
	* m88k-tdep.c, m68hc11-tdep.c, m32r-tdep.c: Update.
	* jv-valprint.c, ia64-tdep.c, hppa-tdep.c: Update.
	* hpacc-abi.c, f-valprint.c, frv-tdep.c, eval.c: Update.
	* c-valprint.c, cris-tdep.c, cp-valprint.c: Update.
	* cli/cli-dump.c, breakpoint.c, avr-tdep.c, arm-tdep.c: Update.
	* arm-linux-tdep.c, amd64-tdep.c, alpha-tdep.c: Update.
	* ada-valprint.c, ada-lang.c: Update.
@
text
@d676 3
d865 2
@


1.159
log
@* sparc-tdep.c (sparc_integral_or_pointer_p): Simplify.
@
text
@d3 1
a3 1
   Copyright 2003, 2004 Free Software Foundation, Inc.
d391 1
a391 1
	  write_memory (sp, VALUE_CONTENTS (args[i]), len);
d426 1
a426 1
      char *valbuf = VALUE_CONTENTS (args[i]);
@


1.158
log
@* sparc-tdep.c (X_RS1, X_SIMM13): New macros.
(sparc32_skip_prologue): Skip instructions that store arguments in
registers into their corresponding stack slots.
@
text
@d191 2
d200 4
a203 8
      {
	/* We have byte, half-word, word and extended-word/doubleword
           integral types.  The doubleword is an extension to the
           original 32-bit ABI by the SCD 2.4.x.  */
	int len = TYPE_LENGTH (type);
	return (len == 1 || len == 2 || len == 4 || len == 8);
      }
      return 1;
d206 2
a207 6
      {
	/* Allow either 32-bit or 64-bit pointers.  */
	int len = TYPE_LENGTH (type);
	return (len == 4 || len == 8);
      }
      return 1;
@


1.157
log
@        * sparc-tdep.c (sparc_is_unimp_insn): New function.
        (sparc32_frame_cache): For functions where there is no debugging
        information to help us determine whether it's a struct-return
        function or not, fallback on checking whether the instruction
        at the return address is an "unimp" instruction or not.
@
text
@d83 1
d88 1
d614 30
a643 1
  return sparc_analyze_prologue (start_pc, 0xffffffffUL, &cache);
@


1.156
log
@	* sparc-tdep.c (sparc_software_single_step): Handle stepping to NULL.
@
text
@d109 11
d679 15
@


1.155
log
@2004-11-12  Andrew Cagney  <cagney@@gnu.org>

	* sparc-tdep.c: Replace VALUE_TYPE with value_type.
	* v850-tdep.c, sparc64-tdep.c, sh-tdep.c: Ditto.
	* sh64-tdep.c, s390-tdep.c, mcore-tdep.c: Ditto.
	* h8300-tdep.c, arm-linux-tdep.c, amd64-tdep.c: Ditto.
	* hppa-tdep.c, mips-tdep.c, m88k-tdep.c: Ditto.
	* m68hc11-tdep.c, m32r-tdep.c, ia64-tdep.c: Ditto.
	* frv-tdep.c, cris-tdep.c, avr-tdep.c, alpha-tdep.c: Ditto.
@
text
@d1033 1
a1033 1
      CORE_ADDR pc;
d1036 1
a1036 1
      npc = sparc_address_from_register (tdep->npc_regnum);
d1046 4
a1049 3
         they're not set at the same spot.  */
      gdb_assert (npc != 0 || nnpc != 0);
      gdb_assert (nnpc != npc);
@


1.154
log
@2004-10-27  Andrew Cagney  <cagney@@gnu.org>

	* trad-frame.c (trad_frame_get_prev_register): Use
	frame_unwind_register instead of frame_register_unwind, do not
	recurse the register's location.
	* xstormy16-tdep.c (xstormy16_frame_prev_register):
	* sparc-tdep.c (sparc32_frame_prev_register): Ditto.
	* sparc64-tdep.c (sparc64_frame_prev_register): Ditto.
	* sh-tdep.c (sh_frame_prev_register): Ditto.
	* m68k-tdep.c (m68k_frame_prev_register): Ditto.
	* i386-tdep.c (i386_frame_prev_register): Ditto.
	* dwarf2-frame.c (dwarf2_frame_prev_register): Ditto.
	* amd64-tdep.c (amd64_frame_prev_register): Ditto.
@
text
@d371 1
a371 1
      struct type *type = VALUE_TYPE (args[i]);
d420 1
a420 1
      struct type *type = VALUE_TYPE (args[i]);
@


1.153
log
@2004-06-06  Randolph Chung  <tausq@@debian.org>

	* gdbarch.sh (PUSH_DUMMY_CALL): Change CORE_ADDR func_addr argument
	to struct value *function.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Likewise.
	* infcall.c (call_function_by_hand): Pass entire function value
	to push_dummy_call.

	* Makefile.in (alpha-tdep.o, frv-tdep.o, ia64-tdep.o, mips-tdep.o)
	(ppc-sysv-tdep.o, rs6000-tdep.o): Update dependencies.
	* alpha-tdep.c (alpha_push_dummy_call): Update call signature.
	* amd64-tdep.c (amd64_push_dummy_call): Likewise.
	* arm-tdep.c (arm_push_dummy_call): Likewise.
	* avr-tdep.c (avr_push_dummy_call): Likewise.
	* cris-tdep.c (cris_push_dummy_call): Likewise.
	* d10v-tdep.c (d10v_push_dummy_call): Likewise.
	* frv-tdep.c (frv_push_dummy_call): Likewise.
	* h8300-tdep.c (h8300_push_dummy_call): Likewise.
	* hppa-tdep.c (hppa32_push_dummy_call)
	(hppa64_push_dummy_call): Likewise.
	* i386-tdep.c (i386_push_dummy_call): Likewise.
	* ia64-tdep.c (ia64_push_dummy_call): Likewise.
	* m32r-tdep.c (m32r_push_dummy_call): Likewise.
	* m68hc11-tdep.c (m68hc11_push_dummy_call): Likewise.
	* m68k-tdep.c (m68k_push_dummy_call): Likewise.
	* m88k-tdep.c (m88k_push_dummy_call): Likewise.
	* mips-tdep.c (mips_eabi_push_dummy_call, mips_n32n64_push_dummy_call)
	(mips_o32_push_dummy_call, mips_o64_push_dummy_call): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	* ppc-tdep.h (ppc_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	* rs6000-tdep.c (rs6000_push_dummy_call): Likewise.
	* s390-tdep.c (s390_push_dummy_call): Likewise.
	* sh-tdep.c (sh_push_dummy_call_fpu)
	(sh_push_dummy_call_nofpu): Likewise.
	* sparc-tdep.c (sparc32_push_dummy_call): Likewise.
	* sparc64-tdep.c (sparc64_push_dummy_call): Likewise.
	* vax-tdep.c (vax_push_dummy_call): Likewise.
@
text
@d766 6
a771 2
  frame_register_unwind (next_frame, regnum,
			 optimizedp, lvalp, addrp, realnump, valuep);
@


1.152
log
@* i386-nat.c: Fix typo in comment.  Re-introduce paranoiac.
* i386obsd-tdep.c: Correct spelling in comment.
* i386nbsd-tdep.c: Correct spelling in comment.
* sparc-tdep.c: Correct spelling in comments.
@
text
@d453 1
a453 1
sparc32_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
@


1.151
log
@* sparc-tdep.c: Fix typo in comment.
@
text
@d49 1
a49 1
   lists changes with respect to the origional 32-bit psABI as defined
d188 1
a188 1
           origional 32-bit ABI by the SCD 2.4.x.  */
@


1.150
log
@* sparc-tdep.c (sparc_frame_cache): Don't bail out if %fp is zero.
Reorganize code a bit.
@
text
@d46 5
a50 6
/* This file implements the The SPARC 32-bit ABI as defined by the
   section "Low-Level System Information" of the SPARC Compliance
   Definition (SCD) 2.4.1, which is the 32-bit System V psABI for
   SPARC.  The SCD lists changes with respect to the origional 32-bit
   psABI as defined in the "System V ABI, SPARC Processor
   Supplement".
@


1.149
log
@* sparc-tdep.c (sparc32_frame_prev_register): Rename local
variable `i6' to `i7'.
(sparc_supply_rwindow, sparc_collect_rwindow): Likewise.
@
text
@a617 8
  /* In priciple, for normal frames, %fp (%i6) holds the frame
     pointer, which holds the base address for the current stack
     frame.  */

  cache->base = frame_unwind_register_unsigned (next_frame, SPARC_FP_REGNUM);
  if (cache->base == 0)
    return cache;

d627 12
a638 4
      /* We didn't find a valid frame, which means that CACHE->base
	 currently holds the frame pointer for our calling frame.  */
      cache->base = frame_unwind_register_unsigned (next_frame,
						    SPARC_SP_REGNUM);
@


1.149.4.1
log
@Merge mainline to intercu branch.
@
text
@d46 6
a51 5
/* This file implements the SPARC 32-bit ABI as defined by the section
   "Low-Level System Information" of the SPARC Compliance Definition
   (SCD) 2.4.1, which is the 32-bit System V psABI for SPARC.  The SCD
   lists changes with respect to the original 32-bit psABI as defined
   in the "System V ABI, SPARC Processor Supplement".
d189 1
a189 1
           original 32-bit ABI by the SCD 2.4.x.  */
d618 8
d635 4
a638 12
      /* This function is frameless, so %fp (%i6) holds the frame
         pointer for our calling frame.  Use %sp (%o6) as this frame's
         base address.  */
      cache->base =
	frame_unwind_register_unsigned (next_frame, SPARC_SP_REGNUM);
    }
  else
    {
      /* For normal frames, %fp (%i6) holds the frame pointer, the
         base address for the current stack frame.  */
      cache->base =
	frame_unwind_register_unsigned (next_frame, SPARC_FP_REGNUM);
@


1.149.4.2
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d453 1
a453 1
sparc32_push_dummy_call (struct gdbarch *gdbarch, struct value *function,
@


1.149.6.1
log
@* sparc-tdep.c (sparc_frame_cache): Don't bail out if %fp is zero.
Reorganize code a bit.
@
text
@d618 8
d635 4
a638 12
      /* This function is frameless, so %fp (%i6) holds the frame
         pointer for our calling frame.  Use %sp (%o6) as this frame's
         base address.  */
      cache->base =
	frame_unwind_register_unsigned (next_frame, SPARC_SP_REGNUM);
    }
  else
    {
      /* For normal frames, %fp (%i6) holds the frame pointer, the
         base address for the current stack frame.  */
      cache->base =
	frame_unwind_register_unsigned (next_frame, SPARC_FP_REGNUM);
@


1.148
log
@* target.h (target_object): Add TARGET_OBJECT_WCOOKIE.
* inftarg.c: Update copyright year.
(child_xfer_partial): Add support for TARGET_OBJECT_WCOOKIE.
* sparc-nat.c: Include "target.h" and "gdb_assert.h".
(sparc_xfer_wcookie): New function.
* sparc-tdep.c (sparc_fetch_wcookie): New function.
* Makefile.in (sparc-nat.o): Update dependencies.
* config/sparc/nm-nbsd.h: Include "target.h".
(NATIVE_XFER_WCOOKIE): New define.
(sparc_xfer_wcookie): New prototype.
@
text
@d732 1
a732 1
	    ULONGEST i6;
d735 2
a736 2
	    i6 = get_frame_memory_unsigned (next_frame, addr, 4);
	    store_unsigned_integer (valuep, 4, i6 ^ wcookie);
d1244 1
a1244 1
		  ULONGEST i6 = extract_unsigned_integer (buf + offset, 4);
d1246 1
a1246 1
		  store_unsigned_integer (buf + offset, 4, i6 ^ wcookie);
d1297 1
a1297 1
		  ULONGEST i6 = extract_unsigned_integer (buf + offset, 4);
d1299 1
a1299 1
		  store_unsigned_integer (buf + offset, 4, i6 ^ wcookie);
@


1.147
log
@* sparc-tdep.c (sparc_fetch_wcookie): New function.
(sparc32_frame_prev_register): Handle StackGhost.
(sparc_supply_rwindow, sparc_collect_rwindow): Likewise.
@
text
@d144 12
a155 4
  /* FIXME: kettenis/20040131: We should fetch the cookie from the
     target.  For now, return zero, which is right for targets without
     StackGhost.  */
  return 0;
d157 1
a158 1

@


1.146
log
@2004-01-26  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (EXTRACT_STRUCT_VALUE_ADDRESS): Deprecate.  Add
	comments mentioning extract_returned_value_address.
	* infcmd.c (print_return_value): Update.  Add comments on
	extract_returned_value_address.
	* stack.c (return_command): Add comments on
	extract_returned_value_address.
	* values.c: Update comment.
	* m32r-tdep.c: Update comment.
	* sparc-tdep.c: Update comment.
	* ia64-tdep.c (ia64_use_struct_convention): Update comment.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* sh64-tdep.c (sh64_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* m68klinux-tdep.c (m68k_linux_init_abi): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* m32r-tdep.c (m32r_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

Index: doc/ChangeLog
2004-01-26  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	EXTRACT_STRUCT_VALUE_ADDRESS to
	DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS.
@
text
@d109 42
d711 23
d1231 10
d1284 10
@


1.145
log
@* sparc-tdep.c (sparc_regset_from_core_section): Check whether
SECT_SIZE is large enough, not wheter it's exactly the right size.
(sparc32_gdbarch_init): Initialize TDEP->sizeof_gregset and
TDEP->fpregset to zero.
@
text
@d842 2
a843 2
   EXTRACT_STRUCT_VALUE_ADDRESS) before this can be made to work
   robustly.  Here is a possible function signature: */
@


1.144
log
@* sparc-tdep.c (sparc32_gdbarch_init): Don't require
TDEP->fpregset to be initialized to enable core file register
sets.
@
text
@d1033 1
a1033 1
  if (strcmp (sect_name, ".reg") == 0 && sect_size == tdep->sizeof_gregset)
d1036 1
a1036 1
  if (strcmp (sect_name, ".reg2") == 0 && sect_size == tdep->sizeof_fpregset)
d1061 1
a1061 1
  tdep->sizeof_gregset = 20 * 4;
d1063 1
a1063 1
  tdep->sizeof_fpregset = 33 * 4;
@


1.143
log
@* sparc-tdep.c (sparc_fetch_instruction): Return zero if we can't
read the instruction at PC.
@
text
@d1116 1
a1116 1
  if (tdep->gregset && tdep->fpregset)
@


1.142
log
@2004-01-17  Andrew Cagney  <cagney@@redhat.com>

	* x86-64-tdep.c (x86_64_init_abi): No need to clear
	extract_struct_value_address, i386 does not set it.
	* sparc64-tdep.c (sparc64_init_abi): Do not set
	extract_struct_value_address, never called.
	(sparc64_extract_struct_value_address): Delete function.
	* m68hc11-tdep.c: Update copyright.
	(m68hc11_gdbarch_init): Delete redundant assignment of
	extract_struct_value_address.
	* i386-tdep.c: Update copyright.
	(i386_gdbarch_init): Do not set extract_struct_value_address,
	never called.
	(i386_extract_struct_value_address): Delete function.
	* sparc-tdep.c (sparc32_gdbarch_init): Do not set
	extract_struct_value_address, never called.
	(sparc32_extract_struct_value_address): #if 0 function.
@
text
@d99 3
a101 1
  read_memory (pc, buf, sizeof (buf));
@


1.141
log
@2004-01-17  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DECR_PC_AFTER_BREAK): Make zero the default.
	* gdbarch.c: Re-generate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	DECR_PC_AFTER_BREAK to zero.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc32_gdbarch_init): Ditto.
	* sh64-tdep.c (sh64_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* m32r-tdep.c (m32r_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-interix-tdep.c (i386_interix_init_abi): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* i386-nto-tdep.c (i386nto_init_abi): Add comment.
@
text
@d837 12
d861 1
a1084 2
  set_gdbarch_extract_struct_value_address
    (gdbarch, sparc32_extract_struct_value_address);
@


1.140
log
@2004-01-13  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (FUNCTION_START_OFFSET): Make zero the default.
	* gdbarch.c: Re-generate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	FUNCTION_START_OFFSET.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc32_gdbarch_init): Ditto.
	* sh64-tdep.c (sh64_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* m32r-tdep.c (m32r_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
@
text
@a1082 1
  set_gdbarch_decr_pc_after_break (gdbarch, 0);
@


1.139
log
@* sparc-tdep.c (sparc32_extract_struct_value_address): Rename from
sparc_extract_struct_value_address.
(sparc32_gdbarch_init): Set extract_struct_value_address.
* sparc64-tdep.c (sparc64_extract_struct_value_address): New
function.
(sparc64_init_abi): Set extract_struct_value_address.  Don't set
return_value_on_stack.
@
text
@a1083 1
  set_gdbarch_function_start_offset (gdbarch, 0);
@


1.138
log
@* sparc-tdep.h (struct regset): Provide opaque declaration.
(struct gdbarch_tdep): Add gregset, sizeof_gregset,
fpregset and sizeof_fpregset members.
* sparc-tdep.c (struct regset): Provide opaque declaration.
(sparc_regset_from_core_section): New function.
(sparc32_gdbarch_init): Initialize TDEP->gregset,
TDEP->sizeof_gregset, TDEP->fpregset and TDEP->sizeof_fpregset.
Set regset_from_core_section when appropriate.
@
text
@d842 1
a842 1
sparc_extract_struct_value_address (struct regcache *regcache)
d1072 2
@


1.137
log
@* sparc-tdep.c (sparc_extract_struct_value_address): Get the
address from [sp + 64] instead of %o2.
@
text
@d44 2
d1009 19
d1045 4
d1101 5
@


1.136
log
@* sparc-tdep.c (sparc32_return_value): New function.
 (sparc32_use_struct_convention, sparc32_return_value_on_stack):
Remove functions.
(sparc32_gdbarch_init): Set return_value, don't set
extract_return_value, store_return_value, use_struct_convention
and return_value_on_stack.
@
text
@d842 1
a842 1
  ULONGEST addr;
d844 2
a845 2
  regcache_cooked_read_unsigned (regcache, SPARC_O0_REGNUM, &addr);
  return addr;
@


1.135
log
@* Makefile.in (ALLDEPFILES): Remove sparc-linux-nat.c and
sparcl-tdep.c.  Add sparc-linux-tdep.c, sparc-sol2-nat.c,
sparc-sol2-tdep.c, sparc-sol2-nat.c, sparc-sol2-tdep.c,
sparc64-linux-nat.c, sparc64-linux-tdep.c, sparc64-nat.c,
sparc64-sol2-tdep.c, sparc64-tdep.c, sparc64fbsd-nat.c,
sparc64fbsd-tdep.c, sparcnbsd-nat.c, sparcnbsd-tdep.c.
(sparc_nat_h): New variable.
(sparcbsd_nat_h, sparcnbsd_tdep_h): Remove variables.
(tm-sun4os4.h): Remove dependency.
(sparcbsd-nat.o, sparc-linux-nat.o): Remove dependencies.
(sparc64fbsd-nat.o, sparc64fbsd-tdep.o, sparc64nbsd-nat.o,
sparc64-tdep.o, sparc-nat.o, sparcnbsd-nat.o, sparcnbsd-tdep.o,
sparc-tdep.o): Update dependencies.
(sparc-linux-tdep.o, sparc-sol2-nat.o, sparc-sol2-tdep.o,
sparc64-linux-nat.o, sparc64-linux-tdep.o, sparc64-nat.o,
sparc64-sol2-tdep.o, sparc64-tdep.o, sparc64nbsd-tdep.o): New
dependencies.
* configure.host: Remove existing sparc-*-lynxos*,
sparc-*-solaris*, sparc-*-sunos4*, sparc-*-sunos5*, sparc-*-*,
ultrasparc-*-freebsd, sparcv9-*-freebsd, sparc64-*-linux*,
sparcv9-*-* and sparc64-*-* triplets.  Add new sparc64-*-linux*,
sparc-*-solaris2*, sparcv9-*-solaris2* and sparc64-*-solaris2*
triplets.
* configure.tgt: Remove exitsing sparc-*-aout*, sparc-*-coff*,
sparc-*-elf*, sparc*-lynxos*, sparc-*-solars2*, sparc-*-sunos4*,
sparc-*-sunos5*, sparc-*-vxworks*, sparc64-*linux*, sparc64-*-*,
sparcv9-*-* and commented out sparc64-*-solars2* triplets.  Add
new sparc-*-solaris2.[0-6], sparc-*-solaris2.[0-6].*,
sparc64-*-linux, sparc-*-solaris2*, sparcv9-*-solaris*,
sparc64-*-solaris2* and sparc64-*-* triplets.
* sparc64-tdep.c: Update copyright year.  Include "inferior.h",
"symtab.h" and "objfiles.h".
(BIAS): Remove define.
(X_OP, X_RD, X_A, X_COND, X_OP2, X_IMM22, X_OP3, X_I, X_DISP22)
(X_DISP19): Remove macros.
(sparc_fetch_instruction): Remove function.
(struct gdbarch_tdep): Remove definition.
(SPARC64_NUM_REGS, SPARC64_NUM_PSEUDO_REGS): Use ARRAY_SIZE.
(sparc_breakpoint_from_pc): Remove function.
(struct sparc64_frame_cache): Remove definition.
(sparc64_alloc_frame_cache, sparc64_analyze_prologue,
sparc64_unwind_pc): Remove functions.
(sparc64_skip_prologue): Use `struct sparc_frame_cache' instead of
`struct sparc64_frame_cache.  Call sparc_analyze_prologue instead
of sparc64_analyze_prologue.  Mark constant as ULL instead of UL.
(sparc64_frame_cache): Change return type to `struct
sparc_frame_cache *'.  Simply call sparc_frame_cache.
(sparc64_frame_this_id, sparc64_frame_prev_register,
sparc64_frame_base_address): Use `struct sparc_frame_cache'
instead of `struct sparc64_frame_cache.
(sparc_unwind_dummy_id, sparc_extract_struct_value_address,
sparc_analyze_control_transfer, sparc_software_single_step,
sparc64_gdbarch_init, sparc_supply_rwindow, sparc_fill_rwindow,
_initialize_sparc64_tdep): Remove functions.
(TSTATE_CWP, TSTATE_ICC, TSTATE_XCC): New macros.
(PSR_S, PSR_ICC, PSR_VERS, PSR_IMPL, PSR_V8PLUS, PSR_XCC): New
macros.
(sparc64_supply_gregset, sparc64_collect_gregset,
sparc64_supply_fpregset, sparc64_collect_fpregset): New functions.
(sparc64_init_abi): New function.
* sparc64-tdep.h: Update copyright year.  Fix typo in multiple
inclusion guard.  Include "sparc-tdep.h".
(BIAS): Define.
(r_tstate_offset, r_fprs_offset): New defines.
(enum sparc_regnum): Remove defenition.
(enum sparc64_regnum): Reformat.
(sparc_supply_rwindow, sparc_fill_rwindow): Remove prototypes.
(sparc64_init_abi, sparc64_supply_gregset,
sparc64_collect_gregset, sparc64_supply_fpregset,
sparc64_collect_fpregset): New prototypes.
(sparc64_sol2_gregset, sparc64nbsd_gregset, sparc64fbsd_gregset):
Add extern declarations.
(sparc64_sol2_init_abi): New prototype.
(sparc64fbsd_supply_reg, sparc64fbsd_fill_reg)
(sparc64fbsd_supply_fpreg, sparc64fbsd_fill_fpreg): Remove
prototypes.
* sparc64fbsd-nat.c: Include "sparc-nat.h", don't include
"sparnbsd-nat.h".
(sparc64fbsd_reg_supplies_p, sparc64fbsd_fpreg_supplies_p): Remove
functions.
(_initialize_sparc64fbsd_nat): Remove initialization of
sparcbsd_supply_reg, sparcbsd_fill_reg, sparcbsd_supply_fpreg,
sparcbsd_fill_fpreg, sparcbsd_reg_supplies_p,
sparcbsd_fpreg_supplies_p.  Initialize sparc_gregset.
* sparc64fbsd-tdep.c: Update copyright year.  Include "frame.h",
"frame-unwind.h", "trad-frame.h" and "gdb_assert.h".
(sparc64fbsd_r_global_offset, sparc64fbsd_r_out_offset)
(sparc64fbsd_r_fprs_offset, sparc64fbsd_r_tnpc_offset)
(sparc64fbsd_r_tpc_offset, sparc64fbsd_r_tstate_offset)
(sparc64fbsd_r_y_offset): Remove variables.
(sparc64fbsd_sizeof_struct_reg, sparc64fbsd_sizeof_struct_fpreg):
Make static and const.
(sparc64fbsd_supply_reg, sparc64fbsd_fill_reg)
(sparc64fbsd_supply_fpreg, sparc64fbsd_fill_fpreg): Remove
functions.
(sparc64fbsd_gregset): New variable.
(fetch_core_registers): Replace calls to sparc64fbsd_supply_reg
and sparc64fbsd_supply_fpreg with calls to sparc64_supply_gregset
and sparc64_supply_fpregset.
(sparc64fbsd_pc_in_sigtramp, sparc64fbsd_sigtramp_frame_cache)
(sparc64fbsd_sigtramp_frame_this_id)
(sparc64fbsd_sigtramp_frame_prev_register): New functions.
(sparc64fbsd_sigtramp_frame_unwind): New variable.
(sparc64fbsd_sigtramp_frame_sniffer): New function.
(sparc64fbsd_init_abi): Set pc_in_sigtramp, append
sparc64fbsd_sigtramp_frame_sniffer.  Call sparc64_init_abi.
* sparcnbsd-tdep.c: Update copyright year.  Include
"floatformat.h", "frame.h", "frame-unwind.h", "symtab.h",
"trad-frame.h" and "gdb_assert.h", don't include "target.h",
"value.h" and "sparcnbsd-tdep.h".
(REG32_OFFSET_PSR, REG32_OFFSET_PC, REG32_OFFSET_NPC)
(REG32_OFFSET_Y, REG32_OFFSET_GLOBAL, REG32_OFFSET_OUT)
(REG64_OFFSET_TSTATE, REG64_OFFSET_PC, REG64_OFFSET_NPC)
(REG64_OFFSET_Y, REG64_OFFSET_GLOBAL, REG64_OFFSET_OUT): Remove
defines.
(sparcnbsd_gregset): New variable.
(sparcnbsd_supply_reg32, sparcnbsd_supply_reg64)
(sparcnbsd_fill_reg32, sparcnbsd_fill_reg64)
(sparcnbsd_supply_fpreg32, sparcnbsd_supply_fpreg64)
(sparcnbsd_fill_reg32, sparcnbsd_fill_reg64): Remove functions.
(sparc32nbsd_sigtramp_start, sparc32nbsd_sigtramp_end): New
variables.
(sparc32nbsd_pc_in_sigtramp, sparc32nbsd_sigcontext_frame_cache)
(sparc32nbsd_sigcontext_frame_this_id)
(sparc32nbsd_sigcontext_frame_prev_register): New functions.
(sparc32nbsd_sigcontext_frame_unwind): New variable.
(sparc32nbsd_sigtramp_frame_sniffer): New function.
(sparcnbsd_get_longjmp_target_32,
sparcnbsd_get_longjmp_target_64): Remove functions.
(sparcnbsd_aout_in_solib_call_trampoline): Rewrite.
(sparcnbsd_init_abi_common, sparcnbsd_init_aout,
sparcnbsd_init_elf): Remove.
(sparcnbsd_init_abi, sparcnbsd_aout_init_abi)
(sparcnbsd_elf_init_abi): New functions.
(_initialize_sparcnbsd_tdep): New prototype.
(_initialize_sparnbsd_tdep): Update.
* config/sparc/fbsd.mh (NATDEPFILES): Remove sparcbsd-nat.o and
corelow.o.  Add sparc64-nat.o and sparc-nat.o.
* config/sparc/fbsd.mt (TDEPFILES): Add sparc-tdep.o and corelow.o.
* config/sparc/linux.mh: Update comment.
(XM_FILE, HOST_IPC): Remove variables.
(NATDEPFILES): Add sparc-sol2-nat.o and core-regset.o.  Remove
sparc-linux-nat.o.
* config/sparc/linux.mt: Update comment.
(TDEPFILES): Add sparc-sol2-tdep.o and sparc-linux-tdep.o.
* config/sparc/nbsd.mt: Reformat.
* config/sparc/nbsd64.mh: Update comment.
(NATDEPFILES): Add sparc-nat.o.
* config/sparc/nbsd64.mt: Update comment.
(TDEPFILES): Add sparc64-tdep.o and sparc64nbsd-tdep.o.
(TM_FILE): Set to tm-nbsd.h.
* config/sparc/nbsdelf.mh: Update comment.
(NATDEPFILES): Add sparc-nat.o.
(XM_FILE): Delete.
* config/sparc/nbsdaout.mh: Update comment.
(NATDEPFILES): Add sparc-nat.o
(XM_FILE): Delete.
* config/sparc/nm-linux.h: Update copyright year.  Don't include
"config/nm-svr4.h" and "solib.h".  Add protection against multiple
inclusion.
(KERNEL_U_SIZE): Remove define.
(kernel_u_size): Remove prototype.
(PTRACE_ARG3_TYPE, PTRACE_XFER_TYPE): Define.
* config/sparc/nm-nbsd.h: Update copyright.  Don't include
"regcache.h".
(CHILD_PREPARE_TO_STORE): Remove define.
* config/sparc/nm-nbsdaout.h: Tweak some comments.
* sparc-nat.c, sparc-tdep.c, sparc-tdep.h, sparc64nbsd-nat.c,
sparcnbsd-nat.c: Rewrite files.
* config/sparc/tm-linux.h, config/sparc/tm-nbsd.h: Rewrite files.
* sparc-linux-nat.c, sparcbsd-nat.c, sparcbsd-nat.h,
sparcnbsd-tdep.h: Remove files.
* config/sparc/nm-sparclynx.h, config/sparc/nm-sun4os4.h,
config/sparc/nm-sun4sol2.h, config/sparc/sp64.mt,
config/sparc/sp64linux.mt, config/sparc/sp64sol2.mt,
config/sparc/sparc-em.mt, config/sparc/sparclynx.mh,
config/sparc/sparclynx.mt, config/sparc/sun4os4.mh,
config/sparc/sun4os4.mt, config/sparc/sun4sol2.mh,
config/sparc/sun4sol2.mt, config/sparc/tm-sp64.h,
config/sparc/tm-sp64linux.h, config/sparc/tm-sparc.h,
config/sparc/tm-sparclynx.h, config/sparc/tm-spc-em.h,
config/sparc/tm-sun4os4.h, config/sparc/tm-sun4sol2.h,
config/sparc/tm-vxsparc.h, config/sparc/vxsparc.mt,
config/sparc/xm-linux.h, config/sparc/xm-sun4sol2.h: Remove files.
* sparc-linux-tdep.c, sparc-nat.h, sparc-sol2-nat.c,
sparc-sol2-tdep.c, sparc64-linux-nat.c, sparc64-linux-t dep.c,
sparc64-nat.c, sparc64-sol2-tdep.c, sparc64nbsd-tdep.c: New files.
* config/sparc/linux64.mh, config/sparc/linux64.mt,
config/sparc/nm-sol2.h, config/sparc/sol2-64.mt,
config/sparc/sol2.mh, config/sparc/sol2.mt, config/sparc/sparc.mt,
config/sparc/sparc64.mt, config/sparc/tm-sol2.h: New files.
@
text
@d818 17
a848 14
sparc32_use_struct_convention (int gcc_p, struct type *type)
{
  gdb_assert (sparc_structure_or_union_p (type));
  return 1;
}

static int
sparc32_return_value_on_stack (struct type *type)
{
  gdb_assert (!sparc_structure_or_union_p (type));
  return (sparc_floating_p (type) && TYPE_LENGTH (type) == 16);
}

static int
d1046 1
a1046 6
  set_gdbarch_extract_return_value (gdbarch, sparc32_extract_return_value);
  set_gdbarch_store_return_value (gdbarch, sparc32_store_return_value);
  set_gdbarch_extract_struct_value_address
    (gdbarch, sparc_extract_struct_value_address);
  set_gdbarch_use_struct_convention (gdbarch, sparc32_use_struct_convention);
  set_gdbarch_return_value_on_stack (gdbarch, sparc32_return_value_on_stack);
@


1.134
log
@2003-11-23  Andrew Cagney  <cagney@@redhat.com>

	* symfile.c (symbol_file_command): Replace STREQ with strcmp.
	* defs.h (DEPRECATED_STREQN): Rename STREQN.
	(DEPRECATED_STREQ): Rename STREQ.
	* ada-exp.y, ada-lang.c, ada-lex.l, coffread.c: Update.
	* config/mips/tm-irix5.h, config/mips/tm-irix6.h: Update.
	* config/mips/tm-mipsv4.h, config/sparc/tm-sun4sol2.h: Update.
	* dbxread.c, dwarf2read.c, dwarfread.c, environ.c: Update.
	* eval.c, exec.c, f-lang.c, hppa-tdep.c, hpread.c: Update.
	* jv-exp.y, language.c, m2-exp.y, mcore-rom.c: Update.
	* mdebugread.c, mipsread.c, objc-exp.y, objfiles.c: Update.
	* p-exp.y, p-typeprint.c, p-valprint.c, rs6000-nat.c: Update.
	* source.c, sparc-tdep.c, stack.c, target.c: Update.
@
text
@d1 1
a1 1
/* Target-dependent code for the SPARC for GDB, the GNU debugger.
d3 1
a3 3
   Copyright 1986, 1987, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation,
   Inc.
a21 2
/* ??? Support for calling functions from gdb in sparc64 is unfinished.  */

d24 2
d27 4
d32 4
d38 2
a39 1
#include "bfd.h"
a40 3
#include "regcache.h"
#include "osabi.h"
#include "dis-asm.h"
d44 52
a95 5
#ifdef	USE_PROC_FS
#include <sys/procfs.h>
/* Prototypes for supply_gregset etc. */
#include "gregset.h"
#endif
d97 9
a105 2
#include "gdbcore.h"
#include "gdb_assert.h"
d107 4
a110 1
#include "symfile.h" 	/* for 'entry_point_address' */
d112 4
a115 38
/*
 * Some local macros that have multi-arch and non-multi-arch versions:
 */

#define SPARC_HAS_FPU 1
/* Number of bytes devoted to Floating Point registers: */
#define FP_REGISTER_BYTES (gdbarch_tdep (current_gdbarch)->fp_register_bytes)
/* Highest numbered Floating Point register.  */
#define FP_MAX_REGNUM     (gdbarch_tdep (current_gdbarch)->fp_max_regnum)
/* Size of a general (integer) register: */
#define SPARC_INTREG_SIZE (gdbarch_tdep (current_gdbarch)->intreg_size)
/* Offset within the call dummy stack of the saved registers.  */
#define DUMMY_REG_SAVE_OFFSET (gdbarch_tdep (current_gdbarch)->reg_save_offset)

struct gdbarch_tdep
  {
    int fp_register_bytes;
    int y_regnum;
    int fp_max_regnum;
    int intreg_size;
    int reg_save_offset;
    int call_dummy_call_offset;
    int print_insn_mach;
  };

/* Now make GDB_TARGET_IS_SPARC64 a runtime test.  */
/* FIXME MVS: or try testing bfd_arch_info.arch and bfd_arch_info.mach ... 
 * define GDB_TARGET_IS_SPARC64 \
 *      (TARGET_ARCHITECTURE->arch == bfd_arch_sparc &&    \
 *      (TARGET_ARCHITECTURE->mach == bfd_mach_sparc_v9 || \
 *       TARGET_ARCHITECTURE->mach == bfd_mach_sparc_v9a))
 */

/* We don't store all registers immediately when requested, since they
   get sent over in large chunks anyway.  Instead, we accumulate most
   of the changes and send them over once.  "deferred_stores" keeps
   track of which sets of registers we have locally-changed copies of,
   so we only need send the groups that have changed.  */
d117 2
a118 1
int deferred_stores = 0;    /* Accumulated stores we want to do eventually. */
d120 1
d122 2
a123 2
const unsigned char *
sparc_breakpoint_from_pc (CORE_ADDR *pc, int *len)
d125 28
a152 3
  static const char breakpoint[] = {0x91, 0xd0, 0x20, 0x01};
  (*len) = sizeof (breakpoint);
  return breakpoint;
d155 1
a155 2
/* Fetch a single instruction.  Even on bi-endian machines
   such as sparc86x, instructions are always big-endian.  */
d157 2
a158 2
static unsigned long
fetch_instruction (CORE_ADDR pc)
d160 15
a174 3
  unsigned long retval;
  int i;
  unsigned char buf[4];
d176 11
a186 1
  read_memory (pc, buf, sizeof (buf));
d188 1
a188 6
  /* Start at the most significant end of the integer, and work towards
     the least significant.  */
  retval = 0;
  for (i = 0; i < sizeof (buf); ++i)
    retval = (retval << 8) | buf[i];
  return retval;
d191 39
d231 2
a232 2
/* Branches with prediction are treated like their non-predicting cousins.  */
/* FIXME: What about floating point branches?  */
d234 2
a235 42
/* Macros to extract fields from sparc instructions.  */
#define X_OP(i) (((i) >> 30) & 0x3)
#define X_RD(i) (((i) >> 25) & 0x1f)
#define X_A(i) (((i) >> 29) & 1)
#define X_COND(i) (((i) >> 25) & 0xf)
#define X_OP2(i) (((i) >> 22) & 0x7)
#define X_IMM22(i) ((i) & 0x3fffff)
#define X_OP3(i) (((i) >> 19) & 0x3f)
#define X_RS1(i) (((i) >> 14) & 0x1f)
#define X_I(i) (((i) >> 13) & 1)
#define X_IMM13(i) ((i) & 0x1fff)
/* Sign extension macros.  */
#define X_SIMM13(i) ((X_IMM13 (i) ^ 0x1000) - 0x1000)
#define X_DISP22(i) ((X_IMM22 (i) ^ 0x200000) - 0x200000)
#define X_CC(i) (((i) >> 20) & 3)
#define X_P(i) (((i) >> 19) & 1)
#define X_DISP19(i) ((((i) & 0x7ffff) ^ 0x40000) - 0x40000)
#define X_RCOND(i) (((i) >> 25) & 7)
#define X_DISP16(i) ((((((i) >> 6) && 0xc000) | ((i) & 0x3fff)) ^ 0x8000) - 0x8000)
#define X_FCN(i) (((i) >> 25) & 31)

typedef enum
{
  Error, not_branch, bicc, bicca, ba, baa, ticc, ta, done_retry
} branch_type;

/* Simulate single-step ptrace call for sun4.  Code written by Gary
   Beihl (beihl@@mcc.com).  */

/* npc4 and next_pc describe the situation at the time that the
   step-breakpoint was set, not necessary the current value of DEPRECATED_NPC_REGNUM.  */
static CORE_ADDR next_pc, npc4, target;
static int brknpc4, brktrg;
typedef char binsn_quantum[BREAKPOINT_MAX];
static binsn_quantum break_mem[3];

static branch_type isbranch (long, CORE_ADDR, CORE_ADDR *);

/* single_step() is called just before we want to resume the inferior,
   if we want to single-step it but there is no hardware or kernel single-step
   support (as on all SPARCs).  We find all the possible targets of the
   coming instruction and breakpoint them.
d237 2
a238 2
   single_step is also called just after the inferior stops.  If we had
   set up a simulated single-step, we undo our damage.  */
d240 2
a241 3
void
sparc_software_single_step (enum target_signal ignore,	/* pid, but we don't need it */
			    int insert_breakpoints_p)
d243 2
a244 3
  branch_type br;
  CORE_ADDR pc;
  long pc_instruction;
d246 2
a247 5
  if (insert_breakpoints_p)
    {
      /* Always set breakpoint for NPC.  */
      next_pc = read_register (DEPRECATED_NPC_REGNUM);
      npc4 = next_pc + 4;	/* branch not taken */
d249 2
a250 2
      target_insert_breakpoint (next_pc, break_mem[0]);
      /* printf_unfiltered ("set break at %x\n",next_pc); */
d252 2
a253 4
      pc = read_register (PC_REGNUM);
      pc_instruction = fetch_instruction (pc);
      br = isbranch (pc_instruction, pc, &target);
      brknpc4 = brktrg = 0;
d255 2
a256 25
      if (br == bicca)
	{
	  /* Conditional annulled branch will either end up at
	     npc (if taken) or at npc+4 (if not taken).
	     Trap npc+4.  */
	  brknpc4 = 1;
	  target_insert_breakpoint (npc4, break_mem[1]);
	}
      else if (br == baa && target != next_pc)
	{
	  /* Unconditional annulled branch will always end up at
	     the target.  */
	  brktrg = 1;
	  target_insert_breakpoint (target, break_mem[2]);
	}
      else if (GDB_TARGET_IS_SPARC64 && br == done_retry)
	{
	  brktrg = 1;
	  target_insert_breakpoint (target, break_mem[2]);
	}
    }
  else
    {
      /* Remove breakpoints */
      target_remove_breakpoint (next_pc, break_mem[0]);
d258 11
a268 2
      if (brknpc4)
	target_remove_breakpoint (npc4, break_mem[1]);
d270 10
a279 3
      if (brktrg)
	target_remove_breakpoint (target, break_mem[2]);
    }
d282 7
a288 1
struct frame_extra_info 
d290 2
a291 10
  CORE_ADDR bottom;
  int in_prologue;
  int flat;
  /* Following fields only relevant for flat frames.  */
  CORE_ADDR pc_addr;
  CORE_ADDR fp_addr;
  /* Add this to ->frame to get the value of the stack pointer at the 
     time of the register saves.  */
  int sp_offset;
};
d293 3
a295 5
/* Call this for each newly created frame.  For SPARC, we need to
   calculate the bottom of the frame, and do some extra work if the
   prologue has been generated via the -mflat option to GCC.  In
   particular, we need to know where the previous fp and the pc have
   been stashed, since their exact position within the frame may vary.  */
d297 4
a300 45
void
sparc_init_extra_frame_info (int fromleaf, struct frame_info *fi)
{
  char *name;
  CORE_ADDR prologue_start, prologue_end;
  int insn;

  frame_extra_info_zalloc (fi, sizeof (struct frame_extra_info));
  frame_saved_regs_zalloc (fi);

  get_frame_extra_info (fi)->bottom =
    (get_next_frame (fi)
     ? (get_frame_base (fi) == get_frame_base (get_next_frame (fi))
	? get_frame_extra_info (get_next_frame (fi))->bottom
	: get_frame_base (get_next_frame (fi)))
     : read_sp ());

  /* If fi->next is NULL, then we already set ->frame by passing
     deprecated_read_fp() to create_new_frame.  */
  if (get_next_frame (fi))
    {
      char buf[MAX_REGISTER_SIZE];

      /* Compute ->frame as if not flat.  If it is flat, we'll change
         it later.  */
      if (get_next_frame (get_next_frame (fi)) != NULL
	  && ((get_frame_type (get_next_frame (get_next_frame (fi))) == SIGTRAMP_FRAME)
	      || deprecated_frame_in_dummy (get_next_frame (get_next_frame (fi))))
	  && frameless_look_for_prologue (get_next_frame (fi)))
	{
	  /* A frameless function interrupted by a signal did not change
	     the frame pointer, fix up frame pointer accordingly.  */
	  deprecated_update_frame_base_hack (fi, get_frame_base (get_next_frame (fi)));
	  get_frame_extra_info (fi)->bottom =
	    get_frame_extra_info (get_next_frame (fi))->bottom;
	}
      else
	{
	  /* Should we adjust for stack bias here? */
	  ULONGEST tmp;
	  tmp = get_frame_register_unsigned (fi, DEPRECATED_FP_REGNUM);
	  deprecated_update_frame_base_hack (fi, tmp);
	  if (GDB_TARGET_IS_SPARC64 && (get_frame_base (fi) & 1))
	    deprecated_update_frame_base_hack (fi, get_frame_base (fi) + 2047);
	}
d303 17
a319 24
  /* Decide whether this is a function with a ``flat register window''
     frame.  For such functions, the frame pointer is actually in %i7.  */
  get_frame_extra_info (fi)->flat = 0;
  get_frame_extra_info (fi)->in_prologue = 0;
  if (find_pc_partial_function (get_frame_pc (fi), &name, &prologue_start, &prologue_end))
    {
      /* See if the function starts with an add (which will be of a
         negative number if a flat frame) to the sp.  FIXME: Does not
         handle large frames which will need more than one instruction
         to adjust the sp.  */
      insn = fetch_instruction (prologue_start);
      if (X_OP (insn) == 2 && X_RD (insn) == 14 && X_OP3 (insn) == 0
	  && X_I (insn) && X_SIMM13 (insn) < 0)
	{
	  int offset = X_SIMM13 (insn);

	  /* Then look for a save of %i7 into the frame.  */
	  insn = fetch_instruction (prologue_start + 4);
	  if (X_OP (insn) == 3
	      && X_RD (insn) == 31
	      && X_OP3 (insn) == 4
	      && X_RS1 (insn) == 14)
	    {
	      char buf[MAX_REGISTER_SIZE];
d321 5
a325 2
	      /* We definitely have a flat frame now.  */
	      get_frame_extra_info (fi)->flat = 1;
d327 3
a329 1
	      get_frame_extra_info (fi)->sp_offset = offset;
d331 9
a339 24
	      /* Overwrite the frame's address with the value in %i7.  */
	      {
		ULONGEST tmp;
		tmp = get_frame_register_unsigned (fi, I7_REGNUM);
		deprecated_update_frame_base_hack (fi, tmp);
	      }

	      if (GDB_TARGET_IS_SPARC64 && (get_frame_base (fi) & 1))
		deprecated_update_frame_base_hack (fi, get_frame_base (fi) + 2047);

	      /* Record where the fp got saved.  */
	      get_frame_extra_info (fi)->fp_addr = 
		get_frame_base (fi) + get_frame_extra_info (fi)->sp_offset + X_SIMM13 (insn);

	      /* Also try to collect where the pc got saved to.  */
	      get_frame_extra_info (fi)->pc_addr = 0;
	      insn = fetch_instruction (prologue_start + 12);
	      if (X_OP (insn) == 3
		  && X_RD (insn) == 15
		  && X_OP3 (insn) == 4
		  && X_RS1 (insn) == 14)
		get_frame_extra_info (fi)->pc_addr = 
		  get_frame_base (fi) + get_frame_extra_info (fi)->sp_offset + X_SIMM13 (insn);
	    }
d343 6
a348 26
	  /* Check if the PC is in the function prologue before a SAVE
	     instruction has been executed yet.  If so, set the frame
	     to the current value of the stack pointer and set
	     the in_prologue flag.  */
	  CORE_ADDR addr;
	  struct symtab_and_line sal;

	  sal = find_pc_line (prologue_start, 0);
	  if (sal.line == 0)	/* no line info, use PC */
	    prologue_end = get_frame_pc (fi);
	  else if (sal.end < prologue_end)
	    prologue_end = sal.end;
	  if (get_frame_pc (fi) < prologue_end)
	    {
	      for (addr = prologue_start; addr < get_frame_pc (fi); addr += 4)
		{
		  insn = read_memory_integer (addr, 4);
		  if (X_OP (insn) == 2 && X_OP3 (insn) == 0x3c)
		    break;	/* SAVE seen, stop searching */
		}
	      if (addr >= get_frame_pc (fi))
		{
		  get_frame_extra_info (fi)->in_prologue = 1;
		  deprecated_update_frame_base_hack (fi, read_register (SP_REGNUM));
		}
	    }
d351 14
a364 1
  if (get_next_frame (fi) && get_frame_base (fi) == 0)
d366 5
a370 5
      /* Kludge to cause init_prev_frame_info to destroy the new frame.  */
      deprecated_update_frame_base_hack (fi, get_frame_base (get_next_frame (fi)));
      deprecated_update_frame_pc_hack (fi, get_frame_pc (get_next_frame (fi)));
    }
}
d372 3
a374 18
CORE_ADDR
sparc_frame_chain (struct frame_info *frame)
{
  /* Value that will cause DEPRECATED_FRAME_CHAIN_VALID to not worry
     about the chain value.  If it really is zero, we detect it later
     in sparc_init_prev_frame.
     
     Note: kevinb/2003-02-18: The constant 1 used to be returned here,
     but, after some recent changes to legacy_frame_chain_valid(),
     this value is no longer suitable for causing
     legacy_frame_chain_valid() to "not worry about the chain value."
     The constant ~0 (i.e, 0xfff...) causes the failing test in
     legacy_frame_chain_valid() to succeed thus preserving the "not
     worry" property.  I had considered using something like
     ``get_frame_base (frame) + 1''.  However, I think a constant
     value is better, because when debugging this problem, I knew that
     something funny was going on as soon as I saw the constant 1
     being used as the frame chain elsewhere in GDB.  */
d376 4
a379 2
  return ~ (CORE_ADDR) 0;
}
d381 4
a384 1
/* Find the pc saved in frame FRAME.  */
d386 1
a386 5
CORE_ADDR
sparc_frame_saved_pc (struct frame_info *frame)
{
  char buf[MAX_REGISTER_SIZE];
  CORE_ADDR addr;
d388 1
a388 1
  if ((get_frame_type (frame) == SIGTRAMP_FRAME))
d390 1
a390 2
      /* This is the signal trampoline frame.
         Get the saved PC from the sigcontext structure.  */
d392 3
a394 3
#ifndef SIGCONTEXT_PC_OFFSET
#define SIGCONTEXT_PC_OFFSET 12
#endif
d396 2
a397 4
      CORE_ADDR sigcontext_addr;
      char *scbuf;
      int saved_pc_offset = SIGCONTEXT_PC_OFFSET;
      char *name = NULL;
d399 14
a412 1
      scbuf = alloca (TARGET_PTR_BIT / HOST_CHAR_BIT);
d414 2
a415 6
      /* Solaris2 ucbsigvechandler passes a pointer to a sigcontext
         as the third parameter.  The offset to the saved pc is 12.  */
      find_pc_partial_function (get_frame_pc (frame), &name,
				(CORE_ADDR *) NULL, (CORE_ADDR *) NULL);
      if (name && DEPRECATED_STREQ (name, "ucbsigvechandler"))
	saved_pc_offset = 12;
d417 2
a418 30
      /* The sigcontext address is contained in register O2.  */
      {
	ULONGEST tmp;
	tmp = get_frame_register_unsigned (frame, O0_REGNUM + 2);
	sigcontext_addr = tmp;
      }

      /* Don't cause a memory_error when accessing sigcontext in case the
         stack layout has changed or the stack is corrupt.  */
      target_read_memory (sigcontext_addr + saved_pc_offset,
			  scbuf, sizeof (scbuf));
      return extract_unsigned_integer (scbuf, sizeof (scbuf));
    }
  else if (get_frame_extra_info (frame)->in_prologue ||
	   (get_next_frame (frame) != NULL &&
	    ((get_frame_type (get_next_frame (frame)) == SIGTRAMP_FRAME) ||
	     deprecated_frame_in_dummy (get_next_frame (frame))) &&
	    frameless_look_for_prologue (frame)))
    {
      /* A frameless function interrupted by a signal did not save
         the PC, it is still in %o7.  */
      ULONGEST tmp;
      tmp = get_frame_register_unsigned (frame, O7_REGNUM);
      return PC_ADJUST (tmp);
    }
  if (get_frame_extra_info (frame)->flat)
    addr = get_frame_extra_info (frame)->pc_addr;
  else
    addr = get_frame_extra_info (frame)->bottom + FRAME_SAVED_I0 +
      SPARC_INTREG_SIZE * (I7_REGNUM - I0_REGNUM);
d420 2
a421 4
  if (addr == 0)
    /* A flat frame leaf function might not save the PC anywhere,
       just leave it in %o7.  */
    return PC_ADJUST (read_register (O7_REGNUM));
d423 1
a423 2
  read_memory (addr, buf, SPARC_INTREG_SIZE);
  return PC_ADJUST (extract_unsigned_integer (buf, SPARC_INTREG_SIZE));
d425 1
d427 8
a434 10
/* Since an individual frame in the frame cache is defined by two
   arguments (a frame pointer and a stack pointer), we need two
   arguments to get info for an arbitrary stack frame.  This routine
   takes two arguments and makes the cached frames look as if these
   two arguments defined a frame on the cache.  This allows the rest
   of info frame to extract the important arguments without
   difficulty.  */

struct frame_info *
setup_arbitrary_frame (int argc, CORE_ADDR *argv)
d436 1
a436 1
  struct frame_info *frame;
d438 4
a441 2
  if (argc != 2)
    error ("Sparc frame specifications require two arguments: fp and sp");
d443 1
a443 1
  frame = create_new_frame (argv[0], 0);
d445 5
a449 3
  if (!frame)
    internal_error (__FILE__, __LINE__,
		    "create_new_frame returned invalid frame");
d451 1
a451 4
  get_frame_extra_info (frame)->bottom = argv[1];
  deprecated_update_frame_pc_hack (frame, DEPRECATED_FRAME_SAVED_PC (frame));
  return frame;
}
d453 3
a455 2
/* Given a pc value, skip it forward past the function prologue by
   disassembling instructions that appear to be a prologue.
d457 2
a458 2
   If FRAMELESS_P is set, we are only testing to see if the function
   is frameless.  This allows a quicker answer.
d460 1
a460 2
   This routine should be more specific in its actions; making sure
   that it uses the same register in the initial prologue section.  */
d462 2
a463 2
static CORE_ADDR examine_prologue (CORE_ADDR, int, struct frame_info *,
				   CORE_ADDR *);
d465 3
a467 3
static CORE_ADDR
examine_prologue (CORE_ADDR start_pc, int frameless_p, struct frame_info *fi,
		  CORE_ADDR *saved_regs)
d469 3
a471 1
  int insn;
a472 2
  CORE_ADDR pc = start_pc;
  int is_flat = 0;
d474 2
a475 1
  insn = fetch_instruction (pc);
d477 17
a493 2
  /* Recognize the `sethi' insn and record its destination.  */
  if (X_OP (insn) == 0 && X_OP2 (insn) == 4)
d496 3
a498 2
      pc += 4;
      insn = fetch_instruction (pc);
d501 2
a502 8
  /* Recognize an add immediate value to register to either %g1 or
     the destination register recorded above.  Actually, this might
     well recognize several different arithmetic operations.
     It doesn't check that rs1 == rd because in theory "sub %g0, 5, %g1"
     followed by "save %sp, %g1, %sp" is a valid prologue (Not that
     I imagine any compiler really does that, however).  */
  if (X_OP (insn) == 2
      && X_I (insn)
d505 1
a505 3
      pc += 4;
      insn = fetch_instruction (pc);
    }
d507 1
a507 39
  /* Recognize any SAVE insn.  */
  if (X_OP (insn) == 2 && X_OP3 (insn) == 60)
    {
      pc += 4;
      if (frameless_p)		/* If the save is all we care about, */
	return pc;		/* return before doing more work */
      insn = fetch_instruction (pc);
    }
  /* Recognize add to %sp.  */
  else if (X_OP (insn) == 2 && X_RD (insn) == 14 && X_OP3 (insn) == 0)
    {
      pc += 4;
      if (frameless_p)		/* If the add is all we care about, */
	return pc;		/* return before doing more work */
      is_flat = 1;
      insn = fetch_instruction (pc);
      /* Recognize store of frame pointer (i7).  */
      if (X_OP (insn) == 3
	  && X_RD (insn) == 31
	  && X_OP3 (insn) == 4
	  && X_RS1 (insn) == 14)
	{
	  pc += 4;
	  insn = fetch_instruction (pc);

	  /* Recognize sub %sp, <anything>, %i7.  */
	  if (X_OP (insn) == 2
	      && X_OP3 (insn) == 4
	      && X_RS1 (insn) == 14
	      && X_RD (insn) == 31)
	    {
	      pc += 4;
	      insn = fetch_instruction (pc);
	    }
	  else
	    return pc;
	}
      else
	return pc;
a508 3
  else
    /* Without a save or add instruction, it's not a prologue.  */
    return start_pc;
d510 2
a511 1
  while (1)
d513 2
a514 52
      /* Recognize stores into the frame from the input registers.
         This recognizes all non alternate stores of an input register,
         into a location offset from the frame pointer between
	 +68 and +92.  */

      /* The above will fail for arguments that are promoted 
	 (eg. shorts to ints or floats to doubles), because the compiler
	 will pass them in positive-offset frame space, but the prologue
	 will save them (after conversion) in negative frame space at an
	 unpredictable offset.  Therefore I am going to remove the 
	 restriction on the target-address of the save, on the theory
	 that any unbroken sequence of saves from input registers must
	 be part of the prologue.  In un-optimized code (at least), I'm
	 fairly sure that the compiler would emit SOME other instruction
	 (eg. a move or add) before emitting another save that is actually
	 a part of the function body.

	 Besides, the reserved stack space is different for SPARC64 anyway.

	 MVS  4/23/2000  */

      if (X_OP (insn) == 3
	  && (X_OP3 (insn) & 0x3c)	 == 4	/* Store, non-alternate.  */
	  && (X_RD (insn) & 0x18) == 0x18	/* Input register.  */
	  && X_I (insn)				/* Immediate mode.  */
	  && X_RS1 (insn) == 30)		/* Off of frame pointer.  */
	; /* empty statement -- fall thru to end of loop */
      else if (GDB_TARGET_IS_SPARC64
	       && X_OP (insn) == 3
	       && (X_OP3 (insn) & 0x3c) == 12	/* store, extended (64-bit) */
	       && (X_RD (insn) & 0x18) == 0x18	/* input register */
	       && X_I (insn)			/* immediate mode */
	       && X_RS1 (insn) == 30)		/* off of frame pointer */
	; /* empty statement -- fall thru to end of loop */
      else if (X_OP (insn) == 3
	       && (X_OP3 (insn) & 0x3c) == 36	/* store, floating-point */
	       && X_I (insn)			/* immediate mode */
	       && X_RS1 (insn) == 30)		/* off of frame pointer */
	; /* empty statement -- fall thru to end of loop */
      else if (is_flat
	       && X_OP (insn) == 3
	       && X_OP3 (insn) == 4		/* store? */
	       && X_RS1 (insn) == 14)		/* off of frame pointer */
	{
	  if (saved_regs && X_I (insn))
	    saved_regs[X_RD (insn)] =
	      get_frame_base (fi) + get_frame_extra_info (fi)->sp_offset + X_SIMM13 (insn);
	}
      else
	break;
      pc += 4;
      insn = fetch_instruction (pc);
d520 9
a528 2
/* Advance PC across any function entry prologue instructions to reach
   some "real" code.  */
d530 2
a531 2
CORE_ADDR
sparc_skip_prologue (CORE_ADDR start_pc)
d535 1
d548 1
a548 2
  /* Oh well, examine the code by hand.  */
  return examine_prologue (start_pc, 0, NULL, NULL);
d551 1
a551 1
/* Is the prologue at IP frameless?  */
d553 2
a554 2
int
sparc_prologue_frameless_p (CORE_ADDR ip)
d556 4
a559 2
  return ip == examine_prologue (ip, 1, NULL, NULL);
}
d561 2
a562 3
/* Check instruction at ADDR to see if it is a branch.
   All non-annulled instructions will go to NPC or will trap.
   Set *TARGET if we find a candidate branch; set to zero if not.
d564 3
a566 1
   This isn't static as it's used by remote-sa.sparc.c.  */
d568 3
a570 5
static branch_type
isbranch (long instruction, CORE_ADDR addr, CORE_ADDR *target)
{
  branch_type val = not_branch;
  long int offset = 0;		/* Must be signed for sign-extend.  */
d572 6
a577 1
  *target = 0;
d579 1
a579 7
  if (X_OP (instruction) == 0
      && (X_OP2 (instruction) == 2
	  || X_OP2 (instruction) == 6
	  || X_OP2 (instruction) == 1
	  || X_OP2 (instruction) == 3
	  || X_OP2 (instruction) == 5
	  || (GDB_TARGET_IS_SPARC64 && X_OP2 (instruction) == 7)))
d581 4
a584 40
      if (X_COND (instruction) == 8)
	val = X_A (instruction) ? baa : ba;
      else
	val = X_A (instruction) ? bicca : bicc;
      switch (X_OP2 (instruction))
	{
	case 7:
	if (!GDB_TARGET_IS_SPARC64)
	  break;
	/* else fall thru */
	case 2:
	case 6:
	  offset = 4 * X_DISP22 (instruction);
	  break;
	case 1:
	case 5:
	  offset = 4 * X_DISP19 (instruction);
	  break;
	case 3:
	  offset = 4 * X_DISP16 (instruction);
	  break;
	}
      *target = addr + offset;
    }
  else if (GDB_TARGET_IS_SPARC64
	   && X_OP (instruction) == 2
	   && X_OP3 (instruction) == 62)
    {
      if (X_FCN (instruction) == 0)
	{
	  /* done */
	  *target = read_register (TNPC_REGNUM);
	  val = done_retry;
	}
      else if (X_FCN (instruction) == 1)
	{
	  /* retry */
	  *target = read_register (TPC_REGNUM);
	  val = done_retry;
	}
d587 1
a587 1
  return val;
a588 8

/* Find register number REGNUM relative to FRAME and put its
   (raw) contents in *RAW_BUFFER.  Set *OPTIMIZED if the variable
   was optimized out (and thus can't be fetched).  If the variable
   was fetched from memory, set *ADDRP to where it was fetched from,
   otherwise it was fetched from a register.

   The argument RAW_BUFFER must point to aligned memory.  */
d590 2
a591 4
void
sparc_get_saved_register (char *raw_buffer, int *optimized, CORE_ADDR *addrp,
			  struct frame_info *frame, int regnum,
			  enum lval_type *lval)
d593 2
a594 5
  struct frame_info *frame1;
  CORE_ADDR addr;

  if (!target_has_registers)
    error ("No registers.");
d596 2
a597 2
  if (optimized)
    *optimized = 0;
d599 1
a599 1
  addr = 0;
d601 2
a602 2
  /* FIXME This code extracted from infcmd.c; should put elsewhere! */
  if (frame == NULL)
d604 2
a605 10
      /* error ("No selected frame."); */
      if (!target_has_registers)
	error ("The program has no registers now.");
      if (deprecated_selected_frame == NULL)
	error ("No selected frame.");
      /* Try to use selected frame */
      frame = get_prev_frame (deprecated_selected_frame);
      if (frame == 0)
	error ("Cmd not meaningful in the outermost frame.");
    }
d607 1
a607 9

  frame1 = get_next_frame (frame);

  /* Get saved PC from the frame info if not in innermost frame.  */
  if (regnum == PC_REGNUM && frame1 != NULL)
    {
      if (lval != NULL)
	*lval = not_lval;
      if (raw_buffer != NULL)
d609 4
a612 2
	  /* Put it back in target format.  */
	  store_unsigned_integer (raw_buffer, DEPRECATED_REGISTER_RAW_SIZE (regnum), get_frame_pc (frame));
a613 3
      if (addrp != NULL)
	*addrp = 0;
      return;
d616 9
a624 3
  while (frame1 != NULL)
    {
      /* FIXME MVS: wrong test for dummy frame at entry.  */
d626 3
a628 55
      if (get_frame_pc (frame1) >= (get_frame_extra_info (frame1)->bottom
				    ? get_frame_extra_info (frame1)->bottom
				    : read_sp ())
	  && get_frame_pc (frame1) <= get_frame_base (frame1))
	{
	  /* Dummy frame.  All but the window regs are in there somewhere.
	     The window registers are saved on the stack, just like in a
	     normal frame.  */
	  if (regnum >= G1_REGNUM && regnum < G1_REGNUM + 7)
	    addr = get_frame_base (frame1) + (regnum - G0_REGNUM) * SPARC_INTREG_SIZE
	      - (FP_REGISTER_BYTES + 8 * SPARC_INTREG_SIZE);
	  else if (regnum >= I0_REGNUM && regnum < I0_REGNUM + 8)
	    /* NOTE: cagney/2002-05-04: The call to get_prev_frame()
               is safe/cheap - there will always be a prev frame.
               This is because frame1 is initialized to frame->next
               (frame1->prev == frame) and is then advanced towards
               the innermost (next) frame.  */
	    addr = (get_frame_extra_info (get_prev_frame (frame1))->bottom
		    + (regnum - I0_REGNUM) * SPARC_INTREG_SIZE
		    + FRAME_SAVED_I0);
	  else if (regnum >= L0_REGNUM && regnum < L0_REGNUM + 8)
	    /* NOTE: cagney/2002-05-04: The call to get_prev_frame()
               is safe/cheap - there will always be a prev frame.
               This is because frame1 is initialized to frame->next
               (frame1->prev == frame) and is then advanced towards
               the innermost (next) frame.  */
	    addr = (get_frame_extra_info (get_prev_frame (frame1))->bottom
		    + (regnum - L0_REGNUM) * SPARC_INTREG_SIZE
		    + FRAME_SAVED_L0);
	  else if (regnum >= O0_REGNUM && regnum < O0_REGNUM + 8)
	    addr = get_frame_base (frame1) + (regnum - O0_REGNUM) * SPARC_INTREG_SIZE
	      - (FP_REGISTER_BYTES + 16 * SPARC_INTREG_SIZE);
	  else if (SPARC_HAS_FPU &&
		   regnum >= FP0_REGNUM && regnum < FP0_REGNUM + 32)
	    addr = get_frame_base (frame1) + (regnum - FP0_REGNUM) * 4
	      - (FP_REGISTER_BYTES);
	  else if (GDB_TARGET_IS_SPARC64 && SPARC_HAS_FPU && 
		   regnum >= FP0_REGNUM + 32 && regnum < FP_MAX_REGNUM)
	    addr = get_frame_base (frame1) + 32 * 4 + (regnum - FP0_REGNUM - 32) * 8
	      - (FP_REGISTER_BYTES);
	  else if (regnum >= Y_REGNUM && regnum < NUM_REGS)
	    addr = get_frame_base (frame1) + (regnum - Y_REGNUM) * SPARC_INTREG_SIZE
	      - (FP_REGISTER_BYTES + 24 * SPARC_INTREG_SIZE);
	}
      else if (get_frame_extra_info (frame1)->flat)
	{

	  if (regnum == RP_REGNUM)
	    addr = get_frame_extra_info (frame1)->pc_addr;
	  else if (regnum == I7_REGNUM)
	    addr = get_frame_extra_info (frame1)->fp_addr;
	  else
	    {
	      CORE_ADDR func_start;
	      CORE_ADDR *regs;
d630 2
a631 2
	      regs = alloca (NUM_REGS * sizeof (CORE_ADDR)); 
	      memset (regs, 0, NUM_REGS * sizeof (CORE_ADDR));
d633 28
a660 4
	      find_pc_partial_function (get_frame_pc (frame1), NULL, &func_start, NULL);
	      examine_prologue (func_start, 0, frame1, regs);
	      addr = regs[regnum];
	    }
d662 1
a662 23
      else
	{
	  /* Normal frame.  Local and In registers are saved on stack.  */
	  if (regnum >= I0_REGNUM && regnum < I0_REGNUM + 8)
	    addr = (get_frame_extra_info (get_prev_frame (frame1))->bottom
		    + (regnum - I0_REGNUM) * SPARC_INTREG_SIZE
		    + FRAME_SAVED_I0);
	  else if (regnum >= L0_REGNUM && regnum < L0_REGNUM + 8)
	    addr = (get_frame_extra_info (get_prev_frame (frame1))->bottom
		    + (regnum - L0_REGNUM) * SPARC_INTREG_SIZE
		    + FRAME_SAVED_L0);
	  else if (regnum >= O0_REGNUM && regnum < O0_REGNUM + 8)
	    {
	      /* Outs become ins.  */
	      int realnum;
	      frame_register (frame1, (regnum - O0_REGNUM + I0_REGNUM),
			      optimized, lval, addrp, &realnum, raw_buffer);
	      return;
	    }
	}
      if (addr != 0)
	break;
      frame1 = get_next_frame (frame1);
d664 11
a674 5
  if (addr != 0)
    {
      if (lval != NULL)
	*lval = lval_memory;
      if (regnum == SP_REGNUM)
d676 4
a679 8
	  if (raw_buffer != NULL)
	    {
	      /* Put it back in target format.  */
	      store_unsigned_integer (raw_buffer, DEPRECATED_REGISTER_RAW_SIZE (regnum), addr);
	    }
	  if (addrp != NULL)
	    *addrp = 0;
	  return;
d681 1
a681 10
      if (raw_buffer != NULL)
	read_memory (addr, raw_buffer, DEPRECATED_REGISTER_RAW_SIZE (regnum));
    }
  else
    {
      if (lval != NULL)
	*lval = lval_register;
      addr = DEPRECATED_REGISTER_BYTE (regnum);
      if (raw_buffer != NULL)
	deprecated_read_register_gen (regnum, raw_buffer);
a682 3
  if (addrp != NULL)
    *addrp = addr;
}
d684 5
a688 1
/* Push an empty stack frame, and record in it the current PC, regs, etc.
d690 3
a692 3
   We save the non-windowed registers and the ins.  The locals and outs
   are new; they don't need to be saved. The i's and l's of
   the last frame were already saved on the stack.  */
d694 19
a712 1
/* Definitely see tm-sparc.h for more doc of the frame format here.  */
d714 2
a715 1
/* See tm-sparc.h for how this is calculated.  */
d717 7
a723 4
#define DUMMY_STACK_REG_BUF_SIZE \
     (((8+8+8) * SPARC_INTREG_SIZE) + FP_REGISTER_BYTES)
#define DUMMY_STACK_SIZE \
     (DUMMY_STACK_REG_BUF_SIZE + DUMMY_REG_SAVE_OFFSET)
d725 2
a726 2
void
sparc_push_dummy_frame (void)
d728 9
a736 2
  CORE_ADDR sp, old_sp;
  char *register_temp;
d738 6
a743 1
  register_temp = alloca (DUMMY_STACK_SIZE);
d745 2
a746 1
  old_sp = sp = read_sp ();
d748 1
a748 1
  if (GDB_TARGET_IS_SPARC64)
d750 5
a754 8
      /* PC, NPC, CCR, FSR, FPRS, Y, ASI */
      deprecated_read_register_bytes (DEPRECATED_REGISTER_BYTE (PC_REGNUM),
				      &register_temp[0],
				      DEPRECATED_REGISTER_RAW_SIZE (PC_REGNUM) * 7);
      deprecated_read_register_bytes (DEPRECATED_REGISTER_BYTE (PSTATE_REGNUM), 
				      &register_temp[7 * SPARC_INTREG_SIZE],
				      DEPRECATED_REGISTER_RAW_SIZE (PSTATE_REGNUM));
      /* FIXME: not sure what needs to be saved here.  */
d758 9
a766 42
      /* Y, PS, WIM, TBR, PC, NPC, FPS, CPS regs */
      deprecated_read_register_bytes (DEPRECATED_REGISTER_BYTE (Y_REGNUM),
				      &register_temp[0],
				      DEPRECATED_REGISTER_RAW_SIZE (Y_REGNUM) * 8);
    }

  deprecated_read_register_bytes (DEPRECATED_REGISTER_BYTE (O0_REGNUM),
				  &register_temp[8 * SPARC_INTREG_SIZE],
				  SPARC_INTREG_SIZE * 8);

  deprecated_read_register_bytes (DEPRECATED_REGISTER_BYTE (G0_REGNUM),
				  &register_temp[16 * SPARC_INTREG_SIZE],
				  SPARC_INTREG_SIZE * 8);

  if (SPARC_HAS_FPU)
    deprecated_read_register_bytes (DEPRECATED_REGISTER_BYTE (FP0_REGNUM),
				    &register_temp[24 * SPARC_INTREG_SIZE],
				    FP_REGISTER_BYTES);

  sp -= DUMMY_STACK_SIZE;

  DEPRECATED_DUMMY_WRITE_SP (sp);

  write_memory (sp + DUMMY_REG_SAVE_OFFSET, &register_temp[0],
		DUMMY_STACK_REG_BUF_SIZE);

  if (strcmp (target_shortname, "sim") != 0)
    {
      /* NOTE: cagney/2002-04-04: The code below originally contained
         GDB's _only_ call to write_fp().  That call was eliminated by
         inlining the corresponding code.  For the 64 bit case, the
         old function (sparc64_write_fp) did the below although I'm
         not clear why.  The same goes for why this is only done when
         the underlying target is a simulator.  */
      if (GDB_TARGET_IS_SPARC64)
	{
	  /* Target is a 64 bit SPARC.  */
	  CORE_ADDR oldfp = read_register (DEPRECATED_FP_REGNUM);
	  if (oldfp & 1)
	    write_register (DEPRECATED_FP_REGNUM, old_sp - 2047);
	  else
	    write_register (DEPRECATED_FP_REGNUM, old_sp);
d770 3
a772 2
	  /* Target is a 32 bit SPARC.  */
	  write_register (DEPRECATED_FP_REGNUM, old_sp);
a773 21
      /* Set return address register for the call dummy to the current PC.  */
      write_register (I7_REGNUM, read_pc () - 8);
    }
  else
    {
      /* The call dummy will write this value to FP before executing
         the 'save'.  This ensures that register window flushes work
         correctly in the simulator.  */
      write_register (G0_REGNUM + 1, read_register (DEPRECATED_FP_REGNUM));

      /* The call dummy will write this value to FP after executing
         the 'save'. */
      write_register (G0_REGNUM + 2, old_sp);

      /* The call dummy will write this value to the return address (%i7) after
         executing the 'save'. */
      write_register (G0_REGNUM + 3, read_pc () - 8);

      /* Set the FP that the call dummy will be using after the 'save'.
         This makes backtraces from an inferior function call work properly.  */
      write_register (DEPRECATED_FP_REGNUM, old_sp);
d777 2
a778 35
/* sparc_frame_find_saved_regs ().  This function is here only because
   pop_frame uses it.  Note there is an interesting corner case which
   I think few ports of GDB get right--if you are popping a frame
   which does not save some register that *is* saved by a more inner
   frame (such a frame will never be a dummy frame because dummy
   frames save all registers).

   NOTE: cagney/2003-03-12: Since pop_frame has been rewritten to use
   frame_unwind_register() the need for this function is questionable.

   Stores, into an array of CORE_ADDR, 
   the addresses of the saved registers of frame described by FRAME_INFO.
   This includes special registers such as pc and fp saved in special
   ways in the stack frame.  sp is even more special:
   the address we return for it IS the sp for the next frame.

   Note that on register window machines, we are currently making the
   assumption that window registers are being saved somewhere in the
   frame in which they are being used.  If they are stored in an
   inferior frame, find_saved_register will break.

   On the Sun 4, the only time all registers are saved is when
   a dummy frame is involved.  Otherwise, the only saved registers
   are the LOCAL and IN registers which are saved as a result
   of the "save/restore" opcodes.  This condition is determined
   by address rather than by value.

   The "pc" is not stored in a frame on the SPARC.  (What is stored
   is a return address minus 8.)  sparc_pop_frame knows how to
   deal with that.  Other routines might or might not.

   See tm-sparc.h (PUSH_DUMMY_FRAME and friends) for CRITICAL information
   about how this works.  */

static void sparc_frame_find_saved_regs (struct frame_info *, CORE_ADDR *);
d781 2
a782 1
sparc_frame_find_saved_regs (struct frame_info *fi, CORE_ADDR *saved_regs_addr)
d784 2
a785 2
  int regnum;
  CORE_ADDR frame_addr = get_frame_base (fi);
d787 2
a788 1
  gdb_assert (fi != NULL);
d790 1
a790 6
  memset (saved_regs_addr, 0, NUM_REGS * sizeof (CORE_ADDR));

  if (get_frame_pc (fi) >= (get_frame_extra_info (fi)->bottom
			    ? get_frame_extra_info (fi)->bottom
			    : read_sp ())
      && get_frame_pc (fi) <= get_frame_base (fi))
d792 5
a796 46
      /* Dummy frame.  All but the window regs are in there somewhere. */
      for (regnum = G1_REGNUM; regnum < G1_REGNUM + 7; regnum++)
	saved_regs_addr[regnum] =
	  frame_addr + (regnum - G0_REGNUM) * SPARC_INTREG_SIZE
	  - DUMMY_STACK_REG_BUF_SIZE + 16 * SPARC_INTREG_SIZE;

      for (regnum = I0_REGNUM; regnum < I0_REGNUM + 8; regnum++)
	saved_regs_addr[regnum] =
	  frame_addr + (regnum - I0_REGNUM) * SPARC_INTREG_SIZE
	  - DUMMY_STACK_REG_BUF_SIZE + 8 * SPARC_INTREG_SIZE;

      if (SPARC_HAS_FPU)
	for (regnum = FP0_REGNUM; regnum < FP_MAX_REGNUM; regnum++)
	  saved_regs_addr[regnum] = frame_addr + (regnum - FP0_REGNUM) * 4
	    - DUMMY_STACK_REG_BUF_SIZE + 24 * SPARC_INTREG_SIZE;

      if (GDB_TARGET_IS_SPARC64)
	{
	  for (regnum = PC_REGNUM; regnum < PC_REGNUM + 7; regnum++)
	    {
	      saved_regs_addr[regnum] =
		frame_addr + (regnum - PC_REGNUM) * SPARC_INTREG_SIZE
		- DUMMY_STACK_REG_BUF_SIZE;
	    }
	  saved_regs_addr[PSTATE_REGNUM] =
	    frame_addr + 8 * SPARC_INTREG_SIZE - DUMMY_STACK_REG_BUF_SIZE;
	}
      else
	for (regnum = Y_REGNUM; regnum < NUM_REGS; regnum++)
	  saved_regs_addr[regnum] =
	    frame_addr + (regnum - Y_REGNUM) * SPARC_INTREG_SIZE
	    - DUMMY_STACK_REG_BUF_SIZE;

      frame_addr = (get_frame_extra_info (fi)->bottom
		    ? get_frame_extra_info (fi)->bottom
		    : read_sp ());
    }
  else if (get_frame_extra_info (fi)->flat)
    {
      CORE_ADDR func_start;
      find_pc_partial_function (get_frame_pc (fi), NULL, &func_start, NULL);
      examine_prologue (func_start, 0, fi, saved_regs_addr);

      /* Flat register window frame.  */
      saved_regs_addr[RP_REGNUM] = get_frame_extra_info (fi)->pc_addr;
      saved_regs_addr[I7_REGNUM] = get_frame_extra_info (fi)->fp_addr;
d800 2
a801 61
      /* Normal frame.  Just Local and In registers */
      frame_addr = (get_frame_extra_info (fi)->bottom
		    ? get_frame_extra_info (fi)->bottom
		    : read_sp ());
      for (regnum = L0_REGNUM; regnum < L0_REGNUM + 8; regnum++)
	saved_regs_addr[regnum] =
	  (frame_addr + (regnum - L0_REGNUM) * SPARC_INTREG_SIZE
	   + FRAME_SAVED_L0);
      for (regnum = I0_REGNUM; regnum < I0_REGNUM + 8; regnum++)
	saved_regs_addr[regnum] =
	  (frame_addr + (regnum - I0_REGNUM) * SPARC_INTREG_SIZE
	   + FRAME_SAVED_I0);
    }
  if (get_next_frame (fi))
    {
      if (get_frame_extra_info (fi)->flat)
	{
	  saved_regs_addr[O7_REGNUM] = get_frame_extra_info (fi)->pc_addr;
	}
      else
	{
	  /* Pull off either the next frame pointer or the stack pointer */
	  CORE_ADDR next_next_frame_addr =
	  (get_frame_extra_info (get_next_frame (fi))->bottom
	   ? get_frame_extra_info (get_next_frame (fi))->bottom
	   : read_sp ());
	  for (regnum = O0_REGNUM; regnum < O0_REGNUM + 8; regnum++)
	    saved_regs_addr[regnum] =
	      (next_next_frame_addr
	       + (regnum - O0_REGNUM) * SPARC_INTREG_SIZE
	       + FRAME_SAVED_I0);
	}
    }
  /* Otherwise, whatever we would get from ptrace(GETREGS) is accurate */
  /* FIXME -- should this adjust for the sparc64 offset? */
  saved_regs_addr[SP_REGNUM] = get_frame_base (fi);
}

/* Discard from the stack the innermost frame, restoring all saved registers.

   Note that the values stored in fsr by
   deprecated_get_frame_saved_regs are *in the context of the called
   frame*.  What this means is that the i regs of fsr must be restored
   into the o regs of the (calling) frame that we pop into.  We don't
   care about the output regs of the calling frame, since unless it's
   a dummy frame, it won't have any output regs in it.

   We never have to bother with %l (local) regs, since the called routine's
   locals get tossed, and the calling routine's locals are already saved
   on its stack.  */

/* Definitely see tm-sparc.h for more doc of the frame format here.  */

void
sparc_pop_frame (void)
{
  struct frame_info *frame = get_current_frame ();
  CORE_ADDR pc;
  CORE_ADDR *fsr;
  char *raw_buffer;
  int regnum;
d803 1
a803 12
  fsr = alloca (NUM_REGS * sizeof (CORE_ADDR));
  raw_buffer = alloca (DEPRECATED_REGISTER_BYTES);
  sparc_frame_find_saved_regs (frame, &fsr[0]);
  if (SPARC_HAS_FPU)
    {
      if (fsr[FP0_REGNUM])
	{
	  read_memory (fsr[FP0_REGNUM], raw_buffer, FP_REGISTER_BYTES);
	  deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (FP0_REGNUM),
					   raw_buffer, FP_REGISTER_BYTES);
	}
      if (!(GDB_TARGET_IS_SPARC64))
d805 3
a807 10
	  if (fsr[FPS_REGNUM])
	    {
	      read_memory (fsr[FPS_REGNUM], raw_buffer, SPARC_INTREG_SIZE);
	      deprecated_write_register_gen (FPS_REGNUM, raw_buffer);
	    }
	  if (fsr[CPS_REGNUM])
	    {
	      read_memory (fsr[CPS_REGNUM], raw_buffer, SPARC_INTREG_SIZE);
	      deprecated_write_register_gen (CPS_REGNUM, raw_buffer);
	    }
a808 91
    }
  if (fsr[G1_REGNUM])
    {
      read_memory (fsr[G1_REGNUM], raw_buffer, 7 * SPARC_INTREG_SIZE);
      deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (G1_REGNUM), raw_buffer,
				       7 * SPARC_INTREG_SIZE);
    }

  if (get_frame_extra_info (frame)->flat)
    {
      /* Each register might or might not have been saved, need to test
         individually.  */
      for (regnum = L0_REGNUM; regnum < L0_REGNUM + 8; ++regnum)
	if (fsr[regnum])
	  write_register (regnum, read_memory_integer (fsr[regnum],
						       SPARC_INTREG_SIZE));
      for (regnum = I0_REGNUM; regnum < I0_REGNUM + 8; ++regnum)
	if (fsr[regnum])
	  write_register (regnum, read_memory_integer (fsr[regnum],
						       SPARC_INTREG_SIZE));

      /* Handle all outs except stack pointer (o0-o5; o7).  */
      for (regnum = O0_REGNUM; regnum < O0_REGNUM + 6; ++regnum)
	if (fsr[regnum])
	  write_register (regnum, read_memory_integer (fsr[regnum],
						       SPARC_INTREG_SIZE));
      if (fsr[O0_REGNUM + 7])
	write_register (O0_REGNUM + 7,
			read_memory_integer (fsr[O0_REGNUM + 7],
					     SPARC_INTREG_SIZE));

      DEPRECATED_DUMMY_WRITE_SP (get_frame_base (frame));
    }
  else if (fsr[I0_REGNUM])
    {
      CORE_ADDR sp;

      char *reg_temp;

      reg_temp = alloca (SPARC_INTREG_SIZE * 16);

      read_memory (fsr[I0_REGNUM], raw_buffer, 8 * SPARC_INTREG_SIZE);

      /* Get the ins and locals which we are about to restore.  Just
         moving the stack pointer is all that is really needed, except
         store_inferior_registers is then going to write the ins and
         locals from the registers array, so we need to muck with the
         registers array.  */
      sp = fsr[SP_REGNUM];
 
      if (GDB_TARGET_IS_SPARC64 && (sp & 1))
	sp += 2047;

      read_memory (sp, reg_temp, SPARC_INTREG_SIZE * 16);

      /* Restore the out registers.
         Among other things this writes the new stack pointer.  */
      deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (O0_REGNUM), raw_buffer,
				       SPARC_INTREG_SIZE * 8);

      deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (L0_REGNUM), reg_temp,
				       SPARC_INTREG_SIZE * 16);
    }

  if (!(GDB_TARGET_IS_SPARC64))
    if (fsr[PS_REGNUM])
      write_register (PS_REGNUM, 
		      read_memory_integer (fsr[PS_REGNUM], 
					   DEPRECATED_REGISTER_RAW_SIZE (PS_REGNUM)));

  if (fsr[Y_REGNUM])
    write_register (Y_REGNUM, 
		    read_memory_integer (fsr[Y_REGNUM], 
					 DEPRECATED_REGISTER_RAW_SIZE (Y_REGNUM)));
  if (fsr[PC_REGNUM])
    {
      /* Explicitly specified PC (and maybe NPC) -- just restore them. */
      write_register (PC_REGNUM, 
		      read_memory_integer (fsr[PC_REGNUM],
					   DEPRECATED_REGISTER_RAW_SIZE (PC_REGNUM)));
      if (fsr[DEPRECATED_NPC_REGNUM])
	write_register (DEPRECATED_NPC_REGNUM,
			read_memory_integer (fsr[DEPRECATED_NPC_REGNUM],
					     DEPRECATED_REGISTER_RAW_SIZE (DEPRECATED_NPC_REGNUM)));
    }
  else if (get_frame_extra_info (frame)->flat)
    {
      if (get_frame_extra_info (frame)->pc_addr)
	pc = PC_ADJUST ((CORE_ADDR)
			read_memory_integer (get_frame_extra_info (frame)->pc_addr,
					     DEPRECATED_REGISTER_RAW_SIZE (PC_REGNUM)));
d811 2
a812 6
	  /* I think this happens only in the innermost frame, if so then
	     it is a complicated way of saying
	     "pc = read_register (O7_REGNUM);".  */
	  ULONGEST tmp;
	  tmp = get_frame_register_unsigned (frame, O7_REGNUM);
	  pc = PC_ADJUST (tmp);
d814 1
a814 3

      write_register (PC_REGNUM, pc);
      write_register (DEPRECATED_NPC_REGNUM, pc + 4);
a815 9
  else if (fsr[I7_REGNUM])
    {
      /* Return address in %i7 -- adjust it, then restore PC and NPC from it */
      pc = PC_ADJUST ((CORE_ADDR) read_memory_integer (fsr[I7_REGNUM],
						       SPARC_INTREG_SIZE));
      write_register (PC_REGNUM, pc);
      write_register (DEPRECATED_NPC_REGNUM, pc + 4);
    }
  flush_cached_frames ();
d818 3
a820 3
/* On the Sun 4 under SunOS, the compile will leave a fake insn which
   encodes the structure size being returned.  If we detect such
   a fake insn, step past it.  */
d822 2
a823 2
CORE_ADDR
sparc_pc_adjust (CORE_ADDR pc)
d825 1
a825 3
  unsigned long insn;
  char buf[4];
  int err;
d827 2
a828 6
  err = target_read_memory (pc + 8, buf, 4);
  insn = extract_unsigned_integer (buf, 4);
  if ((err == 0) && (insn & 0xffc00000) == 0)
    return pc + 12;
  else
    return pc + 8;
d831 6
a836 11
/* If pc is in a shared library trampoline, return its target.
   The SunOs 4.x linker rewrites the jump table entries for PIC
   compiled modules in the main executable to bypass the dynamic linker
   with jumps of the form
   sethi %hi(addr),%g1
   jmp %g1+%lo(addr)
   and removes the corresponding jump table relocation entry in the
   dynamic relocations.
   find_solib_trampoline_target relies on the presence of the jump
   table relocation entry, so we have to detect these jump instructions
   by hand.  */
d838 2
a839 2
CORE_ADDR
sunos4_skip_trampoline_code (CORE_ADDR pc)
d841 3
a843 3
  unsigned long insn1;
  char buf[4];
  int err;
d845 6
a850 12
  err = target_read_memory (pc, buf, 4);
  insn1 = extract_unsigned_integer (buf, 4);
  if (err == 0 && (insn1 & 0xffc00000) == 0x03000000)
    {
      unsigned long insn2;

      err = target_read_memory (pc + 4, buf, 4);
      insn2 = extract_unsigned_integer (buf, 4);
      if (err == 0 && (insn2 & 0xffffe000) == 0x81c06000)
	{
	  CORE_ADDR target_pc = (insn1 & 0x3fffff) << 10;
	  int delta = insn2 & 0x1fff;
a851 8
	  /* Sign extend the displacement.  */
	  if (delta & 0x1000)
	    delta |= ~0x1fff;
	  return target_pc + delta;
	}
    }
  return find_solib_trampoline_target (pc);
}
d853 3
a855 42
#ifdef USE_PROC_FS		/* Target dependent support for /proc */
/* *INDENT-OFF* */
/*  The /proc interface divides the target machine's register set up into
    two different sets, the general register set (gregset) and the floating
    point register set (fpregset).  For each set, there is an ioctl to get
    the current register set and another ioctl to set the current values.

    The actual structure passed through the ioctl interface is, of course,
    naturally machine dependent, and is different for each set of registers.
    For the sparc for example, the general register set is typically defined
    by:

	typedef int gregset_t[38];

	#define	R_G0	0
	...
	#define	R_TBR	37

    and the floating point set by:

	typedef struct prfpregset {
		union { 
			u_long  pr_regs[32]; 
			double  pr_dregs[16];
		} pr_fr;
		void *  pr_filler;
		u_long  pr_fsr;
		u_char  pr_qcnt;
		u_char  pr_q_entrysize;
		u_char  pr_en;
		u_long  pr_q[64];
	} prfpregset_t;

    These routines provide the packing and unpacking of gregset_t and
    fpregset_t formatted data.

 */
/* *INDENT-ON* */

/* Given a pointer to a general register set in /proc format (gregset_t *),
   unpack the register contents and supply them as gdb's idea of the current
   register values. */
d857 2
a858 2
void
supply_gregset (gdb_gregset_t *gregsetp)
d860 4
a863 2
  prgreg_t *regp = (prgreg_t *) gregsetp;
  int regi, offset = 0;
d865 5
a869 108
  /* If the host is 64-bit sparc, but the target is 32-bit sparc, 
     then the gregset may contain 64-bit ints while supply_register
     is expecting 32-bit ints.  Compensate.  */
  if (sizeof (regp[0]) == 8 && SPARC_INTREG_SIZE == 4)
    offset = 4;

  /* GDB register numbers for Gn, On, Ln, In all match /proc reg numbers.  */
  /* FIXME MVS: assumes the order of the first 32 elements... */
  for (regi = G0_REGNUM; regi <= I7_REGNUM; regi++)
    {
      supply_register (regi, ((char *) (regp + regi)) + offset);
    }

  /* These require a bit more care.  */
  supply_register (PC_REGNUM, ((char *) (regp + R_PC)) + offset);
  supply_register (DEPRECATED_NPC_REGNUM, ((char *) (regp + R_nPC)) + offset);
  supply_register (Y_REGNUM, ((char *) (regp + R_Y)) + offset);

  if (GDB_TARGET_IS_SPARC64)
    {
#ifdef R_CCR
      supply_register (CCR_REGNUM, ((char *) (regp + R_CCR)) + offset);
#else
      supply_register (CCR_REGNUM, NULL);
#endif
#ifdef R_FPRS
      supply_register (FPRS_REGNUM, ((char *) (regp + R_FPRS)) + offset);
#else
      supply_register (FPRS_REGNUM, NULL);
#endif
#ifdef R_ASI
      supply_register (ASI_REGNUM, ((char *) (regp + R_ASI)) + offset);
#else
      supply_register (ASI_REGNUM, NULL);
#endif
    }
  else	/* sparc32 */
    {
#ifdef R_PS
      supply_register (PS_REGNUM, ((char *) (regp + R_PS)) + offset);
#else
      supply_register (PS_REGNUM, NULL);
#endif

      /* For 64-bit hosts, R_WIM and R_TBR may not be defined.
	 Steal R_ASI and R_FPRS, and hope for the best!  */

#if !defined (R_WIM) && defined (R_ASI)
#define R_WIM R_ASI
#endif

#if !defined (R_TBR) && defined (R_FPRS)
#define R_TBR R_FPRS
#endif

#if defined (R_WIM)
      supply_register (WIM_REGNUM, ((char *) (regp + R_WIM)) + offset);
#else
      supply_register (WIM_REGNUM, NULL);
#endif

#if defined (R_TBR)
      supply_register (TBR_REGNUM, ((char *) (regp + R_TBR)) + offset);
#else
      supply_register (TBR_REGNUM, NULL);
#endif
    }

  /* Fill inaccessible registers with zero.  */
  if (GDB_TARGET_IS_SPARC64)
    {
      /*
       * don't know how to get value of any of the following:
       */
      supply_register (VER_REGNUM, NULL);
      supply_register (TICK_REGNUM, NULL);
      supply_register (PIL_REGNUM, NULL);
      supply_register (PSTATE_REGNUM, NULL);
      supply_register (TSTATE_REGNUM, NULL);
      supply_register (TBA_REGNUM, NULL);
      supply_register (TL_REGNUM, NULL);
      supply_register (TT_REGNUM, NULL);
      supply_register (TPC_REGNUM, NULL);
      supply_register (TNPC_REGNUM, NULL);
      supply_register (WSTATE_REGNUM, NULL);
      supply_register (CWP_REGNUM, NULL);
      supply_register (CANSAVE_REGNUM, NULL);
      supply_register (CANRESTORE_REGNUM, NULL);
      supply_register (CLEANWIN_REGNUM, NULL);
      supply_register (OTHERWIN_REGNUM, NULL);
      supply_register (ASR16_REGNUM, NULL);
      supply_register (ASR17_REGNUM, NULL);
      supply_register (ASR18_REGNUM, NULL);
      supply_register (ASR19_REGNUM, NULL);
      supply_register (ASR20_REGNUM, NULL);
      supply_register (ASR21_REGNUM, NULL);
      supply_register (ASR22_REGNUM, NULL);
      supply_register (ASR23_REGNUM, NULL);
      supply_register (ASR24_REGNUM, NULL);
      supply_register (ASR25_REGNUM, NULL);
      supply_register (ASR26_REGNUM, NULL);
      supply_register (ASR27_REGNUM, NULL);
      supply_register (ASR28_REGNUM, NULL);
      supply_register (ASR29_REGNUM, NULL);
      supply_register (ASR30_REGNUM, NULL);
      supply_register (ASR31_REGNUM, NULL);
      supply_register (ICC_REGNUM, NULL);
      supply_register (XCC_REGNUM, NULL);
d871 1
a871 1
  else
d873 3
a875 1
      supply_register (CPS_REGNUM, NULL);
d877 1
a877 92
}

void
fill_gregset (gdb_gregset_t *gregsetp, int regno)
{
  prgreg_t *regp = (prgreg_t *) gregsetp;
  int regi, offset = 0;

  /* If the host is 64-bit sparc, but the target is 32-bit sparc, 
     then the gregset may contain 64-bit ints while supply_register
     is expecting 32-bit ints.  Compensate.  */
  if (sizeof (regp[0]) == 8 && SPARC_INTREG_SIZE == 4)
    offset = 4;

  for (regi = 0; regi <= R_I7; regi++)
    if ((regno == -1) || (regno == regi))
      deprecated_read_register_gen (regi, (char *) (regp + regi) + offset);

  if ((regno == -1) || (regno == PC_REGNUM))
    deprecated_read_register_gen (PC_REGNUM, (char *) (regp + R_PC) + offset);

  if ((regno == -1) || (regno == DEPRECATED_NPC_REGNUM))
    deprecated_read_register_gen (DEPRECATED_NPC_REGNUM, (char *) (regp + R_nPC) + offset);

  if ((regno == -1) || (regno == Y_REGNUM))
    deprecated_read_register_gen (Y_REGNUM, (char *) (regp + R_Y) + offset);

  if (GDB_TARGET_IS_SPARC64)
    {
#ifdef R_CCR
      if (regno == -1 || regno == CCR_REGNUM)
	deprecated_read_register_gen (CCR_REGNUM, ((char *) (regp + R_CCR)) + offset);
#endif
#ifdef R_FPRS
      if (regno == -1 || regno == FPRS_REGNUM)
	deprecated_read_register_gen (FPRS_REGNUM, ((char *) (regp + R_FPRS)) + offset);
#endif
#ifdef R_ASI
      if (regno == -1 || regno == ASI_REGNUM)
	deprecated_read_register_gen (ASI_REGNUM, ((char *) (regp + R_ASI)) + offset);
#endif
    }
  else /* sparc32 */
    {
#ifdef R_PS
      if (regno == -1 || regno == PS_REGNUM)
	deprecated_read_register_gen (PS_REGNUM, ((char *) (regp + R_PS)) + offset);
#endif

      /* For 64-bit hosts, R_WIM and R_TBR may not be defined.
	 Steal R_ASI and R_FPRS, and hope for the best!  */

#if !defined (R_WIM) && defined (R_ASI)
#define R_WIM R_ASI
#endif

#if !defined (R_TBR) && defined (R_FPRS)
#define R_TBR R_FPRS
#endif

#if defined (R_WIM)
      if (regno == -1 || regno == WIM_REGNUM)
	deprecated_read_register_gen (WIM_REGNUM, ((char *) (regp + R_WIM)) + offset);
#else
      if (regno == -1 || regno == WIM_REGNUM)
	deprecated_read_register_gen (WIM_REGNUM, NULL);
#endif

#if defined (R_TBR)
      if (regno == -1 || regno == TBR_REGNUM)
	deprecated_read_register_gen (TBR_REGNUM, ((char *) (regp + R_TBR)) + offset);
#else
      if (regno == -1 || regno == TBR_REGNUM)
	deprecated_read_register_gen (TBR_REGNUM, NULL);
#endif
    }
}

/*  Given a pointer to a floating point register set in /proc format
   (fpregset_t *), unpack the register contents and supply them as gdb's
   idea of the current floating point register values. */

void
supply_fpregset (gdb_fpregset_t *fpregsetp)
{
  int regi;
  char *from;

  if (!SPARC_HAS_FPU)
    return;

  for (regi = FP0_REGNUM; regi < FP_MAX_REGNUM; regi++)
d879 4
a882 2
      from = (char *) &fpregsetp->pr_fr.pr_regs[regi - FP0_REGNUM];
      supply_register (regi, from);
d884 1
a884 2

  if (GDB_TARGET_IS_SPARC64)
d886 3
a888 8
      /*
       * don't know how to get value of the following.  
       */
      supply_register (FSR_REGNUM, NULL);	/* zero it out for now */
      supply_register (FCC0_REGNUM, NULL);
      supply_register (FCC1_REGNUM, NULL); /* don't know how to get value */
      supply_register (FCC2_REGNUM, NULL); /* don't know how to get value */
      supply_register (FCC3_REGNUM, NULL); /* don't know how to get value */
d890 1
a890 1
  else
d892 3
a894 1
      supply_register (FPS_REGNUM, (char *) &(fpregsetp->pr_fsr));
a895 1
}
d897 1
a897 5
/*  Given a pointer to a floating point register set in /proc format
   (fpregset_t *), update the register specified by REGNO from gdb's idea
   of the current floating point register set.  If REGNO is -1, update
   them all. */
/* This will probably need some changes for sparc64.  */
d899 1
a899 9
void
fill_fpregset (gdb_fpregset_t *fpregsetp, int regno)
{
  int regi;
  char *to;
  char *from;

  if (!SPARC_HAS_FPU)
    return;
d901 1
a901 1
  for (regi = FP0_REGNUM; regi < FP_MAX_REGNUM; regi++)
d903 1
a903 1
      if ((regno == -1) || (regno == regi))
d905 17
a921 3
	  from = (char *) &deprecated_registers[DEPRECATED_REGISTER_BYTE (regi)];
	  to = (char *) &fpregsetp->pr_fr.pr_regs[regi - FP0_REGNUM];
	  memcpy (to, from, DEPRECATED_REGISTER_RAW_SIZE (regi));
d925 1
a925 7
  if (!(GDB_TARGET_IS_SPARC64)) /* FIXME: does Sparc64 have this register? */
    if ((regno == -1) || (regno == FPS_REGNUM))
      {
	from = (char *)&deprecated_registers[DEPRECATED_REGISTER_BYTE (FPS_REGNUM)];
	to = (char *) &fpregsetp->pr_fsr;
	memcpy (to, from, DEPRECATED_REGISTER_RAW_SIZE (FPS_REGNUM));
      }
d928 6
a933 1
#endif /* USE_PROC_FS */
d935 3
a937 3
/* Because of Multi-arch, GET_LONGJMP_TARGET is always defined.  So test
   for a definition of JB_PC.  */
#ifdef JB_PC
d939 2
a940 5
/* Figure out where the longjmp will land.  We expect that we have just entered
   longjmp and haven't yet setup the stack frame, so the args are still in the
   output regs.  %o0 (O0_REGNUM) points at the jmp_buf structure from which we
   extract the pc (JB_PC) that we will land at.  The pc is copied into ADDR.
   This routine returns true on success */
d942 6
a947 6
int
get_longjmp_target (CORE_ADDR *pc)
{
  CORE_ADDR jb_addr;
#define LONGJMP_TARGET_SIZE 4
  char buf[LONGJMP_TARGET_SIZE];
d949 13
a961 1
  jb_addr = read_register (O0_REGNUM);
d963 4
a966 3
  if (target_read_memory (jb_addr + JB_PC * JB_ELEMENT_SIZE, buf,
			  LONGJMP_TARGET_SIZE))
    return 0;
d968 2
a969 3
  *pc = extract_unsigned_integer (buf, LONGJMP_TARGET_SIZE);

  return 1;
a970 1
#endif /* GET_LONGJMP_TARGET */
d972 1
a972 3
#ifdef STATIC_TRANSFORM_NAME
/* SunPRO (3.0 at least), encodes the static variables.  This is not
   related to C++ mangling, it is done for C too.  */
d975 1
a975 1
sunpro_static_transform_name (char *name)
d977 16
a992 1
  char *p;
d995 3
a997 10
      /* For file-local statics there will be a dollar sign, a bunch
         of junk (the contents of which match a string given in the
         N_OPT), a period and the name.  For function-local statics
         there will be a bunch of junk (which seems to change the
         second character from 'A' to 'B'), a period, the name of the
         function, and the name.  So just skip everything before the
         last period.  */
      p = strrchr (name, '.');
      if (p != NULL)
	name = p + 1;
d999 1
a1001 1
#endif /* STATIC_TRANSFORM_NAME */
d1004 14
a1017 2
/* Utilities for printing registers.
   Page numbers refer to the SPARC Architecture Manual.  */
d1019 32
a1050 1
static void dump_ccreg (char *, int);
d1052 1
a1052 49
static void
dump_ccreg (char *reg, int val)
{
  /* page 41 */
  printf_unfiltered ("%s:%s,%s,%s,%s", reg,
		     val & 8 ? "N" : "NN",
		     val & 4 ? "Z" : "NZ",
		     val & 2 ? "O" : "NO",
		     val & 1 ? "C" : "NC");
}

static char *
decode_asi (int val)
{
  /* page 72 */
  switch (val)
    {
    case 4:
      return "ASI_NUCLEUS";
    case 0x0c:
      return "ASI_NUCLEUS_LITTLE";
    case 0x10:
      return "ASI_AS_IF_USER_PRIMARY";
    case 0x11:
      return "ASI_AS_IF_USER_SECONDARY";
    case 0x18:
      return "ASI_AS_IF_USER_PRIMARY_LITTLE";
    case 0x19:
      return "ASI_AS_IF_USER_SECONDARY_LITTLE";
    case 0x80:
      return "ASI_PRIMARY";
    case 0x81:
      return "ASI_SECONDARY";
    case 0x82:
      return "ASI_PRIMARY_NOFAULT";
    case 0x83:
      return "ASI_SECONDARY_NOFAULT";
    case 0x88:
      return "ASI_PRIMARY_LITTLE";
    case 0x89:
      return "ASI_SECONDARY_LITTLE";
    case 0x8a:
      return "ASI_PRIMARY_NOFAULT_LITTLE";
    case 0x8b:
      return "ASI_SECONDARY_NOFAULT_LITTLE";
    default:
      return NULL;
    }
}
d1054 2
a1055 2
/* Pretty print various registers.  */
/* FIXME: Would be nice if this did some fancy things for 32 bit sparc.  */
d1057 3
a1059 4
static void
sparc_print_register_hook (int regno)
{
  ULONGEST val;
d1061 1
a1061 5
  /* Handle double/quad versions of lower 32 fp regs.  */
  if (regno >= FP0_REGNUM && regno < FP0_REGNUM + 32
      && (regno & 1) == 0)
    {
      char value[16];
d1063 1
a1063 19
      if (frame_register_read (deprecated_selected_frame, regno, value)
	  && frame_register_read (deprecated_selected_frame, regno + 1, value + 4))
	{
	  printf_unfiltered ("\t");
	  print_floating (value, builtin_type_double, gdb_stdout);
	}
#if 0				/* FIXME: gdb doesn't handle long doubles */
      if ((regno & 3) == 0)
	{
	  if (frame_register_read (deprecated_selected_frame, regno + 2, value + 8)
	      && frame_register_read (deprecated_selected_frame, regno + 3, value + 12))
	    {
	      printf_unfiltered ("\t");
	      print_floating (value, builtin_type_long_double, gdb_stdout);
	    }
	}
#endif
      return;
    }
d1065 2
a1066 8
#if 0				/* FIXME: gdb doesn't handle long doubles */
  /* Print upper fp regs as long double if appropriate.  */
  if (regno >= FP0_REGNUM + 32 && regno < FP_MAX_REGNUM
  /* We test for even numbered regs and not a multiple of 4 because
     the upper fp regs are recorded as doubles.  */
      && (regno & 1) == 0)
    {
      char value[16];
d1068 1
a1068 9
      if (frame_register_read (deprecated_selected_frame, regno, value)
	  && frame_register_read (deprecated_selected_frame, regno + 1, value + 8))
	{
	  printf_unfiltered ("\t");
	  print_floating (value, builtin_type_long_double, gdb_stdout);
	}
      return;
    }
#endif
d1070 1
a1070 2
  /* FIXME: Some of these are priviledged registers.
     Not sure how they should be handled.  */
d1072 1
a1072 1
#define BITS(n, mask) ((int) (((val) >> (n)) & (mask)))
d1074 2
a1075 1
  val = read_register (regno);
d1077 1
a1077 110
  /* pages 40 - 60 */
  if (GDB_TARGET_IS_SPARC64)
    switch (regno)
      {
      case CCR_REGNUM:
	printf_unfiltered ("\t");
	dump_ccreg ("xcc", val >> 4);
	printf_unfiltered (", ");
	dump_ccreg ("icc", val & 15);
	break;
      case FPRS_REGNUM:
	printf ("\tfef:%d, du:%d, dl:%d",
		BITS (2, 1), BITS (1, 1), BITS (0, 1));
	break;
      case FSR_REGNUM:
	{
	  static char *fcc[4] =
	  {"=", "<", ">", "?"};
	  static char *rd[4] =
	  {"N", "0", "+", "-"};
	  /* Long, but I'd rather leave it as is and use a wide screen.  */
	  printf_filtered ("\t0:%s, 1:%s, 2:%s, 3:%s, rd:%s, tem:%d, ",
			   fcc[BITS (10, 3)], fcc[BITS (32, 3)],
			   fcc[BITS (34, 3)], fcc[BITS (36, 3)],
			   rd[BITS (30, 3)], BITS (23, 31));
	  printf_filtered ("ns:%d, ver:%d, ftt:%d, qne:%d, aexc:%d, cexc:%d",
			   BITS (22, 1), BITS (17, 7), BITS (14, 7), 
			   BITS (13, 1), BITS (5, 31), BITS (0, 31));
	  break;
	}
      case ASI_REGNUM:
	{
	  char *asi = decode_asi (val);
	  if (asi != NULL)
	    printf ("\t%s", asi);
	  break;
	}
      case VER_REGNUM:
	printf ("\tmanuf:%d, impl:%d, mask:%d, maxtl:%d, maxwin:%d",
		BITS (48, 0xffff), BITS (32, 0xffff),
		BITS (24, 0xff), BITS (8, 0xff), BITS (0, 31));
	break;
      case PSTATE_REGNUM:
	{
	  static char *mm[4] =
	  {"tso", "pso", "rso", "?"};
	  printf_filtered ("\tcle:%d, tle:%d, mm:%s, red:%d, ",
			   BITS (9, 1), BITS (8, 1), 
			   mm[BITS (6, 3)], BITS (5, 1));
	  printf_filtered ("pef:%d, am:%d, priv:%d, ie:%d, ag:%d",
			   BITS (4, 1), BITS (3, 1), BITS (2, 1), 
			   BITS (1, 1), BITS (0, 1));
	  break;
	}
      case TSTATE_REGNUM:
	/* FIXME: print all 4? */
	break;
      case TT_REGNUM:
	/* FIXME: print all 4? */
	break;
      case TPC_REGNUM:
	/* FIXME: print all 4? */
	break;
      case TNPC_REGNUM:
	/* FIXME: print all 4? */
	break;
      case WSTATE_REGNUM:
	printf ("\tother:%d, normal:%d", BITS (3, 7), BITS (0, 7));
	break;
      case CWP_REGNUM:
	printf ("\t%d", BITS (0, 31));
	break;
      case CANSAVE_REGNUM:
	printf ("\t%-2d before spill", BITS (0, 31));
	break;
      case CANRESTORE_REGNUM:
	printf ("\t%-2d before fill", BITS (0, 31));
	break;
      case CLEANWIN_REGNUM:
	printf ("\t%-2d before clean", BITS (0, 31));
	break;
      case OTHERWIN_REGNUM:
	printf ("\t%d", BITS (0, 31));
	break;
      }
  else	/* Sparc32 */
    switch (regno) 
      {
      case PS_REGNUM:
	printf ("\ticc:%c%c%c%c, pil:%d, s:%d, ps:%d, et:%d, cwp:%d",
		BITS (23, 1) ? 'N' : '-', BITS (22, 1) ? 'Z' : '-',
		BITS (21, 1) ? 'V' : '-', BITS (20, 1) ? 'C' : '-',
		BITS (8, 15), BITS (7, 1), BITS (6, 1), BITS (5, 1),
		BITS (0, 31));
	break;
      case FPS_REGNUM:
	{
	  static char *fcc[4] =
	  {"=", "<", ">", "?"};
	  static char *rd[4] =
	  {"N", "0", "+", "-"};
	  /* Long, but I'd rather leave it as is and use a wide screen.  */
	  printf ("\trd:%s, tem:%d, ns:%d, ver:%d, ftt:%d, qne:%d, "
		  "fcc:%s, aexc:%d, cexc:%d",
		  rd[BITS (30, 3)], BITS (23, 31), BITS (22, 1), BITS (17, 7),
		  BITS (14, 7), BITS (13, 1), fcc[BITS (10, 3)], BITS (5, 31),
		  BITS (0, 31));
	  break;
	}
      }
d1079 1
a1079 1
#undef BITS
d1081 2
d1084 2
a1085 6
static void
sparc_print_registers (struct gdbarch *gdbarch,
		       struct ui_file *file,
		       struct frame_info *frame,
		       int regnum, int print_all,
		       void (*print_register_hook) (int))
d1087 2
a1089 3
  const int numregs = NUM_REGS + NUM_PSEUDO_REGS;
  char raw_buffer[MAX_REGISTER_SIZE];
  char virtual_buffer[MAX_REGISTER_SIZE];
d1091 1
a1091 1
  for (i = 0; i < numregs; i++)
d1093 4
a1096 3
      /* Decide between printing all regs, non-float / vector regs, or
         specific reg.  */
      if (regnum == -1)
d1098 1
a1098 1
	  if (!print_all)
d1100 2
a1101 4
	      if (TYPE_CODE (DEPRECATED_REGISTER_VIRTUAL_TYPE (i)) == TYPE_CODE_FLT)
		continue;
	      if (TYPE_VECTOR (DEPRECATED_REGISTER_VIRTUAL_TYPE (i)))
		continue;
d1104 10
a1113 1
      else
d1115 2
a1116 2
	  if (i != regnum)
	    continue;
d1119 1
a1119 10
      /* If the register name is empty, it is undefined for this
         processor, so don't display anything.  */
      if (REGISTER_NAME (i) == NULL || *(REGISTER_NAME (i)) == '\0')
	continue;

      fputs_filtered (REGISTER_NAME (i), file);
      print_spaces_filtered (15 - strlen (REGISTER_NAME (i)), file);

      /* Get the data in raw format.  */
      if (! frame_register_read (frame, i, raw_buffer))
d1121 6
a1126 2
	  fprintf_filtered (file, "*value not available*\n");
	  continue;
d1128 10
d1139 4
a1142 1
      memcpy (virtual_buffer, raw_buffer, DEPRECATED_REGISTER_VIRTUAL_SIZE (i));
d1144 1
a1144 3
      /* If virtual format is floating, print it that way, and in raw
         hex.  */
      if (TYPE_CODE (DEPRECATED_REGISTER_VIRTUAL_TYPE (i)) == TYPE_CODE_FLT)
d1146 1
a1146 7
	  int j;

	  val_print (DEPRECATED_REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0,
		     file, 0, 1, 0, Val_pretty_default);

	  fprintf_filtered (file, "\t(raw 0x");
	  for (j = 0; j < DEPRECATED_REGISTER_RAW_SIZE (i); j++)
d1148 2
a1149 6
	      int idx;
	      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
		idx = j;
	      else
		idx = DEPRECATED_REGISTER_RAW_SIZE (i) - 1 - j;
	      fprintf_filtered (file, "%02x", (unsigned char) raw_buffer[idx]);
a1150 1
	  fprintf_filtered (file, ")");
d1152 12
a1163 1
      else
d1165 1
a1165 6
	  /* Print the register in hex.  */
	  val_print (DEPRECATED_REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0,
		     file, 'x', 1, 0, Val_pretty_default);
          /* If not a vector register, print it also according to its
             natural format.  */
	  if (TYPE_VECTOR (DEPRECATED_REGISTER_VIRTUAL_TYPE (i)) == 0)
d1167 3
a1169 3
	      fprintf_filtered (file, "\t");
	      val_print (DEPRECATED_REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0,
			 file, 0, 1, 0, Val_pretty_default);
a1171 6

      /* Some sparc specific info.  */
      if (print_register_hook != NULL)
	print_register_hook (i);

      fprintf_filtered (file, "\n");
d1175 1
a1175 9
static void
sparc_print_registers_info (struct gdbarch *gdbarch,
			    struct ui_file *file,
			    struct frame_info *frame,
			    int regnum, int print_all)
{
  sparc_print_registers (gdbarch, file, frame, regnum, print_all,
			 sparc_print_register_hook);
}
d1178 3
a1180 1
sparc_do_registers_info (int regnum, int all)
d1182 6
a1187 3
  sparc_print_registers_info (current_gdbarch, gdb_stdout, deprecated_selected_frame,
			      regnum, all);
}
d1189 3
a1191 4
#define SPARC_F0_REGNUM		FP0_REGNUM	/* %f0 */
#define SPARC_F1_REGNUM		(FP0_REGNUM + 1)/* %f1 */
#define SPARC_O0_REGNUM		O0_REGNUM	/* %o0 */
#define SPARC_O1_REGNUM		O1_REGNUM	/* %o1 */
d1193 3
a1195 1
/* Push the arguments onto the stack and into the appropriate registers.  */
d1197 3
a1199 7
static CORE_ADDR
sparc32_do_push_arguments (struct regcache *regcache, int nargs,
			   struct value **args, CORE_ADDR sp)
{
  CORE_ADDR *addr;
  int size = 0;
  int i;
d1201 2
a1202 5
  /* Structure, union and quad-precision arguments are passed by
     reference.  We allocate space for these arguments on the stack
     and record their addresses in an array.  Array elements for
     arguments that are passed by value will be set to zero.*/
  addr = alloca (nargs * sizeof (CORE_ADDR));
d1204 1
a1204 1
  for (i = nargs - 1; i >= 0; i--)
d1206 1
a1206 3
      struct type *type = VALUE_ENCLOSING_TYPE (args[i]);
      enum type_code code = TYPE_CODE (type);
      int len = TYPE_LENGTH (type);
d1208 1
a1208 11
      /* Push the contents of structure, union and quad-precision
	 arguments on the stack.  */
      if (code == TYPE_CODE_STRUCT || code == TYPE_CODE_UNION || len > 8)
	{
	  /* Keep the stack doubleword aligned.  */
	  sp -= (len + 7) & ~7;
	  write_memory (sp, VALUE_CONTENTS_ALL (args[i]), len);
	  addr[i] = sp;
	  size += 4;
	}
      else
d1210 3
a1212 2
	  addr[i] = 0;
	  size += (len > 4) ? 8 : 4;
d1216 1
a1216 15
  /* The needed space for outgoing arguments should be a multiple of 4.  */
  gdb_assert (size % 4 == 0);

  /* Make sure we reserve space for the first six words of arguments
     in the stack frame, even if we don't need them.  */
  if (size < 24)
    sp -= (24 - size);

  /* Make sure we end up with a doubleword aligned stack in the end.
     Reserve an extra word if necessary in order to accomplish this.  */
  if ((sp - size) % 8 == 0)
    sp -= 4;

  /* Now push the arguments onto the stack.  */
  for (i = nargs - 1; i >=0; i--)
d1218 5
a1222 2
      char buf[8];
      int len;
d1224 2
a1225 4
      if (addr[i])
	{
	  store_unsigned_integer (buf, 4, addr[i]);
	  len = 4;
d1229 1
a1229 1
	  struct value *arg = args[i];
d1231 1
a1231 4
	  len = TYPE_LENGTH (VALUE_ENCLOSING_TYPE (arg));

	  /* Expand signed and unsigned bytes and halfwords as needed.  */
	  if (len < 4)
d1233 3
a1235 2
	      arg = value_cast (builtin_type_long, arg);
	      len = 4;
a1236 24
	  else if (len > 4 && len < 8)
	    {
	      arg = value_cast (builtin_type_long_long, arg);
	      len = 4;
	    }

	  gdb_assert (len == 4 || len == 8);
	  memcpy (buf, VALUE_CONTENTS_ALL (arg), len);
	}

      /* We always write the argument word on the stack.  */
      sp -= len;
      write_memory (sp, buf, len);

      /* If this argument occupies one of the first 6 words, write it
         into the appropriate register too.  */
      size -= len;
      if (size < 24)
	{
	  int regnum = SPARC_O0_REGNUM + (size / 4);

	  regcache_cooked_write (regcache, regnum, buf);
	  if (len == 8 && size < 20)
	    regcache_cooked_write (regcache, regnum + 1, buf + 4);
d1239 1
d1241 7
a1247 2
  /* Reserve space for the struct/union return value pointer.  */
  sp -= 4;
d1249 3
a1251 2
  /* Stack should be doubleword aligned at this point.  */
  gdb_assert (sp % 8 == 0);
d1253 3
a1255 3
  /* Return the adjusted stack pointer.  */
  return sp;
}
d1257 3
a1259 3
/* The SPARC passes the arguments on the stack; arguments smaller
   than an int are promoted to an int.  The first 6 words worth of 
   args are also passed in registers o0 - o5.  */
d1261 3
a1263 5
CORE_ADDR
sparc32_push_arguments (int nargs, struct value **args, CORE_ADDR sp,
			int struct_return, CORE_ADDR struct_addr)
{
  sp = sparc32_do_push_arguments (current_regcache, nargs, args, sp);
d1265 1
a1265 4
  /* FIXME: kettenis/20030525: We don't let this function set the
     struct/union return pointer just yet.  */
#if 0
  if (struct_return)
d1267 1
a1267 1
      char buf[4];
d1269 7
a1275 4
      /* The space for the struct/union return value pointer has
         already been reserved.  */
      store_unsigned_integer (buf, 4, struct_addr);
      write (sp, buf, 4);
d1278 1
a1278 22
  return sp;
#else
  return sp + 4;
#endif
}

/* Extract from REGCACHE a function return value of type TYPE and copy
   that into VALBUF.

   Note that REGCACHE specifies the register values for the frame of
   the calling function.  This means that we need to fetch the value
   form %o0 and %o1, which correspond to %i0 and %i1 in the frame of
   the called function.  */

void
sparc32_extract_return_value (struct type *type, struct regcache *regcache,
			      void *valbuf)
{
  int len = TYPE_LENGTH (type);
  char buf[8];

  if (TYPE_CODE (type) == TYPE_CODE_FLT && SPARC_HAS_FPU)
d1280 3
a1282 1
      if (len == 4 || len == 8)
d1284 8
a1291 4
	  regcache_cooked_read (regcache, SPARC_F0_REGNUM, buf);
	  regcache_cooked_read (regcache, SPARC_F1_REGNUM, buf + 4);
	  memcpy (valbuf, buf, len);
	  return;
a1292 3
      else
	internal_error (__FILE__, __LINE__, "\
Cannot extract floating-point return value of %d bytes long.", len);
a1293 15

  if (len <= 4)
    {
      regcache_cooked_read (regcache, SPARC_O0_REGNUM, buf);
      memcpy (valbuf, buf + 4 - len, len);
    }
  else if (len <= 8)
    {
      regcache_cooked_read (regcache, SPARC_O0_REGNUM, buf);
      regcache_cooked_read (regcache, SPARC_O1_REGNUM, buf + 4);
      memcpy (valbuf, buf + 8 - len, len);
    }
  else
    internal_error (__FILE__, __LINE__,
		    "Cannot extract return value of %d bytes long.", len);
a1295 2
/* Write into REGBUF a function return value VALBUF of type TYPE.  */

d1297 2
a1298 2
sparc32_store_return_value (struct type *type, struct regcache *regcache,
			    const void *valbuf)
d1300 2
a1301 22
  int len = TYPE_LENGTH (type);
  char buf[8];

  if (TYPE_CODE (type) == TYPE_CODE_FLT && SPARC_HAS_FPU)
    {
      const char *buf = valbuf;

      if (len == 4)
	{
	  regcache_cooked_write (regcache, SPARC_F0_REGNUM, buf);
	  return;
	}
      else if (len == 8)
	{
	  regcache_cooked_write (regcache, SPARC_F0_REGNUM, buf);
	  regcache_cooked_write (regcache, SPARC_F1_REGNUM, buf + 4);
	  return;
	}
      else
	internal_error (__FILE__, __LINE__, "\
Cannot extract floating-point return value of %d bytes long.", len);
    }
d1303 1
a1303 9
  /* Add leading zeros to the value.  */
  memset (buf, 0, sizeof buf);

  if (len <= 4)
    {
      memcpy (buf + 4 - len, valbuf, len);
      regcache_cooked_write (regcache, SPARC_O0_REGNUM, buf);
    }
  else if (len <= 8)
d1305 2
a1306 3
      memcpy (buf + 8 - len, valbuf, len);
      regcache_cooked_write (regcache, SPARC_O0_REGNUM, buf);
      regcache_cooked_write (regcache, SPARC_O1_REGNUM, buf);
a1307 12
  else
    internal_error (__FILE__, __LINE__,
		    "Cannot extract return value of %d bytes long.", len);
}

/* Extract from REGCACHE the address in which a function should return
   its structure value.  */

CORE_ADDR
sparc_extract_struct_value_address (struct regcache *regcache)
{
  ULONGEST addr;
d1309 2
a1310 2
  regcache_cooked_read_unsigned (regcache, SPARC_O0_REGNUM, &addr);
  return addr;
a1312 44
/* FIXME: kettenis/2003/05/24: Still used for sparc64.  */

static void
sparc_store_return_value (struct type *type, char *valbuf)
{
  int regno;
  char buffer[MAX_REGISTER_SIZE];

  if (TYPE_CODE (type) == TYPE_CODE_FLT && SPARC_HAS_FPU)
    /* Floating-point values are returned in the register pair */
    /* formed by %f0 and %f1 (doubles are, anyway).  */
    regno = FP0_REGNUM;
  else
    /* Other values are returned in register %o0.  */
    regno = O0_REGNUM;

  /* Add leading zeros to the value. */
  if (TYPE_LENGTH (type) < DEPRECATED_REGISTER_RAW_SIZE (regno))
    {
      memset (buffer, 0, DEPRECATED_REGISTER_RAW_SIZE (regno));
      memcpy (buffer + DEPRECATED_REGISTER_RAW_SIZE (regno) - TYPE_LENGTH (type), valbuf,
	      TYPE_LENGTH (type));
      deprecated_write_register_gen (regno, buffer);
    }
  else
    deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (regno), valbuf,
				     TYPE_LENGTH (type));
}

#ifndef CALL_DUMMY_CALL_OFFSET
#define CALL_DUMMY_CALL_OFFSET \
     (gdbarch_tdep (current_gdbarch)->call_dummy_call_offset)
#endif /* CALL_DUMMY_CALL_OFFSET */

/* Insert the function address into a call dummy instruction sequence
   stored at DUMMY.

   For structs and unions, if the function was compiled with Sun cc,
   it expects 'unimp' after the call.  But gcc doesn't use that
   (twisted) convention.  So leave a nop there for gcc
   (DEPRECATED_FIX_CALL_DUMMY can assume it is operating on a pristine
   CALL_DUMMY, not one that has already been customized for a
   different function).  */

d1314 2
a1315 2
sparc_fix_call_dummy (char *dummy, CORE_ADDR pc, CORE_ADDR fun,
		      struct type *value_type, int using_gcc)
d1317 1
d1320 4
a1323 26
  /* Store the relative adddress of the target function into the
     'call' instruction. */
  store_unsigned_integer (dummy + CALL_DUMMY_CALL_OFFSET, 4,
			  (0x40000000
			   | (((fun - (pc + CALL_DUMMY_CALL_OFFSET)) >> 2)
			      & 0x3fffffff)));

  /* If the called function returns an aggregate value, fill in the UNIMP
     instruction containing the size of the returned aggregate return value,
     which follows the call instruction.
     For details see the SPARC Architecture Manual Version 8, Appendix D.3.

     Adjust the call_dummy_breakpoint_offset for the bp_call_dummy breakpoint
     to the proper address in the call dummy, so that `finish' after a stop
     in a call dummy works.

     Tweeking current_gdbarch is not an optimal solution, but the call
     to sparc_fix_call_dummy is immediately followed by a call to
     call_function_by_hand, which is the only function where
     dummy_breakpoint_offset is actually used, if it is non-zero.  */
  if (TYPE_CODE (value_type) == TYPE_CODE_STRUCT
       || TYPE_CODE (value_type) == TYPE_CODE_UNION)
    {
      store_unsigned_integer (dummy + CALL_DUMMY_CALL_OFFSET + 8, 4,
			      TYPE_LENGTH (value_type) & 0x1fff);
      set_gdbarch_deprecated_call_dummy_breakpoint_offset (current_gdbarch, 0x30);
a1324 2
  else
    set_gdbarch_deprecated_call_dummy_breakpoint_offset (current_gdbarch, 0x2c);
d1326 2
a1327 13
  if (!(GDB_TARGET_IS_SPARC64))
    {
      /* If this is not a simulator target, change the first four
	 instructions of the call dummy to NOPs.  Those instructions
	 include a 'save' instruction and are designed to work around
	 problems with register window flushing in the simulator. */
      
      if (strcmp (target_shortname, "sim") != 0)
	{
	  for (i = 0; i < 4; i++)
	    store_unsigned_integer (dummy + (i * 4), 4, 0x01000000);
	}
    }
d1329 1
d1331 1
a1331 3
/*
 * Module "constructor" function. 
 */
d1333 13
a1345 3
static struct gdbarch * sparc_gdbarch_init (struct gdbarch_info info,
					    struct gdbarch_list *arches);
static void sparc_dump_tdep (struct gdbarch *, struct ui_file *);
d1347 2
a1348 1
extern initialize_file_ftype _initialize_sparc_tdep; /* -Wmissing-prototypes */
d1353 1
a1353 896
  /* Hook us into the gdbarch mechanism.  */
  gdbarch_register (bfd_arch_sparc, sparc_gdbarch_init, sparc_dump_tdep);
}

/* Compensate for stack bias. Note that we currently don't handle
   mixed 32/64 bit code. */

static CORE_ADDR
sparc64_read_sp (void)
{
  CORE_ADDR sp = read_register (SP_REGNUM);

  if (sp & 1)
    sp += 2047;
  return sp;
}

static CORE_ADDR
sparc64_read_fp (void)
{
  CORE_ADDR fp = read_register (DEPRECATED_FP_REGNUM);

  if (fp & 1)
    fp += 2047;
  return fp;
}

static void
sparc64_write_sp (CORE_ADDR val)
{
  CORE_ADDR oldsp = read_register (SP_REGNUM);
  if (oldsp & 1)
    write_register (SP_REGNUM, val - 2047);
  else
    write_register (SP_REGNUM, val);
}

/* The SPARC 64 ABI passes floating-point arguments in FP0 to FP31,
   and all other arguments in O0 to O5.  They are also copied onto
   the stack in the correct places.  Apparently (empirically), 
   structs of less than 16 bytes are passed member-by-member in
   separate registers, but I am unable to figure out the algorithm.
   Some members go in floating point regs, but I don't know which.

   FIXME: Handle small structs (less than 16 bytes containing floats).

   The counting regimen for using both integer and FP registers
   for argument passing is rather odd -- a single counter is used
   for both; this means that if the arguments alternate between
   int and float, we will waste every other register of both types.  */

static CORE_ADDR
sparc64_push_arguments (int nargs, struct value **args, CORE_ADDR sp,
			int struct_return, CORE_ADDR struct_retaddr)
{
  int i, j, register_counter = 0;
  CORE_ADDR tempsp;
  struct type *sparc_intreg_type = 
    TYPE_LENGTH (builtin_type_long) == SPARC_INTREG_SIZE ?
    builtin_type_long : builtin_type_long_long;

  sp = (sp & ~(((unsigned long) SPARC_INTREG_SIZE) - 1UL));

  /* Figure out how much space we'll need. */
  for (i = nargs - 1; i >= 0; i--)
    {
      int len = TYPE_LENGTH (check_typedef (VALUE_TYPE (args[i])));
      struct value *copyarg = args[i];
      int copylen = len;

      if (copylen < SPARC_INTREG_SIZE)
	{
	  copyarg = value_cast (sparc_intreg_type, copyarg);
	  copylen = SPARC_INTREG_SIZE;
	}
      sp -= copylen;
    }

  /* Round down. */
  sp = sp & ~7;
  tempsp = sp;

  /* if STRUCT_RETURN, then first argument is the struct return location. */
  if (struct_return)
    write_register (O0_REGNUM + register_counter++, struct_retaddr);

  /* Now write the arguments onto the stack, while writing FP
     arguments into the FP registers, and other arguments into the
     first six 'O' registers.  */

  for (i = 0; i < nargs; i++)
    {
      int len = TYPE_LENGTH (check_typedef (VALUE_TYPE (args[i])));
      struct value *copyarg = args[i];
      enum type_code typecode = TYPE_CODE (VALUE_TYPE (args[i]));
      int copylen = len;

      if (typecode == TYPE_CODE_INT   ||
	  typecode == TYPE_CODE_BOOL  ||
	  typecode == TYPE_CODE_CHAR  ||
	  typecode == TYPE_CODE_RANGE ||
	  typecode == TYPE_CODE_ENUM)
	if (len < SPARC_INTREG_SIZE)
	  {
	    /* Small ints will all take up the size of one intreg on
	       the stack.  */
	    copyarg = value_cast (sparc_intreg_type, copyarg);
	    copylen = SPARC_INTREG_SIZE;
	  }

      write_memory (tempsp, VALUE_CONTENTS (copyarg), copylen);
      tempsp += copylen;

      /* Corner case: Structs consisting of a single float member are floats.
       * FIXME!  I don't know about structs containing multiple floats!
       * Structs containing mixed floats and ints are even more weird.
       */



      /* Separate float args from all other args.  */
      if (typecode == TYPE_CODE_FLT && SPARC_HAS_FPU)
	{
	  if (register_counter < 16)
	    {
	      /* This arg gets copied into a FP register. */
	      int fpreg;

	      switch (len) {
	      case 4:	/* Single-precision (float) */
		fpreg = FP0_REGNUM + 2 * register_counter + 1;
		register_counter += 1;
		break;
	      case 8:	/* Double-precision (double) */
		fpreg = FP0_REGNUM + 2 * register_counter;
		register_counter += 1;
		break;
	      case 16:	/* Quad-precision (long double) */
		fpreg = FP0_REGNUM + 2 * register_counter;
		register_counter += 2;
		break;
	      default:
		internal_error (__FILE__, __LINE__, "bad switch");
	      }
	      deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (fpreg),
					       VALUE_CONTENTS (args[i]),
					       len);
	    }
	}
      else /* all other args go into the first six 'o' registers */
        {
          for (j = 0; 
	       j < len && register_counter < 6; 
	       j += SPARC_INTREG_SIZE)
	    {
	      int oreg = O0_REGNUM + register_counter;

	      deprecated_write_register_gen (oreg, VALUE_CONTENTS (copyarg) + j);
	      register_counter += 1;
	    }
        }
    }
  return sp;
}

/* Values <= 32 bytes are returned in o0-o3 (floating-point values are
   returned in f0-f3). */

static void
sp64_extract_return_value (struct type *type, char *regbuf, char *valbuf,
			   int bitoffset)
{
  int typelen = TYPE_LENGTH (type);
  int regsize = DEPRECATED_REGISTER_RAW_SIZE (O0_REGNUM);

  if (TYPE_CODE (type) == TYPE_CODE_FLT && SPARC_HAS_FPU)
    {
      memcpy (valbuf, &regbuf[DEPRECATED_REGISTER_BYTE (FP0_REGNUM)], typelen);
      return;
    }

  if (TYPE_CODE (type) != TYPE_CODE_STRUCT
      || (TYPE_LENGTH (type) > 32))
    {
      memcpy (valbuf,
	      &regbuf[O0_REGNUM * regsize +
		      (typelen >= regsize ? 0 : regsize - typelen)],
	      typelen);
      return;
    }
  else
    {
      char *o0 = &regbuf[O0_REGNUM * regsize];
      char *f0 = &regbuf[FP0_REGNUM * regsize];
      int x;

      for (x = 0; x < TYPE_NFIELDS (type); x++)
	{
	  struct field *f = &TYPE_FIELDS (type)[x];
	  /* FIXME: We may need to handle static fields here. */
	  int whichreg = (f->loc.bitpos + bitoffset) / 32;
	  int remainder = ((f->loc.bitpos + bitoffset) % 32) / 8;
	  int where = (f->loc.bitpos + bitoffset) / 8;
	  int size = TYPE_LENGTH (f->type);
	  int typecode = TYPE_CODE (f->type);

	  if (typecode == TYPE_CODE_STRUCT)
	    {
	      sp64_extract_return_value (f->type,
					 regbuf,
					 valbuf,
					 bitoffset + f->loc.bitpos);
	    }
	  else if (typecode == TYPE_CODE_FLT && SPARC_HAS_FPU)
	    {
	      memcpy (valbuf + where, &f0[whichreg * 4] + remainder, size);
	    }
	  else
	    {
	      memcpy (valbuf + where, &o0[whichreg * 4] + remainder, size);
	    }
	}
    }
}

static void
sparc64_extract_return_value (struct type *type, char *regbuf, char *valbuf)
{
  sp64_extract_return_value (type, regbuf, valbuf, 0);
}

extern CORE_ADDR
sparc32_stack_align (CORE_ADDR addr)
{
  return ((addr + 7) & -8);
}

static CORE_ADDR
sparc64_stack_align (CORE_ADDR addr)
{
  return ((addr + 15) & -16);
}

extern void
sparc_print_extra_frame_info (struct frame_info *fi)
{
  if (fi && get_frame_extra_info (fi) && get_frame_extra_info (fi)->flat)
    printf_filtered (" flat, pc saved at 0x%s, fp saved at 0x%s\n",
		     paddr_nz (get_frame_extra_info (fi)->pc_addr), 
		     paddr_nz (get_frame_extra_info (fi)->fp_addr));
}

static const char *
sparc32_register_name (int regno)
{
  static char *register_names[] = 
  { "g0", "g1", "g2", "g3", "g4", "g5", "g6", "g7",
    "o0", "o1", "o2", "o3", "o4", "o5", "sp", "o7",
    "l0", "l1", "l2", "l3", "l4", "l5", "l6", "l7",
    "i0", "i1", "i2", "i3", "i4", "i5", "fp", "i7",

    "f0",  "f1",  "f2",  "f3",  "f4",  "f5",  "f6",  "f7",
    "f8",  "f9",  "f10", "f11", "f12", "f13", "f14", "f15",
    "f16", "f17", "f18", "f19", "f20", "f21", "f22", "f23",
    "f24", "f25", "f26", "f27", "f28", "f29", "f30", "f31",

    "y", "psr", "wim", "tbr", "pc", "npc", "fpsr", "cpsr"
  };

  if (regno < 0 ||
      regno >= (sizeof (register_names) / sizeof (register_names[0])))
    return NULL;
  else
    return register_names[regno];
}

static const char *
sparc64_register_name (int regno)
{
  static char *register_names[] = 
  { "g0", "g1", "g2", "g3", "g4", "g5", "g6", "g7",
    "o0", "o1", "o2", "o3", "o4", "o5", "sp", "o7",
    "l0", "l1", "l2", "l3", "l4", "l5", "l6", "l7",
    "i0", "i1", "i2", "i3", "i4", "i5", "fp", "i7",

    "f0",  "f1",  "f2",  "f3",  "f4",  "f5",  "f6",  "f7",
    "f8",  "f9",  "f10", "f11", "f12", "f13", "f14", "f15",
    "f16", "f17", "f18", "f19", "f20", "f21", "f22", "f23",
    "f24", "f25", "f26", "f27", "f28", "f29", "f30", "f31",
    "f32", "f34", "f36", "f38", "f40", "f42", "f44", "f46",
    "f48", "f50", "f52", "f54", "f56", "f58", "f60", "f62",

    "pc", "npc", "ccr", "fsr", "fprs", "y", "asi", "ver", 
    "tick", "pil", "pstate", "tstate", "tba", "tl", "tt", "tpc", 
    "tnpc", "wstate", "cwp", "cansave", "canrestore", "cleanwin", "otherwin",
    "asr16", "asr17", "asr18", "asr19", "asr20", "asr21", "asr22", "asr23", 
    "asr24", "asr25", "asr26", "asr27", "asr28", "asr29", "asr30", "asr31",
    /* These are here at the end to simplify removing them if we have to.  */
    "icc", "xcc", "fcc0", "fcc1", "fcc2", "fcc3"
  };

  if (regno < 0 ||
      regno >= (sizeof (register_names) / sizeof (register_names[0])))
    return NULL;
  else
    return register_names[regno];
}

static CORE_ADDR
sparc_push_return_address (CORE_ADDR pc_unused, CORE_ADDR sp)
{
  if (CALL_DUMMY_LOCATION == AT_ENTRY_POINT)
    {
      /* The return PC of the dummy_frame is the former 'current' PC
	 (where we were before we made the target function call).
	 This is saved in %i7 by push_dummy_frame.

	 We will save the 'call dummy location' (ie. the address
	 to which the target function will return) in %o7.  
	 This address will actually be the program's entry point.  
	 There will be a special call_dummy breakpoint there.  */

      if (DEPRECATED_CALL_DUMMY_ADDRESS_P ())
	write_register (O7_REGNUM, DEPRECATED_CALL_DUMMY_ADDRESS () - 8);
      else
	write_register (O7_REGNUM, entry_point_address () - 8);
    }

  return sp;
}

/* Should call_function allocate stack space for a struct return?  */

static int
sparc64_use_struct_convention (int gcc_p, struct type *type)
{
  return (TYPE_LENGTH (type) > 32);
}

/* Store the address of the place in which to copy the structure the
   subroutine will return.  This is called from call_function_by_hand.
   The ultimate mystery is, tho, what is the value "16"?

   MVS: That's the offset from where the sp is now, to where the
   subroutine is gonna expect to find the struct return address.  */

static void
sparc32_store_struct_return (CORE_ADDR addr, CORE_ADDR sp)
{
  char *val;
  CORE_ADDR o7;

  val = alloca (SPARC_INTREG_SIZE); 
  store_unsigned_integer (val, SPARC_INTREG_SIZE, addr);
  write_memory (sp + (16 * SPARC_INTREG_SIZE), val, SPARC_INTREG_SIZE); 

  if (CALL_DUMMY_LOCATION == AT_ENTRY_POINT)
    {
      /* Now adjust the value of the link register, which was previously
	 stored by push_return_address.  Functions that return structs are
	 peculiar in that they return to link register + 12, rather than
	 link register + 8.  */

      o7 = read_register (O7_REGNUM);
      write_register (O7_REGNUM, o7 - 4);
    }
}

static void
sparc64_store_struct_return (CORE_ADDR addr, CORE_ADDR sp)
{
  /* FIXME: V9 uses %o0 for this.  */
  /* FIXME MVS: Only for small enough structs!!! */

  target_write_memory (sp + (16 * SPARC_INTREG_SIZE), 
		       (char *) &addr, SPARC_INTREG_SIZE); 
#if 0
  if (CALL_DUMMY_LOCATION == AT_ENTRY_POINT)
    {
      /* Now adjust the value of the link register, which was previously
	 stored by push_return_address.  Functions that return structs are
	 peculiar in that they return to link register + 12, rather than
	 link register + 8.  */

      write_register (O7_REGNUM, read_register (O7_REGNUM) - 4);
    }
#endif
}

/* Default target data type for register REGNO.  */

static struct type *
sparc32_register_virtual_type (int regno)
{
  if (regno == PC_REGNUM ||
      regno == DEPRECATED_FP_REGNUM ||
      regno == SP_REGNUM)
    return builtin_type_unsigned_int;
  if (regno < 32)
    return builtin_type_int;
  if (regno < 64)
    return builtin_type_float;
  return builtin_type_int;
}

static struct type *
sparc64_register_virtual_type (int regno)
{
  if (regno == PC_REGNUM ||
      regno == DEPRECATED_FP_REGNUM ||
      regno == SP_REGNUM)
    return builtin_type_unsigned_long_long;
  if (regno < 32)
    return builtin_type_long_long;
  if (regno < 64)
    return builtin_type_float;
  if (regno < 80)
    return builtin_type_double;
  return builtin_type_long_long;
}

/* Number of bytes of storage in the actual machine representation for
   register REGNO.  */

static int
sparc32_register_size (int regno)
{
  return 4;
}

static int
sparc64_register_size (int regno)
{
  return (regno < 32 ? 8 : regno < 64 ? 4 : 8);
}

/* Index within the `registers' buffer of the first byte of the space
   for register REGNO.  */

static int
sparc32_register_byte (int regno)
{
  return (regno * 4);
}

static int
sparc64_register_byte (int regno)
{
  if (regno < 32)
    return regno * 8;
  else if (regno < 64)
    return 32 * 8 + (regno - 32) * 4;
  else if (regno < 80)
    return 32 * 8 + 32 * 4 + (regno - 64) * 8;
  else
    return 64 * 8 + (regno - 80) * 8;
}

/* Immediately after a function call, return the saved pc.
   Can't go through the frames for this because on some machines
   the new frame is not set up until the new function executes
   some instructions.  */

static CORE_ADDR
sparc_saved_pc_after_call (struct frame_info *fi)
{
  return sparc_pc_adjust (read_register (RP_REGNUM));
}

/* Init saved regs: nothing to do, just a place-holder function.  */

static void
sparc_frame_init_saved_regs (struct frame_info *fi_ignored)
{	/* no-op */
}

/* gdbarch fix call dummy:
   All this function does is rearrange the arguments before calling
   sparc_fix_call_dummy (which does the real work).  */

static void
sparc_gdbarch_fix_call_dummy (char *dummy, 
			      CORE_ADDR pc, 
			      CORE_ADDR fun, 
			      int nargs, 
			      struct value **args, 
			      struct type *type, 
			      int gcc_p)
{
  if (CALL_DUMMY_LOCATION == ON_STACK)
    sparc_fix_call_dummy (dummy, pc, fun, type, gcc_p);
}

/* DEPRECATED_CALL_DUMMY_ADDRESS: fetch the breakpoint address for a
   call dummy.  */

static CORE_ADDR
sparc_call_dummy_address (void)
{
  return (DEPRECATED_CALL_DUMMY_START_OFFSET) + DEPRECATED_CALL_DUMMY_BREAKPOINT_OFFSET;
}

/* Supply the Y register number to those that need it.  */

int
sparc_y_regnum (void)
{
  return gdbarch_tdep (current_gdbarch)->y_regnum;
}

int
sparc_reg_struct_has_addr (int gcc_p, struct type *type)
{
  if (GDB_TARGET_IS_SPARC64)
    return (TYPE_LENGTH (type) > 32);
  else
    return (gcc_p != 1);
}

int
sparc_intreg_size (void)
{
  return SPARC_INTREG_SIZE;
}

static int
sparc_return_value_on_stack (struct type *type)
{
  if (TYPE_CODE (type) == TYPE_CODE_FLT &&
      TYPE_LENGTH (type) > 8)
    return 1;
  else
    return 0;
}

/* Get the ith function argument for the current function.  */
static CORE_ADDR
sparc_fetch_pointer_argument (struct frame_info *frame, int argi,
			      struct type *type)
{
  CORE_ADDR addr;
  get_frame_register (frame, O0_REGNUM + argi, &addr);
  return addr;
}

/*
 * Gdbarch "constructor" function.
 */

#define SPARC32_CALL_DUMMY_ON_STACK

#define SPARC_SP_REGNUM    14
#define SPARC_FP_REGNUM    30
#define SPARC_FP0_REGNUM   32
#define SPARC32_NPC_REGNUM 69
#define SPARC32_PC_REGNUM  68
#define SPARC32_Y_REGNUM   64
#define SPARC64_PC_REGNUM  80
#define SPARC64_NPC_REGNUM 81
#define SPARC64_Y_REGNUM   85

static struct gdbarch *
sparc_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
{
  struct gdbarch *gdbarch;
  struct gdbarch_tdep *tdep;

  static LONGEST call_dummy_32[] = 
    { 0xbc100001, 0x9de38000, 0xbc100002, 0xbe100003,
      0xda03a058, 0xd803a054, 0xd603a050, 0xd403a04c,
      0xd203a048, 0x40000000, 0xd003a044, 0x01000000,
      0x91d02001, 0x01000000
    };
  static LONGEST call_dummy_64[] = 
    { 0x9de3bec0fd3fa7f7LL, 0xf93fa7eff53fa7e7LL,
      0xf13fa7dfed3fa7d7LL, 0xe93fa7cfe53fa7c7LL,
      0xe13fa7bfdd3fa7b7LL, 0xd93fa7afd53fa7a7LL,
      0xd13fa79fcd3fa797LL, 0xc93fa78fc53fa787LL,
      0xc13fa77fcc3fa777LL, 0xc83fa76fc43fa767LL,
      0xc03fa75ffc3fa757LL, 0xf83fa74ff43fa747LL,
      0xf03fa73f01000000LL, 0x0100000001000000LL,
      0x0100000091580000LL, 0xd027a72b93500000LL,
      0xd027a72791480000LL, 0xd027a72391400000LL,
      0xd027a71fda5ba8a7LL, 0xd85ba89fd65ba897LL,
      0xd45ba88fd25ba887LL, 0x9fc02000d05ba87fLL,
      0x0100000091d02001LL, 0x0100000001000000LL 
    };
  static LONGEST call_dummy_nil[] = {0};

  /* Try to determine the OS ABI of the object we are loading.  */

  if (info.abfd != NULL
      && info.osabi == GDB_OSABI_UNKNOWN)
    {
      /* If it's an ELF file, assume it's Solaris.  */
      if (bfd_get_flavour (info.abfd) == bfd_target_elf_flavour)
	info.osabi = GDB_OSABI_SOLARIS;
    }

  /* First see if there is already a gdbarch that can satisfy the request.  */
  arches = gdbarch_list_lookup_by_info (arches, &info);
  if (arches != NULL)
    return arches->gdbarch;

  /* None found: is the request for a sparc architecture? */
  if (info.bfd_arch_info->arch != bfd_arch_sparc)
    return NULL;	/* No; then it's not for us.  */

  /* Yes: create a new gdbarch for the specified machine type.  */
  tdep = (struct gdbarch_tdep *) xmalloc (sizeof (struct gdbarch_tdep));
  gdbarch = gdbarch_alloc (&info, tdep);

  /* First set settings that are common for all sparc architectures.  */
  set_gdbarch_believe_pcc_promotion (gdbarch, 1);
  set_gdbarch_breakpoint_from_pc (gdbarch, sparc_breakpoint_from_pc);
  set_gdbarch_decr_pc_after_break (gdbarch, 0);
  set_gdbarch_double_bit (gdbarch, 8 * TARGET_CHAR_BIT);
  set_gdbarch_extract_struct_value_address (gdbarch,
					   sparc_extract_struct_value_address);
  set_gdbarch_deprecated_fix_call_dummy (gdbarch, sparc_gdbarch_fix_call_dummy);
  set_gdbarch_float_bit (gdbarch, 4 * TARGET_CHAR_BIT);
  set_gdbarch_deprecated_fp_regnum (gdbarch, SPARC_FP_REGNUM);
  set_gdbarch_fp0_regnum (gdbarch, SPARC_FP0_REGNUM);
  set_gdbarch_deprecated_frame_chain (gdbarch, sparc_frame_chain);
  set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, sparc_frame_init_saved_regs);
  set_gdbarch_deprecated_frame_saved_pc (gdbarch, sparc_frame_saved_pc);
  set_gdbarch_frameless_function_invocation (gdbarch, 
					     frameless_look_for_prologue);
  set_gdbarch_deprecated_get_saved_register (gdbarch, sparc_get_saved_register);
  set_gdbarch_deprecated_init_extra_frame_info (gdbarch, sparc_init_extra_frame_info);
  set_gdbarch_inner_than (gdbarch, core_addr_lessthan);
  set_gdbarch_int_bit (gdbarch, 4 * TARGET_CHAR_BIT);
  set_gdbarch_long_double_bit (gdbarch, 16 * TARGET_CHAR_BIT);
  set_gdbarch_long_long_bit (gdbarch, 8 * TARGET_CHAR_BIT);
  set_gdbarch_deprecated_max_register_raw_size (gdbarch, 8);
  set_gdbarch_deprecated_max_register_virtual_size (gdbarch, 8);
  set_gdbarch_deprecated_pop_frame (gdbarch, sparc_pop_frame);
  set_gdbarch_deprecated_push_return_address (gdbarch, sparc_push_return_address);
  set_gdbarch_deprecated_push_dummy_frame (gdbarch, sparc_push_dummy_frame);
  set_gdbarch_deprecated_reg_struct_has_addr
    (gdbarch, sparc_reg_struct_has_addr);
  set_gdbarch_return_value_on_stack (gdbarch, sparc_return_value_on_stack);
  set_gdbarch_deprecated_saved_pc_after_call (gdbarch, sparc_saved_pc_after_call);
  set_gdbarch_prologue_frameless_p (gdbarch, sparc_prologue_frameless_p);
  set_gdbarch_short_bit (gdbarch, 2 * TARGET_CHAR_BIT);
  set_gdbarch_skip_prologue (gdbarch, sparc_skip_prologue);
  set_gdbarch_sp_regnum (gdbarch, SPARC_SP_REGNUM);
  set_gdbarch_deprecated_use_generic_dummy_frames (gdbarch, 0);
  set_gdbarch_write_pc (gdbarch, generic_target_write_pc);

  /* Helper for function argument information.  */
  set_gdbarch_fetch_pointer_argument (gdbarch, sparc_fetch_pointer_argument);

  /*
   * Settings that depend only on 32/64 bit word size 
   */

  switch (info.bfd_arch_info->mach)
    {
    case bfd_mach_sparc:
    case bfd_mach_sparc_v8plus:
    case bfd_mach_sparc_v8plusa:
      /* 32-bit machine types: */

#ifdef SPARC32_CALL_DUMMY_ON_STACK
      set_gdbarch_deprecated_pc_in_call_dummy (gdbarch, deprecated_pc_in_call_dummy_on_stack);
      set_gdbarch_deprecated_call_dummy_address (gdbarch, sparc_call_dummy_address);
      set_gdbarch_deprecated_call_dummy_breakpoint_offset (gdbarch, 0x30);
      set_gdbarch_deprecated_call_dummy_length (gdbarch, 0x38);

      /* NOTE: cagney/2003-05-01: Using the just added push_dummy_code
	 architecture method, it is now possible to implement a
	 generic dummy frames based inferior function call that stores
	 the breakpoint (and struct info) on the stack.  Further, by
	 treating a SIGSEG at a breakpoint as equivalent to a SIGTRAP
	 it is even possible to make this work when the stack is
	 no-execute.

	 NOTE: cagney/2002-04-26: Based from info posted by Peter
	 Schauer around Oct '99.  Briefly, due to aspects of the SPARC
	 ABI, it isn't possible to use ON_STACK with a strictly
	 compliant compiler.

	 Peter Schauer writes ...

	 No, any call from GDB to a user function returning a
	 struct/union will fail miserably. Try this:

	 *NOINDENT*
	 struct x
	 {
           int a[4];
         };

	 struct x gx;

	 struct x
	 sret ()
	 {
	   return gx;
	 }

	 main ()
	 {
	   int i;
	   for (i = 0; i < 4; i++)
	     gx.a[i] = i + 1;
	   gx = sret ();
	 }
	 *INDENT*

	 Set a breakpoint at the gx = sret () statement, run to it and
	 issue a `print sret()'. It will not succed with your
	 approach, and I doubt that continuing the program will work
	 as well.

	 For details of the ABI see the Sparc Architecture Manual.  I
	 have Version 8 (Prentice Hall ISBN 0-13-825001-4) and the
	 calling conventions for functions returning aggregate values
	 are explained in Appendix D.3.  */

      set_gdbarch_call_dummy_location (gdbarch, ON_STACK);
      set_gdbarch_deprecated_call_dummy_words (gdbarch, call_dummy_32);
#else
      set_gdbarch_deprecated_pc_in_call_dummy (gdbarch, deprecated_pc_in_call_dummy_at_entry_point);
      set_gdbarch_deprecated_call_dummy_words (gdbarch, call_dummy_nil);
#endif
      set_gdbarch_deprecated_call_dummy_stack_adjust (gdbarch, 68);
      set_gdbarch_frame_args_skip (gdbarch, 68);
      set_gdbarch_function_start_offset (gdbarch, 0);
      set_gdbarch_long_bit (gdbarch, 4 * TARGET_CHAR_BIT);
      set_gdbarch_deprecated_npc_regnum (gdbarch, SPARC32_NPC_REGNUM);
      set_gdbarch_pc_regnum (gdbarch, SPARC32_PC_REGNUM);
      set_gdbarch_ptr_bit (gdbarch, 4 * TARGET_CHAR_BIT);
      set_gdbarch_deprecated_push_arguments (gdbarch, sparc32_push_arguments);

      set_gdbarch_deprecated_register_byte (gdbarch, sparc32_register_byte);
      set_gdbarch_deprecated_register_raw_size (gdbarch, sparc32_register_size);
      set_gdbarch_deprecated_register_size (gdbarch, 4);
      set_gdbarch_deprecated_register_virtual_size (gdbarch, sparc32_register_size);
      set_gdbarch_deprecated_register_virtual_type (gdbarch, sparc32_register_virtual_type);
#ifdef SPARC32_CALL_DUMMY_ON_STACK
      set_gdbarch_deprecated_sizeof_call_dummy_words (gdbarch, sizeof (call_dummy_32));
#else
      set_gdbarch_deprecated_sizeof_call_dummy_words (gdbarch, 0);
#endif
      set_gdbarch_deprecated_stack_align (gdbarch, sparc32_stack_align);
      set_gdbarch_deprecated_extra_stack_alignment_needed (gdbarch, 1);
      set_gdbarch_deprecated_store_struct_return (gdbarch, sparc32_store_struct_return);
      set_gdbarch_use_struct_convention (gdbarch, 
					 generic_use_struct_convention);
      set_gdbarch_deprecated_dummy_write_sp (gdbarch, deprecated_write_sp);
      tdep->y_regnum = SPARC32_Y_REGNUM;
      tdep->fp_max_regnum = SPARC_FP0_REGNUM + 32;
      tdep->intreg_size = 4;
      tdep->reg_save_offset = 0x60;
      tdep->call_dummy_call_offset = 0x24;
      break;

    case bfd_mach_sparc_v9:
    case bfd_mach_sparc_v9a:
      /* 64-bit machine types: */
    default:	/* Any new machine type is likely to be 64-bit.  */

#ifdef SPARC64_CALL_DUMMY_ON_STACK
      set_gdbarch_deprecated_pc_in_call_dummy (gdbarch, deprecated_pc_in_call_dummy_on_stack);
      set_gdbarch_deprecated_call_dummy_address (gdbarch, sparc_call_dummy_address);
      set_gdbarch_deprecated_call_dummy_breakpoint_offset (gdbarch, 8 * 4);
      set_gdbarch_deprecated_call_dummy_length (gdbarch, 192);
      set_gdbarch_call_dummy_location (gdbarch, ON_STACK);
      set_gdbarch_deprecated_call_dummy_start_offset (gdbarch, 148);
      set_gdbarch_deprecated_call_dummy_words (gdbarch, call_dummy_64);
#else
      set_gdbarch_deprecated_pc_in_call_dummy (gdbarch, deprecated_pc_in_call_dummy_at_entry_point);
      set_gdbarch_deprecated_call_dummy_words (gdbarch, call_dummy_nil);
#endif
      set_gdbarch_deprecated_call_dummy_stack_adjust (gdbarch, 128);
      set_gdbarch_frame_args_skip (gdbarch, 136);
      set_gdbarch_function_start_offset (gdbarch, 0);
      set_gdbarch_long_bit (gdbarch, 8 * TARGET_CHAR_BIT);
      set_gdbarch_deprecated_npc_regnum (gdbarch, SPARC64_NPC_REGNUM);
      set_gdbarch_pc_regnum (gdbarch, SPARC64_PC_REGNUM);
      set_gdbarch_ptr_bit (gdbarch, 8 * TARGET_CHAR_BIT);
      set_gdbarch_deprecated_push_arguments (gdbarch, sparc64_push_arguments);
      /* NOTE different for at_entry */
      set_gdbarch_deprecated_target_read_fp (gdbarch, sparc64_read_fp);
      set_gdbarch_read_sp (gdbarch, sparc64_read_sp);
      /* Some of the registers aren't 64 bits, but it's a lot simpler just
	 to assume they all are (since most of them are).  */
      set_gdbarch_deprecated_register_byte (gdbarch, sparc64_register_byte);
      set_gdbarch_deprecated_register_raw_size (gdbarch, sparc64_register_size);
      set_gdbarch_deprecated_register_size (gdbarch, 8);
      set_gdbarch_deprecated_register_virtual_size (gdbarch, sparc64_register_size);
      set_gdbarch_deprecated_register_virtual_type (gdbarch, sparc64_register_virtual_type);
#ifdef SPARC64_CALL_DUMMY_ON_STACK
      set_gdbarch_deprecated_sizeof_call_dummy_words (gdbarch, sizeof (call_dummy_64));
#else
      set_gdbarch_deprecated_sizeof_call_dummy_words (gdbarch, 0);
#endif
      set_gdbarch_deprecated_stack_align (gdbarch, sparc64_stack_align);
      set_gdbarch_deprecated_extra_stack_alignment_needed (gdbarch, 1);
      set_gdbarch_deprecated_store_struct_return (gdbarch, sparc64_store_struct_return);
      set_gdbarch_use_struct_convention (gdbarch, 
					 sparc64_use_struct_convention);
      set_gdbarch_deprecated_dummy_write_sp (gdbarch, sparc64_write_sp);
      tdep->y_regnum = SPARC64_Y_REGNUM;
      tdep->fp_max_regnum = SPARC_FP0_REGNUM + 48;
      tdep->intreg_size = 8;
      tdep->reg_save_offset = 0x90;
      tdep->call_dummy_call_offset = 148 + 4 * 5;
      break;
    }

  /* 
   * Settings that vary per-architecture:
   */

  switch (info.bfd_arch_info->mach)
    {
    case bfd_mach_sparc:
      set_gdbarch_extract_return_value (gdbarch, sparc32_extract_return_value);
      set_gdbarch_store_return_value (gdbarch, sparc32_store_return_value);
      set_gdbarch_num_regs (gdbarch, 72);
      set_gdbarch_deprecated_register_bytes (gdbarch, 32*4 + 32*4 + 8*4);
      set_gdbarch_register_name (gdbarch, sparc32_register_name);
      tdep->fp_register_bytes = 32 * 4;
      tdep->print_insn_mach = bfd_mach_sparc;
      break;
    case bfd_mach_sparc_v8plus:
      set_gdbarch_extract_return_value (gdbarch, sparc32_extract_return_value);
      set_gdbarch_store_return_value (gdbarch, sparc32_store_return_value);
      set_gdbarch_num_regs (gdbarch, 72);
      set_gdbarch_deprecated_register_bytes (gdbarch, 32*4 + 32*4 + 8*4);
      set_gdbarch_register_name (gdbarch, sparc32_register_name);
      tdep->print_insn_mach = bfd_mach_sparc;
      tdep->fp_register_bytes = 32 * 4;
      break;
    case bfd_mach_sparc_v8plusa:
      set_gdbarch_extract_return_value (gdbarch, sparc32_extract_return_value);
      set_gdbarch_store_return_value (gdbarch, sparc32_store_return_value);
      set_gdbarch_num_regs (gdbarch, 72);
      set_gdbarch_deprecated_register_bytes (gdbarch, 32*4 + 32*4 + 8*4);
      set_gdbarch_register_name (gdbarch, sparc32_register_name);
      tdep->fp_register_bytes = 32 * 4;
      tdep->print_insn_mach = bfd_mach_sparc;
      break;
    case bfd_mach_sparc_v9:
      set_gdbarch_deprecated_extract_return_value (gdbarch, sparc64_extract_return_value);
      set_gdbarch_num_regs (gdbarch, 125);
      set_gdbarch_deprecated_register_bytes (gdbarch, 32*8 + 32*8 + 45*8);
      set_gdbarch_register_name (gdbarch, sparc64_register_name);
      set_gdbarch_deprecated_store_return_value (gdbarch, sparc_store_return_value);
      tdep->fp_register_bytes = 64 * 4;
      tdep->print_insn_mach = bfd_mach_sparc_v9a;
      break;
    case bfd_mach_sparc_v9a:
      set_gdbarch_deprecated_extract_return_value (gdbarch, sparc64_extract_return_value);
      set_gdbarch_num_regs (gdbarch, 125);
      set_gdbarch_deprecated_register_bytes (gdbarch, 32*8 + 32*8 + 45*8);
      set_gdbarch_register_name (gdbarch, sparc64_register_name);
      set_gdbarch_deprecated_store_return_value (gdbarch, sparc_store_return_value);
      tdep->fp_register_bytes = 64 * 4;
      tdep->print_insn_mach = bfd_mach_sparc_v9a;
      break;
    }

  set_gdbarch_print_insn (gdbarch, print_insn_sparc);

  /* Hook in OS ABI-specific overrides, if they have been registered.  */
  gdbarch_init_osabi (info, gdbarch);

  return gdbarch;
}

static void
sparc_dump_tdep (struct gdbarch *current_gdbarch, struct ui_file *file)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

  if (tdep == NULL)
    return;

  fprintf_unfiltered (file, "sparc_dump_tdep: fp_register_bytes = %d\n",
		      tdep->fp_register_bytes);
  fprintf_unfiltered (file, "sparc_dump_tdep: y_regnum = %d\n",
		      tdep->y_regnum);
  fprintf_unfiltered (file, "sparc_dump_tdep: fp_max_regnum = %d\n",
		      tdep->fp_max_regnum);
  fprintf_unfiltered (file, "sparc_dump_tdep: intreg_size = %d\n",
		      tdep->intreg_size);
  fprintf_unfiltered (file, "sparc_dump_tdep: reg_save_offset = %d\n",
		      tdep->reg_save_offset);
  fprintf_unfiltered (file, "sparc_dump_tdep: call_dummy_call_offset = %d\n",
		      tdep->call_dummy_call_offset);
  fprintf_unfiltered (file, "sparc_dump_tdep: print_insn_match = %d\n",
		      tdep->print_insn_mach);
@


1.133
log
@2003-10-06  Andrew Cagney  <cagney@@redhat.com>

	* breakpoint.c, breakpoint.h: Remove obsolete code and comments.
	* buildsym.c, dbxread.c, gdbtypes.c, mdebugread.c: Ditto.
	* monitor.c, sparc-tdep.c, stabsread.c: Ditto.
	* stabsread.h, xcoffread.c: Ditto.
@
text
@d436 1
a436 1
      if (name && STREQ (name, "ucbsigvechandler"))
@


1.132
log
@2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_RAW_SIZE): Rename
	REGISTER_RAW_SIZE.
	* gdbarch.h, gdbarch.c: Re-generate.
	* aix-thread.c, alpha-tdep.h, arm-tdep.c, core-sol2.c: Update.
	* cris-tdep.c, dve3900-rom.c, findvar.c, frame.c: Update.
	* hppa-tdep.c, hppab-nat.c, hppah-nat.c, hppam3-nat.c: Update.
	* hpux-thread.c, i386gnu-nat.c, ia64-aix-nat.c: Update.
	* ia64-linux-nat.c, ia64-tdep.c, infcmd.c, infptrace.c: Update.
	* infrun.c, irix5-nat.c, lynx-nat.c, mips-linux-tdep.c: Update.
	* mips-nat.c, mips-tdep.c, mipsv4-nat.c, mn10300-tdep.c: Update.
	* monitor.c, ns32k-tdep.c, ppc-linux-nat.c, regcache.c: Update.
	* remote-e7000.c, remote-mips.c, remote-sim.c: Update.
	* remote-vxmips.c, remote-vxsparc.c, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, rs6000-tdep.c, s390-tdep.c: Update.
	* sh64-tdep.c, sparc-nat.c, sparc-tdep.c, stack.c: Update.
	* target.c, tracepoint.c, v850-tdep.c, v850ice.c, valops.c: Update.
	* vax-tdep.c, vax-tdep.h, x86-64-tdep.c, xstormy16-tdep.c: Update.
	* config/m68k/tm-delta68.h, config/m68k/tm-vx68.h: Update.
	* config/sparc/tm-sparc.h, config/sparc/tm-sparclynx.h: Update.

2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	REGISTER_RAW_SIZE to DEPRECATED_REGISTER_RAW_SIZE.
	* gdb.texinfo (Packets, Stop Reply Packets): Ditto.
	* gdbint.texinfo (Target Architecture Definition): Rename

2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c: Rename REGISTER_RAW_SIZE to
	DEPRECATED_REGISTER_RAW_SIZE.
@
text
@a54 4
#if 0
// OBSOLETE /* Does the target have Floating Point registers?  */
// OBSOLETE #define SPARC_HAS_FPU     (gdbarch_tdep (current_gdbarch)->has_fpu)
#endif
a66 3
#if 0
    // OBSOLETE     int has_fpu;
#endif
a92 9
#if 0
// OBSOLETE /* Some machines, such as Fujitsu SPARClite 86x, have a bi-endian mode
// OBSOLETE    where instructions are big-endian and data are little-endian.
// OBSOLETE    This flag is set when we detect that the target is of this type. */
// OBSOLETE 
// OBSOLETE int bi_endian = 0;
#endif


a2108 18
#if 0
// OBSOLETE static void
// OBSOLETE sparclet_print_registers_info (struct gdbarch *gdbarch,
// OBSOLETE 			       struct ui_file *file,
// OBSOLETE 			       struct frame_info *frame,
// OBSOLETE 			       int regnum, int print_all)
// OBSOLETE {
// OBSOLETE   sparc_print_registers (gdbarch, file, frame, regnum, print_all, NULL);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE sparclet_do_registers_info (int regnum, int all)
// OBSOLETE {
// OBSOLETE   sparclet_print_registers_info (current_gdbarch, gdb_stdout,
// OBSOLETE 				 deprecated_selected_frame, regnum, all);
// OBSOLETE }
#endif

a2388 11
#if 0
// OBSOLETE extern void
// OBSOLETE sparclet_store_return_value (struct type *type, char *valbuf)
// OBSOLETE {
// OBSOLETE   /* Other values are returned in register %o0.  */
// OBSOLETE   deprecated_write_register_bytes (REGISTER_BYTE (O0_REGNUM), valbuf,
// OBSOLETE 				   TYPE_LENGTH (type));
// OBSOLETE }
#endif


a2452 17

#if 0
// OBSOLETE   /* If this is a bi-endian target, GDB has written the call dummy
// OBSOLETE      in little-endian order.  We must byte-swap it back to big-endian. */
// OBSOLETE   if (bi_endian)
// OBSOLETE     {
// OBSOLETE       for (i = 0; i < CALL_DUMMY_LENGTH; i += 4)
// OBSOLETE 	{
// OBSOLETE 	  char tmp = dummy[i];
// OBSOLETE 	  dummy[i] = dummy[i + 3];
// OBSOLETE 	  dummy[i + 3] = tmp;
// OBSOLETE 	  tmp = dummy[i + 1];
// OBSOLETE 	  dummy[i + 1] = dummy[i + 2];
// OBSOLETE 	  dummy[i + 2] = tmp;
// OBSOLETE 	}
// OBSOLETE     }
#endif
a2454 20

#if 0
// OBSOLETE /* Set target byte order based on machine type. */
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE sparc_target_architecture_hook (const bfd_arch_info_type *ap)
// OBSOLETE {
// OBSOLETE   int i, j;
// OBSOLETE 
// OBSOLETE   if (ap->mach == bfd_mach_sparc_sparclite_le)
// OBSOLETE     {
// OBSOLETE       target_byte_order = BFD_ENDIAN_LITTLE;
// OBSOLETE       bi_endian = 1;
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     bi_endian = 0;
// OBSOLETE   return 1;
// OBSOLETE }
#endif

a2469 2

  /* OBSOLETE target_architecture_hook = sparc_target_architecture_hook; */
a2698 14
#if 0
// OBSOLETE extern void 
// OBSOLETE sparclet_extract_return_value (struct type *type,
// OBSOLETE 			       char *regbuf, 
// OBSOLETE 			       char *valbuf)
// OBSOLETE {
// OBSOLETE   regbuf += REGISTER_RAW_SIZE (O0_REGNUM) * 8;
// OBSOLETE   if (TYPE_LENGTH (type) < REGISTER_RAW_SIZE (O0_REGNUM))
// OBSOLETE     regbuf += REGISTER_RAW_SIZE (O0_REGNUM) - TYPE_LENGTH (type);
// OBSOLETE 
// OBSOLETE   memcpy ((void *) valbuf, regbuf, TYPE_LENGTH (type));
// OBSOLETE }
#endif

a2775 65
#if 0
// OBSOLETE static const char *
// OBSOLETE sparclite_register_name (int regno)
// OBSOLETE {
// OBSOLETE   static char *register_names[] = 
// OBSOLETE   { "g0", "g1", "g2", "g3", "g4", "g5", "g6", "g7",
// OBSOLETE     "o0", "o1", "o2", "o3", "o4", "o5", "sp", "o7",
// OBSOLETE     "l0", "l1", "l2", "l3", "l4", "l5", "l6", "l7",
// OBSOLETE     "i0", "i1", "i2", "i3", "i4", "i5", "fp", "i7",
// OBSOLETE 
// OBSOLETE     "f0",  "f1",  "f2",  "f3",  "f4",  "f5",  "f6",  "f7",
// OBSOLETE     "f8",  "f9",  "f10", "f11", "f12", "f13", "f14", "f15",
// OBSOLETE     "f16", "f17", "f18", "f19", "f20", "f21", "f22", "f23",
// OBSOLETE     "f24", "f25", "f26", "f27", "f28", "f29", "f30", "f31",
// OBSOLETE 
// OBSOLETE     "y", "psr", "wim", "tbr", "pc", "npc", "fpsr", "cpsr",
// OBSOLETE     "dia1", "dia2", "dda1", "dda2", "ddv1", "ddv2", "dcr", "dsr" 
// OBSOLETE   };
// OBSOLETE 
// OBSOLETE   if (regno < 0 ||
// OBSOLETE       regno >= (sizeof (register_names) / sizeof (register_names[0])))
// OBSOLETE     return NULL;
// OBSOLETE   else
// OBSOLETE     return register_names[regno];
// OBSOLETE }
#endif

#if 0
// OBSOLETE static const char *
// OBSOLETE sparclet_register_name (int regno)
// OBSOLETE {
// OBSOLETE   static char *register_names[] = 
// OBSOLETE   { "g0", "g1", "g2", "g3", "g4", "g5", "g6", "g7",
// OBSOLETE     "o0", "o1", "o2", "o3", "o4", "o5", "sp", "o7",
// OBSOLETE     "l0", "l1", "l2", "l3", "l4", "l5", "l6", "l7",
// OBSOLETE     "i0", "i1", "i2", "i3", "i4", "i5", "fp", "i7",
// OBSOLETE 
// OBSOLETE     "", "", "", "", "", "", "", "", /* no floating point registers */
// OBSOLETE     "", "", "", "", "", "", "", "",
// OBSOLETE     "", "", "", "", "", "", "", "",
// OBSOLETE     "", "", "", "", "", "", "", "",
// OBSOLETE 
// OBSOLETE     "y", "psr", "wim", "tbr", "pc", "npc", "", "", /* no FPSR or CPSR */
// OBSOLETE     "ccsr", "ccpr", "cccrcr", "ccor", "ccobr", "ccibr", "ccir", "", 
// OBSOLETE 
// OBSOLETE     /*       ASR15                 ASR19 (don't display them) */    
// OBSOLETE     "asr1",  "", "asr17", "asr18", "", "asr20", "asr21", "asr22"
// OBSOLETE     /* None of the rest get displayed */
// OBSOLETE #if 0
// OBSOLETE     "awr0",  "awr1",  "awr2",  "awr3",  "awr4",  "awr5",  "awr6",  "awr7",  
// OBSOLETE     "awr8",  "awr9",  "awr10", "awr11", "awr12", "awr13", "awr14", "awr15", 
// OBSOLETE     "awr16", "awr17", "awr18", "awr19", "awr20", "awr21", "awr22", "awr23", 
// OBSOLETE     "awr24", "awr25", "awr26", "awr27", "awr28", "awr29", "awr30", "awr31", 
// OBSOLETE     "apsr"
// OBSOLETE #endif /* 0 */
// OBSOLETE   };
// OBSOLETE 
// OBSOLETE   if (regno < 0 ||
// OBSOLETE       regno >= (sizeof (register_names) / sizeof (register_names[0])))
// OBSOLETE     return NULL;
// OBSOLETE   else
// OBSOLETE     return register_names[regno];
// OBSOLETE }
#endif

a3127 4
#if 0
      // OBSOLETE     case bfd_mach_sparc_sparclet:
      // OBSOLETE     case bfd_mach_sparc_sparclite:
#endif
a3129 3
#if 0
      // OBSOLETE     case bfd_mach_sparc_sparclite_le:
#endif
a3292 3
#if 0
      // OBSOLETE       tdep->has_fpu = 1;	/* (all but sparclet and sparclite) */
#endif
a3295 24
#if 0
      // OBSOLETE     case bfd_mach_sparc_sparclet:
      // OBSOLETE       set_gdbarch_deprecated_extract_return_value (gdbarch, sparclet_extract_return_value);
      // OBSOLETE       set_gdbarch_num_regs (gdbarch, 32 + 32 + 8 + 8 + 8);
      // OBSOLETE       set_gdbarch_register_bytes (gdbarch, 32*4 + 32*4 + 8*4 + 8*4 + 8*4);
      // OBSOLETE       set_gdbarch_register_name (gdbarch, sparclet_register_name);
      // OBSOLETE       set_gdbarch_deprecated_store_return_value (gdbarch, sparclet_store_return_value);
      // OBSOLETE       tdep->has_fpu = 0;	/* (all but sparclet and sparclite) */
      // OBSOLETE       tdep->fp_register_bytes = 0;
      // OBSOLETE       tdep->print_insn_mach = bfd_mach_sparc_sparclet;
      // OBSOLETE       break;
#endif
#if 0
      // OBSOLETE     case bfd_mach_sparc_sparclite:
      // OBSOLETE       set_gdbarch_deprecated_extract_return_value (gdbarch, sparc32_extract_return_value);
      // OBSOLETE       set_gdbarch_num_regs (gdbarch, 80);
      // OBSOLETE       set_gdbarch_register_bytes (gdbarch, 32*4 + 32*4 + 8*4 + 8*4);
      // OBSOLETE       set_gdbarch_register_name (gdbarch, sparclite_register_name);
      // OBSOLETE       set_gdbarch_deprecated_store_return_value (gdbarch, sparc_store_return_value);
      // OBSOLETE       tdep->has_fpu = 0;	/* (all but sparclet and sparclite) */
      // OBSOLETE       tdep->fp_register_bytes = 0;
      // OBSOLETE       tdep->print_insn_mach = bfd_mach_sparc_sparclite;
      // OBSOLETE       break;
#endif
a3303 3
#if 0
      // OBSOLETE       tdep->has_fpu = 1;	/* (all but sparclet and sparclite) */
#endif
a3310 3
#if 0
      // OBSOLETE       tdep->has_fpu = 1;	/* (all but sparclet and sparclite) */
#endif
a3313 12
#if 0
// OBSOLETE     case bfd_mach_sparc_sparclite_le:
// OBSOLETE       set_gdbarch_deprecated_extract_return_value (gdbarch, sparc32_extract_return_value);
// OBSOLETE       set_gdbarch_num_regs (gdbarch, 80);
// OBSOLETE       set_gdbarch_register_bytes (gdbarch, 32*4 + 32*4 + 8*4 + 8*4);
// OBSOLETE       set_gdbarch_register_name (gdbarch, sparclite_register_name);
// OBSOLETE       set_gdbarch_deprecated_store_return_value (gdbarch, sparc_store_return_value);
// OBSOLETE       tdep->has_fpu = 0;	/* (all but sparclet and sparclite) */
// OBSOLETE       tdep->fp_register_bytes = 0;
// OBSOLETE       tdep->print_insn_mach = bfd_mach_sparc_sparclite;
// OBSOLETE       break;
#endif
a3319 3
#if 0
      // OBSOLETE       tdep->has_fpu = 1;	/* (all but sparclet and sparclite) */
#endif
a3328 3
#if 0
      // OBSOLETE       tdep->has_fpu = 1;	/* (all but sparclet and sparclite) */
#endif
a3349 4
#if 0
  // OBSOLETE   fprintf_unfiltered (file, "sparc_dump_tdep: has_fpu = %d\n",
  // OBSOLETE 		      tdep->has_fpu);
#endif
@


1.131
log
@2003-09-30  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c: Rename REGISTER_VIRTUAL_SIZE to
	DEPRECATED_REGISTER_VIRTUAL_SIZE.

2003-09-30  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_VIRTUAL_SIZE): Rename
	REGISTER_VIRTUAL_SIZE.
	* gdbarch.h, gdbarch.c: Regenerate.
	* vax-tdep.h, sparc-tdep.c, regcache.h: Update.
	* regcache.c, mn10300-tdep.c, mips-tdep.c: Update.
	* infcmd.c, frame.c, findvar.c, cris-tdep.c: Update.

2003-09-30  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	REGISTER_VIRTUAL_SIZE to DEPRECATED_REGISTER_VIRTUAL_SIZE.
	(Target Architecture Definition):
@
text
@d818 1
a818 1
	  store_unsigned_integer (raw_buffer, REGISTER_RAW_SIZE (regnum), get_frame_pc (frame));
d926 1
a926 1
	      store_unsigned_integer (raw_buffer, REGISTER_RAW_SIZE (regnum), addr);
d933 1
a933 1
	read_memory (addr, raw_buffer, REGISTER_RAW_SIZE (regnum));
d977 1
a977 1
				      REGISTER_RAW_SIZE (PC_REGNUM) * 7);
d980 1
a980 1
				      REGISTER_RAW_SIZE (PSTATE_REGNUM));
d988 1
a988 1
				      REGISTER_RAW_SIZE (Y_REGNUM) * 8);
d1311 1
a1311 1
					   REGISTER_RAW_SIZE (PS_REGNUM)));
d1316 1
a1316 1
					 REGISTER_RAW_SIZE (Y_REGNUM)));
d1322 1
a1322 1
					   REGISTER_RAW_SIZE (PC_REGNUM)));
d1326 1
a1326 1
					     REGISTER_RAW_SIZE (DEPRECATED_NPC_REGNUM)));
d1333 1
a1333 1
					     REGISTER_RAW_SIZE (PC_REGNUM)));
d1716 1
a1716 1
	  memcpy (to, from, REGISTER_RAW_SIZE (regi));
d1725 1
a1725 1
	memcpy (to, from, REGISTER_RAW_SIZE (FPS_REGNUM));
d2074 1
a2074 1
	  for (j = 0; j < REGISTER_RAW_SIZE (i); j++)
d2080 1
a2080 1
		idx = REGISTER_RAW_SIZE (i) - 1 - j;
d2411 1
a2411 1
  if (TYPE_LENGTH (type) < REGISTER_RAW_SIZE (regno))
d2413 2
a2414 2
      memset (buffer, 0, REGISTER_RAW_SIZE (regno));
      memcpy (buffer + REGISTER_RAW_SIZE (regno) - TYPE_LENGTH (type), valbuf,
d2725 1
a2725 1
  int regsize = REGISTER_RAW_SIZE (O0_REGNUM);
@


1.130
log
@2003-09-29  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_VIRTUAL_TYPE): Rename
	DEPRECATED_REGISTER_VIRTUAL_TYPE.
	* gdbarch.h, gdbarch.c: Regenerate.
	* arch-utils.c,	hppa-tdep.c, regcache.c, regcache.h: Update.
	* sh64-tdep.c, sparc-tdep.c: Update.

2003-09-30  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	REGISTER_VIRTUAL_TYPE to DEPRECATED_REGISTER_VIRTUAL_TYPE.
@
text
@d2062 1
a2062 1
      memcpy (virtual_buffer, raw_buffer, REGISTER_VIRTUAL_SIZE (i));
@


1.129
log
@2003-09-28  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (frame_read_unsigned_register): Delete function.
	* frame.h (frame_read_unsigned_register): Delete declaration.
	* sparc-tdep.c (sparc_init_extra_frame_info): Use
	get_frame_register_unsigned.
	(sparc_frame_saved_pc, sparc_pop_frame): Ditto.
	* m68hc11-tdep.c (m68hc11_print_register): Ditto.
	* d10v-tdep.c (d10v_print_registers_info): Ditto.

	* frame.h (frame_read_register): Delete declaration.
	* frame.c (frame_read_register): Delete function.
	* arch-utils.c (legacy_register_to_value): Use get_frame_register.
	* sparc-tdep.c (sparc_fetch_pointer_argument): Ditto.
	* rs6000-tdep.c (rs6000_fetch_pointer_argument): Ditto.
	* mips-tdep.c (mips_register_to_value): Ditto.
	* hppa-tdep.c (hppa_fetch_pointer_argument): Ditto.
	* d10v-tdep.c (d10v_print_registers_info): Ditto.

	* frame.c (frame_read_signed_register): Delete function.
	(frame_read_unsigned_register): Update comments.
	* frame.h (frame_read_signed_register): Delete declaration.
	* h8300-tdep.c (h8300_print_register): Use
	get_frame_register_signed.
	* m68hc11-tdep.c (m68hc11_print_register): Ditto.
@
text
@d2035 1
a2035 1
	      if (TYPE_CODE (REGISTER_VIRTUAL_TYPE (i)) == TYPE_CODE_FLT)
d2037 1
a2037 1
	      if (TYPE_VECTOR (REGISTER_VIRTUAL_TYPE (i)))
d2066 1
a2066 1
      if (TYPE_CODE (REGISTER_VIRTUAL_TYPE (i)) == TYPE_CODE_FLT)
d2070 1
a2070 1
	  val_print (REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0,
d2088 1
a2088 1
	  val_print (REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0,
d2092 1
a2092 1
	  if (TYPE_VECTOR (REGISTER_VIRTUAL_TYPE (i)) == 0)
d2095 1
a2095 1
	      val_print (REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0,
@


1.128
log
@2003-09-17  Andrew Cagney  <cagney@@redhat.com>

	* sparc-tdep.c (legacy_register_name): Delete function.
	* mips-tdep.c (mips_dump_tdep): Do not print REGISTER_NAME.
	(mips_gdbarch_init): Refer to MIPS_REGISTER_NAME in comments.
	* infcmd.c (gdb_register_name): Delete variable.
	* gdbarch.sh (SDB_REG_TO_REGNUM): Delete reference to
	REGISTER_NAME and "tm.h".
	* gdbarch.h, gdbarch.c: Regenerate.
	* dpx2-nat.c (regmap): Refer to REGISTER_NAME and not
	REGISTER_NAMES in comments.
	* remote-st.c (get_reg_name), i386b-nat.c (tregmap): Ditto.
	* m68klinux-nat.c (regmap): Ditto.

2003-09-18  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	documentation on REGISTER_NAMES.
@
text
@d302 1
a302 1
	  frame_read_unsigned_register (fi, DEPRECATED_FP_REGNUM, &tmp);
d342 1
a342 1
		frame_read_unsigned_register (fi, I7_REGNUM, &tmp);
d458 1
a458 1
	frame_read_unsigned_register (frame, O0_REGNUM + 2, &tmp);
d477 1
a477 1
      frame_read_unsigned_register (frame, O7_REGNUM, &tmp);
d1340 1
a1340 1
	  frame_read_unsigned_register (frame, O7_REGNUM, &tmp);
d3172 1
a3172 1
  frame_read_register (frame, O0_REGNUM + argi, &addr);
@


1.127
log
@2003-09-17  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_NPC_REGNUM): Deprecate NPC_REGNUM.
	* gdbarch.h, gdbarch.c: Regenerate.
	* core-sol2.c, hppa-tdep.c, lynx-nat.c, procfs.c: Update.
	* regcache.c, remote-vxsparc.c, sparc-linux-nat.c: Update.
	* sparc-nat.c, sparc-tdep.c, sparc64-tdep.c: Update.
	* sparcnbsd-tdep.c: Update.
@
text
@a2817 18
/* MULTI_ARCH support */

const char *
legacy_register_name (int i)
{
#ifdef REGISTER_NAMES
  static char *names[] = REGISTER_NAMES;
  if (i < 0 || i >= (sizeof (names) / sizeof (*names)))
    return NULL;
  else
    return names[i];
#else
  internal_error (__FILE__, __LINE__,
		  "legacy_register_name: called.");
  return NULL;
#endif
}

@


1.127.2.1
log
@New SPARC target.
* configure.tgt: Remove support for old SPARC targets.
* configure.tgt: Remove support for old SPARC hosts.
* Makefile.in: Remove support for old SPARC hosts and targets.
(sparc-tdep.o): Update dependencies.
(sparc-sol2-tdep.o, sparc-sol2-nat.o): New dependencies.
* sparc-tdep.c, sparc-tdep.h: New implementation.
* sparc-sol2-tdep.c, sparc-sol2-nat.c: New files.
* config/sparc/sparc.mt: New files.
* config/sparc/sol2.mt, config/sparc/sol2.mh: New files.
* config/sparc/tm-sol2.h: New file.
@
text
@d1 1
a1 1
/* Target-dependent code for SPARC.
d3 3
a5 1
   Copyright 2003 Free Software Foundation, Inc.
d24 2
a27 1
#include "dis-asm.h"
a28 4
#include "frame-base.h"
#include "frame-unwind.h"
#include "gdbcore.h"
#include "gdbtypes.h"
a29 4
#include "symtab.h"
#include "objfiles.h"
#include "osabi.h"
#include "regcache.h"
d32 13
d46 1
a47 1
#include "gdb_string.h"
d49 88
a136 1
#include "sparc-tdep.h"
d138 2
a139 25
/* This file implements the The SPARC 32-bit ABI as defined by the
   section "Low-Level System Information" of the SPARC Compliance
   Definition (SCD) 2.4.1, which is the 32-bit System V psABI for
   SPARC.  The SCD lists changes with respect to the origional 32-bit
   psABI as defined in the "System V ABI, SPARC Processor
   Supplement".

   Note that if we talk about SunOS, we mean SunOS 4.x, which was
   BSD-based, which is sometimes (retroactively?) referred to as
   Solaris 1.x.  If we talk about Solaris we mean Solaris 2.x and
   above (Solaris 7, 8 and 9 are nothing but Solaris 2.7, 2.8 and 2.9
   suffering from severe version number inflation).  Solaris 2.x is
   also known as SunOS 5.x, since that's what uname(1).  Solaris 2.x
   is SVR4-based.  */

/* Please use the sparc32_-prefix for 32-bit specific code, the
   sparc64_-prefix for 64-bit specific code and the sparc_-prefix for
   code can handle both.  The 64-bit specific code lives in
   sparc64-tdep.c; don't add any here.  */

/* The stack pointer is offset from the stack frame by a BIAS of 2047
   (0x7ff) for 64-bit code.  BIAS is likely to be defined on SPARC
   hosts, so undefine it first.  */
#undef BIAS
#define BIAS 2047
d141 1
a141 1
/* Macros to extract fields from SPARC instructions.  */
d149 1
d151 1
d153 1
d155 2
d158 25
d184 2
a185 2
/* Fetch the instruction at PC.  Instructions are always big-endian
   even if the processor operates in little-endian mode.  */
d187 3
a189 2
static unsigned long
sparc_fetch_instruction (CORE_ADDR pc)
d191 3
a193 3
  unsigned char buf[4];
  unsigned long insn;
  int i;
d195 13
a207 1
  read_memory (pc, buf, sizeof (buf));
d209 20
a228 51
  insn = 0;
  for (i = 0; i < sizeof (buf); i++)
    insn = (insn << 8) | buf[i];
  return insn;
}

/* Return the contents if register REGNUM as an address.  */

static CORE_ADDR
sparc_address_from_register (int regnum)
{
  ULONGEST addr;

  regcache_cooked_read_unsigned (current_regcache, regnum, &addr);
  return addr;
}


/* The functions on this page are intended to be used to classify
   function arguments.  */

/* Check whether TYPE is "Integral or Pointer".  */

static int
sparc_integral_or_pointer_p (const struct type *type)
{
  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_INT:
    case TYPE_CODE_BOOL:
    case TYPE_CODE_CHAR:
    case TYPE_CODE_ENUM:
    case TYPE_CODE_RANGE:
      {
	/* We have byte, half-word, word and extended-word/doubleword
           integral types.  The doubleword is an extension to the
           origional 32-bit ABI by the SCD 2.4.x.  */
	int len = TYPE_LENGTH (type);
	return (len == 1 || len == 2 || len == 4 || len == 8);
      }
      return 1;
    case TYPE_CODE_PTR:
    case TYPE_CODE_REF:
      {
	/* Allow either 32-bit or 64-bit pointers.  */
	int len = TYPE_LENGTH (type);
	return (len == 4 || len == 8);
      }
      return 1;
    default:
      break;
d230 1
a230 10

  return 0;
}

/* Check whether TYPE is "Floating".  */

static int
sparc_floating_p (const struct type *type)
{
  switch (TYPE_CODE (type))
d232 2
a233 8
    case TYPE_CODE_FLT:
      {
	int len = TYPE_LENGTH (type);
	return (len == 4 || len == 8 || len == 16);
      }
    default:
      break;
    }
d235 2
a236 4
  return 0;
}

/* Check whether TYPE is "Structure or Union".  */
d238 2
a239 10
static int
sparc_structure_or_union_p (const struct type *type)
{
  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_STRUCT:
    case TYPE_CODE_UNION:
      return 1;
    default:
      break;
a240 2

  return 0;
d242 2
a243 4

/* Register information.  */

static const char *sparc32_register_names[] =
d245 9
a253 11
  "g0", "g1", "g2", "g3", "g4", "g5", "g6", "g7",
  "o0", "o1", "o2", "o3", "o4", "o5", "sp", "o7",
  "l0", "l1", "l2", "l3", "l4", "l5", "l6", "l7",
  "i0", "i1", "i2", "i3", "i4", "i5", "fp", "i7",

  "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7",
  "f8", "f9", "f10", "f11", "f12", "f13", "f14", "f15",
  "f16", "f17", "f18", "f19", "f20", "f21", "f22", "f23",
  "f24", "f25", "f26", "f27", "f28", "f28", "f30", "f31",

  "y", "psr", "wim", "tbr", "pc", "npc", "fsr", "csr",
d256 5
a260 2
/* Total number of registers.  */
#define SPARC32_NUM_REGS ARRAY_SIZE (sparc32_register_names)
d262 2
a263 4
/* Return the name of register REGNUM.  */

static const char *
sparc32_register_name (int regnum)
d265 42
a306 42
  if (regnum >= 0 && regnum < SPARC32_NUM_REGS)
    return sparc32_register_names[regnum];

  return NULL;
}

/* Return the GDB type object for the "standard" data type of data in
   register REGNUM. */

static struct type *
sparc32_register_type (struct gdbarch *gdbarch, int regnum)
{
  if (regnum >= SPARC_F0_REGNUM && regnum <= SPARC_F31_REGNUM)
    return builtin_type_float;

  if (regnum == SPARC_SP_REGNUM || regnum == SPARC_FP_REGNUM)
    return builtin_type_void_data_ptr;

  if (regnum == SPARC32_PC_REGNUM || regnum == SPARC32_NPC_REGNUM)
    return builtin_type_void_func_ptr;

  return builtin_type_int32;
}

static CORE_ADDR
sparc32_push_dummy_code (struct gdbarch *gdbarch, CORE_ADDR sp,
			 CORE_ADDR funcaddr, int using_gcc,
			 struct value **args, int nargs,
			 struct type *value_type,
			 CORE_ADDR *real_pc, CORE_ADDR *bp_addr)
{
  *bp_addr = sp - 4;
  *real_pc = funcaddr;

  if (using_struct_return (value_type, using_gcc))
    {
      char buf[4];

      /* This is an UNIMP instruction.  */
      store_unsigned_integer (buf, 4, TYPE_LENGTH (value_type) & 0x1fff);
      write_memory (sp - 8, buf, 4);
      return sp - 8;
d309 15
a323 2
  return sp - 4;
}
d325 8
a332 14
static CORE_ADDR
sparc32_store_arguments (struct regcache *regcache, int nargs,
			 struct value **args, CORE_ADDR sp,
			 int struct_return, CORE_ADDR struct_addr)
{
  /* Number of words in the "parameter array".  */
  int num_elements = 0;
  int element = 0;
  int i;

  for (i = 0; i < nargs; i++)
    {
      struct type *type = VALUE_TYPE (args[i]);
      int len = TYPE_LENGTH (type);
d334 2
a335 5
      if (sparc_structure_or_union_p (type)
	  || (sparc_floating_p (type) && len == 16))
	{
	  /* Structure, Union and Quad-Precision Arguments.  */
	  sp -= len;
d337 1
a337 3
	  /* Use doubleword alignment for these values.  That's always
             correct, and wasting a few bytes shouldn't be a problem.  */
	  sp &= ~0x7;
d339 24
a362 9
	  write_memory (sp, VALUE_CONTENTS (args[i]), len);
	  args[i] = value_from_pointer (lookup_pointer_type (type), sp);
	  num_elements++;
	}
      else if (sparc_floating_p (type))
	{
	  /* Floating arguments.  */
	  gdb_assert (len == 4 || len == 8);
	  num_elements += (len / 4);
d366 26
a391 6
	  /* Integral and pointer arguments.  */
	  gdb_assert (sparc_integral_or_pointer_p (type));

	  if (len < 4)
	    args[i] = value_cast (builtin_type_int32, args[i]);
	  num_elements += ((len + 3) / 4);
d394 26
d421 2
a422 2
  /* Always allocate at least six words.  */
  sp -= max (6, num_elements) * 4;
d424 1
a424 3
  /* The psABI says that "Software convention requires space for the
     struct/union return value pointer, even if the word is unused."  */
  sp -= 4;
d426 5
a430 4
  /* The psABI says that "Although software convention and the
     operating system require every stack frame to be doubleword
     aligned."  */
  sp &= ~0x7;
d432 1
a432 1
  for (i = 0; i < nargs; i++)
d434 2
a435 3
      char *valbuf = VALUE_CONTENTS (args[i]);
      struct type *type = VALUE_TYPE (args[i]);
      int len = TYPE_LENGTH (type);
d437 3
a439 1
      gdb_assert (len == 4 || len == 8);
d441 4
a444 3
      if (element < 6)
	{
	  int regnum = SPARC_O0_REGNUM + element;
d446 1
a446 4
	  regcache_cooked_write (regcache, regnum, valbuf);
	  if (len > 4 && element < 5)
	    regcache_cooked_write (regcache, regnum + 1, valbuf + 4);
	}
d448 6
a453 4
      /* Always store the argument in memory.  */
      write_memory (sp + 4 + element * 4, valbuf, len);
      element += len / 4;
    }
d455 6
a460 1
  gdb_assert (element == num_elements);
d462 23
a484 3
  if (struct_return)
    {
      char buf[4];
d486 4
a489 3
      store_unsigned_integer (buf, 4, struct_addr);
      write_memory (sp, buf, 4);
    }
d491 2
a492 1
  return sp;
d495 7
a501 17
static CORE_ADDR
sparc32_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
			 struct regcache *regcache, CORE_ADDR bp_addr,
			 int nargs, struct value **args, CORE_ADDR sp,
			 int struct_return, CORE_ADDR struct_addr)
{
  CORE_ADDR call_pc = (struct_return ? (bp_addr - 12) : (bp_addr - 8));

  /* Set return address.  */
  regcache_cooked_write_unsigned (regcache, SPARC_O7_REGNUM, call_pc);

  /* Set up function arguments.  */
  sp = sparc32_store_arguments (regcache, nargs, args, sp,
				struct_return, struct_addr);

  /* Allocate the 16-word window save area.  */
  sp -= 16 * 4;
d503 4
a506 2
  /* Stack should be doubleword aligned at this point.  */
  gdb_assert (sp % 8 == 0);
d508 2
a509 2
  /* Finally, update the stack pointer.  */
  regcache_cooked_write_unsigned (regcache, SPARC_SP_REGNUM, sp);
d511 1
a511 3
  return sp;
}

d513 3
a515 10
/* Use the program counter to determine the contents and size of a
   breakpoint instruction.  Return a pointer to a string of bytes that
   encode a breakpoint instruction, store the length of the string in
   *LEN and optionally adjust *PC to point to the correct memory
   location for inserting the breakpoint.  */
   
static const unsigned char *
sparc_breakpoint_from_pc (CORE_ADDR *pc, int *len)
{
  static unsigned char break_insn[] = { 0x91, 0xd0, 0x20, 0x01 };
d517 3
a519 2
  *len = sizeof (break_insn);
  return break_insn;
a520 9


/* Allocate and initialize a frame cache.  */

static struct sparc32_frame_cache *
sparc32_alloc_frame_cache (void)
{
  struct sparc32_frame_cache *cache;
  int i;
d522 2
a523 1
  cache = FRAME_OBSTACK_ZALLOC (struct sparc32_frame_cache);
d525 2
a526 3
  /* Base address.  */
  cache->base = 0;
  cache->pc = 0;
d528 2
a529 2
  /* Frameless until proven otherwise.  */
  cache->frameless_p = 1;
d531 2
a532 4
  cache->struct_return_p = 0;

  return cache;
}
d535 2
a536 2
sparc32_analyze_prologue (CORE_ADDR pc, CORE_ADDR current_pc,
			  struct sparc32_frame_cache *cache)
d538 1
a538 3
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  unsigned long insn;
  int offset = 0;
d540 2
d543 1
a543 2
  if (current_pc <= pc)
    return current_pc;
d545 2
a546 17
  /* We have to handle to "Procedure Linkage Table" (PLT) special.  On
     SPARC the linker usually defines a symbol (typically
     _PROCEDURE_LINKAGE_TABLE_) at the start of the .plt section.
     This symbol makes us end up here with PC pointing at the start of
     the PLT and CURRENT_PC probably pointing at a PLT entry.  If we
     would do our normal prologue analysis, we would probably conclude
     that we've got a frame when in reality we don't, since the
     dynamic linker patches up the first PLT with some code that
     starts with a SAVE instruction.  Patch up PC such that it points
     at the start of our PLT entry.  */
  if (tdep->plt_entry_size > 0 && in_plt_section (current_pc, NULL))
    pc = current_pc - ((current_pc - pc) % tdep->plt_entry_size);

  insn = sparc_fetch_instruction (pc);

  /* Recognize a SETHI insn and record its destination.  */
  if (X_OP (insn) == 0 && X_OP2 (insn) == 0x04)
d549 3
a551 1
      offset += 4;
d553 12
a564 1
      insn = sparc_fetch_instruction (pc + 4);
d567 2
a568 3
  /* Allow for an arithmetic operation on DEST or %g1.  */
  if (X_OP (insn) == 2 && X_I (insn)
      && (X_RD (insn) == 1 || X_RD (insn) == dest))
d570 21
a590 1
      offset += 4;
d592 14
a605 1
      insn = sparc_fetch_instruction (pc + 8);
d607 3
d611 1
a611 2
  /* Check for the SAVE instruction that sets up the frame.  */
  if (X_OP (insn) == 2 && X_OP3 (insn) == 0x3c)
d613 52
a664 2
      cache->frameless_p = 0;
      return pc + offset + 4;
d670 2
a671 8
static CORE_ADDR
sparc32_unwind_pc (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  return frame_unwind_register_unsigned (next_frame, SPARC32_PC_REGNUM);
}

/* Return PC of first real instruction of the function starting at
   START_PC.  */
d673 2
a674 2
static CORE_ADDR
sparc32_skip_prologue (CORE_ADDR start_pc)
a677 1
  struct sparc32_frame_cache cache;
d690 2
a691 1
  return sparc32_analyze_prologue (start_pc, 0xffffffffUL, &cache);
d694 1
a694 1
/* Normal frames.  */
d696 2
a697 2
struct sparc32_frame_cache *
sparc32_frame_cache (struct frame_info *next_frame, void **this_cache)
d699 2
a700 2
  struct sparc32_frame_cache *cache;
  struct symbol *sym;
d702 3
a704 2
  if (*this_cache)
    return *this_cache;
d706 1
a706 2
  cache = sparc32_alloc_frame_cache ();
  *this_cache = cache;
d708 5
a712 3
  /* In priciple, for normal frames, %fp (%i6) holds the frame
     pointer, which holds the base address for the current stack
     frame.  */
d714 1
a714 3
  cache->base = frame_unwind_register_unsigned (next_frame, SPARC_FP_REGNUM);
  if (cache->base == 0)
    return cache;
d716 7
a722 5
  cache->pc = frame_func_unwind (next_frame);
  if (cache->pc != 0)
    sparc32_analyze_prologue (cache->pc, frame_pc_unwind (next_frame), cache);

  if (cache->frameless_p)
d724 23
a746 4
      /* We didn't find a valid frame, which means that CACHE->base
	 currently holds the frame pointer for our calling frame.  */
      cache->base = frame_unwind_register_unsigned (next_frame,
						    SPARC_SP_REGNUM);
d748 3
a750 3

  sym = find_pc_function (cache->pc);
  if (sym)
d752 7
a758 4
      struct type *type = check_typedef (SYMBOL_TYPE (sym));
      enum type_code code = TYPE_CODE (type);

      if (code == TYPE_CODE_FUNC || code == TYPE_CODE_METHOD)
d760 3
a762 4
	  type = check_typedef (TYPE_TARGET_TYPE (type));
	  if (sparc_structure_or_union_p (type)
	      || (sparc_floating_p (type) && TYPE_LENGTH (type) == 16))
	    cache->struct_return_p = 1;
d766 1
a766 1
  return cache;
d768 6
d775 6
a780 3
static void
sparc32_frame_this_id (struct frame_info *next_frame, void **this_cache,
		       struct frame_id *this_id)
d782 24
a805 2
  struct sparc32_frame_cache *cache =
    sparc32_frame_cache (next_frame, this_cache);
a806 3
  /* This marks the outermost frame.  */
  if (cache->base == 0)
    return;
d808 1
a808 2
  (*this_id) = frame_id_build (cache->base, cache->pc);
}
d810 9
a818 28
static void
sparc32_frame_prev_register (struct frame_info *next_frame, void **this_cache,
			     int regnum, int *optimizedp,
			     enum lval_type *lvalp, CORE_ADDR *addrp,
			     int *realnump, void *valuep)
{
  struct sparc32_frame_cache *cache =
    sparc32_frame_cache (next_frame, this_cache);

  if (regnum == SPARC32_PC_REGNUM || regnum == SPARC32_NPC_REGNUM)
    {
      *optimizedp = 0;
      *lvalp = not_lval;
      *addrp = 0;
      *realnump = -1;
      if (valuep)
	{
	  CORE_ADDR pc = (regnum == SPARC32_NPC_REGNUM) ? 4 : 0;

	  /* If this functions has a Structure, Union or
             Quad-Precision return value, we have to skip the UNIMP
             instruction that encodes the size of the structure.  */
	  if (cache->struct_return_p)
	    pc += 4;

	  regnum = cache->frameless_p ? SPARC_O7_REGNUM : SPARC_I7_REGNUM;
	  pc += frame_unwind_register_unsigned (next_frame, regnum) + 8;
	  store_unsigned_integer (valuep, 4, pc);
d820 2
d825 8
a832 10
  /* The previous frame's `local' and `in' registers have been saved
     in the register save area.  */
  if (!cache->frameless_p
      && regnum >= SPARC_L0_REGNUM && regnum <= SPARC_I7_REGNUM)
    {
      *optimizedp = 0;
      *lvalp = lval_memory;
      *addrp = cache->base + (regnum - SPARC_L0_REGNUM) * 4;
      *realnump = -1;
      if (valuep)
d834 50
a883 1
	  struct gdbarch *gdbarch = get_frame_arch (next_frame);
d885 46
a930 2
	  /* Read the value in from memory.  */
	  read_memory (*addrp, valuep, register_size (gdbarch, regnum));
d932 10
a941 1
      return;
d943 3
d947 1
a947 5
  /* The previous frame's `out' registers are accessable as the
     current frame's `in' registers.  */
  if (!cache->frameless_p
      && regnum >= SPARC_O0_REGNUM && regnum <= SPARC_O7_REGNUM)
    regnum += (SPARC_I0_REGNUM - SPARC_O0_REGNUM);
d949 7
a955 3
  frame_register_unwind (next_frame, regnum,
			 optimizedp, lvalp, addrp, realnump, valuep);
}
d957 4
a960 6
static const struct frame_unwind sparc32_frame_unwind =
{
  NORMAL_FRAME,
  sparc32_frame_this_id,
  sparc32_frame_prev_register
};
d962 2
a963 2
static const struct frame_unwind *
sparc32_frame_sniffer (struct frame_info *next_frame)
d965 2
a966 3
  return &sparc32_frame_unwind;
}

d968 3
a970 5
static CORE_ADDR
sparc32_frame_base_address (struct frame_info *next_frame, void **this_cache)
{
  struct sparc32_frame_cache *cache =
    sparc32_frame_cache (next_frame, this_cache);
d972 18
a989 2
  return cache->base;
}
d991 3
a993 7
static const struct frame_base sparc32_frame_base =
{
  &sparc32_frame_unwind,
  sparc32_frame_base_address,
  sparc32_frame_base_address,
  sparc32_frame_base_address
};
d995 3
a997 4
static struct frame_id
sparc_unwind_dummy_id (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  CORE_ADDR sp;
d999 4
a1002 4
  sp = frame_unwind_register_unsigned (next_frame, SPARC_SP_REGNUM);
  return frame_id_build (sp, frame_pc_unwind (next_frame));
}

d1004 1
a1004 2
/* Extract from an array REGBUF containing the (raw) register state, a
   function return value of TYPE, and copy that into VALBUF.  */
d1006 1
a1006 6
static void
sparc32_extract_return_value (struct type *type, struct regcache *regcache,
			      void *valbuf)
{
  int len = TYPE_LENGTH (type);
  char buf[8];
d1008 2
a1009 2
  gdb_assert (!sparc_structure_or_union_p (type));
  gdb_assert (!(sparc_floating_p (type) && len == 16));
d1011 1
a1011 1
  if (sparc_floating_p (type))
d1013 7
a1019 13
      /* Floating return values.  */
      regcache_cooked_read (regcache, SPARC_F0_REGNUM, buf);
      if (len > 4)
	regcache_cooked_read (regcache, SPARC_F1_REGNUM, buf + 4);
      memcpy (valbuf, buf, len);
    }
  else
    {
      /* Integral and pointer return values.  */
      gdb_assert (sparc_integral_or_pointer_p (type));

      regcache_cooked_read (regcache, SPARC_O0_REGNUM, buf);
      if (len > 4)
d1021 6
a1026 3
	  regcache_cooked_read (regcache, SPARC_O1_REGNUM, buf + 4);
	  gdb_assert (len == 8);
	  memcpy (valbuf, buf, 8);
d1030 2
a1031 3
	  /* Just stripping off any unused bytes should preserve the
	     signed-ness just fine.  */
	  memcpy (valbuf, buf + 4 - len, len);
d1033 21
d1057 35
a1091 2
/* Write into the appropriate registers a function return value stored
   in VALBUF of type TYPE.  */
d1094 1
a1094 2
sparc32_store_return_value (struct type *type, struct regcache *regcache,
			    const void *valbuf)
d1096 4
a1099 2
  int len = TYPE_LENGTH (type);
  char buf[8];
d1101 1
a1101 2
  gdb_assert (!sparc_structure_or_union_p (type));
  gdb_assert (!(sparc_floating_p (type) && len == 16));
d1103 4
a1106 1
  if (sparc_floating_p (type))
d1108 46
a1153 5
      /* Floating return values.  */
      memcpy (buf, valbuf, len);
      regcache_cooked_write (regcache, SPARC_F0_REGNUM, buf);
      if (len > 4)
	regcache_cooked_write (regcache, SPARC_F1_REGNUM, buf + 4);
d1157 16
a1172 4
      /* Integral and pointer return values.  */
      gdb_assert (sparc_integral_or_pointer_p (type));

      if (len > 4)
d1174 1
a1174 3
	  gdb_assert (len == 8);
	  memcpy (buf, valbuf, 8);
	  regcache_cooked_write (regcache, SPARC_O1_REGNUM, buf + 4);
d1178 10
a1187 2
	  /* ??? Do we need to do any sign-extension here?  */
	  memcpy (buf + 4 - len, valbuf, len);
a1188 1
      regcache_cooked_write (regcache, SPARC_O0_REGNUM, buf);
d1190 3
d1195 8
a1202 3
/* Extract from REGCACHE, which contains the (raw) register state, the
   address in which a function should return its structure value, as a
   CORE_ADDR.  */
d1204 8
a1211 2
static CORE_ADDR
sparc_extract_struct_value_address (struct regcache *regcache)
d1213 130
a1342 1
  ULONGEST addr;
d1344 12
a1355 2
  regcache_cooked_read_unsigned (regcache, SPARC_O0_REGNUM, &addr);
  return addr;
d1358 6
a1363 2
static int
sparc32_use_struct_convention (int gcc_p, struct type *type)
d1365 10
a1374 2
  gdb_assert (sparc_structure_or_union_p (type));
  return 1;
d1377 31
a1407 6
static int
sparc32_return_value_on_stack (struct type *type)
{
  gdb_assert (!sparc_structure_or_union_p (type));
  return (sparc_floating_p (type) && TYPE_LENGTH (type) == 16);
}
d1409 7
a1415 5
static int
sparc32_stabs_argument_has_addr (struct gdbarch *gdbarch, struct type *type)
{
  return (sparc_structure_or_union_p (type)
	  || (sparc_floating_p (type) && TYPE_LENGTH (type) == 16));
a1416 1

d1418 42
a1459 3
/* The SPARC Architecture doesn't have hardware single-step support,
   and most operating systems don't implement it either, so we provide
   software single-step mechanism.  */
d1461 2
a1462 2
static CORE_ADDR
sparc_analyze_control_transfer (CORE_ADDR pc, CORE_ADDR *npc)
d1464 2
a1465 4
  unsigned long insn = sparc_fetch_instruction (pc);
  int conditional_p = X_COND (insn) & 0x7;
  int branch_p = 0;
  long offset = 0;			/* Must be signed for sign-extend.  */
d1467 108
a1574 5
  if (X_OP (insn) == 0 && X_OP2 (insn) == 3 && (insn & 0x1000000) == 0)
    {
      /* Branch on Integer Register with Prediction (BPr).  */
      branch_p = 1;
      conditional_p = 1;
d1576 1
a1576 1
  else if (X_OP (insn) == 0 && X_OP2 (insn) == 6)
d1578 1
a1578 3
      /* Branch on Floating-Point Condition Codes (FBfcc).  */
      branch_p = 1;
      offset = 4 * X_DISP22 (insn);
d1580 92
a1671 1
  else if (X_OP (insn) == 0 && X_OP2 (insn) == 5)
d1673 2
a1674 4
      /* Branch on Floating-Point Condition Codes with Prediction
         (FBPfcc).  */
      branch_p = 1;
      offset = 4 * X_DISP19 (insn);
d1676 2
a1677 1
  else if (X_OP (insn) == 0 && X_OP2 (insn) == 2)
d1679 8
a1686 3
      /* Branch on Integer Condition Codes (Bicc).  */
      branch_p = 1;
      offset = 4 * X_DISP22 (insn);
d1688 1
a1688 1
  else if (X_OP (insn) == 0 && X_OP2 (insn) == 1)
d1690 1
a1690 3
      /* Branch on Integer Condition Codes with Prediction (BPcc).  */
      branch_p = 1;
      offset = 4 * X_DISP19 (insn);
d1692 1
d1694 12
a1705 1
  /* FIXME: Handle DONE and RETRY instructions.  */
d1707 2
a1708 1
  /* FIXME: Handle the Trap instruction.  */
d1710 1
a1710 1
  if (branch_p)
d1712 1
a1712 7
      if (conditional_p)
	{
	  /* For conditional branches, return nPC + 4 iff the annul
	     bit is 1.  */
	  return (X_A (insn) ? *npc + 4 : 0);
	}
      else
d1714 3
a1716 11
	  /* For unconditional branches, return the target if its
	     specified condition is "always" and return nPC + 4 if the
	     condition is "never".  If the annul bit is 1, set *NPC to
	     zero.  */
	  if (X_COND (insn) == 0x0)
	    pc = *npc, offset = 4;
	  if (X_A (insn))
	    *npc = 0;

	  gdb_assert (offset != 0);
	  return pc + offset;
d1720 7
a1726 1
  return 0;
d1729 5
a1733 5
void
sparc_software_single_step (enum target_signal sig, int insert_breakpoints_p)
{
  static CORE_ADDR npc, nnpc;
  static char npc_save[4], nnpc_save[4];
d1735 5
a1739 3
  if (insert_breakpoints_p)
    {
      CORE_ADDR pc;
d1741 6
a1746 2
      gdb_assert (npc == 0);
      gdb_assert (nnpc == 0);
d1748 1
a1748 2
      pc = sparc_address_from_register (SPARC32_PC_REGNUM);
      npc = sparc_address_from_register (SPARC32_NPC_REGNUM);
d1750 3
a1752 6
      /* Analyze the instruction at PC.  */
      nnpc = sparc_analyze_control_transfer (pc, &npc);
      if (npc != 0)
	target_insert_breakpoint (npc, npc_save);
      if (nnpc != 0)
	target_insert_breakpoint (nnpc, nnpc_save);
d1754 1
a1754 9
      /* Assert that we have set at least one breakpoint.  */
      gdb_assert (npc != 0 || nnpc != 0);
    }
  else
    {
      if (npc != 0)
	target_remove_breakpoint (npc, npc_save);
      if (nnpc != 0)
	target_remove_breakpoint (nnpc, nnpc_save);
d1756 24
a1779 2
      npc = 0;
      nnpc = 0;
d1781 1
d1783 7
d1792 1
a1792 1
sparc32_write_pc (CORE_ADDR pc, ptid_t ptid)
d1794 45
a1838 2
  write_register_pid (SPARC32_PC_REGNUM, pc, ptid);
  write_register_pid (SPARC32_NPC_REGNUM, pc + 4, ptid);
a1839 1

d1841 5
a1845 2
static struct gdbarch *
sparc32_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
d1847 1
a1847 2
  struct gdbarch_tdep *tdep;
  struct gdbarch *gdbarch;
d1849 5
a1853 4
  /* If there is already a candidate, use it.  */
  arches = gdbarch_list_lookup_by_info (arches, &info);
  if (arches != NULL)
    return arches->gdbarch;
d1855 19
a1873 3
  /* Allocate space for the new architecture.  */
  tdep = XMALLOC (struct gdbarch_tdep);
  gdbarch = gdbarch_alloc (&info, tdep);
d1875 8
a1882 1
  set_gdbarch_long_double_bit (gdbarch, 128);
d1884 9
a1892 27
  set_gdbarch_num_regs (gdbarch, SPARC32_NUM_REGS);
  set_gdbarch_register_name (gdbarch, sparc32_register_name);
  set_gdbarch_register_type (gdbarch, sparc32_register_type);

  /* Register numbers of various important registers.  */
  set_gdbarch_sp_regnum (gdbarch, SPARC_SP_REGNUM); /* %sp */
  set_gdbarch_pc_regnum (gdbarch, SPARC32_PC_REGNUM); /* %pc */
  set_gdbarch_fp0_regnum (gdbarch, SPARC_F0_REGNUM); /* %f0 */

  /* Call dummy code.  */
  set_gdbarch_call_dummy_location (gdbarch, ON_STACK);
  set_gdbarch_push_dummy_code (gdbarch, sparc32_push_dummy_code);
  set_gdbarch_push_dummy_call (gdbarch, sparc32_push_dummy_call);

  set_gdbarch_extract_return_value (gdbarch, sparc32_extract_return_value);
  set_gdbarch_store_return_value (gdbarch, sparc32_store_return_value);
  set_gdbarch_extract_struct_value_address
    (gdbarch, sparc_extract_struct_value_address);
  set_gdbarch_use_struct_convention (gdbarch, sparc32_use_struct_convention);
  set_gdbarch_return_value_on_stack (gdbarch, sparc32_return_value_on_stack);
  set_gdbarch_stabs_argument_has_addr
    (gdbarch, sparc32_stabs_argument_has_addr);

  set_gdbarch_skip_prologue (gdbarch, sparc32_skip_prologue);

  /* Stack grows downward.  */
  set_gdbarch_inner_than (gdbarch, core_addr_lessthan);
d1894 2
a1895 3
  set_gdbarch_breakpoint_from_pc (gdbarch, sparc_breakpoint_from_pc);
  set_gdbarch_decr_pc_after_break (gdbarch, 0);
  set_gdbarch_function_start_offset (gdbarch, 0);
d1897 1
a1897 1
  set_gdbarch_frame_args_skip (gdbarch, 8);
d1899 1
a1899 1
  set_gdbarch_print_insn (gdbarch, print_insn_sparc);
d1901 110
a2010 3
  set_gdbarch_software_single_step (gdbarch, sparc_software_single_step);

  set_gdbarch_write_pc (gdbarch, sparc32_write_pc);
d2012 1
a2012 12
  set_gdbarch_unwind_dummy_id (gdbarch, sparc_unwind_dummy_id);

  set_gdbarch_unwind_pc (gdbarch, sparc32_unwind_pc);

  frame_base_set_default (gdbarch, &sparc32_frame_base);

  /* Hook in ABI-specific overrides, if they have been registered.  */
  gdbarch_init_osabi (info, gdbarch);

  frame_unwind_append_sniffer (gdbarch, sparc32_frame_sniffer);

  return gdbarch;
a2013 2

/* Helper functions for dealing with register windows.  */
d2015 6
a2020 2
void
sparc_supply_rwindow (struct regcache *regcache, CORE_ADDR sp, int regnum)
a2021 2
  int offset = 0;
  char buf[8];
d2023 9
a2031 7

  if (sp & 1)
    {
      /* Registers are 64-bit.  */
      sp += BIAS;

      for (i = SPARC_L0_REGNUM; i <= SPARC_I7_REGNUM; i++)
d2033 1
a2033 1
	  if (regnum == i || regnum == -1)
d2035 4
a2038 2
	      target_read_memory (sp + ((i - SPARC_L0_REGNUM) * 8), buf, 8);
	      regcache_raw_supply (regcache, i, buf);
d2041 13
a2053 6
    }
  else
    {
      /* Registers are 32-bit.  Toss any sign-extension of the stack
	 pointer.  */
      sp &= 0xffffffffUL;
d2055 2
a2056 3
      /* Clear out the top half of the temporary buffer, and put the
	 register value in the bottom half if we're in 64-bit mode.  */
      if (gdbarch_ptr_bit (current_gdbarch) == 64)
d2058 2
a2059 2
	  memset (buf, 0, 4);
	  offset = 4;
d2062 5
a2066 1
      for (i = SPARC_L0_REGNUM; i <= SPARC_I7_REGNUM; i++)
d2068 25
a2092 1
	  if (regnum == i || regnum == -1)
d2094 3
a2096 3
	      target_read_memory (sp + ((i - SPARC_L0_REGNUM) * 4),
				  buf + offset, 4);
	      regcache_raw_supply (regcache, i, buf);
d2099 6
d2108 10
d2119 34
a2152 2
sparc_collect_rwindow (const struct regcache *regcache,
		       CORE_ADDR sp, int regnum)
d2154 2
a2155 2
  int offset = 0;
  char buf[8];
d2158 7
a2164 1
  if (sp & 1)
d2166 3
a2168 2
      /* Registers are 64-bit.  */
      sp += BIAS;
d2170 3
a2172 1
      for (i = SPARC_L0_REGNUM; i <= SPARC_I7_REGNUM; i++)
d2174 10
a2183 5
	  if (regnum == -1 || regnum == SPARC_SP_REGNUM || regnum == i)
	    {
	      regcache_raw_collect (regcache, i, buf);
	      target_write_memory (sp + ((i - SPARC_L0_REGNUM) * 8), buf, 8);
	    }
d2186 16
a2201 1
  else
d2203 11
a2213 3
      /* Registers are 32-bit.  Toss any sign-extension of the stack
	 pointer.  */
      sp &= 0xffffffffUL;
d2215 1
a2215 3
      /* Only use the bottom half if we're in 64-bit mode.  */
      if (gdbarch_ptr_bit (current_gdbarch) == 64)
	offset = 4;
d2217 7
a2223 3
      for (i = SPARC_L0_REGNUM; i <= SPARC_I7_REGNUM; i++)
	{
	  if (regnum == -1 || regnum == SPARC_SP_REGNUM || regnum == i)
d2225 2
a2226 3
	      regcache_raw_collect (regcache, i, buf);
	      target_write_memory (sp + ((i - SPARC_L0_REGNUM) * 4),
				   buf + offset, 4);
d2228 19
d2249 266
a2515 1

d2517 29
a2545 2
/* Provide a prototype to silence -Wmissing-prototypes.  */
void _initialize_sparc_tdep (void);
d2550 1057
a3606 1
  register_gdbarch_init (bfd_arch_sparc, sparc32_gdbarch_init);
@


1.127.2.2
log
@Integrate SPARC and UltraSPARC targets.
* sparc-tdep.h (struct sparc32_frame_cache): Add pc_regnum and
npc_regnum members.
* sparc-tdep.c (sparc_unwind_pc): Rename from sparc32_unwind_pc.
Get register numbers for %pc from `struct gdbarch_tdep' instead of
using 32-bit specific constants.
(sparc_software_single_step): Get register numbers from %pc and
%npc from `struct gdbarch_tdep'.
(sparc_write_pc): Rename from sparc32_write_pc.  Get register
numbers from %pc and %npc from `struct gdbarch_tdep'.
(sparc32_gdbarch_init): Initialize TDEP->pc_regnum,
TDEP->npc_regnum and TDEP->plt_entry_size.  Set write_pc to
sparc_write_pc, set unwind_pc to sparc_unwind_pc.
* sparc64-tdep.h: Fix typo in multiple inclusion guard.  Include
"sparc-tdep.h".
(enum sparc_regnum): Remove.
(sparc_supply_rwindow, sparc_fill_rwindow): Remove prototypes.
(sparc64_init_abi): New prototype.
* sparc64-tdep.c: Include "inferior.h" and "sparc-tdep.h".
(struct gdbarch_tdep): Remove definition.
(SPARC64_NUM_REGS, SPARC64_NUM_PSEUDO_REGS): Use ARRAY_SIZE.
(sparc_breakpoint_from_pc, sparc64_unwind_pc,
sparc_unwind_dummy_id, sparc_extract_struct_value_address,
sparc_analyze_control_transfer, sparc_software_single_step,
sparc64_gdbarch_init, sparc_supply_rwindow, sparc_fill_rwindow,
_initialize_sparc64_tdep): Remove functions.
(sparc64_init_abi): New function.
* sparc64fbsd-tdep.c (sparc64fbsd_supply_reg): Call
sparc_supply_rwindow with correct number of arguments.
(sparc64fbsd_init_abi): Call sparc64_init_abi.
* sparcbsd-nat.c (store_inferior_registers): Call
sparc_collect_rwindow instead sparc_fill_rwindow.
* config/sparc/fbsd.mt (TDEPFILES): Add sparc-tdep.o and corelow.o.
* config/sparc/fbsd.mh (NATDEPFILES): Remove corelow.o.
* Makefile.in (sparc64_tdep_h): Add dependency on sparc-tdep.h.
(sparc64-tdep.o): Update dependencies.
@
text
@d473 1
a473 1
sparc_unwind_pc (struct gdbarch *gdbarch, struct frame_info *next_frame)
d475 1
a475 2
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  return frame_unwind_register_unsigned (next_frame, tdep->pc_regnum);
a865 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d876 2
a877 2
      pc = sparc_address_from_register (tdep->pc_regnum);
      npc = sparc_address_from_register (tdep->npc_regnum);
d902 1
a902 1
sparc_write_pc (CORE_ADDR pc, ptid_t ptid)
d904 2
a905 4
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

  write_register_pid (tdep->pc_regnum, pc, ptid);
  write_register_pid (tdep->npc_regnum, pc + 4, ptid);
a923 4
  tdep->pc_regnum = SPARC32_PC_REGNUM;
  tdep->npc_regnum = SPARC32_NPC_REGNUM;
  tdep->plt_entry_size = 0;

d963 2
a964 1
  set_gdbarch_write_pc (gdbarch, sparc_write_pc);
d968 1
a968 1
  set_gdbarch_unwind_pc (gdbarch, sparc_unwind_pc);
@


1.127.2.3
log
@* sparc-tdep.h (struct sparc_gregset): New.
(sparc_sol2_supply_gregset, sparc_sol2_collect_gregset,
sparc_sol2_supply_fpregset, sparc_sol2_collect_fpregset): Remove
prototypes.
(sparc_supply_gregset, sparc_collect_gregset,
sparc_supply_fpregset, sparc_collect_fpregset): New prototypes.
(sparc32_sunos4_gregset, sparc32_sol2_gregset): New extern
declarations.
(sparc32_sol2_init_abi): Rename from sparc_sol2_init_abi.
* sparc-tdep.c (sparc_supply_gregset, sparc_collect_gregset,
sparc_supply_fpregset, sparc_collect_fpregset): New function.
(sparc32_sunos4_gregset): New variable.
* sparc-sol2-tdep.c (sparc_sol2_R_PSR, sparc_sol2_R_PC,
sparc_sol2_R_nPC, sparc_sol2_R_Y, sparc_sol2_R_WIM,
sparc_sol2_R_TBR): Remove variables.
(sparc_sol2_supply_gregset, sparc_sol2_collect_gregset,
sparc_sol2_supply_fpregset, sparc_sol2_collect_fpregset): Remove
functions.
(sparc32_sol2_gregset): New variable.
(sparc32_sol2_sigtramp_frame_cache): Rename from
sparc_sol2_sigtramp_frame_cache.
(sparc32_sol2_sigtramp_frame_this_id): Rename from
sparc_sol2_sigtramp_frame_this_id.
(sparc32_sol2_sigtramp_frame_prev_register): Rename from
sparc_sol2_sigtramp_frame_prev_register.
(sparc32_sol2_sigtramp_frame_unwind): Rename from
sparc_sol2_sigtramp_frame_unwind.
(sparc32_sol2_sigtramp_frame_sniffer): Rename from
sparc_sol2_sigtramp_frame_sniffer.
(sparc32_sol2_init_abi): Rename from sparc_sol2_init_abi.
(_initialize_sparc_sol2_tdep): Update.
* sparc-linux-tdep.c: New file.
* sparc-nat.o: Replace with new file.
* sparc-linux-nat.c: Remove file.
* config/sparc/linux.mh (XM_FILE, HOST_IPC): Remove.
(NATDEPFILES): Add sparc-sol2-nat.o and core-regset.o.  Remove
sparc-linux-nat.o.
* config/sparc/linux.mt (TDEPFILES): Add sparc-sol2-tdep.o and
sparc-linux-tdep.o.
* config/sparc/nm-linux.h: Don't include "config/nm-svr4.h" and
"solib.h".  Add protection against multiple inclusion.
(KERNEL_U_SIZE): Don't define.
(kernel_u_size): Remove prototype.
* config/sparc/tm-linux.h: Replace with new file.
* configure.tgt: Add sparc-*-linux*.
* configure.host: Add sparc-*-linux*.
* Makefile.in (ALLDEPFILES): Add sparc-linux-tdep.c and
sparc-nat.c.
(sparc-nat.o, sparc-linux-tdep.o): New dependencies.
@
text
@a1078 173

/* Helper functions for dealing with register sets.  */

/* FIXME: kettenis/20031125: Make these handle 64-bit register sets.  */

void
sparc_supply_gregset (const struct sparc_gregset *gregset,
		      struct regcache *regcache,
		      int regnum, const void *gregs)
{
  const char *regs = gregs;
  int i;

  if (regnum == SPARC32_PSR_REGNUM || regnum == -1)
    regcache_raw_supply (regcache, SPARC32_PSR_REGNUM,
			 regs + gregset->r_psr_offset);

  if (regnum == SPARC32_PC_REGNUM || regnum == -1)
    regcache_raw_supply (regcache, SPARC32_PC_REGNUM,
			 regs + gregset->r_pc_offset);

  if (regnum == SPARC32_NPC_REGNUM || regnum == -1)
    regcache_raw_supply (regcache, SPARC32_NPC_REGNUM,
			 regs + gregset->r_npc_offset);

  if (regnum == SPARC32_Y_REGNUM || regnum == -1)
    regcache_raw_supply (regcache, SPARC32_Y_REGNUM,
			 regs + gregset->r_y_offset);

  if (regnum == SPARC_G0_REGNUM || regnum == -1)
    regcache_raw_supply (regcache, SPARC_G0_REGNUM, NULL);

  if ((regnum >= SPARC_G1_REGNUM && regnum <= SPARC_O7_REGNUM) || regnum == -1)
    {
      int offset = gregset->r_g1_offset;

      for (i = SPARC_G1_REGNUM; i <= SPARC_O7_REGNUM; i++)
	{
	  if (regnum == i || regnum == -1)
	    regcache_raw_supply (regcache, i, regs + offset);
	  offset += 4;
	}
    }

  if ((regnum >= SPARC_L0_REGNUM && regnum <= SPARC_I7_REGNUM) || regnum == -1)
    {
      /* Not all of the register set variants include Locals and
         Inputs.  For those that don't, we read them off the stack.  */
      if (gregset->r_l0_offset == -1)
	{
	  ULONGEST sp;

	  regcache_cooked_read_unsigned (regcache, SPARC_SP_REGNUM, &sp);
	  sparc_supply_rwindow (regcache, sp, regnum);
	}
      else
	{
	  int offset = gregset->r_l0_offset;

	  for (i = SPARC_L0_REGNUM; i <= SPARC_I7_REGNUM; i++)
	    {
	      if (regnum == i || regnum == -1)
		regcache_raw_supply (regcache, i, regs + offset);
	      offset += 4;
	    }
	}
    }
}

void
sparc_collect_gregset (const struct sparc_gregset *gregset,
		       const struct regcache *regcache,
		       int regnum, void *gregs)
{
  char *regs = gregs;
  int i;

  if (regnum == SPARC32_PSR_REGNUM || regnum == -1)
    regcache_raw_collect (regcache, SPARC32_PSR_REGNUM,
			  regs + gregset->r_psr_offset);

  if (regnum == SPARC32_PC_REGNUM || regnum == -1)
    regcache_raw_collect (regcache, SPARC32_PC_REGNUM,
			  regs + gregset->r_pc_offset);

  if (regnum == SPARC32_NPC_REGNUM || regnum == -1)
    regcache_raw_collect (regcache, SPARC32_NPC_REGNUM,
			  regs + gregset->r_npc_offset);

  if (regnum == SPARC32_Y_REGNUM || regnum == -1)
    regcache_raw_collect (regcache, SPARC32_Y_REGNUM,
			  regs + gregset->r_y_offset);

  if ((regnum >= SPARC_G1_REGNUM && regnum <= SPARC_O7_REGNUM) || regnum == -1)
    {
      int offset = gregset->r_g1_offset;

      /* %g0 is always zero.  */
      for (i = SPARC_G1_REGNUM; i <= SPARC_O7_REGNUM; i++)
	{
	  if (regnum == i || regnum == -1)
	    regcache_raw_collect (regcache, i, regs + offset);
	  offset += 4;
	}
    }

  if ((regnum >= SPARC_L0_REGNUM && regnum <= SPARC_I7_REGNUM) || regnum == -1)
    {
      /* Not all of the register set variants include Locals and
         Inputs.  For those that don't, we read them off the stack.  */
      if (gregset->r_l0_offset != -1)
	{
	  int offset = gregset->r_l0_offset;

	  for (i = SPARC_L0_REGNUM; i <= SPARC_I7_REGNUM; i++)
	    {
	      if (regnum == i || regnum == -1)
		regcache_raw_collect (regcache, i, regs + offset);
	      offset += 4;
	    }
	}
    }
}

void
sparc_supply_fpregset (struct regcache *regcache,
		       int regnum, const void *fpregs)
{
  const char *regs = fpregs;
  int i;

  for (i = 0; i < 32; i++)
    {
      if (regnum == (SPARC_F0_REGNUM + i) || regnum == -1)
	regcache_raw_supply (regcache, SPARC_F0_REGNUM + i, regs + (i * 4));
    }

  if (regnum == SPARC32_FSR_REGNUM || regnum == -1)
    regcache_raw_supply (regcache, SPARC32_FSR_REGNUM, regs + (32 * 4) + 4);
}

void
sparc_collect_fpregset (const struct regcache *regcache,
			int regnum, void *fpregs)
{
  char *regs = fpregs;
  int i;

  for (i = 0; i < 32; i++)
    {
      if (regnum == (SPARC_F0_REGNUM + i) || regnum == -1)
	regcache_raw_collect (regcache, SPARC_F0_REGNUM + i, regs + (i * 4));
    }

  if (regnum == SPARC32_FSR_REGNUM || regnum == -1)
    regcache_raw_collect (regcache, SPARC32_FSR_REGNUM, regs + (32 * 4) + 4);
}


/* SunOS 4.  */

/* From <machine/reg.h>.  */
const struct sparc_gregset sparc32_sunos4_gregset =
{
  0 * 4,			/* %psr */
  1 * 4,			/* %pc */
  2 * 4,			/* %npc */
  3 * 4,			/* %y */
  -1,				/* %wim */
  -1,				/* %tbr */
  4 * 4,			/* %g1 */
  -1				/* %l0 */
};
@


1.127.2.4
log
@* sparc-tdep.h (struct sparc_gregset): Add r_y_size member.
(sparc32_supply_gregset): Renamed from sparc_supply_gregset.
(sparc32_collect_gregset): Renamed from sparc_collect_gregset.
(sparc32_supply_fpregset): Renamed from sparc_supply_fpregset.
(sparc32_collect_fpregset): Renamed from sparc_collect_fpregset.
* sparc-tdep.c (sparc32_supply_gregset): Renamed from
sparc_supply_gregset.
(sparc32_collect_gregset): Renamed from sparc_collect_gregset.
(sparc32_supply_fpregset): Renamed from sparc_supply_fpregset.
(sparc32_collect_fpregset): Renamed from sparc_collect_fpregset.
* sparc-linux-tdep.c: Include "solib-svr4.h".
(sparc32_linux_svr4_fetch_link_map_offsets): New function.
(sparc32_linux_init_abi): Set solib_svr4_fetch_link_map_offsets.
* sparc-nat.h: New file.
* sparc-nat.c: Add some more comments.  Include "sparc-nat.h".
(PTRACE_GETREGS): Define to PT_GETREGS if not already defined.
(PTRACE_SETREGS, PTRACE_GETFPREGS, PTRACE_SETFPREGS): Likewise.
(sparc_supply_gregset, sparc_collect_gregset,
sparc_supply_fpregset, sparc_collect_fpregset,
sparc_gregset_supplies_p, sparc_fpregset_supplies_p): New function
variables.
(sparc32_gregset_supplies_p): Rename from
sparc_gregset_supplies_p.
(sparc32_fpregset_supplies_p): Rename from
sparc_fpregset_supplies_p.
(fetch_inferior_registers): Deal with GNU/Linux LWPs.
(store_inferior_registers): Likewise.  Work around peculiarity in
NetBSD when writing the floating-point registers.
(_initialize_sparc_nat): Initialize sparc_supply_gregset,
sparc_collect_gregset, sparc_supply_fpregset,
sparc_collect_fpregset, sparc_gregset_supplies_p and
sparc_fpregset_supplies_p if necessary.
* sparc-sol2-nat.c (supply_gregset): Call sparc32_supply_gregset
instead of sparc_supply_gregset.
(supply_fpregset, fill_gregset, fill_fpregset): Likewise.
@
text
@d1082 2
d1085 3
a1087 3
sparc32_supply_gregset (const struct sparc_gregset *gregset,
			struct regcache *regcache,
			int regnum, const void *gregs)
d1149 3
a1151 3
sparc32_collect_gregset (const struct sparc_gregset *gregset,
			 const struct regcache *regcache,
			 int regnum, void *gregs)
d1204 2
a1205 2
sparc32_supply_fpregset (struct regcache *regcache,
			 int regnum, const void *fpregs)
d1221 2
a1222 2
sparc32_collect_fpregset (const struct regcache *regcache,
			  int regnum, void *fpregs)
@


1.127.2.5
log
@From Peter Schauer  <Peter.Schauer@@Regent.E-Technik.TU-Muenchen.DE>:
* sparc-tdep.c (sparc32_register_names): Fix typo.
* sparc-sol2-tdep.c (sparc32_sol2_init_abi): Set pc_in_sigtramp.
* config/sparc/sol2.mh (NATDEPFILES): Add gcore.o.
* config/sparc/sol64.mh (NATDEPFILES): Add gcore.o.
@
text
@d198 1
a198 1
  "f24", "f25", "f26", "f27", "f28", "f29", "f30", "f31",
@


1.127.2.6
log
@* sparc-tdep.c (sparc32_register_names): Remove trailing comma.
(sparc32_pseudo_register_names): New variable.
(SPARC32_NUM_PSEUDO_REGS): New define.
(sparc32_register_name): Add support for psuedo-registers.
(sparc32_register_type): Add support double precision
floating-point registers.
(sparc32_pseudo_register_read, sparc32_pseudo_register_write): New
functions.
(sparc32_gdbarch_init): Set num_pseudo_regs, pseudo_register_read
and pseudo_register_write.
* sparc-tdep.h (sparc32_regnum): Add SPARC32_D0_REGNUM and
SPARC32_D30_REGNUM.
@
text
@d200 1
a200 1
  "y", "psr", "wim", "tbr", "pc", "npc", "fsr", "csr"
a205 12
/* We provide the aliases %d0..%d30 for the floating registers as
   "psuedo" registers.  */

static const char *sparc32_pseudo_register_names[] =
{
  "d0", "d2", "d4", "d6", "d8", "d10", "d12", "d14",
  "d16", "d18", "d20", "d22", "d24", "d26", "d28", "d30"
};

/* Total number of pseudo registers.  */
#define SPARC32_NUM_PSEUDO_REGS ARRAY_SIZE (sparc32_pseudo_register_names)

a213 3
  if (regnum < SPARC32_NUM_REGS + SPARC32_NUM_PSEUDO_REGS)
    return sparc32_pseudo_register_names[regnum - SPARC32_NUM_REGS];

a225 3
  if (regnum >= SPARC32_D0_REGNUM && regnum <= SPARC32_D30_REGNUM)
    return builtin_type_double;

a234 25
static void
sparc32_pseudo_register_read (struct gdbarch *gdbarch,
			      struct regcache *regcache,
			      int regnum, void *buf)
{
  gdb_assert (regnum >= SPARC32_D0_REGNUM && regnum <= SPARC32_D30_REGNUM);

  regnum = SPARC_F0_REGNUM + 2 * (regnum - SPARC32_D0_REGNUM);
  regcache_raw_read (regcache, regnum, buf);
  regcache_raw_read (regcache, regnum + 1, ((char *)buf) + 4);
}

static void
sparc32_pseudo_register_write (struct gdbarch *gdbarch,
			       struct regcache *regcache,
			       int regnum, const void *buf)
{
  gdb_assert (regnum >= SPARC32_D0_REGNUM && regnum <= SPARC32_D30_REGNUM);

  regnum = SPARC_F0_REGNUM + 2 * (regnum - SPARC32_D0_REGNUM);
  regcache_raw_write (regcache, regnum, buf);
  regcache_raw_write (regcache, regnum + 1, ((const char *)buf) + 4);
}


a936 3
  set_gdbarch_num_pseudo_regs (gdbarch, SPARC32_NUM_PSEUDO_REGS);
  set_gdbarch_pseudo_register_read (gdbarch, sparc32_pseudo_register_read);
  set_gdbarch_pseudo_register_write (gdbarch, sparc32_pseudo_register_write);
@


1.127.2.7
log
@* sparc-tdep.c: Fix typos in comments.
@
text
@d55 2
a56 2
   also known as SunOS 5.x, since that's what uname(1) says.  Solaris
   2.x is SVR4-based.  */
d60 1
a60 1
   code that can handle both.  The 64-bit specific code lives in
@


1.127.2.8
log
@* sparc-tdep.c (sparc32_frame_cache): Use
frame_unwind_address_in_block to obtain the current PC for use in
call to sparc32_analyze_prologue.
* sparc64-tdep.c (sparc64_frame_cache): Likewise.
@
text
@d570 1
a570 4
    {
      CORE_ADDR addr_in_block = frame_unwind_address_in_block (next_frame);
      sparc32_analyze_prologue (cache->pc, addr_in_block, cache);
    }
@


1.127.2.9
log
@* sparc-tdep.h (struct sparc_frame_cache): Rename from `struct
sparc32_frame_cache'.
(sparc_analyze_prologue, sparc_frame_cache): New prototypes.
(sparc32_frame_cache): Adjust prototype.
* sparc-tdep.c (sparc_alloc_frame_cache): Rename from
sparc32_alloc_frame_cache.  Use `struct sparc_frame_cache' instead
of `struct sparc32_frame_cache'.
(sparc_analyze_prologue): Rename from sparc32_analyze_prologue.
Use `struct sparc_frame_cache' instead of `struct
sparc32_frame_cache'.
(sparc32_skip_prologue): Use `struct sparc_frame_cache' instead of
`struct sparc32_frame_cache'.  Call sparc_analyze_prologue instead
of sparc32_analyze_prologue.
(sparc_frame_cache): New function with generic code from...
(sparc32_frame_cache): ...here.
(sparc32_frame_this_id, sparc32_frame_prev_register)
(sparc32_frame_base_address): Use `struct sparc_frame_cache'
instead of `struct sparc32_frame_cache'.
* sparc-sol2-tdep.c (sparc32_sol2_sigtramp_frame_cache)
(sparc32_sol2_sigtramp_frame_this_id)
(sparc32_sol2_sigtramp_frame_prev_register): Change return type to
`struct sparc_frame_cache *'.
* sparc-linux-tdep.c (sparc32_linux_sigtramp_frame_cache)
(sparc32_linux_sigtramp_frame_this_id)
(sparc32_linux_sigtramp_frame_prev_register): Change return type
to `struct sparc_frame_cache *'.
* sparc64-tdep.c (X_OP, X_RD, X_A, X_COND, X_OP2, X_IMM22, X_OP3)
(X_I, X_DISP22, X_DISP19): Remove macros.
(struct sparc64_frame_cache): Remove.
(sparc64_alloc_frame_cache, sparc64_analyze_prologue): Remove
functions.
(sparc64_skip_prologue): Use `struct sparc_frame_cache' instead of
`struct sparc64_frame_cache.  Call sparc_analyze_prologue instead
of sparc64_analuze_prologue.
(sparc64_frame_this_id, sparc64_frame_prev_register,
sparc64_frame_base_address): Use `struct sparc_frame_cache'
instead of `struct sparc64_frame_cache.
(sparc64_frame_cache): Change return type to `struct
sparc_frame_cache *'.  Simply call sparc_frame_cache.
@
text
@d440 2
a441 2
static struct sparc_frame_cache *
sparc_alloc_frame_cache (void)
d443 1
a443 1
  struct sparc_frame_cache *cache;
d446 1
a446 1
  cache = FRAME_OBSTACK_ZALLOC (struct sparc_frame_cache);
d460 3
a462 3
CORE_ADDR
sparc_analyze_prologue (CORE_ADDR pc, CORE_ADDR current_pc,
			struct sparc_frame_cache *cache)
d530 1
a530 1
  struct sparc_frame_cache cache;
d543 1
a543 1
  return sparc_analyze_prologue (start_pc, 0xffffffffUL, &cache);
d548 2
a549 2
struct sparc_frame_cache *
sparc_frame_cache (struct frame_info *next_frame, void **this_cache)
d551 2
a552 1
  struct sparc_frame_cache *cache;
d557 1
a557 1
  cache = sparc_alloc_frame_cache ();
d572 1
a572 1
      sparc_analyze_prologue (cache->pc, addr_in_block, cache);
a582 14
  return cache;
}

struct sparc_frame_cache *
sparc32_frame_cache (struct frame_info *next_frame, void **this_cache)
{
  struct sparc_frame_cache *cache;
  struct symbol *sym;

  if (*this_cache)
    return *this_cache;

  cache = sparc_frame_cache (next_frame, this_cache);

d605 1
a605 1
  struct sparc_frame_cache *cache =
d621 1
a621 1
  struct sparc_frame_cache *cache =
d693 1
a693 1
  struct sparc_frame_cache *cache =
@


1.127.2.10
log
@* sparc-tdep.c (sparc_stabs_unglobalize_name): New function.
* config/sparc/tm-sol2.h (SOFUN_ADDRESS_MAYBE_MISSING): Define.
(sparc_stabs_unglobalize_name): New prototype.
(STATIC_TRANSFORM_NAME, IS_STATIC_TRANSFORM_NAME): New defines.
@
text
@a970 31
/* Unglobalize NAME.  */

char *
sparc_stabs_unglobalize_name (char *name)
{
  /* The Sun compilers (Sun ONE Studio, Forte Developer, Sun WorkShop,
     SunPRO) convert file static variables into global values, a
     process known as globalization.  In order to do this, the
     compiler will create a unique prefix and prepend it to each file
     static variable.  For static variables within a function, this
     globalization prefix is followed by the function name (nested
     static variables within a function are supposed to generate a
     warning message, and are left alone).  The procedure is
     documented in the Stabs Interface Manual, which is distrubuted
     with the compilers, although version 4.0 of the manual seems to
     be incorrect in some places, at least for SPARC.  The
     globalization prefix is encoded into an N_OPT stab, with the form
     "G=<prefix>".  The globalization prefix always seems to start
     with a dollar sign '$'; a dot '.' is used as a seperator.  So we
     simply strip everything up until the last dot.  */

  if (name[0] == '$')
    {
      char *p = strrchr (name, '.');
      if (p)
	return p + 1;
    }

  return name;
}

@


1.127.2.11
log
@* sparc-tdep.c: Include "floatformat.h".
(floatformat_sparc_quad): New define.
(sparc32_gdbarch_init): Set long_double_format to
&floatformat_sparc_quad.
* sparc-linux-tdep.c: Include "floatformat.h".
(sparc32_linux_init_abi): Set long_double_format to
&floatformat_ieee_double_big.
* sparcnbsd-tdep.c: Likewise.
@
text
@a24 1
#include "floatformat.h"
a62 4
/* The SPARC Floating-Point Quad-Precision format is similar to
   big-endian IA-64 Quad-recision format.  */
#define floatformat_sparc_quad floatformat_ia64_quad_big

a1022 1
  set_gdbarch_long_double_format (gdbarch, &floatformat_sparc_quad);
@


1.127.2.12
log
@* sparc-tdep.h: Update copyright year.
(sparc_fetch_instruction): New prototype.
* sparc-tdep.c: Update copyright year.
(sparc_fetch_instruction): Make global.
* sparc64-tdep.c: Update copyright year.
(sparc_fetch_instruction): Remove function.
(X_OP, X_RD, X_A, X_COND, X_OP2, X_IMM22, X_OP3, X_I, X_DISP22)
(X_DISP19): Really remove macros.
* sparc64-sol2-tdep.c: Update copyright year.
* sparc64fbsd-tdep.c: Likewise.
@
text
@d3 1
a3 1
   Copyright 2003, 2004 Free Software Foundation, Inc.
d90 1
a90 1
unsigned long
@


1.126
log
@2003-09-17  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_BYTE): Rename REGISTER_BYTE.
	* gdbarch.h, gdbarch.c: Regenerate.
	* arm-linux-tdep.c, core-sol2.c, cris-tdep.c: Update.
	* d10v-tdep.c, frame.c: Update.
	* hppa-tdep.c, hppab-nat.c, hppah-nat.c, hppam3-nat.c: Update.
	* hpux-thread.c, i386gnu-nat.c, ia64-aix-nat.c: Update.
	* ia64-linux-nat.c, irix5-nat.c, lynx-nat.c, m68knbsd-nat.c: Update.
	* mcore-tdep.c, mips-linux-tdep.c, mips-tdep.c: Update.
	* mipsv4-nat.c, mn10300-tdep.c, ns32k-tdep.c: Update.
	* ns32knbsd-nat.c, ppc-bdm.c, regcache.c, remote-sds.c: Update.
	* remote-vx68.c, remote-vxmips.c, remote-vxsparc.c: Update.
	* remote.c, rs6000-tdep.c, s390-tdep.c, sh64-tdep.c: Update.
	* sparc-nat.c, sparc-tdep.c, sun3-nat.c, v850-tdep.c: Update.
	* v850ice.c, vax-tdep.c, xstormy16-tdep.c: Update.
	* config/m68k/tm-cisco.h, config/m68k/tm-delta68.h: Update.
	* config/pa/nm-hppah.h: Update.

2003-09-17  Andrew Cagney  <cagney@@redhat.com>

	* mi/mi-main.c: Rename REGISTER_BYTE to DEPRECATED_REGISTER_BYTE.
@
text
@d171 1
a171 1
   step-breakpoint was set, not necessary the current value of NPC_REGNUM.  */
d198 1
a198 1
      next_pc = read_register (NPC_REGNUM);
d1323 4
a1326 4
      if (fsr[NPC_REGNUM])
	write_register (NPC_REGNUM,
			read_memory_integer (fsr[NPC_REGNUM],
					     REGISTER_RAW_SIZE (NPC_REGNUM)));
d1345 1
a1345 1
      write_register (NPC_REGNUM, pc + 4);
d1353 1
a1353 1
      write_register (NPC_REGNUM, pc + 4);
d1482 1
a1482 1
  supply_register (NPC_REGNUM, ((char *) (regp + R_nPC)) + offset);
d1601 2
a1602 2
  if ((regno == -1) || (regno == NPC_REGNUM))
    deprecated_read_register_gen (NPC_REGNUM, (char *) (regp + R_nPC) + offset);
d3387 1
a3387 1
      set_gdbarch_npc_regnum (gdbarch, SPARC32_NPC_REGNUM);
d3436 1
a3436 1
      set_gdbarch_npc_regnum (gdbarch, SPARC64_NPC_REGNUM);
@


1.125
log
@2003-09-14  Andrew Cagney  <cagney@@redhat.com>

	* alpha-nat.c: Remove some occurances of "register".
	* alpha-tdep.c, arm-tdep.c, blockframe.c, breakpoint.c: Ditto.
	* buildsym.c, c-typeprint.c, c-valprint.c, coffread.c: Ditto.
	* corefile.c, cp-support.c, cp-valprint.c, cris-tdep.c: Ditto.
	* dbxread.c, dcache.c, dwarf2read.c, elfread.c: Ditto.
	* environ.c, eval.c, event-top.c, f-typeprint.c: Ditto.
	* f-valprint.c, findvar.c, frame.c, gdbtypes.c: Ditto.
	* h8300-tdep.c, hppa-tdep.c, hppab-nat.c, hppah-nat.c: Ditto.
	* hppam3-nat.c, hpread.c, ia64-aix-nat.c, ia64-linux-nat.c: Ditto.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Ditto.
	* infttrace.c, irix5-nat.c, jv-typeprint.c: Ditto.
	* jv-valprint.c, m68k-tdep.c, m68klinux-nat.c, main.c: Ditto.
	* mdebugread.c, minsyms.c, mips-linux-tdep.c: Ditto.
	* mips-nat.c, mips-tdep.c, mipsread.c, mipsv4-nat.c: Ditto.
	* ns32k-tdep.c, objfiles.c, p-typeprint.c: Ditto.
	* p-valprint.c, ppc-linux-nat.c, printcmd.c: Ditto.
	* remote-mips.c, remote-vx.c, rs6000-nat.c: Ditto.
	* rs6000-tdep.c, scm-exp.c, sh-tdep.c, sh64-tdep.c: Ditto.
	* solib.c, somread.c, source.c, sparc-tdep.c: Ditto.
	* stabsread.c, stack.c, standalone.c, symfile.c: Ditto.
	* symmisc.c, symtab.c, top.c, tracepoint.c: Ditto.
	* typeprint.c, utils.c, valarith.c, valops.c: Ditto.
	* values.c, vax-tdep.c, xcoffread.c: Ditto.
@
text
@d939 1
a939 1
      addr = REGISTER_BYTE (regnum);
d975 1
a975 1
      deprecated_read_register_bytes (REGISTER_BYTE (PC_REGNUM),
d978 1
a978 1
      deprecated_read_register_bytes (REGISTER_BYTE (PSTATE_REGNUM), 
d986 1
a986 1
      deprecated_read_register_bytes (REGISTER_BYTE (Y_REGNUM),
d991 1
a991 1
  deprecated_read_register_bytes (REGISTER_BYTE (O0_REGNUM),
d995 1
a995 1
  deprecated_read_register_bytes (REGISTER_BYTE (G0_REGNUM),
d1000 1
a1000 1
    deprecated_read_register_bytes (REGISTER_BYTE (FP0_REGNUM),
d1227 1
a1227 1
	  deprecated_write_register_bytes (REGISTER_BYTE (FP0_REGNUM),
d1247 1
a1247 1
      deprecated_write_register_bytes (REGISTER_BYTE (G1_REGNUM), raw_buffer,
d1300 1
a1300 1
      deprecated_write_register_bytes (REGISTER_BYTE (O0_REGNUM), raw_buffer,
d1303 1
a1303 1
      deprecated_write_register_bytes (REGISTER_BYTE (L0_REGNUM), reg_temp,
d1714 1
a1714 1
	  from = (char *) &deprecated_registers[REGISTER_BYTE (regi)];
d1723 1
a1723 1
	from = (char *)&deprecated_registers[REGISTER_BYTE (FPS_REGNUM)];
d2419 1
a2419 1
    deprecated_write_register_bytes (REGISTER_BYTE (regno), valbuf,
d2696 1
a2696 1
	      deprecated_write_register_bytes (REGISTER_BYTE (fpreg),
d2729 1
a2729 1
      memcpy (valbuf, &regbuf[REGISTER_BYTE (FP0_REGNUM)], typelen);
@


1.124
log
@* cris-tdep.c (cris_gdbarch_init): Set
deprecated_reg_struct_has_addr instead of reg_struct_has_addr.
* hppa-tdep.c (hppa_gdbarch_init): Likewise.
* mcore-tdep.c (mcore_gdbarch_init): Likewise.
* mips-tdep.c (mips_gdbarch_init): Likewise.
* mn10300-tdep.c (mn10300_gdbarch_init): Likewise.
* sparc-tdep.c (sparc_gdbarch_init): Likewise.
@
text
@d1096 1
a1096 1
  register int regnum;
d1213 2
a1214 2
  register struct frame_info *frame = get_current_frame ();
  register CORE_ADDR pc;
d1665 1
a1665 1
  register int regi;
@


1.123
log
@2003-09-11  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_STACK_ALIGN): Rename STACK_ALIGN.
	* gdbarch.h, gdbarch.c: Re-generate.
	* infcall.c (call_function_by_hand): Update.
	* hppa-tdep.c (hppa_push_arguments): Update.
	* ada-lang.c (place_on_stack): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Delete comment refering to
	stack_align.
@
text
@d3288 2
a3289 1
  set_gdbarch_reg_struct_has_addr (gdbarch, sparc_reg_struct_has_addr);
@


1.122
log
@2003-09-04  Andrew Cagney  <cagney@@redhat.com>

	* avr-tdep.c: Include "dis-asm.h".
	* cris-tdep.c: Include "dis-asm.h".
	(cris_delayed_get_disassembler): Use "struct disassemble_info"
	instead of corresponding typedef.
	* h8300-tdep.c: Include "dis-asm.h".
	* ia64-tdep.c: Include "dis-asm.h".
	* i386-tdep.c: Include "dis-asm.h".
	(i386_print_insn): Use "struct disassemble_info" instead of
	corresponding typedef.
	* m68k-tdep.c: Include "dis-asm.h".
	* mcore-tdep.c: Include "dis-asm.h".
	* mips-tdep.c: Include "dis-asm.h".
	(gdb_print_insn_mips): Make static, use "struct disassemble_info"
	instead of corresponding typedef.
	* ns32k-tdep.c: Include "dis-asm.h".
	* s390-tdep.c: Include "dis-asm.h".
	* sparc-tdep.c: Include "dis-asm.h".
	* vax-tdep.c: Include "dis-asm.h".
	* v850-tdep.c: Include "dis-asm.h".
	* mn10300-tdep.c: Include "dis-asm.h".
	* rs6000-tdep.c: Include "dis-asm.h".
	* xstormy16-tdep.c: Include "dis-asm.h".
	(_initialize_xstormy16_tdep): Delete "extern" declaration of
	print_insn_xstormy16.
	* Makefile.in (v850-tdep.o): Update dependencies.
	(vax-tdep.o, sparc-tdep.o, s390-tdep.o): Ditto.
	(ns32k-tdep.o, mips-tdep.o, mcore-tdep.o): Ditto.
	(m68k-tdep.o, ia64-tdep.o, i386-tdep.o): Ditto.
	(h8300-tdep.o, cris-tdep.o, avr-tdep.o): Ditto.
	(mn10300-tdep.o, xstormy16-tdep.o, disasm.o): Ditto.
	(gdbarch_h): Remove $(dis_asm_h).
	* disasm.c: Include "dis-asm.h".
	(dis_asm_read_memory): Use "struct disassemble_info" instead of
	corresponding typedef.
	(dis_asm_memory_error, dump_insns, do_assembly_only): Ditto.
	(gdb_disassemble_info, gdb_disassembly, gdb_print_insn): Ditto.
	* gdbarch.sh: Do not include "dis-asm.h".
	(struct disassemble_info): Declare opaque.
	(TARGET_PRINT_INSN): Update declaration.
	* gdbarch.h, gdbarch.c: Re-generate.
@
text
@d3401 1
a3401 1
      set_gdbarch_stack_align (gdbarch, sparc32_stack_align);
d3454 1
a3454 1
      set_gdbarch_stack_align (gdbarch, sparc64_stack_align);
@


1.121
log
@2003-09-08  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_CALL_DUMMY_ADDRESS): Rename
	CALL_DUMMY_ADDRESS, change to a predicate.
	* gdbarch.h, gdbarch.c: Re-generate.
	* blockframe.c (deprecated_pc_in_call_dummy_at_entry_point):
	Use either DEPRECATED_CALL_DUMMY_ADDRESS or entry_point_address.
	* infcall.c (call_function_by_hand): Ditto.
	* sparc-tdep.c (sparc_push_return_address): Ditto.
	(sparc_gdbarch_init): Set deprecated_call_dummy_address.
	* xstormy16-tdep.c (xstormy16_push_return_address): Replace
	CALL_DUMMY_ADDRESS with entry_point_address.
	* v850-tdep.c (v850_push_return_address): Ditto.
	* s390-tdep.c (s390_push_return_address): Ditto.
	* rs6000-tdep.c (ppc_push_return_address): Ditto.
	* mn10300-tdep.c (mn10300_push_return_address): Ditto.
	* mcore-tdep.c (mcore_push_return_address): Ditto.
	* cris-tdep.c (cris_push_return_address): Ditto.
	* arm-tdep.c (arm_push_return_address): Ditto.
@
text
@d36 1
@


1.120
log
@2003-08-27  Andrew Cagney  <cagney@@redhat.com>

	* Makefile.in (cris-tdep.o): Update dependencies.
	* cris-tdep.c: Include "gdb_assert.h".
	(cris_gdbarch_init): Set print_insn.
	(_initialize_cris_tdep): Do not set deprecated_tm_print_insn.
	(cris_delayed_get_disassembler): Simplify, directly call the
	disassembler returned by cris_get_disassembler.
	* hppa-tdep.c (hppa_gdbarch_init): Set print_insn.
	(_initialize_hppa_tdep): Do not set deprecated_tm_print_insn.
	* ns32k-tdep.c (ns32k_gdbarch_init): Set print_insn.
	(_initialize_ns32k_tdep): Do not set deprecated_tm_print_insn.
	* mn10300-tdep.c (mn10300_gdbarch_init): Set print_insn.
	(_initialize_mn10300_tdep): Do not set deprecated_tm_print_insn.
	* mcore-tdep.c (mcore_gdbarch_init): Set print_insn.
	(_initialize_mcore_tdep): Do not set deprecated_tm_print_insn.
	* frv-tdep.c (frv_gdbarch_init): Set print_insn.
	(_initialize_frv_tdep): Do not set deprecated_tm_print_insn.
	* sparc-tdep.c (sparc_gdbarch_init): Set print_insn.
	(gdb_print_insn_sparc): Delete function.
	(_initialize_sparc_tdep): Do not set deprecated_tm_print_insn or
	deprecated_tm_print_insn_info.
	* v850-tdep.c (v850_gdbarch_init): Set print_insn.
	(_initialize_v850_tdep): Do not set deprecated_tm_print_insn.
	(v850_gdbarch_init): Do not set deprecated_tm_print_insn_info.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Set print_insn.
	(_initialize_xstormy16_tdep): Do not set deprecated_tm_print_insn.
	* s390-tdep.c (gdb_print_insn_s390): Delete function.
	(_initialize_s390_tdep): Do not set deprecated_tm_print_insn.
	(s390_gdbarch_init): Set print_insn.
@
text
@d2970 4
a2973 2
      write_register (O7_REGNUM, 
		      CALL_DUMMY_ADDRESS () - 8);
d3141 2
a3142 1
/* CALL_DUMMY_ADDRESS: fetch the breakpoint address for a call dummy.  */
d3320 1
a3320 1
      set_gdbarch_call_dummy_address (gdbarch, sparc_call_dummy_address);
d3420 1
a3420 1
      set_gdbarch_call_dummy_address (gdbarch, sparc_call_dummy_address);
@


1.119
log
@2003-08-24  Andrew Cagney  <cagney@@redhat.com>

	* arm-tdep.c (_initialize_arm_tdep): Simplify by assuming
	GDB_MULTI_ARCH is always non-zero.
	* osabi.c (_initialize_gdb_osabi): Ditto.
	(gdbarch_init_osabi): Ditto.
	* sparc-tdep.c: Ditto for #if code.
@
text
@a2141 10

static int
gdb_print_insn_sparc (bfd_vma memaddr, disassemble_info *info)
{
  /* It's necessary to override mach again because print_insn messes it up. */
  info->mach = TARGET_ARCHITECTURE->mach;
  return print_insn_sparc (memaddr, info);
}


a2551 2
  deprecated_tm_print_insn = gdb_print_insn_sparc;
  deprecated_tm_print_insn_info.mach = TM_PRINT_INSN_MACH;		/* Selects sparc/sparclite */
d3567 2
@


1.118
log
@2003-07-17  Andrew Cagney  <cagney@@redhat.com>

	* defs.h (GDB_MULTI_ARCH): Delete conditional define.  Handled by
	configure.
	* sparc-tdep.c (sparc_intreg_size): Make non-static.
	* config/sparc/tm-sparc.h (GDB_MULTI_ARCH): Define to
	GDB_MULTI_ARCH_PARTIAL.
@
text
@a53 2
#if (GDB_MULTI_ARCH > 0)

a66 43

#else /* non-multi-arch */


/* Does the target have Floating Point registers?  */
#if 0
// OBSOLETE #if defined(TARGET_SPARCLET) || defined(TARGET_SPARCLITE)
// OBSOLETE #define SPARC_HAS_FPU 0
// OBSOLETE #else
// OBSOLETE #define SPARC_HAS_FPU 1
// OBSOLETE #endif
#endif
#define SPARC_HAS_FPU 1

/* Number of bytes devoted to Floating Point registers: */
#if (GDB_TARGET_IS_SPARC64)
#define FP_REGISTER_BYTES (64 * 4)
#else
#if (SPARC_HAS_FPU)
#define FP_REGISTER_BYTES (32 * 4)
#else
#define FP_REGISTER_BYTES 0
#endif
#endif

/* Highest numbered Floating Point register.  */
#if (GDB_TARGET_IS_SPARC64)
#define FP_MAX_REGNUM (FP0_REGNUM + 48)
#else
#define FP_MAX_REGNUM (FP0_REGNUM + 32)
#endif

/* Size of a general (integer) register: */
#define SPARC_INTREG_SIZE (REGISTER_RAW_SIZE (G0_REGNUM))

/* Offset within the call dummy stack of the saved registers.  */
#if (GDB_TARGET_IS_SPARC64)
#define DUMMY_REG_SAVE_OFFSET (128 + 16)
#else
#define DUMMY_REG_SAVE_OFFSET 0x60
#endif

#endif /* GDB_MULTI_ARCH */
@


1.117
log
@	* Makefile.in (sparc_tdep_h): New.
	(sparc-linux-nat.o, sparc-nat.o, sparc-tdep.o, sparc64nbsd-nat.o)
	(sparcnbsd-nat.o, sparcnbsd-tdep.o): Depend on $(sparc_tdep_h).
	* sparc-linux-nat.c: Include "sparc-tdep.h".
	* sparc-nat.c: Likewise.
	* sparc-tdep.c: Likewise.
	* sparc64nbsd-nat.c: Likewise.
	* sparcnbsd-nat.c: Likewise.
	* sparcnbsd-tdep.c: Likewise.
	* sparc-tdep.h: New file.
	* config/sparc/tm-sparc.h: Remove prototypes for sparc_y_regnum
	and sparc_npc_regnum.
@
text
@d3221 1
a3221 1
static int
@


1.116
log
@2003-07-03  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (REGISTER_NAME): Do not supply a default.
	* gdbarch.h, gdbarch.c: Re-generate.
	* config/sparc/tm-sparc.h (REGISTER_NAME): Define.
	(legacy_register_name): Declare.
	* config/sparc/tm-sp64.h (legacy_register_name): Declare.
	(REGISTER_NAME): Define.
	* sparc-tdep.c (legacy_register_name): New function.
	* config/pa/tm-hppa64.h (REGISTER_NAMES): Delete macro.
	(REGISTER_NAME): Define.
	(hppa64_register_name): Declare.
	* config/pa/tm-hppa.h (REGISTER_NAMES): Delete macro.
	* hppa-tdep.c (hppa_gdbarch_init): Set hppa_register_name.
	(hppa64_register_name): New function.
	(hppa_register_name): New function.
	* arch-utils.c (legacy_register_name): Delete.
	* arch-utils.h (legacy_register_name): Delete.
@
text
@d37 2
@


1.115
log
@        * sparc-tdep.c (stop_after_trap): Remove declaration, not used.
@
text
@d2874 16
@


1.114
log
@	* sparc-tdep.c (sparc_y_regnum): Make external again.
@
text
@a132 3
/* From infrun.c */
extern int stop_after_trap;

@


1.113
log
@2003-06-13  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh: Update comments on registers, re-order.
	(deprecated_register_byte): Rename register_byte.
	(deprecated_register_raw_size): Rename register_raw_size.
	(deprecated_register_virtual_size): Rename register_virtual_size.
	(deprecated_register_virtual_type): Rename register_virtual_type.
	* gdbarch.h, gdbarch.c: Re-generate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c: Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
@
text
@d3191 1
a3191 1
static int
@


1.113.4.1
log
@	* sparc-tdep.c (sparc_y_regnum): Make external again.
@
text
@d3191 1
a3191 1
int
@


1.113.4.2
log
@2003-07-07  Daniel Jacobowitz  <drow@@mvista.com>

	* Makefile.in (sparc_tdep_h): New.
	(sparc-linux-nat.o, sparc-nat.o, sparc-tdep.o, sparc64nbsd-nat.o)
	(sparcnbsd-nat.o, sparcnbsd-tdep.o): Depend on $(sparc_tdep_h).
	* sparc-linux-nat.c: Include "sparc-tdep.h".
	* sparc-nat.c: Likewise.
	* sparc-tdep.c: Likewise.
	* sparc64nbsd-nat.c: Likewise.
	* sparcnbsd-nat.c: Likewise.
	* sparcnbsd-tdep.c: Likewise.
	* sparc-tdep.h: New file.
	* config/sparc/tm-sparc.h: Remove prototypes for sparc_y_regnum
	and sparc_npc_regnum.
@
text
@a36 2
#include "sparc-tdep.h"

@


1.112
log
@2003-06-11  Andrew Cagney  <cagney@@redhat.com>

	* xstormy16-tdep.c (xstormy16_push_return_address): Make static.
	(xstormy16_save_dummy_frame_tos): Make static.
	(_initialize_xstormy16_tdep): Add declaration.
	* vax-tdep.c (_initialize_vax_tdep): Add declaration.
	* v850-tdep.c: Make local functions static.
	(_initialize_v850_tdep): Add declaration.
	* sparc-tdep.c: Make local functions static.
	(_initialize_sparc_tdep): Add declaration.
	* sh-tdep.c: Make local functions static.
	(_initialize_sh_tdep): Add declaration.
	* sh3-rom.c (_initialize_sh3_rom): Add declaration.
	* s390-tdep.c: Make local functions static.
	(_initialize_s390_tdep): Add declaration.
	* dbxread.c (find_stab_function_addr): Make static.
	* ppc-bdm.c (_initialize_bdm_ppc): Add declaration.
	* ocd.c (_initialize_remote_ocd): Add declaration.
	* dink32-rom.c (_initialize_dink32_rom): Add declaration.
	* ppcbug-rom.c (_initialize_ppcbug_rom): Add declaration.
	* ns32k-tdep.c (_initialize_ns32k_tdep): Add declaration.
	* ns32knbsd-tdep.c (_initialize_ns32knbsd_tdep): Add declaration.
	* mips-tdep.c (_initialize_mips_tdep): Add declaration.
	* remote-array.c (_initialize_array): Add declaration.
	(_initialize_remote_monitors): Add declaration.
	* remote-mips.c: Make local functions static.
	(_initialize_remote_mips): Add declaration.
	* mcore-tdep.c: Make all local functions static.
	(_initialize_mcore_tdep): Add declaration.
	* dbug-rom.c (_initialize_dbug_rom): Add declaration.
	* abug-rom.c (_initialize_abug_rom): Add declaration.
	* rom68k-rom.c (_initialize_rom68k): Add declaration.
	* cpu32bug-rom.c (_initialize_cpu32bug_rom): Add declaration.
	* m68k-tdep.c (_initialize_m68k_tdep): Add declaration.
	* remote-est.c (_initialize_est): Add declaration.
	* m68hc11-tdep.c (_initialize_m68hc11_tdep): Add declaration.
	(m68hc11_call_dummy_address): Make static.
	* ia64-tdep.c: Make local functions static.
	(_initialize_ia64_tdep): Add declaration.
	* solib-legacy.c (_initialize_svr4_lm): Add declaration.
	* monitor.c (monitor_wait_filter): Make static.
	(_initialize_remote_monitors): Add declaration.
	* remote-hms.c (_initialize_remote_hms): Add declaration.
	* remote-e7000.c (fetch_regs_from_dump): Make static.
	(expect_n): Make static.
	(_initialize_remote_e7000): Add declaration.
	* ser-e7kpc.c: Always include "defs.h".
	(_initialize_ser_e7000pc): Add declaration.
	* h8300-tdep.c (_initialize_h8300_tdep): Add declaration.
	* cris-tdep.c: Make all but one function static.
	(_initialize_cris_tdep): Add declaration.
	* solib-svr4.c (_initialize_svr4_solib): Add declaration.
	* solib.c (update_solib_list): Make static.
	(_initialize_solib): Add declaration.
	* avr-tdep.c (avr_breakpoint_from_pc): Make static.
	(_initialize_avr_tdep): Add declaration.
	* remote-rdi.c (voiddummy): Make static.
	(_initialize_remote_rdi): Add declaration.
	* arm-tdep.c (_initialize_arm_tdep): Add declaration.
	* remote-rdp.c (send_rdp): Make static.
	(_initialize_remote_rdp): Add declaration.
	* alpha-tdep.c (_initialize_alpha_tdep): Add declaration.
@
text
@d3429 2
a3430 2
      set_gdbarch_register_byte (gdbarch, sparc32_register_byte);
      set_gdbarch_register_raw_size (gdbarch, sparc32_register_size);
d3432 2
a3433 3
      set_gdbarch_register_virtual_size (gdbarch, sparc32_register_size);
      set_gdbarch_register_virtual_type (gdbarch, 
					 sparc32_register_virtual_type);
d3482 2
a3483 2
      set_gdbarch_register_byte (gdbarch, sparc64_register_byte);
      set_gdbarch_register_raw_size (gdbarch, sparc64_register_size);
d3485 2
a3486 3
      set_gdbarch_register_virtual_size (gdbarch, sparc64_register_size);
      set_gdbarch_register_virtual_type (gdbarch, 
					 sparc64_register_virtual_type);
@


1.111
log
@2003-06-09  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (FRAME_NUM_ARGS): Change to function with predicate.
	* gdbarch.h, gdbarch.c: Re-generate.
	* arch-utils.h (frame_num_args_unknown): Delete both declarations.
	* arch-utils.c (frame_num_args_unknown): Delete function.
	* stack.c (print_args_stub): Use FRAME_NUM_ARGS_P.
	(frame_info): Use FRAME_NUM_ARGS_P.
	* arm-tdep.c (arm_frame_num_args): Delete function.
	(arm_gdbarch_init): Do not set frame_num_args.
	* config/pa/tm-hppa64.h (FRAME_NUM_ARGS): Delete.
	* hppa-tdep.c (hppa_frame_num_args): Delete function.
	(hppa_gdbarch_init): Do not set frame_num_args.
	* config/sparc/tm-sparc.h (FRAME_NUM_ARGS): Delete.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	frame_num_args to default frame_num_args_unknown.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
@
text
@d2189 1
a2189 1
int
d2451 1
a2451 1
void
d2600 2
d2616 1
a2616 1
CORE_ADDR
d2626 1
a2626 1
CORE_ADDR
d2636 1
a2636 1
void
d2660 1
a2660 1
CORE_ADDR
d2777 1
a2777 1
void
d2834 1
a2834 1
extern void
d2860 1
a2860 1
extern CORE_ADDR
d2998 1
a2998 1
CORE_ADDR
d3191 1
a3191 1
int
d3206 1
a3206 1
int
d3223 3
a3225 2
CORE_ADDR
sparc_fetch_pointer_argument (struct frame_info *frame, int argi, struct type *type)
@


1.110
log
@2003-06-07  Andrew Cagney  <cagney@@redhat.com>

	* inferior.h (deprecated_write_sp): Replace
	generic_target_write_sp.
	* regcache.c (deprecated_write_sp): Replace
	generic_target_write_sp.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* config/pa/tm-hppa.h (DEPRECATED_DUMMY_WRITE_SP): Update.
@
text
@a3308 1
  set_gdbarch_frame_num_args (gdbarch, frame_num_args_unknown);
@


1.109
log
@2003-06-07  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (TARGET_READ_SP): Add predicate, delete default.
	* gdbarch.h, gdbarch.c: Regenerate.
	* mn10300-tdep.c: Include "gdb_assert.h".
	(mn10300_read_fp): New function.
	(mn10300_gdbarch_init): Set deprecated_target_read_fp to
	mn10300_read_fp.  Do not set read_sp to generic_target_read_sp.
	* ia64-tdep.c: Include "gdb_assert.h".
	(ia64_read_fp): New function.
	(ia64_gdbarch_init): Set deprecated_target_read_fp to
	ia64_read_sp.  Do not set read_sp to generic_target_read_sp.
	* regcache.c (generic_target_read_sp): Delete function.
	(read_sp): Try TARGET_READ_SP and SP_REGNUM for the SP register.
	* inferior.h (generic_target_read_sp): Delete declaration.
	* frv-tdep.c (frv_gdbarch_init): Do not set read_sp to
	generic_target_read_sp.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* Makefile.in (mn10300-tdep.o, ia64-tdep.o): Update dependencies.
@
text
@d3443 1
a3443 1
      set_gdbarch_deprecated_dummy_write_sp (gdbarch, generic_target_write_sp);
@


1.108
log
@2003-06-07  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (TARGET_READ_PC): Add predicate, remove default.
	* gdbarch.h, gdbarch.c: Re-generate.
	* regcache.c: Update comments on read_pc et.al.
	(generic_target_read_pc): Delete function.
	(read_pc_pid): Try TARGET_READ_PC and PC_REGNUM for a PC register.
	* inferior.h (generic_target_read_pc): Delete declaration.
	* frv-tdep.c (frv_gdbarch_init): Do not set read_pc to
	generic_target_read_pc.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
@
text
@a3425 1
      set_gdbarch_read_sp (gdbarch, generic_target_read_sp);
@


1.107
log
@2003-06-03  Andrew Cagney  <cagney@@redhat.com>

	* sparc-tdep.c (sparc_convert_to_virtual): Delete function.
	(sparc_convert_to_raw): Delete function.
	(sparc_gdbarch_init): Do not set register_convert_to_raw or
	register_convert_to_virtual.
@
text
@a3323 1
  set_gdbarch_read_pc (gdbarch, generic_target_read_pc);
@


1.106
log
@2003-06-02  Andrew Cagney  <cagney@@redhat.com>

	* alpha-tdep.c (alpha_gdbarch_init): Set convert_register_p,
	register_to_value, and value_to_register, instead of
	register_convertible, register_convert_to_raw, and
	register_convert_to_virtual.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_print_registers): Delete call to
	REGISTER_CONVERTIBLE.
	(sparc_gdbarch_init): Do not set register_convertible.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
@
text
@a3154 13
/* Convert registers between 'raw' and 'virtual' formats.
   They are the same on sparc, so there's nothing to do.  */

static void
sparc_convert_to_virtual (int regnum, struct type *type, char *from, char *to)
{	/* do nothing (should never be called) */
}

static void
sparc_convert_to_raw (struct type *type, int regnum, char *from, char *to)
{	/* do nothing (should never be called) */
}

a3324 3
  set_gdbarch_register_convert_to_raw (gdbarch, sparc_convert_to_raw);
  set_gdbarch_register_convert_to_virtual (gdbarch, 
					   sparc_convert_to_virtual);
@


1.105
log
@* gdbarch.sh (function_list): Add FETCH_POINTER_ARGUMENT.
* gdbarch.[ch]: Regenerate.
* hppa-tdep.c (hppa_fetch_pointer_argument): New function.
(hppa_gdbarch_init): Set it in the gdbarch vector.
* i386-tdep.c (i386_fetch_pointer_argument): New
(i386_gdbarch_init): Set it into gdbarch.
* rs6000-tdep.c (rs6000_fetch_pointer_argument): New.
(rs6000_gdbarch_init): Set it in gdbarch.
* sparc-tdep.c (sparc_fetch_pointer_argument): New
(sparc_gdbarch_init): Set it in gdbarch.
@
text
@d2107 1
a2107 14
      /* FIXME: cagney/2002-08-03: This code shouldn't be necessary.
         The function frame_register_read() should have returned the
         pre-cooked register so no conversion is necessary.  */
      /* Convert raw data to virtual format if necessary.  */
      if (REGISTER_CONVERTIBLE (i))
	{
	  REGISTER_CONVERT_TO_VIRTUAL (i, REGISTER_VIRTUAL_TYPE (i),
				       raw_buffer, virtual_buffer);
	}
      else
	{
	  memcpy (virtual_buffer, raw_buffer,
		  REGISTER_VIRTUAL_SIZE (i));
	}
a3340 2
  set_gdbarch_register_convertible (gdbarch, 
				    generic_register_convertible_not);
@


1.104
log
@2003-06-01  Andrew Cagney  <cagney@@redhat.com>

	* defs.h (extract_address): Delete declaration.
	* findvar.c (extract_address): Delete function.
	* xstormy16-tdep.c (xstormy16_extract_return_value): Replace
	extract_address with the inline equivalent,
	extract_unsigned_integer.
	(xstormy16_extract_struct_value_address): Ditto.
	(xstormy16_pointer_to_address): Ditto.
	* vax-tdep.c (vax_extract_struct_value_address): Ditto.
	* v850-tdep.c (v850_push_arguments): Ditto.
	(v850_extract_return_value): Ditto.
	(v850_extract_struct_value_address): Ditto.
	* sparcnbsd-tdep.c (sparcnbsd_get_longjmp_target_32): Ditto.
	(sparcnbsd_get_longjmp_target_64): Ditto.
	* sparc-tdep.c (sparc_frame_saved_pc): Ditto.
	(get_longjmp_target): Ditto.
	* sh-tdep.c (sh_extract_struct_value_address): Ditto.
	(sh64_extract_struct_value_address): Ditto.
	(sh_push_arguments): Ditto.
	(sh64_push_arguments): Ditto.
	* remote-vxsparc.c (vx_read_register): Ditto.
	* ppc-linux-tdep.c (ppc_linux_skip_trampoline_code): Ditto.
	* ns32k-tdep.c (ns32k_extract_struct_value_address): Ditto.
	* mn10300-tdep.c (mn10300_extract_struct_value_address): Ditto.
	* mipsv4-nat.c (get_longjmp_target): Ditto.
	* mipsnbsd-tdep.c (mipsnbsd_get_longjmp_target): Ditto.
	* mips-nat.c (get_longjmp_target): Ditto.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target): Ditto.
	* mcore-tdep.c (mcore_extract_struct_value_address): Ditto.
	* m68k-tdep.c (m68k_get_longjmp_target): Ditto.
	* m68hc11-tdep.c (m68hc11_extract_struct_value_address): Ditto.
	* irix5-nat.c (get_longjmp_target): Ditto.
	* irix4-nat.c (get_longjmp_target): Ditto.
	* ia64-tdep.c (generic_elf_find_global_pointer): Ditto.
	(ia64_push_arguments): Ditto.
	* hpux-thread.c (hpux_thread_store_registers): Ditto.
	* h8300-tdep.c (h8300_push_arguments): Ditto.
	(h8300_store_return_value): Ditto.
	(h8300_extract_struct_value_address): Ditto.
	* frv-tdep.c (frv_extract_struct_value_address): Ditto.
	(frv_push_arguments): Ditto.
	* avr-tdep.c (avr_pointer_to_address): Ditto.
	(avr_push_arguments): Ditto.
	* arm-tdep.c (arm_push_dummy_call): Ditto.
	(arm_get_longjmp_target): Ditto.
	* arm-linux-tdep.c (arm_linux_push_arguments): Ditto.
	* alpha-tdep.c (alpha_extract_struct_value_address): Ditto.
	(alpha_get_longjmp_target): Ditto.
@
text
@d3246 9
d3365 3
@


1.103
log
@* sparc-tdep.c (sparc32_do_push_arguments): New function.
(sparc32_push_arguments): Re-implement by calling
sparc32_do_push_arguments.
@
text
@d511 1
a511 1
      return extract_address (scbuf, sizeof (scbuf));
d537 1
a537 1
  return PC_ADJUST (extract_address (buf, SPARC_INTREG_SIZE));
d1799 1
a1799 1
  *pc = extract_address (buf, LONGJMP_TARGET_SIZE);
@


1.102
log
@* sparc-tdep.c (SPARC_F0_REGNUM, SPARC_F1_REGNUM, SPARC_O0_REGNUM,
SPARC_O1_REGNUM): New defines.
(sparc32_extract_return_value): Rewrite to operate on a regcache.
(sparc32_store_return_value): New function.
(sparc_extract_struct_value_address): Rewrite to operate on a
regcache.
(sparc_gdbarch_init): Don't set
deprecated_extract_struct_value_address.  Set
extract_struct_value_address instead. Don't set
deprecated_extract_return_value and deprecated_store_return_value
for 32-bit targets.  Set extract_return_value and
store_return_value instead.
* config/sparc/tm-sparc.h (DEPRECATED_STORE_RETURN_VALUE,
DEPRECTAED_EXTRACT_RETURN_VALUE,
DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS): Don't define these.
(STORE_RETURN_VALUE, EXTRACT_RETURN_VALUE,
EXTRACT_STRUCT_VALUE_ADDRESS): Define these instead.
(sparc_store_return_value): Remove prototype.
(sparc32_store_return_value): New prototype.
(sparc32_extract_return_value, sparc_extract_struct_value_address):
Adjust prototypes.
@
text
@a2209 3
/* The SPARC passes the arguments on the stack; arguments smaller
   than an int are promoted to an int.  The first 6 words worth of 
   args are also passed in registers o0 - o5.  */
d2211 10
a2220 3
CORE_ADDR
sparc32_push_arguments (int nargs, struct value **args, CORE_ADDR sp,
			int struct_return, CORE_ADDR struct_addr)
d2222 48
a2269 3
  int i, j, oregnum;
  int accumulate_size = 0;
  struct sparc_arg
d2271 1
a2271 1
      char *contents;
d2273 7
a2279 14
      int offset;
    };
  struct sparc_arg *sparc_args =
    (struct sparc_arg *) alloca (nargs * sizeof (struct sparc_arg));
  struct sparc_arg *m_arg;

  /* Promote arguments if necessary, and calculate their stack offsets
     and sizes. */
  for (i = 0, m_arg = sparc_args; i < nargs; i++, m_arg++)
    {
      struct value *arg = args[i];
      struct type *arg_type = check_typedef (VALUE_TYPE (arg));
      /* Cast argument to long if necessary as the compiler does it too.  */
      switch (TYPE_CODE (arg_type))
d2281 6
a2286 6
	case TYPE_CODE_INT:
	case TYPE_CODE_BOOL:
	case TYPE_CODE_CHAR:
	case TYPE_CODE_RANGE:
	case TYPE_CODE_ENUM:
	  if (TYPE_LENGTH (arg_type) < TYPE_LENGTH (builtin_type_long))
d2288 2
a2289 2
	      arg_type = builtin_type_long;
	      arg = value_cast (arg_type, arg);
d2291 24
a2314 3
	  break;
	default:
	  break;
a2315 4
      m_arg->len = TYPE_LENGTH (arg_type);
      m_arg->offset = accumulate_size;
      accumulate_size = (accumulate_size + m_arg->len + 3) & ~3;
      m_arg->contents = VALUE_CONTENTS (arg);
d2318 24
a2341 8
  /* Make room for the arguments on the stack.  */
  accumulate_size += DEPRECATED_CALL_DUMMY_STACK_ADJUST;
  sp = ((sp - accumulate_size) & ~7) + DEPRECATED_CALL_DUMMY_STACK_ADJUST;

  /* `Push' arguments on the stack.  */
  for (i = 0, oregnum = 0, m_arg = sparc_args; 
       i < nargs;
       i++, m_arg++)
d2343 6
a2348 5
      write_memory (sp + m_arg->offset, m_arg->contents, m_arg->len);
      for (j = 0; 
	   j < m_arg->len && oregnum < 6; 
	   j += SPARC_INTREG_SIZE, oregnum++)
	deprecated_write_register_gen (O0_REGNUM + oregnum, m_arg->contents + j);
d2352 3
a2355 5

#define SPARC_F0_REGNUM		FP0_REGNUM	/* %f0 */
#define SPARC_F1_REGNUM		(FP0_REGNUM + 1)/* %f1 */
#define SPARC_O0_REGNUM		O0_REGNUM	/* %o0 */
#define SPARC_O1_REGNUM		O1_REGNUM	/* %o1 */
@


1.101
log
@2003-05-16  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_BYTES): Rename REGISTER_BYTES.
	* gdbarch.h, gdbarch.c: Re-generate.
	* arm-linux-tdep.c (arm_linux_extract_return_value): Delete reference.
	* TODO (REGISTER_BYTES): Delete reference.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init_32082): Update.
	(ns32k_gdbarch_init_32382): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* i386-linux-tdep.c (i386_linux_init_abi): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* sparc-tdep.c (sparc_pop_frame): Update.
	* rs6000-tdep.c (rs6000_pop_frame): Update.
	* remote.c (init_remote_state): Update.
	(remote_prepare_to_store): Update.
	* remote-vx.c (vx_prepare_to_store): Update.
	* remote-sds.c (sds_fetch_registers): Update.
	(sds_prepare_to_store): Update.
	* remote-array.c: Update.
	* regcache.c (init_legacy_regcache_descr): Update.
	(init_regcache_descr): Update.
	* mips-tdep.c (mips_eabi_extract_return_value): Update.
	(mips_o64_extract_return_value): Update.
	* irix5-nat.c (fetch_core_registers): Update.
	* irix4-nat.c (fetch_core_registers): Update.
	* i386-tdep.h: Update.
	* hppa-tdep.c (pa_do_registers_info): Update.
	(pa_do_strcat_registers_info): Update.
	* cris-tdep.c (cris_register_bytes_ok): Update.
	* config/nm-gnu.h (CHILD_PREPARE_TO_STORE): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/sparc/nm-sun4sol2.h (CHILD_PREPARE_TO_STORE): Update.
	* config/sparc/nm-sun4os4.h (CHILD_PREPARE_TO_STORE): Update.
	* config/sparc/nm-nbsd.h (CHILD_PREPARE_TO_STORE): Update.
	* config/sparc/tm-sp64.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/s390/tm-s390.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/pa/tm-hppa64.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/mips/tm-mips.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/mips/tm-irix6.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/mips/tm-irix5.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/m68k/tm-sun3.h (DEPRECATED_REGISTER_BYTES): Update.
	(REGISTER_BYTES_OK): Update.
	* config/m68k/nm-sun3.h (CHILD_PREPARE_TO_STORE): Update.
	* config/ia64/tm-ia64.h (DEPRECATED_REGISTER_BYTES): Update.

Index: doc/ChangeLog
2003-05-16  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	REGISTER_BYTES with DEPRECATED_REGISTER_BYTES.  Fix typo,
	DEPRECATED_REGISTER_SIZE instead of REGISTER_BYTE.

Index: mi/ChangeLog
2003-05-16  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c (mi_setup_architecture_data):
@
text
@a468 7
CORE_ADDR
sparc_extract_struct_value_address (char *regbuf)
{
  return extract_address (regbuf + REGISTER_BYTE (O0_REGNUM),
			  REGISTER_RAW_SIZE (O0_REGNUM));
}

d2278 49
d2328 1
a2328 3
/* Extract from an array REGBUF containing the (raw) register state
   a function return value of type TYPE, and copy that, in virtual format,
   into VALBUF.  */
d2331 2
a2332 1
sparc32_extract_return_value (struct type *type, char *regbuf, char *valbuf)
d2334 2
a2335 2
  int typelen = TYPE_LENGTH (type);
  int regsize = REGISTER_RAW_SIZE (O0_REGNUM);
d2338 33
a2370 1
    memcpy (valbuf, &regbuf[REGISTER_BYTE (FP0_REGNUM)], typelen);
d2372 2
a2373 6
    memcpy (valbuf,
	    &regbuf[O0_REGNUM * regsize +
		    (typelen >= regsize
		     || TARGET_BYTE_ORDER == BFD_ENDIAN_LITTLE ? 0
		     : regsize - typelen)],
	    typelen);
d2376 11
d2388 1
a2388 4
/* Write into appropriate registers a function return value
   of type TYPE, given in virtual format.  On SPARCs with FPUs,
   float values are returned in %f0 (and %f1).  In all other cases,
   values are returned in register %o0.  */
d3244 2
a3245 1
  set_gdbarch_deprecated_extract_struct_value_address (gdbarch, sparc_extract_struct_value_address);
d3460 2
a3461 1
      set_gdbarch_deprecated_extract_return_value (gdbarch, sparc32_extract_return_value);
a3464 1
      set_gdbarch_deprecated_store_return_value (gdbarch, sparc_store_return_value);
d3496 2
a3497 1
      set_gdbarch_deprecated_extract_return_value (gdbarch, sparc32_extract_return_value);
a3500 1
      set_gdbarch_deprecated_store_return_value (gdbarch, sparc_store_return_value);
d3508 2
a3509 1
      set_gdbarch_deprecated_extract_return_value (gdbarch, sparc32_extract_return_value);
a3512 1
      set_gdbarch_deprecated_store_return_value (gdbarch, sparc_store_return_value);
@


1.100
log
@2003-05-15  Andrew Cagney  <cagney@@redhat.com>

	* arch-utils.h (legacy_breakpoint_from_pc): Delete declaration.
	* target.h (memory_breakpoint_from_pc): Delete declaration.
	* mem-break.c (memory_breakpoint_from_pc): Delete function.
	* arch-utils.c (legacy_breakpoint_from_pc): Delete function.
	* monitor.c (monitor_insert_breakpoint): Use
	gdbarch_breakpoint_from_pc instead of memory_breakpoint_from_pc.
	* gdbarch.sh (BREAKPOINT_FROM_PC): Do not provide a default.
	* gdbarch.h, gdbarch.c: Re-generate.
	* sparc-tdep.c (sparc_breakpoint_from_pc): New function.
	(sparc_gdbarch_init): Set breakpoint_from_pc to
	sparc_breakpoint_from_pc.
	* config/sparc/tm-sparc.h (BREAKPOINT): Delete macro.
	(BREAKPOINT_FROM_PC): Define.
	(sparc_breakpoint_from_pc): Declare.
	* hppa-tdep.c (hppa_breakpoint_from_pc): New function.
	* config/pa/tm-hppa.h (hppa_breakpoint_from_pc): Declare.
	(BREAKPOINT_FROM_PC): Define.
	(BREAKPOINT): Delete macro.
	* target.h: Update comment.
	* s390-tdep.c (s390_gdbarch_init): Update comments.
	* remote.c: Update comments.
	* remote-mips.c: Update comments.
	* proc-api.c (write_with_trace): Do not check for a breakpoint.
	* mem-break.c: Update comment.
	* ia64-tdep.c (IA64_BREAKPOINT): Rename BREAKPOINT.
	(ia64_memory_insert_breakpoint): Update.
	* config/sparc/tm-sparc.h: Update comment.
	* config/pa/tm-hppa64.h: Update comment.
	* rs6000-tdep.c (BIG_BREAKPOINT, LITTLE_BREAKPOINT): Delete macro.
	(rs6000_breakpoint_from_pc): Update.
	* mips-tdep.c (BIG_BREAKPOINT, LITTLE_BREAKPOINT): Delete macro.
	(PMON_BIG_BREAKPOINT, PMON_LITTLE_BREAKPOINT): Delete macro.
	(IDT_LITTLE_BREAKPOINT, IDT_LITTLE_BREAKPOINT): Delete macro.
	(MIPS16_LITTLE_BREAKPOINT, MIPS16_BIG_BREAKPOINT): Delete macro.
	(mips_breakpoint_from_pc): Update.
	(mips_dump_tdep): Update.
@
text
@d1272 1
a1272 1
  raw_buffer = alloca (REGISTER_BYTES);
d3384 1
a3384 1
      set_gdbarch_register_bytes (gdbarch, 32*4 + 32*4 + 8*4);
d3420 1
a3420 1
      set_gdbarch_register_bytes (gdbarch, 32*4 + 32*4 + 8*4);
d3432 1
a3432 1
      set_gdbarch_register_bytes (gdbarch, 32*4 + 32*4 + 8*4);
d3456 1
a3456 1
      set_gdbarch_register_bytes (gdbarch, 32*8 + 32*8 + 45*8);
d3468 1
a3468 1
      set_gdbarch_register_bytes (gdbarch, 32*8 + 32*8 + 45*8);
@


1.99
log
@2003-05-13  Andrew Cagney  <cagney@@redhat.com>

	* defs.h (store_address): Delete declaration.
	findvar.c (store_address): Delete function.
	* arm-tdep.c (arm_push_dummy_call): Replace store_address with
	store_unsigned_integer.
	* xstormy16-tdep.c (xstormy16_address_to_pointer): Ditto.
	* v850-tdep.c (v850_push_arguments): Ditto.
	* sparc-tdep.c (sparc_get_saved_register): Ditto.
	* sh-tdep.c (sh64_get_saved_register): Ditto.
	* rs6000-tdep.c (rs6000_push_arguments): Ditto.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_arguments): Ditto.
	* mips-tdep.c (mips_eabi_push_arguments): Ditto.
	(mips_get_saved_register): Ditto.
	* ia64-tdep.c (ia64_get_saved_register): Ditto.
	(find_func_descr, ia64_push_arguments): Ditto.
	* i386-tdep.c (i386_push_arguments): Ditto.
	* hpux-thread.c (hpux_thread_fetch_registers): Ditto.
	* frv-tdep.c (frv_push_arguments): Ditto.
	* frame.c (legacy_saved_regs_prev_register): Ditto.
	(deprecated_generic_get_saved_register): Ditto.
	* findvar.c (unsigned_address_to_pointer): Ditto.
	* dwarf2read.c (dwarf2_const_value): Ditto.
	* arm-linux-tdep.c (arm_linux_push_arguments): Ditto.
	* alpha-tdep.c (alpha_push_arguments): Ditto.
@
text
@d154 8
d3164 1
a3164 1
  set_gdbarch_breakpoint_from_pc (gdbarch, memory_breakpoint_from_pc);
@


1.98
log
@2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh: Delete references to MAX_REGISTER_RAW_SIZE.
	* gdbarch.h: Re-generate.
	* defs.h (MAX_REGISTER_RAW_SIZE): Delete macro.
	(legacy_max_register_raw_size): Delete declaration.
	* regcache.c (legacy_max_register_raw_size): Delete function.
	* valops.c: Replace MAX_REGISTER_RAW_SIZE with MAX_REGISTER_SIZE.
	* target.c, stack.c, sparc-tdep.c, sh-tdep.c: Update.
	* rs6000-tdep.c, rs6000-nat.c, remote.c, remote-sim.c: Update.
	* remote-rdp.c, remote-array.c, regcache.c: Update.
	* ppc-linux-nat.c, monitor.c, mn10300-tdep.c: Update.
	* mips-tdep.c, mips-linux-tdep.c, m68klinux-nat.c: Update.
	* infptrace.c, ia64-tdep.c, i386-tdep.c, frame.c: Update.
	* findvar.c, dwarf2cfi.c: Update.

Index: tui/ChangeLog
2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* tuiRegs.c: Use MAX_REGISTER_SIZE instead of
	MAX_REGISTER_RAW_SIZE.

Index: mi/ChangeLog
2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c (register_changed_p): Use MAX_REGISTER_SIZE instead of
	MAX_REGISTER_RAW_SIZE.
@
text
@d862 1
a862 1
	  store_address (raw_buffer, REGISTER_RAW_SIZE (regnum), get_frame_pc (frame));
d970 1
a970 1
	      store_address (raw_buffer, REGISTER_RAW_SIZE (regnum), addr);
@


1.98.4.1
log
@Snap const char * mess.
@
text
@d862 1
a862 1
	  store_unsigned_integer (raw_buffer, REGISTER_RAW_SIZE (regnum), get_frame_pc (frame));
d970 1
a970 1
	      store_unsigned_integer (raw_buffer, REGISTER_RAW_SIZE (regnum), addr);
@


1.97
log
@2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh: Add comments on MAX_REGISTER_SIZE.
	* gdbarch.h: Re-generate.
	* defs.h (MAX_REGISTER_VIRTUAL_SIZE): Delete macro.
	(legacy_max_register_virtual_size): Delete declaration.
	* infcmd.c (default_print_registers_info): Use MAX_REGISTER_SIZE.
	* d10v-tdep.c (d10v_print_registers_info): Ditto.
	* tracepoint.c (memrange_sortmerge): Ditto.
	* sparc-tdep.c (sparc_print_registers): Ditto.
	* regcache.c (legacy_max_register_virtual_size): Delete function.
@
text
@d320 1
a320 3
      char *buf;

      buf = alloca (MAX_REGISTER_RAW_SIZE);
d369 1
a369 3
	      char *buf;
	      
	      buf = alloca (MAX_REGISTER_RAW_SIZE);
d473 1
a473 1
  char *buf;
a475 1
  buf = alloca (MAX_REGISTER_RAW_SIZE);
d2309 1
a2309 3
  char *buffer;

  buffer = alloca (MAX_REGISTER_RAW_SIZE);
@


1.96
log
@2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_SIZE): Rename REGISTER_SIZE.
	(DEPRECATED_SIZEOF_CALL_DUMMY_WORDS): Rename
	SIZEOF_CALL_DUMMY_WORDS.
	(DEPRECATED_CALL_DUMMY_WORDS): Rename CALL_DUMMY_WORDS.
	(DEPRECATED_FIX_CALL_DUMMY): Rename FIX_CALL_DUMMY.
	(DEPRECATED_CALL_DUMMY_BREAKPOINT_OFFSET): Rename
	CALL_DUMMY_BREAKPOINT_OFFSET.
	(DEPRECATED_CALL_DUMMY_START_OFFSET): Rename
	CALL_DUMMY_START_OFFSET.
	(DEPRECATED_CALL_DUMMY_LENGTH): Rename CALL_DUMMY_LENGTH.
	* gdbarch.h, gdbarch.c: Re-generate.
	* alpha-tdep.c, alphafbsd-tdep.c, arm-linux-tdep.c: Update.
	* arm-tdep.c, avr-tdep.c, breakpoint.c, cris-tdep.c: Update.
	* dummy-frame.c, dummy-frame.h, frv-tdep.c, gdbarch.c: Update.
	* gdbarch.h, gdbarch.sh, h8300-tdep.c, hppa-tdep.c: Update.
	* i386-tdep.c, ia64-tdep.c, infcall.c, inferior.h: Update.
	* m68hc11-tdep.c, m68k-tdep.c, mcore-tdep.c: Update.
	* mips-tdep.c, mn10300-tdep.c, ns32k-tdep.c: Update.
	* rs6000-tdep.c, s390-tdep.c, sh-tdep.c, sol-thread.c: Update.
	* sparc-tdep.c, target.c, v850-tdep.c, valops.c: Update.
	* vax-tdep.c, x86-64-tdep.c, xstormy16-tdep.c: Update.
	* config/ia64/tm-ia64.h, config/m68k/tm-vx68.h: Update.
	* config/mips/tm-mips.h, config/pa/nm-hppah.h: Update.
	* config/pa/tm-hppa.h, config/pa/tm-hppa64.h: Update.
	* config/s390/tm-s390.h, config/sparc/tm-sp64.h: Update.
	* config/sparc/tm-sparc.h: Update.

Index: doc/ChangeLog
2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Make
	CALL_DUMMY_WORDS, SIZEOF_CALL_DUMMY_WORDS, CALL_DUMMY_LENGTH,
	FIX_CALL_DUMMY, CALL_DUMMY_BREAKPOINT_OFFSET and
	CALL_DUMMY_BREAKPOINT_OFFSET deprecated.

Index: mi/ChangeLog
2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c (mi_cmd_data_write_register_values): Replace
	REGISTER_SIZE with DEPRECATED_REGISTER_SIZE.

Index: testsuite/ChangeLog
2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* gdb.base/watchpoint.exp: Rename CALL_DUMMY_BREAKPOINT_OFFSET to
	DEPRECATED_CALL_DUMMY_BREAKPOINT_OFFSET in comments.
@
text
@d2073 2
a2074 2
  char *raw_buffer = alloca (MAX_REGISTER_RAW_SIZE);
  char *virtual_buffer = alloca (MAX_REGISTER_VIRTUAL_SIZE);
@


1.95
log
@2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (PUSH_DUMMY_CODE): New architecture method, add
	comments noteing that it replaces the old FIX_CALL_DUMMY code.
	* gdbarch.h, gdbarch.c: Re-generate.
	* d10v-tdep.c (d10v_push_dummy_code): New function.
	(d10v_gdbarch_init): Set push_dummy_code.
	* infcall.c (legacy_push_dummy_code): New function.
	(generic_push_dummy_code): New function.
	(push_dummy_code): New function.
	(call_function_by_hand): Call push_dummy_code.  Pass bp_addr,
	instead of dummy_addr, to push_dummy_call.  Move call to
	generic_save_call_dummy_addr to outside of CALL_DUMMY_LOCATION
	switch.
	* sparc-tdep.c (sparc_gdbarch_init): Mention push_dummy_code.

2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Document
	push_dummy_code.  Add cross references.
@
text
@d2360 4
a2363 3
   (twisted) convention.  So leave a nop there for gcc (FIX_CALL_DUMMY
   can assume it is operating on a pristine CALL_DUMMY, not one that
   has already been customized for a different function).  */
d2396 1
a2396 1
      set_gdbarch_call_dummy_breakpoint_offset (current_gdbarch, 0x30);
d2399 1
a2399 1
    set_gdbarch_call_dummy_breakpoint_offset (current_gdbarch, 0x2c);
d3058 1
a3058 1
  return (CALL_DUMMY_START_OFFSET) + CALL_DUMMY_BREAKPOINT_OFFSET;
d3167 1
a3167 1
  set_gdbarch_fix_call_dummy (gdbarch, sparc_gdbarch_fix_call_dummy);
d3225 2
a3226 2
      set_gdbarch_call_dummy_breakpoint_offset (gdbarch, 0x30);
      set_gdbarch_call_dummy_length (gdbarch, 0x38);
d3280 1
a3280 1
      set_gdbarch_call_dummy_words (gdbarch, call_dummy_32);
d3283 1
a3283 1
      set_gdbarch_call_dummy_words (gdbarch, call_dummy_nil);
d3297 1
a3297 1
      set_gdbarch_register_size (gdbarch, 4);
d3302 1
a3302 1
      set_gdbarch_sizeof_call_dummy_words (gdbarch, sizeof (call_dummy_32));
d3304 1
a3304 1
      set_gdbarch_sizeof_call_dummy_words (gdbarch, 0);
d3327 2
a3328 2
      set_gdbarch_call_dummy_breakpoint_offset (gdbarch, 8 * 4);
      set_gdbarch_call_dummy_length (gdbarch, 192);
d3330 2
a3331 2
      set_gdbarch_call_dummy_start_offset (gdbarch, 148);
      set_gdbarch_call_dummy_words (gdbarch, call_dummy_64);
d3334 1
a3334 1
      set_gdbarch_call_dummy_words (gdbarch, call_dummy_nil);
d3351 1
a3351 1
      set_gdbarch_register_size (gdbarch, 8);
d3356 1
a3356 1
      set_gdbarch_sizeof_call_dummy_words (gdbarch, sizeof (call_dummy_64));
d3358 1
a3358 1
      set_gdbarch_sizeof_call_dummy_words (gdbarch, 0);
@


1.94
log
@2003-04-30  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (deprecated_tm_print_insn_info): Rename
	"tm_print_insn_info".
	(TARGET_PRINT_INSN_INFO): Delete macro.
	(dis_asm_read_memory): Delete function declaration.
	(dis_asm_memory_error, dis_asm_print_address): Ditto.
	(tm_print_insn_info): Delete variable definition.
	(_initialize_gdbarch): Do not initialize "tm_print_insn_info".
	* gdbarch.h, gdbarch.c: Re-generate.
	* d10v-tdep.c (display_trace): Replace "tm_print_insn_info" with
	"deprecated_tm_print_insn_info".
	* mcore-tdep.c (mcore_dump_insn): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* sparc-tdep.c (_initialize_sparc_tdep): Ditto.
	* v850-tdep.c (v850_scan_prologue, v850_gdbarch_init): Ditto.
	* ia64-tdep.c (_initialize_ia64_tdep): Ditto.
	* printcmd.c (print_insn): Use "deprecated_tm_print_insn_info"
	instead of TARGET_PRINT_INSN_INFO, add comment.
	* s390-tdep.c (s390_get_frame_info): Instead of
	"dis_asm_read_memory", use "deprecated_tm_print_insn_info".
	(s390_check_function_end, s390_is_sigreturn): Ditto.
	* corefile.c (dis_asm_read_memory): Move to "disasm.c".
	(dis_asm_memory_error, dis_asm_print_address): Ditto.
	* disasm.c: Include "gdbcore.h".
	(_initialize_disasm): New function, initialize
	"deprecated_tm_print_insn_info".
	(deprecated_tm_print_insn_info): New variable.
	(dis_asm_read_memory): Moved from "corefile.c", made static.
	(dis_asm_print_address, dis_asm_memory_error): Ditto.
	* Makefile.in (disasm.o): Update dependencies.

2003-04-28  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	read_fp, TARGET_READ_FP and FP_REGNUM, with deprecated_read_fp,
	DEPRECATED_TARGET_READ_FP and DEPRECATED_REGNUM.
@
text
@d3227 9
a3235 1
      /* NOTE: cagney/2002-04-26: Based from info posted by Peter
@


1.93
log
@2003-04-30  Andrew Cagney  <cagney@@redhat.com>

	* sparc-tdep.c (SPARC_HAS_FPU): When multi-arch, define as 1.
@
text
@d2467 1
a2467 1
  tm_print_insn_info.mach = TM_PRINT_INSN_MACH;		/* Selects sparc/sparclite */
@


1.92
log
@2003-04-28  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_TARGET_READ_FP): Replace TARGET_READ_FP.
	(DEPRECATED_FP_REGNUM): Replace FP_REGNUM.
	* gdbarch.h, gdbarch.c: Re-generate.
	* infcall.c (call_function_by_hand): Use DEPRECATED_FP_REGNUM,
	DEPRECATED_TARGET_READ_FP, or "sp" to create the dummy frame ID.
	* inferior.h (deprecated_read_fp): Rename read_fp.
	(generic_target_read_fp): Delete declaration.
	* regcache.c (generic_target_read_fp): Delete function.
	(deprecated_read_fp): Replace read_fp, use
	DEPRECATED_TARGET_READ_FP or DEPRECATED_FP_REGNUM.
	* d10v-tdep.c (d10v_read_fp): Delete function.
	(d10v_gdbarch_init): Do not set deprecated_read_fp.

	* sparc-tdep.c (sparc_gdbarch_init): Do not set
	deprecated_target_read_fp to generic_target_read_fp.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.

	* xstormy16-tdep.c (xstormy16_gdbarch_init): Set
	deprecated_fp_regnum.
	* x86-64-tdep.c (x86_64_init_abi): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.

	* x86-64-tdep.c (x86_64_init_abi): Set deprecated_target_read_fp.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.

	* vax-tdep.c (vax_frame_init_saved_regs): Replace FP_REGNUM with
	DEPRECATED_FP_REGNUM.
	(vax_push_dummy_frame, vax_pop_frame): Ditto.
	* std-regs.c (value_of_builtin_frame_fp_reg): Ditto.
	* sparc-tdep.c (sparc_init_extra_frame_info): Ditto.
	(sparc_push_dummy_frame, sparc64_read_fp): Ditto.
	(sparc32_register_virtual_type): Ditto.
	* sh-tdep.c (sh64_frame_chain): Ditto.
	(sh64_get_saved_register, sh64_pop_frame): Ditto.
	(sh_nofp_frame_init_saved_regs): Ditto.
	(sh64_nofp_frame_init_saved_regs): Ditto.
	(sh_fp_frame_init_saved_regs): Ditto.
	* remote-mips.c (mips_wait, mips_fetch_registers): Ditto.
	* remote-e7000.c (fetch_regs_from_dump): Ditto.
	* procfs.c (procfs_fetch_registers): Ditto.
	(procfs_store_registers): Ditto.
	* ns32knbsd-nat.c (fetch_inferior_registers): Ditto.
	(store_inferior_registers, fetch_core_registers): Ditto.
	(fetch_kcore_registers, clear_regs): Ditto.
	* ns32k-tdep.c (ns32k_frame_init_saved_regs): Ditto.
	(ns32k_push_dummy_frame, ns32k_pop_frame): Ditto.
	* nlm/i386.h (DEPRECATED_FP_REGNUM): Ditto.
	* nlm/i386.c (do_status): Ditto.
	* mipsv4-nat.c (supply_gregset): Ditto.
	* mips-tdep.c: Ditto for comments.
	* mips-nat.c (fetch_inferior_registers): Ditto.
	(store_inferior_registers, fetch_core_registers): Ditto.
	* m68k-tdep.c (m68k_push_dummy_frame): Ditto.
	(m68k_pop_frame, m68k_frame_init_saved_regs): Ditto.
	* i386-tdep.c (i386_frame_init_saved_regs): Ditto.
	(i386_do_pop_frame, i386_register_type): Ditto.
	* hppa-tdep.c (hppa_frame_chain): Ditto.
	(hppa_push_dummy_frame, find_dummy_frame_regs): Ditto.
	(hppa_pop_frame, hppa_read_fp): Ditto.
	(skip_prologue_hard_way, hppa_frame_find_saved_regs): Ditto.
	* cris-tdep.c (cris_examine, cris_pop_frame): Ditto.
	* config/vax/nm-vax.h (REGISTER_U_ADDR): Ditto.
	* config/sparc/tm-sparc.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/sparc/tm-sp64.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/s390/tm-s390.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/pa/tm-hppa64.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/ia64/tm-ia64.h (DEPRECATED_FP_REGNUM): Ditto.
	* blockframe.c: Ditto for comments.
	* arch-utils.h: Ditto for comments.
	* arch-utils.c (legacy_virtual_frame_pointer): Ditto.
	* alphanbsd-tdep.c (fetch_core_registers): Ditto.
	* alphabsd-nat.c (fetch_inferior_registers): Ditto.
	* alpha-tdep.h: Ditto for comments.
	* alpha-tdep.c (alpha_cannot_fetch_register): Ditto.
	(alpha_cannot_store_register): Ditto.
	(alpha_push_dummy_frame): Ditto.
	* alpha-nat.c (supply_gregset): Ditto.

	* config/sparc/tm-sp64.h (DEPRECATED_TARGET_READ_FP): Update.
	* config/pa/tm-hppa64.h (DEPRECATED_TARGET_READ_FP): Update.
	* config/sparc/tm-sparc.h: Update comment.

	* hppa-tdep.c (hppa_init_extra_frame_info): Use
	deprecated_read_fp instead of TARGET_READ_FP.
	(hppa_init_extra_frame_info, hppa_frame_chain): Ditto.
	(hppa_push_dummy_frame, hppa_read_fp): Ditto.
	* sparc-tdep.c (sparc_init_extra_frame_info): Use
	deprecated_read_fp instead of read_fp.
	* s390-tdep.c (s390_push_arguments): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* frame.h: Ditto in comments.
	* frame.c (legacy_get_prev_frame): Ditto.
	* dummy-frame.c (dummy_frame_this_id): Ditto.
	* arm-tdep.c (arm_init_extra_frame_info): Ditto.

2003-04-28  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	read_fp, TARGET_READ_FP and FP_REGNUM, with deprecated_read_fp,
	DEPRECATED_TARGET_READ_FP and DEPRECATED_REGNUM.
@
text
@d54 5
a58 2
/* Does the target have Floating Point registers?  */
#define SPARC_HAS_FPU     (gdbarch_tdep (current_gdbarch)->has_fpu)
@


1.91
log
@2003-04-28  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (deprecated_tm_print_insn): Rename tm_print_insn.
	* gdbarch.h, gdbarch.c: Re-generate.
	* xstormy16-tdep.c (_initialize_xstormy16_tdep): Update.
	* vax-tdep.c (_initialize_vax_tdep): Update.
	* v850-tdep.c (_initialize_v850_tdep): Update.
	* sparc-tdep.c (_initialize_sparc_tdep): Update.
	* s390-tdep.c (_initialize_s390_tdep): Update.
	* ns32k-tdep.c (_initialize_ns32k_tdep): Update.
	* mn10300-tdep.c (_initialize_mn10300_tdep): Update.
	* mips-tdep.c (_initialize_mips_tdep): Update.
	* mcore-tdep.c (_initialize_mcore_tdep): Update.
	* m68k-tdep.c (_initialize_m68k_tdep): Update.
	* ia64-tdep.c (_initialize_ia64_tdep): Update.
	* hppa-tdep.c (_initialize_hppa_tdep): Update.
	* h8300-tdep.c (_initialize_h8300_tdep): Update.
	* frv-tdep.c (_initialize_frv_tdep): Update.
	* cris-tdep.c (cris_delayed_get_disassembler): Update.
	(_initialize_cris_tdep): Update.
	* arch-utils.c (legacy_print_insn): Update.
	* alpha-tdep.c (_initialize_alpha_tdep): Update.

2003-04-28  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	"tm_print_insn" to "deprecated_tm_print_insn".
@
text
@d313 2
a314 2
  /* If fi->next is NULL, then we already set ->frame by passing read_fp()
     to create_new_frame.  */
d338 1
a338 1
	  frame_read_unsigned_register (fi, FP_REGNUM, &tmp);
d1068 1
a1068 1
	  CORE_ADDR oldfp = read_register (FP_REGNUM);
d1070 1
a1070 1
	    write_register (FP_REGNUM, old_sp - 2047);
d1072 1
a1072 1
	    write_register (FP_REGNUM, old_sp);
d1077 1
a1077 1
	  write_register (FP_REGNUM, old_sp);
d1087 1
a1087 1
      write_register (G0_REGNUM + 1, read_register (FP_REGNUM));
d1099 1
a1099 1
      write_register (FP_REGNUM, old_sp);
d2484 1
a2484 1
  CORE_ADDR fp = read_register (FP_REGNUM);
d2938 1
a2938 1
      regno == FP_REGNUM ||
d2952 1
a2952 1
      regno == FP_REGNUM ||
d3165 1
a3165 1
  set_gdbarch_fp_regnum (gdbarch, SPARC_FP_REGNUM);
a3280 1
      set_gdbarch_read_fp (gdbarch, generic_target_read_fp);
d3333 1
a3333 1
      set_gdbarch_read_fp (gdbarch, sparc64_read_fp);
@


1.90
log
@2003-04-21  Andrew Cagney  <cagney@@redhat.com>

	* infcall.c: New file.
	* infcall.h: New file.
	* valarith.c: Include "infcall.h".
	* scm-lang.c, objc-lang.cm, hppa-tdep.c, gcore.c: Ditto.
	* eval.c, ada-valprint.c, ada-lang.c: Ditto.
	* Makefile.in (valarith.o, scm-lang.o): Update dependencies.
	(objc-lang.o, hppa-tdep.o, gcore.o): Update dependencies.
	(eval.o, ada-valprint.o, ada-lang.o): Update dependencies.
	(SFILES): Add "infcall.c"
	(COMMON_OBS): Add "infcall.o".
	(infcall.o): Specify dependencies.
	* value.h (call_function_by_hand): Delete declaration.
	* inferior.h (run_stack_dummy): Delete declaration.
	* infcmd.c (breakpoint_auto_delete_contents): Move to "infcall.c".
	(run_stack_dummy): Move to "infcall.c", merged into
	call_function_by_hand.
	* valops.c (call_function_by_hand): Moved to "infcall.c".
	(find_function_addr, value_arg_coerce): Ditto.
	(unwindonsignal_p, coerce_float_to_double): Ditto.
	(_initialize_valops): Move "set/show coerce-float-to-double", and
	"set/show unwindonsignal" commands to "infcall.c".
	* v850-tdep.c, target.h: Update comments.
	* sparc-tdep.c (sparc_fix_call_dummy): Update comments.
	* sh-tdep.c (sh_init_extra_frame_info): Update comments.
	(sh64_init_extra_frame_info): Update comments.
	* mn10300-tdep.c: Update comments.
	* mcore-tdep.c (mcore_init_extra_frame_info): Update comments.
	* config/sparc/tm-sparc.h: Update comments.
	* breakpoint.h: Update comments.
	* avr-tdep.c (avr_init_extra_frame_info): Update comments.
	* arm-tdep.c: Update comment.
@
text
@d2463 1
a2463 1
  tm_print_insn = gdb_print_insn_sparc;
@


1.89
log
@2003-04-16  Andrew Cagney  <cagney@@redhat.com>

	* NEWS: Mention that sparclet-*-* and sparclite-*-* have been made
	obsolete.
	* sparc-tdep.c: Obsolete SPARCLET and SPARCLITE code.
	* sparcl-stub.c: Obsolete file.
	* config/sparc/tm-sparclet.h: Obsolete file.
	* sparclet-stub.c: Obsolete file.
	* sparclet-rom.c: Obsolete file.
	* sparcl-tdep.c: Obsolete file.
	* config/sparc/tm-sparclite.h: Obsolete file.
	* config/sparc/sparclite.mt: Obsolete file.
	* config/sparc/sparclet.mt: Obsolete file.
	* configure.tgt: Make sparclet-*-*, sparclite-*-*, and
	sparc86x-*-* obsolete.
@
text
@d2382 5
a2386 4
     Tweeking current_gdbarch is not an optimal solution, but the call to
     sparc_fix_call_dummy is immediately followed by a call to run_stack_dummy,
     which is the only function where dummy_breakpoint_offset is actually
     used, if it is non-zero.  */
@


1.89.2.1
log
@Merge from mainline.
@
text
@d54 2
a55 5
#if 0
// OBSOLETE /* Does the target have Floating Point registers?  */
// OBSOLETE #define SPARC_HAS_FPU     (gdbarch_tdep (current_gdbarch)->has_fpu)
#endif
#define SPARC_HAS_FPU 1
d313 2
a314 2
  /* If fi->next is NULL, then we already set ->frame by passing
     deprecated_read_fp() to create_new_frame.  */
d338 1
a338 1
	  frame_read_unsigned_register (fi, DEPRECATED_FP_REGNUM, &tmp);
d1068 1
a1068 1
	  CORE_ADDR oldfp = read_register (DEPRECATED_FP_REGNUM);
d1070 1
a1070 1
	    write_register (DEPRECATED_FP_REGNUM, old_sp - 2047);
d1072 1
a1072 1
	    write_register (DEPRECATED_FP_REGNUM, old_sp);
d1077 1
a1077 1
	  write_register (DEPRECATED_FP_REGNUM, old_sp);
d1087 1
a1087 1
      write_register (G0_REGNUM + 1, read_register (DEPRECATED_FP_REGNUM));
d1099 1
a1099 1
      write_register (DEPRECATED_FP_REGNUM, old_sp);
d2382 4
a2385 5

     Tweeking current_gdbarch is not an optimal solution, but the call
     to sparc_fix_call_dummy is immediately followed by a call to
     call_function_by_hand, which is the only function where
     dummy_breakpoint_offset is actually used, if it is non-zero.  */
d2462 2
a2463 2
  deprecated_tm_print_insn = gdb_print_insn_sparc;
  deprecated_tm_print_insn_info.mach = TM_PRINT_INSN_MACH;		/* Selects sparc/sparclite */
d2483 1
a2483 1
  CORE_ADDR fp = read_register (DEPRECATED_FP_REGNUM);
d2937 1
a2937 1
      regno == DEPRECATED_FP_REGNUM ||
d2951 1
a2951 1
      regno == DEPRECATED_FP_REGNUM ||
d3164 1
a3164 1
  set_gdbarch_deprecated_fp_regnum (gdbarch, SPARC_FP_REGNUM);
d3223 1
a3223 9
      /* NOTE: cagney/2003-05-01: Using the just added push_dummy_code
	 architecture method, it is now possible to implement a
	 generic dummy frames based inferior function call that stores
	 the breakpoint (and struct info) on the stack.  Further, by
	 treating a SIGSEG at a breakpoint as equivalent to a SIGTRAP
	 it is even possible to make this work when the stack is
	 no-execute.

	 NOTE: cagney/2002-04-26: Based from info posted by Peter
d3280 1
d3333 1
a3333 1
      set_gdbarch_deprecated_target_read_fp (gdbarch, sparc64_read_fp);
@


1.89.2.2
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@a153 8
const unsigned char *
sparc_breakpoint_from_pc (CORE_ADDR *pc, int *len)
{
  static const char breakpoint[] = {0x91, 0xd0, 0x20, 0x01};
  (*len) = sizeof (breakpoint);
  return breakpoint;
}

d320 3
a322 1
      char buf[MAX_REGISTER_SIZE];
d371 3
a373 1
	      char buf[MAX_REGISTER_SIZE];
d477 1
a477 1
  char buf[MAX_REGISTER_SIZE];
d480 1
d867 1
a867 1
	  store_unsigned_integer (raw_buffer, REGISTER_RAW_SIZE (regnum), get_frame_pc (frame));
d975 1
a975 1
	      store_unsigned_integer (raw_buffer, REGISTER_RAW_SIZE (regnum), addr);
d1269 1
a1269 1
  raw_buffer = alloca (DEPRECATED_REGISTER_BYTES);
d2073 2
a2074 2
  char raw_buffer[MAX_REGISTER_SIZE];
  char virtual_buffer[MAX_REGISTER_SIZE];
d2314 3
a2316 1
  char buffer[MAX_REGISTER_SIZE];
d2360 3
a2362 4
   (twisted) convention.  So leave a nop there for gcc
   (DEPRECATED_FIX_CALL_DUMMY can assume it is operating on a pristine
   CALL_DUMMY, not one that has already been customized for a
   different function).  */
d2395 1
a2395 1
      set_gdbarch_deprecated_call_dummy_breakpoint_offset (current_gdbarch, 0x30);
d2398 1
a2398 1
    set_gdbarch_deprecated_call_dummy_breakpoint_offset (current_gdbarch, 0x2c);
d3057 1
a3057 1
  return (DEPRECATED_CALL_DUMMY_START_OFFSET) + DEPRECATED_CALL_DUMMY_BREAKPOINT_OFFSET;
d3162 1
a3162 1
  set_gdbarch_breakpoint_from_pc (gdbarch, sparc_breakpoint_from_pc);
d3166 1
a3166 1
  set_gdbarch_deprecated_fix_call_dummy (gdbarch, sparc_gdbarch_fix_call_dummy);
d3224 2
a3225 2
      set_gdbarch_deprecated_call_dummy_breakpoint_offset (gdbarch, 0x30);
      set_gdbarch_deprecated_call_dummy_length (gdbarch, 0x38);
d3279 1
a3279 1
      set_gdbarch_deprecated_call_dummy_words (gdbarch, call_dummy_32);
d3282 1
a3282 1
      set_gdbarch_deprecated_call_dummy_words (gdbarch, call_dummy_nil);
d3296 1
a3296 1
      set_gdbarch_deprecated_register_size (gdbarch, 4);
d3301 1
a3301 1
      set_gdbarch_deprecated_sizeof_call_dummy_words (gdbarch, sizeof (call_dummy_32));
d3303 1
a3303 1
      set_gdbarch_deprecated_sizeof_call_dummy_words (gdbarch, 0);
d3326 2
a3327 2
      set_gdbarch_deprecated_call_dummy_breakpoint_offset (gdbarch, 8 * 4);
      set_gdbarch_deprecated_call_dummy_length (gdbarch, 192);
d3329 2
a3330 2
      set_gdbarch_deprecated_call_dummy_start_offset (gdbarch, 148);
      set_gdbarch_deprecated_call_dummy_words (gdbarch, call_dummy_64);
d3333 1
a3333 1
      set_gdbarch_deprecated_call_dummy_words (gdbarch, call_dummy_nil);
d3350 1
a3350 1
      set_gdbarch_deprecated_register_size (gdbarch, 8);
d3355 1
a3355 1
      set_gdbarch_deprecated_sizeof_call_dummy_words (gdbarch, sizeof (call_dummy_64));
d3357 1
a3357 1
      set_gdbarch_deprecated_sizeof_call_dummy_words (gdbarch, 0);
d3382 1
a3382 1
      set_gdbarch_deprecated_register_bytes (gdbarch, 32*4 + 32*4 + 8*4);
d3418 1
a3418 1
      set_gdbarch_deprecated_register_bytes (gdbarch, 32*4 + 32*4 + 8*4);
d3430 1
a3430 1
      set_gdbarch_deprecated_register_bytes (gdbarch, 32*4 + 32*4 + 8*4);
d3454 1
a3454 1
      set_gdbarch_deprecated_register_bytes (gdbarch, 32*8 + 32*8 + 45*8);
d3466 1
a3466 1
      set_gdbarch_deprecated_register_bytes (gdbarch, 32*8 + 32*8 + 45*8);
@


1.88
log
@2003-04-11  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_SAVED_PC_AFTER_CALL): Deprecate
	SAVED_PC_AFTER_CALL.
	* gdbarch.h, gdbarch.c: Regenerate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	(ia64_saved_pc_after_call): Update declaration.
	* i386ly-tdep.c (i386lynx_init_abi): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* ns32knbsd-nat.c (frame_num_args): Update.
	* ns32k-tdep.c (umax_frame_num_args): Update.
	* mips-tdep.c (mips_init_frame_pc_first): Update.
	* infrun.c (step_over_function): Update.
	* i386-linux-tdep.c (skip_hurd_resolver): Update.
	* i386-interix-tdep.c (i386_interix_back_one_frame): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_SAVED_PC_AFTER_CALL): Update.
	(DEPRECATED_INIT_FRAME_PC_FIRST): Update.
	* config/rs6000/tm-rs6000.h (DEPRECATED_INIT_FRAME_PC_FIRST): Update.
	* config/pa/tm-hppa.h (DEPRECATED_SAVED_PC_AFTER_CALL): Update.
	* arm-linux-tdep.c (skip_hurd_resolver): Update.
	* arch-utils.c (init_frame_pc_default): Update.
	* alpha-tdep.c (alpha_init_frame_pc_first): Update.
	* x86-64-tdep.h (x86_64_linux_saved_pc_after_call): Update
	declaration.
@
text
@d69 7
a75 3
#if defined(TARGET_SPARCLET) || defined(TARGET_SPARCLITE)
#define SPARC_HAS_FPU 0
#else
a76 1
#endif
d110 3
a112 1
    int has_fpu;
d142 7
a148 5
/* Some machines, such as Fujitsu SPARClite 86x, have a bi-endian mode
   where instructions are big-endian and data are little-endian.
   This flag is set when we detect that the target is of this type. */

int bi_endian = 0;
d2184 17
a2200 15
static void
sparclet_print_registers_info (struct gdbarch *gdbarch,
			       struct ui_file *file,
			       struct frame_info *frame,
			       int regnum, int print_all)
{
  sparc_print_registers (gdbarch, file, frame, regnum, print_all, NULL);
}

void
sparclet_do_registers_info (int regnum, int all)
{
  sparclet_print_registers_info (current_gdbarch, gdb_stdout,
				 deprecated_selected_frame, regnum, all);
}
d2336 9
a2344 7
extern void
sparclet_store_return_value (struct type *type, char *valbuf)
{
  /* Other values are returned in register %o0.  */
  deprecated_write_register_bytes (REGISTER_BYTE (O0_REGNUM), valbuf,
				   TYPE_LENGTH (type));
}
d2410 16
a2425 14
  /* If this is a bi-endian target, GDB has written the call dummy
     in little-endian order.  We must byte-swap it back to big-endian. */
  if (bi_endian)
    {
      for (i = 0; i < CALL_DUMMY_LENGTH; i += 4)
	{
	  char tmp = dummy[i];
	  dummy[i] = dummy[i + 3];
	  dummy[i + 3] = tmp;
	  tmp = dummy[i + 1];
	  dummy[i + 1] = dummy[i + 2];
	  dummy[i + 2] = tmp;
	}
    }
d2429 18
a2446 17
/* Set target byte order based on machine type. */

static int
sparc_target_architecture_hook (const bfd_arch_info_type *ap)
{
  int i, j;

  if (ap->mach == bfd_mach_sparc_sparclite_le)
    {
      target_byte_order = BFD_ENDIAN_LITTLE;
      bi_endian = 1;
    }
  else
    bi_endian = 0;
  return 1;
}

d2464 1
a2464 1
  target_architecture_hook = sparc_target_architecture_hook;
d2694 13
a2706 12
extern void 
sparclet_extract_return_value (struct type *type,
			       char *regbuf, 
			       char *valbuf)
{
  regbuf += REGISTER_RAW_SIZE (O0_REGNUM) * 8;
  if (TYPE_LENGTH (type) < REGISTER_RAW_SIZE (O0_REGNUM))
    regbuf += REGISTER_RAW_SIZE (O0_REGNUM) - TYPE_LENGTH (type);

  memcpy ((void *) valbuf, regbuf, TYPE_LENGTH (type));
}

d2787 26
a2812 8
static const char *
sparclite_register_name (int regno)
{
  static char *register_names[] = 
  { "g0", "g1", "g2", "g3", "g4", "g5", "g6", "g7",
    "o0", "o1", "o2", "o3", "o4", "o5", "sp", "o7",
    "l0", "l1", "l2", "l3", "l4", "l5", "l6", "l7",
    "i0", "i1", "i2", "i3", "i4", "i5", "fp", "i7",
d2814 37
a2850 51
    "f0",  "f1",  "f2",  "f3",  "f4",  "f5",  "f6",  "f7",
    "f8",  "f9",  "f10", "f11", "f12", "f13", "f14", "f15",
    "f16", "f17", "f18", "f19", "f20", "f21", "f22", "f23",
    "f24", "f25", "f26", "f27", "f28", "f29", "f30", "f31",

    "y", "psr", "wim", "tbr", "pc", "npc", "fpsr", "cpsr",
    "dia1", "dia2", "dda1", "dda2", "ddv1", "ddv2", "dcr", "dsr" 
  };

  if (regno < 0 ||
      regno >= (sizeof (register_names) / sizeof (register_names[0])))
    return NULL;
  else
    return register_names[regno];
}

static const char *
sparclet_register_name (int regno)
{
  static char *register_names[] = 
  { "g0", "g1", "g2", "g3", "g4", "g5", "g6", "g7",
    "o0", "o1", "o2", "o3", "o4", "o5", "sp", "o7",
    "l0", "l1", "l2", "l3", "l4", "l5", "l6", "l7",
    "i0", "i1", "i2", "i3", "i4", "i5", "fp", "i7",

    "", "", "", "", "", "", "", "", /* no floating point registers */
    "", "", "", "", "", "", "", "",
    "", "", "", "", "", "", "", "",
    "", "", "", "", "", "", "", "",

    "y", "psr", "wim", "tbr", "pc", "npc", "", "", /* no FPSR or CPSR */
    "ccsr", "ccpr", "cccrcr", "ccor", "ccobr", "ccibr", "ccir", "", 

    /*       ASR15                 ASR19 (don't display them) */    
    "asr1",  "", "asr17", "asr18", "", "asr20", "asr21", "asr22"
    /* None of the rest get displayed */
#if 0
    "awr0",  "awr1",  "awr2",  "awr3",  "awr4",  "awr5",  "awr6",  "awr7",  
    "awr8",  "awr9",  "awr10", "awr11", "awr12", "awr13", "awr14", "awr15", 
    "awr16", "awr17", "awr18", "awr19", "awr20", "awr21", "awr22", "awr23", 
    "awr24", "awr25", "awr26", "awr27", "awr28", "awr29", "awr30", "awr31", 
    "apsr"
#endif /* 0 */
  };

  if (regno < 0 ||
      regno >= (sizeof (register_names) / sizeof (register_names[0])))
    return NULL;
  else
    return register_names[regno];
}
d3206 4
a3209 2
    case bfd_mach_sparc_sparclet:
    case bfd_mach_sparc_sparclite:
d3212 3
a3214 1
    case bfd_mach_sparc_sparclite_le:
d3374 3
a3376 1
      tdep->has_fpu = 1;	/* (all but sparclet and sparclite) */
d3380 24
a3403 20
    case bfd_mach_sparc_sparclet:
      set_gdbarch_deprecated_extract_return_value (gdbarch, sparclet_extract_return_value);
      set_gdbarch_num_regs (gdbarch, 32 + 32 + 8 + 8 + 8);
      set_gdbarch_register_bytes (gdbarch, 32*4 + 32*4 + 8*4 + 8*4 + 8*4);
      set_gdbarch_register_name (gdbarch, sparclet_register_name);
      set_gdbarch_deprecated_store_return_value (gdbarch, sparclet_store_return_value);
      tdep->has_fpu = 0;	/* (all but sparclet and sparclite) */
      tdep->fp_register_bytes = 0;
      tdep->print_insn_mach = bfd_mach_sparc_sparclet;
      break;
    case bfd_mach_sparc_sparclite:
      set_gdbarch_deprecated_extract_return_value (gdbarch, sparc32_extract_return_value);
      set_gdbarch_num_regs (gdbarch, 80);
      set_gdbarch_register_bytes (gdbarch, 32*4 + 32*4 + 8*4 + 8*4);
      set_gdbarch_register_name (gdbarch, sparclite_register_name);
      set_gdbarch_deprecated_store_return_value (gdbarch, sparc_store_return_value);
      tdep->has_fpu = 0;	/* (all but sparclet and sparclite) */
      tdep->fp_register_bytes = 0;
      tdep->print_insn_mach = bfd_mach_sparc_sparclite;
      break;
d3412 3
a3414 1
      tdep->has_fpu = 1;	/* (all but sparclet and sparclite) */
d3422 3
a3424 1
      tdep->has_fpu = 1;	/* (all but sparclet and sparclite) */
d3428 12
a3439 10
    case bfd_mach_sparc_sparclite_le:
      set_gdbarch_deprecated_extract_return_value (gdbarch, sparc32_extract_return_value);
      set_gdbarch_num_regs (gdbarch, 80);
      set_gdbarch_register_bytes (gdbarch, 32*4 + 32*4 + 8*4 + 8*4);
      set_gdbarch_register_name (gdbarch, sparclite_register_name);
      set_gdbarch_deprecated_store_return_value (gdbarch, sparc_store_return_value);
      tdep->has_fpu = 0;	/* (all but sparclet and sparclite) */
      tdep->fp_register_bytes = 0;
      tdep->print_insn_mach = bfd_mach_sparc_sparclite;
      break;
d3446 3
a3448 1
      tdep->has_fpu = 1;	/* (all but sparclet and sparclite) */
d3458 3
a3460 1
      tdep->has_fpu = 1;	/* (all but sparclet and sparclite) */
d3480 4
a3483 2
  fprintf_unfiltered (file, "sparc_dump_tdep: has_fpu = %d\n",
		      tdep->has_fpu);
@


1.87
log
@2003-04-06  Andrew Cagney  <cagney@@redhat.com>

	* frame.h (legacy_frame_chain_valid): Rename frame_chain_valid.
	Update comment.
	* frame.c (legacy_saved_regs_this_id): Update.
	(legacy_get_prev_frame): Update.
	* xstormy16-tdep.c: Update comment.
	* sparc-tdep.c (sparc_frame_chain): Update comment.
	* blockframe.c (legacy_frame_chain_valid): Update.
@
text
@d3172 1
a3172 1
  set_gdbarch_saved_pc_after_call (gdbarch, sparc_saved_pc_after_call);
@


1.86
log
@2003-04-05  Andrew Cagney  <cagney@@redhat.com>

	Eliminate FRAME_FIND_SAVED_REGS.
	* config/pa/tm-hppah.h (hppa_hpux_frame_find_saved_regs_in_sigtramp):
	Change FSR parameter to a pointer.
	* config/pa/tm-hppa64.h (FRAME_FIND_SAVED_REGS_IN_SIGTRAMP):
	Assume FSR parameter is a pointer.
	* hppa-hpux-tdep.c (hppa_hpux_frame_find_saved_regs_in_sigtramp):
	Make fsr a pointer.
	* hppa-tdep.c (hppa_frame_find_saved_regs): New function.
	(hppa_frame_saved_pc): Call hppa_frame_init_saved_regs.  Make
	saved_regs a pointer.
	(hppa_frame_saved_pc): Ditto.
	(find_dummy_frame_regs): Make frame_saved_regs a pointer
	(hppa_pop_frame): Call hppa_frame_init_saved_regs.  Make fsr a
	pointer.
	(restore_pc_queue): Make fsr a pointer.
	(hppa_frame_find_saved_regs): Make frame_saved_regs a pointer.
	(hppa_frame_chain): Make saved_regs a pointer, call
	hppa_frame_init_saved_regs.
	* sparc-tdep.c: Include "gdb_assert.h".
	(sparc_frame_find_saved_regs): Replace internal_error with
	gdb_assert.
	* remote-vxsparc.c (vx_read_register): Delete reference to
	FRAME_FIND_SAVED_REGS.
	* gdbarch.sh: Delete check for FRAME_FIND_SAVED_REGS.
	* gdbarch.h: Regenerate.
	* frame.h (DEPRECATED_FRAME_INIT_SAVED_REGS): Delete macro.
	(deprecated_get_frame_saved_regs): Delete declaration.
	(struct frame_saved_regs): Delete definition.
	* frame.c (deprecated_get_frame_saved_regs): Delete function.
	* config/pa/tm-hppa.h (hppa_frame_init_saved_regs): Declare.
	(hppa_frame_find_saved_regs): Delete declaration.
	(FRAME_FIND_SAVED_REGS): Delete macro.
	(DEPRECATED_FRAME_INIT_SAVED_REGS): Define.
	* config/i386/tm-ptx.h (FRAME_FIND_SAVED_REGS): Delete
	FRAME_FIND_SAVED_REGS in comment.
@
text
@d440 11
a450 10
     Note:  kevinb/2003-02-18:  The constant 1 used to be returned
     here, but, after some recent changes to frame_chain_valid(),
     this value is no longer suitable for causing frame_chain_valid()
     to "not worry about the chain value."  The constant ~0 (i.e,
     0xfff...) causes the failing test in frame_chain_valid() to
     succeed thus preserving the "not worry" property.  I had considered
     using something like ``get_frame_base (frame) + 1''.  However, I think
     a constant value is better, because when debugging this problem,
     I knew that something funny was going on as soon as I saw the
     constant 1 being used as the frame chain elsewhere in GDB.  */
@


1.85
log
@2003-04-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (CALL_DUMMY_START_OFFSET): Default to zero.
	CALL_DUMMY_LENGTH): Ditto.
	* gdbarch.c: Re-generate.
	* inferior.h (CALL_DUMMY_START_OFFSET): Delete macro.
	(CALL_DUMMY_LENGTH): Delete macro.
	* alpha-tdep.c (alpha_gdbarch_init): Do not set above when zero.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
@
text
@d44 1
d1137 1
a1137 3
  if (!fi)
    internal_error (__FILE__, __LINE__,
		    "Bad frame info struct in FRAME_FIND_SAVED_REGS");
@


1.85.2.1
log
@Merge with mainline.
@
text
@a43 1
#include "gdb_assert.h"
d439 10
a448 11
     Note: kevinb/2003-02-18: The constant 1 used to be returned here,
     but, after some recent changes to legacy_frame_chain_valid(),
     this value is no longer suitable for causing
     legacy_frame_chain_valid() to "not worry about the chain value."
     The constant ~0 (i.e, 0xfff...) causes the failing test in
     legacy_frame_chain_valid() to succeed thus preserving the "not
     worry" property.  I had considered using something like
     ``get_frame_base (frame) + 1''.  However, I think a constant
     value is better, because when debugging this problem, I knew that
     something funny was going on as soon as I saw the constant 1
     being used as the frame chain elsewhere in GDB.  */
d1136 3
a1138 1
  gdb_assert (fi != NULL);
@


1.84
log
@2003-04-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (CALL_DUMMY_BREAKPOINT_OFFSET): Default to zero.
	(CALL_DUMMY_BREAKPOINT_OFFSET_P): Delete.
	* gdbarch.h, gdbarch.c: Re-generate.
	* config/sparc/tm-sp64.h (CALL_DUMMY_BREAKPOINT_OFFSET_P): Delete.
	(CALL_DUMMY_BREAKPOINT_OFFSET_P): Delete.
	* config/pa/tm-hppa64.h (CALL_DUMMY_BREAKPOINT_OFFSET_P): Delete.
	* inferior.h (CALL_DUMMY_BREAKPOINT_OFFSET_P): Delete.
	(CALL_DUMMY_BREAKPOINT_OFFSET): Delete.
	* infcmd.c (run_stack_dummy): Simplify assuming
	CALL_DUMMY_BREAKPOINT_OFFSET_P.
	* infrun.c (handle_inferior_event): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Do not set
	call_dummy_breakpoint_offset or call_dummy_breakpoint_offset_p.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
@
text
@a3246 1
      set_gdbarch_call_dummy_length (gdbarch, 0);
a3249 1
      set_gdbarch_call_dummy_start_offset (gdbarch, 0);
a3298 2
      set_gdbarch_call_dummy_length (gdbarch, 0);
      set_gdbarch_call_dummy_start_offset (gdbarch, 0);
@


1.83
log
@2003-03-31  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh: Include "symfile.h".
	(CALL_DUMMY_ADDRESS): Default to entry_point_address.
	* gdbarch.h, gdbarch.c: Re-generate.
	* inferior.h (CALL_DUMMY_ADDRESS): Delete macro.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	call_dummy_address, the default is at entry_point_address.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
@
text
@a3139 1
  set_gdbarch_call_dummy_breakpoint_offset_p (gdbarch, 1);
a3246 1
      set_gdbarch_call_dummy_breakpoint_offset (gdbarch, 0);
a3300 1
      set_gdbarch_call_dummy_breakpoint_offset (gdbarch, 0);
@


1.82
log
@2003-03-31  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (CALL_DUMMY_P): Delete.
	* gdbarch.h, gdbarch.c: Re-generate.
	* inferior.h (CALL_DUMMY_P): Delete macro.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* d10v-tdep.c (d10v_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* breakpoint.c (deprecated_frame_in_dummy): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* dummy-frame.c (dummy_frame_this_id): Update comments.
	* rs6000-tdep.c (rs6000_extract_struct_value_address): Ditto.
	* frame.c (legacy_get_prev_frame): Ditto.
	* valops.c (call_function_by_hand): Delete function.
	(hand_function_call): Rename to call_function_by_hand

2003-03-31  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	references to CALL_DUMMY_P.
@
text
@a3247 1
      set_gdbarch_call_dummy_address (gdbarch, entry_point_address);
a3302 1
      set_gdbarch_call_dummy_address (gdbarch, entry_point_address);
@


1.81
log
@2003-03-30  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_DUMMY_WRITE_SP): Replace TARGET_WRITE_SP.
	* gdbarch.h, gdbarch.c: Regenerate.
	* v850-tdep.c (v850_gdbarch_init): Set deprecated_dummy_write_sp.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_push_dummy_frame, sparc_pop_frame): Update.
	* config/sparc/tm-sp64.h (DEPRECATED_DUMMY_WRITE_SP): Update.
	* config/pa/tm-hppa.h (DEPRECATED_DUMMY_WRITE_SP): Define.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* valops.c (hand_function_call): Replace TARGET_WRITE_SP with
	DEPRECATED_DUMMY_WRITE_SP.  Call when the method is available,
	instead of when push_dummy_call is not available.

2003-03-30  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Remove
	reference to TARGET_WRITE_SP.
@
text
@a3140 1
  set_gdbarch_call_dummy_p (gdbarch, 1);
@


1.80
log
@2003-03-30  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_PUSH_RETURN_ADDRESS): Replace
	PUSH_RETURN_ADDRESS.
	* gdbarch.h, gdbarch.c: Regenerate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* valops.c (hand_function_call): Update.
@
text
@d1043 1
a1043 1
  TARGET_WRITE_SP (sp);
d1313 1
a1313 1
      TARGET_WRITE_SP (get_frame_base (frame));
d3282 1
a3282 1
      set_gdbarch_write_sp (gdbarch, generic_target_write_sp);
d3340 1
a3340 1
      set_gdbarch_write_sp (gdbarch, sparc64_write_sp);
@


1.79
log
@2003-03-27  Andrew Cagney  <cagney@@redhat.com>

	* regcache.c (write_sp): Delete function and references.
	* inferior.h (write_sp): Delete declaration.
	* valops.c (hand_function_call): Replace write_sp with
	TARGET_WRITE_SP.
	* sparc-tdep.c (sparc_push_dummy_frame): Ditto.
	(sparc_pop_frame): Ditto.

Index: doc/ChangeLog
2003-03-27  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Remove
	references to write_sp.
@
text
@d3164 1
a3164 1
  set_gdbarch_push_return_address (gdbarch, sparc_push_return_address);
@


1.78
log
@2003-03-26  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_PUSH_ARGUMENTS): Rename PUSH_ARGUMENTS.
	(push_dummy_call): New pure multi-arch replacement with gdbarch,
	regcache and dummy_addr parameters.
	* gdbarch.h, gdbarch.c: Re-generate.
	* valops.c (hand_function_call): Use gdbarch_push_dummy_call when
	available; assume it will handle stack alignment and return
	address issues.  Fall back to DEPRECATED_PUSH_ARGUMENTS and
	legacy_push_arguments.
	(legacy_push_arguments): Rename default_push_arguments.
	* value.h (legacy_push_arguments): Rename default_push_arguments.
	* i386-tdep.c (i386_push_arguments): Call legacy_push_arguments.
	* config/sparc/tm-sparc.h (DEPRECATED_PUSH_ARGUMENTS): Update.
	* config/sparc/tm-sp64.h (DEPRECATED_PUSH_ARGUMENTS): Update.
	* config/pa/tm-hppa.h (DEPRECATED_PUSH_ARGUMENTS): Update.
	* config/i386/tm-symmetry.h: Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* d10v-tdep.c (d10v_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* arm-linux-tdep.c (arm_linux_init_abi): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

2003-03-26  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	PUSH_ARGUMENTS with push_dummy_call, add gdbarch, regcache and
	dummy_addr parameters.
@
text
@d1043 1
a1043 1
  write_sp (sp);
d1313 1
a1313 1
      write_sp (get_frame_base (frame));
@


1.77
log
@2003-03-25  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_EXTRA_STACK_ALIGNMENT_NEEDED): Replace
	EXTRA_STACK_ALIGNMENT_NEEDED.  Default to 0 not 1.
	* gdbarch.h, gdbarch.c: Re-generate.
	* config/sparc/tm-sparc.h
	(DEPRECATED_EXTRA_STACK_ALIGNMENT_NEEDED): Define.
	* sparc-tdep.c (sparc_gdbarch_init): Set
	deprecated_extra_stack_alignment_needed.
	* config/pa/tm-hppa.h (EXTRA_STACK_ALIGNMENT_NEEDED): Delete.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not clear
	extra_stack_alignment_needed.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
@
text
@d3262 1
a3262 1
      set_gdbarch_push_arguments (gdbarch, sparc32_push_arguments);
d3318 1
a3318 1
      set_gdbarch_push_arguments (gdbarch, sparc64_push_arguments);
@


1.77.2.1
log
@Merge with mainline.
@
text
@d1043 1
a1043 1
  DEPRECATED_DUMMY_WRITE_SP (sp);
d1313 1
a1313 1
      DEPRECATED_DUMMY_WRITE_SP (get_frame_base (frame));
d3164 1
a3164 1
  set_gdbarch_deprecated_push_return_address (gdbarch, sparc_push_return_address);
d3262 1
a3262 1
      set_gdbarch_deprecated_push_arguments (gdbarch, sparc32_push_arguments);
d3282 1
a3282 1
      set_gdbarch_deprecated_dummy_write_sp (gdbarch, generic_target_write_sp);
d3318 1
a3318 1
      set_gdbarch_deprecated_push_arguments (gdbarch, sparc64_push_arguments);
d3340 1
a3340 1
      set_gdbarch_deprecated_dummy_write_sp (gdbarch, sparc64_write_sp);
@


1.76
log
@2003-03-25  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_STORE_STRUCT_RETURN): Replace
	STORE_STRUCT_RETURN.
	* gdbarch.h, gdbarch.c: Regenerate.
	* d10v-tdep.c (d10v_store_struct_return): Delete function.
	(d10v_push_arguments): Set the struct return register.
	(d10v_gdbarch_init): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
@
text
@d3278 1
d3336 1
@


1.75
log
@2003-03-25  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (CALL_DUMMY_STACK_ADJUST_P): Delete.
	(DEPRECATED_CALL_DUMMY_STACK_ADJUST): Replace
	CALL_DUMMY_STACK_ADJUST with a predicate variable.
	* gdbarch.h, gdbarch.c: Regenerate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	call_dummy_stack_adjust_p.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
	* config/sparc/tm-sp64.h (CALL_DUMMY_STACK_ADJUST): Update.
	* config/sparc/tm-sparc.h (CALL_DUMMY_STACK_ADJUST): Update.
	* config/sparc/tm-sp64.h (CALL_DUMMY_STACK_ADJUST): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.  Do not set
	call_dummy_stack_adjust_p.
	* inferior.h (CALL_DUMMY_STACK_ADJUST_P): Delete macro.
	(CALL_DUMMY_STACK_ADJUST): Delete macro.
	* sparc-tdep.c (sparc32_push_arguments): Update.
	* valops.c (hand_function_call): Update.

2003-03-25  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	reference to CALL_DUMMY_STACK_ADJUST_P.  Rename
	CALL_DUMMY_STACK_ADJUST to DEPRECATED_CALL_DUMMY_STACK_ADJUST.
	Add reference to PUSH_ARGUMENTS.
@
text
@d3278 1
a3278 1
      set_gdbarch_store_struct_return (gdbarch, sparc32_store_struct_return);
d3335 1
a3335 1
      set_gdbarch_store_struct_return (gdbarch, sparc64_store_struct_return);
@


1.74
log
@Index: ChangeLog
2003-03-23  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_FRAME_CHAIN): Replace FRAME_CHAIN.
	(DEPRECATED_FRAME_CHAIN_VALID): Replace FRAME_CHAIN_VALID.
	* gdbarch.h, gdbarch.c: Regenerate.
	* valops.c (hand_function_call): Update.
	* objfiles.h (DEPRECATED_FRAME_CHAIN_VALID): Update.
	* frame.c (legacy_saved_regs_this_id): Update.
	(legacy_get_prev_frame, get_prev_frame, legacy_frame_p): Update.
	* dummy-frame.h: Update.
	* config/sparc/tm-sparc.h (DEPRECATED_FRAME_CHAIN): Update.
	* config/pa/tm-hppa.h (DEPRECATED_FRAME_CHAIN_VALID): Update.
	* config/m68k/tm-vx68.h (DEPRECATED_FRAME_CHAIN): Update.
	* config/m68k/tm-os68k.h (DEPRECATED_FRAME_CHAIN): Update.
	* config/m68k/tm-sun3.h: Update.
	* blockframe.c (inside_main_func, frame_chain_valid): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_frame_chain, sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_frame_saved_pc): Update.
	(rs6000_gdbarch_init, rs6000_frame_saved_pc): Update.
	(frame_get_saved_regs): Update.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_frame_num_args, i386_gdbarch_init): Update.
	* i386-interix-tdep.c (i386_interix_init_abi): Update.
	(i386_interix_back_one_frame): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	(hppa_init_extra_frame_info): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

Index: doc/ChangeLog
2003-03-23  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Algorithms, Target Architecture Definition):
	Deprecate FRAME_CHAIN and FRAME_CHAIN_VALID.
@
text
@d2252 2
a2253 2
  accumulate_size += CALL_DUMMY_STACK_ADJUST;
  sp = ((sp - accumulate_size) & ~7) + CALL_DUMMY_STACK_ADJUST;
a3141 1
  set_gdbarch_call_dummy_stack_adjust_p (gdbarch, 1);
d3254 1
a3254 1
      set_gdbarch_call_dummy_stack_adjust (gdbarch, 68);
d3310 1
a3310 1
      set_gdbarch_call_dummy_stack_adjust (gdbarch, 128);
@


1.73
log
@2003-03-12  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (get_saved_register): Delete function.
	* xstormy16-tdep.c: Update comment.
	* regcache.h: Update comments.
	* sparc-tdep.c (sparc_init_extra_frame_info): Instead of
	get_saved_register and extract_address, use
	frame_read_unsigned_register.
	(sparc_frame_saved_pc): Ditto.
	(sparc_get_saved_register): Instead of get_saved_register, use
	frame_register.
	(sparc_pop_frame): Ditto.
	* frame.h (get_saved_register): Delete declaration.
	* findvar.c: Update comments.
	(value_of_register): Call frame_register instead of
	get_saved_register.
	(value_from_register): Ditto.
	* config/sparc/tm-sparc.h: Update comment.
	* breakpoint.c: Update comment.

Index: doc/ChangeLog
2003-03-12  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	references to get_saved_register.
@
text
@d435 3
a437 3
  /* Value that will cause FRAME_CHAIN_VALID to not worry about the chain
     value.  If it really is zero, we detect it later in
     sparc_init_prev_frame.
d3150 1
a3150 1
  set_gdbarch_frame_chain (gdbarch, sparc_frame_chain);
@


1.72
log
@2003-03-14  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_GET_SAVED_REGISTER): Replace
	GET_SAVED_REGISTER.
	* gdbarch.h, gdbarch.c: Re-generate.
	* frame.h: Update comments.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* frame.c (frame_register): Update.
	(get_saved_register): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_GET_SAVED_REGISTER): Update.
@
text
@d329 3
a331 3
	  get_saved_register (buf, 0, 0, fi, FP_REGNUM, 0);
	  deprecated_update_frame_base_hack (fi, extract_address (buf, REGISTER_RAW_SIZE (FP_REGNUM)));

d370 5
a374 2
	      get_saved_register (buf, 0, 0, fi, I7_REGNUM, 0);
	      deprecated_update_frame_base_hack (fi, extract_address (buf, REGISTER_RAW_SIZE (I7_REGNUM)));
d493 5
a497 3
      get_saved_register (buf, (int *) NULL, (CORE_ADDR *) NULL,
			  frame, O0_REGNUM + 2, (enum lval_type *) NULL);
      sigcontext_addr = extract_address (buf, REGISTER_RAW_SIZE (O0_REGNUM + 2));
d513 3
a515 3
      get_saved_register (buf, (int *) NULL, (CORE_ADDR *) NULL,
			  frame, O7_REGNUM, (enum lval_type *) NULL);
      return PC_ADJUST (extract_address (buf, SPARC_INTREG_SIZE));
d944 3
a946 2
	      get_saved_register (raw_buffer, optimized, addrp, frame1,
				  (regnum - O0_REGNUM + I0_REGNUM), lval);
d1099 4
a1102 4
   frames save all registers).  Rewriting pop_frame to use
   get_saved_register would solve this problem and also get rid of the
   ugly duplication between sparc_frame_find_saved_regs and
   get_saved_register.
d1378 3
a1380 6
	  char *buf;

	  buf = alloca (MAX_REGISTER_RAW_SIZE);
	  get_saved_register (buf, 0, 0, frame, O7_REGNUM, 0);
	  pc = PC_ADJUST (extract_address
			  (buf, REGISTER_RAW_SIZE (O7_REGNUM)));
@


1.71
log
@2003-03-13  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_POP_FRAME): Replace POP_FRAME.
	* gdbarch.h, gdbarch.c: Regenerate.
	* valops.c (hand_function_call): Update comment.
	* stack.c (return_command): Update comment.
	* config/sparc/tm-sparc.h (DEPRECATED_POP_FRAME): Update.
	* config/pa/tm-hppa.h (DEPRECATED_POP_FRAME): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

2003-03-13  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	POP_FRAME with DEPRECATED_POP_FRAME.  Update description.
@
text
@d3153 1
a3153 1
  set_gdbarch_get_saved_register (gdbarch, sparc_get_saved_register);
@


1.70
log
@2003-03-12  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_FRAME_SAVED_PC): Replace FRAME_SAVED_PC.
	* gdbarch.h, gdbarch.c: Re-generate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.h: Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* i386-interix-tdep.c (i386_interix_init_abi): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* sh-tdep.c (sh_init_extra_frame_info): Update.
	(sh64_init_extra_frame_info): Update.
	* ns32knbsd-nat.c (frame_num_args): Update.
	* m68hc11-tdep.c (m68hc11_init_extra_frame_info): Update.
	* xstormy16-tdep.c (xstormy16_pop_frame): Update.
	(xstormy16_frame_chain_valid): Update.
	* vax-tdep.c (vax_saved_pc_after_call): Update.
	* v850-tdep.c (v850_frame_chain): Update.
	(v850_pop_frame): Update.
	(v850_init_extra_frame_info): Update.
	* sparc-tdep.c (setup_arbitrary_frame): Update.
	* ns32k-tdep.c (umax_frame_num_args): Update.
	* s390-tdep.c (s390_pop_frame_regular): Update.
	* mn10300-tdep.c (mn10300_frame_chain): Update.
	(mn10300_pop_frame_regular): Update.
	(mn10300_init_extra_frame_info): Update.
	* mips-tdep.c (mips_init_frame_pc_first): Update.
	(mips_frame_chain): Update.
	(mips_pop_frame): Update.
	* mcore-tdep.c (mcore_frame_chain): Update.
	(mcore_pop_frame): Update.
	(mcore_init_extra_frame_info): Update.
	* arch-utils.c (init_frame_pc_default): Update.
	* m68k-tdep.c (isi_frame_num_args): Update.
	(delta68_frame_num_args): Update.
	(news_frame_num_args): Update.
	* ia64-tdep.c (ia64_pop_frame_regular): Update.
	* alpha-tdep.c (alpha_init_frame_pc_first): Update.
	(alpha_frame_chain): Update.
	(alpha_pop_frame): Update.
	* hppa-tdep.c (hppa_saved_pc_after_call): Update.
	(hppa_init_extra_frame_info): Update.
	(hppa_frame_chain): Update.
	(hppa_frame_chain_valid): Update.
	* cris-tdep.c (cris_init_extra_frame_info): Update.
	* avr-tdep.c (avr_init_extra_frame_info): Update.
	* arm-tdep.c (arm_frame_chain_valid): Update.
	(arm_init_extra_frame_info): Update.
	(arm_pop_frame): Update.
	* frame.c (frame_pc_unwind): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_FRAME_SAVED_PC): Update.
	(DEPRECATED_INIT_FRAME_PC_FIRST): Update.
	* config/rs6000/tm-rs6000.h (DEPRECATED_INIT_FRAME_PC_FIRST): Update.
	* config/pa/tm-hppa.h (DEPRECATED_FRAME_SAVED_PC): Update.
	* config/m68k/tm-delta68.h (DEPRECATED_FRAME_SAVED_PC): Update.
	* config/m68k/tm-linux.h (DEPRECATED_FRAME_SAVED_PC): Update.

2003-03-12  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	FRAME_SAVED_PC to DEPRECATED_FRAME_SAVED_PC.
@
text
@d3161 1
a3161 1
  set_gdbarch_pop_frame (gdbarch, sparc_pop_frame);
@


1.69
log
@2003-03-03  Andrew Cagney  <cagney@@redhat.com>

	Make MAX_REGISTER_RAW_SIZE and MAX_REGISTER_VIRTUAL_SIZE optional.
	* gdbarch.sh (DEPRECATED_MAX_REGISTER_RAW_SIZE): Variable with
	predicate.  Replace MAX_REGISTER_RAW_SIZE.
	(DEPRECATED_MAX_REGISTER_VIRTUAL_SIZE): Ditto for
	MAX_REGISTER_VIRTUAL_SIZE.
	* regcache.c (legacy_max_register_raw_size): New function.
	(legacy_max_register_virtual_size): New function.
	* defs.h (MAX_REGISTER_VIRTUAL_SIZE): Define.
	(MAX_REGISTER_RAW_SIZE): Define.
	(legacy_max_register_raw_size): Declare.
	(legacy_max_register_virtual_size): Declare.
	* config/sparc/tm-sparc.h (DEPRECATED_MAX_REGISTER_RAW_SIZE)
	(DEPRECATED_MAX_REGISTER_VIRTUAL_SIZE): Update.
	* config/sparc/tm-sp64.h (DEPRECATED_MAX_REGISTER_RAW_SIZE)
	(DEPRECATED_MAX_REGISTER_VIRTUAL_SIZE): Ditto.
	* config/pa/tm-hppa.h (DEPRECATED_MAX_REGISTER_RAW_SIZE)
	(DEPRECATED_MAX_REGISTER_VIRTUAL_SIZE): Ditto.
	* config/pa/tm-hppa64.h (DEPRECATED_MAX_REGISTER_RAW_SIZE): Ditto.
	* config/ia64/tm-ia64.h (DEPRECATED_MAX_REGISTER_RAW_SIZE): Ditto.
	* config/i386/tm-ptx.h (DEPRECATED_MAX_REGISTER_RAW_SIZE): Ditto.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* d10v-tdep.c (d10v_gdbarch_init): Do not set
	max_register_raw_size or max_register_virtual_size.
@
text
@d550 1
a550 1
  deprecated_update_frame_pc_hack (frame, FRAME_SAVED_PC (frame));
d3150 1
a3150 1
  set_gdbarch_frame_saved_pc (gdbarch, sparc_frame_saved_pc);
@


1.69.4.1
log
@2003-03-16  Mark Kettenis  <kettenis@@gnu.org>

	Merge with mainline.  Tag is kettenis-i386newframe-20030316-mergepoint.
@
text
@d329 3
a331 3
	  ULONGEST tmp;
	  frame_read_unsigned_register (fi, FP_REGNUM, &tmp);
	  deprecated_update_frame_base_hack (fi, tmp);
d370 2
a371 5
	      {
		ULONGEST tmp;
		frame_read_unsigned_register (fi, I7_REGNUM, &tmp);
		deprecated_update_frame_base_hack (fi, tmp);
	      }
d490 3
a492 5
      {
	ULONGEST tmp;
	frame_read_unsigned_register (frame, O0_REGNUM + 2, &tmp);
	sigcontext_addr = tmp;
      }
d508 3
a510 3
      ULONGEST tmp;
      frame_read_unsigned_register (frame, O7_REGNUM, &tmp);
      return PC_ADJUST (tmp);
d550 1
a550 1
  deprecated_update_frame_pc_hack (frame, DEPRECATED_FRAME_SAVED_PC (frame));
d939 2
a940 3
	      int realnum;
	      frame_register (frame1, (regnum - O0_REGNUM + I0_REGNUM),
			      optimized, lval, addrp, &realnum, raw_buffer);
d1093 4
a1096 4
   frames save all registers).

   NOTE: cagney/2003-03-12: Since pop_frame has been rewritten to use
   frame_unwind_register() the need for this function is questionable.
d1372 6
a1377 3
	  ULONGEST tmp;
	  frame_read_unsigned_register (frame, O7_REGNUM, &tmp);
	  pc = PC_ADJUST (tmp);
d3150 1
a3150 1
  set_gdbarch_deprecated_frame_saved_pc (gdbarch, sparc_frame_saved_pc);
d3153 1
a3153 1
  set_gdbarch_deprecated_get_saved_register (gdbarch, sparc_get_saved_register);
d3161 1
a3161 1
  set_gdbarch_deprecated_pop_frame (gdbarch, sparc_pop_frame);
@


1.68
log
@2003-03-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_FRAME_INIT_SAVED_REGS): Rename
	FRAME_INIT_SAVED_REGS.
	* gdbarch.h, gdbarch.c: Regenerate.
	* stack.c (frame_info): Update.
	* sh-tdep.c (sh_find_callers_reg, sh64_get_saved_pr): Update.
	(sh_init_extra_frame_info, sh64_init_extra_frame_info): Update.
	(sh64_get_saved_register, sh_pop_frame, sh64_pop_frame): Update.
	* ns32k-tdep.c (ns32k_pop_frame): Update.
	* mips-tdep.c (mips_pop_frame): Update.
	* m68hc11-tdep.c (m68hc11_pop_frame): Update.
	* ia64-tdep.c (ia64_frame_chain): Update.
	(ia64_frame_saved_pc, ia64_get_saved_register): Update.
	(ia64_frameless_function_invocation): Update.
	(ia64_init_extra_frame_info): Update.
	(ia64_pop_frame_regular): Update.
	* frame.h (struct frame_info): Update comment.
	(DEPRECATED_FRAME_INIT_SAVED_REGS): Rename macro.
	* frame.c (frame_saved_regs_register_unwind): Update.
	(frame_saved_regs_register_unwind): Update.
	(deprecated_generic_get_saved_register): Update.
	* cris-tdep.c: Update comment.
	* config/sparc/tm-sparc.h (DEPRECATED_FRAME_INIT_SAVED_REGS):
	Rename macro.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

2003-03-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	FRAME_INIT_SAVED_REGS to DEPRECATED_FRAME_INIT_SAVED_REGS.
@
text
@d3159 2
a3160 2
  set_gdbarch_max_register_raw_size (gdbarch, 8);
  set_gdbarch_max_register_virtual_size (gdbarch, 8);
@


1.67
log
@2003-03-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_INIT_EXTRA_FRAME_INFO): Rename
	INIT_EXTRA_FRAME_INFO.
	* gdbarch.h, gdbarch.c: Regenerate.
	* arm-tdep.c: Update comments.
	* sh-tdep.c, mcore-tdep.c, m68hc11-tdep.c: Ditto.
	* i386-interix-tdep.c, hppa-tdep.c, h8300-tdep.c: Ditto.
	* frame.h, avr-tdep.c: Ditto.
	* frame.c (get_prev_frame): DEPRECATED_INIT_EXTRA_FRAME_INFO.
	(create_new_frame, legacy_get_prev_frame): Ditto.
	* config/sparc/tm-sparc.h (DEPRECATED_INIT_EXTRA_FRAME_INFO): Rename.
	* config/pa/tm-hppa.h (DEPRECATED_INIT_EXTRA_FRAME_INFO): Rename.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Initialize
	deprecated_init_extra_frame_info instead of init_extra_frame_info.
	* x86-64-tdep.c (x86_64_init_abi): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-interix-tdep.c (i386_interix_init_abi): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.

Index: doc/ChangeLog
2003-02-26  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo: Rename INIT_EXTRA_FRAME_INFO to
	DEPRECATED_INIT_EXTRA_FRAME_INFO.
@
text
@d3148 1
a3148 1
  set_gdbarch_frame_init_saved_regs (gdbarch, sparc_frame_init_saved_regs);
@


1.66
log
@2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_PUSH_DUMMY_FRAME): Procedure with
	predicate.  Replaces PUSH_DUMMY_FRAME.
	* gdbarch.h, gdbarch.c: Regnerate.
	* valops.c (hand_function_call): Update.  Call
	generic_push_dummy_frame directly.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_PUSH_DUMMY_FRAME): Update.
	* config/pa/tm-hppa.h (DEPRECATED_PUSH_DUMMY_FRAME): Update.
	* inferior.h (PUSH_DUMMY_FRAME): Delete definition.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Don't set
	push_dummy_frame to generic_push_dummy_frame.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
@
text
@d3154 1
a3154 1
  set_gdbarch_init_extra_frame_info (gdbarch, sparc_init_extra_frame_info);
@


1.65
log
@Make Sparc/Solaris work again.
@
text
@d3163 1
a3163 1
  set_gdbarch_push_dummy_frame (gdbarch, sparc_push_dummy_frame);
@


1.64
log
@2003-01-15  Andrew Cagney  <ac131313@@redhat.com>

	* sparc-tdep.c: Delete reference to PRINT_REGISTER_HOOK.

Index: doc/ChangeLog
2003-01-15  Andrew Cagney  <ac131313@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	definition of PRINT_REGISTER_HOOK.
@
text
@d434 14
a447 2
     sparc_init_prev_frame.  */
  return (CORE_ADDR) 1;
@


1.63
log
@2003-01-08  Andrew Cagney  <cagney@@redhat.com>

	* alpha-tdep.c: Use get_frame_extra_info.
	* arm-tdep.c, avr-tdep.c, cris-tdep.c, d10v-tdep.c: Ditto.
	* h8300-tdep.c, ia64-tdep.c, m68hc11-tdep.c, mcore-tdep.c: Ditto.
	* mips-tdep.c, mn10300-tdep.c, s390-tdep.c, sh-tdep.c: Ditto.
	* sparc-tdep.c, xstormy16-tdep.c: Ditto.
@
text
@d1865 1
a1865 2
/* PRINT_REGISTER_HOOK routine.
   Pretty print various registers.  */
@


1.62
log
@2003-01-08  Andrew Cagney  <cagney@@redhat.com>

	* alpha-tdep.c: Use get_next_frame.
	* arm-tdep.c, avr-tdep.c, cris-tdep.c, d10v-tdep.c: Ditto.
	* dwarf2cfi.c, h8300-tdep.c, i386-tdep.c, ia64-tdep.c: Ditto.
	* m68hc11-tdep.c, m68k-tdep.c, mcore-tdep.c: Ditto.
	* mips-tdep.c, mn10200-tdep.c, mn10300-tdep.c: Ditto.
	* ns32k-tdep.c, s390-tdep.c, sh-tdep.c, sparc-tdep.c: Ditto.
	* v850-tdep.c, vax-tdep.c, x86-64-linux-tdep.c: Ditto.
	* xstormy16-tdep.c: Ditto.
@
text
@d298 1
a298 1
  fi->extra_info->bottom =
d301 1
a301 1
	? get_next_frame (fi)->extra_info->bottom
d323 2
a324 1
	  fi->extra_info->bottom = get_next_frame (fi)->extra_info->bottom;
d339 2
a340 2
  fi->extra_info->flat = 0;
  fi->extra_info->in_prologue = 0;
d365 1
a365 1
	      fi->extra_info->flat = 1;
d367 1
a367 1
	      fi->extra_info->sp_offset = offset;
d377 2
a378 2
	      fi->extra_info->fp_addr = 
		get_frame_base (fi) + fi->extra_info->sp_offset + X_SIMM13 (insn);
d381 1
a381 1
	      fi->extra_info->pc_addr = 0;
d387 2
a388 2
		fi->extra_info->pc_addr = 
		  get_frame_base (fi) + fi->extra_info->sp_offset + X_SIMM13 (insn);
d415 1
a415 1
		  fi->extra_info->in_prologue = 1;
d488 1
a488 1
  else if (frame->extra_info->in_prologue ||
d500 2
a501 2
  if (frame->extra_info->flat)
    addr = frame->extra_info->pc_addr;
d503 1
a503 1
    addr = frame->extra_info->bottom + FRAME_SAVED_I0 +
d537 1
a537 1
  frame->extra_info->bottom = argv[1];
d679 1
a679 1
	      get_frame_base (fi) + fi->extra_info->sp_offset + X_SIMM13 (insn);
d849 3
a851 2
      if (get_frame_pc (frame1) >= (frame1->extra_info->bottom ? 
			 frame1->extra_info->bottom : read_sp ())
d866 1
a866 1
	    addr = (get_prev_frame (frame1)->extra_info->bottom
d875 1
a875 1
	    addr = (get_prev_frame (frame1)->extra_info->bottom
d893 1
a893 1
      else if (frame1->extra_info->flat)
d897 1
a897 1
	    addr = frame1->extra_info->pc_addr;
d899 1
a899 1
	    addr = frame1->extra_info->fp_addr;
d917 1
a917 1
	    addr = (get_prev_frame (frame1)->extra_info->bottom
d921 1
a921 1
	    addr = (get_prev_frame (frame1)->extra_info->bottom
d1124 3
a1126 2
  if (get_frame_pc (fi) >= (fi->extra_info->bottom ? 
		 fi->extra_info->bottom : read_sp ())
d1162 3
a1164 2
      frame_addr = fi->extra_info->bottom ?
	fi->extra_info->bottom : read_sp ();
d1166 1
a1166 1
  else if (fi->extra_info->flat)
d1173 2
a1174 2
      saved_regs_addr[RP_REGNUM] = fi->extra_info->pc_addr;
      saved_regs_addr[I7_REGNUM] = fi->extra_info->fp_addr;
d1179 3
a1181 2
      frame_addr = fi->extra_info->bottom ?
	fi->extra_info->bottom : read_sp ();
d1193 1
a1193 1
      if (fi->extra_info->flat)
d1195 1
a1195 1
	  saved_regs_addr[O7_REGNUM] = fi->extra_info->pc_addr;
d1201 3
a1203 2
	  (get_next_frame (fi)->extra_info->bottom ?
	   get_next_frame (fi)->extra_info->bottom : read_sp ());
d1272 1
a1272 1
  if (frame->extra_info->flat)
d1349 1
a1349 1
  else if (frame->extra_info->flat)
d1351 1
a1351 1
      if (frame->extra_info->pc_addr)
d1353 1
a1353 1
			read_memory_integer (frame->extra_info->pc_addr,
d2694 1
a2694 1
  if (fi && fi->extra_info && fi->extra_info->flat)
d2696 2
a2697 2
		     paddr_nz (fi->extra_info->pc_addr), 
		     paddr_nz (fi->extra_info->fp_addr));
@


1.61
log
@2003-01-07  Andrew Cagney  <cagney@@redhat.com>

	* alpha-tdep.c: Use get_frame_base.
	* arm-tdep.c, avr-tdep.c, cris-tdep.c, d10v-tdep.c: Ditto.
	* h8300-tdep.c, i386-tdep.c, ia64-tdep.c, m68hc11-tdep.c: Ditto.
	* m68k-tdep.c, mcore-tdep.c, mips-tdep.c, mn10200-tdep.c: Ditto.
	* mn10300-tdep.c, ns32k-tdep.c, s390-tdep.c, sh-tdep.c: Ditto.
	* sparc-tdep.c, v850-tdep.c, vax-tdep.c: Ditto.
	* x86-64-linux-tdep.c, xstormy16-tdep.c: Ditto.
	* config/h8500/tm-h8500.h, config/mn10200/tm-mn10200.h: Ditto.
	* config/sparc/tm-sparc.h: Ditto.
@
text
@d299 5
a303 3
    (fi->next ?
     (get_frame_base (fi) == get_frame_base (fi->next) ? fi->next->extra_info->bottom : 
      get_frame_base (fi->next)) : read_sp ());
d307 1
a307 1
  if (fi->next)
d315 4
a318 4
      if (fi->next->next != NULL
	  && ((get_frame_type (fi->next->next) == SIGTRAMP_FRAME)
	      || deprecated_frame_in_dummy (fi->next->next))
	  && frameless_look_for_prologue (fi->next))
d322 2
a323 2
	  deprecated_update_frame_base_hack (fi, get_frame_base (fi->next));
	  fi->extra_info->bottom = fi->next->extra_info->bottom;
d420 1
a420 1
  if (fi->next && get_frame_base (fi) == 0)
d423 2
a424 2
      deprecated_update_frame_base_hack (fi, get_frame_base (fi->next));
      deprecated_update_frame_pc_hack (fi, get_frame_pc (fi->next));
d488 3
a490 3
	   (frame->next != NULL &&
	    ((get_frame_type (frame->next) == SIGTRAMP_FRAME) ||
	     deprecated_frame_in_dummy (frame->next)) &&
d827 1
a827 1
  frame1 = frame->next;
d932 1
a932 1
      frame1 = frame1->next;
d1186 1
a1186 1
  if (fi->next)
d1196 2
a1197 2
	  (fi->next->extra_info->bottom ?
	   fi->next->extra_info->bottom : read_sp ());
@


1.60
log
@2003-01-07  Andrew Cagney  <cagney@@redhat.com>

	* xstormy16-tdep.c (xstormy16_init_extra_frame_info): Allocate
	extra_info using frame_extra_info_zalloc.
	* sparc-tdep.c (sparc_init_extra_frame_info): Ditto.
	* sh-tdep.c (sh_init_extra_frame_info): Ditto.
	(sh64_init_extra_frame_info): Ditto.
	* mn10300-tdep.c (mn10300_init_extra_frame_info): Ditto.
	* s390-tdep.c (s390_init_extra_frame_info): Ditto.
	* mips-tdep.c (mips_init_extra_frame_info): Ditto.
	* mcore-tdep.c (mcore_init_extra_frame_info): Ditto.
	* frv-tdep.c (frv_init_extra_frame_info): Ditto.
	* m68hc11-tdep.c (m68hc11_init_extra_frame_info): Ditto.
	* ia64-tdep.c (ia64_init_extra_frame_info): Ditto.
	* h8300-tdep.c (h8300_init_extra_frame_info): Ditto.
	* d10v-tdep.c (d10v_init_extra_frame_info): Ditto.
	* cris-tdep.c (cris_init_extra_frame_info): Ditto.
	* arm-tdep.c (arm_init_extra_frame_info): Ditto.
	* alpha-tdep.c (alpha_init_extra_frame_info): Ditto.

	* mn10300-tdep.c (analyze_dummy_frame): Use
	deprecated_set_frame_extra_info_hack.
	* mcore-tdep.c (analyze_dummy_frame): Ditto.
@
text
@d300 2
a301 2
     (fi->frame == fi->next->frame ? fi->next->extra_info->bottom : 
      fi->next->frame) : read_sp ());
d329 2
a330 2
	  if (GDB_TARGET_IS_SPARC64 && (fi->frame & 1))
	    deprecated_update_frame_base_hack (fi, fi->frame + 2047);
d370 2
a371 2
	      if (GDB_TARGET_IS_SPARC64 && (fi->frame & 1))
		deprecated_update_frame_base_hack (fi, fi->frame + 2047);
d375 1
a375 1
		fi->frame + fi->extra_info->sp_offset + X_SIMM13 (insn);
d385 1
a385 1
		  fi->frame + fi->extra_info->sp_offset + X_SIMM13 (insn);
d418 1
a418 1
  if (fi->next && fi->frame == 0)
d421 1
a421 1
      deprecated_update_frame_base_hack (fi, fi->next->frame);
d676 1
a676 1
	      fi->frame + fi->extra_info->sp_offset + X_SIMM13 (insn);
d854 1
a854 1
	    addr = frame1->frame + (regnum - G0_REGNUM) * SPARC_INTREG_SIZE
d875 1
a875 1
	    addr = frame1->frame + (regnum - O0_REGNUM) * SPARC_INTREG_SIZE
d879 1
a879 1
	    addr = frame1->frame + (regnum - FP0_REGNUM) * 4
d883 1
a883 1
	    addr = frame1->frame + 32 * 4 + (regnum - FP0_REGNUM - 32) * 8
d886 1
a886 1
	    addr = frame1->frame + (regnum - Y_REGNUM) * SPARC_INTREG_SIZE
d1287 1
a1287 1
      write_sp (frame->frame);
@


1.59
log
@2003-01-06  Andrew Cagney  <cagney@@redhat.com>

	* sparc-tdep.c (sparc_dump_tdep): Fix typo, match -> mach.
@
text
@d295 1
a295 2
  fi->extra_info = (struct frame_extra_info *)
    frame_obstack_alloc (sizeof (struct frame_extra_info));
@


1.58
log
@	* arm-tdep.c (arm_frame_chain_valid):  Remove unnecessary test.
	* d10v-tdep.c (d10v_frame_chain_valid): Remove unnecessary tests.
	* hppa-tdep.c (hppa_frame_chain_valid): Remove unnecessary test.

	* blockframe.c: Include "gdbcmd.h" and "command.h".
	(backtrace_below_main): New variable.
	(file_frame_chain_valid, func_frame_chain_valid)
	(nonnull_frame_chain_valid, generic_file_frame_chain_valid)
	(generic_func_frame_chain_valid): Remove functions.
	(frame_chain_valid, do_flush_frames_sfunc): New functions.
	(_initialize_blockframe): New function.
	* Makefile.in (blockframe.o): Update dependencies.
	* frame.c (frame_saved_regs_id_unwind, get_prev_frame): Remove FIXME
	comment.  Call frame_chain_valid ().
	* frame.h: Remove old prototypes.  Add prototype for
	frame_chain_valid and update comments to match.
	* gdbarch.sh: Change FRAME_CHAIN_VALID into a predicated function.
	Remove old comment.
	* gdbarch.h: Regenerated.
	* gdbarch.c: Regenerated.

Plus updates to all other targets not to provide a FRAME_CHAIN_VALID.
@
text
@d3444 1
a3444 1
		      tdep->print_insn_match);
@


1.57
log
@	* arch-utils.c (gdbarch_info_init): Set osabi to
	GDB_OSABI_UNINITIALIZED.
	* gdbarch.sh: Add osabi to struct gdbarch and to struct
	gdbarch_info.  Include "osabi.h" in gdbarch.c.  Check osabi
	in gdbarch_list_lookup_by_info and in gdbarch_update_p.
	* gdbarch.c: Regenerated.
	* gdbarch.h: Regenerated.
	* osabi.c (gdbarch_lookup_osabi): Return GDB_OSABI_UNINITIALIZED if
	there's no BFD.
	(gdbarch_init_osabi): Remove osabi argument; use info.osabi.
	* osabi.h (enum gdb_osabi): Move to defs.h.
	(gdbarch_init_osabi): Update prototype.
	* defs.h (enum gdb_osabi): Moved here.
	* Makefile.in: Update dependencies.

Plus updates to alpha, arm, hppa, i386, mips, ns32k, ppc, sh, sparc, and vax
ports to match.
@
text
@a3334 1
      set_gdbarch_frame_chain_valid (gdbarch, file_frame_chain_valid);
a3344 1
      set_gdbarch_frame_chain_valid (gdbarch, file_frame_chain_valid);
a3354 1
      set_gdbarch_frame_chain_valid (gdbarch, func_frame_chain_valid);
a3364 1
      set_gdbarch_frame_chain_valid (gdbarch, file_frame_chain_valid);
a3374 1
      set_gdbarch_frame_chain_valid (gdbarch, file_frame_chain_valid);
a3384 1
      set_gdbarch_frame_chain_valid (gdbarch, func_frame_chain_valid);
a3394 1
      set_gdbarch_frame_chain_valid (gdbarch, file_frame_chain_valid);
a3404 1
      set_gdbarch_frame_chain_valid (gdbarch, file_frame_chain_valid);
@


1.56
log
@gdb/
	* buildsym.h (processing_hp_compilation): Remove obsolete variable.
	* gdbarch.sh Remove include of "value.h" in gdbarch.h.
	(COERCE_FLOAT_TO_DOUBLE): Remove.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* Makefile.in: Remove value_h from gdbarch_h.
	* valops.c (coerce_float_to_double): New variable.
	(default_coerce_float_to_double): Remove.
	(standard_coerce_float_to_double): Remove.
	(value_arg_coerce): Use coerce_float_to_double.
	(_initialize_valops): Add "set coerce-float-to-double".
	* value.h (default_coerce_float_to_double): Remove prototype.
	(standard_coerce_float_to_double): Remove prototype.

	* hpread.c (hpread_process_one_debug_symbol): Mark C++ functions as
	prototyped.
	* mdebugread.c (parse_symbol): Likewise.
	* stabsread.c (define_symbol): Mark all functions as prototyped.

	* hppa-tdep.c (hppa_coerce_float_to_double): Remove.
	* alpha-tdep.c (alpha_gdbarch_init): Remove call to
	set_gdbarch_coerce_float_to_double.
	* arm-tdep.c (arm_gdbarch_init): Likewise.
	* frv-tdep.c (frv_gdbarch_init): Likewise.
	* h8300-tdep.c (h8300_gdbarch_init): Likewise (commented out).
	* i386-sol2-tdep.c (i386_sol2_init_abi): Likewise.
	* mips-tdep.c (mips_gdbarch_init): Likewise.
	(mips_coerce_float_to_double): Remove.
	* rs6000-tdep.c (rs6000_gdbarch_init): Likewise.
	(rs6000_coerce_float_to_double): Remove.
	* s390-tdep.c (s390_gdbarch_init): Likewise.
	* sh-tdep.c (sh_gdbarch_init): Likewise.
	(sh_coerce_float_to_double): Remove.
	* sparc-tdep.c (sparc_gdbarch_init): Likewise.
	(sparc_coerce_float_to_double): Remove.
	* v850-tdep.c (v850_gdbarch_init): Likewise.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Likewise.
	* config/m32r/tm-m32r.h (COERCE_FLOAT_TO_DOUBLE): Remove.
	* config/pa/tm-hppa.h: (COERCE_FLOAT_TO_DOUBLE): Remove.
	(hppa_coerce_float_to_double): Remove prototype.
	* config/sparc/tm-sparc.h (COERCE_FLOAT_TO_DOUBLE): Remove.
doc/
	* gdb.texinfo (Controlling GDB): Add ABI section.  Document
	"set coerce-float-to-double".
	* gdbint.texinfo (COERCE_FLOAT_TO_DOUBLE): Remove documentation.
testsuite/
	* gdb.base/callfuncs.exp: Don't XFAIL unprototyped functions for
	stabs.
	* gdb.base/completion.exp: Allow marker1(void) as well as marker1().
	* gdb.base/whatis.exp: Always allow (void) after function names.
@
text
@a113 2

    enum gdb_osabi osabi;
a3069 1
  enum gdb_osabi osabi = GDB_OSABI_UNKNOWN;
d3095 2
a3096 1
  if (info.abfd != NULL)
d3098 3
a3100 7
      osabi = gdbarch_lookup_osabi (info.abfd);
      if (osabi == GDB_OSABI_UNKNOWN)
	{
	  /* If it's an ELF file, assume it's Solaris.  */
	  if (bfd_get_flavour (info.abfd) == bfd_target_elf_flavour)
	    osabi = GDB_OSABI_SOLARIS;
	}
d3104 3
a3106 9
  for (arches = gdbarch_list_lookup_by_info (arches, &info);
       arches != NULL;
       arches = gdbarch_list_lookup_by_info (arches->next, &info))
    {
      /* Make sure the ABI selection matches.  */
      tdep = gdbarch_tdep (arches->gdbarch);
      if (tdep && tdep->osabi == osabi)
	return arches->gdbarch;
    }
a3115 2
  tdep->osabi = osabi;

d3424 1
a3424 1
  gdbarch_init_osabi (info, gdbarch, osabi);
d3437 16
a3452 2
  fprintf_unfiltered (file, "sparc_dump_tdep: OS ABI = %s\n",
		      gdbarch_osabi_name (tdep->osabi));
@


1.55
log
@2003-01-03  Andrew Cagney  <cagney@@redhat.com>

	* alpha-tdep.c: Use deprecated_update_frame_base_hack.
	* avr-tdep.c, cris-tdep.c: Ditto.
	* mcore-tdep.c, mips-tdep.c, mn10200-tdep.c: Ditto.
	* sh-tdep.c, sparc-tdep.c, v850-tdep.c: Ditto.
@
text
@d4 1
a4 1
   1996, 1997, 1998, 1999, 2000, 2001, 2002 Free Software Foundation,
a3009 8
/* Coerce float to double: a no-op.  */

static int
sparc_coerce_float_to_double (struct type *formal, struct type *actual)
{
  return 1;
}

a3132 2
  set_gdbarch_coerce_float_to_double (gdbarch, 
				      sparc_coerce_float_to_double);
@


1.54
log
@2003-01-02  Andrew Cagney  <ac131313@@redhat.com>

	* arm-tdep.c: Use get_frame_pc and deprecated_update_frame_pc_hack
	frame accessor methods.
	* alpha-tdep.c, avr-tdep.c, cris-tdep.c, d10v-tdep.c: Ditto.
	* dwarf2cfi.c, h8300-tdep.c, i386-tdep.c, ia64-tdep.c: Ditto.
	* m68hc11-tdep.c, m68k-tdep.c, mcore-tdep.c, mips-tdep.c: Ditto.
	* mn10200-tdep.c, mn10300-tdep.c, ns32k-tdep.c: Ditto.
	* s390-tdep.c, sh-tdep.c, sparc-tdep.c, v850-tdep.c: Ditto.
	* vax-tdep.c, x86-64-linux-tdep.c, xstormy16-tdep.c: Ditto.
	* z8k-tdep.c: Ditto.
@
text
@d323 1
a323 1
	  fi->frame = get_frame_base (fi->next);
d330 1
a330 1
	  fi->frame = extract_address (buf, REGISTER_RAW_SIZE (FP_REGNUM));
d333 1
a333 1
	    fi->frame += 2047;
d371 1
a371 1
	      fi->frame = extract_address (buf, REGISTER_RAW_SIZE (I7_REGNUM));
d374 1
a374 1
		fi->frame += 2047;
d416 1
a416 1
		  fi->frame = read_register (SP_REGNUM);
d424 1
a424 1
      fi->frame = fi->next->frame;
@


1.53
log
@2002-12-11  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (deprecated_get_frame_saved_regs): Rename
	get_frame_saved_regs.
	* frame.h (deprecated_get_frame_saved_regs): Update declaration.
	* sparc-tdep.c: Update.
	* hppa-tdep.c: Update.
	* h8500-tdep.c: Update.
@
text
@d341 1
a341 1
  if (find_pc_partial_function (fi->pc, &name, &prologue_start, &prologue_end))
d402 1
a402 1
	    prologue_end = fi->pc;
d405 1
a405 1
	  if (fi->pc < prologue_end)
d407 1
a407 1
	      for (addr = prologue_start; addr < fi->pc; addr += 4)
d413 1
a413 1
	      if (addr >= fi->pc)
d425 1
a425 1
      fi->pc = fi->next->pc;
d472 1
a472 1
      find_pc_partial_function (frame->pc, &name,
d538 1
a538 1
  frame->pc = FRAME_SAVED_PC (frame);
d838 1
a838 1
	  store_address (raw_buffer, REGISTER_RAW_SIZE (regnum), frame->pc);
d849 1
a849 1
      if (frame1->pc >= (frame1->extra_info->bottom ? 
d851 1
a851 1
	  && frame1->pc <= get_frame_base (frame1))
d907 1
a907 1
	      find_pc_partial_function (frame1->pc, NULL, &func_start, NULL);
d1123 1
a1123 1
  if (fi->pc >= (fi->extra_info->bottom ? 
d1125 1
a1125 1
      && fi->pc <= get_frame_base (fi))
d1166 1
a1166 1
      find_pc_partial_function (fi->pc, NULL, &func_start, NULL);
@


1.52
log
@2002-12-01  Andrew Cagney  <ac131313@@redhat.com>

	* gdbarch.sh (DEPRECATED_PC_IN_CALL_DUMMY): Rename
	PC_IN_CALL_DUMMY.  Change to predicate.  Always allow call.
	* gdbarch.h, gdbarch.c: Re-generate.
	* config/sparc/tm-sparc.h, config/sparc/tm-sp64.h: Update.
	* config/mn10200/tm-mn10200.h, config/h8500/tm-h8500.h: Update.
	* config/pa/tm-hppa.h, frame.h: Update.
	* x86-64-tdep.c, vax-tdep.c, sparc-tdep.c: Update.
	* s390-tdep.c, ns32k-tdep.c, mn10300-tdep.c: Update.
	* m68k-tdep.c, i386-tdep.c, frv-tdep.c: Update.
	* cris-tdep.c, alpha-tdep.c: Update.
	* frame.c (set_unwind_by_pc, create_new_frame): Use either
	DEPRECATED_PC_IN_CALL_DUMMY or pc_in_dummy_frame.
	(get_prev_frame): Ditto.

Index: doc/ChangeLog
2002-12-01  Andrew Cagney  <ac131313@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	PC_IN_CALL_DUMMY.
@
text
@d1213 6
a1218 5
   Note that the values stored in fsr by get_frame_saved_regs are *in
   the context of the called frame*.  What this means is that the i
   regs of fsr must be restored into the o regs of the (calling) frame that
   we pop into.  We don't care about the output regs of the calling frame,
   since unless it's a dummy frame, it won't have any output regs in it.
@


1.51
log
@2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* stack.c (selected_frame, select_frame): Move from here ...
	* frame.c (selected_frame, select_frame): ... to here.  Include
	"language.h".
	* Makefile.in (frame.o): Update dependencies.
	* frame.c (get_selected_frame): New function.
	* frame.h (get_selected_frame): Declare.
	(deprecated_selected_frame): Rename selected_frame.
	* ada-lang.c, ada-tasks.c, breakpoint.c, corelow.c: Update.
	* eval.c, f-valprint.c, findvar.c, frame.c, frame.h: Update.
	* h8300-tdep.c, h8500-tdep.c, hppa-tdep.c, infcmd.c: Update.
	* inflow.c, infrun.c, macroscope.c, mips-tdep.c: Update.
	* mn10300-tdep.c, ocd.c, regcache.h, remote-e7000.c: Update.
	* remote-mips.c, remote-rdp.c, sh-tdep.c, sparc-tdep.c: Update.
	* stack.c, thread.c, tracepoint.c, valops.c, varobj.c: Update.
	* z8k-tdep.c, cli/cli-cmds.c: Update.

Index: mi/ChangeLog
2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* mi/mi-cmd-stack.c, mi/mi-main.c: Update to use
	deprecated_selected_frame.

Index: tui/ChangeLog
2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* tui/tui-hooks.c: Update to use deprecated_selected_frame.
	* tui/tui.c, tui/tuiDisassem.c, tui/tuiRegs.c: Ditto.
	* tui/tuiSource.c, tui/tuiSourceWin.c, tui/tuiWin.c: Ditto.
@
text
@d3200 1
a3200 1
      set_gdbarch_pc_in_call_dummy (gdbarch, deprecated_pc_in_call_dummy_on_stack);
d3251 1
a3251 1
      set_gdbarch_pc_in_call_dummy (gdbarch, deprecated_pc_in_call_dummy_at_entry_point);
d3298 1
a3298 1
      set_gdbarch_pc_in_call_dummy (gdbarch, deprecated_pc_in_call_dummy_on_stack);
d3306 1
a3306 1
      set_gdbarch_pc_in_call_dummy (gdbarch, deprecated_pc_in_call_dummy_at_entry_point);
@


1.50
log
@2002-11-28  Andrew Cagney  <ac131313@@redhat.com>

	* gdbarch.sh (DEPRECATED_USE_GENERIC_DUMMY_FRAMES): Rename
	USE_GENERIC_DUMMY_FRAMES.
	* gdbarch.h, gdbarch.c: Regenerate.
	* valops.c, frame.c: Update.
	* config/z8k/tm-z8k.h, config/mn10200/tm-mn10200.h: Update.
	* config/m32r/tm-m32r.h, config/h8500/tm-h8500.h: Update.
	* config/pa/tm-hppa.h, blockframe.c: Update.
	* vax-tdep.c, sparc-tdep.c, ns32k-tdep.c: Ditto.
	* m68k-tdep.c, alpha-tdep.c: Ditto.

	* arm-tdep.c: Eliminate USE_GENERIC_DUMMY_FRAMES as always 1.
	* mips-tdep.c: Ditto.

Index: doc/ChangeLog
2002-11-28  Andrew Cagney  <ac131313@@redhat.com>

	* gdbint.texinfo (Host Definition): Delete documentation on
	USE_GENERIC_DUMMY_FRAMES.
@
text
@d819 1
a819 1
      if (selected_frame == NULL)
d822 1
a822 1
      frame = get_prev_frame (selected_frame);
d1874 2
a1875 2
      if (frame_register_read (selected_frame, regno, value)
	  && frame_register_read (selected_frame, regno + 1, value + 4))
d1883 2
a1884 2
	  if (frame_register_read (selected_frame, regno + 2, value + 8)
	      && frame_register_read (selected_frame, regno + 3, value + 12))
d1903 2
a1904 2
      if (frame_register_read (selected_frame, regno, value)
	  && frame_register_read (selected_frame, regno + 1, value + 8))
d2153 1
a2153 1
  sparc_print_registers_info (current_gdbarch, gdb_stdout, selected_frame,
d2169 2
a2170 2
  sparclet_print_registers_info (current_gdbarch, gdb_stdout, selected_frame,
				 regnum, all);
@


1.49
log
@2002-11-27  Andrew Cagney  <ac131313@@redhat.com>

	* gdbarch.sh (CALL_DUMMY_LOCATION): Default to AT_ENTRY_POINT.
	(USE_GENERIC_DUMMY_FRAMES): Default to true.
	(PC_IN_CALL_DUMMY): Default to generic_pc_in_call_dummy.
	* gdbarch.c, gdbarch.h: Re-generate.
	* inferior.h (USE_GENERIC_DUMMY_FRAMES): Delete macro definition.
	(CALL_DUMMY_LOCATION): Delete macro definition.
	(PC_IN_CALL_DUMMY): Delete macro definitions.

	* arm-tdep.c (arm_gdbarch_init): Do not set pc_in_call_dummy,
	default is already generic_pc_in_call_dummy.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.

	* arm-tdep.c (arm_gdbarch_init): Do not set
	use_generic_dummy_frames, default is already 1.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
	* x86-64-tdep.c (x86_64_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.

	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	call_dummy_location, default is already AT_ENTRY_POINT.
	* x86-64-tdep.c (x86_64_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
@
text
@d3182 1
a3182 1
  set_gdbarch_use_generic_dummy_frames (gdbarch, 0);
@


1.48
log
@2002-11-26  Andrew Cagney  <ac131313@@redhat.com>

	* inferior.h (deprecated_pc_in_call_dummy_before_text_end): Rename
	pc_in_call_dummy_before_text_end
	(deprecated_pc_in_call_dummy_after_text_end): Rename
	pc_in_call_dummy_after_text_end.
	(deprecated_pc_in_call_dummy_on_stack): Rename
	pc_in_call_dummy_on_stack.
	(deprecated_pc_in_call_dummy_at_entry_point): Rename
	pc_in_call_dummy_at_entry_point.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_gdbarch_init): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* config/sparc/tm-sparc.h (PC_IN_CALL_DUMMY): Update.
	* blockframe.c (deprecated_pc_in_call_dummy_before_text_end)
	(deprecated_pc_in_call_dummy_after_text_end)
	(deprecated_pc_in_call_dummy_on_stack)
	(deprecated_pc_in_call_dummy_at_entry_point): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
@
text
@a3254 1
      set_gdbarch_call_dummy_location (gdbarch, AT_ENTRY_POINT);
a3309 1
      set_gdbarch_call_dummy_location (gdbarch, AT_ENTRY_POINT);
@


1.47
log
@2002-11-19  Andrew Cagney  <ac131313@@redhat.com>

	* frame.h (FRAME_FP): Delete macro.
	(get_frame_base): New function declaration.
	* frame.c (get_frame_base): New function.
	(get_frame_id): Use ->frame.
	(frame_find_by_id): Rewrite to use get_frame_id.
	* blockframe.c: Use get_frame_base instead of FRAME_FP.
	* cris-tdep.c, d10v-tdep.c, findvar.c, h8500-tdep.c: Ditto.
	* hppa-tdep.c, i386-tdep.c, infcmd.c, infrun.c: Ditto.
	* m68hc11-tdep.c, m68k-tdep.c, mcore-tdep.c, mips-tdep.c: Ditto.
	* mn10200-tdep.c, mn10300-tdep.c, rs6000-tdep.c: Ditto.
	* sh-tdep.c, sparc-tdep.c, stack.c, tracepoint.c: Ditto.
	* v850-tdep.c, valops.c, z8k-tdep.c: Ditto.
@
text
@d3200 1
a3200 1
      set_gdbarch_pc_in_call_dummy (gdbarch, pc_in_call_dummy_on_stack);
d3251 1
a3251 1
      set_gdbarch_pc_in_call_dummy (gdbarch, pc_in_call_dummy_at_entry_point);
d3299 1
a3299 1
      set_gdbarch_pc_in_call_dummy (gdbarch, pc_in_call_dummy_on_stack);
d3307 1
a3307 1
      set_gdbarch_pc_in_call_dummy (gdbarch, pc_in_call_dummy_at_entry_point);
@


1.46
log
@2002-11-22  Andrew Cagney  <ac131313@@redhat.com>

	* gdbarch.sh (FRAME_ARGS_ADDRESS, FRAME_LOCALS_ADDRESS): Default
	to default_frame_address.
	* gdbarch.h, gdbarch.c: Re-generate.

	* d10v-tdep.c (d10v_gdbarch_init): Do not set frame_args_address
	or frame_locals_address to default_frame_address.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_gdbarch_init): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.

	* cris-tdep.c (cris_frame_args_address): Delete function.
	(cris_frame_locals_address): Delete function.
	(cris_gdbarch_init): Do not set frame_args_address or
	frame_locals_address.
@
text
@d323 1
a323 1
	  fi->frame = FRAME_FP (fi->next);
d851 1
a851 1
	  && frame1->pc <= FRAME_FP (frame1))
d1115 1
a1115 1
  CORE_ADDR frame_addr = FRAME_FP (fi);
d1125 1
a1125 1
      && fi->pc <= FRAME_FP (fi))
d1208 1
a1208 1
  saved_regs_addr[SP_REGNUM] = FRAME_FP (fi);
@


1.45
log
@2002-11-18  Andrew Cagney  <ac131313@@redhat.com>

	* frame.h (enum frame_type): Define.
	(get_frame_type): Declare.
	(struct frame_info): Add field `type'.  Delete field
	signal_handler_caller.
	(deprecated_set_frame_signal_handler_caller): Declare.
	* frame.c (get_frame_type): New function.
	(deprecated_set_frame_type): New function.
	(create_new_frame): Set the frame's type.
	(get_prev_frame): Similar.
	* sparc-tdep.c: Use get_frame_type instead of signal_handler_caller.
	* s390-tdep.c: Ditto.
	* m68klinux-nat.c: Ditto.
	* ns32k-tdep.c: Ditto.
	* x86-64-linux-tdep.c: Ditto.
	* vax-tdep.c: Ditto.
	* rs6000-tdep.c: Ditto.
	* ppc-linux-tdep.c: Ditto.
	* i386-interix-tdep.c: Ditto.
	* mips-tdep.c: Ditto.
	* m68k-tdep.c: Ditto.
	* hppa-tdep.c: Ditto.
	* ia64-tdep.c: Ditto.
	* cris-tdep.c: Ditto.
	* arm-tdep.c: Ditto.
	* alpha-tdep.c: Ditto.
	* i386-tdep.c: Ditto.
	* stack.c: Ditto.
	* ada-lang.c: Ditto.
	* blockframe.c: Update.
	* i386-interix-tdep.c (i386_interix_back_one_frame): Use
	deprecated_set_frame_type instead of signal_handler_caller.
	* ppc-linux-tdep.c (ppc_linux_init_extra_frame_info): Ditto.
	* rs6000-tdep.c (rs6000_init_extra_frame_info): Ditto.
	* breakpoint.h: Delete FIXME suggesting get_frame_type.

Index: tui/ChangeLog
2002-11-18  Andrew Cagney  <ac131313@@redhat.com>

	* tuiStack.c (tuiShowFrameInfo): Use get_frame_type instead of
	signal_handler_caller.
@
text
@a3151 1
  set_gdbarch_frame_args_address (gdbarch, default_frame_address);
a3153 1
  set_gdbarch_frame_locals_address (gdbarch, default_frame_address);
@


1.44
log
@2002-11-14  Andrew Cagney  <ac131313@@redhat.com>

	* regcache.h (deprecated_registers): Rename registers.
	* a68v-nat.c, alpha-nat.c, arch-utils.c, core-sol2.c: Update.
	* hp300ux-nat.c, hppab-nat.c, hppah-nat.c: Update.
	* hppam3-nat.c, hpux-thread.c, i386gnu-nat.c: Update.
	* ia64-aix-nat.c, ia64-linux-nat.c, ia64-tdep.c: Update.
	* irix4-nat.c, irix5-nat.c, lynx-nat.c, m68k-tdep.c: Update.
	* m68knbsd-nat.c, mips-linux-tdep.c, mipsm3-nat.c: Update.
	* mipsv4-nat.c, ns32knbsd-nat.c, ppc-bdm.c: Update.
	* ppc-sysv-tdep.c, ptx4-nat.c, regcache.c, remote-es.c: Update.
	* remote-sds.c, remote-vx68.c, remote-vxmips.c: Update.
	* remote-vxsparc.c, rs6000-tdep.c, sol-thread.c: Update.
	* sparc-nat.c, sparc-tdep.c, sun3-nat.c, symm-nat.c: Update.
	* v850ice.c: Update.
@
text
@d317 1
a317 1
	  && (fi->next->next->signal_handler_caller
d454 1
a454 1
  if (frame->signal_handler_caller)
d490 1
a490 1
	    (frame->next->signal_handler_caller ||
@


1.43
log
@2002-11-13  Andrew Cagney  <cagney@@redhat.com>

	* regcache.h (deprecated_read_register_bytes): Rename
	read_register_bytes.
	(deprecated_write_register_bytes): Rename write_register_bytes.
	* alpha-tdep.c, arm-tdep.c, cris-tdep.c, d10v-tdep.c: Update.
	* dwarf2cfi.c, frv-tdep.c, hppa-tdep.c, ia64-tdep.c: Update.
	* m68k-tdep.c, mcore-tdep.c, mips-tdep.c, mn10300-tdep.c: Update.
	* ns32k-tdep.c, regcache.c, remote-sds.c, remote-vx.c: Update.
	* remote.c, rs6000-tdep.c, s390-tdep.c, sh-tdep.c: Update.
	* sparc-tdep.c, v850-tdep.c, vax-tdep.c, x86-64-tdep.c: Update.
	* xstormy16-tdep.c, z8k-tdep.c, config/nm-gnu.h: Update.
	* config/nm-m3.h, config/h8500/tm-h8500.h: Update.
	* config/i386/nm-ptx4.h, config/i386/nm-symmetry.h: Update.
	* config/m32r/tm-m32r.h, config/m68k/nm-sun3.h: Update.
	* config/m68k/tm-delta68.h, config/m68k/tm-linux.h: Update.
	* config/mn10200/tm-mn10200.h, config/pa/tm-hppa64.h: Update.
	* config/sparc/nm-nbsd.h, config/sparc/nm-sun4os4.h: Update.
	* config/sparc/nm-sun4sol2.h, config/sparc/tm-sparclet.h: Update.

2002-11-13  Andrew Cagney  <ac131313@@redhat.com>

	* mi-main.c (mi_cmd_data_write_register_values): Use
	deprecated_write_register_bytes instead of write_register_bytes.
@
text
@d1732 1
a1732 1
	  from = (char *) &registers[REGISTER_BYTE (regi)];
d1741 1
a1741 1
	from = (char *)&registers[REGISTER_BYTE (FPS_REGNUM)];
@


1.42
log
@2002-11-10  Andrew Cagney  <ac131313@@redhat.com>

	* breakpoint.h (deprecated_frame_in_dummy): Rename frame_in_dummy.
	* stack.c (print_frame_info_base): Update.
	(print_frame_info_base, frame_info): Update.
	* sparc-tdep.c (sparc_init_extra_frame_info): Update.
	(sparc_frame_saved_pc): Update.
	* ada-lang.c (find_printable_frame): Update.
	* breakpoint.c (deprecated_frame_in_dummy): Update.
@
text
@d993 6
a998 5
      read_register_bytes (REGISTER_BYTE (PC_REGNUM), &register_temp[0],
			   REGISTER_RAW_SIZE (PC_REGNUM) * 7);
      read_register_bytes (REGISTER_BYTE (PSTATE_REGNUM), 
			   &register_temp[7 * SPARC_INTREG_SIZE],
			   REGISTER_RAW_SIZE (PSTATE_REGNUM));
d1004 3
a1006 2
      read_register_bytes (REGISTER_BYTE (Y_REGNUM), &register_temp[0],
			   REGISTER_RAW_SIZE (Y_REGNUM) * 8);
d1009 7
a1015 7
  read_register_bytes (REGISTER_BYTE (O0_REGNUM),
		       &register_temp[8 * SPARC_INTREG_SIZE],
		       SPARC_INTREG_SIZE * 8);

  read_register_bytes (REGISTER_BYTE (G0_REGNUM),
		       &register_temp[16 * SPARC_INTREG_SIZE],
		       SPARC_INTREG_SIZE * 8);
d1018 3
a1020 3
    read_register_bytes (REGISTER_BYTE (FP0_REGNUM),
			 &register_temp[24 * SPARC_INTREG_SIZE],
			 FP_REGISTER_BYTES);
d1242 2
a1243 2
	  write_register_bytes (REGISTER_BYTE (FP0_REGNUM),
				raw_buffer, FP_REGISTER_BYTES);
d1262 2
a1263 2
      write_register_bytes (REGISTER_BYTE (G1_REGNUM), raw_buffer,
			    7 * SPARC_INTREG_SIZE);
d1315 2
a1316 2
      write_register_bytes (REGISTER_BYTE (O0_REGNUM), raw_buffer,
			    SPARC_INTREG_SIZE * 8);
d1318 2
a1319 2
      write_register_bytes (REGISTER_BYTE (L0_REGNUM), reg_temp,
			    SPARC_INTREG_SIZE * 16);
d2303 2
a2304 1
    write_register_bytes (REGISTER_BYTE (regno), valbuf, TYPE_LENGTH (type));
d2311 2
a2312 2
  write_register_bytes (REGISTER_BYTE (O0_REGNUM), valbuf,
			TYPE_LENGTH (type));
d2573 3
a2575 3
	      write_register_bytes (REGISTER_BYTE (fpreg),
				    VALUE_CONTENTS (args[i]),
				    len);
@


1.41
log
@2002-11-05  Andrew Cagney  <ac131313@@redhat.com>

	* sparc-tdep.c (sparc_print_register_hook): Make static.
	(sparc_print_registers_info): New function.
	(sparc_do_registers_info): New function.
	(sparclet_print_registers_info): New function.
	(sparclet_do_registers_info): New function.
	(do_sparc_print_registers_info): New function.
	(sparc_print_registers): New static function, clone of infcmd.c's
	default_print_registers_info.
	* config/sparc/tm-sparclet.h (PRINT_REGISTER_HOOK): Delete macro.
	(sparclet_do_registers_info): Declare.
	(DEPRECATED_DO_REGISTERS_INFO): Re-define.
	* config/sparc/tm-sparc.h (DEPRECATED_DO_REGISTERS_INFO):
	Re-define.
	(sparc_do_registers_info): Declare.
	(PRINT_REGISTER_HOOK): Delete macro.
	(sparc_print_register_hook): Delete declaration.
@
text
@d318 1
a318 1
	      || frame_in_dummy (fi->next->next))
d491 1
a491 1
	     frame_in_dummy (frame->next)) &&
@


1.40
log
@2002-11-02  Andrew Cagney  <cagney@@redhat.com>

	* regcache.h (deprecated_read_register_gen): Rename
	read_register_gen.
	(deprecated_write_register_gen): Rename write_register_gen.
	* i387-tdep.c: Update.
	* x86-64-linux-nat.c: Update
	* wince.c: Update.
	* thread-db.c: Update.
	* win32-nat.c: Update.
	* mips-tdep.c: Update.
	* d10v-tdep.c: Update.
	* cris-tdep.c: Update.
	* remote-sim.c: Update.
	* remote-rdi.c: Update.
	* remote-rdp.c: Update.
	* frame.c: Update.
	* target.c: Update.
	* blockframe.c: Update.
	* x86-64-tdep.c: Update.
	* xstormy16-tdep.c: Update.
	* sh-tdep.c: Update.
	* s390-tdep.c: Update.
	* rs6000-tdep.c: Update.
	* sparc-tdep.c: Update.
	* i386-tdep.c: Update.
	* dwarf2cfi.c: Update.
	* regcache.c: Update.
@
text
@d1861 1
a1861 1
void
d2031 140
@


1.39
log
@Index: ChangeLog
===================================================================
RCS file: /cvs/src/src/gdb/ChangeLog,v
retrieving revision 1.3144
diff -u -r1.3144 ChangeLog
--- ChangeLog	23 Aug 2002 23:05:38 -0000	1.3144
+++ ChangeLog	23 Aug 2002 23:14:45 -0000
@@@@ -1,3 +1,53 @@@@
2002-08-23  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (STORE_RETURN_VALUE): Add regcache parameter.
	(DEPRECATED_STORE_RETURN_VALUE): New method.
	(EXTRACT_RETURN_VALUE): Make buffer parameter a void pointer.
	* gdbarch.h, gdbarch.c: Re-generate.

	* values.c (set_return_value): Pass current_regcache to
	STORE_RETURN_VALUE.
	* arch-utils.h (legacy_store_return_value): Declare.
	* arch-utils.c (legacy_store_return_value): New function.
	(legacy_extract_return_value): Update parameters.

	* config/pa/tm-hppa.h (DEPRECATED_STORE_RETURN_VALUE): Rename
	STORE_RETURN_VALUE.
	* config/pa/tm-hppa64.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/sparc/tm-sparc.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/z8k/tm-z8k.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/sparc/tm-sparclet.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/mn10200/tm-mn10200.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/m68k/tm-linux.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/m68k/tm-delta68.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/m32r/tm-m32r.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/h8500/tm-h8500.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/h8300/tm-h8300.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.

	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* i386-tdep.c (i386_extract_return_value): Update.
	* arch-utils.c (legacy_extract_return_value): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* d10v-tdep.c (d10v_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.

Index: doc/ChangeLog
2002-08-21  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Update
	STORE_RETURN_VALUE, mention regcache.
@
text
@d959 1
a959 1
	read_register_gen (regnum, raw_buffer);
d1248 1
a1248 1
	      write_register_gen (FPS_REGNUM, raw_buffer);
d1253 1
a1253 1
	      write_register_gen (CPS_REGNUM, raw_buffer);
d1612 1
a1612 1
      read_register_gen (regi, (char *) (regp + regi) + offset);
d1615 1
a1615 1
    read_register_gen (PC_REGNUM, (char *) (regp + R_PC) + offset);
d1618 1
a1618 1
    read_register_gen (NPC_REGNUM, (char *) (regp + R_nPC) + offset);
d1621 1
a1621 1
    read_register_gen (Y_REGNUM, (char *) (regp + R_Y) + offset);
d1627 1
a1627 1
	read_register_gen (CCR_REGNUM, ((char *) (regp + R_CCR)) + offset);
d1631 1
a1631 1
	read_register_gen (FPRS_REGNUM, ((char *) (regp + R_FPRS)) + offset);
d1635 1
a1635 1
	read_register_gen (ASI_REGNUM, ((char *) (regp + R_ASI)) + offset);
d1642 1
a1642 1
	read_register_gen (PS_REGNUM, ((char *) (regp + R_PS)) + offset);
d1658 1
a1658 1
	read_register_gen (WIM_REGNUM, ((char *) (regp + R_WIM)) + offset);
d1661 1
a1661 1
	read_register_gen (WIM_REGNUM, NULL);
d1666 1
a1666 1
	read_register_gen (TBR_REGNUM, ((char *) (regp + R_TBR)) + offset);
d1669 1
a1669 1
	read_register_gen (TBR_REGNUM, NULL);
d2102 1
a2102 1
	write_register_gen (O0_REGNUM + oregnum, m_arg->contents + j);
d2158 1
a2158 1
      write_register_gen (regno, buffer);
d2443 1
a2443 1
	      write_register_gen (oreg, VALUE_CONTENTS (copyarg) + j);
@


1.39.10.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d4 1
a4 1
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation,
a35 3
#include "dis-asm.h"

#include "sparc-tdep.h"
a43 1
#include "gdb_assert.h"
d51 4
a54 1
#define SPARC_HAS_FPU 1
d64 40
d106 1
d114 2
d126 3
d138 6
a143 7
const unsigned char *
sparc_breakpoint_from_pc (CORE_ADDR *pc, int *len)
{
  static const char breakpoint[] = {0x91, 0xd0, 0x20, 0x01};
  (*len) = sizeof (breakpoint);
  return breakpoint;
}
d199 1
a199 1
   step-breakpoint was set, not necessary the current value of DEPRECATED_NPC_REGNUM.  */
d226 1
a226 1
      next_pc = read_register (DEPRECATED_NPC_REGNUM);
d297 2
a298 1
  frame_extra_info_zalloc (fi, sizeof (struct frame_extra_info));
d301 8
a308 10
  get_frame_extra_info (fi)->bottom =
    (get_next_frame (fi)
     ? (get_frame_base (fi) == get_frame_base (get_next_frame (fi))
	? get_frame_extra_info (get_next_frame (fi))->bottom
	: get_frame_base (get_next_frame (fi)))
     : read_sp ());

  /* If fi->next is NULL, then we already set ->frame by passing
     deprecated_read_fp() to create_new_frame.  */
  if (get_next_frame (fi))
d310 3
a312 1
      char buf[MAX_REGISTER_SIZE];
d316 4
a319 4
      if (get_next_frame (get_next_frame (fi)) != NULL
	  && ((get_frame_type (get_next_frame (get_next_frame (fi))) == SIGTRAMP_FRAME)
	      || deprecated_frame_in_dummy (get_next_frame (get_next_frame (fi))))
	  && frameless_look_for_prologue (get_next_frame (fi)))
d323 2
a324 3
	  deprecated_update_frame_base_hack (fi, get_frame_base (get_next_frame (fi)));
	  get_frame_extra_info (fi)->bottom =
	    get_frame_extra_info (get_next_frame (fi))->bottom;
d329 5
a333 5
	  ULONGEST tmp;
	  tmp = get_frame_register_unsigned (fi, DEPRECATED_FP_REGNUM);
	  deprecated_update_frame_base_hack (fi, tmp);
	  if (GDB_TARGET_IS_SPARC64 && (get_frame_base (fi) & 1))
	    deprecated_update_frame_base_hack (fi, get_frame_base (fi) + 2047);
d339 3
a341 3
  get_frame_extra_info (fi)->flat = 0;
  get_frame_extra_info (fi)->in_prologue = 0;
  if (find_pc_partial_function (get_frame_pc (fi), &name, &prologue_start, &prologue_end))
d360 3
a362 1
	      char buf[MAX_REGISTER_SIZE];
d365 1
a365 1
	      get_frame_extra_info (fi)->flat = 1;
d367 1
a367 1
	      get_frame_extra_info (fi)->sp_offset = offset;
d370 2
a371 5
	      {
		ULONGEST tmp;
		tmp = get_frame_register_unsigned (fi, I7_REGNUM);
		deprecated_update_frame_base_hack (fi, tmp);
	      }
d373 2
a374 2
	      if (GDB_TARGET_IS_SPARC64 && (get_frame_base (fi) & 1))
		deprecated_update_frame_base_hack (fi, get_frame_base (fi) + 2047);
d377 2
a378 2
	      get_frame_extra_info (fi)->fp_addr = 
		get_frame_base (fi) + get_frame_extra_info (fi)->sp_offset + X_SIMM13 (insn);
d381 1
a381 1
	      get_frame_extra_info (fi)->pc_addr = 0;
d387 2
a388 2
		get_frame_extra_info (fi)->pc_addr = 
		  get_frame_base (fi) + get_frame_extra_info (fi)->sp_offset + X_SIMM13 (insn);
d402 1
a402 1
	    prologue_end = get_frame_pc (fi);
d405 1
a405 1
	  if (get_frame_pc (fi) < prologue_end)
d407 1
a407 1
	      for (addr = prologue_start; addr < get_frame_pc (fi); addr += 4)
d413 1
a413 1
	      if (addr >= get_frame_pc (fi))
d415 2
a416 2
		  get_frame_extra_info (fi)->in_prologue = 1;
		  deprecated_update_frame_base_hack (fi, read_register (SP_REGNUM));
d421 1
a421 1
  if (get_next_frame (fi) && get_frame_base (fi) == 0)
d424 2
a425 2
      deprecated_update_frame_base_hack (fi, get_frame_base (get_next_frame (fi)));
      deprecated_update_frame_pc_hack (fi, get_frame_pc (get_next_frame (fi)));
d432 5
a436 15
  /* Value that will cause DEPRECATED_FRAME_CHAIN_VALID to not worry
     about the chain value.  If it really is zero, we detect it later
     in sparc_init_prev_frame.
     
     Note: kevinb/2003-02-18: The constant 1 used to be returned here,
     but, after some recent changes to legacy_frame_chain_valid(),
     this value is no longer suitable for causing
     legacy_frame_chain_valid() to "not worry about the chain value."
     The constant ~0 (i.e, 0xfff...) causes the failing test in
     legacy_frame_chain_valid() to succeed thus preserving the "not
     worry" property.  I had considered using something like
     ``get_frame_base (frame) + 1''.  However, I think a constant
     value is better, because when debugging this problem, I knew that
     something funny was going on as soon as I saw the constant 1
     being used as the frame chain elsewhere in GDB.  */
d438 5
a442 1
  return ~ (CORE_ADDR) 0;
d450 1
a450 1
  char buf[MAX_REGISTER_SIZE];
d453 2
a454 1
  if ((get_frame_type (frame) == SIGTRAMP_FRAME))
d472 1
a472 1
      find_pc_partial_function (get_frame_pc (frame), &name,
d474 1
a474 1
      if (name && DEPRECATED_STREQ (name, "ucbsigvechandler"))
d478 3
a480 5
      {
	ULONGEST tmp;
	tmp = get_frame_register_unsigned (frame, O0_REGNUM + 2);
	sigcontext_addr = tmp;
      }
d486 1
a486 1
      return extract_unsigned_integer (scbuf, sizeof (scbuf));
d488 4
a491 4
  else if (get_frame_extra_info (frame)->in_prologue ||
	   (get_next_frame (frame) != NULL &&
	    ((get_frame_type (get_next_frame (frame)) == SIGTRAMP_FRAME) ||
	     deprecated_frame_in_dummy (get_next_frame (frame))) &&
d496 3
a498 3
      ULONGEST tmp;
      tmp = get_frame_register_unsigned (frame, O7_REGNUM);
      return PC_ADJUST (tmp);
d500 2
a501 2
  if (get_frame_extra_info (frame)->flat)
    addr = get_frame_extra_info (frame)->pc_addr;
d503 1
a503 1
    addr = get_frame_extra_info (frame)->bottom + FRAME_SAVED_I0 +
d512 1
a512 1
  return PC_ADJUST (extract_unsigned_integer (buf, SPARC_INTREG_SIZE));
d537 2
a538 2
  get_frame_extra_info (frame)->bottom = argv[1];
  deprecated_update_frame_pc_hack (frame, DEPRECATED_FRAME_SAVED_PC (frame));
d679 1
a679 1
	      get_frame_base (fi) + get_frame_extra_info (fi)->sp_offset + X_SIMM13 (insn);
d819 1
a819 1
      if (deprecated_selected_frame == NULL)
d822 1
a822 1
      frame = get_prev_frame (deprecated_selected_frame);
d828 1
a828 1
  frame1 = get_next_frame (frame);
d838 1
a838 1
	  store_unsigned_integer (raw_buffer, DEPRECATED_REGISTER_RAW_SIZE (regnum), get_frame_pc (frame));
d849 3
a851 4
      if (get_frame_pc (frame1) >= (get_frame_extra_info (frame1)->bottom
				    ? get_frame_extra_info (frame1)->bottom
				    : read_sp ())
	  && get_frame_pc (frame1) <= get_frame_base (frame1))
d857 1
a857 1
	    addr = get_frame_base (frame1) + (regnum - G0_REGNUM) * SPARC_INTREG_SIZE
d865 1
a865 1
	    addr = (get_frame_extra_info (get_prev_frame (frame1))->bottom
d874 1
a874 1
	    addr = (get_frame_extra_info (get_prev_frame (frame1))->bottom
d878 1
a878 1
	    addr = get_frame_base (frame1) + (regnum - O0_REGNUM) * SPARC_INTREG_SIZE
d882 1
a882 1
	    addr = get_frame_base (frame1) + (regnum - FP0_REGNUM) * 4
d886 1
a886 1
	    addr = get_frame_base (frame1) + 32 * 4 + (regnum - FP0_REGNUM - 32) * 8
d889 1
a889 1
	    addr = get_frame_base (frame1) + (regnum - Y_REGNUM) * SPARC_INTREG_SIZE
d892 1
a892 1
      else if (get_frame_extra_info (frame1)->flat)
d896 1
a896 1
	    addr = get_frame_extra_info (frame1)->pc_addr;
d898 1
a898 1
	    addr = get_frame_extra_info (frame1)->fp_addr;
d907 1
a907 1
	      find_pc_partial_function (get_frame_pc (frame1), NULL, &func_start, NULL);
d916 1
a916 1
	    addr = (get_frame_extra_info (get_prev_frame (frame1))->bottom
d920 1
a920 1
	    addr = (get_frame_extra_info (get_prev_frame (frame1))->bottom
d926 2
a927 3
	      int realnum;
	      frame_register (frame1, (regnum - O0_REGNUM + I0_REGNUM),
			      optimized, lval, addrp, &realnum, raw_buffer);
d933 1
a933 1
      frame1 = get_next_frame (frame1);
d944 1
a944 1
	      store_unsigned_integer (raw_buffer, DEPRECATED_REGISTER_RAW_SIZE (regnum), addr);
d951 1
a951 1
	read_memory (addr, raw_buffer, DEPRECATED_REGISTER_RAW_SIZE (regnum));
d957 1
a957 1
      addr = DEPRECATED_REGISTER_BYTE (regnum);
d959 1
a959 1
	deprecated_read_register_gen (regnum, raw_buffer);
d993 5
a997 6
      deprecated_read_register_bytes (DEPRECATED_REGISTER_BYTE (PC_REGNUM),
				      &register_temp[0],
				      DEPRECATED_REGISTER_RAW_SIZE (PC_REGNUM) * 7);
      deprecated_read_register_bytes (DEPRECATED_REGISTER_BYTE (PSTATE_REGNUM), 
				      &register_temp[7 * SPARC_INTREG_SIZE],
				      DEPRECATED_REGISTER_RAW_SIZE (PSTATE_REGNUM));
d1003 2
a1004 3
      deprecated_read_register_bytes (DEPRECATED_REGISTER_BYTE (Y_REGNUM),
				      &register_temp[0],
				      DEPRECATED_REGISTER_RAW_SIZE (Y_REGNUM) * 8);
d1007 7
a1013 7
  deprecated_read_register_bytes (DEPRECATED_REGISTER_BYTE (O0_REGNUM),
				  &register_temp[8 * SPARC_INTREG_SIZE],
				  SPARC_INTREG_SIZE * 8);

  deprecated_read_register_bytes (DEPRECATED_REGISTER_BYTE (G0_REGNUM),
				  &register_temp[16 * SPARC_INTREG_SIZE],
				  SPARC_INTREG_SIZE * 8);
d1016 3
a1018 3
    deprecated_read_register_bytes (DEPRECATED_REGISTER_BYTE (FP0_REGNUM),
				    &register_temp[24 * SPARC_INTREG_SIZE],
				    FP_REGISTER_BYTES);
d1022 1
a1022 1
  DEPRECATED_DUMMY_WRITE_SP (sp);
d1038 1
a1038 1
	  CORE_ADDR oldfp = read_register (DEPRECATED_FP_REGNUM);
d1040 1
a1040 1
	    write_register (DEPRECATED_FP_REGNUM, old_sp - 2047);
d1042 1
a1042 1
	    write_register (DEPRECATED_FP_REGNUM, old_sp);
d1047 1
a1047 1
	  write_register (DEPRECATED_FP_REGNUM, old_sp);
d1057 1
a1057 1
      write_register (G0_REGNUM + 1, read_register (DEPRECATED_FP_REGNUM));
d1069 1
a1069 1
      write_register (DEPRECATED_FP_REGNUM, old_sp);
d1078 4
a1081 4
   frames save all registers).

   NOTE: cagney/2003-03-12: Since pop_frame has been rewritten to use
   frame_unwind_register() the need for this function is questionable.
d1112 2
a1113 2
  int regnum;
  CORE_ADDR frame_addr = get_frame_base (fi);
d1115 3
a1117 1
  gdb_assert (fi != NULL);
d1121 3
a1123 4
  if (get_frame_pc (fi) >= (get_frame_extra_info (fi)->bottom
			    ? get_frame_extra_info (fi)->bottom
			    : read_sp ())
      && get_frame_pc (fi) <= get_frame_base (fi))
d1158 2
a1159 3
      frame_addr = (get_frame_extra_info (fi)->bottom
		    ? get_frame_extra_info (fi)->bottom
		    : read_sp ());
d1161 1
a1161 1
  else if (get_frame_extra_info (fi)->flat)
d1164 1
a1164 1
      find_pc_partial_function (get_frame_pc (fi), NULL, &func_start, NULL);
d1168 2
a1169 2
      saved_regs_addr[RP_REGNUM] = get_frame_extra_info (fi)->pc_addr;
      saved_regs_addr[I7_REGNUM] = get_frame_extra_info (fi)->fp_addr;
d1174 2
a1175 3
      frame_addr = (get_frame_extra_info (fi)->bottom
		    ? get_frame_extra_info (fi)->bottom
		    : read_sp ());
d1185 1
a1185 1
  if (get_next_frame (fi))
d1187 1
a1187 1
      if (get_frame_extra_info (fi)->flat)
d1189 1
a1189 1
	  saved_regs_addr[O7_REGNUM] = get_frame_extra_info (fi)->pc_addr;
d1195 2
a1196 3
	  (get_frame_extra_info (get_next_frame (fi))->bottom
	   ? get_frame_extra_info (get_next_frame (fi))->bottom
	   : read_sp ());
d1206 1
a1206 1
  saved_regs_addr[SP_REGNUM] = get_frame_base (fi);
d1211 5
a1215 6
   Note that the values stored in fsr by
   deprecated_get_frame_saved_regs are *in the context of the called
   frame*.  What this means is that the i regs of fsr must be restored
   into the o regs of the (calling) frame that we pop into.  We don't
   care about the output regs of the calling frame, since unless it's
   a dummy frame, it won't have any output regs in it.
d1226 2
a1227 2
  struct frame_info *frame = get_current_frame ();
  CORE_ADDR pc;
d1233 1
a1233 1
  raw_buffer = alloca (DEPRECATED_REGISTER_BYTES);
d1240 2
a1241 2
	  deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (FP0_REGNUM),
					   raw_buffer, FP_REGISTER_BYTES);
d1248 1
a1248 1
	      deprecated_write_register_gen (FPS_REGNUM, raw_buffer);
d1253 1
a1253 1
	      deprecated_write_register_gen (CPS_REGNUM, raw_buffer);
d1260 2
a1261 2
      deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (G1_REGNUM), raw_buffer,
				       7 * SPARC_INTREG_SIZE);
d1264 1
a1264 1
  if (get_frame_extra_info (frame)->flat)
d1287 1
a1287 1
      DEPRECATED_DUMMY_WRITE_SP (get_frame_base (frame));
d1313 2
a1314 2
      deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (O0_REGNUM), raw_buffer,
				       SPARC_INTREG_SIZE * 8);
d1316 2
a1317 2
      deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (L0_REGNUM), reg_temp,
				       SPARC_INTREG_SIZE * 16);
d1324 1
a1324 1
					   DEPRECATED_REGISTER_RAW_SIZE (PS_REGNUM)));
d1329 1
a1329 1
					 DEPRECATED_REGISTER_RAW_SIZE (Y_REGNUM)));
d1335 5
a1339 5
					   DEPRECATED_REGISTER_RAW_SIZE (PC_REGNUM)));
      if (fsr[DEPRECATED_NPC_REGNUM])
	write_register (DEPRECATED_NPC_REGNUM,
			read_memory_integer (fsr[DEPRECATED_NPC_REGNUM],
					     DEPRECATED_REGISTER_RAW_SIZE (DEPRECATED_NPC_REGNUM)));
d1341 1
a1341 1
  else if (get_frame_extra_info (frame)->flat)
d1343 1
a1343 1
      if (get_frame_extra_info (frame)->pc_addr)
d1345 2
a1346 2
			read_memory_integer (get_frame_extra_info (frame)->pc_addr,
					     DEPRECATED_REGISTER_RAW_SIZE (PC_REGNUM)));
d1352 6
a1357 3
	  ULONGEST tmp;
	  tmp = get_frame_register_unsigned (frame, O7_REGNUM);
	  pc = PC_ADJUST (tmp);
d1361 1
a1361 1
      write_register (DEPRECATED_NPC_REGNUM, pc + 4);
d1369 1
a1369 1
      write_register (DEPRECATED_NPC_REGNUM, pc + 4);
d1498 1
a1498 1
  supply_register (DEPRECATED_NPC_REGNUM, ((char *) (regp + R_nPC)) + offset);
d1612 1
a1612 1
      deprecated_read_register_gen (regi, (char *) (regp + regi) + offset);
d1615 1
a1615 1
    deprecated_read_register_gen (PC_REGNUM, (char *) (regp + R_PC) + offset);
d1617 2
a1618 2
  if ((regno == -1) || (regno == DEPRECATED_NPC_REGNUM))
    deprecated_read_register_gen (DEPRECATED_NPC_REGNUM, (char *) (regp + R_nPC) + offset);
d1621 1
a1621 1
    deprecated_read_register_gen (Y_REGNUM, (char *) (regp + R_Y) + offset);
d1627 1
a1627 1
	deprecated_read_register_gen (CCR_REGNUM, ((char *) (regp + R_CCR)) + offset);
d1631 1
a1631 1
	deprecated_read_register_gen (FPRS_REGNUM, ((char *) (regp + R_FPRS)) + offset);
d1635 1
a1635 1
	deprecated_read_register_gen (ASI_REGNUM, ((char *) (regp + R_ASI)) + offset);
d1642 1
a1642 1
	deprecated_read_register_gen (PS_REGNUM, ((char *) (regp + R_PS)) + offset);
d1658 1
a1658 1
	deprecated_read_register_gen (WIM_REGNUM, ((char *) (regp + R_WIM)) + offset);
d1661 1
a1661 1
	deprecated_read_register_gen (WIM_REGNUM, NULL);
d1666 1
a1666 1
	deprecated_read_register_gen (TBR_REGNUM, ((char *) (regp + R_TBR)) + offset);
d1669 1
a1669 1
	deprecated_read_register_gen (TBR_REGNUM, NULL);
d1681 1
a1681 1
  int regi;
d1730 1
a1730 1
	  from = (char *) &deprecated_registers[DEPRECATED_REGISTER_BYTE (regi)];
d1732 1
a1732 1
	  memcpy (to, from, DEPRECATED_REGISTER_RAW_SIZE (regi));
d1739 1
a1739 1
	from = (char *)&deprecated_registers[DEPRECATED_REGISTER_BYTE (FPS_REGNUM)];
d1741 1
a1741 1
	memcpy (to, from, DEPRECATED_REGISTER_RAW_SIZE (FPS_REGNUM));
d1770 1
a1770 1
  *pc = extract_unsigned_integer (buf, LONGJMP_TARGET_SIZE);
d1857 2
a1858 1
/* Pretty print various registers.  */
d1861 1
a1861 1
static void
d1872 2
a1873 2
      if (frame_register_read (deprecated_selected_frame, regno, value)
	  && frame_register_read (deprecated_selected_frame, regno + 1, value + 4))
d1881 2
a1882 2
	  if (frame_register_read (deprecated_selected_frame, regno + 2, value + 8)
	      && frame_register_read (deprecated_selected_frame, regno + 3, value + 12))
d1901 2
a1902 2
      if (frame_register_read (deprecated_selected_frame, regno, value)
	  && frame_register_read (deprecated_selected_frame, regno + 1, value + 8))
d2031 3
a2033 7

static void
sparc_print_registers (struct gdbarch *gdbarch,
		       struct ui_file *file,
		       struct frame_info *frame,
		       int regnum, int print_all,
		       void (*print_register_hook) (int))
d2035 3
a2037 84
  int i;
  const int numregs = NUM_REGS + NUM_PSEUDO_REGS;
  char raw_buffer[MAX_REGISTER_SIZE];
  char virtual_buffer[MAX_REGISTER_SIZE];

  for (i = 0; i < numregs; i++)
    {
      /* Decide between printing all regs, non-float / vector regs, or
         specific reg.  */
      if (regnum == -1)
	{
	  if (!print_all)
	    {
	      if (TYPE_CODE (DEPRECATED_REGISTER_VIRTUAL_TYPE (i)) == TYPE_CODE_FLT)
		continue;
	      if (TYPE_VECTOR (DEPRECATED_REGISTER_VIRTUAL_TYPE (i)))
		continue;
	    }
	}
      else
	{
	  if (i != regnum)
	    continue;
	}

      /* If the register name is empty, it is undefined for this
         processor, so don't display anything.  */
      if (REGISTER_NAME (i) == NULL || *(REGISTER_NAME (i)) == '\0')
	continue;

      fputs_filtered (REGISTER_NAME (i), file);
      print_spaces_filtered (15 - strlen (REGISTER_NAME (i)), file);

      /* Get the data in raw format.  */
      if (! frame_register_read (frame, i, raw_buffer))
	{
	  fprintf_filtered (file, "*value not available*\n");
	  continue;
	}

      memcpy (virtual_buffer, raw_buffer, DEPRECATED_REGISTER_VIRTUAL_SIZE (i));

      /* If virtual format is floating, print it that way, and in raw
         hex.  */
      if (TYPE_CODE (DEPRECATED_REGISTER_VIRTUAL_TYPE (i)) == TYPE_CODE_FLT)
	{
	  int j;

	  val_print (DEPRECATED_REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0,
		     file, 0, 1, 0, Val_pretty_default);

	  fprintf_filtered (file, "\t(raw 0x");
	  for (j = 0; j < DEPRECATED_REGISTER_RAW_SIZE (i); j++)
	    {
	      int idx;
	      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
		idx = j;
	      else
		idx = DEPRECATED_REGISTER_RAW_SIZE (i) - 1 - j;
	      fprintf_filtered (file, "%02x", (unsigned char) raw_buffer[idx]);
	    }
	  fprintf_filtered (file, ")");
	}
      else
	{
	  /* Print the register in hex.  */
	  val_print (DEPRECATED_REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0,
		     file, 'x', 1, 0, Val_pretty_default);
          /* If not a vector register, print it also according to its
             natural format.  */
	  if (TYPE_VECTOR (DEPRECATED_REGISTER_VIRTUAL_TYPE (i)) == 0)
	    {
	      fprintf_filtered (file, "\t");
	      val_print (DEPRECATED_REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0,
			 file, 0, 1, 0, Val_pretty_default);
	    }
	}

      /* Some sparc specific info.  */
      if (print_register_hook != NULL)
	print_register_hook (i);

      fprintf_filtered (file, "\n");
    }
d2039 1
a2039 135

static void
sparc_print_registers_info (struct gdbarch *gdbarch,
			    struct ui_file *file,
			    struct frame_info *frame,
			    int regnum, int print_all)
{
  sparc_print_registers (gdbarch, file, frame, regnum, print_all,
			 sparc_print_register_hook);
}

void
sparc_do_registers_info (int regnum, int all)
{
  sparc_print_registers_info (current_gdbarch, gdb_stdout, deprecated_selected_frame,
			      regnum, all);
}

#define SPARC_F0_REGNUM		FP0_REGNUM	/* %f0 */
#define SPARC_F1_REGNUM		(FP0_REGNUM + 1)/* %f1 */
#define SPARC_O0_REGNUM		O0_REGNUM	/* %o0 */
#define SPARC_O1_REGNUM		O1_REGNUM	/* %o1 */

/* Push the arguments onto the stack and into the appropriate registers.  */

static CORE_ADDR
sparc32_do_push_arguments (struct regcache *regcache, int nargs,
			   struct value **args, CORE_ADDR sp)
{
  CORE_ADDR *addr;
  int size = 0;
  int i;

  /* Structure, union and quad-precision arguments are passed by
     reference.  We allocate space for these arguments on the stack
     and record their addresses in an array.  Array elements for
     arguments that are passed by value will be set to zero.*/
  addr = alloca (nargs * sizeof (CORE_ADDR));

  for (i = nargs - 1; i >= 0; i--)
    {
      struct type *type = VALUE_ENCLOSING_TYPE (args[i]);
      enum type_code code = TYPE_CODE (type);
      int len = TYPE_LENGTH (type);

      /* Push the contents of structure, union and quad-precision
	 arguments on the stack.  */
      if (code == TYPE_CODE_STRUCT || code == TYPE_CODE_UNION || len > 8)
	{
	  /* Keep the stack doubleword aligned.  */
	  sp -= (len + 7) & ~7;
	  write_memory (sp, VALUE_CONTENTS_ALL (args[i]), len);
	  addr[i] = sp;
	  size += 4;
	}
      else
	{
	  addr[i] = 0;
	  size += (len > 4) ? 8 : 4;
	}
    }

  /* The needed space for outgoing arguments should be a multiple of 4.  */
  gdb_assert (size % 4 == 0);

  /* Make sure we reserve space for the first six words of arguments
     in the stack frame, even if we don't need them.  */
  if (size < 24)
    sp -= (24 - size);

  /* Make sure we end up with a doubleword aligned stack in the end.
     Reserve an extra word if necessary in order to accomplish this.  */
  if ((sp - size) % 8 == 0)
    sp -= 4;

  /* Now push the arguments onto the stack.  */
  for (i = nargs - 1; i >=0; i--)
    {
      char buf[8];
      int len;

      if (addr[i])
	{
	  store_unsigned_integer (buf, 4, addr[i]);
	  len = 4;
	}
      else
	{
	  struct value *arg = args[i];

	  len = TYPE_LENGTH (VALUE_ENCLOSING_TYPE (arg));

	  /* Expand signed and unsigned bytes and halfwords as needed.  */
	  if (len < 4)
	    {
	      arg = value_cast (builtin_type_long, arg);
	      len = 4;
	    }
	  else if (len > 4 && len < 8)
	    {
	      arg = value_cast (builtin_type_long_long, arg);
	      len = 4;
	    }

	  gdb_assert (len == 4 || len == 8);
	  memcpy (buf, VALUE_CONTENTS_ALL (arg), len);
	}

      /* We always write the argument word on the stack.  */
      sp -= len;
      write_memory (sp, buf, len);

      /* If this argument occupies one of the first 6 words, write it
         into the appropriate register too.  */
      size -= len;
      if (size < 24)
	{
	  int regnum = SPARC_O0_REGNUM + (size / 4);

	  regcache_cooked_write (regcache, regnum, buf);
	  if (len == 8 && size < 20)
	    regcache_cooked_write (regcache, regnum + 1, buf + 4);
	}
    }

  /* Reserve space for the struct/union return value pointer.  */
  sp -= 4;

  /* Stack should be doubleword aligned at this point.  */
  gdb_assert (sp % 8 == 0);

  /* Return the adjusted stack pointer.  */
  return sp;
}

d2048 3
a2050 6
  sp = sparc32_do_push_arguments (current_regcache, nargs, args, sp);

  /* FIXME: kettenis/20030525: We don't let this function set the
     struct/union return pointer just yet.  */
#if 0
  if (struct_return)
d2052 51
a2102 6
      char buf[4];

      /* The space for the struct/union return value pointer has
         already been reserved.  */
      store_unsigned_integer (buf, 4, struct_addr);
      write (sp, buf, 4);
a2105 3
#else
  return sp + 4;
#endif
a2107 2
/* Extract from REGCACHE a function return value of type TYPE and copy
   that into VALBUF.
d2109 3
a2111 4
   Note that REGCACHE specifies the register values for the frame of
   the calling function.  This means that we need to fetch the value
   form %o0 and %o1, which correspond to %i0 and %i1 in the frame of
   the called function.  */
d2114 1
a2114 2
sparc32_extract_return_value (struct type *type, struct regcache *regcache,
			      void *valbuf)
d2116 2
a2117 41
  int len = TYPE_LENGTH (type);
  char buf[8];

  if (TYPE_CODE (type) == TYPE_CODE_FLT && SPARC_HAS_FPU)
    {
      if (len == 4 || len == 8)
	{
	  regcache_cooked_read (regcache, SPARC_F0_REGNUM, buf);
	  regcache_cooked_read (regcache, SPARC_F1_REGNUM, buf + 4);
	  memcpy (valbuf, buf, len);
	  return;
	}
      else
	internal_error (__FILE__, __LINE__, "\
Cannot extract floating-point return value of %d bytes long.", len);
    }

  if (len <= 4)
    {
      regcache_cooked_read (regcache, SPARC_O0_REGNUM, buf);
      memcpy (valbuf, buf + 4 - len, len);
    }
  else if (len <= 8)
    {
      regcache_cooked_read (regcache, SPARC_O0_REGNUM, buf);
      regcache_cooked_read (regcache, SPARC_O1_REGNUM, buf + 4);
      memcpy (valbuf, buf + 8 - len, len);
    }
  else
    internal_error (__FILE__, __LINE__,
		    "Cannot extract return value of %d bytes long.", len);
}

/* Write into REGBUF a function return value VALBUF of type TYPE.  */

void
sparc32_store_return_value (struct type *type, struct regcache *regcache,
			    const void *valbuf)
{
  int len = TYPE_LENGTH (type);
  char buf[8];
d2120 1
a2120 33
    {
      const char *buf = valbuf;

      if (len == 4)
	{
	  regcache_cooked_write (regcache, SPARC_F0_REGNUM, buf);
	  return;
	}
      else if (len == 8)
	{
	  regcache_cooked_write (regcache, SPARC_F0_REGNUM, buf);
	  regcache_cooked_write (regcache, SPARC_F1_REGNUM, buf + 4);
	  return;
	}
      else
	internal_error (__FILE__, __LINE__, "\
Cannot extract floating-point return value of %d bytes long.", len);
    }

  /* Add leading zeros to the value.  */
  memset (buf, 0, sizeof buf);

  if (len <= 4)
    {
      memcpy (buf + 4 - len, valbuf, len);
      regcache_cooked_write (regcache, SPARC_O0_REGNUM, buf);
    }
  else if (len <= 8)
    {
      memcpy (buf + 8 - len, valbuf, len);
      regcache_cooked_write (regcache, SPARC_O0_REGNUM, buf);
      regcache_cooked_write (regcache, SPARC_O1_REGNUM, buf);
    }
d2122 6
a2127 2
    internal_error (__FILE__, __LINE__,
		    "Cannot extract return value of %d bytes long.", len);
a2129 2
/* Extract from REGCACHE the address in which a function should return
   its structure value.  */
d2131 4
a2134 4
CORE_ADDR
sparc_extract_struct_value_address (struct regcache *regcache)
{
  ULONGEST addr;
d2136 1
a2136 7
  regcache_cooked_read_unsigned (regcache, SPARC_O0_REGNUM, &addr);
  return addr;
}

/* FIXME: kettenis/2003/05/24: Still used for sparc64.  */

static void
d2140 3
a2142 1
  char buffer[MAX_REGISTER_SIZE];
d2153 1
a2153 1
  if (TYPE_LENGTH (type) < DEPRECATED_REGISTER_RAW_SIZE (regno))
d2155 2
a2156 2
      memset (buffer, 0, DEPRECATED_REGISTER_RAW_SIZE (regno));
      memcpy (buffer + DEPRECATED_REGISTER_RAW_SIZE (regno) - TYPE_LENGTH (type), valbuf,
d2158 1
a2158 1
      deprecated_write_register_gen (regno, buffer);
d2161 9
a2169 2
    deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (regno), valbuf,
				     TYPE_LENGTH (type));
d2172 1
d2183 3
a2185 4
   (twisted) convention.  So leave a nop there for gcc
   (DEPRECATED_FIX_CALL_DUMMY can assume it is operating on a pristine
   CALL_DUMMY, not one that has already been customized for a
   different function).  */
d2208 4
a2211 5

     Tweeking current_gdbarch is not an optimal solution, but the call
     to sparc_fix_call_dummy is immediately followed by a call to
     call_function_by_hand, which is the only function where
     dummy_breakpoint_offset is actually used, if it is non-zero.  */
d2217 1
a2217 1
      set_gdbarch_deprecated_call_dummy_breakpoint_offset (current_gdbarch, 0x30);
d2220 1
a2220 1
    set_gdbarch_deprecated_call_dummy_breakpoint_offset (current_gdbarch, 0x2c);
d2235 33
d2269 1
a2278 2
extern initialize_file_ftype _initialize_sparc_tdep; /* -Wmissing-prototypes */

d2284 4
d2293 1
a2293 1
static CORE_ADDR
d2303 1
a2303 1
static CORE_ADDR
d2306 1
a2306 1
  CORE_ADDR fp = read_register (DEPRECATED_FP_REGNUM);
d2313 1
a2313 1
static void
d2337 1
a2337 1
static CORE_ADDR
d2430 3
a2432 3
	      deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (fpreg),
					       VALUE_CONTENTS (args[i]),
					       len);
d2443 1
a2443 1
	      deprecated_write_register_gen (oreg, VALUE_CONTENTS (copyarg) + j);
d2454 1
a2454 1
static void
d2459 1
a2459 1
  int regsize = DEPRECATED_REGISTER_RAW_SIZE (O0_REGNUM);
d2463 1
a2463 1
      memcpy (valbuf, &regbuf[DEPRECATED_REGISTER_BYTE (FP0_REGNUM)], typelen);
d2511 1
a2511 1
static void
d2517 13
d2536 1
a2536 1
static CORE_ADDR
d2545 1
a2545 1
  if (fi && get_frame_extra_info (fi) && get_frame_extra_info (fi)->flat)
d2547 2
a2548 2
		     paddr_nz (get_frame_extra_info (fi)->pc_addr), 
		     paddr_nz (get_frame_extra_info (fi)->fp_addr));
d2551 2
d2609 62
a2670 1
static CORE_ADDR
d2684 2
a2685 4
      if (DEPRECATED_CALL_DUMMY_ADDRESS_P ())
	write_register (O7_REGNUM, DEPRECATED_CALL_DUMMY_ADDRESS () - 8);
      else
	write_register (O7_REGNUM, entry_point_address () - 8);
d2755 1
a2755 1
      regno == DEPRECATED_FP_REGNUM ||
d2769 1
a2769 1
      regno == DEPRECATED_FP_REGNUM ||
d2829 13
d2866 9
a2874 2
/* DEPRECATED_CALL_DUMMY_ADDRESS: fetch the breakpoint address for a
   call dummy.  */
d2879 1
a2879 1
  return (DEPRECATED_CALL_DUMMY_START_OFFSET) + DEPRECATED_CALL_DUMMY_BREAKPOINT_OFFSET;
a2914 10
/* Get the ith function argument for the current function.  */
static CORE_ADDR
sparc_fetch_pointer_argument (struct frame_info *frame, int argi,
			      struct type *type)
{
  CORE_ADDR addr;
  get_frame_register (frame, O0_REGNUM + argi, &addr);
  return addr;
}

d2936 1
d2962 1
a2962 2
  if (info.abfd != NULL
      && info.osabi == GDB_OSABI_UNKNOWN)
d2964 7
a2970 3
      /* If it's an ELF file, assume it's Solaris.  */
      if (bfd_get_flavour (info.abfd) == bfd_target_elf_flavour)
	info.osabi = GDB_OSABI_SOLARIS;
d2974 9
a2982 3
  arches = gdbarch_list_lookup_by_info (arches, &info);
  if (arches != NULL)
    return arches->gdbarch;
d2992 2
d2996 6
a3001 1
  set_gdbarch_breakpoint_from_pc (gdbarch, sparc_breakpoint_from_pc);
d3004 2
a3005 3
  set_gdbarch_extract_struct_value_address (gdbarch,
					   sparc_extract_struct_value_address);
  set_gdbarch_deprecated_fix_call_dummy (gdbarch, sparc_gdbarch_fix_call_dummy);
d3007 1
a3007 1
  set_gdbarch_deprecated_fp_regnum (gdbarch, SPARC_FP_REGNUM);
d3009 6
a3014 3
  set_gdbarch_deprecated_frame_chain (gdbarch, sparc_frame_chain);
  set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, sparc_frame_init_saved_regs);
  set_gdbarch_deprecated_frame_saved_pc (gdbarch, sparc_frame_saved_pc);
d3017 2
a3018 2
  set_gdbarch_deprecated_get_saved_register (gdbarch, sparc_get_saved_register);
  set_gdbarch_deprecated_init_extra_frame_info (gdbarch, sparc_init_extra_frame_info);
d3023 12
a3034 7
  set_gdbarch_deprecated_max_register_raw_size (gdbarch, 8);
  set_gdbarch_deprecated_max_register_virtual_size (gdbarch, 8);
  set_gdbarch_deprecated_pop_frame (gdbarch, sparc_pop_frame);
  set_gdbarch_deprecated_push_return_address (gdbarch, sparc_push_return_address);
  set_gdbarch_deprecated_push_dummy_frame (gdbarch, sparc_push_dummy_frame);
  set_gdbarch_deprecated_reg_struct_has_addr
    (gdbarch, sparc_reg_struct_has_addr);
d3036 1
a3036 1
  set_gdbarch_deprecated_saved_pc_after_call (gdbarch, sparc_saved_pc_after_call);
d3041 1
a3041 1
  set_gdbarch_deprecated_use_generic_dummy_frames (gdbarch, 0);
a3043 3
  /* Helper for function argument information.  */
  set_gdbarch_fetch_pointer_argument (gdbarch, sparc_fetch_pointer_argument);

d3051 2
d3055 1
d3059 4
a3062 12
      set_gdbarch_deprecated_pc_in_call_dummy (gdbarch, deprecated_pc_in_call_dummy_on_stack);
      set_gdbarch_deprecated_call_dummy_address (gdbarch, sparc_call_dummy_address);
      set_gdbarch_deprecated_call_dummy_breakpoint_offset (gdbarch, 0x30);
      set_gdbarch_deprecated_call_dummy_length (gdbarch, 0x38);

      /* NOTE: cagney/2003-05-01: Using the just added push_dummy_code
	 architecture method, it is now possible to implement a
	 generic dummy frames based inferior function call that stores
	 the breakpoint (and struct info) on the stack.  Further, by
	 treating a SIGSEG at a breakpoint as equivalent to a SIGTRAP
	 it is even possible to make this work when the stack is
	 no-execute.
d3064 1
a3064 1
	 NOTE: cagney/2002-04-26: Based from info posted by Peter
d3108 1
a3108 1
      set_gdbarch_deprecated_call_dummy_words (gdbarch, call_dummy_32);
d3110 6
a3115 2
      set_gdbarch_deprecated_pc_in_call_dummy (gdbarch, deprecated_pc_in_call_dummy_at_entry_point);
      set_gdbarch_deprecated_call_dummy_words (gdbarch, call_dummy_nil);
d3117 2
a3118 1
      set_gdbarch_deprecated_call_dummy_stack_adjust (gdbarch, 68);
d3122 1
a3122 1
      set_gdbarch_deprecated_npc_regnum (gdbarch, SPARC32_NPC_REGNUM);
d3125 10
a3134 7
      set_gdbarch_deprecated_push_arguments (gdbarch, sparc32_push_arguments);

      set_gdbarch_deprecated_register_byte (gdbarch, sparc32_register_byte);
      set_gdbarch_deprecated_register_raw_size (gdbarch, sparc32_register_size);
      set_gdbarch_deprecated_register_size (gdbarch, 4);
      set_gdbarch_deprecated_register_virtual_size (gdbarch, sparc32_register_size);
      set_gdbarch_deprecated_register_virtual_type (gdbarch, sparc32_register_virtual_type);
d3136 1
a3136 1
      set_gdbarch_deprecated_sizeof_call_dummy_words (gdbarch, sizeof (call_dummy_32));
d3138 1
a3138 1
      set_gdbarch_deprecated_sizeof_call_dummy_words (gdbarch, 0);
d3140 2
a3141 3
      set_gdbarch_deprecated_stack_align (gdbarch, sparc32_stack_align);
      set_gdbarch_deprecated_extra_stack_alignment_needed (gdbarch, 1);
      set_gdbarch_deprecated_store_struct_return (gdbarch, sparc32_store_struct_return);
d3144 1
a3144 1
      set_gdbarch_deprecated_dummy_write_sp (gdbarch, deprecated_write_sp);
d3158 4
a3161 4
      set_gdbarch_deprecated_pc_in_call_dummy (gdbarch, deprecated_pc_in_call_dummy_on_stack);
      set_gdbarch_deprecated_call_dummy_address (gdbarch, sparc_call_dummy_address);
      set_gdbarch_deprecated_call_dummy_breakpoint_offset (gdbarch, 8 * 4);
      set_gdbarch_deprecated_call_dummy_length (gdbarch, 192);
d3163 2
a3164 2
      set_gdbarch_deprecated_call_dummy_start_offset (gdbarch, 148);
      set_gdbarch_deprecated_call_dummy_words (gdbarch, call_dummy_64);
d3166 7
a3172 2
      set_gdbarch_deprecated_pc_in_call_dummy (gdbarch, deprecated_pc_in_call_dummy_at_entry_point);
      set_gdbarch_deprecated_call_dummy_words (gdbarch, call_dummy_nil);
d3174 1
a3174 1
      set_gdbarch_deprecated_call_dummy_stack_adjust (gdbarch, 128);
d3178 1
a3178 1
      set_gdbarch_deprecated_npc_regnum (gdbarch, SPARC64_NPC_REGNUM);
d3181 1
a3181 1
      set_gdbarch_deprecated_push_arguments (gdbarch, sparc64_push_arguments);
d3183 1
a3183 1
      set_gdbarch_deprecated_target_read_fp (gdbarch, sparc64_read_fp);
d3187 6
a3192 5
      set_gdbarch_deprecated_register_byte (gdbarch, sparc64_register_byte);
      set_gdbarch_deprecated_register_raw_size (gdbarch, sparc64_register_size);
      set_gdbarch_deprecated_register_size (gdbarch, 8);
      set_gdbarch_deprecated_register_virtual_size (gdbarch, sparc64_register_size);
      set_gdbarch_deprecated_register_virtual_type (gdbarch, sparc64_register_virtual_type);
d3194 1
a3194 1
      set_gdbarch_deprecated_sizeof_call_dummy_words (gdbarch, sizeof (call_dummy_64));
d3196 1
a3196 1
      set_gdbarch_deprecated_sizeof_call_dummy_words (gdbarch, 0);
d3198 2
a3199 3
      set_gdbarch_deprecated_stack_align (gdbarch, sparc64_stack_align);
      set_gdbarch_deprecated_extra_stack_alignment_needed (gdbarch, 1);
      set_gdbarch_deprecated_store_struct_return (gdbarch, sparc64_store_struct_return);
d3202 1
a3202 1
      set_gdbarch_deprecated_dummy_write_sp (gdbarch, sparc64_write_sp);
d3218 2
a3219 2
      set_gdbarch_extract_return_value (gdbarch, sparc32_extract_return_value);
      set_gdbarch_store_return_value (gdbarch, sparc32_store_return_value);
d3221 1
a3221 1
      set_gdbarch_deprecated_register_bytes (gdbarch, 32*4 + 32*4 + 8*4);
d3223 2
d3228 22
d3251 2
a3252 2
      set_gdbarch_extract_return_value (gdbarch, sparc32_extract_return_value);
      set_gdbarch_store_return_value (gdbarch, sparc32_store_return_value);
d3254 1
a3254 1
      set_gdbarch_deprecated_register_bytes (gdbarch, 32*4 + 32*4 + 8*4);
d3256 1
d3259 1
d3262 2
a3263 2
      set_gdbarch_extract_return_value (gdbarch, sparc32_extract_return_value);
      set_gdbarch_store_return_value (gdbarch, sparc32_store_return_value);
d3265 1
a3265 1
      set_gdbarch_deprecated_register_bytes (gdbarch, 32*4 + 32*4 + 8*4);
d3267 2
d3272 11
d3285 1
d3287 1
a3287 1
      set_gdbarch_deprecated_register_bytes (gdbarch, 32*8 + 32*8 + 45*8);
d3290 1
d3296 1
d3298 1
a3298 1
      set_gdbarch_deprecated_register_bytes (gdbarch, 32*8 + 32*8 + 45*8);
d3301 1
a3306 2
  set_gdbarch_print_insn (gdbarch, print_insn_sparc);

d3308 1
a3308 1
  gdbarch_init_osabi (info, gdbarch);
d3321 2
a3322 14
  fprintf_unfiltered (file, "sparc_dump_tdep: fp_register_bytes = %d\n",
		      tdep->fp_register_bytes);
  fprintf_unfiltered (file, "sparc_dump_tdep: y_regnum = %d\n",
		      tdep->y_regnum);
  fprintf_unfiltered (file, "sparc_dump_tdep: fp_max_regnum = %d\n",
		      tdep->fp_max_regnum);
  fprintf_unfiltered (file, "sparc_dump_tdep: intreg_size = %d\n",
		      tdep->intreg_size);
  fprintf_unfiltered (file, "sparc_dump_tdep: reg_save_offset = %d\n",
		      tdep->reg_save_offset);
  fprintf_unfiltered (file, "sparc_dump_tdep: call_dummy_call_offset = %d\n",
		      tdep->call_dummy_call_offset);
  fprintf_unfiltered (file, "sparc_dump_tdep: print_insn_match = %d\n",
		      tdep->print_insn_mach);
@


1.39.10.2
log
@Merge mainline to branch.  GDB is broken until I update cp-names.y.
@
text
@d1 1
a1 1
/* Target-dependent code for SPARC.
d3 3
a5 1
   Copyright 2003, 2004 Free Software Foundation, Inc.
d24 2
a27 2
#include "dis-asm.h"
#include "floatformat.h"
a28 4
#include "frame-base.h"
#include "frame-unwind.h"
#include "gdbcore.h"
#include "gdbtypes.h"
a29 4
#include "symtab.h"
#include "objfiles.h"
#include "osabi.h"
#include "regcache.h"
d32 13
d46 1
a47 1
#include "gdb_string.h"
d49 71
a119 1
#include "sparc-tdep.h"
a120 1
struct regset;
d122 2
a123 29
/* This file implements the The SPARC 32-bit ABI as defined by the
   section "Low-Level System Information" of the SPARC Compliance
   Definition (SCD) 2.4.1, which is the 32-bit System V psABI for
   SPARC.  The SCD lists changes with respect to the origional 32-bit
   psABI as defined in the "System V ABI, SPARC Processor
   Supplement".

   Note that if we talk about SunOS, we mean SunOS 4.x, which was
   BSD-based, which is sometimes (retroactively?) referred to as
   Solaris 1.x.  If we talk about Solaris we mean Solaris 2.x and
   above (Solaris 7, 8 and 9 are nothing but Solaris 2.7, 2.8 and 2.9
   suffering from severe version number inflation).  Solaris 2.x is
   also known as SunOS 5.x, since that's what uname(1) says.  Solaris
   2.x is SVR4-based.  */

/* Please use the sparc32_-prefix for 32-bit specific code, the
   sparc64_-prefix for 64-bit specific code and the sparc_-prefix for
   code that can handle both.  The 64-bit specific code lives in
   sparc64-tdep.c; don't add any here.  */

/* The SPARC Floating-Point Quad-Precision format is similar to
   big-endian IA-64 Quad-recision format.  */
#define floatformat_sparc_quad floatformat_ia64_quad_big

/* The stack pointer is offset from the stack frame by a BIAS of 2047
   (0x7ff) for 64-bit code.  BIAS is likely to be defined on SPARC
   hosts, so undefine it first.  */
#undef BIAS
#define BIAS 2047
d125 1
a125 1
/* Macros to extract fields from SPARC instructions.  */
d133 1
d135 1
d137 1
d139 2
d142 25
d168 2
a169 2
/* Fetch the instruction at PC.  Instructions are always big-endian
   even if the processor operates in little-endian mode.  */
d171 3
a173 2
unsigned long
sparc_fetch_instruction (CORE_ADDR pc)
d175 3
a177 3
  unsigned char buf[4];
  unsigned long insn;
  int i;
d179 5
a183 1
  read_memory (pc, buf, sizeof (buf));
d185 2
a186 7
  insn = 0;
  for (i = 0; i < sizeof (buf); i++)
    insn = (insn << 8) | buf[i];
  return insn;
}

/* Return the contents if register REGNUM as an address.  */
d188 4
a191 4
static CORE_ADDR
sparc_address_from_register (int regnum)
{
  ULONGEST addr;
d193 20
a212 38
  regcache_cooked_read_unsigned (current_regcache, regnum, &addr);
  return addr;
}


/* The functions on this page are intended to be used to classify
   function arguments.  */

/* Check whether TYPE is "Integral or Pointer".  */

static int
sparc_integral_or_pointer_p (const struct type *type)
{
  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_INT:
    case TYPE_CODE_BOOL:
    case TYPE_CODE_CHAR:
    case TYPE_CODE_ENUM:
    case TYPE_CODE_RANGE:
      {
	/* We have byte, half-word, word and extended-word/doubleword
           integral types.  The doubleword is an extension to the
           origional 32-bit ABI by the SCD 2.4.x.  */
	int len = TYPE_LENGTH (type);
	return (len == 1 || len == 2 || len == 4 || len == 8);
      }
      return 1;
    case TYPE_CODE_PTR:
    case TYPE_CODE_REF:
      {
	/* Allow either 32-bit or 64-bit pointers.  */
	int len = TYPE_LENGTH (type);
	return (len == 4 || len == 8);
      }
      return 1;
    default:
      break;
d214 1
a214 10

  return 0;
}

/* Check whether TYPE is "Floating".  */

static int
sparc_floating_p (const struct type *type)
{
  switch (TYPE_CODE (type))
d216 2
a217 8
    case TYPE_CODE_FLT:
      {
	int len = TYPE_LENGTH (type);
	return (len == 4 || len == 8 || len == 16);
      }
    default:
      break;
    }
d219 2
a220 4
  return 0;
}

/* Check whether TYPE is "Structure or Union".  */
d222 2
a223 10
static int
sparc_structure_or_union_p (const struct type *type)
{
  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_STRUCT:
    case TYPE_CODE_UNION:
      return 1;
    default:
      break;
a224 2

  return 0;
d226 2
a227 4

/* Register information.  */

static const char *sparc32_register_names[] =
d229 9
a237 11
  "g0", "g1", "g2", "g3", "g4", "g5", "g6", "g7",
  "o0", "o1", "o2", "o3", "o4", "o5", "sp", "o7",
  "l0", "l1", "l2", "l3", "l4", "l5", "l6", "l7",
  "i0", "i1", "i2", "i3", "i4", "i5", "fp", "i7",

  "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7",
  "f8", "f9", "f10", "f11", "f12", "f13", "f14", "f15",
  "f16", "f17", "f18", "f19", "f20", "f21", "f22", "f23",
  "f24", "f25", "f26", "f27", "f28", "f29", "f30", "f31",

  "y", "psr", "wim", "tbr", "pc", "npc", "fsr", "csr"
d240 5
a244 2
/* Total number of registers.  */
#define SPARC32_NUM_REGS ARRAY_SIZE (sparc32_register_names)
d246 2
a247 4
/* We provide the aliases %d0..%d30 for the floating registers as
   "psuedo" registers.  */

static const char *sparc32_pseudo_register_names[] =
d249 43
a291 3
  "d0", "d2", "d4", "d6", "d8", "d10", "d12", "d14",
  "d16", "d18", "d20", "d22", "d24", "d26", "d28", "d30"
};
d293 24
a316 2
/* Total number of pseudo registers.  */
#define SPARC32_NUM_PSEUDO_REGS ARRAY_SIZE (sparc32_pseudo_register_names)
d318 2
a319 1
/* Return the name of register REGNUM.  */
d321 1
a321 5
static const char *
sparc32_register_name (int regnum)
{
  if (regnum >= 0 && regnum < SPARC32_NUM_REGS)
    return sparc32_register_names[regnum];
d323 61
a383 4
  if (regnum < SPARC32_NUM_REGS + SPARC32_NUM_PSEUDO_REGS)
    return sparc32_pseudo_register_names[regnum - SPARC32_NUM_REGS];

  return NULL;
d386 2
a387 5
/* Return the GDB type object for the "standard" data type of data in
   register REGNUM. */

static struct type *
sparc32_register_type (struct gdbarch *gdbarch, int regnum)
d389 15
a403 14
  if (regnum >= SPARC_F0_REGNUM && regnum <= SPARC_F31_REGNUM)
    return builtin_type_float;

  if (regnum >= SPARC32_D0_REGNUM && regnum <= SPARC32_D30_REGNUM)
    return builtin_type_double;

  if (regnum == SPARC_SP_REGNUM || regnum == SPARC_FP_REGNUM)
    return builtin_type_void_data_ptr;

  if (regnum == SPARC32_PC_REGNUM || regnum == SPARC32_NPC_REGNUM)
    return builtin_type_void_func_ptr;

  return builtin_type_int32;
}
d405 1
a405 10
static void
sparc32_pseudo_register_read (struct gdbarch *gdbarch,
			      struct regcache *regcache,
			      int regnum, void *buf)
{
  gdb_assert (regnum >= SPARC32_D0_REGNUM && regnum <= SPARC32_D30_REGNUM);

  regnum = SPARC_F0_REGNUM + 2 * (regnum - SPARC32_D0_REGNUM);
  regcache_raw_read (regcache, regnum, buf);
  regcache_raw_read (regcache, regnum + 1, ((char *)buf) + 4);
d408 1
a408 12
static void
sparc32_pseudo_register_write (struct gdbarch *gdbarch,
			       struct regcache *regcache,
			       int regnum, const void *buf)
{
  gdb_assert (regnum >= SPARC32_D0_REGNUM && regnum <= SPARC32_D30_REGNUM);

  regnum = SPARC_F0_REGNUM + 2 * (regnum - SPARC32_D0_REGNUM);
  regcache_raw_write (regcache, regnum, buf);
  regcache_raw_write (regcache, regnum + 1, ((const char *)buf) + 4);
}

d410 2
a411 6
static CORE_ADDR
sparc32_push_dummy_code (struct gdbarch *gdbarch, CORE_ADDR sp,
			 CORE_ADDR funcaddr, int using_gcc,
			 struct value **args, int nargs,
			 struct type *value_type,
			 CORE_ADDR *real_pc, CORE_ADDR *bp_addr)
d413 2
a414 25
  *bp_addr = sp - 4;
  *real_pc = funcaddr;

  if (using_struct_return (value_type, using_gcc))
    {
      char buf[4];

      /* This is an UNIMP instruction.  */
      store_unsigned_integer (buf, 4, TYPE_LENGTH (value_type) & 0x1fff);
      write_memory (sp - 8, buf, 4);
      return sp - 8;
    }

  return sp - 4;
}

static CORE_ADDR
sparc32_store_arguments (struct regcache *regcache, int nargs,
			 struct value **args, CORE_ADDR sp,
			 int struct_return, CORE_ADDR struct_addr)
{
  /* Number of words in the "parameter array".  */
  int num_elements = 0;
  int element = 0;
  int i;
d416 1
a416 1
  for (i = 0; i < nargs; i++)
d418 2
a419 36
      struct type *type = VALUE_TYPE (args[i]);
      int len = TYPE_LENGTH (type);

      if (sparc_structure_or_union_p (type)
	  || (sparc_floating_p (type) && len == 16))
	{
	  /* Structure, Union and Quad-Precision Arguments.  */
	  sp -= len;

	  /* Use doubleword alignment for these values.  That's always
             correct, and wasting a few bytes shouldn't be a problem.  */
	  sp &= ~0x7;

	  write_memory (sp, VALUE_CONTENTS (args[i]), len);
	  args[i] = value_from_pointer (lookup_pointer_type (type), sp);
	  num_elements++;
	}
      else if (sparc_floating_p (type))
	{
	  /* Floating arguments.  */
	  gdb_assert (len == 4 || len == 8);
	  num_elements += (len / 4);
	}
      else
	{
	  /* Integral and pointer arguments.  */
	  gdb_assert (sparc_integral_or_pointer_p (type));

	  if (len < 4)
	    args[i] = value_cast (builtin_type_int32, args[i]);
	  num_elements += ((len + 3) / 4);
	}
    }

  /* Always allocate at least six words.  */
  sp -= max (6, num_elements) * 4;
d421 3
a423 3
  /* The psABI says that "Software convention requires space for the
     struct/union return value pointer, even if the word is unused."  */
  sp -= 4;
d425 4
a428 4
  /* The psABI says that "Although software convention and the
     operating system require every stack frame to be doubleword
     aligned."  */
  sp &= ~0x7;
d430 1
a430 5
  for (i = 0; i < nargs; i++)
    {
      char *valbuf = VALUE_CONTENTS (args[i]);
      struct type *type = VALUE_TYPE (args[i]);
      int len = TYPE_LENGTH (type);
d432 6
a437 1
      gdb_assert (len == 4 || len == 8);
d439 6
a444 8
      if (element < 6)
	{
	  int regnum = SPARC_O0_REGNUM + element;

	  regcache_cooked_write (regcache, regnum, valbuf);
	  if (len > 4 && element < 5)
	    regcache_cooked_write (regcache, regnum + 1, valbuf + 4);
	}
d446 17
a462 3
      /* Always store the argument in memory.  */
      write_memory (sp + 4 + element * 4, valbuf, len);
      element += len / 4;
d464 5
d470 4
a473 9
  gdb_assert (element == num_elements);

  if (struct_return)
    {
      char buf[4];

      store_unsigned_integer (buf, 4, struct_addr);
      write_memory (sp, buf, 4);
    }
d475 2
a476 1
  return sp;
d479 7
a485 14
static CORE_ADDR
sparc32_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
			 struct regcache *regcache, CORE_ADDR bp_addr,
			 int nargs, struct value **args, CORE_ADDR sp,
			 int struct_return, CORE_ADDR struct_addr)
{
  CORE_ADDR call_pc = (struct_return ? (bp_addr - 12) : (bp_addr - 8));

  /* Set return address.  */
  regcache_cooked_write_unsigned (regcache, SPARC_O7_REGNUM, call_pc);

  /* Set up function arguments.  */
  sp = sparc32_store_arguments (regcache, nargs, args, sp,
				struct_return, struct_addr);
d487 4
a490 5
  /* Allocate the 16-word window save area.  */
  sp -= 16 * 4;

  /* Stack should be doubleword aligned at this point.  */
  gdb_assert (sp % 8 == 0);
d492 2
a493 2
  /* Finally, update the stack pointer.  */
  regcache_cooked_write_unsigned (regcache, SPARC_SP_REGNUM, sp);
d495 1
a495 3
  return sp;
}

d497 3
a499 10
/* Use the program counter to determine the contents and size of a
   breakpoint instruction.  Return a pointer to a string of bytes that
   encode a breakpoint instruction, store the length of the string in
   *LEN and optionally adjust *PC to point to the correct memory
   location for inserting the breakpoint.  */
   
static const unsigned char *
sparc_breakpoint_from_pc (CORE_ADDR *pc, int *len)
{
  static unsigned char break_insn[] = { 0x91, 0xd0, 0x20, 0x01 };
d501 3
a503 2
  *len = sizeof (break_insn);
  return break_insn;
a504 3


/* Allocate and initialize a frame cache.  */
d506 2
a507 5
static struct sparc_frame_cache *
sparc_alloc_frame_cache (void)
{
  struct sparc_frame_cache *cache;
  int i;
d509 2
a510 1
  cache = FRAME_OBSTACK_ZALLOC (struct sparc_frame_cache);
d512 2
a513 3
  /* Base address.  */
  cache->base = 0;
  cache->pc = 0;
d515 2
a516 2
  /* Frameless until proven otherwise.  */
  cache->frameless_p = 1;
d518 3
a520 8
  cache->struct_return_p = 0;

  return cache;
}

CORE_ADDR
sparc_analyze_prologue (CORE_ADDR pc, CORE_ADDR current_pc,
			struct sparc_frame_cache *cache)
d522 1
a522 3
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  unsigned long insn;
  int offset = 0;
d524 2
d527 1
a527 15
  if (current_pc <= pc)
    return current_pc;

  /* We have to handle to "Procedure Linkage Table" (PLT) special.  On
     SPARC the linker usually defines a symbol (typically
     _PROCEDURE_LINKAGE_TABLE_) at the start of the .plt section.
     This symbol makes us end up here with PC pointing at the start of
     the PLT and CURRENT_PC probably pointing at a PLT entry.  If we
     would do our normal prologue analysis, we would probably conclude
     that we've got a frame when in reality we don't, since the
     dynamic linker patches up the first PLT with some code that
     starts with a SAVE instruction.  Patch up PC such that it points
     at the start of our PLT entry.  */
  if (tdep->plt_entry_size > 0 && in_plt_section (current_pc, NULL))
    pc = current_pc - ((current_pc - pc) % tdep->plt_entry_size);
d529 2
a530 4
  insn = sparc_fetch_instruction (pc);

  /* Recognize a SETHI insn and record its destination.  */
  if (X_OP (insn) == 0 && X_OP2 (insn) == 0x04)
d533 2
a534 3
      offset += 4;

      insn = sparc_fetch_instruction (pc + 4);
d537 8
a544 2
  /* Allow for an arithmetic operation on DEST or %g1.  */
  if (X_OP (insn) == 2 && X_I (insn)
d547 3
a549 1
      offset += 4;
d551 39
a589 1
      insn = sparc_fetch_instruction (pc + 8);
d591 3
d595 1
a595 2
  /* Check for the SAVE instruction that sets up the frame.  */
  if (X_OP (insn) == 2 && X_OP3 (insn) == 0x3c)
d597 52
a648 2
      cache->frameless_p = 0;
      return pc + offset + 4;
d654 2
a655 9
static CORE_ADDR
sparc_unwind_pc (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  return frame_unwind_register_unsigned (next_frame, tdep->pc_regnum);
}

/* Return PC of first real instruction of the function starting at
   START_PC.  */
d657 2
a658 2
static CORE_ADDR
sparc32_skip_prologue (CORE_ADDR start_pc)
a661 1
  struct sparc_frame_cache cache;
d674 2
a675 1
  return sparc_analyze_prologue (start_pc, 0xffffffffUL, &cache);
d678 1
a678 1
/* Normal frames.  */
d680 2
a681 2
struct sparc_frame_cache *
sparc_frame_cache (struct frame_info *next_frame, void **this_cache)
d683 2
a684 1
  struct sparc_frame_cache *cache;
d686 3
a688 2
  if (*this_cache)
    return *this_cache;
d690 1
a690 2
  cache = sparc_alloc_frame_cache ();
  *this_cache = cache;
d692 5
a696 3
  /* In priciple, for normal frames, %fp (%i6) holds the frame
     pointer, which holds the base address for the current stack
     frame.  */
d698 1
a698 3
  cache->base = frame_unwind_register_unsigned (next_frame, SPARC_FP_REGNUM);
  if (cache->base == 0)
    return cache;
d700 7
a706 2
  cache->pc = frame_func_unwind (next_frame);
  if (cache->pc != 0)
d708 40
a747 2
      CORE_ADDR addr_in_block = frame_unwind_address_in_block (next_frame);
      sparc_analyze_prologue (cache->pc, addr_in_block, cache);
d750 8
a757 7
  if (cache->frameless_p)
    {
      /* We didn't find a valid frame, which means that CACHE->base
	 currently holds the frame pointer for our calling frame.  */
      cache->base = frame_unwind_register_unsigned (next_frame,
						    SPARC_SP_REGNUM);
    }
d759 1
a759 2
  return cache;
}
d761 4
a764 2
struct sparc_frame_cache *
sparc32_frame_cache (struct frame_info *next_frame, void **this_cache)
d766 2
a767 2
  struct sparc_frame_cache *cache;
  struct symbol *sym;
d769 2
a770 2
  if (*this_cache)
    return *this_cache;
d772 2
a773 1
  cache = sparc_frame_cache (next_frame, this_cache);
d775 4
a778 2
  sym = find_pc_function (cache->pc);
  if (sym)
d780 13
a792 2
      struct type *type = check_typedef (SYMBOL_TYPE (sym));
      enum type_code code = TYPE_CODE (type);
d794 6
a799 1
      if (code == TYPE_CODE_FUNC || code == TYPE_CODE_METHOD)
d801 2
a802 4
	  type = check_typedef (TYPE_TARGET_TYPE (type));
	  if (sparc_structure_or_union_p (type)
	      || (sparc_floating_p (type) && TYPE_LENGTH (type) == 16))
	    cache->struct_return_p = 1;
d804 3
d809 3
a811 2
  return cache;
}
d813 55
a867 6
static void
sparc32_frame_this_id (struct frame_info *next_frame, void **this_cache,
		       struct frame_id *this_id)
{
  struct sparc_frame_cache *cache =
    sparc32_frame_cache (next_frame, this_cache);
d869 2
a870 3
  /* This marks the outermost frame.  */
  if (cache->base == 0)
    return;
d872 24
a895 31
  (*this_id) = frame_id_build (cache->base, cache->pc);
}

static void
sparc32_frame_prev_register (struct frame_info *next_frame, void **this_cache,
			     int regnum, int *optimizedp,
			     enum lval_type *lvalp, CORE_ADDR *addrp,
			     int *realnump, void *valuep)
{
  struct sparc_frame_cache *cache =
    sparc32_frame_cache (next_frame, this_cache);

  if (regnum == SPARC32_PC_REGNUM || regnum == SPARC32_NPC_REGNUM)
    {
      *optimizedp = 0;
      *lvalp = not_lval;
      *addrp = 0;
      *realnump = -1;
      if (valuep)
	{
	  CORE_ADDR pc = (regnum == SPARC32_NPC_REGNUM) ? 4 : 0;

	  /* If this functions has a Structure, Union or
             Quad-Precision return value, we have to skip the UNIMP
             instruction that encodes the size of the structure.  */
	  if (cache->struct_return_p)
	    pc += 4;

	  regnum = cache->frameless_p ? SPARC_O7_REGNUM : SPARC_I7_REGNUM;
	  pc += frame_unwind_register_unsigned (next_frame, regnum) + 8;
	  store_unsigned_integer (valuep, 4, pc);
d897 3
a899 1
      return;
d901 5
a905 11

  /* The previous frame's `local' and `in' registers have been saved
     in the register save area.  */
  if (!cache->frameless_p
      && regnum >= SPARC_L0_REGNUM && regnum <= SPARC_I7_REGNUM)
    {
      *optimizedp = 0;
      *lvalp = lval_memory;
      *addrp = cache->base + (regnum - SPARC_L0_REGNUM) * 4;
      *realnump = -1;
      if (valuep)
d907 8
a914 4
	  struct gdbarch *gdbarch = get_frame_arch (next_frame);

	  /* Read the value in from memory.  */
	  read_memory (*addrp, valuep, register_size (gdbarch, regnum));
d916 10
a925 1
      return;
d927 3
d931 1
a931 5
  /* The previous frame's `out' registers are accessable as the
     current frame's `in' registers.  */
  if (!cache->frameless_p
      && regnum >= SPARC_O0_REGNUM && regnum <= SPARC_O7_REGNUM)
    regnum += (SPARC_I0_REGNUM - SPARC_O0_REGNUM);
d933 3
a935 3
  frame_register_unwind (next_frame, regnum,
			 optimizedp, lvalp, addrp, realnump, valuep);
}
d937 1
a937 6
static const struct frame_unwind sparc32_frame_unwind =
{
  NORMAL_FRAME,
  sparc32_frame_this_id,
  sparc32_frame_prev_register
};
d939 1
a939 6
static const struct frame_unwind *
sparc32_frame_sniffer (struct frame_info *next_frame)
{
  return &sparc32_frame_unwind;
}

d941 4
a944 5
static CORE_ADDR
sparc32_frame_base_address (struct frame_info *next_frame, void **this_cache)
{
  struct sparc_frame_cache *cache =
    sparc32_frame_cache (next_frame, this_cache);
d946 2
a947 13
  return cache->base;
}

static const struct frame_base sparc32_frame_base =
{
  &sparc32_frame_unwind,
  sparc32_frame_base_address,
  sparc32_frame_base_address,
  sparc32_frame_base_address
};

static struct frame_id
sparc_unwind_dummy_id (struct gdbarch *gdbarch, struct frame_info *next_frame)
d949 2
a950 6
  CORE_ADDR sp;

  sp = frame_unwind_register_unsigned (next_frame, SPARC_SP_REGNUM);
  return frame_id_build (sp, frame_pc_unwind (next_frame));
}

d952 1
a952 2
/* Extract from an array REGBUF containing the (raw) register state, a
   function return value of TYPE, and copy that into VALBUF.  */
d954 1
a954 6
static void
sparc32_extract_return_value (struct type *type, struct regcache *regcache,
			      void *valbuf)
{
  int len = TYPE_LENGTH (type);
  char buf[8];
d956 1
a956 4
  gdb_assert (!sparc_structure_or_union_p (type));
  gdb_assert (!(sparc_floating_p (type) && len == 16));

  if (sparc_floating_p (type))
d958 8
a965 5
      /* Floating return values.  */
      regcache_cooked_read (regcache, SPARC_F0_REGNUM, buf);
      if (len > 4)
	regcache_cooked_read (regcache, SPARC_F1_REGNUM, buf + 4);
      memcpy (valbuf, buf, len);
d969 42
a1010 9
      /* Integral and pointer return values.  */
      gdb_assert (sparc_integral_or_pointer_p (type));

      regcache_cooked_read (regcache, SPARC_O0_REGNUM, buf);
      if (len > 4)
	{
	  regcache_cooked_read (regcache, SPARC_O1_REGNUM, buf + 4);
	  gdb_assert (len == 8);
	  memcpy (valbuf, buf, 8);
d1014 2
a1015 3
	  /* Just stripping off any unused bytes should preserve the
	     signed-ness just fine.  */
	  memcpy (valbuf, buf + 4 - len, len);
d1017 21
d1041 35
a1075 2
/* Write into the appropriate registers a function return value stored
   in VALBUF of type TYPE.  */
d1078 1
a1078 2
sparc32_store_return_value (struct type *type, struct regcache *regcache,
			    const void *valbuf)
d1080 4
a1083 2
  int len = TYPE_LENGTH (type);
  char buf[8];
d1085 1
a1085 2
  gdb_assert (!sparc_structure_or_union_p (type));
  gdb_assert (!(sparc_floating_p (type) && len == 16));
d1087 4
a1090 1
  if (sparc_floating_p (type))
d1092 46
a1137 5
      /* Floating return values.  */
      memcpy (buf, valbuf, len);
      regcache_cooked_write (regcache, SPARC_F0_REGNUM, buf);
      if (len > 4)
	regcache_cooked_write (regcache, SPARC_F1_REGNUM, buf + 4);
d1141 61
a1201 2
      /* Integral and pointer return values.  */
      gdb_assert (sparc_integral_or_pointer_p (type));
d1203 12
a1214 1
      if (len > 4)
d1216 10
a1225 3
	  gdb_assert (len == 8);
	  memcpy (buf, valbuf, 8);
	  regcache_cooked_write (regcache, SPARC_O1_REGNUM, buf + 4);
d1227 91
d1320 6
a1325 2
	  /* ??? Do we need to do any sign-extension here?  */
	  memcpy (buf + 4 - len, valbuf, len);
d1327 11
a1337 1
      regcache_cooked_write (regcache, SPARC_O0_REGNUM, buf);
d1339 1
d1342 3
a1344 20
static enum return_value_convention
sparc32_return_value (struct gdbarch *gdbarch, struct type *type,
		      struct regcache *regcache, void *readbuf,
		      const void *writebuf)
{
  if (sparc_structure_or_union_p (type)
      || (sparc_floating_p (type) && TYPE_LENGTH (type) == 16))
    return RETURN_VALUE_STRUCT_CONVENTION;

  if (readbuf)
    sparc32_extract_return_value (type, regcache, readbuf);
  if (writebuf)
    sparc32_store_return_value (type, regcache, writebuf);

  return RETURN_VALUE_REGISTER_CONVENTION;
}

/* Extract from REGCACHE, which contains the (raw) register state, the
   address in which a function should return its structure value, as a
   CORE_ADDR.  */
d1346 2
a1347 2
static CORE_ADDR
sparc32_extract_struct_value_address (struct regcache *regcache)
d1349 3
a1351 1
  ULONGEST sp;
d1353 6
a1358 2
  regcache_cooked_read_unsigned (regcache, SPARC_SP_REGNUM, &sp);
  return read_memory_unsigned_integer (sp + 64, 4);
d1361 14
a1374 2
static int
sparc32_stabs_argument_has_addr (struct gdbarch *gdbarch, struct type *type)
d1376 24
a1399 2
  return (sparc_structure_or_union_p (type)
	  || (sparc_floating_p (type) && TYPE_LENGTH (type) == 16));
a1400 1

d1402 42
a1443 3
/* The SPARC Architecture doesn't have hardware single-step support,
   and most operating systems don't implement it either, so we provide
   software single-step mechanism.  */
d1445 2
a1446 2
static CORE_ADDR
sparc_analyze_control_transfer (CORE_ADDR pc, CORE_ADDR *npc)
d1448 2
a1449 4
  unsigned long insn = sparc_fetch_instruction (pc);
  int conditional_p = X_COND (insn) & 0x7;
  int branch_p = 0;
  long offset = 0;			/* Must be signed for sign-extend.  */
d1451 108
a1558 5
  if (X_OP (insn) == 0 && X_OP2 (insn) == 3 && (insn & 0x1000000) == 0)
    {
      /* Branch on Integer Register with Prediction (BPr).  */
      branch_p = 1;
      conditional_p = 1;
d1560 1
a1560 1
  else if (X_OP (insn) == 0 && X_OP2 (insn) == 6)
d1562 1
a1562 3
      /* Branch on Floating-Point Condition Codes (FBfcc).  */
      branch_p = 1;
      offset = 4 * X_DISP22 (insn);
d1564 92
a1655 1
  else if (X_OP (insn) == 0 && X_OP2 (insn) == 5)
d1657 2
a1658 4
      /* Branch on Floating-Point Condition Codes with Prediction
         (FBPfcc).  */
      branch_p = 1;
      offset = 4 * X_DISP19 (insn);
d1660 2
a1661 1
  else if (X_OP (insn) == 0 && X_OP2 (insn) == 2)
d1663 8
a1670 3
      /* Branch on Integer Condition Codes (Bicc).  */
      branch_p = 1;
      offset = 4 * X_DISP22 (insn);
d1672 1
a1672 1
  else if (X_OP (insn) == 0 && X_OP2 (insn) == 1)
d1674 1
a1674 3
      /* Branch on Integer Condition Codes with Prediction (BPcc).  */
      branch_p = 1;
      offset = 4 * X_DISP19 (insn);
d1676 1
d1678 5
a1682 1
  /* FIXME: Handle DONE and RETRY instructions.  */
d1684 9
a1692 1
  /* FIXME: Handle the Trap instruction.  */
d1694 1
a1694 1
  if (branch_p)
d1696 1
a1696 1
      if (conditional_p)
d1698 3
a1700 17
	  /* For conditional branches, return nPC + 4 iff the annul
	     bit is 1.  */
	  return (X_A (insn) ? *npc + 4 : 0);
	}
      else
	{
	  /* For unconditional branches, return the target if its
	     specified condition is "always" and return nPC + 4 if the
	     condition is "never".  If the annul bit is 1, set *NPC to
	     zero.  */
	  if (X_COND (insn) == 0x0)
	    pc = *npc, offset = 4;
	  if (X_A (insn))
	    *npc = 0;

	  gdb_assert (offset != 0);
	  return pc + offset;
d1704 7
a1710 1
  return 0;
d1713 5
a1717 6
void
sparc_software_single_step (enum target_signal sig, int insert_breakpoints_p)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  static CORE_ADDR npc, nnpc;
  static char npc_save[4], nnpc_save[4];
d1719 5
a1723 3
  if (insert_breakpoints_p)
    {
      CORE_ADDR pc;
d1725 6
a1730 2
      pc = sparc_address_from_register (tdep->pc_regnum);
      npc = sparc_address_from_register (tdep->npc_regnum);
d1732 1
a1732 6
      /* Analyze the instruction at PC.  */
      nnpc = sparc_analyze_control_transfer (pc, &npc);
      if (npc != 0)
	target_insert_breakpoint (npc, npc_save);
      if (nnpc != 0)
	target_insert_breakpoint (nnpc, nnpc_save);
d1734 3
a1736 13
      /* Assert that we have set at least one breakpoint, and that
         they're not set at the same spot.  */
      gdb_assert (npc != 0 || nnpc != 0);
      gdb_assert (nnpc != npc);
    }
  else
    {
      if (npc != 0)
	target_remove_breakpoint (npc, npc_save);
      if (nnpc != 0)
	target_remove_breakpoint (nnpc, nnpc_save);
    }
}
d1738 1
a1738 4
static void
sparc_write_pc (CORE_ADDR pc, ptid_t ptid)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d1740 1
a1740 2
  write_register_pid (tdep->pc_regnum, pc, ptid);
  write_register_pid (tdep->npc_regnum, pc + 4, ptid);
d1742 1
d1744 3
a1746 1
/* Unglobalize NAME.  */
d1749 1
a1749 1
sparc_stabs_unglobalize_name (char *name)
d1751 1
a1751 16
  /* The Sun compilers (Sun ONE Studio, Forte Developer, Sun WorkShop,
     SunPRO) convert file static variables into global values, a
     process known as globalization.  In order to do this, the
     compiler will create a unique prefix and prepend it to each file
     static variable.  For static variables within a function, this
     globalization prefix is followed by the function name (nested
     static variables within a function are supposed to generate a
     warning message, and are left alone).  The procedure is
     documented in the Stabs Interface Manual, which is distrubuted
     with the compilers, although version 4.0 of the manual seems to
     be incorrect in some places, at least for SPARC.  The
     globalization prefix is encoded into an N_OPT stab, with the form
     "G=<prefix>".  The globalization prefix always seems to start
     with a dollar sign '$'; a dot '.' is used as a seperator.  So we
     simply strip everything up until the last dot.  */

d1754 10
a1763 3
      char *p = strrchr (name, '.');
      if (p)
	return p + 1;
a1764 1

d1767 1
d1770 4
a1773 2
/* Return the appropriate register set for the core section identified
   by SECT_NAME and SECT_SIZE.  */
d1775 2
a1776 3
const struct regset *
sparc_regset_from_core_section (struct gdbarch *gdbarch,
				const char *sect_name, size_t sect_size)
d1778 46
a1823 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
d1825 2
a1826 2
  if (strcmp (sect_name, ".reg") == 0 && sect_size == tdep->sizeof_gregset)
    return tdep->gregset;
d1828 2
a1829 9
  if (strcmp (sect_name, ".reg2") == 0 && sect_size == tdep->sizeof_fpregset)
    return tdep->fpregset;

  return NULL;
}


static struct gdbarch *
sparc32_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
d1831 1
a1831 2
  struct gdbarch_tdep *tdep;
  struct gdbarch *gdbarch;
d1833 5
a1837 4
  /* If there is already a candidate, use it.  */
  arches = gdbarch_list_lookup_by_info (arches, &info);
  if (arches != NULL)
    return arches->gdbarch;
d1839 19
a1857 3
  /* Allocate space for the new architecture.  */
  tdep = XMALLOC (struct gdbarch_tdep);
  gdbarch = gdbarch_alloc (&info, tdep);
d1859 8
a1866 33
  tdep->pc_regnum = SPARC32_PC_REGNUM;
  tdep->npc_regnum = SPARC32_NPC_REGNUM;
  tdep->gregset = NULL;
  tdep->sizeof_gregset = 20 * 4;
  tdep->fpregset = NULL;
  tdep->sizeof_fpregset = 33 * 4;
  tdep->plt_entry_size = 0;

  set_gdbarch_long_double_bit (gdbarch, 128);
  set_gdbarch_long_double_format (gdbarch, &floatformat_sparc_quad);

  set_gdbarch_num_regs (gdbarch, SPARC32_NUM_REGS);
  set_gdbarch_register_name (gdbarch, sparc32_register_name);
  set_gdbarch_register_type (gdbarch, sparc32_register_type);
  set_gdbarch_num_pseudo_regs (gdbarch, SPARC32_NUM_PSEUDO_REGS);
  set_gdbarch_pseudo_register_read (gdbarch, sparc32_pseudo_register_read);
  set_gdbarch_pseudo_register_write (gdbarch, sparc32_pseudo_register_write);

  /* Register numbers of various important registers.  */
  set_gdbarch_sp_regnum (gdbarch, SPARC_SP_REGNUM); /* %sp */
  set_gdbarch_pc_regnum (gdbarch, SPARC32_PC_REGNUM); /* %pc */
  set_gdbarch_fp0_regnum (gdbarch, SPARC_F0_REGNUM); /* %f0 */

  /* Call dummy code.  */
  set_gdbarch_call_dummy_location (gdbarch, ON_STACK);
  set_gdbarch_push_dummy_code (gdbarch, sparc32_push_dummy_code);
  set_gdbarch_push_dummy_call (gdbarch, sparc32_push_dummy_call);

  set_gdbarch_return_value (gdbarch, sparc32_return_value);
  set_gdbarch_extract_struct_value_address
    (gdbarch, sparc32_extract_struct_value_address);
  set_gdbarch_stabs_argument_has_addr
    (gdbarch, sparc32_stabs_argument_has_addr);
d1868 9
a1876 4
  set_gdbarch_skip_prologue (gdbarch, sparc32_skip_prologue);

  /* Stack grows downward.  */
  set_gdbarch_inner_than (gdbarch, core_addr_lessthan);
d1878 2
a1879 3
  set_gdbarch_breakpoint_from_pc (gdbarch, sparc_breakpoint_from_pc);
  set_gdbarch_decr_pc_after_break (gdbarch, 0);
  set_gdbarch_function_start_offset (gdbarch, 0);
d1881 1
a1881 1
  set_gdbarch_frame_args_skip (gdbarch, 8);
d1883 1
a1883 1
  set_gdbarch_print_insn (gdbarch, print_insn_sparc);
d1885 110
a1994 2
  set_gdbarch_software_single_step (gdbarch, sparc_software_single_step);
  set_gdbarch_write_pc (gdbarch, sparc_write_pc);
d1996 1
a1996 17
  set_gdbarch_unwind_dummy_id (gdbarch, sparc_unwind_dummy_id);

  set_gdbarch_unwind_pc (gdbarch, sparc_unwind_pc);

  frame_base_set_default (gdbarch, &sparc32_frame_base);

  /* Hook in ABI-specific overrides, if they have been registered.  */
  gdbarch_init_osabi (info, gdbarch);

  frame_unwind_append_sniffer (gdbarch, sparc32_frame_sniffer);

  /* If we have register sets, enable the generic core file support.  */
  if (tdep->gregset && tdep->fpregset)
    set_gdbarch_regset_from_core_section (gdbarch,
					  sparc_regset_from_core_section);

  return gdbarch;
a1997 2

/* Helper functions for dealing with register windows.  */
d1999 6
a2004 2
void
sparc_supply_rwindow (struct regcache *regcache, CORE_ADDR sp, int regnum)
a2005 2
  int offset = 0;
  char buf[8];
d2007 3
d2011 1
a2011 1
  if (sp & 1)
d2013 3
a2015 4
      /* Registers are 64-bit.  */
      sp += BIAS;

      for (i = SPARC_L0_REGNUM; i <= SPARC_I7_REGNUM; i++)
d2017 1
a2017 1
	  if (regnum == i || regnum == -1)
d2019 4
a2022 2
	      target_read_memory (sp + ((i - SPARC_L0_REGNUM) * 8), buf, 8);
	      regcache_raw_supply (regcache, i, buf);
d2025 1
a2025 10
    }
  else
    {
      /* Registers are 32-bit.  Toss any sign-extension of the stack
	 pointer.  */
      sp &= 0xffffffffUL;

      /* Clear out the top half of the temporary buffer, and put the
	 register value in the bottom half if we're in 64-bit mode.  */
      if (gdbarch_ptr_bit (current_gdbarch) == 64)
d2027 2
a2028 2
	  memset (buf, 0, 4);
	  offset = 4;
d2031 10
a2040 1
      for (i = SPARC_L0_REGNUM; i <= SPARC_I7_REGNUM; i++)
d2042 2
a2043 6
	  if (regnum == i || regnum == -1)
	    {
	      target_read_memory (sp + ((i - SPARC_L0_REGNUM) * 4),
				  buf + offset, 4);
	      regcache_raw_supply (regcache, i, buf);
	    }
a2044 2
    }
}
d2046 7
a2052 7
void
sparc_collect_rwindow (const struct regcache *regcache,
		       CORE_ADDR sp, int regnum)
{
  int offset = 0;
  char buf[8];
  int i;
d2054 2
a2055 4
  if (sp & 1)
    {
      /* Registers are 64-bit.  */
      sp += BIAS;
d2057 2
a2058 3
      for (i = SPARC_L0_REGNUM; i <= SPARC_I7_REGNUM; i++)
	{
	  if (regnum == -1 || regnum == SPARC_SP_REGNUM || regnum == i)
d2060 6
a2065 2
	      regcache_raw_collect (regcache, i, buf);
	      target_write_memory (sp + ((i - SPARC_L0_REGNUM) * 8), buf, 8);
d2067 1
d2069 1
a2069 12
    }
  else
    {
      /* Registers are 32-bit.  Toss any sign-extension of the stack
	 pointer.  */
      sp &= 0xffffffffUL;

      /* Only use the bottom half if we're in 64-bit mode.  */
      if (gdbarch_ptr_bit (current_gdbarch) == 64)
	offset = 4;

      for (i = SPARC_L0_REGNUM; i <= SPARC_I7_REGNUM; i++)
d2071 6
a2076 1
	  if (regnum == -1 || regnum == SPARC_SP_REGNUM || regnum == i)
d2078 3
a2080 3
	      regcache_raw_collect (regcache, i, buf);
	      target_write_memory (sp + ((i - SPARC_L0_REGNUM) * 4),
				   buf + offset, 4);
d2083 6
d2092 9
a2100 1
/* Helper functions for dealing with register sets.  */
d2103 1
a2103 3
sparc32_supply_gregset (const struct sparc_gregset *gregset,
			struct regcache *regcache,
			int regnum, const void *gregs)
d2105 3
a2107 2
  const char *regs = gregs;
  int i;
d2109 4
a2112 3
  if (regnum == SPARC32_PSR_REGNUM || regnum == -1)
    regcache_raw_supply (regcache, SPARC32_PSR_REGNUM,
			 regs + gregset->r_psr_offset);
d2114 1
a2114 3
  if (regnum == SPARC32_PC_REGNUM || regnum == -1)
    regcache_raw_supply (regcache, SPARC32_PC_REGNUM,
			 regs + gregset->r_pc_offset);
d2116 7
a2122 3
  if (regnum == SPARC32_NPC_REGNUM || regnum == -1)
    regcache_raw_supply (regcache, SPARC32_NPC_REGNUM,
			 regs + gregset->r_npc_offset);
d2124 5
a2128 3
  if (regnum == SPARC32_Y_REGNUM || regnum == -1)
    regcache_raw_supply (regcache, SPARC32_Y_REGNUM,
			 regs + gregset->r_y_offset);
d2130 1
a2130 4
  if (regnum == SPARC_G0_REGNUM || regnum == -1)
    regcache_raw_supply (regcache, SPARC_G0_REGNUM, NULL);

  if ((regnum >= SPARC_G1_REGNUM && regnum <= SPARC_O7_REGNUM) || regnum == -1)
d2132 3
a2134 1
      int offset = gregset->r_g1_offset;
d2136 11
a2146 1
      for (i = SPARC_G1_REGNUM; i <= SPARC_O7_REGNUM; i++)
d2148 2
a2149 3
	  if (regnum == i || regnum == -1)
	    regcache_raw_supply (regcache, i, regs + offset);
	  offset += 4;
d2153 15
a2167 1
  if ((regnum >= SPARC_L0_REGNUM && regnum <= SPARC_I7_REGNUM) || regnum == -1)
d2169 4
a2172 3
      /* Not all of the register set variants include Locals and
         Inputs.  For those that don't, we read them off the stack.  */
      if (gregset->r_l0_offset == -1)
d2174 2
a2175 4
	  ULONGEST sp;

	  regcache_cooked_read_unsigned (regcache, SPARC_SP_REGNUM, &sp);
	  sparc_supply_rwindow (regcache, sp, regnum);
d2179 1
a2179 1
	  int offset = gregset->r_l0_offset;
d2181 9
a2189 1
	  for (i = SPARC_L0_REGNUM; i <= SPARC_I7_REGNUM; i++)
d2191 2
a2192 3
	      if (regnum == i || regnum == -1)
		regcache_raw_supply (regcache, i, regs + offset);
	      offset += 4;
d2194 19
a2214 1
}
d2216 2
a2217 7
void
sparc32_collect_gregset (const struct sparc_gregset *gregset,
			 const struct regcache *regcache,
			 int regnum, void *gregs)
{
  char *regs = gregs;
  int i;
d2219 2
a2220 3
  if (regnum == SPARC32_PSR_REGNUM || regnum == -1)
    regcache_raw_collect (regcache, SPARC32_PSR_REGNUM,
			  regs + gregset->r_psr_offset);
d2222 3
a2224 3
  if (regnum == SPARC32_PC_REGNUM || regnum == -1)
    regcache_raw_collect (regcache, SPARC32_PC_REGNUM,
			  regs + gregset->r_pc_offset);
d2226 3
a2228 3
  if (regnum == SPARC32_NPC_REGNUM || regnum == -1)
    regcache_raw_collect (regcache, SPARC32_NPC_REGNUM,
			  regs + gregset->r_npc_offset);
d2230 5
a2234 3
  if (regnum == SPARC32_Y_REGNUM || regnum == -1)
    regcache_raw_collect (regcache, SPARC32_Y_REGNUM,
			  regs + gregset->r_y_offset);
d2236 4
a2239 1
  if ((regnum >= SPARC_G1_REGNUM && regnum <= SPARC_O7_REGNUM) || regnum == -1)
d2241 1
a2241 1
      int offset = gregset->r_g1_offset;
d2243 4
a2246 7
      /* %g0 is always zero.  */
      for (i = SPARC_G1_REGNUM; i <= SPARC_O7_REGNUM; i++)
	{
	  if (regnum == i || regnum == -1)
	    regcache_raw_collect (regcache, i, regs + offset);
	  offset += 4;
	}
d2249 22
a2270 1
  if ((regnum >= SPARC_L0_REGNUM && regnum <= SPARC_I7_REGNUM) || regnum == -1)
d2272 1
a2272 3
      /* Not all of the register set variants include Locals and
         Inputs.  For those that don't, we read them off the stack.  */
      if (gregset->r_l0_offset != -1)
d2274 9
a2282 1
	  int offset = gregset->r_l0_offset;
d2284 398
a2681 1
	  for (i = SPARC_L0_REGNUM; i <= SPARC_I7_REGNUM; i++)
d2683 5
a2687 3
	      if (regnum == i || regnum == -1)
		regcache_raw_collect (regcache, i, regs + offset);
	      offset += 4;
d2693 53
a2745 3
void
sparc32_supply_fpregset (struct regcache *regcache,
			 int regnum, const void *fpregs)
d2747 28
a2774 2
  const char *regs = fpregs;
  int i;
d2776 4
a2779 1
  for (i = 0; i < 32; i++)
d2781 13
a2793 2
      if (regnum == (SPARC_F0_REGNUM + i) || regnum == -1)
	regcache_raw_supply (regcache, SPARC_F0_REGNUM + i, regs + (i * 4));
d2796 38
a2833 2
  if (regnum == SPARC32_FSR_REGNUM || regnum == -1)
    regcache_raw_supply (regcache, SPARC32_FSR_REGNUM, regs + (32 * 4) + 4);
d2836 2
a2837 3
void
sparc32_collect_fpregset (const struct regcache *regcache,
			  int regnum, void *fpregs)
d2839 2
a2840 2
  char *regs = fpregs;
  int i;
d2842 4
a2845 1
  for (i = 0; i < 32; i++)
d2847 6
a2852 2
      if (regnum == (SPARC_F0_REGNUM + i) || regnum == -1)
	regcache_raw_collect (regcache, SPARC_F0_REGNUM + i, regs + (i * 4));
d2854 76
d2931 80
a3010 2
  if (regnum == SPARC32_FSR_REGNUM || regnum == -1)
    regcache_raw_collect (regcache, SPARC32_FSR_REGNUM, regs + (32 * 4) + 4);
a3011 1

d3013 15
a3027 1
/* SunOS 4.  */
d3029 2
a3030 2
/* From <machine/reg.h>.  */
const struct sparc_gregset sparc32_sunos4_gregset =
d3032 306
a3337 10
  0 * 4,			/* %psr */
  1 * 4,			/* %pc */
  2 * 4,			/* %npc */
  3 * 4,			/* %y */
  -1,				/* %wim */
  -1,				/* %tbr */
  4 * 4,			/* %g1 */
  -1				/* %l0 */
};

d3339 2
a3340 2
/* Provide a prototype to silence -Wmissing-prototypes.  */
void _initialize_sparc_tdep (void);
d3342 2
a3343 2
void
_initialize_sparc_tdep (void)
d3345 19
a3363 1
  register_gdbarch_init (bfd_arch_sparc, sparc32_gdbarch_init);
@


1.39.10.3
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d99 1
a99 3
  /* If we can't read the instruction at PC, return zero.  */
  if (target_read_memory (pc, buf, sizeof (buf)))
    return 0;
a106 50

/* OpenBSD/sparc includes StackGhost, which according to the author's
   website http://stackghost.cerias.purdue.edu "... transparently and
   automatically protects applications' stack frames; more
   specifically, it guards the return pointers.  The protection
   mechanisms require no application source or binary modification and
   imposes only a negligible performance penalty."

   The same website provides the following description of how
   StackGhost works:

   "StackGhost interfaces with the kernel trap handler that would
   normally write out registers to the stack and the handler that
   would read them back in.  By XORing a cookie into the
   return-address saved in the user stack when it is actually written
   to the stack, and then XOR it out when the return-address is pulled
   from the stack, StackGhost can cause attacker corrupted return
   pointers to behave in a manner the attacker cannot predict.
   StackGhost can also use several unused bits in the return pointer
   to detect a smashed return pointer and abort the process."

   For GDB this means that whenever we're reading %i7 from a stack
   frame's window save area, we'll have to XOR the cookie.

   More information on StackGuard can be found on in:

   Mike Frantzen and Mike Shuey. "StackGhost: Hardware Facilitated
   Stack Protection."  2001.  Published in USENIX Security Symposium
   '01.  */

/* Fetch StackGhost Per-Process XOR cookie.  */

ULONGEST
sparc_fetch_wcookie (void)
{
  struct target_ops *ops = &current_target;
  char buf[8];
  int len;

  len = target_read_partial (ops, TARGET_OBJECT_WCOOKIE, NULL, buf, 0, 8);
  if (len == -1)
    return 0;

  /* We should have either an 32-bit or an 64-bit cookie.  */
  gdb_assert (len == 4 || len == 8);

  return extract_unsigned_integer (buf, len);
}


a666 23
  /* Handle StackGhost.  */
  {
    ULONGEST wcookie = sparc_fetch_wcookie ();

    if (wcookie != 0 && !cache->frameless_p && regnum == SPARC_I7_REGNUM)
      {
	*optimizedp = 0;
	*lvalp = not_lval;
	*addrp = 0;
	*realnump = -1;
	if (valuep)
	  {
	    CORE_ADDR addr = cache->base + (regnum - SPARC_L0_REGNUM) * 4;
	    ULONGEST i7;

	    /* Read the value in from memory.  */
	    i7 = get_frame_memory_unsigned (next_frame, addr, 4);
	    store_unsigned_integer (valuep, 4, i7 ^ wcookie);
	  }
	return;
      }
  }

a836 12
#if 0
/* NOTE: cagney/2004-01-17: For the moment disable this method.  The
   architecture and CORE-gdb will need new code (and a replacement for
   DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS) before this can be made to
   work robustly.  Here is a possible function signature: */
/* NOTE: cagney/2004-01-17: So far only the 32-bit SPARC ABI has been
   identifed as having a way to robustly recover the address of a
   struct-convention return-value (after the function has returned).
   For all other ABIs so far examined, the calling convention makes no
   guarenteed that the register containing the return-value will be
   preserved and hence that the return-value's address can be
   recovered.  */
a848 1
#endif
d1018 1
a1018 1
  if (strcmp (sect_name, ".reg") == 0 && sect_size >= tdep->sizeof_gregset)
d1021 1
a1021 1
  if (strcmp (sect_name, ".reg2") == 0 && sect_size >= tdep->sizeof_fpregset)
d1046 1
a1046 1
  tdep->sizeof_gregset = 0;
d1048 1
a1048 1
  tdep->sizeof_fpregset = 0;
d1072 2
d1083 2
d1105 1
a1105 1
  if (tdep->gregset)
a1154 10

	      /* Handle StackGhost.  */
	      if (i == SPARC_I7_REGNUM)
		{
		  ULONGEST wcookie = sparc_fetch_wcookie ();
		  ULONGEST i7 = extract_unsigned_integer (buf + offset, 4);

		  store_unsigned_integer (buf + offset, 4, i7 ^ wcookie);
		}

a1197 10

	      /* Handle StackGhost.  */
	      if (i == SPARC_I7_REGNUM)
		{
		  ULONGEST wcookie = sparc_fetch_wcookie ();
		  ULONGEST i7 = extract_unsigned_integer (buf + offset, 4);

		  store_unsigned_integer (buf + offset, 4, i7 ^ wcookie);
		}

@


1.39.8.1
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d318 1
a318 1
	      || deprecated_frame_in_dummy (fi->next->next))
d491 1
a491 1
	     deprecated_frame_in_dummy (frame->next)) &&
d959 1
a959 1
	deprecated_read_register_gen (regnum, raw_buffer);
d993 5
a997 6
      deprecated_read_register_bytes (REGISTER_BYTE (PC_REGNUM),
				      &register_temp[0],
				      REGISTER_RAW_SIZE (PC_REGNUM) * 7);
      deprecated_read_register_bytes (REGISTER_BYTE (PSTATE_REGNUM), 
				      &register_temp[7 * SPARC_INTREG_SIZE],
				      REGISTER_RAW_SIZE (PSTATE_REGNUM));
d1003 2
a1004 3
      deprecated_read_register_bytes (REGISTER_BYTE (Y_REGNUM),
				      &register_temp[0],
				      REGISTER_RAW_SIZE (Y_REGNUM) * 8);
d1007 7
a1013 7
  deprecated_read_register_bytes (REGISTER_BYTE (O0_REGNUM),
				  &register_temp[8 * SPARC_INTREG_SIZE],
				  SPARC_INTREG_SIZE * 8);

  deprecated_read_register_bytes (REGISTER_BYTE (G0_REGNUM),
				  &register_temp[16 * SPARC_INTREG_SIZE],
				  SPARC_INTREG_SIZE * 8);
d1016 3
a1018 3
    deprecated_read_register_bytes (REGISTER_BYTE (FP0_REGNUM),
				    &register_temp[24 * SPARC_INTREG_SIZE],
				    FP_REGISTER_BYTES);
d1240 2
a1241 2
	  deprecated_write_register_bytes (REGISTER_BYTE (FP0_REGNUM),
					   raw_buffer, FP_REGISTER_BYTES);
d1248 1
a1248 1
	      deprecated_write_register_gen (FPS_REGNUM, raw_buffer);
d1253 1
a1253 1
	      deprecated_write_register_gen (CPS_REGNUM, raw_buffer);
d1260 2
a1261 2
      deprecated_write_register_bytes (REGISTER_BYTE (G1_REGNUM), raw_buffer,
				       7 * SPARC_INTREG_SIZE);
d1313 2
a1314 2
      deprecated_write_register_bytes (REGISTER_BYTE (O0_REGNUM), raw_buffer,
				       SPARC_INTREG_SIZE * 8);
d1316 2
a1317 2
      deprecated_write_register_bytes (REGISTER_BYTE (L0_REGNUM), reg_temp,
				       SPARC_INTREG_SIZE * 16);
d1612 1
a1612 1
      deprecated_read_register_gen (regi, (char *) (regp + regi) + offset);
d1615 1
a1615 1
    deprecated_read_register_gen (PC_REGNUM, (char *) (regp + R_PC) + offset);
d1618 1
a1618 1
    deprecated_read_register_gen (NPC_REGNUM, (char *) (regp + R_nPC) + offset);
d1621 1
a1621 1
    deprecated_read_register_gen (Y_REGNUM, (char *) (regp + R_Y) + offset);
d1627 1
a1627 1
	deprecated_read_register_gen (CCR_REGNUM, ((char *) (regp + R_CCR)) + offset);
d1631 1
a1631 1
	deprecated_read_register_gen (FPRS_REGNUM, ((char *) (regp + R_FPRS)) + offset);
d1635 1
a1635 1
	deprecated_read_register_gen (ASI_REGNUM, ((char *) (regp + R_ASI)) + offset);
d1642 1
a1642 1
	deprecated_read_register_gen (PS_REGNUM, ((char *) (regp + R_PS)) + offset);
d1658 1
a1658 1
	deprecated_read_register_gen (WIM_REGNUM, ((char *) (regp + R_WIM)) + offset);
d1661 1
a1661 1
	deprecated_read_register_gen (WIM_REGNUM, NULL);
d1666 1
a1666 1
	deprecated_read_register_gen (TBR_REGNUM, ((char *) (regp + R_TBR)) + offset);
d1669 1
a1669 1
	deprecated_read_register_gen (TBR_REGNUM, NULL);
d1730 1
a1730 1
	  from = (char *) &deprecated_registers[REGISTER_BYTE (regi)];
d1739 1
a1739 1
	from = (char *)&deprecated_registers[REGISTER_BYTE (FPS_REGNUM)];
d1861 1
a1861 1
static void
a2030 140

static void
sparc_print_registers (struct gdbarch *gdbarch,
		       struct ui_file *file,
		       struct frame_info *frame,
		       int regnum, int print_all,
		       void (*print_register_hook) (int))
{
  int i;
  const int numregs = NUM_REGS + NUM_PSEUDO_REGS;
  char *raw_buffer = alloca (MAX_REGISTER_RAW_SIZE);
  char *virtual_buffer = alloca (MAX_REGISTER_VIRTUAL_SIZE);

  for (i = 0; i < numregs; i++)
    {
      /* Decide between printing all regs, non-float / vector regs, or
         specific reg.  */
      if (regnum == -1)
	{
	  if (!print_all)
	    {
	      if (TYPE_CODE (REGISTER_VIRTUAL_TYPE (i)) == TYPE_CODE_FLT)
		continue;
	      if (TYPE_VECTOR (REGISTER_VIRTUAL_TYPE (i)))
		continue;
	    }
	}
      else
	{
	  if (i != regnum)
	    continue;
	}

      /* If the register name is empty, it is undefined for this
         processor, so don't display anything.  */
      if (REGISTER_NAME (i) == NULL || *(REGISTER_NAME (i)) == '\0')
	continue;

      fputs_filtered (REGISTER_NAME (i), file);
      print_spaces_filtered (15 - strlen (REGISTER_NAME (i)), file);

      /* Get the data in raw format.  */
      if (! frame_register_read (frame, i, raw_buffer))
	{
	  fprintf_filtered (file, "*value not available*\n");
	  continue;
	}

      /* FIXME: cagney/2002-08-03: This code shouldn't be necessary.
         The function frame_register_read() should have returned the
         pre-cooked register so no conversion is necessary.  */
      /* Convert raw data to virtual format if necessary.  */
      if (REGISTER_CONVERTIBLE (i))
	{
	  REGISTER_CONVERT_TO_VIRTUAL (i, REGISTER_VIRTUAL_TYPE (i),
				       raw_buffer, virtual_buffer);
	}
      else
	{
	  memcpy (virtual_buffer, raw_buffer,
		  REGISTER_VIRTUAL_SIZE (i));
	}

      /* If virtual format is floating, print it that way, and in raw
         hex.  */
      if (TYPE_CODE (REGISTER_VIRTUAL_TYPE (i)) == TYPE_CODE_FLT)
	{
	  int j;

	  val_print (REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0,
		     file, 0, 1, 0, Val_pretty_default);

	  fprintf_filtered (file, "\t(raw 0x");
	  for (j = 0; j < REGISTER_RAW_SIZE (i); j++)
	    {
	      int idx;
	      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
		idx = j;
	      else
		idx = REGISTER_RAW_SIZE (i) - 1 - j;
	      fprintf_filtered (file, "%02x", (unsigned char) raw_buffer[idx]);
	    }
	  fprintf_filtered (file, ")");
	}
      else
	{
	  /* Print the register in hex.  */
	  val_print (REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0,
		     file, 'x', 1, 0, Val_pretty_default);
          /* If not a vector register, print it also according to its
             natural format.  */
	  if (TYPE_VECTOR (REGISTER_VIRTUAL_TYPE (i)) == 0)
	    {
	      fprintf_filtered (file, "\t");
	      val_print (REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0,
			 file, 0, 1, 0, Val_pretty_default);
	    }
	}

      /* Some sparc specific info.  */
      if (print_register_hook != NULL)
	print_register_hook (i);

      fprintf_filtered (file, "\n");
    }
}

static void
sparc_print_registers_info (struct gdbarch *gdbarch,
			    struct ui_file *file,
			    struct frame_info *frame,
			    int regnum, int print_all)
{
  sparc_print_registers (gdbarch, file, frame, regnum, print_all,
			 sparc_print_register_hook);
}

void
sparc_do_registers_info (int regnum, int all)
{
  sparc_print_registers_info (current_gdbarch, gdb_stdout, selected_frame,
			      regnum, all);
}

static void
sparclet_print_registers_info (struct gdbarch *gdbarch,
			       struct ui_file *file,
			       struct frame_info *frame,
			       int regnum, int print_all)
{
  sparc_print_registers (gdbarch, file, frame, regnum, print_all, NULL);
}

void
sparclet_do_registers_info (int regnum, int all)
{
  sparclet_print_registers_info (current_gdbarch, gdb_stdout, selected_frame,
				 regnum, all);
}

d2102 1
a2102 1
	deprecated_write_register_gen (O0_REGNUM + oregnum, m_arg->contents + j);
d2158 1
a2158 1
      deprecated_write_register_gen (regno, buffer);
d2161 1
a2161 2
    deprecated_write_register_bytes (REGISTER_BYTE (regno), valbuf,
				     TYPE_LENGTH (type));
d2168 2
a2169 2
  deprecated_write_register_bytes (REGISTER_BYTE (O0_REGNUM), valbuf,
				   TYPE_LENGTH (type));
d2430 3
a2432 3
	      deprecated_write_register_bytes (REGISTER_BYTE (fpreg),
					       VALUE_CONTENTS (args[i]),
					       len);
d2443 1
a2443 1
	      deprecated_write_register_gen (oreg, VALUE_CONTENTS (copyarg) + j);
@


1.39.8.2
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d317 1
a317 1
	  && ((get_frame_type (fi->next->next) == SIGTRAMP_FRAME)
d323 1
a323 1
	  fi->frame = get_frame_base (fi->next);
d454 1
a454 1
  if ((get_frame_type (frame) == SIGTRAMP_FRAME))
d490 1
a490 1
	    ((get_frame_type (frame->next) == SIGTRAMP_FRAME) ||
d819 1
a819 1
      if (deprecated_selected_frame == NULL)
d822 1
a822 1
      frame = get_prev_frame (deprecated_selected_frame);
d851 1
a851 1
	  && frame1->pc <= get_frame_base (frame1))
d1115 1
a1115 1
  CORE_ADDR frame_addr = get_frame_base (fi);
d1125 1
a1125 1
      && fi->pc <= get_frame_base (fi))
d1208 1
a1208 1
  saved_regs_addr[SP_REGNUM] = get_frame_base (fi);
d1213 5
a1217 6
   Note that the values stored in fsr by
   deprecated_get_frame_saved_regs are *in the context of the called
   frame*.  What this means is that the i regs of fsr must be restored
   into the o regs of the (calling) frame that we pop into.  We don't
   care about the output regs of the calling frame, since unless it's
   a dummy frame, it won't have any output regs in it.
d1874 2
a1875 2
      if (frame_register_read (deprecated_selected_frame, regno, value)
	  && frame_register_read (deprecated_selected_frame, regno + 1, value + 4))
d1883 2
a1884 2
	  if (frame_register_read (deprecated_selected_frame, regno + 2, value + 8)
	      && frame_register_read (deprecated_selected_frame, regno + 3, value + 12))
d1903 2
a1904 2
      if (frame_register_read (deprecated_selected_frame, regno, value)
	  && frame_register_read (deprecated_selected_frame, regno + 1, value + 8))
d2153 1
a2153 1
  sparc_print_registers_info (current_gdbarch, gdb_stdout, deprecated_selected_frame,
d2169 2
a2170 2
  sparclet_print_registers_info (current_gdbarch, gdb_stdout,
				 deprecated_selected_frame, regnum, all);
d3152 1
d3155 1
d3184 1
a3184 1
  set_gdbarch_deprecated_use_generic_dummy_frames (gdbarch, 0);
d3202 1
a3202 1
      set_gdbarch_deprecated_pc_in_call_dummy (gdbarch, deprecated_pc_in_call_dummy_on_stack);
d3253 1
a3253 1
      set_gdbarch_deprecated_pc_in_call_dummy (gdbarch, deprecated_pc_in_call_dummy_at_entry_point);
d3257 1
d3301 1
a3301 1
      set_gdbarch_deprecated_pc_in_call_dummy (gdbarch, deprecated_pc_in_call_dummy_on_stack);
d3309 1
a3309 1
      set_gdbarch_deprecated_pc_in_call_dummy (gdbarch, deprecated_pc_in_call_dummy_at_entry_point);
d3313 1
@


1.39.8.3
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d4 1
a4 1
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation,
d114 2
d297 2
a298 1
  frame_extra_info_zalloc (fi, sizeof (struct frame_extra_info));
d301 4
a304 6
  get_frame_extra_info (fi)->bottom =
    (get_next_frame (fi)
     ? (get_frame_base (fi) == get_frame_base (get_next_frame (fi))
	? get_frame_extra_info (get_next_frame (fi))->bottom
	: get_frame_base (get_next_frame (fi)))
     : read_sp ());
d308 1
a308 1
  if (get_next_frame (fi))
d316 4
a319 4
      if (get_next_frame (get_next_frame (fi)) != NULL
	  && ((get_frame_type (get_next_frame (get_next_frame (fi))) == SIGTRAMP_FRAME)
	      || deprecated_frame_in_dummy (get_next_frame (get_next_frame (fi))))
	  && frameless_look_for_prologue (get_next_frame (fi)))
d323 2
a324 3
	  deprecated_update_frame_base_hack (fi, get_frame_base (get_next_frame (fi)));
	  get_frame_extra_info (fi)->bottom =
	    get_frame_extra_info (get_next_frame (fi))->bottom;
d330 1
a330 1
	  deprecated_update_frame_base_hack (fi, extract_address (buf, REGISTER_RAW_SIZE (FP_REGNUM)));
d332 2
a333 2
	  if (GDB_TARGET_IS_SPARC64 && (get_frame_base (fi) & 1))
	    deprecated_update_frame_base_hack (fi, get_frame_base (fi) + 2047);
d339 3
a341 3
  get_frame_extra_info (fi)->flat = 0;
  get_frame_extra_info (fi)->in_prologue = 0;
  if (find_pc_partial_function (get_frame_pc (fi), &name, &prologue_start, &prologue_end))
d365 1
a365 1
	      get_frame_extra_info (fi)->flat = 1;
d367 1
a367 1
	      get_frame_extra_info (fi)->sp_offset = offset;
d371 1
a371 1
	      deprecated_update_frame_base_hack (fi, extract_address (buf, REGISTER_RAW_SIZE (I7_REGNUM)));
d373 2
a374 2
	      if (GDB_TARGET_IS_SPARC64 && (get_frame_base (fi) & 1))
		deprecated_update_frame_base_hack (fi, get_frame_base (fi) + 2047);
d377 2
a378 2
	      get_frame_extra_info (fi)->fp_addr = 
		get_frame_base (fi) + get_frame_extra_info (fi)->sp_offset + X_SIMM13 (insn);
d381 1
a381 1
	      get_frame_extra_info (fi)->pc_addr = 0;
d387 2
a388 2
		get_frame_extra_info (fi)->pc_addr = 
		  get_frame_base (fi) + get_frame_extra_info (fi)->sp_offset + X_SIMM13 (insn);
d402 1
a402 1
	    prologue_end = get_frame_pc (fi);
d405 1
a405 1
	  if (get_frame_pc (fi) < prologue_end)
d407 1
a407 1
	      for (addr = prologue_start; addr < get_frame_pc (fi); addr += 4)
d413 1
a413 1
	      if (addr >= get_frame_pc (fi))
d415 2
a416 2
		  get_frame_extra_info (fi)->in_prologue = 1;
		  deprecated_update_frame_base_hack (fi, read_register (SP_REGNUM));
d421 1
a421 1
  if (get_next_frame (fi) && get_frame_base (fi) == 0)
d424 2
a425 2
      deprecated_update_frame_base_hack (fi, get_frame_base (get_next_frame (fi)));
      deprecated_update_frame_pc_hack (fi, get_frame_pc (get_next_frame (fi)));
d472 1
a472 1
      find_pc_partial_function (get_frame_pc (frame), &name,
d488 4
a491 4
  else if (get_frame_extra_info (frame)->in_prologue ||
	   (get_next_frame (frame) != NULL &&
	    ((get_frame_type (get_next_frame (frame)) == SIGTRAMP_FRAME) ||
	     deprecated_frame_in_dummy (get_next_frame (frame))) &&
d500 2
a501 2
  if (get_frame_extra_info (frame)->flat)
    addr = get_frame_extra_info (frame)->pc_addr;
d503 1
a503 1
    addr = get_frame_extra_info (frame)->bottom + FRAME_SAVED_I0 +
d537 2
a538 2
  get_frame_extra_info (frame)->bottom = argv[1];
  deprecated_update_frame_pc_hack (frame, FRAME_SAVED_PC (frame));
d679 1
a679 1
	      get_frame_base (fi) + get_frame_extra_info (fi)->sp_offset + X_SIMM13 (insn);
d828 1
a828 1
  frame1 = get_next_frame (frame);
d838 1
a838 1
	  store_address (raw_buffer, REGISTER_RAW_SIZE (regnum), get_frame_pc (frame));
d849 3
a851 4
      if (get_frame_pc (frame1) >= (get_frame_extra_info (frame1)->bottom
				    ? get_frame_extra_info (frame1)->bottom
				    : read_sp ())
	  && get_frame_pc (frame1) <= get_frame_base (frame1))
d857 1
a857 1
	    addr = get_frame_base (frame1) + (regnum - G0_REGNUM) * SPARC_INTREG_SIZE
d865 1
a865 1
	    addr = (get_frame_extra_info (get_prev_frame (frame1))->bottom
d874 1
a874 1
	    addr = (get_frame_extra_info (get_prev_frame (frame1))->bottom
d878 1
a878 1
	    addr = get_frame_base (frame1) + (regnum - O0_REGNUM) * SPARC_INTREG_SIZE
d882 1
a882 1
	    addr = get_frame_base (frame1) + (regnum - FP0_REGNUM) * 4
d886 1
a886 1
	    addr = get_frame_base (frame1) + 32 * 4 + (regnum - FP0_REGNUM - 32) * 8
d889 1
a889 1
	    addr = get_frame_base (frame1) + (regnum - Y_REGNUM) * SPARC_INTREG_SIZE
d892 1
a892 1
      else if (get_frame_extra_info (frame1)->flat)
d896 1
a896 1
	    addr = get_frame_extra_info (frame1)->pc_addr;
d898 1
a898 1
	    addr = get_frame_extra_info (frame1)->fp_addr;
d907 1
a907 1
	      find_pc_partial_function (get_frame_pc (frame1), NULL, &func_start, NULL);
d916 1
a916 1
	    addr = (get_frame_extra_info (get_prev_frame (frame1))->bottom
d920 1
a920 1
	    addr = (get_frame_extra_info (get_prev_frame (frame1))->bottom
d933 1
a933 1
      frame1 = get_next_frame (frame1);
d1123 3
a1125 4
  if (get_frame_pc (fi) >= (get_frame_extra_info (fi)->bottom
			    ? get_frame_extra_info (fi)->bottom
			    : read_sp ())
      && get_frame_pc (fi) <= get_frame_base (fi))
d1160 2
a1161 3
      frame_addr = (get_frame_extra_info (fi)->bottom
		    ? get_frame_extra_info (fi)->bottom
		    : read_sp ());
d1163 1
a1163 1
  else if (get_frame_extra_info (fi)->flat)
d1166 1
a1166 1
      find_pc_partial_function (get_frame_pc (fi), NULL, &func_start, NULL);
d1170 2
a1171 2
      saved_regs_addr[RP_REGNUM] = get_frame_extra_info (fi)->pc_addr;
      saved_regs_addr[I7_REGNUM] = get_frame_extra_info (fi)->fp_addr;
d1176 2
a1177 3
      frame_addr = (get_frame_extra_info (fi)->bottom
		    ? get_frame_extra_info (fi)->bottom
		    : read_sp ());
d1187 1
a1187 1
  if (get_next_frame (fi))
d1189 1
a1189 1
      if (get_frame_extra_info (fi)->flat)
d1191 1
a1191 1
	  saved_regs_addr[O7_REGNUM] = get_frame_extra_info (fi)->pc_addr;
d1197 2
a1198 3
	  (get_frame_extra_info (get_next_frame (fi))->bottom
	   ? get_frame_extra_info (get_next_frame (fi))->bottom
	   : read_sp ());
d1267 1
a1267 1
  if (get_frame_extra_info (frame)->flat)
d1290 1
a1290 1
      write_sp (get_frame_base (frame));
d1344 1
a1344 1
  else if (get_frame_extra_info (frame)->flat)
d1346 1
a1346 1
      if (get_frame_extra_info (frame)->pc_addr)
d1348 1
a1348 1
			read_memory_integer (get_frame_extra_info (frame)->pc_addr,
d1860 2
a1861 1
/* Pretty print various registers.  */
d2689 1
a2689 1
  if (fi && get_frame_extra_info (fi) && get_frame_extra_info (fi)->flat)
d2691 2
a2692 2
		     paddr_nz (get_frame_extra_info (fi)->pc_addr), 
		     paddr_nz (get_frame_extra_info (fi)->fp_addr));
d3010 8
d3080 1
d3106 1
a3106 2
  if (info.abfd != NULL
      && info.osabi == GDB_OSABI_UNKNOWN)
d3108 7
a3114 3
      /* If it's an ELF file, assume it's Solaris.  */
      if (bfd_get_flavour (info.abfd) == bfd_target_elf_flavour)
	info.osabi = GDB_OSABI_SOLARIS;
d3118 9
a3126 3
  arches = gdbarch_list_lookup_by_info (arches, &info);
  if (arches != NULL)
    return arches->gdbarch;
d3136 2
d3141 2
d3359 1
d3370 1
d3381 1
d3392 1
d3403 1
d3414 1
d3425 1
d3436 1
d3448 1
a3448 1
  gdbarch_init_osabi (info, gdbarch);
d3461 2
a3462 16
  fprintf_unfiltered (file, "sparc_dump_tdep: has_fpu = %d\n",
		      tdep->has_fpu);
  fprintf_unfiltered (file, "sparc_dump_tdep: fp_register_bytes = %d\n",
		      tdep->fp_register_bytes);
  fprintf_unfiltered (file, "sparc_dump_tdep: y_regnum = %d\n",
		      tdep->y_regnum);
  fprintf_unfiltered (file, "sparc_dump_tdep: fp_max_regnum = %d\n",
		      tdep->fp_max_regnum);
  fprintf_unfiltered (file, "sparc_dump_tdep: intreg_size = %d\n",
		      tdep->intreg_size);
  fprintf_unfiltered (file, "sparc_dump_tdep: reg_save_offset = %d\n",
		      tdep->reg_save_offset);
  fprintf_unfiltered (file, "sparc_dump_tdep: call_dummy_call_offset = %d\n",
		      tdep->call_dummy_call_offset);
  fprintf_unfiltered (file, "sparc_dump_tdep: print_insn_match = %d\n",
		      tdep->print_insn_mach);
@


1.39.8.4
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d434 2
a435 14
     sparc_init_prev_frame.
     
     Note:  kevinb/2003-02-18:  The constant 1 used to be returned
     here, but, after some recent changes to frame_chain_valid(),
     this value is no longer suitable for causing frame_chain_valid()
     to "not worry about the chain value."  The constant ~0 (i.e,
     0xfff...) causes the failing test in frame_chain_valid() to
     succeed thus preserving the "not worry" property.  I had considered
     using something like ``get_frame_base (frame) + 1''.  However, I think
     a constant value is better, because when debugging this problem,
     I knew that something funny was going on as soon as I saw the
     constant 1 being used as the frame chain elsewhere in GDB.  */

  return ~ (CORE_ADDR) 0;
d3136 1
a3136 1
  set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, sparc_frame_init_saved_regs);
d3142 1
a3142 1
  set_gdbarch_deprecated_init_extra_frame_info (gdbarch, sparc_init_extra_frame_info);
d3147 2
a3148 2
  set_gdbarch_deprecated_max_register_raw_size (gdbarch, 8);
  set_gdbarch_deprecated_max_register_virtual_size (gdbarch, 8);
d3151 1
a3151 1
  set_gdbarch_deprecated_push_dummy_frame (gdbarch, sparc_push_dummy_frame);
@


1.39.8.5
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@a43 1
#include "gdb_assert.h"
d68 4
a71 6
#if 0
// OBSOLETE #if defined(TARGET_SPARCLET) || defined(TARGET_SPARCLITE)
// OBSOLETE #define SPARC_HAS_FPU 0
// OBSOLETE #else
// OBSOLETE #define SPARC_HAS_FPU 1
// OBSOLETE #endif
a72 1
#define SPARC_HAS_FPU 1
d106 1
a106 3
#if 0
    // OBSOLETE     int has_fpu;
#endif
d136 5
a140 7
#if 0
// OBSOLETE /* Some machines, such as Fujitsu SPARClite 86x, have a bi-endian mode
// OBSOLETE    where instructions are big-endian and data are little-endian.
// OBSOLETE    This flag is set when we detect that the target is of this type. */
// OBSOLETE 
// OBSOLETE int bi_endian = 0;
#endif
d329 3
a331 3
	  ULONGEST tmp;
	  frame_read_unsigned_register (fi, FP_REGNUM, &tmp);
	  deprecated_update_frame_base_hack (fi, tmp);
d370 2
a371 5
	      {
		ULONGEST tmp;
		frame_read_unsigned_register (fi, I7_REGNUM, &tmp);
		deprecated_update_frame_base_hack (fi, tmp);
	      }
d432 3
a434 3
  /* Value that will cause DEPRECATED_FRAME_CHAIN_VALID to not worry
     about the chain value.  If it really is zero, we detect it later
     in sparc_init_prev_frame.
d436 10
a445 11
     Note: kevinb/2003-02-18: The constant 1 used to be returned here,
     but, after some recent changes to legacy_frame_chain_valid(),
     this value is no longer suitable for causing
     legacy_frame_chain_valid() to "not worry about the chain value."
     The constant ~0 (i.e, 0xfff...) causes the failing test in
     legacy_frame_chain_valid() to succeed thus preserving the "not
     worry" property.  I had considered using something like
     ``get_frame_base (frame) + 1''.  However, I think a constant
     value is better, because when debugging this problem, I knew that
     something funny was going on as soon as I saw the constant 1
     being used as the frame chain elsewhere in GDB.  */
d490 3
a492 5
      {
	ULONGEST tmp;
	frame_read_unsigned_register (frame, O0_REGNUM + 2, &tmp);
	sigcontext_addr = tmp;
      }
d508 3
a510 3
      ULONGEST tmp;
      frame_read_unsigned_register (frame, O7_REGNUM, &tmp);
      return PC_ADJUST (tmp);
d550 1
a550 1
  deprecated_update_frame_pc_hack (frame, DEPRECATED_FRAME_SAVED_PC (frame));
d939 2
a940 3
	      int realnum;
	      frame_register (frame1, (regnum - O0_REGNUM + I0_REGNUM),
			      optimized, lval, addrp, &realnum, raw_buffer);
d1037 1
a1037 1
  DEPRECATED_DUMMY_WRITE_SP (sp);
d1093 4
a1096 4
   frames save all registers).

   NOTE: cagney/2003-03-12: Since pop_frame has been rewritten to use
   frame_unwind_register() the need for this function is questionable.
d1130 3
a1132 1
  gdb_assert (fi != NULL);
d1307 1
a1307 1
      DEPRECATED_DUMMY_WRITE_SP (get_frame_base (frame));
d1372 6
a1377 3
	  ULONGEST tmp;
	  frame_read_unsigned_register (frame, O7_REGNUM, &tmp);
	  pc = PC_ADJUST (tmp);
d2174 15
a2188 17
#if 0
// OBSOLETE static void
// OBSOLETE sparclet_print_registers_info (struct gdbarch *gdbarch,
// OBSOLETE 			       struct ui_file *file,
// OBSOLETE 			       struct frame_info *frame,
// OBSOLETE 			       int regnum, int print_all)
// OBSOLETE {
// OBSOLETE   sparc_print_registers (gdbarch, file, frame, regnum, print_all, NULL);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE sparclet_do_registers_info (int regnum, int all)
// OBSOLETE {
// OBSOLETE   sparclet_print_registers_info (current_gdbarch, gdb_stdout,
// OBSOLETE 				 deprecated_selected_frame, regnum, all);
// OBSOLETE }
#endif
d2249 2
a2250 2
  accumulate_size += DEPRECATED_CALL_DUMMY_STACK_ADJUST;
  sp = ((sp - accumulate_size) & ~7) + DEPRECATED_CALL_DUMMY_STACK_ADJUST;
d2324 7
a2330 9
#if 0
// OBSOLETE extern void
// OBSOLETE sparclet_store_return_value (struct type *type, char *valbuf)
// OBSOLETE {
// OBSOLETE   /* Other values are returned in register %o0.  */
// OBSOLETE   deprecated_write_register_bytes (REGISTER_BYTE (O0_REGNUM), valbuf,
// OBSOLETE 				   TYPE_LENGTH (type));
// OBSOLETE }
#endif
d2396 14
a2409 16
#if 0
// OBSOLETE   /* If this is a bi-endian target, GDB has written the call dummy
// OBSOLETE      in little-endian order.  We must byte-swap it back to big-endian. */
// OBSOLETE   if (bi_endian)
// OBSOLETE     {
// OBSOLETE       for (i = 0; i < CALL_DUMMY_LENGTH; i += 4)
// OBSOLETE 	{
// OBSOLETE 	  char tmp = dummy[i];
// OBSOLETE 	  dummy[i] = dummy[i + 3];
// OBSOLETE 	  dummy[i + 3] = tmp;
// OBSOLETE 	  tmp = dummy[i + 1];
// OBSOLETE 	  dummy[i + 1] = dummy[i + 2];
// OBSOLETE 	  dummy[i + 2] = tmp;
// OBSOLETE 	}
// OBSOLETE     }
#endif
d2413 17
a2429 18
#if 0
// OBSOLETE /* Set target byte order based on machine type. */
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE sparc_target_architecture_hook (const bfd_arch_info_type *ap)
// OBSOLETE {
// OBSOLETE   int i, j;
// OBSOLETE 
// OBSOLETE   if (ap->mach == bfd_mach_sparc_sparclite_le)
// OBSOLETE     {
// OBSOLETE       target_byte_order = BFD_ENDIAN_LITTLE;
// OBSOLETE       bi_endian = 1;
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     bi_endian = 0;
// OBSOLETE   return 1;
// OBSOLETE }
#endif
d2447 1
a2447 1
  /* OBSOLETE target_architecture_hook = sparc_target_architecture_hook; */
d2677 12
a2688 13
#if 0
// OBSOLETE extern void 
// OBSOLETE sparclet_extract_return_value (struct type *type,
// OBSOLETE 			       char *regbuf, 
// OBSOLETE 			       char *valbuf)
// OBSOLETE {
// OBSOLETE   regbuf += REGISTER_RAW_SIZE (O0_REGNUM) * 8;
// OBSOLETE   if (TYPE_LENGTH (type) < REGISTER_RAW_SIZE (O0_REGNUM))
// OBSOLETE     regbuf += REGISTER_RAW_SIZE (O0_REGNUM) - TYPE_LENGTH (type);
// OBSOLETE 
// OBSOLETE   memcpy ((void *) valbuf, regbuf, TYPE_LENGTH (type));
// OBSOLETE }
#endif
d2769 53
a2821 26
#if 0
// OBSOLETE static const char *
// OBSOLETE sparclite_register_name (int regno)
// OBSOLETE {
// OBSOLETE   static char *register_names[] = 
// OBSOLETE   { "g0", "g1", "g2", "g3", "g4", "g5", "g6", "g7",
// OBSOLETE     "o0", "o1", "o2", "o3", "o4", "o5", "sp", "o7",
// OBSOLETE     "l0", "l1", "l2", "l3", "l4", "l5", "l6", "l7",
// OBSOLETE     "i0", "i1", "i2", "i3", "i4", "i5", "fp", "i7",
// OBSOLETE 
// OBSOLETE     "f0",  "f1",  "f2",  "f3",  "f4",  "f5",  "f6",  "f7",
// OBSOLETE     "f8",  "f9",  "f10", "f11", "f12", "f13", "f14", "f15",
// OBSOLETE     "f16", "f17", "f18", "f19", "f20", "f21", "f22", "f23",
// OBSOLETE     "f24", "f25", "f26", "f27", "f28", "f29", "f30", "f31",
// OBSOLETE 
// OBSOLETE     "y", "psr", "wim", "tbr", "pc", "npc", "fpsr", "cpsr",
// OBSOLETE     "dia1", "dia2", "dda1", "dda2", "ddv1", "ddv2", "dcr", "dsr" 
// OBSOLETE   };
// OBSOLETE 
// OBSOLETE   if (regno < 0 ||
// OBSOLETE       regno >= (sizeof (register_names) / sizeof (register_names[0])))
// OBSOLETE     return NULL;
// OBSOLETE   else
// OBSOLETE     return register_names[regno];
// OBSOLETE }
#endif
d2823 6
a2828 37
#if 0
// OBSOLETE static const char *
// OBSOLETE sparclet_register_name (int regno)
// OBSOLETE {
// OBSOLETE   static char *register_names[] = 
// OBSOLETE   { "g0", "g1", "g2", "g3", "g4", "g5", "g6", "g7",
// OBSOLETE     "o0", "o1", "o2", "o3", "o4", "o5", "sp", "o7",
// OBSOLETE     "l0", "l1", "l2", "l3", "l4", "l5", "l6", "l7",
// OBSOLETE     "i0", "i1", "i2", "i3", "i4", "i5", "fp", "i7",
// OBSOLETE 
// OBSOLETE     "", "", "", "", "", "", "", "", /* no floating point registers */
// OBSOLETE     "", "", "", "", "", "", "", "",
// OBSOLETE     "", "", "", "", "", "", "", "",
// OBSOLETE     "", "", "", "", "", "", "", "",
// OBSOLETE 
// OBSOLETE     "y", "psr", "wim", "tbr", "pc", "npc", "", "", /* no FPSR or CPSR */
// OBSOLETE     "ccsr", "ccpr", "cccrcr", "ccor", "ccobr", "ccibr", "ccir", "", 
// OBSOLETE 
// OBSOLETE     /*       ASR15                 ASR19 (don't display them) */    
// OBSOLETE     "asr1",  "", "asr17", "asr18", "", "asr20", "asr21", "asr22"
// OBSOLETE     /* None of the rest get displayed */
// OBSOLETE #if 0
// OBSOLETE     "awr0",  "awr1",  "awr2",  "awr3",  "awr4",  "awr5",  "awr6",  "awr7",  
// OBSOLETE     "awr8",  "awr9",  "awr10", "awr11", "awr12", "awr13", "awr14", "awr15", 
// OBSOLETE     "awr16", "awr17", "awr18", "awr19", "awr20", "awr21", "awr22", "awr23", 
// OBSOLETE     "awr24", "awr25", "awr26", "awr27", "awr28", "awr29", "awr30", "awr31", 
// OBSOLETE     "apsr"
// OBSOLETE #endif /* 0 */
// OBSOLETE   };
// OBSOLETE 
// OBSOLETE   if (regno < 0 ||
// OBSOLETE       regno >= (sizeof (register_names) / sizeof (register_names[0])))
// OBSOLETE     return NULL;
// OBSOLETE   else
// OBSOLETE     return register_names[regno];
// OBSOLETE }
#endif
d3137 3
d3147 1
a3147 1
  set_gdbarch_deprecated_frame_chain (gdbarch, sparc_frame_chain);
d3150 1
a3150 1
  set_gdbarch_deprecated_frame_saved_pc (gdbarch, sparc_frame_saved_pc);
d3153 1
a3153 1
  set_gdbarch_deprecated_get_saved_register (gdbarch, sparc_get_saved_register);
d3161 2
a3162 2
  set_gdbarch_deprecated_pop_frame (gdbarch, sparc_pop_frame);
  set_gdbarch_deprecated_push_return_address (gdbarch, sparc_push_return_address);
d3172 1
a3172 1
  set_gdbarch_deprecated_saved_pc_after_call (gdbarch, sparc_saved_pc_after_call);
d3187 2
a3188 4
#if 0
      // OBSOLETE     case bfd_mach_sparc_sparclet:
      // OBSOLETE     case bfd_mach_sparc_sparclite:
#endif
d3191 1
a3191 3
#if 0
      // OBSOLETE     case bfd_mach_sparc_sparclite_le:
#endif
d3247 3
d3252 2
a3253 1
      set_gdbarch_deprecated_call_dummy_stack_adjust (gdbarch, 68);
d3260 1
a3260 1
      set_gdbarch_deprecated_push_arguments (gdbarch, sparc32_push_arguments);
d3276 1
a3276 2
      set_gdbarch_deprecated_extra_stack_alignment_needed (gdbarch, 1);
      set_gdbarch_deprecated_store_struct_return (gdbarch, sparc32_store_struct_return);
d3279 1
a3279 1
      set_gdbarch_deprecated_dummy_write_sp (gdbarch, generic_target_write_sp);
d3302 4
d3308 1
a3308 1
      set_gdbarch_deprecated_call_dummy_stack_adjust (gdbarch, 128);
d3315 1
a3315 1
      set_gdbarch_deprecated_push_arguments (gdbarch, sparc64_push_arguments);
d3333 1
a3333 2
      set_gdbarch_deprecated_extra_stack_alignment_needed (gdbarch, 1);
      set_gdbarch_deprecated_store_struct_return (gdbarch, sparc64_store_struct_return);
d3336 1
a3336 1
      set_gdbarch_deprecated_dummy_write_sp (gdbarch, sparc64_write_sp);
d3357 1
a3357 3
#if 0
      // OBSOLETE       tdep->has_fpu = 1;	/* (all but sparclet and sparclite) */
#endif
d3361 20
a3380 24
#if 0
      // OBSOLETE     case bfd_mach_sparc_sparclet:
      // OBSOLETE       set_gdbarch_deprecated_extract_return_value (gdbarch, sparclet_extract_return_value);
      // OBSOLETE       set_gdbarch_num_regs (gdbarch, 32 + 32 + 8 + 8 + 8);
      // OBSOLETE       set_gdbarch_register_bytes (gdbarch, 32*4 + 32*4 + 8*4 + 8*4 + 8*4);
      // OBSOLETE       set_gdbarch_register_name (gdbarch, sparclet_register_name);
      // OBSOLETE       set_gdbarch_deprecated_store_return_value (gdbarch, sparclet_store_return_value);
      // OBSOLETE       tdep->has_fpu = 0;	/* (all but sparclet and sparclite) */
      // OBSOLETE       tdep->fp_register_bytes = 0;
      // OBSOLETE       tdep->print_insn_mach = bfd_mach_sparc_sparclet;
      // OBSOLETE       break;
#endif
#if 0
      // OBSOLETE     case bfd_mach_sparc_sparclite:
      // OBSOLETE       set_gdbarch_deprecated_extract_return_value (gdbarch, sparc32_extract_return_value);
      // OBSOLETE       set_gdbarch_num_regs (gdbarch, 80);
      // OBSOLETE       set_gdbarch_register_bytes (gdbarch, 32*4 + 32*4 + 8*4 + 8*4);
      // OBSOLETE       set_gdbarch_register_name (gdbarch, sparclite_register_name);
      // OBSOLETE       set_gdbarch_deprecated_store_return_value (gdbarch, sparc_store_return_value);
      // OBSOLETE       tdep->has_fpu = 0;	/* (all but sparclet and sparclite) */
      // OBSOLETE       tdep->fp_register_bytes = 0;
      // OBSOLETE       tdep->print_insn_mach = bfd_mach_sparc_sparclite;
      // OBSOLETE       break;
#endif
d3389 1
a3389 3
#if 0
      // OBSOLETE       tdep->has_fpu = 1;	/* (all but sparclet and sparclite) */
#endif
d3397 1
a3397 3
#if 0
      // OBSOLETE       tdep->has_fpu = 1;	/* (all but sparclet and sparclite) */
#endif
d3401 10
a3410 12
#if 0
// OBSOLETE     case bfd_mach_sparc_sparclite_le:
// OBSOLETE       set_gdbarch_deprecated_extract_return_value (gdbarch, sparc32_extract_return_value);
// OBSOLETE       set_gdbarch_num_regs (gdbarch, 80);
// OBSOLETE       set_gdbarch_register_bytes (gdbarch, 32*4 + 32*4 + 8*4 + 8*4);
// OBSOLETE       set_gdbarch_register_name (gdbarch, sparclite_register_name);
// OBSOLETE       set_gdbarch_deprecated_store_return_value (gdbarch, sparc_store_return_value);
// OBSOLETE       tdep->has_fpu = 0;	/* (all but sparclet and sparclite) */
// OBSOLETE       tdep->fp_register_bytes = 0;
// OBSOLETE       tdep->print_insn_mach = bfd_mach_sparc_sparclite;
// OBSOLETE       break;
#endif
d3417 1
a3417 3
#if 0
      // OBSOLETE       tdep->has_fpu = 1;	/* (all but sparclet and sparclite) */
#endif
d3427 1
a3427 3
#if 0
      // OBSOLETE       tdep->has_fpu = 1;	/* (all but sparclet and sparclite) */
#endif
d3447 2
a3448 4
#if 0
  // OBSOLETE   fprintf_unfiltered (file, "sparc_dump_tdep: has_fpu = %d\n",
  // OBSOLETE 		      tdep->has_fpu);
#endif
@


1.39.8.6
log
@2003-04-30  David Carlton  <carlton@@bactrian.org>

	* cp-namespace.c (get_namespace_objfile): Copy the namespace
	objfile's name.

	* block.h (ALL_BLOCK_SYMBOLS): Move here from dictionary.h.
	* dictionary.c: Sync up with mainline version I just posted.
	Specifically, update some commments, and:
	(dict_create_hashed): Fiddle with nsyms updating.
	(dict_create_linear): Ditto.
	(dict_lookup): Delete.
	(iterator_next_hashed): Delete FIXME comment.
	(iter_name_first_hashed): Replace 'sym' by 'sym != NULL'.
	(iter_name_next_hashed): Replate 'next' by 'next != NULL'.
	* dictionary.h: Sync up with mainline version I just posted: add
	inclusion guards, delete declaration of dict_lookup, delete
	ALL_BLOCK_SYMBOLs.

	* Merge with mainline; tag is carlton_dictionary-20030430-merge.
@
text
@d54 2
a55 5
#if 0
// OBSOLETE /* Does the target have Floating Point registers?  */
// OBSOLETE #define SPARC_HAS_FPU     (gdbarch_tdep (current_gdbarch)->has_fpu)
#endif
#define SPARC_HAS_FPU 1
d313 2
a314 2
  /* If fi->next is NULL, then we already set ->frame by passing
     deprecated_read_fp() to create_new_frame.  */
d338 1
a338 1
	  frame_read_unsigned_register (fi, DEPRECATED_FP_REGNUM, &tmp);
d1068 1
a1068 1
	  CORE_ADDR oldfp = read_register (DEPRECATED_FP_REGNUM);
d1070 1
a1070 1
	    write_register (DEPRECATED_FP_REGNUM, old_sp - 2047);
d1072 1
a1072 1
	    write_register (DEPRECATED_FP_REGNUM, old_sp);
d1077 1
a1077 1
	  write_register (DEPRECATED_FP_REGNUM, old_sp);
d1087 1
a1087 1
      write_register (G0_REGNUM + 1, read_register (DEPRECATED_FP_REGNUM));
d1099 1
a1099 1
      write_register (DEPRECATED_FP_REGNUM, old_sp);
d2382 4
a2385 5

     Tweeking current_gdbarch is not an optimal solution, but the call
     to sparc_fix_call_dummy is immediately followed by a call to
     call_function_by_hand, which is the only function where
     dummy_breakpoint_offset is actually used, if it is non-zero.  */
d2462 2
a2463 2
  deprecated_tm_print_insn = gdb_print_insn_sparc;
  deprecated_tm_print_insn_info.mach = TM_PRINT_INSN_MACH;		/* Selects sparc/sparclite */
d2483 1
a2483 1
  CORE_ADDR fp = read_register (DEPRECATED_FP_REGNUM);
d2937 1
a2937 1
      regno == DEPRECATED_FP_REGNUM ||
d2951 1
a2951 1
      regno == DEPRECATED_FP_REGNUM ||
d3164 1
a3164 1
  set_gdbarch_deprecated_fp_regnum (gdbarch, SPARC_FP_REGNUM);
d3280 1
d3333 1
a3333 1
      set_gdbarch_deprecated_target_read_fp (gdbarch, sparc64_read_fp);
@


1.39.8.7
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@a153 8
const unsigned char *
sparc_breakpoint_from_pc (CORE_ADDR *pc, int *len)
{
  static const char breakpoint[] = {0x91, 0xd0, 0x20, 0x01};
  (*len) = sizeof (breakpoint);
  return breakpoint;
}

d320 3
a322 1
      char buf[MAX_REGISTER_SIZE];
d371 3
a373 1
	      char buf[MAX_REGISTER_SIZE];
d477 1
a477 1
  char buf[MAX_REGISTER_SIZE];
d480 1
d867 1
a867 1
	  store_unsigned_integer (raw_buffer, REGISTER_RAW_SIZE (regnum), get_frame_pc (frame));
d975 1
a975 1
	      store_unsigned_integer (raw_buffer, REGISTER_RAW_SIZE (regnum), addr);
d1269 1
a1269 1
  raw_buffer = alloca (DEPRECATED_REGISTER_BYTES);
d2073 2
a2074 2
  char raw_buffer[MAX_REGISTER_SIZE];
  char virtual_buffer[MAX_REGISTER_SIZE];
d2314 3
a2316 1
  char buffer[MAX_REGISTER_SIZE];
d2360 3
a2362 4
   (twisted) convention.  So leave a nop there for gcc
   (DEPRECATED_FIX_CALL_DUMMY can assume it is operating on a pristine
   CALL_DUMMY, not one that has already been customized for a
   different function).  */
d2395 1
a2395 1
      set_gdbarch_deprecated_call_dummy_breakpoint_offset (current_gdbarch, 0x30);
d2398 1
a2398 1
    set_gdbarch_deprecated_call_dummy_breakpoint_offset (current_gdbarch, 0x2c);
d3057 1
a3057 1
  return (DEPRECATED_CALL_DUMMY_START_OFFSET) + DEPRECATED_CALL_DUMMY_BREAKPOINT_OFFSET;
d3162 1
a3162 1
  set_gdbarch_breakpoint_from_pc (gdbarch, sparc_breakpoint_from_pc);
d3166 1
a3166 1
  set_gdbarch_deprecated_fix_call_dummy (gdbarch, sparc_gdbarch_fix_call_dummy);
d3224 2
a3225 10
      set_gdbarch_deprecated_call_dummy_breakpoint_offset (gdbarch, 0x30);
      set_gdbarch_deprecated_call_dummy_length (gdbarch, 0x38);

      /* NOTE: cagney/2003-05-01: Using the just added push_dummy_code
	 architecture method, it is now possible to implement a
	 generic dummy frames based inferior function call that stores
	 the breakpoint (and struct info) on the stack.  Further, by
	 treating a SIGSEG at a breakpoint as equivalent to a SIGTRAP
	 it is even possible to make this work when the stack is
	 no-execute.
d3227 1
a3227 1
	 NOTE: cagney/2002-04-26: Based from info posted by Peter
d3271 1
a3271 1
      set_gdbarch_deprecated_call_dummy_words (gdbarch, call_dummy_32);
d3274 1
a3274 1
      set_gdbarch_deprecated_call_dummy_words (gdbarch, call_dummy_nil);
d3288 1
a3288 1
      set_gdbarch_deprecated_register_size (gdbarch, 4);
d3293 1
a3293 1
      set_gdbarch_deprecated_sizeof_call_dummy_words (gdbarch, sizeof (call_dummy_32));
d3295 1
a3295 1
      set_gdbarch_deprecated_sizeof_call_dummy_words (gdbarch, 0);
d3318 2
a3319 2
      set_gdbarch_deprecated_call_dummy_breakpoint_offset (gdbarch, 8 * 4);
      set_gdbarch_deprecated_call_dummy_length (gdbarch, 192);
d3321 2
a3322 2
      set_gdbarch_deprecated_call_dummy_start_offset (gdbarch, 148);
      set_gdbarch_deprecated_call_dummy_words (gdbarch, call_dummy_64);
d3325 1
a3325 1
      set_gdbarch_deprecated_call_dummy_words (gdbarch, call_dummy_nil);
d3342 1
a3342 1
      set_gdbarch_deprecated_register_size (gdbarch, 8);
d3347 1
a3347 1
      set_gdbarch_deprecated_sizeof_call_dummy_words (gdbarch, sizeof (call_dummy_64));
d3349 1
a3349 1
      set_gdbarch_deprecated_sizeof_call_dummy_words (gdbarch, 0);
d3374 1
a3374 1
      set_gdbarch_deprecated_register_bytes (gdbarch, 32*4 + 32*4 + 8*4);
d3410 1
a3410 1
      set_gdbarch_deprecated_register_bytes (gdbarch, 32*4 + 32*4 + 8*4);
d3422 1
a3422 1
      set_gdbarch_deprecated_register_bytes (gdbarch, 32*4 + 32*4 + 8*4);
d3446 1
a3446 1
      set_gdbarch_deprecated_register_bytes (gdbarch, 32*8 + 32*8 + 45*8);
d3458 1
a3458 1
      set_gdbarch_deprecated_register_bytes (gdbarch, 32*8 + 32*8 + 45*8);
@


1.39.8.8
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d469 7
d518 1
a518 1
      return extract_unsigned_integer (scbuf, sizeof (scbuf));
d544 1
a544 1
  return PC_ADJUST (extract_unsigned_integer (buf, SPARC_INTREG_SIZE));
d1806 1
a1806 1
  *pc = extract_unsigned_integer (buf, LONGJMP_TARGET_SIZE);
d2114 14
a2127 1
      memcpy (virtual_buffer, raw_buffer, REGISTER_VIRTUAL_SIZE (i));
d2209 1
a2209 1
static int
a2216 118

#define SPARC_F0_REGNUM		FP0_REGNUM	/* %f0 */
#define SPARC_F1_REGNUM		(FP0_REGNUM + 1)/* %f1 */
#define SPARC_O0_REGNUM		O0_REGNUM	/* %o0 */
#define SPARC_O1_REGNUM		O1_REGNUM	/* %o1 */

/* Push the arguments onto the stack and into the appropriate registers.  */

static CORE_ADDR
sparc32_do_push_arguments (struct regcache *regcache, int nargs,
			   struct value **args, CORE_ADDR sp)
{
  CORE_ADDR *addr;
  int size = 0;
  int i;

  /* Structure, union and quad-precision arguments are passed by
     reference.  We allocate space for these arguments on the stack
     and record their addresses in an array.  Array elements for
     arguments that are passed by value will be set to zero.*/
  addr = alloca (nargs * sizeof (CORE_ADDR));

  for (i = nargs - 1; i >= 0; i--)
    {
      struct type *type = VALUE_ENCLOSING_TYPE (args[i]);
      enum type_code code = TYPE_CODE (type);
      int len = TYPE_LENGTH (type);

      /* Push the contents of structure, union and quad-precision
	 arguments on the stack.  */
      if (code == TYPE_CODE_STRUCT || code == TYPE_CODE_UNION || len > 8)
	{
	  /* Keep the stack doubleword aligned.  */
	  sp -= (len + 7) & ~7;
	  write_memory (sp, VALUE_CONTENTS_ALL (args[i]), len);
	  addr[i] = sp;
	  size += 4;
	}
      else
	{
	  addr[i] = 0;
	  size += (len > 4) ? 8 : 4;
	}
    }

  /* The needed space for outgoing arguments should be a multiple of 4.  */
  gdb_assert (size % 4 == 0);

  /* Make sure we reserve space for the first six words of arguments
     in the stack frame, even if we don't need them.  */
  if (size < 24)
    sp -= (24 - size);

  /* Make sure we end up with a doubleword aligned stack in the end.
     Reserve an extra word if necessary in order to accomplish this.  */
  if ((sp - size) % 8 == 0)
    sp -= 4;

  /* Now push the arguments onto the stack.  */
  for (i = nargs - 1; i >=0; i--)
    {
      char buf[8];
      int len;

      if (addr[i])
	{
	  store_unsigned_integer (buf, 4, addr[i]);
	  len = 4;
	}
      else
	{
	  struct value *arg = args[i];

	  len = TYPE_LENGTH (VALUE_ENCLOSING_TYPE (arg));

	  /* Expand signed and unsigned bytes and halfwords as needed.  */
	  if (len < 4)
	    {
	      arg = value_cast (builtin_type_long, arg);
	      len = 4;
	    }
	  else if (len > 4 && len < 8)
	    {
	      arg = value_cast (builtin_type_long_long, arg);
	      len = 4;
	    }

	  gdb_assert (len == 4 || len == 8);
	  memcpy (buf, VALUE_CONTENTS_ALL (arg), len);
	}

      /* We always write the argument word on the stack.  */
      sp -= len;
      write_memory (sp, buf, len);

      /* If this argument occupies one of the first 6 words, write it
         into the appropriate register too.  */
      size -= len;
      if (size < 24)
	{
	  int regnum = SPARC_O0_REGNUM + (size / 4);

	  regcache_cooked_write (regcache, regnum, buf);
	  if (len == 8 && size < 20)
	    regcache_cooked_write (regcache, regnum + 1, buf + 4);
	}
    }

  /* Reserve space for the struct/union return value pointer.  */
  sp -= 4;

  /* Stack should be doubleword aligned at this point.  */
  gdb_assert (sp % 8 == 0);

  /* Return the adjusted stack pointer.  */
  return sp;
}

d2225 3
a2227 6
  sp = sparc32_do_push_arguments (current_regcache, nargs, args, sp);

  /* FIXME: kettenis/20030525: We don't let this function set the
     struct/union return pointer just yet.  */
#if 0
  if (struct_return)
d2229 51
a2279 6
      char buf[4];

      /* The space for the struct/union return value pointer has
         already been reserved.  */
      store_unsigned_integer (buf, 4, struct_addr);
      write (sp, buf, 4);
a2282 3
#else
  return sp + 4;
#endif
a2284 2
/* Extract from REGCACHE a function return value of type TYPE and copy
   that into VALBUF.
d2286 3
a2288 4
   Note that REGCACHE specifies the register values for the frame of
   the calling function.  This means that we need to fetch the value
   form %o0 and %o1, which correspond to %i0 and %i1 in the frame of
   the called function.  */
d2291 1
a2291 2
sparc32_extract_return_value (struct type *type, struct regcache *regcache,
			      void *valbuf)
d2293 2
a2294 41
  int len = TYPE_LENGTH (type);
  char buf[8];

  if (TYPE_CODE (type) == TYPE_CODE_FLT && SPARC_HAS_FPU)
    {
      if (len == 4 || len == 8)
	{
	  regcache_cooked_read (regcache, SPARC_F0_REGNUM, buf);
	  regcache_cooked_read (regcache, SPARC_F1_REGNUM, buf + 4);
	  memcpy (valbuf, buf, len);
	  return;
	}
      else
	internal_error (__FILE__, __LINE__, "\
Cannot extract floating-point return value of %d bytes long.", len);
    }

  if (len <= 4)
    {
      regcache_cooked_read (regcache, SPARC_O0_REGNUM, buf);
      memcpy (valbuf, buf + 4 - len, len);
    }
  else if (len <= 8)
    {
      regcache_cooked_read (regcache, SPARC_O0_REGNUM, buf);
      regcache_cooked_read (regcache, SPARC_O1_REGNUM, buf + 4);
      memcpy (valbuf, buf + 8 - len, len);
    }
  else
    internal_error (__FILE__, __LINE__,
		    "Cannot extract return value of %d bytes long.", len);
}

/* Write into REGBUF a function return value VALBUF of type TYPE.  */

void
sparc32_store_return_value (struct type *type, struct regcache *regcache,
			    const void *valbuf)
{
  int len = TYPE_LENGTH (type);
  char buf[8];
d2297 1
a2297 33
    {
      const char *buf = valbuf;

      if (len == 4)
	{
	  regcache_cooked_write (regcache, SPARC_F0_REGNUM, buf);
	  return;
	}
      else if (len == 8)
	{
	  regcache_cooked_write (regcache, SPARC_F0_REGNUM, buf);
	  regcache_cooked_write (regcache, SPARC_F1_REGNUM, buf + 4);
	  return;
	}
      else
	internal_error (__FILE__, __LINE__, "\
Cannot extract floating-point return value of %d bytes long.", len);
    }

  /* Add leading zeros to the value.  */
  memset (buf, 0, sizeof buf);

  if (len <= 4)
    {
      memcpy (buf + 4 - len, valbuf, len);
      regcache_cooked_write (regcache, SPARC_O0_REGNUM, buf);
    }
  else if (len <= 8)
    {
      memcpy (buf + 8 - len, valbuf, len);
      regcache_cooked_write (regcache, SPARC_O0_REGNUM, buf);
      regcache_cooked_write (regcache, SPARC_O1_REGNUM, buf);
    }
d2299 6
a2304 2
    internal_error (__FILE__, __LINE__,
		    "Cannot extract return value of %d bytes long.", len);
a2306 2
/* Extract from REGCACHE the address in which a function should return
   its structure value.  */
d2308 4
a2311 4
CORE_ADDR
sparc_extract_struct_value_address (struct regcache *regcache)
{
  ULONGEST addr;
d2313 1
a2313 7
  regcache_cooked_read_unsigned (regcache, SPARC_O0_REGNUM, &addr);
  return addr;
}

/* FIXME: kettenis/2003/05/24: Still used for sparc64.  */

static void
a2461 2
extern initialize_file_ftype _initialize_sparc_tdep; /* -Wmissing-prototypes */

d2476 1
a2476 1
static CORE_ADDR
d2486 1
a2486 1
static CORE_ADDR
d2496 1
a2496 1
static void
d2520 1
a2520 1
static CORE_ADDR
d2637 1
a2637 1
static void
d2694 1
a2694 1
static void
d2720 1
a2720 1
static CORE_ADDR
d2858 1
a2858 1
static CORE_ADDR
d3017 13
d3064 1
a3064 1
static int
d3079 1
a3079 1
static int
a3094 10
/* Get the ith function argument for the current function.  */
static CORE_ADDR
sparc_fetch_pointer_argument (struct frame_info *frame, int argi,
			      struct type *type)
{
  CORE_ADDR addr;
  frame_read_register (frame, O0_REGNUM + argi, &addr);
  return addr;
}

d3167 1
a3167 2
  set_gdbarch_extract_struct_value_address (gdbarch,
					   sparc_extract_struct_value_address);
d3174 1
d3189 6
a3204 3
  /* Helper for function argument information.  */
  set_gdbarch_fetch_pointer_argument (gdbarch, sparc_fetch_pointer_argument);

d3294 1
d3296 2
a3297 2
      set_gdbarch_deprecated_register_byte (gdbarch, sparc32_register_byte);
      set_gdbarch_deprecated_register_raw_size (gdbarch, sparc32_register_size);
d3299 3
a3301 2
      set_gdbarch_deprecated_register_virtual_size (gdbarch, sparc32_register_size);
      set_gdbarch_deprecated_register_virtual_type (gdbarch, sparc32_register_virtual_type);
d3312 1
a3312 1
      set_gdbarch_deprecated_dummy_write_sp (gdbarch, deprecated_write_sp);
d3350 2
a3351 2
      set_gdbarch_deprecated_register_byte (gdbarch, sparc64_register_byte);
      set_gdbarch_deprecated_register_raw_size (gdbarch, sparc64_register_size);
d3353 3
a3355 2
      set_gdbarch_deprecated_register_virtual_size (gdbarch, sparc64_register_size);
      set_gdbarch_deprecated_register_virtual_type (gdbarch, sparc64_register_virtual_type);
d3382 1
a3382 2
      set_gdbarch_extract_return_value (gdbarch, sparc32_extract_return_value);
      set_gdbarch_store_return_value (gdbarch, sparc32_store_return_value);
d3386 1
d3418 1
a3418 2
      set_gdbarch_extract_return_value (gdbarch, sparc32_extract_return_value);
      set_gdbarch_store_return_value (gdbarch, sparc32_store_return_value);
d3422 1
d3430 1
a3430 2
      set_gdbarch_extract_return_value (gdbarch, sparc32_extract_return_value);
      set_gdbarch_store_return_value (gdbarch, sparc32_store_return_value);
d3434 1
@


1.39.8.9
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@a36 2
#include "sparc-tdep.h"

d133 3
a2876 16
const char *
legacy_register_name (int i)
{
#ifdef REGISTER_NAMES
  static char *names[] = REGISTER_NAMES;
  if (i < 0 || i >= (sizeof (names) / sizeof (*names)))
    return NULL;
  else
    return names[i];
#else
  internal_error (__FILE__, __LINE__,
		  "legacy_register_name: called.");
  return NULL;
#endif
}

d3191 1
a3191 1
int
d3206 1
a3206 1
int
@


1.39.8.10
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@a35 1
#include "dis-asm.h"
d54 2
d70 43
d215 1
a215 1
   step-breakpoint was set, not necessary the current value of DEPRECATED_NPC_REGNUM.  */
d242 1
a242 1
      next_pc = read_register (DEPRECATED_NPC_REGNUM);
d983 1
a983 1
      addr = DEPRECATED_REGISTER_BYTE (regnum);
d1019 1
a1019 1
      deprecated_read_register_bytes (DEPRECATED_REGISTER_BYTE (PC_REGNUM),
d1022 1
a1022 1
      deprecated_read_register_bytes (DEPRECATED_REGISTER_BYTE (PSTATE_REGNUM), 
d1030 1
a1030 1
      deprecated_read_register_bytes (DEPRECATED_REGISTER_BYTE (Y_REGNUM),
d1035 1
a1035 1
  deprecated_read_register_bytes (DEPRECATED_REGISTER_BYTE (O0_REGNUM),
d1039 1
a1039 1
  deprecated_read_register_bytes (DEPRECATED_REGISTER_BYTE (G0_REGNUM),
d1044 1
a1044 1
    deprecated_read_register_bytes (DEPRECATED_REGISTER_BYTE (FP0_REGNUM),
d1140 1
a1140 1
  int regnum;
d1257 2
a1258 2
  struct frame_info *frame = get_current_frame ();
  CORE_ADDR pc;
d1271 1
a1271 1
	  deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (FP0_REGNUM),
d1291 1
a1291 1
      deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (G1_REGNUM), raw_buffer,
d1344 1
a1344 1
      deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (O0_REGNUM), raw_buffer,
d1347 1
a1347 1
      deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (L0_REGNUM), reg_temp,
d1367 4
a1370 4
      if (fsr[DEPRECATED_NPC_REGNUM])
	write_register (DEPRECATED_NPC_REGNUM,
			read_memory_integer (fsr[DEPRECATED_NPC_REGNUM],
					     REGISTER_RAW_SIZE (DEPRECATED_NPC_REGNUM)));
d1389 1
a1389 1
      write_register (DEPRECATED_NPC_REGNUM, pc + 4);
d1397 1
a1397 1
      write_register (DEPRECATED_NPC_REGNUM, pc + 4);
d1526 1
a1526 1
  supply_register (DEPRECATED_NPC_REGNUM, ((char *) (regp + R_nPC)) + offset);
d1645 2
a1646 2
  if ((regno == -1) || (regno == DEPRECATED_NPC_REGNUM))
    deprecated_read_register_gen (DEPRECATED_NPC_REGNUM, (char *) (regp + R_nPC) + offset);
d1709 1
a1709 1
  int regi;
d1758 1
a1758 1
	  from = (char *) &deprecated_registers[DEPRECATED_REGISTER_BYTE (regi)];
d1767 1
a1767 1
	from = (char *)&deprecated_registers[DEPRECATED_REGISTER_BYTE (FPS_REGNUM)];
d2187 10
d2473 1
a2473 1
    deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (regno), valbuf,
d2607 2
d2752 1
a2752 1
	      deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (fpreg),
d2785 1
a2785 1
      memcpy (valbuf, &regbuf[DEPRECATED_REGISTER_BYTE (FP0_REGNUM)], typelen);
d3027 2
a3028 4
      if (DEPRECATED_CALL_DUMMY_ADDRESS_P ())
	write_register (O7_REGNUM, DEPRECATED_CALL_DUMMY_ADDRESS () - 8);
      else
	write_register (O7_REGNUM, entry_point_address () - 8);
d3196 1
a3196 2
/* DEPRECATED_CALL_DUMMY_ADDRESS: fetch the breakpoint address for a
   call dummy.  */
d3341 1
a3341 2
  set_gdbarch_deprecated_reg_struct_has_addr
    (gdbarch, sparc_reg_struct_has_addr);
d3374 1
a3374 1
      set_gdbarch_deprecated_call_dummy_address (gdbarch, sparc_call_dummy_address);
d3439 1
a3439 1
      set_gdbarch_deprecated_npc_regnum (gdbarch, SPARC32_NPC_REGNUM);
d3454 1
a3454 1
      set_gdbarch_deprecated_stack_align (gdbarch, sparc32_stack_align);
d3474 1
a3474 1
      set_gdbarch_deprecated_call_dummy_address (gdbarch, sparc_call_dummy_address);
d3488 1
a3488 1
      set_gdbarch_deprecated_npc_regnum (gdbarch, SPARC64_NPC_REGNUM);
d3507 1
a3507 1
      set_gdbarch_deprecated_stack_align (gdbarch, sparc64_stack_align);
a3623 2

  set_gdbarch_print_insn (gdbarch, print_insn_sparc);
@


1.39.8.11
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d55 4
d71 3
d100 9
d302 1
a302 1
	  tmp = get_frame_register_unsigned (fi, DEPRECATED_FP_REGNUM);
d342 1
a342 1
		tmp = get_frame_register_unsigned (fi, I7_REGNUM);
d458 1
a458 1
	tmp = get_frame_register_unsigned (frame, O0_REGNUM + 2);
d477 1
a477 1
      tmp = get_frame_register_unsigned (frame, O7_REGNUM);
d818 1
a818 1
	  store_unsigned_integer (raw_buffer, DEPRECATED_REGISTER_RAW_SIZE (regnum), get_frame_pc (frame));
d926 1
a926 1
	      store_unsigned_integer (raw_buffer, DEPRECATED_REGISTER_RAW_SIZE (regnum), addr);
d933 1
a933 1
	read_memory (addr, raw_buffer, DEPRECATED_REGISTER_RAW_SIZE (regnum));
d977 1
a977 1
				      DEPRECATED_REGISTER_RAW_SIZE (PC_REGNUM) * 7);
d980 1
a980 1
				      DEPRECATED_REGISTER_RAW_SIZE (PSTATE_REGNUM));
d988 1
a988 1
				      DEPRECATED_REGISTER_RAW_SIZE (Y_REGNUM) * 8);
d1311 1
a1311 1
					   DEPRECATED_REGISTER_RAW_SIZE (PS_REGNUM)));
d1316 1
a1316 1
					 DEPRECATED_REGISTER_RAW_SIZE (Y_REGNUM)));
d1322 1
a1322 1
					   DEPRECATED_REGISTER_RAW_SIZE (PC_REGNUM)));
d1326 1
a1326 1
					     DEPRECATED_REGISTER_RAW_SIZE (DEPRECATED_NPC_REGNUM)));
d1333 1
a1333 1
					     DEPRECATED_REGISTER_RAW_SIZE (PC_REGNUM)));
d1340 1
a1340 1
	  tmp = get_frame_register_unsigned (frame, O7_REGNUM);
d1716 1
a1716 1
	  memcpy (to, from, DEPRECATED_REGISTER_RAW_SIZE (regi));
d1725 1
a1725 1
	memcpy (to, from, DEPRECATED_REGISTER_RAW_SIZE (FPS_REGNUM));
d2035 1
a2035 1
	      if (TYPE_CODE (DEPRECATED_REGISTER_VIRTUAL_TYPE (i)) == TYPE_CODE_FLT)
d2037 1
a2037 1
	      if (TYPE_VECTOR (DEPRECATED_REGISTER_VIRTUAL_TYPE (i)))
d2062 1
a2062 1
      memcpy (virtual_buffer, raw_buffer, DEPRECATED_REGISTER_VIRTUAL_SIZE (i));
d2066 1
a2066 1
      if (TYPE_CODE (DEPRECATED_REGISTER_VIRTUAL_TYPE (i)) == TYPE_CODE_FLT)
d2070 1
a2070 1
	  val_print (DEPRECATED_REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0,
d2074 1
a2074 1
	  for (j = 0; j < DEPRECATED_REGISTER_RAW_SIZE (i); j++)
d2080 1
a2080 1
		idx = DEPRECATED_REGISTER_RAW_SIZE (i) - 1 - j;
d2088 1
a2088 1
	  val_print (DEPRECATED_REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0,
d2092 1
a2092 1
	  if (TYPE_VECTOR (DEPRECATED_REGISTER_VIRTUAL_TYPE (i)) == 0)
d2095 1
a2095 1
	      val_print (DEPRECATED_REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0,
d2125 18
d2411 1
a2411 1
  if (TYPE_LENGTH (type) < DEPRECATED_REGISTER_RAW_SIZE (regno))
d2413 2
a2414 2
      memset (buffer, 0, DEPRECATED_REGISTER_RAW_SIZE (regno));
      memcpy (buffer + DEPRECATED_REGISTER_RAW_SIZE (regno) - TYPE_LENGTH (type), valbuf,
d2423 11
d2498 17
d2517 20
d2552 2
d2725 1
a2725 1
  int regsize = DEPRECATED_REGISTER_RAW_SIZE (O0_REGNUM);
d2783 14
d2818 18
d2892 65
d3190 1
a3190 1
  get_frame_register (frame, O0_REGNUM + argi, &addr);
d3309 4
d3315 3
d3481 3
d3487 24
d3519 3
d3529 3
d3535 12
d3553 3
d3565 3
d3589 4
@


1.39.8.12
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d436 1
a436 1
      if (name && DEPRECATED_STREQ (name, "ucbsigvechandler"))
@


1.39.8.13
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d1 1
a1 1
/* Target-dependent code for SPARC.
d3 3
a5 1
   Copyright 2003, 2004 Free Software Foundation, Inc.
d24 2
a27 2
#include "dis-asm.h"
#include "floatformat.h"
a28 4
#include "frame-base.h"
#include "frame-unwind.h"
#include "gdbcore.h"
#include "gdbtypes.h"
a29 4
#include "symtab.h"
#include "objfiles.h"
#include "osabi.h"
#include "regcache.h"
d32 13
d46 1
a47 1
#include "gdb_string.h"
d49 71
a119 1
#include "sparc-tdep.h"
a120 1
struct regset;
d122 2
a123 29
/* This file implements the The SPARC 32-bit ABI as defined by the
   section "Low-Level System Information" of the SPARC Compliance
   Definition (SCD) 2.4.1, which is the 32-bit System V psABI for
   SPARC.  The SCD lists changes with respect to the origional 32-bit
   psABI as defined in the "System V ABI, SPARC Processor
   Supplement".

   Note that if we talk about SunOS, we mean SunOS 4.x, which was
   BSD-based, which is sometimes (retroactively?) referred to as
   Solaris 1.x.  If we talk about Solaris we mean Solaris 2.x and
   above (Solaris 7, 8 and 9 are nothing but Solaris 2.7, 2.8 and 2.9
   suffering from severe version number inflation).  Solaris 2.x is
   also known as SunOS 5.x, since that's what uname(1) says.  Solaris
   2.x is SVR4-based.  */

/* Please use the sparc32_-prefix for 32-bit specific code, the
   sparc64_-prefix for 64-bit specific code and the sparc_-prefix for
   code that can handle both.  The 64-bit specific code lives in
   sparc64-tdep.c; don't add any here.  */

/* The SPARC Floating-Point Quad-Precision format is similar to
   big-endian IA-64 Quad-recision format.  */
#define floatformat_sparc_quad floatformat_ia64_quad_big

/* The stack pointer is offset from the stack frame by a BIAS of 2047
   (0x7ff) for 64-bit code.  BIAS is likely to be defined on SPARC
   hosts, so undefine it first.  */
#undef BIAS
#define BIAS 2047
d125 1
a125 1
/* Macros to extract fields from SPARC instructions.  */
d133 1
d135 1
d137 1
d139 2
d142 25
d168 2
a169 2
/* Fetch the instruction at PC.  Instructions are always big-endian
   even if the processor operates in little-endian mode.  */
d171 3
a173 2
unsigned long
sparc_fetch_instruction (CORE_ADDR pc)
d175 3
a177 3
  unsigned char buf[4];
  unsigned long insn;
  int i;
d179 5
a183 3
  /* If we can't read the instruction at PC, return zero.  */
  if (target_read_memory (pc, buf, sizeof (buf)))
    return 0;
d185 2
a186 7
  insn = 0;
  for (i = 0; i < sizeof (buf); i++)
    insn = (insn << 8) | buf[i];
  return insn;
}

/* Return the contents if register REGNUM as an address.  */
d188 4
a191 4
static CORE_ADDR
sparc_address_from_register (int regnum)
{
  ULONGEST addr;
d193 20
a212 38
  regcache_cooked_read_unsigned (current_regcache, regnum, &addr);
  return addr;
}


/* The functions on this page are intended to be used to classify
   function arguments.  */

/* Check whether TYPE is "Integral or Pointer".  */

static int
sparc_integral_or_pointer_p (const struct type *type)
{
  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_INT:
    case TYPE_CODE_BOOL:
    case TYPE_CODE_CHAR:
    case TYPE_CODE_ENUM:
    case TYPE_CODE_RANGE:
      {
	/* We have byte, half-word, word and extended-word/doubleword
           integral types.  The doubleword is an extension to the
           origional 32-bit ABI by the SCD 2.4.x.  */
	int len = TYPE_LENGTH (type);
	return (len == 1 || len == 2 || len == 4 || len == 8);
      }
      return 1;
    case TYPE_CODE_PTR:
    case TYPE_CODE_REF:
      {
	/* Allow either 32-bit or 64-bit pointers.  */
	int len = TYPE_LENGTH (type);
	return (len == 4 || len == 8);
      }
      return 1;
    default:
      break;
d214 1
a214 10

  return 0;
}

/* Check whether TYPE is "Floating".  */

static int
sparc_floating_p (const struct type *type)
{
  switch (TYPE_CODE (type))
d216 2
a217 8
    case TYPE_CODE_FLT:
      {
	int len = TYPE_LENGTH (type);
	return (len == 4 || len == 8 || len == 16);
      }
    default:
      break;
    }
d219 2
a220 4
  return 0;
}

/* Check whether TYPE is "Structure or Union".  */
d222 2
a223 10
static int
sparc_structure_or_union_p (const struct type *type)
{
  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_STRUCT:
    case TYPE_CODE_UNION:
      return 1;
    default:
      break;
a224 2

  return 0;
d226 2
a227 4

/* Register information.  */

static const char *sparc32_register_names[] =
d229 9
a237 11
  "g0", "g1", "g2", "g3", "g4", "g5", "g6", "g7",
  "o0", "o1", "o2", "o3", "o4", "o5", "sp", "o7",
  "l0", "l1", "l2", "l3", "l4", "l5", "l6", "l7",
  "i0", "i1", "i2", "i3", "i4", "i5", "fp", "i7",

  "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7",
  "f8", "f9", "f10", "f11", "f12", "f13", "f14", "f15",
  "f16", "f17", "f18", "f19", "f20", "f21", "f22", "f23",
  "f24", "f25", "f26", "f27", "f28", "f29", "f30", "f31",

  "y", "psr", "wim", "tbr", "pc", "npc", "fsr", "csr"
d240 5
a244 2
/* Total number of registers.  */
#define SPARC32_NUM_REGS ARRAY_SIZE (sparc32_register_names)
d246 2
a247 4
/* We provide the aliases %d0..%d30 for the floating registers as
   "psuedo" registers.  */

static const char *sparc32_pseudo_register_names[] =
d249 42
a290 85
  "d0", "d2", "d4", "d6", "d8", "d10", "d12", "d14",
  "d16", "d18", "d20", "d22", "d24", "d26", "d28", "d30"
};

/* Total number of pseudo registers.  */
#define SPARC32_NUM_PSEUDO_REGS ARRAY_SIZE (sparc32_pseudo_register_names)

/* Return the name of register REGNUM.  */

static const char *
sparc32_register_name (int regnum)
{
  if (regnum >= 0 && regnum < SPARC32_NUM_REGS)
    return sparc32_register_names[regnum];

  if (regnum < SPARC32_NUM_REGS + SPARC32_NUM_PSEUDO_REGS)
    return sparc32_pseudo_register_names[regnum - SPARC32_NUM_REGS];

  return NULL;
}

/* Return the GDB type object for the "standard" data type of data in
   register REGNUM. */

static struct type *
sparc32_register_type (struct gdbarch *gdbarch, int regnum)
{
  if (regnum >= SPARC_F0_REGNUM && regnum <= SPARC_F31_REGNUM)
    return builtin_type_float;

  if (regnum >= SPARC32_D0_REGNUM && regnum <= SPARC32_D30_REGNUM)
    return builtin_type_double;

  if (regnum == SPARC_SP_REGNUM || regnum == SPARC_FP_REGNUM)
    return builtin_type_void_data_ptr;

  if (regnum == SPARC32_PC_REGNUM || regnum == SPARC32_NPC_REGNUM)
    return builtin_type_void_func_ptr;

  return builtin_type_int32;
}

static void
sparc32_pseudo_register_read (struct gdbarch *gdbarch,
			      struct regcache *regcache,
			      int regnum, void *buf)
{
  gdb_assert (regnum >= SPARC32_D0_REGNUM && regnum <= SPARC32_D30_REGNUM);

  regnum = SPARC_F0_REGNUM + 2 * (regnum - SPARC32_D0_REGNUM);
  regcache_raw_read (regcache, regnum, buf);
  regcache_raw_read (regcache, regnum + 1, ((char *)buf) + 4);
}

static void
sparc32_pseudo_register_write (struct gdbarch *gdbarch,
			       struct regcache *regcache,
			       int regnum, const void *buf)
{
  gdb_assert (regnum >= SPARC32_D0_REGNUM && regnum <= SPARC32_D30_REGNUM);

  regnum = SPARC_F0_REGNUM + 2 * (regnum - SPARC32_D0_REGNUM);
  regcache_raw_write (regcache, regnum, buf);
  regcache_raw_write (regcache, regnum + 1, ((const char *)buf) + 4);
}


static CORE_ADDR
sparc32_push_dummy_code (struct gdbarch *gdbarch, CORE_ADDR sp,
			 CORE_ADDR funcaddr, int using_gcc,
			 struct value **args, int nargs,
			 struct type *value_type,
			 CORE_ADDR *real_pc, CORE_ADDR *bp_addr)
{
  *bp_addr = sp - 4;
  *real_pc = funcaddr;

  if (using_struct_return (value_type, using_gcc))
    {
      char buf[4];

      /* This is an UNIMP instruction.  */
      store_unsigned_integer (buf, 4, TYPE_LENGTH (value_type) & 0x1fff);
      write_memory (sp - 8, buf, 4);
      return sp - 8;
d293 24
a316 17
  return sp - 4;
}

static CORE_ADDR
sparc32_store_arguments (struct regcache *regcache, int nargs,
			 struct value **args, CORE_ADDR sp,
			 int struct_return, CORE_ADDR struct_addr)
{
  /* Number of words in the "parameter array".  */
  int num_elements = 0;
  int element = 0;
  int i;

  for (i = 0; i < nargs; i++)
    {
      struct type *type = VALUE_TYPE (args[i]);
      int len = TYPE_LENGTH (type);
d318 2
a319 5
      if (sparc_structure_or_union_p (type)
	  || (sparc_floating_p (type) && len == 16))
	{
	  /* Structure, Union and Quad-Precision Arguments.  */
	  sp -= len;
d321 1
a321 3
	  /* Use doubleword alignment for these values.  That's always
             correct, and wasting a few bytes shouldn't be a problem.  */
	  sp &= ~0x7;
d323 24
a346 9
	  write_memory (sp, VALUE_CONTENTS (args[i]), len);
	  args[i] = value_from_pointer (lookup_pointer_type (type), sp);
	  num_elements++;
	}
      else if (sparc_floating_p (type))
	{
	  /* Floating arguments.  */
	  gdb_assert (len == 4 || len == 8);
	  num_elements += (len / 4);
d350 26
a375 6
	  /* Integral and pointer arguments.  */
	  gdb_assert (sparc_integral_or_pointer_p (type));

	  if (len < 4)
	    args[i] = value_cast (builtin_type_int32, args[i]);
	  num_elements += ((len + 3) / 4);
d378 26
d405 2
a406 2
  /* Always allocate at least six words.  */
  sp -= max (6, num_elements) * 4;
d408 1
a408 3
  /* The psABI says that "Software convention requires space for the
     struct/union return value pointer, even if the word is unused."  */
  sp -= 4;
d410 5
a414 4
  /* The psABI says that "Although software convention and the
     operating system require every stack frame to be doubleword
     aligned."  */
  sp &= ~0x7;
d416 1
a416 1
  for (i = 0; i < nargs; i++)
d418 2
a419 3
      char *valbuf = VALUE_CONTENTS (args[i]);
      struct type *type = VALUE_TYPE (args[i]);
      int len = TYPE_LENGTH (type);
d421 3
a423 1
      gdb_assert (len == 4 || len == 8);
d425 13
a437 3
      if (element < 6)
	{
	  int regnum = SPARC_O0_REGNUM + element;
d439 6
a444 4
	  regcache_cooked_write (regcache, regnum, valbuf);
	  if (len > 4 && element < 5)
	    regcache_cooked_write (regcache, regnum + 1, valbuf + 4);
	}
d446 17
a462 3
      /* Always store the argument in memory.  */
      write_memory (sp + 4 + element * 4, valbuf, len);
      element += len / 4;
d464 5
d470 4
a473 9
  gdb_assert (element == num_elements);

  if (struct_return)
    {
      char buf[4];

      store_unsigned_integer (buf, 4, struct_addr);
      write_memory (sp, buf, 4);
    }
d475 2
a476 1
  return sp;
d479 7
a485 17
static CORE_ADDR
sparc32_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
			 struct regcache *regcache, CORE_ADDR bp_addr,
			 int nargs, struct value **args, CORE_ADDR sp,
			 int struct_return, CORE_ADDR struct_addr)
{
  CORE_ADDR call_pc = (struct_return ? (bp_addr - 12) : (bp_addr - 8));

  /* Set return address.  */
  regcache_cooked_write_unsigned (regcache, SPARC_O7_REGNUM, call_pc);

  /* Set up function arguments.  */
  sp = sparc32_store_arguments (regcache, nargs, args, sp,
				struct_return, struct_addr);

  /* Allocate the 16-word window save area.  */
  sp -= 16 * 4;
d487 4
a490 2
  /* Stack should be doubleword aligned at this point.  */
  gdb_assert (sp % 8 == 0);
d492 2
a493 2
  /* Finally, update the stack pointer.  */
  regcache_cooked_write_unsigned (regcache, SPARC_SP_REGNUM, sp);
d495 1
a495 3
  return sp;
}

d497 3
a499 10
/* Use the program counter to determine the contents and size of a
   breakpoint instruction.  Return a pointer to a string of bytes that
   encode a breakpoint instruction, store the length of the string in
   *LEN and optionally adjust *PC to point to the correct memory
   location for inserting the breakpoint.  */
   
static const unsigned char *
sparc_breakpoint_from_pc (CORE_ADDR *pc, int *len)
{
  static unsigned char break_insn[] = { 0x91, 0xd0, 0x20, 0x01 };
d501 3
a503 2
  *len = sizeof (break_insn);
  return break_insn;
a504 1

d506 2
a507 1
/* Allocate and initialize a frame cache.  */
d509 2
a510 5
static struct sparc_frame_cache *
sparc_alloc_frame_cache (void)
{
  struct sparc_frame_cache *cache;
  int i;
d512 2
a513 1
  cache = FRAME_OBSTACK_ZALLOC (struct sparc_frame_cache);
d515 2
a516 3
  /* Base address.  */
  cache->base = 0;
  cache->pc = 0;
d518 3
a520 11
  /* Frameless until proven otherwise.  */
  cache->frameless_p = 1;

  cache->struct_return_p = 0;

  return cache;
}

CORE_ADDR
sparc_analyze_prologue (CORE_ADDR pc, CORE_ADDR current_pc,
			struct sparc_frame_cache *cache)
d522 1
a522 3
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  unsigned long insn;
  int offset = 0;
d524 2
d527 1
a527 17
  if (current_pc <= pc)
    return current_pc;

  /* We have to handle to "Procedure Linkage Table" (PLT) special.  On
     SPARC the linker usually defines a symbol (typically
     _PROCEDURE_LINKAGE_TABLE_) at the start of the .plt section.
     This symbol makes us end up here with PC pointing at the start of
     the PLT and CURRENT_PC probably pointing at a PLT entry.  If we
     would do our normal prologue analysis, we would probably conclude
     that we've got a frame when in reality we don't, since the
     dynamic linker patches up the first PLT with some code that
     starts with a SAVE instruction.  Patch up PC such that it points
     at the start of our PLT entry.  */
  if (tdep->plt_entry_size > 0 && in_plt_section (current_pc, NULL))
    pc = current_pc - ((current_pc - pc) % tdep->plt_entry_size);

  insn = sparc_fetch_instruction (pc);
d529 2
a530 2
  /* Recognize a SETHI insn and record its destination.  */
  if (X_OP (insn) == 0 && X_OP2 (insn) == 0x04)
d533 2
a534 3
      offset += 4;

      insn = sparc_fetch_instruction (pc + 4);
d537 8
a544 2
  /* Allow for an arithmetic operation on DEST or %g1.  */
  if (X_OP (insn) == 2 && X_I (insn)
d547 3
a549 1
      offset += 4;
d551 39
a589 1
      insn = sparc_fetch_instruction (pc + 8);
d591 3
d595 1
a595 2
  /* Check for the SAVE instruction that sets up the frame.  */
  if (X_OP (insn) == 2 && X_OP3 (insn) == 0x3c)
d597 52
a648 2
      cache->frameless_p = 0;
      return pc + offset + 4;
d654 2
a655 9
static CORE_ADDR
sparc_unwind_pc (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  return frame_unwind_register_unsigned (next_frame, tdep->pc_regnum);
}

/* Return PC of first real instruction of the function starting at
   START_PC.  */
d657 2
a658 2
static CORE_ADDR
sparc32_skip_prologue (CORE_ADDR start_pc)
a661 1
  struct sparc_frame_cache cache;
d674 2
a675 1
  return sparc_analyze_prologue (start_pc, 0xffffffffUL, &cache);
d678 1
a678 1
/* Normal frames.  */
d680 2
a681 2
struct sparc_frame_cache *
sparc_frame_cache (struct frame_info *next_frame, void **this_cache)
d683 2
a684 1
  struct sparc_frame_cache *cache;
d686 3
a688 2
  if (*this_cache)
    return *this_cache;
d690 1
a690 2
  cache = sparc_alloc_frame_cache ();
  *this_cache = cache;
d692 5
a696 3
  /* In priciple, for normal frames, %fp (%i6) holds the frame
     pointer, which holds the base address for the current stack
     frame.  */
d698 1
a698 3
  cache->base = frame_unwind_register_unsigned (next_frame, SPARC_FP_REGNUM);
  if (cache->base == 0)
    return cache;
d700 7
a706 2
  cache->pc = frame_func_unwind (next_frame);
  if (cache->pc != 0)
d708 40
a747 2
      CORE_ADDR addr_in_block = frame_unwind_address_in_block (next_frame);
      sparc_analyze_prologue (cache->pc, addr_in_block, cache);
d750 8
a757 7
  if (cache->frameless_p)
    {
      /* We didn't find a valid frame, which means that CACHE->base
	 currently holds the frame pointer for our calling frame.  */
      cache->base = frame_unwind_register_unsigned (next_frame,
						    SPARC_SP_REGNUM);
    }
d759 1
a759 2
  return cache;
}
d761 4
a764 2
struct sparc_frame_cache *
sparc32_frame_cache (struct frame_info *next_frame, void **this_cache)
d766 5
a770 2
  struct sparc_frame_cache *cache;
  struct symbol *sym;
d772 2
a773 2
  if (*this_cache)
    return *this_cache;
d775 1
a775 1
  cache = sparc_frame_cache (next_frame, this_cache);
d777 2
a778 2
  sym = find_pc_function (cache->pc);
  if (sym)
d780 13
a792 2
      struct type *type = check_typedef (SYMBOL_TYPE (sym));
      enum type_code code = TYPE_CODE (type);
d794 6
a799 1
      if (code == TYPE_CODE_FUNC || code == TYPE_CODE_METHOD)
d801 2
a802 4
	  type = check_typedef (TYPE_TARGET_TYPE (type));
	  if (sparc_structure_or_union_p (type)
	      || (sparc_floating_p (type) && TYPE_LENGTH (type) == 16))
	    cache->struct_return_p = 1;
d804 3
d809 3
a811 2
  return cache;
}
d813 55
a867 6
static void
sparc32_frame_this_id (struct frame_info *next_frame, void **this_cache,
		       struct frame_id *this_id)
{
  struct sparc_frame_cache *cache =
    sparc32_frame_cache (next_frame, this_cache);
d869 2
a870 3
  /* This marks the outermost frame.  */
  if (cache->base == 0)
    return;
d872 24
a895 31
  (*this_id) = frame_id_build (cache->base, cache->pc);
}

static void
sparc32_frame_prev_register (struct frame_info *next_frame, void **this_cache,
			     int regnum, int *optimizedp,
			     enum lval_type *lvalp, CORE_ADDR *addrp,
			     int *realnump, void *valuep)
{
  struct sparc_frame_cache *cache =
    sparc32_frame_cache (next_frame, this_cache);

  if (regnum == SPARC32_PC_REGNUM || regnum == SPARC32_NPC_REGNUM)
    {
      *optimizedp = 0;
      *lvalp = not_lval;
      *addrp = 0;
      *realnump = -1;
      if (valuep)
	{
	  CORE_ADDR pc = (regnum == SPARC32_NPC_REGNUM) ? 4 : 0;

	  /* If this functions has a Structure, Union or
             Quad-Precision return value, we have to skip the UNIMP
             instruction that encodes the size of the structure.  */
	  if (cache->struct_return_p)
	    pc += 4;

	  regnum = cache->frameless_p ? SPARC_O7_REGNUM : SPARC_I7_REGNUM;
	  pc += frame_unwind_register_unsigned (next_frame, regnum) + 8;
	  store_unsigned_integer (valuep, 4, pc);
d897 3
a899 1
      return;
d901 5
a905 11

  /* The previous frame's `local' and `in' registers have been saved
     in the register save area.  */
  if (!cache->frameless_p
      && regnum >= SPARC_L0_REGNUM && regnum <= SPARC_I7_REGNUM)
    {
      *optimizedp = 0;
      *lvalp = lval_memory;
      *addrp = cache->base + (regnum - SPARC_L0_REGNUM) * 4;
      *realnump = -1;
      if (valuep)
d907 8
a914 4
	  struct gdbarch *gdbarch = get_frame_arch (next_frame);

	  /* Read the value in from memory.  */
	  read_memory (*addrp, valuep, register_size (gdbarch, regnum));
d916 10
a925 1
      return;
d927 3
d931 1
a931 5
  /* The previous frame's `out' registers are accessable as the
     current frame's `in' registers.  */
  if (!cache->frameless_p
      && regnum >= SPARC_O0_REGNUM && regnum <= SPARC_O7_REGNUM)
    regnum += (SPARC_I0_REGNUM - SPARC_O0_REGNUM);
d933 3
a935 17
  frame_register_unwind (next_frame, regnum,
			 optimizedp, lvalp, addrp, realnump, valuep);
}

static const struct frame_unwind sparc32_frame_unwind =
{
  NORMAL_FRAME,
  sparc32_frame_this_id,
  sparc32_frame_prev_register
};

static const struct frame_unwind *
sparc32_frame_sniffer (struct frame_info *next_frame)
{
  return &sparc32_frame_unwind;
}

d937 1
a937 5
static CORE_ADDR
sparc32_frame_base_address (struct frame_info *next_frame, void **this_cache)
{
  struct sparc_frame_cache *cache =
    sparc32_frame_cache (next_frame, this_cache);
d939 1
a939 2
  return cache->base;
}
d941 4
a944 7
static const struct frame_base sparc32_frame_base =
{
  &sparc32_frame_unwind,
  sparc32_frame_base_address,
  sparc32_frame_base_address,
  sparc32_frame_base_address
};
d946 2
a947 2
static struct frame_id
sparc_unwind_dummy_id (struct gdbarch *gdbarch, struct frame_info *next_frame)
d949 2
a950 9
  CORE_ADDR sp;

  sp = frame_unwind_register_unsigned (next_frame, SPARC_SP_REGNUM);
  return frame_id_build (sp, frame_pc_unwind (next_frame));
}


/* Extract from an array REGBUF containing the (raw) register state, a
   function return value of TYPE, and copy that into VALBUF.  */
d952 1
a952 6
static void
sparc32_extract_return_value (struct type *type, struct regcache *regcache,
			      void *valbuf)
{
  int len = TYPE_LENGTH (type);
  char buf[8];
d954 1
a954 2
  gdb_assert (!sparc_structure_or_union_p (type));
  gdb_assert (!(sparc_floating_p (type) && len == 16));
d956 1
a956 1
  if (sparc_floating_p (type))
d958 8
a965 5
      /* Floating return values.  */
      regcache_cooked_read (regcache, SPARC_F0_REGNUM, buf);
      if (len > 4)
	regcache_cooked_read (regcache, SPARC_F1_REGNUM, buf + 4);
      memcpy (valbuf, buf, len);
d969 42
a1010 9
      /* Integral and pointer return values.  */
      gdb_assert (sparc_integral_or_pointer_p (type));

      regcache_cooked_read (regcache, SPARC_O0_REGNUM, buf);
      if (len > 4)
	{
	  regcache_cooked_read (regcache, SPARC_O1_REGNUM, buf + 4);
	  gdb_assert (len == 8);
	  memcpy (valbuf, buf, 8);
d1014 2
a1015 3
	  /* Just stripping off any unused bytes should preserve the
	     signed-ness just fine.  */
	  memcpy (valbuf, buf + 4 - len, len);
d1017 21
d1041 35
a1075 2
/* Write into the appropriate registers a function return value stored
   in VALBUF of type TYPE.  */
d1078 1
a1078 2
sparc32_store_return_value (struct type *type, struct regcache *regcache,
			    const void *valbuf)
d1080 4
a1083 2
  int len = TYPE_LENGTH (type);
  char buf[8];
d1085 1
a1085 2
  gdb_assert (!sparc_structure_or_union_p (type));
  gdb_assert (!(sparc_floating_p (type) && len == 16));
d1087 4
a1090 1
  if (sparc_floating_p (type))
d1092 46
a1137 5
      /* Floating return values.  */
      memcpy (buf, valbuf, len);
      regcache_cooked_write (regcache, SPARC_F0_REGNUM, buf);
      if (len > 4)
	regcache_cooked_write (regcache, SPARC_F1_REGNUM, buf + 4);
d1141 52
a1192 2
      /* Integral and pointer return values.  */
      gdb_assert (sparc_integral_or_pointer_p (type));
d1194 15
a1208 1
      if (len > 4)
d1210 3
a1212 3
	  gdb_assert (len == 8);
	  memcpy (buf, valbuf, 8);
	  regcache_cooked_write (regcache, SPARC_O1_REGNUM, buf + 4);
d1214 104
d1320 6
a1325 2
	  /* ??? Do we need to do any sign-extension here?  */
	  memcpy (buf + 4 - len, valbuf, len);
d1327 11
a1337 1
      regcache_cooked_write (regcache, SPARC_O0_REGNUM, buf);
d1339 1
d1342 10
a1351 13
static enum return_value_convention
sparc32_return_value (struct gdbarch *gdbarch, struct type *type,
		      struct regcache *regcache, void *readbuf,
		      const void *writebuf)
{
  if (sparc_structure_or_union_p (type)
      || (sparc_floating_p (type) && TYPE_LENGTH (type) == 16))
    return RETURN_VALUE_STRUCT_CONVENTION;

  if (readbuf)
    sparc32_extract_return_value (type, regcache, readbuf);
  if (writebuf)
    sparc32_store_return_value (type, regcache, writebuf);
d1353 6
a1358 1
  return RETURN_VALUE_REGISTER_CONVENTION;
d1361 11
a1371 15
#if 0
/* NOTE: cagney/2004-01-17: For the moment disable this method.  The
   architecture and CORE-gdb will need new code (and a replacement for
   EXTRACT_STRUCT_VALUE_ADDRESS) before this can be made to work
   robustly.  Here is a possible function signature: */
/* NOTE: cagney/2004-01-17: So far only the 32-bit SPARC ABI has been
   identifed as having a way to robustly recover the address of a
   struct-convention return-value (after the function has returned).
   For all other ABIs so far examined, the calling convention makes no
   guarenteed that the register containing the return-value will be
   preserved and hence that the return-value's address can be
   recovered.  */
/* Extract from REGCACHE, which contains the (raw) register state, the
   address in which a function should return its structure value, as a
   CORE_ADDR.  */
d1373 2
a1374 2
static CORE_ADDR
sparc32_extract_struct_value_address (struct regcache *regcache)
d1376 3
a1378 1
  ULONGEST sp;
d1380 12
a1391 4
  regcache_cooked_read_unsigned (regcache, SPARC_SP_REGNUM, &sp);
  return read_memory_unsigned_integer (sp + 64, 4);
}
#endif
d1393 7
a1399 5
static int
sparc32_stabs_argument_has_addr (struct gdbarch *gdbarch, struct type *type)
{
  return (sparc_structure_or_union_p (type)
	  || (sparc_floating_p (type) && TYPE_LENGTH (type) == 16));
a1400 1

d1402 42
a1443 3
/* The SPARC Architecture doesn't have hardware single-step support,
   and most operating systems don't implement it either, so we provide
   software single-step mechanism.  */
d1445 2
a1446 2
static CORE_ADDR
sparc_analyze_control_transfer (CORE_ADDR pc, CORE_ADDR *npc)
d1448 2
a1449 4
  unsigned long insn = sparc_fetch_instruction (pc);
  int conditional_p = X_COND (insn) & 0x7;
  int branch_p = 0;
  long offset = 0;			/* Must be signed for sign-extend.  */
d1451 9
a1459 1
  if (X_OP (insn) == 0 && X_OP2 (insn) == 3 && (insn & 0x1000000) == 0)
d1461 1
a1461 3
      /* Branch on Integer Register with Prediction (BPr).  */
      branch_p = 1;
      conditional_p = 1;
d1463 7
a1469 1
  else if (X_OP (insn) == 0 && X_OP2 (insn) == 6)
d1471 15
a1485 3
      /* Branch on Floating-Point Condition Codes (FBfcc).  */
      branch_p = 1;
      offset = 4 * X_DISP22 (insn);
d1487 1
a1487 1
  else if (X_OP (insn) == 0 && X_OP2 (insn) == 5)
d1489 28
a1516 4
      /* Branch on Floating-Point Condition Codes with Prediction
         (FBPfcc).  */
      branch_p = 1;
      offset = 4 * X_DISP19 (insn);
d1518 3
a1520 1
  else if (X_OP (insn) == 0 && X_OP2 (insn) == 2)
d1522 37
a1558 3
      /* Branch on Integer Condition Codes (Bicc).  */
      branch_p = 1;
      offset = 4 * X_DISP22 (insn);
d1560 1
a1560 1
  else if (X_OP (insn) == 0 && X_OP2 (insn) == 1)
d1562 1
a1562 3
      /* Branch on Integer Condition Codes with Prediction (BPcc).  */
      branch_p = 1;
      offset = 4 * X_DISP19 (insn);
d1564 17
d1582 2
a1583 1
  /* FIXME: Handle DONE and RETRY instructions.  */
d1585 2
a1586 1
  /* FIXME: Handle the Trap instruction.  */
d1588 19
a1606 1
  if (branch_p)
d1608 23
a1630 16
      if (conditional_p)
	{
	  /* For conditional branches, return nPC + 4 iff the annul
	     bit is 1.  */
	  return (X_A (insn) ? *npc + 4 : 0);
	}
      else
	{
	  /* For unconditional branches, return the target if its
	     specified condition is "always" and return nPC + 4 if the
	     condition is "never".  If the annul bit is 1, set *NPC to
	     zero.  */
	  if (X_COND (insn) == 0x0)
	    pc = *npc, offset = 4;
	  if (X_A (insn))
	    *npc = 0;
d1632 7
a1638 3
	  gdb_assert (offset != 0);
	  return pc + offset;
	}
d1640 1
d1642 3
a1644 2
  return 0;
}
d1647 1
a1647 1
sparc_software_single_step (enum target_signal sig, int insert_breakpoints_p)
d1649 5
a1653 3
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  static CORE_ADDR npc, nnpc;
  static char npc_save[4], nnpc_save[4];
d1655 1
a1655 1
  if (insert_breakpoints_p)
d1657 3
a1659 1
      CORE_ADDR pc;
d1661 10
a1670 14
      pc = sparc_address_from_register (tdep->pc_regnum);
      npc = sparc_address_from_register (tdep->npc_regnum);

      /* Analyze the instruction at PC.  */
      nnpc = sparc_analyze_control_transfer (pc, &npc);
      if (npc != 0)
	target_insert_breakpoint (npc, npc_save);
      if (nnpc != 0)
	target_insert_breakpoint (nnpc, nnpc_save);

      /* Assert that we have set at least one breakpoint, and that
         they're not set at the same spot.  */
      gdb_assert (npc != 0 || nnpc != 0);
      gdb_assert (nnpc != npc);
d1674 1
a1674 4
      if (npc != 0)
	target_remove_breakpoint (npc, npc_save);
      if (nnpc != 0)
	target_remove_breakpoint (nnpc, nnpc_save);
d1678 8
a1685 2
static void
sparc_write_pc (CORE_ADDR pc, ptid_t ptid)
d1687 3
a1689 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d1691 2
a1692 24
  write_register_pid (tdep->pc_regnum, pc, ptid);
  write_register_pid (tdep->npc_regnum, pc + 4, ptid);
}

/* Unglobalize NAME.  */

char *
sparc_stabs_unglobalize_name (char *name)
{
  /* The Sun compilers (Sun ONE Studio, Forte Developer, Sun WorkShop,
     SunPRO) convert file static variables into global values, a
     process known as globalization.  In order to do this, the
     compiler will create a unique prefix and prepend it to each file
     static variable.  For static variables within a function, this
     globalization prefix is followed by the function name (nested
     static variables within a function are supposed to generate a
     warning message, and are left alone).  The procedure is
     documented in the Stabs Interface Manual, which is distrubuted
     with the compilers, although version 4.0 of the manual seems to
     be incorrect in some places, at least for SPARC.  The
     globalization prefix is encoded into an N_OPT stab, with the form
     "G=<prefix>".  The globalization prefix always seems to start
     with a dollar sign '$'; a dot '.' is used as a seperator.  So we
     simply strip everything up until the last dot.  */
d1694 1
a1694 1
  if (name[0] == '$')
d1696 6
a1701 3
      char *p = strrchr (name, '.');
      if (p)
	return p + 1;
d1704 7
a1710 1
  return name;
a1711 1

d1713 11
a1723 2
/* Return the appropriate register set for the core section identified
   by SECT_NAME and SECT_SIZE.  */
d1725 2
a1726 3
const struct regset *
sparc_regset_from_core_section (struct gdbarch *gdbarch,
				const char *sect_name, size_t sect_size)
d1728 5
a1732 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
d1734 3
a1736 2
  if (strcmp (sect_name, ".reg") == 0 && sect_size >= tdep->sizeof_gregset)
    return tdep->gregset;
d1738 1
a1738 2
  if (strcmp (sect_name, ".reg2") == 0 && sect_size >= tdep->sizeof_fpregset)
    return tdep->fpregset;
d1740 1
a1740 1
  return NULL;
d1742 1
d1744 3
d1748 2
a1749 2
static struct gdbarch *
sparc32_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
d1751 18
a1768 2
  struct gdbarch_tdep *tdep;
  struct gdbarch *gdbarch;
d1770 2
a1771 4
  /* If there is already a candidate, use it.  */
  arches = gdbarch_list_lookup_by_info (arches, &info);
  if (arches != NULL)
    return arches->gdbarch;
d1773 1
a1773 3
  /* Allocate space for the new architecture.  */
  tdep = XMALLOC (struct gdbarch_tdep);
  gdbarch = gdbarch_alloc (&info, tdep);
d1775 49
a1823 31
  tdep->pc_regnum = SPARC32_PC_REGNUM;
  tdep->npc_regnum = SPARC32_NPC_REGNUM;
  tdep->gregset = NULL;
  tdep->sizeof_gregset = 0;
  tdep->fpregset = NULL;
  tdep->sizeof_fpregset = 0;
  tdep->plt_entry_size = 0;

  set_gdbarch_long_double_bit (gdbarch, 128);
  set_gdbarch_long_double_format (gdbarch, &floatformat_sparc_quad);

  set_gdbarch_num_regs (gdbarch, SPARC32_NUM_REGS);
  set_gdbarch_register_name (gdbarch, sparc32_register_name);
  set_gdbarch_register_type (gdbarch, sparc32_register_type);
  set_gdbarch_num_pseudo_regs (gdbarch, SPARC32_NUM_PSEUDO_REGS);
  set_gdbarch_pseudo_register_read (gdbarch, sparc32_pseudo_register_read);
  set_gdbarch_pseudo_register_write (gdbarch, sparc32_pseudo_register_write);

  /* Register numbers of various important registers.  */
  set_gdbarch_sp_regnum (gdbarch, SPARC_SP_REGNUM); /* %sp */
  set_gdbarch_pc_regnum (gdbarch, SPARC32_PC_REGNUM); /* %pc */
  set_gdbarch_fp0_regnum (gdbarch, SPARC_F0_REGNUM); /* %f0 */

  /* Call dummy code.  */
  set_gdbarch_call_dummy_location (gdbarch, ON_STACK);
  set_gdbarch_push_dummy_code (gdbarch, sparc32_push_dummy_code);
  set_gdbarch_push_dummy_call (gdbarch, sparc32_push_dummy_call);

  set_gdbarch_return_value (gdbarch, sparc32_return_value);
  set_gdbarch_stabs_argument_has_addr
    (gdbarch, sparc32_stabs_argument_has_addr);
d1825 2
a1826 1
  set_gdbarch_skip_prologue (gdbarch, sparc32_skip_prologue);
d1828 4
a1831 2
  /* Stack grows downward.  */
  set_gdbarch_inner_than (gdbarch, core_addr_lessthan);
d1833 5
a1837 1
  set_gdbarch_breakpoint_from_pc (gdbarch, sparc_breakpoint_from_pc);
d1839 19
a1857 1
  set_gdbarch_frame_args_skip (gdbarch, 8);
d1859 8
a1866 1
  set_gdbarch_print_insn (gdbarch, print_insn_sparc);
d1868 9
a1876 2
  set_gdbarch_software_single_step (gdbarch, sparc_software_single_step);
  set_gdbarch_write_pc (gdbarch, sparc_write_pc);
d1878 2
a1879 1
  set_gdbarch_unwind_dummy_id (gdbarch, sparc_unwind_dummy_id);
d1881 1
a1881 1
  set_gdbarch_unwind_pc (gdbarch, sparc_unwind_pc);
d1883 1
a1883 1
  frame_base_set_default (gdbarch, &sparc32_frame_base);
d1885 110
a1994 4
  /* Hook in ABI-specific overrides, if they have been registered.  */
  gdbarch_init_osabi (info, gdbarch);

  frame_unwind_append_sniffer (gdbarch, sparc32_frame_sniffer);
d1996 1
a1996 6
  /* If we have register sets, enable the generic core file support.  */
  if (tdep->gregset)
    set_gdbarch_regset_from_core_section (gdbarch,
					  sparc_regset_from_core_section);

  return gdbarch;
a1997 2

/* Helper functions for dealing with register windows.  */
d1999 6
a2004 2
void
sparc_supply_rwindow (struct regcache *regcache, CORE_ADDR sp, int regnum)
a2005 2
  int offset = 0;
  char buf[8];
d2007 3
d2011 1
a2011 1
  if (sp & 1)
d2013 3
a2015 4
      /* Registers are 64-bit.  */
      sp += BIAS;

      for (i = SPARC_L0_REGNUM; i <= SPARC_I7_REGNUM; i++)
d2017 1
a2017 1
	  if (regnum == i || regnum == -1)
d2019 4
a2022 2
	      target_read_memory (sp + ((i - SPARC_L0_REGNUM) * 8), buf, 8);
	      regcache_raw_supply (regcache, i, buf);
d2025 1
a2025 10
    }
  else
    {
      /* Registers are 32-bit.  Toss any sign-extension of the stack
	 pointer.  */
      sp &= 0xffffffffUL;

      /* Clear out the top half of the temporary buffer, and put the
	 register value in the bottom half if we're in 64-bit mode.  */
      if (gdbarch_ptr_bit (current_gdbarch) == 64)
d2027 2
a2028 2
	  memset (buf, 0, 4);
	  offset = 4;
d2031 10
a2040 1
      for (i = SPARC_L0_REGNUM; i <= SPARC_I7_REGNUM; i++)
d2042 2
a2043 6
	  if (regnum == i || regnum == -1)
	    {
	      target_read_memory (sp + ((i - SPARC_L0_REGNUM) * 4),
				  buf + offset, 4);
	      regcache_raw_supply (regcache, i, buf);
	    }
a2044 2
    }
}
d2046 7
a2052 7
void
sparc_collect_rwindow (const struct regcache *regcache,
		       CORE_ADDR sp, int regnum)
{
  int offset = 0;
  char buf[8];
  int i;
d2054 2
a2055 4
  if (sp & 1)
    {
      /* Registers are 64-bit.  */
      sp += BIAS;
d2057 2
a2058 3
      for (i = SPARC_L0_REGNUM; i <= SPARC_I7_REGNUM; i++)
	{
	  if (regnum == -1 || regnum == SPARC_SP_REGNUM || regnum == i)
d2060 6
a2065 2
	      regcache_raw_collect (regcache, i, buf);
	      target_write_memory (sp + ((i - SPARC_L0_REGNUM) * 8), buf, 8);
d2067 1
d2069 1
a2069 12
    }
  else
    {
      /* Registers are 32-bit.  Toss any sign-extension of the stack
	 pointer.  */
      sp &= 0xffffffffUL;

      /* Only use the bottom half if we're in 64-bit mode.  */
      if (gdbarch_ptr_bit (current_gdbarch) == 64)
	offset = 4;

      for (i = SPARC_L0_REGNUM; i <= SPARC_I7_REGNUM; i++)
d2071 6
a2076 1
	  if (regnum == -1 || regnum == SPARC_SP_REGNUM || regnum == i)
d2078 3
a2080 3
	      regcache_raw_collect (regcache, i, buf);
	      target_write_memory (sp + ((i - SPARC_L0_REGNUM) * 4),
				   buf + offset, 4);
d2083 6
d2092 9
a2100 1
/* Helper functions for dealing with register sets.  */
d2103 1
a2103 3
sparc32_supply_gregset (const struct sparc_gregset *gregset,
			struct regcache *regcache,
			int regnum, const void *gregs)
d2105 3
a2107 2
  const char *regs = gregs;
  int i;
d2109 4
a2112 3
  if (regnum == SPARC32_PSR_REGNUM || regnum == -1)
    regcache_raw_supply (regcache, SPARC32_PSR_REGNUM,
			 regs + gregset->r_psr_offset);
d2114 1
a2114 3
  if (regnum == SPARC32_PC_REGNUM || regnum == -1)
    regcache_raw_supply (regcache, SPARC32_PC_REGNUM,
			 regs + gregset->r_pc_offset);
d2116 7
a2122 3
  if (regnum == SPARC32_NPC_REGNUM || regnum == -1)
    regcache_raw_supply (regcache, SPARC32_NPC_REGNUM,
			 regs + gregset->r_npc_offset);
d2124 5
a2128 3
  if (regnum == SPARC32_Y_REGNUM || regnum == -1)
    regcache_raw_supply (regcache, SPARC32_Y_REGNUM,
			 regs + gregset->r_y_offset);
d2130 1
a2130 4
  if (regnum == SPARC_G0_REGNUM || regnum == -1)
    regcache_raw_supply (regcache, SPARC_G0_REGNUM, NULL);

  if ((regnum >= SPARC_G1_REGNUM && regnum <= SPARC_O7_REGNUM) || regnum == -1)
d2132 3
a2134 1
      int offset = gregset->r_g1_offset;
d2136 11
a2146 1
      for (i = SPARC_G1_REGNUM; i <= SPARC_O7_REGNUM; i++)
d2148 2
a2149 3
	  if (regnum == i || regnum == -1)
	    regcache_raw_supply (regcache, i, regs + offset);
	  offset += 4;
d2153 15
a2167 1
  if ((regnum >= SPARC_L0_REGNUM && regnum <= SPARC_I7_REGNUM) || regnum == -1)
d2169 4
a2172 3
      /* Not all of the register set variants include Locals and
         Inputs.  For those that don't, we read them off the stack.  */
      if (gregset->r_l0_offset == -1)
d2174 2
a2175 4
	  ULONGEST sp;

	  regcache_cooked_read_unsigned (regcache, SPARC_SP_REGNUM, &sp);
	  sparc_supply_rwindow (regcache, sp, regnum);
d2179 3
a2181 1
	  int offset = gregset->r_l0_offset;
d2183 7
a2189 1
	  for (i = SPARC_L0_REGNUM; i <= SPARC_I7_REGNUM; i++)
d2191 2
a2192 3
	      if (regnum == i || regnum == -1)
		regcache_raw_supply (regcache, i, regs + offset);
	      offset += 4;
d2194 19
d2215 38
d2255 8
d2264 143
a2406 3
sparc32_collect_gregset (const struct sparc_gregset *gregset,
			 const struct regcache *regcache,
			 int regnum, void *gregs)
a2407 1
  char *regs = gregs;
d2410 94
a2503 3
  if (regnum == SPARC32_PSR_REGNUM || regnum == -1)
    regcache_raw_collect (regcache, SPARC32_PSR_REGNUM,
			  regs + gregset->r_psr_offset);
d2505 13
a2517 3
  if (regnum == SPARC32_PC_REGNUM || regnum == -1)
    regcache_raw_collect (regcache, SPARC32_PC_REGNUM,
			  regs + gregset->r_pc_offset);
d2519 9
a2527 3
  if (regnum == SPARC32_NPC_REGNUM || regnum == -1)
    regcache_raw_collect (regcache, SPARC32_NPC_REGNUM,
			  regs + gregset->r_npc_offset);
d2529 1
a2529 3
  if (regnum == SPARC32_Y_REGNUM || regnum == -1)
    regcache_raw_collect (regcache, SPARC32_Y_REGNUM,
			  regs + gregset->r_y_offset);
d2531 2
a2532 1
  if ((regnum >= SPARC_G1_REGNUM && regnum <= SPARC_O7_REGNUM) || regnum == -1)
d2534 3
a2536 1
      int offset = gregset->r_g1_offset;
d2538 1
a2538 2
      /* %g0 is always zero.  */
      for (i = SPARC_G1_REGNUM; i <= SPARC_O7_REGNUM; i++)
d2540 2
a2541 3
	  if (regnum == i || regnum == -1)
	    regcache_raw_collect (regcache, i, regs + offset);
	  offset += 4;
d2543 1
d2546 13
a2558 1
  if ((regnum >= SPARC_L0_REGNUM && regnum <= SPARC_I7_REGNUM) || regnum == -1)
d2560 30
a2589 3
      /* Not all of the register set variants include Locals and
         Inputs.  For those that don't, we read them off the stack.  */
      if (gregset->r_l0_offset != -1)
d2591 82
a2672 1
	  int offset = gregset->r_l0_offset;
d2674 8
a2681 1
	  for (i = SPARC_L0_REGNUM; i <= SPARC_I7_REGNUM; i++)
d2683 5
a2687 3
	      if (regnum == i || regnum == -1)
		regcache_raw_collect (regcache, i, regs + offset);
	      offset += 4;
d2693 53
a2745 3
void
sparc32_supply_fpregset (struct regcache *regcache,
			 int regnum, const void *fpregs)
d2747 28
a2774 2
  const char *regs = fpregs;
  int i;
d2776 4
a2779 1
  for (i = 0; i < 32; i++)
d2781 13
a2793 2
      if (regnum == (SPARC_F0_REGNUM + i) || regnum == -1)
	regcache_raw_supply (regcache, SPARC_F0_REGNUM + i, regs + (i * 4));
d2796 1
a2796 2
  if (regnum == SPARC32_FSR_REGNUM || regnum == -1)
    regcache_raw_supply (regcache, SPARC32_FSR_REGNUM, regs + (32 * 4) + 4);
d2799 39
a2837 3
void
sparc32_collect_fpregset (const struct regcache *regcache,
			  int regnum, void *fpregs)
d2839 2
a2840 2
  char *regs = fpregs;
  int i;
d2842 4
a2845 1
  for (i = 0; i < 32; i++)
d2847 6
a2852 2
      if (regnum == (SPARC_F0_REGNUM + i) || regnum == -1)
	regcache_raw_collect (regcache, SPARC_F0_REGNUM + i, regs + (i * 4));
d2854 18
d2873 138
a3010 2
  if (regnum == SPARC32_FSR_REGNUM || regnum == -1)
    regcache_raw_collect (regcache, SPARC32_FSR_REGNUM, regs + (32 * 4) + 4);
a3011 1

d3013 15
a3027 1
/* SunOS 4.  */
d3029 2
a3030 2
/* From <machine/reg.h>.  */
const struct sparc_gregset sparc32_sunos4_gregset =
d3032 306
a3337 10
  0 * 4,			/* %psr */
  1 * 4,			/* %pc */
  2 * 4,			/* %npc */
  3 * 4,			/* %y */
  -1,				/* %wim */
  -1,				/* %tbr */
  4 * 4,			/* %g1 */
  -1				/* %l0 */
};

d3339 2
a3340 2
/* Provide a prototype to silence -Wmissing-prototypes.  */
void _initialize_sparc_tdep (void);
d3342 2
a3343 2
void
_initialize_sparc_tdep (void)
d3345 19
a3363 1
  register_gdbarch_init (bfd_arch_sparc, sparc32_gdbarch_init);
@


1.38
log
@2002-07-26  Andrew Cagney  <ac131313@@redhat.com>

* z8k-tdep.c: Do not include "obstack.h".
* h8300-tdep.c, h8500-tdep.c: Ditto.
* m68hc11-tdep.c, sh-tdep.c: Ditto.
* valprint.c, v850-tdep.c: Ditto.
* d10v-tdep.c, mn10300-tdep.c: Ditto.
* mn10200-tdep.c: Ditto.

* Makefile.in (z8k-tdep.o): Update dependencies.
(m68hc11-tdep.o, valprint.o): Ditto.
(v850-tdep.o, d10v-tdep.o): Ditto.
(mn10300-tdep.o, sparc-tdep.o): Ditto.
(sh-tdep.o, h8500-tdep.o, h8300-tdep.o): Ditto.
(m32r-tdep.o, mn10200-tdep.o): Specify dependencies.
(sh_opc_h, gdb_sim_sh_h): Define.
(elf_sh_h, elf_bfd_h): Define.
(opcode_m68hc11_h): Define.
(OPCODES_SRC, OPCODES_DIR): define.
(OPCODES): Use $(OPCODES_DIR).
(gdb_sim_d10v_h): Rename sim_d10v_h.
(gdb_sim_arm_h): Rename sim_arm_h.
@
text
@d3223 1
a3223 1
      set_gdbarch_store_return_value (gdbarch, sparc_store_return_value);
d3234 1
a3234 1
      set_gdbarch_store_return_value (gdbarch, sparclet_store_return_value);
d3245 1
a3245 1
      set_gdbarch_store_return_value (gdbarch, sparc_store_return_value);
d3256 1
a3256 1
      set_gdbarch_store_return_value (gdbarch, sparc_store_return_value);
d3267 1
a3267 1
      set_gdbarch_store_return_value (gdbarch, sparc_store_return_value);
d3278 1
a3278 1
      set_gdbarch_store_return_value (gdbarch, sparc_store_return_value);
d3289 1
a3289 1
      set_gdbarch_store_return_value (gdbarch, sparc_store_return_value);
d3300 1
a3300 1
      set_gdbarch_store_return_value (gdbarch, sparc_store_return_value);
@


1.37
log
@* gdbarch.sh (REGISTER_NAME): Change return type a constant string
pointer.
* gdbarch.h, gdbarch.c: Regenerate.
* config/mips/tm-mips.h (mips_register_name): Update.
* i386-tdep.h (i386_register_name): Update.
* mips-tdep.c (mips_register_name): Update
* alpha-tdep.c (alpha_register_name): Update.
* arch-utils.c (legacy_register_name): Update.
* arch-utils.h (legacy_register_name): Update.
* avr-tdep.c (avr_register_name): Update.
* ia64-tdep.c (ia64_register_name): Update.
* i386-tdep.c (i386_register_name): Update.
* sparc-tdep.c (sparc32_register_name): Update.
(sparc64_register_name): Update.
(sparclite_register_name): Update.
(sparclet_register_name):
* sh-tdep.c (sh_generic_register_name): Update.
(sh_sh_register_name): Update.
(sh_sh3_register_name): Update.
(sh_sh3e_register_name): Update.
(sh_sh_dsp_register_name): Update.
(sh_sh3_dsp_register_name): Update.
(sh_sh4_register_name): Update.
(sh_sh64_register_name): Update.
* s390-tdep.c (s390_register_name): Update.
* rs6000-tdep.c (rs6000_register_name): Update.
* ns32k-tdep.c (ns32k_register_name_32082): Update.
(ns32k_register_name_32382): Update.
* d10v-tdep.c (d10v_ts2_register_name): Update.
(d10v_ts3_register_name): Update.
* xstormy16-tdep.c (xstormy16_register_name): Update.
* vax-tdep.c (vax_register_name): Update.
* v850-tdep.c (v850_register_name): Update.
* m68hc11-tdep.c (m68hc11_register_name): Update.
* mn10300-tdep.c (mn10300_generic_register_name): Update.
(am33_register_name): Update.
@
text
@a29 1
#include "obstack.h"
@


1.36
log
@+	* gdbarch.sh (DEPRECATED_EXTRACT_RETURN_VALUE): Rename
+	EXTRACT_RETURN_VALUE.
+	(DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS): Rename
+	EXTRACT_STRUCT_VALUE_ADDRESS.
+	* gdbarch.h, gdbarch.c: Regenerate.
+
+	* values.c (value_being_returned): Handle
+	DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS.
+	(EXTRACT_RETURN_VALUE): Define as DEPRECATED_EXTRACT_RETURN_VALUE.
+
+	* arm-linux-tdep.c (arm_linux_init_abi): Update.
+	* arm-tdep.c (arm_gdbarch_init): Update.
+	* avr-tdep.c (avr_gdbarch_init): Update.
+	* cris-tdep.c (cris_gdbarch_init): Update.
+	* d10v-tdep.c (d10v_gdbarch_init): Update.
+	* ia64-tdep.c (ia64_gdbarch_init): Update.
+	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
+	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
+	* s390-tdep.c (s390_gdbarch_init): Update.
+	* sh-tdep.c (sh_gdbarch_init): Update.
+	* s390-tdep.c (s390_gdbarch_init): Update.
+	* sparc-tdep.c (sparc_gdbarch_init): Update.
+	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
+	* v850-tdep.c (v850_gdbarch_init): Update.
+	* vax-tdep.c (vax_gdbarch_init): Update.
+	* x86-64-tdep.c (x86_64_gdbarch_init): Update.
+	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
+
+	* config/arc/tm-arc.h: Update.
+	* config/d30v/tm-d30v.h: Update.
+	* config/fr30/tm-fr30.h: Update.
+	* config/h8300/tm-h8300.h: Update.
* config/h8500/tm-h8500.h: Update.
* config/i386/tm-i386.h: Update.
* config/i386/tm-ptx.h: Update.
* config/i386/tm-symmetry.h: Update.
* config/i960/tm-i960.h: Update.
* config/m32r/tm-m32r.h: Update.
* config/m68k/tm-delta68.h: Update.
* config/m68k/tm-linux.h: Update.
* config/m68k/tm-m68k.h: Update.
* config/m88k/tm-m88k.h: Update.
* config/mcore/tm-mcore.h: Update.
* config/mips/tm-mips.h: Update.
* config/mn10200/tm-mn10200.h: Update.
* config/pa/tm-hppa.h: Update.
* config/pa/tm-hppa64.h: Update.
* config/sparc/tm-sp64.h: Update.
* config/sparc/tm-sparc.h: Update.
* config/sparc/tm-sparclet.h: Update.
* config/z8k/tm-z8k.h: Update.
@
text
@d2554 1
a2554 1
static char *
d2578 1
a2578 1
static char *
d2610 1
a2610 1
static char *
d2635 1
a2635 1
static char *
@


1.35
log
@* Makefile.in (sparc-tdep.o): Add osabi.h to dependency list.
* sparc-tdep.c: Include osabi.h.
(gdbarch_tdep): Add osabi member.
(_initialize_sparc_tdep): Use gdbarch_register.
(sparc_gdbarch_init): Use generic OS ABI framework.
(sparc_dump_tdep): New function.
@
text
@d3005 1
a3005 2
  set_gdbarch_extract_struct_value_address (gdbarch, 
					    sparc_extract_struct_value_address);
d3219 1
a3219 1
      set_gdbarch_extract_return_value (gdbarch, sparc32_extract_return_value);
d3230 1
a3230 2
      set_gdbarch_extract_return_value (gdbarch, 
					sparclet_extract_return_value);
d3241 1
a3241 1
      set_gdbarch_extract_return_value (gdbarch, sparc32_extract_return_value);
d3252 1
a3252 1
      set_gdbarch_extract_return_value (gdbarch, sparc32_extract_return_value);
d3263 1
a3263 1
      set_gdbarch_extract_return_value (gdbarch, sparc32_extract_return_value);
d3274 1
a3274 1
      set_gdbarch_extract_return_value (gdbarch, sparc32_extract_return_value);
d3285 1
a3285 1
      set_gdbarch_extract_return_value (gdbarch, sparc64_extract_return_value);
d3296 1
a3296 1
      set_gdbarch_extract_return_value (gdbarch, sparc64_extract_return_value);
@


1.34
log
@* sparc-tdep.c (sparc_get_saved_register): Comment why
get_prev_frame call is safe.
@
text
@d36 1
d115 2
d2278 1
d2284 1
a2284 1
  register_gdbarch_init (bfd_arch_sparc, sparc_gdbarch_init);
d2937 1
d2961 13
d2975 9
a2983 3
  arches = gdbarch_list_lookup_by_info (arches, &info);
  if (arches != NULL)
    return arches->gdbarch;
d2993 2
d3310 3
d3316 11
@


1.34.6.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@a35 1
#include "osabi.h"
a113 2

    enum gdb_osabi osabi;
a2274 1
static void sparc_dump_tdep (struct gdbarch *, struct ui_file *);
d2280 1
a2280 1
  gdbarch_register (bfd_arch_sparc, sparc_gdbarch_init, sparc_dump_tdep);
d2550 1
a2550 1
static const char *
d2574 1
a2574 1
static const char *
d2606 1
a2606 1
static const char *
d2631 1
a2631 1
static const char *
a2932 1
  enum gdb_osabi osabi = GDB_OSABI_UNKNOWN;
a2955 13
  /* Try to determine the OS ABI of the object we are loading.  */

  if (info.abfd != NULL)
    {
      osabi = gdbarch_lookup_osabi (info.abfd);
      if (osabi == GDB_OSABI_UNKNOWN)
	{
	  /* If it's an ELF file, assume it's Solaris.  */
	  if (bfd_get_flavour (info.abfd) == bfd_target_elf_flavour)
	    osabi = GDB_OSABI_SOLARIS;
	}
    }

d2957 3
a2959 9
  for (arches = gdbarch_list_lookup_by_info (arches, &info);
       arches != NULL;
       arches = gdbarch_list_lookup_by_info (arches->next, &info))
    {
      /* Make sure the ABI selection matches.  */
      tdep = gdbarch_tdep (arches->gdbarch);
      if (tdep && tdep->osabi == osabi)
	return arches->gdbarch;
    }
a2968 2
  tdep->osabi = osabi;

d2979 2
a2980 1
  set_gdbarch_deprecated_extract_struct_value_address (gdbarch, sparc_extract_struct_value_address);
d3194 1
a3194 1
      set_gdbarch_deprecated_extract_return_value (gdbarch, sparc32_extract_return_value);
d3205 2
a3206 1
      set_gdbarch_deprecated_extract_return_value (gdbarch, sparclet_extract_return_value);
d3217 1
a3217 1
      set_gdbarch_deprecated_extract_return_value (gdbarch, sparc32_extract_return_value);
d3228 1
a3228 1
      set_gdbarch_deprecated_extract_return_value (gdbarch, sparc32_extract_return_value);
d3239 1
a3239 1
      set_gdbarch_deprecated_extract_return_value (gdbarch, sparc32_extract_return_value);
d3250 1
a3250 1
      set_gdbarch_deprecated_extract_return_value (gdbarch, sparc32_extract_return_value);
d3261 1
a3261 1
      set_gdbarch_deprecated_extract_return_value (gdbarch, sparc64_extract_return_value);
d3272 1
a3272 1
      set_gdbarch_deprecated_extract_return_value (gdbarch, sparc64_extract_return_value);
a3283 3
  /* Hook in OS ABI-specific overrides, if they have been registered.  */
  gdbarch_init_osabi (info, gdbarch, osabi);

a3286 11
static void
sparc_dump_tdep (struct gdbarch *current_gdbarch, struct ui_file *file)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

  if (tdep == NULL)
    return;

  fprintf_unfiltered (file, "sparc_dump_tdep: OS ABI = %s\n",
		      gdbarch_osabi_name (tdep->osabi));
}
@


1.34.6.2
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d30 1
@


1.34.6.3
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@d3223 1
a3223 1
      set_gdbarch_deprecated_store_return_value (gdbarch, sparc_store_return_value);
d3234 1
a3234 1
      set_gdbarch_deprecated_store_return_value (gdbarch, sparclet_store_return_value);
d3245 1
a3245 1
      set_gdbarch_deprecated_store_return_value (gdbarch, sparc_store_return_value);
d3256 1
a3256 1
      set_gdbarch_deprecated_store_return_value (gdbarch, sparc_store_return_value);
d3267 1
a3267 1
      set_gdbarch_deprecated_store_return_value (gdbarch, sparc_store_return_value);
d3278 1
a3278 1
      set_gdbarch_deprecated_store_return_value (gdbarch, sparc_store_return_value);
d3289 1
a3289 1
      set_gdbarch_deprecated_store_return_value (gdbarch, sparc_store_return_value);
d3300 1
a3300 1
      set_gdbarch_deprecated_store_return_value (gdbarch, sparc_store_return_value);
@


1.34.6.4
log
@merge from mainline
@
text
@d959 1
a959 1
	deprecated_read_register_gen (regnum, raw_buffer);
d1248 1
a1248 1
	      deprecated_write_register_gen (FPS_REGNUM, raw_buffer);
d1253 1
a1253 1
	      deprecated_write_register_gen (CPS_REGNUM, raw_buffer);
d1612 1
a1612 1
      deprecated_read_register_gen (regi, (char *) (regp + regi) + offset);
d1615 1
a1615 1
    deprecated_read_register_gen (PC_REGNUM, (char *) (regp + R_PC) + offset);
d1618 1
a1618 1
    deprecated_read_register_gen (NPC_REGNUM, (char *) (regp + R_nPC) + offset);
d1621 1
a1621 1
    deprecated_read_register_gen (Y_REGNUM, (char *) (regp + R_Y) + offset);
d1627 1
a1627 1
	deprecated_read_register_gen (CCR_REGNUM, ((char *) (regp + R_CCR)) + offset);
d1631 1
a1631 1
	deprecated_read_register_gen (FPRS_REGNUM, ((char *) (regp + R_FPRS)) + offset);
d1635 1
a1635 1
	deprecated_read_register_gen (ASI_REGNUM, ((char *) (regp + R_ASI)) + offset);
d1642 1
a1642 1
	deprecated_read_register_gen (PS_REGNUM, ((char *) (regp + R_PS)) + offset);
d1658 1
a1658 1
	deprecated_read_register_gen (WIM_REGNUM, ((char *) (regp + R_WIM)) + offset);
d1661 1
a1661 1
	deprecated_read_register_gen (WIM_REGNUM, NULL);
d1666 1
a1666 1
	deprecated_read_register_gen (TBR_REGNUM, ((char *) (regp + R_TBR)) + offset);
d1669 1
a1669 1
	deprecated_read_register_gen (TBR_REGNUM, NULL);
d2102 1
a2102 1
	deprecated_write_register_gen (O0_REGNUM + oregnum, m_arg->contents + j);
d2158 1
a2158 1
      deprecated_write_register_gen (regno, buffer);
d2443 1
a2443 1
	      deprecated_write_register_gen (oreg, VALUE_CONTENTS (copyarg) + j);
@


1.34.4.1
log
@merge from trunk
@
text
@a35 1
#include "osabi.h"
a113 2

    enum gdb_osabi osabi;
a2274 1
static void sparc_dump_tdep (struct gdbarch *, struct ui_file *);
d2280 1
a2280 1
  gdbarch_register (bfd_arch_sparc, sparc_gdbarch_init, sparc_dump_tdep);
a2932 1
  enum gdb_osabi osabi = GDB_OSABI_UNKNOWN;
a2955 13
  /* Try to determine the OS ABI of the object we are loading.  */

  if (info.abfd != NULL)
    {
      osabi = gdbarch_lookup_osabi (info.abfd);
      if (osabi == GDB_OSABI_UNKNOWN)
	{
	  /* If it's an ELF file, assume it's Solaris.  */
	  if (bfd_get_flavour (info.abfd) == bfd_target_elf_flavour)
	    osabi = GDB_OSABI_SOLARIS;
	}
    }

d2957 3
a2959 9
  for (arches = gdbarch_list_lookup_by_info (arches, &info);
       arches != NULL;
       arches = gdbarch_list_lookup_by_info (arches->next, &info))
    {
      /* Make sure the ABI selection matches.  */
      tdep = gdbarch_tdep (arches->gdbarch);
      if (tdep && tdep->osabi == osabi)
	return arches->gdbarch;
    }
a2968 2
  tdep->osabi = osabi;

d2979 2
a2980 1
  set_gdbarch_deprecated_extract_struct_value_address (gdbarch, sparc_extract_struct_value_address);
d3194 1
a3194 1
      set_gdbarch_deprecated_extract_return_value (gdbarch, sparc32_extract_return_value);
d3205 2
a3206 1
      set_gdbarch_deprecated_extract_return_value (gdbarch, sparclet_extract_return_value);
d3217 1
a3217 1
      set_gdbarch_deprecated_extract_return_value (gdbarch, sparc32_extract_return_value);
d3228 1
a3228 1
      set_gdbarch_deprecated_extract_return_value (gdbarch, sparc32_extract_return_value);
d3239 1
a3239 1
      set_gdbarch_deprecated_extract_return_value (gdbarch, sparc32_extract_return_value);
d3250 1
a3250 1
      set_gdbarch_deprecated_extract_return_value (gdbarch, sparc32_extract_return_value);
d3261 1
a3261 1
      set_gdbarch_deprecated_extract_return_value (gdbarch, sparc64_extract_return_value);
d3272 1
a3272 1
      set_gdbarch_deprecated_extract_return_value (gdbarch, sparc64_extract_return_value);
a3283 3
  /* Hook in OS ABI-specific overrides, if they have been registered.  */
  gdbarch_init_osabi (info, gdbarch, osabi);

a3286 11
static void
sparc_dump_tdep (struct gdbarch *current_gdbarch, struct ui_file *file)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

  if (tdep == NULL)
    return;

  fprintf_unfiltered (file, "sparc_dump_tdep: OS ABI = %s\n",
		      gdbarch_osabi_name (tdep->osabi));
}
@


1.34.4.2
log
@Merge with trunk.
@
text
@d2554 1
a2554 1
static const char *
d2578 1
a2578 1
static const char *
d2610 1
a2610 1
static const char *
d2635 1
a2635 1
static const char *
@


1.33
log
@* sparc-tdep.c (sparc_gdbarch_init): Add comment explaining why
ON_STACK is needed.
@
text
@d858 5
d867 5
@


1.32
log
@2002-04-24  David S. Miller  <davem@@redhat.com>

	* sparc-tdep.c (sparc_gdbarch_skip_prologue): Kill, duplicates
	sparc_skip_prologue.
	(sparc_skip_prologue): Kill frameless_p arg, and use line number
	information to find prologue when possible.
	(sparc_prologue_frameless_p): Call examine_prologue directly.
	(sparc_gdbarch_init): Update set_gdbarch_skip_prologue call.
	* config/sparc/tm-sparc.h (sparc_skip_prologue): Update for killed
	second argument.
	(SKIP_PROLOGUE): Likewise.
@
text
@d3029 44
@


1.31
log
@2002-04-20  David S. Miller  <davem@@redhat.com>

	* sparc-tdep.c (sparc_pop_frame): Only need to allocate
	SPARC_INTREG_SIZE * 16 bytes for reg_temp.
@
text
@d688 3
d692 1
a692 1
sparc_skip_prologue (CORE_ADDR start_pc, int frameless_p)
d694 16
a709 1
  return examine_prologue (start_pc, frameless_p, NULL, NULL);
d717 1
a717 1
  return ip == sparc_skip_prologue (ip, 1);
a2804 9
/* Advance PC across any function entry prologue instructions to reach
   some "real" code.  */

static CORE_ADDR
sparc_gdbarch_skip_prologue (CORE_ADDR ip)
{
  return examine_prologue (ip, 0, NULL, NULL);
}

d3005 1
a3005 1
  set_gdbarch_skip_prologue (gdbarch, sparc_gdbarch_skip_prologue);
@


1.30
log
@Revert Sparc OS abi changes.
@
text
@d1265 1
a1265 1
      reg_temp = alloca (REGISTER_BYTES);
@


1.29
log
@2002-04-20  David S. Miller  <davem@@redhat.com>

	* sparc-tdep.h: New file.
	* sparc-tdep.c (elf-bfd.h): Include.
	(SPARC_HAS_FPU, FP_REGISTER_BYTES, FP_MAX_REGNUM,
	SPARC_INTREG_SIZE, DUMMY_REG_SAVE_OFFSET, gdbarch_tdep,
	CALL_DUMMY_CALL_OFFSET): Move out to sparc-tdep.h
	(sparc_dump_tdep): New function.
	(_initialize_sparc_tdep): Use gdbarch_register instead of
	register_gdbarch_init which is deprecated.
	(process_note_abi_tag_sections, sparc_abi_handler,
	sparc_abi_handler_list, sparc_gdbarch_register_os_abi): New.
	(sparc_gdbarch_init): Determine elf os ident key based upon
	either the elf header or by using process_note_abi_tag_sections.
	Fix 'gdbarch already exists' test by comparing os_ident as well.
	As the last action, invoke OS abi_handler if installed.
@
text
@a36 2
#include "elf-bfd.h"

d47 68
a114 1
#include "sparc-tdep.h"
d2143 5
a2247 2
static void sparc_dump_tdep (struct gdbarch *gdbarch, struct ui_file *file);

d2252 1
a2252 1
  gdbarch_register (bfd_arch_sparc, sparc_gdbarch_init, sparc_dump_tdep);
a2892 86

static void
process_note_abi_tag_sections (bfd *abfd, asection *sect, void *obj)
{
  int *os_ident_ptr = obj;
  const char *name;
  unsigned int sect_size;

  name = bfd_get_section_name (abfd, sect);
  sect_size = bfd_section_size (abfd, sect);
  if (strcmp (name, ".note.ABI-tag") == 0 && sect_size > 0)
    {
      unsigned int name_length, data_length, note_type;
      char *note = alloca (sect_size);

      bfd_get_section_contents (abfd, sect, note,
                                (file_ptr) 0, (bfd_size_type) sect_size);

      name_length = bfd_h_get_32 (abfd, note);
      data_length = bfd_h_get_32 (abfd, note + 4);
      note_type = bfd_h_get_32 (abfd, note + 8);

      if (name_length == 4 && data_length == 16 && note_type == 1
          && strcmp (note + 12, "GNU") == 0)
        {
          int os_number = bfd_h_get_32 (abfd, note + 16);

          /* The case numbers are from abi-tags in glibc.  */
          switch (os_number)
            {
            case 0:
              *os_ident_ptr = ELFOSABI_LINUX;
              break;
            case 1:
              *os_ident_ptr = ELFOSABI_HURD;
              break;
            case 2:
              *os_ident_ptr = ELFOSABI_SOLARIS;
              break;
            default:
              internal_error (__FILE__, __LINE__,
                              "process_note_abi_sections: "
                              "unknown OS number %d", os_number);
              break;
            }
        }
    }
}

struct sparc_abi_handler
{
  struct sparc_abi_handler *next;
  int os_ident;
  void (*init_abi)(struct gdbarch_info, struct gdbarch *);
};

struct sparc_abi_handler *sparc_abi_handler_list = NULL;

void
sparc_gdbarch_register_os_abi (int os_ident,
			       void (*init_abi)(struct gdbarch_info,
						struct gdbarch *))
{
  struct sparc_abi_handler *p;

  for (p = sparc_abi_handler_list; p != NULL; p = p->next)
    {
      if (p->os_ident == os_ident)
	{
	  internal_error
	    (__FILE__, __LINE__,
	     "sparc_gdbarch_register_os_abi: A handler for this ABI variant (%d)"
	     " has already been registered", (int)os_ident);
	  /* If user wants to continue, override previous definition.  */
	  p->init_abi = init_abi;
	  return;
	}
    }

  p = (struct sparc_abi_handler *) xmalloc (sizeof (*p));
  p->os_ident = os_ident;
  p->init_abi = init_abi;
  p->next = sparc_abi_handler_list;
  sparc_abi_handler_list = p;
}

a2913 2
  struct sparc_abi_handler *abi_handler;
  int os_ident;
a2936 18
  if (info.abfd != NULL
      && bfd_get_flavour (info.abfd) == bfd_target_elf_flavour)
    {
      os_ident = elf_elfheader (info.abfd)->e_ident[EI_OSABI];

      /* If os_ident is 0, it is not necessarily the case that we're
         on a SYSV system.  (ELFOSABI_NONE is defined to be 0.)
         GNU/Linux uses a note section to record OS/ABI info, but
         leaves e_ident[EI_OSABI] zero.  So we have to check for note
         sections too.  */
      if (os_ident == ELFOSABI_NONE)
	bfd_map_over_sections (info.abfd,
			       process_note_abi_tag_sections,
			       &os_ident);
    }
  else
    os_ident = -1;

d2938 3
a2940 8
  for (arches = gdbarch_list_lookup_by_info (arches, &info);
       arches != NULL;
       arches = gdbarch_list_lookup_by_info (arches->next, &info))
    {
      tdep = gdbarch_tdep (arches->gdbarch);
      if (tdep && tdep->os_ident == os_ident)
        return arches->gdbarch;
    }
a2949 2
  tdep->os_ident = os_ident;

a3220 9
  for (abi_handler = sparc_abi_handler_list;
       abi_handler;
       abi_handler = abi_handler->next)
    if (abi_handler->os_ident == os_ident)
      break;

  if (abi_handler)
    abi_handler->init_abi (info, gdbarch);

a3223 92
static void
sparc_dump_tdep (struct gdbarch *gdbarch, struct ui_file *file)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

  if (tdep == NULL)
    return;

  fprintf_unfiltered (file, "sparc_dump_tdep: os_ident ");
  switch (tdep->os_ident)
    {
    case ELFOSABI_NONE:
      fprintf_unfiltered (file, "ELFOSABI_NONE");
      break;
    case ELFOSABI_NETBSD:
      fprintf_unfiltered (file, "ELFOSABI_NETBSD");
      break;
    case ELFOSABI_LINUX:
      fprintf_unfiltered (file, "ELFOSABI_LINUX");
      break;
    case ELFOSABI_HURD:
      fprintf_unfiltered (file, "ELFOSABI_HURD");
      break;
    case ELFOSABI_SOLARIS:
      fprintf_unfiltered (file, "ELFOSABI_SOLARIS");
      break;
    case ELFOSABI_FREEBSD:
      fprintf_unfiltered (file, "ELFOSABI_FREEBSD");
      break;
    case ELFOSABI_OPENBSD:
      fprintf_unfiltered (file, "ELFOSABI_OPENBSD");
      break;
    case ELFOSABI_STANDALONE:
      fprintf_unfiltered (file, "ELFOSABI_STANDALONE");
      break;
    default:
      fprintf_unfiltered (file, "UNKNOWN");
      break;
    }

  fprintf_unfiltered (file, "sparc_dump_tdep: has_fpu %d\n",
		      tdep->has_fpu);
  fprintf_unfiltered (file, "sparc_dump_tdep: fp_register_bytes %d\n",
		      tdep->fp_register_bytes);
  fprintf_unfiltered (file, "sparc_dump_tdep: y_regnum %d\n",
		      tdep->y_regnum);
  fprintf_unfiltered (file, "sparc_dump_tdep: fp_max_regnum %d\n",
		      tdep->fp_max_regnum);
  fprintf_unfiltered (file, "sparc_dump_tdep: intreg_size %d\n",
		      tdep->intreg_size);
  fprintf_unfiltered (file, "sparc_dump_tdep: reg_save_offset %d\n",
		      tdep->reg_save_offset);
  fprintf_unfiltered (file, "sparc_dump_tdep: call_dummy_call_offset %d\n",
		      tdep->call_dummy_call_offset);
  fprintf_unfiltered (file, "sparc_dump_tdep: print_insn_mach ");
  switch (tdep->print_insn_mach)
    {
    case bfd_mach_sparc:
      fprintf_unfiltered (file, "bfd_mach_sparc\n");
      break;
    case bfd_mach_sparc_sparclet:
      fprintf_unfiltered (file, "bfd_mach_sparc_sparclet\n");
      break;
    case bfd_mach_sparc_sparclite:
      fprintf_unfiltered (file, "bfd_mach_sparc_sparclite\n");
      break;
    case bfd_mach_sparc_sparclite_le:
      fprintf_unfiltered (file, "bfd_mach_sparc_sparclite_le\n");
      break;
    case bfd_mach_sparc_v8plus:
      fprintf_unfiltered (file, "bfd_mach_sparc_v8plus\n");
      break;
    case bfd_mach_sparc_v8plusa:
      fprintf_unfiltered (file, "bfd_mach_sparc_v8plusa\n");
      break;
    case bfd_mach_sparc_v8plusb:
      fprintf_unfiltered (file, "bfd_mach_sparc_v8plusb\n");
      break;
    case bfd_mach_sparc_v9:
      fprintf_unfiltered (file, "bfd_mach_sparc_v9\n");
      break;
    case bfd_mach_sparc_v9a:
      fprintf_unfiltered (file, "bfd_mach_sparc_v9a\n");
      break;
    case bfd_mach_sparc_v9b:
      fprintf_unfiltered (file, "bfd_mach_sparc_v9b\n");
      break;
    default:
      fprintf_unfiltered (file, "UNKNOWN\n");
      break;
    };
}
@


1.28
log
@2002-04-21  David S. Miller  <davem@@redhat.com>

	* arch-utils.c (generic_prologue_frameless_p): Kill
	SKIP_PROLOGUE_FRAMELESS_P code.
	* config/arc/tm-arc.h (SKIP_PROLOGUE_FRAMELESS_P): Delete
	references.
	(PROLOGUE_FRAMELESS_P, arc_prologue_frameless_p): New.
	* arc-tdep.c (arc_prologue_frameless_p): Implement.
	* config/arc/tm-sparc.h (SKIP_PROLOGUE_FRAMELESS_P): Delete
	references.
	(PROLOGUE_FRAMELESS_P, sparc_prologue_frameless_p): New.
	* sparc-tdep.c (sparc_prologue_frameless_p): Implement.
	(sparc_gdbarch_init): Pass it to
	set_gdbarch_prologue_frameless_p.
@
text
@d37 2
d49 1
a49 68
/*
 * Some local macros that have multi-arch and non-multi-arch versions:
 */

#if (GDB_MULTI_ARCH > 0)

/* Does the target have Floating Point registers?  */
#define SPARC_HAS_FPU     (gdbarch_tdep (current_gdbarch)->has_fpu)
/* Number of bytes devoted to Floating Point registers: */
#define FP_REGISTER_BYTES (gdbarch_tdep (current_gdbarch)->fp_register_bytes)
/* Highest numbered Floating Point register.  */
#define FP_MAX_REGNUM     (gdbarch_tdep (current_gdbarch)->fp_max_regnum)
/* Size of a general (integer) register: */
#define SPARC_INTREG_SIZE (gdbarch_tdep (current_gdbarch)->intreg_size)
/* Offset within the call dummy stack of the saved registers.  */
#define DUMMY_REG_SAVE_OFFSET (gdbarch_tdep (current_gdbarch)->reg_save_offset)

#else /* non-multi-arch */


/* Does the target have Floating Point registers?  */
#if defined(TARGET_SPARCLET) || defined(TARGET_SPARCLITE)
#define SPARC_HAS_FPU 0
#else
#define SPARC_HAS_FPU 1
#endif

/* Number of bytes devoted to Floating Point registers: */
#if (GDB_TARGET_IS_SPARC64)
#define FP_REGISTER_BYTES (64 * 4)
#else
#if (SPARC_HAS_FPU)
#define FP_REGISTER_BYTES (32 * 4)
#else
#define FP_REGISTER_BYTES 0
#endif
#endif

/* Highest numbered Floating Point register.  */
#if (GDB_TARGET_IS_SPARC64)
#define FP_MAX_REGNUM (FP0_REGNUM + 48)
#else
#define FP_MAX_REGNUM (FP0_REGNUM + 32)
#endif

/* Size of a general (integer) register: */
#define SPARC_INTREG_SIZE (REGISTER_RAW_SIZE (G0_REGNUM))

/* Offset within the call dummy stack of the saved registers.  */
#if (GDB_TARGET_IS_SPARC64)
#define DUMMY_REG_SAVE_OFFSET (128 + 16)
#else
#define DUMMY_REG_SAVE_OFFSET 0x60
#endif

#endif /* GDB_MULTI_ARCH */

struct gdbarch_tdep
  {
    int has_fpu;
    int fp_register_bytes;
    int y_regnum;
    int fp_max_regnum;
    int intreg_size;
    int reg_save_offset;
    int call_dummy_call_offset;
    int print_insn_mach;
  };
a2077 5
#ifndef CALL_DUMMY_CALL_OFFSET
#define CALL_DUMMY_CALL_OFFSET \
     (gdbarch_tdep (current_gdbarch)->call_dummy_call_offset)
#endif /* CALL_DUMMY_CALL_OFFSET */

d2178 2
d2184 1
a2184 1
  register_gdbarch_init (bfd_arch_sparc, sparc_gdbarch_init);
d2825 86
d2932 2
d2957 18
d2976 8
a2983 3
  arches = gdbarch_list_lookup_by_info (arches, &info);
  if (arches != NULL)
    return arches->gdbarch;
d2993 2
d3266 9
d3278 92
@


1.27
log
@* sparc-tdep.c (sparc_get_saved_register): Use get_prev_frame
instead of ->prev.
* z8k-tdep.c (z8k_frame_chain): Do not use ->prev.
* s390-tdep.c (s390_frame_chain): Do not use ->prev.
* rs6000-tdep.c (frame_get_saved_regs): Use rs6000_frame_chain()
instead of ->prev.
@
text
@d694 8
d2788 1
a2788 4
   some "real" code.  SKIP_PROLOGUE_FRAMELESS_P advances the PC past
   some of the prologue, but stops as soon as it knows that the
   function has a frame.  Its result is equal to its input PC if the
   function is frameless, unequal otherwise.  */
d2994 1
@


1.26
log
@* defs.h (read_relative_register_raw_bytes): Delete declaration.
* frame.c (frame_register_read): New function.  Return non-zero on
success.
(read_relative_register_raw_bytes_for_frame): Delete.
(read_relative_register_raw_bytes): Delete.
* frame.h (frame_register_read): Declare.
* d30v-tdep.c: Update Copyright.  Use frame_register_read.
* sh-tdep.c: Ditto.
* infcmd.c (do_registers_info): Ditto.
* hppa-tdep.c: Ditto.
* rs6000-tdep.c: Ditto.
* h8500-tdep.c: Ditto.
* mips-tdep.c: Ditto.
* h8300-tdep.c: Ditto.
* z8k-tdep.c: Ditto.
@
text
@d832 1
a832 1
	    addr = (frame1->prev->extra_info->bottom
d836 1
a836 1
	    addr = (frame1->prev->extra_info->bottom
d878 1
a878 1
	    addr = (frame1->prev->extra_info->bottom
d882 1
a882 1
	    addr = (frame1->prev->extra_info->bottom
@


1.25
log
@* sparc-tdep.c (sparc_push_dummy_frame): Use GDB_TARGET_IS_SPARC64
as test for 64 bit target.
@
text
@d2 4
a5 2
   Copyright 1986, 1987, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996,
   1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
d1834 2
a1835 2
      if (!read_relative_register_raw_bytes (regno, value)
	  && !read_relative_register_raw_bytes (regno + 1, value + 4))
d1843 2
a1844 2
	  if (!read_relative_register_raw_bytes (regno + 2, value + 8)
	      && !read_relative_register_raw_bytes (regno + 3, value + 12))
d1863 2
a1864 2
      if (!read_relative_register_raw_bytes (regno, value)
	  && !read_relative_register_raw_bytes (regno + 1, value + 8))
@


1.24
log
@* sparc-tdep.c (sparc64_write_fp): Delete.
(sparc_push_dummy_frame): Replace write_fp call with code to store
the FP directly.
(sparc_gdbarch_init): Do not initialize write_fp.
@
text
@d995 1
a995 1
      if (gdbarch_tdep (current_gdbarch)->intreg_size == 8)
@


1.23
log
@* arc-tdep.c (get_longjmp_target): Only compile this function if JB_PC
is defined.
* sparc-tdep.c (get_longjmp_target): Likewise.
@
text
@d989 20
a1008 2
      write_fp (old_sp);

a2281 10
void
sparc64_write_fp (CORE_ADDR val)
{
  CORE_ADDR oldfp = read_register (FP_REGNUM);
  if (oldfp & 1)
    write_register (FP_REGNUM, val - 2047);
  else
    write_register (FP_REGNUM, val);
}

a3048 1
      set_gdbarch_write_fp (gdbarch, generic_target_write_fp);
a3106 1
      set_gdbarch_write_fp (gdbarch, sparc64_write_fp);
@


1.22
log
@Assume TARGET_BYTE_ORDER_SELECTABLE{,_P} is always true.
@
text
@d1689 3
a1691 2

#ifdef GET_LONGJMP_TARGET
@


1.21
log
@Eliminate IEEE_FLOAT.
@
text
@d2203 2
a2204 9
      if (TARGET_BYTE_ORDER_SELECTABLE_P)
	{
	  target_byte_order = BFD_ENDIAN_LITTLE;
	  bi_endian = 1;
	}
      else
	{
	  warning ("This GDB does not support little endian sparclite.");
	}
@


1.20
log
@2001-12-30  Michael Snyder  <msnyder@@redhat.com>

        * sparc-tdep.c (sparc-store-return-value): Whitespace fix-up.
@
text
@a2965 1
  set_gdbarch_ieee_float (gdbarch, 1);
@


1.19
log
@LITTLE_ENDIAN -> BFD_ENDIAN_LITTLE
@
text
@d2083 1
a2083 1
  buffer = alloca(MAX_REGISTER_RAW_SIZE);
@


1.18
log
@s/value_ptr/struct value */
@
text
@d2066 1
a2066 1
		     || TARGET_BYTE_ORDER == LITTLE_ENDIAN ? 0
d2205 1
a2205 1
	  target_byte_order = LITTLE_ENDIAN;
@


1.17
log
@* sparc-tdep.c (sparc_gdbarch_init): Get the architecture from
info.bfd_arch_info.
@
text
@d1986 1
a1986 1
sparc32_push_arguments (int nargs, value_ptr *args, CORE_ADDR sp,
d2005 1
a2005 1
      value_ptr arg = args[i];
d2295 1
a2295 1
sparc64_push_arguments (int nargs, value_ptr *args, CORE_ADDR sp,
d2310 1
a2310 1
      value_ptr copyarg = args[i];
d2336 1
a2336 1
      value_ptr copyarg = args[i];
@


1.16
log
@Gag -Wuninitialized warnings.
Add -Wuninitialized to default warning list.
@
text
@d2934 1
a2934 1
  if (info.bfd_architecture != bfd_arch_sparc)
@


1.15
log
@Update/correct copyright notices.
@
text
@d2384 2
@


1.14
log
@Create new file regcache.h.  Update all uses.
@
text
@d2 2
a3 2
   Copyright 1986, 1987, 1989, 1991, 1992, 1993, 1994, 1995, 1996, 1997,
   1998, 1999, 2000, 2001 Free Software Foundation, Inc.
@


1.13
log
@Add __FILE__ and __LINE__ parameter to internal_error() /
internal_verror().
@
text
@d33 1
@


1.12
log
@	* sparc-tdep.c: update copyright notice.
@
text
@d529 2
a530 1
    internal_error ("create_new_frame returned invalid frame");
d1057 2
a1058 1
    internal_error ("Bad frame info struct in FRAME_FIND_SAVED_REGS");
@


1.11
log
@2001-01-02  Michael Snyder  <msnyder@@cleaver.cygnus.com>

        * sparc-tdep.c (sparc-frame-chain): Fix typo in comment.
@
text
@d2 2
a3 2
   Copyright 1986, 1987, 1989, 1991, 1992, 1993, 1994, 1995, 1996, 1997
   Free Software Foundation, Inc.
@


1.10
log
@2000-12-20  Michael Snyder  <msnyder@@mvstp600e.cygnus.com>

        * arch-utils.c (default_frame_address): New function.  Default
        implementation of frame_args_address and frame_locals_address.
        * arch-utils.h (default_frame_address): Export.
        * d10v-tdep.c (d10v_gdbarch_init): Use default_frame_address.
        (d10v_frame_args_address, d10v_frame_locals_address): Delete.
        * sh-tdep.c (sh_gdbarch_init): Use default_frame_address.
        (sh_frame_args_address, sh_frame_locals_address): Delete.
        * sparc-tdep.c (sparc_gdbarch_init): Use default_frame_address.
        (sparc_frame_address): Delete.
@
text
@d428 1
a428 1
     value.  If it realy is zero, we detect it later in
@


1.9
log
@Reorganize solib.c.
@
text
@a2812 8
/* The frame address: stored in the 'frame' field of the frame_info.  */

static CORE_ADDR
sparc_frame_address (struct frame_info *fi)
{
  return fi->frame;
}

d2952 1
a2952 1
  set_gdbarch_frame_args_address (gdbarch, sparc_frame_address);
d2955 1
a2955 1
  set_gdbarch_frame_locals_address (gdbarch, sparc_frame_address);
@


1.8
log
@	* sparc-tdep.c (sparc_fix_call_dummy):  Improve comments.
	Adjust call_dummy_breakpoint_offset, so that `finish' after a stop
	in a call dummy works.
	(sparc_gdbarch_init):  Fix setting of pc_in_call_dummy, it depends
	on SPARC32/64_CALL_DUMMY_ON_STACK, not DO_CALL_DUMMY_ON_STACK.
@
text
@d36 2
a42 3

/* Prototypes for supply_gregset etc. */
#include "gregset.h"
@


1.7
log
@        * sparc-tdep.c (sparc_init_extra_frame_info): Fix number of
        arguments to fetch_instruction.
@
text
@d2139 21
a2159 7
  /* Comply with strange Sun cc calling convention for struct-returning
     functions.  */
  if (!using_gcc
      && (TYPE_CODE (value_type) == TYPE_CODE_STRUCT
	  || TYPE_CODE (value_type) == TYPE_CODE_UNION))
    store_unsigned_integer (dummy + CALL_DUMMY_CALL_OFFSET + 8, 4,
			    TYPE_LENGTH (value_type) & 0x1fff);
a2977 5
#ifdef DO_CALL_DUMMY_ON_STACK
  set_gdbarch_pc_in_call_dummy (gdbarch, pc_in_call_dummy_on_stack);
#else
  set_gdbarch_pc_in_call_dummy (gdbarch, pc_in_call_dummy_at_entry_point);
#endif
d3011 1
d3018 1
d3067 1
d3075 1
@


1.6
log
@Protoization.
@
text
@d343 1
a343 1
      insn = fetch_instruction (prologue_start, 4);
@


1.5
log
@2000-05-26  Michael Snyder  <msnyder@@seadog.cygnus.com>

        * gregset.h: New file.  Typedefs for gdb_gregset_t and
        gdb_fpregset_t, prototypes for supply_gregset and friends.
        * procfs.c: Include gregset.h.  Delete local prototypes for
        supply_gregset etc., and local typedef gdb_gregset_t etc.
        * sol-thread.c: Include gregset.h, delete local prototypes,
        add appropriate casts to gdb_gregset_t.
        * uw-thread.c, lin-thread.c, core-sol2.c, core-regset.c,
        sparc-tdep.c, ptx4-nat.c, ppc-linux-nat.c, mipsv4-nat.c,
        m88k-nat.c, m68klinux-nat.c, m68k-tdep.c, irix5-nat.c,
        irix4-nat.c, ia64-linux-nat.c, i386v4-nat.c, cxux-nat.c,
        arm-linux-nat.c, alpha-nat.c: Include gregset.h.
        * config/nm-linux.h: Define GDB_GREGSET_T, GDB_FPREGET_T.
        * config/sparc/tm-sun4sol2.h: Ditto.
@
text
@d145 1
a145 2
fetch_instruction (pc)
     CORE_ADDR pc;
d212 2
a213 3
sparc_software_single_step (ignore, insert_breakpoints_p)
     enum target_signal ignore;	/* pid, but we don't need it */
     int insert_breakpoints_p;
d287 1
a287 3
sparc_init_extra_frame_info (fromleaf, fi)
     int fromleaf;
     struct frame_info *fi;
d426 1
a426 2
sparc_frame_chain (frame)
     struct frame_info *frame;
d435 1
a435 2
sparc_extract_struct_value_address (regbuf)
     char *regbuf;
d444 1
a444 2
sparc_frame_saved_pc (frame)
     struct frame_info *frame;
d520 1
a520 3
setup_arbitrary_frame (argc, argv)
     int argc;
     CORE_ADDR *argv;
d550 2
a551 5
examine_prologue (start_pc, frameless_p, fi, saved_regs)
     CORE_ADDR start_pc;
     int frameless_p;
     struct frame_info *fi;
     CORE_ADDR *saved_regs;
d686 1
a686 3
sparc_skip_prologue (start_pc, frameless_p)
     CORE_ADDR start_pc;
     int frameless_p;
d698 1
a698 3
isbranch (instruction, addr, target)
     long instruction;
     CORE_ADDR addr, *target;
d767 3
a769 7
sparc_get_saved_register (raw_buffer, optimized, addrp, frame, regnum, lval)
     char *raw_buffer;
     int *optimized;
     CORE_ADDR *addrp;
     struct frame_info *frame;
     int regnum;
     enum lval_type *lval;
d940 1
a940 1
sparc_push_dummy_frame ()
d1051 1
a1051 3
sparc_frame_find_saved_regs (fi, saved_regs_addr)
     struct frame_info *fi;
     CORE_ADDR *saved_regs_addr;
d1164 1
a1164 1
sparc_pop_frame ()
d1319 1
a1319 2
sparc_pc_adjust (pc)
     CORE_ADDR pc;
d1346 1
a1346 2
sunos4_skip_trampoline_code (pc)
     CORE_ADDR pc;
d1418 1
a1418 2
supply_gregset (gregsetp)
     gdb_gregset_t *gregsetp;
d1539 1
a1539 3
fill_gregset (gregsetp, regno)
     gdb_gregset_t *gregsetp;
     int regno;
d1619 1
a1619 2
supply_fpregset (fpregsetp)
     gdb_fpregset_t *fpregsetp;
d1657 1
a1657 3
fill_fpregset (fpregsetp, regno)
     gdb_fpregset_t *fpregsetp;
     int regno;
d1697 1
a1697 2
get_longjmp_target (pc)
     CORE_ADDR *pc;
d1720 1
a1720 2
sunpro_static_transform_name (name)
     char *name;
d1747 1
a1747 3
dump_ccreg (reg, val)
     char *reg;
     int val;
d1758 1
a1758 2
decode_asi (val)
     int val;
d1801 1
a1801 2
sparc_print_register_hook (regno)
     int regno;
d1972 1
a1972 3
gdb_print_insn_sparc (memaddr, info)
     bfd_vma memaddr;
     disassemble_info *info;
d1984 2
a1985 6
sparc32_push_arguments (nargs, args, sp, struct_return, struct_addr)
     int nargs;
     value_ptr *args;
     CORE_ADDR sp;
     int struct_return;
     CORE_ADDR struct_addr;
d2053 1
a2053 4
sparc32_extract_return_value (type, regbuf, valbuf)
     struct type *type;
     char *regbuf;
     char *valbuf;
d2076 1
a2076 3
sparc_store_return_value (type, valbuf)
     struct type *type;
     char *valbuf;
d2127 2
a2128 6
sparc_fix_call_dummy (dummy, pc, fun, value_type, using_gcc)
     char *dummy;
     CORE_ADDR pc;
     CORE_ADDR fun;
     struct type *value_type;
     int using_gcc;
d2181 1
a2181 2
sparc_target_architecture_hook (ap)
     const bfd_arch_info_type *ap;
d2211 1
a2211 1
_initialize_sparc_tdep ()
d2245 1
a2245 2
sparc64_write_sp (val)
     CORE_ADDR val;
d2255 1
a2255 2
sparc64_write_fp (val)
     CORE_ADDR val;
d2279 2
a2280 6
sparc64_push_arguments (nargs, args, sp, struct_return, struct_retaddr)
     int nargs;
     value_ptr *args;
     CORE_ADDR sp;
     int struct_return;
     CORE_ADDR struct_retaddr;
d2394 2
a2395 5
sp64_extract_return_value (type, regbuf, valbuf, bitoffset)
     struct type *type;
     char *regbuf;
     char *valbuf;
     int bitoffset;
@


1.4
log
@2000-05-17  Michael Snyder  <msnyder@@seadog.cygnus.com>

        * config/sparc/tm-sun4sol2.h: Turn on multi-arch.
        * sparc-tdep.c (gdb_print_insn_sparc): Remove temp. multi-arch hack.
@
text
@d42 3
a1436 2


d1443 1
a1443 1
     prgregset_t *gregsetp;
d1565 1
a1565 1
     prgregset_t *gregsetp;
d1647 1
a1647 1
     prfpregset_t *fpregsetp;
d1686 1
a1686 1
     prfpregset_t *fpregsetp;
@


1.3
log
@2000-05-10  Michael Snyder  <msnyder@@seadog.cygnus.com>
	Make Sparc a Multi-Arch target.  Discard PARAMS macro (require ANSI).
	* sparc-tdep.c: include arch-utils.h.
	(SPARC_HAS_FPU, FP_REGISTER_BYTES, FP_MAX_REG NUM, SPARC_INTREG_SIZE,
	DUMMY_REG_SAVE_OFFSET): provide multi-arch-compatible definitions.
	(GDB_TARGET_IS_SPARC64): make into a runtime test.
	(struct frame_extra_info): Define, use instead of the macro.
	(Many places): Use alloca instead of statically allocated buffers
	that depend on a multi-arch variable such as MAX_REGISTER_RAW_SIZE.
	(sparc_extract_struct_value_address): Accept a pointer arg instead
	of an array sized by REGISTER_BYTES.
	(examine_prologue): Accept a pointer to an array of CORE_ADDR,
	instead of the defunct struct frame_saved_regs.  Recognize new
	Sparc64 store instructions as part of the prologue.  Ignore the
	destination of a frame store when parsing the prologue (so long
	as it's on the stack).
	(sparc_push_dummy_frame): Fix incorrect buffer offset for PSTATE.
	(sparc_frame_find_saved_regs): Accept a ptr to an array of CORE_ADDR
	instead of the defunct struct frame_saved_regs.
	(supply_gregset): Discard unnecessary 'zerobuf': just send NULL to
	supply_register.  Provide 4-byte offset to compensate for diff
	between size of the prgreg_t elements on a 64-bit host and size
	of the registers for a 32-bit target.  Fill all inaccessible regs
	with zero so they won't keep being requested again and again.
	(fill_gregset): Handle 32/64 size difference between registers
	and prgreg_t.  Handle as many new 64-bit regs as possible.
	(supply_fpregset, fill_fpregset): Attempt to handle 64-bit world.
	(sparc_push_arguments): Rename to sparc32_push_arguments.
	Copy arguments into registers as well as onto stack, so that the
	CALL_DUMMY (code pushed onto the target stack) is not required.
	(sparc_extract_return_value): Rename to sparc32_extract_return_value.
	(sparc_store_return_value): Use memset instead of bzero.
	Use write_register_gen instead of write_register_bytes.
	(sparclet_store_return_value): New function.
	(_initialize_sparc_tdep): Call register_gdbarch_init to activate
	the gdbarch multi-architecture system.
	(sp64_push_arguments): Rename to sparc64_push_arguments.
	Extend to store arguments in general registers as well as on stack.
	(sparc64_extract_return_value): Rename to sp64_extract_return_value.
	Use as a private function, to be called by the new external function
	sparc64_extract_return_value.
	(sparclet_extract_return_value): New function.
	(sparc32_stack_align, sparc64_stack_align, sparc32_register_name,
	sparc64_register_name, sparc_print_extra_frame_info,
	sparclite_register_name, sparclet_register_name,
	sparc_push_return_address, sparc64_use_struct_convention,
	sparc32_store_struct_return, sparc64_store_struct_return,
	sparc32_register_virtual_type, sparc64_register_virtual_type,
	sparc32_register_size, sparc64_register_size,
	sparc32_register_byte, sparc64_register_byte,
	sparc_gdbarch_skip_prologue, sparc_convert_to_virtual,
	sparc_convert_to_raw, sparc_frame_init_saved_regs,
	sparc_frame_address, sparc_gdbarch_fix_call_dummy,
	sparc_coerce_float_to_double, sparc_call_dummy_address,
	sparc_y_regnum, sparc_reg_struct_has_addr, sparc_intreg_size,
	sparc_return_value_on_stack): New functions supporting multi-arch.
	(sparc_gdbarch_init): New function; initialize multi-arch.
	(struct gdbarch_tdep): Define, use for private multi-arch data.
	* config/sparc/tm-sparc.h: Move definitions around, enclose with
	#ifdef GDB_MULTI_ARCH tests, provide some multi-arch alternate
	definitions.  Add enums for register names, to help debugging gdb.
	This header file must work for non-multi-arch and for multi-arch.
	* config/sparc/tm-sp64.h: Add GDB_MULTI_ARCH configuration.  Also add
	AT_ENTRY_POINT definitions for CALL_DUMMY, for non-multi-arch case.
	Define GDB_MULTI_ARCH.
	* config/sparc/tm-sparclet.h: Add GDB_MULTI_ARCH configuration.
	Do not define GDB_MULTI_ARCH (bfd does not correctly identify target).
	* config/sparc/tm-sparclite.h: Ditto.
	* config/sparc/tm-sun4sol2.h: Define GDB_MULTI_ARCH.
	* sparclet-rom.c (sparclet_regnames): Initialize explicitly, to
	avoid using deprecated REGISTER_NAMES macro.
	* Makefile.in: Let sparc-tdep.c depend on arch-utils.h.
@
text
@a2012 4
#if 1
  /* Selects sparc/sparclite/sparclet/sparc64 */
  tm_print_insn_info.mach = gdbarch_tdep (current_gdbarch) -> print_insn_mach;
#endif
@


1.2
log
@2000-05-08  Michael Snyder  <msnyder@@seadog.cygnus.com>

        * gdbarch.sh: Add FP0_REGNUM to list of multi-arched register numbers.
        * gdbarch.c, gdbarch.h: Regenerate.
        * core-regset.c: Change FP0_REGNUM to a runtime test.
        * procfs.c: Ditto.
        * sun3-nat.c: Ditto.
        * sparc-tdep.c: Ditto.

        * i386mach-nat.c: Remove unnecessary ifdef for FP0_REGNUM.
        * ptx4-nat.c: Ditto.

        * sol-thread.c (sol_thread_create_inferior): only add the thread
        to the thread list if it is not already in there.
        (prototypes for thread_db func ptrs): pretty up formatting.
@
text
@d25 1
d40 23
d69 2
a70 1
#ifdef GDB_TARGET_IS_SPARC64
d72 1
a72 1
#else 
d80 4
a83 2
/* If not defined, assume 32 bit sparc.  */
#ifndef FP_MAX_REGNUM
d87 1
d90 29
d128 1
a128 1
int deferred_stores = 0;	/* Cumulates stores we want to do eventually. */
d186 2
a187 6
  Error, not_branch, bicc, bicca, ba, baa, ticc, ta,
#ifdef GDB_TARGET_IS_SPARC64
  done_retry
#endif
}
branch_type;
d199 1
a199 1
static branch_type isbranch PARAMS ((long, CORE_ADDR, CORE_ADDR *));
d247 1
a247 2
#ifdef GDB_TARGET_IS_SPARC64
      else if (br == done_retry)
a251 1
#endif
d266 18
a283 5
/* Call this for each newly created frame.  For SPARC, we need to calculate
   the bottom of the frame, and do some extra work if the prologue
   has been generated via the -mflat option to GCC.  In particular,
   we need to know where the previous fp and the pc have been stashed,
   since their exact position within the frame may vary.  */
d294 5
a298 1
  fi->bottom =
d300 2
a301 2
     (fi->frame == fi->next->frame ? fi->next->bottom : fi->next->frame) :
     read_sp ());
d307 3
a309 1
      char buf[MAX_REGISTER_RAW_SIZE];
d321 1
a321 1
	  fi->bottom = fi->next->bottom;
d328 2
a329 2
#ifdef GDB_TARGET_IS_SPARC64
	  if (fi->frame & 1)
a330 2
#endif

d336 2
a337 2
  fi->flat = 0;
  fi->in_prologue = 0;
d357 3
a359 1
	      char buf[MAX_REGISTER_RAW_SIZE];
d362 1
a362 1
	      fi->flat = 1;
d364 1
a364 1
	      fi->sp_offset = offset;
d369 2
a370 2
#ifdef GDB_TARGET_IS_SPARC64
	      if (fi->frame & 1)
d372 1
a372 1
#endif
d374 2
a375 1
	      fi->fp_addr = fi->frame + fi->sp_offset + X_SIMM13 (insn);
d378 1
a378 1
	      fi->pc_addr = 0;
d384 2
a385 1
		fi->pc_addr = fi->frame + fi->sp_offset + X_SIMM13 (insn);
d412 1
a412 1
		  fi->in_prologue = 1;
d438 1
a438 1
     char regbuf[REGISTER_BYTES];
d450 1
a450 1
  char buf[MAX_REGISTER_RAW_SIZE];
d453 1
d464 1
a464 1
      char scbuf[TARGET_PTR_BIT / HOST_CHAR_BIT];
d468 2
d488 5
a492 5
  else if (frame->in_prologue ||
	   (frame->next != NULL
	    && (frame->next->signal_handler_caller
		|| frame_in_dummy (frame->next))
	    && frameless_look_for_prologue (frame)))
d500 2
a501 2
  if (frame->flat)
    addr = frame->pc_addr;
d503 1
a503 1
    addr = frame->bottom + FRAME_SAVED_I0 +
d538 1
a538 1
  frame->bottom = argv[1];
d552 2
a553 2
static CORE_ADDR examine_prologue PARAMS ((CORE_ADDR, int, struct frame_info *,
					   struct frame_saved_regs *));
d560 1
a560 1
     struct frame_saved_regs *saved_regs;
d638 38
a675 11
         This recognizes all non alternate stores of input register,
         into a location offset from the frame pointer.  */
      if ((X_OP (insn) == 3
	   && (X_OP3 (insn) & 0x3c) == 4	/* Store, non-alternate.  */
	   && (X_RD (insn) & 0x18) == 0x18	/* Input register.  */
	   && X_I (insn)	/* Immediate mode.  */
	   && X_RS1 (insn) == 30	/* Off of frame pointer.  */
      /* Into reserved stack space.  */
	   && X_SIMM13 (insn) >= 0x44
	   && X_SIMM13 (insn) < 0x5b))
	;
d678 2
a679 3
	       && X_OP3 (insn) == 4
	       && X_RS1 (insn) == 14
	)
d682 2
a683 2
	    saved_regs->regs[X_RD (insn)] =
	      fi->frame + fi->sp_offset + X_SIMM13 (insn);
d724 1
a724 4
#ifndef GDB_TARGET_IS_SPARC64
	  || X_OP2 (instruction) == 7
#endif
      ))
d732 4
a737 3
#ifndef GDB_TARGET_IS_SPARC64
	case 7:
#endif
d750 2
a751 2
#ifdef GDB_TARGET_IS_SPARC64
  else if (X_OP (instruction) == 2
a766 1
#endif
d833 4
a836 2
      if (frame1->pc >= (frame1->bottom ? frame1->bottom :
			 read_sp ())
d846 1
a846 1
	    addr = (frame1->prev->bottom
d850 1
a850 1
	    addr = (frame1->prev->bottom
d856 1
a856 1
	  else if (FP0_REGNUM >= 0 &&
d860 1
a860 2
#ifdef GDB_TARGET_IS_SPARC64
	  else if (FP0_REGNUM >= 0 &&
a863 1
#endif
d868 1
a868 1
      else if (frame1->flat)
d872 1
a872 1
	    addr = frame1->pc_addr;
d874 1
a874 1
	    addr = frame1->fp_addr;
d878 4
a881 2
	      struct frame_saved_regs regs;
	      memset (&regs, 0, sizeof (regs));
d884 2
a885 2
	      examine_prologue (func_start, 0, frame1, &regs);
	      addr = regs.regs[regnum];
d892 1
a892 1
	    addr = (frame1->prev->bottom
d896 1
a896 1
	    addr = (frame1->prev->bottom
d949 1
a949 5
#ifdef GDB_TARGET_IS_SPARC64
#define DUMMY_REG_SAVE_OFFSET (128 + 16)
#else
#define DUMMY_REG_SAVE_OFFSET 0x60
#endif
a950 1
/* See tm-sparc.h for how this is calculated.  */
d953 2
a954 1
#define DUMMY_STACK_SIZE (DUMMY_STACK_REG_BUF_SIZE + DUMMY_REG_SAVE_OFFSET)
d960 3
a962 1
  char register_temp[DUMMY_STACK_SIZE];
d966 16
a981 12
#ifdef GDB_TARGET_IS_SPARC64
  /* PC, NPC, CCR, FSR, FPRS, Y, ASI */
  read_register_bytes (REGISTER_BYTE (PC_REGNUM), &register_temp[0],
		       REGISTER_RAW_SIZE (PC_REGNUM) * 7);
  read_register_bytes (REGISTER_BYTE (PSTATE_REGNUM), &register_temp[8],
		       REGISTER_RAW_SIZE (PSTATE_REGNUM));
  /* FIXME: not sure what needs to be saved here.  */
#else
  /* Y, PS, WIM, TBR, PC, NPC, FPS, CPS regs */
  read_register_bytes (REGISTER_BYTE (Y_REGNUM), &register_temp[0],
		       REGISTER_RAW_SIZE (Y_REGNUM) * 8);
#endif
d991 1
a991 1
  if (FP0_REGNUM >= 0)
d1041 1
a1041 1
   Stores, into a struct frame_saved_regs,
d1065 1
a1065 2
static void sparc_frame_find_saved_regs PARAMS ((struct frame_info *,
						 struct frame_saved_regs *));
d1070 1
a1070 1
     struct frame_saved_regs *saved_regs_addr;
d1078 1
a1078 1
  memset (saved_regs_addr, 0, sizeof (*saved_regs_addr));
d1080 2
a1081 2
  if (fi->pc >= (fi->bottom ? fi->bottom :
		 read_sp ())
d1086 1
a1086 1
	saved_regs_addr->regs[regnum] =
d1089 1
d1091 1
a1091 1
	saved_regs_addr->regs[regnum] =
d1094 7
a1100 1
      if (FP0_REGNUM >= 0)
d1102 8
a1109 10
	  for (regnum = FP0_REGNUM; regnum < FP0_REGNUM + 32; regnum++)
	    saved_regs_addr->regs[regnum] =
	      frame_addr + (regnum - FP0_REGNUM) * 4
	      - DUMMY_STACK_REG_BUF_SIZE + 24 * SPARC_INTREG_SIZE;
#ifdef GDB_TARGET_IS_SPARC64
	  for (regnum = FP0_REGNUM + 32; regnum < FP_MAX_REGNUM; regnum++)
	    saved_regs_addr->regs[regnum] =
	      frame_addr + 32 * 4 + (regnum - FP0_REGNUM - 32) * 4
	      - DUMMY_STACK_REG_BUF_SIZE + 24 * SPARC_INTREG_SIZE;
#endif
d1111 5
d1117 2
a1118 17
#ifdef GDB_TARGET_IS_SPARC64
      for (regnum = PC_REGNUM; regnum < PC_REGNUM + 7; regnum++)
	{
	  saved_regs_addr->regs[regnum] =
	    frame_addr + (regnum - PC_REGNUM) * SPARC_INTREG_SIZE
	    - DUMMY_STACK_REG_BUF_SIZE;
	}
      saved_regs_addr->regs[PSTATE_REGNUM] =
	frame_addr + 8 * SPARC_INTREG_SIZE - DUMMY_STACK_REG_BUF_SIZE;
#else
      for (regnum = Y_REGNUM; regnum < NUM_REGS; regnum++)
	saved_regs_addr->regs[regnum] =
	  frame_addr + (regnum - Y_REGNUM) * SPARC_INTREG_SIZE
	  - DUMMY_STACK_REG_BUF_SIZE;
#endif
      frame_addr = fi->bottom ?
	fi->bottom : read_sp ();
d1120 1
a1120 1
  else if (fi->flat)
d1127 2
a1128 2
      saved_regs_addr->regs[RP_REGNUM] = fi->pc_addr;
      saved_regs_addr->regs[I7_REGNUM] = fi->fp_addr;
d1133 2
a1134 2
      frame_addr = fi->bottom ?
	fi->bottom : read_sp ();
d1136 1
a1136 1
	saved_regs_addr->regs[regnum] =
d1140 1
a1140 1
	saved_regs_addr->regs[regnum] =
d1146 1
a1146 1
      if (fi->flat)
d1148 1
a1148 1
	  saved_regs_addr->regs[O7_REGNUM] = fi->pc_addr;
d1154 2
a1155 3
	  (fi->next->bottom ?
	   fi->next->bottom :
	   read_sp ());
d1157 1
a1157 1
	    saved_regs_addr->regs[regnum] =
d1165 1
a1165 1
  saved_regs_addr->regs[SP_REGNUM] = FRAME_FP (fi);
d1187 2
a1188 2
  struct frame_saved_regs fsr;
  char raw_buffer[REGISTER_BYTES];
d1191 4
a1194 2
  sparc_frame_find_saved_regs (frame, &fsr);
  if (FP0_REGNUM >= 0)
d1196 1
a1196 1
      if (fsr.regs[FP0_REGNUM])
d1198 1
a1198 1
	  read_memory (fsr.regs[FP0_REGNUM], raw_buffer, FP_REGISTER_BYTES);
d1202 1
a1202 2
#ifndef GDB_TARGET_IS_SPARC64
      if (fsr.regs[FPS_REGNUM])
d1204 10
a1213 7
	  read_memory (fsr.regs[FPS_REGNUM], raw_buffer, 4);
	  write_register_bytes (REGISTER_BYTE (FPS_REGNUM), raw_buffer, 4);
	}
      if (fsr.regs[CPS_REGNUM])
	{
	  read_memory (fsr.regs[CPS_REGNUM], raw_buffer, 4);
	  write_register_bytes (REGISTER_BYTE (CPS_REGNUM), raw_buffer, 4);
a1214 1
#endif
d1216 1
a1216 1
  if (fsr.regs[G1_REGNUM])
d1218 1
a1218 1
      read_memory (fsr.regs[G1_REGNUM], raw_buffer, 7 * SPARC_INTREG_SIZE);
d1223 1
a1223 1
  if (frame->flat)
d1228 2
a1229 2
	if (fsr.regs[regnum])
	  write_register (regnum, read_memory_integer (fsr.regs[regnum],
d1232 2
a1233 2
	if (fsr.regs[regnum])
	  write_register (regnum, read_memory_integer (fsr.regs[regnum],
d1238 2
a1239 2
	if (fsr.regs[regnum])
	  write_register (regnum, read_memory_integer (fsr.regs[regnum],
d1241 1
a1241 1
      if (fsr.regs[O0_REGNUM + 7])
d1243 1
a1243 1
			read_memory_integer (fsr.regs[O0_REGNUM + 7],
d1248 1
a1248 1
  else if (fsr.regs[I0_REGNUM])
d1252 3
a1254 1
      char reg_temp[REGISTER_BYTES];
d1256 1
a1256 1
      read_memory (fsr.regs[I0_REGNUM], raw_buffer, 8 * SPARC_INTREG_SIZE);
d1263 3
a1265 3
      sp = fsr.regs[SP_REGNUM];
#ifdef GDB_TARGET_IS_SPARC64
      if (sp & 1)
d1267 1
a1267 1
#endif
d1278 12
a1289 7
#ifndef GDB_TARGET_IS_SPARC64
  if (fsr.regs[PS_REGNUM])
    write_register (PS_REGNUM, read_memory_integer (fsr.regs[PS_REGNUM], 4));
#endif
  if (fsr.regs[Y_REGNUM])
    write_register (Y_REGNUM, read_memory_integer (fsr.regs[Y_REGNUM], REGISTER_RAW_SIZE (Y_REGNUM)));
  if (fsr.regs[PC_REGNUM])
d1292 4
a1295 3
      write_register (PC_REGNUM, read_memory_integer (fsr.regs[PC_REGNUM],
					    REGISTER_RAW_SIZE (PC_REGNUM)));
      if (fsr.regs[NPC_REGNUM])
d1297 2
a1298 2
			read_memory_integer (fsr.regs[NPC_REGNUM],
					   REGISTER_RAW_SIZE (NPC_REGNUM)));
d1300 1
a1300 1
  else if (frame->flat)
d1302 1
a1302 1
      if (frame->pc_addr)
d1304 1
a1304 1
			read_memory_integer (frame->pc_addr,
d1311 3
a1313 1
	  char buf[MAX_REGISTER_RAW_SIZE];
d1322 1
a1322 1
  else if (fsr.regs[I7_REGNUM])
d1325 1
a1325 1
      pc = PC_ADJUST ((CORE_ADDR) read_memory_integer (fsr.regs[I7_REGNUM],
d1444 8
a1451 4
  register int regi;
  register prgreg_t *regp = (prgreg_t *) gregsetp;
  static char zerobuf[MAX_REGISTER_RAW_SIZE] =
  {0};
d1454 1
d1457 1
a1457 1
      supply_register (regi, (char *) (regp + regi));
d1461 53
a1513 4
  supply_register (PS_REGNUM, (char *) (regp + R_PS));
  supply_register (PC_REGNUM, (char *) (regp + R_PC));
  supply_register (NPC_REGNUM, (char *) (regp + R_nPC));
  supply_register (Y_REGNUM, (char *) (regp + R_Y));
d1516 44
a1559 3
  supply_register (WIM_REGNUM, zerobuf);
  supply_register (TBR_REGNUM, zerobuf);
  supply_register (CPS_REGNUM, zerobuf);
d1567 8
a1574 2
  int regi;
  register prgreg_t *regp = (prgreg_t *) gregsetp;
d1577 3
a1579 10
    {
      if ((regno == -1) || (regno == regi))
	{
	  *(regp + regi) = *(int *) &registers[REGISTER_BYTE (regi)];
	}
    }
  if ((regno == -1) || (regno == PS_REGNUM))
    {
      *(regp + R_PS) = *(int *) &registers[REGISTER_BYTE (PS_REGNUM)];
    }
d1581 2
a1582 3
    {
      *(regp + R_PC) = *(int *) &registers[REGISTER_BYTE (PC_REGNUM)];
    }
d1584 6
d1591 12
a1602 1
      *(regp + R_nPC) = *(int *) &registers[REGISTER_BYTE (NPC_REGNUM)];
d1604 1
a1604 1
  if ((regno == -1) || (regno == Y_REGNUM))
d1606 31
a1636 1
      *(regp + R_Y) = *(int *) &registers[REGISTER_BYTE (Y_REGNUM)];
d1651 1
a1651 1
  if (FP0_REGNUM < 0)
d1659 16
a1674 1
  supply_register (FPS_REGNUM, (char *) &(fpregsetp->pr_fsr));
d1681 1
a1681 1
/* ??? This will probably need some changes for sparc64.  */
d1692 1
a1692 1
  if (FP0_REGNUM < 0)
d1704 8
a1711 4
  if ((regno == -1) || (regno == FPS_REGNUM))
    {
      fpregsetp->pr_fsr = *(int *) &registers[REGISTER_BYTE (FPS_REGNUM)];
    }
d1775 1
a1775 1
static void dump_ccreg PARAMS ((char *, int));
d1787 1
a1787 2
		     val & 1 ? "C" : "NC"
    );
d1893 2
a1894 14
  switch (regno)
    {
#ifdef GDB_TARGET_IS_SPARC64
    case CCR_REGNUM:
      printf_unfiltered ("\t");
      dump_ccreg ("xcc", val >> 4);
      printf_unfiltered (", ");
      dump_ccreg ("icc", val & 15);
      break;
    case FPRS_REGNUM:
      printf ("\tfef:%d, du:%d, dl:%d",
	      BITS (2, 1), BITS (1, 1), BITS (0, 1));
      break;
    case FSR_REGNUM:
d1896 55
a1950 10
	static char *fcc[4] =
	{"=", "<", ">", "?"};
	static char *rd[4] =
	{"N", "0", "+", "-"};
	/* Long, yes, but I'd rather leave it as is and use a wide screen.  */
	printf ("\t0:%s, 1:%s, 2:%s, 3:%s, rd:%s, tem:%d, ns:%d, ver:%d, ftt:%d, qne:%d, aexc:%d, cexc:%d",
		fcc[BITS (10, 3)], fcc[BITS (32, 3)],
		fcc[BITS (34, 3)], fcc[BITS (36, 3)],
		rd[BITS (30, 3)], BITS (23, 31), BITS (22, 1), BITS (17, 7),
		BITS (14, 7), BITS (13, 1), BITS (5, 31), BITS (0, 31));
d1952 20
a1971 6
      }
    case ASI_REGNUM:
      {
	char *asi = decode_asi (val);
	if (asi != NULL)
	  printf ("\t%s", asi);
d1973 2
a1974 14
      }
    case VER_REGNUM:
      printf ("\tmanuf:%d, impl:%d, mask:%d, maxtl:%d, maxwin:%d",
	      BITS (48, 0xffff), BITS (32, 0xffff),
	      BITS (24, 0xff), BITS (8, 0xff), BITS (0, 31));
      break;
    case PSTATE_REGNUM:
      {
	static char *mm[4] =
	{"tso", "pso", "rso", "?"};
	printf ("\tcle:%d, tle:%d, mm:%s, red:%d, pef:%d, am:%d, priv:%d, ie:%d, ag:%d",
		BITS (9, 1), BITS (8, 1), mm[BITS (6, 3)], BITS (5, 1),
		BITS (4, 1), BITS (3, 1), BITS (2, 1), BITS (1, 1),
		BITS (0, 1));
d1977 2
a1978 39
    case TSTATE_REGNUM:
      /* FIXME: print all 4? */
      break;
    case TT_REGNUM:
      /* FIXME: print all 4? */
      break;
    case TPC_REGNUM:
      /* FIXME: print all 4? */
      break;
    case TNPC_REGNUM:
      /* FIXME: print all 4? */
      break;
    case WSTATE_REGNUM:
      printf ("\tother:%d, normal:%d", BITS (3, 7), BITS (0, 7));
      break;
    case CWP_REGNUM:
      printf ("\t%d", BITS (0, 31));
      break;
    case CANSAVE_REGNUM:
      printf ("\t%-2d before spill", BITS (0, 31));
      break;
    case CANRESTORE_REGNUM:
      printf ("\t%-2d before fill", BITS (0, 31));
      break;
    case CLEANWIN_REGNUM:
      printf ("\t%-2d before clean", BITS (0, 31));
      break;
    case OTHERWIN_REGNUM:
      printf ("\t%d", BITS (0, 31));
      break;
#else
    case PS_REGNUM:
      printf ("\ticc:%c%c%c%c, pil:%d, s:%d, ps:%d, et:%d, cwp:%d",
	      BITS (23, 1) ? 'N' : '-', BITS (22, 1) ? 'Z' : '-',
	      BITS (21, 1) ? 'V' : '-', BITS (20, 1) ? 'C' : '-',
	      BITS (8, 15), BITS (7, 1), BITS (6, 1), BITS (5, 1),
	      BITS (0, 31));
      break;
    case FPS_REGNUM:
d1980 5
a1984 9
	static char *fcc[4] =
	{"=", "<", ">", "?"};
	static char *rd[4] =
	{"N", "0", "+", "-"};
	/* Long, yes, but I'd rather leave it as is and use a wide screen.  */
	printf ("\trd:%s, tem:%d, ns:%d, ver:%d, ftt:%d, qne:%d, "
		"fcc:%s, aexc:%d, cexc:%d",
		rd[BITS (30, 3)], BITS (23, 31), BITS (22, 1), BITS (17, 7),
		BITS (14, 7), BITS (13, 1), fcc[BITS (10, 3)], BITS (5, 31),
d1987 14
a2002 3
#endif /* GDB_TARGET_IS_SPARC64 */
    }

d2013 4
d2021 2
a2022 1
   than an int are promoted to an int.  */
d2025 1
a2025 1
sparc_push_arguments (nargs, args, sp, struct_return, struct_addr)
d2032 1
a2032 1
  int i;
d2041 1
a2041 1
  (struct sparc_arg *) alloca (nargs * sizeof (struct sparc_arg));
d2078 10
a2087 2
  for (i = nargs; m_arg--, --i >= 0;)
    write_memory (sp + m_arg->offset, m_arg->contents, m_arg->len);
d2098 1
a2098 1
sparc_extract_return_value (type, regbuf, valbuf)
d2129 3
a2131 1
  char buffer[MAX_REGISTER_RAW_SIZE];
d2144 1
a2144 1
      bzero (buffer, REGISTER_RAW_SIZE (regno));
d2147 1
a2147 2
      write_register_bytes (REGISTER_BYTE (regno), buffer,
			    REGISTER_RAW_SIZE (regno));
d2153 13
d2201 1
a2201 6
#ifndef GDB_TARGET_IS_SPARC64
  /* If this is not a simulator target, change the first four instructions
     of the call dummy to NOPs.  Those instructions include a 'save'
     instruction and are designed to work around problems with register
     window flushing in the simulator. */
  if (strcmp (target_shortname, "sim") != 0)
d2203 10
a2212 2
      for (i = 0; i < 4; i++)
	store_unsigned_integer (dummy + (i * 4), 4, 0x01000000);
a2213 1
#endif
d2258 7
d2268 3
d2276 2
a2278 4
#ifdef GDB_TARGET_IS_SPARC64

/* Compensate for stack bias. Note that we currently don't handle mixed
   32/64 bit code. */
d2280 1
a2280 1
sparc64_read_sp ()
d2290 1
a2290 1
sparc64_read_fp ()
d2321 13
a2333 2
/* The SPARC 64 ABI passes floating-point arguments in FP0-31. They are
   also copied onto the stack in the correct places. */
d2336 1
a2336 1
sp64_push_arguments (nargs, args, sp, struct_return, struct_retaddr)
d2340 1
a2340 1
     unsigned char struct_return;
d2343 1
a2343 2
  int x;
  int regnum = 0;
d2345 3
d2349 1
a2349 1
  sp = (sp & ~(((unsigned long) TYPE_LENGTH (builtin_type_long)) - 1UL));
d2352 1
a2352 1
  for (x = nargs - 1; x >= 0; x--)
d2354 2
a2355 2
      int len = TYPE_LENGTH (check_typedef (VALUE_TYPE (args[x])));
      value_ptr copyarg = args[x];
d2358 1
a2358 2
      /* This code is, of course, no longer correct. */
      if (copylen < TYPE_LENGTH (builtin_type_long))
d2360 2
a2361 2
	  copyarg = value_cast (builtin_type_long, copyarg);
	  copylen = TYPE_LENGTH (builtin_type_long);
d2370 13
a2382 6
  /* Now write the arguments onto the stack, while writing FP arguments
     into the FP registers. */
  for (x = 0; x < nargs; x++)
    {
      int len = TYPE_LENGTH (check_typedef (VALUE_TYPE (args[x])));
      value_ptr copyarg = args[x];
d2385 13
a2397 6
      /* This code is, of course, no longer correct. */
      if (copylen < TYPE_LENGTH (builtin_type_long))
	{
	  copyarg = value_cast (builtin_type_long, copyarg);
	  copylen = TYPE_LENGTH (builtin_type_long);
	}
d2400 10
a2409 1
      if (TYPE_CODE (VALUE_TYPE (args[x])) == TYPE_CODE_FLT && regnum < 32)
d2411 23
a2433 15
	  /* This gets copied into a FP register. */
	  int nextreg = regnum + 2;
	  char *data = VALUE_CONTENTS (args[x]);
	  /* Floats go into the lower half of a FP register pair; quads
	     use 2 pairs. */

	  if (len == 16)
	    nextreg += 2;
	  else if (len == 4)
	    regnum++;

	  write_register_bytes (REGISTER_BYTE (FP0_REGNUM + regnum),
				data,
				len);
	  regnum = nextreg;
d2435 12
d2453 1
d2455 1
a2455 1
sparc64_extract_return_value (type, regbuf, valbuf, bitoffset)
d2497 4
a2500 4
	      sparc64_extract_return_value (f->type,
					    regbuf,
					    valbuf,
					    bitoffset + f->loc.bitpos);
d2502 1
a2502 1
	  else if (typecode == TYPE_CODE_FLT)
d2514 407
d2922 110
d3033 239
@


1.1
log
@Initial revision
@
text
@d5 1
a5 1
This file is part of GDB.
d7 14
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d47 3
d51 2
a52 1
#define FP_REGISTER_BYTES (32 * 4)
d133 2
a134 1
} branch_type;
d158 1
a158 1
     enum target_signal ignore; /* pid, but we don't need it */
d169 1
a169 1
      npc4 = next_pc + 4; /* branch not taken */
d242 1
a242 1
	 it later.  */
d262 1
a262 1
	  
d273 3
a275 3
	 negative number if a flat frame) to the sp.  FIXME: Does not
	 handle large frames which will need more than one instruction
	 to adjust the sp.  */
d316 29
a344 29
	else
	  {
	    /* Check if the PC is in the function prologue before a SAVE
	       instruction has been executed yet.  If so, set the frame
	       to the current value of the stack pointer and set
	       the in_prologue flag.  */
	    CORE_ADDR addr;
	    struct symtab_and_line sal;

	    sal = find_pc_line (prologue_start, 0);
	    if (sal.line == 0)			/* no line info, use PC */
	      prologue_end = fi->pc;
	    else if (sal.end < prologue_end)
	      prologue_end = sal.end;
	    if (fi->pc < prologue_end)
	      {
		for (addr = prologue_start; addr < fi->pc; addr += 4)
		  {
		    insn = read_memory_integer (addr, 4);
		    if (X_OP (insn) == 2 && X_OP3 (insn) == 0x3c)
		      break;			/* SAVE seen, stop searching */
		  }
		if (addr >= fi->pc)
		  {
		    fi->in_prologue = 1;
		    fi->frame = read_register (SP_REGNUM);
		  }
	      }
	  }
d361 1
a361 1
  return (CORE_ADDR)1;
d384 1
a384 1
	 Get the saved PC from the sigcontext structure.  */
d396 1
a396 1
	 as the third parameter.  The offset to the saved pc is 12.  */
d398 1
a398 1
				(CORE_ADDR *)NULL,(CORE_ADDR *)NULL);
d403 2
a404 2
      get_saved_register (buf, (int *)NULL, (CORE_ADDR *)NULL,
			  frame, O0_REGNUM + 2, (enum lval_type *)NULL);
d408 1
a408 1
	 stack layout has changed or the stack is corrupt.  */
d416 1
a416 1
	        || frame_in_dummy (frame->next))
d420 3
a422 3
	 the PC, it is still in %o7.  */
      get_saved_register (buf, (int *)NULL, (CORE_ADDR *)NULL,
			  frame, O7_REGNUM, (enum lval_type *)NULL);
d461 2
a462 2
    fatal ("internal: create_new_frame returned invalid frame");
  
d480 1
a480 1
static CORE_ADDR 
d520 2
a521 2
      if (frameless_p)			/* If the save is all we care about, */
	return pc;			/* return before doing more work */
d528 2
a529 2
      if (frameless_p)			/* If the add is all we care about, */
	return pc;			/* return before doing more work */
d542 1
a542 1
	  if (X_OP (insn) ==  2
d563 2
a564 2
	 This recognizes all non alternate stores of input register,
	 into a location offset from the frame pointer.  */
d566 3
a568 3
	   && (X_OP3 (insn) & 0x3c) == 4 /* Store, non-alternate.  */
	   && (X_RD (insn) & 0x18) == 0x18 /* Input register.  */
	   && X_I (insn)		/* Immediate mode.  */
d570 1
a570 1
	   /* Into reserved stack space.  */
d578 1
a578 1
	       )
d593 2
a594 2
CORE_ADDR 
skip_prologue (start_pc, frameless_p)
d626 1
a626 1
	  ))
d682 1
a682 1
get_saved_register (raw_buffer, optimized, addrp, frame, regnum, lval)
d706 3
a708 3
        error ("The program has no registers now.");
      if (selected_frame == NULL) 
        error ("No selected frame.");
d710 1
a710 1
      frame = get_prev_frame (selected_frame);  
d712 1
a712 1
        error ("Cmd not meaningful in the outermost frame."); 
d756 2
a757 2
#ifdef FP0_REGNUM
	  else if (regnum >= FP0_REGNUM && regnum < FP0_REGNUM + 32)
d761 2
a762 1
	  else if (regnum >= FP0_REGNUM + 32 && regnum < FP_MAX_REGNUM)
a765 1
#endif /* FP0_REGNUM */
a855 4
#ifdef FP0_REGNUM
#define DUMMY_STACK_REG_BUF_SIZE \
(((8+8+8) * SPARC_INTREG_SIZE) + FP_REGISTER_BYTES)
#else
d857 1
a857 2
(((8+8+8) * SPARC_INTREG_SIZE) )
#endif /* FP0_REGNUM */
d889 4
a892 5
#ifdef FP0_REGNUM
  read_register_bytes (REGISTER_BYTE (FP0_REGNUM),
		       &register_temp[24 * SPARC_INTREG_SIZE],
		       FP_REGISTER_BYTES);
#endif /* FP0_REGNUM */
d906 1
a906 1
      write_register (I7_REGNUM, read_pc() - 8);
d912 3
a914 3
	 correctly in the simulator.  */
      write_register (G0_REGNUM+1, read_register (FP_REGNUM));
    
d917 2
a918 2
      write_register (G0_REGNUM+2, old_sp);
    
d920 3
a922 3
	 executing the 'save'. */
      write_register (G0_REGNUM+3, read_pc() - 8);
    
d924 1
a924 1
	 This makes backtraces from an inferior function call work properly.  */
d975 1
a975 1
    fatal ("Bad frame info struct in FRAME_FIND_SAVED_REGS");
d980 2
a981 2
		   read_sp ())
      && fi->pc <= FRAME_FP(fi))
d984 1
a984 1
      for (regnum = G1_REGNUM; regnum < G1_REGNUM+7; regnum++)
d987 2
a988 2
	    - DUMMY_STACK_REG_BUF_SIZE + 16 * SPARC_INTREG_SIZE;
      for (regnum = I0_REGNUM; regnum < I0_REGNUM+8; regnum++)
d991 7
a997 6
	    - DUMMY_STACK_REG_BUF_SIZE + 8 * SPARC_INTREG_SIZE;
#ifdef FP0_REGNUM
      for (regnum = FP0_REGNUM; regnum < FP0_REGNUM + 32; regnum++)
	saved_regs_addr->regs[regnum] =
	  frame_addr + (regnum - FP0_REGNUM) * 4
	    - DUMMY_STACK_REG_BUF_SIZE + 24 * SPARC_INTREG_SIZE;
d999 4
a1002 4
      for (regnum = FP0_REGNUM + 32; regnum < FP_MAX_REGNUM; regnum++)
	saved_regs_addr->regs[regnum] =
	  frame_addr + 32 * 4 + (regnum - FP0_REGNUM - 32) * 4
	    - DUMMY_STACK_REG_BUF_SIZE + 24 * SPARC_INTREG_SIZE;
d1004 2
a1005 1
#endif /* FP0_REGNUM */
d1010 2
a1011 2
	    frame_addr + (regnum - PC_REGNUM) * SPARC_INTREG_SIZE 
	      - DUMMY_STACK_REG_BUF_SIZE;
d1013 1
a1013 1
      saved_regs_addr->regs[PSTATE_REGNUM] = 
d1018 2
a1019 2
	  frame_addr + (regnum - Y_REGNUM) * SPARC_INTREG_SIZE 
	    - DUMMY_STACK_REG_BUF_SIZE;
d1039 1
a1039 1
      for (regnum = L0_REGNUM; regnum < L0_REGNUM+8; regnum++)
d1043 1
a1043 1
      for (regnum = I0_REGNUM; regnum < I0_REGNUM+8; regnum++)
d1058 4
a1061 4
	    (fi->next->bottom ?
	     fi->next->bottom :
	     read_sp ());
	  for (regnum = O0_REGNUM; regnum < O0_REGNUM+8; regnum++)
d1097 1
a1097 2
#ifdef FP0_REGNUM
  if (fsr.regs[FP0_REGNUM])
d1099 6
a1104 4
      read_memory (fsr.regs[FP0_REGNUM], raw_buffer, FP_REGISTER_BYTES);
      write_register_bytes (REGISTER_BYTE (FP0_REGNUM),
			    raw_buffer, FP_REGISTER_BYTES);
    }
d1106 11
a1116 4
  if (fsr.regs[FPS_REGNUM])
    {
      read_memory (fsr.regs[FPS_REGNUM], raw_buffer, 4);
      write_register_bytes (REGISTER_BYTE (FPS_REGNUM), raw_buffer, 4);
a1117 7
  if (fsr.regs[CPS_REGNUM])
    {
      read_memory (fsr.regs[CPS_REGNUM], raw_buffer, 4);
      write_register_bytes (REGISTER_BYTE (CPS_REGNUM), raw_buffer, 4);
    }
#endif
#endif /* FP0_REGNUM */
d1128 1
a1128 1
	 individually.  */
d1159 4
a1162 4
	 moving the stack pointer is all that is really needed, except
	 store_inferior_registers is then going to write the ins and
	 locals from the registers array, so we need to muck with the
	 registers array.  */
d1171 1
a1171 1
	 Among other things this writes the new stack pointer.  */
d1188 1
a1188 1
						      REGISTER_RAW_SIZE (PC_REGNUM)));
d1192 1
a1192 1
					     REGISTER_RAW_SIZE (NPC_REGNUM)));
d1211 1
a1211 1
      write_register (PC_REGNUM,  pc);
d1219 1
a1219 1
      write_register (PC_REGNUM,  pc);
d1230 1
a1230 1
sparc_pc_adjust(pc)
d1240 1
a1240 1
    return pc+12;
d1242 1
a1242 1
    return pc+8;
d1249 2
a1250 2
	sethi %hi(addr),%g1
	jmp %g1+%lo(addr)
d1287 2
a1288 2
#ifdef USE_PROC_FS	/* Target dependent support for /proc */

d1324 3
d1334 1
a1334 1
prgregset_t *gregsetp;
d1338 2
a1339 1
  static char zerobuf[MAX_REGISTER_RAW_SIZE] = {0};
d1342 1
a1342 1
  for (regi = G0_REGNUM ; regi <= I7_REGNUM ; regi++)
d1350 2
a1351 2
  supply_register (NPC_REGNUM,(char *) (regp + R_nPC));
  supply_register (Y_REGNUM,  (char *) (regp + R_Y));
d1361 2
a1362 2
prgregset_t *gregsetp;
int regno;
d1367 1
a1367 1
  for (regi = 0 ; regi <= R_I7 ; regi++)
a1391 2
#if defined (FP0_REGNUM)

d1393 2
a1394 2
    (fpregset_t *), unpack the register contents and supply them as gdb's
    idea of the current floating point register values. */
d1396 1
a1396 1
void 
d1398 1
a1398 1
prfpregset_t *fpregsetp;
d1402 5
a1406 2
  
  for (regi = FP0_REGNUM ; regi < FP_MAX_REGNUM ; regi++)
d1408 1
a1408 1
      from = (char *) &fpregsetp->pr_fr.pr_regs[regi-FP0_REGNUM];
d1415 3
a1417 3
    (fpregset_t *), update the register specified by REGNO from gdb's idea
    of the current floating point register set.  If REGNO is -1, update
    them all. */
d1422 2
a1423 2
prfpregset_t *fpregsetp;
int regno;
d1429 4
a1432 1
  for (regi = FP0_REGNUM ; regi < FP_MAX_REGNUM ; regi++)
d1437 1
a1437 1
	  to = (char *) &fpregsetp->pr_fr.pr_regs[regi-FP0_REGNUM];
d1447 1
a1447 3
#endif	/* defined (FP0_REGNUM) */

#endif  /* USE_PROC_FS */
d1490 6
a1495 6
	 of junk (the contents of which match a string given in the
	 N_OPT), a period and the name.  For function-local statics
	 there will be a bunch of junk (which seems to change the
	 second character from 'A' to 'B'), a period, the name of the
	 function, and the name.  So just skip everything before the
	 last period.  */
d1517 5
a1521 5
	  val & 8 ? "N" : "NN",
	  val & 4 ? "Z" : "NZ",
	  val & 2 ? "O" : "NO",
	  val & 1 ? "C" : "NC"
  );
d1531 30
a1560 15
    case 4 : return "ASI_NUCLEUS";
    case 0x0c : return "ASI_NUCLEUS_LITTLE";
    case 0x10 : return "ASI_AS_IF_USER_PRIMARY";
    case 0x11 : return "ASI_AS_IF_USER_SECONDARY";
    case 0x18 : return "ASI_AS_IF_USER_PRIMARY_LITTLE";
    case 0x19 : return "ASI_AS_IF_USER_SECONDARY_LITTLE";
    case 0x80 : return "ASI_PRIMARY";
    case 0x81 : return "ASI_SECONDARY";
    case 0x82 : return "ASI_PRIMARY_NOFAULT";
    case 0x83 : return "ASI_SECONDARY_NOFAULT";
    case 0x88 : return "ASI_PRIMARY_LITTLE";
    case 0x89 : return "ASI_SECONDARY_LITTLE";
    case 0x8a : return "ASI_PRIMARY_NOFAULT_LITTLE";
    case 0x8b : return "ASI_SECONDARY_NOFAULT_LITTLE";
    default : return NULL;
d1586 1
a1586 1
#if 0 /* FIXME: gdb doesn't handle long doubles */
d1600 1
a1600 1
#if 0 /* FIXME: gdb doesn't handle long doubles */
d1603 2
a1604 2
      /* We test for even numbered regs and not a multiple of 4 because
	 the upper fp regs are recorded as doubles.  */
d1630 2
a1631 2
    case CCR_REGNUM :
      printf_unfiltered("\t");
d1633 1
a1633 1
      printf_unfiltered(", ");
d1636 1
a1636 1
    case FPRS_REGNUM :
d1640 1
a1640 1
    case FSR_REGNUM :
d1642 4
a1645 2
	static char *fcc[4] = { "=", "<", ">", "?" };
	static char *rd[4] = { "N", "0", "+", "-" };
d1654 1
a1654 1
    case ASI_REGNUM :
d1661 1
a1661 1
    case VER_REGNUM :
d1666 1
a1666 1
    case PSTATE_REGNUM :
d1668 2
a1669 1
	static char *mm[4] = { "tso", "pso", "rso", "?" };
d1676 1
a1676 1
    case TSTATE_REGNUM :
d1679 1
a1679 1
    case TT_REGNUM :
d1682 1
a1682 1
    case TPC_REGNUM :
d1685 1
a1685 1
    case TNPC_REGNUM :
d1688 1
a1688 1
    case WSTATE_REGNUM :
d1691 1
a1691 1
    case CWP_REGNUM :
d1694 1
a1694 1
    case CANSAVE_REGNUM :
d1697 1
a1697 1
    case CANRESTORE_REGNUM :
d1700 1
a1700 1
    case CLEANWIN_REGNUM :
d1703 1
a1703 1
    case OTHERWIN_REGNUM :
d1716 4
a1719 2
	static char *fcc[4] = { "=", "<", ">", "?" };
	static char *rd[4] = { "N", "0", "+", "-" };
d1729 1
a1729 1
#endif	/* GDB_TARGET_IS_SPARC64 */
d1741 1
a1741 1
  info->mach = TM_PRINT_INSN_MACH;
d1765 1
a1765 1
      (struct sparc_arg*)alloca (nargs * sizeof (struct sparc_arg));
d1794 1
a1794 1
      m_arg->contents = VALUE_CONTENTS(arg);
d1802 2
a1803 2
  for (i = nargs; m_arg--, --i >= 0; )
    write_memory(sp + m_arg->offset, m_arg->contents, m_arg->len);
d1823 1
a1823 1
    memcpy (valbuf, &regbuf [REGISTER_BYTE (FP0_REGNUM)], typelen);
d1826 4
a1829 4
	    &regbuf [O0_REGNUM * regsize +
		     (typelen >= regsize
		      || TARGET_BYTE_ORDER == LITTLE_ENDIAN ? 0
			 : regsize - typelen)],
d1856 1
a1856 1
  if (TYPE_LENGTH (type) < REGISTER_RAW_SIZE(regno))
d1858 2
a1859 2
      bzero (buffer, REGISTER_RAW_SIZE(regno));
      memcpy (buffer + REGISTER_RAW_SIZE(regno) - TYPE_LENGTH (type), valbuf,
d1861 2
a1862 2
      write_register_bytes (REGISTER_BYTE (regno), buffer, 
			    REGISTER_RAW_SIZE(regno));
d1893 1
a1893 1
			       & 0x3fffffff)));
d1921 6
a1926 6
	  char tmp = dummy [i];
	  dummy [i] = dummy [i+3];
	  dummy [i+3] = tmp;
	  tmp = dummy [i+1];
	  dummy [i+1] = dummy [i+2];
	  dummy [i+2] = tmp;
d1956 1
a1957 1

d1962 1
a1962 1
  tm_print_insn_info.mach = TM_PRINT_INSN_MACH;  /* Selects sparc/sparclite */
d2027 2
a2028 2
  
  sp = (sp & ~(((unsigned long)TYPE_LENGTH (builtin_type_long)) - 1UL));
d2040 3
a2042 3
	  copyarg = value_cast(builtin_type_long, copyarg);
          copylen = TYPE_LENGTH (builtin_type_long);
        }
d2061 3
a2063 3
	  copyarg = value_cast(builtin_type_long, copyarg);
          copylen = TYPE_LENGTH (builtin_type_long);
        }
d2102 1
a2102 1
      memcpy (valbuf, &regbuf [REGISTER_BYTE (FP0_REGNUM)], typelen);
d2110 1
a2110 1
	      &regbuf [O0_REGNUM * regsize +
d2123 1
a2123 1
	  struct field *f = &TYPE_FIELDS(type)[x];
d2149 2
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@d676 1
a676 1
sparc_get_saved_register (raw_buffer, optimized, addrp, frame, regnum, lval)
@


1.1.1.3
log
@import gdb-19990504 snapshot
@
text
@d588 1
a588 1
sparc_skip_prologue (start_pc, frameless_p)
@


1.1.1.4
log
@import gdb-1999-07-07 pre reformat
@
text
@a1285 1
/* *INDENT-OFF* */
a1320 1
/* *INDENT-ON* */
@


1.1.1.5
log
@import gdb-1999-07-07 post reformat
@
text
@d5 1
a5 1
   This file is part of GDB.
d7 13
a19 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d128 1
a128 2
}
branch_type;
d152 1
a152 1
     enum target_signal ignore;	/* pid, but we don't need it */
d163 1
a163 1
      npc4 = next_pc + 4;	/* branch not taken */
d236 1
a236 1
         it later.  */
d256 1
a256 1

d267 3
a269 3
         negative number if a flat frame) to the sp.  FIXME: Does not
         handle large frames which will need more than one instruction
         to adjust the sp.  */
d310 29
a338 29
      else
	{
	  /* Check if the PC is in the function prologue before a SAVE
	     instruction has been executed yet.  If so, set the frame
	     to the current value of the stack pointer and set
	     the in_prologue flag.  */
	  CORE_ADDR addr;
	  struct symtab_and_line sal;

	  sal = find_pc_line (prologue_start, 0);
	  if (sal.line == 0)	/* no line info, use PC */
	    prologue_end = fi->pc;
	  else if (sal.end < prologue_end)
	    prologue_end = sal.end;
	  if (fi->pc < prologue_end)
	    {
	      for (addr = prologue_start; addr < fi->pc; addr += 4)
		{
		  insn = read_memory_integer (addr, 4);
		  if (X_OP (insn) == 2 && X_OP3 (insn) == 0x3c)
		    break;	/* SAVE seen, stop searching */
		}
	      if (addr >= fi->pc)
		{
		  fi->in_prologue = 1;
		  fi->frame = read_register (SP_REGNUM);
		}
	    }
	}
d355 1
a355 1
  return (CORE_ADDR) 1;
d378 1
a378 1
         Get the saved PC from the sigcontext structure.  */
d390 1
a390 1
         as the third parameter.  The offset to the saved pc is 12.  */
d392 1
a392 1
				(CORE_ADDR *) NULL, (CORE_ADDR *) NULL);
d397 2
a398 2
      get_saved_register (buf, (int *) NULL, (CORE_ADDR *) NULL,
			  frame, O0_REGNUM + 2, (enum lval_type *) NULL);
d402 1
a402 1
         stack layout has changed or the stack is corrupt.  */
d410 1
a410 1
		|| frame_in_dummy (frame->next))
d414 3
a416 3
         the PC, it is still in %o7.  */
      get_saved_register (buf, (int *) NULL, (CORE_ADDR *) NULL,
			  frame, O7_REGNUM, (enum lval_type *) NULL);
d456 1
a456 1

d474 1
a474 1
static CORE_ADDR
d514 2
a515 2
      if (frameless_p)		/* If the save is all we care about, */
	return pc;		/* return before doing more work */
d522 2
a523 2
      if (frameless_p)		/* If the add is all we care about, */
	return pc;		/* return before doing more work */
d536 1
a536 1
	  if (X_OP (insn) == 2
d557 2
a558 2
         This recognizes all non alternate stores of input register,
         into a location offset from the frame pointer.  */
d560 3
a562 3
	   && (X_OP3 (insn) & 0x3c) == 4	/* Store, non-alternate.  */
	   && (X_RD (insn) & 0x18) == 0x18	/* Input register.  */
	   && X_I (insn)	/* Immediate mode.  */
d564 1
a564 1
      /* Into reserved stack space.  */
d572 1
a572 1
	)
d587 1
a587 1
CORE_ADDR
d620 1
a620 1
      ))
d700 3
a702 3
	error ("The program has no registers now.");
      if (selected_frame == NULL)
	error ("No selected frame.");
d704 1
a704 1
      frame = get_prev_frame (selected_frame);
d706 1
a706 1
	error ("Cmd not meaningful in the outermost frame.");
d906 1
a906 1
      write_register (I7_REGNUM, read_pc () - 8);
d912 3
a914 3
         correctly in the simulator.  */
      write_register (G0_REGNUM + 1, read_register (FP_REGNUM));

d917 2
a918 2
      write_register (G0_REGNUM + 2, old_sp);

d920 3
a922 3
         executing the 'save'. */
      write_register (G0_REGNUM + 3, read_pc () - 8);

d924 1
a924 1
         This makes backtraces from an inferior function call work properly.  */
d980 2
a981 2
		 read_sp ())
      && fi->pc <= FRAME_FP (fi))
d984 1
a984 1
      for (regnum = G1_REGNUM; regnum < G1_REGNUM + 7; regnum++)
d987 2
a988 2
	  - DUMMY_STACK_REG_BUF_SIZE + 16 * SPARC_INTREG_SIZE;
      for (regnum = I0_REGNUM; regnum < I0_REGNUM + 8; regnum++)
d991 1
a991 1
	  - DUMMY_STACK_REG_BUF_SIZE + 8 * SPARC_INTREG_SIZE;
d996 1
a996 1
	  - DUMMY_STACK_REG_BUF_SIZE + 24 * SPARC_INTREG_SIZE;
d1001 1
a1001 1
	  - DUMMY_STACK_REG_BUF_SIZE + 24 * SPARC_INTREG_SIZE;
d1008 2
a1009 2
	    frame_addr + (regnum - PC_REGNUM) * SPARC_INTREG_SIZE
	    - DUMMY_STACK_REG_BUF_SIZE;
d1011 1
a1011 1
      saved_regs_addr->regs[PSTATE_REGNUM] =
d1016 2
a1017 2
	  frame_addr + (regnum - Y_REGNUM) * SPARC_INTREG_SIZE
	  - DUMMY_STACK_REG_BUF_SIZE;
d1037 1
a1037 1
      for (regnum = L0_REGNUM; regnum < L0_REGNUM + 8; regnum++)
d1041 1
a1041 1
      for (regnum = I0_REGNUM; regnum < I0_REGNUM + 8; regnum++)
d1056 4
a1059 4
	  (fi->next->bottom ?
	   fi->next->bottom :
	   read_sp ());
	  for (regnum = O0_REGNUM; regnum < O0_REGNUM + 8; regnum++)
d1125 1
a1125 1
         individually.  */
d1156 4
a1159 4
         moving the stack pointer is all that is really needed, except
         store_inferior_registers is then going to write the ins and
         locals from the registers array, so we need to muck with the
         registers array.  */
d1168 1
a1168 1
         Among other things this writes the new stack pointer.  */
d1185 1
a1185 1
					    REGISTER_RAW_SIZE (PC_REGNUM)));
d1189 1
a1189 1
					   REGISTER_RAW_SIZE (NPC_REGNUM)));
d1208 1
a1208 1
      write_register (PC_REGNUM, pc);
d1216 1
a1216 1
      write_register (PC_REGNUM, pc);
d1227 1
a1227 1
sparc_pc_adjust (pc)
d1237 1
a1237 1
    return pc + 12;
d1239 1
a1239 1
    return pc + 8;
d1246 2
a1247 2
   sethi %hi(addr),%g1
   jmp %g1+%lo(addr)
d1284 2
a1285 1
#ifdef USE_PROC_FS		/* Target dependent support for /proc */
a1323 2


d1330 1
a1330 1
     prgregset_t *gregsetp;
d1334 1
a1334 2
  static char zerobuf[MAX_REGISTER_RAW_SIZE] =
  {0};
d1337 1
a1337 1
  for (regi = G0_REGNUM; regi <= I7_REGNUM; regi++)
d1345 2
a1346 2
  supply_register (NPC_REGNUM, (char *) (regp + R_nPC));
  supply_register (Y_REGNUM, (char *) (regp + R_Y));
d1356 2
a1357 2
     prgregset_t *gregsetp;
     int regno;
d1362 1
a1362 1
  for (regi = 0; regi <= R_I7; regi++)
d1390 2
a1391 2
   (fpregset_t *), unpack the register contents and supply them as gdb's
   idea of the current floating point register values. */
d1393 1
a1393 1
void
d1395 1
a1395 1
     prfpregset_t *fpregsetp;
d1399 2
a1400 2

  for (regi = FP0_REGNUM; regi < FP_MAX_REGNUM; regi++)
d1402 1
a1402 1
      from = (char *) &fpregsetp->pr_fr.pr_regs[regi - FP0_REGNUM];
d1409 3
a1411 3
   (fpregset_t *), update the register specified by REGNO from gdb's idea
   of the current floating point register set.  If REGNO is -1, update
   them all. */
d1416 2
a1417 2
     prfpregset_t *fpregsetp;
     int regno;
d1423 1
a1423 1
  for (regi = FP0_REGNUM; regi < FP_MAX_REGNUM; regi++)
d1428 1
a1428 1
	  to = (char *) &fpregsetp->pr_fr.pr_regs[regi - FP0_REGNUM];
d1438 1
a1438 1
#endif /* defined (FP0_REGNUM) */
d1440 1
a1440 1
#endif /* USE_PROC_FS */
d1483 6
a1488 6
         of junk (the contents of which match a string given in the
         N_OPT), a period and the name.  For function-local statics
         there will be a bunch of junk (which seems to change the
         second character from 'A' to 'B'), a period, the name of the
         function, and the name.  So just skip everything before the
         last period.  */
d1510 5
a1514 5
		     val & 8 ? "N" : "NN",
		     val & 4 ? "Z" : "NZ",
		     val & 2 ? "O" : "NO",
		     val & 1 ? "C" : "NC"
    );
d1524 15
a1538 30
    case 4:
      return "ASI_NUCLEUS";
    case 0x0c:
      return "ASI_NUCLEUS_LITTLE";
    case 0x10:
      return "ASI_AS_IF_USER_PRIMARY";
    case 0x11:
      return "ASI_AS_IF_USER_SECONDARY";
    case 0x18:
      return "ASI_AS_IF_USER_PRIMARY_LITTLE";
    case 0x19:
      return "ASI_AS_IF_USER_SECONDARY_LITTLE";
    case 0x80:
      return "ASI_PRIMARY";
    case 0x81:
      return "ASI_SECONDARY";
    case 0x82:
      return "ASI_PRIMARY_NOFAULT";
    case 0x83:
      return "ASI_SECONDARY_NOFAULT";
    case 0x88:
      return "ASI_PRIMARY_LITTLE";
    case 0x89:
      return "ASI_SECONDARY_LITTLE";
    case 0x8a:
      return "ASI_PRIMARY_NOFAULT_LITTLE";
    case 0x8b:
      return "ASI_SECONDARY_NOFAULT_LITTLE";
    default:
      return NULL;
d1564 1
a1564 1
#if 0				/* FIXME: gdb doesn't handle long doubles */
d1578 1
a1578 1
#if 0				/* FIXME: gdb doesn't handle long doubles */
d1581 2
a1582 2
  /* We test for even numbered regs and not a multiple of 4 because
     the upper fp regs are recorded as doubles.  */
d1608 2
a1609 2
    case CCR_REGNUM:
      printf_unfiltered ("\t");
d1611 1
a1611 1
      printf_unfiltered (", ");
d1614 1
a1614 1
    case FPRS_REGNUM:
d1618 1
a1618 1
    case FSR_REGNUM:
d1620 2
a1621 4
	static char *fcc[4] =
	{"=", "<", ">", "?"};
	static char *rd[4] =
	{"N", "0", "+", "-"};
d1630 1
a1630 1
    case ASI_REGNUM:
d1637 1
a1637 1
    case VER_REGNUM:
d1642 1
a1642 1
    case PSTATE_REGNUM:
d1644 1
a1644 2
	static char *mm[4] =
	{"tso", "pso", "rso", "?"};
d1651 1
a1651 1
    case TSTATE_REGNUM:
d1654 1
a1654 1
    case TT_REGNUM:
d1657 1
a1657 1
    case TPC_REGNUM:
d1660 1
a1660 1
    case TNPC_REGNUM:
d1663 1
a1663 1
    case WSTATE_REGNUM:
d1666 1
a1666 1
    case CWP_REGNUM:
d1669 1
a1669 1
    case CANSAVE_REGNUM:
d1672 1
a1672 1
    case CANRESTORE_REGNUM:
d1675 1
a1675 1
    case CLEANWIN_REGNUM:
d1678 1
a1678 1
    case OTHERWIN_REGNUM:
d1691 2
a1692 4
	static char *fcc[4] =
	{"=", "<", ">", "?"};
	static char *rd[4] =
	{"N", "0", "+", "-"};
d1702 1
a1702 1
#endif /* GDB_TARGET_IS_SPARC64 */
d1738 1
a1738 1
  (struct sparc_arg *) alloca (nargs * sizeof (struct sparc_arg));
d1767 1
a1767 1
      m_arg->contents = VALUE_CONTENTS (arg);
d1775 2
a1776 2
  for (i = nargs; m_arg--, --i >= 0;)
    write_memory (sp + m_arg->offset, m_arg->contents, m_arg->len);
d1796 1
a1796 1
    memcpy (valbuf, &regbuf[REGISTER_BYTE (FP0_REGNUM)], typelen);
d1799 4
a1802 4
	    &regbuf[O0_REGNUM * regsize +
		    (typelen >= regsize
		     || TARGET_BYTE_ORDER == LITTLE_ENDIAN ? 0
		     : regsize - typelen)],
d1829 1
a1829 1
  if (TYPE_LENGTH (type) < REGISTER_RAW_SIZE (regno))
d1831 2
a1832 2
      bzero (buffer, REGISTER_RAW_SIZE (regno));
      memcpy (buffer + REGISTER_RAW_SIZE (regno) - TYPE_LENGTH (type), valbuf,
d1834 2
a1835 2
      write_register_bytes (REGISTER_BYTE (regno), buffer,
			    REGISTER_RAW_SIZE (regno));
d1866 1
a1866 1
			      & 0x3fffffff)));
d1894 6
a1899 6
	  char tmp = dummy[i];
	  dummy[i] = dummy[i + 3];
	  dummy[i + 3] = tmp;
	  tmp = dummy[i + 1];
	  dummy[i + 1] = dummy[i + 2];
	  dummy[i + 2] = tmp;
d1929 1
a1930 1

d1935 1
a1935 1
  tm_print_insn_info.mach = TM_PRINT_INSN_MACH;		/* Selects sparc/sparclite */
d2000 2
a2001 2

  sp = (sp & ~(((unsigned long) TYPE_LENGTH (builtin_type_long)) - 1UL));
d2013 3
a2015 3
	  copyarg = value_cast (builtin_type_long, copyarg);
	  copylen = TYPE_LENGTH (builtin_type_long);
	}
d2034 3
a2036 3
	  copyarg = value_cast (builtin_type_long, copyarg);
	  copylen = TYPE_LENGTH (builtin_type_long);
	}
d2075 1
a2075 1
      memcpy (valbuf, &regbuf[REGISTER_BYTE (FP0_REGNUM)], typelen);
d2083 1
a2083 1
	      &regbuf[O0_REGNUM * regsize +
d2096 1
a2096 1
	  struct field *f = &TYPE_FIELDS (type)[x];
@


1.1.1.6
log
@import gdb-1999-08-09 snapshot
@
text
@d457 1
a457 1
    internal_error ("create_new_frame returned invalid frame");
d977 1
a977 1
    internal_error ("Bad frame info struct in FRAME_FIND_SAVED_REGS");
d1738 1
a1738 1
  info->mach = TARGET_ARCHITECTURE->mach;
@


1.1.1.7
log
@import gdb-1999-10-04 snapshot
@
text
@a2145 2


@


