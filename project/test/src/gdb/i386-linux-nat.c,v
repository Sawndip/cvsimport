head	1.117;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.116
	gdb_7_6-2013-04-26-release:1.116
	gdb_7_6-branch:1.116.0.2
	gdb_7_6-2013-03-12-branchpoint:1.116
	gdb_7_5_1-2012-11-29-release:1.113
	gdb_7_5-2012-08-17-release:1.113
	gdb_7_5-branch:1.113.0.2
	gdb_7_5-2012-07-18-branchpoint:1.113
	gdb_7_4_1-2012-04-26-release:1.106.2.1
	gdb_7_4-2012-01-24-release:1.106.2.1
	gdb_7_4-branch:1.106.0.2
	gdb_7_4-2011-12-13-branchpoint:1.106
	gdb_7_3_1-2011-09-04-release:1.103
	gdb_7_3-2011-07-26-release:1.103
	gdb_7_3-branch:1.103.0.2
	gdb_7_3-2011-04-01-branchpoint:1.103
	gdb_7_2-2010-09-02-release:1.100
	gdb_7_2-branch:1.100.0.2
	gdb_7_2-2010-07-07-branchpoint:1.100
	gdb_7_1-2010-03-18-release:1.95
	gdb_7_1-branch:1.95.0.2
	gdb_7_1-2010-02-18-branchpoint:1.95
	gdb_7_0_1-2009-12-22-release:1.93
	gdb_7_0-2009-10-06-release:1.93
	gdb_7_0-branch:1.93.0.2
	gdb_7_0-2009-09-16-branchpoint:1.93
	arc-sim-20090309:1.85
	msnyder-checkpoint-072509-branch:1.92.0.2
	msnyder-checkpoint-072509-branchpoint:1.92
	arc-insight_6_8-branch:1.85.0.6
	arc-insight_6_8-branchpoint:1.85
	insight_6_8-branch:1.85.0.4
	insight_6_8-branchpoint:1.85
	reverse-20081226-branch:1.87.0.10
	reverse-20081226-branchpoint:1.87
	multiprocess-20081120-branch:1.87.0.8
	multiprocess-20081120-branchpoint:1.87
	reverse-20080930-branch:1.87.0.6
	reverse-20080930-branchpoint:1.87
	reverse-20080717-branch:1.87.0.4
	reverse-20080717-branchpoint:1.87
	msnyder-reverse-20080609-branch:1.87.0.2
	msnyder-reverse-20080609-branchpoint:1.87
	drow-reverse-20070409-branch:1.71.0.2
	drow-reverse-20070409-branchpoint:1.71
	gdb_6_8-2008-03-27-release:1.85
	gdb_6_8-branch:1.85.0.2
	gdb_6_8-2008-02-26-branchpoint:1.85
	gdb_6_7_1-2007-10-29-release:1.82
	gdb_6_7-2007-10-10-release:1.82
	gdb_6_7-branch:1.82.0.2
	gdb_6_7-2007-09-07-branchpoint:1.82
	insight_6_6-20070208-release:1.70
	gdb_6_6-2006-12-18-release:1.70
	gdb_6_6-branch:1.70.0.2
	gdb_6_6-2006-11-15-branchpoint:1.70
	insight_6_5-20061003-release:1.69
	gdb-csl-symbian-6_4_50_20060226-12:1.68
	gdb-csl-sourcerygxx-3_4_4-25:1.67
	nickrob-async-20060828-mergepoint:1.70
	gdb-csl-symbian-6_4_50_20060226-11:1.68
	gdb-csl-sourcerygxx-4_1-17:1.68
	gdb-csl-20060226-branch-local-2:1.68
	gdb-csl-sourcerygxx-4_1-14:1.68
	gdb-csl-sourcerygxx-4_1-13:1.68
	gdb-csl-sourcerygxx-4_1-12:1.68
	gdb-csl-sourcerygxx-3_4_4-21:1.68
	gdb_6_5-20060621-release:1.69
	gdb-csl-sourcerygxx-4_1-9:1.68
	gdb-csl-sourcerygxx-4_1-8:1.68
	gdb-csl-sourcerygxx-4_1-7:1.68
	gdb-csl-arm-2006q1-6:1.68
	gdb-csl-sourcerygxx-4_1-6:1.68
	gdb-csl-symbian-6_4_50_20060226-10:1.68
	gdb-csl-symbian-6_4_50_20060226-9:1.68
	gdb-csl-symbian-6_4_50_20060226-8:1.68
	gdb-csl-coldfire-4_1-11:1.68
	gdb-csl-sourcerygxx-3_4_4-19:1.68
	gdb-csl-coldfire-4_1-10:1.68
	gdb_6_5-branch:1.69.0.10
	gdb_6_5-2006-05-14-branchpoint:1.69
	gdb-csl-sourcerygxx-4_1-5:1.68
	nickrob-async-20060513-branch:1.69.0.8
	nickrob-async-20060513-branchpoint:1.69
	gdb-csl-sourcerygxx-4_1-4:1.68
	msnyder-reverse-20060502-branch:1.69.0.6
	msnyder-reverse-20060502-branchpoint:1.69
	gdb-csl-morpho-4_1-4:1.68
	gdb-csl-sourcerygxx-3_4_4-17:1.68
	readline_5_1-import-branch:1.69.0.4
	readline_5_1-import-branchpoint:1.69
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.68
	gdb-csl-symbian-20060226-branch:1.68.0.6
	gdb-csl-symbian-20060226-branchpoint:1.68
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.68
	msnyder-reverse-20060331-branch:1.69.0.2
	msnyder-reverse-20060331-branchpoint:1.69
	gdb-csl-available-20060303-branch:1.68.0.4
	gdb-csl-available-20060303-branchpoint:1.68
	gdb-csl-20060226-branch:1.68.0.2
	gdb-csl-20060226-branchpoint:1.68
	gdb_6_4-20051202-release:1.67
	msnyder-fork-checkpoint-branch:1.67.0.8
	msnyder-fork-checkpoint-branchpoint:1.67
	gdb-csl-gxxpro-6_3-branch:1.67.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.67
	gdb_6_4-branch:1.67.0.4
	gdb_6_4-2005-11-01-branchpoint:1.67
	gdb-csl-arm-20051020-branch:1.67.0.2
	gdb-csl-arm-20051020-branchpoint:1.67
	msnyder-tracepoint-checkpoint-branch:1.64.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.64
	gdb-csl-arm-20050325-2005-q1b:1.63
	gdb-csl-arm-20050325-2005-q1a:1.63
	csl-arm-20050325-branch:1.63.0.2
	csl-arm-20050325-branchpoint:1.63
	gdb-post-i18n-errorwarning-20050211:1.62
	gdb-pre-i18n-errorwarning-20050211:1.61
	gdb_6_3-20041109-release:1.61
	gdb_6_3-branch:1.61.0.2
	gdb_6_3-20041019-branchpoint:1.61
	drow_intercu-merge-20040921:1.61
	drow_intercu-merge-20040915:1.61
	jimb-gdb_6_2-e500-branch:1.55.0.6
	jimb-gdb_6_2-e500-branchpoint:1.55
	gdb_6_2-20040730-release:1.55
	gdb_6_2-branch:1.55.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.55
	gdb_6_1_1-20040616-release:1.54
	gdb_6_1-2004-04-05-release:1.54
	drow_intercu-merge-20040402:1.54
	drow_intercu-merge-20040327:1.54
	ezannoni_pie-20040323-branch:1.54.0.12
	ezannoni_pie-20040323-branchpoint:1.54
	cagney_tramp-20040321-mergepoint:1.54
	cagney_tramp-20040309-branch:1.54.0.10
	cagney_tramp-20040309-branchpoint:1.54
	gdb_6_1-branch:1.54.0.8
	gdb_6_1-2004-03-01-gmt-branchpoint:1.54
	drow_intercu-20040221-branch:1.54.0.6
	drow_intercu-20040221-branchpoint:1.54
	cagney_bfdfile-20040213-branch:1.54.0.4
	cagney_bfdfile-20040213-branchpoint:1.54
	drow-cplus-merge-20040208:1.54
	carlton_dictionary-20040126-merge:1.54
	cagney_bigcore-20040122-branch:1.54.0.2
	cagney_bigcore-20040122-branchpoint:1.54
	drow-cplus-merge-20040113:1.54
	drow-cplus-merge-20031224:1.53
	drow-cplus-merge-20031220:1.53
	carlton_dictionary-20031215-merge:1.53
	drow-cplus-merge-20031214:1.53
	carlton-dictionary-20031111-merge:1.53
	gdb_6_0-2003-10-04-release:1.47.6.2
	kettenis_sparc-20030918-branch:1.51.0.4
	kettenis_sparc-20030918-branchpoint:1.51
	carlton_dictionary-20030917-merge:1.51
	ezannoni_pie-20030916-branchpoint:1.51
	ezannoni_pie-20030916-branch:1.51.0.2
	cagney_x86i386-20030821-branch:1.48.0.2
	cagney_x86i386-20030821-branchpoint:1.48
	carlton_dictionary-20030805-merge:1.47
	carlton_dictionary-20030627-merge:1.47
	gdb_6_0-branch:1.47.0.6
	gdb_6_0-2003-06-23-branchpoint:1.47
	jimb-ppc64-linux-20030613-branch:1.47.0.4
	jimb-ppc64-linux-20030613-branchpoint:1.47
	cagney_convert-20030606-branch:1.47.0.2
	cagney_convert-20030606-branchpoint:1.47
	cagney_writestrings-20030508-branch:1.45.0.8
	cagney_writestrings-20030508-branchpoint:1.45
	jimb-ppc64-linux-20030528-branch:1.45.0.6
	jimb-ppc64-linux-20030528-branchpoint:1.45
	carlton_dictionary-20030523-merge:1.45
	cagney_fileio-20030521-branch:1.45.0.4
	cagney_fileio-20030521-branchpoint:1.45
	kettenis_i386newframe-20030517-mergepoint:1.45
	jimb-ppc64-linux-20030509-branch:1.45.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.45
	kettenis_i386newframe-20030504-mergepoint:1.45
	carlton_dictionary-20030430-merge:1.44
	kettenis_i386newframe-20030419-branch:1.44.0.2
	kettenis_i386newframe-20030419-branchpoint:1.44
	carlton_dictionary-20030416-merge:1.44
	cagney_frameaddr-20030409-mergepoint:1.43
	kettenis_i386newframe-20030406-branch:1.43.0.18
	kettenis_i386newframe-20030406-branchpoint:1.43
	cagney_frameaddr-20030403-branchpoint:1.43
	cagney_frameaddr-20030403-branch:1.43.0.16
	cagney_framebase-20030330-mergepoint:1.43
	cagney_framebase-20030326-branch:1.43.0.14
	cagney_framebase-20030326-branchpoint:1.43
	cagney_lazyid-20030317-branch:1.43.0.12
	cagney_lazyid-20030317-branchpoint:1.43
	kettenis-i386newframe-20030316-mergepoint:1.43
	offbyone-20030313-branch:1.43.0.10
	offbyone-20030313-branchpoint:1.43
	kettenis-i386newframe-20030308-branch:1.43.0.8
	kettenis-i386newframe-20030308-branchpoint:1.43
	carlton_dictionary-20030305-merge:1.43
	cagney_offbyone-20030303-branch:1.43.0.6
	cagney_offbyone-20030303-branchpoint:1.43
	carlton_dictionary-20030207-merge:1.43
	interps-20030203-mergepoint:1.43
	interps-20030202-branch:1.43.0.4
	interps-20030202-branchpoint:1.43
	cagney-unwind-20030108-branch:1.43.0.2
	cagney-unwind-20030108-branchpoint:1.43
	carlton_dictionary-20021223-merge:1.43
	gdb_5_3-2002-12-12-release:1.42
	carlton_dictionary-20021115-merge:1.43
	kseitz_interps-20021105-merge:1.42
	kseitz_interps-20021103-merge:1.42
	drow-cplus-merge-20021020:1.42
	drow-cplus-merge-20021025:1.42
	carlton_dictionary-20021025-merge:1.42
	carlton_dictionary-20021011-merge:1.42
	drow-cplus-branch:1.42.0.6
	drow-cplus-branchpoint:1.42
	kseitz_interps-20020930-merge:1.42
	carlton_dictionary-20020927-merge:1.42
	carlton_dictionary-branch:1.42.0.4
	carlton_dictionary-20020920-branchpoint:1.42
	gdb_5_3-branch:1.42.0.2
	gdb_5_3-2002-09-04-branchpoint:1.42
	kseitz_interps-20020829-merge:1.41
	cagney_sysregs-20020825-branch:1.40.0.4
	cagney_sysregs-20020825-branchpoint:1.40
	readline_4_3-import-branch:1.40.0.2
	readline_4_3-import-branchpoint:1.40
	gdb_5_2_1-2002-07-23-release:1.35
	kseitz_interps-20020528-branch:1.36.0.4
	kseitz_interps-20020528-branchpoint:1.36
	cagney_regbuf-20020515-branch:1.36.0.2
	cagney_regbuf-20020515-branchpoint:1.36
	jimb-macro-020506-branch:1.35.0.4
	jimb-macro-020506-branchpoint:1.35
	gdb_5_2-2002-04-29-release:1.35
	gdb_5_2-branch:1.35.0.2
	gdb_5_2-2002-03-03-branchpoint:1.35
	gdb_5_1_1-2002-01-24-release:1.28
	gdb_5_1_0_1-2002-01-03-release:1.28
	cygnus_cvs_20020108_pre:1.33
	gdb_5_1_0_1-2002-01-03-branchpoint:1.28
	gdb_5_1_0_1-2002-01-03-branch:1.28.0.8
	gdb_5_1-2001-11-21-release:1.28
	gdb_s390-2001-09-26-branch:1.28.0.6
	gdb_s390-2001-09-26-branchpoint:1.28
	gdb_5_1-2001-07-29-branch:1.28.0.4
	gdb_5_1-2001-07-29-branchpoint:1.28
	dberlin-typesystem-branch:1.28.0.2
	dberlin-typesystem-branchpoint:1.28
	gdb-post-ptid_t-2001-05-03:1.27
	gdb-pre-ptid_t-2001-05-03:1.26
	insight-precleanup-2001-01-01:1.19
	gdb-post-protoization-2000-07-29:1.13
	gdb-pre-protoization-2000-07-29:1.12
	gdb-premipsmulti-2000-06-06-branch:1.12.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.12
	gdb-post-params-removal-2000-06-04:1.12
	gdb-pre-params-removal-2000-06-04:1.12
	gdb-post-params-removal-2000-05-28:1.12
	gdb-pre-params-removal-2000-05-28:1.12
	gdb_5_0-2000-05-19-release:1.9.2.1
	gdb_4_18_2-2000-05-18-release:1.9.2.1
	gdb_4_95_1-2000-05-11-snapshot:1.9.2.1
	gdb_4_95_0-2000-04-27-snapshot:1.9
	gdb_5_0-2000-04-10-branch:1.9.0.2
	gdb_5_0-2000-04-10-branchpoint:1.9
	repo-unification-2000-02-06:1.1.1.8
	insight-2000-02-04:1.1.1.8
	gdb-2000-02-04:1.1.1.8
	gdb-2000-02-02:1.1.1.8
	gdb-2000-02-01:1.1.1.8
	gdb-2000-01-31:1.1.1.8
	gdb-2000-01-26:1.1.1.8
	gdb-2000-01-24:1.1.1.8
	gdb-2000-01-17:1.1.1.8
	gdb-2000-01-10:1.1.1.7
	gdb-2000-01-05:1.1.1.7
	gdb-1999-12-21:1.1.1.7
	gdb-1999-12-13:1.1.1.6
	gdb-1999-12-07:1.1.1.6
	gdb-1999-12-06:1.1.1.5
	gdb-1999-11-16:1.1.1.4
	gdb-1999-11-08:1.1.1.4
	gdb-1999-11-01:1.1.1.3
	gdb-1999-10-25:1.1.1.2
	gdb-1999-10-18:1.1.1.2
	gdb-1999-10-11:1.1.1.1
	gdb-1999-10-04:1.1.1.1
	gdb-1999-09-28:1.1.1.1
	gdb-1999-09-21:1.1.1.1
	gdb-1999-09-13:1.1.1.1
	gdb-1999-09-08:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.117
date	2013.09.30.11.50.11;	author luisgpm;	state Exp;
branches;
next	1.116;

1.116
date	2013.03.11.08.25.57;	author mmetzger;	state Exp;
branches;
next	1.115;

1.115
date	2013.02.13.14.59.48;	author palves;	state Exp;
branches;
next	1.114;

1.114
date	2013.01.01.06.32.45;	author brobecke;	state Exp;
branches;
next	1.113;

1.113
date	2012.05.24.16.39.08;	author palves;	state Exp;
branches;
next	1.112;

1.112
date	2012.03.02.12.56.50;	author qiyao;	state Exp;
branches;
next	1.111;

1.111
date	2012.01.24.13.46.54;	author jkratoch;	state Exp;
branches;
next	1.110;

1.110
date	2012.01.04.08.17.04;	author brobecke;	state Exp;
branches;
next	1.109;

1.109
date	2012.01.02.02.42.24;	author jkratoch;	state Exp;
branches;
next	1.108;

1.108
date	2011.12.20.10.40.15;	author palves;	state Exp;
branches;
next	1.107;

1.107
date	2011.12.14.17.20.30;	author palves;	state Exp;
branches;
next	1.106;

1.106
date	2011.12.05.14.16.50;	author palves;	state Exp;
branches
	1.106.2.1;
next	1.105;

1.105
date	2011.10.07.17.15.15;	author palves;	state Exp;
branches;
next	1.104;

1.104
date	2011.09.23.07.27.19;	author qiyao;	state Exp;
branches;
next	1.103;

1.103
date	2011.02.27.16.25.37;	author msnyder;	state Exp;
branches;
next	1.102;

1.102
date	2011.01.09.03.08.56;	author msnyder;	state Exp;
branches;
next	1.101;

1.101
date	2011.01.01.15.33.07;	author brobecke;	state Exp;
branches;
next	1.100;

1.100
date	2010.06.11.12.08.50;	author uweigand;	state Exp;
branches;
next	1.99;

1.99
date	2010.04.22.20.35.28;	author hjl;	state Exp;
branches;
next	1.98;

1.98
date	2010.04.08.22.32.36;	author hjl;	state Exp;
branches;
next	1.97;

1.97
date	2010.04.07.18.43.44;	author hjl;	state Exp;
branches;
next	1.96;

1.96
date	2010.03.01.15.33.30;	author hjl;	state Exp;
branches;
next	1.95;

1.95
date	2010.01.01.07.31.33;	author brobecke;	state Exp;
branches;
next	1.94;

1.94
date	2009.11.20.19.57.28;	author jkratoch;	state Exp;
branches;
next	1.93;

1.93
date	2009.09.15.03.30.06;	author sergiodj;	state Exp;
branches;
next	1.92;

1.92
date	2009.07.02.17.25.54;	author uweigand;	state Exp;
branches;
next	1.91;

1.91
date	2009.05.14.09.36.59;	author muller;	state Exp;
branches;
next	1.90;

1.90
date	2009.02.23.00.42.06;	author palves;	state Exp;
branches;
next	1.89;

1.89
date	2009.02.23.00.03.49;	author palves;	state Exp;
branches;
next	1.88;

1.88
date	2009.01.03.05.57.51;	author brobecke;	state Exp;
branches;
next	1.87;

1.87
date	2008.03.13.12.22.13;	author drow;	state Exp;
branches;
next	1.86;

1.86
date	2008.03.01.04.39.36;	author drow;	state Exp;
branches;
next	1.85;

1.85
date	2008.01.01.22.53.10;	author drow;	state Exp;
branches;
next	1.84;

1.84
date	2007.10.09.18.18.50;	author uweigand;	state Exp;
branches;
next	1.83;

1.83
date	2007.10.01.00.22.50;	author drow;	state Exp;
branches;
next	1.82;

1.82
date	2007.08.23.18.08.34;	author brobecke;	state Exp;
branches;
next	1.81;

1.81
date	2007.07.16.18.34.50;	author hjl;	state Exp;
branches;
next	1.80;

1.80
date	2007.06.18.17.45.26;	author uweigand;	state Exp;
branches;
next	1.79;

1.79
date	2007.06.16.17.16.25;	author uweigand;	state Exp;
branches;
next	1.78;

1.78
date	2007.06.09.13.42.15;	author uweigand;	state Exp;
branches;
next	1.77;

1.77
date	2007.05.31.17.32.21;	author uweigand;	state Exp;
branches;
next	1.76;

1.76
date	2007.05.12.00.17.05;	author uweigand;	state Exp;
branches;
next	1.75;

1.75
date	2007.05.06.14.34.37;	author uweigand;	state Exp;
branches;
next	1.74;

1.74
date	2007.05.06.14.32.30;	author uweigand;	state Exp;
branches;
next	1.73;

1.73
date	2007.05.06.14.28.27;	author uweigand;	state Exp;
branches;
next	1.72;

1.72
date	2007.04.25.22.10.08;	author uweigand;	state Exp;
branches;
next	1.71;

1.71
date	2007.01.09.17.58.51;	author drow;	state Exp;
branches;
next	1.70;

1.70
date	2006.08.08.21.32.37;	author brobecke;	state Exp;
branches;
next	1.69;

1.69
date	2006.03.24.23.08.16;	author drow;	state Exp;
branches
	1.69.8.1;
next	1.68;

1.68
date	2005.12.17.22.34.01;	author eliz;	state Exp;
branches;
next	1.67;

1.67
date	2005.09.10.18.11.02;	author drow;	state Exp;
branches;
next	1.66;

1.66
date	2005.08.13.22.03.46;	author kettenis;	state Exp;
branches;
next	1.65;

1.65
date	2005.08.09.16.35.45;	author cagney;	state Exp;
branches;
next	1.64;

1.64
date	2005.05.28.16.44.28;	author drow;	state Exp;
branches;
next	1.63;

1.63
date	2005.02.11.18.13.50;	author cagney;	state Exp;
branches;
next	1.62;

1.62
date	2005.02.11.04.05.51;	author cagney;	state Exp;
branches;
next	1.61;

1.61
date	2004.09.08.14.46.09;	author kettenis;	state Exp;
branches;
next	1.60;

1.60
date	2004.08.14.16.01.39;	author kettenis;	state Exp;
branches;
next	1.59;

1.59
date	2004.07.24.01.00.19;	author cagney;	state Exp;
branches;
next	1.58;

1.58
date	2004.07.22.01.31.48;	author cagney;	state Exp;
branches;
next	1.57;

1.57
date	2004.07.20.19.45.06;	author cagney;	state Exp;
branches;
next	1.56;

1.56
date	2004.07.10.01.17.52;	author msnyder;	state Exp;
branches;
next	1.55;

1.55
date	2004.04.09.16.31.01;	author kettenis;	state Exp;
branches;
next	1.54;

1.54
date	2003.12.26.15.42.58;	author kettenis;	state Exp;
branches
	1.54.6.1;
next	1.53;

1.53
date	2003.10.31.22.04.44;	author kettenis;	state Exp;
branches;
next	1.52;

1.52
date	2003.09.28.13.35.44;	author kettenis;	state Exp;
branches;
next	1.51;

1.51
date	2003.08.31.15.18.58;	author kettenis;	state Exp;
branches;
next	1.50;

1.50
date	2003.08.26.19.34.53;	author cagney;	state Exp;
branches;
next	1.49;

1.49
date	2003.08.23.08.56.45;	author kettenis;	state Exp;
branches;
next	1.48;

1.48
date	2003.08.17.18.22.25;	author drow;	state Exp;
branches
	1.48.2.1;
next	1.47;

1.47
date	2003.06.04.20.51.29;	author jjohnstn;	state Exp;
branches
	1.47.6.1;
next	1.46;

1.46
date	2003.06.01.16.45.01;	author kettenis;	state Exp;
branches;
next	1.45;

1.45
date	2003.05.04.10.18.10;	author kettenis;	state Exp;
branches;
next	1.44;

1.44
date	2003.04.16.15.22.02;	author kettenis;	state Exp;
branches
	1.44.2.1;
next	1.43;

1.43
date	2002.11.09.21.31.11;	author kettenis;	state Exp;
branches;
next	1.42;

1.42
date	2002.09.01.22.05.42;	author kettenis;	state Exp;
branches
	1.42.4.1
	1.42.6.1;
next	1.41;

1.41
date	2002.08.27.22.37.06;	author tromey;	state Exp;
branches;
next	1.40;

1.40
date	2002.06.15.16.43.54;	author kettenis;	state Exp;
branches;
next	1.39;

1.39
date	2002.06.15.14.03.10;	author kettenis;	state Exp;
branches;
next	1.38;

1.38
date	2002.06.14.22.30.41;	author cagney;	state Exp;
branches;
next	1.37;

1.37
date	2002.06.09.16.06.48;	author kettenis;	state Exp;
branches;
next	1.36;

1.36
date	2002.05.11.17.22.26;	author thorpej;	state Exp;
branches
	1.36.2.1
	1.36.4.1;
next	1.35;

1.35
date	2002.02.24.22.14.33;	author cagney;	state Exp;
branches;
next	1.34;

1.34
date	2002.01.09.22.32.16;	author msnyder;	state Exp;
branches;
next	1.33;

1.33
date	2001.12.27.19.52.31;	author msnyder;	state Exp;
branches;
next	1.32;

1.32
date	2001.11.18.21.38.59;	author kevinb;	state Exp;
branches;
next	1.31;

1.31
date	2001.11.18.01.19.47;	author kevinb;	state Exp;
branches;
next	1.30;

1.30
date	2001.11.17.23.53.16;	author kevinb;	state Exp;
branches;
next	1.29;

1.29
date	2001.11.04.14.30.42;	author kettenis;	state Exp;
branches;
next	1.28;

1.28
date	2001.05.15.00.03.36;	author kevinb;	state Exp;
branches;
next	1.27;

1.27
date	2001.05.04.04.15.25;	author kevinb;	state Exp;
branches;
next	1.26;

1.26
date	2001.04.01.10.48.48;	author kettenis;	state Exp;
branches;
next	1.25;

1.25
date	2001.03.28.08.35.14;	author kettenis;	state Exp;
branches;
next	1.24;

1.24
date	2001.03.21.21.22.48;	author kettenis;	state Exp;
branches;
next	1.23;

1.23
date	2001.03.13.23.31.13;	author cagney;	state Exp;
branches;
next	1.22;

1.22
date	2001.03.01.01.39.20;	author cagney;	state Exp;
branches;
next	1.21;

1.21
date	2001.02.08.06.03.53;	author cagney;	state Exp;
branches;
next	1.20;

1.20
date	2001.01.03.21.12.17;	author jtc;	state Exp;
branches;
next	1.19;

1.19
date	2000.12.21.20.18.45;	author kettenis;	state Exp;
branches;
next	1.18;

1.18
date	2000.09.22.17.45.47;	author schauer;	state Exp;
branches;
next	1.17;

1.17
date	2000.08.29.23.31.10;	author msnyder;	state Exp;
branches;
next	1.16;

1.16
date	2000.08.28.21.54.37;	author kettenis;	state Exp;
branches;
next	1.15;

1.15
date	2000.08.11.19.45.21;	author kettenis;	state Exp;
branches;
next	1.14;

1.14
date	2000.08.10.17.04.33;	author kettenis;	state Exp;
branches;
next	1.13;

1.13
date	2000.07.30.01.48.25;	author kevinb;	state Exp;
branches;
next	1.12;

1.12
date	2000.05.26.23.22.40;	author msnyder;	state Exp;
branches;
next	1.11;

1.11
date	2000.05.04.19.25.57;	author kettenis;	state Exp;
branches;
next	1.10;

1.10
date	2000.04.30.09.34.13;	author kettenis;	state Exp;
branches;
next	1.9;

1.9
date	2000.04.02.20.16.28;	author kettenis;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2000.03.20.20.38.22;	author jimb;	state Exp;
branches;
next	1.7;

1.7
date	2000.03.16.23.53.35;	author jimb;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.16.22.51.49;	author jimb;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.16.22.46.26;	author jimb;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.06.16.08.12;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.05.22.57.05;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.05.16.39.11;	author kettenis;	state Exp;
branches;
next	1.1;

1.1
date	99.09.08.23.59.15;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.106.2.1
date	2012.01.06.04.43.15;	author brobecke;	state Exp;
branches;
next	;

1.69.8.1
date	2006.05.12.07.40.23;	author nickrob;	state Exp;
branches;
next	1.69.8.2;

1.69.8.2
date	2006.08.28.07.48.48;	author nickrob;	state Exp;
branches;
next	1.69.8.3;

1.69.8.3
date	2006.09.14.02.27.02;	author nickrob;	state Exp;
branches;
next	;

1.54.6.1
date	2004.09.16.17.01.08;	author drow;	state Exp;
branches;
next	;

1.48.2.1
date	2003.08.21.20.16.49;	author cagney;	state Exp;
branches;
next	;

1.47.6.1
date	2003.08.17.18.22.33;	author drow;	state Exp;
branches;
next	1.47.6.2;

1.47.6.2
date	2003.08.26.20.39.24;	author cagney;	state Exp;
branches;
next	;

1.44.2.1
date	2003.05.04.11.37.42;	author kettenis;	state Exp;
branches;
next	;

1.42.4.1
date	2002.11.15.19.18.46;	author carlton;	state Exp;
branches;
next	1.42.4.2;

1.42.4.2
date	2003.04.16.19.56.52;	author carlton;	state Exp;
branches;
next	1.42.4.3;

1.42.4.3
date	2003.05.23.18.40.40;	author carlton;	state Exp;
branches;
next	1.42.4.4;

1.42.4.4
date	2003.06.27.21.49.58;	author carlton;	state Exp;
branches;
next	1.42.4.5;

1.42.4.5
date	2003.09.17.21.28.21;	author carlton;	state Exp;
branches;
next	1.42.4.6;

1.42.4.6
date	2003.11.11.23.50.46;	author carlton;	state Exp;
branches;
next	1.42.4.7;

1.42.4.7
date	2004.01.26.19.11.26;	author carlton;	state Exp;
branches;
next	;

1.42.6.1
date	2003.12.14.20.27.16;	author drow;	state Exp;
branches;
next	1.42.6.2;

1.42.6.2
date	2004.01.13.16.11.57;	author drow;	state Exp;
branches;
next	;

1.36.2.1
date	2002.06.15.16.42.52;	author cagney;	state Exp;
branches;
next	1.36.2.2;

1.36.2.2
date	2002.06.21.16.19.25;	author cagney;	state Exp;
branches;
next	;

1.36.4.1
date	2002.06.20.01.32.31;	author kseitz;	state Exp;
branches;
next	1.36.4.2;

1.36.4.2
date	2002.08.30.22.52.44;	author kseitz;	state Exp;
branches;
next	1.36.4.3;

1.36.4.3
date	2002.10.01.00.46.09;	author kseitz;	state Exp;
branches;
next	;

1.9.2.1
date	2000.05.04.19.14.26;	author kettenis;	state Exp;
branches;
next	;

1.1.1.1
date	99.09.08.23.59.15;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.10.19.02.46.36;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.11.02.04.44.16;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.11.09.01.23.04;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.12.07.03.56.01;	author jsm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.12.08.02.50.38;	author jsm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	99.12.22.21.45.06;	author jsm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2000.01.18.00.54.14;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.117
log
@	* aarch64-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	Replace GET_LWP with ptid_get_lwp.
	* aix-thread.c (BUILD_THREAD, BUILD_LWP): Remove.
	Replace BUILD_THREAD with ptid_build.
	Replace BUILD_LWP with ptid_build.
	Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	* alphabsd-nat.c: Replace PIDGET with ptid_get_pid.
	* amd64-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	* amd64bsd-nat.c: Replace PIDGET with ptid_get_pid.
	* arm-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	Replace GET_LWP with ptid_get_lwp.
	* armnbsd-nat.c: Replace PIDGET with ptid_get_pid.
	* auxv.c: Likewise.
	* breakpoint.c: Likewise.
	* common/ptid.c (ptid_is_pid): Condense check for
	null_ptid and minus_one_ptid.
	(ptid_lwp_p): New function.
	(ptid_tid_p): New function.
	* common/ptid.h: Update comments for accessors.
	(ptid_lwp_p): New prototype.
	(ptid_tid_p): New prototype.
	* defs.h (PIDGET, TIDGET, MERGEPID): Do not define.
	* gcore.c: Replace PIDGET with ptid_get_pid.
	* gdbthread.h: Likewise.
	* gnu-nat.c: Likewise.
	* hppa-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	* hppabsd-nat.c: Replace PIDGET with ptid_get_pid.
	* hppanbsd-nat.c: Likewise.
	* i386-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	* i386bsd-nat.c: Replace PIDGET with ptid_get_pid.
	* ia64-linux-nat.c: Replace PIDGET with ptid_get_pid.
	* infcmd.c: Likewise.
	* inferior.h: Likewise.
	* inflow.c: Likewise.
	* infrun.c: Likewise.
	* linux-fork.c: Likewise.
	* linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace GET_PID with ptid_get_pid.
	Replace is_lwp with ptid_lwp_p.
	Replace GET_LWP with ptid_get_lwp.
	Replace BUILD_LWP with ptid_build.
@
text
@/* Native-dependent code for GNU/Linux i386.

   Copyright (C) 1999-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "i386-nat.h"
#include "inferior.h"
#include "gdbcore.h"
#include "regcache.h"
#include "regset.h"
#include "target.h"
#include "linux-nat.h"
#include "linux-btrace.h"
#include "btrace.h"

#include "gdb_assert.h"
#include "gdb_string.h"
#include "elf/common.h"
#include <sys/uio.h>
#include <sys/ptrace.h>
#include <sys/user.h>
#include <sys/procfs.h>

#ifdef HAVE_SYS_REG_H
#include <sys/reg.h>
#endif

#ifndef ORIG_EAX
#define ORIG_EAX -1
#endif

#ifdef HAVE_SYS_DEBUGREG_H
#include <sys/debugreg.h>
#endif

/* Prototypes for supply_gregset etc.  */
#include "gregset.h"

#include "i387-tdep.h"
#include "i386-tdep.h"
#include "i386-linux-tdep.h"

/* Defines ps_err_e, struct ps_prochandle.  */
#include "gdb_proc_service.h"

#include "i386-xstate.h"

#ifndef PTRACE_GETREGSET
#define PTRACE_GETREGSET	0x4204
#endif

#ifndef PTRACE_SETREGSET
#define PTRACE_SETREGSET	0x4205
#endif

/* Per-thread arch-specific data we want to keep.  */

struct arch_lwp_info
{
  /* Non-zero if our copy differs from what's recorded in the thread.  */
  int debug_registers_changed;
};

/* Does the current host support PTRACE_GETREGSET?  */
static int have_ptrace_getregset = -1;


/* The register sets used in GNU/Linux ELF core-dumps are identical to
   the register sets in `struct user' that is used for a.out
   core-dumps, and is also used by `ptrace'.  The corresponding types
   are `elf_gregset_t' for the general-purpose registers (with
   `elf_greg_t' the type of a single GP register) and `elf_fpregset_t'
   for the floating-point registers.

   Those types used to be available under the names `gregset_t' and
   `fpregset_t' too, and this file used those names in the past.  But
   those names are now used for the register sets used in the
   `mcontext_t' type, and have a different size and layout.  */

/* Which ptrace request retrieves which registers?
   These apply to the corresponding SET requests as well.  */

#define GETREGS_SUPPLIES(regno) \
  ((0 <= (regno) && (regno) <= 15) || (regno) == I386_LINUX_ORIG_EAX_REGNUM)

#define GETFPXREGS_SUPPLIES(regno) \
  (I386_ST0_REGNUM <= (regno) && (regno) < I386_SSE_NUM_REGS)

#define GETXSTATEREGS_SUPPLIES(regno) \
  (I386_ST0_REGNUM <= (regno) && (regno) < I386_AVX_NUM_REGS)

/* Does the current host support the GETREGS request?  */
int have_ptrace_getregs =
#ifdef HAVE_PTRACE_GETREGS
  1
#else
  0
#endif
;

/* Does the current host support the GETFPXREGS request?  The header
   file may or may not define it, and even if it is defined, the
   kernel will return EIO if it's running on a pre-SSE processor.

   My instinct is to attach this to some architecture- or
   target-specific data structure, but really, a particular GDB
   process can only run on top of one kernel at a time.  So it's okay
   for this to be a simple variable.  */
int have_ptrace_getfpxregs =
#ifdef HAVE_PTRACE_GETFPXREGS
  -1
#else
  0
#endif
;


/* Accessing registers through the U area, one at a time.  */

/* Fetch one register.  */

static void
fetch_register (struct regcache *regcache, int regno)
{
  int tid;
  int val;

  gdb_assert (!have_ptrace_getregs);
  if (i386_linux_gregset_reg_offset[regno] == -1)
    {
      regcache_raw_supply (regcache, regno, NULL);
      return;
    }

  /* GNU/Linux LWP ID's are process ID's.  */
  tid = ptid_get_lwp (inferior_ptid);
  if (tid == 0)
    tid = ptid_get_pid (inferior_ptid); /* Not a threaded program.  */

  errno = 0;
  val = ptrace (PTRACE_PEEKUSER, tid,
		i386_linux_gregset_reg_offset[regno], 0);
  if (errno != 0)
    error (_("Couldn't read register %s (#%d): %s."), 
	   gdbarch_register_name (get_regcache_arch (regcache), regno),
	   regno, safe_strerror (errno));

  regcache_raw_supply (regcache, regno, &val);
}

/* Store one register.  */

static void
store_register (const struct regcache *regcache, int regno)
{
  int tid;
  int val;

  gdb_assert (!have_ptrace_getregs);
  if (i386_linux_gregset_reg_offset[regno] == -1)
    return;

  /* GNU/Linux LWP ID's are process ID's.  */
  tid = ptid_get_lwp (inferior_ptid);
  if (tid == 0)
    tid = ptid_get_pid (inferior_ptid); /* Not a threaded program.  */

  errno = 0;
  regcache_raw_collect (regcache, regno, &val);
  ptrace (PTRACE_POKEUSER, tid,
	  i386_linux_gregset_reg_offset[regno], val);
  if (errno != 0)
    error (_("Couldn't write register %s (#%d): %s."),
	   gdbarch_register_name (get_regcache_arch (regcache), regno),
	   regno, safe_strerror (errno));
}


/* Transfering the general-purpose registers between GDB, inferiors
   and core files.  */

/* Fill GDB's register array with the general-purpose register values
   in *GREGSETP.  */

void
supply_gregset (struct regcache *regcache, const elf_gregset_t *gregsetp)
{
  const gdb_byte *regp = (const gdb_byte *) gregsetp;
  int i;

  for (i = 0; i < I386_NUM_GREGS; i++)
    regcache_raw_supply (regcache, i,
			 regp + i386_linux_gregset_reg_offset[i]);

  if (I386_LINUX_ORIG_EAX_REGNUM
	< gdbarch_num_regs (get_regcache_arch (regcache)))
    regcache_raw_supply (regcache, I386_LINUX_ORIG_EAX_REGNUM, regp
			 + i386_linux_gregset_reg_offset[I386_LINUX_ORIG_EAX_REGNUM]);
}

/* Fill register REGNO (if it is a general-purpose register) in
   *GREGSETPS with the value in GDB's register array.  If REGNO is -1,
   do this for all registers.  */

void
fill_gregset (const struct regcache *regcache,
	      elf_gregset_t *gregsetp, int regno)
{
  gdb_byte *regp = (gdb_byte *) gregsetp;
  int i;

  for (i = 0; i < I386_NUM_GREGS; i++)
    if (regno == -1 || regno == i)
      regcache_raw_collect (regcache, i,
			    regp + i386_linux_gregset_reg_offset[i]);

  if ((regno == -1 || regno == I386_LINUX_ORIG_EAX_REGNUM)
      && I386_LINUX_ORIG_EAX_REGNUM
	   < gdbarch_num_regs (get_regcache_arch (regcache)))
    regcache_raw_collect (regcache, I386_LINUX_ORIG_EAX_REGNUM, regp
			  + i386_linux_gregset_reg_offset[I386_LINUX_ORIG_EAX_REGNUM]);
}

#ifdef HAVE_PTRACE_GETREGS

/* Fetch all general-purpose registers from process/thread TID and
   store their values in GDB's register array.  */

static void
fetch_regs (struct regcache *regcache, int tid)
{
  elf_gregset_t regs;
  elf_gregset_t *regs_p = &regs;

  if (ptrace (PTRACE_GETREGS, tid, 0, (int) &regs) < 0)
    {
      if (errno == EIO)
	{
	  /* The kernel we're running on doesn't support the GETREGS
             request.  Reset `have_ptrace_getregs'.  */
	  have_ptrace_getregs = 0;
	  return;
	}

      perror_with_name (_("Couldn't get registers"));
    }

  supply_gregset (regcache, (const elf_gregset_t *) regs_p);
}

/* Store all valid general-purpose registers in GDB's register array
   into the process/thread specified by TID.  */

static void
store_regs (const struct regcache *regcache, int tid, int regno)
{
  elf_gregset_t regs;

  if (ptrace (PTRACE_GETREGS, tid, 0, (int) &regs) < 0)
    perror_with_name (_("Couldn't get registers"));

  fill_gregset (regcache, &regs, regno);
  
  if (ptrace (PTRACE_SETREGS, tid, 0, (int) &regs) < 0)
    perror_with_name (_("Couldn't write registers"));
}

#else

static void fetch_regs (struct regcache *regcache, int tid) {}
static void store_regs (const struct regcache *regcache, int tid, int regno) {}

#endif


/* Transfering floating-point registers between GDB, inferiors and cores.  */

/* Fill GDB's register array with the floating-point register values in
   *FPREGSETP.  */

void 
supply_fpregset (struct regcache *regcache, const elf_fpregset_t *fpregsetp)
{
  i387_supply_fsave (regcache, -1, fpregsetp);
}

/* Fill register REGNO (if it is a floating-point register) in
   *FPREGSETP with the value in GDB's register array.  If REGNO is -1,
   do this for all registers.  */

void
fill_fpregset (const struct regcache *regcache,
	       elf_fpregset_t *fpregsetp, int regno)
{
  i387_collect_fsave (regcache, regno, fpregsetp);
}

#ifdef HAVE_PTRACE_GETREGS

/* Fetch all floating-point registers from process/thread TID and store
   thier values in GDB's register array.  */

static void
fetch_fpregs (struct regcache *regcache, int tid)
{
  elf_fpregset_t fpregs;

  if (ptrace (PTRACE_GETFPREGS, tid, 0, (int) &fpregs) < 0)
    perror_with_name (_("Couldn't get floating point status"));

  supply_fpregset (regcache, (const elf_fpregset_t *) &fpregs);
}

/* Store all valid floating-point registers in GDB's register array
   into the process/thread specified by TID.  */

static void
store_fpregs (const struct regcache *regcache, int tid, int regno)
{
  elf_fpregset_t fpregs;

  if (ptrace (PTRACE_GETFPREGS, tid, 0, (int) &fpregs) < 0)
    perror_with_name (_("Couldn't get floating point status"));

  fill_fpregset (regcache, &fpregs, regno);

  if (ptrace (PTRACE_SETFPREGS, tid, 0, (int) &fpregs) < 0)
    perror_with_name (_("Couldn't write floating point status"));
}

#else

static void
fetch_fpregs (struct regcache *regcache, int tid)
{
}

static void
store_fpregs (const struct regcache *regcache, int tid, int regno)
{
}

#endif


/* Transfering floating-point and SSE registers to and from GDB.  */

/* Fetch all registers covered by the PTRACE_GETREGSET request from
   process/thread TID and store their values in GDB's register array.
   Return non-zero if successful, zero otherwise.  */

static int
fetch_xstateregs (struct regcache *regcache, int tid)
{
  char xstateregs[I386_XSTATE_MAX_SIZE];
  struct iovec iov;

  if (!have_ptrace_getregset)
    return 0;

  iov.iov_base = xstateregs;
  iov.iov_len = sizeof(xstateregs);
  if (ptrace (PTRACE_GETREGSET, tid, (unsigned int) NT_X86_XSTATE,
	      &iov) < 0)
    perror_with_name (_("Couldn't read extended state status"));

  i387_supply_xsave (regcache, -1, xstateregs);
  return 1;
}

/* Store all valid registers in GDB's register array covered by the
   PTRACE_SETREGSET request into the process/thread specified by TID.
   Return non-zero if successful, zero otherwise.  */

static int
store_xstateregs (const struct regcache *regcache, int tid, int regno)
{
  char xstateregs[I386_XSTATE_MAX_SIZE];
  struct iovec iov;

  if (!have_ptrace_getregset)
    return 0;
  
  iov.iov_base = xstateregs;
  iov.iov_len = sizeof(xstateregs);
  if (ptrace (PTRACE_GETREGSET, tid, (unsigned int) NT_X86_XSTATE,
	      &iov) < 0)
    perror_with_name (_("Couldn't read extended state status"));

  i387_collect_xsave (regcache, regno, xstateregs, 0);

  if (ptrace (PTRACE_SETREGSET, tid, (unsigned int) NT_X86_XSTATE,
	      (int) &iov) < 0)
    perror_with_name (_("Couldn't write extended state status"));

  return 1;
}

#ifdef HAVE_PTRACE_GETFPXREGS

/* Fetch all registers covered by the PTRACE_GETFPXREGS request from
   process/thread TID and store their values in GDB's register array.
   Return non-zero if successful, zero otherwise.  */

static int
fetch_fpxregs (struct regcache *regcache, int tid)
{
  elf_fpxregset_t fpxregs;

  if (! have_ptrace_getfpxregs)
    return 0;

  if (ptrace (PTRACE_GETFPXREGS, tid, 0, (int) &fpxregs) < 0)
    {
      if (errno == EIO)
	{
	  have_ptrace_getfpxregs = 0;
	  return 0;
	}

      perror_with_name (_("Couldn't read floating-point and SSE registers"));
    }

  i387_supply_fxsave (regcache, -1, (const elf_fpxregset_t *) &fpxregs);
  return 1;
}

/* Store all valid registers in GDB's register array covered by the
   PTRACE_SETFPXREGS request into the process/thread specified by TID.
   Return non-zero if successful, zero otherwise.  */

static int
store_fpxregs (const struct regcache *regcache, int tid, int regno)
{
  elf_fpxregset_t fpxregs;

  if (! have_ptrace_getfpxregs)
    return 0;
  
  if (ptrace (PTRACE_GETFPXREGS, tid, 0, &fpxregs) == -1)
    {
      if (errno == EIO)
	{
	  have_ptrace_getfpxregs = 0;
	  return 0;
	}

      perror_with_name (_("Couldn't read floating-point and SSE registers"));
    }

  i387_collect_fxsave (regcache, regno, &fpxregs);

  if (ptrace (PTRACE_SETFPXREGS, tid, 0, &fpxregs) == -1)
    perror_with_name (_("Couldn't write floating-point and SSE registers"));

  return 1;
}

#else

static int
fetch_fpxregs (struct regcache *regcache, int tid)
{
  return 0;
}

static int
store_fpxregs (const struct regcache *regcache, int tid, int regno)
{
  return 0;
}

#endif /* HAVE_PTRACE_GETFPXREGS */


/* Transferring arbitrary registers between GDB and inferior.  */

/* Fetch register REGNO from the child process.  If REGNO is -1, do
   this for all registers (including the floating point and SSE
   registers).  */

static void
i386_linux_fetch_inferior_registers (struct target_ops *ops,
				     struct regcache *regcache, int regno)
{
  int tid;

  /* Use the old method of peeking around in `struct user' if the
     GETREGS request isn't available.  */
  if (!have_ptrace_getregs)
    {
      int i;

      for (i = 0; i < gdbarch_num_regs (get_regcache_arch (regcache)); i++)
	if (regno == -1 || regno == i)
	  fetch_register (regcache, i);

      return;
    }

  /* GNU/Linux LWP ID's are process ID's.  */
  tid = ptid_get_lwp (inferior_ptid);
  if (tid == 0)
    tid = ptid_get_pid (inferior_ptid); /* Not a threaded program.  */

  /* Use the PTRACE_GETFPXREGS request whenever possible, since it
     transfers more registers in one system call, and we'll cache the
     results.  But remember that fetch_fpxregs can fail, and return
     zero.  */
  if (regno == -1)
    {
      fetch_regs (regcache, tid);

      /* The call above might reset `have_ptrace_getregs'.  */
      if (!have_ptrace_getregs)
	{
	  i386_linux_fetch_inferior_registers (ops, regcache, regno);
	  return;
	}

      if (fetch_xstateregs (regcache, tid))
	return;
      if (fetch_fpxregs (regcache, tid))
	return;
      fetch_fpregs (regcache, tid);
      return;
    }

  if (GETREGS_SUPPLIES (regno))
    {
      fetch_regs (regcache, tid);
      return;
    }

  if (GETXSTATEREGS_SUPPLIES (regno))
    {
      if (fetch_xstateregs (regcache, tid))
	return;
    }

  if (GETFPXREGS_SUPPLIES (regno))
    {
      if (fetch_fpxregs (regcache, tid))
	return;

      /* Either our processor or our kernel doesn't support the SSE
	 registers, so read the FP registers in the traditional way,
	 and fill the SSE registers with dummy values.  It would be
	 more graceful to handle differences in the register set using
	 gdbarch.  Until then, this will at least make things work
	 plausibly.  */
      fetch_fpregs (regcache, tid);
      return;
    }

  internal_error (__FILE__, __LINE__,
		  _("Got request for bad register number %d."), regno);
}

/* Store register REGNO back into the child process.  If REGNO is -1,
   do this for all registers (including the floating point and SSE
   registers).  */
static void
i386_linux_store_inferior_registers (struct target_ops *ops,
				     struct regcache *regcache, int regno)
{
  int tid;

  /* Use the old method of poking around in `struct user' if the
     SETREGS request isn't available.  */
  if (!have_ptrace_getregs)
    {
      int i;

      for (i = 0; i < gdbarch_num_regs (get_regcache_arch (regcache)); i++)
	if (regno == -1 || regno == i)
	  store_register (regcache, i);

      return;
    }

  /* GNU/Linux LWP ID's are process ID's.  */
  tid = ptid_get_lwp (inferior_ptid);
  if (tid == 0)
    tid = ptid_get_pid (inferior_ptid); /* Not a threaded program.  */

  /* Use the PTRACE_SETFPXREGS requests whenever possible, since it
     transfers more registers in one system call.  But remember that
     store_fpxregs can fail, and return zero.  */
  if (regno == -1)
    {
      store_regs (regcache, tid, regno);
      if (store_xstateregs (regcache, tid, regno))
	return;
      if (store_fpxregs (regcache, tid, regno))
	return;
      store_fpregs (regcache, tid, regno);
      return;
    }

  if (GETREGS_SUPPLIES (regno))
    {
      store_regs (regcache, tid, regno);
      return;
    }

  if (GETXSTATEREGS_SUPPLIES (regno))
    {
      if (store_xstateregs (regcache, tid, regno))
	return;
    }

  if (GETFPXREGS_SUPPLIES (regno))
    {
      if (store_fpxregs (regcache, tid, regno))
	return;

      /* Either our processor or our kernel doesn't support the SSE
	 registers, so just write the FP registers in the traditional
	 way.  */
      store_fpregs (regcache, tid, regno);
      return;
    }

  internal_error (__FILE__, __LINE__,
		  _("Got request to store bad register number %d."), regno);
}


/* Support for debug registers.  */

/* Get debug register REGNUM value from only the one LWP of PTID.  */

static unsigned long
i386_linux_dr_get (ptid_t ptid, int regnum)
{
  int tid;
  unsigned long value;

  tid = ptid_get_lwp (ptid);
  if (tid == 0)
    tid = ptid_get_pid (ptid);

  errno = 0;
  value = ptrace (PTRACE_PEEKUSER, tid,
		  offsetof (struct user, u_debugreg[regnum]), 0);
  if (errno != 0)
    perror_with_name (_("Couldn't read debug register"));

  return value;
}

/* Set debug register REGNUM to VALUE in only the one LWP of PTID.  */

static void
i386_linux_dr_set (ptid_t ptid, int regnum, unsigned long value)
{
  int tid;

  tid = ptid_get_lwp (ptid);
  if (tid == 0)
    tid = ptid_get_pid (ptid);

  errno = 0;
  ptrace (PTRACE_POKEUSER, tid,
	  offsetof (struct user, u_debugreg[regnum]), value);
  if (errno != 0)
    perror_with_name (_("Couldn't write debug register"));
}

/* Return the inferior's debug register REGNUM.  */

static CORE_ADDR
i386_linux_dr_get_addr (int regnum)
{
  /* DR6 and DR7 are retrieved with some other way.  */
  gdb_assert (DR_FIRSTADDR <= regnum && regnum <= DR_LASTADDR);

  return i386_linux_dr_get (inferior_ptid, regnum);
}

/* Return the inferior's DR7 debug control register.  */

static unsigned long
i386_linux_dr_get_control (void)
{
  return i386_linux_dr_get (inferior_ptid, DR_CONTROL);
}

/* Get DR_STATUS from only the one LWP of INFERIOR_PTID.  */

static unsigned long
i386_linux_dr_get_status (void)
{
  return i386_linux_dr_get (inferior_ptid, DR_STATUS);
}

/* Callback for iterate_over_lwps.  Update the debug registers of
   LWP.  */

static int
update_debug_registers_callback (struct lwp_info *lwp, void *arg)
{
  if (lwp->arch_private == NULL)
    lwp->arch_private = XCNEW (struct arch_lwp_info);

  /* The actual update is done later just before resuming the lwp, we
     just mark that the registers need updating.  */
  lwp->arch_private->debug_registers_changed = 1;

  /* If the lwp isn't stopped, force it to momentarily pause, so we
     can update its debug registers.  */
  if (!lwp->stopped)
    linux_stop_lwp (lwp);

  /* Continue the iteration.  */
  return 0;
}

/* Set DR_CONTROL to ADDR in all LWPs of the current inferior.  */

static void
i386_linux_dr_set_control (unsigned long control)
{
  ptid_t pid_ptid = pid_to_ptid (ptid_get_pid (inferior_ptid));

  iterate_over_lwps (pid_ptid, update_debug_registers_callback, NULL);
}

/* Set address REGNUM (zero based) to ADDR in all LWPs of the current
   inferior.  */

static void
i386_linux_dr_set_addr (int regnum, CORE_ADDR addr)
{
  ptid_t pid_ptid = pid_to_ptid (ptid_get_pid (inferior_ptid));

  gdb_assert (regnum >= 0 && regnum <= DR_LASTADDR - DR_FIRSTADDR);

  iterate_over_lwps (pid_ptid, update_debug_registers_callback, NULL);
}

/* Called when resuming a thread.
   If the debug regs have changed, update the thread's copies.  */

static void
i386_linux_prepare_to_resume (struct lwp_info *lwp)
{
  int clear_status = 0;

  /* NULL means this is the main thread still going through the shell,
     or, no watchpoint has been set yet.  In that case, there's
     nothing to do.  */
  if (lwp->arch_private == NULL)
    return;

  if (lwp->arch_private->debug_registers_changed)
    {
      struct i386_debug_reg_state *state
	= i386_debug_reg_state (ptid_get_pid (lwp->ptid));
      int i;

      /* See amd64_linux_prepare_to_resume for Linux kernel note on
	 i386_linux_dr_set calls ordering.  */

      for (i = DR_FIRSTADDR; i <= DR_LASTADDR; i++)
	if (state->dr_ref_count[i] > 0)
	  {
	    i386_linux_dr_set (lwp->ptid, i, state->dr_mirror[i]);

	    /* If we're setting a watchpoint, any change the inferior
	       had done itself to the debug registers needs to be
	       discarded, otherwise, i386_stopped_data_address can get
	       confused.  */
	    clear_status = 1;
	  }

      i386_linux_dr_set (lwp->ptid, DR_CONTROL, state->dr_control_mirror);

      lwp->arch_private->debug_registers_changed = 0;
    }

  if (clear_status || lwp->stopped_by_watchpoint)
    i386_linux_dr_set (lwp->ptid, DR_STATUS, 0);
}

static void
i386_linux_new_thread (struct lwp_info *lp)
{
  struct arch_lwp_info *info = XCNEW (struct arch_lwp_info);

  info->debug_registers_changed = 1;

  lp->arch_private = info;
}

/* linux_nat_new_fork hook.   */

static void
i386_linux_new_fork (struct lwp_info *parent, pid_t child_pid)
{
  pid_t parent_pid;
  struct i386_debug_reg_state *parent_state;
  struct i386_debug_reg_state *child_state;

  /* NULL means no watchpoint has ever been set in the parent.  In
     that case, there's nothing to do.  */
  if (parent->arch_private == NULL)
    return;

  /* Linux kernel before 2.6.33 commit
     72f674d203cd230426437cdcf7dd6f681dad8b0d
     will inherit hardware debug registers from parent
     on fork/vfork/clone.  Newer Linux kernels create such tasks with
     zeroed debug registers.

     GDB core assumes the child inherits the watchpoints/hw
     breakpoints of the parent, and will remove them all from the
     forked off process.  Copy the debug registers mirrors into the
     new process so that all breakpoints and watchpoints can be
     removed together.  The debug registers mirror will become zeroed
     in the end before detaching the forked off process, thus making
     this compatible with older Linux kernels too.  */

  parent_pid = ptid_get_pid (parent->ptid);
  parent_state = i386_debug_reg_state (parent_pid);
  child_state = i386_debug_reg_state (child_pid);
  *child_state = *parent_state;
}



/* Called by libthread_db.  Returns a pointer to the thread local
   storage (or its descriptor).  */

ps_err_e
ps_get_thread_area (const struct ps_prochandle *ph, 
		    lwpid_t lwpid, int idx, void **base)
{
  /* NOTE: cagney/2003-08-26: The definition of this buffer is found
     in the kernel header <asm-i386/ldt.h>.  It, after padding, is 4 x
     4 byte integers in size: `entry_number', `base_addr', `limit',
     and a bunch of status bits.

     The values returned by this ptrace call should be part of the
     regcache buffer, and ps_get_thread_area should channel its
     request through the regcache.  That way remote targets could
     provide the value using the remote protocol and not this direct
     call.

     Is this function needed?  I'm guessing that the `base' is the
     address of a descriptor that libthread_db uses to find the
     thread local address base that GDB needs.  Perhaps that
     descriptor is defined by the ABI.  Anyway, given that
     libthread_db calls this function without prompting (gdb
     requesting tls base) I guess it needs info in there anyway.  */
  unsigned int desc[4];
  gdb_assert (sizeof (int) == 4);

#ifndef PTRACE_GET_THREAD_AREA
#define PTRACE_GET_THREAD_AREA 25
#endif

  if (ptrace (PTRACE_GET_THREAD_AREA, lwpid,
	      (void *) idx, (unsigned long) &desc) < 0)
    return PS_ERR;

  *(int *)base = desc[1];
  return PS_OK;
}


/* The instruction for a GNU/Linux system call is:
       int $0x80
   or 0xcd 0x80.  */

static const unsigned char linux_syscall[] = { 0xcd, 0x80 };

#define LINUX_SYSCALL_LEN (sizeof linux_syscall)

/* The system call number is stored in the %eax register.  */
#define LINUX_SYSCALL_REGNUM I386_EAX_REGNUM

/* We are specifically interested in the sigreturn and rt_sigreturn
   system calls.  */

#ifndef SYS_sigreturn
#define SYS_sigreturn		0x77
#endif
#ifndef SYS_rt_sigreturn
#define SYS_rt_sigreturn	0xad
#endif

/* Offset to saved processor flags, from <asm/sigcontext.h>.  */
#define LINUX_SIGCONTEXT_EFLAGS_OFFSET (64)

/* Resume execution of the inferior process.
   If STEP is nonzero, single-step it.
   If SIGNAL is nonzero, give it that signal.  */

static void
i386_linux_resume (struct target_ops *ops,
		   ptid_t ptid, int step, enum gdb_signal signal)
{
  int pid = ptid_get_pid (ptid);

  int request;

  if (catch_syscall_enabled () > 0)
   request = PTRACE_SYSCALL;
  else
    request = PTRACE_CONT;

  if (step)
    {
      struct regcache *regcache = get_thread_regcache (pid_to_ptid (pid));
      struct gdbarch *gdbarch = get_regcache_arch (regcache);
      enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
      ULONGEST pc;
      gdb_byte buf[LINUX_SYSCALL_LEN];

      request = PTRACE_SINGLESTEP;

      regcache_cooked_read_unsigned (regcache,
				     gdbarch_pc_regnum (gdbarch), &pc);

      /* Returning from a signal trampoline is done by calling a
         special system call (sigreturn or rt_sigreturn, see
         i386-linux-tdep.c for more information).  This system call
         restores the registers that were saved when the signal was
         raised, including %eflags.  That means that single-stepping
         won't work.  Instead, we'll have to modify the signal context
         that's about to be restored, and set the trace flag there.  */

      /* First check if PC is at a system call.  */
      if (target_read_memory (pc, buf, LINUX_SYSCALL_LEN) == 0
	  && memcmp (buf, linux_syscall, LINUX_SYSCALL_LEN) == 0)
	{
	  ULONGEST syscall;
	  regcache_cooked_read_unsigned (regcache,
					 LINUX_SYSCALL_REGNUM, &syscall);

	  /* Then check the system call number.  */
	  if (syscall == SYS_sigreturn || syscall == SYS_rt_sigreturn)
	    {
	      ULONGEST sp, addr;
	      unsigned long int eflags;

	      regcache_cooked_read_unsigned (regcache, I386_ESP_REGNUM, &sp);
	      if (syscall == SYS_rt_sigreturn)
		addr = read_memory_unsigned_integer (sp + 8, 4, byte_order)
		  + 20;
	      else
		addr = sp;

	      /* Set the trace flag in the context that's about to be
                 restored.  */
	      addr += LINUX_SIGCONTEXT_EFLAGS_OFFSET;
	      read_memory (addr, (gdb_byte *) &eflags, 4);
	      eflags |= 0x0100;
	      write_memory (addr, (gdb_byte *) &eflags, 4);
	    }
	}
    }

  if (ptrace (request, pid, 0, gdb_signal_to_host (signal)) == -1)
    perror_with_name (("ptrace"));
}

static void (*super_post_startup_inferior) (ptid_t ptid);

static void
i386_linux_child_post_startup_inferior (ptid_t ptid)
{
  i386_cleanup_dregs ();
  super_post_startup_inferior (ptid);
}

/* Get Linux/x86 target description from running target.  */

static const struct target_desc *
i386_linux_read_description (struct target_ops *ops)
{
  int tid;
  static uint64_t xcr0;

  /* GNU/Linux LWP ID's are process ID's.  */
  tid = ptid_get_lwp (inferior_ptid);
  if (tid == 0)
    tid = ptid_get_pid (inferior_ptid); /* Not a threaded program.  */

#ifdef HAVE_PTRACE_GETFPXREGS
  if (have_ptrace_getfpxregs == -1)
    {
      elf_fpxregset_t fpxregs;

      if (ptrace (PTRACE_GETFPXREGS, tid, 0, (int) &fpxregs) < 0)
	{
	  have_ptrace_getfpxregs = 0;
	  have_ptrace_getregset = 0;
	  return tdesc_i386_mmx_linux;
	}
    }
#endif

  if (have_ptrace_getregset == -1)
    {
      uint64_t xstateregs[(I386_XSTATE_SSE_SIZE / sizeof (uint64_t))];
      struct iovec iov;

      iov.iov_base = xstateregs;
      iov.iov_len = sizeof (xstateregs);

      /* Check if PTRACE_GETREGSET works.  */
      if (ptrace (PTRACE_GETREGSET, tid, (unsigned int) NT_X86_XSTATE,
		  &iov) < 0)
	have_ptrace_getregset = 0;
      else
	{
	  have_ptrace_getregset = 1;

	  /* Get XCR0 from XSAVE extended state.  */
	  xcr0 = xstateregs[(I386_LINUX_XSAVE_XCR0_OFFSET
			     / sizeof (long long))];
	}
    }

  /* Check the native XCR0 only if PTRACE_GETREGSET is available.  */
  if (have_ptrace_getregset
      && (xcr0 & I386_XSTATE_AVX_MASK) == I386_XSTATE_AVX_MASK)
    return tdesc_i386_avx_linux;
  else
    return tdesc_i386_linux;
}

/* Enable branch tracing.  */

static struct btrace_target_info *
i386_linux_enable_btrace (ptid_t ptid)
{
  struct btrace_target_info *tinfo;
  struct gdbarch *gdbarch;

  errno = 0;
  tinfo = linux_enable_btrace (ptid);

  if (tinfo == NULL)
    error (_("Could not enable branch tracing for %s: %s."),
	   target_pid_to_str (ptid), safe_strerror (errno));

  /* Fill in the size of a pointer in bits.  */
  gdbarch = target_thread_architecture (ptid);
  tinfo->ptr_bits = gdbarch_ptr_bit (gdbarch);

  return tinfo;
}

/* Disable branch tracing.  */

static void
i386_linux_disable_btrace (struct btrace_target_info *tinfo)
{
  int errcode = linux_disable_btrace (tinfo);

  if (errcode != 0)
    error (_("Could not disable branch tracing: %s."), safe_strerror (errcode));
}

/* Teardown branch tracing.  */

static void
i386_linux_teardown_btrace (struct btrace_target_info *tinfo)
{
  /* Ignore errors.  */
  linux_disable_btrace (tinfo);
}

/* -Wmissing-prototypes */
extern initialize_file_ftype _initialize_i386_linux_nat;

void
_initialize_i386_linux_nat (void)
{
  struct target_ops *t;

  /* Fill in the generic GNU/Linux methods.  */
  t = linux_target ();

  i386_use_watchpoints (t);

  i386_dr_low.set_control = i386_linux_dr_set_control;
  i386_dr_low.set_addr = i386_linux_dr_set_addr;
  i386_dr_low.get_addr = i386_linux_dr_get_addr;
  i386_dr_low.get_status = i386_linux_dr_get_status;
  i386_dr_low.get_control = i386_linux_dr_get_control;
  i386_set_debug_register_length (4);

  /* Override the default ptrace resume method.  */
  t->to_resume = i386_linux_resume;

  /* Override the GNU/Linux inferior startup hook.  */
  super_post_startup_inferior = t->to_post_startup_inferior;
  t->to_post_startup_inferior = i386_linux_child_post_startup_inferior;

  /* Add our register access methods.  */
  t->to_fetch_registers = i386_linux_fetch_inferior_registers;
  t->to_store_registers = i386_linux_store_inferior_registers;

  t->to_read_description = i386_linux_read_description;

  /* Add btrace methods.  */
  t->to_supports_btrace = linux_supports_btrace;
  t->to_enable_btrace = i386_linux_enable_btrace;
  t->to_disable_btrace = i386_linux_disable_btrace;
  t->to_teardown_btrace = i386_linux_teardown_btrace;
  t->to_read_btrace = linux_read_btrace;

  /* Register the target.  */
  linux_nat_add_target (t);
  linux_nat_set_new_thread (t, i386_linux_new_thread);
  linux_nat_set_new_fork (t, i386_linux_new_fork);
  linux_nat_set_forget_process (t, i386_forget_process);
  linux_nat_set_prepare_to_resume (t, i386_linux_prepare_to_resume);
}
@


1.116
log
@Install the btrace target ops for i386-linux-nat and amd64-linux-nat.

gdb/
	* amd64-linux-nat.c: Include btrace.h and linux-btrace.h.
	(amd64_linux_enable_btrace): New.
	(amd64_linux_disable_btrace): New.
	(amd64_linux_teardown_btrace): New.
	(_initialize_amd64_linux_nat): Initialize btrace ops.
	* i386-linux.nat.c: Include btrace.h and linux-btrace.h.
	(i386_linux_enable_btrace): New.
	(i386_linux_disable_btrace): New.
	(i386_linux_teardown_btrace): New.
	(_initialize_i386_linux_nat): Initialize btrace ops.
	* config/i386/linux.mh: Add linux-btrace.o.
	* config/i386/linux64.mh: Add linux-btrace.o.
@
text
@d151 1
a151 1
  tid = TIDGET (inferior_ptid);
d153 1
a153 1
    tid = PIDGET (inferior_ptid); /* Not a threaded program.  */
d179 1
a179 1
  tid = TIDGET (inferior_ptid);
d181 1
a181 1
    tid = PIDGET (inferior_ptid); /* Not a threaded program.  */
d517 1
a517 1
  tid = TIDGET (inferior_ptid);
d519 1
a519 1
    tid = PIDGET (inferior_ptid); /* Not a threaded program.  */
d598 1
a598 1
  tid = TIDGET (inferior_ptid);
d600 1
a600 1
    tid = PIDGET (inferior_ptid); /* Not a threaded program.  */
d655 1
a655 1
  tid = TIDGET (ptid);
d657 1
a657 1
    tid = PIDGET (ptid);
d675 1
a675 1
  tid = TIDGET (ptid);
d677 1
a677 1
    tid = PIDGET (ptid);
d920 1
a920 1
  int pid = PIDGET (ptid);
d1003 1
a1003 1
  tid = TIDGET (inferior_ptid);
d1005 1
a1005 1
    tid = PIDGET (inferior_ptid); /* Not a threaded program.  */
@


1.115
log
@[native x86 GNU/Linux] Access debug register mirror from the corresponding process.

While reviewing the native AArch64 patch, I noticed a problem:

On 02/06/2013 08:46 PM, Pedro Alves wrote:
>
>> > +static void
>> > +aarch64_linux_prepare_to_resume (struct lwp_info *lwp)
>> > +{
>> > +  struct arch_lwp_info *info = lwp->arch_private;
>> > +
>> > +  /* NULL means this is the main thread still going through the shell,
>> > +     or, no watchpoint has been set yet.  In that case, there's
>> > +     nothing to do.  */
>> > +  if (info == NULL)
>> > +    return;
>> > +
>> > +  if (DR_HAS_CHANGED (info->dr_changed_bp)
>> > +      || DR_HAS_CHANGED (info->dr_changed_wp))
>> > +    {
>> > +      int tid = GET_LWP (lwp->ptid);
>> > +      struct aarch64_debug_reg_state *state = aarch64_get_debug_reg_state ();
> Hmm.  This is always fetching the debug_reg_state of
> the current inferior, but may not be the inferior of lwp.
> I see the same bug on x86.  Sorry about that.  I'll fix it.

A natural fix would be to make xxx_get_debug_reg_state take an
inferior argument, but that doesn't work because of the case where we
detach breakpoints/watchpoints from the child fork, at a time there's
no inferior for the child fork at all.  We do a nasty hack in
i386_inferior_data_get, but that relies on all callers pointing the
current inferior to the correct inferior, which isn't actually being
done by all callers, and I don't think we want to enforce that -- deep
in the bowls of linux-nat.c, there are many cases we resume lwps
behind the scenes, and it's be better to not have that code rely on
global state (as it doesn't today).

The fix is to decouple the watchpoints code from inferiors, making it
track target processes instead.  This way, we can freely keep track of
the watchpoint mirrors for these processes behind the core's back.
Checkpoints also play dirty tricks with swapping the process behind
the inferior, so they get special treatment too in the patch (which
just amounts to calling a new hook).  Instead of the old hack in
i386_inferior_data_get, where we returned a copy of the current
inferior's debug registers mirror, as soon as we detect a fork in the
target, we copy the debug register mirror from the parent to the child
process.

I don't have an old kernel handy to test, but I stepped through gdb doing
the watchpoint removal in the fork child in the watchpoint-fork test
seeing that the debug registers end up cleared in the child.

I didn't find the need for linux_nat_iterate_watchpoint_lwps.  If
we use plain iterate_over_lwps instead, what happens is that
when removing watchpoints, that iterate_over_lwps doesn't actually
iterate over anything, since the fork child is not added to the
lwp list until later, at detach time, in linux_child_follow_fork.
And if we don't iterate over that lwp, we don't mark its debug
registers as needing update.  But linux_child_follow_fork takes
care of doing that explicitly:

	  child_lp = add_lwp (inferior_ptid);
	  child_lp->stopped = 1;
	  child_lp->last_resume_kind = resume_stop;
	  make_cleanup (delete_lwp_cleanup, child_lp);

	  /* CHILD_LP has new PID, therefore linux_nat_new_thread is not called for it.
	     See i386_inferior_data_get for the Linux kernel specifics.
	     Ensure linux_nat_prepare_to_resume will reset the hardware debug
	     registers.  It is done by the linux_nat_new_thread call, which is
	     being skipped in add_lwp above for the first lwp of a pid.  */
	  gdb_assert (num_lwps (GET_PID (child_lp->ptid)) == 1);
	  if (linux_nat_new_thread != NULL)
	    linux_nat_new_thread (child_lp);

	  if (linux_nat_prepare_to_resume != NULL)
	    linux_nat_prepare_to_resume (child_lp);
	  ptrace (PTRACE_DETACH, child_pid, 0, 0);

so unless I'm missing something (quite possible) it ends up all
the same.  But, the !detach-on-fork, and the "follow-fork child" paths
should also call linux_nat_new_thread, and they don't presently.  It
seems to me in those cases we're not clearing debug regs correctly
when that's needed.  Instead of copying that bit that works around
add_lwp bypassing the linux_nat_new_thread call, I thought it'd
be better to add an add_initial_lwp call to be used in the case we
really need to bypass linux_nat_new_thread, and make
add_lwp always call linux_nat_new_thread.

i386_cleanup_dregs is rewritten to forget about the current process
debug mirrors, which takes cares of other i386 ports.  Only a couple
of extra tweaks here and there were needed, as some targets wheren't
actually calling i386_cleanup_dregs.

Tested on Fedora 17 x86_64 -m64/-m32.

GDBserver already fetches the i386_debug_reg_state from the right
process, and, it doesn't handle forks at all, so no fix is needed over
there.

gdb/
2013-02-13  Pedro Alves  <palves@@redhat.com>

	* amd64-linux-nat.c (update_debug_registers_callback):
	Update comment.
	(amd64_linux_dr_set_control, amd64_linux_dr_set_addr): Use
	iterate_over_lwps.
	(amd64_linux_prepare_to_resume): Pass the lwp's pid to
	i386_debug_reg_state.
	(amd64_linux_new_fork): New function.
	(_initialize_amd64_linux_nat): Install amd64_linux_new_fork as
	linux_nat_new_fork hook, and i386_forget_process as
	linux_nat_forget_process hook.
	* i386-linux-nat.c (update_debug_registers_callback):
	Update comment.
	(amd64_linux_dr_set_control, amd64_linux_dr_set_addr): Use
	iterate_over_lwps.
	(i386_linux_prepare_to_resume): Pass the lwp's pid to
	i386_debug_reg_state.
	(i386_linux_new_fork): New function.
	(_initialize_i386_linux_nat): Install i386_linux_new_fork as
	linux_nat_new_fork hook, and i386_forget_process as
	linux_nat_forget_process hook.
	* i386-nat.c (i386_init_dregs): Delete.
	(i386_inferior_data, struct i386_inferior_data):
	Delete.
	(struct i386_process_info): New.
	(i386_process_list): New global.
	(i386_find_process_pid, i386_add_process, i386_process_info_get):
	New functions.
	(i386_inferior_data_get): Delete.
	(i386_process_info_get): New function.
	(i386_debug_reg_state): New parameter 'pid'.  Reimplement.
	(i386_forget_process): New function.
	(i386_cleanup_dregs): Rewrite.
	(i386_update_inferior_debug_regs, i386_insert_watchpoint)
	(i386_remove_watchpoint, i386_region_ok_for_watchpoint)
	(i386_stopped_data_address, i386_insert_hw_breakpoint)
	(i386_remove_hw_breakpoint): Adjust to pass the current process id
	to i386_debug_reg_state.
	(i386_use_watchpoints): Don't register inferior data.
	* i386-nat.h (i386_debug_reg_state): Add new 'pid' parameter, and
	adjust comment.
	(i386_forget_process): Declare.
	* linux-fork.c (delete_fork): Call linux_nat_forget_process.
	* linux-nat.c (linux_nat_new_fork, linux_nat_forget_process_hook):
	New static globals.
	(linux_child_follow_fork): Don't call linux_nat_new_thread here.
	(add_initial_lwp): New, factored out from ...
	(add_lwp): ... this.  Don't check the number of lwps before
	calling linux_nat_new_thread.
	(linux_nat_iterate_watchpoint_lwps): Delete.
	(linux_nat_attach): Use add_initial_lwp instead of add_lwp.
	(linux_handle_extended_wait): Call the linux_nat_new_fork hook on
	forks and vforks.
	(linux_nat_wait_1): Use add_initial_lwp instead of add_lwp for the
	initial lwp.
	(linux_nat_kill, linux_nat_mourn_inferior): Call
	linux_nat_forget_process.
	(linux_nat_set_new_fork, linux_nat_set_forget_process)
	(linux_nat_forget_process): New functions.
	* linux-nat.h (linux_nat_iterate_watchpoint_lwps_ftype): Delete
	type.
	(linux_nat_iterate_watchpoint_lwps): Delete declaration.
	(linux_nat_new_fork_ftype, linux_nat_forget_process_ftype): New
	types.
	(linux_nat_set_new_fork, linux_nat_set_forget_process)
	(linux_nat_forget_process): New declarations.

	* amd64fbsd-nat.c (super_mourn_inferior): New global.
	(amd64fbsd_mourn_inferior): New function.
	(_initialize_amd64fbsd_nat): Override to_mourn_inferior.
	* windows-nat.c (windows_detach): Call i386_cleanup_dregs.
@
text
@d28 2
d1051 42
d1126 7
@


1.114
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d711 2
a712 2
/* Callback for linux_nat_iterate_watchpoint_lwps.  Update the debug registers
   of LWP.  */
d738 3
a740 1
  linux_nat_iterate_watchpoint_lwps (update_debug_registers_callback, NULL);
d753 1
a753 1
  linux_nat_iterate_watchpoint_lwps (update_debug_registers_callback, NULL);
d772 2
a773 1
      struct i386_debug_reg_state *state = i386_debug_reg_state ();
d809 35
d1085 2
@


1.113
log
@gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.

gdb/gdbserver/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.

include/gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.

sim/common/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.
@
text
@d3 1
a3 1
   Copyright (C) 1999-2012 Free Software Foundation, Inc.
@


1.112
log
@gdb/
	Fix -Wmissing-prototypes build.
	* charset.c (phony_iconv_open): Make static.
	(phony_iconv_close, phony_iconv): Likewise.
	* i386-linux-nat.c (_initialize_i386_linux_nat): New prototype.
	* i386-windows-nat.c (_initialize_i386_windows_nat): New
	prototype.
	* mingw-hdep.c (_initialize_mingw_hdep): New prototype.
	* ser-mingw.c (create_select_thread): Make static.
	* windows-termcap.c (tgetent): New prototype.
	(tgetnum, tgetflag, tgetstr, tputs, tgoto): Likewise.
@
text
@d878 1
a878 1
		   ptid_t ptid, int step, enum target_signal signal)
d941 1
a941 1
  if (ptrace (request, pid, 0, target_signal_to_host (signal)) == -1)
@


1.111
log
@gdb/
	Fix watchpoints across inferior fork.
	* amd64-linux-nat.c (update_debug_registers_callback): Update the
	comment for linux_nat_iterate_watchpoint_lwps.
	(amd64_linux_dr_set_control, amd64_linux_dr_set_addr): Use
	linux_nat_iterate_watchpoint_lwps.
	(amd64_linux_prepare_to_resume): New comment on Linux kernel.
	* i386-linux-nat.c (update_debug_registers_callback): Update the
	comment for linux_nat_iterate_watchpoint_lwps.
	(i386_linux_dr_set_control, i386_linux_dr_set_addr): Use
	linux_nat_iterate_watchpoint_lwps.
	(i386_linux_prepare_to_resume): New comment on Linux kernel.
	* i386-nat.c: Include inferior.h.
	(dr_mirror): Remove.
	(i386_inferior_data, struct i386_inferior_data)
	(i386_inferior_data_get): New.
	(i386_debug_reg_state): Use i386_inferior_data_get.
	(i386_cleanup_dregs, i386_update_inferior_debug_regs)
	(i386_insert_watchpoint, i386_remove_watchpoint)
	(i386_stopped_data_address, i386_insert_hw_breakpoint)
	(i386_remove_hw_breakpoint): New variable state, use
	i386_debug_reg_state instead of DR_MIRROR.
	* linux-nat.c (delete_lwp): New declaration.
	(num_lwps): Move here from downwards.
	(delete_lwp_cleanup): New.
	(linux_child_follow_fork): Create new child_lp, call
	linux_nat_new_thread and linux_nat_prepare_to_resume before calling
	PTRACE_DETACH.
	(num_lwps): Move upwards.
	(linux_nat_iterate_watchpoint_lwps): New.
	* linux-nat.h (linux_nat_iterate_watchpoint_lwps_ftype): New.
	(linux_nat_iterate_watchpoint_lwps_ftype): New declaration.

gdb/testsuite/
	Fix watchpoints across inferior fork.
	* gdb.threads/watchpoint-fork-child.c: New file.
	* gdb.threads/watchpoint-fork-mt.c: New file.
	* gdb.threads/watchpoint-fork-parent.c: New file.
	* gdb.threads/watchpoint-fork-st.c: New file.
	* gdb.threads/watchpoint-fork.exp: New file.
	* gdb.threads/watchpoint-fork.h: New file.
@
text
@d1011 3
@


1.110
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d711 2
a712 2
/* Callback for iterate_over_lwps.  Update the debug registers of
   LWP.  */
d738 1
a738 3
  ptid_t pid_ptid = pid_to_ptid (ptid_get_pid (inferior_ptid));

  iterate_over_lwps (pid_ptid, update_debug_registers_callback, NULL);
d751 1
a751 1
  iterate_over_lwps (pid_ptid, update_debug_registers_callback, NULL);
d773 3
@


1.109
log
@gdb/
	* amd64-linux-nat.c (update_debug_registers_callback): New comment on
	the return value.
	* i386-linux-nat.c (update_debug_registers_callback): Likewise.
@
text
@d3 1
a3 2
   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
   2009, 2010, 2011 Free Software Foundation, Inc.
@


1.108
log
@2011-12-20  Pedro Alves  <alves.ped@@gmail.com>
	    Jan Kratochvil  <jan.kratochvil@@redhat.com>

        * linux-nat.c (add_lwp): Don't call linux_nat_new_thread on the
	first LWP.
	* amd64-linux-nat.c (update_debug_registers_callback): Instantiate
	`lwp->arch_private' if NULL.
	(amd64_linux_prepare_to_resume): Do nothing if `lwp->arch_private'
	is NULL.
	* i386-linux-nat.c (update_debug_registers_callback): Instantiate
	`lwp->arch_private' if NULL.
	(i386_linux_prepare_to_resume): Do nothing if `lwp->arch_private'
	is NULL.
@
text
@d730 1
@


1.107
log
@gdb/
2011-12-14  Pedro Alves  <pedro@@codesourcery.com>

	PR threads/10729

	* linux-nat.c (linux_nat_new_thread): Change parameter to an lwp
	pointer.
	(linux_nat_prepare_to_resume): New global.
	(lwp_free): New.
	(purge_lwp_list): Use it.
	(add_lwp): Call linux_nat_new_thread even on the first LWP.
	Adjust to interface change.
	(delete_lwp): Call lwp_free instead of xfree.
	(detach_callback, linux_nat_detach, resume_lwp, linux_nat_resume)
	(linux_handle_syscall_trap, linux_handle_extended_wait)
	(linux_nat_filter_event, resume_stopped_resumed_lwps): Call
	linux_nat_prepare_to_resume before resuming.
	(linux_stop_lwp): New.
	(linux_nat_set_new_thread): Adjust.
	(linux_nat_set_prepare_to_resume): New.
	* linux-nat.h (struct arch_lwp_info): Forward declare.
	(struct lwp_info) <arch_private>: New field.
	(linux_stop_lwp): Declare.
	(linux_nat_set_new_thread): Adjust.
	(linux_nat_set_prepare_to_resume): New.

	* i386-nat.c (DR_NADDR, DR_STATUS, DR_CONTROL)
	(struct i386_debug_reg_state): Move to i386-nat.h.
	(dr_mirror): Comment.
	(i386_debug_reg_state): New.
	(i386_update_inferior_debug_regs): Simplify.
	(i386_stopped_data_address): Use the debug register state from the
	inferior, not from the local cache.
	* i386-nat.h (struct i386_dr_low_type): Delete reset_addr and
	unset_status fields.  New get_addr and get_control fields.
	(DR_FIRSTADDR, DR_LASTADDR, DR_CONTROL): Moved from i386-nat.c.
	(DR_NADDR, DR_STATUS): New.
	(struct i386_debug_reg_state): Moved from i386-nat.c.

	* amd64-linux-nat.c (struct arch_lwp_info): New.
	(amd64_linux_dr): Delete global.
	(amd64_linux_dr_get_addr): New.
	(amd64_linux_dr_get_control): New.
	(amd64_linux_dr_unset_status): Delete.
	(amd64_linux_dr_set_addr): Reimplement.
	(amd64_linux_dr_reset_addr): Delete.
	(update_debug_registers_callback): New.
	(amd64_linux_dr_set_control): Reimplement.
	(amd64_linux_dr_set_addr): Reimplement.
	(amd64_linux_prepare_to_resume): New.
	(amd64_linux_new_thread): Change parameter to an lwp pointer.
	Reimplement.
	(_initialize_amd64_linux_nat): No longer install
	i386_dr_low.reset_addr and i386_dr_low.unset_status.  Install
	amd64_linux_dr_get_control as i386_dr_low.get_control.  Install
	amd64_linux_dr_get_addr as i386_dr_low.get_addr.  Install
	amd64_linux_prepare_to_resume.
	* i386-linux-nat.c (DR_FIRSTADDR, DR_LASTADDR, DR_STATUS)
	(DR_CONTROL): Delete.
	(struct arch_lwp_info): New.
	(i386_linux_dr): Delete global.
	(i386_linux_dr_set_control): Reimplement.
	(i386_linux_dr_get_addr): New.
	(i386_linux_dr_set_addr): Reimplement.
	(i386_linux_dr_get_control): New.
	(update_debug_registers_callback): New.
	(i386_linux_dr_unset_status): Delete.
	(i386_linux_dr_set_addr): Reimplement.
	(i386_linux_prepare_to_resume): New.
	(i386_linux_new_thread): Change parameter to an lwp pointer.
	Reimplement.
	(_initialize_i386_linux_nat): No longer install
	i386_dr_low.reset_addr and i386_dr_low.unset_status.  Install
	i386_linux_dr_get_control as i386_dr_low.get_control.  Install
	i386_linux_dr_get_addr as i386_dr_low.get_addr.  Install
	i386_linux_prepare_to_resume.

	* arm-linux-nat.c (arm_linux_new_thread): Change parameter to an
	lwp pointer.  Adjust.
	* ia64-linux-nat.c (ia64_linux_new_thread): Likewise.
	* mips-linux-nat.c (mips_linux_new_thread): Likewise.
	* ppc-linux-nat.c (ppc_linux_new_thread): Likewise.
	* s390-nat.c (s390_fix_watch_points): Likewise.

	* i386-darwin-nat.c (DR_FIRSTADDR, DR_LASTADDR, DR_STATUS)
	(DR_CONTROL): Delete.
	(i386_darwin_dr_reset_addr): Delete.
	(i386_darwin_dr_get_addr): New.
	(i386_darwin_dr_get_control): New.
	* go32-nat.c
	(go32_get_dr7, go32_get_dr): New.
	(init_go32_ops): No longer install i386_dr_low.reset_addr.
	Install go32_get_dr7 as i386_dr_low.get_control.  Install
	go32_get_dr as i386_dr_low.get_addr.
	* i386bsd-nat.c (i386bsd_dr_get): New.
	(i386bsd_dr_reset_addr): Delete.
	(i386bsd_dr_get_addr): New.
	(i386bsd_dr_get_status): Use i386bsd_dr_get.
	(i386bsd_dr_get_control): New.
	* i386bsd-nat.h (i386bsd_dr_reset_addr): Delete.
	(i386bsd_dr_get_addr): New.
	(i386bsd_dr_get_control): New.
	* i386fbsd-nat.c (_initialize_i386fbsd_nat): No longer install
	i386_dr_low.reset_addr and i386_dr_low.unset_status.  Install
	i386bsd_dr_get_control as i386_dr_low.get_control.  Install
	i386bsd_dr_get_addr as i386_dr_low.get_addr.
	* windows-nat.c (init_windows_ops): No longer install
	i386_dr_low.reset_addr and i386_dr_low.unset_status.  Install
	cygwin_get_dr7 as i386_dr_low.get_control.  Install cygwin_get_dr
	as i386_dr_low.get_addr.
	(cygwin_get_dr): New.
	(cygwin_get_dr7): New.

gdb/testsuite/
2011-12-14  Pedro Alves  <pedro@@codesourcery.com>

	PR threads/10729

	* gdb.mi/watch-nonstop.c: New file.
 	* gdb.mi/mi-watch-nonstop.exp: New file.
@
text
@d718 3
d764 6
@


1.106
log
@2012-12-05  Pedro Alves  <pedro@@codesourcery.com>

	* amd64-linux-nat.c (amd64_linux_dr_get): Remove FIXME comment.
	Reinstate perror_with_name call on ptrace error.  Remove #if 0.
	* i386-linux-nat.c (i386_linux_dr_get): Likewise.
	* i386bsd-nat.c (i386bsd_dr_get_status): Likewise.
@
text
@a49 16
#ifndef DR_FIRSTADDR
#define DR_FIRSTADDR 0
#endif

#ifndef DR_LASTADDR
#define DR_LASTADDR 3
#endif

#ifndef DR_STATUS
#define DR_STATUS 6
#endif

#ifndef DR_CONTROL
#define DR_CONTROL 7
#endif

d70 8
a645 2
static unsigned long i386_linux_dr[DR_CONTROL + 1];

d685 1
a685 1
/* Set DR_CONTROL to ADDR in all LWPs of LWP_LIST.  */
d687 2
a688 2
static void
i386_linux_dr_set_control (unsigned long control)
d690 7
a696 1
  struct lwp_info *lp;
d698 4
a701 3
  i386_linux_dr[DR_CONTROL] = control;
  ALL_LWPS (lp)
    i386_linux_dr_set (lp->ptid, DR_CONTROL, control);
d704 1
a704 1
/* Set address REGNUM (zero based) to ADDR in all LWPs of LWP_LIST.  */
d706 2
a707 2
static void
i386_linux_dr_set_addr (int regnum, CORE_ADDR addr)
d709 5
a713 1
  struct lwp_info *lp;
d715 11
a725 1
  gdb_assert (regnum >= 0 && regnum <= DR_LASTADDR - DR_FIRSTADDR);
d727 1
a727 3
  i386_linux_dr[DR_FIRSTADDR + regnum] = addr;
  ALL_LWPS (lp)
    i386_linux_dr_set (lp->ptid, DR_FIRSTADDR + regnum, addr);
d730 1
a730 1
/* Set address REGNUM (zero based) to zero in all LWPs of LWP_LIST.  */
d733 1
a733 1
i386_linux_dr_reset_addr (int regnum)
d735 3
a737 1
  i386_linux_dr_set_addr (regnum, 0);
d740 2
a741 1
/* Get DR_STATUS from only the one LWP of INFERIOR_PTID.  */
d743 2
a744 2
static unsigned long
i386_linux_dr_get_status (void)
d746 5
a750 1
  return i386_linux_dr_get (inferior_ptid, DR_STATUS);
d753 2
a754 1
/* Unset MASK bits in DR_STATUS in all LWPs of LWP_LIST.  */
d757 1
a757 1
i386_linux_dr_unset_status (unsigned long mask)
d759 1
a759 1
  struct lwp_info *lp;
d761 1
a761 1
  ALL_LWPS (lp)
d763 14
a776 1
      unsigned long value;
d778 3
a780 3
      value = i386_linux_dr_get (lp->ptid, DR_STATUS);
      value &= ~mask;
      i386_linux_dr_set (lp->ptid, DR_STATUS, value);
d782 3
d788 1
a788 1
i386_linux_new_thread (ptid_t ptid)
d790 1
a790 1
  int i;
d792 1
a792 2
  for (i = DR_FIRSTADDR; i <= DR_LASTADDR; i++)
    i386_linux_dr_set (ptid, i, i386_linux_dr[i]);
d794 1
a794 1
  i386_linux_dr_set (ptid, DR_CONTROL, i386_linux_dr[DR_CONTROL]);
d1013 1
a1013 1
  i386_dr_low.reset_addr = i386_linux_dr_reset_addr;
d1015 1
a1015 1
  i386_dr_low.unset_status = i386_linux_dr_unset_status;
d1034 1
@


1.106.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 2
a4 1
   Copyright (C) 1999-2012 Free Software Foundation, Inc.
@


1.105
log
@2011-10-07  Pedro Alves  <pedro@@codesourcery.com>

	* linux-nat.h (ALL_LWPS): Remove the ptid parameter.
	* amd64-linux-nat.c (amd64_linux_dr_set_control)
	(amd64_linux_dr_set_addr, amd64_linux_dr_unset_status): Adjust.
	* arm-linux-nat.c (arm_linux_insert_hw_breakpoint)
	(arm_linux_remove_hw_breakpoint, arm_linux_insert_watchpoint)
	(arm_linux_remove_watchpoint): Adjust.
	* i386-linux-nat.c (i386_linux_dr_set_control)
	(i386_linux_dr_set_addr, i386_linux_dr_unset_status): Adjust.
	* ia64-linux-nat.c (ia64_linux_insert_watchpoint)
	(ia64_linux_remove_watchpoint): Adjust.
	* mips-linux-nat.c (write_watchpoint_regs): Adjust.
	* ppc-linux-nat.c (ppc_linux_insert_hw_breakpoint)
	(ppc_linux_insert_hw_breakpoint, ppc_linux_remove_hw_breakpoint)
	(ppc_linux_insert_mask_watchpoint)
	(ppc_linux_remove_mask_watchpoint, ppc_linux_insert_watchpoint)
	(ppc_linux_remove_watchpoint): Adjust.
	* s390-nat.c (s390_insert_watchpoint, s390_remove_watchpoint):
	Adjust.
@
text
@a667 5
  /* FIXME: kettenis/2001-03-27: Calling perror_with_name if the
     ptrace call fails breaks debugging remote targets.  The correct
     way to fix this is to add the hardware breakpoint and watchpoint
     stuff to the target vector.  For now, just return zero if the
     ptrace call fails.  */
a671 1
#if 0
a672 3
#else
    return 0;
#endif
@


1.104
log
@gdb/
	* i386-linux-nat.c (i386_linux_resume): Use read_memory_unsigned_integer
	to get address.
@
text
@a709 1
  ptid_t ptid;
d712 2
a713 2
  ALL_LWPS (lp, ptid)
    i386_linux_dr_set (ptid, DR_CONTROL, control);
a721 1
  ptid_t ptid;
d726 2
a727 2
  ALL_LWPS (lp, ptid)
    i386_linux_dr_set (ptid, DR_FIRSTADDR + regnum, addr);
a751 1
  ptid_t ptid;
d753 1
a753 1
  ALL_LWPS (lp, ptid)
d756 2
a757 2
      
      value = i386_linux_dr_get (ptid, DR_STATUS);
d759 1
a759 1
      i386_linux_dr_set (ptid, DR_STATUS, value);
@


1.103
log
@2011-02-27  Michael Snyder  <msnyder@@vmware.com>

	* darwin-nat-info.c: Fix comment typo.
	* dwarf2expr.h: Ditto.
	* fbsd-nat.c: Ditto.
	* fbsd-nat.h: Ditto.
	* frame-unwind.h: Ditto.
	* frame.h: Ditto.
	* hppa-hpux-tdep.c: Ditto.
	* i386-linux-nat.c: Ditto.
	* linux-nat.c: Ditto.
	* nbsd-nat.c: Ditto.
	* nbsd-nat.h: Ditto.
	* ppc-linux-tdep.c: Ditto.
	* serial.c: Ditto.
	* ui-file.h: Ditto.
	* tui/tui-winsource.c: Ditto.
@
text
@d896 2
a897 1
		addr = read_memory_integer (sp + 8, 4, byte_order) + 20;
@


1.102
log
@2011-01-08  Michael Snyder  <msnyder@@vmware.com>

	* h8300-tdep.c: Comment cleanup, mostly periods and spaces.
	* hppa-hpux-tdep.c: Ditto.
	* hppa-linux-nat.c: Ditto.
	* hppa-linux-tdep.c: Ditto.
	* hppanbsd-tdep.c: Ditto.
	* hppa-tdep.c: Ditto.
	* hppa-tdep.h: Ditto.
	* hpux-thread.c: Ditto.
	* i386-cygwin-tdep.c: Ditto.
	* i386-darwin-nat.c: Ditto.
	* i386gnu-nat.c: Ditto.
	* i386-linux-nat.c: Ditto.
	* i386-linux-tdep.c: Ditto.
	* i386-nat.c: Ditto.
	* i386-nat.h: Ditto.
	* i386nbsd-tdep.c: Ditto.
	* i386-sol2-nat.c: Ditto.
	* i386-stub.c: Ditto.
	* i386-tdep.c: Ditto.
	* i386-tdep.h: Ditto.
	* i387-tdep.c: Ditto.
	* ia64-linux-nat.c: Ditto.
	* ia64-linux-tdep.c: Ditto.
	* ia64-tdep.c: Ditto.
	* infcall.c: Ditto.
	* infcall.h: Ditto.
	* infcmd.c: Ditto.
	* inferior.c: Ditto.
	* inferior.h: Ditto.
	* infloop.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* interps.c: Ditto.
	* interps.h: Ditto.
	* iq2000-tdep.c: Ditto.
	* irix5-nat.c: Ditto.
	* jit.c: Ditto.
	* jit.h: Ditto.
	* jv-exp.y: Ditto.
	* jv-lang.c: Ditto.
	* jv-lang.h: Ditto.
	* jv-typeprint.c: Ditto.
	* jv-valprint.c: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* linespec.c: Ditto.
	* linux-fork.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-thread-db.c: Ditto.
	* lm32-tdep.c: Ditto.
@
text
@d797 1
a797 1
     address of a a descriptor that libthread_db uses to find the
@


1.101
log
@run copyright.sh for 2011.
@
text
@d173 1
a173 1
/* Store one register. */
d219 2
a220 2
    regcache_raw_supply (regcache, I386_LINUX_ORIG_EAX_REGNUM,
			  regp + i386_linux_gregset_reg_offset[I386_LINUX_ORIG_EAX_REGNUM]);
d242 2
a243 2
    regcache_raw_collect (regcache, I386_LINUX_ORIG_EAX_REGNUM,
			  regp + i386_linux_gregset_reg_offset[I386_LINUX_ORIG_EAX_REGNUM]);
d355 9
a363 2
static void fetch_fpregs (struct regcache *regcache, int tid) {}
static void store_fpregs (const struct regcache *regcache, int tid, int regno) {}
d483 11
a493 2
static int fetch_fpxregs (struct regcache *regcache, int tid) { return 0; }
static int store_fpxregs (const struct regcache *regcache, int tid, int regno) { return 0; }
@


1.100
log
@	* gregset.h (GDB_FPXREGSET_T): Remove.
	(gdb_fpxregset_t): Likewise.
	(supply_fpxregset): Remove prototype.
	(fill_fpxregset): Likewise.
	* i386-linux-nat.c (supply_fpxregset): Remove.
	(fill_fpxregset): Likewise.
	(fetch_fpxregs): Inline supply_fpxregset call.
	(store_fpxregs): Inline fill_fpxregset call.

	* config/i386/linux.mh: Set NAT_FILE to config/nm-linux.h.
	* config/i386/nm-linux.h: Remove file.
@
text
@d4 1
a4 1
   2009, 2010 Free Software Foundation, Inc.
@


1.99
log
@Remove regmap from i386-linux-nat.c.

2010-04-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-linux-nat.c (regmap): Removed.
	(fetch_register): Replace regmap with
	i386_linux_gregset_reg_offset.
	(store_register): Likewise.
	(supply_gregset): Likewise.
	(fill_gregset): Likewise.

	* i386-linux-tdep.c (i386_linux_gregset_reg_offset): Make it
	global.

	* i386-linux-tdep.h (i386_linux_gregset_reg_offset): New.
@
text
@a415 21
/* Fill GDB's register array with the floating-point and SSE register
   values in *FPXREGSETP.  */

void
supply_fpxregset (struct regcache *regcache,
		  const elf_fpxregset_t *fpxregsetp)
{
  i387_supply_fxsave (regcache, -1, fpxregsetp);
}

/* Fill register REGNO (if it is a floating-point or SSE register) in
   *FPXREGSETP with the value in GDB's register array.  If REGNO is
   -1, do this for all registers.  */

void
fill_fpxregset (const struct regcache *regcache,
		elf_fpxregset_t *fpxregsetp, int regno)
{
  i387_collect_fxsave (regcache, regno, fpxregsetp);
}

d439 1
a439 1
  supply_fpxregset (regcache, (const elf_fpxregset_t *) &fpxregs);
d466 1
a466 1
  fill_fpxregset (regcache, &fpxregs, regno);
@


1.98
log
@Support i386 without SSE.

gdb/

2010-04-08  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-linux-nat.c (have_ptrace_getfpxregs): Initialize to -1
	if HAVE_PTRACE_GETFPXREGS is defined.
	(i386_linux_read_description): Set have_ptrace_getfpxregs and
	have_ptrace_getregset to 0 if ptrace PTRACE_GETFPXREGS failed.

	* i386-linux-tdep.c: Include "features/i386/i386-mmx-linux.c"
	(i386_linux_core_read_description): Return tdesc_i386_mmx_linux
	if .reg-xfp section doesn't exist.
	(_initialize_i386_linux_tdep): Call initialize_tdesc_i386_mmx_linux.

	* i386-linux-tdep.h (tdesc_i386_mmx_linux): New.

	* i386-tdep.c: Include "features/i386/i386-mmx.c".
	(i386_go32_init_abi): Set tdesc to tdesc_i386_mmx.
	(i386_validate_tdesc_p): Make org.gnu.gdb.i386.sse optional.  Set
	xcr0 to I386_XSTATE_X87_MASK if SSE isn't available.
	(i386_gdbarch_init): Update comments.
	(_initialize_i386_tdep): Call initialize_tdesc_i386_mmx.

	* common/i386-xstate.h (I386_XSTATE_X87_MASK): New.

	* config/djgpp/fnchange.lst: Add i386 MMX XML files.

	* features/Makefile (i386/i386-mmx-expedite): New.
	(i386/i386-mmx-linux-expedite): Likewise.
	($(outdir)/i386/i386-mmx.dat): Likewise.
	($(outdir)/i386/i386-mmx-linux.dat): Likewise.

	* features/i386/i386-mmx-linux.c: New.
	* features/i386/i386-mmx-linux.xml: Likewise.
	* features/i386/i386-mmx.c: Likewise.
	* features/i386/i386-mmx.xml: Likewise.
	* regformats/i386/i386-mmx-linux.dat: Likewise.
	* regformats/i386/i386-mmx.dat: Likewise.

	* features/Makefile (WHICH): Add i386/i386-mmx and
	i386/i386-mmx-linux.

gdb/doc/

2010-04-08  H.J. Lu  <hongjiu.lu@@intel.com>

	* gdb.texinfo (i386 Features): Make org.gnu.gdb.i386.avx
	optional.  Make org.gnu.gdb.i386.avx requires
	org.gnu.gdb.i386.avx.

gdb/gdbserver/

2010-04-08  H.J. Lu  <hongjiu.lu@@intel.com>

	* Makefile.in (clean): Also remove i386-mmx.c i386-mmx-linux.c.
	(i386-mmx.o): New.
	(i386-mmx.c): Likewise.
	(i386-mmx-linux.o): Likewise.
	(i386-mmx-linux.c): Likewise.

	* configure.srv (srv_i386_regobj): Add i386-mmx.o.
	(srv_i386_linux_regobj): Add i386-mmx-linux.o.
	(srv_i386_xmlfiles): Add i386/i386-mmx.xml.
	(srv_i386_linux_xmlfiles): Add i386/i386-mmx-linux.xml.

	* linux-x86-low.c (init_registers_i386_mmx_linux): New.
	(x86_linux_update_xmltarget): Call init_registers_i386_mmx_linux
	and return if ptrace PTRACE_GETFPXREGS failed in 32bit.
@
text
@a101 20
/* Mapping between the general-purpose registers in `struct user'
   format and GDB's register array layout.  */
static int regmap[] = 
{
  EAX, ECX, EDX, EBX,
  UESP, EBP, ESI, EDI,
  EIP, EFL, CS, SS,
  DS, ES, FS, GS,
  -1, -1, -1, -1,		/* st0, st1, st2, st3 */
  -1, -1, -1, -1,		/* st4, st5, st6, st7 */
  -1, -1, -1, -1,		/* fctrl, fstat, ftag, fiseg */
  -1, -1, -1, -1,		/* fioff, foseg, fooff, fop */
  -1, -1, -1, -1,		/* xmm0, xmm1, xmm2, xmm3 */
  -1, -1, -1, -1,		/* xmm4, xmm5, xmm6, xmm6 */
  -1,				/* mxcsr */
  -1, -1, -1, -1,		/* ymm0h, ymm1h, ymm2h, ymm3h */
  -1, -1, -1, -1,		/* ymm4h, ymm5h, ymm6h, ymm6h */
  ORIG_EAX
};

d151 1
a151 1
  if (regmap[regno] == -1)
d163 2
a164 1
  val = ptrace (PTRACE_PEEKUSER, tid, 4 * regmap[regno], 0);
d182 1
a182 1
  if (regmap[regno] == -1)
d192 2
a193 1
  ptrace (PTRACE_POKEUSER, tid, 4 * regmap[regno], val);
d210 1
a210 1
  const elf_greg_t *regp = (const elf_greg_t *) gregsetp;
d214 2
a215 1
    regcache_raw_supply (regcache, i, regp + regmap[i]);
d220 1
a220 1
			 regp + ORIG_EAX);
d231 1
a231 1
  elf_greg_t *regp = (elf_greg_t *) gregsetp;
d236 2
a237 1
      regcache_raw_collect (regcache, i, regp + regmap[i]);
d243 1
a243 1
			  regp + ORIG_EAX);
@


1.97
log
@Support i386 AVX.

2010-04-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-linux-nat.c: Include "regset.h", "elf/common.h",
	<sys/uio.h> and "i386-xstate.h".
	(PTRACE_GETREGSET): New.
	(PTRACE_SETREGSET): Likewise.
	(fetch_xstateregs): Likewise.
	(store_xstateregs): Likewise.
	(GETXSTATEREGS_SUPPLIES): Likewise.
	(regmap): Include 8 upper YMM registers.
	(i386_linux_fetch_inferior_registers): Support XSAVE extended
	state.
	(i386_linux_store_inferior_registers): Likewise.
	(i386_linux_read_description): Check and enable AVX target
	descriptions.

	* i386-linux-tdep.c: Include "regset.h", "i387-tdep.h",
	"i386-xstate.h" and "features/i386/i386-avx-linux.c".
	(i386_linux_regset_sections): Add ".reg-xstate".
	(i386_linux_gregset_reg_offset): Include 8 upper YMM registers.
	(i386_linux_core_read_xcr0): New.
	(i386_linux_core_read_description): Check and enable AVX target
	description.
	(i386_linux_init_abi): Set xsave_xcr0_offset.
	(_initialize_i386_linux_tdep): Call
	initialize_tdesc_i386_avx_linux.

	* i386-linux-tdep.h (I386_LINUX_ORIG_EAX_REGNUM): Replace
	I386_SSE_NUM_REGS with I386_AVX_NUM_REGS.
	(i386_linux_core_read_xcr0): New.
	(tdesc_i386_avx_linux): Likewise.
	(I386_LINUX_XSAVE_XCR0_OFFSET): Likewise.

	* i386-tdep.c: Include "i386-xstate.h" and
	"features/i386/i386-avx.c".
	(i386_ymm_names): New.
	(i386_ymmh_names): Likewise.
	(i386_ymmh_regnum_p): Likewise.
	(i386_ymm_regnum_p): Likewise.
	(i386_xmm_regnum_p): Likewise.
	(i386_register_name): Likewise.
	(i386_ymm_type): Likewise.
	(i386_supply_xstateregset): Likewise.
	(i386_collect_xstateregset): Likewise.
	(i386_sse_regnum_p): Removed.
	(i386_pseudo_register_name): Support pseudo YMM registers.
	(i386_pseudo_register_type): Likewise.
	(i386_pseudo_register_read): Likewise.
	(i386_pseudo_register_write): Likewise.
	(i386_dbx_reg_to_regnum): Return %ymmN register number for
	%xmmN if AVX is available.
	(i386_regset_from_core_section): Support .reg-xstate section.
	(i386_register_reggroup_p): Supper upper YMM and YMM registers.
	(i386_process_record): Replace i386_sse_regnum_p with
	i386_xmm_regnum_p.
	(i386_validate_tdesc_p): Support org.gnu.gdb.i386.avx feature.
	Set ymmh_register_names, num_ymm_regs, ymm0h_regnum and xcr0.
	(i386_gdbarch_init): Set xstateregset.  Set xsave_xcr0_offset.
	Call set_gdbarch_register_name.  Replace I386_SSE_NUM_REGS with
	I386_AVX_NUM_REGS.  Set ymmh_register_names, ymm0h_regnum and
	num_ymm_regs.  Add num_ymm_regs to set_gdbarch_num_pseudo_regs.
	Set ymm0_regnum.
	(_initialize_i386_tdep): Call initialize_tdesc_i386_avx.

	* i386-tdep.h (gdbarch_tdep): Add xstateregset, ymm0_regnum,
	xcr0, xsave_xcr0_offset, ymm0h_regnum, ymmh_register_names and
	i386_ymm_type.
	(i386_regnum): Add I386_YMM0H_REGNUM, and I386_YMM7H_REGNUM.
	(I386_AVX_NUM_REGS): New.
	(i386_xmm_regnum_p): Likewise.
	(i386_ymm_regnum_p): Likewise.
	(i386_ymmh_regnum_p): Likewise.

	* common/i386-xstate.h: New.
@
text
@d153 1
a153 1
  1
d949 1
d952 19
a972 1
      int tid;
a975 5
      /* GNU/Linux LWP ID's are process ID's.  */
      tid = TIDGET (inferior_ptid);
      if (tid == 0)
	tid = PIDGET (inferior_ptid); /* Not a threaded program.  */

@


1.96
log
@Enable XML target descriptions for x86.

gdb/

2010-03-01  H.J. Lu  <hongjiu.lu@@intel.com>

	* amd64-linux-nat.c (AMD64_LINUX_USER64_CS): New.
	(amd64_linux_read_description): Likewise.
	(_initialize_amd64_linux_nat): Set to_read_description to
	amd64_linux_read_description.

	* amd64-linux-tdep.c: Include "features/i386/amd64-linux.c".
	(amd64_linux_register_name): Removed.
	(amd64_linux_register_type): Likewise.
	(amd64_linux_core_read_description): New.
	(amd64_linux_init_abi): Set target description to
	tdesc_amd64_linux if needed.  Support orig_rax in target
	description.  Don't call set_gdbarch_register_name nor
	set_gdbarch_register_type.  Call
	set_gdbarch_core_read_description.
	(_initialize_amd64_linux_tdep): Call
	initialize_tdesc_amd64_linux.

	* amd64-linux-tdep.h (tdesc_amd64_linux): New.

	* amd64-tdep.c:  Include "features/i386/amd64.c".
	(amd64_register_names): Removed.
	(amd64_register_name): Likewise.
	(amd64_register_type): Likewise.
	(amd64_init_abi):  Set num_core_regs and register_names.  Set
	target description to tdesc_amd64 if needed.  Don't call
	set_gdbarch_register_name nor set_gdbarch_register_type.
	(_initialize_amd64_tdep): New.

	* i386-linux-nat.c (i386_linux_read_description): New.
	(_initialize_i386_linux_nat): Set to_read_description to
	i386_linux_read_description.

	* i386-linux-tdep.c: Include "features/i386/i386-linux.c".
	(i386_linux_register_name): Removed.
	(i386_linux_core_read_description): New.
	(i386_linux_read_description): Likewise.
	(i386_linux_init_abi): Don't call set_gdbarch_register_name.
	Set target description to tdesc_i386_linux if needed.  Support
	orig_eax.  Set register_reggroup_p.  Call
	set_gdbarch_core_read_description.
	(_initialize_i386_linux_tdep): Call initialize_tdesc_i386_linux.

	* i386-linux-tdep.h (tdesc_i386_linux): New.

	* i386-nto-tdep.c (i386nto_regset_id): Replace I386_NUM_FREGS
	with I387_NUM_REGS.

	* i386-tdep.c: Include "features/i386/i386.c".
	(i386_register_names): Make it const.
	(i386_mmx_names): Likewise.
	(i386_num_register_names): Removed.
	(i386_register_name): Likewise.
	(i386_eflags_type): Likewise.
	(i386_mxcsr_type): Likewise.
	(i386_sse_type): Likewise.
	(i386_register_type): Likewise.
	(i387_ext_type): Call tdesc_find_type instead of arch_float_type.
	(i386_pseudo_register_name): New.
	(i386_pseudo_register_type): Likewise.
	(i386_mmx_type): Make it static.
	(i386_gdbarch_init): Check arch.  Replace I386_NUM_FREGS with
	I387_NUM_REGS.  Set num_core_regs and register_names.  Don't
	call set_gdbarch_register_name nor set_gdbarch_register_type.
	Set register_reggroup_p.  Set target description to tdesc_i386
	if needed.  Call set_tdesc_pseudo_register_type,
	set_tdesc_pseudo_register_name and tdesc_use_registers.
	(_initialize_i386_tdep): Call initialize_tdesc_i386.
	initialize_tdesc_x86_64.

	* i386-tdep.h (gdbarch_tdep): Remove i386_eflags_type,
	i386_mxcsr_type and i386_sse_type.  Add num_core_regs,
	register_names, tdesc and register_reggroup_p.
	(I386_NUM_FREGS): Removed.
	(i386_eflags_type): Likewise.
	(i386_mxcsr_type): Likewise.
	(i386_mmx_type): Likewise.
	(i386_sse_type): Likewise.
	(i386_register_name): Likewise.
	(i386_regnum): Add I386_MXCSR_REGNUM.
	(I386_SSE_NUM_REGS): Defined with I386_MXCSR_REGNUM.

	* i387-tdep.h (I387_NUM_REGS): New.

	* regformats/i386/i386-linux.dat: Generated.
	* regformats/i386/i386.dat: Likewise.
	* regformats/i386/amd64-linux.dat: Likewise.
	* regformats/i386/amd64.dat: Likewise.

	* regformats/reg-i386-linux.dat: Removed.
	* regformats/reg-i386.dat: Likewise.
	* regformats/reg-x86-64-linux.dat: Likewise.
	* regformats/reg-x86-64.dat: Likewise.

gdb/gdbserver/

2010-03-01  H.J. Lu  <hongjiu.lu@@intel.com>

	* Makefile.in (clean): Replace reg-i386.c, reg-x86-64.c,
	reg-i386-linux.c and reg-x86-64-linux.c with i386.c, amd64.c,
	i386-linux.c and amd64-linux.c.
	(reg-i386.o): Removed.
	(reg-i386.c): Likewise.
	(reg-i386-linux.o): Likewise.
	(reg-i386-linux.c): Likewise.
	(reg-x86-64.o): Likewise.
	(reg-x86-64.c): Likewise.
	(reg-x86-64-linux.o): Likewise.
	(reg-x86-64-linux.c): Likewise.
	(i386.o): New.
	(i386.c): Likewise.
	(i386-linux.o): Likewise.
	(i386-linux.c): Likewise.
	(amd64.o): Likewise.
	(amd64.c): Likewise.
	(amd64-linux.o): Likewise.
	(amd64-linux.c): Likewise.

	* configure.srv (srv_i386_regobj): New.
	(srv_i386_linux_regobj): Likewise.
	(srv_amd64_regobj): Likewise.
	(srv_amd64_linux_regobj): Likewise.
	(srv_i386_32bit_xmlfiles): Likewise.
	(srv_i386_64bit_xmlfiles): Likewise.
	(srv_i386_xmlfiles): Likewise.
	(srv_amd64_xmlfiles): Likewise.
	(srv_i386_linux_xmlfiles): Likewise.
	(srv_amd64_linux_xmlfiles): Likewise.
	(i[34567]86-*-cygwin*): Set srv_regobj to $srv_i386_regobj.  Set
	srv_xmlfiles to $srv_i386_xmlfiles.
	(i[34567]86-*-mingw32ce*): Likewise.
	(i[34567]86-*-mingw*): Likewise.
	(i[34567]86-*-nto*): Likewise.
	(i[34567]86-*-linux*): Set srv_regobj to $srv_i386_linux_regobj
	and $srv_amd64_linux_regobj.  Set srv_xmlfiles to
	$srv_i386_linux_xmlfiles and $srv_amd64_linux_xmlfiles.
	(x86_64-*-linux*): Likewise.

	* linux-x86-low.c (init_registers_x86_64_linux): Removed.
	(init_registers_amd64_linux): New.
	(x86_arch_setup): Replace init_registers_x86_64_linux with
	init_registers_amd64_linux.

gdb/testsuite/

2010-03-01  H.J. Lu  <hongjiu.lu@@intel.com>

	* gdb.xml/tdesc-regs.exp (architecture): New.  Set it for x86.
	(load_description): Set architecture if defined.
@
text
@d26 1
d32 2
d75 13
d117 2
d131 3
d379 51
d564 2
d578 6
d636 2
d650 6
d949 36
a984 1
  return tdesc_i386_linux;
@


1.95
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d856 8
d892 2
@


1.94
log
@gdb/
	Fix repeated rwatch output.
	* amd64-linux-nat.c (amd64_linux_dr_set, amd64_linux_dr_set_control)
	(amd64_linux_dr_set_addr, amd64_linux_dr_reset_addr)
	(amd64_linux_dr_get_status): New comments.
	(amd64_linux_dr_unset_status): New function.
	(_initialize_amd64_linux_nat): Install it.
	* i386-linux-nat.c (i386_linux_dr_get, i386_linux_dr_set)
	(i386_linux_dr_set_control, i386_linux_dr_set_addr)
	(i386_linux_dr_reset_addr, i386_linux_dr_get_status): New comments.
	(i386_linux_dr_unset_status): New function.
	(_initialize_i386_linux_nat): Install it.
	* i386-nat.c (I386_DR_WATCH_MASK): New macro.
	(I386_DR_WATCH_HIT): Use I386_DR_WATCH_MASK.
	(i386_insert_aligned_watchpoint): Call i386_dr_low.unset_status.
	* i386-nat.h (struct i386_dr_low_type): Extend comments for
	set_control, set_addr, reset_addr and get_status.  New unset_status.
	* breakpoint.c (update_watchpoint): Extend the comment.

gdb/testsuite/
	* gdb.base/watchpoint-hw-hit-once.exp,
	gdb.base/watchpoint-hw-hit-once.c: New.
@
text
@d4 1
a4 1
   2009 Free Software Foundation, Inc.
@


1.93
log
@Implementing catch syscall.

* amd64-linux-tdep.c: Include xml-syscall.h header, define the XML
syscall name for the architecture.
(amd64_linux_get_syscall_number): New function.
(amd64_linux_init_abi): Register the correct functions for syscall
catchpoint; set the correct syscall file name.
* breakpoint.c: New include: xml-syscall.h.
(set_raw_breakpoint_without_location): Setting the parameters
for the catch syscall feature.
(insert_catch_syscall): New.
(remove_catch_syscall): New.
(breakpoint_hit_catch_syscall): New.
(print_it_catch_syscall): New.
(print_one_catch_syscall): New.
(print_mention_catch_syscall): New.
(catch_syscall_breakpoint_ops): New.
(syscall_catchpoint_p): New.
(create_catchpoint_without_mention): New.
(create_catchpoint): Modified in order to use
create_catchpoint_without_mention.
(create_syscall_event_catchpoint): New.
(clean_up_filters): New.
(catch_syscall_split_args): New.
(catch_syscall_command_1): New.
(delete_breakpoint): Add cleanup for catch syscall.
(is_syscall_catchpoint_enabled): New.
(catch_syscall_enabled): New.
(catching_syscall_number): New.
(catch_syscall_completer): New completer function.
(add_catch_command): Add the completer function for catchpoints.
* breakpoint.h (syscalls_to_be_caught): New vector.
(catch_syscall_enabled): New.
(catching_syscall_number): New.
* gdbarch.c: Regenerated.
* gdbarch.h: Regenerated.
* gdbarch.sh: Add syscall catchpoint functions and structures.
(get_syscall_number): New.
(UNKNOWN_SYSCALL): New definition.
* i386-linux-nat.c (i386_linux_resume): Select the proper request
to be made for ptrace() considering if we are catching syscalls
or not.
* i386-linux-tdep.c: Include xml-syscall.h header, define the XML
syscall name for the architecture.
(i386_linux_get_syscall_number): New.
(i386_linux_init_abi): Register the correct functions for syscall
catchpoint; set the correct syscall file name.
* inf-child.c (inf_child_set_syscall_catchpoint): New.
(inf_child_target): Assign default values to target_ops.
* inf-ptrace.c (inf_ptrace_resume): Select the proper request
to be made for ptrace() considering if we are catching syscalls
or not.
* inferior.h (struct inferior): Included new variables
any_syscall_count, syscalls_counts and total_syscalls_count,
used to keep track of requested syscall catchpoints.
* infrun.c (resume): Add syscall catchpoint.
(deal_with_syscall_event): New.
(handle_inferior_event): Add syscall entry/return events.
(inferior_has_called_syscall): New.
* linux-nat.c: Define some helpful variables to track wether we have
support for the needed ptrace option.
(linux_test_for_tracesysgood): New.
(linux_supports_tracesysgood): New.
(linux_enable_tracesysgood): New.
(linux_enable_event_reporting): Save the current used ptrace
options.
(linux_child_post_attach): Calling linux_enable_tracesysgood.
(linux_child_post_startup_inferior): Likewise.
(linux_child_set_syscall_catchpoint): New function.
(linux_handle_extended_wait): Handle the case which the inferior stops
because it has called or returned from a syscall.
(linux_target_install_ops): Install the necessary functions to handle
syscall catchpoints.
* linux-nat.h (struct lwp_info): Include syscall_state into the
structure, which indicates if we are in a syscall entry or return.
* ppc-linux-tdep.c: Include xml-syscall.h header, define the XML
syscall filename for the arch.
(ppc_linux_get_syscall_number): New.
(ppc_linux_init_abi): Register the correct functions for syscall
catchpoint; setting the correct name for the XML syscall file.
* target.c (update_current_target): Update/copy functions related to
syscall catchpoint.
(target_waitstatus_to_string): Add syscall catchpoint entry/return
events.
* target.h (struct target_waitstatus): Add syscall number.
(struct syscall): New struct to hold information about syscalls
in the system.
(struct target_ops): Add ops for syscall catchpoint.
(inferior_has_called_syscall): New.
(target_set_syscall_catchpoint): New.
* xml-support.c (xml_fetch_content_from_file): New function,
transferred from xml-tdesc.c.
* xml-support.h (xml_fetch_content_from_file): New.
* xml-tdesc.c (fetch_xml_from_file): Function removed;
transferred to xml-support.c.
(file_read_description_xml): Updated to use the new
xml_fetch_content_from_file function.
* syscalls/gdb-syscalls.dtd: New definition file for syscall's XML
support.
* syscalls/amd64-linux.xml: New file containing information about
syscalls for GNU/Linux systems that use amd64 architecture.
* syscalls/i386-linux.xml: New file containing information about
syscalls for GNU/Linux systems that use i386 architecture.
* syscalls/ppc-linux.xml: New file containing information about
syscalls for GNU/Linux systems that use PPC architecture.
* syscalls/ppc64-linux.xml: New file containing information about
syscalls for GNU/Linux systems that use PPC64 architecture.
* xml-syscall.c: New file containing functions for manipulating
syscall's XML files.
* xml-syscall.h: New file, exporting the functions above mentioned.
* Makefile.in: Support for relocatable GDB datadir and XML
syscall.
* NEWS: Added information about the catch syscall feature.
* doc/gdb.texinfo (Set Catchpoints): Documentation about the new
feature.
* testsuite/Makefile.in: Inclusion of catch-syscall object.
* testsuite/gdb.base/catch-syscall.c: New file.
* testsuite/gdb.base/catch-syscall.exp: New file.
@
text
@d589 2
d619 2
d637 2
d650 2
d665 2
d673 2
d681 18
d870 1
@


1.92
log
@	* defs.h (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.
	* findvar.c (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.

	* gdbcore.h (read_memory_integer, safe_read_memory_integer,
	read_memory_unsigned_integer, write_memory_signed_integer,
	write_memory_unsigned_integer): Add BYTE_ORDER parameter.
	* corefile.c (struct captured_read_memory_integer_arguments): Add
	BYTE_ORDER member.
	(safe_read_memory_integer): Add BYTE_ORDER parameter.  Store it into
	struct captured_read_memory_integer_arguments.
	(do_captured_read_memory_integer): Pass it to read_memory_integer.
	(read_memory_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_signed_integer.
	(read_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_unsigned_integer.
	(write_memory_signed_integer): Add BYTE_ORDER parameter.  Pass it
	to store_signed_integer.
	(write_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it
	to store_unsigned_integer.

	* target.h (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	* target.c (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	Pass it to extract_unsigned_integer.


	Update calls to extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer, read_memory_integer,
	read_memory_unsigned_integer, safe_read_memory_integer,
	write_memory_signed_integer, write_memory_unsigned_integer, and
	get_target_memory_unsigned to pass byte order:
	* ada-lang.c (ada_value_binop): Update.
	* ada-valprint.c (char_at): Update.
	* alpha-osf1-tdep.c (alpha_osf1_sigcontext_addr): Update.
	* alpha-tdep.c (alpha_lds, alpha_sts, alpha_push_dummy_call,
	alpha_extract_return_value, alpha_read_insn,
	alpha_get_longjmp_target): Update.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Update.
	* amd64obsd-tdep.c (amd64obsd_supply_uthread,
	amd64obsd_collect_uthread, amd64obsd_trapframe_cache): Update.
	* amd64-tdep.c (amd64_push_dummy_call, amd64_analyze_prologue,
	amd64_frame_cache, amd64_sigtramp_frame_cache, fixup_riprel,
	amd64_displaced_step_fixup): Update.
	* arm-linux-tdep.c (arm_linux_sigreturn_init,
	arm_linux_rt_sigreturn_init, arm_linux_supply_gregset): Update.
	* arm-tdep.c (thumb_analyze_prologue, arm_skip_prologue,
	arm_scan_prologue, arm_push_dummy_call, thumb_get_next_pc,
	arm_get_next_pc, arm_extract_return_value, arm_store_return_value,
	arm_return_value): Update.
	* arm-wince-tdep.c (arm_pe_skip_trampoline_code): Update.
	* auxv.c (default_auxv_parse): Update.
	* avr-tdep.c (avr_address_to_pointer, avr_pointer_to_address,
	avr_scan_prologue, avr_extract_return_value,
	avr_frame_prev_register, avr_push_dummy_call): Update.
	* bsd-uthread.c (bsd_uthread_check_magic, bsd_uthread_lookup_offset,
	bsd_uthread_wait, bsd_uthread_thread_alive,
	bsd_uthread_extra_thread_info): Update.
	* c-lang.c (c_printstr, print_wchar): Update.
	* cp-valprint.c (cp_print_class_member): Update.
	* cris-tdep.c (cris_sigcontext_addr, cris_sigtramp_frame_unwind_cache,
	cris_push_dummy_call, cris_scan_prologue, cris_store_return_value,
	cris_extract_return_value, find_step_target, dip_prefix,
	sixteen_bit_offset_branch_op, none_reg_mode_jump_op,
	move_mem_to_reg_movem_op, get_data_from_address): Update.
	* dwarf2expr.c (dwarf2_read_address, execute_stack_op): Update.
	* dwarf2-frame.c (execute_cfa_program): Update.
	* dwarf2loc.c (find_location_expression): Update.
	* dwarf2read.c (dwarf2_const_value): Update.
	* expprint.c (print_subexp_standard): Update.
	* findvar.c (unsigned_pointer_to_address, signed_pointer_to_address,
	unsigned_address_to_pointer, address_to_signed_pointer,
	read_var_value): Update.
	* frame.c (frame_unwind_register_signed,
	frame_unwind_register_unsigned, get_frame_memory_signed,
	get_frame_memory_unsigned): Update.
	* frame-unwind.c (frame_unwind_got_constant): Update.
	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp,
	frv_linux_sigcontext_reg_addr, frv_linux_sigtramp_frame_cache):
	Update.
	* frv-tdep.c (frv_analyze_prologue, frv_skip_main_prologue,
	frv_extract_return_value, find_func_descr,
	frv_convert_from_func_ptr_addr, frv_push_dummy_call): Update.
	* f-valprint.c (f_val_print): Update.
	* gnu-v3-abi.c (gnuv3_decode_method_ptr, gnuv3_make_method_ptr):
	Update.
	* h8300-tdep.c (h8300_is_argument_spill, h8300_analyze_prologue,
	h8300_push_dummy_call, h8300_extract_return_value,
	h8300h_extract_return_value, h8300_store_return_value,
	h8300h_store_return_value): Update.
	* hppabsd-tdep.c (hppabsd_find_global_pointer): Update.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register, hppa_hpux_store_register):
	Update.
	* hppa-hpux-tdep.c (hppa32_hpux_in_solib_call_trampoline,
	hppa64_hpux_in_solib_call_trampoline,
	hppa_hpux_in_solib_return_trampoline, hppa_hpux_skip_trampoline_code,
	hppa_hpux_sigtramp_frame_unwind_cache,
	hppa_hpux_sigtramp_unwind_sniffer, hppa32_hpux_find_global_pointer,
	hppa64_hpux_find_global_pointer, hppa_hpux_search_pattern,
	hppa32_hpux_search_dummy_call_sequence,
	hppa64_hpux_search_dummy_call_sequence, hppa_hpux_supply_save_state,
	hppa_hpux_unwind_adjust_stub): Update.
	* hppa-linux-tdep.c (insns_match_pattern,
	hppa_linux_find_global_pointer): Update.
	* hppa-tdep.c (hppa_in_function_epilogue_p, hppa32_push_dummy_call,
	hppa64_convert_code_addr_to_fptr, hppa64_push_dummy_call,
	skip_prologue_hard_way, hppa_frame_cache, hppa_fallback_frame_cache,
	hppa_pseudo_register_read, hppa_frame_prev_register_helper,
	hppa_match_insns): Update.
	* hpux-thread.c (hpux_thread_fetch_registers): Update.
	* i386-tdep.c (i386bsd_sigcontext_addr): Update.
	* i386-cygwin-tdep.c (core_process_module_section): Update.
	* i386-darwin-nat.c (i386_darwin_sstep_at_sigreturn,
	amd64_darwin_sstep_at_sigreturn): Update.
	* i386-darwin-tdep.c (i386_darwin_sigcontext_addr,
	amd64_darwin_sigcontext_addr): Likewise.
	* i386-linux-nat.c (i386_linux_sigcontext_addr): Update.
	* i386nbsd-tdep.c (i386nbsd_sigtramp_cache_init): Update.
	* i386-nto-tdep.c (i386nto_sigcontext_addr): Update.
	* i386obsd-nat.c (i386obsd_supply_pcb): Update.
	* i386obsd-tdep.c (i386obsd_supply_uthread, i386obsd_collect_uthread,
	i386obsd_trapframe_cache): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_follow_jump,
	i386_analyze_frame_setup, i386_analyze_prologue,
	i386_skip_main_prologue, i386_frame_cache, i386_sigtramp_frame_cache,
	i386_get_longjmp_target, i386_push_dummy_call,
	i386_pe_skip_trampoline_code, i386_svr4_sigcontext_addr,
	i386_fetch_pointer_argument): Update.
	* i387-tdep.c (i387_supply_fsave): Update.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Update.
	* ia64-tdep.c (ia64_pseudo_register_read, ia64_pseudo_register_write,
	examine_prologue, ia64_frame_cache, ia64_frame_prev_register,
	ia64_sigtramp_frame_cache, ia64_sigtramp_frame_prev_register,
	ia64_access_reg, ia64_access_rse_reg, ia64_libunwind_frame_this_id,
	ia64_libunwind_frame_prev_register,
	ia64_libunwind_sigtramp_frame_this_id,
	ia64_libunwind_sigtramp_frame_prev_register, ia64_find_global_pointer,
	find_extant_func_descr, find_func_descr,
	ia64_convert_from_func_ptr_addr, ia64_push_dummy_call, ia64_dummy_id,
	ia64_unwind_pc): Update.
	* iq2000-tdep.c (iq2000_pointer_to_address, iq2000_address_to_pointer,
	iq2000_scan_prologue, iq2000_extract_return_value,
	iq2000_push_dummy_call): Update.
	* irix5nat.c (fill_gregset): Update.
	* jv-lang.c (evaluate_subexp_java): Update.
	* jv-valprint.c (java_value_print): Update.
	* lm32-tdep.c (lm32_analyze_prologue, lm32_push_dummy_call,
	lm32_extract_return_value, lm32_store_return_value): Update.
	* m32c-tdep.c (m32c_push_dummy_call, m32c_return_value,
	m32c_skip_trampoline_code, m32c_m16c_address_to_pointer,
	m32c_m16c_pointer_to_address): Update.
	* m32r-tdep.c (m32r_store_return_value, decode_prologue,
	m32r_skip_prologue, m32r_push_dummy_call, m32r_extract_return_value):
	Update.
	* m68hc11-tdep.c (m68hc11_pseudo_register_read,
	m68hc11_pseudo_register_write, m68hc11_analyze_instruction,
	m68hc11_push_dummy_call): Update.
	* m68linux-tdep.c (m68k_linux_pc_in_sigtramp,
	m68k_linux_get_sigtramp_info, m68k_linux_sigtramp_frame_cache):
	Update.
	* m68k-tdep.c (m68k_push_dummy_call, m68k_analyze_frame_setup,
	m68k_analyze_register_saves, m68k_analyze_prologue, m68k_frame_cache,
	m68k_get_longjmp_target): Update.
	* m88k-tdep.c (m88k_fetch_instruction): Update.
	* mep-tdep.c (mep_pseudo_cr32_read, mep_pseudo_csr_write,
	mep_pseudo_cr32_write, mep_get_insn, mep_push_dummy_call): Update.
	* mi/mi-main.c (mi_cmd_data_write_memory): Update.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target, supply_32bit_reg,
	mips64_linux_get_longjmp_target, mips64_fill_gregset,
	mips64_fill_fpregset, mips_linux_in_dynsym_stub): Update.
	* mipsnbdsd-tdep.c (mipsnbsd_get_longjmp_target): Update.
	* mips-tdep.c (mips_fetch_instruction, fetch_mips_16,
	mips_eabi_push_dummy_call, mips_n32n64_push_dummy_call,
	mips_o32_push_dummy_call, mips_o64_push_dummy_call,
	mips_single_step_through_delay, mips_skip_pic_trampoline_code,
	mips_integer_to_address): Update.
	* mn10300-tdep.c (mn10300_analyze_prologue, mn10300_push_dummy_call):
	Update.
	* monitor.c (monitor_supply_register, monitor_write_memory,
	monitor_read_memory_single): Update.
	* moxie-tdep.c (moxie_store_return_value, moxie_extract_return_value,
	moxie_analyze_prologue): Update.
	* mt-tdep.c (mt_return_value, mt_skip_prologue, mt_select_coprocessor,
	mt_pseudo_register_read, mt_pseudo_register_write, mt_registers_info,
	mt_push_dummy_call): Update.
	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class, find_implementation_from_class): Update.
	* ppc64-linux-tdep.c (ppc64_desc_entry_point,
	ppc64_linux_convert_from_func_ptr_addr, ppc_linux_sigtramp_cache):
	Update.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_sniffer,
	ppcobsd_sigtramp_frame_cache): Update.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call,
	do_ppc_sysv_return_value, ppc64_sysv_abi_push_dummy_call,
	ppc64_sysv_abi_return_value): Update.
	* ppc-linux-nat.c (ppc_linux_auxv_parse): Update.
	* procfs.c (procfs_auxv_parse): Update.
	* p-valprint.c (pascal_val_print): Update.
	* regcache.c (regcache_raw_read_signed, regcache_raw_read_unsigned,
	regcache_raw_write_signed, regcache_raw_write_unsigned,
	regcache_cooked_read_signed, regcache_cooked_read_unsigned,
	regcache_cooked_write_signed, regcache_cooked_write_unsigned): Update.
	* remote-m32r-sdi.c (m32r_fetch_register): Update.
	* remote-mips.c (mips_wait, mips_fetch_registers, mips_xfer_memory):
	Update.
	* rs6000-aix-tdep.c (rs6000_push_dummy_call, rs6000_return_value,
	rs6000_convert_from_func_ptr_addr, branch_dest,
	rs6000_software_single_step): Update.
	* rs6000-tdep.c (rs6000_in_function_epilogue_p,
	ppc_displaced_step_fixup, ppc_deal_with_atomic_sequence,
	bl_to_blrl_insn_p, rs6000_fetch_instruction, skip_prologue,
	rs6000_skip_main_prologue, rs6000_skip_trampoline_code,
	rs6000_frame_cache): Update.
	* s390-tdep.c (s390_pseudo_register_read, s390_pseudo_register_write,
	s390x_pseudo_register_read, s390x_pseudo_register_write, s390_load,
	s390_backchain_frame_unwind_cache, s390_sigtramp_frame_unwind_cache,
	extend_simple_arg, s390_push_dummy_call, s390_return_value): Update.
	* scm-exp.c (scm_lreadr): Update.
	* scm-lang.c (scm_get_field, scm_unpack): Update.
	* scm-valprint.c (scm_val_print): Update.
	* score-tdep.c (score_breakpoint_from_pc, score_push_dummy_call,
	score_fetch_inst): Update.
	* sh64-tdep.c (look_for_args_moves, sh64_skip_prologue_hard_way,
	sh64_analyze_prologue, sh64_push_dummy_call, sh64_extract_return_value,
	sh64_pseudo_register_read, sh64_pseudo_register_write,
	sh64_frame_prev_register): Update:
	* sh-tdep.c (sh_analyze_prologue, sh_push_dummy_call_fpu,
	sh_push_dummy_call_nofpu, sh_extract_return_value_nofpu,
	sh_store_return_value_nofpu, sh_in_function_epilogue_p): Update.
	* solib-darwin.c (darwin_load_image_infos): Update.
	* solib-frv.c (fetch_loadmap, lm_base, frv_current_sos, enable_break2,
	find_canonical_descriptor_in_load_object): Update.
	* solib-irix.c (extract_mips_address, fetch_lm_info, irix_current_sos,
	irix_open_symbol_file_object): Update.
	* solib-som.c (som_solib_create_inferior_hook, link_map_start,
	som_current_sos, som_open_symbol_file_object): Update.
	* solib-sunos.c (SOLIB_EXTRACT_ADDRESS, LM_ADDR, LM_NEXT, LM_NAME):
	Update.
	* solib-svr4.c (read_program_header, scan_dyntag_auxv,
	solib_svr4_r_ldsomap): Update.
	* sparc64-linux-tdep.c (sparc64_linux_step_trap): Update.
	* sparc64obsd-tdep.c (sparc64obsd_supply_uthread,
	sparc64obsd_collect_uthread): Update.
	* sparc64-tdep.c (sparc64_pseudo_register_read,
	sparc64_pseudo_register_write, sparc64_supply_gregset,
	sparc64_collect_gregset): Update.
	* sparc-linux-tdep.c (sparc32_linux_step_trap): Update.
	* sparcobsd-tdep.c (sparc32obsd_supply_uthread,
	sparc32obsd_collect_uthread): Update.
	* sparc-tdep.c (sparc_fetch_wcookie, sparc32_push_dummy_code,
	sparc32_store_arguments, sparc32_return_value, sparc_supply_rwindow,
	sparc_collect_rwindow): Update.
	* spu-linux-nat.c (parse_spufs_run): Update.
	* spu-tdep.c (spu_pseudo_register_read_spu,
	spu_pseudo_register_write_spu, spu_pointer_to_address,
	spu_analyze_prologue, spu_in_function_epilogue_p,
	spu_frame_unwind_cache, spu_push_dummy_call, spu_software_single_step,
	spu_get_longjmp_target, spu_get_overlay_table, spu_overlay_update_osect,
	info_spu_signal_command, info_spu_mailbox_list, info_spu_dma_cmdlist,
	info_spu_dma_command, info_spu_proxydma_command): Update.
	* stack.c (print_frame_nameless_args, frame_info): Update.
	* symfile.c (read_target_long_array, simple_read_overlay_table,
	simple_read_overlay_region_table): Update.
	* target.c (debug_print_register): Update.
	* tramp-frame.c (tramp_frame_start): Update.
	* v850-tdep.c (v850_analyze_prologue, v850_push_dummy_call,
	v850_extract_return_value, v850_store_return_value,
	* valarith.c (value_binop, value_bit_index): Update.
	* valops.c (value_cast): Update.
	* valprint.c (val_print_type_code_int, val_print_string,
	read_string): Update.
	* value.c (unpack_long, unpack_double, unpack_field_as_long,
	modify_field, pack_long): Update.
	* vax-tdep.c (vax_store_arguments, vax_push_dummy_call,
	vax_skip_prologue): Update.
	* xstormy16-tdep.c (xstormy16_push_dummy_call,
	xstormy16_analyze_prologue, xstormy16_in_function_epilogue_p,
	xstormy16_resolve_jmp_table_entry, xstormy16_find_jmp_table_entry,
	xstormy16_pointer_to_address, xstormy16_address_to_pointer): Update.
	* xtensa-tdep.c (extract_call_winsize, xtensa_pseudo_register_read,
	xtensa_pseudo_register_write, xtensa_frame_cache,
	xtensa_push_dummy_call, call0_track_op, call0_frame_cache): Update.


	* dfp.h (decimal_to_string, decimal_from_string, decimal_from_integral,
	decimal_from_floating, decimal_to_doublest, decimal_is_zero): Add
	BYTE_ORDER parameter.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	* dfp.c (match_endianness): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.
	(decimal_to_string, decimal_from_integral, decimal_from_floating,
	decimal_to_doublest, decimal_is_zero): Add BYTE_ORDER parameter.
	Pass it to match_endianness.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.  Pass them to match_endianness.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	Pass them to match_endianness.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	Pass them to match_endianness.
	* valarith.c (value_args_as_decimal): Add BYTE_ORDER_X and
	BYTE_ORDER_Y output parameters.
	(value_binop): Update call to value_args_as_decimal.

	Update calls to decimal_to_string, decimal_from_string,
	decimal_from_integral, decimal_from_floating, decimal_to_doublest,
	decimal_is_zero, decimal_binop, decimal_compare and decimal_convert
	to pass/receive byte order:
	* c-exp.y (parse_number): Update.
	* printcmd.c (printf_command): Update.
	* valarith.c (value_args_as_decimal, value_binop, value_logical_not,
	value_equal, value_less): Update.
	* valops.c (value_cast, value_one): Update.
	* valprint.c (print_decimal_floating): Update.
	* value.c (unpack_long, unpack_double): Update.
	* python/python-value.c (valpy_nonzero): Update.


	* ada-valprint.c (char_at): Add BYTE_ORDER parameter.
	(printstr): Update calls to char_at.
	(ada_val_print_array): Likewise.
	* valprint.c (read_string): Add BYTE_ORDER parameter.
	(val_print_string): Update call to read_string.
	* c-lang.c (c_get_string): Likewise.
	* charset.h (target_wide_charset): Add BYTE_ORDER parameter.
	* charset.c (target_wide_charset): Add BYTE_ORDER parameter.
	Use it instead of current_gdbarch.
	* printcmd.c (printf_command): Update calls to target_wide_charset.
	* c-lang.c (charset_for_string_type): Add BYTE_ORDER parameter.
	Pass to target_wide_charset.  Use it instead of current_gdbarch.
	(classify_type): Add BYTE_ORDER parameter.  Pass to
	charset_for_string_type.  Allow NULL encoding pointer.
	(print_wchar): Add BYTE_ORDER parameter.
	(c_emit_char): Update calls to classify_type and print_wchar.
	(c_printchar, c_printstr): Likewise.


	* gdbarch.sh (in_solib_return_trampoline): Convert to type "m".
	* gdbarch.c, gdbarch.h: Regenerate.
	* arch-utils.h (generic_in_solib_return_trampoline): Add GDBARCH
	parameter.
	* arch-utils.c (generic_in_solib_return_trampoline): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_in_solib_return_trampoline): Likewise.
	* rs6000-tdep.c (rs6000_in_solib_return_trampoline): Likewise.
	(rs6000_skip_trampoline_code): Update call.

	* alpha-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	dynamic_sigtramp_offset and pc_in_sigtramp callbacks.
	(alpha_read_insn): Add GDBARCH parameter.
	* alpha-tdep.c (alpha_lds, alpha_sts): Add GDBARCH parameter.
	(alpha_register_to_value): Pass architecture to alpha_sts.
	(alpha_extract_return_value): Likewise.
	(alpha_value_to_register): Pass architecture to alpha_lds.
	(alpha_store_return_value): Likewise.
	(alpha_read_insn): Add GDBARCH parameter.
	(alpha_skip_prologue): Pass architecture to alpha_read_insn.
	(alpha_heuristic_proc_start): Likewise.
	(alpha_heuristic_frame_unwind_cache): Likewise.
	(alpha_next_pc): Likewise.
	(alpha_sigtramp_frame_this_id): Pass architecture to
	tdep->dynamic_sigtramp_offset callback.
	(alpha_sigtramp_frame_sniffer): Pass architecture to
	tdep->pc_in_sigtramp callback.
	* alphafbsd-tdep.c (alphafbsd_pc_in_sigtramp): Add GDBARCH parameter.
	(alphafbsd_sigtramp_offset): Likewise.
	* alpha-linux-tdep.c (alpha_linux_sigtramp_offset_1): Add GDBARCH
	parameter.  Pass to alpha_read_insn.
	(alpha_linux_sigtramp_offset): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset_1.
	(alpha_linux_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset.
	(alpha_linux_sigcontext_addr): Pass architecture to alpha_read_insn
	and alpha_linux_sigtramp_offset.
	* alphanbsd-tdep.c (alphanbsd_sigtramp_offset): Add GDBARCH parameter.
	(alphanbsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alphanbsd_sigtramp_offset.
	* alphaobsd-tdep.c (alphaobsd_sigtramp_offset): Add GDBARCH parameter.
	(alphaobsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_read_insn.
	(alphaobsd_sigcontext_addr): Pass architecture to
	alphaobsd_sigtramp_offset.
	* alpha-osf1-tdep.c (alpha_osf1_pc_in_sigtramp): Add GDBARCH
	parameter.

	* amd64-tdep.c (amd64_analyze_prologue): Add GDBARCH parameter.
	(amd64_skip_prologue): Pass architecture to amd64_analyze_prologue.
	(amd64_frame_cache): Likewise.

	* arm-tdep.c (SWAP_SHORT, SWAP_INT): Remove.
	(thumb_analyze_prologue, arm_skip_prologue, arm_scan_prologue,
	thumb_get_next_pc, arm_get_next_pc): Do not use SWAP_ macros.
	* arm-wince-tdep.c: Include "frame.h".

	* avr-tdep.c (EXTRACT_INSN): Remove.
	(avr_scan_prologue): Add GDBARCH argument, inline EXTRACT_INSN.
	(avr_skip_prologue): Pass architecture to avr_scan_prologue.
	(avr_frame_unwind_cache): Likewise.

	* cris-tdep.c (struct instruction_environment): Add BYTE_ORDER member.
	(find_step_target): Initialize it.
	(get_data_from_address): Add BYTE_ORDER parameter.
	(bdap_prefix): Pass byte order to get_data_from_address.
	(handle_prefix_assign_mode_for_aritm_op): Likewise.
	(three_operand_add_sub_cmp_and_or_op): Likewise.
	(handle_inc_and_index_mode_for_aritm_op): Likewise.

	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp): Add GDBARCH parameter.
	(frv_linux_sigcontext_reg_addr): Pass architecture to
	frv_linux_pc_in_sigtramp.
	(frv_linux_sigtramp_frame_sniffer): Likewise.

	* h8300-tdep.c (h8300_is_argument_spill): Add GDBARCH parameter.
	(h8300_analyze_prologue): Add GDBARCH parameter.  Pass to
	h8300_is_argument_spill.
	(h8300_frame_cache, h8300_skip_prologue): Pass architecture
	to h8300_analyze_prologue.

	* hppa-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	in_solib_call_trampoline callback.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.
	* hppa-tdep.c (hppa64_convert_code_addr_to_fptr): Add GDBARCH
	parameter.
	(hppa64_push_dummy_call): Pass architecture to
	hppa64_convert_code_addr_to_fptr.
	(hppa_match_insns): Add GDBARCH parameter.
	(hppa_match_insns_relaxed): Add GDBARCH parameter.  Pass to
	hppa_match_insns.
	(hppa_skip_trampoline_code): Pass architecture to hppa_match_insns.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.  Pass to
	hppa_match_insns_relaxed.
	(hppa_stub_unwind_sniffer): Pass architecture to
	tdep->in_solib_call_trampoline callback.
	* hppa-hpux-tdep.c (hppa_hpux_search_pattern): Add GDBARCH parameter.
	(hppa32_hpux_search_dummy_call_sequence): Pass architecture to
	hppa_hpux_search_pattern.
	* hppa-linux-tdep.c (insns_match_pattern): Add GDBARCH parameter.
	(hppa_linux_sigtramp_find_sigcontext): Add GDBARCH parameter.
	Pass to insns_match_pattern.
	(hppa_linux_sigtramp_frame_unwind_cache): Pass architecture to
	hppa_linux_sigtramp_find_sigcontext.
	(hppa_linux_sigtramp_frame_sniffer): Likewise.
	(hppa32_hpux_in_solib_call_trampoline): Add GDBARCH parameter.
	(hppa64_hpux_in_solib_call_trampoline): Likewise.

	* i386-tdep.c (i386_follow_jump): Add GDBARCH parameter.
	(i386_analyze_frame_setup): Add GDBARCH parameter.
	(i386_analyze_prologue): Add GDBARCH parameter.  Pass to
	i386_follow_jump and i386_analyze_frame_setup.
	(i386_skip_prologue): Pass architecture to i386_analyze_prologue
	and i386_follow_jump.
	(i386_frame_cache): Pass architecture to i386_analyze_prologue.
	(i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-tdep.h (i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-cygwin-tdep.c (i386_cygwin_skip_trampoline_code): Pass
	frame to i386_pe_skip_trampoline_code.

	* ia64-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter
	to sigcontext_register_address callback.
	* ia64-tdep.c (ia64_find_global_pointer): Add GDBARCH parameter.
	(ia64_find_unwind_table): Pass architecture to
	ia64_find_global_pointer.
	(find_extant_func_descr): Add GDBARCH parameter.
	(find_func_descr): Pass architecture to find_extant_func_descr
	and ia64_find_global_pointer.
	(ia64_sigtramp_frame_init_saved_regs): Pass architecture to
	tdep->sigcontext_register_address callback.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Add
	GDBARCH parameter.

	* iq2000-tdep.c (iq2000_scan_prologue): Add GDBARCH parameter.
	(iq2000_frame_cache): Pass architecture to iq2000_scan_prologue.

	* lm32-tdep.c (lm32_analyze_prologue): Add GDBARCH parameter.
	(lm32_skip_prologue, lm32_frame_cache): Pass architecture to
	lm32_analyze_prologue.

	* m32r-tdep.c (decode_prologue): Add GDBARCH parameter.
	(m32r_skip_prologue): Pass architecture to decode_prologue.

	* m68hc11-tdep.c (m68hc11_analyze_instruction): Add GDBARCH parameter.
	(m68hc11_scan_prologue): Pass architecture to
	m68hc11_analyze_instruction.

	* m68k-tdep.c (m68k_analyze_frame_setup): Add GDBARCH parameter.
	(m68k_analyze_prologue): Pass architecture to
	m68k_analyze_frame_setup.

	* m88k-tdep.c (m88k_fetch_instruction): Add BYTE_ORDER parameter.
	(m88k_analyze_prologue): Add GDBARCH parameter.  Pass byte order
	to m88k_fetch_instruction.
	(m88k_skip_prologue): Pass architecture to m88k_analyze_prologue.
	(m88k_frame_cache): Likewise.

	* mep-tdep.c (mep_get_insn): Add GDBARCH parameter.
	(mep_analyze_prologue): Pass architecture to mep_get_insn.

	* mips-tdep.c (mips_fetch_instruction): Add GDBARCH parameter.
	(mips32_next_pc): Pass architecture to mips_fetch_instruction.
	(deal_with_atomic_sequence): Likewise.
	(unpack_mips16): Add GDBARCH parameter, pass to mips_fetch_instruction.
	(mips16_scan_prologue): Likewise.
	(mips32_scan_prologue): Likewise.
	(mips16_in_function_epilogue_p): Likewise.
	(mips32_in_function_epilogue_p): Likewise.
	(mips_about_to_return): Likewise.
	(mips_insn16_frame_cache): Pass architecture to mips16_scan_prologue.
	(mips_insn32_frame_cache): Pass architecture to mips32_scan_prologue.
	(mips_skip_prologue): Pass architecture to mips16_scan_prologue
	and mips32_scan_prologue.
	(mips_in_function_epilogue_p): Pass architecture to
	mips16_in_function_epilogue_p and
	mips32_in_function_epilogue_p.
	(heuristic_proc_start): Pass architecture to mips_fetch_instruction
	and mips_about_to_return.
	(mips_skip_mips16_trampoline_code): Pass architecture to
	mips_fetch_instruction.
	(fetch_mips_16): Add GDBARCH parameter.
	(mips16_next_pc): Pass architecture to fetch_mips_16.
	(extended_mips16_next_pc): Pass architecture to unpack_mips16 and
	fetch_mips_16.

	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class): Add GDBARCH parameter.
	(find_implementation_from_class): Add GDBARCH parameter, pass
	to read_objc_class, read_objc_methlist_nmethods, and
	read_objc_methlist_method.
	(find_implementation): Add GDBARCH parameter, pass to
	read_objc_object and find_implementation_from_class.
	(resolve_msgsend, resolve_msgsend_stret): Pass architecture
	to find_implementation.
	(resolve_msgsend_super, resolve_msgsend_super_stret): Pass
	architecture to read_objc_super and find_implementation_from_class.

	* ppc64-linux-tdep.c (ppc64_desc_entry_point): Add GDBARCH parameter.
	(ppc64_standard_linkage1_target, ppc64_standard_linkage2_target,
	ppc64_standard_linkage3_target): Pass architecture to
	ppc64_desc_entry_point.
	* rs6000-tdep.c (bl_to_blrl_insn_p): Add BYTE_ORDER parameter.
	(skip_prologue): Pass byte order to bl_to_blrl_insn_p.
	(rs6000_fetch_instruction): Add GDBARCH parameter.
	(rs6000_skip_stack_check): Add GDBARCH parameter, pass to
	rs6000_fetch_instruction.
	(skip_prologue): Pass architecture to rs6000_fetch_instruction.

	* remote-mips.c (mips_store_word): Return old_contents as host
	integer value instead of target bytes.

	* s390-tdep.c (struct s390_prologue_data): Add BYTE_ORDER member.
	(s390_analyze_prologue): Initialize it.
	(extend_simple_arg): Add GDBARCH parameter.
	(s390_push_dummy_call): Pass architecture to extend_simple_arg.

	* scm-lang.c (scm_get_field): Add BYTE_ORDER parameter.
	* scm-lang.h (scm_get_field): Add BYTE_ORDER parameter.
	(SCM_CAR, SCM_CDR): Pass SCM_BYTE_ORDER to scm_get_field.
	* scm-valprint.c (scm_scmval_print): Likewise.
	(scm_scmlist_print, scm_ipruk, scm_scmval_print): Define
	SCM_BYTE_ORDER.

	* sh64-tdep.c (look_for_args_moves): Add GDBARCH parameter.
	(sh64_skip_prologue_hard_way): Add GDBARCH parameter, pass to
	look_for_args_moves.
	(sh64_skip_prologue): Pass architecture to
	sh64_skip_prologue_hard_way.
	* sh-tdep.c (sh_analyze_prologue): Add GDBARCH parameter.
	(sh_skip_prologue): Pass architecture to sh_analyze_prologue.
	(sh_frame_cache): Likewise.

	* solib-irix.c (extract_mips_address): Add GDBARCH parameter.
	(fetch_lm_info, irix_current_sos, irix_open_symbol_file_object):
	Pass architecture to extract_mips_address.

	* sparc-tdep.h (sparc_fetch_wcookie): Add GDBARCH parameter.
	* sparc-tdep.c (sparc_fetch_wcookie): Add GDBARCH parameter.
	(sparc_supply_rwindow, sparc_collect_rwindow): Pass architecture
	to sparc_fetch_wcookie.
	(sparc32_frame_prev_register): Likewise.
	* sparc64-tdep.c (sparc64_frame_prev_register): Likewise.
	* sparc32nbsd-tdep.c (sparc32nbsd_sigcontext_saved_regs): Likewise.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_saved_regs): Likewise.

	* spu-tdep.c (spu_analyze_prologue): Add GDBARCH parameter.
	(spu_skip_prologue): Pass architecture to spu_analyze_prologue.
	(spu_virtual_frame_pointer): Likewise.
	(spu_frame_unwind_cache): Likewise.
	(info_spu_mailbox_list): Add BYTE_ORER parameter.
	(info_spu_mailbox_command): Pass byte order to info_spu_mailbox_list.
	(info_spu_dma_cmdlist): Add BYTE_ORER parameter.
	(info_spu_dma_command, info_spu_proxydma_command): Pass byte order
	to info_spu_dma_cmdlist.

	* symfile.c (read_target_long_array): Add GDBARCH parameter.
	(simple_read_overlay_table, simple_read_overlay_region_table,
	simple_overlay_update_1): Pass architecture to read_target_long_array.

	* v850-tdep.c (v850_analyze_prologue): Add GDBARCH parameter.
	(v850_frame_cache): Pass architecture to v850_analyze_prologue.

	* xstormy16-tdep.c (xstormy16_analyze_prologue): Add GDBARCH
	parameter.
	(xstormy16_skip_prologue, xstormy16_frame_cache): Pass architecture
	to xstormy16_analyze_prologue.
	(xstormy16_resolve_jmp_table_entry): Add GDBARCH parameter.
	(xstormy16_find_jmp_table_entry): Likewise.
	(xstormy16_skip_trampoline_code): Pass architecture to
	xstormy16_resolve_jmp_table_entry.
	(xstormy16_pointer_to_address): Likewise.
	(xstormy16_address_to_pointer): Pass architecture to
	xstormy16_find_jmp_table_entry.

	* xtensa-tdep.c (call0_track_op): Add GDBARCH parameter.
	(call0_analyze_prologue): Add GDBARCH parameter, pass to
	call0_track_op.
	(call0_frame_cache): Pass architecture to call0_analyze_prologue.
	(xtensa_skip_prologue): Likewise.
@
text
@d755 6
a760 1
  int request = PTRACE_CONT;
@


1.91
log
@	Remove all i386 debug register low level macros in config nm files.
	(I386_DR_LOW_SET_ADDR, I386_DR_LOW_RESET_ADDR): Remove.
	(I386_DR_LOW_GET_STATUS, I386_DR_LOW_SET_CONTROL): Remove.
	(I386_USE_GENERIC_WATCHPOIINTS): Remove.

	* i386-nat.h: New file (adapted from config/i386/nm-i386.h).
	(struct i386_dr_low_type): New type.
	(i386_dr_low): New global variable.
	* i386-nat.c (TARGET_HAS_DR_LEN_8): Update macro.
	(i386_insert_aligned_watchpoint): Replace i386 dr low macros by
	i386_dr_low struct variable fields.
	(i386_remove_aligned_watchpoint): Likewise.
	(i386_stopped_data_address): Likewise.
	(i386_stopped_by_hwbp): Likewise.
	(show_debug_regs_command_added): New static variable.
	(add_show_debug_regs_command): New static function.
	(i386_use_watchpoints): Call add_show_debug_regs_command if not done.
	(i386_set_debug_register_length): New function.
	(_initialize_i386_nat): Delete.

	* amd64-linux-nat.c: Include "i386-nat.h".
	(amd64_linux_dr_set_control):  Change to static.
	(amd64_linux_dr_get_status): Change to static.
	(amd64_linux_dr_set_addr,amd64_linux_dr_reset_addr): Likewise.
	(_initialize_amd64_linux_nat): Set i386_dr_low variable fields.

	* go32-nat.c: Include "i386-nat.h".
	(go32_set_addr): Change to static.
	(go32_set_dr7): Change to static. Change arg type to unisgned long.
	(go32_get_dr6): Change to static. Change return type to unisnged long.
	(init_go32_ops):  Set i386_dr_low variable fields.
	* i386-linux-nat.c: Include "i386-nat.h".
	(i386_linux_dr_set_control, i386_linux_dr_get_status): Change to static.
	(i386_linux_dr_set_addr, i386_linux_dr_reset_addr): Idem.
	(_initialize_i386_linux_nat):  Set i386_dr_low variable fields.
	* i386bsd-nat.h: Declare functions used for
	i386_dr_low fields in i386fbsd-nat.c.
	* i386fbsd-nat.c: Include "i386-nat.h".
	(_initialize_i386fbsd_nat): Set i386_dr_low variable fields.
	* windows-nat.c: Include "i386-nat.h".
	(cygwin_set_dr, cygwin_get_dr6, cygwin_set_dr7): Add prototypes.
	Change to static.
	(cygwin_get_dr6): Change return type to unisnged long.
	(cygwin_set_dr7): Change arg type to unisgned long.
	(init_windows_ops): Set i386_dr_low function fields.

	* amd64-windows-nat.c (_initialize_amd64_windows_nat): Call
	i386_set_debug_register_length.
	* i386-windows-nat.c (_initialize_i386_windows_nat): Likewise.

	* config/i386/nm-cygwin.h: Remove all I386_* macros.
	* config/i386/nm-cygwin64.h: Likewise.
	* config/i386/nm-fbsd.h: Likewise.
	* config/i386/nm-linux.h: Likewise.
	* config/i386/nm-i386.h: Remove completely.
	* config/i386/nm-go32.h: Remove completely.
	* config/i386/nm-linux64.h: Remove completely.
	* config/i386/go32.mh (NAT_FILE): Remove entry.
	* config/i386/linux64.h (NAT_FILE): Change to config/nm-linux.h.
@
text
@d760 2
d767 2
a768 2
      regcache_cooked_read_unsigned
	(regcache, gdbarch_pc_regnum (get_regcache_arch (regcache)), &pc);
d794 1
a794 1
		addr = read_memory_integer (sp + 8, 4) + 20;
@


1.90
log
@	* i386-linux-nat.c (i386_linux_fetch_inferior_registers): Pass
	`ops' to recursive call.
@
text
@d22 1
d633 1
a633 1
void
d644 1
a644 1
void
d657 1
a657 1
void
d663 1
a663 1
unsigned long
d829 6
@


1.89
log
@	* corelow.c (get_core_registers): Adjust.
	(core_file_thread_alive): Rename to...
	(core_thread_alive): ... this.
	(core_pid_to_str): Try gdbarch_core_pid_to_str first.
	(init_core_ops): Adjust.
	(coreops_suppress_target): Delete.
	(_initialize_corelow): Unconditionally add core_ops.
	* procfs.c: Include "inf-child.h".
	(procfs_ops): Delete.
	(init_procfs_ops): Delete.  Reimplement as...
	(procfs_target): ... this, inheriting from inf-child.
	(procfs_attach, procfs_detach, procfs_fetch_registers): Adjust.
	(procfs_prepare_to_store): Delete.
	(procfs_store_registers, procfs_resume): Adjust.
	(procfs_open): Delete.
	(procfs_suppress_run): Delete.
	(procfs_can_run): Delete.
	(procfs_mourn_inferior): Adjust.
	(procfs_init_inferior): Add target_ops parameter.  Adjust.
	(procfs_create_inferior): Don't pass procfs_init_inferior to
	fork_inferior.  Instead call it after fork_inferior returns.
	(procfs_find_new_threads): Adjust.
	(_initialize_procfs): Adjust to use procfs_target instead of
	init_procfs_ops.
	* sol-thread.c (orig_core_ops, sol_core_ops): Delete.
	(lwp_to_thread): Use target_thread_alive.
	(sol_thread_open): Delete.
	(sol_thread_attach): Delete.
	(sol_thread_detach, sol_thread_resume, sol_thread_wait)
	(sol_thread_fetch_registers, sol_thread_store_registers): Adjust
	to use find_target_beneath.
	(sol_thread_prepare_to_store, sol_thread_xfer_memory): Delete.
	(sol_thread_xfer_partial): Adjust to use find_target_beneath.
	(sol_thread_files_info, sol_thread_kill_inferior): Delete.
	(check_for_thread_db): New.
	(sol_thread_notice_signals, sol_thread_create_inferior): Delete.
	(sol_thread_new_objfile): Call check_for_thread_db.
	(sol_thread_mourn_inferior): Adjust to use find_target_beneath.
	(sol_thread_can_run): Delete.
	(sol_thread_alive): Adjust to use find_target_beneath.
	(sol_thread_stop): Delete.
	(rw_common): Use target_write_memory or target_read_memory.
	(ps_lgetregs, ps_lgetfpregs): Use target_fetch_registers.
	(ps_lsetregs, ps_lsetfpregs): Use target_store_registers.
	(solaris_pid_to_str): Remove check for libthread_db initialization
	failing.
	(sol_find_new_threads): Remove check for libthread_db
	initialization failing, or for an invalid inferior_ptid.  Adjust
	to use find_target_beneath.
	(sol_core_open, sol_core_close, sol_core_detach,
	sol_core_files_info, sol_find_memory_regions,
	sol_make_note_section, ignore): Delete.
	(init_sol_thread_ops): Make it a thread_stratum target.  Remove
	unneeded callback settings.
	(init_sol_core_ops): Delete.
	(_initialize_sol_thread): No longer call init_sol_core_ops, set
	procfs_suppress_run, or hack with core_ops.

	* target.h (struct target_ops): Add a target_ops * parameter to
	to_resume, to_fetch_registers, to_store_registers, to_thread_alive
	and to_find_new_threads.
	(target_fetch_registers, target_store_registers)
	(target_thread_alive, target_find_new_threads): Redeclare as
	function.

	* target.c (update_current_target): Do not inherit or de_fault
	to_resume, to_fetch_registers, to_store_registers,
	to_thread_alive, to_find_new_threads.
	(target_resume): Adjust.
	(target_thread_alive, target_find_new_threads): New.
	(debug_to_resume, debug_to_fetch_registers): Delete.
	(target_fetch_registers): New.
	(debug_to_store_registers): Delete.
	(target_store_registers): New.
	(debug_to_thread_alive, debug_to_find_new_threads): Delete.
	(setup_target_debug): Adjust.

	* gdbcore.h (core_ops): Delete declaration.

	* inf-ptrace.c, linux-nat.c, remote.c, amd64-linux-nat.c,
	inf-child.c, linux-thread-db.c, bsd-uthread.c, inf-ttrace.c,
	i386-sol2-tdep.c, darwin-nat.c, gnu-nat.c, go32-nat.c,
	hpux-thread.c, i386-linux-nat.c, i386fbsd-nat.c, monitor.c,
	nto-procfs.c, remote-m32r-sdi.c, remote-mips.c, windows-nat.c,
	alphabsd-nat.c, amd64bsd-nat.c, arm-linux-nat.c, armnbsd-nat.c,
	bsd-kvm.c, hppa-hpux-nat.c, hppa-linux-nat.c, hppabsd-nat.c,
	hppanbsd-nat.c, i386-darwin-nat.c, i386bsd-nat.c,
	ia64-linux-nat.c, m32r-linux-nat.c, m68kbsd-nat.c,
	m68klinux-nat.c, m88kbsd-nat.c, mips-linux-nat.c,
	mips64obsd-nat.c, mipsnbsd-nat.c, ppc-linux-nat.c, ppcnbsd-nat.c,
	ppcobsd-nat.c, remote-sim.c, rs6000-nat.c, s390-nat.c,
	shnbsd-nat.c, sparc-nat.c, sparc-nat.h, spu-linux-nat.c,
	vaxbsd-nat.c, xtensa-linux-nat.c: Adjust to target_ops changes.

	* gdbarch.sh (core_pid_to_str): New gdbarch callback.
	* gdbarch.h, gdbarch.c: Regenerate.

	* sol2-tdep.c: Include "inferior.h".
	(sol2_core_pid_to_str): New.
	* sol2-tdep.h (sol2_core_pid_to_str): Declare.

	* amd64-sol2-tdep.c (amd64_sol2_init_abi): Set it.
	* sparc-sol2-tdep.c (sparc32_sol2_init_abi): Set it.
	* sparc64-sol2-tdep.c (sparc64_sol2_init_abi): Set it.
	* i386-sol2-tdep.c (i386_sol2_init_abi): Set it.
@
text
@d487 1
a487 1
	  i386_linux_fetch_inferior_registers (regcache, regno);
@


1.88
log
@        Updated copyright notices for most files.
@
text
@d453 2
a454 1
i386_linux_fetch_inferior_registers (struct regcache *regcache, int regno)
d526 2
a527 1
i386_linux_store_inferior_registers (struct regcache *regcache, int regno)
d749 2
a750 1
i386_linux_resume (ptid_t ptid, int step, enum target_signal signal)
@


1.87
log
@	* breakpoint.h (breakpoint_restore_shadows): New
	declaration.
	* breakpoint.c (breakpoint_restore_shadows): New.
	(read_memory_nobpt): Delete.
	* gdbcore.h (read_memory_nobpt): Delete declaration.
	* target.c (memory_xfer_partial): Call
	breakpoint_restore_shadows.
	(restore_show_memory_breakpoints)
	(make_show_memory_beakpoints_cleanup): New.
	(show_memory_breakpoints): New.
	* target.h (make_show_memory_beakpoints_cleanup): Declare.
	* ppc-linux-tdep.c (ppc_linux_memory_remove_breakpoint):
	Make sure we see memory breakpoints when checking if
	breakpoint is still there.
	* alpha-tdep.c, alphanbsd-tdep.c, frame.c, frv-tdep.c,
	hppa-linux-tdep.c, hppa-tdep.c, i386-linux-nat.c, i386-tdep.c,
	m68klinux-tdep.c, mips-tdep.c, mn10300-tdep.c, s390-tdep.c,
	sparc-tdep.c: Use target_read_memory instead of read_memory_nobpt.
@
text
@d3 2
a4 2
   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
   Free Software Foundation, Inc.
@


1.86
log
@	* Makefile.in (i386-nat.o): Update.
	* amd64-linux-nat.c (_initialize_amd64_linux_nat): Call
	i386_use_watchpoints.
	* i386-linux-nat.c (_initialize_i386_linux_nat): Call
	i386_use_watchpoints.
	* i386-nat.c (i386_stopped_data_address): Take two arguments.
	(i386_stopped_by_watchpoint): Update call.
	(i386_can_use_hw_breakpoint, i386_use_watchpoints): New.
	* config/i386/nm-i386.h: Conditionalize definitions on
	! I386_WATCHPOINTS_IN_TARGET_VECTOR.
	(i386_use_watchpoints): Declare.
	(i386_stopped_data_address): Update.
	* config/i386/nm-linux.h (I386_WATCHPOINTS_IN_TARGET_VECTOR): Define.
	* config/i386/nm-linux64.h (I386_WATCHPOINTS_IN_TARGET_VECTOR): Define.
@
text
@d773 1
a773 1
      if (read_memory_nobpt (pc, buf, LINUX_SYSCALL_LEN) == 0
@


1.85
log
@	Updated copyright notices for most files.
@
text
@d823 2
@


1.84
log
@2007-10-09  Markus Deuling  <deuling@@de.ibm.com>

	* i386-linux-nat.c (fetch_register): Use get_regcache_arch to get at
	the current architecture by regcache.
	(store_register, supply_gregset, fill_gregset, i386_linux_resume)
	(i386_linux_fetch_inferior_registers)
	(i386_linux_store_inferior_registers): Likewise.
	* i386gnu-nat.c (gnu_fetch_registers, gnu_store_registers): Likewise.
	* i386-nto-tdep.c (i386nto_supply_gregset): Likewise.
	* i386v4-nat.c (supply_fpregset, fill_fpregset): Likewise.
	* i386-tdep.c (i386_unwind_pc): Replace current_gdbarch by gdbarch.
	(i386_extract_return_value, i386_store_return_value): Likewise.
	* i386-tdep.c (i386_frame_prev_register): Use get_frame_arch to get at
	the current architecture by frame_info.
	(i386_sigtramp_frame_cache, i386_get_longjmp_target)
	(i386_register_to_value, i386_value_to_register): Likewise.
@
text
@d3 1
a3 1
   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
@


1.83
log
@	* linux-nat.c (linux_nat_new_thread): New variable.
	(linux_child_follow_fork): Set inferior_ptid to include LWP ID.  Use
	linux_nat_switch_fork.
	(lwp_list): Make public.
	(add_lwp): Call linux_nat_new_thread.
	(lin_lwp_attach_lwp, linux_nat_attach): Call add_lwp after stopping
	the new thread.
	(resume_callback): Clear lp->siginfo.  Remove unused variable.
	(linux_nat_resume): Assert that the LWP list is already initialized.
	Clear lp->siginfo.
	(save_siginfo): New.
	(stop_wait_callback, linux_nat_wait): Call it.
	(linux_nat_set_new_thread, linux_nat_get_siginfo): New.
	* linux-nat.h (struct lwp_info): Add siginfo.
	(lwp_list, linux_nat_set_new_thread, linux_nat_get_siginfo): Declare.
	(ALL_LWPS): Define.

	* amd64-linux-nat.c (amd64_linux_dr): New.
	(amd64_linux_dr_get): Take a PTID argument.  Correct typo.
	(amd64_linux_dr_set): Take a PTID argument.
	(amd64_linux_dr_set_control, amd64_linux_dr_set_addr): Use ALL_LWPS.
	(amd64_linux_dr_reset_addr): Use amd64_linux_dr_set_addr.
	(amd64_linux_dr_get_status): Pass inferior_ptid to amd64_linux_dr_get.
	(amd64_linux_new_thread): New.
	(_initialize_amd64_linux_nat): Call linux_nat_set_new_thread.
	* i386-linux-nat.c (i386_linux_dr): New.
	(i386_linux_dr_get, i386_linux_dr_set): Take a PTID argument.
	(i386_linux_dr_set_control, i386_linux_dr_set_addr): Use ALL_LWPS.
	(i386_linux_dr_reset_addr): Use i386_linux_dr_set_addr.
	(i386_linux_dr_get_status): Pass inferior_ptid to i386_linux_dr_get.
	(i386_linux_new_thread): New.
	(i386_linux_resume): Remove unnecessary PID check.
	(_initialize_i386_linux_nat): Call linux_nat_set_new_thread.
	* ia64-linux-nat.c (enable_watchpoints_in_psr): Take PTID argument.
	(fetch_debug_register, fetch_debug_register_pair): Delete.
	(debug_registers): New.
	(ia64_linux_insert_watchpoint, ia64_linux_remove_watchpoint): Use
	ALL_LWPS and debug_registers.
	(ia64_linux_new_thread): New.
	(ia64_linux_stopped_data_address): Use linux_nat_get_siginfo.
	(_initialize_ia64_linux_nat): Call linux_nat_set_new_thread.
	* ppc-linux-nat.c (last_stopped_data_address): Delete.
	(saved_dabr_value): New.
	(ppc_linux_insert_watchpoint, ppc_linux_remove_watchpoint): Use
	ALL_LWPS.
	(ppc_linux_new_thread): New.
	(ppc_linux_stopped_data_address): Use linux_nat_get_siginfo.
	(ppc_linux_stopped_by_watchpoint): Call ppc_linux_stopped_data_address.
	(_initialize_ppc_linux_nat): Call linux_nat_set_new_thread.
	* s390-nat.c (s390_stopped_by_watchpoint): Clear the watchpoint status
	after reading it.
	(s390_fix_watch_points): Take a PTID argument.
	(s390_insert_watchpoint, s390_remove_watchpoint): Use ALL_LWPS.
	(_initialize_s390_nat): Call linux_nat_set_new_thread.
@
text
@d164 1
a164 1
	   gdbarch_register_name (current_gdbarch, regno),
d192 1
a192 1
	   gdbarch_register_name (current_gdbarch, regno),
d212 2
a213 1
  if (I386_LINUX_ORIG_EAX_REGNUM < gdbarch_num_regs (current_gdbarch))
d234 2
a235 1
      && I386_LINUX_ORIG_EAX_REGNUM < gdbarch_num_regs (current_gdbarch))
d463 1
a463 1
      for (i = 0; i < gdbarch_num_regs (current_gdbarch); i++)
d535 1
a535 1
      for (i = 0; i < gdbarch_num_regs (current_gdbarch); i++)
d761 2
a762 2
      regcache_cooked_read_unsigned (regcache,
				     gdbarch_pc_regnum (current_gdbarch), &pc);
@


1.82
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d582 2
d585 1
a585 1
i386_linux_dr_get (int regnum)
d590 3
a592 4
  /* FIXME: kettenis/2001-01-29: It's not clear what we should do with
     multi-threaded processes here.  For now, pretend there is just
     one thread.  */
  tid = PIDGET (inferior_ptid);
d613 1
a613 1
i386_linux_dr_set (int regnum, unsigned long value)
d617 3
a619 4
  /* FIXME: kettenis/2001-01-29: It's not clear what we should do with
     multi-threaded processes here.  For now, pretend there is just
     one thread.  */
  tid = PIDGET (inferior_ptid);
d631 6
a636 1
  i386_linux_dr_set (DR_CONTROL, control);
d642 3
d647 3
a649 1
  i386_linux_dr_set (DR_FIRSTADDR + regnum, addr);
d655 1
a655 3
  gdb_assert (regnum >= 0 && regnum <= DR_LASTADDR - DR_FIRSTADDR);

  i386_linux_dr_set (DR_FIRSTADDR + regnum, 0L);
d661 12
a672 1
  return i386_linux_dr_get (DR_STATUS);
a750 6
  if (pid == -1)
    /* Resume all threads.  */
    /* I think this only gets used in the non-threaded case, where "resume
       all threads" and "resume inferior_ptid" are the same.  */
    pid = PIDGET (inferior_ptid);

d834 1
@


1.81
log
@2007-07-16  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-linux-nat.c (fetch_regs): Work around gcc 3.4 alias
	warning bug.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d19 1
a19 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.80
log
@2007-06-18  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (SP_REGNUM): Replace by gdbarch_sp_regnum.
	* v850-tdep.c (v850_unwind_sp): Likewise.
	* std-regs.c (value_of_builtin_frame_sp_reg): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh-tdep.c (sh_push_dummy_call_fpu, sh_push_dummy_call_nofpu)
	(sh_dwarf2_frame_init_reg, sh_frame_cache, sh_frame_prev_register)
	(sh_unwind_sp): Likewise.
	* sh64-tdep.c (sh64_push_dummy_call, sh64_frame_cache)
	(sh64_frame_prev_register, sh64_unwind_sp): Likewise.
	* rs6000-tdep.c (rs6000_push_dummy_call, rs6000_unwind_dummy_id)
	(rs6000_frame_cache): Likewise.
	* rs6000-nat.c (store_register): Likewise.
	* remote-mips.c (mips_wait): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_cache): Likewise.
	* ppcobsd-nat.c (ppcobsd_supply_pcb): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_sigtramp_cache_init): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* m32r-rom.c (m32r_supply_register): Likewise.
	* frame.c (frame_sp_unwind): Likewise.
	* mips-tdep.c (mips_insn16_frame_cache)
	(mips_insn32_frame_cache): Likewise (comment).
	* m68klinux-nat.c (supply_gregset): Likewise.
	* m68k-tdep.c (m68k_get_longjmp_target): Likewise.
	* ia64-tdep.c (ia64_frame_prev_register): Likewise.
	* i386-tdep.c (i386_get_longjmp_target): Likewise.
	* dwarf2-frame.c (dwarf2_frame_default_init_reg): Likewise.
	* cris-tdep.c (cris_regnums, cris_sigcontext_addr)
	(cris_sigtramp_frame_unwind_cache, cris_push_dummy_call)
	(cris_scan_prologue, crisv32_scan_prologue, cris_unwind_sp)
	(cris_register_type, crisv32_register_type)
	(cris_dwarf2_frame_init_reg): Likewise.
	* arch-utils.c (legacy_virtual_frame_pointer): Likewise.
	* amd64-tdep.c (amd64_frame_prev_register): Likewise.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Likewise.
	* libunwind-frame.c (libunwind_frame_cache): Likewise.

	* gdbarch.sh (PC_REGNUM): Replace by gdbarch_pc_regnum.
	* regcache.c (read_pc_pid, generic_target_write_pc): Likewise.
	* xtensa-tdep.c (xtensa_register_type, xtensa_supply_gregset)
	(xtensa_unwind_pc, xtensa_frame_cache, xtensa_frame_prev_register)
	(xtensa_extract_return_value, xtensa_store_return_value): Likewise.
	* v850-tdep.c (v850_unwind_pc): Likewise.
	* stack.c (frame_info): Likewise.
	* sh-tdep.c (sh_generic_show_regs, sh3_show_regs, sh2e_show_regs)
	(sh2a_show_regs, sh2a_nofpu_show_regs, sh3e_show_regs)
	(sh3_dsp_show_regs, sh4_show_regs, sh4_nofpu_show_regs)
	(sh_dwarf2_frame_init_reg, sh_frame_prev_register, sh_unwind_pc)
	(sh_dsp_show_regs): Likewise.
	* shnbsd-tdep.c (shnbsd_supply_gregset)
	(shnbsd_collect_gregset): Likewise.
	* shnbsd-nat.c (GETREGS_SUPPLIES): Likewise.
	* sh64-tdep.c (sh64_compact_reg_base_num, sh64_show_media_regs)
	(sh64_frame_prev_register, sh64_unwind_pc): Likewise.
	* rs6000-tdep.c (ppc_supply_gregset, ppc_collect_gregset)
	(6000_register_reggroup_p, rs6000_unwind_pc)
	(rs6000_frame_cache): Likewise.
	* rs6000-nat.c (regmap, rs6000_fetch_inferior_registers)
	(rs6000_store_inferior_registers): Likewise.
	* remote-mips.c (mips_wait, mips_load): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_cache): Likewise.
	* ppcobsd-nat.c (ppcobsd_supply_pcb): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_sigtramp_cache_init): Likewise.
	* ppcnbsd-nat.c (getregs_supplies, ppcnbsd_supply_pcb): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* ppc-linux-nat.c (ppc_register_u_addr, fetch_ppc_registers)
	(store_ppc_registers, fill_gregset): Likewise.
	* mips-tdep.c (mips_stub_frame_cache, mips_gdbarch_init): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_supply_reg, mipsnbsd_fill_reg): Likewise.
	* mipsnbsd-nat.c (getregs_supplies): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_unwind_pc): Likewise.
	* m68klinux-nat.c (supply_gregset): Likewise.
	* irix5-nat.c (fill_gregset): Likewise.
	* i386-tdep.c (i386_unwind_pc): Likewise.
	* i386-linux-nat.c (i386_linux_resume): Likewise.
	* frame.c (get_prev_frame_1): Likewise.
	* dwarf2-frame.c (dwarf2_frame_default_init_reg): Likewise.
	* dbug-rom.c (dbug_supply_register): Likewise.
	* cris-tdep.c (cris_sigtramp_frame_unwind_cache, cris_scan_prologue)
	(crisv32_scan_prologue, cris_unwind_pc, cris_register_size)
	(cris_register_type, crisv32_register_type, crisv32_register_name)
	(cris_dwarf2_frame_init_reg, find_step_target)
	(cris_software_single_step, cris_supply_gregset)
	(cris_regnums): Likewise.
	* alpha-linux-nat.c (alpha_linux_register_u_offset): Likewise.
	* aix-thread.c (special_register_p, supply_sprs64, supply_sprs32)
	(fill_sprs64, fill_sprs32, store_regs_user_thread): Likewise.
	* mips-linux-tdep.c (mips_linux_write_pc): Likewise.

	* gdbarch.sh (PS_REGNUM): Replace by gdbarch_ps_regnum.
	* dbug-rom.c (dbug_supply_register): Likewise.
	* xtensa-tdep.c (xtensa_supply_gregset, xtensa_frame_cache)
	(xtensa_frame_prev_register, xtensa_push_dummy_call): Likewise.
	* win32-nat.c (win32_resume): Likewise.
	* std-regs.c (value_of_builtin_frame_ps_reg)
	(value_of_builtin_frame_pc_reg): Likewise.
	* m68k-tdep.c (m68k_register_type): Likewise.
	* m68klinux-nat.c (supply_gregset): Likewise.

	* gdbarch.sh (FP0_REGNUM): Replace by gdbarch_fp0_regnum.
	* sh-tdep.c (sh_extract_return_value_fpu, sh_store_return_value_fpu)
	(sh2e_show_regs, sh2a_show_regs, sh3e_show_regs, sh4_show_regs)
	(sh_sh2a_register_type, sh_sh3e_register_type, sh_sh4_register_type)
	(fv_reg_base_num, dr_reg_base_num): Likewise.
	* sh64-tdep.c (sh64_fv_reg_base_num, sh64_dr_reg_base_num)
	(sh64_fpp_reg_base_num, sh64_compact_reg_base_num, sh64_push_dummy_call)
	(sh64_extract_return_value, sh64_store_return_value)
	(sh64_show_media_regs, sh64_show_compact_regs, sh64_register_type)
	(sh64_do_fp_register, sh64_media_print_registers_info): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers)
	(invalidate_cache): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_supply_fpreg)
	(mipsnbsd_fill_fpreg): Likewise.
	* mipsnbsd-nat.c (mipsnbsd_fetch_inferior_registers)
	(mipsnbsd_store_inferior_registers): Likewise.
	* mips-linux-tdep.c (mips_supply_fpregset, mips_fill_fpregset)
	(mips64_supply_fpregset, mips64_fill_fpregset): Likewise.
	* mips-linux-nat.c (mips64_linux_register_addr): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_convert_register_p): Likewise.
	* m68klinux-nat.c (getfpregs_supplies, supply_fpregset)
	(fill_fpregset): Likewise.
	* irix5-nat.c (supply_fpregset, fill_fpregset): Likewise.
	* i386-tdep.h (struct_return): Likewise (comment).
	* i386-nto-tdep.c (i386nto_register_area): Likewise.
	* go32-nat.c (fetch_register, go32_fetch_registers, store_register)
	(go32_store_registers): Likewise.
	* alpha-tdep.c (alpha_next_pc): Likewise.
	* alpha-linux-nat.c (alpha_linux_register_u_offset): Likewise.
	* alphabsd-nat.c (alphabsd_fetch_inferior_registers)
	(alphabsd_store_inferior_registers): Likewise.
	* core-regset.c (fetch_core_registers): Likewise.
	* i386v4-nat.c (supply_fpregset, fill_fpregset): Likewise.

	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d249 1
d264 1
a264 1
  supply_gregset (regcache, (const elf_gregset_t *) &regs);
@


1.79
log
@	* regcache.c (struct regcache): Add ptid_t member.
	(regcache_xmalloc): Initialize it.
	(regcache_cpy_no_passthrough): Do not refer to current_regcache.
	(regcache_dup): Likewise.
	(regcache_dup_no_passthrough): Likewise.
	(current_regcache): Make static.
	(registers_ptid): Remove variable.
	(get_thread_regcache): New function.
	(get_current_regcache): New function.
	(registers_changed): Implement by freeing current regcache.
	(regcache_raw_read): Do not refer to current_regcache.  Set
	inferior_ptid to regcache->ptid while calling target routines.
	(regcache_raw_write): Likewise.
	(regcache_raw_supply): Do not refer to current_regcache.
	(read_pc_pid): Use thread regcache.  Do not modify inferior_ptid.
	(write_pc_pid): Likewise.
	(build_regcache): Remove.
	(_initialize_regcache): Do not call DEPRECATED_REGISTER_GDBARCH_SWAP
	or deprecated_register_gdbarch_swap.  Do not initialize
	registers_ptid.
	* regcache.h (get_current_regcache): Add prototype.
	(get_thread_regcache): Likewise.
	(current_regcache): Remove declaration.

	* corelow.c (core_open): Replace current_regcache by
	get_current_regcache ().
	* frame.c (frame_pop): Likewise.
	(put_frame_register): Likewise.
	(get_current_frame, create_new_frame): Likewise.
	* mi/mi-main.c (mi_cmd_data_write_register_values): Likewise.
	* stack.c (return_command): Likewise.
	* infcall.c (call_function_by_hand): Likewise.
	* infrun.c (resume): Likewise.
	(save_inferior_status, restore_inferior_status): Likewise.
	* linux-fork.c (fork_load_infrun_state): Likewise.
	(fork_save_infrun_state): Likewise.
	* win32-nat.c (win32_resume): Likewise.
	* i386fbsd-nat.c (i386fbsd_resume): Likewise.
	* monitor.c (monitor_wait): Likewise.
	* remote.c (remote_wait): Likewise.
	* remote-mips.c (mips_wait): Likewise.

	* bsd-kvm.c (bsd_kvm_open): Likewise
	(bsd_kvm_proc_cmd, bsd_kvm_pcb_cmd): Likewise.
	* fbsd-nat.c (fbsd_make_corefile_notes): Likewise.
	* i386-linux-nat.c (i386_linux_resume): Likewise.
	* ia64-linux-nat.c (ia64_linux_insert_watchpoint): Likewise.
	(ia64_linux_stopped_data_address): Likewise.

	* frv-tdep.c (frv_fdpic_loadmap_addresses): Likewise.
	* m32c-tdep.c (m32c_virtual_frame_pointer): Likewise.
	* mep-tdep.c (current_me_module, current_options): Likewise.
	* mips-tdep.c (deprecated_mips_set_processor_regs_hack): Likewise.

	* linux-nat.c (linux_nat_do_thread_registers): Use thread
	regcache instead of current_regcache.  Call target_fetch_registers.
	(linux_nat_corefile_thread_callback): Update call site.
	(linux_nat_do_registers): Likewise.
	* procfs.c (procfs_do_thread_registers): Use thread regcache instead
	of current_regcache.
	(procfs_make_note_section): Likewise.
	* proc-service.c (ps_lgetregs, ps_lsetregs): Likewise.
	(ps_lgetfpregs, ps_lsetfpregs): Likewise.
	* sol-thread.c (ps_lgetregs, ps_lsetregs): Likewise.
	(ps_lgetfpregs, ps_lsetfpregs): Likewise.
@
text
@d747 2
a748 1
      regcache_cooked_read_unsigned (regcache, PC_REGNUM, &pc);
@


1.78
log
@2007-06-09  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (REGISTER_NAME): Replace by gdbarch_register_name.
	* tracepoint.c (scope_info): Likewise.
	* target.c (debug_print_register): Likewise.
	* stack.c (frame_info): Likewise.
	* sh-tdep.c (sh_register_reggroup_p): Likewise.
	* sh64-tdep.c (sh64_do_fp_register, sh64_do_register)
	(sh64_media_print_registers_info)
	(sh64_compact_print_registers_info): Likewise.
	* rs6000-tdep.c (rs6000_register_reggroup_p): Likewise.
	* remote-sim.c (gdbsim_fetch_register): Likewise.
	* remote.c (packet_reg): Likewise (comment).
	* reggroups.c (default_register_reggroup_p): Likewise.
	* regcache.c (regcache_dump): Likewise.
	* printcmd.c (address_info): Likewise.
	* ppc-linux-nat.c (fetch_register, store_register): Likewise.
	* mt-dep.c (mt_registers_info): Likewise.
	* mn10300-tdep.c (mn10300_dwarf2_reg_to_regnum): Likewise (comment).
	* mips-tdep.c (mips_register_reggroup_p, mips_read_fp_register_single)
	(mips_read_fp_register_double, mips_print_fp_register)
	(mips_print_register, print_gp_register_row, mips_print_registers_info)
	(mips_register_sim_regno): Likewise.
	* m68klinux-nat.c (regmap, fetch_register, store_register): Likewise.
	* inf-ptrace.c (inf_ptrace_fetch_register)
	(inf_ptrace_store_register): Likewise.
	* infcmd.c (default_print_registers_info): Likewise.
	* ia64-linux-nat.c (ia64_linux_fetch_register)
	(ia64_linux_store_register): Likewise.
	* i386-linux-nat.c (fetch_register, store_register): Likewise.
	* i386gnu-nat.c (gnu_fetch_registers, gnu_store_registers): Likewise.
	* hppa-linux-nat.c (fetch_register, store_register): Likewise.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register)
	(hppa_hpux_store_register): Likewise.
	* findvar.c (locate_var_value): Likewise.
	* dwarf2loc.c (locexpr_describe_location): Likewise.
	* dwarf2-frame.c (execute_cfa_program): Likewise.
	* arm-tdep.c (arm_push_dummy_call): Likewise.
	* arch-utils.c (legacy_register_sim_regno): Likewise.
	* alpha-tdep.c (alpha_register_reggroup_p): Likewise.
	* alpha-nat.c (fetch_osf_core_registers): Likewise.
	* mi/mi-main.c (mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers, mi_cmd_data_list_register_values)
	(mi_cmd_data_write_register_values): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d741 1
a741 2
      struct cleanup *old_chain = save_inferior_ptid ();
      struct regcache *regcache = current_regcache;
a746 1
      inferior_ptid = pid_to_ptid (pid);
a784 2

      do_cleanups (old_chain);
@


1.77
log
@2007-05-31  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (NUM_REGS): Replace by gdbarch_num_regs.
	* i386-tdep.c (i386_dbx_reg_to_regnum)
	(i386_svr4_reg_to_regnum): Likewise.
	* inf-ptrace.c (inf_ptrace_fetch_registers)
	(inf_ptrace_store_registers): Likewise.
	* corelow.c (get_core_registers): Likewise.
	* i386-linux-nat.c (supply_gregset, fill_gregset)
	(i386_linux_fetch_inferior_registers)
	(i386_linux_store_inferior_registers): Likewise.
	* remote.c (init_remote_state,packet_reg_from_regnum)
	(packet_reg_from_pnum,process_g_packet,remote_fetch_registers)
	(remote_prepare_to_store,store_registers_using_G)
	(remote_store_registers,remote_arch_state): Likewise.
	* tracepoint.c (encode_actions): Likewise.
	* mi/mi-main.c (mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers,mi_cmd_data_list_register_values)
	(mi_cmd_data_write_register_values): Likewise.
	* tui/tui-regs.c (tui_show_register_group)
	(tui_show_register_group): Likewise.
	* xtensa-tdep.h (FP_ALIAS): Likewise.
	* xtensa-tdep.c (xtensa_register_name,xtensa_register_type)
	(xtensa_reg_to_regnum,xtensa_pseudo_register_read)
	(xtensa_pseudo_register_write,xtensa_register_reggroup_p): Likewise.
	* win32-nat.c (do_win32_fetch_inferior_registers)
	(do_win32_store_inferior_registers,fetch_elf_core_registers
	* user-regs.h: Likewise (comment).
	* user-regs.c (user_reg, user_reg_map_name_to_regnum): Likewise.
	* trad-frame.c (trad_frame_alloc_saved_regs): Likewise.
	* target-descriptions.h: Likewise (comment).
	* target-descriptions.c (tdesc_use_registers): Likewise (comment).
	* target.c (debug_print_register): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh64-tdep.c (sh64_do_pseudo_register,sh64_print_register)
	(sh64_media_print_registers_info)
	(sh64_compact_print_registers_info): Likewise.
	* rs6000-tdep.c (rs6000_register_sim_regno): Likewise.
	* rs6000-nat.c (fetch_register,store_register): Likewise.
	* remote-sim.c (one2one_register_sim_regno,gdbsim_fetch_register)
	(gdbsim_fetch_register,gdbsim_store_register): Likewise.
	* remote-mips.c (mips_fetch_registers,mips_store_registers): Likewise.
	* remote-m32r-sdi.c (m32r_fetch_registers)
	(m32r_store_registers): Likewise.
	* reggroups.c (default_register_reggroup_p): Likewise.
	* regcache.c (init_regcache_descr,register_size,regcache,regcache_save)
	(regcache_restore,regcache_dump): Likewise.
	* monitor.c (monitor_fetch_registers,monitor_store_registers): Likewise.
	* mips-tdep.c (mips_xfer_register,mips_register_name)
	(mips_register_reggroup_p,mips_pseudo_register_read)
	(mips_pseudo_register_write,mips_convert_register_p,mips_register_type)
	(mips_unwind_pc,mips_unwind_sp,mips_unwind_dummy_id,set_reg_offset)
	(mips16_scan_prologue,mips_insn16_frame_cache,reset_saved_regs)
	(mips32_scan_prologue,mips_insn32_frame_cache,read_next_frame_reg)
	(mips_n32n64_return_value,mips_o32_return_value,mips_o64_return_value)
	(print_gp_register_row,mips_print_registers_info)
	(mips_stab_reg_to_regnum,mips_dwarf_dwarf2_ecoff_reg_to_regnum)
	(mips_register_sim_regno): Likewise.
	* mips-linux-tdep.c (mips_linux_o32_sigframe_init)
	(mips_linux_n32n64_sigframe_init): Likewise.
	* mips-linux-nat.c (mips_linux_register_addr)
	(mips64_linux_register_addr): Likewise.
	* findvar.c (value_of_register): Likewise.
	* infcmd.c (default_print_registers_info,registers_info)
	(print_vector_info,print_float_info): Likewise.
	* mips64obsd-tdep.c (mips64obsd_sigframe_init): Likewise.
	* inf-child.c (inf_child_fetch_inferior_registers): Likewise.
	* m68k-tdep.c (m68k_dwarf_reg_to_regnum): Likewise.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache(: Likewise.
	* m32r-tdep.c (m32r_frame_unwind_cache): Likewise.
	* ia64-linux-nat.c (ia64_register_addr,ia64_cannot_fetch_register)
	(ia64_cannot_store_register,ia64_linux_fetch_registers)
	(ia64_linux_store_registers): Likewise.
	* hpux-thread.c (hpux_thread_fetch_registers)
	(hpux_thread_store_registers): Likewise.
	* h8300-tdep.c (E_PSEUDO_CCR_REGNUM,E_PSEUDO_EXR_REGNUM)
	(h8300_init_frame_cache,h8300_frame_cache,h8300_frame_prev_register)
	(h8300_register_type): Likewise.
	* dwarf2-frame.c (dwarf2_frame_cache)
	(dwarf2_frame_state_alloc_regs): Likewise.
	* cris-tdep.c (cris_register_size,cris_cannot_fetch_register)
	(cris_cannot_store_register,crisv32_cannot_fetch_register)
	(crisv32_cannot_store_register,cris_register_name): Likewise.
	* avr-tdep.c (avr_frame_unwind_cache): Likewise.
	* arch-utils.c (legacy_register_sim_regno)
	(legacy_virtual_frame_pointer): Likewise.
	* arm-tdep.c (arm_make_prologue_cache,arm_register_sim_regno):Likewise.
	* arm-tdep.h: Likewise (comment).
	* frv-tdep.c (frv_register_sim_regno): Likewise.
	* m68klinux-nat.c (old_fetch_inferior_registers)
	(old_store_inferior_registers): Likewise.
	* m32c-tdep.c (m32c_virtual_frame_pointer): Likewise.
	* irix5-nat.c (fetch_core_registers): Likewise.
	* hppa-tdep.c (hppa_frame_cache): Likewise.
	* hppa-linux-nat.c (hppa_linux_register_addr)
	(hppa_linux_fetch_inferior_registers)
	(hppa_linux_store_inferior_registers): Likewise.
	* hppa-hpux-nat.c (hppa_hpux_fetch_inferior_registers)
	(hppa_hpux_store_inferior_registers): Likewise.
	* amd64-nat.c (amd64_native_gregset_reg_offset)
	(amd64_supply_native_gregset,amd64_collect_native_gregset): Likewise.
	* dbug-rom.c (dbug_regname): Likewise.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache)
	(HARD_PAGE_REGNUM (comment)): Likewise.
	* gdbarch.sh (NUM_PSEUDO_REGS): Replace by gdbarch_num_pseudo_regs.
	* i386-tdep.c (i386_dbx_reg_to_regnum)
	(i386_svr4_reg_to_regnum): Likewise.
	* mi/mi-main.c (mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers,mi_cmd_data_list_register_values)
	(mi_cmd_data_write_register_values): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
	* tui/tui-regs.c (tui_show_register_group): Likewise.
	* xtensa-tdep.h (FP_ALIAS): Likewise.
	* user-regs.h: Likewise (comment).
	* user-regs.c (user_reg, user_reg_map_name_to_regnum): Likewise.
	* trad-frame.c (trad_frame_alloc_saved_regs): Likewise.
	* target-descriptions.h: Likewise (comment).
	* target.c (debug_print_register): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh64-tdep.c (sh64_print_register,sh64_media_print_registers_info)
	(sh64_compact_print_registers_info): Likewise.
	* rs6000-tdep.c (rs6000_register_sim_regno): Likewise.
	* regcache.c (init_regcache_descr,register_size,regcache,regcache_save
	(regcache_restore,regcache_dump): Likewise.
	* mips-tdep.c (print_gp_register_row,mips_print_registers_info)
	(mips_dwarf_dwarf2_ecoff_reg_to_regnum)
	(mips_stab_reg_to_regnum): Likewise.
	* findvar.c (value_of_register): Likewise.
	* infcmd.c (default_print_registers_info,registers_info)
	(print_vector_info,print_float_info): Likewise.
	* m68k-tdep.c (m68k_dwarf_reg_to_regnum): Likewise.
	* h8300-tdep.c (h8300_register_type): Likewise.
	* dwarf2-frame.c (dwarf2_frame_cache): Likewise.
	* frame.h (SIZEOF_FRAME_SAVED_REGS): Likewise.
	* xtensa-tdep.c (xtensa_register_type,xtensa_reg_to_regnum)
	(xtensa_pseudo_register_read,xtensa_pseudo_register_write): Likewise.
	* parse.c: Remove comment.
	* gdbarch.c, gdbarch.h: Regenerate
@
text
@d165 2
a166 1
    error (_("Couldn't read register %s (#%d): %s."), REGISTER_NAME (regno),
d193 2
a194 1
    error (_("Couldn't write register %s (#%d): %s."), REGISTER_NAME (regno),
@


1.76
log
@	* i386-linux-nat.c (i386_linux_resume): Use regcache functions
	instead of read_register and read_register_pid.

	* ia64-linux-nat.c (enable_watchpoints_in_psr): Use REGCACHE
	argument instead of PTID.  Use regcache functions instead of
	read_register_pid.
	(ia64_linux_insert_watchpoint): Update call.
	(ia64_linux_stopped_data_address): Use regcache functions
	instead of read_register_pid and write_register_pid.
@
text
@d212 1
a212 1
  if (I386_LINUX_ORIG_EAX_REGNUM < NUM_REGS)
d233 1
a233 1
      && I386_LINUX_ORIG_EAX_REGNUM < NUM_REGS)
d460 1
a460 1
      for (i = 0; i < NUM_REGS; i++)
d532 1
a532 1
      for (i = 0; i < NUM_REGS; i++)
@


1.75
log
@	* target.h (struct regcache): Add forward declaration.
	(struct target_ops): Add REGCACHE parameter to to_fetch_registers
	and to_store_registers target operations.
	(target_fetch_registers, target_store_registers): Update.

	* regcache.c (regcache_raw_read): Replace register_cached by
	regcache_valid_p.  Pass regcache to target_fetch_registers.
	(regcache_raw_write): Pass regcache to target_store_registers.

	* arm-linux-nat.c (store_fpregister, store_fpregs, store_register,
	store_regs, store_wmmx_regs): Replace register_cached by
	regcache_valid_p.

	* bsd-kvm.c (bsd_kvm_open, bsd_kvm_proc_cmd): Pass current_regcache
	to target_fetch_registers calls.
	* corelow.c (core_open): Likewise.
	* linux-nat.c (linux_nat_corefile_thread_callback): Likewise.
	* proc-service.c (ps_lgetregs, ps_lsetregs, ps_lgetfpregs,
	ps_lsetfpregs): Likewise.
	* sol-thread.c (ps_lgetregs, ps_lsetregs, ps_lgetfpregs,
	ps_lsetfpregs): Likewise.
	* win32-nat.c (win32_resume): Likewise.
	* ia64-tdep.c (ia64_store_return_value): Pass current_regcache
	to target_store_registers call.
	* rs6000-tdep.c (rs6000_push_dummy_call): Likewise.

	* inferior.h (store_inferior_registers): Update prototype.
	(fetch_inferior_registers): Likewise.
	* gnu-nat.c (gnu_store_registers, gnu_fetch_registers): Likewise.
	* mips-linux-nat.c (super_fetch_registers, super_store_registers):
	Update function pointer signatures.

	* aix-thread.c (aix_thread_fetch_registers): Add REGCACHE parameter,
	use it instead of current_regcache, update calls.
	(aix_thread_store_registers): Likewise.
	* alphabsd-nat.c (alphabsd_fetch_inferior_registers): Likewise.
	(alphabsd_store_inferior_registers): Likewise.
	* amd64bsd-nat.c (amd64bsd_fetch_inferior_registers): Likewise.
	(amd64bsd_store_inferior_registers): Likewise.
	* amd64-linux-nat.c (amd64_linux_fetch_inferior_registers): Likewise.
	(amd64_linux_store_inferior_registers): Likewise.
	* arm-linux-nat.c (fetch_fpregister, fetch_fpregs, store_fpregister,
	store_fpregs, fetch_register, fetch_regs, store_register, store_regs,
	fetch_wmmx_regs, store_wmmx_regs): Likewise.
	(arm_linux_fetch_inferior_registers): Likewise.
	(arm_linux_store_inferior_registers): Likewise.
	* armnbsd-nat.c (fetch_register, fetch_regs, fetch_fp_register,
	fetch_fp_regs, armnbsd_fetch_registers): Likewise.
	(store_register, store_regs, store_fp_register, store_fp_regs,
	armnbsd_store_registers): Likewise.
	* bsd-kvm.c (bsd_kvm_fetch_pcb, bsd_kvm_fetch_registers): Likewise.
	* bsd-uthread.c (bsd_uthread_fetch_registers): Likewise.
	(bsd_uthread_store_registers): Likewise.
	* corelow.c (get_core_registers): Likewise.
	* go32-nat.c (fetch_register, go32_fetch_registers, store_register,
	go32_store_registers): Likewise.
	* hppabsd-nat.c (hppabsd_fetch_registers): Likewise.
	(hppabsd_store_registers): Likewise.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register): Likewise.
	(hppa_hpux_fetch_inferior_registers): Likewise.
	(hppa_hpux_store_register): Likewise.
	(hppa_hpux_store_inferior_registers): Likewise.
	* hppa-linux-nat.c (fetch_register, store_register): Likewise.
	(hppa_linux_fetch_inferior_registers): Likewise.
	(hppa_linux_store_inferior_registers): Likewise.
	* hpux-thread.c (hpux_thread_fetch_registers): Likewise.
	(hpux_thread_store_registers): Likewise.
	* i386bsd-nat.c (i386bsd_fetch_inferior_registers): Likewise.
	(i386bsd_store_inferior_registers): Likewise.
	* i386gnu-nat.c (fetch_fpregs, gnu_fetch_registers, store_fpregs,
	gnu_store_registers): Likewise.
	* i386-linux-nat.c (fetch_register, store_register, fetch_regs,
	store_regs, fetch_fpregs, store_fpregs, fetch_fpxregs, store_fpxregs):
	Likewise.
	(i386_linux_fetch_inferior_registers): Likewise.
	(i386_linux_store_inferior_registers): Likewise.
	* ia64-linux-nat.c (ia64_linux_fetch_register): Likewise.
	(ia64_linux_fetch_registers): Likewise.
	(ia64_linux_store_register): Likewise.
	(ia64_linux_store_registers): Likewise.
	* inf-child.c (inf_child_fetch_inferior_registers): Likewise.
	(inf_child_store_inferior_registers): Likewise.
	* inf-ptrace.c (inf_ptrace_fetch_register): Likewise.
	(inf_ptrace_fetch_registers): Likewise.
	(inf_ptrace_store_register): Likewise.
	(inf_ptrace_store_registers): Likewise.
	* infptrace.c (fetch_register, store_register): Likewise.
	(fetch_inferior_registers, store_inferior_registers): Likewise.
	* m32r-linux-nat.c (fetch_regs, store_regs): Likewise.
	(m32r_linux_fetch_inferior_registers): Likewise.
	(m32r_linux_store_inferior_registers): Likewise.
	* m68kbsd-nat.c (m68kbsd_fetch_inferior_registers): Likewise.
	(m68kbsd_store_inferior_registers): Likewise.
	* m68klinux-nat.c (fetch_register, old_fetch_inferior_registers,
	store_register, old_store_inferior_registers, fetch_regs, store_regs,
	fetch_fpregs, store_fpregs): Likewise.
	(m68k_linux_fetch_inferior_registers): Likewise.
	(m68k_linux_store_inferior_registers): Likewise.
	* m88kbsd-nat.c (m88kbsd_fetch_inferior_registers): Likewise.
	(m88kbsd_store_inferior_registers): Likewise.
	* mips64obsd-nat.c (mips64obsd_fetch_inferior_registers): Likewise.
	(mips64obsd_store_inferior_registers): Likewise.
	* mips-linux-nat.c (mips64_linux_regsets_fetch_registers): Likewise.
	(mips64_linux_regsets_store_registers): Likewise.
	(mips64_linux_fetch_registers): Likewise.
	(mips64_linux_store_registers): Likewise.
	* mipsnbsd-nat.c (mipsnbsd_fetch_inferior_registers): Likewise.
	(mipsnbsd_store_inferior_registers): Likewise.
	* monitor.c (monitor_fetch_register, monitor_store_register): Likewise.
	(monitor_fetch_registers, monitor_store_registers): Likewise.
	* nto-procfs.c (procfs_fetch_registers): Likewise.
	(procfs_store_registers): Likewise.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_spe_register,
	fetch_register, supply_vrregset, fetch_altivec_registers,
	fetch_ppc_registers, ppc_linux_fetch_inferior_registers): Likewise.
	(store_altivec_register, store_spe_register, store_register,
	fill_vrregset, store_altivec_registers, store_ppc_registers,
	ppc_linux_store_inferior_registers): Likewise.
	* ppcnbsd-nat.c (ppcnbsd_fetch_inferior_registers): Likewise.
	(ppcnbsd_store_inferior_registers): Likewise.
	* ppcobsd-nat.c (ppcobsd_fetch_registers): Likewise.
	(ppcobsd_store_registers): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* remote.c (fetch_register_using_p, process_g_packet,
	fetch_registers_using_g, remote_fetch_registers): Likewise.
	(store_register_using_P, store_registers_using_G,
	remote_store_registers): Likewise.
	* remote-m32r-sdi.c (m32r_fetch_registers, m32r_fetch_register,
	m32r_store_register, m32r_store_register): Likewise.
	* remote-mips.c (mips_fetch_registers, mips_store_registers): Likewise.
	* remote-sim.c (gdbsim_fetch_register): Likewise.
	(gdbsim_store_register): Likewise.
	* rs6000-nat.c (fetch_register, store_register): Likewise.
	(rs6000_fetch_inferior_registers): Likewise.
	(rs6000_store_inferior_registers): Likewise.
	* s390-nat.c (fetch_regs, store_regs): Likewise.
	(fetch_fpregs, store_fpregs): Likewise.
	(s390_linux_fetch_inferior_registers): Likewise.
	(s390_linux_store_inferior_registers): Likewise.
	* shnbsd-nat.c (shnbsd_fetch_inferior_registers): Likewise.
	(shnbsd_store_inferior_registers): Likewise.
	* sol-thread.c (sol_thread_fetch_registers): Likewise.
	(sol_thread_store_registers): Likewise.
	* sparc-nat.c (fetch_inferior_registers): Likewise.
	(store_inferior_registers): Likewise.
	* spu-linux-nat.c (spu_fetch_inferior_registers): Likewise.
	(spu_store_inferior_registers): Likewise.
	* target.c (debug_print_register): Likewise.
	(debug_to_fetch_registers, debug_to_store_registers): Likewise.
	* vaxbsd-nat.c (vaxbsd_fetch_inferior_registers): Likewise.
	(vaxbsd_store_inferior_registers): Likewise.
	* win32-nat.c (do_win32_fetch_inferior_registers): Likewise.
	(win32_fetch_inferior_registers): Likewise.
	(win32_store_inferior_registers): Likewise.
@
text
@d739 3
a741 1
      CORE_ADDR pc = read_pc_pid (pid_to_ptid (pid));
d746 3
d761 3
a763 2
	  int syscall = read_register_pid (LINUX_SYSCALL_REGNUM,
	                                   pid_to_ptid (pid));
d768 1
a768 2
	      CORE_ADDR sp = read_register (I386_ESP_REGNUM);
	      CORE_ADDR addr = sp;
d771 1
d774 2
d785 2
@


1.74
log
@	* gregset.h (struct regcache): Add forward declaration.
	(supply_gregset): Add REGCACHE parameter, make GREGS const.
	(supply_fpregset): Add REGCACHE parameter, make FPREGS const.
	(supply_fpxregset): Add REGCACHE parameter, make FPXREGS const.
	(fill_gregset): Add REGCACHE parameter.
	(fill_fpregset): Likewise.
	(fill_fpxregset): Likewise.

	Update all definitions accordingly:
	* alphabsd-nat.c, alpha-linux-nat.c, alpha-nat.c, amd64-linux-nat.c,
	arm-linux-nat.c, hppa-linux-nat.c, i386gnu-nat.c, i386-linux-nat.c,
	i386-sol2-nat.c, i386v4-nat.c, ia64-linux-nat.c, irix5-nat.c,
	m32r-linux-nat.c, m68klinux-nat.c, mips-linux-nat.c, ppc-linux-nat.c,
	s390-nat.c, sparc64-linux-nat.c, sparc-linux-nat.c, sparc-sol2-nat.c
	(supply_gregset): Add REGCACHE parameter, use it instead of
	current_regcache.  Make GREGSETP parameter const, adapt casts.
	(supply_fpregset): Add REGCACHE parameter, use it instead of
	current_regcache.  Make FPREGSETP parameter const, adapt casts.
	(fill_gregset): Add REGCACHE parameter, use it instead of
	current_regcache.
	(fill_fpregset): Likewise.

	Update all callers to pass in current_regcache as the new argument:
	* core-regset.c: Include "regcache.h".
	(fetch_core_registers): Update supply_gregset,and supply_fpregset calls.
	* procfs.c: Include "regcache.h".
	(procfs_fetch_registers): Update supply_gregset, supply_fpregset calls.
	(procfs_store_registers): Update fill_gregset, fill_fpregset calls.
	(procfs_do_thread_registers): Likewise.
	(procfs_make_note_section): Likewise.
	* proc-service.c: Include "regcache.h".
	(ps_lgetregs): Update fill_gregset call.
	(ps_lsetregs): Update supply_gregset call.
	(ps_lgetfpregs): Update fill_fpregset call.
	(ps_lsetfpregs): Update supply_fpregset call.
	* sol-thread.c (sol_thread_fetch_registers): Update supply_gregset,
	supply_fpregset calls.
	(sol_thread_store_registers): Update fill_gregset, fill_fpregset calls.
	(ps_lgetregs): Update fill_gregset call.
	(ps_lsetregs): Update supply_gregset call.
	(ps_lgetfpregs): Update fill_fpregset call.
	(ps_lsetfpregs): Update supply_fpregset call.

	* linux-nat.c (linux_nat_do_thread_registers): Update fill_gregset,
	fill_fpregset, and fill_fpxregset calls.
	* i386-linux-nat.c (fetch_regs): Update supply_gregset call.
	(store_regs): Update fill_gregset call.
	(fetch_fpregs): Update supply_fpregset call.
	(store_fpregs): Update fill_fpregset call.
	(fetch_fpxregs): Update supply_fpxregset call.
	(store_fpxregs): Update fill_fpxregset call.
	* m32r-linux-nat.c (fetch_regs): Update supply_gregset call.
	(store_regs): Update fill_gregset call.
	* m68klinux-nat.c (fetch_regs): Update supply_gregset call.
	(store_regs): Update fill_gregset call.
	(fetch_fpregs): Update supply_fpregset call.
	(store_fpregs): Update fill_fpregset call.
	(fetch_core_registers): Update supply_gregset, supply_fpregset calls.
	* s390-nat.c (fetch_regs): Update supply_gregset call.
	(store_regs): Update fill_gregset call.
	(fetch_fpregs): Update supply_fpregset call.
	(store_fpregs): Update fill_fpregset call.

	* Makefile.in (core-regset.o, procfs.o, proc-service.o): Update
	dependencies.
@
text
@d145 1
a145 1
fetch_register (int regno)
d153 1
a153 1
      regcache_raw_supply (current_regcache, regno, NULL);
d168 1
a168 1
  regcache_raw_supply (current_regcache, regno, &val);
d174 1
a174 1
store_register (int regno)
d189 1
a189 1
  regcache_raw_collect (current_regcache, regno, &val);
d244 1
a244 1
fetch_regs (int tid)
d261 1
a261 1
  supply_gregset (current_regcache, (const elf_gregset_t *) &regs);
d268 1
a268 1
store_regs (int tid, int regno)
d275 1
a275 1
  fill_gregset (current_regcache, &regs, regno);
d283 2
a284 2
static void fetch_regs (int tid) {}
static void store_regs (int tid, int regno) {}
d317 1
a317 1
fetch_fpregs (int tid)
d324 1
a324 1
  supply_fpregset (current_regcache, (const elf_fpregset_t *) &fpregs);
d331 1
a331 1
store_fpregs (int tid, int regno)
d338 1
a338 1
  fill_fpregset (current_regcache, &fpregs, regno);
d346 2
a347 2
static void fetch_fpregs (int tid) {}
static void store_fpregs (int tid, int regno) {}
d382 1
a382 1
fetch_fpxregs (int tid)
d400 1
a400 1
  supply_fpxregset (current_regcache, (const elf_fpxregset_t *) &fpxregs);
d409 1
a409 1
store_fpxregs (int tid, int regno)
d427 1
a427 1
  fill_fpxregset (current_regcache, &fpxregs, regno);
d437 2
a438 2
static int fetch_fpxregs (int tid) { return 0; }
static int store_fpxregs (int tid, int regno) { return 0; }
d450 1
a450 1
i386_linux_fetch_inferior_registers (int regno)
d462 1
a462 1
	  fetch_register (i);
d478 1
a478 1
      fetch_regs (tid);
d483 1
a483 1
	  i386_linux_fetch_inferior_registers (regno);
d487 1
a487 1
      if (fetch_fpxregs (tid))
d489 1
a489 1
      fetch_fpregs (tid);
d495 1
a495 1
      fetch_regs (tid);
d501 1
a501 1
      if (fetch_fpxregs (tid))
d510 1
a510 1
      fetch_fpregs (tid);
d522 1
a522 1
i386_linux_store_inferior_registers (int regno)
d534 1
a534 1
	  store_register (i);
d549 2
a550 2
      store_regs (tid, regno);
      if (store_fpxregs (tid, regno))
d552 1
a552 1
      store_fpregs (tid, regno);
d558 1
a558 1
      store_regs (tid, regno);
d564 1
a564 1
      if (store_fpxregs (tid, regno))
d570 1
a570 1
      store_fpregs (tid, regno);
@


1.73
log
@	* i387-tdep.c (i387_fill_fsave, i387_fill_fxsave): Remove.
	* i387-tdep.h (i387_fill_fsave, i387_fill_fxsave): Remove prototypes.
	* i368-linux-nat.c (supply_fpregset, supply_fpxregset): Replace
	i387_fill_fsave and i387_fill_fxsave calls by inline copies.
	* i386-nto-tdep.c (i386nto_regset_fill): Likewise.
	* i386gnu-nat.c (store_fpregs): Likewise.
	* i386v4-nat.c (fill_fpregset): Likewise.
	* go32-nat.c (store_register, go32_store_registers): Likewise.
@
text
@d204 1
a204 1
supply_gregset (elf_gregset_t *gregsetp)
d206 1
a206 1
  elf_greg_t *regp = (elf_greg_t *) gregsetp;
d210 1
a210 1
    regcache_raw_supply (current_regcache, i, regp + regmap[i]);
d213 1
a213 1
    regcache_raw_supply (current_regcache, I386_LINUX_ORIG_EAX_REGNUM,
d222 2
a223 1
fill_gregset (elf_gregset_t *gregsetp, int regno)
d230 1
a230 1
      regcache_raw_collect (current_regcache, i, regp + regmap[i]);
d234 1
a234 1
    regcache_raw_collect (current_regcache, I386_LINUX_ORIG_EAX_REGNUM,
d261 1
a261 1
  supply_gregset (&regs);
d275 1
a275 1
  fill_gregset (&regs, regno);
d295 1
a295 1
supply_fpregset (elf_fpregset_t *fpregsetp)
d297 1
a297 1
  i387_supply_fsave (current_regcache, -1, fpregsetp);
d305 2
a306 1
fill_fpregset (elf_fpregset_t *fpregsetp, int regno)
d308 1
a308 1
  i387_collect_fsave (current_regcache, regno, fpregsetp);
d324 1
a324 1
  supply_fpregset (&fpregs);
d338 1
a338 1
  fill_fpregset (&fpregs, regno);
d360 2
a361 1
supply_fpxregset (elf_fpxregset_t *fpxregsetp)
d363 1
a363 1
  i387_supply_fxsave (current_regcache, -1, fpxregsetp);
d371 2
a372 1
fill_fpxregset (elf_fpxregset_t *fpxregsetp, int regno)
d374 1
a374 1
  i387_collect_fxsave (current_regcache, regno, fpxregsetp);
d400 1
a400 1
  supply_fpxregset (&fpxregs);
d427 1
a427 1
  fill_fpxregset (&fpxregs, regno);
@


1.72
log
@	* core-aout.c: Delete file.
	* Makefile.in (ALLDEPFILES): Remove core-aout.c.
	(core-aout.o): Delete rule.
	* gdbcore.h (kernel_u_addr, KERNEL_U_ADDR): Remove.

        * config/alpha/nm-linux.h (U_REGS_OFFSET): Remove.

        * arm-linux-nat.c (arm_linux_kernel_u_size): Remove.
        * config/arm/nm-linux.h (U_REGS_OFFSET, KERNEL_U_SIZE,
        KERNEL_U_ADDR): Remove.

        * i386-linux-nat.c (register_u_addr, kernel_u_size): Remove.
        (cannot_fetch_register, cannot_store_register): Remove.
        (fetch_register): Inline cannot_fetch_register and register_addr.
        (store_register): Inline cannot_store_register and register_addr.
        * config/i386/linux.mh (NATDEPFILES): Remove core-aout.o.
        * config/i386/nm-linux.h (KERNEL_U_SIZE, KERNEL_U_ADDR,
        REGISTER_U_ADDR, CANNOT_FETCH_REGISTER, CANNOT_STORE_REGISTER):
        Remove.

        * m68klinux-nat.c (m68k_linux_register_u_addr, kernel_u_size): Remove.
        (fetch_register): Inline register_addr.
        (store_register): Inline register_addr.
        * config/m68k/linux.mh (NATDEPFILES): Remove core-aout.o.
        * config/m68k/nm-linux.h (KERNEL_U_SIZE, KERNEL_U_ADDR,
        U_REGS_OFFSET, REGISTER_U_ADDR): Remove.

        * config/mips/nm-irix5.h (REGISTER_U_ADDR): Remove.
        * config/mips/nm-linux.h (KERNEL_U_SIZE, U_REGS_OFFSET,
        REGISTER_U_ADDR): Remove.

        * hppa-linux-nat.c (register_addr): Rename to ...
        (hppa_linux_register_addr): ... this.  Make static.
        (fetch_register, store_register): Adapt callers.
        * config/pa/nm-linux.h (U_REGS_OFFSET): Remove.

        * ppc-linux-nat.c (kernel_u_size): Remove.
        * config/powerpc/nm-linux.h (KERNEL_U_SIZE, KERNEL_U_ADDR): Remove.

	* vax-nat.c (vax_kernel_u_addr, vax_register_u_addr): Make static.
	* config/vax/vax.mh (NATDEPFILES): Remove core-aout.o.
	(NAT_FILE): Remove.
	* config/vax/nm-vax.h: Delete file.
@
text
@d306 1
a306 1
  i387_fill_fsave ((char *) fpregsetp, regno);
d370 1
a370 1
  i387_fill_fxsave ((char *) fpxregsetp, regno);
@


1.71
log
@Copyright updates for 2007.
@
text
@a139 20
/* Support for the user struct.  */

/* Return the address of register REGNUM.  BLOCKEND is the value of
   u.u_ar0, which should point to the registers.  */

CORE_ADDR
register_u_addr (CORE_ADDR blockend, int regnum)
{
  return (blockend + 4 * regmap[regnum]);
}

/* Return the size of the user struct.  */

int
kernel_u_size (void)
{
  return (sizeof (struct user));
}


d151 1
a151 1
  if (cannot_fetch_register (regno))
d163 1
a163 1
  val = ptrace (PTRACE_PEEKUSER, tid, register_addr (regno, 0), 0);
d180 1
a180 1
  if (cannot_store_register (regno))
d190 1
a190 1
  ptrace (PTRACE_POKEUSER, tid, register_addr (regno, 0), val);
a440 19
/* Check if register REGNO in the child process is accessible.
   If we are accessing registers directly via the U area, only the
   general-purpose registers are available.
   All registers should be accessible if we have GETREGS support.  */
   
int
cannot_fetch_register (int regno)
{
  gdb_assert (regno >= 0 && regno < NUM_REGS);
  return (!have_ptrace_getregs && regmap[regno] == -1);
}

int
cannot_store_register (int regno)
{
  gdb_assert (regno >= 0 && regno < NUM_REGS);
  return (!have_ptrace_getregs && regmap[regno] == -1);
}

@


1.70
log
@        * gdbcore.h (read_memory_nobpt): New function name instead of
        deprecated_read_memory_nobpt.
        * breakpoint.c (read_memory_nobpt): New function name instead
        of deprecated_read_memory_nobpt.
        Adjust calls to old deprecated_read_memory_nobpt accordingly.
        * alpha-tdep.c: Adjust calls to deprecated_read_memory_nobpt
        accordingly.
        * alphanbsd-tdep.c: Likewise.
        * frame.c: Likewise.
        * frv-tdep.c: Likewise.
        * hppa-linux-tdep.c: Likewise.
        * hppa-tdep.c: Likewise.
        * i386-linux-nat.c: Likewise.
        * m68klinux-tdep.c: Likewise.
        * mips-tdep.c: Likewise.
        * s390-tdep.c: Likewise.
@
text
@d3 1
a3 1
   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
@


1.69
log
@	* linux-nat.c (linux_ops_saved): New.
	(super_mourn_inferior, kill_inferior, threaded, linux_nat_ops)
	(child_mourn_inferior, child_wait, linux_nat_create_inferior)
	(linux_nat_fetch_registers, linux_nat_store_registers)
	(linux_nat_child_post_startup_inferior, init_linux_nat_ops): Delete.
	(init_lwp_list): Don't set threaded.
	(add_lwp): Don't modify threaded.
	(delete_lwp): Don't mention non-threaded mode.
	(linux_nat_switch_fork): New.
	(linux_nat_attach): Update inferior_ptid.
	(linux_nat_wait): Handle num_lwps == 0 at entry.  Don't check
	threaded flag.
	(linux_nat_kill): Handle pending forks and saved forks.
	(linux_nat_mourn_inferior): Handle saved forks.
	(linux_nat_pid_to_str): Don't use the LWP form when there is
	only one thread.
	(linux_target): Don't set to_wait, to_kill, or to_mourn_inferior.
	(linux_nat_add_target): New.
	(_initialize_linux_nat): Don't initialize the linux native target
	here.
	* linux-nat.h (linux_nat_add_target, linux_nat_switch_fork): New
	prototypes.
	* linux-fork.c: Include "linux-nat.h".
	(add_fork): Update initial PID.
	(fork_load_infrun_state): Call linux_nat_switch_fork.
	* Makefile.in (linux-fork.o): Update.

	* alpha-linux-nat.c (_initialize_alpha_linux_nat): Use
	linux_nat_add_target instead of add_target.
	* amd64-linux-nat.c (_initialize_amd64_linux_nat): Likewise.
	* arm-linux-nat.c (_initialize_arm_linux_nat): Likewise.
	* hppa-linux-nat.c (_initialize_hppa_linux_nat): Likewise.
	* ia64-linux-nat.c (_initialize_ia64_linux_nat): Likewise.
	* i386-linux-nat.c (_initialize_i386_linux_nat): Likewise.
	* m32r-linux-nat.c (_initialize_m32r_linux_nat): Likewise.
	* m68klinux-nat.c (_initialize_m68k_linux_nat): Likewise.
	* mips-linux-nat.c (_initialize_mips_linux_nat): Likewise.
	* ppc-linux-nat.c (_initialize_ppc_linux_nat): Likewise.
	* s390-nat.c (_initialize_s390_nat): Likewise.
	* sparc-linux-nat.c (_initialize_sparc_linux_nat): Likewise.
	* sparc64-linux-nat.c (_initialize_sparc64_linux_nat): Likewise.
@
text
@d788 1
a788 1
      if (deprecated_read_memory_nobpt (pc, buf, LINUX_SYSCALL_LEN) == 0
@


1.69.8.1
log
@2006-05-13    Changes based on Apple GDB (CVS repository 5th Sept 2005)

	* async-nat-inferior.c, async-nat-inferior.h,
	* async-nat-sigthread.c, async-nat-sigthread.h: New files

	* linux-nat.c: Include async-nat-inferior.h.
	(linux_nat_wait): Add extra argument.  If target_can_async_p
	do something completely different.

	* interps.h (interp_set, interp_set_quiet): New externs.

	* interps.c (interp_set): Make asynchronous.
	(interp_set_quiet): Don't make static.
	(current_interp_command_loop): Call functions with new arguments.

	* target.h (target_wait): Add extra argument.
	(gdb_override_async, gdb_set_async_override) New externs.
	(target_can_async_p): Make conditional on gdb_override_async.

	* target.c (gdb_override_async): New variable.
	(gdb_set_async_override, do_restore_target_async_mask):
	New functions.
	(debug_to_wait): Add extra argument.

	* linux-thread-db.c (thread_db_wait): Add extra argument.

	* wrapper.h (safe_execute_command): Declare structure.

	* top.c (*deprecated_target_wait_hook): Add extra argument.
	(read_command_file): Make asynchronous.

	* remote.c (remote_wait, remote_async_wait): Add extra argument.

	* infrun.c: Include event-top.h
	(wait_for_inferior, fetch_inferior_event): Add extra argument to
	target_wait.
	(proceed): Set target_executing = 0.
	(handle_inferior_event): Call async_disable_stdin if async.

	* inf-ptrace.c: Include inf-loop.h, async-nat-inferior.h.
	(inf_ptrace_him): Create a signal thread.
	(inf_ptrace_wait): Add extra argument to target_wait.

	* inf-loop.c (inferior_event_handler, complete_execution):
	Changes for asynchronous operation (copied verbatim).

	* inf-child.c: Include async-nat-inferior.h.
	(inf_child_target): Use methods async_terminal_inferior
	and async_terminal_ours.

	* i386-linux-nat.c: Include inf-loop.h, async-nat-inferior.h.
	(i386_linux_resume): Call gdb_process_events and then
	async methods.

	* exec.c: Include event-loop.h, async-nat-inferior.h.
	(async_file_handler, standard_async, standard_is_async_p)
	(standard_can_async_p): New functions.
	(init_exec_ops): Initialise above methods.

	* event-top.h (cli_command_loop): Make argument void*.

	* event-top.c (display_gdb_prompt, async_enable_stdin)
	(async_disable_stdin, handle_sigint, async_request_quit)
	(gdb_setup_readline, _initialize_event_loop):
	Changes for asynchronous operation (copied verbatim).
	(cli_command_loop): Make argument void*.

	* event-loop.h (gdb_client_data): Move typedef to defs.h.
	(gdb_create_event): Declare.
	(event_handler_func): Move typedef from event-loop.c.

	* event-loop.c (use_poll): Set to 0.
	(gdb_queue_event, gdb_create_event): New functions.
	(async_queue_event): Don't make static.
	(create_file_event): Use gdb_create_event.
	(gdb_event): Change component from int to void*.
	(process_event, handle_file_event, handle_timer_event):
	Change according to gdb_event.
	(event_handler_func): Move typedef to event-loop.c.

	* defs.h: (gdb_mi_run_status, event_loop_p): New externs.
	(gdb_client_data): Move typedef from event-loop.h.
	(*deprecated_command_loop_hook): Make argument void*.
	(*deprecated_target_wait_hook): Add argument.

	* cli-out.h (cli_quoted_out_new): Declare.

	* cli-out.c (cli_quoted_out_new): New function.
	Include mi/mi-console.h.

	* cli/cli-interp.c: Include inferior.h, mi/mi-console.h.
	(safe_execute_command): Make static.
	(cli_interpreter_resume, cli_interpreter_exec):
	Make asynchronous.
	(cli_quoted_interpreter_resume): New function.
	(_initialize_cli_interp): Add li_command_loop to procs.
	Initialize the console-quoted interpreter.

	* tui/tui-hooks.c (tui_target_wait_hook): Add extra argument.

	* mi/mi-main.h (mi_dont_register_continuation)
	(current_command_token,  mi_interp, mi_interpreter_exec_continuation)
	(mi_continuation_arg): New externs.
	(mi_setup_continuation_arg): Declare.

	* mi/mi-main.c: Include wrapper.h.
	(struct mi_continuation_arg): New structure.
	(mi_interpreter_exec_continuation): Move to mi-interp.c.
	(mi_execute_async_cli_command)
	(mi_exec_async_cli_cmd_continuation): Make asynchronous.
	(mi_setup_continuation_arg): New function.

	* mi/mi-interp.c (mi_interpreter_exec_continuation):
	Move from mi-main.c
	(mi_cmd_interpreter_exec): Switch interpreters.  Make
	asynchronous.
	(mi1_command_loop, mi2_command_loop, mi3_command_loop):
	Make argument void*.

	* Makefile.in (async_nat_inferior_h, async_nat_sigthread_h):
	New variables.
	(gdb$(EXEEXT), $(TUI)$(EXEEXT)): Link with libpthread.
	(async-nat-inferior.o, async-nat-sigthread.o): New rules.
	(COMMON_OBS): Add above object files.
	(exec.o, i386-linux-nat.o, inf-ptrace.o, linux-nat.o):
	Update dependencies.

2006-05-13  Nick Roberts  <nickrob@@snap.net.nz>

	* main.c: (event_loop_p): Re-instate variable.
	(captured_main): Re-instate async/noasync option.
	(print_gdb_help): Describe option again.

	* exec.c(init_exec_ops): Only initialise async methods with async
	option.

	* inf-ptrace.c (inf_ptrace_him): Only reate a signal thread with
	async option.

	* README.async, TODO.async, PROBLEMS.async: New files.
@
text
@a28 2
#include "inf-loop.h"
#include "async-nat-inferior.h"
a765 2
  struct target_waitstatus status;

a815 17

  status.kind = TARGET_WAITKIND_SPURIOUS;
  gdb_process_events (gdb_status, &status, 0, 0);

  if (gdb_post_pending_event ())
    {
      /* QUESTION: Do I need to lie about target_executing here? */
      if (target_is_async_p ())
        target_executing = 1;
      return;
    }

  if (target_can_async_p ())
    target_async (inferior_event_handler, 0);

  if (target_is_async_p ())
    target_executing = 1;
@


1.69.8.2
log
@Changes from nickrob-async-20060828-mergepoint.
@
text
@d792 1
a792 1
      if (read_memory_nobpt (pc, buf, LINUX_SYSCALL_LEN) == 0
@


1.69.8.3
log
@(i386_linux_resume): Move async stuff for
i386_linux_resume into linux_nat_resume in linux-nat.c.  This
file is now the same as for mainline.
@
text
@d29 2
d768 2
d820 17
@


1.68
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d3 1
a3 1
   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005
d847 1
a847 1
  add_target (t);
@


1.67
log
@	* Makefile.in (ALLDEPFILES): Update.
	(alpha-linux-nat.o, sparc-linux-nat.o): New rules.
	(amd64-linux-nat.o, arm-linux-nat.o, hppa-linux-nat.o)
	(i386-linux-nat.o, ia64-linux-nat.o, linux-nat.o, m32r-linux-nat.o)
	(m68klinux-nat.o, mips-linux-nat.o, ppc-linux-nat.o, s390-nat.o)
	(sparc64-linux-nat.o): Update dependencies.
	* alpha-linux-nat.c, sparc-linux-nat.c: New files.
	* amd64-linux-nat.c (amd64_linux_fetch_inferior_registers): Renamed
	from fetch_inferior_registers and made static.
	(amd64_linux_store_inferior_registers): Renamed from
	store_inferior_registers and made static.
	(amd64_linux_child_post_start_inferior): Renamed from
	child_post_startup_inferior and made static.  Call
	super_post_startup_inferior.
	(super_post_startup_inferior): New.
	(_initialize_amd64_linux_nat): Set it.  Call linux_target and
	add_target.
	* arm-linux-nat.c (arm_linux_fetch_inferior_registers): Renamed
	from fetch_inferior_registers and made static.
	(arm_linux_store_inferior_registers): Renamed from
	store_inferior_registers and made static.
	(_initialize_arm_linux_nat): Add a prototype.  Use linux_target and
	add_target.
	* hppa-linux-nat.c (hppa_linux_fetch_inferior_registers): Renamed
	from fetch_inferior_registers and made static.
	(hppa_linux_store_inferior_registers): Renamed from
	store_inferior_registers and made static.
	(_initialize_hppa_linux_nat): New function.
	* i386-linux-nat.c (i386_linux_fetch_inferior_registers): Renamed
	from fetch_inferior_registers and made static.
	(i386_linux_store_inferior_registers): Renamed from
	store_inferior_registers and made static.
	(i386_linux_resume): Renamed from child_resume and made static.
	(i386_linux_child_post_start_inferior): Renamed from
	child_post_startup_inferior and made static.  Call
	super_post_startup_inferior.
	(super_post_startup_inferior): New.
	(_initialize_i386_linux_nat): New function.
	* i386-nat.c: Remove LINUX_CHILD_POST_STARTUP_INFERIOR #ifndef.
	* ia64-linux-nat.c (ia64_linux_xfer_unwind_table): Remove.
	(super_xfer_partial): New.
	(ia64_linux_xfer_partial): New function.  Use it.
	(_initialize_ia64_linux_nat): New function.
	* ia64-tdep.c (getunwind_table): Revert 2005-06-08 change; use
	target_read_partial and document the problem.
	* inf-ptrace.c (inf_ptrace_fetch_register): Use
	CANNOT_FETCH_REGISTER.  Fix some comments.
	(inf_ptrace_store_register): Use CANNOT_STORE_REGISTER.  Fix some
	comments.
	* linux-nat.c: Include "inf-ptrace.h" and "auxv.h".
	(linux_ops, super_xfer_partial): New variables.
	(linux_child_post_startup_inferior): Make static.
	(child_post_startup_inferior): Delete.
	(linux_nat_attach, linux_nat_detach, resume_callback)
	(linux_nat_resume, linux_nat_wait, linux_nat_create_inferior)
	(linux_nat_mourn_inferior): Use linux_ops instead of
	deprecated_child_ops.
	(child_wait): Do not depend on CHILD_WAIT.
	(linux_nat_xfer_memory): Remove, replace by ...
	(linux_nat_xfer_partial): ... this.  Use linux_ops->to_xfer_partial
	instead of linux_proc_xfer_memory and child_xfer_memory.
	(linux_nat_fetch_registers, linux_nat_store_registers)
	(linux_nat_child_post_startup_inferior): New functions.
	(init_linux_nat_ops): Use the new functions.
	(linux_proc_xfer_memory): Remove, replace by ...
	(linux_proc_xfer_partial): ... this.  Make static.
	(linux_xfer_partial, linux_register_u_offset, linux_target): New
	functions.
	(_initialize_linux_nat): Do not modify deprecated_child_ops.
	* linux-nat.h (linux_proc_xfer_memory): Remove prototype.
	(struct mem_attrib, struct target_ops): Remove forward declarations.
	(linux_child_post_startup_inferior): Remove prototype.
	(linux_target): Add prototype.
	* linux-thread-db.c (thread_db_xfer_memory): Remove, replace by ...
	(thread_db_xfer_partial): ... this.
	(init_thread_db_ops): Set to_xfer_partial instead of
	deprecated_xfer_memory.
	* m32r-linux-nat.c (m32r_linux_fetch_inferior_registers): Renamed
	from fetch_inferior_registers and made static.
	(m32r_linux_store_inferior_registers): Renamed from
	store_inferior_registers and made static.
	(_initialize_m32r_linux_nat): New function.
	* m68klinux-nat.c (m68k_linux_fetch_inferior_registers): Renamed
	from fetch_inferior_registers and made static.
	(m68k_linux_store_inferior_registers): Renamed from
	store_inferior_registers and made static.
	(old_fetch_inferior_registers, old_store_inferior_registers): Made
	static.
	(_initialize_m68k_linux_nat): Use linux_target and add_target.
	* mips-linux-nat.c (_initialize_mips_linux_nat): New function.
	* ppc-linux-nat.c (ppc_linux_fetch_inferior_registers): Renamed
	from fetch_inferior_registers and made static.
	(ppc_linux_store_inferior_registers): Renamed from
	store_inferior_registers and made static.
	(_initialize_ppc_linux_nat): New function.
	* s390-nat.c (s390_linux_fetch_inferior_registers): Renamed
	from fetch_inferior_registers and made static.
	(s390_linux_store_inferior_registers): Renamed from
	store_inferior_registers and made static.
	(_initialize_s390_nat): New function.
	* sparc64-linux-nat.c (_initialize_sparc64_linux_nat): Use
	linux_target and add_target.
	* config/nm-linux.h: Don't include "auxv.h".
	(struct target_waitstatus, child_wait, CHILD_WAIT)
	(CHILD_PID_TO_EXEC_FILE, CHILD_INSERT_FORK_CATCHPOINT)
	(CHILD_INSERT_VFORK_CATCHPOINT, CHILD_INSERT_EXEC_CATCHPOINT)
	(CHILD_POST_STARTUP_INFERIOR, CHILD_POST_ATTACH, CHILD_FOLLOW_FORK)
	(DEPRECATED_KILL_INFERIOR, NATIVE_XFER_AUXV): Delete.
	* config/alpha/alpha-linux.mh (NATDEPFILES): Replace infptrace.o
	and inftarg.o with inf-ptrace.o and alpha-linux-nat.o.
	* config/sparc/linux.mh (NATDEPFILES): Replace infptrace.o and
	inftarg.o with sparc-linux-nat.o.
	* config/sparc/linux64.mh (NATDEPFILES): Remove infptrace.o and
	inftarg.o.
	* config/arm/linux.mh (NATDEPFILES): Replace infptrace.o and
	inftarg.o with inf-ptrace.o.
	* config/i386/linux.mh (NATDEPFILES): Likewise.
	* config/i386/linux64.mh (NATDEPFILES): Likewise.
	* config/ia64/linux.mh (NATDEPFILES): Likewise.
	* config/m32r/linux.mh (NATDEPFILES): Likewise.
	* config/m68k/linux.mh (NATDEPFILES): Likewise.
	* config/mips/linux.mh (NATDEPFILES): Likewise.
	* config/pa/linux.mh (NATDEPFILES): Likewise.
	* config/powerpc/linux.mh (NATDEPFILES): Likewise.
	* config/powerpc/ppc64-linux.mh (NATDEPFILES): Likewise.
	* config/s390/s390.mh (NATDEPFILES): Likewise.
	* config/i386/nm-linux.h (DEPRECATED_CHILD_RESUME): Don't define.
	(LINUX_CHILD_POST_STARTUP_INFERIOR): Don't define.
	* config/i386/nm-linux64.h (LINUX_CHILD_POST_STARTUP_INFERIOR):
	Don't define.
	* config/ia64/nm-linux.h: Don't include "target.h".
	(NATIVE_XFER_UNWIND_TABLE, ia64_linux_xfer_unwind_table): Remove.
	* config/djgpp/fnchange.lst: Add alpha-linux-tdep.c,
	alpha-linux-nat.c, sparc-linux-tdep.c, and sparc-linux-nat.c.
@
text
@d3 1
a3 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005
d20 2
a21 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.66
log
@* i386-linux-nat.c (fetch_register, store_register)
(supply_gregset, fill_gregset): Remove redundant casts.
@
text
@d27 1
d484 2
a485 2
void
fetch_inferior_registers (int regno)
d518 1
a518 1
	  fetch_inferior_registers (regno);
d556 2
a557 2
void
store_inferior_registers (int regno)
d759 2
a760 2
void
child_resume (ptid_t ptid, int step, enum target_signal signal)
d818 9
d828 1
a828 1
child_post_startup_inferior (ptid_t ptid)
d830 18
a847 2
  i386_cleanup_dregs ();
  linux_child_post_startup_inferior (ptid);
@


1.65
log
@2005-08-09  Andrew Cagney  <cagney@@gnu.org>

	* linux-nat.h (linux_proc_xfer_memory): Change type of "myaddr" a
	"gdb_byte" pointer.
	* linux-nat.c (linux_proc_xfer_memory): Update.
	(get_signo): Cast signo to a "gdb_byte" pointer.
	* i386-linux-nat.c (child_resume): Make "buf" a gdb_byte, delete
	redundant casts.
	(child_resume): Cast eflags to a "gdb_byte" pointer.
@
text
@d3 2
a4 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
d187 1
a187 1
  regcache_raw_supply (current_regcache, regno, (gdb_byte *) &val);
d208 1
a208 1
  regcache_raw_collect (current_regcache, regno, (gdb_byte *) &val);
d229 1
a229 1
    regcache_raw_supply (current_regcache, i, (gdb_byte *) (regp + regmap[i]));
d233 1
a233 1
			 (gdb_byte *) (regp + ORIG_EAX));
d248 1
a248 1
      regcache_raw_collect (current_regcache, i, (gdb_byte *) (regp + regmap[i]));
d253 1
a253 1
			  (gdb_byte *) (regp + ORIG_EAX));
@


1.64
log
@	* dwarf2-frame.c (dwarf2_frame_prev_register): Use gdb_byte.
	* i386-linux-nat.c (fetch_register, store_register, supply_gregset)
	(fill_gregset): Likewise.
	* i386-tdep.c (i386_frame_prev_register)
	(i386_sigtramp_frame_prev_register): Likewise.
	* linux-nat.c (linux_nat_xfer_memory, linux_nat_make_corefile_notes):
	Likewise.
	* linux-thread-db.c (thread_db_xfer_memory): Likewise.
	* remote.c (remote_insert_hw_breakpoint, remote_remove_hw_breakpoint):
	Likewise.
	* target.c (debug_to_insert_hw_breakpoint)
	(debug_to_remove_hw_breakpoint, update_current_target): Likewise.
@
text
@d773 1
a773 1
      unsigned char buf[LINUX_SYSCALL_LEN];
d786 1
a786 1
      if (deprecated_read_memory_nobpt (pc, (char *) buf, LINUX_SYSCALL_LEN) == 0
d805 1
a805 1
	      read_memory (addr, (char *) &eflags, 4);
d807 1
a807 1
	      write_memory (addr, (char *) &eflags, 4);
@


1.63
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up error_no_arg, query, perror_with_name, complaint, and
	internal_error.
	* breakpoint.c, cp-abi.c, cp-namespace.c, cp-support.c: Update.
	* cris-tdep.c, dbxread.c, dictionary.c, dsrec.c: Update.
	* dummy-frame.c, dve3900-rom.c, dwarf2-frame.c, dwarf2expr.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, event-loop.c: Update.
	* exceptions.c, exec.c, f-lang.c, findvar.c, fork-child.c: Update.
	* frame-unwind.c, frame.c, frv-linux-tdep.c, frv-tdep.c: Update.
	* gdb_assert.h, gdbarch.c, gdbtypes.c, gnu-nat.c: Update.
	* go32-nat.c, hppa-tdep.c, hppabsd-nat.c, hpread.c: Update.
	* i386-linux-nat.c, i386-nat.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386fbsd-nat.c, inf-ptrace.c, inf-ttrace.c, infcall.c: Update.
	* infcmd.c, inflow.c, infptrace.c, infrun.c, inftarg.c: Update.
	* interps.c, language.c, linespec.c, linux-nat.c: Update.
	* m32r-linux-nat.c, m68k-tdep.c, m68kbsd-nat.c: Update.
	* m68klinux-nat.c, m88kbsd-nat.c, macroexp.c, macroscope.c: Update.
	* macrotab.c, maint.c, mdebugread.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mips64obsd-nat.c: Update.
	* mipsnbsd-nat.c, mn10300-tdep.c, monitor.c, nto-procfs.c: Update.
	* objc-lang.c, objfiles.c, objfiles.h, ocd.c, osabi.c: Update.
	* parse.c, ppc-bdm.c, ppc-linux-nat.c, ppc-sysv-tdep.c: Update.
	* ppcnbsd-nat.c, ppcobsd-nat.c, printcmd.c, procfs.c: Update.
	* regcache.c, reggroups.c, remote-e7000.c, remote-mips.c: Update.
	* remote-rdp.c, remote-sds.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote.c, rs6000-nat.c, rs6000-tdep.c: Update.
	* s390-nat.c, s390-tdep.c, sentinel-frame.c, serial.c: Update.
	* sh-tdep.c, sh3-rom.c, sh64-tdep.c, shnbsd-nat.c: Update.
	* solib-aix5.c, solib-svr4.c, solib.c, source.c: Update.
	* sparc-nat.c, stabsread.c, stack.c, symfile.c, symtab.c: Update.
	* symtab.h, target.c, tracepoint.c, ui-file.c, ui-out.c: Update.
	* utils.c, valops.c, valprint.c, vax-nat.c, vaxbsd-nat.c: Update.
	* win32-nat.c, xcoffread.c, xstormy16-tdep.c: Update.
	* cli/cli-cmds.c, cli/cli-logging.c, cli/cli-script.c: Update.
	* cli/cli-setshow.c, mi/mi-cmd-break.c, mi/mi-cmds.c: Update.
	* mi/mi-console.c, mi/mi-getopt.c, mi/mi-out.c: Update.
	* tui/tui-file.c, tui/tui-interp.c: Update.
@
text
@d186 1
a186 1
  regcache_raw_supply (current_regcache, regno, &val);
d207 1
a207 1
  regcache_raw_collect (current_regcache, regno, &val);
d228 1
a228 1
    regcache_raw_supply (current_regcache, i, regp + regmap[i]);
d232 1
a232 1
			 regp + ORIG_EAX);
d247 1
a247 1
      regcache_raw_collect (current_regcache, i, regp + regmap[i]);
d252 1
a252 1
			  regp + ORIG_EAX);
@


1.62
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d275 1
a275 1
      perror_with_name ("Couldn't get registers");
d290 1
a290 1
    perror_with_name ("Couldn't get registers");
d295 1
a295 1
    perror_with_name ("Couldn't write registers");
d338 1
a338 1
    perror_with_name ("Couldn't get floating point status");
d352 1
a352 1
    perror_with_name ("Couldn't get floating point status");
d357 1
a357 1
    perror_with_name ("Couldn't write floating point status");
d411 1
a411 1
      perror_with_name ("Couldn't read floating-point and SSE registers");
d438 1
a438 1
      perror_with_name ("Couldn't read floating-point and SSE registers");
d444 1
a444 1
    perror_with_name ("Couldn't write floating-point and SSE registers");
d548 1
a548 1
		  "Got request for bad register number %d.", regno);
d608 1
a608 1
		  "Got request to store bad register number %d.", regno);
d635 1
a635 1
    perror_with_name ("Couldn't read debug register");
d657 1
a657 1
    perror_with_name ("Couldn't write debug register");
d813 1
a813 1
    perror_with_name ("ptrace");
@


1.61
log
@* i386-tdep.h (FPC_REGNUM, FCTRL_REGNUM, FSTAT_REGNUM, FTAG_REGNUM)
(FISEG_REGNUM, FIOFF_REGNUM, FOSEG_REGNUM, FOOFF_REGNUM)
(FOP_REGNUM, XMM0_REGNUM, MXCSR_REGNUM): Remove macros.
(i386_frameless_signal_p): Remove prototype.
* i386-linux-nat.c (GETFPREGS_SUPPLIES): Remove macro.
(GETFPXREGS_SUPPLIES): Define using I386_ST0_REGNUM and
I386_SSE_NUM_REGS.
* i386-nto-tdep.c (i386nto_supply_gregset): Use I386_NUM_GREGS
instead of FP0_REGNUM.
(i386nto_regset_id): Use I386_NUM_GREGS and I386_NUM_FREGS instead
of FP0_REGNUM and FPC_REGNUM.
@
text
@d183 1
a183 1
    error ("Couldn't read register %s (#%d): %s.", REGISTER_NAME (regno),
d210 1
a210 1
    error ("Couldn't write register %s (#%d): %s.", REGISTER_NAME (regno),
@


1.60
log
@* i386-linux-nat.c (dummy_sse_values): Remove function and
prototype.
(i386_linux_dr_get): Fix typo in comment.
(LINUX_SYSCALL_REGNUM): Define as I386_EAX_REGNUM.
@
text
@a64 1
/* Prototypes for i387_supply_fsave etc.  */
a65 2

/* Defines for XMM0_REGNUM etc. */
a66 2

/* Defines I386_LINUX_ORIG_EAX_REGNUM.  */
a108 3
#define GETFPREGS_SUPPLIES(regno) \
  (FP0_REGNUM <= (regno) && (regno) <= LAST_FPU_CTRL_REGNUM)

d110 1
a110 1
  (FP0_REGNUM <= (regno) && (regno) <= MXCSR_REGNUM)
@


1.59
log
@2004-07-23  Andrew Cagney  <cagney@@gnu.org>

	Use regcache_raw_collect instead of regcache_collect.
	* regcache.h (regcache_collect): Delete declaration.
	* regcache.c (regcache_colect): Delete function.
	* win32-nat.c (do_child_store_inferior_registers): Update.
	* sol-thread.c (sol_thread_store_registers): Update.
	* shnbsd-tdep.c (shnbsd_fill_reg): Update.
	* rs6000-nat.c (store_register): Update.
	* remote.c (store_register_using_P, remote_store_registers): Update.
	* ppcnbsd-tdep.c (ppcnbsd_fill_reg): Update.
	* ppc-linux-nat.c (store_altivec_register, store_spe_register)
	(fill_vrregset, store_spe_registers, fill_gregset)
	(fill_gregset): Update.
	* nto-procfs.c (procfs_store_registers): Update.
	* mipsnbsd-tdep.c (mipsnbsd_fill_reg): Update.
	* mips-linux-tdep.c (fill_gregset, mips64_fill_gregset): Update.
	* m68klinux-nat.c (store_register, fill_gregset): Update.
	* m68k-tdep.c (fill_gregset): Update.
	* infptrace.c (store_register): Update.
	* i386-nto-tdep.c (i386nto_regset_fill): Update.
	* i386-linux-nat.c (store_register, fill_gregset): Update.
	* hppa-linux-nat.c (fill_gregset): Update.
	* go32-nat.c (store_register): Update.
	* armnbsd-nat.c (store_register, store_regs, store_fp_register)
	(store_fp_regs): Update.
	* arm-linux-nat.c (store_nwfpe_single, store_nwfpe_double)
	(store_nwfpe_extended, store_fpregister, store_fpregs)
	(store_register, store_regs, fill_gregset, fill_fpregset): Update.
	* alpha-tdep.c (alpha_fill_int_regs, alpha_fill_fp_regs): Update.
	* aix-thread.c (fill_gprs64, fill_fprs, fill_sprs64, fill_sprs32)
	(store_regs_user_thread, store_regs_kernel_thread): Update.
@
text
@a75 3

/* Prototypes for local functions.  */
static void dummy_sse_values (void);
a322 1
  dummy_sse_values ();
a456 21
/* Fill the XMM registers in the register array with dummy values.  For
   cases where we don't have access to the XMM registers.  I think
   this is cleaner than printing a warning.  For a cleaner solution,
   we should gdbarchify the i386 family.  */

static void
dummy_sse_values (void)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  /* C doesn't have a syntax for NaN's, so write it out as an array of
     longs.  */
  static long dummy[4] = { 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff };
  static long mxcsr = 0x1f80;
  int reg;

  for (reg = 0; reg < tdep->num_xmm_regs; reg++)
    regcache_raw_supply (current_regcache, XMM0_REGNUM + reg, (char *) dummy);
  if (tdep->num_xmm_regs > 0)
    regcache_raw_supply (current_regcache, MXCSR_REGNUM, (char *) &mxcsr);
}

a460 1
static void dummy_sse_values (void) {}
d636 1
a636 1
     stuff to the target vectore.  For now, just return zero if the
d746 1
a746 1
#define LINUX_SYSCALL_REGNUM 0	/* %eax */
@


1.58
log
@2004-07-21  Andrew Cagney  <cagney@@gnu.org>

	Use regcache_raw_supply instead of supply_register.
	* regcache.h (supply_register): Delete declaration.
	* regcache.c (supply_register): Delete function.
	* wince.c (do_child_fetch_inferior_registers): Update.
	* win32-nat.c (do_child_fetch_inferior_registers)
	(fetch_elf_core_registers): Update.
	* v850ice.c (v850ice_fetch_registers): Update.
	* thread-db.c (thread_db_store_registers): Update.
	* sol-thread.c (sol_thread_store_registers): Update.
	* shnbsd-tdep.c (shnbsd_supply_reg): Update.
	* rs6000-nat.c (fetch_register): Update.
	* rom68k-rom.c (rom68k_supply_one_register): Update.
	* remote.c (remote_wait, remote_async_wait): Update.
	* remote-st.c (get_hex_regs): Update.
	* remote-sim.c (gdbsim_fetch_register): Update.
	* remote-sds.c (sds_fetch_registers): Update.
	* remote-rdp.c (remote_rdp_fetch_register): Update.
	* remote-rdi.c (arm_rdi_fetch_registers): Update.
	* remote-mips.c (mips_wait, mips_fetch_registers): Update.
	* remote-m32r-sdi.c (m32r_fetch_register): Update.
	* remote-hms.c (init_hms_cmds): Update.
	* remote-est.c (init_est_cmds): Update.
	* remote-e7000.c (get_hex_regs, fetch_regs_from_dump)
	(e7000_fetch_registers, sub2_from_pc, e7000_wait): Update.
	* ppcnbsd-tdep.c (ppcnbsd_supply_reg, ppcnbsd_supply_fpreg): Update.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_spe_register)
	(fetch_register, supply_vrregset, supply_vrregset)
	(fetch_spe_registers): Update.
	* ppc-bdm.c (bdm_ppc_fetch_registers): Update.
	* monitor.c (monitor_supply_register): Update.
	* mipsv4-nat.c (supply_gregset, supply_fpregset): Update.
	* mipsnbsd-tdep.c (mipsnbsd_supply_reg)
	(mipsnbsd_supply_fpreg): Update.
	* mips-nat.c (fetch_inferior_registers)
	(fetch_core_registers): Update.
	* mips-linux-tdep.c (supply_32bit_reg, supply_gregset)
	(supply_fpregset, mips64_supply_gregset)
	(mips64_supply_fpregset): Update.
	* m68klinux-nat.c (fetch_register, supply_gregset)
	(supply_fpregset): Update.
	* m68k-tdep.c (supply_gregset, supply_fpregset): Update.
	* m32r-rom.c (init_m32r_cmds, init_mon2000_cmds): Update.
	* lynx-nat.c (fetch_inferior_registers, fetch_core_registers): Update.
	* irix5-nat.c (supply_gregset, supply_fpregset): Update.
	* infptrace.c (fetch_register): Update.
	* ia64-linux-nat.c (supply_gregset, supply_fpregset): Update.
	* ia64-aix-nat.c (supply_gregset, supply_fpregset): Update.
	* i386gnu-nat.c (fetch_fpregs, supply_gregset)
	(gnu_fetch_registers, gnu_store_registers): Update.
	* i386-nto-tdep.c (i386nto_supply_gregset): Update.
	* i386-linux-nat.c (fetch_register, supply_gregset)
	(dummy_sse_values): Update.
	* hpux-thread.c (hpux_thread_fetch_registers): Update.
	* hppah-nat.c (fetch_register): Update.
	* hppa-linux-nat.c (fetch_register, supply_gregset)
	(supply_fpregset): Update.
	* go32-nat.c (fetch_register): Update.
	* dve3900-rom.c (fetch_bitmapped_register)
	(_initialize_r3900_rom): Update.
	* cris-tdep.c (supply_gregset): Update.
	* abug-rom.c (init_abug_cmds): Update.
	* core-aout.c (fetch_core_registers): Update.
	* armnbsd-nat.c (supply_gregset, supply_fparegset)
	(fetch_register, fetch_fp_register): Update.
	* arm-linux-nat.c (fetch_nwfpe_single, fetch_nwfpe_none)
	(fetch_nwfpe_extended, fetch_fpregister, fetch_fpregs)
	(fetch_register, fetch_regs, supply_gregset, supply_fpregset): Update.
	* alphanbsd-tdep.c (fetch_core_registers): Update.
	* alpha-tdep.c (alpha_supply_int_regs, alpha_supply_fp_regs): Update.
	* alpha-nat.c (fetch_osf_core_registers)
	(fetch_osf_core_registers, fetch_osf_core_registers): Update.
	* aix-thread.c (supply_gprs64, supply_reg32, supply_fprs)
	(supply_sprs64, supply_sprs32, fetch_regs_kernel_thread): Update.
@
text
@d218 1
a218 1
  regcache_collect (regno, &val);
d258 1
a258 1
      regcache_collect (i, regp + regmap[i]);
d262 2
a263 1
    regcache_collect (I386_LINUX_ORIG_EAX_REGNUM, regp + ORIG_EAX);
@


1.57
log
@2004-07-20  Andrew Cagney  <cagney@@gnu.org>

	* breakpoint.c (deprecated_read_memory_nobpt): Rename
	read_memory_nobpt.
	* sparc-linux-tdep.c (sparc_linux_sigtramp_start): Update.
	* s390-tdep.c (s390_readinstruction, s390_in_function_epilogue_p)
	(s390_sigtramp_frame_sniffer): Update.
	* mn10300-tdep.c (mn10300_analyze_prologue): Update.
	* mipsnbsd-tdep.c (mipsnbsd_sigtramp_offset): Update.
	* mips-tdep.c (mips_fetch_instruction, mips16_fetch_instruction)
	(mips32_fetch_instruction): Update.
	* mcore-tdep.c (get_insn): Update.
	* m68klinux-tdep.c (m68k_linux_pc_in_sigtramp): Update.
	* i386nbsd-tdep.c (i386nbsd_sigtramp_offset): Update.
	* i386ly-tdep.c (i386lynx_saved_pc_after_call): Update.
	* i386-linux-tdep.c (i386_linux_sigtramp_start)
	(i386_linux_rt_sigtramp_start): Update.
	* i386-linux-nat.c (child_resume): Update.
	* hppa-tdep.c (skip_prologue_hard_way, hppa_frame_cache): Update.
	* hppa-linux-tdep.c (insns_match_pattern): Update.
	* gdbcore.h: Update.
	* frv-tdep.c (frv_gdbarch_adjust_breakpoint_address): Update.
	* frame.c (safe_frame_unwind_memory): Update.
	* amd64-linux-tdep.c (amd64_linux_sigtramp_start): Update.
	* alphanbsd-tdep.c (alphanbsd_sigtramp_offset): Update.
	* alpha-tdep.c (alpha_read_insn): Update.
@
text
@d182 1
a182 1
      supply_register (regno, NULL);
d197 1
a197 1
  supply_register (regno, &val);
d239 1
a239 1
    supply_register (i, regp + regmap[i]);
d242 2
a243 1
    supply_register (I386_LINUX_ORIG_EAX_REGNUM, regp + ORIG_EAX);
d476 1
a476 1
    supply_register (XMM0_REGNUM + reg, (char *) dummy);
d478 1
a478 1
    supply_register (MXCSR_REGNUM, (char *) &mxcsr);
@


1.56
log
@2004-07-10  Michael Snyder  <msnyder@@redhat.com>

        * symfile.c (generic_load): Comment typo.
        * stack.c (get_selected_block): Ditto.
        * regcache.c (regcache_cooked_read): Ditto.
        * monitor.c (monitor_debug): Ditto.
        * mips-tdep.c (mips_read_pc): Ditto.
        * i386-linux-nat.c (ps_get_thread_area): Ditto.
        * gdb_mbuild.sh: Ditto.
        * gdbarch.sh: Ditto.
        * gdbarch.h: Ditto.
@
text
@d818 1
a818 1
      if (read_memory_nobpt (pc, (char *) buf, LINUX_SYSCALL_LEN) == 0
@


1.55
log
@* i386-linux-nat.c: Update copyrigth year.  Tweak comment.
@
text
@d741 1
a741 1
     thread local address base that GDB needs.  Perhaphs that
@


1.54
log
@* i386-linux-nat.c: Add comment.
@
text
@d1 1
a1 1
/* Native-dependent code for GNU/Linux x86.
d3 1
a3 1
   Copyright 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
@


1.54.6.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d1 1
a1 1
/* Native-dependent code for GNU/Linux i386.
d3 1
a3 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
d65 1
d67 2
d70 2
d76 3
d117 3
d121 1
a121 1
  (I386_ST0_REGNUM <= (regno) && (regno) < I386_SSE_NUM_REGS)
d182 1
a182 1
      regcache_raw_supply (current_regcache, regno, NULL);
d197 1
a197 1
  regcache_raw_supply (current_regcache, regno, &val);
d218 1
a218 1
  regcache_raw_collect (current_regcache, regno, &val);
d239 1
a239 1
    regcache_raw_supply (current_regcache, i, regp + regmap[i]);
d242 1
a242 2
    regcache_raw_supply (current_regcache, I386_LINUX_ORIG_EAX_REGNUM,
			 regp + ORIG_EAX);
d257 1
a257 1
      regcache_raw_collect (current_regcache, i, regp + regmap[i]);
d261 1
a261 2
    regcache_raw_collect (current_regcache, I386_LINUX_ORIG_EAX_REGNUM,
			  regp + ORIG_EAX);
d324 1
d459 21
d484 1
d660 1
a660 1
     stuff to the target vector.  For now, just return zero if the
d741 1
a741 1
     thread local address base that GDB needs.  Perhaps that
d770 1
a770 1
#define LINUX_SYSCALL_REGNUM I386_EAX_REGNUM
d818 1
a818 1
      if (deprecated_read_memory_nobpt (pc, (char *) buf, LINUX_SYSCALL_LEN) == 0
@


1.53
log
@* i386-linux-nat.c (fetch_core_registers): Remove.
(linux_elf_core_fns): Remove.
(_initialize_i386_linux_nat): Remove.
@
text
@d644 2
@


1.52
log
@* i387-tdep.c (i387_supply_fsave, i387_supply_fxsave): Add
regcache argument and reverse the order of the other two
arguments.  Remove local regcache variable.  Determine
architecture from REGCACHE.  Update comments.
* x86-64-tdep.c (x86_64_supply_fxsave): Add regcache argument and
reverse the order of the other two arguments.  Remove local
regcache variable.  Determine architecture from REGCACHE.  Update
comments.
* i387-tdep.h (i387_supply_fsave, i387_supply_fxsave): Adjust
prototypes.  Update comments.
* x86-64-tdep.c (x86_64_supply_fxsave): Adjust prototype.  Adjust
comment.
* amd64fbsd-nat.c (supply_fpregset, fetch_inferior_registers):
Update.
* go32-nat.c (fetch_register, go32_fetch_registers): Update.
* i386-interix-nat.c (supply_fpregset): Update.
* i386-linux-nat.c (supply_fpregset, supply_fpxregset): Update.
* i386-nto-tdep.c (i386nto_supply_fpregset): Update.
* i386gnu-nat.c (fetch_fpregs, supply_fpregset): Update.
* i386bsd-nat.c (supply_fpregset, fetch_inferior_registers): Update.
* i386nbsd-tdep.c (fetch_core_registers, fetch_elfcore_registers):
Update.
* i386obsd-tdep.c (fetch_core_registers): Update.
* i386v4-nat.c (supply_fpregset): Update.
* x86-64-linux-nat.c (supply_fpregset): Update.
* x86-64-linux-tdep.c (fetch_core_registers): Update.
@
text
@d3 1
a3 1
   Copyright 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
a758 74
/* Interpreting register set info found in core files.  */

/* Provide registers to GDB from a core file.

   (We can't use the generic version of this function in
   core-regset.c, because GNU/Linux has *three* different kinds of
   register set notes.  core-regset.c would have to call
   supply_fpxregset, which most platforms don't have.)

   CORE_REG_SECT points to an array of bytes, which are the contents
   of a `note' from a core file which BFD thinks might contain
   register contents.  CORE_REG_SIZE is its size.

   WHICH says which register set corelow suspects this is:
     0 --- the general-purpose register set, in elf_gregset_t format
     2 --- the floating-point register set, in elf_fpregset_t format
     3 --- the extended floating-point register set, in elf_fpxregset_t format

   REG_ADDR isn't used on GNU/Linux.  */

static void
fetch_core_registers (char *core_reg_sect, unsigned core_reg_size,
		      int which, CORE_ADDR reg_addr)
{
  elf_gregset_t gregset;
  elf_fpregset_t fpregset;

  switch (which)
    {
    case 0:
      if (core_reg_size != sizeof (gregset))
	warning ("Wrong size gregset in core file.");
      else
	{
	  memcpy (&gregset, core_reg_sect, sizeof (gregset));
	  supply_gregset (&gregset);
	}
      break;

    case 2:
      if (core_reg_size != sizeof (fpregset))
	warning ("Wrong size fpregset in core file.");
      else
	{
	  memcpy (&fpregset, core_reg_sect, sizeof (fpregset));
	  supply_fpregset (&fpregset);
	}
      break;

#ifdef HAVE_PTRACE_GETFPXREGS
      {
	elf_fpxregset_t fpxregset;

      case 3:
	if (core_reg_size != sizeof (fpxregset))
	  warning ("Wrong size fpxregset in core file.");
	else
	  {
	    memcpy (&fpxregset, core_reg_sect, sizeof (fpxregset));
	    supply_fpxregset (&fpxregset);
	  }
	break;
      }
#endif

    default:
      /* We've covered all the kinds of registers we know about here,
         so this must be something we wouldn't know what to do with
         anyway.  Just ignore it.  */
      break;
    }
}


a850 19
}


/* Register that we are able to handle GNU/Linux ELF core file
   formats.  */

static struct core_fns linux_elf_core_fns =
{
  bfd_target_elf_flavour,		/* core_flavour */
  default_check_format,			/* check_format */
  default_core_sniffer,			/* core_sniffer */
  fetch_core_registers,			/* core_read_registers */
  NULL					/* next */
};

void
_initialize_i386_linux_nat (void)
{
  add_core_fns (&linux_elf_core_fns);
@


1.51
log
@* i386-linux-nat.c (ps_get_thread_area): Don't define as extern.
Only define PTRACE_GET_THREAD_AREA is not already defined.
Various style fixes in code and comments and some additional
spelling fixes in comments.  Move after functions dealing with
debug registers.
* x86-64-linux-nat.c (ps_get_thread_area): Don't define as extern.
Fix coding-style.
@
text
@d323 1
a323 1
  i387_supply_fsave ((const char *) fpregsetp, -1);
d388 1
a388 1
  i387_supply_fxsave ((const char *) fpxregsetp, -1);
@


1.50
log
@2003-08-26  Andrew Cagney  <cagney@@redhat.com>

	* i386-linux-nat.c (ps_get_thread_area): Make "desc" four "int"s
	in size.  Add comments.
@
text
@a689 35
/* Called by libthread_db.  Return's a pointer to the thread local
   storage (or it's descriptor).  */
extern ps_err_e
ps_get_thread_area(const struct ps_prochandle *ph, 
		   lwpid_t lwpid, int idx, void **base)
{
  /* NOTE: cagney/2003-08-26: The definition of this buffer is found
     in the kernel header <asm-i386/ldt.h>.  It, after padding, is 4 x
     4 byte integers in size: "entry_number", "base_addr", "limit",
     and a bunch of status bits.

     The values returned by this ptrace call should be part of the
     regcache buffer, and ps_get_thread_area should channel its
     request through the regcache.  That way remote targets could
     provide the value using the remote protocol and not this direct
     call.

     Is this function needed?  I'm guessing that the "base" is the
     address of a a descriptor that libthread_db uses to find the
     thread local address base that GDB needs.  Perhaphs that
     descriptor is defined by the ABI.  Anyway, given that
     libthread_db calls this function without prompting (gdb
     requesting tls base) I guess it needs info in there anyway.  */
  unsigned int desc[4];
  gdb_assert (sizeof (int) == 4);
#define PTRACE_GET_THREAD_AREA 25

  if  (ptrace (PTRACE_GET_THREAD_AREA, 
	       lwpid, (void *) idx, (unsigned long) &desc) < 0)
    return PS_ERR;

  *(int *)base = desc[1];
  return PS_OK;
}

d716 40
@


1.49
log
@* go32-nat.c (fetch_register): Call i387_supply_fsave instead of
i387_supply_register.
(go32_fetch_registers): Adjust call to i387_supply_fsave.
* i386nbsd-tdep.c (fetch_core_registers): Adjust call to
i387_supply_fsave.
(fetch_elfcore_registers): Adjust call to i387_supply_fsave and
i387_supply_fxsave.
* i386obsd-tdep.c (fetch_core_registers): Adjust call to
i387_supply_fsave.
* i386bsd-nat.c (supply_fpregset): Adjust call to
i387_supply_fsave.
(fetch_inferior_registers): Remove extraneous whitespace.  Adjust
call to i387_supply_fxsave.  Call i387_supply_fsave instead of
supply_fpregset.
(store_inferior_registers): Remove extraneous whitespace.  Call
i387_fill_fsave instead of fill_fpregset.
* i386gnu-nat.c (fetch_fpregs): Adjust call to i387_supply_fsave.
(supply_fpregset): Likewise.
* i386v4-nat.c (supply_fpregset): Adjust call to
i387_supply_fsave.
* i386-interix-nat.c (supply_fpregset): Adjust call to
i387_supply_fsave.
* i386-linux-nat.c (supply_fpregset): Adjust call to
i387_supply_fsave.
(supply_fpxregset): Adjust call to i387_adjust_fxsave.
* i386-nto-tdep.c (i386nto_supply_fpregset): Adjust calls to
i387supply_fsave and i387_supply_fxsave.
* i387-tdep.c (i387_supply_fsave): Add `regnum' argument.
Incorporate code from `i387_supply_register.
(i387_supply_register): Remove.
(i387_supply_fxsave): Add `regnum' argument.
Update comments.
* i387-tdep.h (i387_supply_fsave, i387_supply_fsxave): Adjust
prototype.
(i387_supply_register): remove prototype.
Update comments.
@
text
@d690 2
d696 19
a714 1
  unsigned long int desc[3];
@


1.48
log
@	* Makefile.in (i386-linux-nat.o): Update dependencies.
	* config/i386/nm-linux.h (LINUX_CHILD_POST_STARTUP_INFERIOR): Define.
	* config/nm-linux.h (CHILD_POST_STARTUP_INFERIOR, CHILD_POST_ATTACH)
	(CHILD_FOLLOW_FORK, KILL_INFERIOR): Define.
	* i386-linux-nat.c: Include "linux-nat.h".
	(child_post_startup_inferior): New function.
	* i386-nat.c (child_post_startup_inferior): Wrap in #ifdef.
	* infptrace.c (kill_inferior): Wrap in #ifdef.
	* lin-lwp.c (lin_lwp_attach_lwp): Call child_post_attach after
	attaching to each LWP.
	(child_wait, lin_lwp_wait): Call linux_handle_extended_wait.
	(init_lin_lwp_ops): Fill in some more operations.
	* linux-nat.h (linux_enable_event_reporting)
	(linux_handle_extended_wait, linux_child_post_startup_inferior): New
	prototypes.
	* linux-nat.c (linux_enable_event_reporting): New function.
	(child_post_attach, linux_child_post_startup_inferior)
	(child_post_startup_inferior, child_follow_fork)
	(linux_handle_extended_wait, kill_inferior): New functions.
@
text
@d323 1
a323 1
  i387_supply_fsave ((char *) fpregsetp);
d388 1
a388 1
  i387_supply_fxsave ((char *) fpxregsetp);
@


1.48.2.1
log
@2003-08-21  Andrew Cagney  <cagney@@redhat.com>

	* i386-tdep.h (i386_regnums): Replace I386_EAX_REGNUM,
	I386_EDX_REGNUM, I386_ESP_REGNUM, I386_EBP_REGNUM,
	I386_EIP_REGNUM, I386_EFLAGS_REGNUM, I386_ST0_REGNUM.
	* i386-linux-tdep.h (i386_linux_greg_offset): Declare.
	(i386_linux_supply_fpxregset): Declare.
	(i386_linux_supply_fpregset): Declare.
	(i386_linux_supply_gregset): Declare.
	* i386-linux-tdep.c: Include "gdb_assert.h", and "i387-tdep.h".
	Do not include "gregset.h".
	(enum user_regs): Define.
	(struct regnum_map, struct regnum_to_user): Define.
	(i386_linux_greg_offset): New function.
	(dummy_sse_values): New function, copied from "i386-linux-nat.c"
	make hist independant.
	(i386_linux_supply_fpregset): New function.
	(i386_linux_supply_gregset): New function.
	(i386_linux_supply_fpxregset): New function.
	(fetch_core_registers): New function.
	(i386_linux_core_sniffer): New function.
	(i386_linux_core_fns): New table.
	(_initialize_i386_linux_tdep): Add i386_linux_core_fns to core
	functions.
	* i386-linux-nat.c: Do not include "gregset.h".
	(dummy_sse_values) Delete function.
	(regmap): Delete array.
	(register_u_addr, fill_gregset, cannot_fetch_register): Use
	i386_linux_greg_offset.
	(cannot_store_register): Call cannot_fetch_register.
	(supply_gregset): Call i386_linux_supply_gregset.
	(supply_fpregset): Call i386_linux_supply_fpregset.
	(supply_fpxregset): Call i386_linux_supply_fpxregset.
	(fetch_core_registers): Delete function.
	(linux_elf_core_fns): Delete table.
	(_initialize_i386_linux_nat): Delete function.
@
text
@d62 3
d76 3
d81 30
d157 1
a157 3
  long offset = i386_linux_greg_offset (regnum);
  gdb_assert (offset >= 0);
  return (blockend + offset);
d235 8
a242 1
  i386_linux_supply_gregset (gregsetp);
d252 1
a252 1
  bfd_byte *regp = (bfd_byte *) gregsetp;
d257 1
a257 5
      {
	long offset = i386_linux_greg_offset (i);
	if (offset >= 0)
	  regcache_collect (i, regp + offset);
      }
d259 3
a261 6
  if (regno == -1 || regno == I386_LINUX_ORIG_EAX_REGNUM)
    {
      long offset = i386_linux_greg_offset (I386_LINUX_ORIG_EAX_REGNUM);
      if (offset >= 0)
	regcache_collect (I386_LINUX_ORIG_EAX_REGNUM, regp + offset);
    }
d323 2
a324 1
  i386_linux_supply_fpregset (fpregsetp);
d388 1
a388 1
  i386_linux_supply_fpxregset (fpxregsetp);
d459 21
d484 1
d500 1
a500 2
  return (!have_ptrace_getregs
	  && i386_linux_greg_offset (regno) < 0);
d506 2
a507 1
  return cannot_fetch_register (regno);
d732 75
d900 19
@


1.47
log
@
2003-06-04  Jeff Johnston  <jjohnstn@@redhat.com>

        * acconfig.h: Add HAVE_TKILL_SYSCALL definition check.
        * config.in: Regenerated.
        * configure.in: Add test for syscall function and check for
        __NR_tkill macro in <syscall.h> to set HAVE_TKILL_SYSCALL.
        * configure: Regenerated.
        * lin-lwp.c [HAVE_TKILL_SYSCALL]: Include <unistd.h> and
        <sys/syscall.h>.
        (kill_lwp): New function that uses tkill syscall or
        uses kill, depending on whether threading model is nptl or not.
        All callers of kill() changed to use kill_lwp().
        (lin_lwp_wait): Make special check when WIFEXITED occurs to
        see if all threads have already exited in the nptl model.
        (stop_and_resume_callback): New callback function used by the
        lin_lwp_wait thread exit handling code.
        (stop_wait_callback): Check for threads already having exited and
        delete such threads fromt the lwp list when discovered.
        (stop_callback): Don't assert retcode of kill call.

        Roland McGrath  <roland@@redhat.com>
        * i386-linux-nat.c (ps_get_thread_area): New function needed by
        nptl libthread_db.
@
text
@d26 1
d893 7
@


1.47.6.1
log
@	* Makefile.in (i386-linux-nat.o): Update dependencies.
	* config/i386/nm-linux.h (LINUX_CHILD_POST_STARTUP_INFERIOR): Define.
	* config/nm-linux.h (CHILD_POST_STARTUP_INFERIOR, CHILD_POST_ATTACH)
	(CHILD_FOLLOW_FORK, KILL_INFERIOR): Define.
	* i386-linux-nat.c: Include "linux-nat.h".
	(child_post_startup_inferior): New function.
	* i386-nat.c (child_post_startup_inferior): Wrap in #ifdef.
	* infptrace.c (kill_inferior): Wrap in #ifdef.
	* lin-lwp.c (lin_lwp_attach_lwp): Call child_post_attach after
	attaching to each LWP.
	(child_wait, lin_lwp_wait): Call linux_handle_extended_wait.
	(init_lin_lwp_ops): Fill in some more operations.
	* linux-nat.h (linux_enable_event_reporting)
	(linux_handle_extended_wait, linux_child_post_startup_inferior): New
	prototypes.
	* linux-nat.c (linux_enable_event_reporting): New function.
	(child_post_attach, linux_child_post_startup_inferior)
	(child_post_startup_inferior, child_follow_fork)
	(linux_handle_extended_wait, kill_inferior): New functions.
@
text
@a25 1
#include "linux-nat.h"
a891 7
}

void
child_post_startup_inferior (ptid_t ptid)
{
  i386_cleanup_dregs ();
  linux_child_post_startup_inferior (ptid);
@


1.47.6.2
log
@2003-08-26  Andrew Cagney  <cagney@@redhat.com>

	* i386-linux-nat.c (ps_get_thread_area): Make "desc" four "int"s
	in size.  Add comments.
@
text
@a689 2
/* Called by libthread_db.  Return's a pointer to the thread local
   storage (or it's descriptor).  */
d694 1
a694 19
  /* NOTE: cagney/2003-08-26: The definition of this buffer is found
     in the kernel header <asm-i386/ldt.h>.  It, after padding, is 4 x
     4 byte integers in size: "entry_number", "base_addr", "limit",
     and a bunch of status bits.

     The values returned by this ptrace call should be part of the
     regcache buffer, and ps_get_thread_area should channel its
     request through the regcache.  That way remote targets could
     provide the value using the remote protocol and not this direct
     call.

     Is this function needed?  I'm guessing that the "base" is the
     address of a a descriptor that libthread_db uses to find the
     thread local address base that GDB needs.  Perhaphs that
     descriptor is defined by the ABI.  Anyway, given that
     libthread_db calls this function without prompting (gdb
     requesting tls base) I guess it needs info in there anyway.  */
  unsigned int desc[4];
  gdb_assert (sizeof (int) == 4);
@


1.46
log
@* i386-linux-nat.c (child_resume): Use I386_ESP_REGNUM instead of
SP_REGNUM.
* i386-linux-tdep.c (i386_linux_sigcontext_addr): Likewise.
* i386bsd-tdep.c (i386bsd_sigcontext_addr): Likewise.
@
text
@d73 3
d687 15
@


1.45
log
@* i386-linux-nat.c (supply_gregset): Remove unnecessary casts.
@
text
@d855 1
a855 1
	      CORE_ADDR sp = read_register (SP_REGNUM);
@


1.44
log
@* i386-linux-nat.c: Add some whitespace to make things more
readable.
(fetch_register, store_register, fetch_inferior_registers,
store_inferior_registers): Get rid of assignment in if-statement.
(store_register): Fix typo in error message.
@
text
@a74 1

d235 1
a235 1
    supply_register (i, (char *) (regp + regmap[i]));
d238 1
a238 1
    supply_register (I386_LINUX_ORIG_EAX_REGNUM, (char *) (regp + ORIG_EAX));
@


1.44.2.1
log
@Merge from mainline.
@
text
@d75 1
d236 1
a236 1
    supply_register (i, regp + regmap[i]);
d239 1
a239 1
    supply_register (I386_LINUX_ORIG_EAX_REGNUM, regp + ORIG_EAX);
@


1.43
log
@* i386-linux-nat.c (ORIG_EAX): Define to -1 if not already
defined.
(regmap): Extend to cover all registers.
(PT_READ_U, PT_WRITE_U, PTRACE_XFER_TYPE,
OLD_CANNOT_FETCH_REGISTERS, OLD_CANNOT_STORE_REGISTERS): Remove
definitions.
(fetch_register, sore_register): Simplify.
(old_fetch_inferior_registers, old_store_inferior_registers):
Remove functions.
(cannot_fetch_register, cannot_store_register): Change
implementation to use regmap array to decide which registers
cannot be fetched/stored.  This removes $orig_eax from the
registers that cannot be fetched/stored.
(fetch_inferior_registers): Call fetch_register directly instead
of calling old_fetch_inferior_registers.
(store_inferior_registers): Call store_register directly instead
of calling old_store_inferior_registers.
(i386_linux_dr_get): Replace PT_READ_U with PTRACE_PEEKUSER.
(i386_linux_dr_set): Replace PT_WRITE_U with PTRACE_POKEUSER.
* config/i386/nm-linux.h (U_REGS_OFFSET): Remove definition.
@
text
@d110 1
d113 1
d116 1
d184 3
a186 2
  if ((tid = TIDGET (inferior_ptid)) == 0)
    tid = PIDGET (inferior_ptid);	/* Not a threaded program.  */
d210 3
a212 2
  if ((tid = TIDGET (inferior_ptid)) == 0)
    tid = PIDGET (inferior_ptid);	/* Not a threaded program.  */
d218 1
a218 1
    error ("Couldn't read register %s (#%d): %s.", REGISTER_NAME (regno),
d530 3
a532 2
  if ((tid = TIDGET (inferior_ptid)) == 0)
    tid = PIDGET (inferior_ptid);		/* Not a threaded program.  */
d602 3
a604 2
  if ((tid = TIDGET (inferior_ptid)) == 0)
    tid = PIDGET (inferior_ptid);	/* Not a threaded program.  */
@


1.42
log
@* i386-linux-nat.c (dummy_sse_values): Only try to fill in the SSE
registers if the target really has them.


* defs.h: Move inclusion of "ansidecl.h" before "gdb_locale.h".
Fix some whitespace problems.
@
text
@d37 4
d97 9
a105 1
  DS, ES, FS, GS
d163 1
a163 25
/* Fetching registers directly from the U area, one at a time.  */

/* FIXME: kettenis/2000-03-05: This duplicates code from `inptrace.c'.
   The problem is that we define FETCH_INFERIOR_REGISTERS since we
   want to use our own versions of {fetch,store}_inferior_registers
   that use the GETREGS request.  This means that the code in
   `infptrace.c' is #ifdef'd out.  But we need to fall back on that
   code when GDB is running on top of a kernel that doesn't support
   the GETREGS request.  I want to avoid changing `infptrace.c' right
   now.  */

#ifndef PT_READ_U
#define PT_READ_U PTRACE_PEEKUSR
#endif
#ifndef PT_WRITE_U
#define PT_WRITE_U PTRACE_POKEUSR
#endif

/* Default the type of the ptrace transfer to int.  */
#ifndef PTRACE_XFER_TYPE
#define PTRACE_XFER_TYPE int
#endif

/* Registers we shouldn't try to fetch.  */
#define OLD_CANNOT_FETCH_REGISTER(regno) ((regno) >= I386_NUM_GREGS)
a169 6
  /* This isn't really an address.  But ptrace thinks of it as one.  */
  CORE_ADDR regaddr;
  char mess[128];		/* For messages */
  register int i;
  unsigned int offset;		/* Offset of registers within the u area.  */
  char buf[MAX_REGISTER_RAW_SIZE];
d171 1
d173 2
a174 1
  if (OLD_CANNOT_FETCH_REGISTER (regno))
d176 1
a176 2
      memset (buf, '\0', REGISTER_RAW_SIZE (regno));	/* Supply zeroes */
      supply_register (regno, buf);
d180 1
a180 1
  /* Overload thread id onto process id */
d182 1
a182 1
    tid = PIDGET (inferior_ptid);	/* no thread id, just use process id */
d184 5
a188 1
  offset = U_REGS_OFFSET;
d190 1
a190 35
  regaddr = register_addr (regno, offset);
  for (i = 0; i < REGISTER_RAW_SIZE (regno); i += sizeof (PTRACE_XFER_TYPE))
    {
      errno = 0;
      *(PTRACE_XFER_TYPE *) & buf[i] = ptrace (PT_READ_U, tid,
					       (PTRACE_ARG3_TYPE) regaddr, 0);
      regaddr += sizeof (PTRACE_XFER_TYPE);
      if (errno != 0)
	{
	  sprintf (mess, "reading register %s (#%d)", 
		   REGISTER_NAME (regno), regno);
	  perror_with_name (mess);
	}
    }
  supply_register (regno, buf);
}

/* Fetch register values from the inferior.
   If REGNO is negative, do this for all registers.
   Otherwise, REGNO specifies which register (so we can save time). */

void
old_fetch_inferior_registers (int regno)
{
  if (regno >= 0)
    {
      fetch_register (regno);
    }
  else
    {
      for (regno = 0; regno < NUM_REGS; regno++)
	{
	  fetch_register (regno);
	}
    }
a192 3
/* Registers we shouldn't try to store.  */
#define OLD_CANNOT_STORE_REGISTER(regno) ((regno) >= I386_NUM_GREGS)

a197 5
  /* This isn't really an address.  But ptrace thinks of it as one.  */
  CORE_ADDR regaddr;
  char mess[128];		/* For messages */
  register int i;
  unsigned int offset;		/* Offset of registers within the u area.  */
d199 1
d201 3
a203 4
  if (OLD_CANNOT_STORE_REGISTER (regno))
    {
      return;
    }
d205 1
a205 1
  /* Overload thread id onto process id */
d207 1
a207 1
    tid = PIDGET (inferior_ptid);	/* no thread id, just use process id */
d209 6
a214 36
  offset = U_REGS_OFFSET;

  regaddr = register_addr (regno, offset);
  for (i = 0; i < REGISTER_RAW_SIZE (regno); i += sizeof (PTRACE_XFER_TYPE))
    {
      errno = 0;
      ptrace (PT_WRITE_U, tid, (PTRACE_ARG3_TYPE) regaddr,
	      *(PTRACE_XFER_TYPE *) & registers[REGISTER_BYTE (regno) + i]);
      regaddr += sizeof (PTRACE_XFER_TYPE);
      if (errno != 0)
	{
	  sprintf (mess, "writing register %s (#%d)", 
		   REGISTER_NAME (regno), regno);
	  perror_with_name (mess);
	}
    }
}

/* Store our register values back into the inferior.
   If REGNO is negative, do this for all registers.
   Otherwise, REGNO specifies which register (so we can save time).  */

void
old_store_inferior_registers (int regno)
{
  if (regno >= 0)
    {
      store_register (regno);
    }
  else
    {
      for (regno = 0; regno < NUM_REGS; regno++)
	{
	  store_register (regno);
	}
    }
d491 2
a492 3
  if (! have_ptrace_getregs)
    return OLD_CANNOT_FETCH_REGISTER (regno);
  return 0;
d494 1
d498 2
a499 3
  if (! have_ptrace_getregs)
    return OLD_CANNOT_STORE_REGISTER (regno);
  return 0;
d513 1
a513 1
  if (! have_ptrace_getregs)
d515 6
a520 1
      old_fetch_inferior_registers (regno);
d537 1
a537 1
      if (! have_ptrace_getregs)
d539 1
a539 1
	  old_fetch_inferior_registers (-1);
d584 1
a584 1
  if (! have_ptrace_getregs)
d586 6
a591 1
      old_store_inferior_registers (regno);
d651 1
a651 1
  value = ptrace (PT_READ_U, tid,
d674 1
a674 1
  ptrace (PT_WRITE_U, tid,
@


1.42.6.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d3 1
a3 1
   Copyright 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
a25 1
#include "linux-nat.h"
a36 4
#ifndef ORIG_EAX
#define ORIG_EAX -1
#endif

a68 3
/* Defines ps_err_e, struct ps_prochandle.  */
#include "gdb_proc_service.h"

d71 1
d93 1
a93 9
  DS, ES, FS, GS,
  -1, -1, -1, -1,		/* st0, st1, st2, st3 */
  -1, -1, -1, -1,		/* st4, st5, st6, st7 */
  -1, -1, -1, -1,		/* fctrl, fstat, ftag, fiseg */
  -1, -1, -1, -1,		/* fioff, foseg, fooff, fop */
  -1, -1, -1, -1,		/* xmm0, xmm1, xmm2, xmm3 */
  -1, -1, -1, -1,		/* xmm4, xmm5, xmm6, xmm6 */
  -1,				/* mxcsr */
  ORIG_EAX
a97 1

a99 1

a101 1

d151 25
a175 1
/* Accessing registers through the U area, one at a time.  */
d182 6
a188 1
  int val;
d190 1
a190 2
  gdb_assert (!have_ptrace_getregs);
  if (cannot_fetch_register (regno))
d192 2
a193 1
      supply_register (regno, NULL);
d197 22
a218 4
  /* GNU/Linux LWP ID's are process ID's.  */
  tid = TIDGET (inferior_ptid);
  if (tid == 0)
    tid = PIDGET (inferior_ptid); /* Not a threaded program.  */
d220 3
a222 5
  errno = 0;
  val = ptrace (PTRACE_PEEKUSER, tid, register_addr (regno, 0), 0);
  if (errno != 0)
    error ("Couldn't read register %s (#%d): %s.", REGISTER_NAME (regno),
	   regno, safe_strerror (errno));
d224 14
a237 1
  supply_register (regno, &val);
d240 3
d248 5
a253 1
  int val;
d255 26
a280 3
  gdb_assert (!have_ptrace_getregs);
  if (cannot_store_register (regno))
    return;
d282 3
a284 4
  /* GNU/Linux LWP ID's are process ID's.  */
  tid = TIDGET (inferior_ptid);
  if (tid == 0)
    tid = PIDGET (inferior_ptid); /* Not a threaded program.  */
d286 14
a299 6
  errno = 0;
  regcache_collect (regno, &val);
  ptrace (PTRACE_POKEUSER, tid, register_addr (regno, 0), val);
  if (errno != 0)
    error ("Couldn't write register %s (#%d): %s.", REGISTER_NAME (regno),
	   regno, safe_strerror (errno));
d316 1
a316 1
    supply_register (i, regp + regmap[i]);
d319 1
a319 1
    supply_register (I386_LINUX_ORIG_EAX_REGNUM, regp + ORIG_EAX);
d400 1
a400 1
  i387_supply_fsave (current_regcache, -1, fpregsetp);
d465 1
a465 1
  i387_supply_fxsave (current_regcache, -1, fpxregsetp);
d576 3
a578 2
  gdb_assert (regno >= 0 && regno < NUM_REGS);
  return (!have_ptrace_getregs && regmap[regno] == -1);
a579 1

d583 3
a585 2
  gdb_assert (regno >= 0 && regno < NUM_REGS);
  return (!have_ptrace_getregs && regmap[regno] == -1);
d599 1
a599 1
  if (!have_ptrace_getregs)
d601 1
a601 6
      int i;

      for (i = 0; i < NUM_REGS; i++)
	if (regno == -1 || regno == i)
	  fetch_register (i);

d606 2
a607 3
  tid = TIDGET (inferior_ptid);
  if (tid == 0)
    tid = PIDGET (inferior_ptid); /* Not a threaded program.  */
d618 1
a618 1
      if (!have_ptrace_getregs)
d620 1
a620 1
	  fetch_inferior_registers (regno);
d665 1
a665 1
  if (!have_ptrace_getregs)
d667 1
a667 6
      int i;

      for (i = 0; i < NUM_REGS; i++)
	if (regno == -1 || regno == i)
	  store_register (i);

d672 2
a673 3
  tid = TIDGET (inferior_ptid);
  if (tid == 0)
    tid = PIDGET (inferior_ptid); /* Not a threaded program.  */
d727 1
a727 1
  value = ptrace (PTRACE_PEEKUSER, tid,
d750 1
a750 1
  ptrace (PTRACE_POKEUSER, tid,
d785 12
a796 2
/* Called by libthread_db.  Returns a pointer to the thread local
   storage (or its descriptor).  */
d798 4
a801 31
ps_err_e
ps_get_thread_area (const struct ps_prochandle *ph, 
		    lwpid_t lwpid, int idx, void **base)
{
  /* NOTE: cagney/2003-08-26: The definition of this buffer is found
     in the kernel header <asm-i386/ldt.h>.  It, after padding, is 4 x
     4 byte integers in size: `entry_number', `base_addr', `limit',
     and a bunch of status bits.

     The values returned by this ptrace call should be part of the
     regcache buffer, and ps_get_thread_area should channel its
     request through the regcache.  That way remote targets could
     provide the value using the remote protocol and not this direct
     call.

     Is this function needed?  I'm guessing that the `base' is the
     address of a a descriptor that libthread_db uses to find the
     thread local address base that GDB needs.  Perhaphs that
     descriptor is defined by the ABI.  Anyway, given that
     libthread_db calls this function without prompting (gdb
     requesting tls base) I guess it needs info in there anyway.  */
  unsigned int desc[4];
  gdb_assert (sizeof (int) == 4);

#ifndef PTRACE_GET_THREAD_AREA
#define PTRACE_GET_THREAD_AREA 25
#endif

  if (ptrace (PTRACE_GET_THREAD_AREA, lwpid,
	      (void *) idx, (unsigned long) &desc) < 0)
    return PS_ERR;
d803 53
a855 2
  *(int *)base = desc[1];
  return PS_OK;
d925 1
a925 1
	      CORE_ADDR sp = read_register (I386_ESP_REGNUM);
d945 13
d960 1
a960 1
child_post_startup_inferior (ptid_t ptid)
d962 1
a962 2
  i386_cleanup_dregs ();
  linux_child_post_startup_inferior (ptid);
@


1.42.6.2
log
@Merge mainline to branch.  GDB is broken until I update cp-names.y.
@
text
@a643 2
/* Support for debug registers.  */

@


1.42.4.1
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@a36 4
#ifndef ORIG_EAX
#define ORIG_EAX -1
#endif

d93 1
a93 9
  DS, ES, FS, GS,
  -1, -1, -1, -1,		/* st0, st1, st2, st3 */
  -1, -1, -1, -1,		/* st4, st5, st6, st7 */
  -1, -1, -1, -1,		/* fctrl, fstat, ftag, fiseg */
  -1, -1, -1, -1,		/* fioff, foseg, fooff, fop */
  -1, -1, -1, -1,		/* xmm0, xmm1, xmm2, xmm3 */
  -1, -1, -1, -1,		/* xmm4, xmm5, xmm6, xmm6 */
  -1,				/* mxcsr */
  ORIG_EAX
d151 25
a175 1
/* Accessing registers through the U area, one at a time.  */
d182 6
a188 1
  int val;
d190 1
a190 2
  gdb_assert (!have_ptrace_getregs);
  if (cannot_fetch_register (regno))
d192 2
a193 1
      supply_register (regno, NULL);
d197 1
a197 1
  /* GNU/Linux LWP ID's are process ID's.  */
d199 20
a218 1
    tid = PIDGET (inferior_ptid);	/* Not a threaded program.  */
d220 3
a222 5
  errno = 0;
  val = ptrace (PTRACE_PEEKUSER, tid, register_addr (regno, 0), 0);
  if (errno != 0)
    error ("Couldn't read register %s (#%d): %s.", REGISTER_NAME (regno),
	   regno, safe_strerror (errno));
d224 14
a237 1
  supply_register (regno, &val);
d240 3
d248 5
a253 1
  int val;
d255 4
a258 3
  gdb_assert (!have_ptrace_getregs);
  if (cannot_store_register (regno))
    return;
d260 1
a260 1
  /* GNU/Linux LWP ID's are process ID's.  */
d262 23
a284 1
    tid = PIDGET (inferior_ptid);	/* Not a threaded program.  */
d286 14
a299 6
  errno = 0;
  regcache_collect (regno, &val);
  ptrace (PTRACE_POKEUSER, tid, register_addr (regno, 0), val);
  if (errno != 0)
    error ("Couldn't read register %s (#%d): %s.", REGISTER_NAME (regno),
	   regno, safe_strerror (errno));
d576 3
a578 2
  gdb_assert (regno >= 0 && regno < NUM_REGS);
  return (!have_ptrace_getregs && regmap[regno] == -1);
a579 1

d583 3
a585 2
  gdb_assert (regno >= 0 && regno < NUM_REGS);
  return (!have_ptrace_getregs && regmap[regno] == -1);
d599 1
a599 1
  if (!have_ptrace_getregs)
d601 1
a601 6
      int i;

      for (i = 0; i < NUM_REGS; i++)
	if (regno == -1 || regno == i)
	  fetch_register (i);

d618 1
a618 1
      if (!have_ptrace_getregs)
d620 1
a620 1
	  fetch_inferior_registers (regno);
d665 1
a665 1
  if (!have_ptrace_getregs)
d667 1
a667 6
      int i;

      for (i = 0; i < NUM_REGS; i++)
	if (regno == -1 || regno == i)
	  store_register (i);

d727 1
a727 1
  value = ptrace (PTRACE_PEEKUSER, tid,
d750 1
a750 1
  ptrace (PTRACE_POKEUSER, tid,
@


1.42.4.2
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@a109 1

a111 1

a113 1

d181 2
a182 3
  tid = TIDGET (inferior_ptid);
  if (tid == 0)
    tid = PIDGET (inferior_ptid); /* Not a threaded program.  */
d206 2
a207 3
  tid = TIDGET (inferior_ptid);
  if (tid == 0)
    tid = PIDGET (inferior_ptid); /* Not a threaded program.  */
d213 1
a213 1
    error ("Couldn't write register %s (#%d): %s.", REGISTER_NAME (regno),
d525 2
a526 3
  tid = TIDGET (inferior_ptid);
  if (tid == 0)
    tid = PIDGET (inferior_ptid); /* Not a threaded program.  */
d596 2
a597 3
  tid = TIDGET (inferior_ptid);
  if (tid == 0)
    tid = PIDGET (inferior_ptid); /* Not a threaded program.  */
@


1.42.4.3
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d75 1
d236 1
a236 1
    supply_register (i, regp + regmap[i]);
d239 1
a239 1
    supply_register (I386_LINUX_ORIG_EAX_REGNUM, regp + ORIG_EAX);
@


1.42.4.4
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@a72 3
/* Defines ps_err_e, struct ps_prochandle.  */
#include "gdb_proc_service.h"

a685 15
extern ps_err_e
ps_get_thread_area(const struct ps_prochandle *ph, 
		   lwpid_t lwpid, int idx, void **base)
{
  unsigned long int desc[3];
#define PTRACE_GET_THREAD_AREA 25

  if  (ptrace (PTRACE_GET_THREAD_AREA, 
	       lwpid, (void *) idx, (unsigned long) &desc) < 0)
    return PS_ERR;

  *(int *)base = desc[1];
  return PS_OK;
}

d855 1
a855 1
	      CORE_ADDR sp = read_register (I386_ESP_REGNUM);
@


1.42.4.5
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@a25 1
#include "linux-nat.h"
d322 1
a322 1
  i387_supply_fsave ((const char *) fpregsetp, -1);
d387 1
a387 1
  i387_supply_fxsave ((const char *) fpxregsetp, -1);
d689 15
a732 40
/* Called by libthread_db.  Returns a pointer to the thread local
   storage (or its descriptor).  */

ps_err_e
ps_get_thread_area (const struct ps_prochandle *ph, 
		    lwpid_t lwpid, int idx, void **base)
{
  /* NOTE: cagney/2003-08-26: The definition of this buffer is found
     in the kernel header <asm-i386/ldt.h>.  It, after padding, is 4 x
     4 byte integers in size: `entry_number', `base_addr', `limit',
     and a bunch of status bits.

     The values returned by this ptrace call should be part of the
     regcache buffer, and ps_get_thread_area should channel its
     request through the regcache.  That way remote targets could
     provide the value using the remote protocol and not this direct
     call.

     Is this function needed?  I'm guessing that the `base' is the
     address of a a descriptor that libthread_db uses to find the
     thread local address base that GDB needs.  Perhaphs that
     descriptor is defined by the ABI.  Anyway, given that
     libthread_db calls this function without prompting (gdb
     requesting tls base) I guess it needs info in there anyway.  */
  unsigned int desc[4];
  gdb_assert (sizeof (int) == 4);

#ifndef PTRACE_GET_THREAD_AREA
#define PTRACE_GET_THREAD_AREA 25
#endif

  if (ptrace (PTRACE_GET_THREAD_AREA, lwpid,
	      (void *) idx, (unsigned long) &desc) < 0)
    return PS_ERR;

  *(int *)base = desc[1];
  return PS_OK;
}


a891 7
}

void
child_post_startup_inferior (ptid_t ptid)
{
  i386_cleanup_dregs ();
  linux_child_post_startup_inferior (ptid);
@


1.42.4.6
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d3 1
a3 1
   Copyright 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d323 1
a323 1
  i387_supply_fsave (current_regcache, -1, fpregsetp);
d388 1
a388 1
  i387_supply_fxsave (current_regcache, -1, fpxregsetp);
d759 74
d925 19
@


1.42.4.7
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@a643 2
/* Support for debug registers.  */

@


1.41
log
@	* Makefile.in (osabi.o, i387-tdep.o, i386-linux-nat.o, lin-lwp.o,
	ax-gdb.o, signals.o, jv-valprint.o, c-valprint.o, cp-abi.o):
	Update dependencies.
	* i387-tdep.c: Include gdb_string.h.
	* osabi.c: Likewise.
	* i386-linux-nat.c: Likewise.
	* lin-lwp.c: Likewise.
	* ax-gdb.c: Likewise.
	* signals/signals.c: Likewise.
	* jv-valprint.c: Likewise.
	* p-lang.c: Likewise.
	* c-valprint.c: Likewise.
	* cp-abi.c: Likewise.
@
text
@d544 1
d551 1
a551 1
  for (reg = 0; reg < 8; reg++)
d553 2
a554 1
  supply_register (MXCSR_REGNUM, (char *) &mxcsr);
@


1.40
log
@* i386-linux-nat.c (OLD_CANNOT_FETCH_REGISTER,
OLD_CANNOT_STORE_REGISTER, supply_gregset, fill_gregset): Replace
usage of NUM_GREGS with I386_NUM_GREGS.
@
text
@d28 1
@


1.39
log
@* i386-linux-nat.c (fill_gregset): Remove redundant parentheses.
@
text
@d174 1
a174 1
#define OLD_CANNOT_FETCH_REGISTER(regno) ((regno) >= NUM_GREGS)
d240 1
a240 1
#define OLD_CANNOT_STORE_REGISTER(regno) ((regno) >= NUM_GREGS)
d314 1
a314 1
  for (i = 0; i < NUM_GREGS; i++)
d331 1
a331 1
  for (i = 0; i < NUM_GREGS; i++)
@


1.38
log
@* Makefile.in (i386_linux_tdep_h): Define.
(i386_tdep_h, i387_tdep_h): Define.
(i386-linux-nat.o): Add $(i386_linux_tdep_h),
$(i386_tdep_h) and $(i387_tdep_h).
* i386-linux-nat.c: Include "i386-linux-tdep.h".
@
text
@d332 1
a332 1
    if ((regno == -1 || regno == i))
@


1.37
log
@* i386-linux-nat.c (suppy_gregset): Don't supply
I386_LINUX_ORIG_EAX_REGNUM if there isn't room for it in GDB's
register cache.
(fill_gregset): Don't fetch it under the same circumstances.
@
text
@d65 3
@


1.36
log
@* Makefile.in (ALLDEPFILES): Remove i387-nat.c.
(i387-nat.o): Delete dependency list.
(go32-nat.o): Change i387-nat.h to i387-tdep.h.
(x86-64-linux-nat.o): Likewise.
* i387-nat.c: Delete file, moving contents to...
* i387-tdep.c: ...here.
* i387-nat.h: Rename...
* i387-tdep.h: ...to this.
* go32-nat.c: Include i387-tdep.h instead of i387-nat.h.
* i386-linux-nat.c: Likewise.
* i386bsd-nat.c: Likewise.
* i386gnu-nat.c: Likewise.
* i386nbsd-nat.c: Likewise.
* i386v4-nat.c: Likewise.
* x86-64-linux-nat.c: Likewise.
* config/i386/fbsd.mh (NATDEPFILES): Remove i387-nat.o.
* config/i386/go32.mh (NATDEPFILES): Likewise.
* config/i386/i386gnu.mh (NATDEPFILES): Likewise.
* config/i386/i386sol2.mh (NATDEPFILES): Likewise.
* config/i386/i386v42mp.mh (NATDEPFILES): Likewise.
* config/i386/linux.mh (NATDEPFILES): Likewise.
* config/i386/nbsd.mh (NATDEPFILES): Likewise.
* config/i386/nbsdelf.mh (NATDEPFILES): Likewise.
* config/i386/obsd.mh (NATDEPFILES): Likewise.
* config/i386/x86-64linux.mh (NATDEPFILES): Likewise.
@
text
@d314 2
a315 1
  supply_register (I386_LINUX_ORIG_EAX_REGNUM, (char *) (regp + ORIG_EAX));
d332 2
a333 1
  if (regno == -1 || regno == I386_LINUX_ORIG_EAX_REGNUM)
@


1.36.4.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@a64 3
/* Defines I386_LINUX_ORIG_EAX_REGNUM.  */
#include "i386-linux-tdep.h"

d171 1
a171 1
#define OLD_CANNOT_FETCH_REGISTER(regno) ((regno) >= I386_NUM_GREGS)
d237 1
a237 1
#define OLD_CANNOT_STORE_REGISTER(regno) ((regno) >= I386_NUM_GREGS)
d311 1
a311 1
  for (i = 0; i < I386_NUM_GREGS; i++)
d314 1
a314 2
  if (I386_LINUX_ORIG_EAX_REGNUM < NUM_REGS)
    supply_register (I386_LINUX_ORIG_EAX_REGNUM, (char *) (regp + ORIG_EAX));
d327 2
a328 2
  for (i = 0; i < I386_NUM_GREGS; i++)
    if (regno == -1 || regno == i)
d331 1
a331 2
  if ((regno == -1 || regno == I386_LINUX_ORIG_EAX_REGNUM)
      && I386_LINUX_ORIG_EAX_REGNUM < NUM_REGS)
@


1.36.4.2
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@a27 1
#include "gdb_string.h"
@


1.36.4.3
log
@Merge with kseitz_interps-20020930-merge.
@
text
@a543 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d550 1
a550 1
  for (reg = 0; reg < tdep->num_xmm_regs; reg++)
d552 1
a552 2
  if (tdep->num_xmm_regs > 0)
    supply_register (MXCSR_REGNUM, (char *) &mxcsr);
@


1.36.2.1
log
@merge from trunk
@
text
@a64 3
/* Defines I386_LINUX_ORIG_EAX_REGNUM.  */
#include "i386-linux-tdep.h"

d314 1
a314 2
  if (I386_LINUX_ORIG_EAX_REGNUM < NUM_REGS)
    supply_register (I386_LINUX_ORIG_EAX_REGNUM, (char *) (regp + ORIG_EAX));
d331 1
a331 2
  if ((regno == -1 || regno == I386_LINUX_ORIG_EAX_REGNUM)
      && I386_LINUX_ORIG_EAX_REGNUM < NUM_REGS)
@


1.36.2.2
log
@Merge with trunk.
@
text
@d174 1
a174 1
#define OLD_CANNOT_FETCH_REGISTER(regno) ((regno) >= I386_NUM_GREGS)
d240 1
a240 1
#define OLD_CANNOT_STORE_REGISTER(regno) ((regno) >= I386_NUM_GREGS)
d314 1
a314 1
  for (i = 0; i < I386_NUM_GREGS; i++)
d331 2
a332 2
  for (i = 0; i < I386_NUM_GREGS; i++)
    if (regno == -1 || regno == i)
@


1.35
log
@s/Linux/.../
Fix PR gdb/378.
@
text
@d60 1
a60 1
#include "i387-nat.h"
@


1.34
log
@2002-01-09  Michael Snyder  <msnyder@@redhat.com>

	* i386-linux-nat.c (fill_fpxregset): Make global.
	(store_fpxregset): Ditto.
@
text
@d1 2
a2 1
/* Native-dependent code for Linux/x86.
d70 4
a73 4
/* The register sets used in Linux ELF core-dumps are identical to the
   register sets in `struct user' that is used for a.out core-dumps,
   and is also used by `ptrace'.  The corresponding types are
   `elf_gregset_t' for the general-purpose registers (with
d597 1
a597 1
  /* Linux LWP ID's are process ID's.  */
d663 1
a663 1
  /* Linux LWP ID's are process ID's.  */
d782 1
a782 1
   core-regset.c, because Linux has *three* different kinds of
d795 1
a795 1
   REG_ADDR isn't used on Linux.  */
d851 1
a851 1
/* The instruction for a Linux system call is:
d939 2
a940 1
/* Register that we are able to handle Linux ELF core file formats.  */
@


1.33
log
@2001-12-27  Michael Snyder  <msnyder@@redhat.com>

	* i386-linux-nat.c: Include i386-tdep.h.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001 Free Software Foundation, Inc.
d455 1
a455 1
static void
d465 1
a465 1
static void
@


1.32
log
@	* i386-linux-nat.c (fill_gregset): Fix botched regcache_collect()
	conversion for I386_LINUX_ORIG_EAX_REGNUM.
@
text
@d61 3
@


1.31
log
@	* i386-linux-nat.c (fill_gregset): Use regcache_collect() instead
	of accessing registers[] directly.
@
text
@d328 1
a328 1
    regcache_collect (I386_LINUX_ORIG_EAX_REGNUM, regp + regmap[ORIG_EAX]);
@


1.30
log
@	* i386-linux-nat.c (fill_gregset): Don't invoke read_register_gen()
	when fetching ORIG_EAX.
@
text
@d325 1
a325 1
      *(regp + regmap[i]) = *(elf_greg_t *) &registers[REGISTER_BYTE (i)];
d328 1
a328 2
    *(regp + regmap[ORIG_EAX]) =
      *(elf_greg_t *) &registers[REGISTER_BYTE (I386_LINUX_ORIG_EAX_REGNUM)];
@


1.29
log
@* i386-linux-nat.c (GETREGS_SUPPLIES, supply_gregset,
fill_gregset): Add support for "orig_eax" register.
@
text
@d328 2
a329 1
    read_register_gen (I386_LINUX_ORIG_EAX_REGNUM, (char *) (regp + ORIG_EAX));
@


1.28
log
@Redefine ptid_t to be a struct rather than an int.
@
text
@d91 1
a91 1
  (0 <= (regno) && (regno) <= 15)
d309 2
d326 3
@


1.27
log
@Phase 1 of the ptid_t changes.
@
text
@a63 11
/* On Linux, threads are implemented as pseudo-processes, in which
   case we may be tracing more than one process at a time.  In that
   case, inferior_ptid will contain the main process ID and the
   individual thread (process) ID mashed together.  These macros are
   used to separate them out.  These definitions should be overridden
   if thread support is included.  */

#if !defined (PIDGET)	/* Default definition for PIDGET/TIDGET.  */
#define PIDGET(PID)	PID
#define TIDGET(PID)	0
#endif
@


1.26
log
@* i386-linux-nat.c (i386_linux_dr_get): Change type of return
value to `unsigned long'.  Change type of `value' to `unsigned
long'.
(i386_linux_dr_set): Change type of second argument to `unsigned
long'.
(i386_linux_dr_set_control): Change type of first argument to
`unsigned long'.
(i386_linux_dr_get_status): Change type of return value to
unsigned long.
* config/i386/nm-linux.h (i386_linux_dr_set_control,
i386_linux_dr_get_status): Adjust prototypes accordingly.
@
text
@d66 1
a66 1
   case, inferior_pid will contain the main process ID and the
d201 2
a202 2
  if ((tid = TIDGET (inferior_pid)) == 0)
    tid = inferior_pid;		/* no thread id, just use process id */
d264 2
a265 2
  if ((tid = TIDGET (inferior_pid)) == 0)
    tid = inferior_pid;		/* no thread id, just use process id */
d600 2
a601 2
  if ((tid = TIDGET (inferior_pid)) == 0)
    tid = inferior_pid;		/* Not a threaded program.  */
d666 2
a667 2
  if ((tid = TIDGET (inferior_pid)) == 0)
    tid = inferior_pid;		/* Not a threaded program.  */
d713 1
a713 1
  tid = PIDGET (inferior_pid);
d741 1
a741 1
  tid = PIDGET (inferior_pid);
d882 1
a882 1
child_resume (int pid, int step, enum target_signal signal)
d884 2
d891 2
a892 2
       all threads" and "resume inferior_pid" are the same.  */
    pid = inferior_pid;
d896 1
a896 1
      CORE_ADDR pc = read_pc_pid (pid);
d913 2
a914 1
	  int syscall = read_register_pid (LINUX_SYSCALL_REGNUM, pid);
@


1.25
log
@* i386-linux-nat.c (i386_linux_dr_get): Return 0 if ptrace call
fails instead of calling perror_with_name.  This should fix
debugging remote i386 targets with a native Linux/x86 GDB.  Add
FIXME for this hack.
@
text
@d704 1
a704 1
static long
d708 1
a708 1
  long value;
d734 1
a734 1
i386_linux_dr_set (int regnum, long value)
d751 1
a751 1
i386_linux_dr_set_control (long control)
d772 1
a772 1
long
d919 1
a919 1
	      
@


1.24
log
@Make Linux use the new unified support for hardware breakpoints
and watchpoints on x86 targets.
* i386-linux-nat.c: Doc fixes.  Include "gdb_assert.h".
[HAVE_SYS_DEBUGREG_H]: Include <sys/debugreg.h>.
(DR_FIRSTADDR, DR_LASTADDR, DR_STATUS, DR_CONTROL): Define to
appropriate value if not already defined.
(register_u_addr): New function.
(kernel_u_size): New function.
(i386_linux_dr_get, i386_linux_dr_set): New functions.
(i386_linux_dr_set_control, i386_linux_dr_set_addr,
i386_linux_reset_addr, i386_linux_dr_get_status): New functions.
* config/i386/nm-linux.h: Don't include "nm-i386v.h".
(I386_USE_GENERIC_WATCHPOINTS): Define and include "nm-i386.h".
(TARGET_HAS_HARDWARE_WATCHPOINTS,
TARGET_CAN_USE_HARDWARE_WATCHPOINTS, HAVE_CONTINUABLE_WATCHPOINT,
STOPPED_BY_WATCHPOINT, target_insert_watchpoint,
target_remove_watchpoint): Remove macros.
(i386_stopped_by_watchpoint, i386_insert_watchpoint,
i386_remove_watchpoint): Remove prototypes.
(register_u_addr): New prototype.
(REGISTER_U_ADDR): Define in terms of register_u_addr.
(i386_linux_dr_set_control, i386_linux_dr_set_addr,
i386_linux_reset_addr, i386_linux_dr_get_status): New prototypes.
(I386_DR_LOW_SET_CONTROL, I386_DR_LOW_SET_ADDR,
I386_DR_LOW_RESET_ADDR, I386_DR_LOW_GET_STATUS): New macros.
* config/i386/linux.mh (NATDEPFILES): Replace i386v-nat.o with
i386-nat.o.
@
text
@d715 5
d724 1
d726 3
@


1.23
log
@Eliminate ARCH_NUM_REGS.
@
text
@d26 1
d35 20
d134 20
d701 66
@


1.22
log
@Create new file regcache.h.  Update all uses.
@
text
@d195 1
a195 1
      for (regno = 0; regno < ARCH_NUM_REGS; regno++)
d257 1
a257 1
      for (regno = 0; regno < ARCH_NUM_REGS; regno++)
@


1.21
log
@Add __FILE__ and __LINE__ parameter to internal_error() /
internal_verror().
@
text
@d24 1
@


1.20
log
@* alphabsd-nat.c, i386-linux-nat.c, i386bsd-nat.c: Fix typo in comment.
@
text
@d2 1
a2 1
   Copyright 1999, 2000 Free Software Foundation, Inc.
d603 2
a604 1
  internal_error ("Got request for bad register number %d.", regno);
d657 2
a658 1
  internal_error ("Got request to store bad register number %d.", regno);
@


1.19
log
@* i386-linux-nat.c (store_fpxregs): Add code to detect support for
the PTRACE_GETFPXREGS request, and return zero if it's not.
@
text
@d267 1
a267 1
/* Fill GDB's register array with the genereal-purpose register values
@


1.18
log
@	* i386-linux-nat.c (OLD_CANNOT_FETCH_REGISTER,
	OLD_CANNOT_FETCH_REGISTER):  New definitions for accessible registers
	when accessing the registers via the U area.
	(fetch_register, store_register):  Use them.
	(cannot_fetch_register, cannot_store_register):  New functions,
	all registers should be accessible if we have GETREGS support.
	* config/i386/nm-linux.h:  Use cannot_fetch/store_register for
	CANNOT_FETCH/STORE_REGISTER definitions.
@
text
@d472 9
a480 1
    perror_with_name ("Couldn't read floating-point and SSE registers");
@


1.17
log
@2000-08-29  Michael Snyder  <msnyder@@cleaver.cygnus.com>

        * i386-linux-nat.c (i386_linux_skip_solib_resolver,
        skip_hurd_resolver, find_minsym_and_objfile): Move these
        solib functions into i386-linux-tdep.c for cross debugging.
        * i386-linux-tdep.c: Receive the above functions.
@
text
@d136 1
a136 3
#if !defined (CANNOT_FETCH_REGISTER)
#define CANNOT_FETCH_REGISTER(regno) 0
#endif
d151 1
a151 1
  if (CANNOT_FETCH_REGISTER (regno))
d202 1
a202 3
#if !defined (CANNOT_STORE_REGISTER)
#define CANNOT_STORE_REGISTER(regno) 0
#endif
d216 1
a216 1
  if (CANNOT_STORE_REGISTER (regno))
d511 20
@


1.16
log
@* i386-linux-nat.c (fetch_inferior_registers): Move call to
dummy_sse_values ...
(supply_fpregset): ... here.
@
text
@a24 5
/* For i386_linux_skip_solib_resolver.  */
#include "symtab.h"
#include "symfile.h"
#include "objfiles.h"

a791 92
}


/* Calling functions in shared libraries.  */
/* FIXME: kettenis/2000-03-05: Doesn't this belong in a
   target-dependent file?  The function
   `i386_linux_skip_solib_resolver' is mentioned in
   `config/i386/tm-linux.h'.  */

/* Find the minimal symbol named NAME, and return both the minsym
   struct and its objfile.  This probably ought to be in minsym.c, but
   everything there is trying to deal with things like C++ and
   SOFUN_ADDRESS_MAYBE_TURQUOISE, ...  Since this is so simple, it may
   be considered too special-purpose for general consumption.  */

static struct minimal_symbol *
find_minsym_and_objfile (char *name, struct objfile **objfile_p)
{
  struct objfile *objfile;

  ALL_OBJFILES (objfile)
    {
      struct minimal_symbol *msym;

      ALL_OBJFILE_MSYMBOLS (objfile, msym)
	{
	  if (SYMBOL_NAME (msym)
	      && STREQ (SYMBOL_NAME (msym), name))
	    {
	      *objfile_p = objfile;
	      return msym;
	    }
	}
    }

  return 0;
}

static CORE_ADDR
skip_hurd_resolver (CORE_ADDR pc)
{
  /* The HURD dynamic linker is part of the GNU C library, so many
     GNU/Linux distributions use it.  (All ELF versions, as far as I
     know.)  An unresolved PLT entry points to "_dl_runtime_resolve",
     which calls "fixup" to patch the PLT, and then passes control to
     the function.

     We look for the symbol `_dl_runtime_resolve', and find `fixup' in
     the same objfile.  If we are at the entry point of `fixup', then
     we set a breakpoint at the return address (at the top of the
     stack), and continue.
  
     It's kind of gross to do all these checks every time we're
     called, since they don't change once the executable has gotten
     started.  But this is only a temporary hack --- upcoming versions
     of Linux will provide a portable, efficient interface for
     debugging programs that use shared libraries.  */

  struct objfile *objfile;
  struct minimal_symbol *resolver 
    = find_minsym_and_objfile ("_dl_runtime_resolve", &objfile);

  if (resolver)
    {
      struct minimal_symbol *fixup
	= lookup_minimal_symbol ("fixup", 0, objfile);

      if (fixup && SYMBOL_VALUE_ADDRESS (fixup) == pc)
	return (SAVED_PC_AFTER_CALL (get_current_frame ()));
    }

  return 0;
}      

/* See the comments for SKIP_SOLIB_RESOLVER at the top of infrun.c.
   This function:
   1) decides whether a PLT has sent us into the linker to resolve
      a function reference, and 
   2) if so, tells us where to set a temporary breakpoint that will
      trigger when the dynamic linker is done.  */

CORE_ADDR
i386_linux_skip_solib_resolver (CORE_ADDR pc)
{
  CORE_ADDR result;

  /* Plug in functions for other kinds of resolvers here.  */
  result = skip_hurd_resolver (pc);
  if (result)
    return result;

  return 0;
@


1.15
log
@* i386-linux-nat.c [! HAVE_PTRACE_GETFPXREGS] (fetch_fpxregs,
store_fpxregs): Return 0.
@
text
@d44 3
d364 1
a580 1
      dummy_sse_values ();
@


1.14
log
@Adapt support for SSE registers in Linux/x86 for Linux 2.4.
* i386-linux-nat.c: Various doc fixes.  Include "i387-nat.h".
(GETFPXREGS_SUPPLIES): Renamed from GETXFPREGS_SUPPLIES.
(have_ptrace_getfpxregs): Renamed from have_ptrace_getxfpregs.
(convert_to_gregset): Removed.  Moved logic to ...
(fill_gregset): ... here.  Simplified function.
(fetch_regs): Use perror_with_name for error reporting.
(store_regs): Add `regno' parameter.  Use perror_with_name for
error reporting.  Call fill_gregset instead of convert_to_gregset.
(FPREG_ADDR): Remove.
(supply_fpregset): Implement by calling i387_supply_fsave.
(convert_to_fpregset): Remove.
(fill_fpregset): Implement by calling i387_fill_fsave.
(fetch_fpregs): Use perror_with_name fro error reporting.
(store_fpregs) Add `regno' parameter.  Use perror_with_name fro
error reporting.  Call fill_fpregset instead of
convert_to_fpregset.
(supply_xfpregset, convert_to_xfpregset): Removed.
(supply_fpxregset, fill_fpxregset): New functions.
(fetch_fpxregs): Renamed from fetch_xfpregs.  Use perror_with_name
for error reporting.  Call supply_fpxregset instead of
supply_xfpregset.
(store_xfpregs): Removed.
(store_fpxregs): New function.
(fetch_inferior_registers): Adjust for xfp -> fpx change.  Tweak
message in call to internal_error.
(store_inferior_registers): Adjust for xfp ->fpx change.  Pass
REGNO to store_regs, store_fpregs and store_fpxregs.
(fetch_core_registers): Adjust for xfp -> fpx change.
* acconfig.h (HAVE_PTRACE_GETFPXREGS): Renamed from
HAVE_PTRACE_GETXFPREGS.
* config.in: Regenerated.
* configure.in: Replace check for PTRACE_GETXFPREGS with check for
PTRACE_GETFPXREGS.  Remove comment about Cygnus SSE extensions.
* configure: Regenerated.
* config/i386/linux.mh (NATDEPFILES): Add i387-nat.o.
* config/i386/tm-linux.h: Base definition of HAVE_SSE_REGS on
HAVE_PTRACE_GETFPXREGS instead of HAVE_PTRACE_GETXFPREGS.
@
text
@d508 2
a509 2
static int fetch_fpxregs (int tid) {}
static int store_fpxregs (int tid, int regno) {}
@


1.13
log
@Protoization.
@
text
@d1 2
a2 2
/* Native-dependent code for Linux running on i386's, for GDB.
   Copyright (C) 1999, 2000 Free Software Foundation, Inc.
d38 1
a38 1
/* Prototypes for supply_gregset etc. */
d41 3
d55 1
a55 1

d85 1
a85 1
#define GETXFPREGS_SUPPLIES(regno) \
d97 1
a97 1
/* Does the current host support the GETXFPREGS request?  The header
a100 7
   PTRACE_GETXFPREGS is a Cygnus invention, since we wrote our own
   Linux kernel patch for SSE support.  That patch may or may not
   actually make it into the official distribution.  If you find that
   years have gone by since this stuff was added, and Linux isn't
   using PTRACE_GETXFPREGS, that means that our patch didn't make it,
   and you can delete this, and the related code.

d105 2
a106 2
int have_ptrace_getxfpregs =
#ifdef HAVE_PTRACE_GETXFPREGS
d112 1
a113 1

d268 1
a269 1

d280 1
a280 1
  int regi;
d282 2
a283 18
  for (regi = 0; regi < NUM_GREGS; regi++)
    supply_register (regi, (char *) (regp + regmap[regi]));
}

/* Convert the valid general-purpose register values in GDB's register
   array to `struct user' format and store them in *GREGSETP.  The
   array VALID indicates which register values are valid.  If VALID is
   NULL, all registers are assumed to be valid.  */

static void
convert_to_gregset (elf_gregset_t *gregsetp, signed char *valid)
{
  elf_greg_t *regp = (elf_greg_t *) gregsetp;
  int regi;

  for (regi = 0; regi < NUM_GREGS; regi++)
    if (! valid || valid[regi])
      *(regp + regmap[regi]) = * (int *) &registers[REGISTER_BYTE (regi)];
d289 1
d293 2
a294 5
  if (regno == -1)
    {
      convert_to_gregset (gregsetp, NULL);
      return;
    }
d296 3
a298 9
  if (GETREGS_SUPPLIES (regno))
    {
      signed char valid[NUM_GREGS];

      memset (valid, 0, sizeof (valid));
      valid[regno] = 1;

      convert_to_gregset (gregsetp, valid);
    }
a309 1
  int ret;
d311 1
a311 2
  ret = ptrace (PTRACE_GETREGS, tid, 0, (int) &regs);
  if (ret < 0)
d321 1
a321 2
      warning ("Couldn't get registers.");
      return;
d331 1
a331 1
store_regs (int tid)
a333 1
  int ret;
d335 2
a336 6
  ret = ptrace (PTRACE_GETREGS, tid, 0, (int) &regs);
  if (ret < 0)
    {
      warning ("Couldn't get registers.");
      return;
    }
d338 4
a341 8
  convert_to_gregset (&regs, register_valid);

  ret = ptrace (PTRACE_SETREGS, tid, 0, (int) &regs);
  if (ret < 0)
    {
      warning ("Couldn't write registers.");
      return;
    }
d347 1
a347 1
static void store_regs (int tid) {}
d350 1
a351 1

a353 3
/* What is the address of st(N) within the floating-point register set F?  */
#define FPREG_ADDR(f, n) ((char *) &(f)->st_space + (n) * 10)

d360 1
a360 80
  int reg;
  long l;

  /* Supply the floating-point registers.  */
  for (reg = 0; reg < 8; reg++)
    supply_register (FP0_REGNUM + reg, FPREG_ADDR (fpregsetp, reg));

  /* We have to mask off the reserved bits in *FPREGSETP before
     storing the values in GDB's register file.  */
#define supply(REGNO, MEMBER)                                           \
  l = fpregsetp->MEMBER & 0xffff;                                       \
  supply_register (REGNO, (char *) &l)

  supply (FCTRL_REGNUM, cwd);
  supply (FSTAT_REGNUM, swd);
  supply (FTAG_REGNUM, twd);
  supply_register (FCOFF_REGNUM, (char *) &fpregsetp->fip);
  supply (FDS_REGNUM, fos);
  supply_register (FDOFF_REGNUM, (char *) &fpregsetp->foo);

#undef supply

  /* Extract the code segment and opcode from the  "fcs" member.  */
  l = fpregsetp->fcs & 0xffff;
  supply_register (FCS_REGNUM, (char *) &l);

  l = (fpregsetp->fcs >> 16) & ((1 << 11) - 1);
  supply_register (FOP_REGNUM, (char *) &l);
}

/* Convert the valid floating-point register values in GDB's register
   array to `struct user' format and store them in *FPREGSETP.  The
   array VALID indicates which register values are valid.  If VALID is
   NULL, all registers are assumed to be valid.  */

static void
convert_to_fpregset (elf_fpregset_t *fpregsetp, signed char *valid)
{
  int reg;

  /* Fill in the floating-point registers.  */
  for (reg = 0; reg < 8; reg++)
    if (!valid || valid[reg])
      memcpy (FPREG_ADDR (fpregsetp, reg),
	      &registers[REGISTER_BYTE (FP0_REGNUM + reg)],
	      REGISTER_RAW_SIZE(FP0_REGNUM + reg));

  /* We're not supposed to touch the reserved bits in *FPREGSETP.  */

#define fill(MEMBER, REGNO)						\
  if (! valid || valid[(REGNO)])					\
    fpregsetp->MEMBER                                                   \
      = ((fpregsetp->MEMBER & ~0xffff)                                  \
         | (* (int *) &registers[REGISTER_BYTE (REGNO)] & 0xffff))

#define fill_register(MEMBER, REGNO)                                    \
  if (! valid || valid[(REGNO)])                                        \
    memcpy (&fpregsetp->MEMBER, &registers[REGISTER_BYTE (REGNO)],      \
            sizeof (fpregsetp->MEMBER))

  fill (cwd, FCTRL_REGNUM);
  fill (swd, FSTAT_REGNUM);
  fill (twd, FTAG_REGNUM);
  fill_register (fip, FCOFF_REGNUM);
  fill (foo, FDOFF_REGNUM);
  fill_register (fos, FDS_REGNUM);

#undef fill
#undef fill_register

  if (! valid || valid[FCS_REGNUM])
    fpregsetp->fcs
      = ((fpregsetp->fcs & ~0xffff)
	 | (* (int *) &registers[REGISTER_BYTE (FCS_REGNUM)] & 0xffff));

  if (! valid || valid[FOP_REGNUM])
    fpregsetp->fcs
      = ((fpregsetp->fcs & 0xffff)
	 | ((*(int *) &registers[REGISTER_BYTE (FOP_REGNUM)] & ((1 << 11) - 1))
	    << 16));
d370 1
a370 15
  if (regno == -1)
    {
      convert_to_fpregset (fpregsetp, NULL);
      return;
    }

  if (GETFPREGS_SUPPLIES(regno))
    {
      signed char valid[MAX_NUM_REGS];
      
      memset (valid, 0, sizeof (valid));
      valid[regno] = 1;
	      
      convert_to_fpregset (fpregsetp, valid);
    }
a381 1
  int ret;
d383 2
a384 6
  ret = ptrace (PTRACE_GETFPREGS, tid, 0, (int) &fpregs);
  if (ret < 0)
    {
      warning ("Couldn't get floating point status.");
      return;
    }
d393 1
a393 1
store_fpregs (int tid)
a395 1
  int ret;
d397 2
a398 6
  ret = ptrace (PTRACE_GETFPREGS, tid, 0, (int) &fpregs);
  if (ret < 0)
    {
      warning ("Couldn't get floating point status.");
      return;
    }
d400 1
a400 1
  convert_to_fpregset (&fpregs, register_valid);
d402 2
a403 6
  ret = ptrace (PTRACE_SETFPREGS, tid, 0, (int) &fpregs);
  if (ret < 0)
    {
      warning ("Couldn't write floating point status.");
      return;
    }
d409 1
a409 1
static void store_fpregs (int tid) {}
d412 1
a413 1

d416 1
a416 8
/* PTRACE_GETXFPREGS is a Cygnus invention, since we wrote our own
   Linux kernel patch for SSE support.  That patch may or may not
   actually make it into the official distribution.  If you find that
   years have gone by since this code was added, and Linux isn't using
   PTRACE_GETXFPREGS, that means that our patch didn't make it, and
   you can delete this code.  */

#ifdef HAVE_PTRACE_GETXFPREGS
d419 1
a419 1
   values in *XFPREGS.  */
d422 1
a422 1
supply_xfpregset (struct user_xfpregs_struct *xfpregs)
d424 1
a424 30
  int reg;

  /* Supply the floating-point registers.  */
  for (reg = 0; reg < 8; reg++)
    supply_register (FP0_REGNUM + reg, (char *) &xfpregs->st_space[reg]);

  {
    supply_register (FCTRL_REGNUM, (char *) &xfpregs->cwd);
    supply_register (FSTAT_REGNUM, (char *) &xfpregs->swd);
    supply_register (FTAG_REGNUM,  (char *) &xfpregs->twd);
    supply_register (FCOFF_REGNUM, (char *) &xfpregs->fip);
    supply_register (FDS_REGNUM,   (char *) &xfpregs->fos);
    supply_register (FDOFF_REGNUM, (char *) &xfpregs->foo);
  
    /* Extract the code segment and opcode from the  "fcs" member.  */
    {
      long l;
      
      l = xfpregs->fcs & 0xffff;
      supply_register (FCS_REGNUM, (char *) &l);

      l = (xfpregs->fcs >> 16) & ((1 << 11) - 1);
      supply_register (FOP_REGNUM, (char *) &l);
    }
  }

  /* Supply the SSE registers.  */
  for (reg = 0; reg < 8; reg++)
    supply_register (XMM0_REGNUM + reg, (char *) &xfpregs->xmm_space[reg]);
  supply_register (MXCSR_REGNUM, (char *) &xfpregs->mxcsr);
d427 3
a429 4
/* Convert the valid floating-point and SSE registers in GDB's
   register array to `struct user' format and store them in *XFPREGS.
   The array VALID indicates which registers are valid.  If VALID is
   NULL, all registers are assumed to be valid.  */
d432 1
a432 2
convert_to_xfpregset (struct user_xfpregs_struct *xfpregs,
		      signed char *valid)
d434 1
a434 40
  int reg;

  /* Fill in the floating-point registers.  */
  for (reg = 0; reg < 8; reg++)
    if (!valid || valid[reg])
      memcpy (&xfpregs->st_space[reg],
	      &registers[REGISTER_BYTE (FP0_REGNUM + reg)],
	      REGISTER_RAW_SIZE(FP0_REGNUM + reg));

#define fill(MEMBER, REGNO)						\
  if (! valid || valid[(REGNO)])					\
    memcpy (&xfpregs->MEMBER, &registers[REGISTER_BYTE (REGNO)],	\
	    sizeof (xfpregs->MEMBER))

  fill (cwd, FCTRL_REGNUM);
  fill (swd, FSTAT_REGNUM);
  fill (twd, FTAG_REGNUM);
  fill (fip, FCOFF_REGNUM);
  fill (foo, FDOFF_REGNUM);
  fill (fos, FDS_REGNUM);

#undef fill

  if (! valid || valid[FCS_REGNUM])
    xfpregs->fcs
      = ((xfpregs->fcs & ~0xffff)
	 | (* (int *) &registers[REGISTER_BYTE (FCS_REGNUM)] & 0xffff));

  if (! valid || valid[FOP_REGNUM])
    xfpregs->fcs
      = ((xfpregs->fcs & 0xffff)
	 | ((*(int *) &registers[REGISTER_BYTE (FOP_REGNUM)] & ((1 << 11) - 1))
	    << 16));

  /* Fill in the XMM registers.  */
  for (reg = 0; reg < 8; reg++)
    if (! valid || valid[reg])
      memcpy (&xfpregs->xmm_space[reg],
	      &registers[REGISTER_BYTE (XMM0_REGNUM + reg)],
	      REGISTER_RAW_SIZE (XMM0_REGNUM + reg));
d437 1
a437 1
/* Fetch all registers covered by the PTRACE_SETXFPREGS request from
d442 1
a442 1
fetch_xfpregs (int tid)
d444 1
a444 2
  struct user_xfpregs_struct xfpregs;
  int ret;
d446 1
a446 1
  if (! have_ptrace_getxfpregs) 
d449 1
a449 2
  ret = ptrace (PTRACE_GETXFPREGS, tid, 0, &xfpregs);
  if (ret == -1)
d453 1
a453 1
	  have_ptrace_getxfpregs = 0;
d457 1
a457 2
      warning ("Couldn't read floating-point and SSE registers.");
      return 0;
d460 1
a460 1
  supply_xfpregset (&xfpregs);
d465 1
a465 1
   PTRACE_SETXFPREGS request into the process/thread specified by TID.
d469 1
a469 1
store_xfpregs (int tid)
d471 1
a471 2
  struct user_xfpregs_struct xfpregs;
  int ret;
d473 1
a473 1
  if (! have_ptrace_getxfpregs)
d475 3
d479 1
a479 14
  ret = ptrace (PTRACE_GETXFPREGS, tid, 0, &xfpregs);
  if (ret == -1)
    {
      if (errno == EIO)
	{
	  have_ptrace_getxfpregs = 0;
	  return 0;
	}

      warning ("Couldn't read floating-point and SSE registers.");
      return 0;
    }

  convert_to_xfpregset (&xfpregs, register_valid);
d481 2
a482 5
  if (ptrace (PTRACE_SETXFPREGS, tid, 0, &xfpregs) < 0)
    {
      warning ("Couldn't write floating-point and SSE registers.");
      return 0;
    }
d508 2
a509 4
/* Stub versions of the above routines, for systems that don't have
   PTRACE_GETXFPREGS.  */
static int store_xfpregs (int tid) { return 0; }
static int fetch_xfpregs (int tid) { return 0; }
d512 2
a513 1
#endif
a514 1

d538 1
a538 1
  /* Use the PTRACE_GETXFPREGS request whenever possible, since it
d540 1
a540 1
     results.  But remember that fetch_xfpregs can fail, and return
d553 1
a553 1
      if (fetch_xfpregs (tid))
d565 1
a565 1
  if (GETXFPREGS_SUPPLIES (regno))
d567 1
a567 1
      if (fetch_xfpregs (tid))
d581 1
a581 2
  internal_error ("i386-linux-nat.c (fetch_inferior_registers): "
		  "got request for bad register number %d", regno);
d604 1
a604 1
  /* Use the PTRACE_SETXFPREGS requests whenever possibl, since it
d606 1
a606 1
     store_xfpregs can fail, and return zero.  */
d609 2
a610 2
      store_regs (tid);
      if (store_xfpregs (tid))
d612 1
a612 1
      store_fpregs (tid);
d618 1
a618 1
      store_regs (tid);
d622 1
a622 1
  if (GETXFPREGS_SUPPLIES (regno))
d624 1
a624 1
      if (store_xfpregs (tid))
d630 1
a630 1
      store_fpregs (tid);
d636 1
a637 1

d645 1
a645 1
   supply_xfpregset, which most platforms don't have.)
d654 1
a654 2
     3 --- the extended floating-point register set, in struct
           user_xfpregs_struct format
d687 1
a687 1
#ifdef HAVE_PTRACE_GETXFPREGS
d689 1
a689 1
	struct user_xfpregs_struct xfpregset;
d692 2
a693 2
	if (core_reg_size != sizeof (xfpregset))
	  warning ("Wrong size user_xfpregs_struct in core file.");
d696 2
a697 2
	    memcpy (&xfpregset, core_reg_sect, sizeof (xfpregset));
	    supply_xfpregset (&xfpregset);
d710 1
a711 1

d795 1
a796 1

a831 1

d887 1
a888 1

@


1.12
log
@2000-05-26  Michael Snyder  <msnyder@@seadog.cygnus.com>

        * gregset.h: New file.  Typedefs for gdb_gregset_t and
        gdb_fpregset_t, prototypes for supply_gregset and friends.
        * procfs.c: Include gregset.h.  Delete local prototypes for
        supply_gregset etc., and local typedef gdb_gregset_t etc.
        * sol-thread.c: Include gregset.h, delete local prototypes,
        add appropriate casts to gdb_gregset_t.
        * uw-thread.c, lin-thread.c, core-sol2.c, core-regset.c,
        sparc-tdep.c, ptx4-nat.c, ppc-linux-nat.c, mipsv4-nat.c,
        m88k-nat.c, m68klinux-nat.c, m68k-tdep.c, irix5-nat.c,
        irix4-nat.c, ia64-linux-nat.c, i386v4-nat.c, cxux-nat.c,
        arm-linux-nat.c, alpha-nat.c: Include gregset.h.
        * config/nm-linux.h: Define GDB_GREGSET_T, GDB_FPREGET_T.
        * config/sparc/tm-sun4sol2.h: Ditto.
@
text
@d149 1
a149 2
fetch_register (regno)
     int regno;
d194 1
a194 2
old_fetch_inferior_registers (regno)
     int regno;
d217 1
a217 2
store_register (regno)
     int regno;
d258 1
a258 2
old_store_inferior_registers (regno)
     int regno;
d1150 1
a1150 1
_initialize_i386_linux_nat ()
@


1.11
log
@* i386-linux-nat.c: Define PT_READ_U and PT_WRITE_U if they're not
already defined.
@
text
@d38 3
@


1.10
log
@2000-04-30  Mark Kettenis  <kettenis@@gnu.org>

	Fix single-stepping out of signal trampolines.
	* config/i386/nm-linux.h (CHILD_RESUME): Define.
	* i386-linux-nat.c (child_resume): New function.
@
text
@d126 7
@


1.9
log
@2000-04-02  Mark Kettenis  <kettenis@@gnu.org>

	* i386-linux-nat.c: Add copyright notice.
@
text
@d954 85
@


1.9.2.1
log
@* i386-linux-nat.c: Define PT_READ_U and PT_WRITE_U if they're not
already defined.
@
text
@a125 7
#ifndef PT_READ_U
#define PT_READ_U PTRACE_PEEKUSR
#endif
#ifndef PT_WRITE_U
#define PT_WRITE_U PTRACE_POKEUSR
#endif

@


1.8
log
@* i386-linux-nat.c: No need to #include "frame.h" any more.
(LINUX_SIGTRAMP_INSN0, LINUX_SIGTRAMP_OFFSET0,
LINUX_SIGTRAMP_INSN1, LINUX_SIGTRAMP_OFFSET1,
LINUX_SIGTRAMP_INSN2, LINUX_SIGTRAMP_OFFSET2, linux_sigtramp_code,
LINUX_SIGTRAMP_LEN, i386_linux_sigtramp_start,
LINUX_RT_SIGTRAMP_INSN0, LINUX_RT_SIGTRAMP_OFFSET0,
LINUX_RT_SIGTRAMP_INSN1, LINUX_RT_SIGTRAMP_OFFSET1,
linux_rt_sigtramp_code, LINUX_RT_SIGTRAMP_LEN,
i386_linux_rt_sigtramp_start, i386_linux_in_sigtramp,
i386_linux_sigcontext_addr, LINUX_SIGCONTEXT_PC_OFFSET,
i386_linux_sigtramp_saved_pc, LINUX_SIGCONTEXT_SP_OFFSET,
i386_linux_sigtramp_saved_sp):	Deleted.  Folks rightly pointed
out that these are target-dependent, and useful in non-native
configurations.  Moved to...
* i386-linux-tdep.c: ... Here, a new file.
* Makefile.in (ALLDEPFILES): Add i386-linux-tdep.c.
(i386-linux-tdep.o): New rule.
(i386-linux-nat.o): We no longer depend on frame.h.
* config/i386/linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d2 1
@


1.7
log
@* i386-linux-nat.c (i386_linux_saved_pc_after_call): Lost in the
merge; reinstated.
@
text
@a25 1
#include "frame.h"
a1042 257
}


/* Recognizing signal handler frames.  */

/* Linux has two flavors of signals.  Normal signal handlers, and
   "realtime" (RT) signals.  The RT signals can provide additional
   information to the signal handler if the SA_SIGINFO flag is set
   when establishing a signal handler using `sigaction'.  It is not
   unlikely that future versions of Linux will support SA_SIGINFO for
   normal signals too.  */

/* When the i386 Linux kernel calls a signal handler and the
   SA_RESTORER flag isn't set, the return address points to a bit of
   code on the stack.  This function returns whether the PC appears to
   be within this bit of code.

   The instruction sequence for normal signals is
       pop    %eax
       mov    $0x77,%eax
       int    $0x80
   or 0x58 0xb8 0x77 0x00 0x00 0x00 0xcd 0x80.

   Checking for the code sequence should be somewhat reliable, because
   the effect is to call the system call sigreturn.  This is unlikely
   to occur anywhere other than a signal trampoline.

   It kind of sucks that we have to read memory from the process in
   order to identify a signal trampoline, but there doesn't seem to be
   any other way.  The IN_SIGTRAMP macro in tm-linux.h arranges to
   only call us if no function name could be identified, which should
   be the case since the code is on the stack.

   Detection of signal trampolines for handlers that set the
   SA_RESTORER flag is in general not possible.  Unfortunately this is
   what the GNU C Library has been doing for quite some time now.
   However, as of version 2.1.2, the GNU C Library uses signal
   trampolines (named __restore and __restore_rt) that are identical
   to the ones used by the kernel.  Therefore, these trampolines are
   supported too.  */

#define LINUX_SIGTRAMP_INSN0 (0x58)	/* pop %eax */
#define LINUX_SIGTRAMP_OFFSET0 (0)
#define LINUX_SIGTRAMP_INSN1 (0xb8)	/* mov $NNNN,%eax */
#define LINUX_SIGTRAMP_OFFSET1 (1)
#define LINUX_SIGTRAMP_INSN2 (0xcd)	/* int */
#define LINUX_SIGTRAMP_OFFSET2 (6)

static const unsigned char linux_sigtramp_code[] =
{
  LINUX_SIGTRAMP_INSN0,					/* pop %eax */
  LINUX_SIGTRAMP_INSN1, 0x77, 0x00, 0x00, 0x00,		/* mov $0x77,%eax */
  LINUX_SIGTRAMP_INSN2, 0x80				/* int $0x80 */
};

#define LINUX_SIGTRAMP_LEN (sizeof linux_sigtramp_code)

/* If PC is in a sigtramp routine, return the address of the start of
   the routine.  Otherwise, return 0.  */

static CORE_ADDR
i386_linux_sigtramp_start (CORE_ADDR pc)
{
  unsigned char buf[LINUX_SIGTRAMP_LEN];

  /* We only recognize a signal trampoline if PC is at the start of
     one of the three instructions.  We optimize for finding the PC at
     the start, as will be the case when the trampoline is not the
     first frame on the stack.  We assume that in the case where the
     PC is not at the start of the instruction sequence, there will be
     a few trailing readable bytes on the stack.  */

  if (read_memory_nobpt (pc, (char *) buf, LINUX_SIGTRAMP_LEN) != 0)
    return 0;

  if (buf[0] != LINUX_SIGTRAMP_INSN0)
    {
      int adjust;

      switch (buf[0])
	{
	case LINUX_SIGTRAMP_INSN1:
	  adjust = LINUX_SIGTRAMP_OFFSET1;
	  break;
	case LINUX_SIGTRAMP_INSN2:
	  adjust = LINUX_SIGTRAMP_OFFSET2;
	  break;
	default:
	  return 0;
	}

      pc -= adjust;

      if (read_memory_nobpt (pc, (char *) buf, LINUX_SIGTRAMP_LEN) != 0)
	return 0;
    }

  if (memcmp (buf, linux_sigtramp_code, LINUX_SIGTRAMP_LEN) != 0)
    return 0;

  return pc;
}

/* This function does the same for RT signals.  Here the instruction
   sequence is
       mov    $0xad,%eax
       int    $0x80
   or 0xb8 0xad 0x00 0x00 0x00 0xcd 0x80.

   The effect is to call the system call rt_sigreturn.  */

#define LINUX_RT_SIGTRAMP_INSN0 (0xb8)	/* mov $NNNN,%eax */
#define LINUX_RT_SIGTRAMP_OFFSET0 (0)
#define LINUX_RT_SIGTRAMP_INSN1 (0xcd)	/* int */
#define LINUX_RT_SIGTRAMP_OFFSET1 (5)

static const unsigned char linux_rt_sigtramp_code[] =
{
  LINUX_RT_SIGTRAMP_INSN0, 0xad, 0x00, 0x00, 0x00,	/* mov $0xad,%eax */
  LINUX_RT_SIGTRAMP_INSN1, 0x80				/* int $0x80 */
};

#define LINUX_RT_SIGTRAMP_LEN (sizeof linux_rt_sigtramp_code)

/* If PC is in a RT sigtramp routine, return the address of the start
   of the routine.  Otherwise, return 0.  */

static CORE_ADDR
i386_linux_rt_sigtramp_start (CORE_ADDR pc)
{
  unsigned char buf[LINUX_RT_SIGTRAMP_LEN];

  /* We only recognize a signal trampoline if PC is at the start of
     one of the two instructions.  We optimize for finding the PC at
     the start, as will be the case when the trampoline is not the
     first frame on the stack.  We assume that in the case where the
     PC is not at the start of the instruction sequence, there will be
     a few trailing readable bytes on the stack.  */

  if (read_memory_nobpt (pc, (char *) buf, LINUX_RT_SIGTRAMP_LEN) != 0)
    return 0;

  if (buf[0] != LINUX_RT_SIGTRAMP_INSN0)
    {
      if (buf[0] != LINUX_RT_SIGTRAMP_INSN1)
	return 0;

      pc -= LINUX_RT_SIGTRAMP_OFFSET1;

      if (read_memory_nobpt (pc, (char *) buf, LINUX_RT_SIGTRAMP_LEN) != 0)
	return 0;
    }

  if (memcmp (buf, linux_rt_sigtramp_code, LINUX_RT_SIGTRAMP_LEN) != 0)
    return 0;

  return pc;
}

/* Return whether PC is in a Linux sigtramp routine.  */

int
i386_linux_in_sigtramp (CORE_ADDR pc, char *name)
{
  if (name)
    return STREQ ("__restore", name) || STREQ ("__restore_rt", name);
  
  return (i386_linux_sigtramp_start (pc) != 0
	  || i386_linux_rt_sigtramp_start (pc) != 0);
}

/* Assuming FRAME is for a Linux sigtramp routine, return the address
   of the associated sigcontext structure.  */

CORE_ADDR
i386_linux_sigcontext_addr (struct frame_info *frame)
{
  CORE_ADDR pc;

  pc = i386_linux_sigtramp_start (frame->pc);
  if (pc)
    {
      CORE_ADDR sp;

      if (frame->next)
	/* If this isn't the top frame, the next frame must be for the
	   signal handler itself.  The sigcontext structure lives on
	   the stack, right after the signum argument.  */
	return frame->next->frame + 12;

      /* This is the top frame.  We'll have to find the address of the
	 sigcontext structure by looking at the stack pointer.  Keep
	 in mind that the first instruction of the sigtramp code is
	 "pop %eax".  If the PC is at this instruction, adjust the
	 returned value accordingly.  */
      sp = read_register (SP_REGNUM);
      if (pc == frame->pc)
	return sp + 4;
      return sp;
    }

  pc = i386_linux_rt_sigtramp_start (frame->pc);
  if (pc)
    {
      if (frame->next)
	/* If this isn't the top frame, the next frame must be for the
	   signal handler itself.  The sigcontext structure is part of
	   the user context.  A pointer to the user context is passed
	   as the third argument to the signal handler.  */
	return read_memory_integer (frame->next->frame + 16, 4) + 20;

      /* This is the top frame.  Again, use the stack pointer to find
	 the address of the sigcontext structure.  */
      return read_memory_integer (read_register (SP_REGNUM) + 8, 4) + 20;
    }

  error ("Couldn't recognize signal trampoline.");
  return 0;
}

/* Offset to saved PC in sigcontext, from <asm/sigcontext.h>.  */
#define LINUX_SIGCONTEXT_PC_OFFSET (56)

/* Assuming FRAME is for a Linux sigtramp routine, return the saved
   program counter.  */

CORE_ADDR
i386_linux_sigtramp_saved_pc (struct frame_info *frame)
{
  CORE_ADDR addr;
  addr = i386_linux_sigcontext_addr (frame);
  return read_memory_integer (addr + LINUX_SIGCONTEXT_PC_OFFSET, 4);
}

/* Offset to saved SP in sigcontext, from <asm/sigcontext.h>.  */
#define LINUX_SIGCONTEXT_SP_OFFSET (28)

/* Assuming FRAME is for a Linux sigtramp routine, return the saved
   stack pointer.  */

CORE_ADDR
i386_linux_sigtramp_saved_sp (struct frame_info *frame)
{
  CORE_ADDR addr;
  addr = i386_linux_sigcontext_addr (frame);
  return read_memory_integer (addr + LINUX_SIGCONTEXT_SP_OFFSET, 4);
}

/* Immediately after a function call, return the saved pc.  */

CORE_ADDR
i386_linux_saved_pc_after_call (struct frame_info *frame)
{
  if (frame->signal_handler_caller)
    return i386_linux_sigtramp_saved_pc (frame);

  return read_memory_integer (read_register (SP_REGNUM), 4);
@


1.6
log
@Doc fix.
@
text
@d1292 11
@


1.5
log
@* i386-tdep.c (LINUX_SIGTRAMP_INSN0, LINUX_SIGTRAMP_OFFSET0,
LINUX_SIGTRAMP_INSN1, LINUX_SIGTRAMP_OFFSET1,
LINUX_SIGTRAMP_INSN2, LINUX_SIGTRAMP_OFFSET2, linux_sigtramp_code,
LINUX_SIGTRAMP_LEN, i386_linux_sigtramp_start,
LINUX_RT_SIGTRAMP_INSN0, LINUX_RT_SIGTRAMP_OFFSET0,
LINUX_RT_SIGTRAMP_INSN1, LINUX_RT_SIGTRAMP_OFFSET1,
linux_rt_sigtramp_code, LINUX_RT_SIGTRAMP_LEN,
i386_linux_rt_sigtramp_start, i386_linux_in_sigtramp,
i386_linux_sigcontext_addr, LINUX_SIGCONTEXT_PC_OFFSET,
i386_linux_sigtramp_saved_pc, LINUX_SIGCONTEXT_SP_OFFSET,
i386_linux_sigtramp_saved_sp): Deleted.  These all implement
Linux-specific signal trampoline detection, and should be moved to...
* i386-linux-nat.c: ... here.
* config/i386/tm-linux.h (I386_LINUX_SIGTRAMP): No need to define
this any more, since we're not enabling OS-specific code in a
OS-independent file.
@
text
@d115 2
@


1.4
log
@2000-03-06  Mark Kettenis  <kettenis@@gnu.org>

	* i386-linux-nat.c (supply_fpregset): Mask off the reserved bits
	in *FPREGSETP.
	(convert_to_fpregset): Don't touch the reserved bits in *FPREGSETP.
@
text
@d1045 246
@


1.3
log
@2000-03-05  Mark Kettenis  <kettenis@@gnu.org>

	Allow GDB to run on Linux 2.0 again.
	* config.in: Add HAVE_PTRACE_GETREGS.
	* configure.in: Check if <sys/ptrace.h> defines PTRACE_GETREGS.
	* configure: Regenerated.
	* config/i386/nm-linux.h (CANNOT_FETCH_REGISTER,
	CANNOT_STORE_REGISTER): New defines.
	* i386-linux-nat.c (have_ptrace_getregs): New variable.
	(PTRACE_XFER_TYPE, CANNOT_FETCH_REGISTER, fetch_register,
	old_fetch_inferior_registers, CANNOT_STORE_REGISTER,
	store_register, old_store_inferior_registers): Copied over from
	`inptrace.c' as a temporary measure.
	(fetch_regs, store_regs, fetch_fpregs, store_fpregs):
	Conditionalize on HAVE_PTRACE_GETREGS.  Define stubs if
	HAVE_PTRACE_GETREGS isn't defined.
	(fetch_regs): Reset `have_ptrace_getregs' if ptrace call fails
	with EIO.
	(fetch_inferior_registers, store_inferior_registers): Fall back on
	the method use in `infptrace.c' (by calling
	old_fetch_inferior_registers and old_store_inferior_registers) if
	`have_ptrace_getregs' isn't set.
@
text
@d396 1
d402 9
a410 3
  supply_register (FCTRL_REGNUM, (char *) &fpregsetp->cwd);
  supply_register (FSTAT_REGNUM, (char *) &fpregsetp->swd);
  supply_register (FTAG_REGNUM,  (char *) &fpregsetp->twd);
d412 1
a412 1
  supply_register (FDS_REGNUM,   (char *) &fpregsetp->fos);
d414 3
a416 1
  
d418 2
a419 2
  {
    long l;
d421 2
a422 6
    l = fpregsetp->fcs & 0xffff;
    supply_register (FCS_REGNUM, (char *) &l);

    l = (fpregsetp->fcs >> 16) & ((1 << 11) - 1);
    supply_register (FOP_REGNUM, (char *) &l);
  }
d442 2
d446 8
a453 2
    memcpy (&fpregsetp->MEMBER, &registers[REGISTER_BYTE (REGNO)],	\
	    sizeof (fpregsetp->MEMBER))
d458 1
a458 1
  fill (fip, FCOFF_REGNUM);
d460 1
a460 1
  fill (fos, FDS_REGNUM);
d463 1
@


1.2
log
@2000-01-29  Mark Kettenis  <kettenis@@gnu.org>

	* i386-linux-nat.c: Use elf_gregset_t and elf_fpregset_t instead
	of gregset_t and fpregset_t.  Those are the only names that are
	guaranteed to specify the right types for all supported Linux
	systems out there.
	Various doc fixes and gratitious local variable renames, all in an
	attempt to stress similarities between the code and unify the
	terminology used.  Use ISO-C all over.
	(regmap): Remove trailing comma.
	(FPREG_ADDR): Renamed from FPREGSET_T_FPREG_ADDR.
	(convert_to_gregset): Make static.  Remove GDB_REGS argument.  It
	is unnecessary and wasn't used anyway.  All callers changed.
	(convert_to_fpregset, convert_to_xfpregset): Likewise.
	(fetch_regs, store_regs): Remove unused variable `regno'.
	(fill_fpregs): If REGNO is not -1, only update the specified
	register.
	(fetch_core_registers): Renamed from
	i386_linux_fetch_core_registers.  There is no need for a unique
	name since the function is static anyway.
	(linux_elf_core_fns): Renamed from i386_linux_nat_core_functions
	since it is more descriptive.
@
text
@d82 9
d115 151
d321 2
d335 8
d376 7
d487 2
d534 7
d750 8
d769 8
d816 8
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
This file is part of GDB.
d5 14
a18 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d24 1
a24 1
/* For i386_linux_skip_solib_resolver */
d38 24
a61 1
/* This is a duplicate of the table in i386-xdep.c. */
d63 2
d70 1
a70 1
  DS, ES, FS, GS,
d73 35
d109 2
a110 9
/*  FIXME:  These routine absolutely depends upon (NUM_REGS - NUM_FREGS)
    being less than or equal to the number of registers that can be stored
    in a gregset_t.  Note that with the current scheme there will typically
    be more registers actually stored in a gregset_t that what we know
    about.  This is bogus and should be fixed. */

/*  Given a pointer to a general register set in /proc format (gregset_t *),
    unpack the register contents and supply them as gdb's idea of the current
    register values. */
d113 1
a113 2
supply_gregset (gregsetp)
     gregset_t *gregsetp;
d115 6
a120 2
  register int regi;
  register greg_t *regp = (greg_t *) gregsetp;
d122 23
a144 1
  for (regi = 0 ; regi < (NUM_REGS - NUM_FREGS) ; regi++)
d146 2
a147 1
      supply_register (regi, (char *) (regp + regmap[regi]));
d149 29
d180 5
a184 4
void
fill_gregset (gregsetp, regno)
     gregset_t *gregsetp;
     int regno;
d186 11
a196 2
  int regi;
  register greg_t *regp = (greg_t *) gregsetp;
d198 2
a199 1
  for (regi = 0 ; regi < (NUM_REGS - NUM_FREGS) ; regi++)
d201 2
a202 4
      if ((regno == -1) || (regno == regi))
	{
	  *(regp + regmap[regi]) = *(int *) &registers[REGISTER_BYTE (regi)];
	}
d206 2
d209 5
a213 3
/*  Given a pointer to a floating point register set in (fpregset_t *)
    format, unpack the register contents and supply them as gdb's
    idea of the current floating point register values. */
d216 1
a216 2
supply_fpregset (fpregsetp)
     fpregset_t *fpregsetp;
d218 76
a293 4
  register int regi;
  char *from;
  from = (char *) &(fpregsetp->st_space[0]);
  for (regi = FPSTART_REGNUM ; regi <= FPEND_REGNUM ; regi++)
d295 12
a306 2
      supply_register(regi, from);
      from += REGISTER_RAW_SIZE(regi);
d310 2
a311 3
/*  Given a pointer to a floating point register set in (fpregset_t *)
    format, update all of the registers from gdb's idea
    of the current floating point register set. */
d313 2
a314 4
void
fill_fpregset (fpregsetp, regno)
     fpregset_t *fpregsetp;
     int regno;
d316 2
a317 3
  int regi;
  char *to;
  char *from;
d319 2
a320 2
  to = (char *) &(fpregsetp->st_space[0]);
  for (regi = FPSTART_REGNUM ; regi <= FPEND_REGNUM ; regi++)
d322 2
a323 3
      from = (char *) &registers[REGISTER_BYTE (regi)];
      memcpy (to, from, REGISTER_RAW_SIZE (regi));
      to += REGISTER_RAW_SIZE(regi);
d325 2
d329 3
a331 4
/*
  Get the whole floating point state of the process and
  store the floating point stack into registers[].
  */
d333 1
a333 1
fetch_fpregs(void)
d335 2
a336 2
  int ret, regno;
  char buf[FPREG_BYTES];
d338 2
a339 2
  ret = ptrace (PTRACE_GETFPREGS, inferior_pid,	0, (int)buf);
  if ( ret < 0 )
d341 1
a341 1
      warning ("Couldn't get floating point status");
d345 4
a348 1
  for ( regno = 0; regno < NUM_FREGS; regno++ )
d350 46
a395 5
      if ( regno < 7 )
	supply_register (NUM_REGS-NUM_FREGS+regno, buf + regno*4);
      else
	supply_register (NUM_REGS-NUM_FREGS+regno,
			 buf + FPENV_BYTES + (regno-7)*FPREG_RAW_SIZE);
d397 1
d399 4
d405 4
a409 4
/*
  Get the whole floating point state of the process and
  replace the contents from registers[].
  */
d411 2
a412 1
store_fpregs(void)
d414 51
a464 2
  int ret, regno;
  char buf[FPREG_BYTES];
d466 5
a470 2
  ret = ptrace (PTRACE_GETFPREGS, inferior_pid,	0, (int)buf);
  if ( ret < 0 )
d472 8
a479 2
      warning ("Couldn't get floating point status");
      return;
d482 19
a500 1
  for ( regno = 0; regno < NUM_FREGS; regno++ )
d502 1
a502 1
      if ( register_valid[regno] )
d504 2
a505 10
	  if ( regno < 7 )
	    {
	      read_register_gen (NUM_REGS-NUM_FREGS+regno,
				 buf + regno*4);
	    }
	  else
	    {
	      read_register_gen (NUM_REGS-NUM_FREGS+regno,
				 buf + FPENV_BYTES + (regno-7)*FPREG_RAW_SIZE);
	    }
d507 3
d512 3
a514 2
  ret = ptrace (PTRACE_SETFPREGS, inferior_pid, 0, (int)buf);
  if ( ret < 0 )
d516 2
a517 2
      warning ("Couldn't write floating point status");
      return;
d520 1
d523 4
a527 4
/*
  Get state of all non-fp registers of the process and
  store into registers[].
  */
d529 32
a560 1
fetch_regs(void)
d562 1
a562 2
  int ret, regno;
  char buf[17*sizeof(unsigned int)];
d564 18
a581 2
  ret = ptrace (PTRACE_GETREGS, inferior_pid, 0, (int)buf);
  if ( ret < 0 )
d583 1
a583 1
      warning ("Couldn't get registers");
d587 4
a590 2
  for ( regno = 0; regno < NUM_REGS-NUM_FREGS; regno++ )
    supply_register (regno, buf + register_addr (regno, U_REGS_OFFSET));
d592 13
d607 5
a611 7

/*
  Get the whole non-floating-point register state of the process and
  replace them in the process from registers[].
  */
static void
store_regs(void)
d613 1
a613 2
  int ret, regno;
  char buf[17*sizeof(unsigned int)];
d615 13
a627 4
  ret = ptrace (PTRACE_GETREGS, inferior_pid, 0, (int)buf);
  if ( ret < 0 )
    {
      warning ("Couldn't get registers");
d631 1
a631 1
  for ( regno = 0; regno < NUM_REGS-NUM_FREGS; regno++ )
d633 2
a634 2
      if ( register_valid[regno] )
	read_register_gen (regno, buf + register_addr (regno, U_REGS_OFFSET));
d637 4
a640 1
  ret = ptrace (PTRACE_SETREGS, inferior_pid, 0, (int)buf);
d642 4
a645 3
  if ( ret < 0 )
    {
      warning ("Couldn't write floating point status");
d649 1
d652 2
d655 1
a655 4
/* Fetch registers from the child process.
   Fetch all if regno == -1, otherwise fetch all ordinary
   registers or all floating point registers depending
   upon the value of regno. */
d657 4
a660 6
void
fetch_inferior_registers (regno)
     int regno;
{
  if ( (regno < NUM_REGS - NUM_FREGS) || (regno == -1) )
    fetch_regs();
d662 3
a664 3
  if ( (regno >= NUM_REGS - NUM_FREGS) || (regno == -1) )
    fetch_fpregs();
}
d666 5
d672 1
a672 5
/* Store our register values back into the inferior.
   If REGNO is -1, do this for all registers.
   Otherwise, REGNO specifies which register, which
   then determines whether we store all ordinary
   registers or all of the floating point registers. */
d674 3
a676 3
void
store_inferior_registers (regno)
     int regno;
d678 14
a691 2
  if ( (regno < NUM_REGS - NUM_FREGS) || (regno == -1) )
    store_regs();
d693 32
a724 2
  if ( (regno >= NUM_REGS - NUM_FREGS) || (regno == -1) )
    store_fpregs();
d727 6
a799 1

d818 18
@


1.1.1.1
log
@import gdb-1999-09-08 snapshot
@
text
@@


1.1.1.2
log
@import gdb-1999-10-18 snapshot
@
text
@d48 10
a57 3
/* Given a pointer to a general register set in struct user format
   (gregset_t *), unpack the register contents and supply them as
   gdb's idea of the current register values. */
d65 1
a65 1
  for (regi = 0; regi < NUM_GREGS; regi++)
a70 8
/* Fill in a gregset_t object with selected data from a gdb-format
   register file.
   - GREGSETP points to the gregset_t object to be filled.
   - GDB_REGS points to the GDB-style register file providing the data.
   - VALID is an array indicating which registers in GDB_REGS are
     valid; the parts of *GREGSETP that would hold registers marked
     invalid in GDB_REGS are left unchanged.  If VALID is zero, all
     registers are assumed to be valid.  */
d72 3
a74 3
convert_to_gregset (gregset_t *gregsetp,
		    char *gdb_regs,
		    signed char *valid)
d79 6
a84 17
  for (regi = 0; regi < NUM_GREGS; regi++)
    if (! valid || valid[regi])
      *(regp + regmap[regi]) = * (int *) &registers[REGISTER_BYTE (regi)];
}

void
fill_gregset (gregset_t *gregsetp,
	      int regno)
{
  if (regno == -1)
    convert_to_gregset (gregsetp, registers, 0);
  else
    {
      signed char valid[NUM_GREGS];
      memset (valid, 0, sizeof (valid));
      valid[regno] = 1;
      convert_to_gregset (gregsetp, valid, valid);
d89 3
a91 3
/* Where does st(N) start in the fpregset_t structure F?  */
#define FPREGSET_T_FPREG_OFFSET(f, n) \
  ((char *) &(f)->st_space + (n) * 10)
a92 2
/* Fill GDB's register file with the floating-point register values in
   *FPREGSETP.  */
d94 2
a95 1
supply_fpregset (fpregset_t *fpregsetp)
d97 8
a104 23
  int i;

  /* Supply the floating-point registers.  */
  for (i = 0; i < 8; i++)
    supply_register (FP0_REGNUM + i, FPREGSET_T_FPREG_OFFSET (fpregsetp, i));

  supply_register (FCTRL_REGNUM, (char *) &fpregsetp->cwd);
  supply_register (FSTAT_REGNUM, (char *) &fpregsetp->swd);
  supply_register (FTAG_REGNUM,  (char *) &fpregsetp->twd);
  supply_register (FCOFF_REGNUM, (char *) &fpregsetp->fip);
  supply_register (FDS_REGNUM,   (char *) &fpregsetp->fos);
  supply_register (FDOFF_REGNUM, (char *) &fpregsetp->foo);
  
  /* Extract the code segment and opcode from the  "fcs" member.  */
  {
    long l;

    l = fpregsetp->fcs & 0xffff;
    supply_register (FCS_REGNUM, (char *) &l);

    l = (fpregsetp->fcs >> 16) & ((1 << 11) - 1);
    supply_register (FOP_REGNUM, (char *) &l);
  }
d107 3
a110 8
/* Fill in an fpregset_t structure with selected data from a
   gdb-format register file.
   - FPREGSETP points to the structure to be filled. 
   - GDB_REGS points to the GDB-style register file providing the data.
   - VALID is an array indicating which registers in GDB_REGS are
     valid; the parts of *FPREGSETP that would hold registers marked
     invalid in GDB_REGS are left unchanged.  If VALID is zero, all
     registers are assumed to be valid.  */
d112 3
a114 3
convert_to_fpregset (fpregset_t *fpregsetp,
		     char *gdb_regs,
		     signed char *valid)
d116 3
a118 1
  int i;
d120 7
a126 31
  /* Fill in the floating-point registers.  */
  for (i = 0; i < 8; i++)
    if (!valid || valid[i])
      memcpy (FPREGSET_T_FPREG_OFFSET (fpregsetp, i),
	      &registers[REGISTER_BYTE (FP0_REGNUM + i)],
	      REGISTER_RAW_SIZE(FP0_REGNUM + i));

#define fill(MEMBER, REGNO)						\
  if (! valid || valid[(REGNO)])					\
    memcpy (&fpregsetp->MEMBER, &registers[REGISTER_BYTE (REGNO)],	\
	    sizeof (fpregsetp->MEMBER))

  fill (cwd, FCTRL_REGNUM);
  fill (swd, FSTAT_REGNUM);
  fill (twd, FTAG_REGNUM);
  fill (fip, FCOFF_REGNUM);
  fill (foo, FDOFF_REGNUM);
  fill (fos, FDS_REGNUM);

#undef fill

  if (! valid || valid[FCS_REGNUM])
    fpregsetp->fcs
      = ((fpregsetp->fcs & ~0xffff)
	 | (* (int *) &registers[REGISTER_BYTE (FCS_REGNUM)] & 0xffff));

  if (! valid || valid[FOP_REGNUM])
    fpregsetp->fcs
      = ((fpregsetp->fcs & 0xffff)
	 | ((*(int *) &registers[REGISTER_BYTE (FOP_REGNUM)] & ((1 << 11) - 1))
	    << 16));
d129 4
a132 15

/* Given a pointer to a floating point register set in (fpregset_t *)
   format, update all of the registers from gdb's idea of the current
   floating point register set.  */

void
fill_fpregset (fpregset_t *fpregsetp,
	       int regno)
{
  convert_to_fpregset (fpregsetp, registers, 0);
}


/* Get the whole floating point state of the process and store the
   floating point stack into registers[].  */
d134 1
a134 1
fetch_fpregs ()
d137 1
a137 1
  fpregset_t buf;
d139 2
a140 2
  ret = ptrace (PTRACE_GETFPREGS, inferior_pid,	0, (int) &buf);
  if (ret < 0)
d146 9
a154 3
  /* ptrace fills an fpregset_t, so we can use the same function we do
     for core files.  */
  supply_fpregset (&buf);
d158 4
a161 2
/* Set the inferior's floating-point registers to the values in
   registers[] --- but only those registers marked valid.  */
d163 1
a163 1
store_fpregs ()
d165 2
a166 2
  int ret;
  fpregset_t buf;
d168 2
a169 2
  ret = ptrace (PTRACE_GETFPREGS, inferior_pid,	0, (int) &buf);
  if (ret < 0)
d175 16
a190 1
  convert_to_fpregset (&buf, registers, register_valid);
d192 2
a193 2
  ret = ptrace (PTRACE_SETFPREGS, inferior_pid, 0, (int) &buf);
  if (ret < 0)
d198 1
d202 4
a205 2
/* Read the general registers from the process, and store them
   in registers[].  */
d207 1
a207 1
fetch_regs ()
d210 1
a210 1
  gregset_t buf;
d212 2
a213 2
  ret = ptrace (PTRACE_GETREGS, inferior_pid, 0, (int) &buf);
  if (ret < 0)
d219 3
a221 1
  supply_gregset (&buf);
d225 4
a228 2
/* Set the inferior's general registers to the values in registers[]
   --- but only those registers marked as valid.  */
d230 1
a230 1
store_regs ()
d233 1
a233 1
  gregset_t buf;
d235 2
a236 2
  ret = ptrace (PTRACE_GETREGS, inferior_pid, 0, (int) &buf);
  if (ret < 0)
d242 5
a246 1
  convert_to_gregset (&buf, registers, register_valid);
d249 2
a250 1
  if (ret < 0)
d252 1
a252 1
      warning ("Couldn't write registers");
d255 1
d265 2
a266 1
fetch_inferior_registers (int regno)
d268 2
a269 2
  if (regno < NUM_GREGS || regno == -1)
    fetch_regs ();
d271 2
a272 2
  if (regno >= NUM_GREGS || regno == -1)
    fetch_fpregs ();
d286 2
a287 2
  if (regno < NUM_GREGS || regno == -1)
    store_regs ();
d289 2
a290 2
  if (regno >= NUM_GREGS || regno == -1)
    store_fpregs ();
@


1.1.1.3
log
@import gdb-1999-11-01 snapshot
@
text
@a47 29
/* Which ptrace request retrieves which registers?
   These apply to the corresponding SET requests as well.  */
#define GETREGS_SUPPLIES(regno) \
  (0 <= (regno) && (regno) <= 15)
#define GETFPREGS_SUPPLIES(regno) \
  (FP0_REGNUM <= (regno) && (regno) <= LAST_FPU_CTRL_REGNUM)
#define GETXFPREGS_SUPPLIES(regno) \
  (FP0_REGNUM <= (regno) && (regno) <= MXCSR_REGNUM)

/* Does the current host support the GETXFPREGS request?  The header
   file may or may not define it, and even if it is defined, the
   kernel will return EIO if it's running on a pre-SSE processor.

   My instinct is to attach this to some architecture- or
   target-specific data structure, but really, a particular GDB
   process can only run on top of one kernel at a time.  So it's okay
   for this to be a simple variable.  */
int have_ptrace_getxfpregs =
#ifdef HAVE_PTRACE_GETXFPREGS
  1
#else
  0
#endif
;



/* Transfering the general registers between GDB, inferiors and core files.  */

a63 1

a84 3

/* Store GDB's value for REGNO in *GREGSETP.  If REGNO is -1, do all
   of them.  */
d101 2
a102 50
/* Read the general registers from the process, and store them
   in registers[].  */
static void
fetch_regs ()
{
  int ret, regno;
  gregset_t buf;

  ret = ptrace (PTRACE_GETREGS, inferior_pid, 0, (int) &buf);
  if (ret < 0)
    {
      warning ("Couldn't get registers");
      return;
    }

  supply_gregset (&buf);
}


/* Set the inferior's general registers to the values in registers[]
   --- but only those registers marked as valid.  */
static void
store_regs ()
{
  int ret, regno;
  gregset_t buf;

  ret = ptrace (PTRACE_GETREGS, inferior_pid, 0, (int) &buf);
  if (ret < 0)
    {
      warning ("Couldn't get registers");
      return;
    }

  convert_to_gregset (&buf, registers, register_valid);

  ret = ptrace (PTRACE_SETREGS, inferior_pid, 0, (int)buf);
  if (ret < 0)
    {
      warning ("Couldn't write registers");
      return;
    }
}



/* Transfering floating-point registers between GDB, inferiors and cores.  */

/* What is the address of st(N) within the fpregset_t structure F?  */
#define FPREGSET_T_FPREG_ADDR(f, n) \
d114 1
a114 1
    supply_register (FP0_REGNUM + i, FPREGSET_T_FPREG_ADDR (fpregsetp, i));
d154 1
a154 1
      memcpy (FPREGSET_T_FPREG_ADDR (fpregsetp, i),
a242 2

/* Transfering floating-point and SSE registers to and from GDB.  */
d244 2
a245 2

#ifdef HAVE_PTRACE_GETXFPREGS
d247 1
a247 1
supply_xfpregset (struct user_xfpregs_struct *xfpregs)
d249 2
a250 1
  int reg;
d252 2
a253 13
  /* Supply the floating-point registers.  */
  for (reg = 0; reg < 8; reg++)
    supply_register (FP0_REGNUM + reg, (char *) &xfpregs->st_space[reg]);

  {
    supply_register (FCTRL_REGNUM, (char *) &xfpregs->cwd);
    supply_register (FSTAT_REGNUM, (char *) &xfpregs->swd);
    supply_register (FTAG_REGNUM,  (char *) &xfpregs->twd);
    supply_register (FCOFF_REGNUM, (char *) &xfpregs->fip);
    supply_register (FDS_REGNUM,   (char *) &xfpregs->fos);
    supply_register (FDOFF_REGNUM, (char *) &xfpregs->foo);
  
    /* Extract the code segment and opcode from the  "fcs" member.  */
d255 2
a256 7
      long l;
      
      l = xfpregs->fcs & 0xffff;
      supply_register (FCS_REGNUM, (char *) &l);

      l = (xfpregs->fcs >> 16) & ((1 << 11) - 1);
      supply_register (FOP_REGNUM, (char *) &l);
a257 1
  }
d259 1
a259 4
  /* Supply the SSE registers.  */
  for (reg = 0; reg < 8; reg++)
    supply_register (XMM0_REGNUM + reg, (char *) &xfpregs->xmm_space[reg]);
  supply_register (MXCSR_REGNUM, (char *) &xfpregs->mxcsr);
d263 2
d266 1
a266 3
convert_to_xfpregset (struct user_xfpregs_struct *xfpregs,
		      char *gdb_regs,
		      signed char *valid)
d268 2
a269 1
  int reg;
d271 2
a272 54
  /* Fill in the floating-point registers.  */
  for (reg = 0; reg < 8; reg++)
    if (!valid || valid[reg])
      memcpy (&xfpregs->st_space[reg],
	      &registers[REGISTER_BYTE (FP0_REGNUM + reg)],
	      REGISTER_RAW_SIZE(FP0_REGNUM + reg));

#define fill(MEMBER, REGNO)						\
  if (! valid || valid[(REGNO)])					\
    memcpy (&xfpregs->MEMBER, &registers[REGISTER_BYTE (REGNO)],	\
	    sizeof (xfpregs->MEMBER))

  fill (cwd, FCTRL_REGNUM);
  fill (swd, FSTAT_REGNUM);
  fill (twd, FTAG_REGNUM);
  fill (fip, FCOFF_REGNUM);
  fill (foo, FDOFF_REGNUM);
  fill (fos, FDS_REGNUM);

#undef fill

  if (! valid || valid[FCS_REGNUM])
    xfpregs->fcs
      = ((xfpregs->fcs & ~0xffff)
	 | (* (int *) &registers[REGISTER_BYTE (FCS_REGNUM)] & 0xffff));

  if (! valid || valid[FOP_REGNUM])
    xfpregs->fcs
      = ((xfpregs->fcs & 0xffff)
	 | ((*(int *) &registers[REGISTER_BYTE (FOP_REGNUM)] & ((1 << 11) - 1))
	    << 16));

  /* Fill in the XMM registers.  */
  for (reg = 0; reg < 8; reg++)
    if (! valid || valid[reg])
      memcpy (&xfpregs->xmm_space[reg],
	      &registers[REGISTER_BYTE (XMM0_REGNUM + reg)],
	      REGISTER_RAW_SIZE (XMM0_REGNUM + reg));
}


/* Make a PTRACE_GETXFPREGS request, and supply all the register
   values that yields to GDB.  */
static int
fetch_xfpregs ()
{
  int ret;
  struct user_xfpregs_struct xfpregs;

  if (! have_ptrace_getxfpregs) 
    return 0;

  ret = ptrace (PTRACE_GETXFPREGS, inferior_pid, 0, &xfpregs);
  if (ret == -1)
d274 2
a275 8
      if (errno == EIO)
	{
	  have_ptrace_getxfpregs = 0;
	  return 0;
	}

      warning ("couldn't read floating-point and SSE registers.");
      return 0;
d278 1
a278 3
  supply_xfpregset (&xfpregs);
  return 1;
}
d280 2
a281 14

/* Send all the valid register values in GDB's register file covered
   by the PTRACE_SETXFPREGS request to the inferior.  */
static int
store_xfpregs ()
{
  int ret;
  struct user_xfpregs_struct xfpregs;

  if (! have_ptrace_getxfpregs)
    return 0;

  ret = ptrace (PTRACE_GETXFPREGS, inferior_pid, 0, &xfpregs);
  if (ret == -1)
d283 2
a284 8
      if (errno == EIO)
	{
	  have_ptrace_getxfpregs = 0;
	  return 0;
	}

      warning ("couldn't read floating-point and SSE registers.");
      return 0;
a285 29

  convert_to_xfpregset (&xfpregs, registers, register_valid);

  if (ptrace (PTRACE_SETXFPREGS, inferior_pid, 0, &xfpregs) < 0)
    {
      warning ("Couldn't write floating-point and SSE registers.");
      return 0;
    }

  return 1;
}


/* Fill the XMM registers in the register file with dummy values.  For
   cases where we don't have access to the XMM registers.  I think
   this is cleaner than printing a warning.  For a cleaner solution,
   we should gdbarchify the i386 family.  */
static void
dummy_sse_values ()
{
  /* C doesn't have a syntax for NaN's, so write it out as an array of
     longs.  */
  static long dummy[4] = { 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff };
  static long mxcsr = 0x1f80;
  int reg;

  for (reg = 0; reg < 8; reg++)
    supply_register (XMM0_REGNUM + reg, (char *) dummy);
  supply_register (MXCSR_REGNUM, (char *) &mxcsr);
a287 12
#else

/* Stub versions of the above routines, for systems that don't have
   PTRACE_GETXFPREGS.  */
static int store_xfpregs () { return 0; }
static int fetch_xfpregs () { return 0; }
static void dummy_sse_values () {}

#endif


/* Transferring arbitrary registers between GDB and inferior.  */
d297 2
a298 17
  /* Use the xfpregs requests whenever possible, since they transfer
     more registers in one system call, and we'll cache the results.
     But remember that fetch_xfpregs can fail, and return zero.  */
  if (regno == -1)
    {
      fetch_regs ();
      if (fetch_xfpregs ())
	return;
      fetch_fpregs ();
      return;
    }

  if (GETREGS_SUPPLIES (regno))
    {
      fetch_regs ();
      return;
    }
d300 2
a301 18
  if (GETXFPREGS_SUPPLIES (regno))
    {
      if (fetch_xfpregs ())
	return;

      /* Either our processor or our kernel doesn't support the SSE
	 registers, so read the FP registers in the traditional way,
	 and fill the SSE registers with dummy values.  It would be
	 more graceful to handle differences in the register set using
	 gdbarch.  Until then, this will at least make things work
	 plausibly.  */
      fetch_fpregs ();
      dummy_sse_values ();
      return;
    }

  internal_error ("i386-linux-nat.c (fetch_inferior_registers): "
		  "got request for bad register number %d", regno);
d315 2
a316 11
  /* Use the xfpregs requests whenever possible, since they transfer
     more registers in one system call.  But remember that
     fetch_xfpregs can fail, and return zero.  */
  if (regno == -1)
    {
      store_regs ();
      if (store_xfpregs ())
	return;
      store_fpregs ();
      return;
    }
d318 2
a319 19
  if (GETREGS_SUPPLIES (regno))
    {
      store_regs ();
      return;
    }

  if (GETXFPREGS_SUPPLIES (regno))
    {
      if (store_xfpregs ())
	return;

      /* Either our processor or our kernel doesn't support the SSE
	 registers, so just write the FP registers in the traditional way.  */
      store_fpregs ();
      return;
    }

  internal_error ("i386-linux-nat.c (store_inferior_registers): "
		  "got request to store bad register number %d", regno);
a321 3


/* Calling functions in shared libraries.  */
@


1.1.1.4
log
@import gdb-1999-11-08 snapshot
@
text
@a327 7
/* PTRACE_GETXFPREGS is a Cygnus invention, since we wrote our own
   Linux kernel patch for SSE support.  That patch may or may not
   actually make it into the official distribution.  If you find that
   years have gone by since this code was added, and Linux isn't using
   PTRACE_GETXFPREGS, that means that our patch didn't make it, and
   you can delete this code.  */

@


1.1.1.5
log
@import gdb-1999-12-06 snapshot
@
text
@a60 7
   PTRACE_GETXFPREGS is a Cygnus invention, since we wrote our own
   Linux kernel patch for SSE support.  That patch may or may not
   actually make it into the official distribution.  If you find that
   years have gone by since this stuff was added, and Linux isn't
   using PTRACE_GETXFPREGS, that means that our patch didn't make it,
   and you can delete this, and the related code.

d124 1
a124 1
  else if (regno >= 0 && regno < NUM_GREGS)
@


1.1.1.6
log
@import gdb-1999-12-07 snapshot
@
text
@a614 85
/* Interpreting register set info found in core files.  */

/* Provide registers to GDB from a core file.

   (We can't use the generic version of this function in
   core-regset.c, because Linux has *three* different kinds of
   register set notes.  core-regset.c would have to call
   supply_xfpregset, which most platforms don't have.)

   CORE_REG_SECT points to an array of bytes, which are the contents
   of a `note' from a core file which BFD thinks might contain
   register contents.  CORE_REG_SIZE is its size.

   WHICH says which register set corelow suspects this is:
   0 --- the general register set, in gregset format
   2 --- the floating-point register set, in fpregset format
   3 --- the extended floating-point register set, in struct
         user_xfpregs_struct format

   DUMMY isn't used on Linux.  */
static void
i386_linux_fetch_core_registers (char *core_reg_sect,
				 unsigned core_reg_size,
				 int which,
				 CORE_ADDR dummy)
{
  gregset_t gregset;
  fpregset_t fpregset;

  switch (which)
    {
    case 0:
      if (core_reg_size != sizeof (gregset))
	warning ("wrong size gregset struct in core file");
      else
	{
	  memcpy (&gregset, core_reg_sect, sizeof (gregset));
	  supply_gregset (&gregset);
	}
      break;

    case 2:
      if (core_reg_size != sizeof (fpregset))
	warning ("wrong size fpregset struct in core file");
      else
	{
	  memcpy (&fpregset, core_reg_sect, sizeof (fpregset));
	  supply_fpregset (&fpregset);
	}
      break;

#ifdef HAVE_PTRACE_GETXFPREGS
      {
	struct user_xfpregs_struct xfpregset;
      case 3:
	if (core_reg_size != sizeof (struct user_xfpregs_struct))
	  warning ("wrong size user_xfpregs_struct in core file");
	else
	  {
	    memcpy (&xfpregset, core_reg_sect, sizeof (xfpregset));
	    supply_xfpregset (&xfpregset);
	  }
	break;
      }
#endif

    default:
      /* We've covered all the kinds of registers we know about here,
         so this must be something we wouldn't know what to do with
         anyway.  Just ignore it.  */
      break;
    }
}


static struct core_fns i386_linux_nat_core_fns =
{
  bfd_target_elf_flavour,		/* core_flavour */
  default_check_format,			/* check_format */
  default_core_sniffer,			/* core_sniffer */
  i386_linux_fetch_core_registers,	/* core_read_registers */
  NULL					/* next */
};


a701 10
}



/* Module initialization.  */

void
_initialize_i386_linux_nat ()
{
  add_core_fns (&i386_linux_nat_core_fns);
@


1.1.1.7
log
@import gdb-1999-12-21 snapshot
@
text
@a36 13
/*
 * Some systems (Linux) may have threads implemented as pseudo-processes, 
 * in which case we may be tracing more than one process at a time.
 * In that case, inferior_pid will contain the main process ID and the 
 * individual thread (process) id mashed together.  These macros are 
 * used to separate them out.  The definitions may be overridden in tm.h
 */

#if !defined (PIDGET)	/* Default definition for PIDGET/TIDGET.  */
#define PIDGET(PID)	PID
#define TIDGET(PID)	0
#endif

d144 1
a144 1
fetch_regs (int tid)
d149 1
a149 1
  ret = ptrace (PTRACE_GETREGS, tid, 0, (int) &buf);
d163 1
a163 1
store_regs (int tid)
d168 1
a168 1
  ret = ptrace (PTRACE_GETREGS, tid, 0, (int) &buf);
d177 1
a177 1
  ret = ptrace (PTRACE_SETREGS, tid, 0, (int)buf);
d288 1
a288 1
fetch_fpregs (int tid)
d293 1
a293 1
  ret = ptrace (PTRACE_GETFPREGS, tid, 0, (int) &buf);
d309 1
a309 1
store_fpregs (int tid)
d314 1
a314 1
  ret = ptrace (PTRACE_GETFPREGS, tid, 0, (int) &buf);
d323 1
a323 1
  ret = ptrace (PTRACE_SETFPREGS, tid, 0, (int) &buf);
d430 1
a430 1
fetch_xfpregs (int tid)
d438 1
a438 1
  ret = ptrace (PTRACE_GETXFPREGS, tid, 0, &xfpregs);
d459 1
a459 1
store_xfpregs (int tid)
d467 1
a467 1
  ret = ptrace (PTRACE_GETXFPREGS, tid, 0, &xfpregs);
d482 1
a482 1
  if (ptrace (PTRACE_SETXFPREGS, tid, 0, &xfpregs) < 0)
d514 2
a515 2
static int store_xfpregs (int tid) { return 0; }
static int fetch_xfpregs (int tid) { return 0; }
a530 6
  /* linux lwp id's are process id's */
  int tid;

  if ((tid = TIDGET (inferior_pid)) == 0)
    tid = inferior_pid;		/* not a threaded program */

d536 2
a537 2
      fetch_regs (tid);
      if (fetch_xfpregs (tid))
d539 1
a539 1
      fetch_fpregs (tid);
d545 1
a545 1
      fetch_regs (tid);
d551 1
a551 1
      if (fetch_xfpregs (tid))
d560 1
a560 1
      fetch_fpregs (tid);
a579 6
  /* linux lwp id's are process id's */
  int tid;

  if ((tid = TIDGET (inferior_pid)) == 0)
    tid = inferior_pid;		/* not a threaded program */

d582 1
a582 1
     store_xfpregs can fail, and return zero.  */
d585 2
a586 2
      store_regs (tid);
      if (store_xfpregs (tid))
d588 1
a588 1
      store_fpregs (tid);
d594 1
a594 1
      store_regs (tid);
d600 1
a600 1
      if (store_xfpregs (tid))
d605 1
a605 1
      store_fpregs (tid);
@


1.1.1.8
log
@import gdb-2000-01-17 snapshot
@
text
@d149 1
a149 1
      convert_to_gregset (gregsetp, registers, valid);
@


