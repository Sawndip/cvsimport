head	1.19;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.19
	gdb_7_6-2013-04-26-release:1.19
	gdb_7_6-branch:1.19.0.2
	gdb_7_6-2013-03-12-branchpoint:1.19
	gdb_7_5_1-2012-11-29-release:1.15
	gdb_7_5-2012-08-17-release:1.15
	gdb_7_5-branch:1.15.0.2
	gdb_7_5-2012-07-18-branchpoint:1.15
	gdb_7_4_1-2012-04-26-release:1.14.4.1
	gdb_7_4-2012-01-24-release:1.14.4.1
	gdb_7_4-branch:1.14.0.4
	gdb_7_4-2011-12-13-branchpoint:1.14
	gdb_7_3_1-2011-09-04-release:1.14
	gdb_7_3-2011-07-26-release:1.14
	gdb_7_3-branch:1.14.0.2
	gdb_7_3-2011-04-01-branchpoint:1.14
	gdb_7_2-2010-09-02-release:1.12
	gdb_7_2-branch:1.12.0.2
	gdb_7_2-2010-07-07-branchpoint:1.12
	gdb_7_1-2010-03-18-release:1.8.2.1
	gdb_7_1-branch:1.8.0.2
	gdb_7_1-2010-02-18-branchpoint:1.8
	gdb_7_0_1-2009-12-22-release:1.7
	gdb_7_0-2009-10-06-release:1.7
	gdb_7_0-branch:1.7.0.2
	gdb_7_0-2009-09-16-branchpoint:1.7
	msnyder-checkpoint-072509-branch:1.5.0.2
	msnyder-checkpoint-072509-branchpoint:1.5
	reverse-20081226-branch:1.1.0.6
	reverse-20080930-branch:1.1.0.4
	reverse-20080717-branch:1.1.0.2;
locks; strict;
comment	@ * @;


1.19
date	2013.03.11.08.45.54;	author mmetzger;	state Exp;
branches;
next	1.18;

1.18
date	2013.03.11.08.42.55;	author mmetzger;	state Exp;
branches;
next	1.17;

1.17
date	2013.03.07.18.29.05;	author palves;	state Exp;
branches;
next	1.16;

1.16
date	2013.01.01.06.32.46;	author brobecke;	state Exp;
branches;
next	1.15;

1.15
date	2012.01.04.08.17.05;	author brobecke;	state Exp;
branches;
next	1.14;

1.14
date	2011.02.28.18.10.30;	author msnyder;	state Exp;
branches
	1.14.4.1;
next	1.13;

1.13
date	2011.01.01.15.33.10;	author brobecke;	state Exp;
branches;
next	1.12;

1.12
date	2010.06.22.02.15.45;	author teawater;	state Exp;
branches;
next	1.11;

1.11
date	2010.05.14.23.41.05;	author msnyder;	state Exp;
branches;
next	1.10;

1.10
date	2010.05.05.19.58.12;	author msnyder;	state Exp;
branches;
next	1.9;

1.9
date	2010.03.16.17.01.21;	author teawater;	state Exp;
branches;
next	1.8;

1.8
date	2010.01.01.07.31.37;	author brobecke;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2009.09.08.22.50.59;	author msnyder;	state Exp;
branches;
next	1.6;

1.6
date	2009.08.10.03.04.44;	author teawater;	state Exp;
branches;
next	1.5;

1.5
date	2009.07.02.17.21.06;	author uweigand;	state Exp;
branches;
next	1.4;

1.4
date	2009.05.24.04.42.51;	author teawater;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.22.14.07.27;	author teawater;	state Exp;
branches;
next	1.2;

1.2
date	2009.04.30.03.04.28;	author teawater;	state Exp;
branches;
next	1.1;

1.1
date	2008.07.20.14.30.11;	author teawater;	state dead;
branches
	1.1.2.1
	1.1.4.1
	1.1.6.1;
next	;

1.14.4.1
date	2012.01.06.04.43.19;	author brobecke;	state Exp;
branches;
next	;

1.8.2.1
date	2010.03.16.17.06.40;	author teawater;	state Exp;
branches;
next	;

1.1.2.1
date	2008.07.20.14.30.11;	author teawater;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2008.08.07.03.04.25;	author teawater;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2008.09.02.09.18.28;	author teawater;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2008.09.07.01.40.43;	author msnyder;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2008.10.05.22.19.32;	author msnyder;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	2008.10.07.07.37.37;	author teawater;	state Exp;
branches;
next	;

1.1.4.1
date	2008.10.01.03.39.00;	author msnyder;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2008.10.07.08.33.15;	author teawater;	state Exp;
branches;
next	;

1.1.6.1
date	2008.12.26.21.09.13;	author msnyder;	state Exp;
branches;
next	1.1.6.2;

1.1.6.2
date	2008.12.28.20.33.32;	author msnyder;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Rename record_ prefixes in record-full.h into record_full_.

gdb/
	* record-full.h, record-full.c (record_memory_query): Rename
	to ...
	(record_full_memory_query): ...this. Update all users.
	(record_arch_list_add_reg): Rename to ...
	(record_full_arch_list_add_reg): ...this. Update all users.
	(record_arch_list_add_mem): Rename to ...
	(record_full_arch_list_add_mem): ...this. Update all users.
	(record_arch_list_add_end): Rename to ...
	(record_full_arch_list_add_end): ...this. Update all users.
	(record_gdb_operation_disable_set): Rename to ...
	(record_full_gdb_operation_disable_set): ...this.
	Update all users.
@
text
@/* Process record and replay target code for GNU/Linux.

   Copyright (C) 2008-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "target.h"
#include "gdbtypes.h"
#include "regcache.h"
#include "record.h"
#include "record-full.h"
#include "linux-record.h"

/* These macros are the values of the first argument of system call
   "sys_ptrace".  The values of these macros were obtained from Linux
   Kernel source.  */

#define RECORD_PTRACE_PEEKTEXT	1
#define RECORD_PTRACE_PEEKDATA	2
#define RECORD_PTRACE_PEEKUSR	3

/* These macros are the values of the first argument of system call
   "sys_socketcall".  The values of these macros were obtained from
   Linux Kernel source.  */

#define RECORD_SYS_SOCKET	1
#define RECORD_SYS_BIND		2
#define RECORD_SYS_CONNECT	3
#define RECORD_SYS_LISTEN	4
#define RECORD_SYS_ACCEPT	5
#define RECORD_SYS_GETSOCKNAME	6
#define RECORD_SYS_GETPEERNAME	7
#define RECORD_SYS_SOCKETPAIR	8
#define RECORD_SYS_SEND		9
#define RECORD_SYS_RECV		10
#define RECORD_SYS_SENDTO	11
#define RECORD_SYS_RECVFROM	12
#define RECORD_SYS_SHUTDOWN	13
#define RECORD_SYS_SETSOCKOPT	14
#define RECORD_SYS_GETSOCKOPT	15
#define RECORD_SYS_SENDMSG	16
#define RECORD_SYS_RECVMSG	17

/* These macros are the values of the first argument of system call
   "sys_ipc".  The values of these macros were obtained from Linux
   Kernel source.  */

#define RECORD_SEMOP		1
#define RECORD_SEMGET		2
#define RECORD_SEMCTL		3
#define RECORD_SEMTIMEDOP	4
#define RECORD_MSGSND		11
#define RECORD_MSGRCV		12
#define RECORD_MSGGET		13
#define RECORD_MSGCTL		14
#define RECORD_SHMAT		21
#define RECORD_SHMDT		22
#define RECORD_SHMGET		23
#define RECORD_SHMCTL		24

/* These macros are the values of the first argument of system call
   "sys_quotactl".  The values of these macros were obtained from Linux
   Kernel source.  */

#define RECORD_Q_GETFMT		0x800004
#define RECORD_Q_GETINFO	0x800005
#define RECORD_Q_GETQUOTA	0x800007
#define RECORD_Q_XGETQSTAT	(('5' << 8) + 5)
#define RECORD_Q_XGETQUOTA	(('3' << 8) + 3)

#define OUTPUT_REG(val, num)      phex_nz ((val), \
    TYPE_LENGTH (gdbarch_register_type (get_regcache_arch (regcache), (num))))

static int
record_linux_sockaddr (struct regcache *regcache,
                       struct linux_record_tdep *tdep, ULONGEST addr,
                       ULONGEST len)
{
  gdb_byte *a;
  int addrlen;
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);

  if (!addr)
    return 0;

  a = alloca (tdep->size_int);

  if (record_full_arch_list_add_mem ((CORE_ADDR) len, tdep->size_int))
    return -1;

  /* Get the addrlen.  */
  if (target_read_memory ((CORE_ADDR) len, a, tdep->size_int))
    {
      if (record_debug)
        fprintf_unfiltered (gdb_stdlog,
                            "Process record: error reading "
                            "memory at addr = 0x%s len = %d.\n",
                            phex_nz (len, tdep->size_pointer),
                            tdep->size_int);
        return -1;
    }
  addrlen = (int) extract_unsigned_integer (a, tdep->size_int, byte_order);
  if (addrlen <= 0 || addrlen > tdep->size_sockaddr)
    addrlen = tdep->size_sockaddr;

  if (record_full_arch_list_add_mem ((CORE_ADDR) addr, addrlen))
    return -1;

  return 0;
}

static int
record_linux_msghdr (struct regcache *regcache,
                     struct linux_record_tdep *tdep, ULONGEST addr)
{
  gdb_byte *a;
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  CORE_ADDR tmpaddr;
  int tmpint;

  if (!addr)
    return 0;

  if (record_full_arch_list_add_mem ((CORE_ADDR) addr, tdep->size_msghdr))
    return -1;

  a = alloca (tdep->size_msghdr);
  if (target_read_memory ((CORE_ADDR) addr, a, tdep->size_msghdr))
    {
      if (record_debug)
        fprintf_unfiltered (gdb_stdlog,
                            "Process record: error reading "
                            "memory at addr = 0x%s "
                            "len = %d.\n",
                            phex_nz (addr, tdep->size_pointer),
                            tdep->size_msghdr);
        return -1;
    }

  /* msg_name msg_namelen */
  addr = extract_unsigned_integer (a, tdep->size_pointer, byte_order);
  a += tdep->size_pointer;
  if (record_full_arch_list_add_mem
      ((CORE_ADDR) addr,
       (int) extract_unsigned_integer (a,
				       tdep->size_int,
				       byte_order)))
    return -1;
  a += tdep->size_int;

  /* msg_iov msg_iovlen */
  addr = extract_unsigned_integer (a, tdep->size_pointer, byte_order);
  a += tdep->size_pointer;
  if (addr)
    {
      ULONGEST i;
      ULONGEST len = extract_unsigned_integer (a, tdep->size_size_t,
                                               byte_order);
      gdb_byte *iov = alloca (tdep->size_iovec);

      for (i = 0; i < len; i++)
        {
          if (target_read_memory ((CORE_ADDR) addr, iov, tdep->size_iovec))
            {
              if (record_debug)
                fprintf_unfiltered (gdb_stdlog,
                                    "Process record: error "
                                    "reading memory at "
                                    "addr = 0x%s "
                                    "len = %d.\n",
                                    phex_nz (addr,tdep->size_pointer),
                                    tdep->size_iovec);
                return -1;
            }
          tmpaddr = (CORE_ADDR) extract_unsigned_integer (iov,
                                                          tdep->size_pointer,
                                                          byte_order);
          tmpint = (int) extract_unsigned_integer (iov + tdep->size_pointer,
                                                   tdep->size_size_t,
                                                   byte_order);
          if (record_full_arch_list_add_mem (tmpaddr, tmpint))
            return -1;
          addr += tdep->size_iovec;
        }
    }
  a += tdep->size_size_t;

  /* msg_control msg_controllen */
  addr = extract_unsigned_integer (a, tdep->size_pointer, byte_order);
  a += tdep->size_pointer;
  tmpint = (int) extract_unsigned_integer (a, tdep->size_size_t, byte_order);
  if (record_full_arch_list_add_mem ((CORE_ADDR) addr, tmpint))
    return -1;

  return 0;
}

/* When the architecture process record get a Linux syscall
   instruction, it will get a Linux syscall number of this
   architecture and convert it to the Linux syscall number "num" which
   is internal to GDB.  Most Linux syscalls across architectures in
   Linux would be similar and mostly differ by sizes of types and
   structures.  This sizes are put to "tdep".

   Record the values of the registers and memory that will be changed
   in current system call.

   Return -1 if something wrong.  */

int
record_linux_system_call (enum gdb_syscall syscall, 
			  struct regcache *regcache,
                          struct linux_record_tdep *tdep)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  ULONGEST tmpulongest;
  CORE_ADDR tmpaddr;
  int tmpint;

  switch (syscall)
    {
    case gdb_sys_restart_syscall:
      break;

    case gdb_sys_exit:
      {
        int q;

        target_terminal_ours ();
        q = yquery (_("The next instruction is syscall exit.  "
                      "It will make the program exit.  "
                      "Do you want to stop the program?"));
        target_terminal_inferior ();
        if (q)
          return 1;
      }
      break;

    case gdb_sys_fork:
      break;

    case gdb_sys_read:
      {
        ULONGEST addr, count;

        regcache_raw_read_unsigned (regcache, tdep->arg2, &addr);
        regcache_raw_read_unsigned (regcache, tdep->arg3, &count);
        if (record_full_arch_list_add_mem ((CORE_ADDR) addr, (int) count))
          return -1;
      }
      break;

    case gdb_sys_write:
    case gdb_sys_open:
    case gdb_sys_close:
    case gdb_sys_waitpid:
    case gdb_sys_creat:
    case gdb_sys_link:
    case gdb_sys_unlink:
    case gdb_sys_execve:
    case gdb_sys_chdir:
    case gdb_sys_time:
    case gdb_sys_mknod:
    case gdb_sys_chmod:
    case gdb_sys_lchown16:
    case gdb_sys_ni_syscall17:
      break;

    case gdb_sys_stat:
    case gdb_sys_fstat:
    case gdb_sys_lstat:
      regcache_raw_read_unsigned (regcache, tdep->arg2, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size__old_kernel_stat))
        return -1;
      break;

    case gdb_sys_lseek:
    case gdb_sys_getpid:
    case gdb_sys_mount:
    case gdb_sys_oldumount:
    case gdb_sys_setuid16:
    case gdb_sys_getuid16:
    case gdb_sys_stime:
      break;

    case gdb_sys_ptrace:
      regcache_raw_read_unsigned (regcache, tdep->arg1, &tmpulongest);
      if (tmpulongest == RECORD_PTRACE_PEEKTEXT
          || tmpulongest == RECORD_PTRACE_PEEKDATA
          || tmpulongest == RECORD_PTRACE_PEEKUSR)
        {
          regcache_raw_read_unsigned (regcache, tdep->arg4,
                                      &tmpulongest);
          if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest, 4))
            return -1;
        }
      break;

    case gdb_sys_alarm:
    case gdb_sys_pause:
    case gdb_sys_utime:
    case gdb_sys_ni_syscall31:
    case gdb_sys_ni_syscall32:
    case gdb_sys_access:
    case gdb_sys_nice:
    case gdb_sys_ni_syscall35:
    case gdb_sys_sync:
    case gdb_sys_kill:
    case gdb_sys_rename:
    case gdb_sys_mkdir:
    case gdb_sys_rmdir:
    case gdb_sys_dup:
    case gdb_sys_pipe:
      break;

    case gdb_sys_times:
      regcache_raw_read_unsigned (regcache, tdep->arg1, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_tms))
        return -1;
      break;

    case gdb_sys_ni_syscall44:
    case gdb_sys_brk:
    case gdb_sys_setgid16:
    case gdb_sys_getgid16:
    case gdb_sys_signal:
    case gdb_sys_geteuid16:
    case gdb_sys_getegid16:
    case gdb_sys_acct:
    case gdb_sys_umount:
    case gdb_sys_ni_syscall53:
      break;

    case gdb_sys_ioctl:
      /* XXX Need to add a lot of support of other ioctl requests.  */
      regcache_raw_read_unsigned (regcache, tdep->arg2, &tmpulongest);
      if (tmpulongest == tdep->ioctl_FIOCLEX
          || tmpulongest == tdep->ioctl_FIONCLEX
          || tmpulongest == tdep->ioctl_FIONBIO
          || tmpulongest == tdep->ioctl_FIOASYNC
          || tmpulongest == tdep->ioctl_TCSETS
          || tmpulongest == tdep->ioctl_TCSETSW
          || tmpulongest == tdep->ioctl_TCSETSF
          || tmpulongest == tdep->ioctl_TCSETA
          || tmpulongest == tdep->ioctl_TCSETAW
          || tmpulongest == tdep->ioctl_TCSETAF
          || tmpulongest == tdep->ioctl_TCSBRK
          || tmpulongest == tdep->ioctl_TCXONC
          || tmpulongest == tdep->ioctl_TCFLSH
          || tmpulongest == tdep->ioctl_TIOCEXCL
          || tmpulongest == tdep->ioctl_TIOCNXCL
          || tmpulongest == tdep->ioctl_TIOCSCTTY
          || tmpulongest == tdep->ioctl_TIOCSPGRP
          || tmpulongest == tdep->ioctl_TIOCSTI
          || tmpulongest == tdep->ioctl_TIOCSWINSZ
          || tmpulongest == tdep->ioctl_TIOCMBIS
          || tmpulongest == tdep->ioctl_TIOCMBIC
          || tmpulongest == tdep->ioctl_TIOCMSET
          || tmpulongest == tdep->ioctl_TIOCSSOFTCAR
          || tmpulongest == tdep->ioctl_TIOCCONS
          || tmpulongest == tdep->ioctl_TIOCSSERIAL
          || tmpulongest == tdep->ioctl_TIOCPKT
          || tmpulongest == tdep->ioctl_TIOCNOTTY
          || tmpulongest == tdep->ioctl_TIOCSETD
          || tmpulongest == tdep->ioctl_TCSBRKP
          || tmpulongest == tdep->ioctl_TIOCTTYGSTRUCT
          || tmpulongest == tdep->ioctl_TIOCSBRK
          || tmpulongest == tdep->ioctl_TIOCCBRK
          || tmpulongest == tdep->ioctl_TCSETS2
          || tmpulongest == tdep->ioctl_TCSETSW2
          || tmpulongest == tdep->ioctl_TCSETSF2
          || tmpulongest == tdep->ioctl_TIOCSPTLCK
          || tmpulongest == tdep->ioctl_TIOCSERCONFIG
          || tmpulongest == tdep->ioctl_TIOCSERGWILD
          || tmpulongest == tdep->ioctl_TIOCSERSWILD
          || tmpulongest == tdep->ioctl_TIOCSLCKTRMIOS
          || tmpulongest == tdep->ioctl_TIOCSERGETMULTI
          || tmpulongest == tdep->ioctl_TIOCSERSETMULTI
          || tmpulongest == tdep->ioctl_TIOCMIWAIT
          || tmpulongest == tdep->ioctl_TIOCSHAYESESP)
        {
          /* Nothing to do.  */
        }
      else if (tmpulongest == tdep->ioctl_TCGETS
               || tmpulongest == tdep->ioctl_TCGETA
               || tmpulongest == tdep->ioctl_TIOCGLCKTRMIOS)
        {
          regcache_raw_read_unsigned (regcache, tdep->arg3,
                                      &tmpulongest);
          if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					     tdep->size_termios))
            return -1;
        }
      else if (tmpulongest == tdep->ioctl_TIOCGPGRP
               || tmpulongest == tdep->ioctl_TIOCGSID)
        {
          regcache_raw_read_unsigned (regcache, tdep->arg3,
                                      &tmpulongest);
          if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					     tdep->size_pid_t))
            return -1;
        }
      else if (tmpulongest == tdep->ioctl_TIOCOUTQ
               || tmpulongest == tdep->ioctl_TIOCMGET
               || tmpulongest == tdep->ioctl_TIOCGSOFTCAR
               || tmpulongest == tdep->ioctl_FIONREAD
               || tmpulongest == tdep->ioctl_TIOCINQ
               || tmpulongest == tdep->ioctl_TIOCGETD
               || tmpulongest == tdep->ioctl_TIOCGPTN
               || tmpulongest == tdep->ioctl_TIOCSERGETLSR)
        {
          regcache_raw_read_unsigned (regcache, tdep->arg3,
                                      &tmpulongest);
          if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					     tdep->size_int))
            return -1;
        }
      else if (tmpulongest == tdep->ioctl_TIOCGWINSZ)
        {
          regcache_raw_read_unsigned (regcache, tdep->arg3,
                                      &tmpulongest);
          if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					     tdep->size_winsize))
            return -1;
        }
      else if (tmpulongest == tdep->ioctl_TIOCLINUX)
        {
          regcache_raw_read_unsigned (regcache, tdep->arg3,
                                      &tmpulongest);
	  /* This syscall affects a char-size memory.  */
          if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest, 1))
            return -1;
        }
      else if (tmpulongest == tdep->ioctl_TIOCGSERIAL)
        {
          regcache_raw_read_unsigned (regcache, tdep->arg3,
                                      &tmpulongest);
          if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					     tdep->size_serial_struct))
            return -1;
        }
      else if (tmpulongest == tdep->ioctl_TCGETS2)
        {
          regcache_raw_read_unsigned (regcache, tdep->arg3,
                                      &tmpulongest);
          if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					     tdep->size_termios2))
            return -1;
        }
      else if (tmpulongest == tdep->ioctl_FIOQSIZE)
        {
          regcache_raw_read_unsigned (regcache, tdep->arg3,
                                      &tmpulongest);
          if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					     tdep->size_loff_t))
            return -1;
        }
      else if (tmpulongest == tdep->ioctl_TIOCGICOUNT)
        {
          regcache_raw_read_unsigned (regcache, tdep->arg3,
                                      &tmpulongest);
          if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					     tdep->size_serial_icounter_struct))
            return -1;
        }
      else if (tmpulongest == tdep->ioctl_TIOCGHAYESESP)
        {
          regcache_raw_read_unsigned (regcache, tdep->arg3,
                                      &tmpulongest);
          if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					     tdep->size_hayes_esp_config))
            return -1;
        }
      else if (tmpulongest == tdep->ioctl_TIOCSERGSTRUCT)
        {
          printf_unfiltered (_("Process record and replay target doesn't "
                               "support ioctl request TIOCSERGSTRUCT\n"));
          return 1;
        }
      else
        {
          printf_unfiltered (_("Process record and replay target doesn't "
                               "support ioctl request 0x%s.\n"),
                             OUTPUT_REG (tmpulongest, tdep->arg2));
          return 1;
        }
      break;

    case gdb_sys_fcntl:
      /* XXX */
      regcache_raw_read_unsigned (regcache, tdep->arg2, &tmpulongest);
    sys_fcntl:
      if (tmpulongest == tdep->fcntl_F_GETLK)
        {
          regcache_raw_read_unsigned (regcache, tdep->arg3,
                                      &tmpulongest);
          if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					     tdep->size_flock))
            return -1;
        }
      break;

    case gdb_sys_ni_syscall56:
    case gdb_sys_setpgid:
    case gdb_sys_ni_syscall58:
      break;

    case gdb_sys_olduname:
      regcache_raw_read_unsigned (regcache, tdep->arg1, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_oldold_utsname))
        return -1;
      break;

    case gdb_sys_umask:
    case gdb_sys_chroot:
      break;

    case gdb_sys_ustat:
      regcache_raw_read_unsigned (regcache, tdep->arg2, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_ustat))
        return -1;
      break;

    case gdb_sys_dup2:
    case gdb_sys_getppid:
    case gdb_sys_getpgrp:
    case gdb_sys_setsid:
      break;

    case gdb_sys_sigaction:
      regcache_raw_read_unsigned (regcache, tdep->arg3, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_old_sigaction))
        return -1;
      break;

    case gdb_sys_sgetmask:
    case gdb_sys_ssetmask:
    case gdb_sys_setreuid16:
    case gdb_sys_setregid16:
    case gdb_sys_sigsuspend:
      break;

    case gdb_sys_sigpending:
      regcache_raw_read_unsigned (regcache, tdep->arg1, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_old_sigset_t))
        return -1;
      break;

    case gdb_sys_sethostname:
    case gdb_sys_setrlimit:
      break;

    case gdb_sys_old_getrlimit:
      regcache_raw_read_unsigned (regcache, tdep->arg2, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_rlimit))
        return -1;
      break;

    case gdb_sys_getrusage:
      regcache_raw_read_unsigned (regcache, tdep->arg2, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_rusage))
        return -1;
      break;

    case gdb_sys_gettimeofday:
      regcache_raw_read_unsigned (regcache, tdep->arg1, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_timeval))
        return -1;
      regcache_raw_read_unsigned (regcache, tdep->arg2, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_timezone))
        return -1;
      break;

    case gdb_sys_settimeofday:
      break;

    case gdb_sys_getgroups16:
      regcache_raw_read_unsigned (regcache, tdep->arg2, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_old_gid_t))
        return -1;
      break;

    case gdb_sys_setgroups16:
      regcache_raw_read_unsigned (regcache, tdep->arg2, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_old_gid_t))
        return -1;
      break;

    case gdb_old_select:
      {
        struct sel_arg_struct
        {
          CORE_ADDR n;
          CORE_ADDR inp;
          CORE_ADDR outp;
          CORE_ADDR exp;
          CORE_ADDR tvp;
        } sel;

        regcache_raw_read_unsigned (regcache, tdep->arg1,
                                    &tmpulongest);
        if (tmpulongest)
          {
            if (target_read_memory (tmpulongest, (gdb_byte *) &sel,
                                    sizeof(sel)))
              {
                if (record_debug)
                  fprintf_unfiltered (gdb_stdlog,
                                      "Process record: error reading memory "
                                      "at addr = 0x%s len = %lu.\n",
                                      OUTPUT_REG (tmpulongest, tdep->arg1),
                                      (unsigned long) sizeof (sel));
                return -1;
              }
            if (record_full_arch_list_add_mem (sel.inp, tdep->size_fd_set))
              return -1;
            if (record_full_arch_list_add_mem (sel.outp, tdep->size_fd_set))
              return -1;
            if (record_full_arch_list_add_mem (sel.exp, tdep->size_fd_set))
              return -1;
            if (record_full_arch_list_add_mem (sel.tvp, tdep->size_timeval))
              return -1;
          }
      }
      break;

    case gdb_sys_symlink:
      break;

    case gdb_sys_readlink:
      {
        ULONGEST len;

        regcache_raw_read_unsigned (regcache, tdep->arg2,
                                    &tmpulongest);
        regcache_raw_read_unsigned (regcache, tdep->arg3, &len);
        if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest, (int) len))
          return -1;
      }
      break;

    case gdb_sys_uselib:
    case gdb_sys_swapon:
      break;

    case gdb_sys_reboot:
      {
        int q;

        target_terminal_ours ();
        q = yquery (_("The next instruction is syscall reboot.  "
		      "It will restart the computer.  "
		      "Do you want to stop the program?"));
        target_terminal_inferior ();
        if (q)
          return 1;
      }
      break;

    case gdb_old_readdir:
      regcache_raw_read_unsigned (regcache, tdep->arg2, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_dirent))
        return -1;
      break;

    case gdb_old_mmap:
      break;

    case gdb_sys_munmap:
      {
        ULONGEST len;

        regcache_raw_read_unsigned (regcache, tdep->arg1,
                                    &tmpulongest);
        regcache_raw_read_unsigned (regcache, tdep->arg2, &len);
        if (record_full_memory_query)
          {
	    int q;

            target_terminal_ours ();
            q = yquery (_("\
The next instruction is syscall munmap.\n\
It will free the memory addr = 0x%s len = %u.\n\
It will make record target cannot record some memory change.\n\
Do you want to stop the program?"),
                        OUTPUT_REG (tmpulongest, tdep->arg1), (int) len);
            target_terminal_inferior ();
            if (q)
              return 1;
          }
      }
      break;

    case gdb_sys_truncate:
    case gdb_sys_ftruncate:
    case gdb_sys_fchmod:
    case gdb_sys_fchown16:
    case gdb_sys_getpriority:
    case gdb_sys_setpriority:
    case gdb_sys_ni_syscall98:
      break;

    case gdb_sys_statfs:
    case gdb_sys_fstatfs:
      regcache_raw_read_unsigned (regcache, tdep->arg2, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_statfs))
        return -1;
      break;

    case gdb_sys_ioperm:
      break;

    case gdb_sys_socket:
    case gdb_sys_sendto:
    case gdb_sys_sendmsg:
    case gdb_sys_shutdown:
    case gdb_sys_bind:
    case gdb_sys_connect:
    case gdb_sys_listen:
    case gdb_sys_setsockopt:
      break;

    case gdb_sys_accept:
    case gdb_sys_getsockname:
    case gdb_sys_getpeername:
      {
        ULONGEST len;

        regcache_raw_read_unsigned (regcache, tdep->arg2, &tmpulongest);
        regcache_raw_read_unsigned (regcache, tdep->arg3, &len);
        if (record_linux_sockaddr (regcache, tdep, tmpulongest, len))
          return -1;
      }
      break;

    case gdb_sys_recvfrom:
      {
        ULONGEST len;

        regcache_raw_read_unsigned (regcache, tdep->arg4, &tmpulongest);
        regcache_raw_read_unsigned (regcache, tdep->arg5, &len);
        if (record_linux_sockaddr (regcache, tdep, tmpulongest, len))
          return -1;
      }
      break;

    case gdb_sys_recv:
      {
        ULONGEST size;

        regcache_raw_read_unsigned (regcache, tdep->arg2, &tmpulongest);
        regcache_raw_read_unsigned (regcache, tdep->arg3, &size);
        if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					   (int) size))
          return -1;
      }
      break;

    case gdb_sys_recvmsg:
      regcache_raw_read_unsigned (regcache, tdep->arg2, &tmpulongest);
      if (record_linux_msghdr (regcache, tdep, tmpulongest))
        return -1;
      break;

    case gdb_sys_socketpair:
      regcache_raw_read_unsigned (regcache, tdep->arg4, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_int))
        return -1;
      break;

    case gdb_sys_getsockopt:
      regcache_raw_read_unsigned (regcache, tdep->arg5, &tmpulongest);
      if (tmpulongest)
        {
          ULONGEST optvalp;
          gdb_byte *optlenp = alloca (tdep->size_int);

          if (target_read_memory ((CORE_ADDR) tmpulongest, optlenp,
                                  tdep->size_int))
            {
              if (record_debug)
                fprintf_unfiltered (gdb_stdlog,
                                    "Process record: error reading "
                                    "memory at addr = 0x%s "
                                    "len = %d.\n",
                                    OUTPUT_REG (tmpulongest, tdep->arg5),
                                    tdep->size_int);
              return -1;
            }
          regcache_raw_read_unsigned (regcache, tdep->arg4, &optvalp);
          tmpint = (int) extract_signed_integer (optlenp, tdep->size_int,
                                                 byte_order);
          if (record_full_arch_list_add_mem ((CORE_ADDR) optvalp, tmpint))
            return -1;
          if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					     tdep->size_int))
            return -1;
        }
      break;

    case gdb_sys_socketcall:
      regcache_raw_read_unsigned (regcache, tdep->arg1, &tmpulongest);
      switch (tmpulongest)
        {
        case RECORD_SYS_SOCKET:
        case RECORD_SYS_BIND:
        case RECORD_SYS_CONNECT:
        case RECORD_SYS_LISTEN:
          break;
        case RECORD_SYS_ACCEPT:
        case RECORD_SYS_GETSOCKNAME:
        case RECORD_SYS_GETPEERNAME:
          {
            regcache_raw_read_unsigned (regcache, tdep->arg2,
                                        &tmpulongest);
            if (tmpulongest)
              {
                gdb_byte *a = alloca (tdep->size_ulong * 2);
                ULONGEST len;

                tmpulongest += tdep->size_ulong;
                if (target_read_memory ((CORE_ADDR) tmpulongest, a,
                                        tdep->size_ulong * 2))
                  {
                    if (record_debug)
                      fprintf_unfiltered (gdb_stdlog,
                                          "Process record: error reading "
                                          "memory at addr = 0x%s len = %d.\n",
                                          OUTPUT_REG (tmpulongest, tdep->arg2),
                                          tdep->size_ulong * 2);
                    return -1;
                  }
                tmpulongest = extract_unsigned_integer (a,
                                                        tdep->size_ulong,
                                                        byte_order);
                len = extract_unsigned_integer (a + tdep->size_ulong,
                                                tdep->size_ulong, byte_order);
                if (record_linux_sockaddr (regcache, tdep, tmpulongest, len))
                  return -1;
              }
          }
          break;

        case RECORD_SYS_SOCKETPAIR:
          {
            gdb_byte *a = alloca (tdep->size_ulong);

            regcache_raw_read_unsigned (regcache, tdep->arg2,
                                        &tmpulongest);
            if (tmpulongest)
              {
                tmpulongest += tdep->size_ulong * 3;
                if (target_read_memory ((CORE_ADDR) tmpulongest, a,
                                        tdep->size_ulong))
                  {
                    if (record_debug)
                      fprintf_unfiltered (gdb_stdlog,
                                          "Process record: error reading "
                                          "memory at addr = 0x%s len = %d.\n",
                                          OUTPUT_REG (tmpulongest, tdep->arg2),
                                          tdep->size_ulong);
                    return -1;
                  }
                tmpaddr
                  = (CORE_ADDR) extract_unsigned_integer (a, tdep->size_ulong,
                                                          byte_order);
                if (record_full_arch_list_add_mem (tmpaddr, tdep->size_int))
                  return -1;
              }
          }
          break;
        case RECORD_SYS_SEND:
        case RECORD_SYS_SENDTO:
          break;
        case RECORD_SYS_RECVFROM:
          regcache_raw_read_unsigned (regcache, tdep->arg2,
                                      &tmpulongest);
          if (tmpulongest)
            {
              gdb_byte *a = alloca (tdep->size_ulong * 2);
              ULONGEST len;

              tmpulongest += tdep->size_ulong * 4;
              if (target_read_memory ((CORE_ADDR) tmpulongest, a,
                                      tdep->size_ulong * 2))
                {
                  if (record_debug)
                    fprintf_unfiltered (gdb_stdlog,
                                        "Process record: error reading "
                                        "memory at addr = 0x%s len = %d.\n",
                                        OUTPUT_REG (tmpulongest, tdep->arg2),
                                        tdep->size_ulong * 2);
                  return -1;
                }
              tmpulongest = extract_unsigned_integer (a, tdep->size_ulong,
                                                      byte_order);
              len = extract_unsigned_integer (a + tdep->size_ulong,
                                              tdep->size_ulong, byte_order);
              if (record_linux_sockaddr (regcache, tdep, tmpulongest, len))
                return -1;
            }
        case RECORD_SYS_RECV:
          regcache_raw_read_unsigned (regcache, tdep->arg2,
                                      &tmpulongest);
          if (tmpulongest)
            {
              gdb_byte *a = alloca (tdep->size_ulong * 2);

              tmpulongest += tdep->size_ulong;
              if (target_read_memory ((CORE_ADDR) tmpulongest, a,
                                      tdep->size_ulong))
                {
                  if (record_debug)
                    fprintf_unfiltered (gdb_stdlog,
                                        "Process record: error reading "
                                        "memory at addr = 0x%s len = %d.\n",
                                        OUTPUT_REG (tmpulongest, tdep->arg2),
                                        tdep->size_ulong);
                    return -1;
                }
              tmpulongest = extract_unsigned_integer (a, tdep->size_ulong,
                                                      byte_order);
              if (tmpulongest)
                {
                  a += tdep->size_ulong;
                  tmpint = (int) extract_unsigned_integer (a, tdep->size_ulong,
                                                           byte_order);
                  if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
						     tmpint))
                    return -1;
                }
            }
          break;
        case RECORD_SYS_SHUTDOWN:
        case RECORD_SYS_SETSOCKOPT:
          break;
        case RECORD_SYS_GETSOCKOPT:
          {
            gdb_byte *a = alloca (tdep->size_ulong * 2);
            gdb_byte *av = alloca (tdep->size_int);

            regcache_raw_read_unsigned (regcache, tdep->arg2,
                                        &tmpulongest);
            if (tmpulongest)
              {
                tmpulongest += tdep->size_ulong * 3;
                if (target_read_memory ((CORE_ADDR) tmpulongest, a,
                                        tdep->size_ulong * 2))
                  {
                    if (record_debug)
                      fprintf_unfiltered (gdb_stdlog,
                                          "Process record: error reading "
                                          "memory at addr = 0x%s len = %d.\n",
                                          OUTPUT_REG (tmpulongest, tdep->arg2),
                                          tdep->size_ulong * 2);
                    return -1;
                  }
                tmpulongest = extract_unsigned_integer (a + tdep->size_ulong,
                                                        tdep->size_ulong,
                                                        byte_order);
                if (tmpulongest)
                  {
                    if (target_read_memory ((CORE_ADDR) tmpulongest, av,
                                            tdep->size_int))
                      {
                        if (record_debug)
                          fprintf_unfiltered (gdb_stdlog,
                                              "Process record: error reading "
                                              "memory at addr = 0x%s "
                                              "len = %d.\n",
                                              phex_nz (tmpulongest,
                                                       tdep->size_ulong),
                                              tdep->size_int);
                        return -1;
                      }
                    tmpaddr
                      = (CORE_ADDR) extract_unsigned_integer (a,
                                                              tdep->size_ulong,
                                                              byte_order);
                    tmpint = (int) extract_unsigned_integer (av,
                                                             tdep->size_int,
                                                             byte_order);
                    if (record_full_arch_list_add_mem (tmpaddr, tmpint))
                      return -1;
                    a += tdep->size_ulong;
                    tmpaddr
                      = (CORE_ADDR) extract_unsigned_integer (a,
                                                              tdep->size_ulong,
                                                              byte_order);
                    if (record_full_arch_list_add_mem (tmpaddr,
						       tdep->size_int))
                      return -1;
                  }
              }
          }
          break;
        case RECORD_SYS_SENDMSG:
          break;
        case RECORD_SYS_RECVMSG:
          {
            gdb_byte *a = alloca (tdep->size_ulong);

            regcache_raw_read_unsigned (regcache, tdep->arg2,
                                        &tmpulongest);
            if (tmpulongest)
              {
                tmpulongest += tdep->size_ulong;
                if (target_read_memory ((CORE_ADDR) tmpulongest, a,
                                        tdep->size_ulong))
                  {
                    if (record_debug)
                      fprintf_unfiltered (gdb_stdlog,
                                          "Process record: error reading "
                                          "memory at addr = 0x%s len = %d.\n",
                                          OUTPUT_REG (tmpulongest, tdep->arg2),
                                          tdep->size_ulong);
                    return -1;
                  }
                tmpulongest = extract_unsigned_integer (a, tdep->size_ulong,
                                                        byte_order);
                if (record_linux_msghdr (regcache, tdep, tmpulongest))
                  return -1;
              }
          }
          break;
        default:
          printf_unfiltered (_("Process record and replay target "
                               "doesn't support socketcall call 0x%s\n"),
                             OUTPUT_REG (tmpulongest, tdep->arg1));
          return -1;
          break;
        }
      break;

    case gdb_sys_syslog:
      break;

    case gdb_sys_setitimer:
      regcache_raw_read_unsigned (regcache, tdep->arg3, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_itimerval))
        return -1;
      break;

    case gdb_sys_getitimer:
      regcache_raw_read_unsigned (regcache, tdep->arg2, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_itimerval))
        return -1;
      break;

    case gdb_sys_newstat:
    case gdb_sys_newlstat:
    case gdb_sys_newfstat:
    case gdb_sys_newfstatat:
      regcache_raw_read_unsigned (regcache, tdep->arg2, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_stat))
        return -1;
      break;

    case gdb_sys_uname:
      regcache_raw_read_unsigned (regcache, tdep->arg1, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_old_utsname))
        return -1;
      break;

    case gdb_sys_iopl:
    case gdb_sys_vhangup:
    case gdb_sys_ni_syscall112:
    case gdb_sys_vm86old:
      break;

    case gdb_sys_wait4:
      regcache_raw_read_unsigned (regcache, tdep->arg2, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_int))
        return -1;
      regcache_raw_read_unsigned (regcache, tdep->arg4, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_rusage))
        return -1;
      break;

    case gdb_sys_swapoff:
      break;

    case gdb_sys_sysinfo:
      regcache_raw_read_unsigned (regcache, tdep->arg1, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_sysinfo))
        return -1;
      break;

    case gdb_sys_shmget:
    case gdb_sys_semget:
    case gdb_sys_semop:
    case gdb_sys_msgget:
      /* XXX maybe need do some record works with sys_shmdt.  */
    case gdb_sys_shmdt:
    case gdb_sys_msgsnd:
    case gdb_sys_semtimedop:
      break;

    case gdb_sys_shmat:
      regcache_raw_read_unsigned (regcache, tdep->arg3, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_ulong))
        return -1;
      break;

    case gdb_sys_shmctl:
      regcache_raw_read_unsigned (regcache, tdep->arg3, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_shmid_ds))
        return -1;
      break;

      /* XXX sys_semctl 525 still not supported.  */
      /* sys_semctl */

    case gdb_sys_msgrcv:
      {
        ULONGEST msgp;
        LONGEST l;

        regcache_raw_read_signed (regcache, tdep->arg3, &l);
        regcache_raw_read_unsigned (regcache, tdep->arg2, &msgp);
        tmpint = l + tdep->size_long;
        if (record_full_arch_list_add_mem ((CORE_ADDR) msgp, tmpint))
          return -1;
      }
      break;

    case gdb_sys_msgctl:
      regcache_raw_read_unsigned (regcache, tdep->arg3, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_msqid_ds))
        return -1;
      break;

    case gdb_sys_ipc:
      regcache_raw_read_unsigned (regcache, tdep->arg1, &tmpulongest);
      tmpulongest &= 0xffff;
      switch (tmpulongest)
        {
        case RECORD_SEMOP:
        case RECORD_SEMGET:
        case RECORD_SEMTIMEDOP:
        case RECORD_MSGSND:
        case RECORD_MSGGET:
	  /* XXX maybe need do some record works with RECORD_SHMDT.  */
        case RECORD_SHMDT:
        case RECORD_SHMGET:
          break;
        case RECORD_MSGRCV:
          {
            LONGEST second;
            ULONGEST ptr;

            regcache_raw_read_signed (regcache, tdep->arg3, &second);
            regcache_raw_read_unsigned (regcache, tdep->arg5, &ptr);
            tmpint = (int) second + tdep->size_long;
            if (record_full_arch_list_add_mem ((CORE_ADDR) ptr, tmpint))
              return -1;
          }
          break;
        case RECORD_MSGCTL:
          regcache_raw_read_unsigned (regcache, tdep->arg5,
                                      &tmpulongest);
          if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					     tdep->size_msqid_ds))
            return -1;
          break;
        case RECORD_SHMAT:
          regcache_raw_read_unsigned (regcache, tdep->arg4,
                                      &tmpulongest);
          if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					     tdep->size_ulong))
            return -1;
          break;
        case RECORD_SHMCTL:
          regcache_raw_read_unsigned (regcache, tdep->arg5,
                                      &tmpulongest);
          if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					     tdep->size_shmid_ds))
            return -1;
          break;
        default:
	  /* XXX RECORD_SEMCTL still not supported.  */
          printf_unfiltered (_("Process record and replay target doesn't "
                               "support ipc number %s\n"), 
			     pulongest (tmpulongest));
          break;
        }
      break;

    case gdb_sys_fsync:
    case gdb_sys_sigreturn:
    case gdb_sys_clone:
    case gdb_sys_setdomainname:
      break;

    case gdb_sys_newuname:
      regcache_raw_read_unsigned (regcache, tdep->arg1, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_new_utsname))
        return -1;
      break;

    case gdb_sys_modify_ldt:
      regcache_raw_read_unsigned (regcache, tdep->arg1, &tmpulongest);
      if (tmpulongest == 0 || tmpulongest == 2)
        {
          ULONGEST ptr, bytecount;

          regcache_raw_read_unsigned (regcache, tdep->arg2, &ptr);
          regcache_raw_read_unsigned (regcache, tdep->arg3, &bytecount);
          if (record_full_arch_list_add_mem ((CORE_ADDR) ptr, (int) bytecount))
            return -1;
        }
      break;

    case gdb_sys_adjtimex:
      regcache_raw_read_unsigned (regcache, tdep->arg1, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_timex))
        return -1;
      break;

    case gdb_sys_mprotect:
      break;

    case gdb_sys_sigprocmask:
      regcache_raw_read_unsigned (regcache, tdep->arg3, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_old_sigset_t))
        return -1;
      break;

    case gdb_sys_ni_syscall127:
    case gdb_sys_init_module:
    case gdb_sys_delete_module:
    case gdb_sys_ni_syscall130:
      break;

    case gdb_sys_quotactl:
      regcache_raw_read_unsigned (regcache, tdep->arg1, &tmpulongest);
      switch (tmpulongest)
        {
        case RECORD_Q_GETFMT:
          regcache_raw_read_unsigned (regcache, tdep->arg4,
                                      &tmpulongest);
          /* __u32 */
          if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest, 4))
            return -1;
          break;
        case RECORD_Q_GETINFO:
          regcache_raw_read_unsigned (regcache, tdep->arg4,
                                      &tmpulongest);
          if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					     tdep->size_mem_dqinfo))
            return -1;
          break;
        case RECORD_Q_GETQUOTA:
          regcache_raw_read_unsigned (regcache, tdep->arg4,
                                      &tmpulongest);
          if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					     tdep->size_if_dqblk))
            return -1;
          break;
        case RECORD_Q_XGETQSTAT:
        case RECORD_Q_XGETQUOTA:
          regcache_raw_read_unsigned (regcache, tdep->arg4,
                                      &tmpulongest);
          if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					     tdep->size_fs_quota_stat))
            return -1;
          break;
        }
      break;

    case gdb_sys_getpgid:
    case gdb_sys_fchdir:
    case gdb_sys_bdflush:
      break;

    case gdb_sys_sysfs:
      regcache_raw_read_unsigned (regcache, tdep->arg1, &tmpulongest);
      if (tmpulongest == 2)
        {
          regcache_raw_read_unsigned (regcache, tdep->arg3,
                                      &tmpulongest);
	  /*XXX the size of memory is not very clear.  */
          if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest, 10))
            return -1;
        }
      break;

    case gdb_sys_personality:
    case gdb_sys_ni_syscall137:
    case gdb_sys_setfsuid16:
    case gdb_sys_setfsgid16:
      break;

    case gdb_sys_llseek:
      regcache_raw_read_unsigned (regcache, tdep->arg4, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_loff_t))
        return -1;
      break;

    case gdb_sys_getdents:
      {
        ULONGEST count;

        regcache_raw_read_unsigned (regcache, tdep->arg2,
                                    &tmpulongest);
        regcache_raw_read_unsigned (regcache, tdep->arg3, &count);
        if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					   tdep->size_dirent * count))
          return -1;
      }
      break;

    case gdb_sys_select:
      regcache_raw_read_unsigned (regcache, tdep->arg2, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_fd_set))
        return -1;
      regcache_raw_read_unsigned (regcache, tdep->arg3, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_fd_set))
        return -1;
      regcache_raw_read_unsigned (regcache, tdep->arg4, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_fd_set))
        return -1;
      regcache_raw_read_unsigned (regcache, tdep->arg5, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_timeval))
        return -1;
      break;

    case gdb_sys_flock:
    case gdb_sys_msync:
      break;

    case gdb_sys_readv:
      {
        ULONGEST vec, vlen;

        regcache_raw_read_unsigned (regcache, tdep->arg2, &vec);
        if (vec)
          {
            gdb_byte *iov = alloca (tdep->size_iovec);

            regcache_raw_read_unsigned (regcache, tdep->arg3, &vlen);
            for (tmpulongest = 0; tmpulongest < vlen; tmpulongest++)
              {
                if (target_read_memory ((CORE_ADDR) vec, iov,
                                        tdep->size_iovec))
                  {
                    if (record_debug)
                      fprintf_unfiltered (gdb_stdlog,
                                          "Process record: error reading "
                                          "memory at addr = 0x%s len = %d.\n",
                                          OUTPUT_REG (vec, tdep->arg2),
                                          tdep->size_iovec);
                    return -1;
                  }
                tmpaddr
                  = (CORE_ADDR) extract_unsigned_integer (iov,
                                                          tdep->size_pointer,
                                                          byte_order);
                tmpint
                  = (int) extract_unsigned_integer (iov + tdep->size_pointer,
                                                    tdep->size_size_t,
                                                    byte_order);
                if (record_full_arch_list_add_mem (tmpaddr, tmpint))
                  return -1;
                vec += tdep->size_iovec;
              }
          }
      }
      break;

    case gdb_sys_writev:
    case gdb_sys_getsid:
    case gdb_sys_fdatasync:
    case gdb_sys_sysctl:
    case gdb_sys_mlock:
    case gdb_sys_munlock:
    case gdb_sys_mlockall:
    case gdb_sys_munlockall:
    case gdb_sys_sched_setparam:
      break;

    case gdb_sys_sched_getparam:
      regcache_raw_read_unsigned (regcache, tdep->arg2, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_int))
        return -1;
      break;

    case gdb_sys_sched_setscheduler:
    case gdb_sys_sched_getscheduler:
    case gdb_sys_sched_yield:
    case gdb_sys_sched_get_priority_max:
    case gdb_sys_sched_get_priority_min:
      break;

    case gdb_sys_sched_rr_get_interval:
    case gdb_sys_nanosleep:
      regcache_raw_read_unsigned (regcache, tdep->arg2, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_timespec))
        return -1;
      break;

    case gdb_sys_mremap:
    case gdb_sys_setresuid16:
      break;

    case gdb_sys_getresuid16:
      regcache_raw_read_unsigned (regcache, tdep->arg1, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_old_uid_t))
        return -1;
      regcache_raw_read_unsigned (regcache, tdep->arg2, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_old_uid_t))
        return -1;
      regcache_raw_read_unsigned (regcache, tdep->arg3, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_old_uid_t))
        return -1;
      break;

    case gdb_sys_vm86:
    case gdb_sys_ni_syscall167:
      break;

    case gdb_sys_poll:
      regcache_raw_read_unsigned (regcache, tdep->arg1, &tmpulongest);
      if (tmpulongest)
        {
          ULONGEST nfds;

          regcache_raw_read_unsigned (regcache, tdep->arg2, &nfds);
          if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					     tdep->size_pollfd * nfds))
            return -1;
        }
      break;

    case gdb_sys_nfsservctl:
      regcache_raw_read_unsigned (regcache, tdep->arg1, &tmpulongest);
      if (tmpulongest == 7 || tmpulongest == 8)
        {
          int rsize;

          if (tmpulongest == 7)
            rsize = tdep->size_NFS_FHSIZE;
          else
            rsize = tdep->size_knfsd_fh;
          regcache_raw_read_unsigned (regcache, tdep->arg3,
                                      &tmpulongest);
          if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest, rsize))
            return -1;
        }
      break;

    case gdb_sys_setresgid16:
      break;

    case gdb_sys_getresgid16:
      regcache_raw_read_unsigned (regcache, tdep->arg1, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_old_gid_t))
        return -1;
      regcache_raw_read_unsigned (regcache, tdep->arg2, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_old_gid_t))
        return -1;
      regcache_raw_read_unsigned (regcache, tdep->arg3, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_old_gid_t))
        return -1;
      break;

    case gdb_sys_prctl:
      regcache_raw_read_unsigned (regcache, tdep->arg1, &tmpulongest);
      switch (tmpulongest)
        {
        case 2:
          regcache_raw_read_unsigned (regcache, tdep->arg2,
                                      &tmpulongest);
          if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					     tdep->size_int))
            return -1;
          break;
        case 16:
          regcache_raw_read_unsigned (regcache, tdep->arg2,
                                      &tmpulongest);
          if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					     tdep->size_TASK_COMM_LEN))
            return -1;
          break;
        }
      break;

    case gdb_sys_rt_sigreturn:
      break;

    case gdb_sys_rt_sigaction:
      regcache_raw_read_unsigned (regcache, tdep->arg3, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_sigaction))
        return -1;
      break;

    case gdb_sys_rt_sigprocmask:
      regcache_raw_read_unsigned (regcache, tdep->arg3, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_sigset_t))
        return -1;
      break;

    case gdb_sys_rt_sigpending:
      regcache_raw_read_unsigned (regcache, tdep->arg1, &tmpulongest);
      if (tmpulongest)
        {
          ULONGEST sigsetsize;

          regcache_raw_read_unsigned (regcache, tdep->arg2,&sigsetsize);
          if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					     (int) sigsetsize))
            return -1;
        }
      break;

    case gdb_sys_rt_sigtimedwait:
      regcache_raw_read_unsigned (regcache, tdep->arg2, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_siginfo_t))
        return -1;
      break;

    case gdb_sys_rt_sigqueueinfo:
    case gdb_sys_rt_sigsuspend:
      break;

    case gdb_sys_pread64:
      regcache_raw_read_unsigned (regcache, tdep->arg2, &tmpulongest);
      if (tmpulongest)
        {
          ULONGEST count;

          regcache_raw_read_unsigned (regcache, tdep->arg3,&count);
          if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					     (int) count))
            return -1;
        }
      break;

    case gdb_sys_pwrite64:
    case gdb_sys_chown16:
      break;

    case gdb_sys_getcwd:
      regcache_raw_read_unsigned (regcache, tdep->arg1, &tmpulongest);
      if (tmpulongest)
        {
          ULONGEST size;

          regcache_raw_read_unsigned (regcache, tdep->arg2, &size);
          if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					     (int) size))
            return -1;
        }
      break;

    case gdb_sys_capget:
      regcache_raw_read_unsigned (regcache, tdep->arg2, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_cap_user_data_t))
        return -1;
      break;

    case gdb_sys_capset:
      break;

    case gdb_sys_sigaltstack:
      regcache_raw_read_unsigned (regcache, tdep->arg2, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_stack_t))
        return -1;
      break;

    case gdb_sys_sendfile:
      regcache_raw_read_unsigned (regcache, tdep->arg3, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_off_t))
        return -1;
      break;

    case gdb_sys_ni_syscall188:
    case gdb_sys_ni_syscall189:
    case gdb_sys_vfork:
      break;

    case gdb_sys_getrlimit:
      regcache_raw_read_unsigned (regcache, tdep->arg2, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_rlimit))
        return -1;
      break;

    case gdb_sys_mmap2:
      break;

    case gdb_sys_truncate64:
    case gdb_sys_ftruncate64:
      break;

    case gdb_sys_stat64:
    case gdb_sys_lstat64:
    case gdb_sys_fstat64:
      regcache_raw_read_unsigned (regcache, tdep->arg2, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_stat64))
        return -1;
      break;

    case gdb_sys_lchown:
    case gdb_sys_getuid:
    case gdb_sys_getgid:
    case gdb_sys_geteuid:
    case gdb_sys_getegid:
    case gdb_sys_setreuid:
    case gdb_sys_setregid:
      break;

    case gdb_sys_getgroups:
      regcache_raw_read_unsigned (regcache, tdep->arg2, &tmpulongest);
      if (tmpulongest)
        {
          ULONGEST gidsetsize;

          regcache_raw_read_unsigned (regcache, tdep->arg1,
                                      &gidsetsize);
          tmpint = tdep->size_gid_t * (int) gidsetsize;
          if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest, tmpint))
            return -1;
        }
      break;

    case gdb_sys_setgroups:
    case gdb_sys_fchown:
    case gdb_sys_setresuid:
      break;

    case gdb_sys_getresuid:
      regcache_raw_read_unsigned (regcache, tdep->arg1, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_uid_t))
        return -1;
      regcache_raw_read_unsigned (regcache, tdep->arg2, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_uid_t))
        return -1;
      regcache_raw_read_unsigned (regcache, tdep->arg3, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_uid_t))
        return -1;
      break;

    case gdb_sys_setresgid:
      break;

    case gdb_sys_getresgid:
      regcache_raw_read_unsigned (regcache, tdep->arg1, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_gid_t))
        return -1;
      regcache_raw_read_unsigned (regcache, tdep->arg2, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_gid_t))
        return -1;
      regcache_raw_read_unsigned (regcache, tdep->arg3, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_gid_t))
        return -1;
      break;

    case gdb_sys_chown:
    case gdb_sys_setuid:
    case gdb_sys_setgid:
    case gdb_sys_setfsuid:
    case gdb_sys_setfsgid:
    case gdb_sys_pivot_root:
      break;

    case gdb_sys_mincore:
      regcache_raw_read_unsigned (regcache, tdep->arg3, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_PAGE_SIZE))
        return -1;
      break;

    case gdb_sys_madvise:
      break;

    case gdb_sys_getdents64:
      {
        ULONGEST count;

        regcache_raw_read_unsigned (regcache, tdep->arg2,
                                    &tmpulongest);
        regcache_raw_read_unsigned (regcache, tdep->arg3, &count);
        if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					   tdep->size_dirent64 * count))
          return -1;
      }
      break;

    case gdb_sys_fcntl64:
      regcache_raw_read_unsigned (regcache, tdep->arg2, &tmpulongest);
      if (tmpulongest == tdep->fcntl_F_GETLK64)
        {
          regcache_raw_read_unsigned (regcache, tdep->arg3,
                                      &tmpulongest);
          if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					     tdep->size_flock64))
            return -1;
        }
      else if (tmpulongest != tdep->fcntl_F_SETLK64
               && tmpulongest != tdep->fcntl_F_SETLKW64)
        {
          goto sys_fcntl;
        }
      break;

    case gdb_sys_ni_syscall222:
    case gdb_sys_ni_syscall223:
    case gdb_sys_gettid:
    case gdb_sys_readahead:
    case gdb_sys_setxattr:
    case gdb_sys_lsetxattr:
    case gdb_sys_fsetxattr:
      break;

    case gdb_sys_getxattr:
    case gdb_sys_lgetxattr:
    case gdb_sys_fgetxattr:
      regcache_raw_read_unsigned (regcache, tdep->arg3, &tmpulongest);
      if (tmpulongest)
        {
          ULONGEST size;

          regcache_raw_read_unsigned (regcache, tdep->arg4, &size);
          if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					     (int) size))
            return -1;
        }
      break;

    case gdb_sys_listxattr:
    case gdb_sys_llistxattr:
    case gdb_sys_flistxattr:
      regcache_raw_read_unsigned (regcache, tdep->arg2, &tmpulongest);
      if (tmpulongest)
        {
          ULONGEST size;

          regcache_raw_read_unsigned (regcache, tdep->arg3, &size);
          if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					     (int) size))
            return -1;
        }
      break;

    case gdb_sys_removexattr:
    case gdb_sys_lremovexattr:
    case gdb_sys_fremovexattr:
    case gdb_sys_tkill:
      break;

    case gdb_sys_sendfile64:
      regcache_raw_read_unsigned (regcache, tdep->arg3, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_loff_t))
        return -1;
      break;

    case gdb_sys_futex:
    case gdb_sys_sched_setaffinity:
      break;

    case gdb_sys_sched_getaffinity:
      regcache_raw_read_unsigned (regcache, tdep->arg3, &tmpulongest);
      if (tmpulongest)
        {
          ULONGEST len;

          regcache_raw_read_unsigned (regcache, tdep->arg2, &len);
          if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					     (int) len))
            return -1;
        }
      break;

    case gdb_sys_set_thread_area:
      regcache_raw_read_unsigned (regcache, tdep->arg1, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_int))
        return -1;
      break;

    case gdb_sys_get_thread_area:
      regcache_raw_read_unsigned (regcache, tdep->arg1, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_user_desc))
        return -1;
      break;

    case gdb_sys_io_setup:
      regcache_raw_read_unsigned (regcache, tdep->arg2, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_long))
        return -1;
      break;

    case gdb_sys_io_destroy:
      break;

    case gdb_sys_io_getevents:
      regcache_raw_read_unsigned (regcache, tdep->arg4, &tmpulongest);
      if (tmpulongest)
        {
          ULONGEST nr;

          regcache_raw_read_unsigned (regcache, tdep->arg3, &nr);
          if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					     nr * tdep->size_io_event))
            return -1;
        }
      break;

    case gdb_sys_io_submit:
      regcache_raw_read_unsigned (regcache, tdep->arg3, &tmpulongest);
      if (tmpulongest)
        {
          ULONGEST nr, i;
          gdb_byte *iocbp;

          regcache_raw_read_unsigned (regcache, tdep->arg2, &nr);
          iocbp = alloca (nr * tdep->size_pointer);
          if (target_read_memory ((CORE_ADDR) tmpulongest, iocbp,
                                  nr * tdep->size_pointer))
            {
              if (record_debug)
                fprintf_unfiltered (gdb_stdlog,
                                    "Process record: error reading memory "
                                    "at addr = 0x%s len = %u.\n",
                                    OUTPUT_REG (tmpulongest, tdep->arg2),
                                    (int) (nr * tdep->size_pointer));
              return -1;
            }
          for (i = 0; i < nr; i++)
            {
              tmpaddr
                = (CORE_ADDR) extract_unsigned_integer (iocbp,
                                                        tdep->size_pointer,
                                                        byte_order);
              if (record_full_arch_list_add_mem (tmpaddr, tdep->size_iocb))
                return -1;
              iocbp += tdep->size_pointer;
            }
        }
      break;

    case gdb_sys_io_cancel:
      regcache_raw_read_unsigned (regcache, tdep->arg3, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_io_event))
        return -1;
      break;

    case gdb_sys_fadvise64:
    case gdb_sys_ni_syscall251:
      break;

    case gdb_sys_exit_group:
      {
        int q;

        target_terminal_ours ();
        q = yquery (_("The next instruction is syscall exit_group.  "
                      "It will make the program exit.  "
                      "Do you want to stop the program?"));
        target_terminal_inferior ();
        if (q)
          return 1;
      }
      break;

    case gdb_sys_lookup_dcookie:
      regcache_raw_read_unsigned (regcache, tdep->arg2, &tmpulongest);
      if (tmpulongest)
        {
          ULONGEST len;

          regcache_raw_read_unsigned (regcache, tdep->arg3, &len);
          if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					     (int) len))
            return -1;
        }
      break;

    case gdb_sys_epoll_create:
    case gdb_sys_epoll_ctl:
      break;

    case gdb_sys_epoll_wait:
      regcache_raw_read_unsigned (regcache, tdep->arg2, &tmpulongest);
      if (tmpulongest)
        {
          ULONGEST maxevents;

          regcache_raw_read_unsigned (regcache, tdep->arg3, &maxevents);
          if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					     (maxevents
					      * tdep->size_epoll_event)))
            return -1;
        }
      break;

    case gdb_sys_remap_file_pages:
    case gdb_sys_set_tid_address:
      break;

    case gdb_sys_timer_create:
      regcache_raw_read_unsigned (regcache, tdep->arg3, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_int))
        return -1;
      break;

    case gdb_sys_timer_settime:
      regcache_raw_read_unsigned (regcache, tdep->arg4, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_itimerspec))
        return -1;
      break;

    case gdb_sys_timer_gettime:
      regcache_raw_read_unsigned (regcache, tdep->arg2, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_itimerspec))
        return -1;
      break;

    case gdb_sys_timer_getoverrun:
    case gdb_sys_timer_delete:
    case gdb_sys_clock_settime:
      break;

    case gdb_sys_clock_gettime:
      regcache_raw_read_unsigned (regcache, tdep->arg2, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_timespec))
        return -1;
      break;

    case gdb_sys_clock_getres:
      regcache_raw_read_unsigned (regcache, tdep->arg2, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_timespec))
        return -1;
      break;

    case gdb_sys_clock_nanosleep:
      regcache_raw_read_unsigned (regcache, tdep->arg4, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_timespec))
        return -1;
      break;

    case gdb_sys_statfs64:
    case gdb_sys_fstatfs64:
      regcache_raw_read_unsigned (regcache, tdep->arg3, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_statfs64))
        return -1;
      break;

    case gdb_sys_tgkill:
    case gdb_sys_utimes:
    case gdb_sys_fadvise64_64:
    case gdb_sys_ni_syscall273:
    case gdb_sys_mbind:
      break;

    case gdb_sys_get_mempolicy:
      regcache_raw_read_unsigned (regcache, tdep->arg1, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_int))
        return -1;
      regcache_raw_read_unsigned (regcache, tdep->arg2, &tmpulongest);
      if (tmpulongest)
        {
          ULONGEST maxnode;

          regcache_raw_read_unsigned (regcache, tdep->arg3, &maxnode);
          if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					     maxnode * tdep->size_long))
            return -1;
        }
      break;

    case gdb_sys_set_mempolicy:
    case gdb_sys_mq_open:
    case gdb_sys_mq_unlink:
    case gdb_sys_mq_timedsend:
      break;

    case gdb_sys_mq_timedreceive:
      regcache_raw_read_unsigned (regcache, tdep->arg2, &tmpulongest);
      if (tmpulongest)
        {
          ULONGEST msg_len;

          regcache_raw_read_unsigned (regcache, tdep->arg3, &msg_len);
          if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					     (int) msg_len))
            return -1;
        }
      regcache_raw_read_unsigned (regcache, tdep->arg4, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_int))
        return -1;
      break;

    case gdb_sys_mq_notify:
      break;

    case gdb_sys_mq_getsetattr:
      regcache_raw_read_unsigned (regcache, tdep->arg3, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_mq_attr))
        return -1;
      break;

    case gdb_sys_kexec_load:
      break;

    case gdb_sys_waitid:
      regcache_raw_read_unsigned (regcache, tdep->arg3, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_siginfo))
        return -1;
      regcache_raw_read_unsigned (regcache, tdep->arg5, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_rusage))
        return -1;
      break;

    case gdb_sys_ni_syscall285:
    case gdb_sys_add_key:
    case gdb_sys_request_key:
      break;

    case gdb_sys_keyctl:
      regcache_raw_read_unsigned (regcache, tdep->arg1, &tmpulongest);
      if (tmpulongest == 6 || tmpulongest == 11)
        {
          regcache_raw_read_unsigned (regcache, tdep->arg3,
                                      &tmpulongest);
          if (tmpulongest)
            {
              ULONGEST buflen;

              regcache_raw_read_unsigned (regcache, tdep->arg4, &buflen);
              if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
						 (int) buflen))
                return -1;
            }
        }
      break;

    case gdb_sys_ioprio_set:
    case gdb_sys_ioprio_get:
    case gdb_sys_inotify_init:
    case gdb_sys_inotify_add_watch:
    case gdb_sys_inotify_rm_watch:
    case gdb_sys_migrate_pages:
    case gdb_sys_openat:
    case gdb_sys_mkdirat:
    case gdb_sys_mknodat:
    case gdb_sys_fchownat:
    case gdb_sys_futimesat:
      break;

    case gdb_sys_fstatat64:
      regcache_raw_read_unsigned (regcache, tdep->arg3, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_stat64))
        return -1;
      break;

    case gdb_sys_unlinkat:
    case gdb_sys_renameat:
    case gdb_sys_linkat:
    case gdb_sys_symlinkat:
      break;

    case gdb_sys_readlinkat:
      regcache_raw_read_unsigned (regcache, tdep->arg3, &tmpulongest);
      if (tmpulongest)
        {
          ULONGEST bufsiz;

          regcache_raw_read_unsigned (regcache, tdep->arg4, &bufsiz);
          if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					     (int) bufsiz))
            return -1;
        }
      break;

    case gdb_sys_fchmodat:
    case gdb_sys_faccessat:
      break;

    case gdb_sys_pselect6:
      regcache_raw_read_unsigned (regcache, tdep->arg2, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_fd_set))
        return -1;
      regcache_raw_read_unsigned (regcache, tdep->arg3, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_fd_set))
        return -1;
      regcache_raw_read_unsigned (regcache, tdep->arg4, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_fd_set))
        return -1;
      regcache_raw_read_unsigned (regcache, tdep->arg5, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_timespec))
        return -1;
      break;

    case gdb_sys_ppoll:
      regcache_raw_read_unsigned (regcache, tdep->arg1, &tmpulongest);
      if (tmpulongest)
        {
          ULONGEST nfds;

          regcache_raw_read_unsigned (regcache, tdep->arg2, &nfds);
          if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					     tdep->size_pollfd * nfds))
            return -1;
        }
      regcache_raw_read_unsigned (regcache, tdep->arg3, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_timespec))
        return -1;
      break;

    case gdb_sys_unshare:
    case gdb_sys_set_robust_list:
      break;

    case gdb_sys_get_robust_list:
      regcache_raw_read_unsigned (regcache, tdep->arg2, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_int))
        return -1;
      regcache_raw_read_unsigned (regcache, tdep->arg3, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_int))
        return -1;
      break;

    case gdb_sys_splice:
      regcache_raw_read_unsigned (regcache, tdep->arg2, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_loff_t))
        return -1;
      regcache_raw_read_unsigned (regcache, tdep->arg4, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_loff_t))
        return -1;
      break;

    case gdb_sys_sync_file_range:
    case gdb_sys_tee:
    case gdb_sys_vmsplice:
      break;

    case gdb_sys_move_pages:
      regcache_raw_read_unsigned (regcache, tdep->arg5, &tmpulongest);
      if (tmpulongest)
        {
          ULONGEST nr_pages;

          regcache_raw_read_unsigned (regcache, tdep->arg2, &nr_pages);
          if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					     nr_pages * tdep->size_int))
            return -1;
        }
      break;

    case gdb_sys_getcpu:
      regcache_raw_read_unsigned (regcache, tdep->arg1, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_int))
        return -1;
      regcache_raw_read_unsigned (regcache, tdep->arg2, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_int))
        return -1;
      regcache_raw_read_unsigned (regcache, tdep->arg3, &tmpulongest);
      if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest,
					 tdep->size_ulong * 2))
        return -1;
      break;

    case gdb_sys_epoll_pwait:
      regcache_raw_read_unsigned (regcache, tdep->arg2, &tmpulongest);
      if (tmpulongest)
        {
          ULONGEST maxevents;

          regcache_raw_read_unsigned (regcache, tdep->arg3, &maxevents);
          tmpint = (int) maxevents * tdep->size_epoll_event;
          if (record_full_arch_list_add_mem ((CORE_ADDR) tmpulongest, tmpint))
            return -1;
        }
      break;

    default:
      printf_unfiltered (_("Process record and replay target doesn't "
                           "support syscall number %d\n"), syscall);
      return -1;
      break;
    }

  return 0;
}
@


1.18
log
@Split record.h into record.h and record-full.h.
Split record.c into record.c and record-full.c.

The split leaves the command part in record.c and moves the target part into
record-full.c.

gdb/
	* record.h: Split into this and ...
	* record-full.h: ... this.
	* record.c: Split into this and ...
	* record-full.c: ... this.
	* target.h (target_ops): Add new fields to_info_record,
	to_save_record, to_delete_record, to_record_is_replaying,
	to_goto_record_begin, to_goto_record_end, to_goto_record.
	(target_info_record): New.
	(target_save_record): New.
	(target_supports_delete_record): New.
	(target_delete_record): New.
	(target_record_is_replaying): New.
	(target_goto_record_begin): New.
	(target_goto_record_end): New.
	(target_goto_record): New.
	* target.c (target_info_record): New.
	(target_save_record): New.
	(target_supports_delete_record): New.
	(target_delete_record): New.
	(target_record_is_replaying): New.
	(target_goto_record_begin): New.
	(target_goto_record_end): New.
	(target_goto_record): New.
	* record.h: Declare struct cmd_list_element.
	(record_cmdlist): New declaration.
	(set_record_cmdlist): New declaration.
	(show_record_cmdlist): New declaration.
	(info_record_cmdlist): New declaration.
	(cmd_record_goto): New declaration.
	* record.c: Remove unnecessary includes.
	Include inferior.h.
	(cmd_record_goto): Remove declaration.
	(record_cmdlist): Now extern. Initialize.
	(set_record_cmdlist): Now extern. Initialize.
	(show_record_cmdlist): Now extern. Initialize.
	(info_record_cmdlist): Now extern. Initialize.
	(find_record_target): New.
	(require_record_target): New.
	(cmd_record_start): Update.
	(cmd_record_delete): Remove target-specific code.
	Call target_delete_record.
	(cmd_record_stop): Unpush any record target.
	(set_record_insn_max_num): Move to record-full.c
	(set_record_command): Add comment.
	(show_record_command): Add comment.
	(info_record_command): Update comment.
	Remove target-specific code.
	Call the record target's to_info_record.
	(cmd_record_start): New.
	(cmd_record_goto): Now extern.
	Remove target-specific code.
	Call target_goto_begin,  target_goto_end, or target_goto.
	(_initialize_record): Move record target ops initialization to
	record-full.c.
	Change "record" command help text.
	Move "record restore", "record set", and "record show" commands to
	record-full.c.
	* Makefile.in (SFILES): Add record-full.c.
	(HFILES_NO_SRCDIR): Add record-full.h.
	(COMMON_OBS): Add record-full.o.
	* amd64-linux-tdep.c: Include record-full.h instead of record.h.
	* arm-tdep.c: Include record-full.h.
	* i386-linux-tdep.c: Include record-full.h instead of record.h.
	* i386-tdep.c: Include record-full.h.
	* infrun.c: Include record-full.h.
	* linux-record.c: Include record-full.h.
	* moxie-tdep.c: Include record-full.h.
	* record-full.c: Include record-full.h.
	Change module comment.
	(set_record_full_cmdlist): New.
	(show_record_full_cmdlist): New.
	(record_full_cmdlist): New.
	(record_goto_insn): New declaration.
	(record_save): New declaration.
	(record_check_insn_num): Change query string.
	(record_info): New.
	(record_delete): New.
	(record_is_replaying): New.
	(record_goto_entry): New.
	(record_goto_begin): New.
	(record_goto_end): New.
	(record_goto): New.
	(init_record_ops): Update.
	(init_record_core_ops): Update.
	(cmd_record_save): Rename to record_save. Remove target and arg checks.
	(cmd_record_start): New.
	(set_record_insn_max_num): Moved from record.c
	(set_record_full_command): New.
	(show_record_full_command): New.
	(_initialize_record_full): New.
@
text
@d103 1
a103 1
  if (record_arch_list_add_mem ((CORE_ADDR) len, tdep->size_int))
d121 1
a121 1
  if (record_arch_list_add_mem ((CORE_ADDR) addr, addrlen))
d140 1
a140 1
  if (record_arch_list_add_mem ((CORE_ADDR) addr, tdep->size_msghdr))
d159 5
a163 4
  if (record_arch_list_add_mem ((CORE_ADDR) addr,
                                (int) extract_unsigned_integer (a,
				                                tdep->size_int,
				                                byte_order)))
d197 1
a197 1
          if (record_arch_list_add_mem (tmpaddr, tmpint))
d208 1
a208 1
  if (record_arch_list_add_mem ((CORE_ADDR) addr, tmpint))
d265 1
a265 1
        if (record_arch_list_add_mem ((CORE_ADDR) addr, (int) count))
d290 2
a291 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size__old_kernel_stat))
d312 1
a312 1
          if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest, 4))
d336 2
a337 1
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest, tdep->size_tms))
d409 2
a410 2
          if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                        tdep->size_termios))
d418 2
a419 2
          if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                        tdep->size_pid_t))
d433 2
a434 2
          if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                        tdep->size_int))
d441 2
a442 2
          if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                        tdep->size_winsize))
d450 1
a450 1
          if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest, 1))
d457 2
a458 2
          if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                        tdep->size_serial_struct))
d465 2
a466 2
          if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                        tdep->size_termios2))
d473 2
a474 2
          if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                        tdep->size_loff_t))
d481 2
a482 2
          if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                        tdep->size_serial_icounter_struct))
d489 2
a490 2
          if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                        tdep->size_hayes_esp_config))
d516 2
a517 2
          if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                        tdep->size_flock))
d529 2
a530 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_oldold_utsname))
d540 2
a541 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_ustat))
d553 2
a554 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_old_sigaction))
d567 2
a568 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_old_sigset_t))
d578 2
a579 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_rlimit))
d585 2
a586 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_rusage))
d592 2
a593 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_timeval))
d596 2
a597 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_timezone))
d606 2
a607 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_old_gid_t))
d613 2
a614 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_old_gid_t))
d644 1
a644 1
            if (record_arch_list_add_mem (sel.inp, tdep->size_fd_set))
d646 1
a646 1
            if (record_arch_list_add_mem (sel.outp, tdep->size_fd_set))
d648 1
a648 1
            if (record_arch_list_add_mem (sel.exp, tdep->size_fd_set))
d650 1
a650 1
            if (record_arch_list_add_mem (sel.tvp, tdep->size_timeval))
d666 1
a666 1
        if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest, (int) len))
d691 2
a692 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_dirent))
d706 1
a706 1
        if (record_memory_query)
d736 2
a737 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_statfs))
d784 2
a785 1
        if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest, (int) size))
d798 2
a799 1
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest, tdep->size_int))
d825 1
a825 1
          if (record_arch_list_add_mem ((CORE_ADDR) optvalp, tmpint))
d827 2
a828 2
          if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                        tdep->size_int))
d899 1
a899 1
                if (record_arch_list_add_mem (tmpaddr, tdep->size_int))
d960 2
a961 2
                  if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                                tmpint))
d1015 1
a1015 1
                    if (record_arch_list_add_mem (tmpaddr, tmpint))
d1022 2
a1023 1
                    if (record_arch_list_add_mem (tmpaddr, tdep->size_int))
d1072 2
a1073 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_itimerval))
d1079 2
a1080 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_itimerval))
d1089 2
a1090 1
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest, tdep->size_stat))
d1096 2
a1097 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_old_utsname))
d1109 2
a1110 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_int))
d1113 2
a1114 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_rusage))
d1123 2
a1124 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_sysinfo))
d1140 2
a1141 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_ulong))
d1147 2
a1148 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_shmid_ds))
d1163 1
a1163 1
        if (record_arch_list_add_mem ((CORE_ADDR) msgp, tmpint))
d1170 2
a1171 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_msqid_ds))
d1197 1
a1197 1
            if (record_arch_list_add_mem ((CORE_ADDR) ptr, tmpint))
d1204 2
a1205 2
          if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                        tdep->size_msqid_ds))
d1211 2
a1212 2
          if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                        tdep->size_ulong))
d1218 2
a1219 2
          if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                        tdep->size_shmid_ds))
d1239 2
a1240 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_new_utsname))
d1252 1
a1252 1
          if (record_arch_list_add_mem ((CORE_ADDR) ptr, (int) bytecount))
d1259 2
a1260 1
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest, tdep->size_timex))
d1269 2
a1270 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_old_sigset_t))
d1288 1
a1288 1
          if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest, 4))
d1294 2
a1295 2
          if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                        tdep->size_mem_dqinfo))
d1301 2
a1302 2
          if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                        tdep->size_if_dqblk))
d1309 2
a1310 2
          if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                        tdep->size_fs_quota_stat))
d1328 1
a1328 1
          if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest, 10))
d1341 2
a1342 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_loff_t))
d1353 2
a1354 2
        if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                      tdep->size_dirent * count))
d1361 2
a1362 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_fd_set))
d1365 2
a1366 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_fd_set))
d1369 2
a1370 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_fd_set))
d1373 2
a1374 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_timeval))
d1413 1
a1413 1
                if (record_arch_list_add_mem (tmpaddr, tmpint))
d1434 2
a1435 1
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest, tdep->size_int))
d1449 2
a1450 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_timespec))
d1460 2
a1461 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_old_uid_t))
d1464 2
a1465 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_old_uid_t))
d1468 2
a1469 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_old_uid_t))
d1484 2
a1485 2
          if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                        tdep->size_pollfd * nfds))
d1502 1
a1502 1
          if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest, rsize))
d1512 2
a1513 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_old_gid_t))
d1516 2
a1517 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_old_gid_t))
d1520 2
a1521 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_old_gid_t))
d1532 2
a1533 2
          if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                        tdep->size_int))
d1539 2
a1540 2
          if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                        tdep->size_TASK_COMM_LEN))
d1551 2
a1552 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_sigaction))
d1558 2
a1559 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_sigset_t))
d1570 2
a1571 2
          if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                        (int) sigsetsize))
d1578 2
a1579 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_siginfo_t))
d1594 2
a1595 1
          if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest, (int) count))
d1611 2
a1612 1
          if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest, (int) size))
d1619 2
a1620 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_cap_user_data_t))
d1629 2
a1630 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_stack_t))
d1636 2
a1637 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_off_t))
d1648 2
a1649 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_rlimit))
d1664 2
a1665 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_stat64))
d1687 1
a1687 1
          if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest, tmpint))
d1699 2
a1700 1
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest, tdep->size_uid_t))
d1703 2
a1704 1
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest, tdep->size_uid_t))
d1707 2
a1708 1
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest, tdep->size_uid_t))
d1717 2
a1718 1
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest, tdep->size_gid_t))
d1721 2
a1722 1
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest, tdep->size_gid_t))
d1725 2
a1726 1
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest, tdep->size_gid_t))
d1740 2
a1741 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_PAGE_SIZE))
d1755 2
a1756 2
        if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                      tdep->size_dirent64 * count))
d1767 2
a1768 2
          if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                        tdep->size_flock64))
d1796 2
a1797 1
          if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest, (int) size))
d1811 2
a1812 1
          if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest, (int) size))
d1825 2
a1826 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_loff_t))
d1841 2
a1842 1
          if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest, (int) len))
d1849 2
a1850 1
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest, tdep->size_int))
d1856 2
a1857 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_user_desc))
d1863 2
a1864 1
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest, tdep->size_long))
d1878 2
a1879 2
          if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                        nr * tdep->size_io_event))
d1910 1
a1910 1
              if (record_arch_list_add_mem (tmpaddr, tdep->size_iocb))
d1919 2
a1920 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_io_event))
d1949 2
a1950 1
          if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest, (int) len))
d1966 3
a1968 2
          if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                        maxevents * tdep->size_epoll_event))
d1979 2
a1980 1
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest, tdep->size_int))
d1986 2
a1987 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_itimerspec))
d1993 2
a1994 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_itimerspec))
d2005 2
a2006 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_timespec))
d2012 2
a2013 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_timespec))
d2019 2
a2020 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_timespec))
d2027 2
a2028 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_statfs64))
d2041 2
a2042 1
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest, tdep->size_int))
d2050 2
a2051 2
          if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                        maxnode * tdep->size_long))
d2069 2
a2070 2
          if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                        (int) msg_len))
d2074 2
a2075 1
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest, tdep->size_int))
d2084 2
a2085 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_mq_attr))
d2094 2
a2095 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_siginfo))
d2098 2
a2099 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_rusage))
d2119 2
a2120 2
              if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                            (int) buflen))
d2141 2
a2142 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_stat64))
d2159 2
a2160 1
          if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest, (int) bufsiz))
d2171 2
a2172 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_fd_set))
d2175 2
a2176 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_fd_set))
d2179 2
a2180 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_fd_set))
d2183 2
a2184 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_timespec))
d2195 2
a2196 2
          if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                        tdep->size_pollfd * nfds))
d2200 2
a2201 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_timespec))
d2211 2
a2212 1
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest, tdep->size_int))
d2215 2
a2216 1
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest, tdep->size_int))
d2222 2
a2223 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_loff_t))
d2226 2
a2227 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_loff_t))
d2243 2
a2244 2
          if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                        nr_pages * tdep->size_int))
d2251 2
a2252 1
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest, tdep->size_int))
d2255 2
a2256 1
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest, tdep->size_int))
d2259 2
a2260 2
      if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest,
                                    tdep->size_ulong * 2))
d2272 1
a2272 1
          if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest, tmpint))
@


1.17
log
@linux-record.c:record_linux_system_call: fix -Wpointer-sign

$ make WERROR_CFLAGS="-Wpointer-sign -Werror" linux-record.o 2>&1 1>/dev/null
...
../../src/gdb/linux-record.c: In function ‘record_linux_system_call’:
../../src/gdb/linux-record.c:1152:9: error: pointer targets in passing argument 3 of ‘regcache_raw_read_signed’ differ in signedness [-Werror=pointer-sign]
In file included from ../../src/gdb/linux-record.c:23:0:
../../src/gdb/regcache.h:76:3: note: expected ‘long int *’ but argument is of type ‘long unsigned int *’
../../src/gdb/linux-record.c:1186:13: error: pointer targets in passing argument 3 of ‘regcache_raw_read_signed’ differ in signedness [-Werror=pointer-sign]
In file included from ../../src/gdb/linux-record.c:23:0:
../../src/gdb/regcache.h:76:3: note: expected ‘long int *’ but argument is of type ‘long unsigned int *’

I believe the read_signed calls are correct, and the variables are in
the wrong.

Tested on x86_64 Fedora 17.

gdb/
2013-03-07  Pedro Alves  <palves@@redhat.com>

	* linux-record.c (record_linux_system_call) <gdb_sys_msgrcv,
	RECORD_MSGRCV>: Pass a signed variable to
	regcache_raw_read_signed, instead of an unsigned one.
@
text
@d25 1
@


1.16
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d1151 1
d1153 1
a1153 1
        regcache_raw_read_signed (regcache, tdep->arg3, &tmpulongest);
d1155 1
a1155 1
        tmpint = (int) tmpulongest + tdep->size_long;
d1184 1
a1184 1
            ULONGEST second;
@


1.15
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 1
a3 1
   Copyright (C) 2008-2012 Free Software Foundation, Inc.
@


1.14
log
@2011-02-28  Michael Snyder  <msnyder@@vmware.com>

	* linux-record.c (record_linux_system_call): Add missing
	break statement.
@
text
@d3 1
a3 1
   Copyright (C) 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
@


1.14.4.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 1
a3 1
   Copyright (C) 2008-2012 Free Software Foundation, Inc.
@


1.13
log
@run copyright.sh for 2011.
@
text
@d773 2
@


1.12
log
@2010-06-22  Hui Zhu  <teawater@@gmail.com>

	* i386-tdep.c (i386_record_lea_modrm): Change warning to query.
	(i386_process_record): Ditto.
	* record.c (record_memory_query): New variable.
	(_initialize_record): New command "set record memory-query".
	* record.h (record_memory_query): New extern.

2010-06-22  Hui Zhu  <teawater@@gmail.com>

	* gdb.texinfo: (Process Record and Replay): Add documentation
	for command "set record memory-query".
@
text
@d3 1
a3 1
   Copyright (C) 2008, 2009, 2010 Free Software Foundation, Inc.
@


1.11
log
@2010-05-14  Michael Snyder  <msnyder@@vmware.com>

	* jv-lang.c: White space.
	* jv-typeprint.c: White space.
	* jv-valprint.c: White space.
	* language.c: White space.
	* libunwind-frame.c: White space.
	* linespec.c: White space.
	* linux-nat.c: White space.
	* linux-record.c: White space.
	* linux-thread-db.c: White space.
@
text
@a697 1
        int q;
d703 15
a717 9
        target_terminal_ours ();
        q = yquery (_("The next instruction is syscall munmap.  "
                      "It will free the memory addr = 0x%s len = %u.  "
                      "It will make record target get error.  "
                      "Do you want to stop the program?"),
                    OUTPUT_REG (tmpulongest, tdep->arg1), (int) len);
        target_terminal_inferior ();
        if (q)
          return 1;
@


1.10
log
@2010-05-05  Michael Snyder  <msnyder@@vmware.com>

	* linux-record.c (record_linux_system_call):
	Delete unused variables.
@
text
@d243 1
d260 1
d659 1
d675 1
d677 3
a679 4
        q =
          yquery (_("The next instruction is syscall reboot.  "
                    "It will restart the computer.  "
                    "Do you want to stop the program?"));
d751 1
d762 1
d771 1
d797 1
d867 1
d1144 1
d1178 1
d1234 1
d1333 1
d1465 1
d1478 1
d1551 1
d1575 1
d1591 1
d1664 1
d1726 1
d1769 1
d1783 1
d1812 1
d1846 1
d1901 1
d1917 1
d1933 1
d2014 1
d2033 1
d2082 1
d2122 1
d2157 1
d2203 1
d2229 1
@


1.9
log
@2010-03-16  Holger Hans Peter Freyther  <zecke@@selfish.org>

	* linux-record.c (record_linux_msghdr): Remove unintended semicolons.
@
text
@a831 2
                int addrlen;
                gdb_byte *addrlenp;
a892 2
              int addrlen;
              gdb_byte *addrlenp;
@


1.8
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d195 1
a195 1
          if (record_arch_list_add_mem (tmpaddr, tmpint));
d206 1
a206 1
  if (record_arch_list_add_mem ((CORE_ADDR) addr, tmpint));
@


1.8.2.1
log
@2010-03-16  Holger Hans Peter Freyther  <zecke@@selfish.org>

	* linux-record.c (record_linux_msghdr): Remove unintended semicolons.
@
text
@d195 1
a195 1
          if (record_arch_list_add_mem (tmpaddr, tmpint))
d206 1
a206 1
  if (record_arch_list_add_mem ((CORE_ADDR) addr, tmpint))
@


1.7
log
@2009-09-08  Michael Snyder  <msnyder@@vmware.com>

	* amd64-linux-tdep.h (enum amd64_syscall): New enum consts,
	to replace literal consts used in amd64-linux-tdep.c
	* linux-record.h (enum gdb_syscall): New enum consts, to replace
	literal consts used in amd64-linux-tdep.c and linux-record.c.
	* amd64-linux-tdep.c (amd64_canonicalize_syscall): New function,
	translate from native amd64 Linux syscall id to internal gdb id.
	(amd64_linux_syscall_record): Switch statement abstracted out
	and replaced with a call to amd64_canonicalize_syscall.
	* linux-record.c (record_linux_system_call): Replace literal
	consts with enum consts.
	* i386-linux-tdep.c (i386_canonicalize_syscall): New function,
	trivially translate from native i386 Linux syscalls to gdb syscalls.
	(i386_linux_intx80_sysenter_record):
@
text
@d3 1
a3 1
   Copyright (C) 2008, 2009 Free Software Foundation, Inc.
@


1.6
log
@2009-08-10  Hui Zhu  <teawater@@gmail.com>

	Add process record Linux system call 64 bits support.

        * linux-record.h (linux_record_tdep): Add size_pointer,
        size_size_t, size_iovec and arg6.  Change the values of
	size_int, size_long and size_ulong to
	gdbarch_int_bit (gdbarch) / TARGET_CHAR_BIT,
	gdbarch_long_bit (gdbarch) / TARGET_CHAR_BIT,
	gdbarch_long_bit (gdbarch) / TARGET_CHAR_BIT.
	* i386-linux-tdep.c (i386_linux_init_abi): Ditto.
	(i386_linux_intx80_sysenter_record): Add a check for system
	call number.
        * linux-record.c (record_linux_system_call): Make this
        function support 64 bits.
@
text
@d225 2
a226 1
record_linux_system_call (int num, struct regcache *regcache,
d235 1
a235 1
  switch (num)
d237 1
a237 2
      /* sys_restart_syscall */
    case 0:
d240 1
a240 2
      /* sys_exit */
    case 1:
d253 1
a253 2
      /* sys_fork */
    case 2:
d256 1
a256 2
      /* sys_read */
    case 3:
d266 19
a284 36
      /* sys_write */
    case 4:
      /* sys_open */
    case 5:
      /* sys_close */
    case 6:
      /* sys_waitpid */
    case 7:
      /* sys_creat */
    case 8:
      /* sys_link */
    case 9:
      /* sys_unlink */
    case 10:
      /* sys_execve */
    case 11:
      /* sys_chdir */
    case 12:
      /* sys_time */
    case 13:
      /* sys_mknod */
    case 14:
      /* sys_chmod */
    case 15:
      /* sys_lchown16 */
    case 16:
      /* sys_ni_syscall */
    case 17:
      break;

      /* sys_stat */
    case 18:
      /* sys_fstat */
    case 28:
      /* sys_lstat */
    case 84:
d291 7
a297 14
      /* sys_lseek */
    case 19:
      /* sys_getpid */
    case 20:
      /* sys_mount */
    case 21:
      /* sys_oldumount */
    case 22:
      /* sys_setuid16 */
    case 23:
      /* sys_getuid16 */
    case 24:
      /* sys_stime */
    case 25:
d300 1
a300 2
      /* sys_ptrace */
    case 26:
d313 15
a327 30
      /* sys_alarm */
    case 27:
      /* sys_pause */
    case 29:
      /* sys_utime    */
    case 30:
      /* sys_ni_syscall */
    case 31:
      /* sys_ni_syscall */
    case 32:
      /* sys_access */
    case 33:
      /* sys_nice */
    case 34:
      /* sys_ni_syscall */
    case 35:
      /* sys_sync */
    case 36:
      /* sys_kill */
    case 37:
      /* sys_rename */
    case 38:
      /* sys_mkdir */
    case 39:
      /* sys_rmdir */
    case 40:
      /* sys_dup */
    case 41:
      /* sys_pipe */
    case 42:
d330 1
a330 2
      /* sys_times */
    case 43:
d336 10
a345 20
      /* sys_ni_syscall */
    case 44:
      /* sys_brk */
    case 45:
      /* sys_setgid16 */
    case 46:
      /* sys_getgid16 */
    case 47:
      /* sys_signal */
    case 48:
      /* sys_geteuid16 */
    case 49:
      /* sys_getegid16 */
    case 50:
      /* sys_acct */
    case 51:
      /* sys_umount */
    case 52:
      /* sys_ni_syscall */
    case 53:
d348 1
a348 2
      /* sys_ioctl */
    case 54:
d444 1
a444 1
          /* This syscall affect a char size memory.  */
d503 1
a503 2
      /* sys_fcntl */
    case 55:
d517 3
a519 6
      /* sys_ni_syscall */
    case 56:
      /* sys_setpgid */
    case 57:
      /* sys_ni_syscall */
    case 58:
d522 1
a522 2
      /* sys_olduname */
    case 59:
d529 2
a530 4
      /* sys_umask */
    case 60:
      /* sys_chroot */
    case 61:
d533 1
a533 2
      /* sys_ustat */
    case 62:
d540 4
a543 8
      /* sys_dup2 */
    case 63:
      /* sys_getppid */
    case 64:
      /* sys_getpgrp */
    case 65:
      /* sys_setsid */
    case 66:
d546 1
a546 2
      /* sys_sigaction */
    case 67:
d553 5
a557 10
      /* sys_sgetmask */
    case 68:
      /* sys_ssetmask */
    case 69:
      /* sys_setreuid16 */
    case 70:
      /* sys_setregid16 */
    case 71:
      /* sys_sigsuspend */
    case 72:
d560 1
a560 2
      /* sys_sigpending */
    case 73:
d567 2
a568 4
      /* sys_sethostname */
    case 74:
      /* sys_setrlimit */
    case 75:
d571 1
a571 2
      /* sys_old_getrlimit */
    case 76:
d578 1
a578 2
      /* sys_getrusage */
    case 77:
d585 1
a585 2
      /* sys_gettimeofday */
    case 78:
d596 1
a596 2
      /* sys_settimeofday */
    case 79:
d599 1
a599 2
      /* sys_getgroups16 */
    case 80:
d606 1
a606 2
      /* sys_setgroups16 */
    case 81:
d613 1
a613 2
      /* old_select */
    case 82:
d651 1
a651 2
      /* sys_symlink */
    case 83:
d654 1
a654 2
      /* sys_readlink */
    case 85:
d665 2
a666 4
      /* sys_uselib */
    case 86:
      /* sys_swapon */
    case 87:
d669 1
a669 2
      /* sys_reboot */
    case 88:
d683 1
a683 2
      /* old_readdir */
    case 89:
d690 1
a690 2
      /* old_mmap */
    case 90:
d693 1
a693 2
      /* sys_munmap */
    case 91:
d713 11
a723 20
      /* sys_truncate */
    case 92:
      /* sys_ftruncate */
    case 93:
      /* sys_fchmod */
    case 94:
      /* sys_fchown16 */
    case 95:
      /* sys_getpriority */
    case 96:
      /* sys_setpriority */
    case 97:
      /* sys_ni_syscall */
    case 98:
      break;

      /* sys_statfs */
    case 99:
      /* sys_fstatfs */
    case 100:
d730 1
a730 2
      /* sys_ioperm */
    case 101:
d733 13
a745 24
      /* sys_socket */
    case 500:
      /* sys_sendto */
    case 503:
      /* sys_sendmsg */
    case 505:
      /* sys_shutdown */
    case 507:
      /* sys_bind */
    case 508:
      /* sys_connect */
    case 501:
      /* sys_listen */
    case 509:
      /* sys_setsockopt */
    case 513:
      break;

      /* sys_accept */
    case 502:
      /* sys_getsockname */
    case 510:
      /* sys_getpeername */
    case 511:
d755 1
a755 2
      /* sys_recvfrom */
    case 504:
d763 1
a763 2
      /* sys_recv */
    case 515:
d773 1
a773 2
      /* sys_recvmsg */
    case 506:
d779 1
a779 2
      /* sys_socketpair */
    case 512:
d785 1
a785 2
      /* sys_getsockopt */
    case 514:
d814 1
a814 2
      /* sys_socketcall */
    case 102:
d1050 1
a1050 2
      /* sys_syslog */
    case 103:
d1053 1
a1053 2
      /* sys_setitimer */
    case 104:
d1060 1
a1060 2
      /* sys_getitimer */
    case 105:
d1067 4
a1070 8
      /* sys_newstat */
    case 106:
      /* sys_newlstat */
    case 107:
      /* sys_newfstat */
    case 108:
      /* sys_newfstatat */
    case 540:
d1076 1
a1076 2
      /* sys_uname */
    case 109:
d1083 4
a1086 8
      /* sys_iopl */
    case 110:
      /* sys_vhangup */
    case 111:
      /* sys_ni_syscall */
    case 112:
      /* sys_vm86old */
    case 113:
d1089 1
a1089 2
      /* sys_wait4 */
    case 114:
d1100 1
a1100 2
      /* sys_swapoff */
    case 115:
d1103 1
a1103 2
      /* sys_sysinfo */
    case 116:
d1110 4
a1113 9
      /* sys_shmget */
    case 520:
      /* sys_semget */
    case 523:
      /* sys_semop */
    case 524:
      /* sys_msgget */
    case 528:
      /* sys_shmdt */
d1115 3
a1117 5
    case 527:
      /* sys_msgsnd */
    case 529:
      /* sys_semtimedop */
    case 532:
d1120 1
a1120 2
      /* sys_shmat */
    case 521:
d1127 1
a1127 2
      /* sys_shmctl */
    case 522:
d1134 1
a1135 1
      /* XXX sys_semctl 525 still not support.  */
d1137 1
a1137 2
      /* sys_msgrcv */
    case 530:
d1148 1
a1148 2
      /* sys_msgctl */
    case 531:
d1155 1
a1155 2
      /* sys_ipc */
    case 117:
d1165 1
a1165 1
          /* XXX maybe need do some record works with RECORD_SHMDT.  */
d1202 1
a1202 1
          /* XXX RECORD_SEMCTL still not support.  */
d1204 2
a1205 1
                               "support ipc number %d\n"), (int) tmpulongest);
d1210 4
a1213 8
      /* sys_fsync */
    case 118:
      /* sys_sigreturn */
    case 119:
      /* sys_clone */
    case 120:
      /* sys_setdomainname */
    case 121:
d1216 1
a1216 2
      /* sys_newuname */
    case 122:
d1223 1
a1223 2
      /* sys_modify_ldt */
    case 123:
d1235 1
a1235 2
      /* sys_adjtimex */
    case 124:
d1241 1
a1241 2
      /* sys_mprotect */
    case 125:
d1244 1
a1244 2
      /* sys_sigprocmask */
    case 126:
d1251 4
a1254 8
      /* sys_ni_syscall */
    case 127:
      /* sys_init_module */
    case 128:
      /* sys_delete_module */
    case 129:
      /* sys_ni_syscall */
    case 130:
d1257 1
a1257 2
      /* sys_quotactl */
    case 131:
d1293 3
a1295 6
      /* sys_getpgid */
    case 132:
      /* sys_fchdir */
    case 133:
      /* sys_bdflush */
    case 134:
d1298 1
a1298 2
      /* sys_sysfs */
    case 135:
d1304 1
a1304 1
          /*XXX the size of memory is not very clear.  */
d1310 4
a1313 8
      /* sys_personality */
    case 136:
      /* sys_ni_syscall */
    case 137:
      /* sys_setfsuid16 */
    case 138:
      /* sys_setfsgid16 */
    case 139:
d1316 1
a1316 2
      /* sys_llseek */
    case 140:
d1323 1
a1323 2
      /* sys_getdents */
    case 141:
d1335 1
a1335 2
      /* sys_select */
    case 142:
d1354 2
a1355 4
      /* sys_flock */
    case 143:
      /* sys_msync */
    case 144:
d1358 1
a1358 2
      /* sys_readv */
    case 145:
d1397 9
a1405 18
      /* sys_writev */
    case 146:
      /* sys_getsid */
    case 147:
      /* sys_fdatasync */
    case 148:
      /* sys_sysctl */
    case 149:
      /* sys_mlock */
    case 150:
      /* sys_munlock */
    case 151:
      /* sys_mlockall */
    case 152:
      /* sys_munlockall */
    case 153:
      /* sys_sched_setparam */
    case 154:
d1408 1
a1408 2
      /* sys_sched_getparam */
    case 155:
d1414 9
a1422 16
      /* sys_sched_setscheduler */
    case 156:
      /* sys_sched_getscheduler */
    case 157:
      /* sys_sched_yield */
    case 158:
      /* sys_sched_get_priority_max */
    case 159:
      /* sys_sched_get_priority_min */
    case 160:
      break;

      /* sys_sched_rr_get_interval */
    case 161:
      /* sys_nanosleep */
    case 162:
d1429 2
a1430 4
      /* sys_mremap */
    case 163:
      /* sys_setresuid16 */
    case 164:
d1433 1
a1433 2
      /* sys_getresuid16 */
    case 165:
d1448 2
a1449 4
      /* sys_vm86 */
    case 166:
      /* sys_ni_syscall */
    case 167:
d1452 1
a1452 2
      /* sys_poll */
    case 168:
d1464 1
a1464 2
      /* sys_nfsservctl */
    case 169:
d1480 1
a1480 2
      /* sys_setresgid16 */
    case 170:
d1483 1
a1483 2
      /* sys_getresgid16 */
    case 171:
d1498 1
a1498 2
      /* sys_prctl */
    case 172:
d1519 1
a1519 2
      /* sys_rt_sigreturn */
    case 173:
d1522 1
a1522 2
      /* sys_rt_sigaction */
    case 174:
d1529 1
a1529 2
      /* sys_rt_sigprocmask */
    case 175:
d1536 1
a1536 2
      /* sys_rt_sigpending */
    case 176:
d1548 1
a1548 2
      /* sys_rt_sigtimedwait */
    case 177:
d1555 2
a1556 4
      /* sys_rt_sigqueueinfo */
    case 178:
      /* sys_rt_sigsuspend */
    case 179:
d1559 1
a1559 2
      /* sys_pread64 */
    case 180:
d1570 2
a1571 4
      /* sys_pwrite64 */
    case 181:
      /* sys_chown16 */
    case 182:
d1574 1
a1574 2
      /* sys_getcwd */
    case 183:
d1585 1
a1585 2
      /* sys_capget */
    case 184:
d1592 1
a1592 2
      /* sys_capset */
    case 185:
d1595 1
a1595 2
      /* sys_sigaltstack */
    case 186:
d1602 1
a1602 2
      /* sys_sendfile */
    case 187:
d1609 3
a1611 6
      /* sys_ni_syscall */
    case 188:
      /* sys_ni_syscall */
    case 189:
      /* sys_vfork */
    case 190:
d1614 1
a1614 2
      /* sys_getrlimit */
    case 191:
d1621 1
a1621 2
      /* sys_mmap2 */
    case 192:
d1624 7
a1630 12
      /* sys_truncate64 */
    case 193:
      /* sys_ftruncate64 */
    case 194:
      break;

      /* sys_stat64 */
    case 195:
      /* sys_lstat64 */
    case 196:
      /* sys_fstat64 */
    case 197:
d1637 7
a1643 14
      /* sys_lchown */
    case 198:
      /* sys_getuid */
    case 199:
      /* sys_getgid */
    case 200:
      /* sys_geteuid */
    case 201:
      /* sys_getegid */
    case 202:
      /* sys_setreuid */
    case 203:
      /* sys_setregid */
    case 204:
d1646 1
a1646 2
      /* sys_getgroups */
    case 205:
d1659 3
a1661 6
      /* sys_setgroups */
    case 206:
      /* sys_fchown */
    case 207:
      /* sys_setresuid */
    case 208:
d1664 1
a1664 2
      /* sys_getresuid */
    case 209:
d1676 1
a1676 2
      /* sys_setresgid */
    case 210:
d1679 1
a1679 2
      /* sys_getresgid */
    case 211:
d1691 6
a1696 12
      /* sys_chown */
    case 212:
      /* sys_setuid */
    case 213:
      /* sys_setgid */
    case 214:
      /* sys_setfsuid */
    case 215:
      /* sys_setfsgid */
    case 216:
      /* sys_pivot_root */
    case 217:
d1699 1
a1699 2
      /* sys_mincore */
    case 218:
d1706 1
a1706 2
      /* sys_madvise */
    case 219:
d1709 1
a1709 2
      /* sys_getdents64 */
    case 220:
d1721 1
a1721 2
      /* sys_fcntl64 */
    case 221:
d1738 12
a1749 22
      /* sys_ni_syscall */
    case 222:
      /* sys_ni_syscall */
    case 223:
      /* sys_gettid */
    case 224:
      /* sys_readahead */
    case 225:
      /* sys_setxattr */
    case 226:
      /* sys_lsetxattr */
    case 227:
      /* sys_fsetxattr */
    case 228:
      break;

      /* sys_getxattr */
    case 229:
      /* sys_lgetxattr */
    case 230:
      /* sys_fgetxattr */
    case 231:
d1760 3
a1762 6
      /* sys_listxattr */
    case 232:
      /* sys_llistxattr */
    case 233:
      /* sys_flistxattr */
    case 234:
d1773 4
a1776 8
      /* sys_removexattr */
    case 235:
      /* sys_lremovexattr */
    case 236:
      /* sys_fremovexattr */
    case 237:
      /* sys_tkill */
    case 238:
d1779 1
a1779 2
      /* sys_sendfile64 */
    case 239:
d1786 2
a1787 4
      /* sys_futex */
    case 240:
      /* sys_sched_setaffinity */
    case 241:
d1790 1
a1790 2
      /* sys_sched_getaffinity */
    case 242:
d1801 1
a1801 2
      /* sys_set_thread_area */
    case 243:
d1807 1
a1807 2
      /* sys_get_thread_area */
    case 244:
d1814 1
a1814 2
      /* sys_io_setup */
    case 245:
d1820 1
a1820 2
      /* sys_io_destroy */
    case 246:
d1823 1
a1823 2
      /* sys_io_getevents */
    case 247:
d1835 1
a1835 2
      /* sys_io_submit */
    case 248:
d1868 1
a1868 2
      /* sys_io_cancel */
    case 249:
d1875 2
a1876 4
      /* sys_fadvise64 */
    case 250:
      /* sys_ni_syscall */
    case 251:
d1879 1
a1879 2
      /* sys_exit_group */
    case 252:
d1892 1
a1892 2
      /* sys_lookup_dcookie */
    case 253:
d1903 2
a1904 4
      /* sys_epoll_create */
    case 254:
      /* sys_epoll_ctl */
    case 255:
d1907 1
a1907 2
      /* sys_epoll_wait */
    case 256:
d1919 2
a1920 4
      /* sys_remap_file_pages */
    case 257:
      /* sys_set_tid_address */
    case 258:
d1923 1
a1923 2
      /* sys_timer_create */
    case 259:
d1929 1
a1929 2
      /* sys_timer_settime */
    case 260:
d1936 1
a1936 2
      /* sys_timer_gettime */
    case 261:
d1943 3
a1945 6
      /* sys_timer_getoverrun */
    case 262:
      /* sys_timer_delete */
    case 263:
      /* sys_clock_settime */
    case 264:
d1948 1
a1948 2
      /* sys_clock_gettime */
    case 265:
d1955 1
a1955 2
      /* sys_clock_getres */
    case 266:
d1962 1
a1962 2
      /* sys_clock_nanosleep */
    case 267:
d1969 2
a1970 4
      /* sys_statfs64 */
    case 268:
      /* sys_fstatfs64 */
    case 269:
d1977 5
a1981 10
      /* sys_tgkill */
    case 270:
      /* sys_utimes */
    case 271:
      /* sys_fadvise64_64 */
    case 272:
      /* sys_ni_syscall */
    case 273:
      /* sys_mbind */
    case 274:
d1984 1
a1984 2
      /* sys_get_mempolicy */
    case 275:
d1999 4
a2002 8
      /* sys_set_mempolicy */
    case 276:
      /* sys_mq_open */
    case 277:
      /* sys_mq_unlink */
    case 278:
      /* sys_mq_timedsend */
    case 279:
d2005 1
a2005 2
      /* sys_mq_timedreceive */
    case 280:
d2020 1
a2020 2
      /* sys_mq_notify */
    case 281:
d2023 1
a2023 2
      /* sys_mq_getsetattr */
    case 282:
d2030 1
a2030 2
      /* sys_kexec_load */
    case 283:
d2033 1
a2033 2
      /* sys_waitid */
    case 284:
d2044 3
a2046 6
      /* sys_ni_syscall */
    case 285:
      /* sys_add_key */
    case 286:
      /* sys_request_key */
    case 287:
d2049 1
a2049 2
      /* sys_keyctl */
    case 288:
d2066 11
a2076 22
      /* sys_ioprio_set */
    case 289:
      /* sys_ioprio_get */
    case 290:
      /* sys_inotify_init */
    case 291:
      /* sys_inotify_add_watch */
    case 292:
      /* sys_inotify_rm_watch */
    case 293:
      /* sys_migrate_pages */
    case 294:
      /* sys_openat */
    case 295:
      /* sys_mkdirat */
    case 296:
      /* sys_mknodat */
    case 297:
      /* sys_fchownat */
    case 298:
      /* sys_futimesat */
    case 299:
d2079 1
a2079 2
      /* sys_fstatat64 */
    case 300:
d2086 4
a2089 8
      /* sys_unlinkat */
    case 301:
      /* sys_renameat */
    case 302:
      /* sys_linkat */
    case 303:
      /* sys_symlinkat */
    case 304:
d2092 1
a2092 2
      /* sys_readlinkat */
    case 305:
d2103 2
a2104 4
      /* sys_fchmodat */
    case 306:
      /* sys_faccessat */
    case 307:
d2107 1
a2107 2
      /* sys_pselect6 */
    case 308:
d2126 1
a2126 2
      /* sys_ppoll */
    case 309:
d2142 2
a2143 4
      /* sys_unshare */
    case 310:
      /* sys_set_robust_list */
    case 311:
d2146 1
a2146 2
      /* sys_get_robust_list */
    case 312:
d2155 1
a2155 2
      /* sys_splice */
    case 313:
d2166 3
a2168 6
      /* sys_sync_file_range */
    case 314:
      /* sys_tee */
    case 315:
      /* sys_vmsplice */
    case 316:
d2171 1
a2171 2
      /* sys_move_pages */
    case 317:
d2183 1
a2183 2
      /* sys_getcpu */
    case 318:
d2196 1
a2196 2
      /* sys_epoll_pwait */
    case 319:
d2210 1
a2210 1
                           "support syscall number %u\n"), num);
@


1.5
log
@	* defs.h (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter.
	* utils.c (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter, use it instead of current_gdbarch.
	* ui-out.h (ui_out_field_core_addr): Add GDBARCH parameter.
	* ui-out.c (ui_out_field_core_addr): Add GDBARCH parameter,
	use it instead of current_gdbarch.

	Update calls to ui_out_field_core_addr to pass architecture:
	* ada-lang.c (print_one_exception): Update.
	* breakpoint.c (print_one_breakpoint_location,
	print_one_exception_catchpoint): Update.
	* disasm.c (dump_insns): Update.
	* darwin-nat-info.c (darwin_debug_regions_recurse): Update.
	* mi/mi-main.c (mi_cmd_data_read_memory): Update.
	* mi/mi-symbol-cmds.c: Include "objfiles.h".
	(mi_cmd_symbol_list_lines): Update.
	* stack.c (print_frame_info, print_frame): Update.

	Update callers of paddress to pass architecture:
	* ada-tasks.c (info_task): Update.
	* ada-valprint.c (ada_val_print_1): Update.
	* annotate.c (annotate_source, annotate_frame_begin): Update.
	* breakpoint.c (insert_bp_location, describe_other_breakpoints,
	mention): Update.
	* cli/cli-cmds.c (edit_command, list_command, print_disassembly):
	Update.
	* corefile.c (memory_error): Update.
	* c-valprint.c (print_function_pointer_address, c_val_print): Update.
	* disasm.c (dis_asm_print_address): Update.
	* exec.c (print_section_info): Update.
	* f-valprint.c (f_val_print): Update.
	* infcmd.c: Include "arch-utils.h".
	(jump_command, program_info): Update.
	* linux-fork.c: Include "arch-utils.h".
	(info_forks_command): Update.
	* m2-valprint.c (print_function_pointer_address,
	print_unpacked_pointer, print_variable_at_address,
	m2_val_print): Update.
	* m32r-rom.c (m32r_load_section, m32r_load, m32r_upload_command):
	Update.
	* printcmd.c (print_address, print_address_demangle, address_info):
	Update.
	* p-valprint.c (pascal_val_print): Update.
	* source.c: Include "arch-utils.h".
	(line_info): Update.
	* stack.c (frame_info, print_block_frame_labels): Update.
	* symfile.c (add_symbol_file_command, list_overlays_command): Update.
	* symmisc.c (dump_msymbols, dump_psymtab, dump_symtab_1,
	print_symbol, print_partial_symbols, maintenance_info_psymtabs,
	maintenance_check_symtabs): Update.
	* symtab.c (find_pc_sect_symtab): Update.
	* target.c (deprecated_debug_xfer_memory): Update.
	* tracepoint.c (scope_info): Update.
	* tui/tui-stack.c (tui_make_status_line): Update.
	* valprint.c (val_print_string): Update.

	Update callers of paddr_nz to use paddress instead (keeping
	user-visible output identical):
	* alpha-tdep.c (alpha_heuristic_proc_start): Update.
	* amd64-tdep.c (fixup_riprel, amd64_displaced_step_copy_insn,
	amd64_displaced_step_fixup): Update.
	* arch-utils.c (simple_displaced_step_copy_insn): Update.
	* auxv.c (fprint_target_auxv): Update.
	* breakpoint.c (insert_single_step_breakpoint): Update.
	* buildsym.c (finish_block): Update.
	* cli/cli-dump.c (restore_section_callback): Update.
	* fbsd-nat.c (fbsd_find_memory_regions): Update.
	* frame.c (frame_unwind_register_value): Update.
	* gcore.c (gcore_create_callback): Update.
	* hppa-tdep.c (hppa_frame_cache, hppa_skip_trampoline_code): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_record_modrm,
	i386_record_lea_modrm_addr, i386_record_lea_modrm,
	i386_process_record): Update.
	* ia64-tdep.c (ia64_frame_this_id, ia64_sigtramp_frame_this_id,
	ia64_libunwind_frame_this_id, ia64_libunwind_sigtramp_frame_this_id,
	ia64_dummy_id, ia64_access_reg, ia64_access_rse_reg): Update.
	* infrun.c (displaced_step_prepare, displaced_step_fixup,
	handle_inferior_event, insert_step_resume_breakpoint_at_sal,
	insert_longjmp_resume_breakpoint): Update.
	* linux-nat.c (linux_nat_find_memory_regions): Update.
	* linux-record.c (record_linux_system_call): Update.
	* mips-tdep.c (heuristic_proc_start, mips_eabi_push_dummy_call,
	mips_n32n64_push_dummy_call, mips_o32_push_dummy_call,
	mips_o64_push_dummy_call): Update.
	* monitor.c (monitor_error, monitor_remove_breakpoint): Update.
	* record.c (record_arch_list_add_mem, record_wait,
	record_xfer_partial): Update.
	* remote-mips.c (mips_fetch_word, mips_check_lsi_error,
	mips_common_breakpoint): Update.
	* remote-sim.c (gdbsim_xfer_inferior_memory): Update.
	* rs6000-tdep.c (ppc_displaced_step_fixup): Update.
	* solib-som.c (som_current_sos): Update.
	* symfile.c (load_progress, generic_load): Update.
	* symfile-mem.c (add_vsyscall_page): Update.
	* valops.c (value_fetch_lazy): Update.
	* windows-tdep.c (windows_xfer_shared_library): Update.

	Update callers of paddr_nz to use paddress instead (changing
	user-visible output to make it more correct):
	* dwarf2loc.c (locexpr_describe_location): Update.
	* ia64-tdep.c (ia64_memory_insert_breakpoint,
	ia64_memory_remove_breakpoint): Update.
	* jv-valprint.c (java_value_print): Update.
	* m32c-tdep.c (m32c_m16c_address_to_pointer): Update.
	* monitor.c (monitor_read_memory): Update.

	Update callers of paddr to use paddress instead (changing
	user-visible output to make it more correct):
	* arm-tdep.c (arm_push_dummy_call): Update.
	* breakpoint.c (insert_bp_location, create_thread_event_breakpoint,
	create_breakpoint): Update.
	* darwin-nat-info.c (darwin_debug_regions): Update.
	* dcache.c (dcache_info): Update.
	* dsrec.c (load_srec, make_srec): Update.
	* dwarf2-frame.c (dwarf2_restore_rule, execute_cfa_program,
	dwarf2_frame_cache): Update.
	* gcore.c (gcore_copy_callback): Update.
	* gnu-nat.c (gnu_xfer_memory): Update.
	* mips-linux-nat.c (mips_show_dr): Update.
	* monitor.c (monitor_write_memory, monitor_insert_breakpoint,
	monitor_remove_breakpoint): Update.
	* remote.c (compare_sections_command): Update.
	* remote-m32r-sdi.c (m32r_xfer_memory, m32r_insert_breakpoint,
	m32r_remove_breakpoint, m32r_insert_watchpoint,
	m32r_remove_watchpoint): Update.
	* sol-thread.c (info_cb): Update.
	* symfile.c (load_progress): Update.

	Update callers of paddress or paddr_nz to use hex_string instead
	(changes output of internal/error/debug messages only):
	* dwarf2read.c (dump_die_shallow): Update.
	* frame.c (fprint_field, fprint_frame, frame_pc_unwind,
	get_frame_func, create_new_frame): Update.
	* hppa-tdep.c (find_unwind_entry, unwind_command): Update.
	* ia64-tdep.c (get_kernel_table, ia64_find_proc_info_x,
	ia64_get_dyn_info_list): Update.
	* maint.c (maintenance_translate_address): Update.
	* mi/mi-cmd-var.c (mi_cmd_var_create): Update.
	* target.c (target_flash_erase): Update.

	Update callers of paddr/paddr_nz to use phex/phex_nz instead,
	using an appropriate address size.  Remove use of strlen_paddr.
	* exec.c (exec_files_info): Update.
	* i386-nat.c (i386_show_dr): Update.
	* remote.c (remote_flash_erase): Update.
	* m32r-rom.c (m32r_load_section): Update.
	* monitor.c (monitor_vsprintf, monitor_store_register): Update.
	* remote.c (remote_check_symbols, remote_search_memory): Update.
	* remote-mips.c (mips_request, mips_common_breakpoint): Update.
	* scm-valprint.c (scm_ipruk, scm_scmval_print): Update.
	* sh64-tdep.c (sh64_show_media_regs, sh64_show_compact_regs): Update.
	* sh-tdep.c (sh_generic_show_regs, sh3_show_regs, sh2e_show_regs,
	sh2a_show_regs, sh2a_nofpu_show_regs, sh3e_show_regs,
	sh3_dsp_show_regs, sh4_show_regs, sh4_nofpu_show_regs,
	sh_dsp_show_regs): Update.
	* xcoffsolib.c (sharedlibrary_command): Update.


	* maint.c (maint_print_section_info): Add ADDR_SIZE parameter.
	Use hex_string_custom instead of paddr.
	(print_bfd_section_info): Pass address size.
	(print_objfile_section_info): Likewise.

	* annotate.h (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* annotate.c (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* source.c (identify_source_line): Update call to annotate_source.
	* stack.c (print_frame_info, print_frame): Update call to
	annotate_frame_begin.

	* breakpoint.c (describe_other_breakpoints): Add GDBARCH parameter.
	(create_breakpoint, create_ada_exception_breakpoint): Update call.

	* stack.c (print_block_frame_labels): Add GDBARCH parameter.
	(print_frame_label_vars): Update call.

	* symmisc.c (print_partial_symbols): Add GDBARCH parameter.
	(dump_psymtab): Update call to print_partial_symbols.
	(struct print_symbol_args): Add GDBARCH member.
	(dump_symtab_1): Set print_symbol_args architecture member.
	(print_symbol): Use it.

	* windows-tdep.h (windows_xfer_shared_library): Add GDBARCH
	parameter.
	* windows-tdep.c (windows_xfer_shared_library): Likewise.
	* i386-cygwin-tdep.c (struct cpms_data): Add GDBARCH member.
	(core_process_module_section): Pass architecture from cpms_data to
	windows_xfer_shared_library.
	(windows_core_xfer_shared_libraries): Initialize cmps_data
	architecture member.
	* windows-nat.c (windows_xfer_shared_libraries): Pass architecture
	to windows_xfer_shared_library.

	* defs.h (print_address): Add GDBARCH parameter.
	* printcmd.c (print_address): Add GDBARCH parameter.
	(print_scalar_formatted, do_examine): Update call.
	* findcmd.c (find_command): Update call.
	* tracepoint.c: Include "arch-utils.h".
	(trace_find_line_command): Update call.
	* tui/tui-disasm.c (tui_disassemble): Update call.

	* value.h (print_address_demangle): Add GDBARCH parameter.
	* printcmd.c (print_address_demangle): Add GDBARCH parameter.
	* c-valprint.c (print_function_pointer_address, c_val_print):
	Update call.
	* f-valprint.c (f_val_print): Update call.
	* gnu-v3-abi.c (gnuv3_print_method_ptr): Update call.
	* jv-valprint.c (java_val_print): Update call.
	* m2-valprint.c (print_function_pointer_address, m2_val_print):
	Update call.
	* p-valprint.c (pascal_val_print): Update call.

	* disasm.c (gdb_disassemble_info): Install architecture into
	di.application_data field.

testsuite/ChangeLog:

	* gdb.threads/tls-shared.exp: Update to locexpr_describe_location
	change to prefix TLS offset in hex with 0x.

doc/ChangeLog:

	* gdbint.texinfo (Item Output Functions): Update signature
	for ui_out_field_core_addr.
@
text
@d22 1
d84 128
d226 1
a226 1
			  struct linux_record_tdep *tdep)
d229 4
a232 1
  uint32_t tmpu32;
d243 8
a250 9
	int q;
	target_terminal_ours ();
	q =
	  yquery (_ ("The next instruction is syscall exit.  "
		     "It will make the program exit.  "
		     "Do you want to stop the program?"));
	target_terminal_inferior ();
	if (q)
	  return 1;
d261 5
a265 5
	uint32_t addr, count;
	regcache_raw_read (regcache, tdep->arg2, (gdb_byte *) & addr);
	regcache_raw_read (regcache, tdep->arg3, (gdb_byte *) & count);
	if (record_arch_list_add_mem (addr, count))
	  return -1;
d305 4
a308 3
      regcache_raw_read (regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size__old_kernel_stat))
	return -1;
d329 10
a338 10
      regcache_raw_read (regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (tmpu32 == RECORD_PTRACE_PEEKTEXT
	  || tmpu32 == RECORD_PTRACE_PEEKDATA
	  || tmpu32 == RECORD_PTRACE_PEEKUSR)
	{
	  regcache_raw_read (regcache, tdep->arg4,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, 4))
	    return -1;
	}
d375 3
a377 3
      regcache_raw_read (regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_tms))
	return -1;
d405 94
a498 76
      regcache_raw_read (regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (tmpu32 == tdep->ioctl_FIOCLEX || tmpu32 == tdep->ioctl_FIONCLEX
	  || tmpu32 == tdep->ioctl_FIONBIO || tmpu32 == tdep->ioctl_FIOASYNC
	  || tmpu32 == tdep->ioctl_TCSETS || tmpu32 == tdep->ioctl_TCSETSW
	  || tmpu32 == tdep->ioctl_TCSETSF || tmpu32 == tdep->ioctl_TCSETA
	  || tmpu32 == tdep->ioctl_TCSETAW || tmpu32 == tdep->ioctl_TCSETAF
	  || tmpu32 == tdep->ioctl_TCSBRK || tmpu32 == tdep->ioctl_TCXONC
	  || tmpu32 == tdep->ioctl_TCFLSH || tmpu32 == tdep->ioctl_TIOCEXCL
	  || tmpu32 == tdep->ioctl_TIOCNXCL
	  || tmpu32 == tdep->ioctl_TIOCSCTTY
	  || tmpu32 == tdep->ioctl_TIOCSPGRP || tmpu32 == tdep->ioctl_TIOCSTI
	  || tmpu32 == tdep->ioctl_TIOCSWINSZ
	  || tmpu32 == tdep->ioctl_TIOCMBIS || tmpu32 == tdep->ioctl_TIOCMBIC
	  || tmpu32 == tdep->ioctl_TIOCMSET
	  || tmpu32 == tdep->ioctl_TIOCSSOFTCAR
	  || tmpu32 == tdep->ioctl_TIOCCONS
	  || tmpu32 == tdep->ioctl_TIOCSSERIAL
	  || tmpu32 == tdep->ioctl_TIOCPKT || tmpu32 == tdep->ioctl_TIOCNOTTY
	  || tmpu32 == tdep->ioctl_TIOCSETD || tmpu32 == tdep->ioctl_TCSBRKP
	  || tmpu32 == tdep->ioctl_TIOCTTYGSTRUCT
	  || tmpu32 == tdep->ioctl_TIOCSBRK || tmpu32 == tdep->ioctl_TIOCCBRK
	  || tmpu32 == tdep->ioctl_TCSETS2 || tmpu32 == tdep->ioctl_TCSETSW2
	  || tmpu32 == tdep->ioctl_TCSETSF2
	  || tmpu32 == tdep->ioctl_TIOCSPTLCK
	  || tmpu32 == tdep->ioctl_TIOCSERCONFIG
	  || tmpu32 == tdep->ioctl_TIOCSERGWILD
	  || tmpu32 == tdep->ioctl_TIOCSERSWILD
	  || tmpu32 == tdep->ioctl_TIOCSLCKTRMIOS
	  || tmpu32 == tdep->ioctl_TIOCSERGETMULTI
	  || tmpu32 == tdep->ioctl_TIOCSERSETMULTI
	  || tmpu32 == tdep->ioctl_TIOCMIWAIT
	  || tmpu32 == tdep->ioctl_TIOCSHAYESESP)
	{
	  /* Nothing to do.  */
	}
      else if (tmpu32 == tdep->ioctl_TCGETS || tmpu32 == tdep->ioctl_TCGETA
	       || tmpu32 == tdep->ioctl_TIOCGLCKTRMIOS)
	{
	  regcache_raw_read (regcache, tdep->arg3,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_termios))
	    return -1;
	}
      else if (tmpu32 == tdep->ioctl_TIOCGPGRP
	       || tmpu32 == tdep->ioctl_TIOCGSID)
	{
	  regcache_raw_read (regcache, tdep->arg3,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_pid_t))
	    return -1;
	}
      else if (tmpu32 == tdep->ioctl_TIOCOUTQ
	       || tmpu32 == tdep->ioctl_TIOCMGET
	       || tmpu32 == tdep->ioctl_TIOCGSOFTCAR
	       || tmpu32 == tdep->ioctl_FIONREAD
	       || tmpu32 == tdep->ioctl_TIOCINQ
	       || tmpu32 == tdep->ioctl_TIOCGETD
	       || tmpu32 == tdep->ioctl_TIOCGPTN
	       || tmpu32 == tdep->ioctl_TIOCSERGETLSR)
	{
	  regcache_raw_read (regcache, tdep->arg3,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_int))
	    return -1;
	}
      else if (tmpu32 == tdep->ioctl_TIOCGWINSZ)
	{
	  regcache_raw_read (regcache, tdep->arg3,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_winsize))
	    return -1;
	}
      else if (tmpu32 == tdep->ioctl_TIOCLINUX)
	{
	  regcache_raw_read (regcache, tdep->arg3,
			     (gdb_byte *) & tmpu32);
d500 49
a548 45
	  if (record_arch_list_add_mem (tmpu32, 1))
	    return -1;
	}
      else if (tmpu32 == tdep->ioctl_TIOCGSERIAL)
	{
	  regcache_raw_read (regcache, tdep->arg3,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_serial_struct))
	    return -1;
	}
      else if (tmpu32 == tdep->ioctl_TCGETS2)
	{
	  regcache_raw_read (regcache, tdep->arg3,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_termios2))
	    return -1;
	}
      else if (tmpu32 == tdep->ioctl_FIOQSIZE)
	{
	  regcache_raw_read (regcache, tdep->arg3,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_loff_t))
	    return -1;
	}
      else if (tmpu32 == tdep->ioctl_TIOCGICOUNT)
	{
	  regcache_raw_read (regcache, tdep->arg3,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem
	      (tmpu32, tdep->size_serial_icounter_struct))
	    return -1;
	}
      else if (tmpu32 == tdep->ioctl_TIOCGHAYESESP)
	{
	  regcache_raw_read (regcache, tdep->arg3,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_hayes_esp_config))
	    return -1;
	}
      else if (tmpu32 == tdep->ioctl_TIOCSERGSTRUCT)
	{
	  printf_unfiltered (_("Process record and replay target doesn't "
			       "support ioctl request TIOCSERGSTRUCT\n"));
	  return 1;
	}
d550 6
a555 6
	{
	  printf_unfiltered (_("Process record and replay target doesn't "
			       "support ioctl request 0x%s.\n"),
			     phex_nz (tmpu32, 4));
	  return 1;
	}
d561 1
a561 1
      regcache_raw_read (regcache, tdep->arg2, (gdb_byte *) & tmpu32);
d563 8
a570 7
      if (tmpu32 == tdep->fcntl_F_GETLK)
	{
	  regcache_raw_read (regcache, tdep->arg3,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_flock))
	    return -1;
	}
d583 4
a586 3
      regcache_raw_read (regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_oldold_utsname))
	return -1;
d597 4
a600 3
      regcache_raw_read (regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_ustat))
	return -1;
d615 4
a618 3
      regcache_raw_read (regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_old_sigaction))
	return -1;
d635 4
a638 3
      regcache_raw_read (regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_old_sigset_t))
	return -1;
d649 4
a652 3
      regcache_raw_read (regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_rlimit))
	return -1;
d657 4
a660 3
      regcache_raw_read (regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_rusage))
	return -1;
d665 8
a672 6
      regcache_raw_read (regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_timeval))
	return -1;
      regcache_raw_read (regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_timezone))
	return -1;
d681 4
a684 3
      regcache_raw_read (regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_old_gid_t))
	return -1;
d689 4
a692 3
      regcache_raw_read (regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_old_gid_t))
	return -1;
d698 33
a730 32
	struct sel_arg_struct
	{
	  CORE_ADDR n;
	  CORE_ADDR inp;
	  CORE_ADDR outp;
	  CORE_ADDR exp;
	  CORE_ADDR tvp;
	} sel;

	regcache_raw_read (regcache, tdep->arg1,
			   (gdb_byte *) & tmpu32);
	if (tmpu32)
	  {
	    if (target_read_memory (tmpu32, (gdb_byte *) & sel, sizeof (sel)))
	      {
		if (record_debug)
		  fprintf_unfiltered (gdb_stdlog,
				      "Process record: error reading memory "
				      "at addr = %s len = %lu.\n",
				      paddress (gdbarch, tmpu32),
				      (unsigned long)sizeof (sel));
		return -1;
	      }
	    if (record_arch_list_add_mem (sel.inp, tdep->size_fd_set))
	      return -1;
	    if (record_arch_list_add_mem (sel.outp, tdep->size_fd_set))
	      return -1;
	    if (record_arch_list_add_mem (sel.exp, tdep->size_fd_set))
	      return -1;
	    if (record_arch_list_add_mem (sel.tvp, tdep->size_timeval))
	      return -1;
	  }
d741 6
a746 6
	uint32_t len;
	regcache_raw_read (regcache, tdep->arg2,
			   (gdb_byte *) & tmpu32);
	regcache_raw_read (regcache, tdep->arg3, (gdb_byte *) & len);
	if (record_arch_list_add_mem (tmpu32, len))
	  return -1;
d759 9
a767 9
	int q;
	target_terminal_ours ();
	q =
	  yquery (_("The next instruction is syscall reboot.  "
		    "It will restart the computer.  "
		    "Do you want to stop the program?"));
	target_terminal_inferior ();
	if (q)
	  return 1;
d773 4
a776 3
      regcache_raw_read (regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_dirent))
	return -1;
d786 2
a787 2
	int q;
	uint32_t len;
d789 12
a800 13
	regcache_raw_read (regcache, tdep->arg1,
			   (gdb_byte *) & tmpu32);
	regcache_raw_read (regcache, tdep->arg2, (gdb_byte *) & len);
	target_terminal_ours ();
	q =
	  yquery (_("The next instruction is syscall munmap.  "
		    "It will free the memory addr = %s len = %u.  "
		    "It will make record target get error.  "
		    "Do you want to stop the program?"),
		  paddress (gdbarch, tmpu32), (int)len);
	target_terminal_inferior ();
	if (q)
	  return 1;
d824 4
a827 3
      regcache_raw_read (regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_statfs))
	return -1;
d834 97
d933 233
a1165 275
      regcache_raw_read (regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      switch (tmpu32)
	{
	case RECORD_SYS_SOCKET:
	case RECORD_SYS_BIND:
	case RECORD_SYS_CONNECT:
	case RECORD_SYS_LISTEN:
	  break;
	case RECORD_SYS_ACCEPT:
	case RECORD_SYS_GETSOCKNAME:
	case RECORD_SYS_GETPEERNAME:
	  {
	    uint32_t a[3];
	    regcache_raw_read (regcache, tdep->arg2,
			       (gdb_byte *) & tmpu32);
	    if (tmpu32)
	      {
		if (target_read_memory (tmpu32, (gdb_byte *) a, sizeof (a)))
		  {
		    if (record_debug)
		      fprintf_unfiltered (gdb_stdlog,
					  "Process record: error reading "
					  "memory at addr = %s len = %lu.\n",
					  paddress (gdbarch, tmpu32),
					  (unsigned long)sizeof (a));
		    return -1;
		  }
		if (record_arch_list_add_mem (a[1], tdep->size_sockaddr))
		  return -1;
		if (record_arch_list_add_mem (a[2], tdep->size_int))
		  return -1;
	      }
	  }
	  break;

	case RECORD_SYS_SOCKETPAIR:
	  {
	    uint32_t a[4];
	    regcache_raw_read (regcache, tdep->arg2,
			       (gdb_byte *) & tmpu32);
	    if (tmpu32)
	      {
		if (target_read_memory (tmpu32, (gdb_byte *) a, sizeof (a)))
		  {
		    if (record_debug)
		      fprintf_unfiltered (gdb_stdlog,
					  "Process record: error reading "
					  "memory at addr = %s len = %lu.\n",
					  paddress (gdbarch, tmpu32),
				          (unsigned long)sizeof (a));
		    return -1;
		  }
		if (record_arch_list_add_mem (a[3], tdep->size_int))
		  return -1;
	      }
	  }
	  break;
	case RECORD_SYS_SEND:
	case RECORD_SYS_SENDTO:
	  break;
	case RECORD_SYS_RECV:
	  {
	    uint32_t a[3];
	    regcache_raw_read (regcache, tdep->arg2,
			       (gdb_byte *) & tmpu32);
	    if (tmpu32)
	      {
		if (target_read_memory (tmpu32, (gdb_byte *) a, sizeof (a)))
		  {
		    if (record_debug)
		      fprintf_unfiltered (gdb_stdlog,
					  "Process record: error reading "
					  "memory at addr = %s len = %lu.\n",
					  paddress (gdbarch, tmpu32),
					  (unsigned long)sizeof (a));
		    return -1;
		  }
		if (a[2])
		  {
		    if (target_read_memory
			(a[2], (gdb_byte *) & (a[2]), sizeof (a[2])))
		      {
			if (record_debug)
			  fprintf_unfiltered (gdb_stdlog,
					      "Process record: error reading "
					      "memory at addr = %s "
					      "len = %lu.\n",
					      paddress (gdbarch, a[2]),
					      (unsigned long)sizeof (a[2]));
			return -1;
		      }
		    if (record_arch_list_add_mem (a[1], a[2]))
		      return -1;
		  }
	      }
	  }
	  break;
	case RECORD_SYS_RECVFROM:
	  {
	    uint32_t a[6];
	    regcache_raw_read (regcache, tdep->arg2,
			       (gdb_byte *) & tmpu32);
	    if (tmpu32)
	      {
		if (target_read_memory (tmpu32, (gdb_byte *) a, sizeof (a)))
		  {
		    if (record_debug)
		      fprintf_unfiltered (gdb_stdlog,
					  "Process record: error reading "
					  "memory at addr = %s len = %lu.\n",
					  paddress (gdbarch, tmpu32),
					  (unsigned long)sizeof (a));
		    return -1;
		  }
		if (a[2])
		  {
		    if (target_read_memory
			(a[2], (gdb_byte *) & (a[2]), sizeof (a[2])))
		      {
			if (record_debug)
			  fprintf_unfiltered (gdb_stdlog,
					      "Process record: error reading "
					      "memory at addr = %s "
					      "len = %lu.\n",
					      paddress (gdbarch, a[2]),
					      (unsigned long)sizeof (a[2]));
			return -1;
		      }
		    if (record_arch_list_add_mem (a[1], a[2]))
		      return -1;
		    if (record_arch_list_add_mem (a[4], tdep->size_sockaddr))
		      return -1;
		    if (record_arch_list_add_mem (a[5], tdep->size_int))
		      return -1;
		  }
	      }
	  }
	  break;
	case RECORD_SYS_SHUTDOWN:
	case RECORD_SYS_SETSOCKOPT:
	  break;
	case RECORD_SYS_GETSOCKOPT:
	  {
	    uint32_t a[5];
	    uint32_t av;

	    regcache_raw_read (regcache, tdep->arg2,
			       (gdb_byte *) & tmpu32);
	    if (tmpu32)
	      {
		if (target_read_memory (tmpu32, (gdb_byte *) a, sizeof (a)))
		  {
		    if (record_debug)
		      fprintf_unfiltered (gdb_stdlog,
					  "Process record: error reading "
					  "memory at addr = %s len = %lu.\n",
					  paddress (gdbarch, tmpu32),
					  (unsigned long)sizeof (a));
		    return -1;
		  }
		if (a[4])
		  {
		    if (target_read_memory
			(a[4], (gdb_byte *) & av, sizeof (av)))
		      {
			if (record_debug)
			  fprintf_unfiltered (gdb_stdlog,
					      "Process record: error reading "
					      "memory at addr = %s "
					      "len = %lu.\n",
					      paddress (gdbarch, a[4]),
					      (unsigned long)sizeof (av));
			return -1;
		      }
		    if (record_arch_list_add_mem (a[3], av))
		      return -1;
		    if (record_arch_list_add_mem (a[4], tdep->size_int))
		      return -1;
		  }
	      }
	  }
	  break;
	case RECORD_SYS_SENDMSG:
	  break;
	case RECORD_SYS_RECVMSG:
	  {
	    uint32_t a[2], i;
	    struct record_msghdr
	    {
	      uint32_t msg_name;
	      uint32_t msg_namelen;
	      uint32_t msg_iov;
	      uint32_t msg_iovlen;
	      uint32_t msg_control;
	      uint32_t msg_controllen;
	      uint32_t msg_flags;
	    } rec;
	    struct record_iovec
	    {
	      uint32_t iov_base;
	      uint32_t iov_len;
	    } iov;

	    regcache_raw_read (regcache, tdep->arg2,
			       (gdb_byte *) & tmpu32);
	    if (tmpu32)
	      {
		if (target_read_memory (tmpu32, (gdb_byte *) a, sizeof (a)))
		  {
		    if (record_debug)
		      fprintf_unfiltered (gdb_stdlog,
					  "Process record: error reading "
					  "memory at addr = %s len = %lu.\n",
					  paddress (gdbarch, tmpu32),
					  (unsigned long)sizeof (a));
		    return -1;
		  }
		if (record_arch_list_add_mem (a[1], tdep->size_msghdr))
		  return -1;
		if (a[1])
		  {
		    if (target_read_memory
			(a[1], (gdb_byte *) & rec, sizeof (rec)))
		      {
			if (record_debug)
			  fprintf_unfiltered (gdb_stdlog,
					      "Process record: error reading "
					      "memory at addr = %s "
					      "len = %lu.\n",
					      paddress (gdbarch, a[1]),
					      (unsigned long)sizeof (rec));
			return -1;
		      }
		    if (record_arch_list_add_mem
			(rec.msg_name, rec.msg_namelen))
		      return -1;
		    if (record_arch_list_add_mem
			(rec.msg_control, rec.msg_controllen))
		      return -1;
		    if (rec.msg_iov)
		      {
			for (i = 0; i < rec.msg_iovlen; i++)
			  {
			    if (target_read_memory
				(rec.msg_iov, (gdb_byte *) & iov,
				 sizeof (iov)))
			      {
				if (record_debug)
				  fprintf_unfiltered (gdb_stdlog,
						      "Process record: error "
						      "reading memory at "
						      "addr = %s "
						      "len = %lu.\n",
						      paddress (gdbarch,
								rec.msg_iov),
						      (unsigned long)sizeof (iov));
				return -1;
			      }
			    if (record_arch_list_add_mem
				(iov.iov_base, iov.iov_len))
			      return -1;
			    rec.msg_iov += sizeof (struct record_iovec);
			  }
		      }
		  }
	      }
	  }
	  break;
	default:
	  printf_unfiltered (_("Process record and replay target "
			       "doesn't support socketcall call 0x%s\n"),
			     phex_nz (tmpu32, 4));
	  return -1;
	  break;
	}
d1174 4
a1177 3
      regcache_raw_read (regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_itimerval))
	return -1;
d1182 4
a1185 3
      regcache_raw_read (regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_itimerval))
	return -1;
d1194 5
a1198 3
      regcache_raw_read (regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_stat))
	return -1;
d1203 4
a1206 3
      regcache_raw_read (regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_old_utsname))
	return -1;
d1221 8
a1228 6
      regcache_raw_read (regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_int))
	return -1;
      regcache_raw_read (regcache, tdep->arg4, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_rusage))
	return -1;
d1237 60
a1296 3
      regcache_raw_read (regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_sysinfo))
	return -1;
d1301 51
a1351 34
      regcache_raw_read (regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      switch (tmpu32)
	{
	case RECORD_MSGRCV:
	  {
	    int32_t second;
	    uint32_t ptr;
	    regcache_raw_read (regcache, tdep->arg3,
			       (gdb_byte *) & second);
	    regcache_raw_read (regcache, tdep->arg5,
			       (gdb_byte *) & ptr);
	    if (record_arch_list_add_mem (ptr, second + tdep->size_long))
	      return -1;
	  }
	  break;
	case RECORD_MSGCTL:
	  regcache_raw_read (regcache, tdep->arg5,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_msqid_ds))
	    return -1;
	  break;
	case RECORD_SHMAT:
	  regcache_raw_read (regcache, tdep->arg4,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_ulong))
	    return -1;
	  break;
	case RECORD_SHMCTL:
	  regcache_raw_read (regcache, tdep->arg5,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_shmid_ds))
	    return -1;
	  break;
	}
d1366 4
a1369 3
      regcache_raw_read (regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_new_utsname))
	return -1;
d1374 9
a1382 10
      regcache_raw_read (regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (tmpu32 == 0 || tmpu32 == 2)
	{
	  uint32_t ptr, bytecount;
	  regcache_raw_read (regcache, tdep->arg2, (gdb_byte *) & ptr);
	  regcache_raw_read (regcache, tdep->arg3,
			     (gdb_byte *) & bytecount);
	  if (record_arch_list_add_mem (ptr, bytecount))
	    return -1;
	}
d1387 3
a1389 3
      regcache_raw_read (regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_timex))
	return -1;
d1398 4
a1401 3
      regcache_raw_read (regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_old_sigset_t))
	return -1;
d1416 33
a1448 29
      regcache_raw_read (regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      switch (tmpu32)
	{
	case RECORD_Q_GETFMT:
	  regcache_raw_read (regcache, tdep->arg4,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, 4))
	    return -1;
	  break;
	case RECORD_Q_GETINFO:
	  regcache_raw_read (regcache, tdep->arg4,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_mem_dqinfo))
	    return -1;
	  break;
	case RECORD_Q_GETQUOTA:
	  regcache_raw_read (regcache, tdep->arg4,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_if_dqblk))
	    return -1;
	  break;
	case RECORD_Q_XGETQSTAT:
	case RECORD_Q_XGETQUOTA:
	  regcache_raw_read (regcache, tdep->arg4,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_fs_quota_stat))
	    return -1;
	  break;
	}
d1461 9
a1469 9
      regcache_raw_read (regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (tmpu32 == 2)
	{
	  regcache_raw_read (regcache, tdep->arg3,
			     (gdb_byte *) & tmpu32);
	  /*XXX the size of memory is not very clear.  */
	  if (record_arch_list_add_mem (tmpu32, 10))
	    return -1;
	}
d1484 4
a1487 3
      regcache_raw_read (regcache, tdep->arg4, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_loff_t))
	return -1;
d1493 7
a1499 6
	uint32_t count;
	regcache_raw_read (regcache, tdep->arg2,
			   (gdb_byte *) & tmpu32);
	regcache_raw_read (regcache, tdep->arg3, (gdb_byte *) & count);
	if (record_arch_list_add_mem (tmpu32, tdep->size_dirent * count))
	  return -1;
d1505 16
a1520 12
      regcache_raw_read (regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_fd_set))
	return -1;
      regcache_raw_read (regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_fd_set))
	return -1;
      regcache_raw_read (regcache, tdep->arg4, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_fd_set))
	return -1;
      regcache_raw_read (regcache, tdep->arg5, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_timeval))
	return -1;
d1532 34
a1565 30
	uint32_t vec;
	uint32_t vlen;
	struct record_iovec
	{
	  uint32_t iov_base;
	  uint32_t iov_len;
	} iov;
	regcache_raw_read (regcache, tdep->arg2, (gdb_byte *) & vec);
	if (vec)
	  {
	    regcache_raw_read (regcache, tdep->arg3,
			       (gdb_byte *) & vlen);
	    for (tmpu32 = 0; tmpu32 < vlen; tmpu32++)
	      {
		if (target_read_memory
		    (vec, (gdb_byte *) & iov, sizeof (struct record_iovec)))
		  {
		    if (record_debug)
		      fprintf_unfiltered (gdb_stdlog,
					  "Process record: error reading "
					  "memory at addr = %s len = %lu.\n",
					  paddress (gdbarch, vec),
					  (unsigned long)sizeof (struct record_iovec));
		    return -1;
		  }
		if (record_arch_list_add_mem (iov.iov_base, iov.iov_len))
		  return -1;
		vec += sizeof (struct record_iovec);
	      }
	  }
d1591 3
a1593 3
      regcache_raw_read (regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_int))
	return -1;
d1612 4
a1615 3
      regcache_raw_read (regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_timespec))
	return -1;
d1626 12
a1637 9
      regcache_raw_read (regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_old_uid_t))
	return -1;
      regcache_raw_read (regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_old_uid_t))
	return -1;
      regcache_raw_read (regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_old_uid_t))
	return -1;
d1648 9
a1656 9
      regcache_raw_read (regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  uint32_t nfds;
	  regcache_raw_read (regcache, tdep->arg2,
			     (gdb_byte *) & nfds);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_pollfd * nfds))
	    return -1;
	}
d1661 13
a1673 13
      regcache_raw_read (regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (tmpu32 == 7 || tmpu32 == 8)
	{
	  uint32_t rsize;
	  if (tmpu32 == 7)
	    rsize = tdep->size_NFS_FHSIZE;
	  else
	    rsize = tdep->size_knfsd_fh;
	  regcache_raw_read (regcache, tdep->arg3,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, rsize))
	    return -1;
	}
d1682 12
a1693 9
      regcache_raw_read (regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_old_gid_t))
	return -1;
      regcache_raw_read (regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_old_gid_t))
	return -1;
      regcache_raw_read (regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_old_gid_t))
	return -1;
d1698 18
a1715 16
      regcache_raw_read (regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      switch (tmpu32)
	{
	case 2:
	  regcache_raw_read (regcache, tdep->arg2,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_int))
	    return -1;
	  break;
	case 16:
	  regcache_raw_read (regcache, tdep->arg2,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_TASK_COMM_LEN))
	    return -1;
	  break;
	}
d1724 4
a1727 3
      regcache_raw_read (regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_sigaction))
	return -1;
d1732 4
a1735 3
      regcache_raw_read (regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_sigset_t))
	return -1;
d1740 9
a1748 9
      regcache_raw_read (regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  uint32_t sigsetsize;
	  regcache_raw_read (regcache, tdep->arg2,
			     (gdb_byte *) & sigsetsize);
	  if (record_arch_list_add_mem (tmpu32, sigsetsize))
	    return -1;
	}
d1753 4
a1756 3
      regcache_raw_read (regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_siginfo_t))
	return -1;
d1767 8
a1774 9
      regcache_raw_read (regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  uint32_t count;
	  regcache_raw_read (regcache, tdep->arg3,
			     (gdb_byte *) & count);
	  if (record_arch_list_add_mem (tmpu32, count))
	    return -1;
	}
d1785 8
a1792 9
      regcache_raw_read (regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  uint32_t size;
	  regcache_raw_read (regcache, tdep->arg2,
			     (gdb_byte *) & size);
	  if (record_arch_list_add_mem (tmpu32, size))
	    return -1;
	}
d1797 4
a1800 3
      regcache_raw_read (regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_cap_user_data_t))
	return -1;
d1809 4
a1812 3
      regcache_raw_read (regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_stack_t))
	return -1;
d1817 4
a1820 3
      regcache_raw_read (regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_off_t))
	return -1;
d1833 4
a1836 3
      regcache_raw_read (regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_rlimit))
	return -1;
d1855 4
a1858 3
      regcache_raw_read (regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_stat64))
	return -1;
d1879 10
a1888 10
      regcache_raw_read (regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  int gidsetsize;
	  regcache_raw_read (regcache, tdep->arg1,
			     (gdb_byte *) & gidsetsize);
	  if (record_arch_list_add_mem
	      (tmpu32, tdep->size_gid_t * gidsetsize))
	    return -1;
	}
d1901 9
a1909 9
      regcache_raw_read (regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_uid_t))
	return -1;
      regcache_raw_read (regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_uid_t))
	return -1;
      regcache_raw_read (regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_uid_t))
	return -1;
d1918 9
a1926 9
      regcache_raw_read (regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_gid_t))
	return -1;
      regcache_raw_read (regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_gid_t))
	return -1;
      regcache_raw_read (regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_gid_t))
	return -1;
d1945 4
a1948 3
      regcache_raw_read (regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_PAGE_SIZE))
	return -1;
d1958 7
a1964 6
	uint32_t count;
	regcache_raw_read (regcache, tdep->arg2,
			   (gdb_byte *) & tmpu32);
	regcache_raw_read (regcache, tdep->arg3, (gdb_byte *) & count);
	if (record_arch_list_add_mem (tmpu32, tdep->size_dirent64 * count))
	  return -1;
d1970 2
a1971 2
      regcache_raw_read (regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (tmpu32 == tdep->fcntl_F_GETLK64)
d1973 8
a1980 7
	  regcache_raw_read (regcache, tdep->arg3,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_flock64))
	    return -1;
	}
      else if (tmpu32 != tdep->fcntl_F_SETLK64
	       && tmpu32 != tdep->fcntl_F_SETLKW64)
d1982 2
a1983 2
	  goto sys_fcntl;
	}
d2008 8
a2015 9
      regcache_raw_read (regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  uint32_t size;
	  regcache_raw_read (regcache, tdep->arg4,
			     (gdb_byte *) & size);
	  if (record_arch_list_add_mem (tmpu32, size))
	    return -1;
	}
d2024 8
a2031 9
      regcache_raw_read (regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  uint32_t size;
	  regcache_raw_read (regcache, tdep->arg3,
			     (gdb_byte *) & size);
	  if (record_arch_list_add_mem (tmpu32, size))
	    return -1;
	}
d2046 4
a2049 3
      regcache_raw_read (regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_loff_t))
	return -1;
d2060 8
a2067 8
      regcache_raw_read (regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  uint32_t len;
	  regcache_raw_read (regcache, tdep->arg2, (gdb_byte *) & len);
	  if (record_arch_list_add_mem (tmpu32, len))
	    return -1;
	}
d2072 3
a2074 3
      regcache_raw_read (regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_int))
	return -1;
d2079 4
a2082 3
      regcache_raw_read (regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_user_desc))
	return -1;
d2087 3
a2089 3
      regcache_raw_read (regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_long))
	return -1;
d2098 9
a2106 8
      regcache_raw_read (regcache, tdep->arg4, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  int32_t nr;
	  regcache_raw_read (regcache, tdep->arg3, (gdb_byte *) & nr);
	  if (record_arch_list_add_mem (tmpu32, nr * tdep->size_io_event))
	    return -1;
	}
d2111 30
a2140 24
      regcache_raw_read (regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  int32_t i, nr;
	  uint32_t *iocbp;
	  regcache_raw_read (regcache, tdep->arg2, (gdb_byte *) & nr);
	  iocbp = (uint32_t *) alloca (nr * tdep->size_int);
	  if (target_read_memory
	      (tmpu32, (gdb_byte *) iocbp, nr * tdep->size_int))
	    {
	      if (record_debug)
		fprintf_unfiltered (gdb_stdlog,
				    "Process record: error reading memory "
				    "at addr = %s len = %u.\n",
				    paddress (gdbarch, tmpu32),
				    (int)(nr * tdep->size_int));
	      return -1;
	    }
	  for (i = 0; i < nr; i++)
	    {
	      if (record_arch_list_add_mem (iocbp[i], tdep->size_iocb))
		return -1;
	    }
	}
d2145 4
a2148 3
      regcache_raw_read (regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_io_event))
	return -1;
d2160 8
a2167 9
	int q;
	target_terminal_ours ();
	q =
	  yquery (_("The next instruction is syscall exit_group.  "
		    "It will make the program exit.  "
		    "Do you want to stop the program?"));
	target_terminal_inferior ();
	if (q)
	  return 1;
d2173 8
a2180 8
      regcache_raw_read (regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  uint32_t len;
	  regcache_raw_read (regcache, tdep->arg3, (gdb_byte *) & len);
	  if (record_arch_list_add_mem (tmpu32, len))
	    return -1;
	}
d2191 9
a2199 10
      regcache_raw_read (regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  int32_t maxevents;
	  regcache_raw_read (regcache, tdep->arg3,
			     (gdb_byte *) & maxevents);
	  if (record_arch_list_add_mem
	      (tmpu32, maxevents * tdep->size_epoll_event))
	    return -1;
	}
d2210 3
a2212 3
      regcache_raw_read (regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_int))
	return -1;
d2217 4
a2220 3
      regcache_raw_read (regcache, tdep->arg4, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_itimerspec))
	return -1;
d2225 4
a2228 3
      regcache_raw_read (regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_itimerspec))
	return -1;
d2241 4
a2244 3
      regcache_raw_read (regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_timespec))
	return -1;
d2249 4
a2252 3
      regcache_raw_read (regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_timespec))
	return -1;
d2257 4
a2260 3
      regcache_raw_read (regcache, tdep->arg4, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_timespec))
	return -1;
d2267 4
a2270 3
      regcache_raw_read (regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_statfs64))
	return -1;
d2287 12
a2298 12
      regcache_raw_read (regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_int))
	return -1;
      regcache_raw_read (regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  uint32_t maxnode;
	  regcache_raw_read (regcache, tdep->arg3,
			     (gdb_byte *) & maxnode);
	  if (record_arch_list_add_mem (tmpu32, maxnode * tdep->size_long))
	    return -1;
	}
d2313 12
a2324 12
      regcache_raw_read (regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  uint32_t msg_len;
	  regcache_raw_read (regcache, tdep->arg3,
			     (gdb_byte *) & msg_len);
	  if (record_arch_list_add_mem (tmpu32, msg_len))
	    return -1;
	}
      regcache_raw_read (regcache, tdep->arg4, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_int))
	return -1;
d2333 4
a2336 3
      regcache_raw_read (regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_mq_attr))
	return -1;
d2345 8
a2352 6
      regcache_raw_read (regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_siginfo))
	return -1;
      regcache_raw_read (regcache, tdep->arg5, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_rusage))
	return -1;
d2365 14
a2378 14
      regcache_raw_read (regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (tmpu32 == 6 || tmpu32 == 11)
	{
	  regcache_raw_read (regcache, tdep->arg3,
			     (gdb_byte *) & tmpu32);
	  if (tmpu32)
	    {
	      uint32_t buflen;
	      regcache_raw_read (regcache, tdep->arg4,
				 (gdb_byte *) & buflen);
	      if (record_arch_list_add_mem (tmpu32, buflen))
		return -1;
	    }
	}
d2407 4
a2410 3
      regcache_raw_read (regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_stat64))
	return -1;
d2425 8
a2432 9
      regcache_raw_read (regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  int32_t bufsiz;
	  regcache_raw_read (regcache, tdep->arg4,
			     (gdb_byte *) & bufsiz);
	  if (record_arch_list_add_mem (tmpu32, bufsiz))
	    return -1;
	}
d2443 16
a2458 12
      regcache_raw_read (regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_fd_set))
	return -1;
      regcache_raw_read (regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_fd_set))
	return -1;
      regcache_raw_read (regcache, tdep->arg4, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_fd_set))
	return -1;
      regcache_raw_read (regcache, tdep->arg5, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_timespec))
	return -1;
d2463 13
a2475 12
      regcache_raw_read (regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  uint32_t nfds;
	  regcache_raw_read (regcache, tdep->arg2,
			     (gdb_byte *) & nfds);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_pollfd * nfds))
	    return -1;
	}
      regcache_raw_read (regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_timespec))
	return -1;
d2486 6
a2491 6
      regcache_raw_read (regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_int))
	return -1;
      regcache_raw_read (regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_int))
	return -1;
d2496 8
a2503 6
      regcache_raw_read (regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_loff_t))
	return -1;
      regcache_raw_read (regcache, tdep->arg4, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_loff_t))
	return -1;
d2516 9
a2524 9
      regcache_raw_read (regcache, tdep->arg5, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  uint32_t nr_pages;
	  regcache_raw_read (regcache, tdep->arg2,
			     (gdb_byte *) & nr_pages);
	  if (record_arch_list_add_mem (tmpu32, nr_pages * tdep->size_int))
	    return -1;
	}
d2529 10
a2538 9
      regcache_raw_read (regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_int))
	return -1;
      regcache_raw_read (regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_int))
	return -1;
      regcache_raw_read (regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_ulong * 2))
	return -1;
d2543 9
a2551 10
      regcache_raw_read (regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  int32_t maxevents;
	  regcache_raw_read (regcache, tdep->arg3,
			     (gdb_byte *) & maxevents);
	  if (record_arch_list_add_mem
	      (tmpu32, maxevents * tdep->size_epoll_event))
	    return -1;
	}
d2556 1
a2556 2
			   "support syscall number %u\n"),
			 (int)tmpu32);
@


1.4
log
@	* i386-linux-tdep.c (I386_LINUX_RECORD_SIZE_*,
	I386_LINUX_RECORD_IOCTL_*,
	I386_LINUX_RECORD_FCNTL_*) Removed.
	(i386_linux_init_abi): Change size of record from macros to
	numbers.
	* i386-linux-tdep.c (i386_linux_init_abi): Remove size_char.
	* linux-record.c (record_linux_system_call): Ditto.
	* linux-record.h (linux_record_tdep): Ditto.
@
text
@d99 1
d551 2
a552 2
				      "at addr = 0x%s len = %lu.\n",
				      paddr_nz (tmpu32),
d628 1
a628 1
		    "It will free the memory addr = 0x%s len = %u.  "
d631 1
a631 1
		  paddr_nz (tmpu32), (int)len);
d691 2
a692 2
					  "memory at addr = 0x%s len = %lu.\n",
					  paddr_nz (tmpu32),
d716 2
a717 2
					  "memory at addr = 0x%s len = %lu.\n",
					  paddr_nz (tmpu32),
d741 2
a742 2
					  "memory at addr = 0x%s len = %lu.\n",
					  paddr_nz (tmpu32),
d754 1
a754 1
					      "memory at addr = 0x%s "
d756 1
a756 1
					      paddr_nz (a[2]),
d778 2
a779 2
					  "memory at addr = 0x%s len = %lu.\n",
					  paddr_nz (tmpu32),
d791 1
a791 1
					      "memory at addr = 0x%s "
d793 1
a793 1
					      paddr_nz (a[2]),
d824 2
a825 2
					  "memory at addr = 0x%s len = %lu.\n",
					  paddr_nz (tmpu32),
d837 1
a837 1
					      "memory at addr = 0x%s "
d839 1
a839 1
					      paddr_nz (a[4]),
d881 2
a882 2
					  "memory at addr = 0x%s len = %lu.\n",
					  paddr_nz (tmpu32),
d896 1
a896 1
					      "memory at addr = 0x%s "
d898 1
a898 1
					      paddr_nz (a[1]),
d920 1
a920 1
						      "addr = 0x%s "
d922 2
a923 2
						      paddr_nz (rec.
								msg_iov),
d1238 2
a1239 2
					  "memory at addr = 0x%s len = %lu.\n",
					  paddr_nz (vec),
d1787 2
a1788 2
				    "at addr = 0x%s len = %u.\n",
				    paddr_nz (tmpu32),
@


1.3
log
@	Add sys_fcntl argument interfaces to linux_record_tdep.

	* linux-record.h (linux_record_tdep): Add fcntl_F_GETLK,
	fcntl_F_GETLK64, fcntl_F_SETLK64 and fcntl_F_SETLKW64 to be
	interfaces.
	* i386-linux-tdep.c (I386_LINUX_RECORD_FCNTL_F_GETLK,
	I386_LINUX_RECORD_FCNTL_F_GETLK64,
	I386_LINUX_RECORD_FCNTL_F_SETLK64,
	I386_LINUX_RECORD_FCNTL_F_SETLKW64): New macros. The values
	of I386 Linux sys_fcntl arguments.
	(i386_linux_init_abi): Set macros values to linux_record_tdep.
	* linux-record.c (record_linux_system_call): Change to use
	the interface in linux_record_tdep in sys_fcntl and
	sys_fcntl64.

	* linux-record.c (record_linux_system_call): Fix the process
	record build error about type in CYGWIN.
@
text
@d348 2
a349 1
	  if (record_arch_list_add_mem (tmpu32, tdep->size_char))
@


1.2
log
@Linux process record and replay support.

* Makefile.in (ALLDEPFILES): Add linux-record.c.
(ALL_TARGET_OBS): Add linux-record.o.
* configure.tgt (x86_64-*-linux*): Add linux-record.o.
(i[34567]86-*-linux*): Add linux-record.o.
* linux-record.c, linux-record.h: New file.
@
text
@d396 2
a397 2
			       "support ioctl request 0x%08x.\n"),
			     tmpu32);
d407 1
a407 1
      if (tmpu32 == F_GETLK)
d549 1
a549 1
				      "at addr = 0x%s len = %d.\n",
d551 1
a551 1
				      (int) sizeof (sel));
d626 1
a626 1
		    "It will free the memory addr = 0x%s len = %d.  "
d629 1
a629 1
		  paddr_nz (tmpu32), len);
d689 1
a689 1
					  "memory at addr = 0x%s len = %d.\n",
d691 1
a691 1
					  (int) sizeof (a));
d714 1
a714 1
					  "memory at addr = 0x%s len = %d.\n",
d716 1
a716 1
				          (int) sizeof (a));
d739 1
a739 1
					  "memory at addr = 0x%s len = %d.\n",
d741 1
a741 1
					  (int) sizeof (a));
d753 1
a753 1
					      "len = %d.\n",
d755 1
a755 1
					      (int) sizeof (a[2]));
d776 1
a776 1
					  "memory at addr = 0x%s len = %d.\n",
d778 1
a778 1
					  (int) sizeof (a));
d790 1
a790 1
					      "len = %d.\n",
d792 1
a792 1
					      (int) sizeof (a[2]));
d822 1
a822 1
					  "memory at addr = 0x%s len = %d.\n",
d824 1
a824 1
					  (int) sizeof (a));
d836 1
a836 1
					      "len = %d.\n",
d838 1
a838 1
					      (int) sizeof (av));
d879 1
a879 1
					  "memory at addr = 0x%s len = %d.\n",
d881 1
a881 1
					  (int) sizeof (a));
d895 1
a895 1
					      "len = %d.\n",
d897 1
a897 1
					      (int) sizeof (rec));
d919 1
a919 1
						      "len = %d.\n",
d922 1
a922 1
						      (int) sizeof (iov));
d937 2
a938 2
			       "doesn't support socketcall call 0x%08x\n"),
			     tmpu32);
d1236 1
a1236 1
					  "memory at addr = 0x%s len = %d.\n",
d1238 1
a1238 1
					  (int) sizeof (struct record_iovec));
d1634 2
a1635 3
      switch (tmpu32)
	{
	case F_GETLK64:
d1640 4
a1643 5
	  break;
	case F_SETLK64:
	case F_SETLKW64:
	  break;
	default:
a1644 1
	  break;
d1785 3
a1787 2
				    "at addr = 0x%s len = %d.\n",
				    paddr_nz (tmpu32), nr * tdep->size_int);
d2196 2
a2197 2
			   "support syscall number 0x%08x\n"),
			 tmpu32);
@


1.1
log
@file linux-record.c was initially added on branch reverse-20080717-branch.
@
text
@d1 2205
@


1.1.6.1
log
@2008-12-26  Michael Snyder  <msnyder@@vmware.com>

	* Marker: adding teawater patches to branch.
@
text
@a0 2507
/* Process record and replay target code for GNU/Linux.

   Copyright (C) 2008 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "target.h"
#include "regcache.h"
#include "record.h"
#include "linux-record.h"
#include <stdint.h>

/* These macros are the values of the first argument of system call
   "sys_ptrace". The values of these macros are gotten from Linux Kernel
   source.  */

#define RECORD_PTRACE_PEEKTEXT	1
#define RECORD_PTRACE_PEEKDATA	2
#define RECORD_PTRACE_PEEKUSR	3

/* These macros are the values of the first argument of system call
   "sys_socketcall". The values of these macros are gotten from Linux Kernel
   source.  */

#define RECORD_SYS_SOCKET	1
#define RECORD_SYS_BIND		2
#define RECORD_SYS_CONNECT	3
#define RECORD_SYS_LISTEN	4
#define RECORD_SYS_ACCEPT	5
#define RECORD_SYS_GETSOCKNAME	6
#define RECORD_SYS_GETPEERNAME	7
#define RECORD_SYS_SOCKETPAIR	8
#define RECORD_SYS_SEND		9
#define RECORD_SYS_RECV		10
#define RECORD_SYS_SENDTO	11
#define RECORD_SYS_RECVFROM	12
#define RECORD_SYS_SHUTDOWN	13
#define RECORD_SYS_SETSOCKOPT	14
#define RECORD_SYS_GETSOCKOPT	15
#define RECORD_SYS_SENDMSG	16
#define RECORD_SYS_RECVMSG	17

/* These macros are the values of the first argument of system call
   "sys_ipc". The values of these macros are gotten from Linux Kernel source.
 */

#define RECORD_SEMOP		1
#define RECORD_SEMGET		2
#define RECORD_SEMCTL		3
#define RECORD_SEMTIMEDOP	4
#define RECORD_MSGSND		11
#define RECORD_MSGRCV		12
#define RECORD_MSGGET		13
#define RECORD_MSGCTL		14
#define RECORD_SHMAT		21
#define RECORD_SHMDT		22
#define RECORD_SHMGET		23
#define RECORD_SHMCTL		24

/* These macros are the values of the first argument of system call
   "sys_quotactl". The values of these macros are gotten from Linux Kernel
   source.  */

#define RECORD_Q_GETFMT		0x800004
#define RECORD_Q_GETINFO	0x800005
#define RECORD_Q_GETQUOTA	0x800007
#define RECORD_Q_XGETQSTAT	(('5'<<8)+(5))
#define RECORD_Q_XGETQUOTA	(('3'<<8)+(3))

/* When the architecture process record get a Linux syscall instruction, it
   will get a Linux syscall number of this architecture and convert it to the
   Linux syscall number "num" which is internal to GDB.
   Most Linux syscalls across architectures in Linux would be similar and
   mostly differ by sizes of types and structures.  This sizes are put
   to "tdep".
   Record the values of the registers and memory that will be changed in
   current system call.
   Return -1 if something wrong.  */

int
record_linux_system_call (int num, linux_record_tdep_t * tdep)
{
  uint32_t tmpu32;

  switch (num)
    {
      /* sys_restart_syscall */
    case 0:
      break;

      /* sys_exit */
    case 1:
      {
	int q;
	target_terminal_ours ();
	q =
	  yquery (_
		  ("The next instruction is syscall exit.  It will make the program exit.  Do you want to stop the program?"));
	target_terminal_inferior ();
	if (q)
	  {
	    return (1);
	  }
      }
      break;

      /* sys_fork */
    case 2:
      break;

      /* sys_read */
    case 3:
      {
	uint32_t addr, count;
	regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & addr);
	regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & count);
	if (record_arch_list_add_mem (addr, count))
	  {
	    return (-1);
	  }
      }
      break;

      /* sys_write */
    case 4:
      /* sys_open */
    case 5:
      /* sys_close */
    case 6:
      /* sys_waitpid */
    case 7:
      /* sys_creat */
    case 8:
      /* sys_link */
    case 9:
      /* sys_unlink */
    case 10:
      /* sys_execve */
    case 11:
      /* sys_chdir */
    case 12:
      /* sys_time */
    case 13:
      /* sys_mknod */
    case 14:
      /* sys_chmod */
    case 15:
      /* sys_lchown16 */
    case 16:
      /* sys_ni_syscall */
    case 17:
      break;

      /* sys_stat */
    case 18:
      /* sys_fstat */
    case 28:
      /* sys_lstat */
    case 84:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size__old_kernel_stat))
	{
	  return (-1);
	}
      break;

      /* sys_lseek */
    case 19:
      /* sys_getpid */
    case 20:
      /* sys_mount */
    case 21:
      /* sys_oldumount */
    case 22:
      /* sys_setuid16 */
    case 23:
      /* sys_getuid16 */
    case 24:
      /* sys_stime */
    case 25:
      break;

      /* sys_ptrace */
    case 26:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (tmpu32 == RECORD_PTRACE_PEEKTEXT
	  || tmpu32 == RECORD_PTRACE_PEEKDATA
	  || tmpu32 == RECORD_PTRACE_PEEKUSR)
	{
	  regcache_raw_read (record_regcache, tdep->arg4,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, 4))
	    {
	      return (-1);
	    }
	}
      break;

      /* sys_alarm */
    case 27:
      /* sys_pause */
    case 29:
      /* sys_utime    */
    case 30:
      /* sys_ni_syscall */
    case 31:
      /* sys_ni_syscall */
    case 32:
      /* sys_access */
    case 33:
      /* sys_nice */
    case 34:
      /* sys_ni_syscall */
    case 35:
      /* sys_sync */
    case 36:
      /* sys_kill */
    case 37:
      /* sys_rename */
    case 38:
      /* sys_mkdir */
    case 39:
      /* sys_rmdir */
    case 40:
      /* sys_dup */
    case 41:
      /* sys_pipe */
    case 42:
      break;

      /* sys_times */
    case 43:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_tms))
	{
	  return (-1);
	}
      break;

      /* sys_ni_syscall */
    case 44:
      /* sys_brk */
    case 45:
      /* sys_setgid16 */
    case 46:
      /* sys_getgid16 */
    case 47:
      /* sys_signal */
    case 48:
      /* sys_geteuid16 */
    case 49:
      /* sys_getegid16 */
    case 50:
      /* sys_acct */
    case 51:
      /* sys_umount */
    case 52:
      /* sys_ni_syscall */
    case 53:
      break;

      /* sys_ioctl */
    case 54:
      /* XXX there need add a lot of support of other ioctl requests.  */
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (tmpu32 == tdep->ioctl_FIOCLEX || tmpu32 == tdep->ioctl_FIONCLEX
	  || tmpu32 == tdep->ioctl_FIONBIO || tmpu32 == tdep->ioctl_FIOASYNC
	  || tmpu32 == tdep->ioctl_TCSETS || tmpu32 == tdep->ioctl_TCSETSW
	  || tmpu32 == tdep->ioctl_TCSETSF || tmpu32 == tdep->ioctl_TCSETA
	  || tmpu32 == tdep->ioctl_TCSETAW || tmpu32 == tdep->ioctl_TCSETAF
	  || tmpu32 == tdep->ioctl_TCSBRK || tmpu32 == tdep->ioctl_TCXONC
	  || tmpu32 == tdep->ioctl_TCFLSH || tmpu32 == tdep->ioctl_TIOCEXCL
	  || tmpu32 == tdep->ioctl_TIOCNXCL
	  || tmpu32 == tdep->ioctl_TIOCSCTTY
	  || tmpu32 == tdep->ioctl_TIOCSPGRP || tmpu32 == tdep->ioctl_TIOCSTI
	  || tmpu32 == tdep->ioctl_TIOCSWINSZ
	  || tmpu32 == tdep->ioctl_TIOCMBIS || tmpu32 == tdep->ioctl_TIOCMBIC
	  || tmpu32 == tdep->ioctl_TIOCMSET
	  || tmpu32 == tdep->ioctl_TIOCSSOFTCAR
	  || tmpu32 == tdep->ioctl_TIOCCONS
	  || tmpu32 == tdep->ioctl_TIOCSSERIAL
	  || tmpu32 == tdep->ioctl_TIOCPKT || tmpu32 == tdep->ioctl_TIOCNOTTY
	  || tmpu32 == tdep->ioctl_TIOCSETD || tmpu32 == tdep->ioctl_TCSBRKP
	  || tmpu32 == tdep->ioctl_TIOCTTYGSTRUCT
	  || tmpu32 == tdep->ioctl_TIOCSBRK || tmpu32 == tdep->ioctl_TIOCCBRK
	  || tmpu32 == tdep->ioctl_TCSETS2 || tmpu32 == tdep->ioctl_TCSETSW2
	  || tmpu32 == tdep->ioctl_TCSETSF2
	  || tmpu32 == tdep->ioctl_TIOCSPTLCK
	  || tmpu32 == tdep->ioctl_TIOCSERCONFIG
	  || tmpu32 == tdep->ioctl_TIOCSERGWILD
	  || tmpu32 == tdep->ioctl_TIOCSERSWILD
	  || tmpu32 == tdep->ioctl_TIOCSLCKTRMIOS
	  || tmpu32 == tdep->ioctl_TIOCSERGETMULTI
	  || tmpu32 == tdep->ioctl_TIOCSERSETMULTI
	  || tmpu32 == tdep->ioctl_TIOCMIWAIT
	  || tmpu32 == tdep->ioctl_TIOCSHAYESESP)
	{
	  /* Nothing to do.  */
	}
      else if (tmpu32 == tdep->ioctl_TCGETS || tmpu32 == tdep->ioctl_TCGETA
	       || tmpu32 == tdep->ioctl_TIOCGLCKTRMIOS)
	{
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_termios))
	    {
	      return (-1);
	    }
	}
      else if (tmpu32 == tdep->ioctl_TIOCGPGRP
	       || tmpu32 == tdep->ioctl_TIOCGSID)
	{
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_pid_t))
	    {
	      return (-1);
	    }
	}
      else if (tmpu32 == tdep->ioctl_TIOCOUTQ
	       || tmpu32 == tdep->ioctl_TIOCMGET
	       || tmpu32 == tdep->ioctl_TIOCGSOFTCAR
	       || tmpu32 == tdep->ioctl_FIONREAD
	       || tmpu32 == tdep->ioctl_TIOCINQ
	       || tmpu32 == tdep->ioctl_TIOCGETD
	       || tmpu32 == tdep->ioctl_TIOCGPTN
	       || tmpu32 == tdep->ioctl_TIOCSERGETLSR)
	{
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_int))
	    {
	      return (-1);
	    }
	}
      else if (tmpu32 == tdep->ioctl_TIOCGWINSZ)
	{
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_winsize))
	    {
	      return (-1);
	    }
	}
      else if (tmpu32 == tdep->ioctl_TIOCLINUX)
	{
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_char))
	    {
	      return (-1);
	    }
	}
      else if (tmpu32 == tdep->ioctl_TIOCGSERIAL)
	{
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_serial_struct))
	    {
	      return (-1);
	    }
	}
      else if (tmpu32 == tdep->ioctl_TCGETS2)
	{
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_termios2))
	    {
	      return (-1);
	    }
	}
      else if (tmpu32 == tdep->ioctl_FIOQSIZE)
	{
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_loff_t))
	    {
	      return (-1);
	    }
	}
      else if (tmpu32 == tdep->ioctl_TIOCGICOUNT)
	{
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem
	      (tmpu32, tdep->size_serial_icounter_struct))
	    {
	      return (-1);
	    }
	}
      else if (tmpu32 == tdep->ioctl_TIOCGHAYESESP)
	{
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_hayes_esp_config))
	    {
	      return (-1);
	    }
	}
      else if (tmpu32 == tdep->ioctl_TIOCSERGSTRUCT)
	{
	  printf_unfiltered (_
			     ("Process record and replay target doesn't support ioctl request TIOCSERGSTRUCT\n"));
	  return (1);
	}
      else
	{
	  printf_unfiltered (_
			     ("Process record and replay target doesn't support ioctl request 0x%08x.\n"),
			     tmpu32);
	  return (1);
	}
      break;

      /* sys_fcntl */
    case 55:
      /* XXX */
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
    sys_fcntl:
      if (tmpu32 == F_GETLK)
	{
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_flock))
	    {
	      return (-1);
	    }
	}
      break;

      /* sys_ni_syscall */
    case 56:
      /* sys_setpgid */
    case 57:
      /* sys_ni_syscall */
    case 58:
      break;

      /* sys_olduname */
    case 59:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_oldold_utsname))
	{
	  return (-1);
	}
      break;

      /* sys_umask */
    case 60:
      /* sys_chroot */
    case 61:
      break;

      /* sys_ustat */
    case 62:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_ustat))
	{
	  return (-1);
	}
      break;

      /* sys_dup2 */
    case 63:
      /* sys_getppid */
    case 64:
      /* sys_getpgrp */
    case 65:
      /* sys_setsid */
    case 66:
      break;

      /* sys_sigaction */
    case 67:
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_old_sigaction))
	{
	  return (-1);
	}
      break;

      /* sys_sgetmask */
    case 68:
      /* sys_ssetmask */
    case 69:
      /* sys_setreuid16 */
    case 70:
      /* sys_setregid16 */
    case 71:
      /* sys_sigsuspend */
    case 72:
      break;

      /* sys_sigpending */
    case 73:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_old_sigset_t))
	{
	  return (-1);
	}
      break;

      /* sys_sethostname */
    case 74:
      /* sys_setrlimit */
    case 75:
      break;

      /* sys_old_getrlimit */
    case 76:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_rlimit))
	{
	  return (-1);
	}
      break;

      /* sys_getrusage */
    case 77:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_rusage))
	{
	  return (-1);
	}
      break;

      /* sys_gettimeofday */
    case 78:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_timeval))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_timezone))
	{
	  return (-1);
	}
      break;

      /* sys_settimeofday */
    case 79:
      break;

      /* sys_getgroups16 */
    case 80:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_old_gid_t))
	{
	  return (-1);
	}
      break;

      /* sys_setgroups16 */
    case 81:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_old_gid_t))
	{
	  return (-1);
	}
      break;

      /* old_select */
    case 82:
      {
	struct sel_arg_struct
	{
	  CORE_ADDR n;
	  CORE_ADDR inp;
	  CORE_ADDR outp;
	  CORE_ADDR exp;
	  CORE_ADDR tvp;
	} sel;

	regcache_raw_read (record_regcache, tdep->arg1,
			   (gdb_byte *) & tmpu32);
	if (tmpu32)
	  {
	    if (target_read_memory (tmpu32, (gdb_byte *) & sel, sizeof (sel)))
	      {
		if (record_debug)
		  {
		    fprintf_unfiltered (gdb_stdlog,
					"Process record: error reading memory at addr = 0x%s len = %d.\n",
					paddr_nz (tmpu32), sizeof (sel));
		  }
		return (-1);
	      }
	    if (record_arch_list_add_mem (sel.inp, tdep->size_fd_set))
	      {
		return (-1);
	      }
	    if (record_arch_list_add_mem (sel.outp, tdep->size_fd_set))
	      {
		return (-1);
	      }
	    if (record_arch_list_add_mem (sel.exp, tdep->size_fd_set))
	      {
		return (-1);
	      }
	    if (record_arch_list_add_mem (sel.tvp, tdep->size_timeval))
	      {
		return (-1);
	      }
	  }
      }
      break;

      /* sys_symlink */
    case 83:
      break;

      /* sys_readlink */
    case 85:
      {
	uint32_t len;
	regcache_raw_read (record_regcache, tdep->arg2,
			   (gdb_byte *) & tmpu32);
	regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & len);
	if (record_arch_list_add_mem (tmpu32, len))
	  {
	    return (-1);
	  }
      }
      break;

      /* sys_uselib */
    case 86:
      /* sys_swapon */
    case 87:
      break;

      /* sys_reboot */
    case 88:
      {
	int q;
	target_terminal_ours ();
	q =
	  yquery (_
		  ("The next instruction is syscall reboot.  It will restart the computer.  Do you want to stop the program?"));
	target_terminal_inferior ();
	if (q)
	  {
	    return (1);
	  }
      }
      break;

      /* old_readdir */
    case 89:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_dirent))
	{
	  return (-1);
	}
      break;

      /* old_mmap */
    case 90:
      break;

      /* sys_munmap */
    case 91:
      {
	int q;
	uint32_t len;

	regcache_raw_read (record_regcache, tdep->arg1,
			   (gdb_byte *) & tmpu32);
	regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & len);
	target_terminal_ours ();
	q =
	  yquery (_
		  ("The next instruction is syscall munmap.  It will free the memory addr = 0x%s len = %d.  It will make record target get error.  Do you want to stop the program?"),
		  paddr_nz (tmpu32), len);
	target_terminal_inferior ();
	if (q)
	  {
	    return (1);
	  }
      }
      break;

      /* sys_truncate */
    case 92:
      /* sys_ftruncate */
    case 93:
      /* sys_fchmod */
    case 94:
      /* sys_fchown16 */
    case 95:
      /* sys_getpriority */
    case 96:
      /* sys_setpriority */
    case 97:
      /* sys_ni_syscall */
    case 98:
      break;

      /* sys_statfs */
    case 99:
      /* sys_fstatfs */
    case 100:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_statfs))
	{
	  return (-1);
	}
      break;

      /* sys_ioperm */
    case 101:
      break;

      /* sys_socketcall */
    case 102:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      switch (tmpu32)
	{
	case RECORD_SYS_SOCKET:
	case RECORD_SYS_BIND:
	case RECORD_SYS_CONNECT:
	case RECORD_SYS_LISTEN:
	  break;
	case RECORD_SYS_ACCEPT:
	case RECORD_SYS_GETSOCKNAME:
	case RECORD_SYS_GETPEERNAME:
	  {
	    uint32_t a[3];
	    regcache_raw_read (record_regcache, tdep->arg2,
			       (gdb_byte *) & tmpu32);
	    if (tmpu32)
	      {
		if (target_read_memory (tmpu32, (gdb_byte *) a, sizeof (a)))
		  {
		    if (record_debug)
		      {
		        fprintf_unfiltered (gdb_stdlog,
					    "Process record: error reading memory at addr = 0x%s len = %d.\n",
					    paddr_nz (tmpu32), sizeof (a));
		      }
		    return (-1);
		  }
		if (record_arch_list_add_mem (a[1], tdep->size_sockaddr))
		  {
		    return (-1);
		  }
		if (record_arch_list_add_mem (a[2], tdep->size_int))
		  {
		    return (-1);
		  }
	      }
	  }
	  break;

	case RECORD_SYS_SOCKETPAIR:
	  {
	    uint32_t a[4];
	    regcache_raw_read (record_regcache, tdep->arg2,
			       (gdb_byte *) & tmpu32);
	    if (tmpu32)
	      {
		if (target_read_memory (tmpu32, (gdb_byte *) a, sizeof (a)))
		  {
		    if (record_debug)
		      {
		        fprintf_unfiltered (gdb_stdlog,
					    "Process record: error reading memory at addr = 0x%s len = %d.\n",
					    paddr_nz (tmpu32), sizeof (a));
		      }
		    return (-1);
		  }
		if (record_arch_list_add_mem (a[3], tdep->size_int))
		  {
		    return (-1);
		  }
	      }
	  }
	  break;
	case RECORD_SYS_SEND:
	case RECORD_SYS_SENDTO:
	  break;
	case RECORD_SYS_RECV:
	  {
	    uint32_t a[3];
	    regcache_raw_read (record_regcache, tdep->arg2,
			       (gdb_byte *) & tmpu32);
	    if (tmpu32)
	      {
		if (target_read_memory (tmpu32, (gdb_byte *) a, sizeof (a)))
		  {
		    if (record_debug)
		      {
		        fprintf_unfiltered (gdb_stdlog,
					    "Process record: error reading memory at addr = 0x%s len = %d.\n",
					    paddr_nz (tmpu32), sizeof (a));
		      }
		    return (-1);
		  }
		if (a[2])
		  {
		    if (target_read_memory
			(a[2], (gdb_byte *) & (a[2]), sizeof (a[2])))
		      {
			if (record_debug)
			  {
			    fprintf_unfiltered (gdb_stdlog,
						"Process record: error reading memory at addr = 0x%s len = %d.\n",
						paddr_nz (a[2]), sizeof (a[2]));
			  }
			return (-1);
		      }
		    if (record_arch_list_add_mem (a[1], a[2]))
		      {
			return (-1);
		      }
		  }
	      }
	  }
	  break;
	case RECORD_SYS_RECVFROM:
	  {
	    uint32_t a[6];
	    regcache_raw_read (record_regcache, tdep->arg2,
			       (gdb_byte *) & tmpu32);
	    if (tmpu32)
	      {
		if (target_read_memory (tmpu32, (gdb_byte *) a, sizeof (a)))
		  {
		    if (record_debug)
		      {
			fprintf_unfiltered (gdb_stdlog,
					    "Process record: error reading memory at addr = 0x%s len = %d.\n",
					    paddr_nz (tmpu32), sizeof (a));
		      }
		    return (-1);
		  }
		if (a[2])
		  {
		    if (target_read_memory
			(a[2], (gdb_byte *) & (a[2]), sizeof (a[2])))
		      {
			if (record_debug)
			  {
			    fprintf_unfiltered (gdb_stdlog,
						"Process record: error reading memory at addr = 0x%s len = %d.\n",
						paddr_nz (a[2]),
						sizeof (a[2]));
			  }
			return (-1);
		      }
		    if (record_arch_list_add_mem (a[1], a[2]))
		      {
			return (-1);
		      }
		    if (record_arch_list_add_mem (a[4], tdep->size_sockaddr))
		      {
			return (-1);
		      }
		    if (record_arch_list_add_mem (a[5], tdep->size_int))
		      {
			return (-1);
		      }
		  }
	      }
	  }
	  break;
	case RECORD_SYS_SHUTDOWN:
	case RECORD_SYS_SETSOCKOPT:
	  break;
	case RECORD_SYS_GETSOCKOPT:
	  {
	    uint32_t a[5];
	    uint32_t av;

	    regcache_raw_read (record_regcache, tdep->arg2,
			       (gdb_byte *) & tmpu32);
	    if (tmpu32)
	      {
		if (target_read_memory (tmpu32, (gdb_byte *) a, sizeof (a)))
		  {
		    if (record_debug)
		      {
			fprintf_unfiltered (gdb_stdlog,
					    "Process record: error reading memory at addr = 0x%s len = %d.\n",
					    paddr_nz (tmpu32), sizeof (a));
		      }
		    return (-1);
		  }
		if (a[4])
		  {
		    if (target_read_memory
			(a[4], (gdb_byte *) & av, sizeof (av)))
		      {
			if (record_debug)
			  {
			    fprintf_unfiltered (gdb_stdlog,
						"Process record: error reading memory at addr = 0x%s len = %d.\n",
						paddr_nz (a[4]), sizeof (av));
			  }
			return (-1);
		      }
		    if (record_arch_list_add_mem (a[3], av))
		      {
			return (-1);
		      }
		    if (record_arch_list_add_mem (a[4], tdep->size_int))
		      {
			return (-1);
		      }
		  }
	      }
	  }
	  break;
	case RECORD_SYS_SENDMSG:
	  break;
	case RECORD_SYS_RECVMSG:
	  {
	    uint32_t a[2], i;
	    struct record_msghdr
	    {
	      uint32_t msg_name;
	      uint32_t msg_namelen;
	      uint32_t msg_iov;
	      uint32_t msg_iovlen;
	      uint32_t msg_control;
	      uint32_t msg_controllen;
	      uint32_t msg_flags;
	    } rec;
	    struct record_iovec
	    {
	      uint32_t iov_base;
	      uint32_t iov_len;
	    } iov;

	    regcache_raw_read (record_regcache, tdep->arg2,
			       (gdb_byte *) & tmpu32);
	    if (tmpu32)
	      {
		if (target_read_memory (tmpu32, (gdb_byte *) a, sizeof (a)))
		  {
		    if (record_debug)
		      {
			fprintf_unfiltered (gdb_stdlog,
					    "Process record: error reading memory at addr = 0x%s len = %d.\n",
					    paddr_nz (tmpu32), sizeof (a));
		      }
		    return (-1);
		  }
		if (record_arch_list_add_mem (a[1], tdep->size_msghdr))
		  {
		    return (-1);
		  }
		if (a[1])
		  {
		    if (target_read_memory
			(a[1], (gdb_byte *) & rec, sizeof (rec)))
		      {
			if (record_debug)
			  {
			    fprintf_unfiltered (gdb_stdlog,
						"Process record: error reading memory at addr = 0x%s len = %d.\n",
						paddr_nz (a[1]),
						sizeof (rec));
			  }
			return (-1);
		      }
		    if (record_arch_list_add_mem
			(rec.msg_name, rec.msg_namelen))
		      {
			return (-1);
		      }
		    if (record_arch_list_add_mem
			(rec.msg_control, rec.msg_controllen))
		      {
			return (-1);
		      }
		    if (rec.msg_iov)
		      {
			for (i = 0; i < rec.msg_iovlen; i++)
			  {
			    if (target_read_memory
				(rec.msg_iov, (gdb_byte *) & iov,
				 sizeof (iov)))
			      {
				if (record_debug)
				  {
				    fprintf_unfiltered (gdb_stdlog,
							"Process record: error reading memory at addr = 0x%s len = %d.\n",
							paddr_nz (rec.
								  msg_iov),
							sizeof (iov));
				  }
				return (-1);
			      }
			    if (record_arch_list_add_mem
				(iov.iov_base, iov.iov_len))
			      {
				return (-1);
			      }
			    rec.msg_iov += sizeof (struct record_iovec);
			  }
		      }
		  }
	      }
	  }
	  break;
	default:
	  printf_unfiltered (_
			     ("Process record and replay target doesn't support socketcall call 0x%08x\n"),
			     tmpu32);
	  return (-1);
	  break;
	}
      break;

      /* sys_syslog */
    case 103:
      break;

      /* sys_setitimer */
    case 104:
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_itimerval))
	{
	  return (-1);
	}
      break;

      /* sys_getitimer */
    case 105:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_itimerval))
	{
	  return (-1);
	}
      break;

      /* sys_newstat */
    case 106:
      /* sys_newlstat */
    case 107:
      /* sys_newfstat */
    case 108:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_stat))
	{
	  return (-1);
	}
      break;

      /* sys_uname */
    case 109:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_old_utsname))
	{
	  return (-1);
	}
      break;

      /* sys_iopl */
    case 110:
      /* sys_vhangup */
    case 111:
      /* sys_ni_syscall */
    case 112:
      /* sys_vm86old */
    case 113:
      break;

      /* sys_wait4 */
    case 114:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_int))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg4, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_rusage))
	{
	  return (-1);
	}
      break;

      /* sys_swapoff */
    case 115:
      break;

      /* sys_sysinfo */
    case 116:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_sysinfo))
	{
	  return (-1);
	}
      break;

      /* sys_ipc */
    case 117:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      switch (tmpu32)
	{
	case RECORD_MSGRCV:
	  {
	    int32_t second;
	    uint32_t ptr;
	    regcache_raw_read (record_regcache, tdep->arg3,
			       (gdb_byte *) & second);
	    regcache_raw_read (record_regcache, tdep->arg5,
			       (gdb_byte *) & ptr);
	    if (record_arch_list_add_mem (ptr, second + tdep->size_long))
	      {
		return (-1);
	      }
	  }
	  break;
	case RECORD_MSGCTL:
	  regcache_raw_read (record_regcache, tdep->arg5,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_msqid_ds))
	    {
	      return (-1);
	    }
	  break;
	case RECORD_SHMAT:
	  regcache_raw_read (record_regcache, tdep->arg4,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_ulong))
	    {
	      return (-1);
	    }
	  break;
	case RECORD_SHMCTL:
	  regcache_raw_read (record_regcache, tdep->arg5,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_shmid_ds))
	    {
	      return (-1);
	    }
	  break;
	}
      break;

      /* sys_fsync */
    case 118:
      /* sys_sigreturn */
    case 119:
      /* sys_clone */
    case 120:
      /* sys_setdomainname */
    case 121:
      break;

      /* sys_newuname */
    case 122:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_new_utsname))
	{
	  return (-1);
	}
      break;

      /* sys_modify_ldt */
    case 123:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (tmpu32 == 0 || tmpu32 == 2)
	{
	  uint32_t ptr, bytecount;
	  regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & ptr);
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & bytecount);
	  if (record_arch_list_add_mem (ptr, bytecount))
	    {
	      return (-1);
	    }
	}
      break;

      /* sys_adjtimex */
    case 124:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_timex))
	{
	  return (-1);
	}
      break;

      /* sys_mprotect */
    case 125:
      break;

      /* sys_sigprocmask */
    case 126:
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_old_sigset_t))
	{
	  return (-1);
	}
      break;

      /* sys_ni_syscall */
    case 127:
      /* sys_init_module */
    case 128:
      /* sys_delete_module */
    case 129:
      /* sys_ni_syscall */
    case 130:
      break;

      /* sys_quotactl */
    case 131:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      switch (tmpu32)
	{
	case RECORD_Q_GETFMT:
	  regcache_raw_read (record_regcache, tdep->arg4,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, 4))
	    {
	      return (-1);
	    }
	  break;
	case RECORD_Q_GETINFO:
	  regcache_raw_read (record_regcache, tdep->arg4,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_mem_dqinfo))
	    {
	      return (-1);
	    }
	  break;
	case RECORD_Q_GETQUOTA:
	  regcache_raw_read (record_regcache, tdep->arg4,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_if_dqblk))
	    {
	      return (-1);
	    }
	  break;
	case RECORD_Q_XGETQSTAT:
	case RECORD_Q_XGETQUOTA:
	  regcache_raw_read (record_regcache, tdep->arg4,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_fs_quota_stat))
	    {
	      return (-1);
	    }
	  break;
	}
      break;

      /* sys_getpgid */
    case 132:
      /* sys_fchdir */
    case 133:
      /* sys_bdflush */
    case 134:
      break;

      /* sys_sysfs */
    case 135:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (tmpu32 == 2)
	{
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & tmpu32);
	  /*XXX the size of memory is not very clear */
	  if (record_arch_list_add_mem (tmpu32, 10))
	    {
	      return (-1);
	    }
	}
      break;

      /* sys_personality */
    case 136:
      /* sys_ni_syscall */
    case 137:
      /* sys_setfsuid16 */
    case 138:
      /* sys_setfsgid16 */
    case 139:
      break;

      /* sys_llseek */
    case 140:
      regcache_raw_read (record_regcache, tdep->arg4, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_loff_t))
	{
	  return (-1);
	}
      break;

      /* sys_getdents */
    case 141:
      {
	uint32_t count;
	regcache_raw_read (record_regcache, tdep->arg2,
			   (gdb_byte *) & tmpu32);
	regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & count);
	if (record_arch_list_add_mem (tmpu32, tdep->size_dirent * count))
	  {
	    return (-1);
	  }
      }
      break;

      /* sys_select */
    case 142:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_fd_set))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_fd_set))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg4, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_fd_set))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg5, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_timeval))
	{
	  return (-1);
	}
      break;

      /* sys_flock */
    case 143:
      /* sys_msync */
    case 144:
      break;

      /* sys_readv */
    case 145:
      {
	uint32_t vec;
	uint32_t vlen;
	struct record_iovec
	{
	  uint32_t iov_base;
	  uint32_t iov_len;
	} iov;
	regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & vec);
	if (vec)
	  {
	    regcache_raw_read (record_regcache, tdep->arg3,
			       (gdb_byte *) & vlen);
	    for (tmpu32 = 0; tmpu32 < vlen; tmpu32++)
	      {
		if (target_read_memory
		    (vec, (gdb_byte *) & iov, sizeof (struct record_iovec)))
		  {
		    if (record_debug)
		      {
			fprintf_unfiltered (gdb_stdlog,
					    "Process record: error reading memory at addr = 0x%s len = %d.\n",
					    paddr_nz (vec),
					    sizeof (struct record_iovec));
		      }
		    return (-1);
		  }
		if (record_arch_list_add_mem (iov.iov_base, iov.iov_len))
		  {
		    return (-1);
		  }
		vec += sizeof (struct record_iovec);
	      }
	  }
      }
      break;

      /* sys_writev */
    case 146:
      /* sys_getsid */
    case 147:
      /* sys_fdatasync */
    case 148:
      /* sys_sysctl */
    case 149:
      /* sys_mlock */
    case 150:
      /* sys_munlock */
    case 151:
      /* sys_mlockall */
    case 152:
      /* sys_munlockall */
    case 153:
      /* sys_sched_setparam */
    case 154:
      break;

      /* sys_sched_getparam */
    case 155:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_int))
	{
	  return (-1);
	}
      break;

      /* sys_sched_setscheduler */
    case 156:
      /* sys_sched_getscheduler */
    case 157:
      /* sys_sched_yield */
    case 158:
      /* sys_sched_get_priority_max */
    case 159:
      /* sys_sched_get_priority_min */
    case 160:
      break;

      /* sys_sched_rr_get_interval */
    case 161:
      /* sys_nanosleep */
    case 162:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_timespec))
	{
	  return (-1);
	}
      break;

      /* sys_mremap */
    case 163:
      /* sys_setresuid16 */
    case 164:
      break;

      /* sys_getresuid16 */
    case 165:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_old_uid_t))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_old_uid_t))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_old_uid_t))
	{
	  return (-1);
	}
      break;

      /* sys_vm86 */
    case 166:
      /* sys_ni_syscall */
    case 167:
      break;

      /* sys_poll */
    case 168:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  uint32_t nfds;
	  regcache_raw_read (record_regcache, tdep->arg2,
			     (gdb_byte *) & nfds);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_pollfd * nfds))
	    {
	      return (-1);
	    }
	}
      break;

      /* sys_nfsservctl */
    case 169:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (tmpu32 == 7 || tmpu32 == 8)
	{
	  uint32_t rsize;
	  if (tmpu32 == 7)
	    {
	      rsize = tdep->size_NFS_FHSIZE;
	    }
	  else
	    {
	      rsize = tdep->size_knfsd_fh;
	    }
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, rsize))
	    {
	      return (-1);
	    }
	}
      break;

      /* sys_setresgid16 */
    case 170:
      break;

      /* sys_getresgid16 */
    case 171:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_old_gid_t))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_old_gid_t))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_old_gid_t))
	{
	  return (-1);
	}
      break;

      /* sys_prctl */
    case 172:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      switch (tmpu32)
	{
	case 2:
	  regcache_raw_read (record_regcache, tdep->arg2,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_int))
	    {
	      return (-1);
	    }
	  break;
	case 16:
	  regcache_raw_read (record_regcache, tdep->arg2,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_TASK_COMM_LEN))
	    {
	      return (-1);
	    }
	  break;
	}
      break;

      /* sys_rt_sigreturn */
    case 173:
      break;

      /* sys_rt_sigaction */
    case 174:
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_sigaction))
	{
	  return (-1);
	}
      break;

      /* sys_rt_sigprocmask */
    case 175:
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_sigset_t))
	{
	  return (-1);
	}
      break;

      /* sys_rt_sigpending */
    case 176:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  uint32_t sigsetsize;
	  regcache_raw_read (record_regcache, tdep->arg2,
			     (gdb_byte *) & sigsetsize);
	  if (record_arch_list_add_mem (tmpu32, sigsetsize))
	    {
	      return (-1);
	    }
	}
      break;

      /* sys_rt_sigtimedwait */
    case 177:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_siginfo_t))
	{
	  return (-1);
	}
      break;

      /* sys_rt_sigqueueinfo */
    case 178:
      /* sys_rt_sigsuspend */
    case 179:
      break;

      /* sys_pread64 */
    case 180:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  uint32_t count;
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & count);
	  if (record_arch_list_add_mem (tmpu32, count))
	    {
	      return (-1);
	    }
	}
      break;

      /* sys_pwrite64 */
    case 181:
      /* sys_chown16 */
    case 182:
      break;

      /* sys_getcwd */
    case 183:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  uint32_t size;
	  regcache_raw_read (record_regcache, tdep->arg2,
			     (gdb_byte *) & size);
	  if (record_arch_list_add_mem (tmpu32, size))
	    {
	      return (-1);
	    }
	}
      break;

      /* sys_capget */
    case 184:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_cap_user_data_t))
	{
	  return (-1);
	}
      break;

      /* sys_capset */
    case 185:
      break;

      /* sys_sigaltstack */
    case 186:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_stack_t))
	{
	  return (-1);
	}
      break;

      /* sys_sendfile */
    case 187:
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_off_t))
	{
	  return (-1);
	}
      break;

      /* sys_ni_syscall */
    case 188:
      /* sys_ni_syscall */
    case 189:
      /* sys_vfork */
    case 190:
      break;

      /* sys_getrlimit */
    case 191:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_rlimit))
	{
	  return (-1);
	}
      break;

      /* sys_mmap2 */
    case 192:
      break;

      /* sys_truncate64 */
    case 193:
      /* sys_ftruncate64 */
    case 194:
      break;

      /* sys_stat64 */
    case 195:
      /* sys_lstat64 */
    case 196:
      /* sys_fstat64 */
    case 197:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_stat64))
	{
	  return (-1);
	}
      break;

      /* sys_lchown */
    case 198:
      /* sys_getuid */
    case 199:
      /* sys_getgid */
    case 200:
      /* sys_geteuid */
    case 201:
      /* sys_getegid */
    case 202:
      /* sys_setreuid */
    case 203:
      /* sys_setregid */
    case 204:
      break;

      /* sys_getgroups */
    case 205:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  int gidsetsize;
	  regcache_raw_read (record_regcache, tdep->arg1,
			     (gdb_byte *) & gidsetsize);
	  if (record_arch_list_add_mem
	      (tmpu32, tdep->size_gid_t * gidsetsize))
	    {
	      return (-1);
	    }
	}
      break;

      /* sys_setgroups */
    case 206:
      /* sys_fchown */
    case 207:
      /* sys_setresuid */
    case 208:
      break;

      /* sys_getresuid */
    case 209:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_uid_t))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_uid_t))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_uid_t))
	{
	  return (-1);
	}
      break;

      /* sys_setresgid */
    case 210:
      break;

      /* sys_getresgid */
    case 211:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_gid_t))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_gid_t))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_gid_t))
	{
	  return (-1);
	}
      break;

      /* sys_chown */
    case 212:
      /* sys_setuid */
    case 213:
      /* sys_setgid */
    case 214:
      /* sys_setfsuid */
    case 215:
      /* sys_setfsgid */
    case 216:
      /* sys_pivot_root */
    case 217:
      break;

      /* sys_mincore */
    case 218:
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_PAGE_SIZE))
	{
	  return (-1);
	}
      break;

      /* sys_madvise */
    case 219:
      break;

      /* sys_getdents64 */
    case 220:
      {
	uint32_t count;
	regcache_raw_read (record_regcache, tdep->arg2,
			   (gdb_byte *) & tmpu32);
	regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & count);
	if (record_arch_list_add_mem (tmpu32, tdep->size_dirent64 * count))
	  {
	    return (-1);
	  }
      }
      break;

      /* sys_fcntl64 */
    case 221:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      switch (tmpu32)
	{
	case F_GETLK64:
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_flock64))
	    {
	      return (-1);
	    }
	  break;
	case F_SETLK64:
	case F_SETLKW64:
	  break;
	default:
	  goto sys_fcntl;
	  break;
	}
      break;

      /* sys_ni_syscall */
    case 222:
      /* sys_ni_syscall */
    case 223:
      /* sys_gettid */
    case 224:
      /* sys_readahead */
    case 225:
      /* sys_setxattr */
    case 226:
      /* sys_lsetxattr */
    case 227:
      /* sys_fsetxattr */
    case 228:
      break;

      /* sys_getxattr */
    case 229:
      /* sys_lgetxattr */
    case 230:
      /* sys_fgetxattr */
    case 231:
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  uint32_t size;
	  regcache_raw_read (record_regcache, tdep->arg4,
			     (gdb_byte *) & size);
	  if (record_arch_list_add_mem (tmpu32, size))
	    {
	      return (-1);
	    }
	}
      break;

      /* sys_listxattr */
    case 232:
      /* sys_llistxattr */
    case 233:
      /* sys_flistxattr */
    case 234:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  uint32_t size;
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & size);
	  if (record_arch_list_add_mem (tmpu32, size))
	    {
	      return (-1);
	    }
	}
      break;

      /* sys_removexattr */
    case 235:
      /* sys_lremovexattr */
    case 236:
      /* sys_fremovexattr */
    case 237:
      /* sys_tkill */
    case 238:
      break;

      /* sys_sendfile64 */
    case 239:
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_loff_t))
	{
	  return (-1);
	}
      break;

      /* sys_futex */
    case 240:
      /* sys_sched_setaffinity */
    case 241:
      break;

      /* sys_sched_getaffinity */
    case 242:
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  uint32_t len;
	  regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & len);
	  if (record_arch_list_add_mem (tmpu32, len))
	    {
	      return (-1);
	    }
	}
      break;

      /* sys_set_thread_area */
    case 243:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_int))
	{
	  return (-1);
	}
      break;

      /* sys_get_thread_area */
    case 244:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_user_desc))
	{
	  return (-1);
	}
      break;

      /* sys_io_setup */
    case 245:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_long))
	{
	  return (-1);
	}
      break;

      /* sys_io_destroy */
    case 246:
      break;

      /* sys_io_getevents */
    case 247:
      regcache_raw_read (record_regcache, tdep->arg4, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  int32_t nr;
	  regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & nr);
	  if (record_arch_list_add_mem (tmpu32, nr * tdep->size_io_event))
	    {
	      return (-1);
	    }
	}
      break;

      /* sys_io_submit */
    case 248:
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  int32_t i, nr;
	  uint32_t *iocbp;
	  regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & nr);
	  iocbp = (uint32_t *) alloca (nr * tdep->size_int);
	  if (target_read_memory
	      (tmpu32, (gdb_byte *) iocbp, nr * tdep->size_int))
	    {
	      if (record_debug)
		{
		  fprintf_unfiltered (gdb_stdlog,
				      "Process record: error reading memory at addr = 0x%s len = %d.\n",
				      paddr_nz (tmpu32), nr * tdep->size_int);
		}
	      return (-1);
	    }
	  for (i = 0; i < nr; i++)
	    {
	      if (record_arch_list_add_mem (iocbp[i], tdep->size_iocb))
		{
		  return (-1);
		}
	    }
	}
      break;

      /* sys_io_cancel */
    case 249:
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_io_event))
	{
	  return (-1);
	}
      break;

      /* sys_fadvise64 */
    case 250:
      /* sys_ni_syscall */
    case 251:
      break;

      /* sys_exit_group */
    case 252:
      {
	int q;
	target_terminal_ours ();
	q =
	  yquery (_
		  ("The next instruction is syscall exit_group.  It will make the program exit.  Do you want to stop the program?"));
	target_terminal_inferior ();
	if (q)
	  {
	    return (1);
	  }
      }
      break;

      /* sys_lookup_dcookie */
    case 253:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  uint32_t len;
	  regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & len);
	  if (record_arch_list_add_mem (tmpu32, len))
	    {
	      return (-1);
	    }
	}
      break;

      /* sys_epoll_create */
    case 254:
      /* sys_epoll_ctl */
    case 255:
      break;

      /* sys_epoll_wait */
    case 256:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  int32_t maxevents;
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & maxevents);
	  if (record_arch_list_add_mem
	      (tmpu32, maxevents * tdep->size_epoll_event))
	    {
	      return (-1);
	    }
	}
      break;

      /* sys_remap_file_pages */
    case 257:
      /* sys_set_tid_address */
    case 258:
      break;

      /* sys_timer_create */
    case 259:
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_int))
	{
	  return (-1);
	}
      break;

      /* sys_timer_settime */
    case 260:
      regcache_raw_read (record_regcache, tdep->arg4, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_itimerspec))
	{
	  return (-1);
	}
      break;

      /* sys_timer_gettime */
    case 261:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_itimerspec))
	{
	  return (-1);
	}
      break;

      /* sys_timer_getoverrun */
    case 262:
      /* sys_timer_delete */
    case 263:
      /* sys_clock_settime */
    case 264:
      break;

      /* sys_clock_gettime */
    case 265:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_timespec))
	{
	  return (-1);
	}
      break;

      /* sys_clock_getres */
    case 266:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_timespec))
	{
	  return (-1);
	}
      break;

      /* sys_clock_nanosleep */
    case 267:
      regcache_raw_read (record_regcache, tdep->arg4, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_timespec))
	{
	  return (-1);
	}
      break;

      /* sys_statfs64 */
    case 268:
      /* sys_fstatfs64 */
    case 269:
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_statfs64))
	{
	  return (-1);
	}
      break;

      /* sys_tgkill */
    case 270:
      /* sys_utimes */
    case 271:
      /* sys_fadvise64_64 */
    case 272:
      /* sys_ni_syscall */
    case 273:
      /* sys_mbind */
    case 274:
      break;

      /* sys_get_mempolicy */
    case 275:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_int))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  uint32_t maxnode;
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & maxnode);
	  if (record_arch_list_add_mem (tmpu32, maxnode * tdep->size_long))
	    {
	      return (-1);
	    }
	}
      break;

      /* sys_set_mempolicy */
    case 276:
      /* sys_mq_open */
    case 277:
      /* sys_mq_unlink */
    case 278:
      /* sys_mq_timedsend */
    case 279:
      break;

      /* sys_mq_timedreceive */
    case 280:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  uint32_t msg_len;
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & msg_len);
	  if (record_arch_list_add_mem (tmpu32, msg_len))
	    {
	      return (-1);
	    }
	}
      regcache_raw_read (record_regcache, tdep->arg4, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_int))
	{
	  return (-1);
	}
      break;

      /* sys_mq_notify */
    case 281:
      break;

      /* sys_mq_getsetattr */
    case 282:
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_mq_attr))
	{
	  return (-1);
	}
      break;

      /* sys_kexec_load */
    case 283:
      break;

      /* sys_waitid */
    case 284:
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_siginfo))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg5, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_rusage))
	{
	  return (-1);
	}
      break;

      /* sys_ni_syscall */
    case 285:
      /* sys_add_key */
    case 286:
      /* sys_request_key */
    case 287:
      break;

      /* sys_keyctl */
    case 288:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (tmpu32 == 6 || tmpu32 == 11)
	{
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & tmpu32);
	  if (tmpu32)
	    {
	      uint32_t buflen;
	      regcache_raw_read (record_regcache, tdep->arg4,
				 (gdb_byte *) & buflen);
	      if (record_arch_list_add_mem (tmpu32, buflen))
		{
		  return (-1);
		}
	    }
	}
      break;

      /* sys_ioprio_set */
    case 289:
      /* sys_ioprio_get */
    case 290:
      /* sys_inotify_init */
    case 291:
      /* sys_inotify_add_watch */
    case 292:
      /* sys_inotify_rm_watch */
    case 293:
      /* sys_migrate_pages */
    case 294:
      /* sys_openat */
    case 295:
      /* sys_mkdirat */
    case 296:
      /* sys_mknodat */
    case 297:
      /* sys_fchownat */
    case 298:
      /* sys_futimesat */
    case 299:
      break;

      /* sys_fstatat64 */
    case 300:
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_stat64))
	{
	  return (-1);
	}
      break;

      /* sys_unlinkat */
    case 301:
      /* sys_renameat */
    case 302:
      /* sys_linkat */
    case 303:
      /* sys_symlinkat */
    case 304:
      break;

      /* sys_readlinkat */
    case 305:
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  int32_t bufsiz;
	  regcache_raw_read (record_regcache, tdep->arg4,
			     (gdb_byte *) & bufsiz);
	  if (record_arch_list_add_mem (tmpu32, bufsiz))
	    {
	      return (-1);
	    }
	}
      break;

      /* sys_fchmodat */
    case 306:
      /* sys_faccessat */
    case 307:
      break;

      /* sys_pselect6 */
    case 308:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_fd_set))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_fd_set))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg4, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_fd_set))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg5, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_timespec))
	{
	  return (-1);
	}
      break;

      /* sys_ppoll */
    case 309:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  uint32_t nfds;
	  regcache_raw_read (record_regcache, tdep->arg2,
			     (gdb_byte *) & nfds);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_pollfd * nfds))
	    {
	      return (-1);
	    }
	}
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_timespec))
	{
	  return (-1);
	}
      break;

      /* sys_unshare */
    case 310:
      /* sys_set_robust_list */
    case 311:
      break;

      /* sys_get_robust_list */
    case 312:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_int))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_int))
	{
	  return (-1);
	}
      break;

      /* sys_splice */
    case 313:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_loff_t))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg4, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_loff_t))
	{
	  return (-1);
	}
      break;

      /* sys_sync_file_range */
    case 314:
      /* sys_tee */
    case 315:
      /* sys_vmsplice */
    case 316:
      break;

      /* sys_move_pages */
    case 317:
      regcache_raw_read (record_regcache, tdep->arg5, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  uint32_t nr_pages;
	  regcache_raw_read (record_regcache, tdep->arg2,
			     (gdb_byte *) & nr_pages);
	  if (record_arch_list_add_mem (tmpu32, nr_pages * tdep->size_int))
	    {
	      return (-1);
	    }
	}
      break;

      /* sys_getcpu */
    case 318:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_int))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_int))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_ulong * 2))
	{
	  return (-1);
	}
      break;

      /* sys_epoll_pwait */
    case 319:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  int32_t maxevents;
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & maxevents);
	  if (record_arch_list_add_mem
	      (tmpu32, maxevents * tdep->size_epoll_event))
	    {
	      return (-1);
	    }
	}
      break;

    default:
      printf_unfiltered (_
			 ("Process record and replay target doesn't support syscall number 0x%08x\n"),
			 tmpu32);
      return (-1);
      break;
    }

  return (0);
}
@


1.1.6.2
log
@2008-12-28  Michael Snyder  <msnyder@@vmware.com>

	* Comments, spelling, white space clean-ups.
@
text
@d28 2
a29 2
   "sys_ptrace".  The values of these macros were obtained from Linux 
   Kernel source.  */
d36 2
a37 2
   "sys_socketcall".  The values of these macros were obtained from 
   Linux Kernel source.  */
d58 2
a59 2
   "sys_ipc".  The values of these macros were obtained from Linux 
   Kernel source.  */
d75 2
a76 2
   "sys_quotactl".  The values of these macros were obtained from Linux
   Kernel source.  */
d81 2
a82 12
#define RECORD_Q_XGETQSTAT	(('5' << 8) + 5)
#define RECORD_Q_XGETQUOTA	(('3' << 8) + 3)

/* When the architecture process record get a Linux syscall
   instruction, it will get a Linux syscall number of this
   architecture and convert it to the Linux syscall number "num" which
   is internal to GDB.  Most Linux syscalls across architectures in
   Linux would be similar and mostly differ by sizes of types and
   structures.  This sizes are put to "tdep".

   Record the values of the registers and memory that will be changed
   in current system call.
d84 8
d278 1
a278 1
      /* XXX Need to add a lot of support of other ioctl requests.  */
d1281 1
a1281 1
	  /*XXX the size of memory is not very clear.  */
@


1.1.4.1
log
@2008-09-30  Hui Zhu  <teawater@@gmail.com>

	Add process record and replay to Linux.
	* linux-record.c, linux-record.h: New files.
	* config/i386/linux.mh: Add linux-record.o to NATDEPFILES.
	* Makefile.in: Add files linux-record.c, linux-record.o.
@
text
@a0 2465
/* Record and reverse target code for GNU/Linux.

   Copyright (C) 2008 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "target.h"
#include "regcache.h"
#include "record.h"
#include "linux-record.h"
#include <stdint.h>

/* These macros are the values of the first argument of system call
   "sys_ptrace". The values of these macros are gotten from Linux Kernel
   source.  */

#define RECORD_PTRACE_PEEKTEXT	1
#define RECORD_PTRACE_PEEKDATA	2
#define RECORD_PTRACE_PEEKUSR	3

/* These macros are the values of the first argument of system call
   "sys_socketcall". The values of these macros are gotten from Linux Kernel
   source.  */

#define RECORD_SYS_SOCKET	1
#define RECORD_SYS_BIND		2
#define RECORD_SYS_CONNECT	3
#define RECORD_SYS_LISTEN	4
#define RECORD_SYS_ACCEPT	5
#define RECORD_SYS_GETSOCKNAME	6
#define RECORD_SYS_GETPEERNAME	7
#define RECORD_SYS_SOCKETPAIR	8
#define RECORD_SYS_SEND		9
#define RECORD_SYS_RECV		10
#define RECORD_SYS_SENDTO	11
#define RECORD_SYS_RECVFROM	12
#define RECORD_SYS_SHUTDOWN	13
#define RECORD_SYS_SETSOCKOPT	14
#define RECORD_SYS_GETSOCKOPT	15
#define RECORD_SYS_SENDMSG	16
#define RECORD_SYS_RECVMSG	17

/* These macros are the values of the first argument of system call
   "sys_ipc". The values of these macros are gotten from Linux Kernel source.
 */

#define RECORD_SEMOP		1
#define RECORD_SEMGET		2
#define RECORD_SEMCTL		3
#define RECORD_SEMTIMEDOP	4
#define RECORD_MSGSND		11
#define RECORD_MSGRCV		12
#define RECORD_MSGGET		13
#define RECORD_MSGCTL		14
#define RECORD_SHMAT		21
#define RECORD_SHMDT		22
#define RECORD_SHMGET		23
#define RECORD_SHMCTL		24

/* These macros are the values of the first argument of system call
   "sys_quotactl". The values of these macros are gotten from Linux Kernel
   source.  */

#define RECORD_Q_GETFMT		0x800004
#define RECORD_Q_GETINFO	0x800005
#define RECORD_Q_GETQUOTA	0x800007
#define RECORD_Q_XGETQSTAT	(('5'<<8)+(5))
#define RECORD_Q_XGETQUOTA	(('3'<<8)+(3))

/* Record the values of the registers and memory that will be changed in
   current system call.
   Return -1 if something wrong.  */

int
record_linux_system_call (int num, linux_record_tdep_t * tdep)
{
  uint32_t tmpu32;

  switch (num)
    {
      /* sys_restart_syscall */
    case 0:
      break;

      /* sys_exit */
    case 1:
      {
	int q;
	target_terminal_ours ();
	q =
	  yquery (_
		  ("The next instruction is syscall exit.  It will make the program exit.  Do you want to stop the program."));
	target_terminal_inferior ();
	if (q)
	  {
	    return (1);
	  }
      }
      break;

      /* sys_fork */
    case 2:
      break;

      /* sys_read */
    case 3:
      {
	uint32_t addr, count;
	regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & addr);
	regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & count);
	if (record_arch_list_add_mem (addr, count))
	  {
	    return (-1);
	  }
      }
      break;

      /* sys_write */
    case 4:
      /* sys_open */
    case 5:
      /* sys_close */
    case 6:
      /* sys_waitpid */
    case 7:
      /* sys_creat */
    case 8:
      /* sys_link */
    case 9:
      /* sys_unlink */
    case 10:
      /* sys_execve */
    case 11:
      /* sys_chdir */
    case 12:
      /* sys_time */
    case 13:
      /* sys_mknod */
    case 14:
      /* sys_chmod */
    case 15:
      /* sys_lchown16 */
    case 16:
      /* sys_ni_syscall */
    case 17:
      break;

      /* sys_stat */
    case 18:
      /* sys_fstat */
    case 28:
      /* sys_lstat */
    case 84:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size__old_kernel_stat))
	{
	  return (-1);
	}
      break;

      /* sys_lseek */
    case 19:
      /* sys_getpid */
    case 20:
      /* sys_mount */
    case 21:
      /* sys_oldumount */
    case 22:
      /* sys_setuid16 */
    case 23:
      /* sys_getuid16 */
    case 24:
      /* sys_stime */
    case 25:
      break;

      /* sys_ptrace */
    case 26:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (tmpu32 == RECORD_PTRACE_PEEKTEXT
	  || tmpu32 == RECORD_PTRACE_PEEKDATA
	  || tmpu32 == RECORD_PTRACE_PEEKUSR)
	{
	  regcache_raw_read (record_regcache, tdep->arg4,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, 4))
	    {
	      return (-1);
	    }
	}
      break;

      /* sys_alarm */
    case 27:
      /* sys_pause */
    case 29:
      /* sys_utime    */
    case 30:
      /* sys_ni_syscall */
    case 31:
      /* sys_ni_syscall */
    case 32:
      /* sys_access */
    case 33:
      /* sys_nice */
    case 34:
      /* sys_ni_syscall */
    case 35:
      /* sys_sync */
    case 36:
      /* sys_kill */
    case 37:
      /* sys_rename */
    case 38:
      /* sys_mkdir */
    case 39:
      /* sys_rmdir */
    case 40:
      /* sys_dup */
    case 41:
      /* sys_pipe */
    case 42:
      break;

      /* sys_times */
    case 43:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_tms))
	{
	  return (-1);
	}
      break;

      /* sys_ni_syscall */
    case 44:
      /* sys_brk */
    case 45:
      /* sys_setgid16 */
    case 46:
      /* sys_getgid16 */
    case 47:
      /* sys_signal */
    case 48:
      /* sys_geteuid16 */
    case 49:
      /* sys_getegid16 */
    case 50:
      /* sys_acct */
    case 51:
      /* sys_umount */
    case 52:
      /* sys_ni_syscall */
    case 53:
      break;

      /* sys_ioctl */
    case 54:
      /* XXX there need add a lot of support of other ioctl requests.  */
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (tmpu32 == tdep->ioctl_FIOCLEX || tmpu32 == tdep->ioctl_FIONCLEX
	  || tmpu32 == tdep->ioctl_FIONBIO || tmpu32 == tdep->ioctl_FIOASYNC
	  || tmpu32 == tdep->ioctl_TCSETS || tmpu32 == tdep->ioctl_TCSETSW
	  || tmpu32 == tdep->ioctl_TCSETSF || tmpu32 == tdep->ioctl_TCSETA
	  || tmpu32 == tdep->ioctl_TCSETAW || tmpu32 == tdep->ioctl_TCSETAF
	  || tmpu32 == tdep->ioctl_TCSBRK || tmpu32 == tdep->ioctl_TCXONC
	  || tmpu32 == tdep->ioctl_TCFLSH || tmpu32 == tdep->ioctl_TIOCEXCL
	  || tmpu32 == tdep->ioctl_TIOCNXCL
	  || tmpu32 == tdep->ioctl_TIOCSCTTY
	  || tmpu32 == tdep->ioctl_TIOCSPGRP || tmpu32 == tdep->ioctl_TIOCSTI
	  || tmpu32 == tdep->ioctl_TIOCSWINSZ
	  || tmpu32 == tdep->ioctl_TIOCMBIS || tmpu32 == tdep->ioctl_TIOCMBIC
	  || tmpu32 == tdep->ioctl_TIOCMSET
	  || tmpu32 == tdep->ioctl_TIOCSSOFTCAR
	  || tmpu32 == tdep->ioctl_TIOCCONS
	  || tmpu32 == tdep->ioctl_TIOCSSERIAL
	  || tmpu32 == tdep->ioctl_TIOCPKT || tmpu32 == tdep->ioctl_TIOCNOTTY
	  || tmpu32 == tdep->ioctl_TIOCSETD || tmpu32 == tdep->ioctl_TCSBRKP
	  || tmpu32 == tdep->ioctl_TIOCTTYGSTRUCT
	  || tmpu32 == tdep->ioctl_TIOCSBRK || tmpu32 == tdep->ioctl_TIOCCBRK
	  || tmpu32 == tdep->ioctl_TCSETS2 || tmpu32 == tdep->ioctl_TCSETSW2
	  || tmpu32 == tdep->ioctl_TCSETSF2
	  || tmpu32 == tdep->ioctl_TIOCSPTLCK
	  || tmpu32 == tdep->ioctl_TIOCSERCONFIG
	  || tmpu32 == tdep->ioctl_TIOCSERGWILD
	  || tmpu32 == tdep->ioctl_TIOCSERSWILD
	  || tmpu32 == tdep->ioctl_TIOCSLCKTRMIOS
	  || tmpu32 == tdep->ioctl_TIOCSERGETMULTI
	  || tmpu32 == tdep->ioctl_TIOCSERSETMULTI
	  || tmpu32 == tdep->ioctl_TIOCMIWAIT
	  || tmpu32 == tdep->ioctl_TIOCSHAYESESP)
	{
	  /* Nothing to do.  */
	}
      else if (tmpu32 == tdep->ioctl_TCGETS || tmpu32 == tdep->ioctl_TCGETA
	       || tmpu32 == tdep->ioctl_TIOCGLCKTRMIOS)
	{
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_termios))
	    {
	      return (-1);
	    }
	}
      else if (tmpu32 == tdep->ioctl_TIOCGPGRP
	       || tmpu32 == tdep->ioctl_TIOCGSID)
	{
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_pid_t))
	    {
	      return (-1);
	    }
	}
      else if (tmpu32 == tdep->ioctl_TIOCOUTQ
	       || tmpu32 == tdep->ioctl_TIOCMGET
	       || tmpu32 == tdep->ioctl_TIOCGSOFTCAR
	       || tmpu32 == tdep->ioctl_FIONREAD
	       || tmpu32 == tdep->ioctl_TIOCINQ
	       || tmpu32 == tdep->ioctl_TIOCGETD
	       || tmpu32 == tdep->ioctl_TIOCGPTN
	       || tmpu32 == tdep->ioctl_TIOCSERGETLSR)
	{
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_int))
	    {
	      return (-1);
	    }
	}
      else if (tmpu32 == tdep->ioctl_TIOCGWINSZ)
	{
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_winsize))
	    {
	      return (-1);
	    }
	}
      else if (tmpu32 == tdep->ioctl_TIOCLINUX)
	{
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_char))
	    {
	      return (-1);
	    }
	}
      else if (tmpu32 == tdep->ioctl_TIOCGSERIAL)
	{
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_serial_struct))
	    {
	      return (-1);
	    }
	}
      else if (tmpu32 == tdep->ioctl_TCGETS2)
	{
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_termios2))
	    {
	      return (-1);
	    }
	}
      else if (tmpu32 == tdep->ioctl_FIOQSIZE)
	{
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_loff_t))
	    {
	      return (-1);
	    }
	}
      else if (tmpu32 == tdep->ioctl_TIOCGICOUNT)
	{
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem
	      (tmpu32, tdep->size_serial_icounter_struct))
	    {
	      return (-1);
	    }
	}
      else if (tmpu32 == tdep->ioctl_TIOCGHAYESESP)
	{
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_hayes_esp_config))
	    {
	      return (-1);
	    }
	}
      else if (tmpu32 == tdep->ioctl_TIOCSERGSTRUCT)
	{
	  printf_unfiltered (_
			     ("Record: record and reverse target doesn't support ioctl request TIOCSERGSTRUCT\n"));
	  return (1);
	}
      else
	{
	  printf_unfiltered (_
			     ("Record: record and reverse target doesn't support ioctl request 0x%08x.\n"),
			     tmpu32);
	  return (1);
	}
      break;

      /* sys_fcntl */
    case 55:
      /* XXX */
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
    sys_fcntl:
      if (tmpu32 == F_GETLK)
	{
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_flock))
	    {
	      return (-1);
	    }
	}
      break;

      /* sys_ni_syscall */
    case 56:
      /* sys_setpgid */
    case 57:
      /* sys_ni_syscall */
    case 58:
      break;

      /* sys_olduname */
    case 59:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_oldold_utsname))
	{
	  return (-1);
	}
      break;

      /* sys_umask */
    case 60:
      /* sys_chroot */
    case 61:
      break;

      /* sys_ustat */
    case 62:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_ustat))
	{
	  return (-1);
	}
      break;

      /* sys_dup2 */
    case 63:
      /* sys_getppid */
    case 64:
      /* sys_getpgrp */
    case 65:
      /* sys_setsid */
    case 66:
      break;

      /* sys_sigaction */
    case 67:
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_old_sigaction))
	{
	  return (-1);
	}
      break;

      /* sys_sgetmask */
    case 68:
      /* sys_ssetmask */
    case 69:
      /* sys_setreuid16 */
    case 70:
      /* sys_setregid16 */
    case 71:
      /* sys_sigsuspend */
    case 72:
      break;

      /* sys_sigpending */
    case 73:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_old_sigset_t))
	{
	  return (-1);
	}
      break;

      /* sys_sethostname */
    case 74:
      /* sys_setrlimit */
    case 75:
      break;

      /* sys_old_getrlimit */
    case 76:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_rlimit))
	{
	  return (-1);
	}
      break;

      /* sys_getrusage */
    case 77:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_rusage))
	{
	  return (-1);
	}
      break;

      /* sys_gettimeofday */
    case 78:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_timeval))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_timezone))
	{
	  return (-1);
	}
      break;

      /* sys_settimeofday */
    case 79:
      break;

      /* sys_getgroups16 */
    case 80:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_old_gid_t))
	{
	  return (-1);
	}
      break;

      /* sys_setgroups16 */
    case 81:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_old_gid_t))
	{
	  return (-1);
	}
      break;

      /* old_select */
    case 82:
      {
	/*
	   struct sel_arg_struct {
	   unsigned long n;
	   fd_set *inp;
	   fd_set *outp;
	   fd_set *exp;
	   struct timeval *tvp;
	   };
	 */
	struct sel_arg_struct
	{
	  uint32_t n;
	  uint32_t inp;
	  uint32_t outp;
	  uint32_t exp;
	  uint32_t tvp;
	} sel;

	regcache_raw_read (record_regcache, tdep->arg1,
			   (gdb_byte *) & tmpu32);
	if (tmpu32)
	  {
	    if (target_read_memory (tmpu32, (gdb_byte *) & sel, sizeof (sel)))
	      {
		fprintf_unfiltered (gdb_stdlog,
				    "Record: read memory addr = 0x%s len = %d error.\n",
				    paddr_nz (tmpu32), sizeof (sel));
		return (-1);
	      }
	    if (record_arch_list_add_mem (sel.inp, tdep->size_fd_set))
	      {
		return (-1);
	      }
	    if (record_arch_list_add_mem (sel.outp, tdep->size_fd_set))
	      {
		return (-1);
	      }
	    if (record_arch_list_add_mem (sel.exp, tdep->size_fd_set))
	      {
		return (-1);
	      }
	    if (record_arch_list_add_mem (sel.tvp, tdep->size_timeval))
	      {
		return (-1);
	      }
	  }
      }
      break;

      /* sys_symlink */
    case 83:
      break;

      /* sys_readlink */
    case 85:
      {
	uint32_t len;
	regcache_raw_read (record_regcache, tdep->arg2,
			   (gdb_byte *) & tmpu32);
	regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & len);
	if (record_arch_list_add_mem (tmpu32, len))
	  {
	    return (-1);
	  }
      }
      break;

      /* sys_uselib */
    case 86:
      /* sys_swapon */
    case 87:
      break;

      /* sys_reboot */
    case 88:
      {
	int q;
	target_terminal_ours ();
	q =
	  yquery (_
		  ("The next instruction is syscall reboot.  It will restart the computer.  Do you want to stop the program."));
	target_terminal_inferior ();
	if (q)
	  {
	    return (1);
	  }
      }
      break;

      /* old_readdir */
    case 89:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_dirent))
	{
	  return (-1);
	}
      break;

      /* old_mmap */
    case 90:
      break;

      /* sys_munmap */
    case 91:
      {
	int q;
	uint32_t len;

	regcache_raw_read (record_regcache, tdep->arg1,
			   (gdb_byte *) & tmpu32);
	regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & len);
	target_terminal_ours ();
	q =
	  yquery (_
		  ("The next instruction is syscall munmap.  It will free the memory addr = 0x%s len = %d.  It will make record target get error.  Do you want to stop the program."),
		  paddr_nz (tmpu32), len);
	target_terminal_inferior ();
	if (q)
	  {
	    return (1);
	  }
      }
      break;

      /* sys_truncate */
    case 92:
      /* sys_ftruncate */
    case 93:
      /* sys_fchmod */
    case 94:
      /* sys_fchown16 */
    case 95:
      /* sys_getpriority */
    case 96:
      /* sys_setpriority */
    case 97:
      /* sys_ni_syscall */
    case 98:
      break;

      /* sys_statfs */
    case 99:
      /* sys_fstatfs */
    case 100:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_statfs))
	{
	  return (-1);
	}
      break;

      /* sys_ioperm */
    case 101:
      break;

      /* sys_socketcall */
    case 102:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      switch (tmpu32)
	{
	case RECORD_SYS_SOCKET:
	case RECORD_SYS_BIND:
	case RECORD_SYS_CONNECT:
	case RECORD_SYS_LISTEN:
	  break;
	case RECORD_SYS_ACCEPT:
	case RECORD_SYS_GETSOCKNAME:
	case RECORD_SYS_GETPEERNAME:
	  {
	    uint32_t a[3];
	    regcache_raw_read (record_regcache, tdep->arg2,
			       (gdb_byte *) & tmpu32);
	    if (tmpu32)
	      {
		if (target_read_memory (tmpu32, (gdb_byte *) a, sizeof (a)))
		  {
		    fprintf_unfiltered (gdb_stdlog,
					"Record: read memory addr = 0x%s len = %d error.\n",
					paddr_nz (tmpu32), sizeof (a));
		    return (-1);
		  }
		if (record_arch_list_add_mem (a[1], tdep->size_sockaddr))
		  {
		    return (-1);
		  }
		if (record_arch_list_add_mem (a[2], tdep->size_int))
		  {
		    return (-1);
		  }
	      }
	  }
	  break;

	case RECORD_SYS_SOCKETPAIR:
	  {
	    uint32_t a[4];
	    regcache_raw_read (record_regcache, tdep->arg2,
			       (gdb_byte *) & tmpu32);
	    if (tmpu32)
	      {
		if (target_read_memory (tmpu32, (gdb_byte *) a, sizeof (a)))
		  {
		    fprintf_unfiltered (gdb_stdlog,
					"Record: read memory addr = 0x%s len = %d error.\n",
					paddr_nz (tmpu32), sizeof (a));
		    return (-1);
		  }
		if (record_arch_list_add_mem (a[3], tdep->size_int))
		  {
		    return (-1);
		  }
	      }
	  }
	  break;
	case RECORD_SYS_SEND:
	case RECORD_SYS_SENDTO:
	  break;
	case RECORD_SYS_RECV:
	  {
	    uint32_t a[3];
	    regcache_raw_read (record_regcache, tdep->arg2,
			       (gdb_byte *) & tmpu32);
	    if (tmpu32)
	      {
		if (target_read_memory (tmpu32, (gdb_byte *) a, sizeof (a)))
		  {
		    fprintf_unfiltered (gdb_stdlog,
					"Record: read memory addr = 0x%s len = %d error.\n",
					paddr_nz (tmpu32), sizeof (a));
		    return (-1);
		  }
		if (a[2])
		  {
		    if (target_read_memory
			(a[2], (gdb_byte *) & (a[2]), sizeof (a[2])))
		      {
			fprintf_unfiltered (gdb_stdlog,
					    "Record: read memory addr = 0x%s len = %d error.\n",
					    paddr_nz (a[2]), sizeof (a[2]));
			return (-1);
		      }
		    if (record_arch_list_add_mem (a[1], a[2]))
		      {
			return (-1);
		      }
		  }
	      }
	  }
	  break;
	case RECORD_SYS_RECVFROM:
	  {
	    uint32_t a[6];
	    regcache_raw_read (record_regcache, tdep->arg2,
			       (gdb_byte *) & tmpu32);
	    if (tmpu32)
	      {
		if (target_read_memory (tmpu32, (gdb_byte *) a, sizeof (a)))
		  {
		    fprintf_unfiltered (gdb_stdlog,
					"Record: read memory addr = 0x%s len = %d error.\n",
					paddr_nz (tmpu32), sizeof (a));
		    return (-1);
		  }
		if (a[2])
		  {
		    if (target_read_memory
			(a[2], (gdb_byte *) & (a[2]), sizeof (a[2])))
		      {
			fprintf_unfiltered (gdb_stdlog,
					    "Record: read memory addr = 0x%s len = %d error.\n",
					    paddr_nz (a[2]), sizeof (a[2]));
			return (-1);
		      }
		    if (record_arch_list_add_mem (a[1], a[2]))
		      {
			return (-1);
		      }
		    if (record_arch_list_add_mem (a[4], tdep->size_sockaddr))
		      {
			return (-1);
		      }
		    if (record_arch_list_add_mem (a[5], tdep->size_int))
		      {
			return (-1);
		      }
		  }
	      }
	  }
	  break;
	case RECORD_SYS_SHUTDOWN:
	case RECORD_SYS_SETSOCKOPT:
	  break;
	case RECORD_SYS_GETSOCKOPT:
	  {
	    uint32_t a[5];
	    uint32_t av;

	    regcache_raw_read (record_regcache, tdep->arg2,
			       (gdb_byte *) & tmpu32);
	    if (tmpu32)
	      {
		if (target_read_memory (tmpu32, (gdb_byte *) a, sizeof (a)))
		  {
		    fprintf_unfiltered (gdb_stdlog,
					"Record: read memory addr = 0x%s len = %d error.\n",
					paddr_nz (tmpu32), sizeof (a));
		    return (-1);
		  }
		if (a[4])
		  {
		    if (target_read_memory
			(a[4], (gdb_byte *) & av, sizeof (av)))
		      {
			fprintf_unfiltered (gdb_stdlog,
					    "Record: read memory addr = 0x%s len = %d error.\n",
					    paddr_nz (a[4]), sizeof (av));
			return (-1);
		      }
		    if (record_arch_list_add_mem (a[3], av))
		      {
			return (-1);
		      }
		    if (record_arch_list_add_mem (a[4], tdep->size_int))
		      {
			return (-1);
		      }
		  }
	      }
	  }
	  break;
	case RECORD_SYS_SENDMSG:
	  break;
	case RECORD_SYS_RECVMSG:
	  {
	    uint32_t a[2], i;
	    struct record_msghdr
	    {
	      uint32_t msg_name;
	      uint32_t msg_namelen;
	      uint32_t msg_iov;
	      uint32_t msg_iovlen;
	      uint32_t msg_control;
	      uint32_t msg_controllen;
	      uint32_t msg_flags;
	    } rec;
	    struct record_iovec
	    {
	      uint32_t iov_base;
	      uint32_t iov_len;
	    } iov;

	    regcache_raw_read (record_regcache, tdep->arg2,
			       (gdb_byte *) & tmpu32);
	    if (tmpu32)
	      {
		if (target_read_memory (tmpu32, (gdb_byte *) a, sizeof (a)))
		  {
		    fprintf_unfiltered (gdb_stdlog,
					"Record: read memory addr = 0x%s len = %d error.\n",
					paddr_nz (tmpu32), sizeof (a));
		    return (-1);
		  }
		if (record_arch_list_add_mem (a[1], tdep->size_msghdr))
		  {
		    return (-1);
		  }
		if (a[1])
		  {
		    if (target_read_memory
			(a[1], (gdb_byte *) & rec, sizeof (rec)))
		      {
			fprintf_unfiltered (gdb_stdlog,
					    "Record: read memory addr = 0x%s len = %d error.\n",
					    paddr_nz (a[1]), sizeof (rec));
			return (-1);
		      }
		    if (record_arch_list_add_mem
			(rec.msg_name, rec.msg_namelen))
		      {
			return (-1);
		      }
		    if (record_arch_list_add_mem
			(rec.msg_control, rec.msg_controllen))
		      {
			return (-1);
		      }
		    if (rec.msg_iov)
		      {
			for (i = 0; i < rec.msg_iovlen; i++)
			  {
			    if (target_read_memory
				(rec.msg_iov, (gdb_byte *) & iov,
				 sizeof (iov)))
			      {
				fprintf_unfiltered (gdb_stdlog,
						    "Record: read memory addr = 0x%s len = %d error.\n",
						    paddr_nz (rec.msg_iov),
						    sizeof (iov));
				return (-1);
			      }
			    if (record_arch_list_add_mem
				(iov.iov_base, iov.iov_len))
			      {
				return (-1);
			      }
			    rec.msg_iov += sizeof (struct record_iovec);
			  }
		      }
		  }
	      }
	  }
	  break;
	default:
	  printf_unfiltered (_
			     ("Record: record and reverse function doesn't support socketcall call 0x%08x\n"),
			     tmpu32);
	  return (-1);
	  break;
	}
      break;

      /* sys_syslog */
    case 103:
      break;

      /* sys_setitimer */
    case 104:
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_itimerval))
	{
	  return (-1);
	}
      break;

      /* sys_getitimer */
    case 105:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_itimerval))
	{
	  return (-1);
	}
      break;

      /* sys_newstat */
    case 106:
      /* sys_newlstat */
    case 107:
      /* sys_newfstat */
    case 108:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_stat))
	{
	  return (-1);
	}
      break;

      /* sys_uname */
    case 109:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_old_utsname))
	{
	  return (-1);
	}
      break;

      /* sys_iopl */
    case 110:
      /* sys_vhangup */
    case 111:
      /* sys_ni_syscall */
    case 112:
      /* sys_vm86old */
    case 113:
      break;

      /* sys_wait4 */
    case 114:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_int))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg4, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_rusage))
	{
	  return (-1);
	}
      break;

      /* sys_swapoff */
    case 115:
      break;

      /* sys_sysinfo */
    case 116:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_sysinfo))
	{
	  return (-1);
	}
      break;

      /* sys_ipc */
    case 117:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      switch (tmpu32)
	{
	case RECORD_MSGRCV:
	  {
	    int32_t second;
	    uint32_t ptr;
	    regcache_raw_read (record_regcache, tdep->arg3,
			       (gdb_byte *) & second);
	    regcache_raw_read (record_regcache, tdep->arg5,
			       (gdb_byte *) & ptr);
	    if (record_arch_list_add_mem (ptr, second + tdep->size_long))
	      {
		return (-1);
	      }
	  }
	  break;
	case RECORD_MSGCTL:
	  regcache_raw_read (record_regcache, tdep->arg5,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_msqid_ds))
	    {
	      return (-1);
	    }
	  break;
	case RECORD_SHMAT:
	  regcache_raw_read (record_regcache, tdep->arg4,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_ulong))
	    {
	      return (-1);
	    }
	  break;
	case RECORD_SHMCTL:
	  regcache_raw_read (record_regcache, tdep->arg5,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_shmid_ds))
	    {
	      return (-1);
	    }
	  break;
	}
      break;

      /* sys_fsync */
    case 118:
      /* sys_sigreturn */
    case 119:
      /* sys_clone */
    case 120:
      /* sys_setdomainname */
    case 121:
      break;

      /* sys_newuname */
    case 122:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_new_utsname))
	{
	  return (-1);
	}
      break;

      /* sys_modify_ldt */
    case 123:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (tmpu32 == 0 || tmpu32 == 2)
	{
	  uint32_t ptr, bytecount;
	  regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & ptr);
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & bytecount);
	  if (record_arch_list_add_mem (ptr, bytecount))
	    {
	      return (-1);
	    }
	}
      break;

      /* sys_adjtimex */
    case 124:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_timex))
	{
	  return (-1);
	}
      break;

      /* sys_mprotect */
    case 125:
      break;

      /* sys_sigprocmask */
    case 126:
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_old_sigset_t))
	{
	  return (-1);
	}
      break;

      /* sys_ni_syscall */
    case 127:
      /* sys_init_module */
    case 128:
      /* sys_delete_module */
    case 129:
      /* sys_ni_syscall */
    case 130:
      break;

      /* sys_quotactl */
    case 131:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      switch (tmpu32)
	{
	case RECORD_Q_GETFMT:
	  regcache_raw_read (record_regcache, tdep->arg4,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, 4))
	    {
	      return (-1);
	    }
	  break;
	case RECORD_Q_GETINFO:
	  regcache_raw_read (record_regcache, tdep->arg4,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_mem_dqinfo))
	    {
	      return (-1);
	    }
	  break;
	case RECORD_Q_GETQUOTA:
	  regcache_raw_read (record_regcache, tdep->arg4,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_if_dqblk))
	    {
	      return (-1);
	    }
	  break;
	case RECORD_Q_XGETQSTAT:
	case RECORD_Q_XGETQUOTA:
	  regcache_raw_read (record_regcache, tdep->arg4,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_fs_quota_stat))
	    {
	      return (-1);
	    }
	  break;
	}
      break;

      /* sys_getpgid */
    case 132:
      /* sys_fchdir */
    case 133:
      /* sys_bdflush */
    case 134:
      break;

      /* sys_sysfs */
    case 135:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (tmpu32 == 2)
	{
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & tmpu32);
	  /*XXX the size of memory is not very clear */
	  if (record_arch_list_add_mem (tmpu32, 10))
	    {
	      return (-1);
	    }
	}
      break;

      /* sys_personality */
    case 136:
      /* sys_ni_syscall */
    case 137:
      /* sys_setfsuid16 */
    case 138:
      /* sys_setfsgid16 */
    case 139:
      break;

      /* sys_llseek */
    case 140:
      regcache_raw_read (record_regcache, tdep->arg4, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_loff_t))
	{
	  return (-1);
	}
      break;

      /* sys_getdents */
    case 141:
      {
	uint32_t count;
	regcache_raw_read (record_regcache, tdep->arg2,
			   (gdb_byte *) & tmpu32);
	regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & count);
	if (record_arch_list_add_mem (tmpu32, tdep->size_dirent * count))
	  {
	    return (-1);
	  }
      }
      break;

      /* sys_select */
    case 142:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_fd_set))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_fd_set))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg4, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_fd_set))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg5, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_timeval))
	{
	  return (-1);
	}
      break;

      /* sys_flock */
    case 143:
      /* sys_msync */
    case 144:
      break;

      /* sys_readv */
    case 145:
      {
	uint32_t vec;
	uint32_t vlen;
	struct record_iovec
	{
	  uint32_t iov_base;
	  uint32_t iov_len;
	} iov;
	regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & vec);
	if (vec)
	  {
	    regcache_raw_read (record_regcache, tdep->arg3,
			       (gdb_byte *) & vlen);
	    for (tmpu32 = 0; tmpu32 < vlen; tmpu32++)
	      {
		if (target_read_memory
		    (vec, (gdb_byte *) & iov, sizeof (struct record_iovec)))
		  {
		    fprintf_unfiltered (gdb_stdlog,
					"Record: read memory addr = 0x%s len = %d error.\n",
					paddr_nz (vec),
					sizeof (struct record_iovec));
		    return (-1);
		  }
		if (record_arch_list_add_mem (iov.iov_base, iov.iov_len))
		  {
		    return (-1);
		  }
		vec += sizeof (struct record_iovec);
	      }
	  }
      }
      break;

      /* sys_writev */
    case 146:
      /* sys_getsid */
    case 147:
      /* sys_fdatasync */
    case 148:
      /* sys_sysctl */
    case 149:
      /* sys_mlock */
    case 150:
      /* sys_munlock */
    case 151:
      /* sys_mlockall */
    case 152:
      /* sys_munlockall */
    case 153:
      /* sys_sched_setparam */
    case 154:
      break;

      /* sys_sched_getparam */
    case 155:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_int))
	{
	  return (-1);
	}
      break;

      /* sys_sched_setscheduler */
    case 156:
      /* sys_sched_getscheduler */
    case 157:
      /* sys_sched_yield */
    case 158:
      /* sys_sched_get_priority_max */
    case 159:
      /* sys_sched_get_priority_min */
    case 160:
      break;

      /* sys_sched_rr_get_interval */
    case 161:
      /* sys_nanosleep */
    case 162:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_timespec))
	{
	  return (-1);
	}
      break;

      /* sys_mremap */
    case 163:
      /* sys_setresuid16 */
    case 164:
      break;

      /* sys_getresuid16 */
    case 165:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_old_uid_t))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_old_uid_t))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_old_uid_t))
	{
	  return (-1);
	}
      break;

      /* sys_vm86 */
    case 166:
      /* sys_ni_syscall */
    case 167:
      break;

      /* sys_poll */
    case 168:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  uint32_t nfds;
	  regcache_raw_read (record_regcache, tdep->arg2,
			     (gdb_byte *) & nfds);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_pollfd * nfds))
	    {
	      return (-1);
	    }
	}
      break;

      /* sys_nfsservctl */
    case 169:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (tmpu32 == 7 || tmpu32 == 8)
	{
	  uint32_t rsize;
	  if (tmpu32 == 7)
	    {
	      rsize = tdep->size_NFS_FHSIZE;
	    }
	  else
	    {
	      rsize = tdep->size_knfsd_fh;
	    }
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, rsize))
	    {
	      return (-1);
	    }
	}
      break;

      /* sys_setresgid16 */
    case 170:
      break;

      /* sys_getresgid16 */
    case 171:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_old_gid_t))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_old_gid_t))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_old_gid_t))
	{
	  return (-1);
	}
      break;

      /* sys_prctl */
    case 172:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      switch (tmpu32)
	{
	case 2:
	  regcache_raw_read (record_regcache, tdep->arg2,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_int))
	    {
	      return (-1);
	    }
	  break;
	case 16:
	  regcache_raw_read (record_regcache, tdep->arg2,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_TASK_COMM_LEN))
	    {
	      return (-1);
	    }
	  break;
	}
      break;

      /* sys_rt_sigreturn */
    case 173:
      break;

      /* sys_rt_sigaction */
    case 174:
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_sigaction))
	{
	  return (-1);
	}
      break;

      /* sys_rt_sigprocmask */
    case 175:
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_sigset_t))
	{
	  return (-1);
	}
      break;

      /* sys_rt_sigpending */
    case 176:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  uint32_t sigsetsize;
	  regcache_raw_read (record_regcache, tdep->arg2,
			     (gdb_byte *) & sigsetsize);
	  if (record_arch_list_add_mem (tmpu32, sigsetsize))
	    {
	      return (-1);
	    }
	}
      break;

      /* sys_rt_sigtimedwait */
    case 177:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_siginfo_t))
	{
	  return (-1);
	}
      break;

      /* sys_rt_sigqueueinfo */
    case 178:
      /* sys_rt_sigsuspend */
    case 179:
      break;

      /* sys_pread64 */
    case 180:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  uint32_t count;
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & count);
	  if (record_arch_list_add_mem (tmpu32, count))
	    {
	      return (-1);
	    }
	}
      break;

      /* sys_pwrite64 */
    case 181:
      /* sys_chown16 */
    case 182:
      break;

      /* sys_getcwd */
    case 183:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  uint32_t size;
	  regcache_raw_read (record_regcache, tdep->arg2,
			     (gdb_byte *) & size);
	  if (record_arch_list_add_mem (tmpu32, size))
	    {
	      return (-1);
	    }
	}
      break;

      /* sys_capget */
    case 184:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_cap_user_data_t))
	{
	  return (-1);
	}
      break;

      /* sys_capset */
    case 185:
      break;

      /* sys_sigaltstack */
    case 186:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_stack_t))
	{
	  return (-1);
	}
      break;

      /* sys_sendfile */
    case 187:
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_off_t))
	{
	  return (-1);
	}
      break;

      /* sys_ni_syscall */
    case 188:
      /* sys_ni_syscall */
    case 189:
      /* sys_vfork */
    case 190:
      break;

      /* sys_getrlimit */
    case 191:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_rlimit))
	{
	  return (-1);
	}
      break;

      /* sys_mmap2 */
    case 192:
      break;

      /* sys_truncate64 */
    case 193:
      /* sys_ftruncate64 */
    case 194:
      break;

      /* sys_stat64 */
    case 195:
      /* sys_lstat64 */
    case 196:
      /* sys_fstat64 */
    case 197:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_stat64))
	{
	  return (-1);
	}
      break;

      /* sys_lchown */
    case 198:
      /* sys_getuid */
    case 199:
      /* sys_getgid */
    case 200:
      /* sys_geteuid */
    case 201:
      /* sys_getegid */
    case 202:
      /* sys_setreuid */
    case 203:
      /* sys_setregid */
    case 204:
      break;

      /* sys_getgroups */
    case 205:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  int gidsetsize;
	  regcache_raw_read (record_regcache, tdep->arg1,
			     (gdb_byte *) & gidsetsize);
	  if (record_arch_list_add_mem
	      (tmpu32, tdep->size_gid_t * gidsetsize))
	    {
	      return (-1);
	    }
	}
      break;

      /* sys_setgroups */
    case 206:
      /* sys_fchown */
    case 207:
      /* sys_setresuid */
    case 208:
      break;

      /* sys_getresuid */
    case 209:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_uid_t))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_uid_t))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_uid_t))
	{
	  return (-1);
	}
      break;

      /* sys_setresgid */
    case 210:
      break;

      /* sys_getresgid */
    case 211:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_gid_t))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_gid_t))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_gid_t))
	{
	  return (-1);
	}
      break;

      /* sys_chown */
    case 212:
      /* sys_setuid */
    case 213:
      /* sys_setgid */
    case 214:
      /* sys_setfsuid */
    case 215:
      /* sys_setfsgid */
    case 216:
      /* sys_pivot_root */
    case 217:
      break;

      /* sys_mincore */
    case 218:
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_PAGE_SIZE))
	{
	  return (-1);
	}
      break;

      /* sys_madvise */
    case 219:
      break;

      /* sys_getdents64 */
    case 220:
      {
	uint32_t count;
	regcache_raw_read (record_regcache, tdep->arg2,
			   (gdb_byte *) & tmpu32);
	regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & count);
	if (record_arch_list_add_mem (tmpu32, tdep->size_dirent64 * count))
	  {
	    return (-1);
	  }
      }
      break;

      /* sys_fcntl64 */
    case 221:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      switch (tmpu32)
	{
	case F_GETLK64:
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_flock64))
	    {
	      return (-1);
	    }
	  break;
	case F_SETLK64:
	case F_SETLKW64:
	  break;
	default:
	  goto sys_fcntl;
	  break;
	}
      break;

      /* sys_ni_syscall */
    case 222:
      /* sys_ni_syscall */
    case 223:
      /* sys_gettid */
    case 224:
      /* sys_readahead */
    case 225:
      /* sys_setxattr */
    case 226:
      /* sys_lsetxattr */
    case 227:
      /* sys_fsetxattr */
    case 228:
      break;

      /* sys_getxattr */
    case 229:
      /* sys_lgetxattr */
    case 230:
      /* sys_fgetxattr */
    case 231:
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  uint32_t size;
	  regcache_raw_read (record_regcache, tdep->arg4,
			     (gdb_byte *) & size);
	  if (record_arch_list_add_mem (tmpu32, size))
	    {
	      return (-1);
	    }
	}
      break;

      /* sys_listxattr */
    case 232:
      /* sys_llistxattr */
    case 233:
      /* sys_flistxattr */
    case 234:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  uint32_t size;
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & size);
	  if (record_arch_list_add_mem (tmpu32, size))
	    {
	      return (-1);
	    }
	}
      break;

      /* sys_removexattr */
    case 235:
      /* sys_lremovexattr */
    case 236:
      /* sys_fremovexattr */
    case 237:
      /* sys_tkill */
    case 238:
      break;

      /* sys_sendfile64 */
    case 239:
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_loff_t))
	{
	  return (-1);
	}
      break;

      /* sys_futex */
    case 240:
      /* sys_sched_setaffinity */
    case 241:
      break;

      /* sys_sched_getaffinity */
    case 242:
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  uint32_t len;
	  regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & len);
	  if (record_arch_list_add_mem (tmpu32, len))
	    {
	      return (-1);
	    }
	}
      break;

      /* sys_set_thread_area */
    case 243:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_int))
	{
	  return (-1);
	}
      break;

      /* sys_get_thread_area */
    case 244:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_user_desc))
	{
	  return (-1);
	}
      break;

      /* sys_io_setup */
    case 245:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_long))
	{
	  return (-1);
	}
      break;

      /* sys_io_destroy */
    case 246:
      break;

      /* sys_io_getevents */
    case 247:
      regcache_raw_read (record_regcache, tdep->arg4, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  int32_t nr;
	  regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & nr);
	  if (record_arch_list_add_mem (tmpu32, nr * tdep->size_io_event))
	    {
	      return (-1);
	    }
	}
      break;

      /* sys_io_submit */
    case 248:
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  int32_t i, nr;
	  uint32_t *iocbp;
	  regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & nr);
	  iocbp = (uint32_t *) alloca (nr * tdep->size_int);
	  if (target_read_memory
	      (tmpu32, (gdb_byte *) iocbp, nr * tdep->size_int))
	    {
	      fprintf_unfiltered (gdb_stdlog,
				  "Record: read memory addr = 0x%s len = %d error.\n",
				  paddr_nz (tmpu32), nr * tdep->size_int);
	      return (-1);
	    }
	  for (i = 0; i < nr; i++)
	    {
	      if (record_arch_list_add_mem (iocbp[i], tdep->size_iocb))
		{
		  return (-1);
		}
	    }
	}
      break;

      /* sys_io_cancel */
    case 249:
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_io_event))
	{
	  return (-1);
	}
      break;

      /* sys_fadvise64 */
    case 250:
      /* sys_ni_syscall */
    case 251:
      break;

      /* sys_exit_group */
    case 252:
      {
	int q;
	target_terminal_ours ();
	q =
	  yquery (_
		  ("The next instruction is syscall exit_group.  It will make the program exit.  Do you want to stop the program."));
	target_terminal_inferior ();
	if (q)
	  {
	    return (1);
	  }
      }
      break;

      /* sys_lookup_dcookie */
    case 253:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  uint32_t len;
	  regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & len);
	  if (record_arch_list_add_mem (tmpu32, len))
	    {
	      return (-1);
	    }
	}
      break;

      /* sys_epoll_create */
    case 254:
      /* sys_epoll_ctl */
    case 255:
      break;

      /* sys_epoll_wait */
    case 256:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  int32_t maxevents;
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & maxevents);
	  if (record_arch_list_add_mem
	      (tmpu32, maxevents * tdep->size_epoll_event))
	    {
	      return (-1);
	    }
	}
      break;

      /* sys_remap_file_pages */
    case 257:
      /* sys_set_tid_address */
    case 258:
      break;

      /* sys_timer_create */
    case 259:
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_int))
	{
	  return (-1);
	}
      break;

      /* sys_timer_settime */
    case 260:
      regcache_raw_read (record_regcache, tdep->arg4, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_itimerspec))
	{
	  return (-1);
	}
      break;

      /* sys_timer_gettime */
    case 261:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_itimerspec))
	{
	  return (-1);
	}
      break;

      /* sys_timer_getoverrun */
    case 262:
      /* sys_timer_delete */
    case 263:
      /* sys_clock_settime */
    case 264:
      break;

      /* sys_clock_gettime */
    case 265:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_timespec))
	{
	  return (-1);
	}
      break;

      /* sys_clock_getres */
    case 266:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_timespec))
	{
	  return (-1);
	}
      break;

      /* sys_clock_nanosleep */
    case 267:
      regcache_raw_read (record_regcache, tdep->arg4, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_timespec))
	{
	  return (-1);
	}
      break;

      /* sys_statfs64 */
    case 268:
      /* sys_fstatfs64 */
    case 269:
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_statfs64))
	{
	  return (-1);
	}
      break;

      /* sys_tgkill */
    case 270:
      /* sys_utimes */
    case 271:
      /* sys_fadvise64_64 */
    case 272:
      /* sys_ni_syscall */
    case 273:
      /* sys_mbind */
    case 274:
      break;

      /* sys_get_mempolicy */
    case 275:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_int))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  uint32_t maxnode;
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & maxnode);
	  if (record_arch_list_add_mem (tmpu32, maxnode * tdep->size_long))
	    {
	      return (-1);
	    }
	}
      break;

      /* sys_set_mempolicy */
    case 276:
      /* sys_mq_open */
    case 277:
      /* sys_mq_unlink */
    case 278:
      /* sys_mq_timedsend */
    case 279:
      break;

      /* sys_mq_timedreceive */
    case 280:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  uint32_t msg_len;
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & msg_len);
	  if (record_arch_list_add_mem (tmpu32, msg_len))
	    {
	      return (-1);
	    }
	}
      regcache_raw_read (record_regcache, tdep->arg4, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_int))
	{
	  return (-1);
	}
      break;

      /* sys_mq_notify */
    case 281:
      break;

      /* sys_mq_getsetattr */
    case 282:
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_mq_attr))
	{
	  return (-1);
	}
      break;

      /* sys_kexec_load */
    case 283:
      break;

      /* sys_waitid */
    case 284:
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_siginfo))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg5, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_rusage))
	{
	  return (-1);
	}
      break;

      /* sys_ni_syscall */
    case 285:
      /* sys_add_key */
    case 286:
      /* sys_request_key */
    case 287:
      break;

      /* sys_keyctl */
    case 288:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (tmpu32 == 6 || tmpu32 == 11)
	{
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & tmpu32);
	  if (tmpu32)
	    {
	      uint32_t buflen;
	      regcache_raw_read (record_regcache, tdep->arg4,
				 (gdb_byte *) & buflen);
	      if (record_arch_list_add_mem (tmpu32, buflen))
		{
		  return (-1);
		}
	    }
	}
      break;

      /* sys_ioprio_set */
    case 289:
      /* sys_ioprio_get */
    case 290:
      /* sys_inotify_init */
    case 291:
      /* sys_inotify_add_watch */
    case 292:
      /* sys_inotify_rm_watch */
    case 293:
      /* sys_migrate_pages */
    case 294:
      /* sys_openat */
    case 295:
      /* sys_mkdirat */
    case 296:
      /* sys_mknodat */
    case 297:
      /* sys_fchownat */
    case 298:
      /* sys_futimesat */
    case 299:
      break;

      /* sys_fstatat64 */
    case 300:
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_stat64))
	{
	  return (-1);
	}
      break;

      /* sys_unlinkat */
    case 301:
      /* sys_renameat */
    case 302:
      /* sys_linkat */
    case 303:
      /* sys_symlinkat */
    case 304:
      break;

      /* sys_readlinkat */
    case 305:
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  int32_t bufsiz;
	  regcache_raw_read (record_regcache, tdep->arg4,
			     (gdb_byte *) & bufsiz);
	  if (record_arch_list_add_mem (tmpu32, bufsiz))
	    {
	      return (-1);
	    }
	}
      break;

      /* sys_fchmodat */
    case 306:
      /* sys_faccessat */
    case 307:
      break;

      /* sys_pselect6 */
    case 308:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_fd_set))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_fd_set))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg4, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_fd_set))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg5, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_timespec))
	{
	  return (-1);
	}
      break;

      /* sys_ppoll */
    case 309:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  uint32_t nfds;
	  regcache_raw_read (record_regcache, tdep->arg2,
			     (gdb_byte *) & nfds);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_pollfd * nfds))
	    {
	      return (-1);
	    }
	}
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_timespec))
	{
	  return (-1);
	}
      break;

      /* sys_unshare */
    case 310:
      /* sys_set_robust_list */
    case 311:
      break;

      /* sys_get_robust_list */
    case 312:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_int))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_int))
	{
	  return (-1);
	}
      break;

      /* sys_splice */
    case 313:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_loff_t))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg4, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_loff_t))
	{
	  return (-1);
	}
      break;

      /* sys_sync_file_range */
    case 314:
      /* sys_tee */
    case 315:
      /* sys_vmsplice */
    case 316:
      break;

      /* sys_move_pages */
    case 317:
      regcache_raw_read (record_regcache, tdep->arg5, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  uint32_t nr_pages;
	  regcache_raw_read (record_regcache, tdep->arg2,
			     (gdb_byte *) & nr_pages);
	  if (record_arch_list_add_mem (tmpu32, nr_pages * tdep->size_int))
	    {
	      return (-1);
	    }
	}
      break;

      /* sys_getcpu */
    case 318:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_int))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_int))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_ulong * 2))
	{
	  return (-1);
	}
      break;

      /* sys_epoll_pwait */
    case 319:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  int32_t maxevents;
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & maxevents);
	  if (record_arch_list_add_mem
	      (tmpu32, maxevents * tdep->size_epoll_event))
	    {
	      return (-1);
	    }
	}
      break;

    default:
      printf_unfiltered (_
			 ("Record: record and reverse function doesn't support syscall number 0x%08x\n"),
			 tmpu32);
      return (-1);
      break;
    }

  return (0);
}
@


1.1.4.2
log
@2008-10-07  Hui Zhu  <teawater@@gmail.com>

	* i386-tdep.c, infrun.c, linux-record.c, linux-record.h,
	record.c, record.h: Change name from
	"record and reverse target" to
	"process record and replay target".
@
text
@d1 1
a1 1
/* Process record and replay target code for GNU/Linux.
@


1.1.2.1
log
@Add record target to GDB.
@
text
@a0 2350
/* Record and reverse target code for GNU/Linux.

   Copyright (C) 2008 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "target.h"
#include "regcache.h"
#include "record.h"
#include "linux-record.h"
#include <stdint.h>

/* These macros are the values of the first argument of system call
   "sys_ptrace". The values of these macros are gotten from Linux Kernel
   source. */

#define RECORD_PTRACE_PEEKTEXT	1
#define RECORD_PTRACE_PEEKDATA	2
#define RECORD_PTRACE_PEEKUSR	3

/* These macros are the values of the first argument of system call
   "sys_socketcall". The values of these macros are gotten from Linux Kernel
   source. */

#define RECORD_SYS_SOCKET	1
#define RECORD_SYS_BIND		2
#define RECORD_SYS_CONNECT	3
#define RECORD_SYS_LISTEN	4
#define RECORD_SYS_ACCEPT	5
#define RECORD_SYS_GETSOCKNAME	6
#define RECORD_SYS_GETPEERNAME	7
#define RECORD_SYS_SOCKETPAIR	8
#define RECORD_SYS_SEND		9
#define RECORD_SYS_RECV		10
#define RECORD_SYS_SENDTO	11
#define RECORD_SYS_RECVFROM	12
#define RECORD_SYS_SHUTDOWN	13
#define RECORD_SYS_SETSOCKOPT	14
#define RECORD_SYS_GETSOCKOPT	15
#define RECORD_SYS_SENDMSG	16
#define RECORD_SYS_RECVMSG	17

/* These macros are the values of the first argument of system call
   "sys_ipc". The values of these macros are gotten from Linux Kernel source. */

#define RECORD_SEMOP		1
#define RECORD_SEMGET		2
#define RECORD_SEMCTL		3
#define RECORD_SEMTIMEDOP	4
#define RECORD_MSGSND		11
#define RECORD_MSGRCV		12
#define RECORD_MSGGET		13
#define RECORD_MSGCTL		14
#define RECORD_SHMAT		21
#define RECORD_SHMDT		22
#define RECORD_SHMGET		23
#define RECORD_SHMCTL		24

/* These macros are the values of the first argument of system call
   "sys_quotactl". The values of these macros are gotten from Linux Kernel
   source. */

#define RECORD_Q_GETFMT		0x800004
#define RECORD_Q_GETINFO	0x800005
#define RECORD_Q_GETQUOTA	0x800007
#define RECORD_Q_XGETQSTAT	(('5'<<8)+(5))
#define RECORD_Q_XGETQUOTA	(('3'<<8)+(3))

/* Record the values of the registers and memory that will be changed in
   current system call.
   Return -1 if something wrong. */

int
record_linux_system_call (int num, linux_record_tdep_t * tdep)
{
  uint32_t tmpu32;

  switch (num)
    {
      /* sys_restart_syscall */
    case 0:
      {
	int q;
	target_terminal_ours ();
	q =
	  yquery (_
		  ("The next instruction is syscall restart. It will restart the computer. Do you want to pause the program."));
	target_terminal_inferior ();
	if (q)
	  {
	    return (1);
	  }
      }
      break;

      /* sys_exit */
    case 1:
      {
	int q;
	target_terminal_ours ();
	q =
	  yquery (_
		  ("The next instruction is syscall exit. It will make the program exit. Do you want to pause the program."));
	target_terminal_inferior ();
	if (q)
	  {
	    return (1);
	  }
      }
      break;

      /* sys_fork */
    case 2:
      break;

      /* sys_read */
    case 3:
      {
	uint32_t addr, count;
	regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & addr);
	regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & count);
	if (record_arch_list_add_mem (addr, count))
	  {
	    return (-1);
	  }
      }
      break;

      /* sys_write */
    case 4:
      /* sys_open */
    case 5:
      /* sys_close */
    case 6:
      /* sys_waitpid */
    case 7:
      /* sys_creat */
    case 8:
      /* sys_link */
    case 9:
      /* sys_unlink */
    case 10:
      /* sys_execve */
    case 11:
      /* sys_chdir */
    case 12:
      /* sys_time */
    case 13:
      /* sys_mknod */
    case 14:
      /* sys_chmod */
    case 15:
      /* sys_lchown16 */
    case 16:
      /* sys_ni_syscall */
    case 17:
      break;

      /* sys_stat */
    case 18:
      /* sys_fstat */
    case 28:
      /* sys_lstat */
    case 84:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size__old_kernel_stat))
	{
	  return (-1);
	}
      break;

      /* sys_lseek */
    case 19:
      /* sys_getpid */
    case 20:
      /* sys_mount */
    case 21:
      /* sys_oldumount */
    case 22:
      /* sys_setuid16 */
    case 23:
      /* sys_getuid16 */
    case 24:
      /* sys_stime */
    case 25:
      break;

      /* sys_ptrace */
    case 26:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (tmpu32 == RECORD_PTRACE_PEEKTEXT
	  || tmpu32 == RECORD_PTRACE_PEEKDATA
	  || tmpu32 == RECORD_PTRACE_PEEKUSR)
	{
	  regcache_raw_read (record_regcache, tdep->arg4,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, 4))
	    {
	      return (-1);
	    }
	}
      break;

      /* sys_alarm */
    case 27:
      /* sys_pause */
    case 29:
      /* sys_utime    */
    case 30:
      /* sys_ni_syscall */
    case 31:
      /* sys_ni_syscall */
    case 32:
      /* sys_access */
    case 33:
      /* sys_nice */
    case 34:
      /* sys_ni_syscall */
    case 35:
      /* sys_sync */
    case 36:
      /* sys_kill */
    case 37:
      /* sys_rename */
    case 38:
      /* sys_mkdir */
    case 39:
      /* sys_rmdir */
    case 40:
      /* sys_dup */
    case 41:
      /* sys_pipe */
    case 42:
      break;

      /* sys_times */
    case 43:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_tms))
	{
	  return (-1);
	}
      break;

      /* sys_ni_syscall */
    case 44:
      /* sys_brk */
    case 45:
      /* sys_setgid16 */
    case 46:
      /* sys_getgid16 */
    case 47:
      /* sys_signal */
    case 48:
      /* sys_geteuid16 */
    case 49:
      /* sys_getegid16 */
    case 50:
      /* sys_acct */
    case 51:
      /* sys_umount */
    case 52:
      /* sys_ni_syscall */
    case 53:
      break;

      /* sys_ioctl */
    case 54:
      /* XXX there need add a lot of support of other ioctl requests. */
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (tmpu32 == tdep->ioctl_FIOCLEX && tmpu32 == tdep->ioctl_FIONCLEX
	  && tmpu32 == tdep->ioctl_FIONBIO && tmpu32 == tdep->ioctl_FIOASYNC)
	{
	  /* need do nothing. */
	}
      else if (tmpu32 == tdep->ioctl_FIOQSIZE)
	{
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_loff_t))
	    {
	      return (-1);
	    }
	}
      else
	{
	  printf_unfiltered (_
			     ("Record: record and reverse function don't support ioctl request 0x%08x\n"),
			     tmpu32);
	  return (-1);
	}
      break;

      /* sys_fcntl */
    case 55:
      /* XXX */
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
    sys_fcntl:
      if (tmpu32 == F_GETLK)
	{
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_flock))
	    {
	      return (-1);
	    }
	}
      break;

      /* sys_ni_syscall */
    case 56:
      /* sys_setpgid */
    case 57:
      /* sys_ni_syscall */
    case 58:
      break;

      /* sys_olduname */
    case 59:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_oldold_utsname))
	{
	  return (-1);
	}
      break;

      /* sys_umask */
    case 60:
      /* sys_chroot */
    case 61:
      break;

      /* sys_ustat */
    case 62:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_ustat))
	{
	  return (-1);
	}
      break;

      /* sys_dup2 */
    case 63:
      /* sys_getppid */
    case 64:
      /* sys_getpgrp */
    case 65:
      /* sys_setsid */
    case 66:
      break;

      /* sys_sigaction */
    case 67:
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_old_sigaction))
	{
	  return (-1);
	}
      break;

      /* sys_sgetmask */
    case 68:
      /* sys_ssetmask */
    case 69:
      /* sys_setreuid16 */
    case 70:
      /* sys_setregid16 */
    case 71:
      /* sys_sigsuspend */
    case 72:
      break;

      /* sys_sigpending */
    case 73:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_old_sigset_t))
	{
	  return (-1);
	}
      break;

      /* sys_sethostname */
    case 74:
      /* sys_setrlimit */
    case 75:
      break;

      /* sys_old_getrlimit */
    case 76:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_rlimit))
	{
	  return (-1);
	}
      break;

      /* sys_getrusage */
    case 77:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_rusage))
	{
	  return (-1);
	}
      break;

      /* sys_gettimeofday */
    case 78:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_timeval))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_timezone))
	{
	  return (-1);
	}
      break;

      /* sys_settimeofday */
    case 79:
      break;

      /* sys_getgroups16 */
    case 80:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_old_gid_t))
	{
	  return (-1);
	}
      break;

      /* sys_setgroups16 */
    case 81:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_old_gid_t))
	{
	  return (-1);
	}
      break;

      /* old_select */
    case 82:
      {
	/*
	   struct sel_arg_struct {
	   unsigned long n;
	   fd_set *inp;
	   fd_set *outp;
	   fd_set *exp;
	   struct timeval *tvp;
	   };
	 */
	struct sel_arg_struct
	{
	  uint32_t n;
	  uint32_t inp;
	  uint32_t outp;
	  uint32_t exp;
	  uint32_t tvp;
	} sel;

	regcache_raw_read (record_regcache, tdep->arg1,
			   (gdb_byte *) & tmpu32);
	if (tmpu32)
	  {
	    if (target_read_memory (tmpu32, (gdb_byte *) & sel, sizeof (sel)))
	      {
		fprintf_unfiltered (gdb_stdlog,
				    "Record: read memory addr = 0x%s len = %d error.\n",
				    paddr_nz (tmpu32), sizeof (sel));
		return (-1);
	      }
	    if (record_arch_list_add_mem (sel.inp, tdep->size_fd_set))
	      {
		return (-1);
	      }
	    if (record_arch_list_add_mem (sel.outp, tdep->size_fd_set))
	      {
		return (-1);
	      }
	    if (record_arch_list_add_mem (sel.exp, tdep->size_fd_set))
	      {
		return (-1);
	      }
	    if (record_arch_list_add_mem (sel.tvp, tdep->size_timeval))
	      {
		return (-1);
	      }
	  }
      }
      break;

      /* sys_symlink */
    case 83:
      break;

      /* sys_readlink */
    case 85:
      {
	uint32_t len;
	regcache_raw_read (record_regcache, tdep->arg2,
			   (gdb_byte *) & tmpu32);
	regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & len);
	if (record_arch_list_add_mem (tmpu32, len))
	  {
	    return (-1);
	  }
      }
      break;

      /* sys_uselib */
    case 86:
      /* sys_swapon */
    case 87:
      break;

      /* sys_reboot */
    case 88:
      {
	int q;
	target_terminal_ours ();
	q =
	  yquery (_
		  ("The next instruction is syscall reboot. It will restart the computer. Do you want to pause the program."));
	target_terminal_inferior ();
	if (q)
	  {
	    return (1);
	  }
      }
      break;

      /* old_readdir */
    case 89:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_dirent))
	{
	  return (-1);
	}
      break;

      /* old_mmap */
    case 90:
      break;

      /* sys_munmap */
    case 91:
      {
	int q;
	uint32_t len;

	regcache_raw_read (record_regcache, tdep->arg1,
			   (gdb_byte *) & tmpu32);
	regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & len);
	target_terminal_ours ();
	q =
	  yquery (_
		  ("The next instruction is syscall munmap. It will free the memory addr = 0x%s len = %d. Do you want to pause the program."),
		  paddr_nz (tmpu32), len);
	target_terminal_inferior ();
	if (q)
	  {
	    return (1);
	  }
      }
      break;

      /* sys_truncate */
    case 92:
      /* sys_ftruncate */
    case 93:
      /* sys_fchmod */
    case 94:
      /* sys_fchown16 */
    case 95:
      /* sys_getpriority */
    case 96:
      /* sys_setpriority */
    case 97:
      /* sys_ni_syscall */
    case 98:
      break;

      /* sys_statfs */
    case 99:
      /* sys_fstatfs */
    case 100:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_statfs))
	{
	  return (-1);
	}
      break;

      /* sys_ioperm */
    case 101:
      break;

      /* sys_socketcall */
    case 102:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      switch (tmpu32)
	{
	case RECORD_SYS_SOCKET:
	case RECORD_SYS_BIND:
	case RECORD_SYS_CONNECT:
	case RECORD_SYS_LISTEN:
	  break;
	case RECORD_SYS_ACCEPT:
	case RECORD_SYS_GETSOCKNAME:
	case RECORD_SYS_GETPEERNAME:
	  {
	    uint32_t a[3];
	    regcache_raw_read (record_regcache, tdep->arg2,
			       (gdb_byte *) & tmpu32);
	    if (tmpu32)
	      {
		if (target_read_memory (tmpu32, (gdb_byte *) a, sizeof (a)))
		  {
		    fprintf_unfiltered (gdb_stdlog,
					"Record: read memory addr = 0x%s len = %d error.\n",
					paddr_nz (tmpu32), sizeof (a));
		    return (-1);
		  }
		if (record_arch_list_add_mem (a[1], tdep->size_sockaddr))
		  {
		    return (-1);
		  }
		if (record_arch_list_add_mem (a[2], tdep->size_int))
		  {
		    return (-1);
		  }
	      }
	  }
	  break;

	case RECORD_SYS_SOCKETPAIR:
	  {
	    uint32_t a[4];
	    regcache_raw_read (record_regcache, tdep->arg2,
			       (gdb_byte *) & tmpu32);
	    if (tmpu32)
	      {
		if (target_read_memory (tmpu32, (gdb_byte *) a, sizeof (a)))
		  {
		    fprintf_unfiltered (gdb_stdlog,
					"Record: read memory addr = 0x%s len = %d error.\n",
					paddr_nz (tmpu32), sizeof (a));
		    return (-1);
		  }
		if (record_arch_list_add_mem (a[3], tdep->size_int))
		  {
		    return (-1);
		  }
	      }
	  }
	  break;
	case RECORD_SYS_SEND:
	case RECORD_SYS_SENDTO:
	  break;
	case RECORD_SYS_RECV:
	  {
	    uint32_t a[3];
	    regcache_raw_read (record_regcache, tdep->arg2,
			       (gdb_byte *) & tmpu32);
	    if (tmpu32)
	      {
		if (target_read_memory (tmpu32, (gdb_byte *) a, sizeof (a)))
		  {
		    fprintf_unfiltered (gdb_stdlog,
					"Record: read memory addr = 0x%s len = %d error.\n",
					paddr_nz (tmpu32), sizeof (a));
		    return (-1);
		  }
		if (a[2])
		  {
		    if (target_read_memory
			(a[2], (gdb_byte *) & (a[2]), sizeof (a[2])))
		      {
			fprintf_unfiltered (gdb_stdlog,
					    "Record: read memory addr = 0x%s len = %d error.\n",
					    paddr_nz (a[2]), sizeof (a[2]));
			return (-1);
		      }
		    if (record_arch_list_add_mem (a[1], a[2]))
		      {
			return (-1);
		      }
		  }
	      }
	  }
	  break;
	case RECORD_SYS_RECVFROM:
	  {
	    uint32_t a[6];
	    regcache_raw_read (record_regcache, tdep->arg2,
			       (gdb_byte *) & tmpu32);
	    if (tmpu32)
	      {
		if (target_read_memory (tmpu32, (gdb_byte *) a, sizeof (a)))
		  {
		    fprintf_unfiltered (gdb_stdlog,
					"Record: read memory addr = 0x%s len = %d error.\n",
					paddr_nz (tmpu32), sizeof (a));
		    return (-1);
		  }
		if (a[2])
		  {
		    if (target_read_memory
			(a[2], (gdb_byte *) & (a[2]), sizeof (a[2])))
		      {
			fprintf_unfiltered (gdb_stdlog,
					    "Record: read memory addr = 0x%s len = %d error.\n",
					    paddr_nz (a[2]), sizeof (a[2]));
			return (-1);
		      }
		    if (record_arch_list_add_mem (a[1], a[2]))
		      {
			return (-1);
		      }
		    if (record_arch_list_add_mem (a[4], tdep->size_sockaddr))
		      {
			return (-1);
		      }
		    if (record_arch_list_add_mem (a[5], tdep->size_int))
		      {
			return (-1);
		      }
		  }
	      }
	  }
	  break;
	case RECORD_SYS_SHUTDOWN:
	case RECORD_SYS_SETSOCKOPT:
	  break;
	case RECORD_SYS_GETSOCKOPT:
	  {
	    uint32_t a[5];
	    uint32_t av;

	    regcache_raw_read (record_regcache, tdep->arg2,
			       (gdb_byte *) & tmpu32);
	    if (tmpu32)
	      {
		if (target_read_memory (tmpu32, (gdb_byte *) a, sizeof (a)))
		  {
		    fprintf_unfiltered (gdb_stdlog,
					"Record: read memory addr = 0x%s len = %d error.\n",
					paddr_nz (tmpu32), sizeof (a));
		    return (-1);
		  }
		if (a[4])
		  {
		    if (target_read_memory
			(a[4], (gdb_byte *) & av, sizeof (av)))
		      {
			fprintf_unfiltered (gdb_stdlog,
					    "Record: read memory addr = 0x%s len = %d error.\n",
					    paddr_nz (a[4]), sizeof (av));
			return (-1);
		      }
		    if (record_arch_list_add_mem (a[3], av))
		      {
			return (-1);
		      }
		    if (record_arch_list_add_mem (a[4], tdep->size_int))
		      {
			return (-1);
		      }
		  }
	      }
	  }
	  break;
	case RECORD_SYS_SENDMSG:
	  break;
	case RECORD_SYS_RECVMSG:
	  {
	    uint32_t a[2], i;
	    struct record_msghdr
	    {
	      uint32_t msg_name;
	      uint32_t msg_namelen;
	      uint32_t msg_iov;
	      uint32_t msg_iovlen;
	      uint32_t msg_control;
	      uint32_t msg_controllen;
	      uint32_t msg_flags;
	    } rec;
	    struct record_iovec
	    {
	      uint32_t iov_base;
	      uint32_t iov_len;
	    } iov;

	    regcache_raw_read (record_regcache, tdep->arg2,
			       (gdb_byte *) & tmpu32);
	    if (tmpu32)
	      {
		if (target_read_memory (tmpu32, (gdb_byte *) a, sizeof (a)))
		  {
		    fprintf_unfiltered (gdb_stdlog,
					"Record: read memory addr = 0x%s len = %d error.\n",
					paddr_nz (tmpu32), sizeof (a));
		    return (-1);
		  }
		if (record_arch_list_add_mem (a[1], tdep->size_msghdr))
		  {
		    return (-1);
		  }
		if (a[1])
		  {
		    if (target_read_memory
			(a[1], (gdb_byte *) & rec, sizeof (rec)))
		      {
			fprintf_unfiltered (gdb_stdlog,
					    "Record: read memory addr = 0x%s len = %d error.\n",
					    paddr_nz (a[1]), sizeof (rec));
			return (-1);
		      }
		    if (record_arch_list_add_mem
			(rec.msg_name, rec.msg_namelen))
		      {
			return (-1);
		      }
		    if (record_arch_list_add_mem
			(rec.msg_control, rec.msg_controllen))
		      {
			return (-1);
		      }
		    if (rec.msg_iov)
		      {
			for (i = 0; i < rec.msg_iovlen; i++)
			  {
			    if (target_read_memory
				(rec.msg_iov, (gdb_byte *) & iov,
				 sizeof (iov)))
			      {
				fprintf_unfiltered (gdb_stdlog,
						    "Record: read memory addr = 0x%s len = %d error.\n",
						    paddr_nz (rec.msg_iov),
						    sizeof (iov));
				return (-1);
			      }
			    if (record_arch_list_add_mem
				(iov.iov_base, iov.iov_len))
			      {
				return (-1);
			      }
			    rec.msg_iov += sizeof (struct record_iovec);
			  }
		      }
		  }
	      }
	  }
	  break;
	default:
	  printf_unfiltered (_
			     ("Record: record and reverse function don't support socketcall call 0x%08x\n"),
			     tmpu32);
	  return (-1);
	  break;
	}
      break;

      /* sys_syslog */
    case 103:
      break;

      /* sys_setitimer */
    case 104:
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_itimerval))
	{
	  return (-1);
	}
      break;

      /* sys_getitimer */
    case 105:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_itimerval))
	{
	  return (-1);
	}
      break;

      /* sys_newstat */
    case 106:
      /* sys_newlstat */
    case 107:
      /* sys_newfstat */
    case 108:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_stat))
	{
	  return (-1);
	}
      break;

      /* sys_uname */
    case 109:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_old_utsname))
	{
	  return (-1);
	}
      break;

      /* sys_iopl */
    case 110:
      /* sys_vhangup */
    case 111:
      /* sys_ni_syscall */
    case 112:
      /* sys_vm86old */
    case 113:
      break;

      /* sys_wait4 */
    case 114:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_int))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg4, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_rusage))
	{
	  return (-1);
	}
      break;

      /* sys_swapoff */
    case 115:
      break;

      /* sys_sysinfo */
    case 116:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_sysinfo))
	{
	  return (-1);
	}
      break;

      /* sys_ipc */
    case 117:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      switch (tmpu32)
	{
	case RECORD_MSGRCV:
	  {
	    int32_t second;
	    uint32_t ptr;
	    regcache_raw_read (record_regcache, tdep->arg3,
			       (gdb_byte *) & second);
	    regcache_raw_read (record_regcache, tdep->arg5,
			       (gdb_byte *) & ptr);
	    if (record_arch_list_add_mem (ptr, second + tdep->size_long))
	      {
		return (-1);
	      }
	  }
	  break;
	case RECORD_MSGCTL:
	  regcache_raw_read (record_regcache, tdep->arg5,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_msqid_ds))
	    {
	      return (-1);
	    }
	  break;
	case RECORD_SHMAT:
	  regcache_raw_read (record_regcache, tdep->arg4,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_ulong))
	    {
	      return (-1);
	    }
	  break;
	case RECORD_SHMCTL:
	  regcache_raw_read (record_regcache, tdep->arg5,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_shmid_ds))
	    {
	      return (-1);
	    }
	  break;
	}
      break;

      /* sys_fsync */
    case 118:
      /* sys_sigreturn */
    case 119:
      /* sys_clone */
    case 120:
      /* sys_setdomainname */
    case 121:
      break;

      /* sys_newuname */
    case 122:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_new_utsname))
	{
	  return (-1);
	}
      break;

      /* sys_modify_ldt */
    case 123:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (tmpu32 == 0 || tmpu32 == 2)
	{
	  uint32_t ptr, bytecount;
	  regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & ptr);
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & bytecount);
	  if (record_arch_list_add_mem (ptr, bytecount))
	    {
	      return (-1);
	    }
	}
      break;

      /* sys_adjtimex */
    case 124:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_timex))
	{
	  return (-1);
	}
      break;

      /* sys_mprotect */
    case 125:
      break;

      /* sys_sigprocmask */
    case 126:
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_old_sigset_t))
	{
	  return (-1);
	}
      break;

      /* sys_ni_syscall */
    case 127:
      /* sys_init_module */
    case 128:
      /* sys_delete_module */
    case 129:
      /* sys_ni_syscall */
    case 130:
      break;

      /* sys_quotactl */
    case 131:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      switch (tmpu32)
	{
	case RECORD_Q_GETFMT:
	  regcache_raw_read (record_regcache, tdep->arg4,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, 4))
	    {
	      return (-1);
	    }
	  break;
	case RECORD_Q_GETINFO:
	  regcache_raw_read (record_regcache, tdep->arg4,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_mem_dqinfo))
	    {
	      return (-1);
	    }
	  break;
	case RECORD_Q_GETQUOTA:
	  regcache_raw_read (record_regcache, tdep->arg4,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_if_dqblk))
	    {
	      return (-1);
	    }
	  break;
	case RECORD_Q_XGETQSTAT:
	case RECORD_Q_XGETQUOTA:
	  regcache_raw_read (record_regcache, tdep->arg4,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_fs_quota_stat))
	    {
	      return (-1);
	    }
	  break;
	}
      break;

      /* sys_getpgid */
    case 132:
      /* sys_fchdir */
    case 133:
      /* sys_bdflush */
    case 134:
      break;

      /* sys_sysfs */
    case 135:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (tmpu32 == 2)
	{
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & tmpu32);
	  /*XXX the size of memory is not very clear */
	  if (record_arch_list_add_mem (tmpu32, 10))
	    {
	      return (-1);
	    }
	}
      break;

      /* sys_personality */
    case 136:
      /* sys_ni_syscall */
    case 137:
      /* sys_setfsuid16 */
    case 138:
      /* sys_setfsgid16 */
    case 139:
      break;

      /* sys_llseek */
    case 140:
      regcache_raw_read (record_regcache, tdep->arg4, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_loff_t))
	{
	  return (-1);
	}
      break;

      /* sys_getdents */
    case 141:
      {
	uint32_t count;
	regcache_raw_read (record_regcache, tdep->arg2,
			   (gdb_byte *) & tmpu32);
	regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & count);
	if (record_arch_list_add_mem (tmpu32, tdep->size_dirent * count))
	  {
	    return (-1);
	  }
      }
      break;

      /* sys_select */
    case 142:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_fd_set))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_fd_set))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg4, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_fd_set))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg5, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_timeval))
	{
	  return (-1);
	}
      break;

      /* sys_flock */
    case 143:
      /* sys_msync */
    case 144:
      break;

      /* sys_readv */
    case 145:
      {
	uint32_t vec;
	uint32_t vlen;
	struct record_iovec
	{
	  uint32_t iov_base;
	  uint32_t iov_len;
	} iov;
	regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & vec);
	if (vec)
	  {
	    regcache_raw_read (record_regcache, tdep->arg3,
			       (gdb_byte *) & vlen);
	    for (tmpu32 = 0; tmpu32 < vlen; tmpu32++)
	      {
		if (target_read_memory
		    (vec, (gdb_byte *) & iov, sizeof (struct record_iovec)))
		  {
		    fprintf_unfiltered (gdb_stdlog,
					"Record: read memory addr = 0x%s len = %d error.\n",
					paddr_nz (vec),
					sizeof (struct record_iovec));
		    return (-1);
		  }
		if (record_arch_list_add_mem (iov.iov_base, iov.iov_len))
		  {
		    return (-1);
		  }
		vec += sizeof (struct record_iovec);
	      }
	  }
      }
      break;

      /* sys_writev */
    case 146:
      /* sys_getsid */
    case 147:
      /* sys_fdatasync */
    case 148:
      /* sys_sysctl */
    case 149:
      /* sys_mlock */
    case 150:
      /* sys_munlock */
    case 151:
      /* sys_mlockall */
    case 152:
      /* sys_munlockall */
    case 153:
      /* sys_sched_setparam */
    case 154:
      break;

      /* sys_sched_getparam */
    case 155:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_int))
	{
	  return (-1);
	}
      break;

      /* sys_sched_setscheduler */
    case 156:
      /* sys_sched_getscheduler */
    case 157:
      /* sys_sched_yield */
    case 158:
      /* sys_sched_get_priority_max */
    case 159:
      /* sys_sched_get_priority_min */
    case 160:
      break;

      /* sys_sched_rr_get_interval */
    case 161:
      /* sys_nanosleep */
    case 162:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_timespec))
	{
	  return (-1);
	}
      break;

      /* sys_mremap */
    case 163:
      /* sys_setresuid16 */
    case 164:
      break;

      /* sys_getresuid16 */
    case 165:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_old_uid_t))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_old_uid_t))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_old_uid_t))
	{
	  return (-1);
	}
      break;

      /* sys_vm86 */
    case 166:
      /* sys_ni_syscall */
    case 167:
      break;

      /* sys_poll */
    case 168:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  uint32_t nfds;
	  regcache_raw_read (record_regcache, tdep->arg2,
			     (gdb_byte *) & nfds);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_pollfd * nfds))
	    {
	      return (-1);
	    }
	}
      break;

      /* sys_nfsservctl */
    case 169:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (tmpu32 == 7 || tmpu32 == 8)
	{
	  uint32_t rsize;
	  if (tmpu32 == 7)
	    {
	      rsize = tdep->size_NFS_FHSIZE;
	    }
	  else
	    {
	      rsize = tdep->size_knfsd_fh;
	    }
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, rsize))
	    {
	      return (-1);
	    }
	}
      break;

      /* sys_setresgid16 */
    case 170:
      break;

      /* sys_getresgid16 */
    case 171:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_old_gid_t))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_old_gid_t))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_old_gid_t))
	{
	  return (-1);
	}
      break;

      /* sys_prctl */
    case 172:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      switch (tmpu32)
	{
	case 2:
	  regcache_raw_read (record_regcache, tdep->arg2,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_int))
	    {
	      return (-1);
	    }
	  break;
	case 16:
	  regcache_raw_read (record_regcache, tdep->arg2,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_TASK_COMM_LEN))
	    {
	      return (-1);
	    }
	  break;
	}
      break;

      /* sys_rt_sigreturn */
    case 173:
      break;

      /* sys_rt_sigaction */
    case 174:
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_sigaction))
	{
	  return (-1);
	}
      break;

      /* sys_rt_sigprocmask */
    case 175:
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_sigset_t))
	{
	  return (-1);
	}
      break;

      /* sys_rt_sigpending */
    case 176:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  uint32_t sigsetsize;
	  regcache_raw_read (record_regcache, tdep->arg2,
			     (gdb_byte *) & sigsetsize);
	  if (record_arch_list_add_mem (tmpu32, sigsetsize))
	    {
	      return (-1);
	    }
	}
      break;

      /* sys_rt_sigtimedwait */
    case 177:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_siginfo_t))
	{
	  return (-1);
	}
      break;

      /* sys_rt_sigqueueinfo */
    case 178:
      /* sys_rt_sigsuspend */
    case 179:
      break;

      /* sys_pread64 */
    case 180:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  uint32_t count;
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & count);
	  if (record_arch_list_add_mem (tmpu32, count))
	    {
	      return (-1);
	    }
	}
      break;

      /* sys_pwrite64 */
    case 181:
      /* sys_chown16 */
    case 182:
      break;

      /* sys_getcwd */
    case 183:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  uint32_t size;
	  regcache_raw_read (record_regcache, tdep->arg2,
			     (gdb_byte *) & size);
	  if (record_arch_list_add_mem (tmpu32, size))
	    {
	      return (-1);
	    }
	}
      break;

      /* sys_capget */
    case 184:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_cap_user_data_t))
	{
	  return (-1);
	}
      break;

      /* sys_capset */
    case 185:
      break;

      /* sys_sigaltstack */
    case 186:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_stack_t))
	{
	  return (-1);
	}
      break;

      /* sys_sendfile */
    case 187:
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_off_t))
	{
	  return (-1);
	}
      break;

      /* sys_ni_syscall */
    case 188:
      /* sys_ni_syscall */
    case 189:
      /* sys_vfork */
    case 190:
      break;

      /* sys_getrlimit */
    case 191:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_rlimit))
	{
	  return (-1);
	}
      break;

      /* sys_mmap2 */
    case 192:
      break;

      /* sys_truncate64 */
    case 193:
      /* sys_ftruncate64 */
    case 194:
      break;

      /* sys_stat64 */
    case 195:
      /* sys_lstat64 */
    case 196:
      /* sys_fstat64 */
    case 197:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_stat64))
	{
	  return (-1);
	}
      break;

      /* sys_lchown */
    case 198:
      /* sys_getuid */
    case 199:
      /* sys_getgid */
    case 200:
      /* sys_geteuid */
    case 201:
      /* sys_getegid */
    case 202:
      /* sys_setreuid */
    case 203:
      /* sys_setregid */
    case 204:
      break;

      /* sys_getgroups */
    case 205:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  int gidsetsize;
	  regcache_raw_read (record_regcache, tdep->arg1,
			     (gdb_byte *) & gidsetsize);
	  if (record_arch_list_add_mem
	      (tmpu32, tdep->size_gid_t * gidsetsize))
	    {
	      return (-1);
	    }
	}
      break;

      /* sys_setgroups */
    case 206:
      /* sys_fchown */
    case 207:
      /* sys_setresuid */
    case 208:
      break;

      /* sys_getresuid */
    case 209:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_uid_t))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_uid_t))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_uid_t))
	{
	  return (-1);
	}
      break;

      /* sys_setresgid */
    case 210:
      break;

      /* sys_getresgid */
    case 211:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_gid_t))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_gid_t))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_gid_t))
	{
	  return (-1);
	}
      break;

      /* sys_chown */
    case 212:
      /* sys_setuid */
    case 213:
      /* sys_setgid */
    case 214:
      /* sys_setfsuid */
    case 215:
      /* sys_setfsgid */
    case 216:
      /* sys_pivot_root */
    case 217:
      break;

      /* sys_mincore */
    case 218:
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_PAGE_SIZE))
	{
	  return (-1);
	}
      break;

      /* sys_madvise */
    case 219:
      break;

      /* sys_getdents64 */
    case 220:
      {
	uint32_t count;
	regcache_raw_read (record_regcache, tdep->arg2,
			   (gdb_byte *) & tmpu32);
	regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & count);
	if (record_arch_list_add_mem (tmpu32, tdep->size_dirent64 * count))
	  {
	    return (-1);
	  }
      }
      break;

      /* sys_fcntl64 */
    case 221:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      switch (tmpu32)
	{
	case F_GETLK64:
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_flock64))
	    {
	      return (-1);
	    }
	  break;
	case F_SETLK64:
	case F_SETLKW64:
	  break;
	default:
	  goto sys_fcntl;
	  break;
	}
      break;

      /* sys_ni_syscall */
    case 222:
      /* sys_ni_syscall */
    case 223:
      /* sys_gettid */
    case 224:
      /* sys_readahead */
    case 225:
      /* sys_setxattr */
    case 226:
      /* sys_lsetxattr */
    case 227:
      /* sys_fsetxattr */
    case 228:
      break;

      /* sys_getxattr */
    case 229:
      /* sys_lgetxattr */
    case 230:
      /* sys_fgetxattr */
    case 231:
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  uint32_t size;
	  regcache_raw_read (record_regcache, tdep->arg4,
			     (gdb_byte *) & size);
	  if (record_arch_list_add_mem (tmpu32, size))
	    {
	      return (-1);
	    }
	}
      break;

      /* sys_listxattr */
    case 232:
      /* sys_llistxattr */
    case 233:
      /* sys_flistxattr */
    case 234:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  uint32_t size;
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & size);
	  if (record_arch_list_add_mem (tmpu32, size))
	    {
	      return (-1);
	    }
	}
      break;

      /* sys_removexattr */
    case 235:
      /* sys_lremovexattr */
    case 236:
      /* sys_fremovexattr */
    case 237:
      /* sys_tkill */
    case 238:
      break;

      /* sys_sendfile64 */
    case 239:
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_loff_t))
	{
	  return (-1);
	}
      break;

      /* sys_futex */
    case 240:
      /* sys_sched_setaffinity */
    case 241:
      break;

      /* sys_sched_getaffinity */
    case 242:
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  uint32_t len;
	  regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & len);
	  if (record_arch_list_add_mem (tmpu32, len))
	    {
	      return (-1);
	    }
	}
      break;

      /* sys_set_thread_area */
    case 243:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_int))
	{
	  return (-1);
	}
      break;

      /* sys_get_thread_area */
    case 244:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_user_desc))
	{
	  return (-1);
	}
      break;

      /* sys_io_setup */
    case 245:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_long))
	{
	  return (-1);
	}
      break;

      /* sys_io_destroy */
    case 246:
      break;

      /* sys_io_getevents */
    case 247:
      regcache_raw_read (record_regcache, tdep->arg4, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  int32_t nr;
	  regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & nr);
	  if (record_arch_list_add_mem (tmpu32, nr * tdep->size_io_event))
	    {
	      return (-1);
	    }
	}
      break;

      /* sys_io_submit */
    case 248:
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  int32_t i, nr;
	  uint32_t *iocbp;
	  regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & nr);
	  iocbp = (uint32_t *) alloca (nr * tdep->size_int);
	  if (target_read_memory
	      (tmpu32, (gdb_byte *) iocbp, nr * tdep->size_int))
	    {
	      fprintf_unfiltered (gdb_stdlog,
				  "Record: read memory addr = 0x%s len = %d error.\n",
				  paddr_nz (tmpu32), nr * tdep->size_int);
	      return (-1);
	    }
	  for (i = 0; i < nr; i++)
	    {
	      if (record_arch_list_add_mem (iocbp[i], tdep->size_iocb))
		{
		  return (-1);
		}
	    }
	}
      break;

      /* sys_io_cancel */
    case 249:
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_io_event))
	{
	  return (-1);
	}
      break;

      /* sys_fadvise64 */
    case 250:
      /* sys_ni_syscall */
    case 251:
      break;

      /* sys_exit_group */
    case 252:
      {
	int q;
	target_terminal_ours ();
	q =
	  yquery (_
		  ("The next instruction is syscall exit_group. It will make the program exit. Do you want to pause the program."));
	target_terminal_inferior ();
	if (q)
	  {
	    return (1);
	  }
      }
      break;

      /* sys_lookup_dcookie */
    case 253:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  uint32_t len;
	  regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & len);
	  if (record_arch_list_add_mem (tmpu32, len))
	    {
	      return (-1);
	    }
	}
      break;

      /* sys_epoll_create */
    case 254:
      /* sys_epoll_ctl */
    case 255:
      break;

      /* sys_epoll_wait */
    case 256:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  int32_t maxevents;
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & maxevents);
	  if (record_arch_list_add_mem
	      (tmpu32, maxevents * tdep->size_epoll_event))
	    {
	      return (-1);
	    }
	}
      break;

      /* sys_remap_file_pages */
    case 257:
      /* sys_set_tid_address */
    case 258:
      break;

      /* sys_timer_create */
    case 259:
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_int))
	{
	  return (-1);
	}
      break;

      /* sys_timer_settime */
    case 260:
      regcache_raw_read (record_regcache, tdep->arg4, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_itimerspec))
	{
	  return (-1);
	}
      break;

      /* sys_timer_gettime */
    case 261:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_itimerspec))
	{
	  return (-1);
	}
      break;

      /* sys_timer_getoverrun */
    case 262:
      /* sys_timer_delete */
    case 263:
      /* sys_clock_settime */
    case 264:
      break;

      /* sys_clock_gettime */
    case 265:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_timespec))
	{
	  return (-1);
	}
      break;

      /* sys_clock_getres */
    case 266:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_timespec))
	{
	  return (-1);
	}
      break;

      /* sys_clock_nanosleep */
    case 267:
      regcache_raw_read (record_regcache, tdep->arg4, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_timespec))
	{
	  return (-1);
	}
      break;

      /* sys_statfs64 */
    case 268:
      /* sys_fstatfs64 */
    case 269:
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_statfs64))
	{
	  return (-1);
	}
      break;

      /* sys_tgkill */
    case 270:
      /* sys_utimes */
    case 271:
      /* sys_fadvise64_64 */
    case 272:
      /* sys_ni_syscall */
    case 273:
      /* sys_mbind */
    case 274:
      break;

      /* sys_get_mempolicy */
    case 275:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_int))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  uint32_t maxnode;
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & maxnode);
	  if (record_arch_list_add_mem (tmpu32, maxnode * tdep->size_long))
	    {
	      return (-1);
	    }
	}
      break;

      /* sys_set_mempolicy */
    case 276:
      /* sys_mq_open */
    case 277:
      /* sys_mq_unlink */
    case 278:
      /* sys_mq_timedsend */
    case 279:
      break;

      /* sys_mq_timedreceive */
    case 280:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  uint32_t msg_len;
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & msg_len);
	  if (record_arch_list_add_mem (tmpu32, msg_len))
	    {
	      return (-1);
	    }
	}
      regcache_raw_read (record_regcache, tdep->arg4, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_int))
	{
	  return (-1);
	}
      break;

      /* sys_mq_notify */
    case 281:
      break;

      /* sys_mq_getsetattr */
    case 282:
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_mq_attr))
	{
	  return (-1);
	}
      break;

      /* sys_kexec_load */
    case 283:
      break;

      /* sys_waitid */
    case 284:
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_siginfo))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg5, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_rusage))
	{
	  return (-1);
	}
      break;

      /* sys_ni_syscall */
    case 285:
      /* sys_add_key */
    case 286:
      /* sys_request_key */
    case 287:
      break;

      /* sys_keyctl */
    case 288:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (tmpu32 == 6 || tmpu32 == 11)
	{
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & tmpu32);
	  if (tmpu32)
	    {
	      uint32_t buflen;
	      regcache_raw_read (record_regcache, tdep->arg4,
				 (gdb_byte *) & buflen);
	      if (record_arch_list_add_mem (tmpu32, buflen))
		{
		  return (-1);
		}
	    }
	}
      break;

      /* sys_ioprio_set */
    case 289:
      /* sys_ioprio_get */
    case 290:
      /* sys_inotify_init */
    case 291:
      /* sys_inotify_add_watch */
    case 292:
      /* sys_inotify_rm_watch */
    case 293:
      /* sys_migrate_pages */
    case 294:
      /* sys_openat */
    case 295:
      /* sys_mkdirat */
    case 296:
      /* sys_mknodat */
    case 297:
      /* sys_fchownat */
    case 298:
      /* sys_futimesat */
    case 299:
      break;

      /* sys_fstatat64 */
    case 300:
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_stat64))
	{
	  return (-1);
	}
      break;

      /* sys_unlinkat */
    case 301:
      /* sys_renameat */
    case 302:
      /* sys_linkat */
    case 303:
      /* sys_symlinkat */
    case 304:
      break;

      /* sys_readlinkat */
    case 305:
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  int32_t bufsiz;
	  regcache_raw_read (record_regcache, tdep->arg4,
			     (gdb_byte *) & bufsiz);
	  if (record_arch_list_add_mem (tmpu32, bufsiz))
	    {
	      return (-1);
	    }
	}
      break;

      /* sys_fchmodat */
    case 306:
      /* sys_faccessat */
    case 307:
      break;

      /* sys_pselect6 */
    case 308:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_fd_set))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_fd_set))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg4, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_fd_set))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg5, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_timespec))
	{
	  return (-1);
	}
      break;

      /* sys_ppoll */
    case 309:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  uint32_t nfds;
	  regcache_raw_read (record_regcache, tdep->arg2,
			     (gdb_byte *) & nfds);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_pollfd * nfds))
	    {
	      return (-1);
	    }
	}
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_timespec))
	{
	  return (-1);
	}
      break;

      /* sys_unshare */
    case 310:
      /* sys_set_robust_list */
    case 311:
      break;

      /* sys_get_robust_list */
    case 312:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_int))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_int))
	{
	  return (-1);
	}
      break;

      /* sys_splice */
    case 313:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_loff_t))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg4, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_loff_t))
	{
	  return (-1);
	}
      break;

      /* sys_sync_file_range */
    case 314:
      /* sys_tee */
    case 315:
      /* sys_vmsplice */
    case 316:
      break;

      /* sys_move_pages */
    case 317:
      regcache_raw_read (record_regcache, tdep->arg5, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  uint32_t nr_pages;
	  regcache_raw_read (record_regcache, tdep->arg2,
			     (gdb_byte *) & nr_pages);
	  if (record_arch_list_add_mem (tmpu32, nr_pages * tdep->size_int))
	    {
	      return (-1);
	    }
	}
      break;

      /* sys_getcpu */
    case 318:
      regcache_raw_read (record_regcache, tdep->arg1, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_int))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_int))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, tdep->arg3, (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem (tmpu32, tdep->size_ulong * 2))
	{
	  return (-1);
	}
      break;

      /* sys_epoll_pwait */
    case 319:
      regcache_raw_read (record_regcache, tdep->arg2, (gdb_byte *) & tmpu32);
      if (tmpu32)
	{
	  int32_t maxevents;
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & maxevents);
	  if (record_arch_list_add_mem
	      (tmpu32, maxevents * tdep->size_epoll_event))
	    {
	      return (-1);
	    }
	}
      break;

    default:
      printf_unfiltered (_
			 ("Record: record and reverse function don't support syscall number 0x%08x\n"),
			 tmpu32);
      return (-1);
      break;
    }

  return (0);
}
@


1.1.2.2
log
@	Support more ioctl requests in record target.

	* i386-linux-tdep.c (I386_RECORD_SIZE_termios,
	I386_RECORD_SIZE_termios2, I386_RECORD_SIZE_pid_t,
	I386_RECORD_SIZE_winsize, I386_RECORD_SIZE_char,
	I386_RECORD_SIZE_serial_struct,
	I386_RECORD_SIZE_serial_icounter_struct,
	I386_RECORD_SIZE_hayes_esp_config): New macros. Sizes of some types in
	I386.
	(I386_RECORD_IOCTL_TCGETS,
	I386_RECORD_IOCTL_TCSETS,
	I386_RECORD_IOCTL_TCSETSW,
	I386_RECORD_IOCTL_TCSETSF,
	I386_RECORD_IOCTL_TCGETA,
	I386_RECORD_IOCTL_TCSETA,
	I386_RECORD_IOCTL_TCSETAW,
	I386_RECORD_IOCTL_TCSETAF,
	I386_RECORD_IOCTL_TCSBRK,
	I386_RECORD_IOCTL_TCXONC,
	I386_RECORD_IOCTL_TCFLSH,
	I386_RECORD_IOCTL_TIOCEXCL,
	I386_RECORD_IOCTL_TIOCNXCL,
	I386_RECORD_IOCTL_TIOCSCTTY,
	I386_RECORD_IOCTL_TIOCGPGRP,
	I386_RECORD_IOCTL_TIOCSPGRP,
	I386_RECORD_IOCTL_TIOCOUTQ,
	I386_RECORD_IOCTL_TIOCSTI,
	I386_RECORD_IOCTL_TIOCGWINSZ,
	I386_RECORD_IOCTL_TIOCSWINSZ,
	I386_RECORD_IOCTL_TIOCMGET,
	I386_RECORD_IOCTL_TIOCMBIS,
	I386_RECORD_IOCTL_TIOCMBIC,
	I386_RECORD_IOCTL_TIOCMSET,
	I386_RECORD_IOCTL_TIOCGSOFTCAR,
	I386_RECORD_IOCTL_TIOCSSOFTCAR,
	I386_RECORD_IOCTL_FIONREAD,
	I386_RECORD_IOCTL_TIOCINQ,
	I386_RECORD_IOCTL_TIOCLINUX,
	I386_RECORD_IOCTL_TIOCCONS,
	I386_RECORD_IOCTL_TIOCGSERIAL,
	I386_RECORD_IOCTL_TIOCSSERIAL,
	I386_RECORD_IOCTL_TIOCPKT,
	I386_RECORD_IOCTL_FIONBIO,
	I386_RECORD_IOCTL_TIOCNOTTY,
	I386_RECORD_IOCTL_TIOCSETD,
	I386_RECORD_IOCTL_TIOCGETD,
	I386_RECORD_IOCTL_TCSBRKP,
	I386_RECORD_IOCTL_TIOCTTYGSTRUCT,
	I386_RECORD_IOCTL_TIOCSBRK,
	I386_RECORD_IOCTL_TIOCCBRK,
	I386_RECORD_IOCTL_TIOCGSID,
	I386_RECORD_IOCTL_TCGETS2,
	I386_RECORD_IOCTL_TCSETS2,
	I386_RECORD_IOCTL_TCSETSW2,
	I386_RECORD_IOCTL_TCSETSF2,
	I386_RECORD_IOCTL_TIOCGPTN,
	I386_RECORD_IOCTL_TIOCSPTLCK,
	I386_RECORD_IOCTL_FIONCLEX,
	I386_RECORD_IOCTL_FIOCLEX,
	I386_RECORD_IOCTL_FIOASYNC,
	I386_RECORD_IOCTL_TIOCSERCONFIG,
	I386_RECORD_IOCTL_TIOCSERGWILD,
	I386_RECORD_IOCTL_TIOCSERSWILD,
	I386_RECORD_IOCTL_TIOCGLCKTRMIOS,
	I386_RECORD_IOCTL_TIOCSLCKTRMIOS,
	I386_RECORD_IOCTL_TIOCSERGSTRUCT,
	I386_RECORD_IOCTL_TIOCSERGETLSR,
	I386_RECORD_IOCTL_TIOCSERGETMULTI,
	I386_RECORD_IOCTL_TIOCSERSETMULTI,
	I386_RECORD_IOCTL_TIOCMIWAIT,
	I386_RECORD_IOCTL_TIOCGICOUNT,
	I386_RECORD_IOCTL_TIOCGHAYESESP,
	I386_RECORD_IOCTL_TIOCSHAYESESP,
	I386_RECORD_IOCTL_FIOQSIZE): New macros. Ioctl request numbers in I386.
	(i386_linux_init_abi): Initialize the size of some types and ioctl
	request numbers in linux_record_tdep.
	linux-record.c (record_linux_system_call): Record more ioctl requests.
	linux-record.h (linux_record_tdep_s): Add size of some types and ioctl
	request numbers.

	Add a cleanup in function "record_wait".

	* record.c (record_wait_cleanups): New function. Clean for function
	"record_wait".
	(record_wait): Add a cleanup to call function "record_wait_cleanups".

	i386-tdep.c (i386_record_lea_modrm): If this is not a error, output
	warning message of "can't get the value of the segment register" just
	when record_debug is set.

	record.c (record_message): Change output message from "pause" to
	"stop".

	linux-record.c (record_linux_system_call): Change output message from
	"pause" to "stop".

	linux-record.c (record_linux_system_call): Make query message for
	syscall munmap more clear.

	record.c (_initialize_record): Fix a little bug.
@
text
@d101 1
a101 1
		  ("The next instruction is syscall restart. It will restart the computer. Do you want to stop the program."));
d117 1
a117 1
		  ("The next instruction is syscall exit. It will make the program exit. Do you want to stop the program."));
d285 2
a286 31
      if (tmpu32 == tdep->ioctl_FIOCLEX || tmpu32 == tdep->ioctl_FIONCLEX
	  || tmpu32 == tdep->ioctl_FIONBIO || tmpu32 == tdep->ioctl_FIOASYNC
	  || tmpu32 == tdep->ioctl_TCSETS || tmpu32 == tdep->ioctl_TCSETSW
	  || tmpu32 == tdep->ioctl_TCSETSF || tmpu32 == tdep->ioctl_TCSETA
	  || tmpu32 == tdep->ioctl_TCSETAW || tmpu32 == tdep->ioctl_TCSETAF
	  || tmpu32 == tdep->ioctl_TCSBRK || tmpu32 == tdep->ioctl_TCXONC
	  || tmpu32 == tdep->ioctl_TCFLSH || tmpu32 == tdep->ioctl_TIOCEXCL
	  || tmpu32 == tdep->ioctl_TIOCNXCL
	  || tmpu32 == tdep->ioctl_TIOCSCTTY
	  || tmpu32 == tdep->ioctl_TIOCSPGRP || tmpu32 == tdep->ioctl_TIOCSTI
	  || tmpu32 == tdep->ioctl_TIOCSWINSZ
	  || tmpu32 == tdep->ioctl_TIOCMBIS || tmpu32 == tdep->ioctl_TIOCMBIC
	  || tmpu32 == tdep->ioctl_TIOCMSET
	  || tmpu32 == tdep->ioctl_TIOCSSOFTCAR
	  || tmpu32 == tdep->ioctl_TIOCCONS
	  || tmpu32 == tdep->ioctl_TIOCSSERIAL
	  || tmpu32 == tdep->ioctl_TIOCPKT || tmpu32 == tdep->ioctl_TIOCNOTTY
	  || tmpu32 == tdep->ioctl_TIOCSETD || tmpu32 == tdep->ioctl_TCSBRKP
	  || tmpu32 == tdep->ioctl_TIOCTTYGSTRUCT
	  || tmpu32 == tdep->ioctl_TIOCSBRK || tmpu32 == tdep->ioctl_TIOCCBRK
	  || tmpu32 == tdep->ioctl_TCSETS2 || tmpu32 == tdep->ioctl_TCSETSW2
	  || tmpu32 == tdep->ioctl_TCSETSF2
	  || tmpu32 == tdep->ioctl_TIOCSPTLCK
	  || tmpu32 == tdep->ioctl_TIOCSERCONFIG
	  || tmpu32 == tdep->ioctl_TIOCSERGWILD
	  || tmpu32 == tdep->ioctl_TIOCSERSWILD
	  || tmpu32 == tdep->ioctl_TIOCSLCKTRMIOS
	  || tmpu32 == tdep->ioctl_TIOCSERGETMULTI
	  || tmpu32 == tdep->ioctl_TIOCSERSETMULTI
	  || tmpu32 == tdep->ioctl_TIOCMIWAIT
	  || tmpu32 == tdep->ioctl_TIOCSHAYESESP)
a289 72
      else if (tmpu32 == tdep->ioctl_TCGETS || tmpu32 == tdep->ioctl_TCGETA
	       || tmpu32 == tdep->ioctl_TIOCGLCKTRMIOS)
	{
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_termios))
	    {
	      return (-1);
	    }
	}
      else if (tmpu32 == tdep->ioctl_TIOCGPGRP
	       || tmpu32 == tdep->ioctl_TIOCGSID)
	{
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_pid_t))
	    {
	      return (-1);
	    }
	}
      else if (tmpu32 == tdep->ioctl_TIOCOUTQ
	       || tmpu32 == tdep->ioctl_TIOCMGET
	       || tmpu32 == tdep->ioctl_TIOCGSOFTCAR
	       || tmpu32 == tdep->ioctl_FIONREAD
	       || tmpu32 == tdep->ioctl_TIOCINQ
	       || tmpu32 == tdep->ioctl_TIOCGETD
	       || tmpu32 == tdep->ioctl_TIOCGPTN
	       || tmpu32 == tdep->ioctl_TIOCSERGETLSR)
	{
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_int))
	    {
	      return (-1);
	    }
	}
      else if (tmpu32 == tdep->ioctl_TIOCGWINSZ)
	{
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_winsize))
	    {
	      return (-1);
	    }
	}
      else if (tmpu32 == tdep->ioctl_TIOCLINUX)
	{
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_char))
	    {
	      return (-1);
	    }
	}
      else if (tmpu32 == tdep->ioctl_TIOCGSERIAL)
	{
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_serial_struct))
	    {
	      return (-1);
	    }
	}
      else if (tmpu32 == tdep->ioctl_TCGETS2)
	{
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_termios2))
	    {
	      return (-1);
	    }
	}
a298 25
      else if (tmpu32 == tdep->ioctl_TIOCGICOUNT)
	{
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem
	      (tmpu32, tdep->size_serial_icounter_struct))
	    {
	      return (-1);
	    }
	}
      else if (tmpu32 == tdep->ioctl_TIOCGHAYESESP)
	{
	  regcache_raw_read (record_regcache, tdep->arg3,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem (tmpu32, tdep->size_hayes_esp_config))
	    {
	      return (-1);
	    }
	}
      else if (tmpu32 == tdep->ioctl_TIOCSERGSTRUCT)
	{
	  printf_unfiltered (_
			     ("Record: record and reverse target doesn't support ioctl request TIOCSERGSTRUCT\n"));
	  return (1);
	}
d302 1
a302 1
			     ("Record: record and reverse target doesn't support ioctl request 0x%08x.\n"),
d304 1
a304 1
	  return (1);
d539 1
a539 1
		  ("The next instruction is syscall reboot. It will restart the computer. Do you want to stop the program."));
d573 1
a573 1
		  ("The next instruction is syscall munmap. It will free the memory addr = 0x%s len = %d. It will make record target get error. Do you want to stop the program."),
d1896 1
a1896 1
		  ("The next instruction is syscall exit_group. It will make the program exit. Do you want to stop the program."));
@


1.1.2.3
log
@
	the insn number.
	(record_registers_change): Call function
	"record_check_insn_num" check the insn number. Increase
	"record_insn_num" if need.
	(record_xfer_partial): Call function "record_check_insn_num"
	check the insn number. Increase "record_insn_num" if need.

2008-08-10  Hui Zhu  <teawater@@gmail.com>

	Add the real beneath function pointers for record target.

	* Makefile.in: Add record.h to depend of target.c.
	* record.c (record_beneath_to_resume, record_beneath_to_wait,
	record_beneath_to_prepare_to_store,
	record_beneath_to_xfer_partial,
	record_beneath_to_insert_breakpoint,
	record_beneath_to_remove_breakpoint): New function pointers.
	The real beneath function pointers.
	(record_resume): Change "record_ops.beneath->to_resume" to
	"record_beneath_to_resume".
	(record_wait): Change "record_ops.beneath->to_wait" to
	"record_beneath_to_wait".
	(record_prepare_to_store): Change
	"record_ops.beneath->to_prepare_to_store" to
	"record_beneath_to_prepare_to_store".
	(record_xfer_partial): Change
	"record_ops.beneath->to_xfer_partial" to
	"record_beneath_to_xfer_partial".
	(record_insert_breakpoint): Change
	"record_ops.beneath->to_insert_breakpoint" to
	"record_beneath_to_insert_breakpoint".
	(record_remove_breakpoint): Change
	"record_ops.beneath->to_remove_breakpoint" to
	"record_beneath_to_remove_breakpoint".
	* record.h (record_beneath_to_resume,
	record_beneath_to_wait,
	record_beneath_to_prepare_to_store,
	record_beneath_to_xfer_partial,
	record_beneath_to_insert_breakpoint,
	record_beneath_to_remove_breakpoint): Extern.
	* target.c: Add include of "record.h".
	(update_current_target): Set the real beneath function
	pointers.
@
text
@d96 12
@


1.1.2.4
log
@2008-09-06  Michael Snyder  <msnyder@@vmware.com>

	* record-linux.c: Comment and message string cleanup.
@
text
@d29 1
a29 1
   source.  */
d37 1
a37 1
   source.  */
d58 1
a58 2
   "sys_ipc". The values of these macros are gotten from Linux Kernel source.
 */
d75 1
a75 1
   source.  */
d85 1
a85 1
   Return -1 if something wrong.  */
d105 1
a105 1
		  ("The next instruction is syscall exit.  It will make the program exit.  Do you want to stop the program."));
d271 1
a271 1
      /* XXX there need add a lot of support of other ioctl requests.  */
d305 1
a305 1
	  /* Nothing to do.  */
d653 1
a653 1
		  ("The next instruction is syscall reboot.  It will restart the computer.  Do you want to stop the program."));
d687 1
a687 1
		  ("The next instruction is syscall munmap.  It will free the memory addr = 0x%s len = %d.  It will make record target get error.  Do you want to stop the program."),
d987 1
a987 1
			     ("Record: record and reverse function doesn't support socketcall call 0x%08x\n"),
d2010 1
a2010 1
		  ("The next instruction is syscall exit_group.  It will make the program exit.  Do you want to stop the program."));
d2457 1
a2457 1
			 ("Record: record and reverse function doesn't support syscall number 0x%08x\n"),
@


1.1.2.5
log
@2008-10-03  Michael Snyder  <msnyder@@vmware.com>

	* linux-record.c (record_linux_system_call): Cast sizeof
	in printf calls, avoid compiler warnings on 64 bit hosts.
@
text
@d599 2
a600 2
				    "Record: read memory addr = 0x%s len = %lu error.\n",
				    paddr_nz (tmpu32), (unsigned long) sizeof (sel));
d751 2
a752 2
					"Record: read memory addr = 0x%s len = %lu error.\n",
					paddr_nz (tmpu32), (unsigned long) sizeof (a));
d777 2
a778 2
					"Record: read memory addr = 0x%s len = %lu error.\n",
					paddr_nz (tmpu32), (unsigned long) sizeof (a));
d801 2
a802 2
					"Record: read memory addr = 0x%s len = %lu error.\n",
					paddr_nz (tmpu32), (unsigned long) sizeof (a));
d811 2
a812 2
					    "Record: read memory addr = 0x%s len = %lu error.\n",
					    paddr_nz (a[2]), (unsigned long) sizeof (a[2]));
d833 2
a834 2
					"Record: read memory addr = 0x%s len = %lu error.\n",
					paddr_nz (tmpu32), (unsigned long) sizeof (a));
d843 2
a844 2
					    "Record: read memory addr = 0x%s len = %lu error.\n",
					    paddr_nz (a[2]), (unsigned long) sizeof (a[2]));
d878 2
a879 2
					"Record: read memory addr = 0x%s len = %lu error.\n",
					paddr_nz (tmpu32), (unsigned long) sizeof (a));
d888 2
a889 2
					    "Record: read memory addr = 0x%s len = %lu error.\n",
					    paddr_nz (a[4]), (unsigned long) sizeof (av));
d932 2
a933 2
					"Record: read memory addr = 0x%s len = %lu error.\n",
					paddr_nz (tmpu32), (unsigned long) sizeof (a));
d946 2
a947 2
					    "Record: read memory addr = 0x%s len = %lu error.\n",
					    paddr_nz (a[1]), (unsigned long) sizeof (rec));
d969 1
a969 1
						    "Record: read memory addr = 0x%s len = %lu error.\n",
d971 1
a971 1
						    (unsigned long) sizeof (iov));
d1337 1
a1337 1
					"Record: read memory addr = 0x%s len = %lu error.\n",
d1339 1
a1339 1
					(unsigned long) sizeof (struct record_iovec));
@


1.1.2.6
log
@2008-10-07  Hui Zhu  <teawater@@gmail.com>

	* i386-tdep.c, inflow.c, infrun.c, linux-record.c,
	linux-record.h, record.c, record.h: Change name from
	"record and reverse target" to
	"process record and replay target".
@
text
@d1 1
a1 1
/* Process record and replay target code for GNU/Linux.
@


