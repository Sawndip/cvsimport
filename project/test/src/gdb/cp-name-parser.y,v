head	1.28;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.28
	gdb_7_6-2013-04-26-release:1.28
	gdb_7_6-branch:1.28.0.2
	gdb_7_6-2013-03-12-branchpoint:1.28
	gdb_7_5_1-2012-11-29-release:1.26
	gdb_7_5-2012-08-17-release:1.26
	gdb_7_5-branch:1.26.0.2
	gdb_7_5-2012-07-18-branchpoint:1.26
	gdb_7_4_1-2012-04-26-release:1.22.2.2
	gdb_7_4-2012-01-24-release:1.22.2.2
	gdb_7_4-branch:1.22.0.2
	gdb_7_4-2011-12-13-branchpoint:1.22
	gdb_7_3_1-2011-09-04-release:1.20
	gdb_7_3-2011-07-26-release:1.20
	gdb_7_3-branch:1.20.0.2
	gdb_7_3-2011-04-01-branchpoint:1.20
	gdb_7_2-2010-09-02-release:1.18
	gdb_7_2-branch:1.18.0.2
	gdb_7_2-2010-07-07-branchpoint:1.18
	gdb_7_1-2010-03-18-release:1.17
	gdb_7_1-branch:1.17.0.2
	gdb_7_1-2010-02-18-branchpoint:1.17
	gdb_7_0_1-2009-12-22-release:1.16
	gdb_7_0-2009-10-06-release:1.16
	gdb_7_0-branch:1.16.0.2
	gdb_7_0-2009-09-16-branchpoint:1.16
	arc-sim-20090309:1.8
	msnyder-checkpoint-072509-branch:1.15.0.2
	msnyder-checkpoint-072509-branchpoint:1.15
	arc-insight_6_8-branch:1.8.0.10
	arc-insight_6_8-branchpoint:1.8
	insight_6_8-branch:1.8.0.8
	insight_6_8-branchpoint:1.8
	reverse-20081226-branch:1.11.0.4
	reverse-20081226-branchpoint:1.11
	multiprocess-20081120-branch:1.11.0.2
	multiprocess-20081120-branchpoint:1.11
	reverse-20080930-branch:1.10.0.2
	reverse-20080930-branchpoint:1.10
	reverse-20080717-branch:1.8.0.6
	reverse-20080717-branchpoint:1.8
	msnyder-reverse-20080609-branch:1.8.0.4
	msnyder-reverse-20080609-branchpoint:1.8
	drow-reverse-20070409-branch:1.5.0.4
	drow-reverse-20070409-branchpoint:1.5
	gdb_6_8-2008-03-27-release:1.8
	gdb_6_8-branch:1.8.0.2
	gdb_6_8-2008-02-26-branchpoint:1.8
	gdb_6_7_1-2007-10-29-release:1.5
	gdb_6_7-2007-10-10-release:1.5
	gdb_6_7-branch:1.5.0.2
	gdb_6_7-2007-09-07-branchpoint:1.5
	insight_6_6-20070208-release:1.4
	gdb_6_6-2006-12-18-release:1.4
	gdb_6_6-branch:1.4.0.18
	gdb_6_6-2006-11-15-branchpoint:1.4
	insight_6_5-20061003-release:1.4
	gdb-csl-symbian-6_4_50_20060226-12:1.4
	gdb-csl-sourcerygxx-3_4_4-25:1.3
	nickrob-async-20060828-mergepoint:1.4
	gdb-csl-symbian-6_4_50_20060226-11:1.4
	gdb-csl-sourcerygxx-4_1-17:1.4
	gdb-csl-20060226-branch-local-2:1.4
	gdb-csl-sourcerygxx-4_1-14:1.4
	gdb-csl-sourcerygxx-4_1-13:1.4
	gdb-csl-sourcerygxx-4_1-12:1.4
	gdb-csl-sourcerygxx-3_4_4-21:1.4
	gdb_6_5-20060621-release:1.4
	gdb-csl-sourcerygxx-4_1-9:1.4
	gdb-csl-sourcerygxx-4_1-8:1.4
	gdb-csl-sourcerygxx-4_1-7:1.4
	gdb-csl-arm-2006q1-6:1.4
	gdb-csl-sourcerygxx-4_1-6:1.4
	gdb-csl-symbian-6_4_50_20060226-10:1.4
	gdb-csl-symbian-6_4_50_20060226-9:1.4
	gdb-csl-symbian-6_4_50_20060226-8:1.4
	gdb-csl-coldfire-4_1-11:1.4
	gdb-csl-sourcerygxx-3_4_4-19:1.4
	gdb-csl-coldfire-4_1-10:1.4
	gdb_6_5-branch:1.4.0.16
	gdb_6_5-2006-05-14-branchpoint:1.4
	gdb-csl-sourcerygxx-4_1-5:1.4
	nickrob-async-20060513-branch:1.4.0.14
	nickrob-async-20060513-branchpoint:1.4
	gdb-csl-sourcerygxx-4_1-4:1.4
	msnyder-reverse-20060502-branch:1.4.0.12
	msnyder-reverse-20060502-branchpoint:1.4
	gdb-csl-morpho-4_1-4:1.4
	gdb-csl-sourcerygxx-3_4_4-17:1.4
	readline_5_1-import-branch:1.4.0.10
	readline_5_1-import-branchpoint:1.4
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.4
	gdb-csl-symbian-20060226-branch:1.4.0.8
	gdb-csl-symbian-20060226-branchpoint:1.4
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.4
	msnyder-reverse-20060331-branch:1.4.0.6
	msnyder-reverse-20060331-branchpoint:1.4
	gdb-csl-available-20060303-branch:1.4.0.4
	gdb-csl-available-20060303-branchpoint:1.4
	gdb-csl-20060226-branch:1.4.0.2
	gdb-csl-20060226-branchpoint:1.4
	gdb_6_4-20051202-release:1.3
	msnyder-fork-checkpoint-branch:1.3.0.10
	msnyder-fork-checkpoint-branchpoint:1.3
	gdb-csl-gxxpro-6_3-branch:1.3.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.3
	gdb_6_4-branch:1.3.0.6
	gdb_6_4-2005-11-01-branchpoint:1.3
	gdb-csl-arm-20051020-branch:1.3.0.4
	gdb-csl-arm-20051020-branchpoint:1.3
	msnyder-tracepoint-checkpoint-branch:1.3.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.3;
locks; strict;
comment	@ * @;


1.28
date	2013.01.01.06.32.40;	author brobecke;	state Exp;
branches;
next	1.27;

1.27
date	2012.09.21.20.01.11;	author jkratoch;	state Exp;
branches;
next	1.26;

1.26
date	2012.04.09.17.07.43;	author kettenis;	state Exp;
branches;
next	1.25;

1.25
date	2012.01.10.19.29.12;	author jkratoch;	state Exp;
branches;
next	1.24;

1.24
date	2012.01.04.08.17.00;	author brobecke;	state Exp;
branches;
next	1.23;

1.23
date	2011.12.17.20.10.57;	author schwab;	state Exp;
branches;
next	1.22;

1.22
date	2011.08.18.16.17.37;	author kseitz;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	2011.08.06.14.13.49;	author jkratoch;	state Exp;
branches;
next	1.20;

1.20
date	2011.03.18.13.51.41;	author muller;	state Exp;
branches;
next	1.19;

1.19
date	2011.01.01.15.32.59;	author brobecke;	state Exp;
branches;
next	1.18;

1.18
date	2010.05.06.00.08.44;	author msnyder;	state Exp;
branches;
next	1.17;

1.17
date	2010.01.01.07.31.30;	author brobecke;	state Exp;
branches;
next	1.16;

1.16
date	2009.07.29.18.44.28;	author jkratoch;	state Exp;
branches;
next	1.15;

1.15
date	2009.03.31.20.21.06;	author tromey;	state Exp;
branches;
next	1.14;

1.14
date	2009.03.18.08.51.11;	author nathan;	state Exp;
branches;
next	1.13;

1.13
date	2009.02.21.16.14.47;	author palves;	state Exp;
branches;
next	1.12;

1.12
date	2009.01.03.05.57.51;	author brobecke;	state Exp;
branches;
next	1.11;

1.11
date	2008.10.27.19.28.52;	author palves;	state Exp;
branches;
next	1.10;

1.10
date	2008.08.25.21.50.25;	author palves;	state Exp;
branches;
next	1.9;

1.9
date	2008.08.10.18.41.33;	author palves;	state Exp;
branches;
next	1.8;

1.8
date	2008.01.01.22.53.09;	author drow;	state Exp;
branches;
next	1.7;

1.7
date	2007.10.22.16.07.13;	author drow;	state Exp;
branches;
next	1.6;

1.6
date	2007.10.22.14.37.36;	author drow;	state Exp;
branches;
next	1.5;

1.5
date	2007.01.09.17.58.50;	author drow;	state Exp;
branches;
next	1.4;

1.4
date	2005.12.17.22.33.59;	author eliz;	state Exp;
branches;
next	1.3;

1.3
date	2005.05.28.16.48.58;	author drow;	state Exp;
branches;
next	1.2;

1.2
date	2005.05.28.08.49.13;	author hp;	state Exp;
branches;
next	1.1;

1.1
date	2005.05.12.16.01.08;	author drow;	state Exp;
branches;
next	;

1.22.2.1
date	2011.12.22.11.19.13;	author schwab;	state Exp;
branches;
next	1.22.2.2;

1.22.2.2
date	2012.01.06.04.43.06;	author brobecke;	state Exp;
branches;
next	;


desc
@@


1.28
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@/* YACC parser for C++ names, for GDB.

   Copyright (C) 2003-2013 Free Software Foundation, Inc.

   Parts of the lexer are based on c-exp.y from GDB.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/* Note that malloc's and realloc's in this file are transformed to
   xmalloc and xrealloc respectively by the same sed command in the
   makefile that remaps any other malloc/realloc inserted by the parser
   generator.  Doing this with #defines and trying to control the interaction
   with include files (<malloc.h> and <stdlib.h> for example) just became
   too messy, particularly when such includes can be inserted at random
   times by the parser generator.  */

%{

#include "defs.h"

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

#include "safe-ctype.h"
#include "libiberty.h"
#include "demangle.h"
#include "cp-support.h"
#include "gdb_assert.h"

/* Bison does not make it easy to create a parser without global
   state, unfortunately.  Here are all the global variables used
   in this parser.  */

/* LEXPTR is the current pointer into our lex buffer.  PREV_LEXPTR
   is the start of the last token lexed, only used for diagnostics.
   ERROR_LEXPTR is the first place an error occurred.  GLOBAL_ERRMSG
   is the first error message encountered.  */

static const char *lexptr, *prev_lexptr, *error_lexptr, *global_errmsg;

/* The components built by the parser are allocated ahead of time,
   and cached in this structure.  */

#define ALLOC_CHUNK 100

struct demangle_info {
  int used;
  struct demangle_info *next;
  struct demangle_component comps[ALLOC_CHUNK];
};

static struct demangle_info *demangle_info;

static struct demangle_component *
d_grab (void)
{
  struct demangle_info *more;

  if (demangle_info->used >= ALLOC_CHUNK)
    {
      if (demangle_info->next == NULL)
	{
	  more = malloc (sizeof (struct demangle_info));
	  more->next = NULL;
	  demangle_info->next = more;
	}
      else
	more = demangle_info->next;

      more->used = 0;
      demangle_info = more;
    }
  return &demangle_info->comps[demangle_info->used++];
}

/* The parse tree created by the parser is stored here after a successful
   parse.  */

static struct demangle_component *global_result;

/* Prototypes for helper functions used when constructing the parse
   tree.  */

static struct demangle_component *d_qualify (struct demangle_component *, int,
					     int);

static struct demangle_component *d_int_type (int);

static struct demangle_component *d_unary (const char *,
					   struct demangle_component *);
static struct demangle_component *d_binary (const char *,
					    struct demangle_component *,
					    struct demangle_component *);

/* Flags passed to d_qualify.  */

#define QUAL_CONST 1
#define QUAL_RESTRICT 2
#define QUAL_VOLATILE 4

/* Flags passed to d_int_type.  */

#define INT_CHAR	(1 << 0)
#define INT_SHORT	(1 << 1)
#define INT_LONG	(1 << 2)
#define INT_LLONG	(1 << 3)

#define INT_SIGNED	(1 << 4)
#define INT_UNSIGNED	(1 << 5)

/* Remap normal yacc parser interface names (yyparse, yylex, yyerror, etc),
   as well as gratuitiously global symbol names, so we can have multiple
   yacc generated parsers in gdb.  Note that these are only the variables
   produced by yacc.  If other parser generators (bison, byacc, etc) produce
   additional global names that conflict at link time, then those parser
   generators need to be fixed instead of adding those names to this list. */

#define	yymaxdepth cpname_maxdepth
#define	yyparse	cpname_parse
#define	yylex	cpname_lex
#define	yyerror	cpname_error
#define	yylval	cpname_lval
#define	yychar	cpname_char
#define	yydebug	cpname_debug
#define	yypact	cpname_pact	
#define	yyr1	cpname_r1			
#define	yyr2	cpname_r2			
#define	yydef	cpname_def		
#define	yychk	cpname_chk		
#define	yypgo	cpname_pgo		
#define	yyact	cpname_act		
#define	yyexca	cpname_exca
#define yyerrflag cpname_errflag
#define yynerrs	cpname_nerrs
#define	yyps	cpname_ps
#define	yypv	cpname_pv
#define	yys	cpname_s
#define	yy_yys	cpname_yys
#define	yystate	cpname_state
#define	yytmp	cpname_tmp
#define	yyv	cpname_v
#define	yy_yyv	cpname_yyv
#define	yyval	cpname_val
#define	yylloc	cpname_lloc
#define yyreds	cpname_reds		/* With YYDEBUG defined */
#define yytoks	cpname_toks		/* With YYDEBUG defined */
#define yyname	cpname_name		/* With YYDEBUG defined */
#define yyrule	cpname_rule		/* With YYDEBUG defined */
#define yylhs	cpname_yylhs
#define yylen	cpname_yylen
#define yydefred cpname_yydefred
#define yydgoto	cpname_yydgoto
#define yysindex cpname_yysindex
#define yyrindex cpname_yyrindex
#define yygindex cpname_yygindex
#define yytable	 cpname_yytable
#define yycheck	 cpname_yycheck
#define yyss	cpname_yyss
#define yysslim	cpname_yysslim
#define yyssp	cpname_yyssp
#define yystacksize cpname_yystacksize
#define yyvs	cpname_yyvs
#define yyvsp	cpname_yyvsp

int yyparse (void);
static int yylex (void);
static void yyerror (char *);

/* Enable yydebug for the stand-alone parser.  */
#ifdef TEST_CPNAMES
# define YYDEBUG	1
#endif

/* Helper functions.  These wrap the demangler tree interface, handle
   allocation from our global store, and return the allocated component.  */

static struct demangle_component *
fill_comp (enum demangle_component_type d_type, struct demangle_component *lhs,
	   struct demangle_component *rhs)
{
  struct demangle_component *ret = d_grab ();
  int i;

  i = cplus_demangle_fill_component (ret, d_type, lhs, rhs);
  gdb_assert (i);

  return ret;
}

static struct demangle_component *
make_empty (enum demangle_component_type d_type)
{
  struct demangle_component *ret = d_grab ();
  ret->type = d_type;
  return ret;
}

static struct demangle_component *
make_operator (const char *name, int args)
{
  struct demangle_component *ret = d_grab ();
  int i;

  i = cplus_demangle_fill_operator (ret, name, args);
  gdb_assert (i);

  return ret;
}

static struct demangle_component *
make_dtor (enum gnu_v3_dtor_kinds kind, struct demangle_component *name)
{
  struct demangle_component *ret = d_grab ();
  int i;

  i = cplus_demangle_fill_dtor (ret, kind, name);
  gdb_assert (i);

  return ret;
}

static struct demangle_component *
make_builtin_type (const char *name)
{
  struct demangle_component *ret = d_grab ();
  int i;

  i = cplus_demangle_fill_builtin_type (ret, name);
  gdb_assert (i);

  return ret;
}

static struct demangle_component *
make_name (const char *name, int len)
{
  struct demangle_component *ret = d_grab ();
  int i;

  i = cplus_demangle_fill_name (ret, name, len);
  gdb_assert (i);

  return ret;
}

#define d_left(dc) (dc)->u.s_binary.left
#define d_right(dc) (dc)->u.s_binary.right

%}

%union
  {
    struct demangle_component *comp;
    struct nested {
      struct demangle_component *comp;
      struct demangle_component **last;
    } nested;
    struct {
      struct demangle_component *comp, *last;
    } nested1;
    struct {
      struct demangle_component *comp, **last;
      struct nested fn;
      struct demangle_component *start;
      int fold_flag;
    } abstract;
    int lval;
    const char *opname;
  }

%type <comp> exp exp1 type start start_opt operator colon_name
%type <comp> unqualified_name colon_ext_name
%type <comp> template template_arg
%type <comp> builtin_type
%type <comp> typespec_2 array_indicator
%type <comp> colon_ext_only ext_only_name

%type <comp> demangler_special function conversion_op
%type <nested> conversion_op_name

%type <abstract> abstract_declarator direct_abstract_declarator
%type <abstract> abstract_declarator_fn
%type <nested> declarator direct_declarator function_arglist

%type <nested> declarator_1 direct_declarator_1

%type <nested> template_params function_args
%type <nested> ptr_operator

%type <nested1> nested_name

%type <lval> qualifier qualifiers qualifiers_opt

%type <lval> int_part int_seq

%token <comp> INT
%token <comp> FLOAT

%token <comp> NAME
%type <comp> name

%token STRUCT CLASS UNION ENUM SIZEOF UNSIGNED COLONCOLON
%token TEMPLATE
%token ERROR
%token NEW DELETE OPERATOR
%token STATIC_CAST REINTERPRET_CAST DYNAMIC_CAST

/* Special type cases, put in to allow the parser to distinguish different
   legal basetypes.  */
%token SIGNED_KEYWORD LONG SHORT INT_KEYWORD CONST_KEYWORD VOLATILE_KEYWORD DOUBLE_KEYWORD BOOL
%token ELLIPSIS RESTRICT VOID FLOAT_KEYWORD CHAR WCHAR_T

%token <opname> ASSIGN_MODIFY

/* C++ */
%token TRUEKEYWORD
%token FALSEKEYWORD

/* Non-C++ things we get from the demangler.  */
%token <lval> DEMANGLER_SPECIAL
%token CONSTRUCTION_VTABLE CONSTRUCTION_IN

/* Precedence declarations.  */

/* Give NAME lower precedence than COLONCOLON, so that nested_name will
   associate greedily.  */
%nonassoc NAME

/* Give NEW and DELETE lower precedence than ']', because we can not
   have an array of type operator new.  This causes NEW '[' to be
   parsed as operator new[].  */
%nonassoc NEW DELETE

/* Give VOID higher precedence than NAME.  Then we can use %prec NAME
   to prefer (VOID) to (function_args).  */
%nonassoc VOID

/* Give VOID lower precedence than ')' for similar reasons.  */
%nonassoc ')'

%left ','
%right '=' ASSIGN_MODIFY
%right '?'
%left OROR
%left ANDAND
%left '|'
%left '^'
%left '&'
%left EQUAL NOTEQUAL
%left '<' '>' LEQ GEQ
%left LSH RSH
%left '@@'
%left '+' '-'
%left '*' '/' '%'
%right UNARY INCREMENT DECREMENT

/* We don't need a precedence for '(' in this reduced grammar, and it
   can mask some unpleasant bugs, so disable it for now.  */

%right ARROW '.' '[' /* '(' */
%left COLONCOLON


%%

result		:	start
			{ global_result = $1; }
		;

start		:	type

		|	demangler_special

		|	function

		;

start_opt	:	/* */
			{ $$ = NULL; }
		|	COLONCOLON start
			{ $$ = $2; }
		;

function
		/* Function with a return type.  declarator_1 is used to prevent
		   ambiguity with the next rule.  */
		:	typespec_2 declarator_1
			{ $$ = $2.comp;
			  *$2.last = $1;
			}

		/* Function without a return type.  We need to use typespec_2
		   to prevent conflicts from qualifiers_opt - harmless.  The
		   start_opt is used to handle "function-local" variables and
		   types.  */
		|	typespec_2 function_arglist start_opt
			{ $$ = fill_comp (DEMANGLE_COMPONENT_TYPED_NAME, $1, $2.comp);
			  if ($3) $$ = fill_comp (DEMANGLE_COMPONENT_LOCAL_NAME, $$, $3); }
		|	colon_ext_only function_arglist start_opt
			{ $$ = fill_comp (DEMANGLE_COMPONENT_TYPED_NAME, $1, $2.comp);
			  if ($3) $$ = fill_comp (DEMANGLE_COMPONENT_LOCAL_NAME, $$, $3); }

		|	conversion_op_name start_opt
			{ $$ = $1.comp;
			  if ($2) $$ = fill_comp (DEMANGLE_COMPONENT_LOCAL_NAME, $$, $2); }
		|	conversion_op_name abstract_declarator_fn
			{ if ($2.last)
			    {
			       /* First complete the abstract_declarator's type using
				  the typespec from the conversion_op_name.  */
			      *$2.last = *$1.last;
			      /* Then complete the conversion_op_name with the type.  */
			      *$1.last = $2.comp;
			    }
			  /* If we have an arglist, build a function type.  */
			  if ($2.fn.comp)
			    $$ = fill_comp (DEMANGLE_COMPONENT_TYPED_NAME, $1.comp, $2.fn.comp);
			  else
			    $$ = $1.comp;
			  if ($2.start) $$ = fill_comp (DEMANGLE_COMPONENT_LOCAL_NAME, $$, $2.start);
			}
		;

demangler_special
		:	DEMANGLER_SPECIAL start
			{ $$ = make_empty ($1);
			  d_left ($$) = $2;
			  d_right ($$) = NULL; }
		|	CONSTRUCTION_VTABLE start CONSTRUCTION_IN start
			{ $$ = fill_comp (DEMANGLE_COMPONENT_CONSTRUCTION_VTABLE, $2, $4); }
		;

operator	:	OPERATOR NEW
			{
			  /* Match the whitespacing of cplus_demangle_operators.
			     It would abort on unrecognized string otherwise.  */
			  $$ = make_operator ("new", 3);
			}
		|	OPERATOR DELETE
			{
			  /* Match the whitespacing of cplus_demangle_operators.
			     It would abort on unrecognized string otherwise.  */
			  $$ = make_operator ("delete ", 1);
			}
		|	OPERATOR NEW '[' ']'
			{
			  /* Match the whitespacing of cplus_demangle_operators.
			     It would abort on unrecognized string otherwise.  */
			  $$ = make_operator ("new[]", 3);
			}
		|	OPERATOR DELETE '[' ']'
			{
			  /* Match the whitespacing of cplus_demangle_operators.
			     It would abort on unrecognized string otherwise.  */
			  $$ = make_operator ("delete[] ", 1);
			}
		|	OPERATOR '+'
			{ $$ = make_operator ("+", 2); }
		|	OPERATOR '-'
			{ $$ = make_operator ("-", 2); }
		|	OPERATOR '*'
			{ $$ = make_operator ("*", 2); }
		|	OPERATOR '/'
			{ $$ = make_operator ("/", 2); }
		|	OPERATOR '%'
			{ $$ = make_operator ("%", 2); }
		|	OPERATOR '^'
			{ $$ = make_operator ("^", 2); }
		|	OPERATOR '&'
			{ $$ = make_operator ("&", 2); }
		|	OPERATOR '|'
			{ $$ = make_operator ("|", 2); }
		|	OPERATOR '~'
			{ $$ = make_operator ("~", 1); }
		|	OPERATOR '!'
			{ $$ = make_operator ("!", 1); }
		|	OPERATOR '='
			{ $$ = make_operator ("=", 2); }
		|	OPERATOR '<'
			{ $$ = make_operator ("<", 2); }
		|	OPERATOR '>'
			{ $$ = make_operator (">", 2); }
		|	OPERATOR ASSIGN_MODIFY
			{ $$ = make_operator ($2, 2); }
		|	OPERATOR LSH
			{ $$ = make_operator ("<<", 2); }
		|	OPERATOR RSH
			{ $$ = make_operator (">>", 2); }
		|	OPERATOR EQUAL
			{ $$ = make_operator ("==", 2); }
		|	OPERATOR NOTEQUAL
			{ $$ = make_operator ("!=", 2); }
		|	OPERATOR LEQ
			{ $$ = make_operator ("<=", 2); }
		|	OPERATOR GEQ
			{ $$ = make_operator (">=", 2); }
		|	OPERATOR ANDAND
			{ $$ = make_operator ("&&", 2); }
		|	OPERATOR OROR
			{ $$ = make_operator ("||", 2); }
		|	OPERATOR INCREMENT
			{ $$ = make_operator ("++", 1); }
		|	OPERATOR DECREMENT
			{ $$ = make_operator ("--", 1); }
		|	OPERATOR ','
			{ $$ = make_operator (",", 2); }
		|	OPERATOR ARROW '*'
			{ $$ = make_operator ("->*", 2); }
		|	OPERATOR ARROW
			{ $$ = make_operator ("->", 2); }
		|	OPERATOR '(' ')'
			{ $$ = make_operator ("()", 2); }
		|	OPERATOR '[' ']'
			{ $$ = make_operator ("[]", 2); }
		;

		/* Conversion operators.  We don't try to handle some of
		   the wackier demangler output for function pointers,
		   since it's not clear that it's parseable.  */
conversion_op
		:	OPERATOR typespec_2
			{ $$ = fill_comp (DEMANGLE_COMPONENT_CAST, $2, NULL); }
		;

conversion_op_name
		:	nested_name conversion_op
			{ $$.comp = $1.comp;
			  d_right ($1.last) = $2;
			  $$.last = &d_left ($2);
			}
		|	conversion_op
			{ $$.comp = $1;
			  $$.last = &d_left ($1);
			}
		|	COLONCOLON nested_name conversion_op
			{ $$.comp = $2.comp;
			  d_right ($2.last) = $3;
			  $$.last = &d_left ($3);
			}
		|	COLONCOLON conversion_op
			{ $$.comp = $2;
			  $$.last = &d_left ($2);
			}
		;

/* DEMANGLE_COMPONENT_NAME */
/* This accepts certain invalid placements of '~'.  */
unqualified_name:	operator
		|	operator '<' template_params '>'
			{ $$ = fill_comp (DEMANGLE_COMPONENT_TEMPLATE, $1, $3.comp); }
		|	'~' NAME
			{ $$ = make_dtor (gnu_v3_complete_object_dtor, $2); }
		;

/* This rule is used in name and nested_name, and expanded inline there
   for efficiency.  */
/*
scope_id	:	NAME
		|	template
		;
*/

colon_name	:	name
		|	COLONCOLON name
			{ $$ = $2; }
		;

/* DEMANGLE_COMPONENT_QUAL_NAME */
/* DEMANGLE_COMPONENT_CTOR / DEMANGLE_COMPONENT_DTOR ? */
name		:	nested_name NAME %prec NAME
			{ $$ = $1.comp; d_right ($1.last) = $2; }
		|	NAME %prec NAME
		|	nested_name template %prec NAME
			{ $$ = $1.comp; d_right ($1.last) = $2; }
		|	template %prec NAME
		;

colon_ext_name	:	colon_name
		|	colon_ext_only
		;

colon_ext_only	:	ext_only_name
		|	COLONCOLON ext_only_name
			{ $$ = $2; }
		;

ext_only_name	:	nested_name unqualified_name
			{ $$ = $1.comp; d_right ($1.last) = $2; }
		|	unqualified_name
		;

nested_name	:	NAME COLONCOLON
			{ $$.comp = make_empty (DEMANGLE_COMPONENT_QUAL_NAME);
			  d_left ($$.comp) = $1;
			  d_right ($$.comp) = NULL;
			  $$.last = $$.comp;
			}
		|	nested_name NAME COLONCOLON
			{ $$.comp = $1.comp;
			  d_right ($1.last) = make_empty (DEMANGLE_COMPONENT_QUAL_NAME);
			  $$.last = d_right ($1.last);
			  d_left ($$.last) = $2;
			  d_right ($$.last) = NULL;
			}
		|	template COLONCOLON
			{ $$.comp = make_empty (DEMANGLE_COMPONENT_QUAL_NAME);
			  d_left ($$.comp) = $1;
			  d_right ($$.comp) = NULL;
			  $$.last = $$.comp;
			}
		|	nested_name template COLONCOLON
			{ $$.comp = $1.comp;
			  d_right ($1.last) = make_empty (DEMANGLE_COMPONENT_QUAL_NAME);
			  $$.last = d_right ($1.last);
			  d_left ($$.last) = $2;
			  d_right ($$.last) = NULL;
			}
		;

/* DEMANGLE_COMPONENT_TEMPLATE */
/* DEMANGLE_COMPONENT_TEMPLATE_ARGLIST */
template	:	NAME '<' template_params '>'
			{ $$ = fill_comp (DEMANGLE_COMPONENT_TEMPLATE, $1, $3.comp); }
		;

template_params	:	template_arg
			{ $$.comp = fill_comp (DEMANGLE_COMPONENT_TEMPLATE_ARGLIST, $1, NULL);
			$$.last = &d_right ($$.comp); }
		|	template_params ',' template_arg
			{ $$.comp = $1.comp;
			  *$1.last = fill_comp (DEMANGLE_COMPONENT_TEMPLATE_ARGLIST, $3, NULL);
			  $$.last = &d_right (*$1.last);
			}
		;

/* "type" is inlined into template_arg and function_args.  */

/* Also an integral constant-expression of integral type, and a
   pointer to member (?) */
template_arg	:	typespec_2
		|	typespec_2 abstract_declarator
			{ $$ = $2.comp;
			  *$2.last = $1;
			}
		|	'&' start
			{ $$ = fill_comp (DEMANGLE_COMPONENT_UNARY, make_operator ("&", 1), $2); }
		|	'&' '(' start ')'
			{ $$ = fill_comp (DEMANGLE_COMPONENT_UNARY, make_operator ("&", 1), $3); }
		|	exp
		;

function_args	:	typespec_2
			{ $$.comp = fill_comp (DEMANGLE_COMPONENT_ARGLIST, $1, NULL);
			  $$.last = &d_right ($$.comp);
			}
		|	typespec_2 abstract_declarator
			{ *$2.last = $1;
			  $$.comp = fill_comp (DEMANGLE_COMPONENT_ARGLIST, $2.comp, NULL);
			  $$.last = &d_right ($$.comp);
			}
		|	function_args ',' typespec_2
			{ *$1.last = fill_comp (DEMANGLE_COMPONENT_ARGLIST, $3, NULL);
			  $$.comp = $1.comp;
			  $$.last = &d_right (*$1.last);
			}
		|	function_args ',' typespec_2 abstract_declarator
			{ *$4.last = $3;
			  *$1.last = fill_comp (DEMANGLE_COMPONENT_ARGLIST, $4.comp, NULL);
			  $$.comp = $1.comp;
			  $$.last = &d_right (*$1.last);
			}
		|	function_args ',' ELLIPSIS
			{ *$1.last
			    = fill_comp (DEMANGLE_COMPONENT_ARGLIST,
					   make_builtin_type ("..."),
					   NULL);
			  $$.comp = $1.comp;
			  $$.last = &d_right (*$1.last);
			}
		;

function_arglist:	'(' function_args ')' qualifiers_opt %prec NAME
			{ $$.comp = fill_comp (DEMANGLE_COMPONENT_FUNCTION_TYPE, NULL, $2.comp);
			  $$.last = &d_left ($$.comp);
			  $$.comp = d_qualify ($$.comp, $4, 1); }
		|	'(' VOID ')' qualifiers_opt
			{ $$.comp = fill_comp (DEMANGLE_COMPONENT_FUNCTION_TYPE, NULL, NULL);
			  $$.last = &d_left ($$.comp);
			  $$.comp = d_qualify ($$.comp, $4, 1); }
		|	'(' ')' qualifiers_opt
			{ $$.comp = fill_comp (DEMANGLE_COMPONENT_FUNCTION_TYPE, NULL, NULL);
			  $$.last = &d_left ($$.comp);
			  $$.comp = d_qualify ($$.comp, $3, 1); }
		;

/* Should do something about DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL */
qualifiers_opt	:	/* epsilon */
			{ $$ = 0; }
		|	qualifiers
		;

qualifier	:	RESTRICT
			{ $$ = QUAL_RESTRICT; }
		|	VOLATILE_KEYWORD
			{ $$ = QUAL_VOLATILE; }
		|	CONST_KEYWORD
			{ $$ = QUAL_CONST; }
		;

qualifiers	:	qualifier
		|	qualifier qualifiers
			{ $$ = $1 | $2; }
		;

/* This accepts all sorts of invalid constructions and produces
   invalid output for them - an error would be better.  */

int_part	:	INT_KEYWORD
			{ $$ = 0; }
		|	SIGNED_KEYWORD
			{ $$ = INT_SIGNED; }
		|	UNSIGNED
			{ $$ = INT_UNSIGNED; }
		|	CHAR
			{ $$ = INT_CHAR; }
		|	LONG
			{ $$ = INT_LONG; }
		|	SHORT
			{ $$ = INT_SHORT; }
		;

int_seq		:	int_part
		|	int_seq int_part
			{ $$ = $1 | $2; if ($1 & $2 & INT_LONG) $$ = $1 | INT_LLONG; }
		;

builtin_type	:	int_seq
			{ $$ = d_int_type ($1); }
		|	FLOAT_KEYWORD
			{ $$ = make_builtin_type ("float"); }
		|	DOUBLE_KEYWORD
			{ $$ = make_builtin_type ("double"); }
		|	LONG DOUBLE_KEYWORD
			{ $$ = make_builtin_type ("long double"); }
		|	BOOL
			{ $$ = make_builtin_type ("bool"); }
		|	WCHAR_T
			{ $$ = make_builtin_type ("wchar_t"); }
		|	VOID
			{ $$ = make_builtin_type ("void"); }
		;

ptr_operator	:	'*' qualifiers_opt
			{ $$.comp = make_empty (DEMANGLE_COMPONENT_POINTER);
			  $$.comp->u.s_binary.left = $$.comp->u.s_binary.right = NULL;
			  $$.last = &d_left ($$.comp);
			  $$.comp = d_qualify ($$.comp, $2, 0); }
		/* g++ seems to allow qualifiers after the reference?  */
		|	'&'
			{ $$.comp = make_empty (DEMANGLE_COMPONENT_REFERENCE);
			  $$.comp->u.s_binary.left = $$.comp->u.s_binary.right = NULL;
			  $$.last = &d_left ($$.comp); }
		|	nested_name '*' qualifiers_opt
			{ $$.comp = make_empty (DEMANGLE_COMPONENT_PTRMEM_TYPE);
			  $$.comp->u.s_binary.left = $1.comp;
			  /* Convert the innermost DEMANGLE_COMPONENT_QUAL_NAME to a DEMANGLE_COMPONENT_NAME.  */
			  *$1.last = *d_left ($1.last);
			  $$.comp->u.s_binary.right = NULL;
			  $$.last = &d_right ($$.comp);
			  $$.comp = d_qualify ($$.comp, $3, 0); }
		|	COLONCOLON nested_name '*' qualifiers_opt
			{ $$.comp = make_empty (DEMANGLE_COMPONENT_PTRMEM_TYPE);
			  $$.comp->u.s_binary.left = $2.comp;
			  /* Convert the innermost DEMANGLE_COMPONENT_QUAL_NAME to a DEMANGLE_COMPONENT_NAME.  */
			  *$2.last = *d_left ($2.last);
			  $$.comp->u.s_binary.right = NULL;
			  $$.last = &d_right ($$.comp);
			  $$.comp = d_qualify ($$.comp, $4, 0); }
		;

array_indicator	:	'[' ']'
			{ $$ = make_empty (DEMANGLE_COMPONENT_ARRAY_TYPE);
			  d_left ($$) = NULL;
			}
		|	'[' INT ']'
			{ $$ = make_empty (DEMANGLE_COMPONENT_ARRAY_TYPE);
			  d_left ($$) = $2;
			}
		;

/* Details of this approach inspired by the G++ < 3.4 parser.  */

/* This rule is only used in typespec_2, and expanded inline there for
   efficiency.  */
/*
typespec	:	builtin_type
		|	colon_name
		;
*/

typespec_2	:	builtin_type qualifiers
			{ $$ = d_qualify ($1, $2, 0); }
		|	builtin_type
		|	qualifiers builtin_type qualifiers
			{ $$ = d_qualify ($2, $1 | $3, 0); }
		|	qualifiers builtin_type
			{ $$ = d_qualify ($2, $1, 0); }

		|	name qualifiers
			{ $$ = d_qualify ($1, $2, 0); }
		|	name
		|	qualifiers name qualifiers
			{ $$ = d_qualify ($2, $1 | $3, 0); }
		|	qualifiers name
			{ $$ = d_qualify ($2, $1, 0); }

		|	COLONCOLON name qualifiers
			{ $$ = d_qualify ($2, $3, 0); }
		|	COLONCOLON name
			{ $$ = $2; }
		|	qualifiers COLONCOLON name qualifiers
			{ $$ = d_qualify ($3, $1 | $4, 0); }
		|	qualifiers COLONCOLON name
			{ $$ = d_qualify ($3, $1, 0); }
		;

abstract_declarator
		:	ptr_operator
			{ $$.comp = $1.comp; $$.last = $1.last;
			  $$.fn.comp = NULL; $$.fn.last = NULL; }
		|	ptr_operator abstract_declarator
			{ $$ = $2; $$.fn.comp = NULL; $$.fn.last = NULL;
			  if ($2.fn.comp) { $$.last = $2.fn.last; *$2.last = $2.fn.comp; }
			  *$$.last = $1.comp;
			  $$.last = $1.last; }
		|	direct_abstract_declarator
			{ $$.fn.comp = NULL; $$.fn.last = NULL;
			  if ($1.fn.comp) { $$.last = $1.fn.last; *$1.last = $1.fn.comp; }
			}
		;

direct_abstract_declarator
		:	'(' abstract_declarator ')'
			{ $$ = $2; $$.fn.comp = NULL; $$.fn.last = NULL; $$.fold_flag = 1;
			  if ($2.fn.comp) { $$.last = $2.fn.last; *$2.last = $2.fn.comp; }
			}
		|	direct_abstract_declarator function_arglist
			{ $$.fold_flag = 0;
			  if ($1.fn.comp) { $$.last = $1.fn.last; *$1.last = $1.fn.comp; }
			  if ($1.fold_flag)
			    {
			      *$$.last = $2.comp;
			      $$.last = $2.last;
			    }
			  else
			    $$.fn = $2;
			}
		|	direct_abstract_declarator array_indicator
			{ $$.fn.comp = NULL; $$.fn.last = NULL; $$.fold_flag = 0;
			  if ($1.fn.comp) { $$.last = $1.fn.last; *$1.last = $1.fn.comp; }
			  *$1.last = $2;
			  $$.last = &d_right ($2);
			}
		|	array_indicator
			{ $$.fn.comp = NULL; $$.fn.last = NULL; $$.fold_flag = 0;
			  $$.comp = $1;
			  $$.last = &d_right ($1);
			}
		/* G++ has the following except for () and (type).  Then
		   (type) is handled in regcast_or_absdcl and () is handled
		   in fcast_or_absdcl.

		   However, this is only useful for function types, and
		   generates reduce/reduce conflicts with direct_declarator.
		   We're interested in pointer-to-function types, and in
		   functions, but not in function types - so leave this
		   out.  */
		/* |	function_arglist */
		;

abstract_declarator_fn
		:	ptr_operator
			{ $$.comp = $1.comp; $$.last = $1.last;
			  $$.fn.comp = NULL; $$.fn.last = NULL; $$.start = NULL; }
		|	ptr_operator abstract_declarator_fn
			{ $$ = $2;
			  if ($2.last)
			    *$$.last = $1.comp;
			  else
			    $$.comp = $1.comp;
			  $$.last = $1.last;
			}
		|	direct_abstract_declarator
			{ $$.comp = $1.comp; $$.last = $1.last; $$.fn = $1.fn; $$.start = NULL; }
		|	direct_abstract_declarator function_arglist COLONCOLON start
			{ $$.start = $4;
			  if ($1.fn.comp) { $$.last = $1.fn.last; *$1.last = $1.fn.comp; }
			  if ($1.fold_flag)
			    {
			      *$$.last = $2.comp;
			      $$.last = $2.last;
			    }
			  else
			    $$.fn = $2;
			}
		|	function_arglist start_opt
			{ $$.fn = $1;
			  $$.start = $2;
			  $$.comp = NULL; $$.last = NULL;
			}
		;

type		:	typespec_2
		|	typespec_2 abstract_declarator
			{ $$ = $2.comp;
			  *$2.last = $1;
			}
		;

declarator	:	ptr_operator declarator
			{ $$.comp = $2.comp;
			  $$.last = $1.last;
			  *$2.last = $1.comp; }
		|	direct_declarator
		;

direct_declarator
		:	'(' declarator ')'
			{ $$ = $2; }
		|	direct_declarator function_arglist
			{ $$.comp = $1.comp;
			  *$1.last = $2.comp;
			  $$.last = $2.last;
			}
		|	direct_declarator array_indicator
			{ $$.comp = $1.comp;
			  *$1.last = $2;
			  $$.last = &d_right ($2);
			}
		|	colon_ext_name
			{ $$.comp = make_empty (DEMANGLE_COMPONENT_TYPED_NAME);
			  d_left ($$.comp) = $1;
			  $$.last = &d_right ($$.comp);
			}
		;

/* These are similar to declarator and direct_declarator except that they
   do not permit ( colon_ext_name ), which is ambiguous with a function
   argument list.  They also don't permit a few other forms with redundant
   parentheses around the colon_ext_name; any colon_ext_name in parentheses
   must be followed by an argument list or an array indicator, or preceded
   by a pointer.  */
declarator_1	:	ptr_operator declarator_1
			{ $$.comp = $2.comp;
			  $$.last = $1.last;
			  *$2.last = $1.comp; }
		|	colon_ext_name
			{ $$.comp = make_empty (DEMANGLE_COMPONENT_TYPED_NAME);
			  d_left ($$.comp) = $1;
			  $$.last = &d_right ($$.comp);
			}
		|	direct_declarator_1

			/* Function local variable or type.  The typespec to
			   our left is the type of the containing function. 
			   This should be OK, because function local types
			   can not be templates, so the return types of their
			   members will not be mangled.  If they are hopefully
			   they'll end up to the right of the ::.  */
		|	colon_ext_name function_arglist COLONCOLON start
			{ $$.comp = fill_comp (DEMANGLE_COMPONENT_TYPED_NAME, $1, $2.comp);
			  $$.last = $2.last;
			  $$.comp = fill_comp (DEMANGLE_COMPONENT_LOCAL_NAME, $$.comp, $4);
			}
		|	direct_declarator_1 function_arglist COLONCOLON start
			{ $$.comp = $1.comp;
			  *$1.last = $2.comp;
			  $$.last = $2.last;
			  $$.comp = fill_comp (DEMANGLE_COMPONENT_LOCAL_NAME, $$.comp, $4);
			}
		;

direct_declarator_1
		:	'(' ptr_operator declarator ')'
			{ $$.comp = $3.comp;
			  $$.last = $2.last;
			  *$3.last = $2.comp; }
		|	direct_declarator_1 function_arglist
			{ $$.comp = $1.comp;
			  *$1.last = $2.comp;
			  $$.last = $2.last;
			}
		|	direct_declarator_1 array_indicator
			{ $$.comp = $1.comp;
			  *$1.last = $2;
			  $$.last = &d_right ($2);
			}
		|	colon_ext_name function_arglist
			{ $$.comp = fill_comp (DEMANGLE_COMPONENT_TYPED_NAME, $1, $2.comp);
			  $$.last = $2.last;
			}
		|	colon_ext_name array_indicator
			{ $$.comp = fill_comp (DEMANGLE_COMPONENT_TYPED_NAME, $1, $2);
			  $$.last = &d_right ($2);
			}
		;

exp	:	'(' exp1 ')'
		{ $$ = $2; }
	;

/* Silly trick.  Only allow '>' when parenthesized, in order to
   handle conflict with templates.  */
exp1	:	exp
	;

exp1	:	exp '>' exp
		{ $$ = d_binary (">", $1, $3); }
	;

/* References.  Not allowed everywhere in template parameters, only
   at the top level, but treat them as expressions in case they are wrapped
   in parentheses.  */
exp1	:	'&' start
		{ $$ = fill_comp (DEMANGLE_COMPONENT_UNARY, make_operator ("&", 1), $2); }
	|	'&' '(' start ')'
		{ $$ = fill_comp (DEMANGLE_COMPONENT_UNARY, make_operator ("&", 1), $3); }
	;

/* Expressions, not including the comma operator.  */
exp	:	'-' exp    %prec UNARY
		{ $$ = d_unary ("-", $2); }
	;

exp	:	'!' exp    %prec UNARY
		{ $$ = d_unary ("!", $2); }
	;

exp	:	'~' exp    %prec UNARY
		{ $$ = d_unary ("~", $2); }
	;

/* Casts.  First your normal C-style cast.  If exp is a LITERAL, just change
   its type.  */

exp	:	'(' type ')' exp  %prec UNARY
		{ if ($4->type == DEMANGLE_COMPONENT_LITERAL
		      || $4->type == DEMANGLE_COMPONENT_LITERAL_NEG)
		    {
		      $$ = $4;
		      d_left ($4) = $2;
		    }
		  else
		    $$ = fill_comp (DEMANGLE_COMPONENT_UNARY,
				      fill_comp (DEMANGLE_COMPONENT_CAST, $2, NULL),
				      $4);
		}
	;

/* Mangling does not differentiate between these, so we don't need to
   either.  */
exp	:	STATIC_CAST '<' type '>' '(' exp1 ')' %prec UNARY
		{ $$ = fill_comp (DEMANGLE_COMPONENT_UNARY,
				    fill_comp (DEMANGLE_COMPONENT_CAST, $3, NULL),
				    $6);
		}
	;

exp	:	DYNAMIC_CAST '<' type '>' '(' exp1 ')' %prec UNARY
		{ $$ = fill_comp (DEMANGLE_COMPONENT_UNARY,
				    fill_comp (DEMANGLE_COMPONENT_CAST, $3, NULL),
				    $6);
		}
	;

exp	:	REINTERPRET_CAST '<' type '>' '(' exp1 ')' %prec UNARY
		{ $$ = fill_comp (DEMANGLE_COMPONENT_UNARY,
				    fill_comp (DEMANGLE_COMPONENT_CAST, $3, NULL),
				    $6);
		}
	;

/* Another form of C++-style cast is "type ( exp1 )".  This creates too many
   conflicts to support.  For a while we supported the simpler
   "typespec_2 ( exp1 )", but that conflicts with "& ( start )" as a
   reference, deep within the wilderness of abstract declarators:
   Qux<int(&(*))> vs Qux<int(&(var))>, a shift-reduce conflict at the
   innermost left parenthesis.  So we do not support function-like casts.
   Fortunately they never appear in demangler output.  */

/* TO INVESTIGATE: ._0 style anonymous names; anonymous namespaces */

/* Binary operators in order of decreasing precedence.  */

exp	:	exp '*' exp
		{ $$ = d_binary ("*", $1, $3); }
	;

exp	:	exp '/' exp
		{ $$ = d_binary ("/", $1, $3); }
	;

exp	:	exp '%' exp
		{ $$ = d_binary ("%", $1, $3); }
	;

exp	:	exp '+' exp
		{ $$ = d_binary ("+", $1, $3); }
	;

exp	:	exp '-' exp
		{ $$ = d_binary ("-", $1, $3); }
	;

exp	:	exp LSH exp
		{ $$ = d_binary ("<<", $1, $3); }
	;

exp	:	exp RSH exp
		{ $$ = d_binary (">>", $1, $3); }
	;

exp	:	exp EQUAL exp
		{ $$ = d_binary ("==", $1, $3); }
	;

exp	:	exp NOTEQUAL exp
		{ $$ = d_binary ("!=", $1, $3); }
	;

exp	:	exp LEQ exp
		{ $$ = d_binary ("<=", $1, $3); }
	;

exp	:	exp GEQ exp
		{ $$ = d_binary (">=", $1, $3); }
	;

exp	:	exp '<' exp
		{ $$ = d_binary ("<", $1, $3); }
	;

exp	:	exp '&' exp
		{ $$ = d_binary ("&", $1, $3); }
	;

exp	:	exp '^' exp
		{ $$ = d_binary ("^", $1, $3); }
	;

exp	:	exp '|' exp
		{ $$ = d_binary ("|", $1, $3); }
	;

exp	:	exp ANDAND exp
		{ $$ = d_binary ("&&", $1, $3); }
	;

exp	:	exp OROR exp
		{ $$ = d_binary ("||", $1, $3); }
	;

/* Not 100% sure these are necessary, but they're harmless.  */
exp	:	exp ARROW NAME
		{ $$ = d_binary ("->", $1, $3); }
	;

exp	:	exp '.' NAME
		{ $$ = d_binary (".", $1, $3); }
	;

exp	:	exp '?' exp ':' exp	%prec '?'
		{ $$ = fill_comp (DEMANGLE_COMPONENT_TRINARY, make_operator ("?", 3),
				    fill_comp (DEMANGLE_COMPONENT_TRINARY_ARG1, $1,
						 fill_comp (DEMANGLE_COMPONENT_TRINARY_ARG2, $3, $5)));
		}
	;
			  
exp	:	INT
	;

/* Not generally allowed.  */
exp	:	FLOAT
	;

exp	:	SIZEOF '(' type ')'	%prec UNARY
		{
		  /* Match the whitespacing of cplus_demangle_operators.
		     It would abort on unrecognized string otherwise.  */
		  $$ = d_unary ("sizeof ", $3);
		}
	;

/* C++.  */
exp     :       TRUEKEYWORD    
		{ struct demangle_component *i;
		  i = make_name ("1", 1);
		  $$ = fill_comp (DEMANGLE_COMPONENT_LITERAL,
				    make_builtin_type ("bool"),
				    i);
		}
	;

exp     :       FALSEKEYWORD   
		{ struct demangle_component *i;
		  i = make_name ("0", 1);
		  $$ = fill_comp (DEMANGLE_COMPONENT_LITERAL,
				    make_builtin_type ("bool"),
				    i);
		}
	;

/* end of C++.  */

%%

/* Apply QUALIFIERS to LHS and return a qualified component.  IS_METHOD
   is set if LHS is a method, in which case the qualifiers are logically
   applied to "this".  We apply qualifiers in a consistent order; LHS
   may already be qualified; duplicate qualifiers are not created.  */

struct demangle_component *
d_qualify (struct demangle_component *lhs, int qualifiers, int is_method)
{
  struct demangle_component **inner_p;
  enum demangle_component_type type;

  /* For now the order is CONST (innermost), VOLATILE, RESTRICT.  */

#define HANDLE_QUAL(TYPE, MTYPE, QUAL)				\
  if ((qualifiers & QUAL) && (type != TYPE) && (type != MTYPE))	\
    {								\
      *inner_p = fill_comp (is_method ? MTYPE : TYPE,	\
			      *inner_p, NULL);			\
      inner_p = &d_left (*inner_p);				\
      type = (*inner_p)->type;					\
    }								\
  else if (type == TYPE || type == MTYPE)			\
    {								\
      inner_p = &d_left (*inner_p);				\
      type = (*inner_p)->type;					\
    }

  inner_p = &lhs;

  type = (*inner_p)->type;

  HANDLE_QUAL (DEMANGLE_COMPONENT_RESTRICT, DEMANGLE_COMPONENT_RESTRICT_THIS, QUAL_RESTRICT);
  HANDLE_QUAL (DEMANGLE_COMPONENT_VOLATILE, DEMANGLE_COMPONENT_VOLATILE_THIS, QUAL_VOLATILE);
  HANDLE_QUAL (DEMANGLE_COMPONENT_CONST, DEMANGLE_COMPONENT_CONST_THIS, QUAL_CONST);

  return lhs;
}

/* Return a builtin type corresponding to FLAGS.  */

static struct demangle_component *
d_int_type (int flags)
{
  const char *name;

  switch (flags)
    {
    case INT_SIGNED | INT_CHAR:
      name = "signed char";
      break;
    case INT_CHAR:
      name = "char";
      break;
    case INT_UNSIGNED | INT_CHAR:
      name = "unsigned char";
      break;
    case 0:
    case INT_SIGNED:
      name = "int";
      break;
    case INT_UNSIGNED:
      name = "unsigned int";
      break;
    case INT_LONG:
    case INT_SIGNED | INT_LONG:
      name = "long";
      break;
    case INT_UNSIGNED | INT_LONG:
      name = "unsigned long";
      break;
    case INT_SHORT:
    case INT_SIGNED | INT_SHORT:
      name = "short";
      break;
    case INT_UNSIGNED | INT_SHORT:
      name = "unsigned short";
      break;
    case INT_LLONG | INT_LONG:
    case INT_SIGNED | INT_LLONG | INT_LONG:
      name = "long long";
      break;
    case INT_UNSIGNED | INT_LLONG | INT_LONG:
      name = "unsigned long long";
      break;
    default:
      return NULL;
    }

  return make_builtin_type (name);
}

/* Wrapper to create a unary operation.  */

static struct demangle_component *
d_unary (const char *name, struct demangle_component *lhs)
{
  return fill_comp (DEMANGLE_COMPONENT_UNARY, make_operator (name, 1), lhs);
}

/* Wrapper to create a binary operation.  */

static struct demangle_component *
d_binary (const char *name, struct demangle_component *lhs, struct demangle_component *rhs)
{
  return fill_comp (DEMANGLE_COMPONENT_BINARY, make_operator (name, 2),
		      fill_comp (DEMANGLE_COMPONENT_BINARY_ARGS, lhs, rhs));
}

/* Find the end of a symbol name starting at LEXPTR.  */

static const char *
symbol_end (const char *lexptr)
{
  const char *p = lexptr;

  while (*p && (ISALNUM (*p) || *p == '_' || *p == '$' || *p == '.'))
    p++;

  return p;
}

/* Take care of parsing a number (anything that starts with a digit).
   The number starts at P and contains LEN characters.  Store the result in
   YYLVAL.  */

static int
parse_number (const char *p, int len, int parsed_float)
{
  int unsigned_p = 0;

  /* Number of "L" suffixes encountered.  */
  int long_p = 0;

  struct demangle_component *signed_type;
  struct demangle_component *unsigned_type;
  struct demangle_component *type, *name;
  enum demangle_component_type literal_type;

  if (p[0] == '-')
    {
      literal_type = DEMANGLE_COMPONENT_LITERAL_NEG;
      p++;
      len--;
    }
  else
    literal_type = DEMANGLE_COMPONENT_LITERAL;

  if (parsed_float)
    {
      /* It's a float since it contains a point or an exponent.  */
      char c;

      /* The GDB lexer checks the result of scanf at this point.  Not doing
         this leaves our error checking slightly weaker but only for invalid
         data.  */

      /* See if it has `f' or `l' suffix (float or long double).  */

      c = TOLOWER (p[len - 1]);

      if (c == 'f')
      	{
      	  len--;
      	  type = make_builtin_type ("float");
      	}
      else if (c == 'l')
	{
	  len--;
	  type = make_builtin_type ("long double");
	}
      else if (ISDIGIT (c) || c == '.')
	type = make_builtin_type ("double");
      else
	return ERROR;

      name = make_name (p, len);
      yylval.comp = fill_comp (literal_type, type, name);

      return FLOAT;
    }

  /* This treats 0x1 and 1 as different literals.  We also do not
     automatically generate unsigned types.  */

  long_p = 0;
  unsigned_p = 0;
  while (len > 0)
    {
      if (p[len - 1] == 'l' || p[len - 1] == 'L')
	{
	  len--;
	  long_p++;
	  continue;
	}
      if (p[len - 1] == 'u' || p[len - 1] == 'U')
	{
	  len--;
	  unsigned_p++;
	  continue;
	}
      break;
    }

  if (long_p == 0)
    {
      unsigned_type = make_builtin_type ("unsigned int");
      signed_type = make_builtin_type ("int");
    }
  else if (long_p == 1)
    {
      unsigned_type = make_builtin_type ("unsigned long");
      signed_type = make_builtin_type ("long");
    }
  else
    {
      unsigned_type = make_builtin_type ("unsigned long long");
      signed_type = make_builtin_type ("long long");
    }

   if (unsigned_p)
     type = unsigned_type;
   else
     type = signed_type;

   name = make_name (p, len);
   yylval.comp = fill_comp (literal_type, type, name);

   return INT;
}

static char backslashable[] = "abefnrtv";
static char represented[] = "\a\b\e\f\n\r\t\v";

/* Translate the backslash the way we would in the host character set.  */
static int
c_parse_backslash (int host_char, int *target_char)
{
  const char *ix;
  ix = strchr (backslashable, host_char);
  if (! ix)
    return 0;
  else
    *target_char = represented[ix - backslashable];
  return 1;
}

/* Parse a C escape sequence.  STRING_PTR points to a variable
   containing a pointer to the string to parse.  That pointer
   should point to the character after the \.  That pointer
   is updated past the characters we use.  The value of the
   escape sequence is returned.

   A negative value means the sequence \ newline was seen,
   which is supposed to be equivalent to nothing at all.

   If \ is followed by a null character, we return a negative
   value and leave the string pointer pointing at the null character.

   If \ is followed by 000, we return 0 and leave the string pointer
   after the zeros.  A value of 0 does not mean end of string.  */

static int
cp_parse_escape (const char **string_ptr)
{
  int target_char;
  int c = *(*string_ptr)++;
  if (c_parse_backslash (c, &target_char))
    return target_char;
  else
    switch (c)
      {
      case '\n':
	return -2;
      case 0:
	(*string_ptr)--;
	return 0;
      case '^':
	{
	  c = *(*string_ptr)++;

	  if (c == '?')
	    return 0177;
	  else if (c == '\\')
	    target_char = cp_parse_escape (string_ptr);
	  else
	    target_char = c;

	  /* Now target_char is something like `c', and we want to find
	     its control-character equivalent.  */
	  target_char = target_char & 037;

	  return target_char;
	}

      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
	{
	  int i = c - '0';
	  int count = 0;
	  while (++count < 3)
	    {
	      c = (**string_ptr);
	      if (c >= '0' && c <= '7')
		{
		  (*string_ptr)++;
		  i *= 8;
		  i += c - '0';
		}
	      else
		{
		  break;
		}
	    }
	  return i;
	}
      default:
	return c;
      }
}

#define HANDLE_SPECIAL(string, comp)				\
  if (strncmp (tokstart, string, sizeof (string) - 1) == 0)	\
    {								\
      lexptr = tokstart + sizeof (string) - 1;			\
      yylval.lval = comp;					\
      return DEMANGLER_SPECIAL;					\
    }

#define HANDLE_TOKEN2(string, token)			\
  if (lexptr[1] == string[1])				\
    {							\
      lexptr += 2;					\
      yylval.opname = string;				\
      return token;					\
    }      

#define HANDLE_TOKEN3(string, token)			\
  if (lexptr[1] == string[1] && lexptr[2] == string[2])	\
    {							\
      lexptr += 3;					\
      yylval.opname = string;				\
      return token;					\
    }      

/* Read one token, getting characters through LEXPTR.  */

static int
yylex (void)
{
  int c;
  int namelen;
  const char *tokstart;

 retry:
  prev_lexptr = lexptr;
  tokstart = lexptr;

  switch (c = *tokstart)
    {
    case 0:
      return 0;

    case ' ':
    case '\t':
    case '\n':
      lexptr++;
      goto retry;

    case '\'':
      /* We either have a character constant ('0' or '\177' for example)
	 or we have a quoted symbol reference ('foo(int,int)' in C++
	 for example). */
      lexptr++;
      c = *lexptr++;
      if (c == '\\')
	c = cp_parse_escape (&lexptr);
      else if (c == '\'')
	{
	  yyerror (_("empty character constant"));
	  return ERROR;
	}

      c = *lexptr++;
      if (c != '\'')
	{
	  yyerror (_("invalid character constant"));
	  return ERROR;
	}

      /* FIXME: We should refer to a canonical form of the character,
	 presumably the same one that appears in manglings - the decimal
	 representation.  But if that isn't in our input then we have to
	 allocate memory for it somewhere.  */
      yylval.comp = fill_comp (DEMANGLE_COMPONENT_LITERAL,
				 make_builtin_type ("char"),
				 make_name (tokstart, lexptr - tokstart));

      return INT;

    case '(':
      if (strncmp (tokstart, "(anonymous namespace)", 21) == 0)
	{
	  lexptr += 21;
	  yylval.comp = make_name ("(anonymous namespace)",
				     sizeof "(anonymous namespace)" - 1);
	  return NAME;
	}
	/* FALL THROUGH */

    case ')':
    case ',':
      lexptr++;
      return c;

    case '.':
      if (lexptr[1] == '.' && lexptr[2] == '.')
	{
	  lexptr += 3;
	  return ELLIPSIS;
	}

      /* Might be a floating point number.  */
      if (lexptr[1] < '0' || lexptr[1] > '9')
	goto symbol;		/* Nope, must be a symbol. */

      goto try_number;

    case '-':
      HANDLE_TOKEN2 ("-=", ASSIGN_MODIFY);
      HANDLE_TOKEN2 ("--", DECREMENT);
      HANDLE_TOKEN2 ("->", ARROW);

      /* For construction vtables.  This is kind of hokey.  */
      if (strncmp (tokstart, "-in-", 4) == 0)
	{
	  lexptr += 4;
	  return CONSTRUCTION_IN;
	}

      if (lexptr[1] < '0' || lexptr[1] > '9')
	{
	  lexptr++;
	  return '-';
	}
      /* FALL THRU into number case.  */

    try_number:
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
      {
	/* It's a number.  */
	int got_dot = 0, got_e = 0, toktype;
	const char *p = tokstart;
	int hex = 0;

	if (c == '-')
	  p++;

	if (c == '0' && (p[1] == 'x' || p[1] == 'X'))
	  {
	    p += 2;
	    hex = 1;
	  }
	else if (c == '0' && (p[1]=='t' || p[1]=='T' || p[1]=='d' || p[1]=='D'))
	  {
	    p += 2;
	    hex = 0;
	  }

	for (;; ++p)
	  {
	    /* This test includes !hex because 'e' is a valid hex digit
	       and thus does not indicate a floating point number when
	       the radix is hex.  */
	    if (!hex && !got_e && (*p == 'e' || *p == 'E'))
	      got_dot = got_e = 1;
	    /* This test does not include !hex, because a '.' always indicates
	       a decimal floating point number regardless of the radix.

	       NOTE drow/2005-03-09: This comment is not accurate in C99;
	       however, it's not clear that all the floating point support
	       in this file is doing any good here.  */
	    else if (!got_dot && *p == '.')
	      got_dot = 1;
	    else if (got_e && (p[-1] == 'e' || p[-1] == 'E')
		     && (*p == '-' || *p == '+'))
	      /* This is the sign of the exponent, not the end of the
		 number.  */
	      continue;
	    /* We will take any letters or digits.  parse_number will
	       complain if past the radix, or if L or U are not final.  */
	    else if (! ISALNUM (*p))
	      break;
	  }
	toktype = parse_number (tokstart, p - tokstart, got_dot|got_e);
        if (toktype == ERROR)
	  {
	    char *err_copy = (char *) alloca (p - tokstart + 1);

	    memcpy (err_copy, tokstart, p - tokstart);
	    err_copy[p - tokstart] = 0;
	    yyerror (_("invalid number"));
	    return ERROR;
	  }
	lexptr = p;
	return toktype;
      }

    case '+':
      HANDLE_TOKEN2 ("+=", ASSIGN_MODIFY);
      HANDLE_TOKEN2 ("++", INCREMENT);
      lexptr++;
      return c;
    case '*':
      HANDLE_TOKEN2 ("*=", ASSIGN_MODIFY);
      lexptr++;
      return c;
    case '/':
      HANDLE_TOKEN2 ("/=", ASSIGN_MODIFY);
      lexptr++;
      return c;
    case '%':
      HANDLE_TOKEN2 ("%=", ASSIGN_MODIFY);
      lexptr++;
      return c;
    case '|':
      HANDLE_TOKEN2 ("|=", ASSIGN_MODIFY);
      HANDLE_TOKEN2 ("||", OROR);
      lexptr++;
      return c;
    case '&':
      HANDLE_TOKEN2 ("&=", ASSIGN_MODIFY);
      HANDLE_TOKEN2 ("&&", ANDAND);
      lexptr++;
      return c;
    case '^':
      HANDLE_TOKEN2 ("^=", ASSIGN_MODIFY);
      lexptr++;
      return c;
    case '!':
      HANDLE_TOKEN2 ("!=", NOTEQUAL);
      lexptr++;
      return c;
    case '<':
      HANDLE_TOKEN3 ("<<=", ASSIGN_MODIFY);
      HANDLE_TOKEN2 ("<=", LEQ);
      HANDLE_TOKEN2 ("<<", LSH);
      lexptr++;
      return c;
    case '>':
      HANDLE_TOKEN3 (">>=", ASSIGN_MODIFY);
      HANDLE_TOKEN2 (">=", GEQ);
      HANDLE_TOKEN2 (">>", RSH);
      lexptr++;
      return c;
    case '=':
      HANDLE_TOKEN2 ("==", EQUAL);
      lexptr++;
      return c;
    case ':':
      HANDLE_TOKEN2 ("::", COLONCOLON);
      lexptr++;
      return c;

    case '[':
    case ']':
    case '?':
    case '@@':
    case '~':
    case '{':
    case '}':
    symbol:
      lexptr++;
      return c;

    case '"':
      /* These can't occur in C++ names.  */
      yyerror (_("unexpected string literal"));
      return ERROR;
    }

  if (!(c == '_' || c == '$' || ISALPHA (c)))
    {
      /* We must have come across a bad character (e.g. ';').  */
      yyerror (_("invalid character"));
      return ERROR;
    }

  /* It's a name.  See how long it is.  */
  namelen = 0;
  do
    c = tokstart[++namelen];
  while (ISALNUM (c) || c == '_' || c == '$');

  lexptr += namelen;

  /* Catch specific keywords.  Notice that some of the keywords contain
     spaces, and are sorted by the length of the first word.  They must
     all include a trailing space in the string comparison.  */
  switch (namelen)
    {
    case 16:
      if (strncmp (tokstart, "reinterpret_cast", 16) == 0)
        return REINTERPRET_CAST;
      break;
    case 12:
      if (strncmp (tokstart, "construction vtable for ", 24) == 0)
	{
	  lexptr = tokstart + 24;
	  return CONSTRUCTION_VTABLE;
	}
      if (strncmp (tokstart, "dynamic_cast", 12) == 0)
        return DYNAMIC_CAST;
      break;
    case 11:
      if (strncmp (tokstart, "static_cast", 11) == 0)
        return STATIC_CAST;
      break;
    case 9:
      HANDLE_SPECIAL ("covariant return thunk to ", DEMANGLE_COMPONENT_COVARIANT_THUNK);
      HANDLE_SPECIAL ("reference temporary for ", DEMANGLE_COMPONENT_REFTEMP);
      break;
    case 8:
      HANDLE_SPECIAL ("typeinfo for ", DEMANGLE_COMPONENT_TYPEINFO);
      HANDLE_SPECIAL ("typeinfo fn for ", DEMANGLE_COMPONENT_TYPEINFO_FN);
      HANDLE_SPECIAL ("typeinfo name for ", DEMANGLE_COMPONENT_TYPEINFO_NAME);
      if (strncmp (tokstart, "operator", 8) == 0)
	return OPERATOR;
      if (strncmp (tokstart, "restrict", 8) == 0)
	return RESTRICT;
      if (strncmp (tokstart, "unsigned", 8) == 0)
	return UNSIGNED;
      if (strncmp (tokstart, "template", 8) == 0)
	return TEMPLATE;
      if (strncmp (tokstart, "volatile", 8) == 0)
	return VOLATILE_KEYWORD;
      break;
    case 7:
      HANDLE_SPECIAL ("virtual thunk to ", DEMANGLE_COMPONENT_VIRTUAL_THUNK);
      if (strncmp (tokstart, "wchar_t", 7) == 0)
	return WCHAR_T;
      break;
    case 6:
      if (strncmp (tokstart, "global constructors keyed to ", 29) == 0)
	{
	  const char *p;
	  lexptr = tokstart + 29;
	  yylval.lval = DEMANGLE_COMPONENT_GLOBAL_CONSTRUCTORS;
	  /* Find the end of the symbol.  */
	  p = symbol_end (lexptr);
	  yylval.comp = make_name (lexptr, p - lexptr);
	  lexptr = p;
	  return DEMANGLER_SPECIAL;
	}
      if (strncmp (tokstart, "global destructors keyed to ", 28) == 0)
	{
	  const char *p;
	  lexptr = tokstart + 28;
	  yylval.lval = DEMANGLE_COMPONENT_GLOBAL_DESTRUCTORS;
	  /* Find the end of the symbol.  */
	  p = symbol_end (lexptr);
	  yylval.comp = make_name (lexptr, p - lexptr);
	  lexptr = p;
	  return DEMANGLER_SPECIAL;
	}

      HANDLE_SPECIAL ("vtable for ", DEMANGLE_COMPONENT_VTABLE);
      if (strncmp (tokstart, "delete", 6) == 0)
	return DELETE;
      if (strncmp (tokstart, "struct", 6) == 0)
	return STRUCT;
      if (strncmp (tokstart, "signed", 6) == 0)
	return SIGNED_KEYWORD;
      if (strncmp (tokstart, "sizeof", 6) == 0)
	return SIZEOF;
      if (strncmp (tokstart, "double", 6) == 0)
	return DOUBLE_KEYWORD;
      break;
    case 5:
      HANDLE_SPECIAL ("guard variable for ", DEMANGLE_COMPONENT_GUARD);
      if (strncmp (tokstart, "false", 5) == 0)
	return FALSEKEYWORD;
      if (strncmp (tokstart, "class", 5) == 0)
	return CLASS;
      if (strncmp (tokstart, "union", 5) == 0)
	return UNION;
      if (strncmp (tokstart, "float", 5) == 0)
	return FLOAT_KEYWORD;
      if (strncmp (tokstart, "short", 5) == 0)
	return SHORT;
      if (strncmp (tokstart, "const", 5) == 0)
	return CONST_KEYWORD;
      break;
    case 4:
      if (strncmp (tokstart, "void", 4) == 0)
	return VOID;
      if (strncmp (tokstart, "bool", 4) == 0)
	return BOOL;
      if (strncmp (tokstart, "char", 4) == 0)
	return CHAR;
      if (strncmp (tokstart, "enum", 4) == 0)
	return ENUM;
      if (strncmp (tokstart, "long", 4) == 0)
	return LONG;
      if (strncmp (tokstart, "true", 4) == 0)
	return TRUEKEYWORD;
      break;
    case 3:
      HANDLE_SPECIAL ("VTT for ", DEMANGLE_COMPONENT_VTT);
      HANDLE_SPECIAL ("non-virtual thunk to ", DEMANGLE_COMPONENT_THUNK);
      if (strncmp (tokstart, "new", 3) == 0)
	return NEW;
      if (strncmp (tokstart, "int", 3) == 0)
	return INT_KEYWORD;
      break;
    default:
      break;
    }

  yylval.comp = make_name (tokstart, namelen);
  return NAME;
}

static void
yyerror (char *msg)
{
  if (global_errmsg)
    return;

  error_lexptr = prev_lexptr;
  global_errmsg = msg ? msg : "parse error";
}

/* Allocate a chunk of the components we'll need to build a tree.  We
   generally allocate too many components, but the extra memory usage
   doesn't hurt because the trees are temporary and the storage is
   reused.  More may be allocated later, by d_grab.  */
static struct demangle_info *
allocate_info (void)
{
  struct demangle_info *info = malloc (sizeof (struct demangle_info));

  info->next = NULL;
  info->used = 0;
  return info;
}

/* Convert RESULT to a string.  The return value is allocated
   using xmalloc.  ESTIMATED_LEN is used only as a guide to the
   length of the result.  This functions handles a few cases that
   cplus_demangle_print does not, specifically the global destructor
   and constructor labels.  */

char *
cp_comp_to_string (struct demangle_component *result, int estimated_len)
{
  size_t err;

  return cplus_demangle_print (DMGL_PARAMS | DMGL_ANSI, result, estimated_len,
			       &err);
}

/* A convenience function to allocate and initialize a new struct
   demangled_parse_info.  */

struct demangle_parse_info *
cp_new_demangle_parse_info (void)
{
  struct demangle_parse_info *info;

  info = malloc (sizeof (struct demangle_parse_info));
  info->info = NULL;
  info->tree = NULL;
  obstack_init (&info->obstack);

  return info;
}

/* Free any memory associated with the given PARSE_INFO.  */

void
cp_demangled_name_parse_free (struct demangle_parse_info *parse_info)
{
  struct demangle_info *info = parse_info->info;

  /* Free any allocated chunks of memory for the parse.  */
  while (info != NULL)
    {
      struct demangle_info *next = info->next;

      free (info);
      info = next;
    }

  /* Free any memory allocated during typedef replacement.  */
  obstack_free (&parse_info->obstack, NULL);

  /* Free the parser info.  */
  free (parse_info);
}

/* Merge the two parse trees given by DEST and SRC.  The parse tree
   in SRC is attached to DEST at the node represented by TARGET.
   SRC is then freed.

   NOTE 1: Since there is no API to merge obstacks, this function does
   even attempt to try it.  Fortunately, we do not (yet?) need this ability.
   The code will assert if SRC->obstack is not empty.

   NOTE 2: The string from which SRC was parsed must not be freed, since
   this function will place pointers to that string into DEST.  */

void
cp_merge_demangle_parse_infos (struct demangle_parse_info *dest,
			       struct demangle_component *target,
			       struct demangle_parse_info *src)

{
  struct demangle_info *di;

  /* Copy the SRC's parse data into DEST.  */
  *target = *src->tree;
  di = dest->info;
  while (di->next != NULL)
    di = di->next;
  di->next = src->info;

  /* Clear the (pointer to) SRC's parse data so that it is not freed when
     cp_demangled_parse_info_free is called.  */
  src->info = NULL;

  /* Free SRC.  */
  cp_demangled_name_parse_free (src);
}

/* Convert a demangled name to a demangle_component tree.  On success,
   a structure containing the root of the new tree is returned; it must
   be freed by calling cp_demangled_name_parse_free. On error, NULL is
   returned, and an error message will be set in *ERRMSG (which does
   not need to be freed).  */

struct demangle_parse_info *
cp_demangled_name_to_comp (const char *demangled_name, const char **errmsg)
{
  static char errbuf[60];
  struct demangle_parse_info *result;

  prev_lexptr = lexptr = demangled_name;
  error_lexptr = NULL;
  global_errmsg = NULL;

  demangle_info = allocate_info ();

  result = cp_new_demangle_parse_info ();
  result->info = demangle_info;

  if (yyparse ())
    {
      if (global_errmsg && errmsg)
	{
	  snprintf (errbuf, sizeof (errbuf) - 2, "%s, near `%s",
		    global_errmsg, error_lexptr);
	  strcat (errbuf, "'");
	  *errmsg = errbuf;
	}
      cp_demangled_name_parse_free (result);
      return NULL;
    }

  result->tree = global_result;
  global_result = NULL;

  return result;
}

#ifdef TEST_CPNAMES

static void
cp_print (struct demangle_component *result)
{
  char *str;
  size_t err = 0;

  str = cplus_demangle_print (DMGL_PARAMS | DMGL_ANSI, result, 64, &err);
  if (str == NULL)
    return;

  fputs (str, stdout);

  free (str);
}

static char
trim_chars (char *lexptr, char **extra_chars)
{
  char *p = (char *) symbol_end (lexptr);
  char c = 0;

  if (*p)
    {
      c = *p;
      *p = 0;
      *extra_chars = p + 1;
    }

  return c;
}

/* When this file is built as a standalone program, xmalloc comes from
   libiberty --- in which case we have to provide xfree ourselves.  */

void
xfree (void *ptr)
{
  if (ptr != NULL)
    {
      /* Literal `free' would get translated back to xfree again.  */
      CONCAT2 (fr,ee) (ptr);
    }
}

/* GDB normally defines internal_error itself, but when this file is built
   as a standalone program, we must also provide an implementation.  */

void
internal_error (const char *file, int line, const char *fmt, ...)
{
  va_list ap;

  va_start (ap, fmt);
  fprintf (stderr, "%s:%d: internal error: ", file, line);
  vfprintf (stderr, fmt, ap);
  exit (1);
}

int
main (int argc, char **argv)
{
  char *str2, *extra_chars = "", c;
  char buf[65536];
  int arg;
  const char *errmsg;
  struct demangle_parse_info *result;

  arg = 1;
  if (argv[arg] && strcmp (argv[arg], "--debug") == 0)
    {
      yydebug = 1;
      arg++;
    }

  if (argv[arg] == NULL)
    while (fgets (buf, 65536, stdin) != NULL)
      {
	int len;
	buf[strlen (buf) - 1] = 0;
	/* Use DMGL_VERBOSE to get expanded standard substitutions.  */
	c = trim_chars (buf, &extra_chars);
	str2 = cplus_demangle (buf, DMGL_PARAMS | DMGL_ANSI | DMGL_VERBOSE);
	if (str2 == NULL)
	  {
	    printf ("Demangling error\n");
	    if (c)
	      printf ("%s%c%s\n", buf, c, extra_chars);
	    else
	      printf ("%s\n", buf);
	    continue;
	  }
	result = cp_demangled_name_to_comp (str2, &errmsg);
	if (result == NULL)
	  {
	    fputs (errmsg, stderr);
	    fputc ('\n', stderr);
	    continue;
	  }

	cp_print (result->tree);
	cp_demangled_name_parse_free (result);

	free (str2);
	if (c)
	  {
	    putchar (c);
	    fputs (extra_chars, stdout);
	  }
	putchar ('\n');
      }
  else
    {
      result = cp_demangled_name_to_comp (argv[arg], &errmsg);
      if (result == NULL)
	{
	  fputs (errmsg, stderr);
	  fputc ('\n', stderr);
	  return 0;
	}
      cp_print (result->tree);
      cp_demangled_name_parse_free (result);
      putchar ('\n');
    }
  return 0;
}

#endif
@


1.27
log
@gdb/
	Fix internal error on canonicalization of clang types.
	* cp-name-parser.y (operator): New comment at make_operator call for
	new, delete, new[] and delete[].
	(exp): Use "sizeof ".  Add new comment at make_operator call.

gdb/testsuite/
	Fix internal error on canonicalization of clang types.
	* gdb.dwarf2/dw2-canonicalize-type.S: New file.
	* gdb.dwarf2/dw2-canonicalize-type.exp: New file.
	* lib/gdb.exp (gdb_file_cmd): Catch also GDB internal error.
@
text
@d3 1
a3 1
   Copyright (C) 2003-2005, 2007-2012 Free Software Foundation, Inc.
@


1.26
log
@* ada-exp.y (yyss, yysslim, yyssp, yystacksize, yyvs, yyvsp): New
defines.
* c-exp.y (yyss, yysslim, yyssp, yystacksize, yyvs, yyvsp): New
defines.
* cp-name-parser.y (yyss, yysslim, yyssp, yystacksize, yyvs)
(yyvsp): New defines.
* f-exp.y (yyss, yysslim, yyssp, yystacksize, yyvs, yyvsp): New
defines.
* jv-exp.y (yyss, yysslim, yyssp, yystacksize, yyvs, yyvsp): New
defines.
* m2-exp.y (yyss, yysslim, yyssp, yystacksize, yyvs, yyvsp): New
defines.
* objc-exp.y (yyss, yysslim, yyssp, yystacksize, yyvs, yyvsp): New
defines.
* p-exp.y (yyss, yysslim, yyssp, yystacksize, yyvs, yyvsp): New
defines.
@
text
@d449 5
a453 1
			{ $$ = make_operator ("new", 3); }
d455 5
a459 1
			{ $$ = make_operator ("delete ", 1); }
d461 5
a465 1
			{ $$ = make_operator ("new[]", 3); }
d467 5
a471 1
			{ $$ = make_operator ("delete[] ", 1); }
d1202 5
a1206 1
		{ $$ = d_unary ("sizeof", $3); }
@


1.25
log
@gdb/
	Fix regression after libiberty/ update for GCC PR 6057 and others.
	* c-exp.y (operator) <OPERATOR DELETE>
	(operator) <OPERATOR DELETE '[' ']'>: Add trailing space.
	* cp-name-parser.y (fill_comp, make_operator, make_dtor)
	(make_builtin_type, make_name): New variable i, add gdb_assert.
	(operator) <OPERATOR NEW>: Update ARGS to 3.
	(operator) <OPERATOR DELETE>: Add trailing space.
	(operator) <OPERATOR NEW '[' ']'>: Update ARGS to 3.
	(operator) <OPERATOR DELETE '[' ']'>: Add trailing space.
	* cp-support.c (cp_canonicalize_string): Check NULL from
	cp_comp_to_string, call warning and return.
@
text
@d173 6
@


1.24
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d191 5
a195 1
  cplus_demangle_fill_component (ret, d_type, lhs, rhs);
d211 5
a215 1
  cplus_demangle_fill_operator (ret, name, args);
d223 5
a227 1
  cplus_demangle_fill_dtor (ret, kind, name);
d235 5
a239 1
  cplus_demangle_fill_builtin_type (ret, name);
d247 5
a251 1
  cplus_demangle_fill_name (ret, name, len);
d443 1
a443 1
			{ $$ = make_operator ("new", 1); }
d445 1
a445 1
			{ $$ = make_operator ("delete", 1); }
d447 1
a447 1
			{ $$ = make_operator ("new[]", 1); }
d449 1
a449 1
			{ $$ = make_operator ("delete[]", 1); }
@


1.23
log
@* cp-name-parser.y (cp_merge_demangle_parse_infos): Don't use
obstack_empty_p.
@
text
@d3 1
a3 2
   Copyright (C) 2003, 2004, 2005, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.22
log
@	PR c++/12266
	* cp-name-parser.y (struct demangle_info): Remove unused
	member PREV.
	(d_grab): Likewise.
	(allocate_info): Change return type to struct demangle_info *.
	Always allocate a new demangle_info.
	Remove unused PREV pointer.
	(cp_new_demangle_parse_info): New function.
	(cp_demangled_name_parse_free): New function.
	(do_demangled_name_parse_free_cleanup): New function.
	(make_cleanup_cp_demangled_name_parse_free): New function.
	(cp_demangled_name_to_comp): Change return type to
	struct demangle_parse_info *.
	Allocate a new storage for each call.
	(main): Update usage for cp_demangled_name_to_comp
	API change.
	* cp-support.h (struct demangle_parse_info): New structure.
	(cp_demangled_name_to_comp): Update API change for
	return type.
	(cp_new_demangle_parse_info): Declare.
	(make_cleanup_cp_demangled_name_parse_free): New declaration.
	(cp_demangled_name_parse_free): Declare.
	* cp-support.c (cp_canonicalize_string): Update API
	change for cp_demangled_name_to_comp.
	(mangled_name_to_comp): Likewise.
	Return struct demangle_parse_info, too.
	(cp_class_name_from_physname): Update mangled_name_to_comp
	API change.
	(method_name_from_physname): Likewise.
	(cp_func_name): Update API change for cp_demangled_name_to_comp.
	(cp_remove_params): Likewise.
	* python/py-type.c (typy_legacy_template_argument): Likewise.

	* cp-support.h (cp_canonicalize_string_no_typedefs): Declare.
	(cp_merge_demangle_parse_infos): Declare.
	* cp-support.c (ignore_typedefs): New file global.
	(copy_string_to_obstack): New function.
	(inspect_type): New function.
	(replace_typedefs): New function.
	(replace_typedefs_qualified_name): New function.
	(cp_canonicalize_string_no_typedefs): New function.
	* cp-name-parser.y (cp_merge_demangle_parse_infos): New function.
	(cp_new_demangle__parse_info): Allocate and initialize the obstack.
	* linespec.c (find_methods): Use cp_canonicalize_string_no_typedefs
	instead of cp_canonicalize_string.
	(find_method): Likewise.
	(decode_compound): Before looking up the name, call
	cp_canonicalize_string_no_typedefs.
	(decode_variable): Likewise.
@
text
@a2031 3
  /* Assert if the SRC obstack is not empty.  */
  gdb_assert (obstack_empty_p (&src->obstack));

@


1.22.2.1
log
@* cp-name-parser.y (cp_merge_demangle_parse_infos): Don't use
obstack_empty_p.
@
text
@d2032 3
@


1.22.2.2
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 2
a4 1
   Copyright (C) 2003-2005, 2007-2012 Free Software Foundation, Inc.
@


1.21
log
@gdb/
	* cp-name-parser.y (xfree): Wrap the name free by CONCAT2.
	(main): Uncomment "Demangling error\n".
@
text
@d44 1
d64 1
a64 1
  struct demangle_info *prev, *next;
a79 1
	  more->prev = demangle_info;
d1938 1
a1938 1
static void
d1941 1
a1941 9
  if (demangle_info == NULL)
    {
      demangle_info = malloc (sizeof (struct demangle_info));
      demangle_info->prev = NULL;
      demangle_info->next = NULL;
    }
  else
    while (demangle_info->prev)
      demangle_info = demangle_info->prev;
d1943 3
a1945 1
  demangle_info->used = 0;
d1963 76
d2040 2
a2041 2
   the root of the new tree is returned; it is valid until the next
   call to this function and should not be freed.  On error, NULL is
d2045 1
a2045 1
struct demangle_component *
d2049 1
a2049 1
  struct demangle_component *result;
d2055 4
a2058 1
  allocate_info ();
d2069 1
d2073 1
a2073 1
  result = global_result;
d2125 14
d2146 1
a2146 1
  struct demangle_component *result;
d2180 2
a2181 1
	cp_print (result);
d2200 2
a2201 1
      cp_print (result);
@


1.20
log
@	ARI fixes: Add missing internationalization markups throughout
	yacc files.
	* c-exp.y: Ditto.
	* cp-name-parser.y: Ditto.
	* f-exp.y: Ditto.
	* m2-exp.y: Ditto.
	* objc-exp.y: Ditto.
	* p-exp.y: Ditto.
@
text
@d2045 4
a2048 1
    free (ptr);
d2077 1
a2077 1
	    /* printf ("Demangling error\n"); */
@


1.19
log
@run copyright.sh for 2011.
@
text
@d1571 1
a1571 1
	  yyerror ("empty character constant");
d1578 1
a1578 1
	  yyerror ("invalid character constant");
d1702 1
a1702 1
	    yyerror ("invalid number");
d1778 1
a1778 1
      yyerror ("unexpected string literal");
d1785 1
a1785 1
      yyerror ("invalid character");
@


1.18
log
@2010-05-05  Michael Snyder  <msnyder@@vmware.com>

	* c-exp.y (parse_string_or_char): Delete unused variable.
	(c_lex): Delete unused variable.
	* cp-name-parser.y (cpname_lex): Delete unused variable.
	* ada-exp.y (find_primitive_type): Delete unused variable.
	(write_var_or_type): Delete unused variable.
	* jv-exp.y (java_parse): Delete unused variable.
	(push_expression_name): Delete unused variable.
	* p-exp.y (pascal_lex): Delete unused variable.
@
text
@d3 1
a3 1
   Copyright (C) 2003, 2004, 2005, 2007, 2008, 2009, 2010
@


1.17
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d1544 1
a1544 1
  const char *tokstart, *tokptr;
@


1.16
log
@gdb/
	Fix gcc-4.5 HEAD warnings.
	* cp-name-parser.y (%union <typed_val_int>, %token GLOBAL)
	(GLOBAL_CONSTRUCTORS, GLOBAL_DESTRUCTORS, demangler_special <GLOBAL>):
	Remove.
	(yylex <"global constructors keyed to ">)
	(yylex <"global destructors keyed to ">): Base it on DEMANGLER_SPECIAL.
	(cp_comp_to_string): Remove variables str, prefix and buf.  Remove the
	GLOBAL_DESTRUCTORS and GLOBAL_CONSTRUCTORS handling.
	(cp_print): Remove the GLOBAL_DESTRUCTORS and GLOBAL_CONSTRUCTORS
	handling.
@
text
@d3 1
a3 1
   Copyright (C) 2003, 2004, 2005, 2007, 2008, 2009
@


1.15
log
@gdb

2009-03-31  Daniel Jacobowitz  <dan@@codesourcery.com>
	    Keith Seitz  <keiths@@redhat.com>
	    Jan Kratochvil  <jan.kratochvil@@redhat.com>

	PR gdb/6817
	* Makefile.in (dbxread.o): Update.
	* dbxread.c (read_dbx_symtab): Use cp_canonicalize_string.
	* dwarf2read.c (GDB_FORM_cached_string): New.
	(read_partial_die): Use dwarf2_canonicalize_name.
	(dwarf2_linkage_name): Use dwarf2_name.
	(dwarf2_canonicalize_name): New.
	(dwarf2_name): Use dwarf2_canonicalize_name.
	(dwarf_form_name, dump_die): Handle GDB_FORM_cached_string.
	* stabsread.c (define_symbol, read_type): Use cp_canonicalize_string.
	* symtab.c (lookup_symbol_in_language): Canonicalize input before
	searching.
	* cp-name-parser.y: operator() requires two parameters,
	according to libiberty.
	* minsyms.c (lookup_minimal_symbol): Canonicalize input
	before searching.
	* NEWS: Update.

gdb/testsuite

2009-03-31  Daniel Jacobowitz  <dan@@codesourcery.com>
	    Jan Kratochvil  <jan.kratochvil@@redhat.com>

	PR gdb/931
	* gdb.cp/gdb1355.exp (f_li, f_lui, f_si, f_sui): Allow canonical
	output.
	* gdb.cp/templates.exp: Allow canonical output.  Remove KFAILs
	for gdb/931.
	* dw2-strp.S (DW_AT_language): Change to C++.
	(DW_TAG_variable (name ""), Abbrev code 7, .Lemptyname): New.
@
text
@a257 4
    struct {
      int val;
      struct demangle_component *type;
    } typed_val_int;
a311 8
%token <typed_val_int> GLOBAL

%{
enum {
  GLOBAL_CONSTRUCTORS = DEMANGLE_COMPONENT_LITERAL + 20,
  GLOBAL_DESTRUCTORS = DEMANGLE_COMPONENT_LITERAL + 21
};
%}
a420 4
		|	GLOBAL
			{ $$ = make_empty ($1.val);
			  d_left ($$) = $1.type;
			  d_right ($$) = NULL; }
d1848 1
a1848 1
	  yylval.typed_val_int.val = GLOBAL_CONSTRUCTORS;
d1851 1
a1851 1
	  yylval.typed_val_int.type = make_name (lexptr, p - lexptr);
d1853 1
a1853 1
	  return GLOBAL;
d1859 1
a1859 1
	  yylval.typed_val_int.val = GLOBAL_DESTRUCTORS;
d1862 1
a1862 1
	  yylval.typed_val_int.type = make_name (lexptr, p - lexptr);
d1864 1
a1864 1
	  return GLOBAL;
d1963 1
a1963 2
  char *str, *prefix = NULL, *buf;
  size_t err = 0;
d1965 2
a1966 23
  if (result->type == GLOBAL_DESTRUCTORS)
    {
      result = d_left (result);
      prefix = "global destructors keyed to ";
    }
  else if (result->type == GLOBAL_CONSTRUCTORS)
    {
      result = d_left (result);
      prefix = "global constructors keyed to ";
    }

  str = cplus_demangle_print (DMGL_PARAMS | DMGL_ANSI, result, estimated_len, &err);
  if (str == NULL)
    return NULL;

  if (prefix == NULL)
    return str;

  buf = malloc (strlen (str) + strlen (prefix) + 1);
  strcpy (buf, prefix);
  strcat (buf, str);
  free (str);
  return (buf);
a2012 11
  if (result->type == GLOBAL_DESTRUCTORS)
    {
      result = d_left (result);
      fputs ("global destructors keyed to ", stdout);
    }
  else if (result->type == GLOBAL_CONSTRUCTORS)
    {
      result = d_left (result);
      fputs ("global constructors keyed to ", stdout);
    }

@


1.14
log
@	* Makefile.in: Update license to GPLv3.
	* ada-exp.y: Update license to GPLv3.
	* ada-lex.l: Update license to GPLv3.
	* c-exp.y: Update license to GPLv3.
	* cp-name-parser.y: Update license to GPLv3.
	* darwin-nat-info.c: Update license to GPLv3.
	* f-exp.y: Update license to GPLv3.
	* gdb_thread_db.h: Update license to GPLv3.
	* hppanbsd-nat.c: Update license to GPLv3.
	* hppanbsd-tdep.c: Update license to GPLv3.
	* hppaobsd-tdep.c: Update license to GPLv3.
	* jv-exp.y: Update license to GPLv3.
	* m2-exp.y: Update license to GPLv3.
	* objc-exp.y: Update license to GPLv3.
	* p-exp.y: Update license to GPLv3.
	* reply_mig_hack.awk: Update license to GPLv3.
	* reverse.c: Update license to GPLv3.
	* xtensa-xtregs.c: Update license to GPLv3.
@
text
@d502 1
a502 1
			{ $$ = make_operator ("()", 0); }
@


1.13
log
@2008-02-21  Pedro Alves  <pedro@@codesorcery.com>

	Silence a few -Wmissing-prototypes warnings.

	PR build/9877:
	* amd64-nat.c: Include "amd64-nat.h".
	* fork-child.c (_initialize_fork_child): Ditto.
	* gcore.c (_initialize_gcore): Ditto.
	* inf-ptrace.c: Include "inf-ptrace.h".
	(inf_ptrace_store_registers): Make it static.
	* linux-nat.c (linux_nat_terminal_ours): Make it static.
	(_initialize_linux_nat): Declare before definition.
	* linux-tdep.c: Include "linux-tdep.h".
	* linux-thread-db.c (_initialize_thread_db): Declare before
	definition.
	* proc-service.c (_initialize_proc_service): Ditto.
	* remote.c (remote_send_printf): Make it static.
	* solib.c: Include "solib.h".
	* symfile-mem.c (_initialize_symfile_mem): Declare before
	definition.
	* ada-lang.c (ada_la_decode, ada_match_name)
	(ada_suppress_symbol_printing, ada_is_array_type)
	(ada_value_ptr_subscript, ada_array_length)
	(ada_to_static_fixed_value): Make them static.
	(_initialize_ada_language): Declare before definition.
	* ada-tasks.c (ada_get_task_number, ada_get_environment_task)
	(ada_task_list_changed, ada_new_objfile_observer): Make them
	static.
	(_initialize_tasks): Declare before definition.
	* addrmap.c (_initialize_addrmap): Declare before definition.
	* auxv.c (default_auxv_parse): Make it static.
	* bfd-target.c (target_bfd_xfer_partial, target_bfd_xclose): Make
	them static.
	* breakpoint.c (remove_sal): Add line break.
	(expand_line_sal_maybe): Make it static.
	* cp-name-parser.y: Include "cp-support.h".
	* cp-valprint.c (cp_find_class_member): Make it static.
	* eval.c (value_f90_subarray): Ditto.
	* exceptions.c (print_any_exception): Ditto.
	* findcmd.c (_initialize_mem_search): Declare before definition.
	* frame.c (frame_observer_target_changed): Make it static.
	* gnu-v3-abi.c (gnuv3_find_method_in): Make it static.
	* inf-child.c: Include "inf-child.h".
	* inferior.h (valid_inferior_id): Rename to ...
	(valid_gdb_inferior_id): ... this.
	* infrun.c (infrun_thread_stop_requested, siginfo_make_value):
	Make them static.
	* jv-lang.c (java_language_arch_info): Make it static.
	* m2-typeprint.c (m2_get_discrete_bounds): Ditto.
	* osdata.c (info_osdata_command): Make it static.
	* regcache.c (regcache_observer_target_changed): Make it static.
	* reverse.c (_initialize_reverse): Declare before definition.
	* stabsread.c (cleanup_undefined_types_noname)
	(cleanup_undefined_types_1): Make them static.
	* symfile.c (place_section): Make it static.
	* symtab.c (find_pc_sect_psymtab_closer): Make it static.
	* target-descriptions.c (_initialize_target_descriptions): Declare
	before definition.
	* target.c (default_get_ada_task_ptid, find_default_can_async_p)
	(find_default_is_async_p, find_default_supports_non_stop): Make
	them static.
	(target_supports_non_stop): Add prototype.
	(dummy_pid_to_str): Make it static.
	* utils.c (_initialize_utils): Declare before definition.
	* ada-exp.y (_initialize_ada_exp): Declare before definition.
	* solib-svr4.c (HAS_LM_DYNAMIC_FROM_LINK_MAP): Add a prototype.
	* target.h (struct target_ops): Add a prototype to the
	to_can_execute_reverse callback.
	* macroscope.c (_initialize_macroscope): Declare before definition.
	* cp-namespace.c (_initialize_cp_namespace): Declare before definition.
	* python/python.c (_initialize_python): Declare before definition.
	* tui/tui-command.c: Include "tui/tui-command.h".
	* tui/tui-data.c (init_content_element, init_win_info): Make them
	static.
	* tui/tui-disasm.c: Include "tui/tui-disasm.h".
	* tui/tui-interp.c (_initialize_tui_interp): Declare before
	definition.
	* tui/tui-layout.c: Include "tui/tui-layout.h".
	(_initialize_tui_layout): Declare before definition.
	* tui/tui-regs.c: Include "tui/tui-regs.h".
	(tui_display_reg_element_at_line): Make it static.
	(_initialize_tui_regs): Declare before definition.
	* tui/tui-stack.c (_initialize_tui_stack): Declare before
	definition.
	* tui/tui-win.c: Include "tui/tui-win.h".
	(_initialize_tui_win): Declare before definition.
	(tui_sigwinch_handler): Make it static.  Wrap in ifdef SIGWINCH.
	* tui/tui-win.h (tui_sigwinch_handler): Delete declaration.
	(tui_get_cmd_list): Add a prototype.
	* tui/tui-windata.c: Include tui-windata.h.
	* tui/tui-wingeneral.c (box_win): Make it static.
	* cli/cli-logging.c (show_logging_command): Make it static.
	(_initialize_cli_logging): Declare before definition.
	* mi/mi-common.c (_initialize_gdb_mi_common): Declare before
	definition.
@
text
@d8 1
a8 1
This file is part of GDB.
d10 12
a21 14
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor,
Boston, MA 02110-1301, USA.  */
@


1.12
log
@        Updated copyright notices for most files.
@
text
@d45 1
@


1.11
log
@	* cp-name-parser.y: Include defs.h instead of config.h.
	(parse_escape): Rename to ...
	(cp_parse_escape): ... this.
	(yylex): Update.
	(xfree) [TEST_CPNAMES]: New.
@
text
@d3 2
a4 1
   Copyright (C) 2003, 2004, 2005, 2007, 2008 Free Software Foundation, Inc.
@


1.10
log
@	* cp-name-parser.y: Include config.h before system headers.
@
text
@d34 1
a34 1
#include "config.h"
d1465 1
a1465 1
parse_escape (const char **string_ptr)
d1486 1
a1486 1
	    target_char = parse_escape (string_ptr);
d1584 1
a1584 1
	c = parse_escape (&lexptr);
d2087 10
@


1.9
log
@	* buildsym.c (start_subfile): Properly cast sentinel in concat
	call.
	* cp-name-parser.y: Include "config.h".
	* xml-tdesc.c (fetch_xml_from_file): Properly cast sentinel in
	concat call.
	* gdb_select.h: Include sys/time.h if sys/select.h is not
	available.
@
text
@d34 2
a40 1
#include "config.h"
@


1.8
log
@	Updated copyright notices for most files.
@
text
@d39 1
@


1.7
log
@	* cp-name-parser.y (exp1): Add & ( var ) as a reference expression.
	(exp): Remove and document function-like casts.
@
text
@d3 1
a3 1
   Copyright (C) 2003, 2004, 2005, 2007 Free Software Foundation, Inc.
@


1.6
log
@	* cp-support.c: Include "safe-ctype.h".
	(cp_already_canonical): New function.
	(cp_canonicalize_string): Use it.  Return NULL for already canonical
	strings.
	(mangled_name_to_comp): Update call to cp_demangled_name_to_comp.
	(cp_func_name, remove_params): Likewise.
	(cp_find_first_component_aux): Use ISSPACE.
	* cp-support.h (cp_demangled_name_to_comp): Correct comment.  Remove
	MEMORY_P argument.
	* cp-name-parser.y (ALLOC_CHUNK): Define.
	(struct demangle_info): Add PREV and NEXT.  Increase the size of
	COMPS.
	(d_grab): Convert to a function.
	(allocate_info): Rewrite.
	(cp_demangled_name_to_comp): Remove MEMORY argument.  Do not use
	strlen.  Update call to allocate_info.  Do not free it on failure.
	(main): Update calls to cp_demangled_name_to_comp.
	* Makefile.in (cp-support.o): Update.
@
text
@d1014 2
d1071 7
a1077 12
/* Another form of C++-style cast.  "type ( exp1 )" is not allowed (it's too
   ambiguous), but "name ( exp1 )" is.  Because we don't need to support
   function types, we can handle this unambiguously (the use of typespec_2
   prevents a silly, harmless conflict with qualifiers_opt).  This does not
   appear in demangler output so it's not a great loss if we need to
   disable it.  */
exp	:	typespec_2 '(' exp1 ')' %prec UNARY
		{ $$ = fill_comp (DEMANGLE_COMPONENT_UNARY,
				    fill_comp (DEMANGLE_COMPONENT_CAST, $1, NULL),
				    $3);
		}
	;
@


1.5
log
@Copyright updates for 2007.
@
text
@d57 2
d61 2
a62 1
  struct demangle_component comps[1];
d66 23
a88 1
#define d_grab() (&demangle_info->comps[demangle_info->used++])
d1951 18
a1968 13
/* Allocate all the components we'll need to build a tree.  We generally
   allocate too many components, but the extra memory usage doesn't hurt
   because the trees are temporary.  If we start keeping the trees for
   a longer lifetime we'll need to be cleverer.  */
static struct demangle_info *
allocate_info (int comps)
{
  struct demangle_info *ret;

  ret = malloc (sizeof (struct demangle_info)
		+ sizeof (struct demangle_component) * (comps - 1));
  ret->used = 0;
  return ret;
d2008 5
a2012 4
/* Convert a demangled name to a demangle_component tree.  *MEMORY is set to the
   block of used memory that should be freed when finished with the
   tree.  On error, NULL is returned, and an error message will be
   set in *ERRMSG (which does not need to be freed).  */
d2015 1
a2015 2
cp_demangled_name_to_comp (const char *demangled_name, void **memory,
			   const char **errmsg)
a2019 3
  int len = strlen (demangled_name);

  len = len + len / 8;
d2024 1
a2024 1
  demangle_info = allocate_info (len);
a2034 1
      free (demangle_info);
a2037 1
  *memory = demangle_info;
d2091 1
a2091 1
  char *str2, *extra_chars, c;
a2094 1
  void *memory;
d2121 1
a2121 1
	result = cp_demangled_name_to_comp (str2, &memory, &errmsg);
a2129 1
	free (memory);
d2141 1
a2141 1
      result = cp_demangled_name_to_comp (argv[arg], &memory, &errmsg);
a2149 1
      free (memory);
@


1.4
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d3 1
a3 2
   Copyright (C) 2003, 2004, 2005
   Free Software Foundation, Inc.
@


1.3
log
@	* cp-name-parser.y (parse_escape): Revert previous change.  Return
	the input character by default.
@
text
@d3 1
a3 1
   Copyright 2003, 2004, 2005
d22 2
a23 1
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.2
log
@	* MAINTAINERS: Change cris-elf state to non-broken.
	* cp-name-parser.y (parse_escape): Initialize target_char to zero.
@
text
@d1443 1
a1443 1
  int target_char = 0;
d1501 1
a1501 1
	return target_char;
@


1.1
log
@	* cp-names.y: Renamed to ...
	* cp-name-parser.y: ... this.
	* Makefile.in (SFILES, YYFILES, YYOBJ): Rename cp-names.y to
	cp-name-parser.y.
	(test-cp-names.o): Renamed to test-cp-name-parser.o.
	(test-cp-names): Renamed to test-cp-name-parser.
	(clean, local-maintainer-clean): Update.
	(cp-names.o): Renamed to cp-name-parser.o.
@
text
@d1443 1
a1443 1
  int target_char;
@

