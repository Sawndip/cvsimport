head	1.120;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.107
	gdb_7_6-2013-04-26-release:1.107
	gdb_7_6-branch:1.107.0.2
	gdb_7_6-2013-03-12-branchpoint:1.107
	gdb_7_5_1-2012-11-29-release:1.97
	gdb_7_5-2012-08-17-release:1.97
	gdb_7_5-branch:1.97.0.2
	gdb_7_5-2012-07-18-branchpoint:1.97
	gdb_7_4_1-2012-04-26-release:1.90.2.1
	gdb_7_4-2012-01-24-release:1.90.2.1
	gdb_7_4-branch:1.90.0.2
	gdb_7_4-2011-12-13-branchpoint:1.90
	gdb_7_3_1-2011-09-04-release:1.84
	gdb_7_3-2011-07-26-release:1.84
	gdb_7_3-branch:1.84.0.2
	gdb_7_3-2011-04-01-branchpoint:1.84
	gdb_7_2-2010-09-02-release:1.79
	gdb_7_2-branch:1.79.0.2
	gdb_7_2-2010-07-07-branchpoint:1.79
	gdb_7_1-2010-03-18-release:1.76
	gdb_7_1-branch:1.76.0.2
	gdb_7_1-2010-02-18-branchpoint:1.76
	gdb_7_0_1-2009-12-22-release:1.70
	gdb_7_0-2009-10-06-release:1.70
	gdb_7_0-branch:1.70.0.4
	gdb_7_0-2009-09-16-branchpoint:1.70
	arc-sim-20090309:1.58
	msnyder-checkpoint-072509-branch:1.70.0.2
	msnyder-checkpoint-072509-branchpoint:1.70
	arc-insight_6_8-branch:1.58.0.6
	arc-insight_6_8-branchpoint:1.58
	insight_6_8-branch:1.58.0.4
	insight_6_8-branchpoint:1.58
	reverse-20081226-branch:1.64.0.4
	reverse-20081226-branchpoint:1.64
	multiprocess-20081120-branch:1.64.0.2
	multiprocess-20081120-branchpoint:1.64
	reverse-20080930-branch:1.63.0.2
	reverse-20080930-branchpoint:1.63
	reverse-20080717-branch:1.60.0.4
	reverse-20080717-branchpoint:1.60
	msnyder-reverse-20080609-branch:1.60.0.2
	msnyder-reverse-20080609-branchpoint:1.60
	drow-reverse-20070409-branch:1.50.0.2
	drow-reverse-20070409-branchpoint:1.50
	gdb_6_8-2008-03-27-release:1.58
	gdb_6_8-branch:1.58.0.2
	gdb_6_8-2008-02-26-branchpoint:1.58
	gdb_6_7_1-2007-10-29-release:1.54
	gdb_6_7-2007-10-10-release:1.54
	gdb_6_7-branch:1.54.0.2
	gdb_6_7-2007-09-07-branchpoint:1.54
	insight_6_6-20070208-release:1.48
	gdb_6_6-2006-12-18-release:1.48
	gdb_6_6-branch:1.48.0.18
	gdb_6_6-2006-11-15-branchpoint:1.48
	insight_6_5-20061003-release:1.48
	gdb-csl-symbian-6_4_50_20060226-12:1.48
	gdb-csl-sourcerygxx-3_4_4-25:1.46
	nickrob-async-20060828-mergepoint:1.48
	gdb-csl-symbian-6_4_50_20060226-11:1.48
	gdb-csl-sourcerygxx-4_1-17:1.48
	gdb-csl-20060226-branch-local-2:1.48
	gdb-csl-sourcerygxx-4_1-14:1.48
	gdb-csl-sourcerygxx-4_1-13:1.48
	gdb-csl-sourcerygxx-4_1-12:1.48
	gdb-csl-sourcerygxx-3_4_4-21:1.48
	gdb_6_5-20060621-release:1.48
	gdb-csl-sourcerygxx-4_1-9:1.48
	gdb-csl-sourcerygxx-4_1-8:1.48
	gdb-csl-sourcerygxx-4_1-7:1.48
	gdb-csl-arm-2006q1-6:1.48
	gdb-csl-sourcerygxx-4_1-6:1.48
	gdb-csl-symbian-6_4_50_20060226-10:1.48
	gdb-csl-symbian-6_4_50_20060226-9:1.48
	gdb-csl-symbian-6_4_50_20060226-8:1.48
	gdb-csl-coldfire-4_1-11:1.48
	gdb-csl-sourcerygxx-3_4_4-19:1.48
	gdb-csl-coldfire-4_1-10:1.48
	gdb_6_5-branch:1.48.0.16
	gdb_6_5-2006-05-14-branchpoint:1.48
	gdb-csl-sourcerygxx-4_1-5:1.48
	nickrob-async-20060513-branch:1.48.0.14
	nickrob-async-20060513-branchpoint:1.48
	gdb-csl-sourcerygxx-4_1-4:1.48
	msnyder-reverse-20060502-branch:1.48.0.12
	msnyder-reverse-20060502-branchpoint:1.48
	gdb-csl-morpho-4_1-4:1.48
	gdb-csl-sourcerygxx-3_4_4-17:1.48
	readline_5_1-import-branch:1.48.0.10
	readline_5_1-import-branchpoint:1.48
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.48
	gdb-csl-symbian-20060226-branch:1.48.0.8
	gdb-csl-symbian-20060226-branchpoint:1.48
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.48
	msnyder-reverse-20060331-branch:1.48.0.6
	msnyder-reverse-20060331-branchpoint:1.48
	gdb-csl-available-20060303-branch:1.48.0.4
	gdb-csl-available-20060303-branchpoint:1.48
	gdb-csl-20060226-branch:1.48.0.2
	gdb-csl-20060226-branchpoint:1.48
	gdb_6_4-20051202-release:1.46
	msnyder-fork-checkpoint-branch:1.46.0.12
	msnyder-fork-checkpoint-branchpoint:1.46
	gdb-csl-gxxpro-6_3-branch:1.46.0.10
	gdb-csl-gxxpro-6_3-branchpoint:1.46
	gdb_6_4-branch:1.46.0.8
	gdb_6_4-2005-11-01-branchpoint:1.46
	gdb-csl-arm-20051020-branch:1.46.0.6
	gdb-csl-arm-20051020-branchpoint:1.46
	msnyder-tracepoint-checkpoint-branch:1.46.0.4
	msnyder-tracepoint-checkpoint-branchpoint:1.46
	gdb-csl-arm-20050325-2005-q1b:1.46
	gdb-csl-arm-20050325-2005-q1a:1.46
	csl-arm-20050325-branch:1.46.0.2
	csl-arm-20050325-branchpoint:1.46
	gdb-post-i18n-errorwarning-20050211:1.45
	gdb-pre-i18n-errorwarning-20050211:1.44
	gdb_6_3-20041109-release:1.43
	gdb_6_3-branch:1.43.0.2
	gdb_6_3-20041019-branchpoint:1.43
	drow_intercu-merge-20040921:1.43
	drow_intercu-merge-20040915:1.43
	jimb-gdb_6_2-e500-branch:1.40.0.14
	jimb-gdb_6_2-e500-branchpoint:1.40
	gdb_6_2-20040730-release:1.40
	gdb_6_2-branch:1.40.0.10
	gdb_6_2-2004-07-10-gmt-branchpoint:1.40
	gdb_6_1_1-20040616-release:1.40
	gdb_6_1-2004-04-05-release:1.40
	drow_intercu-merge-20040402:1.40
	drow_intercu-merge-20040327:1.40
	ezannoni_pie-20040323-branch:1.40.0.8
	ezannoni_pie-20040323-branchpoint:1.40
	cagney_tramp-20040321-mergepoint:1.40
	cagney_tramp-20040309-branch:1.40.0.6
	cagney_tramp-20040309-branchpoint:1.40
	gdb_6_1-branch:1.40.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.40
	drow_intercu-20040221-branch:1.40.0.2
	drow_intercu-20040221-branchpoint:1.40
	cagney_bfdfile-20040213-branch:1.39.0.2
	cagney_bfdfile-20040213-branchpoint:1.39
	drow-cplus-merge-20040208:1.39
	carlton_dictionary-20040126-merge:1.37
	cagney_bigcore-20040122-branch:1.37.0.2
	cagney_bigcore-20040122-branchpoint:1.37
	drow-cplus-merge-20040113:1.37
	drow-cplus-merge-20031224:1.37
	drow-cplus-merge-20031220:1.37
	carlton_dictionary-20031215-merge:1.37
	drow-cplus-merge-20031214:1.37
	carlton-dictionary-20031111-merge:1.36
	gdb_6_0-2003-10-04-release:1.31.4.1
	kettenis_sparc-20030918-branch:1.34.0.4
	kettenis_sparc-20030918-branchpoint:1.34
	carlton_dictionary-20030917-merge:1.34
	ezannoni_pie-20030916-branchpoint:1.34
	ezannoni_pie-20030916-branch:1.34.0.2
	cagney_x86i386-20030821-branch:1.32.0.2
	cagney_x86i386-20030821-branchpoint:1.32
	carlton_dictionary-20030805-merge:1.32
	carlton_dictionary-20030627-merge:1.31
	gdb_6_0-branch:1.31.0.4
	gdb_6_0-2003-06-23-branchpoint:1.31
	jimb-ppc64-linux-20030613-branch:1.31.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.31
	cagney_convert-20030606-branch:1.28.0.6
	cagney_convert-20030606-branchpoint:1.28
	cagney_writestrings-20030508-branch:1.27.0.20
	cagney_writestrings-20030508-branchpoint:1.27
	jimb-ppc64-linux-20030528-branch:1.28.0.4
	jimb-ppc64-linux-20030528-branchpoint:1.28
	carlton_dictionary-20030523-merge:1.28
	cagney_fileio-20030521-branch:1.28.0.2
	cagney_fileio-20030521-branchpoint:1.28
	kettenis_i386newframe-20030517-mergepoint:1.28
	jimb-ppc64-linux-20030509-branch:1.27.0.18
	jimb-ppc64-linux-20030509-branchpoint:1.27
	kettenis_i386newframe-20030504-mergepoint:1.27
	carlton_dictionary-20030430-merge:1.27
	kettenis_i386newframe-20030419-branch:1.27.0.16
	kettenis_i386newframe-20030419-branchpoint:1.27
	carlton_dictionary-20030416-merge:1.27
	cagney_frameaddr-20030409-mergepoint:1.27
	kettenis_i386newframe-20030406-branch:1.27.0.14
	kettenis_i386newframe-20030406-branchpoint:1.27
	cagney_frameaddr-20030403-branchpoint:1.27
	cagney_frameaddr-20030403-branch:1.27.0.12
	cagney_framebase-20030330-mergepoint:1.27
	cagney_framebase-20030326-branch:1.27.0.10
	cagney_framebase-20030326-branchpoint:1.27
	cagney_lazyid-20030317-branch:1.27.0.8
	cagney_lazyid-20030317-branchpoint:1.27
	kettenis-i386newframe-20030316-mergepoint:1.27
	offbyone-20030313-branch:1.27.0.6
	offbyone-20030313-branchpoint:1.27
	kettenis-i386newframe-20030308-branch:1.27.0.4
	kettenis-i386newframe-20030308-branchpoint:1.27
	carlton_dictionary-20030305-merge:1.27
	cagney_offbyone-20030303-branch:1.27.0.2
	cagney_offbyone-20030303-branchpoint:1.27
	carlton_dictionary-20030207-merge:1.26
	interps-20030203-mergepoint:1.26
	interps-20030202-branch:1.26.0.2
	interps-20030202-branchpoint:1.26
	cagney-unwind-20030108-branch:1.23.0.2
	cagney-unwind-20030108-branchpoint:1.23
	carlton_dictionary-20021223-merge:1.23
	gdb_5_3-2002-12-12-release:1.20
	carlton_dictionary-20021115-merge:1.21
	kseitz_interps-20021105-merge:1.21
	kseitz_interps-20021103-merge:1.21
	drow-cplus-merge-20021020:1.20
	drow-cplus-merge-20021025:1.20
	carlton_dictionary-20021025-merge:1.20
	carlton_dictionary-20021011-merge:1.20
	drow-cplus-branch:1.20.0.10
	drow-cplus-branchpoint:1.20
	kseitz_interps-20020930-merge:1.20
	carlton_dictionary-20020927-merge:1.20
	carlton_dictionary-branch:1.20.0.8
	carlton_dictionary-20020920-branchpoint:1.20
	gdb_5_3-branch:1.20.0.6
	gdb_5_3-2002-09-04-branchpoint:1.20
	kseitz_interps-20020829-merge:1.20
	cagney_sysregs-20020825-branch:1.20.0.4
	cagney_sysregs-20020825-branchpoint:1.20
	readline_4_3-import-branch:1.20.0.2
	readline_4_3-import-branchpoint:1.20
	gdb_5_2_1-2002-07-23-release:1.18
	kseitz_interps-20020528-branch:1.19.0.6
	kseitz_interps-20020528-branchpoint:1.19
	cagney_regbuf-20020515-branch:1.19.0.4
	cagney_regbuf-20020515-branchpoint:1.19
	jimb-macro-020506-branch:1.19.0.2
	jimb-macro-020506-branchpoint:1.19
	gdb_5_2-2002-04-29-release:1.18
	gdb_5_2-branch:1.18.0.2
	gdb_5_2-2002-03-03-branchpoint:1.18
	gdb_5_1_1-2002-01-24-release:1.14
	gdb_5_1_0_1-2002-01-03-release:1.14
	cygnus_cvs_20020108_pre:1.18
	gdb_5_1_0_1-2002-01-03-branchpoint:1.14
	gdb_5_1_0_1-2002-01-03-branch:1.14.0.8
	gdb_5_1-2001-11-21-release:1.14
	gdb_s390-2001-09-26-branch:1.14.0.6
	gdb_s390-2001-09-26-branchpoint:1.14
	gdb_5_1-2001-07-29-branch:1.14.0.4
	gdb_5_1-2001-07-29-branchpoint:1.14
	dberlin-typesystem-branch:1.14.0.2
	dberlin-typesystem-branchpoint:1.14
	gdb-post-ptid_t-2001-05-03:1.14
	gdb-pre-ptid_t-2001-05-03:1.14
	insight-precleanup-2001-01-01:1.11
	gdb-post-protoization-2000-07-29:1.7
	gdb-pre-protoization-2000-07-29:1.6
	gdb-premipsmulti-2000-06-06-branch:1.4.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.4
	gdb-post-params-removal-2000-06-04:1.4
	gdb-pre-params-removal-2000-06-04:1.4
	gdb-post-params-removal-2000-05-28:1.4
	gdb-pre-params-removal-2000-05-28:1.3
	gdb_5_0-2000-05-19-release:1.1.1.9
	gdb_4_18_2-2000-05-18-release:1.1.1.9
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.9
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.9
	gdb_5_0-2000-04-10-branch:1.1.1.9.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.9
	repo-unification-2000-02-06:1.1.1.9
	insight-2000-02-04:1.1.1.9
	gdb-2000-02-04:1.1.1.9
	gdb-2000-02-02:1.1.1.9
	gdb-2000-02-01:1.1.1.9
	gdb-2000-01-31:1.1.1.9
	gdb-2000-01-26:1.1.1.9
	gdb-2000-01-24:1.1.1.9
	gdb-2000-01-17:1.1.1.9
	gdb-2000-01-10:1.1.1.9
	gdb-2000-01-05:1.1.1.9
	gdb-1999-12-21:1.1.1.9
	gdb-1999-12-13:1.1.1.9
	gdb-1999-12-07:1.1.1.9
	gdb-1999-12-06:1.1.1.9
	gdb-1999-11-16:1.1.1.8
	gdb-1999-11-08:1.1.1.8
	gdb-1999-11-01:1.1.1.8
	gdb-1999-10-25:1.1.1.8
	gdb-1999-10-18:1.1.1.8
	gdb-1999-10-11:1.1.1.8
	gdb-1999-10-04:1.1.1.7
	gdb-1999-09-28:1.1.1.6
	gdb-1999-09-21:1.1.1.6
	gdb-1999-09-13:1.1.1.6
	gdb-1999-09-08:1.1.1.6
	gdb-1999-08-30:1.1.1.5
	gdb-1999-08-23:1.1.1.5
	gdb-1999-08-16:1.1.1.5
	gdb-1999-08-09:1.1.1.5
	gdb-1999-08-02:1.1.1.4
	gdb-1999-07-26:1.1.1.3
	gdb-1999-07-19:1.1.1.3
	gdb-1999-07-12:1.1.1.3
	gdb-post-reformat-19990707:1.1.1.3
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.3
	gdb-pre-reformat-19990707:1.1.1.2
	gdb-1999-07-07:1.1.1.2
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.120
date	2013.09.25.22.48.19;	author devans;	state Exp;
branches;
next	1.119;

1.119
date	2013.09.25.22.24.05;	author devans;	state Exp;
branches;
next	1.118;

1.118
date	2013.09.24.13.57.37;	author jkratoch;	state Exp;
branches;
next	1.117;

1.117
date	2013.09.18.17.47.56;	author uweigand;	state Exp;
branches;
next	1.116;

1.116
date	2013.08.26.15.28.28;	author uweigand;	state Exp;
branches;
next	1.115;

1.115
date	2013.07.01.11.28.30;	author palves;	state Exp;
branches;
next	1.114;

1.114
date	2013.05.06.19.38.04;	author tromey;	state Exp;
branches;
next	1.113;

1.113
date	2013.05.06.14.15.50;	author brobecke;	state Exp;
branches;
next	1.112;

1.112
date	2013.04.19.15.33.58;	author palves;	state Exp;
branches;
next	1.111;

1.111
date	2013.04.08.20.13.22;	author tromey;	state Exp;
branches;
next	1.110;

1.110
date	2013.04.08.20.04.42;	author tromey;	state Exp;
branches;
next	1.109;

1.109
date	2013.04.08.19.48.30;	author tromey;	state Exp;
branches;
next	1.108;

1.108
date	2013.03.20.18.33.05;	author tromey;	state Exp;
branches;
next	1.107;

1.107
date	2013.01.21.18.13.14;	author tromey;	state Exp;
branches;
next	1.106;

1.106
date	2013.01.21.18.05.13;	author tromey;	state Exp;
branches;
next	1.105;

1.105
date	2013.01.18.03.09.42;	author qiyao;	state Exp;
branches;
next	1.104;

1.104
date	2013.01.14.10.39.33;	author qiyao;	state Exp;
branches;
next	1.103;

1.103
date	2013.01.01.06.41.29;	author brobecke;	state Exp;
branches;
next	1.102;

1.102
date	2012.12.18.14.52.59;	author brobecke;	state Exp;
branches;
next	1.101;

1.101
date	2012.12.15.13.10.50;	author brobecke;	state Exp;
branches;
next	1.100;

1.100
date	2012.12.12.17.03.03;	author tromey;	state Exp;
branches;
next	1.99;

1.99
date	2012.12.12.16.22.33;	author tromey;	state Exp;
branches;
next	1.98;

1.98
date	2012.11.08.19.52.41;	author tromey;	state Exp;
branches;
next	1.97;

1.97
date	2012.05.18.21.02.51;	author sergiodj;	state Exp;
branches;
next	1.96;

1.96
date	2012.04.28.23.22.13;	author devans;	state Exp;
branches;
next	1.95;

1.95
date	2012.04.27.20.47.56;	author sergiodj;	state Exp;
branches;
next	1.94;

1.94
date	2012.04.18.00.25.09;	author brobecke;	state Exp;
branches;
next	1.93;

1.93
date	2012.04.18.00.24.57;	author brobecke;	state Exp;
branches;
next	1.92;

1.92
date	2012.02.07.04.48.23;	author devans;	state Exp;
branches;
next	1.91;

1.91
date	2012.01.04.08.27.58;	author brobecke;	state Exp;
branches;
next	1.90;

1.90
date	2011.07.27.14.45.37;	author tromey;	state Exp;
branches
	1.90.2.1;
next	1.89;

1.89
date	2011.06.07.12.31.07;	author gingold;	state Exp;
branches;
next	1.88;

1.88
date	2011.05.19.06.54.30;	author teawater;	state Exp;
branches;
next	1.87;

1.87
date	2011.04.19.14.33.09;	author schwab;	state Exp;
branches;
next	1.86;

1.86
date	2011.04.19.14.12.50;	author muller;	state Exp;
branches;
next	1.85;

1.85
date	2011.04.04.14.29.27;	author tromey;	state Exp;
branches;
next	1.84;

1.84
date	2011.03.07.16.17.29;	author tromey;	state Exp;
branches;
next	1.83;

1.83
date	2011.01.12.01.23.29;	author msnyder;	state Exp;
branches;
next	1.82;

1.82
date	2011.01.05.22.22.53;	author msnyder;	state Exp;
branches;
next	1.81;

1.81
date	2011.01.01.15.33.19;	author brobecke;	state Exp;
branches;
next	1.80;

1.80
date	2010.09.30.19.14.30;	author tromey;	state Exp;
branches;
next	1.79;

1.79
date	2010.05.17.18.48.51;	author msnyder;	state Exp;
branches;
next	1.78;

1.78
date	2010.03.10.18.27.00;	author tromey;	state Exp;
branches;
next	1.77;

1.77
date	2010.03.10.18.20.07;	author tromey;	state Exp;
branches;
next	1.76;

1.76
date	2010.02.03.14.13.16;	author gingold;	state Exp;
branches;
next	1.75;

1.75
date	2010.01.19.09.47.47;	author brobecke;	state Exp;
branches;
next	1.74;

1.74
date	2010.01.01.07.31.46;	author brobecke;	state Exp;
branches;
next	1.73;

1.73
date	2009.12.07.09.47.40;	author gingold;	state Exp;
branches;
next	1.72;

1.72
date	2009.12.07.09.36.44;	author gingold;	state Exp;
branches;
next	1.71;

1.71
date	2009.11.16.18.40.23;	author tromey;	state Exp;
branches;
next	1.70;

1.70
date	2009.06.29.13.18.37;	author uweigand;	state Exp;
branches;
next	1.69;

1.69
date	2009.06.17.18.41.50;	author uweigand;	state Exp;
branches;
next	1.68;

1.68
date	2009.05.23.16.17.18;	author jkratoch;	state Exp;
branches;
next	1.67;

1.67
date	2009.03.12.17.56.20;	author brobecke;	state Exp;
branches;
next	1.66;

1.66
date	2009.02.22.01.02.20;	author palves;	state Exp;
branches;
next	1.65;

1.65
date	2009.01.03.05.57.54;	author brobecke;	state Exp;
branches;
next	1.64;

1.64
date	2008.10.01.16.41.27;	author tromey;	state Exp;
branches;
next	1.63;

1.63
date	2008.08.21.21.22.39;	author drow;	state Exp;
branches;
next	1.62;

1.62
date	2008.08.21.18.14.39;	author drow;	state Exp;
branches;
next	1.61;

1.61
date	2008.08.16.08.49.23;	author hilfingr;	state Exp;
branches;
next	1.60;

1.60
date	2008.03.27.12.28.48;	author deuling;	state Exp;
branches;
next	1.59;

1.59
date	2008.03.26.14.53.28;	author uweigand;	state Exp;
branches;
next	1.58;

1.58
date	2008.01.16.11.21.42;	author deuling;	state Exp;
branches;
next	1.57;

1.57
date	2008.01.01.22.53.13;	author drow;	state Exp;
branches;
next	1.56;

1.56
date	2007.10.19.12.23.20;	author uweigand;	state Exp;
branches;
next	1.55;

1.55
date	2007.09.21.18.01.23;	author brobecke;	state Exp;
branches;
next	1.54;

1.54
date	2007.08.23.18.08.47;	author brobecke;	state Exp;
branches;
next	1.53;

1.53
date	2007.06.22.12.27.00;	author uweigand;	state Exp;
branches;
next	1.52;

1.52
date	2007.06.18.15.46.38;	author drow;	state Exp;
branches;
next	1.51;

1.51
date	2007.06.12.15.33.04;	author uweigand;	state Exp;
branches;
next	1.50;

1.50
date	2007.01.09.17.58.59;	author drow;	state Exp;
branches;
next	1.49;

1.49
date	2006.11.28.19.07.50;	author uweigand;	state Exp;
branches;
next	1.48;

1.48
date	2006.01.02.04.31.57;	author jimb;	state Exp;
branches;
next	1.47;

1.47
date	2005.12.17.22.34.03;	author eliz;	state Exp;
branches;
next	1.46;

1.46
date	2005.02.11.18.13.54;	author cagney;	state Exp;
branches;
next	1.45;

1.45
date	2005.02.11.04.06.09;	author cagney;	state Exp;
branches;
next	1.44;

1.44
date	2004.10.23.16.18.09;	author cagney;	state Exp;
branches;
next	1.43;

1.43
date	2004.08.10.23.48.28;	author brobecke;	state Exp;
branches;
next	1.42;

1.42
date	2004.08.10.19.37.47;	author cagney;	state Exp;
branches;
next	1.41;

1.41
date	2004.08.06.20.47.25;	author kettenis;	state Exp;
branches;
next	1.40;

1.40
date	2004.02.14.15.46.33;	author ezannoni;	state Exp;
branches
	1.40.2.1;
next	1.39;

1.39
date	2004.02.07.23.13.47;	author ezannoni;	state Exp;
branches;
next	1.38;

1.38
date	2004.02.07.18.29.54;	author ezannoni;	state Exp;
branches;
next	1.37;

1.37
date	2003.11.23.20.41.17;	author cagney;	state Exp;
branches;
next	1.36;

1.36
date	2003.11.06.02.52.28;	author cagney;	state Exp;
branches;
next	1.35;

1.35
date	2003.10.06.19.27.13;	author cagney;	state Exp;
branches;
next	1.34;

1.34
date	2003.09.16.18.56.35;	author cagney;	state Exp;
branches;
next	1.33;

1.33
date	2003.09.14.16.32.14;	author cagney;	state Exp;
branches;
next	1.32;

1.32
date	2003.07.07.18.13.52;	author brobecke;	state Exp;
branches;
next	1.31;

1.31
date	2003.06.11.23.29.48;	author carlton;	state Exp;
branches
	1.31.4.1;
next	1.30;

1.30
date	2003.06.11.22.27.17;	author carlton;	state Exp;
branches;
next	1.29;

1.29
date	2003.06.06.23.33.00;	author mmitchel;	state Exp;
branches;
next	1.28;

1.28
date	2003.05.14.17.43.20;	author ezannoni;	state Exp;
branches;
next	1.27;

1.27
date	2003.02.25.21.36.21;	author carlton;	state Exp;
branches
	1.27.16.1;
next	1.26;

1.26
date	2003.01.19.04.06.46;	author cagney;	state Exp;
branches;
next	1.25;

1.25
date	2003.01.18.15.55.53;	author cagney;	state Exp;
branches;
next	1.24;

1.24
date	2003.01.14.00.15.05;	author ezannoni;	state Exp;
branches;
next	1.23;

1.23
date	2002.12.17.00.39.08;	author kevinb;	state Exp;
branches;
next	1.22;

1.22
date	2002.12.02.16.45.05;	author brobecke;	state Exp;
branches;
next	1.21;

1.21
date	2002.10.25.22.25.55;	author cagney;	state Exp;
branches;
next	1.20;

1.20
date	2002.07.12.18.30.15;	author kevinb;	state Exp;
branches
	1.20.8.1
	1.20.10.1;
next	1.19;

1.19
date	2002.04.30.00.26.44;	author kevinb;	state Exp;
branches
	1.19.6.1;
next	1.18;

1.18
date	2001.12.02.22.38.23;	author cagney;	state Exp;
branches;
next	1.17;

1.17
date	2001.10.02.02.39.48;	author ezannoni;	state Exp;
branches;
next	1.16;

1.16
date	2001.09.20.03.03.40;	author amodra;	state Exp;
branches;
next	1.15;

1.15
date	2001.09.05.02.13.11;	author ezannoni;	state Exp;
branches;
next	1.14;

1.14
date	2001.05.01.19.36.11;	author nsd;	state Exp;
branches;
next	1.13;

1.13
date	2001.04.12.19.53.09;	author nsd;	state Exp;
branches;
next	1.12;

1.12
date	2001.03.06.08.21.18;	author kevinb;	state Exp;
branches;
next	1.11;

1.11
date	2000.12.15.01.01.51;	author kevinb;	state Exp;
branches;
next	1.10;

1.10
date	2000.11.15.19.58.14;	author kevinb;	state Exp;
branches;
next	1.9;

1.9
date	2000.08.27.22.30.29;	author ezannoni;	state Exp;
branches;
next	1.8;

1.8
date	2000.08.07.15.16.15;	author ezannoni;	state Exp;
branches;
next	1.7;

1.7
date	2000.07.30.01.48.28;	author kevinb;	state Exp;
branches;
next	1.6;

1.6
date	2000.07.07.22.00.09;	author nsd;	state Exp;
branches;
next	1.5;

1.5
date	2000.06.16.21.02.21;	author nsd;	state Exp;
branches;
next	1.4;

1.4
date	2000.05.28.01.12.33;	author kevinb;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.16.04.07.39;	author cagney;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.04.16.52.34;	author ezannoni;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.07;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.90.2.1
date	2012.01.06.04.54.34;	author brobecke;	state Exp;
branches;
next	;

1.40.2.1
date	2004.09.16.17.01.27;	author drow;	state Exp;
branches;
next	;

1.31.4.1
date	2003.07.07.18.15.36;	author brobecke;	state Exp;
branches;
next	;

1.27.16.1
date	2003.05.18.09.44.26;	author kettenis;	state Exp;
branches;
next	;

1.20.8.1
date	2002.09.20.18.52.16;	author carlton;	state Exp;
branches;
next	1.20.8.2;

1.20.8.2
date	2002.11.15.19.19.01;	author carlton;	state Exp;
branches;
next	1.20.8.3;

1.20.8.3
date	2002.12.23.19.38.50;	author carlton;	state Exp;
branches;
next	1.20.8.4;

1.20.8.4
date	2003.02.07.19.17.54;	author carlton;	state Exp;
branches;
next	1.20.8.5;

1.20.8.5
date	2003.03.06.00.56.34;	author carlton;	state Exp;
branches;
next	1.20.8.6;

1.20.8.6
date	2003.05.23.18.40.46;	author carlton;	state Exp;
branches;
next	1.20.8.7;

1.20.8.7
date	2003.06.27.21.50.13;	author carlton;	state Exp;
branches;
next	1.20.8.8;

1.20.8.8
date	2003.09.17.21.28.36;	author carlton;	state Exp;
branches;
next	1.20.8.9;

1.20.8.9
date	2003.11.11.23.51.02;	author carlton;	state Exp;
branches;
next	1.20.8.10;

1.20.8.10
date	2003.12.16.00.00.52;	author carlton;	state Exp;
branches;
next	;

1.20.10.1
date	2003.12.14.20.27.34;	author drow;	state Exp;
branches;
next	1.20.10.2;

1.20.10.2
date	2004.02.09.19.43.49;	author drow;	state Exp;
branches;
next	;

1.19.6.1
date	2002.07.22.21.47.04;	author kseitz;	state Exp;
branches;
next	1.19.6.2;

1.19.6.2
date	2002.11.04.00.17.33;	author ezannoni;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.07;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.07.07.17.23.39;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.07.07.20.11.16;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.08.02.23.46.15;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.08.09.21.34.01;	author jsm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.09.08.23.59.40;	author shebs;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	99.10.05.23.09.03;	author jsm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	99.10.12.04.37.26;	author jsm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	99.12.07.03.56.07;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.120
log
@	* symfile.h (struct sym_fns): Delete member "sym_flavour".
	All uses updated.
	(add_symtab_fns): Update prototype.
	* symfile.c (sym_fns_ptr): Delete.  Replace with ...
	(registered_sym_fns): ... this.
	(symtab_fns): Update.
	(add_symtab_fns): New arg "flavour".  All callers updated.
	(find_sym_fns): Rewrite to use new sym_fns registry.
@
text
@/* Read AIX xcoff symbol tables and convert to internal format, for GDB.
   Copyright (C) 1986-2013 Free Software Foundation, Inc.
   Derived from coffread.c, dbxread.c, and a lot of hacking.
   Contributed by IBM Corporation.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "bfd.h"

#include <sys/types.h>
#include <fcntl.h>
#include <ctype.h>
#include "gdb_string.h"

#ifdef HAVE_SYS_FILE_H
#include <sys/file.h>
#endif
#include "gdb_stat.h"

#include "coff/internal.h"
#include "libcoff.h"		/* FIXME, internal data from BFD */
#include "coff/xcoff.h"
#include "libxcoff.h"
#include "coff/rs6000.h"
#include "xcoffread.h"

#include "symtab.h"
#include "gdbtypes.h"
/* FIXME: ezannoni/2004-02-13 Verify if the include below is really needed.  */
#include "symfile.h"
#include "objfiles.h"
#include "buildsym.h"
#include "stabsread.h"
#include "expression.h"
#include "complaints.h"
#include "psympriv.h"

#include "gdb-stabs.h"

/* For interface with stabsread.c.  */
#include "aout/stab_gnu.h"


/* Key for XCOFF-associated data.  */

static const struct objfile_data *xcoff_objfile_data_key;

/* We put a pointer to this structure in the read_symtab_private field
   of the psymtab.  */

struct symloc
  {

    /* First symbol number for this file.  */

    int first_symnum;

    /* Number of symbols in the section of the symbol table devoted to
       this file's symbols (actually, the section bracketed may contain
       more than just this file's symbols).  If numsyms is 0, the only
       reason for this thing's existence is the dependency list.  Nothing
       else will happen when it is read in.  */

    int numsyms;

    /* Position of the start of the line number information for this
       psymtab.  */
    unsigned int lineno_off;
  };

/* Remember what we deduced to be the source language of this psymtab.  */

static enum language psymtab_language = language_unknown;


/* Simplified internal version of coff symbol table information.  */

struct coff_symbol
  {
    char *c_name;
    int c_symnum;		/* Symbol number of this entry.  */
    int c_naux;			/* 0 if syment only, 1 if syment + auxent.  */
    CORE_ADDR c_value;
    unsigned char c_sclass;
    int c_secnum;
    unsigned int c_type;
  };

/* Last function's saved coff symbol `cs'.  */

static struct coff_symbol fcn_cs_saved;

static bfd *symfile_bfd;

/* Core address of start and end of text of current source file.
   This is calculated from the first function seen after a C_FILE
   symbol.  */


static CORE_ADDR cur_src_end_addr;

/* Core address of the end of the first object file.  */

static CORE_ADDR first_object_file_end;

/* Initial symbol-table-debug-string vector length.  */

#define	INITIAL_STABVECTOR_LENGTH	40

/* Nonzero if within a function (so symbols should be local,
   if nothing says specifically).  */

int within_function;

/* Size of a COFF symbol.  I think it is always 18, so I'm not sure
   there is any reason not to just use a #define, but might as well
   ask BFD for the size and store it here, I guess.  */

static unsigned local_symesz;

struct coff_symfile_info
  {
    file_ptr min_lineno_offset;	/* Where in file lowest line#s are.  */
    file_ptr max_lineno_offset;	/* 1+last byte of line#s in file.  */

    /* Pointer to the string table.  */
    char *strtbl;

    /* Pointer to debug section.  */
    char *debugsec;

    /* Pointer to the a.out symbol table.  */
    char *symtbl;

    /* Number of symbols in symtbl.  */
    int symtbl_num_syms;

    /* Offset in data section to TOC anchor.  */
    CORE_ADDR toc_offset;
  };

/* Convenience macro to access the per-objfile XCOFF data.  */

#define XCOFF_DATA(objfile)						\
  ((struct coff_symfile_info *) objfile_data ((objfile),		\
					      xcoff_objfile_data_key))

/* XCOFF names for dwarf sections.  There is no compressed sections.  */

static const struct dwarf2_debug_sections dwarf2_xcoff_names = {
  { ".dwinfo", NULL },
  { ".dwabrev", NULL },
  { ".dwline", NULL },
  { ".dwloc", NULL },
  { NULL, NULL }, /* debug_macinfo */
  { NULL, NULL }, /* debug_macro */
  { ".dwstr", NULL },
  { ".dwrnges", NULL },
  { NULL, NULL }, /* debug_types */
  { NULL, NULL }, /* debug_addr */
  { ".dwframe", NULL },
  { NULL, NULL }, /* eh_frame */
  { NULL, NULL }, /* gdb_index */
  23
};

static void
bf_notfound_complaint (void)
{
  complaint (&symfile_complaints,
	     _("line numbers off, `.bf' symbol not found"));
}

static void
ef_complaint (int arg1)
{
  complaint (&symfile_complaints,
	     _("Mismatched .ef symbol ignored starting at symnum %d"), arg1);
}

static void
eb_complaint (int arg1)
{
  complaint (&symfile_complaints,
	     _("Mismatched .eb symbol ignored starting at symnum %d"), arg1);
}

static void xcoff_initial_scan (struct objfile *, int);

static void scan_xcoff_symtab (struct objfile *);

static char *xcoff_next_symbol_text (struct objfile *);

static void record_include_begin (struct coff_symbol *);

static void
enter_line_range (struct subfile *, unsigned, unsigned,
		  CORE_ADDR, CORE_ADDR, unsigned *);

static void init_stringtab (bfd *, file_ptr, struct objfile *);

static void xcoff_symfile_init (struct objfile *);

static void xcoff_new_init (struct objfile *);

static void xcoff_symfile_finish (struct objfile *);

static char *coff_getfilename (union internal_auxent *, struct objfile *);

static void read_symbol (struct internal_syment *, int);

static int read_symbol_lineno (int);

static CORE_ADDR read_symbol_nvalue (int);

static struct symbol *process_xcoff_symbol (struct coff_symbol *,
					    struct objfile *);

static void read_xcoff_symtab (struct objfile *, struct partial_symtab *);

#if 0
static void add_stab_to_list (char *, struct pending_stabs **);
#endif

static int compare_lte (const void *, const void *);

static struct linetable *arrange_linetable (struct linetable *);

static void record_include_end (struct coff_symbol *);

static void process_linenos (CORE_ADDR, CORE_ADDR);


/* Translate from a COFF section number (target_index) to a SECT_OFF_*
   code.  */
static int secnum_to_section (int, struct objfile *);
static asection *secnum_to_bfd_section (int, struct objfile *);

struct find_targ_sec_arg
  {
    int targ_index;
    int *resultp;
    asection **bfd_sect;
    struct objfile *objfile;
  };

static void find_targ_sec (bfd *, asection *, void *);

static void
find_targ_sec (bfd *abfd, asection *sect, void *obj)
{
  struct find_targ_sec_arg *args = (struct find_targ_sec_arg *) obj;
  struct objfile *objfile = args->objfile;

  if (sect->target_index == args->targ_index)
    {
      /* This is the section.  Figure out what SECT_OFF_* code it is.  */
      if (bfd_get_section_flags (abfd, sect) & SEC_CODE)
	*args->resultp = SECT_OFF_TEXT (objfile);
      else if (bfd_get_section_flags (abfd, sect) & SEC_LOAD)
	*args->resultp = SECT_OFF_DATA (objfile);
      else
	*args->resultp = gdb_bfd_section_index (abfd, sect);
      *args->bfd_sect = sect;
    }
}

/* Search all BFD sections for the section whose target_index is
   equal to N_SCNUM.  Set *BFD_SECT to that section.  The section's
   associated index in the objfile's section_offset table is also
   stored in *SECNUM.

   If no match is found, *BFD_SECT is set to NULL, and *SECNUM
   is set to the text section's number.  */

static void
xcoff_secnum_to_sections (int n_scnum, struct objfile *objfile,
			  asection **bfd_sect, int *secnum)
{
  struct find_targ_sec_arg args;

  args.targ_index = n_scnum;
  args.resultp = secnum;
  args.bfd_sect = bfd_sect;
  args.objfile = objfile;

  *bfd_sect = NULL;
  *secnum = SECT_OFF_TEXT (objfile);

  bfd_map_over_sections (objfile->obfd, find_targ_sec, &args);
}

/* Return the section number (SECT_OFF_*) that N_SCNUM points to.  */

static int
secnum_to_section (int n_scnum, struct objfile *objfile)
{
  int secnum;
  asection *ignored;

  xcoff_secnum_to_sections (n_scnum, objfile, &ignored, &secnum);
  return secnum;
}

/* Return the BFD section that N_SCNUM points to.  */

static asection *
secnum_to_bfd_section (int n_scnum, struct objfile *objfile)
{
  int ignored;
  asection *bfd_sect;

  xcoff_secnum_to_sections (n_scnum, objfile, &bfd_sect, &ignored);
  return bfd_sect;
}

/* add a given stab string into given stab vector.  */

#if 0

static void
add_stab_to_list (char *stabname, struct pending_stabs **stabvector)
{
  if (*stabvector == NULL)
    {
      *stabvector = (struct pending_stabs *)
	xmalloc (sizeof (struct pending_stabs) +
		 INITIAL_STABVECTOR_LENGTH * sizeof (char *));
      (*stabvector)->count = 0;
      (*stabvector)->length = INITIAL_STABVECTOR_LENGTH;
    }
  else if ((*stabvector)->count >= (*stabvector)->length)
    {
      (*stabvector)->length += INITIAL_STABVECTOR_LENGTH;
      *stabvector = (struct pending_stabs *)
	xrealloc ((char *) *stabvector, sizeof (struct pending_stabs) +
		  (*stabvector)->length * sizeof (char *));
    }
  (*stabvector)->stab[(*stabvector)->count++] = stabname;
}

#endif
/* *INDENT-OFF* */
/* Linenos are processed on a file-by-file basis.

   Two reasons:

   1) xlc (IBM's native c compiler) postpones static function code
   emission to the end of a compilation unit.  This way it can
   determine if those functions (statics) are needed or not, and
   can do some garbage collection (I think).  This makes line
   numbers and corresponding addresses unordered, and we end up
   with a line table like:


   lineno       addr
   foo()          10    0x100
   20   0x200
   30   0x300

   foo3()         70    0x400
   80   0x500
   90   0x600

   static foo2()
   40   0x700
   50   0x800
   60   0x900           

   and that breaks gdb's binary search on line numbers, if the
   above table is not sorted on line numbers.  And that sort
   should be on function based, since gcc can emit line numbers
   like:

   10   0x100   - for the init/test part of a for stmt.
   20   0x200
   30   0x300
   10   0x400   - for the increment part of a for stmt.

   arrange_linetable() will do this sorting.

   2)   aix symbol table might look like:

   c_file               // beginning of a new file
   .bi          // beginning of include file
   .ei          // end of include file
   .bi
   .ei

   basically, .bi/.ei pairs do not necessarily encapsulate
   their scope.  They need to be recorded, and processed later
   on when we come the end of the compilation unit.
   Include table (inclTable) and process_linenos() handle
   that.  */
/* *INDENT-ON* */



/* compare line table entry addresses.  */

static int
compare_lte (const void *lte1p, const void *lte2p)
{
  struct linetable_entry *lte1 = (struct linetable_entry *) lte1p;
  struct linetable_entry *lte2 = (struct linetable_entry *) lte2p;

  return lte1->pc - lte2->pc;
}

/* Given a line table with function entries are marked, arrange its
   functions in ascending order and strip off function entry markers
   and return it in a newly created table.  If the old one is good
   enough, return the old one.  */
/* FIXME: I think all this stuff can be replaced by just passing
   sort_linevec = 1 to end_symtab.  */

static struct linetable *
arrange_linetable (struct linetable *oldLineTb)
{
  int ii, jj, newline,		/* new line count */
    function_count;		/* # of functions */

  struct linetable_entry *fentry;	/* function entry vector */
  int fentry_size;		/* # of function entries */
  struct linetable *newLineTb;	/* new line table */
  int extra_lines = 0;

#define NUM_OF_FUNCTIONS 20

  fentry_size = NUM_OF_FUNCTIONS;
  fentry = (struct linetable_entry *)
    xmalloc (fentry_size * sizeof (struct linetable_entry));

  for (function_count = 0, ii = 0; ii < oldLineTb->nitems; ++ii)
    {
      if (oldLineTb->item[ii].line == 0)
	{			/* Function entry found.  */
	  if (function_count >= fentry_size)
	    {			/* Make sure you have room.  */
	      fentry_size *= 2;
	      fentry = (struct linetable_entry *)
		xrealloc (fentry,
			  fentry_size * sizeof (struct linetable_entry));
	    }
	  fentry[function_count].line = ii;
	  fentry[function_count].pc = oldLineTb->item[ii].pc;
	  ++function_count;

	  /* If the function was compiled with XLC, we may have to add an
             extra line entry later.  Reserve space for that.  */
	  if (ii + 1 < oldLineTb->nitems
	      && oldLineTb->item[ii].pc != oldLineTb->item[ii + 1].pc)
	    extra_lines++;
	}
    }

  if (function_count == 0)
    {
      xfree (fentry);
      return oldLineTb;
    }
  else if (function_count > 1)
    qsort (fentry, function_count,
	   sizeof (struct linetable_entry), compare_lte);

  /* Allocate a new line table.  */
  newLineTb = (struct linetable *)
    xmalloc
    (sizeof (struct linetable) +
    (oldLineTb->nitems - function_count + extra_lines) * sizeof (struct linetable_entry));

  /* If line table does not start with a function beginning, copy up until
     a function begin.  */

  newline = 0;
  if (oldLineTb->item[0].line != 0)
    for (newline = 0;
    newline < oldLineTb->nitems && oldLineTb->item[newline].line; ++newline)
      newLineTb->item[newline] = oldLineTb->item[newline];

  /* Now copy function lines one by one.  */

  for (ii = 0; ii < function_count; ++ii)
    {
      /* If the function was compiled with XLC, we may have to add an
         extra line to cover the function prologue.  */
      jj = fentry[ii].line;
      if (jj + 1 < oldLineTb->nitems
	  && oldLineTb->item[jj].pc != oldLineTb->item[jj + 1].pc)
	{
	  newLineTb->item[newline] = oldLineTb->item[jj];
	  newLineTb->item[newline].line = oldLineTb->item[jj + 1].line;
	  newline++;
	}

      for (jj = fentry[ii].line + 1;
	   jj < oldLineTb->nitems && oldLineTb->item[jj].line != 0;
	   ++jj, ++newline)
	newLineTb->item[newline] = oldLineTb->item[jj];
    }
  xfree (fentry);
  /* The number of items in the line table must include these
     extra lines which were added in case of XLC compiled functions.  */
  newLineTb->nitems = oldLineTb->nitems - function_count + extra_lines;
  return newLineTb;
}

/* include file support: C_BINCL/C_EINCL pairs will be kept in the 
   following `IncludeChain'.  At the end of each symtab (end_symtab),
   we will determine if we should create additional symtab's to
   represent if (the include files.  */


typedef struct _inclTable
{
  char *name;			/* include filename */

  /* Offsets to the line table.  end points to the last entry which is
     part of this include file.  */
  int begin, end;

  struct subfile *subfile;
  unsigned funStartLine;	/* Start line # of its function.  */
}
InclTable;

#define	INITIAL_INCLUDE_TABLE_LENGTH	20
static InclTable *inclTable;	/* global include table */
static int inclIndx;		/* last entry to table */
static int inclLength;		/* table length */
static int inclDepth;		/* nested include depth */

static void allocate_include_entry (void);

static void
record_include_begin (struct coff_symbol *cs)
{
  if (inclDepth)
    {
      /* In xcoff, we assume include files cannot be nested (not in .c files
         of course, but in corresponding .s files.).  */

      /* This can happen with old versions of GCC.
         GCC 2.3.3-930426 does not exhibit this on a test case which
         a user said produced the message for him.  */
      complaint (&symfile_complaints, _("Nested C_BINCL symbols"));
    }
  ++inclDepth;

  allocate_include_entry ();

  inclTable[inclIndx].name = cs->c_name;
  inclTable[inclIndx].begin = cs->c_value;
}

static void
record_include_end (struct coff_symbol *cs)
{
  InclTable *pTbl;

  if (inclDepth == 0)
    {
      complaint (&symfile_complaints, _("Mismatched C_BINCL/C_EINCL pair"));
    }

  allocate_include_entry ();

  pTbl = &inclTable[inclIndx];
  pTbl->end = cs->c_value;

  --inclDepth;
  ++inclIndx;
}

static void
allocate_include_entry (void)
{
  if (inclTable == NULL)
    {
      inclTable = (InclTable *)
	xmalloc (sizeof (InclTable) * INITIAL_INCLUDE_TABLE_LENGTH);
      memset (inclTable,
	      '\0', sizeof (InclTable) * INITIAL_INCLUDE_TABLE_LENGTH);
      inclLength = INITIAL_INCLUDE_TABLE_LENGTH;
      inclIndx = 0;
    }
  else if (inclIndx >= inclLength)
    {
      inclLength += INITIAL_INCLUDE_TABLE_LENGTH;
      inclTable = (InclTable *)
	xrealloc (inclTable, sizeof (InclTable) * inclLength);
      memset (inclTable + inclLength - INITIAL_INCLUDE_TABLE_LENGTH,
	      '\0', sizeof (InclTable) * INITIAL_INCLUDE_TABLE_LENGTH);
    }
}

/* Global variable to pass the psymtab down to all the routines involved
   in psymtab to symtab processing.  */
static struct partial_symtab *this_symtab_psymtab;

/* Objfile related to this_symtab_psymtab; set at the same time.  */
static struct objfile *this_symtab_objfile;

/* given the start and end addresses of a compilation unit (or a csect,
   at times) process its lines and create appropriate line vectors.  */

static void
process_linenos (CORE_ADDR start, CORE_ADDR end)
{
  int offset, ii;
  file_ptr max_offset
    = XCOFF_DATA (this_symtab_objfile)->max_lineno_offset;

  /* subfile structure for the main compilation unit.  */
  struct subfile main_subfile;

  /* In the main source file, any time we see a function entry, we
     reset this variable to function's absolute starting line number.
     All the following line numbers in the function are relative to
     this, and we record absolute line numbers in record_line().  */

  unsigned int main_source_baseline = 0;

  unsigned *firstLine;

  offset =
    ((struct symloc *) this_symtab_psymtab->read_symtab_private)->lineno_off;
  if (offset == 0)
    goto return_after_cleanup;

  memset (&main_subfile, '\0', sizeof (main_subfile));

  if (inclIndx == 0)
    /* All source lines were in the main source file.  None in include
       files.  */

    enter_line_range (&main_subfile, offset, 0, start, end,
		      &main_source_baseline);

  else
    {
      /* There was source with line numbers in include files.  */

      int linesz =
	coff_data (this_symtab_objfile->obfd)->local_linesz;
      main_source_baseline = 0;

      for (ii = 0; ii < inclIndx; ++ii)
	{
	  struct subfile *tmpSubfile;

	  /* If there is main file source before include file, enter it.  */
	  if (offset < inclTable[ii].begin)
	    {
	      enter_line_range
		(&main_subfile, offset, inclTable[ii].begin - linesz,
		 start, 0, &main_source_baseline);
	    }

	  if (strcmp (inclTable[ii].name, get_last_source_file ()) == 0)
	    {
              /* The entry in the include table refers to the main source
                 file.  Add the lines to the main subfile.  */

	      main_source_baseline = inclTable[ii].funStartLine;
	      enter_line_range
		(&main_subfile, inclTable[ii].begin, inclTable[ii].end,
		 start, 0, &main_source_baseline);
	      inclTable[ii].subfile = &main_subfile;
	    }
	  else
	    {
	      /* Have a new subfile for the include file.  */

	      tmpSubfile = inclTable[ii].subfile =
		(struct subfile *) xmalloc (sizeof (struct subfile));

	      memset (tmpSubfile, '\0', sizeof (struct subfile));
	      firstLine = &(inclTable[ii].funStartLine);

	      /* Enter include file's lines now.  */
	      enter_line_range (tmpSubfile, inclTable[ii].begin,
				inclTable[ii].end, start, 0, firstLine);
	    }

	  if (offset <= inclTable[ii].end)
	    offset = inclTable[ii].end + linesz;
	}

      /* All the include files' line have been processed at this point.  Now,
         enter remaining lines of the main file, if any left.  */
      if (offset < max_offset + 1 - linesz)
	{
	  enter_line_range (&main_subfile, offset, 0, start, end,
			    &main_source_baseline);
	}
    }

  /* Process main file's line numbers.  */
  if (main_subfile.line_vector)
    {
      struct linetable *lineTb, *lv;

      lv = main_subfile.line_vector;

      /* Line numbers are not necessarily ordered.  xlc compilation will
         put static function to the end.  */

      lineTb = arrange_linetable (lv);
      if (lv == lineTb)
	{
	  current_subfile->line_vector = (struct linetable *)
	    xrealloc (lv, (sizeof (struct linetable)
			   + lv->nitems * sizeof (struct linetable_entry)));
	}
      else
	{
	  xfree (lv);
	  current_subfile->line_vector = lineTb;
	}

      current_subfile->line_vector_length =
	current_subfile->line_vector->nitems;
    }

  /* Now, process included files' line numbers.  */

  for (ii = 0; ii < inclIndx; ++ii)
    {
      if (inclTable[ii].subfile != ((struct subfile *) &main_subfile)
          && (inclTable[ii].subfile)->line_vector)	/* Useless if!!!
							   FIXMEmgo */
	{
	  struct linetable *lineTb, *lv;

	  lv = (inclTable[ii].subfile)->line_vector;

	  /* Line numbers are not necessarily ordered.  xlc compilation will
	     put static function to the end.  */

	  lineTb = arrange_linetable (lv);

	  push_subfile ();

	  /* For the same include file, we might want to have more than one
	     subfile.  This happens if we have something like:

	     ......
	     #include "foo.h"
	     ......
	     #include "foo.h"
	     ......

	     while foo.h including code in it.  (stupid but possible)
	     Since start_subfile() looks at the name and uses an
	     existing one if finds, we need to provide a fake name and
	     fool it.  */

#if 0
	  start_subfile (inclTable[ii].name, (char *) 0);
#else
	  {
	    /* Pick a fake name that will produce the same results as this
	       one when passed to deduce_language_from_filename.  Kludge on
	       top of kludge.  */
	    char *fakename = strrchr (inclTable[ii].name, '.');

	    if (fakename == NULL)
	      fakename = " ?";
	    start_subfile (fakename, (char *) 0);
	    xfree (current_subfile->name);
	  }
	  current_subfile->name = xstrdup (inclTable[ii].name);
#endif

	  if (lv == lineTb)
	    {
	      current_subfile->line_vector =
		(struct linetable *) xrealloc
		(lv, (sizeof (struct linetable)
		      + lv->nitems * sizeof (struct linetable_entry)));

	    }
	  else
	    {
	      xfree (lv);
	      current_subfile->line_vector = lineTb;
	    }

	  current_subfile->line_vector_length =
	    current_subfile->line_vector->nitems;
	  start_subfile (pop_subfile (), (char *) 0);
	}
    }

return_after_cleanup:

  /* We don't want to keep alloc/free'ing the global include file table.  */
  inclIndx = 0;

  /* Start with a fresh subfile structure for the next file.  */
  memset (&main_subfile, '\0', sizeof (struct subfile));
}

static void
aix_process_linenos (struct objfile *objfile)
{
  /* There is no linenos to read if there are only dwarf info.  */
  if (this_symtab_psymtab == NULL)
    return;

  /* Process line numbers and enter them into line vector.  */
  process_linenos (last_source_start_addr, cur_src_end_addr);
}


/* Enter a given range of lines into the line vector.
   can be called in the following two ways:
   enter_line_range (subfile, beginoffset, endoffset,
                     startaddr, 0, firstLine)  or
   enter_line_range (subfile, beginoffset, 0, 
                     startaddr, endaddr, firstLine)

   endoffset points to the last line table entry that we should pay
   attention to.  */

static void
enter_line_range (struct subfile *subfile, unsigned beginoffset,
		  unsigned endoffset,	/* offsets to line table */
		  CORE_ADDR startaddr,	/* offsets to line table */
		  CORE_ADDR endaddr, unsigned *firstLine)
{
  struct objfile *objfile = this_symtab_objfile;
  struct gdbarch *gdbarch = get_objfile_arch (objfile);
  unsigned int curoffset;
  CORE_ADDR addr;
  void *ext_lnno;
  struct internal_lineno int_lnno;
  unsigned int limit_offset;
  bfd *abfd;
  int linesz;

  if (endoffset == 0 && startaddr == 0 && endaddr == 0)
    return;
  curoffset = beginoffset;
  limit_offset = XCOFF_DATA (objfile)->max_lineno_offset;

  if (endoffset != 0)
    {
      if (endoffset >= limit_offset)
	{
	  complaint (&symfile_complaints,
		     _("Bad line table offset in C_EINCL directive"));
	  return;
	}
      limit_offset = endoffset;
    }
  else
    limit_offset -= 1;

  abfd = objfile->obfd;
  linesz = coff_data (abfd)->local_linesz;
  ext_lnno = alloca (linesz);

  while (curoffset <= limit_offset)
    {
      bfd_seek (abfd, curoffset, SEEK_SET);
      bfd_bread (ext_lnno, linesz, abfd);
      bfd_coff_swap_lineno_in (abfd, ext_lnno, &int_lnno);

      /* Find the address this line represents.  */
      addr = (int_lnno.l_lnno
	      ? int_lnno.l_addr.l_paddr
	      : read_symbol_nvalue (int_lnno.l_addr.l_symndx));
      addr += ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));

      if (addr < startaddr || (endaddr && addr >= endaddr))
	return;

      if (int_lnno.l_lnno == 0)
	{
	  *firstLine = read_symbol_lineno (int_lnno.l_addr.l_symndx);
	  record_line (subfile, 0, gdbarch_addr_bits_remove (gdbarch, addr));
	  --(*firstLine);
	}
      else
	record_line (subfile, *firstLine + int_lnno.l_lnno,
		     gdbarch_addr_bits_remove (gdbarch, addr));
      curoffset += linesz;
    }
}


/* Save the vital information for use when closing off the current file.
   NAME is the file name the symbols came from, START_ADDR is the first
   text address for the file, and SIZE is the number of bytes of text.  */

#define complete_symtab(name, start_addr) {	\
  set_last_source_file (name);			\
  last_source_start_addr = start_addr;		\
}


/* Refill the symbol table input buffer
   and set the variables that control fetching entries from it.
   Reports an error if no data available.
   This function can read past the end of the symbol table
   (into the string table) but this does no harm.  */

/* Create a new minimal symbol (using prim_record_minimal_symbol_and_info).

   Creation of all new minimal symbols should go through this function
   rather than calling the various prim_record_[...] functions in order
   to make sure that all symbol addresses get properly relocated.

   Arguments are:

   NAME - the symbol's name (but if NAME starts with a period, that
   leading period is discarded).
   ADDRESS - the symbol's address, prior to relocation.  This function
      relocates the address before recording the minimal symbol.
   MS_TYPE - the symbol's type.
   N_SCNUM - the symbol's XCOFF section number.
   OBJFILE - the objfile associated with the minimal symbol.  */

static void
record_minimal_symbol (const char *name, CORE_ADDR address,
		       enum minimal_symbol_type ms_type,
		       int n_scnum,
		       struct objfile *objfile)
{
  int section = secnum_to_section (n_scnum, objfile);

  if (name[0] == '.')
    ++name;

  address += ANOFFSET (objfile->section_offsets, section);
  prim_record_minimal_symbol_and_info (name, address, ms_type,
				       secnum_to_section (n_scnum, objfile),
				       objfile);
}

/* xcoff has static blocks marked in `.bs', `.es' pairs.  They cannot be
   nested.  At any given time, a symbol can only be in one static block.
   This is the base address of current static block, zero if non exists.  */

static int static_block_base = 0;

/* Section number for the current static block.  */

static int static_block_section = -1;

/* true if space for symbol name has been allocated.  */

static int symname_alloced = 0;

/* Next symbol to read.  Pointer into raw seething symbol table.  */

static char *raw_symbol;

/* This is the function which stabsread.c calls to get symbol
   continuations.  */

static char *
xcoff_next_symbol_text (struct objfile *objfile)
{
  struct internal_syment symbol;
  char *retval;

  /* FIXME: is this the same as the passed arg?  */
  if (this_symtab_objfile)
    objfile = this_symtab_objfile;

  bfd_coff_swap_sym_in (objfile->obfd, raw_symbol, &symbol);
  if (symbol.n_zeroes)
    {
      complaint (&symfile_complaints, _("Unexpected symbol continuation"));

      /* Return something which points to '\0' and hope the symbol reading
         code does something reasonable.  */
      retval = "";
    }
  else if (symbol.n_sclass & 0x80)
    {
      retval = XCOFF_DATA (objfile)->debugsec + symbol.n_offset;
      raw_symbol += coff_data (objfile->obfd)->local_symesz;
      ++symnum;
    }
  else
    {
      complaint (&symfile_complaints, _("Unexpected symbol continuation"));

      /* Return something which points to '\0' and hope the symbol reading
         code does something reasonable.  */
      retval = "";
    }
  return retval;
}

/* Read symbols for a given partial symbol table.  */

static void
read_xcoff_symtab (struct objfile *objfile, struct partial_symtab *pst)
{
  bfd *abfd = objfile->obfd;
  char *raw_auxptr;		/* Pointer to first raw aux entry for sym.  */
  struct coff_symfile_info *xcoff = XCOFF_DATA (objfile);
  char *strtbl = xcoff->strtbl;
  char *debugsec = xcoff->debugsec;
  const char *debugfmt = bfd_xcoff_is_xcoff64 (abfd) ? "XCOFF64" : "XCOFF";

  struct internal_syment symbol[1];
  union internal_auxent main_aux;
  struct coff_symbol cs[1];
  CORE_ADDR file_start_addr = 0;
  CORE_ADDR file_end_addr = 0;

  int next_file_symnum = -1;
  unsigned int max_symnum;
  int just_started = 1;
  int depth = 0;
  CORE_ADDR fcn_start_addr = 0;

  struct coff_symbol fcn_stab_saved = { 0 };

  /* fcn_cs_saved is global because process_xcoff_symbol needs it.  */
  union internal_auxent fcn_aux_saved = main_aux;
  struct context_stack *new;

  char *filestring = " _start_ ";	/* Name of the current file.  */

  const char *last_csect_name;	/* Last seen csect's name.  */

  this_symtab_psymtab = pst;
  this_symtab_objfile = objfile;

  /* Get the appropriate COFF "constants" related to the file we're
     handling.  */
  local_symesz = coff_data (abfd)->local_symesz;

  set_last_source_file (NULL);
  last_csect_name = 0;

  start_stabs ();
  start_symtab (filestring, (char *) NULL, file_start_addr);
  record_debugformat (debugfmt);
  symnum = ((struct symloc *) pst->read_symtab_private)->first_symnum;
  max_symnum =
    symnum + ((struct symloc *) pst->read_symtab_private)->numsyms;
  first_object_file_end = 0;

  raw_symbol = xcoff->symtbl + symnum * local_symesz;

  while (symnum < max_symnum)
    {
      QUIT;			/* make this command interruptable.  */

      /* READ_ONE_SYMBOL (symbol, cs, symname_alloced); */
      /* read one symbol into `cs' structure.  After processing the
         whole symbol table, only string table will be kept in memory,
         symbol table and debug section of xcoff will be freed.  Thus
         we can mark symbols with names in string table as
         `alloced'.  */
      {
	int ii;

	/* Swap and align the symbol into a reasonable C structure.  */
	bfd_coff_swap_sym_in (abfd, raw_symbol, symbol);

	cs->c_symnum = symnum;
	cs->c_naux = symbol->n_numaux;
	if (symbol->n_zeroes)
	  {
	    symname_alloced = 0;
	    /* We must use the original, unswapped, name here so the name field
	       pointed to by cs->c_name will persist throughout xcoffread.  If
	       we use the new field, it gets overwritten for each symbol.  */
	    cs->c_name = ((struct external_syment *) raw_symbol)->e.e_name;
	    /* If it's exactly E_SYMNMLEN characters long it isn't
	       '\0'-terminated.  */
	    if (cs->c_name[E_SYMNMLEN - 1] != '\0')
	      {
		char *p;

		p = obstack_alloc (&objfile->objfile_obstack, E_SYMNMLEN + 1);
		strncpy (p, cs->c_name, E_SYMNMLEN);
		p[E_SYMNMLEN] = '\0';
		cs->c_name = p;
		symname_alloced = 1;
	      }
	  }
	else if (symbol->n_sclass & 0x80)
	  {
	    cs->c_name = debugsec + symbol->n_offset;
	    symname_alloced = 0;
	  }
	else
	  {
	    /* in string table */
	    cs->c_name = strtbl + (int) symbol->n_offset;
	    symname_alloced = 1;
	  }
	cs->c_value = symbol->n_value;
	cs->c_sclass = symbol->n_sclass;
	cs->c_secnum = symbol->n_scnum;
	cs->c_type = (unsigned) symbol->n_type;

	raw_symbol += local_symesz;
	++symnum;

	/* Save addr of first aux entry.  */
	raw_auxptr = raw_symbol;

	/* Skip all the auxents associated with this symbol.  */
	for (ii = symbol->n_numaux; ii; --ii)
	  {
	    raw_symbol += coff_data (abfd)->local_auxesz;
	    ++symnum;
	  }
      }

      /* if symbol name starts with ".$" or "$", ignore it.  */
      if (cs->c_name[0] == '$'
	  || (cs->c_name[1] == '$' && cs->c_name[0] == '.'))
	continue;

      if (cs->c_symnum == next_file_symnum && cs->c_sclass != C_FILE)
	{
	  if (get_last_source_file ())
	    {
	      pst->symtab = end_symtab (cur_src_end_addr, objfile,
					SECT_OFF_TEXT (objfile));
	      end_stabs ();
	    }

	  start_stabs ();
	  start_symtab ("_globals_", (char *) NULL, (CORE_ADDR) 0);
	  record_debugformat (debugfmt);
	  cur_src_end_addr = first_object_file_end;
	  /* Done with all files, everything from here on is globals.  */
	}

      if ((cs->c_sclass == C_EXT || cs->c_sclass == C_HIDEXT)
	  && cs->c_naux == 1)
	{
	  /* Dealing with a symbol with a csect entry.  */

#define	CSECT(PP) ((PP)->x_csect)
#define	CSECT_LEN(PP) (CSECT(PP).x_scnlen.l)
#define	CSECT_ALIGN(PP) (SMTYP_ALIGN(CSECT(PP).x_smtyp))
#define	CSECT_SMTYP(PP) (SMTYP_SMTYP(CSECT(PP).x_smtyp))
#define	CSECT_SCLAS(PP) (CSECT(PP).x_smclas)

	  /* Convert the auxent to something we can access.  */
	  bfd_coff_swap_aux_in (abfd, raw_auxptr, cs->c_type, cs->c_sclass,
				0, cs->c_naux, &main_aux);

	  switch (CSECT_SMTYP (&main_aux))
	    {

	    case XTY_ER:
	      /* Ignore all external references.  */
	      continue;

	    case XTY_SD:
	      /* A section description.  */
	      {
		switch (CSECT_SCLAS (&main_aux))
		  {

		  case XMC_PR:
		    {

		      /* A program csect is seen.  We have to allocate one
		         symbol table for each program csect.  Normally gdb
		         prefers one symtab for each source file.  In case
		         of AIX, one source file might include more than one
		         [PR] csect, and they don't have to be adjacent in
		         terms of the space they occupy in memory.  Thus, one
		         single source file might get fragmented in the
		         memory and gdb's file start and end address
		         approach does not work!  GCC (and I think xlc) seem
		         to put all the code in the unnamed program csect.  */

		      if (last_csect_name)
			{
			  complete_symtab (filestring, file_start_addr);
			  cur_src_end_addr = file_end_addr;
			  end_symtab (file_end_addr, objfile,
				      SECT_OFF_TEXT (objfile));
			  end_stabs ();
			  start_stabs ();
			  /* Give all csects for this source file the same
			     name.  */
			  start_symtab (filestring, NULL, (CORE_ADDR) 0);
			  record_debugformat (debugfmt);
			}

		      /* If this is the very first csect seen,
		         basically `__start'.  */
		      if (just_started)
			{
			  first_object_file_end
			    = cs->c_value + CSECT_LEN (&main_aux);
			  just_started = 0;
			}

		      file_start_addr =
			cs->c_value + ANOFFSET (objfile->section_offsets,
						SECT_OFF_TEXT (objfile));
		      file_end_addr = file_start_addr + CSECT_LEN (&main_aux);

		      if (cs->c_name && (cs->c_name[0] == '.' || cs->c_name[0] == '@@'))
			last_csect_name = cs->c_name;
		    }
		    continue;

		    /* All other symbols are put into the minimal symbol
		       table only.  */

		  case XMC_RW:
		    continue;

		  case XMC_TC0:
		    continue;

		  case XMC_TC:
		    continue;

		  default:
		    /* Ignore the symbol.  */
		    continue;
		  }
	      }
	      break;

	    case XTY_LD:

	      switch (CSECT_SCLAS (&main_aux))
		{
		case XMC_PR:
		  /* a function entry point.  */
		function_entry_point:

		  fcn_start_addr = cs->c_value;

		  /* save the function header info, which will be used
		     when `.bf' is seen.  */
		  fcn_cs_saved = *cs;
		  fcn_aux_saved = main_aux;
		  continue;

		case XMC_GL:
		  /* shared library function trampoline code entry point.  */
		  continue;

		case XMC_DS:
		  /* The symbols often have the same names as debug symbols for
		     functions, and confuse lookup_symbol.  */
		  continue;

		default:
		  /* xlc puts each variable in a separate csect, so we get
		     an XTY_SD for each variable.  But gcc puts several
		     variables in a csect, so that each variable only gets
		     an XTY_LD.  This will typically be XMC_RW; I suspect
		     XMC_RO and XMC_BS might be possible too.
		     These variables are put in the minimal symbol table
		     only.  */
		  continue;
		}
	      break;

	    case XTY_CM:
	      /* Common symbols are put into the minimal symbol table only.  */
	      continue;

	    default:
	      break;
	    }
	}

      /* If explicitly specified as a function, treat is as one.  This check
	 evaluates to true for @@FIX* bigtoc CSECT symbols, so it must occur
	 after the above CSECT check.  */
      if (ISFCN (cs->c_type) && cs->c_sclass != C_TPDEF)
	{
	  bfd_coff_swap_aux_in (abfd, raw_auxptr, cs->c_type, cs->c_sclass,
				0, cs->c_naux, &main_aux);
	  goto function_entry_point;
	}

      switch (cs->c_sclass)
	{
	case C_FILE:

	  /* c_value field contains symnum of next .file entry in table
	     or symnum of first global after last .file.  */

	  next_file_symnum = cs->c_value;

	  /* Complete symbol table for last object file containing
	     debugging information.  */

	  /* Whether or not there was a csect in the previous file, we
	     have to call `end_stabs' and `start_stabs' to reset
	     type_vector, line_vector, etc. structures.  */

	  complete_symtab (filestring, file_start_addr);
	  cur_src_end_addr = file_end_addr;
	  end_symtab (file_end_addr, objfile, SECT_OFF_TEXT (objfile));
	  end_stabs ();

	  /* XCOFF, according to the AIX 3.2 documentation, puts the
	     filename in cs->c_name.  But xlc 1.3.0.2 has decided to
	     do things the standard COFF way and put it in the auxent.
	     We use the auxent if the symbol is ".file" and an auxent
	     exists, otherwise use the symbol itself.  Simple
	     enough.  */
	  if (!strcmp (cs->c_name, ".file") && cs->c_naux > 0)
	    {
	      bfd_coff_swap_aux_in (abfd, raw_auxptr, cs->c_type, cs->c_sclass,
				    0, cs->c_naux, &main_aux);
	      filestring = coff_getfilename (&main_aux, objfile);
	    }
	  else
	    filestring = cs->c_name;

	  start_stabs ();
	  start_symtab (filestring, (char *) NULL, (CORE_ADDR) 0);
	  record_debugformat (debugfmt);
	  last_csect_name = 0;

	  /* reset file start and end addresses.  A compilation unit
	     with no text (only data) should have zero file
	     boundaries.  */
	  file_start_addr = file_end_addr = 0;
	  break;

	case C_FUN:
	  fcn_stab_saved = *cs;
	  break;

	case C_FCN:
	  if (strcmp (cs->c_name, ".bf") == 0)
	    {
	      CORE_ADDR off = ANOFFSET (objfile->section_offsets,
					SECT_OFF_TEXT (objfile));

	      bfd_coff_swap_aux_in (abfd, raw_auxptr, cs->c_type, cs->c_sclass,
				    0, cs->c_naux, &main_aux);

	      within_function = 1;

	      new = push_context (0, fcn_start_addr + off);

	      new->name = define_symbol
		(fcn_cs_saved.c_value + off,
		 fcn_stab_saved.c_name, 0, 0, objfile);
	      if (new->name != NULL)
		SYMBOL_SECTION (new->name) = SECT_OFF_TEXT (objfile);
	    }
	  else if (strcmp (cs->c_name, ".ef") == 0)
	    {
	      bfd_coff_swap_aux_in (abfd, raw_auxptr, cs->c_type, cs->c_sclass,
				    0, cs->c_naux, &main_aux);

	      /* The value of .ef is the address of epilogue code;
	         not useful for gdb.  */
	      /* { main_aux.x_sym.x_misc.x_lnsz.x_lnno
	         contains number of lines to '}' */

	      if (context_stack_depth <= 0)
		{	/* We attempted to pop an empty context stack.  */
		  ef_complaint (cs->c_symnum);
		  within_function = 0;
		  break;
		}
	      new = pop_context ();
	      /* Stack must be empty now.  */
	      if (context_stack_depth > 0 || new == NULL)
		{
		  ef_complaint (cs->c_symnum);
		  within_function = 0;
		  break;
		}

	      finish_block (new->name, &local_symbols, new->old_blocks,
			    new->start_addr,
			    (fcn_cs_saved.c_value
			     + fcn_aux_saved.x_sym.x_misc.x_fsize
			     + ANOFFSET (objfile->section_offsets,
					 SECT_OFF_TEXT (objfile))),
			    objfile);
	      within_function = 0;
	    }
	  break;

	case C_BSTAT:
	  /* Begin static block.  */
	  {
	    struct internal_syment symbol;

	    read_symbol (&symbol, cs->c_value);
	    static_block_base = symbol.n_value;
	    static_block_section =
	      secnum_to_section (symbol.n_scnum, objfile);
	  }
	  break;

	case C_ESTAT:
	  /* End of static block.  */
	  static_block_base = 0;
	  static_block_section = -1;
	  break;

	case C_ARG:
	case C_REGPARM:
	case C_REG:
	case C_TPDEF:
	case C_STRTAG:
	case C_UNTAG:
	case C_ENTAG:
	  {
	    complaint (&symfile_complaints,
		       _("Unrecognized storage class %d."),
		       cs->c_sclass);
	  }
	  break;

	case C_LABEL:
	case C_NULL:
	  /* Ignore these.  */
	  break;

	case C_HIDEXT:
	case C_STAT:
	  break;

	case C_BINCL:
	  /* beginning of include file */
	  /* In xlc output, C_BINCL/C_EINCL pair doesn't show up in sorted
	     order.  Thus, when wee see them, we might not know enough info
	     to process them.  Thus, we'll be saving them into a table 
	     (inclTable) and postpone their processing.  */

	  record_include_begin (cs);
	  break;

	case C_EINCL:
	  /* End of include file.  */
	  /* See the comment after case C_BINCL.  */
	  record_include_end (cs);
	  break;

	case C_BLOCK:
	  if (strcmp (cs->c_name, ".bb") == 0)
	    {
	      depth++;
	      new = push_context (depth,
				  (cs->c_value
				   + ANOFFSET (objfile->section_offsets,
					       SECT_OFF_TEXT (objfile))));
	    }
	  else if (strcmp (cs->c_name, ".eb") == 0)
	    {
	      if (context_stack_depth <= 0)
		{	/* We attempted to pop an empty context stack.  */
		  eb_complaint (cs->c_symnum);
		  break;
		}
	      new = pop_context ();
	      if (depth-- != new->depth)
		{
		  eb_complaint (cs->c_symnum);
		  break;
		}
	      if (local_symbols && context_stack_depth > 0)
		{
		  /* Make a block for the local symbols within.  */
		  finish_block (new->name, &local_symbols, new->old_blocks,
				new->start_addr,
				(cs->c_value
				 + ANOFFSET (objfile->section_offsets,
					     SECT_OFF_TEXT (objfile))),
				objfile);
		}
	      local_symbols = new->locals;
	    }
	  break;

	default:
	  process_xcoff_symbol (cs, objfile);
	  break;
	}
    }

  if (get_last_source_file ())
    {
      struct symtab *s;

      complete_symtab (filestring, file_start_addr);
      cur_src_end_addr = file_end_addr;
      s = end_symtab (file_end_addr, objfile, SECT_OFF_TEXT (objfile));
      /* When reading symbols for the last C_FILE of the objfile, try
         to make sure that we set pst->symtab to the symtab for the
         file, not to the _globals_ symtab.  I'm not sure whether this
         actually works right or when/if it comes up.  */
      if (pst->symtab == NULL)
	pst->symtab = s;
      end_stabs ();
    }
}

#define	SYMBOL_DUP(SYMBOL1, SYMBOL2)	\
  (SYMBOL2) = (struct symbol *)		\
  	obstack_alloc (&objfile->objfile_obstack, sizeof (struct symbol)); \
  *(SYMBOL2) = *(SYMBOL1);


#define	SYMNAME_ALLOC(NAME, ALLOCED)	\
  ((ALLOCED) ? (NAME) : obstack_copy0 (&objfile->objfile_obstack, \
				       (NAME), strlen (NAME)))


/* process one xcoff symbol.  */

static struct symbol *
process_xcoff_symbol (struct coff_symbol *cs, struct objfile *objfile)
{
  struct symbol onesymbol;
  struct symbol *sym = &onesymbol;
  struct symbol *sym2 = NULL;
  char *name, *pp;

  int sec;
  CORE_ADDR off;

  if (cs->c_secnum < 0)
    {
      /* The value is a register number, offset within a frame, etc.,
         and does not get relocated.  */
      off = 0;
      sec = -1;
    }
  else
    {
      sec = secnum_to_section (cs->c_secnum, objfile);
      off = ANOFFSET (objfile->section_offsets, sec);
    }

  name = cs->c_name;
  if (name[0] == '.')
    ++name;

  initialize_symbol (sym);

  /* default assumptions */
  SYMBOL_VALUE_ADDRESS (sym) = cs->c_value + off;
  SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
  SYMBOL_SECTION (sym) = secnum_to_section (cs->c_secnum, objfile);

  if (ISFCN (cs->c_type))
    {
      /* At this point, we don't know the type of the function.  This
         will be patched with the type from its stab entry later on in
         patch_block_stabs (), unless the file was compiled without -g.  */

      SYMBOL_SET_LINKAGE_NAME (sym, SYMNAME_ALLOC (name, symname_alloced));
      SYMBOL_TYPE (sym) = objfile_type (objfile)->nodebug_text_symbol;

      SYMBOL_ACLASS_INDEX (sym) = LOC_BLOCK;
      SYMBOL_DUP (sym, sym2);

      if (cs->c_sclass == C_EXT)
	add_symbol_to_list (sym2, &global_symbols);
      else if (cs->c_sclass == C_HIDEXT || cs->c_sclass == C_STAT)
	add_symbol_to_list (sym2, &file_symbols);
    }
  else
    {
      /* In case we can't figure out the type, provide default.  */
      SYMBOL_TYPE (sym) = objfile_type (objfile)->nodebug_data_symbol;

      switch (cs->c_sclass)
	{
#if 0
	  /* The values of functions and global symbols are now resolved
	     via the global_sym_chain in stabsread.c.  */
	case C_FUN:
	  if (fcn_cs_saved.c_sclass == C_EXT)
	    add_stab_to_list (name, &global_stabs);
	  else
	    add_stab_to_list (name, &file_stabs);
	  break;

	case C_GSYM:
	  add_stab_to_list (name, &global_stabs);
	  break;
#endif

	case C_BCOMM:
	  common_block_start (cs->c_name, objfile);
	  break;

	case C_ECOMM:
	  common_block_end (objfile);
	  break;

	default:
	  complaint (&symfile_complaints, _("Unexpected storage class: %d"),
		     cs->c_sclass);
	  /* FALLTHROUGH */

	case C_DECL:
	case C_PSYM:
	case C_RPSYM:
	case C_ECOML:
	case C_LSYM:
	case C_RSYM:
	case C_GSYM:

	  {
	    sym = define_symbol (cs->c_value + off, cs->c_name, 0, 0, objfile);
	    if (sym != NULL)
	      {
		SYMBOL_SECTION (sym) = sec;
	      }
	    return sym;
	  }

	case C_STSYM:

	  /* For xlc (not GCC), the 'V' symbol descriptor is used for
	     all statics and we need to distinguish file-scope versus
	     function-scope using within_function.  We do this by
	     changing the string we pass to define_symbol to use 'S'
	     where we need to, which is not necessarily super-clean,
	     but seems workable enough.  */

	  if (*name == ':')
	    return NULL;

	  pp = strchr (name, ':');
	  if (pp == NULL)
	    return NULL;

	  ++pp;
	  if (*pp == 'V' && !within_function)
	    *pp = 'S';
	  sym = define_symbol ((cs->c_value
				+ ANOFFSET (objfile->section_offsets,
					    static_block_section)),
			       cs->c_name, 0, 0, objfile);
	  if (sym != NULL)
	    {
	      SYMBOL_VALUE_ADDRESS (sym) += static_block_base;
	      SYMBOL_SECTION (sym) = static_block_section;
	    }
	  return sym;

	}
    }
  return sym2;
}

/* Extract the file name from the aux entry of a C_FILE symbol.
   Result is in static storage and is only good for temporary use.  */

static char *
coff_getfilename (union internal_auxent *aux_entry, struct objfile *objfile)
{
  static char buffer[BUFSIZ];

  if (aux_entry->x_file.x_n.x_zeroes == 0)
    strcpy (buffer, (XCOFF_DATA (objfile)->strtbl
		     + aux_entry->x_file.x_n.x_offset));
  else
    {
      strncpy (buffer, aux_entry->x_file.x_fname, FILNMLEN);
      buffer[FILNMLEN] = '\0';
    }
  return (buffer);
}

/* Set *SYMBOL to symbol number symno in symtbl.  */
static void
read_symbol (struct internal_syment *symbol, int symno)
{
  struct coff_symfile_info *xcoff = XCOFF_DATA (this_symtab_objfile);
  int nsyms = xcoff->symtbl_num_syms;
  char *stbl = xcoff->symtbl;

  if (symno < 0 || symno >= nsyms)
    {
      complaint (&symfile_complaints, _("Invalid symbol offset"));
      symbol->n_value = 0;
      symbol->n_scnum = -1;
      return;
    }
  bfd_coff_swap_sym_in (this_symtab_objfile->obfd,
			stbl + (symno * local_symesz),
			symbol);
}

/* Get value corresponding to symbol number symno in symtbl.  */

static CORE_ADDR
read_symbol_nvalue (int symno)
{
  struct internal_syment symbol[1];

  read_symbol (symbol, symno);
  return symbol->n_value;
}


/* Find the address of the function corresponding to symno, where
   symno is the symbol pointed to by the linetable.  */

static int
read_symbol_lineno (int symno)
{
  struct objfile *objfile = this_symtab_objfile;
  int xcoff64 = bfd_xcoff_is_xcoff64 (objfile->obfd);

  struct coff_symfile_info *info = XCOFF_DATA (objfile);
  int nsyms = info->symtbl_num_syms;
  char *stbl = info->symtbl;
  char *strtbl = info->strtbl;

  struct internal_syment symbol[1];
  union internal_auxent main_aux[1];

  if (symno < 0)
    {
      bf_notfound_complaint ();
      return 0;
    }

  /* Note that just searching for a short distance (e.g. 50 symbols)
     is not enough, at least in the following case.

     .extern foo
     [many .stabx entries]
     [a few functions, referring to foo]
     .globl foo
     .bf

     What happens here is that the assembler moves the .stabx entries
     to right before the ".bf" for foo, but the symbol for "foo" is before
     all the stabx entries.  See PR gdb/2222.  */

  /* Maintaining a table of .bf entries might be preferable to this search.
     If I understand things correctly it would need to be done only for
     the duration of a single psymtab to symtab conversion.  */
  while (symno < nsyms)
    {
      bfd_coff_swap_sym_in (symfile_bfd,
			    stbl + (symno * local_symesz), symbol);
      if (symbol->n_sclass == C_FCN)
	{
	  char *name = xcoff64 ? strtbl + symbol->n_offset : symbol->n_name;

	  if (strcmp (name, ".bf") == 0)
	    goto gotit;
	}
      symno += symbol->n_numaux + 1;
    }

  bf_notfound_complaint ();
  return 0;

gotit:
  /* Take aux entry and return its lineno.  */
  symno++;
  bfd_coff_swap_aux_in (objfile->obfd, stbl + symno * local_symesz,
			symbol->n_type, symbol->n_sclass,
			0, symbol->n_numaux, main_aux);

  return main_aux->x_sym.x_misc.x_lnsz.x_lnno;
}

/* Support for line number handling.  */

/* This function is called for every section; it finds the outer limits
 * of the line table (minimum and maximum file offset) so that the
 * mainline code can read the whole thing for efficiency.
 */
static void
find_linenos (struct bfd *abfd, struct bfd_section *asect, void *vpinfo)
{
  struct coff_symfile_info *info;
  int size, count;
  file_ptr offset, maxoff;

  count = asect->lineno_count;

  if (strcmp (asect->name, ".text") != 0 || count == 0)
    return;

  size = count * coff_data (abfd)->local_linesz;
  info = (struct coff_symfile_info *) vpinfo;
  offset = asect->line_filepos;
  maxoff = offset + size;

  if (offset < info->min_lineno_offset || info->min_lineno_offset == 0)
    info->min_lineno_offset = offset;

  if (maxoff > info->max_lineno_offset)
    info->max_lineno_offset = maxoff;
}

static void
xcoff_psymtab_to_symtab_1 (struct objfile *objfile, struct partial_symtab *pst)
{
  struct cleanup *old_chain;
  int i;

  if (!pst)
    return;

  if (pst->readin)
    {
      fprintf_unfiltered
	(gdb_stderr, "Psymtab for %s already read in.  Shouldn't happen.\n",
	 pst->filename);
      return;
    }

  /* Read in all partial symtabs on which this one is dependent.  */
  for (i = 0; i < pst->number_of_dependencies; i++)
    if (!pst->dependencies[i]->readin)
      {
	/* Inform about additional files that need to be read in.  */
	if (info_verbose)
	  {
	    fputs_filtered (" ", gdb_stdout);
	    wrap_here ("");
	    fputs_filtered ("and ", gdb_stdout);
	    wrap_here ("");
	    printf_filtered ("%s...", pst->dependencies[i]->filename);
	    wrap_here ("");	/* Flush output */
	    gdb_flush (gdb_stdout);
	  }
	xcoff_psymtab_to_symtab_1 (objfile, pst->dependencies[i]);
      }

  if (((struct symloc *) pst->read_symtab_private)->numsyms != 0)
    {
      /* Init stuff necessary for reading in symbols.  */
      stabsread_init ();
      buildsym_init ();
      old_chain = make_cleanup (really_free_pendings, 0);

      read_xcoff_symtab (objfile, pst);

      do_cleanups (old_chain);
    }

  pst->readin = 1;
}

/* Read in all of the symbols for a given psymtab for real.
   Be verbose about it if the user wants that.  SELF is not NULL.  */

static void
xcoff_read_symtab (struct partial_symtab *self, struct objfile *objfile)
{
  if (self->readin)
    {
      fprintf_unfiltered
	(gdb_stderr, "Psymtab for %s already read in.  Shouldn't happen.\n",
	 self->filename);
      return;
    }

  if (((struct symloc *) self->read_symtab_private)->numsyms != 0
      || self->number_of_dependencies)
    {
      /* Print the message now, before reading the string table,
         to avoid disconcerting pauses.  */
      if (info_verbose)
	{
	  printf_filtered ("Reading in symbols for %s...", self->filename);
	  gdb_flush (gdb_stdout);
	}

      next_symbol_text_func = xcoff_next_symbol_text;

      xcoff_psymtab_to_symtab_1 (objfile, self);

      /* Match with global symbols.  This only needs to be done once,
         after all of the symtabs and dependencies have been read in.   */
      scan_file_globals (objfile);

      /* Finish up the debug error message.  */
      if (info_verbose)
	printf_filtered ("done.\n");
    }
}

static void
xcoff_new_init (struct objfile *objfile)
{
  stabsread_new_init ();
  buildsym_new_init ();
}

/* Do initialization in preparation for reading symbols from OBJFILE.

   We will only be called if this is an XCOFF or XCOFF-like file.
   BFD handles figuring out the format of the file, and code in symfile.c
   uses BFD's determination to vector to us.  */

static void
xcoff_symfile_init (struct objfile *objfile)
{
  struct coff_symfile_info *xcoff;

  /* Allocate struct to keep track of the symfile.  */
  xcoff = XNEW (struct coff_symfile_info);
  set_objfile_data (objfile, xcoff_objfile_data_key, xcoff);

  /* XCOFF objects may be reordered, so set OBJF_REORDERED.  If we
     find this causes a significant slowdown in gdb then we could
     set it in the debug symbol readers only when necessary.  */
  objfile->flags |= OBJF_REORDERED;
}

/* Perform any local cleanups required when we are done with a particular
   objfile.  I.E, we are in the process of discarding all symbol information
   for an objfile, freeing up all memory held for it, and unlinking the
   objfile struct from the global list of known objfiles.  */

static void
xcoff_symfile_finish (struct objfile *objfile)
{
  /* Start with a fresh include table for the next objfile.  */
  if (inclTable)
    {
      xfree (inclTable);
      inclTable = NULL;
    }
  inclIndx = inclLength = inclDepth = 0;

  dwarf2_free_objfile (objfile);
}


static void
init_stringtab (bfd *abfd, file_ptr offset, struct objfile *objfile)
{
  long length;
  int val;
  unsigned char lengthbuf[4];
  char *strtbl;
  struct coff_symfile_info *xcoff = XCOFF_DATA (objfile);

  xcoff->strtbl = NULL;

  if (bfd_seek (abfd, offset, SEEK_SET) < 0)
    error (_("cannot seek to string table in %s: %s"),
	   bfd_get_filename (abfd), bfd_errmsg (bfd_get_error ()));

  val = bfd_bread ((char *) lengthbuf, sizeof lengthbuf, abfd);
  length = bfd_h_get_32 (abfd, lengthbuf);

  /* If no string table is needed, then the file may end immediately
     after the symbols.  Just return with `strtbl' set to NULL.  */

  if (val != sizeof lengthbuf || length < sizeof lengthbuf)
    return;

  /* Allocate string table from objfile_obstack.  We will need this table
     as long as we have its symbol table around.  */

  strtbl = (char *) obstack_alloc (&objfile->objfile_obstack, length);
  xcoff->strtbl = strtbl;

  /* Copy length buffer, the first byte is usually zero and is
     used for stabs with a name length of zero.  */
  memcpy (strtbl, lengthbuf, sizeof lengthbuf);
  if (length == sizeof lengthbuf)
    return;

  val = bfd_bread (strtbl + sizeof lengthbuf, length - sizeof lengthbuf, abfd);

  if (val != length - sizeof lengthbuf)
    error (_("cannot read string table from %s: %s"),
	   bfd_get_filename (abfd), bfd_errmsg (bfd_get_error ()));
  if (strtbl[length - 1] != '\0')
    error (_("bad symbol file: string table "
	     "does not end with null character"));

  return;
}

/* If we have not yet seen a function for this psymtab, this is 0.  If we
   have seen one, it is the offset in the line numbers of the line numbers
   for the psymtab.  */
static unsigned int first_fun_line_offset;

/* Allocate and partially fill a partial symtab.  It will be
   completely filled at the end of the symbol list.

   SYMFILE_NAME is the name of the symbol-file we are reading from, and ADDR
   is the address relative to which its symbols are (incremental) or 0
   (normal).  */

static struct partial_symtab *
xcoff_start_psymtab (struct objfile *objfile,
		     const char *filename, int first_symnum,
		     struct partial_symbol **global_syms,
		     struct partial_symbol **static_syms)
{
  struct partial_symtab *result =
    start_psymtab_common (objfile, objfile->section_offsets,
			  filename,
			  /* We fill in textlow later.  */
			  0,
			  global_syms, static_syms);

  result->read_symtab_private = obstack_alloc (&objfile->objfile_obstack,
					       sizeof (struct symloc));
  ((struct symloc *) result->read_symtab_private)->first_symnum = first_symnum;
  result->read_symtab = xcoff_read_symtab;

  /* Deduce the source language from the filename for this psymtab.  */
  psymtab_language = deduce_language_from_filename (filename);

  return result;
}

/* Close off the current usage of PST.
   Returns PST, or NULL if the partial symtab was empty and thrown away.

   CAPPING_SYMBOL_NUMBER is the end of pst (exclusive).

   INCLUDE_LIST, NUM_INCLUDES, DEPENDENCY_LIST, and NUMBER_DEPENDENCIES
   are the information for includes and dependencies.  */

static struct partial_symtab *
xcoff_end_psymtab (struct objfile *objfile, struct partial_symtab *pst,
		   const char **include_list, int num_includes,
		   int capping_symbol_number,
		   struct partial_symtab **dependency_list,
		   int number_dependencies, int textlow_not_set)
{
  int i;

  if (capping_symbol_number != -1)
    ((struct symloc *) pst->read_symtab_private)->numsyms =
      capping_symbol_number
      - ((struct symloc *) pst->read_symtab_private)->first_symnum;
  ((struct symloc *) pst->read_symtab_private)->lineno_off =
    first_fun_line_offset;
  first_fun_line_offset = 0;
  pst->n_global_syms = objfile->global_psymbols.next
    - (objfile->global_psymbols.list + pst->globals_offset);
  pst->n_static_syms = objfile->static_psymbols.next
    - (objfile->static_psymbols.list + pst->statics_offset);

  pst->number_of_dependencies = number_dependencies;
  if (number_dependencies)
    {
      pst->dependencies = (struct partial_symtab **)
	obstack_alloc (&objfile->objfile_obstack,
		    number_dependencies * sizeof (struct partial_symtab *));
      memcpy (pst->dependencies, dependency_list,
	      number_dependencies * sizeof (struct partial_symtab *));
    }
  else
    pst->dependencies = 0;

  for (i = 0; i < num_includes; i++)
    {
      struct partial_symtab *subpst =
	allocate_psymtab (include_list[i], objfile);

      subpst->section_offsets = pst->section_offsets;
      subpst->read_symtab_private = obstack_alloc (&objfile->objfile_obstack,
						   sizeof (struct symloc));
      ((struct symloc *) subpst->read_symtab_private)->first_symnum = 0;
      ((struct symloc *) subpst->read_symtab_private)->numsyms = 0;
      subpst->textlow = 0;
      subpst->texthigh = 0;

      /* We could save slight bits of space by only making one of these,
         shared by the entire set of include files.  FIXME-someday.  */
      subpst->dependencies = (struct partial_symtab **)
	obstack_alloc (&objfile->objfile_obstack,
		       sizeof (struct partial_symtab *));
      subpst->dependencies[0] = pst;
      subpst->number_of_dependencies = 1;

      subpst->globals_offset =
	subpst->n_global_syms =
	subpst->statics_offset =
	subpst->n_static_syms = 0;

      subpst->readin = 0;
      subpst->symtab = 0;
      subpst->read_symtab = pst->read_symtab;
    }

  sort_pst_symbols (objfile, pst);

  if (num_includes == 0
      && number_dependencies == 0
      && pst->n_global_syms == 0
      && pst->n_static_syms == 0)
    {
      /* Throw away this psymtab, it's empty.  We can't deallocate it, since
         it is on the obstack, but we can forget to chain it on the list.  */
      /* Empty psymtabs happen as a result of header files which don't have
         any symbols in them.  There can be a lot of them.  */

      discard_psymtab (objfile, pst);

      /* Indicate that psymtab was thrown away.  */
      pst = (struct partial_symtab *) NULL;
    }
  return pst;
}

/* Swap raw symbol at *RAW and put the name in *NAME, the symbol in
   *SYMBOL, the first auxent in *AUX.  Advance *RAW and *SYMNUMP over
   the symbol and its auxents.  */

static void
swap_sym (struct internal_syment *symbol, union internal_auxent *aux,
	  const char **name, char **raw, unsigned int *symnump,
	  struct objfile *objfile)
{
  bfd_coff_swap_sym_in (objfile->obfd, *raw, symbol);
  if (symbol->n_zeroes)
    {
      /* If it's exactly E_SYMNMLEN characters long it isn't
         '\0'-terminated.  */
      if (symbol->n_name[E_SYMNMLEN - 1] != '\0')
	{
	  /* FIXME: wastes memory for symbols which we don't end up putting
	     into the minimal symbols.  */
	  char *p;

	  p = obstack_alloc (&objfile->objfile_obstack, E_SYMNMLEN + 1);
	  strncpy (p, symbol->n_name, E_SYMNMLEN);
	  p[E_SYMNMLEN] = '\0';
	  *name = p;
	}
      else
	/* Point to the unswapped name as that persists as long as the
	   objfile does.  */
	*name = ((struct external_syment *) *raw)->e.e_name;
    }
  else if (symbol->n_sclass & 0x80)
    {
      *name = XCOFF_DATA (objfile)->debugsec + symbol->n_offset;
    }
  else
    {
      *name = XCOFF_DATA (objfile)->strtbl + symbol->n_offset;
    }
  ++*symnump;
  *raw += coff_data (objfile->obfd)->local_symesz;
  if (symbol->n_numaux > 0)
    {
      bfd_coff_swap_aux_in (objfile->obfd, *raw, symbol->n_type,
			    symbol->n_sclass, 0, symbol->n_numaux, aux);

      *symnump += symbol->n_numaux;
      *raw += coff_data (objfile->obfd)->local_symesz * symbol->n_numaux;
    }
}

static void
function_outside_compilation_unit_complaint (const char *arg1)
{
  complaint (&symfile_complaints,
	     _("function `%s' appears to be defined "
	       "outside of all compilation units"),
	     arg1);
}

static void
scan_xcoff_symtab (struct objfile *objfile)
{
  struct gdbarch *gdbarch = get_objfile_arch (objfile);
  CORE_ADDR toc_offset = 0;	/* toc offset value in data section.  */
  const char *filestring = NULL;

  const char *namestring;
  int past_first_source_file = 0;
  bfd *abfd;
  asection *bfd_sect;
  unsigned int nsyms;

  /* Current partial symtab */
  struct partial_symtab *pst;

  /* List of current psymtab's include files.  */
  const char **psymtab_include_list;
  int includes_allocated;
  int includes_used;

  /* Index within current psymtab dependency list.  */
  struct partial_symtab **dependency_list;
  int dependencies_used, dependencies_allocated;

  char *sraw_symbol;
  struct internal_syment symbol;
  union internal_auxent main_aux[5];
  unsigned int ssymnum;

  const char *last_csect_name = NULL; /* Last seen csect's name and value.  */
  CORE_ADDR last_csect_val = 0;
  int last_csect_sec = 0;
  int misc_func_recorded = 0;	/* true if any misc. function.  */
  int textlow_not_set = 1;

  pst = (struct partial_symtab *) 0;

  includes_allocated = 30;
  includes_used = 0;
  psymtab_include_list = (const char **) alloca (includes_allocated *
						 sizeof (const char *));

  dependencies_allocated = 30;
  dependencies_used = 0;
  dependency_list =
    (struct partial_symtab **) alloca (dependencies_allocated *
				       sizeof (struct partial_symtab *));

  set_last_source_file (NULL);

  abfd = objfile->obfd;
  next_symbol_text_func = xcoff_next_symbol_text;

  sraw_symbol = XCOFF_DATA (objfile)->symtbl;
  nsyms = XCOFF_DATA (objfile)->symtbl_num_syms;
  ssymnum = 0;
  while (ssymnum < nsyms)
    {
      int sclass;

      QUIT;

      bfd_coff_swap_sym_in (abfd, sraw_symbol, &symbol);
      sclass = symbol.n_sclass;

      switch (sclass)
	{
	case C_EXT:
	case C_HIDEXT:
	  {
	    /* The CSECT auxent--always the last auxent.  */
	    union internal_auxent csect_aux;
	    unsigned int symnum_before = ssymnum;

	    swap_sym (&symbol, &main_aux[0], &namestring, &sraw_symbol,
		      &ssymnum, objfile);
	    if (symbol.n_numaux > 1)
	      {
		bfd_coff_swap_aux_in
		  (objfile->obfd,
		   sraw_symbol - coff_data (abfd)->local_symesz,
		   symbol.n_type,
		   symbol.n_sclass,
		   symbol.n_numaux - 1,
		   symbol.n_numaux,
		   &csect_aux);
	      }
	    else
	      csect_aux = main_aux[0];

	    /* If symbol name starts with ".$" or "$", ignore it.  */
	    if (namestring[0] == '$'
		|| (namestring[0] == '.' && namestring[1] == '$'))
	      break;

	    switch (csect_aux.x_csect.x_smtyp & 0x7)
	      {
	      case XTY_SD:
		switch (csect_aux.x_csect.x_smclas)
		  {
		  case XMC_PR:
		    if (last_csect_name)
		      {
			/* If no misc. function recorded in the last
			   seen csect, enter it as a function.  This
			   will take care of functions like strcmp()
			   compiled by xlc.  */

			if (!misc_func_recorded)
			  {
			    record_minimal_symbol
			      (last_csect_name, last_csect_val,
			       mst_text, last_csect_sec, objfile);
			    misc_func_recorded = 1;
			  }

			if (pst != NULL)
			  {
			    /* We have to allocate one psymtab for
			       each program csect, because their text
			       sections need not be adjacent.  */
			    xcoff_end_psymtab
			      (objfile, pst, psymtab_include_list,
			       includes_used, symnum_before, dependency_list,
			       dependencies_used, textlow_not_set);
			    includes_used = 0;
			    dependencies_used = 0;
			    /* Give all psymtabs for this source file the same
			       name.  */
			    pst = xcoff_start_psymtab
			      (objfile,
			       filestring,
			       symnum_before,
			       objfile->global_psymbols.next,
			       objfile->static_psymbols.next);
			  }
		      }
		    /* Activate the misc_func_recorded mechanism for
		       compiler- and linker-generated CSECTs like ".strcmp"
		       and "@@FIX1".  */ 
		    if (namestring && (namestring[0] == '.'
				       || namestring[0] == '@@'))
		      {
			last_csect_name = namestring;
			last_csect_val = symbol.n_value;
			last_csect_sec = symbol.n_scnum;
		      }
		    if (pst != NULL)
		      {
			CORE_ADDR highval =
			  symbol.n_value + csect_aux.x_csect.x_scnlen.l;

			if (highval > pst->texthigh)
			  pst->texthigh = highval;
			if (pst->textlow == 0 || symbol.n_value < pst->textlow)
			  pst->textlow = symbol.n_value;
		      }
		    misc_func_recorded = 0;
		    break;

		  case XMC_RW:
		  case XMC_TD:
		    /* Data variables are recorded in the minimal symbol
		       table, except for section symbols.  */
		    if (*namestring != '.')
		      record_minimal_symbol
			(namestring, symbol.n_value,
			 sclass == C_HIDEXT ? mst_file_data : mst_data,
			 symbol.n_scnum, objfile);
		    break;

		  case XMC_TC0:
		    if (toc_offset)
		      warning (_("More than one XMC_TC0 symbol found."));
		    toc_offset = symbol.n_value;

		    /* Make TOC offset relative to start address of
		       section.  */
		    bfd_sect = secnum_to_bfd_section (symbol.n_scnum, objfile);
		    if (bfd_sect)
		      toc_offset -= bfd_section_vma (objfile->obfd, bfd_sect);
		    break;

		  case XMC_TC:
		    /* These symbols tell us where the TOC entry for a
		       variable is, not the variable itself.  */
		    break;

		  default:
		    break;
		  }
		break;

	      case XTY_LD:
		switch (csect_aux.x_csect.x_smclas)
		  {
		  case XMC_PR:
		    /* A function entry point.  */

		    if (first_fun_line_offset == 0 && symbol.n_numaux > 1)
		      first_fun_line_offset =
			main_aux[0].x_sym.x_fcnary.x_fcn.x_lnnoptr;
		      {
			record_minimal_symbol
			  (namestring, symbol.n_value,
			   sclass == C_HIDEXT ? mst_file_text : mst_text,
			   symbol.n_scnum, objfile);
			misc_func_recorded = 1;
		      }
		    break;

		  case XMC_GL:
		    /* shared library function trampoline code entry
		       point.  */

		    /* record trampoline code entries as
		       mst_solib_trampoline symbol.  When we lookup mst
		       symbols, we will choose mst_text over
		       mst_solib_trampoline.  */
		    record_minimal_symbol
		      (namestring, symbol.n_value,
		       mst_solib_trampoline, symbol.n_scnum, objfile);
		    misc_func_recorded = 1;
		    break;

		  case XMC_DS:
		    /* The symbols often have the same names as
		       debug symbols for functions, and confuse
		       lookup_symbol.  */
		    break;

		  default:

		    /* xlc puts each variable in a separate csect,
		       so we get an XTY_SD for each variable.  But
		       gcc puts several variables in a csect, so
		       that each variable only gets an XTY_LD.  We
		       still need to record them.  This will
		       typically be XMC_RW; I suspect XMC_RO and
		       XMC_BS might be possible too.  */
		    if (*namestring != '.')
		      record_minimal_symbol
			(namestring, symbol.n_value,
			 sclass == C_HIDEXT ? mst_file_data : mst_data,
			 symbol.n_scnum, objfile);
		    break;
		  }
		break;

	      case XTY_CM:
		switch (csect_aux.x_csect.x_smclas)
		  {
		  case XMC_RW:
		  case XMC_BS:
		    /* Common variables are recorded in the minimal symbol
		       table, except for section symbols.  */
		    if (*namestring != '.')
		      record_minimal_symbol
			(namestring, symbol.n_value,
			 sclass == C_HIDEXT ? mst_file_bss : mst_bss,
			 symbol.n_scnum, objfile);
		    break;
		  }
		break;

	      default:
		break;
	      }
	  }
	  break;
	case C_FILE:
	  {
	    unsigned int symnum_before;

	    symnum_before = ssymnum;
	    swap_sym (&symbol, &main_aux[0], &namestring, &sraw_symbol,
		      &ssymnum, objfile);

	    /* See if the last csect needs to be recorded.  */

	    if (last_csect_name && !misc_func_recorded)
	      {
		/* If no misc. function recorded in the last seen csect, enter
		   it as a function.  This will take care of functions like
		   strcmp() compiled by xlc.  */

		record_minimal_symbol (last_csect_name, last_csect_val,
				       mst_text, last_csect_sec, objfile);
		misc_func_recorded = 1;
	      }

	    if (pst)
	      {
		xcoff_end_psymtab (objfile, pst, psymtab_include_list,
				   includes_used, symnum_before,
				   dependency_list, dependencies_used,
				   textlow_not_set);
		includes_used = 0;
		dependencies_used = 0;
	      }
	    first_fun_line_offset = 0;

	    /* XCOFF, according to the AIX 3.2 documentation, puts the
	       filename in cs->c_name.  But xlc 1.3.0.2 has decided to
	       do things the standard COFF way and put it in the auxent.
	       We use the auxent if the symbol is ".file" and an auxent
	       exists, otherwise use the symbol itself.  */
	    if (!strcmp (namestring, ".file") && symbol.n_numaux > 0)
	      {
		filestring = coff_getfilename (&main_aux[0], objfile);
	      }
	    else
	      filestring = namestring;

	    pst = xcoff_start_psymtab (objfile,
				       filestring,
				       symnum_before,
				       objfile->global_psymbols.next,
				       objfile->static_psymbols.next);
	    last_csect_name = NULL;
	  }
	  break;

	default:
	  {
	    complaint (&symfile_complaints,
		       _("Storage class %d not recognized during scan"),
		       sclass);
	  }
	  /* FALLTHROUGH */

	  /* C_FCN is .bf and .ef symbols.  I think it is sufficient
	     to handle only the C_FUN and C_EXT.  */
	case C_FCN:

	case C_BSTAT:
	case C_ESTAT:
	case C_ARG:
	case C_REGPARM:
	case C_REG:
	case C_TPDEF:
	case C_STRTAG:
	case C_UNTAG:
	case C_ENTAG:
	case C_LABEL:
	case C_NULL:

	  /* C_EINCL means we are switching back to the main file.  But there
	     is no reason to care; the only thing we want to know about
	     includes is the names of all the included (.h) files.  */
	case C_EINCL:

	case C_BLOCK:

	  /* I don't think C_STAT is used in xcoff; C_HIDEXT appears to be
	     used instead.  */
	case C_STAT:

	  /* I don't think the name of the common block (as opposed to the
	     variables within it) is something which is user visible
	     currently.  */
	case C_BCOMM:
	case C_ECOMM:

	case C_PSYM:
	case C_RPSYM:

	  /* I think we can ignore C_LSYM; types on xcoff seem to use C_DECL
	     so C_LSYM would appear to be only for locals.  */
	case C_LSYM:

	case C_AUTO:
	case C_RSYM:
	  {
	    /* We probably could save a few instructions by assuming that
	       C_LSYM, C_PSYM, etc., never have auxents.  */
	    int naux1 = symbol.n_numaux + 1;

	    ssymnum += naux1;
	    sraw_symbol += bfd_coff_symesz (abfd) * naux1;
	  }
	  break;

	case C_BINCL:
	  {
	    /* Mark down an include file in the current psymtab.  */
	    enum language tmp_language;

	    swap_sym (&symbol, &main_aux[0], &namestring, &sraw_symbol,
		      &ssymnum, objfile);

	    tmp_language = deduce_language_from_filename (namestring);

	    /* Only change the psymtab's language if we've learned
	       something useful (eg. tmp_language is not language_unknown).
	       In addition, to match what start_subfile does, never change
	       from C++ to C.  */
	    if (tmp_language != language_unknown
		&& (tmp_language != language_c
		    || psymtab_language != language_cplus))
	      psymtab_language = tmp_language;

	    /* In C++, one may expect the same filename to come round many
	       times, when code is coming alternately from the main file
	       and from inline functions in other files.  So I check to see
	       if this is a file we've seen before -- either the main
	       source file, or a previously included file.

	       This seems to be a lot of time to be spending on N_SOL, but
	       things like "break c-exp.y:435" need to work (I
	       suppose the psymtab_include_list could be hashed or put
	       in a binary tree, if profiling shows this is a major hog).  */
	    if (pst && strcmp (namestring, pst->filename) == 0)
	      continue;

	    {
	      int i;

	      for (i = 0; i < includes_used; i++)
		if (strcmp (namestring, psymtab_include_list[i]) == 0)
		  {
		    i = -1;
		    break;
		  }
	      if (i == -1)
		continue;
	    }
	    psymtab_include_list[includes_used++] = namestring;
	    if (includes_used >= includes_allocated)
	      {
		const char **orig = psymtab_include_list;

		psymtab_include_list = (const char **)
		  alloca ((includes_allocated *= 2) *
			  sizeof (const char *));
		memcpy (psymtab_include_list, orig,
			includes_used * sizeof (const char *));
	      }
	    continue;
	  }
	case C_FUN:
	  /* The value of the C_FUN is not the address of the function (it
	     appears to be the address before linking), but as long as it
	     is smaller than the actual address, then find_pc_partial_function
	     will use the minimal symbols instead.  I hope.  */

	case C_GSYM:
	case C_ECOML:
	case C_DECL:
	case C_STSYM:
	  {
	    char *p;

	    swap_sym (&symbol, &main_aux[0], &namestring, &sraw_symbol,
		      &ssymnum, objfile);

	    p = strchr (namestring, ':');
	    if (!p)
	      continue;			/* Not a debugging symbol.   */

	    /* Main processing section for debugging symbols which
	       the initial read through the symbol tables needs to worry
	       about.  If we reach this point, the symbol which we are
	       considering is definitely one we are interested in.
	       p must also contain the (valid) index into the namestring
	       which indicates the debugging type symbol.  */

	    switch (p[1])
	      {
	      case 'S':
		symbol.n_value += ANOFFSET (objfile->section_offsets,
					    SECT_OFF_DATA (objfile));

		if (gdbarch_static_transform_name_p (gdbarch))
		  namestring = gdbarch_static_transform_name
				 (gdbarch, namestring);

		add_psymbol_to_list (namestring, p - namestring, 1,
				     VAR_DOMAIN, LOC_STATIC,
				     &objfile->static_psymbols,
				     0, symbol.n_value,
				     psymtab_language, objfile);
		continue;

	      case 'G':
		symbol.n_value += ANOFFSET (objfile->section_offsets,
					    SECT_OFF_DATA (objfile));
		/* The addresses in these entries are reported to be
		   wrong.  See the code that reads 'G's for symtabs.  */
		add_psymbol_to_list (namestring, p - namestring, 1,
				     VAR_DOMAIN, LOC_STATIC,
				     &objfile->global_psymbols,
				     0, symbol.n_value,
				     psymtab_language, objfile);
		continue;

	      case 'T':
		/* When a 'T' entry is defining an anonymous enum, it
		   may have a name which is the empty string, or a
		   single space.  Since they're not really defining a
		   symbol, those shouldn't go in the partial symbol
		   table.  We do pick up the elements of such enums at
		   'check_enum:', below.  */
		if (p >= namestring + 2
		    || (p == namestring + 1
			&& namestring[0] != ' '))
		  {
		    add_psymbol_to_list (namestring, p - namestring, 1,
					 STRUCT_DOMAIN, LOC_TYPEDEF,
					 &objfile->static_psymbols,
					 symbol.n_value, 0,
					 psymtab_language, objfile);
		    if (p[2] == 't')
		      {
			/* Also a typedef with the same name.  */
			add_psymbol_to_list (namestring, p - namestring, 1,
					     VAR_DOMAIN, LOC_TYPEDEF,
					     &objfile->static_psymbols,
					     symbol.n_value, 0,
					     psymtab_language, objfile);
			p += 1;
		      }
		  }
		goto check_enum;

	      case 't':
		if (p != namestring)	/* a name is there, not just :T...  */
		  {
		    add_psymbol_to_list (namestring, p - namestring, 1,
					 VAR_DOMAIN, LOC_TYPEDEF,
					 &objfile->static_psymbols,
					 symbol.n_value, 0,
					 psymtab_language, objfile);
		  }
	      check_enum:
		/* If this is an enumerated type, we need to
		   add all the enum constants to the partial symbol
		   table.  This does not cover enums without names, e.g.
		   "enum {a, b} c;" in C, but fortunately those are
		   rare.  There is no way for GDB to find those from the
		   enum type without spending too much time on it.  Thus
		   to solve this problem, the compiler needs to put out the
		   enum in a nameless type.  GCC2 does this.  */

		/* We are looking for something of the form
		   <name> ":" ("t" | "T") [<number> "="] "e"
		   {<constant> ":" <value> ","} ";".  */

		/* Skip over the colon and the 't' or 'T'.  */
		p += 2;
		/* This type may be given a number.  Also, numbers can come
		   in pairs like (0,26).  Skip over it.  */
		while ((*p >= '0' && *p <= '9')
		       || *p == '(' || *p == ',' || *p == ')'
		       || *p == '=')
		  p++;

		if (*p++ == 'e')
		  {
		    /* The aix4 compiler emits extra crud before the
		       members.  */
		    if (*p == '-')
		      {
			/* Skip over the type (?).  */
			while (*p != ':')
			  p++;

			/* Skip over the colon.  */
			p++;
		      }

		    /* We have found an enumerated type.  */
		    /* According to comments in read_enum_type
		       a comma could end it instead of a semicolon.
		       I don't know where that happens.
		       Accept either.  */
		    while (*p && *p != ';' && *p != ',')
		      {
			char *q;

			/* Check for and handle cretinous dbx symbol name
			   continuation!  */
			if (*p == '\\' || (*p == '?' && p[1] == '\0'))
			  p = next_symbol_text (objfile);

			/* Point to the character after the name
			   of the enum constant.  */
			for (q = p; *q && *q != ':'; q++)
			  ;
			/* Note that the value doesn't matter for
			   enum constants in psymtabs, just in symtabs.  */
			add_psymbol_to_list (p, q - p, 1,
					     VAR_DOMAIN, LOC_CONST,
					     &objfile->static_psymbols, 0,
					     0, psymtab_language, objfile);
			/* Point past the name.  */
			p = q;
			/* Skip over the value.  */
			while (*p && *p != ',')
			  p++;
			/* Advance past the comma.  */
			if (*p)
			  p++;
		      }
		  }
		continue;

	      case 'c':
		/* Constant, e.g. from "const" in Pascal.  */
		add_psymbol_to_list (namestring, p - namestring, 1,
				     VAR_DOMAIN, LOC_CONST,
				     &objfile->static_psymbols, symbol.n_value,
				     0, psymtab_language, objfile);
		continue;

	      case 'f':
		if (! pst)
		  {
		    int name_len = p - namestring;
		    char *name = xmalloc (name_len + 1);

		    memcpy (name, namestring, name_len);
		    name[name_len] = '\0';
		    function_outside_compilation_unit_complaint (name);
		    xfree (name);
		  }
		symbol.n_value += ANOFFSET (objfile->section_offsets,
					    SECT_OFF_TEXT (objfile));
		add_psymbol_to_list (namestring, p - namestring, 1,
				     VAR_DOMAIN, LOC_BLOCK,
				     &objfile->static_psymbols,
				     0, symbol.n_value,
				     psymtab_language, objfile);
		continue;

		/* Global functions were ignored here, but now they
		   are put into the global psymtab like one would expect.
		   They're also in the minimal symbol table.  */
	      case 'F':
		if (! pst)
		  {
		    int name_len = p - namestring;
		    char *name = xmalloc (name_len + 1);

		    memcpy (name, namestring, name_len);
		    name[name_len] = '\0';
		    function_outside_compilation_unit_complaint (name);
		    xfree (name);
		  }

		/* We need only the minimal symbols for these
		   loader-generated definitions.  Keeping the global
		   symbols leads to "in psymbols but not in symbols"
		   errors.  */
		if (strncmp (namestring, "@@FIX", 4) == 0)
		  continue;

		symbol.n_value += ANOFFSET (objfile->section_offsets,
					    SECT_OFF_TEXT (objfile));
		add_psymbol_to_list (namestring, p - namestring, 1,
				     VAR_DOMAIN, LOC_BLOCK,
				     &objfile->global_psymbols,
				     0, symbol.n_value,
				     psymtab_language, objfile);
		continue;

		/* Two things show up here (hopefully); static symbols of
		   local scope (static used inside braces) or extensions
		   of structure symbols.  We can ignore both.  */
	      case 'V':
	      case '(':
	      case '0':
	      case '1':
	      case '2':
	      case '3':
	      case '4':
	      case '5':
	      case '6':
	      case '7':
	      case '8':
	      case '9':
	      case '-':
	      case '#':		/* For symbol identification (used in
				   live ranges).  */
		continue;

	      case ':':
		/* It is a C++ nested symbol.  We don't need to record it
		   (I don't think); if we try to look up foo::bar::baz,
		   then symbols for the symtab containing foo should get
		   read in, I think.  */
		/* Someone says sun cc puts out symbols like
		   /foo/baz/maclib::/usr/local/bin/maclib,
		   which would get here with a symbol type of ':'.  */
		continue;

	      default:
		/* Unexpected symbol descriptor.  The second and
		   subsequent stabs of a continued stab can show up
		   here.  The question is whether they ever can mimic
		   a normal stab--it would be nice if not, since we
		   certainly don't want to spend the time searching to
		   the end of every string looking for a
		   backslash.  */

		complaint (&symfile_complaints,
			   _("unknown symbol descriptor `%c'"), p[1]);

		/* Ignore it; perhaps it is an extension that we don't
		   know about.  */
		continue;
	      }
	  }
	}
    }

  if (pst)
    {
      xcoff_end_psymtab (objfile, pst, psymtab_include_list, includes_used,
			 ssymnum, dependency_list,
			 dependencies_used, textlow_not_set);
    }

  /* Record the toc offset value of this symbol table into objfile
     structure.  If no XMC_TC0 is found, toc_offset should be zero.
     Another place to obtain this information would be file auxiliary
     header.  */

  XCOFF_DATA (objfile)->toc_offset = toc_offset;
}

/* Return the toc offset value for a given objfile.  */

CORE_ADDR
xcoff_get_toc_offset (struct objfile *objfile)
{
  if (objfile)
    return XCOFF_DATA (objfile)->toc_offset;
  return 0;
}

/* Scan and build partial symbols for a symbol file.
   We have been initialized by a call to dbx_symfile_init, which 
   put all the relevant info into a "struct dbx_symfile_info",
   hung off the objfile structure.

   SECTION_OFFSETS contains offsets relative to which the symbols in the
   various sections are (depending where the sections were actually
   loaded).  */

static void
xcoff_initial_scan (struct objfile *objfile, int symfile_flags)
{
  bfd *abfd;
  int val;
  struct cleanup *back_to;
  int num_symbols;		/* # of symbols */
  file_ptr symtab_offset;	/* symbol table and */
  file_ptr stringtab_offset;	/* string table file offsets */
  struct coff_symfile_info *info;
  const char *name;
  unsigned int size;

  info = XCOFF_DATA (objfile);
  symfile_bfd = abfd = objfile->obfd;
  name = objfile_name (objfile);

  num_symbols = bfd_get_symcount (abfd);	/* # of symbols */
  symtab_offset = obj_sym_filepos (abfd);	/* symbol table file offset */
  stringtab_offset = symtab_offset +
    num_symbols * coff_data (abfd)->local_symesz;

  info->min_lineno_offset = 0;
  info->max_lineno_offset = 0;
  bfd_map_over_sections (abfd, find_linenos, info);

  if (num_symbols > 0)
    {
      /* Read the string table.  */
      init_stringtab (abfd, stringtab_offset, objfile);

      /* Read the .debug section, if present.  */
      {
	struct bfd_section *secp;
	bfd_size_type length;
	bfd_byte *debugsec = NULL;

	secp = bfd_get_section_by_name (abfd, ".debug");
	if (secp)
	  {
	    length = bfd_section_size (abfd, secp);
	    if (length)
	      {
		debugsec = obstack_alloc (&objfile->objfile_obstack, length);

		if (!bfd_get_full_section_contents (abfd, secp, &debugsec))
		  {
		    error (_("Error reading .debug section of `%s': %s"),
			   name, bfd_errmsg (bfd_get_error ()));
		  }
	      }
	  }
	info->debugsec = (char *) debugsec;
      }
    }

  /* Read the symbols.  We keep them in core because we will want to
     access them randomly in read_symbol*.  */
  val = bfd_seek (abfd, symtab_offset, SEEK_SET);
  if (val < 0)
    error (_("Error reading symbols from %s: %s"),
	   name, bfd_errmsg (bfd_get_error ()));
  size = coff_data (abfd)->local_symesz * num_symbols;
  info->symtbl = obstack_alloc (&objfile->objfile_obstack, size);
  info->symtbl_num_syms = num_symbols;

  val = bfd_bread (info->symtbl, size, abfd);
  if (val != size)
    perror_with_name (_("reading symbol table"));

  /* If we are reinitializing, or if we have never loaded syms yet, init.  */
  if (objfile->global_psymbols.size == 0 && objfile->static_psymbols.size == 0)
    /* I'm not sure how how good num_symbols is; the rule of thumb in
       init_psymbol_list was developed for a.out.  On the one hand,
       num_symbols includes auxents.  On the other hand, it doesn't
       include N_SLINE.  */
    init_psymbol_list (objfile, num_symbols);

  free_pending_blocks ();
  back_to = make_cleanup (really_free_pendings, 0);

  init_minimal_symbol_collection ();
  make_cleanup_discard_minimal_symbols ();

  /* Now that the symbol table data of the executable file are all in core,
     process them and define symbols accordingly.  */

  scan_xcoff_symtab (objfile);

  /* Install any minimal symbols that have been collected as the current
     minimal symbols for this objfile.  */

  install_minimal_symbols (objfile);

  /* DWARF2 sections.  */

  if (dwarf2_has_info (objfile, &dwarf2_xcoff_names))
    dwarf2_build_psymtabs (objfile);

  dwarf2_build_frame_info (objfile);

  do_cleanups (back_to);
}

static void
xcoff_symfile_offsets (struct objfile *objfile,
		       const struct section_addr_info *addrs)
{
  const char *first_section_name;

  default_symfile_offsets (objfile, addrs);

  /* Oneof the weird side-effects of default_symfile_offsets is that
     it sometimes sets some section indices to zero for sections that,
     in fact do not exist. See the body of default_symfile_offsets
     for more info on when that happens. Undo that, as this then allows
     us to test whether the associated section exists or not, and then
     access it quickly (without searching it again).  */

  if (objfile->num_sections == 0)
    return; /* Is that even possible?  Better safe than sorry.  */

  first_section_name
    = bfd_section_name (objfile->obfd, objfile->sections[0].the_bfd_section);

  if (objfile->sect_index_text == 0
      && strcmp (first_section_name, ".text") != 0)
    objfile->sect_index_text = -1;

  if (objfile->sect_index_data == 0
      && strcmp (first_section_name, ".data") != 0)
    objfile->sect_index_data = -1;

  if (objfile->sect_index_bss == 0
      && strcmp (first_section_name, ".bss") != 0)
    objfile->sect_index_bss = -1;

  if (objfile->sect_index_rodata == 0
      && strcmp (first_section_name, ".rodata") != 0)
    objfile->sect_index_rodata = -1;
}

/* Register our ability to parse symbols for xcoff BFD files.  */

static const struct sym_fns xcoff_sym_fns =
{

  /* It is possible that coff and xcoff should be merged as
     they do have fundamental similarities (for example, the extra storage
     classes used for stabs could presumably be recognized in any COFF file).
     However, in addition to obvious things like all the csect hair, there are
     some subtler differences between xcoffread.c and coffread.c, notably
     the fact that coffread.c has no need to read in all the symbols, but
     xcoffread.c reads all the symbols and does in fact randomly access them
     (in C_BSTAT and line number processing).  */

  xcoff_new_init,		/* init anything gbl to entire symtab */
  xcoff_symfile_init,		/* read initial info, setup for sym_read() */
  xcoff_initial_scan,		/* read a symbol file into symtab */
  NULL,				/* sym_read_psymbols */
  xcoff_symfile_finish,		/* finished with file, cleanup */
  xcoff_symfile_offsets,	/* xlate offsets ext->int form */
  default_symfile_segments,	/* Get segment information from a file.  */
  aix_process_linenos,
  default_symfile_relocate,	/* Relocate a debug section.  */
  NULL,				/* sym_probe_fns */
  &psym_functions
};

/* Same as xcoff_get_n_import_files, but for core files.  */

static int
xcoff_get_core_n_import_files (bfd *abfd)
{
  asection *sect = bfd_get_section_by_name (abfd, ".ldinfo");
  gdb_byte buf[4];
  file_ptr offset = 0;
  int n_entries = 0;

  if (sect == NULL)
    return -1;  /* Not a core file.  */

  for (offset = 0; offset < bfd_get_section_size (sect);)
    {
      int next;

      n_entries++;

      if (!bfd_get_section_contents (abfd, sect, buf, offset, 4))
	return -1;
      next = bfd_get_32 (abfd, buf);
      if (next == 0)
	break;  /* This is the last entry.  */
      offset += next;
    }

  /* Return the number of entries, excluding the first one, which is
     the path to the executable that produced this core file.  */
  return n_entries - 1;
}

/* Return the number of import files (shared libraries) that the given
   BFD depends on.  Return -1 if this number could not be computed.  */

int
xcoff_get_n_import_files (bfd *abfd)
{
  asection *sect = bfd_get_section_by_name (abfd, ".loader");
  gdb_byte buf[4];
  int l_nimpid;

  /* If the ".loader" section does not exist, the objfile is probably
     not an executable.  Might be a core file...  */
  if (sect == NULL)
    return xcoff_get_core_n_import_files (abfd);

  /* The number of entries in the Import Files Table is stored in
     field l_nimpid.  This field is always at offset 16, and is
     always 4 bytes long.  Read those 4 bytes.  */

  if (!bfd_get_section_contents (abfd, sect, buf, 16, 4))
    return -1;
  l_nimpid = bfd_get_32 (abfd, buf);

  /* By convention, the first entry is the default LIBPATH value
     to be used by the system loader, so it does not count towards
     the number of import files.  */
  return l_nimpid - 1;
}

/* Free the per-objfile xcoff data.  */

static void
xcoff_free_info (struct objfile *objfile, void *arg)
{
  xfree (arg);
}

/* Provide a prototype to silence -Wmissing-prototypes.  */
extern initialize_file_ftype _initialize_xcoffread;

void
_initialize_xcoffread (void)
{
  add_symtab_fns (bfd_target_xcoff_flavour, &xcoff_sym_fns);

  xcoff_objfile_data_key = register_objfile_data_with_cleanup (NULL,
							       xcoff_free_info);
}
@


1.119
log
@	* symfile.h (struct sym_fns): Add "objfile" argument to
	sym_read_linetable.  All uses updated.
@
text
@a3106 2
  bfd_target_xcoff_flavour,

d3195 1
a3195 1
  add_symtab_fns (&xcoff_sym_fns);
@


1.118
log
@Code cleanup: Add objfile_name accessor

gdb/
2013-09-24  Jan Kratochvil  <jan.kratochvil@@redhat.com>

	Code cleanup: Add objfile_name accessor function.
	* ada-lang.c (is_known_support_routine): Use objfile_name.
	* auto-load.c (source_gdb_script_for_objfile)
	(auto_load_objfile_script): Likewise.
	* coffread.c (coff_symtab_read, read_one_sym): Likewise.
	* dbxread.c (dbx_symfile_read): Likewise.
	* dwarf2-frame.c (dwarf2_build_frame_info): Likewise.
	* dwarf2loc.c (locexpr_describe_location_piece): Likewise.
	* dwarf2read.c (dwarf2_get_dwz_file, dwarf2_read_index)
	(dw2_symtab_iter_next, dw2_expand_symtabs_matching)
	(lookup_dwp_signatured_type, lookup_dwo_unit)
	(dwarf2_build_psymtabs_hard, scan_partial_symbols, process_queue)
	(fixup_go_packaging, process_imported_unit_die, dwarf2_physname)
	(read_import_statement, create_dwo_cu, open_and_init_dwp_file)
	(lookup_dwo_cutu, read_call_site_scope, dwarf2_ranges_read)
	(dwarf2_record_block_ranges, read_common_block, read_typedef)
	(read_subrange_type, load_partial_dies, read_partial_die)
	(read_addr_index_1, read_str_index, dwarf_decode_lines_1)
	(die_containing_type, build_error_marker_type, lookup_die_type)
	(follow_die_ref_or_sig, follow_die_ref, dwarf2_fetch_die_loc_sect_off)
	(dwarf2_fetch_constant_bytes, follow_die_sig, get_signatured_type)
	(get_DW_AT_signature_type, write_psymtabs_to_index)
	(save_gdb_index_command): Likewise.
	* elfread.c (find_separate_debug_file_by_buildid, elf_symfile_read):
	Likewise.
	* expprint.c (dump_subexp_body_standard): Likewise.
	* gdbtypes.c (type_name_no_tag_or_error): Likewise.
	* jit.c (jit_object_close_impl): Use the objfile field name renamed to
	original_name.
	* linux-thread-db.c (try_thread_db_load_from_pdir_1): New variable
	obj_name, use objfile_name for it, use the variable.
	(try_thread_db_load_from_pdir, has_libpthread, thread_db_new_objfile):
	Use objfile_name.
	* machoread.c (macho_symtab_read, macho_check_dsym)
	(macho_symfile_relocate): Likewise.
	* maint.c (maintenance_translate_address): Likewise.
	* minidebug.c (find_separate_debug_file_in_section): Likewise.
	* minsyms.c (install_minimal_symbols): Likewise.
	* objfiles.c (allocate_objfile): Use the objfile field name renamed to
	original_name.
	(filter_overlapping_sections): Use objfile_name.
	(objfile_name): New function.
	* objfiles.h (struct objfile): Rename field name to original_name.
	(objfile_name): New prototype.
	* printcmd.c (sym_info, address_info): Use objfile_name.
	* probe.c (parse_probes, collect_probes, compare_probes)
	(info_probes_for_ops): Likewise.
	* progspace.c (clone_program_space): Likewise.
	* psymtab.c (require_partial_symbols, dump_psymtab, allocate_psymtab)
	(maintenance_info_psymtabs): Likewise.
	* python/py-auto-load.c (gdbpy_load_auto_script_for_objfile)
	(source_section_scripts): Likewise.
	* python/py-objfile.c (objfpy_get_filename): Likewise.
	* python/py-progspace.c (pspy_get_filename): Likewise.
	* solib-aix.c (solib_aix_get_toc_value): Likewise.
	* solib-som.c (match_main, som_solib_section_offsets): Likewise.
	* solib.c (solib_read_symbols): Likewise.
	* stabsread.c (scan_file_globals): Likewise.
	* stap-probe.c (handle_stap_probe): Likewise.
	* symfile.c (symbol_file_clear, separate_debug_file_exists)
	(find_separate_debug_file_by_debuglink): Likewise.
	(reread_symbols): Likewise.  Use the objfile field name renamed to
	original_name.
	(allocate_symtab): Use objfile_name.
	* symmisc.c (print_symbol_bcache_statistics, print_objfile_statistics)
	(dump_objfile, dump_msymbols, dump_symtab_1)
	(maintenance_print_msymbols, maintenance_print_objfiles)
	(maintenance_info_symtabs, maintenance_check_symtabs): Likewise.
	* target.c (target_translate_tls_address, target_info): Likewise.
	* xcoffread.c (xcoff_initial_scan): Make variable name const.  Use
	objfile_name.
@
text
@d820 1
a820 1
aix_process_linenos (void)
@


1.117
log
@2013-09-18  Raunaq Bathija  <raunaq12@@in.ibm.com>
	    Ulrich Weigand  <uweigand@@de.ibm.com>

	* xcoffread.c (struct coff_symbol): Use CORE_ADDR as type
	of c_value member.
	(read_xcoff_symtab): Use CORE_ADDR as type of fcn_start_addr.
@
text
@d2961 1
a2961 1
  char *name;
d2966 1
a2966 1
  name = objfile->name;
@


1.116
log
@2013-08-26  Raunaq Bathija  <raunaq12@@in.ibm.com>
	    Ulrich Weigand  <uweigand@@de.ibm.com>

	* xcoffread.c (arrange_linetable): Add fix to correctly handle
	line tables generated by XLC compiled binaries.
@
text
@d97 1
a97 1
    long c_value;
d1036 1
a1036 1
  int fcn_start_addr = 0;
@


1.115
log
@Normalize on PATH_MAX instead of MAXPATHLEN throughout.

With the pathmax gnulib module in place, we can use PATH_MAX
consistently throughout, instead of the current mixbag of PATH_MAX and
MAXPATHLEN uses.  It's no longer necessary to include sys/param.h
(supposedly, I can't check all ports touched here) for MAXPATHLEN.

Don't remove sys/param.h from GDB's configure.ac, as later tests in
the file use HAVE_SYS_PARAM_H checks.

Tested on x86_64 Fedora 17.

Also cross-built for --host=i686-w64-mingw32, and --host=i586-pc-msdosdjgpp.

gdb/
2013-07-01  Pedro Alves  <palves@@redhat.com>

	* defs.h: Include "pathmax.h".
	* utils.c: Don't include sys/param.h.
	(gdb_realpath): Remove code that checks for MAXPATHLEN.
	* solib-ia64-hpux.c (ia64_hpux_handle_load_event): Use PATH_MAX
	instead of MAXPATHLEN.
	* solib-sunos.c: Don't include sys/param.h.
	* xcoffread.c: Don't include sys/param.h.
	* bsd-kvm.c: Don't include sys/param.h.
	* darwin-nat.c: Don't include sys/param.h.
	(darwin_pid_to_exec_file): Use PATH_MAX instead of MAXPATHLEN.
	* darwin-nat-info.c: Don't include sys/param.h.
	* fbsd-nat.c (fbsd_pid_to_exec_file): Use PATH_MAX instead of
	MAXPATHLEN.
	* i386obsd-nat.c: Don't include sys/param.h.
	* inf-child.c: Don't include sys/param.h.
	(inf_child_fileio_readlink): Use PATH_MAX instead of MAXPATHLEN.
	* linux-fork.c: Don't include sys/param.h.
	(fork_save_infrun_state): Use PATH_MAX instead of MAXPATHLEN.
	* linux-nat.c: Don't include sys/param.h.
	(linux_child_pid_to_exec_file, linux_proc_pending_signals)
	(linux_proc_pending_signals): Use PATH_MAX instead of MAXPATHLEN.
	* m68klinux-nat.c: Don't include sys/param.h.
	* nbsd-nat.c: Don't include sys/param.h.
	(nbsd_pid_to_exec_file): Use PATH_MAX instead of MAXPATHLEN.
	* ppc-linux-nat.c: Don't include sys/param.h.
	* rs6000-nat.c: Don't include sys/param.h.
	* spu-linux-nat.c. Don't include sys/param.h.
	* windows-nat.c: Don't include sys/param.h.
	* xtensa-linux-nat.c: Don't include sys/param.h.
	* config/i386/nm-fbsd.h: Don't include sys/param.h.

gdb/gdbserver/
2013-07-01  Pedro Alves  <palves@@redhat.com>

	* server.h: Include "pathmax.h".
	* linux-low.c: Don't include sys/param.h.
	(linux_pid_exe_is_elf_64_file): Use PATH_MAX instead of
	MAXPATHLEN.
	* win32-low.c: Don't include sys/param.h.
	(win32_create_inferior): Use PATH_MAX instead of MAXPATHLEN.
@
text
@d440 1
d462 6
d484 1
a484 1
    (oldLineTb->nitems - function_count) * sizeof (struct linetable_entry));
d499 11
d516 3
a518 1
  newLineTb->nitems = oldLineTb->nitems - function_count;
@


1.114
log
@	* somread.c (som_symfile_offsets): Add 'const' to addrs.
	* machoread.c (macho_symfile_offsets): Add 'const' to addrs.
	* xcoffread.c (xcoff_symfile_offsets): Add 'const' to addrs.
	Remove declaration.
@
text
@a28 1
#include <sys/param.h>
@


1.113
log
@Reimplement shared library support on ppc-aix...

... using the target_so_ops framework.

gdb/ChangeLog:

        * target.h (TARGET_OBJECT_AIX_LIBRARIES): New target_object enum.
        * features/library-list-aix.dtd: New file.
        * solib-aix.h, solib-aix.c: New file.
        * rs6000-aix-tdep.c: #include "solib.h" and "solib-aix.h".
        (rs6000_find_toc_address_hook): Delete.
        (rs6000_push_dummy_call): Rewrite code setting the TOC value.
        (rs6000_aix_init_osabi): Register solib_aix_so_ops.
        * rs6000-nat.c: Remove "xcoffsolib.h" include.  Include
        "xml-utils.h".
        (map_vmap, vmap_exec, vmap_ldinfo, add_vmap, objfile_symbol_add)
        (vmap_symtab, fixup_breakpoints): Delete.
        (rs6000_xfer_shared_libraries): New function.
        (rs6000_xfer_partial): Add TARGET_OBJECT_AIX_LIBRARIES handling.
        (vmap_secs, bss_data_overlap, vmap_add_symbols): Delete.
        (xcoff_relocate_symtab, xcoff_relocate_core): Delete.
        (rs6000_ptrace_ldinfo, rs6000_core_ldinfo)
        (rs6000_xfer_shared_library): New function.
        (find_toc_address): Delete.
        (_initialize_rs6000_nat): Do not set rs6000_find_toc_address_hook.
        * rs6000-tdep.h (rs6000_find_toc_address_hook): Remove.
        * xcoffread.c (record_minimal_symbol): Reloate symbol address
        before creating minimal symbol.  Adjust function description
        accordingly.
        (scan_xcoff_symtab): Replace call to
        prim_record_minimal_symbol_and_info by call to
        record_minimal_symbol.
        (xcoff_symfile_offsets): Reimplement mostly as a wrapper
        around default_symfile_offsets.
        * configure.tgt: Add solib-aix.o to gdb_target_obs for
        powerpc-aix targets.
        * config/rs6000/nm-rs6000.h: Delete.
        * config/powerpc/aix.mh (NAT_FILE): Delete.
        (NATDEPFILES): Remove xcoffsolib.o.
        * Makefile.in (XMLFILES): Add library-list-aix.dtd.
        (ALL_TARGET_OBS): Add solib-aix.o.
        (HFILES_NO_SRCDIR): Remove xcoffsolib.h and
        config/rs6000/nm-rs6000.h.  Add solib-aix.h.
        (ALLDEPFILES): Add solib-aix.c.  Remove xcoffsolib.c.
        * xcoffsolib.h, xcoffsolib.c: Delete.

        * solib.c (reload_shared_libraries): Remove reference to
        SOLIB_CREATE_INFERIOR_HOOK.
        * breakpoint.c (handle_solib_event): Remove reference to SOLIB_ADD.
        (disable_breakpoints_in_shlibs): Remove reference to PC_SOLIB.
        (momentary_bkpt_re_set): Replace SOLIB_ADD by solib_add in
        comment.
        * corelow.c (deprecated_core_resize_section_table): Delete.
        * exec.c: Remove include of xcoffsolib.h".
        (map_vmap, vmap): Delete.
        (exec_close_1): Remove references to vmap.
        (exec_file_attach): Remove vmap handling code, and reference
        to DEPRECATED_IBM6000_TARGET.
        (bfdsec_to_vmap): Delete.
        (exec_files_info): Remove block of code handling VMAP.
        * infcmd.c (post_create_inferior): Remove reference to
        SOLIB_CREATE_INFERIOR_HOOK and SOLIB_ADD.
        * infrun.c (follow_exec): Remove reference to
        SOLIB_CREATE_INFERIOR_HOOK.
        * stack.c (print_frame): Remove reference to PC_SOLIB.
        * solib-dsbt.c (dsbt_current_sos): Adjust comment.
        (dsbt_relocate_main_executable): Likewise.
        * solib-frv.c (frv_current_sos): Likewise.

gdb/doc/ChangeLog:

        * gdbint.texinfo (Algorithms): Remove entries documenting
        DEPRECATED_IBM6000_TARGET, SOLIB_ADD, and
        SOLIB_CREATE_INFERIOR_HOOK.
@
text
@a222 3
static void xcoff_symfile_offsets (struct objfile *,
				   struct section_addr_info *addrs);

d3038 1
a3038 1
		       struct section_addr_info *addrs)
@


1.112
log
@-Wpointer-sign: xcoffread.c.

../../src/gdb/xcoffread.c: In function ‘xcoff_initial_scan’:
../../src/gdb/xcoffread.c:2982:17: error: pointer targets in assignment differ in signedness [-Werror=pointer-sign]

'debugsec' is a 'bfd_byte *', holding the result of a
bfd_get_full_section_contents.  'info->debugsec' holds the same
contents throughout the whole xcoff read, and everywhere it's used to
read symbol names.  Simply adding a cast feels appropriate.

gdb/
2013-04-19  Pedro Alves  <palves@@redhat.com>

	* xcoffread.c (xcoff_initial_scan): Add cast to 'char *'.
@
text
@d910 4
d918 2
a919 1
   ADDRESS - the symbol's address.
d930 2
d935 1
d2350 1
a2350 1
		      prim_record_minimal_symbol_and_info
d2353 1
a2353 2
			 secnum_to_section (symbol.n_scnum, objfile),
			 objfile);
d2426 1
a2426 1
		      prim_record_minimal_symbol_and_info
d2429 1
a2429 2
			 secnum_to_section (symbol.n_scnum, objfile),
			 objfile);
d2442 1
a2442 1
		      prim_record_minimal_symbol_and_info
d2445 1
a2445 2
			 secnum_to_section (symbol.n_scnum, objfile),
			 objfile);
d3043 3
a3045 2
  asection *sect = NULL;
  int i;
d3047 28
a3074 35
  objfile->num_sections = bfd_count_sections (objfile->obfd);
  objfile->section_offsets = (struct section_offsets *)
    obstack_alloc (&objfile->objfile_obstack, 
		   SIZEOF_N_SECTION_OFFSETS (objfile->num_sections));

  /* Initialize the section indexes for future use.  */
  sect = bfd_get_section_by_name (objfile->obfd, ".text");
  if (sect) 
    objfile->sect_index_text = sect->index;

  sect = bfd_get_section_by_name (objfile->obfd, ".data");
  if (sect) 
    objfile->sect_index_data = sect->index;

  sect = bfd_get_section_by_name (objfile->obfd, ".bss");
  if (sect) 
    objfile->sect_index_bss = sect->index;

  sect = bfd_get_section_by_name (objfile->obfd, ".rodata");
  if (sect) 
    objfile->sect_index_rodata = sect->index;

  for (i = 0; i < objfile->num_sections; ++i)
    {
      /* syms_from_objfile kindly subtracts from addr the
	 bfd_section_vma of the .text section.  This strikes me as
	 wrong--whether the offset to be applied to symbol reading is
	 relative to the start address of the section depends on the
	 symbol format.  In any event, this whole "addr" concept is
	 pretty broken (it doesn't handle any section but .text
	 sensibly), so just ignore the addr parameter and use 0.
	 rs6000-nat.c will set the correct section offsets via
	 objfile_relocate.  */
	(objfile->section_offsets)->offsets[i] = 0;
    }
@


1.111
log
@	* coffread.c (record_minimal_symbol): Update.
	* dbxread.c (record_minimal_symbol): Update.
	* elfread.c (record_minimal_symbol): Update.
	* machoread.c (macho_symtab_add_minsym): Update.
	* mdebugread.c (record_minimal_symbol, parse_partial_symbols):
	Update.
	* minsyms.c (prim_record_minimal_symbol): Update.
	(prim_record_minimal_symbol_full): Remove 'bfd_section'
	argument.
	(prim_record_minimal_symbol_and_info): Likewise.
	* minsyms.h (prim_record_minimal_symbol_full)
	(prim_record_minimal_symbol_and_info): Update.
	* symtab.c (allocate_symbol, initialize_symbol)
	(allocate_template_symbol): Initialize SYMBOL_SECTION.
	* xcoffread.c (record_minimal_symbol, scan_xcoff_symtab):
	Update.
@
text
@d2982 1
a2982 1
	info->debugsec = debugsec;
@


1.110
log
@	* coffread.c (cs_to_section): Use gdb_bfd_section_index.
	* elfread.c (record_minimal_symbol, elf_symtab_read): Use
	gdb_bfd_section_index.
	* gdb_bfd.c (gdb_bfd_section_index, gdb_bfd_count_sections):
	New functions.
	* gdb_bfd.h (gdb_bfd_section_index, gdb_bfd_count_sections):
	Declare.
	* machoread.c (macho_symtab_add_minsym, macho_symfile_offsets):
	Update.
	* objfiles.c (add_to_objfile_sections_full): New function.
	(add_to_objfile_sections): Use it.
	(build_section_table): Rewrite.
	(objfile_relocate1): Use gdb_bfd_section_index.  Update.
	* objfiles.h (obj_section_offset): Use gdb_bfd_section_index.
	(struct objfile) <sections>: Update comment.
	(ALL_OBJFILE_OSECTIONS): Skip sections where the_bfd_section
	is NULL.
	(ALL_OBJSECTIONS): Use it.
	* solib-dsbt.c (dsbt_relocate_main_executable): Update.
	* solib-frv.c (frv_relocate_main_executable): Update.
	* solib-target.c (solib_target_relocate_section_addresses):
	Use gdb_bfd_section_index.
	* symfile.c (build_section_addr_info_from_section_table):
	Use gdb_bfd_section_index.
	(build_section_addr_info_from_bfd, place_section): Likewise.
	* symtab.c (fixup_section): Update.
	* xcoffread.c (find_targ_sec): Use gdb_bfd_section_index.
@
text
@a924 3
  int secnum;
  asection *bfd_sect;

a927 1
  xcoff_secnum_to_sections (n_scnum, objfile, &bfd_sect, &secnum);
d929 2
a930 1
				       secnum, bfd_sect, objfile);
a2345 1
			 secnum_to_bfd_section (symbol.n_scnum, objfile),
a2422 1
			 secnum_to_bfd_section (symbol.n_scnum, objfile),
a2439 1
			 secnum_to_bfd_section (symbol.n_scnum, objfile),
@


1.109
log
@	* coffread.c (process_coff_symbol, coff_read_enum_type): Call
	allocate_symbol.
	* dwarf2read.c (fixup_go_packaging): Call allocate_symbol.
	(read_func_scope): Call allocate_template_symbol.
	(new_symbol_full): Call allocate_symbol.
	* jit.c (finalize_symtab): Call allocate_symbol.
	* jv-lang.c (add_class_symbol): Call allocate_symbol.
	* mdebugread.c (parse_symbol, new_block): Call allocate_symbol.
	* stabsread.c (patch_block_stabs, define_symbol, read_enum_type)
	(common_block_end): Call allocate_symbol.
	* symtab.c (allocate_symbol, initialize_symbol)
	(allocate_template_symbol): New functions.
	* symtab.c (allocate_symbol, initialize_symbol)
	(allocate_template_symbol): Declare.
	* xcoffread.c (process_xcoff_symbol): Call initialize_symbol.
@
text
@d281 1
a281 1
	*args->resultp = sect->index;
@


1.108
log
@2013-03-20  Jan Kratochvil  <jan.kratochvil@@redhat.com>
	    Tom Tromey  <tromey@@redhat.com>

	PR symtab/8421:
	* coffread.c (coff_register_index): New global.
	(process_coff_symbol, coff_read_enum_type): Set
	SYMBOL_ACLASS_INDEX.
	(_initialize_coffread): Initialize new global.
	* dwarf2loc.c (locexpr_find_frame_base_location)
	(dwarf2_block_frame_base_locexpr_funcs)
	(loclist_find_frame_base_location)
	(dwarf2_block_frame_base_loclist_funcs): New.
	(dwarf_expr_frame_base_1): Call SYMBOL_BLOCK_OPS, remove internal_error.
	(dwarf2_locexpr_funcs, dwarf2_loclist_funcs): Add location_has_loclist.
	* dwarf2loc.h (dwarf2_block_frame_base_locexpr_funcs)
	(dwarf2_block_frame_base_loclist_funcs): New.
	* dwarf2read.c (dwarf2_locexpr_index, dwarf2_loclist_index)
	(dwarf2_locexpr_block_index, dwarf2_loclist_block_index): New
	globals.
	(read_func_scope): Update.
	(fixup_go_packaging, mark_common_block_symbol_computed)
	(var_decode_location, new_symbol_full, dwarf2_const_value):
	Set SYMBOL_ACLASS_INDEX.
	(dwarf2_symbol_mark_computed): Likewise.  Add 'is_block' argument.
	(_initialize_dwarf2_read): Initialize new globals.
	* jit.c (finalize_symtab): Set SYMBOL_ACLASS_INDEX.
	* jv-lang.c (add_class_symbol): Set SYMBOL_ACLASS_INDEX.
	* mdebugread.c (mdebug_register_index, mdebug_regparm_index): New
	globals.
	(parse_symbol, psymtab_to_symtab_1): Set SYMBOL_ACLASS_INDEX.
	(_initialize_mdebugread): Initialize new globals.
	* psympriv.h (struct partial_symbol) <aclass>: Update comment.
	* stabsread.c (patch_block_stabs): Set SYMBOL_ACLASS_INDEX.
	(stab_register_index, stab_regparm_index): New globals.
	(define_symbol, read_enum_type, common_block_end): Set
	SYMBOL_ACLASS_INDEX.
	(_initialize_stabsread): Initialize new globals.
	* symtab.c (next_aclass_value, symbol_impl, symbol_impls): New
	globals.
	(MAX_SYMBOL_IMPLS): New define.
	(register_symbol_computed_impl, register_symbol_block_impl)
	(register_symbol_register_impl)
	(initialize_ordinary_address_classes): New functions.
	(_initialize_symtab): Call initialize_ordinary_address_classes.
	* symtab.h (enum address_class) <LOC_FINAL_VALUE>: New constant.
	(struct symbol_impl): New.
	(SYMBOL_ACLASS_BITS): New define.
	(struct symbol) <aclass, ops>: Remove fields.
	<aclass_index>: New field.
	(symbol_impls): Declare.
	(SYMBOL_CLASS, SYMBOL_COMPUTED_OPS, SYMBOL_REGISTER_OPS): Redefine.
	(SYMBOL_IMPL, SYMBOL_ACLASS_INDEX): New defines.
	(register_symbol_computed_impl, register_symbol_block_impl)
	(register_symbol_register_impl): Declare.
	(struct symbol_computed_ops): Add location_has_loclist.
	(struct symbol_block_ops): New.
	(SYMBOL_BLOCK_OPS): New.
	* xcoffread.c (process_xcoff_symbol): Set SYMBOL_ACLASS_INDEX.
@
text
@d1549 1
a1549 1
  memset (sym, '\0', sizeof (struct symbol));
@


1.107
log
@	* symfile.h (obsavestring): Don't declare.
	* symfile.c (obsavestring): Remove.
	* ada-exp.y: Use obstack_copy0, not obsavestring.
	* ada-lang.c: Use obstack_copy0, not obsavestring.
	* coffread.c: Use obstack_copy0, not obsavestring.
	* cp-namespace.c: Use obstack_copy0, not obsavestring.
	* dbxread.c: Use obstack_copy0, not obsavestring.
	* dwarf2read.c: Use obstack_copy0, not obsavestring.
	* jit.c: Use obstack_copy0, not obsavestring.
	* mdebugread.c: Use obstack_copy0, not obsavestring.
	* psymtab.c: Use obstack_copy0, not obsavestring.
	* stabsread.c: Use obstack_copy0, not obsavestring.
	* xcoffread.c: Use obstack_copy0, not obsavestring.
@
text
@d1565 1
a1565 1
      SYMBOL_CLASS (sym) = LOC_BLOCK;
@


1.106
log
@	* buildsym.c (patch_subfile_names): Use set_last_source_file.
	(start_symtab): Make 'name' and 'dirname' const.  Use
	set_last_source_file.
	(restart_symtab, reset_symtab_globals): Use set_last_source_file.
	(last_source_file): Define.  Now static.
	(set_last_source_file, get_last_source_file): New functions.
	* buildsym.h (last_source_file): Don't declare.
	(start_symtab): Update.
	(set_last_source_file, get_last_source_file): Declare.
	* coffread.c (complete_symtab): Use set_last_source_file.
	(coff_end_symtab): Likewise.
	(coff_symtab_read): Use set_last_source_file, get_last_source_file.
	* dbxread.c (read_dbx_symtab, read_ofile_symtab): Use
	set_last_source_file.
	(process_one_symbol): Use get_last_source_file.
	* mdebugread.c (parse_partial_symbols): Use set_last_source_file.
	(psymtab_to_symtab_1): Use get_last_source_file.
	* xcoffread.c (process_linenos): Use get_last_source_file.
	(complete_symtab): Use set_last_source_file.
	(read_xcoff_symtab): Use set_last_source_file, get_last_source_file.
	(scan_xcoff_symtab): Use set_last_source_file.
@
text
@d1515 2
a1516 2
  ((ALLOCED) ? (NAME) : obsavestring ((NAME), strlen (NAME), \
				      &objfile->objfile_obstack))
@


1.105
log
@gdb/
	* dbxread.c (dbx_psymtab_to_symtab): Delete the declaration.
	(dbx_read_symtab): New declaration.
	(dbx_psymtab_to_symtab): Delete.
	(dbx_read_symtab): Rename from dbx_psymtab_to_symtab.
	Rename parameter PST to SELF.  Exchanged two parameters.
	(start_psymtab): Caller update.
	* dwarf2read.c (dwarf2_psymtab_to_symtab): Delete the declaration.
	(dwarf2_read_symtab): New declaration.
	(dwarf2_psymtab_to_symtab): Delete.
	(dwarf2_read_symtab): Rename from dwarf2_psymtab_to_symtab.
	Rename parameter PST to SELF.  Exchanged two parameters.
	(create_partial_symtab): Caller update.
	* mdebugread.c (mdebug_psymtab_to_symtab): Delete.
	(mdebug_read_symtab): Rename from mdebug_psymtab_to_symtab.
	Rename parameter PST to SELF.  Exchanged two parameters.
	(parse_partial_symbols, new_psymtab): Caller update.
	* psympriv.h (struct partial_symtab) <read_symtab>: Exchange
	two parameters.
	* psymtab.c (psymtab_to_symtab): Caller update.
	* xcoffread.c (xcoff_psymtab_to_symtab): Delete.
	(xcoff_read_symtab): Rename from xcoff_psymtab_to_symtab.
	Rename parameter PST to SELF.  Exchanged two parameters.
	(xcoff_start_psymtab): Caller update.
@
text
@d658 1
a658 1
	  if (strcmp (inclTable[ii].name, last_source_file) == 0)
d897 1
a897 1
  last_source_file = xstrdup (name);		\
d1034 1
a1034 1
  last_source_file = NULL;
d1122 1
a1122 1
	  if (last_source_file)
d1491 1
a1491 1
  if (last_source_file)
d2228 1
a2228 1
  last_source_file = NULL;
@


1.104
log
@gdb/
2013-01-14  Yao Qi  <yao@@codesourcery.com>

	* dbxread.c (dbx_psymtab_to_symtab_1): Don't check PST is NULL.
	(dbx_psymtab_to_symtab): Likewise.
	* dwarf2read.c (dwarf2_psymtab_to_symtab): Likewise.
	* mdebugread.c (mdebug_psymtab_to_symtab): Likewise.
	* xcoffread.c (xcoff_psymtab_to_symtab_1): Likewise.
@
text
@d1858 1
a1858 1
   Be verbose about it if the user wants that.  PST is not NULL.  */
d1861 1
a1861 1
xcoff_psymtab_to_symtab (struct objfile *objfile, struct partial_symtab *pst)
d1863 1
a1863 1
  if (pst->readin)
d1867 1
a1867 1
	 pst->filename);
d1871 2
a1872 2
  if (((struct symloc *) pst->read_symtab_private)->numsyms != 0
      || pst->number_of_dependencies)
d1878 1
a1878 1
	  printf_filtered ("Reading in symbols for %s...", pst->filename);
d1884 1
a1884 1
      xcoff_psymtab_to_symtab_1 (objfile, pst);
d2020 1
a2020 1
  result->read_symtab = xcoff_psymtab_to_symtab;
@


1.103
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d1858 1
a1858 1
   Be verbose about it if the user wants that.  */
a1862 3
  if (!pst)
    return;

@


1.102
log
@Port GDB to powerpc-lynx178.

gdb/ChangeLog:

        * defs.h (enum gdb_osabi): Add GDB_OSABI_LYNXOS178.
        * osabi.c (gdb_osabi_names): Add entry for GDB_OSABI_LYNXOS178.
        * xcoffread.c (xcoff_get_core_n_import_files): New function.
        (xcoff_get_n_import_files): New function.
        * xcoffread.h (xcoffread.h): Add declaration.
        * rs6000-aix-tdep.c: #include "xcoffread.h".
        (rs6000_aix_osabi_sniffer): Do not return GDB_OSABI_AIX for
        XCOFF executables that do not depend on any shared library.
        * rs6000-lynx178-tdep.c: New file.
        * configure.tgt: Add powerpc-*-lynx*178 handling.
        * Makefile.in (ALL_TARGET_OBS): Add rs6000-lynx178-tdep.o.
        (ALLDEPFILES): Add rs6000-lynx178-tdep.c.
@
text
@d2 1
a2 1
   Copyright (C) 1986-2004, 2007-2012 Free Software Foundation, Inc.
@


1.101
log
@Fix NULL objfile's section_offsets dereference during symbol load.

gdb/ChangeLog:

        * symfile.c (syms_from_objfile_1): Renames syms_from_objfile.
        Remove call to init_entry_point_info.  Add OBJFILE's
        section_offsets and num_sections initialization.  Add note
        about entry info in the function documentation.
        (syms_from_objfile): New function.
        * coffread.c (coff_symfile_init): Remove call to
        init_entry_point_info.
        * machoread.c (macho_symfile_init): Likewise.
        * xcoffread.c(xcoff_symfile_init): Likewise.
@
text
@d3116 61
@


1.100
log
@	* dbxread.c (read_dbx_symtab): Update.
	(end_psymtab, dbx_psymtab_to_symtab_1, dbx_psymtab_to_symtab)
	(read_ofile_symtab): Add 'objfile' argument.
	* dwarf2read.c (process_psymtab_comp_unit_reader)
	(build_type_psymtabs_reader): Update.
	(dwarf2_psymtab_to_symtab): Add 'objfile' argument.
	* mdebugread.c (mdebug_psymtab_to_symtab): Add 'objfile'
	argument.
	(parse_procedure, parse_partial_symbols): Update.
	(psymtab_to_symtab_1): Add 'objfile' argument.
	* psympriv.h (struct partial_symtab) <objfile>: Remove.
	<read_symtab>: Add 'objfile' argument.
	(sort_pst_symbols, discard_psymtab): Update.
	* psymtab.c (partial_map_expand_apply): Update.
	(find_pc_sect_psymtab_closer): Add 'objfile' argument.
	(find_pc_sect_psymtab, find_pc_sect_symtab_from_partial): Update.
	(find_pc_sect_psymbol): Add 'objfile' argument.
	(lookup_symbol_aux_psymtabs): Update.
	(match_partial_symbol, lookup_partial_symbol, psymtab_to_symtab):
	Add 'objfile' argument.
	(find_last_source_symtab_from_partial, dump_psymtab)
	(dump_psymtabs_for_objfile, read_symtabs_for_function)
	(expand_partial_symbol_tables, read_psymtabs_with_filename)
	(find_symbol_file_from_partial, map_matching_symbols_psymtab)
	(expand_symtabs_matching_via_partial): Update.
	(sort_pst_symbols): Add 'objfile' argument.
	(allocate_psymtab): Update.
	(discard_psymtab): Add 'objfile' argument.
	(maintenance_info_psymtabs, maintenance_check_symtabs): Update.
	* stabsread.h (end_psymtab): Update.
	* xcoffread.c (this_symtab_objfile): New global.
	(process_linenos, enter_line_range, xcoff_next_symbol_text):
	Update.
	(read_xcoff_symtab): Add 'objfile' argument.
	(read_symbol, read_symbol_lineno): Update.
	(xcoff_psymtab_to_symtab_1, xcoff_psymtab_to_symtab)
	(xcoff_end_psymtab): Add 'objfile' argument.
	(scan_xcoff_symtab): Update.
@
text
@a1924 2

  init_entry_point_info (objfile);
@


1.99
log
@	* coffread.c (coff_objfile_data_key): New global.
	(coff_symfile_init): Use set_objfile_data.
	(coff_symfile_read): Use objfile_data.
	(coff_symfile_finish): Don't free deprecated_sym_private.
	(coff_free_info): New function.
	(_initialize_coffread): Initialize coff_objfile_data_key.
	* mdebugread.c (pending_list): Update comment.
	* objfiles.h (struct objfile) <deprecated_sym_private>: Remove.
	* symfile.c (reread_symbols): Don't mention
	deprecated_sym_private.
	* xcoffread.c (xcoff_objfile_data_key): New global.
	(XCOFF_DATA): New macro.
	(process_linenos, enter_line_range, xcoff_next_symbol_text)
	(read_xcoff_symtab, coff_getfilename, read_symbol_lineno): Use
	XCOFF_DATA.
	(xcoff_new_init) Use set_objfile_data.
	(xcoff_symfile_finish): Don't free deprecated_sym_private.
	(init_stringtab, swap_sym, scan_xcoff_symtab)
	(xcoff_get_toc_offset, xcoff_initial_scan): Use XCOFF_DATA.
	(xcoff_free_info): New function.
	(_initialize_xcoffread): Initialize xcoff_objfile_data_key.
@
text
@d237 1
a237 1
static void read_xcoff_symtab (struct partial_symtab *);
d599 3
d610 1
a610 1
    = XCOFF_DATA (this_symtab_psymtab->objfile)->max_lineno_offset;
d643 1
a643 1
	coff_data (this_symtab_psymtab->objfile->obfd)->local_linesz;
d831 1
a831 1
  struct objfile *objfile = this_symtab_psymtab->objfile;
d964 2
a965 2
  if (this_symtab_psymtab)
    objfile = this_symtab_psymtab->objfile;
d996 1
a996 1
read_xcoff_symtab (struct partial_symtab *pst)
a997 1
  struct objfile *objfile = pst->objfile;
d1028 1
d1683 1
a1683 1
  struct coff_symfile_info *xcoff = XCOFF_DATA (this_symtab_psymtab->objfile);
d1694 1
a1694 1
  bfd_coff_swap_sym_in (this_symtab_psymtab->objfile->obfd,
d1717 1
a1717 1
  struct objfile *objfile = this_symtab_psymtab->objfile;
a1806 2
static void xcoff_psymtab_to_symtab_1 (struct partial_symtab *);

d1808 1
a1808 1
xcoff_psymtab_to_symtab_1 (struct partial_symtab *pst)
d1839 1
a1839 1
	xcoff_psymtab_to_symtab_1 (pst->dependencies[i]);
d1849 1
a1849 1
      read_xcoff_symtab (pst);
a1856 2
static void xcoff_psymtab_to_symtab (struct partial_symtab *);

d1861 1
a1861 1
xcoff_psymtab_to_symtab (struct partial_symtab *pst)
a1862 2
  bfd *sym_bfd;

a1884 2
      sym_bfd = pst->objfile->obfd;

d1887 1
a1887 1
      xcoff_psymtab_to_symtab_1 (pst);
d1891 1
a1891 1
      scan_file_globals (pst->objfile);
d2042 3
a2044 2
xcoff_end_psymtab (struct partial_symtab *pst, const char **include_list,
		   int num_includes, int capping_symbol_number,
a2048 1
  struct objfile *objfile = pst->objfile;
d2105 1
a2105 1
  sort_pst_symbols (pst);
d2117 1
a2117 1
      discard_psymtab (pst);
d2307 2
a2308 2
			      (pst, psymtab_include_list, includes_used,
			       symnum_before, dependency_list,
d2484 4
a2487 3
		xcoff_end_psymtab (pst, psymtab_include_list, includes_used,
				   symnum_before, dependency_list,
				   dependencies_used, textlow_not_set);
d2909 1
a2909 1
      xcoff_end_psymtab (pst, psymtab_include_list, includes_used,
@


1.98
log
@	PR gdb/14704:
	* gdb_bfd.c (gdb_bfd_ref): Set BFD_DECOMPRESS.
	(zlib_decompress_section): Remove.
	(gdb_bfd_map_section): Only check for compressed section
	in mmap case.  Use bfd_get_full_section_contents.
	* osabi.c (check_note): Add 'sectsize' argument.  Read
	section data.
	(generic_elf_osabi_sniff_abi_tag_sections): Don't read
	section data.  Update for check_note change.
	* xcoffread.c (xcoff_initial_scan): Use
	bfd_get_full_section_contents.
	* py-auto-load.c (auto_load_section_scripts): Use
	bfd_get_full_section_contents.
	* contrib/cc-with-tweaks.sh: Add -Z option.
testsuite
	* gdb.base/comprdebug.exp: New file.
@
text
@d59 4
d157 6
d606 2
a607 3
  file_ptr max_offset =
    ((struct coff_symfile_info *) this_symtab_psymtab->objfile
     ->deprecated_sym_private)->max_lineno_offset;
d841 1
a841 3
  limit_offset =
    ((struct coff_symfile_info *) objfile->deprecated_sym_private)
    ->max_lineno_offset;
d975 1
a975 3
      retval = ((struct coff_symfile_info *)
		objfile->deprecated_sym_private)->debugsec
	+ symbol.n_offset;
d998 3
a1000 4
  char *strtbl = 
    ((struct coff_symfile_info *) objfile->deprecated_sym_private)->strtbl;
  char *debugsec =
    ((struct coff_symfile_info *) objfile->deprecated_sym_private)->debugsec;
d1042 1
a1042 3
  raw_symbol =
    ((struct coff_symfile_info *) objfile->deprecated_sym_private)->symtbl
    + symnum * local_symesz;
d1666 2
a1667 3
    strcpy (buffer, ((struct coff_symfile_info *)
		     objfile->deprecated_sym_private)->strtbl
	    + aux_entry->x_file.x_n.x_offset);
d1680 3
a1682 5
  int nsyms
    = ((struct coff_symfile_info *)
       this_symtab_psymtab->objfile->deprecated_sym_private)->symtbl_num_syms;
  char *stbl = ((struct coff_symfile_info *)
		this_symtab_psymtab->objfile->deprecated_sym_private)->symtbl;
d1717 1
a1717 2
  struct coff_symfile_info *info =
    (struct coff_symfile_info *)objfile->deprecated_sym_private;
d1920 2
d1923 2
a1924 2
  objfile->deprecated_sym_private
    = xmalloc (sizeof (struct coff_symfile_info));
a1941 5
  if (objfile->deprecated_sym_private != NULL)
    {
      xfree (objfile->deprecated_sym_private);
    }

d1961 1
d1963 1
a1963 2
  ((struct coff_symfile_info *) objfile->deprecated_sym_private)->strtbl
    = NULL;
d1982 1
a1982 2
  ((struct coff_symfile_info *) objfile->deprecated_sym_private)->strtbl
    = strtbl;
d2162 1
a2162 2
      *name = ((struct coff_symfile_info *)
	       objfile->deprecated_sym_private)->debugsec + symbol->n_offset;
d2166 1
a2166 2
      *name = ((struct coff_symfile_info *)
	       objfile->deprecated_sym_private)->strtbl + symbol->n_offset;
d2243 2
a2244 4
  sraw_symbol = ((struct coff_symfile_info *)
		 objfile->deprecated_sym_private)->symtbl;
  nsyms = ((struct coff_symfile_info *)
	   objfile->deprecated_sym_private)->symtbl_num_syms;
d2923 1
a2923 2
  ((struct coff_symfile_info *) objfile->deprecated_sym_private)->toc_offset
    = toc_offset;
d2932 1
a2932 2
    return ((struct coff_symfile_info *)
	    objfile->deprecated_sym_private)->toc_offset;
d2958 1
a2958 1
  info = (struct coff_symfile_info *) objfile->deprecated_sym_private;
d2997 1
a2997 3
	((struct coff_symfile_info *)
	 objfile->deprecated_sym_private)->debugsec
	  = debugsec;
d3008 4
a3011 9
  ((struct coff_symfile_info *) objfile->deprecated_sym_private)->symtbl =
    obstack_alloc (&objfile->objfile_obstack, size);
  ((struct coff_symfile_info *)
   objfile->deprecated_sym_private)->symtbl_num_syms
    = num_symbols;

  val = bfd_bread (((struct coff_symfile_info *)
		    objfile->deprecated_sym_private)->symtbl,
		   size, abfd);
d3122 8
d3137 3
@


1.97
log
@2012-05-18  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c:
	* avr-tdep.c:
	* ax-gdb.c:
	* bfin-linux-tdep.c:
	* breakpoint.c:
	* c-valprint.c:
	* cli/cli-cmds.c:
	* coffread.c:
	* cp-support.c:
	* cris-tdep.c:
	* dwarf2-frame-tailcall.c:
	* dwarf2-frame.c:
	* dwarf2expr.c:
	* dwarf2loc.c:
	* dwarf2read.c:
	* elfread.c:
	* eval.c:
	* expprint.c:
	* f-valprint.c:
	* frv-tdep.c:
	* h8300-tdep.c:
	* hppa-hpux-tdep.c:
	* hppa-tdep.c:
	* hppanbsd-tdep.c:
	* i386-nto-tdep.c:
	* i386-tdep.c:
	* i387-tdep.c:
	* ia64-tdep.c:
	* jit.c:
	* linespec.c:
	* linux-tdep.c:
	* lm32-tdep.c:
	* m2-valprint.c:
	* m32c-tdep.c:
	* m32r-rom.c:
	* m32r-tdep.c:
	* m68k-tdep.c:
	* m68klinux-tdep.c:
	* mi/mi-main.c:
	* microblaze-tdep.c:
	* mips-linux-tdep.c:
	* mips-tdep.c:
	* mn10300-tdep.c:
	* p-valprint.c:
	* parse.c:
	* ppc-linux-tdep.c:
	* ppc-sysv-tdep.c:
	* printcmd.c:
	* python/py-finishbreakpoint.c:
	* python/py-inferior.c:
	* python/py-infthread.c:
	* python/py-type.c:
	* python/python.c:
	* remote-fileio.c:
	* remote-m32r-sdi.c:
	* remote-mips.c:
	* reverse.c:
	* rl78-tdep.c:
	* rs6000-aix-tdep.c:
	* rs6000-tdep.c:
	* s390-tdep.c:
	* score-tdep.c:
	* sh64-tdep.c:
	* skip.c:
	* solib-darwin.c:
	* solib-dsbt.c:
	* solib-frv.c:
	* sparc-tdep.c:
	* spu-multiarch.c:
	* spu-tdep.c:
	* stack.c:
	* symfile.c:
	* symtab.c:
	* tic6x-tdep.c:
	* tracepoint.c:
	* v850-tdep.c:
	* valarith.c:
	* valprint.c:
	* value.c:
	* xcoffread.c:
	* xtensa-tdep.c:
	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c: Delete unused variables.
@
text
@d2992 1
a2992 1
	char *debugsec = NULL;
d3000 1
a3000 2
		debugsec =
		  (char *) obstack_alloc (&objfile->objfile_obstack, length);
d3002 1
a3002 2
		if (!bfd_get_section_contents (abfd, secp, debugsec,
					       (file_ptr) 0, length))
@


1.96
log
@	Initial support for Fission.  http://gcc.gnu.org/wiki/DebugFission
	* symfile.c (default_symfile_relocate): Use sectp->owner instead of
	objfile->obfd.
	* symfile.h (dwarf2_debug_sections): New member addr.
	* dwarf2expr.c (execute_stack_op): New case DW_OP_GNU_addr_index.
	(ctx_no_get_addr_index): New function.
	* dwarf2expr.h (dwarf_expr_context_funcs): New member get_addr_index.
	(ctx_no_get_addr_index): Declare.
	* dwarf2-frame.c (dwarf2_frame_ctx_funcs): Update.
	* dwarf2loc.c (dwarf_expr_get_addr_index): New function.
	(dwarf_expr_ctx_funcs): Update.
	(needs_get_addr_index): New function.
	(needs_frame_ctx_funcs): Update.
	* dwarf2loc.h (dwarf2_read_addr_index): Declare.
	* dwarf2read.c: #include "gdbcore.h".
	(dwarf2_per_objfile): New members addr, dwo_files.
	(dwarf2_elf_names): Add entry for addr.
	(struct dwo_section_names): New type.
	(dwo_section_names): New static global.
	(dwarf2_cu): New members dwo_unit, addr_base, have_addr_base.
	(dwarf2_per_cu_data): New member is_debug_types, all boolean uses of
	old debug_types_section member updated to use this.
	Rename member debug_types_section to info_or_types_section,
	all uses updated.
	(signatured_type): Rename member type_offset to type_offset_in_tu,
	all uses updated.  New member type_offset_in_section.
	(struct dwo_sections): New type.
	(struct dwo_unit): New type.
	(struct dwo_file): New type.
	(die_reader_specs): New member dwo_file.
	(dwarf2_locate_sections): Watch for .debug_addr.
	(zlib_decompress_section): Use sectp->owner instead of objfile->obfd.
	(dwarf2_read_section): Get bfd of section from bfd's asection,
	instead of objfile.
	(create_cus_from_index): Initialize the_cu->info_or_types_section.
	(create_signatured_type_table_from_index): Initialize
	sig_type->info_or_types_section.
	(dw2_get_file_names): Statement lists for type units with DWO files
	live in the DWO file.
	(create_debug_types_hash_table): New function.
	(create_all_type_units): Rewrite.
	(init_cu_die_reader): New arg dwo_file, all callers updated.
	(init_and_read_dies_worker): Get section from
	this_cu->info_or_types_section.  Set sig_type->type_offset_in_section.
	Watch for DW_AT_GNU_dwo_name and if present lookup the file and
	continue reading the CU/TU from there.
	(init_cutu_and_read_dies_no_follow): New arg dwo_file, all callers
	updated.  Get section from this_cu->info_or_types_section.
	(create_all_comp_units): Initialize this_cu->info_or_types_section.
	(skip_one_die): New cases DW_FORM_GNU_addr_index,
	DW_FORM_GNU_str_index.
	(hash_dwo_file, eq_dwo_file): New functions.
	(allocate_dwo_file_hash_table): New function.
	(hash_dwo_unit, eq_dwo_unit): New functions.
	(allocate_dwo_unit_table): New function.
	(dwarf2_locate_dwo_sections): New function.
	(struct create_dwo_info_table_data): New type.
	(create_debug_info_hash_table_reader): New function.
	(create_debug_info_hash_table): New function.
	(try_open_dwo_file, open_dwo_file, init_dwo_file): New function.
	(lookup_dwo_file): New function.
	(lookup_dwo_comp_unit, lookup_dwo_type_unit): New functions.
	(free_dwo_file, free_dwo_file_cleanup): New functions.
	(free_dwo_file_from_slot, free_dwo_files): New functions.
	(dwarf2_get_pc_bounds): Handle DW_FORM_GNU_addr_index.
	(dwarf2_record_block_ranges): Ditto.
	(read_partial_die): Ditto.
	(process_enumeration_scope): Update to use type_offset_in_section.
	(read_full_die_1): New function.
	(read_full_die): Rewrite.
	(read_attribute_value): New cases DW_FORM_GNU_addr_index,
	DW_FORM_GNU_str_index.
	(read_addr_index_1, read_addr_index): New functions.
	(read_addr_index_from_leb128): New function.
	(struct dwarf2_read_addr_index_data): New type.
	(dwarf2_read_addr_index_reader): New function.
	(dwarf2_read_addr_index): New function.
	(read_str_index): New function.
	(leb128_size): New function.
	(dwarf_decode_line_header): Delete arg abfd, all callers updated.
	If processing a type unit from a DWO file, get the line section
	from the DWO file.
	(var_decode_location): Watch for DW_OP_GNU_addr_index.
	(dwarf2_const_value_attr): New cases DW_FORM_GNU_addr_index,
	DW_FORM_GNU_str_index.
	(lookup_die_type): Check whether section offset of type's die is
	known before looking it up.  Remove assert.  Condition can
	legimately happen for inter-cu type references.
	(dwarf_attr_name): Handle Fission attributes.
	(dwarf_form_name): Handle Fission forms.
	(dump_die_shallow): New cases DW_FORM_GNU_addr_index,
	DW_FORM_GNU_str_index.
	(follow_die_sig): Update to use type_offset_in_section.
	(decode_locdesc): New case DW_OP_GNU_addr_index.
	(skip_form_bytes): New cases DW_FORM_GNU_addr_index,
	DW_FORM_GNU_str_index.
	(cu_debug_loc_section): New function.
	(fill_in_loclist_baton, dwarf2_symbol_mark_computed): Call it.
	(dwarf2_per_objfile_free): Unmap .debug_addr section.
	Free DWO files if present.
	* xcoffread.c (dwarf2_xcoff_names): Add .debug_addr.

	testsuite/
	* gdb.dwarf2/dw2-intercu.S (.Ltype_int2_in_cu2): Renamed from
	.Ltype_int_in_cu2.  Use name "int2" instead of "int".
	All uses updated.
	* gdb.dwarf2/dw2-intercu.exp: Add "ptype int2" ahead of
	"ptype func_cu1" to expand cu2 before cu1.
@
text
@a914 1
  struct find_targ_sec_arg args;
@


1.95
log
@2012-04-27  Sergio Durigan Junior  <sergiodj@@redhat.com>
	    Tom Tromey  <tromey@@redhat.com>
	    Jan Kratochvil  <jan.kratochvil@@redhat.com>

	* Makefile.in (SFILES): Add `probe' and `stap-probe'.
	(COMMON_OBS): Likewise.
	(HFILES_NO_SRCDIR): Add `probe'.
	* NEWS: Mention support for static and SystemTap probes.
	* amd64-tdep.c (amd64_init_abi): Initializing proper fields used by
	SystemTap probes' arguments parser.
	* arm-linux-tdep.c: Including headers needed to perform the parsing
	of SystemTap probes' arguments.
	(arm_stap_is_single_operand): New function.
	(arm_stap_parse_special_token): Likewise.
	(arm_linux_init_abi): Initializing proper fields used by SystemTap
	probes' arguments parser.
	* ax-gdb.c (require_rvalue): Removing static declaration.
	(gen_expr): Likewise.
	* ax-gdb.h (gen_expr): Declaring function.
	(require_rvalue): Likewise.
	* breakpoint.c: Include `gdb_regex.h' and `probe.h'.
	(bkpt_probe_breakpoint_ops): New variable.
	(momentary_breakpoint_from_master): Set the `probe' value.
	(add_location_to_breakpoint): Likewise.
	(break_command_1): Using proper breakpoint_ops according to the
	argument passed by the user in the command line.
	(bkpt_probe_insert_location): New function.
	(bkpt_probe_remove_location): Likewise.
	(bkpt_probe_create_sals_from_address): Likewise.
	(bkpt_probe_decode_linespec): Likewise.
	(tracepoint_probe_create_sals_from_address): Likewise.
	(tracepoint_probe_decode_linespec): Likewise.
	(tracepoint_probe_breakpoint_ops): New variable.
	(trace_command): Using proper breakpoint_ops according to the
	argument passed by the user in the command line.
	(initialize_breakpoint_ops): Initializing breakpoint_ops for
	static probes on breakpoints and tracepoints.
	* breakpoint.h (struct bp_location) <probe>: New field.
	* cli-utils.c (skip_spaces_const): New function.
	(extract_arg): Likewise.
	* cli-utils.h (skip_spaces_const): Likewise.
	(extract_arg): Likewise.
	* coffread.c (coff_sym_fns): Add `sym_probe_fns' value.
	* configure.ac: Append `stap-probe.o' to be generated when ELF
	support is present.
	* configure: Regenerate.
	* dbxread.c (aout_sym_fns): Add `sym_probe_fns' value.
	* elfread.c: Include `probe.h' and `arch-utils.h'.
	(probe_key): New variable.
	(elf_get_probes): New function.
	(elf_get_probe_argument_count): Likewise.
	(elf_evaluate_probe_argument): Likewise.
	(elf_compile_to_ax): Likewise.
	(elf_symfile_relocate_probe): Likewise.
	(stap_probe_key_free): Likewise.
	(elf_probe_fns): New variable.
	(elf_sym_fns): Add `sym_probe_fns' value.
	(elf_sym_fns_lazy_psyms): Likewise.
	(elf_sym_fns_gdb_index): Likewise.
	(_initialize_elfread): Initialize objfile cache for static
	probes.
	* gdb_vecs.h (struct probe): New forward declaration.
	(probe_p): New VEC declaration.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* gdbarch.sh (stap_integer_prefix): New variable.
	(stap_integer_suffix): Likewise.
	(stap_register_prefix): Likewise.
	(stap_register_suffix): Likewise.
	(stap_register_indirection_prefix): Likewise.
	(stap_register_indirection_suffix): Likewise.
	(stap_gdb_register_prefix): Likewise.
	(stap_gdb_register_suffix): Likewise.
	(stap_is_single_operand): New function.
	(stap_parse_special_token): Likewise.
	(struct stap_parse_info): Forward declaration.
	* i386-tdep.c: Including headers needed to perform the parsing
	of SystemTap probes' arguments.
	(i386_stap_is_single_operand): New function.
	(i386_stap_parse_special_token): Likewise.
	(i386_elf_init_abi): Initializing proper fields used by SystemTap
	probes' arguments parser.
	* i386-tdep.h (i386_stap_is_single_operand): New function.
	(i386_stap_parse_special_token): Likewise.
	* machoread.c (macho_sym_fns): Add `sym_probe_fns' value.
	* mipsread.c (ecoff_sym_fns): Likewise.
	* objfiles.c (objfile_relocate1): Support relocation for static
	probes.
	* parse.c (prefixify_expression): Remove static declaration.
	(initialize_expout): Likewise.
	(reallocate_expout): Likewise.
	* parser-defs.h (initialize_expout): Declare function.
	(reallocate_expout): Likewise.
	(prefixify_expression): Likewise.
	* ppc-linux-tdep.c: Including headers needed to perform the parsing
	of SystemTap probes' arguments.
	(ppc_stap_is_single_operand): New function.
	(ppc_stap_parse_special_token): Likewise.
	(ppc_linux_init_abi): Initializing proper fields used by SystemTap
	probes' arguments parser.
	* probe.c: New file, for generic statically defined probe support.
	* probe.h: Likewise.
	* s390-tdep.c: Including headers needed to perform the parsing of
	SystemTap probes' arguments.
	(s390_stap_is_single_operand): New function.
	(s390_gdbarch_init): Initializing proper fields used by SystemTap
	probes' arguments parser.
	* somread.c (som_sym_fns): Add `sym_probe_fns' value.
	* stap-probe.c: New file, for SystemTap probe support.
	* stap-probe.h: Likewise.
	* symfile.h: Include `gdb_vecs.h'.
	(struct sym_probe_fns): New struct.
	(struct sym_fns) <sym_probe_fns>: New field.
	* symtab.c (init_sal): Initialize `probe' field.
	* symtab.h (struct probe): Forward declaration.
	(struct symtab_and_line) <probe>: New field.
	* tracepoint.c (start_tracing): Adjust semaphore on breakpoints
	locations.
	(stop_tracing): Likewise.
	* xcoffread.c (xcoff_sym_fns): Add `sym_probe_fns' value.
@
text
@d165 1
@


1.94
log
@pspace != NULL failed assertion on ppc-aix

This patch fixes the following problem:

    % gdb foo
    (gdb) b main
    /[...]/progspace.c:216: internal-error: set_current_program_space: Assertion `pspace != NULL' failed.
    A problem internal to GDB has been detected,
    further debugging may prove unreliable.
    Quit this debugging session? (y or n)

The problem happens when we try to get the program space from
a minimal symbol.  For that, we go through the minimal symbol's
obj_section->objfile->pspace.  But the minimal symbol's obj_section
is not set, and thus we somehow get a NULL program space. And
the reason why the obj_section is not set is because the XCOFF
reader did not pass the bfd_section when calling minsyms.c's
prim_record_minimal_symbol_and_info.

gdb/ChangeLog:

        * xcoffread.c (xcoff_secnum_to_sections): New function.
        (secnum_to_section, secnum_to_bfd_section): Reimplement
        using xcoff_secnum_to_sections.  Rename "secnum" parameter
        into "n_scnum".
        (RECORD_MINIMAL_SYMBOL): Delete.
        (record_minimal_symbol): New function.
        (scan_xcoff_symtab): Replace uses of RECORD_MINIMAL_SYMBOL
        by call to record_minimal_symbol and set misc_func_recorded
        to 1.  Set last_csect_sec to the XCOFF section index instead
        of GDB's section_offset index.  Update calls to
        prim_record_minimal_symbol_and_info to pass the BFD section
        as well.
@
text
@d3139 1
@


1.93
log
@Unused local variables in xcoffread.c:read_xcoff_symtab

gdb/ChangeLog:

        * xcoffread.c (read_xcoff_symtab): Delete variables
        last_csect_val and last_csect_sec and associated code.
@
text
@d275 11
a285 3
/* Return the section number (SECT_OFF_*) that CS points to.  */
static int
secnum_to_section (int secnum, struct objfile *objfile)
d287 1
a287 1
  int off = SECT_OFF_TEXT (objfile);
d289 3
a291 5
  asection *sect = NULL;
  struct find_targ_sec_arg args;
  args.targ_index = secnum;
  args.resultp = &off;
  args.bfd_sect = &sect;
d293 4
a297 1
  return off;
d300 14
a313 1
/* Return the BFD section that CS points to.  */
d315 1
a315 1
secnum_to_bfd_section (int secnum, struct objfile *objfile)
d317 2
a318 1
  int off = SECT_OFF_TEXT (objfile);
d320 2
a321 8
  asection *sect = NULL;
  struct find_targ_sec_arg args;
  args.targ_index = secnum;
  args.resultp = &off;
  args.bfd_sect = &sect;
  args.objfile = objfile;
  bfd_map_over_sections (objfile->obfd, find_targ_sec, &args);
  return sect;
d897 23
a919 2
/* Reading symbol table has to be fast! Keep the followings as macros, rather
   than functions.  */
d921 3
a923 10
#define	RECORD_MINIMAL_SYMBOL(NAME, ADDR, TYPE, SECTION, OBJFILE) \
{						\
  const char *namestr;				\
						\
  namestr = (NAME);				\
  if (namestr[0] == '.') ++namestr;		\
  prim_record_minimal_symbol_and_info (namestr, (ADDR), (TYPE),     \
				       (SECTION), (asection *)NULL, \
				       (OBJFILE));		    \
  misc_func_recorded = 1;			\
a925 1

d2310 1
a2310 1
			    RECORD_MINIMAL_SYMBOL
d2312 2
a2313 2
			       mst_text, last_csect_sec,
			       objfile);
d2345 1
a2345 2
			last_csect_sec =
			  secnum_to_section (symbol.n_scnum, objfile);
d2369 2
a2370 1
			 NULL, objfile);
d2404 7
a2410 5
		    RECORD_MINIMAL_SYMBOL
		      (namestring, symbol.n_value,
		       sclass == C_HIDEXT ? mst_file_text : mst_text,
		       secnum_to_section (symbol.n_scnum, objfile),
		       objfile);
d2421 1
a2421 1
		    RECORD_MINIMAL_SYMBOL
d2423 2
a2424 3
		       mst_solib_trampoline,
		       secnum_to_section (symbol.n_scnum, objfile),
		       objfile);
d2447 2
a2448 1
			 NULL, objfile);
d2465 2
a2466 1
			 NULL, objfile);
d2492 3
a2494 3
		RECORD_MINIMAL_SYMBOL
		  (last_csect_name, last_csect_val,
		   mst_text, last_csect_sec, objfile);
@


1.92
log
@	* gdbtypes.h (struct main_type): Change type of name,tag_name,
	and fields.name members from char * to const char *.  All uses updated.
	(struct cplus_struct_type): Change type of fn_fieldlists.name member
	from char * to const char *.  All uses updated.
	(type_name_no_tag): Update.
	(lookup_unsigned_typename, lookup_signed_typename): Update.
	* gdbtypes.c (type_name_no_tag): Change result type
	from char * to const char *.  All callers updated.
	(lookup_unsigned_typename, lookup_signed_typename): Change type of
	name parameter from char * to const char *.
	* symtab.h (struct cplus_specific): Change type of demangled_name
	member from char * to const char *.  All uses updated.
	(struct general_symbol_info): Change type of name and
	mangled_lang.demangled_name members from char * to const char *.
	All uses updated.
	(symbol_get_demangled_name, symbol_natural_name): Update.
	(symbol_demangled_name, symbol_search_name): Update.
	* symtab.c (symbol_get_demangled_name): Change result type
	from char * to const char *.  All callers updated.
	(symbol_natural_name, symbol_demangled_name): Ditto.
	(symbol_search_name): Ditto.
	(completion_list_add_name): Change type of symname,sym_text,
	text,word parameters from char * to const char *.
	(completion_list_objc_symbol): Change type of sym_text,
	text,word parameters from char * to const char *.
	* ada-lang.c (find_struct_field): Change type of name parameter
	from char * to const char *.
	(encoded_ordered_before): Similarly for N0,N1 parameters.
	(old_renaming_is_invisible): Similarly for function_name parameter.
	(ada_type_name): Change result type from char * to const char *.
	All callers updated.
	* ada-lang.h (ada_type_name): Update.
	* buildsym.c (hashname): Change type of name parameter
	from char * to const char *.
	* buildsym.h (hashname): Update.
	* dbxread.c (end_psymtab): Change type of include_list parameter
	from char ** to const char **.
	* dwarf2read.c (determine_prefix): Change result type
	from char * to const char *.  All callers updated.
	* f-lang.c (find_common_for_function): Change type of name, funcname
	parameters from char * to const char *.
	* f-lang.c (find_common_for_function): Update.
	* f-valprint.c (list_all_visible_commons): Change type of funcname
	parameters from char * to const char *.
	* gdbarch.sh (static_transform_name): Change type of name parameter
	and result from char * to const char *.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* i386-sol2-tdep.c (i386_sol2_static_transform_name): Change type
	of name parameter from char * to const char *.
	* jv-lang.c (java_primitive_type_from_name): Ditto.
	(java_demangled_signature_length): Similarly for signature parameter.
	(java_demangled_signature_copy): Ditto.
	(java_demangle_type_signature): Ditto.
	* jv-lang.h (java_primitive_type_from_name): Update.
	(java_demangle_type_signature): Update.
	* objc-lang.c (specialcmp): Change type of a,b parameters
	from char * to const char *.
	* p-lang.c (is_pascal_string_type): Change type of arrayname parameter
	from char * to const char *.  All callers updated.
	* p-lang.h (is_pascal_string_type): Update.
	* solib-frv.c (find_canonical_descriptor_in_load_object): Change type
	of name parameter from char * to const char *.
	* sparc-sol2-tdep.c (sparc_sol2_static_transform_name): Ditto.
	* utils.c (fprintf_symbol_filtered): Ditto.
	* defs.h (fprintf_symbol_filtered): Update.
	* sparc-tdep.h (sparc_sol2_static_transform_name): Update.
	* stabsread.h (end_psymtab): Update.
	* stack.c (find_frame_funname): Change type of funname parameter
	from char ** to const char **.
	* stack.h (find_frame_funname): Update.
	* typeprint.c (type_print): Change type of varstring parameter
	from char * to const char *.
	* value.h (type_print): Update.
	* xcoffread.c (xcoff_start_psymtab): Change type of filename parameter
	from char * to const char *.  All callers updated.
	(xcoff_end_psymtab): Change type of include_list parameter
	from char ** to const char **.  All callers updated.
	(swap_sym): Similarly for name parameter.  All callers updated.
	* coffread.c (patch_type): Add (char*) cast to xfree parameter.
	Use xstrdup.
	(process_coff_symbol): Use xstrdup.
	* stabsread.c (stabs_method_name_from_physname): Renamed from
	update_method_name_from_physname.  Change result type from void
	to char *.  All callers updated.
	(read_member_functions): In has_destructor case, store name in objfile
	obstack instead of malloc space.  In !has_stub case, fix mem leak.
@
text
@d989 1
a989 3
  const char *last_csect_name;	/* Last seen csect's name and value.  */
  CORE_ADDR last_csect_val;
  int last_csect_sec;
a998 1
  last_csect_val = 0;
d1171 2
a1172 8
		      if (cs->c_name && (cs->c_name[0] == '.'
					 || cs->c_name[0] == '@@'))
			{
			  last_csect_name = cs->c_name;
			  last_csect_val = cs->c_value;
			  last_csect_sec = secnum_to_section (cs->c_secnum,
							      objfile);
			}
@


1.91
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d885 1
a885 1
  char *namestr;				\
d989 1
a989 1
  char *last_csect_name;	/* Last seen csect's name and value.  */
a1991 4
static struct partial_symtab *xcoff_start_psymtab
  (struct objfile *, char *, int,
   struct partial_symbol **, struct partial_symbol **);

d2000 2
a2001 1
xcoff_start_psymtab (struct objfile *objfile, char *filename, int first_symnum,
a2022 4
static struct partial_symtab *xcoff_end_psymtab
  (struct partial_symtab *, char **, int, int,
   struct partial_symtab **, int, int);

d2032 1
a2032 1
xcoff_end_psymtab (struct partial_symtab *pst, char **include_list,
a2114 4
static void swap_sym (struct internal_syment *,
		      union internal_auxent *, char **, char **,
		      unsigned int *, struct objfile *);

d2121 1
a2121 1
	  char **name, char **raw, unsigned int *symnump,
d2181 1
a2181 1
  char *filestring = NULL;
d2183 1
a2183 1
  char *namestring;
d2193 1
a2193 1
  char **psymtab_include_list;
d2206 1
a2206 1
  char *last_csect_name = NULL;	/* Last seen csect's name and value.  */
d2216 2
a2217 2
  psymtab_include_list = (char **) alloca (includes_allocated *
					   sizeof (char *));
d2611 1
a2611 1
		char **orig = psymtab_include_list;
d2613 1
a2613 1
		psymtab_include_list = (char **)
d2615 1
a2615 1
			  sizeof (char *));
d2617 1
a2617 1
			includes_used * sizeof (char *));
@


1.90
log
@	* xcoffread.c (dwarf2_xcoff_names): Add 'macro' and 'sentinel'
	entries.
	* symfile.h (struct dwarf2_debug_sections) <sentinel>: New field.
	* dwarf2read.c (dwarf2_elf_names): Add sentinel entry.
@
text
@d2 1
a2 3
   Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2007, 2008, 2009,
   2010, 2011 Free Software Foundation, Inc.
@


1.90.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 3
a4 1
   Copyright (C) 1986-2004, 2007-2012 Free Software Foundation, Inc.
@


1.89
log
@2011-06-07  Tristan Gingold  <gingold@@adacore.com>

	* xcoffread.c (dwarf2_xcoff_names): New variable.
	(aix_process_linenos): Add a guard.
	(xcoff_symfile_finish): Free dwarf2.
	(xcoff_initial_scan): Add dwarf2 support.
@
text
@d163 1
d169 2
a170 1
  { NULL, NULL } /* gdb_index */
@


1.88
log
@2011-05-19  Hui Zhu  <teawater@@gmail.com>

	* xcoffread.c (read_xcoff_symtab): Initialize fcn_aux_saved.
@
text
@d155 16
d776 4
d1933 2
d3047 7
@


1.87
log
@* xcoffread.c (process_xcoff_symbol): Remove useless cast.
(scan_xcoff_symtab): Likewise.
@
text
@d964 1
a964 1
  union internal_auxent fcn_aux_saved;
@


1.86
log
@	* xcoffread.c (process_xcoff_symbol): ARI fix: Avoid assignment
	inside if clause.
@
text
@d1591 1
a1591 1
	  pp = (char *) strchr (name, ':');
d2626 1
a2626 1
	    p = (char *) strchr (namestring, ':');
@


1.85
log
@	* xcoffread.c (read_xcoff_symtab): Make `debugfmt' const.
	* symtab.h (struct symtab) <producer, debugformat>: Now const.
	* symmisc.c (free_symtab): Don't free debugformat.
	* buildsym.h (struct subfile) <producer, debugformat>: Now const.
	(record_debugformat, record_producer): Document.
	* buildsym.c (end_symtab): Don't save debugformat and producer
	names on obstack.
	(end_symtab): Don't free debugformat and producer fields.
	(record_debugformat): Don't call xstrdup.
	(record_producer): Likewise.
@
text
@d1588 5
a1592 1
	  if (*name == ':' || (pp = (char *) strchr (name, ':')) == NULL)
@


1.84
log
@	* xcoffread.c (xcoff_sym_fns): Update.
	* symfile.h (struct sym_fns) <sym_read_psymbols>: New field.
	(enum symfile_add_flags) <SYMFILE_NO_READ>: New constant.
	* symfile.c (syms_from_objfile): Handle SYMFILE_NO_READ.
	(symbol_file_add_with_addrs_or_offsets): Likewise.
	(reread_symbols): Handle OBJF_PSYMTABS_READ.
	* somread.c (som_sym_fns): Update.
	* psymtab.h (require_partial_symbols): Declare.
	* psymtab.c (require_partial_symbols): New function.
	(ALL_OBJFILE_PSYMTABS_REQUIRED): New macro.
	(ALL_OBJFILE_PSYMTABS): Undef.
	(ALL_PSYMTABS): Move from psympriv.h.
	(lookup_partial_symtab, find_pc_sect_psymtab)
	(lookup_symbol_aux_psymtabs, relocate_psymtabs)
	(find_last_source_symtab_from_partial)
	(forget_cached_source_info_partial)
	(print_psymtab_stats_for_objfile, read_symtabs_for_function)
	(expand_partial_symbol_tables, read_psymtabs_with_filename)
	(map_symbol_names_psymtab, map_symbol_filenames_psymtab)
	(find_symbol_file_from_partial, map_matching_symbols_psymtab)
	(expand_symtabs_matching_via_partial, maintenance_info_psymtabs):
	Use ALL_OBJFILE_PSYMTABS_REQUIRED.
	* psympriv.h (ALL_PSYMTABS): Move to psymtab.c.
	* objfiles.h (OBJF_PSYMTABS_READ): New macro.
	* objfiles.c (objfile_has_partial_symbols): Handle lazily-read
	psymtabs.
	* mipsread.c (ecoff_sym_fns): Update.
	* machoread.c (macho_sym_fns): Update.
	* elfread.c (elf_symfile_read): Set up for lazy psymtab reading.
	(read_psyms): New function.
	(elf_sym_fns, elf_sym_fns_gdb_index): Update.
	(elf_sym_fns_lazy_psyms): New global.
	* dwarf2read.c (dwarf2_initialize_objfile): Don't call
	dwarf2_build_psymtabs.
	* dbxread.c (aout_sym_fns): Update.
	* coffread.c (coff_sym_fns): Update.
@
text
@d947 1
a947 1
  char *debugfmt = bfd_xcoff_is_xcoff64 (abfd) ? "XCOFF64" : "XCOFF";
@


1.83
log
@2011-01-11  Michael Snyder  <msnyder@@vmware.com>

	* ui-file.c: Comment cleanup, mostly periods and spaces.
	* ui-file.h: Ditto.
	* ui-out.c: Ditto.
	* ui-out.h: Ditto.
	* utils.c: Ditto.
	* v850-tdep.c: Ditto.
	* valarith.c: Ditto.
	* valops.c: Ditto.
	* valprint.c: Ditto.
	* valprint.h: Ditto.
	* value.c: Ditto.
	* value.h: Ditto.
	* varobj.c: Ditto.
	* varobj.h: Ditto.
	* vax-tdep.c: Ditto.
	* vec.c: Ditto.
	* vec.h: Ditto.
	* version.h: Ditto.
	* windows-nat.c: Ditto.
	* windows-tdep.c: Ditto.
	* xcoffread.c: Ditto.
	* xcoffsolib.c: Ditto.
	* xml-support.c: Ditto.
	* xstormy16-tdep.c: Ditto.
	* xtensa-tdep.c: Ditto.
	* xtensa-tdep.h: Ditto.
@
text
@d3087 1
@


1.82
log
@2011-01-05  Michael Snyder  <msnyder@@vmware.com>

	* addrmap.c: Shorten lines of >= 80 columns.
	* arch-utils.c: Ditto.
	* arch-utils.h: Ditto.
	* ax-gdb.c: Ditto.
	* ax-general.c: Ditto.
	* bcache.c: Ditto.
	* blockframe.c: Ditto.
	* breakpoint.c: Ditto.
	* buildsym.c: Ditto.
	* c-lang.c: Ditto.
	* c-typeprint.c: Ditto.
	* charset.c: Ditto.
	* coffread.c: Ditto.
	* command.h: Ditto.
	* corelow.c: Ditto.
	* cp-abi.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* defs.h: Ditto.
	* dfp.c: Ditto.
	* dfp.h: Ditto.
	* dictionary.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* eval.c: Ditto.
	* event-loop.c: Ditto.
	* event-loop.h: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-lang.c: Ditto.
	* f-valprint.c: Ditto.
	* findcmd.c: Ditto.
	* frame-base.c: Ditto.
	* frame-unwind.c: Ditto.
	* frame-unwind.h: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_dirent.h: Ditto.
	* gdb_obstack.h: Ditto.
	* gdbcore.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* inf-ttrace.c: Ditto.
	* infcall.c: Ditto.
	* infcmd.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* inline-frame.h: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* libunwind-frame.c: Ditto.
	* libunwind-frame.h: Ditto.
	* linespec.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-nat.h: Ditto.
	* linux-thread-db.c: Ditto.
	* machoread.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* memattr.c: Ditto.
	* minsyms.c: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* osabi.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* parse.c: Ditto.
	* printcmd.c: Ditto.
	* proc-events.c: Ditto.
	* procfs.c: Ditto.
	* progspace.c: Ditto.
	* progspace.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote-fileio.c: Ditto.
	* remote.c: Ditto.
	* ser-mingw.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* solib-frv.c: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solib-target.c: Ditto.
	* solib.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.c: Ditto.
	* stack.c: Ditto.
	* stack.h: Ditto.
	* symfile-mem.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target-descriptions.c: Ditto.
	* target-memory.c: Ditto.
	* target.c: Ditto.
	* target.h: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* ui-file.c: Ditto.
	* ui-file.h: Ditto.
	* ui-out.h: Ditto.
	* user-regs.c: Ditto.
	* user-regs.h: Ditto.
	* utils.c: Ditto.
	* valarith.c: Ditto.
	* valops.c: Ditto.
	* valprint.c: Ditto.
	* valprint.h: Ditto.
	* value.c: Ditto.
	* varobj.c: Ditto.
	* varobj.h: Ditto.
	* vec.h: Ditto.
	* xcoffread.c: Ditto.
	* xcoffsolib.c: Ditto.
	* xcoffsolib.h: Ditto.
	* xml-syscall.c: Ditto.
	* xml-tdesc.c: Ditto.
@
text
@d84 1
a84 1
/* Remember what we deduced to be the source language of this psymtab. */
d89 1
a89 1
/* Simplified internal version of coff symbol table information */
d94 2
a95 2
    int c_symnum;		/* symbol number of this entry */
    int c_naux;			/* 0 if syment only, 1 if syment + auxent */
d102 1
a102 1
/* last function's saved coff symbol `cs' */
d110 1
a110 1
   symbol. */
d119 1
a119 1
/* initial symbol-table-debug-string vector length */
d136 2
a137 2
    file_ptr min_lineno_offset;	/* Where in file lowest line#s are */
    file_ptr max_lineno_offset;	/* 1+last byte of line#s in file */
d291 1
a291 1
/* add a given stab string into given stab vector. */
d323 1
a323 1
   emission to the end of a compilation unit. This way it can
d325 1
a325 1
   can do some garbage collection (I think). This makes line
d345 1
a345 1
   above table is not sorted on line numbers. And that sort
d354 1
a354 1
   arrange_linetable() will do this sorting.            
d365 1
a365 1
   their scope. They need to be recorded, and processed later
d373 1
a373 1
/* compare line table entry addresses. */
d384 4
a387 3
/* Given a line table with function entries are marked, arrange its functions
   in ascending order and strip off function entry markers and return it in
   a newly created table. If the old one is good enough, return the old one. */
d410 1
a410 1
	{			/* function entry found. */
d412 1
a412 1
	    {			/* make sure you have room. */
d433 1
a433 1
  /* allocate a new line table. */
d439 2
a440 2
  /* if line table does not start with a function beginning, copy up until
     a function begin. */
d448 1
a448 1
  /* Now copy function lines one by one. */
d463 1
a463 1
   following `IncludeChain'. At the end of each symtab (end_symtab),
d465 1
a465 1
   represent if (the include files. */
d477 1
a477 1
  unsigned funStartLine;	/* start line # of its function */
d556 1
a556 1
   at times) process its lines and create appropriate line vectors. */
d586 2
a587 1
    /* All source lines were in the main source file. None in include files. */
d615 1
a615 1
                 file. Add the lines to the main subfile.  */
d658 2
a659 2
      /* Line numbers are not necessarily ordered. xlc compilation will
         put static function to the end. */
d690 2
a691 2
	  /* Line numbers are not necessarily ordered. xlc compilation will
	     put static function to the end. */
d706 1
a706 1
	     while foo.h including code in it. (stupid but possible)
d760 1
a760 1
  /* process line numbers and enter them into line vector */
d861 1
a861 1
   than functions. */
d876 3
a878 3
/* xcoff has static blocks marked in `.bs', `.es' pairs. They cannot be
   nested. At any given time, a symbol can only be in one static block.
   This is the base address of current static block, zero if non exists. */
d886 1
a886 1
/* true if space for symbol name has been allocated. */
d903 1
a903 1
  /* FIXME: is this the same as the passed arg? */
d942 1
a942 1
  char *raw_auxptr;		/* Pointer to first raw aux entry for sym */
d963 1
a963 1
  /* fcn_cs_saved is global because process_xcoff_symbol needs it. */
d967 1
a967 1
  char *filestring = " _start_ ";	/* Name of the current file. */
d969 1
a969 1
  char *last_csect_name;	/* last seen csect's name and value */
d976 1
a976 1
     handling. */
d1000 1
a1000 1
      /* read one symbol into `cs' structure. After processing the
d1002 1
a1002 1
         symbol table and debug section of xcoff will be freed. Thus
d1004 1
a1004 1
         `alloced'. */
d1063 1
a1063 1
      /* if symbol name starts with ".$" or "$", ignore it. */
d1081 1
a1081 1
	  /* done with all files, everything from here on is globals */
d1120 1
a1120 1
		         terms of the space they occupy in memory. Thus, one
d1141 1
a1141 1
		         basically `__start'. */
d1189 1
a1189 1
		  /* a function entry point. */
d1195 1
a1195 1
		     when `.bf' is seen. */
d1201 1
a1201 1
		  /* shared library function trampoline code entry point. */
d1213 1
a1213 1
		     an XTY_LD. This will typically be XMC_RW; I suspect
d1245 1
a1245 1
	     or symnum of first global after last .file. */
d1250 1
a1250 1
	     debugging information. */
d1281 1
a1281 1
	  /* reset file start and end addresses. A compilation unit
d1283 1
a1283 1
	     boundaries. */
d1321 1
a1321 1
		{	/* We attempted to pop an empty context stack */
d1390 3
a1392 3
	     order. Thus, when wee see them, we might not know enough info
	     to process them. Thus, we'll be saving them into a table 
	     (inclTable) and postpone their processing. */
d1415 1
a1415 1
		{	/* We attempted to pop an empty context stack */
d1473 1
a1473 1
/* process one xcoff symbol. */
d1529 1
a1529 1
      /* In case we can't figure out the type, provide default. */
d1722 1
a1722 1
  /* take aux entry and return its lineno */
d1731 1
a1731 1
/* Support for line number handling */
d1780 1
a1780 1
  /* Read in all partial symtabs on which this one is dependent */
d1877 1
a1877 1
  /* Allocate struct to keep track of the symfile */
d1892 1
a1892 1
   objfile struct from the global list of known objfiles. */
d1936 2
a1937 2
  /* Allocate string table from objfile_obstack. We will need this table
     as long as we have its symbol table around. */
d1975 1
a1975 1
   (normal). */
d1994 1
a1994 1
  /* Deduce the source language from the filename for this psymtab. */
d2004 1
a2004 1
/* Close off the current usage of PST.  
d2165 1
a2165 1
  CORE_ADDR toc_offset = 0;	/* toc offset value in data section. */
d2177 1
a2177 1
  /* List of current psymtab's include files */
d2182 1
a2182 1
  /* Index within current psymtab dependency list */
d2191 1
a2191 1
  char *last_csect_name = NULL;	/* last seen csect's name and value */
d2194 1
a2194 1
  int misc_func_recorded = 0;	/* true if any misc. function */
d2268 1
a2268 1
			   seen csect, enter it as a function. This
d2377 1
a2377 1
		       point. */
d2382 1
a2382 1
		       mst_solib_trampoline. */
d2551 1
a2551 1
	    /* Mark down an include file in the current psymtab */
d2570 1
a2570 1
	       and from inline functions in other files. So I check to see
d2654 1
a2654 1
		   wrong.  See the code that reads 'G's for symtabs. */
d2692 1
a2692 1
		if (p != namestring)	/* a name is there, not just :T... */
d2817 1
a2817 1
		   loader-generated definitions.   Keeping the global
d2819 1
a2819 1
		   errors. */
d2889 4
a2892 3
  /* Record the toc offset value of this symbol table into objfile structure.
     If no XMC_TC0 is found, toc_offset should be zero. Another place to obtain
     this information would be file auxiliary header. */
d2915 2
a2916 2
   various sections are (depending where the sections were actually loaded).
*/
d2997 1
a2997 1
  /* If we are reinitializing, or if we have never loaded syms yet, init */
d3017 1
a3017 1
     minimal symbols for this objfile. */
d3036 1
a3036 1
  /* Initialize the section indexes for future use. */
@


1.81
log
@run copyright.sh for 2011.
@
text
@d79 2
a80 1
    /* Position of the start of the line number information for this psymtab.  */
d158 2
a159 1
  complaint (&symfile_complaints, _("line numbers off, `.bf' symbol not found"));
d311 1
a311 1
		    (*stabvector)->length * sizeof (char *));
d414 2
a415 1
		xrealloc (fentry, fentry_size * sizeof (struct linetable_entry));
d429 2
a430 1
    qsort (fentry, function_count, sizeof (struct linetable_entry), compare_lte);
d681 2
a682 1
          && (inclTable[ii].subfile)->line_vector)		/* Useless if!!! FIXMEmgo */
d765 4
a768 2
   enter_line_range (subfile, beginoffset, endoffset, startaddr, 0, firstLine)  or
   enter_line_range (subfile, beginoffset, 0, startaddr, endaddr, firstLine)
d774 2
a775 1
enter_line_range (struct subfile *subfile, unsigned beginoffset, unsigned endoffset,	/* offsets to line table */
d916 2
a917 2
      retval =
	((struct coff_symfile_info *) objfile->deprecated_sym_private)->debugsec
d919 1
a919 2
      raw_symbol +=
	coff_data (objfile->obfd)->local_symesz;
d1070 2
a1071 2
	      pst->symtab =
		end_symtab (cur_src_end_addr, objfile, SECT_OFF_TEXT (objfile));
d1128 2
a1129 1
			  end_symtab (file_end_addr, objfile, SECT_OFF_TEXT (objfile));
d1157 2
a1158 1
			  last_csect_sec = secnum_to_section (cs->c_secnum, objfile);
d1259 6
a1264 5
	  /* XCOFF, according to the AIX 3.2 documentation, puts the filename
	     in cs->c_name.  But xlc 1.3.0.2 has decided to do things the
	     standard COFF way and put it in the auxent.  We use the auxent if
	     the symbol is ".file" and an auxent exists, otherwise use the symbol
	     itself.  Simple enough.  */
d1279 3
a1281 2
	  /* reset file start and end addresses. A compilation unit with no text
	     (only data) should have zero file boundaries. */
d1370 2
a1371 1
	    complaint (&symfile_complaints, _("Unrecognized storage class %d."),
d1413 1
a1413 1
		{		/* We attempted to pop an empty context stack */
d1467 2
a1468 1
  ((ALLOCED) ? (NAME) : obsavestring ((NAME), strlen (NAME), &objfile->objfile_obstack))
d1617 2
a1618 2
    strcpy (buffer,
	    ((struct coff_symfile_info *) objfile->deprecated_sym_private)->strtbl
d1632 5
a1636 4
  int nsyms =
    ((struct coff_symfile_info *) this_symtab_psymtab->objfile->deprecated_sym_private)->symtbl_num_syms;
  char *stbl =
    ((struct coff_symfile_info *) this_symtab_psymtab->objfile->deprecated_sym_private)->symtbl;
d1876 2
a1877 1
  objfile->deprecated_sym_private = xmalloc (sizeof (struct coff_symfile_info));
d1918 2
a1919 1
  ((struct coff_symfile_info *) objfile->deprecated_sym_private)->strtbl = NULL;
d1938 2
a1939 1
  ((struct coff_symfile_info *) objfile->deprecated_sym_private)->strtbl = strtbl;
d1953 2
a1954 1
    error (_("bad symbol file: string table does not end with null character"));
d2026 4
a2029 4
  pst->n_global_syms =
    objfile->global_psymbols.next - (objfile->global_psymbols.list + pst->globals_offset);
  pst->n_static_syms =
    objfile->static_psymbols.next - (objfile->static_psymbols.list + pst->statics_offset);
d2130 2
a2131 2
      *name = ((struct coff_symfile_info *) objfile->deprecated_sym_private)->debugsec
	+ symbol->n_offset;
d2135 2
a2136 2
      *name = ((struct coff_symfile_info *) objfile->deprecated_sym_private)->strtbl
	+ symbol->n_offset;
d2154 2
a2155 1
	     _("function `%s' appears to be defined outside of all compilation units"),
d2213 4
a2216 2
  sraw_symbol = ((struct coff_symfile_info *) objfile->deprecated_sym_private)->symtbl;
  nsyms = ((struct coff_symfile_info *) objfile->deprecated_sym_private)->symtbl_num_syms;
d2340 2
a2341 1
		    /* Make TOC offset relative to start address of section.  */
d2490 2
a2491 1
		       _("Storage class %d not recognized during scan"), sclass);
d2634 2
a2635 1
		symbol.n_value += ANOFFSET (objfile->section_offsets, SECT_OFF_DATA (objfile));
d2649 2
a2650 1
		symbol.n_value += ANOFFSET (objfile->section_offsets, SECT_OFF_DATA (objfile));
d2723 2
a2724 1
		    /* The aix4 compiler emits extra crud before the members.  */
d2790 2
a2791 1
		symbol.n_value += ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));
d2821 2
a2822 1
		symbol.n_value += ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));
d2846 2
a2847 1
	      case '#':		/* for symbol identification (used in live ranges) */
d2861 7
a2867 6
		/* Unexpected symbol descriptor.  The second and subsequent stabs
		   of a continued stab can show up here.  The question is
		   whether they ever can mimic a normal stab--it would be
		   nice if not, since we certainly don't want to spend the
		   time searching to the end of every string looking for
		   a backslash.  */
d2891 2
a2892 1
  ((struct coff_symfile_info *) objfile->deprecated_sym_private)->toc_offset = toc_offset;
d2901 2
a2902 1
    return ((struct coff_symfile_info *) objfile->deprecated_sym_private)->toc_offset;
d2969 3
a2971 2
	((struct coff_symfile_info *) objfile->deprecated_sym_private)->debugsec =
	  debugsec;
d2984 3
a2986 2
  ((struct coff_symfile_info *) objfile->deprecated_sym_private)->symtbl_num_syms =
    num_symbols;
d2988 2
a2989 1
  val = bfd_bread (((struct coff_symfile_info *) objfile->deprecated_sym_private)->symtbl,
d3022 2
a3023 1
xcoff_symfile_offsets (struct objfile *objfile, struct section_addr_info *addrs)
d3081 8
a3088 9
  xcoff_new_init,		/* sym_new_init: init anything gbl to entire symtab */
  xcoff_symfile_init,		/* sym_init: read initial info, setup for sym_read() */
  xcoff_initial_scan,		/* sym_read: read a symbol file into symtab */
  xcoff_symfile_finish,		/* sym_finish: finished with file, cleanup */
  xcoff_symfile_offsets,	/* sym_offsets: xlate offsets ext->int form */
  default_symfile_segments,	/* sym_segments: Get segment information from
				   a file.  */
  aix_process_linenos,          /* sym_read_linetable */
  default_symfile_relocate,	/* sym_relocate: Relocate a debug section.  */
@


1.80
log
@	* symfile.h (struct sym_fns) <next>: Remove.
	(add_symtab_fns): Update.
	* symfile.c (sym_fns_ptr): New typedef.
	(symtab_fns): Now a VEC.
	(add_symtab_fns): Update.  Change argument type.
	(find_sym_fns): Update.  Change return type.
	(get_symfile_segment_data): Update.
	* objfiles.h (struct objfile) <sf>: Now const.
	* somread.c (som_sym_fns): Now const.  Update.
	* xcoffread.c (xcoff_sym_fns): Now const.  Update.
	* mipsread.c (ecoff_sym_fns): Now const.  Update.
	* machoread.c (macho_sym_fns): Now const.  Update.
	* elfread.c (elf_sym_fns): Now const.  Update.
	(elf_sym_fns_gdb_index): Likewise.
	* dbxread.c (aout_sym_fns): Now const.  Update.
	* coffread.c (coff_sym_fns): Now const.  Update.
@
text
@d4 1
a4 1
   2010 Free Software Foundation, Inc.
@


1.79
log
@2010-05-17  Michael Snyder  <msnyder@@vmware.com>

	* valarith.c: White space.
	* valops.c: White space.
	* valprint.c: White space.
	* value.c: White space.
	* varobj.c: White space.
	* xcoffread.c: White space.
	* xml-support.c: White space.
	* xml-tdesc.c: White space.
@
text
@d3031 1
a3031 1
static struct sym_fns xcoff_sym_fns =
d3054 1
a3054 2
  &psym_functions,
  NULL				/* next: pointer to next struct sym_fns */
@


1.78
log
@	* xcoffread.c (xcoff_start_psymtab): Update.
	(xcoff_end_psymtab): Update.
	* psymtab.c (allocate_psymtab): Remove dead code.
	* psympriv.h (struct partial_symtab) <read_symtab_private>: Now
	void*.
	* mdebugread.c (parse_partial_symbols): Update.
	(new_psymtab): Likewise.
	* dwarf2read.c (process_psymtab_comp_unit): Update.
	(psymtab_to_symtab_1): Update.
	* dbxread.c (start_psymtab): Update.
	(end_psymtab): Likewise.
@
text
@d243 1
d262 1
d278 1
d378 1
a405 1

a407 1

d558 2
a559 2
  ((struct coff_symfile_info *) this_symtab_psymtab->objfile->deprecated_sym_private)
  ->max_lineno_offset;
a618 1

d712 1
d856 7
a862 5
  namestr = (NAME); \
  if (namestr[0] == '.') ++namestr; \
  prim_record_minimal_symbol_and_info (namestr, (ADDR), (TYPE), \
				       (SECTION), (asection *)NULL, (OBJFILE)); \
  misc_func_recorded = 1;					\
d892 1
d934 2
a935 1
  char *strtbl = ((struct coff_symfile_info *) objfile->deprecated_sym_private)->strtbl;
d937 1
a937 1
  ((struct coff_symfile_info *) objfile->deprecated_sym_private)->debugsec;
a987 1

d1016 1
a1230 1

d1283 1
a1298 1

d1308 1
a1308 1
		{		/* We attempted to pop an empty context stack */
d1620 1
a1620 1
  ((struct coff_symfile_info *) this_symtab_psymtab->objfile->deprecated_sym_private)->symtbl_num_syms;
d1622 2
a1623 1
  ((struct coff_symfile_info *) this_symtab_psymtab->objfile->deprecated_sym_private)->symtbl;
d1695 1
d1963 5
a1967 5
  start_psymtab_common (objfile, objfile->section_offsets,
			filename,
			/* We fill in textlow later.  */
			0,
			global_syms, static_syms);
d2028 1
a2028 1
      allocate_psymtab (include_list[i], objfile);
d2099 1
d2292 2
a2293 1
			symbol.n_value + csect_aux.x_csect.x_scnlen.l;
a2424 1

d2518 1
d2528 1
d2555 1
d2558 1
d2593 1
d2758 1
d2780 1
@


1.77
log
@gdb
	* xcoffread.c: Include psymtab.h.
	(xcoff_sym_fns): Update.
	* symtab.h (struct partial_symbol): Remove.
	(PSYMBOL_DOMAIN, PSYMBOL_CLASS): Remove.
	(struct partial_symtab): Remove.
	(PSYMTAB_TO_SYMTAB): Remove.
	(lookup_partial_symbol, lookup_partial_symtab, find_pc_psymtab)
	(find_pc_sect_psymtab): Remove.
	(find_pc_sect_symtab_via_partial): Declare.
	(find_pc_psymtab, find_pc_sect_psymbol, psymtab_to_symtab)
	(find_main_psymtab): Remove.
	(find_main_filename): Declare.
	(fixup_psymbol_section): Remove.
	(fixup_section): Declare.
	* symtab.c: Include psymtab.h.
	(lookup_symtab): Use lookup_symtab method.
	(lookup_partial_symtab): Remove.
	(find_pc_sect_psymtab_closer): Remove.
	(find_pc_sect_psymtab): Remove.
	(find_pc_sect_symtab_via_partial): New function.
	(find_pc_psymtab, find_pc_sect_psymbol, find_pc_psymbol): Remove.
	(fixup_section): No longer static.
	(fixup_psymbol_section): Remove.
	(lookup_symbol_aux): Use lookup_symbol_aux_quick.
	(lookup_global_symbol_from_objfile): Likewise.
	(lookup_symbol_aux_psymtabs): Remove.
	(lookup_symbol_aux_quick): New function.
	(lookup_symbol_global): Use lookup_symbol_aux_quick.
	(lookup_partial_symbol): Remove.
	(basic_lookup_transparent_type_quick): New function.
	(basic_lookup_transparent_type): Use it.
	(find_main_psymtab): Remove.
	(find_main_filename): New function.
	(find_pc_sect_symtab): Use find_pc_sect_symtab method.
	(find_line_symtab): Use expand_symtabs_with_filename method.
	(output_partial_symbol_filename): New function.
	(sources_info): Use map_partial_symbol_filenames.
	(struct search_symbols_data): New type.
	(search_symbols_file_matches): New function.
	(search_symbols_name_matches): Likewise.
	(search_symbols): Use expand_symtabs_matching method.
	(struct add_name_data): Rename from add_macro_name_data.
	(add_macro_name): Update.
	(add_partial_symbol_name): New function.
	(default_make_symbol_completion_list): Use
	map_partial_symbol_names.
	(struct add_partial_symbol_name): New type.
	(maybe_add_partial_symtab_filename): New function.
	(make_source_files_completion_list): Use
	map_partial_symbol_filenames.
	(expand_line_sal): Use expand_symtabs_with_filename method.
	* symmisc.c: Include psymtab.h.
	(print_objfile_statistics): Use print_stats method.
	(dump_objfile): Use dump method.
	(dump_psymtab, maintenance_print_psymbols)
	(maintenance_info_psymtabs, maintenance_check_symtabs)
	(extend_psymbol_list): Remove.
	* symfile.h (struct quick_symbol_functions): New struct.
	(struct sym_fns) <qf>: New field.
	(sort_pst_symbols): Remove.
	(increment_reading_symtab): Declare.
	* symfile.c: Include psymtab.h.
	(compare_psymbols, sort_pst_symbols): Remove.
	(psymtab_to_symtab): Remove.
	(increment_reading_symtab): New function.
	(symbol_file_add_with_addrs_or_offsets): Use expand_all_symtabs
	method.
	(set_initial_language): Use find_main_filename.
	(allocate_psymtab, discard_psymtab, cashier_psymtab): Remove.
	(free_named_symtabs): Remove unused code.
	(start_psymtab_common, add_psymbol_to_bcache)
	(append_psymbol_to_list, add_psymbol_to_list, init_psymbol_list):
	Remove.
	* stack.c: Include psymtab.h, symfile.h.
	(backtrace_command_1): Use find_pc_sect_symtab_via_partial.
	* source.h (psymtab_to_fullname): Don't declare.
	* source.c: Include psymtab.h.
	(select_source_symtab): Use find_last_source_symtab method.
	(forget_cached_source_info): Use forget_cached_source_info
	method.
	(find_and_open_source): No longer static.
	(psymtab_to_fullname): Remove.
	* somread.c: Include psymtab.h.
	(som_sym_fns): Update.
	* psympriv.h: New file.
	* psymtab.h: New file.
	* psymtab.c: New file.
	* objfiles.h: (ALL_OBJFILE_PSYMTABS): Remove.
	(ALL_PSYMTABS, ALL_PSPACE_PSYMTABS): Likewise.
	* objfiles.c: Include psymtab.h.
	(objfile_relocate1): Use relocate method.
	(objfile_has_partial_symbols): Use has_symbols method.
	* mipsread.c: Include psymtab.h.
	(ecoff_sym_fns): Update.
	* mi/mi-cmd-file.c: Include psymtab.h.
	(print_partial_file_name): New function.
	(mi_cmd_file_list_exec_source_files): Use
	map_partial_symbol_filenames.
	* mdebugread.c: Include psympriv.h.
	* machoread.c: Include psympriv.h.
	(macho_sym_fns): Update.
	* m2-exp.y (yylex): Use lookup_symtab.
	* elfread.c: Include psympriv.h.
	(elf_sym_fns): Update.
	* dwarf2read.c: Include psympriv.h.
	* dbxread.c: Include psympriv.h.
	(aout_sym_fns): Update.
	* cp-support.c: Include psymtab.h.
	(read_in_psymtabs): Remove.
	(make_symbol_overload_list_qualified): Use
	expand_symtabs_for_function method.
	* coffread.c: Include psympriv.h.
	(coff_sym_fns): Update.
	* blockframe.c: Include psymtab.h.
	(find_pc_partial_function): Use find_pc_sect_symtab method.
	* ada-lang.h (ada_update_initial_language): Update.
	* ada-lang.c: Include psymtab.h.
	(ada_update_initial_language): Remove 'main_pst' argument.
	(ada_lookup_partial_symbol): Remove.
	(struct ada_psym_data): New type.
	(ada_add_psyms): New function.
	(ada_add_non_local_symbols): Use map_ada_symtabs method.
	(struct add_partial_datum): New type.
	(ada_add_partial_symbol_completions): New function.
	(ada_make_symbol_completion_list): Use map_partial_symbol_names.
	(ada_exception_support_info_sniffer): Update.
	* Makefile.in (SFILES): Add psymtab.c.
	(COMMON_OBS): Add psymtab.o.
	(HFILES_NO_SRCDIR): Add psymtab.h, psympriv.h.
gdb/doc
	* gdbint.texinfo (Symbol Handling): Update.
@
text
@d1962 2
a1963 2
  result->read_symtab_private = (char *)
    obstack_alloc (&objfile->objfile_obstack, sizeof (struct symloc));
d2024 2
a2025 3
      subpst->read_symtab_private =
	(char *) obstack_alloc (&objfile->objfile_obstack,
				sizeof (struct symloc));
@


1.76
log
@2010-02-03  Tristan Gingold  <gingold@@adacore.com>

	* symfile.h (struct sym_fns): Add sym_relocate field.
	(default_symfile_relocate): New prototype.
	(symfile_relocate_debug_section): First argument is now an objfile.
	* symfile.c (default_symfile_relocate): Rename from
	symfile_relocate_debug_section, first argument is now an objfile.
	(symfile_relocate_debug_section): New function.
	* coffread.c (coff_sym_fns): Set sym_relocate field.
	* somread.c (som_sym_fns): Ditto.
	* mipsread.c (ecoff_sym_fns): Ditto.
	* machoread.c (macho_sym_fns): Ditto.
	* elfread.c (elf_sym_fns): Ditto.
	* dwarf2read.c (dwarf2_read_section): Ditto.
	* xcoffread.c (xcoff_sym_fns): Ditto.
	* dbxread.c (aout_sym_fns): Ditto.
	(dbx_psymtab_to_symtab): Adjust call to symfile_relocate_debug_section.
	(elfstab_build_psymtabs): Ditto.
@
text
@d53 1
d3040 1
@


1.75
log
@Delete free_named_symtabs and associated cleanup.

        * symfile.h (free_named_symtabs): Delete declaration.
        * symfile.c: Remove some commented out code (clear_symtab_users_once).
        (cashier_psymtab): Comment function out.
        Delete declaration.
        (free_named_symtabs): Delete.
        * coffread.c (coff_end_symtab): Remove call to free_named_symtabs.
        * dbxread.c (end_psymtab): Likewise.
        * dwarf2read.c (process_psymtab_comp_unit): Ditto.
        * exec.c (exec_close_1): Ditto.
        * xcoffread.c (xcoff_end_psymtab): Likewise.
@
text
@d3038 1
@


1.74
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@a2050 5
  /* If there is already a psymtab or symtab for a file of this name,
     remove it.  (If there is a symtab, more drastic things also
     happen.)  This happens in VxWorks.  */
  free_named_symtabs (pst->filename);

@


1.73
log
@2009-12-07  Tristan Gingold  <gingold@@adacore.com>

	* symfile.h (struct sym_fns): Adjust comment on sym_read.
	* symfile.c (syms_from_objfile): Pass all symfile flags to sym_read.
	* dbxread.c (dbx_symfile_read): Rename mainline to symfile_flags,
	adjust header comment.
	* elfread.c (elf_symfile_read): Ditto.
	* somread.c (som_symfile_read): Ditto.
	* xcoffread.c (xcoff_initial_scan): Ditto.
	* coffread.c (coff_symfile_read): Rename mainline to symfile_flags.
	* machoread.c (macho_symfile_read): Ditto.
	* mipsread.c (mipscoff_symfile_read): Ditto.
@
text
@d3 2
a4 2
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2007, 2008, 2009
   Free Software Foundation, Inc.
@


1.72
log
@2009-12-07  Tristan Gingold  <gingold@@adacore.com>

	* dbxread.c (dbx_symfile_read): No need to test mainline to call
	init_psymbol_list.
	* xcoffread.c (xcoff_initial_scan): Ditto;
	* coffread.c (coff_symfile_read): Remove call to init_psymbol_list.
	* elfread.c (elf_symfile_read): Ditto.
	* machoread.c (macho_symfile_read): Ditto.
@
text
@d2871 1
a2871 2
   MAINLINE is true if we are reading the main symbol
   table (as opposed to a shared lib or dynamically loaded file).  */
d2874 1
a2874 1
xcoff_initial_scan (struct objfile *objfile, int mainline)
@


1.71
log
@	* xcoffread.c (scan_xcoff_symtab): Update.
	* symfile.h (add_psymbol_to_list): Update prototype.
	* symfile.c (add_psymbol_to_bcache): Add copy_name argument.
	(add_psymbol_to_list): Likewise.
	* stabsread.c (define_symbol): Update.
	* mdebugread.c (parse_partial_symbols): Update.
	(handle_psymbol_enumerators): Update.
	(new_symbol): Update.
	* dbxread.c (read_dbx_symtab): Update.
	* coffread.c (process_coff_symbol): Update.
	* symtab.h (prim_record_minimal_symbol_full): Declare.
	(SYMBOL_SET_NAMES): Add copy_name argument.
	* symtab.c (struct demangled_name_entry): New struct.
	(hash_demangled_name_entry): New function.
	(eq_demangled_name_entry): Likewise.
	(create_demangled_names_hash): Use new functions.
	(symbol_set_names): Use struct demangled_name_entry.  Add
	copy_name argument.
	* minsyms.c (prim_record_minimal_symbol_full): New function.
	(prim_record_minimal_symbol_and_info): Use it.
	* elfread.c (record_minimal_symbol): Add name_len and copy_name
	arguments.  Call prim_record_minimal_symbol_full.
	(elf_symtab_read): Add copy_names argument.
	(elf_symfile_read): Update calls to elf_symtab_read.
	* dwarf2read.c (add_partial_symbol): Don't copy symbol names.
	(load_partial_dies): Likewise.
	(new_symbol): Likewise.
	* cp-namespace.c (check_one_possible_namespace_symbol): Don't save
	name on the obstack.  Update call to SYMBOL_SET_NAMES.
@
text
@d2951 1
a2951 3
  if (mainline
      || (objfile->global_psymbols.size == 0
	  && objfile->static_psymbols.size == 0))
@


1.70
log
@	* gdbtypes.h (struct builtin_type): Remove builtin_core_addr,
	nodebug_text_symbol, nodebug_data_symbol, nodebug_unknown_symbol,
	and nodebug_tls_symbol members.
	(struct objfile_type): New data structure.
	(objfile_type): Add prototype.
	* gdbtypes.c (gdbtypes_post_init): Remove initialization code
	for types no longer in struct builtin_type.
	(objfile_type_data): New static variable.
	(_initialize_gdbtypes): Initialize it.
	(objfile_type): New function.

	* gdbtypes.h (builtin_type_error): Remove.
	* gdbtypes.c (build_complex): Do not use builtin_type_error.
	* symtab.c (builtin_type_error): Remove.
	(_initialize_symtab): Remove initialization.

	* stabsread.c (dbx_lookup_type, define_symbol, error_type,
	rs6000_builtin_type, read_range_type): Use per-objfile types
	instead of global or per-architecture builtin types.
	* coffread.c (decode_type): Likewise.
	* dwarf2read.c (read_array_type, read_tag_string_type,
	new_symbol, die_type): Likewise.
	* mdebugread.c (parse_symbol, basic_type, upgrade_type,
	parse_procedure, psymtab_to_symtab_1): Likewise.
	* xcoffread.c (process_xcoff_symbol): Likewise.
	* parse.c (write_exp_msymbol): Likewise.

	* stabsread.c (rs6000_builtin_type_data): New static variable.
	(_initialize_stabsread): Initialize it.
	(rs6000_builtin_type): Add OBJFILE argument.  Allocate builtin
	types per-objfile instead of globally.

	* stabsread.c (dbx_lookup_type): Add OBJFILE argument.  Use it
	instead of current_objfile; pass it to rs6000_builtin_type.
	(dbx_alloc_type, read_type, read_range_type): Update calls.
	(cleanup_undefined_types_noname): Add OBJFILE argument and
	pass it to dbx_lookup_type.
	(cleanup_undefined_types): Add OBJFILE argument and pass it
	to cleanup_undefined_types_noname.
	* stabsread.h (cleanup_undefined_types): Add OBJFILE argument.
	* buildsym.c (end_symtab): Update call.
@
text
@d2609 1
a2609 1
		add_psymbol_to_list (namestring, p - namestring,
d2620 1
a2620 1
		add_psymbol_to_list (namestring, p - namestring,
d2638 1
a2638 1
		    add_psymbol_to_list (namestring, p - namestring,
d2646 1
a2646 1
			add_psymbol_to_list (namestring, p - namestring,
d2659 1
a2659 1
		    add_psymbol_to_list (namestring, p - namestring,
d2721 1
a2721 1
			add_psymbol_to_list (p, q - p,
d2739 1
a2739 1
		add_psymbol_to_list (namestring, p - namestring,
d2756 1
a2756 1
		add_psymbol_to_list (namestring, p - namestring,
d2785 1
a2785 1
		add_psymbol_to_list (namestring, p - namestring,
@


1.69
log
@	* buildsym.c (record_line): Remove call to gdbarch_addr_bits_remove.

	* coffread.c (coff_symtab_read): Call gdbarch_addr_bits_remove before
	calling record_line.
	(enter_linenos): Likewise.
	* dbxread.c (process_one_symbol): Likewise.
	* dwarf2read.c (dwarf_decode_lines): Likewise.
	* mdebugread.c (psymtab_to_symtab_1): Likewise.
	* xcoffread.c (enter_line_range): Likewise.
@
text
@a1456 1
  struct gdbarch *gdbarch = get_objfile_arch (objfile);
d1496 1
a1496 1
      SYMBOL_TYPE (sym) = builtin_type (gdbarch)->nodebug_text_symbol;
d1509 1
a1509 1
      SYMBOL_TYPE (sym) = builtin_type (gdbarch)->nodebug_data_symbol;
@


1.68
log
@gdb/
	Replace the savestring calls by xstrdup calls where possible.
	* breakpoint.c (condition_command, set_raw_breakpoint)
	(create_catchpoint, update_breakpoint_locations): Replace the
	savestring calls by xstrdup calls where possible.
	* buildsym.c (start_subfile, patch_subfile_names, record_debugformat)
	(record_producer): Likewise.
	* coffread.c (coff_start_symtab, complete_symtab): Likewise.
	* corefile.c (set_gnutarget): Likewise.
	* dbxread.c (add_new_header_file): Likewise.
	* demangle.c (set_demangling_command, set_demangling_style): Likewise.
	* event-top.c (push_prompt, pop_prompt, command_line_handler)
	(set_async_prompt): Likewise.
	* infcmd.c (set_inferior_io_terminal, attach_command_post_wait):
	Likewise.
	* language.c (set_language_command, _initialize_language): Likewise.
	* linespec.c (decode_line_2): Likewise.
	* rs6000-nat.c (add_vmap): Likewise.
	* top.c (set_prompt, init_history, init_main): Likewise.
	* tracepoint.c (stringify_collection_list): Likewise.
	* varobj.c (varobj_create): Remove variable expr_len.  Replace the
	savestring calls by xstrdup calls where possible.
	(value_of_root, c_name_of_variable, c_describe_child): Replace the
	savestring calls by xstrdup calls where possible.
	* xcoffread.c (complete_symtab): Likewise.
	* cli/cli-script.c (build_command_line, define_command): Likewise.
	* cli/cli-setshow.c (do_setshow_command): Likewise.
@
text
@d768 2
d782 1
a782 1
    ((struct coff_symfile_info *) this_symtab_psymtab->objfile->deprecated_sym_private)
d798 1
a798 1
  abfd = this_symtab_psymtab->objfile->obfd;
d812 1
a812 2
      addr += ANOFFSET (this_symtab_psymtab->objfile->section_offsets,
			SECT_OFF_TEXT (this_symtab_psymtab->objfile));
d820 1
a820 1
	  record_line (subfile, 0, addr);
d824 2
a825 1
	record_line (subfile, *firstLine + int_lnno.l_lnno, addr);
@


1.67
log
@        * xcoffread.c (process_linenos): Check if the line in the
        include table refers to the main source file and, if so,
        add them to the main subfile.
@
text
@d834 2
a835 2
  last_source_file = savestring (name, strlen (name));	\
  last_source_start_addr = start_addr;			\
@


1.66
log
@	Silence a few -Wmissing-prototypes warnings.

	PR build/9877:
        * alpha-linux-tdep.c (alpha_linux_regset_from_core_section): Make
	it static.
        * alpha-osf1-tdep.c (_initialize_alpha_osf1_tdep): Declare.
        * amd64fbsd-tdep.c (amd64fbsd_init_abi): Make it static.
        * amd64nbsd-tdep.c (_initialize_amd64nbsd_ndep): Rename to ...
	(_initialize_amd64nbsd_tdep): ... this.
	* arm-linux-tdep.c (arm_linux_software_single_step): Make it static.
	(_initialize_arm_linux_tdep): Declare.
	* armbsd-tdep.c (armbsd_fpreg_offset): Make it static.
	* armnbsd-tdep.c (_initialize_arm_netbsd_tdep): Declare.
	* armobsd-tdep.c (_initialize_armobsd_tdep): Declare.
	* avr-tdep.c (avr_return_value): Make it static.
	(avr_frame_unwind_cache): Ditto.
	* bsd-uthread.c (bsd_uthread_inferior_created): Ditto.
	(bsd_uthread_solib_loaded): Ditto.
	(bsd_uthread_solib_unloaded): Ditto.
	(bsd_uthread_target): Ditto.
	(_initialize_bsd_uthread): Declare.
	* cris-tdep.c (crisv32_single_step_through_delay): Make it static.
	(cris_frame_unwind_cache): Ditto.
	* frv-tdep.c (frv_return_value): Ditto.
	* h8300-tdep.c (h8300_use_struct_convention): Ditto.
	(h8300h_use_struct_convention): Ditto.
	* hppa-tdep.c (hppa_sign_extend, hppa_low_hppa_sign_extend):
	Ditto.
	* hppa-tdep.h (hppa_low_sign_extend, hppa_sign_extend): Delete
	declarations.
	* hppabsd-tdep.c: Include hppabsd-tdep.h.
	(hppabsd_find_global_pointer): Make it static.
	* hppabsd-tdep.h: New.
	* hppanbsd-tdep.c: Include hppabsd-tdep.h.
	(hppabsd_init_abi): Remove declaration.
	(_initialize_hppabsd_tdep): Remove declaration.
	(_initialize_hppanbsd_tdep): Declare.
	* hppaobsd-tdep.c: Include hppabsd-tdep.h.
	(hppabsd_init_abi): Delete declaration.
	(hppaobsd_init_abi): Make it static.
	* i386-nto-tdep.c (_initialize_i386nto_tdep): Declare.
	* i386nbsd-tdep.c (_initialize_i386nbsd_tdep): Declare.
	* ia64-linux-tdep.c (_initialize_ia64_linux_tdep): Declare.
	* ia64-tdep.c (ia64_register_reggroup_p): Make it static.
	* iq2000-tdep.c (_initialize_iq2000_tdep): Declare.
	* m32c-tdep.c (m32c_register_reggroup_p): Make it static.
	(m32c_analyze_prologue, m32c_virtual_frame_pointer): Ditto.
	(_initialize_m32c_tdep): Declare.
	* m32r-rom.c (_initialize_m32r_rom): Declare.
	* m32r-tdep.c (m32r_skip_prologue): Make it static.
	(m32r_return_value): Ditto.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache): Make it static.
	(m68hc11_return_value): Ditto.
	* m68klinux-tdep.c (_initialize_m68k_linux_tdep): Declare.
	* m88k-tdep.c (m88k_frame_cache): Make it static.
	* mep-tdep.c (mep_gdb_print_insn): Ditto.
	(mep_return_value): Ditto.
	(_initialize_mep_tdep): Declare.
	* mips-irix-tdep.c (_initialize_mips_irix_tdep): Declare.
	* mips-linux-tdep.c (supply_64bit_reg): Make it static.
	(mips_linux_syscall_next_pc): Ditto.
	(_initialize_mips_linux_tdep): Declare.
	* mips-tdep.c (mips_single_step_through_delay): Make it static.
	* mipsnbsd-tdep.c (_initialize_mipsnbsd_tdep): Declare.
	* mn10300-linux-tdep.c (_initialize_mn10300_linux_tdep): Declare.
	* mn10300-tdep.c (_initialize_mn10300_tdep): Declare.
	* mt-tdep.c (_initialize_mt_tdep): Declare.
	* nbsd-tdep.c: Include nbsd-tdep.h.
	* nto-tdep.c (find_load_phdr): Make it static.
	(_initialize_nto_tdep): Declare.
	* ppc-linux-tdep.c (ppc_linux_memory_remove_breakpoint): Make it
	static.
	(_initialize_ppc_linux_tdep): Declare.
	* remote-m32r-sdi.c (m32r_can_use_hw_watchpoint)
	(m32r_insert_watchpoint, m32r_remove_watchpoint)
	(m32r_stopped_data_address, m32r_stopped_by_watchpoint): Make
	static.
	* rs6000-aix-tdep.c (_initialize_rs6000_aix_tdep): Declare.
	* rs6000-nat.c: Include xcoffread.h.
	(find_toc_address): Don't extern declare get_toc_offset.  Adjust
	to call xcoff_get_to_offset.
	* rs6000-tdep.c (ppc_vsx_support_p, ppc_displaced_step_fixup)
	(rs6000_skip_main_prologue, rs6000_in_solib_return_trampoline)
	(rs6000_skip_trampoline_code): Make static.
	* s390-tdep.c (s390_regset_from_core_section): Ditto.
	* sh-tdep.c (sh_register_reggroup_p): Ditto.
	* shnbsd-tdep.c (shnbsd_regset_from_core_section): Ditto.
	(_initialize_shnbsd_tdep): Declare.
	* solib-frv.c (displacement_from_map): Make static.
	(_initialize_frv_solib): Declare.
	* solib-irix.c (fetch_lm_info): Make static.
	(_initialize_irix_solib): Declare.
	* solib-som.c: Include solib-som.h.
	(som_solib_select): Line break.
	* sparc-tdep.c (sparc_regset_from_core_section): Make static.
	* sparcnbsd-tdep.c (_initialize_sparnbsd_tdep): Rename to ...
	(_initialize_sparcnbsd_tdep): ... this.
	* spu-tdep.c (spu_software_single_step): Make it static.
	(_initialize_spu_tdep): Declare.
	* vax-tdep.c (vax_frame_cache): Make it static.
	* xcoffread.c: Include xcoffread.h.
	(get_toc_offset): Rename to ...
	(xcoff_get_toc_offset): ... this.
	(_initialize_xcoffread): Declare.
	* xcoffread.h: New.
	* xtensa-linux-tdep.c (_initialize_xtensa_linux_tdep): Declare.
	* xtensa-tdep.c (xtensa_skip_prologue, xtensa_derive_tdep): Make
	static.
	(_initialize_xtensa_tdep): Declare.
@
text
@d603 4
a606 1
	  /* Have a new subfile for the include file.  */
d608 8
a615 2
	  tmpSubfile = inclTable[ii].subfile =
	    (struct subfile *) xmalloc (sizeof (struct subfile));
d617 1
a617 2
	  memset (tmpSubfile, '\0', sizeof (struct subfile));
	  firstLine = &(inclTable[ii].funStartLine);
d619 10
a628 3
	  /* Enter include file's lines now.  */
	  enter_line_range (tmpSubfile, inclTable[ii].begin,
			    inclTable[ii].end, start, 0, firstLine);
d674 2
a675 1
      if ((inclTable[ii].subfile)->line_vector)		/* Useless if!!! FIXMEmgo */
@


1.65
log
@        Updated copyright notices for most files.
@
text
@d42 1
d2840 1
a2840 1
get_toc_offset (struct objfile *objfile)
d3032 3
@


1.64
log
@	* xcoffread.c (RECORD_MINIMAL_SYMBOL): Update.
	(scan_xcoff_symtab): Update.
	* mdebugread.c (record_minimal_symbol): Update.
	(parse_partial_symbols): Update.
	* elfread.c (record_minimal_symbol): Update.
	* dbxread.c (record_minimal_symbol): Update.
	* coffread.c (record_minimal_symbol): Update.
	* sh64-tdep.c (MSYMBOL_IS_SPECIAL): Redefine.
	(sh64_elf_make_msymbol_special): Update.
	* mips-tdep.c (mips_elf_make_msymbol_special): Use
	MSYMBOL_TARGET_FLAG_1.
	(mips_elf_make_msymbol_special): Likewise.
	(msymbol_is_special): Likewise.
	* minsyms.c (prim_record_minimal_symbol_and_info): Update.
	(install_minimal_symbols): Likewise.
	(prim_record_minimal_symbol): Update.
	(prim_record_minimal_symbol_and_info): Remove 'info' argument.
	* m68hc11-tdep.c (MSYMBOL_SET_RTC): Redefine.
	(MSYMBOL_SET_RTI): Redefine.
	(MSYMBOL_IS_RTC): Redefine.
	(MSYMBOL_IS_RTI): Redefine.
	* arm-tdep.c (MSYMBOL_SET_SPECIAL): Redefine.
	(MSYMBOL_IS_SPECIAL): Redefine.
	* symtab.h (struct minimal_symbol) <info>: Remove.
	<target_flag_1, target_flag_2>: New fields.
	(MSYMBOL_INFO): Remove.
	(MSYMBOL_TARGET_FLAG_1): New macro.
	(MSYMBOL_TARGET_FLAG_2): Likewise.
	(prim_record_minimal_symbol_and_info): Update.
@
text
@d3 1
a3 1
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2007, 2008
@


1.63
log
@	* xcoffread.c (SYMNAME_ALLOC): Correct syntax.
@
text
@d837 1
a837 1
				       (char *)NULL, (SECTION), (asection *)NULL, (OBJFILE)); \
d2288 1
a2288 1
			 NULL, secnum_to_section (symbol.n_scnum, objfile),
d2363 1
a2363 1
			 NULL, secnum_to_section (symbol.n_scnum, objfile),
d2380 1
a2380 1
			 NULL, secnum_to_section (symbol.n_scnum, objfile),
@


1.62
log
@	* ax-gdb.c (gen_var_ref): Use SYMBOL_LINKAGE_NAME.
	* blockframe.c (find_pc_partial_function): Likewise.
	* buildsym.c (find_symbol_in_list): Likewise.
	* c-valprint.c (c_val_print): Likewise.
	* coffread.c (patch_opaque_types, process_coff_symbol): Likewise.
	(coff_read_enum_type): Likewise.  Use SYMBOL_SET_LINKAGE_NAME.
	* cp-support.c (cp_remove_params): Renamed from remove_params and
	made global.
	(overload_list_add_symbol): Update call to remove_params.
	* cp-support.h (cp_remove_params): Declare.
	* dwarf2read.c (process_enumeration_scope): Use SYMBOL_LINKAGE_NAME.
	(dwarf2_const_value): Use SYMBOL_PRINT_NAME.
	* expprint.c (dump_subexp_body_standard): Likewise.
	* f-valprint.c (info_common_command, there_is_a_visible_common_named):
	Use SYMBOL_LINKAGE_NAME to find symbols and SYMBOL_PRINT_NAME
	for messages.
	* findvar.c (read_var_value): Use SYMBOL_LINKAGE_NAME.
	* gnu-v2-abi.c (gnuv2_value_rtti_type): Likewise.
	* hppa-hpux-tdep.c (hppa32_hpux_in_solib_call_trampoline)
	(hppa_hpux_skip_trampoline_code): Use SYMBOL_LINKAGE_NAME to find
	symbols and SYMBOL_PRINT_NAME for messages.
	* jv-lang.c (add_class_symbol): Use SYMBOL_SET_LINKAGE_NAME.
	* linespec.c (decode_line_2): Use SYMBOL_LINKAGE_NAME.
	* mdebugread.c (parse_symbol): Use SYMBOL_LINKAGE_NAME and
	SYMBOL_SET_LINKAGE_NAME.
	(mylookup_symbol): Use SYMBOL_LINKAGE_NAME.
	* minsyms.c (add_minsym_to_demangled_hash_table): Use
	SYMBOL_SEARCH_NAME.
	(lookup_minimal_symbol): Use SYMBOL_LINKAGE_NAME or
	SYMBOL_MATCHES_SEARCH_NAME, depending on the pass.
	* objfiles.h (ALL_OBJFILE_MSYMBOLS): Use SYMBOL_LINKAGE_NAME.
	* printcmd.c (build_address_symbolic): Use SYMBOL_LINKAGE_NAME.
	(address_info): Use SYMBOL_PRINT_NAME for messages and
	SYMBOL_LINKAGE_NAME for lookups.
	* sol-thread.c (info_cb): Use SYMBOL_PRINT_NAME for messages.
	* stabsread.c (patch_block_stabs, define_symbol)
	(read_type, read_enum_type, common_block_end)
	(cleanup_undefined_types_1, scan_file_globals): Use
	SYMBOL_LINKAGE_NAME, SYMBOL_SET_LINKAGE_NAME, ALL_OBJFILE_MSYMBOLS,
	and SYMBOL_PRINT_NAME.
	* stack.c (print_frame_args): Use SYMBOL_LINKAGE_NAME.
	(print_frame, frame_info): Use SYMBOL_PRINT_NAME for output.  Use
	cp_remove_params instead of cplus_demangle.
	(print_block_frame_labels, print_frame_arg_vars): Use
	SYMBOL_LINKAGE_NAME.
	* symmisc.c (dump_msymbols): Use ALL_OBJFILE_MSYMBOLS and
	SYMBOL_LINKAGE_NAME.
	(dump_symtab_1, print_symbol, print_partial_symbols)
	(maintenance_check_symtabs): Use SYMBOL_LINKAGE_NAME.
	* symtab.h (DEPRECATED_SYMBOL_NAME): Delete.
	(SYMBOL_SET_LINKAGE_NAME): New.
	(SYMBOL_SET_NAMES): Add a comment.
	* tracepoint.c (set_traceframe_context, validate_actionline)
	(collect_symbol, scope_info): Use SYMBOL_LINKAGE_NAME for
	lookups and SYMBOL_PRINT_NAME for output.
	* typeprint.c (typedef_print): Use SYMBOL_LINKAGE_NAME.
	* xcoffread.c (process_xcoff_symbol): Use SYMBOL_SET_LINKAGE_NAME.
@
text
@d1430 1
a1430 1
  (ALLOCED) ? (NAME) : obsavestring ((NAME), strlen (NAME), &objfile->objfile_obstack);
@


1.61
log
@(scan_xcoff_symtab): Do not include global symbols
 ('F' format) for @@FIX names generated by the loader, retaining only
 the minimal symbols (and no partial symbol tables) for these names.
 Fixes warning messages about symbols that are found in partial
 symbol tables, but not full symbol tables.
@
text
@d1477 1
a1477 1
      DEPRECATED_SYMBOL_NAME (sym) = SYMNAME_ALLOC (name, symname_alloced);
@


1.60
log
@	* xcoffread.c (scan_xcoff_symtab): Replace current_gdbarch by
	objfile arch.
@
text
@d2758 8
@


1.59
log
@	* objfiles.h (struct objfile): New GDBARCH member.
	(get_objfile_arch): Add prototype.
	* objfiles.c: Include "arch-utils.h".
	(allocate_objfile): Look up gdbarch associated with bfd.
	(get_objfile_arch): New function.
	* Makefile (objfiles.o): Update dependencies.

	* dwarf2-frame.c (decode_frame_entry_1): Replace current_gdbarch
	by objfile arch.
	* dwarf2loc.c (dwarf_expr_read_reg): Replace current_gdbarch
	by frame arch.
	(locexpr_describe_location): Replace current_gdbarch by
	objfile arch.
	* dwarf2read.c (die_type): Replace current_gdbarch by objfile arch.
	(dwarf2_add_field): Likewise.
	(read_tag_pointer_type): Likewise.
	(read_base_type): Likewise.
	(new_symbol): Likewise.

	* coffread.c (decode_type): Add OBJFILE argument.  Update callers.
	(decode_base_type, decode_function_type): Likewise.
	(coff_read_struct_type, coff_read_enum_type): Likewise.
	(coff_symtab_read): Replace current_gdbarch by objfile arch.
	(decode_base_type): Likewise.
	(coff_read_enum_type): Likewise.
	(coff_read_struct_type): Replace current_objfile by OBJFILE argument.
	(coff_read_enum_type): Likewise.

	* dbxread.c (read_dbx_symtab): Replace current_gdbarch by objfile arch.
	(end_psymtab): Likewise.
	(process_one_symbol): Likewise.

	* mdebugread.c (parse_symbol): Replace current_gdbarch by objfile arch.
	(parse_procedure): Likewise.
	(parse_partial_symbols): Likewise.

	* somread.c (som_symtab_read): Replace current_gdbarch by objfile arch.

	* stabsread.c (define_symbol): Replace current_gdbarch by objfile arch.
	Replace static pcc_promotion_type and pcc_unsigned_promotion_type by
	built-in types.
	(read_range_type): Replace current_gdbarch by objfile arch.  Replace
	static range_index_type by built-in type.
	(read_one_struct_field): Replace current_gdbarch by objfile arch.
	(read_enum_type): Likewise.

	* xcoffread.c (read_xcoff_symtab): Replace current_gdbarch by
	objfile arch.
@
text
@d2122 1
@


1.58
log
@
	* rs6000-nat.c (add_vmap, vmap_ldinfo, vmap_exec): Replace
	DEPRECATED_STREQ by its expression.
	* coffread.c (coff_locate_sections, coff_symtab_read): Likewise.
	* xcoffread.c (read_xcoff_symtab, read_symbol_lineno, find_linenos)
	(scan_xcoff_symtab): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_skip_trampoline_code): Likewise.
	* f-lang.c (find_common_for_function): Likewise.
	* objc-exp.y (parse_number): Likewise.

	* defs.h (DEPRECATED_STREQ): Remove.
@
text
@d1438 1
d1478 1
a1478 1
      SYMBOL_TYPE (sym) = builtin_type (current_gdbarch)->nodebug_text_symbol;
d1491 1
a1491 1
      SYMBOL_TYPE (sym) = builtin_type (current_gdbarch)->nodebug_data_symbol;
d2586 1
a2586 1
		if (gdbarch_static_transform_name_p (current_gdbarch))
d2588 1
a2588 1
				 (current_gdbarch, namestring);
@


1.57
log
@	Updated copyright notices for most files.
@
text
@d1254 1
a1254 1
	  if (DEPRECATED_STREQ (cs->c_name, ".bf"))
d1271 1
a1271 1
	  else if (DEPRECATED_STREQ (cs->c_name, ".ef"))
d1365 1
a1365 1
	  if (DEPRECATED_STREQ (cs->c_name, ".bb"))
d1373 1
a1373 1
	  else if (DEPRECATED_STREQ (cs->c_name, ".eb"))
d1669 1
a1669 1
	  if (DEPRECATED_STREQ (name, ".bf"))
d1703 1
a1703 1
  if (!DEPRECATED_STREQ (asect->name, ".text") || count == 0)
d2528 1
a2528 1
	    if (pst && DEPRECATED_STREQ (namestring, pst->filename))
d2533 1
a2533 1
		if (DEPRECATED_STREQ (namestring, psymtab_include_list[i]))
@


1.56
log
@	* gdbarch.sh (static_transform_name): New gdbarch callback.
	* gdbarch.c, gdbarch.h: Regenerate.
	* dbxread.c (read_dbx_symtab): Use gdbarch_static_transform_name
	instead of STATIC_TRANSFORM_NAME.
	* mdebugread.c (parse_partial_symbols): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* xcoffread.c (scan_xcoff_symtab): Likewise.

	* config/i368/tm-i386sol2.h (STATIC_TRANSFORM_NAME): Remove.
	(IS_STATIC_TRANSFORM_NAME): Remove.
	* i386-tdep.c (sunpro_static_transform_name): Remove, move to ...
	* i386-sol2-tdep.c (i386_sol2_static_transform_name): ... here.
	(i386_sol2_init_abi): Install it.

	* config/sparc/tm-sol2.h (STATIC_TRANSFORM_NAME): Remove.
	(IS_STATIC_TRANSFORM_NAME): Remove.
	* sparc-tdep.c (sparc_stabs_unglobalize_name): Remove, move to ...
	* sparc-sol2-tdep.c (sparc_sol2_static_transform_name): ... here.
	(sparc32_sol2_init_abi): Install it.
	* sparc64-sol2-tdep.c (sparc64_sol2_init_abi): Likewise.
	* sparc-tdep.h (sparc_sol2_static_transform_name): Add prototype.
@
text
@d3 1
a3 1
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2007
@


1.55
log
@        * symfile.h (struct sym_fns): Add new field sym_read_linetable.
        * coffread.c, dbxread.c, elfread.c, mipsread.c somread.c:
        Adjust the struct sym_fns object accordingly by setting
        the new field to NULL.
        * xcoffread.c (aix_process_linenos): Make static.
        (xcoff_sym_fns): Set new field to aix_process_linenos.
        * buildsym.c (end_symtab): Replace call to PROCESS_LINENUMBER_HOOK
        by call to new the new sym_fns sym_read_linetable function.
        * config/powerpc/aix.mt (DEPRECATED_TM_FILE): Delete.
        * config/rs6000/tm-rs6000.h: Delete.
@
text
@d2584 5
a2588 3
#ifdef STATIC_TRANSFORM_NAME
		namestring = STATIC_TRANSFORM_NAME (namestring);
#endif
@


1.54
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d730 1
a730 1
void
d3015 1
@


1.53
log
@	* gdbtypes.h (struct builtin_type): New members nodebug_text_symbol,
	nodebug_data_symbol, nodebug_unknown_symbol, and nodebug_tls_symbol.
	* gdbtypes.c (gdbtypes_post_init): Initialize nodebug_ default types.

	* parse.c (msym_text_symbol_type, msym_data_symbol_type): Remove.
	(msym_unknown_symbol_type, msym_tls_symbol_type): Remove.
	(write_exp_msymbol): Use builtin nodebug_ types instead of them.
	(build_parse): Remove.
	(_initialize_parse): Do not call build_parse.  Do not register
	msym_ types for gdbarch-swapping.

	* dwarf2read.c (new_symbol): Use default nodebug_data_symbol type
	instead of creating private type.

	* xcoffread.c (func_symbol_type, var_symbol_type): Remove.
	(_initialize_xcoffread): Do not initialized them.
	(process_xcoff_symbol): Use builtin nodebug_ types instead of them.

	* mdebugread.c (nodebug_func_symbol_type): Remove.
	(nodebug_var_symbol_type): Remove.
	(_initialize_mdebugread): Do not initialize them.
	(parse_symbol): Use builtin nodebug_ type instead of them.
	(parse_procedure): Likewise.
@
text
@d12 1
a12 1
   the Free Software Foundation; either version 2 of the License, or
d21 1
a21 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.52
log
@	* coffread.c (coff_sym_fns): Add default_symfile_segments.
	* dbxread.c (start_psymtab): Check HAVE_ELF.
	(aout_sym_fns): Likewise.
	* elfread.c (elf_symfile_segments): New.
	(elf_sym_fns): Add elf_symfile_segments.
	* mipsread.c (ecoff_sym_fns): Add default_symfile_segments.
	* remote.c (get_offsets): Use symfile_map_offsets_to_segments.
	Skip if there is no symfile_objfile.  Handle TextSeg and DataSeg.
	* somread.c (som_sym_fns): Use default_symfile_segments.
	* symfile.c (find_sym_fns): Take a BFD and return the sym_fns.
	(init_objfile_sect_indices): Call symfile_find_segment_sections.
	(default_symfile_segments): New function.
	(syms_from_objfile): Update call to find_sym_fns.
	(symfile_get_segment_data, free_symfile_segment_data): New.
	(symfile_map_offsets_to_segments): New.
	(symfile_find_segment_sections): New.
	* symfile.h (struct symfile_segment_data): New.
	(struct sym_fns): Add sym_segments.
	(default_symfile_segments, symfile_get_segment_data)
	(free_symfile_segment_data): New prototypes.
	(symfile_map_offsets_to_segments): Likewise.
	* xcoffread.c (xcoff_sym_fns): Add default_symfile_segments.
	* Makefile.in (COMMON_OBS): Remove elfread.o.
	(elf_internal_h): New.
	(elfread.o): Update.
	* configure.ac: Add elfread.o to COMMON_OBS if bfd/elf.o was
	compiled.
	* config.in, configure: Regenerated.
	* NEWS: Mention qOffsets changes.

	* gdb.texinfo (General Query Packets): Document qOffsets changes.

	* Makefile.def: Add dependency from configure-gdb to all-bfd.
	* Makefile.in: Regenerated.
@
text
@a1434 3
static struct type *func_symbol_type;
static struct type *var_symbol_type;

d1479 1
a1479 1
      SYMBOL_TYPE (sym) = func_symbol_type;
d1492 1
a1492 1
      SYMBOL_TYPE (sym) = var_symbol_type;
a3023 8

  func_symbol_type = init_type (TYPE_CODE_FUNC, 1, 0,
				"<function, no debug info>", NULL);
  TYPE_TARGET_TYPE (func_symbol_type) = builtin_type_int;
  var_symbol_type =
    init_type (TYPE_CODE_INT, 
	       gdbarch_int_bit (current_gdbarch) / HOST_CHAR_BIT, 0,
	       "<variable, no debug info>", NULL);
@


1.51
log
@2007-06-12  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (TARGET_SHORT_BIT): Replace by gdbarch_int_bit.
	* ada-lang.c (ada_create_fundamental_type)
	(ada_language_arch_info): Likewise.
	* c-lang.c (c_create_fundamental_type): Likewise.
	* f-lang.c (f_create_fundamental_type, build_fortran_types): Likewise.
	* gdbtypes.c (build_gdbtypes, gdbtypes_post_init): Likewise.
	* m2-lang.c (m2_create_fundamental_type): Likewise.
	* objc-lang.c (objc_create_fundamental_type): Likewise.
	* p-lang.c (pascal_create_fundamental_type): Likewise.
	* gdbarch.sh (TARGET_INT_BIT): Replace by gdbarch_int_bit.
	* c-exp.y (parse_number): Likewise.
	* objc-exp.y (parse_number): Likewise.
	* ada-lex.l (processInt): Likewise.
	* f-exp.y (parse_number): Likewise.
	* p-exp.y (parse_number): Likewise.
	* ada-lang.c (ada_create_fundamental_type, ada_language_arch_info)
	(gdbtypes_post_init, build_gdbtypes): Likewise.
	* p-lang.c (pascal_create_fundamental_type): Likewise.
	* parse.c (build_parse): Likewise.
	* xcoffread.c (_initialize_xcoffread): Likewise.
	* stabsread.c (define_symbol, read_one_struct_field, read_enum_type)
	(read_range_type): Likewise.
	* objc-lang.c (objc_create_fundamental_type): Likewise.
	* f-lang.c (build_fortran_types, f_create_fundamental_type): Likewise.
	* m2-lang.c (m2_create_fundamental_type, _initialize_m2_language)
	(m2_create_fundamental_type): Likewise.
	* c-lang.c (c_create_fundamental_type): Likewise.
	* coffread.c (coff_read_enum_type): Likewise.
	* mdebugread.c (parse_symbol, _initialize_mdebugread): Likewise.
	* dwarf2read.c (new_symbol): Likewise.
	* gdbarch.sh (TARGET_LONG_BIT): Replace by gdbarch_long_bit.
	* c-exp.y (parse_number): Likewise.
	* objc-exp.y (parse_number): Likewise.
	* ada-lex.l (processInt): Likewise.
	* f-exp.y (parse_number): Likewise.
	* p-exp.y (parse_number): Likewise.
	* valarith.c (value_binop): Likewise.
	* symfile.c (read_target_long_array, simple_overlay_update_1): Likewise.
	* ada-lang.c (ada_create_fundamental_type)
	(ada_language_arch_info): Likewise.
	* gdbtypes.c (build_gdbtypes, gdbtypes_post_init): Likewise.
	* symfile.c (TARGET_LONG_BYTES): Likewise.
	* p-lang.c (pascal_create_fundamental_type): Likewise.
	* objc-lang.c (objc_create_fundamental_type): Likewise.
	* m2-lang.c (m2_create_fundamental_type): Likewise.
	* f-lang.c (f_create_fundamental_type): Likewise.
	* c-lang.c (c_create_fundamental_type): Likewise.
	* coffread.c (decode_base_type): Likewise.
	* gdbarch.sh (TARGET_LONG_LONG_BIT): Replace by gdbarch_long_long_bit.
	* c-exp.y (parse_number): Likewise.
	* objc-exp.y (parse_number): Likewise.
	* p-exp.y (parse_number): Likewise.
	* ada-lang.c (ada_create_fundamental_type)
	(ada_language_arch_info): Likewise.
	* gdbtypes.c (gdbtypes_post_init, build_gdbtypes): Likewise.
	* stabsread.c (read_range_type): Likewise.
	* p-lang.c (pascal_create_fundamental_type): Likewise.
	* objc-lang.c (objc_create_fundamental_type): Likewise.
	* m2-lang.c (m2_create_fundamental_type): Likewise.
	* f-lang.c (f_create_fundamental_type): Likewise.
	* c-lang.c (c_create_fundamental_type): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d3018 2
@


1.50
log
@Copyright updates for 2007.
@
text
@d3030 2
a3031 1
    init_type (TYPE_CODE_INT, TARGET_INT_BIT / HOST_CHAR_BIT, 0,
@


1.49
log
@	* config/tm-linux.h (REALTIME_LO, REALTIME_HI): Do not define.
	* config/mips/tm-linux.h (REALTIME_LO, REALTIME_HI): Likewise.

	* config/rs6000/tm-rs6000ly.h (REALTIME_LO, REALTIME_HI): Move to ...
	* config/nm-lynx.h (REALTIME_LO, REALTIME_HI): ... here.

	* config/i386/nto.mh (NAT_FILE): Define.
	* config/i386/nto.mt (DEPRECATED_TM_FILE): Remove.
	* config/i386/tm-nto.h: Delete file.
	* config/tm-nto.h: Delete file.
	* config/nm-nto.h: New file.

	* Makefile.in (nto-tdep.o): Add dependency on $(objfiles_h).
	* nto-tdep.c: Include "objfiles.h" and <string.h>.

	* coff-solib.h (SOLIB_UNLOADED_LIBRARY_PATHNAME): Define as "".
	* xcoffread.c (read_xcoff_symtab): Initialize fcn_stab_saved.
	* config/rs6000/rs6000lynx.mt (TDEPFILES): Add xcoffread.o.
@
text
@d3 1
a3 1
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
@


1.48
log
@2006-01-01  Roger Sayle  <roger@@eyesopen.com>
            Elena Zannoni <ezannoni@@redhat.com>

	PR symtab/1651
	* xcoffread.c (xcoff_next_symbol_text): Check this_symtab_psymtab
	for NULL before assigning this_symtab_psymtab->objfile to objfile.
	(scan_xcoff_symtab): Initialize next_symbol_text_func.
        (Committed by Jim Blandy)
@
text
@d928 1
a928 1
  struct coff_symbol fcn_stab_saved;
@


1.47
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d871 2
a872 1
  objfile = this_symtab_psymtab->objfile;
d2174 1
@


1.46
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up error_no_arg, query, perror_with_name, complaint, and
	internal_error.
	* breakpoint.c, cp-abi.c, cp-namespace.c, cp-support.c: Update.
	* cris-tdep.c, dbxread.c, dictionary.c, dsrec.c: Update.
	* dummy-frame.c, dve3900-rom.c, dwarf2-frame.c, dwarf2expr.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, event-loop.c: Update.
	* exceptions.c, exec.c, f-lang.c, findvar.c, fork-child.c: Update.
	* frame-unwind.c, frame.c, frv-linux-tdep.c, frv-tdep.c: Update.
	* gdb_assert.h, gdbarch.c, gdbtypes.c, gnu-nat.c: Update.
	* go32-nat.c, hppa-tdep.c, hppabsd-nat.c, hpread.c: Update.
	* i386-linux-nat.c, i386-nat.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386fbsd-nat.c, inf-ptrace.c, inf-ttrace.c, infcall.c: Update.
	* infcmd.c, inflow.c, infptrace.c, infrun.c, inftarg.c: Update.
	* interps.c, language.c, linespec.c, linux-nat.c: Update.
	* m32r-linux-nat.c, m68k-tdep.c, m68kbsd-nat.c: Update.
	* m68klinux-nat.c, m88kbsd-nat.c, macroexp.c, macroscope.c: Update.
	* macrotab.c, maint.c, mdebugread.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mips64obsd-nat.c: Update.
	* mipsnbsd-nat.c, mn10300-tdep.c, monitor.c, nto-procfs.c: Update.
	* objc-lang.c, objfiles.c, objfiles.h, ocd.c, osabi.c: Update.
	* parse.c, ppc-bdm.c, ppc-linux-nat.c, ppc-sysv-tdep.c: Update.
	* ppcnbsd-nat.c, ppcobsd-nat.c, printcmd.c, procfs.c: Update.
	* regcache.c, reggroups.c, remote-e7000.c, remote-mips.c: Update.
	* remote-rdp.c, remote-sds.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote.c, rs6000-nat.c, rs6000-tdep.c: Update.
	* s390-nat.c, s390-tdep.c, sentinel-frame.c, serial.c: Update.
	* sh-tdep.c, sh3-rom.c, sh64-tdep.c, shnbsd-nat.c: Update.
	* solib-aix5.c, solib-svr4.c, solib.c, source.c: Update.
	* sparc-nat.c, stabsread.c, stack.c, symfile.c, symtab.c: Update.
	* symtab.h, target.c, tracepoint.c, ui-file.c, ui-out.c: Update.
	* utils.c, valops.c, valprint.c, vax-nat.c, vaxbsd-nat.c: Update.
	* win32-nat.c, xcoffread.c, xstormy16-tdep.c: Update.
	* cli/cli-cmds.c, cli/cli-logging.c, cli/cli-script.c: Update.
	* cli/cli-setshow.c, mi/mi-cmd-break.c, mi/mi-cmds.c: Update.
	* mi/mi-console.c, mi/mi-getopt.c, mi/mi-out.c: Update.
	* tui/tui-file.c, tui/tui-interp.c: Update.
@
text
@d2 1
a2 1
   Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
d22 2
a23 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.45
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d157 1
a157 1
  complaint (&symfile_complaints, "line numbers off, `.bf' symbol not found");
d164 1
a164 1
	     "Mismatched .ef symbol ignored starting at symnum %d", arg1);
d171 1
a171 1
	     "Mismatched .eb symbol ignored starting at symnum %d", arg1);
d493 1
a493 1
      complaint (&symfile_complaints, "Nested C_BINCL symbols");
d510 1
a510 1
      complaint (&symfile_complaints, "Mismatched C_BINCL/C_EINCL pair");
d773 1
a773 1
		     "Bad line table offset in C_EINCL directive");
d876 1
a876 1
      complaint (&symfile_complaints, "Unexpected symbol continuation");
d893 1
a893 1
      complaint (&symfile_complaints, "Unexpected symbol continuation");
d1335 1
a1335 1
	    complaint (&symfile_complaints, "Unrecognized storage class %d.",
d1522 1
a1522 1
	  complaint (&symfile_complaints, "Unexpected storage class: %d",
d1604 1
a1604 1
      complaint (&symfile_complaints, "Invalid symbol offset");
d2118 1
a2118 1
	     "function `%s' appears to be defined outside of all compilation units",
d2448 1
a2448 1
		       "Storage class %d not recognized during scan", sclass);
d2803 1
a2803 1
			   "unknown symbol descriptor `%c'", p[1]);
d2921 1
a2921 1
    perror_with_name ("reading symbol table");
@


1.44
log
@2004-10-23  Andrew Cagney  <cagney@@gnu.org>

	* objfiles.h (struct objfile): Rename obj_private to
	deprecated_obj_private, sym_private to deprecated_sym_private, and
	sym_stab_info to deprecated_sym_stab_info.
	* gdb-stabs.h: Update.
	* elfread.c: Update.
	* dbxread.c: Update.
	* coffread.c: Update.
	* xcoffread.c: Update.
	* symfile.c: Update.
	* somread.c: Update.
	* nlmread.c: Update.
	* mdebugread.c: Update.
	* hpread.c: Update.
	* coffread.c: Update.
@
text
@d1883 1
a1883 1
    error ("cannot seek to string table in %s: %s",
d1910 1
a1910 1
    error ("cannot read string table from %s: %s",
d1913 1
a1913 1
    error ("bad symbol file: string table does not end with null character");
d2295 1
a2295 1
		      warning ("More than one XMC_TC0 symbol found.");
d2896 1
a2896 1
		    error ("Error reading .debug section of `%s': %s",
d2910 1
a2910 1
    error ("Error reading symbols from %s: %s",
@


1.43
log
@        * xcoff_symfile_finish: Replace last call to xmfree by call
        to xfree.
@
text
@d556 1
a556 1
  ((struct coff_symfile_info *) this_symtab_psymtab->objfile->sym_private)
d765 1
a765 1
    ((struct coff_symfile_info *) this_symtab_psymtab->objfile->sym_private)
d885 1
a885 1
	((struct coff_symfile_info *) objfile->sym_private)->debugsec
d910 1
a910 1
  char *strtbl = ((struct coff_symfile_info *) objfile->sym_private)->strtbl;
d912 1
a912 1
  ((struct coff_symfile_info *) objfile->sym_private)->debugsec;
d958 1
a958 1
    ((struct coff_symfile_info *) objfile->sym_private)->symtbl
d1584 1
a1584 1
	    ((struct coff_symfile_info *) objfile->sym_private)->strtbl
d1599 1
a1599 2
  ((struct coff_symfile_info *) this_symtab_psymtab->objfile->sym_private)
  ->symtbl_num_syms;
d1601 1
a1601 2
  ((struct coff_symfile_info *) this_symtab_psymtab->objfile->sym_private)
  ->symtbl;
d1636 1
a1636 1
    (struct coff_symfile_info *)objfile->sym_private;
d1839 1
a1839 1
  objfile->sym_private = xmalloc (sizeof (struct coff_symfile_info));
d1857 1
a1857 1
  if (objfile->sym_private != NULL)
d1859 1
a1859 1
      xfree (objfile->sym_private);
d1880 1
a1880 1
  ((struct coff_symfile_info *) objfile->sym_private)->strtbl = NULL;
d1899 1
a1899 1
  ((struct coff_symfile_info *) objfile->sym_private)->strtbl = strtbl;
d2094 1
a2094 1
      *name = ((struct coff_symfile_info *) objfile->sym_private)->debugsec
d2099 1
a2099 1
      *name = ((struct coff_symfile_info *) objfile->sym_private)->strtbl
d2174 2
a2175 2
  sraw_symbol = ((struct coff_symfile_info *) objfile->sym_private)->symtbl;
  nsyms = ((struct coff_symfile_info *) objfile->sym_private)->symtbl_num_syms;
d2824 1
a2824 1
  ((struct coff_symfile_info *) objfile->sym_private)->toc_offset = toc_offset;
d2833 1
a2833 1
    return ((struct coff_symfile_info *) objfile->sym_private)->toc_offset;
d2860 1
a2860 1
  info = (struct coff_symfile_info *) objfile->sym_private;
d2901 1
a2901 1
	((struct coff_symfile_info *) objfile->sym_private)->debugsec =
d2913 1
a2913 1
  ((struct coff_symfile_info *) objfile->sym_private)->symtbl =
d2915 1
a2915 1
  ((struct coff_symfile_info *) objfile->sym_private)->symtbl_num_syms =
d2918 1
a2918 1
  val = bfd_bread (((struct coff_symfile_info *) objfile->sym_private)->symtbl,
@


1.42
log
@2004-08-10  Andrew Cagney  <cagney@@gnu.org>

	* utils.c (xmmalloc): Delete.
	(xmalloc): Inline xmmalloc and mmalloc calls.
	(msavestring): Use xmalloc.
	* defs.h (xmmalloc): Delete declaration.
	* xcoffread.c (xcoff_symfile_init): Use xmalloc instead of
	xmmalloc.
	* symmisc.c (extend_psymbol_list): Ditto.
	* symfile.c (init_psymbol_list): Ditto.
	* source.c (find_source_lines): Ditto.
	* hpread.c (hpread_symfile_init, hpread_lookup_type): Ditto.
	* elfread.c (elf_symtab_read): Ditto.
	* dbxread.c (dbx_symfile_init, init_bincl_list): Ditto.
	* coffread.c (coff_symfile_init): Ditto.
@
text
@d1861 1
a1861 1
      xmfree (objfile->md, objfile->sym_private);
@


1.41
log
@* infptrace.c: Include <sys/file.h> if HAVE_SYS_FILE_H instead of
!NO_SYS_FILE.
[KERNEL_U_ADDR_BSD]: Don't include <a.out.h>.
[KERNEL_U_ADDR_BSD] (kernel_u_addr): Remove variable.
(_initialize_kernel_u_addr): Remove prototype and function.
* infttrace.c: Include <sys/file.h> if HAVE_SYS_FILE_H instead of
!NO_SYS_FILE.
* xcoffread.c: Likewise.
@
text
@d1841 1
a1841 2
  objfile->sym_private = xmmalloc (objfile->md,
				   sizeof (struct coff_symfile_info));
@


1.40
log
@2004-02-14  Elena Zannoni  <ezannoni@@redhat.com>

	* symfile.c (init_entry_point_info, entry_point_address): Move
	from here...
	* objfiles.c (init_entry_point_info, entry_point_address):..to
	here.
	* symfile.h (init_entry_point_info, entry_point_address): Remove
	prototypes.
	* objfiles.h (init_entry_point_info, entry_point_address):Add
	prototypes.
	* cris-tdep.c: Remove include of symfile.h. Add include of
	objfiles.h.
	* infcall.c: Ditto.
	* mcore-tdep.c: Ditto.
	* mn10300-tdep.c: Ditto.
	* sh64-tdep.c: Ditto.
 	* v850-tdep.c: Ditto.
	* arm-tdep.c: Remove include of symfile.h.
	* blockframe.c: Ditto.
	* coffread.c: Ditto.
	* dbxread.c: Ditto.
	* dwarf2read.c: Ditto.
	* dwarfread.c: Ditto.
	* frv-tdep.c: Ditto.
	* ia64-tdep.c: Ditto.
	* mdebugread.c: Ditto.
	* mipsread.c: Ditto.
	* rs6000-tdep.c: Ditto.
	* s390-tdep.c: Ditto.
	* sh-tdep.c: Ditto.
	* xstormy16-tdep.c: Ditto.
	* gdbarch.sh: Remove include of symfile.h.
	* gdbarch.c: Regenerate.
	* solib-irix.c (enable_break): Use entry_point_address().
	Add comment about include file.
	* xcoffread.c: Add comment about include file.
	* Makefile.in (arm-tdep.o, blockframe.o, coffread.o, cris-tdep.o)
	(dbxread.o, dwarf2read.o, dwarfread.o, frv-tdep.o, gdbarch.o)
	(ia64-tdep.o, infcall.o, mcore-tdep.o, mdebugread.o, mipsread.o)
	(mn10300-tdep.o, rs6000-nat.o, s390-tdep.o, sh64-tdep.o)
	(sh-tdep.o, v850-tdep.o, xstormy16-tdep.o): Update dependencies.
@
text
@d34 1
a34 1
#ifndef	NO_SYS_FILE
@


1.40.2.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d34 1
a34 1
#ifdef HAVE_SYS_FILE_H
d1841 2
a1842 1
  objfile->sym_private = xmalloc (sizeof (struct coff_symfile_info));
d1862 1
a1862 1
      xfree (objfile->sym_private);
@


1.39
log
@2004-02-07  Elena Zannoni  <ezannoni@@redhat.com>

	* buildsym.c (free_pending_blocks, finish_block)
	(record_pending_block, make_blockvector, end_symtab): Replace
	symbol_obstack with objfile_obstack.
	* coffread.c (process_coff_symbol, coff_read_struct_type)
	(coff_read_enum_type): Ditto.
	* cp-namespace.c (initialize_namespace_symtab)
	(check_one_possible_namespace_symbol): Ditto.
	* dwarf2read.c (new_symbol, dwarf2_const_value, macro_start_file)
	(dwarf2_symbol_mark_computed): Ditto.
	* dwarfread.c (enum_type, new_symbol, synthesize_typedef): Ditto.
	* elfread.c (elf_symtab_read): Ditto.
	* hpread.c (hpread_symfile_init, hpread_symfile_init)
	(hpread_read_enum_type, hpread_read_function_type)
	(hpread_read_doc_function_type, hpread_process_one_debug_symbol):
	Ditto.
	* jv-lang.c (get_java_class_symtab, add_class_symbol)
	(java_link_class_type): Ditto.
	* mdebugread.c (parse_symbol, psymtab_to_symtab_1, new_symtab)
	(new_symbol): Ditto.
	* minsyms.c (install_minimal_symbols): Ditto.
	* objfiles.c (allocate_objfile): Remove init of symbol_obstack.
	(terminate_minimal_symbol_table): Replace symbol_obstack with
	objfile_obstack.
	(free_objfile): Remove freeing of symbol_obstack.
	* objfiles.h: Remove symbol_obstack field.
	* pa64solib.c (add_to_solist): Replace symbol_obstack with
	objfile_obstack.
	* solib-sunos.c (allocate_rt_common_objfile): Remove init of
	symbol_obstack.
	(solib_add_common_symbols): Replace symbol_obstack with
	objfile_obstack.
	* somsolib.c (som_solib_add): Ditto.
	* stabsread.c (patch_block_stabs, define_symbol, read_enum_type)
	(common_block_start, common_block_end): Ditto.
	* symfile.c (reread_symbols): Remove freeing and init of
	symbol_obstack.
	(allocate_symtab): Rename symbol_obstack to objfile_obstack.
	* symfile.h: Update comment.
	* symmisc.c (print_objfile_statistics): Remove symbol_obstack
	stats printing.
	* symtab.c (symbol_set_names): Replace symbol_obstack with
	objfile_obstack.
	* symtab.h (struct general_symbol_info, struct minimal_symbol):
	Update comments.
	* xcoffread.c (read_xcoff_symtab, SYMBOL_DUP, SYMNAME_ALLOC)
	(init_stringtab, xcoff_initial_scan): Replace symbol_obstack with
	objfile_obstack.
@
text
@d47 1
@


1.38
log
@2004-02-07  Elena Zannoni  <ezannoni@@redhat.com>

	* dbxread.c (dbx_symfile_init, start_psymtab, end_psymtab,
	coffstab_build_psymtabs, elfstab_build_psymtabs)
	(stabsect_build_psymtabs): Replace psymbol_obstack with
	objfile_obstack.
	* dwarf2-frame.c (decode_frame_entry_1): Ditto.
	* dwarf2read.c (dwarf2_build_psymtabs_hard, dwarf2_read_section):
	Ditto.
	* dwarfread.c (scan_compilation_units): Ditto.
	* elfread.c (elfstab_offset_sections): Ditto.
	* hppa-tdep.c (read_unwind_info): Ditto.
	* hpread.c (hpread_build_psymtabs, hpread_start_psymtab)
	(hpread_end_psymtab): Ditto.
	* mdebugread.c (mdebug_build_psymtabs, add_pending)
	(parse_partial_symbols, new_psymtab, elfmdebug_build_psymtabs):
	Ditto.
	* mips-tdep.c (non_heuristic_proc_desc): Ditto.
	* objfiles.c (add_to_objfile_sections)
	(build_objfile_section_table): Ditto.
	(allocate_objfile): Remove init of psymbol_obstack.
	(free_objfile): Remove freeing of psymbol_obstack.
	* objfiles.h (struct objfile): Remove field
	psymbol_obstack. Update comments.
	* pa64solib.c (pa64_solib_add_solib_objfile): Replace
	psymbol_obstack with objfile_obstack.
	* solib-sunos.c (allocate_rt_common_objfile): Remove init of
        psymbol_obstack.
	* somread.c (som_symfile_offsets, init_import_symbols)
	(init_export_symbols): Replace psymbol_obstack with
	objfile_obstack.
	* somsolib.c (som_solib_add_solib_objfile): Ditto.
	* symfile.c (default_symfile_offsets, syms_from_objfile)
	(reread_symbols): Remove freeing and init of psymbol_obstack.
	(cashier_psymtab): Update comment.
	* symmisc.c (print_objfile_statistics): Don't report stats for
	psymbol obstack.
	* symtab.h (struct general_symbol_info, struct partial_symtab):
	Update comments.
	* xcoffread.c (xcoff_start_psymtab, xcoff_end_psymtab, swap_sym)
	(xcoff_symfile_offsets): Replace psymbol_obstack with
	objfile_obstack.
@
text
@d991 1
a991 1
		p = obstack_alloc (&objfile->symbol_obstack, E_SYMNMLEN + 1);
d1425 1
a1425 1
  	obstack_alloc (&objfile->symbol_obstack, sizeof (struct symbol)); \
d1430 1
a1430 1
  (ALLOCED) ? (NAME) : obsavestring ((NAME), strlen (NAME), &objfile->symbol_obstack);
d1897 1
a1897 1
  /* Allocate string table from symbol_obstack. We will need this table
d1900 1
a1900 1
  strtbl = (char *) obstack_alloc (&objfile->symbol_obstack, length);
d2893 1
a2893 1
		  (char *) obstack_alloc (&objfile->symbol_obstack, length);
d2916 1
a2916 1
    obstack_alloc (&objfile->symbol_obstack, size);
@


1.37
log
@2003-11-23  Andrew Cagney  <cagney@@redhat.com>

	* symfile.c (symbol_file_command): Replace STREQ with strcmp.
	* defs.h (DEPRECATED_STREQN): Rename STREQN.
	(DEPRECATED_STREQ): Rename STREQ.
	* ada-exp.y, ada-lang.c, ada-lex.l, coffread.c: Update.
	* config/mips/tm-irix5.h, config/mips/tm-irix6.h: Update.
	* config/mips/tm-mipsv4.h, config/sparc/tm-sun4sol2.h: Update.
	* dbxread.c, dwarf2read.c, dwarfread.c, environ.c: Update.
	* eval.c, exec.c, f-lang.c, hppa-tdep.c, hpread.c: Update.
	* jv-exp.y, language.c, m2-exp.y, mcore-rom.c: Update.
	* mdebugread.c, mipsread.c, objc-exp.y, objfiles.c: Update.
	* p-exp.y, p-typeprint.c, p-valprint.c, rs6000-nat.c: Update.
	* source.c, sparc-tdep.c, stack.c, target.c: Update.
@
text
@d3 1
a3 1
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d1949 1
a1949 1
    obstack_alloc (&objfile->psymbol_obstack, sizeof (struct symloc));
d1996 1
a1996 1
	obstack_alloc (&objfile->psymbol_obstack,
d2011 1
a2011 1
	(char *) obstack_alloc (&objfile->psymbol_obstack,
d2021 1
a2021 1
	obstack_alloc (&objfile->psymbol_obstack,
d2084 1
a2084 1
	  p = obstack_alloc (&objfile->psymbol_obstack, E_SYMNMLEN + 1);
d2962 1
a2962 1
    obstack_alloc (&objfile->psymbol_obstack, 
@


1.36
log
@2003-11-05  Andrew Cagney  <cagney@@redhat.com>

	* xcoffread.c (find_linenos): Replace "sec_ptr" and "bfd" with
	"struct bfd_section" and "struct bfd".
	* target.h (struct section_table): Ditto.
	* rs6000-nat.c (xcoff_relocate_core): Ditto.
	* solib-svr4.c (elf_locate_base): Ditto.
	* pa64solib.c (dld_cache_t): Ditto.
	* objfiles.h (struct obj_section): Ditto.
	* objfiles.c (add_to_objfile_sections): Ditto.
	* exec.c (bfdsec_to_vmap): Ditto.
	(add_to_section_table): Ditto.
	(build_section_table): Ditto.
	* corelow.c (get_core_register_section): Ditto.
	* coffread.c (find_linenos): Ditto.
	* elfread.c (elf_interpreter): Delete #if0'd function.

	* mips-tdep.c (mips_dump_tdep): Delete code prinint VX_NUM_REGS.
	* config/sparc/tm-vxsparc.h (VX_NUM_REGS): Delete macro.
	* config/mips/tm-vxmips.h (VX_NUM_REGS): Delete macro.
	* config/m68k/tm-vx68.h (VX_NUM_REGS): Delete macro.

	* arch-utils.h (generic_cannot_extract_struct_value_address):
	Delete declaration.
	* wince.c (_initialize_wince): Fix multi-line string.
	* ia64-tdep.c (floatformat_valid): Convert to ISO C.
@
text
@d1254 1
a1254 1
	  if (STREQ (cs->c_name, ".bf"))
d1271 1
a1271 1
	  else if (STREQ (cs->c_name, ".ef"))
d1365 1
a1365 1
	  if (STREQ (cs->c_name, ".bb"))
d1373 1
a1373 1
	  else if (STREQ (cs->c_name, ".eb"))
d1674 1
a1674 1
	  if (STREQ (name, ".bf"))
d1708 1
a1708 1
  if (!STREQ (asect->name, ".text") || count == 0)
d2533 1
a2533 1
	    if (pst && STREQ (namestring, pst->filename))
d2538 1
a2538 1
		if (STREQ (namestring, psymtab_include_list[i]))
@


1.35
log
@2003-10-06  Andrew Cagney  <cagney@@redhat.com>

	* breakpoint.c, breakpoint.h: Remove obsolete code and comments.
	* buildsym.c, dbxread.c, gdbtypes.c, mdebugread.c: Ditto.
	* monitor.c, sparc-tdep.c, stabsread.c: Ditto.
	* stabsread.h, xcoffread.c: Ditto.
@
text
@a195 2
static void find_linenos (bfd *, sec_ptr, void *);

d1700 1
a1700 1
find_linenos (bfd *abfd, sec_ptr asect, void *vpinfo)
d2882 1
a2882 1
	sec_ptr secp;
@


1.34
log
@2003-09-16  Andrew Cagney  <cagney@@redhat.com>

	* buildsym.c: Remove more occurances of "register".
	* coffread.c, dbxread.c, dcache.c, dwarf2read.c: Ditto.
	* environ.c, eval.c, f-valprint.c, findvar.c: Ditto.
	* gdbtypes.c, gnu-v2-abi.c, h8300-tdep.c, hppa-tdep.c: Ditto.
	* infcmd.c, mdebugread.c, minsyms.c, mips-tdep.c: Ditto.
	* printcmd.c, remote-vx.c, sh-stub.c, sh-tdep.c: Ditto.
	* sh64-tdep.c, source.c, stabsread.c, stack.c: Ditto.
	* standalone.c, symfile.c, symmisc.c, symtab.c: Ditto.
	* utils.c, valops.c, values.c, xcoffread.c: Ditto.
@
text
@a2637 16
#if 0 /* OBSOLETE CFront */
// OBSOLETE  		    /* The semantics of C++ state that "struct foo { ... }"
// OBSOLETE  		       also defines a typedef for "foo".  Unfortuantely, cfront
// OBSOLETE  		       never makes the typedef when translating from C++ to C.
// OBSOLETE  		       We make the typedef here so that "ptype foo" works as
// OBSOLETE  		       expected for cfront translated code.  */
// OBSOLETE  		    else if (psymtab_language == language_cplus)
// OBSOLETE  		      {
// OBSOLETE  			/* Also a typedef with the same name.  */
// OBSOLETE  			add_psymbol_to_list (namestring, p - namestring,
// OBSOLETE  					     VAR_DOMAIN, LOC_TYPEDEF,
// OBSOLETE  					     &objfile->static_psymbols,
// OBSOLETE  					     symbol.n_value, 0,
// OBSOLETE  					     psymtab_language, objfile);
// OBSOLETE  		      }
#endif /* OBSOLETE CFront */
a2785 5
#if 0 /* OBSOLETE CFront */
// OBSOLETE 		/* added to support cfront stabs strings */
// OBSOLETE 	      case 'Z':		/* for definition continuations */
// OBSOLETE 	      case 'P':		/* for prototypes */
#endif /* OBSOLETE CFront */
@


1.33
log
@2003-09-14  Andrew Cagney  <cagney@@redhat.com>

	* alpha-nat.c: Remove some occurances of "register".
	* alpha-tdep.c, arm-tdep.c, blockframe.c, breakpoint.c: Ditto.
	* buildsym.c, c-typeprint.c, c-valprint.c, coffread.c: Ditto.
	* corefile.c, cp-support.c, cp-valprint.c, cris-tdep.c: Ditto.
	* dbxread.c, dcache.c, dwarf2read.c, elfread.c: Ditto.
	* environ.c, eval.c, event-top.c, f-typeprint.c: Ditto.
	* f-valprint.c, findvar.c, frame.c, gdbtypes.c: Ditto.
	* h8300-tdep.c, hppa-tdep.c, hppab-nat.c, hppah-nat.c: Ditto.
	* hppam3-nat.c, hpread.c, ia64-aix-nat.c, ia64-linux-nat.c: Ditto.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Ditto.
	* infttrace.c, irix5-nat.c, jv-typeprint.c: Ditto.
	* jv-valprint.c, m68k-tdep.c, m68klinux-nat.c, main.c: Ditto.
	* mdebugread.c, minsyms.c, mips-linux-tdep.c: Ditto.
	* mips-nat.c, mips-tdep.c, mipsread.c, mipsv4-nat.c: Ditto.
	* ns32k-tdep.c, objfiles.c, p-typeprint.c: Ditto.
	* p-valprint.c, ppc-linux-nat.c, printcmd.c: Ditto.
	* remote-mips.c, remote-vx.c, rs6000-nat.c: Ditto.
	* rs6000-tdep.c, scm-exp.c, sh-tdep.c, sh64-tdep.c: Ditto.
	* solib.c, somread.c, source.c, sparc-tdep.c: Ditto.
	* stabsread.c, stack.c, standalone.c, symfile.c: Ditto.
	* symmisc.c, symtab.c, top.c, tracepoint.c: Ditto.
	* typeprint.c, utils.c, valarith.c, valops.c: Ditto.
	* values.c, vax-tdep.c, xcoffread.c: Ditto.
@
text
@d1441 1
a1441 1
process_xcoff_symbol (register struct coff_symbol *cs, struct objfile *objfile)
d2538 1
a2538 1
	      register int i;
@


1.32
log
@        * xcoffread.c (xcoff_psymtab_to_symtab_1): Remove call to
        sort_symtab_syms, no longer necessary.
@
text
@d1444 1
a1444 1
  register struct symbol *sym = &onesymbol;
@


1.31
log
@2003-06-11  David Carlton  <carlton@@bactrian.org>

	* dictionary.h: New.
	* dictionary.c: New.
	* block.h: Add opaque declaration for struct dictionary.
	(struct block): Add 'dict' member; delete 'hashtable', 'nsyms',
	'sym' members.
	(BLOCK_DICT): New macro.
	Delete macros BLOCK_HASHTABLE, BLOCK_NSYMS, BLOCK_SYM,
	BLOCK_BUCKETS, BLOCK_BUCKET, BLOCK_HASHTABLE_SIZE,
	BLOCK_SHOULD_SORT.
	(ALL_BLOCK_SYMBOLS): Update definition.
	* Makefile.in (SFILES): Add dictionary.c.
	(dictionary_h): New.
	(COMMON_OBS): Add dictionary.o.
	(dictionary.o): New.
	(ada-lang.o): Depend on dictionary_h.
	(buildsym.o, coffread.o, jv-lang.o, mdebugread.o, objfiles.o)
	(stack.o, symmisc.o, symtab.o, tracepoint.o, valops.o)
	(mi-cmd-stack.o): Ditto.
	(gdbtk-cmds.o): Update dependencies.
	(gdbtk-stack.o): Ditto.
	* ada-lang.c: Include dictionary.h.
	(symtab_for_sym): Update uses of ALL_BLOCK_SYMBOLS.
	(fill_in_ada_prototype, debug_print_block): Ditto.
	(ada_add_block_symbols): Update uses of ALL_BLOCK_SYMBOLS; replace
	explicit iteration by use of ALL_BLOCK_SYMBOLS.  Delete variable
	'is_sorted'.
	* mdebugread.c: Include dictionary.h.
	(struct parse_stack): Delete 'maxsyms' member.
	(parse_symbol): Update calls to new_block.  Delete calls to
	shrink_block.  Use dictionary methods.
	(psymtab_to_symtab_1): Delete calls to sort_symtab_syms.
	Update calls to new_symtab.  Don't maintain maxsyms data.
	(mylookup_symbol): Update use of ALL_BLOCK_SYMBOLS.
	(add_symbol): Just call dict_add_symbol.
	(new_symtab): Delete 'maxsyms' argument.
	(new_symtab): Update calls to new_block.
	(new_block): Delete 'maxsyms' argument; add 'function' argument.
	(shrink_block): Delete function.
	(fixup_sigtramp): Update call to new_block.  Add symbol via
	dict_add_symbol.
	* jv-lang.c: Include dictionary.h.
	(get_java_class_symtab): Set the BLOCK_DICT of the blocks
	appropriately.  Set class_symtab->free_func.  Make sure the
	blockvector is big enough to hold two blocks.
	(add_class_symtab_symbol): Use dictionary methods.
	(free_class_block): New function.
	(type_from_class): Replace explicit iteration by
	ALL_BLOCK_SYMBOLS.
	* symtab.h (struct symtab): Replace 'free_ptr' method by
	'free_func'.
	* dwarf2read.c (psymtab_to_symtab_1): Delete call to
	sort_symtab_syms.
	* dwarfread.c (psymtab_to_symtab_1): Delete call to
	sort_symtab_syms.
	* coffread.c (coff_symfile_read): Delete call to sort_symtab_syms.
	Include dictionary.h.
	(patch_opaque_types): Update use of ALL_BLOCK_SYMBOLS.
	* dbxread.c (dbx_psymtab_to_symtab_1): Delete call to
	sort_symtab_syms.
	* objfiles.c: Include dictionary.h.
	(objfile_relocate): Update use of ALL_BLOCK_SYMBOLS.
	* buildsym.c: Include dictionary.h.
	(finish_block): Use dictionary methods.
	(end_symtab): Set free_func to NULL, not free_ptr.
	* tracepoint.c: Include dictionary.h.
	(add_local_symbols): Update use of ALL_BLOCK_SYMBOLS.
	(scope_info): Ditto.
	* stack.c: Include dictionary.h.
	(print_block_frame_locals): Update use of ALL_BLOCK_SYMBOLS.
	(print_block_frame_labels, print_frame_arg_vars)
	(print_frame_args): Ditto.
	* symmisc.c (free_symtab_block): Use dictionary methods.
	(dump_symtab): Ditto.
	(free_symtab): Replace use of 'free_ptr' by 'free_func'.
	Include	dictionary.h.
	* symfile.h: Delete declarations of sort_block_syms,
	sort_symtab_syms.
	* symfile.c (sort_block_syms): Delete.
	(sort_symtab_syms): Delete.
	* symtab.c: Include dictionary.h.
	(lookup_block_symbol): Use dictionary iterators.
	(find_pc_sect_symtab): Update use of ALL_BLOCK_SYMBOLS.
	(search_symbols, make_symbol_completion_list): Ditto.
	(make_symbol_overload_list): Ditto.
	* valops.c (value_of_local): Use dict_empty.
	Include dictionary.h.

2003-06-11  David Carlton  <carlton@@bactrian.org>

	* generic/gdbtk-stack.c: Include dictionary.h.
	(gdb_block_vars): Update use of ALL_BLOCK_SYMBOLS.
	(gdb_get_blocks, gdb_get_vars_command): Ditto.
	* generic/gdbtk-cmds.c: Include dictionary.h.
	(gdb_listfuncs): Update use of ALL_BLOCK_SYMBOLS.

2003-06-11  David Carlton  <carlton@@bactrian.org>

	* mi-cmd-stack.c: Include dictionary.h.
	(list_args_or_locals): Update use of ALL_BLOCK_SYMBOLS.
@
text
@a1769 1
      sort_symtab_syms (pst->symtab);
@


1.31.4.1
log
@        * xcoffread.c (xcoff_psymtab_to_symtab_1): Remove call to
        sort_symtab_syms, no longer necessary.
@
text
@d1770 1
@


1.30
log
@2003-06-11  David Carlton  <carlton@@bactrian.org>

	* block.h (BLOCK_SHOULD_SORT): Delete.
	* symtab.c (lookup_block_symbol): Don't worry about sorted linear
	blocks.
	* ada-lang.c (ada_add_block_symbols): Ditto.
	* symfile.c (sort_block_syms): Delete.
	(sort_symtab_syms): Ditto.
	* symfile.h: Delete sort_symtabs_syms and sort_block_syms
	declarations.
	* coffread.c (coff_symfile_read): Don't call sort_symtab_syms.
	* dbxread.c (dbx_psymtab_to_symtab_1): Ditto.
	* dwarf2read.c (psymtab_to_symtab_1): Ditto.
	* dwarfread.c (psymtab_to_symtab_1): Ditto.
	* hpread.c (hpread_psymtab_to_symtab_1): Ditto.
	* mdebugread.c (psymtab_to_symtab_1): Ditto.
	* xcoffread.c (xcoff_psymtab_to_symtab_1): Ditto.
@
text
@d1770 1
@


1.29
log
@	* elfread.c (elf_symtab_read): Avoid use of SECT_OFF_MAX.
	(elfstab_offset_sections): Likewise.
	* gdb-stabs.h (stab_section_info): Likewise.
	* i386-interix-tdep.c (pei_adjust_objfile_offsets): Likewise.
	* objfiles.c (objfile_relocate): Likewise.
	* pa64solib.c (pa64_solib_add_solib_objfile): Likewise.
	* remote.c (get_offsets): Likewise.
	(remote_cisco_objfile_relocate): Likewise.
	* somread.c (som_symfile_offsets): Likewise.
	* symfile.c (alloc_section_addr_info): New function.
	(build_section_addr_info_from_section_tab): Use it.
	(free_section_addr_info): Adjust.
	(default_symfile_offsets): Avoid use of SECT_OFF_MAX.
	(syms_from_objfile): Allocate local_addr dynamically.
	(symbol_file_add_with_addrs_or_offsets): Allocate orig_addrs
	dynamically.
	(add_symbol_file_command): Allocate sect_opts dynamically.
	(reread_symbols): Avoid use of SECT_OFF_MAX.
	* symfile.h (section_addr_info): Do not use MAX_SECTIONS.
	(alloc_section_addr_info): Declare it.
	* symtab.h (SIZEOF_SECTION_OFFSETS): Remove.
	* win32-nat.c (solib_symbols_add): Allocate section_addrs
	dynamically.
	* xcoffread.c (xcoff_symfile_offsets): Avoid use of SECT_OFF_MAX.
@
text
@a1769 1
      sort_symtab_syms (pst->symtab);
@


1.28
log
@2003-05-14  Elena Zannoni  <ezannoni@@redhat.com>

	* symtab.h (enum domain_enum): Rename from namespace_enum.
	(UNDEF_DOMAIN, VAR_DOMAIN, STRUCT_DOMAIN, LABEL_DOMAIN,
	VARIABLES_DOMAIN, FUNCTIONS_DOMAIN, TYPES_DOMAIN, METHODS_DOMAIN):
	Rename from UNDEF_NAMESPACE, VAR_NAMESPACE, STRUCT_NAMESPACE,
	LABEL_NAMESPACE, VARIABLES_NAMESPACE, FUNCTIONS_NAMESPACE,
	TYPES_NAMESPACE, METHODS_NAMESPACE.
	(SYMBOL_NAMESPACE): Rename to SYMBOL_DOMAIN.
	(struct symbol, struct partial_symbol): Rename field
	'namespace_enum namespace' to 'domain_enum domain'.
	(PSYMBOL_NAMESPACE): Rename to PSYMBOL_DOMAIN.
	Delete old define kludge for namespace.

	* ada-exp.y, ada-lang.c, ada-lang.h, alpha-tdep.c, arm-tdep.c,
	blockframe.c, c-exp.y, c-valprint.c, coffread.c, dbxread.c,
	dwarf2read.c, dwarfread.c, f-exp.y, gdbtypes.c, gdbtypes.h,
	gnu-v3-abi.c, hppa-tdep.c, hpread.c, jv-exp.y, jv-lang.c,
	language.c, linespec.c, m2-exp.y, m3-nat.c, mdebugread.c,
	mips-tdep.c, nlmread.c, objc-exp.y, objc-lang.c, objfiles.c,
	p-exp.y, p-valprint.c, parse.c, printcmd.c, scm-lang.c, source.c,
	stabsread.c, stack.c, symfile.c, symfile.h, symmisc.c, symtab.c,
	valops.c, values.c, xcoffread.c, xstormy16-tdep.c: Replace all
	occurrences of the above.

2003-05-12  Elena Zannoni  <ezannoni@@redhat.com>

	* mi-mi-cmd-stack.c (list_args_or_locals): Rename VAR_NAMESPACE to
	VAR_DOMAIN.
@
text
@d2984 1
a2984 1
  objfile->num_sections = SECT_OFF_MAX;
d2986 2
a2987 1
    obstack_alloc (&objfile->psymbol_obstack, SIZEOF_SECTION_OFFSETS);
@


1.27
log
@2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.h (SYMBOL_NATURAL_NAME): New macro.
	(SYMBOL_LINKAGE_NAME): Ditto.
	(SYMBOL_PRINT_NAME): Use SYMBOL_NATURAL_NAME and
	SYMBOL_LINKAGE_NAME.
	(struct general_symbol_info): Expand comment.
	(DEPRECATED_SYMBOL_NAME): Rename from SYMBOL_NAME.
	(SYMBOL_MATCHES_NAME): Use DEPRECATED_SYMBOL_NAME.
	(SYMBOL_MATCHES_REGEXP): Ditto.
	* symtab.c (symbol_natural_name): New function.
	* objfiles.h: Replace all uses of SYMBOL_NAME by
	DEPRECATED_SYMBOL_NAME.
	* xcoffread.c, valops.c, typeprint.c, tracepoint.c: Ditto.
	* symtab.c, symmisc.c, symfile.c, stack.c, stabsread.c: Ditto.
	* somsolib.c, sol-thread.c, rs6000-tdep.c, p-valprint.c: Ditto.
	* printcmd.c, objfiles.c, objc-lang.c, mipsread.c: Ditto.
	* minsyms.c, mdebugread.c, linespec.c, jv-lang.c: Ditto.
	* i386-tdep.c, i386-linux-tdep.c, hpread.c, hppa-tdep.c: Ditto.
	* gnu-v2-abi.c, f-valprint.c, findvar.c, expprint.c: Ditto.
	* dwarfread.c, dwarf2read.c, dbxread.c, c-valprint.c: Ditto.
	* cp-valprint.c, coffread.c, buildsym.c, breakpoint.c: Ditto.
	* blockframe.c, ax-gdb.c, arm-linux-tdep.c, ada-lang.c: Ditto.
	* ada-exp.y: Ditto.
	* ada-exp.y: Update copyright.
	* sol-thread.c, mipsread.c, jv-lang.c, f-valprint.c: Ditto.
	* cp-valprint.c: Ditto.

2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* generic/gdbtk.h: Replace all instances of SYMBOL_NAME by
	DEPRECATED_SYMBOL_NAME.
	* generic/gdbtk-stack.c, generic/gdbtk-cmds.c: Ditto.
	* generic/gdbtk-stack.c, generic/gdbtk-cmds.c: Update copyright.

2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c: Replace all instances of SYMBOL_NAME with
	DEPRECATED_SYMBOL_NAME.  Update copyright.
@
text
@d1472 1
a1472 1
  SYMBOL_NAMESPACE (sym) = VAR_NAMESPACE;
d2596 1
a2596 1
				     VAR_NAMESPACE, LOC_STATIC,
d2607 1
a2607 1
				     VAR_NAMESPACE, LOC_STATIC,
d2625 1
a2625 1
					 STRUCT_NAMESPACE, LOC_TYPEDEF,
d2633 1
a2633 1
					     VAR_NAMESPACE, LOC_TYPEDEF,
d2649 1
a2649 1
// OBSOLETE  					     VAR_NAMESPACE, LOC_TYPEDEF,
d2662 1
a2662 1
					 VAR_NAMESPACE, LOC_TYPEDEF,
d2724 1
a2724 1
					     VAR_NAMESPACE, LOC_CONST,
d2742 1
a2742 1
				     VAR_NAMESPACE, LOC_CONST,
d2759 1
a2759 1
				     VAR_NAMESPACE, LOC_BLOCK,
d2780 1
a2780 1
				     VAR_NAMESPACE, LOC_BLOCK,
@


1.27.16.1
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d1472 1
a1472 1
  SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d2596 1
a2596 1
				     VAR_DOMAIN, LOC_STATIC,
d2607 1
a2607 1
				     VAR_DOMAIN, LOC_STATIC,
d2625 1
a2625 1
					 STRUCT_DOMAIN, LOC_TYPEDEF,
d2633 1
a2633 1
					     VAR_DOMAIN, LOC_TYPEDEF,
d2649 1
a2649 1
// OBSOLETE  					     VAR_DOMAIN, LOC_TYPEDEF,
d2662 1
a2662 1
					 VAR_DOMAIN, LOC_TYPEDEF,
d2724 1
a2724 1
					     VAR_DOMAIN, LOC_CONST,
d2742 1
a2742 1
				     VAR_DOMAIN, LOC_CONST,
d2759 1
a2759 1
				     VAR_DOMAIN, LOC_BLOCK,
d2780 1
a2780 1
				     VAR_DOMAIN, LOC_BLOCK,
@


1.26
log
@2003-01-18  Andrew Cagney  <ac131313@@redhat.com>

	* cris-tdep.c: Fix function declaration indentation.
	* dwarfread.c, gdbcore.h, gdbtypes.h, i386v-nat.c: Ditto.
	* mips-tdep.c, monitor.h, parse.c, proc-utils.h: Ditto.
	* rs6000-nat.c, ser-go32.c, somread.c, stabsread.c: Ditto.
	* symfile.h, symtab.h, target.c, target.h, value.h: Ditto.
	* xcoffread.c, config/pa/tm-hppa.h: Ditto.
	* config/sparc/tm-sp64.h, config/sparc/tm-sparc.h: Ditto.
@
text
@d1481 1
a1481 1
      SYMBOL_NAME (sym) = SYMNAME_ALLOC (name, symname_alloced);
@


1.25
log
@2003-01-18  Andrew Cagney  <ac131313@@redhat.com>

	* ada-valprint.c: Eliminate PTR.
	* breakpoint.c, corelow.c, cris-tdep.c, dbxread.c: Ditto.
	* defs.h, dve3900-rom.c, dwarf2read.c, dwarfread.c: Ditto.
	* exec.c, hppa-tdep.c, hpread.c, infcmd.c, mdebugread.c: Ditto.
	* objfiles.c, objfiles.h, ocd.c, remote-es.c: Ditto.
	* remote-mips.c, remote-sds.c, remote-vx.c: Ditto.
	* solib-svr4.c, solib.c, stack.c, symfile.c, symfile.h: Ditto.
	* symmisc.c, v850ice.c, xcoffread.c, cli/cli-script.c: Ditto.
@
text
@d193 2
a194 2
static void
xcoff_symfile_offsets (struct objfile *, struct section_addr_info *addrs);
@


1.24
log
@2003-01-13  Elena Zannoni  <ezannoni@@redhat.com>

	* stabsread.h (process_later, resolve_cfront_continuation):
	Obsolete.
	Update copyright years.
	* buildsym.c (start_subfile): Obsolete comment pertinent to Cfront.
	Update copyright year.
	* dbxread.c(struct cont_elem): Obsolete.
	(process_later, process_now): Obsolete functions.
	(read_dbx_symtab, read_ofile_symtab): Obsolete cfront support.
	Update copyright year.
	* gdbtypes.c (INIT_EXTRA, ADD_EXTRA): Obsolete macros.
	(add_name, add_mangled_type, cfront_mangle_name): Obsolete functions.
	* mdebugread.c (parse_type): Obsolete comment pertinent to Cfront.
	(parse_partial_symbols): Obsolete cfront support.
	* stabsread.c
	(CFRONT_VISIBILITY_PRIVATE,CFRONT_VISIBILITY_PUBLIC): Obsolete
	macros.
	(get_substring, get_cfront_method_physname, msg_unknown_complaint,
	read_cfront_baseclasses, read_cfront_member_functions,
	resolve_cfront_continuation,read_cfront_static_fields,
	copy_cfront_struct_fields): Obsolete functions.
	(define_symbol, read_one_struct_field): Obsolete cfront support.
	* xcoffread.c (scan_xcoff_symtab): Obsolete CFront support.
	Update Copyright year.
@
text
@d196 1
a196 1
static void find_linenos (bfd *, sec_ptr, PTR);
d240 1
a240 1
find_targ_sec (bfd *abfd, asection *sect, PTR obj)
d1702 1
a1702 1
find_linenos (bfd *abfd, sec_ptr asect, PTR vpinfo)
d2557 1
a2557 1
		memcpy ((PTR) psymtab_include_list, (PTR) orig,
@


1.23
log
@Replace complain() with complaint().
@
text
@d3 1
a3 1
   1996, 1997, 1998, 1999, 2000, 2001
d2639 16
a2654 14
		    /* The semantics of C++ state that "struct foo { ... }"
		       also defines a typedef for "foo".  Unfortuantely, cfront
		       never makes the typedef when translating from C++ to C.
		       We make the typedef here so that "ptype foo" works as
		       expected for cfront translated code.  */
		    else if (psymtab_language == language_cplus)
		      {
			/* Also a typedef with the same name.  */
			add_psymbol_to_list (namestring, p - namestring,
					     VAR_NAMESPACE, LOC_TYPEDEF,
					     &objfile->static_psymbols,
					     symbol.n_value, 0,
					     psymtab_language, objfile);
		      }
d2803 5
a2807 3
		/* added to support cfront stabs strings */
	      case 'Z':		/* for definition continuations */
	      case 'P':		/* for prototypes */
@


1.22
log
@       * xcoffread.c (read_symbol_lineno): Replace type boolean by int.
       Fixes a compilation failure on AiX.
@
text
@d153 5
a157 2
static struct deprecated_complaint storclass_complaint =
{"Unexpected storage class: %d", 0, 0};
d159 6
a164 2
static struct deprecated_complaint bf_notfound_complaint =
{"line numbers off, `.bf' symbol not found", 0, 0};
d166 6
a171 5
static struct deprecated_complaint ef_complaint =
{"Mismatched .ef symbol ignored starting at symnum %d", 0, 0};

static struct deprecated_complaint eb_complaint =
{"Mismatched .eb symbol ignored starting at symnum %d", 0, 0};
d494 1
a494 3
      static struct deprecated_complaint msg =
      {"Nested C_BINCL symbols", 0, 0};
      complain (&msg);
d511 1
a511 3
      static struct deprecated_complaint msg =
      {"Mismatched C_BINCL/C_EINCL pair", 0, 0};
      complain (&msg);
d773 2
a774 3
	  static struct deprecated_complaint msg =
	  {"Bad line table offset in C_EINCL directive", 0, 0};
	  complain (&msg);
a869 2
  static struct deprecated_complaint msg =
  {"Unexpected symbol continuation", 0, 0};
d877 1
a877 1
      complain (&msg);
d894 1
a894 1
      complain (&msg);
d1286 1
a1286 1
		  complain (&ef_complaint, cs->c_symnum);
d1294 1
a1294 1
		  complain (&ef_complaint, cs->c_symnum);
d1336 2
a1337 3
	    static struct deprecated_complaint msg =
	    {"Unrecognized storage class %d.", 0, 0};
	    complain (&msg, cs->c_sclass);
d1379 1
a1379 1
		  complain (&eb_complaint, cs->c_symnum);
d1385 1
a1385 1
		  complain (&eb_complaint, cs->c_symnum);
d1523 2
a1524 1
	  complain (&storclass_complaint, cs->c_sclass);
d1607 1
a1607 3
      static struct deprecated_complaint msg =
      {"Invalid symbol offset", 0, 0};
      complain (&msg);
d1649 1
a1649 1
      complain (&bf_notfound_complaint);
d1682 1
a1682 1
  complain (&bf_notfound_complaint);
d2120 8
d2452 2
a2453 3
	    static struct deprecated_complaint msg =
	    {"Storage class %d not recognized during scan", 0, 0};
	    complain (&msg, sclass);
a2572 5

	    static struct deprecated_complaint function_outside_compilation_unit = {
	      "function `%s' appears to be defined outside of all compilation units", 0, 0
	    };

d2752 1
a2752 1
		    complain (&function_outside_compilation_unit, name);
d2773 1
a2773 1
		    complain (&function_outside_compilation_unit, name);
d2824 2
a2825 1
		complain (&unknown_symchar_complaint, p[1]);
@


1.21
log
@2002-10-25  Andrew Cagney  <cagney@@redhat.com>

	* complaints.h (struct deprecated_complaint): Rename `struct
	complaint'.
	* complaints.c (complain): Update.
	* remote-vx68.c, remote-vxmips.c, remote-vxsparc.c: Delete
	incorrect comment indicating that "symfile.h" was being included
	for the `struct complaint' definition.
	* remote-vx.c: Update.
	* objc-lang.c: Update.
	* xcoffread.c: Update.
	* hpread.c: Update.
	* mdebugread.c: Update.
	* stabsread.c: Update.
	* dwarf2read.c: Update.
	* dwarfread.c: Update.
	* elfread.c: Update.
	* coffread.c: Update.
	* stabsread.h: Update.
	* dbxread.c: Update.
	* buildsym.c: Update.
	* gdbtypes.c: Update.
	* macrotab.c: Update.
@
text
@d1637 1
a1637 1
  boolean xcoff64 = bfd_xcoff_is_xcoff64 (objfile->obfd);
@


1.20
log
@	From Nicholas Duffek:
	* xcoffread.c (scan_xcoff_symtab): Recognize XMC_TD as a data storage
	csect.
@
text
@d153 1
a153 1
static struct complaint storclass_complaint =
d156 1
a156 1
static struct complaint bf_notfound_complaint =
d159 1
a159 1
static struct complaint ef_complaint =
d162 1
a162 1
static struct complaint eb_complaint =
d486 1
a486 1
      static struct complaint msg =
d505 1
a505 1
      static struct complaint msg =
d769 1
a769 1
	  static struct complaint msg =
d867 1
a867 1
  static struct complaint msg =
d1335 1
a1335 1
	    static struct complaint msg =
d1606 1
a1606 1
      static struct complaint msg =
d2445 1
a2445 1
	    static struct complaint msg =
d2568 1
a2568 1
	    static struct complaint function_outside_compilation_unit = {
@


1.20.10.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d3 1
a3 1
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d153 5
a157 5
static void
bf_notfound_complaint (void)
{
  complaint (&symfile_complaints, "line numbers off, `.bf' symbol not found");
}
d159 2
a160 6
static void
ef_complaint (int arg1)
{
  complaint (&symfile_complaints,
	     "Mismatched .ef symbol ignored starting at symnum %d", arg1);
}
d162 2
a163 6
static void
eb_complaint (int arg1)
{
  complaint (&symfile_complaints,
	     "Mismatched .eb symbol ignored starting at symnum %d", arg1);
}
d185 4
a188 2
static void xcoff_symfile_offsets (struct objfile *,
				   struct section_addr_info *addrs);
d232 1
a232 1
find_targ_sec (bfd *abfd, asection *sect, void *obj)
d486 3
a488 1
      complaint (&symfile_complaints, "Nested C_BINCL symbols");
d505 3
a507 1
      complaint (&symfile_complaints, "Mismatched C_BINCL/C_EINCL pair");
d769 3
a771 2
	  complaint (&symfile_complaints,
		     "Bad line table offset in C_EINCL directive");
d867 2
d876 1
a876 1
      complaint (&symfile_complaints, "Unexpected symbol continuation");
d893 1
a893 1
      complaint (&symfile_complaints, "Unexpected symbol continuation");
d1255 1
a1255 1
	  if (DEPRECATED_STREQ (cs->c_name, ".bf"))
d1272 1
a1272 1
	  else if (DEPRECATED_STREQ (cs->c_name, ".ef"))
d1285 1
a1285 1
		  ef_complaint (cs->c_symnum);
d1293 1
a1293 1
		  ef_complaint (cs->c_symnum);
d1335 3
a1337 2
	    complaint (&symfile_complaints, "Unrecognized storage class %d.",
		       cs->c_sclass);
d1367 1
a1367 1
	  if (DEPRECATED_STREQ (cs->c_name, ".bb"))
d1375 1
a1375 1
	  else if (DEPRECATED_STREQ (cs->c_name, ".eb"))
d1379 1
a1379 1
		  eb_complaint (cs->c_symnum);
d1385 1
a1385 1
		  eb_complaint (cs->c_symnum);
d1441 1
a1441 1
process_xcoff_symbol (struct coff_symbol *cs, struct objfile *objfile)
d1444 1
a1444 1
  struct symbol *sym = &onesymbol;
d1472 1
a1472 1
  SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d1481 1
a1481 1
      DEPRECATED_SYMBOL_NAME (sym) = SYMNAME_ALLOC (name, symname_alloced);
d1523 1
a1523 2
	  complaint (&symfile_complaints, "Unexpected storage class: %d",
		     cs->c_sclass);
d1606 3
a1608 1
      complaint (&symfile_complaints, "Invalid symbol offset");
d1637 1
a1637 1
  int xcoff64 = bfd_xcoff_is_xcoff64 (objfile->obfd);
d1650 1
a1650 1
      bf_notfound_complaint ();
d1677 1
a1677 1
	  if (DEPRECATED_STREQ (name, ".bf"))
d1683 1
a1683 1
  bf_notfound_complaint ();
d1703 1
a1703 1
find_linenos (struct bfd *abfd, struct bfd_section *asect, void *vpinfo)
d1711 1
a1711 1
  if (!DEPRECATED_STREQ (asect->name, ".text") || count == 0)
d1771 1
a2120 8
function_outside_compilation_unit_complaint (const char *arg1)
{
  complaint (&symfile_complaints,
	     "function `%s' appears to be defined outside of all compilation units",
	     arg1);
}

static void
d2445 3
a2447 2
	    complaint (&symfile_complaints,
		       "Storage class %d not recognized during scan", sclass);
d2530 1
a2530 1
	    if (pst && DEPRECATED_STREQ (namestring, pst->filename))
d2533 1
a2533 1
	      int i;
d2535 1
a2535 1
		if (DEPRECATED_STREQ (namestring, psymtab_include_list[i]))
d2551 1
a2551 1
		memcpy (psymtab_include_list, orig,
d2567 5
d2595 1
a2595 1
				     VAR_DOMAIN, LOC_STATIC,
d2606 1
a2606 1
				     VAR_DOMAIN, LOC_STATIC,
d2624 1
a2624 1
					 STRUCT_DOMAIN, LOC_TYPEDEF,
d2632 1
a2632 1
					     VAR_DOMAIN, LOC_TYPEDEF,
d2638 14
d2659 1
a2659 1
					 VAR_DOMAIN, LOC_TYPEDEF,
d2721 1
a2721 1
					     VAR_DOMAIN, LOC_CONST,
d2739 1
a2739 1
				     VAR_DOMAIN, LOC_CONST,
d2751 1
a2751 1
		    function_outside_compilation_unit_complaint (name);
d2756 1
a2756 1
				     VAR_DOMAIN, LOC_BLOCK,
d2772 1
a2772 1
		    function_outside_compilation_unit_complaint (name);
d2777 1
a2777 1
				     VAR_DOMAIN, LOC_BLOCK,
d2800 3
d2823 1
a2823 2
		complaint (&symfile_complaints,
			   "unknown symbol descriptor `%c'", p[1]);
d2900 1
a2900 1
	struct bfd_section *secp;
d2978 1
a2978 1
  objfile->num_sections = bfd_count_sections (objfile->obfd);
d2980 1
a2980 2
    obstack_alloc (&objfile->psymbol_obstack, 
		   SIZEOF_N_SECTION_OFFSETS (objfile->num_sections));
@


1.20.10.2
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d3 1
a3 1
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
d991 1
a991 1
		p = obstack_alloc (&objfile->objfile_obstack, E_SYMNMLEN + 1);
d1425 1
a1425 1
  	obstack_alloc (&objfile->objfile_obstack, sizeof (struct symbol)); \
d1430 1
a1430 1
  (ALLOCED) ? (NAME) : obsavestring ((NAME), strlen (NAME), &objfile->objfile_obstack);
d1897 1
a1897 1
  /* Allocate string table from objfile_obstack. We will need this table
d1900 1
a1900 1
  strtbl = (char *) obstack_alloc (&objfile->objfile_obstack, length);
d1949 1
a1949 1
    obstack_alloc (&objfile->objfile_obstack, sizeof (struct symloc));
d1996 1
a1996 1
	obstack_alloc (&objfile->objfile_obstack,
d2011 1
a2011 1
	(char *) obstack_alloc (&objfile->objfile_obstack,
d2021 1
a2021 1
	obstack_alloc (&objfile->objfile_obstack,
d2084 1
a2084 1
	  p = obstack_alloc (&objfile->objfile_obstack, E_SYMNMLEN + 1);
d2893 1
a2893 1
		  (char *) obstack_alloc (&objfile->objfile_obstack, length);
d2916 1
a2916 1
    obstack_alloc (&objfile->objfile_obstack, size);
d2962 1
a2962 1
    obstack_alloc (&objfile->objfile_obstack, 
@


1.20.8.1
log
@2002-09-18  David Carlton  <carlton@@math.stanford.edu>

	* symtab.h: Delete BLOCK_SHOULD_SORT.
	* symtab.c (lookup_block_symbol): Assume non-hashed blocks aren't
	sorted.
	* ada-lang.c (ada_add_block_symbols): Ditto.
	* symfile.h: Delete prototypes for sort_block_syms and
	sort_symtab_syms.
	* symfile.c: Delete functions sort_block_syms and
	sort_symtab_syms.
	* coffread.c (coff_symfile_read): Remove call to
	sort_symtab_syms.
	* xcoffread.c (xcoff_psymtab_to_symtab_1): Ditto.
	* mdebugread.c (psymtab_to_symtab_1): Ditto.
	* hpread.c (hpread_psymtab_to_symtab_1): Ditto.
	* dwarfread.c (psymtab_to_symtab_1): Ditto.
	* dwarf2read.c (psymtab_to_symtab_1): Ditto.
	* dbxread.c (dbx_psymtab_to_symtab_1): Ditto.

2002-09-20  David Carlton  <carlton@@math.stanford.edu>

	* Makefile.in (c-lang.o): Correct dependencies.
	(utils.o): Gather dependencies.
	(charset.o): Move.
@
text
@d1771 1
@


1.20.8.2
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d153 1
a153 1
static struct deprecated_complaint storclass_complaint =
d156 1
a156 1
static struct deprecated_complaint bf_notfound_complaint =
d159 1
a159 1
static struct deprecated_complaint ef_complaint =
d162 1
a162 1
static struct deprecated_complaint eb_complaint =
d486 1
a486 1
      static struct deprecated_complaint msg =
d505 1
a505 1
      static struct deprecated_complaint msg =
d769 1
a769 1
	  static struct deprecated_complaint msg =
d867 1
a867 1
  static struct deprecated_complaint msg =
d1335 1
a1335 1
	    static struct deprecated_complaint msg =
d1606 1
a1606 1
      static struct deprecated_complaint msg =
d2444 1
a2444 1
	    static struct deprecated_complaint msg =
d2567 1
a2567 1
	    static struct deprecated_complaint function_outside_compilation_unit = {
@


1.20.8.3
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d153 5
a157 5
static void
bf_notfound_complaint (void)
{
  complaint (&symfile_complaints, "line numbers off, `.bf' symbol not found");
}
d159 2
a160 6
static void
ef_complaint (int arg1)
{
  complaint (&symfile_complaints,
	     "Mismatched .ef symbol ignored starting at symnum %d", arg1);
}
d162 2
a163 6
static void
eb_complaint (int arg1)
{
  complaint (&symfile_complaints,
	     "Mismatched .eb symbol ignored starting at symnum %d", arg1);
}
d486 3
a488 1
      complaint (&symfile_complaints, "Nested C_BINCL symbols");
d505 3
a507 1
      complaint (&symfile_complaints, "Mismatched C_BINCL/C_EINCL pair");
d769 3
a771 2
	  complaint (&symfile_complaints,
		     "Bad line table offset in C_EINCL directive");
d867 2
d876 1
a876 1
      complaint (&symfile_complaints, "Unexpected symbol continuation");
d893 1
a893 1
      complaint (&symfile_complaints, "Unexpected symbol continuation");
d1285 1
a1285 1
		  ef_complaint (cs->c_symnum);
d1293 1
a1293 1
		  ef_complaint (cs->c_symnum);
d1335 3
a1337 2
	    complaint (&symfile_complaints, "Unrecognized storage class %d.",
		       cs->c_sclass);
d1379 1
a1379 1
		  eb_complaint (cs->c_symnum);
d1385 1
a1385 1
		  eb_complaint (cs->c_symnum);
d1523 1
a1523 2
	  complaint (&symfile_complaints, "Unexpected storage class: %d",
		     cs->c_sclass);
d1606 3
a1608 1
      complaint (&symfile_complaints, "Invalid symbol offset");
d1637 1
a1637 1
  int xcoff64 = bfd_xcoff_is_xcoff64 (objfile->obfd);
d1650 1
a1650 1
      bf_notfound_complaint ();
d1683 1
a1683 1
  bf_notfound_complaint ();
a2119 8
function_outside_compilation_unit_complaint (const char *arg1)
{
  complaint (&symfile_complaints,
	     "function `%s' appears to be defined outside of all compilation units",
	     arg1);
}

static void
d2444 3
a2446 2
	    complaint (&symfile_complaints,
		       "Storage class %d not recognized during scan", sclass);
d2566 5
d2750 1
a2750 1
		    function_outside_compilation_unit_complaint (name);
d2771 1
a2771 1
		    function_outside_compilation_unit_complaint (name);
d2822 1
a2822 2
		complaint (&symfile_complaints,
			   "unknown symbol descriptor `%c'", p[1]);
@


1.20.8.4
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d3 1
a3 1
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d193 2
a194 2
static void xcoff_symfile_offsets (struct objfile *,
				   struct section_addr_info *addrs);
d196 1
a196 1
static void find_linenos (bfd *, sec_ptr, void *);
d240 1
a240 1
find_targ_sec (bfd *abfd, asection *sect, void *obj)
d1702 1
a1702 1
find_linenos (bfd *abfd, sec_ptr asect, void *vpinfo)
d2556 1
a2556 1
		memcpy (psymtab_include_list, orig,
d2638 14
a2651 16
#if 0 /* OBSOLETE CFront */
// OBSOLETE  		    /* The semantics of C++ state that "struct foo { ... }"
// OBSOLETE  		       also defines a typedef for "foo".  Unfortuantely, cfront
// OBSOLETE  		       never makes the typedef when translating from C++ to C.
// OBSOLETE  		       We make the typedef here so that "ptype foo" works as
// OBSOLETE  		       expected for cfront translated code.  */
// OBSOLETE  		    else if (psymtab_language == language_cplus)
// OBSOLETE  		      {
// OBSOLETE  			/* Also a typedef with the same name.  */
// OBSOLETE  			add_psymbol_to_list (namestring, p - namestring,
// OBSOLETE  					     VAR_NAMESPACE, LOC_TYPEDEF,
// OBSOLETE  					     &objfile->static_psymbols,
// OBSOLETE  					     symbol.n_value, 0,
// OBSOLETE  					     psymtab_language, objfile);
// OBSOLETE  		      }
#endif /* OBSOLETE CFront */
d2800 3
a2802 5
#if 0 /* OBSOLETE CFront */
// OBSOLETE 		/* added to support cfront stabs strings */
// OBSOLETE 	      case 'Z':		/* for definition continuations */
// OBSOLETE 	      case 'P':		/* for prototypes */
#endif /* OBSOLETE CFront */
@


1.20.8.5
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d1481 1
a1481 1
      DEPRECATED_SYMBOL_NAME (sym) = SYMNAME_ALLOC (name, symname_alloced);
@


1.20.8.6
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d1472 1
a1472 1
  SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d2595 1
a2595 1
				     VAR_DOMAIN, LOC_STATIC,
d2606 1
a2606 1
				     VAR_DOMAIN, LOC_STATIC,
d2624 1
a2624 1
					 STRUCT_DOMAIN, LOC_TYPEDEF,
d2632 1
a2632 1
					     VAR_DOMAIN, LOC_TYPEDEF,
d2648 1
a2648 1
// OBSOLETE  					     VAR_DOMAIN, LOC_TYPEDEF,
d2661 1
a2661 1
					 VAR_DOMAIN, LOC_TYPEDEF,
d2723 1
a2723 1
					     VAR_DOMAIN, LOC_CONST,
d2741 1
a2741 1
				     VAR_DOMAIN, LOC_CONST,
d2758 1
a2758 1
				     VAR_DOMAIN, LOC_BLOCK,
d2779 1
a2779 1
				     VAR_DOMAIN, LOC_BLOCK,
@


1.20.8.7
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d2983 1
a2983 1
  objfile->num_sections = bfd_count_sections (objfile->obfd);
d2985 1
a2985 2
    obstack_alloc (&objfile->psymbol_obstack, 
		   SIZEOF_N_SECTION_OFFSETS (objfile->num_sections));
@


1.20.8.8
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d1441 1
a1441 1
process_xcoff_symbol (struct coff_symbol *cs, struct objfile *objfile)
d1444 1
a1444 1
  struct symbol *sym = &onesymbol;
d2538 1
a2538 1
	      int i;
@


1.20.8.9
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d196 2
d1702 1
a1702 1
find_linenos (struct bfd *abfd, struct bfd_section *asect, void *vpinfo)
d2638 16
d2802 5
d2905 1
a2905 1
	struct bfd_section *secp;
@


1.20.8.10
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d1254 1
a1254 1
	  if (DEPRECATED_STREQ (cs->c_name, ".bf"))
d1271 1
a1271 1
	  else if (DEPRECATED_STREQ (cs->c_name, ".ef"))
d1365 1
a1365 1
	  if (DEPRECATED_STREQ (cs->c_name, ".bb"))
d1373 1
a1373 1
	  else if (DEPRECATED_STREQ (cs->c_name, ".eb"))
d1674 1
a1674 1
	  if (DEPRECATED_STREQ (name, ".bf"))
d1708 1
a1708 1
  if (!DEPRECATED_STREQ (asect->name, ".text") || count == 0)
d2533 1
a2533 1
	    if (pst && DEPRECATED_STREQ (namestring, pst->filename))
d2538 1
a2538 1
		if (DEPRECATED_STREQ (namestring, psymtab_include_list[i]))
@


1.19
log
@Don't use BFD-private data to determine that an object file is 64-bit xcoff.
@
text
@d2280 1
@


1.19.6.1
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@a2279 1
		  case XMC_TD:
@


1.19.6.2
log
@merge from mainline
@
text
@d153 1
a153 1
static struct deprecated_complaint storclass_complaint =
d156 1
a156 1
static struct deprecated_complaint bf_notfound_complaint =
d159 1
a159 1
static struct deprecated_complaint ef_complaint =
d162 1
a162 1
static struct deprecated_complaint eb_complaint =
d486 1
a486 1
      static struct deprecated_complaint msg =
d505 1
a505 1
      static struct deprecated_complaint msg =
d769 1
a769 1
	  static struct deprecated_complaint msg =
d867 1
a867 1
  static struct deprecated_complaint msg =
d1335 1
a1335 1
	    static struct deprecated_complaint msg =
d1606 1
a1606 1
      static struct deprecated_complaint msg =
d2445 1
a2445 1
	    static struct deprecated_complaint msg =
d2568 1
a2568 1
	    static struct deprecated_complaint function_outside_compilation_unit = {
@


1.18
log
@mfree() -> xmfree().
@
text
@d41 2
d913 1
a913 1
  char *debugfmt = xcoff_data (abfd)->xcoff64 ? "XCOFF64" : "XCOFF";
d1637 1
a1637 1
  boolean xcoff64 = xcoff_data (objfile->obfd)->xcoff64;
@


1.17
log
@2001-10-01  Elena Zannoni <ezannoni@@redhat.com>

	* xcoffread.c (N_UNDF, N_ABS, N_TEXT, N_DATA, N_BSS, N_COMM, N_FN,
	N_EXT, N_INDR, N_SETA, N_SETT, N_SETD, N_SETB, N_SETV,
	CUR_SYMBOL_TYPE, CUR_SYMBOL_VALUE, START_PSYMTAB, END_PSYMTAB,
	SET_NAMESTRING): Delete definitions.
	Don't include language.h any more.
	Don't include partial-stab.h any more.
	(scan_xcoff_symtab): Don't jump through hoops to reuse code in
	partial-stab.h, include the code directly, instead.

	* Makefile.in (xcoffread.o): Remove dependency on partial-stab.h.
@
text
@d1863 1
a1863 1
      mfree (objfile->md, objfile->sym_private);
@


1.16
log
@	* coffread.c: Replace all occurrences of bfd_read with bfd_bread.
	* dbxread.c: Likewise.
	* dwarf2read.c: Likewise.
	* dwarfread.c: Likewise.
	* somread.c: Likewise.
	* ultra3-nat.c: Likewise.
	* xcoffread.c: Likewise.
@
text
@a49 1
#include "language.h"		/* Needed inside partial-stab.h */
a56 35
/* For interface with partial-stab.h.  */
#define N_UNDF	0		/* Undefined symbol */
#undef N_ABS
#define N_ABS 2
#define N_TEXT 	4		/* Text sym -- defined at offset in text seg */
#define N_DATA 	6		/* Data sym -- defined at offset in data seg */
#define N_BSS 	8		/* BSS  sym -- defined at offset in zero'd seg */
#define	N_COMM	0x12		/* Common symbol (visible after shared lib dynlink) */
#define N_FN	0x1f		/* File name of .o file */
#define	N_FN_SEQ 0x0C		/* N_FN from Sequent compilers (sigh) */
/* Note: N_EXT can only be usefully OR-ed with N_UNDF, N_ABS, N_TEXT,
   N_DATA, or N_BSS.  When the low-order bit of other types is set,
   (e.g. N_WARNING versus N_FN), they are two different types.  */
#define N_EXT 	1		/* External symbol (as opposed to local-to-this-file) */
#define N_INDR 0x0a

/* The following symbols refer to set elements.
   All the N_SET[ATDB] symbols with the same name form one set.
   Space is allocated for the set in the text section, and each set
   elements value is stored into one word of the space.
   The first word of the space is the length of the set (number of elements).

   The address of the set is made into an N_SETV symbol
   whose name is the same as the name of the set.
   This symbol acts like a N_DATA global symbol
   in that it can satisfy undefined external references.  */

/* These appear as input to LD, in a .o file.  */
#define	N_SETA	0x14		/* Absolute set element symbol */
#define	N_SETT	0x16		/* Text set element symbol */
#define	N_SETD	0x18		/* Data set element symbol */
#define	N_SETB	0x1A		/* Bss set element symbol */

/* This is output from LD.  */
#define N_SETV	0x1C		/* Pointer to set vector in data area.  */
a2175 5
      /* This is the type we pass to partial-stab.h.  A less kludgy solution
         would be to break out partial-stab.h into its various parts--shuffle
         off the DBXREAD_ONLY stuff to dbxread.c, and make separate
         pstab-norm.h (for most types), pstab-sol.h (for N_SOL), etc.  */
      int stype;
d2500 44
a2543 2
	  stype = N_SOL;
	  goto pstab;
d2545 8
d2563 169
a2731 15
	  stype = N_LSYM;
	pstab:
	  swap_sym (&symbol, &main_aux[0], &namestring, &sraw_symbol,
		    &ssymnum, objfile);
#define CUR_SYMBOL_TYPE stype
#define CUR_SYMBOL_VALUE symbol.n_value

/* START_PSYMTAB and END_PSYMTAB are never used, because they are only
   called from DBXREAD_ONLY or N_SO code.  Likewise for the symnum
   variable.  */
#define START_PSYMTAB(ofile,fname,low,symoff,global_syms,static_syms) 0
#define END_PSYMTAB(pst,ilist,ninc,c_off,c_text,dep_list,n_deps,textlow_not_set)\
  do {} while (0)
/* We have already set the namestring.  */
#define SET_NAMESTRING()	/* */
d2733 94
a2826 1
#include "partial-stab.h"
@


1.15
log
@2001-09-04  Elena Zannoni  <ezannoni@@redhat.com>

	From Daniel Jacobowitz  <drow@@mvista.com>
	* dbxread.c (dbx_symfile_read): Only reinitialize
	the psymbol list if mainline or if both static
	and global lists are empty.
	* dwarf2read.c (dwarf2_build_psymtabs): Likewise.
	* dwarfread.c (dwarf_build_psymtabs): Likewise.
	* xcoffread.c (xcoff_initial_scan): Likewise.
	* os9kread.c (os9k_symfile_read): Likewise.
@
text
@d3 1
a3 1
   1996, 1997, 1998, 1999, 2000
d820 1
a820 1
      bfd_read (ext_lnno, linesz, 1, abfd);
d1926 1
a1926 1
  val = bfd_read ((char *) lengthbuf, 1, sizeof lengthbuf, abfd);
d1947 1
a1947 2
  val = bfd_read (strtbl + sizeof lengthbuf, 1, length - sizeof lengthbuf,
		  abfd);
d2679 2
a2680 2
  val = bfd_read (((struct coff_symfile_info *) objfile->sym_private)->symtbl,
		  size, 1, abfd);
@


1.14
log
@	* config/rs6000/tm-rs6000.h (IN_SOLIB_RETURN_TRAMPOLINE): Define.
	(rs6000_in_solib_return_trampoline): Declare.
	* rs6000-tdep.c (rs6000_in_solib_return_trampoline): New
	function.
	(rs6000_skip_trampoline_code): Skip bigtoc fixup code.
	* xcoffread.c (read_xcoff_symtab): Perform the ISFCN function
	check after the CSECT check rather than before it.  Allocate
	separate symtabs for CSECTs whose names begin with '@@'.
	(scan_xcoff_symtab): Don't ignore symbols beginning with '@@'.
	Activate the misc_func_recorded mechanism for whose names begin
	with '@@'.
@
text
@d2687 2
a2688 2
      || objfile->global_psymbols.size == 0
      || objfile->static_psymbols.size == 0)
@


1.13
log
@	* xcoffread.c (scan_xcoff_symtab): Ignore symbols beginning with
	"@@".
@
text
@a1083 8
      /* if explicitly specified as a function, treat is as one. */
      if (ISFCN (cs->c_type) && cs->c_sclass != C_TPDEF)
	{
	  bfd_coff_swap_aux_in (abfd, raw_auxptr, cs->c_type, cs->c_sclass,
				0, cs->c_naux, &main_aux);
	  goto function_entry_point;
	}

d1153 2
a1154 1
		      if (cs->c_name && cs->c_name[0] == '.')
d1228 10
d2249 2
a2250 8
	    /* If symbol name starts with ".$" or "$", ignore it. 

	       A symbol like "@@FIX1" introduces a section for -bbigtoc jump
	       tables, which contain anonymous linker-generated code. 
	       Ignore those sections to avoid "pc 0x... in read in psymtab,
	       but not in symtab" warnings from find_pc_sect_symtab.  */

	    if (namestring[0] == '$' || namestring[0] == '@@'
d2296 5
a2300 1
		    if (namestring && namestring[0] == '.')
@


1.12
log
@Update/correct copyright notices.
@
text
@d2246 8
a2253 2
	    /* If symbol name starts with ".$" or "$", ignore it.  */
	    if (namestring[0] == '$'
@


1.11
log
@Replace free() with xfree().
@
text
@d2 2
a3 1
   Copyright 1986, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 1997
@


1.10
log
@Protoization.
@
text
@d446 1
a446 1
      free (fentry);
d476 1
a476 1
  free (fentry);
d678 1
a678 1
	  free (lv);
d728 1
a728 1
	    free (current_subfile->name);
d743 1
a743 1
	      free (lv);
d1901 1
a1901 1
      free (inclTable);
@


1.9
log
@2000-08-27  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

	* pa64solib.c (pa64_solib_load_symbols): Don't use ANOFFSET as an
 	lvalue.
	* xcoffread.c (xcoff_symfile_offsets): Ditto
	* somsolib.c (som_solib_section_offsets): Ditto.
	* somread.c (som_symfile_offsets): Ditto.
	* rs6000-nat.c (vmap_symtab): Ditto.
	* remote-vx.c (vx_add_symbols): Ditto.
	* remote-os9k.c (rombug_wait): Ditto.
@
text
@d411 1
a411 2
arrange_linetable (oldLineTb)
     struct linetable *oldLineTb;	/* old linetable */
d2602 1
a2602 3
xcoff_initial_scan (objfile, mainline)
     struct objfile *objfile;
     int mainline;		/* FIXME comments above */
@


1.8
log
@2000-08-07  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

	* objfiles.h (SECT_OFF_BSS): Don't detect invalid sect_index_bss
 	here, let the users of the macro do it.
	* symtab.h (ANOFFSET): Detect here if the section index is not
 	initialized.
	* xcoffread.c (find_targ_sec): Don't treat .bss as special,
 	because some objfiles may not have that section at all.
	* coffread.c (cs_to_section): Ditto.
	* elfread.c (elf_symtab_read): Detect an uninitialized index
 	value.
	(elfstab_offset_sections): The macro ANOFFSET cannot be used as an
 	lvalue anymore.
	* remote.c (get_offsets, remote_cisco_objfile_relocate): Don't use
 	ANOFFSET as an lvalue.
	* objfiles.c (objfile_relocate, objfile_relocate): Don't use
 	ANOFFSET as an lvalue.
	* symfile.c (default_symfile_offsets): Don't use ANOFFSET as an
 	lvalue.
@
text
@d2747 1
a2747 1
	ANOFFSET (objfile->section_offsets, i) = 0;
@


1.7
log
@Protoization.
@
text
@d277 1
a277 1
	*args->resultp = SECT_OFF_BSS (objfile);
@


1.6
log
@	* xcoffread.c (read_symbol_nvalue): Return CORE_ADDR.
	* rs6000-tdep.c (rs6000_pop_frame): Make addr CORE_ADDR type.
@
text
@d265 1
a265 4
find_targ_sec (abfd, sect, obj)
     bfd *abfd;
     asection *sect;
     PTR obj;
d284 1
a284 3
secnum_to_section (secnum, objfile)
     int secnum;
     struct objfile *objfile;
d299 1
a299 3
secnum_to_bfd_section (secnum, objfile)
     int secnum;
     struct objfile *objfile;
d317 1
a317 3
add_stab_to_list (stabname, stabvector)
     char *stabname;
     struct pending_stabs **stabvector;
d397 1
a397 3
compare_lte (lte1p, lte2p)
     const void *lte1p;
     const void *lte2p;
d510 1
a510 2
record_include_begin (cs)
     struct coff_symbol *cs;
d533 1
a533 2
record_include_end (cs)
     struct coff_symbol *cs;
d554 1
a554 1
allocate_include_entry ()
d583 1
a583 2
process_linenos (start, end)
     CORE_ADDR start, end;
d764 1
a764 1
aix_process_linenos ()
d780 3
a782 6
enter_line_range (subfile, beginoffset, endoffset, startaddr, endaddr,
		  firstLine)
     struct subfile *subfile;
     unsigned beginoffset, endoffset;	/* offsets to line table */
     CORE_ADDR startaddr, endaddr;
     unsigned *firstLine;
d898 1
a898 2
xcoff_next_symbol_text (objfile)
     struct objfile *objfile;
d939 1
a939 2
read_xcoff_symtab (pst)
     struct partial_symtab *pst;
d1472 1
a1472 3
process_xcoff_symbol (cs, objfile)
     register struct coff_symbol *cs;
     struct objfile *objfile;
d1609 1
a1609 3
coff_getfilename (aux_entry, objfile)
     union internal_auxent *aux_entry;
     struct objfile *objfile;
d1627 1
a1627 3
read_symbol (symbol, symno)
     struct internal_syment *symbol;
     int symno;
d1652 1
a1652 2
read_symbol_nvalue (symno)
     int symno;
d1665 1
a1665 2
read_symbol_lineno (symno)
     int symno;
d1734 1
a1734 4
find_linenos (abfd, asect, vpinfo)
     bfd *abfd;
     sec_ptr asect;
     PTR vpinfo;
d1760 1
a1760 2
xcoff_psymtab_to_symtab_1 (pst)
     struct partial_symtab *pst;
d1816 1
a1816 2
xcoff_psymtab_to_symtab (pst)
     struct partial_symtab *pst;
d1859 1
a1859 2
xcoff_new_init (objfile)
     struct objfile *objfile;
d1872 1
a1872 2
xcoff_symfile_init (objfile)
     struct objfile *objfile;
d1892 1
a1892 2
xcoff_symfile_finish (objfile)
     struct objfile *objfile;
d1910 1
a1910 4
init_stringtab (abfd, offset, objfile)
     bfd *abfd;
     file_ptr offset;
     struct objfile *objfile;
d1973 3
a1975 7
xcoff_start_psymtab (objfile, filename, first_symnum, global_syms,
		     static_syms)
     struct objfile *objfile;
     char *filename;
     int first_symnum;
     struct partial_symbol **global_syms;
     struct partial_symbol **static_syms;
d2008 4
a2011 9
xcoff_end_psymtab (pst, include_list, num_includes, capping_symbol_number,
		   dependency_list, number_dependencies, textlow_not_set)
     struct partial_symtab *pst;
     char **include_list;
     int num_includes;
     int capping_symbol_number;
     struct partial_symtab **dependency_list;
     int number_dependencies;
     int textlow_not_set;
d2106 3
a2108 7
swap_sym (symbol, aux, name, raw, symnump, objfile)
     struct internal_syment *symbol;
     union internal_auxent *aux;
     char **name;
     char **raw;
     unsigned int *symnump;
     struct objfile *objfile;
d2153 1
a2153 2
scan_xcoff_symtab (objfile)
     struct objfile *objfile;
d2585 1
a2585 2
get_toc_offset (objfile)
     struct objfile *objfile;
d2710 1
a2710 3
xcoff_symfile_offsets (objfile, addrs)
     struct objfile *objfile;
     struct section_addr_info *addrs;
d2776 1
a2776 1
_initialize_xcoffread ()
@


1.5
log
@	* rs6000-tdep.c: Changes throughout for multi-arch 64-bit
	support.  Incorporate most of tm-rs6000.h.
	(find_toc_address_hook): Rename to rs6000_find_toc_address_hook.
	(rs6000_set_host_arch_hook): Declare.
	(read_memory_addr): Define.
	(pop_frame): Rename to rs6000_pop_frame.
	(rs6000_pop_frame, rs6000_fix_call_dummy, rs6000_push_arguments,
	rs6000_frame_saved_pc, rs6000_frame_chain): Remove non-generic
	dummy frame handling.
	(branch_dest, rs6000_pop_frame, rs6000_skip_trampoline_code,
	rs6000_frame_saved_pc, frame_get_saved_regs,
	frame_initial_stack_address, rs6000_frame_chain,
	rs6000_convert_from_func_ptr_addr): Call read_memory_addr instead
	of read_memory_integer.
	(branch_dest, rs6000_pop_frame, rs6000_push_arguments,
	rs6000_skip_trampoline_code, rs6000_frame_saved_pc,
	frame_get_saved_regs, frame_initial_stack_address,
	rs6000_frame_chain): Replace 4 with TDEP->wordsize.
	(skip_prologue): Recognize some 64-bit stack adjustments.
	(push_dummy_frame, pop_dummy_frame, set_processor,
	show_processor): Delete.
	(frame_get_saved_regs): Manipulate saved register addresses using
	CORE_ADDR instead of int.
	(rs6000_create_inferior): New function.
	(register_names_*[]): Change to struct reg registers_*[].
	(variants[]): Assimilate into multi-arch approach.
	(register_names_*[], variants[]): Refer to pre-PowerPC
	architectures as POWER instead of RS6000.
	* rs6000-nat.c: Ubiquitous changes for 64-bit support.
	(vmap_secs, xcoff_relocate_symtab): Cast addresses
	to unsigned long to avoid sign-extension errors.
	(set_host_arch): New function.
	(xcoff_relocate_symtab): Try disabling usleep(36000) workaround.
	(rs6000_core_fns): Use new bfd_target_xcoff_flavour.
	(_initialize_core_rs6000): Initialize rs6000_set_host_arch_hook.
	* symfile.c (find_sym_fns): Remove special xcoff kludge.
	* xcoffread.c (secnum_to_bfd_section): Initialize args.objfile.
	(process_linenos): Query line struct size from coff
	backend instead of using compile-time constant.
	(enter_line_range): Likewise.
	(read_xcoff_symtab): Pass "XCOFF64" instead of "XCOFF" to
	record_debugformat() if appropriate.
	(process_xcoff_symbol): Access symbol addresses using
	SYMBOL_VALUE_ADDRESS instead of SYMBOL_VALUE.
	(read_symbol_lineno): Retrieve XCOFF64 symbol names from strtbl.
	(scan_xcoff_symtab): Likewise.  Query syment struct size from
	coff backend instead of using compile-time constant.
	(xcoff_sym_fns): Set flavour to bfd_target_xcoff_flavour.
	* Makefile.in (INTERNAL_LDFLAGS): Add $(MH_LDFLAGS) to list of flags
	that this Makefile variable get set to.  (From Kevin Buettner.)
	* config/powerpc/aix.mh (MH_LDFLAGS): Add linker flags so that
	the TOC doesn't overflow.  (From Kevin Buettner.)
	* config/powerpc/tm-ppc-aix.h: Move config decisions to
	multi-arched rs6000-tdep.c.
	* config/rs6000/tm-rs6000.h: Likewise.
	(GDB_MULTI_ARCH): Define.
	(skip_trampoline_code): Rename to rs6000_skip_trampoline_code.
	(is_magic_function_pointer): Replace with
	rs6000_convert_from_func_ptr_addr.
	(TARGET_CREATE_INFERIOR_HOOK): Define.
	(find_toc_address_hook): Rename to rs6000_find_toc_address_hook.
	(rs6000_set_host_arch_hook): Declare.
	* config/rs6000/nm-rs6000.h (CHILD_XFER_MEMORY): Define.
@
text
@d229 1
a229 1
static int read_symbol_nvalue (int);
d1676 1
a1676 1
static int
@


1.4
log
@PARAMS removal.
@
text
@d314 1
d632 3
d636 1
d645 1
a645 1
		(&main_subfile, offset, inclTable[ii].begin - LINESZ,
d662 1
a662 1
	    offset = inclTable[ii].end + LINESZ;
d667 1
a667 1
      if (offset < max_offset + 1 - LINESZ)
d803 1
a803 1
  struct external_lineno ext_lnno;
d807 1
d829 1
d831 2
d837 2
a838 2
      bfd_read (&ext_lnno, sizeof (struct external_lineno), 1, abfd);
      bfd_coff_swap_lineno_in (abfd, &ext_lnno, &int_lnno);
d858 1
a858 1
      curoffset += LINESZ;
d966 1
d1004 1
a1004 1
  record_debugformat ("XCOFF");
d1068 1
a1068 1
	raw_symbol += coff_data (abfd)->local_symesz;
d1098 1
a1098 1
	  record_debugformat ("XCOFF");
d1163 1
a1163 1
			  record_debugformat ("XCOFF");
d1292 1
a1292 1
	  record_debugformat ("XCOFF");
d1523 1
a1523 1
  SYMBOL_VALUE (sym) = cs->c_value + off;
d1616 1
a1616 1
	      SYMBOL_VALUE (sym) += static_block_base;
d1694 9
a1702 6
  int nsyms =
  ((struct coff_symfile_info *) this_symtab_psymtab->objfile->sym_private)
  ->symtbl_num_syms;
  char *stbl =
  ((struct coff_symfile_info *) this_symtab_psymtab->objfile->sym_private)
  ->symtbl;
d1732 6
a1737 2
      if (symbol->n_sclass == C_FCN && STREQ (symbol->n_name, ".bf"))
	goto gotit;
d1747 1
a1747 2
  bfd_coff_swap_aux_in (this_symtab_psymtab->objfile->obfd,
			stbl + symno * local_symesz,
d2261 1
a2261 1
      int sclass = ((struct external_syment *) sraw_symbol)->e_sclass[0] & 0xff;
d2270 3
d2580 1
a2580 2
	    int naux1 =
	    ((struct external_syment *) sraw_symbol)->e_numaux[0] + 1;
d2582 1
a2582 1
	    sraw_symbol += sizeof (struct external_syment) * naux1;
d2601 1
a2601 1
	pstab:;
d2811 1
a2811 2
  /* Because the bfd uses coff_flavour, we need to specially kludge
     the flavour.  It is possible that coff and xcoff should be merged as
d2820 1
a2820 1
  (enum bfd_flavour) -1,
@


1.3
log
@Cleanup discard_minimal_symbols cleanup.
@
text
@d198 1
a198 2
static void
xcoff_initial_scan PARAMS ((struct objfile *, int));
d200 1
a200 2
static void
scan_xcoff_symtab PARAMS ((struct objfile *));
d202 1
a202 2
static char *
  xcoff_next_symbol_text PARAMS ((struct objfile *));
d204 1
a204 2
static void
record_include_begin PARAMS ((struct coff_symbol *));
d207 2
a208 2
enter_line_range PARAMS ((struct subfile *, unsigned, unsigned,
			  CORE_ADDR, CORE_ADDR, unsigned *));
d210 1
a210 2
static void
init_stringtab PARAMS ((bfd *, file_ptr, struct objfile *));
d212 1
a212 2
static void
xcoff_symfile_init PARAMS ((struct objfile *));
d214 1
a214 2
static void
xcoff_new_init PARAMS ((struct objfile *));
d216 1
a216 2
static void
xcoff_symfile_finish PARAMS ((struct objfile *));
d219 1
a219 1
  xcoff_symfile_offsets PARAMS ((struct objfile *, struct section_addr_info *addrs));
d221 1
a221 2
static void
find_linenos PARAMS ((bfd *, sec_ptr, PTR));
d223 1
a223 2
static char *
  coff_getfilename PARAMS ((union internal_auxent *, struct objfile *));
d225 1
a225 2
static void
read_symbol PARAMS ((struct internal_syment *, int));
d227 1
a227 2
static int
read_symbol_lineno PARAMS ((int));
d229 1
a229 2
static int
read_symbol_nvalue PARAMS ((int));
d231 2
a232 2
static struct symbol *
  process_xcoff_symbol PARAMS ((struct coff_symbol *, struct objfile *));
d234 1
a234 2
static void
read_xcoff_symtab PARAMS ((struct partial_symtab *));
d237 1
a237 2
static void
add_stab_to_list PARAMS ((char *, struct pending_stabs **));
d240 1
a240 2
static int
compare_lte PARAMS ((const void *, const void *));
d242 1
a242 2
static struct linetable *
  arrange_linetable PARAMS ((struct linetable *));
d244 1
a244 2
static void
record_include_end PARAMS ((struct coff_symbol *));
d246 1
a246 2
static void
process_linenos PARAMS ((CORE_ADDR, CORE_ADDR));
d251 2
a252 2
static int secnum_to_section PARAMS ((int, struct objfile *));
static asection *secnum_to_bfd_section PARAMS ((int, struct objfile *));
d262 1
a262 1
static void find_targ_sec PARAMS ((bfd *, asection *, void *));
d517 1
a517 1
static void allocate_include_entry PARAMS ((void));
d1771 1
a1771 1
static void xcoff_psymtab_to_symtab_1 PARAMS ((struct partial_symtab *));
d1825 1
a1825 1
static void xcoff_psymtab_to_symtab PARAMS ((struct partial_symtab *));
d1984 2
a1985 2
  PARAMS ((struct objfile *, char *, int,
	   struct partial_symbol **, struct partial_symbol **));
d2022 2
a2023 2
  PARAMS ((struct partial_symtab *, char **, int, int,
	   struct partial_symtab **, int, int));
d2128 3
a2130 4
static void swap_sym PARAMS ((struct internal_syment *,
			      union internal_auxent *, char **, char **,
			      unsigned int *,
			      struct objfile *));
@


1.2
log
@Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * objfiles.h (SECT_OFF_DATA, SECT_OFF_TEXT, SECT_OFF_BSS,
        SECT_OFF_RODATA): Define as functions of OBJFILE.  Add
        sect_index_text, sect_index_data, sect_index_rodata,
        sect_index_bss to objfile structure.
        * gdb-stabs.h (SECT_OFF_DATA, SECT_OFF_TEXT, SECT_OFF_BSS,
        SECT_OFF_RODATA): Remove.
        * objfiles.c (allocate_objfile): Initialize
        sect_index_{text,data,bss,rodata} to -1, for error detection.

        * symfile.c (default_symfile_offsets): Initialize
        sect_index_{text,data,bss,rodata} from bfd information.
        * xcoffread.c (xcoff_symfile_offsets): Ditto.
        * somread.c (som_symfile_offsets): Initialize
        sect_index_{text,data,bss,rodata}.

        * coffread.c, dbxread.c, elfread.c, hp-psymtab-read.c,
        hp-symtab-read.c, hpread.c, mdebugread.c, minsyms.c,
        mipsread.c, objfiles.c, os9kread.c, pa64solib.c, partial-stab.h,
        remote-os9k.c, remote-vx.c, remote.c, rs6000-nat.c, somsolib.c,
        stabsread.c, symfile.c, xcoffread.c:
        Update use of SECT_OFF_{TEXT,DATA,BSS,RODATA} to depend on the
        current objfile.

        * xcoffread.c: Add new field objfile to find_targ_sec_arg.
@
text
@d2749 1
a2749 1
  make_cleanup ((make_cleanup_func) discard_minimal_symbols, 0);
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
   	     Free Software Foundation, Inc.
d7 1
a7 1
This file is part of GDB.
d9 14
a22 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d58 1
a58 1
#define N_UNDF	0	/* Undefined symbol */
d61 6
a66 6
#define N_TEXT 	4	/* Text sym -- defined at offset in text seg */
#define N_DATA 	6	/* Data sym -- defined at offset in data seg */
#define N_BSS 	8	/* BSS  sym -- defined at offset in zero'd seg */
#define	N_COMM	0x12	/* Common symbol (visible after shared lib dynlink) */
#define N_FN	0x1f	/* File name of .o file */
#define	N_FN_SEQ 0x0C	/* N_FN from Sequent compilers (sigh) */
d70 1
a70 1
#define N_EXT 	1	/* External symbol (as opposed to local-to-this-file) */
d96 2
a97 1
struct symloc {
d99 1
a99 1
  /* First symbol number for this file.  */
d101 1
a101 1
  int first_symnum;
d103 5
a107 5
  /* Number of symbols in the section of the symbol table devoted to
     this file's symbols (actually, the section bracketed may contain
     more than just this file's symbols).  If numsyms is 0, the only
     reason for this thing's existence is the dependency list.  Nothing
     else will happen when it is read in.  */
d109 1
a109 1
  int numsyms;
d111 3
a113 3
  /* Position of the start of the line number information for this psymtab.  */
  unsigned int lineno_off;
};
d118 1
a119 1

d122 10
a131 9
struct coff_symbol {
  char *c_name;
  int c_symnum;		/* symbol number of this entry */
  int c_naux;		/* 0 if syment only, 1 if syment + auxent */
  long c_value;
  unsigned char c_sclass;
  int c_secnum;
  unsigned int c_type;
};
d163 1
a163 1
static unsigned	local_symesz;
d165 4
a168 3
struct coff_symfile_info {
  file_ptr min_lineno_offset;		/* Where in file lowest line#s are */
  file_ptr max_lineno_offset;		/* 1+last byte of line#s in file */
d170 2
a171 2
  /* Pointer to the string table.  */
  char *strtbl;
d173 2
a174 2
  /* Pointer to debug section.  */
  char *debugsec;
d176 2
a177 2
  /* Pointer to the a.out symbol table.  */
  char *symtbl;
d179 2
a180 2
  /* Number of symbols in symtbl.  */
  int symtbl_num_syms;
d182 3
a184 3
  /* Offset in data section to TOC anchor.  */
  CORE_ADDR toc_offset;
};
d187 1
a187 1
  {"Unexpected storage class: %d", 0, 0};
d190 1
a190 1
  {"line numbers off, `.bf' symbol not found", 0, 0};
d192 2
a193 2
static struct complaint ef_complaint = 
  {"Mismatched .ef symbol ignored starting at symnum %d", 0, 0};
d195 2
a196 2
static struct complaint eb_complaint = 
  {"Mismatched .eb symbol ignored starting at symnum %d", 0, 0};
d199 1
a199 1
xcoff_initial_scan PARAMS ((struct objfile *, struct section_offsets *, int));
d202 1
a202 1
scan_xcoff_symtab PARAMS ((struct section_offsets *, struct objfile *));
d205 1
a205 1
xcoff_next_symbol_text PARAMS ((struct objfile *));
d226 2
a227 2
static struct section_offsets *
xcoff_symfile_offsets PARAMS ((struct objfile *, CORE_ADDR));
d233 1
a233 1
coff_getfilename PARAMS ((union internal_auxent *, struct objfile *));
d245 1
a245 1
process_xcoff_symbol PARAMS ((struct coff_symbol *, struct objfile *));
d259 1
a259 1
arrange_linetable PARAMS ((struct linetable *));
d266 1
a267 1

d271 1
a271 1
static asection * secnum_to_bfd_section PARAMS ((int, struct objfile *));
d273 7
a279 5
struct find_targ_sec_arg {
  int targ_index;
  int *resultp;
  asection **bfd_sect;
};
d283 2
a284 1
static void find_targ_sec (abfd, sect, obj)
d289 2
a290 1
  struct find_targ_sec_arg *args = (struct find_targ_sec_arg *)obj;
d295 1
a295 1
	*args->resultp = SECT_OFF_TEXT;
d297 1
a297 1
	*args->resultp = SECT_OFF_DATA;
d299 1
a299 1
	*args->resultp = SECT_OFF_BSS;
d310 1
a310 1
  int off = SECT_OFF_TEXT;
d316 1
d327 1
a327 1
  int off = SECT_OFF_TEXT;
d343 2
a344 2
char *stabname;
struct pending_stabs **stabvector;
d346 16
a361 14
  if ( *stabvector == NULL) {
    *stabvector = (struct pending_stabs *)
	xmalloc (sizeof (struct pending_stabs) + 
			INITIAL_STABVECTOR_LENGTH * sizeof (char*));
    (*stabvector)->count = 0;
    (*stabvector)->length = INITIAL_STABVECTOR_LENGTH;
  }
  else if ((*stabvector)->count >= (*stabvector)->length) {
    (*stabvector)->length += INITIAL_STABVECTOR_LENGTH;
    *stabvector = (struct pending_stabs *)
	xrealloc ((char *) *stabvector, sizeof (struct pending_stabs) + 
	(*stabvector)->length * sizeof (char*));
  }
  (*stabvector)->stab [(*stabvector)->count++] = stabname;
d365 1
a365 2


d370 50
a419 47
    1) xlc (IBM's native c compiler) postpones static function code
       emission to the end of a compilation unit. This way it can
       determine if those functions (statics) are needed or not, and
       can do some garbage collection (I think). This makes line
       numbers and corresponding addresses unordered, and we end up
       with a line table like:
       

		lineno	addr
        foo()	  10	0x100
		  20	0x200
		  30	0x300

	foo3()	  70	0x400
		  80	0x500
		  90	0x600

	static foo2()
		  40	0x700
		  50	0x800
		  60	0x900		

	and that breaks gdb's binary search on line numbers, if the
	above table is not sorted on line numbers. And that sort
	should be on function based, since gcc can emit line numbers
	like:
	
		10	0x100	- for the init/test part of a for stmt.
		20	0x200
		30	0x300
		10	0x400	- for the increment part of a for stmt.

	arrange_linetable() will do this sorting.		

     2)	aix symbol table might look like:

		c_file		// beginning of a new file
		.bi		// beginning of include file
		.ei		// end of include file
		.bi
		.ei

	basically, .bi/.ei pairs do not necessarily encapsulate
	their scope. They need to be recorded, and processed later
	on when we come the end of the compilation unit.
	Include table (inclTable) and process_linenos() handle
	that.  */
d441 1
a441 1
     struct linetable *oldLineTb;			/* old linetable */
d443 6
a448 7
  int ii, jj, 
      newline, 					/* new line count */
      function_count;				/* # of functions */

  struct linetable_entry *fentry;		/* function entry vector */
  int fentry_size;				/* # of function entries */
  struct linetable *newLineTb;			/* new line table */
d453 1
a453 1
  fentry = (struct linetable_entry*)
d456 2
a457 1
  for (function_count=0, ii=0; ii <oldLineTb->nitems; ++ii) {
d459 2
a460 1
    if (oldLineTb->item[ii].line == 0) {	/* function entry found. */
d462 17
a478 15
      if (function_count >= fentry_size) {	/* make sure you have room. */
	fentry_size *= 2;
	fentry = (struct linetable_entry*) 
	  xrealloc (fentry, fentry_size * sizeof (struct linetable_entry));
      }
      fentry[function_count].line = ii;
      fentry[function_count].pc = oldLineTb->item[ii].pc;
      ++function_count;
    }
  }

  if (function_count == 0) {
    free (fentry);
    return oldLineTb;
  }
d480 1
a480 1
    qsort (fentry, function_count, sizeof(struct linetable_entry), compare_lte);
d485 2
a486 2
      (sizeof (struct linetable) + 
       (oldLineTb->nitems - function_count) * sizeof (struct linetable_entry));
d493 2
a494 2
    for (newline=0; 
	newline < oldLineTb->nitems && oldLineTb->item[newline].line; ++newline)
d499 7
a505 6
  for (ii=0; ii < function_count; ++ii) {
    for (jj = fentry[ii].line + 1;
	         jj < oldLineTb->nitems && oldLineTb->item[jj].line != 0; 
							 ++jj, ++newline)
      newLineTb->item[newline] = oldLineTb->item[jj];
  }
d508 2
a509 2
  return newLineTb;  
}     
d517 3
a519 2
typedef struct _inclTable {
  char		*name;				/* include filename */
d523 2
a524 2
  int		begin, end;
  
d526 3
a528 2
  unsigned	funStartLine;			/* start line # of its function */
} InclTable;
d531 4
a534 4
static InclTable  *inclTable;			/* global include table */
static int	  inclIndx;			/* last entry to table */
static int	  inclLength;			/* table length */
static int	  inclDepth;			/* nested include depth */
d540 1
a540 1
struct coff_symbol *cs;
d545 1
a545 1
	 of course, but in corresponding .s files.).  */
d548 4
a551 3
	 GCC 2.3.3-930426 does not exhibit this on a test case which
	 a user said produced the message for him.  */
      static struct complaint msg = {"Nested C_BINCL symbols", 0, 0};
d558 2
a559 2
  inclTable [inclIndx].name  = cs->c_name;
  inclTable [inclIndx].begin = cs->c_value;
d564 1
a564 1
struct coff_symbol *cs;
d566 1
a566 1
  InclTable *pTbl;  
d570 2
a571 1
      static struct complaint msg = {"Mismatched C_BINCL/C_EINCL pair", 0, 0};
d577 1
a577 1
  pTbl = &inclTable [inclIndx];
d589 1
a589 1
      inclTable = (InclTable *) 
d599 1
a599 1
      inclTable = (InclTable *) 
d601 2
a602 2
      memset (inclTable + inclLength - INITIAL_INCLUDE_TABLE_LENGTH, 
	      '\0', sizeof (InclTable)*INITIAL_INCLUDE_TABLE_LENGTH);
d619 2
a620 2
    ((struct coff_symfile_info *)this_symtab_psymtab->objfile->sym_private)
      ->max_lineno_offset;
d635 1
a635 1
    ((struct symloc *)this_symtab_psymtab->read_symtab_private)->lineno_off;
d644 2
a645 2
    enter_line_range (&main_subfile, offset, 0, start, end, 
    						&main_source_baseline);
d651 1
a651 1
      for (ii=0; ii < inclIndx; ++ii)
d672 1
a672 1
	  enter_line_range (tmpSubfile, inclTable[ii].begin, 
d680 1
a680 1
	 enter remaining lines of the main file, if any left.  */
d683 1
a683 1
	  enter_line_range (&main_subfile, offset, 0, start, end, 
d696 1
a696 1
	 put static function to the end. */
d711 1
a711 1
      current_subfile->line_vector_length = 
d717 1
a717 1
  for (ii=0; ii < inclIndx; ++ii)
d719 1
a719 1
      if ((inclTable[ii].subfile)->line_vector) /* Useless if!!! FIXMEmgo */
d735 5
a739 5
  		......
	        #include "foo.h"
		......
	 	#include "foo.h"
		......
d747 1
a747 1
	  start_subfile (inclTable[ii].name, (char*)0);
d756 1
a756 1
	    start_subfile (fakename, (char*)0);
d759 1
a759 1
	  current_subfile->name = strdup (inclTable[ii].name);
d766 2
a767 2
		  (lv, (sizeof (struct linetable)
			+ lv->nitems * sizeof (struct linetable_entry)));
d776 1
a776 1
	  current_subfile->line_vector_length = 
d778 1
a778 1
	  start_subfile (pop_subfile (), (char*)0);
d782 1
a782 1
 return_after_cleanup:
d801 2
a802 2
     enter_line_range (subfile, beginoffset, endoffset, startaddr, 0, firstLine)  or
     enter_line_range (subfile, beginoffset, 0, startaddr, endaddr, firstLine)
d811 3
a813 3
     unsigned   beginoffset, endoffset;	/* offsets to line table */
     CORE_ADDR  startaddr, endaddr;
     unsigned   *firstLine;
d826 2
a827 2
    ((struct coff_symfile_info *)this_symtab_psymtab->objfile->sym_private)
      ->max_lineno_offset;
d834 1
a834 1
	    {"Bad line table offset in C_EINCL directive", 0, 0};
d855 1
a855 1
			SECT_OFF_TEXT);
d906 1
a906 1
   
d930 1
a930 1
    {"Unexpected symbol continuation", 0, 0};
d941 1
a941 1
	 code does something reasonable.  */
d947 2
a948 2
	((struct coff_symfile_info *)objfile->sym_private)->debugsec
	  + symbol.n_offset;
d958 1
a958 1
	 code does something reasonable.  */
d973 1
a973 1
  char *strtbl = ((struct coff_symfile_info *)objfile->sym_private)->strtbl;
d975 1
a975 1
    ((struct coff_symfile_info *)objfile->sym_private)->debugsec;
d997 1
a997 1
  char *last_csect_name;		/* last seen csect's name and value */
d1012 1
a1012 1
  start_symtab (filestring, (char *)NULL, file_start_addr);
d1014 1
a1014 1
  symnum = ((struct symloc *)pst->read_symtab_private)->first_symnum;
d1016 1
a1016 1
    symnum + ((struct symloc *)pst->read_symtab_private)->numsyms;
d1021 1
a1021 1
      + symnum * local_symesz;
d1030 4
a1033 4
	 whole symbol table, only string table will be kept in memory,
	 symbol table and debug section of xcoff will be freed. Thus
	 we can mark symbols with names in string table as
	 `alloced'. */
d1048 1
a1048 1
	    cs->c_name = ((struct external_syment *)raw_symbol)->e.e_name;
d1069 1
a1069 1
	    cs->c_name = strtbl + (int)symbol->n_offset;
d1075 1
a1075 1
	cs->c_type = (unsigned)symbol->n_type;
d1101 1
a1101 1
		end_symtab (cur_src_end_addr, objfile, SECT_OFF_TEXT);
d1106 1
a1106 1
	  start_symtab ("_globals_", (char *)NULL, (CORE_ADDR)0);
d1113 1
a1113 1
      if (ISFCN(cs->c_type) && cs->c_sclass != C_TPDEF)
d1152 9
a1160 9
			 symbol table for each program csect.  Normally gdb
			 prefers one symtab for each source file.  In case
			 of AIX, one source file might include more than one
			 [PR] csect, and they don't have to be adjacent in
			 terms of the space they occupy in memory. Thus, one
			 single source file might get fragmented in the
			 memory and gdb's file start and end address
			 approach does not work!  GCC (and I think xlc) seem
			 to put all the code in the unnamed program csect.  */
d1166 1
a1166 1
			  end_symtab (file_end_addr, objfile, SECT_OFF_TEXT);
d1171 1
a1171 1
			  start_symtab (filestring, NULL, (CORE_ADDR)0);
d1176 1
a1176 1
			 basically `__start'. */
d1186 1
a1186 1
						SECT_OFF_TEXT);
d1282 1
a1282 1
	  end_symtab (file_end_addr, objfile, SECT_OFF_TEXT);
d1300 1
a1300 1
	  start_symtab (filestring, (char *)NULL, (CORE_ADDR)0);
d1317 1
a1317 1
					SECT_OFF_TEXT);
d1325 1
a1325 1
	      new->name = define_symbol 
d1329 1
a1329 1
		SYMBOL_SECTION (new->name) = SECT_OFF_TEXT;
d1338 1
a1338 1
		 not useful for gdb.  */
d1340 1
a1340 1
		 contains number of lines to '}' */
d1362 1
a1362 1
					 SECT_OFF_TEXT)),
d1395 1
a1395 1
	      {"Unrecognized storage class %d.", 0, 0};
d1432 1
a1432 1
					       SECT_OFF_TEXT)));
d1454 1
a1454 1
					     SECT_OFF_TEXT)),
d1473 1
a1473 1
      s = end_symtab (file_end_addr, objfile, SECT_OFF_TEXT);
d1488 2
a1489 2
  
 
d1501 2
a1502 2
  register struct coff_symbol *cs;
  struct objfile *objfile;
d1515 1
a1515 1
	 and does not get relocated.  */
d1539 2
a1540 2
	 will be patched with the type from its stab entry later on in
	 patch_block_stabs (), unless the file was compiled without -g.  */
d1561 2
a1562 2
	/* The values of functions and global symbols are now resolved
	   via the global_sym_chain in stabsread.c.  */
d1613 1
a1613 1
	  if (*name == ':' || (pp = (char *) strchr(name, ':')) == NULL)
d1647 1
a1647 1
	    ((struct coff_symfile_info *)objfile->sym_private)->strtbl
d1664 5
a1668 5
    ((struct coff_symfile_info *)this_symtab_psymtab->objfile->sym_private)
      ->symtbl_num_syms;
  char *stbl = 
    ((struct coff_symfile_info *)this_symtab_psymtab->objfile->sym_private)
      ->symtbl;
d1672 1
a1672 1
	{"Invalid symbol offset", 0, 0};
d1679 1
a1679 1
			stbl + (symno*local_symesz),
d1682 1
a1682 1
  
d1692 1
a1692 1
  return symbol->n_value;  
d1704 5
a1708 5
    ((struct coff_symfile_info *)this_symtab_psymtab->objfile->sym_private)
      ->symtbl_num_syms;
  char *stbl = 
    ((struct coff_symfile_info *)this_symtab_psymtab->objfile->sym_private)
      ->symtbl;
d1767 1
a1767 1
     PTR vpinfo; 
d1779 1
a1779 1
  info = (struct coff_symfile_info *)vpinfo;
d1798 1
a1798 1
  
d1822 1
a1822 1
	    wrap_here ("");		/* Flush output */
d1828 1
a1828 1
  if (((struct symloc *)pst->read_symtab_private)->numsyms != 0)
d1833 1
a1833 1
      old_chain = make_cleanup ((make_cleanup_func) really_free_pendings, 0);
d1866 1
a1866 1
  if (((struct symloc *)pst->read_symtab_private)->numsyms != 0
d1870 1
a1870 1
	 to avoid disconcerting pauses.  */
d1902 1
a1902 1
 
d1912 2
a1913 2
  objfile -> sym_private = xmmalloc (objfile -> md,
				     sizeof (struct coff_symfile_info));
d1932 1
a1932 1
  if (objfile -> sym_private != NULL)
d1934 1
a1934 1
      mfree (objfile -> md, objfile -> sym_private);
d1958 1
a1958 1
  ((struct coff_symfile_info *)objfile->sym_private)->strtbl = NULL;
d1964 1
a1964 1
  val = bfd_read ((char *)lengthbuf, 1, sizeof lengthbuf, abfd);
d1977 1
a1977 1
  ((struct coff_symfile_info *)objfile->sym_private)->strtbl = strtbl;
d2003 1
a2003 1
  PARAMS ((struct objfile *, struct section_offsets *, char *, int,
d2014 2
a2015 2
xcoff_start_psymtab (objfile, section_offsets,
		     filename, first_symnum, global_syms, static_syms)
a2016 1
     struct section_offsets *section_offsets;
d2023 5
a2027 5
    start_psymtab_common (objfile, section_offsets,
			  filename,
			  /* We fill in textlow later.  */
			  0,
			  global_syms, static_syms);
d2030 2
a2031 2
    obstack_alloc (&objfile -> psymbol_obstack, sizeof (struct symloc));
  ((struct symloc *)result->read_symtab_private)->first_symnum = first_symnum;
d2064 1
a2064 1
  struct objfile *objfile = pst -> objfile;
d2067 1
a2067 1
    ((struct symloc *)pst->read_symtab_private)->numsyms =
d2069 2
a2070 2
	- ((struct symloc *)pst->read_symtab_private)->first_symnum;
  ((struct symloc *)pst->read_symtab_private)->lineno_off =
d2083 1
a2083 1
		       number_dependencies * sizeof (struct partial_symtab *));
d2085 1
a2085 1
	     number_dependencies * sizeof (struct partial_symtab *));
d2093 1
a2093 1
	allocate_psymtab (include_list[i], objfile);
d2097 4
a2100 4
	  (char *) obstack_alloc (&objfile->psymbol_obstack,
				  sizeof (struct symloc));
      ((struct symloc *)subpst->read_symtab_private)->first_symnum = 0;
      ((struct symloc *)subpst->read_symtab_private)->numsyms = 0;
d2105 1
a2105 1
	 shared by the entire set of include files.  FIXME-someday.  */
d2114 2
a2115 2
	  subpst->statics_offset =
	    subpst->n_static_syms = 0;
d2135 1
a2135 1
	 it is on the obstack, but we can forget to chain it on the list.  */
d2137 1
a2137 1
	 any symbols in them.  There can be a lot of them.  */
d2142 1
a2142 1
      pst = (struct partial_symtab *)NULL;
d2169 1
a2169 1
	 '\0'-terminated.  */
d2183 1
a2183 1
	*name = ((struct external_syment *)*raw)->e.e_name;
d2187 1
a2187 1
      *name = ((struct coff_symfile_info *)objfile->sym_private)->debugsec
d2192 1
a2192 1
      *name = ((struct coff_symfile_info *)objfile->sym_private)->strtbl
d2208 1
a2208 2
scan_xcoff_symtab (section_offsets, objfile)
     struct section_offsets *section_offsets;
d2211 1
a2211 1
  CORE_ADDR toc_offset = 0;		/* toc offset value in data section. */
d2234 1
a2234 1
  union internal_auxent main_aux;
d2237 1
a2237 1
  char *last_csect_name = NULL;		/* last seen csect's name and value */
d2240 1
a2240 1
  int  misc_func_recorded = 0;		/* true if any misc. function */
d2260 2
a2261 2
  sraw_symbol = ((struct coff_symfile_info *)objfile->sym_private)->symtbl;
  nsyms = ((struct coff_symfile_info *)objfile->sym_private)->symtbl_num_syms;
d2265 1
a2265 1
      int sclass = ((struct external_syment *)sraw_symbol)->e_sclass[0] & 0xff;
d2267 3
a2269 3
	 would be to break out partial-stab.h into its various parts--shuffle
	 off the DBXREAD_ONLY stuff to dbxread.c, and make separate
	 pstab-norm.h (for most types), pstab-sol.h (for N_SOL), etc.  */
d2283 1
a2283 1
	    swap_sym (&symbol, &main_aux, &namestring, &sraw_symbol,
d2289 1
a2289 1
		   sraw_symbol - coff_data(abfd)->local_symesz,
d2297 1
a2297 1
	      csect_aux = main_aux;
d2339 1
a2339 1
			      (objfile, section_offsets,
d2356 1
a2356 1
			  symbol.n_value + csect_aux.x_csect.x_scnlen.l;
d2405 1
a2405 1
			main_aux.x_sym.x_fcnary.x_fcn.x_lnnoptr;
d2480 1
a2480 1
	    swap_sym (&symbol, &main_aux, &namestring, &sraw_symbol,
d2514 1
a2514 1
		filestring = coff_getfilename (&main_aux, objfile);
d2519 1
a2519 1
	    pst = xcoff_start_psymtab (objfile, section_offsets,
d2531 1
a2531 1
	      {"Storage class %d not recognized during scan", 0, 0};
d2582 1
a2582 1
	      ((struct external_syment *)sraw_symbol)->e_numaux[0] + 1;
d2604 1
a2604 1
	  swap_sym (&symbol, &main_aux, &namestring, &sraw_symbol,
d2612 1
a2612 1
#define START_PSYMTAB(ofile,secoff,fname,low,symoff,global_syms,static_syms) 0
d2616 1
a2616 1
#define SET_NAMESTRING() /* */
d2658 1
a2658 1
xcoff_initial_scan (objfile, section_offsets, mainline)
d2660 1
a2660 2
     struct section_offsets *section_offsets;
     int mainline;	/* FIXME comments above */
d2665 3
a2667 3
  int num_symbols;			/* # of symbols */
  file_ptr symtab_offset;		/* symbol table and */
  file_ptr stringtab_offset;		/* string table file offsets */
d2672 1
a2672 1
  info = (struct coff_symfile_info *) objfile -> sym_private;
d2679 1
a2679 1
    num_symbols * coff_data(abfd)->local_symesz;
d2713 1
a2713 1
	((struct coff_symfile_info *)objfile->sym_private)->debugsec =
d2725 1
a2725 1
  ((struct coff_symfile_info *)objfile->sym_private)->symtbl =
d2727 1
a2727 1
  ((struct coff_symfile_info *)objfile->sym_private)->symtbl_num_syms =
d2730 1
a2730 1
  val = bfd_read (((struct coff_symfile_info *)objfile->sym_private)->symtbl,
d2746 1
a2746 1
  back_to = make_cleanup ((make_cleanup_func) really_free_pendings, 0);
d2754 1
a2754 1
  scan_xcoff_symtab (section_offsets, objfile);
d2764 2
a2765 2
static struct section_offsets *
xcoff_symfile_offsets (objfile, addr)
d2767 1
a2767 1
     CORE_ADDR addr;
d2769 1
a2769 1
  struct section_offsets *section_offsets;
d2773 20
a2792 14
  section_offsets = (struct section_offsets *)
    obstack_alloc
      (&objfile -> psymbol_obstack,
       sizeof (struct section_offsets)
       + sizeof (section_offsets->offsets) * objfile->num_sections);

  /* syms_from_objfile kindly subtracts from addr the bfd_section_vma
     of the .text section.  This strikes me as wrong--whether the
     offset to be applied to symbol reading is relative to the start
     address of the section depends on the symbol format.  In any
     event, this whole "addr" concept is pretty broken (it doesn't
     handle any section but .text sensibly), so just ignore the addr
     parameter and use 0.  rs6000-nat.c will set the correct section
     offsets via objfile_relocate.  */
d2794 12
a2805 3
    ANOFFSET (section_offsets, i) = 0;

  return section_offsets;
d2823 1
a2823 1
  (enum bfd_flavour)-1,
d2825 6
a2830 6
  xcoff_new_init,	/* sym_new_init: init anything gbl to entire symtab */
  xcoff_symfile_init,	/* sym_init: read initial info, setup for sym_read() */
  xcoff_initial_scan,	/* sym_read: read a symbol file into symtab */
  xcoff_symfile_finish, /* sym_finish: finished with file, cleanup */
  xcoff_symfile_offsets, /* sym_offsets: xlate offsets ext->int form */
  NULL			/* next: pointer to next struct sym_fns */
d2836 1
a2836 1
  add_symtab_fns(&xcoff_sym_fns);
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-07-07 pre reformat
@
text
@a355 1
/* *INDENT-OFF* */
a406 1
/* *INDENT-ON* */
@


1.1.1.3
log
@import gdb-1999-07-07 post reformat
@
text
@d3 1
a3 1
   Free Software Foundation, Inc.
d7 1
a7 1
   This file is part of GDB.
d9 13
a21 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d57 1
a57 1
#define N_UNDF	0		/* Undefined symbol */
d60 6
a65 6
#define N_TEXT 	4		/* Text sym -- defined at offset in text seg */
#define N_DATA 	6		/* Data sym -- defined at offset in data seg */
#define N_BSS 	8		/* BSS  sym -- defined at offset in zero'd seg */
#define	N_COMM	0x12		/* Common symbol (visible after shared lib dynlink) */
#define N_FN	0x1f		/* File name of .o file */
#define	N_FN_SEQ 0x0C		/* N_FN from Sequent compilers (sigh) */
d69 1
a69 1
#define N_EXT 	1		/* External symbol (as opposed to local-to-this-file) */
d95 1
a95 2
struct symloc
  {
d97 1
a97 1
    /* First symbol number for this file.  */
d99 1
a99 1
    int first_symnum;
d101 5
a105 5
    /* Number of symbols in the section of the symbol table devoted to
       this file's symbols (actually, the section bracketed may contain
       more than just this file's symbols).  If numsyms is 0, the only
       reason for this thing's existence is the dependency list.  Nothing
       else will happen when it is read in.  */
d107 1
a107 1
    int numsyms;
d109 3
a111 3
    /* Position of the start of the line number information for this psymtab.  */
    unsigned int lineno_off;
  };
d116 1
a117 1

d120 9
a128 10
struct coff_symbol
  {
    char *c_name;
    int c_symnum;		/* symbol number of this entry */
    int c_naux;			/* 0 if syment only, 1 if syment + auxent */
    long c_value;
    unsigned char c_sclass;
    int c_secnum;
    unsigned int c_type;
  };
d160 1
a160 1
static unsigned local_symesz;
d162 3
a164 4
struct coff_symfile_info
  {
    file_ptr min_lineno_offset;	/* Where in file lowest line#s are */
    file_ptr max_lineno_offset;	/* 1+last byte of line#s in file */
d166 2
a167 2
    /* Pointer to the string table.  */
    char *strtbl;
d169 2
a170 2
    /* Pointer to debug section.  */
    char *debugsec;
d172 2
a173 2
    /* Pointer to the a.out symbol table.  */
    char *symtbl;
d175 2
a176 2
    /* Number of symbols in symtbl.  */
    int symtbl_num_syms;
d178 3
a180 3
    /* Offset in data section to TOC anchor.  */
    CORE_ADDR toc_offset;
  };
d183 1
a183 1
{"Unexpected storage class: %d", 0, 0};
d186 1
a186 1
{"line numbers off, `.bf' symbol not found", 0, 0};
d188 2
a189 2
static struct complaint ef_complaint =
{"Mismatched .ef symbol ignored starting at symnum %d", 0, 0};
d191 2
a192 2
static struct complaint eb_complaint =
{"Mismatched .eb symbol ignored starting at symnum %d", 0, 0};
d201 1
a201 1
  xcoff_next_symbol_text PARAMS ((struct objfile *));
d223 1
a223 1
  xcoff_symfile_offsets PARAMS ((struct objfile *, CORE_ADDR));
d229 1
a229 1
  coff_getfilename PARAMS ((union internal_auxent *, struct objfile *));
d241 1
a241 1
  process_xcoff_symbol PARAMS ((struct coff_symbol *, struct objfile *));
d255 1
a255 1
  arrange_linetable PARAMS ((struct linetable *));
d262 1
a263 1

d267 1
a267 1
static asection *secnum_to_bfd_section PARAMS ((int, struct objfile *));
d269 5
a273 6
struct find_targ_sec_arg
  {
    int targ_index;
    int *resultp;
    asection **bfd_sect;
  };
d277 1
a277 2
static void
find_targ_sec (abfd, sect, obj)
d282 1
a282 1
  struct find_targ_sec_arg *args = (struct find_targ_sec_arg *) obj;
d334 2
a335 2
     char *stabname;
     struct pending_stabs **stabvector;
d337 14
a350 16
  if (*stabvector == NULL)
    {
      *stabvector = (struct pending_stabs *)
	xmalloc (sizeof (struct pending_stabs) +
		 INITIAL_STABVECTOR_LENGTH * sizeof (char *));
      (*stabvector)->count = 0;
      (*stabvector)->length = INITIAL_STABVECTOR_LENGTH;
    }
  else if ((*stabvector)->count >= (*stabvector)->length)
    {
      (*stabvector)->length += INITIAL_STABVECTOR_LENGTH;
      *stabvector = (struct pending_stabs *)
	xrealloc ((char *) *stabvector, sizeof (struct pending_stabs) +
		    (*stabvector)->length * sizeof (char *));
    }
  (*stabvector)->stab[(*stabvector)->count++] = stabname;
d354 3
a356 1
/* *INDENT-OFF* */
d361 47
a407 47
   1) xlc (IBM's native c compiler) postpones static function code
   emission to the end of a compilation unit. This way it can
   determine if those functions (statics) are needed or not, and
   can do some garbage collection (I think). This makes line
   numbers and corresponding addresses unordered, and we end up
   with a line table like:


   lineno       addr
   foo()          10    0x100
   20   0x200
   30   0x300

   foo3()         70    0x400
   80   0x500
   90   0x600

   static foo2()
   40   0x700
   50   0x800
   60   0x900           

   and that breaks gdb's binary search on line numbers, if the
   above table is not sorted on line numbers. And that sort
   should be on function based, since gcc can emit line numbers
   like:

   10   0x100   - for the init/test part of a for stmt.
   20   0x200
   30   0x300
   10   0x400   - for the increment part of a for stmt.

   arrange_linetable() will do this sorting.            

   2)   aix symbol table might look like:

   c_file               // beginning of a new file
   .bi          // beginning of include file
   .ei          // end of include file
   .bi
   .ei

   basically, .bi/.ei pairs do not necessarily encapsulate
   their scope. They need to be recorded, and processed later
   on when we come the end of the compilation unit.
   Include table (inclTable) and process_linenos() handle
   that.  */
a409 2


d430 1
a430 1
     struct linetable *oldLineTb;	/* old linetable */
d432 7
a438 6
  int ii, jj, newline,		/* new line count */
    function_count;		/* # of functions */

  struct linetable_entry *fentry;	/* function entry vector */
  int fentry_size;		/* # of function entries */
  struct linetable *newLineTb;	/* new line table */
d443 1
a443 1
  fentry = (struct linetable_entry *)
d446 1
a446 2
  for (function_count = 0, ii = 0; ii < oldLineTb->nitems; ++ii)
    {
d448 1
a448 2
      if (oldLineTb->item[ii].line == 0)
	{			/* function entry found. */
d450 15
a464 17
	  if (function_count >= fentry_size)
	    {			/* make sure you have room. */
	      fentry_size *= 2;
	      fentry = (struct linetable_entry *)
		xrealloc (fentry, fentry_size * sizeof (struct linetable_entry));
	    }
	  fentry[function_count].line = ii;
	  fentry[function_count].pc = oldLineTb->item[ii].pc;
	  ++function_count;
	}
    }

  if (function_count == 0)
    {
      free (fentry);
      return oldLineTb;
    }
d466 1
a466 1
    qsort (fentry, function_count, sizeof (struct linetable_entry), compare_lte);
d471 2
a472 2
    (sizeof (struct linetable) +
    (oldLineTb->nitems - function_count) * sizeof (struct linetable_entry));
d479 2
a480 2
    for (newline = 0;
    newline < oldLineTb->nitems && oldLineTb->item[newline].line; ++newline)
d485 6
a490 7
  for (ii = 0; ii < function_count; ++ii)
    {
      for (jj = fentry[ii].line + 1;
	   jj < oldLineTb->nitems && oldLineTb->item[jj].line != 0;
	   ++jj, ++newline)
	newLineTb->item[newline] = oldLineTb->item[jj];
    }
d493 2
a494 2
  return newLineTb;
}
d502 2
a503 3
typedef struct _inclTable
{
  char *name;			/* include filename */
d507 2
a508 2
  int begin, end;

d510 2
a511 3
  unsigned funStartLine;	/* start line # of its function */
}
InclTable;
d514 4
a517 4
static InclTable *inclTable;	/* global include table */
static int inclIndx;		/* last entry to table */
static int inclLength;		/* table length */
static int inclDepth;		/* nested include depth */
d523 1
a523 1
     struct coff_symbol *cs;
d528 1
a528 1
         of course, but in corresponding .s files.).  */
d531 3
a533 4
         GCC 2.3.3-930426 does not exhibit this on a test case which
         a user said produced the message for him.  */
      static struct complaint msg =
      {"Nested C_BINCL symbols", 0, 0};
d540 2
a541 2
  inclTable[inclIndx].name = cs->c_name;
  inclTable[inclIndx].begin = cs->c_value;
d546 1
a546 1
     struct coff_symbol *cs;
d548 1
a548 1
  InclTable *pTbl;
d552 1
a552 2
      static struct complaint msg =
      {"Mismatched C_BINCL/C_EINCL pair", 0, 0};
d558 1
a558 1
  pTbl = &inclTable[inclIndx];
d570 1
a570 1
      inclTable = (InclTable *)
d580 1
a580 1
      inclTable = (InclTable *)
d582 2
a583 2
      memset (inclTable + inclLength - INITIAL_INCLUDE_TABLE_LENGTH,
	      '\0', sizeof (InclTable) * INITIAL_INCLUDE_TABLE_LENGTH);
d600 2
a601 2
  ((struct coff_symfile_info *) this_symtab_psymtab->objfile->sym_private)
  ->max_lineno_offset;
d616 1
a616 1
    ((struct symloc *) this_symtab_psymtab->read_symtab_private)->lineno_off;
d625 2
a626 2
    enter_line_range (&main_subfile, offset, 0, start, end,
		      &main_source_baseline);
d632 1
a632 1
      for (ii = 0; ii < inclIndx; ++ii)
d653 1
a653 1
	  enter_line_range (tmpSubfile, inclTable[ii].begin,
d661 1
a661 1
         enter remaining lines of the main file, if any left.  */
d664 1
a664 1
	  enter_line_range (&main_subfile, offset, 0, start, end,
d677 1
a677 1
         put static function to the end. */
d692 1
a692 1
      current_subfile->line_vector_length =
d698 1
a698 1
  for (ii = 0; ii < inclIndx; ++ii)
d700 1
a700 1
      if ((inclTable[ii].subfile)->line_vector)		/* Useless if!!! FIXMEmgo */
d716 5
a720 5
	     ......
	     #include "foo.h"
	     ......
	     #include "foo.h"
	     ......
d728 1
a728 1
	  start_subfile (inclTable[ii].name, (char *) 0);
d737 1
a737 1
	    start_subfile (fakename, (char *) 0);
d747 2
a748 2
		(lv, (sizeof (struct linetable)
		      + lv->nitems * sizeof (struct linetable_entry)));
d757 1
a757 1
	  current_subfile->line_vector_length =
d759 1
a759 1
	  start_subfile (pop_subfile (), (char *) 0);
d763 1
a763 1
return_after_cleanup:
d782 2
a783 2
   enter_line_range (subfile, beginoffset, endoffset, startaddr, 0, firstLine)  or
   enter_line_range (subfile, beginoffset, 0, startaddr, endaddr, firstLine)
d792 3
a794 3
     unsigned beginoffset, endoffset;	/* offsets to line table */
     CORE_ADDR startaddr, endaddr;
     unsigned *firstLine;
d807 2
a808 2
    ((struct coff_symfile_info *) this_symtab_psymtab->objfile->sym_private)
    ->max_lineno_offset;
d815 1
a815 1
	  {"Bad line table offset in C_EINCL directive", 0, 0};
d887 1
a887 1

d911 1
a911 1
  {"Unexpected symbol continuation", 0, 0};
d922 1
a922 1
         code does something reasonable.  */
d928 2
a929 2
	((struct coff_symfile_info *) objfile->sym_private)->debugsec
	+ symbol.n_offset;
d939 1
a939 1
         code does something reasonable.  */
d954 1
a954 1
  char *strtbl = ((struct coff_symfile_info *) objfile->sym_private)->strtbl;
d956 1
a956 1
  ((struct coff_symfile_info *) objfile->sym_private)->debugsec;
d978 1
a978 1
  char *last_csect_name;	/* last seen csect's name and value */
d993 1
a993 1
  start_symtab (filestring, (char *) NULL, file_start_addr);
d995 1
a995 1
  symnum = ((struct symloc *) pst->read_symtab_private)->first_symnum;
d997 1
a997 1
    symnum + ((struct symloc *) pst->read_symtab_private)->numsyms;
d1002 1
a1002 1
    + symnum * local_symesz;
d1011 4
a1014 4
         whole symbol table, only string table will be kept in memory,
         symbol table and debug section of xcoff will be freed. Thus
         we can mark symbols with names in string table as
         `alloced'. */
d1029 1
a1029 1
	    cs->c_name = ((struct external_syment *) raw_symbol)->e.e_name;
d1050 1
a1050 1
	    cs->c_name = strtbl + (int) symbol->n_offset;
d1056 1
a1056 1
	cs->c_type = (unsigned) symbol->n_type;
d1087 1
a1087 1
	  start_symtab ("_globals_", (char *) NULL, (CORE_ADDR) 0);
d1094 1
a1094 1
      if (ISFCN (cs->c_type) && cs->c_sclass != C_TPDEF)
d1133 9
a1141 9
		         symbol table for each program csect.  Normally gdb
		         prefers one symtab for each source file.  In case
		         of AIX, one source file might include more than one
		         [PR] csect, and they don't have to be adjacent in
		         terms of the space they occupy in memory. Thus, one
		         single source file might get fragmented in the
		         memory and gdb's file start and end address
		         approach does not work!  GCC (and I think xlc) seem
		         to put all the code in the unnamed program csect.  */
d1152 1
a1152 1
			  start_symtab (filestring, NULL, (CORE_ADDR) 0);
d1157 1
a1157 1
		         basically `__start'. */
d1281 1
a1281 1
	  start_symtab (filestring, (char *) NULL, (CORE_ADDR) 0);
d1306 1
a1306 1
	      new->name = define_symbol
d1319 1
a1319 1
	         not useful for gdb.  */
d1321 1
a1321 1
	         contains number of lines to '}' */
d1376 1
a1376 1
	    {"Unrecognized storage class %d.", 0, 0};
d1469 2
a1470 2


d1482 2
a1483 2
     register struct coff_symbol *cs;
     struct objfile *objfile;
d1496 1
a1496 1
         and does not get relocated.  */
d1520 2
a1521 2
         will be patched with the type from its stab entry later on in
         patch_block_stabs (), unless the file was compiled without -g.  */
d1542 2
a1543 2
	  /* The values of functions and global symbols are now resolved
	     via the global_sym_chain in stabsread.c.  */
d1594 1
a1594 1
	  if (*name == ':' || (pp = (char *) strchr (name, ':')) == NULL)
d1628 1
a1628 1
	    ((struct coff_symfile_info *) objfile->sym_private)->strtbl
d1645 5
a1649 5
  ((struct coff_symfile_info *) this_symtab_psymtab->objfile->sym_private)
  ->symtbl_num_syms;
  char *stbl =
  ((struct coff_symfile_info *) this_symtab_psymtab->objfile->sym_private)
  ->symtbl;
d1653 1
a1653 1
      {"Invalid symbol offset", 0, 0};
d1660 1
a1660 1
			stbl + (symno * local_symesz),
d1663 1
a1663 1

d1673 1
a1673 1
  return symbol->n_value;
d1685 5
a1689 5
  ((struct coff_symfile_info *) this_symtab_psymtab->objfile->sym_private)
  ->symtbl_num_syms;
  char *stbl =
  ((struct coff_symfile_info *) this_symtab_psymtab->objfile->sym_private)
  ->symtbl;
d1748 1
a1748 1
     PTR vpinfo;
d1760 1
a1760 1
  info = (struct coff_symfile_info *) vpinfo;
d1779 1
a1779 1

d1803 1
a1803 1
	    wrap_here ("");	/* Flush output */
d1809 1
a1809 1
  if (((struct symloc *) pst->read_symtab_private)->numsyms != 0)
d1847 1
a1847 1
  if (((struct symloc *) pst->read_symtab_private)->numsyms != 0
d1851 1
a1851 1
         to avoid disconcerting pauses.  */
d1883 1
a1883 1

d1893 2
a1894 2
  objfile->sym_private = xmmalloc (objfile->md,
				   sizeof (struct coff_symfile_info));
d1913 1
a1913 1
  if (objfile->sym_private != NULL)
d1915 1
a1915 1
      mfree (objfile->md, objfile->sym_private);
d1939 1
a1939 1
  ((struct coff_symfile_info *) objfile->sym_private)->strtbl = NULL;
d1945 1
a1945 1
  val = bfd_read ((char *) lengthbuf, 1, sizeof lengthbuf, abfd);
d1958 1
a1958 1
  ((struct coff_symfile_info *) objfile->sym_private)->strtbl = strtbl;
d2005 5
a2009 5
  start_psymtab_common (objfile, section_offsets,
			filename,
  /* We fill in textlow later.  */
			0,
			global_syms, static_syms);
d2012 2
a2013 2
    obstack_alloc (&objfile->psymbol_obstack, sizeof (struct symloc));
  ((struct symloc *) result->read_symtab_private)->first_symnum = first_symnum;
d2046 1
a2046 1
  struct objfile *objfile = pst->objfile;
d2049 1
a2049 1
    ((struct symloc *) pst->read_symtab_private)->numsyms =
d2051 2
a2052 2
      - ((struct symloc *) pst->read_symtab_private)->first_symnum;
  ((struct symloc *) pst->read_symtab_private)->lineno_off =
d2065 1
a2065 1
		    number_dependencies * sizeof (struct partial_symtab *));
d2067 1
a2067 1
	      number_dependencies * sizeof (struct partial_symtab *));
d2075 1
a2075 1
      allocate_psymtab (include_list[i], objfile);
d2079 4
a2082 4
	(char *) obstack_alloc (&objfile->psymbol_obstack,
				sizeof (struct symloc));
      ((struct symloc *) subpst->read_symtab_private)->first_symnum = 0;
      ((struct symloc *) subpst->read_symtab_private)->numsyms = 0;
d2087 1
a2087 1
         shared by the entire set of include files.  FIXME-someday.  */
d2096 2
a2097 2
	subpst->statics_offset =
	subpst->n_static_syms = 0;
d2117 1
a2117 1
         it is on the obstack, but we can forget to chain it on the list.  */
d2119 1
a2119 1
         any symbols in them.  There can be a lot of them.  */
d2124 1
a2124 1
      pst = (struct partial_symtab *) NULL;
d2151 1
a2151 1
         '\0'-terminated.  */
d2165 1
a2165 1
	*name = ((struct external_syment *) *raw)->e.e_name;
d2169 1
a2169 1
      *name = ((struct coff_symfile_info *) objfile->sym_private)->debugsec
d2174 1
a2174 1
      *name = ((struct coff_symfile_info *) objfile->sym_private)->strtbl
d2194 1
a2194 1
  CORE_ADDR toc_offset = 0;	/* toc offset value in data section. */
d2220 1
a2220 1
  char *last_csect_name = NULL;	/* last seen csect's name and value */
d2223 1
a2223 1
  int misc_func_recorded = 0;	/* true if any misc. function */
d2243 2
a2244 2
  sraw_symbol = ((struct coff_symfile_info *) objfile->sym_private)->symtbl;
  nsyms = ((struct coff_symfile_info *) objfile->sym_private)->symtbl_num_syms;
d2248 1
a2248 1
      int sclass = ((struct external_syment *) sraw_symbol)->e_sclass[0] & 0xff;
d2250 3
a2252 3
         would be to break out partial-stab.h into its various parts--shuffle
         off the DBXREAD_ONLY stuff to dbxread.c, and make separate
         pstab-norm.h (for most types), pstab-sol.h (for N_SOL), etc.  */
d2272 1
a2272 1
		   sraw_symbol - coff_data (abfd)->local_symesz,
d2339 1
a2339 1
			symbol.n_value + csect_aux.x_csect.x_scnlen.l;
d2514 1
a2514 1
	    {"Storage class %d not recognized during scan", 0, 0};
d2565 1
a2565 1
	    ((struct external_syment *) sraw_symbol)->e_numaux[0] + 1;
d2599 1
a2599 1
#define SET_NAMESTRING()	/* */
d2644 1
a2644 1
     int mainline;		/* FIXME comments above */
d2649 3
a2651 3
  int num_symbols;		/* # of symbols */
  file_ptr symtab_offset;	/* symbol table and */
  file_ptr stringtab_offset;	/* string table file offsets */
d2656 1
a2656 1
  info = (struct coff_symfile_info *) objfile->sym_private;
d2663 1
a2663 1
    num_symbols * coff_data (abfd)->local_symesz;
d2697 1
a2697 1
	((struct coff_symfile_info *) objfile->sym_private)->debugsec =
d2709 1
a2709 1
  ((struct coff_symfile_info *) objfile->sym_private)->symtbl =
d2711 1
a2711 1
  ((struct coff_symfile_info *) objfile->sym_private)->symtbl_num_syms =
d2714 1
a2714 1
  val = bfd_read (((struct coff_symfile_info *) objfile->sym_private)->symtbl,
d2759 3
a2761 3
    (&objfile->psymbol_obstack,
     sizeof (struct section_offsets)
     + sizeof (section_offsets->offsets) * objfile->num_sections);
d2792 1
a2792 1
  (enum bfd_flavour) -1,
d2794 6
a2799 6
  xcoff_new_init,		/* sym_new_init: init anything gbl to entire symtab */
  xcoff_symfile_init,		/* sym_init: read initial info, setup for sym_read() */
  xcoff_initial_scan,		/* sym_read: read a symbol file into symtab */
  xcoff_symfile_finish,		/* sym_finish: finished with file, cleanup */
  xcoff_symfile_offsets,	/* sym_offsets: xlate offsets ext->int form */
  NULL				/* next: pointer to next struct sym_fns */
d2805 1
a2805 1
  add_symtab_fns (&xcoff_sym_fns);
@


1.1.1.4
log
@import gdb-1999-08-02 snapshot
@
text
@d1830 1
a1830 1
      old_chain = make_cleanup (really_free_pendings, 0);
d2746 1
a2746 1
  back_to = make_cleanup (really_free_pendings, 0);
@


1.1.1.5
log
@import gdb-1999-08-09 snapshot
@
text
@d199 1
a199 1
xcoff_initial_scan PARAMS ((struct objfile *, int));
d2233 1
a2233 1
  union internal_auxent main_aux[5];
d2282 1
a2282 1
	    swap_sym (&symbol, &main_aux[0], &namestring, &sraw_symbol,
d2296 1
a2296 1
	      csect_aux = main_aux[0];
d2404 1
a2404 1
			main_aux[0].x_sym.x_fcnary.x_fcn.x_lnnoptr;
d2479 1
a2479 1
	    swap_sym (&symbol, &main_aux[0], &namestring, &sraw_symbol,
d2513 1
a2513 1
		filestring = coff_getfilename (&main_aux[0], objfile);
d2603 1
a2603 1
	  swap_sym (&symbol, &main_aux[0], &namestring, &sraw_symbol,
d2657 1
a2657 1
xcoff_initial_scan (objfile, mainline)
d2659 1
d2754 1
a2754 1
  scan_xcoff_symtab (objfile->section_offsets, objfile);
d2774 4
a2777 1
    obstack_alloc (&objfile->psymbol_obstack, SIZEOF_SECTION_OFFSETS);
@


1.1.1.6
log
@import gdb-1999-09-08 snapshot
@
text
@d202 1
a202 1
scan_xcoff_symtab PARAMS ((struct objfile *));
d226 1
a226 1
static void
d2000 1
a2000 1
  PARAMS ((struct objfile *, char *, int,
d2011 2
a2012 2
xcoff_start_psymtab (objfile, filename, first_symnum, global_syms,
		     static_syms)
d2014 1
d2021 1
a2021 1
  start_psymtab_common (objfile, objfile->section_offsets,
d2023 1
a2023 1
			/* We fill in textlow later.  */
d2206 2
a2207 1
scan_xcoff_symtab (objfile)
d2338 1
a2338 1
			      (objfile,
d2518 1
a2518 1
	    pst = xcoff_start_psymtab (objfile,
d2611 1
a2611 1
#define START_PSYMTAB(ofile,fname,low,symoff,global_syms,static_syms) 0
d2753 1
a2753 1
  scan_xcoff_symtab (objfile);
d2763 1
a2763 1
static void
d2768 1
d2772 1
a2772 1
  objfile->section_offsets = (struct section_offsets *)
d2784 3
a2786 1
    ANOFFSET (objfile->section_offsets, i) = 0;
@


1.1.1.7
log
@import gdb-1999-10-04 snapshot
@
text
@d227 1
a227 1
  xcoff_symfile_offsets PARAMS ((struct objfile *, struct section_addr_info *addrs));
d2764 1
a2764 1
     struct section_addr_info *addrs;
@


1.1.1.8
log
@import gdb-1999-10-11 snapshot
@
text
@d2762 1
a2762 1
xcoff_symfile_offsets (objfile, addrs)
@


1.1.1.9
log
@import gdb-1999-12-06 snapshot
@
text
@d756 1
a756 1
	  current_subfile->name = xstrdup (inclTable[ii].name);
@


