head	1.64;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.58
	gdb_7_6-2013-04-26-release:1.58
	gdb_7_6-branch:1.58.0.2
	gdb_7_6-2013-03-12-branchpoint:1.58
	gdb_7_5_1-2012-11-29-release:1.54
	gdb_7_5-2012-08-17-release:1.54
	gdb_7_5-branch:1.54.0.2
	gdb_7_5-2012-07-18-branchpoint:1.54
	gdb_7_4_1-2012-04-26-release:1.52.2.1
	gdb_7_4-2012-01-24-release:1.52.2.1
	gdb_7_4-branch:1.52.0.2
	gdb_7_4-2011-12-13-branchpoint:1.52
	gdb_7_3_1-2011-09-04-release:1.51
	gdb_7_3-2011-07-26-release:1.51
	gdb_7_3-branch:1.51.0.2
	gdb_7_3-2011-04-01-branchpoint:1.51
	gdb_7_2-2010-09-02-release:1.46
	gdb_7_2-branch:1.46.0.2
	gdb_7_2-2010-07-07-branchpoint:1.46
	gdb_7_1-2010-03-18-release:1.45
	gdb_7_1-branch:1.45.0.2
	gdb_7_1-2010-02-18-branchpoint:1.45
	gdb_7_0_1-2009-12-22-release:1.41
	gdb_7_0-2009-10-06-release:1.41
	gdb_7_0-branch:1.41.0.4
	gdb_7_0-2009-09-16-branchpoint:1.41
	arc-sim-20090309:1.39
	msnyder-checkpoint-072509-branch:1.41.0.2
	msnyder-checkpoint-072509-branchpoint:1.41
	arc-insight_6_8-branch:1.39.0.6
	arc-insight_6_8-branchpoint:1.39
	insight_6_8-branch:1.39.0.4
	insight_6_8-branchpoint:1.39
	reverse-20081226-branch:1.40.0.10
	reverse-20081226-branchpoint:1.40
	multiprocess-20081120-branch:1.40.0.8
	multiprocess-20081120-branchpoint:1.40
	reverse-20080930-branch:1.40.0.6
	reverse-20080930-branchpoint:1.40
	reverse-20080717-branch:1.40.0.4
	reverse-20080717-branchpoint:1.40
	msnyder-reverse-20080609-branch:1.40.0.2
	msnyder-reverse-20080609-branchpoint:1.40
	drow-reverse-20070409-branch:1.32.0.2
	drow-reverse-20070409-branchpoint:1.32
	gdb_6_8-2008-03-27-release:1.39
	gdb_6_8-branch:1.39.0.2
	gdb_6_8-2008-02-26-branchpoint:1.39
	gdb_6_7_1-2007-10-29-release:1.37
	gdb_6_7-2007-10-10-release:1.37
	gdb_6_7-branch:1.37.0.2
	gdb_6_7-2007-09-07-branchpoint:1.37
	insight_6_6-20070208-release:1.31
	gdb_6_6-2006-12-18-release:1.31
	gdb_6_6-branch:1.31.0.2
	gdb_6_6-2006-11-15-branchpoint:1.31
	insight_6_5-20061003-release:1.30
	gdb-csl-symbian-6_4_50_20060226-12:1.29
	gdb-csl-sourcerygxx-3_4_4-25:1.27
	nickrob-async-20060828-mergepoint:1.30
	gdb-csl-symbian-6_4_50_20060226-11:1.29
	gdb-csl-sourcerygxx-4_1-17:1.29
	gdb-csl-20060226-branch-local-2:1.29
	gdb-csl-sourcerygxx-4_1-14:1.29
	gdb-csl-sourcerygxx-4_1-13:1.29
	gdb-csl-sourcerygxx-4_1-12:1.29
	gdb-csl-sourcerygxx-3_4_4-21:1.29
	gdb_6_5-20060621-release:1.30
	gdb-csl-sourcerygxx-4_1-9:1.29
	gdb-csl-sourcerygxx-4_1-8:1.29
	gdb-csl-sourcerygxx-4_1-7:1.29
	gdb-csl-arm-2006q1-6:1.29
	gdb-csl-sourcerygxx-4_1-6:1.29
	gdb-csl-symbian-6_4_50_20060226-10:1.29
	gdb-csl-symbian-6_4_50_20060226-9:1.29
	gdb-csl-symbian-6_4_50_20060226-8:1.29
	gdb-csl-coldfire-4_1-11:1.29
	gdb-csl-sourcerygxx-3_4_4-19:1.29
	gdb-csl-coldfire-4_1-10:1.29
	gdb_6_5-branch:1.30.0.12
	gdb_6_5-2006-05-14-branchpoint:1.30
	gdb-csl-sourcerygxx-4_1-5:1.29
	nickrob-async-20060513-branch:1.30.0.10
	nickrob-async-20060513-branchpoint:1.30
	gdb-csl-sourcerygxx-4_1-4:1.29
	msnyder-reverse-20060502-branch:1.30.0.8
	msnyder-reverse-20060502-branchpoint:1.30
	gdb-csl-morpho-4_1-4:1.29
	gdb-csl-sourcerygxx-3_4_4-17:1.29
	readline_5_1-import-branch:1.30.0.6
	readline_5_1-import-branchpoint:1.30
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.29
	gdb-csl-symbian-20060226-branch:1.29.0.4
	gdb-csl-symbian-20060226-branchpoint:1.29
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.29
	msnyder-reverse-20060331-branch:1.30.0.4
	msnyder-reverse-20060331-branchpoint:1.30
	gdb-csl-available-20060303-branch:1.30.0.2
	gdb-csl-available-20060303-branchpoint:1.30
	gdb-csl-20060226-branch:1.29.0.2
	gdb-csl-20060226-branchpoint:1.29
	gdb_6_4-20051202-release:1.27
	msnyder-fork-checkpoint-branch:1.27.0.12
	msnyder-fork-checkpoint-branchpoint:1.27
	gdb-csl-gxxpro-6_3-branch:1.27.0.10
	gdb-csl-gxxpro-6_3-branchpoint:1.27
	gdb_6_4-branch:1.27.0.8
	gdb_6_4-2005-11-01-branchpoint:1.27
	gdb-csl-arm-20051020-branch:1.27.0.6
	gdb-csl-arm-20051020-branchpoint:1.27
	msnyder-tracepoint-checkpoint-branch:1.27.0.4
	msnyder-tracepoint-checkpoint-branchpoint:1.27
	gdb-csl-arm-20050325-2005-q1b:1.27
	gdb-csl-arm-20050325-2005-q1a:1.27
	csl-arm-20050325-branch:1.27.0.2
	csl-arm-20050325-branchpoint:1.27
	gdb-post-i18n-errorwarning-20050211:1.27
	gdb-pre-i18n-errorwarning-20050211:1.26
	gdb_6_3-20041109-release:1.24
	gdb_6_3-branch:1.24.0.2
	gdb_6_3-20041019-branchpoint:1.24
	drow_intercu-merge-20040921:1.24
	drow_intercu-merge-20040915:1.24
	jimb-gdb_6_2-e500-branch:1.23.0.6
	jimb-gdb_6_2-e500-branchpoint:1.23
	gdb_6_2-20040730-release:1.23
	gdb_6_2-branch:1.23.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.23
	gdb_6_1_1-20040616-release:1.22
	gdb_6_1-2004-04-05-release:1.22
	drow_intercu-merge-20040402:1.22
	drow_intercu-merge-20040327:1.22
	ezannoni_pie-20040323-branch:1.22.0.10
	ezannoni_pie-20040323-branchpoint:1.22
	cagney_tramp-20040321-mergepoint:1.22
	cagney_tramp-20040309-branch:1.22.0.8
	cagney_tramp-20040309-branchpoint:1.22
	gdb_6_1-branch:1.22.0.6
	gdb_6_1-2004-03-01-gmt-branchpoint:1.22
	drow_intercu-20040221-branch:1.22.0.4
	drow_intercu-20040221-branchpoint:1.22
	cagney_bfdfile-20040213-branch:1.22.0.2
	cagney_bfdfile-20040213-branchpoint:1.22
	drow-cplus-merge-20040208:1.22
	carlton_dictionary-20040126-merge:1.21
	cagney_bigcore-20040122-branch:1.21.0.6
	cagney_bigcore-20040122-branchpoint:1.21
	drow-cplus-merge-20040113:1.21
	drow-cplus-merge-20031224:1.21
	drow-cplus-merge-20031220:1.21
	carlton_dictionary-20031215-merge:1.21
	drow-cplus-merge-20031214:1.21
	carlton-dictionary-20031111-merge:1.21
	gdb_6_0-2003-10-04-release:1.19.4.1
	kettenis_sparc-20030918-branch:1.21.0.4
	kettenis_sparc-20030918-branchpoint:1.21
	carlton_dictionary-20030917-merge:1.21
	ezannoni_pie-20030916-branchpoint:1.21
	ezannoni_pie-20030916-branch:1.21.0.2
	cagney_x86i386-20030821-branch:1.20.0.2
	cagney_x86i386-20030821-branchpoint:1.20
	carlton_dictionary-20030805-merge:1.20
	carlton_dictionary-20030627-merge:1.19
	gdb_6_0-branch:1.19.0.4
	gdb_6_0-2003-06-23-branchpoint:1.19
	jimb-ppc64-linux-20030613-branch:1.19.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.19
	cagney_convert-20030606-branch:1.18.0.16
	cagney_convert-20030606-branchpoint:1.18
	cagney_writestrings-20030508-branch:1.18.0.14
	cagney_writestrings-20030508-branchpoint:1.18
	jimb-ppc64-linux-20030528-branch:1.18.0.12
	jimb-ppc64-linux-20030528-branchpoint:1.18
	carlton_dictionary-20030523-merge:1.18
	cagney_fileio-20030521-branch:1.18.0.10
	cagney_fileio-20030521-branchpoint:1.18
	kettenis_i386newframe-20030517-mergepoint:1.18
	jimb-ppc64-linux-20030509-branch:1.18.0.8
	jimb-ppc64-linux-20030509-branchpoint:1.18
	kettenis_i386newframe-20030504-mergepoint:1.18
	carlton_dictionary-20030430-merge:1.18
	kettenis_i386newframe-20030419-branch:1.18.0.6
	kettenis_i386newframe-20030419-branchpoint:1.18
	carlton_dictionary-20030416-merge:1.18
	cagney_frameaddr-20030409-mergepoint:1.18
	kettenis_i386newframe-20030406-branch:1.18.0.4
	kettenis_i386newframe-20030406-branchpoint:1.18
	cagney_frameaddr-20030403-branchpoint:1.18
	cagney_frameaddr-20030403-branch:1.18.0.2
	cagney_framebase-20030330-mergepoint:1.18
	cagney_framebase-20030326-branch:1.17.0.10
	cagney_framebase-20030326-branchpoint:1.17
	cagney_lazyid-20030317-branch:1.17.0.8
	cagney_lazyid-20030317-branchpoint:1.17
	kettenis-i386newframe-20030316-mergepoint:1.17
	offbyone-20030313-branch:1.17.0.6
	offbyone-20030313-branchpoint:1.17
	kettenis-i386newframe-20030308-branch:1.17.0.4
	kettenis-i386newframe-20030308-branchpoint:1.17
	carlton_dictionary-20030305-merge:1.17
	cagney_offbyone-20030303-branch:1.17.0.2
	cagney_offbyone-20030303-branchpoint:1.17
	carlton_dictionary-20030207-merge:1.16
	interps-20030203-mergepoint:1.16
	interps-20030202-branch:1.16.0.2
	interps-20030202-branchpoint:1.16
	cagney-unwind-20030108-branch:1.15.0.18
	cagney-unwind-20030108-branchpoint:1.15
	carlton_dictionary-20021223-merge:1.15
	gdb_5_3-2002-12-12-release:1.15
	carlton_dictionary-20021115-merge:1.15
	kseitz_interps-20021105-merge:1.15
	kseitz_interps-20021103-merge:1.15
	drow-cplus-merge-20021020:1.15
	drow-cplus-merge-20021025:1.15
	carlton_dictionary-20021025-merge:1.15
	carlton_dictionary-20021011-merge:1.15
	drow-cplus-branch:1.15.0.16
	drow-cplus-branchpoint:1.15
	kseitz_interps-20020930-merge:1.15
	carlton_dictionary-20020927-merge:1.15
	carlton_dictionary-branch:1.15.0.14
	carlton_dictionary-20020920-branchpoint:1.15
	gdb_5_3-branch:1.15.0.12
	gdb_5_3-2002-09-04-branchpoint:1.15
	kseitz_interps-20020829-merge:1.15
	cagney_sysregs-20020825-branch:1.15.0.10
	cagney_sysregs-20020825-branchpoint:1.15
	readline_4_3-import-branch:1.15.0.8
	readline_4_3-import-branchpoint:1.15
	gdb_5_2_1-2002-07-23-release:1.14
	kseitz_interps-20020528-branch:1.15.0.6
	kseitz_interps-20020528-branchpoint:1.15
	cagney_regbuf-20020515-branch:1.15.0.4
	cagney_regbuf-20020515-branchpoint:1.15
	jimb-macro-020506-branch:1.15.0.2
	jimb-macro-020506-branchpoint:1.15
	gdb_5_2-2002-04-29-release:1.14
	gdb_5_2-branch:1.14.0.2
	gdb_5_2-2002-03-03-branchpoint:1.14
	gdb_5_1_1-2002-01-24-release:1.10
	gdb_5_1_0_1-2002-01-03-release:1.10
	cygnus_cvs_20020108_pre:1.12
	gdb_5_1_0_1-2002-01-03-branchpoint:1.10
	gdb_5_1_0_1-2002-01-03-branch:1.10.0.8
	gdb_5_1-2001-11-21-release:1.10
	gdb_s390-2001-09-26-branch:1.10.0.6
	gdb_s390-2001-09-26-branchpoint:1.10
	gdb_5_1-2001-07-29-branch:1.10.0.4
	gdb_5_1-2001-07-29-branchpoint:1.10
	dberlin-typesystem-branch:1.10.0.2
	dberlin-typesystem-branchpoint:1.10
	gdb-post-ptid_t-2001-05-03:1.10
	gdb-pre-ptid_t-2001-05-03:1.10
	insight-precleanup-2001-01-01:1.9
	gdb-post-protoization-2000-07-29:1.6
	gdb-pre-protoization-2000-07-29:1.5
	gdb-premipsmulti-2000-06-06-branch:1.5.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.5
	gdb-post-params-removal-2000-06-04:1.5
	gdb-pre-params-removal-2000-06-04:1.5
	gdb-post-params-removal-2000-05-28:1.5
	gdb-pre-params-removal-2000-05-28:1.4
	gdb_5_0-2000-05-19-release:1.1.1.7
	gdb_4_18_2-2000-05-18-release:1.1.1.7
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.7
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.7
	gdb_5_0-2000-04-10-branch:1.1.1.7.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.7
	repo-unification-2000-02-06:1.1.1.7
	insight-2000-02-04:1.1.1.7
	gdb-2000-02-04:1.1.1.7
	gdb-2000-02-02:1.1.1.7
	gdb-2000-02-01:1.1.1.7
	gdb-2000-01-31:1.1.1.7
	gdb-2000-01-26:1.1.1.7
	gdb-2000-01-24:1.1.1.7
	gdb-2000-01-17:1.1.1.7
	gdb-2000-01-10:1.1.1.7
	gdb-2000-01-05:1.1.1.7
	gdb-1999-12-21:1.1.1.7
	gdb-1999-12-13:1.1.1.7
	gdb-1999-12-07:1.1.1.7
	gdb-1999-12-06:1.1.1.7
	gdb-1999-11-16:1.1.1.7
	gdb-1999-11-08:1.1.1.7
	gdb-1999-11-01:1.1.1.7
	gdb-1999-10-25:1.1.1.7
	gdb-1999-10-18:1.1.1.7
	gdb-1999-10-11:1.1.1.7
	gdb-1999-10-04:1.1.1.7
	gdb-1999-09-28:1.1.1.6
	gdb-1999-09-21:1.1.1.6
	gdb-1999-09-13:1.1.1.6
	gdb-1999-09-08:1.1.1.6
	gdb-1999-08-30:1.1.1.5
	gdb-1999-08-23:1.1.1.5
	gdb-1999-08-16:1.1.1.5
	gdb-1999-08-09:1.1.1.4
	gdb-1999-08-02:1.1.1.3
	gdb-1999-07-26:1.1.1.3
	gdb-1999-07-19:1.1.1.3
	gdb-1999-07-12:1.1.1.3
	gdb-post-reformat-19990707:1.1.1.3
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.3
	gdb-pre-reformat-19990707:1.1.1.2
	gdb-1999-07-07:1.1.1.2
	gdb-1999-07-05:1.1.1.2
	gdb-1999-06-28:1.1.1.2
	gdb-1999-06-21:1.1.1.2
	gdb-1999-06-14:1.1.1.2
	gdb-1999-06-07:1.1.1.2
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.64
date	2013.09.25.22.48.18;	author devans;	state Exp;
branches;
next	1.63;

1.63
date	2013.05.30.16.28.29;	author tromey;	state Exp;
branches;
next	1.62;

1.62
date	2013.05.06.19.38.04;	author tromey;	state Exp;
branches;
next	1.61;

1.61
date	2013.04.08.20.13.22;	author tromey;	state Exp;
branches;
next	1.60;

1.60
date	2013.04.08.20.08.21;	author tromey;	state Exp;
branches;
next	1.59;

1.59
date	2013.03.21.16.18.48;	author tromey;	state Exp;
branches;
next	1.58;

1.58
date	2013.01.09.17.21.35;	author tromey;	state Exp;
branches;
next	1.57;

1.57
date	2013.01.01.06.32.51;	author brobecke;	state Exp;
branches;
next	1.56;

1.56
date	2012.12.12.15.57.01;	author tromey;	state Exp;
branches;
next	1.55;

1.55
date	2012.11.21.00.29.55;	author qiyao;	state Exp;
branches;
next	1.54;

1.54
date	2012.04.27.20.47.56;	author sergiodj;	state Exp;
branches;
next	1.53;

1.53
date	2012.01.04.08.17.11;	author brobecke;	state Exp;
branches;
next	1.52;

1.52
date	2011.08.09.12.51.47;	author palves;	state Exp;
branches
	1.52.2.1;
next	1.51;

1.51
date	2011.03.07.16.17.29;	author tromey;	state Exp;
branches;
next	1.50;

1.50
date	2011.01.11.21.53.24;	author msnyder;	state Exp;
branches;
next	1.49;

1.49
date	2011.01.05.22.22.50;	author msnyder;	state Exp;
branches;
next	1.48;

1.48
date	2011.01.01.15.33.15;	author brobecke;	state Exp;
branches;
next	1.47;

1.47
date	2010.09.30.19.14.30;	author tromey;	state Exp;
branches;
next	1.46;

1.46
date	2010.03.10.18.20.06;	author tromey;	state Exp;
branches;
next	1.45;

1.45
date	2010.02.03.14.13.16;	author gingold;	state Exp;
branches;
next	1.44;

1.44
date	2010.01.01.07.31.41;	author brobecke;	state Exp;
branches;
next	1.43;

1.43
date	2009.12.07.09.47.40;	author gingold;	state Exp;
branches;
next	1.42;

1.42
date	2009.12.02.11.34.37;	author gingold;	state Exp;
branches;
next	1.41;

1.41
date	2009.01.03.05.57.53;	author brobecke;	state Exp;
branches;
next	1.40;

1.40
date	2008.03.26.14.53.28;	author uweigand;	state Exp;
branches;
next	1.39;

1.39
date	2008.01.01.22.53.13;	author drow;	state Exp;
branches;
next	1.38;

1.38
date	2007.09.21.18.01.23;	author brobecke;	state Exp;
branches;
next	1.37;

1.37
date	2007.08.23.18.08.38;	author brobecke;	state Exp;
branches;
next	1.36;

1.36
date	2007.06.18.15.46.38;	author drow;	state Exp;
branches;
next	1.35;

1.35
date	2007.06.12.16.55.32;	author uweigand;	state Exp;
branches;
next	1.34;

1.34
date	2007.06.05.22.46.30;	author uweigand;	state Exp;
branches;
next	1.33;

1.33
date	2007.04.10.11.58.15;	author drow;	state Exp;
branches;
next	1.32;

1.32
date	2007.01.09.17.58.58;	author drow;	state Exp;
branches;
next	1.31;

1.31
date	2006.10.04.21.36.39;	author brobecke;	state Exp;
branches;
next	1.30;

1.30
date	2006.03.01.05.47.46;	author tausq;	state Exp;
branches;
next	1.29;

1.29
date	2005.12.17.22.34.02;	author eliz;	state Exp;
branches;
next	1.28;

1.28
date	2005.12.08.00.17.33;	author tausq;	state Exp;
branches;
next	1.27;

1.27
date	2005.02.11.04.06.05;	author cagney;	state Exp;
branches;
next	1.26;

1.26
date	2004.12.18.14.21.09;	author kettenis;	state Exp;
branches;
next	1.25;

1.25
date	2004.10.23.16.18.09;	author cagney;	state Exp;
branches;
next	1.24;

1.24
date	2004.08.10.21.52.05;	author cagney;	state Exp;
branches;
next	1.23;

1.23
date	2004.06.11.23.44.24;	author tausq;	state Exp;
branches;
next	1.22;

1.22
date	2004.02.07.18.29.54;	author ezannoni;	state Exp;
branches
	1.22.4.1;
next	1.21;

1.21
date	2003.09.14.16.32.14;	author cagney;	state Exp;
branches;
next	1.20;

1.20
date	2003.07.09.18.50.12;	author brobecke;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.06.23.32.59;	author mmitchel;	state Exp;
branches
	1.19.4.1;
next	1.18;

1.18
date	2003.03.29.23.29.47;	author cagney;	state Exp;
branches;
next	1.17;

1.17
date	2003.02.20.18.31.14;	author drow;	state Exp;
branches
	1.17.10.1;
next	1.16;

1.16
date	2003.01.19.04.06.46;	author cagney;	state Exp;
branches;
next	1.15;

1.15
date	2002.03.27.00.21.51;	author law;	state Exp;
branches
	1.15.14.1
	1.15.16.1;
next	1.14;

1.14
date	2002.02.04.11.55.35;	author rearnsha;	state Exp;
branches;
next	1.13;

1.13
date	2002.01.08.02.09.31;	author msnyder;	state Exp;
branches;
next	1.12;

1.12
date	2001.12.02.22.38.23;	author cagney;	state Exp;
branches;
next	1.11;

1.11
date	2001.09.20.03.03.40;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.06.08.21.17;	author kevinb;	state Exp;
branches;
next	1.9;

1.9
date	2000.12.15.01.01.49;	author kevinb;	state Exp;
branches;
next	1.8;

1.8
date	2000.10.30.21.50.58;	author jtc;	state Exp;
branches;
next	1.7;

1.7
date	2000.08.27.22.30.29;	author ezannoni;	state Exp;
branches;
next	1.6;

1.6
date	2000.07.30.01.48.27;	author kevinb;	state Exp;
branches;
next	1.5;

1.5
date	2000.05.28.01.12.29;	author kevinb;	state Exp;
branches;
next	1.4;

1.4
date	2000.05.16.04.07.39;	author cagney;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.04.16.52.34;	author ezannoni;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.21.14.24.45;	author ezannoni;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.04;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.52.2.1
date	2012.01.06.04.43.30;	author brobecke;	state Exp;
branches;
next	;

1.22.4.1
date	2004.09.16.17.01.19;	author drow;	state Exp;
branches;
next	;

1.19.4.1
date	2003.07.09.18.51.42;	author brobecke;	state Exp;
branches;
next	;

1.17.10.1
date	2003.03.30.16.35.22;	author cagney;	state Exp;
branches;
next	;

1.15.14.1
date	2003.02.07.19.17.52;	author carlton;	state Exp;
branches;
next	1.15.14.2;

1.15.14.2
date	2003.03.06.00.56.32;	author carlton;	state Exp;
branches;
next	1.15.14.3;

1.15.14.3
date	2003.04.16.19.56.54;	author carlton;	state Exp;
branches;
next	1.15.14.4;

1.15.14.4
date	2003.06.27.21.50.10;	author carlton;	state Exp;
branches;
next	1.15.14.5;

1.15.14.5
date	2003.08.05.17.13.14;	author carlton;	state Exp;
branches;
next	1.15.14.6;

1.15.14.6
date	2003.09.17.21.28.31;	author carlton;	state Exp;
branches;
next	;

1.15.16.1
date	2003.12.14.20.27.30;	author drow;	state Exp;
branches;
next	1.15.16.2;

1.15.16.2
date	2004.02.09.19.43.48;	author drow;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.04;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.06.07.19.17.51;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.07.07.20.10.02;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.08.09.21.33.54;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.08.16.19.53.58;	author jsm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.09.08.23.59.30;	author shebs;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	99.10.05.23.08.49;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.64
log
@	* symfile.h (struct sym_fns): Delete member "sym_flavour".
	All uses updated.
	(add_symtab_fns): Update prototype.
	* symfile.c (sym_fns_ptr): Delete.  Replace with ...
	(registered_sym_fns): ... this.
	(symtab_fns): Update.
	(add_symtab_fns): New arg "flavour".  All callers updated.
	(find_sym_fns): Rewrite to use new sym_fns registry.
@
text
@/* Read HP PA/Risc object files for GDB.
   Copyright (C) 1991-2013 Free Software Foundation, Inc.
   Written by Fred Fish at Cygnus Support.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "bfd.h"
#include "som/aout.h"
#include "symtab.h"
#include "symfile.h"
#include "objfiles.h"
#include "buildsym.h"
#include "stabsread.h"
#include "gdb-stabs.h"
#include "complaints.h"
#include "gdb_string.h"
#include "demangle.h"
#include "som.h"
#include "libhppa.h"
#include "psymtab.h"

#include "solib-som.h"

/* Read the symbol table of a SOM file.

   Given an open bfd, a base address to relocate symbols to, and a
   flag that specifies whether or not this bfd is for an executable
   or not (may be shared library for example), add all the global
   function and data symbols to the minimal symbol table.  */

static void
som_symtab_read (bfd *abfd, struct objfile *objfile,
		 struct section_offsets *section_offsets)
{
  struct cleanup *cleanup;
  struct gdbarch *gdbarch = get_objfile_arch (objfile);
  unsigned int number_of_symbols;
  int val, dynamic;
  char *stringtab;
  asection *shlib_info;
  struct som_external_symbol_dictionary_record *buf, *bufp, *endbufp;
  char *symname;
  CONST int symsize = sizeof (struct som_external_symbol_dictionary_record);


#define text_offset ANOFFSET (section_offsets, SECT_OFF_TEXT (objfile))
#define data_offset ANOFFSET (section_offsets, SECT_OFF_DATA (objfile))

  number_of_symbols = bfd_get_symcount (abfd);

  /* Allocate a buffer to read in the debug info.
     We avoid using alloca because the memory size could be so large
     that we could hit the stack size limit.  */
  buf = xmalloc (symsize * number_of_symbols);
  cleanup = make_cleanup (xfree, buf);
  bfd_seek (abfd, obj_som_sym_filepos (abfd), SEEK_SET);
  val = bfd_bread (buf, symsize * number_of_symbols, abfd);
  if (val != symsize * number_of_symbols)
    error (_("Couldn't read symbol dictionary!"));

  /* Allocate a buffer to read in the som stringtab section of
     the debugging info.  Again, we avoid using alloca because
     the data could be so large that we could potentially hit
     the stack size limitat.  */
  stringtab = xmalloc (obj_som_stringtab_size (abfd));
  make_cleanup (xfree, stringtab);
  bfd_seek (abfd, obj_som_str_filepos (abfd), SEEK_SET);
  val = bfd_bread (stringtab, obj_som_stringtab_size (abfd), abfd);
  if (val != obj_som_stringtab_size (abfd))
    error (_("Can't read in HP string table."));

  /* We need to determine if objfile is a dynamic executable (so we
     can do the right thing for ST_ENTRY vs ST_CODE symbols).

     There's nothing in the header which easily allows us to do
     this.

     This code used to rely upon the existence of a $SHLIB_INFO$
     section to make this determination.  HP claims that it is
     more accurate to check for a nonzero text offset, but they
     have not provided any information about why that test is
     more accurate.  */
  dynamic = (text_offset != 0);

  endbufp = buf + number_of_symbols;
  for (bufp = buf; bufp < endbufp; ++bufp)
    {
      enum minimal_symbol_type ms_type;
      unsigned int flags = bfd_getb32 (bufp->flags);
      unsigned int symbol_type
	= (flags >> SOM_SYMBOL_TYPE_SH) & SOM_SYMBOL_TYPE_MASK;
      unsigned int symbol_scope
	= (flags >> SOM_SYMBOL_SCOPE_SH) & SOM_SYMBOL_SCOPE_MASK;
      CORE_ADDR symbol_value = bfd_getb32 (bufp->symbol_value);
      asection *section = NULL;

      QUIT;

      /* Compute the section.  */
      switch (symbol_scope)
	{
	case SS_EXTERNAL:
	  if (symbol_type != ST_STORAGE)
	    section = bfd_und_section_ptr;
	  else
	    section = bfd_com_section_ptr;
	  break;

	case SS_UNSAT:
	  if (symbol_type != ST_STORAGE)
	    section = bfd_und_section_ptr;
	  else
	    section = bfd_com_section_ptr;
	  break;

	case SS_UNIVERSAL:
	  section = bfd_section_from_som_symbol (abfd, bufp);
	  break;

	case SS_LOCAL:
	  section = bfd_section_from_som_symbol (abfd, bufp);
	  break;
	}

      switch (symbol_scope)
	{
	case SS_UNIVERSAL:
	case SS_EXTERNAL:
	  switch (symbol_type)
	    {
	    case ST_SYM_EXT:
	    case ST_ARG_EXT:
	      continue;

	    case ST_CODE:
	    case ST_PRI_PROG:
	    case ST_SEC_PROG:
	    case ST_MILLICODE:
	      symname = bfd_getb32 (bufp->name) + stringtab;
	      ms_type = mst_text;
	      symbol_value += text_offset;
	      symbol_value = gdbarch_addr_bits_remove (gdbarch, symbol_value);
	      break;

	    case ST_ENTRY:
	      symname = bfd_getb32 (bufp->name) + stringtab;
	      /* For a dynamic executable, ST_ENTRY symbols are
	         the stubs, while the ST_CODE symbol is the real
	         function.  */
	      if (dynamic)
		ms_type = mst_solib_trampoline;
	      else
		ms_type = mst_text;
	      symbol_value += text_offset;
	      symbol_value = gdbarch_addr_bits_remove (gdbarch, symbol_value);
	      break;

	    case ST_STUB:
	      symname = bfd_getb32 (bufp->name) + stringtab;
	      ms_type = mst_solib_trampoline;
	      symbol_value += text_offset;
	      symbol_value = gdbarch_addr_bits_remove (gdbarch, symbol_value);
	      break;

	    case ST_DATA:
	      symname = bfd_getb32 (bufp->name) + stringtab;
	      symbol_value += data_offset;
	      ms_type = mst_data;
	      break;
	    default:
	      continue;
	    }
	  break;

#if 0
	  /* SS_GLOBAL and SS_LOCAL are two names for the same thing (!).  */
	case SS_GLOBAL:
#endif
	case SS_LOCAL:
	  switch (symbol_type)
	    {
	    case ST_SYM_EXT:
	    case ST_ARG_EXT:
	      continue;

	    case ST_CODE:
	      symname = bfd_getb32 (bufp->name) + stringtab;
	      ms_type = mst_file_text;
	      symbol_value += text_offset;
	      symbol_value = gdbarch_addr_bits_remove (gdbarch, symbol_value);

	    check_strange_names:
	      /* Utah GCC 2.5, FSF GCC 2.6 and later generate correct local
	         label prefixes for stabs, constant data, etc.  So we need
	         only filter out L$ symbols which are left in due to
	         limitations in how GAS generates SOM relocations.

	         When linking in the HPUX C-library the HP linker has
	         the nasty habit of placing section symbols from the literal
	         subspaces in the middle of the program's text.  Filter
	         those out as best we can.  Check for first and last character
	         being '$'.

	         And finally, the newer HP compilers emit crud like $PIC_foo$N
	         in some circumstance (PIC code I guess).  It's also claimed
	         that they emit D$ symbols too.  What stupidity.  */
	      if ((symname[0] == 'L' && symname[1] == '$')
	      || (symname[0] == '$' && symname[strlen (symname) - 1] == '$')
		  || (symname[0] == 'D' && symname[1] == '$')
		  || (strncmp (symname, "L0\001", 3) == 0)
		  || (strncmp (symname, "$PIC", 4) == 0))
		continue;
	      break;

	    case ST_PRI_PROG:
	    case ST_SEC_PROG:
	    case ST_MILLICODE:
	      symname = bfd_getb32 (bufp->name) + stringtab;
	      ms_type = mst_file_text;
	      symbol_value += text_offset;
	      symbol_value = gdbarch_addr_bits_remove (gdbarch, symbol_value);
	      break;

	    case ST_ENTRY:
	      symname = bfd_getb32 (bufp->name) + stringtab;
	      /* SS_LOCAL symbols in a shared library do not have
		 export stubs, so we do not have to worry about
		 using mst_file_text vs mst_solib_trampoline here like
		 we do for SS_UNIVERSAL and SS_EXTERNAL symbols above.  */
	      ms_type = mst_file_text;
	      symbol_value += text_offset;
	      symbol_value = gdbarch_addr_bits_remove (gdbarch, symbol_value);
	      break;

	    case ST_STUB:
	      symname = bfd_getb32 (bufp->name) + stringtab;
	      ms_type = mst_solib_trampoline;
	      symbol_value += text_offset;
	      symbol_value = gdbarch_addr_bits_remove (gdbarch, symbol_value);
	      break;


	    case ST_DATA:
	      symname = bfd_getb32 (bufp->name) + stringtab;
	      symbol_value += data_offset;
	      ms_type = mst_file_data;
	      goto check_strange_names;

	    default:
	      continue;
	    }
	  break;

	  /* This can happen for common symbols when -E is passed to the
	     final link.  No idea _why_ that would make the linker force
	     common symbols to have an SS_UNSAT scope, but it does.

	     This also happens for weak symbols, but their type is
	     ST_DATA.  */
	case SS_UNSAT:
	  switch (symbol_type)
	    {
	    case ST_STORAGE:
	    case ST_DATA:
	      symname = bfd_getb32 (bufp->name) + stringtab;
	      symbol_value += data_offset;
	      ms_type = mst_data;
	      break;

	    default:
	      continue;
	    }
	  break;

	default:
	  continue;
	}

      if (bfd_getb32 (bufp->name) > obj_som_stringtab_size (abfd))
	error (_("Invalid symbol data; bad HP string table offset: %s"),
	       plongest (bfd_getb32 (bufp->name)));

      if (bfd_is_const_section (section))
	{
	  struct obj_section *iter;

	  ALL_OBJFILE_OSECTIONS (objfile, iter)
	    {
	      if (bfd_is_const_section (iter->the_bfd_section))
		continue;

	      if (obj_section_addr (iter) <= symbol_value
		  && symbol_value < obj_section_endaddr (iter))
		{
		  section = iter->the_bfd_section;
		  break;
		}
	    }
	}

      prim_record_minimal_symbol_and_info (symname, symbol_value, ms_type,
					   gdb_bfd_section_index (objfile->obfd,
								  section),
					   objfile);
    }

  do_cleanups (cleanup);
}

/* Scan and build partial symbols for a symbol file.
   We have been initialized by a call to som_symfile_init, which 
   currently does nothing.

   SECTION_OFFSETS is a set of offsets to apply to relocate the symbols
   in each section.  This is ignored, as it isn't needed for SOM.

   This function only does the minimum work necessary for letting the
   user "name" things symbolically; it does not read the entire symtab.
   Instead, it reads the external and static symbols and puts them in partial
   symbol tables.  When more extensive information is requested of a
   file, the corresponding partial symbol table is mutated into a full
   fledged symbol table by going back and reading the symbols
   for real.

   We look for sections with specific names, to tell us what debug
   format to look for.

   somstab_build_psymtabs() handles STABS symbols.

   Note that SOM files have a "minimal" symbol table, which is vaguely
   reminiscent of a COFF symbol table, but has only the minimal information
   necessary for linking.  We process this also, and use the information to
   build gdb's minimal symbol table.  This gives us some minimal debugging
   capability even for files compiled without -g.  */

static void
som_symfile_read (struct objfile *objfile, int symfile_flags)
{
  bfd *abfd = objfile->obfd;
  struct cleanup *back_to;

  init_minimal_symbol_collection ();
  back_to = make_cleanup_discard_minimal_symbols ();

  /* Process the normal SOM symbol table first.
     This reads in the DNTT and string table, but doesn't
     actually scan the DNTT.  It does scan the linker symbol
     table and thus build up a "minimal symbol table".  */

  som_symtab_read (abfd, objfile, objfile->section_offsets);

  /* Install any minimal symbols that have been collected as the current
     minimal symbols for this objfile.
     Further symbol-reading is done incrementally, file-by-file,
     in a step known as "psymtab-to-symtab" expansion.  hp-symtab-read.c
     contains the code to do the actual DNTT scanning and symtab building.  */
  install_minimal_symbols (objfile);
  do_cleanups (back_to);

  /* Now read information from the stabs debug sections.
     This is emitted by gcc.  */
  stabsect_build_psymtabs (objfile,
			   "$GDB_SYMBOLS$", "$GDB_STRINGS$", "$TEXT$");
}

/* Initialize anything that needs initializing when a completely new symbol
   file is specified (not just adding some symbols from another file, e.g. a
   shared library).

   We reinitialize buildsym, since we may be reading stabs from a SOM file.  */

static void
som_new_init (struct objfile *ignore)
{
  stabsread_new_init ();
  buildsym_new_init ();
}

/* Perform any local cleanups required when we are done with a particular
   objfile.  I.e, we are in the process of discarding all symbol information
   for an objfile, freeing up all memory held for it, and unlinking the
   objfile struct from the global list of known objfiles.  */

static void
som_symfile_finish (struct objfile *objfile)
{
}

/* SOM specific initialization routine for reading symbols.  */

static void
som_symfile_init (struct objfile *objfile)
{
  /* SOM objects may be reordered, so set OBJF_REORDERED.  If we
     find this causes a significant slowdown in gdb then we could
     set it in the debug symbol readers only when necessary.  */
  objfile->flags |= OBJF_REORDERED;
}

/* An object of this type is passed to find_section_offset.  */

struct find_section_offset_arg
{
  /* The objfile.  */

  struct objfile *objfile;

  /* Flags to invert.  */

  flagword invert;

  /* Flags to look for.  */

  flagword flags;

  /* A text section with non-zero size, if any.  */

  asection *best_section;

  /* An empty text section, if any.  */

  asection *empty_section;
};

/* A callback for bfd_map_over_sections that tries to find a section
   with particular flags in an objfile.  */

static void
find_section_offset (bfd *abfd, asection *sect, void *arg)
{
  struct find_section_offset_arg *info = arg;
  flagword aflag;

  aflag = bfd_get_section_flags (abfd, sect);

  aflag ^= info->invert;

  if ((aflag & info->flags) == info->flags)
    {
      if (bfd_section_size (abfd, sect) > 0)
	{
	  if (info->best_section == NULL)
	    info->best_section = sect;
	}
      else
	{
	  if (info->empty_section == NULL)
	    info->empty_section = sect;
	}
    }
}

/* Set a section index from a BFD.  */

static void
set_section_index (struct objfile *objfile, flagword invert, flagword flags,
		   int *index_ptr)
{
  struct find_section_offset_arg info;

  info.objfile = objfile;
  info.best_section = NULL;
  info.empty_section = NULL;
  info.invert = invert;
  info.flags = flags;
  bfd_map_over_sections (objfile->obfd, find_section_offset, &info);

  if (info.best_section)
    *index_ptr = info.best_section->index;
  else if (info.empty_section)
    *index_ptr = info.empty_section->index;
}

/* SOM specific parsing routine for section offsets.

   Plain and simple for now.  */

static void
som_symfile_offsets (struct objfile *objfile,
		     const struct section_addr_info *addrs)
{
  int i;
  CORE_ADDR text_addr;
  asection *sect;

  objfile->num_sections = bfd_count_sections (objfile->obfd);
  objfile->section_offsets = (struct section_offsets *)
    obstack_alloc (&objfile->objfile_obstack, 
		   SIZEOF_N_SECTION_OFFSETS (objfile->num_sections));

  set_section_index (objfile, 0, SEC_ALLOC | SEC_CODE,
		     &objfile->sect_index_text);
  set_section_index (objfile, 0, SEC_ALLOC | SEC_DATA,
		     &objfile->sect_index_data);
  set_section_index (objfile, SEC_LOAD, SEC_ALLOC | SEC_LOAD,
		     &objfile->sect_index_bss);
  set_section_index (objfile, 0, SEC_ALLOC | SEC_READONLY,
		     &objfile->sect_index_rodata);

  /* First see if we're a shared library.  If so, get the section
     offsets from the library, else get them from addrs.  */
  if (!som_solib_section_offsets (objfile, objfile->section_offsets))
    {
      /* Note: Here is OK to compare with ".text" because this is the
         name that gdb itself gives to that section, not the SOM
         name.  */
      for (i = 0; i < addrs->num_sections; i++)
	if (strcmp (addrs->other[i].name, ".text") == 0)
	  break;
      text_addr = addrs->other[i].addr;

      for (i = 0; i < objfile->num_sections; i++)
	(objfile->section_offsets)->offsets[i] = text_addr;
    }
}



/* Register that we are able to handle SOM object file formats.  */

static const struct sym_fns som_sym_fns =
{
  som_new_init,			/* init anything gbl to entire symtab */
  som_symfile_init,		/* read initial info, setup for sym_read() */
  som_symfile_read,		/* read a symbol file into symtab */
  NULL,				/* sym_read_psymbols */
  som_symfile_finish,		/* finished with file, cleanup */
  som_symfile_offsets,		/* Translate ext. to int. relocation */
  default_symfile_segments,	/* Get segment information from a file.  */
  NULL,
  default_symfile_relocate,	/* Relocate a debug section.  */
  NULL,				/* sym_get_probes */
  &psym_functions
};

initialize_file_ftype _initialize_somread;

void
_initialize_somread (void)
{
  add_symtab_fns (bfd_target_som_flavour, &som_sym_fns);
}
@


1.63
log
@fix cleanups in som_symtab_read

This fixes som_symtab_read not to leak cleanups.

	* somread.c (som_symtab_read): Call do_cleanups.
@
text
@a536 1
  bfd_target_som_flavour,
d555 1
a555 1
  add_symtab_fns (&som_sym_fns);
@


1.62
log
@	* somread.c (som_symfile_offsets): Add 'const' to addrs.
	* machoread.c (macho_symfile_offsets): Add 'const' to addrs.
	* xcoffread.c (xcoff_symfile_offsets): Add 'const' to addrs.
	Remove declaration.
@
text
@d49 1
d69 1
a69 1
  make_cleanup (xfree, buf);
d320 2
@


1.61
log
@	* coffread.c (record_minimal_symbol): Update.
	* dbxread.c (record_minimal_symbol): Update.
	* elfread.c (record_minimal_symbol): Update.
	* machoread.c (macho_symtab_add_minsym): Update.
	* mdebugread.c (record_minimal_symbol, parse_partial_symbols):
	Update.
	* minsyms.c (prim_record_minimal_symbol): Update.
	(prim_record_minimal_symbol_full): Remove 'bfd_section'
	argument.
	(prim_record_minimal_symbol_and_info): Likewise.
	* minsyms.h (prim_record_minimal_symbol_full)
	(prim_record_minimal_symbol_and_info): Update.
	* symtab.c (allocate_symbol, initialize_symbol)
	(allocate_template_symbol): Initialize SYMBOL_SECTION.
	* xcoffread.c (record_minimal_symbol, scan_xcoff_symtab):
	Update.
@
text
@d490 2
a491 1
som_symfile_offsets (struct objfile *objfile, struct section_addr_info *addrs)
@


1.60
log
@	PR symtab/8423:
	* solib-som.c (som_solib_section_offsets): Use BFD section
	indices.  Set offsets for all sections.
	* somread.c (som_symtab_read): Compute BFD section for
	symbol.  Use prim_record_minimal_symbol_and_info.
	(som_symfile_read): Fix comment.
	(struct find_section_offset_arg): New.
	(find_section_offset, set_section_index): New functions.
	(som_symfile_offsets): Use set_section_index to compute
	section indices.
bfd/
	* som.c (bfd_section_from_som_symbol): No longer static.
	* som.h (bfd_section_from_som_symbol): Declare.
@
text
@a316 1
					   section,
@


1.59
log
@	* symfile.c (alloc_section_addr_info): Update header.  Don't set
	'num_sections' field.
	(build_section_addr_info_from_section_table): Set 'num_sections'.
	(build_section_addr_info_from_bfd): Likewise.
	(build_section_addr_info_from_objfile): Remove dead loop
	condition.
	(free_section_addr_info): Unconditionally call xfree.
	(relative_addr_info_to_section_offsets, addrs_section_sort)
	(addr_info_make_relative, syms_from_objfile_1): Remove dead loop
	condition.
	(syms_from_objfile_1): Remove dead 'if' condition.  Check
	'num_sections'.
	(add_symbol_file_command): Set 'num_sections'.
	* symfile-mem.c (symbol_file_add_from_memory): Set
	'num_sections'.
	* somread.c (som_symfile_offsets): Remove dead loop condition.
	* machoread.c (macho_symfile_offsets): Remove dead 'if'.
	* jit.c (jit_bfd_try_read_symtab): Set 'num_sections'.
@
text
@a56 1
  CORE_ADDR text_offset, data_offset;
d59 2
a60 2
  text_offset = ANOFFSET (section_offsets, 0);
  data_offset = ANOFFSET (section_offsets, 1);
d108 1
d112 26
d296 23
a318 1
      prim_record_minimal_symbol (symname, symbol_value, ms_type, objfile);
d338 1
a338 1
   format to look for:  FIXME!!!
d412 74
d495 1
d502 8
a509 10
  /* FIXME: ezannoni 2000-04-20 The section names in SOM are not
     .text, .data, etc, but $TEXT$, $DATA$,...  We should initialize
     SET_OFF_* from bfd.  (See default_symfile_offsets()).  But I don't
     know the correspondence between SOM sections and GDB's idea of
     section names.  So for now we default to what is was before these
     changes.  */
  objfile->sect_index_text = 0;
  objfile->sect_index_data = 1;
  objfile->sect_index_bss = 2;
  objfile->sect_index_rodata = 3;
@


1.58
log
@	* config/pa/hpux.mh (NATDEPFILES): Remove somread.o.
	* configure: Rebuild.
	* configure.ac: Add somread.o to the build if BFD has SOM
	support.
	* somread.c: Include som/aout.h, not syms.h.
	(som_symtab_read): Use som_external_symbol_dictionary_record.
	Unpack records manually.
	(_initialize_somread): Declare.
@
text
@d397 1
a397 1
      for (i = 0; i < addrs->num_sections && addrs->other[i].name; i++)
@


1.57
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d22 1
a22 1
#include <syms.h>
d54 1
a54 1
  struct symbol_dictionary_record *buf, *bufp, *endbufp;
d56 1
a56 1
  CONST int symsize = sizeof (struct symbol_dictionary_record);
d103 6
d112 1
a112 1
      switch (bufp->symbol_scope)
d116 1
a116 1
	  switch (bufp->symbol_type)
d126 1
a126 1
	      symname = bufp->name.n_strx + stringtab;
d128 2
a129 3
	      bufp->symbol_value += text_offset;
	      bufp->symbol_value = gdbarch_addr_bits_remove
				     (gdbarch, bufp->symbol_value);
d133 1
a133 1
	      symname = bufp->name.n_strx + stringtab;
d141 2
a142 3
	      bufp->symbol_value += text_offset;
	      bufp->symbol_value = gdbarch_addr_bits_remove
				     (gdbarch, bufp->symbol_value);
d146 1
a146 1
	      symname = bufp->name.n_strx + stringtab;
d148 2
a149 3
	      bufp->symbol_value += text_offset;
	      bufp->symbol_value = gdbarch_addr_bits_remove
				     (gdbarch, bufp->symbol_value);
d153 2
a154 2
	      symname = bufp->name.n_strx + stringtab;
	      bufp->symbol_value += data_offset;
d167 1
a167 1
	  switch (bufp->symbol_type)
d174 1
a174 1
	      symname = bufp->name.n_strx + stringtab;
d176 2
a177 3
	      bufp->symbol_value += text_offset;
	      bufp->symbol_value = gdbarch_addr_bits_remove
				     (gdbarch, bufp->symbol_value);
d205 1
a205 1
	      symname = bufp->name.n_strx + stringtab;
d207 2
a208 3
	      bufp->symbol_value += text_offset;
	      bufp->symbol_value = gdbarch_addr_bits_remove
				     (gdbarch, bufp->symbol_value);
d212 1
a212 1
	      symname = bufp->name.n_strx + stringtab;
d218 2
a219 3
	      bufp->symbol_value += text_offset;
	      bufp->symbol_value = gdbarch_addr_bits_remove
				     (gdbarch, bufp->symbol_value);
d223 1
a223 1
	      symname = bufp->name.n_strx + stringtab;
d225 2
a226 3
	      bufp->symbol_value += text_offset;
	      bufp->symbol_value = gdbarch_addr_bits_remove
				     (gdbarch, bufp->symbol_value);
d231 2
a232 2
	      symname = bufp->name.n_strx + stringtab;
	      bufp->symbol_value += data_offset;
d248 1
a248 1
	  switch (bufp->symbol_type)
d252 2
a253 2
	      symname = bufp->name.n_strx + stringtab;
	      bufp->symbol_value += data_offset;
d266 3
a268 3
      if (bufp->name.n_strx > obj_som_stringtab_size (abfd))
	error (_("Invalid symbol data; bad HP string table offset: %d"),
	       bufp->name.n_strx);
d270 1
a270 2
      prim_record_minimal_symbol (symname, bufp->symbol_value, ms_type,
				  objfile);
d427 2
@


1.56
log
@	* coffread.c (coff_symfile_init): Use set_objfile_data.
	(coff_symfile_read): Use DBX_SYMFILE_INFO.
	* dbxread.c (dbx_objfile_data_key): New global.
	(dbx_symfile_init): Use set_objfile_data.
	(dbx_symfile_finish): Don't free deprecated_sym_stab_info.
	(dbx_free_symfile_info): New function.
	(coffstab_build_psymtabs, elfstab_build_psymtabs): Use
	DBX_SYMFILE_INFO.
	(stabsect_build_psymtabs): Use set_objfile_data.
	(_initialize_dbxreadb): Initialize dbx_objfile_data_key.
	* elfread.c (elf_symtab_read): Use DBX_SYMFILE_INFO,
	set_objfile_data.
	(free_elfinfo): Use DBX_SYMFILE_INFO.
	(elf_symfile_finish): Don't free deprecated_sym_stab_info.
	(elfstab_offset_sections): Use DBX_SYMFILE_INFO.
	* gdb-stabs.h (dbx_objfile_data_key): Declare.
	(DBX_SYMFILE_INFO): Rewrite to use objfile_data.
	* objfiles.h (struct objfile) <deprecated_sym_stab_info>: Remove.
	* somread.c (som_symfile_finish): Don't free
	deprecated_sym_stab_info.
@
text
@d2 1
a2 2
   Copyright (C) 1991-1992, 1994-1996, 1998-2002, 2004, 2007-2012 Free
   Software Foundation, Inc.
@


1.55
log
@gdb/
2012-11-21  Yao Qi  <yao@@codesourcery.com>

	PR tdep/7438
	* gdbarch.sh (smash_text_address): Remove.
	* gdbarch.c, gdbarch.h: Regenerate.
	* arm-tdep.c (arm_smash_text_address): Remove.
	(arm_gdbarch_init): Don't call set_gdbarch_smash_text_address.
	* hppa-tdep.c (hppa_smash_text_address): Remove.
	(hppa_addr_bits_remove): Rename from hppa_smash_text_address.
	(hppa_gdbarch_init): Don't call set_gdbarch_smash_text_address.
	Caller update.
	* coffread.c (coff_symtab_read): Caller update.
	* dbxread.c (process_one_symbol): Likewise.
	* elfread.c (record_minimal_symbol): Likewise.
	* somread.c (som_symtab_read): Likewise.
@
text
@a353 4
  if (objfile->deprecated_sym_stab_info != NULL)
    {
      xfree (objfile->deprecated_sym_stab_info);
    }
@


1.54
log
@2012-04-27  Sergio Durigan Junior  <sergiodj@@redhat.com>
	    Tom Tromey  <tromey@@redhat.com>
	    Jan Kratochvil  <jan.kratochvil@@redhat.com>

	* Makefile.in (SFILES): Add `probe' and `stap-probe'.
	(COMMON_OBS): Likewise.
	(HFILES_NO_SRCDIR): Add `probe'.
	* NEWS: Mention support for static and SystemTap probes.
	* amd64-tdep.c (amd64_init_abi): Initializing proper fields used by
	SystemTap probes' arguments parser.
	* arm-linux-tdep.c: Including headers needed to perform the parsing
	of SystemTap probes' arguments.
	(arm_stap_is_single_operand): New function.
	(arm_stap_parse_special_token): Likewise.
	(arm_linux_init_abi): Initializing proper fields used by SystemTap
	probes' arguments parser.
	* ax-gdb.c (require_rvalue): Removing static declaration.
	(gen_expr): Likewise.
	* ax-gdb.h (gen_expr): Declaring function.
	(require_rvalue): Likewise.
	* breakpoint.c: Include `gdb_regex.h' and `probe.h'.
	(bkpt_probe_breakpoint_ops): New variable.
	(momentary_breakpoint_from_master): Set the `probe' value.
	(add_location_to_breakpoint): Likewise.
	(break_command_1): Using proper breakpoint_ops according to the
	argument passed by the user in the command line.
	(bkpt_probe_insert_location): New function.
	(bkpt_probe_remove_location): Likewise.
	(bkpt_probe_create_sals_from_address): Likewise.
	(bkpt_probe_decode_linespec): Likewise.
	(tracepoint_probe_create_sals_from_address): Likewise.
	(tracepoint_probe_decode_linespec): Likewise.
	(tracepoint_probe_breakpoint_ops): New variable.
	(trace_command): Using proper breakpoint_ops according to the
	argument passed by the user in the command line.
	(initialize_breakpoint_ops): Initializing breakpoint_ops for
	static probes on breakpoints and tracepoints.
	* breakpoint.h (struct bp_location) <probe>: New field.
	* cli-utils.c (skip_spaces_const): New function.
	(extract_arg): Likewise.
	* cli-utils.h (skip_spaces_const): Likewise.
	(extract_arg): Likewise.
	* coffread.c (coff_sym_fns): Add `sym_probe_fns' value.
	* configure.ac: Append `stap-probe.o' to be generated when ELF
	support is present.
	* configure: Regenerate.
	* dbxread.c (aout_sym_fns): Add `sym_probe_fns' value.
	* elfread.c: Include `probe.h' and `arch-utils.h'.
	(probe_key): New variable.
	(elf_get_probes): New function.
	(elf_get_probe_argument_count): Likewise.
	(elf_evaluate_probe_argument): Likewise.
	(elf_compile_to_ax): Likewise.
	(elf_symfile_relocate_probe): Likewise.
	(stap_probe_key_free): Likewise.
	(elf_probe_fns): New variable.
	(elf_sym_fns): Add `sym_probe_fns' value.
	(elf_sym_fns_lazy_psyms): Likewise.
	(elf_sym_fns_gdb_index): Likewise.
	(_initialize_elfread): Initialize objfile cache for static
	probes.
	* gdb_vecs.h (struct probe): New forward declaration.
	(probe_p): New VEC declaration.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* gdbarch.sh (stap_integer_prefix): New variable.
	(stap_integer_suffix): Likewise.
	(stap_register_prefix): Likewise.
	(stap_register_suffix): Likewise.
	(stap_register_indirection_prefix): Likewise.
	(stap_register_indirection_suffix): Likewise.
	(stap_gdb_register_prefix): Likewise.
	(stap_gdb_register_suffix): Likewise.
	(stap_is_single_operand): New function.
	(stap_parse_special_token): Likewise.
	(struct stap_parse_info): Forward declaration.
	* i386-tdep.c: Including headers needed to perform the parsing
	of SystemTap probes' arguments.
	(i386_stap_is_single_operand): New function.
	(i386_stap_parse_special_token): Likewise.
	(i386_elf_init_abi): Initializing proper fields used by SystemTap
	probes' arguments parser.
	* i386-tdep.h (i386_stap_is_single_operand): New function.
	(i386_stap_parse_special_token): Likewise.
	* machoread.c (macho_sym_fns): Add `sym_probe_fns' value.
	* mipsread.c (ecoff_sym_fns): Likewise.
	* objfiles.c (objfile_relocate1): Support relocation for static
	probes.
	* parse.c (prefixify_expression): Remove static declaration.
	(initialize_expout): Likewise.
	(reallocate_expout): Likewise.
	* parser-defs.h (initialize_expout): Declare function.
	(reallocate_expout): Likewise.
	(prefixify_expression): Likewise.
	* ppc-linux-tdep.c: Including headers needed to perform the parsing
	of SystemTap probes' arguments.
	(ppc_stap_is_single_operand): New function.
	(ppc_stap_parse_special_token): Likewise.
	(ppc_linux_init_abi): Initializing proper fields used by SystemTap
	probes' arguments parser.
	* probe.c: New file, for generic statically defined probe support.
	* probe.h: Likewise.
	* s390-tdep.c: Including headers needed to perform the parsing of
	SystemTap probes' arguments.
	(s390_stap_is_single_operand): New function.
	(s390_gdbarch_init): Initializing proper fields used by SystemTap
	probes' arguments parser.
	* somread.c (som_sym_fns): Add `sym_probe_fns' value.
	* stap-probe.c: New file, for SystemTap probe support.
	* stap-probe.h: Likewise.
	* symfile.h: Include `gdb_vecs.h'.
	(struct sym_probe_fns): New struct.
	(struct sym_fns) <sym_probe_fns>: New field.
	* symtab.c (init_sal): Initialize `probe' field.
	* symtab.h (struct probe): Forward declaration.
	(struct symtab_and_line) <probe>: New field.
	* tracepoint.c (start_tracing): Adjust semaphore on breakpoints
	locations.
	(stop_tracing): Likewise.
	* xcoffread.c (xcoff_sym_fns): Add `sym_probe_fns' value.
@
text
@d124 1
a124 1
	      bufp->symbol_value = gdbarch_smash_text_address
d138 1
a138 1
	      bufp->symbol_value = gdbarch_smash_text_address
d146 1
a146 1
	      bufp->symbol_value = gdbarch_smash_text_address
d175 1
a175 1
	      bufp->symbol_value = gdbarch_smash_text_address
d207 1
a207 1
	      bufp->symbol_value = gdbarch_smash_text_address
d219 1
a219 1
	      bufp->symbol_value = gdbarch_smash_text_address
d227 1
a227 1
	      bufp->symbol_value = gdbarch_smash_text_address
@


1.53
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d430 1
@


1.52
log
@2011-08-09  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* elfread.c (elf_symtab_read): Ditto.
	* maint.c (maintenance_command): Ditto.
	* somread.c (som_symtab_read): Ditto.
	* solib.c (solib_find, solib_map_sections, update_solib_list)
	(solib_add, info_sharedlibrary_command, solib_name_from_address)
	(solib_create_inferior_hook, in_solib_dynsym_resolve_code)
	(sharedlibrary_command, no_shared_libraries): Rework comments.
	* solib-irix.c (locate_base, disable_break, enable_break)
	(irix_solib_create_inferior_hook, irix_solib_create_inferior_hook)
	(irix_current_sos, irix_open_symbol_file_object)
	(irix_special_symbol_handling): Ditto.
	* solib-sunos.c (locate_base, first_link_map_member)
	(sunos_current_sos, disable_break, enable_break)
	(sunos_special_symbol_handling, sunos_solib_create_inferior_hook):
	Ditto.
	* solib-svr4.c (bfd_lookup_symbol, elf_locate_base, locate_base)
	(open_symbol_file_object, svr4_current_sos, enable_break)
	(svr4_special_symbol_handling, svr4_solib_create_inferior_hook):
	Ditto.
	* solib-frv.c (bfd_lookup_symbol, open_symbol_file_object)
	(frv_current_sos, enable_break, frv_special_symbol_handling)
	(frv_solib_create_inferior_hook): Ditto.
	* solist.h (struct target_so_ops): Extend the comments of the
	special_symbol_handling, current_sos and open_symbol_file_object
	methods.
@
text
@d2 2
a3 2
   Copyright (C) 1991, 1992, 1994, 1995, 1996, 1998, 1999, 2000, 2001, 2002,
   2004, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
@


1.52.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 2
a3 2
   Copyright (C) 1991-1992, 1994-1996, 1998-2002, 2004, 2007-2012 Free
   Software Foundation, Inc.
@


1.51
log
@	* xcoffread.c (xcoff_sym_fns): Update.
	* symfile.h (struct sym_fns) <sym_read_psymbols>: New field.
	(enum symfile_add_flags) <SYMFILE_NO_READ>: New constant.
	* symfile.c (syms_from_objfile): Handle SYMFILE_NO_READ.
	(symbol_file_add_with_addrs_or_offsets): Likewise.
	(reread_symbols): Handle OBJF_PSYMTABS_READ.
	* somread.c (som_sym_fns): Update.
	* psymtab.h (require_partial_symbols): Declare.
	* psymtab.c (require_partial_symbols): New function.
	(ALL_OBJFILE_PSYMTABS_REQUIRED): New macro.
	(ALL_OBJFILE_PSYMTABS): Undef.
	(ALL_PSYMTABS): Move from psympriv.h.
	(lookup_partial_symtab, find_pc_sect_psymtab)
	(lookup_symbol_aux_psymtabs, relocate_psymtabs)
	(find_last_source_symtab_from_partial)
	(forget_cached_source_info_partial)
	(print_psymtab_stats_for_objfile, read_symtabs_for_function)
	(expand_partial_symbol_tables, read_psymtabs_with_filename)
	(map_symbol_names_psymtab, map_symbol_filenames_psymtab)
	(find_symbol_file_from_partial, map_matching_symbols_psymtab)
	(expand_symtabs_matching_via_partial, maintenance_info_psymtabs):
	Use ALL_OBJFILE_PSYMTABS_REQUIRED.
	* psympriv.h (ALL_PSYMTABS): Move to psymtab.c.
	* objfiles.h (OBJF_PSYMTABS_READ): New macro.
	* objfiles.c (objfile_has_partial_symbols): Handle lazily-read
	psymtabs.
	* mipsread.c (ecoff_sym_fns): Update.
	* machoread.c (macho_sym_fns): Update.
	* elfread.c (elf_symfile_read): Set up for lazy psymtab reading.
	(read_psyms): New function.
	(elf_sym_fns, elf_sym_fns_gdb_index): Update.
	(elf_sym_fns_lazy_psyms): New global.
	* dwarf2read.c (dwarf2_initialize_objfile): Don't call
	dwarf2_build_psymtabs.
	* dbxread.c (aout_sym_fns): Update.
	* coffread.c (coff_sym_fns): Update.
@
text
@d39 1
a39 12
/*

   LOCAL FUNCTION

   som_symtab_read -- read the symbol table of a SOM file

   SYNOPSIS

   void som_symtab_read (bfd *abfd, struct objfile *objfile,
   struct section_offsets *section_offsets)

   DESCRIPTION
d44 1
a44 2
   function and data symbols to the minimal symbol table.
 */
@


1.50
log
@2011-01-11  Michael Snyder  <msnyder@@vmware.com>

	* s390-tdep.c: Comment cleanup, mostly periods and spaces.
	* score-tdep.c: Ditto.
	* score-tdep.h: Ditto.
	* ser-base.c: Ditto.
	* ser-go32.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* ser-mingw.c: Ditto.
	* ser-pipe.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* sh64-tdep.c: Ditto.
	* shnbsd-nat.c: Ditto.
	* sh-tdep.c: Ditto.
	* sh-tdep.h: Ditto.
	* solib.c: Ditto.
	* solib-darwin.c: Ditto.
	* solib-frv.c: Ditto.
	* solib.h: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-spu.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solist.h: Ditto.
	* sol-thread.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* source.h: Ditto.
	* sparc64-linux-tdep.c: Ditto.
	* sparc64-tdep.c: Ditto.
	* sparc-linux-nat.c: Ditto.
	* sparc-linux-tdep.c: Ditto.
	* sparc-sol2-nat.c: Ditto.
	* sparc-sol2-tdep.c: Ditto.
	* sparc-tdep.c: Ditto.
	* sparc-tdep.h: Ditto.
	* spu-tdep.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.h: Ditto.
	* stack.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target.c: Ditto.
	* target-descriptions.c: Ditto.
	* target-descriptions.h: Ditto.
	* target.h: Ditto.
	* target-memory.c: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* trad-frame.h: Ditto.
	* typeprint.c: Ditto.
@
text
@d436 1
@


1.49
log
@2011-01-05  Michael Snyder  <msnyder@@vmware.com>

	* addrmap.c: Shorten lines of >= 80 columns.
	* arch-utils.c: Ditto.
	* arch-utils.h: Ditto.
	* ax-gdb.c: Ditto.
	* ax-general.c: Ditto.
	* bcache.c: Ditto.
	* blockframe.c: Ditto.
	* breakpoint.c: Ditto.
	* buildsym.c: Ditto.
	* c-lang.c: Ditto.
	* c-typeprint.c: Ditto.
	* charset.c: Ditto.
	* coffread.c: Ditto.
	* command.h: Ditto.
	* corelow.c: Ditto.
	* cp-abi.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* defs.h: Ditto.
	* dfp.c: Ditto.
	* dfp.h: Ditto.
	* dictionary.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* eval.c: Ditto.
	* event-loop.c: Ditto.
	* event-loop.h: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-lang.c: Ditto.
	* f-valprint.c: Ditto.
	* findcmd.c: Ditto.
	* frame-base.c: Ditto.
	* frame-unwind.c: Ditto.
	* frame-unwind.h: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_dirent.h: Ditto.
	* gdb_obstack.h: Ditto.
	* gdbcore.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* inf-ttrace.c: Ditto.
	* infcall.c: Ditto.
	* infcmd.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* inline-frame.h: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* libunwind-frame.c: Ditto.
	* libunwind-frame.h: Ditto.
	* linespec.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-nat.h: Ditto.
	* linux-thread-db.c: Ditto.
	* machoread.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* memattr.c: Ditto.
	* minsyms.c: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* osabi.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* parse.c: Ditto.
	* printcmd.c: Ditto.
	* proc-events.c: Ditto.
	* procfs.c: Ditto.
	* progspace.c: Ditto.
	* progspace.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote-fileio.c: Ditto.
	* remote.c: Ditto.
	* ser-mingw.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* solib-frv.c: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solib-target.c: Ditto.
	* solib.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.c: Ditto.
	* stack.c: Ditto.
	* stack.h: Ditto.
	* symfile-mem.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target-descriptions.c: Ditto.
	* target-memory.c: Ditto.
	* target.c: Ditto.
	* target.h: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* ui-file.c: Ditto.
	* ui-file.h: Ditto.
	* ui-out.h: Ditto.
	* user-regs.c: Ditto.
	* user-regs.h: Ditto.
	* utils.c: Ditto.
	* valarith.c: Ditto.
	* valops.c: Ditto.
	* valprint.c: Ditto.
	* valprint.h: Ditto.
	* value.c: Ditto.
	* varobj.c: Ditto.
	* varobj.h: Ditto.
	* vec.h: Ditto.
	* xcoffread.c: Ditto.
	* xcoffsolib.c: Ditto.
	* xcoffsolib.h: Ditto.
	* xml-syscall.c: Ditto.
	* xml-tdesc.c: Ditto.
@
text
@d200 1
a200 1
	         being '$'. 
d324 1
a324 1
  /* Process the normal SOM symbol table first. 
d326 2
a327 2
     actually scan the DNTT. It does scan the linker symbol
     table and thus build up a "minimal symbol table". */
d332 1
a332 1
     minimal symbols for this objfile. 
d334 2
a335 2
     in a step known as "psymtab-to-symtab" expansion. hp-symtab-read.c
     contains the code to do the actual DNTT scanning and symtab building. */
d359 1
a359 1
   objfile.  I.E, we are in the process of discarding all symbol information
d361 1
a361 1
   objfile struct from the global list of known objfiles. */
d399 2
a400 2
     .text, .data, etc, but $TEXT$, $DATA$,... We should initialize
     SET_OFF_* from bfd. (See default_symfile_offsets()). But I don't
d402 2
a403 2
     section names. So for now we default to what is was before these
     changes.*/
d415 1
a415 1
         name. */
@


1.48
log
@run copyright.sh for 2011.
@
text
@d433 8
a440 9
  som_new_init,			/* sym_new_init: init anything gbl to entire symtab */
  som_symfile_init,		/* sym_init: read initial info, setup for sym_read() */
  som_symfile_read,		/* sym_read: read a symbol file into symtab */
  som_symfile_finish,		/* sym_finish: finished with file, cleanup */
  som_symfile_offsets,		/* sym_offsets:  Translate ext. to int. relocation */
  default_symfile_segments,	/* sym_segments: Get segment information from
				   a file.  */
  NULL,                         /* sym_read_linetable */
  default_symfile_relocate,	/* sym_relocate: Relocate a debug section.  */
@


1.47
log
@	* symfile.h (struct sym_fns) <next>: Remove.
	(add_symtab_fns): Update.
	* symfile.c (sym_fns_ptr): New typedef.
	(symtab_fns): Now a VEC.
	(add_symtab_fns): Update.  Change argument type.
	(find_sym_fns): Update.  Change return type.
	(get_symfile_segment_data): Update.
	* objfiles.h (struct objfile) <sf>: Now const.
	* somread.c (som_sym_fns): Now const.  Update.
	* xcoffread.c (xcoff_sym_fns): Now const.  Update.
	* mipsread.c (ecoff_sym_fns): Now const.  Update.
	* machoread.c (macho_sym_fns): Now const.  Update.
	* elfread.c (elf_sym_fns): Now const.  Update.
	(elf_sym_fns_gdb_index): Likewise.
	* dbxread.c (aout_sym_fns): Now const.  Update.
	* coffread.c (coff_sym_fns): Now const.  Update.
@
text
@d3 1
a3 1
   2004, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
@


1.46
log
@gdb
	* xcoffread.c: Include psymtab.h.
	(xcoff_sym_fns): Update.
	* symtab.h (struct partial_symbol): Remove.
	(PSYMBOL_DOMAIN, PSYMBOL_CLASS): Remove.
	(struct partial_symtab): Remove.
	(PSYMTAB_TO_SYMTAB): Remove.
	(lookup_partial_symbol, lookup_partial_symtab, find_pc_psymtab)
	(find_pc_sect_psymtab): Remove.
	(find_pc_sect_symtab_via_partial): Declare.
	(find_pc_psymtab, find_pc_sect_psymbol, psymtab_to_symtab)
	(find_main_psymtab): Remove.
	(find_main_filename): Declare.
	(fixup_psymbol_section): Remove.
	(fixup_section): Declare.
	* symtab.c: Include psymtab.h.
	(lookup_symtab): Use lookup_symtab method.
	(lookup_partial_symtab): Remove.
	(find_pc_sect_psymtab_closer): Remove.
	(find_pc_sect_psymtab): Remove.
	(find_pc_sect_symtab_via_partial): New function.
	(find_pc_psymtab, find_pc_sect_psymbol, find_pc_psymbol): Remove.
	(fixup_section): No longer static.
	(fixup_psymbol_section): Remove.
	(lookup_symbol_aux): Use lookup_symbol_aux_quick.
	(lookup_global_symbol_from_objfile): Likewise.
	(lookup_symbol_aux_psymtabs): Remove.
	(lookup_symbol_aux_quick): New function.
	(lookup_symbol_global): Use lookup_symbol_aux_quick.
	(lookup_partial_symbol): Remove.
	(basic_lookup_transparent_type_quick): New function.
	(basic_lookup_transparent_type): Use it.
	(find_main_psymtab): Remove.
	(find_main_filename): New function.
	(find_pc_sect_symtab): Use find_pc_sect_symtab method.
	(find_line_symtab): Use expand_symtabs_with_filename method.
	(output_partial_symbol_filename): New function.
	(sources_info): Use map_partial_symbol_filenames.
	(struct search_symbols_data): New type.
	(search_symbols_file_matches): New function.
	(search_symbols_name_matches): Likewise.
	(search_symbols): Use expand_symtabs_matching method.
	(struct add_name_data): Rename from add_macro_name_data.
	(add_macro_name): Update.
	(add_partial_symbol_name): New function.
	(default_make_symbol_completion_list): Use
	map_partial_symbol_names.
	(struct add_partial_symbol_name): New type.
	(maybe_add_partial_symtab_filename): New function.
	(make_source_files_completion_list): Use
	map_partial_symbol_filenames.
	(expand_line_sal): Use expand_symtabs_with_filename method.
	* symmisc.c: Include psymtab.h.
	(print_objfile_statistics): Use print_stats method.
	(dump_objfile): Use dump method.
	(dump_psymtab, maintenance_print_psymbols)
	(maintenance_info_psymtabs, maintenance_check_symtabs)
	(extend_psymbol_list): Remove.
	* symfile.h (struct quick_symbol_functions): New struct.
	(struct sym_fns) <qf>: New field.
	(sort_pst_symbols): Remove.
	(increment_reading_symtab): Declare.
	* symfile.c: Include psymtab.h.
	(compare_psymbols, sort_pst_symbols): Remove.
	(psymtab_to_symtab): Remove.
	(increment_reading_symtab): New function.
	(symbol_file_add_with_addrs_or_offsets): Use expand_all_symtabs
	method.
	(set_initial_language): Use find_main_filename.
	(allocate_psymtab, discard_psymtab, cashier_psymtab): Remove.
	(free_named_symtabs): Remove unused code.
	(start_psymtab_common, add_psymbol_to_bcache)
	(append_psymbol_to_list, add_psymbol_to_list, init_psymbol_list):
	Remove.
	* stack.c: Include psymtab.h, symfile.h.
	(backtrace_command_1): Use find_pc_sect_symtab_via_partial.
	* source.h (psymtab_to_fullname): Don't declare.
	* source.c: Include psymtab.h.
	(select_source_symtab): Use find_last_source_symtab method.
	(forget_cached_source_info): Use forget_cached_source_info
	method.
	(find_and_open_source): No longer static.
	(psymtab_to_fullname): Remove.
	* somread.c: Include psymtab.h.
	(som_sym_fns): Update.
	* psympriv.h: New file.
	* psymtab.h: New file.
	* psymtab.c: New file.
	* objfiles.h: (ALL_OBJFILE_PSYMTABS): Remove.
	(ALL_PSYMTABS, ALL_PSPACE_PSYMTABS): Likewise.
	* objfiles.c: Include psymtab.h.
	(objfile_relocate1): Use relocate method.
	(objfile_has_partial_symbols): Use has_symbols method.
	* mipsread.c: Include psymtab.h.
	(ecoff_sym_fns): Update.
	* mi/mi-cmd-file.c: Include psymtab.h.
	(print_partial_file_name): New function.
	(mi_cmd_file_list_exec_source_files): Use
	map_partial_symbol_filenames.
	* mdebugread.c: Include psympriv.h.
	* machoread.c: Include psympriv.h.
	(macho_sym_fns): Update.
	* m2-exp.y (yylex): Use lookup_symtab.
	* elfread.c: Include psympriv.h.
	(elf_sym_fns): Update.
	* dwarf2read.c: Include psympriv.h.
	* dbxread.c: Include psympriv.h.
	(aout_sym_fns): Update.
	* cp-support.c: Include psymtab.h.
	(read_in_psymtabs): Remove.
	(make_symbol_overload_list_qualified): Use
	expand_symtabs_for_function method.
	* coffread.c: Include psympriv.h.
	(coff_sym_fns): Update.
	* blockframe.c: Include psymtab.h.
	(find_pc_partial_function): Use find_pc_sect_symtab method.
	* ada-lang.h (ada_update_initial_language): Update.
	* ada-lang.c: Include psymtab.h.
	(ada_update_initial_language): Remove 'main_pst' argument.
	(ada_lookup_partial_symbol): Remove.
	(struct ada_psym_data): New type.
	(ada_add_psyms): New function.
	(ada_add_non_local_symbols): Use map_ada_symtabs method.
	(struct add_partial_datum): New type.
	(ada_add_partial_symbol_completions): New function.
	(ada_make_symbol_completion_list): Use map_partial_symbol_names.
	(ada_exception_support_info_sniffer): Update.
	* Makefile.in (SFILES): Add psymtab.c.
	(COMMON_OBS): Add psymtab.o.
	(HFILES_NO_SRCDIR): Add psymtab.h, psympriv.h.
gdb/doc
	* gdbint.texinfo (Symbol Handling): Update.
@
text
@d430 1
a430 1
static struct sym_fns som_sym_fns =
d442 1
a442 2
  &psym_functions,
  NULL				/* next: pointer to next struct sym_fns */
@


1.45
log
@2010-02-03  Tristan Gingold  <gingold@@adacore.com>

	* symfile.h (struct sym_fns): Add sym_relocate field.
	(default_symfile_relocate): New prototype.
	(symfile_relocate_debug_section): First argument is now an objfile.
	* symfile.c (default_symfile_relocate): Rename from
	symfile_relocate_debug_section, first argument is now an objfile.
	(symfile_relocate_debug_section): New function.
	* coffread.c (coff_sym_fns): Set sym_relocate field.
	* somread.c (som_sym_fns): Ditto.
	* mipsread.c (ecoff_sym_fns): Ditto.
	* machoread.c (macho_sym_fns): Ditto.
	* elfread.c (elf_sym_fns): Ditto.
	* dwarf2read.c (dwarf2_read_section): Ditto.
	* xcoffread.c (xcoff_sym_fns): Ditto.
	* dbxread.c (aout_sym_fns): Ditto.
	(dbx_psymtab_to_symtab): Adjust call to symfile_relocate_debug_section.
	(elfstab_build_psymtabs): Ditto.
@
text
@d35 1
d442 1
@


1.44
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d440 1
@


1.43
log
@2009-12-07  Tristan Gingold  <gingold@@adacore.com>

	* symfile.h (struct sym_fns): Adjust comment on sym_read.
	* symfile.c (syms_from_objfile): Pass all symfile flags to sym_read.
	* dbxread.c (dbx_symfile_read): Rename mainline to symfile_flags,
	adjust header comment.
	* elfread.c (elf_symfile_read): Ditto.
	* somread.c (som_symfile_read): Ditto.
	* xcoffread.c (xcoff_initial_scan): Ditto.
	* coffread.c (coff_symfile_read): Rename mainline to symfile_flags.
	* machoread.c (macho_symfile_read): Ditto.
	* mipsread.c (mipscoff_symfile_read): Ditto.
@
text
@d3 1
a3 1
   2004, 2007, 2008, 2009 Free Software Foundation, Inc.
@


1.42
log
@2009-12-02  Tristan Gingold  <gingold@@adacore.com>

	* dwarf2read.c (dwarf2_build_psymtabs_easy): Remove mainline parameter.
	(dwarf2_build_psymtabs_hard): Ditto.
	(dwarf2_build_psymtabs): Ajust calls.
	* stabsread.h (elfstab_build_psymtabs): Remove mainline parameter on
	the prototype.
	(coffstab_build_psymtabs): Ditto.
	(stabsect_build_psymtabs): Ditto.
	* dbxread.c (coffstab_build_psymtabs): Remove mainline parameter on
	the definition.
	(elfstab_build_psymtabs): Ditto.
	(stabsect_build_psymtabs): Ditto.
	* coffread.c (coff_symfile_read): Adjust call.
	* elfread.c (elf_symfile_read): Ditto.
	* somread.c (som_symfile_read): Ditto.
@
text
@a294 3
   MAINLINE is true if we are reading the main symbol
   table (as opposed to a shared lib or dynamically loaded file).

d315 1
a315 1
som_symfile_read (struct objfile *objfile, int mainline)
@


1.41
log
@        Updated copyright notices for most files.
@
text
@d343 1
a343 1
  stabsect_build_psymtabs (objfile, mainline,
@


1.40
log
@	* objfiles.h (struct objfile): New GDBARCH member.
	(get_objfile_arch): Add prototype.
	* objfiles.c: Include "arch-utils.h".
	(allocate_objfile): Look up gdbarch associated with bfd.
	(get_objfile_arch): New function.
	* Makefile (objfiles.o): Update dependencies.

	* dwarf2-frame.c (decode_frame_entry_1): Replace current_gdbarch
	by objfile arch.
	* dwarf2loc.c (dwarf_expr_read_reg): Replace current_gdbarch
	by frame arch.
	(locexpr_describe_location): Replace current_gdbarch by
	objfile arch.
	* dwarf2read.c (die_type): Replace current_gdbarch by objfile arch.
	(dwarf2_add_field): Likewise.
	(read_tag_pointer_type): Likewise.
	(read_base_type): Likewise.
	(new_symbol): Likewise.

	* coffread.c (decode_type): Add OBJFILE argument.  Update callers.
	(decode_base_type, decode_function_type): Likewise.
	(coff_read_struct_type, coff_read_enum_type): Likewise.
	(coff_symtab_read): Replace current_gdbarch by objfile arch.
	(decode_base_type): Likewise.
	(coff_read_enum_type): Likewise.
	(coff_read_struct_type): Replace current_objfile by OBJFILE argument.
	(coff_read_enum_type): Likewise.

	* dbxread.c (read_dbx_symtab): Replace current_gdbarch by objfile arch.
	(end_psymtab): Likewise.
	(process_one_symbol): Likewise.

	* mdebugread.c (parse_symbol): Replace current_gdbarch by objfile arch.
	(parse_procedure): Likewise.
	(parse_partial_symbols): Likewise.

	* somread.c (som_symtab_read): Replace current_gdbarch by objfile arch.

	* stabsread.c (define_symbol): Replace current_gdbarch by objfile arch.
	Replace static pcc_promotion_type and pcc_unsigned_promotion_type by
	built-in types.
	(read_range_type): Replace current_gdbarch by objfile arch.  Replace
	static range_index_type by built-in type.
	(read_one_struct_field): Replace current_gdbarch by objfile arch.
	(read_enum_type): Likewise.

	* xcoffread.c (read_xcoff_symtab): Replace current_gdbarch by
	objfile arch.
@
text
@d3 1
a3 1
   2004, 2007, 2008 Free Software Foundation, Inc.
@


1.39
log
@	Updated copyright notices for most files.
@
text
@d61 1
d136 1
a136 1
				     (current_gdbarch, bufp->symbol_value);
d150 1
a150 1
				     (current_gdbarch, bufp->symbol_value);
d158 1
a158 1
				     (current_gdbarch, bufp->symbol_value);
d187 1
a187 1
				     (current_gdbarch, bufp->symbol_value);
d219 1
a219 1
				     (current_gdbarch, bufp->symbol_value);
d231 1
a231 1
				     (current_gdbarch, bufp->symbol_value);
d239 1
a239 1
				     (current_gdbarch, bufp->symbol_value);
@


1.38
log
@        * symfile.h (struct sym_fns): Add new field sym_read_linetable.
        * coffread.c, dbxread.c, elfread.c, mipsread.c somread.c:
        Adjust the struct sym_fns object accordingly by setting
        the new field to NULL.
        * xcoffread.c (aix_process_linenos): Make static.
        (xcoff_sym_fns): Set new field to aix_process_linenos.
        * buildsym.c (end_symtab): Replace call to PROCESS_LINENUMBER_HOOK
        by call to new the new sym_fns sym_read_linetable function.
        * config/powerpc/aix.mt (DEPRECATED_TM_FILE): Delete.
        * config/rs6000/tm-rs6000.h: Delete.
@
text
@d3 1
a3 1
   2004, 2007 Free Software Foundation, Inc.
@


1.37
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d441 1
@


1.36
log
@	* coffread.c (coff_sym_fns): Add default_symfile_segments.
	* dbxread.c (start_psymtab): Check HAVE_ELF.
	(aout_sym_fns): Likewise.
	* elfread.c (elf_symfile_segments): New.
	(elf_sym_fns): Add elf_symfile_segments.
	* mipsread.c (ecoff_sym_fns): Add default_symfile_segments.
	* remote.c (get_offsets): Use symfile_map_offsets_to_segments.
	Skip if there is no symfile_objfile.  Handle TextSeg and DataSeg.
	* somread.c (som_sym_fns): Use default_symfile_segments.
	* symfile.c (find_sym_fns): Take a BFD and return the sym_fns.
	(init_objfile_sect_indices): Call symfile_find_segment_sections.
	(default_symfile_segments): New function.
	(syms_from_objfile): Update call to find_sym_fns.
	(symfile_get_segment_data, free_symfile_segment_data): New.
	(symfile_map_offsets_to_segments): New.
	(symfile_find_segment_sections): New.
	* symfile.h (struct symfile_segment_data): New.
	(struct sym_fns): Add sym_segments.
	(default_symfile_segments, symfile_get_segment_data)
	(free_symfile_segment_data): New prototypes.
	(symfile_map_offsets_to_segments): Likewise.
	* xcoffread.c (xcoff_sym_fns): Add default_symfile_segments.
	* Makefile.in (COMMON_OBS): Remove elfread.o.
	(elf_internal_h): New.
	(elfread.o): Update.
	* configure.ac: Add elfread.o to COMMON_OBS if bfd/elf.o was
	compiled.
	* config.in, configure: Regenerated.
	* NEWS: Mention qOffsets changes.

	* gdb.texinfo (General Query Packets): Document qOffsets changes.

	* Makefile.def: Add dependency from configure-gdb to all-bfd.
	* Makefile.in: Regenerated.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d19 1
a19 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.35
log
@2007-06-12  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (SMASH_TEXT_ADDRESS): Replace by
	gdbarch_smash_text_address.
	* somread.c (som_symtab_read): Likewise.
	* elfread.c (record_minimal_symbol): Likewise.
	* dbxread.c (process_one_symbol): Likewise.
	* coffread.c (coff_symtab_read): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d441 2
@


1.34
log
@	* objfiles.h (ImportEntry, ExportEntry): Remove types.
	(struct objfile): Remove import_list, import_list_size,
	export_list, export_list_size members.
	(is_in_import_list): Remove prototype.
	* objfiles.c (is_in_import_list): Remove.
	* somread.c (init_import_symbols, init_export_symbols): Remove.
	(som_symfile_read): Do not call init_import_symbols.  Do not
	set objfile->export_list and objfile->export_list_size.
@
text
@d136 2
a137 1
	      bufp->symbol_value = SMASH_TEXT_ADDRESS (bufp->symbol_value);
d150 2
a151 1
	      bufp->symbol_value = SMASH_TEXT_ADDRESS (bufp->symbol_value);
d158 2
a159 1
	      bufp->symbol_value = SMASH_TEXT_ADDRESS (bufp->symbol_value);
d187 2
a188 1
	      bufp->symbol_value = SMASH_TEXT_ADDRESS (bufp->symbol_value);
d219 2
a220 1
	      bufp->symbol_value = SMASH_TEXT_ADDRESS (bufp->symbol_value);
d231 2
a232 1
	      bufp->symbol_value = SMASH_TEXT_ADDRESS (bufp->symbol_value);
d239 2
a240 1
	      bufp->symbol_value = SMASH_TEXT_ADDRESS (bufp->symbol_value);
@


1.33
log
@	* Makefile.in (SFILES): Remove hpacc-abi.c.
	(COMMON_OBS): Remove hpacc-abi.o.
	(ALLDEPFILES): Remove hpread.c and $(HPREAD_SOURCE).
	(hpacc-abi.o, hpread.o): Delete rules.
	* somread.c: Delete extern declarations from hpread.c.
	(som_symfile_read): Do not call do_pxdb or hpread_build_psymtabs.
	(som_symfile_finish): Do not call hpread_symfile_finish.
	(som_symfile_init): Do not call hpread_symfile_init.
	* config/pa/hppa64.mt (TDEPFILES): Remove hpread.o.
	* config/pa/hppahpux.mt (TDEPFILES): Likewise.
	* hpacc-abi.c, hpread.c: Deleted.

	* gdbint.texinfo (SOM): Correct location of the SOM reader.
@
text
@a39 3
/* Prototypes for local functions.  */
static int init_import_symbols (struct objfile *objfile);

a319 12
  /* Read in the import list and the export list.  Currently
     the export list isn't used; the import list is used in
     hp-symtab-read.c to handle static vars declared in other
     shared libraries. */
  init_import_symbols (objfile);
#if 0				/* Export symbols not used today 1997-08-05 */
  init_export_symbols (objfile);
#else
  objfile->export_list = NULL;
  objfile->export_list_size = 0;
#endif

a420 251

/* Read in and initialize the SOM import list which is present
   for all executables and shared libraries.  The import list
   consists of the symbols that are referenced in OBJFILE but
   not defined there.  (Variables that are imported are dealt
   with as "loc_indirect" vars.)
   Return value = number of import symbols read in. */
static int
init_import_symbols (struct objfile *objfile)
{
  unsigned int import_list;
  unsigned int import_list_size;
  unsigned int string_table;
  unsigned int string_table_size;
  char *string_buffer;
  int i;
  int j;
  int k;
  asection *text_section;	/* section handle */
  unsigned int dl_header[12];	/* SOM executable header */

  /* A struct for an entry in the SOM import list */
  typedef struct
    {
      int name;			/* index into the string table */
      short dont_care1;		/* we don't use this */
      unsigned char type;	/* 0 = NULL, 2 = Data, 3 = Code, 7 = Storage, 13 = Plabel */
      unsigned int reserved2:8;	/* not used */
    }
  SomImportEntry;

  /* We read 100 entries in at a time from the disk file. */
#define SOM_READ_IMPORTS_NUM         100
#define SOM_READ_IMPORTS_CHUNK_SIZE  (sizeof (SomImportEntry) * SOM_READ_IMPORTS_NUM)
  SomImportEntry buffer[SOM_READ_IMPORTS_NUM];

  /* Initialize in case we error out */
  objfile->import_list = NULL;
  objfile->import_list_size = 0;

  /* It doesn't work, for some reason, to read in space $TEXT$;
     the subspace $SHLIB_INFO$ has to be used.  Some BFD quirk? pai/1997-08-05 */
  text_section = bfd_get_section_by_name (objfile->obfd, "$SHLIB_INFO$");
  if (!text_section)
    return 0;
  /* Get the SOM executable header */
  bfd_get_section_contents (objfile->obfd, text_section, dl_header, 0, 12 * sizeof (int));

  /* Check header version number for 10.x HP-UX */
  /* Currently we deal only with 10.x systems; on 9.x the version # is 89060912.
     FIXME: Change for future HP-UX releases and mods to the SOM executable format */
  if (dl_header[0] != 93092112)
    return 0;

  import_list = dl_header[4];
  import_list_size = dl_header[5];
  if (!import_list_size)
    return 0;
  string_table = dl_header[10];
  string_table_size = dl_header[11];
  if (!string_table_size)
    return 0;

  /* Suck in SOM string table */
  string_buffer = (char *) xmalloc (string_table_size);
  bfd_get_section_contents (objfile->obfd, text_section, string_buffer,
			    string_table, string_table_size);

  /* Allocate import list in the psymbol obstack; this has nothing
     to do with psymbols, just a matter of convenience.  We want the
     import list to be freed when the objfile is deallocated */
  objfile->import_list
    = (ImportEntry *) obstack_alloc (&objfile->objfile_obstack,
				   import_list_size * sizeof (ImportEntry));

  /* Read in the import entries, a bunch at a time */
  for (j = 0, k = 0;
       j < (import_list_size / SOM_READ_IMPORTS_NUM);
       j++)
    {
      bfd_get_section_contents (objfile->obfd, text_section, buffer,
			      import_list + j * SOM_READ_IMPORTS_CHUNK_SIZE,
				SOM_READ_IMPORTS_CHUNK_SIZE);
      for (i = 0; i < SOM_READ_IMPORTS_NUM; i++, k++)
	{
	  if (buffer[i].type != (unsigned char) 0)
	    {
	      objfile->import_list[k]
		= (char *) obstack_alloc (&objfile->objfile_obstack, strlen (string_buffer + buffer[i].name) + 1);
	      strcpy (objfile->import_list[k], string_buffer + buffer[i].name);
	      /* Some day we might want to record the type and other information too */
	    }
	  else			/* null type */
	    objfile->import_list[k] = NULL;

	}
    }

  /* Get the leftovers */
  if (k < import_list_size)
    bfd_get_section_contents (objfile->obfd, text_section, buffer,
			      import_list + k * sizeof (SomImportEntry),
			  (import_list_size - k) * sizeof (SomImportEntry));
  for (i = 0; k < import_list_size; i++, k++)
    {
      if (buffer[i].type != (unsigned char) 0)
	{
	  objfile->import_list[k]
	    = (char *) obstack_alloc (&objfile->objfile_obstack, strlen (string_buffer + buffer[i].name) + 1);
	  strcpy (objfile->import_list[k], string_buffer + buffer[i].name);
	  /* Some day we might want to record the type and other information too */
	}
      else
	objfile->import_list[k] = NULL;
    }

  objfile->import_list_size = import_list_size;
  xfree (string_buffer);
  return import_list_size;
}

/* Read in and initialize the SOM export list which is present
   for all executables and shared libraries.  The import list
   consists of the symbols that are referenced in OBJFILE but
   not defined there.  (Variables that are imported are dealt
   with as "loc_indirect" vars.)
   Return value = number of import symbols read in. */
int
init_export_symbols (struct objfile *objfile)
{
  unsigned int export_list;
  unsigned int export_list_size;
  unsigned int string_table;
  unsigned int string_table_size;
  char *string_buffer;
  int i;
  int j;
  int k;
  asection *text_section;	/* section handle */
  unsigned int dl_header[12];	/* SOM executable header */

  /* A struct for an entry in the SOM export list */
  typedef struct
    {
      int next;			/* for hash table use -- we don't use this */
      int name;			/* index into string table */
      int value;		/* offset or plabel */
      int dont_care1;		/* not used */
      unsigned char type;	/* 0 = NULL, 2 = Data, 3 = Code, 7 = Storage, 13 = Plabel */
      char dont_care2;		/* not used */
      short dont_care3;		/* not used */
    }
  SomExportEntry;

  /* We read 100 entries in at a time from the disk file. */
#define SOM_READ_EXPORTS_NUM         100
#define SOM_READ_EXPORTS_CHUNK_SIZE  (sizeof (SomExportEntry) * SOM_READ_EXPORTS_NUM)
  SomExportEntry buffer[SOM_READ_EXPORTS_NUM];

  /* Initialize in case we error out */
  objfile->export_list = NULL;
  objfile->export_list_size = 0;

  /* It doesn't work, for some reason, to read in space $TEXT$;
     the subspace $SHLIB_INFO$ has to be used.  Some BFD quirk? pai/1997-08-05 */
  text_section = bfd_get_section_by_name (objfile->obfd, "$SHLIB_INFO$");
  if (!text_section)
    return 0;
  /* Get the SOM executable header */
  bfd_get_section_contents (objfile->obfd, text_section, dl_header, 0, 12 * sizeof (int));

  /* Check header version number for 10.x HP-UX */
  /* Currently we deal only with 10.x systems; on 9.x the version # is 89060912.
     FIXME: Change for future HP-UX releases and mods to the SOM executable format */
  if (dl_header[0] != 93092112)
    return 0;

  export_list = dl_header[8];
  export_list_size = dl_header[9];
  if (!export_list_size)
    return 0;
  string_table = dl_header[10];
  string_table_size = dl_header[11];
  if (!string_table_size)
    return 0;

  /* Suck in SOM string table */
  string_buffer = (char *) xmalloc (string_table_size);
  bfd_get_section_contents (objfile->obfd, text_section, string_buffer,
			    string_table, string_table_size);

  /* Allocate export list in the psymbol obstack; this has nothing
     to do with psymbols, just a matter of convenience.  We want the
     export list to be freed when the objfile is deallocated */
  objfile->export_list
    = (ExportEntry *) obstack_alloc (&objfile->objfile_obstack,
				   export_list_size * sizeof (ExportEntry));

  /* Read in the export entries, a bunch at a time */
  for (j = 0, k = 0;
       j < (export_list_size / SOM_READ_EXPORTS_NUM);
       j++)
    {
      bfd_get_section_contents (objfile->obfd, text_section, buffer,
			      export_list + j * SOM_READ_EXPORTS_CHUNK_SIZE,
				SOM_READ_EXPORTS_CHUNK_SIZE);
      for (i = 0; i < SOM_READ_EXPORTS_NUM; i++, k++)
	{
	  if (buffer[i].type != (unsigned char) 0)
	    {
	      objfile->export_list[k].name
		= (char *) obstack_alloc (&objfile->objfile_obstack, strlen (string_buffer + buffer[i].name) + 1);
	      strcpy (objfile->export_list[k].name, string_buffer + buffer[i].name);
	      objfile->export_list[k].address = buffer[i].value;
	      /* Some day we might want to record the type and other information too */
	    }
	  else
	    /* null type */
	    {
	      objfile->export_list[k].name = NULL;
	      objfile->export_list[k].address = 0;
	    }
	}
    }

  /* Get the leftovers */
  if (k < export_list_size)
    bfd_get_section_contents (objfile->obfd, text_section, buffer,
			      export_list + k * sizeof (SomExportEntry),
			  (export_list_size - k) * sizeof (SomExportEntry));
  for (i = 0; k < export_list_size; i++, k++)
    {
      if (buffer[i].type != (unsigned char) 0)
	{
	  objfile->export_list[k].name
	    = (char *) obstack_alloc (&objfile->objfile_obstack, strlen (string_buffer + buffer[i].name) + 1);
	  strcpy (objfile->export_list[k].name, string_buffer + buffer[i].name);
	  /* Some day we might want to record the type and other information too */
	  objfile->export_list[k].address = buffer[i].value;
	}
      else
	{
	  objfile->export_list[k].name = NULL;
	  objfile->export_list[k].address = 0;
	}
    }

  objfile->export_list_size = export_list_size;
  xfree (string_buffer);
  return export_list_size;
}
@


1.32
log
@Copyright updates for 2007.
@
text
@a42 10
/* FIXME: These should really be in a common header somewhere */

extern void hpread_build_psymtabs (struct objfile *, int);

extern void hpread_symfile_finish (struct objfile *);

extern void hpread_symfile_init (struct objfile *);

extern void do_pxdb (bfd *);

a319 2
  do_pxdb (symfile_bfd_open (objfile->name));

a353 6

  /* Now read the native debug information. 
     This builds the psymtab. This used to be done via a scan of
     the DNTT, but is now done via the PXDB-built quick-lookup tables
     together with a scan of the GNTT. See hp-psymtab-read.c. */
  hpread_build_psymtabs (objfile, mainline);
a380 1
  hpread_symfile_finish (objfile);
a391 1
  hpread_symfile_init (objfile);
@


1.31
log
@        * somread.c (som_symtab_read): Avoid using alloca for potentially
        large buffers.
@
text
@d3 1
a3 1
   2004 Free Software Foundation, Inc.
@


1.30
log
@2006-03-01  Randolph Chung  <tausq@@debian.org>

	* somread.c (som_symfile_read): Update comment and remove unneeded
	use of a deprecated variable.
@
text
@d91 5
a95 2
  /* FIXME (alloca): could be quite large. */
  buf = alloca (symsize * number_of_symbols);
d101 6
a106 2
  /* FIXME (alloca): could be quite large. */
  stringtab = alloca (obj_som_stringtab_size (abfd));
@


1.29
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d356 1
a356 3
     This is a no-op for SOM.
     Perhaps it is intended for some kind of mixed STABS/SOM
     situation? */
a364 3

  /* Force hppa-tdep.c to re-read the unwind descriptors.  */
  objfile->deprecated_obj_private = NULL;
@


1.28
log
@2005-12-08  Randolph Chung  <tausq@@debian.org>

	* somread.c (som_symfile_offsets): Iterate through number of sections
	in addrs instead of objfile.
@
text
@d2 1
a2 1
   Copyright 1991, 1992, 1994, 1995, 1996, 1998, 1999, 2000, 2001, 2002,
d20 2
a21 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.27
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d445 1
a445 1
      for (i = 0; i < objfile->num_sections && addrs->other[i].name; i++)
@


1.26
log
@* somread.c: Include "solib-som.h".
(som_symfile_init, som_new_init, som_symfile_read,
som_symfile_finish, som_symtab_read, som_symfile_offsets): Remove
redudant prototypes.
* Makefile.in (somread.o): Update dependencies.
@
text
@d96 1
a96 1
    error ("Couldn't read symbol dictionary!");
d103 1
a103 1
    error ("Can't read in HP string table.");
d280 1
a280 1
	error ("Invalid symbol data; bad HP string table offset: %d",
@


1.25
log
@2004-10-23  Andrew Cagney  <cagney@@gnu.org>

	* objfiles.h (struct objfile): Rename obj_private to
	deprecated_obj_private, sym_private to deprecated_sym_private, and
	sym_stab_info to deprecated_sym_stab_info.
	* gdb-stabs.h: Update.
	* elfread.c: Update.
	* dbxread.c: Update.
	* coffread.c: Update.
	* xcoffread.c: Update.
	* symfile.c: Update.
	* somread.c: Update.
	* nlmread.c: Update.
	* mdebugread.c: Update.
	* hpread.c: Update.
	* coffread.c: Update.
@
text
@d38 1
a38 1
/* Various things we might complain about... */
d40 1
a42 13
static void som_symfile_init (struct objfile *);

static void som_new_init (struct objfile *);

static void som_symfile_read (struct objfile *, int);

static void som_symfile_finish (struct objfile *);

static void som_symtab_read (bfd *, struct objfile *,
			     struct section_offsets *);

static void som_symfile_offsets (struct objfile *, struct section_addr_info *);

@


1.24
log
@2004-08-10  Andrew Cagney  <cagney@@gnu.org>

	* defs.h (xmfree): Delete.
	* utils.c (xmfree): Delete function.
	(xfree): Inline calls to xmfree and mfree.
	* symmisc.c (free_symtab_block, free_symtab): Use xfree.
	* symfile.c (reread_symbols, init_psymbol_list): Ditto.
	* source.c (forget_cached_source_info, find_and_open_source): Ditto.
	* somread.c (som_symfile_finish): Ditto.
	* objfiles.c (allocate_objfile, free_objfile):
	* nlmread.c (nlm_symfile_finish): Ditto.
	* hpread.c (hpread_symfile_finish): Ditto.
	* elfread.c (free_elfinfo, elf_symfile_finish): Ditto.
	* dbxread.c (dbx_symfile_finish, free_bincl_list): Ditto.
	* coffread.c (coff_symfile_finish): Ditto.
@
text
@d381 1
a381 1
  objfile->obj_private = NULL;
d405 1
a405 1
  if (objfile->sym_stab_info != NULL)
d407 1
a407 1
      xfree (objfile->sym_stab_info);
@


1.23
log
@2004-06-11  Randolph Chung  <tausq@@debian.org>

	* somread.c (som_symtab_read): Exclude gcc local symbols.
@
text
@d407 1
a407 1
      xmfree (objfile->md, objfile->sym_stab_info);
@


1.22
log
@2004-02-07  Elena Zannoni  <ezannoni@@redhat.com>

	* dbxread.c (dbx_symfile_init, start_psymtab, end_psymtab,
	coffstab_build_psymtabs, elfstab_build_psymtabs)
	(stabsect_build_psymtabs): Replace psymbol_obstack with
	objfile_obstack.
	* dwarf2-frame.c (decode_frame_entry_1): Ditto.
	* dwarf2read.c (dwarf2_build_psymtabs_hard, dwarf2_read_section):
	Ditto.
	* dwarfread.c (scan_compilation_units): Ditto.
	* elfread.c (elfstab_offset_sections): Ditto.
	* hppa-tdep.c (read_unwind_info): Ditto.
	* hpread.c (hpread_build_psymtabs, hpread_start_psymtab)
	(hpread_end_psymtab): Ditto.
	* mdebugread.c (mdebug_build_psymtabs, add_pending)
	(parse_partial_symbols, new_psymtab, elfmdebug_build_psymtabs):
	Ditto.
	* mips-tdep.c (non_heuristic_proc_desc): Ditto.
	* objfiles.c (add_to_objfile_sections)
	(build_objfile_section_table): Ditto.
	(allocate_objfile): Remove init of psymbol_obstack.
	(free_objfile): Remove freeing of psymbol_obstack.
	* objfiles.h (struct objfile): Remove field
	psymbol_obstack. Update comments.
	* pa64solib.c (pa64_solib_add_solib_objfile): Replace
	psymbol_obstack with objfile_obstack.
	* solib-sunos.c (allocate_rt_common_objfile): Remove init of
        psymbol_obstack.
	* somread.c (som_symfile_offsets, init_import_symbols)
	(init_export_symbols): Replace psymbol_obstack with
	objfile_obstack.
	* somsolib.c (som_solib_add_solib_objfile): Ditto.
	* symfile.c (default_symfile_offsets, syms_from_objfile)
	(reread_symbols): Remove freeing and init of psymbol_obstack.
	(cashier_psymtab): Update comment.
	* symmisc.c (print_objfile_statistics): Don't report stats for
	psymbol obstack.
	* symtab.h (struct general_symbol_info, struct partial_symtab):
	Update comments.
	* xcoffread.c (xcoff_start_psymtab, xcoff_end_psymtab, swap_sym)
	(xcoff_symfile_offsets): Replace psymbol_obstack with
	objfile_obstack.
@
text
@d222 1
@


1.22.4.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@a221 1
		  || (strncmp (symname, "L0\001", 3) == 0)
d406 1
a406 1
      xfree (objfile->sym_stab_info);
@


1.21
log
@2003-09-14  Andrew Cagney  <cagney@@redhat.com>

	* alpha-nat.c: Remove some occurances of "register".
	* alpha-tdep.c, arm-tdep.c, blockframe.c, breakpoint.c: Ditto.
	* buildsym.c, c-typeprint.c, c-valprint.c, coffread.c: Ditto.
	* corefile.c, cp-support.c, cp-valprint.c, cris-tdep.c: Ditto.
	* dbxread.c, dcache.c, dwarf2read.c, elfread.c: Ditto.
	* environ.c, eval.c, event-top.c, f-typeprint.c: Ditto.
	* f-valprint.c, findvar.c, frame.c, gdbtypes.c: Ditto.
	* h8300-tdep.c, hppa-tdep.c, hppab-nat.c, hppah-nat.c: Ditto.
	* hppam3-nat.c, hpread.c, ia64-aix-nat.c, ia64-linux-nat.c: Ditto.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Ditto.
	* infttrace.c, irix5-nat.c, jv-typeprint.c: Ditto.
	* jv-valprint.c, m68k-tdep.c, m68klinux-nat.c, main.c: Ditto.
	* mdebugread.c, minsyms.c, mips-linux-tdep.c: Ditto.
	* mips-nat.c, mips-tdep.c, mipsread.c, mipsv4-nat.c: Ditto.
	* ns32k-tdep.c, objfiles.c, p-typeprint.c: Ditto.
	* p-valprint.c, ppc-linux-nat.c, printcmd.c: Ditto.
	* remote-mips.c, remote-vx.c, rs6000-nat.c: Ditto.
	* rs6000-tdep.c, scm-exp.c, sh-tdep.c, sh64-tdep.c: Ditto.
	* solib.c, somread.c, source.c, sparc-tdep.c: Ditto.
	* stabsread.c, stack.c, standalone.c, symfile.c: Ditto.
	* symmisc.c, symtab.c, top.c, tracepoint.c: Ditto.
	* typeprint.c, utils.c, valarith.c, valops.c: Ditto.
	* values.c, vax-tdep.c, xcoffread.c: Ditto.
@
text
@d2 2
a3 2
   Copyright 1991, 1992, 1994, 1995, 1996, 1998, 1999, 2000, 2001, 2002
   Free Software Foundation, Inc.
d435 1
a435 1
    obstack_alloc (&objfile->psymbol_obstack, 
d537 1
a537 1
    = (ImportEntry *) obstack_alloc (&objfile->psymbol_obstack,
d553 1
a553 1
		= (char *) obstack_alloc (&objfile->psymbol_obstack, strlen (string_buffer + buffer[i].name) + 1);
d573 1
a573 1
	    = (char *) obstack_alloc (&objfile->psymbol_obstack, strlen (string_buffer + buffer[i].name) + 1);
d660 1
a660 1
    = (ExportEntry *) obstack_alloc (&objfile->psymbol_obstack,
d676 1
a676 1
		= (char *) obstack_alloc (&objfile->psymbol_obstack, strlen (string_buffer + buffer[i].name) + 1);
d700 1
a700 1
	    = (char *) obstack_alloc (&objfile->psymbol_obstack, strlen (string_buffer + buffer[i].name) + 1);
@


1.20
log
@       * somread.c (som_symfile_offsets): Fix compilation error.
@
text
@d480 3
a482 3
  register int i;
  register int j;
  register int k;
d600 3
a602 3
  register int i;
  register int j;
  register int k;
@


1.19
log
@	* elfread.c (elf_symtab_read): Avoid use of SECT_OFF_MAX.
	(elfstab_offset_sections): Likewise.
	* gdb-stabs.h (stab_section_info): Likewise.
	* i386-interix-tdep.c (pei_adjust_objfile_offsets): Likewise.
	* objfiles.c (objfile_relocate): Likewise.
	* pa64solib.c (pa64_solib_add_solib_objfile): Likewise.
	* remote.c (get_offsets): Likewise.
	(remote_cisco_objfile_relocate): Likewise.
	* somread.c (som_symfile_offsets): Likewise.
	* symfile.c (alloc_section_addr_info): New function.
	(build_section_addr_info_from_section_tab): Use it.
	(free_section_addr_info): Adjust.
	(default_symfile_offsets): Avoid use of SECT_OFF_MAX.
	(syms_from_objfile): Allocate local_addr dynamically.
	(symbol_file_add_with_addrs_or_offsets): Allocate orig_addrs
	dynamically.
	(add_symbol_file_command): Allocate sect_opts dynamically.
	(reread_symbols): Avoid use of SECT_OFF_MAX.
	* symfile.h (section_addr_info): Do not use MAX_SECTIONS.
	(alloc_section_addr_info): Declare it.
	* symtab.h (SIZEOF_SECTION_OFFSETS): Remove.
	* win32-nat.c (solib_symbols_add): Allocate section_addrs
	dynamically.
	* xcoffread.c (xcoff_symfile_offsets): Avoid use of SECT_OFF_MAX.
@
text
@d456 1
a456 1
      for (i = 0; i < SECT_OFF_MAX && addrs->other[i].name; i++)
@


1.19.4.1
log
@        * somread.c (som_symfile_offsets): Fix compilation error.
@
text
@d456 1
a456 1
      for (i = 0; i < objfile->num_sections && addrs->other[i].name; i++)
@


1.18
log
@2003-03-29  Andrew Cagney  <cagney@@redhat.com>

	* infttrace.h: New file.
	* hpread.c: Include "gdb_assert.h" and "somsolib.h".
	(hpread_get_textlow): Detect an uninitialized dn_bufp.
	(hpread_read_doc_function_type): Detect an initialized type1.
	(hpread_quick_traverse): Initialize mod_name_string.
	* somsolib.h: Add #ifdef SOMSOLIB_H wrapper.
	(som_solib_get_solib_by_pc): Declare.
	(so_lib_thread_start_addr): Declare.
	(no_shared_libraries): Declare.
	* somread.c (init_import_symbols): Make static.  Add forward
	declaration.
	* config/pa/nm-hppah.h: Include "infttrace.h" for
	parent_attach_all.
	(hppa_insert_hw_watchpoint): Declare.
	(hppa_can_use_hw_watchpoint, hppa_remove_hw_watchpoint): Declare.
	* hppah-nat.c: Include "gdb_string.h".
	(parent_attach_all): Delete extern declaration, moved to
	"infttrace.h".
	(hppa_can_use_hw_watchpoint): Change type of "type" parameter to
	int.
	(hppa_remove_hw_watchpoint, hppa_insert_hw_watchpoint): Ditto.
	* Makefile.in (infttrace_h): Define.
	(hpread.o): Update dependencies.
	(hppah-nat.o, hppa-hpux-tdep.o, hppa-tdep.o): Ditto.
	* hppa-hpux-tdep.c: Include "gdb_string.h".
	* hppa-tdep.c (hppa_frame_saved_pc): Initialize "old_pc".
	* infrun.c (handle_inferior_event): Always initialize
	stepped_after_stopped_by_watchpoint.  Add default and remove
	fallthrough in switch statement.
	* infttrace.c (hppa_can_use_hw_watchpoint): Change type of "type"
	parameter to int.
	(hppa_remove_hw_watchpoint): Ditto.
@
text
@d433 1
a433 1
  objfile->num_sections = SECT_OFF_MAX;
d435 2
a436 1
    obstack_alloc (&objfile->psymbol_obstack, SIZEOF_SECTION_OFFSETS);
d461 1
a461 1
      for (i = 0; i < SECT_OFF_MAX; i++)
@


1.17
log
@	* coffread.c (coff_symfile_read): Clean up minimal symbols earlier.
	* dbxread.c (elfstab_build_psymtabs): Don't call
	install_minimal_symbols.
	(stabsect_build_psymtabs): Likewise.
	* elfread.c (elf_symfile_read): Call install_minimal_symbols
	earlier.
	* somread.c (som_symfile_read): Call install_minimal_symbols
	and do_cleanups earlier.
	* nlmread.c (nlm_symfile_read): Likewise.
	* mdebugread.c (elfmdebug_build_psymtabs): Call
	install_minimal_symbols and make appropriate cleanups.
@
text
@d40 2
d471 1
a471 1
int
@


1.17.10.1
log
@Merge with mainline.
@
text
@a39 2
static int init_import_symbols (struct objfile *objfile);

d469 1
a469 1
static int
@


1.16
log
@2003-01-18  Andrew Cagney  <ac131313@@redhat.com>

	* cris-tdep.c: Fix function declaration indentation.
	* dwarfread.c, gdbcore.h, gdbtypes.h, i386v-nat.c: Ditto.
	* mips-tdep.c, monitor.h, parse.c, proc-utils.h: Ditto.
	* rs6000-nat.c, ser-go32.c, somread.c, stabsread.c: Ditto.
	* symfile.h, symtab.h, target.c, target.h, value.h: Ditto.
	* xcoffread.c, config/pa/tm-hppa.h: Ditto.
	* config/sparc/tm-sp64.h, config/sparc/tm-sparc.h: Ditto.
@
text
@d356 8
a376 7
  /* Install any minimal symbols that have been collected as the current
     minimal symbols for this objfile. 
     Further symbol-reading is done incrementally, file-by-file,
     in a step known as "psymtab-to-symtab" expansion. hp-symtab-read.c
     contains the code to do the actual DNTT scanning and symtab building. */
  install_minimal_symbols (objfile);

a378 1
  do_cleanups (back_to);
@


1.15
log
@        * somread.c (som_symtab_read): Remove some commented out code and
        updated related comments.  Do not set the minimal symbol table to
        mst_solib_trampoline for ST_ENTRY symbols with SS_LOCAL scope
        in a dynamic executable.
        * hppa-tdep.c (find_proc_framesize): Sanely handle the case
        where we are unable to find the minimal symbol for the given
        PC value.
@
text
@d48 2
a49 2
static void
som_symtab_read (bfd *, struct objfile *, struct section_offsets *);
d51 1
a51 2
static void
som_symfile_offsets (struct objfile *, struct section_addr_info *);
@


1.15.16.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@a39 2
static int init_import_symbols (struct objfile *objfile);

d48 2
a49 2
static void som_symtab_read (bfd *, struct objfile *,
			     struct section_offsets *);
d51 2
a52 1
static void som_symfile_offsets (struct objfile *, struct section_addr_info *);
a356 8
  /* Install any minimal symbols that have been collected as the current
     minimal symbols for this objfile. 
     Further symbol-reading is done incrementally, file-by-file,
     in a step known as "psymtab-to-symtab" expansion. hp-symtab-read.c
     contains the code to do the actual DNTT scanning and symtab building. */
  install_minimal_symbols (objfile);
  do_cleanups (back_to);

d370 7
d379 1
d432 1
a432 1
  objfile->num_sections = bfd_count_sections (objfile->obfd);
d434 1
a434 2
    obstack_alloc (&objfile->psymbol_obstack, 
		   SIZEOF_N_SECTION_OFFSETS (objfile->num_sections));
d454 1
a454 1
      for (i = 0; i < objfile->num_sections && addrs->other[i].name; i++)
d459 1
a459 1
      for (i = 0; i < objfile->num_sections; i++)
d470 1
a470 1
static int
d478 3
a480 3
  int i;
  int j;
  int k;
d598 3
a600 3
  int i;
  int j;
  int k;
@


1.15.16.2
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d2 2
a3 2
   Copyright 1991, 1992, 1994, 1995, 1996, 1998, 1999, 2000, 2001, 2002,
   2004 Free Software Foundation, Inc.
d435 1
a435 1
    obstack_alloc (&objfile->objfile_obstack, 
d537 1
a537 1
    = (ImportEntry *) obstack_alloc (&objfile->objfile_obstack,
d553 1
a553 1
		= (char *) obstack_alloc (&objfile->objfile_obstack, strlen (string_buffer + buffer[i].name) + 1);
d573 1
a573 1
	    = (char *) obstack_alloc (&objfile->objfile_obstack, strlen (string_buffer + buffer[i].name) + 1);
d660 1
a660 1
    = (ExportEntry *) obstack_alloc (&objfile->objfile_obstack,
d676 1
a676 1
		= (char *) obstack_alloc (&objfile->objfile_obstack, strlen (string_buffer + buffer[i].name) + 1);
d700 1
a700 1
	    = (char *) obstack_alloc (&objfile->objfile_obstack, strlen (string_buffer + buffer[i].name) + 1);
@


1.15.14.1
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d48 2
a49 2
static void som_symtab_read (bfd *, struct objfile *,
			     struct section_offsets *);
d51 2
a52 1
static void som_symfile_offsets (struct objfile *, struct section_addr_info *);
@


1.15.14.2
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@a355 8
  /* Install any minimal symbols that have been collected as the current
     minimal symbols for this objfile. 
     Further symbol-reading is done incrementally, file-by-file,
     in a step known as "psymtab-to-symtab" expansion. hp-symtab-read.c
     contains the code to do the actual DNTT scanning and symtab building. */
  install_minimal_symbols (objfile);
  do_cleanups (back_to);

d369 7
d378 1
@


1.15.14.3
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@a39 2
static int init_import_symbols (struct objfile *objfile);

d469 1
a469 1
static int
@


1.15.14.4
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d433 1
a433 1
  objfile->num_sections = bfd_count_sections (objfile->obfd);
d435 1
a435 2
    obstack_alloc (&objfile->psymbol_obstack, 
		   SIZEOF_N_SECTION_OFFSETS (objfile->num_sections));
d460 1
a460 1
      for (i = 0; i < objfile->num_sections; i++)
@


1.15.14.5
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@d456 1
a456 1
      for (i = 0; i < objfile->num_sections && addrs->other[i].name; i++)
@


1.15.14.6
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d480 3
a482 3
  int i;
  int j;
  int k;
d600 3
a602 3
  int i;
  int j;
  int k;
@


1.14
log
@* gdbarch.sh (copyright): Update years in generated header.
(SMASH_TEXT_ADDRESS): Add rule.
*gdbarch.h, gdbarch.c: Re-generate.
* coffread.c: Multi-arch uses of SMASH_TEXT_ADDRESS.
* dbxread.c: Likewise.
* dwarfread.c: Likewise.
* elfread.c: Likewise.
* somread.c: Likewise.

* arm-tdep.c (arm_smash_text_address): New function.
* config/arm/tm-arm.h (SMASH_TEXT_ADDRESS): Define in terms of above.
@
text
@d120 7
a126 14
     this.  The only reliable way I know of is to check for the
     existence of a $SHLIB_INFO$ section with a non-zero size.  */
  /* The code below is not a reliable way to check whether an
   * executable is dynamic, so I commented it out - RT
   * shlib_info = bfd_get_section_by_name (objfile->obfd, "$SHLIB_INFO$");
   * if (shlib_info)
   *   dynamic = (bfd_section_size (objfile->obfd, shlib_info) != 0);
   * else
   *   dynamic = 0;
   */
  /* I replaced the code with a simple check for text offset not being
   * zero. Still not 100% reliable, but a more reliable way of asking
   * "is this a dynamic executable?" than the above. RT
   */
d236 5
a240 7
	      /* For a dynamic executable, ST_ENTRY symbols are
	         the stubs, while the ST_CODE symbol is the real
	         function.  */
	      if (dynamic)
		ms_type = mst_solib_trampoline;
	      else
		ms_type = mst_file_text;
@


1.13
log
@2002-01-07  Michael Snyder  <msnyder@@redhat.com>

	* cp-valprint.c (cp_print_value): FIXME comment, alloca size.
	* p-valprint.c (pascal_object_print_value): Ditto.
	* somread.c (som_symtab_read): Ditto.
	* symfile.c (simple_free_overlay_region_table): Ditto.
	* valops.c (value_assign): Ditto.
@
text
@d2 1
a2 1
   Copyright 1991, 1992, 1994, 1995, 1996, 1998, 1999, 2000, 2001
d160 1
a160 3
#ifdef SMASH_TEXT_ADDRESS
	      SMASH_TEXT_ADDRESS (bufp->symbol_value);
#endif
d173 1
a173 3
#ifdef SMASH_TEXT_ADDRESS
	      SMASH_TEXT_ADDRESS (bufp->symbol_value);
#endif
d180 1
a180 3
#ifdef SMASH_TEXT_ADDRESS
	      SMASH_TEXT_ADDRESS (bufp->symbol_value);
#endif
d208 1
a208 3
#ifdef SMASH_TEXT_ADDRESS
	      SMASH_TEXT_ADDRESS (bufp->symbol_value);
#endif
d238 1
a238 3
#ifdef SMASH_TEXT_ADDRESS
	      SMASH_TEXT_ADDRESS (bufp->symbol_value);
#endif
d251 1
a251 3
#ifdef SMASH_TEXT_ADDRESS
	      SMASH_TEXT_ADDRESS (bufp->symbol_value);
#endif
d258 1
a258 3
#ifdef SMASH_TEXT_ADDRESS
	      SMASH_TEXT_ADDRESS (bufp->symbol_value);
#endif
@


1.12
log
@mfree() -> xmfree().
@
text
@d102 1
d109 1
@


1.11
log
@	* coffread.c: Replace all occurrences of bfd_read with bfd_bread.
	* dbxread.c: Likewise.
	* dwarf2read.c: Likewise.
	* dwarfread.c: Likewise.
	* somread.c: Likewise.
	* ultra3-nat.c: Likewise.
	* xcoffread.c: Likewise.
@
text
@d426 1
a426 1
      mfree (objfile->md, objfile->sym_stab_info);
@


1.10
log
@Update/correct copyright notices.
@
text
@d2 1
a2 1
   Copyright 1991, 1992, 1994, 1995, 1996, 1998, 1999, 2000
d104 1
a104 1
  val = bfd_read (buf, symsize * number_of_symbols, 1, abfd);
d110 1
a110 1
  val = bfd_read (stringtab, obj_som_stringtab_size (abfd), 1, abfd);
@


1.9
log
@Replace free() with xfree().
@
text
@d2 2
a3 1
   Copyright 1991, 1992, 1996, 1999 Free Software Foundation, Inc.
@


1.8
log
@* gdbarch.sh, hp-psymtab-read.c, hpread.c, m3-nat.c, mcore-tdep.c,
mips-tdep.c, monitor.c, regcache.c, remote-es.c, ser-unix.c,
somread.c, tracepoint.c: Fix spelling errors in comments.
* gdbarch.c: Regenerate.

* gnu-nat.c (S_exception_raise_request): Fix typos and spelling
errors in strings.
* m3-nat.c (intercept_exec_calls, mach_thread_parse_id): Likewise.
* mcore-tdep.c (mcore_analyze_prologue): Likewise.
* mips-tdep.c (mips16_next_pc, _initialize_mips_tdep): Likewise.
* remote-e7000.c (e7000_start_remote): Likewise.
* remote-rdp.c (handle_swi): Likewise.
* remote-vx.c (vx_load_command): Likewise.
* sh-tdep.c (sh_do_pseudo_register): Likewise.
* sol-thread.c (td_err_string): Likewise.
* symtab.c (decode_line_2): Likewise.
-------------------------------------------------------------------
@
text
@d600 1
a600 1
  free (string_buffer);
d731 1
a731 1
  free (string_buffer);
@


1.7
log
@2000-08-27  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

	* pa64solib.c (pa64_solib_load_symbols): Don't use ANOFFSET as an
 	lvalue.
	* xcoffread.c (xcoff_symfile_offsets): Ditto
	* somsolib.c (som_solib_section_offsets): Ditto.
	* somread.c (som_symfile_offsets): Ditto.
	* rs6000-nat.c (vmap_symtab): Ditto.
	* remote-vx.c (vx_add_symbols): Ditto.
	* remote-os9k.c (rombug_wait): Ditto.
@
text
@d118 1
a118 1
     existance of a $SHLIB_INFO$ section with a non-zero size.  */
@


1.6
log
@Protoization.
@
text
@d480 1
a480 1
	ANOFFSET (objfile->section_offsets, i) = text_addr;
@


1.5
log
@PARAMS removal.
@
text
@d83 2
a84 4
som_symtab_read (abfd, objfile, section_offsets)
     bfd *abfd;
     struct objfile *objfile;
     struct section_offsets *section_offsets;
d348 1
a348 3
som_symfile_read (objfile, mainline)
     struct objfile *objfile;
     int mainline;
d409 1
a409 2
som_new_init (ignore)
     struct objfile *ignore;
d421 1
a421 2
som_symfile_finish (objfile)
     struct objfile *objfile;
d433 1
a433 2
som_symfile_init (objfile)
     struct objfile *objfile;
d447 1
a447 3
som_symfile_offsets (objfile, addrs)
     struct objfile *objfile;
     struct section_addr_info *addrs;
d491 1
a491 2
init_import_symbols (objfile)
     struct objfile *objfile;
d611 1
a611 2
init_export_symbols (objfile)
     struct objfile *objfile;
d751 1
a751 1
_initialize_somread ()
@


1.4
log
@Cleanup discard_minimal_symbols cleanup.
@
text
@d39 1
a39 2
static void
som_symfile_init PARAMS ((struct objfile *));
d41 1
a41 2
static void
som_new_init PARAMS ((struct objfile *));
d43 1
a43 2
static void
som_symfile_read PARAMS ((struct objfile *, int));
d45 1
a45 2
static void
som_symfile_finish PARAMS ((struct objfile *));
d48 1
a48 2
som_symtab_read PARAMS ((bfd *, struct objfile *,
			 struct section_offsets *));
d51 1
a51 1
som_symfile_offsets PARAMS ((struct objfile *, struct section_addr_info *));
d55 1
a55 2
extern void
hpread_build_psymtabs PARAMS ((struct objfile *, int));
d57 1
a57 2
extern void
hpread_symfile_finish PARAMS ((struct objfile *));
d59 1
a59 2
extern void
hpread_symfile_init PARAMS ((struct objfile *));
d61 1
a61 2
extern void
do_pxdb PARAMS ((bfd *));
@


1.3
log
@Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * objfiles.h (SECT_OFF_DATA, SECT_OFF_TEXT, SECT_OFF_BSS,
        SECT_OFF_RODATA): Define as functions of OBJFILE.  Add
        sect_index_text, sect_index_data, sect_index_rodata,
        sect_index_bss to objfile structure.
        * gdb-stabs.h (SECT_OFF_DATA, SECT_OFF_TEXT, SECT_OFF_BSS,
        SECT_OFF_RODATA): Remove.
        * objfiles.c (allocate_objfile): Initialize
        sect_index_{text,data,bss,rodata} to -1, for error detection.

        * symfile.c (default_symfile_offsets): Initialize
        sect_index_{text,data,bss,rodata} from bfd information.
        * xcoffread.c (xcoff_symfile_offsets): Ditto.
        * somread.c (som_symfile_offsets): Initialize
        sect_index_{text,data,bss,rodata}.

        * coffread.c, dbxread.c, elfread.c, hp-psymtab-read.c,
        hp-symtab-read.c, hpread.c, mdebugread.c, minsyms.c,
        mipsread.c, objfiles.c, os9kread.c, pa64solib.c, partial-stab.h,
        remote-os9k.c, remote-vx.c, remote.c, rs6000-nat.c, somsolib.c,
        stabsread.c, symfile.c, xcoffread.c:
        Update use of SECT_OFF_{TEXT,DATA,BSS,RODATA} to depend on the
        current objfile.

        * xcoffread.c: Add new field objfile to find_targ_sec_arg.
@
text
@d369 1
a369 1
  back_to = make_cleanup ((make_cleanup_func) discard_minimal_symbols, 0);
@


1.2
log
@2000-04-21  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

	* win32-nat.c  (handle_load_dll): Don't treat .text as a special
 	section anymore.
	* somread.c (som_symfile_offsets): Ditto.
	* somsolib.c (som_solib_add_solib_objfile): Ditto.
@
text
@d474 11
d489 3
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1991, 1992, 1996 Free Software Foundation, Inc.
d5 1
a5 1
This file is part of GDB.
d7 14
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d46 1
a46 1
som_symfile_read PARAMS ((struct objfile *, struct section_offsets *, int));
d55 2
a56 2
static struct section_offsets *
som_symfile_offsets PARAMS ((struct objfile *, CORE_ADDR));
d61 1
a61 1
hpread_build_psymtabs PARAMS ((struct objfile *, struct section_offsets *, int));
d74 1
a74 1
LOCAL FUNCTION
d76 1
a76 1
	som_symtab_read -- read the symbol table of a SOM file
d78 1
a78 1
SYNOPSIS
d80 2
a81 2
	void som_symtab_read (bfd *abfd, struct objfile *objfile,
			      struct section_offsets *section_offsets)
d83 1
a83 1
DESCRIPTION
d85 5
a89 5
	Given an open bfd, a base address to relocate symbols to, and a
	flag that specifies whether or not this bfd is for an executable
	or not (may be shared library for example), add all the global
	function and data symbols to the minimal symbol table.
*/
d176 2
a177 2
		 the stubs, while the ST_CODE symbol is the real
		 function.  */
d228 13
a240 13
		 label prefixes for stabs, constant data, etc.  So we need
		 only filter out L$ symbols which are left in due to
		 limitations in how GAS generates SOM relocations.

		 When linking in the HPUX C-library the HP linker has
		 the nasty habit of placing section symbols from the literal
		 subspaces in the middle of the program's text.  Filter
		 those out as best we can.  Check for first and last character
		 being '$'. 

		 And finally, the newer HP compilers emit crud like $PIC_foo$N
		 in some circumstance (PIC code I guess).  It's also claimed
		 that they emit D$ symbols too.  What stupidity.  */
d242 1
a242 1
		  || (symname[0] == '$' && symname[strlen(symname) - 1] == '$')
d262 2
a263 2
		 the stubs, while the ST_CODE symbol is the real
		 function.  */
d295 3
a297 3
	/* This can happen for common symbols when -E is passed to the
	   final link.  No idea _why_ that would make the linker force
	   common symbols to have an SS_UNSAT scope, but it does.
d299 2
a300 2
	   This also happens for weak symbols, but their type is
	   ST_DATA.  */
d304 6
a309 6
	      case ST_STORAGE:
	      case ST_DATA:
		symname = bufp->name.n_strx + stringtab;
		bufp->symbol_value += data_offset;
		ms_type = mst_data;
		break;
d311 2
a312 2
	      default:
		continue;
d324 1
a324 1
      prim_record_minimal_symbol (symname, bufp->symbol_value, ms_type, 
d359 1
a359 1
som_symfile_read (objfile, section_offsets, mainline)
a360 1
     struct section_offsets *section_offsets;
d376 1
a376 1
#if 0   /* Export symbols not used today 1997-08-05 */ 
d387 2
a388 2
 
  som_symtab_read (abfd, objfile, section_offsets);
d393 2
a394 2
     situation? */    
  stabsect_build_psymtabs (objfile, section_offsets, mainline,
d401 1
a401 1
  hpread_build_psymtabs (objfile, section_offsets, mainline);
d438 1
a438 1
  if (objfile -> sym_stab_info != NULL)
d440 1
a440 1
      mfree (objfile -> md, objfile -> sym_stab_info);
d462 2
a463 2
static struct section_offsets *
som_symfile_offsets (objfile, addr)
d465 1
a465 1
     CORE_ADDR addr;
a466 1
  struct section_offsets *section_offsets;
d468 1
d471 2
a472 2
  section_offsets = (struct section_offsets *)
    obstack_alloc (&objfile -> psymbol_obstack, SIZEOF_SECTION_OFFSETS);
d475 2
a476 2
     offsets from the library, else get them from addr.  */
  if (!som_solib_section_offsets (objfile, section_offsets))
d478 5
d484 1
a484 1
	ANOFFSET (section_offsets, i) = addr;
a485 28

  return section_offsets;
}



/* Check if a given symbol NAME is in the import list
   of OBJFILE.
   1 => true, 0 => false
   This is used in hp_symtab_read.c to deal with static variables
   that are defined in a different shared library than the one
   whose symbols are being processed. */ 

int is_in_import_list (name, objfile)
  char * name;
  struct objfile * objfile;
{
  register int i;

  if (!objfile ||
      !name ||
      !*name)
    return 0;

  for (i=0; i < objfile->import_list_size; i++)
    if (objfile->import_list[i] && STREQ (name, objfile->import_list[i]))
        return 1;
  return 0;
a487 1

d496 1
a496 1
  struct objfile * objfile;
d502 1
a502 1
  char * string_buffer;
d506 2
a507 2
  asection * text_section;      /* section handle */ 
  unsigned int dl_header[12];   /* SOM executable header */ 
d510 12
a521 10
  typedef struct {
    int name;              /* index into the string table */ 
    short dont_care1;      /* we don't use this */ 
    unsigned char type;    /* 0 = NULL, 2 = Data, 3 = Code, 7 = Storage, 13 = Plabel */ 
    unsigned int reserved2 : 8; /* not used */ 
  } SomImportEntry;

  /* We read 100 entries in at a time from the disk file. */ 
# define SOM_READ_IMPORTS_NUM         100
# define SOM_READ_IMPORTS_CHUNK_SIZE  (sizeof (SomImportEntry) * SOM_READ_IMPORTS_NUM)
d523 1
a523 1
  
a527 4
#if 0  /* DEBUGGING */
  printf ("Processing import list for %s\n", objfile->name);
#endif

d529 1
a529 1
     the subspace $SHLIB_INFO$ has to be used.  Some BFD quirk? pai/1997-08-05 */ 
d533 1
a533 1
  /* Get the SOM executable header */ 
d538 1
a538 1
     FIXME: Change for future HP-UX releases and mods to the SOM executable format */ 
d541 2
a542 2
  
  import_list = dl_header[4];     
d546 1
a546 1
  string_table = dl_header[10];     
d551 1
a551 1
  /* Suck in SOM string table */ 
d554 1
a554 1
                            string_table, string_table_size);
d558 1
a558 1
     import list to be freed when the objfile is deallocated */ 
d561 1
a561 1
                                      import_list_size * sizeof (ImportEntry));
d563 2
a564 2
  /* Read in the import entries, a bunch at a time */ 
  for (j=0, k=0;
d569 15
a583 19
                                import_list + j * SOM_READ_IMPORTS_CHUNK_SIZE,
                                SOM_READ_IMPORTS_CHUNK_SIZE);
      for (i=0; i < SOM_READ_IMPORTS_NUM; i++, k++)
        {
          if (buffer[i].type != (unsigned char) 0) 
            {
              objfile->import_list[k]
                = (char *) obstack_alloc (&objfile->psymbol_obstack, strlen (string_buffer + buffer[i].name) + 1);
              strcpy (objfile->import_list[k], string_buffer + buffer[i].name);
              /* Some day we might want to record the type and other information too */ 
            }
          else /* null type */ 
            objfile->import_list[k] = NULL;
          
#if 0 /* DEBUGGING */
          printf ("Import String %d:%d (%d), type %d is %s\n", j, i, k,
                  (int) buffer[i].type, objfile->import_list[k]);
#endif
        }
d586 1
a586 1
  /* Get the leftovers */ 
d589 3
a591 3
                              import_list + k * sizeof (SomImportEntry),
                              (import_list_size - k) * sizeof (SomImportEntry));
  for (i=0; k < import_list_size; i++, k++)
d594 6
a599 6
        {
          objfile->import_list[k]
            = (char *) obstack_alloc (&objfile->psymbol_obstack, strlen (string_buffer + buffer[i].name) + 1);
          strcpy (objfile->import_list[k], string_buffer + buffer[i].name);
          /* Some day we might want to record the type and other information too */ 
        }
d601 1
a601 5
        objfile->import_list[k] = NULL;
#if 0 /* DEBUGGING */ 
      printf ("Import String F:%d (%d), type %d, is %s\n", i, k,
              (int) buffer[i].type, objfile->import_list[k]);
#endif
d617 1
a617 1
  struct objfile * objfile;
d623 1
a623 1
  char * string_buffer;
d627 2
a628 2
  asection * text_section;    /* section handle */  
  unsigned int dl_header[12]; /* SOM executable header */ 
d631 15
a645 13
  typedef struct {
    int next;    /* for hash table use -- we don't use this */ 
    int name;    /* index into string table */ 
    int value;   /* offset or plabel */
    int dont_care1;     /* not used */ 
    unsigned char type; /* 0 = NULL, 2 = Data, 3 = Code, 7 = Storage, 13 = Plabel */ 
    char dont_care2;    /* not used */ 
    short dont_care3;   /* not used */ 
  } SomExportEntry;

  /* We read 100 entries in at a time from the disk file. */ 
# define SOM_READ_EXPORTS_NUM         100  
# define SOM_READ_EXPORTS_CHUNK_SIZE  (sizeof (SomExportEntry) * SOM_READ_EXPORTS_NUM)
a651 4
#if 0  /* DEBUGGING */
  printf ("Processing export list for %s\n", objfile->name);
#endif

d653 1
a653 1
     the subspace $SHLIB_INFO$ has to be used.  Some BFD quirk? pai/1997-08-05 */ 
d657 1
a657 1
  /* Get the SOM executable header */ 
d662 1
a662 1
     FIXME: Change for future HP-UX releases and mods to the SOM executable format */ 
d665 3
a667 3
  
  export_list = dl_header[8];      
  export_list_size = dl_header[9]; 
d670 1
a670 1
  string_table = dl_header[10];     
d675 1
a675 1
  /* Suck in SOM string table */ 
d678 1
a678 1
                            string_table, string_table_size);
d682 1
a682 1
     export list to be freed when the objfile is deallocated */ 
d684 2
a685 2
    = (ExportEntry *)  obstack_alloc (&objfile->psymbol_obstack,
                                      export_list_size * sizeof (ExportEntry));
d687 2
a688 2
  /* Read in the export entries, a bunch at a time */ 
  for (j=0, k=0;
d693 19
a711 22
                                export_list + j * SOM_READ_EXPORTS_CHUNK_SIZE,
                                SOM_READ_EXPORTS_CHUNK_SIZE);
      for (i=0; i < SOM_READ_EXPORTS_NUM; i++, k++)
        {
          if (buffer[i].type != (unsigned char) 0)
            {
              objfile->export_list[k].name
                = (char *) obstack_alloc (&objfile->psymbol_obstack, strlen (string_buffer + buffer[i].name) + 1);
              strcpy (objfile->export_list[k].name, string_buffer + buffer[i].name);
              objfile->export_list[k].address = buffer[i].value;
              /* Some day we might want to record the type and other information too */ 
            }
          else /* null type */ 
            { 
              objfile->export_list[k].name = NULL;
              objfile->export_list[k].address = 0;
            }
#if 0 /* DEBUGGING */
          printf ("Export String %d:%d (%d), type %d is %s\n", j, i, k,
                  (int) buffer[i].type, objfile->export_list[k].name);
#endif
        }
d714 1
a714 1
  /* Get the leftovers */ 
d717 3
a719 3
                              export_list + k * sizeof (SomExportEntry),
                              (export_list_size - k) * sizeof (SomExportEntry));
  for (i=0; k < export_list_size; i++, k++)
d722 7
a728 7
        {
          objfile->export_list[k].name
            = (char *) obstack_alloc (&objfile->psymbol_obstack, strlen (string_buffer + buffer[i].name) + 1);
          strcpy (objfile->export_list[k].name, string_buffer + buffer[i].name);
          /* Some day we might want to record the type and other information too */ 
          objfile->export_list[k].address = buffer[i].value;
        }
d730 4
a733 8
        {
          objfile->export_list[k].name = NULL;
          objfile->export_list[k].address = 0;
        }
#if 0 /* DEBUGGING */ 
      printf ("Export String F:%d (%d), type %d, value %x is %s\n", i, k,
              (int) buffer[i].type, buffer[i].value, objfile->export_list[k].name);
#endif
d740 1
a742 1

d748 6
a753 6
  som_new_init,		/* sym_new_init: init anything gbl to entire symtab */
  som_symfile_init,	/* sym_init: read initial info, setup for sym_read() */
  som_symfile_read,	/* sym_read: read a symbol file into symtab */
  som_symfile_finish,	/* sym_finish: finished with file, cleanup */
  som_symfile_offsets,	/* sym_offsets:  Translate ext. to int. relocation */
  NULL			/* next: pointer to next struct sym_fns */
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-06-07 snapshot
@
text
@d2 1
a2 1
   Copyright 1991, 1992, 1996, 1999 Free Software Foundation, Inc.
d550 4
d609 4
d632 4
d684 4
d746 4
d773 4
@


1.1.1.3
log
@import gdb-1999-07-07 post reformat
@
text
@d5 1
a5 1
   This file is part of GDB.
d7 13
a19 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d55 1
a55 1
  som_symfile_offsets PARAMS ((struct objfile *, CORE_ADDR));
d73 1
a73 1
   LOCAL FUNCTION
d75 1
a75 1
   som_symtab_read -- read the symbol table of a SOM file
d77 1
a77 1
   SYNOPSIS
d79 2
a80 2
   void som_symtab_read (bfd *abfd, struct objfile *objfile,
   struct section_offsets *section_offsets)
d82 1
a82 1
   DESCRIPTION
d84 5
a88 5
   Given an open bfd, a base address to relocate symbols to, and a
   flag that specifies whether or not this bfd is for an executable
   or not (may be shared library for example), add all the global
   function and data symbols to the minimal symbol table.
 */
d175 2
a176 2
	         the stubs, while the ST_CODE symbol is the real
	         function.  */
d227 13
a239 13
	         label prefixes for stabs, constant data, etc.  So we need
	         only filter out L$ symbols which are left in due to
	         limitations in how GAS generates SOM relocations.

	         When linking in the HPUX C-library the HP linker has
	         the nasty habit of placing section symbols from the literal
	         subspaces in the middle of the program's text.  Filter
	         those out as best we can.  Check for first and last character
	         being '$'. 

	         And finally, the newer HP compilers emit crud like $PIC_foo$N
	         in some circumstance (PIC code I guess).  It's also claimed
	         that they emit D$ symbols too.  What stupidity.  */
d241 1
a241 1
	      || (symname[0] == '$' && symname[strlen (symname) - 1] == '$')
d261 2
a262 2
	         the stubs, while the ST_CODE symbol is the real
	         function.  */
d294 3
a296 3
	  /* This can happen for common symbols when -E is passed to the
	     final link.  No idea _why_ that would make the linker force
	     common symbols to have an SS_UNSAT scope, but it does.
d298 2
a299 2
	     This also happens for weak symbols, but their type is
	     ST_DATA.  */
d303 6
a308 6
	    case ST_STORAGE:
	    case ST_DATA:
	      symname = bufp->name.n_strx + stringtab;
	      bufp->symbol_value += data_offset;
	      ms_type = mst_data;
	      break;
d310 2
a311 2
	    default:
	      continue;
d323 1
a323 1
      prim_record_minimal_symbol (symname, bufp->symbol_value, ms_type,
d376 1
a376 1
#if 0				/* Export symbols not used today 1997-08-05 */
d387 1
a387 1

d393 1
a393 1
     situation? */
d438 1
a438 1
  if (objfile->sym_stab_info != NULL)
d440 1
a440 1
      mfree (objfile->md, objfile->sym_stab_info);
d472 1
a472 1
    obstack_alloc (&objfile->psymbol_obstack, SIZEOF_SECTION_OFFSETS);
d492 1
a492 1
   whose symbols are being processed. */
d494 3
a496 4
int
is_in_import_list (name, objfile)
     char *name;
     struct objfile *objfile;
d505 1
a505 1
  for (i = 0; i < objfile->import_list_size; i++)
d507 1
a507 1
      return 1;
d520 1
a520 1
     struct objfile *objfile;
d526 1
a526 1
  char *string_buffer;
d530 2
a531 2
  asection *text_section;	/* section handle */
  unsigned int dl_header[12];	/* SOM executable header */
d534 10
a543 12
  typedef struct
    {
      int name;			/* index into the string table */
      short dont_care1;		/* we don't use this */
      unsigned char type;	/* 0 = NULL, 2 = Data, 3 = Code, 7 = Storage, 13 = Plabel */
      unsigned int reserved2:8;	/* not used */
    }
  SomImportEntry;

  /* We read 100 entries in at a time from the disk file. */
#define SOM_READ_IMPORTS_NUM         100
#define SOM_READ_IMPORTS_CHUNK_SIZE  (sizeof (SomImportEntry) * SOM_READ_IMPORTS_NUM)
d545 1
a545 1

d551 1
a551 1
     the subspace $SHLIB_INFO$ has to be used.  Some BFD quirk? pai/1997-08-05 */
d555 1
a555 1
  /* Get the SOM executable header */
d560 1
a560 1
     FIXME: Change for future HP-UX releases and mods to the SOM executable format */
d563 2
a564 2

  import_list = dl_header[4];
d568 1
a568 1
  string_table = dl_header[10];
d573 1
a573 1
  /* Suck in SOM string table */
d576 1
a576 1
			    string_table, string_table_size);
d580 1
a580 1
     import list to be freed when the objfile is deallocated */
d583 1
a583 1
				   import_list_size * sizeof (ImportEntry));
d585 2
a586 2
  /* Read in the import entries, a bunch at a time */
  for (j = 0, k = 0;
d591 15
a605 15
			      import_list + j * SOM_READ_IMPORTS_CHUNK_SIZE,
				SOM_READ_IMPORTS_CHUNK_SIZE);
      for (i = 0; i < SOM_READ_IMPORTS_NUM; i++, k++)
	{
	  if (buffer[i].type != (unsigned char) 0)
	    {
	      objfile->import_list[k]
		= (char *) obstack_alloc (&objfile->psymbol_obstack, strlen (string_buffer + buffer[i].name) + 1);
	      strcpy (objfile->import_list[k], string_buffer + buffer[i].name);
	      /* Some day we might want to record the type and other information too */
	    }
	  else			/* null type */
	    objfile->import_list[k] = NULL;

	}
d608 1
a608 1
  /* Get the leftovers */
d611 3
a613 3
			      import_list + k * sizeof (SomImportEntry),
			  (import_list_size - k) * sizeof (SomImportEntry));
  for (i = 0; k < import_list_size; i++, k++)
d616 6
a621 6
	{
	  objfile->import_list[k]
	    = (char *) obstack_alloc (&objfile->psymbol_obstack, strlen (string_buffer + buffer[i].name) + 1);
	  strcpy (objfile->import_list[k], string_buffer + buffer[i].name);
	  /* Some day we might want to record the type and other information too */
	}
d623 1
a623 1
	objfile->import_list[k] = NULL;
d639 1
a639 1
     struct objfile *objfile;
d645 1
a645 1
  char *string_buffer;
d649 2
a650 2
  asection *text_section;	/* section handle */
  unsigned int dl_header[12];	/* SOM executable header */
d653 13
a665 15
  typedef struct
    {
      int next;			/* for hash table use -- we don't use this */
      int name;			/* index into string table */
      int value;		/* offset or plabel */
      int dont_care1;		/* not used */
      unsigned char type;	/* 0 = NULL, 2 = Data, 3 = Code, 7 = Storage, 13 = Plabel */
      char dont_care2;		/* not used */
      short dont_care3;		/* not used */
    }
  SomExportEntry;

  /* We read 100 entries in at a time from the disk file. */
#define SOM_READ_EXPORTS_NUM         100
#define SOM_READ_EXPORTS_CHUNK_SIZE  (sizeof (SomExportEntry) * SOM_READ_EXPORTS_NUM)
d673 1
a673 1
     the subspace $SHLIB_INFO$ has to be used.  Some BFD quirk? pai/1997-08-05 */
d677 1
a677 1
  /* Get the SOM executable header */
d682 1
a682 1
     FIXME: Change for future HP-UX releases and mods to the SOM executable format */
d685 3
a687 3

  export_list = dl_header[8];
  export_list_size = dl_header[9];
d690 1
a690 1
  string_table = dl_header[10];
d695 1
a695 1
  /* Suck in SOM string table */
d698 1
a698 1
			    string_table, string_table_size);
d702 1
a702 1
     export list to be freed when the objfile is deallocated */
d704 2
a705 2
    = (ExportEntry *) obstack_alloc (&objfile->psymbol_obstack,
				   export_list_size * sizeof (ExportEntry));
d707 2
a708 2
  /* Read in the export entries, a bunch at a time */
  for (j = 0, k = 0;
d713 18
a730 19
			      export_list + j * SOM_READ_EXPORTS_CHUNK_SIZE,
				SOM_READ_EXPORTS_CHUNK_SIZE);
      for (i = 0; i < SOM_READ_EXPORTS_NUM; i++, k++)
	{
	  if (buffer[i].type != (unsigned char) 0)
	    {
	      objfile->export_list[k].name
		= (char *) obstack_alloc (&objfile->psymbol_obstack, strlen (string_buffer + buffer[i].name) + 1);
	      strcpy (objfile->export_list[k].name, string_buffer + buffer[i].name);
	      objfile->export_list[k].address = buffer[i].value;
	      /* Some day we might want to record the type and other information too */
	    }
	  else
	    /* null type */
	    {
	      objfile->export_list[k].name = NULL;
	      objfile->export_list[k].address = 0;
	    }
	}
d733 1
a733 1
  /* Get the leftovers */
d736 3
a738 3
			      export_list + k * sizeof (SomExportEntry),
			  (export_list_size - k) * sizeof (SomExportEntry));
  for (i = 0; k < export_list_size; i++, k++)
d741 7
a747 7
	{
	  objfile->export_list[k].name
	    = (char *) obstack_alloc (&objfile->psymbol_obstack, strlen (string_buffer + buffer[i].name) + 1);
	  strcpy (objfile->export_list[k].name, string_buffer + buffer[i].name);
	  /* Some day we might want to record the type and other information too */
	  objfile->export_list[k].address = buffer[i].value;
	}
d749 4
a752 4
	{
	  objfile->export_list[k].name = NULL;
	  objfile->export_list[k].address = 0;
	}
a758 1

d761 1
d767 6
a772 6
  som_new_init,			/* sym_new_init: init anything gbl to entire symtab */
  som_symfile_init,		/* sym_init: read initial info, setup for sym_read() */
  som_symfile_read,		/* sym_read: read a symbol file into symtab */
  som_symfile_finish,		/* sym_finish: finished with file, cleanup */
  som_symfile_offsets,		/* sym_offsets:  Translate ext. to int. relocation */
  NULL				/* next: pointer to next struct sym_fns */
@


1.1.1.4
log
@import gdb-1999-08-09 snapshot
@
text
@d46 1
a46 1
som_symfile_read PARAMS ((struct objfile *, int));
d56 1
a56 1
som_symfile_offsets PARAMS ((struct objfile *, CORE_ADDR));
d359 1
a359 1
som_symfile_read (objfile, mainline)
d361 1
d389 1
a389 1
  som_symtab_read (abfd, objfile, objfile->section_offsets);
d395 1
a395 1
  stabsect_build_psymtabs (objfile, mainline,
d402 1
a402 1
  hpread_build_psymtabs (objfile, objfile->section_offsets, mainline);
@


1.1.1.5
log
@import gdb-1999-08-16 snapshot
@
text
@d485 28
@


1.1.1.6
log
@import gdb-1999-09-08 snapshot
@
text
@d55 1
a55 1
static void
d61 1
a61 1
hpread_build_psymtabs PARAMS ((struct objfile *, int));
d401 1
a401 1
  hpread_build_psymtabs (objfile, mainline);
d462 1
a462 1
static void
d467 1
d471 1
a471 1
  objfile->section_offsets = (struct section_offsets *)
d476 1
a476 1
  if (!som_solib_section_offsets (objfile, objfile->section_offsets))
d479 1
a479 1
	ANOFFSET (objfile->section_offsets, i) = addr;
d481 2
@


1.1.1.7
log
@import gdb-1999-10-04 snapshot
@
text
@d56 1
a56 1
som_symfile_offsets PARAMS ((struct objfile *, struct section_addr_info *));
d463 1
a463 1
som_symfile_offsets (objfile, addrs)
d465 1
a465 1
     struct section_addr_info *addrs;
d474 1
a474 1
     offsets from the library, else get them from addrs.  */
d478 1
a478 1
	ANOFFSET (objfile->section_offsets, i) = addrs -> text_addr;
@


