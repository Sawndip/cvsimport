head	1.24;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.22
	gdb_7_6-2013-04-26-release:1.22
	gdb_7_6-branch:1.22.0.2
	gdb_7_6-2013-03-12-branchpoint:1.22
	gdb_7_5_1-2012-11-29-release:1.18
	gdb_7_5-2012-08-17-release:1.18
	gdb_7_5-branch:1.18.0.2
	gdb_7_5-2012-07-18-branchpoint:1.18
	gdb_7_4_1-2012-04-26-release:1.13.2.1
	gdb_7_4-2012-01-24-release:1.13.2.1
	gdb_7_4-branch:1.13.0.2
	gdb_7_4-2011-12-13-branchpoint:1.13
	gdb_7_3_1-2011-09-04-release:1.10
	gdb_7_3-2011-07-26-release:1.10
	gdb_7_3-branch:1.10.0.2
	gdb_7_3-2011-04-01-branchpoint:1.10;
locks; strict;
comment	@ * @;


1.24
date	2013.05.13.16.51.51;	author tromey;	state Exp;
branches;
next	1.23;

1.23
date	2013.03.25.17.26.18;	author tromey;	state Exp;
branches;
next	1.22;

1.22
date	2013.01.25.17.16.40;	author aburgess;	state Exp;
branches;
next	1.21;

1.21
date	2013.01.01.06.32.47;	author brobecke;	state Exp;
branches;
next	1.20;

1.20
date	2012.11.29.18.56.23;	author uweigand;	state Exp;
branches;
next	1.19;

1.19
date	2012.08.17.17.37.00;	author kseitz;	state Exp;
branches;
next	1.18;

1.18
date	2012.03.02.19.29.01;	author brobecke;	state Exp;
branches;
next	1.17;

1.17
date	2012.03.01.21.13.59;	author palves;	state Exp;
branches;
next	1.16;

1.16
date	2012.02.08.19.54.37;	author brobecke;	state Exp;
branches;
next	1.15;

1.15
date	2012.01.26.04.20.36;	author brobecke;	state Exp;
branches;
next	1.14;

1.14
date	2012.01.04.08.17.09;	author brobecke;	state Exp;
branches;
next	1.13;

1.13
date	2011.12.06.18.54.39;	author tromey;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2011.10.09.19.43.40;	author jkratoch;	state Exp;
branches;
next	1.11;

1.11
date	2011.07.14.15.00.20;	author jkratoch;	state Exp;
branches;
next	1.10;

1.10
date	2011.02.28.22.49.57;	author msnyder;	state Exp;
branches;
next	1.9;

1.9
date	2011.02.28.18.40.31;	author msnyder;	state Exp;
branches;
next	1.8;

1.8
date	2011.02.28.18.31.36;	author msnyder;	state Exp;
branches;
next	1.7;

1.7
date	2011.02.21.15.53.10;	author uweigand;	state Exp;
branches;
next	1.6;

1.6
date	2011.02.15.20.09.52;	author kwerner;	state Exp;
branches;
next	1.5;

1.5
date	2011.02.02.13.47.06;	author uweigand;	state Exp;
branches;
next	1.4;

1.4
date	2011.01.10.20.38.49;	author msnyder;	state Exp;
branches;
next	1.3;

1.3
date	2011.01.01.15.33.12;	author brobecke;	state Exp;
branches;
next	1.2;

1.2
date	2010.11.29.21.18.16;	author tromey;	state Exp;
branches;
next	1.1;

1.1
date	2010.11.05.14.31.28;	author kwerner;	state Exp;
branches;
next	;

1.13.2.1
date	2012.01.06.04.43.21;	author brobecke;	state Exp;
branches;
next	;


desc
@@


1.24
log
@	PR exp/15364:
	* eval.c (evaluate_subexp_standard) <STRUCTOP_STRUCT,
	STRUCTOP_PTR>: Return a not_lval value for
	EVAL_AVOID_SIDE_EFFECTS.
	* opencl-lang.c (evaluate_subexp_opencl): Return a not_lval value
	for EVAL_AVOID_SIDE_EFFECTS.
gdb/testsuite
	* gdb.base/exprs.exp (test_expr): Add regression test.
	* gdb.base/exprs.c (null_t_struct): New global.
@
text
@/* OpenCL language support for GDB, the GNU debugger.
   Copyright (C) 2010-2013 Free Software Foundation, Inc.

   Contributed by Ken Werner <ken.werner@@de.ibm.com>.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "gdb_string.h"
#include "gdbtypes.h"
#include "symtab.h"
#include "expression.h"
#include "parser-defs.h"
#include "symtab.h"
#include "language.h"
#include "c-lang.h"
#include "gdb_assert.h"

extern void _initialize_opencl_language (void);

/* This macro generates enum values from a given type.  */

#define OCL_P_TYPE(TYPE)\
  opencl_primitive_type_##TYPE,\
  opencl_primitive_type_##TYPE##2,\
  opencl_primitive_type_##TYPE##3,\
  opencl_primitive_type_##TYPE##4,\
  opencl_primitive_type_##TYPE##8,\
  opencl_primitive_type_##TYPE##16

enum opencl_primitive_types {
  OCL_P_TYPE (char),
  OCL_P_TYPE (uchar),
  OCL_P_TYPE (short),
  OCL_P_TYPE (ushort),
  OCL_P_TYPE (int),
  OCL_P_TYPE (uint),
  OCL_P_TYPE (long),
  OCL_P_TYPE (ulong),
  OCL_P_TYPE (half),
  OCL_P_TYPE (float),
  OCL_P_TYPE (double),
  opencl_primitive_type_bool,
  opencl_primitive_type_unsigned_char,
  opencl_primitive_type_unsigned_short,
  opencl_primitive_type_unsigned_int,
  opencl_primitive_type_unsigned_long,
  opencl_primitive_type_size_t,
  opencl_primitive_type_ptrdiff_t,
  opencl_primitive_type_intptr_t,
  opencl_primitive_type_uintptr_t,
  opencl_primitive_type_void,
  nr_opencl_primitive_types
};

static struct gdbarch_data *opencl_type_data;

static struct type **
builtin_opencl_type (struct gdbarch *gdbarch)
{
  return gdbarch_data (gdbarch, opencl_type_data);
}

/* Returns the corresponding OpenCL vector type from the given type code,
   the length of the element type, the unsigned flag and the amount of
   elements (N).  */

static struct type *
lookup_opencl_vector_type (struct gdbarch *gdbarch, enum type_code code,
			   unsigned int el_length, unsigned int flag_unsigned,
			   int n)
{
  int i;
  unsigned int length;
  struct type *type = NULL;
  struct type **types = builtin_opencl_type (gdbarch);

  /* Check if n describes a valid OpenCL vector size (2, 3, 4, 8, 16).  */
  if (n != 2 && n != 3 && n != 4 && n != 8 && n != 16)
    error (_("Invalid OpenCL vector size: %d"), n);

  /* Triple vectors have the size of a quad vector.  */
  length = (n == 3) ?  el_length * 4 : el_length * n;

  for (i = 0; i < nr_opencl_primitive_types; i++)
    {
      LONGEST lowb, highb;

      if (TYPE_CODE (types[i]) == TYPE_CODE_ARRAY && TYPE_VECTOR (types[i])
	  && get_array_bounds (types[i], &lowb, &highb)
	  && TYPE_CODE (TYPE_TARGET_TYPE (types[i])) == code
	  && TYPE_UNSIGNED (TYPE_TARGET_TYPE (types[i])) == flag_unsigned
	  && TYPE_LENGTH (TYPE_TARGET_TYPE (types[i])) == el_length
	  && TYPE_LENGTH (types[i]) == length
	  && highb - lowb + 1 == n)
	{
	  type = types[i];
	  break;
	}
    }

  return type;
}

/* Returns nonzero if the array ARR contains duplicates within
     the first N elements.  */

static int
array_has_dups (int *arr, int n)
{
  int i, j;

  for (i = 0; i < n; i++)
    {
      for (j = i + 1; j < n; j++)
        {
          if (arr[i] == arr[j])
            return 1;
        }
    }

  return 0;
}

/* The OpenCL component access syntax allows to create lvalues referring to
   selected elements of an original OpenCL vector in arbitrary order.  This
   structure holds the information to describe such lvalues.  */

struct lval_closure
{
  /* Reference count.  */
  int refc;
  /* The number of indices.  */
  int n;
  /* The element indices themselves.  */
  int *indices;
  /* A pointer to the original value.  */
  struct value *val;
};

/* Allocates an instance of struct lval_closure.  */

static struct lval_closure *
allocate_lval_closure (int *indices, int n, struct value *val)
{
  struct lval_closure *c = XZALLOC (struct lval_closure);

  c->refc = 1;
  c->n = n;
  c->indices = XCALLOC (n, int);
  memcpy (c->indices, indices, n * sizeof (int));
  value_incref (val); /* Increment the reference counter of the value.  */
  c->val = val;

  return c;
}

static void
lval_func_read (struct value *v)
{
  struct lval_closure *c = (struct lval_closure *) value_computed_closure (v);
  struct type *type = check_typedef (value_type (v));
  struct type *eltype = TYPE_TARGET_TYPE (check_typedef (value_type (c->val)));
  int offset = value_offset (v);
  int elsize = TYPE_LENGTH (eltype);
  int n, i, j = 0;
  LONGEST lowb = 0;
  LONGEST highb = 0;

  if (TYPE_CODE (type) == TYPE_CODE_ARRAY
      && !get_array_bounds (type, &lowb, &highb))
    error (_("Could not determine the vector bounds"));

  /* Assume elsize aligned offset.  */
  gdb_assert (offset % elsize == 0);
  offset /= elsize;
  n = offset + highb - lowb + 1;
  gdb_assert (n <= c->n);

  for (i = offset; i < n; i++)
    memcpy (value_contents_raw (v) + j++ * elsize,
	    value_contents (c->val) + c->indices[i] * elsize,
	    elsize);
}

static void
lval_func_write (struct value *v, struct value *fromval)
{
  struct value *mark = value_mark ();
  struct lval_closure *c = (struct lval_closure *) value_computed_closure (v);
  struct type *type = check_typedef (value_type (v));
  struct type *eltype = TYPE_TARGET_TYPE (check_typedef (value_type (c->val)));
  int offset = value_offset (v);
  int elsize = TYPE_LENGTH (eltype);
  int n, i, j = 0;
  LONGEST lowb = 0;
  LONGEST highb = 0;

  if (TYPE_CODE (type) == TYPE_CODE_ARRAY
      && !get_array_bounds (type, &lowb, &highb))
    error (_("Could not determine the vector bounds"));

  /* Assume elsize aligned offset.  */
  gdb_assert (offset % elsize == 0);
  offset /= elsize;
  n = offset + highb - lowb + 1;

  /* Since accesses to the fourth component of a triple vector is undefined we
     just skip writes to the fourth element.  Imagine something like this:
       int3 i3 = (int3)(0, 1, 2);
       i3.hi.hi = 5;
     In this case n would be 4 (offset=12/4 + 1) while c->n would be 3.  */
  if (n > c->n)
    n = c->n;

  for (i = offset; i < n; i++)
    {
      struct value *from_elm_val = allocate_value (eltype);
      struct value *to_elm_val = value_subscript (c->val, c->indices[i]);

      memcpy (value_contents_writeable (from_elm_val),
	      value_contents (fromval) + j++ * elsize,
	      elsize);
      value_assign (to_elm_val, from_elm_val);
    }

  value_free_to_mark (mark);
}

/* Return nonzero if all bits in V within OFFSET and LENGTH are valid.  */

static int
lval_func_check_validity (const struct value *v, int offset, int length)
{
  struct lval_closure *c = (struct lval_closure *) value_computed_closure (v);
  /* Size of the target type in bits.  */
  int elsize =
      TYPE_LENGTH (TYPE_TARGET_TYPE (check_typedef (value_type (c->val)))) * 8;
  int startrest = offset % elsize;
  int start = offset / elsize;
  int endrest = (offset + length) % elsize;
  int end = (offset + length) / elsize;
  int i;

  if (endrest)
    end++;

  if (end > c->n)
    return 0;

  for (i = start; i < end; i++)
    {
      int comp_offset = (i == start) ? startrest : 0;
      int comp_length = (i == end) ? endrest : elsize;

      if (!value_bits_valid (c->val, c->indices[i] * elsize + comp_offset,
			     comp_length))
	return 0;
    }

  return 1;
}

/* Return nonzero if any bit in V is valid.  */

static int
lval_func_check_any_valid (const struct value *v)
{
  struct lval_closure *c = (struct lval_closure *) value_computed_closure (v);
  /* Size of the target type in bits.  */
  int elsize =
      TYPE_LENGTH (TYPE_TARGET_TYPE (check_typedef (value_type (c->val)))) * 8;
  int i;

  for (i = 0; i < c->n; i++)
    if (value_bits_valid (c->val, c->indices[i] * elsize, elsize))
      return 1;

  return 0;
}

/* Return nonzero if bits in V from OFFSET and LENGTH represent a
   synthetic pointer.  */

static int
lval_func_check_synthetic_pointer (const struct value *v,
				   int offset, int length)
{
  struct lval_closure *c = (struct lval_closure *) value_computed_closure (v);
  /* Size of the target type in bits.  */
  int elsize =
      TYPE_LENGTH (TYPE_TARGET_TYPE (check_typedef (value_type (c->val)))) * 8;
  int startrest = offset % elsize;
  int start = offset / elsize;
  int endrest = (offset + length) % elsize;
  int end = (offset + length) / elsize;
  int i;

  if (endrest)
    end++;

  if (end > c->n)
    return 0;

  for (i = start; i < end; i++)
    {
      int comp_offset = (i == start) ? startrest : 0;
      int comp_length = (i == end) ? endrest : elsize;

      if (!value_bits_synthetic_pointer (c->val,
					 c->indices[i] * elsize + comp_offset,
					 comp_length))
	return 0;
    }

  return 1;
}

static void *
lval_func_copy_closure (const struct value *v)
{
  struct lval_closure *c = (struct lval_closure *) value_computed_closure (v);

  ++c->refc;

  return c;
}

static void
lval_func_free_closure (struct value *v)
{
  struct lval_closure *c = (struct lval_closure *) value_computed_closure (v);

  --c->refc;

  if (c->refc == 0)
    {
      value_free (c->val); /* Decrement the reference counter of the value.  */
      xfree (c->indices);
      xfree (c);
    }
}

static const struct lval_funcs opencl_value_funcs =
  {
    lval_func_read,
    lval_func_write,
    lval_func_check_validity,
    lval_func_check_any_valid,
    NULL,	/* indirect */
    NULL,	/* coerce_ref */
    lval_func_check_synthetic_pointer,
    lval_func_copy_closure,
    lval_func_free_closure
  };

/* Creates a sub-vector from VAL.  The elements are selected by the indices of
   an array with the length of N.  Supported values for NOSIDE are
   EVAL_NORMAL and EVAL_AVOID_SIDE_EFFECTS.  */

static struct value *
create_value (struct gdbarch *gdbarch, struct value *val, enum noside noside,
	      int *indices, int n)
{
  struct type *type = check_typedef (value_type (val));
  struct type *elm_type = TYPE_TARGET_TYPE (type);
  struct value *ret;

  /* Check if a single component of a vector is requested which means
     the resulting type is a (primitive) scalar type.  */
  if (n == 1)
    {
      if (noside == EVAL_AVOID_SIDE_EFFECTS)
        ret = value_zero (elm_type, not_lval);
      else
        ret = value_subscript (val, indices[0]);
    }
  else
    {
      /* Multiple components of the vector are requested which means the
	 resulting type is a vector as well.  */
      struct type *dst_type =
	lookup_opencl_vector_type (gdbarch, TYPE_CODE (elm_type),
				   TYPE_LENGTH (elm_type),
				   TYPE_UNSIGNED (elm_type), n);

      if (dst_type == NULL)
	dst_type = init_vector_type (elm_type, n);

      make_cv_type (TYPE_CONST (type), TYPE_VOLATILE (type), dst_type, NULL);

      if (noside == EVAL_AVOID_SIDE_EFFECTS)
	ret = allocate_value (dst_type);
      else
	{
	  /* Check whether to create a lvalue or not.  */
	  if (VALUE_LVAL (val) != not_lval && !array_has_dups (indices, n))
	    {
	      struct lval_closure *c = allocate_lval_closure (indices, n, val);
	      ret = allocate_computed_value (dst_type, &opencl_value_funcs, c);
	    }
	  else
	    {
	      int i;

	      ret = allocate_value (dst_type);

	      /* Copy src val contents into the destination value.  */
	      for (i = 0; i < n; i++)
		memcpy (value_contents_writeable (ret)
			+ (i * TYPE_LENGTH (elm_type)),
			value_contents (val)
			+ (indices[i] * TYPE_LENGTH (elm_type)),
			TYPE_LENGTH (elm_type));
	    }
	}
    }
  return ret;
}

/* OpenCL vector component access.  */

static struct value *
opencl_component_ref (struct expression *exp, struct value *val, char *comps,
		      enum noside noside)
{
  LONGEST lowb, highb;
  int src_len;
  struct value *v;
  int indices[16], i;
  int dst_len;

  if (!get_array_bounds (check_typedef (value_type (val)), &lowb, &highb))
    error (_("Could not determine the vector bounds"));

  src_len = highb - lowb + 1;

  /* Throw an error if the amount of array elements does not fit a
     valid OpenCL vector size (2, 3, 4, 8, 16).  */
  if (src_len != 2 && src_len != 3 && src_len != 4 && src_len != 8
      && src_len != 16)
    error (_("Invalid OpenCL vector size"));

  if (strcmp (comps, "lo") == 0 )
    {
      dst_len = (src_len == 3) ? 2 : src_len / 2;

      for (i = 0; i < dst_len; i++)
	indices[i] = i;
    }
  else if (strcmp (comps, "hi") == 0)
    {
      dst_len = (src_len == 3) ? 2 : src_len / 2;

      for (i = 0; i < dst_len; i++)
	indices[i] = dst_len + i;
    }
  else if (strcmp (comps, "even") == 0)
    {
      dst_len = (src_len == 3) ? 2 : src_len / 2;

      for (i = 0; i < dst_len; i++)
	indices[i] = i*2;
    }
  else if (strcmp (comps, "odd") == 0)
    {
      dst_len = (src_len == 3) ? 2 : src_len / 2;

      for (i = 0; i < dst_len; i++)
        indices[i] = i*2+1;
    }
  else if (strncasecmp (comps, "s", 1) == 0)
    {
#define HEXCHAR_TO_INT(C) ((C >= '0' && C <= '9') ? \
                           C-'0' : ((C >= 'A' && C <= 'F') ? \
                           C-'A'+10 : ((C >= 'a' && C <= 'f') ? \
                           C-'a'+10 : -1)))

      dst_len = strlen (comps);
      /* Skip the s/S-prefix.  */
      dst_len--;

      for (i = 0; i < dst_len; i++)
	{
	  indices[i] = HEXCHAR_TO_INT(comps[i+1]);
	  /* Check if the requested component is invalid or exceeds
	     the vector.  */
	  if (indices[i] < 0 || indices[i] >= src_len)
	    error (_("Invalid OpenCL vector component accessor %s"), comps);
	}
    }
  else
    {
      dst_len = strlen (comps);

      for (i = 0; i < dst_len; i++)
	{
	  /* x, y, z, w */
	  switch (comps[i])
	  {
	  case 'x':
	    indices[i] = 0;
	    break;
	  case 'y':
	    indices[i] = 1;
	    break;
	  case 'z':
	    if (src_len < 3)
	      error (_("Invalid OpenCL vector component accessor %s"), comps);
	    indices[i] = 2;
	    break;
	  case 'w':
	    if (src_len < 4)
	      error (_("Invalid OpenCL vector component accessor %s"), comps);
	    indices[i] = 3;
	    break;
	  default:
	    error (_("Invalid OpenCL vector component accessor %s"), comps);
	    break;
	  }
	}
    }

  /* Throw an error if the amount of requested components does not
     result in a valid length (1, 2, 3, 4, 8, 16).  */
  if (dst_len != 1 && dst_len != 2 && dst_len != 3 && dst_len != 4
      && dst_len != 8 && dst_len != 16)
    error (_("Invalid OpenCL vector component accessor %s"), comps);

  v = create_value (exp->gdbarch, val, noside, indices, dst_len);

  return v;
}

/* Perform the unary logical not (!) operation.  */

static struct value *
opencl_logical_not (struct expression *exp, struct value *arg)
{
  struct type *type = check_typedef (value_type (arg));
  struct type *rettype;
  struct value *ret;

  if (TYPE_CODE (type) == TYPE_CODE_ARRAY && TYPE_VECTOR (type))
    {
      struct type *eltype = check_typedef (TYPE_TARGET_TYPE (type));
      LONGEST lowb, highb;
      int i;

      if (!get_array_bounds (type, &lowb, &highb))
	error (_("Could not determine the vector bounds"));

      /* Determine the resulting type of the operation and allocate the
	 value.  */
      rettype = lookup_opencl_vector_type (exp->gdbarch, TYPE_CODE_INT,
					   TYPE_LENGTH (eltype), 0,
					   highb - lowb + 1);
      ret = allocate_value (rettype);

      for (i = 0; i < highb - lowb + 1; i++)
	{
	  /* For vector types, the unary operator shall return a 0 if the
	  value of its operand compares unequal to 0, and -1 (i.e. all bits
	  set) if the value of its operand compares equal to 0.  */
	  int tmp = value_logical_not (value_subscript (arg, i)) ? -1 : 0;
	  memset (value_contents_writeable (ret) + i * TYPE_LENGTH (eltype),
		  tmp, TYPE_LENGTH (eltype));
	}
    }
  else
    {
      rettype = language_bool_type (exp->language_defn, exp->gdbarch);
      ret = value_from_longest (rettype, value_logical_not (arg));
    }

  return ret;
}

/* Perform a relational operation on two scalar operands.  */

static int
scalar_relop (struct value *val1, struct value *val2, enum exp_opcode op)
{
  int ret;

  switch (op)
    {
    case BINOP_EQUAL:
      ret = value_equal (val1, val2);
      break;
    case BINOP_NOTEQUAL:
      ret = !value_equal (val1, val2);
      break;
    case BINOP_LESS:
      ret = value_less (val1, val2);
      break;
    case BINOP_GTR:
      ret = value_less (val2, val1);
      break;
    case BINOP_GEQ:
      ret = value_less (val2, val1) || value_equal (val1, val2);
      break;
    case BINOP_LEQ:
      ret = value_less (val1, val2) || value_equal (val1, val2);
      break;
    case BINOP_LOGICAL_AND:
      ret = !value_logical_not (val1) && !value_logical_not (val2);
      break;
    case BINOP_LOGICAL_OR:
      ret = !value_logical_not (val1) || !value_logical_not (val2);
      break;
    default:
      error (_("Attempt to perform an unsupported operation"));
      break;
    }
  return ret;
}

/* Perform a relational operation on two vector operands.  */

static struct value *
vector_relop (struct expression *exp, struct value *val1, struct value *val2,
	      enum exp_opcode op)
{
  struct value *ret;
  struct type *type1, *type2, *eltype1, *eltype2, *rettype;
  int t1_is_vec, t2_is_vec, i;
  LONGEST lowb1, lowb2, highb1, highb2;

  type1 = check_typedef (value_type (val1));
  type2 = check_typedef (value_type (val2));

  t1_is_vec = (TYPE_CODE (type1) == TYPE_CODE_ARRAY && TYPE_VECTOR (type1));
  t2_is_vec = (TYPE_CODE (type2) == TYPE_CODE_ARRAY && TYPE_VECTOR (type2));

  if (!t1_is_vec || !t2_is_vec)
    error (_("Vector operations are not supported on scalar types"));

  eltype1 = check_typedef (TYPE_TARGET_TYPE (type1));
  eltype2 = check_typedef (TYPE_TARGET_TYPE (type2));

  if (!get_array_bounds (type1,&lowb1, &highb1)
      || !get_array_bounds (type2, &lowb2, &highb2))
    error (_("Could not determine the vector bounds"));

  /* Check whether the vector types are compatible.  */
  if (TYPE_CODE (eltype1) != TYPE_CODE (eltype2)
      || TYPE_LENGTH (eltype1) != TYPE_LENGTH (eltype2)
      || TYPE_UNSIGNED (eltype1) != TYPE_UNSIGNED (eltype2)
      || lowb1 != lowb2 || highb1 != highb2)
    error (_("Cannot perform operation on vectors with different types"));

  /* Determine the resulting type of the operation and allocate the value.  */
  rettype = lookup_opencl_vector_type (exp->gdbarch, TYPE_CODE_INT,
				       TYPE_LENGTH (eltype1), 0,
				       highb1 - lowb1 + 1);
  ret = allocate_value (rettype);

  for (i = 0; i < highb1 - lowb1 + 1; i++)
    {
      /* For vector types, the relational, equality and logical operators shall
	 return 0 if the specified relation is false and -1 (i.e. all bits set)
	 if the specified relation is true.  */
      int tmp = scalar_relop (value_subscript (val1, i),
			      value_subscript (val2, i), op) ? -1 : 0;
      memset (value_contents_writeable (ret) + i * TYPE_LENGTH (eltype1),
	      tmp, TYPE_LENGTH (eltype1));
     }

  return ret;
}

/* Perform a cast of ARG into TYPE.  There's sadly a lot of duplication in
   here from valops.c:value_cast, opencl is different only in the
   behaviour of scalar to vector casting.  As far as possibly we're going
   to try and delegate back to the standard value_cast function. */

static struct value *
opencl_value_cast (struct type *type, struct value *arg)
{
  if (type != value_type (arg))
    {
      /* Casting scalar to vector is a special case for OpenCL, scalar
	 is cast to element type of vector then replicated into each
	 element of the vector.  First though, we need to work out if
	 this is a scalar to vector cast; code lifted from
	 valops.c:value_cast.  */
      enum type_code code1, code2;
      struct type *to_type;
      int scalar;

      to_type = check_typedef (type);

      code1 = TYPE_CODE (to_type);
      code2 = TYPE_CODE (check_typedef (value_type (arg)));

      if (code2 == TYPE_CODE_REF)
	code2 = TYPE_CODE (check_typedef (value_type (coerce_ref (arg))));

      scalar = (code2 == TYPE_CODE_INT || code2 == TYPE_CODE_BOOL
		|| code2 == TYPE_CODE_CHAR || code2 == TYPE_CODE_FLT
		|| code2 == TYPE_CODE_DECFLOAT || code2 == TYPE_CODE_ENUM
		|| code2 == TYPE_CODE_RANGE);

      if (code1 == TYPE_CODE_ARRAY && TYPE_VECTOR (to_type) && scalar)
	{
	  struct type *eltype;

	  /* Cast to the element type of the vector here as
	     value_vector_widen will error if the scalar value is
	     truncated by the cast.  To avoid the error, cast (and
	     possibly truncate) here.  */
	  eltype = check_typedef (TYPE_TARGET_TYPE (to_type));
	  arg = value_cast (eltype, arg);

	  return value_vector_widen (arg, type);
	}
      else
	/* Standard cast handler.  */
	arg = value_cast (type, arg);
    }
  return arg;
}

/* Perform a relational operation on two operands.  */

static struct value *
opencl_relop (struct expression *exp, struct value *arg1, struct value *arg2,
	      enum exp_opcode op)
{
  struct value *val;
  struct type *type1 = check_typedef (value_type (arg1));
  struct type *type2 = check_typedef (value_type (arg2));
  int t1_is_vec = (TYPE_CODE (type1) == TYPE_CODE_ARRAY
		   && TYPE_VECTOR (type1));
  int t2_is_vec = (TYPE_CODE (type2) == TYPE_CODE_ARRAY
		   && TYPE_VECTOR (type2));

  if (!t1_is_vec && !t2_is_vec)
    {
      int tmp = scalar_relop (arg1, arg2, op);
      struct type *type =
	language_bool_type (exp->language_defn, exp->gdbarch);

      val = value_from_longest (type, tmp);
    }
  else if (t1_is_vec && t2_is_vec)
    {
      val = vector_relop (exp, arg1, arg2, op);
    }
  else
    {
      /* Widen the scalar operand to a vector.  */
      struct value **v = t1_is_vec ? &arg2 : &arg1;
      struct type *t = t1_is_vec ? type2 : type1;

      if (TYPE_CODE (t) != TYPE_CODE_FLT && !is_integral_type (t))
	error (_("Argument to operation not a number or boolean."));

      *v = opencl_value_cast (t1_is_vec ? type1 : type2, *v);
      val = vector_relop (exp, arg1, arg2, op);
    }

  return val;
}

/* Expression evaluator for the OpenCL.  Most operations are delegated to
   evaluate_subexp_standard; see that function for a description of the
   arguments.  */

static struct value *
evaluate_subexp_opencl (struct type *expect_type, struct expression *exp,
		   int *pos, enum noside noside)
{
  enum exp_opcode op = exp->elts[*pos].opcode;
  struct value *arg1 = NULL;
  struct value *arg2 = NULL;
  struct type *type1, *type2;

  switch (op)
    {
    /* Handle assignment and cast operators to support OpenCL-style
       scalar-to-vector widening.  */
    case BINOP_ASSIGN:
      (*pos)++;
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      type1 = value_type (arg1);
      arg2 = evaluate_subexp (type1, exp, pos, noside);

      if (noside == EVAL_SKIP || noside == EVAL_AVOID_SIDE_EFFECTS)
	return arg1;

      if (deprecated_value_modifiable (arg1)
	  && VALUE_LVAL (arg1) != lval_internalvar)
	arg2 = opencl_value_cast (type1, arg2);

      return value_assign (arg1, arg2);

    case UNOP_CAST:
      type1 = exp->elts[*pos + 1].type;
      (*pos) += 2;
      arg1 = evaluate_subexp (type1, exp, pos, noside);

      if (noside == EVAL_SKIP)
	return value_from_longest (builtin_type (exp->gdbarch)->
				   builtin_int, 1);

      return opencl_value_cast (type1, arg1);

    case UNOP_CAST_TYPE:
      (*pos)++;
      arg1 = evaluate_subexp (NULL, exp, pos, EVAL_AVOID_SIDE_EFFECTS);
      type1 = value_type (arg1);
      arg1 = evaluate_subexp (type1, exp, pos, noside);

      if (noside == EVAL_SKIP)
	return value_from_longest (builtin_type (exp->gdbarch)->
				   builtin_int, 1);

      return opencl_value_cast (type1, arg1);

    /* Handle binary relational and equality operators that are either not
       or differently defined for GNU vectors.  */
    case BINOP_EQUAL:
    case BINOP_NOTEQUAL:
    case BINOP_LESS:
    case BINOP_GTR:
    case BINOP_GEQ:
    case BINOP_LEQ:
      (*pos)++;
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      arg2 = evaluate_subexp (value_type (arg1), exp, pos, noside);

      if (noside == EVAL_SKIP)
	return value_from_longest (builtin_type (exp->gdbarch)->
				   builtin_int, 1);

      return opencl_relop (exp, arg1, arg2, op);

    /* Handle the logical unary operator not(!).  */
    case UNOP_LOGICAL_NOT:
      (*pos)++;
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);

      if (noside == EVAL_SKIP)
	return value_from_longest (builtin_type (exp->gdbarch)->
				   builtin_int, 1);

      return opencl_logical_not (exp, arg1);

    /* Handle the logical operator and(&&) and or(||).  */
    case BINOP_LOGICAL_AND:
    case BINOP_LOGICAL_OR:
      (*pos)++;
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);

      if (noside == EVAL_SKIP)
	{
	  evaluate_subexp (NULL_TYPE, exp, pos, noside);

	  return value_from_longest (builtin_type (exp->gdbarch)->
				     builtin_int, 1);
	}
      else
	{
	  /* For scalar operations we need to avoid evaluating operands
	     unecessarily.  However, for vector operations we always need to
	     evaluate both operands.  Unfortunately we only know which of the
	     two cases apply after we know the type of the second operand.
	     Therefore we evaluate it once using EVAL_AVOID_SIDE_EFFECTS.  */
	  int oldpos = *pos;

	  arg2 = evaluate_subexp (NULL_TYPE, exp, pos,
				  EVAL_AVOID_SIDE_EFFECTS);
	  *pos = oldpos;
	  type1 = check_typedef (value_type (arg1));
	  type2 = check_typedef (value_type (arg2));

	  if ((TYPE_CODE (type1) == TYPE_CODE_ARRAY && TYPE_VECTOR (type1))
	      || (TYPE_CODE (type2) == TYPE_CODE_ARRAY && TYPE_VECTOR (type2)))
	    {
	      arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);

	      return opencl_relop (exp, arg1, arg2, op);
	    }
	  else
	    {
	      /* For scalar built-in types, only evaluate the right
		 hand operand if the left hand operand compares
		 unequal(&&)/equal(||) to 0.  */
	      int res;
	      int tmp = value_logical_not (arg1);

	      if (op == BINOP_LOGICAL_OR)
		tmp = !tmp;

	      arg2 = evaluate_subexp (NULL_TYPE, exp, pos,
				      tmp ? EVAL_SKIP : noside);
	      type1 = language_bool_type (exp->language_defn, exp->gdbarch);

	      if (op == BINOP_LOGICAL_AND)
		res = !tmp && !value_logical_not (arg2);
	      else /* BINOP_LOGICAL_OR */
		res = tmp || !value_logical_not (arg2);

	      return value_from_longest (type1, res);
	    }
	}

    /* Handle the ternary selection operator.  */
    case TERNOP_COND:
      (*pos)++;
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      type1 = check_typedef (value_type (arg1));
      if (TYPE_CODE (type1) == TYPE_CODE_ARRAY && TYPE_VECTOR (type1))
	{
	  struct value *arg3, *tmp, *ret;
	  struct type *eltype2, *type3, *eltype3;
	  int t2_is_vec, t3_is_vec, i;
	  LONGEST lowb1, lowb2, lowb3, highb1, highb2, highb3;

	  arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
	  arg3 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
	  type2 = check_typedef (value_type (arg2));
	  type3 = check_typedef (value_type (arg3));
	  t2_is_vec
	    = TYPE_CODE (type2) == TYPE_CODE_ARRAY && TYPE_VECTOR (type2);
	  t3_is_vec
	    = TYPE_CODE (type3) == TYPE_CODE_ARRAY && TYPE_VECTOR (type3);

	  /* Widen the scalar operand to a vector if necessary.  */
	  if (t2_is_vec || !t3_is_vec)
	    {
	      arg3 = opencl_value_cast (type2, arg3);
	      type3 = value_type (arg3);
	    }
	  else if (!t2_is_vec || t3_is_vec)
	    {
	      arg2 = opencl_value_cast (type3, arg2);
	      type2 = value_type (arg2);
	    }
	  else if (!t2_is_vec || !t3_is_vec)
	    {
	      /* Throw an error if arg2 or arg3 aren't vectors.  */
	      error (_("\
Cannot perform conditional operation on incompatible types"));
	    }

	  eltype2 = check_typedef (TYPE_TARGET_TYPE (type2));
	  eltype3 = check_typedef (TYPE_TARGET_TYPE (type3));

	  if (!get_array_bounds (type1, &lowb1, &highb1)
	      || !get_array_bounds (type2, &lowb2, &highb2)
	      || !get_array_bounds (type3, &lowb3, &highb3))
	    error (_("Could not determine the vector bounds"));

	  /* Throw an error if the types of arg2 or arg3 are incompatible.  */
	  if (TYPE_CODE (eltype2) != TYPE_CODE (eltype3)
	      || TYPE_LENGTH (eltype2) != TYPE_LENGTH (eltype3)
	      || TYPE_UNSIGNED (eltype2) != TYPE_UNSIGNED (eltype3)
	      || lowb2 != lowb3 || highb2 != highb3)
	    error (_("\
Cannot perform operation on vectors with different types"));

	  /* Throw an error if the sizes of arg1 and arg2/arg3 differ.  */
	  if (lowb1 != lowb2 || lowb1 != lowb3
	      || highb1 != highb2 || highb1 != highb3)
	    error (_("\
Cannot perform conditional operation on vectors with different sizes"));

	  ret = allocate_value (type2);

	  for (i = 0; i < highb1 - lowb1 + 1; i++)
	    {
	      tmp = value_logical_not (value_subscript (arg1, i)) ?
		    value_subscript (arg3, i) : value_subscript (arg2, i);
	      memcpy (value_contents_writeable (ret) +
		      i * TYPE_LENGTH (eltype2), value_contents_all (tmp),
		      TYPE_LENGTH (eltype2));
	    }

	  return ret;
	}
      else
	{
	  if (value_logical_not (arg1))
	    {
	      /* Skip the second operand.  */
	      evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);

	      return evaluate_subexp (NULL_TYPE, exp, pos, noside);
	    }
	  else
	    {
	      /* Skip the third operand.  */
	      arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
	      evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);

	      return arg2;
	    }
	}

    /* Handle STRUCTOP_STRUCT to allow component access on OpenCL vectors.  */
    case STRUCTOP_STRUCT:
      {
	int pc = (*pos)++;
	int tem = longest_to_int (exp->elts[pc + 1].longconst);

	(*pos) += 3 + BYTES_TO_EXP_ELEM (tem + 1);
	arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
	type1 = check_typedef (value_type (arg1));

	if (noside == EVAL_SKIP)
	  {
	    return value_from_longest (builtin_type (exp->gdbarch)->
				       builtin_int, 1);
	  }
	else if (TYPE_CODE (type1) == TYPE_CODE_ARRAY && TYPE_VECTOR (type1))
	  {
	    return opencl_component_ref (exp, arg1, &exp->elts[pc + 2].string,
					 noside);
	  }
	else
	  {
	    struct value *v = value_struct_elt (&arg1, NULL,
						&exp->elts[pc + 2].string, NULL,
						"structure");

	    if (noside == EVAL_AVOID_SIDE_EFFECTS)
	      v = value_zero (value_type (v), not_lval);
	    return v;
	  }
      }
    default:
      break;
    }

  return evaluate_subexp_c (expect_type, exp, pos, noside);
}

/* Print OpenCL types.  */

static void
opencl_print_type (struct type *type, const char *varstring,
		   struct ui_file *stream, int show, int level,
		   const struct type_print_options *flags)
{
  /* We nearly always defer to C type printing, except that vector
     types are considered primitive in OpenCL, and should always
     be printed using their TYPE_NAME.  */
  if (show > 0)
    {
      CHECK_TYPEDEF (type);
      if (TYPE_CODE (type) == TYPE_CODE_ARRAY && TYPE_VECTOR (type)
	  && TYPE_NAME (type) != NULL)
	show = 0;
    }

  c_print_type (type, varstring, stream, show, level, flags); 
}

static void
opencl_language_arch_info (struct gdbarch *gdbarch,
			   struct language_arch_info *lai)
{
  struct type **types = builtin_opencl_type (gdbarch);

  /* Copy primitive types vector from gdbarch.  */
  lai->primitive_type_vector = types;

  /* Type of elements of strings.  */
  lai->string_char_type = types [opencl_primitive_type_char];

  /* Specifies the return type of logical and relational operations.  */
  lai->bool_type_symbol = "int";
  lai->bool_type_default = types [opencl_primitive_type_int];
}

const struct exp_descriptor exp_descriptor_opencl =
{
  print_subexp_standard,
  operator_length_standard,
  operator_check_standard,
  op_name_standard,
  dump_subexp_body_standard,
  evaluate_subexp_opencl
};

const struct language_defn opencl_language_defn =
{
  "opencl",			/* Language name */
  language_opencl,
  range_check_off,
  case_sensitive_on,
  array_row_major,
  macro_expansion_c,
  &exp_descriptor_opencl,
  c_parse,
  c_error,
  null_post_parser,
  c_printchar,			/* Print a character constant */
  c_printstr,			/* Function to print string constant */
  c_emit_char,			/* Print a single char */
  opencl_print_type,		/* Print a type using appropriate syntax */
  c_print_typedef,		/* Print a typedef using appropriate syntax */
  c_val_print,			/* Print a value using appropriate syntax */
  c_value_print,		/* Print a top-level value */
  default_read_var_value,	/* la_read_var_value */
  NULL,				/* Language specific skip_trampoline */
  NULL,                         /* name_of_this */
  basic_lookup_symbol_nonlocal,	/* lookup_symbol_nonlocal */
  basic_lookup_transparent_type,/* lookup_transparent_type */
  NULL,				/* Language specific symbol demangler */
  NULL,				/* Language specific
				   class_name_from_physname */
  c_op_print_tab,		/* expression operators for printing */
  1,				/* c-style arrays */
  0,				/* String lower bound */
  default_word_break_characters,
  default_make_symbol_completion_list,
  opencl_language_arch_info,
  default_print_array_index,
  default_pass_by_reference,
  c_get_string,
  NULL,				/* la_get_symbol_name_cmp */
  iterate_over_symbols,
  LANG_MAGIC
};

static void *
build_opencl_types (struct gdbarch *gdbarch)
{
  struct type **types
    = GDBARCH_OBSTACK_CALLOC (gdbarch, nr_opencl_primitive_types + 1,
			      struct type *);

/* Helper macro to create strings.  */
#define OCL_STRING(S) #S
/* This macro allocates and assigns the type struct pointers
   for the vector types.  */
#define BUILD_OCL_VTYPES(TYPE)\
  types[opencl_primitive_type_##TYPE##2] \
    = init_vector_type (types[opencl_primitive_type_##TYPE], 2); \
  TYPE_NAME (types[opencl_primitive_type_##TYPE##2]) = OCL_STRING(TYPE ## 2); \
  types[opencl_primitive_type_##TYPE##3] \
    = init_vector_type (types[opencl_primitive_type_##TYPE], 3); \
  TYPE_NAME (types[opencl_primitive_type_##TYPE##3]) = OCL_STRING(TYPE ## 3); \
  TYPE_LENGTH (types[opencl_primitive_type_##TYPE##3]) \
    = 4 * TYPE_LENGTH (types[opencl_primitive_type_##TYPE]); \
  types[opencl_primitive_type_##TYPE##4] \
    = init_vector_type (types[opencl_primitive_type_##TYPE], 4); \
  TYPE_NAME (types[opencl_primitive_type_##TYPE##4]) = OCL_STRING(TYPE ## 4); \
  types[opencl_primitive_type_##TYPE##8] \
    = init_vector_type (types[opencl_primitive_type_##TYPE], 8); \
  TYPE_NAME (types[opencl_primitive_type_##TYPE##8]) = OCL_STRING(TYPE ## 8); \
  types[opencl_primitive_type_##TYPE##16] \
    = init_vector_type (types[opencl_primitive_type_##TYPE], 16); \
  TYPE_NAME (types[opencl_primitive_type_##TYPE##16]) = OCL_STRING(TYPE ## 16)

  types[opencl_primitive_type_char]
    = arch_integer_type (gdbarch, 8, 0, "char");
  BUILD_OCL_VTYPES (char);
  types[opencl_primitive_type_uchar]
    = arch_integer_type (gdbarch, 8, 1, "uchar");
  BUILD_OCL_VTYPES (uchar);
  types[opencl_primitive_type_short]
    = arch_integer_type (gdbarch, 16, 0, "short");
  BUILD_OCL_VTYPES (short);
  types[opencl_primitive_type_ushort]
    = arch_integer_type (gdbarch, 16, 1, "ushort");
  BUILD_OCL_VTYPES (ushort);
  types[opencl_primitive_type_int]
    = arch_integer_type (gdbarch, 32, 0, "int");
  BUILD_OCL_VTYPES (int);
  types[opencl_primitive_type_uint]
    = arch_integer_type (gdbarch, 32, 1, "uint");
  BUILD_OCL_VTYPES (uint);
  types[opencl_primitive_type_long]
    = arch_integer_type (gdbarch, 64, 0, "long");
  BUILD_OCL_VTYPES (long);
  types[opencl_primitive_type_ulong]
    = arch_integer_type (gdbarch, 64, 1, "ulong");
  BUILD_OCL_VTYPES (ulong);
  types[opencl_primitive_type_half]
    = arch_float_type (gdbarch, 16, "half", floatformats_ieee_half);
  BUILD_OCL_VTYPES (half);
  types[opencl_primitive_type_float]
    = arch_float_type (gdbarch, 32, "float", floatformats_ieee_single);
  BUILD_OCL_VTYPES (float);
  types[opencl_primitive_type_double]
    = arch_float_type (gdbarch, 64, "double", floatformats_ieee_double);
  BUILD_OCL_VTYPES (double);
  types[opencl_primitive_type_bool]
    = arch_boolean_type (gdbarch, 8, 1, "bool");
  types[opencl_primitive_type_unsigned_char]
    = arch_integer_type (gdbarch, 8, 1, "unsigned char");
  types[opencl_primitive_type_unsigned_short]
    = arch_integer_type (gdbarch, 16, 1, "unsigned short");
  types[opencl_primitive_type_unsigned_int]
    = arch_integer_type (gdbarch, 32, 1, "unsigned int");
  types[opencl_primitive_type_unsigned_long]
    = arch_integer_type (gdbarch, 64, 1, "unsigned long");
  types[opencl_primitive_type_size_t]
    = arch_integer_type (gdbarch, gdbarch_ptr_bit (gdbarch), 1, "size_t");
  types[opencl_primitive_type_ptrdiff_t]
    = arch_integer_type (gdbarch, gdbarch_ptr_bit (gdbarch), 0, "ptrdiff_t");
  types[opencl_primitive_type_intptr_t]
    = arch_integer_type (gdbarch, gdbarch_ptr_bit (gdbarch), 0, "intptr_t");
  types[opencl_primitive_type_uintptr_t]
    = arch_integer_type (gdbarch, gdbarch_ptr_bit (gdbarch), 1, "uintptr_t");
  types[opencl_primitive_type_void]
    = arch_type (gdbarch, TYPE_CODE_VOID, 1, "void");

  return types;
}

/* Provide a prototype to silence -Wmissing-prototypes.  */
extern initialize_file_ftype _initialize_opencl_language;

void
_initialize_opencl_language (void)
{
  opencl_type_data = gdbarch_data_register_post_init (build_opencl_types);
  add_language (&opencl_language_defn);
}
@


1.23
log
@	PR c++/9197:
	* opencl-lang.c (evaluate_subexp_opencl) <STRUCTOP_STRUCT>: Use
	value_struct_elt, not lookup_struct_elt_type.
	* eval.c (evaluate_subexp_standard) <STRUCTOP_STRUCT,
	STRUCTOP_PTR>: Use value_struct_elt, not lookup_struct_elt_type.
	* expression.h (EVAL_AVOID_SIDE_EFFECTS): Update comment.
gdb/testsuite
	* gdb.cp/m-static.exp: Add constructor ptype tests.
	* gdb.cp/m-static.cc (single_constructor): New class.
	(main): Make instance of single_constructor.
@
text
@d1038 7
a1044 4
	    /* Also handle EVAL_AVOID_SIDE_EFFECTS.  */
	    return value_struct_elt (&arg1, NULL,
				     &exp->elts[pc + 2].string, NULL,
				     "structure");
@


1.22
log
@http://sourceware.org/ml/gdb-patches/2012-11/msg00312.html

gdb/ChangeLog
        * valarith.c (value_vector_widen): New function for replicating a
        scalar into a vector.
        (value_binop): Use value_vector_widen to widen scalar to vector
        rather than casting, this better matches gcc C behaviour.
        * valops.c (value_casst): Update logic for casting between vector
        types, and for casting from scalar to vector, try to match gcc C
        behaviour.
        * value.h (value_vector_widen): Declare.
        * opencl-lang.c (opencl_value_cast): New opencl specific casting
        function, handle special case for casting scalar to vector.
        (opencl_relop): Use opencl_value_cast.
        (evaluate_subexp_opencl): Use opencl_value_cast instead of
        value_cast, and handle BINOP_ASSIGN, UNOP_CAST, and UNOP_CAST_TYPE
        in order to use opencl_value_cast.

gdb/testsuite/ChangeLog
        * gdb.base/gnu_vector.c: New variable for use in tests.
        * gdb.base/gnu_vector.exp: Update and extend tests to reflect
        changes in scalar to vector casting and widening.
        * gdb.python/py-type.c: New variables for use in tests.
        * gdb.python/py-type.exp: Update vector related tests to reflect
        changes in scalar to vector casting and widening.
@
text
@d1038 4
a1041 9
	    if (noside == EVAL_AVOID_SIDE_EFFECTS)
	      return
		  value_zero (lookup_struct_elt_type
			      (value_type (arg1),&exp->elts[pc + 2].string, 0),
			      lval_memory);
	    else
	      return value_struct_elt (&arg1, NULL,
				       &exp->elts[pc + 2].string, NULL,
				       "structure");
@


1.21
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d686 52
d773 1
a773 1
      *v = value_cast (t1_is_vec ? type1 : type2, *v);
d795 40
d947 1
a947 1
	      arg3 = value_cast (type2, arg3);
d952 1
a952 1
	      arg2 = value_cast (type3, arg2);
@


1.20
log
@ChangeLog:

	* opencl-lang.c (opencl_print_type): New function.
	(opencl_language_arch_info): Install it.

testsuite/ChangeLog:

	* gdb.opencl/convs_casts.exp: Always expect standard vector type names.
	* gdb.opencl/datatypes.exp: Likewise.
	* gdb.opencl/operators.exp: Likewise.
	* gdb.opencl/vec_comps.exp: Likewise.
@
text
@d2 1
a2 1
   Copyright (C) 2010-2012 Free Software Foundation, Inc.
@


1.19
log
@	PR c++/13356
	* gdbtypes.c (strict_type_checking): New variable.
	(show_strict_type_checking): New function.
	(rank_one_type): Return NS_POINTER_INTEGER_CONVERSION_BADNESS
	if strict type checking is disabled.
	(_initialize_gdbtypes): Add "check type" subcommand.
	* gdbtypes.h (NS_INTEGER_POINTER_CONVERSION_BADNESS): New struct.

	PR c++/13356
	* gdb.base/default.exp: Update all "check type" tests.
	* gdb.base/help.exp: Likewise.
	* gdb.base/setshow.exp: Likewise.
	* gdb.cp/converts.cc (foo1_type_check): New function.
	(foo2_type_check): New function.
	(foo3_type_check): New function.
	(main): Call new functions.
	* converts.exp: Add tests for integer-to-pointer conversions
	with/without strict type-checking.

	PR c++/13356
	* gdb.texinfo (Type and Range Checking): Remove warning.
	Remove spurious commas.
	Update text and examples for re-implementation of set/show
	check type.
	(C and C++ Type and Range Checks): Likewise.

	* language.h (type_mode): Remove.
	(type_check): Remove.
	(struct language_defn): Remove la_type_check.
	(STRICT_TYPE): Remove unused macro.
	(type_error): Remove.
	* language.c (set_type_range_case): Renamed to ...
	(set_range_case): ... this.  Update all callers.
	Remove type_mode/type_check.
	(type_mode): Remove.
	(type_check): Remove.
	(show_type_command): Remove.
	(set_type_command): Remove.
	(language_info): Remove type checking output.
	(type_error): Remove unused function.
	(range_error): Update comment.
	(unknown_language_defn): Remove la_type_check.
	(auto_language_defn): Likewise.
	(local_language_defn): Likewise.
	(_initialize_language): Remove "check type" subcommand.
	* ada-lang.c (ada_language_defn): Remove la_type_check.
	* c-lang.c (c_language_defn): Likewise.
	(cplus_language_defn): Likewise.
	(asm_language_defn): Likewise.
	(minimal_language_defn): Likewise.
	* d-lang.c (d_language_defn): Likewise.
	* f-lang.c (f_language_defn): Likewise.
	* go-lang.c (go_language_defn): Likewise.
	* jv-lang.c (java_language_defn): Likewise.
	* m2-lang.c (m2_language_defn): Likewise.
	* objc-lang.c (objc_language_defn): Likewise.
	* opencl-lang.c (opencl_language_defn): Likewise.
	* p-lang.c (pascal_language_defn): Likewise.
@
text
@d964 21
d1027 1
a1027 1
  c_print_type,			/* Print a type using appropriate syntax */
@


1.18
log
@language-specific read_var_value for Ada renamings

The purpose of this patch is to better support renamings in the
"info locals" command. Consider ...

    procedure Foo is
       GV : Integer renames Pck.Global_Variable;
    begin
       Increment (GV); -- STOP
    end Foo;

... Pck.Global_Variable is just an integer. After having stopped at
the "STOP" line, "info locals" yields:

    (gdb) info locals
    gv = <error reading variable gv (Cannot access memory at address 0xffffffffffffffff)>

In reality, two things are happening:

   (1) Variable "GV" does not exist, which is normal, since there is
       "GV" the renaming of another variable;

   (2) But to allow the user access to that renaming the same way
       the code has, the compiler produces an artificial variable
       whose name encodes the renaming:

        gv___XR_pck__global_variable___XE

       For practical reasons, the artificial variable itself is given
       irrelevant types and addresses.

But the "info locals" command does not act as if it was a short-cut
of "foreach VAR in locals, print VAR". Instead it gets the value of
each VAR directly, which does not work in this case, since the variable
is artificial and needs to be decoded first.

This patch makes the "read_var_value" routine language-specific.
The old implementation of "read_var_value" gets renamed to
"default_read_var_value" and all languages now use it (unchanged
behavior), except for Ada. In Ada, the new function ada_read_var_value
checks if we have a renaming, and if so, evaluates its value, or else
defers to default_read_var_value.

gdb/ChangeLog:

        * language.h (struct language_defn): New "method" la_read_var_value.
        * findvar.c: #include "language.h".
        (default_read_var_value): Renames read_var_value.  Rewrite
        function description.
        (read_var_value): New function.
        * value.h (default_read_var_value): Add prototype.
        * ada-lang.c (ada_read_renaming_var_value, ada_read_var_value):
        New functions.
        (ada_language_defn): Add entry for la_read_var_value.
        * c-lang.c, d-lang.c, f-lang.c, jv-lang.c, language.c,
        * m2-lang.c, objc-lang.c, opencl-lang.c, p-lang.c: Update
        language_defn structures to add entry for new la_read_var_value
        field.
@
text
@a995 1
  type_check_off,
@


1.17
log
@2012-03-01  Pedro Alves  <palves@@redhat.com>

	* amd64-linux-tdep.c (amd64_linux_record_signal): Make static.
	* breakpoint.c (create_exception_master_breakpoint, trace_command)
	(ftrace_command, strace_command): Make static.
	* d-lang.c (_initialize_d_language): Declare.
	* dwarf2expr.c (_initialize_dwarf2expr): Declare.
	* dwarf2loc.c (_initialize_dwarf2loc):
	* dwarf2read.c (process_psymtab_comp_unit): Make static.
	* exec.c (exec_get_section_table): Make static.
	* i386-linux-tdep.c (i386_linux_record_signal): Make static.
	* infcmd.c (ensure_valid_thread, ensure_not_tfind_mode): Make static.
	* inferior.c (remove_inferior_command, add_inferior_command)
	(clone_inferior_command): Make static.
	* linux-nat.c (linux_nat_thread_address_space)
	(linux_nat_core_of_thread): Make static.
	* linux-tdep.c (_initialize_linux_tdep): Declare.
	* objc-lang.c (_initialize_objc_lang): Declare.
	* opencl-lang.c (builtin_opencl_type, opencl_language_arch_info):
	Make static.
	(_initialize_opencl_language): Declare.
	* record.c (_initialize_record): Declare.
	* remote.c (demand_private_info, remote_get_tib_address)
	(remote_supports_cond_tracepoints)
	(remote_supports_fast_tracepoints, remote_get_tracepoint_status):
	Make static.
	* skip.c (_initialize_step_skip): Declare.
	* symtab.c (skip_prologue_using_lineinfo): Make static.
	* tracepoint.c (delete_trace_state_variable)
	(trace_variable_command, delete_trace_variable_command)
	(get_uploaded_tsv, find_matching_tracepoint_location)
	(find_matching_tsv, create_tsv_from_upload, get_traceframe_info):
	Make static.
	* value.c (pack_unsigned_long): Make static.
	* varobj.c (varobj_ensure_python_env): Make static.
	* windows-tdep.c (_initialize_windows_tdep): Declare.
	* xml-syscall.c (make_cleanup_free_syscalls_info): Make static.
@
text
@d1011 1
@


1.16
log
@Rename la_get_symbol_name_match_p into la_get_symbol_name_cmp

The la_get_symbol_name_match_p language hook was poorly named, as
it suggested that the function should return nonzero if the names
match, whereas it is the exact opposite.  This patch therefore
renames the hook and associated typedef, as well some of the code
that uses that hook.

gdb/ChangeLog:

        * language.h (symbol_name_cmp_ftype): Renames
        symbol_name_match_p_ftype.
        (struct language_defn)[la_get_symbol_name_cmp]: Renames
        la_get_symbol_name_match_p.
        * ada-lang.c (ada_get_symbol_name_cmp): Renames
        ada_get_symbol_name_match_p.  Update comment.
        (ada_language_defn)[la_get_symbol_name_cmp]: Update value.
        * linespec.c (struct symbol_matcher_data)[symbol_name_cmp]:
        Renames symbol_name_match_p.  Update field type.
        (iterate_name_matcher, iterate_over_all_matching_symtabs): Adjust.
        * c-lang.c, d-lang.c, f-lang.c, jv-lang.c, m2-lang.c, objc-lang.c,
        opencl-lang.c, p-lang.c: Replace "la_get_symbol_name_match_p" by
        "la_get_symbol_name_cmp" in comments.
        * language.c: Likewise.
@
text
@d71 1
a71 1
struct type **
d964 1
a964 1
void
d1119 3
@


1.15
log
@Ada: allow unqualified function names in linespecs

This is the meat, where we replace the old la_symbol_name_compare
language method with the new ada_get_symbol_name_match_p.
It fixes the problem when trying to insert a breakpoint on "+".

gdb/ChangeLog:

        * language.h (symbol_name_match_p_ftype): New typedef.
        (struct language_defn): Replace field la_symbol_name_compare
        by la_get_symbol_name_match_p.
        * ada-lang.c (ada_get_symbol_name_match_p): New function.
        (ada_language_defn): Use it.
        * linespec.c (struct symbol_matcher_data): New type.
        (iterate_name_matcher): Rewrite.
        (iterate_over_all_matching_symtabs): Pass a pointer to
        a symbol_matcher_data struct to expand_symtabs_matching
        instead of just the lookup name.
        * c-lang.c, d-lang.c, jv-lang.c, m2-lang.c, objc-lang.c,
        opencl-lang.c, p-lang.c, language.c: Delete field
        la_symbol_name_compare, and replace by NULL for new field
        la_get_symbol_name_match_p.
        * symfile.h (struct quick_symbol_functions): Update comment.
@
text
@d1027 1
a1027 1
  NULL,				/* la_get_symbol_name_match_p */
@


1.14
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d1027 1
a1027 1
  strcmp_iw_ordered,
@


1.13
log
@the "ambiguous linespec" series
gdb
2011-12-06  Joel Brobecker  <brobecker@@acacore.com>

        * language.h (struct language_defn): Add new component
        la_symbol_name_compare.
        * symfile.h (struct quick_symbol_functions): Update the profile
        of parameter "name_matcher" for the expand_symtabs_matching
        method.  Update the documentation accordingly.
        * ada-lang.h (ada_name_for_lookup): Add declaration.
        * ada-lang.c (ada_name_for_lookup): New function, extracted out
        from ada_iterate_over_symbols.
        (ada_iterate_over_symbols): Do not encode symbol name anymore.
        (ada_expand_partial_symbol_name): Adjust profile.
        (ada_language_defn): Add value for la_symbol_name_compare field.
        * linespec.c: #include "ada-lang.h".
        (iterate_name_matcher): Add language parameter. Replace call
        to strcmp_iw by call to language->la_symbol_name_compare.
        (decode_variable): Encode COPY if current language is Ada.
        * dwarf2read.c (dw2_expand_symtabs_matching): Adjust profile
        of name_matcher parameter.  Adjust call to name_matcher.
        * psymtab.c (expand_symtabs_matching_via_partial): Likewise.
        (expand_partial_symbol_names): Update profile of parameter "fun".
        * psymtab.h (expand_partial_symbol_names): Update profile of
        parameter "fun".
        * symtab.c (demangle_for_lookup): Update function documentation.
        (search_symbols_name_matches): Add language parameter.
        (expand_partial_symbol_name): Likewise.
        * c-lang.c (c_language_defn, cplus_language_defn)
        (asm_language_defn, minimal_language_defn): Add value for
        la_symbol_name_compare field.
        * d-lang.c (d_language_defn): Likewise.
        * f-lang.c (f_language_defn): Ditto.
        * jv-lang.c (java_language_defn): Ditto.
        * m2-lang.c (m2_language_defn): Ditto.
        * objc-lang.c (objc_language_defn): Ditto.
        * opencl-lang.c (opencl_language_defn): Ditto.
        * p-lang.c (pascal_language_defn): Ditto.
        * language.c (unknown_language_defn, auto_language_defn)
        (local_language_defn): Ditto.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* linespec.c (iterate_over_all_matching_symtabs): Use
	LA_ITERATE_OVER_SYMBOLS.
	(lookup_prefix_sym, add_matching_symbols_to_info): Likewise.
	(find_function_symbols, decode_variable): Remove Ada special
	case.
	* language.h (struct language_defn) <la_iterate_over_symbols>: New
	field.
	(LA_ITERATE_OVER_SYMBOLS): New macro.
	* language.c (unknown_language_defn, auto_language_defn)
	(local_language_defn): Update.
	* c-lang.c (c_language_defn, cplus_language_defn)
	(asm_language_defn, minimal_language_defn): Update.
	* d-lang.c (d_language_defn): Update.
	* f-lang.c (f_language_defn): Update.
	* jv-lang.c (java_language_defn): Update.
	* m2-lang.c (m2_language_defn): Update.
	* objc-lang.c (objc_language_defn): Update.
	* opencl-lang.c (opencl_language_defn): Update.
	* p-lang.c (pascal_language_defn): Update.
	* ada-lang.c (ada_iterate_over_symbols): New function.
	(ada_language_defn): Update.

2011-12-06  Tom Tromey  <tromey@@redhat.com>
	    Joel Brobecker  <brobecker@@acacore.com>

	PR breakpoints/13105, PR objc/8341, PR objc/8343, PR objc/8366,
	PR objc/8535, PR breakpoints/11657, PR breakpoints/11970,
	PR breakpoints/12023, PR breakpoints/12334, PR breakpoints/12856,
	PR shlibs/8929, PR shlibs/7393:
	* python/py-type.c (compare_maybe_null_strings): Rename from
	compare_strings.
	(check_types_equal): Update.
	* utils.c (compare_strings): New function.
	* tui/tui-winsource.c (tui_update_breakpoint_info): Update for
	location changes.
	* tracepoint.c (scope_info): Update.
	(trace_find_line_command): Use DECODE_LINE_FUNFIRSTLINE.
	* symtab.h (iterate_over_minimal_symbols)
	(iterate_over_some_symtabs, iterate_over_symtabs)
	(find_pcs_for_symtab_line, iterate_over_symbols)
	(demangle_for_lookup): Declare.
	(expand_line_sal): Remove.
	* symtab.c (iterate_over_some_symtabs, iterate_over_symtabs)
	(lookup_symtab_callback): New functions.
	(lookup_symtab): Rewrite.
	(demangle_for_lookup): New function, extract from
	lookup_symbol_in_language.
	(lookup_symbol_in_language): Use it.
	(iterate_over_symbols): New function.
	(find_line_symtab): Update.
	(find_pcs_for_symtab_line): New functions.
	(find_line_common): Add 'start' argument.
	(decode_line_spec): Update.  Change argument to 'flags', change
	interpretation.
	(append_expanded_sal): Remove.
	(append_exact_match_to_sals): Remove.
	(expand_line_sal): Remove.
	* symfile.h (struct quick_symbol_functions) <lookup_symtab>:
	Remove.
	<map_symtabs_matching_filename>: New field.
	* stack.c (func_command): Only look in the current program space.
	Use DECODE_LINE_FUNFIRSTLINE.
	* source.c (line_info): Set pspace on sal.  Check program space in
	the loop.  Use DECODE_LINE_LIST_MODE.
	(select_source_symtab): Use DECODE_LINE_FUNFIRSTLINE.
	* solib-target.c: Remove DEF_VEC_I(CORE_ADDR).
	* python/python.c (gdbpy_decode_line): Update.
	* psymtab.c (partial_map_expand_apply): New function.
	(partial_map_symtabs_matching_filename): Rename from
	lookup_partial_symbol.  Update arguments.
	(lookup_symtab_via_partial_symtab): Remove.
	(psym_functions): Update.
	* objc-lang.h (parse_selector, parse_method): Don't declare.
	(find_imps): Update.
	* objc-lang.c (parse_selector, parse_method): Now static.
	(find_methods): Change arguments.  Fill in a vector of symbol
	names.
	(uniquify_strings): New function.
	(find_imps): Change arguments.
	* minsyms.c (iterate_over_minimal_symbols): New function.
	* linespec.h (enum decode_line_flags): New.
	(struct linespec_sals): New.
	(struct linespec_result) <canonical>: Remove.
	<pre_expanded, addr_string, sals>: New fields.
	(destroy_linespec_result, make_cleanup_destroy_linespec_result)
	(decode_line_full): Declare.
	(decode_line_1): Update.
	* linespec.c (struct address_entry, struct linespec_state, struct
	collect_info): New types.
	(add_sal_to_sals_basic, add_sal_to_sals, hash_address_entry)
	(eq_address_entry, maybe_add_address): New functions.
	(total_number_of_methods): Remove.
	(iterate_name_matcher, iterate_over_all_matching_symtabs): New
	functions.
	(find_methods): Change arguments.  Don't canonicalize input.
	Simplify logic.
	(add_matching_methods, add_constructors)
	(build_canonical_line_spec): Remove.
	(filter_results, convert_results_to_lsals): New functions.
	(decode_line_2): Change arguments.  Rewrite for new data
	structures.
	(decode_line_internal): Rename from decode_line_1.  Change
	arguments.  Add cleanups.  Update for new data structures.
	(linespec_state_constructor, linespec_state_destructor)
	(decode_line_full, decode_line_1): New functions.
	(decode_indirect): Change arguments.  Update.
	(locate_first_half): Use skip_spaces.
	(decode_objc): Change arguments.  Update for new data structures.
	Simplify logic.
	(decode_compound): Change arguments.  Add cleanups.  Remove
	fallback code, replace with error.
	(struct decode_compound_collector): New type.
	(collect_one_symbol): New function.
	(lookup_prefix_sym): Change arguments.  Update.
	(compare_symbol_name, add_all_symbol_names_from_pspace)
	(find_superclass_methods ): New functions.
	(find_method): Rewrite.
	(struct symtab_collector): New type.
	(add_symtabs_to_list, collect_symtabs_from_filename): New
	functions.
	(symtabs_from_filename): Change API.  Rename from
	symtab_from_filename.
	(collect_function_symbols): New function.
	(find_function_symbols): Change API.  Rename from
	find_function_symbol.  Rewrite.
	(decode_all_digits): Change arguments.  Rewrite.
	(decode_dollar): Change arguments.  Use decode_variable.
	(decode_label): Change arguments.  Rewrite.
	(collect_symbols): New function.
	(minsym_found): Change arguments.  Rewrite.
	(check_minsym, search_minsyms_for_name)
	(add_matching_symbols_to_info): New function.
	(decode_variable): Change arguments.  Iterate over all symbols.
	(symbol_found): Remove.
	(symbol_to_sal): New function.
	(init_linespec_result, destroy_linespec_result)
	(cleanup_linespec_result, make_cleanup_destroy_linespec_result):
	New functions.
	(decode_digits_list_mode, decode_digits_ordinary): New functions.
	* dwarf2read.c (dw2_map_expand_apply): New function.
	(dw2_map_symtabs_matching_filename): Rename from
	dw2_lookup_symtab.  Change arguments.
	(dwarf2_gdb_index_functions): Update.
	* dwarf2loc.c: Remove DEF_VEC_I(CORE_ADDR).
	* defs.h (compare_strings): Declare.
	* cli/cli-cmds.c (compare_strings): Move to utils.c.
	(edit_command, list_command): Use DECODE_LINE_LIST_MODE.  Call
	filter_sals.
	(compare_symtabs, filter_sals): New functions.
	* breakpoint.h (struct bp_location) <line_number, source_file>:
	New fields.
	(struct breakpoint) <line_number, source_file>: Remove.
	<filter>: New field.
	* breakpoint.c (print_breakpoint_location, init_raw_breakpoint)
	(momentary_breakpoint_from_master, add_location_to_breakpoint):
	Update for changes to locations.
	(init_breakpoint_sal): Add 'filter' argument.  Set 'filter' on
	breakpoint.
	(create_breakpoint_sal): Add 'filter' argument.
	(remove_sal, expand_line_sal_maybe): Remove.
	(create_breakpoints_sal): Remove 'sals' argument.  Handle
	pre-expanded sals and the filter.
	(parse_breakpoint_sals): Use decode_line_full.
	(check_fast_tracepoint_sals): Use get_sal_arch.
	(create_breakpoint): Create a linespec_sals.  Update.
	(break_range_command): Use decode_line_full.  Update.
	(until_break_command): Update.
	(clear_command): Update match conditions for linespec.c changes.
	Use DECODE_LINE_LIST_MODE.
	(say_where): Update for changes to locations.
	(bp_location_dtor): Free 'source_file'.
	(base_breakpoint_dtor): Free 'filter'.  Don't free 'source_file'.
	(update_static_tracepoint): Update for changes to locations.
	(update_breakpoint_locations): Disable ranged breakpoint if too
	many locations match.  Update.
	(addr_string_to_sals): Use decode_line_full.  Resolve all sal
	PCs.
	(breakpoint_re_set_default): Don't call expand_line_sal_maybe.
	(decode_line_spec_1): Update.  Change argument name to 'flags',
	change interpretation.
	* block.h (block_containing_function): Declare.
	* block.c (block_containing_function): New function.
	* skip.c (skip_function_command): Update.
	(skip_re_set): Update.
	* infcmd.c (jump_command): Use DECODE_LINE_FUNFIRSTLINE.
	* mi/mi-main.c (mi_cmd_trace_find): Use DECODE_LINE_FUNFIRSTLINE.
	* NEWS: Add entry.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* elfread.c (elf_gnu_ifunc_resolver_return_stop): Allow
	breakpoint's pspace to be NULL.
	* breakpoint.h (struct breakpoint) <pspace>: Update comment.
	* breakpoint.c (init_raw_breakpoint): Conditionally set
	breakpoint's pspace.
	(init_breakpoint_sal): Don't set breakpoint's pspace.
	(prepare_re_set_context): Conditionally switch program space.
	(addr_string_to_sals): Check executing_startup on location's
	program space.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* breakpoint.h (enum enable_state) <bp_startup_disabled>: Remove.
	* breakpoint.c (should_be_inserted): Explicitly check if program
	space is executing startup.
	(describe_other_breakpoints): Update.
	(disable_breakpoints_before_startup): Change executing_startup
	earlier.  Remove loop.
	(enable_breakpoints_after_startup): Likewise.
	(init_breakpoint_sal): Don't use bp_startup_disabled.
	(create_breakpoint): Don't use bp_startup_disabled.
	(update_global_location_list): Use should_be_inserted.
	(bkpt_re_set): Update.
gdb/testsuite
2011-12-06  Joel Brobecker  <brobecker@@acacore.com>

        * gdb.ada/fullname_bp.exp: Add tests for other valid linespecs
        involving a fully qualified function name.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* gdb.ada/homonym.exp: Add three breakpoint tests.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* gdb.base/solib-weak.exp (do_test): Remove kfail.
	* gdb.trace/tracecmd.exp: Disable pending breakpoints earlier.
	* gdb.objc/objcdecode.exp: Update for output changes.
	* gdb.linespec/linespec.exp: New file.
	* gdb.linespec/lspec.cc: New file.
	* gdb.linespec/lspec.h: New file.
	* gdb.linespec/body.h: New file.
	* gdb.linespec/base/two/thefile.cc: New file.
	* gdb.linespec/base/one/thefile.cc: New file.
	* gdb.linespec/Makefile.in: New file.
	* gdb.cp/templates.exp (test_template_breakpoints): Update for
	output changes.
	* gdb.cp/re-set-overloaded.exp: Remove kfail.
	* gdb.cp/ovldbreak.exp: Update for output changes.  "all" test now
	makes one breakpoint.
	* gdb.cp/method2.exp (test_break): Update for output changes.
	* gdb.cp/mb-templates.exp: Update for output changes.
	* gdb.cp/mb-inline.exp: Update for output changes.
	* gdb.cp/mb-ctor.exp: Update for output changes.
	* gdb.cp/ovsrch.exp: Use fully-qualified names.
	* gdb.base/solib-symbol.exp: Run to main later.  Breakpoint now
	has multiple matches.
	* gdb.base/sepdebug.exp: Disable pending breakpoints.  Update for
	error message change.
	* gdb.base/list.exp (test_list_filename_and_number): Update for
	error message change.
	* gdb.base/break.exp: Disable pending breakpoints.  Update for
	output changes.
	* configure.ac: Add gdb.linespec.
	* configure: Rebuild.
	* Makefile.in (ALL_SUBDIRS): Add gdb.linespec.
gdb/doc
2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* gdb.texinfo (Set Breaks): Update for new behavior.
@
text
@d2 1
a2 1
   Copyright (C) 2010, 2011 Free Software Foundation, Inc.
@


1.13.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 1
a2 1
   Copyright (C) 2010-2012 Free Software Foundation, Inc.
@


1.12
log
@gdb/
	Display @@entry parameter values even for references.
	* ada-valprint.c (ada_val_print_1) <TYPE_CODE_REF>: Try also
	coerce_ref_if_computed.
	* c-valprint.c (c_val_print) <TYPE_CODE_REF>: Likewise.
	* dwarf2expr.c (dwarf_block_to_dwarf_reg_deref): New function.
	(execute_stack_op) <DW_OP_GNU_entry_value>: Add -1 deref_size to the
	existing push_dwarf_reg_entry_value call.  Add new detection calling
	dwarf_block_to_dwarf_reg_deref.  Update the error message.
	(ctx_no_push_dwarf_reg_entry_value): New parameter deref_size.
	* dwarf2expr.h
	(struct dwarf_expr_context_funcs) <push_dwarf_reg_entry_value>: Add new
	parameter deref_size, describe it in the comment.
	(ctx_no_push_dwarf_reg_entry_value): Add new parameter deref_size.
	(dwarf_block_to_dwarf_reg_deref): New declaration.
	* dwarf2loc.c (dwarf_entry_parameter_to_value): Add new parameter
	deref_size, describe it in the function comment.  New variables
	data_src and size, fetch the alternative block accoring to DEREF_SIZE.
	(dwarf_expr_push_dwarf_reg_entry_value): Add new parameter deref_size,
	describe it in the function comment.  Fetch the alternative block
	accoring to DEREF_SIZE.
	(entry_data_value_coerce_ref, entry_data_value_copy_closure)
	(entry_data_value_free_closure, entry_data_value_funcs): New.
	(value_of_dwarf_reg_entry): New variables checked_type, target_type,
	outer_val, target_val, val and addr.  Try to fetch and create also
	referenced value content.
	(pieced_value_funcs): NULL value for coerce_ref.
	(needs_dwarf_reg_entry_value): Add new parameter deref_size.
	* f-valprint.c (f_val_print) <TYPE_CODE_REF>: Try also
	coerce_ref_if_computed.
	* opencl-lang.c (opencl_value_funcs): NULL value for coerce_ref.
	* p-valprint.c (pascal_val_print) <TYPE_CODE_REF>: Likewise.
	* stack.c (read_frame_arg): Compare also dereferenced values.
	* value.c (value_computed_funcs): Make the parameter v const, use
	value_lval_const for it.
	(value_lval_const, coerce_ref_if_computed): New function.
	(coerce_ref): New variable retval.  Call also coerce_ref_if_computed.
	* value.h (struct lval_funcs): New field coerce_ref.
	(value_computed_funcs): Make the parameter v const.
	(value_lval_const, coerce_ref_if_computed): New declarations.

gdb/testsuite/
	Display @@entry parameter values even for references.
	* gdb.arch/amd64-entry-value.cc (reference, datap, datap_input): New
	functions.
	(main): New variables regvar, nodatavarp, stackvar1, stackvar2.  Call
	reference and datap_input.
	* gdb.arch/amd64-entry-value.exp (reference, breakhere_reference): New
	breakpoints.
	(continue to breakpoint: entry_reference: reference)
	(entry_reference: bt at entry)
	(continue to breakpoint: entry_reference: breakhere_reference)
	(entry_reference: bt, entry_reference: ptype regparam)
	(entry_reference: p regparam, entry_reference: ptype regparam@@entry)
	(entry_reference: p regparam@@entry, entry_reference: p &regparam@@entry)
	(entry_reference: p regcopy, entry_reference: p nodataparam)
	(entry_reference: p nodataparam@@entry): New tests.
@
text
@d1027 2
@


1.11
log
@gdb/
	Code cleanup - constify struct lval_funcs.
	* dwarf2loc.c (pieced_value_funcs): Make it const.
	* infrun.c (siginfo_value_funcs): Likewise.
	* opencl-lang.c (opencl_value_funcs): Likewise.
	* valops.c (value_assign, value_ind): Make the funcs variable const.
	* value.c (struct value): Make location.computed.funcs target const.
	Rearrange the comments.
	(allocate_computed_value): Make the funcs parameter target const.
	(value_computed_funcs): Return the funcs target const.
	(value_free, value_copy, set_value_component_location): Make the funcs
	variable const.
	* value.h (allocate_computed_value): Make the funcs parameter target
	const.
	(value_computed_funcs): Return the funcs target const.
	* windows-tdep.c (tlb_value_funcs): Make it const.
@
text
@d363 2
a364 1
    NULL,
@


1.10
log
@2011-02-28  Michael Snyder  <msnyder@@vmware.com>

	* opencl-lang.c (evaluate_subexp_opencl): Discard unused value.
@
text
@d357 1
a357 1
static struct lval_funcs opencl_value_funcs =
@


1.9
log
@2011-02-28  Michael Snyder  <msnyder@@vmware.com>

	* opencl-lang.c (lval_func_check_validity): Rename inner variables.
	(lval_func_check_synthetic_pointer): Ditto.
@
text
@d779 1
a779 1
	  arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
@


1.8
log
@2011-02-28  Michael Snyder  <msnyder@@vmware.com>

	* opencl-lang.c (lval_func_free_closure): Fix use-after-free.
@
text
@d266 2
a267 2
      int startoffset = (i == start) ? startrest : 0;
      int length = (i == end) ? endrest : elsize;
d269 2
a270 2
      if (!value_bits_valid (c->val, c->indices[i] * elsize + startoffset,
			     length))
d320 2
a321 2
      int startoffset = (i == start) ? startrest : 0;
      int length = (i == end) ? endrest : elsize;
d324 2
a325 2
					 c->indices[i] * elsize + startoffset,
					 length))
@


1.7
log
@	* opencl-lang.c (STRUCT_OCL_TYPE): Remove.
	(struct builtin_opencl_type): Remove.
	(builtin_opencl_type): Change return type to "struct type **".
	(lookup_opencl_vector_type): Update caller.
	(opencl_language_arch_info): Copy primitive type vector from gdbarch.
	(build_opencl_types): Install plain array of "struct type *"
	instead of "struct builtin_opencl_type".
@
text
@d351 1
a353 1
      value_free (c->val); /* Decrement the reference counter of the value.  */
@


1.6
log
@gdb/ChangeLog

2011-02-15  Ken Werner  <ken.werner@@de.ibm.com>

	* opencl-lang.c (build_opencl_types): Set the size of the built-in
	bool data type to a size of one byte.

gdb/testsuite/ChangeLog

2011-02-15  Ken Werner  <ken.werner@@de.ibm.com>

	* gdb.opencl/datatypes.exp: Expect the size of a bool to be one byte.
@
text
@a68 35
/* This macro generates the type struct declarations from a given type.  */

#define STRUCT_OCL_TYPE(TYPE)\
  struct type *builtin_##TYPE;\
  struct type *builtin_##TYPE##2;\
  struct type *builtin_##TYPE##3;\
  struct type *builtin_##TYPE##4;\
  struct type *builtin_##TYPE##8;\
  struct type *builtin_##TYPE##16

struct builtin_opencl_type
{
  STRUCT_OCL_TYPE (char);
  STRUCT_OCL_TYPE (uchar);
  STRUCT_OCL_TYPE (short);
  STRUCT_OCL_TYPE (ushort);
  STRUCT_OCL_TYPE (int);
  STRUCT_OCL_TYPE (uint);
  STRUCT_OCL_TYPE (long);
  STRUCT_OCL_TYPE (ulong);
  STRUCT_OCL_TYPE (half);
  STRUCT_OCL_TYPE (float);
  STRUCT_OCL_TYPE (double);
  struct type *builtin_bool;
  struct type *builtin_unsigned_char;
  struct type *builtin_unsigned_short;
  struct type *builtin_unsigned_int;
  struct type *builtin_unsigned_long;
  struct type *builtin_size_t;
  struct type *builtin_ptrdiff_t;
  struct type *builtin_intptr_t;
  struct type *builtin_uintptr_t;
  struct type *builtin_void;
};

d71 1
a71 1
const struct builtin_opencl_type *
d89 1
a89 1
  struct type **types = (struct type **) builtin_opencl_type (gdbarch);
d965 1
a965 1
		      struct language_arch_info *lai)
d967 1
a967 1
  const struct builtin_opencl_type *builtin = builtin_opencl_type (gdbarch);
d969 2
a970 4
  lai->string_char_type = builtin->builtin_char;
  lai->primitive_type_vector
    = GDBARCH_OBSTACK_CALLOC (gdbarch, nr_opencl_primitive_types + 1,
			      struct type *);
d972 2
a973 48
/* This macro fills the primitive_type_vector from a given type.  */
#define FILL_TYPE_VECTOR(LAI, TYPE)\
  LAI->primitive_type_vector [opencl_primitive_type_##TYPE]\
    = builtin->builtin_##TYPE;\
  LAI->primitive_type_vector [opencl_primitive_type_##TYPE##2]\
    = builtin->builtin_##TYPE##2;\
  LAI->primitive_type_vector [opencl_primitive_type_##TYPE##3]\
    = builtin->builtin_##TYPE##3;\
  LAI->primitive_type_vector [opencl_primitive_type_##TYPE##4]\
    = builtin->builtin_##TYPE##4;\
  LAI->primitive_type_vector [opencl_primitive_type_##TYPE##8]\
    = builtin->builtin_##TYPE##8;\
  LAI->primitive_type_vector [opencl_primitive_type_##TYPE##16]\
    = builtin->builtin_##TYPE##16

  FILL_TYPE_VECTOR (lai, char);
  FILL_TYPE_VECTOR (lai, uchar);
  FILL_TYPE_VECTOR (lai, short);
  FILL_TYPE_VECTOR (lai, ushort);
  FILL_TYPE_VECTOR (lai, int);
  FILL_TYPE_VECTOR (lai, uint);
  FILL_TYPE_VECTOR (lai, long);
  FILL_TYPE_VECTOR (lai, ulong);
  FILL_TYPE_VECTOR (lai, half);
  FILL_TYPE_VECTOR (lai, float);
  FILL_TYPE_VECTOR (lai, double);
  lai->primitive_type_vector [opencl_primitive_type_bool]
    = builtin->builtin_bool;
  lai->primitive_type_vector [opencl_primitive_type_unsigned_char]
    = builtin->builtin_unsigned_char;
  lai->primitive_type_vector [opencl_primitive_type_unsigned_short]
    = builtin->builtin_unsigned_short;
  lai->primitive_type_vector [opencl_primitive_type_unsigned_int]
    = builtin->builtin_unsigned_int;
  lai->primitive_type_vector [opencl_primitive_type_unsigned_long]
    = builtin->builtin_unsigned_long;
  lai->primitive_type_vector [opencl_primitive_type_half]
    = builtin->builtin_half;
  lai->primitive_type_vector [opencl_primitive_type_size_t]
    = builtin->builtin_size_t;
  lai->primitive_type_vector [opencl_primitive_type_ptrdiff_t]
    = builtin->builtin_ptrdiff_t;
  lai->primitive_type_vector [opencl_primitive_type_intptr_t]
    = builtin->builtin_intptr_t;
  lai->primitive_type_vector [opencl_primitive_type_uintptr_t]
    = builtin->builtin_uintptr_t;
  lai->primitive_type_vector [opencl_primitive_type_void]
    = builtin->builtin_void;
d977 1
a977 1
  lai->bool_type_default = builtin->builtin_int;
d1032 3
a1034 2
  struct builtin_opencl_type *builtin_opencl_type
    = GDBARCH_OBSTACK_ZALLOC (gdbarch, struct builtin_opencl_type);
d1041 17
a1057 17
  builtin_opencl_type->builtin_##TYPE##2\
    = init_vector_type (builtin_opencl_type->builtin_##TYPE, 2);\
  TYPE_NAME (builtin_opencl_type->builtin_##TYPE##2) = OCL_STRING(TYPE ## 2);\
  builtin_opencl_type->builtin_##TYPE##3\
    = init_vector_type (builtin_opencl_type->builtin_##TYPE, 3);\
  TYPE_NAME (builtin_opencl_type->builtin_##TYPE##3) = OCL_STRING(TYPE ## 3);\
  TYPE_LENGTH (builtin_opencl_type->builtin_##TYPE##3)\
    = 4 * TYPE_LENGTH (builtin_opencl_type->builtin_##TYPE);\
  builtin_opencl_type->builtin_##TYPE##4\
    = init_vector_type (builtin_opencl_type->builtin_##TYPE, 4);\
  TYPE_NAME (builtin_opencl_type->builtin_##TYPE##4) = OCL_STRING(TYPE ## 4);\
  builtin_opencl_type->builtin_##TYPE##8\
    = init_vector_type (builtin_opencl_type->builtin_##TYPE, 8);\
  TYPE_NAME (builtin_opencl_type->builtin_##TYPE##8) = OCL_STRING(TYPE ## 8);\
  builtin_opencl_type->builtin_##TYPE##16\
    = init_vector_type (builtin_opencl_type->builtin_##TYPE, 16);\
  TYPE_NAME (builtin_opencl_type->builtin_##TYPE##16) = OCL_STRING(TYPE ## 16)
d1059 1
a1059 1
  builtin_opencl_type->builtin_char
d1062 1
a1062 1
  builtin_opencl_type->builtin_uchar
d1065 1
a1065 1
  builtin_opencl_type->builtin_short
d1068 1
a1068 1
  builtin_opencl_type->builtin_ushort
d1071 1
a1071 1
  builtin_opencl_type->builtin_int
d1074 1
a1074 1
  builtin_opencl_type->builtin_uint
d1077 1
a1077 1
  builtin_opencl_type->builtin_long
d1080 1
a1080 1
  builtin_opencl_type->builtin_ulong
d1083 1
a1083 1
  builtin_opencl_type->builtin_half
d1086 1
a1086 1
  builtin_opencl_type->builtin_float
d1089 1
a1089 1
  builtin_opencl_type->builtin_double
d1092 1
a1092 1
  builtin_opencl_type->builtin_bool
d1094 1
a1094 1
  builtin_opencl_type->builtin_unsigned_char
d1096 1
a1096 1
  builtin_opencl_type->builtin_unsigned_short
d1098 1
a1098 1
  builtin_opencl_type->builtin_unsigned_int
d1100 1
a1100 1
  builtin_opencl_type->builtin_unsigned_long
d1102 1
a1102 1
  builtin_opencl_type->builtin_size_t
d1104 1
a1104 1
  builtin_opencl_type->builtin_ptrdiff_t
d1106 1
a1106 1
  builtin_opencl_type->builtin_intptr_t
d1108 1
a1108 1
  builtin_opencl_type->builtin_uintptr_t
d1110 1
a1110 1
  builtin_opencl_type->builtin_void
d1113 1
a1113 1
  return builtin_opencl_type;
@


1.5
log
@	* opencl-lang.c (STRINGIFY): Rename to OCL_STRING.
	(BUILD_OCL_VTYPES): Update.
@
text
@d1175 1
a1175 1
    = arch_boolean_type (gdbarch, 32, 1, "bool");
@


1.4
log
@2011-01-10  Michael Snyder  <msnyder@@vmware.com>

	* nto-procfs.c: Comment cleanup, mostly periods and spaces.
	* nto-tdep.c: Ditto.
	* nto-tdep.h: Ditto.
	* objc-exp.y: Ditto.
	* objc-lang.c: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* observer.c: Ditto.
	* opencl-lang.c: Ditto.
	* osabi.c: Ditto.
	* parse.c: Ditto.
	* parser-defs.h: Ditto.
	* p-exp.y: Ditto.
	* p-lang.c: Ditto.
	* posix-hdep.c: Ditto.
	* ppcbug-rom.c: Ditto.
	* ppc-linux-nat.c: Ditto.
	* ppc-linux-tdep.c: Ditto.
	* ppc-linux-tdep.h: Ditto.
	* ppcnbsd-tdep.c: Ditto.
	* ppcobsd-tdep.c: Ditto.
	* ppcobsd-tdep.h: Ditto.
	* ppc-sysv-tdep.c: Ditto.
	* ppc-tdep.h: Ditto.
	* printcmd.c: Ditto.
	* proc-abi.c: Ditto.
	* proc-flags.c: Ditto.
	* procfs.c: Ditto.
	* proc-utils.h: Ditto.
	* progspace.h: Ditto.
	* prologue-value.c: Ditto.
	* prologue-value.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* ravenscar-sparc-thread.c: Ditto.
	* ravenscar-thread.c: Ditto.
	* ravenscar-thread.h: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote.c: Ditto.
	* remote-fileio.c: Ditto.
	* remote-fileio.h: Ditto.
	* remote.h: Ditto.
	* remote-m32r-sdi.c: Ditto.
	* remote-mips.c: Ditto.
	* remote-sim.c: Ditto.
	* rs6000-aix-tdep.c: Ditto.
	* rs6000-nat.c: Ditto.
	* rs6000-tdep.c: Ditto.
@
text
@d1119 1
a1119 1
#define STRINGIFY(S) #S
d1125 1
a1125 1
  TYPE_NAME (builtin_opencl_type->builtin_##TYPE##2) = STRINGIFY(TYPE ## 2);\
d1128 1
a1128 1
  TYPE_NAME (builtin_opencl_type->builtin_##TYPE##3) = STRINGIFY(TYPE ## 3);\
d1133 1
a1133 1
  TYPE_NAME (builtin_opencl_type->builtin_##TYPE##4) = STRINGIFY(TYPE ## 4);\
d1136 1
a1136 1
  TYPE_NAME (builtin_opencl_type->builtin_##TYPE##8) = STRINGIFY(TYPE ## 8);\
d1139 1
a1139 1
  TYPE_NAME (builtin_opencl_type->builtin_##TYPE##16) = STRINGIFY(TYPE ## 16)
@


1.3
log
@run copyright.sh for 2011.
@
text
@d828 2
a829 1
	  arg2 = evaluate_subexp (NULL_TYPE, exp, pos, EVAL_AVOID_SIDE_EFFECTS);
d1098 2
a1099 1
  NULL,				/* Language specific class_name_from_physname */
@


1.2
log
@gdb
	* opencl-lang.c (lval_func_check_synthetic_pointer): New
	function.
	* value.h (struct lval_funcs) <indirect, check_synthetic_pointer>:
	New fields.
	(value_bits_synthetic_pointer): Declare.
	* value.c (value_bits_synthetic_pointer): New function.
	* valprint.c (valprint_check_validity): Handle synthetic
	pointers.
	* valops.c (value_ind): Use new 'indirect' lval_funcs method.
	* valarith.c (value_ptradd): Use set_value_component_location.
	* p-valprint.c (pascal_object_print_value_fields): Handle
	synthetic pointers.
	* jv-valprint.c (java_print_value_fields): Handle synthetic
	pointers.
	* dwarf2read.c (dwarf_stack_op_name): Add
	DW_OP_GNU_implicit_pointer.
	(dwarf2_fetch_die_location_block): Add get_frame_pc, baton
	arguments.  Handle location lists.
	(fill_in_loclist_baton): New function.
	(dwarf2_symbol_mark_computed): Use it.
	* dwarf2loc.h (dwarf2_find_location_expression): Declare.
	(dwarf2_fetch_die_location_block): Add get_frame_pc, baton
	arguments.
	* dwarf2loc.c (dwarf2_find_location_expression): Rename from
	find_location_expression.  No longer static.  Update all callers.
	(dwarf_expr_frame_pc): New function.
	(per_cu_dwarf_call): Add get_frame_pc, baton arguments.  Update
	all callers.
	(struct piece_closure) <per_cu>: New field.
	(allocate_piece_closure): Add per_cu argument.
	(read_pieced_value): Handle DWARF_VALUE_IMPLICIT_POINTER.
	(check_pieced_value_bits): Remove validity argument, add check_for
	argument.  Handle DWARF_VALUE_IMPLICIT_POINTER.
	(check_pieced_value_validity, check_pieced_value_invalid):
	Update.
	(check_pieced_synthetic_pointer): New function.
	(get_frame_address_in_block_wrapper): New function.
	(indirect_pieced_value): New function.
	(pieced_value_funcs): Update.
	(invalid_synthetic_pointer): New function.
	(dwarf2_evaluate_loc_desc_full): Rename from
	dwarf2_evaluate_loc_desc.  Add byte_offset argument.
	(dwarf2_evaluate_loc_desc): Rewrite.
	(dwarf2_loc_desc_needs_frame): Set new field on context.
	(get_ax_pc): New function.
	(disassemble_dwarf_expression): Handle
	DW_OP_GNU_implicit_pointer.
	* dwarf2expr.h (enum dwarf_value_location)
	<DWARF_VALUE_IMPLICIT_POINTER>: New constant.
	(struct dwarf_expr_context) <get_frame_pc>: New field.
	(struct dwarf_expr_piece) <v.ptr>: New field.
	* dwarf2expr.c (add_piece): Handle DWARF_VALUE_IMPLICIT_POINTER.
	(execute_stack_op): Handle DW_OP_GNU_implicit_pointer.
	* dwarf2-frame.c (no_get_frame_pc): New function.
	(execute_stack_op): Set new field on context.
	* cp-valprint.c (cp_print_value_fields): Handle synthetic
	pointers.
gdb/testsuite
	* gdb.dwarf2/implptr.exp: New file.
	* gdb.dwarf2/implptr.c: New file.
	* gdb.dwarf2/implptr.S: New file.
@
text
@d2 1
a2 1
   Copyright (C) 2010 Free Software Foundation, Inc.
@


1.1
log
@gdb:
	* NEWS: Mention OpenCL C language support.
	* Makefile.in (SFILES): Add opencl-lang.c.
	(COMMON_OBS): Add opencl-lang.o.
	* opencl-lang.c: New File
	* defs.h (enum language): Add language_opencl.
	* dwarf2read.c (read_file_scope): Handle DW_AT_producer for the
	IBM XL C OpenCL compiler.
	* c-lang.h: Include "parser-defs.h".
	(evaluate_subexp_c): Declare.
	* c-lang.c (evaluate_subexp_c): Remove the static qualifier.
	(c_op_print_tab): Add declaration.
	* eval.c (binop_promote): Handle language_opencl.
	* c-exp.y: Lookup the primitive types instead of referring to the
	builtins.

gdb/testsuite:
	* Makefile.in (ALL_SUBDIRS): Add gdb.opencl.
	* configure.ac (AC_OUTPUT): Add gdb.opencl/Makefile.
	* configure: Regenerate.
	* gdb.opencl/Makefile.in: New File.
	* gdb.opencl/datatypes.exp: Likewise.
	* gdb.opencl/datatypes.cl: Likewise.
	* gdb.opencl/operators.exp: Likewise.
	* gdb.opencl/operators.cl: Likewise.
	* gdb.opencl/vec_comps.exp: Likewise.
	* gdb.opencl/vec_comps.cl: Likewise.
	* gdb.opencl/convs_casts.exp: Likewise.
	* gdb.opencl/convs_casts.cl: Likewise.
	* lib/opencl.exp: Likewise.
	* lib/opencl_hostapp.c: Likewise.
	* lib/opencl_kernel.cl: Likewise.
	* lib/cl_util.c: Likewise.
	* lib/cl_util.c: Likewise.
	* gdb.base/default.exp (set language): Add "opencl" to the list of
	languages.

gdb/doc:
	* gdb.texinfo: (Summary) Add mention about OpenCL C language support.
	(OpenCL C): New node.
@
text
@d330 37
d398 2
@

