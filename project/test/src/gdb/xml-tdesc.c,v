head	1.28;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.28
	gdb_7_6-2013-04-26-release:1.28
	gdb_7_6-branch:1.28.0.2
	gdb_7_6-2013-03-12-branchpoint:1.28
	gdb_7_5_1-2012-11-29-release:1.27
	gdb_7_5-2012-08-17-release:1.27
	gdb_7_5-branch:1.27.0.2
	gdb_7_5-2012-07-18-branchpoint:1.27
	gdb_7_4_1-2012-04-26-release:1.26.4.1
	gdb_7_4-2012-01-24-release:1.26.4.1
	gdb_7_4-branch:1.26.0.4
	gdb_7_4-2011-12-13-branchpoint:1.26
	gdb_7_3_1-2011-09-04-release:1.26
	gdb_7_3-2011-07-26-release:1.26
	gdb_7_3-branch:1.26.0.2
	gdb_7_3-2011-04-01-branchpoint:1.26
	gdb_7_2-2010-09-02-release:1.22
	gdb_7_2-branch:1.22.0.2
	gdb_7_2-2010-07-07-branchpoint:1.22
	gdb_7_1-2010-03-18-release:1.19
	gdb_7_1-branch:1.19.0.2
	gdb_7_1-2010-02-18-branchpoint:1.19
	gdb_7_0_1-2009-12-22-release:1.18
	gdb_7_0-2009-10-06-release:1.18
	gdb_7_0-branch:1.18.0.2
	gdb_7_0-2009-09-16-branchpoint:1.18
	arc-sim-20090309:1.10
	msnyder-checkpoint-072509-branch:1.16.0.2
	msnyder-checkpoint-072509-branchpoint:1.16
	arc-insight_6_8-branch:1.10.0.10
	arc-insight_6_8-branchpoint:1.10
	insight_6_8-branch:1.10.0.8
	insight_6_8-branchpoint:1.10
	reverse-20081226-branch:1.13.0.4
	reverse-20081226-branchpoint:1.13
	multiprocess-20081120-branch:1.13.0.2
	multiprocess-20081120-branchpoint:1.13
	reverse-20080930-branch:1.12.0.2
	reverse-20080930-branchpoint:1.12
	reverse-20080717-branch:1.10.0.6
	reverse-20080717-branchpoint:1.10
	msnyder-reverse-20080609-branch:1.10.0.4
	msnyder-reverse-20080609-branchpoint:1.10
	drow-reverse-20070409-branch:1.5.0.2
	drow-reverse-20070409-branchpoint:1.5
	gdb_6_8-2008-03-27-release:1.10
	gdb_6_8-branch:1.10.0.2
	gdb_6_8-2008-02-26-branchpoint:1.10
	gdb_6_7_1-2007-10-29-release:1.9
	gdb_6_7-2007-10-10-release:1.9
	gdb_6_7-branch:1.9.0.2
	gdb_6_7-2007-09-07-branchpoint:1.9;
locks; strict;
comment	@ * @;


1.28
date	2013.01.01.06.41.29;	author brobecke;	state Exp;
branches;
next	1.27;

1.27
date	2012.01.04.08.27.58;	author brobecke;	state Exp;
branches;
next	1.26;

1.26
date	2011.02.02.16.12.59;	author palves;	state Exp;
branches
	1.26.4.1;
next	1.25;

1.25
date	2011.01.25.09.49.59;	author palves;	state Exp;
branches;
next	1.24;

1.24
date	2011.01.05.22.22.53;	author msnyder;	state Exp;
branches;
next	1.23;

1.23
date	2011.01.01.15.33.19;	author brobecke;	state Exp;
branches;
next	1.22;

1.22
date	2010.05.17.18.48.51;	author msnyder;	state Exp;
branches;
next	1.21;

1.21
date	2010.05.07.02.09.54;	author msnyder;	state Exp;
branches;
next	1.20;

1.20
date	2010.03.01.17.19.22;	author drow;	state Exp;
branches;
next	1.19;

1.19
date	2010.01.01.07.31.46;	author brobecke;	state Exp;
branches;
next	1.18;

1.18
date	2009.09.15.03.30.06;	author sergiodj;	state Exp;
branches;
next	1.17;

1.17
date	2009.07.31.14.39.11;	author uweigand;	state Exp;
branches;
next	1.16;

1.16
date	2009.07.20.18.51.41;	author palves;	state Exp;
branches;
next	1.15;

1.15
date	2009.06.23.16.59.46;	author uweigand;	state Exp;
branches;
next	1.14;

1.14
date	2009.01.03.05.57.54;	author brobecke;	state Exp;
branches;
next	1.13;

1.13
date	2008.10.28.15.22.13;	author tromey;	state Exp;
branches;
next	1.12;

1.12
date	2008.08.24.16.39.57;	author tromey;	state Exp;
branches;
next	1.11;

1.11
date	2008.08.10.18.41.33;	author palves;	state Exp;
branches;
next	1.10;

1.10
date	2008.01.01.22.53.13;	author drow;	state Exp;
branches;
next	1.9;

1.9
date	2007.09.05.00.51.48;	author drow;	state Exp;
branches;
next	1.8;

1.8
date	2007.08.23.18.08.47;	author brobecke;	state Exp;
branches;
next	1.7;

1.7
date	2007.06.13.19.22.35;	author drow;	state Exp;
branches;
next	1.6;

1.6
date	2007.06.04.12.34.11;	author drow;	state Exp;
branches;
next	1.5;

1.5
date	2007.02.13.15.48.05;	author drow;	state Exp;
branches;
next	1.4;

1.4
date	2007.02.08.21.00.34;	author drow;	state Exp;
branches;
next	1.3;

1.3
date	2007.02.07.22.51.36;	author drow;	state Exp;
branches;
next	1.2;

1.2
date	2007.02.07.22.48.06;	author drow;	state Exp;
branches;
next	1.1;

1.1
date	2007.01.09.22.55.10;	author drow;	state Exp;
branches;
next	;

1.26.4.1
date	2012.01.06.04.54.34;	author brobecke;	state Exp;
branches;
next	;


desc
@@


1.28
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@/* XML target description support for GDB.

   Copyright (C) 2006-2013 Free Software Foundation, Inc.

   Contributed by CodeSourcery.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "target.h"
#include "target-descriptions.h"
#include "xml-support.h"
#include "xml-tdesc.h"
#include "osabi.h"

#include "filenames.h"

#include "gdb_assert.h"

#if !defined(HAVE_LIBEXPAT)

/* Parse DOCUMENT into a target description.  Or don't, since we don't have
   an XML parser.  */

static struct target_desc *
tdesc_parse_xml (const char *document, xml_fetch_another fetcher,
		 void *fetcher_baton)
{
  static int have_warned;

  if (!have_warned)
    {
      have_warned = 1;
      warning (_("Can not parse XML target description; XML support was "
		 "disabled at compile time"));
    }

  return NULL;
}

#else /* HAVE_LIBEXPAT */

/* A record of every XML description we have parsed.  We never discard
   old descriptions, because we never discard gdbarches.  As long as we
   have a gdbarch referencing this description, we want to have a copy
   of it here, so that if we parse the same XML document again we can
   return the same "struct target_desc *"; if they are not singletons,
   then we will create unnecessary duplicate gdbarches.  See
   gdbarch_list_lookup_by_info.  */

struct tdesc_xml_cache
{
  const char *xml_document;
  struct target_desc *tdesc;
};
typedef struct tdesc_xml_cache tdesc_xml_cache_s;
DEF_VEC_O(tdesc_xml_cache_s);

static VEC(tdesc_xml_cache_s) *xml_cache;

/* Callback data for target description parsing.  */

struct tdesc_parsing_data
{
  /* The target description we are building.  */
  struct target_desc *tdesc;

  /* The target feature we are currently parsing, or last parsed.  */
  struct tdesc_feature *current_feature;

  /* The register number to use for the next register we see, if
     it does not have its own.  This starts at zero.  */
  int next_regnum;

  /* The struct or union we are currently parsing, or last parsed.  */
  struct tdesc_type *current_type;

  /* The byte size of the current struct type, if specified.  Zero
     if not specified.  */
  int current_type_size;

  /* Whether the current type is a flags type.  */
  int current_type_is_flags;
};

/* Handle the end of an <architecture> element and its value.  */

static void
tdesc_end_arch (struct gdb_xml_parser *parser,
		const struct gdb_xml_element *element,
		void *user_data, const char *body_text)
{
  struct tdesc_parsing_data *data = user_data;
  const struct bfd_arch_info *arch;

  arch = bfd_scan_arch (body_text);
  if (arch == NULL)
    gdb_xml_error (parser, _("Target description specified unknown "
			     "architecture \"%s\""), body_text);
  set_tdesc_architecture (data->tdesc, arch);
}

/* Handle the end of an <osabi> element and its value.  */

static void
tdesc_end_osabi (struct gdb_xml_parser *parser,
		 const struct gdb_xml_element *element,
		 void *user_data, const char *body_text)
{
  struct tdesc_parsing_data *data = user_data;
  enum gdb_osabi osabi;

  osabi = osabi_from_tdesc_string (body_text);
  if (osabi == GDB_OSABI_UNKNOWN)
    warning (_("Target description specified unknown osabi \"%s\""),
	     body_text);
  else
    set_tdesc_osabi (data->tdesc, osabi);
}

/* Handle the end of a <compatible> element and its value.  */

static void
tdesc_end_compatible (struct gdb_xml_parser *parser,
		      const struct gdb_xml_element *element,
		      void *user_data, const char *body_text)
{
  struct tdesc_parsing_data *data = user_data;
  const struct bfd_arch_info *arch;

  arch = bfd_scan_arch (body_text);
  tdesc_add_compatible (data->tdesc, arch);
}

/* Handle the start of a <target> element.  */

static void
tdesc_start_target (struct gdb_xml_parser *parser,
		    const struct gdb_xml_element *element,
		    void *user_data, VEC(gdb_xml_value_s) *attributes)
{
  char *version = xml_find_attribute (attributes, "version")->value;

  if (strcmp (version, "1.0") != 0)
    gdb_xml_error (parser,
		   _("Target description has unsupported version \"%s\""),
		   version);
}

/* Handle the start of a <feature> element.  */

static void
tdesc_start_feature (struct gdb_xml_parser *parser,
		     const struct gdb_xml_element *element,
		     void *user_data, VEC(gdb_xml_value_s) *attributes)
{
  struct tdesc_parsing_data *data = user_data;
  char *name = xml_find_attribute (attributes, "name")->value;

  data->current_feature = tdesc_create_feature (data->tdesc, name);
}

/* Handle the start of a <reg> element.  Fill in the optional
   attributes and attach it to the containing feature.  */

static void
tdesc_start_reg (struct gdb_xml_parser *parser,
		 const struct gdb_xml_element *element,
		 void *user_data, VEC(gdb_xml_value_s) *attributes)
{
  struct tdesc_parsing_data *data = user_data;
  struct gdb_xml_value *attrs = VEC_address (gdb_xml_value_s, attributes);
  int ix = 0, length;
  char *name, *group, *type;
  int bitsize, regnum, save_restore;

  length = VEC_length (gdb_xml_value_s, attributes);

  name = attrs[ix++].value;
  bitsize = * (ULONGEST *) attrs[ix++].value;

  if (ix < length && strcmp (attrs[ix].name, "regnum") == 0)
    regnum = * (ULONGEST *) attrs[ix++].value;
  else
    regnum = data->next_regnum;

  if (ix < length && strcmp (attrs[ix].name, "type") == 0)
    type = attrs[ix++].value;
  else
    type = "int";

  if (ix < length && strcmp (attrs[ix].name, "group") == 0)
    group = attrs[ix++].value;
  else
    group = NULL;

  if (ix < length && strcmp (attrs[ix].name, "save-restore") == 0)
    save_restore = * (ULONGEST *) attrs[ix++].value;
  else
    save_restore = 1;

  if (strcmp (type, "int") != 0
      && strcmp (type, "float") != 0
      && tdesc_named_type (data->current_feature, type) == NULL)
    gdb_xml_error (parser, _("Register \"%s\" has unknown type \"%s\""),
		   name, type);

  tdesc_create_reg (data->current_feature, name, regnum, save_restore, group,
		    bitsize, type);

  data->next_regnum = regnum + 1;
}

/* Handle the start of a <union> element.  Initialize the type and
   record it with the current feature.  */

static void
tdesc_start_union (struct gdb_xml_parser *parser,
		   const struct gdb_xml_element *element,
		   void *user_data, VEC(gdb_xml_value_s) *attributes)
{
  struct tdesc_parsing_data *data = user_data;
  char *id = xml_find_attribute (attributes, "id")->value;

  data->current_type = tdesc_create_union (data->current_feature, id);
  data->current_type_size = 0;
  data->current_type_is_flags = 0;
}

/* Handle the start of a <struct> element.  Initialize the type and
   record it with the current feature.  */

static void
tdesc_start_struct (struct gdb_xml_parser *parser,
		   const struct gdb_xml_element *element,
		   void *user_data, VEC(gdb_xml_value_s) *attributes)
{
  struct tdesc_parsing_data *data = user_data;
  char *id = xml_find_attribute (attributes, "id")->value;
  struct tdesc_type *type;
  struct gdb_xml_value *attr;

  type = tdesc_create_struct (data->current_feature, id);
  data->current_type = type;
  data->current_type_size = 0;
  data->current_type_is_flags = 0;

  attr = xml_find_attribute (attributes, "size");
  if (attr != NULL)
    {
      int size = (int) * (ULONGEST *) attr->value;

      tdesc_set_struct_size (type, size);
      data->current_type_size = size;
    }
}

static void
tdesc_start_flags (struct gdb_xml_parser *parser,
		   const struct gdb_xml_element *element,
		   void *user_data, VEC(gdb_xml_value_s) *attributes)
{
  struct tdesc_parsing_data *data = user_data;
  char *id = xml_find_attribute (attributes, "id")->value;
  int length = (int) * (ULONGEST *)
    xml_find_attribute (attributes, "size")->value;
  struct tdesc_type *type;

  type = tdesc_create_flags (data->current_feature, id, length);

  data->current_type = type;
  data->current_type_size = 0;
  data->current_type_is_flags = 1;
}

/* Handle the start of a <field> element.  Attach the field to the
   current struct or union.  */

static void
tdesc_start_field (struct gdb_xml_parser *parser,
		   const struct gdb_xml_element *element,
		   void *user_data, VEC(gdb_xml_value_s) *attributes)
{
  struct tdesc_parsing_data *data = user_data;
  struct gdb_xml_value *attr;
  struct tdesc_type *field_type;
  char *field_name, *field_type_id;
  int start, end;

  field_name = xml_find_attribute (attributes, "name")->value;

  attr = xml_find_attribute (attributes, "type");
  if (attr != NULL)
    field_type_id = attr->value;
  else
    field_type_id = NULL;

  attr = xml_find_attribute (attributes, "start");
  if (attr != NULL)
    start = * (ULONGEST *) attr->value;
  else
    start = -1;

  attr = xml_find_attribute (attributes, "end");
  if (attr != NULL)
    end = * (ULONGEST *) attr->value;
  else
    end = -1;

  if (field_type_id != NULL)
    {
      if (data->current_type_is_flags)
	gdb_xml_error (parser, _("Cannot add typed field \"%s\" to flags"), 
		       field_name);
      if (data->current_type_size != 0)
	gdb_xml_error (parser,
		       _("Explicitly sized type can not "
			 "contain non-bitfield \"%s\""), 
		       field_name);

      field_type = tdesc_named_type (data->current_feature, field_type_id);
      if (field_type == NULL)
	gdb_xml_error (parser, _("Field \"%s\" references undefined "
				 "type \"%s\""),
		       field_name, field_type_id);

      tdesc_add_field (data->current_type, field_name, field_type);
    }
  else if (start != -1 && end != -1)
    {
      struct tdesc_type *t = data->current_type;

      if (data->current_type_is_flags)
	tdesc_add_flag (t, start, field_name);
      else
	{
	  if (data->current_type_size == 0)
	    gdb_xml_error (parser,
			   _("Implicitly sized type can "
			     "not contain bitfield \"%s\""), 
			   field_name);

	  if (end >= 64)
	    gdb_xml_error (parser,
			   _("Bitfield \"%s\" goes past "
			     "64 bits (unsupported)"),
			   field_name);

	  /* Assume that the bit numbering in XML is "lsb-zero".  Most
	     architectures other than PowerPC use this ordering.  In
	     the future, we can add an XML tag to indicate "msb-zero"
	     numbering.  */
	  if (start > end)
	    gdb_xml_error (parser, _("Bitfield \"%s\" has start after end"),
			   field_name);

	  if (end >= data->current_type_size * TARGET_CHAR_BIT)
	    gdb_xml_error (parser,
			   _("Bitfield \"%s\" does not fit in struct"));

	  tdesc_add_bitfield (t, field_name, start, end);
	}
    }
  else
    gdb_xml_error (parser, _("Field \"%s\" has neither type nor bit position"),
		   field_name);
}

/* Handle the start of a <vector> element.  Initialize the type and
   record it with the current feature.  */

static void
tdesc_start_vector (struct gdb_xml_parser *parser,
		    const struct gdb_xml_element *element,
		    void *user_data, VEC(gdb_xml_value_s) *attributes)
{
  struct tdesc_parsing_data *data = user_data;
  struct gdb_xml_value *attrs = VEC_address (gdb_xml_value_s, attributes);
  struct tdesc_type *field_type;
  char *id, *field_type_id;
  int count;

  id = attrs[0].value;
  field_type_id = attrs[1].value;
  count = * (ULONGEST *) attrs[2].value;

  field_type = tdesc_named_type (data->current_feature, field_type_id);
  if (field_type == NULL)
    gdb_xml_error (parser, _("Vector \"%s\" references undefined type \"%s\""),
		   id, field_type_id);

  tdesc_create_vector (data->current_feature, id, field_type, count);
}

/* The elements and attributes of an XML target description.  */

static const struct gdb_xml_attribute field_attributes[] = {
  { "name", GDB_XML_AF_NONE, NULL, NULL },
  { "type", GDB_XML_AF_OPTIONAL, NULL, NULL },
  { "start", GDB_XML_AF_OPTIONAL, gdb_xml_parse_attr_ulongest, NULL },
  { "end", GDB_XML_AF_OPTIONAL, gdb_xml_parse_attr_ulongest, NULL },
  { NULL, GDB_XML_AF_NONE, NULL, NULL }
};

static const struct gdb_xml_element struct_union_children[] = {
  { "field", field_attributes, NULL, GDB_XML_EF_REPEATABLE,
    tdesc_start_field, NULL },
  { NULL, NULL, NULL, GDB_XML_EF_NONE, NULL, NULL }
};

static const struct gdb_xml_attribute reg_attributes[] = {
  { "name", GDB_XML_AF_NONE, NULL, NULL },
  { "bitsize", GDB_XML_AF_NONE, gdb_xml_parse_attr_ulongest, NULL },
  { "regnum", GDB_XML_AF_OPTIONAL, gdb_xml_parse_attr_ulongest, NULL },
  { "type", GDB_XML_AF_OPTIONAL, NULL, NULL },
  { "group", GDB_XML_AF_OPTIONAL, NULL, NULL },
  { "save-restore", GDB_XML_AF_OPTIONAL,
    gdb_xml_parse_attr_enum, gdb_xml_enums_boolean },
  { NULL, GDB_XML_AF_NONE, NULL, NULL }
};

static const struct gdb_xml_attribute struct_union_attributes[] = {
  { "id", GDB_XML_AF_NONE, NULL, NULL },
  { "size", GDB_XML_AF_OPTIONAL, gdb_xml_parse_attr_ulongest, NULL},
  { NULL, GDB_XML_AF_NONE, NULL, NULL }
};

static const struct gdb_xml_attribute flags_attributes[] = {
  { "id", GDB_XML_AF_NONE, NULL, NULL },
  { "size", GDB_XML_AF_NONE, gdb_xml_parse_attr_ulongest, NULL},
  { NULL, GDB_XML_AF_NONE, NULL, NULL }
};

static const struct gdb_xml_attribute vector_attributes[] = {
  { "id", GDB_XML_AF_NONE, NULL, NULL },
  { "type", GDB_XML_AF_NONE, NULL, NULL },
  { "count", GDB_XML_AF_NONE, gdb_xml_parse_attr_ulongest, NULL },
  { NULL, GDB_XML_AF_NONE, NULL, NULL }
};

static const struct gdb_xml_attribute feature_attributes[] = {
  { "name", GDB_XML_AF_NONE, NULL, NULL },
  { NULL, GDB_XML_AF_NONE, NULL, NULL }
};

static const struct gdb_xml_element feature_children[] = {
  { "reg", reg_attributes, NULL,
    GDB_XML_EF_OPTIONAL | GDB_XML_EF_REPEATABLE,
    tdesc_start_reg, NULL },
  { "struct", struct_union_attributes, struct_union_children,
    GDB_XML_EF_OPTIONAL | GDB_XML_EF_REPEATABLE,
    tdesc_start_struct, NULL },
  { "union", struct_union_attributes, struct_union_children,
    GDB_XML_EF_OPTIONAL | GDB_XML_EF_REPEATABLE,
    tdesc_start_union, NULL },
  { "flags", flags_attributes, struct_union_children,
    GDB_XML_EF_OPTIONAL | GDB_XML_EF_REPEATABLE,
    tdesc_start_flags, NULL },    
  { "vector", vector_attributes, NULL,
    GDB_XML_EF_OPTIONAL | GDB_XML_EF_REPEATABLE,
    tdesc_start_vector, NULL },
  { NULL, NULL, NULL, GDB_XML_EF_NONE, NULL, NULL }
};

static const struct gdb_xml_attribute target_attributes[] = {
  { "version", GDB_XML_AF_NONE, NULL, NULL },
  { NULL, GDB_XML_AF_NONE, NULL, NULL }
};

static const struct gdb_xml_element target_children[] = {
  { "architecture", NULL, NULL, GDB_XML_EF_OPTIONAL,
    NULL, tdesc_end_arch },
  { "osabi", NULL, NULL, GDB_XML_EF_OPTIONAL,
    NULL, tdesc_end_osabi },
  { "compatible", NULL, NULL, GDB_XML_EF_OPTIONAL | GDB_XML_EF_REPEATABLE,
    NULL, tdesc_end_compatible },
  { "feature", feature_attributes, feature_children,
    GDB_XML_EF_OPTIONAL | GDB_XML_EF_REPEATABLE,
    tdesc_start_feature, NULL },
  { NULL, NULL, NULL, GDB_XML_EF_NONE, NULL, NULL }
};

static const struct gdb_xml_element tdesc_elements[] = {
  { "target", target_attributes, target_children, GDB_XML_EF_NONE,
    tdesc_start_target, NULL },
  { NULL, NULL, NULL, GDB_XML_EF_NONE, NULL, NULL }
};

/* Parse DOCUMENT into a target description and return it.  */

static struct target_desc *
tdesc_parse_xml (const char *document, xml_fetch_another fetcher,
		 void *fetcher_baton)
{
  struct cleanup *back_to, *result_cleanup;
  struct tdesc_parsing_data data;
  struct tdesc_xml_cache *cache;
  char *expanded_text;
  int ix;

  /* Expand all XInclude directives.  */
  expanded_text = xml_process_xincludes (_("target description"),
					 document, fetcher, fetcher_baton, 0);
  if (expanded_text == NULL)
    {
      warning (_("Could not load XML target description; ignoring"));
      return NULL;
    }

  /* Check for an exact match in the list of descriptions we have
     previously parsed.  strcmp is a slightly inefficient way to
     do this; an SHA-1 checksum would work as well.  */
  for (ix = 0; VEC_iterate (tdesc_xml_cache_s, xml_cache, ix, cache); ix++)
    if (strcmp (cache->xml_document, expanded_text) == 0)
      {
       xfree (expanded_text);
       return cache->tdesc;
      }

  back_to = make_cleanup (null_cleanup, NULL);

  memset (&data, 0, sizeof (struct tdesc_parsing_data));
  data.tdesc = allocate_target_description ();
  result_cleanup = make_cleanup_free_target_description (data.tdesc);
  make_cleanup (xfree, expanded_text);

  if (gdb_xml_parse_quick (_("target description"), "gdb-target.dtd",
			   tdesc_elements, expanded_text, &data) == 0)
    {
      /* Parsed successfully.  */
      struct tdesc_xml_cache new_cache;

      new_cache.xml_document = expanded_text;
      new_cache.tdesc = data.tdesc;
      VEC_safe_push (tdesc_xml_cache_s, xml_cache, &new_cache);
      discard_cleanups (result_cleanup);
      do_cleanups (back_to);
      return data.tdesc;
    }
  else
    {
      warning (_("Could not load XML target description; ignoring"));
      do_cleanups (back_to);
      return NULL;
    }
}
#endif /* HAVE_LIBEXPAT */


/* Read an XML target description from FILENAME.  Parse it, and return
   the parsed description.  */

const struct target_desc *
file_read_description_xml (const char *filename)
{
  struct target_desc *tdesc;
  char *tdesc_str;
  struct cleanup *back_to;
  char *dirname;

  tdesc_str = xml_fetch_content_from_file (filename, NULL);
  if (tdesc_str == NULL)
    {
      warning (_("Could not open \"%s\""), filename);
      return NULL;
    }

  back_to = make_cleanup (xfree, tdesc_str);

  dirname = ldirname (filename);
  if (dirname != NULL)
    make_cleanup (xfree, dirname);

  tdesc = tdesc_parse_xml (tdesc_str, xml_fetch_content_from_file, dirname);
  do_cleanups (back_to);

  return tdesc;
}

/* Read a string representation of available features from the target,
   using TARGET_OBJECT_AVAILABLE_FEATURES.  The returned string is
   malloc allocated and NUL-terminated.  NAME should be a non-NULL
   string identifying the XML document we want; the top level document
   is "target.xml".  Other calls may be performed for the DTD or
   for <xi:include>.  */

static char *
fetch_available_features_from_target (const char *name, void *baton_)
{
  struct target_ops *ops = baton_;

  /* Read this object as a string.  This ensures that a NUL
     terminator is added.  */
  return target_read_stralloc (ops,
			       TARGET_OBJECT_AVAILABLE_FEATURES,
			       name);
}


/* Read an XML target description using OPS.  Parse it, and return the
   parsed description.  */

const struct target_desc *
target_read_description_xml (struct target_ops *ops)
{
  struct target_desc *tdesc;
  char *tdesc_str;
  struct cleanup *back_to;

  tdesc_str = fetch_available_features_from_target ("target.xml", ops);
  if (tdesc_str == NULL)
    return NULL;

  back_to = make_cleanup (xfree, tdesc_str);
  tdesc = tdesc_parse_xml (tdesc_str,
			   fetch_available_features_from_target,
			   ops);
  do_cleanups (back_to);

  return tdesc;
}
@


1.27
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 1
a3 1
   Copyright (C) 2006, 2008-2012 Free Software Foundation, Inc.
@


1.26
log
@	* xml-support.c (xml_find_attribute): New.
	(xinclude_start_include): Use it.
	* xml-support.h (xml_find_attribute): Declare.
	* memory-map.c (memory_map_start_memory)
	(memory_map_start_property): Use xml_find_attribute.
	* osdata.c (osdata_start_osdata, osdata_start_column): Use
	xml_find_attribute.
	* remote.c (start_thread): Use xml_find_attribute.
	* solib-target.c (library_list_start_segment)
	(library_list_start_section, library_list_start_library)
	(library_list_start_list): Use xml_find_attribute.
	* xml-tdesc.c (tdesc_start_target, tdesc_start_feature)
	(tdesc_start_union, tdesc_start_struct, tdesc_start_flags)
	(tdesc_start_field): Use xml_find_attribute.
@
text
@d3 1
a3 1
   Copyright (C) 2006, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
@


1.26.4.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 1
a3 1
   Copyright (C) 2006, 2008-2012 Free Software Foundation, Inc.
@


1.25
log
@	Simplify XML parsing a bit.

	* xml-support.h (gdb_xml_parse_quick): Declare.
	* xml-support.c (gdb_xml_create_parser_and_cleanup_1): Renamed
	from gdb_xml_create_parser_and_cleanup, and added `old_chain'
	parameter.
	(gdb_xml_create_parser_and_cleanup): Reimplement on top of
	gdb_xml_create_parser_and_cleanup_1.
	(gdb_xml_parse_quick): New.
	* memory-map.c (parse_memory_map): Use gdb_xml_parse_quick.
	* osdata.c (osdata_parse): Ditto.
	* remote.c (remote_threads_info): Ditto.
	* solib-target.c (solib_target_parse_libraries): Ditto.
	* xml-syscall.c (syscall_parse_xml): Ditto.
	* xml-tdesc.c (tdesc_parse_xml): Ditto.
@
text
@d155 1
a155 1
  char *version = VEC_index (gdb_xml_value_s, attributes, 0)->value;
d171 1
a171 1
  char *name = VEC_index (gdb_xml_value_s, attributes, 0)->value;
d236 1
a236 1
  char *id = VEC_index (gdb_xml_value_s, attributes, 0)->value;
d252 1
a252 1
  char *id = VEC_index (gdb_xml_value_s, attributes, 0)->value;
d254 1
d261 2
a262 1
  if (VEC_length (gdb_xml_value_s, attributes) > 1)
d264 1
a264 2
      int size = (int) * (ULONGEST *)
	VEC_index (gdb_xml_value_s, attributes, 1)->value;
d277 1
a277 1
  char *id = VEC_index (gdb_xml_value_s, attributes, 0)->value;
d279 1
a279 1
    VEC_index (gdb_xml_value_s, attributes, 1)->value;
d298 1
a298 2
  int ix = 0, length;
  struct gdb_xml_value *attrs = VEC_address (gdb_xml_value_s, attributes);
d303 1
a303 1
  length = VEC_length (gdb_xml_value_s, attributes);
d305 3
a307 4
  field_name = attrs[ix++].value;

  if (ix < length && strcmp (attrs[ix].name, "type") == 0)
    field_type_id = attrs[ix++].value;
d311 3
a313 2
  if (ix < length && strcmp (attrs[ix].name, "start") == 0)
    start = * (ULONGEST *) attrs[ix++].value;
d317 3
a319 2
  if (ix < length && strcmp (attrs[ix].name, "end") == 0)
    end = * (ULONGEST *) attrs[ix++].value;
@


1.24
log
@2011-01-05  Michael Snyder  <msnyder@@vmware.com>

	* addrmap.c: Shorten lines of >= 80 columns.
	* arch-utils.c: Ditto.
	* arch-utils.h: Ditto.
	* ax-gdb.c: Ditto.
	* ax-general.c: Ditto.
	* bcache.c: Ditto.
	* blockframe.c: Ditto.
	* breakpoint.c: Ditto.
	* buildsym.c: Ditto.
	* c-lang.c: Ditto.
	* c-typeprint.c: Ditto.
	* charset.c: Ditto.
	* coffread.c: Ditto.
	* command.h: Ditto.
	* corelow.c: Ditto.
	* cp-abi.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* defs.h: Ditto.
	* dfp.c: Ditto.
	* dfp.h: Ditto.
	* dictionary.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* eval.c: Ditto.
	* event-loop.c: Ditto.
	* event-loop.h: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-lang.c: Ditto.
	* f-valprint.c: Ditto.
	* findcmd.c: Ditto.
	* frame-base.c: Ditto.
	* frame-unwind.c: Ditto.
	* frame-unwind.h: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_dirent.h: Ditto.
	* gdb_obstack.h: Ditto.
	* gdbcore.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* inf-ttrace.c: Ditto.
	* infcall.c: Ditto.
	* infcmd.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* inline-frame.h: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* libunwind-frame.c: Ditto.
	* libunwind-frame.h: Ditto.
	* linespec.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-nat.h: Ditto.
	* linux-thread-db.c: Ditto.
	* machoread.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* memattr.c: Ditto.
	* minsyms.c: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* osabi.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* parse.c: Ditto.
	* printcmd.c: Ditto.
	* proc-events.c: Ditto.
	* procfs.c: Ditto.
	* progspace.c: Ditto.
	* progspace.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote-fileio.c: Ditto.
	* remote.c: Ditto.
	* ser-mingw.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* solib-frv.c: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solib-target.c: Ditto.
	* solib.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.c: Ditto.
	* stack.c: Ditto.
	* stack.h: Ditto.
	* symfile-mem.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target-descriptions.c: Ditto.
	* target-memory.c: Ditto.
	* target.c: Ditto.
	* target.h: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* ui-file.c: Ditto.
	* ui-file.h: Ditto.
	* ui-out.h: Ditto.
	* user-regs.c: Ditto.
	* user-regs.h: Ditto.
	* utils.c: Ditto.
	* valarith.c: Ditto.
	* valops.c: Ditto.
	* valprint.c: Ditto.
	* valprint.h: Ditto.
	* value.c: Ditto.
	* varobj.c: Ditto.
	* varobj.h: Ditto.
	* vec.h: Ditto.
	* xcoffread.c: Ditto.
	* xcoffsolib.c: Ditto.
	* xcoffsolib.h: Ditto.
	* xml-syscall.c: Ditto.
	* xml-tdesc.c: Ditto.
@
text
@a507 1
  struct gdb_xml_parser *parser;
a532 3
  parser = gdb_xml_create_parser_and_cleanup (_("target description"),
					      tdesc_elements, &data);
  gdb_xml_use_dtd (parser, "gdb-target.dtd");
d539 2
a540 1
  if (gdb_xml_parse (parser, expanded_text) == 0)
@


1.23
log
@run copyright.sh for 2011.
@
text
@d329 2
a330 1
		       _("Explicitly sized type can not contain non-bitfield \"%s\""), 
d351 2
a352 1
			   _("Implicitly sized type can not contain bitfield \"%s\""), 
d357 2
a358 1
			   _("Bitfield \"%s\" goes past 64 bits (unsupported)"),
d370 2
a371 1
	    gdb_xml_error (parser, _("Bitfield \"%s\" does not fit in struct"));
@


1.22
log
@2010-05-17  Michael Snyder  <msnyder@@vmware.com>

	* valarith.c: White space.
	* valops.c: White space.
	* valprint.c: White space.
	* value.c: White space.
	* varobj.c: White space.
	* xcoffread.c: White space.
	* xml-support.c: White space.
	* xml-tdesc.c: White space.
@
text
@d3 1
a3 1
   Copyright (C) 2006, 2008, 2009, 2010 Free Software Foundation, Inc.
@


1.21
log
@2010-05-06  Michael Snyder  <msnyder@@vmware.com>

	* xml-support.c (xinclude_start_include): Delete unused variable.
	(xml_process_xincludes): Delete unused variable.
	* xml-syscall.c (syscall_parse_xml): Delete unused variable.
	* target-descriptions.c (tdesc_gdb_type): Delete unused variable.
	(tdesc_find_arch_register): Delete unused variable.
	(tdesc_use_registers): Delete unused variable.
	* xml-tdesc.c (tdesc_start_target): Delete unused variable.
	* inferior.c (print_inferior): Delete unused variable.
	* record.c (record_open_1): Delete unused variable.
	(record_restore): Delete unused variable.
	(cmd_record_save): Delete unused variable.
	* gcore.c (derive_heap_segment): Delete unused variable.
	(objfile_find_memory_regions): Use unused variable.
	* jit.c (jit_inferior_init): Delete unused variable.
	* progspace.c (clone_program_space): Delete unused variable.
	(pspace_empty_p): Delete unused variable.
@
text
@d264 1
@


1.20
log
@	* gdbtypes.c (append_composite_type_field_raw): New.
	(append_composite_type_field_aligned): Use the new function.
	* gdbtypes.h (append_composite_type_field_raw): Declare.
	* target-descriptions.c (struct tdesc_type_field): Add start and end.
	(struct tdesc_type_flag): New type.
	(struct tdesc_type): Add TDESC_TYPE_STRUCT and TDESC_TYPE_FLAGS to
	kind.  Add size to u.u.  Add u.f for flags.
	(tdesc_gdb_type): Handle TDESC_TYPE_STRUCT and TDESC_TYPE_FLAGS.
	(tdesc_free_type): Likewise.
	(tdesc_create_struct, tdesc_set_struct_size, tdesc_create_flags): New.
	(tdesc_add_field): Handle TDESC_TYPE_STRUCT.
	(tdesc_add_bitfield, tdesc_add_flag): New.
	* target-descriptions.h (tdesc_create_struct, tdesc_set_struct_size)
	(tdesc_create_flags, tdesc_add_bitfield, tdesc_add_flag): Declare.
	* xml-tdesc.c (struct tdesc_parsing_data): Rename current_union to
	current_type.  Add current_type_size and current_type_is_flags.
	(tdesc_start_union): Clear the new fields.
	(tdesc_start_struct, tdesc_start_flags): New.
	(tdesc_start_field): Handle struct fields, including bitfields.
	(field_attributes): Make type optional.  Add start and end.
	(union_children): Rename to struct_union_children.
	(union_attributes): Rename to struct_union_attributes.  Add optional
	size.
	(flags_attributes): New.
	(feature_children): Add struct and flags.
	* features/gdb-target.dtd: Add flags and struct to features.
	Make field type optional.  Add field start and end.

	doc/
	* gdb.texinfo (Types): Describe <struct> and <flags>.

	testsuite/
	* gdb.xml/extra-regs.xml: Add struct1, struct2, and flags
	types.  Add structreg, bitfields, and flags registers.
	* gdb.xml/tdesc-regs.exp: Test structreg and bitfields
	registers.
@
text
@a154 1
  struct tdesc_parsing_data *data = user_data;
@


1.19
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d88 9
a96 2
  /* The union we are currently parsing, or last parsed.  */
  struct tdesc_type *current_union;
d239 47
a285 1
  data->current_union = tdesc_create_union (data->current_feature, id);
d289 1
a289 1
   current union.  */
d297 1
d301 3
d305 60
a364 2
  field_name = attrs[0].value;
  field_type_id = attrs[1].value;
d366 2
a367 5
  field_type = tdesc_named_type (data->current_feature, field_type_id);
  if (field_type == NULL)
    gdb_xml_error (parser, _("Union field \"%s\" references undefined "
			     "type \"%s\""),
		   field_name, field_type_id);
d369 6
a374 1
  tdesc_add_field (data->current_union, field_name, field_type);
d407 3
a409 1
  { "type", GDB_XML_AF_NONE, NULL, NULL },
d413 1
a413 1
static const struct gdb_xml_element union_children[] = {
d430 1
a430 1
static const struct gdb_xml_attribute union_attributes[] = {
d432 7
d458 4
a461 1
  { "union", union_attributes, union_children,
d464 3
@


1.18
log
@Implementing catch syscall.

* amd64-linux-tdep.c: Include xml-syscall.h header, define the XML
syscall name for the architecture.
(amd64_linux_get_syscall_number): New function.
(amd64_linux_init_abi): Register the correct functions for syscall
catchpoint; set the correct syscall file name.
* breakpoint.c: New include: xml-syscall.h.
(set_raw_breakpoint_without_location): Setting the parameters
for the catch syscall feature.
(insert_catch_syscall): New.
(remove_catch_syscall): New.
(breakpoint_hit_catch_syscall): New.
(print_it_catch_syscall): New.
(print_one_catch_syscall): New.
(print_mention_catch_syscall): New.
(catch_syscall_breakpoint_ops): New.
(syscall_catchpoint_p): New.
(create_catchpoint_without_mention): New.
(create_catchpoint): Modified in order to use
create_catchpoint_without_mention.
(create_syscall_event_catchpoint): New.
(clean_up_filters): New.
(catch_syscall_split_args): New.
(catch_syscall_command_1): New.
(delete_breakpoint): Add cleanup for catch syscall.
(is_syscall_catchpoint_enabled): New.
(catch_syscall_enabled): New.
(catching_syscall_number): New.
(catch_syscall_completer): New completer function.
(add_catch_command): Add the completer function for catchpoints.
* breakpoint.h (syscalls_to_be_caught): New vector.
(catch_syscall_enabled): New.
(catching_syscall_number): New.
* gdbarch.c: Regenerated.
* gdbarch.h: Regenerated.
* gdbarch.sh: Add syscall catchpoint functions and structures.
(get_syscall_number): New.
(UNKNOWN_SYSCALL): New definition.
* i386-linux-nat.c (i386_linux_resume): Select the proper request
to be made for ptrace() considering if we are catching syscalls
or not.
* i386-linux-tdep.c: Include xml-syscall.h header, define the XML
syscall name for the architecture.
(i386_linux_get_syscall_number): New.
(i386_linux_init_abi): Register the correct functions for syscall
catchpoint; set the correct syscall file name.
* inf-child.c (inf_child_set_syscall_catchpoint): New.
(inf_child_target): Assign default values to target_ops.
* inf-ptrace.c (inf_ptrace_resume): Select the proper request
to be made for ptrace() considering if we are catching syscalls
or not.
* inferior.h (struct inferior): Included new variables
any_syscall_count, syscalls_counts and total_syscalls_count,
used to keep track of requested syscall catchpoints.
* infrun.c (resume): Add syscall catchpoint.
(deal_with_syscall_event): New.
(handle_inferior_event): Add syscall entry/return events.
(inferior_has_called_syscall): New.
* linux-nat.c: Define some helpful variables to track wether we have
support for the needed ptrace option.
(linux_test_for_tracesysgood): New.
(linux_supports_tracesysgood): New.
(linux_enable_tracesysgood): New.
(linux_enable_event_reporting): Save the current used ptrace
options.
(linux_child_post_attach): Calling linux_enable_tracesysgood.
(linux_child_post_startup_inferior): Likewise.
(linux_child_set_syscall_catchpoint): New function.
(linux_handle_extended_wait): Handle the case which the inferior stops
because it has called or returned from a syscall.
(linux_target_install_ops): Install the necessary functions to handle
syscall catchpoints.
* linux-nat.h (struct lwp_info): Include syscall_state into the
structure, which indicates if we are in a syscall entry or return.
* ppc-linux-tdep.c: Include xml-syscall.h header, define the XML
syscall filename for the arch.
(ppc_linux_get_syscall_number): New.
(ppc_linux_init_abi): Register the correct functions for syscall
catchpoint; setting the correct name for the XML syscall file.
* target.c (update_current_target): Update/copy functions related to
syscall catchpoint.
(target_waitstatus_to_string): Add syscall catchpoint entry/return
events.
* target.h (struct target_waitstatus): Add syscall number.
(struct syscall): New struct to hold information about syscalls
in the system.
(struct target_ops): Add ops for syscall catchpoint.
(inferior_has_called_syscall): New.
(target_set_syscall_catchpoint): New.
* xml-support.c (xml_fetch_content_from_file): New function,
transferred from xml-tdesc.c.
* xml-support.h (xml_fetch_content_from_file): New.
* xml-tdesc.c (fetch_xml_from_file): Function removed;
transferred to xml-support.c.
(file_read_description_xml): Updated to use the new
xml_fetch_content_from_file function.
* syscalls/gdb-syscalls.dtd: New definition file for syscall's XML
support.
* syscalls/amd64-linux.xml: New file containing information about
syscalls for GNU/Linux systems that use amd64 architecture.
* syscalls/i386-linux.xml: New file containing information about
syscalls for GNU/Linux systems that use i386 architecture.
* syscalls/ppc-linux.xml: New file containing information about
syscalls for GNU/Linux systems that use PPC architecture.
* syscalls/ppc64-linux.xml: New file containing information about
syscalls for GNU/Linux systems that use PPC64 architecture.
* xml-syscall.c: New file containing functions for manipulating
syscall's XML files.
* xml-syscall.h: New file, exporting the functions above mentioned.
* Makefile.in: Support for relocatable GDB datadir and XML
syscall.
* NEWS: Added information about the catch syscall feature.
* doc/gdb.texinfo (Set Catchpoints): Documentation about the new
feature.
* testsuite/Makefile.in: Inclusion of catch-syscall object.
* testsuite/gdb.base/catch-syscall.c: New file.
* testsuite/gdb.base/catch-syscall.exp: New file.
@
text
@d3 1
a3 1
   Copyright (C) 2006, 2008, 2009 Free Software Foundation, Inc.
@


1.17
log
@ChangeLog:

	* features/gdb-target.dtd (target): Accept optional
	<compatible> elements.
	(compatible): Define element.

	* target-descriptions.h (tdesc_compatible_p): New.
	(tdesc_add_compatible): New.
	* target-descriptions.c (arch_p): New VEC_P type.
	(struct target_desc): New member compatible.
	(free_target_description): Handle it.
	(maint_print_c_tdesc_cmd): Likewise.
	(tdesc_compatible_p): New function.
	(tdesc_add_compatible): New function.

	* xml-tdesc.c (tdesc_end_compatible): New function.
	(target_children): Handle <compatible> element.

	* arch-utils.c (choose_architecture_for_target): Accept target
	description instead of BFD architecture as input.  Query target
	description for compatible architectures.
	(gdbarch_info_fill): Update call.

	* NEWS: Mention <compatible> element of target descriptions.

doc/ChangeLog:

	* gdb.texinfo (Target Descriptions): Document <compatible> element.
@
text
@a428 63
/* Open FILENAME, read all its text into memory, close it, and return
   the text.  If something goes wrong, return NULL and warn.  */

static char *
fetch_xml_from_file (const char *filename, void *baton)
{
  const char *dirname = baton;
  FILE *file;
  struct cleanup *back_to;
  char *text;
  size_t len, offset;

  if (dirname && *dirname)
    {
      char *fullname = concat (dirname, "/", filename, (char *) NULL);
      if (fullname == NULL)
	nomem (0);
      file = fopen (fullname, FOPEN_RT);
      xfree (fullname);
    }
  else
    file = fopen (filename, FOPEN_RT);

  if (file == NULL)
    return NULL;

  back_to = make_cleanup_fclose (file);

  /* Read in the whole file, one chunk at a time.  */
  len = 4096;
  offset = 0;
  text = xmalloc (len);
  make_cleanup (free_current_contents, &text);
  while (1)
    {
      size_t bytes_read;

      /* Continue reading where the last read left off.  Leave at least
	 one byte so that we can NUL-terminate the result.  */
      bytes_read = fread (text + offset, 1, len - offset - 1, file);
      if (ferror (file))
	{
	  warning (_("Read error from \"%s\""), filename);
	  do_cleanups (back_to);
	  return NULL;
	}

      offset += bytes_read;

      if (feof (file))
	break;

      len = len * 2;
      text = xrealloc (text, len);
    }

  fclose (file);
  discard_cleanups (back_to);

  text[offset] = '\0';
  return text;
}

d440 1
a440 1
  tdesc_str = fetch_xml_from_file (filename, NULL);
d453 1
a453 1
  tdesc = tdesc_parse_xml (tdesc_str, fetch_xml_from_file, dirname);
@


1.16
log
@2009-07-20  Pedro Alves  <pedro@@codesourcery.com>

	* features/gdb-target.dtd (target): Accept an optional 'osabi'
	element.
	(osabi): Define element.
	* features/mips-linux.xml (target): Add an osabi subelement set to
	GNU/Linux.
	* regformats/regdat.sh (xmlarch, xmlosabi): New variables.  Don't
	write the architecture into $xmltarget.  Store it in $xmlarch.
	Handle the 'osabi' type.  Handle outputting the osabi element of
	the target description.
	* regformats/reg-x86-64-linux.dat (osabi): Set to GNU/Linux.
	* regformats/reg-i386-linux.dat (osabi): Set to GNU/Linux.

	* target-descriptions.h (tdesc_osabi, set_tdesc_osabi): Declare.
	* target-descriptions.c (struct target_desc) <osabi>: New field.
	(tdesc_osabi): New function.
	(set_tdesc_osabi): New function.
	* xml-tdesc.c: Include osabi.h.
	(tdesc_end_osabi): New.
	(target_children): Parse "osabi" elements.
	* arch-utils.c (gdbarch_info_fill): Try to get the osabi from the
	target description if the user didn't override it or it is not
	extractable from the bfd.  If that still fails, fallback to the
	configured in default.
	* osabi.h (osabi_from_tdesc_string): Declare.
	* osabi.c (osabi_from_tdesc_string): New.
	(gdbarch_lookup_osabi): Return GDB_OSABI_UNKNOWN instead of
	GDB_OSABI_DEFAULT.

	* NEWS: Mention that target descriptions can now describe the
	target OS ABI.

2009-07-20  Pedro Alves  <pedro@@codesourcery.com>

	* gdb.texinfo (Target Description Format): Mention the new <osabi>
	optional element.
	(subsection OS ABI): New subsection.
@
text
@d127 14
d351 2
@


1.15
log
@	* target-descriptions.h (struct type): Do not declare.
	(struct tdesc_type): Declare.
	(tdesc_named_type): Change return type to struct tdesc_type *.
	(tdesc_record_type): Remove.
	(tdesc_create_vector): Add prototype.
	(tdesc_create_union): Likewise.
	(tdesc_add_field): Likewise.

	* target-descriptions.c (struct tdesc_reg): Replace gdb_type
	member by tdesc_type member.
	(struct tdesc_type_field, tdesc_type_field): Add type and vector def.
	(struct tdesc_type, tdesc_type_p): Likewise.
	(struct tdesc_arch_reg, tdesc_arch_reg): Likewise.
	(struct tdesc_feature): Change type of "types" to VEC(tdesc_type_p).
	(struct tdesc_arch_data): Replace registers member by arch_regs.

	(tdesc_predefined_types): Change to array of pre-defined
	struct tdesc_type structures.  Add "code_ptr" and "data_ptr".
	(tdesc_named_type): Return struct tdesc_type * instead of GDB type.
	(tdesc_gdb_type): New function.

	(target_find_description): Update for data structure changes.
	(tdesc_data_cleanup): Likewise.
	(tdesc_numbered_register): Likewise.
	(tdesc_use_registers): Likewise.
	(tdesc_create_reg): Likewise.

	(tdesc_find_arch_register): New function.
	(tdesc_find_register): Use it.
	(tdesc_register_type): Use tdesc_gdb_type to generate GDB type from
	tdesc_type on demand; cache generated types in tdesc_arch_reg.

	(tdesc_free_type): New function.
	(tdesc_free_feature): Call it.

	(tdesc_create_vector): New function.
	(tdesc_create_union): Likewise.
	(tdesc_add_field): Likewise.
	(tdesc_record_type): Remove.

	(tdesc_type_id): Remove.
	(maint_print_c_tdesc_cmd): Update for data structure changes.  Update
	generated code to create tdesc_type structures instead of GDB types.

	* xml-tdesc.c: Do not include "gdbtypes.h".
	(struct tdesc_parsing_data): Change type of current_union to
	struct tdesc_type *.
	(tdesc_start_reg): Do not special-case "code_ptr" or "data_ptr".
	(tdesc_start_union): Call tdesc_create_union.
	(tdesc_start_field): Call tdesc_add_field.
	(tdesc_start_vector): Call tdesc_create_vector.
	(tdesc_end_union): Remove.
	(feature_children): Remove reference to tdesc_end_union.

	* features/arm-with-iwmmxt.c: Regenerate.
	* features/mips-linux.c: Regenerate.
	* features/mips64-linux.c: Regenerate.
	* features/rs6000/powerpc-32.c: Regenerate.
	* features/rs6000/powerpc-32l.c: Regenerate.
	* features/rs6000/powerpc-403.c: Regenerate.
	* features/rs6000/powerpc-403gc.c: Regenerate.
	* features/rs6000/powerpc-505.c: Regenerate.
	* features/rs6000/powerpc-601.c: Regenerate.
	* features/rs6000/powerpc-602.c: Regenerate.
	* features/rs6000/powerpc-603.c: Regenerate.
	* features/rs6000/powerpc-604.c: Regenerate.
	* features/rs6000/powerpc-64.c: Regenerate.
	* features/rs6000/powerpc-64l.c: Regenerate.
	* features/rs6000/powerpc-7400.c: Regenerate.
	* features/rs6000/powerpc-750.c: Regenerate.
	* features/rs6000/powerpc-860.c: Regenerate.
	* features/rs6000/powerpc-altivec32.c: Regenerate.
	* features/rs6000/powerpc-altivec32l.c: Regenerate.
	* features/rs6000/powerpc-altivec64.c: Regenerate.
	* features/rs6000/powerpc-altivec64l.c: Regenerate.
	* features/rs6000/powerpc-e500.c: Regenerate.
	* features/rs6000/powerpc-e500l.c: Regenerate.
	* features/rs6000/powerpc-isa205-32l.c: Regenerate.
	* features/rs6000/powerpc-isa205-64l.c: Regenerate.
	* features/rs6000/powerpc-isa205-altivec32l.c: Regenerate.
	* features/rs6000/powerpc-isa205-altivec64l.c: Regenerate.
	* features/rs6000/powerpc-isa205-vsx32l.c: Regenerate.
	* features/rs6000/powerpc-isa205-vsx64l.c: Regenerate.
	* features/rs6000/powerpc-vsx32.c: Regenerate.
	* features/rs6000/powerpc-vsx32l.c: Regenerate.
	* features/rs6000/powerpc-vsx64.c: Regenerate.
	* features/rs6000/powerpc-vsx64l.c: Regenerate.
	* features/rs6000/rs6000.c: Regenerate.
@
text
@d27 1
d109 18
d335 2
@


1.14
log
@        Updated copyright notices for most files.
@
text
@a22 1
#include "gdbtypes.h"
d88 1
a88 1
  struct type *current_union;
a177 2
      && strcmp (type, "code_ptr") != 0
      && strcmp (type, "data_ptr") != 0
a197 1
  struct type *type;
d199 1
a199 25
  type = init_composite_type (NULL, TYPE_CODE_UNION);
  TYPE_NAME (type) = xstrdup (id);
  tdesc_record_type (data->current_feature, type);
  data->current_union = type;
}

/* Handle the end of a <union> element.  */

static void
tdesc_end_union (struct gdb_xml_parser *parser,
		 const struct gdb_xml_element *element,
		 void *user_data, const char *body_text)
{
  struct tdesc_parsing_data *data = user_data;
  int i;

  /* If any of the children of this union are vectors, flag the union
     as a vector also.  This allows e.g. a union of two vector types
     to show up automatically in "info vector".  */
  for (i = 0; i < TYPE_NFIELDS (data->current_union); i++)
    if (TYPE_VECTOR (TYPE_FIELD_TYPE (data->current_union, i)))
      {
        TYPE_VECTOR (data->current_union) = 1;
        break;
      }
d212 1
a212 1
  struct type *type, *field_type;
d224 1
a224 2
  append_composite_type_field (data->current_union, xstrdup (field_name),
			       field_type);
d237 1
a237 1
  struct type *type, *field_type, *range_type;
d250 1
a250 4
  type = init_vector_type (field_type, count);
  TYPE_NAME (type) = xstrdup (id);

  tdesc_record_type (data->current_feature, type);
d301 1
a301 1
    tdesc_start_union, tdesc_end_union },
@


1.13
log
@	* cli/cli-script.c (do_fclose_cleanup): Remove.
	(script_from_file): Use make_cleanup_fclose.
	* xml-tdesc.c (do_cleanup_fclose): Remove.
	(fetch_xml_from_file): Use make_cleanup_fclose.
	* tracepoint.c (tracepoint_save_command): Use
	make_cleanup_fclose.  Always free pathname.
	* source.c (print_source_lines_base): Use make_cleanup_fclose.
	* remote.c (fclose_cleanup): Remove.
	(remote_file_put): Use make_cleanup_fclose.
	(remote_file_get): Likewise.
	* linux-nat.c (linux_nat_find_memory_regions): Use
	make_cleanup_fclose.
	(linux_nat_info_proc_cmd): Likewise.
	(linux_proc_pending_signals): Likewise.
	* fbsd-nat.c (fbsd_find_memory_regions): Use make_cleanup_fclose.
	Free file name.
	* cli/cli-dump.c (do_fclose_cleanup): Remove.
	(make_cleanup_fclose): Remove.
	* defs.h (make_cleanup_fclose): Declare.
	* utils.c (do_fclose_cleanup): New function.
	(make_cleanup_fclose): Likewise.
@
text
@d3 1
a3 1
   Copyright (C) 2006, 2008 Free Software Foundation, Inc.
@


1.12
log
@gdb:
	* xml-tdesc.c (tdesc_end_union): Update.
	* stabsread.c (define_symbol): Update.
	(read_type): Update.
	(read_struct_type): Update.
	(read_enum_type): Update.
	* spu-tdep.c (spu_builtin_type_vec128): Update.
	* sh-tdep.c (sh_push_dummy_call_fpu): Update.
	(sh_push_dummy_call_nofpu): Update.
	* mdebugread.c (parse_symbol): Update.
	(parse_symbol): Update.
	(parse_symbol): Update.
	(upgrade_type): Update.
	* jv-lang.c (java_lookup_class): Update.
	* iq2000-tdep.c (iq2000_pointer_to_address): Update.
	* i386-tdep.c (i386_mmx_type): Update.
	(i386_sse_type): Update.
	* gdbtypes.h (enum type_flag_value): New enum.
	(enum type_instance_flag_value): New enum.
	(TYPE_FLAG_UNSIGNED, TYPE_FLAG_NOSIGN, TYPE_FLAG_STUB,
	TYPE_FLAG_TARGET_STUB, TYPE_FLAG_STATIC, TYPE_FLAG_PROTOTYPED,
	TYPE_FLAG_INCOMPLETE, TYPE_FLAG_VARARGS, TYPE_FLAG_VECTOR,
	TYPE_FLAG_FIXED_INSTANCE, TYPE_FLAG_STUB_SUPPORTED,
	TYPE_FLAG_NOTTEXT): Now enum constants.
	(TYPE_FLAG_CONST, TYPE_FLAG_VOLATILE, TYPE_FLAG_CODE_SPACE,
	TYPE_FLAG_DATA_SPACE, TYPE_FLAG_ADDRESS_CLASS_1,
	TYPE_FLAG_ADDRESS_CLASS_2): Remove.
	(TYPE_INSTANCE_FLAG_CONST, TYPE_INSTANCE_FLAG_VOLATILE,
	TYPE_INSTANCE_FLAG_CODE_SPACE, TYPE_INSTANCE_FLAG_DATA_SPACE,
	TYPE_INSTANCE_FLAG_ADDRESS_CLASS_1,
	TYPE_INSTANCE_FLAG_ADDRESS_CLASS_2): New constants.
	(TYPE_UNSIGNED, TYPE_NOSIGN, TYPE_STUB, TYPE_TARGET_STUB,
	TYPE_STATIC, TYPE_PROTOTYPED, TYPE_INCOMPLETE, TYPE_VARARGS,
	TYPE_VECTOR, TYPE_FIXED_INSTANCE, TYPE_STUB_SUPPORTED,
	TYPE_NOTTEXT): Update.
	(TYPE_FLAG_ADDRESS_CLASS_ALL): Remove.
	(TYPE_INSTANCE_FLAG_ADDRESS_CLASS_ALL): New define.
	(TYPE_VOLATILE, TYPE_CODE_SPACE, TYPE_DATA_SPACE,
	TYPE_ADDRESS_CLASS_1, TYPE_ADDRESS_CLASS_2,
	TYPE_ADDRESS_CLASS_ALL): Update.
	(struct main_type) <flags>: Remove.
	<flag_unsigned, flag_nosign, flag_stub, flag_target_stub,
	flag_static, flag_prototyped, flag_incomplete, flag_varargs,
	flag_vector, flag_stub_supported, flag_nottext,
	flag_fixed_instance>: New fields.
	<nfields, vptr_fieldno>: Move earlier.
	(TYPE_FLAGS): Remove.
	* gdbtypes.c (make_pointer_type): Update.
	(address_space_name_to_int): Update.
	(address_space_int_to_name): Update.
	(make_type_with_address_space): Update.
	(make_cv_type): Update.
	(create_range_type): Update.
	(get_discrete_bounds): Update.
	(create_set_type): Update.
	(make_vector_type): Update.
	(smash_to_method_type): Update.
	(check_typedef): Update.
	(check_stub_method): Update.
	(init_type): Individually assign flag fields.
	(recursive_dump_type): Don't print entire TYPE_FLAGS field.  Do
	print TYPE_FIXED_INSTANCE, TYPE_STUB_SUPPORTED, and TYPE_NOTTEXT.
	(copy_type_recursive): Copy the entire main type.  Don't use
	TYPE_FLAGS.
	* features/rs6000/powerpc-altivec64l.c
	(initialize_tdesc_powerpc_altivec64l): Update.
	* features/rs6000/powerpc-altivec64.c
	(initialize_tdesc_powerpc_altivec64): Update.
	* features/rs6000/powerpc-altivec32l.c
	(initialize_tdesc_powerpc_altivec32l): Update.
	* features/rs6000/powerpc-altivec32.c
	(initialize_tdesc_powerpc_altivec32): Update.
	* features/rs6000/powerpc-7400.c (initialize_tdesc_powerpc_7400):
	Update.
	* features/arm-with-iwmmxt.c (initialize_tdesc_arm_with_iwmmxt):
	Update.
	* dwarf2read.c (read_structure_type): Update.
	(read_enumeration_type): Likewise.
	(process_enumeration_scope): Likewise.
	(read_tag_pointer_type): Likewise.
	(read_subroutine_type): Likewise.
	(read_subroutine_type): Likewise.
	(read_base_type): Likewise.
	* coffread.c (coff_read_enum_type): Update.
	* ada-valprint.c (adjust_type_signedness): Update.
	* ada-typeprint.c (print_record_field_types): Update.
	* ada-lang.c (packed_array_type): Update.
	(empty_record): Don't reset TYPE_FLAGS.
	(ada_template_to_fixed_record_type_1): Update.
	(ada_template_to_fixed_record_type_1): Likewise.
	(template_to_static_fixed_type): Likewise.
	(to_record_with_fixed_variant_part): Likewise.
	(to_fixed_record_type): Likewise.
	(to_fixed_array_type): Likewise.
	(to_static_fixed_type): Likewise.
gdb/testsuite:
	* gdb.base/maint.exp: Update "maint print type".
@
text
@a423 8
/* Close FILE.  */

static void
do_cleanup_fclose (void *file)
{
  fclose (file);
}

d450 1
a450 1
  back_to = make_cleanup (do_cleanup_fclose, file);
@


1.11
log
@	* buildsym.c (start_subfile): Properly cast sentinel in concat
	call.
	* cp-name-parser.y: Include "config.h".
	* xml-tdesc.c (fetch_xml_from_file): Properly cast sentinel in
	concat call.
	* gdb_select.h: Include sys/time.h if sys/select.h is not
	available.
@
text
@d225 1
a225 1
        TYPE_FLAGS (data->current_union) |= TYPE_FLAG_VECTOR;
@


1.10
log
@	Updated copyright notices for most files.
@
text
@d446 1
a446 1
      char *fullname = concat (dirname, "/", filename, NULL);
@


1.9
log
@	* NEWS: Update description of string changes.  Mention print/s.
	* c-valprint.c (textual_element_type): New.
	(c_val_print): Use it.  Do not skip address printing for pointers
	with a string format.
	(c_value_print): Doc update.
	* dwarf2read.c (read_array_type): Use make_vector_type.
	* gdbtypes.c (make_vector_type): New.
	(init_vector_type): Use it.
	(gdbtypes_post_init): Initialize builtin_true_unsigned_char.
	(_initialize_gdbtypes): Mark int8_t and uint8_t as TYPE_FLAG_NOTTEXT.
	* gdbtypes.h (struct builtin_type): Add builtin_true_unsigned_char.
	(TYPE_FLAG_NOTTEXT, TYPE_NOTTEXT): New.
	(make_vector_type): New.
	* printcmd.c (print_formatted): Only handle 's' and 'i' for examine.
	Call the language print routine for string format.
	(print_scalar_formatted): Call val_print for string format.  Handle
	unsigned original types for char format.
	(validate_format): Do not reject string format.
	* stabsread.c (read_type): Use make_vector_type.
	* xml-tdesc.c (tdesc_start_vector): Use init_vector_type.

	* gdb.texinfo (Output Formats): Update 'c' description.  Describe 's'.
	(Examining Memory): Update mentions of the 's' format.
	(Automatic Display): Likewise.

	* gdb.arch/i386-sse.exp: Do not expect character constants.
	* gdb.base/charsign.c, gdb.base/charsign.exp: Delete.
	* gdb.base/display.exp: Allow print/s.
	* gdb.base/printcmds.exp, gdb.base/setvar.exp: Revert signed
	and unsigned char array changes.
@
text
@d3 1
a3 2
   Copyright (C) 2006
   Free Software Foundation, Inc.
@


1.8
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d280 1
a280 3
  /* A vector is just an array plus a special flag.  */
  range_type = create_range_type (NULL, builtin_type_int, 0, count - 1);
  type = create_array_type (NULL, field_type, range_type);
a282 2
  TYPE_FLAGS (type) |= TYPE_FLAG_VECTOR;

@


1.7
log
@	* gdb.texinfo (Target Description Format): Add version attribute
	for <target>.

	* xml-tdesc.c (tdesc_start_target): New.
	(target_attributes): New.
	(tdesc_elements): Use it.
	* features/gdb-target.dtd: Add #FIXED version attribute for
	<target>.
@
text
@d12 1
a12 1
   the Free Software Foundation; either version 2 of the License, or
d21 1
a21 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.6
log
@	* defs.h (ldirname): New prototype.
	* dwarf2read.c (read_file_scope): Use DW_AT_name if DW_AT_comp_dir is
	missing.
	* utils.c (ldirname): New function.
	* xml-tdesc.c (file_read_description_xml): Use ldirname.
@
text
@d112 16
d347 5
d362 2
a363 2
  { "target", NULL, target_children, GDB_XML_EF_NONE,
    NULL, NULL },
@


1.5
log
@	* target-descriptions.c (tdesc_named_type): Move code_ptr and data_ptr
	handling from here...
	(tdesc_register_type): ...to here.
	* xml-tdesc.c (tdesc_start_reg): Allow code_ptr and data_ptr.
	* features/arm-core.xml: Use code_ptr and data_ptr.
@
text
@a489 1
  const char *base;
d501 3
a503 22
  /* Simple, portable version of dirname that does not modify its
     argument.  */
  base = lbasename (filename);
  while (base > filename && IS_DIR_SEPARATOR (base[-1]))
    --base;
  if (base > filename)
    {
      dirname = xmalloc (base - filename + 2);
      memcpy (dirname, filename, base - filename);

      /* On DOS based file systems, convert "d:foo" to "d:.", so that
	 we create "d:./bar" later instead of the (different)
	 "d:/bar".  */
      if (base - filename == 2 && IS_ABSOLUTE_PATH (base)
	  && !IS_DIR_SEPARATOR (filename[0]))
	dirname[base++ - filename] = '.';

      dirname[base - filename] = '\0';
      make_cleanup (xfree, dirname);
    }
  else
    dirname = NULL;
@


1.4
log
@	* Makefile.in (arm-tdep.o, eval.o, target-descriptions.o)
	(xml-tdesc.o): Update.
	* xml-support.c: Add a comment.
	(gdb_xml_enums_boolean): New variable.
	(gdb_xml_parse_attr_enum): Use strcasecmp.
	* xml-support.h (gdb_xml_enums_boolean): Declare.
	* xml-tdesc.c (struct tdesc_parsing_data): Record current_feature,
	next_regnum, and current_union.
	(tdesc_start_feature, tdesc_start_reg, tdesc_start_union)
	(tdesc_end_union, tdesc_start_field, tdesc_start_vector)
	(field_attributes, union_children, reg_attributes, union_attributes)
	(vector_attributes, feature_attributes, feature_children): New.
	(target_children): Make static.  Add <feature>.
	(tdesc_elements): Make static.
	* target-descriptions.c (struct tdesc_reg, tdesc_reg_p, type_p)
	(struct tdesc_feature, tdesc_feature_p): New types.
	(struct target_desc): Add features member.
	(struct tdesc_arch_data, tdesc_data): New.
	(target_find_description): Clarify error message.  Warn about
	ignored register descriptions.
	(tdesc_has_registers, tdesc_find_feature, tdesc_feature_name)
	(tdesc_named_type, tdesc_data_init, tdesc_data_alloc)
	(tdesc_data_cleanup, tdesc_numbered_register)
	(tdesc_numbered_register_choices, tdesc_find_register)
	(tdesc_register_name, tdesc_register_type)
	(tdesc_remote_register_number, tdesc_register_reggroup_p)
	(set_tdesc_pseudo_register_name, set_tdesc_pseudo_register_type)
	(set_tdesc_pseudo_register_reggroup_p, tdesc_use_registers)
	(tdesc_free_reg, tdesc_create_reg, tdesc_free_feature)
	(tdesc_create_feature, tdesc_record_type): New.
	(free_target_description): Free features.
	(_initialize_target_descriptions): Initialize tdesc_data.
	* arch-utils.c (default_remote_register_number): New.
	* arch-utils.h (default_remote_register_number): New prototype.
	* target-descriptions.h (set_tdesc_pseudo_register_name)
	(set_tdesc_pseudo_register_type, set_tdesc_pseudo_register_reggroup_p)
	(tdesc_use_registers, tdesc_data_alloc, tdesc_data_cleanup)
	(tdesc_numbered_register, tdesc_numbered_register_choices)
	(tdesc_has_registers, tdesc_find_feature, tdesc_feature_name)
	(tdesc_named_type, tdesc_create_feature, tdesc_record_type)
	(tdesc_create_reg): Declare.
	* gdbarch.sh (remote_register_number): New entry.
	* gdbarch.c, gdbarch.h: Regenerate.
	* remote.c (init_remote_state): Use gdbarch_remote_register_number.
	* features/gdb-target.dtd: Add feature, reg, vector, union, and field.

	* arm-tdep.c (arm_register_aliases): New.
	(arm_register_name_strings): Rename to...
	(arm_register_names): ...this.  Make const.  Delete the old version.
	(current_option, arm_register_byte): Delete.
	(set_disassembly_style): Simplify.  Do not adjust arm_register_names.
	(value_of_arm_user_reg): New.
	(arm_gdbarch_init): Verify any described registers.  Call
	tdesc_use_registers.  Don't use arm_register_byte.  Create aliases
	for standard register names.
	(_initialize_arm_tdep): Do not adjust arm_register_names.
	* user-regs.c (struct user_reg): Add baton member.
	(append_user_reg, user_reg_add_builtin, user_regs_init)
	(user_reg_add, value_of_user_reg): Use a baton for user
	register functions.
	* std-regs.c: Update.
	* user-regs.h (user_reg_read_ftype, user_reg_add_builtin)
	(user_reg_add): Add baton argument.
	* NEWS: Mention target description register support.
	* features/arm-core.xml, features/arm-fpa.xml: New.
	* eval.c (evaluate_subexp_standard): Allow ptype $register
	when the program is not running.

	* gdb.texinfo (-target-disconnect): Use @@smallexample.
	(Requirements): Add anchor for Expat.  Update description.
	(Target Descriptions): Mention Expat.
	(Target Description Format): Document new elements.  Use
	@@smallexample.
	(Predefined Target Types, Standard Target Features): New sections.
	* doc/gdbint.texinfo (Target Descriptions): New section.

	* gdb.xml/single-reg.xml, gdb.xml/tdesc-regs.exp,
	gdb.xml/core-only.xml, gdb.xml/extra-regs.xml: New files.
@
text
@d166 2
@


1.3
log
@	* xml-tdesc.c (struct tdesc_xml_cache, tdesc_xml_cache_s)
	(xml_cache): New.
	(tdesc_parse_xml): Cache expanded descriptions.
@
text
@d26 1
d83 10
d112 162
d276 54
a329 1
const struct gdb_xml_element target_children[] = {
d332 3
d338 1
a338 1
const struct gdb_xml_element tdesc_elements[] = {
@


1.2
log
@	* Makefile.in (XMLFILES): New.
	(COMMON_OBS): Add xml-builtin.o.
	(xml-builtin.c, stamp-xml): New rules.
	(xml-tdesc.o): Update.
	* features/feature_to_c.sh: New file.
	* xml-support.c (MAX_XINCLUDE_DEPTH): Define.
	(struct gdb_xml_parser): Add dtd_name and is_xinclude.
	(gdb_xml_start_element): Initialize scope after possibly reallocating
	scopes.  Move cleanup later.  Handle the XInclude description
	specially.
	(gdb_xml_end_element): Only parse the body if there is a current element.
	Call XML_DefaultCurrent if there is no element.
	(gdb_xml_fetch_external_entity, gdb_xml_use_dtd): New.
	(struct xinclude_parsing_data, xinclude_start_include)
	(xinclude_end_include, xml_xinclude_default)
	(xml_xinclude_start_doctype, xml_xinclude_end_doctype)
	(xml_xinclude_xml_decl, xml_xinclude_cleanup, xinclude_attributes)
	(xinclude_elements, xml_process_xincludes, fetch_xml_builtin): New.
	* xml-support.h (xml_fetch_another, xml_process_xincludes)
	(fetch_xml_builtin, xml_builtin, gdb_xml_use_dtd): New declarations.
	* xml-tdesc.c (tdesc_parse_xml): Add fetcher_baton argument.  Expand
	XInclude directives.  Use the compiled in DTD.
	(fetch_xml_from_file): Add baton argument.  Treat it as a containing
	directory name.  Do not warn here.
	(file_read_description_xml): Update call.  Warn here instead.  Pass
	a dirname as baton.
	(fetch_available_features_from_target): New.
	(target_read_description_xml): Use it.
	* features/gdb-target.dtd: Add copyright notice.  Use xinclude.dtd
	to handle XInclude.
	* features/xinclude.dtd: New file.

	* gdb.xml/bad-include.xml, gdb.xml/inc-2.xml, gdb.xml/inc-body.xml,
	gdb.xml/includes.xml, gdb.xml/tdesc-xinclude.exp: New files.

	* gdb.texinfo (Target Description Format): Add section on XInclude.
@
text
@d58 18
d124 1
d126 1
a135 1
  back_to = make_cleanup (xfree, expanded_text);
d137 11
d155 1
d160 5
@


1.1
log
@XML feature description support.

	* NEWS: Mention target descriptions, "set tdesc filename",
	"unset tdesc filename", "show tdesc filename", and
	qXfer:features:read.
	* arch-utils.c (choose_architecture_for_target): New function.
	(gdbarch_info_fill): Call it.
	* target-descriptions.c (struct property): Make members non-const.
	(struct target_desc): Add arch member.
	(target_description_filename): New variable.
	(target_find_description): Try via XML first.
	(tdesc_architecture): New.
	(free_target_description, make_cleanup_free_target_description): New.
	(set_tdesc_property): Call xstrdup.
	(set_tdesc_architecture, tdesc_set_cmdlist, tdesc_show_cmdlist)
	(tdesc_unset_cmdlist, unset_tdesc_cmd, unset_tdesc_filename_cmd)
	(set_tdesc_cmd, show_tdesc_cmd, set_tdesc_filename_cmd)
	(show_tdesc_filename_cmd, _initialize_target_descriptions): New.
	* target-descriptions.h (tdesc_architecture)
	(make_cleanup_free_target_description, set_tdesc_architecture): New
	prototypes.
	* Makefile.in (SFILES): Add xml-tdesc.c.
	(COMMON_OBS): Add xml-tdesc.o.
	(target-descriptions.o): Update.
	(xml-tdesc.o): New rule.
	* xml-tdesc.c, xml-tdesc.h: New files.
	* remote.c (PACKET_qXfer_features): New enum.
	(remote_protocol_features): Add qXfer:features:read.
	(remote_xfer_partial): Handle TARGET_OBJECT_AVAILABLE_FEATURES.
	(_initialize_remote): Register qXfer:features:read.
	* target.h (enum target_object): Add TARGET_OBJECT_AVAILABLE_FEATURES.
	* features/gdb-target.dtd: New file.

	* linux-i386-low.c (the_low_target): Set arch_string.
	* linux-x86-64-low.c (the_low_target): Likewise.
	* linux-low.c (linux_arch_string): New.
	(linux_target_ops): Add it.
	* linux-low.h (struct linux_target_ops): Add arch_string.
	* server.c (write_qxfer_response): Use const void * for DATA.
	(get_features_xml): New.
	(handle_query): Handle qXfer:features:read.  Report it for qSupported.
	* target.h (struct target_ops): Add arch_string method.

	* gdb.texinfo (Target Descriptions): New section.
	(General Query Packets): Add QPassSignals anchor.  Mention
	qXfer:features:read under qSupported.  Expand mentions of
	qXfer:memory-map:read and QPassSignals.  Document
	qXfer:features:read.
@
text
@d31 2
d41 2
a42 1
tdesc_parse_xml (const char *document)
d100 2
a101 1
tdesc_parse_xml (const char *document)
d106 1
d108 9
a116 1
  memset (&data, 0, sizeof (struct tdesc_parsing_data));
a117 1
  back_to = make_cleanup (null_cleanup, NULL);
d120 1
d122 1
d126 1
a126 1
  if (gdb_xml_parse (parser, document) == 0)
a139 1

d155 1
a155 1
fetch_xml_from_file (const char *filename)
d157 1
d163 1
a163 2
  file = fopen (filename, FOPEN_RT);
  if (file == NULL)
d165 5
a169 2
      warning (_("Could not open \"%s\""), filename);
      return NULL;
d171 6
d223 2
d226 1
a226 1
  tdesc_str = fetch_xml_from_file (filename);
d228 4
a231 1
    return NULL;
d234 25
a258 1
  tdesc = tdesc_parse_xml (tdesc_str);
d264 20
d294 1
a294 2
  tdesc_str = target_read_stralloc (ops, TARGET_OBJECT_AVAILABLE_FEATURES,
				    "target.xml");
d299 3
a301 1
  tdesc = tdesc_parse_xml (tdesc_str);
@

