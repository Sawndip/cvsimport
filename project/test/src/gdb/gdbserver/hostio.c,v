head	1.23;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.21
	gdb_7_6-2013-04-26-release:1.21
	gdb_7_6-branch:1.21.0.2
	gdb_7_6-2013-03-12-branchpoint:1.21
	gdb_7_5_1-2012-11-29-release:1.18.2.1
	gdb_7_5-2012-08-17-release:1.18.2.1
	gdb_7_5-branch:1.18.0.2
	gdb_7_5-2012-07-18-branchpoint:1.18
	gdb_7_4_1-2012-04-26-release:1.15.4.1
	gdb_7_4-2012-01-24-release:1.15.4.1
	gdb_7_4-branch:1.15.0.4
	gdb_7_4-2011-12-13-branchpoint:1.15
	gdb_7_3_1-2011-09-04-release:1.15
	gdb_7_3-2011-07-26-release:1.15
	gdb_7_3-branch:1.15.0.2
	gdb_7_3-2011-04-01-branchpoint:1.15
	gdb_7_2-2010-09-02-release:1.10
	gdb_7_2-branch:1.10.0.4
	gdb_7_2-2010-07-07-branchpoint:1.10
	gdb_7_1-2010-03-18-release:1.10
	gdb_7_1-branch:1.10.0.2
	gdb_7_1-2010-02-18-branchpoint:1.10
	gdb_7_0_1-2009-12-22-release:1.9
	gdb_7_0-2009-10-06-release:1.9
	gdb_7_0-branch:1.9.0.4
	gdb_7_0-2009-09-16-branchpoint:1.9
	arc-sim-20090309:1.6
	msnyder-checkpoint-072509-branch:1.9.0.2
	msnyder-checkpoint-072509-branchpoint:1.9
	arc-insight_6_8-branch:1.6.0.14
	arc-insight_6_8-branchpoint:1.6
	insight_6_8-branch:1.6.0.12
	insight_6_8-branchpoint:1.6
	reverse-20081226-branch:1.7.0.2
	reverse-20081226-branchpoint:1.7
	multiprocess-20081120-branch:1.6.0.10
	multiprocess-20081120-branchpoint:1.6
	reverse-20080930-branch:1.6.0.8
	reverse-20080930-branchpoint:1.6
	reverse-20080717-branch:1.6.0.6
	reverse-20080717-branchpoint:1.6
	msnyder-reverse-20080609-branch:1.6.0.4
	msnyder-reverse-20080609-branchpoint:1.6
	gdb_6_8-2008-03-27-release:1.6
	gdb_6_8-branch:1.6.0.2
	gdb_6_8-2008-02-26-branchpoint:1.6
	gdb-csl-symbian-6_4_50_20060226-12:1.1.2.1
	gdb-csl-symbian-6_4_50_20060226-11:1.1.2.1
	gdb-csl-symbian-6_4_50_20060226-10:1.1.2.1
	gdb-csl-symbian-6_4_50_20060226-9:1.1.2.1
	gdb-csl-symbian-6_4_50_20060226-8:1.1.2.1
	gdb-csl-symbian-20060226-branch:1.1.0.2;
locks; strict;
comment	@ * @;


1.23
date	2013.09.05.20.45.39;	author palves;	state Exp;
branches;
next	1.22;

1.22
date	2013.07.01.11.29.17;	author palves;	state Exp;
branches;
next	1.21;

1.21
date	2013.01.01.06.33.00;	author brobecke;	state Exp;
branches;
next	1.20;

1.20
date	2012.11.26.14.19.33;	author palves;	state Exp;
branches;
next	1.19;

1.19
date	2012.08.02.15.52.27;	author uweigand;	state Exp;
branches;
next	1.18;

1.18
date	2012.02.09.17.29.34;	author brobecke;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2012.01.20.09.47.32;	author uweigand;	state Exp;
branches;
next	1.16;

1.16
date	2012.01.04.08.17.23;	author brobecke;	state Exp;
branches;
next	1.15;

1.15
date	2011.03.14.21.26.24;	author msnyder;	state Exp;
branches
	1.15.4.1;
next	1.14;

1.14
date	2011.02.28.15.55.08;	author uweigand;	state Exp;
branches;
next	1.13;

1.13
date	2011.02.28.04.20.30;	author jkratoch;	state Exp;
branches;
next	1.12;

1.12
date	2011.02.27.23.32.04;	author msnyder;	state Exp;
branches;
next	1.11;

1.11
date	2011.01.01.15.33.24;	author brobecke;	state Exp;
branches;
next	1.10;

1.10
date	2010.01.01.07.31.49;	author brobecke;	state Exp;
branches;
next	1.9;

1.9
date	2009.03.13.07.57.47;	author nathan;	state Exp;
branches;
next	1.8;

1.8
date	2009.01.03.05.57.57;	author brobecke;	state Exp;
branches;
next	1.7;

1.7
date	2008.12.14.20.51.04;	author devans;	state Exp;
branches;
next	1.6;

1.6
date	2008.02.01.00.08.25;	author palves;	state Exp;
branches;
next	1.5;

1.5
date	2008.01.01.22.53.14;	author drow;	state Exp;
branches;
next	1.4;

1.4
date	2007.12.16.21.50.05;	author drow;	state Exp;
branches;
next	1.3;

1.3
date	2007.12.01.05.00.04;	author drow;	state Exp;
branches;
next	1.2;

1.2
date	2007.11.30.21.50.19;	author drow;	state Exp;
branches;
next	1.1;

1.1
date	2006.05.23.21.44.20;	author drow;	state dead;
branches
	1.1.2.1;
next	;

1.18.2.1
date	2012.08.02.15.53.45;	author uweigand;	state Exp;
branches;
next	;

1.15.4.1
date	2012.01.06.04.43.37;	author brobecke;	state Exp;
branches;
next	;

1.1.2.1
date	2006.05.23.21.44.20;	author drow;	state Exp;
branches;
next	;


desc
@@


1.23
log
@[gdbserver] Split a new hostio.h file out of server.h.

gdb/gdbserver/
2013-09-05  Pedro Alves  <palves@@redhat.com>

	* server.h (handle_vFile, hostio_last_error_from_errno): Move
	to ...
	* hostio.h: ... this new file.
	* hostio.c, server.c, linux-low.c, nto-low.c, spu-low,
	win32-low.c: Include hostio.h.
@
text
@/* Host file transfer support for gdbserver.
   Copyright (C) 2007-2013 Free Software Foundation, Inc.

   Contributed by CodeSourcery.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "server.h"
#include "gdb/fileio.h"
#include "hostio.h"

#include <fcntl.h>
#include <limits.h>
#include <unistd.h>

extern int remote_debug;

struct fd_list
{
  int fd;
  struct fd_list *next;
};

static struct fd_list *open_fds;

static int
safe_fromhex (char a, int *nibble)
{
  if (a >= '0' && a <= '9')
    *nibble = a - '0';
  else if (a >= 'a' && a <= 'f')
    *nibble = a - 'a' + 10;
  else if (a >= 'A' && a <= 'F')
    *nibble = a - 'A' + 10;
  else
    return -1;

  return 0;
}

/* Filenames are hex encoded, so the maximum we can handle is half the
   packet buffer size.  Cap to PATH_MAX, if it is shorter.  */
#if !defined (PATH_MAX) || (PATH_MAX > (PBUFSIZ / 2 + 1))
#  define HOSTIO_PATH_MAX (PBUFSIZ / 2 + 1)
#else
#  define HOSTIO_PATH_MAX PATH_MAX
#endif

static int
require_filename (char **pp, char *filename)
{
  int count;
  char *p;

  p = *pp;
  count = 0;

  while (*p && *p != ',')
    {
      int nib1, nib2;

      /* Don't allow overflow.  */
      if (count >= HOSTIO_PATH_MAX - 1)
	return -1;

      if (safe_fromhex (p[0], &nib1)
	  || safe_fromhex (p[1], &nib2))
	return -1;

      filename[count++] = nib1 * 16 + nib2;
      p += 2;
    }

  filename[count] = '\0';
  *pp = p;
  return 0;
}

static int
require_int (char **pp, int *value)
{
  char *p;
  int count;

  p = *pp;
  *value = 0;
  count = 0;

  while (*p && *p != ',')
    {
      int nib;

      /* Don't allow overflow.  */
      if (count >= 7)
	return -1;

      if (safe_fromhex (p[0], &nib))
	return -1;
      *value = *value * 16 + nib;
      p++;
      count++;
    }

  *pp = p;
  return 0;
}

static int
require_data (char *p, int p_len, char **data, int *data_len)
{
  int input_index, output_index, escaped;

  *data = xmalloc (p_len);

  output_index = 0;
  escaped = 0;
  for (input_index = 0; input_index < p_len; input_index++)
    {
      char b = p[input_index];

      if (escaped)
	{
	  (*data)[output_index++] = b ^ 0x20;
	  escaped = 0;
	}
      else if (b == '}')
	escaped = 1;
      else
	(*data)[output_index++] = b;
    }

  if (escaped)
    {
      free (*data);
      return -1;
    }

  *data_len = output_index;
  return 0;
}

static int
require_comma (char **pp)
{
  if (**pp == ',')
    {
      (*pp)++;
      return 0;
    }
  else
    return -1;
}

static int
require_end (char *p)
{
  if (*p == '\0')
    return 0;
  else
    return -1;
}

static int
require_valid_fd (int fd)
{
  struct fd_list *fd_ptr;

  for (fd_ptr = open_fds; fd_ptr != NULL; fd_ptr = fd_ptr->next)
    if (fd_ptr->fd == fd)
      return 0;

  return -1;
}

/* Fill in own_buf with the last hostio error packet, however it
   suitable for the target.  */
static void
hostio_error (char *own_buf)
{
  the_target->hostio_last_error (own_buf);
}

static void
hostio_packet_error (char *own_buf)
{
  sprintf (own_buf, "F-1,%x", FILEIO_EINVAL);
}

static void
hostio_reply (char *own_buf, int result)
{
  sprintf (own_buf, "F%x", result);
}

static int
hostio_reply_with_data (char *own_buf, char *buffer, int len,
			int *new_packet_len)
{
  int input_index, output_index, out_maxlen;

  sprintf (own_buf, "F%x;", len);
  output_index = strlen (own_buf);

  out_maxlen = PBUFSIZ;

  for (input_index = 0; input_index < len; input_index++)
    {
      char b = buffer[input_index];

      if (b == '$' || b == '#' || b == '}' || b == '*')
	{
	  /* These must be escaped.  */
	  if (output_index + 2 > out_maxlen)
	    break;
	  own_buf[output_index++] = '}';
	  own_buf[output_index++] = b ^ 0x20;
	}
      else
	{
	  if (output_index + 1 > out_maxlen)
	    break;
	  own_buf[output_index++] = b;
	}
    }

  *new_packet_len = output_index;
  return input_index;
}

static int
fileio_open_flags_to_host (int fileio_open_flags, int *open_flags_p)
{
  int open_flags = 0;

  if (fileio_open_flags & ~FILEIO_O_SUPPORTED)
    return -1;

  if (fileio_open_flags & FILEIO_O_CREAT)
    open_flags |= O_CREAT;
  if (fileio_open_flags & FILEIO_O_EXCL)
    open_flags |= O_EXCL;
  if (fileio_open_flags & FILEIO_O_TRUNC)
    open_flags |= O_TRUNC;
  if (fileio_open_flags & FILEIO_O_APPEND)
    open_flags |= O_APPEND;
  if (fileio_open_flags & FILEIO_O_RDONLY)
    open_flags |= O_RDONLY;
  if (fileio_open_flags & FILEIO_O_WRONLY)
    open_flags |= O_WRONLY;
  if (fileio_open_flags & FILEIO_O_RDWR)
    open_flags |= O_RDWR;
/* On systems supporting binary and text mode, always open files in
   binary mode. */
#ifdef O_BINARY
  open_flags |= O_BINARY;
#endif

  *open_flags_p = open_flags;
  return 0;
}

static void
handle_open (char *own_buf)
{
  char filename[HOSTIO_PATH_MAX];
  char *p;
  int fileio_flags, mode, flags, fd;
  struct fd_list *new_fd;

  p = own_buf + strlen ("vFile:open:");

  if (require_filename (&p, filename)
      || require_comma (&p)
      || require_int (&p, &fileio_flags)
      || require_comma (&p)
      || require_int (&p, &mode)
      || require_end (p)
      || fileio_open_flags_to_host (fileio_flags, &flags))
    {
      hostio_packet_error (own_buf);
      return;
    }

  /* We do not need to convert MODE, since the fileio protocol
     uses the standard values.  */
  fd = open (filename, flags, mode);

  if (fd == -1)
    {
      hostio_error (own_buf);
      return;
    }

  /* Record the new file descriptor.  */
  new_fd = xmalloc (sizeof (struct fd_list));
  new_fd->fd = fd;
  new_fd->next = open_fds;
  open_fds = new_fd;

  hostio_reply (own_buf, fd);
}

static void
handle_pread (char *own_buf, int *new_packet_len)
{
  int fd, ret, len, offset, bytes_sent;
  char *p, *data;

  p = own_buf + strlen ("vFile:pread:");

  if (require_int (&p, &fd)
      || require_comma (&p)
      || require_valid_fd (fd)
      || require_int (&p, &len)
      || require_comma (&p)
      || require_int (&p, &offset)
      || require_end (p))
    {
      hostio_packet_error (own_buf);
      return;
    }

  data = xmalloc (len);
#ifdef HAVE_PREAD
  ret = pread (fd, data, len, offset);
#else
  ret = -1;
#endif
  /* If we have no pread or it failed for this file, use lseek/read.  */
  if (ret == -1)
    {
      ret = lseek (fd, offset, SEEK_SET);
      if (ret != -1)
	ret = read (fd, data, len);
    }

  if (ret == -1)
    {
      hostio_error (own_buf);
      free (data);
      return;
    }

  bytes_sent = hostio_reply_with_data (own_buf, data, ret, new_packet_len);

  /* If we were using read, and the data did not all fit in the reply,
     we would have to back up using lseek here.  With pread it does
     not matter.  But we still have a problem; the return value in the
     packet might be wrong, so we must fix it.  This time it will
     definitely fit.  */
  if (bytes_sent < ret)
    bytes_sent = hostio_reply_with_data (own_buf, data, bytes_sent,
					 new_packet_len);

  free (data);
}

static void
handle_pwrite (char *own_buf, int packet_len)
{
  int fd, ret, len, offset;
  char *p, *data;

  p = own_buf + strlen ("vFile:pwrite:");

  if (require_int (&p, &fd)
      || require_comma (&p)
      || require_valid_fd (fd)
      || require_int (&p, &offset)
      || require_comma (&p)
      || require_data (p, packet_len - (p - own_buf), &data, &len))
    {
      hostio_packet_error (own_buf);
      return;
    }

#ifdef HAVE_PWRITE
  ret = pwrite (fd, data, len, offset);
#else
  ret = -1;
#endif
  /* If we have no pwrite or it failed for this file, use lseek/write.  */
  if (ret == -1)
    {
      ret = lseek (fd, offset, SEEK_SET);
      if (ret != -1)
	ret = write (fd, data, len);
    }

  if (ret == -1)
    {
      hostio_error (own_buf);
      free (data);
      return;
    }

  hostio_reply (own_buf, ret);
  free (data);
}

static void
handle_close (char *own_buf)
{
  int fd, ret;
  char *p;
  struct fd_list **open_fd_p, *old_fd;

  p = own_buf + strlen ("vFile:close:");

  if (require_int (&p, &fd)
      || require_valid_fd (fd)
      || require_end (p))
    {
      hostio_packet_error (own_buf);
      return;
    }

  ret = close (fd);

  if (ret == -1)
    {
      hostio_error (own_buf);
      return;
    }

  open_fd_p = &open_fds;
  /* We know that fd is in the list, thanks to require_valid_fd.  */
  while ((*open_fd_p)->fd != fd)
    open_fd_p = &(*open_fd_p)->next;

  old_fd = *open_fd_p;
  *open_fd_p = (*open_fd_p)->next;
  free (old_fd);

  hostio_reply (own_buf, ret);
}

static void
handle_unlink (char *own_buf)
{
  char filename[HOSTIO_PATH_MAX];
  char *p;
  int ret;

  p = own_buf + strlen ("vFile:unlink:");

  if (require_filename (&p, filename)
      || require_end (p))
    {
      hostio_packet_error (own_buf);
      return;
    }

  ret = unlink (filename);

  if (ret == -1)
    {
      hostio_error (own_buf);
      return;
    }

  hostio_reply (own_buf, ret);
}

static void
handle_readlink (char *own_buf, int *new_packet_len)
{
#if defined (HAVE_READLINK)
  char filename[HOSTIO_PATH_MAX], linkname[HOSTIO_PATH_MAX];
  char *p;
  int ret, bytes_sent;

  p = own_buf + strlen ("vFile:readlink:");

  if (require_filename (&p, filename)
      || require_end (p))
    {
      hostio_packet_error (own_buf);
      return;
    }

  ret = readlink (filename, linkname, sizeof (linkname) - 1);
  if (ret == -1)
    {
      hostio_error (own_buf);
      return;
    }

  bytes_sent = hostio_reply_with_data (own_buf, linkname, ret, new_packet_len);

  /* If the response does not fit into a single packet, do not attempt
     to return a partial response, but simply fail.  */
  if (bytes_sent < ret)
    sprintf (own_buf, "F-1,%x", FILEIO_ENAMETOOLONG);
#else /* ! HAVE_READLINK */
    sprintf (own_buf, "F-1,%x", FILEIO_ENOSYS);
#endif
}

/* Handle all the 'F' file transfer packets.  */

int
handle_vFile (char *own_buf, int packet_len, int *new_packet_len)
{
  if (strncmp (own_buf, "vFile:open:", 11) == 0)
    handle_open (own_buf);
  else if (strncmp (own_buf, "vFile:pread:", 11) == 0)
    handle_pread (own_buf, new_packet_len);
  else if (strncmp (own_buf, "vFile:pwrite:", 12) == 0)
    handle_pwrite (own_buf, packet_len);
  else if (strncmp (own_buf, "vFile:close:", 12) == 0)
    handle_close (own_buf);
  else if (strncmp (own_buf, "vFile:unlink:", 13) == 0)
    handle_unlink (own_buf);
  else if (strncmp (own_buf, "vFile:readlink:", 15) == 0)
    handle_readlink (own_buf, new_packet_len);
  else
    return 0;

  return 1;
}
@


1.22
log
@[GDBserver] hostio.c: Fallback to packet buffer size if PATH_MAX is not available.

PATH_MAX is not defined on systems which have no limit on filename
length, such as GNU/Hurd.  As designed, the hostio RSP packets carry
the paths as parameters in the request/reply packets, which themselves
have an upper size limit, so lifting the filename limit completely
would require a redesign with new hostio packets.  While that doesn't
happen, we can at least support filename lengths as long as the packet
buffer can fit.

gdb/gdbserver/
2013-07-01  Pedro Alves  <palves@@redhat.com>

	* hostio.c (HOSTIO_PATH_MAX): Define.
	(require_filename, handle_open, handle_unlink, handle_readlink):
	Use it.
@
text
@d23 1
@


1.21
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d53 8
d75 1
a75 1
      if (count >= PATH_MAX - 1)
d277 1
a277 1
  char filename[PATH_MAX];
d453 1
a453 1
  char filename[PATH_MAX];
d481 1
a481 1
  char filename[PATH_MAX], linkname[PATH_MAX];
@


1.20
log
@gdb/
2012-11-26  Maxime Villard  <rustyBSD@@gmx.fr>
	    Pedro Alves  <palves@@redhat.com>

	* common/linux-osdata.c (linux_xfer_osdata_fds): Decrease buffer
	size parameter passed to readlink by one byte.
	* fbsd-nat.c (fbsd_pid_to_exec_file): Ditto.
	* linux-nat.c (linux_child_pid_to_exec_file): Ditto.
	* nbsd-nat.c (nbsd_pid_to_exec_file): Ditto.
	* inf-child.c (inf_child_fileio_readlink): Decrease local buffer's
	size by one byte.

gdb/gdbserver/
2012-11-26  Maxime Villard  <rustyBSD@@gmx.fr>

	* hostio.c (handle_readlink): Decrease buffer size
	parameter passed to readlink by one byte.
@
text
@d2 1
a2 1
   Copyright (C) 2007-2012 Free Software Foundation, Inc.
@


1.19
log
@ChangeLog:

	* inf-child.c (inf_child_fileio_pwrite): If pwrite fails, fall back
	to attempting lseek/write.
	(inf_child_fileio_pread): Likewise for pread.

gdbserver/ChangeLog:

	* hostio.c (handle_pread): If pread fails, fall back to attempting
	lseek/read.
	(handle_pwrite): Likewise for pwrite.
@
text
@d486 1
a486 1
  ret = readlink (filename, linkname, sizeof linkname);
@


1.18
log
@[gdbserver] return ENOSYS if readlink not supported.

This reproduces on the GDBserver side what GDB does when readlink is
not supported.

gdb/gdbserver/ChangeLog:

        * configure.ac: Add readlink to AC_CHECK_FUNCS list.
        * configure, config.in: Regenerate.
        * hostio.c: Provide an alternate implementation if HAVE_READLINK
        is not defined.
@
text
@d331 1
a331 3
  ret = lseek (fd, offset, SEEK_SET);
  if (ret != -1)
    ret = read (fd, data, len);
d333 7
d384 1
a384 3
  ret = lseek (fd, offset, SEEK_SET);
  if (ret != -1)
    ret = write (fd, data, len);
d386 7
@


1.18.2.1
log
@ChangeLog:

	* inf-child.c (inf_child_fileio_pwrite): If pwrite fails, fall back
	to attempting lseek/write.
	(inf_child_fileio_pread): Likewise for pread.

gdbserver/ChangeLog:

	* hostio.c (handle_pread): If pread fails, fall back to attempting
	lseek/read.
	(handle_pwrite): Likewise for pwrite.
@
text
@d331 3
a333 1
  ret = -1;
a334 7
  /* If we have no pread or it failed for this file, use lseek/read.  */
  if (ret == -1)
    {
      ret = lseek (fd, offset, SEEK_SET);
      if (ret != -1)
	ret = read (fd, data, len);
    }
d379 3
a381 1
  ret = -1;
a382 7
  /* If we have no pwrite or it failed for this file, use lseek/write.  */
  if (ret == -1)
    {
      ret = lseek (fd, offset, SEEK_SET);
      if (ret != -1)
	ret = write (fd, data, len);
    }
@


1.17
log
@ChangeLog:

	* configure.ac [AC_CHECK_FUNCS]: Check for readlink.
	* config.in, configure: Regenerate.

	* target.h (struct target_ops): Add to_fileio_readlink.
	(target_fileio_readlink): Add prototype.
	* target.c (target_fileio_readlink): New function.

	* inf-child.c: Conditionally include <sys/param.h>.
	(inf_child_fileio_readlink): New function.
	(inf_child_target): Install it.

	* remote.c (PACKET_vFile_readlink): New enum value.
	(remote_hostio_readlink): New function.
	(init_remote_ops): Install it.
	(_initialize_remote): Handle vFile:readlink packet type.

doc/ChangeLog:

	* gdb.texinfo (Remote Configuration): Document
	"set remote hostio-readlink-packet" command.
	(General Query Packets): Document vFile:readlink packet.

gdbserver/ChangeLog:

	* hostio.c (handle_readlink): New function.
	(handle_vFile): Call it to handle "vFile:readlink" packets.
@
text
@d462 1
d489 3
@


1.16
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d459 31
d505 2
@


1.15
log
@2011-03-14  Michael Snyder  <msnyder@@vmware.com>

	* gdbserver/hostio.c (handle_close): Remove unnecessary null test.
@
text
@d2 1
a2 1
   Copyright (C) 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
@


1.15.4.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 1
a2 1
   Copyright (C) 2007-2012 Free Software Foundation, Inc.
@


1.14
log
@	* hostio.c (require_data): Free *data, not data.
@
text
@d421 2
a422 1
  while (*open_fd_p && (*open_fd_p)->fd != fd)
@


1.13
log
@gdb/gdbserver/
	* hostio.c (require_data): Use free, not xfree.
@
text
@d138 1
a138 1
      free (data);
@


1.12
log
@2011-02-27  Michael Snyder  <msnyder@@vmware.com>

	* hostio.c (require_data): Free malloc memory before returning
	error.
@
text
@d138 1
a138 1
      xfree (data);
@


1.11
log
@run copyright.sh for 2011.
@
text
@d137 4
a140 1
    return -1;
@


1.10
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d2 1
a2 1
   Copyright (C) 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
@


1.9
log
@	* Makefile.in, hostio-errno.c, errno.c, xtensa-xtregs.c: Change to
	GPLv3, update license URL.
@
text
@d2 1
a2 1
   Copyright (C) 2007, 2008, 2009 Free Software Foundation, Inc.
@


1.8
log
@        Updated copyright notices for most files.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d19 1
a19 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.7
log
@	* utils.c (xmalloc,xcalloc,xstrdup): New fns.
	* server.h (ATTR_MALLOC): New macro.
	(xmalloc,xcalloc,xstrdup): Declare.
	* hostio.c: Replace malloc,calloc,strdup with xmalloc,xcalloc,xstrdup.
	* inferiors.c: Ditto.
	* linux-low.c: Ditto.
	* mem-break.c: Ditto.
	* regcache.c: Ditto.
	* remote-utils.c: Ditto.
	* server.c: Ditto.
	* target.c: Ditto.
	* win32-low.c: Ditto.
@
text
@d2 1
a2 1
   Copyright (C) 2007, 2008 Free Software Foundation, Inc.
@


1.6
log
@	* hostio.c: Don't include errno.h.
	(errno_to_fileio_errno): Move to hostio-errno.
	* hostio.c: (hostio_error): Remove the error parameter.  Defer the
	error number outputting to the target->hostio_last_error callback.
	(hostio_packet_error): Use FILEIO_EINVAL directly.
	(handle_open, handle_pread, hostio_error, handle_unlink): Update
	calls to hostio_error.
	* hostio-errno.c: New.
	* server.h (hostio_last_error_from_errno): Declare.
	* target.h (target_ops): Add hostio_last_error member.
	* linux-low.c (linux_target_op): Register hostio_last_error_from_errno
	as hostio_last_error handler.
	* spu-low.c (spu_target_ops): Likewise.
	* win32-low.c [_WIN32_WCE] (win32_error_to_fileio_error)
	(wince_hostio_last_error): New functions.
	(win32_target_ops) [_WIN32_WCE]: Register wince_hostio_last_error
	as hostio_last_error handler.
	(win32_target_ops) [!_WIN32_WCE]: Register
	hostio_last_error_from_errno as hostio_last_error handler.
	* Makefile.in (SFILES): Add hostio.c and hostio-errno.c.
	(hostio-errno.o): New rule.
	* configure.ac (GDBSERVER_DEPFILES): Add $srv_hostio_err_objs.
	* configure.srv (srv_hostio_err_objs): New variable.  Default to
	hostio-errno.o.
	(arm*-*-mingw32ce*): Set srv_hostio_err_objs to "".
	* configure: Regenerate.
@
text
@d119 1
a119 1
  *data = malloc (p_len);
d298 1
a298 1
  new_fd = malloc (sizeof (struct fd_list));
d326 1
a326 1
  data = malloc (len);
@


1.5
log
@	Updated copyright notices for most files.
@
text
@a25 1
#include <errno.h>
d178 2
a179 51
static int
errno_to_fileio_errno (int error)
{
  switch (error)
    {
    case EPERM:
      return FILEIO_EPERM;
    case ENOENT:
      return FILEIO_ENOENT;
    case EINTR:
      return FILEIO_EINTR;
    case EIO:
      return FILEIO_EIO;
    case EBADF:
      return FILEIO_EBADF;
    case EACCES:
      return FILEIO_EACCES;
    case EFAULT:
      return FILEIO_EFAULT;
    case EBUSY:
      return FILEIO_EBUSY;
    case EEXIST:
      return FILEIO_EEXIST;
    case ENODEV:
      return FILEIO_ENODEV;
    case ENOTDIR:
      return FILEIO_ENOTDIR;
    case EISDIR:
      return FILEIO_EISDIR;
    case EINVAL:
      return FILEIO_EINVAL;
    case ENFILE:
      return FILEIO_ENFILE;
    case EMFILE:
      return FILEIO_EMFILE;
    case EFBIG:
      return FILEIO_EFBIG;
    case ENOSPC:
      return FILEIO_ENOSPC;
    case ESPIPE:
      return FILEIO_ESPIPE;
    case EROFS:
      return FILEIO_EROFS;
    case ENOSYS:
      return FILEIO_ENOSYS;
    case ENAMETOOLONG:
      return FILEIO_ENAMETOOLONG;
    }
  return FILEIO_EUNKNOWN;
}

d181 1
a181 1
hostio_error (char *own_buf, int error)
d183 1
a183 3
  int fileio_error = errno_to_fileio_errno (error);

  sprintf (own_buf, "F-1,%x", fileio_error);
d189 1
a189 1
  hostio_error (own_buf, EINVAL);
d293 1
a293 1
      hostio_error (own_buf, errno);
d337 1
a337 1
      hostio_error (own_buf, errno);
d385 1
a385 1
      hostio_error (own_buf, errno);
d415 1
a415 1
      hostio_error (own_buf, errno);
d450 1
a450 1
      hostio_error (own_buf, errno);
@


1.4
log
@	* configure.ac: Check for pread and pwrite.
	* hostio.c (handle_pread): Fall back to lseek and read.
	(handle_pwrite): Fall back to lseek and write.
	* config.in, configure: Regenerated.
@
text
@d2 1
a2 2
   Copyright (C) 2007
   Free Software Foundation, Inc.
@


1.3
log
@	* hostio.c: Correct copyright year.
@
text
@d380 1
d382 5
d428 1
d430 5
@


1.2
log
@	* remote.c (remote_cmdlist): New variable.
	(PACKET_vFile_open, PACKET_vFile_pread, PACKET_vFile_pwrite)
	(PACKET_vFile_close, PACKET_vFile_unlink): New constants.
	(remote_buffer_add_string, remote_buffer_add_bytes)
	(remote_buffer_add_int, remote_hostio_parse_result)
	(remote_hostio_send_command, remote_hostio_open, remote_hostio_pwrite)
	(remote_hostio_pread, remote_hostio_close, remote_hostio_unlink)
	(remote_fileio_errno_to_host, remote_hostio_error, fclose_cleanup)
	(remote_hostio_close_cleanup, remote_file_put, remote_file_get)
	(remote_file_delete, remote_put_command, remote_get_command)
	(remote_delete_command, remote_command): New functions.
	(_initialize_remote): Register new packets and commands.
	* Makefile.in (gdb_fileio_h): New variable.
	(remote.o): Update.
	(SUBDIR_MI_OBS): Add mi-cmd-target.o.
	(SUBDIR_MI_SRCS): Add mi/mi-cmd-target.c.
	(mi-cmd-target.o): New rule.
	* mi/mi-cmd-target.c: New file.
	* mi/mi-cmds.c (mi_cmds): Add target-file-delete, target-file-get,
	and target-file-put.
	* mi/mi-cmds.h (mi_cmd_target_file_get, mi_cmd_target_file_put)
	(mi_cmd_target_file_delete): Declare.
	* remote.h (remote_file_put, remote_file_get, remote_file_delete):
	Declare.
	* NEWS: Describe new file transfer support.

	* gdb.texinfo (Debugging Programs with Multiple Processes): Correct
	formatting.
	(Remote Debugging): Add File Transfer section.
	(Remote Configuration): Document Host I/O packets.
	(GDB/MI): Add GDB/MI File Transfer Commands section.
	(Remote Protocol): Add Host I/O Packets section.
	(Packets): Add vFile.

	* Makefile.in (OBS): Add hostio.o.
	(hostio.o): New rule.
	* server.h (handle_vFile): Declare.
	* hostio.c: New file.
	* server.c (handle_v_requests): Take packet_len and new_packet_len
	for binary packets.  Call handle_vFile.
	(main): Update call to handle_v_requests.

	* gdb.server/file-transfer.exp, gdb.server/transfer.txt,
	gdb.mi/mi-file-transfer.exp: New.
@
text
@d2 1
a2 1
   Copyright (C) 2006
@


1.1
log
@file hostio.c was initially added on branch gdb-csl-symbian-20060226-branch.
@
text
@d1 517
@


1.1.2.1
log
@	* gdb/remote.c: Include "gdb/fileio.h".
	(PACKET_Fopen, PACKET_Fread, PACKET_Fwrite, PACKET_Fclose): New
	enums.
	(remote_escape_output, remote_unescape_input): New functions.
	(remote_write_bytes): Use remote_escape_output.
	(readchar): Do not mask off the high bit.
	(read_frame): Print binary packets correctly.
	(getpkt_sane): Likewise.  Return the number of bytes read
	or -1.
	(remote_buffer_add_string, remote_buffer_add_bytes)
	(remote_buffer_add_int, remote_hostio_parse_result)
	(remote_hostio_send_command, remote_hostio_open)
	(remote_hostio_write, remote_hostio_read)
	(remote_hostio_close, remote_fileio_errno_to_host)
	(remote_hostio_error, fclose_cleanup, remote_download_command)
	(remote_upload_command): New functions.
	(_initialize_remote): Register new packets and remote-upload
	and remote-download commands.

	* gdb/doc/gdb.texinfo (File Transfer): New section.
	(Remote Configuration): Document Host I/O packet commands.
	(Host I/O Packets): New section.
	(Packets): Mention overloading of F prefix.

	* gdb/gdbserver/Makefile.in (OBS): Add hostio.o.
	(hostio.o): New rule.
	* gdb/gdbserver/hostio.c: New file.
	* gdb/gdbserver/remote-utils.c (putpkt_binary): New function,
	broken out from putpkt.
	(putpkt): Use it.
	(readchar): Do not mask the high bits.  Correct the buffer
	type.
	* gdb/gdbserver/server.c (main): Leave space for a trailing
	zero in the packet buffer.  Save the length of the
	received packet.  Handle Host I/O requests.  Optionally call
	putpkt_binary.
	* gdb/gdbserver/server.h (handle_f_hostio, putpkt_binary): New
	prototypes.
@
text
@a0 480
/* Host file transfer support for gdbserver.
   Copyright (C) 2006
   Free Software Foundation, Inc.

   Contributed by CodeSourcery.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */

#include "server.h"
#include "gdb/fileio.h"

#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <unistd.h>

extern int remote_debug;

struct fd_list
{
  int fd;
  struct fd_list *next;
};

static struct fd_list *open_fds;

static int
safe_fromhex (char a, int *nibble)
{
  if (a >= '0' && a <= '9')
    *nibble = a - '0';
  else if (a >= 'a' && a <= 'f')
    *nibble = a - 'a' + 10;
  else if (a >= 'A' && a <= 'F')
    *nibble = a - 'A' + 10;
  else
    return -1;

  return 0;
}

static int
require_filename (char **pp, char *filename)
{
  int count;
  char *p;

  p = *pp;
  count = 0;

  while (*p && *p != ',')
    {
      int nib1, nib2;

      /* Don't allow overflow.  */
      if (count >= PATH_MAX - 1)
	return -1;

      if (safe_fromhex (p[0], &nib1)
	  || safe_fromhex (p[1], &nib2))
	return -1;

      filename[count++] = nib1 * 16 + nib2;
      p += 2;
    }

  filename[count] = '\0';
  *pp = p;
  return 0;
}

static int
require_int (char **pp, int *value)
{
  char *p;
  int count;

  p = *pp;
  *value = 0;
  count = 0;

  while (*p && *p != ',')
    {
      int nib;

      /* Don't allow overflow.  */
      if (count >= 7)
	return -1;

      if (safe_fromhex (p[0], &nib))
	return -1;
      *value = *value * 16 + nib;
      p++;
      count++;
    }

  *pp = p;
  return 0;
}

static int
require_data (char *p, int p_len, char **data, int *data_len)
{
  int input_index, output_index, escaped;

  *data = malloc (p_len);

  output_index = 0;
  escaped = 0;
  for (input_index = 0; input_index < p_len; input_index++)
    {
      char b = p[input_index];

      if (escaped)
	{
	  (*data)[output_index++] = b ^ 0x20;
	  escaped = 0;
	}
      else if (b == '}')
	escaped = 1;
      else
	(*data)[output_index++] = b;
    }

  if (escaped)
    return -1;

  *data_len = output_index;
  return 0;
}

static int
require_comma (char **pp)
{
  if (**pp == ',')
    {
      (*pp)++;
      return 0;
    }
  else
    return -1;
}

static int
require_end (char *p)
{
  if (*p == '\0')
    return 0;
  else
    return -1;
}

static int
require_valid_fd (int fd)
{
  struct fd_list *fd_ptr;

  for (fd_ptr = open_fds; fd_ptr != NULL; fd_ptr = fd_ptr->next)
    if (fd_ptr->fd == fd)
      return 0;

  return -1;
}

static int
errno_to_fileio_errno (int error)
{
  switch (error)
    {
    case EPERM:
      return FILEIO_EPERM;
    case ENOENT:
      return FILEIO_ENOENT;
    case EINTR:
      return FILEIO_EINTR;
    case EIO:
      return FILEIO_EIO;
    case EBADF:
      return FILEIO_EBADF;
    case EACCES:
      return FILEIO_EACCES;
    case EFAULT:
      return FILEIO_EFAULT;
    case EBUSY:
      return FILEIO_EBUSY;
    case EEXIST:
      return FILEIO_EEXIST;
    case ENODEV:
      return FILEIO_ENODEV;
    case ENOTDIR:
      return FILEIO_ENOTDIR;
    case EISDIR:
      return FILEIO_EISDIR;
    case EINVAL:
      return FILEIO_EINVAL;
    case ENFILE:
      return FILEIO_ENFILE;
    case EMFILE:
      return FILEIO_EMFILE;
    case EFBIG:
      return FILEIO_EFBIG;
    case ENOSPC:
      return FILEIO_ENOSPC;
    case ESPIPE:
      return FILEIO_ESPIPE;
    case EROFS:
      return FILEIO_EROFS;
    case ENOSYS:
      return FILEIO_ENOSYS;
    case ENAMETOOLONG:
      return FILEIO_ENAMETOOLONG;
    }
  return FILEIO_EUNKNOWN;
}

static void
hostio_error (char *own_buf, int error)
{
  int fileio_error = errno_to_fileio_errno (error);

  sprintf (own_buf, "F-1,%x", fileio_error);
}

static void
hostio_packet_error (char *own_buf)
{
  hostio_error (own_buf, EINVAL);
}

static void
hostio_reply (char *own_buf, int result)
{
  sprintf (own_buf, "F%x", result);
}

static int
hostio_reply_with_data (char *own_buf, char *buffer, int len,
			int *new_packet_len)
{
  int input_index, output_index, out_maxlen;

  sprintf (own_buf, "F%x;", len);
  output_index = strlen (own_buf);

  out_maxlen = PBUFSIZ;

  for (input_index = 0; input_index < len; input_index++)
    {
      char b = buffer[input_index];

      if (b == '$' || b == '#' || b == '}' || b == '*')
	{
	  /* These must be escaped.  */
	  if (output_index + 2 > out_maxlen)
	    break;
	  own_buf[output_index++] = '}';
	  own_buf[output_index++] = b ^ 0x20;
	}
      else
	{
	  if (output_index + 1 > out_maxlen)
	    break;
	  own_buf[output_index++] = b;
	}
    }

  *new_packet_len = output_index;
  return input_index;
}

static int
fileio_open_flags_to_host (int fileio_open_flags, int *open_flags_p)
{
  int open_flags = 0;

  if (fileio_open_flags & ~FILEIO_O_SUPPORTED)
    return -1;

  if (fileio_open_flags & FILEIO_O_CREAT)
    open_flags |= O_CREAT;
  if (fileio_open_flags & FILEIO_O_EXCL)
    open_flags |= O_EXCL;
  if (fileio_open_flags & FILEIO_O_TRUNC)
    open_flags |= O_TRUNC;
  if (fileio_open_flags & FILEIO_O_APPEND)
    open_flags |= O_APPEND;
  if (fileio_open_flags & FILEIO_O_RDONLY)
    open_flags |= O_RDONLY;
  if (fileio_open_flags & FILEIO_O_WRONLY)
    open_flags |= O_WRONLY;
  if (fileio_open_flags & FILEIO_O_RDWR)
    open_flags |= O_RDWR;
/* On systems supporting binary and text mode, always open files in
   binary mode. */
#ifdef O_BINARY
  open_flags |= O_BINARY;
#endif

  *open_flags_p = open_flags;
  return 0;
}

static void
handle_fopen (char *own_buf)
{
  char filename[PATH_MAX];
  char *p;
  int fileio_flags, mode, flags, fd;
  struct fd_list *new_fd;

  p = own_buf + strlen ("Fopen,");

  if (require_filename (&p, filename)
      || require_comma (&p)
      || require_int (&p, &fileio_flags)
      || require_comma (&p)
      || require_int (&p, &mode)
      || require_end (p)
      || fileio_open_flags_to_host (fileio_flags, &flags))
    {
      hostio_packet_error (own_buf);
      return;
    }

  /* We do not need to convert MODE, since the fileio protocol
     uses the standard values.  */
  fd = open (filename, flags, mode);

  if (fd == -1)
    {
      hostio_error (own_buf, errno);
      return;
    }

  /* Record the new file descriptor.  */
  new_fd = malloc (sizeof (struct fd_list));
  new_fd->fd = fd;
  new_fd->next = open_fds;
  open_fds = new_fd;

  hostio_reply (own_buf, fd);
}

static void
handle_fread (char *own_buf, int *new_packet_len)
{
  int fd, ret, len, bytes_sent;
  char *p, *data;

  p = own_buf + strlen ("Fread,");

  if (require_int (&p, &fd)
      || require_comma (&p)
      || require_valid_fd (fd)
      || require_int (&p, &len)
      || require_end (p))
    {
      hostio_packet_error (own_buf);
      return;
    }

  data = malloc (len);
  ret = read (fd, data, len);

  if (ret == -1)
    {
      hostio_error (own_buf, errno);
      free (data);
      return;
    }

  bytes_sent = hostio_reply_with_data (own_buf, data, ret, new_packet_len);

  /* If all the data could not fit in the reply, back up the file
     pointer for the next read.  */
  if (bytes_sent < ret)
    lseek (fd, bytes_sent - ret, SEEK_CUR);

  free (data);
}

static void
handle_fwrite (char *own_buf, int packet_len)
{
  int fd, ret, len;
  char *p, *data;

  p = own_buf + strlen ("Fwrite,");

  if (require_int (&p, &fd)
      || require_comma (&p)
      || require_valid_fd (fd)
      || require_data (p, packet_len - (p - own_buf), &data, &len))
    {
      hostio_packet_error (own_buf);
      return;
    }

  ret = write (fd, data, len);

  if (ret == -1)
    {
      hostio_error (own_buf, errno);
      free (data);
      return;
    }

  hostio_reply (own_buf, ret);
  free (data);
}

static void
handle_fclose (char *own_buf)
{
  int fd, ret;
  char *p;
  struct fd_list **open_fd_p, *old_fd;

  p = own_buf + strlen ("Fclose,");

  if (require_int (&p, &fd)
      || require_valid_fd (fd)
      || require_end (p))
    {
      hostio_packet_error (own_buf);
      return;
    }

  ret = close (fd);

  if (ret == -1)
    {
      hostio_error (own_buf, errno);
      return;
    }

  open_fd_p = &open_fds;
  while (*open_fd_p && (*open_fd_p)->fd != fd)
    open_fd_p = &(*open_fd_p)->next;

  old_fd = *open_fd_p;
  *open_fd_p = (*open_fd_p)->next;
  free (old_fd);

  hostio_reply (own_buf, ret);
}

/* Handle all the 'F' file transfer packets.  */

int
handle_f_hostio (char *own_buf, int packet_len, int *new_packet_len)
{
  if (strncmp (own_buf, "Fopen,", 6) == 0)
    handle_fopen (own_buf);
  else if (strncmp (own_buf, "Fread,", 6) == 0)
    handle_fread (own_buf, new_packet_len);
  else if (strncmp (own_buf, "Fwrite,", 7) == 0)
    handle_fwrite (own_buf, packet_len);
  else if (strncmp (own_buf, "Fclose,", 7) == 0)
    handle_fclose (own_buf);
  else
    return 0;

  return 1;
}
@

