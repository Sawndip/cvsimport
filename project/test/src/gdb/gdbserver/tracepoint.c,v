head	1.84;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.74.2.1
	gdb_7_6-2013-04-26-release:1.74
	gdb_7_6-branch:1.74.0.2
	gdb_7_6-2013-03-12-branchpoint:1.74
	gdb_7_5_1-2012-11-29-release:1.62
	gdb_7_5-2012-08-17-release:1.62
	gdb_7_5-branch:1.62.0.2
	gdb_7_5-2012-07-18-branchpoint:1.62
	gdb_7_4_1-2012-04-26-release:1.36.2.1
	gdb_7_4-2012-01-24-release:1.36.2.1
	gdb_7_4-branch:1.36.0.2
	gdb_7_4-2011-12-13-branchpoint:1.36
	gdb_7_3_1-2011-09-04-release:1.24
	gdb_7_3-2011-07-26-release:1.24
	gdb_7_3-branch:1.24.0.2
	gdb_7_3-2011-04-01-branchpoint:1.24
	gdb_7_2-2010-09-02-release:1.9
	gdb_7_2-branch:1.9.0.2
	gdb_7_2-2010-07-07-branchpoint:1.9;
locks; strict;
comment	@ * @;


1.84
date	2013.10.16.02.55.27;	author sergiodj;	state Exp;
branches;
next	1.83;

1.83
date	2013.09.05.20.40.33;	author palves;	state Exp;
branches;
next	1.82;

1.82
date	2013.09.02.15.15.57;	author palves;	state Exp;
branches;
next	1.81;

1.81
date	2013.06.26.15.24.10;	author ddk;	state Exp;
branches;
next	1.80;

1.80
date	2013.06.26.15.14.39;	author ddk;	state Exp;
branches;
next	1.79;

1.79
date	2013.06.26.08.01.57;	author qiyao;	state Exp;
branches;
next	1.78;

1.78
date	2013.06.07.10.46.59;	author palves;	state Exp;
branches;
next	1.77;

1.77
date	2013.05.03.15.43.57;	author abidh;	state Exp;
branches;
next	1.76;

1.76
date	2013.03.14.11.40.08;	author sergiodj;	state Exp;
branches;
next	1.75;

1.75
date	2013.03.13.03.40.26;	author qiyao;	state Exp;
branches;
next	1.74;

1.74
date	2013.03.08.15.06.37;	author abidh;	state Exp;
branches
	1.74.2.1;
next	1.73;

1.73
date	2013.03.07.13.17.28;	author qiyao;	state Exp;
branches;
next	1.72;

1.72
date	2013.02.28.01.21.08;	author qiyao;	state Exp;
branches;
next	1.71;

1.71
date	2013.02.26.14.11.58;	author qiyao;	state Exp;
branches;
next	1.70;

1.70
date	2013.02.14.18.07.19;	author palves;	state Exp;
branches;
next	1.69;

1.69
date	2013.02.14.17.11.41;	author palves;	state Exp;
branches;
next	1.68;

1.68
date	2013.01.18.06.40.57;	author qiyao;	state Exp;
branches;
next	1.67;

1.67
date	2013.01.01.06.33.00;	author brobecke;	state Exp;
branches;
next	1.66;

1.66
date	2012.11.09.02.58.50;	author qiyao;	state Exp;
branches;
next	1.65;

1.65
date	2012.09.04.01.47.49;	author qiyao;	state Exp;
branches;
next	1.64;

1.64
date	2012.08.28.16.53.30;	author qiyao;	state Exp;
branches;
next	1.63;

1.63
date	2012.07.27.08.09.13;	author qiyao;	state Exp;
branches;
next	1.62;

1.62
date	2012.04.29.06.28.30;	author qiyao;	state Exp;
branches;
next	1.61;

1.61
date	2012.04.16.15.38.53;	author qiyao;	state Exp;
branches;
next	1.60;

1.60
date	2012.04.16.11.24.47;	author qiyao;	state Exp;
branches;
next	1.59;

1.59
date	2012.04.16.11.16.30;	author qiyao;	state Exp;
branches;
next	1.58;

1.58
date	2012.04.14.05.36.24;	author qiyao;	state Exp;
branches;
next	1.57;

1.57
date	2012.04.14.04.10.04;	author qiyao;	state Exp;
branches;
next	1.56;

1.56
date	2012.03.15.12.57.13;	author qiyao;	state Exp;
branches;
next	1.55;

1.55
date	2012.03.15.10.42.38;	author qiyao;	state Exp;
branches;
next	1.54;

1.54
date	2012.03.09.03.47.15;	author qiyao;	state Exp;
branches;
next	1.53;

1.53
date	2012.03.03.09.51.28;	author qiyao;	state Exp;
branches;
next	1.52;

1.52
date	2012.03.03.04.34.52;	author qiyao;	state Exp;
branches;
next	1.51;

1.51
date	2012.03.03.04.04.35;	author qiyao;	state Exp;
branches;
next	1.50;

1.50
date	2012.03.03.03.08.36;	author qiyao;	state Exp;
branches;
next	1.49;

1.49
date	2012.03.02.00.18.51;	author qiyao;	state Exp;
branches;
next	1.48;

1.48
date	2012.03.02.00.12.47;	author qiyao;	state Exp;
branches;
next	1.47;

1.47
date	2012.02.24.15.13.37;	author luisgpm;	state Exp;
branches;
next	1.46;

1.46
date	2012.02.24.14.46.48;	author palves;	state Exp;
branches;
next	1.45;

1.45
date	2012.02.02.18.04.29;	author palves;	state Exp;
branches;
next	1.44;

1.44
date	2012.01.17.17.22.10;	author palves;	state Exp;
branches;
next	1.43;

1.43
date	2012.01.06.05.58.28;	author qiyao;	state Exp;
branches;
next	1.42;

1.42
date	2012.01.04.14.39.12;	author qiyao;	state Exp;
branches;
next	1.41;

1.41
date	2012.01.04.14.34.49;	author qiyao;	state Exp;
branches;
next	1.40;

1.40
date	2012.01.04.08.17.24;	author brobecke;	state Exp;
branches;
next	1.39;

1.39
date	2012.01.03.02.26.52;	author qiyao;	state Exp;
branches;
next	1.38;

1.38
date	2011.12.15.12.40.03;	author qiyao;	state Exp;
branches;
next	1.37;

1.37
date	2011.12.14.07.47.14;	author qiyao;	state Exp;
branches;
next	1.36;

1.36
date	2011.12.13.01.26.56;	author qiyao;	state Exp;
branches
	1.36.2.1;
next	1.35;

1.35
date	2011.11.25.04.41.15;	author shebs;	state Exp;
branches;
next	1.34;

1.34
date	2011.11.20.23.59.48;	author shebs;	state Exp;
branches;
next	1.33;

1.33
date	2011.11.14.20.07.24;	author shebs;	state Exp;
branches;
next	1.32;

1.32
date	2011.11.14.15.18.51;	author qiyao;	state Exp;
branches;
next	1.31;

1.31
date	2011.11.14.14.38.41;	author qiyao;	state Exp;
branches;
next	1.30;

1.30
date	2011.11.05.13.16.22;	author qiyao;	state Exp;
branches;
next	1.29;

1.29
date	2011.11.02.23.44.21;	author shebs;	state Exp;
branches;
next	1.28;

1.28
date	2011.11.02.04.34.22;	author qiyao;	state Exp;
branches;
next	1.27;

1.27
date	2011.09.15.22.54.13;	author shebs;	state Exp;
branches;
next	1.26;

1.26
date	2011.07.20.11.01.21;	author palves;	state Exp;
branches;
next	1.25;

1.25
date	2011.05.12.12.09.17;	author kcy;	state Exp;
branches;
next	1.24;

1.24
date	2011.03.10.20.21.14;	author msnyder;	state Exp;
branches;
next	1.23;

1.23
date	2011.03.10.20.18.42;	author msnyder;	state Exp;
branches;
next	1.22;

1.22
date	2011.03.09.15.59.12;	author msnyder;	state Exp;
branches;
next	1.21;

1.21
date	2011.02.24.07.38.42;	author brobecke;	state Exp;
branches;
next	1.20;

1.20
date	2011.02.21.08.39.14;	author teawater;	state Exp;
branches;
next	1.19;

1.19
date	2011.02.18.21.12.07;	author tromey;	state Exp;
branches;
next	1.18;

1.18
date	2011.02.18.20.55.45;	author tromey;	state Exp;
branches;
next	1.17;

1.17
date	2011.02.14.11.13.12;	author palves;	state Exp;
branches;
next	1.16;

1.16
date	2011.02.07.12.14.11;	author palves;	state Exp;
branches;
next	1.15;

1.15
date	2011.01.28.13.36.32;	author palves;	state Exp;
branches;
next	1.14;

1.14
date	2011.01.06.00.14.09;	author msnyder;	state Exp;
branches;
next	1.13;

1.13
date	2011.01.01.15.33.24;	author brobecke;	state Exp;
branches;
next	1.12;

1.12
date	2010.09.06.15.15.50;	author qiyao;	state Exp;
branches;
next	1.11;

1.11
date	2010.09.01.17.29.32;	author gdbadmin;	state Exp;
branches;
next	1.10;

1.10
date	2010.09.01.01.53.43;	author gdbadmin;	state Exp;
branches;
next	1.9;

1.9
date	2010.07.01.10.36.11;	author palves;	state Exp;
branches;
next	1.8;

1.8
date	2010.06.20.22.18.48;	author palves;	state Exp;
branches;
next	1.7;

1.7
date	2010.06.15.10.44.48;	author palves;	state Exp;
branches;
next	1.6;

1.6
date	2010.06.14.22.16.09;	author palves;	state Exp;
branches;
next	1.5;

1.5
date	2010.06.01.13.20.52;	author palves;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.03.04.02.20;	author palves;	state Exp;
branches;
next	1.3;

1.3
date	2010.04.11.16.33.56;	author palves;	state Exp;
branches;
next	1.2;

1.2
date	2010.04.09.14.40.48;	author palves;	state Exp;
branches;
next	1.1;

1.1
date	2010.04.09.03.40.00;	author palves;	state Exp;
branches;
next	;

1.74.2.1
date	2013.05.03.16.26.32;	author abidh;	state Exp;
branches;
next	;

1.36.2.1
date	2012.01.06.04.43.40;	author brobecke;	state Exp;
branches;
next	;


desc
@@


1.84
log
@There were two functions who were calling "sizeof" twice.

The first one, dw2_get_real_path from gdb/dwarf2read.c, was actually
making use of OBSTACK_CALLOC which already calls "sizeof" for its third
argument.

The second, download_tracepoint_1 from gdb/gdbserver/tracepoint.c, was
explicitly calling "sizeof" inside another "sizeof".

This patch fixed both functions.

gdb/ChangeLog
2013-10-16  Sergio Durigan Junior  <sergiodj@@redhat.com>

	PR gdb/16014
	* dwarf2read.c (dw2_get_real_path): Remove unnecessary call to
	sizeof.

gdb/gdbserver/ChangeLog
2013-10-16  Sergio Durigan Junior  <sergiodj@@redhat.com>

	PR gdb/16014
	* tracepoint.c (download_tracepoint_1): Remove unnecessary double
	call to sizeof.
@
text
@/* Tracepoint code for remote server for GDB.
   Copyright (C) 2009-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "server.h"
#include "tracepoint.h"
#include "gdbthread.h"
#include "agent.h"

#include <ctype.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/time.h>
#include <stddef.h>
#include <inttypes.h>
#include <stdint.h>

#include "ax.h"
#include "tdesc.h"

#define DEFAULT_TRACE_BUFFER_SIZE 5242880 /* 5*1024*1024 */

/* This file is built for both GDBserver, and the in-process
   agent (IPA), a shared library that includes a tracing agent that is
   loaded by the inferior to support fast tracepoints.  Fast
   tracepoints (or more accurately, jump based tracepoints) are
   implemented by patching the tracepoint location with a jump into a
   small trampoline function whose job is to save the register state,
   call the in-process tracing agent, and then execute the original
   instruction that was under the tracepoint jump (possibly adjusted,
   if PC-relative, or some such).

   The current synchronization design is pull based.  That means,
   GDBserver does most of the work, by peeking/poking at the inferior
   agent's memory directly for downloading tracepoint and associated
   objects, and for uploading trace frames.  Whenever the IPA needs
   something from GDBserver (trace buffer is full, tracing stopped for
   some reason, etc.) the IPA calls a corresponding hook function
   where GDBserver has placed a breakpoint.

   Each of the agents has its own trace buffer.  When browsing the
   trace frames built from slow and fast tracepoints from GDB (tfind
   mode), there's no guarantee the user is seeing the trace frames in
   strict chronological creation order, although, GDBserver tries to
   keep the order relatively reasonable, by syncing the trace buffers
   at appropriate times.

*/

static void trace_vdebug (const char *, ...) ATTRIBUTE_PRINTF (1, 2);

static void
trace_vdebug (const char *fmt, ...)
{
  char buf[1024];
  va_list ap;

  va_start (ap, fmt);
  vsprintf (buf, fmt, ap);
  fprintf (stderr, PROG "/tracepoint: %s\n", buf);
  va_end (ap);
}

#define trace_debug_1(level, fmt, args...)	\
  do {						\
    if (level <= debug_threads)		\
      trace_vdebug ((fmt), ##args);		\
  } while (0)

#define trace_debug(FMT, args...)		\
  trace_debug_1 (1, FMT, ##args)

#if defined(__GNUC__)
#  define ATTR_USED __attribute__((used))
#  define ATTR_NOINLINE __attribute__((noinline))
#  define ATTR_CONSTRUCTOR __attribute__ ((constructor))
#else
#  define ATTR_USED
#  define ATTR_NOINLINE
#  define ATTR_CONSTRUCTOR
#endif

/* Make sure the functions the IPA needs to export (symbols GDBserver
   needs to query GDB about) are exported.  */

#ifdef IN_PROCESS_AGENT
# if defined _WIN32 || defined __CYGWIN__
#   define IP_AGENT_EXPORT __declspec(dllexport) ATTR_USED
# else
#   if __GNUC__ >= 4
#     define IP_AGENT_EXPORT \
  __attribute__ ((visibility("default"))) ATTR_USED
#   else
#     define IP_AGENT_EXPORT ATTR_USED
#   endif
# endif
#else
#  define IP_AGENT_EXPORT
#endif

/* Prefix exported symbols, for good citizenship.  All the symbols
   that need exporting are defined in this module.  */
#ifdef IN_PROCESS_AGENT
# define gdb_tp_heap_buffer gdb_agent_gdb_tp_heap_buffer
# define gdb_jump_pad_buffer gdb_agent_gdb_jump_pad_buffer
# define gdb_jump_pad_buffer_end gdb_agent_gdb_jump_pad_buffer_end
# define gdb_trampoline_buffer gdb_agent_gdb_trampoline_buffer
# define gdb_trampoline_buffer_end gdb_agent_gdb_trampoline_buffer_end
# define gdb_trampoline_buffer_error gdb_agent_gdb_trampoline_buffer_error
# define collecting gdb_agent_collecting
# define gdb_collect gdb_agent_gdb_collect
# define stop_tracing gdb_agent_stop_tracing
# define flush_trace_buffer gdb_agent_flush_trace_buffer
# define about_to_request_buffer_space gdb_agent_about_to_request_buffer_space
# define trace_buffer_is_full gdb_agent_trace_buffer_is_full
# define stopping_tracepoint gdb_agent_stopping_tracepoint
# define expr_eval_result gdb_agent_expr_eval_result
# define error_tracepoint gdb_agent_error_tracepoint
# define tracepoints gdb_agent_tracepoints
# define tracing gdb_agent_tracing
# define trace_buffer_ctrl gdb_agent_trace_buffer_ctrl
# define trace_buffer_ctrl_curr gdb_agent_trace_buffer_ctrl_curr
# define trace_buffer_lo gdb_agent_trace_buffer_lo
# define trace_buffer_hi gdb_agent_trace_buffer_hi
# define traceframe_read_count gdb_agent_traceframe_read_count
# define traceframe_write_count gdb_agent_traceframe_write_count
# define traceframes_created gdb_agent_traceframes_created
# define trace_state_variables gdb_agent_trace_state_variables
# define get_raw_reg gdb_agent_get_raw_reg
# define get_trace_state_variable_value \
  gdb_agent_get_trace_state_variable_value
# define set_trace_state_variable_value \
  gdb_agent_set_trace_state_variable_value
# define ust_loaded gdb_agent_ust_loaded
# define helper_thread_id gdb_agent_helper_thread_id
# define cmd_buf gdb_agent_cmd_buf
#endif

#ifndef IN_PROCESS_AGENT

/* Addresses of in-process agent's symbols GDBserver cares about.  */

struct ipa_sym_addresses
{
  CORE_ADDR addr_gdb_tp_heap_buffer;
  CORE_ADDR addr_gdb_jump_pad_buffer;
  CORE_ADDR addr_gdb_jump_pad_buffer_end;
  CORE_ADDR addr_gdb_trampoline_buffer;
  CORE_ADDR addr_gdb_trampoline_buffer_end;
  CORE_ADDR addr_gdb_trampoline_buffer_error;
  CORE_ADDR addr_collecting;
  CORE_ADDR addr_gdb_collect;
  CORE_ADDR addr_stop_tracing;
  CORE_ADDR addr_flush_trace_buffer;
  CORE_ADDR addr_about_to_request_buffer_space;
  CORE_ADDR addr_trace_buffer_is_full;
  CORE_ADDR addr_stopping_tracepoint;
  CORE_ADDR addr_expr_eval_result;
  CORE_ADDR addr_error_tracepoint;
  CORE_ADDR addr_tracepoints;
  CORE_ADDR addr_tracing;
  CORE_ADDR addr_trace_buffer_ctrl;
  CORE_ADDR addr_trace_buffer_ctrl_curr;
  CORE_ADDR addr_trace_buffer_lo;
  CORE_ADDR addr_trace_buffer_hi;
  CORE_ADDR addr_traceframe_read_count;
  CORE_ADDR addr_traceframe_write_count;
  CORE_ADDR addr_traceframes_created;
  CORE_ADDR addr_trace_state_variables;
  CORE_ADDR addr_get_raw_reg;
  CORE_ADDR addr_get_trace_state_variable_value;
  CORE_ADDR addr_set_trace_state_variable_value;
  CORE_ADDR addr_ust_loaded;
};

static struct
{
  const char *name;
  int offset;
  int required;
} symbol_list[] = {
  IPA_SYM(gdb_tp_heap_buffer),
  IPA_SYM(gdb_jump_pad_buffer),
  IPA_SYM(gdb_jump_pad_buffer_end),
  IPA_SYM(gdb_trampoline_buffer),
  IPA_SYM(gdb_trampoline_buffer_end),
  IPA_SYM(gdb_trampoline_buffer_error),
  IPA_SYM(collecting),
  IPA_SYM(gdb_collect),
  IPA_SYM(stop_tracing),
  IPA_SYM(flush_trace_buffer),
  IPA_SYM(about_to_request_buffer_space),
  IPA_SYM(trace_buffer_is_full),
  IPA_SYM(stopping_tracepoint),
  IPA_SYM(expr_eval_result),
  IPA_SYM(error_tracepoint),
  IPA_SYM(tracepoints),
  IPA_SYM(tracing),
  IPA_SYM(trace_buffer_ctrl),
  IPA_SYM(trace_buffer_ctrl_curr),
  IPA_SYM(trace_buffer_lo),
  IPA_SYM(trace_buffer_hi),
  IPA_SYM(traceframe_read_count),
  IPA_SYM(traceframe_write_count),
  IPA_SYM(traceframes_created),
  IPA_SYM(trace_state_variables),
  IPA_SYM(get_raw_reg),
  IPA_SYM(get_trace_state_variable_value),
  IPA_SYM(set_trace_state_variable_value),
  IPA_SYM(ust_loaded),
};

static struct ipa_sym_addresses ipa_sym_addrs;

static int read_inferior_integer (CORE_ADDR symaddr, int *val);

/* Returns true if both the in-process agent library and the static
   tracepoints libraries are loaded in the inferior, and agent has
   capability on static tracepoints.  */

static int
in_process_agent_supports_ust (void)
{
  int loaded = 0;

  if (!agent_loaded_p ())
    {
      warning ("In-process agent not loaded");
      return 0;
    }

  if (agent_capability_check (AGENT_CAPA_STATIC_TRACE))
    {
      /* Agent understands static tracepoint, then check whether UST is in
	 fact loaded in the inferior.  */
      if (read_inferior_integer (ipa_sym_addrs.addr_ust_loaded, &loaded))
	{
	  warning ("Error reading ust_loaded in lib");
	  return 0;
	}

      return loaded;
    }
  else
    return 0;
}

static void
write_e_ipa_not_loaded (char *buffer)
{
  sprintf (buffer,
	   "E.In-process agent library not loaded in process.  "
	   "Fast and static tracepoints unavailable.");
}

/* Write an error to BUFFER indicating that UST isn't loaded in the
   inferior.  */

static void
write_e_ust_not_loaded (char *buffer)
{
#ifdef HAVE_UST
  sprintf (buffer,
	   "E.UST library not loaded in process.  "
	   "Static tracepoints unavailable.");
#else
  sprintf (buffer, "E.GDBserver was built without static tracepoints support");
#endif
}

/* If the in-process agent library isn't loaded in the inferior, write
   an error to BUFFER, and return 1.  Otherwise, return 0.  */

static int
maybe_write_ipa_not_loaded (char *buffer)
{
  if (!agent_loaded_p ())
    {
      write_e_ipa_not_loaded (buffer);
      return 1;
    }
  return 0;
}

/* If the in-process agent library and the ust (static tracepoints)
   library aren't loaded in the inferior, write an error to BUFFER,
   and return 1.  Otherwise, return 0.  */

static int
maybe_write_ipa_ust_not_loaded (char *buffer)
{
  if (!agent_loaded_p ())
    {
      write_e_ipa_not_loaded (buffer);
      return 1;
    }
  else if (!in_process_agent_supports_ust ())
    {
      write_e_ust_not_loaded (buffer);
      return 1;
    }
  return 0;
}

/* Cache all future symbols that the tracepoints module might request.
   We can not request symbols at arbitrary states in the remote
   protocol, only when the client tells us that new symbols are
   available.  So when we load the in-process library, make sure to
   check the entire list.  */

void
tracepoint_look_up_symbols (void)
{
  int i;

  if (agent_loaded_p ())
    return;

  for (i = 0; i < sizeof (symbol_list) / sizeof (symbol_list[0]); i++)
    {
      CORE_ADDR *addrp =
	(CORE_ADDR *) ((char *) &ipa_sym_addrs + symbol_list[i].offset);

      if (look_up_one_symbol (symbol_list[i].name, addrp, 1) == 0)
	{
	  if (debug_threads)
	    fprintf (stderr, "symbol `%s' not found\n", symbol_list[i].name);
	  return;
	}
    }

  agent_look_up_symbols (NULL);
}

#endif

/* GDBserver places a breakpoint on the IPA's version (which is a nop)
   of the "stop_tracing" function.  When this breakpoint is hit,
   tracing stopped in the IPA for some reason.  E.g., due to
   tracepoint reaching the pass count, hitting conditional expression
   evaluation error, etc.

   The IPA's trace buffer is never in circular tracing mode: instead,
   GDBserver's is, and whenever the in-process buffer fills, it calls
   "flush_trace_buffer", which triggers an internal breakpoint.
   GDBserver reacts to this breakpoint by pulling the meanwhile
   collected data.  Old frames discarding is always handled on the
   GDBserver side.  */

#ifdef IN_PROCESS_AGENT
int
read_inferior_memory (CORE_ADDR memaddr, unsigned char *myaddr, int len)
{
  memcpy (myaddr, (void *) (uintptr_t) memaddr, len);
  return 0;
}

/* Call this in the functions where GDBserver places a breakpoint, so
   that the compiler doesn't try to be clever and skip calling the
   function at all.  This is necessary, even if we tell the compiler
   to not inline said functions.  */

#if defined(__GNUC__)
#  define UNKNOWN_SIDE_EFFECTS() asm ("")
#else
#  define UNKNOWN_SIDE_EFFECTS() do {} while (0)
#endif

IP_AGENT_EXPORT void ATTR_USED ATTR_NOINLINE
stop_tracing (void)
{
  /* GDBserver places breakpoint here.  */
  UNKNOWN_SIDE_EFFECTS();
}

IP_AGENT_EXPORT void ATTR_USED ATTR_NOINLINE
flush_trace_buffer (void)
{
  /* GDBserver places breakpoint here.  */
  UNKNOWN_SIDE_EFFECTS();
}

#endif

#ifndef IN_PROCESS_AGENT
static int
tracepoint_handler (CORE_ADDR address)
{
  trace_debug ("tracepoint_handler: tracepoint at 0x%s hit",
	       paddress (address));
  return 0;
}

/* Breakpoint at "stop_tracing" in the inferior lib.  */
struct breakpoint *stop_tracing_bkpt;
static int stop_tracing_handler (CORE_ADDR);

/* Breakpoint at "flush_trace_buffer" in the inferior lib.  */
struct breakpoint *flush_trace_buffer_bkpt;
static int flush_trace_buffer_handler (CORE_ADDR);

static void download_trace_state_variables (void);
static void upload_fast_traceframes (void);

static int run_inferior_command (char *cmd, int len);

static int
read_inferior_integer (CORE_ADDR symaddr, int *val)
{
  return read_inferior_memory (symaddr, (unsigned char *) val,
			       sizeof (*val));
}

struct tracepoint;
static int tracepoint_send_agent (struct tracepoint *tpoint);

static int
read_inferior_uinteger (CORE_ADDR symaddr, unsigned int *val)
{
  return read_inferior_memory (symaddr, (unsigned char *) val,
			       sizeof (*val));
}

static int
read_inferior_data_pointer (CORE_ADDR symaddr, CORE_ADDR *val)
{
  void *pval = (void *) (uintptr_t) val;
  int ret;

  ret = read_inferior_memory (symaddr, (unsigned char *) &pval, sizeof (pval));
  *val = (uintptr_t) pval;
  return ret;
}

static int
write_inferior_data_pointer (CORE_ADDR symaddr, CORE_ADDR val)
{
  void *pval = (void *) (uintptr_t) val;
  return write_inferior_memory (symaddr,
				(unsigned char *) &pval, sizeof (pval));
}

static int
write_inferior_integer (CORE_ADDR symaddr, int val)
{
  return write_inferior_memory (symaddr, (unsigned char *) &val, sizeof (val));
}

static int
write_inferior_uinteger (CORE_ADDR symaddr, unsigned int val)
{
  return write_inferior_memory (symaddr, (unsigned char *) &val, sizeof (val));
}

static CORE_ADDR target_malloc (ULONGEST size);
static int write_inferior_data_ptr (CORE_ADDR where, CORE_ADDR ptr);

#define COPY_FIELD_TO_BUF(BUF, OBJ, FIELD)	\
  do {							\
    memcpy (BUF, &(OBJ)->FIELD, sizeof ((OBJ)->FIELD)); \
    BUF += sizeof ((OBJ)->FIELD);			\
  } while (0)

#endif

/* Operations on various types of tracepoint actions.  */

struct tracepoint_action;

struct tracepoint_action_ops
{
  /* Download tracepoint action ACTION to IPA.  Return the address of action
     in IPA/inferior.  */
  CORE_ADDR (*download) (const struct tracepoint_action *action);

  /* Send ACTION to agent via command buffer started from BUFFER.  Return
     updated head of command buffer.  */
  char* (*send) (char *buffer, const struct tracepoint_action *action);
};

/* Base action.  Concrete actions inherit this.  */

struct tracepoint_action
{
#ifndef IN_PROCESS_AGENT
  const struct tracepoint_action_ops *ops;
#endif
  char type;
};

/* An 'M' (collect memory) action.  */
struct collect_memory_action
{
  struct tracepoint_action base;

  ULONGEST addr;
  ULONGEST len;
  int32_t basereg;
};

/* An 'R' (collect registers) action.  */

struct collect_registers_action
{
  struct tracepoint_action base;
};

/* An 'X' (evaluate expression) action.  */

struct eval_expr_action
{
  struct tracepoint_action base;

  struct agent_expr *expr;
};

/* An 'L' (collect static trace data) action.  */
struct collect_static_trace_data_action
{
  struct tracepoint_action base;
};

#ifndef IN_PROCESS_AGENT
static CORE_ADDR
m_tracepoint_action_download (const struct tracepoint_action *action)
{
  int size_in_ipa = (sizeof (struct collect_memory_action)
		     - offsetof (struct tracepoint_action, type));
  CORE_ADDR ipa_action = target_malloc (size_in_ipa);

  write_inferior_memory (ipa_action, (unsigned char *) &action->type,
			 size_in_ipa);

  return ipa_action;
}
static char *
m_tracepoint_action_send (char *buffer, const struct tracepoint_action *action)
{
  struct collect_memory_action *maction
    = (struct collect_memory_action *) action;

  COPY_FIELD_TO_BUF (buffer, maction, addr);
  COPY_FIELD_TO_BUF (buffer, maction, len);
  COPY_FIELD_TO_BUF (buffer, maction, basereg);

  return buffer;
}

static const struct tracepoint_action_ops m_tracepoint_action_ops =
{
  m_tracepoint_action_download,
  m_tracepoint_action_send,
};

static CORE_ADDR
r_tracepoint_action_download (const struct tracepoint_action *action)
{
  int size_in_ipa = (sizeof (struct collect_registers_action)
		     - offsetof (struct tracepoint_action, type));
  CORE_ADDR ipa_action  = target_malloc (size_in_ipa);

  write_inferior_memory (ipa_action, (unsigned char *) &action->type,
			size_in_ipa);

  return ipa_action;
}

static char *
r_tracepoint_action_send (char *buffer, const struct tracepoint_action *action)
{
  return buffer;
}

static const struct tracepoint_action_ops r_tracepoint_action_ops =
{
  r_tracepoint_action_download,
  r_tracepoint_action_send,
};

static CORE_ADDR download_agent_expr (struct agent_expr *expr);

static CORE_ADDR
x_tracepoint_action_download (const struct tracepoint_action *action)
{
  int size_in_ipa = (sizeof (struct eval_expr_action)
		     - offsetof (struct tracepoint_action, type));
  CORE_ADDR ipa_action = target_malloc (size_in_ipa);
  CORE_ADDR expr;

  write_inferior_memory (ipa_action, (unsigned char *) &action->type,
			 size_in_ipa);
  expr = download_agent_expr (((struct eval_expr_action *)action)->expr);
  write_inferior_data_ptr (ipa_action + offsetof (struct eval_expr_action, expr)
			   - offsetof (struct tracepoint_action, type),
			   expr);

  return ipa_action;
}

/* Copy agent expression AEXPR to buffer pointed by P.  If AEXPR is NULL,
   copy 0 to P.  Return updated header of buffer.  */

static char *
agent_expr_send (char *p, const struct agent_expr *aexpr)
{
  /* Copy the length of condition first, and then copy its
     content.  */
  if (aexpr == NULL)
    {
      memset (p, 0, 4);
      p += 4;
    }
  else
    {
      memcpy (p, &aexpr->length, 4);
      p +=4;

      memcpy (p, aexpr->bytes, aexpr->length);
      p += aexpr->length;
    }
  return p;
}

static char *
x_tracepoint_action_send ( char *buffer, const struct tracepoint_action *action)
{
  struct eval_expr_action *eaction = (struct eval_expr_action *) action;

  return agent_expr_send (buffer, eaction->expr);
}

static const struct tracepoint_action_ops x_tracepoint_action_ops =
{
  x_tracepoint_action_download,
  x_tracepoint_action_send,
};

static CORE_ADDR
l_tracepoint_action_download (const struct tracepoint_action *action)
{
  int size_in_ipa = (sizeof (struct collect_static_trace_data_action)
		     - offsetof (struct tracepoint_action, type));
  CORE_ADDR ipa_action = target_malloc (size_in_ipa);

  write_inferior_memory (ipa_action, (unsigned char *) &action->type,
			 size_in_ipa);

  return ipa_action;
}

static char *
l_tracepoint_action_send (char *buffer, const struct tracepoint_action *action)
{
  return buffer;
}

static const struct tracepoint_action_ops l_tracepoint_action_ops =
{
  l_tracepoint_action_download,
  l_tracepoint_action_send,
};
#endif

/* This structure describes a piece of the source-level definition of
   the tracepoint.  The contents are not interpreted by the target,
   but preserved verbatim for uploading upon reconnection.  */

struct source_string
{
  /* The type of string, such as "cond" for a conditional.  */
  char *type;

  /* The source-level string itself.  For the sake of target
     debugging, we store it in plaintext, even though it is always
     transmitted in hex.  */
  char *str;

  /* Link to the next one in the list.  We link them in the order
     received, in case some make up an ordered list of commands or
     some such.  */
  struct source_string *next;
};

enum tracepoint_type
{
  /* Trap based tracepoint.  */
  trap_tracepoint,

  /* A fast tracepoint implemented with a jump instead of a trap.  */
  fast_tracepoint,

  /* A static tracepoint, implemented by a program call into a tracing
     library.  */
  static_tracepoint
};

struct tracepoint_hit_ctx;

typedef enum eval_result_type (*condfn) (struct tracepoint_hit_ctx *,
					 ULONGEST *);

/* The definition of a tracepoint.  */

/* Tracepoints may have multiple locations, each at a different
   address.  This can occur with optimizations, template
   instantiation, etc.  Since the locations may be in different
   scopes, the conditions and actions may be different for each
   location.  Our target version of tracepoints is more like GDB's
   notion of "breakpoint locations", but we have almost nothing that
   is not per-location, so we bother having two kinds of objects.  The
   key consequence is that numbers are not unique, and that it takes
   both number and address to identify a tracepoint uniquely.  */

struct tracepoint
{
  /* The number of the tracepoint, as specified by GDB.  Several
     tracepoint objects here may share a number.  */
  uint32_t number;

  /* Address at which the tracepoint is supposed to trigger.  Several
     tracepoints may share an address.  */
  CORE_ADDR address;

  /* Tracepoint type.  */
  enum tracepoint_type type;

  /* True if the tracepoint is currently enabled.  */
  int8_t enabled;

  /* The number of single steps that will be performed after each
     tracepoint hit.  */
  uint64_t step_count;

  /* The number of times the tracepoint may be hit before it will
     terminate the entire tracing run.  */
  uint64_t pass_count;

  /* Pointer to the agent expression that is the tracepoint's
     conditional, or NULL if the tracepoint is unconditional.  */
  struct agent_expr *cond;

  /* The list of actions to take when the tracepoint triggers.  */
  uint32_t numactions;
  struct tracepoint_action **actions;

  /* Count of the times we've hit this tracepoint during the run.
     Note that while-stepping steps are not counted as "hits".  */
  uint64_t hit_count;

  /* Cached sum of the sizes of traceframes created by this point.  */
  uint64_t traceframe_usage;

  CORE_ADDR compiled_cond;

  /* Link to the next tracepoint in the list.  */
  struct tracepoint *next;

#ifndef IN_PROCESS_AGENT
  /* The list of actions to take when the tracepoint triggers, in
     string/packet form.  */
  char **actions_str;

  /* The collection of strings that describe the tracepoint as it was
     entered into GDB.  These are not used by the target, but are
     reported back to GDB upon reconnection.  */
  struct source_string *source_strings;

  /* The number of bytes displaced by fast tracepoints. It may subsume
     multiple instructions, for multi-byte fast tracepoints.  This
     field is only valid for fast tracepoints.  */
  uint32_t orig_size;

  /* Only for fast tracepoints.  */
  CORE_ADDR obj_addr_on_target;

  /* Address range where the original instruction under a fast
     tracepoint was relocated to.  (_end is actually one byte past
     the end).  */
  CORE_ADDR adjusted_insn_addr;
  CORE_ADDR adjusted_insn_addr_end;

  /* The address range of the piece of the jump pad buffer that was
     assigned to this fast tracepoint.  (_end is actually one byte
     past the end).*/
  CORE_ADDR jump_pad;
  CORE_ADDR jump_pad_end;

  /* The address range of the piece of the trampoline buffer that was
     assigned to this fast tracepoint.  (_end is actually one byte
     past the end).  */
  CORE_ADDR trampoline;
  CORE_ADDR trampoline_end;

  /* The list of actions to take while in a stepping loop.  These
     fields are only valid for patch-based tracepoints.  */
  int num_step_actions;
  struct tracepoint_action **step_actions;
  /* Same, but in string/packet form.  */
  char **step_actions_str;

  /* Handle returned by the breakpoint or tracepoint module when we
     inserted the trap or jump, or hooked into a static tracepoint.
     NULL if we haven't inserted it yet.  */
  void *handle;
#endif

};

#ifndef IN_PROCESS_AGENT

/* Given `while-stepping', a thread may be collecting data for more
   than one tracepoint simultaneously.  On the other hand, the same
   tracepoint with a while-stepping action may be hit by more than one
   thread simultaneously (but not quite, each thread could be handling
   a different step).  Each thread holds a list of these objects,
   representing the current step of each while-stepping action being
   collected.  */

struct wstep_state
{
  struct wstep_state *next;

  /* The tracepoint number.  */
  int tp_number;
  /* The tracepoint's address.  */
  CORE_ADDR tp_address;

  /* The number of the current step in this 'while-stepping'
     action.  */
  long current_step;
};

#endif

/* The linked list of all tracepoints.  Marked explicitly as used as
   the in-process library doesn't use it for the fast tracepoints
   support.  */
IP_AGENT_EXPORT struct tracepoint *tracepoints ATTR_USED;

#ifndef IN_PROCESS_AGENT

/* Pointer to the last tracepoint in the list, new tracepoints are
   linked in at the end.  */

static struct tracepoint *last_tracepoint;
#endif

/* The first tracepoint to exceed its pass count.  */

IP_AGENT_EXPORT struct tracepoint *stopping_tracepoint;

/* True if the trace buffer is full or otherwise no longer usable.  */

IP_AGENT_EXPORT int trace_buffer_is_full;

static enum eval_result_type expr_eval_result = expr_eval_no_error;

#ifndef IN_PROCESS_AGENT

static const char *eval_result_names[] =
  {
    "terror:in the attic",  /* this should never be reported */
    "terror:empty expression",
    "terror:empty stack",
    "terror:stack overflow",
    "terror:stack underflow",
    "terror:unhandled opcode",
    "terror:unrecognized opcode",
    "terror:divide by zero"
  };

#endif

/* The tracepoint in which the error occurred.  */

static struct tracepoint *error_tracepoint;

struct trace_state_variable
{
  /* This is the name of the variable as used in GDB.  The target
     doesn't use the name, but needs to have it for saving and
     reconnection purposes.  */
  char *name;

  /* This number identifies the variable uniquely.  Numbers may be
     assigned either by the target (in the case of builtin variables),
     or by GDB, and are presumed unique during the course of a trace
     experiment.  */
  int number;

  /* The variable's initial value, a 64-bit signed integer always.  */
  LONGEST initial_value;

  /* The variable's value, a 64-bit signed integer always.  */
  LONGEST value;

  /* Pointer to a getter function, used to supply computed values.  */
  LONGEST (*getter) (void);

  /* Link to the next variable.  */
  struct trace_state_variable *next;
};

/* Linked list of all trace state variables.  */

#ifdef IN_PROCESS_AGENT
struct trace_state_variable *alloced_trace_state_variables;
#endif

IP_AGENT_EXPORT struct trace_state_variable *trace_state_variables;

/* The results of tracing go into a fixed-size space known as the
   "trace buffer".  Because usage follows a limited number of
   patterns, we manage it ourselves rather than with malloc.  Basic
   rules are that we create only one trace frame at a time, each is
   variable in size, they are never moved once created, and we only
   discard if we are doing a circular buffer, and then only the oldest
   ones.  Each trace frame includes its own size, so we don't need to
   link them together, and the trace frame number is relative to the
   first one, so we don't need to record numbers.  A trace frame also
   records the number of the tracepoint that created it.  The data
   itself is a series of blocks, each introduced by a single character
   and with a defined format.  Each type of block has enough
   type/length info to allow scanners to jump quickly from one block
   to the next without reading each byte in the block.  */

/* Trace buffer management would be simple - advance a free pointer
   from beginning to end, then stop - were it not for the circular
   buffer option, which is a useful way to prevent a trace run from
   stopping prematurely because the buffer filled up.  In the circular
   case, the location of the first trace frame (trace_buffer_start)
   moves as old trace frames are discarded.  Also, since we grow trace
   frames incrementally as actions are performed, we wrap around to
   the beginning of the trace buffer.  This is per-block, so each
   block within a trace frame remains contiguous.  Things get messy
   when the wrapped-around trace frame is the one being discarded; the
   free space ends up in two parts at opposite ends of the buffer.  */

#ifndef ATTR_PACKED
#  if defined(__GNUC__)
#    define ATTR_PACKED __attribute__ ((packed))
#  else
#    define ATTR_PACKED /* nothing */
#  endif
#endif

/* The data collected at a tracepoint hit.  This object should be as
   small as possible, since there may be a great many of them.  We do
   not need to keep a frame number, because they are all sequential
   and there are no deletions; so the Nth frame in the buffer is
   always frame number N.  */

struct traceframe
{
  /* Number of the tracepoint that collected this traceframe.  A value
     of 0 indicates the current end of the trace buffer.  We make this
     a 16-bit field because it's never going to happen that GDB's
     numbering of tracepoints reaches 32,000.  */
  int tpnum : 16;

  /* The size of the data in this trace frame.  We limit this to 32
     bits, even on a 64-bit target, because it's just implausible that
     one is validly going to collect 4 gigabytes of data at a single
     tracepoint hit.  */
  unsigned int data_size : 32;

  /* The base of the trace data, which is contiguous from this point.  */
  unsigned char data[0];

} ATTR_PACKED;

/* The size of the EOB marker, in bytes.  A traceframe with zeroed
   fields (and no data) marks the end of trace data.  */
#define TRACEFRAME_EOB_MARKER_SIZE offsetof (struct traceframe, data)

/* The traceframe to be used as the source of data to send back to
   GDB.  A value of -1 means to get data from the live program.  */

int current_traceframe = -1;

/* This flag is true if the trace buffer is circular, meaning that
   when it fills, the oldest trace frames are discarded in order to
   make room.  */

#ifndef IN_PROCESS_AGENT
static int circular_trace_buffer;
#endif

/* Size of the trace buffer.  */

static LONGEST trace_buffer_size;

/* Pointer to the block of memory that traceframes all go into.  */

static unsigned char *trace_buffer_lo;

/* Pointer to the end of the trace buffer, more precisely to the byte
   after the end of the buffer.  */

static unsigned char *trace_buffer_hi;

/* Control structure holding the read/write/etc. pointers into the
   trace buffer.  We need more than one of these to implement a
   transaction-like mechanism to garantees that both GDBserver and the
   in-process agent can try to change the trace buffer
   simultaneously.  */

struct trace_buffer_control
{
  /* Pointer to the first trace frame in the buffer.  In the
     non-circular case, this is equal to trace_buffer_lo, otherwise it
     moves around in the buffer.  */
  unsigned char *start;

  /* Pointer to the free part of the trace buffer.  Note that we clear
     several bytes at and after this pointer, so that traceframe
     scans/searches terminate properly.  */
  unsigned char *free;

  /* Pointer to the byte after the end of the free part.  Note that
     this may be smaller than trace_buffer_free in the circular case,
     and means that the free part is in two pieces.  Initially it is
     equal to trace_buffer_hi, then is generally equivalent to
     trace_buffer_start.  */
  unsigned char *end_free;

  /* Pointer to the wraparound.  If not equal to trace_buffer_hi, then
     this is the point at which the trace data breaks, and resumes at
     trace_buffer_lo.  */
  unsigned char *wrap;
};

/* Same as above, to be used by GDBserver when updating the in-process
   agent.  */
struct ipa_trace_buffer_control
{
  uintptr_t start;
  uintptr_t free;
  uintptr_t end_free;
  uintptr_t wrap;
};


/* We have possibly both GDBserver and an inferior thread accessing
   the same IPA trace buffer memory.  The IPA is the producer (tries
   to put new frames in the buffer), while GDBserver occasionally
   consumes them, that is, flushes the IPA's buffer into its own
   buffer.  Both sides need to update the trace buffer control
   pointers (current head, tail, etc.).  We can't use a global lock to
   synchronize the accesses, as otherwise we could deadlock GDBserver
   (if the thread holding the lock stops for a signal, say).  So
   instead of that, we use a transaction scheme where GDBserver writes
   always prevail over the IPAs writes, and, we have the IPA detect
   the commit failure/overwrite, and retry the whole attempt.  This is
   mainly implemented by having a global token object that represents
   who wrote last to the buffer control structure.  We need to freeze
   any inferior writing to the buffer while GDBserver touches memory,
   so that the inferior can correctly detect that GDBserver had been
   there, otherwise, it could mistakingly think its commit was
   successful; that's implemented by simply having GDBserver set a
   breakpoint the inferior hits if it is the critical region.

   There are three cycling trace buffer control structure copies
   (buffer head, tail, etc.), with the token object including an index
   indicating which is current live copy.  The IPA tentatively builds
   an updated copy in a non-current control structure, while GDBserver
   always clobbers the current version directly.  The IPA then tries
   to atomically "commit" its version; if GDBserver clobbered the
   structure meanwhile, that will fail, and the IPA restarts the
   allocation process.

   Listing the step in further detail, we have:

  In-process agent (producer):

  - passes by `about_to_request_buffer_space' breakpoint/lock

  - reads current token, extracts current trace buffer control index,
    and starts tentatively updating the rightmost one (0->1, 1->2,
    2->0).  Note that only one inferior thread is executing this code
    at any given time, due to an outer lock in the jump pads.

  - updates counters, and tries to commit the token.

  - passes by second `about_to_request_buffer_space' breakpoint/lock,
    leaving the sync region.

  - checks if the update was effective.

  - if trace buffer was found full, hits flush_trace_buffer
    breakpoint, and restarts later afterwards.

  GDBserver (consumer):

  - sets `about_to_request_buffer_space' breakpoint/lock.

  - updates the token unconditionally, using the current buffer
    control index, since it knows that the IP agent always writes to
    the rightmost, and due to the breakpoint, at most one IP thread
    can try to update the trace buffer concurrently to GDBserver, so
    there will be no danger of trace buffer control index wrap making
    the IPA write to the same index as GDBserver.

  - flushes the IP agent's trace buffer completely, and updates the
    current trace buffer control structure.  GDBserver *always* wins.

  - removes the `about_to_request_buffer_space' breakpoint.

The token is stored in the `trace_buffer_ctrl_curr' variable.
Internally, it's bits are defined as:

 |-------------+-----+-------------+--------+-------------+--------------|
 | Bit offsets |  31 |   30 - 20   |   19   |    18-8     |     7-0      |
 |-------------+-----+-------------+--------+-------------+--------------|
 | What        | GSB | PC (11-bit) | unused | CC (11-bit) | TBCI (8-bit) |
 |-------------+-----+-------------+--------+-------------+--------------|

 GSB  - GDBserver Stamp Bit
 PC   - Previous Counter
 CC   - Current Counter
 TBCI - Trace Buffer Control Index


An IPA update of `trace_buffer_ctrl_curr' does:

    - read CC from the current token, save as PC.
    - updates pointers
    - atomically tries to write PC+1,CC

A GDBserver update of `trace_buffer_ctrl_curr' does:

    - reads PC and CC from the current token.
    - updates pointers
    - writes GSB,PC,CC
*/

/* These are the bits of `trace_buffer_ctrl_curr' that are reserved
   for the counters described below.  The cleared bits are used to
   hold the index of the items of the `trace_buffer_ctrl' array that
   is "current".  */
#define GDBSERVER_FLUSH_COUNT_MASK        0xfffffff0

/* `trace_buffer_ctrl_curr' contains two counters.  The `previous'
   counter, and the `current' counter.  */

#define GDBSERVER_FLUSH_COUNT_MASK_PREV   0x7ff00000
#define GDBSERVER_FLUSH_COUNT_MASK_CURR   0x0007ff00

/* When GDBserver update the IP agent's `trace_buffer_ctrl_curr', it
   always stamps this bit as set.  */
#define GDBSERVER_UPDATED_FLUSH_COUNT_BIT 0x80000000

#ifdef IN_PROCESS_AGENT
IP_AGENT_EXPORT struct trace_buffer_control trace_buffer_ctrl[3];
IP_AGENT_EXPORT unsigned int trace_buffer_ctrl_curr;

# define TRACE_BUFFER_CTRL_CURR \
  (trace_buffer_ctrl_curr & ~GDBSERVER_FLUSH_COUNT_MASK)

#else

/* The GDBserver side agent only needs one instance of this object, as
   it doesn't need to sync with itself.  Define it as array anyway so
   that the rest of the code base doesn't need to care for the
   difference.  */
struct trace_buffer_control trace_buffer_ctrl[1];
# define TRACE_BUFFER_CTRL_CURR 0
#endif

/* These are convenience macros used to access the current trace
   buffer control in effect.  */
#define trace_buffer_start (trace_buffer_ctrl[TRACE_BUFFER_CTRL_CURR].start)
#define trace_buffer_free (trace_buffer_ctrl[TRACE_BUFFER_CTRL_CURR].free)
#define trace_buffer_end_free \
  (trace_buffer_ctrl[TRACE_BUFFER_CTRL_CURR].end_free)
#define trace_buffer_wrap (trace_buffer_ctrl[TRACE_BUFFER_CTRL_CURR].wrap)


/* Macro that returns a pointer to the first traceframe in the buffer.  */

#define FIRST_TRACEFRAME() ((struct traceframe *) trace_buffer_start)

/* Macro that returns a pointer to the next traceframe in the buffer.
   If the computed location is beyond the wraparound point, subtract
   the offset of the wraparound.  */

#define NEXT_TRACEFRAME_1(TF) \
  (((unsigned char *) (TF)) + sizeof (struct traceframe) + (TF)->data_size)

#define NEXT_TRACEFRAME(TF) \
  ((struct traceframe *) (NEXT_TRACEFRAME_1 (TF)  \
			  - ((NEXT_TRACEFRAME_1 (TF) >= trace_buffer_wrap) \
			     ? (trace_buffer_wrap - trace_buffer_lo)	\
			     : 0)))

/* The difference between these counters represents the total number
   of complete traceframes present in the trace buffer.  The IP agent
   writes to the write count, GDBserver writes to read count.  */

IP_AGENT_EXPORT unsigned int traceframe_write_count;
IP_AGENT_EXPORT unsigned int traceframe_read_count;

/* Convenience macro.  */

#define traceframe_count \
  ((unsigned int) (traceframe_write_count - traceframe_read_count))

/* The count of all traceframes created in the current run, including
   ones that were discarded to make room.  */

IP_AGENT_EXPORT int traceframes_created;

#ifndef IN_PROCESS_AGENT

/* Read-only regions are address ranges whose contents don't change,
   and so can be read from target memory even while looking at a trace
   frame.  Without these, disassembly for instance will likely fail,
   because the program code is not usually collected into a trace
   frame.  This data structure does not need to be very complicated or
   particularly efficient, it's only going to be used occasionally,
   and only by some commands.  */

struct readonly_region
{
  /* The bounds of the region.  */
  CORE_ADDR start, end;

  /* Link to the next one.  */
  struct readonly_region *next;
};

/* Linked list of readonly regions.  This list stays in effect from
   one tstart to the next.  */

static struct readonly_region *readonly_regions;

#endif

/* The global that controls tracing overall.  */

IP_AGENT_EXPORT int tracing;

#ifndef IN_PROCESS_AGENT

/* Controls whether tracing should continue after GDB disconnects.  */

int disconnected_tracing;

/* The reason for the last tracing run to have stopped.  We initialize
   to a distinct string so that GDB can distinguish between "stopped
   after running" and "stopped because never run" cases.  */

static const char *tracing_stop_reason = "tnotrun";

static int tracing_stop_tpnum;

/* 64-bit timestamps for the trace run's start and finish, expressed
   in microseconds from the Unix epoch.  */

LONGEST tracing_start_time;
LONGEST tracing_stop_time;

/* The (optional) user-supplied name of the user that started the run.
   This is an arbitrary string, and may be NULL.  */

char *tracing_user_name;

/* Optional user-supplied text describing the run.  This is
   an arbitrary string, and may be NULL.  */

char *tracing_notes;

/* Optional user-supplied text explaining a tstop command.  This is an
   arbitrary string, and may be NULL.  */

char *tracing_stop_note;

#endif

/* Functions local to this file.  */

/* Base "class" for tracepoint type specific data to be passed down to
   collect_data_at_tracepoint.  */
struct tracepoint_hit_ctx
{
  enum tracepoint_type type;
};

#ifdef IN_PROCESS_AGENT

/* Fast/jump tracepoint specific data to be passed down to
   collect_data_at_tracepoint.  */
struct fast_tracepoint_ctx
{
  struct tracepoint_hit_ctx base;

  struct regcache regcache;
  int regcache_initted;
  unsigned char *regspace;

  unsigned char *regs;
  struct tracepoint *tpoint;
};

/* Static tracepoint specific data to be passed down to
   collect_data_at_tracepoint.  */
struct static_tracepoint_ctx
{
  struct tracepoint_hit_ctx base;

  /* The regcache corresponding to the registers state at the time of
     the tracepoint hit.  Initialized lazily, from REGS.  */
  struct regcache regcache;
  int regcache_initted;

  /* The buffer space REGCACHE above uses.  We use a separate buffer
     instead of letting the regcache malloc for both signal safety and
     performance reasons; this is allocated on the stack instead.  */
  unsigned char *regspace;

  /* The register buffer as passed on by lttng/ust.  */
  struct registers *regs;

  /* The "printf" formatter and the args the user passed to the marker
     call.  We use this to be able to collect "static trace data"
     ($_sdata).  */
  const char *fmt;
  va_list *args;

  /* The GDB tracepoint matching the probed marker that was "hit".  */
  struct tracepoint *tpoint;
};

#else

/* Static tracepoint specific data to be passed down to
   collect_data_at_tracepoint.  */
struct trap_tracepoint_ctx
{
  struct tracepoint_hit_ctx base;

  struct regcache *regcache;
};

#endif

#ifndef IN_PROCESS_AGENT
static CORE_ADDR traceframe_get_pc (struct traceframe *tframe);
static int traceframe_read_tsv (int num, LONGEST *val);
#endif

static int condition_true_at_tracepoint (struct tracepoint_hit_ctx *ctx,
					 struct tracepoint *tpoint);

#ifndef IN_PROCESS_AGENT
static void clear_readonly_regions (void);
static void clear_installed_tracepoints (void);
#endif

static void collect_data_at_tracepoint (struct tracepoint_hit_ctx *ctx,
					CORE_ADDR stop_pc,
					struct tracepoint *tpoint);
#ifndef IN_PROCESS_AGENT
static void collect_data_at_step (struct tracepoint_hit_ctx *ctx,
				  CORE_ADDR stop_pc,
				  struct tracepoint *tpoint, int current_step);
static void compile_tracepoint_condition (struct tracepoint *tpoint,
					  CORE_ADDR *jump_entry);
#endif
static void do_action_at_tracepoint (struct tracepoint_hit_ctx *ctx,
				     CORE_ADDR stop_pc,
				     struct tracepoint *tpoint,
				     struct traceframe *tframe,
				     struct tracepoint_action *taction);

#ifndef IN_PROCESS_AGENT
static struct tracepoint *fast_tracepoint_from_ipa_tpoint_address (CORE_ADDR);

static void install_tracepoint (struct tracepoint *, char *own_buf);
static void download_tracepoint (struct tracepoint *);
static int install_fast_tracepoint (struct tracepoint *, char *errbuf);
static void clone_fast_tracepoint (struct tracepoint *to,
				   const struct tracepoint *from);
#endif

static LONGEST get_timestamp (void);

#if defined(__GNUC__)
#  define memory_barrier() asm volatile ("" : : : "memory")
#else
#  define memory_barrier() do {} while (0)
#endif

/* We only build the IPA if this builtin is supported, and there are
   no uses of this in GDBserver itself, so we're safe in defining this
   unconditionally.  */
#define cmpxchg(mem, oldval, newval) \
  __sync_val_compare_and_swap (mem, oldval, newval)

/* Record that an error occurred during expression evaluation.  */

static void
record_tracepoint_error (struct tracepoint *tpoint, const char *which,
			 enum eval_result_type rtype)
{
  trace_debug ("Tracepoint %d at %s %s eval reports error %d",
	       tpoint->number, paddress (tpoint->address), which, rtype);

#ifdef IN_PROCESS_AGENT
  /* Only record the first error we get.  */
  if (cmpxchg (&expr_eval_result,
	       expr_eval_no_error,
	       rtype) != expr_eval_no_error)
    return;
#else
  if (expr_eval_result != expr_eval_no_error)
    return;
#endif

  error_tracepoint = tpoint;
}

/* Trace buffer management.  */

static void
clear_trace_buffer (void)
{
  trace_buffer_start = trace_buffer_lo;
  trace_buffer_free = trace_buffer_lo;
  trace_buffer_end_free = trace_buffer_hi;
  trace_buffer_wrap = trace_buffer_hi;
  /* A traceframe with zeroed fields marks the end of trace data.  */
  ((struct traceframe *) trace_buffer_free)->tpnum = 0;
  ((struct traceframe *) trace_buffer_free)->data_size = 0;
  traceframe_read_count = traceframe_write_count = 0;
  traceframes_created = 0;
}

#ifndef IN_PROCESS_AGENT

static void
clear_inferior_trace_buffer (void)
{
  CORE_ADDR ipa_trace_buffer_lo;
  CORE_ADDR ipa_trace_buffer_hi;
  struct traceframe ipa_traceframe = { 0 };
  struct ipa_trace_buffer_control ipa_trace_buffer_ctrl;

  read_inferior_data_pointer (ipa_sym_addrs.addr_trace_buffer_lo,
			      &ipa_trace_buffer_lo);
  read_inferior_data_pointer (ipa_sym_addrs.addr_trace_buffer_hi,
			      &ipa_trace_buffer_hi);

  ipa_trace_buffer_ctrl.start = ipa_trace_buffer_lo;
  ipa_trace_buffer_ctrl.free = ipa_trace_buffer_lo;
  ipa_trace_buffer_ctrl.end_free = ipa_trace_buffer_hi;
  ipa_trace_buffer_ctrl.wrap = ipa_trace_buffer_hi;

  /* A traceframe with zeroed fields marks the end of trace data.  */
  write_inferior_memory (ipa_sym_addrs.addr_trace_buffer_ctrl,
			 (unsigned char *) &ipa_trace_buffer_ctrl,
			 sizeof (ipa_trace_buffer_ctrl));

  write_inferior_uinteger (ipa_sym_addrs.addr_trace_buffer_ctrl_curr, 0);

  /* A traceframe with zeroed fields marks the end of trace data.  */
  write_inferior_memory (ipa_trace_buffer_lo,
			 (unsigned char *) &ipa_traceframe,
			 sizeof (ipa_traceframe));

  write_inferior_uinteger (ipa_sym_addrs.addr_traceframe_write_count, 0);
  write_inferior_uinteger (ipa_sym_addrs.addr_traceframe_read_count, 0);
  write_inferior_integer (ipa_sym_addrs.addr_traceframes_created, 0);
}

#endif

static void
init_trace_buffer (LONGEST bufsize)
{
  size_t alloc_size;

  trace_buffer_size = bufsize;

  /* Make sure to internally allocate at least space for the EOB
     marker.  */
  alloc_size = (bufsize < TRACEFRAME_EOB_MARKER_SIZE
		? TRACEFRAME_EOB_MARKER_SIZE : bufsize);
  trace_buffer_lo = xrealloc (trace_buffer_lo, alloc_size);

  trace_buffer_hi = trace_buffer_lo + trace_buffer_size;

  clear_trace_buffer ();
}

#ifdef IN_PROCESS_AGENT

IP_AGENT_EXPORT void ATTR_USED ATTR_NOINLINE
about_to_request_buffer_space (void)
{
  /* GDBserver places breakpoint here while it goes about to flush
     data at random times.  */
  UNKNOWN_SIDE_EFFECTS();
}

#endif

/* Carve out a piece of the trace buffer, returning NULL in case of
   failure.  */

static void *
trace_buffer_alloc (size_t amt)
{
  unsigned char *rslt;
  struct trace_buffer_control *tbctrl;
  unsigned int curr;
#ifdef IN_PROCESS_AGENT
  unsigned int prev, prev_filtered;
  unsigned int commit_count;
  unsigned int commit;
  unsigned int readout;
#else
  struct traceframe *oldest;
  unsigned char *new_start;
#endif

  trace_debug ("Want to allocate %ld+%ld bytes in trace buffer",
	       (long) amt, (long) sizeof (struct traceframe));

  /* Account for the EOB marker.  */
  amt += TRACEFRAME_EOB_MARKER_SIZE;

#ifdef IN_PROCESS_AGENT
 again:
  memory_barrier ();

  /* Read the current token and extract the index to try to write to,
     storing it in CURR.  */
  prev = trace_buffer_ctrl_curr;
  prev_filtered = prev & ~GDBSERVER_FLUSH_COUNT_MASK;
  curr = prev_filtered + 1;
  if (curr > 2)
    curr = 0;

  about_to_request_buffer_space ();

  /* Start out with a copy of the current state.  GDBserver may be
     midway writing to the PREV_FILTERED TBC, but, that's OK, we won't
     be able to commit anyway if that happens.  */
  trace_buffer_ctrl[curr]
    = trace_buffer_ctrl[prev_filtered];
  trace_debug ("trying curr=%u", curr);
#else
  /* The GDBserver's agent doesn't need all that syncing, and always
     updates TCB 0 (there's only one, mind you).  */
  curr = 0;
#endif
  tbctrl = &trace_buffer_ctrl[curr];

  /* Offsets are easier to grok for debugging than raw addresses,
     especially for the small trace buffer sizes that are useful for
     testing.  */
  trace_debug ("Trace buffer [%d] start=%d free=%d endfree=%d wrap=%d hi=%d",
	       curr,
	       (int) (tbctrl->start - trace_buffer_lo),
	       (int) (tbctrl->free - trace_buffer_lo),
	       (int) (tbctrl->end_free - trace_buffer_lo),
	       (int) (tbctrl->wrap - trace_buffer_lo),
	       (int) (trace_buffer_hi - trace_buffer_lo));

  /* The algorithm here is to keep trying to get a contiguous block of
     the requested size, possibly discarding older traceframes to free
     up space.  Since free space might come in one or two pieces,
     depending on whether discarded traceframes wrapped around at the
     high end of the buffer, we test both pieces after each
     discard.  */
  while (1)
    {
      /* First, if we have two free parts, try the upper one first.  */
      if (tbctrl->end_free < tbctrl->free)
	{
	  if (tbctrl->free + amt <= trace_buffer_hi)
	    /* We have enough in the upper part.  */
	    break;
	  else
	    {
	      /* Our high part of free space wasn't enough.  Give up
		 on it for now, set wraparound.  We will recover the
		 space later, if/when the wrapped-around traceframe is
		 discarded.  */
	      trace_debug ("Upper part too small, setting wraparound");
	      tbctrl->wrap = tbctrl->free;
	      tbctrl->free = trace_buffer_lo;
	    }
	}

      /* The normal case.  */
      if (tbctrl->free + amt <= tbctrl->end_free)
	break;

#ifdef IN_PROCESS_AGENT
      /* The IP Agent's buffer is always circular.  It isn't used
	 currently, but `circular_trace_buffer' could represent
	 GDBserver's mode.  If we didn't find space, ask GDBserver to
	 flush.  */

      flush_trace_buffer ();
      memory_barrier ();
      if (tracing)
	{
	  trace_debug ("gdbserver flushed buffer, retrying");
	  goto again;
	}

      /* GDBserver cancelled the tracing.  Bail out as well.  */
      return NULL;
#else
      /* If we're here, then neither part is big enough, and
	 non-circular trace buffers are now full.  */
      if (!circular_trace_buffer)
	{
	  trace_debug ("Not enough space in the trace buffer");
	  return NULL;
	}

      trace_debug ("Need more space in the trace buffer");

      /* If we have a circular buffer, we can try discarding the
	 oldest traceframe and see if that helps.  */
      oldest = FIRST_TRACEFRAME ();
      if (oldest->tpnum == 0)
	{
	  /* Not good; we have no traceframes to free.  Perhaps we're
	     asking for a block that is larger than the buffer?  In
	     any case, give up.  */
	  trace_debug ("No traceframes to discard");
	  return NULL;
	}

      /* We don't run this code in the in-process agent currently.
	 E.g., we could leave the in-process agent in autonomous
	 circular mode if we only have fast tracepoints.  If we do
	 that, then this bit becomes racy with GDBserver, which also
	 writes to this counter.  */
      --traceframe_write_count;

      new_start = (unsigned char *) NEXT_TRACEFRAME (oldest);
      /* If we freed the traceframe that wrapped around, go back
	 to the non-wrap case.  */
      if (new_start < tbctrl->start)
	{
	  trace_debug ("Discarding past the wraparound");
	  tbctrl->wrap = trace_buffer_hi;
	}
      tbctrl->start = new_start;
      tbctrl->end_free = tbctrl->start;

      trace_debug ("Discarded a traceframe\n"
		   "Trace buffer [%d], start=%d free=%d "
		   "endfree=%d wrap=%d hi=%d",
		   curr,
		   (int) (tbctrl->start - trace_buffer_lo),
		   (int) (tbctrl->free - trace_buffer_lo),
		   (int) (tbctrl->end_free - trace_buffer_lo),
		   (int) (tbctrl->wrap - trace_buffer_lo),
		   (int) (trace_buffer_hi - trace_buffer_lo));

      /* Now go back around the loop.  The discard might have resulted
	 in either one or two pieces of free space, so we want to try
	 both before freeing any more traceframes.  */
#endif
    }

  /* If we get here, we know we can provide the asked-for space.  */

  rslt = tbctrl->free;

  /* Adjust the request back down, now that we know we have space for
     the marker, but don't commit to AMT yet, we may still need to
     restart the operation if GDBserver touches the trace buffer
     (obviously only important in the in-process agent's version).  */
  tbctrl->free += (amt - sizeof (struct traceframe));

  /* Or not.  If GDBserver changed the trace buffer behind our back,
     we get to restart a new allocation attempt.  */

#ifdef IN_PROCESS_AGENT
  /* Build the tentative token.  */
  commit_count = (((prev & GDBSERVER_FLUSH_COUNT_MASK_CURR) + 0x100)
		  & GDBSERVER_FLUSH_COUNT_MASK_CURR);
  commit = (((prev & GDBSERVER_FLUSH_COUNT_MASK_CURR) << 12)
	    | commit_count
	    | curr);

  /* Try to commit it.  */
  readout = cmpxchg (&trace_buffer_ctrl_curr, prev, commit);
  if (readout != prev)
    {
      trace_debug ("GDBserver has touched the trace buffer, restarting."
		   " (prev=%08x, commit=%08x, readout=%08x)",
		   prev, commit, readout);
      goto again;
    }

  /* Hold your horses here.  Even if that change was committed,
     GDBserver could come in, and clobber it.  We need to hold to be
     able to tell if GDBserver clobbers before or after we committed
     the change.  Whenever GDBserver goes about touching the IPA
     buffer, it sets a breakpoint in this routine, so we have a sync
     point here.  */
  about_to_request_buffer_space ();

  /* Check if the change has been effective, even if GDBserver stopped
     us at the breakpoint.  */

  {
    unsigned int refetch;

    memory_barrier ();

    refetch = trace_buffer_ctrl_curr;

    if (refetch == commit
	|| ((refetch & GDBSERVER_FLUSH_COUNT_MASK_PREV) >> 12) == commit_count)
      {
	/* effective */
	trace_debug ("change is effective: (prev=%08x, commit=%08x, "
		     "readout=%08x, refetch=%08x)",
		     prev, commit, readout, refetch);
      }
    else
      {
	trace_debug ("GDBserver has touched the trace buffer, not effective."
		     " (prev=%08x, commit=%08x, readout=%08x, refetch=%08x)",
		     prev, commit, readout, refetch);
	goto again;
      }
  }
#endif

  /* We have a new piece of the trace buffer.  Hurray!  */

  /* Add an EOB marker just past this allocation.  */
  ((struct traceframe *) tbctrl->free)->tpnum = 0;
  ((struct traceframe *) tbctrl->free)->data_size = 0;

  /* Adjust the request back down, now that we know we have space for
     the marker.  */
  amt -= sizeof (struct traceframe);

  if (debug_threads)
    {
      trace_debug ("Allocated %d bytes", (int) amt);
      trace_debug ("Trace buffer [%d] start=%d free=%d "
		   "endfree=%d wrap=%d hi=%d",
		   curr,
		   (int) (tbctrl->start - trace_buffer_lo),
		   (int) (tbctrl->free - trace_buffer_lo),
		   (int) (tbctrl->end_free - trace_buffer_lo),
		   (int) (tbctrl->wrap - trace_buffer_lo),
		   (int) (trace_buffer_hi - trace_buffer_lo));
    }

  return rslt;
}

#ifndef IN_PROCESS_AGENT

/* Return the total free space.  This is not necessarily the largest
   block we can allocate, because of the two-part case.  */

static int
free_space (void)
{
  if (trace_buffer_free <= trace_buffer_end_free)
    return trace_buffer_end_free - trace_buffer_free;
  else
    return ((trace_buffer_end_free - trace_buffer_lo)
	    + (trace_buffer_hi - trace_buffer_free));
}

/* An 'S' in continuation packets indicates remainder are for
   while-stepping.  */

static int seen_step_action_flag;

/* Create a tracepoint (location) with given number and address.  Add this
   new tracepoint to list and sort this list.  */

static struct tracepoint *
add_tracepoint (int num, CORE_ADDR addr)
{
  struct tracepoint *tpoint, **tp_next;

  tpoint = xmalloc (sizeof (struct tracepoint));
  tpoint->number = num;
  tpoint->address = addr;
  tpoint->numactions = 0;
  tpoint->actions = NULL;
  tpoint->actions_str = NULL;
  tpoint->cond = NULL;
  tpoint->num_step_actions = 0;
  tpoint->step_actions = NULL;
  tpoint->step_actions_str = NULL;
  /* Start all off as regular (slow) tracepoints.  */
  tpoint->type = trap_tracepoint;
  tpoint->orig_size = -1;
  tpoint->source_strings = NULL;
  tpoint->compiled_cond = 0;
  tpoint->handle = NULL;
  tpoint->next = NULL;

  /* Find a place to insert this tracepoint into list in order to keep
     the tracepoint list still in the ascending order.  There may be
     multiple tracepoints at the same address as TPOINT's, and this
     guarantees TPOINT is inserted after all the tracepoints which are
     set at the same address.  For example, fast tracepoints A, B, C are
     set at the same address, and D is to be insert at the same place as
     well,

     -->| A |--> | B |-->| C |->...

     One jump pad was created for tracepoint A, B, and C, and the target
     address of A is referenced/used in jump pad.  So jump pad will let
     inferior jump to A.  If D is inserted in front of A, like this,

     -->| D |-->| A |--> | B |-->| C |->...

     without updating jump pad, D is not reachable during collect, which
     is wrong.  As we can see, the order of B, C and D doesn't matter, but
     A should always be the `first' one.  */
  for (tp_next = &tracepoints;
       (*tp_next) != NULL && (*tp_next)->address <= tpoint->address;
       tp_next = &(*tp_next)->next)
    ;
  tpoint->next = *tp_next;
  *tp_next = tpoint;
  last_tracepoint = tpoint;

  seen_step_action_flag = 0;

  return tpoint;
}

#ifndef IN_PROCESS_AGENT

/* Return the tracepoint with the given number and address, or NULL.  */

static struct tracepoint *
find_tracepoint (int id, CORE_ADDR addr)
{
  struct tracepoint *tpoint;

  for (tpoint = tracepoints; tpoint; tpoint = tpoint->next)
    if (tpoint->number == id && tpoint->address == addr)
      return tpoint;

  return NULL;
}

/* Remove TPOINT from global list.  */

static void
remove_tracepoint (struct tracepoint *tpoint)
{
  struct tracepoint *tp, *tp_prev;

  for (tp = tracepoints, tp_prev = NULL; tp && tp != tpoint;
       tp_prev = tp, tp = tp->next)
    ;

  if (tp)
    {
      if (tp_prev)
	tp_prev->next = tp->next;
      else
	tracepoints = tp->next;

      xfree (tp);
    }
}

/* There may be several tracepoints with the same number (because they
   are "locations", in GDB parlance); return the next one after the
   given tracepoint, or search from the beginning of the list if the
   first argument is NULL.  */

static struct tracepoint *
find_next_tracepoint_by_number (struct tracepoint *prev_tp, int num)
{
  struct tracepoint *tpoint;

  if (prev_tp)
    tpoint = prev_tp->next;
  else
    tpoint = tracepoints;
  for (; tpoint; tpoint = tpoint->next)
    if (tpoint->number == num)
      return tpoint;

  return NULL;
}

#endif

/* Append another action to perform when the tracepoint triggers.  */

static void
add_tracepoint_action (struct tracepoint *tpoint, char *packet)
{
  char *act;

  if (*packet == 'S')
    {
      seen_step_action_flag = 1;
      ++packet;
    }

  act = packet;

  while (*act)
    {
      char *act_start = act;
      struct tracepoint_action *action = NULL;

      switch (*act)
	{
	case 'M':
	  {
	    struct collect_memory_action *maction;
	    ULONGEST basereg;
	    int is_neg;

	    maction = xmalloc (sizeof *maction);
	    maction->base.type = *act;
	    maction->base.ops = &m_tracepoint_action_ops;
	    action = &maction->base;

	    ++act;
	    is_neg = (*act == '-');
	    if (*act == '-')
	      ++act;
	    act = unpack_varlen_hex (act, &basereg);
	    ++act;
	    act = unpack_varlen_hex (act, &maction->addr);
	    ++act;
	    act = unpack_varlen_hex (act, &maction->len);
	    maction->basereg = (is_neg
				? - (int) basereg
				: (int) basereg);
	    trace_debug ("Want to collect %s bytes at 0x%s (basereg %d)",
			 pulongest (maction->len),
			 paddress (maction->addr), maction->basereg);
	    break;
	  }
	case 'R':
	  {
	    struct collect_registers_action *raction;

	    raction = xmalloc (sizeof *raction);
	    raction->base.type = *act;
	    raction->base.ops = &r_tracepoint_action_ops;
	    action = &raction->base;

	    trace_debug ("Want to collect registers");
	    ++act;
	    /* skip past hex digits of mask for now */
	    while (isxdigit(*act))
	      ++act;
	    break;
	  }
	case 'L':
	  {
	    struct collect_static_trace_data_action *raction;

	    raction = xmalloc (sizeof *raction);
	    raction->base.type = *act;
	    raction->base.ops = &l_tracepoint_action_ops;
	    action = &raction->base;

	    trace_debug ("Want to collect static trace data");
	    ++act;
	    break;
	  }
	case 'S':
	  trace_debug ("Unexpected step action, ignoring");
	  ++act;
	  break;
	case 'X':
	  {
	    struct eval_expr_action *xaction;

	    xaction = xmalloc (sizeof (*xaction));
	    xaction->base.type = *act;
	    xaction->base.ops = &x_tracepoint_action_ops;
	    action = &xaction->base;

	    trace_debug ("Want to evaluate expression");
	    xaction->expr = gdb_parse_agent_expr (&act);
	    break;
	  }
	default:
	  trace_debug ("unknown trace action '%c', ignoring...", *act);
	  break;
	case '-':
	  break;
	}

      if (action == NULL)
	break;

      if (seen_step_action_flag)
	{
	  tpoint->num_step_actions++;

	  tpoint->step_actions
	    = xrealloc (tpoint->step_actions,
			(sizeof (*tpoint->step_actions)
			 * tpoint->num_step_actions));
	  tpoint->step_actions_str
	    = xrealloc (tpoint->step_actions_str,
			(sizeof (*tpoint->step_actions_str)
			 * tpoint->num_step_actions));
	  tpoint->step_actions[tpoint->num_step_actions - 1] = action;
	  tpoint->step_actions_str[tpoint->num_step_actions - 1]
	    = savestring (act_start, act - act_start);
	}
      else
	{
	  tpoint->numactions++;
	  tpoint->actions
	    = xrealloc (tpoint->actions,
			sizeof (*tpoint->actions) * tpoint->numactions);
	  tpoint->actions_str
	    = xrealloc (tpoint->actions_str,
			sizeof (*tpoint->actions_str) * tpoint->numactions);
	  tpoint->actions[tpoint->numactions - 1] = action;
	  tpoint->actions_str[tpoint->numactions - 1]
	    = savestring (act_start, act - act_start);
	}
    }
}

#endif

/* Find or create a trace state variable with the given number.  */

static struct trace_state_variable *
get_trace_state_variable (int num)
{
  struct trace_state_variable *tsv;

#ifdef IN_PROCESS_AGENT
  /* Search for an existing variable.  */
  for (tsv = alloced_trace_state_variables; tsv; tsv = tsv->next)
    if (tsv->number == num)
      return tsv;
#endif

  /* Search for an existing variable.  */
  for (tsv = trace_state_variables; tsv; tsv = tsv->next)
    if (tsv->number == num)
      return tsv;

  return NULL;
}

/* Find or create a trace state variable with the given number.  */

static struct trace_state_variable *
create_trace_state_variable (int num, int gdb)
{
  struct trace_state_variable *tsv;

  tsv = get_trace_state_variable (num);
  if (tsv != NULL)
    return tsv;

  /* Create a new variable.  */
  tsv = xmalloc (sizeof (struct trace_state_variable));
  tsv->number = num;
  tsv->initial_value = 0;
  tsv->value = 0;
  tsv->getter = NULL;
  tsv->name = NULL;
#ifdef IN_PROCESS_AGENT
  if (!gdb)
    {
      tsv->next = alloced_trace_state_variables;
      alloced_trace_state_variables = tsv;
    }
  else
#endif
    {
      tsv->next = trace_state_variables;
      trace_state_variables = tsv;
    }
  return tsv;
}

IP_AGENT_EXPORT LONGEST
get_trace_state_variable_value (int num)
{
  struct trace_state_variable *tsv;

  tsv = get_trace_state_variable (num);

  if (!tsv)
    {
      trace_debug ("No trace state variable %d, skipping value get", num);
      return 0;
    }

  /* Call a getter function if we have one.  While it's tempting to
     set up something to only call the getter once per tracepoint hit,
     it could run afoul of thread races. Better to let the getter
     handle it directly, if necessary to worry about it.  */
  if (tsv->getter)
    tsv->value = (tsv->getter) ();

  trace_debug ("get_trace_state_variable_value(%d) ==> %s",
	       num, plongest (tsv->value));

  return tsv->value;
}

IP_AGENT_EXPORT void
set_trace_state_variable_value (int num, LONGEST val)
{
  struct trace_state_variable *tsv;

  tsv = get_trace_state_variable (num);

  if (!tsv)
    {
      trace_debug ("No trace state variable %d, skipping value set", num);
      return;
    }

  tsv->value = val;
}

LONGEST
agent_get_trace_state_variable_value (int num)
{
  return get_trace_state_variable_value (num);
}

void
agent_set_trace_state_variable_value (int num, LONGEST val)
{
  set_trace_state_variable_value (num, val);
}

static void
set_trace_state_variable_name (int num, const char *name)
{
  struct trace_state_variable *tsv;

  tsv = get_trace_state_variable (num);

  if (!tsv)
    {
      trace_debug ("No trace state variable %d, skipping name set", num);
      return;
    }

  tsv->name = (char *) name;
}

static void
set_trace_state_variable_getter (int num, LONGEST (*getter) (void))
{
  struct trace_state_variable *tsv;

  tsv = get_trace_state_variable (num);

  if (!tsv)
    {
      trace_debug ("No trace state variable %d, skipping getter set", num);
      return;
    }

  tsv->getter = getter;
}

/* Add a raw traceframe for the given tracepoint.  */

static struct traceframe *
add_traceframe (struct tracepoint *tpoint)
{
  struct traceframe *tframe;

  tframe = trace_buffer_alloc (sizeof (struct traceframe));

  if (tframe == NULL)
    return NULL;

  tframe->tpnum = tpoint->number;
  tframe->data_size = 0;

  return tframe;
}

/* Add a block to the traceframe currently being worked on.  */

static unsigned char *
add_traceframe_block (struct traceframe *tframe,
		      struct tracepoint *tpoint, int amt)
{
  unsigned char *block;

  if (!tframe)
    return NULL;

  block = trace_buffer_alloc (amt);

  if (!block)
    return NULL;

  gdb_assert (tframe->tpnum == tpoint->number);

  tframe->data_size += amt;
  tpoint->traceframe_usage += amt;

  return block;
}

/* Flag that the current traceframe is finished.  */

static void
finish_traceframe (struct traceframe *tframe)
{
  ++traceframe_write_count;
  ++traceframes_created;
}

#ifndef IN_PROCESS_AGENT

/* Given a traceframe number NUM, find the NUMth traceframe in the
   buffer.  */

static struct traceframe *
find_traceframe (int num)
{
  struct traceframe *tframe;
  int tfnum = 0;

  for (tframe = FIRST_TRACEFRAME ();
       tframe->tpnum != 0;
       tframe = NEXT_TRACEFRAME (tframe))
    {
      if (tfnum == num)
	return tframe;
      ++tfnum;
    }

  return NULL;
}

static CORE_ADDR
get_traceframe_address (struct traceframe *tframe)
{
  CORE_ADDR addr;
  struct tracepoint *tpoint;

  addr = traceframe_get_pc (tframe);

  if (addr)
    return addr;

  /* Fallback strategy, will be incorrect for while-stepping frames
     and multi-location tracepoints.  */
  tpoint = find_next_tracepoint_by_number (NULL, tframe->tpnum);
  return tpoint->address;
}

/* Search for the next traceframe whose address is inside or outside
   the given range.  */

static struct traceframe *
find_next_traceframe_in_range (CORE_ADDR lo, CORE_ADDR hi, int inside_p,
			       int *tfnump)
{
  struct traceframe *tframe;
  CORE_ADDR tfaddr;

  *tfnump = current_traceframe + 1;
  tframe = find_traceframe (*tfnump);
  /* The search is not supposed to wrap around.  */
  if (!tframe)
    {
      *tfnump = -1;
      return NULL;
    }

  for (; tframe->tpnum != 0; tframe = NEXT_TRACEFRAME (tframe))
    {
      tfaddr = get_traceframe_address (tframe);
      if (inside_p
	  ? (lo <= tfaddr && tfaddr <= hi)
	  : (lo > tfaddr || tfaddr > hi))
	return tframe;
      ++*tfnump;
    }

  *tfnump = -1;
  return NULL;
}

/* Search for the next traceframe recorded by the given tracepoint.
   Note that for multi-location tracepoints, this will find whatever
   location appears first.  */

static struct traceframe *
find_next_traceframe_by_tracepoint (int num, int *tfnump)
{
  struct traceframe *tframe;

  *tfnump = current_traceframe + 1;
  tframe = find_traceframe (*tfnump);
  /* The search is not supposed to wrap around.  */
  if (!tframe)
    {
      *tfnump = -1;
      return NULL;
    }

  for (; tframe->tpnum != 0; tframe = NEXT_TRACEFRAME (tframe))
    {
      if (tframe->tpnum == num)
	return tframe;
      ++*tfnump;
    }

  *tfnump = -1;
  return NULL;
}

#endif

#ifndef IN_PROCESS_AGENT

/* Clear all past trace state.  */

static void
cmd_qtinit (char *packet)
{
  struct trace_state_variable *tsv, *prev, *next;

  /* Make sure we don't try to read from a trace frame.  */
  current_traceframe = -1;

  stop_tracing ();

  trace_debug ("Initializing the trace");

  clear_installed_tracepoints ();
  clear_readonly_regions ();

  tracepoints = NULL;
  last_tracepoint = NULL;

  /* Clear out any leftover trace state variables.  Ones with target
     defined getters should be kept however.  */
  prev = NULL;
  tsv = trace_state_variables;
  while (tsv)
    {
      trace_debug ("Looking at var %d", tsv->number);
      if (tsv->getter == NULL)
	{
	  next = tsv->next;
	  if (prev)
	    prev->next = next;
	  else
	    trace_state_variables = next;
	  trace_debug ("Deleting var %d", tsv->number);
	  free (tsv);
	  tsv = next;
	}
      else
	{
	  prev = tsv;
	  tsv = tsv->next;
	}
    }

  clear_trace_buffer ();
  clear_inferior_trace_buffer ();

  write_ok (packet);
}

/* Unprobe the UST marker at ADDRESS.  */

static void
unprobe_marker_at (CORE_ADDR address)
{
  char cmd[IPA_CMD_BUF_SIZE];

  sprintf (cmd, "unprobe_marker_at:%s", paddress (address));
  run_inferior_command (cmd, strlen (cmd) + 1);
}

/* Restore the program to its pre-tracing state.  This routine may be called
   in error situations, so it needs to be careful about only restoring
   from known-valid bits.  */

static void
clear_installed_tracepoints (void)
{
  struct tracepoint *tpoint;
  struct tracepoint *prev_stpoint;

  pause_all (1);
  cancel_breakpoints ();

  prev_stpoint = NULL;

  /* Restore any bytes overwritten by tracepoints.  */
  for (tpoint = tracepoints; tpoint; tpoint = tpoint->next)
    {
      /* Catch the case where we might try to remove a tracepoint that
	 was never actually installed.  */
      if (tpoint->handle == NULL)
	{
	  trace_debug ("Tracepoint %d at 0x%s was "
		       "never installed, nothing to clear",
		       tpoint->number, paddress (tpoint->address));
	  continue;
	}

      switch (tpoint->type)
	{
	case trap_tracepoint:
	  delete_breakpoint (tpoint->handle);
	  break;
	case fast_tracepoint:
	  delete_fast_tracepoint_jump (tpoint->handle);
	  break;
	case static_tracepoint:
	  if (prev_stpoint != NULL
	      && prev_stpoint->address == tpoint->address)
	    /* Nothing to do.  We already unprobed a tracepoint set at
	       this marker address (and there can only be one probe
	       per marker).  */
	    ;
	  else
	    {
	      unprobe_marker_at (tpoint->address);
	      prev_stpoint = tpoint;
	    }
	  break;
	}

      tpoint->handle = NULL;
    }

  unpause_all (1);
}

/* Parse a packet that defines a tracepoint.  */

static void
cmd_qtdp (char *own_buf)
{
  int tppacket;
  /* Whether there is a trailing hyphen at the end of the QTDP packet.  */
  int trail_hyphen = 0;
  ULONGEST num;
  ULONGEST addr;
  ULONGEST count;
  struct tracepoint *tpoint;
  char *actparm;
  char *packet = own_buf;

  packet += strlen ("QTDP:");

  /* A hyphen at the beginning marks a packet specifying actions for a
     tracepoint already supplied.  */
  tppacket = 1;
  if (*packet == '-')
    {
      tppacket = 0;
      ++packet;
    }
  packet = unpack_varlen_hex (packet, &num);
  ++packet; /* skip a colon */
  packet = unpack_varlen_hex (packet, &addr);
  ++packet; /* skip a colon */

  /* See if we already have this tracepoint.  */
  tpoint = find_tracepoint (num, addr);

  if (tppacket)
    {
      /* Duplicate tracepoints are never allowed.  */
      if (tpoint)
	{
	  trace_debug ("Tracepoint error: tracepoint %d"
		       " at 0x%s already exists",
		       (int) num, paddress (addr));
	  write_enn (own_buf);
	  return;
	}

      tpoint = add_tracepoint (num, addr);

      tpoint->enabled = (*packet == 'E');
      ++packet; /* skip 'E' */
      ++packet; /* skip a colon */
      packet = unpack_varlen_hex (packet, &count);
      tpoint->step_count = count;
      ++packet; /* skip a colon */
      packet = unpack_varlen_hex (packet, &count);
      tpoint->pass_count = count;
      /* See if we have any of the additional optional fields.  */
      while (*packet == ':')
	{
	  ++packet;
	  if (*packet == 'F')
	    {
	      tpoint->type = fast_tracepoint;
	      ++packet;
	      packet = unpack_varlen_hex (packet, &count);
	      tpoint->orig_size = count;
	    }
	  else if (*packet == 'S')
	    {
	      tpoint->type = static_tracepoint;
	      ++packet;
	    }
	  else if (*packet == 'X')
	    {
	      actparm = (char *) packet;
	      tpoint->cond = gdb_parse_agent_expr (&actparm);
	      packet = actparm;
	    }
	  else if (*packet == '-')
	    break;
	  else if (*packet == '\0')
	    break;
	  else
	    trace_debug ("Unknown optional tracepoint field");
	}
      if (*packet == '-')
	{
	  trail_hyphen = 1;
	  trace_debug ("Also has actions\n");
	}

      trace_debug ("Defined %stracepoint %d at 0x%s, "
		   "enabled %d step %" PRIu64 " pass %" PRIu64,
		   tpoint->type == fast_tracepoint ? "fast "
		   : tpoint->type == static_tracepoint ? "static " : "",
		   tpoint->number, paddress (tpoint->address), tpoint->enabled,
		   tpoint->step_count, tpoint->pass_count);
    }
  else if (tpoint)
    add_tracepoint_action (tpoint, packet);
  else
    {
      trace_debug ("Tracepoint error: tracepoint %d at 0x%s not found",
		   (int) num, paddress (addr));
      write_enn (own_buf);
      return;
    }

  /* Install tracepoint during tracing only once for each tracepoint location.
     For each tracepoint loc, GDB may send multiple QTDP packets, and we can
     determine the last QTDP packet for one tracepoint location by checking
     trailing hyphen in QTDP packet.  */
  if (tracing && !trail_hyphen)
    {
      struct tracepoint *tp = NULL;

      /* Pause all threads temporarily while we patch tracepoints.  */
      pause_all (0);

      /* download_tracepoint will update global `tracepoints'
	 list, so it is unsafe to leave threads in jump pad.  */
      stabilize_threads ();

      /* Freeze threads.  */
      pause_all (1);


      if (tpoint->type != trap_tracepoint)
	{
	  /* Find another fast or static tracepoint at the same address.  */
	  for (tp = tracepoints; tp; tp = tp->next)
	    {
	      if (tp->address == tpoint->address && tp->type == tpoint->type
		  && tp->number != tpoint->number)
		break;
	    }

	  /* TPOINT is installed at the same address as TP.  */
	  if (tp)
	    {
	      if (tpoint->type == fast_tracepoint)
		clone_fast_tracepoint (tpoint, tp);
	      else if (tpoint->type == static_tracepoint)
		tpoint->handle = (void *) -1;
	    }
	}

      if (use_agent && tpoint->type == fast_tracepoint
	  && agent_capability_check (AGENT_CAPA_FAST_TRACE))
	{
	  /* Download and install fast tracepoint by agent.  */
	  if (tracepoint_send_agent (tpoint) == 0)
	    write_ok (own_buf);
	  else
	    {
	      write_enn (own_buf);
	      remove_tracepoint (tpoint);
	    }
	}
      else
	{
	  download_tracepoint (tpoint);

	  if (tpoint->type == trap_tracepoint || tp == NULL)
	    {
	      install_tracepoint (tpoint, own_buf);
	      if (strcmp (own_buf, "OK") != 0)
		remove_tracepoint (tpoint);
	    }
	  else
	    write_ok (own_buf);
	}

      unpause_all (1);
      return;
    }

  write_ok (own_buf);
}

static void
cmd_qtdpsrc (char *own_buf)
{
  ULONGEST num, addr, start, slen;
  struct tracepoint *tpoint;
  char *packet = own_buf;
  char *saved, *srctype, *src;
  size_t nbytes;
  struct source_string *last, *newlast;

  packet += strlen ("QTDPsrc:");

  packet = unpack_varlen_hex (packet, &num);
  ++packet; /* skip a colon */
  packet = unpack_varlen_hex (packet, &addr);
  ++packet; /* skip a colon */

  /* See if we already have this tracepoint.  */
  tpoint = find_tracepoint (num, addr);

  if (!tpoint)
    {
      trace_debug ("Tracepoint error: tracepoint %d at 0x%s not found",
		   (int) num, paddress (addr));
      write_enn (own_buf);
      return;
    }

  saved = packet;
  packet = strchr (packet, ':');
  srctype = xmalloc (packet - saved + 1);
  memcpy (srctype, saved, packet - saved);
  srctype[packet - saved] = '\0';
  ++packet;
  packet = unpack_varlen_hex (packet, &start);
  ++packet; /* skip a colon */
  packet = unpack_varlen_hex (packet, &slen);
  ++packet; /* skip a colon */
  src = xmalloc (slen + 1);
  nbytes = unhexify (src, packet, strlen (packet) / 2);
  src[nbytes] = '\0';

  newlast = xmalloc (sizeof (struct source_string));
  newlast->type = srctype;
  newlast->str = src;
  newlast->next = NULL;
  /* Always add a source string to the end of the list;
     this keeps sequences of actions/commands in the right
     order.  */
  if (tpoint->source_strings)
    {
      for (last = tpoint->source_strings; last->next; last = last->next)
	;
      last->next = newlast;
    }
  else
    tpoint->source_strings = newlast;

  write_ok (own_buf);
}

static void
cmd_qtdv (char *own_buf)
{
  ULONGEST num, val, builtin;
  char *varname;
  size_t nbytes;
  struct trace_state_variable *tsv;
  char *packet = own_buf;

  packet += strlen ("QTDV:");

  packet = unpack_varlen_hex (packet, &num);
  ++packet; /* skip a colon */
  packet = unpack_varlen_hex (packet, &val);
  ++packet; /* skip a colon */
  packet = unpack_varlen_hex (packet, &builtin);
  ++packet; /* skip a colon */

  nbytes = strlen (packet) / 2;
  varname = xmalloc (nbytes + 1);
  nbytes = unhexify (varname, packet, nbytes);
  varname[nbytes] = '\0';

  tsv = create_trace_state_variable (num, 1);
  tsv->initial_value = (LONGEST) val;
  tsv->name = varname;

  set_trace_state_variable_value (num, (LONGEST) val);

  write_ok (own_buf);
}

static void
cmd_qtenable_disable (char *own_buf, int enable)
{
  char *packet = own_buf;
  ULONGEST num, addr;
  struct tracepoint *tp;

  packet += strlen (enable ? "QTEnable:" : "QTDisable:");
  packet = unpack_varlen_hex (packet, &num);
  ++packet; /* skip a colon */
  packet = unpack_varlen_hex (packet, &addr);

  tp = find_tracepoint (num, addr);

  if (tp)
    {
      if ((enable && tp->enabled) || (!enable && !tp->enabled))
	{
	  trace_debug ("Tracepoint %d at 0x%s is already %s",
		       (int) num, paddress (addr),
		       enable ? "enabled" : "disabled");
	  write_ok (own_buf);
	  return;
	}

      trace_debug ("%s tracepoint %d at 0x%s",
		   enable ? "Enabling" : "Disabling",
		   (int) num, paddress (addr));

      tp->enabled = enable;

      if (tp->type == fast_tracepoint || tp->type == static_tracepoint)
	{
	  int ret;
	  int offset = offsetof (struct tracepoint, enabled);
	  CORE_ADDR obj_addr = tp->obj_addr_on_target + offset;

	  ret = prepare_to_access_memory ();
	  if (ret)
	    {
	      trace_debug ("Failed to temporarily stop inferior threads");
	      write_enn (own_buf);
	      return;
	    }
	  
	  ret = write_inferior_integer (obj_addr, enable);
	  done_accessing_memory ();
	  
	  if (ret)
	    {
	      trace_debug ("Cannot write enabled flag into "
			   "inferior process memory");
	      write_enn (own_buf);
	      return;
	    }
	}

      write_ok (own_buf);
    }
  else
    {
      trace_debug ("Tracepoint %d at 0x%s not found",
		   (int) num, paddress (addr));
      write_enn (own_buf);
    }
}

static void
cmd_qtv (char *own_buf)
{
  ULONGEST num;
  LONGEST val = 0;
  int err;
  char *packet = own_buf;

  packet += strlen ("qTV:");
  unpack_varlen_hex (packet, &num);

  if (current_traceframe >= 0)
    {
      err = traceframe_read_tsv ((int) num, &val);
      if (err)
	{
	  strcpy (own_buf, "U");
	  return;
	}
    }
  /* Only make tsv's be undefined before the first trace run.  After a
     trace run is over, the user might want to see the last value of
     the tsv, and it might not be available in a traceframe.  */
  else if (!tracing && strcmp (tracing_stop_reason, "tnotrun") == 0)
    {
      strcpy (own_buf, "U");
      return;
    }
  else
    val = get_trace_state_variable_value (num);

  sprintf (own_buf, "V%s", phex_nz (val, 0));
}

/* Clear out the list of readonly regions.  */

static void
clear_readonly_regions (void)
{
  struct readonly_region *roreg;

  while (readonly_regions)
    {
      roreg = readonly_regions;
      readonly_regions = readonly_regions->next;
      free (roreg);
    }
}

/* Parse the collection of address ranges whose contents GDB believes
   to be unchanging and so can be read directly from target memory
   even while looking at a traceframe.  */

static void
cmd_qtro (char *own_buf)
{
  ULONGEST start, end;
  struct readonly_region *roreg;
  char *packet = own_buf;

  trace_debug ("Want to mark readonly regions");

  clear_readonly_regions ();

  packet += strlen ("QTro");

  while (*packet == ':')
    {
      ++packet;  /* skip a colon */
      packet = unpack_varlen_hex (packet, &start);
      ++packet;  /* skip a comma */
      packet = unpack_varlen_hex (packet, &end);
      roreg = xmalloc (sizeof (struct readonly_region));
      roreg->start = start;
      roreg->end = end;
      roreg->next = readonly_regions;
      readonly_regions = roreg;
      trace_debug ("Added readonly region from 0x%s to 0x%s",
		   paddress (roreg->start), paddress (roreg->end));
    }

  write_ok (own_buf);
}

/* Test to see if the given range is in our list of readonly ranges.
   We only test for being entirely within a range, GDB is not going to
   send a single memory packet that spans multiple regions.  */

int
in_readonly_region (CORE_ADDR addr, ULONGEST length)
{
  struct readonly_region *roreg;

  for (roreg = readonly_regions; roreg; roreg = roreg->next)
    if (roreg->start <= addr && (addr + length - 1) <= roreg->end)
      return 1;

  return 0;
}

/* The maximum size of a jump pad entry.  */
static const int max_jump_pad_size = 0x100;

static CORE_ADDR gdb_jump_pad_head;

/* Return the address of the next free jump space.  */

static CORE_ADDR
get_jump_space_head (void)
{
  if (gdb_jump_pad_head == 0)
    {
      if (read_inferior_data_pointer (ipa_sym_addrs.addr_gdb_jump_pad_buffer,
				      &gdb_jump_pad_head))
	fatal ("error extracting jump_pad_buffer");
    }

  return gdb_jump_pad_head;
}

/* Reserve USED bytes from the jump space.  */

static void
claim_jump_space (ULONGEST used)
{
  trace_debug ("claim_jump_space reserves %s bytes at %s",
	       pulongest (used), paddress (gdb_jump_pad_head));
  gdb_jump_pad_head += used;
}

static CORE_ADDR trampoline_buffer_head = 0;
static CORE_ADDR trampoline_buffer_tail;

/* Reserve USED bytes from the trampoline buffer and return the
   address of the start of the reserved space in TRAMPOLINE.  Returns
   non-zero if the space is successfully claimed.  */

int
claim_trampoline_space (ULONGEST used, CORE_ADDR *trampoline)
{
  if (!trampoline_buffer_head)
    {
      if (read_inferior_data_pointer (ipa_sym_addrs.addr_gdb_trampoline_buffer,
				      &trampoline_buffer_tail))
	{
	  fatal ("error extracting trampoline_buffer");
	  return 0;
	}

      if (read_inferior_data_pointer (ipa_sym_addrs.addr_gdb_trampoline_buffer_end,
				      &trampoline_buffer_head))
	{
	  fatal ("error extracting trampoline_buffer_end");
	  return 0;
	}
    }

  /* Start claiming space from the top of the trampoline space.  If
     the space is located at the bottom of the virtual address space,
     this reduces the possibility that corruption will occur if a null
     pointer is used to write to memory.  */
  if (trampoline_buffer_head - trampoline_buffer_tail < used)
    {
      trace_debug ("claim_trampoline_space failed to reserve %s bytes",
		   pulongest (used));
      return 0;
    }

  trampoline_buffer_head -= used;

  trace_debug ("claim_trampoline_space reserves %s bytes at %s",
	       pulongest (used), paddress (trampoline_buffer_head));

  *trampoline = trampoline_buffer_head;
  return 1;
}

/* Returns non-zero if there is space allocated for use in trampolines
   for fast tracepoints.  */

int
have_fast_tracepoint_trampoline_buffer (char *buf)
{
  CORE_ADDR trampoline_end, errbuf;

  if (read_inferior_data_pointer (ipa_sym_addrs.addr_gdb_trampoline_buffer_end,
				  &trampoline_end))
    {
      fatal ("error extracting trampoline_buffer_end");
      return 0;
    }
  
  if (buf)
    {
      buf[0] = '\0';
      strcpy (buf, "was claiming");
      if (read_inferior_data_pointer (ipa_sym_addrs.addr_gdb_trampoline_buffer_error,
				  &errbuf))
	{
	  fatal ("error extracting errbuf");
	  return 0;
	}

      read_inferior_memory (errbuf, (unsigned char *) buf, 100);
    }

  return trampoline_end != 0;
}

/* Ask the IPA to probe the marker at ADDRESS.  Returns -1 if running
   the command fails, or 0 otherwise.  If the command ran
   successfully, but probing the marker failed, ERROUT will be filled
   with the error to reply to GDB, and -1 is also returned.  This
   allows directly passing IPA errors to GDB.  */

static int
probe_marker_at (CORE_ADDR address, char *errout)
{
  char cmd[IPA_CMD_BUF_SIZE];
  int err;

  sprintf (cmd, "probe_marker_at:%s", paddress (address));
  err = run_inferior_command (cmd, strlen (cmd) + 1);

  if (err == 0)
    {
      if (*cmd == 'E')
	{
	  strcpy (errout, cmd);
	  return -1;
	}
    }

  return err;
}

static void
clone_fast_tracepoint (struct tracepoint *to, const struct tracepoint *from)
{
  to->jump_pad = from->jump_pad;
  to->jump_pad_end = from->jump_pad_end;
  to->trampoline = from->trampoline;
  to->trampoline_end = from->trampoline_end;
  to->adjusted_insn_addr = from->adjusted_insn_addr;
  to->adjusted_insn_addr_end = from->adjusted_insn_addr_end;
  to->handle = from->handle;

  gdb_assert (from->handle);
  inc_ref_fast_tracepoint_jump ((struct fast_tracepoint_jump *) from->handle);
}

#define MAX_JUMP_SIZE 20

/* Install fast tracepoint.  Return 0 if successful, otherwise return
   non-zero.  */

static int
install_fast_tracepoint (struct tracepoint *tpoint, char *errbuf)
{
  CORE_ADDR jentry, jump_entry;
  CORE_ADDR trampoline;
  ULONGEST trampoline_size;
  int err = 0;
  /* The jump to the jump pad of the last fast tracepoint
     installed.  */
  unsigned char fjump[MAX_JUMP_SIZE];
  ULONGEST fjump_size;

  if (tpoint->orig_size < target_get_min_fast_tracepoint_insn_len ())
    {
      trace_debug ("Requested a fast tracepoint on an instruction "
		   "that is of less than the minimum length.");
      return 0;
    }

  jentry = jump_entry = get_jump_space_head ();

  trampoline = 0;
  trampoline_size = 0;

  /* Install the jump pad.  */
  err = install_fast_tracepoint_jump_pad (tpoint->obj_addr_on_target,
					  tpoint->address,
					  ipa_sym_addrs.addr_gdb_collect,
					  ipa_sym_addrs.addr_collecting,
					  tpoint->orig_size,
					  &jentry,
					  &trampoline, &trampoline_size,
					  fjump, &fjump_size,
					  &tpoint->adjusted_insn_addr,
					  &tpoint->adjusted_insn_addr_end,
					  errbuf);

  if (err)
    return 1;

  /* Wire it in.  */
  tpoint->handle = set_fast_tracepoint_jump (tpoint->address, fjump,
					     fjump_size);

  if (tpoint->handle != NULL)
    {
      tpoint->jump_pad = jump_entry;
      tpoint->jump_pad_end = jentry;
      tpoint->trampoline = trampoline;
      tpoint->trampoline_end = trampoline + trampoline_size;

      /* Pad to 8-byte alignment.  */
      jentry = ((jentry + 7) & ~0x7);
      claim_jump_space (jentry - jump_entry);
    }

  return 0;
}


/* Install tracepoint TPOINT, and write reply message in OWN_BUF.  */

static void
install_tracepoint (struct tracepoint *tpoint, char *own_buf)
{
  tpoint->handle = NULL;
  *own_buf = '\0';

  if (tpoint->type == trap_tracepoint)
    {
      /* Tracepoints are installed as memory breakpoints.  Just go
	 ahead and install the trap.  The breakpoints module
	 handles duplicated breakpoints, and the memory read
	 routine handles un-patching traps from memory reads.  */
      tpoint->handle = set_breakpoint_at (tpoint->address,
					  tracepoint_handler);
    }
  else if (tpoint->type == fast_tracepoint || tpoint->type == static_tracepoint)
    {
      if (!agent_loaded_p ())
	{
	  trace_debug ("Requested a %s tracepoint, but fast "
		       "tracepoints aren't supported.",
		       tpoint->type == static_tracepoint ? "static" : "fast");
	  write_e_ipa_not_loaded (own_buf);
	  return;
	}
      if (tpoint->type == static_tracepoint
	  && !in_process_agent_supports_ust ())
	{
	  trace_debug ("Requested a static tracepoint, but static "
		       "tracepoints are not supported.");
	  write_e_ust_not_loaded (own_buf);
	  return;
	}

      if (tpoint->type == fast_tracepoint)
	install_fast_tracepoint (tpoint, own_buf);
      else
	{
	  if (probe_marker_at (tpoint->address, own_buf) == 0)
	    tpoint->handle = (void *) -1;
	}

    }
  else
    internal_error (__FILE__, __LINE__, "Unknown tracepoint type");

  if (tpoint->handle == NULL)
    {
      if (*own_buf == '\0')
	write_enn (own_buf);
    }
  else
    write_ok (own_buf);
}

static void download_tracepoint_1 (struct tracepoint *tpoint);

static void
cmd_qtstart (char *packet)
{
  struct tracepoint *tpoint, *prev_ftpoint, *prev_stpoint;
  CORE_ADDR tpptr = 0, prev_tpptr = 0;

  trace_debug ("Starting the trace");

  /* Pause all threads temporarily while we patch tracepoints.  */
  pause_all (0);

  /* Get threads out of jump pads.  Safe to do here, since this is a
     top level command.  And, required to do here, since we're
     deleting/rewriting jump pads.  */

  stabilize_threads ();

  /* Freeze threads.  */
  pause_all (1);

  /* Sync the fast tracepoints list in the inferior ftlib.  */
  if (agent_loaded_p ())
    download_trace_state_variables ();

  /* No previous fast tpoint yet.  */
  prev_ftpoint = NULL;

  /* No previous static tpoint yet.  */
  prev_stpoint = NULL;

  *packet = '\0';

  /* Start out empty.  */
  if (agent_loaded_p ())
    write_inferior_data_ptr (ipa_sym_addrs.addr_tracepoints, 0);

  /* Download and install tracepoints.  */
  for (tpoint = tracepoints; tpoint; tpoint = tpoint->next)
    {
      /* Ensure all the hit counts start at zero.  */
      tpoint->hit_count = 0;
      tpoint->traceframe_usage = 0;

      if (tpoint->type == trap_tracepoint)
	{
	  /* Tracepoints are installed as memory breakpoints.  Just go
	     ahead and install the trap.  The breakpoints module
	     handles duplicated breakpoints, and the memory read
	     routine handles un-patching traps from memory reads.  */
	  tpoint->handle = set_breakpoint_at (tpoint->address,
					      tracepoint_handler);
	}
      else if (tpoint->type == fast_tracepoint
	       || tpoint->type == static_tracepoint)
	{
	  if (maybe_write_ipa_not_loaded (packet))
	    {
	      trace_debug ("Requested a %s tracepoint, but fast "
			   "tracepoints aren't supported.",
			   tpoint->type == static_tracepoint
			   ? "static" : "fast");
	      break;
	    }

	  if (tpoint->type == fast_tracepoint)
	    {
	      int use_agent_p
		= use_agent && agent_capability_check (AGENT_CAPA_FAST_TRACE);

	      if (prev_ftpoint != NULL
		  && prev_ftpoint->address == tpoint->address)
		{
		  if (use_agent_p)
		    tracepoint_send_agent (tpoint);
		  else
		    download_tracepoint_1 (tpoint);

		  clone_fast_tracepoint (tpoint, prev_ftpoint);
		}
	      else
		{
		  /* Tracepoint is installed successfully?  */
		  int installed = 0;

		  /* Download and install fast tracepoint by agent.  */
		  if (use_agent_p)
		    installed = !tracepoint_send_agent (tpoint);
		  else
		    {
		      download_tracepoint_1 (tpoint);
		      installed = !install_fast_tracepoint (tpoint, packet);
		    }

		  if (installed)
		    prev_ftpoint = tpoint;
		}
	    }
	  else
	    {
	      if (!in_process_agent_supports_ust ())
		{
		  trace_debug ("Requested a static tracepoint, but static "
			       "tracepoints are not supported.");
		  break;
		}

	      download_tracepoint_1 (tpoint);
	      /* Can only probe a given marker once.  */
	      if (prev_stpoint != NULL
		  && prev_stpoint->address == tpoint->address)
		tpoint->handle = (void *) -1;
	      else
		{
		  if (probe_marker_at (tpoint->address, packet) == 0)
		    {
		      tpoint->handle = (void *) -1;

		      /* So that we can handle multiple static tracepoints
			 at the same address easily.  */
		      prev_stpoint = tpoint;
		    }
		}
	    }

	  prev_tpptr = tpptr;
	  tpptr = tpoint->obj_addr_on_target;

	  if (tpoint == tracepoints)
	    /* First object in list, set the head pointer in the
	       inferior.  */
	    write_inferior_data_ptr (ipa_sym_addrs.addr_tracepoints, tpptr);
	  else
	    write_inferior_data_ptr (prev_tpptr + offsetof (struct tracepoint,
							    next),
				     tpptr);
	}

      /* Any failure in the inner loop is sufficient cause to give
	 up.  */
      if (tpoint->handle == NULL)
	break;
    }

  /* Any error in tracepoint insertion is unacceptable; better to
     address the problem now, than end up with a useless or misleading
     trace run.  */
  if (tpoint != NULL)
    {
      clear_installed_tracepoints ();
      if (*packet == '\0')
	write_enn (packet);
      unpause_all (1);
      return;
    }

  stopping_tracepoint = NULL;
  trace_buffer_is_full = 0;
  expr_eval_result = expr_eval_no_error;
  error_tracepoint = NULL;
  tracing_start_time = get_timestamp ();

  /* Tracing is now active, hits will now start being logged.  */
  tracing = 1;

  if (agent_loaded_p ())
    {
      if (write_inferior_integer (ipa_sym_addrs.addr_tracing, 1))
	fatal ("Error setting tracing variable in lib");

      if (write_inferior_data_pointer (ipa_sym_addrs.addr_stopping_tracepoint,
				       0))
	fatal ("Error clearing stopping_tracepoint variable in lib");

      if (write_inferior_integer (ipa_sym_addrs.addr_trace_buffer_is_full, 0))
	fatal ("Error clearing trace_buffer_is_full variable in lib");

      stop_tracing_bkpt = set_breakpoint_at (ipa_sym_addrs.addr_stop_tracing,
					     stop_tracing_handler);
      if (stop_tracing_bkpt == NULL)
	error ("Error setting stop_tracing breakpoint");

      flush_trace_buffer_bkpt
	= set_breakpoint_at (ipa_sym_addrs.addr_flush_trace_buffer,
			     flush_trace_buffer_handler);
      if (flush_trace_buffer_bkpt == NULL)
	error ("Error setting flush_trace_buffer breakpoint");
    }

  unpause_all (1);

  write_ok (packet);
}

/* End a tracing run, filling in a stop reason to report back to GDB,
   and removing the tracepoints from the code.  */

void
stop_tracing (void)
{
  if (!tracing)
    {
      trace_debug ("Tracing is already off, ignoring");
      return;
    }

  trace_debug ("Stopping the trace");

  /* Pause all threads before removing fast jumps from memory,
     breakpoints, and touching IPA state variables (inferior memory).
     Some thread may hit the internal tracing breakpoints, or be
     collecting this moment, but that's ok, we don't release the
     tpoint object's memory or the jump pads here (we only do that
     when we're sure we can move all threads out of the jump pads).
     We can't now, since we may be getting here due to the inferior
     agent calling us.  */
  pause_all (1);
  /* Since we're removing breakpoints, cancel breakpoint hits,
     possibly related to the breakpoints we're about to delete.  */
  cancel_breakpoints ();

  /* Stop logging. Tracepoints can still be hit, but they will not be
     recorded.  */
  tracing = 0;
  if (agent_loaded_p ())
    {
      if (write_inferior_integer (ipa_sym_addrs.addr_tracing, 0))
	fatal ("Error clearing tracing variable in lib");
    }

  tracing_stop_time = get_timestamp ();
  tracing_stop_reason = "t???";
  tracing_stop_tpnum = 0;
  if (stopping_tracepoint)
    {
      trace_debug ("Stopping the trace because "
		   "tracepoint %d was hit %" PRIu64 " times",
		   stopping_tracepoint->number,
		   stopping_tracepoint->pass_count);
      tracing_stop_reason = "tpasscount";
      tracing_stop_tpnum = stopping_tracepoint->number;
    }
  else if (trace_buffer_is_full)
    {
      trace_debug ("Stopping the trace because the trace buffer is full");
      tracing_stop_reason = "tfull";
    }
  else if (expr_eval_result != expr_eval_no_error)
    {
      trace_debug ("Stopping the trace because of an expression eval error");
      tracing_stop_reason = eval_result_names[expr_eval_result];
      tracing_stop_tpnum = error_tracepoint->number;
    }
#ifndef IN_PROCESS_AGENT
  else if (!gdb_connected ())
    {
      trace_debug ("Stopping the trace because GDB disconnected");
      tracing_stop_reason = "tdisconnected";
    }
#endif
  else
    {
      trace_debug ("Stopping the trace because of a tstop command");
      tracing_stop_reason = "tstop";
    }

  stopping_tracepoint = NULL;
  error_tracepoint = NULL;

  /* Clear out the tracepoints.  */
  clear_installed_tracepoints ();

  if (agent_loaded_p ())
    {
      /* Pull in fast tracepoint trace frames from the inferior lib
	 buffer into our buffer, even if our buffer is already full,
	 because we want to present the full number of created frames
	 in addition to what fit in the trace buffer.  */
      upload_fast_traceframes ();
    }

  if (stop_tracing_bkpt != NULL)
    {
      delete_breakpoint (stop_tracing_bkpt);
      stop_tracing_bkpt = NULL;
    }

  if (flush_trace_buffer_bkpt != NULL)
    {
      delete_breakpoint (flush_trace_buffer_bkpt);
      flush_trace_buffer_bkpt = NULL;
    }

  unpause_all (1);
}

static int
stop_tracing_handler (CORE_ADDR addr)
{
  trace_debug ("lib hit stop_tracing");

  /* Don't actually handle it here.  When we stop tracing we remove
     breakpoints from the inferior, and that is not allowed in a
     breakpoint handler (as the caller is walking the breakpoint
     list).  */
  return 0;
}

static int
flush_trace_buffer_handler (CORE_ADDR addr)
{
  trace_debug ("lib hit flush_trace_buffer");
  return 0;
}

static void
cmd_qtstop (char *packet)
{
  stop_tracing ();
  write_ok (packet);
}

static void
cmd_qtdisconnected (char *own_buf)
{
  ULONGEST setting;
  char *packet = own_buf;

  packet += strlen ("QTDisconnected:");

  unpack_varlen_hex (packet, &setting);

  write_ok (own_buf);

  disconnected_tracing = setting;
}

static void
cmd_qtframe (char *own_buf)
{
  ULONGEST frame, pc, lo, hi, num;
  int tfnum, tpnum;
  struct traceframe *tframe;
  char *packet = own_buf;

  packet += strlen ("QTFrame:");

  if (strncmp (packet, "pc:", strlen ("pc:")) == 0)
    {
      packet += strlen ("pc:");
      unpack_varlen_hex (packet, &pc);
      trace_debug ("Want to find next traceframe at pc=0x%s", paddress (pc));
      tframe = find_next_traceframe_in_range (pc, pc, 1, &tfnum);
    }
  else if (strncmp (packet, "range:", strlen ("range:")) == 0)
    {
      packet += strlen ("range:");
      packet = unpack_varlen_hex (packet, &lo);
      ++packet;
      unpack_varlen_hex (packet, &hi);
      trace_debug ("Want to find next traceframe in the range 0x%s to 0x%s",
		   paddress (lo), paddress (hi));
      tframe = find_next_traceframe_in_range (lo, hi, 1, &tfnum);
    }
  else if (strncmp (packet, "outside:", strlen ("outside:")) == 0)
    {
      packet += strlen ("outside:");
      packet = unpack_varlen_hex (packet, &lo);
      ++packet;
      unpack_varlen_hex (packet, &hi);
      trace_debug ("Want to find next traceframe "
		   "outside the range 0x%s to 0x%s",
		   paddress (lo), paddress (hi));
      tframe = find_next_traceframe_in_range (lo, hi, 0, &tfnum);
    }
  else if (strncmp (packet, "tdp:", strlen ("tdp:")) == 0)
    {
      packet += strlen ("tdp:");
      unpack_varlen_hex (packet, &num);
      tpnum = (int) num;
      trace_debug ("Want to find next traceframe for tracepoint %d", tpnum);
      tframe = find_next_traceframe_by_tracepoint (tpnum, &tfnum);
    }
  else
    {
      unpack_varlen_hex (packet, &frame);
      tfnum = (int) frame;
      if (tfnum == -1)
	{
	  trace_debug ("Want to stop looking at traceframes");
	  current_traceframe = -1;
	  write_ok (own_buf);
	  return;
	}
      trace_debug ("Want to look at traceframe %d", tfnum);
      tframe = find_traceframe (tfnum);
    }

  if (tframe)
    {
      current_traceframe = tfnum;
      sprintf (own_buf, "F%xT%x", tfnum, tframe->tpnum);
    }
  else
    sprintf (own_buf, "F-1");
}

static void
cmd_qtstatus (char *packet)
{
  char *stop_reason_rsp = NULL;
  char *buf1, *buf2, *buf3, *str;
  int slen;

  /* Translate the plain text of the notes back into hex for
     transmission.  */

  str = (tracing_user_name ? tracing_user_name : "");
  slen = strlen (str);
  buf1 = (char *) alloca (slen * 2 + 1);
  hexify (buf1, str, slen);

  str = (tracing_notes ? tracing_notes : "");
  slen = strlen (str);
  buf2 = (char *) alloca (slen * 2 + 1);
  hexify (buf2, str, slen);

  str = (tracing_stop_note ? tracing_stop_note : "");
  slen = strlen (str);
  buf3 = (char *) alloca (slen * 2 + 1);
  hexify (buf3, str, slen);

  trace_debug ("Returning trace status as %d, stop reason %s",
	       tracing, tracing_stop_reason);

  if (agent_loaded_p ())
    {
      pause_all (1);

      upload_fast_traceframes ();

      unpause_all (1);
   }

  stop_reason_rsp = (char *) tracing_stop_reason;

  /* The user visible error string in terror needs to be hex encoded.
     We leave it as plain string in `tracing_stop_reason' to ease
     debugging.  */
  if (strncmp (stop_reason_rsp, "terror:", strlen ("terror:")) == 0)
    {
      const char *result_name;
      int hexstr_len;
      char *p;

      result_name = stop_reason_rsp + strlen ("terror:");
      hexstr_len = strlen (result_name) * 2;
      p = stop_reason_rsp = alloca (strlen ("terror:") + hexstr_len + 1);
      strcpy (p, "terror:");
      p += strlen (p);
      convert_int_to_ascii ((gdb_byte *) result_name, p, strlen (result_name));
    }

  /* If this was a forced stop, include any stop note that was supplied.  */
  if (strcmp (stop_reason_rsp, "tstop") == 0)
    {
      stop_reason_rsp = alloca (strlen ("tstop:") + strlen (buf3) + 1);
      strcpy (stop_reason_rsp, "tstop:");
      strcat (stop_reason_rsp, buf3);
    }

  sprintf (packet,
	   "T%d;"
	   "%s:%x;"
	   "tframes:%x;tcreated:%x;"
	   "tfree:%x;tsize:%s;"
	   "circular:%d;"
	   "disconn:%d;"
	   "starttime:%s;stoptime:%s;"
	   "username:%s;notes:%s:",
	   tracing ? 1 : 0,
	   stop_reason_rsp, tracing_stop_tpnum,
	   traceframe_count, traceframes_created,
	   free_space (), phex_nz (trace_buffer_hi - trace_buffer_lo, 0),
	   circular_trace_buffer,
	   disconnected_tracing,
	   phex_nz (tracing_start_time, sizeof (tracing_start_time)),
	   phex_nz (tracing_stop_time, sizeof (tracing_stop_time)),
	   buf1, buf2);
}

static void
cmd_qtp (char *own_buf)
{
  ULONGEST num, addr;
  struct tracepoint *tpoint;
  char *packet = own_buf;

  packet += strlen ("qTP:");

  packet = unpack_varlen_hex (packet, &num);
  ++packet; /* skip a colon */
  packet = unpack_varlen_hex (packet, &addr);

  /* See if we already have this tracepoint.  */
  tpoint = find_tracepoint (num, addr);

  if (!tpoint)
    {
      trace_debug ("Tracepoint error: tracepoint %d at 0x%s not found",
		   (int) num, paddress (addr));
      write_enn (own_buf);
      return;
    }

  sprintf (own_buf, "V%" PRIu64 ":%" PRIu64 "", tpoint->hit_count,
	   tpoint->traceframe_usage);
}

/* State variables to help return all the tracepoint bits.  */
static struct tracepoint *cur_tpoint;
static unsigned int cur_action;
static unsigned int cur_step_action;
static struct source_string *cur_source_string;
static struct trace_state_variable *cur_tsv;

/* Compose a response that is an imitation of the syntax by which the
   tracepoint was originally downloaded.  */

static void
response_tracepoint (char *packet, struct tracepoint *tpoint)
{
  char *buf;

  sprintf (packet, "T%x:%s:%c:%" PRIx64 ":%" PRIx64, tpoint->number,
	   paddress (tpoint->address),
	   (tpoint->enabled ? 'E' : 'D'), tpoint->step_count,
	   tpoint->pass_count);
  if (tpoint->type == fast_tracepoint)
    sprintf (packet + strlen (packet), ":F%x", tpoint->orig_size);
  else if (tpoint->type == static_tracepoint)
    sprintf (packet + strlen (packet), ":S");

  if (tpoint->cond)
    {
      buf = gdb_unparse_agent_expr (tpoint->cond);
      sprintf (packet + strlen (packet), ":X%x,%s",
	       tpoint->cond->length, buf);
      free (buf);
    }
}

/* Compose a response that is an imitation of the syntax by which the
   tracepoint action was originally downloaded (with the difference
   that due to the way we store the actions, this will output a packet
   per action, while GDB could have combined more than one action
   per-packet.  */

static void
response_action (char *packet, struct tracepoint *tpoint,
		 char *taction, int step)
{
  sprintf (packet, "%c%x:%s:%s",
	   (step ? 'S' : 'A'), tpoint->number, paddress (tpoint->address),
	   taction);
}

/* Compose a response that is an imitation of the syntax by which the
   tracepoint source piece was originally downloaded.  */

static void
response_source (char *packet,
		 struct tracepoint *tpoint, struct source_string *src)
{
  char *buf;
  int len;

  len = strlen (src->str);
  buf = alloca (len * 2 + 1);
  convert_int_to_ascii ((gdb_byte *) src->str, buf, len);

  sprintf (packet, "Z%x:%s:%s:%x:%x:%s",
	   tpoint->number, paddress (tpoint->address),
	   src->type, 0, len, buf);
}

/* Return the first piece of tracepoint definition, and initialize the
   state machine that will iterate through all the tracepoint
   bits.  */

static void
cmd_qtfp (char *packet)
{
  trace_debug ("Returning first tracepoint definition piece");

  cur_tpoint = tracepoints;
  cur_action = cur_step_action = 0;
  cur_source_string = NULL;

  if (cur_tpoint)
    response_tracepoint (packet, cur_tpoint);
  else
    strcpy (packet, "l");
}

/* Return additional pieces of tracepoint definition.  Each action and
   stepping action must go into its own packet, because of packet size
   limits, and so we use state variables to deliver one piece at a
   time.  */

static void
cmd_qtsp (char *packet)
{
  trace_debug ("Returning subsequent tracepoint definition piece");

  if (!cur_tpoint)
    {
      /* This case would normally never occur, but be prepared for
	 GDB misbehavior.  */
      strcpy (packet, "l");
    }
  else if (cur_action < cur_tpoint->numactions)
    {
      response_action (packet, cur_tpoint,
		       cur_tpoint->actions_str[cur_action], 0);
      ++cur_action;
    }
  else if (cur_step_action < cur_tpoint->num_step_actions)
    {
      response_action (packet, cur_tpoint,
		       cur_tpoint->step_actions_str[cur_step_action], 1);
      ++cur_step_action;
    }
  else if ((cur_source_string
	    ? cur_source_string->next
	    : cur_tpoint->source_strings))
    {
      if (cur_source_string)
	cur_source_string = cur_source_string->next;
      else
	cur_source_string = cur_tpoint->source_strings;
      response_source (packet, cur_tpoint, cur_source_string);
    }
  else
    {
      cur_tpoint = cur_tpoint->next;
      cur_action = cur_step_action = 0;
      cur_source_string = NULL;
      if (cur_tpoint)
	response_tracepoint (packet, cur_tpoint);
      else
	strcpy (packet, "l");
    }
}

/* Compose a response that is an imitation of the syntax by which the
   trace state variable was originally downloaded.  */

static void
response_tsv (char *packet, struct trace_state_variable *tsv)
{
  char *buf = (char *) "";
  int namelen;

  if (tsv->name)
    {
      namelen = strlen (tsv->name);
      buf = alloca (namelen * 2 + 1);
      convert_int_to_ascii ((gdb_byte *) tsv->name, buf, namelen);
    }

  sprintf (packet, "%x:%s:%x:%s", tsv->number, phex_nz (tsv->initial_value, 0),
	   tsv->getter ? 1 : 0, buf);
}

/* Return the first trace state variable definition, and initialize
   the state machine that will iterate through all the tsv bits.  */

static void
cmd_qtfv (char *packet)
{
  trace_debug ("Returning first trace state variable definition");

  cur_tsv = trace_state_variables;

  if (cur_tsv)
    response_tsv (packet, cur_tsv);
  else
    strcpy (packet, "l");
}

/* Return additional trace state variable definitions. */

static void
cmd_qtsv (char *packet)
{
  trace_debug ("Returning additional trace state variable definition");

  if (cur_tsv)
    {
      cur_tsv = cur_tsv->next;
      if (cur_tsv)
	response_tsv (packet, cur_tsv);
      else
	strcpy (packet, "l");
    }
  else
    strcpy (packet, "l");
}

/* Return the first static tracepoint marker, and initialize the state
   machine that will iterate through all the static tracepoints
   markers.  */

static void
cmd_qtfstm (char *packet)
{
  if (!maybe_write_ipa_ust_not_loaded (packet))
    run_inferior_command (packet, strlen (packet) + 1);
}

/* Return additional static tracepoints markers.  */

static void
cmd_qtsstm (char *packet)
{
  if (!maybe_write_ipa_ust_not_loaded (packet))
    run_inferior_command (packet, strlen (packet) + 1);
}

/* Return the definition of the static tracepoint at a given address.
   Result packet is the same as qTsST's.  */

static void
cmd_qtstmat (char *packet)
{
  if (!maybe_write_ipa_ust_not_loaded (packet))
    run_inferior_command (packet, strlen (packet) + 1);
}

/* Sent the agent a command to close it.  */

void
gdb_agent_about_to_close (int pid)
{
  char buf[IPA_CMD_BUF_SIZE];

  if (!maybe_write_ipa_not_loaded (buf))
    {
      struct thread_info *save_inferior;
      struct inferior_list_entry *inf = all_threads.head;

      save_inferior = current_inferior;

      /* Find a certain thread which belongs to process PID.  */
      while (inf != NULL)
	{
	  if (ptid_get_pid (inf->id) == pid)
	    break;
	  inf = inf->next;
	}

      current_inferior = (struct thread_info *) inf;

      strcpy (buf, "close");

      run_inferior_command (buf, strlen (buf) + 1);

      current_inferior = save_inferior;
    }
}

/* Return the minimum instruction size needed for fast tracepoints as a
   hexadecimal number.  */

static void
cmd_qtminftpilen (char *packet)
{
  if (current_inferior == NULL)
    {
      /* Indicate that the minimum length is currently unknown.  */
      strcpy (packet, "0");
      return;
    }

  sprintf (packet, "%x", target_get_min_fast_tracepoint_insn_len ());
}

/* Respond to qTBuffer packet with a block of raw data from the trace
   buffer.  GDB may ask for a lot, but we are allowed to reply with
   only as much as will fit within packet limits or whatever.  */

static void
cmd_qtbuffer (char *own_buf)
{
  ULONGEST offset, num, tot;
  unsigned char *tbp;
  char *packet = own_buf;

  packet += strlen ("qTBuffer:");

  packet = unpack_varlen_hex (packet, &offset);
  ++packet; /* skip a comma */
  unpack_varlen_hex (packet, &num);

  trace_debug ("Want to get trace buffer, %d bytes at offset 0x%s",
	       (int) num, phex_nz (offset, 0));

  tot = (trace_buffer_hi - trace_buffer_lo) - free_space ();

  /* If we're right at the end, reply specially that we're done.  */
  if (offset == tot)
    {
      strcpy (own_buf, "l");
      return;
    }

  /* Object to any other out-of-bounds request.  */
  if (offset > tot)
    {
      write_enn (own_buf);
      return;
    }

  /* Compute the pointer corresponding to the given offset, accounting
     for wraparound.  */
  tbp = trace_buffer_start + offset;
  if (tbp >= trace_buffer_wrap)
    tbp -= (trace_buffer_wrap - trace_buffer_lo);

  /* Trim to the remaining bytes if we're close to the end.  */
  if (num > tot - offset)
    num = tot - offset;

  /* Trim to available packet size.  */
  if (num >= (PBUFSIZ - 16) / 2 )
    num = (PBUFSIZ - 16) / 2;

  convert_int_to_ascii (tbp, own_buf, num);
}

static void
cmd_bigqtbuffer_circular (char *own_buf)
{
  ULONGEST val;
  char *packet = own_buf;

  packet += strlen ("QTBuffer:circular:");

  unpack_varlen_hex (packet, &val);
  circular_trace_buffer = val;
  trace_debug ("Trace buffer is now %s",
	       circular_trace_buffer ? "circular" : "linear");
  write_ok (own_buf);
}

static void
cmd_bigqtbuffer_size (char *own_buf)
{
  ULONGEST val;
  LONGEST sval;
  char *packet = own_buf;

  /* Can't change the size during a tracing run.  */
  if (tracing)
    {
      write_enn (own_buf);
      return;
    }

  packet += strlen ("QTBuffer:size:");

  /* -1 is sent as literal "-1".  */
  if (strcmp (packet, "-1") == 0)
    sval = DEFAULT_TRACE_BUFFER_SIZE;
  else
    {
      unpack_varlen_hex (packet, &val);
      sval = (LONGEST) val;
    }

  init_trace_buffer (sval);
  trace_debug ("Trace buffer is now %s bytes",
	       plongest (trace_buffer_size));
  write_ok (own_buf);
}

static void
cmd_qtnotes (char *own_buf)
{
  size_t nbytes;
  char *saved, *user, *notes, *stopnote;
  char *packet = own_buf;

  packet += strlen ("QTNotes:");

  while (*packet)
    {
      if (strncmp ("user:", packet, strlen ("user:")) == 0)
	{
	  packet += strlen ("user:");
	  saved = packet;
	  packet = strchr (packet, ';');
	  nbytes = (packet - saved) / 2;
	  user = xmalloc (nbytes + 1);
	  nbytes = unhexify (user, saved, nbytes);
	  user[nbytes] = '\0';
	  ++packet; /* skip the semicolon */
	  trace_debug ("User is '%s'", user);
	  xfree (tracing_user_name);
	  tracing_user_name = user;
	}
      else if (strncmp ("notes:", packet, strlen ("notes:")) == 0)
	{
	  packet += strlen ("notes:");
	  saved = packet;
	  packet = strchr (packet, ';');
	  nbytes = (packet - saved) / 2;
	  notes = xmalloc (nbytes + 1);
	  nbytes = unhexify (notes, saved, nbytes);
	  notes[nbytes] = '\0';
	  ++packet; /* skip the semicolon */
	  trace_debug ("Notes is '%s'", notes);
	  xfree (tracing_notes);
	  tracing_notes = notes;
	}
      else if (strncmp ("tstop:", packet, strlen ("tstop:")) == 0)
	{
	  packet += strlen ("tstop:");
	  saved = packet;
	  packet = strchr (packet, ';');
	  nbytes = (packet - saved) / 2;
	  stopnote = xmalloc (nbytes + 1);
	  nbytes = unhexify (stopnote, saved, nbytes);
	  stopnote[nbytes] = '\0';
	  ++packet; /* skip the semicolon */
	  trace_debug ("tstop note is '%s'", stopnote);
	  xfree (tracing_stop_note);
	  tracing_stop_note = stopnote;
	}
      else
	break;
    }

  write_ok (own_buf);
}

int
handle_tracepoint_general_set (char *packet)
{
  if (strcmp ("QTinit", packet) == 0)
    {
      cmd_qtinit (packet);
      return 1;
    }
  else if (strncmp ("QTDP:", packet, strlen ("QTDP:")) == 0)
    {
      cmd_qtdp (packet);
      return 1;
    }
  else if (strncmp ("QTDPsrc:", packet, strlen ("QTDPsrc:")) == 0)
    {
      cmd_qtdpsrc (packet);
      return 1;
    }
  else if (strncmp ("QTEnable:", packet, strlen ("QTEnable:")) == 0)
    {
      cmd_qtenable_disable (packet, 1);
      return 1;
    }
  else if (strncmp ("QTDisable:", packet, strlen ("QTDisable:")) == 0)
    {
      cmd_qtenable_disable (packet, 0);
      return 1;
    }
  else if (strncmp ("QTDV:", packet, strlen ("QTDV:")) == 0)
    {
      cmd_qtdv (packet);
      return 1;
    }
  else if (strncmp ("QTro:", packet, strlen ("QTro:")) == 0)
    {
      cmd_qtro (packet);
      return 1;
    }
  else if (strcmp ("QTStart", packet) == 0)
    {
      cmd_qtstart (packet);
      return 1;
    }
  else if (strcmp ("QTStop", packet) == 0)
    {
      cmd_qtstop (packet);
      return 1;
    }
  else if (strncmp ("QTDisconnected:", packet,
		    strlen ("QTDisconnected:")) == 0)
    {
      cmd_qtdisconnected (packet);
      return 1;
    }
  else if (strncmp ("QTFrame:", packet, strlen ("QTFrame:")) == 0)
    {
      cmd_qtframe (packet);
      return 1;
    }
  else if (strncmp ("QTBuffer:circular:", packet, strlen ("QTBuffer:circular:")) == 0)
    {
      cmd_bigqtbuffer_circular (packet);
      return 1;
    }
  else if (strncmp ("QTBuffer:size:", packet, strlen ("QTBuffer:size:")) == 0)
    {
      cmd_bigqtbuffer_size (packet);
      return 1;
    }
  else if (strncmp ("QTNotes:", packet, strlen ("QTNotes:")) == 0)
    {
      cmd_qtnotes (packet);
      return 1;
    }

  return 0;
}

int
handle_tracepoint_query (char *packet)
{
  if (strcmp ("qTStatus", packet) == 0)
    {
      cmd_qtstatus (packet);
      return 1;
    }
  else if (strncmp ("qTP:", packet, strlen ("qTP:")) == 0)
    {
      cmd_qtp (packet);
      return 1;
    }
  else if (strcmp ("qTfP", packet) == 0)
    {
      cmd_qtfp (packet);
      return 1;
    }
  else if (strcmp ("qTsP", packet) == 0)
    {
      cmd_qtsp (packet);
      return 1;
    }
  else if (strcmp ("qTfV", packet) == 0)
    {
      cmd_qtfv (packet);
      return 1;
    }
  else if (strcmp ("qTsV", packet) == 0)
    {
      cmd_qtsv (packet);
      return 1;
    }
  else if (strncmp ("qTV:", packet, strlen ("qTV:")) == 0)
    {
      cmd_qtv (packet);
      return 1;
    }
  else if (strncmp ("qTBuffer:", packet, strlen ("qTBuffer:")) == 0)
    {
      cmd_qtbuffer (packet);
      return 1;
    }
  else if (strcmp ("qTfSTM", packet) == 0)
    {
      cmd_qtfstm (packet);
      return 1;
    }
  else if (strcmp ("qTsSTM", packet) == 0)
    {
      cmd_qtsstm (packet);
      return 1;
    }
  else if (strncmp ("qTSTMat:", packet, strlen ("qTSTMat:")) == 0)
    {
      cmd_qtstmat (packet);
      return 1;
    }
  else if (strcmp ("qTMinFTPILen", packet) == 0)
    {
      cmd_qtminftpilen (packet);
      return 1;
    }

  return 0;
}

#endif
#ifndef IN_PROCESS_AGENT

/* Call this when thread TINFO has hit the tracepoint defined by
   TP_NUMBER and TP_ADDRESS, and that tracepoint has a while-stepping
   action.  This adds a while-stepping collecting state item to the
   threads' collecting state list, so that we can keep track of
   multiple simultaneous while-stepping actions being collected by the
   same thread.  This can happen in cases like:

    ff0001  INSN1 <-- TP1, while-stepping 10 collect $regs
    ff0002  INSN2
    ff0003  INSN3 <-- TP2, collect $regs
    ff0004  INSN4 <-- TP3, while-stepping 10 collect $regs
    ff0005  INSN5

   Notice that when instruction INSN5 is reached, the while-stepping
   actions of both TP1 and TP3 are still being collected, and that TP2
   had been collected meanwhile.  The whole range of ff0001-ff0005
   should be single-stepped, due to at least TP1's while-stepping
   action covering the whole range.  */

static void
add_while_stepping_state (struct thread_info *tinfo,
			  int tp_number, CORE_ADDR tp_address)
{
  struct wstep_state *wstep;

  wstep = xmalloc (sizeof (*wstep));
  wstep->next = tinfo->while_stepping;

  wstep->tp_number = tp_number;
  wstep->tp_address = tp_address;
  wstep->current_step = 0;

  tinfo->while_stepping = wstep;
}

/* Release the while-stepping collecting state WSTEP.  */

static void
release_while_stepping_state (struct wstep_state *wstep)
{
  free (wstep);
}

/* Release all while-stepping collecting states currently associated
   with thread TINFO.  */

void
release_while_stepping_state_list (struct thread_info *tinfo)
{
  struct wstep_state *head;

  while (tinfo->while_stepping)
    {
      head = tinfo->while_stepping;
      tinfo->while_stepping = head->next;
      release_while_stepping_state (head);
    }
}

/* If TINFO was handling a 'while-stepping' action, the step has
   finished, so collect any step data needed, and check if any more
   steps are required.  Return true if the thread was indeed
   collecting tracepoint data, false otherwise.  */

int
tracepoint_finished_step (struct thread_info *tinfo, CORE_ADDR stop_pc)
{
  struct tracepoint *tpoint;
  struct wstep_state *wstep;
  struct wstep_state **wstep_link;
  struct trap_tracepoint_ctx ctx;

  /* Pull in fast tracepoint trace frames from the inferior lib buffer into
     our buffer.  */
  if (agent_loaded_p ())
    upload_fast_traceframes ();

  /* Check if we were indeed collecting data for one of more
     tracepoints with a 'while-stepping' count.  */
  if (tinfo->while_stepping == NULL)
    return 0;

  if (!tracing)
    {
      /* We're not even tracing anymore.  Stop this thread from
	 collecting.  */
      release_while_stepping_state_list (tinfo);

      /* The thread had stopped due to a single-step request indeed
	 explained by a tracepoint.  */
      return 1;
    }

  wstep = tinfo->while_stepping;
  wstep_link = &tinfo->while_stepping;

  trace_debug ("Thread %s finished a single-step for tracepoint %d at 0x%s",
	       target_pid_to_str (tinfo->entry.id),
	       wstep->tp_number, paddress (wstep->tp_address));

  ctx.base.type = trap_tracepoint;
  ctx.regcache = get_thread_regcache (tinfo, 1);

  while (wstep != NULL)
    {
      tpoint = find_tracepoint (wstep->tp_number, wstep->tp_address);
      if (tpoint == NULL)
	{
	  trace_debug ("NO TRACEPOINT %d at 0x%s FOR THREAD %s!",
		       wstep->tp_number, paddress (wstep->tp_address),
		       target_pid_to_str (tinfo->entry.id));

	  /* Unlink.  */
	  *wstep_link = wstep->next;
	  release_while_stepping_state (wstep);
	  wstep = *wstep_link;
	  continue;
	}

      /* We've just finished one step.  */
      ++wstep->current_step;

      /* Collect data.  */
      collect_data_at_step ((struct tracepoint_hit_ctx *) &ctx,
			    stop_pc, tpoint, wstep->current_step);

      if (wstep->current_step >= tpoint->step_count)
	{
	  /* The requested numbers of steps have occurred.  */
	  trace_debug ("Thread %s done stepping for tracepoint %d at 0x%s",
		       target_pid_to_str (tinfo->entry.id),
		       wstep->tp_number, paddress (wstep->tp_address));

	  /* Unlink the wstep.  */
	  *wstep_link = wstep->next;
	  release_while_stepping_state (wstep);
	  wstep = *wstep_link;

	  /* Only check the hit count now, which ensure that we do all
	     our stepping before stopping the run.  */
	  if (tpoint->pass_count > 0
	      && tpoint->hit_count >= tpoint->pass_count
	      && stopping_tracepoint == NULL)
	    stopping_tracepoint = tpoint;
	}
      else
	{
	  /* Keep single-stepping until the requested numbers of steps
	     have occurred.  */
	  wstep_link = &wstep->next;
	  wstep = *wstep_link;
	}

      if (stopping_tracepoint
	  || trace_buffer_is_full
	  || expr_eval_result != expr_eval_no_error)
	{
	  stop_tracing ();
	  break;
	}
    }

  return 1;
}

/* Handle any internal tracing control breakpoint hits.  That means,
   pull traceframes from the IPA to our buffer, and syncing both
   tracing agents when the IPA's tracing stops for some reason.  */

int
handle_tracepoint_bkpts (struct thread_info *tinfo, CORE_ADDR stop_pc)
{
  /* Pull in fast tracepoint trace frames from the inferior in-process
     agent's buffer into our buffer.  */

  if (!agent_loaded_p ())
    return 0;

  upload_fast_traceframes ();

  /* Check if the in-process agent had decided we should stop
     tracing.  */
  if (stop_pc == ipa_sym_addrs.addr_stop_tracing)
    {
      int ipa_trace_buffer_is_full;
      CORE_ADDR ipa_stopping_tracepoint;
      int ipa_expr_eval_result;
      CORE_ADDR ipa_error_tracepoint;

      trace_debug ("lib stopped at stop_tracing");

      read_inferior_integer (ipa_sym_addrs.addr_trace_buffer_is_full,
			     &ipa_trace_buffer_is_full);

      read_inferior_data_pointer (ipa_sym_addrs.addr_stopping_tracepoint,
				  &ipa_stopping_tracepoint);
      write_inferior_data_pointer (ipa_sym_addrs.addr_stopping_tracepoint, 0);

      read_inferior_data_pointer (ipa_sym_addrs.addr_error_tracepoint,
				  &ipa_error_tracepoint);
      write_inferior_data_pointer (ipa_sym_addrs.addr_error_tracepoint, 0);

      read_inferior_integer (ipa_sym_addrs.addr_expr_eval_result,
			     &ipa_expr_eval_result);
      write_inferior_integer (ipa_sym_addrs.addr_expr_eval_result, 0);

      trace_debug ("lib: trace_buffer_is_full: %d, "
		   "stopping_tracepoint: %s, "
		   "ipa_expr_eval_result: %d, "
		   "error_tracepoint: %s, ",
		   ipa_trace_buffer_is_full,
		   paddress (ipa_stopping_tracepoint),
		   ipa_expr_eval_result,
		   paddress (ipa_error_tracepoint));

      if (debug_threads)
	{
	  if (ipa_trace_buffer_is_full)
	    trace_debug ("lib stopped due to full buffer.");
	  if (ipa_stopping_tracepoint)
	    trace_debug ("lib stopped due to tpoint");
	  if (ipa_stopping_tracepoint)
	    trace_debug ("lib stopped due to error");
	}

      if (ipa_stopping_tracepoint != 0)
	{
	  stopping_tracepoint
	    = fast_tracepoint_from_ipa_tpoint_address (ipa_stopping_tracepoint);
	}
      else if (ipa_expr_eval_result != expr_eval_no_error)
	{
	  expr_eval_result = ipa_expr_eval_result;
	  error_tracepoint
	    = fast_tracepoint_from_ipa_tpoint_address (ipa_error_tracepoint);
	}
      stop_tracing ();
      return 1;
    }
  else if (stop_pc == ipa_sym_addrs.addr_flush_trace_buffer)
    {
      trace_debug ("lib stopped at flush_trace_buffer");
      return 1;
    }

  return 0;
}

/* Return true if TINFO just hit a tracepoint.  Collect data if
   so.  */

int
tracepoint_was_hit (struct thread_info *tinfo, CORE_ADDR stop_pc)
{
  struct tracepoint *tpoint;
  int ret = 0;
  struct trap_tracepoint_ctx ctx;

  /* Not tracing, don't handle.  */
  if (!tracing)
    return 0;

  ctx.base.type = trap_tracepoint;
  ctx.regcache = get_thread_regcache (tinfo, 1);

  for (tpoint = tracepoints; tpoint; tpoint = tpoint->next)
    {
      /* Note that we collect fast tracepoints here as well.  We'll
	 step over the fast tracepoint jump later, which avoids the
	 double collect.  However, we don't collect for static
	 tracepoints here, because UST markers are compiled in program,
	 and probes will be executed in program.  So static tracepoints
	 are collected there.   */
      if (tpoint->enabled && stop_pc == tpoint->address
	  && tpoint->type != static_tracepoint)
	{
	  trace_debug ("Thread %s at address of tracepoint %d at 0x%s",
		       target_pid_to_str (tinfo->entry.id),
		       tpoint->number, paddress (tpoint->address));

	  /* Test the condition if present, and collect if true.  */
	  if (!tpoint->cond
	      || (condition_true_at_tracepoint
		  ((struct tracepoint_hit_ctx *) &ctx, tpoint)))
	    collect_data_at_tracepoint ((struct tracepoint_hit_ctx *) &ctx,
					stop_pc, tpoint);

	  if (stopping_tracepoint
	      || trace_buffer_is_full
	      || expr_eval_result != expr_eval_no_error)
	    {
	      stop_tracing ();
	    }
	  /* If the tracepoint had a 'while-stepping' action, then set
	     the thread to collect this tracepoint on the following
	     single-steps.  */
	  else if (tpoint->step_count > 0)
	    {
	      add_while_stepping_state (tinfo,
					tpoint->number, tpoint->address);
	    }

	  ret = 1;
	}
    }

  return ret;
}

#endif

#if defined IN_PROCESS_AGENT && defined HAVE_UST
struct ust_marker_data;
static void collect_ust_data_at_tracepoint (struct tracepoint_hit_ctx *ctx,
					    struct traceframe *tframe);
#endif

/* Create a trace frame for the hit of the given tracepoint in the
   given thread.  */

static void
collect_data_at_tracepoint (struct tracepoint_hit_ctx *ctx, CORE_ADDR stop_pc,
			    struct tracepoint *tpoint)
{
  struct traceframe *tframe;
  int acti;

  /* Only count it as a hit when we actually collect data.  */
  tpoint->hit_count++;

  /* If we've exceeded a defined pass count, record the event for
     later, and finish the collection for this hit.  This test is only
     for nonstepping tracepoints, stepping tracepoints test at the end
     of their while-stepping loop.  */
  if (tpoint->pass_count > 0
      && tpoint->hit_count >= tpoint->pass_count
      && tpoint->step_count == 0
      && stopping_tracepoint == NULL)
    stopping_tracepoint = tpoint;

  trace_debug ("Making new traceframe for tracepoint %d at 0x%s, hit %" PRIu64,
	       tpoint->number, paddress (tpoint->address), tpoint->hit_count);

  tframe = add_traceframe (tpoint);

  if (tframe)
    {
      for (acti = 0; acti < tpoint->numactions; ++acti)
	{
#ifndef IN_PROCESS_AGENT
	  trace_debug ("Tracepoint %d at 0x%s about to do action '%s'",
		       tpoint->number, paddress (tpoint->address),
		       tpoint->actions_str[acti]);
#endif

	  do_action_at_tracepoint (ctx, stop_pc, tpoint, tframe,
				   tpoint->actions[acti]);
	}

      finish_traceframe (tframe);
    }

  if (tframe == NULL && tracing)
    trace_buffer_is_full = 1;
}

#ifndef IN_PROCESS_AGENT

static void
collect_data_at_step (struct tracepoint_hit_ctx *ctx,
		      CORE_ADDR stop_pc,
		      struct tracepoint *tpoint, int current_step)
{
  struct traceframe *tframe;
  int acti;

  trace_debug ("Making new step traceframe for "
	       "tracepoint %d at 0x%s, step %d of %" PRIu64 ", hit %" PRIu64,
	       tpoint->number, paddress (tpoint->address),
	       current_step, tpoint->step_count,
	       tpoint->hit_count);

  tframe = add_traceframe (tpoint);

  if (tframe)
    {
      for (acti = 0; acti < tpoint->num_step_actions; ++acti)
	{
	  trace_debug ("Tracepoint %d at 0x%s about to do step action '%s'",
		       tpoint->number, paddress (tpoint->address),
		       tpoint->step_actions_str[acti]);

	  do_action_at_tracepoint (ctx, stop_pc, tpoint, tframe,
				   tpoint->step_actions[acti]);
	}

      finish_traceframe (tframe);
    }

  if (tframe == NULL && tracing)
    trace_buffer_is_full = 1;
}

#endif

#ifdef IN_PROCESS_AGENT
/* The target description used by the IPA.  Given that the IPA library
   is built for a specific architecture that is loaded into the
   inferior, there only needs to be one such description per
   build.  */
const struct target_desc *ipa_tdesc;
#endif

static struct regcache *
get_context_regcache (struct tracepoint_hit_ctx *ctx)
{
  struct regcache *regcache = NULL;

#ifdef IN_PROCESS_AGENT
  if (ctx->type == fast_tracepoint)
    {
      struct fast_tracepoint_ctx *fctx = (struct fast_tracepoint_ctx *) ctx;
      if (!fctx->regcache_initted)
	{
	  fctx->regcache_initted = 1;
	  init_register_cache (&fctx->regcache, ipa_tdesc, fctx->regspace);
	  supply_regblock (&fctx->regcache, NULL);
	  supply_fast_tracepoint_registers (&fctx->regcache, fctx->regs);
	}
      regcache = &fctx->regcache;
    }
#ifdef HAVE_UST
  if (ctx->type == static_tracepoint)
    {
      struct static_tracepoint_ctx *sctx
	= (struct static_tracepoint_ctx *) ctx;

      if (!sctx->regcache_initted)
	{
	  sctx->regcache_initted = 1;
	  init_register_cache (&sctx->regcache, ipa_tdesc, sctx->regspace);
	  supply_regblock (&sctx->regcache, NULL);
	  /* Pass down the tracepoint address, because REGS doesn't
	     include the PC, but we know what it must have been.  */
	  supply_static_tracepoint_registers (&sctx->regcache,
					      (const unsigned char *)
					      sctx->regs,
					      sctx->tpoint->address);
	}
      regcache = &sctx->regcache;
    }
#endif
#else
  if (ctx->type == trap_tracepoint)
    {
      struct trap_tracepoint_ctx *tctx = (struct trap_tracepoint_ctx *) ctx;
      regcache = tctx->regcache;
    }
#endif

  gdb_assert (regcache != NULL);

  return regcache;
}

static void
do_action_at_tracepoint (struct tracepoint_hit_ctx *ctx,
			 CORE_ADDR stop_pc,
			 struct tracepoint *tpoint,
			 struct traceframe *tframe,
			 struct tracepoint_action *taction)
{
  enum eval_result_type err;

  switch (taction->type)
    {
    case 'M':
      {
	struct collect_memory_action *maction;
	struct eval_agent_expr_context ax_ctx;

	maction = (struct collect_memory_action *) taction;
	ax_ctx.regcache = NULL;
	ax_ctx.tframe = tframe;
	ax_ctx.tpoint = tpoint;

	trace_debug ("Want to collect %s bytes at 0x%s (basereg %d)",
		     pulongest (maction->len),
		     paddress (maction->addr), maction->basereg);
	/* (should use basereg) */
	agent_mem_read (&ax_ctx, NULL, (CORE_ADDR) maction->addr,
			maction->len);
	break;
      }
    case 'R':
      {
	unsigned char *regspace;
	struct regcache tregcache;
	struct regcache *context_regcache;
	int regcache_size;

	trace_debug ("Want to collect registers");

	context_regcache = get_context_regcache (ctx);
	regcache_size = register_cache_size (context_regcache->tdesc);

	/* Collect all registers for now.  */
	regspace = add_traceframe_block (tframe, tpoint, 1 + regcache_size);
	if (regspace == NULL)
	  {
	    trace_debug ("Trace buffer block allocation failed, skipping");
	    break;
	  }
	/* Identify a register block.  */
	*regspace = 'R';

	/* Wrap the regblock in a register cache (in the stack, we
	   don't want to malloc here).  */
	init_register_cache (&tregcache, context_regcache->tdesc,
			     regspace + 1);

	/* Copy the register data to the regblock.  */
	regcache_cpy (&tregcache, context_regcache);

#ifndef IN_PROCESS_AGENT
	/* On some platforms, trap-based tracepoints will have the PC
	   pointing to the next instruction after the trap, but we
	   don't want the user or GDB trying to guess whether the
	   saved PC needs adjusting; so always record the adjusted
	   stop_pc.  Note that we can't use tpoint->address instead,
	   since it will be wrong for while-stepping actions.  This
	   adjustment is a nop for fast tracepoints collected from the
	   in-process lib (but not if GDBserver is collecting one
	   preemptively), since the PC had already been adjusted to
	   contain the tracepoint's address by the jump pad.  */
	trace_debug ("Storing stop pc (0x%s) in regblock",
		     paddress (stop_pc));

	/* This changes the regblock, not the thread's
	   regcache.  */
	regcache_write_pc (&tregcache, stop_pc);
#endif
      }
      break;
    case 'X':
      {
	struct eval_expr_action *eaction;
	struct eval_agent_expr_context ax_ctx;

	eaction = (struct eval_expr_action *) taction;
	ax_ctx.regcache = get_context_regcache (ctx);
	ax_ctx.tframe = tframe;
	ax_ctx.tpoint = tpoint;

	trace_debug ("Want to evaluate expression");

	err = gdb_eval_agent_expr (&ax_ctx, eaction->expr, NULL);

	if (err != expr_eval_no_error)
	  {
	    record_tracepoint_error (tpoint, "action expression", err);
	    return;
	  }
      }
      break;
    case 'L':
      {
#if defined IN_PROCESS_AGENT && defined HAVE_UST
	trace_debug ("Want to collect static trace data");
	collect_ust_data_at_tracepoint (ctx, tframe);
#else
	trace_debug ("warning: collecting static trace data, "
		     "but static tracepoints are not supported");
#endif
      }
      break;
    default:
      trace_debug ("unknown trace action '%c', ignoring", taction->type);
      break;
    }
}

static int
condition_true_at_tracepoint (struct tracepoint_hit_ctx *ctx,
			      struct tracepoint *tpoint)
{
  ULONGEST value = 0;
  enum eval_result_type err;

  /* Presently, gdbserver doesn't run compiled conditions, only the
     IPA does.  If the program stops at a fast tracepoint's address
     (e.g., due to a breakpoint, trap tracepoint, or stepping),
     gdbserver preemptively collect the fast tracepoint.  Later, on
     resume, gdbserver steps over the fast tracepoint like it steps
     over breakpoints, so that the IPA doesn't see that fast
     tracepoint.  This avoids double collects of fast tracepoints in
     that stopping scenario.  Having gdbserver itself handle the fast
     tracepoint gives the user a consistent view of when fast or trap
     tracepoints are collected, compared to an alternative where only
     trap tracepoints are collected on stop, and fast tracepoints on
     resume.  When a fast tracepoint is being processed by gdbserver,
     it is always the non-compiled condition expression that is
     used.  */
#ifdef IN_PROCESS_AGENT
  if (tpoint->compiled_cond)
    err = ((condfn) (uintptr_t) (tpoint->compiled_cond)) (ctx, &value);
  else
#endif
    {
      struct eval_agent_expr_context ax_ctx;

      ax_ctx.regcache = get_context_regcache (ctx);
      ax_ctx.tframe = NULL;
      ax_ctx.tpoint = tpoint;

      err = gdb_eval_agent_expr (&ax_ctx, tpoint->cond, &value);
    }
  if (err != expr_eval_no_error)
    {
      record_tracepoint_error (tpoint, "condition", err);
      /* The error case must return false.  */
      return 0;
    }

  trace_debug ("Tracepoint %d at 0x%s condition evals to %s",
	       tpoint->number, paddress (tpoint->address),
	       pulongest (value));
  return (value ? 1 : 0);
}

/* Do memory copies for bytecodes.  */
/* Do the recording of memory blocks for actions and bytecodes.  */

int
agent_mem_read (struct eval_agent_expr_context *ctx,
		unsigned char *to, CORE_ADDR from, ULONGEST len)
{
  unsigned char *mspace;
  ULONGEST remaining = len;
  unsigned short blocklen;

  /* If a 'to' buffer is specified, use it.  */
  if (to != NULL)
    {
      read_inferior_memory (from, to, len);
      return 0;
    }

  /* Otherwise, create a new memory block in the trace buffer.  */
  while (remaining > 0)
    {
      size_t sp;

      blocklen = (remaining > 65535 ? 65535 : remaining);
      sp = 1 + sizeof (from) + sizeof (blocklen) + blocklen;
      mspace = add_traceframe_block (ctx->tframe, ctx->tpoint, sp);
      if (mspace == NULL)
	return 1;
      /* Identify block as a memory block.  */
      *mspace = 'M';
      ++mspace;
      /* Record address and size.  */
      memcpy (mspace, &from, sizeof (from));
      mspace += sizeof (from);
      memcpy (mspace, &blocklen, sizeof (blocklen));
      mspace += sizeof (blocklen);
      /* Record the memory block proper.  */
      read_inferior_memory (from, mspace, blocklen);
      trace_debug ("%d bytes recorded", blocklen);
      remaining -= blocklen;
      from += blocklen;
    }
  return 0;
}

int
agent_mem_read_string (struct eval_agent_expr_context *ctx,
		       unsigned char *to, CORE_ADDR from, ULONGEST len)
{
  unsigned char *buf, *mspace;
  ULONGEST remaining = len;
  unsigned short blocklen, i;

  /* To save a bit of space, block lengths are 16-bit, so break large
     requests into multiple blocks.  Bordering on overkill for strings,
     but it could happen that someone specifies a large max length.  */
  while (remaining > 0)
    {
      size_t sp;

      blocklen = (remaining > 65535 ? 65535 : remaining);
      /* We want working space to accumulate nonzero bytes, since
	 traceframes must have a predecided size (otherwise it gets
	 harder to wrap correctly for the circular case, etc).  */
      buf = (unsigned char *) xmalloc (blocklen + 1);
      for (i = 0; i < blocklen; ++i)
	{
	  /* Read the string one byte at a time, in case the string is
	     at the end of a valid memory area - we don't want a
	     correctly-terminated string to engender segvio
	     complaints.  */
	  read_inferior_memory (from + i, buf + i, 1);

	  if (buf[i] == '\0')
	    {
	      blocklen = i + 1;
	      /* Make sure outer loop stops now too.  */
	      remaining = blocklen;
	      break;
	    }
	}
      sp = 1 + sizeof (from) + sizeof (blocklen) + blocklen;
      mspace = add_traceframe_block (ctx->tframe, ctx->tpoint, sp);
      if (mspace == NULL)
	{
	  xfree (buf);
	  return 1;
	}
      /* Identify block as a memory block.  */
      *mspace = 'M';
      ++mspace;
      /* Record address and size.  */
      memcpy ((void *) mspace, (void *) &from, sizeof (from));
      mspace += sizeof (from);
      memcpy ((void *) mspace, (void *) &blocklen, sizeof (blocklen));
      mspace += sizeof (blocklen);
      /* Copy the string contents.  */
      memcpy ((void *) mspace, (void *) buf, blocklen);
      remaining -= blocklen;
      from += blocklen;
      xfree (buf);
    }
  return 0;
}

/* Record the value of a trace state variable.  */

int
agent_tsv_read (struct eval_agent_expr_context *ctx, int n)
{
  unsigned char *vspace;
  LONGEST val;

  vspace = add_traceframe_block (ctx->tframe, ctx->tpoint,
				 1 + sizeof (n) + sizeof (LONGEST));
  if (vspace == NULL)
    return 1;
  /* Identify block as a variable.  */
  *vspace = 'V';
  /* Record variable's number and value.  */
  memcpy (vspace + 1, &n, sizeof (n));
  val = get_trace_state_variable_value (n);
  memcpy (vspace + 1 + sizeof (n), &val, sizeof (val));
  trace_debug ("Variable %d recorded", n);
  return 0;
}

#ifndef IN_PROCESS_AGENT

/* Callback for traceframe_walk_blocks, used to find a given block
   type in a traceframe.  */

static int
match_blocktype (char blocktype, unsigned char *dataptr, void *data)
{
  char *wantedp = data;

  if (*wantedp == blocktype)
    return 1;

  return 0;
}

/* Walk over all traceframe blocks of the traceframe buffer starting
   at DATABASE, of DATASIZE bytes long, and call CALLBACK for each
   block found, passing in DATA unmodified.  If CALLBACK returns true,
   this returns a pointer to where the block is found.  Returns NULL
   if no callback call returned true, indicating that all blocks have
   been walked.  */

static unsigned char *
traceframe_walk_blocks (unsigned char *database, unsigned int datasize,
			int tfnum,
			int (*callback) (char blocktype,
					 unsigned char *dataptr,
					 void *data),
			void *data)
{
  unsigned char *dataptr;

  if (datasize == 0)
    {
      trace_debug ("traceframe %d has no data", tfnum);
      return NULL;
    }

  /* Iterate through a traceframe's blocks, looking for a block of the
     requested type.  */
  for (dataptr = database;
       dataptr < database + datasize;
       /* nothing */)
    {
      char blocktype;
      unsigned short mlen;

      if (dataptr == trace_buffer_wrap)
	{
	  /* Adjust to reflect wrapping part of the frame around to
	     the beginning.  */
	  datasize = dataptr - database;
	  dataptr = database = trace_buffer_lo;
	}

      blocktype = *dataptr++;

      if ((*callback) (blocktype, dataptr, data))
	return dataptr;

      switch (blocktype)
	{
	case 'R':
	  /* Skip over the registers block.  */
	  dataptr += current_target_desc ()->registers_size;
	  break;
	case 'M':
	  /* Skip over the memory block.  */
	  dataptr += sizeof (CORE_ADDR);
	  memcpy (&mlen, dataptr, sizeof (mlen));
	  dataptr += (sizeof (mlen) + mlen);
	  break;
	case 'V':
	  /* Skip over the TSV block.  */
	  dataptr += (sizeof (int) + sizeof (LONGEST));
	  break;
	case 'S':
	  /* Skip over the static trace data block.  */
	  memcpy (&mlen, dataptr, sizeof (mlen));
	  dataptr += (sizeof (mlen) + mlen);
	  break;
	default:
	  trace_debug ("traceframe %d has unknown block type 0x%x",
		       tfnum, blocktype);
	  return NULL;
	}
    }

  return NULL;
}

/* Look for the block of type TYPE_WANTED in the trameframe starting
   at DATABASE of DATASIZE bytes long.  TFNUM is the traceframe
   number.  */

static unsigned char *
traceframe_find_block_type (unsigned char *database, unsigned int datasize,
			    int tfnum, char type_wanted)
{
  return traceframe_walk_blocks (database, datasize, tfnum,
				 match_blocktype, &type_wanted);
}

static unsigned char *
traceframe_find_regblock (struct traceframe *tframe, int tfnum)
{
  unsigned char *regblock;

  regblock = traceframe_find_block_type (tframe->data,
					 tframe->data_size,
					 tfnum, 'R');

  if (regblock == NULL)
    trace_debug ("traceframe %d has no register data", tfnum);

  return regblock;
}

/* Get registers from a traceframe.  */

int
fetch_traceframe_registers (int tfnum, struct regcache *regcache, int regnum)
{
  unsigned char *dataptr;
  struct tracepoint *tpoint;
  struct traceframe *tframe;

  tframe = find_traceframe (tfnum);

  if (tframe == NULL)
    {
      trace_debug ("traceframe %d not found", tfnum);
      return 1;
    }

  dataptr = traceframe_find_regblock (tframe, tfnum);
  if (dataptr == NULL)
    {
      /* Mark registers unavailable.  */
      supply_regblock (regcache, NULL);

      /* We can generally guess at a PC, although this will be
	 misleading for while-stepping frames and multi-location
	 tracepoints.  */
      tpoint = find_next_tracepoint_by_number (NULL, tframe->tpnum);
      if (tpoint != NULL)
	regcache_write_pc (regcache, tpoint->address);
    }
  else
    supply_regblock (regcache, dataptr);

  return 0;
}

static CORE_ADDR
traceframe_get_pc (struct traceframe *tframe)
{
  struct regcache regcache;
  unsigned char *dataptr;
  const struct target_desc *tdesc = current_target_desc ();

  dataptr = traceframe_find_regblock (tframe, -1);
  if (dataptr == NULL)
    return 0;

  init_register_cache (&regcache, tdesc, dataptr);
  return regcache_read_pc (&regcache);
}

/* Read a requested block of memory from a trace frame.  */

int
traceframe_read_mem (int tfnum, CORE_ADDR addr,
		     unsigned char *buf, ULONGEST length,
		     ULONGEST *nbytes)
{
  struct traceframe *tframe;
  unsigned char *database, *dataptr;
  unsigned int datasize;
  CORE_ADDR maddr;
  unsigned short mlen;

  trace_debug ("traceframe_read_mem");

  tframe = find_traceframe (tfnum);

  if (!tframe)
    {
      trace_debug ("traceframe %d not found", tfnum);
      return 1;
    }

  datasize = tframe->data_size;
  database = dataptr = &tframe->data[0];

  /* Iterate through a traceframe's blocks, looking for memory.  */
  while ((dataptr = traceframe_find_block_type (dataptr,
						datasize
						- (dataptr - database),
						tfnum, 'M')) != NULL)
    {
      memcpy (&maddr, dataptr, sizeof (maddr));
      dataptr += sizeof (maddr);
      memcpy (&mlen, dataptr, sizeof (mlen));
      dataptr += sizeof (mlen);
      trace_debug ("traceframe %d has %d bytes at %s",
		   tfnum, mlen, paddress (maddr));

      /* If the block includes the first part of the desired range,
	 return as much it has; GDB will re-request the remainder,
	 which might be in a different block of this trace frame.  */
      if (maddr <= addr && addr < (maddr + mlen))
	{
	  ULONGEST amt = (maddr + mlen) - addr;
	  if (amt > length)
	    amt = length;

	  memcpy (buf, dataptr + (addr - maddr), amt);
	  *nbytes = amt;
	  return 0;
	}

      /* Skip over this block.  */
      dataptr += mlen;
    }

  trace_debug ("traceframe %d has no memory data for the desired region",
	       tfnum);

  *nbytes = 0;
  return 0;
}

static int
traceframe_read_tsv (int tsvnum, LONGEST *val)
{
  int tfnum;
  struct traceframe *tframe;
  unsigned char *database, *dataptr;
  unsigned int datasize;
  int vnum;
  int found = 0;

  trace_debug ("traceframe_read_tsv");

  tfnum = current_traceframe;

  if (tfnum < 0)
    {
      trace_debug ("no current traceframe");
      return 1;
    }

  tframe = find_traceframe (tfnum);

  if (tframe == NULL)
    {
      trace_debug ("traceframe %d not found", tfnum);
      return 1;
    }

  datasize = tframe->data_size;
  database = dataptr = &tframe->data[0];

  /* Iterate through a traceframe's blocks, looking for the last
     matched tsv.  */
  while ((dataptr = traceframe_find_block_type (dataptr,
						datasize
						- (dataptr - database),
						tfnum, 'V')) != NULL)
    {
      memcpy (&vnum, dataptr, sizeof (vnum));
      dataptr += sizeof (vnum);

      trace_debug ("traceframe %d has variable %d", tfnum, vnum);

      /* Check that this is the variable we want.  */
      if (tsvnum == vnum)
	{
	  memcpy (val, dataptr, sizeof (*val));
	  found = 1;
	}

      /* Skip over this block.  */
      dataptr += sizeof (LONGEST);
    }

  if (!found)
    trace_debug ("traceframe %d has no data for variable %d",
		 tfnum, tsvnum);
  return !found;
}

/* Read a requested block of static tracepoint data from a trace
   frame.  */

int
traceframe_read_sdata (int tfnum, ULONGEST offset,
		       unsigned char *buf, ULONGEST length,
		       ULONGEST *nbytes)
{
  struct traceframe *tframe;
  unsigned char *database, *dataptr;
  unsigned int datasize;
  unsigned short mlen;

  trace_debug ("traceframe_read_sdata");

  tframe = find_traceframe (tfnum);

  if (!tframe)
    {
      trace_debug ("traceframe %d not found", tfnum);
      return 1;
    }

  datasize = tframe->data_size;
  database = &tframe->data[0];

  /* Iterate through a traceframe's blocks, looking for static
     tracepoint data.  */
  dataptr = traceframe_find_block_type (database, datasize,
					tfnum, 'S');
  if (dataptr != NULL)
    {
      memcpy (&mlen, dataptr, sizeof (mlen));
      dataptr += sizeof (mlen);
      if (offset < mlen)
	{
	  if (offset + length > mlen)
	    length = mlen - offset;

	  memcpy (buf, dataptr, length);
	  *nbytes = length;
	}
      else
	*nbytes = 0;
      return 0;
    }

  trace_debug ("traceframe %d has no static trace data", tfnum);

  *nbytes = 0;
  return 0;
}

/* Callback for traceframe_walk_blocks.  Builds a traceframe-info
   object.  DATA is pointer to a struct buffer holding the
   traceframe-info object being built.  */

static int
build_traceframe_info_xml (char blocktype, unsigned char *dataptr, void *data)
{
  struct buffer *buffer = data;

  switch (blocktype)
    {
    case 'M':
      {
	unsigned short mlen;
	CORE_ADDR maddr;

	memcpy (&maddr, dataptr, sizeof (maddr));
	dataptr += sizeof (maddr);
	memcpy (&mlen, dataptr, sizeof (mlen));
	dataptr += sizeof (mlen);
	buffer_xml_printf (buffer,
			   "<memory start=\"0x%s\" length=\"0x%s\"/>\n",
			   paddress (maddr), phex_nz (mlen, sizeof (mlen)));
	break;
      }
    case 'V':
      {
	int vnum;

	memcpy (&vnum, dataptr, sizeof (vnum));
	buffer_xml_printf (buffer, "<tvar id=\"%d\"/>\n", vnum);
	break;
      }
    case 'R':
    case 'S':
      {
	break;
      }
    default:
      warning ("Unhandled trace block type (%d) '%c ' "
	       "while building trace frame info.",
	       blocktype, blocktype);
      break;
    }

  return 0;
}

/* Build a traceframe-info object for traceframe number TFNUM into
   BUFFER.  */

int
traceframe_read_info (int tfnum, struct buffer *buffer)
{
  struct traceframe *tframe;

  trace_debug ("traceframe_read_info");

  tframe = find_traceframe (tfnum);

  if (!tframe)
    {
      trace_debug ("traceframe %d not found", tfnum);
      return 1;
    }

  buffer_grow_str (buffer, "<traceframe-info>\n");
  traceframe_walk_blocks (tframe->data, tframe->data_size,
			  tfnum, build_traceframe_info_xml, buffer);
  buffer_grow_str0 (buffer, "</traceframe-info>\n");
  return 0;
}

/* Return the first fast tracepoint whose jump pad contains PC.  */

static struct tracepoint *
fast_tracepoint_from_jump_pad_address (CORE_ADDR pc)
{
  struct tracepoint *tpoint;

  for (tpoint = tracepoints; tpoint; tpoint = tpoint->next)
    if (tpoint->type == fast_tracepoint)
      if (tpoint->jump_pad <= pc && pc < tpoint->jump_pad_end)
	return tpoint;

  return NULL;
}

/* Return the first fast tracepoint whose trampoline contains PC.  */

static struct tracepoint *
fast_tracepoint_from_trampoline_address (CORE_ADDR pc)
{
  struct tracepoint *tpoint;

  for (tpoint = tracepoints; tpoint; tpoint = tpoint->next)
    {
      if (tpoint->type == fast_tracepoint
	  && tpoint->trampoline <= pc && pc < tpoint->trampoline_end)
	return tpoint;
    }

  return NULL;
}

/* Return GDBserver's tracepoint that matches the IP Agent's
   tracepoint object that lives at IPA_TPOINT_OBJ in the IP Agent's
   address space.  */

static struct tracepoint *
fast_tracepoint_from_ipa_tpoint_address (CORE_ADDR ipa_tpoint_obj)
{
  struct tracepoint *tpoint;

  for (tpoint = tracepoints; tpoint; tpoint = tpoint->next)
    if (tpoint->type == fast_tracepoint)
      if (tpoint->obj_addr_on_target == ipa_tpoint_obj)
	return tpoint;

  return NULL;
}

#endif

/* The type of the object that is used to synchronize fast tracepoint
   collection.  */

typedef struct collecting_t
{
  /* The fast tracepoint number currently collecting.  */
  uintptr_t tpoint;

  /* A number that GDBserver can use to identify the thread that is
     presently holding the collect lock.  This need not (and usually
     is not) the thread id, as getting the current thread ID usually
     requires a system call, which we want to avoid like the plague.
     Usually this is thread's TCB, found in the TLS (pseudo-)
     register, which is readable with a single insn on several
     architectures.  */
  uintptr_t thread_area;
} collecting_t;

#ifndef IN_PROCESS_AGENT

void
force_unlock_trace_buffer (void)
{
  write_inferior_data_pointer (ipa_sym_addrs.addr_collecting, 0);
}

/* Check if the thread identified by THREAD_AREA which is stopped at
   STOP_PC, is presently locking the fast tracepoint collection, and
   if so, gather some status of said collection.  Returns 0 if the
   thread isn't collecting or in the jump pad at all.  1, if in the
   jump pad (or within gdb_collect) and hasn't executed the adjusted
   original insn yet (can set a breakpoint there and run to it).  2,
   if presently executing the adjusted original insn --- in which
   case, if we want to move the thread out of the jump pad, we need to
   single-step it until this function returns 0.  */

int
fast_tracepoint_collecting (CORE_ADDR thread_area,
			    CORE_ADDR stop_pc,
			    struct fast_tpoint_collect_status *status)
{
  CORE_ADDR ipa_collecting;
  CORE_ADDR ipa_gdb_jump_pad_buffer, ipa_gdb_jump_pad_buffer_end;
  CORE_ADDR ipa_gdb_trampoline_buffer;
  CORE_ADDR ipa_gdb_trampoline_buffer_end;
  struct tracepoint *tpoint;
  int needs_breakpoint;

  /* The thread THREAD_AREA is either:

      0. not collecting at all, not within the jump pad, or within
	 gdb_collect or one of its callees.

      1. in the jump pad and haven't reached gdb_collect

      2. within gdb_collect (out of the jump pad) (collect is set)

      3. we're in the jump pad, after gdb_collect having returned,
	 possibly executing the adjusted insns.

      For cases 1 and 3, `collecting' may or not be set.  The jump pad
      doesn't have any complicated jump logic, so we can tell if the
      thread is executing the adjust original insn or not by just
      matching STOP_PC with known jump pad addresses.  If we it isn't
      yet executing the original insn, set a breakpoint there, and let
      the thread run to it, so to quickly step over a possible (many
      insns) gdb_collect call.  Otherwise, or when the breakpoint is
      hit, only a few (small number of) insns are left to be executed
      in the jump pad.  Single-step the thread until it leaves the
      jump pad.  */

 again:
  tpoint = NULL;
  needs_breakpoint = 0;
  trace_debug ("fast_tracepoint_collecting");

  if (read_inferior_data_pointer (ipa_sym_addrs.addr_gdb_jump_pad_buffer,
				  &ipa_gdb_jump_pad_buffer))
    fatal ("error extracting `gdb_jump_pad_buffer'");
  if (read_inferior_data_pointer (ipa_sym_addrs.addr_gdb_jump_pad_buffer_end,
				  &ipa_gdb_jump_pad_buffer_end))
    fatal ("error extracting `gdb_jump_pad_buffer_end'");

  if (read_inferior_data_pointer (ipa_sym_addrs.addr_gdb_trampoline_buffer,
				  &ipa_gdb_trampoline_buffer))
    fatal ("error extracting `gdb_trampoline_buffer'");
  if (read_inferior_data_pointer (ipa_sym_addrs.addr_gdb_trampoline_buffer_end,
				  &ipa_gdb_trampoline_buffer_end))
    fatal ("error extracting `gdb_trampoline_buffer_end'");

  if (ipa_gdb_jump_pad_buffer <= stop_pc
      && stop_pc < ipa_gdb_jump_pad_buffer_end)
    {
      /* We can tell which tracepoint(s) the thread is collecting by
	 matching the jump pad address back to the tracepoint.  */
      tpoint = fast_tracepoint_from_jump_pad_address (stop_pc);
      if (tpoint == NULL)
	{
	  warning ("in jump pad, but no matching tpoint?");
	  return 0;
	}
      else
	{
	  trace_debug ("in jump pad of tpoint (%d, %s); jump_pad(%s, %s); "
		       "adj_insn(%s, %s)",
		       tpoint->number, paddress (tpoint->address),
		       paddress (tpoint->jump_pad),
		       paddress (tpoint->jump_pad_end),
		       paddress (tpoint->adjusted_insn_addr),
		       paddress (tpoint->adjusted_insn_addr_end));
	}

      /* Definitely in the jump pad.  May or may not need
	 fast-exit-jump-pad breakpoint.  */
      if (tpoint->jump_pad <= stop_pc
	  && stop_pc < tpoint->adjusted_insn_addr)
	needs_breakpoint =  1;
    }
  else if (ipa_gdb_trampoline_buffer <= stop_pc
	   && stop_pc < ipa_gdb_trampoline_buffer_end)
    {
      /* We can tell which tracepoint(s) the thread is collecting by
	 matching the trampoline address back to the tracepoint.  */
      tpoint = fast_tracepoint_from_trampoline_address (stop_pc);
      if (tpoint == NULL)
	{
	  warning ("in trampoline, but no matching tpoint?");
	  return 0;
	}
      else
	{
	  trace_debug ("in trampoline of tpoint (%d, %s); trampoline(%s, %s)",
		       tpoint->number, paddress (tpoint->address),
		       paddress (tpoint->trampoline),
		       paddress (tpoint->trampoline_end));
	}

      /* Have not reached jump pad yet, but treat the trampoline as a
	 part of the jump pad that is before the adjusted original
	 instruction.  */
      needs_breakpoint = 1;
    }
  else
    {
      collecting_t ipa_collecting_obj;

      /* If `collecting' is set/locked, then the THREAD_AREA thread
	 may or not be the one holding the lock.  We have to read the
	 lock to find out.  */

      if (read_inferior_data_pointer (ipa_sym_addrs.addr_collecting,
				      &ipa_collecting))
	{
	  trace_debug ("fast_tracepoint_collecting:"
		       " failed reading 'collecting' in the inferior");
	  return 0;
	}

      if (!ipa_collecting)
	{
	  trace_debug ("fast_tracepoint_collecting: not collecting"
		       " (and nobody is).");
	  return 0;
	}

      /* Some thread is collecting.  Check which.  */
      if (read_inferior_memory (ipa_collecting,
				(unsigned char *) &ipa_collecting_obj,
				sizeof (ipa_collecting_obj)) != 0)
	goto again;

      if (ipa_collecting_obj.thread_area != thread_area)
	{
	  trace_debug ("fast_tracepoint_collecting: not collecting "
		       "(another thread is)");
	  return 0;
	}

      tpoint
	= fast_tracepoint_from_ipa_tpoint_address (ipa_collecting_obj.tpoint);
      if (tpoint == NULL)
	{
	  warning ("fast_tracepoint_collecting: collecting, "
		   "but tpoint %s not found?",
		   paddress ((CORE_ADDR) ipa_collecting_obj.tpoint));
	  return 0;
	}

      /* The thread is within `gdb_collect', skip over the rest of
	 fast tracepoint collection quickly using a breakpoint.  */
      needs_breakpoint = 1;
    }

  /* The caller wants a bit of status detail.  */
  if (status != NULL)
    {
      status->tpoint_num = tpoint->number;
      status->tpoint_addr = tpoint->address;
      status->adjusted_insn_addr = tpoint->adjusted_insn_addr;
      status->adjusted_insn_addr_end = tpoint->adjusted_insn_addr_end;
    }

  if (needs_breakpoint)
    {
      /* Hasn't executed the original instruction yet.  Set breakpoint
	 there, and wait till it's hit, then single-step until exiting
	 the jump pad.  */

      trace_debug ("\
fast_tracepoint_collecting, returning continue-until-break at %s",
		   paddress (tpoint->adjusted_insn_addr));

      return 1; /* continue */
    }
  else
    {
      /* Just single-step until exiting the jump pad.  */

      trace_debug ("fast_tracepoint_collecting, returning "
		   "need-single-step (%s-%s)",
		   paddress (tpoint->adjusted_insn_addr),
		   paddress (tpoint->adjusted_insn_addr_end));

      return 2; /* single-step */
    }
}

#endif

#ifdef IN_PROCESS_AGENT

/* The global fast tracepoint collect lock.  Points to a collecting_t
   object built on the stack by the jump pad, if presently locked;
   NULL if it isn't locked.  Note that this lock *must* be set while
   executing any *function other than the jump pad.  See
   fast_tracepoint_collecting.  */
static collecting_t * ATTR_USED collecting;

/* This routine, called from the jump pad (in asm) is designed to be
   called from the jump pads of fast tracepoints, thus it is on the
   critical path.  */

IP_AGENT_EXPORT void ATTR_USED
gdb_collect (struct tracepoint *tpoint, unsigned char *regs)
{
  struct fast_tracepoint_ctx ctx;

  /* Don't do anything until the trace run is completely set up.  */
  if (!tracing)
    return;

  ctx.base.type = fast_tracepoint;
  ctx.regs = regs;
  ctx.regcache_initted = 0;
  /* Wrap the regblock in a register cache (in the stack, we don't
     want to malloc here).  */
  ctx.regspace = alloca (ipa_tdesc->registers_size);
  if (ctx.regspace == NULL)
    {
      trace_debug ("Trace buffer block allocation failed, skipping");
      return;
    }

  for (ctx.tpoint = tpoint;
       ctx.tpoint != NULL && ctx.tpoint->address == tpoint->address;
       ctx.tpoint = ctx.tpoint->next)
    {
      if (!ctx.tpoint->enabled)
	continue;

      /* Multiple tracepoints of different types, such as fast tracepoint and
	 static tracepoint, can be set at the same address.  */
      if (ctx.tpoint->type != tpoint->type)
	continue;

      /* Test the condition if present, and collect if true.  */
      if (ctx.tpoint->cond == NULL
	  || condition_true_at_tracepoint ((struct tracepoint_hit_ctx *) &ctx,
					   ctx.tpoint))
	{
	  collect_data_at_tracepoint ((struct tracepoint_hit_ctx *) &ctx,
				      ctx.tpoint->address, ctx.tpoint);

	  /* Note that this will cause original insns to be written back
	     to where we jumped from, but that's OK because we're jumping
	     back to the next whole instruction.  This will go badly if
	     instruction restoration is not atomic though.  */
	  if (stopping_tracepoint
	      || trace_buffer_is_full
	      || expr_eval_result != expr_eval_no_error)
	    {
	      stop_tracing ();
	      break;
	    }
	}
      else
	{
	  /* If there was a condition and it evaluated to false, the only
	     way we would stop tracing is if there was an error during
	     condition expression evaluation.  */
	  if (expr_eval_result != expr_eval_no_error)
	    {
	      stop_tracing ();
	      break;
	    }
	}
    }
}

#endif

#ifndef IN_PROCESS_AGENT

CORE_ADDR
get_raw_reg_func_addr (void)
{
  return ipa_sym_addrs.addr_get_raw_reg;
}

CORE_ADDR
get_get_tsv_func_addr (void)
{
  return ipa_sym_addrs.addr_get_trace_state_variable_value;
}

CORE_ADDR
get_set_tsv_func_addr (void)
{
  return ipa_sym_addrs.addr_set_trace_state_variable_value;
}

static void
compile_tracepoint_condition (struct tracepoint *tpoint,
			      CORE_ADDR *jump_entry)
{
  CORE_ADDR entry_point = *jump_entry;
  enum eval_result_type err;

  trace_debug ("Starting condition compilation for tracepoint %d\n",
	       tpoint->number);

  /* Initialize the global pointer to the code being built.  */
  current_insn_ptr = *jump_entry;

  emit_prologue ();

  err = compile_bytecodes (tpoint->cond);

  if (err == expr_eval_no_error)
    {
      emit_epilogue ();

      /* Record the beginning of the compiled code.  */
      tpoint->compiled_cond = entry_point;

      trace_debug ("Condition compilation for tracepoint %d complete\n",
		   tpoint->number);
    }
  else
    {
      /* Leave the unfinished code in situ, but don't point to it.  */

      tpoint->compiled_cond = 0;

      trace_debug ("Condition compilation for tracepoint %d failed, "
		   "error code %d",
		   tpoint->number, err);
    }

  /* Update the code pointer passed in.  Note that we do this even if
     the compile fails, so that we can look at the partial results
     instead of letting them be overwritten.  */
  *jump_entry = current_insn_ptr;

  /* Leave a gap, to aid dump decipherment.  */
  *jump_entry += 16;
}

/* We'll need to adjust these when we consider bi-arch setups, and big
   endian machines.  */

static int
write_inferior_data_ptr (CORE_ADDR where, CORE_ADDR ptr)
{
  return write_inferior_memory (where,
				(unsigned char *) &ptr, sizeof (void *));
}

/* The base pointer of the IPA's heap.  This is the only memory the
   IPA is allowed to use.  The IPA should _not_ call the inferior's
   `malloc' during operation.  That'd be slow, and, most importantly,
   it may not be safe.  We may be collecting a tracepoint in a signal
   handler, for example.  */
static CORE_ADDR target_tp_heap;

/* Allocate at least SIZE bytes of memory from the IPA heap, aligned
   to 8 bytes.  */

static CORE_ADDR
target_malloc (ULONGEST size)
{
  CORE_ADDR ptr;

  if (target_tp_heap == 0)
    {
      /* We have the pointer *address*, need what it points to.  */
      if (read_inferior_data_pointer (ipa_sym_addrs.addr_gdb_tp_heap_buffer,
				      &target_tp_heap))
	fatal ("could get target heap head pointer");
    }

  ptr = target_tp_heap;
  target_tp_heap += size;

  /* Pad to 8-byte alignment.  */
  target_tp_heap = ((target_tp_heap + 7) & ~0x7);

  return ptr;
}

static CORE_ADDR
download_agent_expr (struct agent_expr *expr)
{
  CORE_ADDR expr_addr;
  CORE_ADDR expr_bytes;

  expr_addr = target_malloc (sizeof (*expr));
  write_inferior_memory (expr_addr, (unsigned char *) expr, sizeof (*expr));

  expr_bytes = target_malloc (expr->length);
  write_inferior_data_ptr (expr_addr + offsetof (struct agent_expr, bytes),
			   expr_bytes);
  write_inferior_memory (expr_bytes, expr->bytes, expr->length);

  return expr_addr;
}

/* Align V up to N bits.  */
#define UALIGN(V, N) (((V) + ((N) - 1)) & ~((N) - 1))

/* Sync tracepoint with IPA, but leave maintenance of linked list to caller.  */

static void
download_tracepoint_1 (struct tracepoint *tpoint)
{
  struct tracepoint target_tracepoint;
  CORE_ADDR tpptr = 0;

  gdb_assert (tpoint->type == fast_tracepoint
	      || tpoint->type == static_tracepoint);

  if (tpoint->cond != NULL && target_emit_ops () != NULL)
    {
      CORE_ADDR jentry, jump_entry;

      jentry = jump_entry = get_jump_space_head ();

      if (tpoint->cond != NULL)
	{
	  /* Pad to 8-byte alignment. (needed?)  */
	  /* Actually this should be left for the target to
	     decide.  */
	  jentry = UALIGN (jentry, 8);

	  compile_tracepoint_condition (tpoint, &jentry);
	}

      /* Pad to 8-byte alignment.  */
      jentry = UALIGN (jentry, 8);
      claim_jump_space (jentry - jump_entry);
    }

  target_tracepoint = *tpoint;

  tpptr = target_malloc (sizeof (*tpoint));
  tpoint->obj_addr_on_target = tpptr;

  /* Write the whole object.  We'll fix up its pointers in a bit.
     Assume no next for now.  This is fixed up above on the next
     iteration, if there's any.  */
  target_tracepoint.next = NULL;
  /* Need to clear this here too, since we're downloading the
     tracepoints before clearing our own copy.  */
  target_tracepoint.hit_count = 0;

  write_inferior_memory (tpptr, (unsigned char *) &target_tracepoint,
			 sizeof (target_tracepoint));

  if (tpoint->cond)
    write_inferior_data_ptr (tpptr + offsetof (struct tracepoint,
					       cond),
			     download_agent_expr (tpoint->cond));

  if (tpoint->numactions)
    {
      int i;
      CORE_ADDR actions_array;

      /* The pointers array.  */
      actions_array
	= target_malloc (sizeof (*tpoint->actions) * tpoint->numactions);
      write_inferior_data_ptr (tpptr + offsetof (struct tracepoint,
						 actions),
			       actions_array);

      /* Now for each pointer, download the action.  */
      for (i = 0; i < tpoint->numactions; i++)
	{
	  struct tracepoint_action *action = tpoint->actions[i];
	  CORE_ADDR ipa_action = action->ops->download (action);

	  if (ipa_action != 0)
	    write_inferior_data_ptr
	      (actions_array + i * sizeof (*tpoint->actions),
	       ipa_action);
	}
    }
}

#define IPA_PROTO_FAST_TRACE_FLAG 0
#define IPA_PROTO_FAST_TRACE_ADDR_ON_TARGET 2
#define IPA_PROTO_FAST_TRACE_JUMP_PAD 10
#define IPA_PROTO_FAST_TRACE_FJUMP_SIZE 18
#define IPA_PROTO_FAST_TRACE_FJUMP_INSN 22

/* Send a command to agent to download and install tracepoint TPOINT.  */

static int
tracepoint_send_agent (struct tracepoint *tpoint)
{
  char buf[IPA_CMD_BUF_SIZE];
  char *p;
  int i, ret;

  p = buf;
  strcpy (p, "FastTrace:");
  p += 10;

  COPY_FIELD_TO_BUF (p, tpoint, number);
  COPY_FIELD_TO_BUF (p, tpoint, address);
  COPY_FIELD_TO_BUF (p, tpoint, type);
  COPY_FIELD_TO_BUF (p, tpoint, enabled);
  COPY_FIELD_TO_BUF (p, tpoint, step_count);
  COPY_FIELD_TO_BUF (p, tpoint, pass_count);
  COPY_FIELD_TO_BUF (p, tpoint, numactions);
  COPY_FIELD_TO_BUF (p, tpoint, hit_count);
  COPY_FIELD_TO_BUF (p, tpoint, traceframe_usage);
  COPY_FIELD_TO_BUF (p, tpoint, compiled_cond);
  COPY_FIELD_TO_BUF (p, tpoint, orig_size);

  /* condition */
  p = agent_expr_send (p, tpoint->cond);

  /* tracepoint_action */
  for (i = 0; i < tpoint->numactions; i++)
    {
      struct tracepoint_action *action = tpoint->actions[i];

      p[0] = action->type;
      p = action->ops->send (&p[1], action);
    }

  get_jump_space_head ();
  /* Copy the value of GDB_JUMP_PAD_HEAD to command buffer, so that
     agent can use jump pad from it.  */
  if (tpoint->type == fast_tracepoint)
    {
      memcpy (p, &gdb_jump_pad_head, 8);
      p += 8;
    }

  ret = run_inferior_command (buf, (int) (ptrdiff_t) (p - buf));
  if (ret)
    return ret;

  if (strncmp (buf, "OK", 2) != 0)
    return 1;

  /* The value of tracepoint's target address is stored in BUF.  */
  memcpy (&tpoint->obj_addr_on_target,
	  &buf[IPA_PROTO_FAST_TRACE_ADDR_ON_TARGET], 8);

  if (tpoint->type == fast_tracepoint)
    {
      unsigned char *insn
	= (unsigned char *) &buf[IPA_PROTO_FAST_TRACE_FJUMP_INSN];
      int fjump_size;

     trace_debug ("agent: read from cmd_buf 0x%x 0x%x\n",
		  (unsigned int) tpoint->obj_addr_on_target,
		  (unsigned int) gdb_jump_pad_head);

      memcpy (&gdb_jump_pad_head, &buf[IPA_PROTO_FAST_TRACE_JUMP_PAD], 8);

      /* This has been done in agent.  We should also set up record for it.  */
      memcpy (&fjump_size, &buf[IPA_PROTO_FAST_TRACE_FJUMP_SIZE], 4);
      /* Wire it in.  */
      tpoint->handle
	= set_fast_tracepoint_jump (tpoint->address, insn, fjump_size);
    }

  return 0;
}

static void
download_tracepoint (struct tracepoint *tpoint)
{
  struct tracepoint *tp, *tp_prev;

  if (tpoint->type != fast_tracepoint
      && tpoint->type != static_tracepoint)
    return;

  download_tracepoint_1 (tpoint);

  /* Find the previous entry of TPOINT, which is fast tracepoint or
     static tracepoint.  */
  tp_prev = NULL;
  for (tp = tracepoints; tp != tpoint; tp = tp->next)
    {
      if (tp->type == fast_tracepoint || tp->type == static_tracepoint)
	tp_prev = tp;
    }

  if (tp_prev)
    {
      CORE_ADDR tp_prev_target_next_addr;

      /* Insert TPOINT after TP_PREV in IPA.  */
      if (read_inferior_data_pointer (tp_prev->obj_addr_on_target
				      + offsetof (struct tracepoint, next),
				      &tp_prev_target_next_addr))
	fatal ("error reading `tp_prev->next'");

      /* tpoint->next = tp_prev->next */
      write_inferior_data_ptr (tpoint->obj_addr_on_target
			       + offsetof (struct tracepoint, next),
			       tp_prev_target_next_addr);
      /* tp_prev->next = tpoint */
      write_inferior_data_ptr (tp_prev->obj_addr_on_target
			       + offsetof (struct tracepoint, next),
			       tpoint->obj_addr_on_target);
    }
  else
    /* First object in list, set the head pointer in the
       inferior.  */
    write_inferior_data_ptr (ipa_sym_addrs.addr_tracepoints,
			     tpoint->obj_addr_on_target);

}

static void
download_trace_state_variables (void)
{
  CORE_ADDR ptr = 0, prev_ptr = 0;
  struct trace_state_variable *tsv;

  /* Start out empty.  */
  write_inferior_data_ptr (ipa_sym_addrs.addr_trace_state_variables, 0);

  for (tsv = trace_state_variables; tsv != NULL; tsv = tsv->next)
    {
      struct trace_state_variable target_tsv;

      /* TSV's with a getter have been initialized equally in both the
	 inferior and GDBserver.  Skip them.  */
      if (tsv->getter != NULL)
	continue;

      target_tsv = *tsv;

      prev_ptr = ptr;
      ptr = target_malloc (sizeof (*tsv));

      if (tsv == trace_state_variables)
	{
	  /* First object in list, set the head pointer in the
	     inferior.  */

	  write_inferior_data_ptr (ipa_sym_addrs.addr_trace_state_variables,
				   ptr);
	}
      else
	{
	  write_inferior_data_ptr (prev_ptr
				   + offsetof (struct trace_state_variable,
					       next),
				   ptr);
	}

      /* Write the whole object.  We'll fix up its pointers in a bit.
	 Assume no next, fixup when needed.  */
      target_tsv.next = NULL;

      write_inferior_memory (ptr, (unsigned char *) &target_tsv,
			     sizeof (target_tsv));

      if (tsv->name != NULL)
	{
	  size_t size = strlen (tsv->name) + 1;
	  CORE_ADDR name_addr = target_malloc (size);
	  write_inferior_memory (name_addr,
				 (unsigned char *) tsv->name, size);
	  write_inferior_data_ptr (ptr
				   + offsetof (struct trace_state_variable,
					       name),
				   name_addr);
	}

      if (tsv->getter != NULL)
	{
	  fatal ("what to do with these?");
	}
    }

  if (prev_ptr != 0)
    {
      /* Fixup the next pointer in the last item in the list.  */
      write_inferior_data_ptr (prev_ptr
			       + offsetof (struct trace_state_variable,
					   next), 0);
    }
}

/* Upload complete trace frames out of the IP Agent's trace buffer
   into GDBserver's trace buffer.  This always uploads either all or
   no trace frames.  This is the counter part of
   `trace_alloc_trace_buffer'.  See its description of the atomic
   synching mechanism.  */

static void
upload_fast_traceframes (void)
{
  unsigned int ipa_traceframe_read_count, ipa_traceframe_write_count;
  unsigned int ipa_traceframe_read_count_racy, ipa_traceframe_write_count_racy;
  CORE_ADDR tf;
  struct ipa_trace_buffer_control ipa_trace_buffer_ctrl;
  unsigned int curr_tbctrl_idx;
  unsigned int ipa_trace_buffer_ctrl_curr;
  unsigned int ipa_trace_buffer_ctrl_curr_old;
  CORE_ADDR ipa_trace_buffer_ctrl_addr;
  struct breakpoint *about_to_request_buffer_space_bkpt;
  CORE_ADDR ipa_trace_buffer_lo;
  CORE_ADDR ipa_trace_buffer_hi;

  if (read_inferior_uinteger (ipa_sym_addrs.addr_traceframe_read_count,
			      &ipa_traceframe_read_count_racy))
    {
      /* This will happen in most targets if the current thread is
	 running.  */
      return;
    }

  if (read_inferior_uinteger (ipa_sym_addrs.addr_traceframe_write_count,
			      &ipa_traceframe_write_count_racy))
    return;

  trace_debug ("ipa_traceframe_count (racy area): %d (w=%d, r=%d)",
	       ipa_traceframe_write_count_racy
	       - ipa_traceframe_read_count_racy,
	       ipa_traceframe_write_count_racy,
	       ipa_traceframe_read_count_racy);

  if (ipa_traceframe_write_count_racy == ipa_traceframe_read_count_racy)
    return;

  about_to_request_buffer_space_bkpt
    = set_breakpoint_at (ipa_sym_addrs.addr_about_to_request_buffer_space,
			 NULL);

  if (read_inferior_uinteger (ipa_sym_addrs.addr_trace_buffer_ctrl_curr,
			      &ipa_trace_buffer_ctrl_curr))
    return;

  ipa_trace_buffer_ctrl_curr_old = ipa_trace_buffer_ctrl_curr;

  curr_tbctrl_idx = ipa_trace_buffer_ctrl_curr & ~GDBSERVER_FLUSH_COUNT_MASK;

  {
    unsigned int prev, counter;

    /* Update the token, with new counters, and the GDBserver stamp
       bit.  Alway reuse the current TBC index.  */
    prev = ipa_trace_buffer_ctrl_curr & GDBSERVER_FLUSH_COUNT_MASK_CURR;
    counter = (prev + 0x100) & GDBSERVER_FLUSH_COUNT_MASK_CURR;

    ipa_trace_buffer_ctrl_curr = (GDBSERVER_UPDATED_FLUSH_COUNT_BIT
				  | (prev << 12)
				  | counter
				  | curr_tbctrl_idx);
  }

  if (write_inferior_uinteger (ipa_sym_addrs.addr_trace_buffer_ctrl_curr,
			       ipa_trace_buffer_ctrl_curr))
    return;

  trace_debug ("Lib: Committed %08x -> %08x",
	       ipa_trace_buffer_ctrl_curr_old,
	       ipa_trace_buffer_ctrl_curr);

  /* Re-read these, now that we've installed the
     `about_to_request_buffer_space' breakpoint/lock.  A thread could
     have finished a traceframe between the last read of these
     counters and setting the breakpoint above.  If we start
     uploading, we never want to leave this function with
     traceframe_read_count != 0, otherwise, GDBserver could end up
     incrementing the counter tokens more than once (due to event loop
     nesting), which would break the IP agent's "effective" detection
     (see trace_alloc_trace_buffer).  */
  if (read_inferior_uinteger (ipa_sym_addrs.addr_traceframe_read_count,
			      &ipa_traceframe_read_count))
    return;
  if (read_inferior_uinteger (ipa_sym_addrs.addr_traceframe_write_count,
			      &ipa_traceframe_write_count))
    return;

  if (debug_threads)
    {
      trace_debug ("ipa_traceframe_count (blocked area): %d (w=%d, r=%d)",
		   ipa_traceframe_write_count - ipa_traceframe_read_count,
		   ipa_traceframe_write_count, ipa_traceframe_read_count);

      if (ipa_traceframe_write_count != ipa_traceframe_write_count_racy
	  || ipa_traceframe_read_count != ipa_traceframe_read_count_racy)
	trace_debug ("note that ipa_traceframe_count's parts changed");
    }

  /* Get the address of the current TBC object (the IP agent has an
     array of 3 such objects).  The index is stored in the TBC
     token.  */
  ipa_trace_buffer_ctrl_addr = ipa_sym_addrs.addr_trace_buffer_ctrl;
  ipa_trace_buffer_ctrl_addr
    += sizeof (struct ipa_trace_buffer_control) * curr_tbctrl_idx;

  if (read_inferior_memory (ipa_trace_buffer_ctrl_addr,
			    (unsigned char *) &ipa_trace_buffer_ctrl,
			    sizeof (struct ipa_trace_buffer_control)))
    return;

  if (read_inferior_data_pointer (ipa_sym_addrs.addr_trace_buffer_lo,
				  &ipa_trace_buffer_lo))
    return;
  if (read_inferior_data_pointer (ipa_sym_addrs.addr_trace_buffer_hi,
				  &ipa_trace_buffer_hi))
    return;

  /* Offsets are easier to grok for debugging than raw addresses,
     especially for the small trace buffer sizes that are useful for
     testing.  */
  trace_debug ("Lib: Trace buffer [%d] start=%d free=%d "
	       "endfree=%d wrap=%d hi=%d",
	       curr_tbctrl_idx,
	       (int) (ipa_trace_buffer_ctrl.start - ipa_trace_buffer_lo),
	       (int) (ipa_trace_buffer_ctrl.free - ipa_trace_buffer_lo),
	       (int) (ipa_trace_buffer_ctrl.end_free - ipa_trace_buffer_lo),
	       (int) (ipa_trace_buffer_ctrl.wrap - ipa_trace_buffer_lo),
	       (int) (ipa_trace_buffer_hi - ipa_trace_buffer_lo));

  /* Note that the IPA's buffer is always circular.  */

#define IPA_FIRST_TRACEFRAME() (ipa_trace_buffer_ctrl.start)

#define IPA_NEXT_TRACEFRAME_1(TF, TFOBJ)		\
  ((TF) + sizeof (struct traceframe) + (TFOBJ)->data_size)

#define IPA_NEXT_TRACEFRAME(TF, TFOBJ)					\
  (IPA_NEXT_TRACEFRAME_1 (TF, TFOBJ)					\
   - ((IPA_NEXT_TRACEFRAME_1 (TF, TFOBJ) >= ipa_trace_buffer_ctrl.wrap) \
      ? (ipa_trace_buffer_ctrl.wrap - ipa_trace_buffer_lo)		\
      : 0))

  tf = IPA_FIRST_TRACEFRAME ();

  while (ipa_traceframe_write_count - ipa_traceframe_read_count)
    {
      struct tracepoint *tpoint;
      struct traceframe *tframe;
      unsigned char *block;
      struct traceframe ipa_tframe;

      if (read_inferior_memory (tf, (unsigned char *) &ipa_tframe,
				offsetof (struct traceframe, data)))
	error ("Uploading: couldn't read traceframe at %s\n", paddress (tf));

      if (ipa_tframe.tpnum == 0)
	fatal ("Uploading: No (more) fast traceframes, but "
	       "ipa_traceframe_count == %u??\n",
	       ipa_traceframe_write_count - ipa_traceframe_read_count);

      /* Note that this will be incorrect for multi-location
	 tracepoints...  */
      tpoint = find_next_tracepoint_by_number (NULL, ipa_tframe.tpnum);

      tframe = add_traceframe (tpoint);
      if (tframe == NULL)
	{
	  trace_buffer_is_full = 1;
	  trace_debug ("Uploading: trace buffer is full");
	}
      else
	{
	  /* Copy the whole set of blocks in one go for now.  FIXME:
	     split this in smaller blocks.  */
	  block = add_traceframe_block (tframe, tpoint,
					ipa_tframe.data_size);
	  if (block != NULL)
	    {
	      if (read_inferior_memory (tf
					+ offsetof (struct traceframe, data),
					block, ipa_tframe.data_size))
		error ("Uploading: Couldn't read traceframe data at %s\n",
		       paddress (tf + offsetof (struct traceframe, data)));
	    }

	  trace_debug ("Uploading: traceframe didn't fit");
	  finish_traceframe (tframe);
	}

      tf = IPA_NEXT_TRACEFRAME (tf, &ipa_tframe);

      /* If we freed the traceframe that wrapped around, go back
	 to the non-wrap case.  */
      if (tf < ipa_trace_buffer_ctrl.start)
	{
	  trace_debug ("Lib: Discarding past the wraparound");
	  ipa_trace_buffer_ctrl.wrap = ipa_trace_buffer_hi;
	}
      ipa_trace_buffer_ctrl.start = tf;
      ipa_trace_buffer_ctrl.end_free = ipa_trace_buffer_ctrl.start;
      ++ipa_traceframe_read_count;

      if (ipa_trace_buffer_ctrl.start == ipa_trace_buffer_ctrl.free
	  && ipa_trace_buffer_ctrl.start == ipa_trace_buffer_ctrl.end_free)
	{
	  trace_debug ("Lib: buffer is fully empty.  "
		       "Trace buffer [%d] start=%d free=%d endfree=%d",
		       curr_tbctrl_idx,
		       (int) (ipa_trace_buffer_ctrl.start
			      - ipa_trace_buffer_lo),
		       (int) (ipa_trace_buffer_ctrl.free
			      - ipa_trace_buffer_lo),
		       (int) (ipa_trace_buffer_ctrl.end_free
			      - ipa_trace_buffer_lo));

	  ipa_trace_buffer_ctrl.start = ipa_trace_buffer_lo;
	  ipa_trace_buffer_ctrl.free = ipa_trace_buffer_lo;
	  ipa_trace_buffer_ctrl.end_free = ipa_trace_buffer_hi;
	  ipa_trace_buffer_ctrl.wrap = ipa_trace_buffer_hi;
	}

      trace_debug ("Uploaded a traceframe\n"
		   "Lib: Trace buffer [%d] start=%d free=%d "
		   "endfree=%d wrap=%d hi=%d",
		   curr_tbctrl_idx,
		   (int) (ipa_trace_buffer_ctrl.start - ipa_trace_buffer_lo),
		   (int) (ipa_trace_buffer_ctrl.free - ipa_trace_buffer_lo),
		   (int) (ipa_trace_buffer_ctrl.end_free
			  - ipa_trace_buffer_lo),
		   (int) (ipa_trace_buffer_ctrl.wrap - ipa_trace_buffer_lo),
		   (int) (ipa_trace_buffer_hi - ipa_trace_buffer_lo));
    }

  if (write_inferior_memory (ipa_trace_buffer_ctrl_addr,
			     (unsigned char *) &ipa_trace_buffer_ctrl,
			     sizeof (struct ipa_trace_buffer_control)))
    return;

  write_inferior_integer (ipa_sym_addrs.addr_traceframe_read_count,
			  ipa_traceframe_read_count);

  trace_debug ("Done uploading traceframes [%d]\n", curr_tbctrl_idx);

  pause_all (1);
  cancel_breakpoints ();

  delete_breakpoint (about_to_request_buffer_space_bkpt);
  about_to_request_buffer_space_bkpt = NULL;

  unpause_all (1);

  if (trace_buffer_is_full)
    stop_tracing ();
}
#endif

#ifdef IN_PROCESS_AGENT

IP_AGENT_EXPORT int ust_loaded;
IP_AGENT_EXPORT char cmd_buf[IPA_CMD_BUF_SIZE];

#ifdef HAVE_UST

/* Static tracepoints.  */

/* UST puts a "struct tracepoint" in the global namespace, which
   conflicts with our tracepoint.  Arguably, being a library, it
   shouldn't take ownership of such a generic name.  We work around it
   here.  */
#define tracepoint ust_tracepoint
#include <ust/ust.h>
#undef tracepoint

extern int serialize_to_text (char *outbuf, int bufsize,
			      const char *fmt, va_list ap);

#define GDB_PROBE_NAME "gdb"

/* We dynamically search for the UST symbols instead of linking them
   in.  This lets the user decide if the application uses static
   tracepoints, instead of always pulling libust.so in.  This vector
   holds pointers to all functions we care about.  */

static struct
{
  int (*serialize_to_text) (char *outbuf, int bufsize,
			    const char *fmt, va_list ap);

  int (*ltt_probe_register) (struct ltt_available_probe *pdata);
  int (*ltt_probe_unregister) (struct ltt_available_probe *pdata);

  int (*ltt_marker_connect) (const char *channel, const char *mname,
			     const char *pname);
  int (*ltt_marker_disconnect) (const char *channel, const char *mname,
				const char *pname);

  void (*marker_iter_start) (struct marker_iter *iter);
  void (*marker_iter_next) (struct marker_iter *iter);
  void (*marker_iter_stop) (struct marker_iter *iter);
  void (*marker_iter_reset) (struct marker_iter *iter);
} ust_ops;

#include <dlfcn.h>

/* Cast through typeof to catch incompatible API changes.  Since UST
   only builds with gcc, we can freely use gcc extensions here
   too.  */
#define GET_UST_SYM(SYM)					\
  do								\
    {								\
      if (ust_ops.SYM == NULL)					\
	ust_ops.SYM = (typeof (&SYM)) dlsym (RTLD_DEFAULT, #SYM);	\
      if (ust_ops.SYM == NULL)					\
	return 0;						\
    } while (0)

#define USTF(SYM) ust_ops.SYM

/* Get pointers to all libust.so functions we care about.  */

static int
dlsym_ust (void)
{
  GET_UST_SYM (serialize_to_text);

  GET_UST_SYM (ltt_probe_register);
  GET_UST_SYM (ltt_probe_unregister);
  GET_UST_SYM (ltt_marker_connect);
  GET_UST_SYM (ltt_marker_disconnect);

  GET_UST_SYM (marker_iter_start);
  GET_UST_SYM (marker_iter_next);
  GET_UST_SYM (marker_iter_stop);
  GET_UST_SYM (marker_iter_reset);

  ust_loaded = 1;
  return 1;
}

/* Given an UST marker, return the matching gdb static tracepoint.
   The match is done by address.  */

static struct tracepoint *
ust_marker_to_static_tracepoint (const struct marker *mdata)
{
  struct tracepoint *tpoint;

  for (tpoint = tracepoints; tpoint; tpoint = tpoint->next)
    {
      if (tpoint->type != static_tracepoint)
	continue;

      if (tpoint->address == (uintptr_t) mdata->location)
	return tpoint;
    }

  return NULL;
}

/* The probe function we install on lttng/ust markers.  Whenever a
   probed ust marker is hit, this function is called.  This is similar
   to gdb_collect, only for static tracepoints, instead of fast
   tracepoints.  */

static void
gdb_probe (const struct marker *mdata, void *probe_private,
	   struct registers *regs, void *call_private,
	   const char *fmt, va_list *args)
{
  struct tracepoint *tpoint;
  struct static_tracepoint_ctx ctx;

  /* Don't do anything until the trace run is completely set up.  */
  if (!tracing)
    {
      trace_debug ("gdb_probe: not tracing\n");
      return;
    }

  ctx.base.type = static_tracepoint;
  ctx.regcache_initted = 0;
  ctx.regs = regs;
  ctx.fmt = fmt;
  ctx.args = args;

  /* Wrap the regblock in a register cache (in the stack, we don't
     want to malloc here).  */
  ctx.regspace = alloca (ipa_tdesc->registers_size);
  if (ctx.regspace == NULL)
    {
      trace_debug ("Trace buffer block allocation failed, skipping");
      return;
    }

  tpoint = ust_marker_to_static_tracepoint (mdata);
  if (tpoint == NULL)
    {
      trace_debug ("gdb_probe: marker not known: "
		   "loc:0x%p, ch:\"%s\",n:\"%s\",f:\"%s\"",
		   mdata->location, mdata->channel,
		   mdata->name, mdata->format);
      return;
    }

  if (!tpoint->enabled)
    {
      trace_debug ("gdb_probe: tracepoint disabled");
      return;
    }

  ctx.tpoint = tpoint;

  trace_debug ("gdb_probe: collecting marker: "
	       "loc:0x%p, ch:\"%s\",n:\"%s\",f:\"%s\"",
	       mdata->location, mdata->channel,
	       mdata->name, mdata->format);

  /* Test the condition if present, and collect if true.  */
  if (tpoint->cond == NULL
      || condition_true_at_tracepoint ((struct tracepoint_hit_ctx *) &ctx,
				       tpoint))
    {
      collect_data_at_tracepoint ((struct tracepoint_hit_ctx *) &ctx,
				  tpoint->address, tpoint);

      if (stopping_tracepoint
	  || trace_buffer_is_full
	  || expr_eval_result != expr_eval_no_error)
	stop_tracing ();
    }
  else
    {
      /* If there was a condition and it evaluated to false, the only
	 way we would stop tracing is if there was an error during
	 condition expression evaluation.  */
      if (expr_eval_result != expr_eval_no_error)
	stop_tracing ();
    }
}

/* Called if the gdb static tracepoint requested collecting "$_sdata",
   static tracepoint string data.  This is a string passed to the
   tracing library by the user, at the time of the tracepoint marker
   call.  E.g., in the UST marker call:

     trace_mark (ust, bar33, "str %s", "FOOBAZ");

   the collected data is "str FOOBAZ".
*/

static void
collect_ust_data_at_tracepoint (struct tracepoint_hit_ctx *ctx,
				struct traceframe *tframe)
{
  struct static_tracepoint_ctx *umd = (struct static_tracepoint_ctx *) ctx;
  unsigned char *bufspace;
  int size;
  va_list copy;
  unsigned short blocklen;

  if (umd == NULL)
    {
      trace_debug ("Wanted to collect static trace data, "
		   "but there's no static trace data");
      return;
    }

  va_copy (copy, *umd->args);
  size = USTF(serialize_to_text) (NULL, 0, umd->fmt, copy);
  va_end (copy);

  trace_debug ("Want to collect ust data");

  /* 'S' + size + string */
  bufspace = add_traceframe_block (tframe, umd->tpoint,
				   1 + sizeof (blocklen) + size + 1);
  if (bufspace == NULL)
    {
      trace_debug ("Trace buffer block allocation failed, skipping");
      return;
    }

  /* Identify a static trace data block.  */
  *bufspace = 'S';

  blocklen = size + 1;
  memcpy (bufspace + 1, &blocklen, sizeof (blocklen));

  va_copy (copy, *umd->args);
  USTF(serialize_to_text) ((char *) bufspace + 1 + sizeof (blocklen),
			   size + 1, umd->fmt, copy);
  va_end (copy);

  trace_debug ("Storing static tracepoint data in regblock: %s",
	       bufspace + 1 + sizeof (blocklen));
}

/* The probe to register with lttng/ust.  */
static struct ltt_available_probe gdb_ust_probe =
  {
    GDB_PROBE_NAME,
    NULL,
    gdb_probe,
  };

#endif /* HAVE_UST */
#endif /* IN_PROCESS_AGENT */

#ifndef IN_PROCESS_AGENT

/* Ask the in-process agent to run a command.  Since we don't want to
   have to handle the IPA hitting breakpoints while running the
   command, we pause all threads, remove all breakpoints, and then set
   the helper thread re-running.  We communicate with the helper
   thread by means of direct memory xfering, and a socket for
   synchronization.  */

static int
run_inferior_command (char *cmd, int len)
{
  int err = -1;
  int pid = ptid_get_pid (current_ptid);

  trace_debug ("run_inferior_command: running: %s", cmd);

  pause_all (0);
  uninsert_all_breakpoints ();

  err = agent_run_command (pid, (const char *) cmd, len);

  reinsert_all_breakpoints ();
  unpause_all (0);

  return err;
}

#else /* !IN_PROCESS_AGENT */

#include <sys/socket.h>
#include <sys/un.h>

#ifndef UNIX_PATH_MAX
#define UNIX_PATH_MAX sizeof(((struct sockaddr_un *) NULL)->sun_path)
#endif

/* Where we put the socked used for synchronization.  */
#define SOCK_DIR P_tmpdir

/* Thread ID of the helper thread.  GDBserver reads this to know which
   is the help thread.  This is an LWP id on Linux.  */
int helper_thread_id;

static int
init_named_socket (const char *name)
{
  int result, fd;
  struct sockaddr_un addr;

  result = fd = socket (PF_UNIX, SOCK_STREAM, 0);
  if (result == -1)
    {
      warning ("socket creation failed: %s", strerror (errno));
      return -1;
    }

  addr.sun_family = AF_UNIX;

  strncpy (addr.sun_path, name, UNIX_PATH_MAX);
  addr.sun_path[UNIX_PATH_MAX - 1] = '\0';

  result = access (name, F_OK);
  if (result == 0)
    {
      /* File exists.  */
      result = unlink (name);
      if (result == -1)
	{
	  warning ("unlink failed: %s", strerror (errno));
	  close (fd);
	  return -1;
	}
      warning ("socket %s already exists; overwriting", name);
    }

  result = bind (fd, (struct sockaddr *) &addr, sizeof (addr));
  if (result == -1)
    {
      warning ("bind failed: %s", strerror (errno));
      close (fd);
      return -1;
    }

  result = listen (fd, 1);
  if (result == -1)
    {
      warning ("listen: %s", strerror (errno));
      close (fd);
      return -1;
    }

  return fd;
}

static char agent_socket_name[UNIX_PATH_MAX];

static int
gdb_agent_socket_init (void)
{
  int result, fd;

  result = xsnprintf (agent_socket_name, UNIX_PATH_MAX, "%s/gdb_ust%d",
		      SOCK_DIR, getpid ());
  if (result >= UNIX_PATH_MAX)
    {
      trace_debug ("string overflow allocating socket name");
      return -1;
    }

  fd = init_named_socket (agent_socket_name);
  if (fd < 0)
    warning ("Error initializing named socket (%s) for communication with the "
	     "ust helper thread. Check that directory exists and that it "
	     "is writable.", agent_socket_name);

  return fd;
}

#ifdef HAVE_UST

/* The next marker to be returned on a qTsSTM command.  */
static const struct marker *next_st;

/* Returns the first known marker.  */

struct marker *
first_marker (void)
{
  struct marker_iter iter;

  USTF(marker_iter_reset) (&iter);
  USTF(marker_iter_start) (&iter);

  return iter.marker;
}

/* Returns the marker following M.  */

const struct marker *
next_marker (const struct marker *m)
{
  struct marker_iter iter;

  USTF(marker_iter_reset) (&iter);
  USTF(marker_iter_start) (&iter);

  for (; iter.marker != NULL; USTF(marker_iter_next) (&iter))
    {
      if (iter.marker == m)
	{
	  USTF(marker_iter_next) (&iter);
	  return iter.marker;
	}
    }

  return NULL;
}

/* Return an hexstr version of the STR C string, fit for sending to
   GDB.  */

static char *
cstr_to_hexstr (const char *str)
{
  int len = strlen (str);
  char *hexstr = xmalloc (len * 2 + 1);
  convert_int_to_ascii ((gdb_byte *) str, hexstr, len);
  return hexstr;
}

/* Compose packet that is the response to the qTsSTM/qTfSTM/qTSTMat
   packets.  */

static void
response_ust_marker (char *packet, const struct marker *st)
{
  char *strid, *format, *tmp;

  next_st = next_marker (st);

  tmp = xmalloc (strlen (st->channel) + 1 +
		 strlen (st->name) + 1);
  sprintf (tmp, "%s/%s", st->channel, st->name);

  strid = cstr_to_hexstr (tmp);
  free (tmp);

  format = cstr_to_hexstr (st->format);

  sprintf (packet, "m%s:%s:%s",
	   paddress ((uintptr_t) st->location),
	   strid,
	   format);

  free (strid);
  free (format);
}

/* Return the first static tracepoint, and initialize the state
   machine that will iterate through all the static tracepoints.  */

static void
cmd_qtfstm (char *packet)
{
  trace_debug ("Returning first trace state variable definition");

  if (first_marker ())
    response_ust_marker (packet, first_marker ());
  else
    strcpy (packet, "l");
}

/* Return additional trace state variable definitions. */

static void
cmd_qtsstm (char *packet)
{
  trace_debug ("Returning static tracepoint");

  if (next_st)
    response_ust_marker (packet, next_st);
  else
    strcpy (packet, "l");
}

/* Disconnect the GDB probe from a marker at a given address.  */

static void
unprobe_marker_at (char *packet)
{
  char *p = packet;
  ULONGEST address;
  struct marker_iter iter;

  p += sizeof ("unprobe_marker_at:") - 1;

  p = unpack_varlen_hex (p, &address);

  USTF(marker_iter_reset) (&iter);
  USTF(marker_iter_start) (&iter);
  for (; iter.marker != NULL; USTF(marker_iter_next) (&iter))
    if ((uintptr_t ) iter.marker->location == address)
      {
	int result;

	result = USTF(ltt_marker_disconnect) (iter.marker->channel,
					      iter.marker->name,
					      GDB_PROBE_NAME);
	if (result < 0)
	  warning ("could not disable marker %s/%s",
		   iter.marker->channel, iter.marker->name);
	break;
      }
}

/* Connect the GDB probe to a marker at a given address.  */

static int
probe_marker_at (char *packet)
{
  char *p = packet;
  ULONGEST address;
  struct marker_iter iter;
  struct marker *m;

  p += sizeof ("probe_marker_at:") - 1;

  p = unpack_varlen_hex (p, &address);

  USTF(marker_iter_reset) (&iter);

  for (USTF(marker_iter_start) (&iter), m = iter.marker;
       m != NULL;
       USTF(marker_iter_next) (&iter), m = iter.marker)
    if ((uintptr_t ) m->location == address)
      {
	int result;

	trace_debug ("found marker for address.  "
		     "ltt_marker_connect (marker = %s/%s)",
		     m->channel, m->name);

	result = USTF(ltt_marker_connect) (m->channel, m->name,
					   GDB_PROBE_NAME);
	if (result && result != -EEXIST)
	  trace_debug ("ltt_marker_connect (marker = %s/%s, errno = %d)",
		       m->channel, m->name, -result);

	if (result < 0)
	  {
	    sprintf (packet, "E.could not connect marker: channel=%s, name=%s",
		     m->channel, m->name);
	    return -1;
	  }

	strcpy (packet, "OK");
	return 0;
      }

  sprintf (packet, "E.no marker found at 0x%s", paddress (address));
  return -1;
}

static int
cmd_qtstmat (char *packet)
{
  char *p = packet;
  ULONGEST address;
  struct marker_iter iter;
  struct marker *m;

  p += sizeof ("qTSTMat:") - 1;

  p = unpack_varlen_hex (p, &address);

  USTF(marker_iter_reset) (&iter);

  for (USTF(marker_iter_start) (&iter), m = iter.marker;
       m != NULL;
       USTF(marker_iter_next) (&iter), m = iter.marker)
    if ((uintptr_t ) m->location == address)
      {
	response_ust_marker (packet, m);
	return 0;
      }

  strcpy (packet, "l");
  return -1;
}

static void
gdb_ust_init (void)
{
  if (!dlsym_ust ())
    return;

  USTF(ltt_probe_register) (&gdb_ust_probe);
}

#endif /* HAVE_UST */

#include <sys/syscall.h>
#include <stdlib.h>

static void
gdb_agent_remove_socket (void)
{
  unlink (agent_socket_name);
}

/* Helper thread of agent.  */

static void *
gdb_agent_helper_thread (void *arg)
{
  int listen_fd;

  atexit (gdb_agent_remove_socket);

  while (1)
    {
      listen_fd = gdb_agent_socket_init ();

      if (helper_thread_id == 0)
	helper_thread_id = syscall (SYS_gettid);

      if (listen_fd == -1)
	{
	  warning ("could not create sync socket\n");
	  break;
	}

      while (1)
	{
	  socklen_t tmp;
	  struct sockaddr_un sockaddr;
	  int fd;
	  char buf[1];
	  int ret;
	  int stop_loop = 0;

	  tmp = sizeof (sockaddr);

	  do
	    {
	      fd = accept (listen_fd, &sockaddr, &tmp);
	    }
	  /* It seems an ERESTARTSYS can escape out of accept.  */
	  while (fd == -512 || (fd == -1 && errno == EINTR));

	  if (fd < 0)
	    {
	      warning ("Accept returned %d, error: %s\n",
		       fd, strerror (errno));
	      break;
	    }

	  do
	    {
	      ret = read (fd, buf, 1);
	    } while (ret == -1 && errno == EINTR);

	  if (ret == -1)
	    {
	      warning ("reading socket (fd=%d) failed with %s",
		       fd, strerror (errno));
	      close (fd);
	      break;
	    }

	  if (cmd_buf[0])
	    {
	      if (strncmp ("close", cmd_buf, 5) == 0)
		{
		  stop_loop = 1;
		}
#ifdef HAVE_UST
	      else if (strcmp ("qTfSTM", cmd_buf) == 0)
		{
		  cmd_qtfstm (cmd_buf);
		}
	      else if (strcmp ("qTsSTM", cmd_buf) == 0)
		{
		  cmd_qtsstm (cmd_buf);
		}
	      else if (strncmp ("unprobe_marker_at:",
				cmd_buf,
				sizeof ("unprobe_marker_at:") - 1) == 0)
		{
		  unprobe_marker_at (cmd_buf);
		}
	      else if (strncmp ("probe_marker_at:",
				cmd_buf,
				sizeof ("probe_marker_at:") - 1) == 0)
		{
		  probe_marker_at (cmd_buf);
		}
	      else if (strncmp ("qTSTMat:",
				cmd_buf,
				sizeof ("qTSTMat:") - 1) == 0)
		{
		  cmd_qtstmat (cmd_buf);
		}
#endif /* HAVE_UST */
	    }

	  /* Fix compiler's warning: ignoring return value of 'write'.  */
	  ret = write (fd, buf, 1);
	  close (fd);

	  if (stop_loop)
	    {
	      close (listen_fd);
	      unlink (agent_socket_name);

	      /* Sleep endlessly to wait the whole inferior stops.  This
		 thread can not exit because GDB or GDBserver may still need
		 'current_inferior' (representing this thread) to access
		 inferior memory.  Otherwise, this thread exits earlier than
		 other threads, and 'current_inferior' is set to NULL.  */
	      while (1)
		sleep (10);
	    }
	}
    }

  return NULL;
}

#include <signal.h>
#include <pthread.h>

IP_AGENT_EXPORT int gdb_agent_capability = AGENT_CAPA_STATIC_TRACE;

static void
gdb_agent_init (void)
{
  int res;
  pthread_t thread;
  sigset_t new_mask;
  sigset_t orig_mask;

  /* We want the helper thread to be as transparent as possible, so
     have it inherit an all-signals-blocked mask.  */

  sigfillset (&new_mask);
  res = pthread_sigmask (SIG_SETMASK, &new_mask, &orig_mask);
  if (res)
    fatal ("pthread_sigmask (1) failed: %s", strerror (res));

  res = pthread_create (&thread,
			NULL,
			gdb_agent_helper_thread,
			NULL);

  res = pthread_sigmask (SIG_SETMASK, &orig_mask, NULL);
  if (res)
    fatal ("pthread_sigmask (2) failed: %s", strerror (res));

  while (helper_thread_id == 0)
    usleep (1);

#ifdef HAVE_UST
  gdb_ust_init ();
#endif
}

#include <sys/mman.h>
#include <fcntl.h>

IP_AGENT_EXPORT char *gdb_tp_heap_buffer;
IP_AGENT_EXPORT char *gdb_jump_pad_buffer;
IP_AGENT_EXPORT char *gdb_jump_pad_buffer_end;
IP_AGENT_EXPORT char *gdb_trampoline_buffer;
IP_AGENT_EXPORT char *gdb_trampoline_buffer_end;
IP_AGENT_EXPORT char *gdb_trampoline_buffer_error;

/* Record the result of getting buffer space for fast tracepoint
   trampolines.  Any error message is copied, since caller may not be
   using persistent storage.  */

void
set_trampoline_buffer_space (CORE_ADDR begin, CORE_ADDR end, char *errmsg)
{
  gdb_trampoline_buffer = (char *) (uintptr_t) begin;
  gdb_trampoline_buffer_end = (char *) (uintptr_t) end;
  if (errmsg)
    strncpy (gdb_trampoline_buffer_error, errmsg, 99);
  else
    strcpy (gdb_trampoline_buffer_error, "no buffer passed");
}

static void __attribute__ ((constructor))
initialize_tracepoint_ftlib (void)
{
  initialize_tracepoint ();

  gdb_agent_init ();
}

#endif /* IN_PROCESS_AGENT */

/* Return a timestamp, expressed as microseconds of the usual Unix
   time.  (As the result is a 64-bit number, it will not overflow any
   time soon.)  */

static LONGEST
get_timestamp (void)
{
   struct timeval tv;

   if (gettimeofday (&tv, 0) != 0)
     return -1;
   else
     return (LONGEST) tv.tv_sec * 1000000 + tv.tv_usec;
}

void
initialize_tracepoint (void)
{
  /* Start with the default size.  */
  init_trace_buffer (DEFAULT_TRACE_BUFFER_SIZE);

  /* Wire trace state variable 1 to be the timestamp.  This will be
     uploaded to GDB upon connection and become one of its trace state
     variables.  (In case you're wondering, if GDB already has a trace
     variable numbered 1, it will be renumbered.)  */
  create_trace_state_variable (1, 0);
  set_trace_state_variable_name (1, "trace_timestamp");
  set_trace_state_variable_getter (1, get_timestamp);

#ifdef IN_PROCESS_AGENT
  {
    uintptr_t addr;
    int pagesize;

    pagesize = sysconf (_SC_PAGE_SIZE);
    if (pagesize == -1)
      fatal ("sysconf");

    gdb_tp_heap_buffer = xmalloc (5 * 1024 * 1024);

#define SCRATCH_BUFFER_NPAGES 20

    /* Allocate scratch buffer aligned on a page boundary, at a low
       address (close to the main executable's code).  */
    for (addr = pagesize; addr != 0; addr += pagesize)
      {
	gdb_jump_pad_buffer = mmap ((void *) addr, pagesize * SCRATCH_BUFFER_NPAGES,
				    PROT_READ | PROT_WRITE | PROT_EXEC,
				    MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED,
				    -1, 0);
	if (gdb_jump_pad_buffer != MAP_FAILED)
	  break;
      }

    if (addr == 0)
      fatal ("\
initialize_tracepoint: mmap'ing jump pad buffer failed with %s",
	     strerror (errno));

    gdb_jump_pad_buffer_end = gdb_jump_pad_buffer + pagesize * SCRATCH_BUFFER_NPAGES;
  }

  gdb_trampoline_buffer = gdb_trampoline_buffer_end = 0;

  /* It's not a fatal error for something to go wrong with trampoline
     buffer setup, but it can be mysterious, so create a channel to
     report back on what went wrong, using a fixed size since we may
     not be able to allocate space later when the problem occurs.  */
  gdb_trampoline_buffer_error = xmalloc (IPA_BUFSIZ);

  strcpy (gdb_trampoline_buffer_error, "No errors reported");

  initialize_low_tracepoint ();
#endif
}
@


1.83
log
@[gdbserver] Split a new tracepoint.h file out of server.h.

gdb/gdbserver/
2013-09-05  Pedro Alves  <palves@@redhat.com>

	* ax.c, linux-low.c, linux-x86-low.c, server.c: Include
	tracepoint.h.
	* server.h (IPA_BUFSIZ, initialize_tracepoint, tracing)
	(disconnected_tracing, tracepoint_look_up_symbols, stop_tracing
	(handle_tracepoint_general_set, handle_tracepoint_query)
	(tracepoint_finished_step, tracepoint_was_hit)
	(release_while_stepping_state_list, current_traceframe)
	(in_readonly_region, traceframe_read_mem)
	(fetch_traceframe_registers, traceframe_read_sdata)
	(traceframe_read_info, struct fast_tpoint_collect_status)
	(fast_tracepoint_collecting, force_unlock_trace_buffer)
	(handle_tracepoit_bkpts, initialize_low_tracepoint)
	(supply_fast_tracepoint_registers)
	(supply_static_tracepoint_registers, set_trampoline_buffer_space)
	(ipa_tdesc, claim_trampoline_space)
	(have_fast_tracepoint_trampoline_buffer, gdb_agent_about_to_close)
	(agent_mem_read, agent_get_trace_state_variable_value)
	(agent_set_trace_state_variable_value, agent_tsv_read)
	(agent_mem_read_string, get_raw_reg_func_addr)
	(get_get_tsv_func_addr, get_set_tsv_func_addr): Move to ...
	* tracepoint.h: ... this new file.
@
text
@d6026 1
a6026 1
	      (actions_array + i * sizeof (sizeof (*tpoint->actions)),
@


1.82
log
@[gdbserver] Fix trace-buffer-size.exp FAILs.

I'm seeing trace-buffer-size.exp failing (with gdbserver):

  (gdb) PASS: gdb.trace/trace-buffer-size.exp: tstatus check 2
  show trace-buffer-size 4
  Requested size of trace buffer is 4.
  (gdb) PASS: gdb.trace/trace-buffer-size.exp: show trace buffer size
  set trace-buffer-size -1
  memory clobbered past end of allocated block
  Remote connection closed
  (gdb) FAIL: gdb.trace/trace-buffer-size.exp: set trace buffer size 2
  set trace-buffer-size unlimited
  (gdb) PASS: gdb.trace/trace-buffer-size.exp: set trace-buffer-size unlimited

That "memory clobbered past end of allocated block" is mcheck triggering.

Valgrind shows:

  ==23624== Invalid write of size 1
  ==23624==    at 0x418DD8: clear_trace_buffer (tracepoint.c:1443)
  ==23624==    by 0x418F3A: init_trace_buffer (tracepoint.c:1497)
  ==23624==    by 0x41D95B: cmd_bigqtbuffer_size (tracepoint.c:4061)
  ==23624==    by 0x41DEEC: handle_tracepoint_general_set (tracepoint.c:4193)

clear_trace_buffer does:

  static void
  clear_trace_buffer (void)
  {
    trace_buffer_start = trace_buffer_lo;
    trace_buffer_free = trace_buffer_lo;
    trace_buffer_end_free = trace_buffer_hi;
    trace_buffer_wrap = trace_buffer_hi;
    /* A traceframe with zeroed fields marks the end of trace data.  */
    ((struct traceframe *) trace_buffer_free)->tpnum = 0;
    ((struct traceframe *) trace_buffer_free)->data_size = 0;
    traceframe_read_count = traceframe_write_count = 0;
    traceframes_created = 0;
  }

And the tpnum+data_size fields are over 4 bytes...  This fixes it by
ensuring we allocate space at least for an EOB.  We have code
elsewhere that relies on the EOB being present (like e.g.,
find_traceframe), so this seems simplest.

gdb/gdbserver/
2013-09-02  Pedro Alves  <palves@@redhat.com>

	* tracepoint.c (TRACEFRAME_EOB_MARKER_SIZE): New macro.
	(init_trace_buffer): Ensure at least TRACEFRAME_EOB_MARKER_SIZE is
	allocated.
	(trace_buffer_alloc): Use TRACEFRAME_EOB_MARKER_SIZE.
@
text
@d20 1
@


1.81
log
@	Fix trace status to output username without trailing colon.
@
text
@d985 4
d1494 2
d1498 5
a1502 2
  /* If we already have a trace buffer, try realloc'ing.  */
  trace_buffer_lo = xrealloc (trace_buffer_lo, bufsize);
d1504 1
a1504 1
  trace_buffer_hi = trace_buffer_lo + bufsize;
d1544 1
a1544 1
  amt += sizeof (struct traceframe);
@


1.80
log
@	Fix trace-status to output proper start-time and stop-time.
@
text
@d3659 1
a3659 1
	   "username:%s:;notes:%s:",
@


1.79
log
@gdb/

2013-06-26  Pedro Alves  <pedro@@codesourcery.com>
	    Yao Qi  <yao@@codesourcery.com>

	* ctf.c (ctf_traceframe_info): Push trace state variables
	present in the trace data into the traceframe info object.
	* breakpoint.c (DEF_VEC_I): Remove.
	* common/filestuff.c (DEF_VEC_I): Likewise.
	* dwarf2loc.c (DEF_VEC_I): Likewise.
	* mi/mi-main.c (DEF_VEC_I): Likewise.
	* common/gdb_vecs.h (DEF_VEC_I): Define vector for int.
	* features/traceframe-info.dtd: Add tvar element and its
	attributes.
	* tracepoint.c (free_traceframe_info): Free vector 'tvars'.
	(build_traceframe_info): Push trace state variables present in the
	trace data into the traceframe info object.
	(traceframe_info_start_tvar): New function.
	(tvar_attributes): New.
	(traceframe_info_children): Add "tvar" element.
	* tracepoint.h (struct traceframe_info) <tvars>: New field.

	* NEWS: Mention the change in GDB and GDBserver.

gdb/doc:

2013-06-26  Pedro Alves  <pedro@@codesourcery.com>

	* gdb.texinfo (Traceframe Info Format): Document tvar element and
	its attributes.

gdb/gdbserver:

2013-06-26  Pedro Alves  <pedro@@codesourcery.com>

	* tracepoint.c (build_traceframe_info_xml): Output trace state
	variables present in the trace buffer.
@
text
@d3666 2
a3667 1
	   plongest (tracing_start_time), plongest (tracing_stop_time),
@


1.78
log
@[GDBserver] Multi-process + multi-arch

This patch makes GDBserver support multi-process + biarch.

Currently, if you're debugging more than one process at once with a
single gdbserver (in extended-remote mode), then all processes must
have the same architecture (e.g., 64-bit vs 32-bit).  Otherwise, you
see this:

Added inferior 2
[Switching to inferior 2 [<null>] (<noexec>)]
Reading symbols from /home/pedro/gdb/tests/main32...done.
Temporary breakpoint 2 at 0x4004cf: main. (2 locations)
Starting program: /home/pedro/gdb/tests/main32
warning: Selected architecture i386 is not compatible with reported target architecture i386:x86-64
warning: Architecture rejected target-supplied description
Remote 'g' packet reply is too long: 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000090cfffff0000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000b042f7460000000000020000230000002b0000002b0000002b000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007f03000000000000ffff0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000801f00003b0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
... etc, etc ...

Even though the process was running a 32-bit program, GDBserver sent
back to GDB a register set in 64-bit layout.

A patch (http://sourceware.org/ml/gdb-patches/2012-11/msg00228.html) a
while ago made GDB track a target_gdbarch per inferior, and as
consequence, fetch a target description per-inferior.  This patch is
the GDBserver counterpart, that makes GDBserver keep track of each
process'es XML target description and register layout.  So in the
example above, GDBserver will send the correct register set in 32-bit
layout to GDB.

A new "struct target_desc" object (tdesc for short) is added, that
holds the target description and register layout information about
each process.  Each `struct process_info' holds a pointer to a target
description.  The regcache also gains a pointer to a target
description, mainly for convenience, and parallel with GDB (and
possible future support for programs that flip processor modes).

The low target's arch_setup routines are responsible for setting the
process'es correct tdesc.  This isn't that much different to how
things were done before, except that instead of detecting the inferior
process'es architecture and calling the corresponding
init_registers_FOO routine, which would change the regcache layout
globals and recreate the threads' regcaches, the regcache.c globals
are gone, and the init_registers_$BAR routines now each initialize a
separate global struct target_desc object (one for each arch variant
GDBserver supports), and so all the init_registers_$BAR routines that
are built into GDBserver are called early at GDBserver startup time
(similarly to how GDB handles its built-in target descriptions), and
then the arch_setup routine is responsible for making
process_info->tdesc point to one of these target description globals.
The regcache module is all parameterized to get the regcache's layout
from the tdesc object instead of the old register_bytes, etc. globals.

The threads' regcaches are now created lazily.  The old scheme where
we created each of them when we added a new thread doesn't work
anymore, because we add the main thread/lwp before we see it stop for
the first time, and it is only when we see the thread stop for the
first time that we have a chance of determining the inferior's
architecture (through the_low_target.arch_setup).  Therefore when we
add the main thread we don't know which architecture/tdesc its
regcache should have.

This patch makes the gdb.multi/multi-arch.exp test now pass against
(extended-remote) GDBserver.  It currently fails, without this patch.

The IPA also uses the regcache, so it gains a new global struct
target_desc pointer, which points at the description of the process it
is loaded in.

Re. the linux-low.c & friends changes.  Since the register map
etc. may differ between processes (64-bit vs 32-bit) etc., the
linux_target_ops num_regs, regmap and regset_bitmap data fields are no
longer sufficient.  A new method is added in their place that returns
a pointer to a new struct that includes all info linux-low.c needs to
access registers of the current inferior.

The patch/discussion that originally introduced
linux-low.c:disabled_regsets mentions that the disabled_regsets set
may be different per mode (in a biarch setup), and indeed that is
cleared whenever we start a new (first) inferior, so that global is
moved as well behind the new `struct regs_info'.

On the x86 side:

I simply replaced the i387-fp.c:num_xmm_registers global with a check
for 64-bit or 32-bit process, which is equivalent to how the global
was set.  This avoided coming up with some more general mechanism that
would work for all targets that use this module (GNU/Linux, Windows,
etc.).

Tested:

  GNU/Linux IA64
  GNU/Linux MIPS64
  GNU/Linux PowerPC (Fedora 16)
  GNU/Linux s390x (Fedora 16)
  GNU/Linux sparc64 (Debian)
  GNU/Linux x86_64, -m64 and -m32 (Fedora 17)

Cross built, and smoke tested:

  i686-w64-mingw32, under Wine.
  GNU/Linux TI C6x, by Yao Qi.

Cross built but otherwise not tested:

  aarch64-linux-gnu
  arm-linux-gnu
  m68k-linux
  nios2-linux-gnu
  sh-linux-gnu
  spu
  tilegx-unknown-linux-gnu

Completely untested:

  GNU/Linux Blackfin
  GNU/Linux CRIS
  GNU/Linux CRISv32
  GNU/Linux TI Xtensa
  GNU/Linux M32R
  LynxOS
  QNX NTO

gdb/gdbserver/
2013-06-07  Pedro Alves  <palves@@redhat.com>

	* Makefile.in (OBS): Add tdesc.o.
	(IPA_OBJS): Add tdesc-ipa.o.
	(tdesc-ipa.o): New rule.
	* ax.c (gdb_eval_agent_expr): Adjust register_size call to new
	interface.
	* linux-low.c (new_inferior): Delete.
	(disabled_regsets, num_regsets): Delete.
	(linux_add_process): Adjust to set the new per-process
	new_inferior flag.
	(linux_detach_one_lwp): Adjust to call regcache_invalidate_thread.
	(linux_wait_for_lwp): Adjust.  Only call arch_setup if the event
	was a stop.  When calling arch_setup, switch the current inferior
	to the thread that got an event.
	(linux_resume_one_lwp): Adjust to call regcache_invalidate_thread.
	(regsets_fetch_inferior_registers)
	(regsets_store_inferior_registers): New regsets_info parameter.
	Adjust to use it.
	(linux_register_in_regsets): New regs_info parameter.  Adjust to
	use it.
	(register_addr, fetch_register, store_register): New usrregs_info
	parameter.  Adjust to use it.
	(usr_fetch_inferior_registers, usr_store_inferior_registers): New
	parameter regs_info.  Adjust to use it.
	(linux_fetch_registers): Get the current inferior's regs_info, and
	adjust to use it.
	(linux_store_registers): Ditto.
	[HAVE_LINUX_REGSETS] (initialize_regsets_info): New.
	(initialize_low): Don't initialize the target_regsets here.  Call
	initialize_low_arch.
	* linux-low.h (target_regsets): Delete declaration.
	(struct regsets_info): New.
	(struct usrregs_info): New.
	(struct regs_info): New.
	(struct process_info_private) <new_inferior>: New field.
	(struct linux_target_ops): Delete the num_regs, regmap, and
	regset_bitmap fields.  New field regs_info.
	[HAVE_LINUX_REGSETS] (initialize_regsets_info): Declare.
	* i387-fp.c (num_xmm_registers): Delete.
	(i387_cache_to_fsave, i387_fsave_to_cache): Adjust find_regno
	calls to new interface.
	(i387_cache_to_fxsave, i387_cache_to_xsave, i387_fxsave_to_cache)
	(i387_xsave_to_cache): Adjust find_regno calls to new interface.
	Infer the number of xmm registers from the regcache's target
	description.
	* i387-fp.h (num_xmm_registers): Delete.
	* inferiors.c (add_thread): Don't install the thread's regcache
	here.
	* proc-service.c (gregset_info): Fetch the current inferior's
	regs_info.  Adjust to use it.
	* regcache.c: Include tdesc.h.
	(register_bytes, reg_defs, num_registers)
	(gdbserver_expedite_regs): Delete.
	(get_thread_regcache): If the thread doesn't have a regcache yet,
	create one, instead of aborting gdbserver.
	(regcache_invalidate_one): Rename to ...
	(regcache_invalidate_thread): ... this.
	(regcache_invalidate_one): New.
	(regcache_invalidate): Only invalidate registers of the current
	process.
	(init_register_cache): Add target_desc parameter, and use it.
	(new_register_cache): Ditto.  Assert the target description has a
	non zero registers_size.
	(regcache_cpy): Add assertions.  Adjust.
	(realloc_register_cache, set_register_cache): Delete.
	(registers_to_string, registers_from_string): Adjust.
	(find_register_by_name, find_regno, find_register_by_number)
	(register_cache_size): Add target_desc parameter, and use it.
	(free_register_cache_thread, free_register_cache_thread_one)
	(regcache_release, register_cache_size): New.
	(register_size): Add target_desc parameter, and use it.
	(register_data, supply_register, supply_register_zeroed)
	(supply_regblock, supply_register_by_name, collect_register)
	(collect_register_as_string, collect_register_by_name): Adjust.
	* regcache.h (struct target_desc): Forward declare.
	(struct regcache) <tdesc>: New field.
	(init_register_cache, new_register_cache): Add target_desc
	parameter.
	(regcache_invalidate_thread): Declare.
	(regcache_invalidate_one): Delete declaration.
	(regcache_release): Declare.
	(find_register_by_number, register_cache_size, register_size)
	(find_regno): Add target_desc parameter.
	(gdbserver_expedite_regs, gdbserver_xmltarget): Delete
	declarations.
	* remote-utils.c: Include tdesc.h.
	(outreg, prepare_resume_reply): Adjust.
	* server.c: Include tdesc.h.
	(gdbserver_xmltarget): Delete declaration.
	(get_features_xml, process_serial_event): Adjust.
	* server.h [IN_PROCESS_AGENT] (struct target_desc): Forward
	declare.
	(struct process_info) <tdesc>: New field.
	(ipa_tdesc): Declare.
	* tdesc.c: New file.
	* tdesc.h: New file.
	* tracepoint.c: Include tdesc.h.
	[IN_PROCESS_AGENT] (ipa_tdesc): Define.
	(get_context_regcache): Adjust to pass ipa_tdesc down.
	(do_action_at_tracepoint): Adjust to get the register cache size
	from the context regcache's description.
	(traceframe_walk_blocks): Adjust to get the register cache size
	from the current trace frame's description.
	(traceframe_get_pc): Adjust to get current trace frame's
	description and pass it down.
	(gdb_collect): Adjust to get the register cache size from the
	IPA's description.
	* linux-amd64-ipa.c (tdesc_amd64_linux): Declare.
	(gdbserver_xmltarget): Delete.
	(initialize_low_tracepoint): Set the ipa's target description.
	* linux-i386-ipa.c (tdesc_i386_linux): Declare.
	(initialize_low_tracepoint): Set the ipa's target description.
	* linux-x86-low.c: Include tdesc.h.
	[__x86_64__] (is_64bit_tdesc): New.
	(ps_get_thread_area, x86_get_thread_area): Use it.
	(i386_cannot_store_register): Rename to ...
	(x86_cannot_store_register): ... this.  Use is_64bit_tdesc.
	(i386_cannot_fetch_register): Rename to ...
	(x86_cannot_fetch_register): ... this.  Use is_64bit_tdesc.
	(x86_fill_gregset, x86_store_gregset): Adjust register_size calls
	to new interface.
	(target_regsets): Rename to ...
	(x86_regsets): ... this.
	(x86_get_pc, x86_set_pc): Adjust register_size calls to new
	interface.
	(x86_siginfo_fixup): Use is_64bit_tdesc.
	[__x86_64__] (tdesc_amd64_linux, tdesc_amd64_avx_linux)
	(tdesc_x32_avx_linux, tdesc_x32_linux)
	(tdesc_i386_linux, tdesc_i386_mmx_linux, tdesc_i386_avx_linux):
	Declare.
	(x86_linux_update_xmltarget): Delete.
	(I386_LINUX_XSAVE_XCR0_OFFSET): Define.
	(have_ptrace_getfpxregs, have_ptrace_getregset): New.
	(AMD64_LINUX_USER64_CS): New.
	(x86_linux_read_description): New, based on
	x86_linux_update_xmltarget.
	(same_process_callback): New.
	(x86_arch_setup_process_callback): New.
	(x86_linux_update_xmltarget): New.
	(x86_regsets_info): New.
	(amd64_linux_regs_info): New.
	(i386_linux_usrregs_info): New.
	(i386_linux_regs_info): New.
	(x86_linux_regs_info): New.
	(x86_arch_setup): Reimplement.
	(x86_install_fast_tracepoint_jump_pad): Use is_64bit_tdesc.
	(x86_emit_ops): Ditto.
	(the_low_target): Adjust.  Install x86_linux_regs_info,
	x86_cannot_fetch_register, and x86_cannot_store_register.
	(initialize_low_arch): New.
	* linux-ia64-low.c (tdesc_ia64): Declare.
	(ia64_fetch_register): Adjust.
	(ia64_usrregs_info, regs_info): New globals.
	(ia64_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-sparc-low.c (tdesc_sparc64): Declare.
	(sparc_fill_gregset_to_stack, sparc_store_gregset_from_stack):
	Adjust.
	(sparc_arch_setup): New function.
	(sparc_regsets_info, sparc_usrregs_info, regs_info): New globals.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-ppc-low.c (tdesc_powerpc_32l, tdesc_powerpc_altivec32l)
	(tdesc_powerpc_cell32l, tdesc_powerpc_vsx32l)
	(tdesc_powerpc_isa205_32l, tdesc_powerpc_isa205_altivec32l)
	(tdesc_powerpc_isa205_vsx32l, tdesc_powerpc_e500l)
	(tdesc_powerpc_64l, tdesc_powerpc_altivec64l)
	(tdesc_powerpc_cell64l, tdesc_powerpc_vsx64l)
	(tdesc_powerpc_isa205_64l, tdesc_powerpc_isa205_altivec64l)
	(tdesc_powerpc_isa205_vsx64l): Declare.
	(ppc_cannot_store_register, ppc_collect_ptrace_register)
	(ppc_supply_ptrace_register, parse_spufs_run, ppc_get_pc)
	(ppc_set_pc, ppc_get_hwcap): Adjust.
	(ppc_usrregs_info): Forward declare.
	(!__powerpc64__) ppc_regmap_adjusted: New global.
	(ppc_arch_setup): Adjust to the current process'es target
	description.
	(ppc_fill_vsxregset, ppc_store_vsxregset, ppc_fill_vrregset)
	(ppc_store_vrregset, ppc_fill_evrregset, ppc_store_evrregse)
	(ppc_store_evrregset): Adjust.
	(target_regsets): Rename to ...
	(ppc_regsets): ... this, and make static.
	(ppc_usrregs_info, ppc_regsets_info, regs_info): New globals.
	(ppc_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-s390-low.c (tdesc_s390_linux32, tdesc_s390_linux32v1)
	(tdesc_s390_linux32v2, tdesc_s390_linux64, tdesc_s390_linux64v1)
	(tdesc_s390_linux64v2, tdesc_s390x_linux64, tdesc_s390x_linux64v1)
	(tdesc_s390x_linux64v2): Declare.
	(s390_collect_ptrace_register, s390_supply_ptrace_register)
	(s390_fill_gregset, s390_store_last_break): Adjust.
	(target_regsets): Rename to ...
	(s390_regsets): ... this, and make static.
	(s390_get_pc, s390_set_pc): Adjust.
	(s390_get_hwcap): New target_desc parameter, and use it.
	[__s390x__] (have_hwcap_s390_high_gprs): New global.
	(s390_arch_setup): Adjust to set the current process'es target
	description.  Don't adjust the regmap.
	(s390_usrregs_info, s390_regsets_info, regs_info): New globals.
	[__s390x__] (s390_usrregs_info_3264, s390_regsets_info_3264)
	(regs_info_3264): New globals.
	(s390_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-mips-low.c (tdesc_mips_linux, tdesc_mips_dsp_linux)
	(tdesc_mips64_linux, tdesc_mips64_dsp_linux): Declare.
	[__mips64] (init_registers_mips_linux)
	(init_registers_mips_dsp_linux): Delete defines.
	[__mips64] (tdesc_mips_linux, tdesc_mips_dsp_linux): New defines.
	(have_dsp): New global.
	(mips_read_description): New, based on mips_arch_setup.
	(mips_arch_setup): Reimplement.
	(get_usrregs_info): New function.
	(mips_cannot_fetch_register, mips_cannot_store_register)
	(mips_get_pc, mips_set_pc, mips_fill_gregset, mips_store_gregset)
	(mips_fill_fpregset, mips_store_fpregset): Adjust.
	(target_regsets): Rename to ...
	(mips_regsets): ... this, and make static.
	(mips_regsets_info, mips_dsp_usrregs_info, mips_usrregs_info)
	(dsp_regs_info, regs_info): New globals.
	(mips_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-arm-low.c (tdesc_arm, tdesc_arm_with_iwmmxt)
	(tdesc_arm_with_vfpv2, tdesc_arm_with_vfpv3, tdesc_arm_with_neon):
	Declare.
	(arm_fill_vfpregset, arm_store_vfpregset): Adjust.
	(arm_read_description): New, with bits factored from
	arm_arch_setup.
	(arm_arch_setup): Reimplement.
	(target_regsets): Rename to ...
	(arm_regsets): ... this, and make static.
	(arm_regsets_info, arm_usrregs_info, regs_info): New globals.
	(arm_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-m68k-low.c (tdesc_m68k): Declare.
	(target_regsets): Rename to ...
	(m68k_regsets): ... this, and make static.
	(m68k_regsets_info, m68k_usrregs_info, regs_info): New globals.
	(m68k_regs_info): New function.
	(m68k_arch_setup): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-sh-low.c (tdesc_sharch): Declare.
	(target_regsets): Rename to ...
	(sh_regsets): ... this, and make static.
	(sh_regsets_info, sh_usrregs_info, regs_info): New globals.
	(sh_regs_info, sh_arch_setup): New functions.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-bfin-low.c (tdesc_bfin): Declare.
	(bfin_arch_setup): New function.
	(bfin_usrregs_info, regs_info): New globals.
	(bfin_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-cris-low.c (tdesc_cris): Declare.
	(cris_arch_setup): New function.
	(cris_usrregs_info, regs_info): New globals.
	(cris_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-cris-low.c (tdesc_crisv32): Declare.
	(cris_arch_setup): New function.
	(cris_regsets_info, cris_usrregs_info, regs_info): New globals.
	(cris_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-m32r-low.c (tdesc_m32r): Declare.
	(m32r_arch_setup): New function.
	(m32r_usrregs_info, regs_info): New globals.
	(m32r_regs_info): Adjust.
	(initialize_low_arch): New function.
	* linux-tic6x-low.c (tdesc_tic6x_c64xp_linux)
	(tdesc_tic6x_c64x_linux, tdesc_tic6x_c62x_linux): Declare.
	(tic6x_usrregs_info): Forward declare.
	(tic6x_read_description): New function, based on ...
	(tic6x_arch_setup): ... this.  Reimplement.
	(target_regsets): Rename to ...
	(tic6x_regsets): ... this, and make static.
	(tic6x_regsets_info, tic6x_usrregs_info, regs_info): New globals.
	(tic6x_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-xtensa-low.c (tdesc_xtensa): Declare.
	(xtensa_fill_gregset, xtensa_store_gregset): Adjust.
	(target_regsets): Rename to ...
	(xtensa_regsets): ... this, and make static.
	(xtensa_regsets_info, xtensa_usrregs_info, regs_info): New
	globals.
	(xtensa_arch_setup, xtensa_regs_info): New functions.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-nios2-low.c (tdesc_nios2_linux): Declare.
	(nios2_arch_setup): Set the current process'es tdesc.
	(target_regsets): Rename to ...
	(nios2_regsets): ... this.
	(nios2_regsets_info, nios2_usrregs_info, regs_info): New globals.
	(nios2_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
        * linux-aarch64-low.c (tdesc_aarch64): Declare.
        (aarch64_arch_setup): Set the current process'es tdesc.
        (target_regsets): Rename to ...
        (aarch64_regsets): ... this.
        (aarch64_regsets_info, aarch64_usrregs_info, regs_info): New globals.
        (aarch64_regs_info): New function.
        (the_low_target): Adjust.
        (initialize_low_arch): New function.
	* linux-tile-low.c (tdesc_tilegx, tdesc_tilegx32): Declare
	globals.
	(target_regsets): Rename to ...
	(tile_regsets): ... this.
	(tile_regsets_info, tile_usrregs_info, regs_info): New globals.
	(tile_regs_info): New function.
	(tile_arch_setup): Set the current process'es tdesc.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* spu-low.c (tdesc_spu): Declare.
	(spu_create_inferior, spu_attach): Set the new process'es tdesc.
	* win32-arm-low.c (tdesc_arm): Declare.
	(arm_arch_setup): New function.
	(the_low_target): Install arm_arch_setup instead of
	init_registers_arm.
	* win32-i386-low.c (tdesc_i386, tdesc_amd64): Declare.
	(init_windows_x86): Rename to ...
	(i386_arch_setup): ... this.  Set `win32_tdesc'.
	(the_low_target): Adjust.
	* win32-low.c (win32_tdesc): New global.
	(child_add_thread): Don't create the thread cache here.
	(do_initial_child_stuff): Set the new process'es tdesc.
	* win32-low.h (struct target_desc): Forward declare.
	(win32_tdesc): Declare.
	* lynx-i386-low.c (tdesc_i386): Declare global.
	(lynx_i386_arch_setup): Set `lynx_tdesc'.
	* lynx-low.c (lynx_tdesc): New global.
	(lynx_add_process): Set the new process'es tdesc.
	* lynx-low.h (struct target_desc): Forward declare.
	(lynx_tdesc): Declare global.
	* lynx-ppc-low.c (tdesc_powerpc_32): Declare global.
	(lynx_ppc_arch_setup): Set `lynx_tdesc'.
	* nto-low.c (nto_tdesc): New global.
	(do_attach): Set the new process'es tdesc.
	* nto-low.h (struct target_desc): Forward declare.
	(nto_tdesc): Declare.
	* nto-x86-low.c (tdesc_i386): Declare.
	(nto_x86_arch_setup): Set `nto_tdesc'.

gdb/
2013-06-07  Pedro Alves  <palves@@redhat.com>

	* regformats/regdat.sh: Output #include tdesc.h.  Make globals
	static.  Output a global target description pointer.
	(init_registers_${name}): Adjust to initialize a
	target description structure.
@
text
@d5404 7
@


1.77
log
@2013-05-03  Hafiz Abid Qadeer  <abidh@@codesourcery.com>

	* tracepoint.c (cmd_qtinit): Call 'stop_tracing'.

2013-05-03  Hafiz Abid Qadeer  <abidh@@codesourcery.com>

	* status-stop.exp (test_tstart_tstart): Check for error
	returned by the second 'tstart' command.
@
text
@d32 1
d4679 8
d4699 1
a4699 1
	  init_register_cache (&fctx->regcache, fctx->regspace);
d4714 1
a4714 1
	  init_register_cache (&sctx->regcache, sctx->regspace);
d4773 1
d4775 1
d4777 2
a4778 1
	trace_debug ("Want to collect registers");
d4781 1
a4781 2
	regspace = add_traceframe_block (tframe, tpoint,
					 1 + register_cache_size ());
a4789 2
	context_regcache = get_context_regcache (ctx);

d4792 2
a4793 1
	init_register_cache (&tregcache, regspace + 1);
d5096 1
a5096 1
	  dataptr += register_cache_size ();
d5191 1
d5197 1
a5197 1
  init_register_cache (&regcache, dataptr);
d5751 1
a5751 1
  ctx.regspace = alloca (register_cache_size ());
d6611 1
a6611 1
  ctx.regspace = alloca (register_cache_size ());
@


1.76
log
@2013-03-14  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* tracepoint.c (cmd_qtv): Initialize `val' with zero, silencing
	compiler warning.
@
text
@d2357 2
@


1.75
log
@	* tracepoint.c (tfile_get_trace_state_variable_value): Look for
	the last matched 'V' blcok in trace frame.

gdb/gdbserver:

	* tracepoint.c (traceframe_read_tsv): Look for the last matched
	'V' block in trace frame.

gdb/testsuite:

	* gdb.trace/tsv.exp (check_tsv): New.
	(top level): Save a tfile on current trace session. Call
	check_tsv on live target.  Load the tfile with target tfile
	and call check_tsv again.
@
text
@d2807 1
a2807 1
  LONGEST val;
@


1.74
log
@2012-03-08  Stan Shebs  <stan@@codesourcery.com>
	    Hafiz Abid Qadeer  <abidh@@codesourcery.com>

	gdb/
	* NEWS: Mention set and show trace-buffer-size commands.
	Mention new packet.
	* target.h (struct target_ops): New method
	to_set_trace_buffer_size.
	(target_set_trace_buffer_size): New macro.
	* target.c (update_current_target): Set up new method.
	* tracepoint.c (trace_buffer_size): New global.
	(start_tracing): Send it to the target.
	(set_trace_buffer_size): New function.
	(_initialize_tracepoint): Add new setshow for trace-buffer-size.
	* remote.c (remote_set_trace_buffer_size): New function.
	(_initialize_remote): Use it.
	(QTBuffer:size) New remote command.
	(PACKET_QTBuffer_size): New enum.
	(remote_protocol_features): Add an entry for
	PACKET_QTBuffer_size.

	gdb/gdbserver/
	* tracepoint.c (trace_buffer_size): New global.
	(DEFAULT_TRACE_BUFFER_SIZE): New define.
	(init_trace_buffer): Change to one-argument function. Allocate
	trace buffer memory.
	(handle_tracepoint_general_set): Call cmd_bigqtbuffer_size to
	handle QTBuffer:size packet.
	(cmd_bigqtbuffer_size): New function.
	(initialize_tracepoint): Call init_trace_buffer with
	DEFAULT_TRACE_BUFFER_SIZE.
	* server.c (handle_query): Add QTBuffer:size in the
	supported packets.

	gdb/doc/
	* gdb.texinfo (Starting and Stopping Trace Experiments): Document
	trace-buffer-size set and show commands.
	(Tracepoint Packets): Document QTBuffer:size.
	(General Query Packets): Document QTBuffer:size.

	gdb/testsuite/
	* gdb.trace/trace-buffer-size.exp: New file.
	* gdb.trace/trace-buffer-size.c: New file.
@
text
@d5260 1
d5283 2
a5284 1
  /* Iterate through a traceframe's blocks, looking for the tsv.  */
d5299 1
a5299 1
	  return 0;
d5306 4
a5309 3
  trace_debug ("traceframe %d has no data for variable %d",
	       tfnum, tsvnum);
  return 1;
@


1.74.2.1
log
@2013-05-03  Hafiz Abid Qadeer  <abidh@@codesourcery.com>

	* tracepoint.c (cmd_qtinit): Call 'stop_tracing'.

2013-05-03  Hafiz Abid Qadeer  <abidh@@codesourcery.com>

	* status-stop.exp (test_tstart_tstart): Check for error
	returned by the second 'tstart' command.
@
text
@a2356 2
  stop_tracing ();

@


1.73
log
@gdb/gdbserver/
	* tracepoint.c (cur_action, cur_step_action): Make them unsigned.
	(cmd_qtfp): Initialize cur_action and cur_step_action 0 instead
	of -1.
	(cmd_qtsp): Adjust condition.  Do post increment.
	Set cur_action and cur_step_action back to 0.
@
text
@d33 2
d997 4
d1487 1
a1487 1
init_trace_buffer (unsigned char *buf, int bufsize)
d1489 5
a1493 1
  trace_buffer_lo = buf;
d4033 31
d4187 5
d7277 2
a7278 4
  /* There currently no way to change the buffer size.  */
  const int sizeOfBuffer = 5 * 1024 * 1024;
  unsigned char *buf = xmalloc (sizeOfBuffer);
  init_trace_buffer (buf, sizeOfBuffer);
@


1.72
log
@gdb/gdbserver/

	* tracepoint.c (cmd_qtbuffer): Call phex_nz instead of
	pulongest.
@
text
@d3687 2
a3688 2
static int cur_action;
static int cur_step_action;
d3762 1
a3762 1
  cur_action = cur_step_action = -1;
d3787 1
a3787 1
  else if (cur_action < cur_tpoint->numactions - 1)
a3788 1
      ++cur_action;
d3791 1
d3793 1
a3793 1
  else if (cur_step_action < cur_tpoint->num_step_actions - 1)
a3794 1
      ++cur_step_action;
d3797 1
d3812 1
a3812 1
      cur_action = cur_step_action = -1;
@


1.71
log
@gdb/gdbserver/

	* tracepoint.c (cmd_qtbuffer): Don't set '\0' in OWN_BUF.
@
text
@d3972 1
a3972 1
	       (int) num, pulongest (offset));
@


1.70
log
@gdbserver: QTNotes, plug memory leak.

The previous notes aren't being released before setting new ones.

Tested on x86_64 Fedora 17.

gdb/gdbserver/
2013-02-14  Pedro Alves  <palves@@redhat.com>

	Plug memory leak.

	* tracepoint.c (cmd_qtnotes): Free TRACING_USER_NAME,
	TRACING_NOTES and TRACING_STOP_NOTE before clobbering.
@
text
@a4004 1
  own_buf[num] = '\0';
@


1.69
log
@Move savestring to common/common-utils.c, make gdbserver use it.

This makes gdbserver share gdb's savestring, instead of baking its own.

Tested on x86_64 Fedora 17.

gdb/
2013-02-14  Pedro Alves  <palves@@redhat.com>

	* utils.c (savestring): Don't #undef it.  Move function to
	common/common-utils.c.
	* common/common-utils.c: Include gdb_string.h.
	(savestring): Move here from utils.c.
	* common/common-utils.h (savestring): Declare.

gdb/gdbserver/
2013-02-14  Pedro Alves  <palves@@redhat.com>

	* tracepoint.c (save_string): Delete.
	(add_tracepoint_action): Use savestring instead of save_string.
@
text
@d4045 1
d4059 1
d4073 1
@


1.68
log
@gdb/gdbserver:

	* ax.h (struct eval_agent_expr_context): New.
	(gdb_eval_agent_expr): Update declaration.
	* ax.c (gdb_eval_agent_expr): Remove argument REGCACHE and
	TFRAME.  Add new argument CTX.
	* server.h (struct eval_agent_expr_context): Declare.
	(agent_mem_read, agent_tsv_read): Update declaration.
	(agent_mem_read_string): Likewise.
	* tracepoint.c (eval_tracepoint_agent_expr): Remove.
	(add_traceframe_block): Add new argument TPOINT.
	Increase TPOINT->traceframe_usage.
	(do_action_at_tracepoint): Call gdb_eval_agent_expr instead of
	eval_tracepoint_agent_expr.
	(condition_true_at_tracepoint): Likewise.
	(agent_mem_read): Remove argument TFRAME.  Add argument CTX.
	(agent_mem_read_string, agent_tsv_read): Likewise.
	Callers update.

gdb/testsuite:

	* gdb.trace/infotrace.exp: Check 'traceframe usage' in the
	output of 'info tracepoints'.
	* gdb.trace/disconnected-tracing.exp (disconnected_tracing):
	Likewise.
	* gdb.trace/tstatus.exp (run_trace_experiment): Likewise.
	* gdb.trace/disconnected-tracing.c (struct foo): New.
@
text
@a1898 12
static char *
save_string (const char *str, size_t len)
{
  char *s;

  s = xmalloc (len + 1);
  memcpy (s, str, len);
  s[len] = '\0';

  return s;
}

d2019 1
a2019 1
	    = save_string (act_start, act - act_start);
d2032 1
a2032 1
	    = save_string (act_start, act - act_start);
@


1.67
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@a1348 6
static enum eval_result_type
eval_tracepoint_agent_expr (struct tracepoint_hit_ctx *ctx,
			    struct traceframe *tframe,
			    struct agent_expr *aexpr,
			    ULONGEST *rslt);

d2213 2
a2214 1
add_traceframe_block (struct traceframe *tframe, int amt)
d2226 2
d2229 1
d4706 1
d4709 3
d4717 2
a4718 2
	agent_mem_read (tframe, NULL,
			(CORE_ADDR) maction->addr, maction->len);
d4731 1
a4731 1
	regspace = add_traceframe_block (tframe,
d4773 1
d4776 3
d4782 1
a4782 1
	err = eval_tracepoint_agent_expr (ctx, tframe, eaction->expr, NULL);
d4834 2
a4835 1
    err = eval_tracepoint_agent_expr (ctx, NULL, tpoint->cond, &value);
d4837 6
a4855 16
/* Evaluates a tracepoint agent expression with context CTX,
   traceframe TFRAME, agent expression AEXPR and store the
   result in RSLT.  */

static enum eval_result_type
eval_tracepoint_agent_expr (struct tracepoint_hit_ctx *ctx,
			    struct traceframe *tframe,
			    struct agent_expr *aexpr,
			    ULONGEST *rslt)
{
  struct regcache *regcache;
  regcache = get_context_regcache (ctx);

  return gdb_eval_agent_expr (regcache, tframe, aexpr, rslt);
}

d4860 1
a4860 1
agent_mem_read (struct traceframe *tframe,
d4881 1
a4881 1
      mspace = add_traceframe_block (tframe, sp);
d4902 1
a4902 1
agent_mem_read_string (struct traceframe *tframe,
d4938 1
a4938 1
      mspace = add_traceframe_block (tframe, sp);
d4964 1
a4964 1
agent_tsv_read (struct traceframe *tframe, int n)
d4969 1
a4969 1
  vspace = add_traceframe_block (tframe,
d6346 2
a6347 1
	  block = add_traceframe_block (tframe, ipa_tframe.data_size);
d6646 1
a6646 1
  bufspace = add_traceframe_block (tframe,
@


1.66
log
@gdb/gdbserver:
2012-11-09  Yao Qi  <yao@@codesourcery.com>

	* spu-low.c (current_ptid): Move it to ..
	* gdbthread.h: ... here.  New.
	* remote-utils.c (read_ptid): Use macro 'current_ptid'.
	* server.c (myresume, process_serial_event): Likewise.
	* thread-db.c (thread_db_find_new_threads): Likewise.
	* tracepoint.c (run_inferior_command): Likewise.
@
text
@d2 1
a2 1
   Copyright (C) 2009-2012 Free Software Foundation, Inc.
@


1.65
log
@gdb/gdbserver/
	* tracepoint.c (cmd_qtsv): Adjust debug message.
	Don't check CUR_TPOINT.
@
text
@d6695 1
a6695 1
  int pid = ptid_get_pid (current_inferior->entry.id);
@


1.64
log
@gdb/gdbserver/
	* ax.c, tracepoint.c: Replace ATTR_FORMAT with ATTRIBUTE_PRINTF.
	* server.h: Include 'libiberty.h' and 'ansidecl.h'.
	(ATTR_NORETURN, ATTR_FORMAT, ATTR_MALLOC): Remove.
	Remove declarations of xmalloc, xreallloc, xstrdup and
	freeargv.
	* Makefile.in (libiberty_h): New.
	(server_h): Append dependencies 'libiberty.h' and 'ansidecl.h'.
	(linux-bfin-low.o): Append dependency 'libiberty.h'.
@
text
@d3876 1
a3876 1
  trace_debug ("Returning first trace state variable definition");
d3878 1
a3878 7
  if (!cur_tpoint)
    {
      /* This case would normally never occur, but be prepared for
	 GDB misbehavior.  */
      strcpy (packet, "l");
    }
  else if (cur_tsv)
@


1.63
log
@gdb/gdbserver/
	PR remote/14161.

	* server.h: Declare gdb_agent_about_to_close.
	* target.c (kill_inferior): Include "agent.h".
	New.  Send command 'kill'.
	* target.h (kill_inferior): Removed macro.
	* tracepoint.c (gdb_agent_about_to_close): New.
	(gdb_agent_helper_thread): Handle command 'close'.
	Wait endlessly until the inferior stops.
	Install gdb_agent_remove_socket to atexit hook.
	(agent_socket_name): New static variable.
	(gdb_agent_socket_init): Replace local variable 'name' with
	'agent_socket_name'.
	(gdb_agent_remove_socket): New.

gdb/doc/
	* gdb.texinfo (IPA Protocol Commands): Document new command
	'close'.

gdb/testsuite/
	KFAIL for PR remote/14161.
	* gdb.trace/strace.exp (strace_remove_socket): kfail for native.
	Cleanup socket files.
	(strace_info_marker): Detach inferior.
@
text
@d60 1
a60 1
static void trace_vdebug (const char *, ...) ATTR_FORMAT (printf, 1, 2);
@


1.62
log
@gdb/gdbserver:

	* server.h: Move some code to ...
	* gdbthread.h: ... here.  New.
	* Makefile.in (inferiors.o, regcache.o): Depends on gdbthread.h
	(remote-utils.o, server.o, target.o tracepoint.o): Likewise.
	(nto-low.o, win32-low.o): Likewise.
	* inferiors.c, linux-low.h, nto-low.c: Include gdbthread.h.
	* regcache.c, remote-utils.c, server.c: Likewise.
	* target.c, tracepoint.c, win32-low.c: Likewise.
@
text
@d3926 32
d6783 2
a6788 1
  char name[UNIX_PATH_MAX];
d6790 1
a6790 1
  result = xsnprintf (name, UNIX_PATH_MAX, "%s/gdb_ust%d",
d6798 1
a6798 1
  fd = init_named_socket (name);
d6802 1
a6802 1
	     "is writable.", name);
d7031 7
d7046 2
d7068 1
d7101 4
d7106 1
a7106 1
	      if (strcmp ("qTfSTM", cmd_buf) == 0)
d7138 14
@


1.61
log
@gdb/gdbserver/
	* tracepoint.c (cmd_qtstart): Download tracepoints even when they are
	duplicated on address.
@
text
@d20 1
@


1.60
log
@gdb/

	* common/agent.c (agent_run_command): Add one more parameter `len'.
	Update callers.
	* common/agent.h: Update declaration.
	* linux-nat.c (linux_child_static_tracepoint_markers_by_strid):
	Update.
	(linux_child_static_tracepoint_markers_by_strid): Ditto.

gdb/gdbserver/

	* tracepoint.c (COPY_FIELD_TO_BUF): New macro.
	(struct tracepoint_action_ops) <send>: New field.
	(m_tracepoint_action_send, r_tracepoint_action_send): New.
	(agent_expr_send, x_tracepoint_action_send): New.
	(l_tracepoint_action_send): New.
	(cmd_qtdp): Download and install tracepoint
	according to `use_agent'.
	(run_inferior_command): Add one more parameter `len'.
	Update callers.
	(tracepoint_send_agent): New.
	(cmd_qtdp, cmd_qtstart): Call tracepoint_send_agent.
@
text
@d3247 3
d3252 8
a3259 1
		clone_fast_tracepoint (tpoint, prev_ftpoint);
d3266 1
a3266 2
		  if (use_agent
		      && agent_capability_check (AGENT_CAPA_FAST_TRACE))
@


1.59
log
@gdb/gdbserver/

	* tracepoint.c (download_tracepoints): Moved to ...
	(cmd_qtstart): ... here.
@
text
@d414 1
a414 1
static int run_inferior_command (char *cmd);
d423 3
d466 7
d484 4
d545 12
d561 1
d577 6
d586 1
d609 32
d644 1
d660 6
d669 1
d2407 1
a2407 1
  run_inferior_command (cmd);
d2613 2
a2614 3
      download_tracepoint (tpoint);

      if (tpoint->type == trap_tracepoint || tp == NULL)
d2616 8
a2623 3
	  install_tracepoint (tpoint, own_buf);
	  if (strcmp (own_buf, "OK") != 0)
	    remove_tracepoint (tpoint);
d2626 12
a2637 1
	write_ok (own_buf);
d3028 1
a3028 1
  err = run_inferior_command (cmd);
a3246 2
	      download_tracepoint_1 (tpoint);

d3252 14
a3265 1
		  if (install_fast_tracepoint (tpoint, packet) == 0)
d3894 1
a3894 1
    run_inferior_command (packet);
d3903 1
a3903 1
    run_inferior_command (packet);
d3913 1
a3913 1
    run_inferior_command (packet);
d5929 85
d6656 1
a6656 1
run_inferior_command (char *cmd)
d6666 1
a6666 1
  err = agent_run_command (pid, (const char *) cmd);
@


1.58
log
@gdb/gdbserver/
	* tracepoint.c: Include inttypes.h.
	(struct collect_memory_action): Use sized types.
	(struct tracepoint): Likewise.
	(cmd_qtdp, stop_tracing): Update print specifiers.
	(cmd_qtp, response_tracepoint): Likewise.
	(collect_data_at_tracepoint): Likewise.
	(collect_data_at_step): Likewise.
@
text
@a410 1
static void download_tracepoints (void);
d3090 2
d3096 1
d3114 1
a3114 4
    {
      download_tracepoints ();
      download_trace_state_variables ();
    }
d3124 5
a3128 1
  /* Install tracepoints.  */
d3144 2
a3145 1
      else if (tpoint->type == fast_tracepoint)
d3149 4
a3152 2
	      trace_debug ("Requested a fast tracepoint, but fast "
			   "tracepoints aren't supported.");
d3156 1
a3156 11
	  if (prev_ftpoint != NULL && prev_ftpoint->address == tpoint->address)
	    clone_fast_tracepoint (tpoint, prev_ftpoint);
	  else
	    {
	      if (install_fast_tracepoint (tpoint, packet) == 0)
		prev_ftpoint = tpoint;
	    }
	}
      else if (tpoint->type == static_tracepoint)
	{
	  if (maybe_write_ipa_ust_not_loaded (packet))
d3158 1
a3158 4
	      trace_debug ("Requested a static tracepoint, but static "
			   "tracepoints are not supported.");
	      break;
	    }
d3160 8
a3167 4
	  /* Can only probe a given marker once.  */
	  if (prev_stpoint != NULL && prev_stpoint->address == tpoint->address)
	    {
	      tpoint->handle = (void *) -1;
d3171 1
a3171 1
	      if (probe_marker_at (tpoint->address, packet) == 0)
d3173 4
a3176 1
		  tpoint->handle = (void *) -1;
d3178 15
a3192 3
		  /* So that we can handle multiple static tracepoints
		     at the same address easily.  */
		  prev_stpoint = tpoint;
d3195 12
a5876 36
download_tracepoints (void)
{
  CORE_ADDR tpptr = 0, prev_tpptr = 0;
  struct tracepoint *tpoint;

  /* Start out empty.  */
  write_inferior_data_ptr (ipa_sym_addrs.addr_tracepoints, 0);

  for (tpoint = tracepoints; tpoint; tpoint = tpoint->next)
    {
      if (tpoint->type != fast_tracepoint
	  && tpoint->type != static_tracepoint)
	continue;

      prev_tpptr = tpptr;

      download_tracepoint_1 (tpoint);

      tpptr = tpoint->obj_addr_on_target;

      if (tpoint == tracepoints)
	{
	  /* First object in list, set the head pointer in the
	     inferior.  */
	  write_inferior_data_ptr (ipa_sym_addrs.addr_tracepoints, tpptr);
	}
      else
	{
	  write_inferior_data_ptr (prev_tpptr + offsetof (struct tracepoint,
							  next),
				   tpptr);
	}
    }
}

static void
@


1.57
log
@gdb/gdbserver/

	* tracepoint.c: Include stdint.h unconditionally.
@
text
@d27 1
d494 1
a494 1
  int basereg;
d654 1
a654 1
  int number;
d664 1
a664 1
  int enabled;
d668 1
a668 1
  long step_count;
d672 1
a672 1
  long pass_count;
d679 1
a679 1
  int numactions;
d684 1
a684 1
  long hit_count;
d687 1
a687 1
  long traceframe_usage;
d707 1
a707 1
  int orig_size;
d2485 1
a2485 1
		   "enabled %d step %ld pass %ld",
d3283 1
a3283 1
		   "tracepoint %d was hit %ld times",
d3561 2
a3562 1
  sprintf (own_buf, "V%lx:%lx", tpoint->hit_count, tpoint->traceframe_usage);
d3580 1
a3580 1
  sprintf (packet, "T%x:%s:%c:%lx:%lx", tpoint->number,
d4417 1
a4417 1
  trace_debug ("Making new traceframe for tracepoint %d at 0x%s, hit %ld",
d4454 1
a4454 1
	       "tracepoint %d at 0x%s, step %d of %ld, hit %ld",
@


1.56
log
@gdb/gdbserver/

	* tracepoint.c (install_tracepoint): Move duplicated tracepoint
	handling to ...
	(cmd_qtdp): ... here.
@
text
@a26 1
#if HAVE_STDINT_H
d28 1
a28 1
#endif
@


1.55
log
@gdb/gdbserver/

	* tracepoint.c (struct tracepoint_action_ops): New.
	(struct tracepoint_action) [!IN_PROCESS_AGENT] <ops>: New field.
	(m_tracepoint_action_download): New.
	(r_tracepoint_action_download): New.
	(x_tracepoint_action_download): New.
	(l_tracepoint_action_download): New.
	(add_tracepoint_action): Install `action->ops' according type.
	(download_tracepoint_1): Move code `download' function pointer
	of various tracepoint_action_ops.
@
text
@d1316 2
d2507 2
d2519 21
d2541 9
a2549 3
      install_tracepoint (tpoint, own_buf);
      if (strcmp (own_buf, "OK") != 0)
	remove_tracepoint (tpoint);
a3052 2
      struct tracepoint *tp;

a3069 8
      /* Find another fast or static tracepoint at the same address.  */
      for (tp = tracepoints; tp; tp = tp->next)
	{
	  if (tp->address == tpoint->address && tp->type == tpoint->type
	      && tp->number != tpoint->number)
	    break;
	}

d3071 1
a3071 6
	{
	  if (tp) /* TPOINT is installed at the same address as TP.  */
	    clone_fast_tracepoint (tpoint, tp);
	  else
	    install_fast_tracepoint (tpoint, own_buf);
	}
d3074 1
a3074 1
	  if (tp)
a3075 5
	  else
	    {
	      if (probe_marker_at (tpoint->address, own_buf) == 0)
		tpoint->handle = (void *) -1;
	    }
@


1.54
log
@2012-03-08  Yao Qi  <yao@@codesourcery.com>
	    Pedro Alves  <palves@@redhat.com>

	Fix PR server/13392.
	* linux-x86-low.c (amd64_install_fast_tracepoint_jump_pad): Check
	offset of JMP insn.
	* tracepoint.c (remove_tracepoint): New.
	(cmd_qtdp): Call remove_tracepoint when failed to install.

2012-03-08  Yao Qi  <yao@@codesourcery.com>
	    Pedro Alves  <palves@@redhat.com>

	Fix PR server/13392.
	* gdb.trace/change-loc.exp (tracepoint_change_loc_1): Remove kfail.
	(tracepoint_change_loc_2): Remove kfail.  Return if failed to
	download tracepoints.
	* gdb.trace/pending.exp (pending_tracepoint_works): Likewise.
	(pending_tracepoint_resolved_during_trace): Likewise.
	(pending_tracepoint_installed_during_trace): Likewise.
	(pending_tracepoint_with_action_resolved): Likewise.
@
text
@d462 2
d466 11
d481 3
d519 81
d1871 1
d1897 1
d1913 1
d1930 1
a5781 1
	  CORE_ADDR ipa_action = 0;
d5783 1
a5783 47

	  switch (action->type)
	    {
	    case 'M':
	      ipa_action
		= target_malloc (sizeof (struct collect_memory_action));
	      write_inferior_memory (ipa_action,
				     (unsigned char *) action,
				     sizeof (struct collect_memory_action));
	      break;
	    case 'R':
	      ipa_action
		= target_malloc (sizeof (struct collect_registers_action));
	      write_inferior_memory (ipa_action,
				     (unsigned char *) action,
				     sizeof (struct collect_registers_action));
	      break;
	    case 'X':
	      {
		CORE_ADDR expr;
		struct eval_expr_action *eaction
		  = (struct eval_expr_action *) action;

		ipa_action = target_malloc (sizeof (*eaction));
		write_inferior_memory (ipa_action,
				       (unsigned char *) eaction,
				       sizeof (*eaction));

		expr = download_agent_expr (eaction->expr);
		write_inferior_data_ptr
		  (ipa_action + offsetof (struct eval_expr_action, expr),
		   expr);
		break;
	      }
	    case 'L':
	      ipa_action = target_malloc
		(sizeof (struct collect_static_trace_data_action));
	      write_inferior_memory
		(ipa_action,
		 (unsigned char *) action,
		 sizeof (struct collect_static_trace_data_action));
	      break;
	    default:
	      trace_debug ("unknown trace action '%c', ignoring",
			   action->type);
	      break;
	    }
@


1.53
log
@gdb:
	* common/agent.c (agent_look_up_symbols): Add one parameter 'arg'.
	* common/agent.h: Update declaration.
	* inf-child.c (inf_child_use_agent): New.
	(inf_child_can_use_agent): New.
	(inf_child_target): Initialize fields `to_use_agent'
	and `to_can_use_agent'.
	* agent.c (agent_new_objfile): New.
        (_initialize_agent): Add agent_new_objfile to new_objfile
	observer.

	* linux-nat.c (linux_child_static_tracepoint_markers_by_strid):
	New.
        (linux_target_install_ops): Initialize field
	`to_static_tracepoint_markers_by_strid'.
	* remote.c (free_current_marker): Move it to ...
	* tracepoint.c (free_current_marker): ... here.  New.
	(cleanup_target_stop): New.
	* tracepoint.h: Declare free_current_marker.
	* NEWS: Add one entry about `info static-tracepoint-marker'.

gdb/gdbserver:
	* tracepoint.c (tracepoint_look_up_symbols): Update call to
	agent_look_up_symbols.

gdb/testsuite:
	* gdb.trace/strace.exp: run strace_info_marker in linux native gdb.
@
text
@d1687 22
d2416 2
@


1.52
log
@gdb:
        * common/agent.c (agent_loaded_p): New.
        (agent_look_up_symbols): New global.
        * common/agent.h: Declare agent_loaded_p.

gdb/gdbserver:

        * Makefile.in (linux-low.o): Keep dependence on agent.h.
        (linux-x86-low.o): Likewise.
        * server.h: Remove in_process_agent_loaded.
        * tracepoint.c (in_process_agent_loaded): Removed.  Moved it
        common/agent.c.
        Update callers.
@
text
@d341 1
a341 1
  agent_look_up_symbols ();
@


1.51
log
@gdb:
	* common/agent.c (struct ipa_sym_addresses) <addr_capability>: New.
	(agent_capability_check, agent_capability_invalidate): New.
	(symbol_list): New array element.
	* common/agent.h (enum agent_capa): New.
	* target.c (target_pre_inferior): Call agent_capability_invalidate.

gdb/gdbserver:
	* tracepoint.c (gdb_agent_capability): New global.
	(in_process_agent_loaded_ust): Renamed to
	`in_process_agent_supports_ust'.
	Update callers.
	(in_process_agent_supports_ust): Call agent_capability_check.
	(clear_installed_tracepoints): Assert that agent supports
	agent.
@
text
@a223 8
int all_tracepoint_symbols_looked_up;

int
in_process_agent_loaded (void)
{
  return all_tracepoint_symbols_looked_up;
}

d235 1
a235 1
  if (!in_process_agent_loaded ())
d286 1
a286 1
  if (!in_process_agent_loaded ())
d301 1
a301 1
  if (!in_process_agent_loaded ())
d325 1
a325 1
  if (all_tracepoint_symbols_looked_up)
d341 1
a341 4
  if (agent_look_up_symbols () != 0)
    return;

  all_tracepoint_symbols_looked_up = 1;
d2899 1
a2899 1
      if (!in_process_agent_loaded ())
d2975 1
a2975 1
  if (in_process_agent_loaded ())
d3076 1
a3076 1
  if (in_process_agent_loaded ())
d3135 1
a3135 1
  if (in_process_agent_loaded ())
d3183 1
a3183 1
  if (in_process_agent_loaded ())
d3346 1
a3346 1
  if (in_process_agent_loaded ())
d4014 1
a4014 1
  if (in_process_agent_loaded ())
d4115 1
a4115 1
  if (!in_process_agent_loaded ())
@


1.50
log
@gdb:

	* common/agent.c: New.
	* common/agent.h: New.
	* configure.ac: Add `sys/socket.h' and `sys/un.h' to
	AC_CHECK_HEADERS.
	* configure, configh.in: Regenerated.

gdb/gdbserver:

	* Makefile.in (OBS): Add agent.o.
	Add new rule for agent.o.
	Track dependence of tracepoint.c on agent.h.
	* tracepoint.c (run_inferior_command_1):
	(run_inferior_command): Call agent_run_command.
	(gdb_ust_connect_sync_socket): Deleted.  Move it to
	common/agent.c.
	(resume_thread, stop_thread): Likewise.
	(gdb_ust_socket_init): Renamed to ...
	(gdb_agent_socket_init): ... New.
	(gdb_ust_thread): Renamed to ...
	(gdb_agent_helper_thread): ... New.
	(gdb_ust_init): Move some code to ...
	(gdb_agent_init): ... here.  New.
	[HAVE_UST]: Call gdb_ust_init.
	(initialize_tracepoint_ftlib):  Call gdb_agent_init.
	* configure.ac: Add `sys/un.h' to AC_CHECK_HEADERS.
	* config.in, configure: Regenerated.
@
text
@d235 2
a236 1
   tracepoints libraries are loaded in the inferior.  */
d239 1
a239 1
in_process_agent_loaded_ust (void)
d249 1
a249 1
  if (read_inferior_integer (ipa_sym_addrs.addr_ust_loaded, &loaded))
d251 9
a259 2
      warning ("Error reading ust_loaded in lib");
      return 0;
d261 2
a262 2

  return loaded;
d314 1
a314 1
  else if (!in_process_agent_loaded_ust ())
d2918 2
a2919 1
      if (tpoint->type == static_tracepoint && !in_process_agent_loaded_ust ())
d6838 2
@


1.49
log
@gdb/gdbserver:
	* tracepoint.c (do_action_at_tracepoint): Write `stop_pc' in
	debug log.
@
text
@d20 2
a182 2
  CORE_ADDR addr_helper_thread_id;
  CORE_ADDR addr_cmd_buf;
a184 8
#define STRINGIZE_1(STR) #STR
#define STRINGIZE(STR) STRINGIZE_1(STR)
#define IPA_SYM(SYM)					\
  {							\
    STRINGIZE (gdb_agent_ ## SYM),			\
    offsetof (struct ipa_sym_addresses, addr_ ## SYM)	\
  }

a219 2
  IPA_SYM(helper_thread_id),
  IPA_SYM(cmd_buf),
d222 1
a222 1
struct ipa_sym_addresses ipa_sym_addrs;
d341 3
a1237 4
/* The size in bytes of the buffer used to talk to the IPA helper
   thread.  */
#define CMD_BUF_SIZE 1024

d2209 1
a2209 1
  char cmd[CMD_BUF_SIZE];
d2783 1
a2783 1
  char cmd[CMD_BUF_SIZE];
d6136 1
a6136 1
IP_AGENT_EXPORT char cmd_buf[CMD_BUF_SIZE];
a6384 14
#ifdef HAVE_UST

#include <sys/socket.h>
#include <sys/un.h>

#ifndef UNIX_PATH_MAX
#define UNIX_PATH_MAX sizeof(((struct sockaddr_un *) NULL)->sun_path)
#endif

/* Where we put the socked used for synchronization.  */
#define SOCK_DIR P_tmpdir

#endif /* HAVE_UST */

a6386 72
#ifdef HAVE_UST

static int
gdb_ust_connect_sync_socket (int pid)
{
  struct sockaddr_un addr;
  int res, fd;
  char path[UNIX_PATH_MAX];

  res = xsnprintf (path, UNIX_PATH_MAX, "%s/gdb_ust%d", SOCK_DIR, pid);
  if (res >= UNIX_PATH_MAX)
    {
      trace_debug ("string overflow allocating socket name");
      return -1;
    }

  res = fd = socket (PF_UNIX, SOCK_STREAM, 0);
  if (res == -1)
    {
      warning ("error opening sync socket: %s\n", strerror (errno));
      return -1;
    }

  addr.sun_family = AF_UNIX;

  res = xsnprintf (addr.sun_path, UNIX_PATH_MAX, "%s", path);
  if (res >= UNIX_PATH_MAX)
    {
      warning ("string overflow allocating socket name\n");
      close (fd);
      return -1;
    }

  res = connect (fd, (struct sockaddr *) &addr, sizeof (addr));
  if (res == -1)
    {
      warning ("error connecting sync socket (%s): %s. "
	       "Make sure the directory exists and that it is writable.",
	       path, strerror (errno));
      close (fd);
      return -1;
    }

  return fd;
}

/* Resume thread PTID.  */

static void
resume_thread (ptid_t ptid)
{
  struct thread_resume resume_info;

  resume_info.thread = ptid;
  resume_info.kind = resume_continue;
  resume_info.sig = TARGET_SIGNAL_0;
  (*the_target->resume) (&resume_info, 1);
}

/* Stop thread PTID.  */

static void
stop_thread (ptid_t ptid)
{
  struct thread_resume resume_info;

  resume_info.thread = ptid;
  resume_info.kind = resume_stop;
  resume_info.sig = TARGET_SIGNAL_0;
  (*the_target->resume) (&resume_info, 1);
}

a6397 1
  int fd = -1;
a6398 2
  int tid;
  ptid_t ptid = null_ptid;
d6405 1
a6405 75
  if (read_inferior_integer (ipa_sym_addrs.addr_helper_thread_id, &tid))
    {
      warning ("Error reading helper thread's id in lib");
      goto out;
    }

  if (tid == 0)
    {
      warning ("helper thread not initialized yet");
      goto out;
    }

  if (write_inferior_memory (ipa_sym_addrs.addr_cmd_buf,
			     (unsigned char *) cmd, strlen (cmd) + 1))
    {
      warning ("Error writing command");
      goto out;
    }

  ptid = ptid_build (pid, tid, 0);

  resume_thread (ptid);

  fd = gdb_ust_connect_sync_socket (pid);
  if (fd >= 0)
    {
      char buf[1] = "";
      int ret;

      trace_debug ("signalling helper thread");

      do
	{
	  ret = write (fd, buf, 1);
	} while (ret == -1 && errno == EINTR);

      trace_debug ("waiting for helper thread's response");

      do
	{
	  ret = read (fd, buf, 1);
	} while (ret == -1 && errno == EINTR);

      close (fd);

      trace_debug ("helper thread's response received");
    }

 out:

  /* Need to read response with the inferior stopped.  */
  if (!ptid_equal (ptid, null_ptid))
    {
      int was_non_stop = non_stop;
      struct target_waitstatus status;

      stop_thread (ptid);
      non_stop = 1;
      mywait (ptid, &status, 0, 0);
      non_stop = was_non_stop;
    }

  if (fd >= 0)
    {
      if (read_inferior_memory (ipa_sym_addrs.addr_cmd_buf,
				(unsigned char *) cmd, CMD_BUF_SIZE))
	{
	  warning ("Error reading command response");
	}
      else
	{
	  err = 0;
	  trace_debug ("run_inferior_command: response: %s", cmd);
	}
    }
d6413 1
a6413 1
#else /* HAVE_UST */
d6415 2
a6416 5
static int
run_inferior_command (char *cmd)
{
  return -1;
}
d6418 3
a6420 1
#endif /* HAVE_UST */
d6422 2
a6423 1
#else /* !IN_PROCESS_AGENT */
a6428 2
#ifdef HAVE_UST

d6481 1
a6481 1
gdb_ust_socket_init (void)
d6503 1
a6503 11
/* Return an hexstr version of the STR C string, fit for sending to
   GDB.  */

static char *
cstr_to_hexstr (const char *str)
{
  int len = strlen (str);
  char *hexstr = xmalloc (len * 2 + 1);
  convert_int_to_ascii ((gdb_byte *) str, hexstr, len);
  return hexstr;
}
d6543 12
d6715 11
d6728 2
d6731 1
a6731 1
gdb_ust_thread (void *arg)
d6737 1
a6737 1
      listen_fd = gdb_ust_socket_init ();
d6787 1
d6814 1
a6814 6
	      else if (strcmp (cmd_buf, "help") == 0)
		{
		  strcpy (cmd_buf, "for help, press F1\n");
		}
	      else
		strcpy (cmd_buf, "");
d6827 1
d6830 1
a6830 1
gdb_ust_init (void)
a6836 3
  if (!dlsym_ust ())
    return;

d6847 1
a6847 1
			gdb_ust_thread,
d6857 3
a6859 1
  USTF(ltt_probe_register) (&gdb_ust_probe);
a6861 2
#endif /* HAVE_UST */

d6892 1
a6892 3
#ifdef HAVE_UST
  gdb_ust_init ();
#endif
@


1.48
log
@gdb/gdbserver:
	* tracepoint.c (collect_ust_data_at_tracepoint): Remove parameters
	`stop_pc' and `tpoint'.  Update caller.
@
text
@d4476 1
a4476 1
		     paddress (tpoint->address));
@


1.47
log
@2012-02-24  Luis Machado  <lgustavo@@codesourcery>

	* server.h: Include tracepoint.h.
	(agent_mem_read, agent_get_trace_state_variable_value,
	agent_set_trace_state_variable_value,
	agent_tsv_read, agent_mem_read_string, get_get_tsv_func_addr,
	get_set_tsv_func_addr): New prototypes.

	* ax.h: New include file.
	* ax.c: New source file.

	* tracepoint.c: Include ax.h.
	(gdb_agent_op, gdb_agent_op_names, gdb_agent_op_sizes,
	agent_expr, eval_result_type): Move to ax.h.
	(parse_agent_expr): Rename to ...
	(gdb_parse_agent_expr): ... this, make it non-static and move
	to ax.h.
	(unparse_agent_expr) Rename to ...
	(gdb_unparse_agent_expr): ... this, make it non-static and move
	to ax.h.
	(eval_agent_expr): Rename to ...
	(eval_tracepoint_agent_expr): ... this.
	(agent_mem_read, agent_mem_read_string, agent_tsv_read): Remove
	forward declarations.
	(add_tracepoint_action): Call gdb_parse_agent_expr (...).
	(agent_get_trace_state_variable_value): New function.
	(agent_set_trace_state_variable_value): New function.
	(cmd_qtdp): Call gdb_parse_agent_expr (...).
	(response_tracepoint): Call gdb_unparse_agent_expr (...).
	(do_action_at_tracepoint): Call eval_tracepoint_agent_expr (...).
	(condition_true_at_tracepoint): Likewise.
	(parse_agent_expr): Rename to ...
	(gdb_parse_agent_expr): ... this and move to ax.c.
	(unparse_agent_expr): Rename to ...
	(gdb_unparse_agent_expr): ... this and move to ax.c.
	(gdb_agent_op_name): Move to ax.c.
	(eval_agent_expr): Rename to ...
	(gdb_eval_agent_expr): ... this, use regcache passed as parameter
	and move to ax.c.
	(eval_tracepoint_agent_expr): New function.
	(agent_mem_read, agent_mem_read_string, agent_tsv_read): Make
	non-static.
	(current_insn_ptr, emit_error, struct bytecode_address): Move to
	ax.c.
	(emit_prologue, emit_epilogue, emit_add, emit_sub, emit_mul, emit_lsh,
	emit_rsh_signed, emit_rsh_unsigned, emit_ext, emit_log_not,
	emit_bit_and, emit_bit_or, emit_bit_xor, emit_bit_not, emit_equal,
	emit_less_signed, emit_less_unsigned, emit_ref, emit_if_goto,
	emit_goto, write_goto_address, emit_const, emit_reg, emit_pop,
	emit_stack, emit_zero_ext, emit_swap, emit_stack_adjust,
	emit_int_call_1, emit_void_call_2, emit_eq_goto, emit_ne_goto,
	emit_lt_goto, emit_ge_goto, emit_gt_goto, emit_le_goto): Move to ax.c.
	(get_get_tsv_func_addr, get_set_tsv_func_addr): New functions.
	(compile_bytecodes): Remove forward declaration.
	(is_goto_target): Move to ax.c.
	(compile_bytecodes): Move to ax.c and call
	agent_get_trace_state_variable_value (...) and
	agent_set_trace_state_variable_value (...).

	* Makefile.in: Update ax.c and IPA dependencies.
@
text
@a4266 2
					    CORE_ADDR stop_pc,
					    struct tracepoint *tpoint,
d4505 1
a4505 2
	collect_ust_data_at_tracepoint (ctx, stop_pc,
					tpoint, tframe);
a6339 2
				CORE_ADDR stop_pc,
				struct tracepoint *tpoint,
@


1.46
log
@2012-02-24  Pedro Alves  <palves@@redhat.com>

	* tracepoint.c (cmd_bigqtbuffer): Rename as ...
	(cmd_bigqtbuffer_circular): ... this.  Only handle
	'QTBuffer:circular:'.
	(handle_tracepoint_general_set): Adjust.
@
text
@d28 1
d67 1
a67 5
#ifdef IN_PROCESS_AGENT
  fprintf (stderr, "ipa/tracepoint: %s\n", buf);
#else
  fprintf (stderr, "gdbserver/tracepoint: %s\n", buf);
#endif
a70 4
#ifdef IN_PROCESS_AGENT
#define debug_threads debug_agent
#endif

a369 2
int debug_agent = 0;

a473 35
/* This enum must exactly match what is documented in
   gdb/doc/agentexpr.texi, including all the numerical values.  */

enum gdb_agent_op
  {
#define DEFOP(NAME, SIZE, DATA_SIZE, CONSUMED, PRODUCED, VALUE)  \
    gdb_agent_op_ ## NAME = VALUE,
#include "ax.def"
#undef DEFOP
    gdb_agent_op_last
  };

static const char *gdb_agent_op_names [gdb_agent_op_last] =
  {
    "?undef?"
#define DEFOP(NAME, SIZE, DATA_SIZE, CONSUMED, PRODUCED, VALUE)  , # NAME
#include "ax.def"
#undef DEFOP
  };

static const unsigned char gdb_agent_op_sizes [gdb_agent_op_last] =
  {
    0
#define DEFOP(NAME, SIZE, DATA_SIZE, CONSUMED, PRODUCED, VALUE)  , SIZE
#include "ax.def"
#undef DEFOP
  };

struct agent_expr
{
  int length;

  unsigned char *bytes;
};

a704 16
/* Enumeration of the different kinds of things that can happen during
   agent expression evaluation.  */

enum eval_result_type
  {
    expr_eval_no_error,
    expr_eval_empty_expression,
    expr_eval_empty_stack,
    expr_eval_stack_overflow,
    expr_eval_stack_underflow,
    expr_eval_unhandled_opcode,
    expr_eval_unrecognized_opcode,
    expr_eval_divide_by_zero,
    expr_eval_invalid_goto
  };

d1188 5
a1192 15
#ifndef IN_PROCESS_AGENT
static struct agent_expr *parse_agent_expr (char **actparm);
static char *unparse_agent_expr (struct agent_expr *aexpr);
#endif
static enum eval_result_type eval_agent_expr (struct tracepoint_hit_ctx *ctx,
					      struct traceframe *tframe,
					      struct agent_expr *aexpr,
					      ULONGEST *rslt);

static int agent_mem_read (struct traceframe *tframe,
			   unsigned char *to, CORE_ADDR from, ULONGEST len);
static int agent_mem_read_string (struct traceframe *tframe,
				  unsigned char *to, CORE_ADDR from,
				  ULONGEST len);
static int agent_tsv_read (struct traceframe *tframe, int n);
d1825 1
a1825 1
	    xaction->expr = parse_agent_expr (&act);
d1969 12
d2357 1
a2357 1
	      tpoint->cond = parse_agent_expr (&actparm);
d3467 1
a3467 1
      buf = unparse_agent_expr (tpoint->cond);
d4494 1
a4494 1
	err = eval_agent_expr (ctx, tframe, eaction->expr, NULL);
d4547 1
a4547 1
    err = eval_agent_expr (ctx, NULL, tpoint->cond, &value);
d4562 3
a4564 1
#ifndef IN_PROCESS_AGENT
d4566 5
a4570 5
/* The packet form of an agent expression consists of an 'X', number
   of bytes in expression, a comma, and then the bytes.  */

static struct agent_expr *
parse_agent_expr (char **actparm)
d4572 2
a4573 18
  char *act = *actparm;
  ULONGEST xlen;
  struct agent_expr *aexpr;

  ++act;  /* skip the X */
  act = unpack_varlen_hex (act, &xlen);
  ++act;  /* skip a comma */
  aexpr = xmalloc (sizeof (struct agent_expr));
  aexpr->length = xlen;
  aexpr->bytes = xmalloc (xlen);
  convert_ascii_to_int (act, aexpr->bytes, xlen);
  *actparm = act + (xlen * 2);
  return aexpr;
}

/* Convert the bytes of an agent expression back into hex digits, so
   they can be printed or uploaded.  This allocates the buffer,
   callers should free when they are done with it.  */
d4575 1
a4575 424
static char *
unparse_agent_expr (struct agent_expr *aexpr)
{
  char *rslt;

  rslt = xmalloc (2 * aexpr->length + 1);
  convert_int_to_ascii (aexpr->bytes, rslt, aexpr->length);
  return rslt;
}

#endif

/* A wrapper for gdb_agent_op_names that does some bounds-checking.  */

static const char *
gdb_agent_op_name (int op)
{
  if (op < 0 || op >= gdb_agent_op_last || gdb_agent_op_names[op] == NULL)
    return "?undef?";
  return gdb_agent_op_names[op];
}

/* The agent expression evaluator, as specified by the GDB docs. It
   returns 0 if everything went OK, and a nonzero error code
   otherwise.  */

static enum eval_result_type
eval_agent_expr (struct tracepoint_hit_ctx *ctx,
		 struct traceframe *tframe,
		 struct agent_expr *aexpr,
		 ULONGEST *rslt)
{
  int pc = 0;
#define STACK_MAX 100
  ULONGEST stack[STACK_MAX], top;
  int sp = 0;
  unsigned char op;
  int arg;

  /* This union is a convenient way to convert representations.  For
     now, assume a standard architecture where the hardware integer
     types have 8, 16, 32, 64 bit types.  A more robust solution would
     be to import stdint.h from gnulib.  */
  union
  {
    union
    {
      unsigned char bytes[1];
      unsigned char val;
    } u8;
    union
    {
      unsigned char bytes[2];
      unsigned short val;
    } u16;
    union
    {
      unsigned char bytes[4];
      unsigned int val;
    } u32;
    union
    {
      unsigned char bytes[8];
      ULONGEST val;
    } u64;
  } cnv;

  if (aexpr->length == 0)
    {
      trace_debug ("empty agent expression");
      return expr_eval_empty_expression;
    }

  /* Cache the stack top in its own variable. Much of the time we can
     operate on this variable, rather than dinking with the stack. It
     needs to be copied to the stack when sp changes.  */
  top = 0;

  while (1)
    {
      op = aexpr->bytes[pc++];

      trace_debug ("About to interpret byte 0x%x", op);

      switch (op)
	{
	case gdb_agent_op_add:
	  top += stack[--sp];
	  break;

	case gdb_agent_op_sub:
	  top = stack[--sp] - top;
	  break;

	case gdb_agent_op_mul:
	  top *= stack[--sp];
	  break;

	case gdb_agent_op_div_signed:
	  if (top == 0)
	    {
	      trace_debug ("Attempted to divide by zero");
	      return expr_eval_divide_by_zero;
	    }
	  top = ((LONGEST) stack[--sp]) / ((LONGEST) top);
	  break;

	case gdb_agent_op_div_unsigned:
	  if (top == 0)
	    {
	      trace_debug ("Attempted to divide by zero");
	      return expr_eval_divide_by_zero;
	    }
	  top = stack[--sp] / top;
	  break;

	case gdb_agent_op_rem_signed:
	  if (top == 0)
	    {
	      trace_debug ("Attempted to divide by zero");
	      return expr_eval_divide_by_zero;
	    }
	  top = ((LONGEST) stack[--sp]) % ((LONGEST) top);
	  break;

	case gdb_agent_op_rem_unsigned:
	  if (top == 0)
	    {
	      trace_debug ("Attempted to divide by zero");
	      return expr_eval_divide_by_zero;
	    }
	  top = stack[--sp] % top;
	  break;

	case gdb_agent_op_lsh:
	  top = stack[--sp] << top;
	  break;

	case gdb_agent_op_rsh_signed:
	  top = ((LONGEST) stack[--sp]) >> top;
	  break;

	case gdb_agent_op_rsh_unsigned:
	  top = stack[--sp] >> top;
	  break;

	case gdb_agent_op_trace:
	  agent_mem_read (tframe,
			  NULL, (CORE_ADDR) stack[--sp], (ULONGEST) top);
	  if (--sp >= 0)
	    top = stack[sp];
	  break;

	case gdb_agent_op_trace_quick:
	  arg = aexpr->bytes[pc++];
	  agent_mem_read (tframe, NULL, (CORE_ADDR) top, (ULONGEST) arg);
	  break;

	case gdb_agent_op_log_not:
	  top = !top;
	  break;

	case gdb_agent_op_bit_and:
	  top &= stack[--sp];
	  break;

	case gdb_agent_op_bit_or:
	  top |= stack[--sp];
	  break;

	case gdb_agent_op_bit_xor:
	  top ^= stack[--sp];
	  break;

	case gdb_agent_op_bit_not:
	  top = ~top;
	  break;

	case gdb_agent_op_equal:
	  top = (stack[--sp] == top);
	  break;

	case gdb_agent_op_less_signed:
	  top = (((LONGEST) stack[--sp]) < ((LONGEST) top));
	  break;

	case gdb_agent_op_less_unsigned:
	  top = (stack[--sp] < top);
	  break;

	case gdb_agent_op_ext:
	  arg = aexpr->bytes[pc++];
	  if (arg < (sizeof (LONGEST) * 8))
	    {
	      LONGEST mask = 1 << (arg - 1);
	      top &= ((LONGEST) 1 << arg) - 1;
	      top = (top ^ mask) - mask;
	    }
	  break;

	case gdb_agent_op_ref8:
	  agent_mem_read (tframe, cnv.u8.bytes, (CORE_ADDR) top, 1);
	  top = cnv.u8.val;
	  break;

	case gdb_agent_op_ref16:
	  agent_mem_read (tframe, cnv.u16.bytes, (CORE_ADDR) top, 2);
	  top = cnv.u16.val;
	  break;

	case gdb_agent_op_ref32:
	  agent_mem_read (tframe, cnv.u32.bytes, (CORE_ADDR) top, 4);
	  top = cnv.u32.val;
	  break;

	case gdb_agent_op_ref64:
	  agent_mem_read (tframe, cnv.u64.bytes, (CORE_ADDR) top, 8);
	  top = cnv.u64.val;
	  break;

	case gdb_agent_op_if_goto:
	  if (top)
	    pc = (aexpr->bytes[pc] << 8) + (aexpr->bytes[pc + 1]);
	  else
	    pc += 2;
	  if (--sp >= 0)
	    top = stack[sp];
	  break;

	case gdb_agent_op_goto:
	  pc = (aexpr->bytes[pc] << 8) + (aexpr->bytes[pc + 1]);
	  break;

	case gdb_agent_op_const8:
	  /* Flush the cached stack top.  */
	  stack[sp++] = top;
	  top = aexpr->bytes[pc++];
	  break;

	case gdb_agent_op_const16:
	  /* Flush the cached stack top.  */
	  stack[sp++] = top;
	  top = aexpr->bytes[pc++];
	  top = (top << 8) + aexpr->bytes[pc++];
	  break;

	case gdb_agent_op_const32:
	  /* Flush the cached stack top.  */
	  stack[sp++] = top;
	  top = aexpr->bytes[pc++];
	  top = (top << 8) + aexpr->bytes[pc++];
	  top = (top << 8) + aexpr->bytes[pc++];
	  top = (top << 8) + aexpr->bytes[pc++];
	  break;

	case gdb_agent_op_const64:
	  /* Flush the cached stack top.  */
	  stack[sp++] = top;
	  top = aexpr->bytes[pc++];
	  top = (top << 8) + aexpr->bytes[pc++];
	  top = (top << 8) + aexpr->bytes[pc++];
	  top = (top << 8) + aexpr->bytes[pc++];
	  top = (top << 8) + aexpr->bytes[pc++];
	  top = (top << 8) + aexpr->bytes[pc++];
	  top = (top << 8) + aexpr->bytes[pc++];
	  top = (top << 8) + aexpr->bytes[pc++];
	  break;

	case gdb_agent_op_reg:
	  /* Flush the cached stack top.  */
	  stack[sp++] = top;
	  arg = aexpr->bytes[pc++];
	  arg = (arg << 8) + aexpr->bytes[pc++];
	  {
	    int regnum = arg;
	    struct regcache *regcache;

	    regcache = get_context_regcache (ctx);

	    switch (register_size (regnum))
	      {
	      case 8:
		collect_register (regcache, regnum, cnv.u64.bytes);
		top = cnv.u64.val;
		break;
	      case 4:
		collect_register (regcache, regnum, cnv.u32.bytes);
		top = cnv.u32.val;
		break;
	      case 2:
		collect_register (regcache, regnum, cnv.u16.bytes);
		top = cnv.u16.val;
		break;
	      case 1:
		collect_register (regcache, regnum, cnv.u8.bytes);
		top = cnv.u8.val;
		break;
	      default:
		internal_error (__FILE__, __LINE__,
				"unhandled register size");
	      }
	  }
	  break;

	case gdb_agent_op_end:
	  trace_debug ("At end of expression, sp=%d, stack top cache=0x%s",
		       sp, pulongest (top));
	  if (rslt)
	    {
	      if (sp <= 0)
		{
		  /* This should be an error */
		  trace_debug ("Stack is empty, nothing to return");
		  return expr_eval_empty_stack;
		}
	      *rslt = top;
	    }
	  return expr_eval_no_error;

	case gdb_agent_op_dup:
	  stack[sp++] = top;
	  break;

	case gdb_agent_op_pop:
	  if (--sp >= 0)
	    top = stack[sp];
	  break;

	case gdb_agent_op_pick:
	  arg = aexpr->bytes[pc++];
	  stack[sp] = top;
	  top = stack[sp - arg];
	  ++sp;
	  break;

	case gdb_agent_op_rot:
	  {
	    ULONGEST tem = stack[sp - 1];

	    stack[sp - 1] = stack[sp - 2];
	    stack[sp - 2] = top;
	    top = tem;
	  }
	  break;

	case gdb_agent_op_zero_ext:
	  arg = aexpr->bytes[pc++];
	  if (arg < (sizeof (LONGEST) * 8))
	    top &= ((LONGEST) 1 << arg) - 1;
	  break;

	case gdb_agent_op_swap:
	  /* Interchange top two stack elements, making sure top gets
	     copied back onto stack.  */
	  stack[sp] = top;
	  top = stack[sp - 1];
	  stack[sp - 1] = stack[sp];
	  break;

	case gdb_agent_op_getv:
	  /* Flush the cached stack top.  */
	  stack[sp++] = top;
	  arg = aexpr->bytes[pc++];
	  arg = (arg << 8) + aexpr->bytes[pc++];
	  top = get_trace_state_variable_value (arg);
	  break;

	case gdb_agent_op_setv:
	  arg = aexpr->bytes[pc++];
	  arg = (arg << 8) + aexpr->bytes[pc++];
	  set_trace_state_variable_value (arg, top);
	  /* Note that we leave the value on the stack, for the
	     benefit of later/enclosing expressions.  */
	  break;

	case gdb_agent_op_tracev:
	  arg = aexpr->bytes[pc++];
	  arg = (arg << 8) + aexpr->bytes[pc++];
	  agent_tsv_read (tframe, arg);
	  break;

	case gdb_agent_op_tracenz:
	  agent_mem_read_string (tframe, NULL, (CORE_ADDR) stack[--sp],
				 (ULONGEST) top);
	  if (--sp >= 0)
	    top = stack[sp];
	  break;

	  /* GDB never (currently) generates any of these ops.  */
	case gdb_agent_op_float:
	case gdb_agent_op_ref_float:
	case gdb_agent_op_ref_double:
	case gdb_agent_op_ref_long_double:
	case gdb_agent_op_l_to_d:
	case gdb_agent_op_d_to_l:
	case gdb_agent_op_trace16:
	  trace_debug ("Agent expression op 0x%x valid, but not handled",
		       op);
	  /* If ever GDB generates any of these, we don't have the
	     option of ignoring.  */
	  return 1;

	default:
	  trace_debug ("Agent expression op 0x%x not recognized", op);
	  /* Don't struggle on, things will just get worse.  */
	  return expr_eval_unrecognized_opcode;
	}

      /* Check for stack badness.  */
      if (sp >= (STACK_MAX - 1))
	{
	  trace_debug ("Expression stack overflow");
	  return expr_eval_stack_overflow;
	}

      if (sp < 0)
	{
	  trace_debug ("Expression stack underflow");
	  return expr_eval_stack_underflow;
	}

      trace_debug ("Op %s -> sp=%d, top=0x%s",
		   gdb_agent_op_name (op), sp, pulongest (top));
    }
d4581 1
a4581 1
static int
d4623 1
a4623 1
static int
d4685 1
a4685 1
static int
a5477 16
/* Bytecode compilation.  */

CORE_ADDR current_insn_ptr;

int emit_error;

struct bytecode_address
{
  int pc;
  CORE_ADDR address;
  int goto_pc;
  /* Offset and size of field to be modified in the goto block.  */
  int from_offset, from_size;
  struct bytecode_address *next;
} *bytecode_address_table;

d5484 2
a5485 2
static void
emit_prologue (void)
d5487 1
a5487 1
  target_emit_ops ()->emit_prologue ();
d5490 2
a5491 210
static void
emit_epilogue (void)
{
  target_emit_ops ()->emit_epilogue ();
}

static void
emit_add (void)
{
  target_emit_ops ()->emit_add ();
}

static void
emit_sub (void)
{
  target_emit_ops ()->emit_sub ();
}

static void
emit_mul (void)
{
  target_emit_ops ()->emit_mul ();
}

static void
emit_lsh (void)
{
  target_emit_ops ()->emit_lsh ();
}

static void
emit_rsh_signed (void)
{
  target_emit_ops ()->emit_rsh_signed ();
}

static void
emit_rsh_unsigned (void)
{
  target_emit_ops ()->emit_rsh_unsigned ();
}

static void
emit_ext (int arg)
{
  target_emit_ops ()->emit_ext (arg);
}

static void
emit_log_not (void)
{
  target_emit_ops ()->emit_log_not ();
}

static void
emit_bit_and (void)
{
  target_emit_ops ()->emit_bit_and ();
}

static void
emit_bit_or (void)
{
  target_emit_ops ()->emit_bit_or ();
}

static void
emit_bit_xor (void)
{
  target_emit_ops ()->emit_bit_xor ();
}

static void
emit_bit_not (void)
{
  target_emit_ops ()->emit_bit_not ();
}

static void
emit_equal (void)
{
  target_emit_ops ()->emit_equal ();
}

static void
emit_less_signed (void)
{
  target_emit_ops ()->emit_less_signed ();
}

static void
emit_less_unsigned (void)
{
  target_emit_ops ()->emit_less_unsigned ();
}

static void
emit_ref (int size)
{
  target_emit_ops ()->emit_ref (size);
}

static void
emit_if_goto (int *offset_p, int *size_p)
{
  target_emit_ops ()->emit_if_goto (offset_p, size_p);
}

static void
emit_goto (int *offset_p, int *size_p)
{
  target_emit_ops ()->emit_goto (offset_p, size_p);
}

static void
write_goto_address (CORE_ADDR from, CORE_ADDR to, int size)
{
  target_emit_ops ()->write_goto_address (from, to, size);
}

static void
emit_const (LONGEST num)
{
  target_emit_ops ()->emit_const (num);
}

static void
emit_reg (int reg)
{
  target_emit_ops ()->emit_reg (reg);
}

static void
emit_pop (void)
{
  target_emit_ops ()->emit_pop ();
}

static void
emit_stack_flush (void)
{
  target_emit_ops ()->emit_stack_flush ();
}

static void
emit_zero_ext (int arg)
{
  target_emit_ops ()->emit_zero_ext (arg);
}

static void
emit_swap (void)
{
  target_emit_ops ()->emit_swap ();
}

static void
emit_stack_adjust (int n)
{
  target_emit_ops ()->emit_stack_adjust (n);
}

/* FN's prototype is `LONGEST(*fn)(int)'.  */

static void
emit_int_call_1 (CORE_ADDR fn, int arg1)
{
  target_emit_ops ()->emit_int_call_1 (fn, arg1);
}

/* FN's prototype is `void(*fn)(int,LONGEST)'.  */

static void
emit_void_call_2 (CORE_ADDR fn, int arg1)
{
  target_emit_ops ()->emit_void_call_2 (fn, arg1);
}

static void
emit_eq_goto (int *offset_p, int *size_p)
{
  target_emit_ops ()->emit_eq_goto (offset_p, size_p);
}

static void
emit_ne_goto (int *offset_p, int *size_p)
{
  target_emit_ops ()->emit_ne_goto (offset_p, size_p);
}

static void
emit_lt_goto (int *offset_p, int *size_p)
{
  target_emit_ops ()->emit_lt_goto (offset_p, size_p);
}

static void
emit_ge_goto (int *offset_p, int *size_p)
{
  target_emit_ops ()->emit_ge_goto (offset_p, size_p);
}

static void
emit_gt_goto (int *offset_p, int *size_p)
{
  target_emit_ops ()->emit_gt_goto (offset_p, size_p);
}

static void
emit_le_goto (int *offset_p, int *size_p)
d5493 1
a5493 1
  target_emit_ops ()->emit_le_goto (offset_p, size_p);
a5495 2
static enum eval_result_type compile_bytecodes (struct agent_expr *aexpr);

a5542 430
/* Scan an agent expression for any evidence that the given PC is the
   target of a jump bytecode in the expression.  */

int
is_goto_target (struct agent_expr *aexpr, int pc)
{
  int i;
  unsigned char op;

  for (i = 0; i < aexpr->length; i += 1 + gdb_agent_op_sizes[op])
    {
      op = aexpr->bytes[i];

      if (op == gdb_agent_op_goto || op == gdb_agent_op_if_goto)
	{
	  int target = (aexpr->bytes[i + 1] << 8) + aexpr->bytes[i + 2];
	  if (target == pc)
	    return 1;
	}
    }

  return 0;
}

/* Given an agent expression, turn it into native code.  */

static enum eval_result_type
compile_bytecodes (struct agent_expr *aexpr)
{
  int pc = 0;
  int done = 0;
  unsigned char op, next_op;
  int arg;
  /* This is only used to build 64-bit value for constants.  */
  ULONGEST top;
  struct bytecode_address *aentry, *aentry2;

#define UNHANDLED					\
  do							\
    {							\
      trace_debug ("Cannot compile op 0x%x\n", op);	\
      return expr_eval_unhandled_opcode;		\
    } while (0)

  if (aexpr->length == 0)
    {
      trace_debug ("empty agent expression\n");
      return expr_eval_empty_expression;
    }

  bytecode_address_table = NULL;

  while (!done)
    {
      op = aexpr->bytes[pc];

      trace_debug ("About to compile op 0x%x, pc=%d\n", op, pc);

      /* Record the compiled-code address of the bytecode, for use by
	 jump instructions.  */
      aentry = xmalloc (sizeof (struct bytecode_address));
      aentry->pc = pc;
      aentry->address = current_insn_ptr;
      aentry->goto_pc = -1;
      aentry->from_offset = aentry->from_size = 0;
      aentry->next = bytecode_address_table;
      bytecode_address_table = aentry;

      ++pc;

      emit_error = 0;

      switch (op)
	{
	case gdb_agent_op_add:
	  emit_add ();
	  break;

	case gdb_agent_op_sub:
	  emit_sub ();
	  break;

	case gdb_agent_op_mul:
	  emit_mul ();
	  break;

	case gdb_agent_op_div_signed:
	  UNHANDLED;
	  break;

	case gdb_agent_op_div_unsigned:
	  UNHANDLED;
	  break;

	case gdb_agent_op_rem_signed:
	  UNHANDLED;
	  break;

	case gdb_agent_op_rem_unsigned:
	  UNHANDLED;
	  break;

	case gdb_agent_op_lsh:
	  emit_lsh ();
	  break;

	case gdb_agent_op_rsh_signed:
	  emit_rsh_signed ();
	  break;

	case gdb_agent_op_rsh_unsigned:
	  emit_rsh_unsigned ();
	  break;

	case gdb_agent_op_trace:
	  UNHANDLED;
	  break;

	case gdb_agent_op_trace_quick:
	  UNHANDLED;
	  break;

	case gdb_agent_op_log_not:
	  emit_log_not ();
	  break;

	case gdb_agent_op_bit_and:
	  emit_bit_and ();
	  break;

	case gdb_agent_op_bit_or:
	  emit_bit_or ();
	  break;

	case gdb_agent_op_bit_xor:
	  emit_bit_xor ();
	  break;

	case gdb_agent_op_bit_not:
	  emit_bit_not ();
	  break;

	case gdb_agent_op_equal:
	  next_op = aexpr->bytes[pc];
	  if (next_op == gdb_agent_op_if_goto
	      && !is_goto_target (aexpr, pc)
	      && target_emit_ops ()->emit_eq_goto)
	    {
	      trace_debug ("Combining equal & if_goto");
	      pc += 1;
	      aentry->pc = pc;
	      arg = aexpr->bytes[pc++];
	      arg = (arg << 8) + aexpr->bytes[pc++];
	      aentry->goto_pc = arg;
	      emit_eq_goto (&(aentry->from_offset), &(aentry->from_size));
	    }
	  else if (next_op == gdb_agent_op_log_not
		   && (aexpr->bytes[pc + 1] == gdb_agent_op_if_goto)
		   && !is_goto_target (aexpr, pc + 1)
		   && target_emit_ops ()->emit_ne_goto)
	    {
	      trace_debug ("Combining equal & log_not & if_goto");
	      pc += 2;
	      aentry->pc = pc;
	      arg = aexpr->bytes[pc++];
	      arg = (arg << 8) + aexpr->bytes[pc++];
	      aentry->goto_pc = arg;
	      emit_ne_goto (&(aentry->from_offset), &(aentry->from_size));
	    }
	  else
	    emit_equal ();
	  break;

	case gdb_agent_op_less_signed:
	  next_op = aexpr->bytes[pc];
	  if (next_op == gdb_agent_op_if_goto
	      && !is_goto_target (aexpr, pc))
	    {
	      trace_debug ("Combining less_signed & if_goto");
	      pc += 1;
	      aentry->pc = pc;
	      arg = aexpr->bytes[pc++];
	      arg = (arg << 8) + aexpr->bytes[pc++];
	      aentry->goto_pc = arg;
	      emit_lt_goto (&(aentry->from_offset), &(aentry->from_size));
	    }
	  else if (next_op == gdb_agent_op_log_not
		   && !is_goto_target (aexpr, pc)
		   && (aexpr->bytes[pc + 1] == gdb_agent_op_if_goto)
		   && !is_goto_target (aexpr, pc + 1))
	    {
	      trace_debug ("Combining less_signed & log_not & if_goto");
	      pc += 2;
	      aentry->pc = pc;
	      arg = aexpr->bytes[pc++];
	      arg = (arg << 8) + aexpr->bytes[pc++];
	      aentry->goto_pc = arg;
	      emit_ge_goto (&(aentry->from_offset), &(aentry->from_size));
	    }
	  else
	    emit_less_signed ();
	  break;

	case gdb_agent_op_less_unsigned:
	  emit_less_unsigned ();
	  break;

	case gdb_agent_op_ext:
	  arg = aexpr->bytes[pc++];
	  if (arg < (sizeof (LONGEST) * 8))
	    emit_ext (arg);
	  break;

	case gdb_agent_op_ref8:
	  emit_ref (1);
	  break;

	case gdb_agent_op_ref16:
	  emit_ref (2);
	  break;

	case gdb_agent_op_ref32:
	  emit_ref (4);
	  break;

	case gdb_agent_op_ref64:
	  emit_ref (8);
	  break;

	case gdb_agent_op_if_goto:
	  arg = aexpr->bytes[pc++];
	  arg = (arg << 8) + aexpr->bytes[pc++];
	  aentry->goto_pc = arg;
	  emit_if_goto (&(aentry->from_offset), &(aentry->from_size));
	  break;

	case gdb_agent_op_goto:
	  arg = aexpr->bytes[pc++];
	  arg = (arg << 8) + aexpr->bytes[pc++];
	  aentry->goto_pc = arg;
	  emit_goto (&(aentry->from_offset), &(aentry->from_size));
	  break;

	case gdb_agent_op_const8:
	  emit_stack_flush ();
	  top = aexpr->bytes[pc++];
	  emit_const (top);
	  break;

	case gdb_agent_op_const16:
	  emit_stack_flush ();
	  top = aexpr->bytes[pc++];
	  top = (top << 8) + aexpr->bytes[pc++];
	  emit_const (top);
	  break;

	case gdb_agent_op_const32:
	  emit_stack_flush ();
	  top = aexpr->bytes[pc++];
	  top = (top << 8) + aexpr->bytes[pc++];
	  top = (top << 8) + aexpr->bytes[pc++];
	  top = (top << 8) + aexpr->bytes[pc++];
	  emit_const (top);
	  break;

	case gdb_agent_op_const64:
	  emit_stack_flush ();
	  top = aexpr->bytes[pc++];
	  top = (top << 8) + aexpr->bytes[pc++];
	  top = (top << 8) + aexpr->bytes[pc++];
	  top = (top << 8) + aexpr->bytes[pc++];
	  top = (top << 8) + aexpr->bytes[pc++];
	  top = (top << 8) + aexpr->bytes[pc++];
	  top = (top << 8) + aexpr->bytes[pc++];
	  top = (top << 8) + aexpr->bytes[pc++];
	  emit_const (top);
	  break;

	case gdb_agent_op_reg:
	  emit_stack_flush ();
	  arg = aexpr->bytes[pc++];
	  arg = (arg << 8) + aexpr->bytes[pc++];
	  emit_reg (arg);
	  break;

	case gdb_agent_op_end:
	  trace_debug ("At end of expression\n");

	  /* Assume there is one stack element left, and that it is
	     cached in "top" where emit_epilogue can get to it.  */
	  emit_stack_adjust (1);

	  done = 1;
	  break;

	case gdb_agent_op_dup:
	  /* In our design, dup is equivalent to stack flushing.  */
	  emit_stack_flush ();
	  break;

	case gdb_agent_op_pop:
	  emit_pop ();
	  break;

	case gdb_agent_op_zero_ext:
	  arg = aexpr->bytes[pc++];
	  if (arg < (sizeof (LONGEST) * 8))
	    emit_zero_ext (arg);
	  break;

	case gdb_agent_op_swap:
	  next_op = aexpr->bytes[pc];
	  /* Detect greater-than comparison sequences.  */
	  if (next_op == gdb_agent_op_less_signed
	      && !is_goto_target (aexpr, pc)
	      && (aexpr->bytes[pc + 1] == gdb_agent_op_if_goto)
	      && !is_goto_target (aexpr, pc + 1))
	    {
	      trace_debug ("Combining swap & less_signed & if_goto");
	      pc += 2;
	      aentry->pc = pc;
	      arg = aexpr->bytes[pc++];
	      arg = (arg << 8) + aexpr->bytes[pc++];
	      aentry->goto_pc = arg;
	      emit_gt_goto (&(aentry->from_offset), &(aentry->from_size));
	    }
	  else if (next_op == gdb_agent_op_less_signed
		   && !is_goto_target (aexpr, pc)
		   && (aexpr->bytes[pc + 1] == gdb_agent_op_log_not)
		   && !is_goto_target (aexpr, pc + 1)
		   && (aexpr->bytes[pc + 2] == gdb_agent_op_if_goto)
		   && !is_goto_target (aexpr, pc + 2))
	    {
	      trace_debug ("Combining swap & less_signed & log_not & if_goto");
	      pc += 3;
	      aentry->pc = pc;
	      arg = aexpr->bytes[pc++];
	      arg = (arg << 8) + aexpr->bytes[pc++];
	      aentry->goto_pc = arg;
	      emit_le_goto (&(aentry->from_offset), &(aentry->from_size));
	    }
	  else
	    emit_swap ();
	  break;

	case gdb_agent_op_getv:
	  emit_stack_flush ();
	  arg = aexpr->bytes[pc++];
	  arg = (arg << 8) + aexpr->bytes[pc++];
	  emit_int_call_1 (ipa_sym_addrs.addr_get_trace_state_variable_value,
			   arg);
	  break;

	case gdb_agent_op_setv:
	  arg = aexpr->bytes[pc++];
	  arg = (arg << 8) + aexpr->bytes[pc++];
	  emit_void_call_2 (ipa_sym_addrs.addr_set_trace_state_variable_value,
			    arg);
	  break;

	case gdb_agent_op_tracev:
	  UNHANDLED;
	  break;

	  /* GDB never (currently) generates any of these ops.  */
	case gdb_agent_op_float:
	case gdb_agent_op_ref_float:
	case gdb_agent_op_ref_double:
	case gdb_agent_op_ref_long_double:
	case gdb_agent_op_l_to_d:
	case gdb_agent_op_d_to_l:
	case gdb_agent_op_trace16:
	  UNHANDLED;
	  break;

	default:
	  trace_debug ("Agent expression op 0x%x not recognized\n", op);
	  /* Don't struggle on, things will just get worse.  */
	  return expr_eval_unrecognized_opcode;
	}

      /* This catches errors that occur in target-specific code
	 emission.  */
      if (emit_error)
	{
	  trace_debug ("Error %d while emitting code for %s\n",
		       emit_error, gdb_agent_op_name (op));
	  return expr_eval_unhandled_opcode;
	}

      trace_debug ("Op %s compiled\n", gdb_agent_op_name (op));
    }

  /* Now fill in real addresses as goto destinations.  */
  for (aentry = bytecode_address_table; aentry; aentry = aentry->next)
    {
      int written = 0;

      if (aentry->goto_pc < 0)
	continue;

      /* Find the location that we are going to, and call back into
	 target-specific code to write the actual address or
	 displacement.  */
      for (aentry2 = bytecode_address_table; aentry2; aentry2 = aentry2->next)
	{
	  if (aentry2->pc == aentry->goto_pc)
	    {
	      trace_debug ("Want to jump from %s to %s\n",
			   paddress (aentry->address),
			   paddress (aentry2->address));
	      write_goto_address (aentry->address + aentry->from_offset,
				  aentry2->address, aentry->from_size);
	      written = 1;
	      break;
	    }
	}

      /* Error out if we didn't find a destination.  */
      if (!written)
	{
	  trace_debug ("Destination of goto %d not found\n",
		       aentry->goto_pc);
	  return expr_eval_invalid_goto;
	}
    }

  return expr_eval_no_error;
}

@


1.45
log
@gdbserver/
2012-02-02  Pedro Alves  <palves@@redhat.com>

	* tracepoint.c (cmd_qtminftpilen): Return 0 if there's no current
	inferior.

gdb/
2012-02-02  Pedro Alves  <palves@@redhat.com>

	* remote.c (remote_get_min_fast_tracepoint_insn_len): Return 0 if
	the current inferior has no execution.  Make sure the current
	remote process matches gdb's current inferior.
@
text
@d3797 1
a3797 1
cmd_bigqtbuffer (char *own_buf)
d3802 1
a3802 1
  packet += strlen ("QTBuffer:");
d3804 5
a3808 11
  if (strncmp ("circular:", packet, strlen ("circular:")) == 0)
    {
      packet += strlen ("circular:");
      unpack_varlen_hex (packet, &val);
      circular_trace_buffer = val;
      trace_debug ("Trace buffer is now %s",
		   circular_trace_buffer ? "circular" : "linear");
      write_ok (own_buf);
    }
  else
    write_enn (own_buf);
d3927 1
a3927 1
  else if (strncmp ("QTBuffer:", packet, strlen ("QTBuffer:")) == 0)
d3929 1
a3929 1
      cmd_bigqtbuffer (packet);
@


1.44
log
@2012-01-17  Pedro Alves  <palves@@redhat.com>

	* tracepoint.c (initialize_tracepoint): Use mmap instead of
	memalign plus mprotect to allocate the scratch buffer.
@
text
@d3732 7
@


1.43
log
@	* tracepoint.c [IN_PROCESS_AGENT] (debug_threads): Macro
	defined.
	[IN_PROCESS_AGENT] (debug_agent): New global variable.
@
text
@d8254 1
d8256 1
d8263 15
a8277 7
    /* Allocate scratch buffer aligned on a page boundary.  */
    gdb_jump_pad_buffer = memalign (pagesize, pagesize * 20);
    gdb_jump_pad_buffer_end = gdb_jump_pad_buffer + pagesize * 20;

    /* Make it writable and executable.  */
    if (mprotect (gdb_jump_pad_buffer, pagesize * 20,
		  PROT_READ | PROT_WRITE | PROT_EXEC) != 0)
d8279 4
a8282 2
initialize_tracepoint: mprotect(%p, %d, PROT_READ|PROT_EXEC) failed with %s",
	     gdb_jump_pad_buffer, pagesize * 20, strerror (errno));
@


1.42
log
@gdb/gdbserver/
	* tracepoint.c (cmd_qtdp): Print debug message
	for static tracepoint.
@
text
@d74 4
d80 1
a80 1
    if (level <= debug_threads)			\
d377 1
a377 1
int debug_threads = 0;
@


1.41
log
@gdb/gdbserver/
	* tracepoint.c (trace_vdebug): Differentiate debug message
	between gdbserver and IPA.
@
text
@d2430 1
a2430 1
		   : "",
@


1.40
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d66 3
d70 1
@


1.39
log
@gdb/gdbserver/
	* tracepoint.c (tracepoint_was_hit): Don't collect for
	static tracepoint.
@
text
@d2 1
a2 1
   Copyright (C) 2009, 2010, 2011 Free Software Foundation, Inc.
@


1.38
log
@gdb/gdbserver/
	* tracepoint.c: Include sys/syscall.h.
	(gdb_ust_thread): Remove preprocessor conditional.
@
text
@d4271 6
a4276 2
	 double collect.  */
      if (tpoint->enabled && stop_pc == tpoint->address)
@


1.37
log
@gdb/gdbserver/

	* tracepoint.c (gdb_ust_thread): Don't ignore return value
	of write.
@
text
@d8032 2
a8042 1
#ifdef SYS_gettid
a8044 1
#endif
@


1.36
log
@2011-12-13  Yao Qi  <yao@@codesourcery.com>

	* tracepoint.c (trace_buffer_alloc): Replace magic numbers with
	macros.
	(upload_fast_traceframes, upload_fast_traceframes): Likewise.
@
text
@d8125 2
a8126 1
	  write (fd, buf, 1);
@


1.36.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 1
a2 1
   Copyright (C) 2009-2012 Free Software Foundation, Inc.
@


1.35
log
@2011-11-24  Stan Shebs  <stan@@codesourcery.com>

	* tracepoint.c (cmd_qtstatus): Use plongest instead of %llx.
@
text
@d1591 3
a1593 2
  commit_count = (((prev & 0x0007ff00) + 0x100) & 0x0007ff00);
  commit = (((prev & 0x0007ff00) << 12)
d1625 2
a1626 2
    if ((refetch == commit
	 || ((refetch & 0x7ff00000) >> 12) == commit_count))
d7084 2
a7085 2
    prev = ipa_trace_buffer_ctrl_curr & 0x0007ff00;
    counter = (prev + 0x100) & 0x0007ff00;
d7087 1
a7087 1
    ipa_trace_buffer_ctrl_curr = (0x80000000
@


1.34
log
@	* NEWS: Mention tracepoint additions.
	* breakpoint.h (struct tracepoint): New field traceframe_usage.
	* breakpoint.c (print_one_breakpoint_location): Identify
	tracepoints as such when reporting hit counts, report
	trace buffer usage.
	(create_tracepoint_from_upload): Copy status info.
	* tracepoint.h (struct trace_status): Rename error_desc to stop_desc,
	add fields user_name, notes, start_time, stop_time.
	(struct uploaded_tp): Add fields hit_count, traceframe_usage.
	* tracepoint.c (trace_user): New global.
	(trace_notes): New global.
	(trace_stop_notes): New global.
	(start_tracing): Add argument and trace note handling.
	(stop_tracing): Ditto.
	(trace_start_command): Add notes argument.
	(trace_stop_command): Ditto.
	(trace_status_command): Report additional status info.
	(trace_status_mi): Similarly.
	(trace_save): Update, record tracepoint status.
	(set_disconnected_tracing): Call target method directly.
	(send_disconnected_tracing_value): Remove.
	(set_trace_user): New function.
	(set_trace_notes): New function.
	(set_trace_stop_notes): New function.
	(parse_trace_status): Handle additional status.
	(parse_tracepoint_status): New function.
	(parse_tracepoint_definition): Call it.
	(tfile_get_tracepoint_status): New function.
	(init_tfile_ops): Use it.
	(_initialize_tracepoint): Add new setshows.
	* target.h (struct target_ops): New methods to_get_tracepoint_status
	and to_set_trace_notes.
	(target_get_tracepoint_status): New macro.
	(target_set_trace_notes): New macro.
	* target.c (update_current_target): Add new methods.
	* remote.c (remote_get_tracepoint_status): New function.
	(remote_set_trace_notes): New function.
	(init_remote_ops): Add them.
	* mi/mi-main.c (mi_cmd_trace_start): Add argument to call.
	(mi_cmd_trace_stop): Ditto.

	* tracepoint.c (struct tracepoint): New field traceframe_usage.
	(tracing_start_time): New global.
	(tracing_stop_time): New global.
	(tracing_user_name): New global.
	(tracing_notes): New global.
	(tracing_stop_note): New global.
	(cmd_qtstart): Set traceframe_usage, start_time.
	(stop_tracing): Set stop_time.
	(cmd_qtstatus): Report additional status.
	(cmd_qtp): New function.
	(handle_tracepoint_query): Call it.
	(cmd_qtnotes): New function.
	(handle_tracepoint_general_set): Call it.
	(get_timestamp): Rename from tsv_get_timestamp.

	* gdb.texinfo (Starting and Stopping Trace Experiments): Document
	note-related options and variables.
	(Tracepoint Packets): Document packet changes.

	* gdb.trace/tstatus.exp: New.
	* gdb.trace/actions.c: Include string.h.
@
text
@d3451 1
a3451 1
	   "starttime:%llx;stoptime:%llx;"
d3459 1
a3459 1
	   tracing_start_time, tracing_stop_time,
@


1.33
log
@2011-11-14  Stan Shebs  <stan@@codesourcery.com>
	    Kwok Cheung Yeung  <kcy@@codesourcery.com>

	* NEWS: Document shorter fast tracepoints and qTMinFTPILen packet.
	* i386-tdep.c (i386_fast_tracepoint_valid_at): Query target for
	the minimum instruction size for fast tracepoints.
	* target.h (struct target_ops): Add new method
	to_get_min_fast_tracepoint_insn_len.
	(target_get_min_fast_tracepoint_insn_len): New.
	* target.c (update_current_target): Set up new target operation.
	* remote.c (remote_write_bytes_aux): Fix typo.
	(remote_get_min_fast_tracepoint_insn_len): New.
	(init_remote_ops): Initialize new field.

	* gdb.texinfo (Create and Delete Tracepoints): Describe what is
	needed to get shorter fast tracepoints.
	(Tracepoint Packets): Document new qTMinFTPILen packet.

	* linux-x86-low.c (small_jump_insn): New.
	(i386_install_fast_tracepoint_jump_pad): Add arguments for
	trampoline and error message, build a trampoline and issue a small
	jump instruction to it.
	(x86_install_fast_tracepoint_jump_pad): Add arguments for
	trampoline and error message.
	(x86_get_min_fast_tracepoint_insn_len): New.
	(the_low_target): Add call to x86_get_min_fast_tracepoint_insn_len.
	* linux-low.h (struct linux_target_ops): Add arguments to
	install_fast_tracepoint_jump_pad operation, add new operation.
	* linux-low.c (linux_install_fast_tracepoint_jump_pad): Add
	arguments.
	(linux_get_min_fast_tracepoint_insn_len): New function.
	(linux_target_op): Add new operation.
	* tracepoint.c (gdb_trampoline_buffer): New IPA variable.
	(gdb_trampoline_buffer_end): Ditto.
	(gdb_trampoline_buffer_error): Ditto.
	(struct ipa_sym_addresses): Add fields for new IPA variables.
	(symbol_list): Add entries for new IPA variables.
	(struct tracepoint): Add fields to hold the address range of the
	trampoline used by the tracepoint.
	(trampoline_buffer_head): New static variable.
	(trampoline_buffer_tail): Ditto.
	(claim_trampoline_space): New function.
	(have_fast_tracepoint_trampoline_buffer): New function.
	(clone_fast_tracepoint): Fill in trampoline fields of tracepoint
	structure.
	(install_fast_tracepoint): Ditto, also add error buffer argument.
	(cmd_qtminftpilen): New function.
	(handle_tracepoint_query): Add response to qTMinFTPILen packet.
	(fast_tracepoint_from_trampoline_address): New function.
	(fast_tracepoint_collecting): Handle trampoline as part of jump
	pad space.
	(set_trampoline_buffer_space): New function.
	(initialize_tracepoint): Initialize new IPA variables.
	* target.h (struct target_ops): Add arguments to
	install_fast_tracepoint_jump_pad operation, add new
	get_min_fast_tracepoint_insn_len operation.
	(target_get_min_fast_tracepoint_insn_len): New.
	(install_fast_tracepoint_jump_pad): Add arguments.
	* server.h (IPA_BUFSIZ): Define.
	* linux-i386-ipa.c: Include extra header files.
	(initialize_fast_tracepoint_trampoline_buffer): New function.
	(initialize_low_tracepoint): Call it.
	* server.h (set_trampoline_buffer_space): Declare.
	(claim_trampoline_space): Ditto.
	(have_fast_tracepoint_trampoline_buffer): Ditto.

	* gdb.trace/ftrace.c: New.
	* gdb.trace/ftrace.exp: New.
@
text
@d635 3
d1150 21
d1293 2
d3056 1
d3133 1
d3203 1
d3384 20
d3420 1
a3420 1
     We leave it as plain string in `tracepoint_stop_reason' to ease
d3436 8
d3450 3
a3452 1
	   "disconn:%d",
d3458 30
a3487 1
	   disconnected_tracing);
d3801 57
d3922 5
d3939 5
d8207 4
d8212 1
a8212 1
tsv_get_timestamp (void)
d8236 1
a8236 1
  set_trace_state_variable_getter (1, tsv_get_timestamp);
@


1.32
log
@gdb/
	* remote.c (struct remote_state): <install_in_trace> new field.
	(PACKET_InstallInTrace): New enum value.
	(remote_install_in_trace_feature): Support InstallInTrace.
	(remote_supports_install_in_trace): Likewise.
	(remote_protocol_features): Likewise.
	(_initialize_remote): Likewise.
	(remote_can_download_tracepoint): New.
	* target.h (struct target): New field
	`to_can_download_tracepoint'.
	(target_can_download_tracepoint): New macro.
	* target.c (update_current_target): Update.
	* breakpoint.h (struct bp_location): Add comment on field
	`duplicate'.
	(should_be_inserted): Don't differentiate breakpoint and tracepoint.
	(remove_breakpoints): Don't remove tracepoints.
	(tracepoint_locations_match ): New.
	(breakpoint_locations_match): Call it.
	(disable_breakpoints_in_unloaded_shlib): Handle tracepoint.
	(download_tracepoint_locations): New.
	(update_global_location_list): Call it.
	* tracepoint.c (find_matching_tracepoint): Delete.
	(find_matching_tracepoint_location): Renamed from
	find_matching_tracepoint.  Return bp_location rather than
	tracepoint.
	(merge_uploaded_tracepoints): Set `inserted' field to 1 if
	tracepoint is found.

gdb/doc/
	* gdb.texinfo (Create and Delete Tracepoints): Describe changed
	behavior of tracepoint.
	(General Query Packets): New feature InstallInTrace.
	(Remote Configuration): Document "set remote
	install-in-trace-packet".

gdb/gdbserver/
	* server.c (handle_query): Handle InstallInTrace for qSupported.
	* tracepoint.c (add_tracepoint): Sort list.
	(install_tracepoint, download_tracepoint): New.
	(cmd_qtdp): Call them to install and download tracepoints.
	(sort_tracepoints): Removed.
	(cmd_qtstart): Update.

gdb/testsuite/
	* gdb.trace/change-loc-1.c: New.
	* gdb.trace/change-loc-2.c: New.
	* gdb.trace/change-loc.c: New.
	* gdb.trace/change-loc.exp:  New.
	* gdb.trace/change-loc.h:  New.
	* gdb.trace/trace-break.c (marker): Define new symbol.
	* gdb.trace/trace-break.exp (break_trace_same_addr_5):
        New.
	(break_trace_same_addr_6): New.
@
text
@d113 3
d154 3
d201 3
d670 6
d1266 1
a1266 1
static int install_fast_tracepoint (struct tracepoint *);
d2729 79
d2840 2
d2856 1
a2856 1
install_fast_tracepoint (struct tracepoint *tpoint)
d2859 2
d2867 7
d2876 3
d2885 3
a2887 1
					  &jentry, fjump, &fjump_size,
d2889 2
a2890 1
					  &tpoint->adjusted_insn_addr_end);
d2903 2
d2965 1
a2965 1
	    install_fast_tracepoint (tpoint);
d3053 1
a3053 1
	      if (install_fast_tracepoint (tpoint) == 0)
a3054 1

d3629 9
d3834 5
d5455 17
d5534 2
d5574 7
d5609 24
d8021 18
d8100 10
@


1.31
log
@	* mem-break.c (inc_ref_fast_tracepoint_jump): New.
	* mem-break.h: Declare.
	* tracepoint.c (cmd_qtstart): Move some code to ...
	(clone_fast_tracepoint, install_fast_tracepoint): ... here.
	New.
	(download_tracepoints): Move some code to ...
	(download_tracepoint_1): ... here.  New.
@
text
@d1248 3
d1647 2
a1648 1
/* Create a tracepoint (location) with given number and address.  */
d1653 1
a1653 1
  struct tracepoint *tpoint;
d1673 25
a1697 4
  if (!last_tracepoint)
    tracepoints = tpoint;
  else
    last_tracepoint->next = tpoint;
d2297 2
d2376 4
a2379 1
	trace_debug ("Also has actions\n");
d2398 23
a2713 53
/* Sort tracepoints by PC, using a bubble sort.  */

static void
sort_tracepoints (void)
{
  struct tracepoint *lst, *tmp, *prev = NULL;
  int i, j, n = 0;

  if (tracepoints == NULL)
    return;

  /* Count nodes.  */
  for (tmp = tracepoints; tmp->next; tmp = tmp->next)
    n++;

  for (i = 0; i < n - 1; i++)
    for (j = 0, lst = tracepoints;
	 lst && lst->next && (j <= n - 1 - i);
	 j++)
      {
	/* If we're at beginning, the start node is the prev
	   node.  */
	if (j == 0)
	  prev = lst;

	/* Compare neighbors.  */
	if (lst->next->address < lst->address)
	  {
	    struct tracepoint *p;

	    /* Swap'em.  */
	    tmp = (lst->next ? lst->next->next : NULL);

	    if (j == 0 && prev == tracepoints)
	      tracepoints = lst->next;

	    p = lst->next;
	    prev->next = lst->next;
	    lst->next->next = lst;
	    lst->next = tmp;
	    prev = p;
	  }
	else
	  {
	    lst = lst->next;
	    /* Keep track of the previous node.  We need it if we need
	       to swap nodes.  */
	    if (j != 0)
	      prev = prev->next;
	  }
      }
}

d2801 77
a2884 4
  /* Sort tracepoints by ascending address.  This makes installing
     fast tracepoints at the same address easier to handle. */
  sort_tracepoints ();

d6538 47
@


1.30
log
@gdb/gdbserver:

2011-11-05  Yao Qi  <yao@@codesourcery.com>

	* tracepoint.c (gdb_collect): Loop over tracepoints of same
	address as TPOINT's.

gdb/testsuite:

2011-11-05  Yao Qi  <yao@@codesourcery.com>

	* gdb.trace/trace-break.exp: Add test on setting two
	fast tracepoints at the same address.
@
text
@d1248 1
d2741 13
d2756 5
a2760 2
static void
cmd_qtstart (char *packet)
d2762 2
a2763 3
  struct tracepoint *tpoint, *prev_ftpoint, *prev_stpoint;
  CORE_ADDR jump_entry;

d2769 37
d2864 1
a2864 10
	    {
	      tpoint->handle = set_fast_tracepoint_jump (tpoint->address,
							 fjump,
							 fjump_size);
	      tpoint->jump_pad = prev_ftpoint->jump_pad;
	      tpoint->jump_pad_end = prev_ftpoint->jump_pad_end;
	      tpoint->adjusted_insn_addr = prev_ftpoint->adjusted_insn_addr;
	      tpoint->adjusted_insn_addr_end
		= prev_ftpoint->adjusted_insn_addr_end;
	    }
d2867 2
a2868 32
	      CORE_ADDR jentry;
	      int err = 0;

	      prev_ftpoint = NULL;

	      jentry = jump_entry = get_jump_space_head ();

	      /* Install the jump pad.  */
	      err = install_fast_tracepoint_jump_pad
		(tpoint->obj_addr_on_target,
		 tpoint->address,
		 ipa_sym_addrs.addr_gdb_collect,
		 ipa_sym_addrs.addr_collecting,
		 tpoint->orig_size,
		 &jentry,
		 fjump, &fjump_size,
		 &tpoint->adjusted_insn_addr,
		 &tpoint->adjusted_insn_addr_end);

	      /* Wire it in.  */
	      if (!err)
		tpoint->handle = set_fast_tracepoint_jump (tpoint->address,
							   fjump, fjump_size);

	      if (tpoint->handle != NULL)
		{
		  tpoint->jump_pad = jump_entry;
		  tpoint->jump_pad_end = jentry;

		  /* Pad to 8-byte alignment.  */
		  jentry = ((jentry + 7) & ~0x7);
		  claim_jump_space (jentry - jump_entry);
a2869 4
		  /* So that we can handle multiple fast tracepoints
		     at the same address easily.  */
		  prev_ftpoint = tpoint;
		}
d6338 2
d6341 1
a6341 1
download_tracepoints (void)
d6343 2
a6344 2
  CORE_ADDR tpptr = 0, prev_tpptr = 0;
  struct tracepoint *tpoint;
d6346 2
a6347 2
  /* Start out empty.  */
  write_inferior_data_ptr (ipa_sym_addrs.addr_tracepoints, 0);
d6349 1
a6349 1
  for (tpoint = tracepoints; tpoint; tpoint = tpoint->next)
d6351 1
a6351 1
      struct tracepoint target_tracepoint;
d6353 1
a6353 3
      if (tpoint->type != fast_tracepoint
	  && tpoint->type != static_tracepoint)
	continue;
d6355 1
a6355 2
      /* Maybe download a compiled condition.  */
      if (tpoint->cond != NULL && target_emit_ops () != NULL)
d6357 25
a6381 1
	  CORE_ADDR jentry, jump_entry;
d6383 2
a6384 1
	  jentry = jump_entry = get_jump_space_head ();
d6386 24
a6409 1
	  if (tpoint->cond != NULL)
d6411 24
a6434 4
	      /* Pad to 8-byte alignment. (needed?)  */
	      /* Actually this should be left for the target to
		 decide.  */
	      jentry = UALIGN (jentry, 8);
d6436 18
a6453 1
	      compile_tracepoint_condition (tpoint, &jentry);
d6456 4
a6459 3
	  /* Pad to 8-byte alignment.  */
	  jentry = UALIGN (jentry, 8);
	  claim_jump_space (jentry - jump_entry);
d6461 2
d6464 14
a6477 1
      target_tracepoint = *tpoint;
d6480 4
a6483 2
      tpptr = target_malloc (sizeof (*tpoint));
      tpoint->obj_addr_on_target = tpptr;
a6496 88

      /* Write the whole object.  We'll fix up its pointers in a bit.
	 Assume no next for now.  This is fixed up above on the next
	 iteration, if there's any.  */
      target_tracepoint.next = NULL;
      /* Need to clear this here too, since we're downloading the
	 tracepoints before clearing our own copy.  */
      target_tracepoint.hit_count = 0;

      write_inferior_memory (tpptr, (unsigned char *) &target_tracepoint,
			     sizeof (target_tracepoint));

      if (tpoint->cond)
	write_inferior_data_ptr (tpptr + offsetof (struct tracepoint,
						   cond),
				 download_agent_expr (tpoint->cond));

      if (tpoint->numactions)
	{
	  int i;
	  CORE_ADDR actions_array;

	  /* The pointers array.  */
	  actions_array
	    = target_malloc (sizeof (*tpoint->actions) * tpoint->numactions);
	  write_inferior_data_ptr (tpptr + offsetof (struct tracepoint,
						     actions),
				   actions_array);

	  /* Now for each pointer, download the action.  */
	  for (i = 0; i < tpoint->numactions; i++)
	    {
	      CORE_ADDR ipa_action = 0;
	      struct tracepoint_action *action = tpoint->actions[i];

	      switch (action->type)
		{
		case 'M':
		  ipa_action
		    = target_malloc (sizeof (struct collect_memory_action));
		  write_inferior_memory (ipa_action,
					 (unsigned char *) action,
					 sizeof (struct collect_memory_action));
		  break;
		case 'R':
		  ipa_action
		    = target_malloc (sizeof (struct collect_registers_action));
		  write_inferior_memory (ipa_action,
					 (unsigned char *) action,
					 sizeof (struct collect_registers_action));
		  break;
		case 'X':
		  {
		    CORE_ADDR expr;
		    struct eval_expr_action *eaction
		      = (struct eval_expr_action *) action;

		    ipa_action = target_malloc (sizeof (*eaction));
		    write_inferior_memory (ipa_action,
					   (unsigned char *) eaction,
					   sizeof (*eaction));

		    expr = download_agent_expr (eaction->expr);
		    write_inferior_data_ptr
		      (ipa_action + offsetof (struct eval_expr_action, expr),
		       expr);
		    break;
		  }
		case 'L':
		  ipa_action = target_malloc
		    (sizeof (struct collect_static_trace_data_action));
		  write_inferior_memory
		    (ipa_action,
		     (unsigned char *) action,
		     sizeof (struct collect_static_trace_data_action));
		  break;
		default:
		  trace_debug ("unknown trace action '%c', ignoring",
			       action->type);
		  break;
		}

	      if (ipa_action != 0)
		write_inferior_data_ptr
		  (actions_array + i * sizeof (sizeof (*tpoint->actions)),
		   ipa_action);
	    }
	}
@


1.29
log
@2011-11-02  Stan Shebs  <stan@@codesourcery.com>

	String collection for tracepoints.
	* NEWS: Mention string collection.
	* common/ax.def (tracenz): New bytecode.
	* ax-gdb.h (trace_string_kludge): Declare.
	* ax-gdb.c: Include valprint.h and c-lang.h.
	(trace_string_kludge): New global.
	(gen_traced_pop): Add string case.
	(agent_command): Add string case.
	* tracepoint.h (decode_agent_options): Declare.
	* tracepoint.c: Include cli-utils.h.
	(decode_agent_options): New function.
	(validate_actionline): Call it.
	(encode_actions_1): Ditto.
	* target.h (struct target_ops): New method to_supports_string_tracing.
	(target_supports_string_tracing): New macro.
	* target.c (update_current_target): Add to_supports_string_tracing.
	* remote.c (struct remote_state): New field string_tracing.
	(remote_string_tracing_feature): New function.
	(remote_protocol_features): New feature tracenz.
	(remote_supports_string_tracing): New function.
	(init_remote_ops): Set to_supports_string_tracing.

	* tracepoint.c (agent_mem_read_string): New function.
	(eval_agent_expr): Call it for tracenz.
	* server.c (handle_query): Report support for tracenz.

	* gdb.texinfo (Tracepoint Action Lists): Document collect/s.
	(General Query Packets): Describe tracenz feature.
	* agentexpr.texi (Bytecode Descriptions): Describe tracenz.

	* gdb.trace/collection.c: Add code using strings.
	* gdb.trace/collection.exp: Add tests of string collection.
@
text
@a5482 3
  if (!tpoint->enabled)
    return;

a5485 2
  ctx.tpoint = tpoint;

d5495 3
a5497 4
  /* Test the condition if present, and collect if true.  */
  if (tpoint->cond == NULL
      || condition_true_at_tracepoint ((struct tracepoint_hit_ctx *) &ctx,
				       tpoint))
d5499 7
a5505 2
      collect_data_at_tracepoint ((struct tracepoint_hit_ctx *) &ctx,
				  tpoint->address, tpoint);
d5507 31
a5537 16
      /* Note that this will cause original insns to be written back
	 to where we jumped from, but that's OK because we're jumping
	 back to the next whole instruction.  This will go badly if
	 instruction restoration is not atomic though.  */
      if (stopping_tracepoint
	  || trace_buffer_is_full
	  || expr_eval_result != expr_eval_no_error)
	stop_tracing ();
    }
  else
    {
      /* If there was a condition and it evaluated to false, the only
	 way we would stop tracing is if there was an error during
	 condition expression evaluation.  */
      if (expr_eval_result != expr_eval_no_error)
	stop_tracing ();
@


1.28
log
@gdb/gdbserver/

	* tracepoint.c (cmd_qtstart): Remove unused local variables.
@
text
@d1212 3
d4650 7
d4740 60
@


1.27
log
@	* server.h (struct emit_ops): Add compare-goto fields.
	* tracepoint.c (gdb_agent_op_sizes): New table.
	(emit_eq_goto): New function.
	(emit_ne_goto): New function.
	(emit_lt_goto): New function.
	(emit_le_goto): New function.
	(emit_gt_goto): New function.
	(emit_ge_goto): New function.
	(is_goto_target): New function.
	(compile_bytecodes): Recognize special cases of compare-goto
	combinations and call specialized emitters for them.
	* linux-x86-low.c (amd64_emit_eq_goto): New function.
	(amd64_emit_ne_goto): New function.
	(amd64_emit_lt_goto): New function.
	(amd64_emit_le_goto): New function.
	(amd64_emit_gt_goto): New function.
	(amd64_emit_ge_goto): New function.
	(amd64_emit_ops): Add the new functions.
	(i386_emit_eq_goto): New function.
	(i386_emit_ne_goto): New function.
	(i386_emit_lt_goto): New function.
	(i386_emit_le_goto): New function.
	(i386_emit_gt_goto): New function.
	(i386_emit_ge_goto): New function.
	(i386_emit_ops): Add the new functions.
@
text
@a2742 1
  int slow_tracepoint_count, fast_count;
a2751 2
  slow_tracepoint_count = fast_count = 0;

a2790 2
	  ++slow_tracepoint_count;

a2799 2
	  ++fast_count;

@


1.26
log
@2011-07-20  Pedro Alves  <pedro@@codesourcery.com>

	* tracepoint.c (tracepoint_look_up_symbols): Return upon the first
	symbol error.
@
text
@d486 8
d5674 36
d5759 24
d5790 1
a5790 1
  unsigned char op;
d5902 28
a5929 1
	  emit_equal ();
d5933 27
a5959 1
	  emit_less_signed ();
d6070 32
a6101 1
	  emit_swap ();
@


1.25
log
@Add support for enabling and disabling tracepoints while a trace
experiment is still running.

gdb/
	* breakpoint.c (disable_breakpoint): Disable all locations
	associated with a tracepoint on target if a trace experiment is
	running.
	(disable_command): Disable a specific tracepoint location on target if
	a trace	experiment is running.
	(do_enable_breakpoint): Enable all locations associated with a
	tracepoint on target if a trace experiment is running.
	(enable_command) Enable a specific tracepoint location on target if a
	trace experiment is running.
	* target.c (update_current_target): Add INHERIT and de_fault clauses for
	to_supports_enable_disable_tracepoint, to_enable_tracepoint and
	to_disable_tracepoint.
	* target.h: Add declaration of struct bp_location.
	(struct target_ops): Add new functions
	to_supports_enable_disable_tracepoint, to_enable_tracepoint and
	to_disable_tracepoint to target operations.
	(target_supports_enable_disable_tracepoint): New macro.
	(target_enable_tracepoint): New macro.
	(target_disable_tracepoint): New macro.
	* remote.c (struct remote_state): Add new field.
	(remote_enable_disable_tracepoint_feature): New.
	(remote_protocol_features): Add new entry.
	(remote_supports_enable_disable_tracepoint): New.
	(remote_enable_tracepoint): New.
	(remote_disable_tracepoint): New.
	(init_remote_ops): Add remote_enable_tracepoint,
	remote_disable_tracepoint and remote_supports_enable_disable_tracepoint
	to remote operations.
	* tracepoint.c (start_tracing): Allow tracing to start without any
	tracepoints enabled with just a warning if they can be re-enabled
	later.
	* NEWS: Add news item for the new behaviour of the enable and disable
	GDB commands when applied to tracepoints.
	Add news items for the new remote packets QTEnable and QTDisable.

gdb/doc/
	* gdb.texinfo: Document change in the behaviour of the enable and
	disable GDB commands when applied to tracepoints.
	Document the EnableDisableTracepoints remote stub feature.
	Document QTEnable and QTDisable in the list of tracepoint packets.

gdb/gdbserver/
	* server.c (handle_query): Add EnableDisableTracepoints to the list
	of supported features.
	* tracepoint.c (clear_installed_tracepoints): Uninstall	disabled
	tracepoints.
	(cmd_qtenable_disable): New.
	(cmd_qtstart): Install tracepoints even if disabled.
	(handle_tracepoint_general_set): Add call to cmd_qtenable_disable on
	receiving a QTEnable or QTDisable packet.
	(gdb_collect): Skip data collection if fast tracepoint is disabled.
	(ust_marker_to_static_tracepoint): Do not ignore disabled static
	tracepoints.
	(gdb_probe): Skip data collection if static tracepoint is disabled.
@
text
@a322 1
  int all_ok;
a327 1
  all_ok = 1;
d337 1
a337 1
	  all_ok = 0;
d341 1
a341 1
  all_tracepoint_symbols_looked_up = all_ok;
@


1.24
log
@2011-02-28  Michael Snyder  <msnyder@@vmware.com>

	* tracepoint.c (cmd_qtv): Discard unused value 'packet'.
	(cmd_qtframe): Ditto.
	(cmd_qtbuffer): Ditto.
	(cmd_bigqtbuffer): Ditto.
@
text
@a2216 3
      if (!tpoint->enabled)
	continue;

d2455 67
a2785 3
      if (!tpoint->enabled)
	continue;

d3525 10
d5414 3
d6675 1
a6675 1
      if (!tpoint->enabled || tpoint->type != static_tracepoint)
d6730 6
@


1.23
log
@2011-02-27  Michael Snyder  <msnyder@@vmware.com>

	* gdbserver/tracepoint.c (tracepoint_finish_step): Fix
	loop variable.
@
text
@d2466 1
a2466 1
  packet = unpack_varlen_hex (packet, &num);
d3036 1
a3036 1
      packet = unpack_varlen_hex (packet, &pc);
d3045 1
a3045 1
      packet = unpack_varlen_hex (packet, &hi);
d3055 1
a3055 1
      packet = unpack_varlen_hex (packet, &hi);
d3064 1
a3064 1
      packet = unpack_varlen_hex (packet, &num);
d3386 1
a3386 1
  packet = unpack_varlen_hex (packet, &num);
d3436 1
a3436 1
      packet = unpack_varlen_hex (packet, &val);
@


1.22
log
@2011-03-09  Michael Snyder  <msnyder@@vmware.com>

	* gdbserver/tracepoint.c: Fix small comment typo.
@
text
@d3679 1
@


1.21
log
@Revert the following patch (printf tracepoint op) (not approved yet)

        2011-02-21  Hui Zhu  <teawater@@gmail.com>
        * tracepoint.c (tp_printf): New function.
        (eval_agent_expr): Handle gdb_agent_op_printf.
@
text
@d29 1
a29 1
/* This file is built for both both GDBserver, and the in-process
@


1.20
log
@2011-02-21  Hui Zhu  <teawater@@gmail.com>

	* tracepoint.c (tp_printf): New function.
	(eval_agent_expr): Handle gdb_agent_op_printf.
@
text
@a4216 10
int
tp_printf (const char *format, ...)
{
  va_list ap;
  va_start (ap, format);
  vprintf (format, ap);
  va_end (ap);
  return 0;
}

a4575 34
	case gdb_agent_op_printf:
	  {
	    void *argv;
	    arg = aexpr->bytes[pc++];
	    argv = (void *) (unsigned long) top;
	    if (--sp >= 0)
	      top = stack[sp];

	    if (arg)
	      {
		if (strstr ((char *) (aexpr->bytes + pc), "%s"))
		  {
		    int			i;
		    unsigned char	buf[100];

		    for (i = 0; i < 100; i++)
		      {
			agent_mem_read (tframe, buf + i,
					(CORE_ADDR) ((unsigned long)argv + i),
					1);
			if (!buf[i])
			  break;
		      }
		    tp_printf ((char *) (aexpr->bytes + pc), buf);
		  }
		else
	          tp_printf ((char *) (aexpr->bytes + pc), argv);
	      }
	    else
	      tp_printf ((char *) (aexpr->bytes + pc));
	    pc += strlen ((char *) aexpr->bytes + pc) + 1;
	  }
	  break;

@


1.19
log
@gdb
	* common/ax.def: New file.
	* ax.h (enum agent_op): Use ax.def.
	* ax-general.c (aop_map): Use ax.def.
gdbserver
	* Makefile.in (tracepoint-ipa.o): Depend on ax.def.
	(tracepoint.o): Likewise.
	* tracepoint.c (enum gdb_agent_op): Use ax.def.
	(gdb_agent_op_names): Likewise.
@
text
@d4217 10
d4586 34
@


1.18
log
@gdb
	* ax-general.c (aop_map): Add pick and rot.
	* dwarf2loc.c (compile_dwarf_to_ax) <DW_OP_over>: Reimplement.
	<DW_OP_rot>: Implement.
	* ax.h (enum agent_op) <aop_pick, aop_rot>: New constants.
	(ax_pick): Declare.
	* ax-general.c (ax_pick): New function.
doc
	* agentexpr.texi (Bytecode Descriptions): Document pick and rot.
gdbserver
	* tracepoint.c (enum gdb_agent_op) <gdb_agent_op_pick,
	gdb_agent_op_rot>: New constants.
	(gdb_agent_op_names): Add pick and roll.
	(eval_agent_expr) <gdb_agent_op_pick, gdb_agent_op_rot>: New
	cases.
@
text
@d473 4
a476 49
    gdb_agent_op_float = 0x01,
    gdb_agent_op_add = 0x02,
    gdb_agent_op_sub = 0x03,
    gdb_agent_op_mul = 0x04,
    gdb_agent_op_div_signed = 0x05,
    gdb_agent_op_div_unsigned = 0x06,
    gdb_agent_op_rem_signed = 0x07,
    gdb_agent_op_rem_unsigned = 0x08,
    gdb_agent_op_lsh = 0x09,
    gdb_agent_op_rsh_signed = 0x0a,
    gdb_agent_op_rsh_unsigned = 0x0b,
    gdb_agent_op_trace = 0x0c,
    gdb_agent_op_trace_quick = 0x0d,
    gdb_agent_op_log_not = 0x0e,
    gdb_agent_op_bit_and = 0x0f,
    gdb_agent_op_bit_or = 0x10,
    gdb_agent_op_bit_xor = 0x11,
    gdb_agent_op_bit_not = 0x12,
    gdb_agent_op_equal = 0x13,
    gdb_agent_op_less_signed = 0x14,
    gdb_agent_op_less_unsigned = 0x15,
    gdb_agent_op_ext = 0x16,
    gdb_agent_op_ref8 = 0x17,
    gdb_agent_op_ref16 = 0x18,
    gdb_agent_op_ref32 = 0x19,
    gdb_agent_op_ref64 = 0x1a,
    gdb_agent_op_ref_float = 0x1b,
    gdb_agent_op_ref_double = 0x1c,
    gdb_agent_op_ref_long_double = 0x1d,
    gdb_agent_op_l_to_d = 0x1e,
    gdb_agent_op_d_to_l = 0x1f,
    gdb_agent_op_if_goto = 0x20,
    gdb_agent_op_goto = 0x21,
    gdb_agent_op_const8 = 0x22,
    gdb_agent_op_const16 = 0x23,
    gdb_agent_op_const32 = 0x24,
    gdb_agent_op_const64 = 0x25,
    gdb_agent_op_reg = 0x26,
    gdb_agent_op_end = 0x27,
    gdb_agent_op_dup = 0x28,
    gdb_agent_op_pop = 0x29,
    gdb_agent_op_zero_ext = 0x2a,
    gdb_agent_op_swap = 0x2b,
    gdb_agent_op_getv = 0x2c,
    gdb_agent_op_setv = 0x2d,
    gdb_agent_op_tracev = 0x2e,
    gdb_agent_op_trace16 = 0x30,
    gdb_agent_op_pick = 0x32,
    gdb_agent_op_rot = 0x33,
d482 4
a485 52
    "?undef?",
    "float",
    "add",
    "sub",
    "mul",
    "div_signed",
    "div_unsigned",
    "rem_signed",
    "rem_unsigned",
    "lsh",
    "rsh_signed",
    "rsh_unsigned",
    "trace",
    "trace_quick",
    "log_not",
    "bit_and",
    "bit_or",
    "bit_xor",
    "bit_not",
    "equal",
    "less_signed",
    "less_unsigned",
    "ext",
    "ref8",
    "ref16",
    "ref32",
    "ref64",
    "ref_float",
    "ref_double",
    "ref_long_double",
    "l_to_d",
    "d_to_l",
    "if_goto",
    "goto",
    "const8",
    "const16",
    "const32",
    "const64",
    "reg",
    "end",
    "dup",
    "pop",
    "zero_ext",
    "swap",
    "getv",
    "setv",
    "tracev",
    "?undef?",
    "trace16",
    "?undef?",
    "pick",
    "rot"
d4207 10
d4610 1
a4610 1
		   gdb_agent_op_names[op], sp, pulongest (top));
d5920 1
a5920 1
		       emit_error, gdb_agent_op_names[op]);
d5924 1
a5924 1
      trace_debug ("Op %s compiled\n", gdb_agent_op_names[op]);
@


1.17
log
@	gdb/
	* target.h (struct traceframe_info): Forward declare.
	(enum target_object): Add TARGET_OBJECT_TRACEFRAME_INFO.
	(struct target_ops) <to_traceframe_info>: New field.
	(target_traceframe_info): New.
	* target.c (update_current_target): Inherit and default
	to_traceframe_info.
	* remote.c (PACKET_qXfer_traceframe_info): New.
	(remote_protocol_features): Register qXfer:traceframe-info:read.
	(remote_xfer_partial): Handle TARGET_OBJECT_TRACEFRAME_INFO.
	(remote_traceframe_info): New.
	(init_remote_ops): Install it.
	(_initialize_remote): Install "set/show remote traceframe-info"
	commands.
	* tracepoint.h (parse_traceframe_info): Declare.
	* tracepoint.c (struct mem_range): New.
	(mem_range_s): New typedef.
	(struct traceframe_info): New.
	(traceframe_info): New global.
	(free_traceframe_info): New function.
	(clear_traceframe_info): New function.
	(start_tracing, tfind_1, set_traceframe_number): Clear traceframe
	info.
	(build_traceframe_info): New function.
	(tfile_traceframe_info): New function.
	(init_tfile_ops): Install tfile_traceframe_info.
	(traceframe_info_start_memory, free_result): New functions.
	(memory_attributes, traceframe_info_elements): New globals.
	(parse_traceframe_info, get_traceframe_info): New functions.
	* features/traceframe-info.dtd: New file.
	* Makefile.in (XMLFILES): Add traceframe-info.dtd.

	gdb/gdbserver/
	* server.c (handle_qxfer_traceframe_info): New.
	(qxfer_packets): Register "traceframe-info".
	(handle_query): Report support for qXfer:traceframe-info:read+.
	* tracepoint.c (match_blocktype): New.
	(traceframe_find_block_type): Rename to ...
	(traceframe_walk_blocks): ... this.  Add callback filter argument,
	and use it.
	(traceframe_find_block_type): New, reimplemented on top of
	traceframe_walk_blocks.
	(build_traceframe_info_xml): New.
	(traceframe_read_info): New.
	* server.h (traceframe_read_info): Declare.

	gdb/doc/
	* gdb.texinfo (Remote Configuration): Mention set/show remote
	traceframe-info.
	(Tools/Packages Optional for Building GDB): Mention that expat is
	used for traceframe info.
	(Remote Protocol) <Menu>: Add "Traceframe Info Format".
	(General Query Packets) <qSupported>: Describe the
	qXfer:traceframe-info:read feature.
	(qXfer::read): Describe qXfer:traceframe-info:read.
	(Traceframe Info Format): New section.
@
text
@d520 2
d576 3
d4606 17
@


1.16
log
@	gdb/server/
	* server.c (gdb_read_memory): Change return semantics to allow
	partial transfers.
	(handle_search_memory_1): Adjust.
	(process_serial_event) <'m' packet>: Handle partial transfers.
	* tracepoint.c (traceframe_read_mem): Handle partial transfers.

	gdb/testsuite/
	* gdb.trace/collection.c (global_pieces): New.
	* gdb.trace/collection.exp (gdb_collect_global_in_pieces_test):
	New procedure.
	(gdb_trace_collection_test): Call it.
@
text
@d4744 21
d4766 6
a4771 2
traceframe_find_block_type (unsigned char *database, unsigned int datasize,
			    int tfnum, char type_wanted)
d4797 1
d4800 1
a4800 1
      if (type_wanted == blocktype)
d4834 12
d5085 66
@


1.15
log
@	gdb/gdbserver/
	* regcache.c (init_register_cache): Initialize
	regcache->register_status.
	(free_register_cache): Release regcache->register_status.
	(regcache_cpy): Copy register_status.
	(registers_to_string): Print 'x's for unavailable registers.
	(supply_register): Mark the register's status valid or
	unavailable, depending on whether a buffer was passed in or not.
	(supply_register_zeroed): New.
	(supply_regblock): Mark the registers' status valid or
	unavailable, depending on whether a buffer was passed in or not.
	* regcache.h (REG_UNAVAILABLE, REG_VALID): New defines.
	(struct regcache): New `register_status' field.
	(supply_register_zeroed): Declare.
	* i387-fp.c (i387_xsave_to_cache): Zero out registers using
	supply_register_zeroed, rather than passing a NULL buffer to
	supply_register.
	* tracepoint.c (fetch_traceframe_registers): Update comment.
@
text
@d4912 11
a4922 6
      /* Check that requested data is in bounds.  */
      if (maddr <= addr && (addr + length) <= (maddr + mlen))
	{
	  /* Block includes the requested range, copy it out.  */
	  memcpy (buf, dataptr + (addr - maddr), length);
	  *nbytes = length;
@


1.14
log
@2011-01-05  Michael Snyder  <msnyder@@msnyder-server.eng.vmware.com>

	* gdbreplay.c: Shorten lines of >= 80 columns.
	* linux-low.c: Ditto.
	* linux-ppc-low.c: Ditto.
	* linux-s390-low.c: Ditto.
	* linux-sparc-low.c: Ditto.
	* linux-x86-low.c: Ditto.
	* linux-xtensa-low.c: Ditto.
	* mem-break.c: Ditto.
	* nto-low.c: Ditto.
	* regcache.h: Ditto.
	* remote-utils.c: Ditto.
	* server.c: Ditto.
	* server.h: Ditto.
	* thread-db.c: Ditto.
	* tracepoint.c: Ditto.
	* utils.c: Ditto.
	* win32-low.h: Ditto.
@
text
@d4843 1
a4843 2
      /* We don't like making up numbers, but GDB has all manner of
	 troubles when the target says there are no registers.  */
@


1.13
log
@run copyright.sh for 2011.
@
text
@d133 4
a136 2
# define get_trace_state_variable_value gdb_agent_get_trace_state_variable_value
# define set_trace_state_variable_value gdb_agent_set_trace_state_variable_value
d180 1
a180 1
#define IPA_SYM(SYM)				\
d4075 3
a4077 1
      struct static_tracepoint_ctx *sctx = (struct static_tracepoint_ctx *) ctx;
d4902 2
a4903 1
						datasize - (dataptr - database),
d4965 2
a4966 1
						datasize - (dataptr - database),
d5158 2
a5159 1
  if (ipa_gdb_jump_pad_buffer <= stop_pc && stop_pc < ipa_gdb_jump_pad_buffer_end)
d5549 2
a5550 1
compile_tracepoint_condition (struct tracepoint *tpoint, CORE_ADDR *jump_entry)
d6194 3
a6196 2
      write_inferior_data_ptr (prev_ptr + offsetof (struct trace_state_variable,
						    next), 0);
d6234 4
a6237 2
	       ipa_traceframe_write_count_racy - ipa_traceframe_read_count_racy,
	       ipa_traceframe_write_count_racy, ipa_traceframe_read_count_racy);
d6382 2
a6383 1
	      if (read_inferior_memory (tf + offsetof (struct traceframe, data),
d6431 2
a6432 1
		   (int) (ipa_trace_buffer_ctrl.end_free - ipa_trace_buffer_lo),
d7153 2
a7154 1
	result = USTF(ltt_marker_connect) (m->channel, m->name, GDB_PROBE_NAME);
@


1.12
log
@2010-09-06  Yao Qi  <yao@@codesourcery.com>

	* linux-low.c (linux_kill): Remove unused variable.
	(linux_stabilize_threads): Likewise.
	* server.c (start_inferior): Likewise.
	(queue_stop_reply_callback): Likewise.
	* tracepoint.c (do_action_at_tracepoint): Likewise.
@
text
@d2 1
a2 1
   Copyright (C) 2009, 2010 Free Software Foundation, Inc.
@


1.11
log
@[gdbserver] Move malloc.h include to server.h.

This patch moves all includes of malloc.h, which were introduced
purely to get access to alloca's declaration, to server.h, next
to the include of alloca.h.

There is one exception: gdbreplay.c, which does not include server.h.
In this case, the include of alloca.h was simply moved up a bit, next
to the include of malloc.h.

gdb/gdbserver/ChangeLog:

        * gdbreplay.c: Move include of alloca.h up, next to include of
        malloc.h.
        * server.h: Add include of malloc.h.
        * mem-break.c: Remove include of malloc.h.
        * server.c, tracepoint.c, utils.c, win32-low.c: Likewise.
@
text
@a4128 2
	struct collect_registers_action *raction;

a4132 1
	raction = (struct collect_registers_action *) taction;
@


1.10
log
@use xsnprintf instead of snprintf.

snprintf is not available on LynxOS, so I changed the calls to snprintf
to calls to xsnprintf, which should be strictly equivalent.

gdb/gdbserver/ChangeLog:

        * utils.c (xsnprintf): Make non-static.
        * server.h: Add xsnprintf declaration.
        * linux-low.c, nto-low.c, target.c, thread-db.c, tracepoint.c:
        replace calls to snprintf by calls to xsnprintf throughout.
@
text
@a24 3
#if HAVE_MALLOC_H
#include <malloc.h>
#endif
@


1.9
log
@	Static tracepoints support, and UST integration.

	gdb/gdbserver/
	* configure.ac: Handle --with-ust.  substitute ustlibs and ustinc.
	* mem-break.c (uninsert_all_breakpoints)
	(reinsert_all_breakpoints): New.
	* mem-break.h (reinsert_all_breakpoints, uninsert_all_breakpoints):
	* tracepoint.c (ust_loaded, helper_thread_id, cmd_buf): New.
	(gdb_agent_ust_loaded, helper_thread_id)
	(gdb_agent_helper_thread_id): New macros.
	(struct ipa_sym_addresses): Add addr_ust_loaded,
	addr_helper_thread_id, addr_cmd_buf.
	(symbol_list): Add ust_loaded, helper_thread_id, cmd_buf.
	(in_process_agent_loaded_ust): New.
	(write_e_ust_not_loaded): New.
	(maybe_write_ipa_ust_not_loaded): New.
	(struct collect_static_trace_data_action): New.
	(enum tracepoint_type) <static_tracepoint>: New.
	(struct tracepoint) <handle>: Mention static tracepoints.
	(struct static_tracepoint_ctx): New.
	(CMD_BUF_SIZE): New.
	(add_tracepoint_action): Handle static tracepoint actions.
	(unprobe_marker_at): New.
	(clear_installed_tracepoints): Handle static tracepoints.
	(cmd_qtdp): Handle static tracepoints.
	(probe_marker_at): New.
	(cmd_qtstart): Handle static tracepoints.
	(response_tracepoint): Handle static tracepoints.
	(cmd_qtfstm, cmd_qtsstm, cmd_qtstmat): New.
	(handle_tracepoint_query): Handle qTfSTM, qTsSTM and qTSTMat.
	(get_context_regcache): Handle static tracepoints.
	(do_action_at_tracepoint): Handle static tracepoint actions.
	(traceframe_find_block_type): Handle static trace data blocks.
	(traceframe_read_sdata): New.
	(download_tracepoints): Download static tracepoint actions.
	[HAVE_UST] Include ust/ust.h, dlfcn.h, sys/socket.h, and sys/un.h.
	(GDB_PROBE_NAME): New.
	(ust_ops): New.
	(GET_UST_SYM): New.
	(USTF): New.
	(dlsym_ust): New.
	(ust_marker_to_static_tracepoint): New.
	(gdb_probe): New.
	(collect_ust_data_at_tracepoint): New.
	(gdb_ust_probe): New.
	(UNIX_PATH_MAX, SOCK_DIR): New.
	(gdb_ust_connect_sync_socket): New.
	(resume_thread, stop_thread): New.
	(run_inferior_command): New.
	(init_named_socket): New.
	(gdb_ust_socket_init): New.
	(cstr_to_hexstr): New.
	(next_st): New.
	(first_marker, next_marker): New.
	(response_ust_marker): New.
	(cmd_qtfstm, cmd_qtsstm): New.
	(unprobe_marker_at, probe_marker_at): New.
	(cmd_qtstmat, gdb_ust_thread): New.
	(gdb_ust_init): New.
	(initialize_tracepoint_ftlib): Call gdb_ust_init.
	* linux-amd64-ipa.c [HAVE_UST]: Include ust/processor.h
	(ST_REGENTRY): New.
	(x86_64_st_collect_regmap): New.
	(X86_64_NUM_ST_COLLECT_GREGS): New.
	(AMD64_RIP_REGNUM): New.
	(supply_static_tracepoint_registers): New.
	* linux-i386-ipa.c [HAVE_UST]: Include ust/processor.h
	(ST_REGENTRY): New.
	(i386_st_collect_regmap): New.
	(i386_NUM_ST_COLLECT_GREGS): New.
	(supply_static_tracepoint_registers): New.
	* server.c (handle_query): Handle qXfer:statictrace:read.
	<qSupported>: Report support for StaticTracepoints, and
	qXfer:statictrace:read features.
	* server.h (traceframe_read_sdata)
	(supply_static_tracepoint_registers): Declare.
	* remote-utils.c (convert_int_to_ascii, hexchars, ishex, tohex)
	(unpack_varlen_hex): Include in IPA build.
	* Makefile.in (ustlibs, ustinc): New.
	(IPA_OBJS): Add remote-utils-ipa.o.
	($(IPA_LIB)): Link -ldl and -lpthread.
	(UST_CFLAGS): New.
	(IPAGENT_CFLAGS): Add UST_CFLAGS.
	* config.in, configure: Regenerate.

	gdb/
	* NEWS: Mention new support for static tracepoints.
	(New packets): Mention qTfSTM, qTsSTM, qTSTMat and
	qXfer:statictrace:read.
	(New features in the GDB remote stub, GDBserver): Mention static
	tracepoints support using an UST based backend.
	(New commands): Mention "info static-tracepoint-markers" and
	"strace".
	* breakpoint.c (is_marker_spec): New.
	(is_tracepoint): Handle static tracepoints.
	(validate_commands_for_breakpoint): Static tracepoints can't do
	while-stepping.
	(static_tracepoints_here): New.
	(bpstat_what): Handle static tracepoints.
	(print_one_breakpoint_location, allocate_bp_location, mention):
	Ditto.
	(create_breakpoint_sal): Ditto.
	(decode_static_tracepoint_spec): New.
	(create_breakpoint): Replace `hardwareflag', and `traceflag' with
	`type_wanted'.  Adjust.  Handle static tracepoint marker
	locations.
	(break_command_1): Adjust.
	(update_static_tracepoint): New.
	(update_breakpoint_locations): Handle static tracepoints.
	(breakpoint_re_set_one): Handle static tracepoint marker
	locations.
	(disable_command, enable_command): Handle static tracepoints.
	(trace_command, ftrace_command): Adjust.
	(strace_command): New.
	(create_tracepoint_from_upload): Adjust.
	(save_breakpoints): Handle static tracepoints.
	(_initialize_breakpoint): Install the "strace" command.
	* breakpoint.h (enum bptype): New bp_static_tracepoint type.
	(struct breakpoint): New fields static_trace_marker_id and
	static_trace_marker_id_idx.
	(breakpoints_here_p): Declare.
	(create_breakpoint): Adjust.
	(static_tracepoints_here): Declare.
	* remote.c (struct remote_state) <static_tracepoints>: New field.
	(PACKET_qXfer_statictrace_read, PACKET_StaticTracepoints): New.
	(remote_static_tracepoint_marker_at): New.
	(remote_static_tracepoint_markers_by_strid): New.
	(remote_static_tracepoint_feature): New.
	(remote_disconnected_tracing_feature): Handle "StaticTracepoints".
	(remote_xfer_partial): Handle TARGET_OBJECT_STATIC_TRACE_DATA.
	(remote_supports_static_tracepoints): New.
	(remote_download_tracepoint): Download static tracepoints.
	(init_remote_ops): Install remote_static_tracepoint_marker_at and
	remote_static_tracepoint_markers_by_strid.
	(_initialize_remote): Install set|show remote static-tracepoints,
	and set|show remote read-sdata-object commands.
	* target.c (update_current_target): Inherit and default
	to_static_tracepoint_marker_at, and
	to_static_tracepoint_markers_by_strid.
	* target.h (static_tracepoint_marker): Forward declare.
	(enum target_object): New object TARGET_OBJECT_STATIC_TRACE_DATA.
	(static_tracepoint_marker_p): New typedef.
	(DEF_VEC_P(static_tracepoint_marker_p)): New VEC type.
	(struct target_ops): New fields to_static_tracepoint_marker_at and
	to_static_tracepoint_markers_by_strid.
	(target_static_tracepoint_marker_at)
	(target_static_tracepoint_markers_by_strid): New.
	* tracepoint.c: Include source.h.
	(validate_actionline): Handle $_sdata.
	(struct collection_list): New field strace_data.
	(add_static_trace_data): New.
	(clear_collection_list): Clear strace_data.
	(stringify_collection_list): Account for a possible static trace
	data collection.
	(encode_actions_1): Encode an $_sdata collection.
	(parse_tracepoint_definition): Handle static tracepoints.
	(parse_static_tracepoint_marker_definition): New.
	(release_static_tracepoint_marker): New.
	(print_one_static_tracepoint_marker): New.
	(info_static_tracepoint_markers_command): New.
	(sdata_make_value): New.
	(_initialize_tracepoint): Create the $_sdata convenience variable.
	Add the "info static-tracepoint-markers" command.
	Mention $_sdata in the "collect" command's help output.
	* tracepoint.h (struct static_tracepoint_marker): New.
	(parse_static_tracepoint_marker_definition)
	(release_static_tracepoint_marker): Declare.
	* mi/mi-cmd-break.c (mi_cmd_break_insert): Adjust.
	* python/py-breakpoint.c (bppy_new): Adjust.

	doc/
	* gdb.texinfo (Convenience Variables): Document $_sdata.
	(Commands to Set Tracepoints): Describe static tracepoints.  Add
	`Listing Static Tracepoint Markers' menu entry.  Document
	"strace".
	(Tracepoint Action Lists): Document collecting $_sdata.
	(Listing Static Tracepoint Markers): New subsection.
	(Tracepoints support in gdbserver): Mention static tracepoints.
	(remote packets, enabling and disabling): Mention
	read-sdata-object.
	(General Query Packets) <qSupported>: Document qXfer:sdata:read
	and StaticTracepoint.
	Mention qTfSTM, qTsSTM and qTSTMat as tracepoint packets.
	Document qXfer:sdata:read.
	(Tracepoint packets): Document qTfSTM, qTsSTM and qTSTMat.
@
text
@d6726 1
a6726 1
  res = snprintf (path, UNIX_PATH_MAX, "%s/gdb_ust%d", SOCK_DIR, pid);
d6742 1
a6742 1
  res = snprintf (addr.sun_path, UNIX_PATH_MAX, "%s", path);
d6967 2
a6968 2
  result = snprintf (name, UNIX_PATH_MAX, "%s/gdb_ust%d",
		     SOCK_DIR, getpid ());
@


1.8
log
@	* tracepoint.c (condition_true_at_tracepoint): Don't run compiled
	conditions in gdbserver.
@
text
@d138 3
d174 3
d218 3
d235 23
d263 16
a278 1
	   "Dynamic tracepoints unavailable.");
d281 3
d295 20
d420 2
d617 6
d650 4
d752 2
a753 2
     inserted the trap or jump.  NULL if we haven't inserted it
     yet.  */
d1242 29
d1342 4
d1874 12
d2277 11
d2327 13
d2412 5
d2729 27
d2761 1
a2761 1
  struct tracepoint *tpoint, *prev_ftpoint;
d2800 3
d2888 26
d3254 2
d3430 30
d3631 15
d3959 8
d4073 19
d4199 12
d4795 5
d4990 53
d5990 2
a5991 1
      if (tpoint->type != fast_tracepoint)
d6102 8
d6455 80
a6534 2
#include <sys/mman.h>
#include <fcntl.h>
d6536 2
a6537 3
IP_AGENT_EXPORT char *gdb_tp_heap_buffer;
IP_AGENT_EXPORT char *gdb_jump_pad_buffer;
IP_AGENT_EXPORT char *gdb_jump_pad_buffer_end;
d6539 2
a6540 2
static void __attribute__ ((constructor))
initialize_tracepoint_ftlib (void)
d6542 12
a6553 1
  initialize_tracepoint ();
d6556 152
d6710 641
@


1.7
log
@	* linux-x86-low.c (amd64_emit_const, amd64_emit_void_call_2)
	(i386_emit_const, i386_emit_void_call_2): Replace int64_t uses with
	LONGEST uses.
	* server.h (struct emit_ops): Replace int64_t uses with LONGEST
	uses.
	* tracepoint.c (emit_const, emit_void_call_2): Replace int64_t
	uses with LONGEST uses.
@
text
@d3926 15
d3944 1
@


1.6
log
@gdb/
2010-06-14  Pedro Alves  <pedro@@codesourcery.com>

	* NEWS: Mention GDBserver's JIT compilation of tracepoint
	bytecode.

gdb/gdbserver/
2010-06-14  Stan Shebs  <stan@@codesourcery.com>
	    Pedro Alves  <pedro@@codesourcery.com>

	Bytecode compiler.

	* linux-x86-low.c: Include limits.h.
	(add_insns): New.
	(always_true): New.
	(EMIT_ASM): New.
	(EMIT_ASM32): New.
	(amd64_emit_prologue, amd64_emit_epilogue, amd64_emit_add)
	(amd64_emit_sub, amd64_emit_mul, amd64_emit_lsh)
	(amd64_emit_rsh_signed, amd64_emit_rsh_unsigned, amd64_emit_ext,
	(amd64_emit_log_not, amd64_emit_bit_and, amd64_emit_bit_or)
	(amd64_emit_bit_xor, amd64_emit_bit_not, amd64_emit_equal,
	(amd64_emit_less_signed, amd64_emit_less_unsigned, amd64_emit_ref,
	(amd64_emit_if_goto, amd64_emit_goto, amd64_write_goto_address)
	(amd64_emit_const, amd64_emit_call, amd64_emit_reg)
	(amd64_emit_pop, amd64_emit_stack_flush, amd64_emit_zero_ext)
	(amd64_emit_swap, amd64_emit_stack_adjust, amd64_emit_int_call_1)
	(amd64_emit_void_call_2): New.
	(amd64_emit_ops): New.
	(i386_emit_prologue, i386_emit_epilogue, i386_emit_add)
	(i386_emit_sub,i386_emit_mul, i386_emit_lsh, i386_emit_rsh_signed)
	(i386_emit_rsh_unsigned, i386_emit_ext, i386_emit_log_not)
	(i386_emit_bit_and, i386_emit_bit_or, i386_emit_bit_xor)
	(i386_emit_bit_not, i386_emit_equal, i386_emit_less_signed)
	(i386_emit_less_unsigned, i386_emit_ref, i386_emit_if_goto)
	(i386_emit_goto, i386_write_goto_address, i386_emit_const)
	(i386_emit_call, i386_emit_reg, i386_emit_pop)
	(i386_emit_stack_flush, i386_emit_zero_ext, i386_emit_swap)
	(i386_emit_stack_adjust, i386_emit_int_call_1)
	(i386_emit_void_call_2): New.
	(i386_emit_ops): New.
	(x86_emit_ops): New.
	(the_low_target): Install x86_emit_ops.
	* server.h (struct emit_ops): New.
	(get_raw_reg_func_addr): Declare.
	(current_insn_ptr, emit_error): Declare.
	* tracepoint.c (get_raw_reg, get_trace_state_variable_value)
	(set_trace_state_variable_value): New defines.
	(struct ipa_sym_addresses): New fields addr_get_raw_reg,
	addr_get_trace_state_variable_value and
	addr_set_trace_state_variable_value.
	(symbol_list): New fields for get_raw_reg,
	get_trace_state_variable_value and set_trace_state_variable_value.
	(condfn): New typedef.
	(struct tracepoint): New field `compiled_cond'.
	(do_action_at_tracepoint): Clear compiled_cond.
	(get_trace_state_variable_value, set_trace_state_variable_value):
	Export in the IPA.
	(condition_true_at_tracepoint): If there's a compiled condition,
	run that.
	(current_insn_ptr, emit_error): New globals.
	(struct bytecode_address): New.
	(get_raw_reg_func_addr): New.
	(emit_prologue, emit_epilogue, emit_add, emit_sub, emit_mul)
	(emit_lsh, emit_rsh_signed, emit_rsh_unsigned, emit_ext)
	(emit_log_not, emit_bit_and, emit_bit_or, emit_bit_xor)
	(emit_bit_not, emit_equal, emit_less_signed, emit_less_unsigned)
	(emit_ref, emit_if_goto, emit_goto, write_goto_address, emit_const)
	(emit_reg, emit_pop, emit_stack_flush, emit_zero_ext, emit_swap)
	(emit_stack_adjust, emit_int_call_1, emit_void_call_2): New.
	(compile_tracepoint_condition, compile_bytecodes): New.
	* target.h (emit_ops): Forward declare.
	(struct target_ops): New field emit_ops.
	(target_emit_ops): New.
	* linux-amd64-ipa.c (gdb_agent_get_raw_reg): New.
	* linux-i386-ipa.c (gdb_agent_get_raw_reg): New.
	* linux-low.c (linux_emit_ops): New.
	(linux_target_ops): Install it.
	* linux-low.h (struct linux_target_ops): New field emit_ops.
@
text
@d5116 1
a5116 1
emit_const (int64_t num)
d5165 1
a5165 1
/* FN's prototype is `void(*fn)(int,int64_t)'.  */
@


1.5
log
@gdb/gdbserver/
2010-06-01  Pedro Alves  <pedro@@codesourcery.com>
	    Stan Shebs  <stan@@codesourcery.com>

	* Makefile.in (IPA_DEPFILES, extra_libraries): New.
	(all): Depend on $(extra_libraries).
	(install-only): Install the IPA.
	(IPA_OBJS, IPA_LIB): New.
	(clean): Remove the IPA lib.
	(IPAGENT_CFLAGS): New.
	(tracepoint-ipa.o, utils-ipa.o, remote-utils-ipa.o)
	(regcache-ipa.o, i386-linux-ipa.o, linux-i386-ipa.o)
	(linux-amd64-ipa.o, amd64-linux-ipa.o): New rules.
	* linux-amd64-ipa.c, linux-i386-ipa.c: New files.
	* configure.ac: Check for atomic builtins support in the compiler.
	(IPA_DEPFILES, extra_libraries): Define.
	* configure.srv (ipa_obj): Add description.
	(ipa_i386_linux_regobj, ipa_amd64_linux_regobj): Define.
	(i[34567]86-*-linux*): Set ipa_obj.
	(x86_64-*-linux*): Set ipa_obj.
	* linux-low.c (stabilizing_threads): New.
	(supports_fast_tracepoints): New.
	(linux_detach): Stabilize threads before detaching.
	(handle_tracepoints): Handle internal tracing breakpoints.  Assert
	the lwp is either not stabilizing, or is moving out of a jump pad.
	(linux_fast_tracepoint_collecting): New.
	(maybe_move_out_of_jump_pad): New.
	(enqueue_one_deferred_signal): New.
	(dequeue_one_deferred_signal): New.
	(linux_wait_for_event_1): If moving out of a jump pad, defer
	pending signals to later.
	(linux_stabilize_threads): New.
	(linux_wait_1): Check if threads need moving out of jump pads, and
	do it if so.
	(stuck_in_jump_pad_callback): New.
	(move_out_of_jump_pad_callback): New.
	(lwp_running): New.
	(linux_resume_one_lwp): Handle moving out of jump pads.
	(linux_set_resume_request): Dequeue deferred signals.
	(need_step_over_p): Also step over fast tracepoint jumps.
	(start_step_over): Also uninsert fast tracepoint jumps.
	(finish_step_over): Also reinsert fast tracepoint jumps.
	(linux_install_fast_tracepoint_jump): New.
	(linux_target_ops): Install linux_stabilize_threads and
	linux_install_fast_tracepoint_jump_pad.
	* linux-low.h (linux_target_ops) <get_thread_area,
	install_fast_tracepoint_jump_pad>: New fields.
	(struct lwp_info) <collecting_fast_tracepoint,
	pending_signals_to_report, exit_jump_pad_bkpt>: New fields.
	(linux_get_thread_area): Declare.
	* linux-x86-low.c (jump_insn): New.
	(x86_get_thread_area): New.
	(append_insns): New.
	(push_opcode): New.
	(amd64_install_fast_tracepoint_jump_pad): New.
	(i386_install_fast_tracepoint_jump_pad): New.
	(x86_install_fast_tracepoint_jump_pad): New.
	(the_low_target): Install x86_get_thread_area and
	x86_install_fast_tracepoint_jump_pad.
	* mem-break.c (set_raw_breakpoint_at): Use read_inferior_memory.
	(struct fast_tracepoint_jump): New.
	(fast_tracepoint_jump_insn): New.
	(fast_tracepoint_jump_shadow): New.
	(find_fast_tracepoint_jump_at): New.
	(fast_tracepoint_jump_here): New.
	(delete_fast_tracepoint_jump): New.
	(set_fast_tracepoint_jump): New.
	(uninsert_fast_tracepoint_jumps_at): New.
	(reinsert_fast_tracepoint_jumps_at): New.
	(set_breakpoint_at): Use write_inferior_memory.
	(uninsert_raw_breakpoint): Use write_inferior_memory.
	(check_mem_read): Mask out fast tracepoint jumps.
	(check_mem_write): Mask out fast tracepoint jumps.
	* mem-break.h (struct fast_tracepoint_jump): Forward declare.
	(set_fast_tracepoint_jump): Declare.
	(delete_fast_tracepoint_jump)
	(fast_tracepoint_jump_here, uninsert_fast_tracepoint_jumps_at)
	(reinsert_fast_tracepoint_jumps_at): Declare.
	* regcache.c: Don't compile many functions when building the
	in-process agent library.
	(init_register_cache) [IN_PROCESS_AGENT]: Don't allow allocating
	the register buffer in the heap.
	(free_register_cache): If the register buffer isn't owned by the
	regcache, don't free it.
	(set_register_cache) [IN_PROCESS_AGENT]: Don't re-alocate
	pre-existing register caches.
	* remote-utils.c (convert_int_to_ascii): Constify `from' parameter
	type.
	(convert_ascii_to_int): : Constify `from' parameter type.
	(decode_M_packet, decode_X_packet): Replace the `to' parameter by
	a `to_p' pointer to pointer parameter.  If TO_P is NULL, malloc
	the needed buffer in-place.
	(relocate_instruction): New.
	* server.c (handle_query) <qSymbols>: If the target supports
	tracepoints, give it a chance of looking up symbols.  Report
	support for fast tracepoints.
	(handle_status): Stabilize threads.
	(process_serial_event): Adjust.
	* server.h (struct fast_tracepoint_jump): Forward declare.
	(struct process_info) <fast_tracepoint_jumps>: New field.
	(convert_ascii_to_int, convert_int_to_ascii): Adjust.
	(decode_X_packet, decode_M_packet): Adjust.
	(relocate_instruction): Declare.
	(in_process_agent_loaded): Declare.
	(tracepoint_look_up_symbols): Declare.
	(struct fast_tpoint_collect_status): Declare.
	(fast_tracepoint_collecting): Declare.
	(force_unlock_trace_buffer): Declare.
	(handle_tracepoint_bkpts): Declare.
	(initialize_low_tracepoint)
	(supply_fast_tracepoint_registers) [IN_PROCESS_AGENT]: Declare.
	* target.h (struct target_ops) <stabilize_threads,
	install_fast_tracepoint_jump_pad>: New fields.
	(stabilize_threads, install_fast_tracepoint_jump_pad): New.
	* tracepoint.c [HAVE_MALLOC_H]: Include malloc.h.
	[HAVE_STDINT_H]: Include stdint.h.
	(trace_debug_1): Rename to ...
	(trace_vdebug): ... this.
	(trace_debug): Rename to ...
	(trace_debug_1): ... this.  Add `level' parameter.
	(trace_debug): New.
	(ATTR_USED, ATTR_NOINLINE): New.
	(IP_AGENT_EXPORT): New.
	(gdb_tp_heap_buffer, gdb_jump_pad_buffer, gdb_jump_pad_buffer_end)
	(collecting, gdb_collect, stop_tracing, flush_trace_buffer)
	(about_to_request_buffer_space, trace_buffer_is_full)
	(stopping_tracepoint, expr_eval_result, error_tracepoint)
	(tracepoints, tracing, trace_buffer_ctrl, trace_buffer_ctrl_curr)
	(trace_buffer_lo, trace_buffer_hi, traceframe_read_count)
	(traceframe_write_count, traceframes_created)
	(trace_state_variables)
	New renaming defines.
	(struct ipa_sym_addresses): New.
	(STRINGIZE_1, STRINGIZE, IPA_SYM): New.
	(symbol_list): New.
	(ipa_sym_addrs): New.
	(all_tracepoint_symbols_looked_up): New.
	(in_process_agent_loaded): New.
	(write_e_ipa_not_loaded): New.
	(maybe_write_ipa_not_loaded): New.
	(tracepoint_look_up_symbols): New.
	(debug_threads) [IN_PROCESS_AGENT]: New.
	(read_inferior_memory) [IN_PROCESS_AGENT]: New.
	(UNKNOWN_SIDE_EFFECTS): New.
	(stop_tracing): New.
	(flush_trace_buffer): New.
	(stop_tracing_bkpt): New.
	(flush_trace_buffer_bkpt): New.
	(read_inferior_integer): New.
	(read_inferior_uinteger): New.
	(read_inferior_data_pointer): New.
	(write_inferior_data_pointer): New.
	(write_inferior_integer): New.
	(write_inferior_uinteger): New.
	(struct collect_static_trace_data_action): Delete.
	(enum tracepoint_type): New.
	(struct tracepoint) <type>: New field `type'.
	<actions_str, step_actions, step_actions_str>: Only include in GDBserver.
	<orig_size, obj_addr_on_target, adjusted_insn_addr>
	<adjusted_insn_addr_end, jump_pad, jump_pad_end>: New fields.
	(tracepoints): Use IP_AGENT_EXPORT.
	(last_tracepoint): Don't include in the IPA.
	(stopping_tracepoint): Use IP_AGENT_EXPORT.
	(trace_buffer_is_full): Use IP_AGENT_EXPORT.
	(alloced_trace_state_variables): New.
	(trace_state_variables): Use IP_AGENT_EXPORT.
	(traceframe_t): Delete unused variable.
	(circular_trace_buffer): Don't include in the IPA.
	(trace_buffer_start): Delete.
	(struct trace_buffer_control): New.
	(trace_buffer_free): Delete.
	(struct ipa_trace_buffer_control): New.
	(GDBSERVER_FLUSH_COUNT_MASK, GDBSERVER_FLUSH_COUNT_MASK_PREV)
	(GDBSERVER_FLUSH_COUNT_MASK_CURR, GDBSERVER_UPDATED_FLUSH_COUNT_BIT):
	New.
	(trace_buffer_ctrl): New.
	(TRACE_BUFFER_CTRL_CURR): New.
	(trace_buffer_start, trace_buffer_free, trace_buffer_end_free):
	Reimplement as macros.
	(trace_buffer_wrap): Delete.
	(traceframe_write_count, traceframe_read_count)
	(traceframes_created, tracing): Use IP_AGENT_EXPORT.
	(struct tracepoint_hit_ctx) <type>: New field.
	(struct fast_tracepoint_ctx): New.
	(memory_barrier): New.
	(cmpxchg): New.
	(record_tracepoint_error): Update atomically in the IPA.
	(clear_inferior_trace_buffer): New.
	(about_to_request_buffer_space): New.
	(trace_buffer_alloc): Handle GDBserver and inferior simulatenous
	updating the same buffer.
	(add_tracepoint): Default the tracepoint's type to trap
	tracepoint, and orig_size to -1.
	(get_trace_state_variable) [IN_PROCESS_AGENT]: Handle allocated
	internal variables.
	(create_trace_state_variable): New parameter `gdb'.  Handle it.
	(clear_installed_tracepoints): Clear fast tracepoint jumps.
	(cmd_qtdp): Handle fast tracepoints.
	(cmd_qtdv): Adjust.
	(max_jump_pad_size): New.
	(gdb_jump_pad_head): New.
	(get_jump_space_head): New.
	(claim_jump_space): New.
	(sort_tracepoints): New.
	(MAX_JUMP_SIZE): New.
	(cmd_qtstart): Handle fast tracepoints.  Sync tracepoints with the
	IPA.
	(stop_tracing) [IN_PROCESS_AGENT]: Don't include the tdisconnected
	support.  Upload fast traceframes, and delete internal IPA
	breakpoints.
	(stop_tracing_handler): New.
	(flush_trace_buffer_handler): New.
	(cmd_qtstop): Upload fast tracepoints.
	(response_tracepoint): Handle fast tracepoints.
	(tracepoint_finished_step): Upload fast traceframes.  Set the
	tracepoint hit context's tracepoint type.
	(handle_tracepoint_bkpts): New.
	(tracepoint_was_hit): Set the tracepoint hit context's tracepoint
	type.  Add comment about fast tracepoints.
	(collect_data_at_tracepoint) [IN_PROCESS_AGENT]: Don't access the
	non-existing action_str field.
	(get_context_regcache): Handle fast tracepoints.
	(do_action_at_tracepoint) [!IN_PROCESS_AGENT]: Don't write the PC
	to the regcache.
	(fast_tracepoint_from_jump_pad_address): New.
	(fast_tracepoint_from_ipa_tpoint_address): New.
	(collecting_t): New.
	(force_unlock_trace_buffer): New.
	(fast_tracepoint_collecting): New.
	(collecting): New.
	(gdb_collect): New.
	(write_inferior_data_ptr): New.
	(target_tp_heap): New.
	(target_malloc): New.
	(download_agent_expr): New.
	(UALIGN): New.
	(download_tracepoints): New.
	(download_trace_state_variables): New.
	(upload_fast_traceframes): New.
	(IPA_FIRST_TRACEFRAME): New.
	(IPA_NEXT_TRACEFRAME_1): New.
	(IPA_NEXT_TRACEFRAME): New.
	[IN_PROCESS_AGENT]: Include sys/mman.h and fcntl.h.
	[IN_PROCESS_AGENT] (gdb_tp_heap_buffer, gdb_jump_pad_buffer)
	(gdb_jump_pad_buffer_end): New.
	[IN_PROCESS_AGENT] (initialize_tracepoint_ftlib): New.
	(initialize_tracepoint): Adjust.
	[IN_PROCESS_AGENT]: Allocate the IPA heap, and jump pad scratch
	buffer.  Initialize the low module.
	* utils.c (PREFIX, TOOLNAME): New.
	(malloc_failure): Use PREFIX.
	(error): In the IPA, an error causes an exit.
	(fatal, warning): Use PREFIX.
	(internal_error): Use TOOLNAME.
	(NUMCELLS): Increase to 10.
	* configure, config.in: Regenerate.

gdb/
2010-06-01  Pedro Alves  <pedro@@codesourcery.com>

	* NEWS: Mention gdbserver fast tracepoints support.

gdb/doc/
2010-06-01  Pedro Alves  <pedro@@codesourcery.com>

	* gdb.texinfo (Set Tracepoints): Mention tracepoints support in
	gdbserver, and add cross reference.
	(Tracepoints support in gdbserver): New subsection.
@
text
@d135 3
d168 3
d209 3
d576 3
d627 2
d1206 2
d1629 1
d1874 1
a1874 1
static LONGEST
d1900 1
a1900 1
static void
d3926 4
a3929 1
  err = eval_agent_expr (ctx, NULL, tpoint->cond, &value);
d4967 576
d5621 22
@


1.4
log
@	* linux-low.c (linux_kill, linux_detach): Adjust.
	(status_pending_p_callback): Remove redundant statement.  Check
	for !TARGET_WAITIKIND_IGNORE, instead of
	TARGET_WAITKIND_STOPPED.
	(handle_tracepoints): Make sure LWP is locked.  Adjust.
	(linux_wait_for_event_1): Adjust.
	(linux_cancel_breakpoints): New.
	(unsuspend_one_lwp): New.
	(unsuspend_all_lwps): New.
	(linux_wait_1): If finishing a step-over, unsuspend all lwps.
	(send_sigstop_callback): Change return type to int, add new
	`except' parameter and handle it.
	(suspend_and_send_sigstop_callback): New.
	(stop_all_lwps): Add new `suspend' and `expect' parameters, and
	pass them down.  If SUSPEND, also increment the lwp's suspend
	count.
	(linux_resume_one_lwp): Add notice about resuming a suspended LWP.
	(need_step_over_p): Don't consider suspended LWPs.
	(start_step_over): Adjust.
	(proceed_one_lwp): Change return type to int, add new `except'
	parameter and handle it.
	(unsuspend_and_proceed_one_lwp): New.
	(proceed_all_lwps): Use find_inferior instead of
	for_each_inferior.
	(unstop_all_lwps): Add `unsuspend' parameter.  If UNSUSPEND, them
	also decrement the suspend count of LWPs.  Pass `except' down,
	instead of hacking its suspend count.
	(linux_pause_all): Add `freeze' parameter.  Adjust.
	(linux_unpause_all): New.
	(linux_target_ops): Install linux_unpause_all.
	* server.c (handle_status): Adjust.
	* target.h (struct target_ops): New fields `unpause_all' and
	`cancel_breakpoints'.  Add new parameter to `pause_all'.
	(pause_all): Add new `freeze' parameter.
	(unpause_all): New.
	(cancel_breakpoints): New.
	* tracepoint.c (clear_installed_tracepoints): Pause threads, and
	cancel breakpoints.
	(cmd_qtstart): Pause threads.
	(stop_tracing): Pause threads, and cancel breakpoints.
	* win32-low.c (win32_target_ops): Adjust.
@
text
@d24 34
d59 1
a59 1
static void trace_debug_1 (const char *, ...) ATTR_FORMAT (printf, 1, 2);
d62 1
a62 1
trace_debug_1 (const char *fmt, ...)
d73 1
a73 1
#define trace_debug(FMT, args...)		\
d75 2
a76 2
    if (debug_threads)				\
      trace_debug_1 ((FMT), ##args);		\
d79 242
d329 59
a535 6
/* An 'L' (collect static trace data) action.  */
struct collect_static_trace_data_action
{
  struct tracepoint_action base;
};

d556 9
d589 3
a609 8
  /* Same, but in string/packet form.  */
  char **actions_str;

  /* The list of actions to take while in a stepping loop.  */
  int num_step_actions;
  struct tracepoint_action **step_actions;
  /* Same, but in string/packet form.  */
  char **step_actions_str;
d615 8
d628 30
a657 2
  /* Handle returned by the breakpoint module when we inserted the
     trap.  NULL if we haven't inserted it yet.  */
d659 1
a660 2
  /* Link to the next tracepoint in the list.  */
  struct tracepoint *next;
d663 2
d687 6
a692 1
/* The linked list of all tracepoints.  */
d694 1
a694 1
static struct tracepoint *tracepoints;
d700 1
d704 1
a704 1
static struct tracepoint *stopping_tracepoint;
d708 1
a708 1
static int trace_buffer_is_full;
d728 2
d742 2
d776 5
a780 1
static struct trace_state_variable *trace_state_variables;
d840 1
a840 1
} ATTR_PACKED traceframe_t;
d851 1
d853 1
d864 30
a893 3
/* Pointer to the first trace frame in the buffer.  In the
   non-circular case, this is equal to trace_buffer_lo, otherwise it
   moves around in the buffer.  */
d895 9
a903 1
static unsigned char *trace_buffer_start;
a904 3
/* Pointer to the free part of the trace buffer.  Note that we clear
   several bytes at and after this pointer, so that traceframe
   scans/searches terminate properly.  */
d906 125
a1030 7
static unsigned char *trace_buffer_free;

/* Pointer to the byte after the end of the free part.  Note that this
   may be smaller than trace_buffer_free in the circular case, and
   means that the free part is in two pieces.  Initially it is equal
   to trace_buffer_hi, then is generally equivalent to
   trace_buffer_start.  */
d1032 7
a1038 1
static unsigned char *trace_buffer_end_free;
a1039 5
/* Pointer to the wraparound.  If not equal to trace_buffer_hi, then
   this is the point at which the trace data breaks, and resumes at
   trace_buffer_lo.  */

static unsigned char *trace_buffer_wrap;
d1059 2
a1060 1
   of complete traceframes present in the trace buffer.  */
d1062 2
a1063 2
static unsigned int traceframe_write_count;
static unsigned int traceframe_read_count;
d1073 3
a1075 1
static int traceframes_created;
d1099 2
d1103 3
a1105 1
int tracing;
d1119 2
d1124 1
a1124 1
   collect_data_at_tracepoint. */
d1127 1
a1127 1
  /* empty */
d1130 3
a1132 1
/* Trap tracepoint specific data to be passed down to
d1134 11
d1146 4
d1157 3
d1162 1
d1172 1
d1175 1
d1180 1
d1183 1
d1188 1
a1188 1

d1192 1
a1192 1

d1199 16
d1224 11
a1234 1
  expr_eval_result = rtype;
d1254 39
d1302 12
d1321 8
d1331 1
d1339 27
d1369 6
a1374 5
  trace_debug ("Trace buffer start=%d free=%d endfree=%d wrap=%d hi=%d",
	       (int) (trace_buffer_start - trace_buffer_lo),
	       (int) (trace_buffer_free - trace_buffer_lo),
	       (int) (trace_buffer_end_free - trace_buffer_lo),
	       (int) (trace_buffer_wrap - trace_buffer_lo),
d1386 1
a1386 1
      if (trace_buffer_end_free < trace_buffer_free)
d1388 1
a1388 1
	  if (trace_buffer_free + amt <= trace_buffer_hi)
d1398 2
a1399 2
	      trace_buffer_wrap = trace_buffer_free;
	      trace_buffer_free = trace_buffer_lo;
d1404 1
a1404 1
      if (trace_buffer_free + amt <= trace_buffer_end_free)
d1407 17
d1446 5
d1456 1
a1456 1
      if (new_start < trace_buffer_start)
d1459 1
a1459 1
	  trace_buffer_wrap = trace_buffer_hi;
d1461 2
a1462 2
      trace_buffer_start = new_start;
      trace_buffer_end_free = trace_buffer_start;
d1465 7
a1471 5
		   "Trace buffer, start=%d free=%d endfree=%d wrap=%d hi=%d",
		   (int) (trace_buffer_start - trace_buffer_lo),
		   (int) (trace_buffer_free - trace_buffer_lo),
		   (int) (trace_buffer_end_free - trace_buffer_lo),
		   (int) (trace_buffer_wrap - trace_buffer_lo),
d1477 1
d1482 1
a1482 1
  rslt = trace_buffer_free;
d1485 60
a1544 2
     the marker.  */
  trace_buffer_free += (amt - sizeof (struct traceframe));
d1549 2
a1550 2
  ((struct traceframe *) trace_buffer_free)->tpnum = 0;
  ((struct traceframe *) trace_buffer_free)->data_size = 0;
d1559 7
a1565 5
      trace_debug ("Trace buffer start=%d free=%d endfree=%d wrap=%d hi=%d",
		   (int) (trace_buffer_start - trace_buffer_lo),
		   (int) (trace_buffer_free - trace_buffer_lo),
		   (int) (trace_buffer_end_free - trace_buffer_lo),
		   (int) (trace_buffer_wrap - trace_buffer_lo),
d1572 2
d1609 3
d1627 2
d1664 2
d1800 2
d1809 7
d1827 1
a1827 1
create_trace_state_variable (int num)
d1842 12
a1853 3
  tsv->next = trace_state_variables;
  trace_state_variables = tsv;

d1978 2
d2080 4
d2128 1
d2164 10
a2173 1
      delete_breakpoint (tpoint->handle);
d2237 8
a2244 1
	  if (*packet == 'X')
d2260 1
a2260 1
      trace_debug ("Defined tracepoint %d at 0x%s, "
d2262 3
a2264 2
		   tpoint->number, paddress (tpoint->address),
		   tpoint->enabled,
d2364 1
a2364 1
  tsv = create_trace_state_variable (num);
d2473 2
a2474 5
static void
cmd_qtstart (char *packet)
{
  struct tracepoint *tpoint;
  int slow_tracepoint_count;
d2476 1
a2476 1
  trace_debug ("Starting the trace");
d2478 1
a2478 1
  slow_tracepoint_count = 0;
d2480 97
a2576 1
  *packet = '\0';
d2579 9
d2590 12
d2611 37
a2647 1
      ++slow_tracepoint_count;
d2649 1
a2649 5
      /* Tracepoints are installed as memory breakpoints.  Just go
	 ahead and install the trap.  The breakpoints module handles
	 duplicated breakpoints, and the memory read routine handles
	 un-patching traps from memory reads.  */
      tpoint->handle = set_breakpoint_at (tpoint->address, tracepoint_handler);
d2651 37
a2687 1
      /* Any failure is sufficient cause to give up.  */
d2712 24
d2755 8
a2762 1
  /* Pause all threads before removing breakpoints from memory.  */
d2771 5
d2799 1
d2805 1
d2818 21
d2842 19
d2961 9
d3023 2
d3374 3
d3449 5
d3477 1
d3541 83
d3638 1
d3643 3
d3681 2
d3715 1
d3719 1
d3732 2
d3769 2
d3774 22
a3795 2
  struct trap_tracepoint_ctx *tctx = (struct trap_tracepoint_ctx *) ctx;
  struct regcache *regcache = tctx->regcache;
d3859 1
d3865 5
a3869 1
	   since it will be wrong for while-stepping actions.  */
d3876 1
d3924 2
d3961 2
d4410 2
a4456 5
	case 'S':
	  /* Skip over the static trace data block.  */
	  memcpy (&mlen, dataptr, sizeof (mlen));
	  dataptr += (sizeof (mlen) + mlen);
	  break;
d4651 820
d5494 1
a5494 1
  create_trace_state_variable (1);
d5497 24
@


1.3
log
@	GDBserver disconnected tracing support.

	* linux-low.c (linux_remove_process): Delete.
	(add_lwp): Don't set last_resume_kind here.
	(linux_kill): Use `mourn'.
	(linux_detach): Use `thread_db_detach', and `mourn'.
	(linux_mourn): New.
	(linux_attach_lwp_1): Adjust comment.
	(linux_attach): last_resume_kind moved the thread_info; adjust.
	(status_pending_p_callback): Adjust.
	(linux_wait_for_event_1): Adjust.
	(count_events_callback, select_singlestep_lwp_callback)
	(select_event_lwp_callback, cancel_breakpoints_callback)
	(db_wants_lwp_stopped, linux_wait_1, need_step_over_p)
	(proceed_one_lwp): Adjust.
	(linux_async): Add debug output.
	(linux_thread_stopped): New.
	(linux_pause_all): New.
	(linux_target_ops): Install linux_mourn, linux_thread_stopped and
	linux_pause_all.
	* linux-low.h (struct lwp_info): Delete last_resume_kind field.
	(thread_db_free): Delete declaration.
	(thread_db_detach, thread_db_mourn): Declare.
	* thread-db.c (thread_db_init): Use thread_db_mourn.
	(thread_db_free): Delete, split in two.
	(disable_thread_event_reporting): New.
	(thread_db_detach): New.
	(thread_db_mourn): New.

	* server.h (struct thread_info) <last_resume_kind>: New field.
	<attached>: Add comment.
	<gdb_detached>: New field.
	(handler_func): Change return type to int.
	(handle_serial_event, handle_target_event): Ditto.
	(gdb_connected): Declare.
	(tracing): Delete.
	(disconnected_tracing): Declare.
	(stop_tracing): Declare.

	* server.c (handle_query) <qSupported>: Report support for
	disconnected tracing.
	(queue_stop_reply_callback): Account for running threads.
	(gdb_wants_thread_stopped): New.
	(gdb_wants_all_threads_stopped): New.
	(gdb_reattached_process): New.
	(handle_status): Clear the `gdb_detached' flag of all processes.
	In all-stop, stop all threads.
	(main): Be sure to leave tfind mode.  Handle disconnected tracing.
	(process_serial_event): If the remote connection breaks, or if an
	exit was forced with "monitor exit", force an event loop exit.
	Handle disconnected tracing on detach.
	(handle_serial_event): Adjust.
	(handle_target_event): If GDB isn't connected, forward events back
	to the inferior, unless the last process exited, in which case,
	exit gdbserver.  Adjust interface.

	* remote-utils.c (remote_open): Don't block in accept.  Instead
	register an event loop source on the listen socket file
	descriptor.  Refactor bits into ...
	(listen_desc): ... this new global.
	(gdb_connected): ... this new function.
	(enable_async_notification): ... this new function.
	(handle_accept_event): ... this new function.
	(remote_close): Clear remote_desc.

	* inferiors.c (add_thread): Set the new thread's last_resume_kind.

	* target.h (struct target_ops) <mourn, thread_stopped, pause_all>:
	New fields.
	(mourn_inferior): Define.
	(target_process_qsupported): Avoid the dangling else problem.
	(thread_stopped): Define.
	(pause_all): Define.
	(target_waitstatus_to_string): Declare.
	* target.c (target_waitstatus_to_string): New.

	* tracepoint.c (tracing): Make extern.
	(disconnected_tracing): New.
	(stop_tracing): Make extern.  Handle tracing stops due to GDB
	disconnecting.
	(cmd_qtdisconnected): New.
	(cmd_qtstatus): Report disconnected tracing status in trace reply.
	(handle_tracepoint_general_set): Handle QTDisconnected.

	* event-loop.c (event_handler_func): Change return type to int.
	(process_event): Bail out if the event handler wants the event
	loop to stop.
	(handle_file_event): Ditto.
	(start_event_loop): Bail out if the event handler wants the event
	loop to stop.

	* nto-low.c (nto_target_ops): Adjust.
	* spu-low.c (spu_wait): Don't remove the process here.
	(spu_target_ops): Adjust.
	* win32-low.c (win32_wait): Don't remove the process here.
	(win32_target_ops): Adjust.
@
text
@d1339 3
d1363 2
d1664 3
d1697 1
d1709 2
d1728 6
d1776 2
@


1.2
log
@	* tracepoint.c (cmd_qtstatus): Report trace buffer circularity.
@
text
@d561 5
a565 1
static int tracing;
d1706 1
a1706 1
static void
d1743 5
d1769 15
d1880 7
a1886 1
  sprintf (packet, "T%d;%s:%x;tframes:%x;tcreated:%x;tfree:%x;tsize:%s;circular:%d",
d1890 3
a1892 3
	   free_space (),
	   phex_nz (trace_buffer_hi - trace_buffer_lo, 0),
	   circular_trace_buffer);
d2201 6
@


1.1
log
@	gdb/gdbserver/
	* server.h (LONGEST): New.
	(struct thread_info) <while_stepping>: New field.
	(unpack_varlen_hex, xrealloc, pulongest, plongest, phex_nz):
	Declare.
	(initialize_tracepoint, handle_tracepoint_general_set)
	(handle_tracepoint_query, tracepoint_finished_step)
	(tracepoint_was_hit, release_while_stepping_state_list):
	(current_traceframe): Declare.
	* server.c (handle_general_set): Handle tracepoint packets.
	(read_memory): New.
	(write_memory): New.
	(handle_search_memory_1): Use read_memory.
	(handle_query): Report support for conditional tracepoints, trace
	state variables, and tracepoint sources.  Handle tracepoint
	queries.
	(main): Initialize the tracepoints module.
	(process_serial_event): Handle traceframe reads/writes.

	* linux-low.c (handle_tracepoints): New.
	(linux_wait_1): Call it.
	(linux_resume_one_lwp): Handle while-stepping.
	(linux_supports_tracepoints, linux_read_pc, linux_write_pc): New.
	(linux_target_ops): Install them.
	* linux-low.h (struct linux_target_ops) <supports_tracepoints>:
	New field.
	* linux-x86-low.c (x86_supports_tracepoints): New.
	(the_low_target). Install it.

	* mem-break.h (delete_breakpoint): Declare.
	* mem-break.c (delete_breakpoint): Make external.

	* target.h (struct target_ops): Add `supports_tracepoints',
	`read_pc', and `write_pc' fields.
	(target_supports_tracepoints): Define.
	* utils.c (xrealloc, decimal2str, pulongest, plongest, thirty_two)
	(phex_nz): New.

	* regcache.h (struct regcache) <registers_owned>: New field.
	(init_register_cache, regcache_cpy): Declare.
	(regcache_read_pc, regcache_write_pc): Declare.
	(register_cache_size): Declare.
	(supply_regblock): Declare.
	* regcache.c (init_register_cache): New.
	(new_register_cache): Use it.
	(regcache_cpy): New.
	(register_cache_size): New.
	(supply_regblock): New.
	(regcache_read_pc, regcache_write_pc): New.

	* tracepoint.c: New.

	* Makefile.in (OBS): Add tracepoint.o.
	(tracepoint.o): New rule.

	gdb/
	* regformats/regdat.sh: Include server.h.  Don't include
	regcache.h.
@
text
@d1856 2
a1857 2
  sprintf (packet, "T%c;%s:%x;tframes:%x;tcreated:%x;tfree:%x;tsize:%s",
	   (tracing ? '1' : '0'),
d1861 2
a1862 1
	   phex_nz (trace_buffer_hi - trace_buffer_lo, 0));
@

