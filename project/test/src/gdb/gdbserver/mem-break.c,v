head	1.38;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.38
	gdb_7_6-2013-04-26-release:1.38
	gdb_7_6-branch:1.38.0.2
	gdb_7_6-2013-03-12-branchpoint:1.38
	gdb_7_5_1-2012-11-29-release:1.36
	gdb_7_5-2012-08-17-release:1.36
	gdb_7_5-branch:1.36.0.2
	gdb_7_5-2012-07-18-branchpoint:1.36
	gdb_7_4_1-2012-04-26-release:1.30.2.1
	gdb_7_4-2012-01-24-release:1.30.2.1
	gdb_7_4-branch:1.30.0.2
	gdb_7_4-2011-12-13-branchpoint:1.30
	gdb_7_3_1-2011-09-04-release:1.27
	gdb_7_3-2011-07-26-release:1.27
	gdb_7_3-branch:1.27.0.2
	gdb_7_3-2011-04-01-branchpoint:1.27
	gdb_7_2-2010-09-02-release:1.23
	gdb_7_2-branch:1.23.0.2
	gdb_7_2-2010-07-07-branchpoint:1.23
	gdb_7_1-2010-03-18-release:1.15
	gdb_7_1-branch:1.15.0.2
	gdb_7_1-2010-02-18-branchpoint:1.15
	gdb_7_0_1-2009-12-22-release:1.14
	gdb_7_0-2009-10-06-release:1.14
	gdb_7_0-branch:1.14.0.4
	gdb_7_0-2009-09-16-branchpoint:1.14
	arc-sim-20090309:1.11
	msnyder-checkpoint-072509-branch:1.14.0.2
	msnyder-checkpoint-072509-branchpoint:1.14
	arc-insight_6_8-branch:1.11.0.14
	arc-insight_6_8-branchpoint:1.11
	insight_6_8-branch:1.11.0.12
	insight_6_8-branchpoint:1.11
	reverse-20081226-branch:1.12.0.2
	reverse-20081226-branchpoint:1.12
	multiprocess-20081120-branch:1.11.0.10
	multiprocess-20081120-branchpoint:1.11
	reverse-20080930-branch:1.11.0.8
	reverse-20080930-branchpoint:1.11
	reverse-20080717-branch:1.11.0.6
	reverse-20080717-branchpoint:1.11
	msnyder-reverse-20080609-branch:1.11.0.4
	msnyder-reverse-20080609-branchpoint:1.11
	drow-reverse-20070409-branch:1.7.0.2
	drow-reverse-20070409-branchpoint:1.7
	gdb_6_8-2008-03-27-release:1.11
	gdb_6_8-branch:1.11.0.2
	gdb_6_8-2008-02-26-branchpoint:1.11
	gdb_6_7_1-2007-10-29-release:1.9
	gdb_6_7-2007-10-10-release:1.9
	gdb_6_7-branch:1.9.0.2
	gdb_6_7-2007-09-07-branchpoint:1.9
	insight_6_6-20070208-release:1.5
	gdb_6_6-2006-12-18-release:1.5
	gdb_6_6-branch:1.5.0.18
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb-csl-symbian-6_4_50_20060226-12:1.5
	gdb-csl-sourcerygxx-3_4_4-25:1.4
	nickrob-async-20060828-mergepoint:1.5
	gdb-csl-symbian-6_4_50_20060226-11:1.5
	gdb-csl-sourcerygxx-4_1-17:1.5
	gdb-csl-20060226-branch-local-2:1.5
	gdb-csl-sourcerygxx-4_1-14:1.5
	gdb-csl-sourcerygxx-4_1-13:1.5
	gdb-csl-sourcerygxx-4_1-12:1.5
	gdb-csl-sourcerygxx-3_4_4-21:1.5
	gdb_6_5-20060621-release:1.5
	gdb-csl-sourcerygxx-4_1-9:1.5
	gdb-csl-sourcerygxx-4_1-8:1.5
	gdb-csl-sourcerygxx-4_1-7:1.5
	gdb-csl-arm-2006q1-6:1.5
	gdb-csl-sourcerygxx-4_1-6:1.5
	gdb-csl-symbian-6_4_50_20060226-10:1.5
	gdb-csl-symbian-6_4_50_20060226-9:1.5
	gdb-csl-symbian-6_4_50_20060226-8:1.5
	gdb-csl-coldfire-4_1-11:1.5
	gdb-csl-sourcerygxx-3_4_4-19:1.5
	gdb-csl-coldfire-4_1-10:1.5
	gdb_6_5-branch:1.5.0.16
	gdb_6_5-2006-05-14-branchpoint:1.5
	gdb-csl-sourcerygxx-4_1-5:1.5
	nickrob-async-20060513-branch:1.5.0.14
	nickrob-async-20060513-branchpoint:1.5
	gdb-csl-sourcerygxx-4_1-4:1.5
	msnyder-reverse-20060502-branch:1.5.0.12
	msnyder-reverse-20060502-branchpoint:1.5
	gdb-csl-morpho-4_1-4:1.5
	gdb-csl-sourcerygxx-3_4_4-17:1.5
	readline_5_1-import-branch:1.5.0.10
	readline_5_1-import-branchpoint:1.5
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.5
	gdb-csl-symbian-20060226-branch:1.5.0.8
	gdb-csl-symbian-20060226-branchpoint:1.5
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.5
	msnyder-reverse-20060331-branch:1.5.0.6
	msnyder-reverse-20060331-branchpoint:1.5
	gdb-csl-available-20060303-branch:1.5.0.4
	gdb-csl-available-20060303-branchpoint:1.5
	gdb-csl-20060226-branch:1.5.0.2
	gdb-csl-20060226-branchpoint:1.5
	gdb_6_4-20051202-release:1.4
	msnyder-fork-checkpoint-branch:1.4.0.8
	msnyder-fork-checkpoint-branchpoint:1.4
	gdb-csl-gxxpro-6_3-branch:1.4.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.4
	gdb_6_4-branch:1.4.0.4
	gdb_6_4-2005-11-01-branchpoint:1.4
	gdb-csl-arm-20051020-branch:1.4.0.2
	gdb-csl-arm-20051020-branchpoint:1.4
	msnyder-tracepoint-checkpoint-branch:1.3.0.28
	msnyder-tracepoint-checkpoint-branchpoint:1.3
	gdb-csl-arm-20050325-2005-q1b:1.3
	gdb-csl-arm-20050325-2005-q1a:1.3
	csl-arm-20050325-branch:1.3.0.26
	csl-arm-20050325-branchpoint:1.3
	gdb-post-i18n-errorwarning-20050211:1.3
	gdb-pre-i18n-errorwarning-20050211:1.3
	gdb_6_3-20041109-release:1.3
	gdb_6_3-branch:1.3.0.22
	gdb_6_3-20041019-branchpoint:1.3
	drow_intercu-merge-20040921:1.3
	drow_intercu-merge-20040915:1.3
	jimb-gdb_6_2-e500-branch:1.3.0.24
	jimb-gdb_6_2-e500-branchpoint:1.3
	gdb_6_2-20040730-release:1.3
	gdb_6_2-branch:1.3.0.20
	gdb_6_2-2004-07-10-gmt-branchpoint:1.3
	gdb_6_1_1-20040616-release:1.3
	gdb_6_1-2004-04-05-release:1.3
	drow_intercu-merge-20040402:1.3
	drow_intercu-merge-20040327:1.3
	ezannoni_pie-20040323-branch:1.3.0.18
	ezannoni_pie-20040323-branchpoint:1.3
	cagney_tramp-20040321-mergepoint:1.3
	cagney_tramp-20040309-branch:1.3.0.16
	cagney_tramp-20040309-branchpoint:1.3
	gdb_6_1-branch:1.3.0.14
	gdb_6_1-2004-03-01-gmt-branchpoint:1.3
	drow_intercu-20040221-branch:1.3.0.12
	drow_intercu-20040221-branchpoint:1.3
	cagney_bfdfile-20040213-branch:1.3.0.10
	cagney_bfdfile-20040213-branchpoint:1.3
	drow-cplus-merge-20040208:1.3
	carlton_dictionary-20040126-merge:1.3
	cagney_bigcore-20040122-branch:1.3.0.8
	cagney_bigcore-20040122-branchpoint:1.3
	drow-cplus-merge-20040113:1.3
	drow-cplus-merge-20031224:1.3
	drow-cplus-merge-20031220:1.3
	carlton_dictionary-20031215-merge:1.3
	drow-cplus-merge-20031214:1.3
	carlton-dictionary-20031111-merge:1.3
	gdb_6_0-2003-10-04-release:1.2
	kettenis_sparc-20030918-branch:1.3.0.6
	kettenis_sparc-20030918-branchpoint:1.3
	carlton_dictionary-20030917-merge:1.3
	ezannoni_pie-20030916-branchpoint:1.3
	ezannoni_pie-20030916-branch:1.3.0.4
	cagney_x86i386-20030821-branch:1.3.0.2
	cagney_x86i386-20030821-branchpoint:1.3
	carlton_dictionary-20030805-merge:1.3
	carlton_dictionary-20030627-merge:1.2
	gdb_6_0-branch:1.2.0.48
	gdb_6_0-2003-06-23-branchpoint:1.2
	jimb-ppc64-linux-20030613-branch:1.2.0.46
	jimb-ppc64-linux-20030613-branchpoint:1.2
	cagney_convert-20030606-branch:1.2.0.44
	cagney_convert-20030606-branchpoint:1.2
	cagney_writestrings-20030508-branch:1.2.0.42
	cagney_writestrings-20030508-branchpoint:1.2
	jimb-ppc64-linux-20030528-branch:1.2.0.40
	jimb-ppc64-linux-20030528-branchpoint:1.2
	carlton_dictionary-20030523-merge:1.2
	cagney_fileio-20030521-branch:1.2.0.38
	cagney_fileio-20030521-branchpoint:1.2
	kettenis_i386newframe-20030517-mergepoint:1.2
	jimb-ppc64-linux-20030509-branch:1.2.0.36
	jimb-ppc64-linux-20030509-branchpoint:1.2
	kettenis_i386newframe-20030504-mergepoint:1.2
	carlton_dictionary-20030430-merge:1.2
	kettenis_i386newframe-20030419-branch:1.2.0.34
	kettenis_i386newframe-20030419-branchpoint:1.2
	carlton_dictionary-20030416-merge:1.2
	cagney_frameaddr-20030409-mergepoint:1.2
	kettenis_i386newframe-20030406-branch:1.2.0.32
	kettenis_i386newframe-20030406-branchpoint:1.2
	cagney_frameaddr-20030403-branchpoint:1.2
	cagney_frameaddr-20030403-branch:1.2.0.30
	cagney_framebase-20030330-mergepoint:1.2
	cagney_framebase-20030326-branch:1.2.0.28
	cagney_framebase-20030326-branchpoint:1.2
	cagney_lazyid-20030317-branch:1.2.0.26
	cagney_lazyid-20030317-branchpoint:1.2
	kettenis-i386newframe-20030316-mergepoint:1.2
	offbyone-20030313-branch:1.2.0.24
	offbyone-20030313-branchpoint:1.2
	kettenis-i386newframe-20030308-branch:1.2.0.22
	kettenis-i386newframe-20030308-branchpoint:1.2
	carlton_dictionary-20030305-merge:1.2
	cagney_offbyone-20030303-branch:1.2.0.20
	cagney_offbyone-20030303-branchpoint:1.2
	carlton_dictionary-20030207-merge:1.2
	interps-20030203-mergepoint:1.2
	interps-20030202-branch:1.2.0.18
	interps-20030202-branchpoint:1.2
	cagney-unwind-20030108-branch:1.2.0.16
	cagney-unwind-20030108-branchpoint:1.2
	carlton_dictionary-20021223-merge:1.2
	gdb_5_3-2002-12-12-release:1.2
	carlton_dictionary-20021115-merge:1.2
	kseitz_interps-20021105-merge:1.2
	kseitz_interps-20021103-merge:1.2
	drow-cplus-merge-20021020:1.2
	drow-cplus-merge-20021025:1.2
	carlton_dictionary-20021025-merge:1.2
	carlton_dictionary-20021011-merge:1.2
	drow-cplus-branch:1.2.0.14
	drow-cplus-branchpoint:1.2
	kseitz_interps-20020930-merge:1.2
	carlton_dictionary-20020927-merge:1.2
	carlton_dictionary-branch:1.2.0.12
	carlton_dictionary-20020920-branchpoint:1.2
	gdb_5_3-branch:1.2.0.10
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.8
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.6
	readline_4_3-import-branchpoint:1.2
	kseitz_interps-20020528-branch:1.2.0.4
	kseitz_interps-20020528-branchpoint:1.2
	cagney_regbuf-20020515-branch:1.2.0.2
	cagney_regbuf-20020515-branchpoint:1.2
	jimb-macro-020506-branch:1.1.0.2
	jimb-macro-020506-branchpoint:1.1;
locks; strict;
comment	@ * @;


1.38
date	2013.01.18.06.40.57;	author qiyao;	state Exp;
branches;
next	1.37;

1.37
date	2013.01.01.06.33.00;	author brobecke;	state Exp;
branches;
next	1.36;

1.36
date	2012.07.02.17.37.35;	author devans;	state Exp;
branches;
next	1.35;

1.35
date	2012.07.02.17.11.36;	author devans;	state Exp;
branches;
next	1.34;

1.34
date	2012.07.02.15.29.38;	author shebs;	state Exp;
branches;
next	1.33;

1.33
date	2012.02.25.19.54.50;	author luisgpm;	state Exp;
branches;
next	1.32;

1.32
date	2012.02.24.15.15.56;	author luisgpm;	state Exp;
branches;
next	1.31;

1.31
date	2012.01.04.08.17.23;	author brobecke;	state Exp;
branches;
next	1.30;

1.30
date	2011.12.06.23.29.47;	author jkratoch;	state Exp;
branches
	1.30.2.1;
next	1.29;

1.29
date	2011.11.14.14.38.41;	author qiyao;	state Exp;
branches;
next	1.28;

1.28
date	2011.10.31.12.55.25;	author palves;	state Exp;
branches;
next	1.27;

1.27
date	2011.01.06.00.14.09;	author msnyder;	state Exp;
branches;
next	1.26;

1.26
date	2011.01.01.15.33.24;	author brobecke;	state Exp;
branches;
next	1.25;

1.25
date	2010.09.01.17.29.32;	author gdbadmin;	state Exp;
branches;
next	1.24;

1.24
date	2010.08.26.16.47.05;	author palves;	state Exp;
branches;
next	1.23;

1.23
date	2010.07.01.10.36.11;	author palves;	state Exp;
branches;
next	1.22;

1.22
date	2010.06.01.13.20.52;	author palves;	state Exp;
branches;
next	1.21;

1.21
date	2010.05.02.00.47.34;	author palves;	state Exp;
branches;
next	1.20;

1.20
date	2010.04.09.03.40.00;	author palves;	state Exp;
branches;
next	1.19;

1.19
date	2010.04.01.14.26.53;	author palves;	state Exp;
branches;
next	1.18;

1.18
date	2010.04.01.14.25.34;	author palves;	state Exp;
branches;
next	1.17;

1.17
date	2010.03.24.21.11.25;	author palves;	state Exp;
branches;
next	1.16;

1.16
date	2010.03.24.00.05.03;	author palves;	state Exp;
branches;
next	1.15;

1.15
date	2010.01.01.07.31.49;	author brobecke;	state Exp;
branches;
next	1.14;

1.14
date	2009.04.01.22.50.24;	author palves;	state Exp;
branches;
next	1.13;

1.13
date	2009.01.03.05.57.57;	author brobecke;	state Exp;
branches;
next	1.12;

1.12
date	2008.12.14.20.51.04;	author devans;	state Exp;
branches;
next	1.11;

1.11
date	2008.01.01.22.53.14;	author drow;	state Exp;
branches
	1.11.10.1;
next	1.10;

1.10
date	2007.12.18.21.58.01;	author drow;	state Exp;
branches;
next	1.9;

1.9
date	2007.08.23.18.08.48;	author brobecke;	state Exp;
branches;
next	1.8;

1.8
date	2007.07.02.15.35.36;	author drow;	state Exp;
branches;
next	1.7;

1.7
date	2007.03.29.01.06.47;	author palves;	state Exp;
branches;
next	1.6;

1.6
date	2007.01.09.17.59.08;	author drow;	state Exp;
branches;
next	1.5;

1.5
date	2005.12.23.18.11.55;	author eliz;	state Exp;
branches;
next	1.4;

1.4
date	2005.06.13.01.59.22;	author drow;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.08.18.51.44;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	2002.05.15.03.36.13;	author drow;	state Exp;
branches
	1.2.12.1
	1.2.14.1;
next	1.1;

1.1
date	2002.04.20.17.04.09;	author drow;	state Exp;
branches;
next	;

1.30.2.1
date	2012.01.06.04.43.37;	author brobecke;	state Exp;
branches;
next	;

1.11.10.1
date	2008.11.25.20.47.19;	author palves;	state Exp;
branches;
next	;

1.2.12.1
date	2003.08.05.17.13.21;	author carlton;	state Exp;
branches;
next	;

1.2.14.1
date	2003.12.14.20.27.44;	author drow;	state Exp;
branches;
next	;


desc
@@


1.38
log
@gdb/gdbserver:

	* ax.h (struct eval_agent_expr_context): New.
	(gdb_eval_agent_expr): Update declaration.
	* ax.c (gdb_eval_agent_expr): Remove argument REGCACHE and
	TFRAME.  Add new argument CTX.
	* server.h (struct eval_agent_expr_context): Declare.
	(agent_mem_read, agent_tsv_read): Update declaration.
	(agent_mem_read_string): Likewise.
	* tracepoint.c (eval_tracepoint_agent_expr): Remove.
	(add_traceframe_block): Add new argument TPOINT.
	Increase TPOINT->traceframe_usage.
	(do_action_at_tracepoint): Call gdb_eval_agent_expr instead of
	eval_tracepoint_agent_expr.
	(condition_true_at_tracepoint): Likewise.
	(agent_mem_read): Remove argument TFRAME.  Add argument CTX.
	(agent_mem_read_string, agent_tsv_read): Likewise.
	Callers update.

gdb/testsuite:

	* gdb.trace/infotrace.exp: Check 'traceframe usage' in the
	output of 'info tracepoints'.
	* gdb.trace/disconnected-tracing.exp (disconnected_tracing):
	Likewise.
	* gdb.trace/tstatus.exp (run_trace_experiment): Likewise.
	* gdb.trace/disconnected-tracing.c (struct foo): New.
@
text
@/* Memory breakpoint operations for the remote server for GDB.
   Copyright (C) 2002-2013 Free Software Foundation, Inc.

   Contributed by MontaVista Software.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "server.h"
#include "regcache.h"
#include "ax.h"
#include <stdint.h>

const unsigned char *breakpoint_data;
int breakpoint_len;

#define MAX_BREAKPOINT_LEN 8

/* GDB will never try to install multiple breakpoints at the same
   address.  But, we need to keep track of internal breakpoints too,
   and so we do need to be able to install multiple breakpoints at the
   same address transparently.  We keep track of two different, and
   closely related structures.  A raw breakpoint, which manages the
   low level, close to the metal aspect of a breakpoint.  It holds the
   breakpoint address, and a buffer holding a copy of the instructions
   that would be in memory had not been a breakpoint there (we call
   that the shadow memory of the breakpoint).  We occasionally need to
   temporarilly uninsert a breakpoint without the client knowing about
   it (e.g., to step over an internal breakpoint), so we keep an
   `inserted' state associated with this low level breakpoint
   structure.  There can only be one such object for a given address.
   Then, we have (a bit higher level) breakpoints.  This structure
   holds a callback to be called whenever a breakpoint is hit, a
   high-level type, and a link to a low level raw breakpoint.  There
   can be many high-level breakpoints at the same address, and all of
   them will point to the same raw breakpoint, which is reference
   counted.  */

/* The low level, physical, raw breakpoint.  */
struct raw_breakpoint
{
  struct raw_breakpoint *next;

  /* A reference count.  Each high level breakpoint referencing this
     raw breakpoint accounts for one reference.  */
  int refcount;

  /* The breakpoint's insertion address.  There can only be one raw
     breakpoint for a given PC.  */
  CORE_ADDR pc;

  /* The breakpoint's shadow memory.  */
  unsigned char old_data[MAX_BREAKPOINT_LEN];

  /* Non-zero if this breakpoint is currently inserted in the
     inferior.  */
  int inserted;

  /* Non-zero if this breakpoint is currently disabled because we no
     longer detect it as inserted.  */
  int shlib_disabled;
};

/* The type of a breakpoint.  */
enum bkpt_type
  {
    /* A GDB breakpoint, requested with a Z0 packet.  */
    gdb_breakpoint,

    /* A basic-software-single-step breakpoint.  */
    reinsert_breakpoint,

    /* Any other breakpoint type that doesn't require specific
       treatment goes here.  E.g., an event breakpoint.  */
    other_breakpoint,
  };

struct point_cond_list
{
  /* Pointer to the agent expression that is the breakpoint's
     conditional.  */
  struct agent_expr *cond;

  /* Pointer to the next condition.  */
  struct point_cond_list *next;
};

struct point_command_list
{
  /* Pointer to the agent expression that is the breakpoint's
     commands.  */
  struct agent_expr *cmd;

  /* Flag that is true if this command should run even while GDB is
     disconnected.  */
  int persistence;

  /* Pointer to the next command.  */
  struct point_command_list *next;
};

/* A high level (in gdbserver's perspective) breakpoint.  */
struct breakpoint
{
  struct breakpoint *next;

  /* The breakpoint's type.  */
  enum bkpt_type type;

  /* Pointer to the condition list that should be evaluated on
     the target or NULL if the breakpoint is unconditional or
     if GDB doesn't want us to evaluate the conditionals on the
     target's side.  */
  struct point_cond_list *cond_list;

  /* Point to the list of commands to run when this is hit.  */
  struct point_command_list *command_list;

  /* Link to this breakpoint's raw breakpoint.  This is always
     non-NULL.  */
  struct raw_breakpoint *raw;

  /* Function to call when we hit this breakpoint.  If it returns 1,
     the breakpoint shall be deleted; 0 or if this callback is NULL,
     it will be left inserted.  */
  int (*handler) (CORE_ADDR);
};

int
any_persistent_commands ()
{
  struct process_info *proc = current_process ();
  struct breakpoint *bp;
  struct point_command_list *cl;

  for (bp = proc->breakpoints; bp != NULL; bp = bp->next)
    {
      for (cl = bp->command_list; cl != NULL; cl = cl->next)
	if (cl->persistence)
	  return 1;
    }

  return 0;
}

static struct raw_breakpoint *
find_raw_breakpoint_at (CORE_ADDR where)
{
  struct process_info *proc = current_process ();
  struct raw_breakpoint *bp;

  for (bp = proc->raw_breakpoints; bp != NULL; bp = bp->next)
    if (bp->pc == where)
      return bp;

  return NULL;
}

static struct raw_breakpoint *
set_raw_breakpoint_at (CORE_ADDR where)
{
  struct process_info *proc = current_process ();
  struct raw_breakpoint *bp;
  int err;
  unsigned char buf[MAX_BREAKPOINT_LEN];

  if (breakpoint_data == NULL)
    error ("Target does not support breakpoints.");

  bp = find_raw_breakpoint_at (where);
  if (bp != NULL)
    {
      bp->refcount++;
      return bp;
    }

  bp = xcalloc (1, sizeof (*bp));
  bp->pc = where;
  bp->refcount = 1;

  /* Note that there can be fast tracepoint jumps installed in the
     same memory range, so to get at the original memory, we need to
     use read_inferior_memory, which masks those out.  */
  err = read_inferior_memory (where, buf, breakpoint_len);
  if (err != 0)
    {
      if (debug_threads)
	fprintf (stderr,
		 "Failed to read shadow memory of"
		 " breakpoint at 0x%s (%s).\n",
		 paddress (where), strerror (err));
      free (bp);
      return NULL;
    }
  memcpy (bp->old_data, buf, breakpoint_len);

  err = (*the_target->write_memory) (where, breakpoint_data,
				     breakpoint_len);
  if (err != 0)
    {
      if (debug_threads)
	fprintf (stderr,
		 "Failed to insert breakpoint at 0x%s (%s).\n",
		 paddress (where), strerror (err));
      free (bp);
      return NULL;
    }

  /* Link the breakpoint in.  */
  bp->inserted = 1;
  bp->next = proc->raw_breakpoints;
  proc->raw_breakpoints = bp;
  return bp;
}

/* Notice that breakpoint traps are always installed on top of fast
   tracepoint jumps.  This is even if the fast tracepoint is installed
   at a later time compared to when the breakpoint was installed.
   This means that a stopping breakpoint or tracepoint has higher
   "priority".  In turn, this allows having fast and slow tracepoints
   (and breakpoints) at the same address behave correctly.  */


/* A fast tracepoint jump.  */

struct fast_tracepoint_jump
{
  struct fast_tracepoint_jump *next;

  /* A reference count.  GDB can install more than one fast tracepoint
     at the same address (each with its own action list, for
     example).  */
  int refcount;

  /* The fast tracepoint's insertion address.  There can only be one
     of these for a given PC.  */
  CORE_ADDR pc;

  /* Non-zero if this fast tracepoint jump is currently inserted in
     the inferior.  */
  int inserted;

  /* The length of the jump instruction.  */
  int length;

  /* A poor-man's flexible array member, holding both the jump
     instruction to insert, and a copy of the instruction that would
     be in memory had not been a jump there (the shadow memory of the
     tracepoint jump).  */
  unsigned char insn_and_shadow[0];
};

/* Fast tracepoint FP's jump instruction to insert.  */
#define fast_tracepoint_jump_insn(fp) \
  ((fp)->insn_and_shadow + 0)

/* The shadow memory of fast tracepoint jump FP.  */
#define fast_tracepoint_jump_shadow(fp) \
  ((fp)->insn_and_shadow + (fp)->length)


/* Return the fast tracepoint jump set at WHERE.  */

static struct fast_tracepoint_jump *
find_fast_tracepoint_jump_at (CORE_ADDR where)
{
  struct process_info *proc = current_process ();
  struct fast_tracepoint_jump *jp;

  for (jp = proc->fast_tracepoint_jumps; jp != NULL; jp = jp->next)
    if (jp->pc == where)
      return jp;

  return NULL;
}

int
fast_tracepoint_jump_here (CORE_ADDR where)
{
  struct fast_tracepoint_jump *jp = find_fast_tracepoint_jump_at (where);

  return (jp != NULL);
}

int
delete_fast_tracepoint_jump (struct fast_tracepoint_jump *todel)
{
  struct fast_tracepoint_jump *bp, **bp_link;
  int ret;
  struct process_info *proc = current_process ();

  bp = proc->fast_tracepoint_jumps;
  bp_link = &proc->fast_tracepoint_jumps;

  while (bp)
    {
      if (bp == todel)
	{
	  if (--bp->refcount == 0)
	    {
	      struct fast_tracepoint_jump *prev_bp_link = *bp_link;
	      unsigned char *buf;

	      /* Unlink it.  */
	      *bp_link = bp->next;

	      /* Since there can be breakpoints inserted in the same
		 address range, we use `write_inferior_memory', which
		 takes care of layering breakpoints on top of fast
		 tracepoints, and on top of the buffer we pass it.
		 This works because we've already unlinked the fast
		 tracepoint jump above.  Also note that we need to
		 pass the current shadow contents, because
		 write_inferior_memory updates any shadow memory with
		 what we pass here, and we want that to be a nop.  */
	      buf = alloca (bp->length);
	      memcpy (buf, fast_tracepoint_jump_shadow (bp), bp->length);
	      ret = write_inferior_memory (bp->pc, buf, bp->length);
	      if (ret != 0)
		{
		  /* Something went wrong, relink the jump.  */
		  *bp_link = prev_bp_link;

		  if (debug_threads)
		    fprintf (stderr,
			     "Failed to uninsert fast tracepoint jump "
			     "at 0x%s (%s) while deleting it.\n",
			     paddress (bp->pc), strerror (ret));
		  return ret;
		}

	      free (bp);
	    }

	  return 0;
	}
      else
	{
	  bp_link = &bp->next;
	  bp = *bp_link;
	}
    }

  warning ("Could not find fast tracepoint jump in list.");
  return ENOENT;
}

void
inc_ref_fast_tracepoint_jump (struct fast_tracepoint_jump *jp)
{
  jp->refcount++;
}

struct fast_tracepoint_jump *
set_fast_tracepoint_jump (CORE_ADDR where,
			  unsigned char *insn, ULONGEST length)
{
  struct process_info *proc = current_process ();
  struct fast_tracepoint_jump *jp;
  int err;
  unsigned char *buf;

  /* We refcount fast tracepoint jumps.  Check if we already know
     about a jump at this address.  */
  jp = find_fast_tracepoint_jump_at (where);
  if (jp != NULL)
    {
      jp->refcount++;
      return jp;
    }

  /* We don't, so create a new object.  Double the length, because the
     flexible array member holds both the jump insn, and the
     shadow.  */
  jp = xcalloc (1, sizeof (*jp) + (length * 2));
  jp->pc = where;
  jp->length = length;
  memcpy (fast_tracepoint_jump_insn (jp), insn, length);
  jp->refcount = 1;
  buf = alloca (length);

  /* Note that there can be trap breakpoints inserted in the same
     address range.  To access the original memory contents, we use
     `read_inferior_memory', which masks out breakpoints.  */
  err = read_inferior_memory (where, buf, length);
  if (err != 0)
    {
      if (debug_threads)
	fprintf (stderr,
		 "Failed to read shadow memory of"
		 " fast tracepoint at 0x%s (%s).\n",
		 paddress (where), strerror (err));
      free (jp);
      return NULL;
    }
  memcpy (fast_tracepoint_jump_shadow (jp), buf, length);

  /* Link the jump in.  */
  jp->inserted = 1;
  jp->next = proc->fast_tracepoint_jumps;
  proc->fast_tracepoint_jumps = jp;

  /* Since there can be trap breakpoints inserted in the same address
     range, we use use `write_inferior_memory', which takes care of
     layering breakpoints on top of fast tracepoints, on top of the
     buffer we pass it.  This works because we've already linked in
     the fast tracepoint jump above.  Also note that we need to pass
     the current shadow contents, because write_inferior_memory
     updates any shadow memory with what we pass here, and we want
     that to be a nop.  */
  err = write_inferior_memory (where, buf, length);
  if (err != 0)
    {
      if (debug_threads)
	fprintf (stderr,
		 "Failed to insert fast tracepoint jump at 0x%s (%s).\n",
		 paddress (where), strerror (err));

      /* Unlink it.  */
      proc->fast_tracepoint_jumps = jp->next;
      free (jp);

      return NULL;
    }

  return jp;
}

void
uninsert_fast_tracepoint_jumps_at (CORE_ADDR pc)
{
  struct fast_tracepoint_jump *jp;
  int err;

  jp = find_fast_tracepoint_jump_at (pc);
  if (jp == NULL)
    {
      /* This can happen when we remove all breakpoints while handling
	 a step-over.  */
      if (debug_threads)
	fprintf (stderr,
		 "Could not find fast tracepoint jump at 0x%s "
		 "in list (uninserting).\n",
		 paddress (pc));
      return;
    }

  if (jp->inserted)
    {
      unsigned char *buf;

      jp->inserted = 0;

      /* Since there can be trap breakpoints inserted in the same
	 address range, we use use `write_inferior_memory', which
	 takes care of layering breakpoints on top of fast
	 tracepoints, and on top of the buffer we pass it.  This works
	 because we've already marked the fast tracepoint fast
	 tracepoint jump uninserted above.  Also note that we need to
	 pass the current shadow contents, because
	 write_inferior_memory updates any shadow memory with what we
	 pass here, and we want that to be a nop.  */
      buf = alloca (jp->length);
      memcpy (buf, fast_tracepoint_jump_shadow (jp), jp->length);
      err = write_inferior_memory (jp->pc, buf, jp->length);
      if (err != 0)
	{
	  jp->inserted = 1;

	  if (debug_threads)
	    fprintf (stderr,
		     "Failed to uninsert fast tracepoint jump at 0x%s (%s).\n",
		     paddress (pc), strerror (err));
	}
    }
}

void
reinsert_fast_tracepoint_jumps_at (CORE_ADDR where)
{
  struct fast_tracepoint_jump *jp;
  int err;
  unsigned char *buf;

  jp = find_fast_tracepoint_jump_at (where);
  if (jp == NULL)
    {
      /* This can happen when we remove breakpoints when a tracepoint
	 hit causes a tracing stop, while handling a step-over.  */
      if (debug_threads)
	fprintf (stderr,
		 "Could not find fast tracepoint jump at 0x%s "
		 "in list (reinserting).\n",
		 paddress (where));
      return;
    }

  if (jp->inserted)
    error ("Jump already inserted at reinsert time.");

  jp->inserted = 1;

  /* Since there can be trap breakpoints inserted in the same address
     range, we use `write_inferior_memory', which takes care of
     layering breakpoints on top of fast tracepoints, and on top of
     the buffer we pass it.  This works because we've already marked
     the fast tracepoint jump inserted above.  Also note that we need
     to pass the current shadow contents, because
     write_inferior_memory updates any shadow memory with what we pass
     here, and we want that to be a nop.  */
  buf = alloca (jp->length);
  memcpy (buf, fast_tracepoint_jump_shadow (jp), jp->length);
  err = write_inferior_memory (where, buf, jp->length);
  if (err != 0)
    {
      jp->inserted = 0;

      if (debug_threads)
	fprintf (stderr,
		 "Failed to reinsert fast tracepoint jump at 0x%s (%s).\n",
		 paddress (where), strerror (err));
    }
}

struct breakpoint *
set_breakpoint_at (CORE_ADDR where, int (*handler) (CORE_ADDR))
{
  struct process_info *proc = current_process ();
  struct breakpoint *bp;
  struct raw_breakpoint *raw;

  raw = set_raw_breakpoint_at (where);

  if (raw == NULL)
    {
      /* warn? */
      return NULL;
    }

  bp = xcalloc (1, sizeof (struct breakpoint));
  bp->type = other_breakpoint;

  bp->raw = raw;
  bp->handler = handler;

  bp->next = proc->breakpoints;
  proc->breakpoints = bp;

  return bp;
}

static int
delete_raw_breakpoint (struct process_info *proc, struct raw_breakpoint *todel)
{
  struct raw_breakpoint *bp, **bp_link;
  int ret;

  bp = proc->raw_breakpoints;
  bp_link = &proc->raw_breakpoints;

  while (bp)
    {
      if (bp == todel)
	{
	  if (bp->inserted)
	    {
	      struct raw_breakpoint *prev_bp_link = *bp_link;
	      unsigned char buf[MAX_BREAKPOINT_LEN];

	      *bp_link = bp->next;

	      /* Since there can be trap breakpoints inserted in the
		 same address range, we use `write_inferior_memory',
		 which takes care of layering breakpoints on top of
		 fast tracepoints, and on top of the buffer we pass
		 it.  This works because we've already unlinked the
		 fast tracepoint jump above.  Also note that we need
		 to pass the current shadow contents, because
		 write_inferior_memory updates any shadow memory with
		 what we pass here, and we want that to be a nop.  */
	      memcpy (buf, bp->old_data, breakpoint_len);
	      ret = write_inferior_memory (bp->pc, buf, breakpoint_len);
	      if (ret != 0)
		{
		  /* Something went wrong, relink the breakpoint.  */
		  *bp_link = prev_bp_link;

		  if (debug_threads)
		    fprintf (stderr,
			     "Failed to uninsert raw breakpoint "
			     "at 0x%s (%s) while deleting it.\n",
			     paddress (bp->pc), strerror (ret));
		  return ret;
		}

	    }
	  else
	    *bp_link = bp->next;

	  free (bp);
	  return 0;
	}
      else
	{
	  bp_link = &bp->next;
	  bp = *bp_link;
	}
    }

  warning ("Could not find raw breakpoint in list.");
  return ENOENT;
}

static int
release_breakpoint (struct process_info *proc, struct breakpoint *bp)
{
  int newrefcount;
  int ret;

  newrefcount = bp->raw->refcount - 1;
  if (newrefcount == 0)
    {
      ret = delete_raw_breakpoint (proc, bp->raw);
      if (ret != 0)
	return ret;
    }
  else
    bp->raw->refcount = newrefcount;

  free (bp);

  return 0;
}

static int
delete_breakpoint_1 (struct process_info *proc, struct breakpoint *todel)
{
  struct breakpoint *bp, **bp_link;
  int err;

  bp = proc->breakpoints;
  bp_link = &proc->breakpoints;

  while (bp)
    {
      if (bp == todel)
	{
	  *bp_link = bp->next;

	  err = release_breakpoint (proc, bp);
	  if (err != 0)
	    return err;

	  bp = *bp_link;
	  return 0;
	}
      else
	{
	  bp_link = &bp->next;
	  bp = *bp_link;
	}
    }

  warning ("Could not find breakpoint in list.");
  return ENOENT;
}

int
delete_breakpoint (struct breakpoint *todel)
{
  struct process_info *proc = current_process ();
  return delete_breakpoint_1 (proc, todel);
}

struct breakpoint *
find_gdb_breakpoint_at (CORE_ADDR where)
{
  struct process_info *proc = current_process ();
  struct breakpoint *bp;

  for (bp = proc->breakpoints; bp != NULL; bp = bp->next)
    if (bp->type == gdb_breakpoint && bp->raw->pc == where)
      return bp;

  return NULL;
}

int
set_gdb_breakpoint_at (CORE_ADDR where)
{
  struct breakpoint *bp;

  if (breakpoint_data == NULL)
    return 1;

  /* If we see GDB inserting a second breakpoint at the same address,
     then the first breakpoint must have disappeared due to a shared
     library unload.  On targets where the shared libraries are
     handled by userspace, like SVR4, for example, GDBserver can't
     tell if a library was loaded or unloaded.  Since we refcount
     breakpoints, if we didn't do this, we'd just increase the
     refcount of the previous breakpoint at this address, but the trap
     was not planted in the inferior anymore, thus the breakpoint
     would never be hit.  */
  bp = find_gdb_breakpoint_at (where);
  if (bp != NULL)
    {
      delete_gdb_breakpoint_at (where);

      /* Might as well validate all other breakpoints.  */
      validate_breakpoints ();
    }

  bp = set_breakpoint_at (where, NULL);
  if (bp == NULL)
    return -1;

  bp->type = gdb_breakpoint;
  return 0;
}

int
delete_gdb_breakpoint_at (CORE_ADDR addr)
{
  struct breakpoint *bp;
  int err;

  if (breakpoint_data == NULL)
    return 1;

  bp = find_gdb_breakpoint_at (addr);
  if (bp == NULL)
    return -1;

  /* Before deleting the breakpoint, make sure to free
     its condition list.  */
  clear_gdb_breakpoint_conditions (addr);
  err = delete_breakpoint (bp);
  if (err)
    return -1;

  return 0;
}

/* Clear all conditions associated with this breakpoint address.  */

void
clear_gdb_breakpoint_conditions (CORE_ADDR addr)
{
  struct breakpoint *bp = find_gdb_breakpoint_at (addr);
  struct point_cond_list *cond;

  if (bp == NULL || bp->cond_list == NULL)
    return;

  cond = bp->cond_list;

  while (cond != NULL)
    {
      struct point_cond_list *cond_next;

      cond_next = cond->next;
      free (cond->cond->bytes);
      free (cond->cond);
      free (cond);
      cond = cond_next;
    }

  bp->cond_list = NULL;
}

/* Add condition CONDITION to GDBserver's breakpoint BP.  */

void
add_condition_to_breakpoint (struct breakpoint *bp,
			     struct agent_expr *condition)
{
  struct point_cond_list *new_cond;

  /* Create new condition.  */
  new_cond = xcalloc (1, sizeof (*new_cond));
  new_cond->cond = condition;

  /* Add condition to the list.  */
  new_cond->next = bp->cond_list;
  bp->cond_list = new_cond;
}

/* Add a target-side condition CONDITION to the breakpoint at ADDR.  */

int
add_breakpoint_condition (CORE_ADDR addr, char **condition)
{
  struct breakpoint *bp = find_gdb_breakpoint_at (addr);
  char *actparm = *condition;
  struct agent_expr *cond;

  if (bp == NULL)
    return 1;

  if (condition == NULL)
    return 1;

  cond = gdb_parse_agent_expr (&actparm);

  if (cond == NULL)
    {
      fprintf (stderr, "Condition evaluation failed. "
	       "Assuming unconditional.\n");
      return 0;
    }

  add_condition_to_breakpoint (bp, cond);

  *condition = actparm;

  return 0;
}

/* Evaluate condition (if any) at breakpoint BP.  Return 1 if
   true and 0 otherwise.  */

int
gdb_condition_true_at_breakpoint (CORE_ADDR where)
{
  /* Fetch registers for the current inferior.  */
  struct breakpoint *bp = find_gdb_breakpoint_at (where);
  ULONGEST value = 0;
  struct point_cond_list *cl;
  int err = 0;
  struct eval_agent_expr_context ctx;

  if (bp == NULL)
    return 0;

  /* Check if the breakpoint is unconditional.  If it is,
     the condition always evaluates to TRUE.  */
  if (bp->cond_list == NULL)
    return 1;

  ctx.regcache = get_thread_regcache (current_inferior, 1);
  ctx.tframe = NULL;
  ctx.tpoint = NULL;

  /* Evaluate each condition in the breakpoint's list of conditions.
     Return true if any of the conditions evaluates to TRUE.

     If we failed to evaluate the expression, TRUE is returned.  This
     forces GDB to reevaluate the conditions.  */
  for (cl = bp->cond_list;
       cl && !value && !err; cl = cl->next)
    {
      /* Evaluate the condition.  */
      err = gdb_eval_agent_expr (&ctx, cl->cond, &value);
    }

  if (err)
    return 1;

  return (value != 0);
}

/* Add commands COMMANDS to GDBserver's breakpoint BP.  */

void
add_commands_to_breakpoint (struct breakpoint *bp,
			    struct agent_expr *commands, int persist)
{
  struct point_command_list *new_cmd;

  /* Create new command.  */
  new_cmd = xcalloc (1, sizeof (*new_cmd));
  new_cmd->cmd = commands;
  new_cmd->persistence = persist;

  /* Add commands to the list.  */
  new_cmd->next = bp->command_list;
  bp->command_list = new_cmd;
}

/* Add a target-side command COMMAND to the breakpoint at ADDR.  */

int
add_breakpoint_commands (CORE_ADDR addr, char **command, int persist)
{
  struct breakpoint *bp = find_gdb_breakpoint_at (addr);
  char *actparm = *command;
  struct agent_expr *cmd;

  if (bp == NULL)
    return 1;

  if (command == NULL)
    return 1;

  cmd = gdb_parse_agent_expr (&actparm);

  if (cmd == NULL)
    {
      fprintf (stderr, "Command evaluation failed. "
	       "Disabling.\n");
      return 0;
    }

  add_commands_to_breakpoint (bp, cmd, persist);

  *command = actparm;

  return 0;
}

/* Return true if there are no commands to run at this location,
   which likely means we want to report back to GDB.  */
int
gdb_no_commands_at_breakpoint (CORE_ADDR where)
{
  struct breakpoint *bp = find_gdb_breakpoint_at (where);

  if (bp == NULL)
    return 0;

  if (debug_threads)
    fprintf (stderr, "at 0x%s, bp command_list is 0x%s\n",
	     paddress (where),
	     phex_nz ((uintptr_t) bp->command_list, 0));
  return (bp->command_list == NULL);
}

void
run_breakpoint_commands (CORE_ADDR where)
{
  /* Fetch registers for the current inferior.  */
  struct breakpoint *bp = find_gdb_breakpoint_at (where);
  ULONGEST value = 0;
  struct point_command_list *cl;
  int err = 0;
  struct eval_agent_expr_context ctx;

  if (bp == NULL)
    return;

  ctx.regcache = get_thread_regcache (current_inferior, 1);
  ctx.tframe = NULL;
  ctx.tpoint = NULL;

  for (cl = bp->command_list;
       cl && !value && !err; cl = cl->next)
    {
      /* Run the command.  */
      err = gdb_eval_agent_expr (&ctx, cl->cmd, &value);

      /* If one command has a problem, stop digging the hole deeper.  */
      if (err)
	break;
    }
}

/* Return 1 if there is a breakpoint inserted in address WHERE
   and if its condition, if it exists, is true.  */

int
gdb_breakpoint_here (CORE_ADDR where)
{
  return (find_gdb_breakpoint_at (where) != NULL);
}

void
set_reinsert_breakpoint (CORE_ADDR stop_at)
{
  struct breakpoint *bp;

  bp = set_breakpoint_at (stop_at, NULL);
  bp->type = reinsert_breakpoint;
}

void
delete_reinsert_breakpoints (void)
{
  struct process_info *proc = current_process ();
  struct breakpoint *bp, **bp_link;

  bp = proc->breakpoints;
  bp_link = &proc->breakpoints;

  while (bp)
    {
      if (bp->type == reinsert_breakpoint)
	{
	  *bp_link = bp->next;
	  release_breakpoint (proc, bp);
	  bp = *bp_link;
	}
      else
	{
	  bp_link = &bp->next;
	  bp = *bp_link;
	}
    }
}

static void
uninsert_raw_breakpoint (struct raw_breakpoint *bp)
{
  if (bp->inserted)
    {
      int err;
      unsigned char buf[MAX_BREAKPOINT_LEN];

      bp->inserted = 0;
      /* Since there can be fast tracepoint jumps inserted in the same
	 address range, we use `write_inferior_memory', which takes
	 care of layering breakpoints on top of fast tracepoints, and
	 on top of the buffer we pass it.  This works because we've
	 already unlinked the fast tracepoint jump above.  Also note
	 that we need to pass the current shadow contents, because
	 write_inferior_memory updates any shadow memory with what we
	 pass here, and we want that to be a nop.  */
      memcpy (buf, bp->old_data, breakpoint_len);
      err = write_inferior_memory (bp->pc, buf, breakpoint_len);
      if (err != 0)
	{
	  bp->inserted = 1;

	  if (debug_threads)
	    fprintf (stderr,
		     "Failed to uninsert raw breakpoint at 0x%s (%s).\n",
		     paddress (bp->pc), strerror (err));
	}
    }
}

void
uninsert_breakpoints_at (CORE_ADDR pc)
{
  struct raw_breakpoint *bp;

  bp = find_raw_breakpoint_at (pc);
  if (bp == NULL)
    {
      /* This can happen when we remove all breakpoints while handling
	 a step-over.  */
      if (debug_threads)
	fprintf (stderr,
		 "Could not find breakpoint at 0x%s "
		 "in list (uninserting).\n",
		 paddress (pc));
      return;
    }

  if (bp->inserted)
    uninsert_raw_breakpoint (bp);
}

void
uninsert_all_breakpoints (void)
{
  struct process_info *proc = current_process ();
  struct raw_breakpoint *bp;

  for (bp = proc->raw_breakpoints; bp != NULL; bp = bp->next)
    if (bp->inserted)
      uninsert_raw_breakpoint (bp);
}

static void
reinsert_raw_breakpoint (struct raw_breakpoint *bp)
{
  int err;

  if (bp->inserted)
    error ("Breakpoint already inserted at reinsert time.");

  err = (*the_target->write_memory) (bp->pc, breakpoint_data,
				     breakpoint_len);
  if (err == 0)
    bp->inserted = 1;
  else if (debug_threads)
    fprintf (stderr,
	     "Failed to reinsert breakpoint at 0x%s (%s).\n",
	     paddress (bp->pc), strerror (err));
}

void
reinsert_breakpoints_at (CORE_ADDR pc)
{
  struct raw_breakpoint *bp;

  bp = find_raw_breakpoint_at (pc);
  if (bp == NULL)
    {
      /* This can happen when we remove all breakpoints while handling
	 a step-over.  */
      if (debug_threads)
	fprintf (stderr,
		 "Could not find raw breakpoint at 0x%s "
		 "in list (reinserting).\n",
		 paddress (pc));
      return;
    }

  reinsert_raw_breakpoint (bp);
}

void
reinsert_all_breakpoints (void)
{
  struct process_info *proc = current_process ();
  struct raw_breakpoint *bp;

  for (bp = proc->raw_breakpoints; bp != NULL; bp = bp->next)
    if (!bp->inserted)
      reinsert_raw_breakpoint (bp);
}

void
check_breakpoints (CORE_ADDR stop_pc)
{
  struct process_info *proc = current_process ();
  struct breakpoint *bp, **bp_link;

  bp = proc->breakpoints;
  bp_link = &proc->breakpoints;

  while (bp)
    {
      if (bp->raw->pc == stop_pc)
	{
	  if (!bp->raw->inserted)
	    {
	      warning ("Hit a removed breakpoint?");
	      return;
	    }

	  if (bp->handler != NULL && (*bp->handler) (stop_pc))
	    {
	      *bp_link = bp->next;

	      release_breakpoint (proc, bp);

	      bp = *bp_link;
	      continue;
	    }
	}

      bp_link = &bp->next;
      bp = *bp_link;
    }
}

void
set_breakpoint_data (const unsigned char *bp_data, int bp_len)
{
  breakpoint_data = bp_data;
  breakpoint_len = bp_len;
}

int
breakpoint_here (CORE_ADDR addr)
{
  return (find_raw_breakpoint_at (addr) != NULL);
}

int
breakpoint_inserted_here (CORE_ADDR addr)
{
  struct raw_breakpoint *bp;

  bp = find_raw_breakpoint_at (addr);

  return (bp != NULL && bp->inserted);
}

static int
validate_inserted_breakpoint (struct raw_breakpoint *bp)
{
  unsigned char *buf;
  int err;

  gdb_assert (bp->inserted);

  buf = alloca (breakpoint_len);
  err = (*the_target->read_memory) (bp->pc, buf, breakpoint_len);
  if (err || memcmp (buf, breakpoint_data, breakpoint_len) != 0)
    {
      /* Tag it as gone.  */
      bp->inserted = 0;
      bp->shlib_disabled = 1;
      return 0;
    }

  return 1;
}

static void
delete_disabled_breakpoints (void)
{
  struct process_info *proc = current_process ();
  struct breakpoint *bp, *next;

  for (bp = proc->breakpoints; bp != NULL; bp = next)
    {
      next = bp->next;
      if (bp->raw->shlib_disabled)
	delete_breakpoint_1 (proc, bp);
    }
}

/* Check if breakpoints we inserted still appear to be inserted.  They
   may disappear due to a shared library unload, and worse, a new
   shared library may be reloaded at the same address as the
   previously unloaded one.  If that happens, we should make sure that
   the shadow memory of the old breakpoints isn't used when reading or
   writing memory.  */

void
validate_breakpoints (void)
{
  struct process_info *proc = current_process ();
  struct breakpoint *bp;

  for (bp = proc->breakpoints; bp != NULL; bp = bp->next)
    {
      if (bp->raw->inserted)
	validate_inserted_breakpoint (bp->raw);
    }

  delete_disabled_breakpoints ();
}

void
check_mem_read (CORE_ADDR mem_addr, unsigned char *buf, int mem_len)
{
  struct process_info *proc = current_process ();
  struct raw_breakpoint *bp = proc->raw_breakpoints;
  struct fast_tracepoint_jump *jp = proc->fast_tracepoint_jumps;
  CORE_ADDR mem_end = mem_addr + mem_len;
  int disabled_one = 0;

  for (; jp != NULL; jp = jp->next)
    {
      CORE_ADDR bp_end = jp->pc + jp->length;
      CORE_ADDR start, end;
      int copy_offset, copy_len, buf_offset;

      gdb_assert (fast_tracepoint_jump_shadow (jp) >= buf + mem_len
		  || buf >= fast_tracepoint_jump_shadow (jp) + (jp)->length);

      if (mem_addr >= bp_end)
	continue;
      if (jp->pc >= mem_end)
	continue;

      start = jp->pc;
      if (mem_addr > start)
	start = mem_addr;

      end = bp_end;
      if (end > mem_end)
	end = mem_end;

      copy_len = end - start;
      copy_offset = start - jp->pc;
      buf_offset = start - mem_addr;

      if (jp->inserted)
	memcpy (buf + buf_offset,
		fast_tracepoint_jump_shadow (jp) + copy_offset,
		copy_len);
    }

  for (; bp != NULL; bp = bp->next)
    {
      CORE_ADDR bp_end = bp->pc + breakpoint_len;
      CORE_ADDR start, end;
      int copy_offset, copy_len, buf_offset;

      gdb_assert (bp->old_data >= buf + mem_len
		  || buf >= &bp->old_data[sizeof (bp->old_data)]);

      if (mem_addr >= bp_end)
	continue;
      if (bp->pc >= mem_end)
	continue;

      start = bp->pc;
      if (mem_addr > start)
	start = mem_addr;

      end = bp_end;
      if (end > mem_end)
	end = mem_end;

      copy_len = end - start;
      copy_offset = start - bp->pc;
      buf_offset = start - mem_addr;

      if (bp->inserted)
	{
	  if (validate_inserted_breakpoint (bp))
	    memcpy (buf + buf_offset, bp->old_data + copy_offset, copy_len);
	  else
	    disabled_one = 1;
	}
    }

  if (disabled_one)
    delete_disabled_breakpoints ();
}

void
check_mem_write (CORE_ADDR mem_addr, unsigned char *buf,
		 const unsigned char *myaddr, int mem_len)
{
  struct process_info *proc = current_process ();
  struct raw_breakpoint *bp = proc->raw_breakpoints;
  struct fast_tracepoint_jump *jp = proc->fast_tracepoint_jumps;
  CORE_ADDR mem_end = mem_addr + mem_len;
  int disabled_one = 0;

  /* First fast tracepoint jumps, then breakpoint traps on top.  */

  for (; jp != NULL; jp = jp->next)
    {
      CORE_ADDR jp_end = jp->pc + jp->length;
      CORE_ADDR start, end;
      int copy_offset, copy_len, buf_offset;

      gdb_assert (fast_tracepoint_jump_shadow (jp) >= myaddr + mem_len
		  || myaddr >= fast_tracepoint_jump_shadow (jp) + (jp)->length);
      gdb_assert (fast_tracepoint_jump_insn (jp) >= buf + mem_len
		  || buf >= fast_tracepoint_jump_insn (jp) + (jp)->length);

      if (mem_addr >= jp_end)
	continue;
      if (jp->pc >= mem_end)
	continue;

      start = jp->pc;
      if (mem_addr > start)
	start = mem_addr;

      end = jp_end;
      if (end > mem_end)
	end = mem_end;

      copy_len = end - start;
      copy_offset = start - jp->pc;
      buf_offset = start - mem_addr;

      memcpy (fast_tracepoint_jump_shadow (jp) + copy_offset,
	      myaddr + buf_offset, copy_len);
      if (jp->inserted)
	memcpy (buf + buf_offset,
		fast_tracepoint_jump_insn (jp) + copy_offset, copy_len);
    }

  for (; bp != NULL; bp = bp->next)
    {
      CORE_ADDR bp_end = bp->pc + breakpoint_len;
      CORE_ADDR start, end;
      int copy_offset, copy_len, buf_offset;

      gdb_assert (bp->old_data >= myaddr + mem_len
		  || myaddr >= &bp->old_data[sizeof (bp->old_data)]);

      if (mem_addr >= bp_end)
	continue;
      if (bp->pc >= mem_end)
	continue;

      start = bp->pc;
      if (mem_addr > start)
	start = mem_addr;

      end = bp_end;
      if (end > mem_end)
	end = mem_end;

      copy_len = end - start;
      copy_offset = start - bp->pc;
      buf_offset = start - mem_addr;

      memcpy (bp->old_data + copy_offset, myaddr + buf_offset, copy_len);
      if (bp->inserted)
	{
	  if (validate_inserted_breakpoint (bp))
	    memcpy (buf + buf_offset, breakpoint_data + copy_offset, copy_len);
	  else
	    disabled_one = 1;
	}
    }

  if (disabled_one)
    delete_disabled_breakpoints ();
}

/* Delete all breakpoints, and un-insert them from the inferior.  */

void
delete_all_breakpoints (void)
{
  struct process_info *proc = current_process ();

  while (proc->breakpoints)
    delete_breakpoint_1 (proc, proc->breakpoints);
}

/* Clear the "inserted" flag in all breakpoints.  */

void
mark_breakpoints_out (struct process_info *proc)
{
  struct raw_breakpoint *raw_bp;

  for (raw_bp = proc->raw_breakpoints; raw_bp != NULL; raw_bp = raw_bp->next)
    raw_bp->inserted = 0;
}

/* Release all breakpoints, but do not try to un-insert them from the
   inferior.  */

void
free_all_breakpoints (struct process_info *proc)
{
  mark_breakpoints_out (proc);

  /* Note: use PROC explicitly instead of deferring to
     delete_all_breakpoints --- CURRENT_INFERIOR may already have been
     released when we get here.  There should be no call to
     current_process from here on.  */
  while (proc->breakpoints)
    delete_breakpoint_1 (proc, proc->breakpoints);
}
@


1.37
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d843 1
a843 2

  struct regcache *regcache = get_thread_regcache (current_inferior, 1);
d853 4
d866 1
a866 1
      err = gdb_eval_agent_expr (regcache, NULL, cl->cond, &value);
d949 1
a949 2

  struct regcache *regcache = get_thread_regcache (current_inferior, 1);
d954 4
d962 1
a962 1
      err = gdb_eval_agent_expr (regcache, NULL, cl->cmd, &value);
@


1.36
log
@(gdb_no_commands_at_breakpoint): Tweak previous patch for win64 where
sizeof (long) < sizeof (void*).
@
text
@d2 1
a2 2
   Copyright (C) 2002-2003, 2005, 2007-2012 Free Software Foundation,
   Inc.
@


1.35
log
@	* mem-break.c (gdb_no_commands_at_breakpoint): Fix cast from
	pointer to int.
@
text
@d933 3
a935 2
    fprintf (stderr, "at 0x%s, bp command_list is 0x%lx\n",
	     paddress (where), (long) (uintptr_t) bp->command_list);
@


1.34
log
@	Add target-side support for dynamic printf.
	* NEWS: Mention the additional style.
	* breakpoint.h (struct bp_target_info): New fields tcommands, persist.
	(struct bp_location): New field cmd_bytecode.
	* breakpoint.c: Include format.h.
	(disconnected_dprintf): New global.
	(parse_cmd_to_aexpr): New function.
	(build_target_command_list): New function.
	(insert_bp_location): Call it.
	(remove_breakpoints_pid): Skip dprintf breakpoints.
	(print_one_breakpoint_location): Ditto.
	(dprintf_style_agent): New global.
	(dprintf_style_enums): Add dprintf_style_agent.
	(update_dprintf_command_list): Add agent case.
	(agent_printf_command): New function.
	(_initialize_breakpoint): Add new commands.
	* common/ax.def (printf): New bytecode.
	* ax.h (ax_string): Declare.
	* ax-gdb.h (gen_printf): Declare.
	* ax-gdb.c: Include cli-utils.h, format.h.
	(gen_printf): New function.
	(maint_agent_print_command): New function.
	(_initialize_ax_gdb): Add maint agent-printf command.
	* ax-general.c (ax_string): New function.
	(ax_print): Add printf disassembly.
	* Makefile.in (SFILES): Add format.c
	(COMMON_OBS): Add format.o.
	* common/format.h: New file.
	* common/format.c: New file.
	* printcmd.c: Include format.h.
	(ui_printf): Call parse_format_string.
	* remote.c (remote_state): New field breakpoint_commands.
	(PACKET_BreakpointCommands): New enum.
	(remote_breakpoint_commands_feature): New function.
	(remote_protocol_features): Add new BreakpointCommands entry.
	(remote_can_run_breakpoint_commands): New function.
	(remote_add_target_side_commands): New function.
	(remote_insert_breakpoint): Call it.
	(remote_insert_hw_breakpoint): Ditto.
	(_initialize_remote): Add new packet configuration for
	target-side breakpoint commands.
	* target.h (struct target_ops): New field
	to_can_run_breakpoint_commands.
	(target_can_run_breakpoint_commands): New macro.
	* target.c (update_current_target): Handle
	to_can_run_breakpoint_commands.

	[gdbserver]
	* Makefile.in (WARN_CFLAGS_NO_FORMAT): Define.
	(ax.o): Add it to build rule.
	(ax-ipa.o): Ditto.
	(OBS): Add format.o.
	(IPA_OBS): Add format.o.
	* server.c (handle_query): Claim support for breakpoint commands.
	(process_point_options): Add command case.
	(process_serial_event): Leave running if there are printfs in
	effect.
	* mem-break.h (any_persistent_commands): Declare.
	(add_breakpoint_commands): Declare.
	(gdb_no_commands_at_breakpoint): Declare.
	(run_breakpoint_commands): Declare.
	* mem-break.c (struct point_command_list): New struct.
	(struct breakpoint): New field command_list.
	(any_persistent_commands): New function.
	(add_commands_to_breakpoint): New function.
	(add_breakpoint_commands): New function.
	(gdb_no_commands_at_breakpoint): New function.
	(run_breakpoint_commands): New function.
	* linux-low.c (linux_wait_1): Test for and run breakpoint commands
	locally.
	* ax.c: Include format.h.
	(ax_printf): New function.
	(gdb_eval_agent_expr): Add printf opcode.

	[doc]
	* gdb.texinfo (Dynamic Printf): Mention agent style and
	disconnected dprintf.
	(Maintenance Commands): Describe maint agent-printf.
	(General Query Packets): Mention BreakpointCommands feature.
	(Packets): Document commands extension to Z0 packet.
	* agentexpr.texi (Bytecode Descriptions): Document printf
	bytecode.

	[testsuite]
	* gdb.base/dprintf.exp: Add agent style tests.
@
text
@d25 1
d933 2
a934 2
    fprintf (stderr, "at 0x%s, bp command_list is 0x%x\n",
	     paddress (where), (int) bp->command_list);
@


1.33
log
@2012-02-25  Luis Machado  <lgustavo@@codesourcery.com>

	* mem-break.c (clear_gdb_breakpoint_conditions): Fix de-allocation
	of conditions.
@
text
@d100 14
d128 3
d141 17
d872 91
@


1.32
log
@2012-02-24  Luis Machado  <lgustavo@@codesourcery>

	* server.c (handle_query): Advertise support for target-side
	breakpoint condition evaluation.
	(process_point_options): New function.
	(process_serial_event): When inserting a breakpoint, check for
	a target-side condition that should be evaluated.

	* mem-break.c: Include regcache.h and ax.h.
	(point_cond_list_t): New data structure.
	(breakpoint) <cond_list>: New field.
	(find_gdb_breakpoint_at): Make non-static.
	(delete_gdb_breakpoint_at): Clear any target-side
	conditions.
	(clear_gdb_breakpoint_conditions): New function.
	(add_condition_to_breakpoint): Likewise.
	(add_breakpoint_condition): Likewise.
	(gdb_condition_true_at_breakpoint): Likewise.
	(gdb_breakpoint_here): Return result directly instead
	of going through a local variable.

	* mem-break.h (find_gdb_breakpoint_at): New prototype.
	(clear_gdb_breakpoint_conditions): Likewise.
	(add_breakpoint_condition): Likewise.
	(gdb_condition_true_at_breakpoint): Likewise.

	* linux-low.c (linux_wait_1): Evaluate target-side breakpoint condition.
	(need_step_over_p): Take target-side breakpoint condition into
	consideration.
@
text
@d729 1
a729 1
  struct point_cond_list *cond, **cond_p;
a734 1
  cond_p = &bp->cond_list->next;
d738 4
d744 1
a744 2
      cond = *cond_p;
      cond_p = &cond->next;
@


1.31
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d23 2
d90 10
d108 6
d653 1
a653 1
static struct breakpoint *
d713 3
d723 44
d768 33
a800 1
gdb_breakpoint_here (CORE_ADDR where)
d802 1
d804 8
d813 30
a842 1
  return (bp != NULL);
@


1.30
log
@gdb/gdbserver/
	Fix overlapping memcpy.
	* mem-break.c (set_raw_breakpoint_at): New variable buf.  Use it for
	the read_inferior_memory transfer.
	(delete_fast_tracepoint_jump): New variable buf.  Use it for the
	write_inferior_memory transfer.
	(set_fast_tracepoint_jump): New variable buf.  Use it for the
	read_inferior_memory and write_inferior_memory transfers.
	(uninsert_fast_tracepoint_jumps_at, reinsert_fast_tracepoint_jumps_at)
	(delete_raw_breakpoint, uninsert_raw_breakpoint): New variable buf.
	Use it for the write_inferior_memory transfer.
	(check_mem_read, check_mem_write): New gdb_asserts for overlapping
	buffers.
@
text
@d2 2
a3 2
   Copyright (C) 2002, 2003, 2005, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.30.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 2
a3 2
   Copyright (C) 2002-2003, 2005, 2007-2012 Free Software Foundation,
   Inc.
@


1.29
log
@	* mem-break.c (inc_ref_fast_tracepoint_jump): New.
	* mem-break.h: Declare.
	* tracepoint.c (cmd_qtstart): Move some code to ...
	(clone_fast_tracepoint, install_fast_tracepoint): ... here.
	New.
	(download_tracepoints): Move some code to ...
	(download_tracepoint_1): ... here.  New.
@
text
@d125 1
d144 1
a144 1
  err = read_inferior_memory (where, bp->old_data, breakpoint_len);
d155 1
d262 1
d276 3
a278 3
	      ret = write_inferior_memory (bp->pc,
					   fast_tracepoint_jump_shadow (bp),
					   bp->length);
d321 1
d340 1
d345 1
a345 2
  err = read_inferior_memory (where,
			      fast_tracepoint_jump_shadow (jp), jp->length);
d356 1
d371 1
a371 2
  err = write_inferior_memory (where, fast_tracepoint_jump_shadow (jp),
			       length);
d410 2
d423 3
a425 3
      err = write_inferior_memory (jp->pc,
				   fast_tracepoint_jump_shadow (jp),
				   jp->length);
d443 1
d471 3
a473 2
  err = write_inferior_memory (where,
			       fast_tracepoint_jump_shadow (jp), jp->length);
d528 1
d541 2
a542 2
	      ret = write_inferior_memory (bp->pc, bp->old_data,
					   breakpoint_len);
d750 1
d761 2
a762 2
      err = write_inferior_memory (bp->pc, bp->old_data,
				   breakpoint_len);
d988 3
d1020 3
d1071 5
d1106 3
@


1.28
log
@2011-10-31  Pedro Alves  <pedro@@codesourcery.com>

	gdb/gdbserver/
	* mem-break.c (check_mem_write): Add `myaddr' parameter.  Don't
	clobber the breakpoints' shadows with fast tracepoint jumps.
	* mem-break.h (check_mem_write): Add `myaddr' parameter.
	* target.c (write_inferior_memory): Also pass MYADDR down to
	check_mem_write.

	gdb/testsuite/
        * gdb.trace/trace-break.c: New.
        * gdb.trace/trace-break.exp: New.
@
text
@d305 6
@


1.27
log
@2011-01-05  Michael Snyder  <msnyder@@msnyder-server.eng.vmware.com>

	* gdbreplay.c: Shorten lines of >= 80 columns.
	* linux-low.c: Ditto.
	* linux-ppc-low.c: Ditto.
	* linux-s390-low.c: Ditto.
	* linux-sparc-low.c: Ditto.
	* linux-x86-low.c: Ditto.
	* linux-xtensa-low.c: Ditto.
	* mem-break.c: Ditto.
	* nto-low.c: Ditto.
	* regcache.h: Ditto.
	* remote-utils.c: Ditto.
	* server.c: Ditto.
	* server.h: Ditto.
	* thread-db.c: Ditto.
	* tracepoint.c: Ditto.
	* utils.c: Ditto.
	* win32-low.h: Ditto.
@
text
@d1032 2
a1033 1
check_mem_write (CORE_ADDR mem_addr, unsigned char *buf, int mem_len)
d1067 1
a1067 1
	      buf + buf_offset, copy_len);
d1096 1
a1096 1
      memcpy (bp->old_data + copy_offset, buf + buf_offset, copy_len);
@


1.26
log
@run copyright.sh for 2011.
@
text
@d360 2
a361 1
  err = write_inferior_memory (where, fast_tracepoint_jump_shadow (jp), length);
@


1.25
log
@[gdbserver] Move malloc.h include to server.h.

This patch moves all includes of malloc.h, which were introduced
purely to get access to alloca's declaration, to server.h, next
to the include of alloca.h.

There is one exception: gdbreplay.c, which does not include server.h.
In this case, the include of alloca.h was simply moved up a bit, next
to the include of malloc.h.

gdb/gdbserver/ChangeLog:

        * gdbreplay.c: Move include of alloca.h up, next to include of
        malloc.h.
        * server.h: Add include of malloc.h.
        * mem-break.c: Remove include of malloc.h.
        * server.c, tracepoint.c, utils.c, win32-low.c: Likewise.
@
text
@d2 1
a2 1
   Copyright (C) 2002, 2003, 2005, 2007, 2008, 2009, 2010
@


1.24
log
@	* mem-break.c [HAVE_MALLOC_H]: Include malloc.h.
@
text
@a22 3
#if HAVE_MALLOC_H
#include <malloc.h>
#endif
@


1.23
log
@	Static tracepoints support, and UST integration.

	gdb/gdbserver/
	* configure.ac: Handle --with-ust.  substitute ustlibs and ustinc.
	* mem-break.c (uninsert_all_breakpoints)
	(reinsert_all_breakpoints): New.
	* mem-break.h (reinsert_all_breakpoints, uninsert_all_breakpoints):
	* tracepoint.c (ust_loaded, helper_thread_id, cmd_buf): New.
	(gdb_agent_ust_loaded, helper_thread_id)
	(gdb_agent_helper_thread_id): New macros.
	(struct ipa_sym_addresses): Add addr_ust_loaded,
	addr_helper_thread_id, addr_cmd_buf.
	(symbol_list): Add ust_loaded, helper_thread_id, cmd_buf.
	(in_process_agent_loaded_ust): New.
	(write_e_ust_not_loaded): New.
	(maybe_write_ipa_ust_not_loaded): New.
	(struct collect_static_trace_data_action): New.
	(enum tracepoint_type) <static_tracepoint>: New.
	(struct tracepoint) <handle>: Mention static tracepoints.
	(struct static_tracepoint_ctx): New.
	(CMD_BUF_SIZE): New.
	(add_tracepoint_action): Handle static tracepoint actions.
	(unprobe_marker_at): New.
	(clear_installed_tracepoints): Handle static tracepoints.
	(cmd_qtdp): Handle static tracepoints.
	(probe_marker_at): New.
	(cmd_qtstart): Handle static tracepoints.
	(response_tracepoint): Handle static tracepoints.
	(cmd_qtfstm, cmd_qtsstm, cmd_qtstmat): New.
	(handle_tracepoint_query): Handle qTfSTM, qTsSTM and qTSTMat.
	(get_context_regcache): Handle static tracepoints.
	(do_action_at_tracepoint): Handle static tracepoint actions.
	(traceframe_find_block_type): Handle static trace data blocks.
	(traceframe_read_sdata): New.
	(download_tracepoints): Download static tracepoint actions.
	[HAVE_UST] Include ust/ust.h, dlfcn.h, sys/socket.h, and sys/un.h.
	(GDB_PROBE_NAME): New.
	(ust_ops): New.
	(GET_UST_SYM): New.
	(USTF): New.
	(dlsym_ust): New.
	(ust_marker_to_static_tracepoint): New.
	(gdb_probe): New.
	(collect_ust_data_at_tracepoint): New.
	(gdb_ust_probe): New.
	(UNIX_PATH_MAX, SOCK_DIR): New.
	(gdb_ust_connect_sync_socket): New.
	(resume_thread, stop_thread): New.
	(run_inferior_command): New.
	(init_named_socket): New.
	(gdb_ust_socket_init): New.
	(cstr_to_hexstr): New.
	(next_st): New.
	(first_marker, next_marker): New.
	(response_ust_marker): New.
	(cmd_qtfstm, cmd_qtsstm): New.
	(unprobe_marker_at, probe_marker_at): New.
	(cmd_qtstmat, gdb_ust_thread): New.
	(gdb_ust_init): New.
	(initialize_tracepoint_ftlib): Call gdb_ust_init.
	* linux-amd64-ipa.c [HAVE_UST]: Include ust/processor.h
	(ST_REGENTRY): New.
	(x86_64_st_collect_regmap): New.
	(X86_64_NUM_ST_COLLECT_GREGS): New.
	(AMD64_RIP_REGNUM): New.
	(supply_static_tracepoint_registers): New.
	* linux-i386-ipa.c [HAVE_UST]: Include ust/processor.h
	(ST_REGENTRY): New.
	(i386_st_collect_regmap): New.
	(i386_NUM_ST_COLLECT_GREGS): New.
	(supply_static_tracepoint_registers): New.
	* server.c (handle_query): Handle qXfer:statictrace:read.
	<qSupported>: Report support for StaticTracepoints, and
	qXfer:statictrace:read features.
	* server.h (traceframe_read_sdata)
	(supply_static_tracepoint_registers): Declare.
	* remote-utils.c (convert_int_to_ascii, hexchars, ishex, tohex)
	(unpack_varlen_hex): Include in IPA build.
	* Makefile.in (ustlibs, ustinc): New.
	(IPA_OBJS): Add remote-utils-ipa.o.
	($(IPA_LIB)): Link -ldl and -lpthread.
	(UST_CFLAGS): New.
	(IPAGENT_CFLAGS): Add UST_CFLAGS.
	* config.in, configure: Regenerate.

	gdb/
	* NEWS: Mention new support for static tracepoints.
	(New packets): Mention qTfSTM, qTsSTM, qTSTMat and
	qXfer:statictrace:read.
	(New features in the GDB remote stub, GDBserver): Mention static
	tracepoints support using an UST based backend.
	(New commands): Mention "info static-tracepoint-markers" and
	"strace".
	* breakpoint.c (is_marker_spec): New.
	(is_tracepoint): Handle static tracepoints.
	(validate_commands_for_breakpoint): Static tracepoints can't do
	while-stepping.
	(static_tracepoints_here): New.
	(bpstat_what): Handle static tracepoints.
	(print_one_breakpoint_location, allocate_bp_location, mention):
	Ditto.
	(create_breakpoint_sal): Ditto.
	(decode_static_tracepoint_spec): New.
	(create_breakpoint): Replace `hardwareflag', and `traceflag' with
	`type_wanted'.  Adjust.  Handle static tracepoint marker
	locations.
	(break_command_1): Adjust.
	(update_static_tracepoint): New.
	(update_breakpoint_locations): Handle static tracepoints.
	(breakpoint_re_set_one): Handle static tracepoint marker
	locations.
	(disable_command, enable_command): Handle static tracepoints.
	(trace_command, ftrace_command): Adjust.
	(strace_command): New.
	(create_tracepoint_from_upload): Adjust.
	(save_breakpoints): Handle static tracepoints.
	(_initialize_breakpoint): Install the "strace" command.
	* breakpoint.h (enum bptype): New bp_static_tracepoint type.
	(struct breakpoint): New fields static_trace_marker_id and
	static_trace_marker_id_idx.
	(breakpoints_here_p): Declare.
	(create_breakpoint): Adjust.
	(static_tracepoints_here): Declare.
	* remote.c (struct remote_state) <static_tracepoints>: New field.
	(PACKET_qXfer_statictrace_read, PACKET_StaticTracepoints): New.
	(remote_static_tracepoint_marker_at): New.
	(remote_static_tracepoint_markers_by_strid): New.
	(remote_static_tracepoint_feature): New.
	(remote_disconnected_tracing_feature): Handle "StaticTracepoints".
	(remote_xfer_partial): Handle TARGET_OBJECT_STATIC_TRACE_DATA.
	(remote_supports_static_tracepoints): New.
	(remote_download_tracepoint): Download static tracepoints.
	(init_remote_ops): Install remote_static_tracepoint_marker_at and
	remote_static_tracepoint_markers_by_strid.
	(_initialize_remote): Install set|show remote static-tracepoints,
	and set|show remote read-sdata-object commands.
	* target.c (update_current_target): Inherit and default
	to_static_tracepoint_marker_at, and
	to_static_tracepoint_markers_by_strid.
	* target.h (static_tracepoint_marker): Forward declare.
	(enum target_object): New object TARGET_OBJECT_STATIC_TRACE_DATA.
	(static_tracepoint_marker_p): New typedef.
	(DEF_VEC_P(static_tracepoint_marker_p)): New VEC type.
	(struct target_ops): New fields to_static_tracepoint_marker_at and
	to_static_tracepoint_markers_by_strid.
	(target_static_tracepoint_marker_at)
	(target_static_tracepoint_markers_by_strid): New.
	* tracepoint.c: Include source.h.
	(validate_actionline): Handle $_sdata.
	(struct collection_list): New field strace_data.
	(add_static_trace_data): New.
	(clear_collection_list): Clear strace_data.
	(stringify_collection_list): Account for a possible static trace
	data collection.
	(encode_actions_1): Encode an $_sdata collection.
	(parse_tracepoint_definition): Handle static tracepoints.
	(parse_static_tracepoint_marker_definition): New.
	(release_static_tracepoint_marker): New.
	(print_one_static_tracepoint_marker): New.
	(info_static_tracepoint_markers_command): New.
	(sdata_make_value): New.
	(_initialize_tracepoint): Create the $_sdata convenience variable.
	Add the "info static-tracepoint-markers" command.
	Mention $_sdata in the "collect" command's help output.
	* tracepoint.h (struct static_tracepoint_marker): New.
	(parse_static_tracepoint_marker_definition)
	(release_static_tracepoint_marker): Declare.
	* mi/mi-cmd-break.c (mi_cmd_break_insert): Adjust.
	* python/py-breakpoint.c (bppy_new): Adjust.

	doc/
	* gdb.texinfo (Convenience Variables): Document $_sdata.
	(Commands to Set Tracepoints): Describe static tracepoints.  Add
	`Listing Static Tracepoint Markers' menu entry.  Document
	"strace".
	(Tracepoint Action Lists): Document collecting $_sdata.
	(Listing Static Tracepoint Markers): New subsection.
	(Tracepoints support in gdbserver): Mention static tracepoints.
	(remote packets, enabling and disabling): Mention
	read-sdata-object.
	(General Query Packets) <qSupported>: Document qXfer:sdata:read
	and StaticTracepoint.
	Mention qTfSTM, qTsSTM and qTSTMat as tracepoint packets.
	Document qXfer:sdata:read.
	(Tracepoint packets): Document qTfSTM, qTsSTM and qTSTMat.
@
text
@d23 3
@


1.22
log
@gdb/gdbserver/
2010-06-01  Pedro Alves  <pedro@@codesourcery.com>
	    Stan Shebs  <stan@@codesourcery.com>

	* Makefile.in (IPA_DEPFILES, extra_libraries): New.
	(all): Depend on $(extra_libraries).
	(install-only): Install the IPA.
	(IPA_OBJS, IPA_LIB): New.
	(clean): Remove the IPA lib.
	(IPAGENT_CFLAGS): New.
	(tracepoint-ipa.o, utils-ipa.o, remote-utils-ipa.o)
	(regcache-ipa.o, i386-linux-ipa.o, linux-i386-ipa.o)
	(linux-amd64-ipa.o, amd64-linux-ipa.o): New rules.
	* linux-amd64-ipa.c, linux-i386-ipa.c: New files.
	* configure.ac: Check for atomic builtins support in the compiler.
	(IPA_DEPFILES, extra_libraries): Define.
	* configure.srv (ipa_obj): Add description.
	(ipa_i386_linux_regobj, ipa_amd64_linux_regobj): Define.
	(i[34567]86-*-linux*): Set ipa_obj.
	(x86_64-*-linux*): Set ipa_obj.
	* linux-low.c (stabilizing_threads): New.
	(supports_fast_tracepoints): New.
	(linux_detach): Stabilize threads before detaching.
	(handle_tracepoints): Handle internal tracing breakpoints.  Assert
	the lwp is either not stabilizing, or is moving out of a jump pad.
	(linux_fast_tracepoint_collecting): New.
	(maybe_move_out_of_jump_pad): New.
	(enqueue_one_deferred_signal): New.
	(dequeue_one_deferred_signal): New.
	(linux_wait_for_event_1): If moving out of a jump pad, defer
	pending signals to later.
	(linux_stabilize_threads): New.
	(linux_wait_1): Check if threads need moving out of jump pads, and
	do it if so.
	(stuck_in_jump_pad_callback): New.
	(move_out_of_jump_pad_callback): New.
	(lwp_running): New.
	(linux_resume_one_lwp): Handle moving out of jump pads.
	(linux_set_resume_request): Dequeue deferred signals.
	(need_step_over_p): Also step over fast tracepoint jumps.
	(start_step_over): Also uninsert fast tracepoint jumps.
	(finish_step_over): Also reinsert fast tracepoint jumps.
	(linux_install_fast_tracepoint_jump): New.
	(linux_target_ops): Install linux_stabilize_threads and
	linux_install_fast_tracepoint_jump_pad.
	* linux-low.h (linux_target_ops) <get_thread_area,
	install_fast_tracepoint_jump_pad>: New fields.
	(struct lwp_info) <collecting_fast_tracepoint,
	pending_signals_to_report, exit_jump_pad_bkpt>: New fields.
	(linux_get_thread_area): Declare.
	* linux-x86-low.c (jump_insn): New.
	(x86_get_thread_area): New.
	(append_insns): New.
	(push_opcode): New.
	(amd64_install_fast_tracepoint_jump_pad): New.
	(i386_install_fast_tracepoint_jump_pad): New.
	(x86_install_fast_tracepoint_jump_pad): New.
	(the_low_target): Install x86_get_thread_area and
	x86_install_fast_tracepoint_jump_pad.
	* mem-break.c (set_raw_breakpoint_at): Use read_inferior_memory.
	(struct fast_tracepoint_jump): New.
	(fast_tracepoint_jump_insn): New.
	(fast_tracepoint_jump_shadow): New.
	(find_fast_tracepoint_jump_at): New.
	(fast_tracepoint_jump_here): New.
	(delete_fast_tracepoint_jump): New.
	(set_fast_tracepoint_jump): New.
	(uninsert_fast_tracepoint_jumps_at): New.
	(reinsert_fast_tracepoint_jumps_at): New.
	(set_breakpoint_at): Use write_inferior_memory.
	(uninsert_raw_breakpoint): Use write_inferior_memory.
	(check_mem_read): Mask out fast tracepoint jumps.
	(check_mem_write): Mask out fast tracepoint jumps.
	* mem-break.h (struct fast_tracepoint_jump): Forward declare.
	(set_fast_tracepoint_jump): Declare.
	(delete_fast_tracepoint_jump)
	(fast_tracepoint_jump_here, uninsert_fast_tracepoint_jumps_at)
	(reinsert_fast_tracepoint_jumps_at): Declare.
	* regcache.c: Don't compile many functions when building the
	in-process agent library.
	(init_register_cache) [IN_PROCESS_AGENT]: Don't allow allocating
	the register buffer in the heap.
	(free_register_cache): If the register buffer isn't owned by the
	regcache, don't free it.
	(set_register_cache) [IN_PROCESS_AGENT]: Don't re-alocate
	pre-existing register caches.
	* remote-utils.c (convert_int_to_ascii): Constify `from' parameter
	type.
	(convert_ascii_to_int): : Constify `from' parameter type.
	(decode_M_packet, decode_X_packet): Replace the `to' parameter by
	a `to_p' pointer to pointer parameter.  If TO_P is NULL, malloc
	the needed buffer in-place.
	(relocate_instruction): New.
	* server.c (handle_query) <qSymbols>: If the target supports
	tracepoints, give it a chance of looking up symbols.  Report
	support for fast tracepoints.
	(handle_status): Stabilize threads.
	(process_serial_event): Adjust.
	* server.h (struct fast_tracepoint_jump): Forward declare.
	(struct process_info) <fast_tracepoint_jumps>: New field.
	(convert_ascii_to_int, convert_int_to_ascii): Adjust.
	(decode_X_packet, decode_M_packet): Adjust.
	(relocate_instruction): Declare.
	(in_process_agent_loaded): Declare.
	(tracepoint_look_up_symbols): Declare.
	(struct fast_tpoint_collect_status): Declare.
	(fast_tracepoint_collecting): Declare.
	(force_unlock_trace_buffer): Declare.
	(handle_tracepoint_bkpts): Declare.
	(initialize_low_tracepoint)
	(supply_fast_tracepoint_registers) [IN_PROCESS_AGENT]: Declare.
	* target.h (struct target_ops) <stabilize_threads,
	install_fast_tracepoint_jump_pad>: New fields.
	(stabilize_threads, install_fast_tracepoint_jump_pad): New.
	* tracepoint.c [HAVE_MALLOC_H]: Include malloc.h.
	[HAVE_STDINT_H]: Include stdint.h.
	(trace_debug_1): Rename to ...
	(trace_vdebug): ... this.
	(trace_debug): Rename to ...
	(trace_debug_1): ... this.  Add `level' parameter.
	(trace_debug): New.
	(ATTR_USED, ATTR_NOINLINE): New.
	(IP_AGENT_EXPORT): New.
	(gdb_tp_heap_buffer, gdb_jump_pad_buffer, gdb_jump_pad_buffer_end)
	(collecting, gdb_collect, stop_tracing, flush_trace_buffer)
	(about_to_request_buffer_space, trace_buffer_is_full)
	(stopping_tracepoint, expr_eval_result, error_tracepoint)
	(tracepoints, tracing, trace_buffer_ctrl, trace_buffer_ctrl_curr)
	(trace_buffer_lo, trace_buffer_hi, traceframe_read_count)
	(traceframe_write_count, traceframes_created)
	(trace_state_variables)
	New renaming defines.
	(struct ipa_sym_addresses): New.
	(STRINGIZE_1, STRINGIZE, IPA_SYM): New.
	(symbol_list): New.
	(ipa_sym_addrs): New.
	(all_tracepoint_symbols_looked_up): New.
	(in_process_agent_loaded): New.
	(write_e_ipa_not_loaded): New.
	(maybe_write_ipa_not_loaded): New.
	(tracepoint_look_up_symbols): New.
	(debug_threads) [IN_PROCESS_AGENT]: New.
	(read_inferior_memory) [IN_PROCESS_AGENT]: New.
	(UNKNOWN_SIDE_EFFECTS): New.
	(stop_tracing): New.
	(flush_trace_buffer): New.
	(stop_tracing_bkpt): New.
	(flush_trace_buffer_bkpt): New.
	(read_inferior_integer): New.
	(read_inferior_uinteger): New.
	(read_inferior_data_pointer): New.
	(write_inferior_data_pointer): New.
	(write_inferior_integer): New.
	(write_inferior_uinteger): New.
	(struct collect_static_trace_data_action): Delete.
	(enum tracepoint_type): New.
	(struct tracepoint) <type>: New field `type'.
	<actions_str, step_actions, step_actions_str>: Only include in GDBserver.
	<orig_size, obj_addr_on_target, adjusted_insn_addr>
	<adjusted_insn_addr_end, jump_pad, jump_pad_end>: New fields.
	(tracepoints): Use IP_AGENT_EXPORT.
	(last_tracepoint): Don't include in the IPA.
	(stopping_tracepoint): Use IP_AGENT_EXPORT.
	(trace_buffer_is_full): Use IP_AGENT_EXPORT.
	(alloced_trace_state_variables): New.
	(trace_state_variables): Use IP_AGENT_EXPORT.
	(traceframe_t): Delete unused variable.
	(circular_trace_buffer): Don't include in the IPA.
	(trace_buffer_start): Delete.
	(struct trace_buffer_control): New.
	(trace_buffer_free): Delete.
	(struct ipa_trace_buffer_control): New.
	(GDBSERVER_FLUSH_COUNT_MASK, GDBSERVER_FLUSH_COUNT_MASK_PREV)
	(GDBSERVER_FLUSH_COUNT_MASK_CURR, GDBSERVER_UPDATED_FLUSH_COUNT_BIT):
	New.
	(trace_buffer_ctrl): New.
	(TRACE_BUFFER_CTRL_CURR): New.
	(trace_buffer_start, trace_buffer_free, trace_buffer_end_free):
	Reimplement as macros.
	(trace_buffer_wrap): Delete.
	(traceframe_write_count, traceframe_read_count)
	(traceframes_created, tracing): Use IP_AGENT_EXPORT.
	(struct tracepoint_hit_ctx) <type>: New field.
	(struct fast_tracepoint_ctx): New.
	(memory_barrier): New.
	(cmpxchg): New.
	(record_tracepoint_error): Update atomically in the IPA.
	(clear_inferior_trace_buffer): New.
	(about_to_request_buffer_space): New.
	(trace_buffer_alloc): Handle GDBserver and inferior simulatenous
	updating the same buffer.
	(add_tracepoint): Default the tracepoint's type to trap
	tracepoint, and orig_size to -1.
	(get_trace_state_variable) [IN_PROCESS_AGENT]: Handle allocated
	internal variables.
	(create_trace_state_variable): New parameter `gdb'.  Handle it.
	(clear_installed_tracepoints): Clear fast tracepoint jumps.
	(cmd_qtdp): Handle fast tracepoints.
	(cmd_qtdv): Adjust.
	(max_jump_pad_size): New.
	(gdb_jump_pad_head): New.
	(get_jump_space_head): New.
	(claim_jump_space): New.
	(sort_tracepoints): New.
	(MAX_JUMP_SIZE): New.
	(cmd_qtstart): Handle fast tracepoints.  Sync tracepoints with the
	IPA.
	(stop_tracing) [IN_PROCESS_AGENT]: Don't include the tdisconnected
	support.  Upload fast traceframes, and delete internal IPA
	breakpoints.
	(stop_tracing_handler): New.
	(flush_trace_buffer_handler): New.
	(cmd_qtstop): Upload fast tracepoints.
	(response_tracepoint): Handle fast tracepoints.
	(tracepoint_finished_step): Upload fast traceframes.  Set the
	tracepoint hit context's tracepoint type.
	(handle_tracepoint_bkpts): New.
	(tracepoint_was_hit): Set the tracepoint hit context's tracepoint
	type.  Add comment about fast tracepoints.
	(collect_data_at_tracepoint) [IN_PROCESS_AGENT]: Don't access the
	non-existing action_str field.
	(get_context_regcache): Handle fast tracepoints.
	(do_action_at_tracepoint) [!IN_PROCESS_AGENT]: Don't write the PC
	to the regcache.
	(fast_tracepoint_from_jump_pad_address): New.
	(fast_tracepoint_from_ipa_tpoint_address): New.
	(collecting_t): New.
	(force_unlock_trace_buffer): New.
	(fast_tracepoint_collecting): New.
	(collecting): New.
	(gdb_collect): New.
	(write_inferior_data_ptr): New.
	(target_tp_heap): New.
	(target_malloc): New.
	(download_agent_expr): New.
	(UALIGN): New.
	(download_tracepoints): New.
	(download_trace_state_variables): New.
	(upload_fast_traceframes): New.
	(IPA_FIRST_TRACEFRAME): New.
	(IPA_NEXT_TRACEFRAME_1): New.
	(IPA_NEXT_TRACEFRAME): New.
	[IN_PROCESS_AGENT]: Include sys/mman.h and fcntl.h.
	[IN_PROCESS_AGENT] (gdb_tp_heap_buffer, gdb_jump_pad_buffer)
	(gdb_jump_pad_buffer_end): New.
	[IN_PROCESS_AGENT] (initialize_tracepoint_ftlib): New.
	(initialize_tracepoint): Adjust.
	[IN_PROCESS_AGENT]: Allocate the IPA heap, and jump pad scratch
	buffer.  Initialize the low module.
	* utils.c (PREFIX, TOOLNAME): New.
	(malloc_failure): Use PREFIX.
	(error): In the IPA, an error causes an exit.
	(fatal, warning): Use PREFIX.
	(internal_error): Use TOOLNAME.
	(NUMCELLS): Increase to 10.
	* configure, config.in: Regenerate.

gdb/
2010-06-01  Pedro Alves  <pedro@@codesourcery.com>

	* NEWS: Mention gdbserver fast tracepoints support.

gdb/doc/
2010-06-01  Pedro Alves  <pedro@@codesourcery.com>

	* gdb.texinfo (Set Tracepoints): Mention tracepoints support in
	gdbserver, and add cross reference.
	(Tracepoints support in gdbserver): New subsection.
@
text
@d780 11
d831 11
@


1.21
log
@	* linux-low.c (linux_kill_one_lwp): Assume the lwp is stopped.
	(linux_kill): Stop all lwps here.  Don't delete the main lwp here.
	(linux_detach_one_lwp): Assume the lwp is stopped.
	(any_thread_of): Delete.
	(linux_detach): Stop all lwps here.  Don't blindly delete all
	breakpoints.
	(delete_lwp_callback): New.
	(linux_mourn): Delete all lwps of the process that is gone.
	(linux_wait_1): Don't delete the last lwp of the process here.
	* mem-break.h (mark_breakpoints_out): Declare.
	* mem-break.c (mark_breakpoints_out): New.
	(free_all_breakpoints): Use it.
	* server.c (handle_target_event): If the process is gone, mark
	breakpoints out.
	* thread-db.c (struct thread_db) <create_bp>: New field.
	(thread_db_enable_reporting): Fix prototype.  Store a thread event
	breakpoint reference in the thread_db struct.
	(thread_db_load_search): Clear the thread_db object.
	(try_thread_db_load_1): Ditto.
	(switch_to_process): New.
	(disable_thread_event_reporting): Use it.
	(remove_thread_event_breakpoints): New.
	(thread_db_detach, thread_db_mourn): Use it.
@
text
@d140 4
a143 2
  err = (*the_target->read_memory) (where, bp->old_data,
				    breakpoint_len);
d174 296
d516 11
a526 2
	      ret = (*the_target->write_memory) (bp->pc, bp->old_data,
						 breakpoint_len);
d736 10
a745 2
      err = (*the_target->write_memory) (bp->pc, bp->old_data,
					 breakpoint_len);
d939 1
d943 29
d1013 1
d1017 32
@


1.20
log
@	gdb/gdbserver/
	* server.h (LONGEST): New.
	(struct thread_info) <while_stepping>: New field.
	(unpack_varlen_hex, xrealloc, pulongest, plongest, phex_nz):
	Declare.
	(initialize_tracepoint, handle_tracepoint_general_set)
	(handle_tracepoint_query, tracepoint_finished_step)
	(tracepoint_was_hit, release_while_stepping_state_list):
	(current_traceframe): Declare.
	* server.c (handle_general_set): Handle tracepoint packets.
	(read_memory): New.
	(write_memory): New.
	(handle_search_memory_1): Use read_memory.
	(handle_query): Report support for conditional tracepoints, trace
	state variables, and tracepoint sources.  Handle tracepoint
	queries.
	(main): Initialize the tracepoints module.
	(process_serial_event): Handle traceframe reads/writes.

	* linux-low.c (handle_tracepoints): New.
	(linux_wait_1): Call it.
	(linux_resume_one_lwp): Handle while-stepping.
	(linux_supports_tracepoints, linux_read_pc, linux_write_pc): New.
	(linux_target_ops): Install them.
	* linux-low.h (struct linux_target_ops) <supports_tracepoints>:
	New field.
	* linux-x86-low.c (x86_supports_tracepoints): New.
	(the_low_target). Install it.

	* mem-break.h (delete_breakpoint): Declare.
	* mem-break.c (delete_breakpoint): Make external.

	* target.h (struct target_ops): Add `supports_tracepoints',
	`read_pc', and `write_pc' fields.
	(target_supports_tracepoints): Define.
	* utils.c (xrealloc, decimal2str, pulongest, plongest, thirty_two)
	(phex_nz): New.

	* regcache.h (struct regcache) <registers_owned>: New field.
	(init_register_cache, regcache_cpy): Declare.
	(regcache_read_pc, regcache_write_pc): Declare.
	(register_cache_size): Declare.
	(supply_regblock): Declare.
	* regcache.c (init_register_cache): New.
	(new_register_cache): Use it.
	(regcache_cpy): New.
	(register_cache_size): New.
	(supply_regblock): New.
	(regcache_read_pc, regcache_write_pc): New.

	* tracepoint.c: New.

	* Makefile.in (OBS): Add tracepoint.o.
	(tracepoint.o): New rule.

	gdb/
	* regformats/regdat.sh: Include server.h.  Don't include
	regcache.h.
@
text
@d719 1
a719 2
/* Release all breakpoints, but do not try to un-insert them from the
   inferior.  */
d722 1
a722 1
free_all_breakpoints (struct process_info *proc)
d728 9
@


1.19
log
@	* mem-break.c (struct raw_breakpoint): New field shlib_disabled.
	(set_gdb_breakpoint_at): If GDB is inserting a breakpoint on top
	of another, then delete the previous, and validate all
	breakpoints.
	(validate_inserted_breakpoint): New.
	(delete_disabled_breakpoints): New.
	(validate_breakpoints): New.
	(check_mem_read): Validate breakpoints before trusting their
	shadow.  Delete disabled breakpoints.
	(check_mem_write): Validate breakpoints before trusting they
	should be inserted.  Delete disabled breakpoints.
	* mem-break.h (validate_breakpoints):
	* server.c (handle_query): Validate breakpoints when we see a
	qSymbol query.
@
text
@d305 1
a305 1
static int
@


1.18
log
@	* linux-low.c (linux_wait_1): Avoid setting need_step_over is
	there's a GDB breakpoint at stop_pc.  Always report a trap to GDB
	if we could tell there's a GDB breakpoint at stop_pc.
	(need_step_over_p): Don't do a step over if we find a GDB
	breakpoint at the resume PC.

	* mem-break.c (struct raw_breakpoint): New.
	(enum bkpt_type): New type `gdb_breakpoint'.
	(struct breakpoint): Delete the `PC', `old_data' and `inserted'
	fields.  New field `raw'.
	(find_raw_breakpoint_at): New.
	(set_raw_breakpoint_at): Handle refcounting.  Create a raw
	breakpoint instead.
	(set_breakpoint_at): Adjust.
	(delete_raw_breakpoint): New.
	(release_breakpoint): New.
	(delete_breakpoint): Rename to...
	(delete_breakpoint_1): ... this.  Add proc parameter.  Use
	release_breakpoint.  Return ENOENT.
	(delete_breakpoint): Reimplement.
	(find_breakpoint_at): Delete.
	(find_gdb_breakpoint_at): New.
	(delete_breakpoint_at): Delete.
	(set_gdb_breakpoint_at): New.
	(delete_gdb_breakpoint_at): New.
	(gdb_breakpoint_here): New.
	(set_reinsert_breakpoint): Use release_breakpoint.
	(uninsert_breakpoint): Rename to ...
	(uninsert_raw_breakpoint): ... this.
	(uninsert_breakpoints_at): Adjust to handle raw breakpoints.
	(reinsert_raw_breakpoint): Change parameter type to
	raw_breakpoint.
	(reinsert_breakpoints_at): Adjust to handle raw breakpoints
	instead.
	(check_breakpoints): Adjust.  Use release_breakpoint.
	(breakpoint_here): Rewrite using find_raw_breakpoint_at.
	(breakpoint_inserted_here): Ditto.
	(check_mem_read): Adjust to iterate over raw breakpoints instead.
	Don't trust the breakpoint's shadow if it is not inserted.
	(check_mem_write): Adjust to iterate over raw breakpoints instead.
	(delete_all_breakpoints): Adjust.
	(free_all_breakpoints): Mark all breakpoints as uninserted, and
	use delete_breakpoint_1.

	* mem-break.h (breakpoints_supported): Delete declaration.
	(set_gdb_breakpoint_at): Declare.
	(gdb_breakpoint_here): Declare.
	(delete_breakpoint_at): Delete.
	(delete_gdb_breakpoint_at): Declare.

	* server.h (struct raw_breakpoint): Forward declare.
	(struct process_info): New field `raw_breakpoints'.

	* linux-x86-low.c (x86_insert_point, x86_remote_point): Handle Z0
	breakpoints.
@
text
@d68 4
d333 18
d562 57
d625 1
d651 6
a656 1
	memcpy (buf + buf_offset, bp->old_data + copy_offset, copy_len);
d658 3
d669 1
d696 6
a701 1
	memcpy (buf + buf_offset, breakpoint_data + copy_offset, copy_len);
d703 3
@


1.17
log
@	* mem-break.c (enum bkpt_type): New.
	(struct breakpoint): New field `type'.
	(set_breakpoint_at): Change return type to struct breakpoint
	pointer.  Set type to `other_breakpoint' by default.
	(delete_breakpoint): Rewrite, supporting more than one breakpoint
	in the breakpoint list.
	(delete_reinsert_breakpoints): Only delete reinsert breakpoints.
	(reinsert_breakpoint): Rename to ...
	(reinsert_raw_breakpoint): ... this.
	(reinsert_breakpoints_at): Adjust.
	* mem-break.h (struct breakpoint): Declare.
	(set_breakpoint_at): Change return type to struct breakpoint
	pointer.
@
text
@d29 41
d73 3
d84 1
a87 6
  CORE_ADDR pc;
  unsigned char old_data[MAX_BREAKPOINT_LEN];

  /* Non-zero if this breakpoint is currently inserted in the
     inferior.  */
  int inserted;
d92 4
d97 2
a98 1
     the breakpoint shall be deleted; 0, it will be left inserted.  */
d102 5
a106 1
static void uninsert_breakpoint (struct breakpoint *bp);
d108 8
a115 1
static struct breakpoint *
d119 1
a119 1
  struct breakpoint *bp;
d125 7
d134 1
d163 2
a164 2
  bp->next = proc->breakpoints;
  proc->breakpoints = bp;
d173 1
d175 1
a175 1
  bp = set_raw_breakpoint_at (where);
d177 1
a177 1
  if (bp == NULL)
d185 2
d195 75
a269 2
static void
delete_breakpoint (struct breakpoint *todel)
a270 1
  struct process_info *proc = current_process ();
d272 1
d283 6
a288 3
	  uninsert_breakpoint (bp);
	  free (bp);
	  return;
d298 8
d309 1
a309 1
find_breakpoint_at (CORE_ADDR where)
d312 1
a312 1
  struct breakpoint *bp = proc->breakpoints;
d314 3
a316 6
  while (bp != NULL)
    {
      if (bp->pc == where)
	return bp;
      bp = bp->next;
    }
d321 38
a358 2
void
delete_breakpoint_at (CORE_ADDR addr)
d360 3
a362 3
  struct breakpoint *bp = find_breakpoint_at (addr);
  if (bp != NULL)
    delete_breakpoint (bp);
a370 1

d388 1
a388 7

	  /* If something goes wrong, maybe this is a shared library
	     breakpoint, and the shared library has been unmapped.
	     Assume the breakpoint is gone anyway.  */
	  uninsert_breakpoint (bp);
	  free (bp);

d400 1
a400 1
uninsert_breakpoint (struct breakpoint *bp)
d424 1
a424 1
  struct breakpoint *bp;
d426 1
a426 1
  bp = find_breakpoint_at (pc);
d440 1
a440 1
    uninsert_breakpoint (bp);
d444 1
a444 1
reinsert_raw_breakpoint (struct breakpoint *bp)
d464 1
a464 1
  struct breakpoint *bp;
d466 1
a466 1
  bp = find_breakpoint_at (pc);
d473 1
a473 1
		 "Could not find breakpoint at 0x%s "
d493 1
a493 1
      if (bp->pc == stop_pc)
d495 1
a495 1
	  if (!bp->inserted)
d505 1
a505 1
	      delete_breakpoint (bp);
d527 1
a527 8
  struct process_info *proc = current_process ();
  struct breakpoint *bp;

  for (bp = proc->breakpoints; bp != NULL; bp = bp->next)
    if (bp->pc == addr)
      return 1;

  return 0;
d533 1
a533 2
  struct process_info *proc = current_process ();
  struct breakpoint *bp;
d535 1
a535 3
  for (bp = proc->breakpoints; bp != NULL; bp = bp->next)
    if (bp->pc == addr && bp->inserted)
      return 1;
d537 1
a537 1
  return 0;
d544 1
a544 1
  struct breakpoint *bp = proc->breakpoints;
d570 2
a571 1
      memcpy (buf + buf_offset, bp->old_data + copy_offset, copy_len);
d579 1
a579 1
  struct breakpoint *bp = proc->breakpoints;
d619 1
a619 1
    delete_breakpoint (proc->breakpoints);
d628 4
a631 1
  struct breakpoint *bp;
d633 4
d638 1
a638 5
    {
      bp = proc->breakpoints;
      proc->breakpoints = bp->next;
      free (bp);
    }
@


1.16
log
@	Teach linux gdbserver to step-over-breakpoints.

	* linux-low.c (can_hardware_single_step): New.
	(supports_breakpoints): New.
	(handle_extended_wait): If stopping threads, read the stop pc of
	the new cloned LWP.
	(get_pc): New.
	(get_stop_pc): Add `lwp' parameter.  Handle it.  Bail out if the
	low target doesn't support retrieving the PC.
	(add_lwp): Set last_resume_kind to resume_continue.
	(linux_attach_lwp_1): Adjust comments.  Always set stop_expected.
	(linux_attach): Don't clear stop_expected.  Set the lwp's
	last_resume_kind to resume_stop.
	(linux_detach_one_lwp): Don't check for removed breakpoints.
	(check_removed_breakpoint): Delete.
	(status_pending_p): Rename to ...
	(status_pending_p_callback): ... this.  Don't check for removed
	breakpoints.  Don't consider threads that are stopped from GDB's
	perspective.
	(linux_wait_for_lwp): Always read the stop_pc here.
	(cancel_breakpoint): New.
	(step_over_bkpt): New global.
	(linux_wait_for_event_1): Implement stepping over breakpoints.
	(gdb_wants_lwp_stopped): New.
	(gdb_wants_all_stopped): New.
	(linux_wait_1): Tag threads as gdb-wants-stopped.  Cancel finished
	single-step traps here.  Store the thread's last reported target
	wait status.
	(send_sigstop): Don't clear stop_expected.  Always set it,
	instead.
	(mark_lwp_dead): Remove reference to pending_is_breakpoint.
	(cancel_finished_single_step): New.
	(cancel_finished_single_steps): New.
	(wait_for_sigstop): Don't cancel finished single-step traps here.
	(linux_resume_one_lwp): Don't check for removed breakpoints.
	Don't set `step' on non-hardware step archs.
	(linux_set_resume_request): Ignore resume_stop requests if already
	stopping or stopped.  Set the lwp's last_resume_kind.
	(resume_status_pending_p): Don't check for removed breakpoints.
	(need_step_over_p): New.
	(start_step_over): New.
	(finish_step_over): New.
	(linux_resume_one_thread): Always queue a sigstop for resume_stop
	requests.  Clear the thread's last reported target waitstatus.
	Don't use the `suspended' flag.  Don't consider pending breakpoints.
	(linux_resume): Start a step-over if necessary.
	(proceed_one_lwp): New.
	(proceed_all_lwps): New.
	(unstop_all_lwps): New.
	* linux-low.h (struct lwp_info): Rewrite comment for the
	`suspended' flag.  Add the `stop_pc' field.  Delete the
	`pending_stop_pc' field.  Tweak the `stepping' flag's comment.
	Add `'last_resume_kind' and `need_step_over' fields.
	* inferiors.c (struct thread_info): Delete, moved elsewhere.
	* mem-break.c (struct breakpoint): Delete `reinserting' flag.
	Delete `breakpoint_to_reinsert' field.  New flag `inserted'.
	(set_raw_breakpoint_at): New.
	(set_breakpoint_at): Rewrite to use it.
	(reinsert_breakpoint_handler): Delete.
	(set_reinsert_breakpoint): New.
	(reinsert_breakpoint_by_bp): Delete.
	(delete_reinsert_breakpoints): New.
	(uninsert_breakpoint): Rewrite.
	(uninsert_breakpoints_at): New.
	(reinsert_breakpoint): Rewrite.
	(reinsert_breakpoints_at): New.
	(check_breakpoints): Rewrite.
	(breakpoint_here): New.
	(breakpoint_inserted_here): New.
	(check_mem_read): Adjust.
	* mem-break.h (breakpoints_supported, breakpoint_here)
	(breakpoint_inserted_here, set_reinsert_breakpoint): Declare.
	(reinsert_breakpoint_by_bp): Delete declaration.
	(delete_reinsert_breakpoints): Declare.
	(reinsert_breakpoint): Delete declaration.
	(reinsert_breakpoints_at): Declare.
	(uninsert_breakpoint): Delete declaration.
	(uninsert_breakpoints_at): Declare.
	(check_breakpoints): Adjust prototype.
	* server.h: Adjust include order.
	(struct thread_info): Declare here.  Add a `last_status' field.
@
text
@d29 11
d50 3
d58 2
d105 1
a105 1
void
d116 1
a116 1
      return;
d120 1
d125 2
d130 1
a130 1
delete_breakpoint (struct breakpoint *bp)
d133 1
a133 1
  struct breakpoint *cur;
d135 4
a138 1
  if (proc->breakpoints == bp)
d140 1
a140 10
      proc->breakpoints = bp->next;
      (*the_target->write_memory) (bp->pc, bp->old_data,
				   breakpoint_len);
      free (bp);
      return;
    }
  cur = proc->breakpoints;
  while (cur->next)
    {
      if (cur->next == bp)
d142 3
a144 3
	  cur->next = bp->next;
	  (*the_target->write_memory) (bp->pc, bp->old_data,
				       breakpoint_len);
d148 5
d154 1
d185 5
a189 1
  set_breakpoint_at (stop_at, NULL);
d203 17
a219 3
      *bp_link = bp->next;
      delete_breakpoint (bp);
      bp = *bp_link;
d268 1
a268 1
reinsert_breakpoint (struct breakpoint *bp)
d303 1
a303 1
  reinsert_breakpoint (bp);
@


1.15
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d35 3
a37 7
  /* Non-zero iff we are stepping over this breakpoint.  */
  int reinserting;

  /* Non-NULL iff this breakpoint was inserted to step over
     another one.  Points to the other breakpoint (which is also
     in the *next chain somewhere).  */
  struct breakpoint *breakpoint_to_reinsert;
d40 1
a40 2
     the breakpoint will be deleted; 0, it will be reinserted for
     another round.  */
d44 2
a45 2
void
set_breakpoint_at (CORE_ADDR where, int (*handler) (CORE_ADDR))
d49 1
d54 34
a87 2
  bp = xmalloc (sizeof (struct breakpoint));
  memset (bp, 0, sizeof (struct breakpoint));
d89 5
a93 4
  (*the_target->read_memory) (where, bp->old_data,
			      breakpoint_len);
  (*the_target->write_memory) (where, breakpoint_data,
			       breakpoint_len);
d95 9
a103 1
  bp->pc = where;
d163 2
a164 2
static int
reinsert_breakpoint_handler (CORE_ADDR stop_pc)
d166 2
a167 1
  struct breakpoint *stop_bp, *orig_bp;
d169 5
a173 3
  stop_bp = find_breakpoint_at (stop_pc);
  if (stop_bp == NULL)
    error ("lost the stopping breakpoint.");
d175 2
a176 3
  orig_bp = stop_bp->breakpoint_to_reinsert;
  if (orig_bp == NULL)
    error ("no breakpoint to reinsert");
d178 6
a183 4
  (*the_target->write_memory) (orig_bp->pc, breakpoint_data,
			       breakpoint_len);
  orig_bp->reinserting = 0;
  return 1;
d186 2
a187 2
void
reinsert_breakpoint_by_bp (CORE_ADDR stop_pc, CORE_ADDR stop_at)
d189 3
a191 1
  struct breakpoint *bp, *orig_bp;
d193 6
a198 3
  orig_bp = find_breakpoint_at (stop_pc);
  if (orig_bp == NULL)
    error ("Could not find original breakpoint in list.");
d200 6
a205 10
  set_breakpoint_at (stop_at, reinsert_breakpoint_handler);

  bp = find_breakpoint_at (stop_at);
  if (bp == NULL)
    error ("Could not find breakpoint in list (reinserting by breakpoint).");
  bp->breakpoint_to_reinsert = orig_bp;

  (*the_target->write_memory) (orig_bp->pc, orig_bp->old_data,
			       breakpoint_len);
  orig_bp->reinserting = 1;
d209 1
a209 1
uninsert_breakpoint (CORE_ADDR stopped_at)
d213 1
a213 1
  bp = find_breakpoint_at (stopped_at);
d215 10
a224 1
    error ("Could not find breakpoint in list (uninserting).");
d226 2
a227 3
  (*the_target->write_memory) (bp->pc, bp->old_data,
			       breakpoint_len);
  bp->reinserting = 1;
d230 2
a231 2
void
reinsert_breakpoint (CORE_ADDR stopped_at)
d233 1
a233 1
  struct breakpoint *bp;
d235 1
a235 4
  bp = find_breakpoint_at (stopped_at);
  if (bp == NULL)
    error ("Could not find breakpoint in list (uninserting).");
  if (! bp->reinserting)
d238 8
a245 3
  (*the_target->write_memory) (bp->pc, breakpoint_data,
			       breakpoint_len);
  bp->reinserting = 0;
d248 2
a249 2
int
check_breakpoints (CORE_ADDR stop_pc)
d253 1
a253 1
  bp = find_breakpoint_at (stop_pc);
a254 2
    return 0;
  if (bp->reinserting)
d256 8
a263 2
      warning ("Hit a removed breakpoint?");
      return 0;
d266 13
a278 1
  if ((*bp->handler) (bp->pc))
d280 21
a300 2
      delete_breakpoint (bp);
      return 2;
a301 2
  else
    return 1;
d311 26
d402 1
a402 1
      if (bp->reinserting == 0)
@


1.14
log
@2009-04-01  Pedro Alves  <pedro@@codesourcery.com>

	Implement the multiprocess extensions, and add linux multiprocess
	support.

	* server.h (ULONGEST): Declare.
	(struct ptid, ptid_t): New.
	(minus_one_ptid, null_ptid): Declare.
	(ptid_build, pid_to_ptid, ptid_get_pid, ptid_get_lwp)
	(ptid_get_tid, ptid_equal, ptid_is_pid): Declare.
	(struct inferior_list_entry): Change `id' type from unsigned from
	to ptid_t.
	(struct sym_cache, struct breakpoint, struct
	process_info_private): Forward declare.
	(struct process_info): Declare.
	(current_process): Declare.
	(all_processes): Declare.
	(initialize_inferiors): Declare.
	(add_thread): Adjust to use ptid_t.
	(thread_id_to_gdb_id, thread_to_gdb_id, gdb_id_to_thread_id): Ditto.
	(add_process, remove_process, find_thread_pid): Declare.
	(find_inferior_id): Adjust to use ptid_t.
	(cont_thread, general_thread, step_thread): Change type to ptid_t.
	(multi_process): Declare.
	(push_event): Adjust to use ptid_t.
	(read_ptid, write_ptid): Declare.
	(prepare_resume_reply): Adjust to use ptid_t.
	(clear_symbol_cache): Declare.
	* inferiors.c (all_processes): New.
	(null_ptid, minus_one_ptid): New.
	(ptid_build, pid_to_ptid, ptid_get_pid, ptid_get_lwp)
	(ptid_get_tid, ptid_equal, ptid_is_pid): New.
	(add_thread): Change unsigned long to ptid.  Remove gdb_id
	parameter.  Adjust.
	(thread_id_to_gdb_id, thread_to_gdb_id): Change unsigned long to ptid.
	(gdb_id_to_thread): Rename to ...
	(find_thread_pid): ... this.  Change unsigned long to ptid.
	(gdb_id_to_thread_id, find_inferior_id): Change unsigned long to ptid.
	(loaded_dll, pull_pid_from_list): Adjust.
	(add_process, remove_process, find_process_pid)
	(get_thread_process, current_process, initialize_inferiors): New.
	* target.h (struct thread_resume) <thread>: Change type to ptid_t.
	(struct target_waitstatus) <related_pid>: Ditto.
	(struct target_ops) <kill, detach>: Add `pid' argument.  Change
	return type to int.
	(struct target_ops) <join>: Add `pid' argument.
	(struct target_ops) <thread_alive>: Change pid's type to ptid_t.
	(struct target_ops) <wait>: Add `ptid' field.  Change return type
	to ptid.
	(kill_inferior, detach_inferior, join_inferior): Add `pid' argument.
	(mywait): Add `ptid' argument.  Change return type to ptid_t.
	(target_pid_to_str): Declare.
	* target.c (set_desired_inferior): Adjust to use ptids.
	(mywait): Add new `ptid' argument.  Adjust.
	(target_pid_to_str): New.
	* mem-break.h (free_all_breakpoints): Declare.
	* mem-break.c (breakpoints): Delelete.
	(set_breakpoint_at, delete_breakpoint, find_breakpoint_at)
	(check_mem_read, check_mem_write, delete_all_breakpoints): Adjust
	to use per-process breakpoint list.
	(free_all_breakpoints): New.
	* remote-utils.c (struct sym_cache) <name>: Drop `const'.
	(symbol_cache, all_symbols_looked_up): Delete.
	(hexchars): New.
	(ishex, unpack_varlen_hex, write_ptid, hex_or_minus_one,
	read_ptid): New.
	(prepare_resume_reply): Change ptid argument's type from unsigned
	long to ptid_t.  Adjust.  Implement W;process and X;process.
	(free_sym_cache, clear_symbol_cache): New.
	(look_up_one_symbol): Adjust to per-process symbol cache.  *
	* server.c (cont_thread, general_thread, step_thread): Change type
	to ptid_t.
	(attached): Delete.
	(multi_process): New.
	(last_ptid): Change type to ptid_t.
	(struct vstop_notif) <ptid>: Change type to ptid_t.
	(queue_stop_reply, push_event): Change `ptid' argument's type to
	ptid_t.
	(discard_queued_stop_replies): Add `pid' argument.
	(start_inferior): Adjust to use ptids.  Adjust to mywait interface
	changes.  Don't reference the `attached' global.
	(attach_inferior): Adjust to mywait interface changes.
	(handle_query): Adjust to use ptids.  Parse GDB's qSupported
	features.  Handle and report "multiprocess+".  Handle
	"qAttached:PID".
	(handle_v_cont): Adjust to use ptids.  Adjust to mywait interface
	changes.
	(handle_v_kill): New.
	(handle_v_stopped): Adjust to use target_pid_to_str.
	(handle_v_requests): Allow multiple attaches and runs when
	multiprocess extensions are in effect.  Handle "vKill".
	(myresume): Adjust to use ptids.
	(queue_stop_reply_callback): Add `arg' parameter.  Handle it.
	(handle_status): Adjust to discard_queued_stop_replies interface
	change.
	(first_thread_of, kill_inferior_callback)
	(detach_or_kill_inferior_callback, join_inferiors_callback): New.
	(main): Call initialize_inferiors.  Adjust to use ptids, killing
	and detaching from all inferiors.  Handle multiprocess packet
	variants.
	* linux-low.h: Include gdb_proc_service.h.
	(struct process_info_private): New.
	(struct linux_target_ops) <pid_of>: Use ptid_get_pid.
	<lwpid_of>: Use ptid_get_lwp.
	(get_lwp_thread): Adjust.
	(struct lwp_info): Add `dead' member.
	(find_lwp_pid): Declare.
	* linux-low.c (thread_db_active): Delete.
	(new_inferior): Adjust comment.
	(inferior_pid): Delete.
	(linux_add_process): New.
	(handle_extended_wait): Adjust.
	(add_lwp): Change unsigned long to ptid.
	(linux_create_inferior): Add process to processes table.  Adjust
	to use ptids.  Don't set new_inferior here.
	(linux_attach_lwp): Rename to ...
	(linux_attach_lwp_1): ... this.  Add `initial' argument.  Handle
	it.  Adjust to use ptids.
	(linux_attach_lwp): New.
	(linux_attach): Add process to processes table.  Don't set
	new_inferior here.
	(struct counter): New.
	(second_thread_of_pid_p, last_thread_of_process_p): New.
	(linux_kill_one_lwp): Add `args' parameter.  Handle it.  Adjust to
	multiple processes.
	(linux_kill): Add `pid' argument.  Handle it.  Adjust to multiple
	processes.  Remove process from process table.
	(linux_detach_one_lwp): Add `args' parameter.  Handle it.  Adjust
	to multiple processes.
	(any_thread_of): New.
	(linux_detach): Add `pid' argument, and handle it.  Remove process
	from processes table.
	(linux_join): Add `pid' argument.  Handle it.
	(linux_thread_alive): Change unsighed long argument to ptid_t.
	Consider dead lwps as not being alive.
	(status_pending_p): Rename `dummy' argument to `arg'.  Filter out
	threads we're not interested in.
	(same_lwp, find_lwp_pid): New.
	(linux_wait_for_lwp): Change `pid' argument's type from int to
	ptid_t.  Adjust.
	(linux_wait_for_event): Rename to ...
	(linux_wait_for_event_1): ... this.  Change `pid' argument's type
	from int to ptid_t.  Adjust.
	(linux_wait_for_event): New.
	(linux_wait_1): Add `ptid' argument.  Change return type to
	ptid_t.  Adjust.  Use last_thread_of_process_p.  Remove processes
	that exit from the process table.
	(linux_wait): Add `ptid' argument.  Change return type to ptid_t.
	Adjust.
	(mark_lwp_dead): New.
	(wait_for_sigstop): Adjust to use ptids.  If a process exits while
	stopping all threads, mark its main lwp as dead.
	(linux_set_resume_request, linux_resume_one_thread): Adjust to use
	ptids.
	(fetch_register, usr_store_inferior_registers)
	(regsets_fetch_inferior_registers)
	(regsets_store_inferior_registers, linux_read_memory)
	(linux_write_memory): Inline `inferior_pid'.
	(linux_look_up_symbols): Adjust to use per-process
	`thread_db_active'.
	(linux_request_interrupt): Adjust to use ptids.
	(linux_read_auxv): Inline `inferior_pid'.
	(initialize_low): Don't reference thread_db_active.
	* gdb_proc_service.h (struct ps_prochandle) <pid>: Remove.
	* proc-service.c (ps_lgetregs): Use find_lwp_pid.
	(ps_getpid): Return the pid of the current inferior.
	* thread-db.c (proc_handle, thread_agent): Delete.
	(thread_db_create_event, thread_db_enable_reporting): Adjust to
	per-process data.
	(find_one_thread): Change argument type to ptid_t.  Adjust to
	per-process data.
	(maybe_attach_thread): Adjust to per-process data and ptids.
	(thread_db_find_new_threads): Ditto.
	(thread_db_init): Ditto.
	* spu-low.c (spu_create_inferior, spu_attach): Add process to
	processes table.  Adjust to use ptids.
	(spu_kill, spu_detach): Adjust interface.  Remove process from
	processes table.
	(spu_join, spu_thread_alive): Adjust interface.
	(spu_wait): Adjust interface.  Remove process from processes
	table.  Adjust to use ptids.
	* win32-low.c (current_inferior_tid): Delete.
	(current_inferior_ptid): New.
	(debug_event_ptid): New.
	(thread_rec): Take a ptid.  Adjust.
	(child_add_thread): Add `pid' argument.  Adjust to use ptids.
	(child_delete_thread): Ditto.
	(do_initial_child_stuff): Add `attached' argument.  Add process to
	processes table.
	(child_fetch_inferior_registers, child_store_inferior_registers):
	Adjust.
	(win32_create_inferior): Pass 0 to do_initial_child_stuff.
	(win32_attach): Pass 1 to do_initial_child_stuff.
	(win32_kill): Adjust interface.  Remove process from processes
	table.
	(win32_detach): Ditto.
	(win32_join): Adjust interface.
	(win32_thread_alive): Take a ptid.
	(win32_resume): Adjust to use ptids.
	(get_child_debug_event): Ditto.
	(win32_wait): Adjust interface.  Remove exiting process from
	processes table.
@
text
@d2 1
a2 1
   Copyright (C) 2002, 2003, 2005, 2007, 2008, 2009
@


1.13
log
@        Updated copyright notices for most files.
@
text
@a48 2
struct breakpoint *breakpoints;

d52 1
d69 2
a70 2
  bp->next = breakpoints;
  breakpoints = bp;
d76 1
d79 1
a79 1
  if (breakpoints == bp)
d81 1
a81 1
      breakpoints = bp->next;
d87 1
a87 1
  cur = breakpoints;
d105 2
a106 1
  struct breakpoint *bp = breakpoints;
d229 2
a230 1
  struct breakpoint *bp = breakpoints;
d263 2
a264 1
  struct breakpoint *bp = breakpoints;
d296 1
a296 1
/* Delete all breakpoints.  */
d301 20
a320 2
  while (breakpoints)
    delete_breakpoint (breakpoints);
@


1.12
log
@	* utils.c (xmalloc,xcalloc,xstrdup): New fns.
	* server.h (ATTR_MALLOC): New macro.
	(xmalloc,xcalloc,xstrdup): Declare.
	* hostio.c: Replace malloc,calloc,strdup with xmalloc,xcalloc,xstrdup.
	* inferiors.c: Ditto.
	* linux-low.c: Ditto.
	* mem-break.c: Ditto.
	* regcache.c: Ditto.
	* remote-utils.c: Ditto.
	* server.c: Ditto.
	* target.c: Ditto.
	* win32-low.c: Ditto.
@
text
@d2 2
a3 1
   Copyright (C) 2002, 2003, 2005, 2007, 2008 Free Software Foundation, Inc.
@


1.11
log
@	Updated copyright notices for most files.
@
text
@d58 1
a58 1
  bp = malloc (sizeof (struct breakpoint));
@


1.11.10.1
log
@2008-11-25  Pedro Alves  <pedro@@codesourcery.com>

	2008-10-13  Pedro Alves  <pedro@@codesourcery.com>

	* server.c (discard_pending_stop_replies): Initialize prev.

	2008-10-12  Pedro Alves  <pedro@@codesourcery.com>

	* linux-low.c (linux_wait_1): Cancel breakpoint hits in threads
	we're not reporting.
	(cancel_breakpoints_callback): New.

	2008-10-12  Pedro Alves  <pedro@@codesourcery.com>

	* server.c (queue_stop_reply_callback, handle_status): Pass
	TARGET_SIGNAL_TRAP, not TARGET_SIGNAL_0.

	* linux-low.c (ptid_is_pid): Delete.
	(linux_wait_for_event): In non-stop, don't set the current
	inferior arbitrarily.
	(linux_wait): Flush the event pipe before polling for an event.
	(wait_for_sigstop): In non-stop, don't set the current
	inferior arbitrarily.
	(linux_resume_one_lwp): Small cleanup.
	(cancel_breakpoint): New.
	(linux_resume_one_thread): Use it.  Still report SIGTRAPs.
	(regsets_store_inferior_registers): Plug leak.
	(sigchld_handler): Don't use fprintf here.

	* mem-break.c (breakpoint_at): New.
	* inferiors.c (ptid_is_pid): New.
	* mem-break.h (breakpoint_at): Declare.
	* server.c (discard_queued_stop_replies): Add `pid' argument.
	Handle it.
	(send_next_stop_reply): Cleanup.
	(attach_inferior): Don't wait here in non-stop mode.
	(handle_v_attach): Don't queue stop replies here.
	(handle_v_kill): Discard queued stop replies of the inferior we
	just killed.
	(queue_stop_reply_callback): Add `arg' argument.  Handle it.
	(handle_status): Adjust.
	(kill_inferior_callback): Discard queued stop replies of the
	inferior we just killed.
	(detach_or_kill_inferior_callback): Discard queued stop replies of
	the inferior we just killed or detached from.
	(process_serial_event): Cleanup.  Discard queued stop replies of
	the inferior we just detached.  Don't write 0 bytes to the inferior.
	(handle_serial_event): Debug output.
	* server.h (ptid_is_pid): Declare.

	* remote-utils.c (prepare_resume_reply): Avoid reading registers
	and memory from a thread that is gone.

	2008-09-26  Pedro Alves  <pedro@@codesourcery.com>

	* server.h (struct sym_cache, struct process_info_private):
	Forward declare.
	(struct process_info): Add symbol_cache, all_symbols_looked_up and
	private fields.
	(current_process): Declare.
	* remote-utils.c (struct sym_cache) <name>: Remove constness.
	(symbol_cache): Delete.
	(free_sym_cache, clear_symbol_cache): New.
	(look_up_one_symbol): Adjust, to per-process symbol cache.
	* inferiors.c (current_process): New.

	* linux-low.h: Include "gdb_proc_service.h".
	(struct process_info_private): Define.
	* linux-low.c (thread_db_active): Delete.
	(linux_add_process): New.
	(handle_extended_wait, linux_create_inferior, linux_attach): Use
	it.
	(linux_wait_for_event, linux_look_up_symbols): Adjust.
	(initialize_low): Don't clear the global thread_db_active.
	* thread-db.c (proc_handle, thread_agent): Delete.
	(fixup_proc_handle): New.
	(thread_db_err_str, thread_db_enable_reporting): Use it.  Adjust.
	(thread_db_find_new_threads): Look for the current inferior
	thread, not the first thread in the list.  Use fixup_proc_handle.
	Adjust.
	(thread_db_get_tls_address): Use fixup_proc_handle.
	(thread_db_init): Likewise.  Adjust.

	2008-09-26  Pedro Alves  <pedro@@codesourcery.com>

	* mem-break.c (get_breakpoint_list): Add `create' argument.  Only
	create the list if create is set.
	(remove_breakpoint_list): New.
	(set_breakpoint_at, find_breakpoint_at, check_mem_read)
	(check_mem_write, delete_all_breakpoints): Adjust.

	2008-09-26  Pedro Alves  <pedro@@codesourcery.com>

	* server.c (gdbserver_usage): Describe --remote-debug option.
	(main): Handle --remote-debug switch.

	2008-09-19  Pedro Alves  <pedro@@codesourcery.com>

	Non-stop mode support.

	* linux-low.c (linux_event_pipe): New int array for pipe.
	(target_is_async_p): New.
	(handle_extended_wait): Use my_waitpid.
	(linux_kill_one_lwp): Stop the LWP if it is not stopped already.
	Use my_waitpid, not linux_wait_for_event.  Remove the lwp and the
	corresponding thread from the lists.
	(linux_kill_one_process, linux_kill): Delete.
	(linux_kill_1): Rename back to ...
	(linux_kill) ... this.  Stop the LWP if it is not stopped already.
	Use my_waitpid, not linux_wait_for_event.  Remove the lwp and the
	corresponding thread from the lists.
	(linux_detach_one_lwp): Make sure the LWP is stopped.  Adjust to
	new linux_wait_for_event interface.
	(linux_detach_one_process, linux_detach): Delete.
	(linux_detach_1): Rename back to ...
	(linux_detach): This.
	(linux_join): Add PID argument.  Use my_waitpid instead of
	waitpid.
	(status_pending_p): Ignore suspended threads.
	(my_waitpid): Emulate __WALL.
	(linux_wait_for_lwp): Add 'options' argument.  Handle it.  Use
	my_wait.  If requesting an event from a specific process, leave
	events in other processes pending.
	(resume_stopped_lwps): New.
	(linux_wait_for_event): Delete.
	(linux_wait_for_event_1): Rename back to ...
	(linux_wait_for_event): ... this.  Change interface: add wstat and
	options arguments, return -1 on error, 0 otherwise.  Adjust.  In
	all-stop, resume stopped lwps if there was no pending status.
	Don't return immediatelly if a pending status was found ---
	continue handling it instead.  Don't loop, only handle one event.
	(linux_wait): Rename to ...
	(linux_wait_1): ... this.  Add target_options argument.  Handle
	it.  Don't loop --- only handle one event.  Ignore the continue
	thread in non_stop mode.  Adjust to new resume_kind interface.
	Only stop all threads in all-stop mode.
	(async_file_flush, async_file_mark): New.
	(linux_wait): New.
	(wait_for_sigstop): Set stopping_threads here.  Use
	linux_wait_for_lwp instead of linux_wait_for_event.  Adjust.
	(stop_all_lwps): Don't set stopping_threads here.
	(resume_ptr): Delete.
	(struct resume_info): New.
	(linux_set_resume_request): Add arg argument.  Adjust to take a
	struct remove_info instead of the global resume_ptr.  Accept
	pid,-1 to apply to all threads.
	(linux_continue_one_thread, linux_queue_one_thread): Merge both
	and create ...
	(linux_resume_one_thread): ... this.  New.  Handle rk_stop.
	(resume_status_pending_p): Assume no resume info to mean do
	nothing.  Ignore suspended LWPs.
	(linux_resume): Add n argument.  Adjust.  In non-stop mode, don't
	look for a pending status over all threads.
	(linux_read_offsets): Minor cleanup.
	(sigchld_handler, linux_async, linux_start_non_stop): New.
	(linux_target_ops): Register linux_async and linux_start_non_stop.
	(initialize_low): Register sigchld_handler as SIGCHLD handler.

	* utils.c (internal_verror, internal_error_file_line): New.

	* Makefile.in (SFILES): Add event-loop.c.
	(OBS): Add event-loop.o.
	(event-loop.o): New rule.

	* linux-low.h (struct lwp_info) <suspended>: New flag.

	* thread-db.c (thread_db_create_event): Make sure thread_db reads
	from the current inferior.
	(thread_db_get_tls_address): Comment.

	* server.c (thread_from_wait, old_thread_from_wait, attached):
	Delete.
	(non_stop): New global.
	(own_buf, mem_buf): New globals.
	(struct vstop_notif): New.
	(notif_queue): New.
	(queue_stop_reply, push_event, discard_queued_stop_replies)
	(send_next_stop_reply): New.
	(start_inferior): Adjust to new thread_resume interface.  Adjust
	to new mywait interface.
	(attach_inferior): Adjust.
	(handle_general_set): Handle QNonStop.
	(handle_query): Pass 'QNonStop+'.
	(handle_v_cont): Handle vCont;t.  Don't enable/disable async io in
	non-stop mode.  In non-stop return OK, and don't wait for the
	target.
	(handle_v_attach): In non-stop, return OK, and queue events for
	all threads.
	(handle_v_run): In non-stop, set the general thread here.
	(handle_v_stopped): New.
	(handle_v_requests): Report support for 't'.  Handle 'vStopped'.
	(proceed): Add comment.  Adjust.  In non-stop, don't
	enable/disable async io; write 'OK', and don't wait for the
	target.
	(queue_stop_reply_callback, handle_status): New.
	(kill_inferior_callback, detach_or_kill_inferior_callback)
	(join_inferiors_callback): New.
	(main): In --debug mode, also enable remote debug.  Don't pass -1
	to kill_inferior or detach_inferior; instead, iterate over all
	processes killing or detaching them.  Adjust to use the even-loop.
	(process_serial_event): New, factored out of main.  If the
	connection closed, remove all sources from the event loop.
	Iterate over all inferiors joining them.  Use handle_status.
	Don't print inferior exit notices here.  In non-stop, defer
	exiting until GDB read all queued events.
	(handle_serial_event, handle_target_event): New.

	* server.h (FOR_EACH_INFERIOR): New.
	(thread_from_wait, old_thread_from_wait): Remove.
	(non_stop): Declare.
	(gdb_client_data, handler_func): New typedefs.
	(delete_file_handler, add_file_handler, start_event_loop)
	(handle_serial_event, handle_target_event, push_event)
	(putpkt_notif, internal_error_file_line): Declare.
	(internal_error): Define.

	* target.c (mywait): Add `options' argument.  Print inferior exit
	notices here.
	(start_non_stop): New.

	* event-loop.c: New.

	* remote-utils.c (remote_open): Register remote_desc in the event
	loop, with handle_serial_event as callback.
	(remote_close): Remove remote_desc from the event loop.
	(hex_or_minus_one): New.
	(read_ptid, read_ptid): Use it.
	(putpkt_binary): Rename to ...
	(putpkt_binary_1): ... this.  Add `notif' argument.  Handle
	pushing a remote protocol notification.
	(putpkt_binary): New as wrapper around putpkt_binary_1.
	(putpkt_notif): New.
	(getpkt): Debug output.
	(prepare_resume_reply): Remove dead code.  In non-stop, don't set
	the general thread here.

	* target.h (enum resume_kind): New.
	(struct thread_resume) <leave_stopped, step>: Delete.
	(struct thread_resume) <kind>: New field.
	(TARGET_WNOHANG): Define.
	(struct target_ops) <kill, detach>: Adjust comments.
	(struct target_ops) <join>: Add `pid' argument.
	(struct target_ops) <resume>: Add `n' argument.
	(struct target_ops) <wait>: Add `options' argument.
	(struct target_ops) <async, start_non_stop>: New fields.
	(join_inferior): Add `pid' argument.
	(target_async): New.
	(start_non_stop): Declare.
	(mywait): Add options argument.

	2008-09-15  Pedro Alves  <pedro@@codesourcery.com>

	* linux-low.c (new_inferior): Mention in the comment that all
	inferiors should have the same architecture for now.
	(linux_create_inferior, linux_attach): Only set new_inferior if
	this is the first process.

	2008-08-29  Pedro Alves  <pedro@@codesourcery.com>

	* linux-low.c (ptid_is_pid): Move higher.
	(linux_wait_for_lwp): Remove dead code.
	(linux_wait_for_event): Rename to ...
	(linux_wait_for_event_1): ... this.
	(linux_wait_for_event): New.
	(ptid_same_pid): Delete.
	(linux_set_resume_request): Clearify.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* linux-low.c (handle_extended_wait, linux_attach_lwp)
	(linux_attach): Minor cleanups.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* linux-low.c (linux_thread_alive): Return false for a listed
	thread known to be dead.
	(linux_wait_for_event): Don't set the dead flag here.
	(wait_for_sigstop): Store ptid before waiting for the event.
	Minor cleanup.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* inferiors.c (find_inferior): Allow deleting the current iterated
	inferior.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* linux-low.c (linux_pid_to_exec_file): Move higher.
	(linux_enable_event_reporting): Enable PTRACE_O_TRACEEXEC.
	(handle_extended_wait): Handle PTRACE_EVENT_EXEC.

	* remote-utils.c (prepare_resume_reply): Set the general thread to
	the last thread that had an event in TARGET_WAITKIND_FORKED and
	TARGET_WAITKIND_VFORKED.  Handle TARGET_WAITKIND_EXECD.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* server.c (handle_query): Pass "QExecFile:PID;" back in the reply.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* linux-low.c (linux_supports_tracefork_flag): Move higher.
	(linux_enable_event_reporting): New.
	(handle_extended_wait): Change return type to int.  Handle
	PTRACE_EVENT_FORK and PTRACE_EVENT_VFORK.
	(add_lwp): Set waitstatus.kind to TARGET_WAITKIND_IGNORE.
	(linux_attach_lwp): Use linux_enable_event_reporting.
	(linux_wait_for_event): Don't keep waiting if the extended wait
	status should be reported to gdb.
	(linux_wait): Use linux_enable_event_reporting.  If waitstatus
	holds a processed event, return it instead.
	* remote-utils.c (prepare_resume_reply): Handle
	TARGET_WAITKIND_FORKED and TARGET_WAITKIND_VFORKED.
	* linux-low.h (struct lwp_info) <waitstatus>: New member.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* target.h (struct target_ops) <pid_to_exec_file>: New member.
	* server.c (handle_query): Handle qExecFile.
	* linux-low.c (linux_pid_to_exec_file): New.
	(linux_target_ops): Register it.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* linux-low.c (is_lwpid): New.
	(linux_kill_one_lwp, linux_kill_1, linux_detach_one_lwp): Adjust.
	(status_pending_p): Check if we're interested in this lwp.
	(linux_wait_for_lwp): Change signature: return an lwp_info*, and
	take a ptid instead of an lwp_info**.
	(linux_wait_for_event): Take a ptid instead of a thread_info
	pointer.  Adjust.
	(wait_for_sigstop): Adjust.  If a whole process died, keep the
	exit status pending.
	(ptid_is_pid, ptid_same_pid): New.
	(linux_set_resume_request): Allow resuming all threads of a process.
	(resume_status_pending_p): Check for dead lwps.

	* linux-low.h (struct lwp_info) <dead>: New field.

	* server.c (start_inferior): Only resume and wait for events from
	the inferior we're creating.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	Decouple target code from remote protocol.

	* linux-low.c (linux_wait): Change prototype.  Adjust.
	* server.c (last_status, last_ptid): New.
	(start_inferior): Remove "statusptr" argument.  Adjust.
	(attach_inferior, handle_v_cont, handle_v_attach, handle_v_run)
	(handle_v_kill, handle_v_requests): Remove "status" and "signal"
	parameters.  Adjust.
	(myresume): Rename to ...
	(proceed): ... this.  Remove "statusp" parameter.  Adjust.
	(main): Remove "status" local.  Adjust.
	* target.c (mywait): Change prototype.  Adjust.
	* target.h (enum target_waitkind): New.
	(struct target_waitstatus): New.
	(struct target_ops) <wait>: Change prototype.
	(mywait): Adjust.
	* remote-utils.c: Include "target.h".
	(prepare_resume_reply): Change prototype to take a ptid and a
	target_waitstatus.  Adjust.
	* server.h (prepare_resume_reply): Adjust prototype.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* inferiors.c (all_processes): New.
	(add_process): New.

	* linux-low.c (linux_create_inferior): Add process.
	(linux_attach_lwp): Add "initial" parameter, and use it instead of
	relying on having only one thread in the global list.
	(linux_attach): Add process.
	(struct counter): New.
	(check_if_last_thread_of_pid, is_last_thread_of_process): New.
	(linux_kill_one_lwp): Add ARGS parameter.  Change return type to
	int.  Check if we're interested in this lwp.  Use
	is_last_thread_of_process.
	(linux_kill): Rename to ...
	(linux_kill_1): ... this.  Kill lwps of the requested only.
	(linux_kill_one_process): New.
	(linux_kill): New.
	(linux_detach_one_lwp): Add ARGS parameter.  Change return type to
	int.  Check if we're interested in this lwp.  Remove the lwp from
	both the lwp list and the thread list.
	(any_thread_of, linux_detach_1, linux_detach_one_process): New.
	(linux_detach): Reimplement.
	(linux_wait_for_event): Use is_last_thread_of_process.
	(linux_wait): Likewise.  On process exit, don't clear all inferiors.
	Implement multi-process extensions.

	* mem-break.c (breakpoints): Delete.
	(struct breakpoint_list): New.
	(all_breakpoints): New.
	(get_breakpoint_list): New.
	(set_breakpoint_at, delete_breakpoint, find_breakpoint_at)
	(check_mem_read, check_mem_write, delete_all_breakpoints): Use it.

	* server.h (struct process_info): New.
	(all_processes): Declare.
	(add_process): Declare.

	* linux-low.h (linux_attach_lwp): Add "initial" parameter.

	* thread-db.c (maybe_attach_thread): Adjust.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* linux-low.c, linux-low.h, proc-service.c, thread-db.c: Rename
	`struct process_info' to `struct lwp_info', and adjust throughout.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	Implement remote protocol multi-process extensions.

	* inferiors.c (null_ptid, minus_one_ptid): New.
	(ptid_build, pid_to_ptid, ptid_get_pid, ptid_get_lwp)
	(ptid_get_tid, ptid_equal): New functions.
	(add_thread): Drop gdb_id argument.  Retype thread_id argument to
	ptid_t.  Adjust.
	(thread_id_to_gdb_id): Adjust.
	(thread_to_gdb_id): Change return type to ptid_t.  Adjust.
	(gdb_id_to_thread): Rename to ...
	(find_thread_pid): ... this.  Adjust.
	(gdb_id_to_thread_id): Change return type to ptid_t.  Adjust.
	(find_inferior_id): Change id argument type to ptid_t.  Adjust.
	(loaded_dll, add_pid_to_list, pull_pid_from_list): Adjust.
	(initialize_inferiors): New.

	* remote-utils.c (hexchars): New.
	(ishex, unpack_varlen_hex, write_ptid, read_ptid): New.
	(prepare_resume_reply): Adjust.

	* server.c (cont_thread, general_thread, step_thread)
	(thread_from_wait, old_thread_from_wait): Change type to ptid_t.
	(multi_process): New.
	(start_inferior): Adjust.
	(handle_query): Adjust.  Report multiprocess extensions support.
	(handle_v_cont): Adjust.
	(handle_v_kill): New.
	(handle_v_requests): Handle vKill.
	(myresume): Adjust.
	(first_thread_of): New.
	(main): Call initialize_inferiors.  If bailing out, kill all
	inferiors.  Handle multi-process detach.  Handle multi-process H
	and T.

	* server.h (ULONGEST): New typedef.
	(struct ptid): New struct.
	(ptid_t): New typedef.
	(minus_one_ptid, null_ptid): New.
	(ptid_t ptid_build, pid_to_ptid, ptid_get_pid, ptid_get_lwp)
	(ptid_get_tid, ptid_equal): New.
	(struct inferior_list_entry) <id>: Change type to ptid_t.
	(add_thread, thread_id_to_gdb_id, thread_to_gdb_id)
	(gdb_id_to_thread_id): Adjust prototypes.
	(find_thread_pid): Declare.
	(find_inferior_id): Adjust prototype.
	(cont_thread, general_thread, step_thread, thread_from_wait)
	(old_thread_from_wait): Adjust type to ptid_t.
	(multi_process): Declare.
	(read_ptid, write_ptid): Declare.

	* linux-low.c (pid_of): Adjust.
	(lwpid_of): New.
	(inferior_lwpid): New.
	(handle_extended_wait): Adjust.
	(add_process): Change pid argument to a ptid.  Adjust.
	(linux_create_inferior): Adjust.
	(linux_attach_lwp): Adjust.  Clear new_inferior on error.  If
	creating a new inferior, don't rely on inferior_pid, instead use
	the lwpid as pid.
	(linux_attach): Set new_inferior earlier.  Adjust.
	(linux_kill): Change return type to int.  Adjust.
	(linux_detach): Add pid parameter.
	(linux_thread_alive): Change lwpid paremeter type to ptid.
	Adjust.
	(same_lwp, find_lwp_pid): New.
	(linux_wait_for_process): Adjust.
	(linux_wait_for_process, linux_wait_for_event, send_sigstop)
	(wait_for_sigstop, linux_resume_one_process,
	(linux_resume_one_process, linux_set_resume_request)
	(linux_continue_one_thread, linux_queue_one_thread)
	(fetch_register, usr_store_inferior_registers)
	(regsets_fetch_inferior_registers)
	(regsets_store_inferior_registers, linux_read_memory)
	(linux_write_memory, linux_request_interrupt, linux_read_auxv):
	Adjust.

	* linux-low.h (get_process_thread): Adjust.
	(struct process_info) <lwpid>: Remove.
	(find_lwp_pid): Declare.

	* target.c (set_desired_inferior): Adjust.
	(target_pid_to_str): New.

	* target.h (struct thread_resume) <thread>: Change type to ptid_t.
	(struct target_ops) <kill>: Change return type to int, and take an
	int as parameter.
	(struct target_ops) <detach>: Take an int as parameter.
	(struct target_ops) <thread_alive>: Change pid argument type to
	ptid_t.
	(kill_inferior, detach_inferior): Add PID argument.

	* thread-db.c (thread_db_create_event): Adjust.
	(find_one_thread): Change argument to a ptid.  Adjust.
	(maybe_attach_thread, thread_db_get_tls_address, thread_db_init):
	Adjust.

	* proc-service.c (ps_lgetregs): Adjust.
@
text
@d48 1
a48 38
struct breakpoint_list
{
  struct inferior_list_entry head;

  struct breakpoint *breakpoints;
};

/* ``all_breakpoints'' is keyed by process ID.  */

struct inferior_list all_breakpoints;

static struct breakpoint_list *
get_breakpoint_list (int create)
{
  ptid_t ptid;
  int pid;
  struct inferior_list_entry *list;

  ptid = ((struct inferior_list_entry *)current_inferior)->id;
  pid = ptid_get_pid (ptid);

  list = find_inferior_id (&all_breakpoints, pid_to_ptid (pid));

  if (list == NULL && create)
    {
      list = calloc (1, sizeof (struct breakpoint_list));
      list->id = pid_to_ptid (pid);
      add_inferior_to_list (&all_breakpoints, list);
    }

  return (struct breakpoint_list *) list;
}

static void
remove_breakpoint_list (struct breakpoint_list *list)
{
  remove_inferior (&all_breakpoints, &list->head);
}
a52 1
  struct breakpoint_list *list;
a57 2
  list = get_breakpoint_list (1);

d69 2
a70 2
  bp->next = list->breakpoints;
  list->breakpoints = bp;
a75 1
  struct breakpoint_list *list;
d78 1
a78 6
  list = get_breakpoint_list (0);

  if (list == NULL)
    goto out;

  if (list->breakpoints == bp)
d80 1
a80 1
      list->breakpoints = bp->next;
d86 1
a86 1
  cur = list->breakpoints;
a97 2

 out:
d104 1
a104 9
  struct breakpoint_list *list;
  struct breakpoint *bp;

  list = get_breakpoint_list (0);

  if (list == NULL)
    return NULL;

  bp = list->breakpoints;
a216 8
int
breakpoint_at (CORE_ADDR stop_pc)
{
  struct breakpoint *bp;
  bp = find_breakpoint_at (stop_pc);
  return (bp != NULL);
}

d227 2
a228 11
  struct breakpoint_list *list;
  struct breakpoint *bp;
  CORE_ADDR mem_end;

  list = get_breakpoint_list (0);

  if (list == NULL)
    return;

  bp = list->breakpoints;
  mem_end = mem_addr + mem_len;
d260 2
a261 11
  struct breakpoint_list *list;
  struct breakpoint *bp;
  CORE_ADDR mem_end;

  list = get_breakpoint_list (0);

  if (list == NULL)
    return;

  bp = list->breakpoints;
  mem_end = mem_addr + mem_len;
d297 2
a298 11
  struct breakpoint_list *list;

  list = get_breakpoint_list (0);

  if (list == NULL)
    return;

  while (list->breakpoints)
    delete_breakpoint (list->breakpoints);

  remove_breakpoint_list (list);
@


1.10
log
@	* linux-low.c (linux_wait_for_event): Update messages.  Do not
	reinsert auto-delete breakpoints.
	* mem-break.c (struct breakpoint): Change return type of handler to
	int.
	(set_breakpoint_at): Update handler type.
	(reinsert_breakpoint_handler): Return 1 instead of calling
	delete_breakpoint.
	(reinsert_breakpoint_by_bp): Check for the original breakpoint before
	setting a new one.
	(check_breakpoints): Delete auto-delete breakpoints and return 2.
	* mem-break.h (set_breakpoint_at): Update handler type.
	* thread-db.c (thread_db_create_event, thread_db_create_event): Update.
	* win32-low.c (auto_delete_breakpoint): New.
	(get_child_debug_event): Use it.
@
text
@d2 1
a2 1
   Copyright (C) 2002, 2003, 2005, 2007 Free Software Foundation, Inc.
@


1.9
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d42 4
a45 2
  /* Function to call when we hit this breakpoint.  */
  void (*handler) (CORE_ADDR);
d51 1
a51 1
set_breakpoint_at (CORE_ADDR where, void (*handler) (CORE_ADDR))
d124 1
a124 1
static void
d140 1
a140 1
  delete_breakpoint (stop_bp);
a147 2
  set_breakpoint_at (stop_at, reinsert_breakpoint_handler);

d152 2
d208 7
a214 2
  (*bp->handler) (bp->pc);
  return 1;
@


1.8
log
@	* inferiors.c (change_inferior_id): Add comment.
	* linux-low.c (check_removed_breakpoint): Add an early
	prototype.  Improve debug output.
	(linux_attach): Doc update.
	(linux_detach_one_process, linux_detach): Clean up before releasing
	each process.
	(send_sigstop, wait_for_sigstop): Improve comments and debug output.
	* linux-low.h (struct process_info): Doc improvement.
	* mem-break.c (delete_all_breakpoints): New.
	* mem-break.h (delete_all_breakpoints): New prototype.
	* thread-db.c (find_first_thread): New.
	(thread_db_create_event): Call it instead of
	thread_db_find_new_threads.  Clean up unused variables.
	(maybe_attach_thread): Remove first thread handling.
	(thread_db_find_new_threads): Use find_first_thread.
	(thread_db_get_tls_address): Likewise.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d19 1
a19 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.7
log
@gdb/

	* arm-wince-tdep.c: New.
	* config/arm/wince.mt (DEPRECATED_TM_FILE): Use tm-arm.h.
	(MT_CFLAGS): Delete.
	(TM_CLIBS): Delete.
	(TDEPFILES): Add arm-wince-tdep.o, corelow.o, solib.o,
	solib-legacy.o, solib-svr4.o, and remove wince.o.
	* configure.tgt (arm*-*-mingw32ce*): Add.
	* signals/signals.c [HAVE_SIGNAL_H]: Check.
	(do_target_signal_to_host): Silence 'not used' warning.
	* config/arm/tm-wince.h: Remove.

gdb/gdbserver/

	* gdbserver/configure.ac: Add errno checking.
	(AC_CHECK_HEADERS): Add errno.h, fcntl.h, signal.h,
	sys/file.h and malloc.h.
	(AC_CHECK_DECLS): Add perror.
	(srv_mingwce): Handle.
	* gdbserver/configure.srv (i[34567]86-*-cygwin*): Add
	win32-i386-low.o to srv_tgtobj.
	(i[34567]86-*-mingw*): Likewise.
	(arm*-*-mingw32ce*): Add case.
	* gdbreplay.c [HAVE_SYS_FILE_H, HAVE_SIGNAL_H,
	HAVE_FCNTL_H, HAVE_ERRNO_H, HAVE_MALLOC_H]: Check.
	[__MINGW32CE__] (strerror): New function.
	[__MINGW32CE__] (errno): Define to GetLastError.
	[__MINGW32CE__] (COUNTOF): New macro.
	(remote_open): Remove extra close call.
	* mem-break.c (delete_breakpoint_at): New function.
	* mem-break.h (delete_breakpoint_at): Declare.
	* remote-utils.c [HAVE_SYS_FILE_H, HAVE_SIGNAL_H,
	HAVE_FCNTL_H, HAVE_UNISTD_H, HAVE_ERRNO_H]: Check.
	[USE_WIN32API] (read, write): Add char* casts.
	* server.c [HAVE_UNISTD_H, HAVE_SIGNAL_H]: Check.
	* server.h: Include wincecompat.h on Windows CE.
	[HAVE_ERRNO_H]: Check.
	(perror): Declare if not declared.
	* utils.c: Add stdlib.h, errno.h and malloc.h includes.
	(perror_with_name): Remove errno declaration.
	* wincecompat.h: New.
	* wincecompat.c: New.
	* win32-low.h: New.
	* win32-arm-low.c: New.
	* win32-i386-low.c: New.
	(win32-low.c): Include mem-break.h and win32-low.h, and winnt.h.
	(OUTMSG2): Make it safe.
	(_T): New macro.
	(COUNTOF): New macro.
	(NUM_REGS): Get it from the low target.
	(CONTEXT_EXTENDED_REGISTERS, CONTEXT_FLOATING_POINT,
	CONTEXT_DEBUG_REGISTERS): Add fallbacks to 0.
	(thread_rec): Let low target handle debug registers.
	(child_add_thread): Likewise.
	(child_init_thread_list): Likewise.
	(continue_one_thread): Likewise.
	(regptr): New.
	(do_child_fetch_inferior_registers): Move to ...
	* win32-i386-low.c: ... here, and rename to ...
	(do_fetch_inferior_registers): ... this.
	* win32-low.c (child_fetch_inferior_registers):
	Go through the low target.
	(do_child_store_inferior_registers): Use regptr.
	(strwinerror): New function.
	(win32_create_inferior): Handle Windows CE.
	Use strwinerror instead of strerror on Windows error
	codes.  Add program to the error output.
	Don't close the main thread handle on Windows CE.
	(win32_attach): Use coredll.dll on Windows CE.
	(win32_kill): Close current process and current
	thread handles.
	(win32_detach): Use coredll.dll on Windows CE.
	(win32_resume): Let low target handle debug registers, and
	step request.
	(handle_exception): Add/Remove initial breakpoint.  Avoid
	non-existant WSTOPSIG on Windows CE.
	(win32_read_inferior_memory): Cast to remove warning.
	(win32_arch_string): Go through the low target.
	(initialize_low): Call set_breakpoint_data with the low
	target's breakpoint.
	* win32-low.c (dr, FLAG_TRACE_BIT, FCS_REGNUM,
	FOP_REGNUM, mappings): Move to ...
	* win32-i386-low.c: ... here.
	* win32-low.c (win32_thread_info): Move to ...
	* win32-low.h: ... here.
	* Makefile.in (SFILES): Add win32-low.c, win32-i386-low.c,
	win32-arm-low.c and wincecompat.c.
	(all:): Add $EXEEXT.
	(install-only:): Likewise.
	(gdbserver:): Likewise.
	(gdbreplay:): Likewise.
	* config.in: Regenerate.
	* configure: Regenerate.
@
text
@d286 9
@


1.6
log
@Copyright updates for 2007.
@
text
@d116 8
@


1.5
log
@	* linux-arm-low.c:
	* linux-cris-low.c:
	* inferiors.c:
	* i387-fp.h:
	* i387-fp.c:
	* gdbreplay.c:
	* regcache.c:
	* proc-service.c:
	* mem-break.h:
	* mem-break.c:
	* linux-x86-64-low.c:
	* linux-sh-low.c:
	* linux-s390-low.c:
	* linux-ppc64-low.c:
	* linux-ppc-low.c:
	* linux-mips-low.c:
	* linux-m68k-low.c:
	* linux-m32r-low.c:
	* linux-low.h:
	* linux-low.c:
	* linux-ia64-low.c:
	* linux-i386-low.c:
	* linux-crisv32-low.c:
	* thread-db.c:
	* terminal.h:
	* target.h:
	* target.c:
	* server.h:
	* server.c:
	* remote-utils.c:
	* regcache.h:
	* utils.c:
	* Makefile.in:
	* configure.ac:
	* gdbserver.1: Add (C) after Copyright.  Update the FSF
	address.
@
text
@d2 1
a2 2
   Copyright (C) 2002, 2003, 2005
   Free Software Foundation, Inc.
@


1.4
log
@	* acconfig.h: Remove.
	* configure.ac: Add a test for socklen_t.  Use three-argument
	AC_DEFINE throughout.
	* config.in: Regenerated using autoheader 2.59.
	* configure: Regenerated.

	* gdbreplay.c (socklen_t): Provide a default.
	(remote_open): Use socklen_t.
	* remote-utils.c (socklen_t): Provide a default.
	(remote_open): Use socklen_t.
	(convert_int_to_ascii, convert_ascii_to_int, decode_M_packet): Use
	unsigned char.

	* i387-fp.c (struct i387_fsave, struct i387_fxsave): Use unsigned
	char for buffers.
	* linux-low.c (linux_read_memory, linux_write_memory)
	(linux_read_auxv): Likewise.
	* mem-break.c (breakpoint_data, set_breakpoint_data, check_mem_read)
	(check_mem_write): Likewise.
	* mem-break.h (set_breakpoint_data, check_mem_read, check_mem_write):
	Likewise.
	* regcache.c (struct inferior_rgcache_data, registers_to_string)
	(registers_from_string, register_data): Likewise.
	* server.c (handle_query, main): Likewise.
	* server.h (convert_ascii_to_int, convert_int_to_ascii)
	(decode_M_packet): Likewise.
	* target.c (read_inferior_memory, write_inferior_memory): Likewise.
	* target.h (struct target_ops): Update read_memory, write_memory,
	and read_auxv.
	(read_inferior_memory, write_inferior_memory): Update.
	* linux-low.h (struct linux_target_ops): Change type of breakpoint
	to unsigned char *.
	* linux-arm-low.c, linux-cris-low.c, linux-crisv32-low.c,
	linux-i386-low.c, linux-m32r-low.c, linux-m68k-low.c,
	linux-mips-low.c, linux-ppc-low.c, linux-ppc64-low.c,
	linux-s390-low.c, linux-sh-low.c: Update for changes in
	read_inferior_memory and the_low_target->breakpoint.
@
text
@d2 1
a2 1
   Copyright 2002, 2003, 2005
d21 2
a22 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.3
log
@* mem-break.c: Remove whitespace at end of file.
@
text
@d2 1
a2 1
   Copyright 2002
d26 1
a26 1
const char *breakpoint_data;
d206 1
a206 1
set_breakpoint_data (const char *bp_data, int bp_len)
d213 1
a213 1
check_mem_read (CORE_ADDR mem_addr, char *buf, int mem_len)
d246 1
a246 1
check_mem_write (CORE_ADDR mem_addr, char *buf, int mem_len)
@


1.2
log
@2002-05-14  Daniel Jacobowitz  <drow@@mvista.com>

        * gdbserver/mem-break.c (reinsert_breakpoint_by_bp): Correct typo
        stop_at -> stop_pc.
@
text
@a278 2


@


1.2.14.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d279 2
@


1.2.12.1
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@d279 2
@


1.1
log
@2002-04-20  Daniel Jacobowitz  <drow@@mvista.com>

        * gdbserver/mem-break.c: New file.
        * gdbserver/mem-break.h: New file.
        * gdbserver/Makefile.in: Add mem-break.o rule; update server.h
        dependencies.
        * gdbserver/inferiors.c (struct inferior_info): Add target_data
        member.
        (clear_inferiors): Free target_data member if set.
        (inferior_target_data, set_inferior_target_data): New functions.
        * gdbserver/linux-i386-low.c (i386_breakpoint, i386_breakpoint_len)
        (i386_stop_pc, i386_set_pc): New.  Add to the_low_target.
        * gdbserver/linux-low.c (linux_bp_reinsert): New variable.
        (struct inferior_linux_data): New.
        (linux_create_inferior): Use set_inferior_target_data.
        (linux_attach): Likewise.  Call add_inferior.
        (linux_wait_for_one_inferior): New function.
        (linux_wait): Call it.
        (linux_write_memory): Add const.
        (initialize_low): Call set_breakpoint_data.
        * gdbserver/linux-low.h (struct linux_target_ops): Add breakpoint
        handling members.
        * gdbserver/server.c (attach_inferior): Remove extra add_inferior
        call.
        * gdbserver/server.h: Include mem-break.h.  Update inferior.c
        prototypes.
        * gdbserver/target.c (read_inferior_memory)
        (write_inferior_memory): New functions.
        * gdbserver/target.h (read_inferior_memory)
        (write_inferior_memory): Change macros to prototypes.
        (struct target_ops): Update comments.  Add const to write_memory
        definition.
@
text
@d143 1
a143 1
  orig_bp = find_breakpoint_at (stop_at);
@

