head	1.202;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.189
	gdb_7_6-2013-04-26-release:1.189
	gdb_7_6-branch:1.189.0.2
	gdb_7_6-2013-03-12-branchpoint:1.189
	gdb_7_5_1-2012-11-29-release:1.175.2.1
	gdb_7_5-2012-08-17-release:1.175.2.1
	gdb_7_5-branch:1.175.0.2
	gdb_7_5-2012-07-18-branchpoint:1.175
	gdb_7_4_1-2012-04-26-release:1.152.2.2
	gdb_7_4-2012-01-24-release:1.152.2.2
	gdb_7_4-branch:1.152.0.2
	gdb_7_4-2011-12-13-branchpoint:1.152
	gdb_7_3_1-2011-09-04-release:1.142
	gdb_7_3-2011-07-26-release:1.142
	gdb_7_3-branch:1.142.0.2
	gdb_7_3-2011-04-01-branchpoint:1.142
	gdb_7_2-2010-09-02-release:1.125.2.1
	gdb_7_2-branch:1.125.0.2
	gdb_7_2-2010-07-07-branchpoint:1.125
	gdb_7_1-2010-03-18-release:1.108
	gdb_7_1-branch:1.108.0.2
	gdb_7_1-2010-02-18-branchpoint:1.108
	gdb_7_0_1-2009-12-22-release:1.102
	gdb_7_0-2009-10-06-release:1.102
	gdb_7_0-branch:1.102.0.4
	gdb_7_0-2009-09-16-branchpoint:1.102
	arc-sim-20090309:1.66
	msnyder-checkpoint-072509-branch:1.102.0.2
	msnyder-checkpoint-072509-branchpoint:1.102
	arc-insight_6_8-branch:1.66.0.6
	arc-insight_6_8-branchpoint:1.66
	insight_6_8-branch:1.66.0.4
	insight_6_8-branchpoint:1.66
	reverse-20081226-branch:1.82.0.2
	reverse-20081226-branchpoint:1.82
	multiprocess-20081120-branch:1.79.0.2
	multiprocess-20081120-branchpoint:1.79
	reverse-20080930-branch:1.78.0.2
	reverse-20080930-branchpoint:1.78
	reverse-20080717-branch:1.76.0.2
	reverse-20080717-branchpoint:1.76
	msnyder-reverse-20080609-branch:1.73.0.2
	msnyder-reverse-20080609-branchpoint:1.73
	drow-reverse-20070409-branch:1.50.0.2
	drow-reverse-20070409-branchpoint:1.50
	gdb_6_8-2008-03-27-release:1.66
	gdb_6_8-branch:1.66.0.2
	gdb_6_8-2008-02-26-branchpoint:1.66
	gdb_6_7_1-2007-10-29-release:1.56
	gdb_6_7-2007-10-10-release:1.56
	gdb_6_7-branch:1.56.0.2
	gdb_6_7-2007-09-07-branchpoint:1.56
	insight_6_6-20070208-release:1.41
	gdb_6_6-2006-12-18-release:1.41
	gdb_6_6-branch:1.41.0.2
	gdb_6_6-2006-11-15-branchpoint:1.41
	insight_6_5-20061003-release:1.33
	gdb-csl-symbian-6_4_50_20060226-12:1.32.2.1.2.4
	gdb-csl-sourcerygxx-3_4_4-25:1.29
	nickrob-async-20060828-mergepoint:1.39
	gdb-csl-symbian-6_4_50_20060226-11:1.32.2.1.2.4
	gdb-csl-sourcerygxx-4_1-17:1.32.2.1
	gdb-csl-20060226-branch-local-2:1.32.2.1
	gdb-csl-sourcerygxx-4_1-14:1.32.2.1
	gdb-csl-sourcerygxx-4_1-13:1.32.2.1
	gdb-csl-sourcerygxx-4_1-12:1.32.2.1
	gdb-csl-sourcerygxx-3_4_4-21:1.32.2.1
	gdb_6_5-20060621-release:1.33
	gdb-csl-sourcerygxx-4_1-9:1.32.2.1
	gdb-csl-sourcerygxx-4_1-8:1.32.2.1
	gdb-csl-sourcerygxx-4_1-7:1.32.2.1
	gdb-csl-arm-2006q1-6:1.32.2.1
	gdb-csl-sourcerygxx-4_1-6:1.32.2.1
	gdb-csl-symbian-6_4_50_20060226-10:1.32.2.1.2.4
	gdb-csl-symbian-6_4_50_20060226-9:1.32.2.1.2.4
	gdb-csl-symbian-6_4_50_20060226-8:1.32.2.1.2.4
	gdb-csl-coldfire-4_1-11:1.32.2.1
	gdb-csl-sourcerygxx-3_4_4-19:1.32.2.1
	gdb-csl-coldfire-4_1-10:1.32.2.1
	gdb_6_5-branch:1.33.0.4
	gdb_6_5-2006-05-14-branchpoint:1.33
	gdb-csl-sourcerygxx-4_1-5:1.32.2.1
	nickrob-async-20060513-branch:1.33.0.2
	nickrob-async-20060513-branchpoint:1.33
	gdb-csl-sourcerygxx-4_1-4:1.32.2.1
	msnyder-reverse-20060502-branch:1.32.0.10
	msnyder-reverse-20060502-branchpoint:1.32
	gdb-csl-morpho-4_1-4:1.32.2.1
	gdb-csl-sourcerygxx-3_4_4-17:1.32.2.1
	readline_5_1-import-branch:1.32.0.8
	readline_5_1-import-branchpoint:1.32
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.32.2.1
	gdb-csl-symbian-20060226-branch:1.32.2.1.0.2
	gdb-csl-symbian-20060226-branchpoint:1.32.2.1
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.32.2.1
	msnyder-reverse-20060331-branch:1.32.0.6
	msnyder-reverse-20060331-branchpoint:1.32
	gdb-csl-available-20060303-branch:1.32.0.4
	gdb-csl-available-20060303-branchpoint:1.32
	gdb-csl-20060226-branch:1.32.0.2
	gdb-csl-20060226-branchpoint:1.32
	gdb_6_4-20051202-release:1.29
	msnyder-fork-checkpoint-branch:1.29.0.6
	msnyder-fork-checkpoint-branchpoint:1.29
	gdb-csl-gxxpro-6_3-branch:1.29.0.4
	gdb-csl-gxxpro-6_3-branchpoint:1.29
	gdb_6_4-branch:1.29.0.2
	gdb_6_4-2005-11-01-branchpoint:1.29
	gdb-csl-arm-20051020-branch:1.28.0.2
	gdb-csl-arm-20051020-branchpoint:1.28
	msnyder-tracepoint-checkpoint-branch:1.25.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.25
	gdb-csl-arm-20050325-2005-q1b:1.23.2.2
	gdb-csl-arm-20050325-2005-q1a:1.23.2.2
	csl-arm-20050325-branch:1.23.0.2
	csl-arm-20050325-branchpoint:1.23
	gdb-post-i18n-errorwarning-20050211:1.22
	gdb-pre-i18n-errorwarning-20050211:1.22
	gdb_6_3-20041109-release:1.22
	gdb_6_3-branch:1.22.0.8
	gdb_6_3-20041019-branchpoint:1.22
	drow_intercu-merge-20040921:1.22
	drow_intercu-merge-20040915:1.22
	jimb-gdb_6_2-e500-branch:1.22.0.10
	jimb-gdb_6_2-e500-branchpoint:1.22
	gdb_6_2-20040730-release:1.22
	gdb_6_2-branch:1.22.0.6
	gdb_6_2-2004-07-10-gmt-branchpoint:1.22
	gdb_6_1_1-20040616-release:1.20.2.2
	gdb_6_1-2004-04-05-release:1.20.2.2
	drow_intercu-merge-20040402:1.22
	drow_intercu-merge-20040327:1.22
	ezannoni_pie-20040323-branch:1.22.0.4
	ezannoni_pie-20040323-branchpoint:1.22
	cagney_tramp-20040321-mergepoint:1.22
	cagney_tramp-20040309-branch:1.22.0.2
	cagney_tramp-20040309-branchpoint:1.22
	gdb_6_1-branch:1.20.0.2
	gdb_6_1-2004-03-01-gmt-branchpoint:1.20
	drow_intercu-20040221-branch:1.16.0.6
	drow_intercu-20040221-branchpoint:1.16
	cagney_bfdfile-20040213-branch:1.16.0.4
	cagney_bfdfile-20040213-branchpoint:1.16
	drow-cplus-merge-20040208:1.16
	carlton_dictionary-20040126-merge:1.16
	cagney_bigcore-20040122-branch:1.16.0.2
	cagney_bigcore-20040122-branchpoint:1.16
	drow-cplus-merge-20040113:1.16
	drow-cplus-merge-20031224:1.16
	drow-cplus-merge-20031220:1.16
	carlton_dictionary-20031215-merge:1.16
	drow-cplus-merge-20031214:1.16
	carlton-dictionary-20031111-merge:1.16
	gdb_6_0-2003-10-04-release:1.15
	kettenis_sparc-20030918-branch:1.15.0.8
	kettenis_sparc-20030918-branchpoint:1.15
	carlton_dictionary-20030917-merge:1.15
	ezannoni_pie-20030916-branchpoint:1.15
	ezannoni_pie-20030916-branch:1.15.0.6
	cagney_x86i386-20030821-branch:1.15.0.4
	cagney_x86i386-20030821-branchpoint:1.15
	carlton_dictionary-20030805-merge:1.15
	carlton_dictionary-20030627-merge:1.15
	gdb_6_0-branch:1.15.0.2
	gdb_6_0-2003-06-23-branchpoint:1.15
	jimb-ppc64-linux-20030613-branch:1.14.0.38
	jimb-ppc64-linux-20030613-branchpoint:1.14
	cagney_convert-20030606-branch:1.14.0.36
	cagney_convert-20030606-branchpoint:1.14
	cagney_writestrings-20030508-branch:1.14.0.34
	cagney_writestrings-20030508-branchpoint:1.14
	jimb-ppc64-linux-20030528-branch:1.14.0.32
	jimb-ppc64-linux-20030528-branchpoint:1.14
	carlton_dictionary-20030523-merge:1.14
	cagney_fileio-20030521-branch:1.14.0.30
	cagney_fileio-20030521-branchpoint:1.14
	kettenis_i386newframe-20030517-mergepoint:1.14
	jimb-ppc64-linux-20030509-branch:1.14.0.28
	jimb-ppc64-linux-20030509-branchpoint:1.14
	kettenis_i386newframe-20030504-mergepoint:1.14
	carlton_dictionary-20030430-merge:1.14
	kettenis_i386newframe-20030419-branch:1.14.0.26
	kettenis_i386newframe-20030419-branchpoint:1.14
	carlton_dictionary-20030416-merge:1.14
	cagney_frameaddr-20030409-mergepoint:1.14
	kettenis_i386newframe-20030406-branch:1.14.0.24
	kettenis_i386newframe-20030406-branchpoint:1.14
	cagney_frameaddr-20030403-branchpoint:1.14
	cagney_frameaddr-20030403-branch:1.14.0.22
	cagney_framebase-20030330-mergepoint:1.14
	cagney_framebase-20030326-branch:1.14.0.20
	cagney_framebase-20030326-branchpoint:1.14
	cagney_lazyid-20030317-branch:1.14.0.18
	cagney_lazyid-20030317-branchpoint:1.14
	kettenis-i386newframe-20030316-mergepoint:1.14
	offbyone-20030313-branch:1.14.0.16
	offbyone-20030313-branchpoint:1.14
	kettenis-i386newframe-20030308-branch:1.14.0.14
	kettenis-i386newframe-20030308-branchpoint:1.14
	carlton_dictionary-20030305-merge:1.14
	cagney_offbyone-20030303-branch:1.14.0.12
	cagney_offbyone-20030303-branchpoint:1.14
	carlton_dictionary-20030207-merge:1.14
	interps-20030203-mergepoint:1.14
	interps-20030202-branch:1.14.0.10
	interps-20030202-branchpoint:1.14
	cagney-unwind-20030108-branch:1.14.0.8
	cagney-unwind-20030108-branchpoint:1.14
	carlton_dictionary-20021223-merge:1.14
	gdb_5_3-2002-12-12-release:1.14
	carlton_dictionary-20021115-merge:1.14
	kseitz_interps-20021105-merge:1.14
	kseitz_interps-20021103-merge:1.14
	drow-cplus-merge-20021020:1.14
	drow-cplus-merge-20021025:1.14
	carlton_dictionary-20021025-merge:1.14
	carlton_dictionary-20021011-merge:1.14
	drow-cplus-branch:1.14.0.6
	drow-cplus-branchpoint:1.14
	kseitz_interps-20020930-merge:1.14
	carlton_dictionary-20020927-merge:1.14
	carlton_dictionary-branch:1.14.0.4
	carlton_dictionary-20020920-branchpoint:1.14
	gdb_5_3-branch:1.14.0.2
	gdb_5_3-2002-09-04-branchpoint:1.14
	kseitz_interps-20020829-merge:1.14
	cagney_sysregs-20020825-branch:1.13.0.4
	cagney_sysregs-20020825-branchpoint:1.13
	readline_4_3-import-branch:1.13.0.2
	readline_4_3-import-branchpoint:1.13
	gdb_5_2_1-2002-07-23-release:1.6.2.1
	kseitz_interps-20020528-branch:1.12.0.2
	kseitz_interps-20020528-branchpoint:1.12
	cagney_regbuf-20020515-branch:1.11.0.4
	cagney_regbuf-20020515-branchpoint:1.11
	jimb-macro-020506-branch:1.11.0.2
	jimb-macro-020506-branchpoint:1.11
	gdb_5_2-2002-04-29-release:1.6.2.1
	gdb_5_2-branch:1.6.0.2
	gdb_5_2-2002-03-03-branchpoint:1.6
	gdb_5_1_1-2002-01-24-release:1.3
	gdb_5_1_0_1-2002-01-03-release:1.3
	cygnus_cvs_20020108_pre:1.3
	gdb_5_1_0_1-2002-01-03-branch:1.3.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.3
	gdb_5_1-2001-11-21-release:1.3
	gdb_s390-2001-09-26-branch:1.3.0.6
	gdb_s390-2001-09-26-branchpoint:1.3
	gdb_5_1-2001-07-29-branch:1.3.0.4
	gdb_5_1-2001-07-29-branchpoint:1.3
	dberlin-typesystem-branch:1.3.0.2
	dberlin-typesystem-branchpoint:1.3
	gdb-post-ptid_t-2001-05-03:1.3
	gdb-pre-ptid_t-2001-05-03:1.3
	insight-precleanup-2001-01-01:1.2
	gdb-post-protoization-2000-07-29:1.1.1.4
	gdb-pre-protoization-2000-07-29:1.1.1.4
	gdb-premipsmulti-2000-06-06-branch:1.1.1.4.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.4
	gdb-post-params-removal-2000-06-04:1.1.1.4
	gdb-pre-params-removal-2000-06-04:1.1.1.4
	gdb-post-params-removal-2000-05-28:1.1.1.4
	gdb-pre-params-removal-2000-05-28:1.1.1.4
	gdb_5_0-2000-05-19-release:1.1.1.4
	gdb_4_18_2-2000-05-18-release:1.1.1.4
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.4
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.4
	gdb_5_0-2000-04-10-branch:1.1.1.4.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.4
	repo-unification-2000-02-06:1.1.1.4
	insight-2000-02-04:1.1.1.4
	gdb-2000-02-04:1.1.1.4
	gdb-2000-02-02:1.1.1.4
	gdb-2000-02-01:1.1.1.4
	gdb-2000-01-31:1.1.1.4
	gdb-2000-01-26:1.1.1.4
	gdb-2000-01-24:1.1.1.4
	gdb-2000-01-17:1.1.1.4
	gdb-2000-01-10:1.1.1.4
	gdb-2000-01-05:1.1.1.4
	gdb-1999-12-21:1.1.1.4
	gdb-1999-12-13:1.1.1.4
	gdb-1999-12-07:1.1.1.4
	gdb-1999-12-06:1.1.1.4
	gdb-1999-11-16:1.1.1.4
	gdb-1999-11-08:1.1.1.3
	gdb-1999-11-01:1.1.1.3
	gdb-1999-10-25:1.1.1.2
	gdb-1999-10-18:1.1.1.2
	gdb-1999-10-11:1.1.1.2
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.202
date	2013.10.02.11.42.35;	author palves;	state Exp;
branches;
next	1.201;

1.201
date	2013.09.18.01.59.59;	author qiyao;	state Exp;
branches;
next	1.200;

1.200
date	2013.09.05.20.45.39;	author palves;	state Exp;
branches;
next	1.199;

1.199
date	2013.09.05.20.41.55;	author palves;	state Exp;
branches;
next	1.198;

1.198
date	2013.09.05.20.40.33;	author palves;	state Exp;
branches;
next	1.197;

1.197
date	2013.09.02.14.14.58;	author palves;	state Exp;
branches;
next	1.196;

1.196
date	2013.08.28.17.40.58;	author jkratoch;	state Exp;
branches;
next	1.195;

1.195
date	2013.07.24.16.20.12;	author luisgpm;	state Exp;
branches;
next	1.194;

1.194
date	2013.07.01.11.19.27;	author palves;	state Exp;
branches;
next	1.193;

1.193
date	2013.06.07.10.46.59;	author palves;	state Exp;
branches;
next	1.192;

1.192
date	2013.06.04.12.59.21;	author gary;	state Exp;
branches;
next	1.191;

1.191
date	2013.05.24.11.28.06;	author palves;	state Exp;
branches;
next	1.190;

1.190
date	2013.05.23.17.17.50;	author palves;	state Exp;
branches;
next	1.189;

1.189
date	2013.03.11.08.35.11;	author mmetzger;	state Exp;
branches;
next	1.188;

1.188
date	2013.03.11.08.31.48;	author mmetzger;	state Exp;
branches;
next	1.187;

1.187
date	2013.03.08.15.06.37;	author abidh;	state Exp;
branches;
next	1.186;

1.186
date	2013.02.27.13.31.38;	author qiyao;	state Exp;
branches;
next	1.185;

1.185
date	2013.02.19.20.52.57;	author palves;	state Exp;
branches;
next	1.184;

1.184
date	2013.01.25.14.12.02;	author qiyao;	state Exp;
branches;
next	1.183;

1.183
date	2013.01.01.06.33.00;	author brobecke;	state Exp;
branches;
next	1.182;

1.182
date	2013.01.01.05.45.22;	author brobecke;	state Exp;
branches;
next	1.181;

1.181
date	2012.12.15.02.48.17;	author qiyao;	state Exp;
branches;
next	1.180;

1.180
date	2012.11.15.16.12.19;	author muller;	state Exp;
branches;
next	1.179;

1.179
date	2012.11.09.02.58.50;	author qiyao;	state Exp;
branches;
next	1.178;

1.178
date	2012.10.01.12.02.12;	author aburgess;	state Exp;
branches;
next	1.177;

1.177
date	2012.07.31.19.16.46;	author palves;	state Exp;
branches;
next	1.176;

1.176
date	2012.07.27.00.56.32;	author qiyao;	state Exp;
branches;
next	1.175;

1.175
date	2012.07.02.15.29.38;	author shebs;	state Exp;
branches
	1.175.2.1;
next	1.174;

1.174
date	2012.06.13.02.35.01;	author qiyao;	state Exp;
branches;
next	1.173;

1.173
date	2012.06.12.14.02.15;	author qiyao;	state Exp;
branches;
next	1.172;

1.172
date	2012.06.01.16.50.11;	author jkratoch;	state Exp;
branches;
next	1.171;

1.171
date	2012.05.24.16.51.37;	author palves;	state Exp;
branches;
next	1.170;

1.170
date	2012.05.24.16.39.13;	author palves;	state Exp;
branches;
next	1.169;

1.169
date	2012.04.29.06.28.30;	author qiyao;	state Exp;
branches;
next	1.168;

1.168
date	2012.04.19.05.05.11;	author qiyao;	state Exp;
branches;
next	1.167;

1.167
date	2012.03.26.13.54.57;	author palves;	state Exp;
branches;
next	1.166;

1.166
date	2012.03.19.14.33.35;	author palves;	state Exp;
branches;
next	1.165;

1.165
date	2012.03.08.22.19.56;	author brobecke;	state Exp;
branches;
next	1.164;

1.164
date	2012.03.07.19.25.39;	author palves;	state Exp;
branches;
next	1.163;

1.163
date	2012.03.03.03.32.45;	author qiyao;	state Exp;
branches;
next	1.162;

1.162
date	2012.02.24.15.15.56;	author luisgpm;	state Exp;
branches;
next	1.161;

1.161
date	2012.02.11.13.36.41;	author qiyao;	state Exp;
branches;
next	1.160;

1.160
date	2012.01.23.16.40.26;	author palves;	state Exp;
branches;
next	1.159;

1.159
date	2012.01.20.09.44.35;	author uweigand;	state Exp;
branches;
next	1.158;

1.158
date	2012.01.13.20.06.40;	author palves;	state Exp;
branches;
next	1.157;

1.157
date	2012.01.13.20.02.36;	author palves;	state Exp;
branches;
next	1.156;

1.156
date	2012.01.09.17.17.50;	author devans;	state Exp;
branches;
next	1.155;

1.155
date	2012.01.04.08.17.23;	author brobecke;	state Exp;
branches;
next	1.154;

1.154
date	2012.01.02.08.59.35;	author brobecke;	state Exp;
branches;
next	1.153;

1.153
date	2011.12.16.19.06.38;	author devans;	state Exp;
branches;
next	1.152;

1.152
date	2011.12.02.22.26.53;	author jkratoch;	state Exp;
branches
	1.152.2.1;
next	1.151;

1.151
date	2011.11.14.15.18.51;	author qiyao;	state Exp;
branches;
next	1.150;

1.150
date	2011.11.02.23.44.21;	author shebs;	state Exp;
branches;
next	1.149;

1.149
date	2011.10.07.12.06.48;	author uweigand;	state Exp;
branches;
next	1.148;

1.148
date	2011.09.01.03.14.10;	author jiez;	state Exp;
branches;
next	1.147;

1.147
date	2011.08.14.13.03.13;	author qiyao;	state Exp;
branches;
next	1.146;

1.146
date	2011.07.21.23.46.12;	author kcy;	state Exp;
branches;
next	1.145;

1.145
date	2011.05.12.12.09.17;	author kcy;	state Exp;
branches;
next	1.144;

1.144
date	2011.05.04.20.20.12;	author devans;	state Exp;
branches;
next	1.143;

1.143
date	2011.04.24.08.02.20;	author jkratoch;	state Exp;
branches;
next	1.142;

1.142
date	2011.03.10.20.09.18;	author msnyder;	state Exp;
branches;
next	1.141;

1.141
date	2011.03.05.00.21.10;	author msnyder;	state Exp;
branches;
next	1.140;

1.140
date	2011.02.28.01.46.51;	author msnyder;	state Exp;
branches;
next	1.139;

1.139
date	2011.02.14.11.13.12;	author palves;	state Exp;
branches;
next	1.138;

1.138
date	2011.02.07.12.14.11;	author palves;	state Exp;
branches;
next	1.137;

1.137
date	2011.01.25.10.09.19;	author palves;	state Exp;
branches;
next	1.136;

1.136
date	2011.01.06.00.14.09;	author msnyder;	state Exp;
branches;
next	1.135;

1.135
date	2011.01.01.15.33.24;	author brobecke;	state Exp;
branches;
next	1.134;

1.134
date	2011.01.01.14.14.46;	author brobecke;	state Exp;
branches;
next	1.133;

1.133
date	2010.09.06.15.15.50;	author qiyao;	state Exp;
branches;
next	1.132;

1.132
date	2010.09.01.17.29.32;	author gdbadmin;	state Exp;
branches;
next	1.131;

1.131
date	2010.08.27.00.16.48;	author palves;	state Exp;
branches;
next	1.130;

1.130
date	2010.08.26.23.17.22;	author palves;	state Exp;
branches;
next	1.129;

1.129
date	2010.08.25.16.27.05;	author palves;	state Exp;
branches;
next	1.128;

1.128
date	2010.08.12.15.16.12;	author palves;	state Exp;
branches;
next	1.127;

1.127
date	2010.07.25.10.15.54;	author jkratoch;	state Exp;
branches;
next	1.126;

1.126
date	2010.07.20.18.20.27;	author sezero;	state Exp;
branches;
next	1.125;

1.125
date	2010.07.07.16.14.04;	author brobecke;	state Exp;
branches
	1.125.2.1;
next	1.124;

1.124
date	2010.07.06.21.20.43;	author brobecke;	state Exp;
branches;
next	1.123;

1.123
date	2010.07.01.10.36.11;	author palves;	state Exp;
branches;
next	1.122;

1.122
date	2010.06.01.13.20.52;	author palves;	state Exp;
branches;
next	1.121;

1.121
date	2010.06.01.12.47.33;	author palves;	state Exp;
branches;
next	1.120;

1.120
date	2010.05.03.04.02.20;	author palves;	state Exp;
branches;
next	1.119;

1.119
date	2010.05.02.00.47.34;	author palves;	state Exp;
branches;
next	1.118;

1.118
date	2010.04.26.22.02.33;	author devans;	state Exp;
branches;
next	1.117;

1.117
date	2010.04.24.00.58.43;	author devans;	state Exp;
branches;
next	1.116;

1.116
date	2010.04.16.07.49.36;	author muller;	state Exp;
branches;
next	1.115;

1.115
date	2010.04.12.17.39.42;	author palves;	state Exp;
branches;
next	1.114;

1.114
date	2010.04.11.16.33.56;	author palves;	state Exp;
branches;
next	1.113;

1.113
date	2010.04.09.03.40.00;	author palves;	state Exp;
branches;
next	1.112;

1.112
date	2010.04.07.18.49.46;	author hjl;	state Exp;
branches;
next	1.111;

1.111
date	2010.04.01.14.26.53;	author palves;	state Exp;
branches;
next	1.110;

1.110
date	2010.03.24.00.14.54;	author palves;	state Exp;
branches;
next	1.109;

1.109
date	2010.03.23.22.43.50;	author msnyder;	state Exp;
branches;
next	1.108;

1.108
date	2010.01.20.22.55.38;	author palves;	state Exp;
branches;
next	1.107;

1.107
date	2010.01.12.21.40.24;	author vprus;	state Exp;
branches;
next	1.106;

1.106
date	2010.01.01.07.31.49;	author brobecke;	state Exp;
branches;
next	1.105;

1.105
date	2010.01.01.06.59.28;	author brobecke;	state Exp;
branches;
next	1.104;

1.104
date	2009.10.29.20.12.26;	author sandra;	state Exp;
branches;
next	1.103;

1.103
date	2009.10.09.00.31.01;	author ppluzhnikov;	state Exp;
branches;
next	1.102;

1.102
date	2009.06.30.16.35.25;	author devans;	state Exp;
branches;
next	1.101;

1.101
date	2009.06.25.22.13.52;	author palves;	state Exp;
branches;
next	1.100;

1.100
date	2009.06.24.15.23.32;	author muller;	state Exp;
branches;
next	1.99;

1.99
date	2009.06.23.15.12.44;	author aristovski;	state Exp;
branches;
next	1.98;

1.98
date	2009.06.19.13.35.35;	author palves;	state Exp;
branches;
next	1.97;

1.97
date	2009.05.24.21.06.53;	author devans;	state Exp;
branches;
next	1.96;

1.96
date	2009.04.30.22.21.06;	author devans;	state Exp;
branches;
next	1.95;

1.95
date	2009.04.01.22.50.24;	author palves;	state Exp;
branches;
next	1.94;

1.94
date	2009.04.01.22.48.05;	author palves;	state Exp;
branches;
next	1.93;

1.93
date	2009.04.01.22.31.45;	author palves;	state Exp;
branches;
next	1.92;

1.92
date	2009.04.01.22.29.33;	author palves;	state Exp;
branches;
next	1.91;

1.91
date	2009.03.31.22.46.36;	author palves;	state Exp;
branches;
next	1.90;

1.90
date	2009.03.23.00.22.54;	author palves;	state Exp;
branches;
next	1.89;

1.89
date	2009.03.22.23.57.10;	author palves;	state Exp;
branches;
next	1.88;

1.88
date	2009.03.14.01.38.08;	author palves;	state Exp;
branches;
next	1.87;

1.87
date	2009.02.06.22.59.01;	author palves;	state Exp;
branches;
next	1.86;

1.86
date	2009.01.26.16.16.48;	author palves;	state Exp;
branches;
next	1.85;

1.85
date	2009.01.19.00.16.46;	author devans;	state Exp;
branches;
next	1.84;

1.84
date	2009.01.06.04.49.29;	author brobecke;	state Exp;
branches;
next	1.83;

1.83
date	2009.01.03.05.57.57;	author brobecke;	state Exp;
branches;
next	1.82;

1.82
date	2008.12.14.20.51.04;	author devans;	state Exp;
branches;
next	1.81;

1.81
date	2008.12.02.07.57.37;	author vprus;	state Exp;
branches;
next	1.80;

1.80
date	2008.11.24.18.05.02;	author drow;	state Exp;
branches;
next	1.79;

1.79
date	2008.10.10.14.06.05;	author palves;	state Exp;
branches
	1.79.2.1;
next	1.78;

1.78
date	2008.08.12.15.18.31;	author sandra;	state Exp;
branches;
next	1.77;

1.77
date	2008.07.31.17.46.33;	author palves;	state Exp;
branches;
next	1.76;

1.76
date	2008.07.07.23.00.11;	author palves;	state Exp;
branches;
next	1.75;

1.75
date	2008.06.27.13.22.15;	author palves;	state Exp;
branches;
next	1.74;

1.74
date	2008.06.20.16.01.42;	author carlos;	state Exp;
branches;
next	1.73;

1.73
date	2008.06.05.22.36.57;	author jsm28;	state Exp;
branches;
next	1.72;

1.72
date	2008.05.09.17.37.36;	author devans;	state Exp;
branches;
next	1.71;

1.71
date	2008.05.09.17.02.02;	author devans;	state Exp;
branches;
next	1.70;

1.70
date	2008.04.04.19.19.11;	author uweigand;	state Exp;
branches;
next	1.69;

1.69
date	2008.03.27.13.11.52;	author uweigand;	state Exp;
branches;
next	1.68;

1.68
date	2008.03.10.23.14.06;	author drow;	state Exp;
branches;
next	1.67;

1.67
date	2008.02.28.05.54.09;	author uweigand;	state Exp;
branches;
next	1.66;

1.66
date	2008.02.19.21.36.54;	author palves;	state Exp;
branches;
next	1.65;

1.65
date	2008.02.17.15.26.17;	author drow;	state Exp;
branches;
next	1.64;

1.64
date	2008.02.14.16.42.55;	author drow;	state Exp;
branches;
next	1.63;

1.63
date	2008.01.30.00.51.50;	author drow;	state Exp;
branches;
next	1.62;

1.62
date	2008.01.01.22.53.14;	author drow;	state Exp;
branches;
next	1.61;

1.61
date	2007.12.07.14.00.37;	author drow;	state Exp;
branches;
next	1.60;

1.60
date	2007.12.07.01.41.29;	author drow;	state Exp;
branches;
next	1.59;

1.59
date	2007.12.03.01.38.09;	author palves;	state Exp;
branches;
next	1.58;

1.58
date	2007.12.03.01.34.09;	author palves;	state Exp;
branches;
next	1.57;

1.57
date	2007.11.30.21.50.19;	author drow;	state Exp;
branches;
next	1.56;

1.56
date	2007.08.23.18.08.48;	author brobecke;	state Exp;
branches;
next	1.55;

1.55
date	2007.07.27.18.44.40;	author msnyder;	state Exp;
branches;
next	1.54;

1.54
date	2007.07.17.12.51.41;	author drow;	state Exp;
branches;
next	1.53;

1.53
date	2007.06.12.14.38.32;	author uweigand;	state Exp;
branches;
next	1.52;

1.52
date	2007.05.16.15.26.35;	author uweigand;	state Exp;
branches;
next	1.51;

1.51
date	2007.05.10.21.05.15;	author palves;	state Exp;
branches;
next	1.50;

1.50
date	2007.03.29.01.06.47;	author palves;	state Exp;
branches;
next	1.49;

1.49
date	2007.03.27.19.10.16;	author drow;	state Exp;
branches;
next	1.48;

1.48
date	2007.02.26.20.10.18;	author drow;	state Exp;
branches;
next	1.47;

1.47
date	2007.02.25.17.40.10;	author palves;	state Exp;
branches;
next	1.46;

1.46
date	2007.02.08.21.39.04;	author drow;	state Exp;
branches;
next	1.45;

1.45
date	2007.01.09.22.55.10;	author drow;	state Exp;
branches;
next	1.44;

1.44
date	2007.01.09.17.59.08;	author drow;	state Exp;
branches;
next	1.43;

1.43
date	2006.12.30.15.44.51;	author drow;	state Exp;
branches;
next	1.42;

1.42
date	2006.11.16.15.08.25;	author drow;	state Exp;
branches;
next	1.41;

1.41
date	2006.11.06.21.50.32;	author drow;	state Exp;
branches;
next	1.40;

1.40
date	2006.10.17.16.02.27;	author drow;	state Exp;
branches;
next	1.39;

1.39
date	2006.08.08.16.03.29;	author rsandifo;	state Exp;
branches;
next	1.38;

1.38
date	2006.07.27.00.06.12;	author drow;	state Exp;
branches;
next	1.37;

1.37
date	2006.07.23.03.52.15;	author drow;	state Exp;
branches;
next	1.36;

1.36
date	2006.07.12.18.50.18;	author drow;	state Exp;
branches;
next	1.35;

1.35
date	2006.06.22.15.20.47;	author drow;	state Exp;
branches;
next	1.34;

1.34
date	2006.06.21.13.57.21;	author drow;	state Exp;
branches;
next	1.33;

1.33
date	2006.05.09.15.21.19;	author nathan;	state Exp;
branches
	1.33.2.1;
next	1.32;

1.32
date	2006.02.08.20.26.44;	author drow;	state Exp;
branches
	1.32.2.1;
next	1.31;

1.31
date	2006.02.01.21.37.21;	author drow;	state Exp;
branches;
next	1.30;

1.30
date	2005.12.23.18.11.55;	author eliz;	state Exp;
branches;
next	1.29;

1.29
date	2005.10.25.11.11.08;	author schwab;	state Exp;
branches;
next	1.28;

1.28
date	2005.07.13.15.02.49;	author drow;	state Exp;
branches
	1.28.2.1;
next	1.27;

1.27
date	2005.06.17.04.01.05;	author drow;	state Exp;
branches;
next	1.26;

1.26
date	2005.06.13.01.59.22;	author drow;	state Exp;
branches;
next	1.25;

1.25
date	2005.05.12.12.14.23;	author orjanf;	state Exp;
branches;
next	1.24;

1.24
date	2005.05.04.18.51.38;	author drow;	state Exp;
branches;
next	1.23;

1.23
date	2005.03.03.16.56.53;	author drow;	state Exp;
branches
	1.23.2.1;
next	1.22;

1.22
date	2004.03.05.03.44.27;	author drow;	state Exp;
branches;
next	1.21;

1.21
date	2004.03.05.03.43.19;	author drow;	state Exp;
branches;
next	1.20;

1.20
date	2004.02.29.16.49.38;	author drow;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	2004.02.29.16.46.01;	author drow;	state Exp;
branches;
next	1.18;

1.18
date	2004.02.26.15.08.47;	author drow;	state Exp;
branches;
next	1.17;

1.17
date	2004.02.25.20.41.29;	author roland;	state Exp;
branches;
next	1.16;

1.16
date	2003.10.13.16.17.21;	author drow;	state Exp;
branches
	1.16.6.1;
next	1.15;

1.15
date	2003.06.17.20.28.14;	author drow;	state Exp;
branches
	1.15.6.1;
next	1.14;

1.14
date	2002.08.29.18.50.25;	author drow;	state Exp;
branches
	1.14.4.1
	1.14.6.1;
next	1.13;

1.13
date	2002.06.11.17.32.40;	author drow;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.16.02.33.04;	author drow;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2002.04.20.17.04.09;	author drow;	state Exp;
branches
	1.11.4.1;
next	1.10;

1.10
date	2002.04.09.23.52.06;	author drow;	state Exp;
branches;
next	1.9;

1.9
date	2002.04.09.21.16.16;	author drow;	state Exp;
branches;
next	1.8;

1.8
date	2002.04.09.21.11.35;	author drow;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.27.05.15.49;	author drow;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.14.06.21.22;	author drow;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2002.01.17.21.13.50;	author drow;	state Exp;
branches;
next	1.4;

1.4
date	2002.01.17.20.46.16;	author drow;	state Exp;
branches;
next	1.3;

1.3
date	2001.03.06.08.21.44;	author kevinb;	state Exp;
branches
	1.3.6.1;
next	1.2;

1.2
date	2000.08.26.17.29.53;	author kevinb;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.26;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.175.2.1
date	2012.07.27.02.30.20;	author qiyao;	state Exp;
branches;
next	;

1.152.2.1
date	2012.01.06.04.16.15;	author brobecke;	state Exp;
branches;
next	1.152.2.2;

1.152.2.2
date	2012.01.06.04.43.39;	author brobecke;	state Exp;
branches;
next	;

1.125.2.1
date	2010.07.21.20.01.09;	author sezero;	state Exp;
branches;
next	;

1.79.2.1
date	2008.11.25.20.47.19;	author palves;	state Exp;
branches;
next	;

1.33.2.1
date	2006.08.28.07.48.46;	author nickrob;	state Exp;
branches;
next	;

1.32.2.1
date	2006.03.31.15.31.56;	author nathan;	state Exp;
branches
	1.32.2.1.2.1;
next	1.32.2.2;

1.32.2.2
date	2006.08.02.17.40.18;	author rsandifo;	state Exp;
branches;
next	;

1.32.2.1.2.1
date	2006.04.12.14.48.23;	author drow;	state Exp;
branches;
next	1.32.2.1.2.2;

1.32.2.1.2.2
date	2006.04.12.14.52.05;	author drow;	state Exp;
branches;
next	1.32.2.1.2.3;

1.32.2.1.2.3
date	2006.04.12.18.11.42;	author drow;	state Exp;
branches;
next	1.32.2.1.2.4;

1.32.2.1.2.4
date	2006.05.23.21.44.20;	author drow;	state Exp;
branches;
next	;

1.28.2.1
date	2005.10.20.03.36.28;	author pbrook;	state Exp;
branches;
next	;

1.23.2.1
date	2005.03.29.02.52.06;	author pbrook;	state Exp;
branches;
next	1.23.2.2;

1.23.2.2
date	2005.03.30.14.59.31;	author drow;	state Exp;
branches;
next	;

1.20.2.1
date	2004.03.05.03.44.51;	author drow;	state Exp;
branches;
next	1.20.2.2;

1.20.2.2
date	2004.03.05.03.45.15;	author drow;	state Exp;
branches;
next	;

1.16.6.1
date	2004.03.27.17.38.01;	author drow;	state Exp;
branches;
next	;

1.15.6.1
date	2004.03.23.20.28.36;	author ezannoni;	state Exp;
branches;
next	;

1.14.4.1
date	2003.06.27.21.50.18;	author carlton;	state Exp;
branches;
next	1.14.4.2;

1.14.4.2
date	2003.11.11.23.51.09;	author carlton;	state Exp;
branches;
next	;

1.14.6.1
date	2003.12.14.20.27.44;	author drow;	state Exp;
branches;
next	;

1.12.2.1
date	2002.06.20.01.36.23;	author kseitz;	state Exp;
branches;
next	1.12.2.2;

1.12.2.2
date	2002.08.30.22.52.50;	author kseitz;	state Exp;
branches;
next	;

1.11.4.1
date	2002.06.15.16.43.13;	author cagney;	state Exp;
branches;
next	;

1.6.2.1
date	2002.03.29.19.03.34;	author drow;	state Exp;
branches;
next	;

1.3.6.1
date	2001.09.27.00.13.30;	author cagney;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.26;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.07.07.20.17.52;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.11.02.04.44.24;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.11.17.02.30.36;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.202
log
@[GDBserver]: Silence exits if GDB is connected through stdio.

If we make gdbserver gdb_continue_to_end actually expect a process
exit with GDBserver, we get many testsuite failures with the remote
stdio board:

-PASS: gdb.arch/amd64-disp-step.exp: continue until exit at amd64-disp-step
+FAIL: gdb.arch/amd64-disp-step.exp: continue until exit at amd64-disp-step (the program exited)
-PASS: gdb.base/break.exp: continue until exit at recursive next test
+FAIL: gdb.base/break.exp: continue until exit at recursive next test (the program exited)
-PASS: gdb.base/chng-syms.exp: continue until exit at breakpoint first time through
+FAIL: gdb.base/chng-syms.exp: continue until exit at breakpoint first time through (the program exited)
... etc. ...

This is what the log shows for all of them:

 (gdb) continue
 Continuing.

 Child exited with status 0
 GDBserver exiting
 [Inferior 1 (process 22721) exited normally]
 (gdb) FAIL: gdb.arch/amd64-disp-step.exp: continue until exit (the program exited)

The problem is the whole "Child exited ... GDBserver exiting" output,
that comes out of GDBserver, and that the testsuite is not expecting.

I pondered somehow making the testsuite adjust to this.  But,
testsuite aside, I think GDBserver should not be outputting this at
all when GDB is connected through stdio.  GDBserver will be printing
this in GDB's console, but the user can already tell from the regular
output that the inferior is gone.

Again, manually:

 (gdb) tar remote | ./gdbserver/gdbserver - program
 Remote debugging using | ./gdbserver/gdbserver - program
 Process program created; pid = 22486
 stdin/stdout redirected
 Remote debugging using stdio
 done.
 Loaded symbols for /lib64/ld-linux-x86-64.so.2
 0x000000323d001530 in _start () from /lib64/ld-linux-x86-64.so.2
 (gdb) c
 Continuing.
 Child exited with status 1
 ^^^^^^^^^^^^^^^^^^^^^^^^^^
 GDBserver exiting
 ^^^^^^^^^^^^^^^^^
 [Inferior 1 (process 22486) exited with code 01]
 (gdb)

Suppressing those two lines makes the output be exactly like when
debugging against a remote tcp gdbserver:

 (gdb) c
 Continuing.
 [Inferior 1 (process 22914) exited with code 01]
 (gdb)

2013-10-02  Pedro Alves  <palves@@redhat.com>

	* server.c (process_serial_event): Don't output "GDBserver
	exiting" if GDB is connected through stdio.
	* target.c (mywait): Likewise, be silent if GDB is connected
	through stdio.
@
text
@/* Main code for remote server for GDB.
   Copyright (C) 1989-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "server.h"
#include "gdbthread.h"
#include "agent.h"
#include "notif.h"
#include "tdesc.h"

#include <unistd.h>
#if HAVE_SIGNAL_H
#include <signal.h>
#endif
#include "gdb_wait.h"
#include "btrace-common.h"
#include "filestuff.h"
#include "tracepoint.h"
#include "dll.h"
#include "hostio.h"

/* The thread set with an `Hc' packet.  `Hc' is deprecated in favor of
   `vCont'.  Note the multi-process extensions made `vCont' a
   requirement, so `Hc pPID.TID' is pretty much undefined.  So
   CONT_THREAD can be null_ptid for no `Hc' thread, minus_one_ptid for
   resuming all threads of the process (again, `Hc' isn't used for
   multi-process), or a specific thread ptid_t.

   We also set this when handling a single-thread `vCont' resume, as
   some places in the backends check it to know when (and for which
   thread) single-thread scheduler-locking is in effect.  */
ptid_t cont_thread;

/* The thread set with an `Hg' packet.  */
ptid_t general_thread;

int server_waiting;

static int extended_protocol;
static int response_needed;
static int exit_requested;

/* --once: Exit after the first connection has closed.  */
int run_once;

int multi_process;
int non_stop;

/* Whether we should attempt to disable the operating system's address
   space randomization feature before starting an inferior.  */
int disable_randomization = 1;

static char **program_argv, **wrapper_argv;

/* Enable miscellaneous debugging output.  The name is historical - it
   was originally used to debug LinuxThreads support.  */
int debug_threads;

/* Enable debugging of h/w breakpoint/watchpoint support.  */
int debug_hw_points;

int pass_signals[GDB_SIGNAL_LAST];
int program_signals[GDB_SIGNAL_LAST];
int program_signals_p;

jmp_buf toplevel;

/* The PID of the originally created or attached inferior.  Used to
   send signals to the process when GDB sends us an asynchronous interrupt
   (user hitting Control-C in the client), and to wait for the child to exit
   when no longer debugging it.  */

unsigned long signal_pid;

#ifdef SIGTTOU
/* A file descriptor for the controlling terminal.  */
int terminal_fd;

/* TERMINAL_FD's original foreground group.  */
pid_t old_foreground_pgrp;

/* Hand back terminal ownership to the original foreground group.  */

static void
restore_old_foreground_pgrp (void)
{
  tcsetpgrp (terminal_fd, old_foreground_pgrp);
}
#endif

/* Set if you want to disable optional thread related packets support
   in gdbserver, for the sake of testing GDB against stubs that don't
   support them.  */
int disable_packet_vCont;
int disable_packet_Tthread;
int disable_packet_qC;
int disable_packet_qfThreadInfo;

/* Last status reported to GDB.  */
static struct target_waitstatus last_status;
static ptid_t last_ptid;

static char *own_buf;
static unsigned char *mem_buf;

/* A sub-class of 'struct notif_event' for stop, holding information
   relative to a single stop reply.  We keep a queue of these to
   push to GDB in non-stop mode.  */

struct vstop_notif
{
  struct notif_event base;

  /* Thread or process that got the event.  */
  ptid_t ptid;

  /* Event info.  */
  struct target_waitstatus status;
};

DEFINE_QUEUE_P (notif_event_p);

/* Put a stop reply to the stop reply queue.  */

static void
queue_stop_reply (ptid_t ptid, struct target_waitstatus *status)
{
  struct vstop_notif *new_notif = xmalloc (sizeof (*new_notif));

  new_notif->ptid = ptid;
  new_notif->status = *status;

  notif_event_enque (&notif_stop, (struct notif_event *) new_notif);
}

static int
remove_all_on_match_pid (QUEUE (notif_event_p) *q,
			    QUEUE_ITER (notif_event_p) *iter,
			    struct notif_event *event,
			    void *data)
{
  int *pid = data;

  if (*pid == -1
      || ptid_get_pid (((struct vstop_notif *) event)->ptid) == *pid)
    {
      if (q->free_func != NULL)
	q->free_func (event);

      QUEUE_remove_elem (notif_event_p, q, iter);
    }

  return 1;
}

/* Get rid of the currently pending stop replies for PID.  If PID is
   -1, then apply to all processes.  */

static void
discard_queued_stop_replies (int pid)
{
  QUEUE_iterate (notif_event_p, notif_stop.queue,
		 remove_all_on_match_pid, &pid);
}

static void
vstop_notif_reply (struct notif_event *event, char *own_buf)
{
  struct vstop_notif *vstop = (struct vstop_notif *) event;

  prepare_resume_reply (own_buf, vstop->ptid, &vstop->status);
}

struct notif_server notif_stop =
{
  "vStopped", "Stop", NULL, vstop_notif_reply,
};

static int
target_running (void)
{
  return all_threads.head != NULL;
}

static int
start_inferior (char **argv)
{
  char **new_argv = argv;

  if (wrapper_argv != NULL)
    {
      int i, count = 1;

      for (i = 0; wrapper_argv[i] != NULL; i++)
	count++;
      for (i = 0; argv[i] != NULL; i++)
	count++;
      new_argv = alloca (sizeof (char *) * count);
      count = 0;
      for (i = 0; wrapper_argv[i] != NULL; i++)
	new_argv[count++] = wrapper_argv[i];
      for (i = 0; argv[i] != NULL; i++)
	new_argv[count++] = argv[i];
      new_argv[count] = NULL;
    }

  if (debug_threads)
    {
      int i;
      for (i = 0; new_argv[i]; ++i)
	fprintf (stderr, "new_argv[%d] = \"%s\"\n", i, new_argv[i]);
      fflush (stderr);
    }

#ifdef SIGTTOU
  signal (SIGTTOU, SIG_DFL);
  signal (SIGTTIN, SIG_DFL);
#endif

  /* Clear this so the backend doesn't get confused, thinking
     CONT_THREAD died, and it needs to resume all threads.  */
  cont_thread = null_ptid;

  signal_pid = create_inferior (new_argv[0], new_argv);

  /* FIXME: we don't actually know at this point that the create
     actually succeeded.  We won't know that until we wait.  */
  fprintf (stderr, "Process %s created; pid = %ld\n", argv[0],
	   signal_pid);
  fflush (stderr);

#ifdef SIGTTOU
  signal (SIGTTOU, SIG_IGN);
  signal (SIGTTIN, SIG_IGN);
  terminal_fd = fileno (stderr);
  old_foreground_pgrp = tcgetpgrp (terminal_fd);
  tcsetpgrp (terminal_fd, signal_pid);
  atexit (restore_old_foreground_pgrp);
#endif

  if (wrapper_argv != NULL)
    {
      struct thread_resume resume_info;

      memset (&resume_info, 0, sizeof (resume_info));
      resume_info.thread = pid_to_ptid (signal_pid);
      resume_info.kind = resume_continue;
      resume_info.sig = 0;

      last_ptid = mywait (pid_to_ptid (signal_pid), &last_status, 0, 0);

      if (last_status.kind != TARGET_WAITKIND_STOPPED)
	return signal_pid;

      do
	{
	  (*the_target->resume) (&resume_info, 1);

 	  last_ptid = mywait (pid_to_ptid (signal_pid), &last_status, 0, 0);
	  if (last_status.kind != TARGET_WAITKIND_STOPPED)
	    return signal_pid;

	  current_inferior->last_resume_kind = resume_stop;
	  current_inferior->last_status = last_status;
	}
      while (last_status.value.sig != GDB_SIGNAL_TRAP);

      return signal_pid;
    }

  /* Wait till we are at 1st instruction in program, return new pid
     (assuming success).  */
  last_ptid = mywait (pid_to_ptid (signal_pid), &last_status, 0, 0);

  if (last_status.kind != TARGET_WAITKIND_EXITED
      && last_status.kind != TARGET_WAITKIND_SIGNALLED)
    {
      current_inferior->last_resume_kind = resume_stop;
      current_inferior->last_status = last_status;
    }

  return signal_pid;
}

static int
attach_inferior (int pid)
{
  /* myattach should return -1 if attaching is unsupported,
     0 if it succeeded, and call error() otherwise.  */

  if (myattach (pid) != 0)
    return -1;

  fprintf (stderr, "Attached; pid = %d\n", pid);
  fflush (stderr);

  /* FIXME - It may be that we should get the SIGNAL_PID from the
     attach function, so that it can be the main thread instead of
     whichever we were told to attach to.  */
  signal_pid = pid;

  /* Clear this so the backend doesn't get confused, thinking
     CONT_THREAD died, and it needs to resume all threads.  */
  cont_thread = null_ptid;

  if (!non_stop)
    {
      last_ptid = mywait (pid_to_ptid (pid), &last_status, 0, 0);

      /* GDB knows to ignore the first SIGSTOP after attaching to a running
	 process using the "attach" command, but this is different; it's
	 just using "target remote".  Pretend it's just starting up.  */
      if (last_status.kind == TARGET_WAITKIND_STOPPED
	  && last_status.value.sig == GDB_SIGNAL_STOP)
	last_status.value.sig = GDB_SIGNAL_TRAP;

      current_inferior->last_resume_kind = resume_stop;
      current_inferior->last_status = last_status;
    }

  return 0;
}

extern int remote_debug;

/* Decode a qXfer read request.  Return 0 if everything looks OK,
   or -1 otherwise.  */

static int
decode_xfer_read (char *buf, CORE_ADDR *ofs, unsigned int *len)
{
  /* After the read marker and annex, qXfer looks like a
     traditional 'm' packet.  */
  decode_m_packet (buf, ofs, len);

  return 0;
}

static int
decode_xfer (char *buf, char **object, char **rw, char **annex, char **offset)
{
  /* Extract and NUL-terminate the object.  */
  *object = buf;
  while (*buf && *buf != ':')
    buf++;
  if (*buf == '\0')
    return -1;
  *buf++ = 0;

  /* Extract and NUL-terminate the read/write action.  */
  *rw = buf;
  while (*buf && *buf != ':')
    buf++;
  if (*buf == '\0')
    return -1;
  *buf++ = 0;

  /* Extract and NUL-terminate the annex.  */
  *annex = buf;
  while (*buf && *buf != ':')
    buf++;
  if (*buf == '\0')
    return -1;
  *buf++ = 0;

  *offset = buf;
  return 0;
}

/* Write the response to a successful qXfer read.  Returns the
   length of the (binary) data stored in BUF, corresponding
   to as much of DATA/LEN as we could fit.  IS_MORE controls
   the first character of the response.  */
static int
write_qxfer_response (char *buf, const void *data, int len, int is_more)
{
  int out_len;

  if (is_more)
    buf[0] = 'm';
  else
    buf[0] = 'l';

  return remote_escape_output (data, len, (unsigned char *) buf + 1, &out_len,
			       PBUFSIZ - 2) + 1;
}

/* Handle btrace enabling.  */

static const char *
handle_btrace_enable (struct thread_info *thread)
{
  if (thread->btrace != NULL)
    return "E.Btrace already enabled.";

  thread->btrace = target_enable_btrace (thread->entry.id);
  if (thread->btrace == NULL)
    return "E.Could not enable btrace.";

  return NULL;
}

/* Handle btrace disabling.  */

static const char *
handle_btrace_disable (struct thread_info *thread)
{

  if (thread->btrace == NULL)
    return "E.Branch tracing not enabled.";

  if (target_disable_btrace (thread->btrace) != 0)
    return "E.Could not disable branch tracing.";

  thread->btrace = NULL;
  return NULL;
}

/* Handle the "Qbtrace" packet.  */

static int
handle_btrace_general_set (char *own_buf)
{
  struct thread_info *thread;
  const char *err;
  char *op;

  if (strncmp ("Qbtrace:", own_buf, strlen ("Qbtrace:")) != 0)
    return 0;

  op = own_buf + strlen ("Qbtrace:");

  if (!target_supports_btrace ())
    {
      strcpy (own_buf, "E.Target does not support branch tracing.");
      return -1;
    }

  if (ptid_equal (general_thread, null_ptid)
      || ptid_equal (general_thread, minus_one_ptid))
    {
      strcpy (own_buf, "E.Must select a single thread.");
      return -1;
    }

  thread = find_thread_ptid (general_thread);
  if (thread == NULL)
    {
      strcpy (own_buf, "E.No such thread.");
      return -1;
    }

  err = NULL;

  if (strcmp (op, "bts") == 0)
    err = handle_btrace_enable (thread);
  else if (strcmp (op, "off") == 0)
    err = handle_btrace_disable (thread);
  else
    err = "E.Bad Qbtrace operation. Use bts or off.";

  if (err != 0)
    strcpy (own_buf, err);
  else
    write_ok (own_buf);

  return 1;
}

/* Handle all of the extended 'Q' packets.  */

static void
handle_general_set (char *own_buf)
{
  if (strncmp ("QPassSignals:", own_buf, strlen ("QPassSignals:")) == 0)
    {
      int numsigs = (int) GDB_SIGNAL_LAST, i;
      const char *p = own_buf + strlen ("QPassSignals:");
      CORE_ADDR cursig;

      p = decode_address_to_semicolon (&cursig, p);
      for (i = 0; i < numsigs; i++)
	{
	  if (i == cursig)
	    {
	      pass_signals[i] = 1;
	      if (*p == '\0')
		/* Keep looping, to clear the remaining signals.  */
		cursig = -1;
	      else
		p = decode_address_to_semicolon (&cursig, p);
	    }
	  else
	    pass_signals[i] = 0;
	}
      strcpy (own_buf, "OK");
      return;
    }

  if (strncmp ("QProgramSignals:", own_buf, strlen ("QProgramSignals:")) == 0)
    {
      int numsigs = (int) GDB_SIGNAL_LAST, i;
      const char *p = own_buf + strlen ("QProgramSignals:");
      CORE_ADDR cursig;

      program_signals_p = 1;

      p = decode_address_to_semicolon (&cursig, p);
      for (i = 0; i < numsigs; i++)
	{
	  if (i == cursig)
	    {
	      program_signals[i] = 1;
	      if (*p == '\0')
		/* Keep looping, to clear the remaining signals.  */
		cursig = -1;
	      else
		p = decode_address_to_semicolon (&cursig, p);
	    }
	  else
	    program_signals[i] = 0;
	}
      strcpy (own_buf, "OK");
      return;
    }

  if (strcmp (own_buf, "QStartNoAckMode") == 0)
    {
      if (remote_debug)
	{
	  fprintf (stderr, "[noack mode enabled]\n");
	  fflush (stderr);
	}

      noack_mode = 1;
      write_ok (own_buf);
      return;
    }

  if (strncmp (own_buf, "QNonStop:", 9) == 0)
    {
      char *mode = own_buf + 9;
      int req = -1;
      char *req_str;

      if (strcmp (mode, "0") == 0)
	req = 0;
      else if (strcmp (mode, "1") == 0)
	req = 1;
      else
	{
	  /* We don't know what this mode is, so complain to
	     GDB.  */
	  fprintf (stderr, "Unknown non-stop mode requested: %s\n",
		   own_buf);
	  write_enn (own_buf);
	  return;
	}

      req_str = req ? "non-stop" : "all-stop";
      if (start_non_stop (req) != 0)
	{
	  fprintf (stderr, "Setting %s mode failed\n", req_str);
	  write_enn (own_buf);
	  return;
	}

      non_stop = req;

      if (remote_debug)
	fprintf (stderr, "[%s mode enabled]\n", req_str);

      write_ok (own_buf);
      return;
    }

  if (strncmp ("QDisableRandomization:", own_buf,
	       strlen ("QDisableRandomization:")) == 0)
    {
      char *packet = own_buf + strlen ("QDisableRandomization:");
      ULONGEST setting;

      unpack_varlen_hex (packet, &setting);
      disable_randomization = setting;

      if (remote_debug)
	{
	  if (disable_randomization)
	    fprintf (stderr, "[address space randomization disabled]\n");
	  else
	    fprintf (stderr, "[address space randomization enabled]\n");
	}

      write_ok (own_buf);
      return;
    }

  if (target_supports_tracepoints ()
      && handle_tracepoint_general_set (own_buf))
    return;

  if (strncmp ("QAgent:", own_buf, strlen ("QAgent:")) == 0)
    {
      char *mode = own_buf + strlen ("QAgent:");
      int req = 0;

      if (strcmp (mode, "0") == 0)
	req = 0;
      else if (strcmp (mode, "1") == 0)
	req = 1;
      else
	{
	  /* We don't know what this value is, so complain to GDB.  */
	  sprintf (own_buf, "E.Unknown QAgent value");
	  return;
	}

      /* Update the flag.  */
      use_agent = req;
      if (remote_debug)
	fprintf (stderr, "[%s agent]\n", req ? "Enable" : "Disable");
      write_ok (own_buf);
      return;
    }

  if (handle_btrace_general_set (own_buf))
    return;

  /* Otherwise we didn't know what packet it was.  Say we didn't
     understand it.  */
  own_buf[0] = 0;
}

static const char *
get_features_xml (const char *annex)
{
  const struct target_desc *desc = current_target_desc ();

  /* `desc->xmltarget' defines what to return when looking for the
     "target.xml" file.  Its contents can either be verbatim XML code
     (prefixed with a '@@') or else the name of the actual XML file to
     be used in place of "target.xml".

     This variable is set up from the auto-generated
     init_registers_... routine for the current target.  */

  if (desc->xmltarget != NULL && strcmp (annex, "target.xml") == 0)
    {
      if (*desc->xmltarget == '@@')
	return desc->xmltarget + 1;
      else
	annex = desc->xmltarget;
    }

#ifdef USE_XML
  {
    extern const char *const xml_builtin[][2];
    int i;

    /* Look for the annex.  */
    for (i = 0; xml_builtin[i][0] != NULL; i++)
      if (strcmp (annex, xml_builtin[i][0]) == 0)
	break;

    if (xml_builtin[i][0] != NULL)
      return xml_builtin[i][1];
  }
#endif

  return NULL;
}

void
monitor_show_help (void)
{
  monitor_output ("The following monitor commands are supported:\n");
  monitor_output ("  set debug <0|1>\n");
  monitor_output ("    Enable general debugging messages\n");
  monitor_output ("  set debug-hw-points <0|1>\n");
  monitor_output ("    Enable h/w breakpoint/watchpoint debugging messages\n");
  monitor_output ("  set remote-debug <0|1>\n");
  monitor_output ("    Enable remote protocol debugging messages\n");
  monitor_output ("  exit\n");
  monitor_output ("    Quit GDBserver\n");
}

/* Read trace frame or inferior memory.  Returns the number of bytes
   actually read, zero when no further transfer is possible, and -1 on
   error.  Return of a positive value smaller than LEN does not
   indicate there's no more to be read, only the end of the transfer.
   E.g., when GDB reads memory from a traceframe, a first request may
   be served from a memory block that does not cover the whole request
   length.  A following request gets the rest served from either
   another block (of the same traceframe) or from the read-only
   regions.  */

static int
gdb_read_memory (CORE_ADDR memaddr, unsigned char *myaddr, int len)
{
  int res;

  if (current_traceframe >= 0)
    {
      ULONGEST nbytes;
      ULONGEST length = len;

      if (traceframe_read_mem (current_traceframe,
			       memaddr, myaddr, len, &nbytes))
	return -1;
      /* Data read from trace buffer, we're done.  */
      if (nbytes > 0)
	return nbytes;
      if (!in_readonly_region (memaddr, length))
	return -1;
      /* Otherwise we have a valid readonly case, fall through.  */
      /* (assume no half-trace half-real blocks for now) */
    }

  res = prepare_to_access_memory ();
  if (res == 0)
    {
      res = read_inferior_memory (memaddr, myaddr, len);
      done_accessing_memory ();

      return res == 0 ? len : -1;
    }
  else
    return -1;
}

/* Write trace frame or inferior memory.  Actually, writing to trace
   frames is forbidden.  */

static int
gdb_write_memory (CORE_ADDR memaddr, const unsigned char *myaddr, int len)
{
  if (current_traceframe >= 0)
    return EIO;
  else
    {
      int ret;

      ret = prepare_to_access_memory ();
      if (ret == 0)
	{
	  ret = write_inferior_memory (memaddr, myaddr, len);
	  done_accessing_memory ();
	}
      return ret;
    }
}

/* Subroutine of handle_search_memory to simplify it.  */

static int
handle_search_memory_1 (CORE_ADDR start_addr, CORE_ADDR search_space_len,
			gdb_byte *pattern, unsigned pattern_len,
			gdb_byte *search_buf,
			unsigned chunk_size, unsigned search_buf_size,
			CORE_ADDR *found_addrp)
{
  /* Prime the search buffer.  */

  if (gdb_read_memory (start_addr, search_buf, search_buf_size)
      != search_buf_size)
    {
      warning ("Unable to access %ld bytes of target "
	       "memory at 0x%lx, halting search.",
	       (long) search_buf_size, (long) start_addr);
      return -1;
    }

  /* Perform the search.

     The loop is kept simple by allocating [N + pattern-length - 1] bytes.
     When we've scanned N bytes we copy the trailing bytes to the start and
     read in another N bytes.  */

  while (search_space_len >= pattern_len)
    {
      gdb_byte *found_ptr;
      unsigned nr_search_bytes = (search_space_len < search_buf_size
				  ? search_space_len
				  : search_buf_size);

      found_ptr = memmem (search_buf, nr_search_bytes, pattern, pattern_len);

      if (found_ptr != NULL)
	{
	  CORE_ADDR found_addr = start_addr + (found_ptr - search_buf);
	  *found_addrp = found_addr;
	  return 1;
	}

      /* Not found in this chunk, skip to next chunk.  */

      /* Don't let search_space_len wrap here, it's unsigned.  */
      if (search_space_len >= chunk_size)
	search_space_len -= chunk_size;
      else
	search_space_len = 0;

      if (search_space_len >= pattern_len)
	{
	  unsigned keep_len = search_buf_size - chunk_size;
	  CORE_ADDR read_addr = start_addr + chunk_size + keep_len;
	  int nr_to_read;

	  /* Copy the trailing part of the previous iteration to the front
	     of the buffer for the next iteration.  */
	  memcpy (search_buf, search_buf + chunk_size, keep_len);

	  nr_to_read = (search_space_len - keep_len < chunk_size
			? search_space_len - keep_len
			: chunk_size);

	  if (gdb_read_memory (read_addr, search_buf + keep_len,
			       nr_to_read) != search_buf_size)
	    {
	      warning ("Unable to access %ld bytes of target memory "
		       "at 0x%lx, halting search.",
		       (long) nr_to_read, (long) read_addr);
	      return -1;
	    }

	  start_addr += chunk_size;
	}
    }

  /* Not found.  */

  return 0;
}

/* Handle qSearch:memory packets.  */

static void
handle_search_memory (char *own_buf, int packet_len)
{
  CORE_ADDR start_addr;
  CORE_ADDR search_space_len;
  gdb_byte *pattern;
  unsigned int pattern_len;
  /* NOTE: also defined in find.c testcase.  */
#define SEARCH_CHUNK_SIZE 16000
  const unsigned chunk_size = SEARCH_CHUNK_SIZE;
  /* Buffer to hold memory contents for searching.  */
  gdb_byte *search_buf;
  unsigned search_buf_size;
  int found;
  CORE_ADDR found_addr;
  int cmd_name_len = sizeof ("qSearch:memory:") - 1;

  pattern = malloc (packet_len);
  if (pattern == NULL)
    {
      error ("Unable to allocate memory to perform the search");
      strcpy (own_buf, "E00");
      return;
    }
  if (decode_search_memory_packet (own_buf + cmd_name_len,
				   packet_len - cmd_name_len,
				   &start_addr, &search_space_len,
				   pattern, &pattern_len) < 0)
    {
      free (pattern);
      error ("Error in parsing qSearch:memory packet");
      strcpy (own_buf, "E00");
      return;
    }

  search_buf_size = chunk_size + pattern_len - 1;

  /* No point in trying to allocate a buffer larger than the search space.  */
  if (search_space_len < search_buf_size)
    search_buf_size = search_space_len;

  search_buf = malloc (search_buf_size);
  if (search_buf == NULL)
    {
      free (pattern);
      error ("Unable to allocate memory to perform the search");
      strcpy (own_buf, "E00");
      return;
    }

  found = handle_search_memory_1 (start_addr, search_space_len,
				  pattern, pattern_len,
				  search_buf, chunk_size, search_buf_size,
				  &found_addr);

  if (found > 0)
    sprintf (own_buf, "1,%lx", (long) found_addr);
  else if (found == 0)
    strcpy (own_buf, "0");
  else
    strcpy (own_buf, "E00");

  free (search_buf);
  free (pattern);
}

#define require_running(BUF)			\
  if (!target_running ())			\
    {						\
      write_enn (BUF);				\
      return;					\
    }

/* Handle monitor commands not handled by target-specific handlers.  */

static void
handle_monitor_command (char *mon, char *own_buf)
{
  if (strcmp (mon, "set debug 1") == 0)
    {
      debug_threads = 1;
      monitor_output ("Debug output enabled.\n");
    }
  else if (strcmp (mon, "set debug 0") == 0)
    {
      debug_threads = 0;
      monitor_output ("Debug output disabled.\n");
    }
  else if (strcmp (mon, "set debug-hw-points 1") == 0)
    {
      debug_hw_points = 1;
      monitor_output ("H/W point debugging output enabled.\n");
    }
  else if (strcmp (mon, "set debug-hw-points 0") == 0)
    {
      debug_hw_points = 0;
      monitor_output ("H/W point debugging output disabled.\n");
    }
  else if (strcmp (mon, "set remote-debug 1") == 0)
    {
      remote_debug = 1;
      monitor_output ("Protocol debug output enabled.\n");
    }
  else if (strcmp (mon, "set remote-debug 0") == 0)
    {
      remote_debug = 0;
      monitor_output ("Protocol debug output disabled.\n");
    }
  else if (strcmp (mon, "help") == 0)
    monitor_show_help ();
  else if (strcmp (mon, "exit") == 0)
    exit_requested = 1;
  else
    {
      monitor_output ("Unknown monitor command.\n\n");
      monitor_show_help ();
      write_enn (own_buf);
    }
}

/* Associates a callback with each supported qXfer'able object.  */

struct qxfer
{
  /* The object this handler handles.  */
  const char *object;

  /* Request that the target transfer up to LEN 8-bit bytes of the
     target's OBJECT.  The OFFSET, for a seekable object, specifies
     the starting point.  The ANNEX can be used to provide additional
     data-specific information to the target.

     Return the number of bytes actually transfered, zero when no
     further transfer is possible, -1 on error, -2 when the transfer
     is not supported, and -3 on a verbose error message that should
     be preserved.  Return of a positive value smaller than LEN does
     not indicate the end of the object, only the end of the transfer.

     One, and only one, of readbuf or writebuf must be non-NULL.  */
  int (*xfer) (const char *annex,
	       gdb_byte *readbuf, const gdb_byte *writebuf,
	       ULONGEST offset, LONGEST len);
};

/* Handle qXfer:auxv:read.  */

static int
handle_qxfer_auxv (const char *annex,
		   gdb_byte *readbuf, const gdb_byte *writebuf,
		   ULONGEST offset, LONGEST len)
{
  if (the_target->read_auxv == NULL || writebuf != NULL)
    return -2;

  if (annex[0] != '\0' || !target_running ())
    return -1;

  return (*the_target->read_auxv) (offset, readbuf, len);
}

/* Handle qXfer:features:read.  */

static int
handle_qxfer_features (const char *annex,
		       gdb_byte *readbuf, const gdb_byte *writebuf,
		       ULONGEST offset, LONGEST len)
{
  const char *document;
  size_t total_len;

  if (writebuf != NULL)
    return -2;

  if (!target_running ())
    return -1;

  /* Grab the correct annex.  */
  document = get_features_xml (annex);
  if (document == NULL)
    return -1;

  total_len = strlen (document);

  if (offset > total_len)
    return -1;

  if (offset + len > total_len)
    len = total_len - offset;

  memcpy (readbuf, document + offset, len);
  return len;
}

/* Handle qXfer:libraries:read.  */

static int
handle_qxfer_libraries (const char *annex,
			gdb_byte *readbuf, const gdb_byte *writebuf,
			ULONGEST offset, LONGEST len)
{
  unsigned int total_len;
  char *document, *p;
  struct inferior_list_entry *dll_ptr;

  if (writebuf != NULL)
    return -2;

  if (annex[0] != '\0' || !target_running ())
    return -1;

  /* Over-estimate the necessary memory.  Assume that every character
     in the library name must be escaped.  */
  total_len = 64;
  for (dll_ptr = all_dlls.head; dll_ptr != NULL; dll_ptr = dll_ptr->next)
    total_len += 128 + 6 * strlen (((struct dll_info *) dll_ptr)->name);

  document = malloc (total_len);
  if (document == NULL)
    return -1;

  strcpy (document, "<library-list>\n");
  p = document + strlen (document);

  for (dll_ptr = all_dlls.head; dll_ptr != NULL; dll_ptr = dll_ptr->next)
    {
      struct dll_info *dll = (struct dll_info *) dll_ptr;
      char *name;

      strcpy (p, "  <library name=\"");
      p = p + strlen (p);
      name = xml_escape_text (dll->name);
      strcpy (p, name);
      free (name);
      p = p + strlen (p);
      strcpy (p, "\"><segment address=\"");
      p = p + strlen (p);
      sprintf (p, "0x%lx", (long) dll->base_addr);
      p = p + strlen (p);
      strcpy (p, "\"/></library>\n");
      p = p + strlen (p);
    }

  strcpy (p, "</library-list>\n");

  total_len = strlen (document);

  if (offset > total_len)
    {
      free (document);
      return -1;
    }

  if (offset + len > total_len)
    len = total_len - offset;

  memcpy (readbuf, document + offset, len);
  free (document);
  return len;
}

/* Handle qXfer:libraries-svr4:read.  */

static int
handle_qxfer_libraries_svr4 (const char *annex,
			     gdb_byte *readbuf, const gdb_byte *writebuf,
			     ULONGEST offset, LONGEST len)
{
  if (writebuf != NULL)
    return -2;

  if (!target_running () || the_target->qxfer_libraries_svr4 == NULL)
    return -1;

  return the_target->qxfer_libraries_svr4 (annex, readbuf, writebuf, offset, len);
}

/* Handle qXfer:osadata:read.  */

static int
handle_qxfer_osdata (const char *annex,
		     gdb_byte *readbuf, const gdb_byte *writebuf,
		     ULONGEST offset, LONGEST len)
{
  if (the_target->qxfer_osdata == NULL || writebuf != NULL)
    return -2;

  return (*the_target->qxfer_osdata) (annex, readbuf, NULL, offset, len);
}

/* Handle qXfer:siginfo:read and qXfer:siginfo:write.  */

static int
handle_qxfer_siginfo (const char *annex,
		      gdb_byte *readbuf, const gdb_byte *writebuf,
		      ULONGEST offset, LONGEST len)
{
  if (the_target->qxfer_siginfo == NULL)
    return -2;

  if (annex[0] != '\0' || !target_running ())
    return -1;

  return (*the_target->qxfer_siginfo) (annex, readbuf, writebuf, offset, len);
}

/* Handle qXfer:spu:read and qXfer:spu:write.  */

static int
handle_qxfer_spu (const char *annex,
		  gdb_byte *readbuf, const gdb_byte *writebuf,
		  ULONGEST offset, LONGEST len)
{
  if (the_target->qxfer_spu == NULL)
    return -2;

  if (!target_running ())
    return -1;

  return (*the_target->qxfer_spu) (annex, readbuf, writebuf, offset, len);
}

/* Handle qXfer:statictrace:read.  */

static int
handle_qxfer_statictrace (const char *annex,
			  gdb_byte *readbuf, const gdb_byte *writebuf,
			  ULONGEST offset, LONGEST len)
{
  ULONGEST nbytes;

  if (writebuf != NULL)
    return -2;

  if (annex[0] != '\0' || !target_running () || current_traceframe == -1)
    return -1;

  if (traceframe_read_sdata (current_traceframe, offset,
			     readbuf, len, &nbytes))
    return -1;
  return nbytes;
}

/* Helper for handle_qxfer_threads.  */

static void
handle_qxfer_threads_proper (struct buffer *buffer)
{
  struct inferior_list_entry *thread;

  buffer_grow_str (buffer, "<threads>\n");

  for (thread = all_threads.head; thread; thread = thread->next)
    {
      ptid_t ptid = thread_to_gdb_id ((struct thread_info *)thread);
      char ptid_s[100];
      int core = target_core_of_thread (ptid);
      char core_s[21];

      write_ptid (ptid_s, ptid);

      if (core != -1)
	{
	  sprintf (core_s, "%d", core);
	  buffer_xml_printf (buffer, "<thread id=\"%s\" core=\"%s\"/>\n",
			     ptid_s, core_s);
	}
      else
	{
	  buffer_xml_printf (buffer, "<thread id=\"%s\"/>\n",
			     ptid_s);
	}
    }

  buffer_grow_str0 (buffer, "</threads>\n");
}

/* Handle qXfer:threads:read.  */

static int
handle_qxfer_threads (const char *annex,
		      gdb_byte *readbuf, const gdb_byte *writebuf,
		      ULONGEST offset, LONGEST len)
{
  static char *result = 0;
  static unsigned int result_length = 0;

  if (writebuf != NULL)
    return -2;

  if (!target_running () || annex[0] != '\0')
    return -1;

  if (offset == 0)
    {
      struct buffer buffer;
      /* When asked for data at offset 0, generate everything and store into
	 'result'.  Successive reads will be served off 'result'.  */
      if (result)
	free (result);

      buffer_init (&buffer);

      handle_qxfer_threads_proper (&buffer);

      result = buffer_finish (&buffer);
      result_length = strlen (result);
      buffer_free (&buffer);
    }

  if (offset >= result_length)
    {
      /* We're out of data.  */
      free (result);
      result = NULL;
      result_length = 0;
      return 0;
    }

  if (len > result_length - offset)
    len = result_length - offset;

  memcpy (readbuf, result + offset, len);

  return len;
}

/* Handle qXfer:traceframe-info:read.  */

static int
handle_qxfer_traceframe_info (const char *annex,
			      gdb_byte *readbuf, const gdb_byte *writebuf,
			      ULONGEST offset, LONGEST len)
{
  static char *result = 0;
  static unsigned int result_length = 0;

  if (writebuf != NULL)
    return -2;

  if (!target_running () || annex[0] != '\0' || current_traceframe == -1)
    return -1;

  if (offset == 0)
    {
      struct buffer buffer;

      /* When asked for data at offset 0, generate everything and
	 store into 'result'.  Successive reads will be served off
	 'result'.  */
      free (result);

      buffer_init (&buffer);

      traceframe_read_info (current_traceframe, &buffer);

      result = buffer_finish (&buffer);
      result_length = strlen (result);
      buffer_free (&buffer);
    }

  if (offset >= result_length)
    {
      /* We're out of data.  */
      free (result);
      result = NULL;
      result_length = 0;
      return 0;
    }

  if (len > result_length - offset)
    len = result_length - offset;

  memcpy (readbuf, result + offset, len);
  return len;
}

/* Handle qXfer:fdpic:read.  */

static int
handle_qxfer_fdpic (const char *annex, gdb_byte *readbuf,
		    const gdb_byte *writebuf, ULONGEST offset, LONGEST len)
{
  if (the_target->read_loadmap == NULL)
    return -2;

  if (!target_running ())
    return -1;

  return (*the_target->read_loadmap) (annex, offset, readbuf, len);
}

/* Handle qXfer:btrace:read.  */

static int
handle_qxfer_btrace (const char *annex,
		     gdb_byte *readbuf, const gdb_byte *writebuf,
		     ULONGEST offset, LONGEST len)
{
  static struct buffer cache;
  struct thread_info *thread;
  int type;

  if (the_target->read_btrace == NULL || writebuf != NULL)
    return -2;

  if (!target_running ())
    return -1;

  if (ptid_equal (general_thread, null_ptid)
      || ptid_equal (general_thread, minus_one_ptid))
    {
      strcpy (own_buf, "E.Must select a single thread.");
      return -3;
    }

  thread = find_thread_ptid (general_thread);
  if (thread == NULL)
    {
      strcpy (own_buf, "E.No such thread.");
      return -3;
    }

  if (thread->btrace == NULL)
    {
      strcpy (own_buf, "E.Btrace not enabled.");
      return -3;
    }

  if (strcmp (annex, "all") == 0)
    type = btrace_read_all;
  else if (strcmp (annex, "new") == 0)
    type = btrace_read_new;
  else
    {
      strcpy (own_buf, "E.Bad annex.");
      return -3;
    }

  if (offset == 0)
    {
      buffer_free (&cache);

      target_read_btrace (thread->btrace, &cache, type);
    }
  else if (offset > cache.used_size)
    {
      buffer_free (&cache);
      return -3;
    }

  if (len > cache.used_size - offset)
    len = cache.used_size - offset;

  memcpy (readbuf, cache.buffer + offset, len);

  return len;
}

static const struct qxfer qxfer_packets[] =
  {
    { "auxv", handle_qxfer_auxv },
    { "btrace", handle_qxfer_btrace },
    { "fdpic", handle_qxfer_fdpic},
    { "features", handle_qxfer_features },
    { "libraries", handle_qxfer_libraries },
    { "libraries-svr4", handle_qxfer_libraries_svr4 },
    { "osdata", handle_qxfer_osdata },
    { "siginfo", handle_qxfer_siginfo },
    { "spu", handle_qxfer_spu },
    { "statictrace", handle_qxfer_statictrace },
    { "threads", handle_qxfer_threads },
    { "traceframe-info", handle_qxfer_traceframe_info },
  };

static int
handle_qxfer (char *own_buf, int packet_len, int *new_packet_len_p)
{
  int i;
  char *object;
  char *rw;
  char *annex;
  char *offset;

  if (strncmp (own_buf, "qXfer:", 6) != 0)
    return 0;

  /* Grab the object, r/w and annex.  */
  if (decode_xfer (own_buf + 6, &object, &rw, &annex, &offset) < 0)
    {
      write_enn (own_buf);
      return 1;
    }

  for (i = 0;
       i < sizeof (qxfer_packets) / sizeof (qxfer_packets[0]);
       i++)
    {
      const struct qxfer *q = &qxfer_packets[i];

      if (strcmp (object, q->object) == 0)
	{
	  if (strcmp (rw, "read") == 0)
	    {
	      unsigned char *data;
	      int n;
	      CORE_ADDR ofs;
	      unsigned int len;

	      /* Grab the offset and length.  */
	      if (decode_xfer_read (offset, &ofs, &len) < 0)
		{
		  write_enn (own_buf);
		  return 1;
		}

	      /* Read one extra byte, as an indicator of whether there is
		 more.  */
	      if (len > PBUFSIZ - 2)
		len = PBUFSIZ - 2;
	      data = malloc (len + 1);
	      if (data == NULL)
		{
		  write_enn (own_buf);
		  return 1;
		}
	      n = (*q->xfer) (annex, data, NULL, ofs, len + 1);
	      if (n == -2)
		{
		  free (data);
		  return 0;
		}
	      else if (n == -3)
		{
		  /* Preserve error message.  */
		}
	      else if (n < 0)
		write_enn (own_buf);
	      else if (n > len)
		*new_packet_len_p = write_qxfer_response (own_buf, data, len, 1);
	      else
		*new_packet_len_p = write_qxfer_response (own_buf, data, n, 0);

	      free (data);
	      return 1;
	    }
	  else if (strcmp (rw, "write") == 0)
	    {
	      int n;
	      unsigned int len;
	      CORE_ADDR ofs;
	      unsigned char *data;

	      strcpy (own_buf, "E00");
	      data = malloc (packet_len - (offset - own_buf));
	      if (data == NULL)
		{
		  write_enn (own_buf);
		  return 1;
		}
	      if (decode_xfer_write (offset, packet_len - (offset - own_buf),
				     &ofs, &len, data) < 0)
		{
		  free (data);
		  write_enn (own_buf);
		  return 1;
		}

	      n = (*q->xfer) (annex, NULL, data, ofs, len);
	      if (n == -2)
		{
		  free (data);
		  return 0;
		}
	      else if (n == -3)
		{
		  /* Preserve error message.  */
		}
	      else if (n < 0)
		write_enn (own_buf);
	      else
		sprintf (own_buf, "%x", n);

	      free (data);
	      return 1;
	    }

	  return 0;
	}
    }

  return 0;
}

/* Table used by the crc32 function to calcuate the checksum.  */

static unsigned int crc32_table[256] =
{0, 0};

/* Compute 32 bit CRC from inferior memory.

   On success, return 32 bit CRC.
   On failure, return (unsigned long long) -1.  */

static unsigned long long
crc32 (CORE_ADDR base, int len, unsigned int crc)
{
  if (!crc32_table[1])
    {
      /* Initialize the CRC table and the decoding table.  */
      int i, j;
      unsigned int c;

      for (i = 0; i < 256; i++)
	{
	  for (c = i << 24, j = 8; j > 0; --j)
	    c = c & 0x80000000 ? (c << 1) ^ 0x04c11db7 : (c << 1);
	  crc32_table[i] = c;
	}
    }

  while (len--)
    {
      unsigned char byte = 0;

      /* Return failure if memory read fails.  */
      if (read_inferior_memory (base, &byte, 1) != 0)
	return (unsigned long long) -1;

      crc = (crc << 8) ^ crc32_table[((crc >> 24) ^ byte) & 255];
      base++;
    }
  return (unsigned long long) crc;
}

/* Handle all of the extended 'q' packets.  */

void
handle_query (char *own_buf, int packet_len, int *new_packet_len_p)
{
  static struct inferior_list_entry *thread_ptr;

  /* Reply the current thread id.  */
  if (strcmp ("qC", own_buf) == 0 && !disable_packet_qC)
    {
      ptid_t gdb_id;
      require_running (own_buf);

      if (!ptid_equal (general_thread, null_ptid)
	  && !ptid_equal (general_thread, minus_one_ptid))
	gdb_id = general_thread;
      else
	{
	  thread_ptr = all_threads.head;
	  gdb_id = thread_to_gdb_id ((struct thread_info *)thread_ptr);
	}

      sprintf (own_buf, "QC");
      own_buf += 2;
      write_ptid (own_buf, gdb_id);
      return;
    }

  if (strcmp ("qSymbol::", own_buf) == 0)
    {
      /* GDB is suggesting new symbols have been loaded.  This may
	 mean a new shared library has been detected as loaded, so
	 take the opportunity to check if breakpoints we think are
	 inserted, still are.  Note that it isn't guaranteed that
	 we'll see this when a shared library is loaded, and nor will
	 we see this for unloads (although breakpoints in unloaded
	 libraries shouldn't trigger), as GDB may not find symbols for
	 the library at all.  We also re-validate breakpoints when we
	 see a second GDB breakpoint for the same address, and or when
	 we access breakpoint shadows.  */
      validate_breakpoints ();

      if (target_supports_tracepoints ())
	tracepoint_look_up_symbols ();

      if (target_running () && the_target->look_up_symbols != NULL)
	(*the_target->look_up_symbols) ();

      strcpy (own_buf, "OK");
      return;
    }

  if (!disable_packet_qfThreadInfo)
    {
      if (strcmp ("qfThreadInfo", own_buf) == 0)
	{
	  ptid_t gdb_id;

	  require_running (own_buf);
	  thread_ptr = all_threads.head;

	  *own_buf++ = 'm';
	  gdb_id = thread_to_gdb_id ((struct thread_info *)thread_ptr);
	  write_ptid (own_buf, gdb_id);
	  thread_ptr = thread_ptr->next;
	  return;
	}

      if (strcmp ("qsThreadInfo", own_buf) == 0)
	{
	  ptid_t gdb_id;

	  require_running (own_buf);
	  if (thread_ptr != NULL)
	    {
	      *own_buf++ = 'm';
	      gdb_id = thread_to_gdb_id ((struct thread_info *)thread_ptr);
	      write_ptid (own_buf, gdb_id);
	      thread_ptr = thread_ptr->next;
	      return;
	    }
	  else
	    {
	      sprintf (own_buf, "l");
	      return;
	    }
	}
    }

  if (the_target->read_offsets != NULL
      && strcmp ("qOffsets", own_buf) == 0)
    {
      CORE_ADDR text, data;

      require_running (own_buf);
      if (the_target->read_offsets (&text, &data))
	sprintf (own_buf, "Text=%lX;Data=%lX;Bss=%lX",
		 (long)text, (long)data, (long)data);
      else
	write_enn (own_buf);

      return;
    }

  /* Protocol features query.  */
  if (strncmp ("qSupported", own_buf, 10) == 0
      && (own_buf[10] == ':' || own_buf[10] == '\0'))
    {
      char *p = &own_buf[10];
      int gdb_supports_qRelocInsn = 0;

      /* Start processing qSupported packet.  */
      target_process_qsupported (NULL);

      /* Process each feature being provided by GDB.  The first
	 feature will follow a ':', and latter features will follow
	 ';'.  */
      if (*p == ':')
	{
	  char **qsupported = NULL;
	  int count = 0;
	  int i;

	  /* Two passes, to avoid nested strtok calls in
	     target_process_qsupported.  */
	  for (p = strtok (p + 1, ";");
	       p != NULL;
	       p = strtok (NULL, ";"))
	    {
	      count++;
	      qsupported = xrealloc (qsupported, count * sizeof (char *));
	      qsupported[count - 1] = xstrdup (p);
	    }

	  for (i = 0; i < count; i++)
	    {
	      p = qsupported[i];
	      if (strcmp (p, "multiprocess+") == 0)
		{
		  /* GDB supports and wants multi-process support if
		     possible.  */
		  if (target_supports_multi_process ())
		    multi_process = 1;
		}
	      else if (strcmp (p, "qRelocInsn+") == 0)
		{
		  /* GDB supports relocate instruction requests.  */
		  gdb_supports_qRelocInsn = 1;
		}
	      else
		target_process_qsupported (p);

	      free (p);
	    }

	  free (qsupported);
	}

      sprintf (own_buf,
	       "PacketSize=%x;QPassSignals+;QProgramSignals+",
	       PBUFSIZ - 1);

      if (the_target->qxfer_libraries_svr4 != NULL)
	strcat (own_buf, ";qXfer:libraries-svr4:read+"
		";augmented-libraries-svr4-read+");
      else
	{
	  /* We do not have any hook to indicate whether the non-SVR4 target
	     backend supports qXfer:libraries:read, so always report it.  */
	  strcat (own_buf, ";qXfer:libraries:read+");
	}

      if (the_target->read_auxv != NULL)
	strcat (own_buf, ";qXfer:auxv:read+");

      if (the_target->qxfer_spu != NULL)
	strcat (own_buf, ";qXfer:spu:read+;qXfer:spu:write+");

      if (the_target->qxfer_siginfo != NULL)
	strcat (own_buf, ";qXfer:siginfo:read+;qXfer:siginfo:write+");

      if (the_target->read_loadmap != NULL)
	strcat (own_buf, ";qXfer:fdpic:read+");

      /* We always report qXfer:features:read, as targets may
	 install XML files on a subsequent call to arch_setup.
	 If we reported to GDB on startup that we don't support
	 qXfer:feature:read at all, we will never be re-queried.  */
      strcat (own_buf, ";qXfer:features:read+");

      if (transport_is_reliable)
	strcat (own_buf, ";QStartNoAckMode+");

      if (the_target->qxfer_osdata != NULL)
	strcat (own_buf, ";qXfer:osdata:read+");

      if (target_supports_multi_process ())
	strcat (own_buf, ";multiprocess+");

      if (target_supports_non_stop ())
	strcat (own_buf, ";QNonStop+");

      if (target_supports_disable_randomization ())
	strcat (own_buf, ";QDisableRandomization+");

      strcat (own_buf, ";qXfer:threads:read+");

      if (target_supports_tracepoints ())
	{
	  strcat (own_buf, ";ConditionalTracepoints+");
	  strcat (own_buf, ";TraceStateVariables+");
	  strcat (own_buf, ";TracepointSource+");
	  strcat (own_buf, ";DisconnectedTracing+");
	  if (gdb_supports_qRelocInsn && target_supports_fast_tracepoints ())
	    strcat (own_buf, ";FastTracepoints+");
	  strcat (own_buf, ";StaticTracepoints+");
	  strcat (own_buf, ";InstallInTrace+");
	  strcat (own_buf, ";qXfer:statictrace:read+");
	  strcat (own_buf, ";qXfer:traceframe-info:read+");
	  strcat (own_buf, ";EnableDisableTracepoints+");
	  strcat (own_buf, ";QTBuffer:size+");
	  strcat (own_buf, ";tracenz+");
	}

      /* Support target-side breakpoint conditions and commands.  */
      strcat (own_buf, ";ConditionalBreakpoints+");
      strcat (own_buf, ";BreakpointCommands+");

      if (target_supports_agent ())
	strcat (own_buf, ";QAgent+");

      if (target_supports_btrace ())
	{
	  strcat (own_buf, ";Qbtrace:bts+");
	  strcat (own_buf, ";Qbtrace:off+");
	  strcat (own_buf, ";qXfer:btrace:read+");
	}

      return;
    }

  /* Thread-local storage support.  */
  if (the_target->get_tls_address != NULL
      && strncmp ("qGetTLSAddr:", own_buf, 12) == 0)
    {
      char *p = own_buf + 12;
      CORE_ADDR parts[2], address = 0;
      int i, err;
      ptid_t ptid = null_ptid;

      require_running (own_buf);

      for (i = 0; i < 3; i++)
	{
	  char *p2;
	  int len;

	  if (p == NULL)
	    break;

	  p2 = strchr (p, ',');
	  if (p2)
	    {
	      len = p2 - p;
	      p2++;
	    }
	  else
	    {
	      len = strlen (p);
	      p2 = NULL;
	    }

	  if (i == 0)
	    ptid = read_ptid (p, NULL);
	  else
	    decode_address (&parts[i - 1], p, len);
	  p = p2;
	}

      if (p != NULL || i < 3)
	err = 1;
      else
	{
	  struct thread_info *thread = find_thread_ptid (ptid);

	  if (thread == NULL)
	    err = 2;
	  else
	    err = the_target->get_tls_address (thread, parts[0], parts[1],
					       &address);
	}

      if (err == 0)
	{
	  strcpy (own_buf, paddress(address));
	  return;
	}
      else if (err > 0)
	{
	  write_enn (own_buf);
	  return;
	}

      /* Otherwise, pretend we do not understand this packet.  */
    }

  /* Windows OS Thread Information Block address support.  */
  if (the_target->get_tib_address != NULL
      && strncmp ("qGetTIBAddr:", own_buf, 12) == 0)
    {
      char *annex;
      int n;
      CORE_ADDR tlb;
      ptid_t ptid = read_ptid (own_buf + 12, &annex);

      n = (*the_target->get_tib_address) (ptid, &tlb);
      if (n == 1)
	{
	  strcpy (own_buf, paddress(tlb));
	  return;
	}
      else if (n == 0)
	{
	  write_enn (own_buf);
	  return;
	}
      return;
    }

  /* Handle "monitor" commands.  */
  if (strncmp ("qRcmd,", own_buf, 6) == 0)
    {
      char *mon = malloc (PBUFSIZ);
      int len = strlen (own_buf + 6);

      if (mon == NULL)
	{
	  write_enn (own_buf);
	  return;
	}

      if ((len % 2) != 0 || unhexify (mon, own_buf + 6, len / 2) != len / 2)
	{
	  write_enn (own_buf);
	  free (mon);
	  return;
	}
      mon[len / 2] = '\0';

      write_ok (own_buf);

      if (the_target->handle_monitor_command == NULL
	  || (*the_target->handle_monitor_command) (mon) == 0)
	/* Default processing.  */
	handle_monitor_command (mon, own_buf);

      free (mon);
      return;
    }

  if (strncmp ("qSearch:memory:", own_buf,
	       sizeof ("qSearch:memory:") - 1) == 0)
    {
      require_running (own_buf);
      handle_search_memory (own_buf, packet_len);
      return;
    }

  if (strcmp (own_buf, "qAttached") == 0
      || strncmp (own_buf, "qAttached:", sizeof ("qAttached:") - 1) == 0)
    {
      struct process_info *process;

      if (own_buf[sizeof ("qAttached") - 1])
	{
	  int pid = strtoul (own_buf + sizeof ("qAttached:") - 1, NULL, 16);
	  process = (struct process_info *)
	    find_inferior_id (&all_processes, pid_to_ptid (pid));
	}
      else
	{
	  require_running (own_buf);
	  process = current_process ();
	}

      if (process == NULL)
	{
	  write_enn (own_buf);
	  return;
	}

      strcpy (own_buf, process->attached ? "1" : "0");
      return;
    }

  if (strncmp ("qCRC:", own_buf, 5) == 0)
    {
      /* CRC check (compare-section).  */
      char *comma;
      ULONGEST base;
      int len;
      unsigned long long crc;

      require_running (own_buf);
      comma = unpack_varlen_hex (own_buf + 5, &base);
      if (*comma++ != ',')
	{
	  write_enn (own_buf);
	  return;
	}
      len = strtoul (comma, NULL, 16);
      crc = crc32 (base, len, 0xffffffff);
      /* Check for memory failure.  */
      if (crc == (unsigned long long) -1)
	{
	  write_enn (own_buf);
	  return;
	}
      sprintf (own_buf, "C%lx", (unsigned long) crc);
      return;
    }

  if (handle_qxfer (own_buf, packet_len, new_packet_len_p))
    return;

  if (target_supports_tracepoints () && handle_tracepoint_query (own_buf))
    return;

  /* Otherwise we didn't know what packet it was.  Say we didn't
     understand it.  */
  own_buf[0] = 0;
}

static void gdb_wants_all_threads_stopped (void);

/* Parse vCont packets.  */
void
handle_v_cont (char *own_buf)
{
  char *p, *q;
  int n = 0, i = 0;
  struct thread_resume *resume_info;
  struct thread_resume default_action = {{0}};

  /* Count the number of semicolons in the packet.  There should be one
     for every action.  */
  p = &own_buf[5];
  while (p)
    {
      n++;
      p++;
      p = strchr (p, ';');
    }

  resume_info = malloc (n * sizeof (resume_info[0]));
  if (resume_info == NULL)
    goto err;

  p = &own_buf[5];
  while (*p)
    {
      p++;

      memset (&resume_info[i], 0, sizeof resume_info[i]);

      if (p[0] == 's' || p[0] == 'S')
	resume_info[i].kind = resume_step;
      else if (p[0] == 'r')
	resume_info[i].kind = resume_step;
      else if (p[0] == 'c' || p[0] == 'C')
	resume_info[i].kind = resume_continue;
      else if (p[0] == 't')
	resume_info[i].kind = resume_stop;
      else
	goto err;

      if (p[0] == 'S' || p[0] == 'C')
	{
	  int sig;
	  sig = strtol (p + 1, &q, 16);
	  if (p == q)
	    goto err;
	  p = q;

	  if (!gdb_signal_to_host_p (sig))
	    goto err;
	  resume_info[i].sig = gdb_signal_to_host (sig);
	}
      else if (p[0] == 'r')
	{
	  ULONGEST addr;

	  p = unpack_varlen_hex (p + 1, &addr);
	  resume_info[i].step_range_start = addr;

	  if (*p != ',')
	    goto err;

	  p = unpack_varlen_hex (p + 1, &addr);
	  resume_info[i].step_range_end = addr;
	}
      else
	{
	  p = p + 1;
	}

      if (p[0] == 0)
	{
	  resume_info[i].thread = minus_one_ptid;
	  default_action = resume_info[i];

	  /* Note: we don't increment i here, we'll overwrite this entry
	     the next time through.  */
	}
      else if (p[0] == ':')
	{
	  ptid_t ptid = read_ptid (p + 1, &q);

	  if (p == q)
	    goto err;
	  p = q;
	  if (p[0] != ';' && p[0] != 0)
	    goto err;

	  resume_info[i].thread = ptid;

	  i++;
	}
    }

  if (i < n)
    resume_info[i] = default_action;

  /* `cont_thread' is still used in occasional places in the backend,
     to implement single-thread scheduler-locking.  Doesn't make sense
     to set it if we see a stop request, or a wildcard action (one
     with '-1' (all threads), or 'pPID.-1' (all threads of PID)).  */
  if (n == 1
      && !(ptid_equal (resume_info[0].thread, minus_one_ptid)
	   || ptid_get_lwp (resume_info[0].thread) == -1)
      && resume_info[0].kind != resume_stop)
    cont_thread = resume_info[0].thread;
  else
    cont_thread = minus_one_ptid;
  set_desired_inferior (0);

  if (!non_stop)
    enable_async_io ();

  (*the_target->resume) (resume_info, n);

  free (resume_info);

  if (non_stop)
    write_ok (own_buf);
  else
    {
      last_ptid = mywait (minus_one_ptid, &last_status, 0, 1);

      if (last_status.kind != TARGET_WAITKIND_EXITED
          && last_status.kind != TARGET_WAITKIND_SIGNALLED)
	current_inferior->last_status = last_status;

      /* From the client's perspective, all-stop mode always stops all
	 threads implicitly (and the target backend has already done
	 so by now).  Tag all threads as "want-stopped", so we don't
	 resume them implicitly without the client telling us to.  */
      gdb_wants_all_threads_stopped ();
      prepare_resume_reply (own_buf, last_ptid, &last_status);
      disable_async_io ();

      if (last_status.kind == TARGET_WAITKIND_EXITED
          || last_status.kind == TARGET_WAITKIND_SIGNALLED)
        mourn_inferior (find_process_pid (ptid_get_pid (last_ptid)));
    }
  return;

err:
  write_enn (own_buf);
  free (resume_info);
  return;
}

/* Attach to a new program.  Return 1 if successful, 0 if failure.  */
int
handle_v_attach (char *own_buf)
{
  int pid;

  pid = strtol (own_buf + 8, NULL, 16);
  if (pid != 0 && attach_inferior (pid) == 0)
    {
      /* Don't report shared library events after attaching, even if
	 some libraries are preloaded.  GDB will always poll the
	 library list.  Avoids the "stopped by shared library event"
	 notice on the GDB side.  */
      dlls_changed = 0;

      if (non_stop)
	{
	  /* In non-stop, we don't send a resume reply.  Stop events
	     will follow up using the normal notification
	     mechanism.  */
	  write_ok (own_buf);
	}
      else
	prepare_resume_reply (own_buf, last_ptid, &last_status);

      return 1;
    }
  else
    {
      write_enn (own_buf);
      return 0;
    }
}

/* Run a new program.  Return 1 if successful, 0 if failure.  */
static int
handle_v_run (char *own_buf)
{
  char *p, *next_p, **new_argv;
  int i, new_argc;

  new_argc = 0;
  for (p = own_buf + strlen ("vRun;"); p && *p; p = strchr (p, ';'))
    {
      p++;
      new_argc++;
    }

  new_argv = calloc (new_argc + 2, sizeof (char *));
  if (new_argv == NULL)
    {
      write_enn (own_buf);
      return 0;
    }

  i = 0;
  for (p = own_buf + strlen ("vRun;"); *p; p = next_p)
    {
      next_p = strchr (p, ';');
      if (next_p == NULL)
	next_p = p + strlen (p);

      if (i == 0 && p == next_p)
	new_argv[i] = NULL;
      else
	{
	  /* FIXME: Fail request if out of memory instead of dying.  */
	  new_argv[i] = xmalloc (1 + (next_p - p) / 2);
	  unhexify (new_argv[i], p, (next_p - p) / 2);
	  new_argv[i][(next_p - p) / 2] = '\0';
	}

      if (*next_p)
	next_p++;
      i++;
    }
  new_argv[i] = NULL;

  if (new_argv[0] == NULL)
    {
      /* GDB didn't specify a program to run.  Use the program from the
	 last run with the new argument list.  */

      if (program_argv == NULL)
	{
	  write_enn (own_buf);
	  freeargv (new_argv);
	  return 0;
	}

      new_argv[0] = strdup (program_argv[0]);
      if (new_argv[0] == NULL)
	{
	  write_enn (own_buf);
	  freeargv (new_argv);
	  return 0;
	}
    }

  /* Free the old argv and install the new one.  */
  freeargv (program_argv);
  program_argv = new_argv;

  start_inferior (program_argv);
  if (last_status.kind == TARGET_WAITKIND_STOPPED)
    {
      prepare_resume_reply (own_buf, last_ptid, &last_status);

      /* In non-stop, sending a resume reply doesn't set the general
	 thread, but GDB assumes a vRun sets it (this is so GDB can
	 query which is the main thread of the new inferior.  */
      if (non_stop)
	general_thread = last_ptid;

      return 1;
    }
  else
    {
      write_enn (own_buf);
      return 0;
    }
}

/* Kill process.  Return 1 if successful, 0 if failure.  */
int
handle_v_kill (char *own_buf)
{
  int pid;
  char *p = &own_buf[6];
  if (multi_process)
    pid = strtol (p, NULL, 16);
  else
    pid = signal_pid;
  if (pid != 0 && kill_inferior (pid) == 0)
    {
      last_status.kind = TARGET_WAITKIND_SIGNALLED;
      last_status.value.sig = GDB_SIGNAL_KILL;
      last_ptid = pid_to_ptid (pid);
      discard_queued_stop_replies (pid);
      write_ok (own_buf);
      return 1;
    }
  else
    {
      write_enn (own_buf);
      return 0;
    }
}

/* Handle all of the extended 'v' packets.  */
void
handle_v_requests (char *own_buf, int packet_len, int *new_packet_len)
{
  if (!disable_packet_vCont)
    {
      if (strncmp (own_buf, "vCont;", 6) == 0)
	{
	  require_running (own_buf);
	  handle_v_cont (own_buf);
	  return;
	}

      if (strncmp (own_buf, "vCont?", 6) == 0)
	{
	  strcpy (own_buf, "vCont;c;C;s;S;t");
	  if (target_supports_range_stepping ())
	    {
	      own_buf = own_buf + strlen (own_buf);
	      strcpy (own_buf, ";r");
	    }
	  return;
	}
    }

  if (strncmp (own_buf, "vFile:", 6) == 0
      && handle_vFile (own_buf, packet_len, new_packet_len))
    return;

  if (strncmp (own_buf, "vAttach;", 8) == 0)
    {
      if ((!extended_protocol || !multi_process) && target_running ())
	{
	  fprintf (stderr, "Already debugging a process\n");
	  write_enn (own_buf);
	  return;
	}
      handle_v_attach (own_buf);
      return;
    }

  if (strncmp (own_buf, "vRun;", 5) == 0)
    {
      if ((!extended_protocol || !multi_process) && target_running ())
	{
	  fprintf (stderr, "Already debugging a process\n");
	  write_enn (own_buf);
	  return;
	}
      handle_v_run (own_buf);
      return;
    }

  if (strncmp (own_buf, "vKill;", 6) == 0)
    {
      if (!target_running ())
	{
	  fprintf (stderr, "No process to kill\n");
	  write_enn (own_buf);
	  return;
	}
      handle_v_kill (own_buf);
      return;
    }

  if (handle_notif_ack (own_buf, packet_len))
    return;

  /* Otherwise we didn't know what packet it was.  Say we didn't
     understand it.  */
  own_buf[0] = 0;
  return;
}

/* Resume inferior and wait for another event.  In non-stop mode,
   don't really wait here, but return immediatelly to the event
   loop.  */
static void
myresume (char *own_buf, int step, int sig)
{
  struct thread_resume resume_info[2];
  int n = 0;
  int valid_cont_thread;

  set_desired_inferior (0);

  valid_cont_thread = (!ptid_equal (cont_thread, null_ptid)
			 && !ptid_equal (cont_thread, minus_one_ptid));

  if (step || sig || valid_cont_thread)
    {
      resume_info[0].thread = current_ptid;
      if (step)
	resume_info[0].kind = resume_step;
      else
	resume_info[0].kind = resume_continue;
      resume_info[0].sig = sig;
      n++;
    }

  if (!valid_cont_thread)
    {
      resume_info[n].thread = minus_one_ptid;
      resume_info[n].kind = resume_continue;
      resume_info[n].sig = 0;
      n++;
    }

  if (!non_stop)
    enable_async_io ();

  (*the_target->resume) (resume_info, n);

  if (non_stop)
    write_ok (own_buf);
  else
    {
      last_ptid = mywait (minus_one_ptid, &last_status, 0, 1);

      if (last_status.kind != TARGET_WAITKIND_EXITED
          && last_status.kind != TARGET_WAITKIND_SIGNALLED)
	{
	  current_inferior->last_resume_kind = resume_stop;
	  current_inferior->last_status = last_status;
	}

      prepare_resume_reply (own_buf, last_ptid, &last_status);
      disable_async_io ();

      if (last_status.kind == TARGET_WAITKIND_EXITED
          || last_status.kind == TARGET_WAITKIND_SIGNALLED)
        mourn_inferior (find_process_pid (ptid_get_pid (last_ptid)));
    }
}

/* Callback for for_each_inferior.  Make a new stop reply for each
   stopped thread.  */

static int
queue_stop_reply_callback (struct inferior_list_entry *entry, void *arg)
{
  struct thread_info *thread = (struct thread_info *) entry;

  /* For now, assume targets that don't have this callback also don't
     manage the thread's last_status field.  */
  if (the_target->thread_stopped == NULL)
    {
      struct vstop_notif *new_notif = xmalloc (sizeof (*new_notif));

      new_notif->ptid = entry->id;
      new_notif->status = thread->last_status;
      /* Pass the last stop reply back to GDB, but don't notify
	 yet.  */
      notif_event_enque (&notif_stop,
			 (struct notif_event *) new_notif);
    }
  else
    {
      if (thread_stopped (thread))
	{
	  if (debug_threads)
	    {
	      char *status_string
		= target_waitstatus_to_string (&thread->last_status);

	      fprintf (stderr,
		       "Reporting thread %s as already stopped with %s\n",
		       target_pid_to_str (entry->id),
		       status_string);

	      xfree (status_string);
	    }

	  gdb_assert (thread->last_status.kind != TARGET_WAITKIND_IGNORE);

	  /* Pass the last stop reply back to GDB, but don't notify
	     yet.  */
	  queue_stop_reply (entry->id, &thread->last_status);
	}
    }

  return 0;
}

/* Set this inferior threads's state as "want-stopped".  We won't
   resume this thread until the client gives us another action for
   it.  */

static void
gdb_wants_thread_stopped (struct inferior_list_entry *entry)
{
  struct thread_info *thread = (struct thread_info *) entry;

  thread->last_resume_kind = resume_stop;

  if (thread->last_status.kind == TARGET_WAITKIND_IGNORE)
    {
      /* Most threads are stopped implicitly (all-stop); tag that with
	 signal 0.  */
      thread->last_status.kind = TARGET_WAITKIND_STOPPED;
      thread->last_status.value.sig = GDB_SIGNAL_0;
    }
}

/* Set all threads' states as "want-stopped".  */

static void
gdb_wants_all_threads_stopped (void)
{
  for_each_inferior (&all_threads, gdb_wants_thread_stopped);
}

/* Clear the gdb_detached flag of every process.  */

static void
gdb_reattached_process (struct inferior_list_entry *entry)
{
  struct process_info *process = (struct process_info *) entry;

  process->gdb_detached = 0;
}

/* Status handler for the '?' packet.  */

static void
handle_status (char *own_buf)
{
  /* GDB is connected, don't forward events to the target anymore.  */
  for_each_inferior (&all_processes, gdb_reattached_process);

  /* In non-stop mode, we must send a stop reply for each stopped
     thread.  In all-stop mode, just send one for the first stopped
     thread we find.  */

  if (non_stop)
    {
      discard_queued_stop_replies (-1);
      find_inferior (&all_threads, queue_stop_reply_callback, NULL);

      /* The first is sent immediatly.  OK is sent if there is no
	 stopped thread, which is the same handling of the vStopped
	 packet (by design).  */
      notif_write_event (&notif_stop, own_buf);
    }
  else
    {
      pause_all (0);
      stabilize_threads ();
      gdb_wants_all_threads_stopped ();

      if (all_threads.head)
	{
	  struct target_waitstatus status;

	  status.kind = TARGET_WAITKIND_STOPPED;
	  status.value.sig = GDB_SIGNAL_TRAP;
	  prepare_resume_reply (own_buf,
				all_threads.head->id, &status);
	}
      else
	strcpy (own_buf, "W00");
    }
}

static void
gdbserver_version (void)
{
  printf ("GNU gdbserver %s%s\n"
	  "Copyright (C) 2013 Free Software Foundation, Inc.\n"
	  "gdbserver is free software, covered by the "
	  "GNU General Public License.\n"
	  "This gdbserver was configured as \"%s\"\n",
	  PKGVERSION, version, host_name);
}

static void
gdbserver_usage (FILE *stream)
{
  fprintf (stream, "Usage:\tgdbserver [OPTIONS] COMM PROG [ARGS ...]\n"
	   "\tgdbserver [OPTIONS] --attach COMM PID\n"
	   "\tgdbserver [OPTIONS] --multi COMM\n"
	   "\n"
	   "COMM may either be a tty device (for serial debugging), or \n"
	   "HOST:PORT to listen for a TCP connection.\n"
	   "\n"
	   "Options:\n"
	   "  --debug               Enable general debugging output.\n"
	   "  --remote-debug        Enable remote protocol debugging output.\n"
	   "  --version             Display version information and exit.\n"
	   "  --wrapper WRAPPER --  Run WRAPPER to start new programs.\n"
	   "  --once                Exit after the first connection has "
								  "closed.\n");
  if (REPORT_BUGS_TO[0] && stream == stdout)
    fprintf (stream, "Report bugs to \"%s\".\n", REPORT_BUGS_TO);
}

static void
gdbserver_show_disableable (FILE *stream)
{
  fprintf (stream, "Disableable packets:\n"
	   "  vCont       \tAll vCont packets\n"
	   "  qC          \tQuerying the current thread\n"
	   "  qfThreadInfo\tThread listing\n"
	   "  Tthread     \tPassing the thread specifier in the "
	   "T stop reply packet\n"
	   "  threads     \tAll of the above\n");
}


#undef require_running
#define require_running(BUF)			\
  if (!target_running ())			\
    {						\
      write_enn (BUF);				\
      break;					\
    }

static int
first_thread_of (struct inferior_list_entry *entry, void *args)
{
  int pid = * (int *) args;

  if (ptid_get_pid (entry->id) == pid)
    return 1;

  return 0;
}

static void
kill_inferior_callback (struct inferior_list_entry *entry)
{
  struct process_info *process = (struct process_info *) entry;
  int pid = ptid_get_pid (process->head.id);

  kill_inferior (pid);
  discard_queued_stop_replies (pid);
}

/* Callback for for_each_inferior to detach or kill the inferior,
   depending on whether we attached to it or not.
   We inform the user whether we're detaching or killing the process
   as this is only called when gdbserver is about to exit.  */

static void
detach_or_kill_inferior_callback (struct inferior_list_entry *entry)
{
  struct process_info *process = (struct process_info *) entry;
  int pid = ptid_get_pid (process->head.id);

  if (process->attached)
    detach_inferior (pid);
  else
    kill_inferior (pid);

  discard_queued_stop_replies (pid);
}

/* for_each_inferior callback for detach_or_kill_for_exit to print
   the pids of started inferiors.  */

static void
print_started_pid (struct inferior_list_entry *entry)
{
  struct process_info *process = (struct process_info *) entry;

  if (! process->attached)
    {
      int pid = ptid_get_pid (process->head.id);
      fprintf (stderr, " %d", pid);
    }
}

/* for_each_inferior callback for detach_or_kill_for_exit to print
   the pids of attached inferiors.  */

static void
print_attached_pid (struct inferior_list_entry *entry)
{
  struct process_info *process = (struct process_info *) entry;

  if (process->attached)
    {
      int pid = ptid_get_pid (process->head.id);
      fprintf (stderr, " %d", pid);
    }
}

/* Call this when exiting gdbserver with possible inferiors that need
   to be killed or detached from.  */

static void
detach_or_kill_for_exit (void)
{
  /* First print a list of the inferiors we will be killing/detaching.
     This is to assist the user, for example, in case the inferior unexpectedly
     dies after we exit: did we screw up or did the inferior exit on its own?
     Having this info will save some head-scratching.  */

  if (have_started_inferiors_p ())
    {
      fprintf (stderr, "Killing process(es):");
      for_each_inferior (&all_processes, print_started_pid);
      fprintf (stderr, "\n");
    }
  if (have_attached_inferiors_p ())
    {
      fprintf (stderr, "Detaching process(es):");
      for_each_inferior (&all_processes, print_attached_pid);
      fprintf (stderr, "\n");
    }

  /* Now we can kill or detach the inferiors.  */

  for_each_inferior (&all_processes, detach_or_kill_inferior_callback);
}

int
main (int argc, char *argv[])
{
  int bad_attach;
  int pid;
  char *arg_end, *port;
  char **next_arg = &argv[1];
  volatile int multi_mode = 0;
  volatile int attach = 0;
  int was_running;

  while (*next_arg != NULL && **next_arg == '-')
    {
      if (strcmp (*next_arg, "--version") == 0)
	{
	  gdbserver_version ();
	  exit (0);
	}
      else if (strcmp (*next_arg, "--help") == 0)
	{
	  gdbserver_usage (stdout);
	  exit (0);
	}
      else if (strcmp (*next_arg, "--attach") == 0)
	attach = 1;
      else if (strcmp (*next_arg, "--multi") == 0)
	multi_mode = 1;
      else if (strcmp (*next_arg, "--wrapper") == 0)
	{
	  next_arg++;

	  wrapper_argv = next_arg;
	  while (*next_arg != NULL && strcmp (*next_arg, "--") != 0)
	    next_arg++;

	  if (next_arg == wrapper_argv || *next_arg == NULL)
	    {
	      gdbserver_usage (stderr);
	      exit (1);
	    }

	  /* Consume the "--".  */
	  *next_arg = NULL;
	}
      else if (strcmp (*next_arg, "--debug") == 0)
	debug_threads = 1;
      else if (strcmp (*next_arg, "--remote-debug") == 0)
	remote_debug = 1;
      else if (strcmp (*next_arg, "--disable-packet") == 0)
	{
	  gdbserver_show_disableable (stdout);
	  exit (0);
	}
      else if (strncmp (*next_arg,
			"--disable-packet=",
			sizeof ("--disable-packet=") - 1) == 0)
	{
	  char *packets, *tok;

	  packets = *next_arg += sizeof ("--disable-packet=") - 1;
	  for (tok = strtok (packets, ",");
	       tok != NULL;
	       tok = strtok (NULL, ","))
	    {
	      if (strcmp ("vCont", tok) == 0)
		disable_packet_vCont = 1;
	      else if (strcmp ("Tthread", tok) == 0)
		disable_packet_Tthread = 1;
	      else if (strcmp ("qC", tok) == 0)
		disable_packet_qC = 1;
	      else if (strcmp ("qfThreadInfo", tok) == 0)
		disable_packet_qfThreadInfo = 1;
	      else if (strcmp ("threads", tok) == 0)
		{
		  disable_packet_vCont = 1;
		  disable_packet_Tthread = 1;
		  disable_packet_qC = 1;
		  disable_packet_qfThreadInfo = 1;
		}
	      else
		{
		  fprintf (stderr, "Don't know how to disable \"%s\".\n\n",
			   tok);
		  gdbserver_show_disableable (stderr);
		  exit (1);
		}
	    }
	}
      else if (strcmp (*next_arg, "-") == 0)
	{
	  /* "-" specifies a stdio connection and is a form of port
	     specification.  */
	  *next_arg = STDIO_CONNECTION_NAME;
	  break;
	}
      else if (strcmp (*next_arg, "--disable-randomization") == 0)
	disable_randomization = 1;
      else if (strcmp (*next_arg, "--no-disable-randomization") == 0)
	disable_randomization = 0;
      else if (strcmp (*next_arg, "--once") == 0)
	run_once = 1;
      else
	{
	  fprintf (stderr, "Unknown argument: %s\n", *next_arg);
	  exit (1);
	}

      next_arg++;
      continue;
    }

  if (setjmp (toplevel))
    {
      fprintf (stderr, "Exiting\n");
      exit (1);
    }

  port = *next_arg;
  next_arg++;
  if (port == NULL || (!attach && !multi_mode && *next_arg == NULL))
    {
      gdbserver_usage (stderr);
      exit (1);
    }

  /* Remember stdio descriptors.  LISTEN_DESC must not be listed, it will be
     opened by remote_prepare.  */
  notice_open_fds ();

  /* We need to know whether the remote connection is stdio before
     starting the inferior.  Inferiors created in this scenario have
     stdin,stdout redirected.  So do this here before we call
     start_inferior.  */
  remote_prepare (port);

  bad_attach = 0;
  pid = 0;

  /* --attach used to come after PORT, so allow it there for
       compatibility.  */
  if (*next_arg != NULL && strcmp (*next_arg, "--attach") == 0)
    {
      attach = 1;
      next_arg++;
    }

  if (attach
      && (*next_arg == NULL
	  || (*next_arg)[0] == '\0'
	  || (pid = strtoul (*next_arg, &arg_end, 0)) == 0
	  || *arg_end != '\0'
	  || next_arg[1] != NULL))
    bad_attach = 1;

  if (bad_attach)
    {
      gdbserver_usage (stderr);
      exit (1);
    }

  initialize_async_io ();
  initialize_low ();
  initialize_event_loop ();
  if (target_supports_tracepoints ())
    initialize_tracepoint ();

  own_buf = xmalloc (PBUFSIZ + 1);
  mem_buf = xmalloc (PBUFSIZ);

  if (pid == 0 && *next_arg != NULL)
    {
      int i, n;

      n = argc - (next_arg - argv);
      program_argv = xmalloc (sizeof (char *) * (n + 1));
      for (i = 0; i < n; i++)
	program_argv[i] = xstrdup (next_arg[i]);
      program_argv[i] = NULL;

      /* Wait till we are at first instruction in program.  */
      start_inferior (program_argv);

      /* We are now (hopefully) stopped at the first instruction of
	 the target process.  This assumes that the target process was
	 successfully created.  */
    }
  else if (pid != 0)
    {
      if (attach_inferior (pid) == -1)
	error ("Attaching not supported on this target");

      /* Otherwise succeeded.  */
    }
  else
    {
      last_status.kind = TARGET_WAITKIND_EXITED;
      last_status.value.integer = 0;
      last_ptid = minus_one_ptid;
    }

  initialize_notif ();

  /* Don't report shared library events on the initial connection,
     even if some libraries are preloaded.  Avoids the "stopped by
     shared library event" notice on gdb side.  */
  dlls_changed = 0;

  if (setjmp (toplevel))
    {
      /* If something fails and longjmps while detaching or killing
	 inferiors, we'd end up here again, stuck in an infinite loop
	 trap.  Be sure that if that happens, we exit immediately
	 instead.  */
      if (setjmp (toplevel) == 0)
	detach_or_kill_for_exit ();
      else
	fprintf (stderr, "Detach or kill failed.  Exiting\n");
      exit (1);
    }

  if (last_status.kind == TARGET_WAITKIND_EXITED
      || last_status.kind == TARGET_WAITKIND_SIGNALLED)
    was_running = 0;
  else
    was_running = 1;

  if (!was_running && !multi_mode)
    {
      fprintf (stderr, "No program to debug.  GDBserver exiting.\n");
      exit (1);
    }

  while (1)
    {
      noack_mode = 0;
      multi_process = 0;
      /* Be sure we're out of tfind mode.  */
      current_traceframe = -1;

      remote_open (port);

      if (setjmp (toplevel) != 0)
	{
	  /* An error occurred.  */
	  if (response_needed)
	    {
	      write_enn (own_buf);
	      putpkt (own_buf);
	    }
	}

      /* Wait for events.  This will return when all event sources are
	 removed from the event loop.  */
      start_event_loop ();

      /* If an exit was requested (using the "monitor exit" command),
	 terminate now.  The only other way to get here is for
	 getpkt to fail; close the connection and reopen it at the
	 top of the loop.  */

      if (exit_requested || run_once)
	{
	  /* If something fails and longjmps while detaching or
	     killing inferiors, we'd end up here again, stuck in an
	     infinite loop trap.  Be sure that if that happens, we
	     exit immediately instead.  */
	  if (setjmp (toplevel) == 0)
	    {
	      detach_or_kill_for_exit ();
	      exit (0);
	    }
	  else
	    {
	      fprintf (stderr, "Detach or kill failed.  Exiting\n");
	      exit (1);
	    }
	}

      fprintf (stderr,
	       "Remote side has terminated connection.  "
	       "GDBserver will reopen the connection.\n");

      if (tracing)
	{
	  if (disconnected_tracing)
	    {
	      /* Try to enable non-stop/async mode, so we we can both
		 wait for an async socket accept, and handle async
		 target events simultaneously.  There's also no point
		 either in having the target always stop all threads,
		 when we're going to pass signals down without
		 informing GDB.  */
	      if (!non_stop)
		{
		  if (start_non_stop (1))
		    non_stop = 1;

		  /* Detaching implicitly resumes all threads; simply
		     disconnecting does not.  */
		}
	    }
	  else
	    {
	      fprintf (stderr,
		       "Disconnected tracing disabled; stopping trace run.\n");
	      stop_tracing ();
	    }
	}
    }
}

/* Process options coming from Z packets for *point at address
   POINT_ADDR.  PACKET is the packet buffer.  *PACKET is updated
   to point to the first char after the last processed option.  */

static void
process_point_options (CORE_ADDR point_addr, char **packet)
{
  char *dataptr = *packet;
  int persist;

  /* Check if data has the correct format.  */
  if (*dataptr != ';')
    return;

  dataptr++;

  while (*dataptr)
    {
      if (*dataptr == ';')
	++dataptr;

      if (*dataptr == 'X')
	{
	  /* Conditional expression.  */
	  if (debug_threads)
	    fprintf (stderr, "Found breakpoint condition.\n");
	  add_breakpoint_condition (point_addr, &dataptr);
	}
      else if (strncmp (dataptr, "cmds:", strlen ("cmds:")) == 0)
	{
	  dataptr += strlen ("cmds:");
	  if (debug_threads)
	    fprintf (stderr, "Found breakpoint commands %s.\n", dataptr);
	  persist = (*dataptr == '1');
	  dataptr += 2;
	  add_breakpoint_commands (point_addr, &dataptr, persist);
	}
      else
	{
	  fprintf (stderr, "Unknown token %c, ignoring.\n",
		   *dataptr);
	  /* Skip tokens until we find one that we recognize.  */
	  while (*dataptr && *dataptr != ';')
	    dataptr++;
	}
    }
  *packet = dataptr;
}

/* Event loop callback that handles a serial event.  The first byte in
   the serial buffer gets us here.  We expect characters to arrive at
   a brisk pace, so we read the rest of the packet with a blocking
   getpkt call.  */

static int
process_serial_event (void)
{
  char ch;
  int i = 0;
  int signal;
  unsigned int len;
  int res;
  CORE_ADDR mem_addr;
  int pid;
  unsigned char sig;
  int packet_len;
  int new_packet_len = -1;

  /* Used to decide when gdbserver should exit in
     multi-mode/remote.  */
  static int have_ran = 0;

  if (!have_ran)
    have_ran = target_running ();

  disable_async_io ();

  response_needed = 0;
  packet_len = getpkt (own_buf);
  if (packet_len <= 0)
    {
      remote_close ();
      /* Force an event loop break.  */
      return -1;
    }
  response_needed = 1;

  i = 0;
  ch = own_buf[i++];
  switch (ch)
    {
    case 'q':
      handle_query (own_buf, packet_len, &new_packet_len);
      break;
    case 'Q':
      handle_general_set (own_buf);
      break;
    case 'D':
      require_running (own_buf);

      if (multi_process)
	{
	  i++; /* skip ';' */
	  pid = strtol (&own_buf[i], NULL, 16);
	}
      else
	pid = ptid_get_pid (current_ptid);

      if ((tracing && disconnected_tracing) || any_persistent_commands ())
	{
	  struct thread_resume resume_info;
	  struct process_info *process = find_process_pid (pid);

	  if (process == NULL)
	    {
	      write_enn (own_buf);
	      break;
	    }

	  if (tracing && disconnected_tracing)
	    fprintf (stderr,
		     "Disconnected tracing in effect, "
		     "leaving gdbserver attached to the process\n");

	  if (any_persistent_commands ())
	    fprintf (stderr,
		     "Persistent commands are present, "
		     "leaving gdbserver attached to the process\n");

	  /* Make sure we're in non-stop/async mode, so we we can both
	     wait for an async socket accept, and handle async target
	     events simultaneously.  There's also no point either in
	     having the target stop all threads, when we're going to
	     pass signals down without informing GDB.  */
	  if (!non_stop)
	    {
	      if (debug_threads)
		fprintf (stderr, "Forcing non-stop mode\n");

	      non_stop = 1;
	      start_non_stop (1);
	    }

	  process->gdb_detached = 1;

	  /* Detaching implicitly resumes all threads.  */
	  resume_info.thread = minus_one_ptid;
	  resume_info.kind = resume_continue;
	  resume_info.sig = 0;
	  (*the_target->resume) (&resume_info, 1);

	  write_ok (own_buf);
	  break; /* from switch/case */
	}

      fprintf (stderr, "Detaching from process %d\n", pid);
      stop_tracing ();
      if (detach_inferior (pid) != 0)
	write_enn (own_buf);
      else
	{
	  discard_queued_stop_replies (pid);
	  write_ok (own_buf);

	  if (extended_protocol)
	    {
	      /* Treat this like a normal program exit.  */
	      last_status.kind = TARGET_WAITKIND_EXITED;
	      last_status.value.integer = 0;
	      last_ptid = pid_to_ptid (pid);

	      current_inferior = NULL;
	    }
	  else
	    {
	      putpkt (own_buf);
	      remote_close ();

	      /* If we are attached, then we can exit.  Otherwise, we
		 need to hang around doing nothing, until the child is
		 gone.  */
	      join_inferior (pid);
	      exit (0);
	    }
	}
      break;
    case '!':
      extended_protocol = 1;
      write_ok (own_buf);
      break;
    case '?':
      handle_status (own_buf);
      break;
    case 'H':
      if (own_buf[1] == 'c' || own_buf[1] == 'g' || own_buf[1] == 's')
	{
	  ptid_t gdb_id, thread_id;
	  int pid;

	  require_running (own_buf);

	  gdb_id = read_ptid (&own_buf[2], NULL);

	  pid = ptid_get_pid (gdb_id);

	  if (ptid_equal (gdb_id, null_ptid)
	      || ptid_equal (gdb_id, minus_one_ptid))
	    thread_id = null_ptid;
	  else if (pid != 0
		   && ptid_equal (pid_to_ptid (pid),
				  gdb_id))
	    {
	      struct thread_info *thread =
		(struct thread_info *) find_inferior (&all_threads,
						      first_thread_of,
						      &pid);
	      if (!thread)
		{
		  write_enn (own_buf);
		  break;
		}

	      thread_id = ((struct inferior_list_entry *)thread)->id;
	    }
	  else
	    {
	      thread_id = gdb_id_to_thread_id (gdb_id);
	      if (ptid_equal (thread_id, null_ptid))
		{
		  write_enn (own_buf);
		  break;
		}
	    }

	  if (own_buf[1] == 'g')
	    {
	      if (ptid_equal (thread_id, null_ptid))
		{
		  /* GDB is telling us to choose any thread.  Check if
		     the currently selected thread is still valid. If
		     it is not, select the first available.  */
		  struct thread_info *thread =
		    (struct thread_info *) find_inferior_id (&all_threads,
							     general_thread);
		  if (thread == NULL)
		    thread_id = all_threads.head->id;
		}

	      general_thread = thread_id;
	      set_desired_inferior (1);
	    }
	  else if (own_buf[1] == 'c')
	    cont_thread = thread_id;

	  write_ok (own_buf);
	}
      else
	{
	  /* Silently ignore it so that gdb can extend the protocol
	     without compatibility headaches.  */
	  own_buf[0] = '\0';
	}
      break;
    case 'g':
      require_running (own_buf);
      if (current_traceframe >= 0)
	{
	  struct regcache *regcache
	    = new_register_cache (current_target_desc ());

	  if (fetch_traceframe_registers (current_traceframe,
					  regcache, -1) == 0)
	    registers_to_string (regcache, own_buf);
	  else
	    write_enn (own_buf);
	  free_register_cache (regcache);
	}
      else
	{
	  struct regcache *regcache;

	  set_desired_inferior (1);
	  regcache = get_thread_regcache (current_inferior, 1);
	  registers_to_string (regcache, own_buf);
	}
      break;
    case 'G':
      require_running (own_buf);
      if (current_traceframe >= 0)
	write_enn (own_buf);
      else
	{
	  struct regcache *regcache;

	  set_desired_inferior (1);
	  regcache = get_thread_regcache (current_inferior, 1);
	  registers_from_string (regcache, &own_buf[1]);
	  write_ok (own_buf);
	}
      break;
    case 'm':
      require_running (own_buf);
      decode_m_packet (&own_buf[1], &mem_addr, &len);
      res = gdb_read_memory (mem_addr, mem_buf, len);
      if (res < 0)
	write_enn (own_buf);
      else
	convert_int_to_ascii (mem_buf, own_buf, res);
      break;
    case 'M':
      require_running (own_buf);
      decode_M_packet (&own_buf[1], &mem_addr, &len, &mem_buf);
      if (gdb_write_memory (mem_addr, mem_buf, len) == 0)
	write_ok (own_buf);
      else
	write_enn (own_buf);
      break;
    case 'X':
      require_running (own_buf);
      if (decode_X_packet (&own_buf[1], packet_len - 1,
			   &mem_addr, &len, &mem_buf) < 0
	  || gdb_write_memory (mem_addr, mem_buf, len) != 0)
	write_enn (own_buf);
      else
	write_ok (own_buf);
      break;
    case 'C':
      require_running (own_buf);
      convert_ascii_to_int (own_buf + 1, &sig, 1);
      if (gdb_signal_to_host_p (sig))
	signal = gdb_signal_to_host (sig);
      else
	signal = 0;
      myresume (own_buf, 0, signal);
      break;
    case 'S':
      require_running (own_buf);
      convert_ascii_to_int (own_buf + 1, &sig, 1);
      if (gdb_signal_to_host_p (sig))
	signal = gdb_signal_to_host (sig);
      else
	signal = 0;
      myresume (own_buf, 1, signal);
      break;
    case 'c':
      require_running (own_buf);
      signal = 0;
      myresume (own_buf, 0, signal);
      break;
    case 's':
      require_running (own_buf);
      signal = 0;
      myresume (own_buf, 1, signal);
      break;
    case 'Z':  /* insert_ ... */
      /* Fallthrough.  */
    case 'z':  /* remove_ ... */
      {
	char *dataptr;
	ULONGEST addr;
	int len;
	char type = own_buf[1];
	int res;
	const int insert = ch == 'Z';
	char *p = &own_buf[3];

	p = unpack_varlen_hex (p, &addr);
	len = strtol (p + 1, &dataptr, 16);

	/* Default to unrecognized/unsupported.  */
	res = 1;
	switch (type)
	  {
	  case '0': /* software-breakpoint */
	  case '1': /* hardware-breakpoint */
	  case '2': /* write watchpoint */
	  case '3': /* read watchpoint */
	  case '4': /* access watchpoint */
	    require_running (own_buf);
	    if (insert && the_target->insert_point != NULL)
	      {
		/* Insert the breakpoint.  If it is already inserted, nothing
		   will take place.  */
		res = (*the_target->insert_point) (type, addr, len);

		/* GDB may have sent us a list of *point parameters to be
		   evaluated on the target's side.  Read such list here.  If we
		   already have a list of parameters, GDB is telling us to drop
		   that list and use this one instead.  */
		if (!res && (type == '0' || type == '1'))
		  {
		    /* Remove previous conditions.  */
		    clear_gdb_breakpoint_conditions (addr);
		    process_point_options (addr, &dataptr);
		  }
	      }
	    else if (!insert && the_target->remove_point != NULL)
	      res = (*the_target->remove_point) (type, addr, len);
	    break;
	  default:
	    break;
	  }

	if (res == 0)
	  write_ok (own_buf);
	else if (res == 1)
	  /* Unsupported.  */
	  own_buf[0] = '\0';
	else
	  write_enn (own_buf);
	break;
      }
    case 'k':
      response_needed = 0;
      if (!target_running ())
	/* The packet we received doesn't make sense - but we can't
	   reply to it, either.  */
	return 0;

      fprintf (stderr, "Killing all inferiors\n");
      for_each_inferior (&all_processes, kill_inferior_callback);

      /* When using the extended protocol, we wait with no program
	 running.  The traditional protocol will exit instead.  */
      if (extended_protocol)
	{
	  last_status.kind = TARGET_WAITKIND_EXITED;
	  last_status.value.sig = GDB_SIGNAL_KILL;
	  return 0;
	}
      else
	exit (0);

    case 'T':
      {
	ptid_t gdb_id, thread_id;

	require_running (own_buf);

	gdb_id = read_ptid (&own_buf[1], NULL);
	thread_id = gdb_id_to_thread_id (gdb_id);
	if (ptid_equal (thread_id, null_ptid))
	  {
	    write_enn (own_buf);
	    break;
	  }

	if (mythread_alive (thread_id))
	  write_ok (own_buf);
	else
	  write_enn (own_buf);
      }
      break;
    case 'R':
      response_needed = 0;

      /* Restarting the inferior is only supported in the extended
	 protocol.  */
      if (extended_protocol)
	{
	  if (target_running ())
	    for_each_inferior (&all_processes,
			       kill_inferior_callback);
	  fprintf (stderr, "GDBserver restarting\n");

	  /* Wait till we are at 1st instruction in prog.  */
	  if (program_argv != NULL)
	    start_inferior (program_argv);
	  else
	    {
	      last_status.kind = TARGET_WAITKIND_EXITED;
	      last_status.value.sig = GDB_SIGNAL_KILL;
	    }
	  return 0;
	}
      else
	{
	  /* It is a request we don't understand.  Respond with an
	     empty packet so that gdb knows that we don't support this
	     request.  */
	  own_buf[0] = '\0';
	  break;
	}
    case 'v':
      /* Extended (long) request.  */
      handle_v_requests (own_buf, packet_len, &new_packet_len);
      break;

    default:
      /* It is a request we don't understand.  Respond with an empty
	 packet so that gdb knows that we don't support this
	 request.  */
      own_buf[0] = '\0';
      break;
    }

  if (new_packet_len != -1)
    putpkt_binary (own_buf, new_packet_len);
  else
    putpkt (own_buf);

  response_needed = 0;

  if (!extended_protocol && have_ran && !target_running ())
    {
      /* In non-stop, defer exiting until GDB had a chance to query
	 the whole vStopped list (until it gets an OK).  */
      if (QUEUE_is_empty (notif_event_p, notif_stop.queue))
	{
	  /* Be transparent when GDB is connected through stdio -- no
	     need to spam GDB's console.  */
	  if (!remote_connection_is_stdio ())
	    fprintf (stderr, "GDBserver exiting\n");
	  remote_close ();
	  exit (0);
	}
    }

  if (exit_requested)
    return -1;

  return 0;
}

/* Event-loop callback for serial events.  */

int
handle_serial_event (int err, gdb_client_data client_data)
{
  if (debug_threads)
    fprintf (stderr, "handling possible serial event\n");

  /* Really handle it.  */
  if (process_serial_event () < 0)
    return -1;

  /* Be sure to not change the selected inferior behind GDB's back.
     Important in the non-stop mode asynchronous protocol.  */
  set_desired_inferior (1);

  return 0;
}

/* Event-loop callback for target events.  */

int
handle_target_event (int err, gdb_client_data client_data)
{
  if (debug_threads)
    fprintf (stderr, "handling possible target event\n");

  last_ptid = mywait (minus_one_ptid, &last_status,
		      TARGET_WNOHANG, 1);

  if (last_status.kind != TARGET_WAITKIND_IGNORE)
    {
      int pid = ptid_get_pid (last_ptid);
      struct process_info *process = find_process_pid (pid);
      int forward_event = !gdb_connected () || process->gdb_detached;

      if (last_status.kind == TARGET_WAITKIND_EXITED
	  || last_status.kind == TARGET_WAITKIND_SIGNALLED)
	{
	  mark_breakpoints_out (process);
	  mourn_inferior (process);
	}
      else
	{
	  /* We're reporting this thread as stopped.  Update its
	     "want-stopped" state to what the client wants, until it
	     gets a new resume action.  */
	  current_inferior->last_resume_kind = resume_stop;
	  current_inferior->last_status = last_status;
	}

      if (forward_event)
	{
	  if (!target_running ())
	    {
	      /* The last process exited.  We're done.  */
	      exit (0);
	    }

	  if (last_status.kind == TARGET_WAITKIND_STOPPED)
	    {
	      /* A thread stopped with a signal, but gdb isn't
		 connected to handle it.  Pass it down to the
		 inferior, as if it wasn't being traced.  */
	      struct thread_resume resume_info;

	      if (debug_threads)
		fprintf (stderr,
			 "GDB not connected; forwarding event %d for [%s]\n",
			 (int) last_status.kind,
			 target_pid_to_str (last_ptid));

	      resume_info.thread = last_ptid;
	      resume_info.kind = resume_continue;
	      resume_info.sig = gdb_signal_to_host (last_status.value.sig);
	      (*the_target->resume) (&resume_info, 1);
	    }
	  else if (debug_threads)
	    fprintf (stderr, "GDB not connected; ignoring event %d for [%s]\n",
		     (int) last_status.kind,
		     target_pid_to_str (last_ptid));
	}
      else
	{
	  struct vstop_notif *vstop_notif
	    = xmalloc (sizeof (struct vstop_notif));

	  vstop_notif->status = last_status;
	  vstop_notif->ptid = last_ptid;
	  /* Push Stop notification.  */
	  notif_push (&notif_stop,
		      (struct notif_event *) vstop_notif);
	}
    }

  /* Be sure to not change the selected inferior behind GDB's back.
     Important in the non-stop mode asynchronous protocol.  */
  set_desired_inferior (1);

  return 0;
}
@


1.201
log
@gdb/gdbserver/

2013-09-18  Yao Qi  <yao@@codesourcery.com>

	PR server/15959
	* server.c (start_inferior): Clear 'resume_info'.

gdb/testsuite/

2013-09-18  Yao Qi  <yao@@codesourcery.com>

	* gdb.server/wrapper.c: New.
	* gdb.server/wrapper.exp: New.
@
text
@d3553 4
a3556 1
	  fprintf (stderr, "GDBserver exiting\n");
@


1.200
log
@[gdbserver] Split a new hostio.h file out of server.h.

gdb/gdbserver/
2013-09-05  Pedro Alves  <palves@@redhat.com>

	* server.h (handle_vFile, hostio_last_error_from_errno): Move
	to ...
	* hostio.h: ... this new file.
	* hostio.c, server.c, linux-low.c, nto-low.c, spu-low,
	win32-low.c: Include hostio.h.
@
text
@d259 1
@


1.199
log
@[gdbserver] Split a new dll.h file out of server.h.

gdb/gdbserver/
2013-09-05  Pedro Alves  <palves@@redhat.com>

	* dll.c, inferiors.c, remote-utils.c, server.c: Include "dll.h".
	* server.h (struct dll_info, all_dlls, dlls_changed, clear_dlls)
	(loaded_dll, unloaded_dll): Move to ...
	* dll.h: ... this new file.
	* inferiors.c, remote-utils.c, win32-low.c: Include "dll.h".
@
text
@d34 1
@


1.198
log
@[gdbserver] Split a new tracepoint.h file out of server.h.

gdb/gdbserver/
2013-09-05  Pedro Alves  <palves@@redhat.com>

	* ax.c, linux-low.c, linux-x86-low.c, server.c: Include
	tracepoint.h.
	* server.h (IPA_BUFSIZ, initialize_tracepoint, tracing)
	(disconnected_tracing, tracepoint_look_up_symbols, stop_tracing
	(handle_tracepoint_general_set, handle_tracepoint_query)
	(tracepoint_finished_step, tracepoint_was_hit)
	(release_while_stepping_state_list, current_traceframe)
	(in_readonly_region, traceframe_read_mem)
	(fetch_traceframe_registers, traceframe_read_sdata)
	(traceframe_read_info, struct fast_tpoint_collect_status)
	(fast_tracepoint_collecting, force_unlock_trace_buffer)
	(handle_tracepoit_bkpts, initialize_low_tracepoint)
	(supply_fast_tracepoint_registers)
	(supply_static_tracepoint_registers, set_trampoline_buffer_space)
	(ipa_tdesc, claim_trampoline_space)
	(have_fast_tracepoint_trampoline_buffer, gdb_agent_about_to_close)
	(agent_mem_read, agent_get_trace_state_variable_value)
	(agent_set_trace_state_variable_value, agent_tsv_read)
	(agent_mem_read_string, get_raw_reg_func_addr)
	(get_get_tsv_func_addr, get_set_tsv_func_addr): Move to ...
	* tracepoint.h: ... this new file.
@
text
@d33 1
@


1.197
log
@server.c:gdb_read_memory: Fix error return.

When I added gdb_read_memory, with bits factored out from elsewhere, I
missed adjusting this error return.  gdb_read_memory has an interface
similar to Like GDB's xfer_partial:

> /* Read trace frame or inferior memory.  Returns the number of bytes
>   actually read, zero when no further transfer is possible, and -1 on
>   error.  Return of a positive value smaller than LEN does not
>   indicate there's no more to be read, only the end of the transfer.

Returning EIO, a positive value, is obviously bogus, for the caller
will confuse it with a successful partial transfer.

Found by inspection.

Tested on x86_64 Fedora 17.

gdb/gdbserver/
2013-09-02  Pedro Alves  <palves@@redhat.com>

	* server.c (gdb_read_memory): Return -1 on traceframe memory read
	error instead of EIO.
@
text
@d32 1
@


1.196
log
@PR server/15604

gdb/gdbserver/
2013-08-28  Jan Kratochvil  <jan.kratochvil@@redhat.com>

	PR server/15604
	* linux-low.c: Include filestuff.h.
	(linux_create_inferior) <pid == 0>: Call close_most_fds.
	* lynx-low.c: Include filestuff.h.
	(lynx_create_inferior) <pid == 0>: Call close_most_fds.
	* server.c: Include filestuff.h.
	(main): Call notice_open_fds.
	* spu-low.c: Include filestuff.h.
	(spu_create_inferior) <pid == 0>: Call close_most_fds.
@
text
@d719 1
a719 1
	return EIO;
@


1.195
log
@	gdb/
	* Makefile.in (SFILES): Add common/target-common.c.
	Add common/target-common.h to headers.
	(COMMON_OBS): Add target-common.o.
	(target-common.o): New target.
	* linux-nat.h (resume_kind): Move to common/target-common.h.
	* target.c (target_waitstatus_to_string): Move to
	common/target-common.c.
	* target.h: Include target-common.h.
	(target_waitkind): Move to common/target-common.h.
	(target_waitstatus): Likewise.
	(TARGET_WNOHANG): Likewise.
	* common/target-common.c: New file.
	* common/target-common.h: New file.

	gdb/gdbserver/
	* Makefile.in (SFILES): /common/target-common.c.
	(OBS): Add target-common.o.
	(server_h): Add $(srcdir)/../common/target-common.h.
	(target-common.o): New target.
	* server.c (queue_stop_reply_callback): Free
	status string after use.
	* target.c (target_waitstatus_to_string): Remove.
	* target.h: Include target-common.h.
	(resume_kind): Likewise.
	(target_waitkind): Likewise.
	(target_waitstatus): Likewise.
	(TARGET_WNOHANG): Likewise.
@
text
@d31 1
d2854 4
@


1.194
log
@Rely on gnulib's unistd.h replacement.

With gnulib's unistd module, we can assume unistd.h is always present, and that
STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO are always defined.

Don't remove unistd.h from GDB's configure.ac, as later tests in the
file use HAVE_UNISTD_H checks.

gdb/
2013-07-01  Pedro Alves  <palves@@redhat.com>

	* defs.h: Don't check HAVE_UNISTD_H before including <unistd.h>.
	(STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO): Delete.
	* tracepoint.c: Don't check HAVE_UNISTD_H before including
	<unistd.h>.

gdb/gdbserver/
2013-07-01  Pedro Alves  <palves@@redhat.com>

	* event-loop.c: Don't check HAVE_UNISTD_H before including
	<unistd.h>.
	* gdbreplay.c: Likewise.
	* remote-utils.c: Likewise.
	* server.c: Likewise.
	* configure.ac: Don't check for unistd.h.
	* configure: Regenerate.
@
text
@d2473 11
a2483 4
	    fprintf (stderr,
		     "Reporting thread %s as already stopped with %s\n",
		     target_pid_to_str (entry->id),
		     target_waitstatus_to_string (&thread->last_status));
@


1.193
log
@[GDBserver] Multi-process + multi-arch

This patch makes GDBserver support multi-process + biarch.

Currently, if you're debugging more than one process at once with a
single gdbserver (in extended-remote mode), then all processes must
have the same architecture (e.g., 64-bit vs 32-bit).  Otherwise, you
see this:

Added inferior 2
[Switching to inferior 2 [<null>] (<noexec>)]
Reading symbols from /home/pedro/gdb/tests/main32...done.
Temporary breakpoint 2 at 0x4004cf: main. (2 locations)
Starting program: /home/pedro/gdb/tests/main32
warning: Selected architecture i386 is not compatible with reported target architecture i386:x86-64
warning: Architecture rejected target-supplied description
Remote 'g' packet reply is too long: 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000090cfffff0000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000b042f7460000000000020000230000002b0000002b0000002b000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007f03000000000000ffff0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000801f00003b0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
... etc, etc ...

Even though the process was running a 32-bit program, GDBserver sent
back to GDB a register set in 64-bit layout.

A patch (http://sourceware.org/ml/gdb-patches/2012-11/msg00228.html) a
while ago made GDB track a target_gdbarch per inferior, and as
consequence, fetch a target description per-inferior.  This patch is
the GDBserver counterpart, that makes GDBserver keep track of each
process'es XML target description and register layout.  So in the
example above, GDBserver will send the correct register set in 32-bit
layout to GDB.

A new "struct target_desc" object (tdesc for short) is added, that
holds the target description and register layout information about
each process.  Each `struct process_info' holds a pointer to a target
description.  The regcache also gains a pointer to a target
description, mainly for convenience, and parallel with GDB (and
possible future support for programs that flip processor modes).

The low target's arch_setup routines are responsible for setting the
process'es correct tdesc.  This isn't that much different to how
things were done before, except that instead of detecting the inferior
process'es architecture and calling the corresponding
init_registers_FOO routine, which would change the regcache layout
globals and recreate the threads' regcaches, the regcache.c globals
are gone, and the init_registers_$BAR routines now each initialize a
separate global struct target_desc object (one for each arch variant
GDBserver supports), and so all the init_registers_$BAR routines that
are built into GDBserver are called early at GDBserver startup time
(similarly to how GDB handles its built-in target descriptions), and
then the arch_setup routine is responsible for making
process_info->tdesc point to one of these target description globals.
The regcache module is all parameterized to get the regcache's layout
from the tdesc object instead of the old register_bytes, etc. globals.

The threads' regcaches are now created lazily.  The old scheme where
we created each of them when we added a new thread doesn't work
anymore, because we add the main thread/lwp before we see it stop for
the first time, and it is only when we see the thread stop for the
first time that we have a chance of determining the inferior's
architecture (through the_low_target.arch_setup).  Therefore when we
add the main thread we don't know which architecture/tdesc its
regcache should have.

This patch makes the gdb.multi/multi-arch.exp test now pass against
(extended-remote) GDBserver.  It currently fails, without this patch.

The IPA also uses the regcache, so it gains a new global struct
target_desc pointer, which points at the description of the process it
is loaded in.

Re. the linux-low.c & friends changes.  Since the register map
etc. may differ between processes (64-bit vs 32-bit) etc., the
linux_target_ops num_regs, regmap and regset_bitmap data fields are no
longer sufficient.  A new method is added in their place that returns
a pointer to a new struct that includes all info linux-low.c needs to
access registers of the current inferior.

The patch/discussion that originally introduced
linux-low.c:disabled_regsets mentions that the disabled_regsets set
may be different per mode (in a biarch setup), and indeed that is
cleared whenever we start a new (first) inferior, so that global is
moved as well behind the new `struct regs_info'.

On the x86 side:

I simply replaced the i387-fp.c:num_xmm_registers global with a check
for 64-bit or 32-bit process, which is equivalent to how the global
was set.  This avoided coming up with some more general mechanism that
would work for all targets that use this module (GNU/Linux, Windows,
etc.).

Tested:

  GNU/Linux IA64
  GNU/Linux MIPS64
  GNU/Linux PowerPC (Fedora 16)
  GNU/Linux s390x (Fedora 16)
  GNU/Linux sparc64 (Debian)
  GNU/Linux x86_64, -m64 and -m32 (Fedora 17)

Cross built, and smoke tested:

  i686-w64-mingw32, under Wine.
  GNU/Linux TI C6x, by Yao Qi.

Cross built but otherwise not tested:

  aarch64-linux-gnu
  arm-linux-gnu
  m68k-linux
  nios2-linux-gnu
  sh-linux-gnu
  spu
  tilegx-unknown-linux-gnu

Completely untested:

  GNU/Linux Blackfin
  GNU/Linux CRIS
  GNU/Linux CRISv32
  GNU/Linux TI Xtensa
  GNU/Linux M32R
  LynxOS
  QNX NTO

gdb/gdbserver/
2013-06-07  Pedro Alves  <palves@@redhat.com>

	* Makefile.in (OBS): Add tdesc.o.
	(IPA_OBJS): Add tdesc-ipa.o.
	(tdesc-ipa.o): New rule.
	* ax.c (gdb_eval_agent_expr): Adjust register_size call to new
	interface.
	* linux-low.c (new_inferior): Delete.
	(disabled_regsets, num_regsets): Delete.
	(linux_add_process): Adjust to set the new per-process
	new_inferior flag.
	(linux_detach_one_lwp): Adjust to call regcache_invalidate_thread.
	(linux_wait_for_lwp): Adjust.  Only call arch_setup if the event
	was a stop.  When calling arch_setup, switch the current inferior
	to the thread that got an event.
	(linux_resume_one_lwp): Adjust to call regcache_invalidate_thread.
	(regsets_fetch_inferior_registers)
	(regsets_store_inferior_registers): New regsets_info parameter.
	Adjust to use it.
	(linux_register_in_regsets): New regs_info parameter.  Adjust to
	use it.
	(register_addr, fetch_register, store_register): New usrregs_info
	parameter.  Adjust to use it.
	(usr_fetch_inferior_registers, usr_store_inferior_registers): New
	parameter regs_info.  Adjust to use it.
	(linux_fetch_registers): Get the current inferior's regs_info, and
	adjust to use it.
	(linux_store_registers): Ditto.
	[HAVE_LINUX_REGSETS] (initialize_regsets_info): New.
	(initialize_low): Don't initialize the target_regsets here.  Call
	initialize_low_arch.
	* linux-low.h (target_regsets): Delete declaration.
	(struct regsets_info): New.
	(struct usrregs_info): New.
	(struct regs_info): New.
	(struct process_info_private) <new_inferior>: New field.
	(struct linux_target_ops): Delete the num_regs, regmap, and
	regset_bitmap fields.  New field regs_info.
	[HAVE_LINUX_REGSETS] (initialize_regsets_info): Declare.
	* i387-fp.c (num_xmm_registers): Delete.
	(i387_cache_to_fsave, i387_fsave_to_cache): Adjust find_regno
	calls to new interface.
	(i387_cache_to_fxsave, i387_cache_to_xsave, i387_fxsave_to_cache)
	(i387_xsave_to_cache): Adjust find_regno calls to new interface.
	Infer the number of xmm registers from the regcache's target
	description.
	* i387-fp.h (num_xmm_registers): Delete.
	* inferiors.c (add_thread): Don't install the thread's regcache
	here.
	* proc-service.c (gregset_info): Fetch the current inferior's
	regs_info.  Adjust to use it.
	* regcache.c: Include tdesc.h.
	(register_bytes, reg_defs, num_registers)
	(gdbserver_expedite_regs): Delete.
	(get_thread_regcache): If the thread doesn't have a regcache yet,
	create one, instead of aborting gdbserver.
	(regcache_invalidate_one): Rename to ...
	(regcache_invalidate_thread): ... this.
	(regcache_invalidate_one): New.
	(regcache_invalidate): Only invalidate registers of the current
	process.
	(init_register_cache): Add target_desc parameter, and use it.
	(new_register_cache): Ditto.  Assert the target description has a
	non zero registers_size.
	(regcache_cpy): Add assertions.  Adjust.
	(realloc_register_cache, set_register_cache): Delete.
	(registers_to_string, registers_from_string): Adjust.
	(find_register_by_name, find_regno, find_register_by_number)
	(register_cache_size): Add target_desc parameter, and use it.
	(free_register_cache_thread, free_register_cache_thread_one)
	(regcache_release, register_cache_size): New.
	(register_size): Add target_desc parameter, and use it.
	(register_data, supply_register, supply_register_zeroed)
	(supply_regblock, supply_register_by_name, collect_register)
	(collect_register_as_string, collect_register_by_name): Adjust.
	* regcache.h (struct target_desc): Forward declare.
	(struct regcache) <tdesc>: New field.
	(init_register_cache, new_register_cache): Add target_desc
	parameter.
	(regcache_invalidate_thread): Declare.
	(regcache_invalidate_one): Delete declaration.
	(regcache_release): Declare.
	(find_register_by_number, register_cache_size, register_size)
	(find_regno): Add target_desc parameter.
	(gdbserver_expedite_regs, gdbserver_xmltarget): Delete
	declarations.
	* remote-utils.c: Include tdesc.h.
	(outreg, prepare_resume_reply): Adjust.
	* server.c: Include tdesc.h.
	(gdbserver_xmltarget): Delete declaration.
	(get_features_xml, process_serial_event): Adjust.
	* server.h [IN_PROCESS_AGENT] (struct target_desc): Forward
	declare.
	(struct process_info) <tdesc>: New field.
	(ipa_tdesc): Declare.
	* tdesc.c: New file.
	* tdesc.h: New file.
	* tracepoint.c: Include tdesc.h.
	[IN_PROCESS_AGENT] (ipa_tdesc): Define.
	(get_context_regcache): Adjust to pass ipa_tdesc down.
	(do_action_at_tracepoint): Adjust to get the register cache size
	from the context regcache's description.
	(traceframe_walk_blocks): Adjust to get the register cache size
	from the current trace frame's description.
	(traceframe_get_pc): Adjust to get current trace frame's
	description and pass it down.
	(gdb_collect): Adjust to get the register cache size from the
	IPA's description.
	* linux-amd64-ipa.c (tdesc_amd64_linux): Declare.
	(gdbserver_xmltarget): Delete.
	(initialize_low_tracepoint): Set the ipa's target description.
	* linux-i386-ipa.c (tdesc_i386_linux): Declare.
	(initialize_low_tracepoint): Set the ipa's target description.
	* linux-x86-low.c: Include tdesc.h.
	[__x86_64__] (is_64bit_tdesc): New.
	(ps_get_thread_area, x86_get_thread_area): Use it.
	(i386_cannot_store_register): Rename to ...
	(x86_cannot_store_register): ... this.  Use is_64bit_tdesc.
	(i386_cannot_fetch_register): Rename to ...
	(x86_cannot_fetch_register): ... this.  Use is_64bit_tdesc.
	(x86_fill_gregset, x86_store_gregset): Adjust register_size calls
	to new interface.
	(target_regsets): Rename to ...
	(x86_regsets): ... this.
	(x86_get_pc, x86_set_pc): Adjust register_size calls to new
	interface.
	(x86_siginfo_fixup): Use is_64bit_tdesc.
	[__x86_64__] (tdesc_amd64_linux, tdesc_amd64_avx_linux)
	(tdesc_x32_avx_linux, tdesc_x32_linux)
	(tdesc_i386_linux, tdesc_i386_mmx_linux, tdesc_i386_avx_linux):
	Declare.
	(x86_linux_update_xmltarget): Delete.
	(I386_LINUX_XSAVE_XCR0_OFFSET): Define.
	(have_ptrace_getfpxregs, have_ptrace_getregset): New.
	(AMD64_LINUX_USER64_CS): New.
	(x86_linux_read_description): New, based on
	x86_linux_update_xmltarget.
	(same_process_callback): New.
	(x86_arch_setup_process_callback): New.
	(x86_linux_update_xmltarget): New.
	(x86_regsets_info): New.
	(amd64_linux_regs_info): New.
	(i386_linux_usrregs_info): New.
	(i386_linux_regs_info): New.
	(x86_linux_regs_info): New.
	(x86_arch_setup): Reimplement.
	(x86_install_fast_tracepoint_jump_pad): Use is_64bit_tdesc.
	(x86_emit_ops): Ditto.
	(the_low_target): Adjust.  Install x86_linux_regs_info,
	x86_cannot_fetch_register, and x86_cannot_store_register.
	(initialize_low_arch): New.
	* linux-ia64-low.c (tdesc_ia64): Declare.
	(ia64_fetch_register): Adjust.
	(ia64_usrregs_info, regs_info): New globals.
	(ia64_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-sparc-low.c (tdesc_sparc64): Declare.
	(sparc_fill_gregset_to_stack, sparc_store_gregset_from_stack):
	Adjust.
	(sparc_arch_setup): New function.
	(sparc_regsets_info, sparc_usrregs_info, regs_info): New globals.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-ppc-low.c (tdesc_powerpc_32l, tdesc_powerpc_altivec32l)
	(tdesc_powerpc_cell32l, tdesc_powerpc_vsx32l)
	(tdesc_powerpc_isa205_32l, tdesc_powerpc_isa205_altivec32l)
	(tdesc_powerpc_isa205_vsx32l, tdesc_powerpc_e500l)
	(tdesc_powerpc_64l, tdesc_powerpc_altivec64l)
	(tdesc_powerpc_cell64l, tdesc_powerpc_vsx64l)
	(tdesc_powerpc_isa205_64l, tdesc_powerpc_isa205_altivec64l)
	(tdesc_powerpc_isa205_vsx64l): Declare.
	(ppc_cannot_store_register, ppc_collect_ptrace_register)
	(ppc_supply_ptrace_register, parse_spufs_run, ppc_get_pc)
	(ppc_set_pc, ppc_get_hwcap): Adjust.
	(ppc_usrregs_info): Forward declare.
	(!__powerpc64__) ppc_regmap_adjusted: New global.
	(ppc_arch_setup): Adjust to the current process'es target
	description.
	(ppc_fill_vsxregset, ppc_store_vsxregset, ppc_fill_vrregset)
	(ppc_store_vrregset, ppc_fill_evrregset, ppc_store_evrregse)
	(ppc_store_evrregset): Adjust.
	(target_regsets): Rename to ...
	(ppc_regsets): ... this, and make static.
	(ppc_usrregs_info, ppc_regsets_info, regs_info): New globals.
	(ppc_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-s390-low.c (tdesc_s390_linux32, tdesc_s390_linux32v1)
	(tdesc_s390_linux32v2, tdesc_s390_linux64, tdesc_s390_linux64v1)
	(tdesc_s390_linux64v2, tdesc_s390x_linux64, tdesc_s390x_linux64v1)
	(tdesc_s390x_linux64v2): Declare.
	(s390_collect_ptrace_register, s390_supply_ptrace_register)
	(s390_fill_gregset, s390_store_last_break): Adjust.
	(target_regsets): Rename to ...
	(s390_regsets): ... this, and make static.
	(s390_get_pc, s390_set_pc): Adjust.
	(s390_get_hwcap): New target_desc parameter, and use it.
	[__s390x__] (have_hwcap_s390_high_gprs): New global.
	(s390_arch_setup): Adjust to set the current process'es target
	description.  Don't adjust the regmap.
	(s390_usrregs_info, s390_regsets_info, regs_info): New globals.
	[__s390x__] (s390_usrregs_info_3264, s390_regsets_info_3264)
	(regs_info_3264): New globals.
	(s390_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-mips-low.c (tdesc_mips_linux, tdesc_mips_dsp_linux)
	(tdesc_mips64_linux, tdesc_mips64_dsp_linux): Declare.
	[__mips64] (init_registers_mips_linux)
	(init_registers_mips_dsp_linux): Delete defines.
	[__mips64] (tdesc_mips_linux, tdesc_mips_dsp_linux): New defines.
	(have_dsp): New global.
	(mips_read_description): New, based on mips_arch_setup.
	(mips_arch_setup): Reimplement.
	(get_usrregs_info): New function.
	(mips_cannot_fetch_register, mips_cannot_store_register)
	(mips_get_pc, mips_set_pc, mips_fill_gregset, mips_store_gregset)
	(mips_fill_fpregset, mips_store_fpregset): Adjust.
	(target_regsets): Rename to ...
	(mips_regsets): ... this, and make static.
	(mips_regsets_info, mips_dsp_usrregs_info, mips_usrregs_info)
	(dsp_regs_info, regs_info): New globals.
	(mips_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-arm-low.c (tdesc_arm, tdesc_arm_with_iwmmxt)
	(tdesc_arm_with_vfpv2, tdesc_arm_with_vfpv3, tdesc_arm_with_neon):
	Declare.
	(arm_fill_vfpregset, arm_store_vfpregset): Adjust.
	(arm_read_description): New, with bits factored from
	arm_arch_setup.
	(arm_arch_setup): Reimplement.
	(target_regsets): Rename to ...
	(arm_regsets): ... this, and make static.
	(arm_regsets_info, arm_usrregs_info, regs_info): New globals.
	(arm_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-m68k-low.c (tdesc_m68k): Declare.
	(target_regsets): Rename to ...
	(m68k_regsets): ... this, and make static.
	(m68k_regsets_info, m68k_usrregs_info, regs_info): New globals.
	(m68k_regs_info): New function.
	(m68k_arch_setup): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-sh-low.c (tdesc_sharch): Declare.
	(target_regsets): Rename to ...
	(sh_regsets): ... this, and make static.
	(sh_regsets_info, sh_usrregs_info, regs_info): New globals.
	(sh_regs_info, sh_arch_setup): New functions.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-bfin-low.c (tdesc_bfin): Declare.
	(bfin_arch_setup): New function.
	(bfin_usrregs_info, regs_info): New globals.
	(bfin_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-cris-low.c (tdesc_cris): Declare.
	(cris_arch_setup): New function.
	(cris_usrregs_info, regs_info): New globals.
	(cris_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-cris-low.c (tdesc_crisv32): Declare.
	(cris_arch_setup): New function.
	(cris_regsets_info, cris_usrregs_info, regs_info): New globals.
	(cris_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-m32r-low.c (tdesc_m32r): Declare.
	(m32r_arch_setup): New function.
	(m32r_usrregs_info, regs_info): New globals.
	(m32r_regs_info): Adjust.
	(initialize_low_arch): New function.
	* linux-tic6x-low.c (tdesc_tic6x_c64xp_linux)
	(tdesc_tic6x_c64x_linux, tdesc_tic6x_c62x_linux): Declare.
	(tic6x_usrregs_info): Forward declare.
	(tic6x_read_description): New function, based on ...
	(tic6x_arch_setup): ... this.  Reimplement.
	(target_regsets): Rename to ...
	(tic6x_regsets): ... this, and make static.
	(tic6x_regsets_info, tic6x_usrregs_info, regs_info): New globals.
	(tic6x_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-xtensa-low.c (tdesc_xtensa): Declare.
	(xtensa_fill_gregset, xtensa_store_gregset): Adjust.
	(target_regsets): Rename to ...
	(xtensa_regsets): ... this, and make static.
	(xtensa_regsets_info, xtensa_usrregs_info, regs_info): New
	globals.
	(xtensa_arch_setup, xtensa_regs_info): New functions.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-nios2-low.c (tdesc_nios2_linux): Declare.
	(nios2_arch_setup): Set the current process'es tdesc.
	(target_regsets): Rename to ...
	(nios2_regsets): ... this.
	(nios2_regsets_info, nios2_usrregs_info, regs_info): New globals.
	(nios2_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
        * linux-aarch64-low.c (tdesc_aarch64): Declare.
        (aarch64_arch_setup): Set the current process'es tdesc.
        (target_regsets): Rename to ...
        (aarch64_regsets): ... this.
        (aarch64_regsets_info, aarch64_usrregs_info, regs_info): New globals.
        (aarch64_regs_info): New function.
        (the_low_target): Adjust.
        (initialize_low_arch): New function.
	* linux-tile-low.c (tdesc_tilegx, tdesc_tilegx32): Declare
	globals.
	(target_regsets): Rename to ...
	(tile_regsets): ... this.
	(tile_regsets_info, tile_usrregs_info, regs_info): New globals.
	(tile_regs_info): New function.
	(tile_arch_setup): Set the current process'es tdesc.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* spu-low.c (tdesc_spu): Declare.
	(spu_create_inferior, spu_attach): Set the new process'es tdesc.
	* win32-arm-low.c (tdesc_arm): Declare.
	(arm_arch_setup): New function.
	(the_low_target): Install arm_arch_setup instead of
	init_registers_arm.
	* win32-i386-low.c (tdesc_i386, tdesc_amd64): Declare.
	(init_windows_x86): Rename to ...
	(i386_arch_setup): ... this.  Set `win32_tdesc'.
	(the_low_target): Adjust.
	* win32-low.c (win32_tdesc): New global.
	(child_add_thread): Don't create the thread cache here.
	(do_initial_child_stuff): Set the new process'es tdesc.
	* win32-low.h (struct target_desc): Forward declare.
	(win32_tdesc): Declare.
	* lynx-i386-low.c (tdesc_i386): Declare global.
	(lynx_i386_arch_setup): Set `lynx_tdesc'.
	* lynx-low.c (lynx_tdesc): New global.
	(lynx_add_process): Set the new process'es tdesc.
	* lynx-low.h (struct target_desc): Forward declare.
	(lynx_tdesc): Declare global.
	* lynx-ppc-low.c (tdesc_powerpc_32): Declare global.
	(lynx_ppc_arch_setup): Set `lynx_tdesc'.
	* nto-low.c (nto_tdesc): New global.
	(do_attach): Set the new process'es tdesc.
	* nto-low.h (struct target_desc): Forward declare.
	(nto_tdesc): Declare.
	* nto-x86-low.c (tdesc_i386): Declare.
	(nto_x86_arch_setup): Set `nto_tdesc'.

gdb/
2013-06-07  Pedro Alves  <palves@@redhat.com>

	* regformats/regdat.sh: Output #include tdesc.h.  Make globals
	static.  Output a global target description pointer.
	(init_registers_${name}): Adjust to initialize a
	target description structure.
@
text
@a24 1
#if HAVE_UNISTD_H
a25 1
#endif
@


1.192
log
@2013-06-04  Gary Benson  <gbenson@@redhat.com>

	* server.c (handle_query): Add "augmented-libraries-svr4-read+"
	to qSupported response when appropriate.
	(handle_qxfer_libraries_svr4): Allow qXfer:libraries-svr4:read
	with nonzero-length annex.
	* linux-low.c (linux_qxfer_libraries_svr4): Parse and handle
	arguments supplied in annex.
@
text
@d23 1
a79 2
const char *gdbserver_xmltarget;

d648 6
a653 4
  /* gdbserver_xmltarget defines what to return when looking
     for the "target.xml" file.  Its contents can either be
     verbatim XML code (prefixed with a '@@') or else the name
     of the actual XML file to be used in place of "target.xml".
d658 1
a658 2
  if (gdbserver_xmltarget
      && strcmp (annex, "target.xml") == 0)
d660 2
a661 2
      if (*gdbserver_xmltarget == '@@')
	return gdbserver_xmltarget + 1;
d663 1
a663 1
	annex = gdbserver_xmltarget;
d3297 2
a3298 1
	  struct regcache *regcache = new_register_cache ();
@


1.191
log
@[gdbserver] Don't assume vCont;r ADDR1,ADDR2 comes with a ptid attached.

This bit:

+	  p1 = strchr (p, ':');
+	  decode_address (&resume_info[i].step_range_end, p, p1 - p);

should not expect the ':' to be there.  An action without a ptid is
valid:

 "If an action is specified with no thread-id, then it is applied to any
 threads that don't have a specific action specified"

This is handled further below:

      if (p[0] == 0)
	{
	  resume_info[i].thread = minus_one_ptid;
	  default_action = resume_info[i];

	  /* Note: we don't increment i here, we'll overwrite this entry
	     the next time through.  */
	}
      else if (p[0] == ':')

A stub that doesn't support and report to gdb thread ids at all (like
metal metal targets) only will always only see a single default action
with no ptid.

Use unpack_varlen_hex instead of decode_address.  The former doesn't
need to be told where the hex number ends, and it actually returns
that info instead, which we can use for validation.

Tested on x86_64 Fedora 17.

gdb/gdbserver/
2013-05-24  Pedro Alves  <palves@@redhat.com>

	* server.c (handle_v_cont) <vCont;r>: Use unpack_varlen_hex
	instead of strchr/decode_address.  Error if the range isn't split
	with a ','.  Don't assume there's be a ':' in the action.
@
text
@d1118 1
a1118 2
  if (annex[0] != '\0' || !target_running ()
      || the_target->qxfer_libraries_svr4 == NULL)
d1745 2
a1746 1
	strcat (own_buf, ";qXfer:libraries-svr4:read+");
@


1.190
log
@range stepping: gdbserver (x86 GNU/Linux)

This patch adds support for range stepping to GDBserver, teaching it
about vCont;r.

It'd be easy to enable this for all hardware single-step targets
without needing the linux_target_ops hook, however, at least PPC needs
special care, due to the fact that PPC atomic sequences can't be
hardware single-stepped through, a thing which GDBserver doesn't know
about.  So this leaves the support limited to x86/x86_64.

gdb/
2013-05-23  Pedro Alves  <palves@@redhat.com>

	* NEWS: Mention GDBserver range stepping support.

gdb/gdbserver/
2013-05-23  Yao Qi  <yao@@codesourcery.com>
	    Pedro Alves  <palves@@redhat.com>

	* linux-low.c (lwp_in_step_range): New function.
	(linux_wait_1): If the thread was range stepping and stopped
	outside the stepping range, report the stop to GDB.  Otherwise,
	continue stepping.  Add range stepping debug output.
	(linux_set_resume_request): Copy the step range from the resume
	request to the lwp.
	(linux_supports_range_stepping): New.
	(linux_target_ops) <supports_range_stepping>: Set to
	linux_supports_range_stepping.
	* linux-low.h (struct linux_target_ops)
	<supports_range_stepping>: New field.
	(struct lwp_info) <step_range_start, step_range_end>: New fields.
	* linux-x86-low.c (x86_supports_range_stepping): New.
	(the_low_target) <supports_range_stepping>: Set to
	x86_supports_range_stepping.
	* server.c (handle_v_cont): Handle 'r' action.
	(handle_v_requests): Append ";r" if the target supports range
	stepping.
	* target.h (struct thread_resume) <step_range_start,
	step_range_end>: New fields.
	(struct target_ops) <supports_range_stepping>:
	New field.
	(target_supports_range_stepping): New macro.
@
text
@d2072 1
a2072 1
	  char *p1;
d2074 2
a2075 3
	  p = p + 1;
	  p1 = strchr (p, ',');
	  decode_address (&resume_info[i].step_range_start, p, p1 - p);
d2077 2
a2078 3
	  p = p1 + 1;
	  p1 = strchr (p, ':');
	  decode_address (&resume_info[i].step_range_end, p, p1 - p);
d2080 2
a2081 1
	  p = p1;
@


1.189
log
@Add the gdb remote target operations for branch tracing.
We define the following packets:

  Qbtrace:bts         enable branch tracing for the current thread
                      returns "OK" or "Enn"

  Qbtrace:off         disable branch tracing for the current thread
                      returns "OK" or "Enn"

  qXfer:btrace:read   read the full branch trace data for the current thread

gdb/
	* target.h (enum target_object): Add TARGET_OBJECT_BTRACE.
	* remote.c: Include btrace.h.
	(struct btrace_target_info): New struct.
	(remote_supports_btrace): New function.
	(send_Qbtrace): New function.
	(remote_enable_btrace): New function.
	(remote_disable_btrace): New function.
	(remote_teardown_btrace): New function.
	(remote_read_btrace): New function.
	(init_remote_ops): Add btrace ops.
	(enum <unnamed>): Add btrace packets.
	(struct protocol_feature remote_protocol_features[]): Add btrace packets.
	(_initialize_remote): Add packet configuration for branch tracing.

gdbserver/
	* target.h (struct target_ops): Add btrace ops.
	(target_supports_btrace): New macro.
	(target_enable_btrace): New macro.
	(target_disable_btrace): New macro.
	(target_read_btrace): New macro.
	* gdbthread.h (struct thread_info): Add btrace field.
	* server.c: Include btrace-common.h.
	(handle_btrace_general_set): New function.
	(handle_btrace_enable): New function.
	(handle_btrace_disable): New function.
	(handle_general_set): Call handle_btrace_general_set.
	(handle_qxfer_btrace): New function.
	(struct qxfer qxfer_packets[]): Add btrace entry.
	* inferiors.c (remove_thread): Disable btrace.
	* linux-low: Include linux-btrace.h.
	(linux_low_enable_btrace): New function.
	(linux_low_read_btrace): New function.
	(linux_target_ops): Add btrace ops.
	* configure.srv (i[34567]86-*-linux*): Add linux-btrace.o.
	Add srv_linux_btrace=yes.
	(x86_64-*-linux*): Add linux-btrace.o.
	Add srv_linux_btrace=yes.
	* configure.ac: Define HAVE_LINUX_BTRACE.
	* config.in: Regenerated.
	* configure: Regenerated.
@
text
@d2045 2
d2049 2
d2070 14
a2085 1
	  resume_info[i].sig = 0;
d2331 5
@


1.188
log
@Preserve a verbose error message of xfer functions if they return -3.

gdbserver/
	* server.c (handle_qxfer): Preserve error message if -3 is
	returned.
	(qxfer): Document the -3 return value.
@
text
@d31 1
d400 82
d638 3
d1340 67
d1410 1
d1813 7
@


1.187
log
@2012-03-08  Stan Shebs  <stan@@codesourcery.com>
	    Hafiz Abid Qadeer  <abidh@@codesourcery.com>

	gdb/
	* NEWS: Mention set and show trace-buffer-size commands.
	Mention new packet.
	* target.h (struct target_ops): New method
	to_set_trace_buffer_size.
	(target_set_trace_buffer_size): New macro.
	* target.c (update_current_target): Set up new method.
	* tracepoint.c (trace_buffer_size): New global.
	(start_tracing): Send it to the target.
	(set_trace_buffer_size): New function.
	(_initialize_tracepoint): Add new setshow for trace-buffer-size.
	* remote.c (remote_set_trace_buffer_size): New function.
	(_initialize_remote): Use it.
	(QTBuffer:size) New remote command.
	(PACKET_QTBuffer_size): New enum.
	(remote_protocol_features): Add an entry for
	PACKET_QTBuffer_size.

	gdb/gdbserver/
	* tracepoint.c (trace_buffer_size): New global.
	(DEFAULT_TRACE_BUFFER_SIZE): New define.
	(init_trace_buffer): Change to one-argument function. Allocate
	trace buffer memory.
	(handle_tracepoint_general_set): Call cmd_bigqtbuffer_size to
	handle QTBuffer:size packet.
	(cmd_bigqtbuffer_size): New function.
	(initialize_tracepoint): Call init_trace_buffer with
	DEFAULT_TRACE_BUFFER_SIZE.
	* server.c (handle_query): Add QTBuffer:size in the
	supported packets.

	gdb/doc/
	* gdb.texinfo (Starting and Stopping Trace Experiments): Document
	trace-buffer-size set and show commands.
	(Tracepoint Packets): Document QTBuffer:size.
	(General Query Packets): Document QTBuffer:size.

	gdb/testsuite/
	* gdb.trace/trace-buffer-size.exp: New file.
	* gdb.trace/trace-buffer-size.c: New file.
@
text
@d895 4
a898 4
     further transfer is possible, -1 on error, and -2 when the
     transfer is not supported.  Return of a positive value smaller
     than LEN does not indicate the end of the object, only the end of
     the transfer.
d1326 4
d1368 4
@


1.186
log
@gdb/gdbserver/
	* server.c (process_point_options): Print debug message when
	debug_threads is true.
@
text
@d1640 1
@


1.185
log
@gdbserver:server.c - use unpack_varlen_hex to extract hex numbers.

Addresses, as most numbers in the RSP are hex encoded, with variable
length (that just means the width isn't specified, and there's no top
cap.  So they should be extracted with unpack_varlen_hex.

A couple spots in server.c are using strto(u)l, which doesn't work on
LLP64 targets.

This patch fixes it.

Tested on x86_64 Fedora 17.

2013-02-19  Pedro Alves  <palves@@redhat.com>
	    Kai Tietz <ktietz@@redhat.com>

	PR gdb/15161

	* server.c (handle_query) <CRC check>: Use unpack_varlen_hex
	instead of strtoul to extract address from packet.
	(process_serial_event) <'z'>: Likewise.
@
text
@d2863 2
a2864 1
	  fprintf (stderr, "Found breakpoint condition.\n");
@


1.184
log
@gdb/gdbserver
	* event-loop.c: Include "queue.h".
	(gdb_event_p): New typedef.
	(struct gdb_event) <next_event>: Remove.
	(event_queue): Change to QUEUE(gdb_event_p).
	(async_queue_event): Remove.
	(gdb_event_xfree): New.
	(initialize_event_loop): New.
	(process_event): Use API from QUEUE.
	(wait_for_event): Likewise.
	* server.c (main): Call initialize_event_loop.
	* server.h (initialize_event_loop): Declare.
@
text
@d1811 1
a1811 1
      CORE_ADDR base;
d1816 1
a1816 1
      base = strtoul (own_buf + 5, &comma, 16);
a3194 1
	char *lenptr;
d3196 2
a3197 2
	CORE_ADDR addr = strtoul (&own_buf[3], &lenptr, 16);
	int len = strtol (lenptr + 1, &dataptr, 16);
d3201 4
@


1.183
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d2690 1
@


1.182
log
@Update copyright year in gdb/gdbserver/gdbreplay version output.

gdb/ChangeLog:

        * top.c (print_gdb_version): Update copyright year.

gdb/gdbserver/ChangeLog:

        * gdbreplay.c (gdbreplay_version): Update copyright year.
        * server.c (gdbserver_version): Likewise.
@
text
@d2 1
a2 2
   Copyright (C) 1989, 1993-1995, 1997-2000, 2002-2012 Free Software
   Foundation, Inc.
@


1.181
log
@gdb/gdbserver/
2012-12-15  Yao Qi  <yao@@codesourcery.com>

	* Makefile.in (OBS): Add notif.o.
	* notif.c, notif.h: New.
	* server.c: Include "notif.h".
	(struct vstop_notif) <next>: Remove.
	<base>: New field.
	(queue_stop_reply): Update.
	(push_event, send_next_stop_reply): Remove.
	(discard_queued_stop_replies): Update.
	(notif_stop): New variable.
	(handle_v_stopped): Remove.
	(handle_v_requests): Don't call handle_v_stopped.  Call
	handle_ack_notif instead.
	(queue_stop_reply_callback): Call notif_event_enque instead
	of queue_stop_reply.
	(handle_status): Don't call send_next_stop_reply, call
	notif_write_event instead.
	(kill_inferior_callback): Likewise.
	(detach_or_kill_inferior_callback): Likewise.
	(main): Call initialize_notif.
	(process_serial_event): Call QUEUE_is_empty.
	(handle_target_event): Call notif_push instead of push event.
	* server.h (push_event): Remove declaration.
@
text
@d2385 1
a2385 1
	  "Copyright (C) 2012 Free Software Foundation, Inc.\n"
@


1.180
log
@2012-11-15  Pierre Muller  <muller@@sourceware.org>

	ARI fixes: move gdb_wait and gdb_stat headers to common subdirectory.
	* gdb_stat.h: Delete. Moved to common directory.
	* common/gdb_stat.h: New file.
	* gdb_wait.h: Delete. Moved to common directory.
	* common/gdb_wait.h: New file.
	* Makefile.in (H_FILES_NO_SRC): Adapt to new header
	location.
	* contrib/ari/gdb_ari.sh (wait.h rule): Adapt to new gdb_wait.h
	location.
	(stat.h rule): Adapt to new gdb_stat.h location.
	* common/linux-osdata.c: Include "gdb_stat.h" header instead of
	<sys/stat.h> header.
	* common/linux-ptrace.c: Include "gdb_wait.h" header instead of
	<sys/wait.h> header.


gdbserver ChangeLog entry:

2012-11-15  Pierre Muller  <muller@@sourceware.org>

	* configure.ac (AC_CHECK_HEADERS): Add wait.h header.
	* config.in: Regenerate.
	* configure: Regenerate.
	* linux-low.c: Use "gdb_stat.h" header instead of <sys/stat.h> header.
	Use "gdb_wait.h" header instead of <sys/wait.h> header.
	* lynx-low.c: Use "gdb_wait.h" header instead of <sys/wait.h> header.
	* remote-utils.c: Use "gdb_stat.h" header instead of <sys/stat.h>
	header.
	* server.c: Remove HAVE_WAIT_H conditional.  Use "gdb_wait.h" header
	instead of <sys/wait.h> header.
	* spu-low.c: Use "gdb_wait.h" header instead of <sys/wait.h> header.
@
text
@d23 1
d119 4
a122 3
/* Structure holding information relative to a single stop reply.  We
   keep a queue of these (really a singly-linked list) to push to GDB
   in non-stop mode.  */
d125 1
a125 2
  /* Pointer to next in list.  */
  struct vstop_notif *next;
d134 1
a134 2
/* The pending stop replies list head.  */
static struct vstop_notif *notif_queue = NULL;
d141 1
a141 1
  struct vstop_notif *new_notif;
a142 2
  new_notif = xmalloc (sizeof (*new_notif));
  new_notif->next = NULL;
d146 1
a146 22
  if (notif_queue)
    {
      struct vstop_notif *tail;
      for (tail = notif_queue;
	   tail && tail->next;
	   tail = tail->next)
	;
      tail->next = new_notif;
    }
  else
    notif_queue = new_notif;

  if (remote_debug)
    {
      int i = 0;
      struct vstop_notif *n;

      for (n = notif_queue; n; n = n->next)
	i++;

      fprintf (stderr, "pending stop replies: %d\n", i);
    }
d149 5
a153 5
/* Place an event in the stop reply queue, and push a notification if
   we aren't sending one yet.  */

void
push_event (ptid_t ptid, struct target_waitstatus *status)
d155 1
a155 1
  gdb_assert (status->kind != TARGET_WAITKIND_IGNORE);
d157 5
a161 1
  queue_stop_reply (ptid, status);
d163 1
a163 10
  /* If this is the first stop reply in the queue, then inform GDB
     about it, by sending a Stop notification.  */
  if (notif_queue->next == NULL)
    {
      char *p = own_buf;
      strcpy (p, "Stop:");
      p += strlen (p);
      prepare_resume_reply (p,
			    notif_queue->ptid, &notif_queue->status);
      putpkt_notif (own_buf);
d165 2
d175 3
a177 1
  struct vstop_notif *prev = NULL, *reply, *next;
d179 4
a182 3
  for (reply = notif_queue; reply; reply = next)
    {
      next = reply->next;
d184 1
a184 13
      if (pid == -1
	  || ptid_get_pid (reply->ptid) == pid)
	{
	  if (reply == notif_queue)
	    notif_queue = next;
	  else
	    prev->next = reply->next;

	  free (reply);
	}
      else
	prev = reply;
    }
d187 1
a187 4
/* If there are more stop replies to push, push one now.  */

static void
send_next_stop_reply (char *own_buf)
d189 2
a190 7
  if (notif_queue)
    prepare_resume_reply (own_buf,
			  notif_queue->ptid,
			  &notif_queue->status);
  else
    write_ok (own_buf);
}
a2128 23
/* Handle a 'vStopped' packet.  */
static void
handle_v_stopped (char *own_buf)
{
  /* If we're waiting for GDB to acknowledge a pending stop reply,
     consider that done.  */
  if (notif_queue)
    {
      struct vstop_notif *head;

      if (remote_debug)
	fprintf (stderr, "vStopped: acking %s\n",
		 target_pid_to_str (notif_queue->ptid));

      head = notif_queue;
      notif_queue = notif_queue->next;
      free (head);
    }

  /* Push another stop reply, or if there are no more left, an OK.  */
  send_next_stop_reply (own_buf);
}

d2189 2
a2190 5
  if (strncmp (own_buf, "vStopped", 8) == 0)
    {
      handle_v_stopped (own_buf);
      return;
    }
d2271 4
d2277 2
a2278 1
      queue_stop_reply (entry->id, &thread->last_status);
d2359 1
a2359 1
      send_next_stop_reply (own_buf);
d2728 2
d3341 1
a3341 1
      if (!notif_queue)
d3439 8
a3446 2
	  /* Something interesting.  Tell GDB about it.  */
	  push_event (last_ptid, &last_status);
@


1.179
log
@gdb/gdbserver:
2012-11-09  Yao Qi  <yao@@codesourcery.com>

	* spu-low.c (current_ptid): Move it to ..
	* gdbthread.h: ... here.  New.
	* remote-utils.c (read_ptid): Use macro 'current_ptid'.
	* server.c (myresume, process_serial_event): Likewise.
	* thread-db.c (thread_db_find_new_threads): Likewise.
	* tracepoint.c (run_inferior_command): Likewise.
@
text
@d30 1
a30 3
#if HAVE_SYS_WAIT_H
#include <sys/wait.h>
#endif
@


1.178
log
@http://sourceware.org/ml/gdb-patches/2012-09/msg00568.html

gdb/ChangeLog

        * target.c (simple_search_memory): Include access length in
        warning message.

gdb/gdbserver/ChangeLog

        * server.c (handle_search_memory_1): Include access length in
        warning message.

gdb/testsuite/ChangeLog

        Test find command on unmapped memory.
        * gdb.base/find-unmapped.c: New file.
        * gdb.base/find-unmapped.exp: New file.
@
text
@d2286 1
a2286 2
      resume_info[0].thread
	= ((struct inferior_list_entry *) current_inferior)->id;
d3008 1
a3008 2
	pid =
	  ptid_get_pid (((struct inferior_list_entry *) current_inferior)->id);
@


1.177
log
@2012-07-31  Pedro Alves  <palves@@redhat.com>

	* server.c (process_point_options): Only skip tokens if we find
	one that is unrecognized.  Don't treat 'X' specially while
	skipping unrecognized tokens.
@
text
@d738 3
a740 2
      warning ("Unable to access target memory at 0x%lx, halting search.",
	       (long) start_addr);
d791 1
a791 1
	      warning ("Unable to access target memory "
d793 1
a793 1
		       (long) read_addr);
@


1.176
log
@gdb/gdbserver/
	* server.c (process_point_options): Stop at 'X' when parsing.
@
text
@a2940 1
	  /* Unrecognized token, just skip it.  */
d2943 3
a2946 4

      /* Skip tokens until we find one that we recognize.  */
      while (*dataptr && *dataptr != 'X' && *dataptr != ';')
	dataptr++;
@


1.175
log
@	Add target-side support for dynamic printf.
	* NEWS: Mention the additional style.
	* breakpoint.h (struct bp_target_info): New fields tcommands, persist.
	(struct bp_location): New field cmd_bytecode.
	* breakpoint.c: Include format.h.
	(disconnected_dprintf): New global.
	(parse_cmd_to_aexpr): New function.
	(build_target_command_list): New function.
	(insert_bp_location): Call it.
	(remove_breakpoints_pid): Skip dprintf breakpoints.
	(print_one_breakpoint_location): Ditto.
	(dprintf_style_agent): New global.
	(dprintf_style_enums): Add dprintf_style_agent.
	(update_dprintf_command_list): Add agent case.
	(agent_printf_command): New function.
	(_initialize_breakpoint): Add new commands.
	* common/ax.def (printf): New bytecode.
	* ax.h (ax_string): Declare.
	* ax-gdb.h (gen_printf): Declare.
	* ax-gdb.c: Include cli-utils.h, format.h.
	(gen_printf): New function.
	(maint_agent_print_command): New function.
	(_initialize_ax_gdb): Add maint agent-printf command.
	* ax-general.c (ax_string): New function.
	(ax_print): Add printf disassembly.
	* Makefile.in (SFILES): Add format.c
	(COMMON_OBS): Add format.o.
	* common/format.h: New file.
	* common/format.c: New file.
	* printcmd.c: Include format.h.
	(ui_printf): Call parse_format_string.
	* remote.c (remote_state): New field breakpoint_commands.
	(PACKET_BreakpointCommands): New enum.
	(remote_breakpoint_commands_feature): New function.
	(remote_protocol_features): Add new BreakpointCommands entry.
	(remote_can_run_breakpoint_commands): New function.
	(remote_add_target_side_commands): New function.
	(remote_insert_breakpoint): Call it.
	(remote_insert_hw_breakpoint): Ditto.
	(_initialize_remote): Add new packet configuration for
	target-side breakpoint commands.
	* target.h (struct target_ops): New field
	to_can_run_breakpoint_commands.
	(target_can_run_breakpoint_commands): New macro.
	* target.c (update_current_target): Handle
	to_can_run_breakpoint_commands.

	[gdbserver]
	* Makefile.in (WARN_CFLAGS_NO_FORMAT): Define.
	(ax.o): Add it to build rule.
	(ax-ipa.o): Ditto.
	(OBS): Add format.o.
	(IPA_OBS): Add format.o.
	* server.c (handle_query): Claim support for breakpoint commands.
	(process_point_options): Add command case.
	(process_serial_event): Leave running if there are printfs in
	effect.
	* mem-break.h (any_persistent_commands): Declare.
	(add_breakpoint_commands): Declare.
	(gdb_no_commands_at_breakpoint): Declare.
	(run_breakpoint_commands): Declare.
	* mem-break.c (struct point_command_list): New struct.
	(struct breakpoint): New field command_list.
	(any_persistent_commands): New function.
	(add_commands_to_breakpoint): New function.
	(add_breakpoint_commands): New function.
	(gdb_no_commands_at_breakpoint): New function.
	(run_breakpoint_commands): New function.
	* linux-low.c (linux_wait_1): Test for and run breakpoint commands
	locally.
	* ax.c: Include format.h.
	(ax_printf): New function.
	(gdb_eval_agent_expr): Add printf opcode.

	[doc]
	* gdb.texinfo (Dynamic Printf): Mention agent style and
	disconnected dprintf.
	(Maintenance Commands): Describe maint agent-printf.
	(General Query Packets): Mention BreakpointCommands feature.
	(Packets): Document commands extension to Z0 packet.
	* agentexpr.texi (Bytecode Descriptions): Document printf
	bytecode.

	[testsuite]
	* gdb.base/dprintf.exp: Add agent style tests.
@
text
@d2947 1
a2947 1
      while (*dataptr && *dataptr != ';')
@


1.175.2.1
log
@gdb/gdbserver/
	* server.c (process_point_options): Stop at 'X' when parsing.
@
text
@d2947 1
a2947 1
      while (*dataptr && *dataptr != 'X' && *dataptr != ';')
@


1.174
log
@gdb/gdbserver:
	* server.c (start_inferior): Remove duplicated writes to fields
	'last_resume_kind' and 'last_status' of 'current_inferior'.
@
text
@d1688 1
a1688 1
      /* Support target-side breakpoint conditions.  */
d1690 1
d2911 1
d2921 19
a2939 1
      switch (*dataptr)
d2941 3
a2943 10
	  case 'X':
	    /* Conditional expression.  */
	    if (remote_debug)
	      fprintf (stderr, "Found breakpoint condition.\n");
	    add_breakpoint_condition (point_addr, &dataptr);
	    break;
	  default:
	    /* Unrecognized token, just skip it.  */
	    fprintf (stderr, "Unknown token %c, ignoring.\n",
		     *dataptr);
d2947 1
a2947 1
      while (*dataptr && *dataptr != 'X' && *dataptr != ';')
d3013 1
a3013 1
      if (tracing && disconnected_tracing)
d3024 9
a3032 3
	  fprintf (stderr,
		   "Disconnected tracing in effect, "
		   "leaving gdbserver attached to the process\n");
@


1.173
log
@gdb/gdbserver:
        * linux-low.c (linux_set_resume_request): Simplify predicate.  Add
        comment.
        * server.c (handle_v_cont): Extend comment.
@
text
@a324 2
      current_inferior->last_resume_kind = resume_stop;
      current_inferior->last_status = last_status;
@


1.172
log
@gdb/gdbserver/
	Fix gcc -flto compilation warning.
	* server.c (main): Make variable multi_mode and attach volatile.
@
text
@d1977 2
a1978 2
     to set it if we see a stop request, or any form of wildcard
     vCont.  */
@


1.171
log
@gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

gdb/gdbserver/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

include/gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        * gdb/signals.def: Replace TARGET_SIGNAL_ with GDB_SIGNAL_
	throughout.

sim/arm/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/avr/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/common/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/cr16/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/d10v/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/erc32/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/m32c/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/ppc/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/rl78/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/rx/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.
@
text
@d2607 2
a2608 2
  int multi_mode = 0;
  int attach = 0;
@


1.170
log
@gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.

gdb/gdbserver/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.

include/gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.

sim/common/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.
@
text
@d74 2
a75 2
int pass_signals[TARGET_SIGNAL_LAST];
int program_signals[TARGET_SIGNAL_LAST];
d323 1
a323 1
      while (last_status.value.sig != TARGET_SIGNAL_TRAP);
d373 2
a374 2
	  && last_status.value.sig == TARGET_SIGNAL_STOP)
	last_status.value.sig = TARGET_SIGNAL_TRAP;
d454 1
a454 1
      int numsigs = (int) TARGET_SIGNAL_LAST, i;
d479 1
a479 1
      int numsigs = (int) TARGET_SIGNAL_LAST, i;
d2161 1
a2161 1
      last_status.value.sig = TARGET_SIGNAL_KILL;
d2384 1
a2384 1
      thread->last_status.value.sig = TARGET_SIGNAL_0;
d2439 1
a2439 1
	  status.value.sig = TARGET_SIGNAL_TRAP;
d3311 1
a3311 1
	  last_status.value.sig = TARGET_SIGNAL_KILL;
d3355 1
a3355 1
	      last_status.value.sig = TARGET_SIGNAL_KILL;
@


1.169
log
@gdb/gdbserver:

	* server.h: Move some code to ...
	* gdbthread.h: ... here.  New.
	* Makefile.in (inferiors.o, regcache.o): Depends on gdbthread.h
	(remote-utils.o, server.o, target.o tracepoint.o): Likewise.
	(nto-low.o, win32-low.o): Likewise.
	* inferiors.c, linux-low.h, nto-low.c: Include gdbthread.h.
	* regcache.c, remote-utils.c, server.c: Likewise.
	* target.c, tracepoint.c, win32-low.c: Likewise.
@
text
@d1938 1
a1938 1
	  if (!target_signal_to_host_p (sig))
d1940 1
a1940 1
	  resume_info[i].sig = target_signal_to_host (sig);
d3216 2
a3217 2
      if (target_signal_to_host_p (sig))
	signal = target_signal_to_host (sig);
d3225 2
a3226 2
      if (target_signal_to_host_p (sig))
	signal = target_signal_to_host (sig);
d3479 1
a3479 1
	      resume_info.sig = target_signal_to_host (last_status.value.sig);
@


1.168
log
@gdb/gdbserver/
	* remote-utils.c (prepare_resume_reply): Replace with macro
	target_core_of_thread.
	* server.c (handle_qxfer_threads_proper): Likewise.
	* target.h (traget_core_of_thread): New macro.
@
text
@d21 1
@


1.167
log
@2012-03-26  Pedro Alves  <palves@@redhat.com>

	* server.c (handle_qxfer_libraries): Don't bail early if
	the_target->qxfer_libraries_svr4 is not NULL.
@
text
@d1164 1
a1164 1
      int core = -1;
a1168 3
      if (the_target->core_of_thread)
	core = (*the_target->core_of_thread) (ptid);

@


1.166
log
@2012-03-19  Pedro Alves  <palves@@redhat.com>
	    Jan Kratochvil  <jan.kratochvil@@redhat.com>

	* server.c (cont_thread, general_thread): Add describing comments.
	(start_inferior): Clear `cont_thread'.
	(handle_v_cont): Don't set `cont_thread' if resuming all threads
	of a process.
@
text
@a1017 4
  /* Do not confuse this packet with qXfer:libraries-svr4:read.  */
  if (the_target->qxfer_libraries_svr4 != NULL)
    return 0;

@


1.165
log
@Make breakpoint condition detection trace conditional on remote_debug.

gdb/gdbserver/ChangeLog:

        * server.c (process_point_options): If a conditional expression
        is found, only print a message if remote_debug is nonzero.
@
text
@d33 10
d44 2
d277 4
d1981 4
a1984 1
  /* Still used in occasional places in the backend.  */
d1986 2
a1987 1
      && !ptid_equal (resume_info[0].thread, minus_one_ptid)
@


1.164
log
@2012-03-07  Pedro Alves  <palves@@redhat.com>

	gdb/doc/
	* gdb.texinfo (General Query Packets): Document new
	QProgramSignals packet.
	* gdb.texinfo (Remote configuration): Mention
	"program-signals-packet".

	gdb/gdbserver/
	* linux-low.c (get_detach_signal): New.
	(linux_detach_one_lwp): Get rid of a pending SIGSTOP with SIGCONT.
	Pass on pending signals to PTRACE_DETACH.  Check the result of the
	ptrace call.
	* server.c (program_signals, program_signals_p): New.
	(handle_general_set): Handle QProgramSignals.
	* server.h (program_signals, program_signals_p): Declare.

	gdb/
	* NEWS: Mention QProgramSignals.
	* inferior.h (update_signals_program_target): Declare.
	* infrun.c: (update_signals_program_target): New.
	(handle_command): Update the target of the new program signals
	array changes.
	* remote.c (PACKET_QProgramSignals): New enum.
	(last_program_signals_packet): New global.
	(remote_program_signals): New.
	(remote_start_remote): Update the target with the program signals
	list.
	(remote_protocol_features): Add entry for QPassSignals.
	(remote_open_1): Free anc clear last_program_signals_packet.
	(init_remote_ops): Install remote_program_signals.
	* target.c (update_current_target): Adjust.
	(target_program_signals): New.
	* target.h (struct target_ops) <to_program_signals>: New field.
	(target_program_signals): Declare.
@
text
@d2911 2
a2912 1
	    fprintf (stderr, "Found breakpoint condition.\n");
@


1.163
log
@gdb:
	* target.h (struct target_ops) <to_use_agent>: New field.
	(struct target_ops) <to_can_use_agent>: New field.
	(target_use_agent, target_can_use_agent): New macro.
	* target.c (update_current_target): Update.
	* remote.c: New enum `PACKET_QAgent'.
	(remote_protocol_features): Add a new element.
	(remote_use_agent, remote_can_use_agent): New.
	(init_remote_ops): Initialize field `can_use_agent' with
	remote_can_use_agent.  Intiailize field `use_agent' with
	remote_use_agent.
	* common/agent.c (use_agent): New global.
	* common/agent.h: Declare it.
	* tracepoint.c (info_static_tracepoint_markers_command): Add
	comment.
	* Makefile.in (SFILES): Add common/agent.c and agent.c.
	(COMMON_OBS): Add common/agent.o and agent.o
	(common-agent.o): New rule.
	* agent.c: New.

gdb/doc:
	* gdb.texinfo (In-Process Agent): New node.
	Document new commands.
	(General Query Packets): Add packet `QAgent'.

gdb/gdbserver:
	* linux-low.c (linux_supports_agent): New.
	(linux_target_ops): Initialize field `supports_agent' with
	linux_supports_agent.
	* target.h (struct target_ops) <supports_agent>: New.
	(target_supports_agent): New macro.
	* server.c (handle_general_set): Handle packet 'QAgent'.
	(handle_query): Send `QAgent+'.
	* Makefile.in (server.o): Depends on agent.h.
@
text
@d62 2
d460 27
d1616 3
a1618 1
      sprintf (own_buf, "PacketSize=%x;QPassSignals+", PBUFSIZ - 1);
@


1.162
log
@2012-02-24  Luis Machado  <lgustavo@@codesourcery>

	* server.c (handle_query): Advertise support for target-side
	breakpoint condition evaluation.
	(process_point_options): New function.
	(process_serial_event): When inserting a breakpoint, check for
	a target-side condition that should be evaluated.

	* mem-break.c: Include regcache.h and ax.h.
	(point_cond_list_t): New data structure.
	(breakpoint) <cond_list>: New field.
	(find_gdb_breakpoint_at): Make non-static.
	(delete_gdb_breakpoint_at): Clear any target-side
	conditions.
	(clear_gdb_breakpoint_conditions): New function.
	(add_condition_to_breakpoint): Likewise.
	(add_breakpoint_condition): Likewise.
	(gdb_condition_true_at_breakpoint): Likewise.
	(gdb_breakpoint_here): Return result directly instead
	of going through a local variable.

	* mem-break.h (find_gdb_breakpoint_at): New prototype.
	(clear_gdb_breakpoint_conditions): Likewise.
	(add_breakpoint_condition): Likewise.
	(gdb_condition_true_at_breakpoint): Likewise.

	* linux-low.c (linux_wait_1): Evaluate target-side breakpoint condition.
	(need_step_over_p): Take target-side breakpoint condition into
	consideration.
@
text
@d21 1
d533 24
d1652 3
@


1.161
log
@gdb/gdbserver/
	* server.c: (handle_monitor_command): Add a new parameter
	`own_buf'.
	(handle_query): Update caller.
@
text
@d1624 3
d2831 37
d3190 16
a3205 1
	      res = (*the_target->insert_point) (type, addr, len);
@


1.160
log
@2012-01-23  Pedro Alves  <palves@@redhat.com>

	* server.c (main): Avoid yet another case of infinite loop while
	detaching/killing after a longjmp.
@
text
@d814 1
a814 1
handle_monitor_command (char *mon)
d1740 1
a1740 1
	handle_monitor_command (mon);
@


1.159
log
@2012-01-20  Pedro Alves  <palves@@redhat.com>
	    Ulrich Weigand  <ulrich.weigand@@linaro.org>

ChangeLog:

	* remote.c (remote_multi_process_p): Only check for multi-process
	protocol feature, do not check for extended protocol.
	(remote_supports_multi_process): Check for extended protocol here.
	(set_general_process): Likewise.
	(extended_remote_kill): Likewise.
	(remote_pid_to_str): Likewise.
	(remote_query_supported): Always query multiprocess mode.

gdbserver/ChangeLog:

	* server.c (handle_v_requests): Only support vAttach and vRun to
	start multiple processes when in extended protocol mode.
@
text
@d2730 4
a2733 7
      if (setjmp (toplevel))
	{
	  fprintf (stderr, "Detach or kill failed.  Exiting\n");
	  exit (1);
	}

      detach_or_kill_for_exit ();
d2779 14
a2792 2
	  detach_or_kill_for_exit ();
	  exit (0);
@


1.158
log
@2012-01-13  Pedro Alves  <palves@@redhat.com>

	* server.c (attach_inferior): Clear `cont_thread'.
@
text
@d2147 1
a2147 1
      if (!multi_process && target_running ())
d2159 1
a2159 1
      if (!multi_process && target_running ())
@


1.157
log
@2012-01-13  Pedro Alves  <palves@@redhat.com>

	* server.c (main): Avoid infinite loop while detaching/killing
	after a longjmp.
@
text
@d341 4
@


1.156
log
@	* server.c (start_inferior): Set last_ptid in --wrapper case.
@
text
@d2722 10
@


1.155
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d287 1
a287 1
      mywait (pid_to_ptid (signal_pid), &last_status, 0, 0);
d296 1
a296 1
 	  mywait (pid_to_ptid (signal_pid), &last_status, 0, 0);
@


1.154
log
@gdb/gdbserver/gdbreplay: Update copyright year in version out

gdb/ChangeLog:

	* top.c (print_gdb_version): Update copyright year.

gdb/gdbserver/ChangeLog:

	* server.c (gdbserver_version): Update copyright year.
	* gdbreplay.c (gdbreplay_version): Likewise.
@
text
@d2 2
a3 3
   Copyright (C) 1989, 1993, 1994, 1995, 1997, 1998, 1999, 2000, 2002, 2003,
   2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.153
log
@	* NEWS: Add entry for stdio gdbserver.

	gdbserver/
	* linux-low.c (linux_create_inferior): If stdio connection,
	redirect stdin from /dev/null, stdout to stderr.
	* remote-utils.c (remote_is_stdio): New static global.
	(remote_connection_is_stdio): New function.
	(remote_prepare): Handle stdio connection.
	(remote_open): Ditto.
	(remote_close): Don't close stdin for stdio connections.
	(read_prim,write_prim): New functions.  Replace all calls to
	read/write to these.
	* server.c (main): Watch for "-" argument.  Move call to
	remote_prepare before start_inferior.
	* server.h (STDIO_CONNECTION_NAME): New macro.
	(remote_connection_is_stdio): Declare.

	doc/
	* gdb.texinfo (Server): Document -/stdio argument to gdbserver.

	testsuite/
	* lib/gdbserver-support.exp (gdb_target_cmd): Recognize stdio
	gdbserver output.
	(gdbserver_default_get_remote_address): New function.
	(gdbserver_start): Call gdb,get_remote_address to compute argument
	to "target remote" command.
@
text
@d2373 1
a2373 1
	  "Copyright (C) 2011 Free Software Foundation, Inc.\n"
@


1.152
log
@gdb/
	* Makefile.in (XMLFILES): Add library-list-svr4.dtd.
	* features/library-list-svr4.dtd: New file.
	* remote.c (PACKET_qXfer_libraries_svr4): New.
	(remote_protocol_features): new entry for PACKET_qXfer_libraries_svr4.
	(remote_xfer_partial): Handle TARGET_OBJECT_LIBRARIES_SVR4.
	* solib-svr4.c (struct svr4_library_list): New.
	[HAVE_LIBEXPAT]: Include xml-support.h.
	[HAVE_LIBEXPAT] (svr4_library_list_start_library)
	[HAVE_LIBEXPAT] (svr4_library_list_start_list, svr4_library_attributes)
	[HAVE_LIBEXPAT] (svr4_library_list_children)
	[HAVE_LIBEXPAT] (svr4_library_list_attributes)
	[HAVE_LIBEXPAT] (svr4_library_list_elements, svr4_parse_libraries)
	[HAVE_LIBEXPAT] (svr4_current_sos_via_xfer_libraries)
	[!HAVE_LIBEXPAT] (svr4_current_sos_via_xfer_libraries): New.
	(svr4_read_so_list): Extend the corruption message by addresses.
	(svr4_current_sos): New variable library_list, call
	svr4_current_sos_via_xfer_libraries.
	* target.h (enum target_object): New TARGET_OBJECT_LIBRARIES_SVR4.

gdb/gdbserver/
	* linux-low.c (get_phdr_phnum_from_proc_auxv, get_dynamic, get_r_debug)
	(read_one_ptr, struct link_map_offsets, linux_qxfer_libraries_svr4):
	New.
	(struct linux_target_ops): Install linux_qxfer_libraries_svr4.
	* linux-low.h (struct process_info_private): New member r_debug.
	* server.c (handle_qxfer_libraries): Call
	the_target->qxfer_libraries_svr4.
	(handle_qxfer_libraries_svr4): New function.
	(qxfer_packets): New entry "libraries-svr4".
	(handle_query): Check QXFER_LIBRARIES_SVR4 and report libraries-svr4.
	* target.h (struct target_ops): New member qxfer_libraries_svr4.
	* remote.c (remote_xfer_partial): Call add_packet_config_cmd for
	PACKET_qXfer_libraries_svr4.

gdb/doc/
	* gdb.texinfo (Requirements, Remote Protocol): Reference also `Library
	List Format for SVR4 Targets'.
	(General Query Packets): New item qXfer:libraries-svr4:read.
	(Library List Format for SVR4 Targets): New node.

gdb/testsuite/
	* gdb.base/solib-corrupted.exp: Suppress test on is_remote target.
	(corrupted list): Adjust the expectation.
@
text
@d2609 7
d2646 6
a2738 2
  remote_prepare (port);

@


1.152.2.1
log
@gdb/gdbserver/gdbreplay: Update copyright year in version out

gdb/ChangeLog:

	* top.c (print_gdb_version): Update copyright year.

gdb/gdbserver/ChangeLog:

	* server.c (gdbserver_version): Update copyright year.
	* gdbreplay.c (gdbreplay_version): Likewise.
@
text
@d2373 1
a2373 1
	  "Copyright (C) 2012 Free Software Foundation, Inc.\n"
@


1.152.2.2
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 3
a4 2
   Copyright (C) 1989, 1993-1995, 1997-2000, 2002-2012 Free Software
   Foundation, Inc.
@


1.151
log
@gdb/
	* remote.c (struct remote_state): <install_in_trace> new field.
	(PACKET_InstallInTrace): New enum value.
	(remote_install_in_trace_feature): Support InstallInTrace.
	(remote_supports_install_in_trace): Likewise.
	(remote_protocol_features): Likewise.
	(_initialize_remote): Likewise.
	(remote_can_download_tracepoint): New.
	* target.h (struct target): New field
	`to_can_download_tracepoint'.
	(target_can_download_tracepoint): New macro.
	* target.c (update_current_target): Update.
	* breakpoint.h (struct bp_location): Add comment on field
	`duplicate'.
	(should_be_inserted): Don't differentiate breakpoint and tracepoint.
	(remove_breakpoints): Don't remove tracepoints.
	(tracepoint_locations_match ): New.
	(breakpoint_locations_match): Call it.
	(disable_breakpoints_in_unloaded_shlib): Handle tracepoint.
	(download_tracepoint_locations): New.
	(update_global_location_list): Call it.
	* tracepoint.c (find_matching_tracepoint): Delete.
	(find_matching_tracepoint_location): Renamed from
	find_matching_tracepoint.  Return bp_location rather than
	tracepoint.
	(merge_uploaded_tracepoints): Set `inserted' field to 1 if
	tracepoint is found.

gdb/doc/
	* gdb.texinfo (Create and Delete Tracepoints): Describe changed
	behavior of tracepoint.
	(General Query Packets): New feature InstallInTrace.
	(Remote Configuration): Document "set remote
	install-in-trace-packet".

gdb/gdbserver/
	* server.c (handle_query): Handle InstallInTrace for qSupported.
	* tracepoint.c (add_tracepoint): Sort list.
	(install_tracepoint, download_tracepoint): New.
	(cmd_qtdp): Call them to install and download tracepoints.
	(sort_tracepoints): Removed.
	(cmd_qtstart): Update.

gdb/testsuite/
	* gdb.trace/change-loc-1.c: New.
	* gdb.trace/change-loc-2.c: New.
	* gdb.trace/change-loc.c: New.
	* gdb.trace/change-loc.exp:  New.
	* gdb.trace/change-loc.h:  New.
	* gdb.trace/trace-break.c (marker): Define new symbol.
	* gdb.trace/trace-break.exp (break_trace_same_addr_5):
        New.
	(break_trace_same_addr_6): New.
@
text
@d945 4
d999 17
d1240 1
d1561 8
a1568 3
      /* We do not have any hook to indicate whether the target backend
	 supports qXfer:libraries:read, so always report it.  */
      strcat (own_buf, ";qXfer:libraries:read+");
@


1.150
log
@2011-11-02  Stan Shebs  <stan@@codesourcery.com>

	String collection for tracepoints.
	* NEWS: Mention string collection.
	* common/ax.def (tracenz): New bytecode.
	* ax-gdb.h (trace_string_kludge): Declare.
	* ax-gdb.c: Include valprint.h and c-lang.h.
	(trace_string_kludge): New global.
	(gen_traced_pop): Add string case.
	(agent_command): Add string case.
	* tracepoint.h (decode_agent_options): Declare.
	* tracepoint.c: Include cli-utils.h.
	(decode_agent_options): New function.
	(validate_actionline): Call it.
	(encode_actions_1): Ditto.
	* target.h (struct target_ops): New method to_supports_string_tracing.
	(target_supports_string_tracing): New macro.
	* target.c (update_current_target): Add to_supports_string_tracing.
	* remote.c (struct remote_state): New field string_tracing.
	(remote_string_tracing_feature): New function.
	(remote_protocol_features): New feature tracenz.
	(remote_supports_string_tracing): New function.
	(init_remote_ops): Set to_supports_string_tracing.

	* tracepoint.c (agent_mem_read_string): New function.
	(eval_agent_expr): Call it for tracenz.
	* server.c (handle_query): Report support for tracenz.

	* gdb.texinfo (Tracepoint Action Lists): Document collect/s.
	(General Query Packets): Describe tracenz feature.
	* agentexpr.texi (Bytecode Descriptions): Describe tracenz.

	* gdb.trace/collection.c: Add code using strings.
	* gdb.trace/collection.exp: Add tests of string collection.
@
text
@d1587 1
@


1.149
log
@	* inferior.h (disable_randomization): Declare.
	* infrun.c (disable_randomization): New global variable.
	(show_disable_randomization): New function.
	(set_disable_randomization): Likewise.
	(_initialize_infrun): Install set/show disable-randomization
	commands.
	* linux-nat.c (disable_randomization): Remove.
	(show_disable_randomization): Likewise.
	(set_disable_randomization): Likewise.
	(_initialize_linux_nat): No longer install set/show
	disable-randomization commands here.
	(linux_nat_supports_disable_randomization): New function.
	(linux_nat_add_target): Install it.
	* remote.c (PACKET_QDisableRandomization): New enum value.
	(remote_protocol_packets): Support QDisableRandomization.
	(_initialize_remote): Likewise.
	(remote_supports_disable_randomization): New function.
	(init_remote_ops): Install it.
	(extended_remote_supports_disable_randomization): New function.
	(init_extended_remote_ops): Install it.
	(extended_remote_disable_randomization): New function.
	(extended_remote_create_inferior_1): Call it.
	* target.h (struct target_ops): Add to_supports_disable_randomization.
	(target_supports_disable_randomization): Add prototype.
	* target.c (target_supports_disable_randomization): New function.
	(find_default_supports_disable_randomization): Likewise.
	(init_dummy_target): Install it.

doc/
	* gdb.texinfo (Starting your Program): "set disable-randomization"
	is no longer Linux-specific.
	(Remote Configuration): Document "set remote
	disable-randomization-packet".
	(General Query Packets): Document "QDisableRandomization" packet
	and add it to "qSupported" list.

gdbserver/
	* configure.ac: Check support for personality routine.
	* configure: Regenerate.
	* config.in: Likewise.
	* linux-low.c: Include <sys/personality.h>.
	Define ADDR_NO_RANDOMIZE if necessary.
	(linux_create_inferior): Disable address space randomization when
	forking inferior, if requested.
	(linux_supports_disable_randomization): New function.
	(linux_target_ops): Install it.
	* server.h (disable_randomization): Declare.
	* server.c (disable_randomization): New global variable.
	(handle_general_set): Handle QDisableRandomization.
	(handle_query): Likewise for qSupported.
	(main): Support --disable-randomization and --no-disable-randomization
	command line arguments.
	* target.h (struct target_ops): Add supports_disable_randomization.
	(target_supports_disable_randomization): New macro.
@
text
@d1590 1
@


1.148
log
@	* server.c (step_thread): Remove definition.
	(process_serial_event): Don't handle Hs.
	* server.h (step_thread): Remove declaration.
	* target.c (set_desired_inferior): Remove use of step_thread.
@
text
@d48 4
d504 21
d1573 3
d2580 4
@


1.147
log
@        gdb/
        * remote.c (PACKET_qXfer_fdpic): New enum value.
        (remote_protocol_features): Add qXfer:fdpic:read packet.
        (remote_xfer_partial): Support TARGET_OBJECT_FDPIC.
        (_initialize_remote): Add set/show remote read-fdpic-loadmap command.
        * target.h (enum target_object): Add TARGET_OBJECT_FDPIC.

        gdb/gdbserver:
        * target.h (struct target_ops): Add read_loadmap.
        * linux-low.c (struct target_loadseg): New type.
        (struct target_loadmap): New type.
        (linux_read_loadmap): New function.
        (linux_target_ops): Add linux_read_loadmap.
        * server.c (handle_query): Support qXfer:fdpic:read packet.
	* win32-low.c (win32_target_ops): Initialize field `read_loadmap' to NULL.

        gdb/doc/
        * gdb.texinfo : Document qXfer:fdpic:read packet.
@
text
@a34 1
ptid_t step_thread;
a2932 2
	  else if (own_buf[1] == 's')
	    step_thread = thread_id;
@


1.146
log
@2011-07-22  Kwok Cheung Yeung  <kcy@@codesourcery.com>

gdb/
	* defs.h: Add guard against inclusion in gdbserver.
	(struct ptid, ptid_t): Move to common/ptid.h.
	(xfree, xzalloc, xasprintf, xvasprintf, xstrprintf, xstrvprintf,
	xsnprintf, internal_error): Move to common/common-utils.h.
	(nomem): Delete.
	* gdb_assert.h: Move into common/ sub-directory.
	* gdb_locale.h: Ditto.
	* gdb_dirent.h: Ditto.
	* inferior.h (minus_one_ptid, null_ptid, ptid_build, pid_to_ptid,
	ptid_get_pid, ptid_get_lwp, ptid_get_tid, ptid_equal, ptid_is_pid):
	Move into common/ptid.h.
	* xml-support.c (xml_escape_text): Move into common/xml-utils.c.
	(gdb_xml_create_parser_and_cleanup_1, xml_fetch_context_from_file):
	Change nomem to malloc_failure.
	* xml-support.h (xml_escape_text): Move into common/xml-utils.h.
	* utils.c (nomem): Rename to malloc_failure.
	(xmalloc, xzalloc, xrealloc, xcalloc, xfree, xstrprintf, xasprintf,
	xvasprintf, xstrvprintf, xsnprintf): Move to common/common-utils.c.
	(gdb_buildargv): Change nomem to malloc_failure.
	* infrun.c (null_ptid, minus_one_ptid, ptid_build, pid_to_ptid,
	ptid_get_pid, ptid_get_lwp, ptid_get_tid, ptid_equal,
	ptid_is_pid): Move into common/ptid.c.
	(initialize_infrun): Delete initialization of null_ptid and
	minus_one_ptid.
	* linux-nat.c (linux_nat_xfer_osdata): Defer to
	linux_common_xfer_osdata.
	* Makefile.in (SFILES): Add common/common-utils.c, common/xml-utils.c,
	common/ptid.c and common/buffer.c.
	(HFILES_NO_SRCDIR): Add common/common-utils.h, common/xml-utils.h,
	common/ptid.h, common/buffer.h and common/linux-osdata.h.
	(COMMON_OBS): Add xml-utils.o, common-utils.o, buffer.o and ptid.o.
	(common-utils.o, xml-utils.o, ptid.o, buffer.o, linux-osdata.o): New
	rules.
	* common/gdb_assert.h: New.
	* common/gdb_dirent.h: New.
	* common/gdb_locale.h: New.
	* common/buffer.c: New.
	* common/buffer.h: New.
	* common/ptid.c: New.
	* common/ptid.h: New.
	* common/xml-utils.c: New.
	* common/xml-utils.h: New.
	* common/common-utils.c: New.
	* common/common-utils.h: New.
	* common/linux-osdata.c: New.
	* common/linux-osdata.h: New.
	* config/alpha/alpha-linux.mh (NATDEPFILES): Add linux-osdata.o.
	* config/arm/linux.mh (NATDEPFILES): Ditto.
	* config/i386/linux.mh (NATDEPFILES): Ditto.
	* config/i386/linux64.mh (NATDEPFILES): Ditto.
	* config/ia64/linux.mh (NATDEPFILES): Ditto.
	* config/m32r/linux.mh (NATDEPFILES): Ditto.
	* config/m68k/linux.mh (NATDEPFILES): Ditto.
	* config/mips/linux.mh (NATDEPFILES): Ditto.
	* config/pa/linux.mh (NATDEPFILES): Ditto.
	* config/powerpc/linux.mh (NATDEPFILES): Ditto.
	* config/powerpc/ppc64-linux.mh (NATDEPFILES): Ditto.
	* config/s390/s390.mh (NATDEPFILES): Ditto.
	* config/sparc/linux.mh (NATDEPFILES): Ditto.
	* config/sparc/linux64.mh (NATDEPFILES): Ditto.
	* config/xtensa/linux.mh (NATDEPFILES): Ditto.

gdbserver/
	* linux-low.c (compare_ints, unique, list_threads, show_process,
	linux_core_of_thread): Delete.
	(linux_target_ops): Change linux_core_of_thread to
	linux_common_core_of_thread.
	(linux_qxfer_osdata): Defer to linux_common_xfer_osdata.
	* utils.c (malloc_failure): Change type of argument.
	(xmalloc, xrealloc, xcalloc, xsnprintf): Delete.
	* Makefile.in (SFILES): Add common/common-utils.c, common/xml-utils.c,
	common/linux-osdata.c, common/ptid.c and common/buffer.c.
	(OBS): Add xml-utils.o, common-utils.o, ptid.o and buffer.o.
	(IPA_OBJS): Add common-utils-ipa.o.
	(ptid_h, linux_osdata_h): New macros.
	(server_h): Add common/common-utils.h, common/xml-utils.h,
	common/buffer.h, common/gdb_assert.h, common/gdb_locale.h and
	common/ptid.h.
	(common-utils-ipa.o, common-utils.o, xml-utils.o, linux-osdata.o,
	ptid.o, buffer.o): New rules.
	(linux-low.o): Add common/linux-osdata.h as a dependency.
	* configure.srv (srv_tgtobj): Add linux-osdata.o to Linux targets.
	* configure.ac: Add AC_HEADER_DIRENT check.
	* config.in: Regenerate.
	* configure: Regenerate.
	* remote-utils.c (xml_escape_text): Delete.
	(buffer_grow, buffer_free, buffer_init, buffer_finish,
	buffer_xml_printf): Move to common/buffer.c.
	* server.c (main): Remove call to initialize_inferiors.
	* server.h (struct ptid, ptid_t, minus_one_ptid, null_ptid,
	ptid_build, pid_to_ptid, ptid_get_pid, ptid_get_lwp, ptid_get_tid,
	ptid_equal, ptid_is_pid, initialize_inferiors, xml_escape_text,
	internal_error, gdb_assert, gdb_assert_fail): Delete.
	(struct buffer, buffer_grow, buffer_free, buffer_init, buffer_finish,
	buffer_xml_printf, buffer_grow_str, buffer_grow_str0): Move to
	common/buffer.h.
	* inferiors.c (null_ptid, minus_one_ptid, ptid_build, pid_to_ptid,
	ptid_get_pid, ptid_get_lwp, ptid_get_tid, ptid_equal, ptid_is_pid,
	initialize_inferiors): Delete.
@
text
@d1174 15
d1192 1
d1528 3
@


1.145
log
@Add support for enabling and disabling tracepoints while a trace
experiment is still running.

gdb/
	* breakpoint.c (disable_breakpoint): Disable all locations
	associated with a tracepoint on target if a trace experiment is
	running.
	(disable_command): Disable a specific tracepoint location on target if
	a trace	experiment is running.
	(do_enable_breakpoint): Enable all locations associated with a
	tracepoint on target if a trace experiment is running.
	(enable_command) Enable a specific tracepoint location on target if a
	trace experiment is running.
	* target.c (update_current_target): Add INHERIT and de_fault clauses for
	to_supports_enable_disable_tracepoint, to_enable_tracepoint and
	to_disable_tracepoint.
	* target.h: Add declaration of struct bp_location.
	(struct target_ops): Add new functions
	to_supports_enable_disable_tracepoint, to_enable_tracepoint and
	to_disable_tracepoint to target operations.
	(target_supports_enable_disable_tracepoint): New macro.
	(target_enable_tracepoint): New macro.
	(target_disable_tracepoint): New macro.
	* remote.c (struct remote_state): Add new field.
	(remote_enable_disable_tracepoint_feature): New.
	(remote_protocol_features): Add new entry.
	(remote_supports_enable_disable_tracepoint): New.
	(remote_enable_tracepoint): New.
	(remote_disable_tracepoint): New.
	(init_remote_ops): Add remote_enable_tracepoint,
	remote_disable_tracepoint and remote_supports_enable_disable_tracepoint
	to remote operations.
	* tracepoint.c (start_tracing): Allow tracing to start without any
	tracepoints enabled with just a warning if they can be re-enabled
	later.
	* NEWS: Add news item for the new behaviour of the enable and disable
	GDB commands when applied to tracepoints.
	Add news items for the new remote packets QTEnable and QTDisable.

gdb/doc/
	* gdb.texinfo: Document change in the behaviour of the enable and
	disable GDB commands when applied to tracepoints.
	Document the EnableDisableTracepoints remote stub feature.
	Document QTEnable and QTDisable in the list of tracepoint packets.

gdb/gdbserver/
	* server.c (handle_query): Add EnableDisableTracepoints to the list
	of supported features.
	* tracepoint.c (clear_installed_tracepoints): Uninstall	disabled
	tracepoints.
	(cmd_qtenable_disable): New.
	(cmd_qtstart): Install tracepoints even if disabled.
	(handle_tracepoint_general_set): Add call to cmd_qtenable_disable on
	receiving a QTEnable or QTDisable packet.
	(gdb_collect): Skip data collection if fast tracepoint is disabled.
	(ust_marker_to_static_tracepoint): Do not ignore disabled static
	tracepoints.
	(gdb_probe): Skip data collection if static tracepoint is disabled.
@
text
@a2584 1
  initialize_inferiors ();
@


1.144
log
@	* linux-low.c (linux_join): Skip process lookup.
	* spu-low.c (spu_join): Ditto.
	* server.c (join_inferiors_callback): Delete.
	(process_serial_event): For 'D' packet (detach) call join_inferior
	directly.
@
text
@d1543 1
@


1.143
log
@gdb/
	* NEWS: Document the new gdbserver --once option.

gdb/doc/
	* gdb.texinfo (Starting and Stopping Trace Experiments): New anchor
	for disconnected tracing.
	(Multi-Process Mode for @@code{gdbserver}): Mention --multi and
	extended-remote relationship.  Mention --once.
	(TCP port allocation lifecycle of @@code{gdbserver}): New.

gdb/gdbserver/
	* remote-utils.c (handle_accept_event): Close LISTEN_DESC only if
	RUN_ONCE.  Comment for the LISTEN_DESC delete_file_handler call.
	(remote_prepare): New function with most of the TCP code from ...
	(remote_open): ... here.  Detect PORT here unconditionally.  Move also
	setting transport_is_reliable.
	* server.c (run_once): New variable.
	(gdbserver_usage): Document it.
	(main): Set run_once for `--once'.  Call remote_prepare.  Exit after
	the first run if RUN_ONCE.
	* server.h (run_once, remote_prepare): New declarations.

gdb/testsuite/
	* gdb.base/solib-disc.exp: Set gdbserver_reconnect_p.
	* lib/gdb.exp (gdb_init): Clear gdbserver_reconnect_p.
	* lib/gdbserver-support.exp (gdbserver_start): Add `--once' if
	!gdbserver_reconnect_p..
	(gdbserver_reconnect): Call error if !gdbserver_reconnect_p..
@
text
@a2444 11
static void
join_inferiors_callback (struct inferior_list_entry *entry)
{
  struct process_info *process = (struct process_info *) entry;

  /* If we are attached, then we can exit.  Otherwise, we need to hang
     around doing nothing, until the child is gone.  */
  if (!process->attached)
    join_inferior (ptid_get_pid (process->head.id));
}

d2843 1
a2843 2
	      for_each_inferior (&all_processes,
				 join_inferiors_callback);
@


1.142
log
@2011-03-10  Michael Snyder  <msnyder@@vmware.com>

	* gdbserver/server.c (handle_v_run): Free alloced buffer on early
	return.
@
text
@d43 3
d2318 3
a2320 1
	   "  --wrapper WRAPPER --  Run WRAPPER to start new programs.\n");
d2544 2
d2658 2
d2688 1
a2688 1
      if (exit_requested)
@


1.141
log
@2011-03-04  Michael Snyder  <msnyder@@vmware.com>

	* gdbserver/server.c (queue_stop_reply): Call xmalloc not malloc.
@
text
@a1951 1
	  /* FIXME: new_argv memory leak */
d1953 1
a1959 1
	  /* FIXME: new_argv memory leak */
d1961 1
@


1.140
log
@2011-02-27  Michael Snyder  <msnyder@@vmware.com>

	* server.c (handle_query): Discard unused value.
@
text
@d124 1
a124 1
  new_notif = malloc (sizeof (*new_notif));
@


1.139
log
@	gdb/
	* target.h (struct traceframe_info): Forward declare.
	(enum target_object): Add TARGET_OBJECT_TRACEFRAME_INFO.
	(struct target_ops) <to_traceframe_info>: New field.
	(target_traceframe_info): New.
	* target.c (update_current_target): Inherit and default
	to_traceframe_info.
	* remote.c (PACKET_qXfer_traceframe_info): New.
	(remote_protocol_features): Register qXfer:traceframe-info:read.
	(remote_xfer_partial): Handle TARGET_OBJECT_TRACEFRAME_INFO.
	(remote_traceframe_info): New.
	(init_remote_ops): Install it.
	(_initialize_remote): Install "set/show remote traceframe-info"
	commands.
	* tracepoint.h (parse_traceframe_info): Declare.
	* tracepoint.c (struct mem_range): New.
	(mem_range_s): New typedef.
	(struct traceframe_info): New.
	(traceframe_info): New global.
	(free_traceframe_info): New function.
	(clear_traceframe_info): New function.
	(start_tracing, tfind_1, set_traceframe_number): Clear traceframe
	info.
	(build_traceframe_info): New function.
	(tfile_traceframe_info): New function.
	(init_tfile_ops): Install tfile_traceframe_info.
	(traceframe_info_start_memory, free_result): New functions.
	(memory_attributes, traceframe_info_elements): New globals.
	(parse_traceframe_info, get_traceframe_info): New functions.
	* features/traceframe-info.dtd: New file.
	* Makefile.in (XMLFILES): Add traceframe-info.dtd.

	gdb/gdbserver/
	* server.c (handle_qxfer_traceframe_info): New.
	(qxfer_packets): Register "traceframe-info".
	(handle_query): Report support for qXfer:traceframe-info:read+.
	* tracepoint.c (match_blocktype): New.
	(traceframe_find_block_type): Rename to ...
	(traceframe_walk_blocks): ... this.  Add callback filter argument,
	and use it.
	(traceframe_find_block_type): New, reimplemented on top of
	traceframe_walk_blocks.
	(build_traceframe_info_xml): New.
	(traceframe_read_info): New.
	* server.h (traceframe_read_info): Declare.

	gdb/doc/
	* gdb.texinfo (Remote Configuration): Mention set/show remote
	traceframe-info.
	(Tools/Packages Optional for Building GDB): Mention that expat is
	used for traceframe info.
	(Remote Protocol) <Menu>: Add "Traceframe Info Format".
	(General Query Packets) <qSupported>: Describe the
	qXfer:traceframe-info:read feature.
	(qXfer::read): Describe qXfer:traceframe-info:read.
	(Traceframe Info Format): New section.
@
text
@d1360 1
a1360 1
      own_buf = write_ptid (own_buf, gdb_id);
@


1.138
log
@	gdb/server/
	* server.c (gdb_read_memory): Change return semantics to allow
	partial transfers.
	(handle_search_memory_1): Adjust.
	(process_serial_event) <'m' packet>: Handle partial transfers.
	* tracepoint.c (traceframe_read_mem): Handle partial transfers.

	gdb/testsuite/
	* gdb.trace/collection.c (global_pieces): New.
	* gdb.trace/collection.exp (gdb_collect_global_in_pieces_test):
	New procedure.
	(gdb_trace_collection_test): Call it.
@
text
@d1121 50
d1181 1
d1539 1
@


1.137
log
@2011-01-25  Pedro Alves  <pedro@@codesourcery.com>

	* server.h (decode_xfer_write): Change prototype.
	* remote-utils.c (decode_xfer_write): Remove `annex' parameter,
	and don't extract the annex here.
	* server.c (decode_xfer_read): Remove `annex' parameter,
	and don't extract the annex here.
	(decode_xfer): New.
	(struct qxfer): New.
	(handle_qxfer_auxv, handle_qxfer_features, handle_qxfer_libraries)
	(handle_qxfer_osdata, handle_qxfer_siginfo, handle_qxfer_spu)
	(handle_qxfer_statictrace): New functions, abstracted out from
	handle_query, and made to use the struct qxfer interface.
	(handle_threads_qxfer_proper): Rename to ...
	(handle_qxfer_threads_proper): ... this.
	(handle_threads_qxfer): Rename to ...
	(handle_qxfer_threads): ... this.  Adjust.
	(qxfer_packets): New array.
	(handle_qxfer): New function.
	(handle_query): Use handle_qxfer.
@
text
@d559 9
a567 1
/* Read trace frame or inferior memory.  */
d572 1
a572 1
  int ret;
d583 2
a584 2
      if (nbytes == length)
	return 0;
d586 1
a586 1
	return EIO;
d591 2
a592 2
  ret = prepare_to_access_memory ();
  if (ret == 0)
d594 1
a594 1
      ret = read_inferior_memory (memaddr, myaddr, len);
d596 2
d599 2
a600 2

  return ret;
d636 2
a637 1
  if (gdb_read_memory (start_addr, search_buf, search_buf_size) != 0)
d689 1
a689 1
			       nr_to_read) != 0)
d2678 1
d2917 3
a2919 2
      if (gdb_read_memory (mem_addr, mem_buf, len) == 0)
	convert_int_to_ascii (mem_buf, own_buf, len);
d2921 1
a2921 1
	write_enn (own_buf);
@


1.136
log
@2011-01-05  Michael Snyder  <msnyder@@msnyder-server.eng.vmware.com>

	* gdbreplay.c: Shorten lines of >= 80 columns.
	* linux-low.c: Ditto.
	* linux-ppc-low.c: Ditto.
	* linux-s390-low.c: Ditto.
	* linux-sparc-low.c: Ditto.
	* linux-x86-low.c: Ditto.
	* linux-xtensa-low.c: Ditto.
	* mem-break.c: Ditto.
	* nto-low.c: Ditto.
	* regcache.h: Ditto.
	* remote-utils.c: Ditto.
	* server.c: Ditto.
	* server.h: Ditto.
	* thread-db.c: Ditto.
	* tracepoint.c: Ditto.
	* utils.c: Ditto.
	* win32-low.h: Ditto.
@
text
@d360 1
a360 1
decode_xfer_read (char *buf, char **annex, CORE_ADDR *ofs, unsigned int *len)
d362 26
d396 1
a396 4
  /* After the read marker and annex, qXfer looks like a
     traditional 'm' packet.  */
  decode_m_packet (buf, ofs, len);

d817 208
d1026 1
a1026 1
handle_threads_qxfer_proper (struct buffer *buffer)
d1060 2
d1063 3
a1065 3
handle_threads_qxfer (const char *annex,
		      unsigned char *readbuf,
		      CORE_ADDR offset, int length)
d1070 5
a1074 2
  if (annex && strcmp (annex, "") != 0)
    return 0;
d1086 1
a1086 1
      handle_threads_qxfer_proper (&buffer);
d1102 53
a1154 2
  if (length > result_length - offset)
    length = result_length - offset;
d1156 29
a1184 1
  memcpy (readbuf, result + offset, length);
d1186 9
a1194 1
  return length;
d1196 35
d1275 1
a1377 400
  if (the_target->qxfer_spu != NULL
      && strncmp ("qXfer:spu:read:", own_buf, 15) == 0)
    {
      char *annex;
      int n;
      unsigned int len;
      CORE_ADDR ofs;
      unsigned char *spu_buf;

      require_running (own_buf);
      strcpy (own_buf, "E00");
      if (decode_xfer_read (own_buf + 15, &annex, &ofs, &len) < 0)
	return;
      if (len > PBUFSIZ - 2)
	len = PBUFSIZ - 2;
      spu_buf = malloc (len + 1);
      if (!spu_buf)
	return;

      n = (*the_target->qxfer_spu) (annex, spu_buf, NULL, ofs, len + 1);
      if (n < 0)
	write_enn (own_buf);
      else if (n > len)
	*new_packet_len_p = write_qxfer_response (own_buf, spu_buf, len, 1);
      else
	*new_packet_len_p = write_qxfer_response (own_buf, spu_buf, n, 0);

      free (spu_buf);
      return;
    }

  if (the_target->qxfer_spu != NULL
      && strncmp ("qXfer:spu:write:", own_buf, 16) == 0)
    {
      char *annex;
      int n;
      unsigned int len;
      CORE_ADDR ofs;
      unsigned char *spu_buf;

      require_running (own_buf);
      strcpy (own_buf, "E00");
      spu_buf = malloc (packet_len - 15);
      if (!spu_buf)
	return;
      if (decode_xfer_write (own_buf + 16, packet_len - 16, &annex,
			     &ofs, &len, spu_buf) < 0)
	{
	  free (spu_buf);
	  return;
	}

      n = (*the_target->qxfer_spu)
	(annex, NULL, (unsigned const char *)spu_buf, ofs, len);
      if (n < 0)
	write_enn (own_buf);
      else
	sprintf (own_buf, "%x", n);

      free (spu_buf);
      return;
    }

  if (the_target->read_auxv != NULL
      && strncmp ("qXfer:auxv:read:", own_buf, 16) == 0)
    {
      unsigned char *data;
      int n;
      CORE_ADDR ofs;
      unsigned int len;
      char *annex;

      require_running (own_buf);

      /* Reject any annex; grab the offset and length.  */
      if (decode_xfer_read (own_buf + 16, &annex, &ofs, &len) < 0
	  || annex[0] != '\0')
	{
	  strcpy (own_buf, "E00");
	  return;
	}

      /* Read one extra byte, as an indicator of whether there is
	 more.  */
      if (len > PBUFSIZ - 2)
	len = PBUFSIZ - 2;
      data = malloc (len + 1);
      if (data == NULL)
	{
	  write_enn (own_buf);
	  return;
	}
      n = (*the_target->read_auxv) (ofs, data, len + 1);
      if (n < 0)
	write_enn (own_buf);
      else if (n > len)
	*new_packet_len_p = write_qxfer_response (own_buf, data, len, 1);
      else
	*new_packet_len_p = write_qxfer_response (own_buf, data, n, 0);

      free (data);

      return;
    }

  if (strncmp ("qXfer:features:read:", own_buf, 20) == 0)
    {
      CORE_ADDR ofs;
      unsigned int len, total_len;
      const char *document;
      char *annex;

      require_running (own_buf);

      /* Grab the annex, offset, and length.  */
      if (decode_xfer_read (own_buf + 20, &annex, &ofs, &len) < 0)
	{
	  strcpy (own_buf, "E00");
	  return;
	}

      /* Now grab the correct annex.  */
      document = get_features_xml (annex);
      if (document == NULL)
	{
	  strcpy (own_buf, "E00");
	  return;
	}

      total_len = strlen (document);
      if (len > PBUFSIZ - 2)
	len = PBUFSIZ - 2;

      if (ofs > total_len)
	write_enn (own_buf);
      else if (len < total_len - ofs)
	*new_packet_len_p = write_qxfer_response (own_buf, document + ofs,
						  len, 1);
      else
	*new_packet_len_p = write_qxfer_response (own_buf, document + ofs,
						  total_len - ofs, 0);

      return;
    }

  if (strncmp ("qXfer:libraries:read:", own_buf, 21) == 0)
    {
      CORE_ADDR ofs;
      unsigned int len, total_len;
      char *document, *p;
      struct inferior_list_entry *dll_ptr;
      char *annex;

      require_running (own_buf);

      /* Reject any annex; grab the offset and length.  */
      if (decode_xfer_read (own_buf + 21, &annex, &ofs, &len) < 0
	  || annex[0] != '\0')
	{
	  strcpy (own_buf, "E00");
	  return;
	}

      /* Over-estimate the necessary memory.  Assume that every character
	 in the library name must be escaped.  */
      total_len = 64;
      for (dll_ptr = all_dlls.head; dll_ptr != NULL; dll_ptr = dll_ptr->next)
	total_len += 128 + 6 * strlen (((struct dll_info *) dll_ptr)->name);

      document = malloc (total_len);
      if (document == NULL)
	{
	  write_enn (own_buf);
	  return;
	}
      strcpy (document, "<library-list>\n");
      p = document + strlen (document);

      for (dll_ptr = all_dlls.head; dll_ptr != NULL; dll_ptr = dll_ptr->next)
	{
	  struct dll_info *dll = (struct dll_info *) dll_ptr;
	  char *name;

	  strcpy (p, "  <library name=\"");
	  p = p + strlen (p);
	  name = xml_escape_text (dll->name);
	  strcpy (p, name);
	  free (name);
	  p = p + strlen (p);
	  strcpy (p, "\"><segment address=\"");
	  p = p + strlen (p);
	  sprintf (p, "0x%lx", (long) dll->base_addr);
	  p = p + strlen (p);
	  strcpy (p, "\"/></library>\n");
	  p = p + strlen (p);
	}

      strcpy (p, "</library-list>\n");

      total_len = strlen (document);
      if (len > PBUFSIZ - 2)
	len = PBUFSIZ - 2;

      if (ofs > total_len)
	write_enn (own_buf);
      else if (len < total_len - ofs)
	*new_packet_len_p = write_qxfer_response (own_buf, document + ofs,
						  len, 1);
      else
	*new_packet_len_p = write_qxfer_response (own_buf, document + ofs,
						  total_len - ofs, 0);

      free (document);
      return;
    }

  if (the_target->qxfer_osdata != NULL
      && strncmp ("qXfer:osdata:read:", own_buf, 18) == 0)
    {
      char *annex;
      int n;
      unsigned int len;
      CORE_ADDR ofs;
      unsigned char *workbuf;

      strcpy (own_buf, "E00");
      if (decode_xfer_read (own_buf + 18, &annex, &ofs, &len) < 0)
	return;
      if (len > PBUFSIZ - 2)
	len = PBUFSIZ - 2;
      workbuf = malloc (len + 1);
      if (!workbuf)
	return;

      n = (*the_target->qxfer_osdata) (annex, workbuf, NULL, ofs, len + 1);
      if (n < 0)
	write_enn (own_buf);
      else if (n > len)
	*new_packet_len_p = write_qxfer_response (own_buf, workbuf, len, 1);
      else
	*new_packet_len_p = write_qxfer_response (own_buf, workbuf, n, 0);

      free (workbuf);
      return;
    }

  if (the_target->qxfer_siginfo != NULL
      && strncmp ("qXfer:siginfo:read:", own_buf, 19) == 0)
    {
      unsigned char *data;
      int n;
      CORE_ADDR ofs;
      unsigned int len;
      char *annex;

      require_running (own_buf);

      /* Reject any annex; grab the offset and length.  */
      if (decode_xfer_read (own_buf + 19, &annex, &ofs, &len) < 0
	  || annex[0] != '\0')
	{
	  strcpy (own_buf, "E00");
	  return;
	}

      /* Read one extra byte, as an indicator of whether there is
	 more.  */
      if (len > PBUFSIZ - 2)
	len = PBUFSIZ - 2;
      data = malloc (len + 1);
      if (!data)
	return;
      n = (*the_target->qxfer_siginfo) (annex, data, NULL, ofs, len + 1);
      if (n < 0)
	write_enn (own_buf);
      else if (n > len)
	*new_packet_len_p = write_qxfer_response (own_buf, data, len, 1);
      else
	*new_packet_len_p = write_qxfer_response (own_buf, data, n, 0);

      free (data);
      return;
    }

  if (the_target->qxfer_siginfo != NULL
      && strncmp ("qXfer:siginfo:write:", own_buf, 20) == 0)
    {
      char *annex;
      int n;
      unsigned int len;
      CORE_ADDR ofs;
      unsigned char *data;

      require_running (own_buf);

      strcpy (own_buf, "E00");
      data = malloc (packet_len - 19);
      if (!data)
	return;
      if (decode_xfer_write (own_buf + 20, packet_len - 20, &annex,
			     &ofs, &len, data) < 0)
	{
	  free (data);
	  return;
	}

      n = (*the_target->qxfer_siginfo)
	(annex, NULL, (unsigned const char *)data, ofs, len);
      if (n < 0)
	write_enn (own_buf);
      else
	sprintf (own_buf, "%x", n);

      free (data);
      return;
    }

  if (strncmp ("qXfer:threads:read:", own_buf, 19) == 0)
    {
      unsigned char *data;
      int n;
      CORE_ADDR ofs;
      unsigned int len;
      char *annex;

      require_running (own_buf);

      /* Reject any annex; grab the offset and length.  */
      if (decode_xfer_read (own_buf + 19, &annex, &ofs, &len) < 0
	  || annex[0] != '\0')
	{
	  strcpy (own_buf, "E00");
	  return;
	}

      /* Read one extra byte, as an indicator of whether there is
	 more.  */
      if (len > PBUFSIZ - 2)
	len = PBUFSIZ - 2;
      data = malloc (len + 1);
      if (!data)
	return;
      n = handle_threads_qxfer (annex, data, ofs, len + 1);
      if (n < 0)
	write_enn (own_buf);
      else if (n > len)
	*new_packet_len_p = write_qxfer_response (own_buf, data, len, 1);
      else
	*new_packet_len_p = write_qxfer_response (own_buf, data, n, 0);

      free (data);
      return;
    }

  if (strncmp ("qXfer:statictrace:read:", own_buf,
	       sizeof ("qXfer:statictrace:read:") -1) == 0)
    {
      unsigned char *data;
      CORE_ADDR ofs;
      unsigned int len;
      char *annex;
      ULONGEST nbytes;

      require_running (own_buf);

      if (current_traceframe == -1)
	{
	  write_enn (own_buf);
	  return;
	}

      /* Reject any annex; grab the offset and length.  */
      if (decode_xfer_read (own_buf + sizeof ("qXfer:statictrace:read:") -1,
			    &annex, &ofs, &len) < 0
	  || annex[0] != '\0')
	{
	  strcpy (own_buf, "E00");
	  return;
	}

      /* Read one extra byte, as an indicator of whether there is
	 more.  */
      if (len > PBUFSIZ - 2)
	len = PBUFSIZ - 2;
      data = malloc (len + 1);
      if (!data)
	return;

      if (traceframe_read_sdata (current_traceframe, ofs,
				 data, len + 1, &nbytes))
	write_enn (own_buf);
      else if (nbytes > len)
	*new_packet_len_p = write_qxfer_response (own_buf, data, len, 1);
      else
	*new_packet_len_p = write_qxfer_response (own_buf, data, nbytes, 0);

      free (data);
      return;
    }

d1663 3
@


1.135
log
@run copyright.sh for 2011.
@
text
@d657 2
a658 1
	      warning ("Unable to access target memory at 0x%lx, halting search.",
d1642 2
a1643 1
  if (strncmp ("qSearch:memory:", own_buf, sizeof ("qSearch:memory:") - 1) == 0)
d2169 2
a2170 1
	    fprintf (stderr, "Reporting thread %s as already stopped with %s\n",
d2270 2
a2271 1
	  "gdbserver is free software, covered by the GNU General Public License.\n"
d2302 2
a2303 1
	   "  Tthread     \tPassing the thread specifier in the T stop reply packet\n"
@


1.134
log
@Update copyright year in version of output (gdb/gdbserver/gdbreplay)

gdb/ChangeLog:

       * top.c (print_gdb_version): Update copyright year in version output.

gdb/gdbserverChangeLog:

       * server.c (gdbserver_version): Update copyright year in version
       output.
       * gdbreplay.c (gdbreplay_version): Ditto.
@
text
@d3 2
a4 1
   2004, 2005, 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
@


1.133
log
@2010-09-06  Yao Qi  <yao@@codesourcery.com>

	* linux-low.c (linux_kill): Remove unused variable.
	(linux_stabilize_threads): Likewise.
	* server.c (start_inferior): Likewise.
	(queue_stop_reply_callback): Likewise.
	* tracepoint.c (do_action_at_tracepoint): Likewise.
@
text
@d2265 1
a2265 1
	  "Copyright (C) 2010 Free Software Foundation, Inc.\n"
@


1.132
log
@[gdbserver] Move malloc.h include to server.h.

This patch moves all includes of malloc.h, which were introduced
purely to get access to alloca's declaration, to server.h, next
to the include of alloca.h.

There is one exception: gdbreplay.c, which does not include server.h.
In this case, the include of alloca.h was simply moved up a bit, next
to the include of malloc.h.

gdb/gdbserver/ChangeLog:

        * gdbreplay.c: Move include of alloca.h up, next to include of
        malloc.h.
        * server.h: Add include of malloc.h.
        * mem-break.c: Remove include of malloc.h.
        * server.c, tracepoint.c, utils.c, win32-low.c: Likewise.
@
text
@a275 1
      ptid_t ptid;
d281 1
a281 1
      ptid = mywait (pid_to_ptid (signal_pid), &last_status, 0, 0);
a2156 5
      struct target_waitstatus status;

      status.kind = TARGET_WAITKIND_STOPPED;
      status.value.sig = TARGET_SIGNAL_TRAP;

@


1.131
log
@	* linux-low.c (linux_unprepare_to_access_memory): Rename to ...
	(linux_done_accessing_memory): ... this.
	(linux_target_ops): Adjust.
	* linux-x86-low.c (x86_insert_point, x86_remove_point): Adjust.
	* nto-low.c (nto_target_ops): Adjust comment.
	* server.c (gdb_read_memory, gdb_write_memory): Adjust.
	* spu-low.c (spu_target_ops): Adjust comment.
	* target.h (target_ops): Rename unprepare_to_access_memory field
	to done_accessing_memory.
	(unprepare_to_access_memory): Rename to ...
	(done_accessing_memory): ... this.
@
text
@a30 3
#if HAVE_MALLOC_H
#include <malloc.h>
#endif
@


1.130
log
@	* linux-low.c (linux_prepare_to_access_memory): New.
	(linux_unprepare_to_access_memory): New.
	(linux_target_ops): Install them.
	* server.c (read_memory): Rename to ...
	(gdb_read_memory): ... this.  Use
	prepare_to_access_memory/prepare_to_access_memory.
	(write_memory): Rename to ...
	(gdb_write_memory): ... this.  Use
	prepare_to_access_memory/prepare_to_access_memory.
	(handle_search_memory_1): Adjust.
	(process_serial_event): Adjust.
	* target.h (struct target_ops): New fields
	prepare_to_access_memory and unprepare_to_access_memory.
	(prepare_to_access_memory, unprepare_to_access_memory): New.
	* linux-x86-low.c (x86_insert_point, x86_remove_point): Use
	prepare_to_access_memory/prepare_to_access_memory.
	* nto-low.c (nto_target_ops): Adjust.
	* spu-low.c (spu_target_ops): Adjust.
	* win32-low.c (win32_target_ops): Adjust.
@
text
@d567 1
a567 1
      unprepare_to_access_memory ();
d589 1
a589 1
	  unprepare_to_access_memory ();
@


1.129
log
@	* linux-low.c (linux_wait_1): Don't set last_status here.
	* server.c (push_event, queue_stop_reply_callback): Assert we're
	not pushing a TARGET_WAITKIND_IGNORE event.
	(start_inferior, start_inferior, attach_inferior, handle_v_cont)
	(myresume, handle_target_event): Set the thread's last_resume_kind
	and last_status from the target returned status.
@
text
@d542 1
a542 1
read_memory (CORE_ADDR memaddr, unsigned char *myaddr, int len)
d544 2
d563 8
a570 1
  return read_inferior_memory (memaddr, myaddr, len);
d577 1
a577 1
write_memory (CORE_ADDR memaddr, const unsigned char *myaddr, int len)
d582 11
a592 1
    return write_inferior_memory (memaddr, myaddr, len);
d606 1
a606 1
  if (read_memory (start_addr, search_buf, search_buf_size) != 0)
d657 2
a658 2
	  if (read_memory (read_addr, search_buf + keep_len,
				    nr_to_read) != 0)
d2946 1
a2946 1
      if (read_memory (mem_addr, mem_buf, len) == 0)
d2954 1
a2954 1
      if (write_memory (mem_addr, mem_buf, len) == 0)
d2963 1
a2963 1
	  || write_memory (mem_addr, mem_buf, len) != 0)
@


1.128
log
@Really commit server.c bits of 2010-08-09's change...
@
text
@d161 2
d297 3
d303 2
d312 7
d349 3
d1800 4
d2113 8
d2160 2
d3169 7
a3175 4
	/* We're reporting this thread as stopped.  Update it's
	   "want-stopped" state to what the client wants, until it gets
	   a new resume action.  */
	gdb_wants_thread_stopped (&current_inferior->entry);
@


1.127
log
@gdb/gdbserver/
	* server.c (handle_target_event): Use target_signal_to_host for
	resume_info.sig initialization.
	* target.h (struct thread_resume) <sig>: New comment.
@
text
@d1677 2
d1782 6
d2140 3
a2142 2
/* Set this inferior LWP's state as "want-stopped".  We won't resume
   this LWP until the client gives us another action for it.  */
d2153 2
d3137 5
@


1.126
log
@* gdb/gdbserver/server.c (handle_query): strcpy() the returned string from
paddress() instead of sprintf().
@
text
@d3150 1
a3150 1
	      resume_info.sig = last_status.value.sig;
@


1.125
log
@[PATCH] Unexpected EOF read from connection with GDB after inferior exits.

This is on GNU/Linux.

GDBserver does not exit properly when the inferior exits, as demonstrated
with any program using the procedure below:

   % gdbserver-head :4444 simple_main
   Process simple_main created; pid = 25681
   Listening on port 4444

Then, in another terminal, start GDB, connect to GDBserver, and run
the program to completion:

   % gdb-head simple_main
   (gdb) tar rem :4444
   (gdb) cont
   Continuing.

   Program exited normally.

Going back to the terminal where GDBserver is running, we see the following
output:

    Child exited with status 0
    readchar: Got EOF
    Remote side has terminated connection.  GDBserver will reopen the connection.
    Listening on port 4444

The problem is that we're missing a call to mourn_inferior.  As a result,
after we've handled the vCont packet, we fail to notice that there are
no process left to debug (target_running() returns true), and thus try
to continue reading from the remote socket.  However, since GDB just
disconnected after having received the "exit with status 0" reply to the
vCont request, the read triggers the EOF exception.

gdb/gdbserver/ChangeLog:

        * server.c (handle_v_cont): Call mourn_inferior if process
        just exited.
        (myresume): Likewise.
@
text
@d1542 1
a1542 1
	  sprintf (own_buf, "%llx", address);
d1566 1
a1566 1
	  sprintf (own_buf, "%llx", tlb);
@


1.125.2.1
log
@Merge recent win64 breakage fixes from HEAD to 7.2 branch:

gdb/

	* target.c (debug_to_insert_breakpoint): Instead of casting to unsigned
	long and %ld, use core_addr_to_string() and %s to print CORE_ADDR vars
	and host_address_to_string() and %s for pointers.
	(debug_to_remove_breakpoint): Likewise.
	(debug_to_region_ok_for_hw_watchpoint): Likewise.
	(debug_to_can_accel_watchpoint_condition): Likewise.
	(debug_to_stopped_data_address): Likewise.
	(debug_to_watchpoint_addr_within_range): Likewise.
	(debug_to_insert_hw_breakpoint): Likewise.
	(debug_to_remove_hw_breakpoint): Likewise.
	(debug_to_insert_watchpoint): Likewise.
	(debug_to_remove_watchpoint): Likewise.

gdb/gdbserver/

	* server.c (handle_query): strcpy() the returned string from paddress()
	instead of sprintf().
	* utils.c (paddress): Return phex_nz().
@
text
@d1542 1
a1542 1
	  strcpy (own_buf, paddress(address));
d1566 1
a1566 1
	  strcpy (own_buf, paddress(tlb));
@


1.124
log
@Make server.c:myresume static.

I just happened to notice that this function was exclusively used in
server.c, and thus could be made static.

2010-07-06  Joel Brobecker  <brobecker@@adacore.com>

        * server.c (myresume): Make static.
@
text
@d1782 4
d2086 4
@


1.123
log
@	Static tracepoints support, and UST integration.

	gdb/gdbserver/
	* configure.ac: Handle --with-ust.  substitute ustlibs and ustinc.
	* mem-break.c (uninsert_all_breakpoints)
	(reinsert_all_breakpoints): New.
	* mem-break.h (reinsert_all_breakpoints, uninsert_all_breakpoints):
	* tracepoint.c (ust_loaded, helper_thread_id, cmd_buf): New.
	(gdb_agent_ust_loaded, helper_thread_id)
	(gdb_agent_helper_thread_id): New macros.
	(struct ipa_sym_addresses): Add addr_ust_loaded,
	addr_helper_thread_id, addr_cmd_buf.
	(symbol_list): Add ust_loaded, helper_thread_id, cmd_buf.
	(in_process_agent_loaded_ust): New.
	(write_e_ust_not_loaded): New.
	(maybe_write_ipa_ust_not_loaded): New.
	(struct collect_static_trace_data_action): New.
	(enum tracepoint_type) <static_tracepoint>: New.
	(struct tracepoint) <handle>: Mention static tracepoints.
	(struct static_tracepoint_ctx): New.
	(CMD_BUF_SIZE): New.
	(add_tracepoint_action): Handle static tracepoint actions.
	(unprobe_marker_at): New.
	(clear_installed_tracepoints): Handle static tracepoints.
	(cmd_qtdp): Handle static tracepoints.
	(probe_marker_at): New.
	(cmd_qtstart): Handle static tracepoints.
	(response_tracepoint): Handle static tracepoints.
	(cmd_qtfstm, cmd_qtsstm, cmd_qtstmat): New.
	(handle_tracepoint_query): Handle qTfSTM, qTsSTM and qTSTMat.
	(get_context_regcache): Handle static tracepoints.
	(do_action_at_tracepoint): Handle static tracepoint actions.
	(traceframe_find_block_type): Handle static trace data blocks.
	(traceframe_read_sdata): New.
	(download_tracepoints): Download static tracepoint actions.
	[HAVE_UST] Include ust/ust.h, dlfcn.h, sys/socket.h, and sys/un.h.
	(GDB_PROBE_NAME): New.
	(ust_ops): New.
	(GET_UST_SYM): New.
	(USTF): New.
	(dlsym_ust): New.
	(ust_marker_to_static_tracepoint): New.
	(gdb_probe): New.
	(collect_ust_data_at_tracepoint): New.
	(gdb_ust_probe): New.
	(UNIX_PATH_MAX, SOCK_DIR): New.
	(gdb_ust_connect_sync_socket): New.
	(resume_thread, stop_thread): New.
	(run_inferior_command): New.
	(init_named_socket): New.
	(gdb_ust_socket_init): New.
	(cstr_to_hexstr): New.
	(next_st): New.
	(first_marker, next_marker): New.
	(response_ust_marker): New.
	(cmd_qtfstm, cmd_qtsstm): New.
	(unprobe_marker_at, probe_marker_at): New.
	(cmd_qtstmat, gdb_ust_thread): New.
	(gdb_ust_init): New.
	(initialize_tracepoint_ftlib): Call gdb_ust_init.
	* linux-amd64-ipa.c [HAVE_UST]: Include ust/processor.h
	(ST_REGENTRY): New.
	(x86_64_st_collect_regmap): New.
	(X86_64_NUM_ST_COLLECT_GREGS): New.
	(AMD64_RIP_REGNUM): New.
	(supply_static_tracepoint_registers): New.
	* linux-i386-ipa.c [HAVE_UST]: Include ust/processor.h
	(ST_REGENTRY): New.
	(i386_st_collect_regmap): New.
	(i386_NUM_ST_COLLECT_GREGS): New.
	(supply_static_tracepoint_registers): New.
	* server.c (handle_query): Handle qXfer:statictrace:read.
	<qSupported>: Report support for StaticTracepoints, and
	qXfer:statictrace:read features.
	* server.h (traceframe_read_sdata)
	(supply_static_tracepoint_registers): Declare.
	* remote-utils.c (convert_int_to_ascii, hexchars, ishex, tohex)
	(unpack_varlen_hex): Include in IPA build.
	* Makefile.in (ustlibs, ustinc): New.
	(IPA_OBJS): Add remote-utils-ipa.o.
	($(IPA_LIB)): Link -ldl and -lpthread.
	(UST_CFLAGS): New.
	(IPAGENT_CFLAGS): Add UST_CFLAGS.
	* config.in, configure: Regenerate.

	gdb/
	* NEWS: Mention new support for static tracepoints.
	(New packets): Mention qTfSTM, qTsSTM, qTSTMat and
	qXfer:statictrace:read.
	(New features in the GDB remote stub, GDBserver): Mention static
	tracepoints support using an UST based backend.
	(New commands): Mention "info static-tracepoint-markers" and
	"strace".
	* breakpoint.c (is_marker_spec): New.
	(is_tracepoint): Handle static tracepoints.
	(validate_commands_for_breakpoint): Static tracepoints can't do
	while-stepping.
	(static_tracepoints_here): New.
	(bpstat_what): Handle static tracepoints.
	(print_one_breakpoint_location, allocate_bp_location, mention):
	Ditto.
	(create_breakpoint_sal): Ditto.
	(decode_static_tracepoint_spec): New.
	(create_breakpoint): Replace `hardwareflag', and `traceflag' with
	`type_wanted'.  Adjust.  Handle static tracepoint marker
	locations.
	(break_command_1): Adjust.
	(update_static_tracepoint): New.
	(update_breakpoint_locations): Handle static tracepoints.
	(breakpoint_re_set_one): Handle static tracepoint marker
	locations.
	(disable_command, enable_command): Handle static tracepoints.
	(trace_command, ftrace_command): Adjust.
	(strace_command): New.
	(create_tracepoint_from_upload): Adjust.
	(save_breakpoints): Handle static tracepoints.
	(_initialize_breakpoint): Install the "strace" command.
	* breakpoint.h (enum bptype): New bp_static_tracepoint type.
	(struct breakpoint): New fields static_trace_marker_id and
	static_trace_marker_id_idx.
	(breakpoints_here_p): Declare.
	(create_breakpoint): Adjust.
	(static_tracepoints_here): Declare.
	* remote.c (struct remote_state) <static_tracepoints>: New field.
	(PACKET_qXfer_statictrace_read, PACKET_StaticTracepoints): New.
	(remote_static_tracepoint_marker_at): New.
	(remote_static_tracepoint_markers_by_strid): New.
	(remote_static_tracepoint_feature): New.
	(remote_disconnected_tracing_feature): Handle "StaticTracepoints".
	(remote_xfer_partial): Handle TARGET_OBJECT_STATIC_TRACE_DATA.
	(remote_supports_static_tracepoints): New.
	(remote_download_tracepoint): Download static tracepoints.
	(init_remote_ops): Install remote_static_tracepoint_marker_at and
	remote_static_tracepoint_markers_by_strid.
	(_initialize_remote): Install set|show remote static-tracepoints,
	and set|show remote read-sdata-object commands.
	* target.c (update_current_target): Inherit and default
	to_static_tracepoint_marker_at, and
	to_static_tracepoint_markers_by_strid.
	* target.h (static_tracepoint_marker): Forward declare.
	(enum target_object): New object TARGET_OBJECT_STATIC_TRACE_DATA.
	(static_tracepoint_marker_p): New typedef.
	(DEF_VEC_P(static_tracepoint_marker_p)): New VEC type.
	(struct target_ops): New fields to_static_tracepoint_marker_at and
	to_static_tracepoint_markers_by_strid.
	(target_static_tracepoint_marker_at)
	(target_static_tracepoint_markers_by_strid): New.
	* tracepoint.c: Include source.h.
	(validate_actionline): Handle $_sdata.
	(struct collection_list): New field strace_data.
	(add_static_trace_data): New.
	(clear_collection_list): Clear strace_data.
	(stringify_collection_list): Account for a possible static trace
	data collection.
	(encode_actions_1): Encode an $_sdata collection.
	(parse_tracepoint_definition): Handle static tracepoints.
	(parse_static_tracepoint_marker_definition): New.
	(release_static_tracepoint_marker): New.
	(print_one_static_tracepoint_marker): New.
	(info_static_tracepoint_markers_command): New.
	(sdata_make_value): New.
	(_initialize_tracepoint): Create the $_sdata convenience variable.
	Add the "info static-tracepoint-markers" command.
	Mention $_sdata in the "collect" command's help output.
	* tracepoint.h (struct static_tracepoint_marker): New.
	(parse_static_tracepoint_marker_definition)
	(release_static_tracepoint_marker): Declare.
	* mi/mi-cmd-break.c (mi_cmd_break_insert): Adjust.
	* python/py-breakpoint.c (bppy_new): Adjust.

	doc/
	* gdb.texinfo (Convenience Variables): Document $_sdata.
	(Commands to Set Tracepoints): Describe static tracepoints.  Add
	`Listing Static Tracepoint Markers' menu entry.  Document
	"strace".
	(Tracepoint Action Lists): Document collecting $_sdata.
	(Listing Static Tracepoint Markers): New subsection.
	(Tracepoints support in gdbserver): Mention static tracepoints.
	(remote packets, enabling and disabling): Mention
	read-sdata-object.
	(General Query Packets) <qSupported>: Document qXfer:sdata:read
	and StaticTracepoint.
	Mention qTfSTM, qTsSTM and qTSTMat as tracepoint packets.
	Document qXfer:sdata:read.
	(Tracepoint packets): Document qTfSTM, qTsSTM and qTSTMat.
@
text
@d2038 1
a2038 1
void
@


1.122
log
@gdb/gdbserver/
2010-06-01  Pedro Alves  <pedro@@codesourcery.com>
	    Stan Shebs  <stan@@codesourcery.com>

	* Makefile.in (IPA_DEPFILES, extra_libraries): New.
	(all): Depend on $(extra_libraries).
	(install-only): Install the IPA.
	(IPA_OBJS, IPA_LIB): New.
	(clean): Remove the IPA lib.
	(IPAGENT_CFLAGS): New.
	(tracepoint-ipa.o, utils-ipa.o, remote-utils-ipa.o)
	(regcache-ipa.o, i386-linux-ipa.o, linux-i386-ipa.o)
	(linux-amd64-ipa.o, amd64-linux-ipa.o): New rules.
	* linux-amd64-ipa.c, linux-i386-ipa.c: New files.
	* configure.ac: Check for atomic builtins support in the compiler.
	(IPA_DEPFILES, extra_libraries): Define.
	* configure.srv (ipa_obj): Add description.
	(ipa_i386_linux_regobj, ipa_amd64_linux_regobj): Define.
	(i[34567]86-*-linux*): Set ipa_obj.
	(x86_64-*-linux*): Set ipa_obj.
	* linux-low.c (stabilizing_threads): New.
	(supports_fast_tracepoints): New.
	(linux_detach): Stabilize threads before detaching.
	(handle_tracepoints): Handle internal tracing breakpoints.  Assert
	the lwp is either not stabilizing, or is moving out of a jump pad.
	(linux_fast_tracepoint_collecting): New.
	(maybe_move_out_of_jump_pad): New.
	(enqueue_one_deferred_signal): New.
	(dequeue_one_deferred_signal): New.
	(linux_wait_for_event_1): If moving out of a jump pad, defer
	pending signals to later.
	(linux_stabilize_threads): New.
	(linux_wait_1): Check if threads need moving out of jump pads, and
	do it if so.
	(stuck_in_jump_pad_callback): New.
	(move_out_of_jump_pad_callback): New.
	(lwp_running): New.
	(linux_resume_one_lwp): Handle moving out of jump pads.
	(linux_set_resume_request): Dequeue deferred signals.
	(need_step_over_p): Also step over fast tracepoint jumps.
	(start_step_over): Also uninsert fast tracepoint jumps.
	(finish_step_over): Also reinsert fast tracepoint jumps.
	(linux_install_fast_tracepoint_jump): New.
	(linux_target_ops): Install linux_stabilize_threads and
	linux_install_fast_tracepoint_jump_pad.
	* linux-low.h (linux_target_ops) <get_thread_area,
	install_fast_tracepoint_jump_pad>: New fields.
	(struct lwp_info) <collecting_fast_tracepoint,
	pending_signals_to_report, exit_jump_pad_bkpt>: New fields.
	(linux_get_thread_area): Declare.
	* linux-x86-low.c (jump_insn): New.
	(x86_get_thread_area): New.
	(append_insns): New.
	(push_opcode): New.
	(amd64_install_fast_tracepoint_jump_pad): New.
	(i386_install_fast_tracepoint_jump_pad): New.
	(x86_install_fast_tracepoint_jump_pad): New.
	(the_low_target): Install x86_get_thread_area and
	x86_install_fast_tracepoint_jump_pad.
	* mem-break.c (set_raw_breakpoint_at): Use read_inferior_memory.
	(struct fast_tracepoint_jump): New.
	(fast_tracepoint_jump_insn): New.
	(fast_tracepoint_jump_shadow): New.
	(find_fast_tracepoint_jump_at): New.
	(fast_tracepoint_jump_here): New.
	(delete_fast_tracepoint_jump): New.
	(set_fast_tracepoint_jump): New.
	(uninsert_fast_tracepoint_jumps_at): New.
	(reinsert_fast_tracepoint_jumps_at): New.
	(set_breakpoint_at): Use write_inferior_memory.
	(uninsert_raw_breakpoint): Use write_inferior_memory.
	(check_mem_read): Mask out fast tracepoint jumps.
	(check_mem_write): Mask out fast tracepoint jumps.
	* mem-break.h (struct fast_tracepoint_jump): Forward declare.
	(set_fast_tracepoint_jump): Declare.
	(delete_fast_tracepoint_jump)
	(fast_tracepoint_jump_here, uninsert_fast_tracepoint_jumps_at)
	(reinsert_fast_tracepoint_jumps_at): Declare.
	* regcache.c: Don't compile many functions when building the
	in-process agent library.
	(init_register_cache) [IN_PROCESS_AGENT]: Don't allow allocating
	the register buffer in the heap.
	(free_register_cache): If the register buffer isn't owned by the
	regcache, don't free it.
	(set_register_cache) [IN_PROCESS_AGENT]: Don't re-alocate
	pre-existing register caches.
	* remote-utils.c (convert_int_to_ascii): Constify `from' parameter
	type.
	(convert_ascii_to_int): : Constify `from' parameter type.
	(decode_M_packet, decode_X_packet): Replace the `to' parameter by
	a `to_p' pointer to pointer parameter.  If TO_P is NULL, malloc
	the needed buffer in-place.
	(relocate_instruction): New.
	* server.c (handle_query) <qSymbols>: If the target supports
	tracepoints, give it a chance of looking up symbols.  Report
	support for fast tracepoints.
	(handle_status): Stabilize threads.
	(process_serial_event): Adjust.
	* server.h (struct fast_tracepoint_jump): Forward declare.
	(struct process_info) <fast_tracepoint_jumps>: New field.
	(convert_ascii_to_int, convert_int_to_ascii): Adjust.
	(decode_X_packet, decode_M_packet): Adjust.
	(relocate_instruction): Declare.
	(in_process_agent_loaded): Declare.
	(tracepoint_look_up_symbols): Declare.
	(struct fast_tpoint_collect_status): Declare.
	(fast_tracepoint_collecting): Declare.
	(force_unlock_trace_buffer): Declare.
	(handle_tracepoint_bkpts): Declare.
	(initialize_low_tracepoint)
	(supply_fast_tracepoint_registers) [IN_PROCESS_AGENT]: Declare.
	* target.h (struct target_ops) <stabilize_threads,
	install_fast_tracepoint_jump_pad>: New fields.
	(stabilize_threads, install_fast_tracepoint_jump_pad): New.
	* tracepoint.c [HAVE_MALLOC_H]: Include malloc.h.
	[HAVE_STDINT_H]: Include stdint.h.
	(trace_debug_1): Rename to ...
	(trace_vdebug): ... this.
	(trace_debug): Rename to ...
	(trace_debug_1): ... this.  Add `level' parameter.
	(trace_debug): New.
	(ATTR_USED, ATTR_NOINLINE): New.
	(IP_AGENT_EXPORT): New.
	(gdb_tp_heap_buffer, gdb_jump_pad_buffer, gdb_jump_pad_buffer_end)
	(collecting, gdb_collect, stop_tracing, flush_trace_buffer)
	(about_to_request_buffer_space, trace_buffer_is_full)
	(stopping_tracepoint, expr_eval_result, error_tracepoint)
	(tracepoints, tracing, trace_buffer_ctrl, trace_buffer_ctrl_curr)
	(trace_buffer_lo, trace_buffer_hi, traceframe_read_count)
	(traceframe_write_count, traceframes_created)
	(trace_state_variables)
	New renaming defines.
	(struct ipa_sym_addresses): New.
	(STRINGIZE_1, STRINGIZE, IPA_SYM): New.
	(symbol_list): New.
	(ipa_sym_addrs): New.
	(all_tracepoint_symbols_looked_up): New.
	(in_process_agent_loaded): New.
	(write_e_ipa_not_loaded): New.
	(maybe_write_ipa_not_loaded): New.
	(tracepoint_look_up_symbols): New.
	(debug_threads) [IN_PROCESS_AGENT]: New.
	(read_inferior_memory) [IN_PROCESS_AGENT]: New.
	(UNKNOWN_SIDE_EFFECTS): New.
	(stop_tracing): New.
	(flush_trace_buffer): New.
	(stop_tracing_bkpt): New.
	(flush_trace_buffer_bkpt): New.
	(read_inferior_integer): New.
	(read_inferior_uinteger): New.
	(read_inferior_data_pointer): New.
	(write_inferior_data_pointer): New.
	(write_inferior_integer): New.
	(write_inferior_uinteger): New.
	(struct collect_static_trace_data_action): Delete.
	(enum tracepoint_type): New.
	(struct tracepoint) <type>: New field `type'.
	<actions_str, step_actions, step_actions_str>: Only include in GDBserver.
	<orig_size, obj_addr_on_target, adjusted_insn_addr>
	<adjusted_insn_addr_end, jump_pad, jump_pad_end>: New fields.
	(tracepoints): Use IP_AGENT_EXPORT.
	(last_tracepoint): Don't include in the IPA.
	(stopping_tracepoint): Use IP_AGENT_EXPORT.
	(trace_buffer_is_full): Use IP_AGENT_EXPORT.
	(alloced_trace_state_variables): New.
	(trace_state_variables): Use IP_AGENT_EXPORT.
	(traceframe_t): Delete unused variable.
	(circular_trace_buffer): Don't include in the IPA.
	(trace_buffer_start): Delete.
	(struct trace_buffer_control): New.
	(trace_buffer_free): Delete.
	(struct ipa_trace_buffer_control): New.
	(GDBSERVER_FLUSH_COUNT_MASK, GDBSERVER_FLUSH_COUNT_MASK_PREV)
	(GDBSERVER_FLUSH_COUNT_MASK_CURR, GDBSERVER_UPDATED_FLUSH_COUNT_BIT):
	New.
	(trace_buffer_ctrl): New.
	(TRACE_BUFFER_CTRL_CURR): New.
	(trace_buffer_start, trace_buffer_free, trace_buffer_end_free):
	Reimplement as macros.
	(trace_buffer_wrap): Delete.
	(traceframe_write_count, traceframe_read_count)
	(traceframes_created, tracing): Use IP_AGENT_EXPORT.
	(struct tracepoint_hit_ctx) <type>: New field.
	(struct fast_tracepoint_ctx): New.
	(memory_barrier): New.
	(cmpxchg): New.
	(record_tracepoint_error): Update atomically in the IPA.
	(clear_inferior_trace_buffer): New.
	(about_to_request_buffer_space): New.
	(trace_buffer_alloc): Handle GDBserver and inferior simulatenous
	updating the same buffer.
	(add_tracepoint): Default the tracepoint's type to trap
	tracepoint, and orig_size to -1.
	(get_trace_state_variable) [IN_PROCESS_AGENT]: Handle allocated
	internal variables.
	(create_trace_state_variable): New parameter `gdb'.  Handle it.
	(clear_installed_tracepoints): Clear fast tracepoint jumps.
	(cmd_qtdp): Handle fast tracepoints.
	(cmd_qtdv): Adjust.
	(max_jump_pad_size): New.
	(gdb_jump_pad_head): New.
	(get_jump_space_head): New.
	(claim_jump_space): New.
	(sort_tracepoints): New.
	(MAX_JUMP_SIZE): New.
	(cmd_qtstart): Handle fast tracepoints.  Sync tracepoints with the
	IPA.
	(stop_tracing) [IN_PROCESS_AGENT]: Don't include the tdisconnected
	support.  Upload fast traceframes, and delete internal IPA
	breakpoints.
	(stop_tracing_handler): New.
	(flush_trace_buffer_handler): New.
	(cmd_qtstop): Upload fast tracepoints.
	(response_tracepoint): Handle fast tracepoints.
	(tracepoint_finished_step): Upload fast traceframes.  Set the
	tracepoint hit context's tracepoint type.
	(handle_tracepoint_bkpts): New.
	(tracepoint_was_hit): Set the tracepoint hit context's tracepoint
	type.  Add comment about fast tracepoints.
	(collect_data_at_tracepoint) [IN_PROCESS_AGENT]: Don't access the
	non-existing action_str field.
	(get_context_regcache): Handle fast tracepoints.
	(do_action_at_tracepoint) [!IN_PROCESS_AGENT]: Don't write the PC
	to the regcache.
	(fast_tracepoint_from_jump_pad_address): New.
	(fast_tracepoint_from_ipa_tpoint_address): New.
	(collecting_t): New.
	(force_unlock_trace_buffer): New.
	(fast_tracepoint_collecting): New.
	(collecting): New.
	(gdb_collect): New.
	(write_inferior_data_ptr): New.
	(target_tp_heap): New.
	(target_malloc): New.
	(download_agent_expr): New.
	(UALIGN): New.
	(download_tracepoints): New.
	(download_trace_state_variables): New.
	(upload_fast_traceframes): New.
	(IPA_FIRST_TRACEFRAME): New.
	(IPA_NEXT_TRACEFRAME_1): New.
	(IPA_NEXT_TRACEFRAME): New.
	[IN_PROCESS_AGENT]: Include sys/mman.h and fcntl.h.
	[IN_PROCESS_AGENT] (gdb_tp_heap_buffer, gdb_jump_pad_buffer)
	(gdb_jump_pad_buffer_end): New.
	[IN_PROCESS_AGENT] (initialize_tracepoint_ftlib): New.
	(initialize_tracepoint): Adjust.
	[IN_PROCESS_AGENT]: Allocate the IPA heap, and jump pad scratch
	buffer.  Initialize the low module.
	* utils.c (PREFIX, TOOLNAME): New.
	(malloc_failure): Use PREFIX.
	(error): In the IPA, an error causes an exit.
	(fatal, warning): Use PREFIX.
	(internal_error): Use TOOLNAME.
	(NUMCELLS): Increase to 10.
	* configure, config.in: Regenerate.

gdb/
2010-06-01  Pedro Alves  <pedro@@codesourcery.com>

	* NEWS: Mention gdbserver fast tracepoints support.

gdb/doc/
2010-06-01  Pedro Alves  <pedro@@codesourcery.com>

	* gdb.texinfo (Set Tracepoints): Mention tracepoints support in
	gdbserver, and add cross reference.
	(Tracepoints support in gdbserver): New subsection.
@
text
@d1339 46
d1482 2
@


1.121
log
@	* server.c (handle_query) <qSupported>: Do two passes over the
	qSupported string to avoid nesting strtok.
@
text
@d923 3
d1344 1
d1379 5
d1434 2
d2136 1
d2836 1
a2836 1
      decode_M_packet (&own_buf[1], &mem_addr, &len, mem_buf);
d2845 1
a2845 1
			   &mem_addr, &len, mem_buf) < 0
@


1.120
log
@	* linux-low.c (linux_kill, linux_detach): Adjust.
	(status_pending_p_callback): Remove redundant statement.  Check
	for !TARGET_WAITIKIND_IGNORE, instead of
	TARGET_WAITKIND_STOPPED.
	(handle_tracepoints): Make sure LWP is locked.  Adjust.
	(linux_wait_for_event_1): Adjust.
	(linux_cancel_breakpoints): New.
	(unsuspend_one_lwp): New.
	(unsuspend_all_lwps): New.
	(linux_wait_1): If finishing a step-over, unsuspend all lwps.
	(send_sigstop_callback): Change return type to int, add new
	`except' parameter and handle it.
	(suspend_and_send_sigstop_callback): New.
	(stop_all_lwps): Add new `suspend' and `expect' parameters, and
	pass them down.  If SUSPEND, also increment the lwp's suspend
	count.
	(linux_resume_one_lwp): Add notice about resuming a suspended LWP.
	(need_step_over_p): Don't consider suspended LWPs.
	(start_step_over): Adjust.
	(proceed_one_lwp): Change return type to int, add new `except'
	parameter and handle it.
	(unsuspend_and_proceed_one_lwp): New.
	(proceed_all_lwps): Use find_inferior instead of
	for_each_inferior.
	(unstop_all_lwps): Add `unsuspend' parameter.  If UNSUSPEND, them
	also decrement the suspend count of LWPs.  Pass `except' down,
	instead of hacking its suspend count.
	(linux_pause_all): Add `freeze' parameter.  Adjust.
	(linux_unpause_all): New.
	(linux_target_ops): Install linux_unpause_all.
	* server.c (handle_status): Adjust.
	* target.h (struct target_ops): New fields `unpause_all' and
	`cancel_breakpoints'.  Add new parameter to `pause_all'.
	(pause_all): Add new `freeze' parameter.
	(unpause_all): New.
	(cancel_breakpoints): New.
	* tracepoint.c (clear_installed_tracepoints): Pause threads, and
	cancel breakpoints.
	(cmd_qtstart): Pause threads.
	(stop_tracing): Pause threads, and cancel breakpoints.
	* win32-low.c (win32_target_ops): Adjust.
@
text
@d1349 34
a1382 14
	for (p = strtok (p + 1, ";");
	     p != NULL;
	     p = strtok (NULL, ";"))
	  {
	    if (strcmp (p, "multiprocess+") == 0)
	      {
		/* GDB supports and wants multi-process support if
		   possible.  */
		if (target_supports_multi_process ())
		  multi_process = 1;
	      }
	    else
	      target_process_qsupported (p);
	  }
@


1.119
log
@	* linux-low.c (linux_kill_one_lwp): Assume the lwp is stopped.
	(linux_kill): Stop all lwps here.  Don't delete the main lwp here.
	(linux_detach_one_lwp): Assume the lwp is stopped.
	(any_thread_of): Delete.
	(linux_detach): Stop all lwps here.  Don't blindly delete all
	breakpoints.
	(delete_lwp_callback): New.
	(linux_mourn): Delete all lwps of the process that is gone.
	(linux_wait_1): Don't delete the last lwp of the process here.
	* mem-break.h (mark_breakpoints_out): Declare.
	* mem-break.c (mark_breakpoints_out): New.
	(free_all_breakpoints): Use it.
	* server.c (handle_target_event): If the process is gone, mark
	breakpoints out.
	* thread-db.c (struct thread_db) <create_bp>: New field.
	(thread_db_enable_reporting): Fix prototype.  Store a thread event
	breakpoint reference in the thread_db struct.
	(thread_db_load_search): Clear the thread_db object.
	(try_thread_db_load_1): Ditto.
	(switch_to_process): New.
	(disable_thread_event_reporting): Use it.
	(remove_thread_event_breakpoints): New.
	(thread_db_detach, thread_db_mourn): Use it.
@
text
@d2104 1
a2104 1
      pause_all ();
@


1.118
log
@	* server.c (handle_general_set): Make static.
@
text
@d3034 4
a3037 1
	mourn_inferior (process);
@


1.117
log
@	* server.c (start_inferior): Print inferior argv if --debug.
@
text
@d382 2
a383 1
void
@


1.116
log
@
	Support for Windows OS Thread Information Block.
	* NEWS: Document new feature.
	* remote.c (PACKET_qGetTIBAddr): New enum element.
	(remote_get_tib_address): New function.
	(init_remote_ops): Set to_get_tib_address field
	to remote_get_tib_address.
	(_initialize_remote): Add add_packet_config_cmd
	for PACKET_qGetTIBAddr.
	* target.c (update_current_target): Set default value for
	new to_get_tib_address field.
	* target.h (target_ops): New field to_get_tib_address.
	(target_get_tib_address): New macro.
	* windows-nat.c (thread_info): Add thread_local_base field.
	(windows_add_thread): Add tlb argument of type 'void *'.
	(fake_create_process): Adapt windows_add_thread call.
	(get_windows_debug_event): Idem.
	(windows_get_tib_address): New function.
	(init_windows_ops): Set to_get_tib_address field
	to remote_get_tib_address.
	(_initialize_windows_nat): Replace info_w32_cmdlist
	initialization by a call to init_w32_command_list.
	(info_w32_command, info_w32_cmdlist): Removed from here...
	to windows-tdep.c file.
	* windows-tdep.h (info_w32_cmdlist): Declare.
	(init_w32_command_list): New external function
	declaration.
	* windows-tdep.c: Add several headers.
	(info_w32_cmdlist): to here, made global.
	(thread_information_32): New struct.
	(thread_information_64): New struct.
	(TIB_NAME): New char array.
	(MAX_TIB32, MAX_TIB64, FULL_TIB_SIZE): New constants.
	(maint_display_all_tib): New static variable.
	(windows_get_tlb_type): New function.
	(tlb_value_read, tlb_value_write): New functions.
	(tlb_value_funcs): New static struct.
	(tlb_make_value): New function.
	(display_one_tib): New function.
	(display_tib): New function.
	(show_maint_show_all_tib):New function.
	(info_w32_command): Moved from windows-nat.c.
	(init_w32_command_list): New function.
	(_initialize_windows_tdep): New function.
	New "maint set/show show-all-tib" command
	New "$_tlb" internal variable.

gdbserver/ChangeLog entry:

	* server.c (handle_query): Handle 'qGetTIBAddr' query.
	* target.h (target_ops): New get_tib_address field.
	* win32-low.h (win32_thread_info): Add thread_local_base field.
	* win32-low.c (child_add_thread): Add tlb argument.
	Set thread_local_base field to TLB.
	(get_child_debug_event): Adapt to child_add_thread change.
	(win32_get_tib_address): New function.
	(win32_target_ops): Set get_tib_address field to
	win32_get_tib_address.
	* linux-low.c (linux_target_ops): Set get_tib_address field to NULL.

doc/ChangeLog entry:

	gdb.texinfo ($_tlb): Document new automatic convinience variable.
	(info w32 thread-information-block): Document new command.
	(qGetTIBAddress): Document new gdbserver query.
	(maint set/show show-all-tib): Document new command.
@
text
@d244 8
@


1.115
log
@	gdb/gdbserver/
	* linux-low.c (linux_mourn): Also remove the process.
	* server.c (handle_target_event): Don't remove the process here.
	* nto-low.c (nto_mourn): New.
	(nto_target_ops): Install it.
	* spu-low.c (spu_mourn): New.
	(spu_target_ops): Install it.
	* win32-low.c (win32_mourn): New.
	(win32_target_ops): Install it.
@
text
@d1466 23
@


1.114
log
@	GDBserver disconnected tracing support.

	* linux-low.c (linux_remove_process): Delete.
	(add_lwp): Don't set last_resume_kind here.
	(linux_kill): Use `mourn'.
	(linux_detach): Use `thread_db_detach', and `mourn'.
	(linux_mourn): New.
	(linux_attach_lwp_1): Adjust comment.
	(linux_attach): last_resume_kind moved the thread_info; adjust.
	(status_pending_p_callback): Adjust.
	(linux_wait_for_event_1): Adjust.
	(count_events_callback, select_singlestep_lwp_callback)
	(select_event_lwp_callback, cancel_breakpoints_callback)
	(db_wants_lwp_stopped, linux_wait_1, need_step_over_p)
	(proceed_one_lwp): Adjust.
	(linux_async): Add debug output.
	(linux_thread_stopped): New.
	(linux_pause_all): New.
	(linux_target_ops): Install linux_mourn, linux_thread_stopped and
	linux_pause_all.
	* linux-low.h (struct lwp_info): Delete last_resume_kind field.
	(thread_db_free): Delete declaration.
	(thread_db_detach, thread_db_mourn): Declare.
	* thread-db.c (thread_db_init): Use thread_db_mourn.
	(thread_db_free): Delete, split in two.
	(disable_thread_event_reporting): New.
	(thread_db_detach): New.
	(thread_db_mourn): New.

	* server.h (struct thread_info) <last_resume_kind>: New field.
	<attached>: Add comment.
	<gdb_detached>: New field.
	(handler_func): Change return type to int.
	(handle_serial_event, handle_target_event): Ditto.
	(gdb_connected): Declare.
	(tracing): Delete.
	(disconnected_tracing): Declare.
	(stop_tracing): Declare.

	* server.c (handle_query) <qSupported>: Report support for
	disconnected tracing.
	(queue_stop_reply_callback): Account for running threads.
	(gdb_wants_thread_stopped): New.
	(gdb_wants_all_threads_stopped): New.
	(gdb_reattached_process): New.
	(handle_status): Clear the `gdb_detached' flag of all processes.
	In all-stop, stop all threads.
	(main): Be sure to leave tfind mode.  Handle disconnected tracing.
	(process_serial_event): If the remote connection breaks, or if an
	exit was forced with "monitor exit", force an event loop exit.
	Handle disconnected tracing on detach.
	(handle_serial_event): Adjust.
	(handle_target_event): If GDB isn't connected, forward events back
	to the inferior, unless the last process exited, in which case,
	exit gdbserver.  Adjust interface.

	* remote-utils.c (remote_open): Don't block in accept.  Instead
	register an event loop source on the listen socket file
	descriptor.  Refactor bits into ...
	(listen_desc): ... this new global.
	(gdb_connected): ... this new function.
	(enable_async_notification): ... this new function.
	(handle_accept_event): ... this new function.
	(remote_close): Clear remote_desc.

	* inferiors.c (add_thread): Set the new thread's last_resume_kind.

	* target.h (struct target_ops) <mourn, thread_stopped, pause_all>:
	New fields.
	(mourn_inferior): Define.
	(target_process_qsupported): Avoid the dangling else problem.
	(thread_stopped): Define.
	(pause_all): Define.
	(target_waitstatus_to_string): Declare.
	* target.c (target_waitstatus_to_string): New.

	* tracepoint.c (tracing): Make extern.
	(disconnected_tracing): New.
	(stop_tracing): Make extern.  Handle tracing stops due to GDB
	disconnecting.
	(cmd_qtdisconnected): New.
	(cmd_qtstatus): Report disconnected tracing status in trace reply.
	(handle_tracepoint_general_set): Handle QTDisconnected.

	* event-loop.c (event_handler_func): Change return type to int.
	(process_event): Bail out if the event handler wants the event
	loop to stop.
	(handle_file_event): Ditto.
	(start_event_loop): Bail out if the event handler wants the event
	loop to stop.

	* nto-low.c (nto_target_ops): Adjust.
	* spu-low.c (spu_wait): Don't remove the process here.
	(spu_target_ops): Adjust.
	* win32-low.c (win32_wait): Don't remove the process here.
	(win32_target_ops): Adjust.
@
text
@d3002 1
a3002 4
	{
	  mourn_inferior (process);
	  remove_process (process);
	}
@


1.113
log
@	gdb/gdbserver/
	* server.h (LONGEST): New.
	(struct thread_info) <while_stepping>: New field.
	(unpack_varlen_hex, xrealloc, pulongest, plongest, phex_nz):
	Declare.
	(initialize_tracepoint, handle_tracepoint_general_set)
	(handle_tracepoint_query, tracepoint_finished_step)
	(tracepoint_was_hit, release_while_stepping_state_list):
	(current_traceframe): Declare.
	* server.c (handle_general_set): Handle tracepoint packets.
	(read_memory): New.
	(write_memory): New.
	(handle_search_memory_1): Use read_memory.
	(handle_query): Report support for conditional tracepoints, trace
	state variables, and tracepoint sources.  Handle tracepoint
	queries.
	(main): Initialize the tracepoints module.
	(process_serial_event): Handle traceframe reads/writes.

	* linux-low.c (handle_tracepoints): New.
	(linux_wait_1): Call it.
	(linux_resume_one_lwp): Handle while-stepping.
	(linux_supports_tracepoints, linux_read_pc, linux_write_pc): New.
	(linux_target_ops): Install them.
	* linux-low.h (struct linux_target_ops) <supports_tracepoints>:
	New field.
	* linux-x86-low.c (x86_supports_tracepoints): New.
	(the_low_target). Install it.

	* mem-break.h (delete_breakpoint): Declare.
	* mem-break.c (delete_breakpoint): Make external.

	* target.h (struct target_ops): Add `supports_tracepoints',
	`read_pc', and `write_pc' fields.
	(target_supports_tracepoints): Define.
	* utils.c (xrealloc, decimal2str, pulongest, plongest, thirty_two)
	(phex_nz): New.

	* regcache.h (struct regcache) <registers_owned>: New field.
	(init_register_cache, regcache_cpy): Declare.
	(regcache_read_pc, regcache_write_pc): Declare.
	(register_cache_size): Declare.
	(supply_regblock): Declare.
	* regcache.c (init_register_cache): New.
	(new_register_cache): Use it.
	(regcache_cpy): New.
	(register_cache_size): New.
	(supply_regblock): New.
	(regcache_read_pc, regcache_write_pc): New.

	* tracepoint.c: New.

	* Makefile.in (OBS): Add tracepoint.o.
	(tracepoint.o): New rule.

	gdb/
	* regformats/regdat.sh: Include server.h.  Don't include
	regcache.h.
@
text
@d1395 1
d1980 1
a1980 1
  int pid = * (int *) arg;
d1982 3
a1984 2
  if (pid == -1
      || ptid_get_pid (entry->id) == pid)
d1991 17
a2007 2
      /* Pass the last stop reply back to GDB, but don't notify.  */
      queue_stop_reply (entry->id, &status);
d2013 35
d2053 2
a2054 3
  struct target_waitstatus status;
  status.kind = TARGET_WAITKIND_STOPPED;
  status.value.sig = TARGET_SIGNAL_TRAP;
d2062 2
a2063 3
      int pid = -1;
      discard_queued_stop_replies (pid);
      find_inferior (&all_threads, queue_stop_reply_callback, &pid);
d2072 3
d2076 8
a2083 2
	prepare_resume_reply (own_buf,
			      all_threads.head->id, &status);
d2452 2
a2453 1
      non_stop = 0;
d2468 1
a2468 1
	 removed from the event loop. */
d2481 31
a2511 3
      else
	fprintf (stderr, "Remote side has terminated connection.  "
		 "GDBserver will reopen the connection.\n");
d2520 1
a2520 1
static void
a2545 1
      target_async (0);
d2547 2
a2548 1
      return;
d2574 41
d2616 1
d2860 1
a2860 1
	return;
d2871 1
a2871 1
	  return;
d2874 2
a2875 4
	{
	  exit (0);
	  break;
	}
d2916 1
a2916 1
	  return;
d2957 5
d2966 1
a2966 1
void
d2973 2
a2974 1
  process_serial_event ();
d2979 2
d2985 1
a2985 1
void
d2996 47
a3042 2
      /* Something interesting.  Tell GDB about it.  */
      push_event (last_ptid, &last_status);
d3048 2
@


1.112
log
@Add x86 AVX support to gdbserver.

2010-04-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* Makefile.in (clean): Updated.
	(i386-avx.o): New.
	(i386-avx.c): Likewise.
	(i386-avx-linux.o): Likewise.
	(i386-avx-linux.c): Likewise.
	(amd64-avx.o): Likewise.
	(amd64-avx.c): Likewise.
	(amd64-avx-linux.o): Likewise.
	(amd64-avx-linux.c): Likewise.

	* configure.srv (srv_i386_regobj): Add i386-avx.o.
	(srv_i386_linux_regobj): Add i386-avx-linux.o.
	(srv_amd64_regobj): Add amd64-avx.o.
	(srv_amd64_linux_regobj): Add amd64-avx-linux.o.
	(srv_i386_32bit_xmlfiles): Add i386/32bit-avx.xml.
	(srv_i386_64bit_xmlfiles): Add i386/64bit-avx.xml.
	(srv_i386_xmlfiles): Add i386/i386-avx.xml.
	(srv_amd64_xmlfiles): Add i386/amd64-avx.xml.
	(srv_i386_linux_xmlfiles): Add i386/i386-avx-linux.xml.
	(srv_amd64_linux_xmlfiles): Add i386/amd64-avx-linux.xml.

	* i387-fp.c: Include "i386-xstate.h".
	(i387_xsave): New.
	(i387_cache_to_xsave): Likewise.
	(i387_xsave_to_cache): Likewise.
	(x86_xcr0): Likewise.

	* i387-fp.h (i387_cache_to_xsave): Likewise.
	(i387_xsave_to_cache): Likewise.
	(x86_xcr0): Likewise.

	* linux-arm-low.c (target_regsets): Initialize nt_type to 0.
	* linux-crisv32-low.c (target_regsets): Likewise.
	* linux-m68k-low.c (target_regsets): Likewise.
	* linux-mips-low.c (target_regsets): Likewise.
	* linux-ppc-low.c (target_regsets): Likewise.
	* linux-s390-low.c (target_regsets): Likewise.
	* linux-sh-low.c (target_regsets): Likewise.
	* linux-sparc-low.c (target_regsets): Likewise.
	* linux-xtensa-low.c (target_regsets): Likewise.

	* linux-low.c: Include <sys/uio.h>.
	(regsets_fetch_inferior_registers): Support nt_type.
	(regsets_store_inferior_registers): Likewise.
	(linux_process_qsupported): New.
	(linux_target_ops): Add linux_process_qsupported.

	* linux-low.h (regset_info): Add nt_type.
	(linux_target_ops): Add process_qsupported.

	* linux-x86-low.c: Include "i386-xstate.h", "elf/common.h"
	and <sys/uio.h>.
	(init_registers_i386_avx_linux): New.
	(init_registers_amd64_avx_linux): Likewise.
	(xmltarget_i386_linux_no_xml): Likewise.
	(xmltarget_amd64_linux_no_xml): Likewise.
	(PTRACE_GETREGSET): Likewise.
	(PTRACE_SETREGSET): Likewise.
	(x86_fill_xstateregset): Likewise.
	(x86_store_xstateregset): Likewise.
	(use_xml): Likewise.
	(x86_linux_update_xmltarget): Likewise.
	(x86_linux_process_qsupported): Likewise.
	(target_regsets): Add NT_X86_XSTATE entry and Initialize nt_type.
	(x86_arch_setup): Don't call init_registers_amd64_linux nor
	init_registers_i386_linux here.  Call
	x86_linux_update_xmltarget.
	(the_low_target): Add x86_linux_process_qsupported.

	* server.c (handle_query): Call target_process_qsupported.

	* target.h (target_ops): Add process_qsupported.
	(target_process_qsupported): New.
@
text
@d452 4
d513 37
d561 1
a561 1
  if (read_inferior_memory (start_addr, search_buf, search_buf_size) != 0)
d612 1
a612 1
	  if (read_inferior_memory (read_addr, search_buf + keep_len,
d1390 7
d1557 3
d2329 2
d2597 15
a2611 2
      {
	struct regcache *regcache;
d2613 4
a2616 5
	require_running (own_buf);
	set_desired_inferior (1);
	regcache = get_thread_regcache (current_inferior, 1);
	registers_to_string (regcache, own_buf);
      }
d2619 5
a2623 1
 	{
a2625 1
	  require_running (own_buf);
d2635 1
a2635 1
      if (read_inferior_memory (mem_addr, mem_buf, len) == 0)
d2643 1
a2643 1
      if (write_inferior_memory (mem_addr, mem_buf, len) == 0)
d2652 1
a2652 1
	  || write_inferior_memory (mem_addr, mem_buf, len) != 0)
@


1.111
log
@	* mem-break.c (struct raw_breakpoint): New field shlib_disabled.
	(set_gdb_breakpoint_at): If GDB is inserting a breakpoint on top
	of another, then delete the previous, and validate all
	breakpoints.
	(validate_inserted_breakpoint): New.
	(delete_disabled_breakpoints): New.
	(validate_breakpoints): New.
	(check_mem_read): Validate breakpoints before trusting their
	shadow.  Delete disabled breakpoints.
	(check_mem_write): Validate breakpoints before trusting they
	should be inserted.  Delete disabled breakpoints.
	* mem-break.h (validate_breakpoints):
	* server.c (handle_query): Validate breakpoints when we see a
	qSymbol query.
@
text
@d1292 3
d1310 2
@


1.110
log
@	* server.c (handle_query): Assign, not compare.
@
text
@d861 12
@


1.109
log
@2010-03-23  Michael Snyder  <msnyder@@vmware.com>

	* server.c (crc32): New function.
	(handle_query): Add handling for 'qCRC:' request.
@
text
@d1474 1
a1474 1
      base == strtoul (own_buf + 5, &comma, 16);
@


1.108
log
@	* regcache.h (struct thread_info): Forward declare.
	(struct regcache): New.
	(new_register_cache): Adjust prototype.
	(get_thread_regcache): Declare.
	(free_register_cache): Adjust prototype.
	(registers_to_string, registers_from_string): Ditto.
	(supply_register, supply_register_by_name, collect_register)
	(collect_register_as_string, collect_register_by_name): Ditto.
	* regcache.c (struct inferior_regcache_data): Delete.
	(get_regcache): Rename to ...
	(get_thread_regcache): ... this.  Adjust.  Switch inferior before
	fetching registers.
	(regcache_invalidate_one): Adjust.
	(regcache_invalidate): Fix prototype.
	(new_register_cache): Return the new register cache.
	(free_register_cache): Change prototype.
	(realloc_register_cache): Adjust.
	(registers_to_string): Change prototype to take a regcache.  Adjust.
	(registers_from_string): Ditto.
	(register_data): Ditto.
	(supply_register): Ditto.
	(supply_register_by_name): Ditto.
	(collect_register): Ditto.
	(collect_register_as_string): Ditto.
	(collect_register_by_name): Ditto.
	* server.c (process_serial_event): Adjust.
	* linux-low.h (regset_fill_func, regset_store_func): Change
	prototype.
	(get_pc, set_pc, collect_ptrace_register, supply_ptrace_register):
	Change prototype.
	* linux-low.c (get_stop_pc): Adjust.
	(check_removed_breakpoint): Adjust.
	(linux_wait_for_event): Adjust.
	(linux_resume_one_lwp): Adjust.
	(fetch_register): Add regcache parameter.  Adjust.
	(usr_store_inferior_registers): Ditto.
	(regsets_fetch_inferior_registers): Ditto.
	(regsets_store_inferior_registers): Ditto.
	(linux_fetch_registers, linux_store_registers): Ditto.
	* i387-fp.c (i387_cache_to_fsave): Change prototype to take a
	regcache.  Adjust.
	(i387_fsave_to_cache, i387_cache_to_fxsave, i387_fxsave_to_cache): Ditto.
	* i387-fp.h (i387_cache_to_fsave, i387_fsave_to_cache): Change
	prototype to take a regcache.
	(i387_cache_to_fxsave, i387_fxsave_to_cache): Ditto.
	* remote-utils.c (convert_ascii_to_int, outreg)
	(prepare_resume_reply): Change prototype to take a regcache.
	Adjust.
	* target.h (struct target_ops) <fetch_registers, store_registers>:
	Change prototype to take a regcache.
	(fetch_inferior_registers, store_inferior_registers): Change
	prototype to take a regcache.  Adjust.
	* proc-service.c (ps_lgetregs): Adjust.
	* linux-x86-low.c (x86_fill_gregset, x86_store_gregset)
	(x86_fill_fpregset, x86_store_fpregset, x86_fill_fpxregset)
	(x86_store_fpxregset, x86_get_pc, x86_set_pc): Change prototype to
	take a regcache.  Adjust.
	* linux-arm-low.c (arm_fill_gregset, arm_store_gregset)
	(arm_fill_wmmxregset, arm_store_wmmxregset, arm_fill_vfpregset)
	(arm_store_vfpregset, arm_get_pc, arm_set_pc):
	(arm_breakpoint_at): Change prototype to take a regcache.  Adjust.
	* linux-cris-low.c (cris_get_pc, cris_set_pc)
	(cris_cannot_fetch_register):
	(cris_breakpoint_at): Change prototype to take a regcache.
	Adjust.
	* linux-crisv32-low.c (cris_get_pc, cris_set_pc,
	cris_reinsert_addr, cris_write_data_breakpoint): Change prototype
	to take a regcache.  Adjust.
	(cris_breakpoint_at, cris_insert_point, cris_remove_point):
	Adjust.
	* linux-m32r-low.c (m32r_get_pc, m32r_set_pc): Change prototype to
	take a regcache.  Adjust.
	* linux-m68k-low.c (m68k_fill_gregset, m68k_store_gregset)
	(m68k_fill_fpregset, m68k_store_fpregset, m68k_get_pc,
	(m68k_set_pc): Change prototype to take a regcache.  Adjust.
	* linux-mips-low.c (mips_get_pc):
	(mips_set_pc): Change prototype to take a regcache.  Adjust.
	(mips_reinsert_addr): Adjust.
	(mips_collect_register): Change prototype to take a regcache.
	Adjust.
	(mips_supply_register):
	(mips_collect_register_32bit, mips_supply_register_32bit)
	(mips_fill_gregset, mips_store_gregset, mips_fill_fpregset)
	(mips_store_fpregset): Ditto.
	* linux-ppc-low.c (ppc_supply_ptrace_register, ppc_supply_ptrace_register):
	Ditto.
	(parse_spufs_run): Adjust.
	(ppc_get_pc, ppc_set_pc, ppc_fill_gregset, ppc_fill_vsxregset)
	(ppc_store_vsxregset, ppc_fill_vrregset, ppc_store_vrregset)
	(ppc_fill_evrregset, ppc_store_evrregset): Change prototype to
	take a regcache.  Adjust.
	* linux-s390-low.c (s390_collect_ptrace_register)
	(s390_supply_ptrace_register, s390_fill_gregset, s390_get_pc)
	(s390_set_pc): Change prototype to take a regcache.  Adjust.
	(s390_arch_setup): Adjust.
	* linux-sh-low.c (sh_get_pc, sh_breakpoint_at)
	(sh_fill_gregset): Change prototype to take a regcache.  Adjust.
	* linux-sparc-low.c (sparc_fill_gregset_to_stack)
	(sparc_fill_gregset, sparc_store_gregset_from_stack)
	(sparc_store_gregset, sparc_get_pc): Change prototype to take a
	regcache.  Adjust.
	(sparc_breakpoint_at): Adjust.
	* linux-xtensa-low.c (xtensa_fill_gregset):
	(xtensa_store_gregset):
	(xtensa_fill_xtregset, xtensa_store_xtregset, xtensa_get_pc)
	(xtensa_set_pc): Change prototype to take a regcache.  Adjust.
	* nto-low.c (nto_fetch_registers, nto_store_registers): Change
	prototype to take a regcache.  Adjust.
	* win32-arm-low.c (arm_fetch_inferior_register)
	(arm_store_inferior_register): Change prototype to take a
	regcache.  Adjust.
	* win32-i386-low.c (i386_fetch_inferior_register)
	(i386_store_inferior_register): Change prototype to take a
	regcache.  Adjust.
	* win32-low.c (child_fetch_inferior_registers)
	(child_store_inferior_registers): Change prototype to take a
	regcache.  Adjust.
	(win32_wait): Adjust.
	(win32_fetch_inferior_registers): Change prototype to take a
	regcache.  Adjust.
	(win32_store_inferior_registers): Adjust.
	* win32-low.h (struct win32_target_ops) <fetch_inferior_register,
	store_inferior_register>: Change prototype to take a regcache.
@
text
@d791 41
d1465 27
@


1.107
log
@	Implement core awareness.

	* bcache.c (compare_ints): Remove
	(print_percentage): Use compare_positive_ints.
	* defs.h (compare_positive_ints): Declare.
	* linux-nat.h (struct lin_lwp): New field core.
	(linux_nat_core_of_thread_1): Declare.
	* linux-nat.c (add_lwp): Init the 'core' field.
	(linux_nat_wait_1): Record the core.
	(linux_nat_core_of_thread_1, linux_nat_core_of_thread): New.
	(linux_nat_add_target): Register the above.
	* linux-thread-db.c (update_thread_core): New.
	(thread_db_find_new_threads): Update core information for
	every thread.
	* remote.c (struct private_thread_info): New.
	(free_private_thread_info, demand_private_info): New.
	(PACKET_qXfer_threads, use_osdata_threads): New.
	(struct thread_item, threads_parsing_context
	(start_thread, end_thread, thread_attributes)
	(thread_children, threads_children, threads_elements): New.
	(remote_threads_info): Try qXfer:threads before anything
	else.
	(remote_protocol_packets): Register qXfer:threads.
	(remote_open_1): Init use_osdata_threads.
	(struct stop_reply): New field 'core'.
	(remote_parse_stop_reply): Parse core number.
	(process_stop_reply): Record core number.
	(remote_xfer_partial): Handle qXfer:threads.
	(remote_core_of_thread): New.
	(init_remote_ops): Register remote_core_of_thread.
	(_initialize_remote): Register qXfer:read.
	* target.c (target_core_of_thread): New
	* target.h (enum target_object): New value TARGET_OBJECT_THREADS.
	(struct target_ops): New field to_core_of_threads.
	(target_core_of_thread): Declare.
	* gdbthread.h (struct thread_info): New field private_dtor.
	* thread.c (print_thread_info): Report the core.
	* ui-out.c (MAX_UI_OUT_LEVELS): Increase.
	* utils.c (compare_positive_ints): New.
	* features/threads.dtd: New.
	* mi/mi-interp.c (mi_on_normal_stop): Report the core.
	* mi/mi-main.c (struct collect_cores_data, collect_cores)
	(do_nothing, free_vector_of_osdata_items)
	(splay_tree_int_comparator, free_splay_tree): New.
	(print_one_inferior_data): Implemented printing of selected
	inferiors.  Collect and print cores.
	(output_cores): New.
	(mi_cmd_list_thread_groups): Support --recurse.  Permit specifying
	thread groups together with --available.
@
text
@d2459 8
a2466 3
      require_running (own_buf);
      set_desired_inferior (1);
      registers_to_string (own_buf);
d2469 9
a2477 4
      require_running (own_buf);
      set_desired_inferior (1);
      registers_from_string (&own_buf[1]);
      write_ok (own_buf);
@


1.106
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d710 81
d1196 37
d1289 2
@


1.105
log
@        * server.c (gdbserver_version): Update copyright year to 2010.
        * gdbreplay.c (gdbreplay_version): Likewise.
@
text
@d3 1
a3 1
   2004, 2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
@


1.104
log
@2009-10-29  Sandra Loosemore  <sandra@@codesourcery.com>

	PR gdb/10783

	gdb/
	* target.c (simple_search_memory): Correct read_addr initialization
	in loop for searching subsequent chunks.

	gdb/gdbserver/
	* server.c (handle_search_memory_1): Correct read_addr initialization
	in loop for searching subsequent chunks.
@
text
@d1778 1
a1778 1
	  "Copyright (C) 2009 Free Software Foundation, Inc.\n"
@


1.103
log
@doc/
2009-10-08  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* gdb.texinfo (Server): Document libthread-db-search-path.

gdbserver/
2009-10-08  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* acinclude.m4: (SRV_CHECK_THREAD_DB, SRV_CHECK_TLS_GET_ADDR): Remove.
	* configure.ac: Adjust.
	* linux-low.h (struct process_info_private): Move members to struct
	thread_db.
	(thread_db_free, thread_db_handle_monitor_command): New prototype.
	* linux-low.c (linux_remove_process): Adjust.
	(linux_wait_for_event_1, linux_look_up_symbols): Likewise.
	* server.c (handle_query): Move code ...
	(handle_monitor_command): ... here. New function.
	* target.h (struct target_ops): New member.
	* thread-db.c (struct thread_db): New.
	(libthread_db_search_path): New variable.
	(thread_db_create_event, thread_db_enable_reporting)
	(find_one_thread, maybe_attach_thread, find_new_threads_callback)
	(thread_db_find_new_threads, (thread_db_get_tls_address): Adjust.
	(try_thread_db_load_1, dladdr_to_soname): New functions.
	(try_thread_db_load, thread_db_load_search): New functions.
	(thread_db_init): Search for libthread_db.
	(thread_db_free): New function.
	(thread_db_handle_monitor_command): Likewise.
	* config.in: Regenerate.
	* configure: Regenerate.
@
text
@d560 1
a560 1
	  CORE_ADDR read_addr = start_addr + keep_len;
@


1.102
log
@	Add h/w watchpoint support to x86-linux, win32-i386.
	* Makefile.in (SFILES): Add i386-low.c
	(i386_low_h): Define.
	(i386-low.o): Add dependencies.
	(linux-x86-low.o): Add i386-low.h dependency.
	(win32-i386-low.o): Ditto.
	* i386-low.c: New file.
	* i386-low.h: New file.
	* configure.srv (i[34567]86-*-cygwin*): Add i386-low.o to srv_tgtobj.
	(i[34567]86-*-linux*, i[34567]86-*-mingw*, x86_64-*-linux*): Ditto.
	* linux-low.c (linux_add_process): Initialize arch_private.
	(linux_remove_process): Free arch_private.
	(add_lwp): Initialize arch_private.
	(delete_lwp): Free arch_private.
	(linux_resume_one_lwp): Call the_low_target.prepare_to_resume if
	provided.
	* linux-low.h (process_info_private): New member arch_private.
	(lwp_info): New member arch_private.
	(linux_target_ops): New members new_process, new_thread,
	prepare_to_resume.
	(ptid_of): New macro.
	* linux-x86-low.c: Include stddef.h, i386-low.h.
	(arch_process_info): New struct.
	(arch_lwp_info): New struct.
	(x86_linux_dr_get, x86_linux_dr_set): New functions.
	(i386_dr_low_set_addr, i386_dr_low_set_control): New functions.
	(i386_dr_low_get_status): New function.
	(x86_insert_point, x86_remove_point): New functions.
	(x86_stopped_by_watchpoint): New function.
	(x86_stopped_data_address): New function.
	(x86_linux_new_process, x86_linux_new_thread): New functions.
	(x86_linux_prepare_to_resume): New function.
	(the_low_target): Add entries for insert_point, remove_point,
	stopped_by_watchpoint, stopped_data_address, new_process, new_thread,
	prepare_to_resume.
	* server.c (debug_hw_points): New global.
	(monitor_show_help): Document set debug-hw-points.
	(handle_query): Process "set debug-hw-points".
	* server.h (debug_hw_points): Declare.
	(paddress): Declare.
	* utils.c (NUMCELLS, CELLSIZE): New macros.
	(get_sell, xsnprintf, paddress): New functions.
	* win32-arm-low.c (the_low_target): Add entries for insert_point,
	remove_point, stopped_by_watchpoint, stopped_data_address.
	* win32-i386-low.c: Include i386-low.h.
	(debug_reg_state): Replaces dr.
	(i386_dr_low_set_addr, i386_dr_low_set_control): New functions.
	(i386_dr_low_get_status): New function.
	(i386_insert_point, i386_remove_point): New functions.
	(i386_stopped_by_watchpoint): New function.
	(i386_stopped_data_address): New function.
	(i386_initial_stuff): Update.
	(get_thread_context,set_thread_context,i386_thread_added): Update.
	(the_low_target): Add entries for insert_point,
	remove_point, stopped_by_watchpoint, stopped_data_address.
	* win32-low.c (win32_insert_watchpoint): New function.
	(win32_remove_watchpoint): New function.
	(win32_stopped_by_watchpoint): New function.
	(win32_stopped_data_address): New function.
	(win32_target_ops): Add entries for insert_watchpoint,
	remove_watchpoint, stopped_by_watchpoint, stopped_data_address.
	* win32-low.h (win32_target_ops): New members insert_point,
	remove_point, stopped_by_watchpoint, stopped_data_address.
@
text
@d663 47
d1261 4
a1264 40
      if (strcmp (mon, "set debug 1") == 0)
	{
	  debug_threads = 1;
	  monitor_output ("Debug output enabled.\n");
	}
      else if (strcmp (mon, "set debug 0") == 0)
	{
	  debug_threads = 0;
	  monitor_output ("Debug output disabled.\n");
	}
      else if (strcmp (mon, "set debug-hw-points 1") == 0)
	{
	  debug_hw_points = 1;
	  monitor_output ("H/W point debugging output enabled.\n");
	}
      else if (strcmp (mon, "set debug-hw-points 0") == 0)
	{
	  debug_hw_points = 0;
	  monitor_output ("H/W point debugging output disabled.\n");
	}
      else if (strcmp (mon, "set remote-debug 1") == 0)
	{
	  remote_debug = 1;
	  monitor_output ("Protocol debug output enabled.\n");
	}
      else if (strcmp (mon, "set remote-debug 0") == 0)
	{
	  remote_debug = 0;
	  monitor_output ("Protocol debug output disabled.\n");
	}
      else if (strcmp (mon, "help") == 0)
	monitor_show_help ();
      else if (strcmp (mon, "exit") == 0)
	exit_requested = 1;
      else
	{
	  monitor_output ("Unknown monitor command.\n\n");
	  monitor_show_help ();
	  write_enn (own_buf);
	}
@


1.101
log
@	* server.c (process_serial_event): Re-return unsupported, not
	error, if the type isn't recognized.  Re-allow supporting only
	insert or remove packets.  Also call require_running for
	breakpoints.  Add missing break statement to default case.  Tidy.
	* target.h (struct target_ops): Rename insert_watchpoint to
	insert_point, and remove_watchpoint to remove_point.

	* linux-low.h (struct linux_target_ops): Likewise.
	* linux-low.c (linux_insert_watchpoint): Rename to ...
	(linux_insert_point): ... this.  Adjust.
	(linux_remove_watchpoint): Rename to ...
	(linux_remove_point): ... this.  Adjust.
	(linux_target_ops): Adjust.
	* linux-crisv32-low.c (cris_insert_watchpoint): Rename to ...
	(cris_insert_point): ... this.
	(cris_remove_watchpoint): Rename to ...
	(cris_remove_point): ... this.
	(the_low_target): Adjust.
@
text
@d54 3
d501 2
d1224 10
@


1.100
log
@	* server.c (handle_v_kill): Pass signal_pid to
	kill_inferior if multi_process is zero.
@
text
@d2386 1
a2386 1
	const int insert_ = ch == 'Z';
d2388 18
a2405 30
	/* Type: '0' - software-breakpoint
		 '1' - hardware-breakpoint
		 '2' - write watchpoint
		 '3' - read watchpoint
		 '4' - access watchpoint  */

	if (the_target->insert_watchpoint == NULL
	    || the_target->remove_watchpoint == NULL)
	  res = 1;  /* Not supported.  */
	else
	  switch (type)
	    {
	    case '2':
	      /* Fallthrough.  */
	    case '3':
	      /* Fallthrough.  */
	    case '4':
	      require_running (own_buf);
	      /* Fallthrough.  */
	    case '0':
	      /* Fallthrough.  */
	    case '1':
	      res = insert_ ? (*the_target->insert_watchpoint) (type, addr,
								len)
			    : (*the_target->remove_watchpoint) (type, addr,
								len);
	      break;
	    default:
	      res = -1; /* Unrecognized type.  */
	    }
@


1.99
log
@* server.c (process_serial_event): Add support for Z0 and Z1 packet.
* target.h (target_ops): Comment for *_watchpoint to make it clear
the functions can get types '0' and '1'.
@
text
@d1526 4
a1529 2

  pid = strtol (p, NULL, 16);
@


1.98
log
@2009-06-19  Aleksandar Ristovski  <aristovski@@qnx.com>
	    Pedro Alves <pedro@@codesourcery.com>

	* target.h (struct target_ops) <supports_multi_process>: New
	callback.
	(target_supports_multi_process): New.
	* server.c (handle_query): Even if GDB reports support, only
	enable multi-process if the target also supports it.  Report
	multi-process support only if the target backend supports it.
	* linux-low.c (linux_supports_multi_process): New function.
	(linux_target_ops): Install it as target_supports_multi_process
	callback.
@
text
@d2374 3
a2376 1
    case 'Z':
d2383 8
d2393 2
a2394 6
	    || (type < '2' || type > '4'))
	  {
	    /* No watchpoint support or not a watchpoint command;
	       unrecognized either way.  */
	    own_buf[0] = '\0';
	  }
d2396 20
a2415 2
	  {
	    int res;
d2417 5
a2421 27
	    require_running (own_buf);
	    res = (*the_target->insert_watchpoint) (type, addr, len);
	    if (res == 0)
	      write_ok (own_buf);
	    else if (res == 1)
	      /* Unsupported.  */
	      own_buf[0] = '\0';
	    else
	      write_enn (own_buf);
	  }
	break;
      }
    case 'z':
      {
	char *lenptr;
	char *dataptr;
	CORE_ADDR addr = strtoul (&own_buf[3], &lenptr, 16);
	int len = strtol (lenptr + 1, &dataptr, 16);
	char type = own_buf[1];

	if (the_target->remove_watchpoint == NULL
	    || (type < '2' || type > '4'))
	  {
	    /* No watchpoint support or not a watchpoint command;
	       unrecognized either way.  */
	    own_buf[0] = '\0';
	  }
d2423 1
a2423 13
	  {
	    int res;

	    require_running (own_buf);
	    res = (*the_target->remove_watchpoint) (type, addr, len);
	    if (res == 0)
	      write_ok (own_buf);
	    else if (res == 1)
	      /* Unsupported.  */
	      own_buf[0] = '\0';
	    else
	      write_enn (own_buf);
	  }
@


1.97
log
@gdb:
	Global renaming of find_thread_pid to find_thread_ptid.
	* gdbthread.h (find_thread_ptid): Renamed from find_thread_pid.
	* thread.c (find_thread_ptid): Renamed from find_thread_pid.
	All callers updated.
gdbserver:
	Global renaming of find_thread_pid to find_thread_ptid.
	* server.h (find_thread_ptid): Renamed from find_thread_pid.
	* inferiors.c (find_thread_ptid): Renamed from find_thread_pid.
	All callers updated.
@
text
@a1076 1
	    /* Record if GDB knows about multiprocess support.  */
d1078 6
a1083 1
	      multi_process = 1;
d1113 2
a1114 1
      strcat (own_buf, ";multiprocess+");
@


1.96
log
@	* inferiors.c (started_inferior_callback): New function.
	(attached_inferior_callback): New function.
	(have_started_inferiors_p, have_attached_inferiors_p): New functions.
	* server.c (print_started_pid, print_attached_pid): New functions.
	(detach_or_kill_for_exit): New function.
	(main): Call it instead of for_each_inferior (kill_inferior_callback).
	* server.h (have_started_inferiors_p): Declare.
	(have_attached_inferiors_p): Declare.
@
text
@d1159 1
a1159 1
	  struct thread_info *thread = find_thread_pid (ptid);
@


1.95
log
@2009-04-01  Pedro Alves  <pedro@@codesourcery.com>

	Implement the multiprocess extensions, and add linux multiprocess
	support.

	* server.h (ULONGEST): Declare.
	(struct ptid, ptid_t): New.
	(minus_one_ptid, null_ptid): Declare.
	(ptid_build, pid_to_ptid, ptid_get_pid, ptid_get_lwp)
	(ptid_get_tid, ptid_equal, ptid_is_pid): Declare.
	(struct inferior_list_entry): Change `id' type from unsigned from
	to ptid_t.
	(struct sym_cache, struct breakpoint, struct
	process_info_private): Forward declare.
	(struct process_info): Declare.
	(current_process): Declare.
	(all_processes): Declare.
	(initialize_inferiors): Declare.
	(add_thread): Adjust to use ptid_t.
	(thread_id_to_gdb_id, thread_to_gdb_id, gdb_id_to_thread_id): Ditto.
	(add_process, remove_process, find_thread_pid): Declare.
	(find_inferior_id): Adjust to use ptid_t.
	(cont_thread, general_thread, step_thread): Change type to ptid_t.
	(multi_process): Declare.
	(push_event): Adjust to use ptid_t.
	(read_ptid, write_ptid): Declare.
	(prepare_resume_reply): Adjust to use ptid_t.
	(clear_symbol_cache): Declare.
	* inferiors.c (all_processes): New.
	(null_ptid, minus_one_ptid): New.
	(ptid_build, pid_to_ptid, ptid_get_pid, ptid_get_lwp)
	(ptid_get_tid, ptid_equal, ptid_is_pid): New.
	(add_thread): Change unsigned long to ptid.  Remove gdb_id
	parameter.  Adjust.
	(thread_id_to_gdb_id, thread_to_gdb_id): Change unsigned long to ptid.
	(gdb_id_to_thread): Rename to ...
	(find_thread_pid): ... this.  Change unsigned long to ptid.
	(gdb_id_to_thread_id, find_inferior_id): Change unsigned long to ptid.
	(loaded_dll, pull_pid_from_list): Adjust.
	(add_process, remove_process, find_process_pid)
	(get_thread_process, current_process, initialize_inferiors): New.
	* target.h (struct thread_resume) <thread>: Change type to ptid_t.
	(struct target_waitstatus) <related_pid>: Ditto.
	(struct target_ops) <kill, detach>: Add `pid' argument.  Change
	return type to int.
	(struct target_ops) <join>: Add `pid' argument.
	(struct target_ops) <thread_alive>: Change pid's type to ptid_t.
	(struct target_ops) <wait>: Add `ptid' field.  Change return type
	to ptid.
	(kill_inferior, detach_inferior, join_inferior): Add `pid' argument.
	(mywait): Add `ptid' argument.  Change return type to ptid_t.
	(target_pid_to_str): Declare.
	* target.c (set_desired_inferior): Adjust to use ptids.
	(mywait): Add new `ptid' argument.  Adjust.
	(target_pid_to_str): New.
	* mem-break.h (free_all_breakpoints): Declare.
	* mem-break.c (breakpoints): Delelete.
	(set_breakpoint_at, delete_breakpoint, find_breakpoint_at)
	(check_mem_read, check_mem_write, delete_all_breakpoints): Adjust
	to use per-process breakpoint list.
	(free_all_breakpoints): New.
	* remote-utils.c (struct sym_cache) <name>: Drop `const'.
	(symbol_cache, all_symbols_looked_up): Delete.
	(hexchars): New.
	(ishex, unpack_varlen_hex, write_ptid, hex_or_minus_one,
	read_ptid): New.
	(prepare_resume_reply): Change ptid argument's type from unsigned
	long to ptid_t.  Adjust.  Implement W;process and X;process.
	(free_sym_cache, clear_symbol_cache): New.
	(look_up_one_symbol): Adjust to per-process symbol cache.  *
	* server.c (cont_thread, general_thread, step_thread): Change type
	to ptid_t.
	(attached): Delete.
	(multi_process): New.
	(last_ptid): Change type to ptid_t.
	(struct vstop_notif) <ptid>: Change type to ptid_t.
	(queue_stop_reply, push_event): Change `ptid' argument's type to
	ptid_t.
	(discard_queued_stop_replies): Add `pid' argument.
	(start_inferior): Adjust to use ptids.  Adjust to mywait interface
	changes.  Don't reference the `attached' global.
	(attach_inferior): Adjust to mywait interface changes.
	(handle_query): Adjust to use ptids.  Parse GDB's qSupported
	features.  Handle and report "multiprocess+".  Handle
	"qAttached:PID".
	(handle_v_cont): Adjust to use ptids.  Adjust to mywait interface
	changes.
	(handle_v_kill): New.
	(handle_v_stopped): Adjust to use target_pid_to_str.
	(handle_v_requests): Allow multiple attaches and runs when
	multiprocess extensions are in effect.  Handle "vKill".
	(myresume): Adjust to use ptids.
	(queue_stop_reply_callback): Add `arg' parameter.  Handle it.
	(handle_status): Adjust to discard_queued_stop_replies interface
	change.
	(first_thread_of, kill_inferior_callback)
	(detach_or_kill_inferior_callback, join_inferiors_callback): New.
	(main): Call initialize_inferiors.  Adjust to use ptids, killing
	and detaching from all inferiors.  Handle multiprocess packet
	variants.
	* linux-low.h: Include gdb_proc_service.h.
	(struct process_info_private): New.
	(struct linux_target_ops) <pid_of>: Use ptid_get_pid.
	<lwpid_of>: Use ptid_get_lwp.
	(get_lwp_thread): Adjust.
	(struct lwp_info): Add `dead' member.
	(find_lwp_pid): Declare.
	* linux-low.c (thread_db_active): Delete.
	(new_inferior): Adjust comment.
	(inferior_pid): Delete.
	(linux_add_process): New.
	(handle_extended_wait): Adjust.
	(add_lwp): Change unsigned long to ptid.
	(linux_create_inferior): Add process to processes table.  Adjust
	to use ptids.  Don't set new_inferior here.
	(linux_attach_lwp): Rename to ...
	(linux_attach_lwp_1): ... this.  Add `initial' argument.  Handle
	it.  Adjust to use ptids.
	(linux_attach_lwp): New.
	(linux_attach): Add process to processes table.  Don't set
	new_inferior here.
	(struct counter): New.
	(second_thread_of_pid_p, last_thread_of_process_p): New.
	(linux_kill_one_lwp): Add `args' parameter.  Handle it.  Adjust to
	multiple processes.
	(linux_kill): Add `pid' argument.  Handle it.  Adjust to multiple
	processes.  Remove process from process table.
	(linux_detach_one_lwp): Add `args' parameter.  Handle it.  Adjust
	to multiple processes.
	(any_thread_of): New.
	(linux_detach): Add `pid' argument, and handle it.  Remove process
	from processes table.
	(linux_join): Add `pid' argument.  Handle it.
	(linux_thread_alive): Change unsighed long argument to ptid_t.
	Consider dead lwps as not being alive.
	(status_pending_p): Rename `dummy' argument to `arg'.  Filter out
	threads we're not interested in.
	(same_lwp, find_lwp_pid): New.
	(linux_wait_for_lwp): Change `pid' argument's type from int to
	ptid_t.  Adjust.
	(linux_wait_for_event): Rename to ...
	(linux_wait_for_event_1): ... this.  Change `pid' argument's type
	from int to ptid_t.  Adjust.
	(linux_wait_for_event): New.
	(linux_wait_1): Add `ptid' argument.  Change return type to
	ptid_t.  Adjust.  Use last_thread_of_process_p.  Remove processes
	that exit from the process table.
	(linux_wait): Add `ptid' argument.  Change return type to ptid_t.
	Adjust.
	(mark_lwp_dead): New.
	(wait_for_sigstop): Adjust to use ptids.  If a process exits while
	stopping all threads, mark its main lwp as dead.
	(linux_set_resume_request, linux_resume_one_thread): Adjust to use
	ptids.
	(fetch_register, usr_store_inferior_registers)
	(regsets_fetch_inferior_registers)
	(regsets_store_inferior_registers, linux_read_memory)
	(linux_write_memory): Inline `inferior_pid'.
	(linux_look_up_symbols): Adjust to use per-process
	`thread_db_active'.
	(linux_request_interrupt): Adjust to use ptids.
	(linux_read_auxv): Inline `inferior_pid'.
	(initialize_low): Don't reference thread_db_active.
	* gdb_proc_service.h (struct ps_prochandle) <pid>: Remove.
	* proc-service.c (ps_lgetregs): Use find_lwp_pid.
	(ps_getpid): Return the pid of the current inferior.
	* thread-db.c (proc_handle, thread_agent): Delete.
	(thread_db_create_event, thread_db_enable_reporting): Adjust to
	per-process data.
	(find_one_thread): Change argument type to ptid_t.  Adjust to
	per-process data.
	(maybe_attach_thread): Adjust to per-process data and ptids.
	(thread_db_find_new_threads): Ditto.
	(thread_db_init): Ditto.
	* spu-low.c (spu_create_inferior, spu_attach): Add process to
	processes table.  Adjust to use ptids.
	(spu_kill, spu_detach): Adjust interface.  Remove process from
	processes table.
	(spu_join, spu_thread_alive): Adjust interface.
	(spu_wait): Adjust interface.  Remove process from processes
	table.  Adjust to use ptids.
	* win32-low.c (current_inferior_tid): Delete.
	(current_inferior_ptid): New.
	(debug_event_ptid): New.
	(thread_rec): Take a ptid.  Adjust.
	(child_add_thread): Add `pid' argument.  Adjust to use ptids.
	(child_delete_thread): Ditto.
	(do_initial_child_stuff): Add `attached' argument.  Add process to
	processes table.
	(child_fetch_inferior_registers, child_store_inferior_registers):
	Adjust.
	(win32_create_inferior): Pass 0 to do_initial_child_stuff.
	(win32_attach): Pass 1 to do_initial_child_stuff.
	(win32_kill): Adjust interface.  Remove process from processes
	table.
	(win32_detach): Ditto.
	(win32_join): Adjust interface.
	(win32_thread_alive): Take a ptid.
	(win32_resume): Adjust to use ptids.
	(get_child_debug_event): Ditto.
	(win32_wait): Adjust interface.  Remove exiting process from
	processes table.
@
text
@d1811 5
d1830 59
d2082 1
a2082 3
      fprintf (stderr, "Killing all inferiors\n");
      for_each_inferior (&all_processes,
			 kill_inferior_callback);
d2127 1
a2127 2
	  for_each_inferior (&all_processes,
			     detach_or_kill_inferior_callback);
@


1.94
log
@	Non-stop mode support.

	* server.h (non_stop): Declare.
	(gdb_client_data, handler_func): Declare.
	(delete_file_handler, add_file_handler, start_event_loop):
	Declare.
	(handle_serial_event, handle_target_event, push_event)
	(putpkt_notif): Declare.
	* target.h (enum resume_kind): New.
	(struct thread_resume): Replace `step' field by `kind' field.
	(TARGET_WNOHANG): Define.
	(struct target_ops) <wait>: Add `options' argument.
	<supports_non_stop, async, start_non_stop>: New fields.
	(target_supports_non_stop, target_async): New.
	(start_non_stop): Declare.
	(mywait): Add `options' argument.
	* target.c (mywait): Add `options' argument.  Print child exit
	notifications here.
	(start_non_stop): New.
	* server.c (non_stop, own_buf, mem_buf): New globals.
	(struct vstop_notif): New.
	(notif_queue): New global.
	(queue_stop_reply, push_event, discard_queued_stop_replies)
	(send_next_stop_reply): New.
	(start_inferior): Adjust to use resume_kind.  Adjust to mywait
	interface changes.
	(attach_inferior): In non-stop mode, don't wait for the target
	here.
	(handle_general_set): Handle QNonStop.
	(handle_query): When handling qC, return the current general
	thread, instead of the first thread of the list.
	(handle_query): If the backend supports non-stop mode, include
	QNonStop+ in the qSupported query response.
	(handle_v_cont): Adjust to use resume_kind.  Handle resume_stop
	and non-stop mode.
	(handle_v_attach, handle_v_run): Handle non-stop mode.
	(handle_v_stopped): New.
	(handle_v_requests): Report support for vCont;t.  Handle vStopped.
	(myresume): Adjust to use resume_kind.  Handle non-stop.
	(queue_stop_reply_callback): New.
	(handle_status): Handle non-stop mode.
	(main): Clear non_stop flag on reconnection.  Use the event-loop.
	Refactor serial protocol handling from here ...
	(process_serial_event): ... to this new function.  When GDB
	selects any thread, select one here.  In non-stop mode, wait until
	GDB acks all pending events before exiting.
	(handle_serial_event, handle_target_event): New.
	* remote-utils.c (remote_open): Install remote_desc in the event
	loop.
	(remote_close): Remove remote_desc from the event loop.
	(putpkt_binary): Rename to...
	(putpkt_binary_1): ... this.  Add `is_notic' argument.  Handle it.
	(putpkt_binary): New as wrapper around putpkt_binary_1.
	(putpkt_notif): New.
	(prepare_resume_reply): In non-stop mode, don't change the
	general_thread.
	* event-loop.c: New.
	* Makefile.in (OBJ): Add event-loop.o.
	(event-loop.o): New rule.

	* linux-low.h (pid_of): Moved here.
	(lwpid_of): New.
	(get_lwp_thread): Use lwpid_of.
	(struct lwp_info): Delete `lwpid' field.  Add `suspended' field.
	* linux-low.c (pid_of): Delete.
	(inferior_pid): Use lwpid_of.
	(linux_event_pipe): New.
	(target_is_async_p): New.
	(delete_lwp): New.
	(handle_extended_wait): Use lwpid_of.
	(add_lwp): Don't set lwpid field.
	(linux_attach_lwp): Adjust debug output.  Use lwpid_of.
	(linux_kill_one_lwp): If killing a running lwp, stop it first.
	Use lwpid_of.  Adjust to linux_wait_for_event interface changes.
	(linux_detach_one_lwp): If detaching from a running lwp, stop it
	first.  Adjust to linux_wait_for_event interface changes.  Use
	lwpid_of.
	(linux_detach): Don't delete the main lwp here.
	(linux_join): Use my_waitpid.  Avoid signal_pid.  Use lwpid_of.
	(status_pending_p): Don't consider explicitly suspended lwps.
	(linux_wait_for_lwp): Take an integer pid instead of a lwp_info
	pointer.  Add OPTIONS argument.  Change return type to int.  Use
	my_waitpid instead of sleeping.  Handle WNOHANG.  Use lwpid_of.
	(linux_wait_for_event): Take an integer pid instead of a lwp_info
	pointer.  Add status pointer argument.  Return a pid instead of a
	status.  Use lwpid_of.  Adjust to linux_wait_for_lwp interface
	changes.  In non-stop mode, don't switch to a random thread.
	(linux_wait): Rename to...
	(linux_wait_1): ... this.  Add target_options argument, and handle
	it.  Adjust to use resume_kind.  Use lwpid_of.  In non-stop mode,
	don't handle the continue thread.  Handle TARGET_WNOHANG.  Merge
	clean exit and signal exit code.  Don't stop all threads in
	non-stop mode.  In all-stop mode, only stop all threads when
	reporting a stop to GDB.  Handle explicit thread stop requests.
	(async_file_flush, async_file_mark): New.
	(linux_wait): New.
	(send_sigstop): Use lwpid_of.
	(wait_for_sigstop): Use lwpid_of.  Adjust to linux_wait_for_event
	interface changes.  In non-stop mode, don't switch to a random
	thread.
	(linux_resume_one_lwp): Use lwpid_of.
	(linux_continue_one_thread, linux_queue_one_thread): Merge into ...
	(linux_resume_one_thread): ... this.  Handle resume_stop.  In
	non-stop mode, don't look for pending flag in all threads.
	(resume_status_pending_p): Don't consider explicitly suspended
	threads.
	(my_waitpid): Reimplement.  Emulate __WALL.
	(linux_request_interrupt, linux_read_offsets, linux_xfer_siginfo):
	Use lwpid_of.
	(sigchld_handler, linux_supports_non_stop, linux_async)
	(linux_start_non_stop): New.
	(linux_target_ops): Register linux_supports_non_stop, linux_async
	and linux_start_non_stop.
	(initialize_low): Install SIGCHLD handler.
	* thread-db.c (thread_db_create_event, find_one_thread)
	(thread_db_get_tls_address): Use lwpid_of.
	* win32-low.c (win32_detach): Adjust to use resume_kind.
	(win32_wait): Add `options' argument.
	* spu-low.c (spu_resume): Adjust to use resume_kind.
	(spu_wait): Add `options' argument.
@
text
@d35 3
a37 3
unsigned long cont_thread;
unsigned long general_thread;
unsigned long step_thread;
a41 1
static int attached;
d45 1
d93 1
a93 1
static unsigned long last_ptid;
d107 1
a107 1
  unsigned long ptid;
d119 1
a119 1
queue_stop_reply (unsigned long ptid, struct target_waitstatus *status)
d156 1
a156 1
push_event (unsigned long ptid, struct target_waitstatus *status)
d173 2
a174 1
/* Get rid of the currently pending stop replies.  */
d177 1
a177 1
discard_queued_stop_replies (void)
d179 1
a179 1
  struct vstop_notif *next;
d181 1
a181 1
  while (notif_queue)
d183 9
a191 2
      next = notif_queue->next;
      notif_queue = next;
d193 4
a196 1
      free (next);
a222 1
  attached = 0;
d266 1
a266 1
      unsigned long ptid;
d268 1
a268 1
      resume_info.thread = -1;
d272 1
a272 1
      ptid = mywait (&last_status, 0, 0);
d281 1
a281 1
 	  mywait (&last_status, 0, 0);
d292 1
a292 1
  last_ptid = mywait (&last_status, 0, 0);
a305 2
  attached = 1;

d316 1
a316 1
      last_ptid = mywait (&last_status, 0, 0);
d667 1
a667 1
      unsigned long gdb_id;
d670 2
a671 1
      if (general_thread != 0 && general_thread != -1)
d679 3
a681 1
      sprintf (own_buf, "QC%lx", gdb_id);
d698 2
d702 4
a705 2
	  sprintf (own_buf, "m%x",
		   thread_to_gdb_id ((struct thread_info *)thread_ptr));
d712 2
d717 3
a719 2
	      sprintf (own_buf, "m%x",
		       thread_to_gdb_id ((struct thread_info *)thread_ptr));
d1067 15
d1109 2
d1124 1
a1124 1
      unsigned long ptid = 0;
d1149 1
a1149 1
	    ptid = strtoul (p, NULL, 16);
d1159 1
a1159 1
	  struct thread_info *thread = gdb_id_to_thread (ptid);
d1246 2
a1247 1
  if (strcmp (own_buf, "qAttached") == 0)
d1249 21
a1269 2
      require_running (own_buf);
      strcpy (own_buf, attached ? "1" : "0");
d1285 1
a1285 1
  struct thread_resume default_action = {0};
d1335 1
a1335 1
	  resume_info[i].thread = -1;
d1343 1
a1343 2
	  unsigned int gdb_id = strtoul (p + 1, &q, 16);
	  unsigned long thread_id;
d1351 1
a1351 5
	  thread_id = gdb_id_to_thread_id (gdb_id);
	  if (thread_id)
	    resume_info[i].thread = thread_id;
	  else
	    goto err;
d1362 1
a1362 1
      && resume_info[0].thread != -1
d1366 1
a1366 1
    cont_thread = -1;
d1380 1
a1380 1
      last_ptid = mywait (&last_status, 0, 1);
d1515 24
d1550 2
a1551 1
	fprintf (stderr, "vStopped: acking %ld\n", notif_queue->ptid);
d1588 1
a1588 1
      if (target_running ())
d1600 1
a1600 1
      if (target_running ())
d1610 12
d1646 2
a1647 1
  valid_cont_thread = (cont_thread != 0 && cont_thread != -1);
d1663 1
a1663 1
      resume_info[n].thread = -1;
d1678 1
a1678 1
      last_ptid = mywait (&last_status, 0, 1);
d1687 2
a1688 2
static void
queue_stop_reply_callback (struct inferior_list_entry *entry)
d1690 9
a1698 1
  struct target_waitstatus status;
d1700 3
a1702 2
  status.kind = TARGET_WAITKIND_STOPPED;
  status.value.sig = TARGET_SIGNAL_TRAP;
d1704 1
a1704 2
  /* Pass the last stop reply back to GDB, but don't notify.  */
  queue_stop_reply (entry->id, &status);
d1722 3
a1724 2
      discard_queued_stop_replies ();
      for_each_inferior (&all_threads, queue_stop_reply_callback);
d1790 46
d1973 1
d2008 1
a2008 1
      last_ptid = -1;
d2018 3
a2020 2
      fprintf (stderr, "Killing inferior\n");
      kill_inferior ();
d2039 1
d2065 2
a2066 4
	  if (attached)
	    detach_inferior ();
	  else
	    kill_inferior ();
d2088 1
d2124 12
a2135 2
      fprintf (stderr, "Detaching from inferior\n");
      if (detach_inferior () != 0)
d2139 1
a2139 1
	  discard_queued_stop_replies ();
d2147 1
a2147 1
	      last_ptid = signal_pid;
d2159 2
a2160 3
	      if (!attached)
		join_inferior ();

d2175 2
a2176 1
	  unsigned long gdb_id, thread_id;
d2179 24
a2202 3
	  gdb_id = strtoul (&own_buf[2], NULL, 16);
	  if (gdb_id == 0 || gdb_id == -1)
	    thread_id = gdb_id;
d2206 1
a2206 1
	      if (thread_id == 0)
d2215 1
a2215 1
	      if (thread_id == 0)
d2373 2
a2374 2
	/* The packet we received doesn't make sense - but we
	   can't reply to it, either.  */
d2377 2
a2378 3
      fprintf (stderr, "Killing inferior\n");
      kill_inferior ();
      discard_queued_stop_replies ();
d2395 1
a2395 1
	unsigned long gdb_id, thread_id;
d2398 2
a2399 1
	gdb_id = strtoul (&own_buf[1], NULL, 16);
d2401 1
a2401 1
	if (thread_id == 0)
d2421 2
a2422 4
	    {
	      kill_inferior ();
	      discard_queued_stop_replies ();
	    }
d2500 2
a2501 1
  last_ptid = mywait (&last_status, TARGET_WNOHANG, 1);
@


1.93
log
@	Decouple target code from remote protocol.

	* target.h (enum target_waitkind): New.
	(struct target_waitstatus): New.
	(struct target_ops) <wait>: Return an unsigned long.  Take a
	target_waitstatus pointer instead of a char pointer.
	(mywait): Likewise.
	* target.c (mywait): Change prototype to return an unsigned long.
	Take a target_waitstatus pointer instead of a char pointer.  Adjust.
	* server.h (thread_from_wait, old_thread_from_wait): Delete
	declarations.
	(prepare_resume_reply): Change prototype to take a
	target_waitstatus.
	* server.c (thread_from_wait, old_thread_from_wait): Delete.
	(last_status, last_ptid): New.
	(start_inferior): Remove "statusptr" argument.  Adjust.  Return a
	pid instead of a signal.
	(attach_inferior): Remove "status" and "signal" parameters.
	Adjust.
	(handle_query): For qGetTLSAddr, parse the thread id with strtol,
	not as an address.
	(handle_v_cont, handle_v_attach, handle_v_run, handle_v_kill)
	(handle_v_requests, myresume): Remove "status" and "signal"
	parameters.  Adjust.
	(handle_status): New.
	(main): Delete local `status'.  Adjust.
	* remote-utils.c: Include target.h.
	(prepare_resume_reply): Change prototype to take a
	target_waitstatus.  Adjust.

	* linux-low.c (linux_wait): Adjust to new target_ops->wait
	interface.
	* spu-low.c (spu_wait): Adjust.
	* win32-low.c (enum target_waitkind, struct target_waitstatus):
	Delete.
	(win32_wait): Adjust.
@
text
@d46 2
d95 107
d259 1
a259 1
      resume_info.step = 0;
d262 2
a263 1
      ptid = mywait (&last_status, 0);
d271 1
a271 1
 	  mywait (&last_status, 0);
d282 1
a282 1
  last_ptid = mywait (&last_status, 0);
d306 3
a308 1
  last_ptid = mywait (&last_status, 0);
d310 7
a316 6
  /* GDB knows to ignore the first SIGSTOP after attaching to a running
     process using the "attach" command, but this is different; it's
     just using "target remote".  Pretend it's just starting up.  */
  if (last_status.kind == TARGET_WAITKIND_STOPPED
      && last_status.value.sig == TARGET_SIGNAL_STOP)
    last_status.value.sig = TARGET_SIGNAL_TRAP;
d404 37
d659 1
d661 10
a670 3
      thread_ptr = all_threads.head;
      sprintf (own_buf, "QC%x",
	       thread_to_gdb_id ((struct thread_info *)thread_ptr));
d1076 3
d1089 1
a1089 1
      unsigned long ptid;
d1252 1
a1252 1
	resume_info[i].step = 1;
d1254 3
a1256 1
	resume_info[i].step = 0;
d1311 3
a1313 1
  if (n == 1 && resume_info[0].thread != -1)
d1319 3
a1321 1
  enable_async_io ();
d1326 8
a1333 3
  last_ptid = mywait (&last_status, 1);
  prepare_resume_reply (own_buf, last_ptid, &last_status);
  disable_async_io ();
d1356 11
a1366 1
      prepare_resume_reply (own_buf, last_ptid, &last_status);
d1449 7
d1465 22
d1502 1
a1502 1
	  strcpy (own_buf, "vCont;c;C;s;S");
d1535 6
d1547 3
d1565 4
a1568 1
      resume_info[0].step = step;
d1576 1
a1576 1
      resume_info[n].step = 0;
d1581 3
a1583 1
  enable_async_io ();
d1585 24
a1608 3
  last_ptid = mywait (&last_status, 1);
  prepare_resume_reply (own_buf, last_ptid, &last_status);
  disable_async_io ();
d1616 18
a1633 3
  if (all_threads.head)
    prepare_resume_reply (own_buf,
			  all_threads.head->id, &last_status);
d1635 7
a1641 1
    strcpy (own_buf, "W00");
a1695 6
  char ch, *own_buf;
  unsigned char *mem_buf;
  int i = 0;
  int signal;
  unsigned int len;
  CORE_ADDR mem_addr;
d1894 2
a1897 1
    restart:
d1908 10
a1917 2
      disable_async_io ();
      while (!exit_requested)
d1919 32
a1950 9
	  unsigned char sig;
	  int packet_len;
	  int new_packet_len = -1;

	  response_needed = 0;
	  packet_len = getpkt (own_buf);
	  if (packet_len <= 0)
	    break;
	  response_needed = 1;
d1952 2
a1953 18
	  i = 0;
	  ch = own_buf[i++];
	  switch (ch)
	    {
	    case 'q':
	      handle_query (own_buf, packet_len, &new_packet_len);
	      break;
	    case 'Q':
	      handle_general_set (own_buf);
	      break;
	    case 'D':
	      require_running (own_buf);
	      fprintf (stderr, "Detaching from inferior\n");
	      if (detach_inferior () != 0)
		write_enn (own_buf);
	      else
		{
		  write_ok (own_buf);
d1955 1
a1955 17
		  if (extended_protocol)
		    {
		      /* Treat this like a normal program exit.  */
		      last_status.kind = TARGET_WAITKIND_EXITED;
		      last_status.value.integer = 0;
		      last_ptid = signal_pid;
		    }
		  else
		    {
		      putpkt (own_buf);
		      remote_close ();

		      /* If we are attached, then we can exit.  Otherwise, we
			 need to hang around doing nothing, until the child
			 is gone.  */
		      if (!attached)
			join_inferior ();
d1957 36
a1992 15
		      exit (0);
		    }
		}
	      break;
	    case '!':
	      extended_protocol = 1;
	      write_ok (own_buf);
	      break;
	    case '?':
	      handle_status (own_buf);
	      break;
	    case 'H':
	      if (own_buf[1] == 'c' || own_buf[1] == 'g' || own_buf[1] == 's')
		{
		  unsigned long gdb_id, thread_id;
d1994 6
a1999 23
		  require_running (own_buf);
		  gdb_id = strtoul (&own_buf[2], NULL, 16);
		  if (gdb_id == 0 || gdb_id == -1)
		    thread_id = gdb_id;
		  else
		    {
		      thread_id = gdb_id_to_thread_id (gdb_id);
		      if (thread_id == 0)
			{
			  write_enn (own_buf);
			  break;
			}
		    }

		  if (own_buf[1] == 'g')
		    {
		      general_thread = thread_id;
		      set_desired_inferior (1);
		    }
		  else if (own_buf[1] == 'c')
		    cont_thread = thread_id;
		  else if (own_buf[1] == 's')
		    step_thread = thread_id;
d2001 5
a2005 141
		  write_ok (own_buf);
		}
	      else
		{
		  /* Silently ignore it so that gdb can extend the protocol
		     without compatibility headaches.  */
		  own_buf[0] = '\0';
		}
	      break;
	    case 'g':
	      require_running (own_buf);
	      set_desired_inferior (1);
	      registers_to_string (own_buf);
	      break;
	    case 'G':
	      require_running (own_buf);
	      set_desired_inferior (1);
	      registers_from_string (&own_buf[1]);
	      write_ok (own_buf);
	      break;
	    case 'm':
	      require_running (own_buf);
	      decode_m_packet (&own_buf[1], &mem_addr, &len);
	      if (read_inferior_memory (mem_addr, mem_buf, len) == 0)
		convert_int_to_ascii (mem_buf, own_buf, len);
	      else
		write_enn (own_buf);
	      break;
	    case 'M':
	      require_running (own_buf);
	      decode_M_packet (&own_buf[1], &mem_addr, &len, mem_buf);
	      if (write_inferior_memory (mem_addr, mem_buf, len) == 0)
		write_ok (own_buf);
	      else
		write_enn (own_buf);
	      break;
	    case 'X':
	      require_running (own_buf);
	      if (decode_X_packet (&own_buf[1], packet_len - 1,
				   &mem_addr, &len, mem_buf) < 0
		  || write_inferior_memory (mem_addr, mem_buf, len) != 0)
		write_enn (own_buf);
	      else
		write_ok (own_buf);
	      break;
	    case 'C':
	      require_running (own_buf);
	      convert_ascii_to_int (own_buf + 1, &sig, 1);
	      if (target_signal_to_host_p (sig))
		signal = target_signal_to_host (sig);
	      else
		signal = 0;
	      myresume (own_buf, 0, signal);
	      break;
	    case 'S':
	      require_running (own_buf);
	      convert_ascii_to_int (own_buf + 1, &sig, 1);
	      if (target_signal_to_host_p (sig))
		signal = target_signal_to_host (sig);
	      else
		signal = 0;
	      myresume (own_buf, 1, signal);
	      break;
	    case 'c':
	      require_running (own_buf);
	      signal = 0;
	      myresume (own_buf, 0, signal);
	      break;
	    case 's':
	      require_running (own_buf);
	      signal = 0;
	      myresume (own_buf, 1, signal);
	      break;
	    case 'Z':
	      {
		char *lenptr;
		char *dataptr;
		CORE_ADDR addr = strtoul (&own_buf[3], &lenptr, 16);
		int len = strtol (lenptr + 1, &dataptr, 16);
		char type = own_buf[1];

		if (the_target->insert_watchpoint == NULL
		    || (type < '2' || type > '4'))
		  {
		    /* No watchpoint support or not a watchpoint command;
		       unrecognized either way.  */
		    own_buf[0] = '\0';
		  }
		else
		  {
		    int res;

		    require_running (own_buf);
		    res = (*the_target->insert_watchpoint) (type, addr, len);
		    if (res == 0)
		      write_ok (own_buf);
		    else if (res == 1)
		      /* Unsupported.  */
		      own_buf[0] = '\0';
		    else
		      write_enn (own_buf);
		  }
		break;
	      }
	    case 'z':
	      {
		char *lenptr;
		char *dataptr;
		CORE_ADDR addr = strtoul (&own_buf[3], &lenptr, 16);
		int len = strtol (lenptr + 1, &dataptr, 16);
		char type = own_buf[1];

		if (the_target->remove_watchpoint == NULL
		    || (type < '2' || type > '4'))
		  {
		    /* No watchpoint support or not a watchpoint command;
		       unrecognized either way.  */
		    own_buf[0] = '\0';
		  }
		else
		  {
		    int res;

		    require_running (own_buf);
		    res = (*the_target->remove_watchpoint) (type, addr, len);
		    if (res == 0)
		      write_ok (own_buf);
		    else if (res == 1)
		      /* Unsupported.  */
		      own_buf[0] = '\0';
		    else
		      write_enn (own_buf);
		  }
		break;
	      }
	    case 'k':
	      response_needed = 0;
	      if (!target_running ())
		/* The packet we received doesn't make sense - but we
		   can't reply to it, either.  */
		goto restart;
d2007 15
a2021 2
	      fprintf (stderr, "Killing inferior\n");
	      kill_inferior ();
d2023 8
a2030 4
	      /* When using the extended protocol, we wait with no
		 program running.  The traditional protocol will exit
		 instead.  */
	      if (extended_protocol)
a2031 26
		  last_status.kind = TARGET_WAITKIND_EXITED;
		  last_status.value.sig = TARGET_SIGNAL_KILL;
		  was_running = 0;
		  goto restart;
		}
	      else
		{
		  exit (0);
		  break;
		}
	    case 'T':
	      {
		unsigned long gdb_id, thread_id;

		require_running (own_buf);
		gdb_id = strtoul (&own_buf[1], NULL, 16);
		thread_id = gdb_id_to_thread_id (gdb_id);
		if (thread_id == 0)
		  {
		    write_enn (own_buf);
		    break;
		  }

		if (mythread_alive (thread_id))
		  write_ok (own_buf);
		else
a2032 29
	      }
	      break;
	    case 'R':
	      response_needed = 0;

	      /* Restarting the inferior is only supported in the
		 extended protocol.  */
	      if (extended_protocol)
		{
		  if (target_running ())
		    kill_inferior ();
		  fprintf (stderr, "GDBserver restarting\n");

		  /* Wait till we are at 1st instruction in prog.  */
		  if (program_argv != NULL)
		    start_inferior (program_argv);
		  else
		    {
		      last_status.kind = TARGET_WAITKIND_EXITED;
		      last_status.value.sig = TARGET_SIGNAL_KILL;
		    }
		  goto restart;
		}
	      else
		{
		  /* It is a request we don't understand.  Respond with an
		     empty packet so that gdb knows that we don't support this
		     request.  */
		  own_buf[0] = '\0';
a2034 11
	    case 'v':
	      /* Extended (long) request.  */
	      handle_v_requests (own_buf, packet_len, &new_packet_len);
	      break;

	    default:
	      /* It is a request we don't understand.  Respond with an
		 empty packet so that gdb knows that we don't support this
		 request.  */
	      own_buf[0] = '\0';
	      break;
d2037 1
a2037 10
	  if (new_packet_len != -1)
	    putpkt_binary (own_buf, new_packet_len);
	  else
	    putpkt (own_buf);

	  response_needed = 0;

	  if (was_running
	      && (last_status.kind == TARGET_WAITKIND_EXITED
		  || last_status.kind == TARGET_WAITKIND_SIGNALLED))
d2039 1
a2039 14
	      was_running = 0;

	      if (last_status.kind == TARGET_WAITKIND_EXITED)
		fprintf (stderr,
			 "\nChild exited with status %d\n",
			 last_status.value.integer);
	      else if (last_status.kind == TARGET_WAITKIND_SIGNALLED)
		fprintf (stderr, "\nChild terminated with signal = 0x%x (%s)\n",
			 target_signal_to_host (last_status.value.sig),
			 target_signal_to_name (last_status.value.sig));

	      if (extended_protocol)
		goto restart;
	      else
d2041 8
a2048 3
		  fprintf (stderr, "GDBserver exiting\n");
		  remote_close ();
		  exit (0);
d2050 3
d2054 4
d2059 1
a2059 3
	  if (last_status.kind != TARGET_WAITKIND_EXITED
	      && last_status.kind != TARGET_WAITKIND_SIGNALLED)
	    was_running = 1;
d2061 139
d2201 3
a2203 4
      /* If an exit was requested (using the "monitor exit" command),
	 terminate now.  The only other way to get here is for
	 getpkt to fail; close the connection and reopen it at the
	 top of the loop.  */
d2205 9
a2213 1
      if (exit_requested)
a2214 5
	  remote_close ();
	  if (attached && target_running ())
	    detach_inferior ();
	  else if (target_running ())
	    kill_inferior ();
d2216 44
d2263 33
a2295 2
	  fprintf (stderr, "Remote side has terminated connection.  "
			   "GDBserver will reopen the connection.\n");
d2297 1
d2301 37
@


1.92
log
@	* target.h (struct thread_resume): Delete leave_stopped member.
	(struct target_ops): Add a `n' argument to the `resume' callback.
	* server.c (start_inferior): Adjust.
	(handle_v_cont, myresume): Adjust.
	* linux-low.c (check_removed_breakpoint): Adjust to resume
	interface change, and to removed leave_stopped field.
	(resume_ptr): Delete.
	(struct thread_resume_array): New.
	(linux_set_resume_request): Add new `arg' parameter.  Adjust to
	resume interface change.
	(linux_continue_one_thread, linux_queue_one_thread)
	(resume_status_pending_p): Check if the resume field is NULL
	instead of checking the leave_stopped member.
	(linux_resume): Adjust to the target resume interface change.
	* spu-low.c (spu_resume): Adjust to the target resume interface
	change.
	* win32-low.c (win32_detach, win32_resume): Ditto.
@
text
@d38 1
a38 2
unsigned long thread_from_wait;
unsigned long old_thread_from_wait;
d89 4
d100 1
a100 1
start_inferior (char **argv, char *statusptr)
d147 1
a147 1
      int sig;
d153 3
a155 3
      sig = mywait (statusptr, 0);
      if (*statusptr != 'T')
	return sig;
d161 3
a163 3
	  sig = mywait (statusptr, 0);
	  if (*statusptr != 'T')
	    return sig;
d165 1
a165 1
      while (sig != TARGET_SIGNAL_TRAP);
d167 1
a167 1
      return sig;
d170 5
a174 3
  /* Wait till we are at 1st instruction in program, return signal
     number (assuming success).  */
  return mywait (statusptr, 0);
d178 1
a178 1
attach_inferior (int pid, char *statusptr, int *sigptr)
d196 1
a196 1
  *sigptr = mywait (statusptr, 0);
d201 3
a203 2
  if (*statusptr == 'T' && *sigptr == TARGET_SIGNAL_STOP)
    *sigptr = TARGET_SIGNAL_TRAP;
d926 1
a926 1
      CORE_ADDR parts[3], address = 0;
d928 1
d952 4
a955 1
	  decode_address (&parts[i], p, len);
d963 1
a963 1
	  struct thread_info *thread = gdb_id_to_thread (parts[0]);
d968 1
a968 1
	    err = the_target->get_tls_address (thread, parts[1], parts[2],
d1064 1
a1064 1
handle_v_cont (char *own_buf, char *status, int *signal)
d1159 2
a1160 2
  *signal = mywait (status, 1);
  prepare_resume_reply (own_buf, *status, *signal);
d1172 1
a1172 1
handle_v_attach (char *own_buf, char *status, int *signal)
d1177 1
a1177 1
  if (pid != 0 && attach_inferior (pid, status, signal) == 0)
d1184 1
a1184 1
      prepare_resume_reply (own_buf, *status, *signal);
d1196 1
a1196 1
handle_v_run (char *own_buf, char *status, int *signal)
d1263 2
a1264 2
  *signal = start_inferior (program_argv, status);
  if (*status == 'T')
d1266 1
a1266 1
      prepare_resume_reply (own_buf, *status, *signal);
d1278 1
a1278 2
handle_v_requests (char *own_buf, char *status, int *signal,
		   int packet_len, int *new_packet_len)
d1285 1
a1285 1
	  handle_v_cont (own_buf, status, signal);
d1308 1
a1308 1
      handle_v_attach (own_buf, status, signal);
d1320 1
a1320 1
      handle_v_run (own_buf, status, signal);
d1331 1
a1331 1
myresume (char *own_buf, int step, int *signalp, char *statusp)
a1334 1
  int sig = *signalp;
d1360 2
a1361 2
  *signalp = mywait (statusp, 1);
  prepare_resume_reply (own_buf, *statusp, *signalp);
d1365 12
d1429 1
a1429 1
  char ch, status, *own_buf;
d1586 1
a1586 1
      signal = start_inferior (program_argv, &status);
d1594 1
a1594 1
      if (attach_inferior (pid, &status, &signal) == -1)
d1601 3
a1603 2
      status = 'W';
      signal = 0;
d1618 2
a1619 1
  if (status == 'W' || status == 'X')
d1681 3
a1683 2
		      signal = 0;
		      status = 'W';
d1705 1
a1705 1
	      prepare_resume_reply (own_buf, status, signal);
d1788 1
a1788 1
	      myresume (own_buf, 0, &signal, &status);
d1797 1
a1797 1
	      myresume (own_buf, 1, &signal, &status);
d1802 1
a1802 1
	      myresume (own_buf, 0, &signal, &status);
d1807 1
a1807 1
	      myresume (own_buf, 1, &signal, &status);
d1886 2
a1887 2
		  status = 'X';
		  signal = TARGET_SIGNAL_KILL;
d1928 1
a1928 1
		    signal = start_inferior (program_argv, &status);
d1931 2
a1932 2
		      status = 'X';
		      signal = TARGET_SIGNAL_KILL;
d1946 1
a1946 2
	      handle_v_requests (own_buf, &status, &signal,
				 packet_len, &new_packet_len);
d1964 3
a1966 1
	  if (was_running && (status == 'W' || status == 'X'))
d1970 1
a1970 1
	      if (status == 'W')
d1972 3
a1974 2
			 "\nChild exited with status %d\n", signal);
	      if (status == 'X')
d1976 2
a1977 2
			 target_signal_to_host (signal),
			 target_signal_to_name (signal));
d1989 2
a1990 1
	  if (status != 'W' && status != 'X')
@


1.91
log
@	* server.c (main): After the inferior having exited, call
	remote_close before exiting gdbserver.
@
text
@a148 1
      resume_info.leave_stopped = 0;
d156 1
a156 1
	  (*the_target->resume) (&resume_info);
d1058 2
a1059 1
  struct thread_resume *resume_info, default_action;
d1070 2
a1071 4
  /* Allocate room for one extra action, for the default remain-stopped
     behavior; if no default action is in the list, we'll need the extra
     slot.  */
  resume_info = malloc ((n + 1) * sizeof (resume_info[0]));
a1074 5
  default_action.thread = -1;
  default_action.leave_stopped = 1;
  default_action.step = 0;
  default_action.sig = 0;

a1075 1
  i = 0;
a1079 2
      resume_info[i].leave_stopped = 0;

d1134 2
a1135 1
  resume_info[i] = default_action;
d1145 1
a1145 1
  (*the_target->resume) (resume_info);
d1327 1
d1331 3
a1333 1
  if (step || sig || (cont_thread != 0 && cont_thread != -1))
a1338 1
      resume_info[0].leave_stopped = 0;
d1341 8
a1348 4
  resume_info[n].thread = -1;
  resume_info[n].step = 0;
  resume_info[n].sig = 0;
  resume_info[n].leave_stopped = (cont_thread != 0 && cont_thread != -1);
d1351 1
a1351 1
  (*the_target->resume) (resume_info);
@


1.90
log
@	* server.c (handle_query) Whitespace and formatting.
@
text
@d1962 1
@


1.89
log
@	* i387-fp.c, linux-arm-low.c, linux-cris-low.c,
	linux-crisv32-low.c, linux-i386-low.c, linux-low.c,
	linux-mips-low.c, linux-s390-low.c, linux-sparc-low.c,
	linux-x86-64-low.c, linux-xtensa-low.c, proc-service.c,
	regcache.c, remote-utils.c, server.c, spu-low.c, target.h,
	thread-db.c, win32-low.c, xtensa-xtregs.c, gdbreplay.c,
	Makefile.in, configure.ac: Fix whitespace throughout.
	* configure: Regenerate.
@
text
@d577 1
a577 1
	  return;
d588 1
a588 2
	*new_packet_len_p = write_qxfer_response
			      (own_buf, spu_buf, len, 1);
d590 1
a590 2
	*new_packet_len_p = write_qxfer_response
			      (own_buf, spu_buf, n, 0);
d792 1
a792 1
       return;
d794 1
a794 1
       len = PBUFSIZ - 2;
d801 1
a801 1
       write_enn (own_buf);
d803 1
a803 1
       *new_packet_len_p = write_qxfer_response (own_buf, workbuf, len, 1);
d805 1
a805 1
       *new_packet_len_p = write_qxfer_response (own_buf, workbuf, n, 0);
@


1.88
log
@2009-03-14  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* remote.c (PACKET_qAttached): New.
	(remote_query_attached): New.
	(remote_add_inferior): Add new `attached' argument.  Handle it.
	(remote_notice_new_inferior, remote_start_remote): Adjust to pass
	-1 to remote_add_inferior in new parameter.
	(extended_remote_attach_1): Adjust to pass 1 to
	remote_add_inferior in the new parameter.
	(extended_remote_create_inferior_1): Adjust to pass 0 to
	remote_add_inferior in the new parameter.
	(_initialize_remote): Add "set/show remote query-attached-packet"
	commands.

2009-03-14  Pedro Alves  <pedro@@codesourcery.com>

	gdb/gdbserver/
	* server.c (handle_query): Handle "qAttached".

2009-03-14  Pedro Alves  <pedro@@codesourcery.com>

	gdb/doc/
	* gdb.texinfo (Remote Configuration): Document query-attached.
        (General Query Packets): Document qAttached.
@
text
@d334 1
a334 1
  monitor_output ("    Enable general debugging messages\n");  
d526 2
a527 1
	  sprintf (own_buf, "m%x", thread_to_gdb_id ((struct thread_info *)thread_ptr));
d537 2
a538 1
	      sprintf (own_buf, "m%x", thread_to_gdb_id ((struct thread_info *)thread_ptr));
d561 1
a561 1
      
d582 1
a582 1
        return;
d585 1
a585 1
      if (n < 0) 
d590 1
a590 1
      else 
d611 1
a611 1
        return;
d619 1
a619 1
      n = (*the_target->qxfer_spu) 
d799 1
a799 1
        return;
d805 1
a805 2
       *new_packet_len_p = write_qxfer_response
                             (own_buf, workbuf, len, 1);
d807 1
a807 2
       *new_packet_len_p = write_qxfer_response
                             (own_buf, workbuf, n, 0);
d838 1
a838 1
        return;
d865 1
a865 1
        return;
d913 1
a913 1
        strcat (own_buf, ";qXfer:osdata:read+");
d1257 1
a1257 1
	}	  
d1901 1
a1901 1
	         extended protocol.  */
d1934 2
a1935 2
	         empty packet so that gdb knows that we don't support this
	         request.  */
@


1.87
log
@2009-02-06  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* target.h (enum target_object): Add new TARGET_OBJECT_SIGNAL_INFO.
	* infrun.c (siginfo_value_read, siginfo_value_write): New.
	(siginfo_value_funcs): New.
	(siginfo_make_value): New.
	(_initialize_infrun): Create the $_siginfo convenience variable.
	* gdbtypes.h (append_composite_type_field_aligned): Declare.
	* gdbtypes.c (append_composite_type_field): Rename to...
	(append_composite_type_field_aligned): ... this.  Add ALIGNMENT
	argument.  Handle it.
	(append_composite_type_field): Rewrite on top of
	append_composite_type_field_aligned.
	* value.h (internalvar_make_value): New typedef.
	(struct internalvar) <make_value>: New field.
	(create_internalvar_type_lazy): Declare.
	* value.c (create_internalvar): Clear make_value.
	(create_internalvar_type_lazy): New.
	(value_of_internalvar): If make_value is set use it.
	(preserve_values): Skip internal variables that don't have a
	value.
	* gdbarch.sh (get_siginfo_type): New.
	* gdbarch.h, gdbarch.c: Regenerate.

	* linux-tdep.h, linux-tdep.c: New.
	* amd64-linux-tdep.c: Include "linux-tdep.h".
	(amd64_linux_init_abi): Register linux_get_siginfo_type and
	linux_get_siginfo_mapper.
	* i386-linux-tdep.c: Include "linux-tdep.h".
	(i386_linux_init_abi): Register linux_get_siginfo_type and
	linux_get_siginfo_mapper.
	* arm-linux-tdep.c: Include "linux-tdep.h".
	(i386_linux_init_abi): Register linux_get_siginfo_type and
	linux_get_siginfo_mapper.

	* linux-nat.c (linux_xfer_siginfo): New.
	(linux_nat_xfer_partial): Handle TARGET_OBJECT_SIGNAL_INFO.
	* remote.c (PACKET_qXfer_siginfo_read)
	(PACKET_qXfer_siginfo_write): New.
	(feature remote_protocol_features): Add "qXfer:siginfo:read" and
	"qXfer:siginfo:write" features.
	(remote_xfer_partial): Handle TARGET_OBJECT_SIGNAL_INFO.
	(_initialize_remote): Add "set/show remote read-siginfo-object"
	and "set/show remote write-siginfo-object" commands.

	* Makefile.in (ALL_TARGET_OBS): Add linux-tdep.o.
	(HFILES_NO_SRCDIR): Add linux-tdep.h.
	(ALLDEPFILES): Add linux-tdep.c.

	* configure.tgt (arm*-*-linux* | arm*-*-uclinux*)
	(i[34567]86-*-linux*, x86_64-*-linux*): Add linux-tdep.o to
	gdb_target_obs.

2009-02-06  Pedro Alves  <pedro@@codesourcery.com>

	gdb/gdbserver/
	* server.c (handle_query): Report qXfer:siginfo:read and
	qXfer:siginfo:write as supported and handle them.
	* target.h (struct target_ops) <qxfer_siginfo>: New field.
	* linux-low.c (linux_xfer_siginfo): New.
	(linux_target_ops): Set it.

2009-02-06  Pedro Alves  <pedro@@codesourcery.com>

	gdb/doc/
	* gdb.texinfo (Signals): Document $_siginfo.
	(Convenience Variables): Mention $_siginfo.
	(Remote Configuration): Document qXfer:siginfo:read,
	qXfer:siginfo:write packets, and the read-siginfo-object,
	write-siginfo-object commands.

2009-02-06  Pedro Alves  <pedro@@codesourcery.com>

	gdb/testsuite/
	* gdb.base/siginfo-obj.c, gdb.base/siginfo-obj.exp: New.
@
text
@d1043 7
@


1.86
log
@gdb/gdbserver/
	* server.c (gdbserver_usage): Mention --remote-debug.
	(main): Accept '--remote-debug' switch.

gdb/doc/
	* gdb.texinfo (Using the `gdbserver' Program): Document
	--remote-debug.
@
text
@d813 71
d900 3
@


1.85
log
@	* regcache.c (new_register_cache): No need to check result of xcalloc.
	* server.c (handle_search_memory): Back out calls to xmalloc,
	result is checked and error is returned to user upon failure.
	(handle_query): Ditto.  Add more checks for result of malloc.
	(handle_v_cont): Check result of malloc, report error back to
	user upon failure.
	(handle_v_run): Ditto.  Call freeargv.
	* server.h (freeargv): Declare.
	* utils.c (freeargv): New fn.
@
text
@d1302 4
a1305 3
	   "  --debug\t\tEnable debugging output.\n"
	   "  --version\t\tDisplay version information and exit.\n"
	   "  --wrapper WRAPPER --\tRun WRAPPER to start new programs.\n");
d1382 2
@


1.84
log
@	* gdbreplay.c (gdbreplay_version): Update copyright year.
	* server.c (gdbserver_version): Likewise.
@
text
@d439 1
a439 1
  pattern = xmalloc (packet_len);
d463 1
a463 1
  search_buf = xmalloc (search_buf_size);
d578 1
a578 1
      spu_buf = xmalloc (len + 1);
d607 1
a607 1
      spu_buf = xmalloc (packet_len - 15);
d651 6
a656 1
      data = xmalloc (len + 1);
d734 6
a739 1
      document = xmalloc (total_len);
d795 1
a795 1
      workbuf = xmalloc (len + 1);
d908 1
a908 1
      char *mon = xmalloc (PBUFSIZ);
d911 6
d994 3
a996 1
  resume_info = xmalloc ((n + 1) * sizeof (resume_info[0]));
d1118 1
a1118 1
  char *p, **pp, *next_p, **new_argv;
d1128 7
a1134 1
  new_argv = xcalloc (new_argc + 2, sizeof (char *));
d1146 1
d1165 1
d1170 7
a1176 1
      new_argv[0] = xstrdup (program_argv[0]);
d1179 2
a1180 7
  /* Free the old argv.  */
  if (program_argv)
    {
      for (pp = program_argv; *pp != NULL; pp++)
	free (*pp);
      free (program_argv);
    }
@


1.83
log
@        Updated copyright notices for most files.
@
text
@d1258 1
a1258 1
	  "Copyright (C) 2007 Free Software Foundation, Inc.\n"
@


1.82
log
@	* utils.c (xmalloc,xcalloc,xstrdup): New fns.
	* server.h (ATTR_MALLOC): New macro.
	(xmalloc,xcalloc,xstrdup): Declare.
	* hostio.c: Replace malloc,calloc,strdup with xmalloc,xcalloc,xstrdup.
	* inferiors.c: Ditto.
	* linux-low.c: Ditto.
	* mem-break.c: Ditto.
	* regcache.c: Ditto.
	* remote-utils.c: Ditto.
	* server.c: Ditto.
	* target.c: Ditto.
	* win32-low.c: Ditto.
@
text
@d3 1
a3 1
   2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
@


1.81
log
@	Implement -list-thread-groups --available

        * Makefile.in (XMLFILES): Add osdata.dtd.
        (SFILES): Add osdata.c.
        (COMMON_OBS): Add osdata.o.
        * linux-nat.c: Include pwd.h, sys/types.h, gdb_dirent.h and xml-support.h.
        (linux_nat_xfer_osdata): New function.
        (linux_xfer_partial): Handle TARGET_OBJECT_OSDATA.
        * osdata.c: New file.
        * osdata.h: New file.
        * remote.c (PACKET_qXfer_osdata): New packet enum.
        (remote_protocol_features): Add "qXfer:osdata:read".
        (remote_read_qxfer): Handle TARGET_OBJECT_OSDATA.
        (extended_remote_can_run): New.
        (init_extended_remote_ops): Set to_can_run to
        extended_remote_can_run.
        (_initialize_remote): Add packet config command for
        "qXfer:osdata:read".
        * xml-support.c (obstack_xml_printf): New function.
        * xml-support.h (obstack_xml_printf): Declare.
        * target.c (target_get_osdata): New function.
        * target.h (enum target_object): Add TARGET_OBJECT_OSDATA.
        (target_os_data): Declare.
        * features/osdata.dtd: New file.
        * mi/mi-main.c (mi_list_thread_groups): Handle the --available
        option.
@
text
@d439 1
a439 1
  pattern = malloc (packet_len);
d463 1
a463 1
  search_buf = malloc (search_buf_size);
d578 1
a578 1
      spu_buf = malloc (len + 1);
d607 1
a607 1
      spu_buf = malloc (packet_len - 15);
d651 1
a651 1
      data = malloc (len + 1);
d729 1
a729 1
      document = malloc (total_len);
d785 1
a785 1
      workbuf = malloc (len + 1);
d898 1
a898 1
      char *mon = malloc (PBUFSIZ);
d978 1
a978 1
  resume_info = malloc ((n + 1) * sizeof (resume_info[0]));
d1110 1
a1110 1
  new_argv = calloc (new_argc + 2, sizeof (char *));
d1122 1
a1122 1
	  new_argv[i] = malloc (1 + (next_p - p) / 2);
d1144 1
a1144 1
      new_argv[0] = strdup (program_argv[0]);
d1446 2
a1447 2
  own_buf = malloc (PBUFSIZ + 1);
  mem_buf = malloc (PBUFSIZ);
d1454 1
a1454 1
      program_argv = malloc (sizeof (char *) * (n + 1));
d1456 1
a1456 1
	program_argv[i] = strdup (next_arg[i]);
@


1.80
log
@	* server.c (handle_v_run): Always use the supplied argument list.
@
text
@d771 32
d827 4
@


1.79
log
@	* server.c (handle_v_run): If GDB didn't specify an argv, use the
	whole argv from the last run, not just argv[0].
@
text
@d1074 1
a1074 1
  new_argv = malloc ((new_argc + 2) * sizeof (char *));
d1099 2
a1100 4
      /* GDB didn't specify a program to run.  Try to use the argv
	 from the last run: either from the last vRun with a non-empty
	 argv, or from what the user specified if gdbserver was
	 started as: `gdbserver :1234 PROG ARGS'.  */
d1108 1
a1108 2
      /* We can reuse the old args.  We don't need this then.  */
      free (new_argv);
d1110 3
a1112 1
  else
d1114 3
a1116 8
      /* Free the old argv.  */
      if (program_argv)
	{
	  for (pp = program_argv; *pp != NULL; pp++)
	    free (*pp);
	  free (program_argv);
	}
      program_argv = new_argv;
d1118 1
@


1.79.2.1
log
@2008-11-25  Pedro Alves  <pedro@@codesourcery.com>

	2008-10-13  Pedro Alves  <pedro@@codesourcery.com>

	* server.c (discard_pending_stop_replies): Initialize prev.

	2008-10-12  Pedro Alves  <pedro@@codesourcery.com>

	* linux-low.c (linux_wait_1): Cancel breakpoint hits in threads
	we're not reporting.
	(cancel_breakpoints_callback): New.

	2008-10-12  Pedro Alves  <pedro@@codesourcery.com>

	* server.c (queue_stop_reply_callback, handle_status): Pass
	TARGET_SIGNAL_TRAP, not TARGET_SIGNAL_0.

	* linux-low.c (ptid_is_pid): Delete.
	(linux_wait_for_event): In non-stop, don't set the current
	inferior arbitrarily.
	(linux_wait): Flush the event pipe before polling for an event.
	(wait_for_sigstop): In non-stop, don't set the current
	inferior arbitrarily.
	(linux_resume_one_lwp): Small cleanup.
	(cancel_breakpoint): New.
	(linux_resume_one_thread): Use it.  Still report SIGTRAPs.
	(regsets_store_inferior_registers): Plug leak.
	(sigchld_handler): Don't use fprintf here.

	* mem-break.c (breakpoint_at): New.
	* inferiors.c (ptid_is_pid): New.
	* mem-break.h (breakpoint_at): Declare.
	* server.c (discard_queued_stop_replies): Add `pid' argument.
	Handle it.
	(send_next_stop_reply): Cleanup.
	(attach_inferior): Don't wait here in non-stop mode.
	(handle_v_attach): Don't queue stop replies here.
	(handle_v_kill): Discard queued stop replies of the inferior we
	just killed.
	(queue_stop_reply_callback): Add `arg' argument.  Handle it.
	(handle_status): Adjust.
	(kill_inferior_callback): Discard queued stop replies of the
	inferior we just killed.
	(detach_or_kill_inferior_callback): Discard queued stop replies of
	the inferior we just killed or detached from.
	(process_serial_event): Cleanup.  Discard queued stop replies of
	the inferior we just detached.  Don't write 0 bytes to the inferior.
	(handle_serial_event): Debug output.
	* server.h (ptid_is_pid): Declare.

	* remote-utils.c (prepare_resume_reply): Avoid reading registers
	and memory from a thread that is gone.

	2008-09-26  Pedro Alves  <pedro@@codesourcery.com>

	* server.h (struct sym_cache, struct process_info_private):
	Forward declare.
	(struct process_info): Add symbol_cache, all_symbols_looked_up and
	private fields.
	(current_process): Declare.
	* remote-utils.c (struct sym_cache) <name>: Remove constness.
	(symbol_cache): Delete.
	(free_sym_cache, clear_symbol_cache): New.
	(look_up_one_symbol): Adjust, to per-process symbol cache.
	* inferiors.c (current_process): New.

	* linux-low.h: Include "gdb_proc_service.h".
	(struct process_info_private): Define.
	* linux-low.c (thread_db_active): Delete.
	(linux_add_process): New.
	(handle_extended_wait, linux_create_inferior, linux_attach): Use
	it.
	(linux_wait_for_event, linux_look_up_symbols): Adjust.
	(initialize_low): Don't clear the global thread_db_active.
	* thread-db.c (proc_handle, thread_agent): Delete.
	(fixup_proc_handle): New.
	(thread_db_err_str, thread_db_enable_reporting): Use it.  Adjust.
	(thread_db_find_new_threads): Look for the current inferior
	thread, not the first thread in the list.  Use fixup_proc_handle.
	Adjust.
	(thread_db_get_tls_address): Use fixup_proc_handle.
	(thread_db_init): Likewise.  Adjust.

	2008-09-26  Pedro Alves  <pedro@@codesourcery.com>

	* mem-break.c (get_breakpoint_list): Add `create' argument.  Only
	create the list if create is set.
	(remove_breakpoint_list): New.
	(set_breakpoint_at, find_breakpoint_at, check_mem_read)
	(check_mem_write, delete_all_breakpoints): Adjust.

	2008-09-26  Pedro Alves  <pedro@@codesourcery.com>

	* server.c (gdbserver_usage): Describe --remote-debug option.
	(main): Handle --remote-debug switch.

	2008-09-19  Pedro Alves  <pedro@@codesourcery.com>

	Non-stop mode support.

	* linux-low.c (linux_event_pipe): New int array for pipe.
	(target_is_async_p): New.
	(handle_extended_wait): Use my_waitpid.
	(linux_kill_one_lwp): Stop the LWP if it is not stopped already.
	Use my_waitpid, not linux_wait_for_event.  Remove the lwp and the
	corresponding thread from the lists.
	(linux_kill_one_process, linux_kill): Delete.
	(linux_kill_1): Rename back to ...
	(linux_kill) ... this.  Stop the LWP if it is not stopped already.
	Use my_waitpid, not linux_wait_for_event.  Remove the lwp and the
	corresponding thread from the lists.
	(linux_detach_one_lwp): Make sure the LWP is stopped.  Adjust to
	new linux_wait_for_event interface.
	(linux_detach_one_process, linux_detach): Delete.
	(linux_detach_1): Rename back to ...
	(linux_detach): This.
	(linux_join): Add PID argument.  Use my_waitpid instead of
	waitpid.
	(status_pending_p): Ignore suspended threads.
	(my_waitpid): Emulate __WALL.
	(linux_wait_for_lwp): Add 'options' argument.  Handle it.  Use
	my_wait.  If requesting an event from a specific process, leave
	events in other processes pending.
	(resume_stopped_lwps): New.
	(linux_wait_for_event): Delete.
	(linux_wait_for_event_1): Rename back to ...
	(linux_wait_for_event): ... this.  Change interface: add wstat and
	options arguments, return -1 on error, 0 otherwise.  Adjust.  In
	all-stop, resume stopped lwps if there was no pending status.
	Don't return immediatelly if a pending status was found ---
	continue handling it instead.  Don't loop, only handle one event.
	(linux_wait): Rename to ...
	(linux_wait_1): ... this.  Add target_options argument.  Handle
	it.  Don't loop --- only handle one event.  Ignore the continue
	thread in non_stop mode.  Adjust to new resume_kind interface.
	Only stop all threads in all-stop mode.
	(async_file_flush, async_file_mark): New.
	(linux_wait): New.
	(wait_for_sigstop): Set stopping_threads here.  Use
	linux_wait_for_lwp instead of linux_wait_for_event.  Adjust.
	(stop_all_lwps): Don't set stopping_threads here.
	(resume_ptr): Delete.
	(struct resume_info): New.
	(linux_set_resume_request): Add arg argument.  Adjust to take a
	struct remove_info instead of the global resume_ptr.  Accept
	pid,-1 to apply to all threads.
	(linux_continue_one_thread, linux_queue_one_thread): Merge both
	and create ...
	(linux_resume_one_thread): ... this.  New.  Handle rk_stop.
	(resume_status_pending_p): Assume no resume info to mean do
	nothing.  Ignore suspended LWPs.
	(linux_resume): Add n argument.  Adjust.  In non-stop mode, don't
	look for a pending status over all threads.
	(linux_read_offsets): Minor cleanup.
	(sigchld_handler, linux_async, linux_start_non_stop): New.
	(linux_target_ops): Register linux_async and linux_start_non_stop.
	(initialize_low): Register sigchld_handler as SIGCHLD handler.

	* utils.c (internal_verror, internal_error_file_line): New.

	* Makefile.in (SFILES): Add event-loop.c.
	(OBS): Add event-loop.o.
	(event-loop.o): New rule.

	* linux-low.h (struct lwp_info) <suspended>: New flag.

	* thread-db.c (thread_db_create_event): Make sure thread_db reads
	from the current inferior.
	(thread_db_get_tls_address): Comment.

	* server.c (thread_from_wait, old_thread_from_wait, attached):
	Delete.
	(non_stop): New global.
	(own_buf, mem_buf): New globals.
	(struct vstop_notif): New.
	(notif_queue): New.
	(queue_stop_reply, push_event, discard_queued_stop_replies)
	(send_next_stop_reply): New.
	(start_inferior): Adjust to new thread_resume interface.  Adjust
	to new mywait interface.
	(attach_inferior): Adjust.
	(handle_general_set): Handle QNonStop.
	(handle_query): Pass 'QNonStop+'.
	(handle_v_cont): Handle vCont;t.  Don't enable/disable async io in
	non-stop mode.  In non-stop return OK, and don't wait for the
	target.
	(handle_v_attach): In non-stop, return OK, and queue events for
	all threads.
	(handle_v_run): In non-stop, set the general thread here.
	(handle_v_stopped): New.
	(handle_v_requests): Report support for 't'.  Handle 'vStopped'.
	(proceed): Add comment.  Adjust.  In non-stop, don't
	enable/disable async io; write 'OK', and don't wait for the
	target.
	(queue_stop_reply_callback, handle_status): New.
	(kill_inferior_callback, detach_or_kill_inferior_callback)
	(join_inferiors_callback): New.
	(main): In --debug mode, also enable remote debug.  Don't pass -1
	to kill_inferior or detach_inferior; instead, iterate over all
	processes killing or detaching them.  Adjust to use the even-loop.
	(process_serial_event): New, factored out of main.  If the
	connection closed, remove all sources from the event loop.
	Iterate over all inferiors joining them.  Use handle_status.
	Don't print inferior exit notices here.  In non-stop, defer
	exiting until GDB read all queued events.
	(handle_serial_event, handle_target_event): New.

	* server.h (FOR_EACH_INFERIOR): New.
	(thread_from_wait, old_thread_from_wait): Remove.
	(non_stop): Declare.
	(gdb_client_data, handler_func): New typedefs.
	(delete_file_handler, add_file_handler, start_event_loop)
	(handle_serial_event, handle_target_event, push_event)
	(putpkt_notif, internal_error_file_line): Declare.
	(internal_error): Define.

	* target.c (mywait): Add `options' argument.  Print inferior exit
	notices here.
	(start_non_stop): New.

	* event-loop.c: New.

	* remote-utils.c (remote_open): Register remote_desc in the event
	loop, with handle_serial_event as callback.
	(remote_close): Remove remote_desc from the event loop.
	(hex_or_minus_one): New.
	(read_ptid, read_ptid): Use it.
	(putpkt_binary): Rename to ...
	(putpkt_binary_1): ... this.  Add `notif' argument.  Handle
	pushing a remote protocol notification.
	(putpkt_binary): New as wrapper around putpkt_binary_1.
	(putpkt_notif): New.
	(getpkt): Debug output.
	(prepare_resume_reply): Remove dead code.  In non-stop, don't set
	the general thread here.

	* target.h (enum resume_kind): New.
	(struct thread_resume) <leave_stopped, step>: Delete.
	(struct thread_resume) <kind>: New field.
	(TARGET_WNOHANG): Define.
	(struct target_ops) <kill, detach>: Adjust comments.
	(struct target_ops) <join>: Add `pid' argument.
	(struct target_ops) <resume>: Add `n' argument.
	(struct target_ops) <wait>: Add `options' argument.
	(struct target_ops) <async, start_non_stop>: New fields.
	(join_inferior): Add `pid' argument.
	(target_async): New.
	(start_non_stop): Declare.
	(mywait): Add options argument.

	2008-09-15  Pedro Alves  <pedro@@codesourcery.com>

	* linux-low.c (new_inferior): Mention in the comment that all
	inferiors should have the same architecture for now.
	(linux_create_inferior, linux_attach): Only set new_inferior if
	this is the first process.

	2008-08-29  Pedro Alves  <pedro@@codesourcery.com>

	* linux-low.c (ptid_is_pid): Move higher.
	(linux_wait_for_lwp): Remove dead code.
	(linux_wait_for_event): Rename to ...
	(linux_wait_for_event_1): ... this.
	(linux_wait_for_event): New.
	(ptid_same_pid): Delete.
	(linux_set_resume_request): Clearify.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* linux-low.c (handle_extended_wait, linux_attach_lwp)
	(linux_attach): Minor cleanups.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* linux-low.c (linux_thread_alive): Return false for a listed
	thread known to be dead.
	(linux_wait_for_event): Don't set the dead flag here.
	(wait_for_sigstop): Store ptid before waiting for the event.
	Minor cleanup.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* inferiors.c (find_inferior): Allow deleting the current iterated
	inferior.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* linux-low.c (linux_pid_to_exec_file): Move higher.
	(linux_enable_event_reporting): Enable PTRACE_O_TRACEEXEC.
	(handle_extended_wait): Handle PTRACE_EVENT_EXEC.

	* remote-utils.c (prepare_resume_reply): Set the general thread to
	the last thread that had an event in TARGET_WAITKIND_FORKED and
	TARGET_WAITKIND_VFORKED.  Handle TARGET_WAITKIND_EXECD.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* server.c (handle_query): Pass "QExecFile:PID;" back in the reply.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* linux-low.c (linux_supports_tracefork_flag): Move higher.
	(linux_enable_event_reporting): New.
	(handle_extended_wait): Change return type to int.  Handle
	PTRACE_EVENT_FORK and PTRACE_EVENT_VFORK.
	(add_lwp): Set waitstatus.kind to TARGET_WAITKIND_IGNORE.
	(linux_attach_lwp): Use linux_enable_event_reporting.
	(linux_wait_for_event): Don't keep waiting if the extended wait
	status should be reported to gdb.
	(linux_wait): Use linux_enable_event_reporting.  If waitstatus
	holds a processed event, return it instead.
	* remote-utils.c (prepare_resume_reply): Handle
	TARGET_WAITKIND_FORKED and TARGET_WAITKIND_VFORKED.
	* linux-low.h (struct lwp_info) <waitstatus>: New member.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* target.h (struct target_ops) <pid_to_exec_file>: New member.
	* server.c (handle_query): Handle qExecFile.
	* linux-low.c (linux_pid_to_exec_file): New.
	(linux_target_ops): Register it.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* linux-low.c (is_lwpid): New.
	(linux_kill_one_lwp, linux_kill_1, linux_detach_one_lwp): Adjust.
	(status_pending_p): Check if we're interested in this lwp.
	(linux_wait_for_lwp): Change signature: return an lwp_info*, and
	take a ptid instead of an lwp_info**.
	(linux_wait_for_event): Take a ptid instead of a thread_info
	pointer.  Adjust.
	(wait_for_sigstop): Adjust.  If a whole process died, keep the
	exit status pending.
	(ptid_is_pid, ptid_same_pid): New.
	(linux_set_resume_request): Allow resuming all threads of a process.
	(resume_status_pending_p): Check for dead lwps.

	* linux-low.h (struct lwp_info) <dead>: New field.

	* server.c (start_inferior): Only resume and wait for events from
	the inferior we're creating.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	Decouple target code from remote protocol.

	* linux-low.c (linux_wait): Change prototype.  Adjust.
	* server.c (last_status, last_ptid): New.
	(start_inferior): Remove "statusptr" argument.  Adjust.
	(attach_inferior, handle_v_cont, handle_v_attach, handle_v_run)
	(handle_v_kill, handle_v_requests): Remove "status" and "signal"
	parameters.  Adjust.
	(myresume): Rename to ...
	(proceed): ... this.  Remove "statusp" parameter.  Adjust.
	(main): Remove "status" local.  Adjust.
	* target.c (mywait): Change prototype.  Adjust.
	* target.h (enum target_waitkind): New.
	(struct target_waitstatus): New.
	(struct target_ops) <wait>: Change prototype.
	(mywait): Adjust.
	* remote-utils.c: Include "target.h".
	(prepare_resume_reply): Change prototype to take a ptid and a
	target_waitstatus.  Adjust.
	* server.h (prepare_resume_reply): Adjust prototype.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* inferiors.c (all_processes): New.
	(add_process): New.

	* linux-low.c (linux_create_inferior): Add process.
	(linux_attach_lwp): Add "initial" parameter, and use it instead of
	relying on having only one thread in the global list.
	(linux_attach): Add process.
	(struct counter): New.
	(check_if_last_thread_of_pid, is_last_thread_of_process): New.
	(linux_kill_one_lwp): Add ARGS parameter.  Change return type to
	int.  Check if we're interested in this lwp.  Use
	is_last_thread_of_process.
	(linux_kill): Rename to ...
	(linux_kill_1): ... this.  Kill lwps of the requested only.
	(linux_kill_one_process): New.
	(linux_kill): New.
	(linux_detach_one_lwp): Add ARGS parameter.  Change return type to
	int.  Check if we're interested in this lwp.  Remove the lwp from
	both the lwp list and the thread list.
	(any_thread_of, linux_detach_1, linux_detach_one_process): New.
	(linux_detach): Reimplement.
	(linux_wait_for_event): Use is_last_thread_of_process.
	(linux_wait): Likewise.  On process exit, don't clear all inferiors.
	Implement multi-process extensions.

	* mem-break.c (breakpoints): Delete.
	(struct breakpoint_list): New.
	(all_breakpoints): New.
	(get_breakpoint_list): New.
	(set_breakpoint_at, delete_breakpoint, find_breakpoint_at)
	(check_mem_read, check_mem_write, delete_all_breakpoints): Use it.

	* server.h (struct process_info): New.
	(all_processes): Declare.
	(add_process): Declare.

	* linux-low.h (linux_attach_lwp): Add "initial" parameter.

	* thread-db.c (maybe_attach_thread): Adjust.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* linux-low.c, linux-low.h, proc-service.c, thread-db.c: Rename
	`struct process_info' to `struct lwp_info', and adjust throughout.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	Implement remote protocol multi-process extensions.

	* inferiors.c (null_ptid, minus_one_ptid): New.
	(ptid_build, pid_to_ptid, ptid_get_pid, ptid_get_lwp)
	(ptid_get_tid, ptid_equal): New functions.
	(add_thread): Drop gdb_id argument.  Retype thread_id argument to
	ptid_t.  Adjust.
	(thread_id_to_gdb_id): Adjust.
	(thread_to_gdb_id): Change return type to ptid_t.  Adjust.
	(gdb_id_to_thread): Rename to ...
	(find_thread_pid): ... this.  Adjust.
	(gdb_id_to_thread_id): Change return type to ptid_t.  Adjust.
	(find_inferior_id): Change id argument type to ptid_t.  Adjust.
	(loaded_dll, add_pid_to_list, pull_pid_from_list): Adjust.
	(initialize_inferiors): New.

	* remote-utils.c (hexchars): New.
	(ishex, unpack_varlen_hex, write_ptid, read_ptid): New.
	(prepare_resume_reply): Adjust.

	* server.c (cont_thread, general_thread, step_thread)
	(thread_from_wait, old_thread_from_wait): Change type to ptid_t.
	(multi_process): New.
	(start_inferior): Adjust.
	(handle_query): Adjust.  Report multiprocess extensions support.
	(handle_v_cont): Adjust.
	(handle_v_kill): New.
	(handle_v_requests): Handle vKill.
	(myresume): Adjust.
	(first_thread_of): New.
	(main): Call initialize_inferiors.  If bailing out, kill all
	inferiors.  Handle multi-process detach.  Handle multi-process H
	and T.

	* server.h (ULONGEST): New typedef.
	(struct ptid): New struct.
	(ptid_t): New typedef.
	(minus_one_ptid, null_ptid): New.
	(ptid_t ptid_build, pid_to_ptid, ptid_get_pid, ptid_get_lwp)
	(ptid_get_tid, ptid_equal): New.
	(struct inferior_list_entry) <id>: Change type to ptid_t.
	(add_thread, thread_id_to_gdb_id, thread_to_gdb_id)
	(gdb_id_to_thread_id): Adjust prototypes.
	(find_thread_pid): Declare.
	(find_inferior_id): Adjust prototype.
	(cont_thread, general_thread, step_thread, thread_from_wait)
	(old_thread_from_wait): Adjust type to ptid_t.
	(multi_process): Declare.
	(read_ptid, write_ptid): Declare.

	* linux-low.c (pid_of): Adjust.
	(lwpid_of): New.
	(inferior_lwpid): New.
	(handle_extended_wait): Adjust.
	(add_process): Change pid argument to a ptid.  Adjust.
	(linux_create_inferior): Adjust.
	(linux_attach_lwp): Adjust.  Clear new_inferior on error.  If
	creating a new inferior, don't rely on inferior_pid, instead use
	the lwpid as pid.
	(linux_attach): Set new_inferior earlier.  Adjust.
	(linux_kill): Change return type to int.  Adjust.
	(linux_detach): Add pid parameter.
	(linux_thread_alive): Change lwpid paremeter type to ptid.
	Adjust.
	(same_lwp, find_lwp_pid): New.
	(linux_wait_for_process): Adjust.
	(linux_wait_for_process, linux_wait_for_event, send_sigstop)
	(wait_for_sigstop, linux_resume_one_process,
	(linux_resume_one_process, linux_set_resume_request)
	(linux_continue_one_thread, linux_queue_one_thread)
	(fetch_register, usr_store_inferior_registers)
	(regsets_fetch_inferior_registers)
	(regsets_store_inferior_registers, linux_read_memory)
	(linux_write_memory, linux_request_interrupt, linux_read_auxv):
	Adjust.

	* linux-low.h (get_process_thread): Adjust.
	(struct process_info) <lwpid>: Remove.
	(find_lwp_pid): Declare.

	* target.c (set_desired_inferior): Adjust.
	(target_pid_to_str): New.

	* target.h (struct thread_resume) <thread>: Change type to ptid_t.
	(struct target_ops) <kill>: Change return type to int, and take an
	int as parameter.
	(struct target_ops) <detach>: Take an int as parameter.
	(struct target_ops) <thread_alive>: Change pid argument type to
	ptid_t.
	(kill_inferior, detach_inferior): Add PID argument.

	* thread-db.c (thread_db_create_event): Adjust.
	(find_one_thread): Change argument to a ptid.  Adjust.
	(maybe_attach_thread, thread_db_get_tls_address, thread_db_init):
	Adjust.

	* proc-service.c (ps_lgetregs): Adjust.
@
text
@d35 5
a39 4
ptid_t cont_thread;
ptid_t general_thread;
ptid_t step_thread;

d43 1
a46 3
int multi_process;
int non_stop;

a89 117
/* Last status reported to GDB.  */
static struct target_waitstatus last_status;
static ptid_t last_ptid;

static char *own_buf;
static unsigned char *mem_buf;

/* Structure holding information relative to a single stop reply.  We
   keep a queue of these (realy a singly-linked list) to push to GDB
   in non-stop mode.  */
struct vstop_notif
{
  /* Pointer to next in list.  */
  struct vstop_notif *next;

  /* Thread or process that got the event.  */
  ptid_t ptid;

  /* Event info.  */
  struct target_waitstatus status;
};

/* The pending stop replies list head.  */
static struct vstop_notif *notif_queue = NULL;

/* Put a stop reply to the stop reply queue.  */
static void
queue_stop_reply (ptid_t ptid, struct target_waitstatus *status)
{
  struct vstop_notif *new_notif;

  new_notif = malloc (sizeof (*new_notif));
  new_notif->next = NULL;
  new_notif->ptid = ptid;
  new_notif->status = *status;

  if (notif_queue)
    {
      struct vstop_notif *tail;
      for (tail = notif_queue;
	   tail && tail->next;
	   tail = tail->next)
	;
      tail->next = new_notif;
    }
  else
    notif_queue = new_notif;

  if (remote_debug)
    {
      int i = 0;
      struct vstop_notif *tail;

      for (tail = notif_queue; tail; tail = tail->next)
	i++;

      fprintf (stderr, "pending stop replies: %d\n", i);
    }
}

/* Place an an event in the stop reply queue, and push a notification
   if we aren't sending one yet.  */
void
push_event (ptid_t ptid, struct target_waitstatus *status)
{
  queue_stop_reply (ptid, status);

  /* If this is the first stop reply in the queue, then inform GDB
     about it, by sending a Stop notification.  */
  if (notif_queue->next == NULL)
    {
      char *p = own_buf;
      strcpy (p, "Stop:");
      p += strlen (p);
      prepare_resume_reply (p,
			    notif_queue->ptid, &notif_queue->status);
      putpkt_notif (own_buf);
    }
}

/* Get rid of the currently pending stop replies.  */
static void
discard_queued_stop_replies (int pid)
{
  struct vstop_notif *prev = NULL, *reply, *next;

  for (reply = notif_queue; reply; reply = next)
    {
      next = reply->next;

      if (pid == -1
	  || ptid_get_pid (reply->ptid) == pid)
	{
	  if (reply == notif_queue)
	    notif_queue = next;
	  else
	    prev->next = reply->next;

	  free (reply);
	}
      else
	prev = reply;
    }
}

/* If there are more stop replies to push, push one now.  */
static void
send_next_stop_reply (char *own_buf)
{
  if (notif_queue)
    prepare_resume_reply (own_buf,
			  notif_queue->ptid,
			  &notif_queue->status);
  else
    write_ok (own_buf);
}

d97 1
a97 1
start_inferior (char **argv)
d100 1
d144 1
a144 1
      ptid_t ptid;
d146 2
a147 2
      resume_info.thread = pid_to_ptid (signal_pid);
      resume_info.kind = rk_continue;
d149 1
d151 3
a153 4
      ptid = mywait (pid_to_ptid (signal_pid), &last_status, 0, 0);

      if (last_status.kind != TARGET_WAITKIND_STOPPED)
	return signal_pid;
d157 1
a157 1
	  (*the_target->resume) (&resume_info, 1);
d159 3
a161 3
 	  mywait (pid_to_ptid (signal_pid), &last_status, 0, 0);
	  if (last_status.kind != TARGET_WAITKIND_STOPPED)
	    return signal_pid;
d163 1
a163 1
      while (last_status.value.sig != TARGET_SIGNAL_TRAP);
d165 1
a165 1
      return signal_pid;
d168 3
a170 5
  /* Wait till we are at 1st instruction in program, return new pid
     (assuming success).  */
  last_ptid = mywait (pid_to_ptid (signal_pid), &last_status, 0, 0);

  return signal_pid;
d174 1
a174 1
attach_inferior (int pid)
d182 2
d192 1
a192 3
  if (!non_stop)
    {
      last_ptid = mywait (pid_to_ptid (pid), &last_status, 0, 0);
d194 5
a198 7
      /* GDB knows to ignore the first SIGSTOP after attaching to a running
	 process using the "attach" command, but this is different; it's
	 just using "target remote".  Pretend it's just starting up.  */
      if (last_status.kind == TARGET_WAITKIND_STOPPED
	  && last_status.value.sig == TARGET_SIGNAL_STOP)
	last_status.value.sig = TARGET_SIGNAL_TRAP;
    }
a285 37
  if (strncmp (own_buf, "QNonStop:", 9) == 0)
    {
      char *mode = own_buf + 9;
      int req = -1;
      char *req_str;

      if (strcmp (mode, "0") == 0)
	req = 0;
      else if (strcmp (mode, "1") == 0)
	req = 1;
      else
	{
	  /* We don't know what this mode is, so complain to
	     GDB.  */
	  fprintf (stderr, "Unknown non-stop mode requested: %s\n",
		   own_buf);
	  write_enn (own_buf);
	  return;
	}

      req_str = req ? "non-stop" : "all-stop";
      if (start_non_stop (req) != 0)
	{
	  fprintf (stderr, "Setting %s mode failed\n", req_str);
	  write_enn (own_buf);
	  return;
	}

      non_stop = req;

      if (remote_debug)
	fprintf (stderr, "[%s mode enabled]\n", req_str);

      write_ok (own_buf);
      return;
    }

a503 1
      ptid_t gdb_id;
d505 3
a507 12

      if (!ptid_equal (general_thread, minus_one_ptid))
	gdb_id = general_thread;
      else
	{
	  thread_ptr = all_threads.head;
	  gdb_id = thread_to_gdb_id ((struct thread_info *)thread_ptr);
	}

      sprintf (own_buf, "QC");
      own_buf += 2;
      own_buf = write_ptid (own_buf, gdb_id);
a523 2
	  ptid_t gdb_id;

d526 1
a526 4

	  *own_buf++ = 'm';
	  gdb_id = thread_to_gdb_id ((struct thread_info *)thread_ptr);
	  write_ptid (own_buf, gdb_id);
a532 2
	  ptid_t gdb_id;

d536 1
a536 3
	      *own_buf++ = 'm';
	      gdb_id = thread_to_gdb_id ((struct thread_info *)thread_ptr);
	      write_ptid (own_buf, gdb_id);
a774 15
      char *p = &own_buf[10];

      /* Process each feature being provided by GDB.  The first
	 feature will follow a ':', and latter features will follow
	 ';'.  */
      if (*p == ':')
	for (p = strtok (p + 1, ";");
	     p != NULL;
	     p = strtok (NULL, ";"))
	  {
	    /* Record if GDB knows about multiprocess support.  */
	    if (strcmp (p, "multiprocess+") == 0)
	      multi_process = 1;
	  }

a794 5

      strcat (own_buf, ";multiprocess+");

      strcat (own_buf, ";QNonStop+");

d803 1
a803 1
      CORE_ADDR parts[2], address = 0;
a804 1
      ptid_t ptid;
d828 1
a828 4
	  if (i == 0)
	    ptid = read_ptid (p, NULL);
	  else
	    decode_address (&parts[i - 1], p, len);
d836 1
a836 1
	  struct thread_info *thread = find_thread_pid (ptid);
d841 1
a841 1
	    err = the_target->get_tls_address (thread, parts[0], parts[1],
a916 34
  if (the_target->pid_to_exec_file != NULL
      && strncmp ("qExecFile:", own_buf, 10) == 0)
    {
      char *p = own_buf + 10;
      int pid;
      char *path;
      size_t len;

      pid = strtol (p, NULL, 16);

      path = (*the_target->pid_to_exec_file) (pid);

      if (!path)
	{
	  write_enn (own_buf);
	  return;
	}

      len = strlen (path);

      if (len * 2 >= PBUFSIZ - strlen (own_buf) - 2)
	{
	  /* File name too long for packet.  */
	  write_enn (own_buf);
	  return;
	}

      own_buf[0] = 'Q';
      p = own_buf + strlen (own_buf);
      *p++ = ';';
      hexify (p, path, len);
      return;
    }

d924 1
a924 1
handle_v_cont (char *own_buf)
d928 1
a928 1
  struct thread_resume *resume_info;
d939 9
a947 2

  resume_info = malloc (n * sizeof (resume_info[0]));
d950 1
d955 2
d958 1
a958 1
	resume_info[i].kind = rk_step;
d960 1
a960 3
	resume_info[i].kind = rk_continue;
      else if (p[0] == 't')
	resume_info[i].kind = rk_stop;
d983 7
a989 1
	resume_info[i].thread = minus_one_ptid;
d992 2
a993 1
	  ptid_t ptid = read_ptid (p + 1, &q);
d1001 7
a1007 1
	  resume_info[i].thread = ptid;
d1009 1
d1011 1
a1011 2
      i++;
    }
d1014 1
a1014 3
  if (n == 1
      && !ptid_equal (resume_info[0].thread, minus_one_ptid)
      && resume_info[0].kind != rk_stop)
d1017 1
a1017 1
    cont_thread = minus_one_ptid;
d1020 2
a1021 4
  if (!non_stop)
    enable_async_io ();

  (*the_target->resume) (resume_info, n);
d1025 3
a1027 8
  if (non_stop)
    write_ok (own_buf);
  else
    {
      last_ptid = mywait (minus_one_ptid, &last_status, 0, 1);
      prepare_resume_reply (own_buf, last_ptid, &last_status);
      disable_async_io ();
    }
d1038 1
a1038 1
handle_v_attach (char *own_buf)
d1043 1
a1043 1
  if (pid != 0 && attach_inferior (pid) == 0)
d1050 1
a1050 14

      if (non_stop)
	{
	  /* In non-stop, we don't send a resume reply.  GDB will
	     query for the current thread, so set it.  */
	  general_thread = last_ptid;

	  /* Stop events will follow up using the normal notification
	     mechanism.  */
	  write_ok (own_buf);
	}
      else
	prepare_resume_reply (own_buf, last_ptid, &last_status);

d1062 1
a1062 1
handle_v_run (char *own_buf)
d1099 5
d1110 2
a1111 24
      new_argv[0] = strdup (program_argv[0]);
    }

  /* Free the old argv.  */
  if (program_argv)
    {
      for (pp = program_argv; *pp != NULL; pp++)
	free (*pp);
      free (program_argv);
    }
  program_argv = new_argv;

  start_inferior (program_argv);
  if (last_status.kind == TARGET_WAITKIND_STOPPED)
    {
      prepare_resume_reply (own_buf, last_ptid, &last_status);

      /* In non-stop, sending a resume reply doesn't set the general
	 thread, but GDB assumes a vRun sets it (this is so GDB can
	 query which is the main thread of the new inferior.  */
      if (non_stop)
	general_thread = last_ptid;

      return 1;
d1115 8
a1122 2
      write_enn (own_buf);
      return 0;
a1123 8
}

/* Attach to a new program.  Return 1 if successful, 0 if failure.  */
int
handle_v_kill (char *own_buf)
{
  int pid;
  char *p = &own_buf[6];
d1125 2
a1126 2
  pid = strtol (p, NULL, 16);
  if (pid != 0 && kill_inferior (pid) == 0)
d1128 1
a1128 4
      last_status.kind = TARGET_WAITKIND_SIGNALLED;
      last_status.value.sig = TARGET_SIGNAL_KILL;
      discard_queued_stop_replies (pid);
      write_ok (own_buf);
a1137 23
/* Handle a 'vStopped' packet.  */
static void
handle_v_stopped (char *own_buf)
{
  /* If we're waiting for GDB to acknowledge a pending stop reply,
     consider that done.  */
  if (notif_queue)
    {
      struct vstop_notif *head;

      if (remote_debug)
	fprintf (stderr, "vStopped: acking %s\n",
		 target_pid_to_str (notif_queue->ptid));

      head = notif_queue;
      notif_queue = notif_queue->next;
      free (head);
    }

  /* Push another, or if there are no more left, and OK.  */
  send_next_stop_reply (own_buf);
}

d1140 2
a1141 1
handle_v_requests (char *own_buf, int packet_len, int *new_packet_len)
d1148 1
a1148 1
	  handle_v_cont (own_buf);
d1154 1
a1154 1
	  strcpy (own_buf, "vCont;c;C;s;S;t");
d1165 1
a1165 1
      if (!multi_process && target_running ())
d1171 1
a1171 1
      handle_v_attach (own_buf);
d1177 1
a1177 1
      if (!multi_process && target_running ())
d1183 1
a1183 19
      handle_v_run (own_buf);
      return;
    }

  if (strncmp (own_buf, "vKill;", 6) == 0)
    {
      if (!target_running ())
	{
	  fprintf (stderr, "No process to kill\n");
	  write_enn (own_buf);
	  return;
	}
      handle_v_kill (own_buf);
      return;
    }

  if (strncmp (own_buf, "vStopped", 8) == 0)
    {
      handle_v_stopped (own_buf);
a1192 3
/* Resume inferior and wait for another event.  In non-stop mode,
   don't really wait here, but return immediatelly to the event
   loop.  */
d1194 1
a1194 1
proceed (char *own_buf, int step, int siggnal)
d1198 1
a1198 1
  int valid_cont_thread;
d1202 1
a1202 4
  valid_cont_thread = (!ptid_equal (cont_thread, null_ptid)
			 && !ptid_equal (cont_thread, minus_one_ptid));

  if (step || siggnal || valid_cont_thread)
d1206 3
a1208 5
      if (step)
	resume_info[0].kind = rk_step;
      else
	resume_info[0].kind = rk_continue;
      resume_info[0].sig = siggnal;
d1211 10
a1220 77

  if (!valid_cont_thread)
    {
      resume_info[n].thread = minus_one_ptid;
      resume_info[n].kind = rk_continue;
      resume_info[n].sig = 0;
    }

  if (!non_stop)
    enable_async_io ();

  (*the_target->resume) (resume_info, n);

  if (non_stop)
    write_ok (own_buf);
  else
    {
      last_ptid = mywait (minus_one_ptid, &last_status, 0, 1);
      prepare_resume_reply (own_buf, last_ptid, &last_status);
      disable_async_io ();
    }
}

/* Callback for for_each_inferior.  Make a new stop reply for each
   stopped thread.  */
static int
queue_stop_reply_callback (struct inferior_list_entry *entry, void *arg)
{
  int pid = * (int *) arg;

  if (pid == -1
      || ptid_get_pid (entry->id) == pid)
    {
      struct target_waitstatus status;

      status.kind = TARGET_WAITKIND_STOPPED;
      status.value.sig = TARGET_SIGNAL_TRAP;

      /* Pass the last stop reply back to GDB, but don't notify.  */
      queue_stop_reply (entry->id, &status);
    }

  return 0;
}

/* Status handler for the '?' packet.  */

static void
handle_status (char *own_buf)
{
  struct target_waitstatus status;
  status.kind = TARGET_WAITKIND_STOPPED;
  status.value.sig = TARGET_SIGNAL_TRAP;

  /* In non-stop mode, we must send a stop reply for each stopped
     thread.  In all-stop mode, just send one for the first stopped
     thread we find.  */

  if (non_stop)
    {
      int pid = -1;
      discard_queued_stop_replies (pid);
      find_inferior (&all_threads, queue_stop_reply_callback, &pid);

      /* The first is sent immediatly.  OK is sent if there is no
	 stopped thread, which is the same handling of the vStopped
	 packet (by design).  */
      send_next_stop_reply (own_buf);
    }
  else
    {
      if (all_threads.head)
	prepare_resume_reply (own_buf,
			      all_threads.head->id, &status);
      else
	strcpy (own_buf, "W00");
    }
d1244 1
a1244 2
	   "  --debug\t\tEnable general debugging output.\n"
	   "  --remote-debug\tEnable remote protocol debugging output.\n"
a1270 42
static int
first_thread_of (struct inferior_list_entry *entry, void *args)
{
  int pid = * (int *) args;

  if (ptid_get_pid (entry->id) == pid)
    return 1;

  return 0;
}

static void
kill_inferior_callback (struct inferior_list_entry *entry)
{
  struct process_info *process = (struct process_info *) entry;
  int pid = ptid_get_pid (process->head.id);

  kill_inferior (pid);
  discard_queued_stop_replies (pid);
}

static void
detach_or_kill_inferior_callback (struct inferior_list_entry *entry)
{
  struct process_info *process = (struct process_info *) entry;
  int pid = ptid_get_pid (process->head.id);

  if (process->attached)
    detach_inferior (pid);
  else
    kill_inferior (pid);

  discard_queued_stop_replies (pid);
}

static void
join_inferiors_callback (struct inferior_list_entry *entry)
{
  struct process_info *process = (struct process_info *) entry;
  join_inferior (ptid_get_pid (process->head.id));
}

d1274 6
a1322 2
      else if (strcmp (*next_arg, "--remote-debug") == 0)
	remote_debug = 1;
a1411 1
  initialize_inferiors ();
d1429 1
a1429 1
      start_inferior (program_argv);
d1437 1
a1437 1
      if (attach_inferior (pid) == -1)
d1444 2
a1445 3
      last_status.kind = TARGET_WAITKIND_EXITED;
      last_status.value.integer = 0;
      last_ptid = minus_one_ptid;
d1455 2
a1456 3
      fprintf (stderr, "Killing all inferiors\n");
      for_each_inferior (&all_processes,
			 kill_inferior_callback);
d1460 1
a1460 2
  if (last_status.kind == TARGET_WAITKIND_EXITED
      || last_status.kind == TARGET_WAITKIND_SIGNALLED)
a1473 3
      multi_process = 0;
      non_stop = 0;

d1476 1
a1486 42
      /* Wait for events.  This will return when all event sources are
	 removed from the event loop. */
      start_event_loop ();

      /* If an exit was requested (using the "monitor exit" command),
	 terminate now.  The only other way to get here is for
	 getpkt to fail; close the connection and reopen it at the
	 top of the loop.  */

      if (exit_requested)
	{
	  for_each_inferior (&all_processes,
			     detach_or_kill_inferior_callback);
	  exit (0);
	}
      else
	fprintf (stderr, "Remote side has terminated connection.  "
		 "GDBserver will reopen the connection.\n");
    }
}

/* Event loop callback that handles a serial event.  The first byte in
   the serial buffer gets us here.  We expect characters to arrive at
   a brisk pace, so we read the rest of the packet with a blocking
   getpkt call.  */
static void
process_serial_event (void)
{
  char ch;
  int i = 0;
  int signal;
  unsigned int len;
  CORE_ADDR mem_addr;
  int pid;

  /* Used to decide when gdbserver should exit in
     multi-mode/remote.  */
  static int have_ran = 0;

  if (!have_ran)
    have_ran = target_running ();

d1488 1
d1497 1
a1497 5
	    {
	      target_async (0);
	      remote_close ();
	      return;
	    }
d1512 2
a1513 11

	      if (multi_process)
		{
		  i++; /* skip ';' */
		  pid = strtol (&own_buf[i], NULL, 16);
		}
	      else
		pid = ptid_get_pid (((struct inferior_list_entry *)current_inferior)->id);

	      fprintf (stderr, "Detaching from process %d\n", pid);
	      if (detach_inferior (pid) != 0)
a1516 1
		  discard_queued_stop_replies (pid);
d1522 2
a1523 5
		      last_status.kind = TARGET_WAITKIND_EXITED;
		      last_status.value.integer = 0;
		      last_ptid = pid_to_ptid (pid);

		      current_inferior = NULL;
d1530 5
a1534 9
		      /* Usually, if we are attached, then we can
			 exit.  Otherwise, we need to hang around
			 doing nothing, until the child is gone.  The
			 decision to join or not is left to the
			 target, as some targets may have to join even
			 if attached (e.g., Windows versions without
			 DebugSetProcessKillOnExit).  */
		      for_each_inferior (&all_processes,
					 join_inferiors_callback);
d1545 1
a1545 1
	      handle_status (own_buf);
d1550 1
a1550 2
		  ptid_t gdb_id, thread_id;
		  int pid;
d1553 3
a1555 24

		  gdb_id = read_ptid (&own_buf[2], NULL);

		  pid = ptid_get_pid (gdb_id);

		  if (ptid_equal (gdb_id, null_ptid)
		      || ptid_equal (gdb_id, minus_one_ptid))
		    thread_id = null_ptid;
		  else if (pid != 0
			   && ptid_equal (pid_to_ptid (pid),
					  gdb_id))
		    {
		      struct thread_info *thread =
			(struct thread_info *) find_inferior (&all_threads,
							      first_thread_of,
							      &pid);
		      if (!thread)
			{
			  write_enn (own_buf);
			  break;
			}

		      thread_id = ((struct inferior_list_entry *)thread)->id;
		    }
d1559 1
a1559 1
		      if (ptid_equal (thread_id, null_ptid))
a1567 13
		      if (ptid_equal (thread_id, null_ptid))
			{
			  /* GDB is telling us to choose any thread.
			     Check if the currently selected thread is
			     still valid. If it is not, select the
			     first available.  */
			  struct thread_info *thread =
			    (struct thread_info *) find_inferior_id (&all_threads,
								     general_thread);
			  if (thread == NULL)
			    thread_id = all_threads.head->id;
			}

a1613 2

	      /* If len == 0, GDB is probing for packet support.  */
d1616 1
a1616 1
		  || (len > 0 && write_inferior_memory (mem_addr, mem_buf, len) != 0))
d1628 1
a1628 1
	      proceed (own_buf, 0, signal);
d1637 1
a1637 1
	      proceed (own_buf, 1, signal);
d1642 1
a1642 1
	      proceed (own_buf, 0, signal);
d1647 1
a1647 1
	      proceed (own_buf, 1, signal);
d1716 1
a1716 1
		return;
d1718 2
a1719 2
	      fprintf (stderr, "Killing all inferiors\n");
	      for_each_inferior (&all_processes, kill_inferior_callback);
d1726 4
a1729 3
		  last_status.kind = TARGET_WAITKIND_EXITED;
		  last_status.value.sig = TARGET_SIGNAL_KILL;
		  return;
d1738 1
a1738 1
		ptid_t gdb_id, thread_id;
d1741 1
a1741 2

		gdb_id = read_ptid (&own_buf[1], NULL);
d1743 1
a1743 1
		if (ptid_equal (thread_id, null_ptid))
d1763 1
a1763 2
		    for_each_inferior (&all_processes,
				       kill_inferior_callback);
d1768 1
a1768 1
		    start_inferior (program_argv);
d1771 2
a1772 2
		      last_status.kind = TARGET_WAITKIND_EXITED;
		      last_status.value.sig = TARGET_SIGNAL_KILL;
d1774 1
a1774 1
		  return;
d1786 2
a1787 1
	      handle_v_requests (own_buf, packet_len, &new_packet_len);
d1805 1
a1805 1
	  if (!extended_protocol && have_ran && !target_running ())
d1807 13
a1819 4
	      /* In non-stop, defer exiting until GDB had a chance to
		 query the whole vStopped list (until it gets an
		 OK).  */
	      if (!notif_queue)
d1825 3
a1828 1
}
d1830 4
a1833 6
/* Event-loop callback for serial events.  */
void
handle_serial_event (int err, gdb_client_data client_data)
{
  if (debug_threads)
    fprintf (stderr, "handling possible serial event\n");
d1835 16
a1850 27
  /* Really handle it.  */
  process_serial_event ();

  /* Be sure to not change the selected inferior behind GDB's back.
     Important in the non-stop mode asynchronous protocol.  */
  set_desired_inferior (1);
}

/* Event-loop callback for the target events.  */
void
handle_target_event (int err, gdb_client_data client_data)
{
  if (debug_threads)
    fprintf (stderr, "handling possible target event\n");

  last_ptid = mywait (minus_one_ptid, &last_status,
		      TARGET_WNOHANG, 1);

  if (last_status.kind == TARGET_WAITKIND_IGNORE)
    return; /* Nothing interesting found.  */

  /* Something interesting.  Tell GDB about it.  */
  push_event (last_ptid, &last_status);

  /* Be sure to not change the selected inferior behind GDB's back.
     Important in the non-stop mode asynchronous protocol.  */
  set_desired_inferior (1);
@


1.78
log
@gdb/doc/
2008-08-12  Sandra Loosemore  <sandra@@codesourcery.com>

	* gdb.texinfo (Remote Configuration): Document set remote noack-packet.
	(Remote Protocol): Add Packet Acknowledgment to menu.
	(Overview): Mention +/- can be disabled, and point to new section
	where this is discussed in detail.
	(General Query Packets): Document QStartNoAckMode packet, and
	corresponding qSupported reply.
	(Packet Acknowledgment): New section.

gdb/
2008-08-12  Pedro Alves  <pedro@@codesourcery.com>

	Add no-ack mode to the remote protocol --- optionally stop ACKing
	packets and responses when we have a reliable communication
	medium.

	Based on Apple's GDB, by Jason Molenda <jmolenda@@apple.com>

	* remote.c (struct remote_state): Add noack_mode field.
	(PACKET_QStartNoAckMode): New.
	(remote_start_remote): Don't any outstanding packet here.
	(remote_open_1): Clear noack_mode.  Ack any outstanding packet
	here.  Activate noack mode if requested.
	(remote_protocol_features): Add QStartNoAckMode.
	(remote_open_1):
	(putpkt_binary): Don't send ack in noack mode.
	(read_frame): Don't recompute the checksum in noack mode.
	(getpkt_sane): Skip sending ack if in noack mode.
	(_initialize_remote): Add set/show remote noack mode.
	* NEWS:  Note the new features.

gdb/gdbserver/
2008-08-12  Pedro Alves  <pedro@@codesourcery.com>

	* remote-utils.c (noack_mode, transport_is_reliable): New globals.
	(remote_open): Set or clear transport_is_reliable.
	(putpkt_binary): Don't expect acks in noack mode.
	(getpkt): Don't send ack/nac in noack mode.
	* server.c (handle_general_set): Handle QStartNoAckMode.
	(handle_query): If connected by tcp pass QStartNoAckMode+ in
	qSupported.
	(main): Reset noack_mode on every connection.
	* server.h (noack_mode): Declare.
@
text
@d1099 5
d1110 2
a1111 1
      new_argv[0] = strdup (program_argv[0]);
d1113 1
a1113 3

  /* Free the old argv.  */
  if (program_argv)
d1115 8
a1122 3
      for (pp = program_argv; *pp != NULL; pp++)
	free (*pp);
      free (program_argv);
a1123 1
  program_argv = new_argv;
@


1.77
log
@	* configure.ac: Check for memmem declaration.
	* server.c [HAVE_MALLOC_H]: Include malloc.h.
	(disable_packet_vCont, disable_packet_Tthread, disable_packet_qC)
	(disable_packet_qfThreadInfo): Unconditionally compile.
	* server.h [!HAVE_DECL_MEMMEM]: Declare memmem.
	* configure, config.in: Regenerate.
@
text
@d273 13
d793 2
d1465 1
@


1.76
log
@	* server.c (handle_v_attach): Inhibit reporting dll changes.
@
text
@d31 3
a72 8
/* Set if you want to disable optional thread related packets support
   in gdbserver, for the sake of testing GDB against stubs that don't
   support them.  */
int disable_packet_vCont;
int disable_packet_Tthread;
int disable_packet_qC;
int disable_packet_qfThreadInfo;

d82 8
@


1.75
log
@	* remote-utils.c (prepare_resume_reply): If requested, don't
	output "thread:TID" in the T stop reply.

	* server.c (disable_packet_vCont, disable_packet_Tthread)
	(disable_packet_qC, disable_packet_qfThreadInfo): New globals.
	(handle_query): If requested, disable support for qC, qfThreadInfo
	and qsThreadInfo.
	(handle_v_requests): If requested, disable support for vCont.
	(gdbserver_show_disableable): New.
	(main): Handle --disable-packet and --disable-packet=LIST.

	* server.h (disable_packet_vCont, disable_packet_Tthread)
	(disable_packet_qC, disable_packet_qfThreadInfo): Declare.
@
text
@d1027 5
@


1.74
log
@
gdb/gdbserver/

2008-06-20  Carlos O'Donell  <carlos@@codesourcery.com>

	* server.c (gdbserver_usage): Mention --version.
@
text
@d70 8
d486 1
a486 1
  if (strcmp ("qC", own_buf) == 0)
d491 1
a491 1
	thread_to_gdb_id ((struct thread_info *)thread_ptr));
d504 1
a504 1
  if (strcmp ("qfThreadInfo", own_buf) == 0)
d506 1
a506 11
      require_running (own_buf);
      thread_ptr = all_threads.head;
      sprintf (own_buf, "m%x", thread_to_gdb_id ((struct thread_info *)thread_ptr));
      thread_ptr = thread_ptr->next;
      return;
    }

  if (strcmp ("qsThreadInfo", own_buf) == 0)
    {
      require_running (own_buf);
      if (thread_ptr != NULL)
d508 2
d514 2
a515 1
      else
d517 12
a528 2
	  sprintf (own_buf, "l");
	  return;
d1112 1
a1112 1
  if (strncmp (own_buf, "vCont;", 6) == 0)
d1114 6
a1119 4
      require_running (own_buf);
      handle_v_cont (own_buf, status, signal);
      return;
    }
d1121 5
a1125 4
  if (strncmp (own_buf, "vCont?", 6) == 0)
    {
      strcpy (own_buf, "vCont;c;C;s;S");
      return;
d1220 12
d1292 40
@


1.73
log
@2008-06-05  Vladimir Prus  <vladimir@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>

	* acinclude.m4: Include ../config/acx.m4.
	* configure.ac: Use ACX_PKGVERSION and ACX_BUGURL.
	* configure, config.in: Regenerate.
	* main.c (print_gdb_help): Use REPORT_BUGS_TO for bug-reporting
	address.
	* top.c (print_gdb_version): Use PKGVERSION and REPORT_BUGS_TO.

doc:
2008-06-05  Vladimir Prus  <vladimir@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>

	* configure.ac: Include ../../config/acx.m4.  Use ACX_PKGVERSION
	and ACX_BUGURL.
	* configure: Regenerate.
	* Makefile.in (PKGVERSION, BUGURL_TEXI): Define.
	(GDBvn.texi): Define VERSION_PACKAGE, BUGURL and BUGURL_DEFAULT.
	* gdb.texinfo: Use VERSION_PACKAGE and BUGURL.  Remove
	mailing-list-specific text about bug reporting unless
	BUGURL_DEFAULT.

gdbserver:
2008-06-05  Vladimir Prus  <vladimir@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>

	* acinclude.m4: Include ../../config/acx.m4.
	* configure.ac: Use ACX_PKGVERSION and ACX_BUGURL.
	* configure, config.in: Regenerate.
	* Makefile.in (gdbreplay$(EXEEXT)): Add version.o.
	* server.c (gdbserver_version): Print PKGVERSION.
	(gdbsrever_usage): Add stream parameter.  Print REPORT_BUGS_TO.
	(main): Adjust gdbserver_usage calls.
	* gdbreplay.c (version, host_name): Add declarations.
	(gdbreplay_version, gdbreplay_usage): New.
	(main): Accept --version and --help options.
@
text
@d1200 1
@


1.72
log
@	* error.c (parse_find_args): Fix capitalization in previous patch.
	(find_command): Ditto.
	* target.c (simple_search_memory): Ditto.
	* gdbserver/server.c (handle_search_memory_1): Ditto.
	(handle_search_memory): Ditto.
@
text
@d1181 1
a1181 1
  printf ("GNU gdbserver %s\n"
d1185 1
a1185 1
	  version, host_name);
d1189 1
a1189 1
gdbserver_usage (void)
d1191 12
a1202 10
  printf ("Usage:\tgdbserver [OPTIONS] COMM PROG [ARGS ...]\n"
	  "\tgdbserver [OPTIONS] --attach COMM PID\n"
	  "\tgdbserver [OPTIONS] --multi COMM\n"
	  "\n"
	  "COMM may either be a tty device (for serial debugging), or \n"
	  "HOST:PORT to listen for a TCP connection.\n"
	  "\n"
	  "Options:\n"
	  "  --debug\t\tEnable debugging output.\n"
	  "  --wrapper WRAPPER --\tRun WRAPPER to start new programs.\n");
d1239 1
a1239 1
	  gdbserver_usage ();
d1256 1
a1256 1
	      gdbserver_usage ();
d1285 1
a1285 1
      gdbserver_usage ();
d1310 1
a1310 1
      gdbserver_usage ();
@


1.71
log
@	New "find" command.
	* NEWS: Document find command and qSearch:memory packet.
	* Makefile.in (SFILES): Add findcmd.c.
	(COMMON_OBJS): Add findcmd.o.
	(findcmd.o): New rule.
	* findcmd.c: New file.
	* target.h (target_ops): New member to_search_memory.
	(simple_search_memory): Declare.
	(target_search_memory): Declare.
	* target.c (simple_search_memory): New fn.
	(target_search_memory): New fn.
	* remote.c (PACKET_qSearch_memory): New packet kind.
	(remote_search_memory): New fn.
	(init_remote_ops): Init to_search_memory.
	(init_extended_remote_ops): Ditto.
	(_initialize_remote): Add qSearch:memory packet config command.

	* gdbserver/server.h (decode_search_memory_packet): Declare.
	* gdbserver/remote-utils.c (decode_search_memory_packet): New fn.
	* gdbserver/server.c (handle_search_memory_1): New fn.
	(handle_search_memory): New fn.
	(handle_query): Process qSearch:memory packets.

	* doc/gdb.texinfo: Document "find" command, qSearch:memory packet.

	* testsuite/gdb.base/find.exp: New file.
	* testsuite/gdb.base/find.c: New file.
@
text
@d330 1
a330 1
      warning ("unable to access target memory at 0x%lx, halting search",
d382 1
a382 1
	      warning ("unable to access target memory at 0x%lx, halting search",
d418 1
a418 1
      error ("unable to allocate memory to perform the search");
d428 1
a428 1
      error ("error in parsing qSearch:memory packet");
d443 1
a443 1
      error ("unable to allocate memory to perform the search");
@


1.70
log
@	* server.c (handle_query): Never return "unsupported" for
	qXfer:features:read queries.
@
text
@d317 147
d881 7
@


1.69
log
@ChangeLog:

	* features/Makefile (%.dat): Set xmltarget to the base filename
	of the XML source, without subdirectory.
	* regformats/rs6000/powerpc-32.dat: Regenerate.
	* regformats/rs6000/powerpc-64.dat: Regenerate.
	* regformats/rs6000/powerpc-e500.dat: Regenerate.

gdbserver/ChangeLog:

	* server.c (get_features_xml): Fix inverted condition.
	(handle_query): Always support qXfer:feature:read.
@
text
@a499 8
      /* Check for support.  */
      document = get_features_xml ("target.xml");
      if (document == NULL)
	{
	  own_buf[0] = '\0';
	  return;
	}

@


1.68
log
@	* Makefile.in (fork-child.o): Update.
	* NEWS: Document "set exec-wrapper" and the gdbserver --wrapper
	argument.  Gather all gdbserver features together.
	* fork-child.c (exec_wrapper): New variable.
	(fork_inferior): Use it.
	(startup_inferior): Skip an extra trap if using "set exec-wrapper".
	(unset_exec_wrapper_command, _initialize_fork_child): New.

	* gdb.texinfo (Starting): Document "set exec-wrapper".
	(Server): Document gdbserver --wrapper.

	* server.c (wrapper_argv): New.
	(start_inferior): Handle wrapper_argv.  If set, expect an extra
	trap.
	(gdbserver_usage): Document --wrapper.
	(main): Parse --wrapper.
@
text
@d279 1
a279 1
      && strcmp (annex, "target.xml") != 0)
d621 5
a625 2
      if (get_features_xml ("target.xml") != NULL)
	strcat (own_buf, ";qXfer:features:read+");
@


1.67
log
@ChangeLog:

	* features/Makefile (%.dat): Emit xmltarget statement.

	* regformats/regdat.sh: Support xmltarget and xmlarch statments.
	Generate code to set gdbserver_xmltarget in init_registers_${name}.

	* regformats/arm-with-iwmmxt.dat: Regenerate.
	* regformats/mips64-linux.dat: Regenerate.
	* regformats/mips-linux.dat: Regenerate.
	* regformats/rs6000/powerpc-32.dat: Regenerate.
	* regformats/rs6000/powerpc-64.dat: Regenerate.
	* regformats/rs6000/powerpc-e500.dat: Regenerate.

	* regformats/reg-arm.dat: Add xmlarch statement.
	* regformats/reg-i386.dat: Likewise.
	* regformats/reg-i386-linux.dat: Likewise.
	* regformats/reg-x86-64-linux.dat: Likewise.
	* regformats/reg-spu.dat: Likewise.

gdbserver/ChangeLog:

	* regcache.h (gdbserver_xmltarget): Add extern declaration.
	* server.c (gdbserver_xmltarget): Define.
	(get_features_xml): Use it to replace "target.xml" and arch_string.

	* configure.srv: Remove srv_xmltarget.  Add XML files that were
	mentioned there to srv_xmlfiles instead.  Remove conditional tests
	on gdb_cv_arm_iwmmxt, gdb_cv_ppc_altivec, gdb_cv_ppc_spe; set
	srv_xmlfiles and srv_regobj to include all possible choices.
	* configure.ac (srv_xmltarget): Remove.
	(srv_xmlfiles): Do not add "target.xml".
	(gdb_cv_arm_iwmmxt, gdb_cv_ppc_altivec, gdb_cv_ppc_spe): Remove
	checks for supplementary target information.
	* configure: Regenerate.
	* Makefile.in (XML_TARGET): Remove.
	(target.xml): Remove rule.
	(clean): Do not clean up target.xml.
	(.PRECIOUS): Do not mention target.xml.

	* target.h (struct target_ops): Remove arch_string member.
	* linux-low.c (linux_arch_string): Remove.
	(linux_target_ops): Remove arch_string initializer.
	* linux-low.h (struct linux_target_ops): Remove arch_string member.
	* linux-i386-low.c (the_low_target): Remove arch_string initializer.
	* linux-x86-64-low.c (the_low_target): Remove arch_string initializer.
	* spu-low.c (spu_arch_string): Remove.
	(spu_target_ops): Remove arch_string initializer.
	* win32-low.c (win32_arch_string): Remove.
	(win32_target_ops): Remove arch_string initializer.
	* win32-low.h (struct win32_target_ops): Remove arch_string member.
	* win32-arm-low.c (the_low_target): Remove arch_string initializer.
	* win32-i368-low.c (the_low_target): Remove arch_string initializer.
@
text
@d44 1
a44 1
static char **program_argv;
d86 1
a86 1
start_inferior (char *argv[], char *statusptr)
d88 1
d91 17
d113 1
a113 1
  signal_pid = create_inferior (argv[0], argv);
d130 27
d1050 2
a1051 1
	  "  --debug\t\tEnable debugging output.\n");
d1095 17
@


1.66
log
@doc/
	* gdb.texinfo (vAttach, vRun): Remove requirement of the stub
	killing the inferior when it is already debugging a process.

gdbserver/
	* server.c (handle_v_requests): When handling the vRun and vAttach
	packets, if already debugging a process, don't kill it.  Return an
	error instead.
@
text
@d54 2
d225 4
a228 15
  static int features_supported = -1;
  static char *document;

#ifdef USE_XML
  extern const char *const xml_builtin[][2];
  int i;

  /* Look for the annex.  */
  for (i = 0; xml_builtin[i][0] != NULL; i++)
    if (strcmp (annex, xml_builtin[i][0]) == 0)
      break;

  if (xml_builtin[i][0] != NULL)
    return xml_builtin[i][1];
#endif
d230 2
a231 2
  if (strcmp (annex, "target.xml") != 0)
    return NULL;
d233 2
a234 1
  if (features_supported == -1)
d236 2
a237 6
      const char *arch = NULL;
      if (the_target->arch_string != NULL)
	arch = (*the_target->arch_string) ();

      if (arch == NULL)
	features_supported = 0;
d239 1
a239 7
	{
	  features_supported = 1;
	  document = malloc (64 + strlen (arch));
	  snprintf (document, 64 + strlen (arch),
		    "<target><architecture>%s</architecture></target>",
		    arch);
	}
d242 16
a257 1
  return document;
@


1.65
log
@	* server.c (handle_query): Correct length check.
@
text
@d931 3
a933 2
	  fprintf (stderr, "Killing inferior\n");
	  kill_inferior ();
d943 3
a945 2
	  fprintf (stderr, "Killing inferior\n");
	  kill_inferior ();
@


1.64
log
@	* server.c (monitor_show_help): Add "exit".
@
text
@d652 1
a652 1
      if ((len % 1) != 0 || unhexify (mon, own_buf + 6, len / 2) != len / 2)
@


1.63
log
@	* linux-low.c (linux_attach_lwp): Do not _exit after errors.
	(linux_kill, linux_detach): Clean up the process list.
	* remote-utils.c (remote_open): Improve port number parsing.
	(putpkt_binary, input_interrupt): Only send interrupts if the target
	is running.
	* server.c (extended_protocol): Make static.
	(attached): Define earlier.
	(exit_requested, response_needed, program_argv): New variables.
	(target_running): New.
	(start_inferior): Clear attached here.
	(attach_inferior): Set attached here.
	(require_running): Define.
	(handle_query): Use require_running and target_running.  Implement
	"monitor exit".
	(handle_v_attach, handle_v_run): New.
	(handle_v_requests): Use require_running.  Handle vAttach and vRun.
	(gdbserver_usage): Update.
	(main): Redo argument parsing.  Handle --debug and --multi.  Handle
	--attach along with other options or after the port.  Save
	program_argv.  Support no initial program.  Resynchronize
	communication with GDB after an error.  Handle "monitor exit".
	Use require_running and target_running.  Always allow the extended
	protocol.  Do not error out for Hc0 or Hc-1.  Do not automatically
	restart in extended mode.
	* README: Refer to the GDB manual.  Update --attach usage.

	* remote.c (struct remote_state): Add cached_wait_status.
	(remote_exec_file): New variable.
	(PACKET_vAttach, PACKET_vRun): New constants.
	(extended_remote_restart): Do not query for status.
	(struct start_remote_args): New.
	(remote_start_remote): Take it as a second argument.  Check
	whether the target is running.  Issue an error for non-running
	non-extended targets.  Cache the wait status.  Set inferior_ptid
	here.
	(remote_open_1): Prompt to disconnect non-running targets.  Make
	sure the target is marked running.  Do not set inferior_ptid here.
	Update call to remote_start_remote.  Do not call remote_check_symbols
	if the target is not running.
	(remote_detach_1): Rename from remote_detach.  Take an EXTENDED
	argument.  Handle a non-running target.
	(remote_detach): Use it.
	(extended_remote_detach): New.
	(remote_disconnect): Fix typo.  Use remoute_mourn_1.
	(extended_remote_attach_1, extended_remote_attach)
	(extended_async_remote_attach): New.
	(remote_vcont_resume): Remove unused variable.
	(remote_wait, remote_async_wait): Use any cached wait status.
	(putpkt_binary, getpkt): Clear any cached wait status.
	(extended_remoute_mourn_1): New.
	(extended_remote_mourn): Use it.
	(extended_async_remote_mourn, extended_remote_run): New.
	(extended_remote_create_inferior_1): New.
	(extended_remote_create_inferior): Use it.
	(extended_remote_async_create_inferior): Likewise.
	(remote_xfer_partial): Skip for non-executing targets.
	(init_extended_remote_ops): Set to_detach and to_attach.
	(init_extended_async_remote_ops): Likewise.  Use
	extended_async_remote_mourn.
	(_initialize_remote): Register vAttach, vRun, and
	set remote exec-file.
	* NEWS: Mention vAttach, vRun, and gdbserver extended-remote support.

	* gdb.server/ext-attach.c, gdb.server/ext-attach.exp,
	gdb.server/ext-run.exp: New files.
	* lib/gdbserver-support.exp (gdbserver_download): New.
	(gdbserver_start): New.  Update gdbserver expected
	output.
	(gdbserver_spawn): Use them.
	(gdbserver_start_extended): New.

	* gdb.texinfo (Using the `gdbserver' Program): Add security
	warning.  Rearrange into subsections and subsubsections.  Document
	--multi and --debug.  Correct --with-sysroot typo.  Update --attach
	usage.  Make load reference clearer.  Document monitor exit.
	(Remote Configuration): Document set remote exec-file, attach-packet,
	and run-packet.
	(Packets): Document vAttach and vRun.
@
text
@d271 2
@


1.62
log
@	Updated copyright notices for most files.
@
text
@a36 1
int extended_protocol;
d39 7
d78 6
d86 2
d124 2
d273 7
d289 1
d298 1
a298 1
      if (the_target->look_up_symbols != NULL)
d307 1
d316 1
d334 2
a335 1
      
d354 1
d387 1
d419 2
d454 2
d503 2
d573 1
a573 1
     
d591 2
d682 2
d814 89
d910 1
d925 22
a982 2
static int attached;

d996 3
a998 2
  printf ("Usage:\tgdbserver COMM PROG [ARGS ...]\n"
	  "\tgdbserver COMM --attach PID\n"
d1001 4
a1004 1
	  "HOST:PORT to listen for a TCP connection.\n");
d1007 8
d1026 5
a1030 1
  char *arg_end;
d1032 1
a1032 1
  if (argc >= 2 && strcmp (argv[1], "--version") == 0)
d1034 24
a1057 2
      gdbserver_version ();
      exit (0);
d1060 1
a1060 1
  if (argc >= 2 && strcmp (argv[1], "--help") == 0)
d1062 2
a1063 2
      gdbserver_usage ();
      exit (0);
d1066 3
a1068 1
  if (setjmp (toplevel))
d1070 1
a1070 1
      fprintf (stderr, "Exiting\n");
a1075 13
  attached = 0;
  if (argc >= 3 && strcmp (argv[2], "--attach") == 0)
    {
      if (argc == 4
	  && argv[3][0] != '\0'
	  && (pid = strtoul (argv[3], &arg_end, 0)) != 0
	  && *arg_end == '\0')
	{
	  ;
	}
      else
	bad_attach = 1;
    }
d1077 17
a1093 1
  if (argc < 3 || bad_attach)
d1105 1
a1105 1
  if (pid == 0)
d1107 8
d1116 1
a1116 1
      signal = start_inferior (&argv[2], &status);
d1122 7
d1131 2
a1132 9
      switch (attach_inferior (pid, &status, &signal))
	{
	case -1:
	  error ("Attaching not supported on this target");
	  break;
	default:
	  attached = 1;
	  break;
	}
d1148 5
d1154 1
a1154 1
      fprintf (stderr, "No inferior, GDBserver exiting.\n");
d1160 1
a1160 1
      remote_open (argv[1]);
d1163 10
a1172 1
      setjmp (toplevel);
d1174 1
a1174 1
      while (1)
d1180 1
d1184 1
d1197 1
d1200 1
a1200 4
		{
		  write_enn (own_buf);
		  putpkt (own_buf);
		}
a1203 2
		  putpkt (own_buf);
		  remote_close ();
d1205 10
a1214 5
		  /* If we are attached, then we can exit.  Otherwise, we
		     need to hang around doing nothing, until the child
		     is gone.  */
		  if (!attached)
		    join_inferior ();
d1216 8
a1223 1
		  exit (0);
d1225 1
d1227 2
a1228 12
	      if (attached == 0)
		{
		  extended_protocol = 1;
		  prepare_resume_reply (own_buf, status, signal);
		}
	      else
		{
		  /* We can not use the extended protocol if we are
		     attached, because we can not restart the running
		     program.  So return unrecognized.  */
		  own_buf[0] = '\0';
		}
d1238 1
d1240 3
a1242 2
		  thread_id = gdb_id_to_thread_id (gdb_id);
		  if (thread_id == 0)
d1244 6
a1249 2
		      write_enn (own_buf);
		      break;
d1272 1
d1277 1
d1283 1
d1291 1
d1299 1
d1308 1
d1317 1
d1326 1
d1331 1
d1354 1
d1385 1
d1398 6
d1406 4
a1409 3
	      /* When using the extended protocol, we start up a new
	         debugging session.   The traditional protocol will
	         exit instead.  */
d1412 3
a1414 5
		  write_ok (own_buf);
		  fprintf (stderr, "GDBserver restarting\n");

		  /* Wait till we are at 1st instruction in prog.  */
		  signal = start_inferior (&argv[2], &status);
a1415 1
		  break;
d1426 1
d1442 2
d1448 2
a1449 2
		  kill_inferior ();
		  write_ok (own_buf);
d1453 7
a1459 1
		  signal = start_inferior (&argv[2], &status);
a1460 1
		  break;
d1489 3
a1491 8
	  if (status == 'W')
	    fprintf (stderr,
		     "\nChild exited with status %d\n", signal);
	  if (status == 'X')
	    fprintf (stderr, "\nChild terminated with signal = 0x%x (%s)\n",
		     target_signal_to_host (signal),
		     target_signal_to_name (signal));
	  if (status == 'W' || status == 'X')
d1493 10
d1504 1
a1504 11
		{
		  fprintf (stderr, "Killing inferior\n");
		  kill_inferior ();
		  write_ok (own_buf);
		  fprintf (stderr, "GDBserver restarting\n");

		  /* Wait till we are at 1st instruction in prog.  */
		  signal = start_inferior (&argv[2], &status);
		  goto restart;
		  break;
		}
d1511 3
d1516 4
a1519 4
      /* We come here when getpkt fails.

         For the extended remote protocol we exit (and this is the only
         way we gracefully exit!).
d1521 1
a1521 3
         For the traditional remote protocol close the connection,
         and re-open it at the top of the loop.  */
      if (extended_protocol)
d1524 4
@


1.61
log
@	* server.c (myresume): Add own_buf argument.
	(main): Update calls.
@
text
@d3 1
a3 1
   2004, 2005, 2006, 2007 Free Software Foundation, Inc.
@


1.60
log
@	* linux-low.c (linux_wait, linux_resume): Do not handle async I/O.
	* remote-utils.c (remote_open): Do not call disable_async_io.
	(block_async_io): Delete.
	(unblock_async_io): Make static.
	(initialize_async_io): New.
	* server.c (handle_v_cont): Handle async I/O here.
	(myresume): Likewise.  Move other common resume tasks here...
	(main): ... from here.  Call initialize_async_io.  Disable async
	I/O before the main loop.
	* server.h (initialize_async_io): Declare.
	(block_async_io, unblock_async_io): Delete prototypes.
	* spu-low.c (spu_resume, spu_wait): Do not handle async I/O here.
@
text
@d803 1
a803 1
myresume (int step, int *signalp, char *statusp)
d1087 1
a1087 1
	      myresume (0, &signal, &status);
d1095 1
a1095 1
	      myresume (1, &signal, &status);
d1099 1
a1099 1
	      myresume (0, &signal, &status);
d1103 1
a1103 1
	      myresume (1, &signal, &status);
@


1.59
log
@	* server.c (main): Don't report dll events on the initial
	connection on attaches.
@
text
@d759 1
d766 1
d803 1
a803 1
myresume (int step, int sig)
d807 3
d825 1
d827 3
d907 1
d959 1
d1087 1
a1087 4
	      set_desired_inferior (0);
	      myresume (0, signal);
	      signal = mywait (&status, 1);
	      prepare_resume_reply (own_buf, status, signal);
d1095 1
a1095 4
	      set_desired_inferior (0);
	      myresume (1, signal);
	      signal = mywait (&status, 1);
	      prepare_resume_reply (own_buf, status, signal);
d1098 2
a1099 4
	      set_desired_inferior (0);
	      myresume (0, 0);
	      signal = mywait (&status, 1);
	      prepare_resume_reply (own_buf, status, signal);
d1102 2
a1103 4
	      set_desired_inferior (0);
	      myresume (1, 0);
	      signal = mywait (&status, 1);
	      prepare_resume_reply (own_buf, status, signal);
@


1.58
log
@	* server.c (main): Relax numerical bases supported for the pid of
	the --attach command line argument.
@
text
@a910 4

      /* Don't report shared library events on the initial connection,
	 even if some libraries are preloaded.  */
      dlls_changed = 0;
d925 5
@


1.57
log
@	* remote.c (remote_cmdlist): New variable.
	(PACKET_vFile_open, PACKET_vFile_pread, PACKET_vFile_pwrite)
	(PACKET_vFile_close, PACKET_vFile_unlink): New constants.
	(remote_buffer_add_string, remote_buffer_add_bytes)
	(remote_buffer_add_int, remote_hostio_parse_result)
	(remote_hostio_send_command, remote_hostio_open, remote_hostio_pwrite)
	(remote_hostio_pread, remote_hostio_close, remote_hostio_unlink)
	(remote_fileio_errno_to_host, remote_hostio_error, fclose_cleanup)
	(remote_hostio_close_cleanup, remote_file_put, remote_file_get)
	(remote_file_delete, remote_put_command, remote_get_command)
	(remote_delete_command, remote_command): New functions.
	(_initialize_remote): Register new packets and commands.
	* Makefile.in (gdb_fileio_h): New variable.
	(remote.o): Update.
	(SUBDIR_MI_OBS): Add mi-cmd-target.o.
	(SUBDIR_MI_SRCS): Add mi/mi-cmd-target.c.
	(mi-cmd-target.o): New rule.
	* mi/mi-cmd-target.c: New file.
	* mi/mi-cmds.c (mi_cmds): Add target-file-delete, target-file-get,
	and target-file-put.
	* mi/mi-cmds.h (mi_cmd_target_file_get, mi_cmd_target_file_put)
	(mi_cmd_target_file_delete): Declare.
	* remote.h (remote_file_put, remote_file_get, remote_file_delete):
	Declare.
	* NEWS: Describe new file transfer support.

	* gdb.texinfo (Debugging Programs with Multiple Processes): Correct
	formatting.
	(Remote Debugging): Add File Transfer section.
	(Remote Configuration): Document Host I/O packets.
	(GDB/MI): Add GDB/MI File Transfer Commands section.
	(Remote Protocol): Add Host I/O Packets section.
	(Packets): Add vFile.

	* Makefile.in (OBS): Add hostio.o.
	(hostio.o): New rule.
	* server.h (handle_vFile): Declare.
	* hostio.c: New file.
	* server.c (handle_v_requests): Take packet_len and new_packet_len
	for binary packets.  Call handle_vFile.
	(main): Update call to handle_v_requests.

	* gdb.server/file-transfer.exp, gdb.server/transfer.txt,
	gdb.mi/mi-file-transfer.exp: New.
@
text
@d883 1
a883 1
	  && (pid = strtoul (argv[3], &arg_end, 10)) != 0
@


1.56
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d775 2
a776 1
handle_v_requests (char *own_buf, char *status, int *signal)
d790 4
d1226 2
a1227 1
	      handle_v_requests (own_buf, &status, &signal);
d1229 1
@


1.55
log
@2007-07-27  Michael Snyder  <michael.snyder@@access-company.com>

	* server.c (main): Check for inferior exit before main loop.
@
text
@d9 1
a9 1
   the Free Software Foundation; either version 2 of the License, or
d18 1
a18 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.54
log
@2007-07-17  Pedro Alves  <pedro_alves@@portugalmail.pt>
	    Daniel Jacobowitz  <dan@@codesourcery.com>

	* config/i386/cygwin.mt (TDEPFILES): Add solib-target.o.
	* coff-pe-read.c (read_pe_exported_syms): Delete verbose
	printf.
	* NEWS: Mention gdbserver DLL support.

	* gdb.base/unload.c (dlopen, dlsym, dlclose, dlerror): Define
	for __WIN32__.
	(SHLIB_NAME): Delete definition.  Always pass dlerror to fprintf.
	* gdb.base/unload.exp: Use shared library test routines.

	* inferiors.c (all_dlls, dlls_changed, get_dll): New.
	(add_thread): Minor cleanups.
	(clear_inferiors): Move lower in the file.  Clear the DLL
	list.
	(free_one_dll, match_dll, loaded_dll, unloaded_dll, clear_list): New.
	* remote-utils.c (prepare_resume_reply): Check dlls_changed.
	(xml_escape_text): New.
	* server.c (handle_query): Handle qXfer:libraries:read.  Report it
	for qSupported.
	(handle_v_cont): Report errors.
	(gdbserver_version): Update.
	(main): Correct size of own_buf.  Do not report initial DLL events.
	* server.h (struct dll_info, all_dlls, dlls_changed, loaded_dll)
	(unloaded_dll, xml_escape_text): New.
	* win32-low.c (enum target_waitkind): Update comments.
	(win32_add_one_solib, get_image_name, winapi_EnumProcessModules)
	(winapi_GetModuleInformation, winapi_GetModuleFileNameExA)
	(win32_EnumProcessModules, win32_GetModuleInformation)
	(win32_GetModuleFileNameExA, load_psapi, psapi_get_dll_name)
	(winapi_CreateToolhelp32Snapshot, winapi_Module32First)
	(winapi_Module32Next, win32_CreateToolhelp32Snapshot)
	(win32_Module32First, win32_Module32Next, load_toolhelp)
	(toolhelp_get_dll_name, handle_load_dll, handle_unload_dll): New.
	(get_child_debug_event): Handle DLL events.
	(win32_wait): Likewise.
@
text
@d83 2
d98 2
a99 1
  /* Wait till we are at 1st instruction in program, return signal number.  */
d905 3
a907 1
      /* We are now stopped at the first instruction of the target process */
d933 6
@


1.53
log
@ChangeLog:

	* remote.c (remote_write_qxfer): New function.
	(remote_xfer_partial): Add handling for TARGET_OBJECT_SPU.
	(remote_read_qxfer): Do not cache empty objects.
	(_initialize_remote): Add PACKET_qXfer_spu_read and
	PACKET_qXfer_spu_write.

doc/ChangeLog:

	* gdb.texinfo (General Query Packets): Document qXfer:spu:read
	and qXfer:spu:write packets and mention them under qSupported.

gdbserver/ChangeLog:

	* remote-utils.c (decode_xfer_write): New function.
	* server.h (decode_xfer_write): Add prototype.
	* server.c (handle_query): Add PACKET_LEN argument.  Support
	qXfer:spu:read and qXfer:spu:write packets.
	(main): Pass packet_len to handle_query.
	* spu-low.c (spu_target_ops): Add spu_proc_xfer_spu.
	* target.h (target_ops): Add qxfer_spu.
@
text
@d461 64
d531 4
d767 1
a767 2
  /* No other way to report an error... */
  strcpy (own_buf, "");
d823 1
a823 1
	  "Copyright (C) 2006 Free Software Foundation, Inc.\n"
d894 1
a894 1
  own_buf = malloc (PBUFSIZ);
d903 4
@


1.52
log
@2007-05-16  Markus Deuling  <deuling@@de.ibm.com>

	* server.c (handle_query): Add reply for qC packet.
@
text
@d144 1
a144 1
  /* After the read/write marker and annex, qXfer looks like a
d258 1
a258 1
handle_query (char *own_buf, int *new_packet_len_p)
d317 63
d469 3
d878 1
a878 1
	      handle_query (own_buf, &new_packet_len);
@


1.51
log
@	* target.h (target_ops): Change return type of detach to int.
	Add join.
	(join_inferior): New.
	* server.c (main): Don't skip detach support on mingw32.
	If the inferior doesn't support detaching return error.
	Call join_inferior instead of using waitpid.
	* linux-low.c (linux_join): New.
	(linux_target_op): Add linux_join.
	* spu-low.c (spu_join): New.
	(spu_target_ops): Add spu_join.
	* win32-low.c (win32_detach): Adapt to new interface.
	Reopen current_process_handle before detaching.  Issue a child
	resume before detaching.
	(win32_join): New.
	(win32_target_op): Add win32_join.
@
text
@d262 9
@


1.50
log
@gdb/

	* arm-wince-tdep.c: New.
	* config/arm/wince.mt (DEPRECATED_TM_FILE): Use tm-arm.h.
	(MT_CFLAGS): Delete.
	(TM_CLIBS): Delete.
	(TDEPFILES): Add arm-wince-tdep.o, corelow.o, solib.o,
	solib-legacy.o, solib-svr4.o, and remove wince.o.
	* configure.tgt (arm*-*-mingw32ce*): Add.
	* signals/signals.c [HAVE_SIGNAL_H]: Check.
	(do_target_signal_to_host): Silence 'not used' warning.
	* config/arm/tm-wince.h: Remove.

gdb/gdbserver/

	* gdbserver/configure.ac: Add errno checking.
	(AC_CHECK_HEADERS): Add errno.h, fcntl.h, signal.h,
	sys/file.h and malloc.h.
	(AC_CHECK_DECLS): Add perror.
	(srv_mingwce): Handle.
	* gdbserver/configure.srv (i[34567]86-*-cygwin*): Add
	win32-i386-low.o to srv_tgtobj.
	(i[34567]86-*-mingw*): Likewise.
	(arm*-*-mingw32ce*): Add case.
	* gdbreplay.c [HAVE_SYS_FILE_H, HAVE_SIGNAL_H,
	HAVE_FCNTL_H, HAVE_ERRNO_H, HAVE_MALLOC_H]: Check.
	[__MINGW32CE__] (strerror): New function.
	[__MINGW32CE__] (errno): Define to GetLastError.
	[__MINGW32CE__] (COUNTOF): New macro.
	(remote_open): Remove extra close call.
	* mem-break.c (delete_breakpoint_at): New function.
	* mem-break.h (delete_breakpoint_at): Declare.
	* remote-utils.c [HAVE_SYS_FILE_H, HAVE_SIGNAL_H,
	HAVE_FCNTL_H, HAVE_UNISTD_H, HAVE_ERRNO_H]: Check.
	[USE_WIN32API] (read, write): Add char* casts.
	* server.c [HAVE_UNISTD_H, HAVE_SIGNAL_H]: Check.
	* server.h: Include wincecompat.h on Windows CE.
	[HAVE_ERRNO_H]: Check.
	(perror): Declare if not declared.
	* utils.c: Add stdlib.h, errno.h and malloc.h includes.
	(perror_with_name): Remove errno declaration.
	* wincecompat.h: New.
	* wincecompat.c: New.
	* win32-low.h: New.
	* win32-arm-low.c: New.
	* win32-i386-low.c: New.
	(win32-low.c): Include mem-break.h and win32-low.h, and winnt.h.
	(OUTMSG2): Make it safe.
	(_T): New macro.
	(COUNTOF): New macro.
	(NUM_REGS): Get it from the low target.
	(CONTEXT_EXTENDED_REGISTERS, CONTEXT_FLOATING_POINT,
	CONTEXT_DEBUG_REGISTERS): Add fallbacks to 0.
	(thread_rec): Let low target handle debug registers.
	(child_add_thread): Likewise.
	(child_init_thread_list): Likewise.
	(continue_one_thread): Likewise.
	(regptr): New.
	(do_child_fetch_inferior_registers): Move to ...
	* win32-i386-low.c: ... here, and rename to ...
	(do_fetch_inferior_registers): ... this.
	* win32-low.c (child_fetch_inferior_registers):
	Go through the low target.
	(do_child_store_inferior_registers): Use regptr.
	(strwinerror): New function.
	(win32_create_inferior): Handle Windows CE.
	Use strwinerror instead of strerror on Windows error
	codes.  Add program to the error output.
	Don't close the main thread handle on Windows CE.
	(win32_attach): Use coredll.dll on Windows CE.
	(win32_kill): Close current process and current
	thread handles.
	(win32_detach): Use coredll.dll on Windows CE.
	(win32_resume): Let low target handle debug registers, and
	step request.
	(handle_exception): Add/Remove initial breakpoint.  Avoid
	non-existant WSTOPSIG on Windows CE.
	(win32_read_inferior_memory): Cast to remove warning.
	(win32_arch_string): Go through the low target.
	(initialize_low): Call set_breakpoint_data with the low
	target's breakpoint.
	* win32-low.c (dr, FLAG_TRACE_BIT, FCS_REGNUM,
	FOP_REGNUM, mappings): Move to ...
	* win32-i386-low.c: ... here.
	* win32-low.c (win32_thread_info): Move to ...
	* win32-low.h: ... here.
	* Makefile.in (SFILES): Add win32-low.c, win32-i386-low.c,
	win32-arm-low.c and wincecompat.c.
	(all:): Add $EXEEXT.
	(install-only:): Likewise.
	(gdbserver:): Likewise.
	(gdbreplay:): Likewise.
	* config.in: Regenerate.
	* configure: Regenerate.
@
text
@a807 3
#ifndef USE_WIN32API
	    /* Skip "detach" support on mingw32, since we don't have
	       waitpid.  */
d810 4
a813 16
	      detach_inferior ();
	      write_ok (own_buf);
	      putpkt (own_buf);
	      remote_close ();

	      /* If we are attached, then we can exit.  Otherwise, we need to
		 hang around doing nothing, until the child is gone.  */
	      if (!attached)
		{
		  int status, ret;

		  do {
		    ret = waitpid (signal_pid, &status, 0);
		    if (WIFEXITED (status) || WIFSIGNALED (status))
		      break;
		  } while (ret != -1 || errno != ECHILD);
d815 5
d821 5
a825 2
	      exit (0);
#endif
d827 2
@


1.49
log
@2007-03-27  Mat Hostetter  <mat@@lcs.mit.edu>

	* server.c (main): Correct strtoul check.
@
text
@d24 1
d26 2
d29 1
@


1.48
log
@	* gdb.texinfo (Monitor commands for gdbserver): New subsection.

	* remote-utils.c (monitor_output): New function.
	* server.c (debug_threads): Define here.
	(monitor_show_help): New function.
	(handle_query): Handle qRcmd.
	(main): Do not handle 'd' packet.
	* server.h (debug_threads, remote_debug, monitor_output): Declare.
	* linux-low.c, spu-low.c, win32-i386-low.c: Remove definitions
	of debug_threads.

	* gdb.server/server-mon.exp: New test.
@
text
@d730 1
a730 1
	  && argv[3] != '\0'
@


1.47
log
@	* server.c (get_features_xml): Check if target implemented
	arch_string.
	* win32-i386-low.c (win32_arch_string): New.
	(win32_target_ops): Add win32_arch_string as arch_string member.
@
text
@d38 4
d242 10
d459 49
a803 3
	    case 'd':
	      remote_debug = !remote_debug;
	      break;
@


1.46
log
@	* features/Makefile, features/arm-with-iwmmxt.xml,
	features/gdbserver-regs.xsl, features/number-regs.xsl,
	features/sort-regs.xsl, features/xscale-iwmmxt.xml: New files.
	* regformats/arm-with-iwmmxt.dat: Generate.
	* NEWS: Mention iWMMXt.

	* gdb.arch/iwmmxt-regs.c, gdb.arch/iwmmxt-regs.exp: New.

	* Makefile.in (OBS): Add $(XML_BUILTIN).
	(XML_DIR, XML_TARGET, XML_FILES, XML_BUILTIN): New.
	(clean): Update.
	(target.xml, xml-builtin.c, stamp-xml, arm-with-iwmmxt.o)
	(arm-with-iwmmxt.c): New.
	* config.in, configure: Regenerate.
	* configure.ac: Check for iWMMXt.  Handle srv_xmltarget,
	srv_xmlbuiltin, and srv_xmlfiles.  Define USE_XML.
	* configure.srv: Mention srv_xmltarget and srv_xmlfiles.
	(arm*-*-linux*): Add iWMMXt and regset support.
	* linux-arm-low.c (PTRACE_GETWMMXREGS, PTRACE_SETWMMXREGS): Define.
	(arm_fill_gregset, arm_store_gregset, arm_fill_wmmxregset)
	(arm_store_wmmxregset, target_regsets): New.
	* server.c (get_features_xml): Take annex argument.  Check builtin
	XML documents.
	(handle_query): Handle multiple annexes.
@
text
@d219 3
a221 1
      const char *arch = (*the_target->arch_string) ();
@


1.45
log
@XML feature description support.

	* NEWS: Mention target descriptions, "set tdesc filename",
	"unset tdesc filename", "show tdesc filename", and
	qXfer:features:read.
	* arch-utils.c (choose_architecture_for_target): New function.
	(gdbarch_info_fill): Call it.
	* target-descriptions.c (struct property): Make members non-const.
	(struct target_desc): Add arch member.
	(target_description_filename): New variable.
	(target_find_description): Try via XML first.
	(tdesc_architecture): New.
	(free_target_description, make_cleanup_free_target_description): New.
	(set_tdesc_property): Call xstrdup.
	(set_tdesc_architecture, tdesc_set_cmdlist, tdesc_show_cmdlist)
	(tdesc_unset_cmdlist, unset_tdesc_cmd, unset_tdesc_filename_cmd)
	(set_tdesc_cmd, show_tdesc_cmd, set_tdesc_filename_cmd)
	(show_tdesc_filename_cmd, _initialize_target_descriptions): New.
	* target-descriptions.h (tdesc_architecture)
	(make_cleanup_free_target_description, set_tdesc_architecture): New
	prototypes.
	* Makefile.in (SFILES): Add xml-tdesc.c.
	(COMMON_OBS): Add xml-tdesc.o.
	(target-descriptions.o): Update.
	(xml-tdesc.o): New rule.
	* xml-tdesc.c, xml-tdesc.h: New files.
	* remote.c (PACKET_qXfer_features): New enum.
	(remote_protocol_features): Add qXfer:features:read.
	(remote_xfer_partial): Handle TARGET_OBJECT_AVAILABLE_FEATURES.
	(_initialize_remote): Register qXfer:features:read.
	* target.h (enum target_object): Add TARGET_OBJECT_AVAILABLE_FEATURES.
	* features/gdb-target.dtd: New file.

	* linux-i386-low.c (the_low_target): Set arch_string.
	* linux-x86-64-low.c (the_low_target): Likewise.
	* linux-low.c (linux_arch_string): New.
	(linux_target_ops): Add it.
	* linux-low.h (struct linux_target_ops): Add arch_string.
	* server.c (write_qxfer_response): Use const void * for DATA.
	(get_features_xml): New.
	(handle_query): Handle qXfer:features:read.  Report it for qSupported.
	* target.h (struct target_ops): Add arch_string method.

	* gdb.texinfo (Target Descriptions): New section.
	(General Query Packets): Add QPassSignals anchor.  Mention
	qXfer:features:read under qSupported.  Expand mentions of
	qXfer:memory-map:read and QPassSignals.  Document
	qXfer:features:read.
@
text
@d196 1
a196 1
get_features_xml (void)
d201 16
d330 2
a331 1
      document = get_features_xml ();
d338 10
a347 4
      /* Reject any annex other than target.xml; grab the offset and
	 length.  */
      if (decode_xfer_read (own_buf + 20, &annex, &ofs, &len) < 0
	  || strcmp (annex, "target.xml") != 0)
d378 1
a378 1
      if (get_features_xml () != NULL)
@


1.44
log
@Copyright updates for 2007.
@
text
@d148 1
a148 1
write_qxfer_response (char *buf, unsigned char *data, int len, int is_more)
d195 25
d307 39
d355 3
@


1.43
log
@	* remote-utils.c (remote_open): Check the type of specified
	serial port devices before opening them.
	* server.c (main): Kill the inferior if an error occurs during
	the first remote_open.
@
text
@d2 2
a3 3
   Copyright (C) 1989, 1993, 1994, 1995, 1997, 1998, 1999, 2000, 2002, 2003, 2004,
   2005, 2006
   Free Software Foundation, Inc.
@


1.42
log
@gdb/
	* remote.c (PACKET_QPassSignals): New.
	(last_pass_packet, remote_pass_signals): New.
	(remote_protocol_features): Add QPassSignals.
	(remote_query_supported): Correct an infinite loop.
	(remote_open_1): Reset last_pass_packet.
	(remote_resume): Call remote_pass_signals.
	(_initialize_remote): Register "set remote pass-signals".
gdb/doc/
	* gdb.texinfo (Remote configuration): Mention
	"pass-signals-packet".
	(General Query Packets): Document QPassSignals.  Fix
	a typo.
gdb/gdbserver/
	* linux-low.c (linux_wait_for_event): Reformat.  Use the
	pass_signals array.
	* remote-utils.c (decode_address_to_semicolon): New.
	* server.c (pass_signals, handle_general_set): New.
	(handle_query): Mention QPassSignals for qSupported.
	(main): Call handle_general_set.
	* server.h (pass_signals, decode_address_to_semicolon): New.
@
text
@d617 7
@


1.41
log
@	* server.c (handle_query): Correct error handling for read_auxv.
@
text
@d39 2
d162 34
d287 1
a287 1
      sprintf (own_buf, "PacketSize=%x", PBUFSIZ - 1);
d640 3
@


1.40
log
@	* acinclude.m4 (SRV_CHECK_TLS_GET_ADDR): New.
	* configure.ac: Use it.  Define HAVE_TD_THR_TLS_GET_ADDR.
	* config.in, configure: Regenerated.
	* inferiors.c (gdb_id_to_thread): New function.
	(gdb_id_to_thread_id): Use it.
	* linux-low.c (linux_target_ops): Use thread_db_get_tls_address.
	* linux-low.h (struct process_info): Add th member.
	(thread_db_get_tls_address): New prototype.
	* remote-utils.c (decode_address): Make non-static.
	* server.c (handle_query): Handle qGetTLSAddr.
	* server.h (gdb_id_to_thread, decode_address): New prototypes.
	* target.h (struct target_ops): Add get_tls_address.
	* thread-db.c (maybe_attach_thread): Save the thread handle.
	(thread_db_get_tls_address): New.
@
text
@d235 3
a237 1
      if (n > len)
@


1.39
log
@gdb/gdbserver/
	* server.c (terminal_fd): New variable.
	(old_foreground_pgrp): Likewise.
	(restore_old_foreground_pgrp): New function.
	(start_inferior): Record the terminal file descriptor in terminal_fd
	and its original foreground group in old_foreground_pgrp.  Register
	restore_old_foreground_pgrp with atexit().
@
text
@d257 59
@


1.38
log
@	* server.c (handle_query): Correct qPart to qXfer.
@
text
@d48 16
d81 4
a84 1
  tcsetpgrp (fileno (stderr), signal_pid);
@


1.37
log
@gdb/
	* configure.tgt: Build gdbserver for Cygwin and mingw32.
gdb/gdbserver/
	* configure.ac: Check for more headers which are missing on
	Windows.  Automatically supply -lwsock32 and USE_WIN32API.
	* configure.srv: Add Cygwin and mingw32.
	* remote-utils.c: Don't include headers unconditionally which
	are missing on mingw32.  Include <winsock.h> for mingw32.
	(remote_open): Adjust for mingw32 support.  Flush
	standard error after writing to it.
	(remote_close, putpkt_binary, input_interrupt, block_async_io)
	(unblock_async_io, enable_async_io, disable_async_io)
	(readchar, getpkt): Update for Winsock support.
	(prepare_resume_reply): Expect a protocol signal number.
	* server.c: Disable <sys/wait.h> on mingw32.
	(start_inferior): Adjust for mingw32 support.  Flush
	standard error after writing to it.
	(attach_inferior): Likewise.  Use protocol signal
	numbers.
	(main): Skip 'D' packet on mingw32.  Use protocol signal numbers
	and names.
	* win32-i386-low.c: New file.
	* Makefile.in (XM_CLIBS): Set.
	(gdbserver, gdbreplay): Use $(INTERNAL_CFLAGS).
	(win32-i386-low.o): New dependency rule.
	* linux-low.c (linux_wait): Use target signal numbers.
	* target.h (struct target_ops): Doc fix.
	* server.h (target_signal_to_name): New prototype.
	* gdbreplay.c: Don't include headers unconditionally which
	are missing on mingw32.  Include <winsock.h> for mingw32.
	(remote_close, remote_open): Adjust for Winsock support.
	* configure, config.in: Regenerated.
@
text
@d233 1
a233 1
	strcat (own_buf, ";qPart:auxv:read+");
@


1.36
log
@gdb/
	* remote.c (PACKET_qXfer_auxv): New, renamed from PACKET_qPart_auxv.
	(remote_supported_packet): Remove #if 0.
	(remote_protocol_features): Add qPart:auxv:read.
	(remote_unescape_input): New function.
	(readchar): Don't mask off the high bit.
	(read_frame): Use fputstrn_filtered for packet data.
	(getpkt_sane): Return the number of bytes read or -1.  Use
	fputstrn_unfiltered.
	(remote_read_qxfer): New.
	(remote_xfer_partial): Use it for TARGET_OBJECT_AUXV.
	(_initialize_remote): Update packet registration.
	* defs.h (fputstrn_filtered): New prototype.
	* utils.c (fputstrn_filtered): New.
	* NEWS: Mention qXfer.
gdb/doc/
	* gdb.texinfo (OS Information): Update qPart reference to
	qXfer.
	(Remote configuration): Likewise.
	(Overview): Move @@cindex to the start of a paragraph.  Talk
	about binary data encoding.
	(Packets): Refer to the overview for the details of the X
	packet encoding.
	(General Query Packets): Remove qPart description.  Add qXfer
	description.  Add an anchor to qSupported.  Correct feature
	table title.  Add a new feature for qXfer:auxv:read.
	(Interrupts): Add a missing parenthesis.
gdb/gdbserver/
	* server.c (decode_xfer_read, write_qxfer_response): New.
	(handle_query): Take a packet length argument.  Handle
	qXfer:auxv:read instead of qPart:auxv:read.  Mention it in
	the qSupported response.
	(main): Update call to handle_query.
@
text
@d27 1
d29 1
d51 1
d54 1
d60 1
d62 1
d66 1
d82 1
d94 2
a95 2
  if (*statusptr == 'T' && *sigptr == SIGSTOP)
    *sigptr = SIGTRAP;
d527 3
d551 1
d809 3
a811 2
	    fprintf (stderr, "\nChild terminated with signal = 0x%x\n",
		     signal);
@


1.35
log
@	* remote-utils.c (remote_escape_output, remote_unescape_input): New.
	(putpkt_binary): Renamed from putpkt and adjusted for binary
	data.
	(putpkt): New wrapper for putpkt_binary.
	(readchar): Don't mask off the high bit.
	(decode_X_packet): New function.
	* server.c (main): Call putpkt_binary if a handler sets the packet
	length.  Save the length of the incoming packet.  Handle 'X'.
	* server.h (gdb_byte, remote_escape_output, decode_X_packet): New.
@
text
@d94 39
d135 1
a135 1
handle_query (char *own_buf)
d186 1
a186 1
      && strncmp ("qPart:auxv:read::", own_buf, 17) == 0)
d188 2
a189 1
      unsigned char data[(PBUFSIZ - 1) / 2];
d192 18
a209 9
      int n;
      decode_m_packet (&own_buf[17], &ofs, &len); /* "OFS,LEN" */
      if (len > sizeof data)
	len = sizeof data;
      n = (*the_target->read_auxv) (ofs, data, len);
      if (n == 0)
	write_ok (own_buf);
      else if (n < 0)
	write_enn (own_buf);
d211 4
a214 1
	convert_int_to_ascii (data, own_buf, n);
d223 4
d514 1
a514 1
	      handle_query (own_buf);
@


1.34
log
@gdb/
	* NEWS: Mention qSupported.
	* remote.c (struct remote_state): Add explicit_packet_size.
	(get_remote_packet_size): Check explicit_packet_size.
	(get_memory_packet_size): Likewise.
	(PACKET_qSupported): New enum value.
	(struct protocol_feature, remote_supported_packet)
	(remote_packet_size, remote_protocol_features)
	(remote_query_supported): New.
	(remote_open_1): Reset explicit_packet_size.  Call
	remote_query_supported.
	(_initialize_remote): Register qSupported.
gdb/doc/
	* gdb.texinfo (Remote configuration): Document set / show
	remote supported-packets.
	(General Query Packets): Document qSupported packet.
gdb/gdbserver/
	* server.c (handle_query): Handle qSupported.
@
text
@d443 1
a443 1
      while (getpkt (own_buf) > 0)
d446 7
d557 8
d732 4
a735 1
	  putpkt (own_buf);
@


1.33
log
@	* configure.srv (m68k*-*-uclinux*): New target.
	* linux-low.c (linux_create_inferior): Use vfork on mmuless systems.
	(linux_resume_one_process): Remove extraneous cast.
	(linux_read_offsets): New.
	(linux_target_op): Add linux_read_offsets on mmuless systems.
	* server.c (handle_query): Add qOffsets logic.
	* target.h (struct target_ops): Add read_offsets.
@
text
@d166 8
@


1.33.2.1
log
@Changes from nickrob-async-20060828-mergepoint.
@
text
@a26 1
#if HAVE_SYS_WAIT_H
a27 1
#endif
a45 16
#ifdef SIGTTOU
/* A file descriptor for the controlling terminal.  */
int terminal_fd;

/* TERMINAL_FD's original foreground group.  */
pid_t old_foreground_pgrp;

/* Hand back terminal ownership to the original foreground group.  */

static void
restore_old_foreground_pgrp (void)
{
  tcsetpgrp (terminal_fd, old_foreground_pgrp);
}
#endif

a48 1
#ifdef SIGTTOU
a50 1
#endif
a55 1
  fflush (stderr);
a56 1
#ifdef SIGTTOU
d59 1
a59 5
  terminal_fd = fileno (stderr);
  old_foreground_pgrp = tcgetpgrp (terminal_fd);
  tcsetpgrp (terminal_fd, signal_pid);
  atexit (restore_old_foreground_pgrp);
#endif
a74 1
  fflush (stderr);
d86 2
a87 2
  if (*statusptr == 'T' && *sigptr == TARGET_SIGNAL_STOP)
    *sigptr = TARGET_SIGNAL_TRAP;
a93 39
/* Decode a qXfer read request.  Return 0 if everything looks OK,
   or -1 otherwise.  */

static int
decode_xfer_read (char *buf, char **annex, CORE_ADDR *ofs, unsigned int *len)
{
  /* Extract and NUL-terminate the annex.  */
  *annex = buf;
  while (*buf && *buf != ':')
    buf++;
  if (*buf == '\0')
    return -1;
  *buf++ = 0;

  /* After the read/write marker and annex, qXfer looks like a
     traditional 'm' packet.  */
  decode_m_packet (buf, ofs, len);

  return 0;
}

/* Write the response to a successful qXfer read.  Returns the
   length of the (binary) data stored in BUF, corresponding
   to as much of DATA/LEN as we could fit.  IS_MORE controls
   the first character of the response.  */
static int
write_qxfer_response (char *buf, unsigned char *data, int len, int is_more)
{
  int out_len;

  if (is_more)
    buf[0] = 'm';
  else
    buf[0] = 'l';

  return remote_escape_output (data, len, (unsigned char *) buf + 1, &out_len,
			       PBUFSIZ - 2) + 1;
}

d96 1
a96 1
handle_query (char *own_buf, int *new_packet_len_p)
d147 1
a147 1
      && strncmp ("qXfer:auxv:read:", own_buf, 16) == 0)
d149 1
a149 2
      unsigned char *data;
      int n;
d152 9
a160 18
      char *annex;

      /* Reject any annex; grab the offset and length.  */
      if (decode_xfer_read (own_buf + 16, &annex, &ofs, &len) < 0
	  || annex[0] != '\0')
	{
	  strcpy (own_buf, "E00");
	  return;
	}

      /* Read one extra byte, as an indicator of whether there is
	 more.  */
      if (len > PBUFSIZ - 2)
	len = PBUFSIZ - 2;
      data = malloc (len + 1);
      n = (*the_target->read_auxv) (ofs, data, len + 1);
      if (n > len)
	*new_packet_len_p = write_qxfer_response (own_buf, data, len, 1);
d162 1
a162 16
	*new_packet_len_p = write_qxfer_response (own_buf, data, n, 0);

      free (data);

      return;
    }

  /* Protocol features query.  */
  if (strncmp ("qSupported", own_buf, 10) == 0
      && (own_buf[10] == ':' || own_buf[10] == '\0'))
    {
      sprintf (own_buf, "PacketSize=%x", PBUFSIZ - 1);

      if (the_target->read_auxv != NULL)
	strcat (own_buf, ";qXfer:auxv:read+");

d435 1
a435 1
      while (1)
a437 7
	  int packet_len;
	  int new_packet_len = -1;

	  packet_len = getpkt (own_buf);
	  if (packet_len <= 0)
	    break;

d443 1
a443 1
	      handle_query (own_buf, &new_packet_len);
a447 3
#ifndef USE_WIN32API
	    /* Skip "detach" support on mingw32, since we don't have
	       waitpid.  */
a468 1
#endif
a541 8
	    case 'X':
	      if (decode_X_packet (&own_buf[1], packet_len - 1,
				   &mem_addr, &len, mem_buf) < 0
		  || write_inferior_memory (mem_addr, mem_buf, len) != 0)
		write_enn (own_buf);
	      else
		write_ok (own_buf);
	      break;
d709 1
a709 4
	  if (new_packet_len != -1)
	    putpkt_binary (own_buf, new_packet_len);
	  else
	    putpkt (own_buf);
d715 2
a716 3
	    fprintf (stderr, "\nChild terminated with signal = 0x%x (%s)\n",
		     target_signal_to_host (signal),
		     target_signal_to_name (signal));
@


1.32
log
@	* server.c (attach_inferior): Return SIGTRAP for a successful
	attach.
@
text
@d132 14
@


1.32.2.1
log
@	* gdb/gdbserver/Makefile.in (reg-cf.o, reg-cf.c): New targets.
	* gdb/gdbserver/configure.srv (m68k*-*-uclinux*): New target.
	* gdb/gdbserver/linux-low.c (linux_create_inferior): Use vfork on
	mmuless systems.
	(linux_resume_one_process): Remove extraneous cast.
	(linux_read_offsets): New.
	(linux_target_op): Add linux_read_offsets on mmuless systems.
	* gdb/gdbserver/server.c (handle_query): Add qOffsets logic.
	* gdb/gdbserver/target.h (struct target_ops): Add read_offsets.
@
text
@a131 14
  if (the_target->read_offsets != NULL
      && strcmp ("qOffsets", own_buf) == 0)
    {
      CORE_ADDR text, data;
      
      if (the_target->read_offsets (&text, &data))
	sprintf (own_buf, "Text=%lX;Data=%lX;Bss=%lX",
		 (long)text, (long)data, (long)data);
      else
	write_enn (own_buf);
      
      return;
    }

@


1.32.2.2
log
@	gdb/gdbserver/
	* server.c (terminal_fd): New variable.
	(old_foreground_pgrp): Likewise.
	(restore_old_foreground_pgrp): New function.
	(start_inferior): Record the terminal file descriptor in terminal_fd
	and its original foreground group in old_foreground_pgrp.  Register
	restore_old_foreground_pgrp with atexit().
@
text
@a45 14
/* A file descriptor for the controlling terminal.  */
int terminal_fd;

/* TERMINAL_FD's original foreground group.  */
pid_t old_foreground_pgrp;

/* Hand back terminal ownership to the original foreground group.  */

static void
restore_old_foreground_pgrp (void)
{
  tcsetpgrp (terminal_fd, old_foreground_pgrp);
}

d59 1
a59 4
  terminal_fd = fileno (stderr);
  old_foreground_pgrp = tcgetpgrp (terminal_fd);
  tcsetpgrp (terminal_fd, signal_pid);
  atexit (restore_old_foreground_pgrp);
@


1.32.2.1.2.1
log
@Actually include patch, not just changelog.
@
text
@d278 2
a279 1
  write_enn (own_buf);
a350 3
/* FIXME declare here, give sensible name, give values?  */
extern int debug_threads;

a381 7
  if (argc >= 2 && strcmp (argv[1], "--debug") == 0)
    {
      argc--;
      argv++;
      debug_threads = 1;
    }

d493 2
a494 3
		  if (gdb_id == 0 || gdb_id == -1)
		    thread_id = gdb_id;
		  else
d496 2
a497 6
		      thread_id = gdb_id_to_thread_id (gdb_id);
		      if (thread_id == 0)
			{
			  write_enn (own_buf);
			  break;
			}
@


1.32.2.1.2.2
log
@No, really, check in the RIGHT patch!
[Revert half of changes from previous commit.]
@
text
@d278 1
a278 2
  /* No other way to report an error... */
  strcpy (own_buf, "");
d350 3
d384 7
d502 3
a504 2
		  thread_id = gdb_id_to_thread_id (gdb_id);
		  if (thread_id == 0)
d506 6
a511 2
		      write_enn (own_buf);
		      break;
@


1.32.2.1.2.3
log
@Add experimental support for SymbianOS-related protocol features.
@
text
@a35 1
int exit_requested;
a38 2
static int attached;

a45 4
int restarting_program;

char **program_argv;

a48 4
  int sig;

  attached = 0;

d62 1
a62 5
  restarting_program = 1;
  block_async_io ();
  sig = mywait (statusptr, 0);
  restarting_program = 0;
  return sig;
a73 2
  attached = 1;

a165 61
  if (strncmp ("qRcmd,", own_buf, 6) == 0)
    {
      if (strcmp (own_buf + 6, "65786974") == 0)
	{
	  /* "exit".  */
	  write_ok (own_buf);
	  exit_requested = 1;
	  return;
	}
      else
	{
	  write_enn (own_buf);
	  return;
	}
    }

  /* Otherwise we didn't know what packet it was.  Say we didn't
     understand it.  */
  own_buf[0] = 0;
}

void
handle_query_non_running (char *own_buf)
{
  if (strcmp ("qSymbol::", own_buf) == 0)
    {
      /* No symbols to look up when the target is not running.  */
      write_ok (own_buf);
      return;
    }

  if (strcmp ("qfThreadInfo", own_buf) == 0
      || strcmp ("qsThreadInfo", own_buf) == 0)
    {
      write_enn (own_buf);
      return;
    }

  if (the_target->read_auxv != NULL
      && strncmp ("qPart:auxv:read::", own_buf, 17) == 0)
    {
      write_enn (own_buf);
      return;
    }

  if (strncmp ("qRcmd,", own_buf, 6) == 0)
    {
      if (strcmp (own_buf + 6, "65786974") == 0)
	{
	  /* "exit".  */
	  write_ok (own_buf);
	  exit_requested = 1;
	  return;
	}
      else
	{
	  write_enn (own_buf);
	  return;
	}
    }

d278 2
a279 1
  write_enn (own_buf);
a283 95
/* Attach to a new program.  Return 1 if successful, 0 if failure.  */
int
handle_v_attach (char *own_buf, char *status, int *signal)
{
  int pid;

  /* FIXME: attach_inferior failures may return -1, or may call error().
     gdbserver use of error() is totally busted; the protocol conversation
     gets out of sync.  */

  pid = strtol (own_buf + 8, NULL, 16);
  if (pid != 0 && attach_inferior (pid, status, signal) == 0)
    {
      prepare_resume_reply (own_buf, *status, *signal);
      putpkt (own_buf);
      return 1;
    }
  else
    {
      write_enn (own_buf);
      return 0;
    }
}

/* Run a new program.  Return 1 if successful, 0 if failure.  */
static int
handle_v_run (char *own_buf, char *status, int *signal)
{
  char *p, **pp, *next_p, **new_argv;
  int i, new_argc;

  new_argc = 0;
  for (p = own_buf + strlen ("vRun;"); p && *p; p = strchr (p, ';'))
    {
      p++;
      new_argc++;
    }

  new_argv = malloc ((new_argc + 2) * sizeof (char *));
  i = 0;
  for (p = own_buf + strlen ("vRun;"); *p; p = next_p)
    {
      next_p = strchr (p, ';');
      if (next_p == NULL)
	next_p = p + strlen (p);

      if (i == 0 && p == next_p)
	new_argv[i] = NULL;
      else
	{
	  new_argv[i] = malloc (1 + (next_p - p) / 2);
	  unhexify (new_argv[i], p, (next_p - p) / 2);
	  new_argv[i][(next_p - p) / 2] = '\0';
	}

      if (*next_p)
	next_p++;
      i++;
    }
  new_argv[i] = NULL;

  if (new_argv[0] == NULL)
    {
      if (program_argv == NULL)
	{
	  write_enn (own_buf);
	  return 0;
	}

      new_argv[0] = strdup (program_argv[0]);
    }

  /* Free the old argv.  */
  if (program_argv)
    {
      for (pp = program_argv; *pp != NULL; pp++)
	free (*pp);
      free (program_argv);
    }
  program_argv = new_argv;

  *signal = start_inferior (program_argv, status);
  if (*status == 'T')
    {
      prepare_resume_reply (own_buf, *status, *signal);
      putpkt (own_buf);
      return 1;
    }
  else
    {
      write_enn (own_buf);
      return 0;
    }
}

a299 16
  if (strncmp (own_buf, "vAttach;", 8) == 0)
    {
      fprintf (stderr, "Killing inferior\n");
      kill_inferior ();
      handle_v_attach (own_buf, status, signal);
      return;
    }

  if (strncmp (own_buf, "vRun;", 5) == 0)
    {
      fprintf (stderr, "Killing inferior\n");
      kill_inferior ();
      handle_v_run (own_buf, status, signal);
      return;
    }

a305 30
/* Handle all of the extended 'v' packets.  Return 1 if there is now
   an inferior.  */
int
handle_v_requests_non_running (char *own_buf, char *status, int *signal)
{
  if (strncmp (own_buf, "vCont;", 6) == 0)
    {
      /* Can't do this when not running.  */
      write_enn (own_buf);
      return 0;
    }

  if (strncmp (own_buf, "vCont?", 6) == 0)
    {
      strcpy (own_buf, "vCont;c;C;s;S");
      return 0;
    }

  if (strncmp (own_buf, "vAttach;", 8) == 0)
    return handle_v_attach (own_buf, status, signal);

  if (strncmp (own_buf, "vRun;", 5) == 0)
    return handle_v_run (own_buf, status, signal);

  /* Otherwise we didn't know what packet it was.  Say we didn't
     understand it.  */
  own_buf[0] = 0;
  return 0;
}

d329 2
a350 91
/* FIXME declare here, give sensible name, give values?  */
extern int debug_threads;

/* Handle a single packet.  Return 1 if the program is now running, 0
   if it is not.  */

int
non_running (char *own_buf, char *status, int *signal)
{
  char ch;
  int i = 0;

  ch = own_buf[i++];
  switch (ch)
    {
    case 'q':
      handle_query_non_running (own_buf);
      break;
    case 'd':
      remote_debug = !remote_debug;
      break;
    case 'D':
      /* Can not detach with nothing running.  */
      write_enn (own_buf);
      break;
    case '!':
      /* Already in extended mode.  */
      write_ok (own_buf);
      break;
    case '?':
      prepare_resume_reply (own_buf, *status, *signal);
      break;
    case 'H':
      if (own_buf[1] == 'c' || own_buf[1] == 'g' || own_buf[1] == 's')
	write_enn (own_buf);
      else
	own_buf[0] = 0;
      break;
    case 'g':
    case 'G':
    case 'm':
    case 'M':
    case 'C':
    case 'S':
    case 'c':
    case 's':
      /* Commands which do not make sense without a program to debug.  */
      write_enn (own_buf);
      break;

    case 'k':
      /* This is special.  It doesn't make sense - but we can't reply
	 to it, either.  */
      return 2;

    case 'Z':
    case 'z':
      /* If we return an error, the client will assume we support this
	 particular breakpoint packet.  But maybe we do, and maybe we
	 don't.  However, we don't worry about it - it's a bug in the
	 client to insert breakpoints when there is no inferior.  */
      write_enn (own_buf);
      break;

    case 'T':
      /* Obviously the thread is not alive.  */
      write_enn (own_buf);
      break;

    case 'R':
      /* Restart request.  */
      fprintf (stderr, "GDBserver restarting\n");

      /* Wait till we are at 1st instruction in prog.  */
      *signal = start_inferior (program_argv, status);
      return 1;

    case 'v':
      /* Extended (long) request.  */
      return handle_v_requests_non_running (own_buf, status, signal);

    default:
      /* It is a request we don't understand.  Respond with an
	 empty packet so that gdb knows that we don't support this
	 request.  */
      own_buf[0] = '\0';
      break;
    }
  return 0;
}

a362 1
  int running;
a381 7
  if (argc >= 2 && strcmp (argv[1], "--debug") == 0)
    {
      argc--;
      argv++;
      debug_threads = 1;
    }

d384 1
a410 6
      int i;
      program_argv = malloc (sizeof (char *) * (argc + 1));
      for (i = 0; 2 + i < argc; i++)
	program_argv[i] = strdup (argv[2 + i]);
      program_argv[argc] = NULL;

d412 1
a412 1
      signal = start_inferior (program_argv, &status);
d418 9
a426 4
      if (attach_inferior (pid, &status, &signal) == -1)
	error ("Attaching not supported on this target");

      /* Otherwise succeeded.  */
a427 1
  running = 1;
d435 1
a435 1
      while (!exit_requested && getpkt (own_buf) > 0)
a437 18

	  if (running == 0)
	    {
	      int ret = non_running (own_buf, &status, &signal);
	      if (ret == 1)
		{
		  /* Go back to the top.  We do not call putpkt; the 'R'
		     packet does not expect a response for historical
		     reasons.  */
		  running = 1;
		  goto restart;
		}
	      if (ret == 2)
		/* A packet which should not be responded to.  */
		goto restart;
	      goto done_packet;
	    }

d452 2
d455 3
a457 1
	      if (extended_protocol)
d459 7
a465 4
		  /* Treat this like a normal program exit.  */
		  signal = 0;
		  status = 'W';
		  running = 0;
a466 4
	      else
		{
		  putpkt (own_buf);
		  remote_close ();
d468 1
a468 13
		  /* If we are attached, then we can exit.  Otherwise,
		     we need to hang around doing nothing, until the
		     child is gone.  */
		  if (!attached)
		    {
		      int status, ret;

		      do {
			ret = waitpid (signal_pid, &status, 0);
			if (WIFEXITED (status) || WIFSIGNALED (status))
			  break;
		      } while (ret != -1 || errno != ECHILD);
		    }
a469 3
		  exit (0);
		}
	      break;
d493 2
a494 3
		  if (gdb_id == 0 || gdb_id == -1)
		    thread_id = gdb_id;
		  else
d496 2
a497 6
		      thread_id = gdb_id_to_thread_id (gdb_id);
		      if (thread_id == 0)
			{
			  write_enn (own_buf);
			  break;
			}
a644 3
		  status = 'X';
		  signal = SIGKILL;
#if 0
d648 1
a648 5
		  signal = start_inferior (program_argv, &status);
#else
		  fprintf (stderr, "GDBserver killing inferior\n");
		  running = 0;
#endif
d685 1
a685 1
		  signal = start_inferior (program_argv, &status);
a708 1
done_packet:
d711 7
a717 1
	  if (running && (status == 'W' || status == 'X'))
a718 7
	      if (status == 'W')
		fprintf (stderr,
			 "\nChild exited with status %d\n", signal);
	      if (status == 'X')
		fprintf (stderr, "\nChild terminated with signal = 0x%x\n",
			 signal);

d721 7
a727 1
		  running = 0;
d729 1
d739 4
a742 4
      /* If an exit was requested (using the "monitor exit" command),
	 terminate now.  The only other way to get here is for
	 getpkt to fail; close the connection and reopen it at the
	 top of the loop.  */
d744 3
a746 1
      if (exit_requested)
a748 4
	  if (attached && running)
	    detach_inferior ();
	  else if (running)
	    kill_inferior ();
@


1.32.2.1.2.4
log
@	* gdb/remote.c: Include "gdb/fileio.h".
	(PACKET_Fopen, PACKET_Fread, PACKET_Fwrite, PACKET_Fclose): New
	enums.
	(remote_escape_output, remote_unescape_input): New functions.
	(remote_write_bytes): Use remote_escape_output.
	(readchar): Do not mask off the high bit.
	(read_frame): Print binary packets correctly.
	(getpkt_sane): Likewise.  Return the number of bytes read
	or -1.
	(remote_buffer_add_string, remote_buffer_add_bytes)
	(remote_buffer_add_int, remote_hostio_parse_result)
	(remote_hostio_send_command, remote_hostio_open)
	(remote_hostio_write, remote_hostio_read)
	(remote_hostio_close, remote_fileio_errno_to_host)
	(remote_hostio_error, fclose_cleanup, remote_download_command)
	(remote_upload_command): New functions.
	(_initialize_remote): Register new packets and remote-upload
	and remote-download commands.

	* gdb/doc/gdb.texinfo (File Transfer): New section.
	(Remote Configuration): Document Host I/O packet commands.
	(Host I/O Packets): New section.
	(Packets): Mention overloading of F prefix.

	* gdb/gdbserver/Makefile.in (OBS): Add hostio.o.
	(hostio.o): New rule.
	* gdb/gdbserver/hostio.c: New file.
	* gdb/gdbserver/remote-utils.c (putpkt_binary): New function,
	broken out from putpkt.
	(putpkt): Use it.
	(readchar): Do not mask the high bits.  Correct the buffer
	type.
	* gdb/gdbserver/server.c (main): Leave space for a trailing
	zero in the packet buffer.  Save the length of the
	received packet.  Handle Host I/O requests.  Optionally call
	putpkt_binary.
	* gdb/gdbserver/server.h (handle_f_hostio, putpkt_binary): New
	prototypes.
@
text
@d720 1
a720 1
  own_buf = malloc (PBUFSIZ + 1);
d751 1
a751 1
      while (!exit_requested)
a753 6
	  int new_packet_len = -1;
	  int packet_len;

	  packet_len = getpkt (own_buf);
	  if (packet_len <= 0)
	    break;
a1058 10
	    case 'F':
	      if (handle_f_hostio (own_buf, packet_len, &new_packet_len))
		break;

	      /* It is a request we don't understand.  Respond with an
	         empty packet so that gdb knows that we don't support this
	         request.  */
	      own_buf[0] = '\0';
	      break;

d1068 1
a1068 4
	  if (new_packet_len != -1)
	    putpkt_binary (own_buf, new_packet_len);
	  else
	    putpkt (own_buf);
@


1.31
log
@	* Makefile.in (OBS): Add version.o.
	(STAGESTUFF): Delete.
	(version.o): Add dependencies.
	(version.c): Replace rule.
	(clean): Remove version.c.
	* server.c (gdbserver_version): New.
	(gdbserver_usage): Use printf.
	(main): Handle --version and --help.
	* server.h (version, host_name): Add declarations.
@
text
@d83 6
@


1.30
log
@	* linux-arm-low.c:
	* linux-cris-low.c:
	* inferiors.c:
	* i387-fp.h:
	* i387-fp.c:
	* gdbreplay.c:
	* regcache.c:
	* proc-service.c:
	* mem-break.h:
	* mem-break.c:
	* linux-x86-64-low.c:
	* linux-sh-low.c:
	* linux-s390-low.c:
	* linux-ppc64-low.c:
	* linux-ppc-low.c:
	* linux-mips-low.c:
	* linux-m68k-low.c:
	* linux-m32r-low.c:
	* linux-low.h:
	* linux-low.c:
	* linux-ia64-low.c:
	* linux-i386-low.c:
	* linux-crisv32-low.c:
	* thread-db.c:
	* terminal.h:
	* target.h:
	* target.c:
	* server.h:
	* server.c:
	* remote-utils.c:
	* regcache.h:
	* utils.c:
	* Makefile.in:
	* configure.ac:
	* gdbserver.1: Add (C) after Copyright.  Update the FSF
	address.
@
text
@d3 1
a3 1
   2005
d312 10
d324 5
a328 5
  error ("Usage:\tgdbserver COMM PROG [ARGS ...]\n"
	 "\tgdbserver COMM --attach PID\n"
	 "\n"
	 "COMM may either be a tty device (for serial debugging), or \n"
	 "HOST:PORT to listen for a TCP connection.\n");
d344 12
d379 4
a382 1
    gdbserver_usage();
@


1.29
log
@	* regformats/reg-ia64.dat: Remove NAT registers.

gdbserver:
	* server.c (main): Allocate mem_buf with PBUFSIZ bytes.

	* linux-ia64-low.c (ia64_regmap): Remove NAT registers.
	(ia64_num_regs): Reduce to 462.
@
text
@d2 1
a2 1
   Copyright 1989, 1993, 1994, 1995, 1997, 1998, 1999, 2000, 2002, 2003, 2004,
d20 2
a21 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.28
log
@	* inferiors.c (struct thread_info): Add gdb_id.
	(add_thread): Add gdb_id argument.
	(thread_id_to_gdb_id, thread_to_gdb_id, gdb_id_to_thread_id): New.
	* linux-low.c (linux_create_inferior, linux_attach_lwp): Update
	calls to add_thread.
	* remote-utils.c (prepare_resume_reply: Use thread_to_gdb_id.
	* server.c (handle_query): Use thread_to_gdb_id.
	(handle_v_cont, main): Use gdb_id_to_thread_id.
	* server.h (add_thread): Update prototype.
	(thread_id_to_gdb_id, thread_to_gdb_id, gdb_id_to_thread_id): New
	prototypes.
@
text
@d325 1
a325 1
  unsigned char mem_buf[2000];
d362 1
@


1.28.2.1
log
@2005-03-30  Daniel Jacobowitz  <dan@@codesourcery.com>

	* gdb/Makefile.in (arm-linux-nat.o): Update dependencies.
	* gdb/arm-linux-nat.c: Include "gdb_assert.h".
	(PTRACE_GETWMMXREGS, PTRACE_SETWMMXREGS): Define.
	(arm_linux_has_wmmx_registers): New flag.
	(GET_THREAD_ID): Remove stray punctuation.
	(IWMMXT_REGS_SIZE): Define.
	(fetch_wmmx_regs, store_wmmx_regs): New functions.
	(fetch_inferior_registers, store_inferior_registers): Call them.
	(arm_linux_available_registers): New function.
	* gdb/inftarg.c (child_xfer_partial): Handle
	TARGET_OBJECT_AVAILABLE_REGISTERS.
	* gdb/config/arm/nm-linux.h (arm_linux_available_registers): Add
	prototype.
	(NATIVE_XFER_AVAILABLE_REGISTERS): Define.

	* gdb/gdbserver/linux-arm-low.c (arm_fill_wmmxregset)
	(arm_store_wmmxregset): Remove stray text.
	(arm_available_registers): Remove debugging output.  Use hex.
	* gdb/gdbserver/regcache.c (num_registers): Make global.
	* gdb/gdbserver/server.c (handle_p_packet, handle_P_packet): Check
	the value of regnum.

2005-03-28  Paul Brook  <paul@@codesourcery.com>
	Daniel Jacobowitz  <dan@@codesourcery.com>

	* gdb/Makefile.in: arm-tdep.o depends on $(observer_h).
	* gdb/arm-linux-nat.c (fetch_fpregister, fetch_fpregs,
	store_fpregister, store_fpregs): Rename...
	(fetch_fpa_register, fetch_fpa_regs, store_fpa_register,
	store_fpa_regs): ... to this.
	* gdb/arm-linux-tdep.c (arm_linux_init_abi): Provide ABI specific
	overrides.
	* gdb/arm-tdep.c: Include opserver.h.
	(struct gdbarch_tdep_info): Add.
	(arm_push_dummy_call): Handle doubleword alignment.
	(arm_register_type): Handle iWMMXt and VFP regs.
	(arm_register_byte): Ditto.
	(arm_pseudo_register_read): New function.
	(arm_pseudo_register_write): New function.
	(arm_dwarf_reg_to_regnum): New function.
	(arm_register_sim_regno): Handle iWMMXT regs.
	(arm_register_remote_regno): New function.
	(arm_extract_return_value): Use new macro names.
	(arm_register_name): Handle iWMMXt and VFP registers.
	(arm_sim_available_registers): New function.
	(arm_update_architecture): New function.
	(arm_gdbarch_init): Handle optional register sets.  Register new
	hooks.  Fix misleading error message.
	(_initialize_arm_tdep): Call observer_attach_inferior_created.
	* gdb/arm-tdep.h (ARM_NUM_FP_ARG_REGS, ARM_LAST_FP_ARG_REGNUM,
	FP_REGISTER_SIZE, NUM_FREGS): Rename ...
	(ARM_NUM_FPA_ARG_REGS, ARM_LAST_FPA_ARG_REGNUM, FPA_REGISTER_SIZE,
	NUM_FPA_REGS): ... to this.
	(NUM_IWMMXT_COP0REGS, NUM_IWMMXT_COP1REGS, NUM_IWMMXT_REGS,
	IWMMXT_COP0_REGSIZE, IWMMXT_COP1_REGSIZE, NUM_VFP_XREGS,
	VFP_XREG_SIZE, NUM_VFP_SREGS, VFP_SREG_SIZE, NUM_VFP_PSEUDOS): Define.
	(struct gdbarch_tdep): Add target_has_iwmmxt_regs,
	target_has_vfp_regs, first_iwmmxt_regnum, target_iwmmxt_regnum,
	first_vfp_regnum, first_vfp_pseudo and target_vfp_regnum.
	* gdb/gdbarch.c (struct gdbarch): Add remote_num_g_packet_regs,
	sim_available_registers and register_remote_regno.
	(startup_gdbarch, verify_gdbarch): Ditto.
	(gdbarch_dump): Dump new fields.
	(gdbarch_remote_num_g_packet_regs_p, gdbarch_remote_num_g_packet_regs,
	set_gdbarch_remote_num_g_packet_regs,
	gdbarch_sim_available_registers_p, gdbarch_sim_available_registers,
	set_gdbarch_sim_available_registers, gdbarch_register_remote_regno_p,
	gdbarch_register_remote_regno, set_gdbarch_register_remote_regno):
	New functions.
	* gdb/gdbarch.h: Add prototypes.
	* gdb/gdbarch.sh: Add new fields.
	(deprecated_current_gdbarch_select_hack): Call flush_cached_frames.
	* gdb/remote-sim.h (gdbsim_create_inferior): Call
	observer_notify_inferior_created.
	(gdbsim_xfer_partial): New function.
	(init_gdbsim_ops): Use it.
	* gdb/remote.c (struct remote_state): Add num_g_regs.
	(init_remote_state): Only consider hard regs.  Allow target to provide
	register mapping.
	(packet_reg_from_regnum): Don't check pseudo regs.
	(packet_reg_from_pnum): Ditto.
	(remote_protocol_qPart_availableRegisters): Add.
	(set_remote_protocol_qPart_availableRegisters_packet_cmd,
	show_remote_protocol_qPart_availableRegisters_packet_cmd): New
	functions.
	(fetch_register_using_p, store_register_using_P): Handle arbitrary
	register mappings.
	(fetch_registers_using_g): New function.
	(remote_fetch_registers): Use it.
	(store_registers_using_G): New function.
	(remote_store_registers): Use it.
	(remote_xfer_partial): Handle TARGET_OBJECT_AVAILABLE_REGISTERS.
	(show_remote_cmd): Display availableRegisters.
	(_initialize_remote): Register qPart_availableRegisters.
	* gdb/target.h (enum target_object): Add
	TARGET_OBJECT_AVAILABLE_REGISTERS.
	* gdb/gdbserver/configure.srv (arm*-*-linux*): set
	srv_linux_regsets=yes.
	* gdb/gdbserver/linux-arm-low.c (PTRACE_GETWMMXREGS,
	PTRACE_SETWMMXREGS): Define.
	(arm_fill_gregset, arm_store_gregset, arm_fill_wmmxregset,
	arm_store_wmmxregset, arm_available_registers): New functions.
	(target_regsets): Add.
	(the_low_target): Use arm_available_registers.
	* gdb/gdbserver/linux-low.c (linux_available_registers): New function.
	(linux_target_op): Use it.
	* gdb/gdbserver/linux-low.h (gdbserver/linux-low.h): Add
	available_registers.
	(use_regsets_p): Declare.
	* gdb/gdbserver/regcache.c (g_register_bytes): Add.
	(regcache_invalidate, registers_to_string, registers_from_string):
	Use it.
	(set_register_cache): Set g_register_bytes.
	(supply_register_as_string): New function.
	* gdb/gdbserver/regcache.h (supply_register_as_string): Add prototype.
	* gdb/gdbserver/server.c (handle_query): Handle
	qPart:availableRegisters.
	(handle_p_packet, handle_P_packet): New functions.
	(main): Handle 'p' and 'P' packets.
	* gdb/gdbserver/target.h (struct target_ops): Add available_registers.
	* gdb/regformats/reg-arm.dat: Add last_g_reg and iWMMXT regs.
	* gdb/regformats/regdat.sh: Handle last_g_reg.
	* gdb/regformats/regdef.h (set_register_cache): Update prototype.
@
text
@a145 20
  if (the_target->available_registers != NULL
      && strncmp ("qPart:availableRegisters:read::", own_buf, 31) == 0)
    {
      char *data;
      CORE_ADDR ofs;
      unsigned int len;
      decode_m_packet (&own_buf[31], &ofs, &len); /* "OFS,LEN" */
      if (len > sizeof data)
	len = sizeof data;
      /* FIXME: Handle OFS, LEN */
      data = (*the_target->available_registers) ();
      if (data == NULL || *data == 0)
	write_ok (own_buf);
      else
	convert_int_to_ascii (data, own_buf, strlen (data));
      if (data)
	free (data);
      return;
    }

a285 35
extern int num_registers;

/* Handle a register fetch ('p') request.  */
void
handle_p_packet (char *own_buf)
{
  char *end = own_buf + 1;
  int regnum = strtol (own_buf + 1, &end, 16);

  if (*end || regnum < 0 || regnum >= num_registers)
    {
      write_enn (own_buf);
      return;
    }

  collect_register_as_string (regnum, own_buf);
  own_buf[2 * register_size (regnum)] = 0;
}

void
handle_P_packet (char *own_buf)
{
  char *end = own_buf + 1;
  int regnum = strtol (own_buf + 1, &end, 16);

  if (*end != '=' || regnum < 0 || regnum >= num_registers)
    {
      write_enn (own_buf);
      return;
    }

  supply_register_as_string (regnum, end + 1);
  write_ok (own_buf);
}

a481 9
	    case 'p':
	      set_desired_inferior (1);
	      handle_p_packet (own_buf);
	      break;
	    case 'P':
	      set_desired_inferior (1);
	      handle_P_packet (own_buf);
	      write_ok (own_buf);
	      break;
@


1.27
log
@	* linux-low.c (linux_wait, linux_send_signal): Don't test
	an unsigned long variable for > 0 if it could be MAX_ULONG.
	* server.c (myresume): Likewise.
	* target.c (set_desired_inferior): Likewise.
@
text
@d106 1
a106 1
      sprintf (own_buf, "m%lx", thread_ptr->id);
d115 1
a115 1
	  sprintf (own_buf, "m%lx", thread_ptr->id);
d221 3
a223 1
	  resume_info[i].thread = strtoul (p + 1, &q, 16);
d230 6
d442 1
a442 1
	      switch (own_buf[1])
d444 20
a463 2
		case 'g':
		  general_thread = strtoul (&own_buf[2], NULL, 16);
d465 3
a467 11
		  set_desired_inferior (1);
		  break;
		case 'c':
		  cont_thread = strtoul (&own_buf[2], NULL, 16);
		  write_ok (own_buf);
		  break;
		case 's':
		  step_thread = strtoul (&own_buf[2], NULL, 16);
		  write_ok (own_buf);
		  break;
		default:
a470 1
		  break;
d612 16
a627 4
	      if (mythread_alive (strtoul (&own_buf[1], NULL, 16)))
		write_ok (own_buf);
	      else
		write_enn (own_buf);
@


1.26
log
@	* acconfig.h: Remove.
	* configure.ac: Add a test for socklen_t.  Use three-argument
	AC_DEFINE throughout.
	* config.in: Regenerated using autoheader 2.59.
	* configure: Regenerated.

	* gdbreplay.c (socklen_t): Provide a default.
	(remote_open): Use socklen_t.
	* remote-utils.c (socklen_t): Provide a default.
	(remote_open): Use socklen_t.
	(convert_int_to_ascii, convert_ascii_to_int, decode_M_packet): Use
	unsigned char.

	* i387-fp.c (struct i387_fsave, struct i387_fxsave): Use unsigned
	char for buffers.
	* linux-low.c (linux_read_memory, linux_write_memory)
	(linux_read_auxv): Likewise.
	* mem-break.c (breakpoint_data, set_breakpoint_data, check_mem_read)
	(check_mem_write): Likewise.
	* mem-break.h (set_breakpoint_data, check_mem_read, check_mem_write):
	Likewise.
	* regcache.c (struct inferior_rgcache_data, registers_to_string)
	(registers_from_string, register_data): Likewise.
	* server.c (handle_query, main): Likewise.
	* server.h (convert_ascii_to_int, convert_int_to_ascii)
	(decode_M_packet): Likewise.
	* target.c (read_inferior_memory, write_inferior_memory): Likewise.
	* target.h (struct target_ops): Update read_memory, write_memory,
	and read_auxv.
	(read_inferior_memory, write_inferior_memory): Update.
	* linux-low.h (struct linux_target_ops): Change type of breakpoint
	to unsigned char *.
	* linux-arm-low.c, linux-cris-low.c, linux-crisv32-low.c,
	linux-i386-low.c, linux-m32r-low.c, linux-m68k-low.c,
	linux-mips-low.c, linux-ppc-low.c, linux-ppc64-low.c,
	linux-s390-low.c, linux-sh-low.c: Update for changes in
	read_inferior_memory and the_low_target->breakpoint.
@
text
@d284 1
a284 1
  if (step || sig || cont_thread > 0)
d296 1
a296 1
  resume_info[n].leave_stopped = (cont_thread > 0);
@


1.25
log
@2005-05-12  Orjan Friberg  <orjanf@@axis.com>

	* target.h (struct target_ops): Add insert_watchpoint,
	remove_watchpoint, stopped_by_watchpoint, stopped_data_address function
	pointers for hardware watchpoint support.
	* linux-low.h (struct linux_target_ops): Ditto.
	* linux-low.c (linux_insert_watchpoint, linux_remove_watchpoint)
	(linux_stopped_by_watchpoint, linux_stopped_data_address): New.  Add
	to linux_target_ops.
	* remote-utils.c (prepare_resume_reply): Add watchpoint information to
	reply packet.
	* server.c (main): Recognize 'Z' and 'z' packets.
@
text
@d129 1
a129 1
      char data[(PBUFSIZ - 1) / 2];
d316 2
a317 1
  char ch, status, *own_buf, mem_buf[2000];
@


1.24
log
@	* server.c (start_inferior): Change return type to int.
	(attach_inferior): Change sigptr to int *.
	(handle_v_cont, handle_v_requests): Change signal to int *.
	(main): Change signal to int.
@
text
@d512 60
@


1.23
log
@	* inferiors.c (change_inferior_id, add_thread, find_inferior_id):
	Take unsigned long arguments for PIDs.
	* linux-low.c (add_process, linux_attach_lwp, linux_attach)
	(linux_thread_alive, linux_wait_for_event, kill_lwp, send_sigstop)
	(wait_for_sigstop, linux_resume_one_process)
	(regsets_fetch_inferior_registers, linux_send_signal)
	(linux_read_auxv): Likewise.  Update the types of variables holding
	PIDs.  Update format string specifiers.
	* linux-low.h (struct process_info, linux_attach_lwp): Likewise.
	* remote-utils.c (prepare_resume_reply): Likewise.
	* server.c (cont_thread, general_thread, step_thread)
	(thread_from_wait, old_thread_from_wait, signal_pid): Change type to
	unsigned long.
	(handle_query): Update format specifiers.
	(handle_v_cont, main): Use strtoul for thread IDs.
	* server.h (struct inferior_list_entry): Use unsigned long for ID.
	(add_thread, find_inferior_id, change_inferior_id, cont_thread)
	(general_thread, step_thread, thread_from_wait)
	(old_thread_from_wait): Update.
	* target.h (struct thread_resume): Use unsigned long for THREAD.
	(struct target_ops): Use unsigned long for arguments to attach and
	thread_alive.
@
text
@d46 1
a46 1
static unsigned char
d66 1
a66 1
attach_inferior (int pid, char *statusptr, unsigned char *sigptr)
d153 1
a153 1
handle_v_cont (char *own_buf, char *status, unsigned char *signal)
d258 1
a258 1
handle_v_requests (char *own_buf, char *status, unsigned char *signal)
d318 1
a318 1
  unsigned char signal;
@


1.23.2.1
log
@2005-03-28  Paul Brook  <paul@@codesourcery.com>
	Daniel Jacobowitz  <dan@@codesourcery.com>

	* gdb/Makefile.in: arm-tdep.o depends on $(observer_h).
	* gdb/arm-linux-nat.c (fetch_fpregister, fetch_fpregs,
	store_fpregister, store_fpregs): Rename...
	(fetch_fpa_register, fetch_fpa_regs, store_fpa_register,
	store_fpa_regs): ... to this.
	* gdb/arm-linux-tdep.c (arm_linux_init_abi): Provide ABI specific
	overrides.
	* gdb/arm-tdep.c: Include opserver.h.
	(struct gdbarch_tdep_info): Add.
	(arm_push_dummy_call): Handle doubleword alignment.
	(arm_register_type): Handle iWMMXt and VFP regs.
	(arm_register_byte): Ditto.
	(arm_pseudo_register_read): New function.
	(arm_pseudo_register_write): New function.
	(arm_dwarf_reg_to_regnum): New function.
	(arm_register_sim_regno): Handle iWMMXT regs.
	(arm_register_remote_regno): New function.
	(arm_extract_return_value): Use new macro names.
	(arm_register_name): Handle iWMMXt and VFP registers.
	(arm_sim_available_registers): New function.
	(arm_update_architecture): New function.
	(arm_gdbarch_init): Handle optional register sets.  Register new
	hooks.  Fix misleading error message.
	(_initialize_arm_tdep): Call observer_attach_inferior_created.
	* gdb/arm-tdep.h (ARM_NUM_FP_ARG_REGS, ARM_LAST_FP_ARG_REGNUM,
	FP_REGISTER_SIZE, NUM_FREGS): Rename ...
	(ARM_NUM_FPA_ARG_REGS, ARM_LAST_FPA_ARG_REGNUM, FPA_REGISTER_SIZE,
	NUM_FPA_REGS): ... to this.
	(NUM_IWMMXT_COP0REGS, NUM_IWMMXT_COP1REGS, NUM_IWMMXT_REGS,
	IWMMXT_COP0_REGSIZE, IWMMXT_COP1_REGSIZE, NUM_VFP_XREGS,
	VFP_XREG_SIZE, NUM_VFP_SREGS, VFP_SREG_SIZE, NUM_VFP_PSEUDOS): Define.
	(struct gdbarch_tdep): Add target_has_iwmmxt_regs,
	target_has_vfp_regs, first_iwmmxt_regnum, target_iwmmxt_regnum,
	first_vfp_regnum, first_vfp_pseudo and target_vfp_regnum.
	* gdb/gdbarch.c (struct gdbarch): Add remote_num_g_packet_regs,
	sim_available_registers and register_remote_regno.
	(startup_gdbarch, verify_gdbarch): Ditto.
	(gdbarch_dump): Dump new fields.
	(gdbarch_remote_num_g_packet_regs_p, gdbarch_remote_num_g_packet_regs,
	set_gdbarch_remote_num_g_packet_regs,
	gdbarch_sim_available_registers_p, gdbarch_sim_available_registers,
	set_gdbarch_sim_available_registers, gdbarch_register_remote_regno_p,
	gdbarch_register_remote_regno, set_gdbarch_register_remote_regno):
	New functions.
	* gdb/gdbarch.h: Add prototypes.
	* gdb/gdbarch.sh: Add new fields.
	(deprecated_current_gdbarch_select_hack): Call flush_cached_frames.
	* gdb/remote-sim.h (gdbsim_create_inferior): Call
	observer_notify_inferior_created.
	(gdbsim_xfer_partial): New function.
	(init_gdbsim_ops): Use it.
	* gdb/remote.c (struct remote_state): Add num_g_regs.
	(init_remote_state): Only consider hard regs.  Allow target to provide
	register mapping.
	(packet_reg_from_regnum): Don't check pseudo regs.
	(packet_reg_from_pnum): Ditto.
	(remote_protocol_qPart_availableRegisters): Add.
	(set_remote_protocol_qPart_availableRegisters_packet_cmd,
	show_remote_protocol_qPart_availableRegisters_packet_cmd): New
	functions.
	(fetch_register_using_p, store_register_using_P): Handle arbitrary
	register mappings.
	(fetch_registers_using_g): New function.
	(remote_fetch_registers): Use it.
	(store_registers_using_G): New function.
	(remote_store_registers): Use it.
	(remote_xfer_partial): Handle TARGET_OBJECT_AVAILABLE_REGISTERS.
	(show_remote_cmd): Display availableRegisters.
	(_initialize_remote): Register qPart_availableRegisters.
	* gdb/target.h (enum target_object): Add
	TARGET_OBJECT_AVAILABLE_REGISTERS.
	* gdb/gdbserver/configure.srv (arm*-*-linux*): set
	srv_linux_regsets=yes.
	* gdb/gdbserver/linux-arm-low.c (PTRACE_GETWMMXREGS,
	PTRACE_SETWMMXREGS): Define.
	(arm_fill_gregset, arm_store_gregset, arm_fill_wmmxregset,
	arm_store_wmmxregset, arm_available_registers): New functions.
	(target_regsets): Add.
	(the_low_target): Use arm_available_registers.
	* gdb/gdbserver/linux-low.c (linux_available_registers): New function.
	(linux_target_op): Use it.
	* gdb/gdbserver/linux-low.h (gdbserver/linux-low.h): Add
	available_registers.
	(use_regsets_p): Declare.
	* gdb/gdbserver/regcache.c (g_register_bytes): Add.
	(regcache_invalidate, registers_to_string, registers_from_string):
	Use it.
	(set_register_cache): Set g_register_bytes.
	(supply_register_as_string): New function.
	* gdb/gdbserver/regcache.h (supply_register_as_string): Add prototype.
	* gdb/gdbserver/server.c (handle_query): Handle
	qPart:availableRegisters.
	(handle_p_packet, handle_P_packet): New functions.
	(main): Handle 'p' and 'P' packets.
	* gdb/gdbserver/target.h (struct target_ops): Add available_registers.
	* gdb/regformats/reg-arm.dat: Add last_g_reg and iWMMXT regs.
	* gdb/regformats/regdat.sh: Handle last_g_reg.
	* gdb/regformats/regdef.h (set_register_cache): Update prototype.
@
text
@a145 20
  if (the_target->available_registers != NULL
      && strncmp ("qPart:availableRegisters:read::", own_buf, 31) == 0)
    {
      char *data;
      CORE_ADDR ofs;
      unsigned int len;
      decode_m_packet (&own_buf[31], &ofs, &len); /* "OFS,LEN" */
      if (len > sizeof data)
	len = sizeof data;
      /* FIXME: Handle OFS, LEN */
      data = (*the_target->available_registers) ();
      if (data == NULL || *data == 0)
	write_ok (own_buf);
      else
	convert_int_to_ascii (data, own_buf, strlen (data));
      if (data)
	free (data);
      return;
    }

a277 33
/* Handle a register fetch ('p') request.  */
void
handle_p_packet (char *own_buf)
{
  char *end = own_buf + 1;
  int regnum = strtol (own_buf + 1, &end, 16);

  if (*end)
    {
      write_enn (own_buf);
      return;
    }

  collect_register_as_string (regnum, own_buf);
  own_buf[2 * register_size (regnum)] = 0;
}

void
handle_P_packet (char *own_buf)
{
  char *end = own_buf + 1;
  int regnum = strtol (own_buf + 1, &end, 16);

  if (*end != '=')
    {
      write_enn (own_buf);
      return;
    }

  supply_register_as_string (regnum, end + 1);
  write_ok (own_buf);
}

a463 9
	    case 'p':
	      set_desired_inferior (1);
	      handle_p_packet (own_buf);
	      break;
	    case 'P':
	      set_desired_inferior (1);
	      handle_P_packet (own_buf);
	      write_ok (own_buf);
	      break;
@


1.23.2.2
log
@	* gdb/Makefile.in (arm-linux-nat.o): Update dependencies.
	* gdb/arm-linux-nat.c: Include "gdb_assert.h".
	(PTRACE_GETWMMXREGS, PTRACE_SETWMMXREGS): Define.
	(arm_linux_has_wmmx_registers): New flag.
	(GET_THREAD_ID): Remove stray punctuation.
	(IWMMXT_REGS_SIZE): Define.
	(fetch_wmmx_regs, store_wmmx_regs): New functions.
	(fetch_inferior_registers, store_inferior_registers): Call them.
	(arm_linux_available_registers): New function.
	* gdb/inftarg.c (child_xfer_partial): Handle
	TARGET_OBJECT_AVAILABLE_REGISTERS.
	* gdb/config/arm/nm-linux.h (arm_linux_available_registers): Add
	prototype.
	(NATIVE_XFER_AVAILABLE_REGISTERS): Define.

	* gdb/gdbserver/linux-arm-low.c (arm_fill_wmmxregset)
	(arm_store_wmmxregset): Remove stray text.
	(arm_available_registers): Remove debugging output.  Use hex.
	* gdb/gdbserver/regcache.c (num_registers): Make global.
	* gdb/gdbserver/server.c (handle_p_packet, handle_P_packet): Check
	the value of regnum.
@
text
@a297 2
extern int num_registers;

d305 1
a305 1
  if (*end || regnum < 0 || regnum >= num_registers)
d321 1
a321 1
  if (*end != '=' || regnum < 0 || regnum >= num_registers)
@


1.22
log
@	* server.c (main): Print child status or termination signal from
	variable 'signal', not 'sig'.
@
text
@d2 2
a3 1
   Copyright 1989, 1993, 1994, 1995, 1997, 1998, 1999, 2000, 2002, 2003, 2004
d29 5
a33 5
int cont_thread;
int general_thread;
int step_thread;
int thread_from_wait;
int old_thread_from_wait;
d44 1
a44 1
int signal_pid;
d54 1
a54 1
  fprintf (stderr, "Process %s created; pid = %d\n", argv[0],
d106 1
a106 1
      sprintf (own_buf, "m%x", thread_ptr->id);
d115 1
a115 1
	  sprintf (own_buf, "m%x", thread_ptr->id);
d221 1
a221 1
	  resume_info[i].thread = strtol (p + 1, &q, 16);
d436 1
a436 1
		  general_thread = strtol (&own_buf[2], NULL, 16);
d441 1
a441 1
		  cont_thread = strtol (&own_buf[2], NULL, 16);
d445 1
a445 1
		  step_thread = strtol (&own_buf[2], NULL, 16);
d534 1
a534 1
	      if (mythread_alive (strtol (&own_buf[1], NULL, 16)))
@


1.21
log
@	* linux-low.c (linux_read_memory): Change return type to
	int.  Check for and return error from ptrace().
	* target.c (read_inferior_memory): Change return type to int.  Pass
	back return status from the_target->read_memory().
	* target.h (struct target_ops): Adapt *read_memory() prototype.
	Update comment.
	(read_inferior_memory): Adapt prototype.
	* server.c (main): Return an error packet if
	read_inferior_memory() returns an error.
@
text
@d576 1
a576 1
		     "\nChild exited with status %d\n", sig);
d578 2
a579 1
	    fprintf (stderr, "\nChild terminated with signal = 0x%x\n", sig);
@


1.20
log
@	* server.c (handle_v_cont): Call set_desired_inferior.
@
text
@d465 4
a468 2
	      read_inferior_memory (mem_addr, mem_buf, len);
	      convert_int_to_ascii (mem_buf, own_buf, len);
@


1.20.2.1
log
@	* linux-low.c (linux_read_memory): Change return type to
	int.  Check for and return error from ptrace().
	* target.c (read_inferior_memory): Change return type to int.  Pass
	back return status from the_target->read_memory().
	* target.h (struct target_ops): Adapt *read_memory() prototype.
	Update comment.
	(read_inferior_memory): Adapt prototype.
	* server.c (main): Return an error packet if
	read_inferior_memory() returns an error.
@
text
@d465 2
a466 4
	      if (read_inferior_memory (mem_addr, mem_buf, len) == 0)
		convert_int_to_ascii (mem_buf, own_buf, len);
	      else
		write_enn (own_buf);
@


1.20.2.2
log
@	* server.c (main): Print child status or termination signal from
	variable 'signal', not 'sig'.
@
text
@d576 1
a576 1
		     "\nChild exited with status %d\n", signal);
d578 1
a578 2
	    fprintf (stderr, "\nChild terminated with signal = 0x%x\n",
		     signal);
@


1.19
log
@	* remote-utils.c (remote_open): Print a status notice after
	opening a TCP port.
	* server.c (attach_inferior): Print a status notice after
	attaching.
@
text
@d238 1
@


1.18
log
@	* remote-utils.c (write_enn): Use "E01" instead of "ENN" for the
	error packet.
	* server.c, target.h: Update copyright years.
@
text
@d73 2
@


1.17
log
@2004-02-25  Roland McGrath  <roland@@redhat.com>

	* target.h (struct target_ops): New member `read_auxv'.
	* server.c (handle_query): Handle qPart:auxv:read: query using that.
	* linux-low.c (linux_read_auxv): New function.
	(linux_target_ops): Initialize `read_auxv' member to that.
@
text
@d2 1
a2 1
   Copyright 1989, 1993, 1994, 1995, 1997, 1998, 1999, 2000, 2002
@


1.16
log
@	* linux-low.c (linux_resume): Take a struct thread_resume *
	argument.
	(linux_wait): Update call.
	(resume_ptr): New static variable.
	(linux_continue_one_thread): Renamed from
	linux_continue_one_process.  Use resume_ptr.
	(linux_resume): Use linux_continue_one_thread.
	* server.c (handle_v_cont, handle_v_requests): New functions.
	(myresume): New function.
	(main): Handle 'v' case.
	* target.h (struct thread_resume): New type.
	(struct target_ops): Change argument of "resume" to struct
	thread_resume *.
	(myresume): Delete macro.
@
text
@d107 1
a107 1
  
d122 21
a142 1
      
d394 1
a394 1
	      remote_close ();		  
@


1.16.6.1
log
@Merge mainline to intercu branch.
@
text
@d2 1
a2 1
   Copyright 1989, 1993, 1994, 1995, 1997, 1998, 1999, 2000, 2002, 2003, 2004
a72 2
  fprintf (stderr, "Attached; pid = %d\n", pid);

d107 1
a107 1

d122 1
a122 21

  if (the_target->read_auxv != NULL
      && strncmp ("qPart:auxv:read::", own_buf, 17) == 0)
    {
      char data[(PBUFSIZ - 1) / 2];
      CORE_ADDR ofs;
      unsigned int len;
      int n;
      decode_m_packet (&own_buf[17], &ofs, &len); /* "OFS,LEN" */
      if (len > sizeof data)
	len = sizeof data;
      n = (*the_target->read_auxv) (ofs, data, len);
      if (n == 0)
	write_ok (own_buf);
      else if (n < 0)
	write_enn (own_buf);
      else
	convert_int_to_ascii (data, own_buf, n);
      return;
    }

a215 1
  set_desired_inferior (0);
d374 1
a374 1
	      remote_close ();
d442 2
a443 4
	      if (read_inferior_memory (mem_addr, mem_buf, len) == 0)
		convert_int_to_ascii (mem_buf, own_buf, len);
	      else
		write_enn (own_buf);
d551 1
a551 1
		     "\nChild exited with status %d\n", signal);
d553 1
a553 2
	    fprintf (stderr, "\nChild terminated with signal = 0x%x\n",
		     signal);
@


1.15
log
@gdb/
        * NEWS: Mention gdbserver detach change and "disconnect" command.
        * infcmd.c (disconnect_command): New function.
        (_initialize_infcmd): Add ``disconnect'' command.
        * remote.c (remote_async_detach): Delete.
        (remote_detach): Merge remote_async_detach.
        (remote_disconnect): New.
        (init_remote_ops): Set to_disconnect.
        (init_remote_cisco_ops): Likewise.
        (init_remote_async_ops): Likewise.  Use remote_detach.
        * target.c (cleanup_target): Default to_disconnect.
        (update_current_target): Inherit to_disconnect.
        (target_disconnect, debug_to_disconnect): New functions.
        (setup_target_debug): Set to_disconnect.
        * target.h (struct target_ops): Add to_disconnect.
        (target_disconnect): Add prototype.
gdbserver/
	* linux-low.c: Move comment to linux_thread_alive where it belonged.
	(linux_detach_one_process, linux_detach): New functions.
	(linux_target_ops): Add linux_detach.
	* server.c (main): Handle 'D' packet.
	* target.h (struct target_ops): Add "detach" member.
	(detach_inferior): Define.
mi/
        * mi-cmds.c (mi_cmds): Add "-target-disconnect".
@
text
@d128 149
d535 4
@


1.15.6.1
log
@merge mainline chenges into branch
@
text
@d2 1
a2 1
   Copyright 1989, 1993, 1994, 1995, 1997, 1998, 1999, 2000, 2002, 2003, 2004
a72 2
  fprintf (stderr, "Attached; pid = %d\n", pid);

d107 1
a107 1

d122 1
a122 147

  if (the_target->read_auxv != NULL
      && strncmp ("qPart:auxv:read::", own_buf, 17) == 0)
    {
      char data[(PBUFSIZ - 1) / 2];
      CORE_ADDR ofs;
      unsigned int len;
      int n;
      decode_m_packet (&own_buf[17], &ofs, &len); /* "OFS,LEN" */
      if (len > sizeof data)
	len = sizeof data;
      n = (*the_target->read_auxv) (ofs, data, len);
      if (n == 0)
	write_ok (own_buf);
      else if (n < 0)
	write_enn (own_buf);
      else
	convert_int_to_ascii (data, own_buf, n);
      return;
    }

  /* Otherwise we didn't know what packet it was.  Say we didn't
     understand it.  */
  own_buf[0] = 0;
}

/* Parse vCont packets.  */
void
handle_v_cont (char *own_buf, char *status, unsigned char *signal)
{
  char *p, *q;
  int n = 0, i = 0;
  struct thread_resume *resume_info, default_action;

  /* Count the number of semicolons in the packet.  There should be one
     for every action.  */
  p = &own_buf[5];
  while (p)
    {
      n++;
      p++;
      p = strchr (p, ';');
    }
  /* Allocate room for one extra action, for the default remain-stopped
     behavior; if no default action is in the list, we'll need the extra
     slot.  */
  resume_info = malloc ((n + 1) * sizeof (resume_info[0]));

  default_action.thread = -1;
  default_action.leave_stopped = 1;
  default_action.step = 0;
  default_action.sig = 0;

  p = &own_buf[5];
  i = 0;
  while (*p)
    {
      p++;

      resume_info[i].leave_stopped = 0;

      if (p[0] == 's' || p[0] == 'S')
	resume_info[i].step = 1;
      else if (p[0] == 'c' || p[0] == 'C')
	resume_info[i].step = 0;
      else
	goto err;

      if (p[0] == 'S' || p[0] == 'C')
	{
	  int sig;
	  sig = strtol (p + 1, &q, 16);
	  if (p == q)
	    goto err;
	  p = q;

	  if (!target_signal_to_host_p (sig))
	    goto err;
	  resume_info[i].sig = target_signal_to_host (sig);
	}
      else
	{
	  resume_info[i].sig = 0;
	  p = p + 1;
	}

      if (p[0] == 0)
	{
	  resume_info[i].thread = -1;
	  default_action = resume_info[i];

	  /* Note: we don't increment i here, we'll overwrite this entry
	     the next time through.  */
	}
      else if (p[0] == ':')
	{
	  resume_info[i].thread = strtol (p + 1, &q, 16);
	  if (p == q)
	    goto err;
	  p = q;
	  if (p[0] != ';' && p[0] != 0)
	    goto err;

	  i++;
	}
    }

  resume_info[i] = default_action;

  /* Still used in occasional places in the backend.  */
  if (n == 1 && resume_info[0].thread != -1)
    cont_thread = resume_info[0].thread;
  else
    cont_thread = -1;
  set_desired_inferior (0);

  (*the_target->resume) (resume_info);

  free (resume_info);

  *signal = mywait (status, 1);
  prepare_resume_reply (own_buf, *status, *signal);
  return;

err:
  /* No other way to report an error... */
  strcpy (own_buf, "");
  free (resume_info);
  return;
}

/* Handle all of the extended 'v' packets.  */
void
handle_v_requests (char *own_buf, char *status, unsigned char *signal)
{
  if (strncmp (own_buf, "vCont;", 6) == 0)
    {
      handle_v_cont (own_buf, status, signal);
      return;
    }

  if (strncmp (own_buf, "vCont?", 6) == 0)
    {
      strcpy (own_buf, "vCont;c;C;s;S");
      return;
    }

a125 24
  return;
}

void
myresume (int step, int sig)
{
  struct thread_resume resume_info[2];
  int n = 0;

  if (step || sig || cont_thread > 0)
    {
      resume_info[0].thread
	= ((struct inferior_list_entry *) current_inferior)->id;
      resume_info[0].step = step;
      resume_info[0].sig = sig;
      resume_info[0].leave_stopped = 0;
      n++;
    }
  resume_info[n].thread = -1;
  resume_info[n].step = 0;
  resume_info[n].sig = 0;
  resume_info[n].leave_stopped = (cont_thread > 0);

  (*the_target->resume) (resume_info);
d225 1
a225 1
	      remote_close ();
d293 2
a294 4
	      if (read_inferior_memory (mem_addr, mem_buf, len) == 0)
		convert_int_to_ascii (mem_buf, own_buf, len);
	      else
		write_enn (own_buf);
a385 4
	    case 'v':
	      /* Extended (long) request.  */
	      handle_v_requests (own_buf, &status, &signal);
	      break;
d398 1
a398 1
		     "\nChild exited with status %d\n", signal);
d400 1
a400 2
	    fprintf (stderr, "\nChild terminated with signal = 0x%x\n",
		     signal);
@


1.14
log
@        * linux-low.c (linux_create_inferior): Call setpgid.  Return
        the new PID.
        (unstopped_p, linux_signal_pid): Remove.
        (linux_target_ops): Remove linux_signal_pid.
        * remote-utils.c (putpkt, input_interrupt): Use signal_pid
        global instead of target method.
        * target.h (struct target_ops): Remove signal_pid.  Update comment
        for create_inferior.
        * server.c (signal_pid): New variable.
        (create_inferior): Set signal_pid.  Block SIGTTOU and SIGTTIN in
        gdbserver.  Set the child to be the foreground process group.
        (attach_inferior): Set signal_pid.
@
text
@d220 22
@


1.14.6.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@a127 149
/* Parse vCont packets.  */
void
handle_v_cont (char *own_buf, char *status, unsigned char *signal)
{
  char *p, *q;
  int n = 0, i = 0;
  struct thread_resume *resume_info, default_action;

  /* Count the number of semicolons in the packet.  There should be one
     for every action.  */
  p = &own_buf[5];
  while (p)
    {
      n++;
      p++;
      p = strchr (p, ';');
    }
  /* Allocate room for one extra action, for the default remain-stopped
     behavior; if no default action is in the list, we'll need the extra
     slot.  */
  resume_info = malloc ((n + 1) * sizeof (resume_info[0]));

  default_action.thread = -1;
  default_action.leave_stopped = 1;
  default_action.step = 0;
  default_action.sig = 0;

  p = &own_buf[5];
  i = 0;
  while (*p)
    {
      p++;

      resume_info[i].leave_stopped = 0;

      if (p[0] == 's' || p[0] == 'S')
	resume_info[i].step = 1;
      else if (p[0] == 'c' || p[0] == 'C')
	resume_info[i].step = 0;
      else
	goto err;

      if (p[0] == 'S' || p[0] == 'C')
	{
	  int sig;
	  sig = strtol (p + 1, &q, 16);
	  if (p == q)
	    goto err;
	  p = q;

	  if (!target_signal_to_host_p (sig))
	    goto err;
	  resume_info[i].sig = target_signal_to_host (sig);
	}
      else
	{
	  resume_info[i].sig = 0;
	  p = p + 1;
	}

      if (p[0] == 0)
	{
	  resume_info[i].thread = -1;
	  default_action = resume_info[i];

	  /* Note: we don't increment i here, we'll overwrite this entry
	     the next time through.  */
	}
      else if (p[0] == ':')
	{
	  resume_info[i].thread = strtol (p + 1, &q, 16);
	  if (p == q)
	    goto err;
	  p = q;
	  if (p[0] != ';' && p[0] != 0)
	    goto err;

	  i++;
	}
    }

  resume_info[i] = default_action;

  /* Still used in occasional places in the backend.  */
  if (n == 1 && resume_info[0].thread != -1)
    cont_thread = resume_info[0].thread;
  else
    cont_thread = -1;

  (*the_target->resume) (resume_info);

  free (resume_info);

  *signal = mywait (status, 1);
  prepare_resume_reply (own_buf, *status, *signal);
  return;

err:
  /* No other way to report an error... */
  strcpy (own_buf, "");
  free (resume_info);
  return;
}

/* Handle all of the extended 'v' packets.  */
void
handle_v_requests (char *own_buf, char *status, unsigned char *signal)
{
  if (strncmp (own_buf, "vCont;", 6) == 0)
    {
      handle_v_cont (own_buf, status, signal);
      return;
    }

  if (strncmp (own_buf, "vCont?", 6) == 0)
    {
      strcpy (own_buf, "vCont;c;C;s;S");
      return;
    }

  /* Otherwise we didn't know what packet it was.  Say we didn't
     understand it.  */
  own_buf[0] = 0;
  return;
}

void
myresume (int step, int sig)
{
  struct thread_resume resume_info[2];
  int n = 0;

  if (step || sig || cont_thread > 0)
    {
      resume_info[0].thread
	= ((struct inferior_list_entry *) current_inferior)->id;
      resume_info[0].step = step;
      resume_info[0].sig = sig;
      resume_info[0].leave_stopped = 0;
      n++;
    }
  resume_info[n].thread = -1;
  resume_info[n].step = 0;
  resume_info[n].sig = 0;
  resume_info[n].leave_stopped = (cont_thread > 0);

  (*the_target->resume) (resume_info);
}

a219 22
	    case 'D':
	      fprintf (stderr, "Detaching from inferior\n");
	      detach_inferior ();
	      write_ok (own_buf);
	      putpkt (own_buf);
	      remote_close ();		  

	      /* If we are attached, then we can exit.  Otherwise, we need to
		 hang around doing nothing, until the child is gone.  */
	      if (!attached)
		{
		  int status, ret;

		  do {
		    ret = waitpid (signal_pid, &status, 0);
		    if (WIFEXITED (status) || WIFSIGNALED (status))
		      break;
		  } while (ret != -1 || errno != ECHILD);
		}

	      exit (0);

a363 4
	    case 'v':
	      /* Extended (long) request.  */
	      handle_v_requests (own_buf, &status, &signal);
	      break;
@


1.14.4.1
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@a219 22
	    case 'D':
	      fprintf (stderr, "Detaching from inferior\n");
	      detach_inferior ();
	      write_ok (own_buf);
	      putpkt (own_buf);
	      remote_close ();		  

	      /* If we are attached, then we can exit.  Otherwise, we need to
		 hang around doing nothing, until the child is gone.  */
	      if (!attached)
		{
		  int status, ret;

		  do {
		    ret = waitpid (signal_pid, &status, 0);
		    if (WIFEXITED (status) || WIFSIGNALED (status))
		      break;
		  } while (ret != -1 || errno != ECHILD);
		}

	      exit (0);

@


1.14.4.2
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@a127 149
/* Parse vCont packets.  */
void
handle_v_cont (char *own_buf, char *status, unsigned char *signal)
{
  char *p, *q;
  int n = 0, i = 0;
  struct thread_resume *resume_info, default_action;

  /* Count the number of semicolons in the packet.  There should be one
     for every action.  */
  p = &own_buf[5];
  while (p)
    {
      n++;
      p++;
      p = strchr (p, ';');
    }
  /* Allocate room for one extra action, for the default remain-stopped
     behavior; if no default action is in the list, we'll need the extra
     slot.  */
  resume_info = malloc ((n + 1) * sizeof (resume_info[0]));

  default_action.thread = -1;
  default_action.leave_stopped = 1;
  default_action.step = 0;
  default_action.sig = 0;

  p = &own_buf[5];
  i = 0;
  while (*p)
    {
      p++;

      resume_info[i].leave_stopped = 0;

      if (p[0] == 's' || p[0] == 'S')
	resume_info[i].step = 1;
      else if (p[0] == 'c' || p[0] == 'C')
	resume_info[i].step = 0;
      else
	goto err;

      if (p[0] == 'S' || p[0] == 'C')
	{
	  int sig;
	  sig = strtol (p + 1, &q, 16);
	  if (p == q)
	    goto err;
	  p = q;

	  if (!target_signal_to_host_p (sig))
	    goto err;
	  resume_info[i].sig = target_signal_to_host (sig);
	}
      else
	{
	  resume_info[i].sig = 0;
	  p = p + 1;
	}

      if (p[0] == 0)
	{
	  resume_info[i].thread = -1;
	  default_action = resume_info[i];

	  /* Note: we don't increment i here, we'll overwrite this entry
	     the next time through.  */
	}
      else if (p[0] == ':')
	{
	  resume_info[i].thread = strtol (p + 1, &q, 16);
	  if (p == q)
	    goto err;
	  p = q;
	  if (p[0] != ';' && p[0] != 0)
	    goto err;

	  i++;
	}
    }

  resume_info[i] = default_action;

  /* Still used in occasional places in the backend.  */
  if (n == 1 && resume_info[0].thread != -1)
    cont_thread = resume_info[0].thread;
  else
    cont_thread = -1;

  (*the_target->resume) (resume_info);

  free (resume_info);

  *signal = mywait (status, 1);
  prepare_resume_reply (own_buf, *status, *signal);
  return;

err:
  /* No other way to report an error... */
  strcpy (own_buf, "");
  free (resume_info);
  return;
}

/* Handle all of the extended 'v' packets.  */
void
handle_v_requests (char *own_buf, char *status, unsigned char *signal)
{
  if (strncmp (own_buf, "vCont;", 6) == 0)
    {
      handle_v_cont (own_buf, status, signal);
      return;
    }

  if (strncmp (own_buf, "vCont?", 6) == 0)
    {
      strcpy (own_buf, "vCont;c;C;s;S");
      return;
    }

  /* Otherwise we didn't know what packet it was.  Say we didn't
     understand it.  */
  own_buf[0] = 0;
  return;
}

void
myresume (int step, int sig)
{
  struct thread_resume resume_info[2];
  int n = 0;

  if (step || sig || cont_thread > 0)
    {
      resume_info[0].thread
	= ((struct inferior_list_entry *) current_inferior)->id;
      resume_info[0].step = step;
      resume_info[0].sig = sig;
      resume_info[0].leave_stopped = 0;
      n++;
    }
  resume_info[n].thread = -1;
  resume_info[n].step = 0;
  resume_info[n].sig = 0;
  resume_info[n].leave_stopped = (cont_thread > 0);

  (*the_target->resume) (resume_info);
}

a385 4
	    case 'v':
	      /* Extended (long) request.  */
	      handle_v_requests (own_buf, &status, &signal);
	      break;
@


1.13
log
@2002-06-11  Daniel Jacobowitz  <drow@@mvista.com>

	* gdbserver/thread-db.c: New file.
	* gdbserver/proc-service.c: New file.
	* gdbserver/acinclude.m4: New file.
	* gdbserver/Makefile.in: Add GDBSERVER_LIBS, gdb_proc_service_h,
	proc-service.o, and thread-db.o.
	(linux-low.o): Add USE_THREAD_DB.
	* gdbserver/acconfig.h: Add HAVE_PRGREGSET_T, HAVE_PRFPREGSET_T,
	HAVE_LWPID_T, HAVE_PSADDR_T, and PRFPREGSET_T_BROKEN.
	* gdbserver/aclocal.m4: Regenerated.
	* gdbserver/config.in: Regenerated.
	* gdbserver/configure: Regenerated.
	* gdbserver/configure.in: Check for proc_service.h, sys/procfs.h,
	thread_db.h, and linux/elf.h headrs.
	Check for lwpid_t, psaddr_t, prgregset_t, prfpregset_t, and
	PRFPREGSET_T_BROKEN.  Introduce srv_thread_depfiles and USE_THREAD_DB.
	Check for -lthread_db and thread support.
	* gdbserver/configure.srv: Enable thread_db support for ARM, i386, MIPS,
	PowerPC, and SuperH.
	* gdbserver/i387-fp.c: Constify arguments.
	* gdbserver/i387-fp.h: Likewise.
	* gdbserver/inferiors.c: (struct thread_info): Renamed from
	`struct inferior_info'.  Remove PID member.  Use generic inferior
	list header.  All uses updated.
	(inferiors, signal_pid): Removed.
	(all_threads): New variable.
	(get_thread): Define.
	(add_inferior_to_list): New function.
	(for_each_inferior): New function.
	(change_inferior_id): New function.
	(add_inferior): Removed.
	(remove_inferior): New function.
	(add_thread): New function.
	(free_one_thread): New function.
	(remove_thread): New function.
	(clear_inferiors): Use for_each_inferior and free_one_thread.
	(find_inferior): New function.
	(find_inferior_id): New function.
	(inferior_target_data): Update argument type.
	(set_inferior_target_data): Likewise.
	(inferior_regcache_data): Likewise.
	(set_inferior_regcache_data): Likewise.
	* gdbserver/linux-low.c (linux_bp_reinsert): Remove.
	(all_processes, stopping_threads, using_thrads)
	(struct pending_signals, debug_threads, pid_of): New.
	(inferior_pid): Replace with macro.
	(struct inferior_linux_data): Remove.
	(get_stop_pc, add_process): New functions.
	(linux_create_inferior): Restore SIGRTMIN+1 before calling exec.
	Use add_process and add_thread.
	(linux_attach_lwp): New function, based on old linux_attach.  Use
	add_process and add_thread.  Set stop_expected for new threads.
	(linux_attach): New function.
	(linux_kill_one_process): New function.
	(linux_kill): Kill all LWPs.
	(linux_thread_alive): Use find_inferior_id.
	(check_removed_breakpoints, status_pending_p): New functions.
	(linux_wait_for_process): Renamed from linux_wait_for_one_inferior.
	Update.  Use WNOHANG.  Wait for cloned processes also.  Update process
	struct for the found process.
	(linux_wait_for_event): New function.
	(linux_wait): Use it.  Support LWPs.
	(send_sigstop, wait_for_sigstop, stop_all_processes)
	(linux_resume_one_process, linux_continue_one_process): New functions.
	(linux_resume): Support LWPs.
	(REGISTER_RAW_SIZE): Remove.
	(fetch_register): Use register_size instead.  Call supply_register.
	(usr_store_inferior_registers): Likewise.  Call collect_register.
	Fix recursive case.
	(regsets_fetch_inferior_registers): Improve error message.
	(regsets_store_inferior_registers): Add debugging.
	(linux_look_up_symbols): Call thread_db_init if USE_THREAD_DB.
	(unstopped_p, linux_signal_pid): New functions.
	(linux_target_ops): Add linux_signal_pid.
	(linux_init_signals): New function.
	(initialize_low): Call it.  Initialize using_threads.
	* gdbserver/regcache.c (inferior_regcache_data): Add valid
	flag.
	(get_regcache): Fetch registers lazily.  Add fetch argument
	and update all callers.
	(regcache_invalidate_one, regcache_invalidate): New
	functions.
	(new_register_cache): Renamed from create_register_cache.
	Return the new regcache.
	(free_register_cache): Change argument to a void *.
	(registers_to_string, registers_from_string): Call get_regcache
	with fetch flag set.
	(register_data): Make static.  Pass fetch flag to get_regcache.
	(supply_register): Call get_regcache with fetch flag clear.
	(collect_register): Call get_regcache with fetch flag set.
	(collect_register_as_string): New function.
	* gdbserver/regcache.h: Update.
	* gdbserver/remote-utils.c (putpkt): Flush after debug output and use
	stderr.
	Handle input interrupts while waiting for an ACK.
	(input_interrupt): Use signal_pid method.
	(getpkt): Flush after debug output and use stderr.
	(outreg): Use collect_register_as_string.
	(new_thread_notify, dead_thread_notify): New functions.
	(prepare_resume_reply): Check using_threads.  Set thread_from_wait
	and general_thread.
	(look_up_one_symbol): Flush after debug output.
	* gdbserver/server.c (step_thread, server_waiting): New variables.
	(start_inferior): Don't use signal_pid.  Update call to mywait.
	(attach_inferior): Update call to mywait.
	(handle_query): Handle qfThreadInfo and qsThreadInfo.
	(main): Don't fetch/store registers explicitly.  Use
	set_desired_inferior.  Support proposed ``Hs'' packet.  Update
	calls to mywait.
	* gdbserver/server.h: Update.
	(struct inferior_list, struct_inferior_list_entry): New.
	* gdbserver/target.c (set_desired_inferior): New.
	(write_inferior_memory): Constify.
	(mywait): New function.
	* gdbserver/target.h: Update.
	(struct target_ops): New signal_pid method.
	(mywait): Removed macro, added prototype.

	* gdbserver/linux-low.h (regset_func): Removed.
	(regset_fill_func, regset_store_func): New.
	(enum regset_type): New.
	(struct regset_info): Add type field.  Use new operation types.
	(struct linux_target_ops): stop_pc renamed to get_pc.
	Add decr_pc_after_break and breakpoint_at.
	(get_process, get_thread_proess, get_process_thread)
	(strut process_info, all_processes, linux_attach_lwp)
	(thread_db_init): New.

	* gdbserver/linux-arm-low.c (arm_get_pc, arm_set_pc,
	arm_breakpoint, arm_breakpoint_len, arm_breakpoint_at): New.
	(the_low_target): Add new members.
	* gdbserver/linux-i386-low.c (i386_store_gregset, i386_store_fpregset)
	(i386_store_fpxregset): Constify.
	(target_regsets): Add new kind identifier.
	(i386_get_pc): Renamed from i386_stop_pc.  Simplify.
	(i386_set_pc): Add debugging.
	(i386_breakpoint_at): New function.
	(the_low_target): Add new members.
	* gdbserver/linux-mips-low.c (mips_get_pc, mips_set_pc)
	(mips_breakpoint, mips_breakpoint_len, mips_reinsert_addr)
	(mips_breakpoint_at): New.
	(the_low_target): Add new members.
	* gdbserver/linux-ppc-low.c (ppc_get_pc, ppc_set_pc)
	(ppc_breakpoint, ppc_breakpoint_len, ppc_breakpoint_at): New.
	(the_low_target): Add new members.
	* gdbserver/linux-sh-low.c (sh_get_pc, sh_set_pc)
	(sh_breakpoint, sh_breakpoint_len, sh_breakpoint_at): New.
	(the_low_target): Add new members.
	* gdbserver/linux-x86-64-low.c (target_regsets): Add new kind
	identifier.
@
text
@d24 4
d38 7
d48 4
a51 2
  /* FIXME Check error? Or turn to void.  */
  create_inferior (argv[0], argv);
d54 5
a58 1
	   all_threads.head->id);
d69 1
d72 5
@


1.12
log
@2002-05-15  Daniel Jacobowitz  <drow@@mvista.com>

        From Martin Pool <mbp@@samba.org>:
        * gdbserver/server.c (gdbserver_usage): New function.
        (main): Call it.
@
text
@d26 1
d30 2
d39 3
a41 2
  /* FIXME Print pid properly.  */
  fprintf (stderr, "Process %s created; pid = %d\n", argv[0], signal_pid);
d44 1
a44 1
  return mywait (statusptr);
d55 1
a55 1
  *sigptr = mywait (statusptr);
d66 2
d77 23
d220 1
a220 1
		  fetch_inferior_registers (0);
d226 4
d238 1
d242 1
a243 1
	      store_inferior_registers (-1);
d264 1
d266 1
a266 1
	      signal = mywait (&status);
d275 1
d277 1
a277 1
	      signal = mywait (&status);
d281 1
d283 1
a283 1
	      signal = mywait (&status);
d287 1
d289 1
a289 1
	      signal = mywait (&status);
@


1.12.2.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@a25 1
int step_thread;
a28 2
int server_waiting;

d36 2
a37 3

  fprintf (stderr, "Process %s created; pid = %d\n", argv[0],
	   all_threads.head->id);
d40 1
a40 1
  return mywait (statusptr, 0);
d51 1
a51 1
  *sigptr = mywait (statusptr, 0);
a61 2
  static struct inferior_list_entry *thread_ptr;

a70 23
  if (strcmp ("qfThreadInfo", own_buf) == 0)
    {
      thread_ptr = all_threads.head;
      sprintf (own_buf, "m%x", thread_ptr->id);
      thread_ptr = thread_ptr->next;
      return;
    }
  
  if (strcmp ("qsThreadInfo", own_buf) == 0)
    {
      if (thread_ptr != NULL)
	{
	  sprintf (own_buf, "m%x", thread_ptr->id);
	  thread_ptr = thread_ptr->next;
	  return;
	}
      else
	{
	  sprintf (own_buf, "l");
	  return;
	}
    }
      
d191 1
a191 1
		  set_desired_inferior (1);
a196 4
		case 's':
		  step_thread = strtol (&own_buf[2], NULL, 16);
		  write_ok (own_buf);
		  break;
a204 1
	      set_desired_inferior (1);
a207 1
	      set_desired_inferior (1);
d209 1
a229 1
	      set_desired_inferior (0);
d231 1
a231 1
	      signal = mywait (&status, 1);
a239 1
	      set_desired_inferior (0);
d241 1
a241 1
	      signal = mywait (&status, 1);
a244 1
	      set_desired_inferior (0);
d246 1
a246 1
	      signal = mywait (&status, 1);
a249 1
	      set_desired_inferior (0);
d251 1
a251 1
	      signal = mywait (&status, 1);
@


1.12.2.2
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@a23 4
#include <unistd.h>
#include <signal.h>
#include <sys/wait.h>

a33 7
/* The PID of the originally created or attached inferior.  Used to
   send signals to the process when GDB sends us an asynchronous interrupt
   (user hitting Control-C in the client), and to wait for the child to exit
   when no longer debugging it.  */

int signal_pid;

d37 2
a38 4
  signal (SIGTTOU, SIG_DFL);
  signal (SIGTTIN, SIG_DFL);

  signal_pid = create_inferior (argv[0], argv);
d41 1
a41 5
	   signal_pid);

  signal (SIGTTOU, SIG_IGN);
  signal (SIGTTIN, SIG_IGN);
  tcsetpgrp (fileno (stderr), signal_pid);
a51 1

a53 5

  /* FIXME - It may be that we should get the SIGNAL_PID from the
     attach function, so that it can be the main thread instead of
     whichever we were told to attach to.  */
  signal_pid = pid;
@


1.11
log
@2002-04-20  Daniel Jacobowitz  <drow@@mvista.com>

        * gdbserver/mem-break.c: New file.
        * gdbserver/mem-break.h: New file.
        * gdbserver/Makefile.in: Add mem-break.o rule; update server.h
        dependencies.
        * gdbserver/inferiors.c (struct inferior_info): Add target_data
        member.
        (clear_inferiors): Free target_data member if set.
        (inferior_target_data, set_inferior_target_data): New functions.
        * gdbserver/linux-i386-low.c (i386_breakpoint, i386_breakpoint_len)
        (i386_stop_pc, i386_set_pc): New.  Add to the_low_target.
        * gdbserver/linux-low.c (linux_bp_reinsert): New variable.
        (struct inferior_linux_data): New.
        (linux_create_inferior): Use set_inferior_target_data.
        (linux_attach): Likewise.  Call add_inferior.
        (linux_wait_for_one_inferior): New function.
        (linux_wait): Call it.
        (linux_write_memory): Add const.
        (initialize_low): Call set_breakpoint_data.
        * gdbserver/linux-low.h (struct linux_target_ops): Add breakpoint
        handling members.
        * gdbserver/server.c (attach_inferior): Remove extra add_inferior
        call.
        * gdbserver/server.h: Include mem-break.h.  Update inferior.c
        prototypes.
        * gdbserver/target.c (read_inferior_memory)
        (write_inferior_memory): New functions.
        * gdbserver/target.h (read_inferior_memory)
        (write_inferior_memory): Change macros to prototypes.
        (struct target_ops): Update comments.  Add const to write_memory
        definition.
@
text
@d78 10
d123 1
a123 2
    error ("Usage:\tgdbserver tty prog [args ...]\n"
		 "\tgdbserver tty --attach pid");
@


1.11.4.1
log
@merge from trunk
@
text
@a25 1
int step_thread;
a28 2
int server_waiting;

d36 2
a37 3

  fprintf (stderr, "Process %s created; pid = %d\n", argv[0],
	   all_threads.head->id);
d40 1
a40 1
  return mywait (statusptr, 0);
d51 1
a51 1
  *sigptr = mywait (statusptr, 0);
a61 2
  static struct inferior_list_entry *thread_ptr;

a70 23
  if (strcmp ("qfThreadInfo", own_buf) == 0)
    {
      thread_ptr = all_threads.head;
      sprintf (own_buf, "m%x", thread_ptr->id);
      thread_ptr = thread_ptr->next;
      return;
    }
  
  if (strcmp ("qsThreadInfo", own_buf) == 0)
    {
      if (thread_ptr != NULL)
	{
	  sprintf (own_buf, "m%x", thread_ptr->id);
	  thread_ptr = thread_ptr->next;
	  return;
	}
      else
	{
	  sprintf (own_buf, "l");
	  return;
	}
    }
      
a77 10
static void
gdbserver_usage (void)
{
  error ("Usage:\tgdbserver COMM PROG [ARGS ...]\n"
	 "\tgdbserver COMM --attach PID\n"
	 "\n"
	 "COMM may either be a tty device (for serial debugging), or \n"
	 "HOST:PORT to listen for a TCP connection.\n");
}

d113 2
a114 1
    gdbserver_usage();
d182 1
a182 1
		  set_desired_inferior (1);
a187 4
		case 's':
		  step_thread = strtol (&own_buf[2], NULL, 16);
		  write_ok (own_buf);
		  break;
a195 1
	      set_desired_inferior (1);
a198 1
	      set_desired_inferior (1);
d200 1
a220 1
	      set_desired_inferior (0);
d222 1
a222 1
	      signal = mywait (&status, 1);
a230 1
	      set_desired_inferior (0);
d232 1
a232 1
	      signal = mywait (&status, 1);
a235 1
	      set_desired_inferior (0);
d237 1
a237 1
	      signal = mywait (&status, 1);
a240 1
	      set_desired_inferior (0);
d242 1
a242 1
	      signal = mywait (&status, 1);
@


1.10
log
@2002-04-09  Daniel Jacobowitz  <drow@@mvista.com>

        * linux-low.c (linux_look_up_symbols): New hook.
        (linux_target_ops): Add linux_look_up_symbols.
        * remote-utils.c (decode_address): New function.
        (look_up_one_symbol): New function.
        * server.c (handle_query): Call target look_up_symbols hook.
        * server.h (look_up_one_symbol): Add prototype.
        * target.h (struct target_ops): Add look_up_symbols hook.
@
text
@a50 2
  add_inferior (pid);

@


1.9
log
@2002-04-09  Daniel Jacobowitz  <drow@@mvista.com>

        * gdbserver/inferiors.c: New file.
        * gdbserver/target.c: New file.
        * gdbserver/target.h: New file.
        * gdbserver/Makefile.in:  Add target.o and inferiors.o.  Update
        dependencies.
        * gdbserver/linux-low.c (inferior_pid): New static variable,
        moved from server.c.
        (linux_create_inferior): Renamed from create_inferior.
        Call add_inferior.  Return 0 on success instead of a PID.
        (linux_attach): Renamed from myattach.
        (linux_kill): Renamed from kill_inferior.  Call clear_inferiors ().
        (linux_thread_alive): Renamed from mythread_alive.
        (linux_wait): Renamed from mywait.  Call clear_inferiors () if the
        child dies.
        (linux_resume): Renamed from myresume.  Add missing ``return 0''.
        (regsets_store_inferior_registers): Correct error message.
        Add missing ``return 0''.
        (linux_fetch_registers): Renamed from fetch_inferior_registers.
        (linux_store_registers): Renamed from store_inferior_registers.
        (linux_read_memory): Renamed from read_inferior_memory.
        (linux_write_memory): Renamed from write_inferior_memory.
        (linux_target_ops): New structure.
        (initialize_low): Call set_target_ops ().
        * gdbserver/remote-utils.c (unhexify): New function.
        (hexify): New function.
        (input_interrupt): Send signals to ``signal_pid''.
        * gdbserver/server.c (inferior_pid): Remove.
        (start_inferior): Update create_inferior call.
        (attach_inferior): Call add_inferior.
        (handle_query): New function.
        (main): Call handle_query for `q' packets.
        * gdbserver/server.h: Include "target.h".  Remove obsolete prototypes.
        Add prototypes for "inferiors.c", "target.c", hexify, and unhexify.
@
text
@d66 3
a68 7
#if 0
      strcpy (own_buf, "qSymbol:");
      hexify (own_buf + strlen ("qSymbol:"), "main", 4);
      putpkt (own_buf);
      getpkt (own_buf);
      fprintf (stderr, "Got %s", own_buf);
#endif
@


1.8
log
@2002-04-09  Daniel Jacobowitz  <drow@@mvista.com>

        * gdbserver/Makefile.in: Add WARN_CFLAGS.  Update configury
        dependencies.
        * gdbserver/configure.in: Check for <string.h>
        * gdbserver/configure: Regenerate.
        * gdbserver/config.in: Regenerate.
        * gdbserver/gdbreplay.c: Include needed system headers.
        (remote_open): Remove strchr prototype.
        * gdbserver/linux-low.h: Correct #ifdef to HAVE_LINUX_USRREGS.
        * gdbserver/regcache.c (supply_register): Change buf argument to const void *.
        (supply_register_by_name): Likewise.
        (collect_register): Change buf argument to void *.
        (collect_register_by_name): Likewise.
        * gdbserver/regcache.h: Add missing prototypes.
        * gdbserver/remote-utils.c: Include <arpa/inet.h> for inet_ntoa.
        * gdbserver/server.c (handle_query): New function.
        (attached): New static variable, moved out of main.
        (main): Quiet longjmp clobber warnings.
        * gdbserver/server.h: Add ATTR_NORETURN and ATTR_FORMAT.  Update prototypes.
        * gdbserver/utils.c (error): Remove NORETURN.
        (fatal): Likewise.
@
text
@a29 1
int inferior_pid;
d34 4
a37 2
  inferior_pid = create_inferior (argv[0], argv);
  fprintf (stderr, "Process %s created; pid = %d\n", argv[0], inferior_pid);
d51 1
a51 1
  inferior_pid = pid;
d59 23
d159 3
@


1.7
log
@2002-03-27  Daniel Jacobowitz  <drow@@mvista.com>

        * gdbserver/server.c (main): Call target_signal_to_host_p
        and target_signal_to_host on signals received from the remote.
        * gdbserver/remote-utils.c (prepare_resume_reply): Call
        target_signal_from_host on signals sent to the remote.
        * gdbserver/server.h: Add prototypes.  Include "gdb/signals.h".
        * gdbserver/Makefile.in: Add signals.o.  Add -I${INCLUDE_DIR}.
@
text
@d58 1
d68 2
a69 3
  int bad_attach = 0;
  int pid = 0;
  int attached = 0;
d78 3
@


1.6
log
@2002-02-14  Daniel Jacobowitz  <drow@@mvista.com>

        * gdbserver/Makefile.in: Add regformats directory to INCLUDE_CFLAGS,
        and remove unused $(INCLUDE_DIR).
        Add regcache.c to OBS.
        Add generated register protocol files to clean target.
        Update dependencies for new objects, obsolete old target code.

        * gdbserver/linux-low.c: Remove all platform-specific code to
        new files.  Remove various dead code.  Update to use regcache
        functionality.
        * gdbserver/remote-utils.c (fromhex): Add return statement
        to quiet warning.
        (putpkt): Dynamically allocate buf2 because PBUFSIZ is no longer
        constant.
        (input_interrupt): Add integer parameter to match prototype
        of a signal handler.
        (outreg): Use register_data ().
        (prepare_resume_reply): Use gdbserver_expedite_regs.
        * gdbserver/server.c (main): Dynamically allocate own_buf because
        PBUFSIZ is no longer constant.  Use registers_to_string () and
        registers_from_string ().
        * gdbserver/server.h: No longer include "defs.h".  Add prototypes
        for error (), fatal (), and warning ().  Update definition of
        PBUFSIZ to use regcache functionality.  Add include guard.
        * gdbserver/utils.c (fatal): Add missing ``const''.
        (warning): New function.

        * regformats/regdat.sh: Include "regcache.h" in generated files.
        Provide init_registers () function.
        * regformats/regdef.h: Add prototype for set_register_cache ().
        Add include guard.

        * gdbserver/linux-arm-low.c: New file.
        * gdbserver/linux-i386-low.c: New file.
        * gdbserver/linux-ia64-low.c: New file.
        * gdbserver/linux-m68k-low.c: New file.
        * gdbserver/linux-mips-low.c: New file.
        * gdbserver/linux-ppc-low.c: New file.
        * gdbserver/linux-sh-low.c: New file.

        * gdbserver/regcache.c: New file.
        * gdbserver/regcache.h: New file.

        * gdbserver/low-linux.c: Removed obsolete file.
@
text
@d193 5
a197 1
	      myresume (0, sig);
d203 5
a207 1
	      myresume (1, sig);
@


1.6.2.1
log
@2002-03-29  Daniel Jacobowitz  <drow@@mvista.com>

        Merge from trunk:

        2002-03-27  Daniel Jacobowitz  <drow@@mvista.com>

        * gdbserver/server.c (main): Call target_signal_to_host_p
        and target_signal_to_host on signals received from the remote.
        * gdbserver/remote-utils.c (prepare_resume_reply): Call
        target_signal_from_host on signals sent to the remote.
        * gdbserver/server.h: Add prototypes.  Include "gdb/signals.h".
        * gdbserver/Makefile.in: Add signals.o.  Add -I${INCLUDE_DIR}.


        2002-03-20  Martin M. Hunt  <hunt@@redhat.com>

        * gdbserver/remote-utils.c (remote_open): Don't call
        getprotobyname, we're all using TCP here so just use
        IPPROTO_TCP.
        * gdbserver/gdbreplay.c (remote_open): Ditto.


        2002-03-13  Michal Ludvig  <mludvig@@suse.cz>

        * gdbserver/remote-util.c (remote_open): Print remote-side's
        IP address when remote debugging over the network.
@
text
@d193 1
a193 5
	      if (target_signal_to_host_p (sig))
		signal = target_signal_to_host (sig);
	      else
		signal = 0;
	      myresume (0, signal);
d199 1
a199 5
	      if (target_signal_to_host_p (sig))
		signal = target_signal_to_host (sig);
	      else
		signal = 0;
	      myresume (1, signal);
@


1.5
log
@2002-01-17  Daniel Jacobowitz  <drow@@mvista.com>

        * gdbserver/low-hppabsd.c, gdbserver/low-lynx.c,
        gdbserver/low-nbsd.c, gdbserver/low-sim.c,
        gdbserver/low-sparc.c, gdbserver/low-sun3.c,
        gdbserver/low-linux.c, gdbserver/server.c: Correct copyright notices.
@
text
@d62 1
a62 1
  char ch, status, own_buf[PBUFSIZ], mem_buf[2000];
d97 2
d172 1
a172 1
	      convert_int_to_ascii (registers, own_buf, REGISTER_BYTES);
d175 1
a175 1
	      convert_ascii_to_int (&own_buf[1], registers, REGISTER_BYTES);
@


1.4
log
@2002-01-17  Daniel Jacobowitz  <drow@@mvista.com>

        * low-hppabsd.c (myattach): New function, returning -1.
        * low-lynx.c (myattach): Likewise.
        * low-nbsd.c (myattach): Likewise.
        * low-sim.c (myattach): Likewise.
        * low-sparc.c (myattach): Likewise.
        * low-sun3.c (myattach): Likewise.

        * low-linux.c (myattach): New function.

        * server.c (attach_inferior): New function.
        (main): Handle "--attach".
@
text
@d2 1
a2 1
   Copyright 1989, 1993, 1994, 1995, 1997, 1998, 1999, 2000
@


1.3
log
@Update/correct copyright notices.
@
text
@d42 15
d67 4
d78 16
a93 2
  if (argc < 3)
    error ("Usage: gdbserver tty prog [args ...]");
d97 4
a100 2
  /* Wait till we are at first instruction in program.  */
  signal = start_inferior (&argv[2], &status);
d102 14
a115 1
  /* We are now stopped at the first instruction of the target process */
d134 12
a145 2
	      extended_protocol = 1;
	      prepare_resume_reply (own_buf, status, signal);
d311 2
a312 2
	  fprintf (stderr, "Remote side has terminated connection.  GDBserver will reopen the connection.\n");

@


1.3.6.1
log
@http://www10.software.ibm.com/developerworks/opensource/linux390/exp_src.html
Patch:    gdb-5.1pre-050901-s390.tar.gz (09/11/2001)
MD5: 886251f3719a754dd65a69df462ceac1
@
text
@a22 1
#include "target.h"
d63 1
a132 1
	      sig = target_signal_to_host (sig);
a138 1
	      sig = target_signal_to_host (sig);
d213 2
a214 1
	    fprintf (stderr, "\nChild exited with status %d\n", sig);
d253 1
a253 2
	  fprintf (stderr,
		   "Remote side has terminated connection.  GDBserver will reopen the connection.\n");
@


1.2
log
@Protoization.
@
text
@d2 2
a3 1
   Copyright (C) 1989, 1993 Free Software Foundation, Inc.
@


1.1
log
@Initial revision
@
text
@d4 1
a4 1
This file is part of GDB.
d6 14
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d32 1
a32 3
start_inferior (argv, statusptr)
     char *argv[];
     char *statusptr;
d44 1
a44 3
main (argc, argv)
     int argc;
     char *argv[];
d46 1
a46 1
  char ch, status, own_buf[2000], mem_buf[2000];
d52 1
a52 1
  if (setjmp(toplevel))
d54 2
a55 2
      fprintf(stderr, "Exiting\n");
      exit(1);
d59 3
a61 1
    error("Usage: gdbserver tty prog [args ...]");
d72 2
a73 2
restart:
      setjmp(toplevel);
d156 1
a156 1
		 debugging session.   The traditional protocol will
d181 1
a181 1
		 extended protocol.  */
d203 2
a204 2
		 empty packet so that gdb knows that we don't support this
		 request.  */
d240 2
a241 2
	 For the extended remote protocol we exit (and this is the only
	 way we gracefully exit!).
d243 2
a244 2
	 For the traditional remote protocol close the connection,
	 and re-open it at the top of the loop.  */
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-07-07 post reformat
@
text
@d4 1
a4 1
   This file is part of GDB.
d6 13
a18 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d55 1
a55 1
  if (setjmp (toplevel))
d57 2
a58 2
      fprintf (stderr, "Exiting\n");
      exit (1);
d62 1
a62 1
    error ("Usage: gdbserver tty prog [args ...]");
d73 2
a74 2
    restart:
      setjmp (toplevel);
d157 1
a157 1
	         debugging session.   The traditional protocol will
d182 1
a182 1
	         extended protocol.  */
d204 2
a205 2
	         empty packet so that gdb knows that we don't support this
	         request.  */
d241 2
a242 2
         For the extended remote protocol we exit (and this is the only
         way we gracefully exit!).
d244 2
a245 2
         For the traditional remote protocol close the connection,
         and re-open it at the top of the loop.  */
@


1.1.1.3
log
@import gdb-1999-11-01 snapshot
@
text
@d50 1
a50 1
  char ch, status, own_buf[PBUFSIZ], mem_buf[2000];
@


1.1.1.4
log
@import gdb-1999-11-16 snapshot
@
text
@a64 2
  initialize_low ();

@


