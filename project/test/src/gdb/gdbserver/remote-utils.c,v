head	1.99;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.96.2.1
	gdb_7_6-2013-04-26-release:1.96
	gdb_7_6-branch:1.96.0.2
	gdb_7_6-2013-03-12-branchpoint:1.96
	gdb_7_5_1-2012-11-29-release:1.93
	gdb_7_5-2012-08-17-release:1.93
	gdb_7_5-branch:1.93.0.2
	gdb_7_5-2012-07-18-branchpoint:1.93
	gdb_7_4_1-2012-04-26-release:1.88.2.1
	gdb_7_4-2012-01-24-release:1.88.2.1
	gdb_7_4-branch:1.88.0.2
	gdb_7_4-2011-12-13-branchpoint:1.88
	gdb_7_3_1-2011-09-04-release:1.85
	gdb_7_3-2011-07-26-release:1.85
	gdb_7_3-branch:1.85.0.2
	gdb_7_3-2011-04-01-branchpoint:1.85
	gdb_7_2-2010-09-02-release:1.79
	gdb_7_2-branch:1.79.0.2
	gdb_7_2-2010-07-07-branchpoint:1.79
	gdb_7_1-2010-03-18-release:1.71
	gdb_7_1-branch:1.71.0.2
	gdb_7_1-2010-02-18-branchpoint:1.71
	gdb_7_0_1-2009-12-22-release:1.68
	gdb_7_0-2009-10-06-release:1.68
	gdb_7_0-branch:1.68.0.4
	gdb_7_0-2009-09-16-branchpoint:1.68
	arc-sim-20090309:1.54.6.1
	msnyder-checkpoint-072509-branch:1.68.0.2
	msnyder-checkpoint-072509-branchpoint:1.68
	arc-insight_6_8-branch:1.54.0.6
	arc-insight_6_8-branchpoint:1.54
	insight_6_8-branch:1.54.0.4
	insight_6_8-branchpoint:1.54
	reverse-20081226-branch:1.59.0.2
	reverse-20081226-branchpoint:1.59
	multiprocess-20081120-branch:1.57.0.4
	multiprocess-20081120-branchpoint:1.57
	reverse-20080930-branch:1.57.0.2
	reverse-20080930-branchpoint:1.57
	reverse-20080717-branch:1.56.0.2
	reverse-20080717-branchpoint:1.56
	msnyder-reverse-20080609-branch:1.55.0.2
	msnyder-reverse-20080609-branchpoint:1.55
	drow-reverse-20070409-branch:1.43.0.2
	drow-reverse-20070409-branchpoint:1.43
	gdb_6_8-2008-03-27-release:1.54
	gdb_6_8-branch:1.54.0.2
	gdb_6_8-2008-02-26-branchpoint:1.54
	gdb_6_7_1-2007-10-29-release:1.50
	gdb_6_7-2007-10-10-release:1.50
	gdb_6_7-branch:1.50.0.2
	gdb_6_7-2007-09-07-branchpoint:1.50
	insight_6_6-20070208-release:1.33
	gdb_6_6-2006-12-18-release:1.33
	gdb_6_6-branch:1.33.0.2
	gdb_6_6-2006-11-15-branchpoint:1.33
	insight_6_5-20061003-release:1.28
	gdb-csl-symbian-6_4_50_20060226-12:1.27.4.2
	gdb-csl-sourcerygxx-3_4_4-25:1.26
	nickrob-async-20060828-mergepoint:1.31
	gdb-csl-symbian-6_4_50_20060226-11:1.27.4.2
	gdb-csl-sourcerygxx-4_1-17:1.27
	gdb-csl-20060226-branch-local-2:1.27
	gdb-csl-sourcerygxx-4_1-14:1.27
	gdb-csl-sourcerygxx-4_1-13:1.27
	gdb-csl-sourcerygxx-4_1-12:1.27
	gdb-csl-sourcerygxx-3_4_4-21:1.27
	gdb_6_5-20060621-release:1.28
	gdb-csl-sourcerygxx-4_1-9:1.27
	gdb-csl-sourcerygxx-4_1-8:1.27
	gdb-csl-sourcerygxx-4_1-7:1.27
	gdb-csl-arm-2006q1-6:1.27
	gdb-csl-sourcerygxx-4_1-6:1.27
	gdb-csl-symbian-6_4_50_20060226-10:1.27.4.2
	gdb-csl-symbian-6_4_50_20060226-9:1.27.4.2
	gdb-csl-symbian-6_4_50_20060226-8:1.27.4.2
	gdb-csl-coldfire-4_1-11:1.27
	gdb-csl-sourcerygxx-3_4_4-19:1.27
	gdb-csl-coldfire-4_1-10:1.27
	gdb_6_5-branch:1.28.0.12
	gdb_6_5-2006-05-14-branchpoint:1.28
	gdb-csl-sourcerygxx-4_1-5:1.27
	nickrob-async-20060513-branch:1.28.0.10
	nickrob-async-20060513-branchpoint:1.28
	gdb-csl-sourcerygxx-4_1-4:1.27
	msnyder-reverse-20060502-branch:1.28.0.8
	msnyder-reverse-20060502-branchpoint:1.28
	gdb-csl-morpho-4_1-4:1.27
	gdb-csl-sourcerygxx-3_4_4-17:1.27
	readline_5_1-import-branch:1.28.0.6
	readline_5_1-import-branchpoint:1.28
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.27
	gdb-csl-symbian-20060226-branch:1.27.0.4
	gdb-csl-symbian-20060226-branchpoint:1.27
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.27
	msnyder-reverse-20060331-branch:1.28.0.4
	msnyder-reverse-20060331-branchpoint:1.28
	gdb-csl-available-20060303-branch:1.28.0.2
	gdb-csl-available-20060303-branchpoint:1.28
	gdb-csl-20060226-branch:1.27.0.2
	gdb-csl-20060226-branchpoint:1.27
	gdb_6_4-20051202-release:1.26
	msnyder-fork-checkpoint-branch:1.26.0.8
	msnyder-fork-checkpoint-branchpoint:1.26
	gdb-csl-gxxpro-6_3-branch:1.26.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.26
	gdb_6_4-branch:1.26.0.4
	gdb_6_4-2005-11-01-branchpoint:1.26
	gdb-csl-arm-20051020-branch:1.26.0.2
	gdb-csl-arm-20051020-branchpoint:1.26
	msnyder-tracepoint-checkpoint-branch:1.24.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.24
	gdb-csl-arm-20050325-2005-q1b:1.23
	gdb-csl-arm-20050325-2005-q1a:1.23
	csl-arm-20050325-branch:1.23.0.2
	csl-arm-20050325-branchpoint:1.23
	gdb-post-i18n-errorwarning-20050211:1.22
	gdb-pre-i18n-errorwarning-20050211:1.22
	gdb_6_3-20041109-release:1.22
	gdb_6_3-branch:1.22.0.2
	gdb_6_3-20041019-branchpoint:1.22
	drow_intercu-merge-20040921:1.21
	drow_intercu-merge-20040915:1.21
	jimb-gdb_6_2-e500-branch:1.21.0.12
	jimb-gdb_6_2-e500-branchpoint:1.21
	gdb_6_2-20040730-release:1.21
	gdb_6_2-branch:1.21.0.8
	gdb_6_2-2004-07-10-gmt-branchpoint:1.21
	gdb_6_1_1-20040616-release:1.21
	gdb_6_1-2004-04-05-release:1.21
	drow_intercu-merge-20040402:1.21
	drow_intercu-merge-20040327:1.21
	ezannoni_pie-20040323-branch:1.21.0.6
	ezannoni_pie-20040323-branchpoint:1.21
	cagney_tramp-20040321-mergepoint:1.21
	cagney_tramp-20040309-branch:1.21.0.4
	cagney_tramp-20040309-branchpoint:1.21
	gdb_6_1-branch:1.21.0.2
	gdb_6_1-2004-03-01-gmt-branchpoint:1.21
	drow_intercu-20040221-branch:1.17.0.18
	drow_intercu-20040221-branchpoint:1.17
	cagney_bfdfile-20040213-branch:1.17.0.16
	cagney_bfdfile-20040213-branchpoint:1.17
	drow-cplus-merge-20040208:1.17
	carlton_dictionary-20040126-merge:1.17
	cagney_bigcore-20040122-branch:1.17.0.14
	cagney_bigcore-20040122-branchpoint:1.17
	drow-cplus-merge-20040113:1.17
	drow-cplus-merge-20031224:1.17
	drow-cplus-merge-20031220:1.17
	carlton_dictionary-20031215-merge:1.17
	drow-cplus-merge-20031214:1.17
	carlton-dictionary-20031111-merge:1.17
	gdb_6_0-2003-10-04-release:1.17
	kettenis_sparc-20030918-branch:1.17.0.12
	kettenis_sparc-20030918-branchpoint:1.17
	carlton_dictionary-20030917-merge:1.17
	ezannoni_pie-20030916-branchpoint:1.17
	ezannoni_pie-20030916-branch:1.17.0.10
	cagney_x86i386-20030821-branch:1.17.0.8
	cagney_x86i386-20030821-branchpoint:1.17
	carlton_dictionary-20030805-merge:1.17
	carlton_dictionary-20030627-merge:1.17
	gdb_6_0-branch:1.17.0.6
	gdb_6_0-2003-06-23-branchpoint:1.17
	jimb-ppc64-linux-20030613-branch:1.17.0.4
	jimb-ppc64-linux-20030613-branchpoint:1.17
	cagney_convert-20030606-branch:1.17.0.2
	cagney_convert-20030606-branchpoint:1.17
	cagney_writestrings-20030508-branch:1.16.0.34
	cagney_writestrings-20030508-branchpoint:1.16
	jimb-ppc64-linux-20030528-branch:1.16.0.32
	jimb-ppc64-linux-20030528-branchpoint:1.16
	carlton_dictionary-20030523-merge:1.16
	cagney_fileio-20030521-branch:1.16.0.30
	cagney_fileio-20030521-branchpoint:1.16
	kettenis_i386newframe-20030517-mergepoint:1.16
	jimb-ppc64-linux-20030509-branch:1.16.0.28
	jimb-ppc64-linux-20030509-branchpoint:1.16
	kettenis_i386newframe-20030504-mergepoint:1.16
	carlton_dictionary-20030430-merge:1.16
	kettenis_i386newframe-20030419-branch:1.16.0.26
	kettenis_i386newframe-20030419-branchpoint:1.16
	carlton_dictionary-20030416-merge:1.16
	cagney_frameaddr-20030409-mergepoint:1.16
	kettenis_i386newframe-20030406-branch:1.16.0.24
	kettenis_i386newframe-20030406-branchpoint:1.16
	cagney_frameaddr-20030403-branchpoint:1.16
	cagney_frameaddr-20030403-branch:1.16.0.22
	cagney_framebase-20030330-mergepoint:1.16
	cagney_framebase-20030326-branch:1.16.0.20
	cagney_framebase-20030326-branchpoint:1.16
	cagney_lazyid-20030317-branch:1.16.0.18
	cagney_lazyid-20030317-branchpoint:1.16
	kettenis-i386newframe-20030316-mergepoint:1.16
	offbyone-20030313-branch:1.16.0.16
	offbyone-20030313-branchpoint:1.16
	kettenis-i386newframe-20030308-branch:1.16.0.14
	kettenis-i386newframe-20030308-branchpoint:1.16
	carlton_dictionary-20030305-merge:1.16
	cagney_offbyone-20030303-branch:1.16.0.12
	cagney_offbyone-20030303-branchpoint:1.16
	carlton_dictionary-20030207-merge:1.16
	interps-20030203-mergepoint:1.16
	interps-20030202-branch:1.16.0.10
	interps-20030202-branchpoint:1.16
	cagney-unwind-20030108-branch:1.16.0.8
	cagney-unwind-20030108-branchpoint:1.16
	carlton_dictionary-20021223-merge:1.16
	gdb_5_3-2002-12-12-release:1.16
	carlton_dictionary-20021115-merge:1.16
	kseitz_interps-20021105-merge:1.16
	kseitz_interps-20021103-merge:1.16
	drow-cplus-merge-20021020:1.16
	drow-cplus-merge-20021025:1.16
	carlton_dictionary-20021025-merge:1.16
	carlton_dictionary-20021011-merge:1.16
	drow-cplus-branch:1.16.0.6
	drow-cplus-branchpoint:1.16
	kseitz_interps-20020930-merge:1.16
	carlton_dictionary-20020927-merge:1.16
	carlton_dictionary-branch:1.16.0.4
	carlton_dictionary-20020920-branchpoint:1.16
	gdb_5_3-branch:1.16.0.2
	gdb_5_3-2002-09-04-branchpoint:1.16
	kseitz_interps-20020829-merge:1.16
	cagney_sysregs-20020825-branch:1.15.0.4
	cagney_sysregs-20020825-branchpoint:1.15
	readline_4_3-import-branch:1.15.0.2
	readline_4_3-import-branchpoint:1.15
	gdb_5_2_1-2002-07-23-release:1.8.2.1
	kseitz_interps-20020528-branch:1.14.0.6
	kseitz_interps-20020528-branchpoint:1.14
	cagney_regbuf-20020515-branch:1.14.0.4
	cagney_regbuf-20020515-branchpoint:1.14
	jimb-macro-020506-branch:1.14.0.2
	jimb-macro-020506-branchpoint:1.14
	gdb_5_2-2002-04-29-release:1.8.2.1
	gdb_5_2-branch:1.8.0.2
	gdb_5_2-2002-03-03-branchpoint:1.8
	gdb_5_1_1-2002-01-24-release:1.7
	gdb_5_1_0_1-2002-01-03-release:1.7
	cygnus_cvs_20020108_pre:1.7
	gdb_5_1_0_1-2002-01-03-branch:1.7.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.7
	gdb_5_1-2001-11-21-release:1.7
	gdb_s390-2001-09-26-branch:1.7.0.4
	gdb_s390-2001-09-26-branchpoint:1.7
	gdb_5_1-2001-07-29-branch:1.7.0.2
	gdb_5_1-2001-07-29-branchpoint:1.7
	dberlin-typesystem-branch:1.4.0.2
	dberlin-typesystem-branchpoint:1.4
	gdb-post-ptid_t-2001-05-03:1.4
	gdb-pre-ptid_t-2001-05-03:1.4
	insight-precleanup-2001-01-01:1.3
	gdb-post-protoization-2000-07-29:1.3
	gdb-pre-protoization-2000-07-29:1.2
	gdb-premipsmulti-2000-06-06-branch:1.2.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb-post-params-removal-2000-06-04:1.2
	gdb-pre-params-removal-2000-06-04:1.2
	gdb-post-params-removal-2000-05-28:1.2
	gdb-pre-params-removal-2000-05-28:1.2
	gdb_5_0-2000-05-19-release:1.1.1.3
	gdb_4_18_2-2000-05-18-release:1.1.1.3
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.3
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.3
	gdb_5_0-2000-04-10-branch:1.1.1.3.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.3
	repo-unification-2000-02-06:1.1.1.3
	insight-2000-02-04:1.1.1.3
	gdb-2000-02-04:1.1.1.3
	gdb-2000-02-02:1.1.1.3
	gdb-2000-02-01:1.1.1.3
	gdb-2000-01-31:1.1.1.3
	gdb-2000-01-26:1.1.1.3
	gdb-2000-01-24:1.1.1.3
	gdb-2000-01-17:1.1.1.3
	gdb-2000-01-10:1.1.1.3
	gdb-2000-01-05:1.1.1.3
	gdb-1999-12-21:1.1.1.3
	gdb-1999-12-13:1.1.1.3
	gdb-1999-12-07:1.1.1.3
	gdb-1999-12-06:1.1.1.3
	gdb-1999-11-16:1.1.1.3
	gdb-1999-11-08:1.1.1.3
	gdb-1999-11-01:1.1.1.3
	gdb-1999-10-25:1.1.1.2
	gdb-1999-10-18:1.1.1.2
	gdb-1999-10-11:1.1.1.2
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.99
date	2013.09.05.20.41.55;	author palves;	state Exp;
branches;
next	1.98;

1.98
date	2013.07.01.11.19.27;	author palves;	state Exp;
branches;
next	1.97;

1.97
date	2013.06.07.10.46.59;	author palves;	state Exp;
branches;
next	1.96;

1.96
date	2013.01.01.06.33.00;	author brobecke;	state Exp;
branches
	1.96.2.1;
next	1.95;

1.95
date	2012.11.15.16.12.19;	author muller;	state Exp;
branches;
next	1.94;

1.94
date	2012.11.09.02.58.50;	author qiyao;	state Exp;
branches;
next	1.93;

1.93
date	2012.04.29.06.28.30;	author qiyao;	state Exp;
branches;
next	1.92;

1.92
date	2012.04.19.05.05.11;	author qiyao;	state Exp;
branches;
next	1.91;

1.91
date	2012.01.04.08.17.23;	author brobecke;	state Exp;
branches;
next	1.90;

1.90
date	2011.12.16.19.06.38;	author devans;	state Exp;
branches;
next	1.89;

1.89
date	2011.12.16.18.45.48;	author devans;	state Exp;
branches;
next	1.88;

1.88
date	2011.11.09.02.32.42;	author qiyao;	state Exp;
branches
	1.88.2.1;
next	1.87;

1.87
date	2011.07.21.23.46.12;	author kcy;	state Exp;
branches;
next	1.86;

1.86
date	2011.04.24.08.02.20;	author jkratoch;	state Exp;
branches;
next	1.85;

1.85
date	2011.03.07.20.15.12;	author jkratoch;	state Exp;
branches;
next	1.84;

1.84
date	2011.01.25.10.09.19;	author palves;	state Exp;
branches;
next	1.83;

1.83
date	2011.01.06.00.14.09;	author msnyder;	state Exp;
branches;
next	1.82;

1.82
date	2011.01.01.15.33.24;	author brobecke;	state Exp;
branches;
next	1.81;

1.81
date	2010.08.27.16.02.49;	author palves;	state Exp;
branches;
next	1.80;

1.80
date	2010.08.26.16.24.41;	author palves;	state Exp;
branches;
next	1.79;

1.79
date	2010.07.01.10.36.11;	author palves;	state Exp;
branches;
next	1.78;

1.78
date	2010.06.01.13.20.52;	author palves;	state Exp;
branches;
next	1.77;

1.77
date	2010.05.26.22.40.22;	author sezero;	state Exp;
branches;
next	1.76;

1.76
date	2010.05.03.20.53.21;	author devans;	state Exp;
branches;
next	1.75;

1.75
date	2010.05.03.18.13.36;	author palves;	state Exp;
branches;
next	1.74;

1.74
date	2010.04.26.17.38.07;	author devans;	state Exp;
branches;
next	1.73;

1.73
date	2010.04.17.20.43.13;	author muller;	state Exp;
branches;
next	1.72;

1.72
date	2010.04.11.16.33.56;	author palves;	state Exp;
branches;
next	1.71;

1.71
date	2010.01.20.22.55.38;	author palves;	state Exp;
branches;
next	1.70;

1.70
date	2010.01.12.21.40.24;	author vprus;	state Exp;
branches;
next	1.69;

1.69
date	2010.01.01.07.31.49;	author brobecke;	state Exp;
branches;
next	1.68;

1.68
date	2009.07.06.18.31.20;	author aristovski;	state Exp;
branches;
next	1.67;

1.67
date	2009.05.24.21.06.53;	author devans;	state Exp;
branches;
next	1.66;

1.66
date	2009.04.03.14.38.38;	author uweigand;	state Exp;
branches;
next	1.65;

1.65
date	2009.04.01.22.50.24;	author palves;	state Exp;
branches;
next	1.64;

1.64
date	2009.04.01.22.48.05;	author palves;	state Exp;
branches;
next	1.63;

1.63
date	2009.04.01.22.31.45;	author palves;	state Exp;
branches;
next	1.62;

1.62
date	2009.03.22.23.57.10;	author palves;	state Exp;
branches;
next	1.61;

1.61
date	2009.02.14.00.07.51;	author muller;	state Exp;
branches;
next	1.60;

1.60
date	2009.01.03.05.57.57;	author brobecke;	state Exp;
branches;
next	1.59;

1.59
date	2008.12.14.20.51.04;	author devans;	state Exp;
branches;
next	1.58;

1.58
date	2008.12.02.07.57.37;	author vprus;	state Exp;
branches;
next	1.57;

1.57
date	2008.08.12.15.18.31;	author sandra;	state Exp;
branches
	1.57.4.1;
next	1.56;

1.56
date	2008.06.27.13.22.15;	author palves;	state Exp;
branches;
next	1.55;

1.55
date	2008.05.09.17.02.02;	author devans;	state Exp;
branches;
next	1.54;

1.54
date	2008.01.30.00.51.50;	author drow;	state Exp;
branches
	1.54.6.1;
next	1.53;

1.53
date	2008.01.01.22.53.14;	author drow;	state Exp;
branches;
next	1.52;

1.52
date	2007.12.07.01.41.29;	author drow;	state Exp;
branches;
next	1.51;

1.51
date	2007.12.06.14.21.26;	author drow;	state Exp;
branches;
next	1.50;

1.50
date	2007.08.23.18.08.48;	author brobecke;	state Exp;
branches;
next	1.49;

1.49
date	2007.08.01.20.34.36;	author msnyder;	state Exp;
branches;
next	1.48;

1.48
date	2007.07.18.12.36.51;	author palves;	state Exp;
branches;
next	1.47;

1.47
date	2007.07.17.12.51.41;	author drow;	state Exp;
branches;
next	1.46;

1.46
date	2007.07.03.15.58.42;	author drow;	state Exp;
branches;
next	1.45;

1.45
date	2007.06.12.14.38.32;	author uweigand;	state Exp;
branches;
next	1.44;

1.44
date	2007.05.10.22.04.50;	author palves;	state Exp;
branches;
next	1.43;

1.43
date	2007.03.29.01.06.47;	author palves;	state Exp;
branches;
next	1.42;

1.42
date	2007.03.27.22.46.08;	author palves;	state Exp;
branches;
next	1.41;

1.41
date	2007.02.27.17.21.35;	author drow;	state Exp;
branches;
next	1.40;

1.40
date	2007.02.26.20.10.18;	author drow;	state Exp;
branches;
next	1.39;

1.39
date	2007.02.25.17.59.43;	author palves;	state Exp;
branches;
next	1.38;

1.38
date	2007.02.16.20.01.14;	author drow;	state Exp;
branches;
next	1.37;

1.37
date	2007.01.29.13.22.09;	author drow;	state Exp;
branches;
next	1.36;

1.36
date	2007.01.09.17.59.08;	author drow;	state Exp;
branches;
next	1.35;

1.35
date	2006.12.30.15.44.51;	author drow;	state Exp;
branches;
next	1.34;

1.34
date	2006.11.16.15.08.25;	author drow;	state Exp;
branches;
next	1.33;

1.33
date	2006.10.17.16.02.27;	author drow;	state Exp;
branches;
next	1.32;

1.32
date	2006.09.21.16.09.54;	author drow;	state Exp;
branches;
next	1.31;

1.31
date	2006.07.23.03.52.15;	author drow;	state Exp;
branches;
next	1.30;

1.30
date	2006.06.22.15.20.47;	author drow;	state Exp;
branches;
next	1.29;

1.29
date	2006.05.30.19.05.33;	author drow;	state Exp;
branches;
next	1.28;

1.28
date	2006.03.03.14.48.55;	author drow;	state Exp;
branches
	1.28.10.1;
next	1.27;

1.27
date	2005.12.23.18.11.55;	author eliz;	state Exp;
branches
	1.27.4.1;
next	1.26;

1.26
date	2005.07.13.15.02.49;	author drow;	state Exp;
branches;
next	1.25;

1.25
date	2005.06.13.01.59.22;	author drow;	state Exp;
branches;
next	1.24;

1.24
date	2005.05.12.12.14.23;	author orjanf;	state Exp;
branches;
next	1.23;

1.23
date	2005.03.03.16.56.53;	author drow;	state Exp;
branches;
next	1.22;

1.22
date	2004.10.16.17.42.00;	author drow;	state Exp;
branches;
next	1.21;

1.21
date	2004.02.29.16.48.29;	author drow;	state Exp;
branches;
next	1.20;

1.20
date	2004.02.29.16.47.15;	author drow;	state Exp;
branches;
next	1.19;

1.19
date	2004.02.29.16.46.01;	author drow;	state Exp;
branches;
next	1.18;

1.18
date	2004.02.26.15.08.47;	author drow;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.05.14.26.58;	author drow;	state Exp;
branches
	1.17.10.1
	1.17.18.1;
next	1.16;

1.16
date	2002.08.29.18.50.25;	author drow;	state Exp;
branches
	1.16.4.1
	1.16.6.1;
next	1.15;

1.15
date	2002.06.11.17.32.40;	author drow;	state Exp;
branches;
next	1.14;

1.14
date	2002.04.09.23.52.06;	author drow;	state Exp;
branches
	1.14.4.1
	1.14.6.1;
next	1.13;

1.13
date	2002.04.09.21.16.16;	author drow;	state Exp;
branches;
next	1.12;

1.12
date	2002.04.09.21.11.35;	author drow;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.27.05.15.49;	author drow;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.21.02.11.03;	author hunt;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.13.20.42.16;	author mludvig;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.14.06.21.22;	author drow;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2001.07.12.21.04.35;	author drow;	state Exp;
branches
	1.7.4.1;
next	1.6;

1.6
date	2001.07.11.19.11.07;	author drow;	state Exp;
branches;
next	1.5;

1.5
date	2001.07.11.17.33.24;	author jtc;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.06.08.21.44;	author kevinb;	state Exp;
branches;
next	1.3;

1.3
date	2000.07.30.01.48.28;	author kevinb;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.02.09.36.57;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.26;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.96.2.1
date	2013.08.29.14.24.15;	author jkratoch;	state Exp;
branches;
next	;

1.88.2.1
date	2012.01.06.04.43.37;	author brobecke;	state Exp;
branches;
next	;

1.57.4.1
date	2008.11.25.20.47.19;	author palves;	state Exp;
branches;
next	;

1.54.6.1
date	2009.03.09.20.36.09;	author amylaar;	state Exp;
branches;
next	1.54.6.2;

1.54.6.2
date	2009.09.11.04.45.50;	author amylaar;	state Exp;
branches;
next	;

1.28.10.1
date	2006.08.28.07.48.46;	author nickrob;	state Exp;
branches;
next	;

1.27.4.1
date	2006.04.12.18.11.42;	author drow;	state Exp;
branches;
next	1.27.4.2;

1.27.4.2
date	2006.05.23.21.44.20;	author drow;	state Exp;
branches;
next	;

1.17.10.1
date	2004.03.23.20.28.36;	author ezannoni;	state Exp;
branches;
next	;

1.17.18.1
date	2004.03.27.17.38.01;	author drow;	state Exp;
branches;
next	;

1.16.4.1
date	2003.06.27.21.50.18;	author carlton;	state Exp;
branches;
next	;

1.16.6.1
date	2003.12.14.20.27.44;	author drow;	state Exp;
branches;
next	;

1.14.4.1
date	2002.06.15.16.43.13;	author cagney;	state Exp;
branches;
next	;

1.14.6.1
date	2002.06.20.01.36.23;	author kseitz;	state Exp;
branches;
next	1.14.6.2;

1.14.6.2
date	2002.08.30.22.52.50;	author kseitz;	state Exp;
branches;
next	;

1.8.2.1
date	2002.03.29.19.03.34;	author drow;	state Exp;
branches;
next	;

1.7.4.1
date	2001.09.27.00.13.30;	author cagney;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.26;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.07.07.20.17.51;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.11.02.04.44.24;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.99
log
@[gdbserver] Split a new dll.h file out of server.h.

gdb/gdbserver/
2013-09-05  Pedro Alves  <palves@@redhat.com>

	* dll.c, inferiors.c, remote-utils.c, server.c: Include "dll.h".
	* server.h (struct dll_info, all_dlls, dlls_changed, clear_dlls)
	(loaded_dll, unloaded_dll): Move to ...
	* dll.h: ... this new file.
	* inferiors.c, remote-utils.c, win32-low.c: Include "dll.h".
@
text
@/* Remote utility routines for the remote server for GDB.
   Copyright (C) 1986-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "server.h"
#include "terminal.h"
#include "target.h"
#include "gdbthread.h"
#include "tdesc.h"
#include "dll.h"

#include <stdio.h>
#include <string.h>
#if HAVE_SYS_IOCTL_H
#include <sys/ioctl.h>
#endif
#if HAVE_SYS_FILE_H
#include <sys/file.h>
#endif
#if HAVE_NETINET_IN_H
#include <netinet/in.h>
#endif
#if HAVE_SYS_SOCKET_H
#include <sys/socket.h>
#endif
#if HAVE_NETDB_H
#include <netdb.h>
#endif
#if HAVE_NETINET_TCP_H
#include <netinet/tcp.h>
#endif
#if HAVE_SYS_IOCTL_H
#include <sys/ioctl.h>
#endif
#if HAVE_SIGNAL_H
#include <signal.h>
#endif
#if HAVE_FCNTL_H
#include <fcntl.h>
#endif
#include <sys/time.h>
#include <unistd.h>
#if HAVE_ARPA_INET_H
#include <arpa/inet.h>
#endif
#include "gdb_stat.h"
#if HAVE_ERRNO_H
#include <errno.h>
#endif

#if USE_WIN32API
#include <winsock2.h>
#endif

#if __QNX__
#include <sys/iomgr.h>
#endif /* __QNX__ */

#ifndef HAVE_SOCKLEN_T
typedef int socklen_t;
#endif

#ifndef IN_PROCESS_AGENT

#if USE_WIN32API
# define INVALID_DESCRIPTOR INVALID_SOCKET
#else
# define INVALID_DESCRIPTOR -1
#endif

/* Extra value for readchar_callback.  */
enum {
  /* The callback is currently not scheduled.  */
  NOT_SCHEDULED = -1
};

/* Status of the readchar callback.
   Either NOT_SCHEDULED or the callback id.  */
static int readchar_callback = NOT_SCHEDULED;

static int readchar (void);
static void reset_readchar (void);
static void reschedule (void);

/* A cache entry for a successfully looked-up symbol.  */
struct sym_cache
{
  char *name;
  CORE_ADDR addr;
  struct sym_cache *next;
};

int remote_debug = 0;
struct ui_file *gdb_stdlog;

static int remote_is_stdio = 0;

static gdb_fildes_t remote_desc = INVALID_DESCRIPTOR;
static gdb_fildes_t listen_desc = INVALID_DESCRIPTOR;

/* FIXME headerize? */
extern int using_threads;
extern int debug_threads;

/* If true, then GDB has requested noack mode.  */
int noack_mode = 0;
/* If true, then we tell GDB to use noack mode by default.  */
int transport_is_reliable = 0;

#ifdef USE_WIN32API
# define read(fd, buf, len) recv (fd, (char *) buf, len, 0)
# define write(fd, buf, len) send (fd, (char *) buf, len, 0)
#endif

int
gdb_connected (void)
{
  return remote_desc != INVALID_DESCRIPTOR;
}

/* Return true if the remote connection is over stdio.  */

int
remote_connection_is_stdio (void)
{
  return remote_is_stdio;
}

static void
enable_async_notification (int fd)
{
#if defined(F_SETFL) && defined (FASYNC)
  int save_fcntl_flags;

  save_fcntl_flags = fcntl (fd, F_GETFL, 0);
  fcntl (fd, F_SETFL, save_fcntl_flags | FASYNC);
#if defined (F_SETOWN)
  fcntl (fd, F_SETOWN, getpid ());
#endif
#endif
}

static int
handle_accept_event (int err, gdb_client_data client_data)
{
  struct sockaddr_in sockaddr;
  socklen_t tmp;

  if (debug_threads)
    fprintf (stderr, "handling possible accept event\n");

  tmp = sizeof (sockaddr);
  remote_desc = accept (listen_desc, (struct sockaddr *) &sockaddr, &tmp);
  if (remote_desc == -1)
    perror_with_name ("Accept failed");

  /* Enable TCP keep alive process. */
  tmp = 1;
  setsockopt (remote_desc, SOL_SOCKET, SO_KEEPALIVE,
	      (char *) &tmp, sizeof (tmp));

  /* Tell TCP not to delay small packets.  This greatly speeds up
     interactive response. */
  tmp = 1;
  setsockopt (remote_desc, IPPROTO_TCP, TCP_NODELAY,
	      (char *) &tmp, sizeof (tmp));

#ifndef USE_WIN32API
  signal (SIGPIPE, SIG_IGN);	/* If we don't do this, then gdbserver simply
				   exits when the remote side dies.  */
#endif

  if (run_once)
    {
#ifndef USE_WIN32API
      close (listen_desc);		/* No longer need this */
#else
      closesocket (listen_desc);	/* No longer need this */
#endif
    }

  /* Even if !RUN_ONCE no longer notice new connections.  Still keep the
     descriptor open for add_file_handler to wait for a new connection.  */
  delete_file_handler (listen_desc);

  /* Convert IP address to string.  */
  fprintf (stderr, "Remote debugging from host %s\n",
	   inet_ntoa (sockaddr.sin_addr));

  enable_async_notification (remote_desc);

  /* Register the event loop handler.  */
  add_file_handler (remote_desc, handle_serial_event, NULL);

  /* We have a new GDB connection now.  If we were disconnected
     tracing, there's a window where the target could report a stop
     event to the event loop, and since we have a connection now, we'd
     try to send vStopped notifications to GDB.  But, don't do that
     until GDB as selected all-stop/non-stop, and has queried the
     threads' status ('?').  */
  target_async (0);

  return 0;
}

/* Prepare for a later connection to a remote debugger.
   NAME is the filename used for communication.  */

void
remote_prepare (char *name)
{
  char *port_str;
#ifdef USE_WIN32API
  static int winsock_initialized;
#endif
  int port;
  struct sockaddr_in sockaddr;
  socklen_t tmp;
  char *port_end;

  remote_is_stdio = 0;
  if (strcmp (name, STDIO_CONNECTION_NAME) == 0)
    {
      /* We need to record fact that we're using stdio sooner than the
	 call to remote_open so start_inferior knows the connection is
	 via stdio.  */
      remote_is_stdio = 1;
      transport_is_reliable = 1;
      return;
    }

  port_str = strchr (name, ':');
  if (port_str == NULL)
    {
      transport_is_reliable = 0;
      return;
    }

  port = strtoul (port_str + 1, &port_end, 10);
  if (port_str[1] == '\0' || *port_end != '\0')
    fatal ("Bad port argument: %s", name);

#ifdef USE_WIN32API
  if (!winsock_initialized)
    {
      WSADATA wsad;

      WSAStartup (MAKEWORD (1, 0), &wsad);
      winsock_initialized = 1;
    }
#endif

  listen_desc = socket (PF_INET, SOCK_STREAM, IPPROTO_TCP);
  if (listen_desc == -1)
    perror_with_name ("Can't open socket");

  /* Allow rapid reuse of this port. */
  tmp = 1;
  setsockopt (listen_desc, SOL_SOCKET, SO_REUSEADDR, (char *) &tmp,
	      sizeof (tmp));

  sockaddr.sin_family = PF_INET;
  sockaddr.sin_port = htons (port);
  sockaddr.sin_addr.s_addr = INADDR_ANY;

  if (bind (listen_desc, (struct sockaddr *) &sockaddr, sizeof (sockaddr))
      || listen (listen_desc, 1))
    perror_with_name ("Can't bind address");

  transport_is_reliable = 1;
}

/* Open a connection to a remote debugger.
   NAME is the filename used for communication.  */

void
remote_open (char *name)
{
  char *port_str;

  port_str = strchr (name, ':');
#ifdef USE_WIN32API
  if (port_str == NULL)
    error ("Only <host>:<port> is supported on this platform.");
#endif

  if (strcmp (name, STDIO_CONNECTION_NAME) == 0)
    {
      fprintf (stderr, "Remote debugging using stdio\n");

      /* Use stdin as the handle of the connection.
	 We only select on reads, for example.  */
      remote_desc = fileno (stdin);

      enable_async_notification (remote_desc);

      /* Register the event loop handler.  */
      add_file_handler (remote_desc, handle_serial_event, NULL);
    }
#ifndef USE_WIN32API
  else if (port_str == NULL)
    {
      struct stat statbuf;

      if (stat (name, &statbuf) == 0
	  && (S_ISCHR (statbuf.st_mode) || S_ISFIFO (statbuf.st_mode)))
	remote_desc = open (name, O_RDWR);
      else
	{
	  errno = EINVAL;
	  remote_desc = -1;
	}

      if (remote_desc < 0)
	perror_with_name ("Could not open remote device");

#ifdef HAVE_TERMIOS
      {
	struct termios termios;
	tcgetattr (remote_desc, &termios);

	termios.c_iflag = 0;
	termios.c_oflag = 0;
	termios.c_lflag = 0;
	termios.c_cflag &= ~(CSIZE | PARENB);
	termios.c_cflag |= CLOCAL | CS8;
	termios.c_cc[VMIN] = 1;
	termios.c_cc[VTIME] = 0;

	tcsetattr (remote_desc, TCSANOW, &termios);
      }
#endif

#ifdef HAVE_TERMIO
      {
	struct termio termio;
	ioctl (remote_desc, TCGETA, &termio);

	termio.c_iflag = 0;
	termio.c_oflag = 0;
	termio.c_lflag = 0;
	termio.c_cflag &= ~(CSIZE | PARENB);
	termio.c_cflag |= CLOCAL | CS8;
	termio.c_cc[VMIN] = 1;
	termio.c_cc[VTIME] = 0;

	ioctl (remote_desc, TCSETA, &termio);
      }
#endif

#ifdef HAVE_SGTTY
      {
	struct sgttyb sg;

	ioctl (remote_desc, TIOCGETP, &sg);
	sg.sg_flags = RAW;
	ioctl (remote_desc, TIOCSETP, &sg);
      }
#endif

      fprintf (stderr, "Remote debugging using %s\n", name);

      enable_async_notification (remote_desc);

      /* Register the event loop handler.  */
      add_file_handler (remote_desc, handle_serial_event, NULL);
    }
#endif /* USE_WIN32API */
  else
    {
      int port;
      socklen_t len;
      struct sockaddr_in sockaddr;

      len = sizeof (sockaddr);
      if (getsockname (listen_desc,
		       (struct sockaddr *) &sockaddr, &len) < 0
	  || len < sizeof (sockaddr))
	perror_with_name ("Can't determine port");
      port = ntohs (sockaddr.sin_port);

      fprintf (stderr, "Listening on port %d\n", port);
      fflush (stderr);

      /* Register the event loop handler.  */
      add_file_handler (listen_desc, handle_accept_event, NULL);
    }
}

void
remote_close (void)
{
  delete_file_handler (remote_desc);

#ifdef USE_WIN32API
  closesocket (remote_desc);
#else
  if (! remote_connection_is_stdio ())
    close (remote_desc);
#endif
  remote_desc = INVALID_DESCRIPTOR;

  reset_readchar ();
}

/* Convert hex digit A to a number.  */

static int
fromhex (int a)
{
  if (a >= '0' && a <= '9')
    return a - '0';
  else if (a >= 'a' && a <= 'f')
    return a - 'a' + 10;
  else
    error ("Reply contains invalid hex digit");
  return 0;
}

#endif

static const char hexchars[] = "0123456789abcdef";

static int
ishex (int ch, int *val)
{
  if ((ch >= 'a') && (ch <= 'f'))
    {
      *val = ch - 'a' + 10;
      return 1;
    }
  if ((ch >= 'A') && (ch <= 'F'))
    {
      *val = ch - 'A' + 10;
      return 1;
    }
  if ((ch >= '0') && (ch <= '9'))
    {
      *val = ch - '0';
      return 1;
    }
  return 0;
}

#ifndef IN_PROCESS_AGENT

int
unhexify (char *bin, const char *hex, int count)
{
  int i;

  for (i = 0; i < count; i++)
    {
      if (hex[0] == 0 || hex[1] == 0)
	{
	  /* Hex string is short, or of uneven length.
	     Return the count that has been converted so far. */
	  return i;
	}
      *bin++ = fromhex (hex[0]) * 16 + fromhex (hex[1]);
      hex += 2;
    }
  return i;
}

void
decode_address (CORE_ADDR *addrp, const char *start, int len)
{
  CORE_ADDR addr;
  char ch;
  int i;

  addr = 0;
  for (i = 0; i < len; i++)
    {
      ch = start[i];
      addr = addr << 4;
      addr = addr | (fromhex (ch) & 0x0f);
    }
  *addrp = addr;
}

const char *
decode_address_to_semicolon (CORE_ADDR *addrp, const char *start)
{
  const char *end;

  end = start;
  while (*end != '\0' && *end != ';')
    end++;

  decode_address (addrp, start, end - start);

  if (*end == ';')
    end++;
  return end;
}

#endif

/* Convert number NIB to a hex digit.  */

static int
tohex (int nib)
{
  if (nib < 10)
    return '0' + nib;
  else
    return 'a' + nib - 10;
}

#ifndef IN_PROCESS_AGENT

int
hexify (char *hex, const char *bin, int count)
{
  int i;

  /* May use a length, or a nul-terminated string as input. */
  if (count == 0)
    count = strlen (bin);

  for (i = 0; i < count; i++)
    {
      *hex++ = tohex ((*bin >> 4) & 0xf);
      *hex++ = tohex (*bin++ & 0xf);
    }
  *hex = 0;
  return i;
}

/* Convert BUFFER, binary data at least LEN bytes long, into escaped
   binary data in OUT_BUF.  Set *OUT_LEN to the length of the data
   encoded in OUT_BUF, and return the number of bytes in OUT_BUF
   (which may be more than *OUT_LEN due to escape characters).  The
   total number of bytes in the output buffer will be at most
   OUT_MAXLEN.  */

int
remote_escape_output (const gdb_byte *buffer, int len,
		      gdb_byte *out_buf, int *out_len,
		      int out_maxlen)
{
  int input_index, output_index;

  output_index = 0;
  for (input_index = 0; input_index < len; input_index++)
    {
      gdb_byte b = buffer[input_index];

      if (b == '$' || b == '#' || b == '}' || b == '*')
	{
	  /* These must be escaped.  */
	  if (output_index + 2 > out_maxlen)
	    break;
	  out_buf[output_index++] = '}';
	  out_buf[output_index++] = b ^ 0x20;
	}
      else
	{
	  if (output_index + 1 > out_maxlen)
	    break;
	  out_buf[output_index++] = b;
	}
    }

  *out_len = input_index;
  return output_index;
}

/* Convert BUFFER, escaped data LEN bytes long, into binary data
   in OUT_BUF.  Return the number of bytes written to OUT_BUF.
   Raise an error if the total number of bytes exceeds OUT_MAXLEN.

   This function reverses remote_escape_output.  It allows more
   escaped characters than that function does, in particular because
   '*' must be escaped to avoid the run-length encoding processing
   in reading packets.  */

static int
remote_unescape_input (const gdb_byte *buffer, int len,
		       gdb_byte *out_buf, int out_maxlen)
{
  int input_index, output_index;
  int escaped;

  output_index = 0;
  escaped = 0;
  for (input_index = 0; input_index < len; input_index++)
    {
      gdb_byte b = buffer[input_index];

      if (output_index + 1 > out_maxlen)
	error ("Received too much data from the target.");

      if (escaped)
	{
	  out_buf[output_index++] = b ^ 0x20;
	  escaped = 0;
	}
      else if (b == '}')
	escaped = 1;
      else
	out_buf[output_index++] = b;
    }

  if (escaped)
    error ("Unmatched escape character in target response.");

  return output_index;
}

/* Look for a sequence of characters which can be run-length encoded.
   If there are any, update *CSUM and *P.  Otherwise, output the
   single character.  Return the number of characters consumed.  */

static int
try_rle (char *buf, int remaining, unsigned char *csum, char **p)
{
  int n;

  /* Always output the character.  */
  *csum += buf[0];
  *(*p)++ = buf[0];

  /* Don't go past '~'.  */
  if (remaining > 97)
    remaining = 97;

  for (n = 1; n < remaining; n++)
    if (buf[n] != buf[0])
      break;

  /* N is the index of the first character not the same as buf[0].
     buf[0] is counted twice, so by decrementing N, we get the number
     of characters the RLE sequence will replace.  */
  n--;

  if (n < 3)
    return 1;

  /* Skip the frame characters.  The manual says to skip '+' and '-'
     also, but there's no reason to.  Unfortunately these two unusable
     characters double the encoded length of a four byte zero
     value.  */
  while (n + 29 == '$' || n + 29 == '#')
    n--;

  *csum += '*';
  *(*p)++ = '*';
  *csum += n + 29;
  *(*p)++ = n + 29;

  return n + 1;
}

#endif

char *
unpack_varlen_hex (char *buff,	/* packet to parse */
		   ULONGEST *result)
{
  int nibble;
  ULONGEST retval = 0;

  while (ishex (*buff, &nibble))
    {
      buff++;
      retval = retval << 4;
      retval |= nibble & 0x0f;
    }
  *result = retval;
  return buff;
}

#ifndef IN_PROCESS_AGENT

/* Write a PTID to BUF.  Returns BUF+CHARACTERS_WRITTEN.  */

char *
write_ptid (char *buf, ptid_t ptid)
{
  int pid, tid;

  if (multi_process)
    {
      pid = ptid_get_pid (ptid);
      if (pid < 0)
	buf += sprintf (buf, "p-%x.", -pid);
      else
	buf += sprintf (buf, "p%x.", pid);
    }
  tid = ptid_get_lwp (ptid);
  if (tid < 0)
    buf += sprintf (buf, "-%x", -tid);
  else
    buf += sprintf (buf, "%x", tid);

  return buf;
}

ULONGEST
hex_or_minus_one (char *buf, char **obuf)
{
  ULONGEST ret;

  if (strncmp (buf, "-1", 2) == 0)
    {
      ret = (ULONGEST) -1;
      buf += 2;
    }
  else
    buf = unpack_varlen_hex (buf, &ret);

  if (obuf)
    *obuf = buf;

  return ret;
}

/* Extract a PTID from BUF.  If non-null, OBUF is set to the to one
   passed the last parsed char.  Returns null_ptid on error.  */
ptid_t
read_ptid (char *buf, char **obuf)
{
  char *p = buf;
  char *pp;
  ULONGEST pid = 0, tid = 0;

  if (*p == 'p')
    {
      /* Multi-process ptid.  */
      pp = unpack_varlen_hex (p + 1, &pid);
      if (*pp != '.')
	error ("invalid remote ptid: %s\n", p);

      p = pp + 1;

      tid = hex_or_minus_one (p, &pp);

      if (obuf)
	*obuf = pp;
      return ptid_build (pid, tid, 0);
    }

  /* No multi-process.  Just a tid.  */
  tid = hex_or_minus_one (p, &pp);

  /* Since the stub is not sending a process id, then default to
     what's in the current inferior.  */
  pid = ptid_get_pid (current_ptid);

  if (obuf)
    *obuf = pp;
  return ptid_build (pid, tid, 0);
}

/* Write COUNT bytes in BUF to the client.
   The result is the number of bytes written or -1 if error.
   This may return less than COUNT.  */

static int
write_prim (const void *buf, int count)
{
  if (remote_connection_is_stdio ())
    return write (fileno (stdout), buf, count);
  else
    return write (remote_desc, buf, count);
}

/* Read COUNT bytes from the client and store in BUF.
   The result is the number of bytes read or -1 if error.
   This may return less than COUNT.  */

static int
read_prim (void *buf, int count)
{
  if (remote_connection_is_stdio ())
    return read (fileno (stdin), buf, count);
  else
    return read (remote_desc, buf, count);
}

/* Send a packet to the remote machine, with error checking.
   The data of the packet is in BUF, and the length of the
   packet is in CNT.  Returns >= 0 on success, -1 otherwise.  */

static int
putpkt_binary_1 (char *buf, int cnt, int is_notif)
{
  int i;
  unsigned char csum = 0;
  char *buf2;
  char *p;
  int cc;

  buf2 = xmalloc (strlen ("$") + cnt + strlen ("#nn") + 1);

  /* Copy the packet into buffer BUF2, encapsulating it
     and giving it a checksum.  */

  p = buf2;
  if (is_notif)
    *p++ = '%';
  else
    *p++ = '$';

  for (i = 0; i < cnt;)
    i += try_rle (buf + i, cnt - i, &csum, &p);

  *p++ = '#';
  *p++ = tohex ((csum >> 4) & 0xf);
  *p++ = tohex (csum & 0xf);

  *p = '\0';

  /* Send it over and over until we get a positive ack.  */

  do
    {
      if (write_prim (buf2, p - buf2) != p - buf2)
	{
	  perror ("putpkt(write)");
	  free (buf2);
	  return -1;
	}

      if (noack_mode || is_notif)
	{
	  /* Don't expect an ack then.  */
	  if (remote_debug)
	    {
	      if (is_notif)
		fprintf (stderr, "putpkt (\"%s\"); [notif]\n", buf2);
	      else
		fprintf (stderr, "putpkt (\"%s\"); [noack mode]\n", buf2);
	      fflush (stderr);
	    }
	  break;
	}

      if (remote_debug)
	{
	  fprintf (stderr, "putpkt (\"%s\"); [looking for ack]\n", buf2);
	  fflush (stderr);
	}

      cc = readchar ();

      if (cc < 0)
	{
	  free (buf2);
	  return -1;
	}

      if (remote_debug)
	{
	  fprintf (stderr, "[received '%c' (0x%x)]\n", cc, cc);
	  fflush (stderr);
	}

      /* Check for an input interrupt while we're here.  */
      if (cc == '\003' && current_inferior != NULL)
	(*the_target->request_interrupt) ();
    }
  while (cc != '+');

  free (buf2);
  return 1;			/* Success! */
}

int
putpkt_binary (char *buf, int cnt)
{
  return putpkt_binary_1 (buf, cnt, 0);
}

/* Send a packet to the remote machine, with error checking.  The data
   of the packet is in BUF, and the packet should be a NUL-terminated
   string.  Returns >= 0 on success, -1 otherwise.  */

int
putpkt (char *buf)
{
  return putpkt_binary (buf, strlen (buf));
}

int
putpkt_notif (char *buf)
{
  return putpkt_binary_1 (buf, strlen (buf), 1);
}

/* Come here when we get an input interrupt from the remote side.  This
   interrupt should only be active while we are waiting for the child to do
   something.  Thus this assumes readchar:bufcnt is 0.
   About the only thing that should come through is a ^C, which
   will cause us to request child interruption.  */

static void
input_interrupt (int unused)
{
  fd_set readset;
  struct timeval immediate = { 0, 0 };

  /* Protect against spurious interrupts.  This has been observed to
     be a problem under NetBSD 1.4 and 1.5.  */

  FD_ZERO (&readset);
  FD_SET (remote_desc, &readset);
  if (select (remote_desc + 1, &readset, 0, 0, &immediate) > 0)
    {
      int cc;
      char c = 0;

      cc = read_prim (&c, 1);

      if (cc != 1 || c != '\003' || current_inferior == NULL)
	{
	  fprintf (stderr, "input_interrupt, count = %d c = %d ('%c')\n",
		   cc, c, c);
	  return;
	}

      (*the_target->request_interrupt) ();
    }
}

/* Check if the remote side sent us an interrupt request (^C).  */
void
check_remote_input_interrupt_request (void)
{
  /* This function may be called before establishing communications,
     therefore we need to validate the remote descriptor.  */

  if (remote_desc == INVALID_DESCRIPTOR)
    return;

  input_interrupt (0);
}

/* Asynchronous I/O support.  SIGIO must be enabled when waiting, in order to
   accept Control-C from the client, and must be disabled when talking to
   the client.  */

static void
unblock_async_io (void)
{
#ifndef USE_WIN32API
  sigset_t sigio_set;

  sigemptyset (&sigio_set);
  sigaddset (&sigio_set, SIGIO);
  sigprocmask (SIG_UNBLOCK, &sigio_set, NULL);
#endif
}

#ifdef __QNX__
static void
nto_comctrl (int enable)
{
  struct sigevent event;

  if (enable)
    {
      event.sigev_notify = SIGEV_SIGNAL_THREAD;
      event.sigev_signo = SIGIO;
      event.sigev_code = 0;
      event.sigev_value.sival_ptr = NULL;
      event.sigev_priority = -1;
      ionotify (remote_desc, _NOTIFY_ACTION_POLLARM, _NOTIFY_COND_INPUT,
		&event);
    }
  else
    ionotify (remote_desc, _NOTIFY_ACTION_POLL, _NOTIFY_COND_INPUT, NULL);
}
#endif /* __QNX__ */


/* Current state of asynchronous I/O.  */
static int async_io_enabled;

/* Enable asynchronous I/O.  */
void
enable_async_io (void)
{
  if (async_io_enabled)
    return;

#ifndef USE_WIN32API
  signal (SIGIO, input_interrupt);
#endif
  async_io_enabled = 1;
#ifdef __QNX__
  nto_comctrl (1);
#endif /* __QNX__ */
}

/* Disable asynchronous I/O.  */
void
disable_async_io (void)
{
  if (!async_io_enabled)
    return;

#ifndef USE_WIN32API
  signal (SIGIO, SIG_IGN);
#endif
  async_io_enabled = 0;
#ifdef __QNX__
  nto_comctrl (0);
#endif /* __QNX__ */

}

void
initialize_async_io (void)
{
  /* Make sure that async I/O starts disabled.  */
  async_io_enabled = 1;
  disable_async_io ();

  /* Make sure the signal is unblocked.  */
  unblock_async_io ();
}

/* Internal buffer used by readchar.
   These are global to readchar because reschedule_remote needs to be
   able to tell whether the buffer is empty.  */

static unsigned char readchar_buf[BUFSIZ];
static int readchar_bufcnt = 0;
static unsigned char *readchar_bufp;

/* Returns next char from remote GDB.  -1 if error.  */

static int
readchar (void)
{
  int ch;

  if (readchar_bufcnt == 0)
    {
      readchar_bufcnt = read_prim (readchar_buf, sizeof (readchar_buf));

      if (readchar_bufcnt <= 0)
	{
	  if (readchar_bufcnt == 0)
	    fprintf (stderr, "readchar: Got EOF\n");
	  else
	    perror ("readchar");

	  return -1;
	}

      readchar_bufp = readchar_buf;
    }

  readchar_bufcnt--;
  ch = *readchar_bufp++;
  reschedule ();
  return ch;
}

/* Reset the readchar state machine.  */

static void
reset_readchar (void)
{
  readchar_bufcnt = 0;
  if (readchar_callback != NOT_SCHEDULED)
    {
      delete_callback_event (readchar_callback);
      readchar_callback = NOT_SCHEDULED;
    }
}

/* Process remaining data in readchar_buf.  */

static int
process_remaining (void *context)
{
  int res;

  /* This is a one-shot event.  */
  readchar_callback = NOT_SCHEDULED;

  if (readchar_bufcnt > 0)
    res = handle_serial_event (0, NULL);
  else
    res = 0;

  return res;
}

/* If there is still data in the buffer, queue another event to process it,
   we can't sleep in select yet.  */

static void
reschedule (void)
{
  if (readchar_bufcnt > 0 && readchar_callback == NOT_SCHEDULED)
    readchar_callback = append_callback_event (process_remaining, NULL);
}

/* Read a packet from the remote machine, with error checking,
   and store it in BUF.  Returns length of packet, or negative if error. */

int
getpkt (char *buf)
{
  char *bp;
  unsigned char csum, c1, c2;
  int c;

  while (1)
    {
      csum = 0;

      while (1)
	{
	  c = readchar ();
	  if (c == '$')
	    break;
	  if (remote_debug)
	    {
	      fprintf (stderr, "[getpkt: discarding char '%c']\n", c);
	      fflush (stderr);
	    }

	  if (c < 0)
	    return -1;
	}

      bp = buf;
      while (1)
	{
	  c = readchar ();
	  if (c < 0)
	    return -1;
	  if (c == '#')
	    break;
	  *bp++ = c;
	  csum += c;
	}
      *bp = 0;

      c1 = fromhex (readchar ());
      c2 = fromhex (readchar ());

      if (csum == (c1 << 4) + c2)
	break;

      if (noack_mode)
	{
	  fprintf (stderr,
		   "Bad checksum, sentsum=0x%x, csum=0x%x, "
		   "buf=%s [no-ack-mode, Bad medium?]\n",
		   (c1 << 4) + c2, csum, buf);
	  /* Not much we can do, GDB wasn't expecting an ack/nac.  */
	  break;
	}

      fprintf (stderr, "Bad checksum, sentsum=0x%x, csum=0x%x, buf=%s\n",
	       (c1 << 4) + c2, csum, buf);
      if (write_prim ("-", 1) != 1)
	return -1;
    }

  if (!noack_mode)
    {
      if (remote_debug)
	{
	  fprintf (stderr, "getpkt (\"%s\");  [sending ack] \n", buf);
	  fflush (stderr);
	}

      if (write_prim ("+", 1) != 1)
	return -1;

      if (remote_debug)
	{
	  fprintf (stderr, "[sent ack]\n");
	  fflush (stderr);
	}
    }
  else
    {
      if (remote_debug)
	{
	  fprintf (stderr, "getpkt (\"%s\");  [no ack sent] \n", buf);
	  fflush (stderr);
	}
    }

  return bp - buf;
}

void
write_ok (char *buf)
{
  buf[0] = 'O';
  buf[1] = 'K';
  buf[2] = '\0';
}

void
write_enn (char *buf)
{
  /* Some day, we should define the meanings of the error codes... */
  buf[0] = 'E';
  buf[1] = '0';
  buf[2] = '1';
  buf[3] = '\0';
}

#endif

void
convert_int_to_ascii (const unsigned char *from, char *to, int n)
{
  int nib;
  int ch;
  while (n--)
    {
      ch = *from++;
      nib = ((ch & 0xf0) >> 4) & 0x0f;
      *to++ = tohex (nib);
      nib = ch & 0x0f;
      *to++ = tohex (nib);
    }
  *to++ = 0;
}

#ifndef IN_PROCESS_AGENT

void
convert_ascii_to_int (const char *from, unsigned char *to, int n)
{
  int nib1, nib2;
  while (n--)
    {
      nib1 = fromhex (*from++);
      nib2 = fromhex (*from++);
      *to++ = (((nib1 & 0x0f) << 4) & 0xf0) | (nib2 & 0x0f);
    }
}

static char *
outreg (struct regcache *regcache, int regno, char *buf)
{
  if ((regno >> 12) != 0)
    *buf++ = tohex ((regno >> 12) & 0xf);
  if ((regno >> 8) != 0)
    *buf++ = tohex ((regno >> 8) & 0xf);
  *buf++ = tohex ((regno >> 4) & 0xf);
  *buf++ = tohex (regno & 0xf);
  *buf++ = ':';
  collect_register_as_string (regcache, regno, buf);
  buf += 2 * register_size (regcache->tdesc, regno);
  *buf++ = ';';

  return buf;
}

void
new_thread_notify (int id)
{
  char own_buf[256];

  /* The `n' response is not yet part of the remote protocol.  Do nothing.  */
  if (1)
    return;

  if (server_waiting == 0)
    return;

  sprintf (own_buf, "n%x", id);
  disable_async_io ();
  putpkt (own_buf);
  enable_async_io ();
}

void
dead_thread_notify (int id)
{
  char own_buf[256];

  /* The `x' response is not yet part of the remote protocol.  Do nothing.  */
  if (1)
    return;

  sprintf (own_buf, "x%x", id);
  disable_async_io ();
  putpkt (own_buf);
  enable_async_io ();
}

void
prepare_resume_reply (char *buf, ptid_t ptid,
		      struct target_waitstatus *status)
{
  if (debug_threads)
    fprintf (stderr, "Writing resume reply for %s:%d\n",
	     target_pid_to_str (ptid), status->kind);

  switch (status->kind)
    {
    case TARGET_WAITKIND_STOPPED:
      {
	struct thread_info *saved_inferior;
	const char **regp;
	struct regcache *regcache;

	sprintf (buf, "T%02x", status->value.sig);
	buf += strlen (buf);

	saved_inferior = current_inferior;

	current_inferior = find_thread_ptid (ptid);

	regp = current_target_desc ()->expedite_regs;

	regcache = get_thread_regcache (current_inferior, 1);

	if (the_target->stopped_by_watchpoint != NULL
	    && (*the_target->stopped_by_watchpoint) ())
	  {
	    CORE_ADDR addr;
	    int i;

	    strncpy (buf, "watch:", 6);
	    buf += 6;

	    addr = (*the_target->stopped_data_address) ();

	    /* Convert each byte of the address into two hexadecimal
	       chars.  Note that we take sizeof (void *) instead of
	       sizeof (addr); this is to avoid sending a 64-bit
	       address to a 32-bit GDB.  */
	    for (i = sizeof (void *) * 2; i > 0; i--)
	      *buf++ = tohex ((addr >> (i - 1) * 4) & 0xf);
	    *buf++ = ';';
	  }

	while (*regp)
	  {
	    buf = outreg (regcache, find_regno (regcache->tdesc, *regp), buf);
	    regp ++;
	  }
	*buf = '\0';

	/* Formerly, if the debugger had not used any thread features
	   we would not burden it with a thread status response.  This
	   was for the benefit of GDB 4.13 and older.  However, in
	   recent GDB versions the check (``if (cont_thread != 0)'')
	   does not have the desired effect because of sillyness in
	   the way that the remote protocol handles specifying a
	   thread.  Since thread support relies on qSymbol support
	   anyway, assume GDB can handle threads.  */

	if (using_threads && !disable_packet_Tthread)
	  {
	    /* This if (1) ought to be unnecessary.  But remote_wait
	       in GDB will claim this event belongs to inferior_ptid
	       if we do not specify a thread, and there's no way for
	       gdbserver to know what inferior_ptid is.  */
	    if (1 || !ptid_equal (general_thread, ptid))
	      {
		int core = -1;
		/* In non-stop, don't change the general thread behind
		   GDB's back.  */
		if (!non_stop)
		  general_thread = ptid;
		sprintf (buf, "thread:");
		buf += strlen (buf);
		buf = write_ptid (buf, ptid);
		strcat (buf, ";");
		buf += strlen (buf);

		core = target_core_of_thread (ptid);

		if (core != -1)
		  {
		    sprintf (buf, "core:");
		    buf += strlen (buf);
		    sprintf (buf, "%x", core);
		    strcat (buf, ";");
		    buf += strlen (buf);
		  }
	      }
	  }

	if (dlls_changed)
	  {
	    strcpy (buf, "library:;");
	    buf += strlen (buf);
	    dlls_changed = 0;
	  }

	current_inferior = saved_inferior;
      }
      break;
    case TARGET_WAITKIND_EXITED:
      if (multi_process)
	sprintf (buf, "W%x;process:%x",
		 status->value.integer, ptid_get_pid (ptid));
      else
	sprintf (buf, "W%02x", status->value.integer);
      break;
    case TARGET_WAITKIND_SIGNALLED:
      if (multi_process)
	sprintf (buf, "X%x;process:%x",
		 status->value.sig, ptid_get_pid (ptid));
      else
	sprintf (buf, "X%02x", status->value.sig);
      break;
    default:
      error ("unhandled waitkind");
      break;
    }
}

void
decode_m_packet (char *from, CORE_ADDR *mem_addr_ptr, unsigned int *len_ptr)
{
  int i = 0, j = 0;
  char ch;
  *mem_addr_ptr = *len_ptr = 0;

  while ((ch = from[i++]) != ',')
    {
      *mem_addr_ptr = *mem_addr_ptr << 4;
      *mem_addr_ptr |= fromhex (ch) & 0x0f;
    }

  for (j = 0; j < 4; j++)
    {
      if ((ch = from[i++]) == 0)
	break;
      *len_ptr = *len_ptr << 4;
      *len_ptr |= fromhex (ch) & 0x0f;
    }
}

void
decode_M_packet (char *from, CORE_ADDR *mem_addr_ptr, unsigned int *len_ptr,
		 unsigned char **to_p)
{
  int i = 0;
  char ch;
  *mem_addr_ptr = *len_ptr = 0;

  while ((ch = from[i++]) != ',')
    {
      *mem_addr_ptr = *mem_addr_ptr << 4;
      *mem_addr_ptr |= fromhex (ch) & 0x0f;
    }

  while ((ch = from[i++]) != ':')
    {
      *len_ptr = *len_ptr << 4;
      *len_ptr |= fromhex (ch) & 0x0f;
    }

  if (*to_p == NULL)
    *to_p = xmalloc (*len_ptr);

  convert_ascii_to_int (&from[i++], *to_p, *len_ptr);
}

int
decode_X_packet (char *from, int packet_len, CORE_ADDR *mem_addr_ptr,
		 unsigned int *len_ptr, unsigned char **to_p)
{
  int i = 0;
  char ch;
  *mem_addr_ptr = *len_ptr = 0;

  while ((ch = from[i++]) != ',')
    {
      *mem_addr_ptr = *mem_addr_ptr << 4;
      *mem_addr_ptr |= fromhex (ch) & 0x0f;
    }

  while ((ch = from[i++]) != ':')
    {
      *len_ptr = *len_ptr << 4;
      *len_ptr |= fromhex (ch) & 0x0f;
    }

  if (*to_p == NULL)
    *to_p = xmalloc (*len_ptr);

  if (remote_unescape_input ((const gdb_byte *) &from[i], packet_len - i,
			     *to_p, *len_ptr) != *len_ptr)
    return -1;

  return 0;
}

/* Decode a qXfer write request.  */

int
decode_xfer_write (char *buf, int packet_len, CORE_ADDR *offset,
		   unsigned int *len, unsigned char *data)
{
  char ch;
  char *b = buf;

  /* Extract the offset.  */
  *offset = 0;
  while ((ch = *buf++) != ':')
    {
      *offset = *offset << 4;
      *offset |= fromhex (ch) & 0x0f;
    }

  /* Get encoded data.  */
  packet_len -= buf - b;
  *len = remote_unescape_input ((const gdb_byte *) buf, packet_len,
				data, packet_len);
  return 0;
}

/* Decode the parameters of a qSearch:memory packet.  */

int
decode_search_memory_packet (const char *buf, int packet_len,
			     CORE_ADDR *start_addrp,
			     CORE_ADDR *search_space_lenp,
			     gdb_byte *pattern, unsigned int *pattern_lenp)
{
  const char *p = buf;

  p = decode_address_to_semicolon (start_addrp, p);
  p = decode_address_to_semicolon (search_space_lenp, p);
  packet_len -= p - buf;
  *pattern_lenp = remote_unescape_input ((const gdb_byte *) p, packet_len,
					 pattern, packet_len);
  return 0;
}

static void
free_sym_cache (struct sym_cache *sym)
{
  if (sym != NULL)
    {
      free (sym->name);
      free (sym);
    }
}

void
clear_symbol_cache (struct sym_cache **symcache_p)
{
  struct sym_cache *sym, *next;

  /* Check the cache first.  */
  for (sym = *symcache_p; sym; sym = next)
    {
      next = sym->next;
      free_sym_cache (sym);
    }

  *symcache_p = NULL;
}

/* Get the address of NAME, and return it in ADDRP if found.  if
   MAY_ASK_GDB is false, assume symbol cache misses are failures.
   Returns 1 if the symbol is found, 0 if it is not, -1 on error.  */

int
look_up_one_symbol (const char *name, CORE_ADDR *addrp, int may_ask_gdb)
{
  char own_buf[266], *p, *q;
  int len;
  struct sym_cache *sym;
  struct process_info *proc;

  proc = current_process ();

  /* Check the cache first.  */
  for (sym = proc->symbol_cache; sym; sym = sym->next)
    if (strcmp (name, sym->name) == 0)
      {
	*addrp = sym->addr;
	return 1;
      }

  /* It might not be an appropriate time to look up a symbol,
     e.g. while we're trying to fetch registers.  */
  if (!may_ask_gdb)
    return 0;

  /* Send the request.  */
  strcpy (own_buf, "qSymbol:");
  hexify (own_buf + strlen ("qSymbol:"), name, strlen (name));
  if (putpkt (own_buf) < 0)
    return -1;

  /* FIXME:  Eventually add buffer overflow checking (to getpkt?)  */
  len = getpkt (own_buf);
  if (len < 0)
    return -1;

  /* We ought to handle pretty much any packet at this point while we
     wait for the qSymbol "response".  That requires re-entering the
     main loop.  For now, this is an adequate approximation; allow
     GDB to read from memory while it figures out the address of the
     symbol.  */
  while (own_buf[0] == 'm')
    {
      CORE_ADDR mem_addr;
      unsigned char *mem_buf;
      unsigned int mem_len;

      decode_m_packet (&own_buf[1], &mem_addr, &mem_len);
      mem_buf = xmalloc (mem_len);
      if (read_inferior_memory (mem_addr, mem_buf, mem_len) == 0)
	convert_int_to_ascii (mem_buf, own_buf, mem_len);
      else
	write_enn (own_buf);
      free (mem_buf);
      if (putpkt (own_buf) < 0)
	return -1;
      len = getpkt (own_buf);
      if (len < 0)
	return -1;
    }

  if (strncmp (own_buf, "qSymbol:", strlen ("qSymbol:")) != 0)
    {
      warning ("Malformed response to qSymbol, ignoring: %s\n", own_buf);
      return -1;
    }

  p = own_buf + strlen ("qSymbol:");
  q = p;
  while (*q && *q != ':')
    q++;

  /* Make sure we found a value for the symbol.  */
  if (p == q || *q == '\0')
    return 0;

  decode_address (addrp, p, q - p);

  /* Save the symbol in our cache.  */
  sym = xmalloc (sizeof (*sym));
  sym->name = xstrdup (name);
  sym->addr = *addrp;
  sym->next = proc->symbol_cache;
  proc->symbol_cache = sym;

  return 1;
}

/* Relocate an instruction to execute at a different address.  OLDLOC
   is the address in the inferior memory where the instruction to
   relocate is currently at.  On input, TO points to the destination
   where we want the instruction to be copied (and possibly adjusted)
   to.  On output, it points to one past the end of the resulting
   instruction(s).  The effect of executing the instruction at TO
   shall be the same as if executing it at OLDLOC.  For example, call
   instructions that implicitly push the return address on the stack
   should be adjusted to return to the instruction after OLDLOC;
   relative branches, and other PC-relative instructions need the
   offset adjusted; etc.  Returns 0 on success, -1 on failure.  */

int
relocate_instruction (CORE_ADDR *to, CORE_ADDR oldloc)
{
  char own_buf[266];
  int len;
  ULONGEST written = 0;

  /* Send the request.  */
  strcpy (own_buf, "qRelocInsn:");
  sprintf (own_buf, "qRelocInsn:%s;%s", paddress (oldloc),
	   paddress (*to));
  if (putpkt (own_buf) < 0)
    return -1;

  /* FIXME:  Eventually add buffer overflow checking (to getpkt?)  */
  len = getpkt (own_buf);
  if (len < 0)
    return -1;

  /* We ought to handle pretty much any packet at this point while we
     wait for the qRelocInsn "response".  That requires re-entering
     the main loop.  For now, this is an adequate approximation; allow
     GDB to access memory.  */
  while (own_buf[0] == 'm' || own_buf[0] == 'M' || own_buf[0] == 'X')
    {
      CORE_ADDR mem_addr;
      unsigned char *mem_buf = NULL;
      unsigned int mem_len;

      if (own_buf[0] == 'm')
	{
	  decode_m_packet (&own_buf[1], &mem_addr, &mem_len);
	  mem_buf = xmalloc (mem_len);
	  if (read_inferior_memory (mem_addr, mem_buf, mem_len) == 0)
	    convert_int_to_ascii (mem_buf, own_buf, mem_len);
	  else
	    write_enn (own_buf);
	}
      else if (own_buf[0] == 'X')
	{
	  if (decode_X_packet (&own_buf[1], len - 1, &mem_addr,
			       &mem_len, &mem_buf) < 0
	      || write_inferior_memory (mem_addr, mem_buf, mem_len) != 0)
	    write_enn (own_buf);
	  else
	    write_ok (own_buf);
	}
      else
	{
	  decode_M_packet (&own_buf[1], &mem_addr, &mem_len, &mem_buf);
	  if (write_inferior_memory (mem_addr, mem_buf, mem_len) == 0)
	    write_ok (own_buf);
	  else
	    write_enn (own_buf);
	}
      free (mem_buf);
      if (putpkt (own_buf) < 0)
	return -1;
      len = getpkt (own_buf);
      if (len < 0)
	return -1;
    }

  if (own_buf[0] == 'E')
    {
      warning ("An error occurred while relocating an instruction: %s\n",
	       own_buf);
      return -1;
    }

  if (strncmp (own_buf, "qRelocInsn:", strlen ("qRelocInsn:")) != 0)
    {
      warning ("Malformed response to qRelocInsn, ignoring: %s\n",
	       own_buf);
      return -1;
    }

  unpack_varlen_hex (own_buf + strlen ("qRelocInsn:"), &written);

  *to += written;
  return 0;
}

void
monitor_output (const char *msg)
{
  char *buf = xmalloc (strlen (msg) * 2 + 2);

  buf[0] = 'O';
  hexify (buf + 1, msg, 0);

  putpkt (buf);
  free (buf);
}

#endif
@


1.98
log
@Rely on gnulib's unistd.h replacement.

With gnulib's unistd module, we can assume unistd.h is always present, and that
STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO are always defined.

Don't remove unistd.h from GDB's configure.ac, as later tests in the
file use HAVE_UNISTD_H checks.

gdb/
2013-07-01  Pedro Alves  <palves@@redhat.com>

	* defs.h: Don't check HAVE_UNISTD_H before including <unistd.h>.
	(STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO): Delete.
	* tracepoint.c: Don't check HAVE_UNISTD_H before including
	<unistd.h>.

gdb/gdbserver/
2013-07-01  Pedro Alves  <palves@@redhat.com>

	* event-loop.c: Don't check HAVE_UNISTD_H before including
	<unistd.h>.
	* gdbreplay.c: Likewise.
	* remote-utils.c: Likewise.
	* server.c: Likewise.
	* configure.ac: Don't check for unistd.h.
	* configure: Regenerate.
@
text
@d24 2
@


1.97
log
@[GDBserver] Multi-process + multi-arch

This patch makes GDBserver support multi-process + biarch.

Currently, if you're debugging more than one process at once with a
single gdbserver (in extended-remote mode), then all processes must
have the same architecture (e.g., 64-bit vs 32-bit).  Otherwise, you
see this:

Added inferior 2
[Switching to inferior 2 [<null>] (<noexec>)]
Reading symbols from /home/pedro/gdb/tests/main32...done.
Temporary breakpoint 2 at 0x4004cf: main. (2 locations)
Starting program: /home/pedro/gdb/tests/main32
warning: Selected architecture i386 is not compatible with reported target architecture i386:x86-64
warning: Architecture rejected target-supplied description
Remote 'g' packet reply is too long: 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000090cfffff0000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000b042f7460000000000020000230000002b0000002b0000002b000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007f03000000000000ffff0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000801f00003b0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
... etc, etc ...

Even though the process was running a 32-bit program, GDBserver sent
back to GDB a register set in 64-bit layout.

A patch (http://sourceware.org/ml/gdb-patches/2012-11/msg00228.html) a
while ago made GDB track a target_gdbarch per inferior, and as
consequence, fetch a target description per-inferior.  This patch is
the GDBserver counterpart, that makes GDBserver keep track of each
process'es XML target description and register layout.  So in the
example above, GDBserver will send the correct register set in 32-bit
layout to GDB.

A new "struct target_desc" object (tdesc for short) is added, that
holds the target description and register layout information about
each process.  Each `struct process_info' holds a pointer to a target
description.  The regcache also gains a pointer to a target
description, mainly for convenience, and parallel with GDB (and
possible future support for programs that flip processor modes).

The low target's arch_setup routines are responsible for setting the
process'es correct tdesc.  This isn't that much different to how
things were done before, except that instead of detecting the inferior
process'es architecture and calling the corresponding
init_registers_FOO routine, which would change the regcache layout
globals and recreate the threads' regcaches, the regcache.c globals
are gone, and the init_registers_$BAR routines now each initialize a
separate global struct target_desc object (one for each arch variant
GDBserver supports), and so all the init_registers_$BAR routines that
are built into GDBserver are called early at GDBserver startup time
(similarly to how GDB handles its built-in target descriptions), and
then the arch_setup routine is responsible for making
process_info->tdesc point to one of these target description globals.
The regcache module is all parameterized to get the regcache's layout
from the tdesc object instead of the old register_bytes, etc. globals.

The threads' regcaches are now created lazily.  The old scheme where
we created each of them when we added a new thread doesn't work
anymore, because we add the main thread/lwp before we see it stop for
the first time, and it is only when we see the thread stop for the
first time that we have a chance of determining the inferior's
architecture (through the_low_target.arch_setup).  Therefore when we
add the main thread we don't know which architecture/tdesc its
regcache should have.

This patch makes the gdb.multi/multi-arch.exp test now pass against
(extended-remote) GDBserver.  It currently fails, without this patch.

The IPA also uses the regcache, so it gains a new global struct
target_desc pointer, which points at the description of the process it
is loaded in.

Re. the linux-low.c & friends changes.  Since the register map
etc. may differ between processes (64-bit vs 32-bit) etc., the
linux_target_ops num_regs, regmap and regset_bitmap data fields are no
longer sufficient.  A new method is added in their place that returns
a pointer to a new struct that includes all info linux-low.c needs to
access registers of the current inferior.

The patch/discussion that originally introduced
linux-low.c:disabled_regsets mentions that the disabled_regsets set
may be different per mode (in a biarch setup), and indeed that is
cleared whenever we start a new (first) inferior, so that global is
moved as well behind the new `struct regs_info'.

On the x86 side:

I simply replaced the i387-fp.c:num_xmm_registers global with a check
for 64-bit or 32-bit process, which is equivalent to how the global
was set.  This avoided coming up with some more general mechanism that
would work for all targets that use this module (GNU/Linux, Windows,
etc.).

Tested:

  GNU/Linux IA64
  GNU/Linux MIPS64
  GNU/Linux PowerPC (Fedora 16)
  GNU/Linux s390x (Fedora 16)
  GNU/Linux sparc64 (Debian)
  GNU/Linux x86_64, -m64 and -m32 (Fedora 17)

Cross built, and smoke tested:

  i686-w64-mingw32, under Wine.
  GNU/Linux TI C6x, by Yao Qi.

Cross built but otherwise not tested:

  aarch64-linux-gnu
  arm-linux-gnu
  m68k-linux
  nios2-linux-gnu
  sh-linux-gnu
  spu
  tilegx-unknown-linux-gnu

Completely untested:

  GNU/Linux Blackfin
  GNU/Linux CRIS
  GNU/Linux CRISv32
  GNU/Linux TI Xtensa
  GNU/Linux M32R
  LynxOS
  QNX NTO

gdb/gdbserver/
2013-06-07  Pedro Alves  <palves@@redhat.com>

	* Makefile.in (OBS): Add tdesc.o.
	(IPA_OBJS): Add tdesc-ipa.o.
	(tdesc-ipa.o): New rule.
	* ax.c (gdb_eval_agent_expr): Adjust register_size call to new
	interface.
	* linux-low.c (new_inferior): Delete.
	(disabled_regsets, num_regsets): Delete.
	(linux_add_process): Adjust to set the new per-process
	new_inferior flag.
	(linux_detach_one_lwp): Adjust to call regcache_invalidate_thread.
	(linux_wait_for_lwp): Adjust.  Only call arch_setup if the event
	was a stop.  When calling arch_setup, switch the current inferior
	to the thread that got an event.
	(linux_resume_one_lwp): Adjust to call regcache_invalidate_thread.
	(regsets_fetch_inferior_registers)
	(regsets_store_inferior_registers): New regsets_info parameter.
	Adjust to use it.
	(linux_register_in_regsets): New regs_info parameter.  Adjust to
	use it.
	(register_addr, fetch_register, store_register): New usrregs_info
	parameter.  Adjust to use it.
	(usr_fetch_inferior_registers, usr_store_inferior_registers): New
	parameter regs_info.  Adjust to use it.
	(linux_fetch_registers): Get the current inferior's regs_info, and
	adjust to use it.
	(linux_store_registers): Ditto.
	[HAVE_LINUX_REGSETS] (initialize_regsets_info): New.
	(initialize_low): Don't initialize the target_regsets here.  Call
	initialize_low_arch.
	* linux-low.h (target_regsets): Delete declaration.
	(struct regsets_info): New.
	(struct usrregs_info): New.
	(struct regs_info): New.
	(struct process_info_private) <new_inferior>: New field.
	(struct linux_target_ops): Delete the num_regs, regmap, and
	regset_bitmap fields.  New field regs_info.
	[HAVE_LINUX_REGSETS] (initialize_regsets_info): Declare.
	* i387-fp.c (num_xmm_registers): Delete.
	(i387_cache_to_fsave, i387_fsave_to_cache): Adjust find_regno
	calls to new interface.
	(i387_cache_to_fxsave, i387_cache_to_xsave, i387_fxsave_to_cache)
	(i387_xsave_to_cache): Adjust find_regno calls to new interface.
	Infer the number of xmm registers from the regcache's target
	description.
	* i387-fp.h (num_xmm_registers): Delete.
	* inferiors.c (add_thread): Don't install the thread's regcache
	here.
	* proc-service.c (gregset_info): Fetch the current inferior's
	regs_info.  Adjust to use it.
	* regcache.c: Include tdesc.h.
	(register_bytes, reg_defs, num_registers)
	(gdbserver_expedite_regs): Delete.
	(get_thread_regcache): If the thread doesn't have a regcache yet,
	create one, instead of aborting gdbserver.
	(regcache_invalidate_one): Rename to ...
	(regcache_invalidate_thread): ... this.
	(regcache_invalidate_one): New.
	(regcache_invalidate): Only invalidate registers of the current
	process.
	(init_register_cache): Add target_desc parameter, and use it.
	(new_register_cache): Ditto.  Assert the target description has a
	non zero registers_size.
	(regcache_cpy): Add assertions.  Adjust.
	(realloc_register_cache, set_register_cache): Delete.
	(registers_to_string, registers_from_string): Adjust.
	(find_register_by_name, find_regno, find_register_by_number)
	(register_cache_size): Add target_desc parameter, and use it.
	(free_register_cache_thread, free_register_cache_thread_one)
	(regcache_release, register_cache_size): New.
	(register_size): Add target_desc parameter, and use it.
	(register_data, supply_register, supply_register_zeroed)
	(supply_regblock, supply_register_by_name, collect_register)
	(collect_register_as_string, collect_register_by_name): Adjust.
	* regcache.h (struct target_desc): Forward declare.
	(struct regcache) <tdesc>: New field.
	(init_register_cache, new_register_cache): Add target_desc
	parameter.
	(regcache_invalidate_thread): Declare.
	(regcache_invalidate_one): Delete declaration.
	(regcache_release): Declare.
	(find_register_by_number, register_cache_size, register_size)
	(find_regno): Add target_desc parameter.
	(gdbserver_expedite_regs, gdbserver_xmltarget): Delete
	declarations.
	* remote-utils.c: Include tdesc.h.
	(outreg, prepare_resume_reply): Adjust.
	* server.c: Include tdesc.h.
	(gdbserver_xmltarget): Delete declaration.
	(get_features_xml, process_serial_event): Adjust.
	* server.h [IN_PROCESS_AGENT] (struct target_desc): Forward
	declare.
	(struct process_info) <tdesc>: New field.
	(ipa_tdesc): Declare.
	* tdesc.c: New file.
	* tdesc.h: New file.
	* tracepoint.c: Include tdesc.h.
	[IN_PROCESS_AGENT] (ipa_tdesc): Define.
	(get_context_regcache): Adjust to pass ipa_tdesc down.
	(do_action_at_tracepoint): Adjust to get the register cache size
	from the context regcache's description.
	(traceframe_walk_blocks): Adjust to get the register cache size
	from the current trace frame's description.
	(traceframe_get_pc): Adjust to get current trace frame's
	description and pass it down.
	(gdb_collect): Adjust to get the register cache size from the
	IPA's description.
	* linux-amd64-ipa.c (tdesc_amd64_linux): Declare.
	(gdbserver_xmltarget): Delete.
	(initialize_low_tracepoint): Set the ipa's target description.
	* linux-i386-ipa.c (tdesc_i386_linux): Declare.
	(initialize_low_tracepoint): Set the ipa's target description.
	* linux-x86-low.c: Include tdesc.h.
	[__x86_64__] (is_64bit_tdesc): New.
	(ps_get_thread_area, x86_get_thread_area): Use it.
	(i386_cannot_store_register): Rename to ...
	(x86_cannot_store_register): ... this.  Use is_64bit_tdesc.
	(i386_cannot_fetch_register): Rename to ...
	(x86_cannot_fetch_register): ... this.  Use is_64bit_tdesc.
	(x86_fill_gregset, x86_store_gregset): Adjust register_size calls
	to new interface.
	(target_regsets): Rename to ...
	(x86_regsets): ... this.
	(x86_get_pc, x86_set_pc): Adjust register_size calls to new
	interface.
	(x86_siginfo_fixup): Use is_64bit_tdesc.
	[__x86_64__] (tdesc_amd64_linux, tdesc_amd64_avx_linux)
	(tdesc_x32_avx_linux, tdesc_x32_linux)
	(tdesc_i386_linux, tdesc_i386_mmx_linux, tdesc_i386_avx_linux):
	Declare.
	(x86_linux_update_xmltarget): Delete.
	(I386_LINUX_XSAVE_XCR0_OFFSET): Define.
	(have_ptrace_getfpxregs, have_ptrace_getregset): New.
	(AMD64_LINUX_USER64_CS): New.
	(x86_linux_read_description): New, based on
	x86_linux_update_xmltarget.
	(same_process_callback): New.
	(x86_arch_setup_process_callback): New.
	(x86_linux_update_xmltarget): New.
	(x86_regsets_info): New.
	(amd64_linux_regs_info): New.
	(i386_linux_usrregs_info): New.
	(i386_linux_regs_info): New.
	(x86_linux_regs_info): New.
	(x86_arch_setup): Reimplement.
	(x86_install_fast_tracepoint_jump_pad): Use is_64bit_tdesc.
	(x86_emit_ops): Ditto.
	(the_low_target): Adjust.  Install x86_linux_regs_info,
	x86_cannot_fetch_register, and x86_cannot_store_register.
	(initialize_low_arch): New.
	* linux-ia64-low.c (tdesc_ia64): Declare.
	(ia64_fetch_register): Adjust.
	(ia64_usrregs_info, regs_info): New globals.
	(ia64_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-sparc-low.c (tdesc_sparc64): Declare.
	(sparc_fill_gregset_to_stack, sparc_store_gregset_from_stack):
	Adjust.
	(sparc_arch_setup): New function.
	(sparc_regsets_info, sparc_usrregs_info, regs_info): New globals.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-ppc-low.c (tdesc_powerpc_32l, tdesc_powerpc_altivec32l)
	(tdesc_powerpc_cell32l, tdesc_powerpc_vsx32l)
	(tdesc_powerpc_isa205_32l, tdesc_powerpc_isa205_altivec32l)
	(tdesc_powerpc_isa205_vsx32l, tdesc_powerpc_e500l)
	(tdesc_powerpc_64l, tdesc_powerpc_altivec64l)
	(tdesc_powerpc_cell64l, tdesc_powerpc_vsx64l)
	(tdesc_powerpc_isa205_64l, tdesc_powerpc_isa205_altivec64l)
	(tdesc_powerpc_isa205_vsx64l): Declare.
	(ppc_cannot_store_register, ppc_collect_ptrace_register)
	(ppc_supply_ptrace_register, parse_spufs_run, ppc_get_pc)
	(ppc_set_pc, ppc_get_hwcap): Adjust.
	(ppc_usrregs_info): Forward declare.
	(!__powerpc64__) ppc_regmap_adjusted: New global.
	(ppc_arch_setup): Adjust to the current process'es target
	description.
	(ppc_fill_vsxregset, ppc_store_vsxregset, ppc_fill_vrregset)
	(ppc_store_vrregset, ppc_fill_evrregset, ppc_store_evrregse)
	(ppc_store_evrregset): Adjust.
	(target_regsets): Rename to ...
	(ppc_regsets): ... this, and make static.
	(ppc_usrregs_info, ppc_regsets_info, regs_info): New globals.
	(ppc_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-s390-low.c (tdesc_s390_linux32, tdesc_s390_linux32v1)
	(tdesc_s390_linux32v2, tdesc_s390_linux64, tdesc_s390_linux64v1)
	(tdesc_s390_linux64v2, tdesc_s390x_linux64, tdesc_s390x_linux64v1)
	(tdesc_s390x_linux64v2): Declare.
	(s390_collect_ptrace_register, s390_supply_ptrace_register)
	(s390_fill_gregset, s390_store_last_break): Adjust.
	(target_regsets): Rename to ...
	(s390_regsets): ... this, and make static.
	(s390_get_pc, s390_set_pc): Adjust.
	(s390_get_hwcap): New target_desc parameter, and use it.
	[__s390x__] (have_hwcap_s390_high_gprs): New global.
	(s390_arch_setup): Adjust to set the current process'es target
	description.  Don't adjust the regmap.
	(s390_usrregs_info, s390_regsets_info, regs_info): New globals.
	[__s390x__] (s390_usrregs_info_3264, s390_regsets_info_3264)
	(regs_info_3264): New globals.
	(s390_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-mips-low.c (tdesc_mips_linux, tdesc_mips_dsp_linux)
	(tdesc_mips64_linux, tdesc_mips64_dsp_linux): Declare.
	[__mips64] (init_registers_mips_linux)
	(init_registers_mips_dsp_linux): Delete defines.
	[__mips64] (tdesc_mips_linux, tdesc_mips_dsp_linux): New defines.
	(have_dsp): New global.
	(mips_read_description): New, based on mips_arch_setup.
	(mips_arch_setup): Reimplement.
	(get_usrregs_info): New function.
	(mips_cannot_fetch_register, mips_cannot_store_register)
	(mips_get_pc, mips_set_pc, mips_fill_gregset, mips_store_gregset)
	(mips_fill_fpregset, mips_store_fpregset): Adjust.
	(target_regsets): Rename to ...
	(mips_regsets): ... this, and make static.
	(mips_regsets_info, mips_dsp_usrregs_info, mips_usrregs_info)
	(dsp_regs_info, regs_info): New globals.
	(mips_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-arm-low.c (tdesc_arm, tdesc_arm_with_iwmmxt)
	(tdesc_arm_with_vfpv2, tdesc_arm_with_vfpv3, tdesc_arm_with_neon):
	Declare.
	(arm_fill_vfpregset, arm_store_vfpregset): Adjust.
	(arm_read_description): New, with bits factored from
	arm_arch_setup.
	(arm_arch_setup): Reimplement.
	(target_regsets): Rename to ...
	(arm_regsets): ... this, and make static.
	(arm_regsets_info, arm_usrregs_info, regs_info): New globals.
	(arm_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-m68k-low.c (tdesc_m68k): Declare.
	(target_regsets): Rename to ...
	(m68k_regsets): ... this, and make static.
	(m68k_regsets_info, m68k_usrregs_info, regs_info): New globals.
	(m68k_regs_info): New function.
	(m68k_arch_setup): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-sh-low.c (tdesc_sharch): Declare.
	(target_regsets): Rename to ...
	(sh_regsets): ... this, and make static.
	(sh_regsets_info, sh_usrregs_info, regs_info): New globals.
	(sh_regs_info, sh_arch_setup): New functions.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-bfin-low.c (tdesc_bfin): Declare.
	(bfin_arch_setup): New function.
	(bfin_usrregs_info, regs_info): New globals.
	(bfin_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-cris-low.c (tdesc_cris): Declare.
	(cris_arch_setup): New function.
	(cris_usrregs_info, regs_info): New globals.
	(cris_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-cris-low.c (tdesc_crisv32): Declare.
	(cris_arch_setup): New function.
	(cris_regsets_info, cris_usrregs_info, regs_info): New globals.
	(cris_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-m32r-low.c (tdesc_m32r): Declare.
	(m32r_arch_setup): New function.
	(m32r_usrregs_info, regs_info): New globals.
	(m32r_regs_info): Adjust.
	(initialize_low_arch): New function.
	* linux-tic6x-low.c (tdesc_tic6x_c64xp_linux)
	(tdesc_tic6x_c64x_linux, tdesc_tic6x_c62x_linux): Declare.
	(tic6x_usrregs_info): Forward declare.
	(tic6x_read_description): New function, based on ...
	(tic6x_arch_setup): ... this.  Reimplement.
	(target_regsets): Rename to ...
	(tic6x_regsets): ... this, and make static.
	(tic6x_regsets_info, tic6x_usrregs_info, regs_info): New globals.
	(tic6x_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-xtensa-low.c (tdesc_xtensa): Declare.
	(xtensa_fill_gregset, xtensa_store_gregset): Adjust.
	(target_regsets): Rename to ...
	(xtensa_regsets): ... this, and make static.
	(xtensa_regsets_info, xtensa_usrregs_info, regs_info): New
	globals.
	(xtensa_arch_setup, xtensa_regs_info): New functions.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-nios2-low.c (tdesc_nios2_linux): Declare.
	(nios2_arch_setup): Set the current process'es tdesc.
	(target_regsets): Rename to ...
	(nios2_regsets): ... this.
	(nios2_regsets_info, nios2_usrregs_info, regs_info): New globals.
	(nios2_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
        * linux-aarch64-low.c (tdesc_aarch64): Declare.
        (aarch64_arch_setup): Set the current process'es tdesc.
        (target_regsets): Rename to ...
        (aarch64_regsets): ... this.
        (aarch64_regsets_info, aarch64_usrregs_info, regs_info): New globals.
        (aarch64_regs_info): New function.
        (the_low_target): Adjust.
        (initialize_low_arch): New function.
	* linux-tile-low.c (tdesc_tilegx, tdesc_tilegx32): Declare
	globals.
	(target_regsets): Rename to ...
	(tile_regsets): ... this.
	(tile_regsets_info, tile_usrregs_info, regs_info): New globals.
	(tile_regs_info): New function.
	(tile_arch_setup): Set the current process'es tdesc.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* spu-low.c (tdesc_spu): Declare.
	(spu_create_inferior, spu_attach): Set the new process'es tdesc.
	* win32-arm-low.c (tdesc_arm): Declare.
	(arm_arch_setup): New function.
	(the_low_target): Install arm_arch_setup instead of
	init_registers_arm.
	* win32-i386-low.c (tdesc_i386, tdesc_amd64): Declare.
	(init_windows_x86): Rename to ...
	(i386_arch_setup): ... this.  Set `win32_tdesc'.
	(the_low_target): Adjust.
	* win32-low.c (win32_tdesc): New global.
	(child_add_thread): Don't create the thread cache here.
	(do_initial_child_stuff): Set the new process'es tdesc.
	* win32-low.h (struct target_desc): Forward declare.
	(win32_tdesc): Declare.
	* lynx-i386-low.c (tdesc_i386): Declare global.
	(lynx_i386_arch_setup): Set `lynx_tdesc'.
	* lynx-low.c (lynx_tdesc): New global.
	(lynx_add_process): Set the new process'es tdesc.
	* lynx-low.h (struct target_desc): Forward declare.
	(lynx_tdesc): Declare global.
	* lynx-ppc-low.c (tdesc_powerpc_32): Declare global.
	(lynx_ppc_arch_setup): Set `lynx_tdesc'.
	* nto-low.c (nto_tdesc): New global.
	(do_attach): Set the new process'es tdesc.
	* nto-low.h (struct target_desc): Forward declare.
	(nto_tdesc): Declare.
	* nto-x86-low.c (tdesc_i386): Declare.
	(nto_x86_arch_setup): Set `nto_tdesc'.

gdb/
2013-06-07  Pedro Alves  <palves@@redhat.com>

	* regformats/regdat.sh: Output #include tdesc.h.  Make globals
	static.  Output a global target description pointer.
	(init_registers_${name}): Adjust to initialize a
	target description structure.
@
text
@a53 1
#if HAVE_UNISTD_H
a54 1
#endif
@


1.96
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d23 1
d1274 1
a1274 1
  buf += 2 * register_size (regno);
a1331 2
	regp = gdbserver_expedite_regs;

d1336 2
d1362 1
a1362 1
	    buf = outreg (regcache, find_regno (*regp), buf);
@


1.96.2.1
log
@PR server/15604

gdb/gdbserver/
2013-08-29  Jan Kratochvil  <jan.kratochvil@@redhat.com>

	PR server/15604
	* linux-low.c
	(linux_create_inferior) <pid == 0 && !remote_connection_is_stdio ()>:
	Close LISTEN_DESC and optionally REMOTE_DESC.
	(lynx_create_inferior) <pid == 0 && !remote_connection_is_stdio ()>:
	Close LISTEN_DESC and optionally REMOTE_DESC.
	* remote-utils.c (remote_desc, listen_desc): Remove static qualifier.
	* server.h (remote_desc, listen_desc): New declaration.
	* spu-low.c
	(spu_create_inferior) <pid == 0 && !remote_connection_is_stdio ()>:
	Close LISTEN_DESC and optionally REMOTE_DESC.
@
text
@d111 2
a112 2
gdb_fildes_t remote_desc = INVALID_DESCRIPTOR;
gdb_fildes_t listen_desc = INVALID_DESCRIPTOR;
@


1.95
log
@2012-11-15  Pierre Muller  <muller@@sourceware.org>

	ARI fixes: move gdb_wait and gdb_stat headers to common subdirectory.
	* gdb_stat.h: Delete. Moved to common directory.
	* common/gdb_stat.h: New file.
	* gdb_wait.h: Delete. Moved to common directory.
	* common/gdb_wait.h: New file.
	* Makefile.in (H_FILES_NO_SRC): Adapt to new header
	location.
	* contrib/ari/gdb_ari.sh (wait.h rule): Adapt to new gdb_wait.h
	location.
	(stat.h rule): Adapt to new gdb_stat.h location.
	* common/linux-osdata.c: Include "gdb_stat.h" header instead of
	<sys/stat.h> header.
	* common/linux-ptrace.c: Include "gdb_wait.h" header instead of
	<sys/wait.h> header.


gdbserver ChangeLog entry:

2012-11-15  Pierre Muller  <muller@@sourceware.org>

	* configure.ac (AC_CHECK_HEADERS): Add wait.h header.
	* config.in: Regenerate.
	* configure: Regenerate.
	* linux-low.c: Use "gdb_stat.h" header instead of <sys/stat.h> header.
	Use "gdb_wait.h" header instead of <sys/wait.h> header.
	* lynx-low.c: Use "gdb_wait.h" header instead of <sys/wait.h> header.
	* remote-utils.c: Use "gdb_stat.h" header instead of <sys/stat.h>
	header.
	* server.c: Remove HAVE_WAIT_H conditional.  Use "gdb_wait.h" header
	instead of <sys/wait.h> header.
	* spu-low.c: Use "gdb_wait.h" header instead of <sys/wait.h> header.
@
text
@d2 1
a2 1
   Copyright (C) 1986, 1989, 1993-2012 Free Software Foundation, Inc.
@


1.94
log
@gdb/gdbserver:
2012-11-09  Yao Qi  <yao@@codesourcery.com>

	* spu-low.c (current_ptid): Move it to ..
	* gdbthread.h: ... here.  New.
	* remote-utils.c (read_ptid): Use macro 'current_ptid'.
	* server.c (myresume, process_serial_event): Likewise.
	* thread-db.c (thread_db_find_new_threads): Likewise.
	* tracepoint.c (run_inferior_command): Likewise.
@
text
@d59 1
a59 1
#include <sys/stat.h>
@


1.93
log
@gdb/gdbserver:

	* server.h: Move some code to ...
	* gdbthread.h: ... here.  New.
	* Makefile.in (inferiors.o, regcache.o): Depends on gdbthread.h
	(remote-utils.o, server.o, target.o tracepoint.o): Likewise.
	(nto-low.o, win32-low.o): Likewise.
	* inferiors.c, linux-low.h, nto-low.c: Include gdbthread.h.
	* regcache.c, remote-utils.c, server.c: Likewise.
	* target.c, tracepoint.c, win32-low.c: Likewise.
@
text
@d764 1
a764 1
  pid = ptid_get_pid (((struct inferior_list_entry *) current_inferior)->id);
@


1.92
log
@gdb/gdbserver/
	* remote-utils.c (prepare_resume_reply): Replace with macro
	target_core_of_thread.
	* server.c (handle_qxfer_threads_proper): Likewise.
	* target.h (traget_core_of_thread): New macro.
@
text
@d22 1
@


1.91
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d1393 2
a1394 2
		if (the_target->core_of_thread)
		  core = (*the_target->core_of_thread) (ptid);
@


1.90
log
@	* NEWS: Add entry for stdio gdbserver.

	gdbserver/
	* linux-low.c (linux_create_inferior): If stdio connection,
	redirect stdin from /dev/null, stdout to stderr.
	* remote-utils.c (remote_is_stdio): New static global.
	(remote_connection_is_stdio): New function.
	(remote_prepare): Handle stdio connection.
	(remote_open): Ditto.
	(remote_close): Don't close stdin for stdio connections.
	(read_prim,write_prim): New functions.  Replace all calls to
	read/write to these.
	* server.c (main): Watch for "-" argument.  Move call to
	remote_prepare before start_inferior.
	* server.h (STDIO_CONNECTION_NAME): New macro.
	(remote_connection_is_stdio): Declare.

	doc/
	* gdb.texinfo (Server): Document -/stdio argument to gdbserver.

	testsuite/
	* lib/gdbserver-support.exp (gdb_target_cmd): Recognize stdio
	gdbserver output.
	(gdbserver_default_get_remote_address): New function.
	(gdbserver_start): Call gdb,get_remote_address to compute argument
	to "target remote" command.
@
text
@d2 1
a2 3
   Copyright (C) 1986, 1989, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.89
log
@	* remote-utils.c (prepare_resume_reply): Remove extraneous \n
	in debugging output.
@
text
@d110 2
d135 8
d235 11
d296 1
d298 18
a316 3
#ifdef USE_WIN32API
      error ("Only <host>:<port> is supported on this platform.");
#else
d381 1
a382 1
    }
d412 2
a413 1
  close (remote_desc);
d772 26
d835 1
a835 1
      if (write (remote_desc, buf2, p - buf2) != p - buf2)
d930 1
a930 1
      cc = read (remote_desc, &c, 1);
d1058 1
a1058 2
      readchar_bufcnt = read (remote_desc, readchar_buf,
			      sizeof (readchar_buf));
d1180 1
a1180 1
      if (write (remote_desc, "-", 1) != 1)
d1192 1
a1192 1
      if (write (remote_desc, "+", 1) != 1)
@


1.88
log
@gdb/gdbserver

	* remote-utils.c (relocate_instruction): A comment fix.
@
text
@d1255 1
a1255 1
    fprintf (stderr, "Writing resume reply for %s:%d\n\n",
@


1.88.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 3
a4 1
   Copyright (C) 1986, 1989, 1993-2012 Free Software Foundation, Inc.
@


1.87
log
@2011-07-22  Kwok Cheung Yeung  <kcy@@codesourcery.com>

gdb/
	* defs.h: Add guard against inclusion in gdbserver.
	(struct ptid, ptid_t): Move to common/ptid.h.
	(xfree, xzalloc, xasprintf, xvasprintf, xstrprintf, xstrvprintf,
	xsnprintf, internal_error): Move to common/common-utils.h.
	(nomem): Delete.
	* gdb_assert.h: Move into common/ sub-directory.
	* gdb_locale.h: Ditto.
	* gdb_dirent.h: Ditto.
	* inferior.h (minus_one_ptid, null_ptid, ptid_build, pid_to_ptid,
	ptid_get_pid, ptid_get_lwp, ptid_get_tid, ptid_equal, ptid_is_pid):
	Move into common/ptid.h.
	* xml-support.c (xml_escape_text): Move into common/xml-utils.c.
	(gdb_xml_create_parser_and_cleanup_1, xml_fetch_context_from_file):
	Change nomem to malloc_failure.
	* xml-support.h (xml_escape_text): Move into common/xml-utils.h.
	* utils.c (nomem): Rename to malloc_failure.
	(xmalloc, xzalloc, xrealloc, xcalloc, xfree, xstrprintf, xasprintf,
	xvasprintf, xstrvprintf, xsnprintf): Move to common/common-utils.c.
	(gdb_buildargv): Change nomem to malloc_failure.
	* infrun.c (null_ptid, minus_one_ptid, ptid_build, pid_to_ptid,
	ptid_get_pid, ptid_get_lwp, ptid_get_tid, ptid_equal,
	ptid_is_pid): Move into common/ptid.c.
	(initialize_infrun): Delete initialization of null_ptid and
	minus_one_ptid.
	* linux-nat.c (linux_nat_xfer_osdata): Defer to
	linux_common_xfer_osdata.
	* Makefile.in (SFILES): Add common/common-utils.c, common/xml-utils.c,
	common/ptid.c and common/buffer.c.
	(HFILES_NO_SRCDIR): Add common/common-utils.h, common/xml-utils.h,
	common/ptid.h, common/buffer.h and common/linux-osdata.h.
	(COMMON_OBS): Add xml-utils.o, common-utils.o, buffer.o and ptid.o.
	(common-utils.o, xml-utils.o, ptid.o, buffer.o, linux-osdata.o): New
	rules.
	* common/gdb_assert.h: New.
	* common/gdb_dirent.h: New.
	* common/gdb_locale.h: New.
	* common/buffer.c: New.
	* common/buffer.h: New.
	* common/ptid.c: New.
	* common/ptid.h: New.
	* common/xml-utils.c: New.
	* common/xml-utils.h: New.
	* common/common-utils.c: New.
	* common/common-utils.h: New.
	* common/linux-osdata.c: New.
	* common/linux-osdata.h: New.
	* config/alpha/alpha-linux.mh (NATDEPFILES): Add linux-osdata.o.
	* config/arm/linux.mh (NATDEPFILES): Ditto.
	* config/i386/linux.mh (NATDEPFILES): Ditto.
	* config/i386/linux64.mh (NATDEPFILES): Ditto.
	* config/ia64/linux.mh (NATDEPFILES): Ditto.
	* config/m32r/linux.mh (NATDEPFILES): Ditto.
	* config/m68k/linux.mh (NATDEPFILES): Ditto.
	* config/mips/linux.mh (NATDEPFILES): Ditto.
	* config/pa/linux.mh (NATDEPFILES): Ditto.
	* config/powerpc/linux.mh (NATDEPFILES): Ditto.
	* config/powerpc/ppc64-linux.mh (NATDEPFILES): Ditto.
	* config/s390/s390.mh (NATDEPFILES): Ditto.
	* config/sparc/linux.mh (NATDEPFILES): Ditto.
	* config/sparc/linux64.mh (NATDEPFILES): Ditto.
	* config/xtensa/linux.mh (NATDEPFILES): Ditto.

gdbserver/
	* linux-low.c (compare_ints, unique, list_threads, show_process,
	linux_core_of_thread): Delete.
	(linux_target_ops): Change linux_core_of_thread to
	linux_common_core_of_thread.
	(linux_qxfer_osdata): Defer to linux_common_xfer_osdata.
	* utils.c (malloc_failure): Change type of argument.
	(xmalloc, xrealloc, xcalloc, xsnprintf): Delete.
	* Makefile.in (SFILES): Add common/common-utils.c, common/xml-utils.c,
	common/linux-osdata.c, common/ptid.c and common/buffer.c.
	(OBS): Add xml-utils.o, common-utils.o, ptid.o and buffer.o.
	(IPA_OBJS): Add common-utils-ipa.o.
	(ptid_h, linux_osdata_h): New macros.
	(server_h): Add common/common-utils.h, common/xml-utils.h,
	common/buffer.h, common/gdb_assert.h, common/gdb_locale.h and
	common/ptid.h.
	(common-utils-ipa.o, common-utils.o, xml-utils.o, linux-osdata.o,
	ptid.o, buffer.o): New rules.
	(linux-low.o): Add common/linux-osdata.h as a dependency.
	* configure.srv (srv_tgtobj): Add linux-osdata.o to Linux targets.
	* configure.ac: Add AC_HEADER_DIRENT check.
	* config.in: Regenerate.
	* configure: Regenerate.
	* remote-utils.c (xml_escape_text): Delete.
	(buffer_grow, buffer_free, buffer_init, buffer_finish,
	buffer_xml_printf): Move to common/buffer.c.
	* server.c (main): Remove call to initialize_inferiors.
	* server.h (struct ptid, ptid_t, minus_one_ptid, null_ptid,
	ptid_build, pid_to_ptid, ptid_get_pid, ptid_get_lwp, ptid_get_tid,
	ptid_equal, ptid_is_pid, initialize_inferiors, xml_escape_text,
	internal_error, gdb_assert, gdb_assert_fail): Delete.
	(struct buffer, buffer_grow, buffer_free, buffer_init, buffer_finish,
	buffer_xml_printf, buffer_grow_str, buffer_grow_str0): Move to
	common/buffer.h.
	* inferiors.c (null_ptid, minus_one_ptid, ptid_build, pid_to_ptid,
	ptid_get_pid, ptid_get_lwp, ptid_get_tid, ptid_equal, ptid_is_pid,
	initialize_inferiors): Delete.
@
text
@d1616 1
a1616 1
   shall be the same as if executing it at FROM.  For example, call
@


1.86
log
@gdb/
	* NEWS: Document the new gdbserver --once option.

gdb/doc/
	* gdb.texinfo (Starting and Stopping Trace Experiments): New anchor
	for disconnected tracing.
	(Multi-Process Mode for @@code{gdbserver}): Mention --multi and
	extended-remote relationship.  Mention --once.
	(TCP port allocation lifecycle of @@code{gdbserver}): New.

gdb/gdbserver/
	* remote-utils.c (handle_accept_event): Close LISTEN_DESC only if
	RUN_ONCE.  Comment for the LISTEN_DESC delete_file_handler call.
	(remote_prepare): New function with most of the TCP code from ...
	(remote_open): ... here.  Detect PORT here unconditionally.  Move also
	setting transport_is_reliable.
	* server.c (run_once): New variable.
	(gdbserver_usage): Document it.
	(main): Set run_once for `--once'.  Call remote_prepare.  Exit after
	the first run if RUN_ONCE.
	* server.h (run_once, remote_prepare): New declarations.

gdb/testsuite/
	* gdb.base/solib-disc.exp: Set gdbserver_reconnect_p.
	* lib/gdb.exp (gdb_init): Clear gdbserver_reconnect_p.
	* lib/gdbserver-support.exp (gdbserver_start): Add `--once' if
	!gdbserver_reconnect_p..
	(gdbserver_reconnect): Call error if !gdbserver_reconnect_p..
@
text
@a1716 164
/* Return a malloc allocated string with special characters from TEXT
   replaced by entity references.  */

char *
xml_escape_text (const char *text)
{
  char *result;
  int i, special;

  /* Compute the length of the result.  */
  for (i = 0, special = 0; text[i] != '\0'; i++)
    switch (text[i])
      {
      case '\'':
      case '\"':
	special += 5;
	break;
      case '&':
	special += 4;
	break;
      case '<':
      case '>':
	special += 3;
	break;
      default:
	break;
      }

  /* Expand the result.  */
  result = xmalloc (i + special + 1);
  for (i = 0, special = 0; text[i] != '\0'; i++)
    switch (text[i])
      {
      case '\'':
	strcpy (result + i + special, "&apos;");
	special += 5;
	break;
      case '\"':
	strcpy (result + i + special, "&quot;");
	special += 5;
	break;
      case '&':
	strcpy (result + i + special, "&amp;");
	special += 4;
	break;
      case '<':
	strcpy (result + i + special, "&lt;");
	special += 3;
	break;
      case '>':
	strcpy (result + i + special, "&gt;");
	special += 3;
	break;
      default:
	result[i + special] = text[i];
	break;
      }
  result[i + special] = '\0';

  return result;
}

void
buffer_grow (struct buffer *buffer, const char *data, size_t size)
{
  char *new_buffer;
  size_t new_buffer_size;

  if (size == 0)
    return;

  new_buffer_size = buffer->buffer_size;

  if (new_buffer_size == 0)
    new_buffer_size = 1;

  while (buffer->used_size + size > new_buffer_size)
    new_buffer_size *= 2;
  new_buffer = realloc (buffer->buffer, new_buffer_size);
  if (!new_buffer)
    abort ();
  memcpy (new_buffer + buffer->used_size, data, size);
  buffer->buffer = new_buffer;
  buffer->buffer_size = new_buffer_size;
  buffer->used_size += size;
}

void
buffer_free (struct buffer *buffer)
{
  if (!buffer)
    return;

  free (buffer->buffer);
  buffer->buffer = NULL;
  buffer->buffer_size = 0;
  buffer->used_size = 0;
}

void
buffer_init (struct buffer *buffer)
{
  memset (buffer, 0, sizeof (*buffer));
}

char*
buffer_finish (struct buffer *buffer)
{
  char *ret = buffer->buffer;
  buffer->buffer = NULL;
  buffer->buffer_size = 0;
  buffer->used_size = 0;
  return ret;
}

void
buffer_xml_printf (struct buffer *buffer, const char *format, ...)
{
  va_list ap;
  const char *f;
  const char *prev;
  int percent = 0;

  va_start (ap, format);

  prev = format;
  for (f = format; *f; f++)
    {
      if (percent)
       {
	 switch (*f)
	   {
	   case 's':
	     {
	       char *p;
	       char *a = va_arg (ap, char *);
	       buffer_grow (buffer, prev, f - prev - 1);
	       p = xml_escape_text (a);
	       buffer_grow_str (buffer, p);
	       free (p);
	       prev = f + 1;
	     }
	     break;
	   case 'd':
	     {
	       int i = va_arg (ap, int);
	       char b[sizeof ("4294967295")];

	       buffer_grow (buffer, prev, f - prev - 1);
	       sprintf (b, "%d", i);
	       buffer_grow_str (buffer, b);
	       prev = f + 1;
	     }
	   }
	 percent = 0;
       }
      else if (*f == '%')
       percent = 1;
    }

  buffer_grow_str (buffer, prev);
  va_end (ap);
}

@


1.85
log
@gdb/gdbserver/
	* remote-utils.c (putpkt_binary_1): Calculate BUF2 size dynamically.
@
text
@a172 2
  close (listen_desc);		/* No longer need this */

d175 6
d182 1
a182 1
  closesocket (listen_desc);	/* No longer need this */
d184 1
d186 2
d210 56
a339 2
      transport_is_reliable = 0;

a347 3
#ifdef USE_WIN32API
      static int winsock_initialized;
#endif
d349 1
a350 11
      socklen_t tmp;
      char *port_end;

      port = strtoul (port_str + 1, &port_end, 10);
      if (port_str[1] == '\0' || *port_end != '\0')
	fatal ("Bad port argument: %s", name);

#ifdef USE_WIN32API
      if (!winsock_initialized)
	{
	  WSADATA wsad;
d352 6
a357 33
	  WSAStartup (MAKEWORD (1, 0), &wsad);
	  winsock_initialized = 1;
	}
#endif

      listen_desc = socket (PF_INET, SOCK_STREAM, IPPROTO_TCP);
      if (listen_desc == -1)
	perror_with_name ("Can't open socket");

      /* Allow rapid reuse of this port. */
      tmp = 1;
      setsockopt (listen_desc, SOL_SOCKET, SO_REUSEADDR, (char *) &tmp,
		  sizeof (tmp));

      sockaddr.sin_family = PF_INET;
      sockaddr.sin_port = htons (port);
      sockaddr.sin_addr.s_addr = INADDR_ANY;

      if (bind (listen_desc, (struct sockaddr *) &sockaddr, sizeof (sockaddr))
	  || listen (listen_desc, 1))
	perror_with_name ("Can't bind address");

      /* If port is zero, a random port will be selected, and the
	 fprintf below needs to know what port was selected.  */
      if (port == 0)
	{
	  socklen_t len = sizeof (sockaddr);
	  if (getsockname (listen_desc,
			   (struct sockaddr *) &sockaddr, &len) < 0
	      || len < sizeof (sockaddr))
	    perror_with_name ("Can't determine port");
	  port = ntohs (sockaddr.sin_port);
	}
a363 2

      transport_is_reliable = 1;
@


1.84
log
@2011-01-25  Pedro Alves  <pedro@@codesourcery.com>

	* server.h (decode_xfer_write): Change prototype.
	* remote-utils.c (decode_xfer_write): Remove `annex' parameter,
	and don't extract the annex here.
	* server.c (decode_xfer_read): Remove `annex' parameter,
	and don't extract the annex here.
	(decode_xfer): New.
	(struct qxfer): New.
	(handle_qxfer_auxv, handle_qxfer_features, handle_qxfer_libraries)
	(handle_qxfer_osdata, handle_qxfer_siginfo, handle_qxfer_spu)
	(handle_qxfer_statictrace): New functions, abstracted out from
	handle_query, and made to use the struct qxfer interface.
	(handle_threads_qxfer_proper): Rename to ...
	(handle_qxfer_threads_proper): ... this.
	(handle_threads_qxfer): Rename to ...
	(handle_qxfer_threads): ... this.  Adjust.
	(qxfer_packets): New array.
	(handle_qxfer): New function.
	(handle_query): Use handle_qxfer.
@
text
@d728 1
a728 1
  buf2 = xmalloc (PBUFSIZ);
@


1.83
log
@2011-01-05  Michael Snyder  <msnyder@@msnyder-server.eng.vmware.com>

	* gdbreplay.c: Shorten lines of >= 80 columns.
	* linux-low.c: Ditto.
	* linux-ppc-low.c: Ditto.
	* linux-s390-low.c: Ditto.
	* linux-sparc-low.c: Ditto.
	* linux-x86-low.c: Ditto.
	* linux-xtensa-low.c: Ditto.
	* mem-break.c: Ditto.
	* nto-low.c: Ditto.
	* regcache.h: Ditto.
	* remote-utils.c: Ditto.
	* server.c: Ditto.
	* server.h: Ditto.
	* thread-db.c: Ditto.
	* tracepoint.c: Ditto.
	* utils.c: Ditto.
	* win32-low.h: Ditto.
@
text
@d1435 1
d1437 1
a1437 1
decode_xfer_write (char *buf, int packet_len, char **annex, CORE_ADDR *offset,
d1441 1
a1441 8

  /* Extract and NUL-terminate the annex.  */
  *annex = buf;
  while (*buf && *buf != ':')
    buf++;
  if (*buf == '\0')
    return -1;
  *buf++ = 0;
d1452 1
a1452 1
  packet_len -= buf - *annex;
@


1.82
log
@run copyright.sh for 2011.
@
text
@d331 2
a332 1
	  if (getsockname (listen_desc, (struct sockaddr *) &sockaddr, &len) < 0
d975 2
a976 1
      readchar_bufcnt = read (remote_desc, readchar_buf, sizeof (readchar_buf));
d1088 3
a1090 1
	  fprintf (stderr, "Bad checksum, sentsum=0x%x, csum=0x%x, buf=%s [no-ack-mode, Bad medium?]\n",
@


1.81
log
@	* event-loop.c (event_handle_func): Adjust to use gdb_fildes_t.
	(struct gdb_event) <fd>: Change type to gdb_fildes_t.
	(struct file_handler) <fd>: Change type to gdb_fildes_t.
	(process_event): Change local fd's type to gdb_fildes_t.
	(create_file_handler): Adjust prototype.
	(delete_file_handler): Adjust prototype.
	(handle_file_event): Adjust prototype.  Use pfildes.
	(create_file_event): Adjsut prototype.
	* remote-utils.c (remote_desc, listen_desc): Change type to
	gdb_fildes_t.
	* server.h: New gdb_fildes_t typedef.
	[USE_WIN32API]: Include winsock2.h.
	(delete_file_handler, add_file_handler): Adjust prototypes.
	(pfildes): Declare.
	* utils.c (pfildes): New.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
@


1.80
log
@	* gdbreplay.c (remote_error): New.
	(gdbchar): New.
	(expect): Use gdbchar.  Check for error reading from GDB.
	Clarify sync error output.
	(play): Check for errors writing to GDB.
	* linux-low.c (sigchld_handler): Really ignore `write' errors.
	* remote-utils.c (getpkt): Check for errors writing to the remote
	descriptor.
@
text
@d110 2
a111 2
static int remote_desc = INVALID_DESCRIPTOR;
static int listen_desc = INVALID_DESCRIPTOR;
@


1.79
log
@	Static tracepoints support, and UST integration.

	gdb/gdbserver/
	* configure.ac: Handle --with-ust.  substitute ustlibs and ustinc.
	* mem-break.c (uninsert_all_breakpoints)
	(reinsert_all_breakpoints): New.
	* mem-break.h (reinsert_all_breakpoints, uninsert_all_breakpoints):
	* tracepoint.c (ust_loaded, helper_thread_id, cmd_buf): New.
	(gdb_agent_ust_loaded, helper_thread_id)
	(gdb_agent_helper_thread_id): New macros.
	(struct ipa_sym_addresses): Add addr_ust_loaded,
	addr_helper_thread_id, addr_cmd_buf.
	(symbol_list): Add ust_loaded, helper_thread_id, cmd_buf.
	(in_process_agent_loaded_ust): New.
	(write_e_ust_not_loaded): New.
	(maybe_write_ipa_ust_not_loaded): New.
	(struct collect_static_trace_data_action): New.
	(enum tracepoint_type) <static_tracepoint>: New.
	(struct tracepoint) <handle>: Mention static tracepoints.
	(struct static_tracepoint_ctx): New.
	(CMD_BUF_SIZE): New.
	(add_tracepoint_action): Handle static tracepoint actions.
	(unprobe_marker_at): New.
	(clear_installed_tracepoints): Handle static tracepoints.
	(cmd_qtdp): Handle static tracepoints.
	(probe_marker_at): New.
	(cmd_qtstart): Handle static tracepoints.
	(response_tracepoint): Handle static tracepoints.
	(cmd_qtfstm, cmd_qtsstm, cmd_qtstmat): New.
	(handle_tracepoint_query): Handle qTfSTM, qTsSTM and qTSTMat.
	(get_context_regcache): Handle static tracepoints.
	(do_action_at_tracepoint): Handle static tracepoint actions.
	(traceframe_find_block_type): Handle static trace data blocks.
	(traceframe_read_sdata): New.
	(download_tracepoints): Download static tracepoint actions.
	[HAVE_UST] Include ust/ust.h, dlfcn.h, sys/socket.h, and sys/un.h.
	(GDB_PROBE_NAME): New.
	(ust_ops): New.
	(GET_UST_SYM): New.
	(USTF): New.
	(dlsym_ust): New.
	(ust_marker_to_static_tracepoint): New.
	(gdb_probe): New.
	(collect_ust_data_at_tracepoint): New.
	(gdb_ust_probe): New.
	(UNIX_PATH_MAX, SOCK_DIR): New.
	(gdb_ust_connect_sync_socket): New.
	(resume_thread, stop_thread): New.
	(run_inferior_command): New.
	(init_named_socket): New.
	(gdb_ust_socket_init): New.
	(cstr_to_hexstr): New.
	(next_st): New.
	(first_marker, next_marker): New.
	(response_ust_marker): New.
	(cmd_qtfstm, cmd_qtsstm): New.
	(unprobe_marker_at, probe_marker_at): New.
	(cmd_qtstmat, gdb_ust_thread): New.
	(gdb_ust_init): New.
	(initialize_tracepoint_ftlib): Call gdb_ust_init.
	* linux-amd64-ipa.c [HAVE_UST]: Include ust/processor.h
	(ST_REGENTRY): New.
	(x86_64_st_collect_regmap): New.
	(X86_64_NUM_ST_COLLECT_GREGS): New.
	(AMD64_RIP_REGNUM): New.
	(supply_static_tracepoint_registers): New.
	* linux-i386-ipa.c [HAVE_UST]: Include ust/processor.h
	(ST_REGENTRY): New.
	(i386_st_collect_regmap): New.
	(i386_NUM_ST_COLLECT_GREGS): New.
	(supply_static_tracepoint_registers): New.
	* server.c (handle_query): Handle qXfer:statictrace:read.
	<qSupported>: Report support for StaticTracepoints, and
	qXfer:statictrace:read features.
	* server.h (traceframe_read_sdata)
	(supply_static_tracepoint_registers): Declare.
	* remote-utils.c (convert_int_to_ascii, hexchars, ishex, tohex)
	(unpack_varlen_hex): Include in IPA build.
	* Makefile.in (ustlibs, ustinc): New.
	(IPA_OBJS): Add remote-utils-ipa.o.
	($(IPA_LIB)): Link -ldl and -lpthread.
	(UST_CFLAGS): New.
	(IPAGENT_CFLAGS): Add UST_CFLAGS.
	* config.in, configure: Regenerate.

	gdb/
	* NEWS: Mention new support for static tracepoints.
	(New packets): Mention qTfSTM, qTsSTM, qTSTMat and
	qXfer:statictrace:read.
	(New features in the GDB remote stub, GDBserver): Mention static
	tracepoints support using an UST based backend.
	(New commands): Mention "info static-tracepoint-markers" and
	"strace".
	* breakpoint.c (is_marker_spec): New.
	(is_tracepoint): Handle static tracepoints.
	(validate_commands_for_breakpoint): Static tracepoints can't do
	while-stepping.
	(static_tracepoints_here): New.
	(bpstat_what): Handle static tracepoints.
	(print_one_breakpoint_location, allocate_bp_location, mention):
	Ditto.
	(create_breakpoint_sal): Ditto.
	(decode_static_tracepoint_spec): New.
	(create_breakpoint): Replace `hardwareflag', and `traceflag' with
	`type_wanted'.  Adjust.  Handle static tracepoint marker
	locations.
	(break_command_1): Adjust.
	(update_static_tracepoint): New.
	(update_breakpoint_locations): Handle static tracepoints.
	(breakpoint_re_set_one): Handle static tracepoint marker
	locations.
	(disable_command, enable_command): Handle static tracepoints.
	(trace_command, ftrace_command): Adjust.
	(strace_command): New.
	(create_tracepoint_from_upload): Adjust.
	(save_breakpoints): Handle static tracepoints.
	(_initialize_breakpoint): Install the "strace" command.
	* breakpoint.h (enum bptype): New bp_static_tracepoint type.
	(struct breakpoint): New fields static_trace_marker_id and
	static_trace_marker_id_idx.
	(breakpoints_here_p): Declare.
	(create_breakpoint): Adjust.
	(static_tracepoints_here): Declare.
	* remote.c (struct remote_state) <static_tracepoints>: New field.
	(PACKET_qXfer_statictrace_read, PACKET_StaticTracepoints): New.
	(remote_static_tracepoint_marker_at): New.
	(remote_static_tracepoint_markers_by_strid): New.
	(remote_static_tracepoint_feature): New.
	(remote_disconnected_tracing_feature): Handle "StaticTracepoints".
	(remote_xfer_partial): Handle TARGET_OBJECT_STATIC_TRACE_DATA.
	(remote_supports_static_tracepoints): New.
	(remote_download_tracepoint): Download static tracepoints.
	(init_remote_ops): Install remote_static_tracepoint_marker_at and
	remote_static_tracepoint_markers_by_strid.
	(_initialize_remote): Install set|show remote static-tracepoints,
	and set|show remote read-sdata-object commands.
	* target.c (update_current_target): Inherit and default
	to_static_tracepoint_marker_at, and
	to_static_tracepoint_markers_by_strid.
	* target.h (static_tracepoint_marker): Forward declare.
	(enum target_object): New object TARGET_OBJECT_STATIC_TRACE_DATA.
	(static_tracepoint_marker_p): New typedef.
	(DEF_VEC_P(static_tracepoint_marker_p)): New VEC type.
	(struct target_ops): New fields to_static_tracepoint_marker_at and
	to_static_tracepoint_markers_by_strid.
	(target_static_tracepoint_marker_at)
	(target_static_tracepoint_markers_by_strid): New.
	* tracepoint.c: Include source.h.
	(validate_actionline): Handle $_sdata.
	(struct collection_list): New field strace_data.
	(add_static_trace_data): New.
	(clear_collection_list): Clear strace_data.
	(stringify_collection_list): Account for a possible static trace
	data collection.
	(encode_actions_1): Encode an $_sdata collection.
	(parse_tracepoint_definition): Handle static tracepoints.
	(parse_static_tracepoint_marker_definition): New.
	(release_static_tracepoint_marker): New.
	(print_one_static_tracepoint_marker): New.
	(info_static_tracepoint_markers_command): New.
	(sdata_make_value): New.
	(_initialize_tracepoint): Create the $_sdata convenience variable.
	Add the "info static-tracepoint-markers" command.
	Mention $_sdata in the "collect" command's help output.
	* tracepoint.h (struct static_tracepoint_marker): New.
	(parse_static_tracepoint_marker_definition)
	(release_static_tracepoint_marker): Declare.
	* mi/mi-cmd-break.c (mi_cmd_break_insert): Adjust.
	* python/py-breakpoint.c (bppy_new): Adjust.

	doc/
	* gdb.texinfo (Convenience Variables): Document $_sdata.
	(Commands to Set Tracepoints): Describe static tracepoints.  Add
	`Listing Static Tracepoint Markers' menu entry.  Document
	"strace".
	(Tracepoint Action Lists): Document collecting $_sdata.
	(Listing Static Tracepoint Markers): New subsection.
	(Tracepoints support in gdbserver): Mention static tracepoints.
	(remote packets, enabling and disabling): Mention
	read-sdata-object.
	(General Query Packets) <qSupported>: Document qXfer:sdata:read
	and StaticTracepoint.
	Mention qTfSTM, qTsSTM and qTSTMat as tracepoint packets.
	Document qXfer:sdata:read.
	(Tracepoint packets): Document qTfSTM, qTsSTM and qTSTMat.
@
text
@d1094 2
a1095 1
      write (remote_desc, "-", 1);
d1106 2
a1107 1
      write (remote_desc, "+", 1);
@


1.78
log
@gdb/gdbserver/
2010-06-01  Pedro Alves  <pedro@@codesourcery.com>
	    Stan Shebs  <stan@@codesourcery.com>

	* Makefile.in (IPA_DEPFILES, extra_libraries): New.
	(all): Depend on $(extra_libraries).
	(install-only): Install the IPA.
	(IPA_OBJS, IPA_LIB): New.
	(clean): Remove the IPA lib.
	(IPAGENT_CFLAGS): New.
	(tracepoint-ipa.o, utils-ipa.o, remote-utils-ipa.o)
	(regcache-ipa.o, i386-linux-ipa.o, linux-i386-ipa.o)
	(linux-amd64-ipa.o, amd64-linux-ipa.o): New rules.
	* linux-amd64-ipa.c, linux-i386-ipa.c: New files.
	* configure.ac: Check for atomic builtins support in the compiler.
	(IPA_DEPFILES, extra_libraries): Define.
	* configure.srv (ipa_obj): Add description.
	(ipa_i386_linux_regobj, ipa_amd64_linux_regobj): Define.
	(i[34567]86-*-linux*): Set ipa_obj.
	(x86_64-*-linux*): Set ipa_obj.
	* linux-low.c (stabilizing_threads): New.
	(supports_fast_tracepoints): New.
	(linux_detach): Stabilize threads before detaching.
	(handle_tracepoints): Handle internal tracing breakpoints.  Assert
	the lwp is either not stabilizing, or is moving out of a jump pad.
	(linux_fast_tracepoint_collecting): New.
	(maybe_move_out_of_jump_pad): New.
	(enqueue_one_deferred_signal): New.
	(dequeue_one_deferred_signal): New.
	(linux_wait_for_event_1): If moving out of a jump pad, defer
	pending signals to later.
	(linux_stabilize_threads): New.
	(linux_wait_1): Check if threads need moving out of jump pads, and
	do it if so.
	(stuck_in_jump_pad_callback): New.
	(move_out_of_jump_pad_callback): New.
	(lwp_running): New.
	(linux_resume_one_lwp): Handle moving out of jump pads.
	(linux_set_resume_request): Dequeue deferred signals.
	(need_step_over_p): Also step over fast tracepoint jumps.
	(start_step_over): Also uninsert fast tracepoint jumps.
	(finish_step_over): Also reinsert fast tracepoint jumps.
	(linux_install_fast_tracepoint_jump): New.
	(linux_target_ops): Install linux_stabilize_threads and
	linux_install_fast_tracepoint_jump_pad.
	* linux-low.h (linux_target_ops) <get_thread_area,
	install_fast_tracepoint_jump_pad>: New fields.
	(struct lwp_info) <collecting_fast_tracepoint,
	pending_signals_to_report, exit_jump_pad_bkpt>: New fields.
	(linux_get_thread_area): Declare.
	* linux-x86-low.c (jump_insn): New.
	(x86_get_thread_area): New.
	(append_insns): New.
	(push_opcode): New.
	(amd64_install_fast_tracepoint_jump_pad): New.
	(i386_install_fast_tracepoint_jump_pad): New.
	(x86_install_fast_tracepoint_jump_pad): New.
	(the_low_target): Install x86_get_thread_area and
	x86_install_fast_tracepoint_jump_pad.
	* mem-break.c (set_raw_breakpoint_at): Use read_inferior_memory.
	(struct fast_tracepoint_jump): New.
	(fast_tracepoint_jump_insn): New.
	(fast_tracepoint_jump_shadow): New.
	(find_fast_tracepoint_jump_at): New.
	(fast_tracepoint_jump_here): New.
	(delete_fast_tracepoint_jump): New.
	(set_fast_tracepoint_jump): New.
	(uninsert_fast_tracepoint_jumps_at): New.
	(reinsert_fast_tracepoint_jumps_at): New.
	(set_breakpoint_at): Use write_inferior_memory.
	(uninsert_raw_breakpoint): Use write_inferior_memory.
	(check_mem_read): Mask out fast tracepoint jumps.
	(check_mem_write): Mask out fast tracepoint jumps.
	* mem-break.h (struct fast_tracepoint_jump): Forward declare.
	(set_fast_tracepoint_jump): Declare.
	(delete_fast_tracepoint_jump)
	(fast_tracepoint_jump_here, uninsert_fast_tracepoint_jumps_at)
	(reinsert_fast_tracepoint_jumps_at): Declare.
	* regcache.c: Don't compile many functions when building the
	in-process agent library.
	(init_register_cache) [IN_PROCESS_AGENT]: Don't allow allocating
	the register buffer in the heap.
	(free_register_cache): If the register buffer isn't owned by the
	regcache, don't free it.
	(set_register_cache) [IN_PROCESS_AGENT]: Don't re-alocate
	pre-existing register caches.
	* remote-utils.c (convert_int_to_ascii): Constify `from' parameter
	type.
	(convert_ascii_to_int): : Constify `from' parameter type.
	(decode_M_packet, decode_X_packet): Replace the `to' parameter by
	a `to_p' pointer to pointer parameter.  If TO_P is NULL, malloc
	the needed buffer in-place.
	(relocate_instruction): New.
	* server.c (handle_query) <qSymbols>: If the target supports
	tracepoints, give it a chance of looking up symbols.  Report
	support for fast tracepoints.
	(handle_status): Stabilize threads.
	(process_serial_event): Adjust.
	* server.h (struct fast_tracepoint_jump): Forward declare.
	(struct process_info) <fast_tracepoint_jumps>: New field.
	(convert_ascii_to_int, convert_int_to_ascii): Adjust.
	(decode_X_packet, decode_M_packet): Adjust.
	(relocate_instruction): Declare.
	(in_process_agent_loaded): Declare.
	(tracepoint_look_up_symbols): Declare.
	(struct fast_tpoint_collect_status): Declare.
	(fast_tracepoint_collecting): Declare.
	(force_unlock_trace_buffer): Declare.
	(handle_tracepoint_bkpts): Declare.
	(initialize_low_tracepoint)
	(supply_fast_tracepoint_registers) [IN_PROCESS_AGENT]: Declare.
	* target.h (struct target_ops) <stabilize_threads,
	install_fast_tracepoint_jump_pad>: New fields.
	(stabilize_threads, install_fast_tracepoint_jump_pad): New.
	* tracepoint.c [HAVE_MALLOC_H]: Include malloc.h.
	[HAVE_STDINT_H]: Include stdint.h.
	(trace_debug_1): Rename to ...
	(trace_vdebug): ... this.
	(trace_debug): Rename to ...
	(trace_debug_1): ... this.  Add `level' parameter.
	(trace_debug): New.
	(ATTR_USED, ATTR_NOINLINE): New.
	(IP_AGENT_EXPORT): New.
	(gdb_tp_heap_buffer, gdb_jump_pad_buffer, gdb_jump_pad_buffer_end)
	(collecting, gdb_collect, stop_tracing, flush_trace_buffer)
	(about_to_request_buffer_space, trace_buffer_is_full)
	(stopping_tracepoint, expr_eval_result, error_tracepoint)
	(tracepoints, tracing, trace_buffer_ctrl, trace_buffer_ctrl_curr)
	(trace_buffer_lo, trace_buffer_hi, traceframe_read_count)
	(traceframe_write_count, traceframes_created)
	(trace_state_variables)
	New renaming defines.
	(struct ipa_sym_addresses): New.
	(STRINGIZE_1, STRINGIZE, IPA_SYM): New.
	(symbol_list): New.
	(ipa_sym_addrs): New.
	(all_tracepoint_symbols_looked_up): New.
	(in_process_agent_loaded): New.
	(write_e_ipa_not_loaded): New.
	(maybe_write_ipa_not_loaded): New.
	(tracepoint_look_up_symbols): New.
	(debug_threads) [IN_PROCESS_AGENT]: New.
	(read_inferior_memory) [IN_PROCESS_AGENT]: New.
	(UNKNOWN_SIDE_EFFECTS): New.
	(stop_tracing): New.
	(flush_trace_buffer): New.
	(stop_tracing_bkpt): New.
	(flush_trace_buffer_bkpt): New.
	(read_inferior_integer): New.
	(read_inferior_uinteger): New.
	(read_inferior_data_pointer): New.
	(write_inferior_data_pointer): New.
	(write_inferior_integer): New.
	(write_inferior_uinteger): New.
	(struct collect_static_trace_data_action): Delete.
	(enum tracepoint_type): New.
	(struct tracepoint) <type>: New field `type'.
	<actions_str, step_actions, step_actions_str>: Only include in GDBserver.
	<orig_size, obj_addr_on_target, adjusted_insn_addr>
	<adjusted_insn_addr_end, jump_pad, jump_pad_end>: New fields.
	(tracepoints): Use IP_AGENT_EXPORT.
	(last_tracepoint): Don't include in the IPA.
	(stopping_tracepoint): Use IP_AGENT_EXPORT.
	(trace_buffer_is_full): Use IP_AGENT_EXPORT.
	(alloced_trace_state_variables): New.
	(trace_state_variables): Use IP_AGENT_EXPORT.
	(traceframe_t): Delete unused variable.
	(circular_trace_buffer): Don't include in the IPA.
	(trace_buffer_start): Delete.
	(struct trace_buffer_control): New.
	(trace_buffer_free): Delete.
	(struct ipa_trace_buffer_control): New.
	(GDBSERVER_FLUSH_COUNT_MASK, GDBSERVER_FLUSH_COUNT_MASK_PREV)
	(GDBSERVER_FLUSH_COUNT_MASK_CURR, GDBSERVER_UPDATED_FLUSH_COUNT_BIT):
	New.
	(trace_buffer_ctrl): New.
	(TRACE_BUFFER_CTRL_CURR): New.
	(trace_buffer_start, trace_buffer_free, trace_buffer_end_free):
	Reimplement as macros.
	(trace_buffer_wrap): Delete.
	(traceframe_write_count, traceframe_read_count)
	(traceframes_created, tracing): Use IP_AGENT_EXPORT.
	(struct tracepoint_hit_ctx) <type>: New field.
	(struct fast_tracepoint_ctx): New.
	(memory_barrier): New.
	(cmpxchg): New.
	(record_tracepoint_error): Update atomically in the IPA.
	(clear_inferior_trace_buffer): New.
	(about_to_request_buffer_space): New.
	(trace_buffer_alloc): Handle GDBserver and inferior simulatenous
	updating the same buffer.
	(add_tracepoint): Default the tracepoint's type to trap
	tracepoint, and orig_size to -1.
	(get_trace_state_variable) [IN_PROCESS_AGENT]: Handle allocated
	internal variables.
	(create_trace_state_variable): New parameter `gdb'.  Handle it.
	(clear_installed_tracepoints): Clear fast tracepoint jumps.
	(cmd_qtdp): Handle fast tracepoints.
	(cmd_qtdv): Adjust.
	(max_jump_pad_size): New.
	(gdb_jump_pad_head): New.
	(get_jump_space_head): New.
	(claim_jump_space): New.
	(sort_tracepoints): New.
	(MAX_JUMP_SIZE): New.
	(cmd_qtstart): Handle fast tracepoints.  Sync tracepoints with the
	IPA.
	(stop_tracing) [IN_PROCESS_AGENT]: Don't include the tdisconnected
	support.  Upload fast traceframes, and delete internal IPA
	breakpoints.
	(stop_tracing_handler): New.
	(flush_trace_buffer_handler): New.
	(cmd_qtstop): Upload fast tracepoints.
	(response_tracepoint): Handle fast tracepoints.
	(tracepoint_finished_step): Upload fast traceframes.  Set the
	tracepoint hit context's tracepoint type.
	(handle_tracepoint_bkpts): New.
	(tracepoint_was_hit): Set the tracepoint hit context's tracepoint
	type.  Add comment about fast tracepoints.
	(collect_data_at_tracepoint) [IN_PROCESS_AGENT]: Don't access the
	non-existing action_str field.
	(get_context_regcache): Handle fast tracepoints.
	(do_action_at_tracepoint) [!IN_PROCESS_AGENT]: Don't write the PC
	to the regcache.
	(fast_tracepoint_from_jump_pad_address): New.
	(fast_tracepoint_from_ipa_tpoint_address): New.
	(collecting_t): New.
	(force_unlock_trace_buffer): New.
	(fast_tracepoint_collecting): New.
	(collecting): New.
	(gdb_collect): New.
	(write_inferior_data_ptr): New.
	(target_tp_heap): New.
	(target_malloc): New.
	(download_agent_expr): New.
	(UALIGN): New.
	(download_tracepoints): New.
	(download_trace_state_variables): New.
	(upload_fast_traceframes): New.
	(IPA_FIRST_TRACEFRAME): New.
	(IPA_NEXT_TRACEFRAME_1): New.
	(IPA_NEXT_TRACEFRAME): New.
	[IN_PROCESS_AGENT]: Include sys/mman.h and fcntl.h.
	[IN_PROCESS_AGENT] (gdb_tp_heap_buffer, gdb_jump_pad_buffer)
	(gdb_jump_pad_buffer_end): New.
	[IN_PROCESS_AGENT] (initialize_tracepoint_ftlib): New.
	(initialize_tracepoint): Adjust.
	[IN_PROCESS_AGENT]: Allocate the IPA heap, and jump pad scratch
	buffer.  Initialize the low module.
	* utils.c (PREFIX, TOOLNAME): New.
	(malloc_failure): Use PREFIX.
	(error): In the IPA, an error causes an exit.
	(fatal, warning): Use PREFIX.
	(internal_error): Use TOOLNAME.
	(NUMCELLS): Increase to 10.
	* configure, config.in: Regenerate.

gdb/
2010-06-01  Pedro Alves  <pedro@@codesourcery.com>

	* NEWS: Mention gdbserver fast tracepoints support.

gdb/doc/
2010-06-01  Pedro Alves  <pedro@@codesourcery.com>

	* gdb.texinfo (Set Tracepoints): Mention tracepoints support in
	gdbserver, and add cross reference.
	(Tracepoints support in gdbserver): New subsection.
@
text
@d77 2
d376 2
d401 2
d455 2
d468 2
d613 2
d632 2
d1143 2
d1161 1
d1861 2
@


1.77
log
@2010-05-26  Ozkan Sezer  <sezeroz@@gmail.com>

gdb/
	* ser-tcp.c (net_open): Check error return from socket() call by its
	equality to -1 not by it being negative.
	(net_close): Likewise.

gdb/gdbserver/
	* gdbreplay.c (remote_open): Check error return from socket() call by
	its equality to -1 not by it being negative.
	* remote-utils.c (remote_open): Likewise.

sim/arm/
	* communicate.c (MYread_char): Check error return from accept() call
	by its equality to -1 not by it being negative.
	(MYread_charwait): Likewise.
	* main.c (main): Likewise for both socket() and accept() calls.

sim/common/
	* dv-sockser.c (dv_sockser_init): Check error return from socket()
	call by its equality to -1 not by it being negative.
	(connected_p): Likewise for accept() call.

sim/cris/
	* dv-rv.c (hw_rv_init_socket): Check error return from socket() call
	by its equality to -1 not by it being negative.
	(hw_rv_write): Likewise.
	(hw_rv_handle_incoming): Likewise.
	(hw_rv_poll_once): Likewise.
	* rvdummy.c (setupsocket): Likewise.
	(main): Likewise for accept() call as returned from setupsocket().

sim/m32c/
	* main.c (setup_tcp_console): Check error return from socket() call
	by its equality to -1 not by it being negative.
@
text
@d1130 1
a1130 1
convert_int_to_ascii (unsigned char *from, char *to, int n)
d1147 1
a1147 1
convert_ascii_to_int (char *from, unsigned char *to, int n)
d1357 1
a1357 1
		 unsigned char *to)
d1375 4
a1378 1
  convert_ascii_to_int (&from[i++], to, *len_ptr);
d1383 1
a1383 1
		 unsigned int *len_ptr, unsigned char *to)
d1401 3
d1405 1
a1405 1
			     to, *len_ptr) != *len_ptr)
d1574 95
@


1.76
log
@	* event-loop.c (struct callback_event): New struct.
	(callback_list): New global.
	(append_callback_event, delete_callback_event): New functions.
	(process_callback): New function.
	(start_event_loop): Call it.
	* remote-utils.c (NOT_SCHEDULED): Define.
	(readchar_buf, readchar_bufcnt, readchar_bufp): New static globals,
	moved out of readchar.
	(readchar): Rewrite.  Call reschedule before returning.
	(reset_readchar): New function.
	(remote_close): Call it.
	(process_remaining, reschedule): New functions.
	* server.h (callback_handler_func): New typedef.
	(append_callback_event, delete_callback_event): Declare.
@
text
@d308 1
a308 1
      if (listen_desc < 0)
@


1.75
log
@	gdb/gdbserver/
	* proc-service.c (ps_pglobal_lookup): Use
	thread_db_look_up_one_symbol.
	* remote-utils.c (look_up_one_symbol): Add new `may_ask_gdb'
	parameter.  Use it instead of all_symbols_looked_up.
	* server.h (struct process_info) <all_symbols_looked_up>: Delete
	field.
	(all_symbols_looked_up): Don't declare.
	(look_up_one_symbol): Add new `may_ask_gdb' parameter.
	* thread-db.c (struct thread_db) <all_symbols_looked_up>: New
	field.
	(thread_db_look_up_symbols): Adjust call to look_up_one_symbol.
	Set all_symbols_looked_up here.
	(thread_db_look_up_one_symbol): New.
	(thread_db_get_tls_address): Adjust.
	(thread_db_load_search, try_thread_db_load_1): Always allocate the
	thread_db object on the heap, and tentatively set it in the
	process structure.
	(thread_db_init): Don't set all_symbols_looked_up here.
	* linux-low.h (thread_db_look_up_one_symbol): Declare.
@
text
@d83 10
d94 2
d356 2
d943 8
d956 1
a956 3
  static unsigned char buf[BUFSIZ];
  static int bufcnt = 0;
  static unsigned char *bufp;
d958 3
a960 2
  if (bufcnt-- > 0)
    return *bufp++;
d962 6
a967 1
  bufcnt = read (remote_desc, buf, sizeof (buf));
d969 19
a987 1
  if (bufcnt <= 0)
d989 22
a1010 4
      if (bufcnt == 0)
	fprintf (stderr, "readchar: Got EOF\n");
      else
	perror ("readchar");
d1012 2
a1013 2
      return -1;
    }
d1015 5
a1019 3
  bufp = buf;
  bufcnt--;
  return *bufp++;
@


1.74
log
@	* remote-utils.c (putpkt_binary_1): Call readchar instead of read.
	Print received char after testing for error/eof instead of before.
	(input_interrupt): Tweak comment.
@
text
@d1414 2
a1415 1
/* Ask GDB for the address of NAME, and return it in ADDRP if found.
d1419 1
a1419 1
look_up_one_symbol (const char *name, CORE_ADDR *addrp)
d1436 3
a1438 6
  /* If we've passed the call to thread_db_look_up_symbols, then
     anything not in the cache must not exist; we're not interested
     in any libraries loaded after that point, only in symbols in
     libpthread.so.  It might not be an appropriate time to look
     up a symbol, e.g. while we're trying to fetch registers.  */
  if (proc->all_symbols_looked_up)
@


1.73
log
@	* configure.ac: Use `ws2_32' library for srv_mingw.
	* configure: Regenerate.
	* gdbreplay.c: Include winsock2.h instead of winsock.h.
	* remote-utils.c: Likewise.
@
text
@d83 2
a695 1
  char buf3[1];
d697 1
a722 2
      int cc;

d749 4
a752 2
      cc = read (remote_desc, buf3, 1);
      if (remote_debug)
d754 2
a755 2
	  fprintf (stderr, "[received '%c' (0x%x)]\n", buf3[0], buf3[0]);
	  fflush (stderr);
d758 1
a758 1
      if (cc <= 0)
d760 2
a761 7
	  if (cc == 0)
	    fprintf (stderr, "putpkt(read): Got EOF\n");
	  else
	    perror ("putpkt(read)");

	  free (buf2);
	  return -1;
d765 1
a765 1
      if (buf3[0] == '\003' && current_inferior != NULL)
d768 1
a768 1
  while (buf3[0] != '+');
d798 2
a799 1
   something.  About the only thing that should come through is a ^C, which
@


1.72
log
@	GDBserver disconnected tracing support.

	* linux-low.c (linux_remove_process): Delete.
	(add_lwp): Don't set last_resume_kind here.
	(linux_kill): Use `mourn'.
	(linux_detach): Use `thread_db_detach', and `mourn'.
	(linux_mourn): New.
	(linux_attach_lwp_1): Adjust comment.
	(linux_attach): last_resume_kind moved the thread_info; adjust.
	(status_pending_p_callback): Adjust.
	(linux_wait_for_event_1): Adjust.
	(count_events_callback, select_singlestep_lwp_callback)
	(select_event_lwp_callback, cancel_breakpoints_callback)
	(db_wants_lwp_stopped, linux_wait_1, need_step_over_p)
	(proceed_one_lwp): Adjust.
	(linux_async): Add debug output.
	(linux_thread_stopped): New.
	(linux_pause_all): New.
	(linux_target_ops): Install linux_mourn, linux_thread_stopped and
	linux_pause_all.
	* linux-low.h (struct lwp_info): Delete last_resume_kind field.
	(thread_db_free): Delete declaration.
	(thread_db_detach, thread_db_mourn): Declare.
	* thread-db.c (thread_db_init): Use thread_db_mourn.
	(thread_db_free): Delete, split in two.
	(disable_thread_event_reporting): New.
	(thread_db_detach): New.
	(thread_db_mourn): New.

	* server.h (struct thread_info) <last_resume_kind>: New field.
	<attached>: Add comment.
	<gdb_detached>: New field.
	(handler_func): Change return type to int.
	(handle_serial_event, handle_target_event): Ditto.
	(gdb_connected): Declare.
	(tracing): Delete.
	(disconnected_tracing): Declare.
	(stop_tracing): Declare.

	* server.c (handle_query) <qSupported>: Report support for
	disconnected tracing.
	(queue_stop_reply_callback): Account for running threads.
	(gdb_wants_thread_stopped): New.
	(gdb_wants_all_threads_stopped): New.
	(gdb_reattached_process): New.
	(handle_status): Clear the `gdb_detached' flag of all processes.
	In all-stop, stop all threads.
	(main): Be sure to leave tfind mode.  Handle disconnected tracing.
	(process_serial_event): If the remote connection breaks, or if an
	exit was forced with "monitor exit", force an event loop exit.
	Handle disconnected tracing on detach.
	(handle_serial_event): Adjust.
	(handle_target_event): If GDB isn't connected, forward events back
	to the inferior, unless the last process exited, in which case,
	exit gdbserver.  Adjust interface.

	* remote-utils.c (remote_open): Don't block in accept.  Instead
	register an event loop source on the listen socket file
	descriptor.  Refactor bits into ...
	(listen_desc): ... this new global.
	(gdb_connected): ... this new function.
	(enable_async_notification): ... this new function.
	(handle_accept_event): ... this new function.
	(remote_close): Clear remote_desc.

	* inferiors.c (add_thread): Set the new thread's last_resume_kind.

	* target.h (struct target_ops) <mourn, thread_stopped, pause_all>:
	New fields.
	(mourn_inferior): Define.
	(target_process_qsupported): Avoid the dangling else problem.
	(thread_stopped): Define.
	(pause_all): Define.
	(target_waitstatus_to_string): Declare.
	* target.c (target_waitstatus_to_string): New.

	* tracepoint.c (tracing): Make extern.
	(disconnected_tracing): New.
	(stop_tracing): Make extern.  Handle tracing stops due to GDB
	disconnecting.
	(cmd_qtdisconnected): New.
	(cmd_qtstatus): Report disconnected tracing status in trace reply.
	(handle_tracepoint_general_set): Handle QTDisconnected.

	* event-loop.c (event_handler_func): Change return type to int.
	(process_event): Bail out if the event handler wants the event
	loop to stop.
	(handle_file_event): Ditto.
	(start_event_loop): Bail out if the event handler wants the event
	loop to stop.

	* nto-low.c (nto_target_ops): Adjust.
	* spu-low.c (spu_wait): Don't remove the process here.
	(spu_target_ops): Adjust.
	* win32-low.c (win32_wait): Don't remove the process here.
	(win32_target_ops): Adjust.
@
text
@d66 1
a66 1
#include <winsock.h>
@


1.71
log
@	* regcache.h (struct thread_info): Forward declare.
	(struct regcache): New.
	(new_register_cache): Adjust prototype.
	(get_thread_regcache): Declare.
	(free_register_cache): Adjust prototype.
	(registers_to_string, registers_from_string): Ditto.
	(supply_register, supply_register_by_name, collect_register)
	(collect_register_as_string, collect_register_by_name): Ditto.
	* regcache.c (struct inferior_regcache_data): Delete.
	(get_regcache): Rename to ...
	(get_thread_regcache): ... this.  Adjust.  Switch inferior before
	fetching registers.
	(regcache_invalidate_one): Adjust.
	(regcache_invalidate): Fix prototype.
	(new_register_cache): Return the new register cache.
	(free_register_cache): Change prototype.
	(realloc_register_cache): Adjust.
	(registers_to_string): Change prototype to take a regcache.  Adjust.
	(registers_from_string): Ditto.
	(register_data): Ditto.
	(supply_register): Ditto.
	(supply_register_by_name): Ditto.
	(collect_register): Ditto.
	(collect_register_as_string): Ditto.
	(collect_register_by_name): Ditto.
	* server.c (process_serial_event): Adjust.
	* linux-low.h (regset_fill_func, regset_store_func): Change
	prototype.
	(get_pc, set_pc, collect_ptrace_register, supply_ptrace_register):
	Change prototype.
	* linux-low.c (get_stop_pc): Adjust.
	(check_removed_breakpoint): Adjust.
	(linux_wait_for_event): Adjust.
	(linux_resume_one_lwp): Adjust.
	(fetch_register): Add regcache parameter.  Adjust.
	(usr_store_inferior_registers): Ditto.
	(regsets_fetch_inferior_registers): Ditto.
	(regsets_store_inferior_registers): Ditto.
	(linux_fetch_registers, linux_store_registers): Ditto.
	* i387-fp.c (i387_cache_to_fsave): Change prototype to take a
	regcache.  Adjust.
	(i387_fsave_to_cache, i387_cache_to_fxsave, i387_fxsave_to_cache): Ditto.
	* i387-fp.h (i387_cache_to_fsave, i387_fsave_to_cache): Change
	prototype to take a regcache.
	(i387_cache_to_fxsave, i387_fxsave_to_cache): Ditto.
	* remote-utils.c (convert_ascii_to_int, outreg)
	(prepare_resume_reply): Change prototype to take a regcache.
	Adjust.
	* target.h (struct target_ops) <fetch_registers, store_registers>:
	Change prototype to take a regcache.
	(fetch_inferior_registers, store_inferior_registers): Change
	prototype to take a regcache.  Adjust.
	* proc-service.c (ps_lgetregs): Adjust.
	* linux-x86-low.c (x86_fill_gregset, x86_store_gregset)
	(x86_fill_fpregset, x86_store_fpregset, x86_fill_fpxregset)
	(x86_store_fpxregset, x86_get_pc, x86_set_pc): Change prototype to
	take a regcache.  Adjust.
	* linux-arm-low.c (arm_fill_gregset, arm_store_gregset)
	(arm_fill_wmmxregset, arm_store_wmmxregset, arm_fill_vfpregset)
	(arm_store_vfpregset, arm_get_pc, arm_set_pc):
	(arm_breakpoint_at): Change prototype to take a regcache.  Adjust.
	* linux-cris-low.c (cris_get_pc, cris_set_pc)
	(cris_cannot_fetch_register):
	(cris_breakpoint_at): Change prototype to take a regcache.
	Adjust.
	* linux-crisv32-low.c (cris_get_pc, cris_set_pc,
	cris_reinsert_addr, cris_write_data_breakpoint): Change prototype
	to take a regcache.  Adjust.
	(cris_breakpoint_at, cris_insert_point, cris_remove_point):
	Adjust.
	* linux-m32r-low.c (m32r_get_pc, m32r_set_pc): Change prototype to
	take a regcache.  Adjust.
	* linux-m68k-low.c (m68k_fill_gregset, m68k_store_gregset)
	(m68k_fill_fpregset, m68k_store_fpregset, m68k_get_pc,
	(m68k_set_pc): Change prototype to take a regcache.  Adjust.
	* linux-mips-low.c (mips_get_pc):
	(mips_set_pc): Change prototype to take a regcache.  Adjust.
	(mips_reinsert_addr): Adjust.
	(mips_collect_register): Change prototype to take a regcache.
	Adjust.
	(mips_supply_register):
	(mips_collect_register_32bit, mips_supply_register_32bit)
	(mips_fill_gregset, mips_store_gregset, mips_fill_fpregset)
	(mips_store_fpregset): Ditto.
	* linux-ppc-low.c (ppc_supply_ptrace_register, ppc_supply_ptrace_register):
	Ditto.
	(parse_spufs_run): Adjust.
	(ppc_get_pc, ppc_set_pc, ppc_fill_gregset, ppc_fill_vsxregset)
	(ppc_store_vsxregset, ppc_fill_vrregset, ppc_store_vrregset)
	(ppc_fill_evrregset, ppc_store_evrregset): Change prototype to
	take a regcache.  Adjust.
	* linux-s390-low.c (s390_collect_ptrace_register)
	(s390_supply_ptrace_register, s390_fill_gregset, s390_get_pc)
	(s390_set_pc): Change prototype to take a regcache.  Adjust.
	(s390_arch_setup): Adjust.
	* linux-sh-low.c (sh_get_pc, sh_breakpoint_at)
	(sh_fill_gregset): Change prototype to take a regcache.  Adjust.
	* linux-sparc-low.c (sparc_fill_gregset_to_stack)
	(sparc_fill_gregset, sparc_store_gregset_from_stack)
	(sparc_store_gregset, sparc_get_pc): Change prototype to take a
	regcache.  Adjust.
	(sparc_breakpoint_at): Adjust.
	* linux-xtensa-low.c (xtensa_fill_gregset):
	(xtensa_store_gregset):
	(xtensa_fill_xtregset, xtensa_store_xtregset, xtensa_get_pc)
	(xtensa_set_pc): Change prototype to take a regcache.  Adjust.
	* nto-low.c (nto_fetch_registers, nto_store_registers): Change
	prototype to take a regcache.  Adjust.
	* win32-arm-low.c (arm_fetch_inferior_register)
	(arm_store_inferior_register): Change prototype to take a
	regcache.  Adjust.
	* win32-i386-low.c (i386_fetch_inferior_register)
	(i386_store_inferior_register): Change prototype to take a
	regcache.  Adjust.
	* win32-low.c (child_fetch_inferior_registers)
	(child_store_inferior_registers): Change prototype to take a
	regcache.  Adjust.
	(win32_wait): Adjust.
	(win32_fetch_inferior_registers): Change prototype to take a
	regcache.  Adjust.
	(win32_store_inferior_registers): Adjust.
	* win32-low.h (struct win32_target_ops) <fetch_inferior_register,
	store_inferior_register>: Change prototype to take a regcache.
@
text
@d95 1
d111 76
a192 3
#if defined(F_SETFL) && defined (FASYNC)
  int save_fcntl_flags;
#endif
a259 1
#endif /* USE_WIN32API */
d262 6
a276 1
      int tmp_desc;
d293 2
a294 2
      tmp_desc = socket (PF_INET, SOCK_STREAM, IPPROTO_TCP);
      if (tmp_desc < 0)
d299 1
a299 1
      setsockopt (tmp_desc, SOL_SOCKET, SO_REUSEADDR, (char *) &tmp,
d306 2
a307 2
      if (bind (tmp_desc, (struct sockaddr *) &sockaddr, sizeof (sockaddr))
	  || listen (tmp_desc, 1))
d315 1
a315 1
	  if (getsockname (tmp_desc, (struct sockaddr *) &sockaddr, &len) < 0
d324 2
a325 29
      tmp = sizeof (sockaddr);
      remote_desc = accept (tmp_desc, (struct sockaddr *) &sockaddr, &tmp);
      if (remote_desc == -1)
	perror_with_name ("Accept failed");

      /* Enable TCP keep alive process. */
      tmp = 1;
      setsockopt (remote_desc, SOL_SOCKET, SO_KEEPALIVE,
		  (char *) &tmp, sizeof (tmp));

      /* Tell TCP not to delay small packets.  This greatly speeds up
	 interactive response. */
      tmp = 1;
      setsockopt (remote_desc, IPPROTO_TCP, TCP_NODELAY,
		  (char *) &tmp, sizeof (tmp));


#ifndef USE_WIN32API
      close (tmp_desc);		/* No longer need this */

      signal (SIGPIPE, SIG_IGN);	/* If we don't do this, then gdbserver simply
					   exits when the remote side dies.  */
#else
      closesocket (tmp_desc);	/* No longer need this */
#endif

      /* Convert IP address to string.  */
      fprintf (stderr, "Remote debugging from host %s\n",
	       inet_ntoa (sockaddr.sin_addr));
a328 11

#if defined(F_SETFL) && defined (FASYNC)
  save_fcntl_flags = fcntl (remote_desc, F_GETFL, 0);
  fcntl (remote_desc, F_SETFL, save_fcntl_flags | FASYNC);
#if defined (F_SETOWN)
  fcntl (remote_desc, F_SETOWN, getpid ());
#endif
#endif

  /* Register the event loop handler.  */
  add_file_handler (remote_desc, handle_serial_event, NULL);
d341 1
@


1.70
log
@	Implement core awareness.

	* bcache.c (compare_ints): Remove
	(print_percentage): Use compare_positive_ints.
	* defs.h (compare_positive_ints): Declare.
	* linux-nat.h (struct lin_lwp): New field core.
	(linux_nat_core_of_thread_1): Declare.
	* linux-nat.c (add_lwp): Init the 'core' field.
	(linux_nat_wait_1): Record the core.
	(linux_nat_core_of_thread_1, linux_nat_core_of_thread): New.
	(linux_nat_add_target): Register the above.
	* linux-thread-db.c (update_thread_core): New.
	(thread_db_find_new_threads): Update core information for
	every thread.
	* remote.c (struct private_thread_info): New.
	(free_private_thread_info, demand_private_info): New.
	(PACKET_qXfer_threads, use_osdata_threads): New.
	(struct thread_item, threads_parsing_context
	(start_thread, end_thread, thread_attributes)
	(thread_children, threads_children, threads_elements): New.
	(remote_threads_info): Try qXfer:threads before anything
	else.
	(remote_protocol_packets): Register qXfer:threads.
	(remote_open_1): Init use_osdata_threads.
	(struct stop_reply): New field 'core'.
	(remote_parse_stop_reply): Parse core number.
	(process_stop_reply): Record core number.
	(remote_xfer_partial): Handle qXfer:threads.
	(remote_core_of_thread): New.
	(init_remote_ops): Register remote_core_of_thread.
	(_initialize_remote): Register qXfer:read.
	* target.c (target_core_of_thread): New
	* target.h (enum target_object): New value TARGET_OBJECT_THREADS.
	(struct target_ops): New field to_core_of_threads.
	(target_core_of_thread): Declare.
	* gdbthread.h (struct thread_info): New field private_dtor.
	* thread.c (print_thread_info): Report the core.
	* ui-out.c (MAX_UI_OUT_LEVELS): Increase.
	* utils.c (compare_positive_ints): New.
	* features/threads.dtd: New.
	* mi/mi-interp.c (mi_on_normal_stop): Report the core.
	* mi/mi-main.c (struct collect_cores_data, collect_cores)
	(do_nothing, free_vector_of_osdata_items)
	(splay_tree_int_comparator, free_splay_tree): New.
	(print_one_inferior_data): Implemented printing of selected
	inferiors.  Collect and print cores.
	(output_cores): New.
	(mi_cmd_list_thread_groups): Support --recurse.  Permit specifying
	thread groups together with --available.
@
text
@d1056 1
a1056 1
outreg (int regno, char *buf)
d1065 1
a1065 1
  collect_register_as_string (regno, buf);
d1119 1
d1130 2
d1154 1
a1154 1
	    buf = outreg (find_regno (*regp), buf);
@


1.69
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d1173 1
d1183 11
d1619 10
@


1.68
log
@	Adding Neutrino gdbserver.
	* configure: Regenerated.
	* configure.ac: Add case for srv_qnx and set LIBS accordingly.
	* configure.srv (i[34567]86-*-nto*): New target.
	* nto-low.c, nto-low.h, nto-x86-low.c: New files.
	* remote-utils.c [__QNX__]: Include sys/iomgr.h
	(nto_comctrl) [__QNX__]: New function.
	(enable_async_io, disable_async_io) [__QNX__]: Call nto_comctrl.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
@


1.67
log
@gdb:
	Global renaming of find_thread_pid to find_thread_ptid.
	* gdbthread.h (find_thread_ptid): Renamed from find_thread_pid.
	* thread.c (find_thread_ptid): Renamed from find_thread_pid.
	All callers updated.
gdbserver:
	Global renaming of find_thread_pid to find_thread_ptid.
	* server.h (find_thread_ptid): Renamed from find_thread_pid.
	* inferiors.c (find_thread_ptid): Renamed from find_thread_pid.
	All callers updated.
@
text
@d69 4
d821 22
d857 3
d873 4
@


1.66
log
@	* remote-utils.c (prepare_resume_reply): Null-terminate packet.
	* spu-low.c (current_tid): Rename to ...
	(current_ptid): ... this.
	(fetch_ppc_register, fetch_ppc_memory, store_ppc_memory,
	spu_proc_xfer_spu, spu_resume, spu_request_interrupt): Use
	ptid_get_lwp (current_ptid) instead of current_tid.
	(spu_kill, spu_detach, spu_join, spu_wait): Use pid argument
	instead of current_tid.  Use find_process_pid to verify pid
	argument is valid.  Pass proper argument to remove_process.
	(spu_thread_alive): Compare current_ptid instead of current_tid.
	(spu_resume): Likewise.
@
text
@d1094 1
a1094 1
	current_inferior = find_thread_pid (ptid);
@


1.65
log
@2009-04-01  Pedro Alves  <pedro@@codesourcery.com>

	Implement the multiprocess extensions, and add linux multiprocess
	support.

	* server.h (ULONGEST): Declare.
	(struct ptid, ptid_t): New.
	(minus_one_ptid, null_ptid): Declare.
	(ptid_build, pid_to_ptid, ptid_get_pid, ptid_get_lwp)
	(ptid_get_tid, ptid_equal, ptid_is_pid): Declare.
	(struct inferior_list_entry): Change `id' type from unsigned from
	to ptid_t.
	(struct sym_cache, struct breakpoint, struct
	process_info_private): Forward declare.
	(struct process_info): Declare.
	(current_process): Declare.
	(all_processes): Declare.
	(initialize_inferiors): Declare.
	(add_thread): Adjust to use ptid_t.
	(thread_id_to_gdb_id, thread_to_gdb_id, gdb_id_to_thread_id): Ditto.
	(add_process, remove_process, find_thread_pid): Declare.
	(find_inferior_id): Adjust to use ptid_t.
	(cont_thread, general_thread, step_thread): Change type to ptid_t.
	(multi_process): Declare.
	(push_event): Adjust to use ptid_t.
	(read_ptid, write_ptid): Declare.
	(prepare_resume_reply): Adjust to use ptid_t.
	(clear_symbol_cache): Declare.
	* inferiors.c (all_processes): New.
	(null_ptid, minus_one_ptid): New.
	(ptid_build, pid_to_ptid, ptid_get_pid, ptid_get_lwp)
	(ptid_get_tid, ptid_equal, ptid_is_pid): New.
	(add_thread): Change unsigned long to ptid.  Remove gdb_id
	parameter.  Adjust.
	(thread_id_to_gdb_id, thread_to_gdb_id): Change unsigned long to ptid.
	(gdb_id_to_thread): Rename to ...
	(find_thread_pid): ... this.  Change unsigned long to ptid.
	(gdb_id_to_thread_id, find_inferior_id): Change unsigned long to ptid.
	(loaded_dll, pull_pid_from_list): Adjust.
	(add_process, remove_process, find_process_pid)
	(get_thread_process, current_process, initialize_inferiors): New.
	* target.h (struct thread_resume) <thread>: Change type to ptid_t.
	(struct target_waitstatus) <related_pid>: Ditto.
	(struct target_ops) <kill, detach>: Add `pid' argument.  Change
	return type to int.
	(struct target_ops) <join>: Add `pid' argument.
	(struct target_ops) <thread_alive>: Change pid's type to ptid_t.
	(struct target_ops) <wait>: Add `ptid' field.  Change return type
	to ptid.
	(kill_inferior, detach_inferior, join_inferior): Add `pid' argument.
	(mywait): Add `ptid' argument.  Change return type to ptid_t.
	(target_pid_to_str): Declare.
	* target.c (set_desired_inferior): Adjust to use ptids.
	(mywait): Add new `ptid' argument.  Adjust.
	(target_pid_to_str): New.
	* mem-break.h (free_all_breakpoints): Declare.
	* mem-break.c (breakpoints): Delelete.
	(set_breakpoint_at, delete_breakpoint, find_breakpoint_at)
	(check_mem_read, check_mem_write, delete_all_breakpoints): Adjust
	to use per-process breakpoint list.
	(free_all_breakpoints): New.
	* remote-utils.c (struct sym_cache) <name>: Drop `const'.
	(symbol_cache, all_symbols_looked_up): Delete.
	(hexchars): New.
	(ishex, unpack_varlen_hex, write_ptid, hex_or_minus_one,
	read_ptid): New.
	(prepare_resume_reply): Change ptid argument's type from unsigned
	long to ptid_t.  Adjust.  Implement W;process and X;process.
	(free_sym_cache, clear_symbol_cache): New.
	(look_up_one_symbol): Adjust to per-process symbol cache.  *
	* server.c (cont_thread, general_thread, step_thread): Change type
	to ptid_t.
	(attached): Delete.
	(multi_process): New.
	(last_ptid): Change type to ptid_t.
	(struct vstop_notif) <ptid>: Change type to ptid_t.
	(queue_stop_reply, push_event): Change `ptid' argument's type to
	ptid_t.
	(discard_queued_stop_replies): Add `pid' argument.
	(start_inferior): Adjust to use ptids.  Adjust to mywait interface
	changes.  Don't reference the `attached' global.
	(attach_inferior): Adjust to mywait interface changes.
	(handle_query): Adjust to use ptids.  Parse GDB's qSupported
	features.  Handle and report "multiprocess+".  Handle
	"qAttached:PID".
	(handle_v_cont): Adjust to use ptids.  Adjust to mywait interface
	changes.
	(handle_v_kill): New.
	(handle_v_stopped): Adjust to use target_pid_to_str.
	(handle_v_requests): Allow multiple attaches and runs when
	multiprocess extensions are in effect.  Handle "vKill".
	(myresume): Adjust to use ptids.
	(queue_stop_reply_callback): Add `arg' parameter.  Handle it.
	(handle_status): Adjust to discard_queued_stop_replies interface
	change.
	(first_thread_of, kill_inferior_callback)
	(detach_or_kill_inferior_callback, join_inferiors_callback): New.
	(main): Call initialize_inferiors.  Adjust to use ptids, killing
	and detaching from all inferiors.  Handle multiprocess packet
	variants.
	* linux-low.h: Include gdb_proc_service.h.
	(struct process_info_private): New.
	(struct linux_target_ops) <pid_of>: Use ptid_get_pid.
	<lwpid_of>: Use ptid_get_lwp.
	(get_lwp_thread): Adjust.
	(struct lwp_info): Add `dead' member.
	(find_lwp_pid): Declare.
	* linux-low.c (thread_db_active): Delete.
	(new_inferior): Adjust comment.
	(inferior_pid): Delete.
	(linux_add_process): New.
	(handle_extended_wait): Adjust.
	(add_lwp): Change unsigned long to ptid.
	(linux_create_inferior): Add process to processes table.  Adjust
	to use ptids.  Don't set new_inferior here.
	(linux_attach_lwp): Rename to ...
	(linux_attach_lwp_1): ... this.  Add `initial' argument.  Handle
	it.  Adjust to use ptids.
	(linux_attach_lwp): New.
	(linux_attach): Add process to processes table.  Don't set
	new_inferior here.
	(struct counter): New.
	(second_thread_of_pid_p, last_thread_of_process_p): New.
	(linux_kill_one_lwp): Add `args' parameter.  Handle it.  Adjust to
	multiple processes.
	(linux_kill): Add `pid' argument.  Handle it.  Adjust to multiple
	processes.  Remove process from process table.
	(linux_detach_one_lwp): Add `args' parameter.  Handle it.  Adjust
	to multiple processes.
	(any_thread_of): New.
	(linux_detach): Add `pid' argument, and handle it.  Remove process
	from processes table.
	(linux_join): Add `pid' argument.  Handle it.
	(linux_thread_alive): Change unsighed long argument to ptid_t.
	Consider dead lwps as not being alive.
	(status_pending_p): Rename `dummy' argument to `arg'.  Filter out
	threads we're not interested in.
	(same_lwp, find_lwp_pid): New.
	(linux_wait_for_lwp): Change `pid' argument's type from int to
	ptid_t.  Adjust.
	(linux_wait_for_event): Rename to ...
	(linux_wait_for_event_1): ... this.  Change `pid' argument's type
	from int to ptid_t.  Adjust.
	(linux_wait_for_event): New.
	(linux_wait_1): Add `ptid' argument.  Change return type to
	ptid_t.  Adjust.  Use last_thread_of_process_p.  Remove processes
	that exit from the process table.
	(linux_wait): Add `ptid' argument.  Change return type to ptid_t.
	Adjust.
	(mark_lwp_dead): New.
	(wait_for_sigstop): Adjust to use ptids.  If a process exits while
	stopping all threads, mark its main lwp as dead.
	(linux_set_resume_request, linux_resume_one_thread): Adjust to use
	ptids.
	(fetch_register, usr_store_inferior_registers)
	(regsets_fetch_inferior_registers)
	(regsets_store_inferior_registers, linux_read_memory)
	(linux_write_memory): Inline `inferior_pid'.
	(linux_look_up_symbols): Adjust to use per-process
	`thread_db_active'.
	(linux_request_interrupt): Adjust to use ptids.
	(linux_read_auxv): Inline `inferior_pid'.
	(initialize_low): Don't reference thread_db_active.
	* gdb_proc_service.h (struct ps_prochandle) <pid>: Remove.
	* proc-service.c (ps_lgetregs): Use find_lwp_pid.
	(ps_getpid): Return the pid of the current inferior.
	* thread-db.c (proc_handle, thread_agent): Delete.
	(thread_db_create_event, thread_db_enable_reporting): Adjust to
	per-process data.
	(find_one_thread): Change argument type to ptid_t.  Adjust to
	per-process data.
	(maybe_attach_thread): Adjust to per-process data and ptids.
	(thread_db_find_new_threads): Ditto.
	(thread_db_init): Ditto.
	* spu-low.c (spu_create_inferior, spu_attach): Add process to
	processes table.  Adjust to use ptids.
	(spu_kill, spu_detach): Adjust interface.  Remove process from
	processes table.
	(spu_join, spu_thread_alive): Adjust interface.
	(spu_wait): Adjust interface.  Remove process from processes
	table.  Adjust to use ptids.
	* win32-low.c (current_inferior_tid): Delete.
	(current_inferior_ptid): New.
	(debug_event_ptid): New.
	(thread_rec): Take a ptid.  Adjust.
	(child_add_thread): Add `pid' argument.  Adjust to use ptids.
	(child_delete_thread): Ditto.
	(do_initial_child_stuff): Add `attached' argument.  Add process to
	processes table.
	(child_fetch_inferior_registers, child_store_inferior_registers):
	Adjust.
	(win32_create_inferior): Pass 0 to do_initial_child_stuff.
	(win32_attach): Pass 1 to do_initial_child_stuff.
	(win32_kill): Adjust interface.  Remove process from processes
	table.
	(win32_detach): Ditto.
	(win32_join): Adjust interface.
	(win32_thread_alive): Take a ptid.
	(win32_resume): Adjust to use ptids.
	(get_child_debug_event): Ditto.
	(win32_wait): Adjust interface.  Remove exiting process from
	processes table.
@
text
@d1121 1
@


1.64
log
@	Non-stop mode support.

	* server.h (non_stop): Declare.
	(gdb_client_data, handler_func): Declare.
	(delete_file_handler, add_file_handler, start_event_loop):
	Declare.
	(handle_serial_event, handle_target_event, push_event)
	(putpkt_notif): Declare.
	* target.h (enum resume_kind): New.
	(struct thread_resume): Replace `step' field by `kind' field.
	(TARGET_WNOHANG): Define.
	(struct target_ops) <wait>: Add `options' argument.
	<supports_non_stop, async, start_non_stop>: New fields.
	(target_supports_non_stop, target_async): New.
	(start_non_stop): Declare.
	(mywait): Add `options' argument.
	* target.c (mywait): Add `options' argument.  Print child exit
	notifications here.
	(start_non_stop): New.
	* server.c (non_stop, own_buf, mem_buf): New globals.
	(struct vstop_notif): New.
	(notif_queue): New global.
	(queue_stop_reply, push_event, discard_queued_stop_replies)
	(send_next_stop_reply): New.
	(start_inferior): Adjust to use resume_kind.  Adjust to mywait
	interface changes.
	(attach_inferior): In non-stop mode, don't wait for the target
	here.
	(handle_general_set): Handle QNonStop.
	(handle_query): When handling qC, return the current general
	thread, instead of the first thread of the list.
	(handle_query): If the backend supports non-stop mode, include
	QNonStop+ in the qSupported query response.
	(handle_v_cont): Adjust to use resume_kind.  Handle resume_stop
	and non-stop mode.
	(handle_v_attach, handle_v_run): Handle non-stop mode.
	(handle_v_stopped): New.
	(handle_v_requests): Report support for vCont;t.  Handle vStopped.
	(myresume): Adjust to use resume_kind.  Handle non-stop.
	(queue_stop_reply_callback): New.
	(handle_status): Handle non-stop mode.
	(main): Clear non_stop flag on reconnection.  Use the event-loop.
	Refactor serial protocol handling from here ...
	(process_serial_event): ... to this new function.  When GDB
	selects any thread, select one here.  In non-stop mode, wait until
	GDB acks all pending events before exiting.
	(handle_serial_event, handle_target_event): New.
	* remote-utils.c (remote_open): Install remote_desc in the event
	loop.
	(remote_close): Remove remote_desc from the event loop.
	(putpkt_binary): Rename to...
	(putpkt_binary_1): ... this.  Add `is_notic' argument.  Handle it.
	(putpkt_binary): New as wrapper around putpkt_binary_1.
	(putpkt_notif): New.
	(prepare_resume_reply): In non-stop mode, don't change the
	general_thread.
	* event-loop.c: New.
	* Makefile.in (OBJ): Add event-loop.o.
	(event-loop.o): New rule.

	* linux-low.h (pid_of): Moved here.
	(lwpid_of): New.
	(get_lwp_thread): Use lwpid_of.
	(struct lwp_info): Delete `lwpid' field.  Add `suspended' field.
	* linux-low.c (pid_of): Delete.
	(inferior_pid): Use lwpid_of.
	(linux_event_pipe): New.
	(target_is_async_p): New.
	(delete_lwp): New.
	(handle_extended_wait): Use lwpid_of.
	(add_lwp): Don't set lwpid field.
	(linux_attach_lwp): Adjust debug output.  Use lwpid_of.
	(linux_kill_one_lwp): If killing a running lwp, stop it first.
	Use lwpid_of.  Adjust to linux_wait_for_event interface changes.
	(linux_detach_one_lwp): If detaching from a running lwp, stop it
	first.  Adjust to linux_wait_for_event interface changes.  Use
	lwpid_of.
	(linux_detach): Don't delete the main lwp here.
	(linux_join): Use my_waitpid.  Avoid signal_pid.  Use lwpid_of.
	(status_pending_p): Don't consider explicitly suspended lwps.
	(linux_wait_for_lwp): Take an integer pid instead of a lwp_info
	pointer.  Add OPTIONS argument.  Change return type to int.  Use
	my_waitpid instead of sleeping.  Handle WNOHANG.  Use lwpid_of.
	(linux_wait_for_event): Take an integer pid instead of a lwp_info
	pointer.  Add status pointer argument.  Return a pid instead of a
	status.  Use lwpid_of.  Adjust to linux_wait_for_lwp interface
	changes.  In non-stop mode, don't switch to a random thread.
	(linux_wait): Rename to...
	(linux_wait_1): ... this.  Add target_options argument, and handle
	it.  Adjust to use resume_kind.  Use lwpid_of.  In non-stop mode,
	don't handle the continue thread.  Handle TARGET_WNOHANG.  Merge
	clean exit and signal exit code.  Don't stop all threads in
	non-stop mode.  In all-stop mode, only stop all threads when
	reporting a stop to GDB.  Handle explicit thread stop requests.
	(async_file_flush, async_file_mark): New.
	(linux_wait): New.
	(send_sigstop): Use lwpid_of.
	(wait_for_sigstop): Use lwpid_of.  Adjust to linux_wait_for_event
	interface changes.  In non-stop mode, don't switch to a random
	thread.
	(linux_resume_one_lwp): Use lwpid_of.
	(linux_continue_one_thread, linux_queue_one_thread): Merge into ...
	(linux_resume_one_thread): ... this.  Handle resume_stop.  In
	non-stop mode, don't look for pending flag in all threads.
	(resume_status_pending_p): Don't consider explicitly suspended
	threads.
	(my_waitpid): Reimplement.  Emulate __WALL.
	(linux_request_interrupt, linux_read_offsets, linux_xfer_siginfo):
	Use lwpid_of.
	(sigchld_handler, linux_supports_non_stop, linux_async)
	(linux_start_non_stop): New.
	(linux_target_ops): Register linux_supports_non_stop, linux_async
	and linux_start_non_stop.
	(initialize_low): Install SIGCHLD handler.
	* thread-db.c (thread_db_create_event, find_one_thread)
	(thread_db_get_tls_address): Use lwpid_of.
	* win32-low.c (win32_detach): Adjust to use resume_kind.
	(win32_wait): Add `options' argument.
	* spu-low.c (spu_resume): Adjust to use resume_kind.
	(spu_wait): Add `options' argument.
@
text
@d82 1
a82 1
  const char *name;
a86 7
/* The symbol cache.  */
static struct sym_cache *symbol_cache;

/* If this flag has been set, assume cache misses are
   failures.  */
int all_symbols_looked_up;

d313 23
d542 97
d1073 1
a1073 1
prepare_resume_reply (char *buf, unsigned long ptid,
d1077 2
a1078 2
    fprintf (stderr, "Writing resume reply for %lu:%d\n\n",
	     ptid, status->kind);
d1094 1
a1094 1
	current_inferior = gdb_id_to_thread (ptid);
d1137 1
a1137 1
	    if (1 || general_thread != ptid)
d1143 4
a1146 1
		sprintf (buf, "thread:%lx;", ptid);
d1162 5
a1166 1
      sprintf (buf, "W%02x", status->value.integer);
d1169 5
a1173 1
      sprintf (buf, "X%02x", status->value.sig);
d1301 25
d1335 3
d1340 1
a1340 1
  for (sym = symbol_cache; sym; sym = sym->next)
d1352 1
a1352 1
  if (all_symbols_looked_up)
d1412 2
a1413 2
  sym->next = symbol_cache;
  symbol_cache = sym;
@


1.63
log
@	Decouple target code from remote protocol.

	* target.h (enum target_waitkind): New.
	(struct target_waitstatus): New.
	(struct target_ops) <wait>: Return an unsigned long.  Take a
	target_waitstatus pointer instead of a char pointer.
	(mywait): Likewise.
	* target.c (mywait): Change prototype to return an unsigned long.
	Take a target_waitstatus pointer instead of a char pointer.  Adjust.
	* server.h (thread_from_wait, old_thread_from_wait): Delete
	declarations.
	(prepare_resume_reply): Change prototype to take a
	target_waitstatus.
	* server.c (thread_from_wait, old_thread_from_wait): Delete.
	(last_status, last_ptid): New.
	(start_inferior): Remove "statusptr" argument.  Adjust.  Return a
	pid instead of a signal.
	(attach_inferior): Remove "status" and "signal" parameters.
	Adjust.
	(handle_query): For qGetTLSAddr, parse the thread id with strtol,
	not as an address.
	(handle_v_cont, handle_v_attach, handle_v_run, handle_v_kill)
	(handle_v_requests, myresume): Remove "status" and "signal"
	parameters.  Adjust.
	(handle_status): New.
	(main): Delete local `status'.  Adjust.
	* remote-utils.c: Include target.h.
	(prepare_resume_reply): Change prototype to take a
	target_waitstatus.  Adjust.

	* linux-low.c (linux_wait): Adjust to new target_ops->wait
	interface.
	* spu-low.c (spu_wait): Adjust.
	* win32-low.c (enum target_waitkind, struct target_waitstatus):
	Delete.
	(win32_wait): Adjust.
@
text
@d289 3
d297 2
d530 2
a531 2
int
putpkt_binary (char *buf, int cnt)
d545 4
a548 1
  *p++ = '$';
d572 1
a572 1
      if (noack_mode)
d577 4
a580 1
	      fprintf (stderr, "putpkt (\"%s\"); [noack mode]\n", buf2);
d619 6
d635 6
d1026 4
a1029 1
		general_thread = ptid;
@


1.62
log
@	* i387-fp.c, linux-arm-low.c, linux-cris-low.c,
	linux-crisv32-low.c, linux-i386-low.c, linux-low.c,
	linux-mips-low.c, linux-s390-low.c, linux-sparc-low.c,
	linux-x86-64-low.c, linux-xtensa-low.c, proc-service.c,
	regcache.c, remote-utils.c, server.c, spu-low.c, target.h,
	thread-db.c, win32-low.c, xtensa-xtregs.c, gdbreplay.c,
	Makefile.in, configure.ac: Fix whitespace throughout.
	* configure: Regenerate.
@
text
@d23 1
d937 2
a938 1
prepare_resume_reply (char *buf, char status, unsigned char sig)
d940 3
a942 1
  int nib;
d944 6
a949 1
  *buf++ = status;
d951 2
a952 4
  nib = ((sig & 0xf0) >> 4);
  *buf++ = tohex (nib);
  nib = sig & 0x0f;
  *buf++ = tohex (nib);
d954 1
a954 3
  if (status == 'T')
    {
      const char **regp = gdbserver_expedite_regs;
d956 1
a956 5
      if (the_target->stopped_by_watchpoint != NULL
	  && (*the_target->stopped_by_watchpoint) ())
	{
	  CORE_ADDR addr;
	  int i;
d958 1
a958 2
	  strncpy (buf, "watch:", 6);
	  buf += 6;
d960 5
a964 1
	  addr = (*the_target->stopped_data_address) ();
d966 2
a967 9
	  /* Convert each byte of the address into two hexadecimal chars.
	     Note that we take sizeof (void *) instead of sizeof (addr);
	     this is to avoid sending a 64-bit address to a 32-bit GDB.  */
	  for (i = sizeof (void *) * 2; i > 0; i--)
	    {
	      *buf++ = tohex ((addr >> (i - 1) * 4) & 0xf);
	    }
	  *buf++ = ';';
	}
d969 1
a969 5
      while (*regp)
	{
	  buf = outreg (find_regno (*regp), buf);
	  regp ++;
	}
d971 8
a978 7
      /* Formerly, if the debugger had not used any thread features we would not
	 burden it with a thread status response.  This was for the benefit of
	 GDB 4.13 and older.  However, in recent GDB versions the check
	 (``if (cont_thread != 0)'') does not have the desired effect because of
	 sillyness in the way that the remote protocol handles specifying a thread.
	 Since thread support relies on qSymbol support anyway, assume GDB can handle
	 threads.  */
d980 35
a1014 3
      if (using_threads && !disable_packet_Tthread)
	{
	  unsigned int gdb_id_from_wait;
d1016 12
a1027 25
	  /* FIXME right place to set this? */
	  thread_from_wait = ((struct inferior_list_entry *)current_inferior)->id;
	  gdb_id_from_wait = thread_to_gdb_id (current_inferior);

	  if (debug_threads)
	    fprintf (stderr, "Writing resume reply for %ld\n\n", thread_from_wait);
	  /* This if (1) ought to be unnecessary.  But remote_wait in GDB
	     will claim this event belongs to inferior_ptid if we do not
	     specify a thread, and there's no way for gdbserver to know
	     what inferior_ptid is.  */
	  if (1 || old_thread_from_wait != thread_from_wait)
	    {
	      general_thread = thread_from_wait;
	      sprintf (buf, "thread:%x;", gdb_id_from_wait);
	      buf += strlen (buf);
	      old_thread_from_wait = thread_from_wait;
	    }
	}

      if (dlls_changed)
	{
	  strcpy (buf, "library:;");
	  buf += strlen (buf);
	  dlls_changed = 0;
	}
a1028 2
  /* For W and X, we're done.  */
  *buf++ = 0;
@


1.61
log
@	* remote-utils.c (getpkt): Also generate remote-debug
	information if noack_mode is set.
@
text
@d259 1
a259 1
         interactive response. */
d275 2
a276 2
      fprintf (stderr, "Remote debugging from host %s\n", 
         inet_ntoa (sockaddr.sin_addr));
d322 5
a326 5
        {
          /* Hex string is short, or of uneven length.
             Return the count that has been converted so far. */
          return i;
        }
d1201 1
a1201 1
  
d1371 15
a1385 15
         switch (*f)
           {
           case 's':
             {
               char *p;
               char *a = va_arg (ap, char *);
               buffer_grow (buffer, prev, f - prev - 1);
               p = xml_escape_text (a);
               buffer_grow_str (buffer, p);
               free (p);
               prev = f + 1;
             }
             break;
           }
         percent = 0;
@


1.60
log
@        Updated copyright notices for most files.
@
text
@d826 8
@


1.59
log
@	* utils.c (xmalloc,xcalloc,xstrdup): New fns.
	* server.h (ATTR_MALLOC): New macro.
	(xmalloc,xcalloc,xstrdup): Declare.
	* hostio.c: Replace malloc,calloc,strdup with xmalloc,xcalloc,xstrdup.
	* inferiors.c: Ditto.
	* linux-low.c: Ditto.
	* mem-break.c: Ditto.
	* regcache.c: Ditto.
	* remote-utils.c: Ditto.
	* server.c: Ditto.
	* target.c: Ditto.
	* win32-low.c: Ditto.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
@


1.58
log
@	Implement -list-thread-groups --available

        * Makefile.in (XMLFILES): Add osdata.dtd.
        (SFILES): Add osdata.c.
        (COMMON_OBS): Add osdata.o.
        * linux-nat.c: Include pwd.h, sys/types.h, gdb_dirent.h and xml-support.h.
        (linux_nat_xfer_osdata): New function.
        (linux_xfer_partial): Handle TARGET_OBJECT_OSDATA.
        * osdata.c: New file.
        * osdata.h: New file.
        * remote.c (PACKET_qXfer_osdata): New packet enum.
        (remote_protocol_features): Add "qXfer:osdata:read".
        (remote_read_qxfer): Handle TARGET_OBJECT_OSDATA.
        (extended_remote_can_run): New.
        (init_extended_remote_ops): Set to_can_run to
        extended_remote_can_run.
        (_initialize_remote): Add packet config command for
        "qXfer:osdata:read".
        * xml-support.c (obstack_xml_printf): New function.
        * xml-support.h (obstack_xml_printf): Declare.
        * target.c (target_get_osdata): New function.
        * target.h (enum target_object): Add TARGET_OBJECT_OSDATA.
        (target_os_data): Declare.
        * features/osdata.dtd: New file.
        * mi/mi-main.c (mi_list_thread_groups): Handle the --available
        option.
@
text
@d533 1
a533 1
  buf2 = malloc (PBUFSIZ);
d1181 1
a1181 1
      mem_buf = malloc (mem_len);
d1212 2
a1213 2
  sym = malloc (sizeof (*sym));
  sym->name = strdup (name);
d1224 1
a1224 1
  char *buf = malloc (strlen (msg) * 2 + 2);
d1262 1
a1262 1
  result = malloc (i + special + 1);
@


1.57
log
@gdb/doc/
2008-08-12  Sandra Loosemore  <sandra@@codesourcery.com>

	* gdb.texinfo (Remote Configuration): Document set remote noack-packet.
	(Remote Protocol): Add Packet Acknowledgment to menu.
	(Overview): Mention +/- can be disabled, and point to new section
	where this is discussed in detail.
	(General Query Packets): Document QStartNoAckMode packet, and
	corresponding qSupported reply.
	(Packet Acknowledgment): New section.

gdb/
2008-08-12  Pedro Alves  <pedro@@codesourcery.com>

	Add no-ack mode to the remote protocol --- optionally stop ACKing
	packets and responses when we have a reliable communication
	medium.

	Based on Apple's GDB, by Jason Molenda <jmolenda@@apple.com>

	* remote.c (struct remote_state): Add noack_mode field.
	(PACKET_QStartNoAckMode): New.
	(remote_start_remote): Don't any outstanding packet here.
	(remote_open_1): Clear noack_mode.  Ack any outstanding packet
	here.  Activate noack mode if requested.
	(remote_protocol_features): Add QStartNoAckMode.
	(remote_open_1):
	(putpkt_binary): Don't send ack in noack mode.
	(read_frame): Don't recompute the checksum in noack mode.
	(getpkt_sane): Skip sending ack if in noack mode.
	(_initialize_remote): Add set/show remote noack mode.
	* NEWS:  Note the new features.

gdb/gdbserver/
2008-08-12  Pedro Alves  <pedro@@codesourcery.com>

	* remote-utils.c (noack_mode, transport_is_reliable): New globals.
	(remote_open): Set or clear transport_is_reliable.
	(putpkt_binary): Don't expect acks in noack mode.
	(getpkt): Don't send ack/nac in noack mode.
	* server.c (handle_general_set): Handle QStartNoAckMode.
	(handle_query): If connected by tcp pass QStartNoAckMode+ in
	qSupported.
	(main): Reset noack_mode on every connection.
	* server.h (noack_mode): Declare.
@
text
@d1294 92
@


1.57.4.1
log
@2008-11-25  Pedro Alves  <pedro@@codesourcery.com>

	2008-10-13  Pedro Alves  <pedro@@codesourcery.com>

	* server.c (discard_pending_stop_replies): Initialize prev.

	2008-10-12  Pedro Alves  <pedro@@codesourcery.com>

	* linux-low.c (linux_wait_1): Cancel breakpoint hits in threads
	we're not reporting.
	(cancel_breakpoints_callback): New.

	2008-10-12  Pedro Alves  <pedro@@codesourcery.com>

	* server.c (queue_stop_reply_callback, handle_status): Pass
	TARGET_SIGNAL_TRAP, not TARGET_SIGNAL_0.

	* linux-low.c (ptid_is_pid): Delete.
	(linux_wait_for_event): In non-stop, don't set the current
	inferior arbitrarily.
	(linux_wait): Flush the event pipe before polling for an event.
	(wait_for_sigstop): In non-stop, don't set the current
	inferior arbitrarily.
	(linux_resume_one_lwp): Small cleanup.
	(cancel_breakpoint): New.
	(linux_resume_one_thread): Use it.  Still report SIGTRAPs.
	(regsets_store_inferior_registers): Plug leak.
	(sigchld_handler): Don't use fprintf here.

	* mem-break.c (breakpoint_at): New.
	* inferiors.c (ptid_is_pid): New.
	* mem-break.h (breakpoint_at): Declare.
	* server.c (discard_queued_stop_replies): Add `pid' argument.
	Handle it.
	(send_next_stop_reply): Cleanup.
	(attach_inferior): Don't wait here in non-stop mode.
	(handle_v_attach): Don't queue stop replies here.
	(handle_v_kill): Discard queued stop replies of the inferior we
	just killed.
	(queue_stop_reply_callback): Add `arg' argument.  Handle it.
	(handle_status): Adjust.
	(kill_inferior_callback): Discard queued stop replies of the
	inferior we just killed.
	(detach_or_kill_inferior_callback): Discard queued stop replies of
	the inferior we just killed or detached from.
	(process_serial_event): Cleanup.  Discard queued stop replies of
	the inferior we just detached.  Don't write 0 bytes to the inferior.
	(handle_serial_event): Debug output.
	* server.h (ptid_is_pid): Declare.

	* remote-utils.c (prepare_resume_reply): Avoid reading registers
	and memory from a thread that is gone.

	2008-09-26  Pedro Alves  <pedro@@codesourcery.com>

	* server.h (struct sym_cache, struct process_info_private):
	Forward declare.
	(struct process_info): Add symbol_cache, all_symbols_looked_up and
	private fields.
	(current_process): Declare.
	* remote-utils.c (struct sym_cache) <name>: Remove constness.
	(symbol_cache): Delete.
	(free_sym_cache, clear_symbol_cache): New.
	(look_up_one_symbol): Adjust, to per-process symbol cache.
	* inferiors.c (current_process): New.

	* linux-low.h: Include "gdb_proc_service.h".
	(struct process_info_private): Define.
	* linux-low.c (thread_db_active): Delete.
	(linux_add_process): New.
	(handle_extended_wait, linux_create_inferior, linux_attach): Use
	it.
	(linux_wait_for_event, linux_look_up_symbols): Adjust.
	(initialize_low): Don't clear the global thread_db_active.
	* thread-db.c (proc_handle, thread_agent): Delete.
	(fixup_proc_handle): New.
	(thread_db_err_str, thread_db_enable_reporting): Use it.  Adjust.
	(thread_db_find_new_threads): Look for the current inferior
	thread, not the first thread in the list.  Use fixup_proc_handle.
	Adjust.
	(thread_db_get_tls_address): Use fixup_proc_handle.
	(thread_db_init): Likewise.  Adjust.

	2008-09-26  Pedro Alves  <pedro@@codesourcery.com>

	* mem-break.c (get_breakpoint_list): Add `create' argument.  Only
	create the list if create is set.
	(remove_breakpoint_list): New.
	(set_breakpoint_at, find_breakpoint_at, check_mem_read)
	(check_mem_write, delete_all_breakpoints): Adjust.

	2008-09-26  Pedro Alves  <pedro@@codesourcery.com>

	* server.c (gdbserver_usage): Describe --remote-debug option.
	(main): Handle --remote-debug switch.

	2008-09-19  Pedro Alves  <pedro@@codesourcery.com>

	Non-stop mode support.

	* linux-low.c (linux_event_pipe): New int array for pipe.
	(target_is_async_p): New.
	(handle_extended_wait): Use my_waitpid.
	(linux_kill_one_lwp): Stop the LWP if it is not stopped already.
	Use my_waitpid, not linux_wait_for_event.  Remove the lwp and the
	corresponding thread from the lists.
	(linux_kill_one_process, linux_kill): Delete.
	(linux_kill_1): Rename back to ...
	(linux_kill) ... this.  Stop the LWP if it is not stopped already.
	Use my_waitpid, not linux_wait_for_event.  Remove the lwp and the
	corresponding thread from the lists.
	(linux_detach_one_lwp): Make sure the LWP is stopped.  Adjust to
	new linux_wait_for_event interface.
	(linux_detach_one_process, linux_detach): Delete.
	(linux_detach_1): Rename back to ...
	(linux_detach): This.
	(linux_join): Add PID argument.  Use my_waitpid instead of
	waitpid.
	(status_pending_p): Ignore suspended threads.
	(my_waitpid): Emulate __WALL.
	(linux_wait_for_lwp): Add 'options' argument.  Handle it.  Use
	my_wait.  If requesting an event from a specific process, leave
	events in other processes pending.
	(resume_stopped_lwps): New.
	(linux_wait_for_event): Delete.
	(linux_wait_for_event_1): Rename back to ...
	(linux_wait_for_event): ... this.  Change interface: add wstat and
	options arguments, return -1 on error, 0 otherwise.  Adjust.  In
	all-stop, resume stopped lwps if there was no pending status.
	Don't return immediatelly if a pending status was found ---
	continue handling it instead.  Don't loop, only handle one event.
	(linux_wait): Rename to ...
	(linux_wait_1): ... this.  Add target_options argument.  Handle
	it.  Don't loop --- only handle one event.  Ignore the continue
	thread in non_stop mode.  Adjust to new resume_kind interface.
	Only stop all threads in all-stop mode.
	(async_file_flush, async_file_mark): New.
	(linux_wait): New.
	(wait_for_sigstop): Set stopping_threads here.  Use
	linux_wait_for_lwp instead of linux_wait_for_event.  Adjust.
	(stop_all_lwps): Don't set stopping_threads here.
	(resume_ptr): Delete.
	(struct resume_info): New.
	(linux_set_resume_request): Add arg argument.  Adjust to take a
	struct remove_info instead of the global resume_ptr.  Accept
	pid,-1 to apply to all threads.
	(linux_continue_one_thread, linux_queue_one_thread): Merge both
	and create ...
	(linux_resume_one_thread): ... this.  New.  Handle rk_stop.
	(resume_status_pending_p): Assume no resume info to mean do
	nothing.  Ignore suspended LWPs.
	(linux_resume): Add n argument.  Adjust.  In non-stop mode, don't
	look for a pending status over all threads.
	(linux_read_offsets): Minor cleanup.
	(sigchld_handler, linux_async, linux_start_non_stop): New.
	(linux_target_ops): Register linux_async and linux_start_non_stop.
	(initialize_low): Register sigchld_handler as SIGCHLD handler.

	* utils.c (internal_verror, internal_error_file_line): New.

	* Makefile.in (SFILES): Add event-loop.c.
	(OBS): Add event-loop.o.
	(event-loop.o): New rule.

	* linux-low.h (struct lwp_info) <suspended>: New flag.

	* thread-db.c (thread_db_create_event): Make sure thread_db reads
	from the current inferior.
	(thread_db_get_tls_address): Comment.

	* server.c (thread_from_wait, old_thread_from_wait, attached):
	Delete.
	(non_stop): New global.
	(own_buf, mem_buf): New globals.
	(struct vstop_notif): New.
	(notif_queue): New.
	(queue_stop_reply, push_event, discard_queued_stop_replies)
	(send_next_stop_reply): New.
	(start_inferior): Adjust to new thread_resume interface.  Adjust
	to new mywait interface.
	(attach_inferior): Adjust.
	(handle_general_set): Handle QNonStop.
	(handle_query): Pass 'QNonStop+'.
	(handle_v_cont): Handle vCont;t.  Don't enable/disable async io in
	non-stop mode.  In non-stop return OK, and don't wait for the
	target.
	(handle_v_attach): In non-stop, return OK, and queue events for
	all threads.
	(handle_v_run): In non-stop, set the general thread here.
	(handle_v_stopped): New.
	(handle_v_requests): Report support for 't'.  Handle 'vStopped'.
	(proceed): Add comment.  Adjust.  In non-stop, don't
	enable/disable async io; write 'OK', and don't wait for the
	target.
	(queue_stop_reply_callback, handle_status): New.
	(kill_inferior_callback, detach_or_kill_inferior_callback)
	(join_inferiors_callback): New.
	(main): In --debug mode, also enable remote debug.  Don't pass -1
	to kill_inferior or detach_inferior; instead, iterate over all
	processes killing or detaching them.  Adjust to use the even-loop.
	(process_serial_event): New, factored out of main.  If the
	connection closed, remove all sources from the event loop.
	Iterate over all inferiors joining them.  Use handle_status.
	Don't print inferior exit notices here.  In non-stop, defer
	exiting until GDB read all queued events.
	(handle_serial_event, handle_target_event): New.

	* server.h (FOR_EACH_INFERIOR): New.
	(thread_from_wait, old_thread_from_wait): Remove.
	(non_stop): Declare.
	(gdb_client_data, handler_func): New typedefs.
	(delete_file_handler, add_file_handler, start_event_loop)
	(handle_serial_event, handle_target_event, push_event)
	(putpkt_notif, internal_error_file_line): Declare.
	(internal_error): Define.

	* target.c (mywait): Add `options' argument.  Print inferior exit
	notices here.
	(start_non_stop): New.

	* event-loop.c: New.

	* remote-utils.c (remote_open): Register remote_desc in the event
	loop, with handle_serial_event as callback.
	(remote_close): Remove remote_desc from the event loop.
	(hex_or_minus_one): New.
	(read_ptid, read_ptid): Use it.
	(putpkt_binary): Rename to ...
	(putpkt_binary_1): ... this.  Add `notif' argument.  Handle
	pushing a remote protocol notification.
	(putpkt_binary): New as wrapper around putpkt_binary_1.
	(putpkt_notif): New.
	(getpkt): Debug output.
	(prepare_resume_reply): Remove dead code.  In non-stop, don't set
	the general thread here.

	* target.h (enum resume_kind): New.
	(struct thread_resume) <leave_stopped, step>: Delete.
	(struct thread_resume) <kind>: New field.
	(TARGET_WNOHANG): Define.
	(struct target_ops) <kill, detach>: Adjust comments.
	(struct target_ops) <join>: Add `pid' argument.
	(struct target_ops) <resume>: Add `n' argument.
	(struct target_ops) <wait>: Add `options' argument.
	(struct target_ops) <async, start_non_stop>: New fields.
	(join_inferior): Add `pid' argument.
	(target_async): New.
	(start_non_stop): Declare.
	(mywait): Add options argument.

	2008-09-15  Pedro Alves  <pedro@@codesourcery.com>

	* linux-low.c (new_inferior): Mention in the comment that all
	inferiors should have the same architecture for now.
	(linux_create_inferior, linux_attach): Only set new_inferior if
	this is the first process.

	2008-08-29  Pedro Alves  <pedro@@codesourcery.com>

	* linux-low.c (ptid_is_pid): Move higher.
	(linux_wait_for_lwp): Remove dead code.
	(linux_wait_for_event): Rename to ...
	(linux_wait_for_event_1): ... this.
	(linux_wait_for_event): New.
	(ptid_same_pid): Delete.
	(linux_set_resume_request): Clearify.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* linux-low.c (handle_extended_wait, linux_attach_lwp)
	(linux_attach): Minor cleanups.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* linux-low.c (linux_thread_alive): Return false for a listed
	thread known to be dead.
	(linux_wait_for_event): Don't set the dead flag here.
	(wait_for_sigstop): Store ptid before waiting for the event.
	Minor cleanup.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* inferiors.c (find_inferior): Allow deleting the current iterated
	inferior.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* linux-low.c (linux_pid_to_exec_file): Move higher.
	(linux_enable_event_reporting): Enable PTRACE_O_TRACEEXEC.
	(handle_extended_wait): Handle PTRACE_EVENT_EXEC.

	* remote-utils.c (prepare_resume_reply): Set the general thread to
	the last thread that had an event in TARGET_WAITKIND_FORKED and
	TARGET_WAITKIND_VFORKED.  Handle TARGET_WAITKIND_EXECD.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* server.c (handle_query): Pass "QExecFile:PID;" back in the reply.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* linux-low.c (linux_supports_tracefork_flag): Move higher.
	(linux_enable_event_reporting): New.
	(handle_extended_wait): Change return type to int.  Handle
	PTRACE_EVENT_FORK and PTRACE_EVENT_VFORK.
	(add_lwp): Set waitstatus.kind to TARGET_WAITKIND_IGNORE.
	(linux_attach_lwp): Use linux_enable_event_reporting.
	(linux_wait_for_event): Don't keep waiting if the extended wait
	status should be reported to gdb.
	(linux_wait): Use linux_enable_event_reporting.  If waitstatus
	holds a processed event, return it instead.
	* remote-utils.c (prepare_resume_reply): Handle
	TARGET_WAITKIND_FORKED and TARGET_WAITKIND_VFORKED.
	* linux-low.h (struct lwp_info) <waitstatus>: New member.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* target.h (struct target_ops) <pid_to_exec_file>: New member.
	* server.c (handle_query): Handle qExecFile.
	* linux-low.c (linux_pid_to_exec_file): New.
	(linux_target_ops): Register it.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* linux-low.c (is_lwpid): New.
	(linux_kill_one_lwp, linux_kill_1, linux_detach_one_lwp): Adjust.
	(status_pending_p): Check if we're interested in this lwp.
	(linux_wait_for_lwp): Change signature: return an lwp_info*, and
	take a ptid instead of an lwp_info**.
	(linux_wait_for_event): Take a ptid instead of a thread_info
	pointer.  Adjust.
	(wait_for_sigstop): Adjust.  If a whole process died, keep the
	exit status pending.
	(ptid_is_pid, ptid_same_pid): New.
	(linux_set_resume_request): Allow resuming all threads of a process.
	(resume_status_pending_p): Check for dead lwps.

	* linux-low.h (struct lwp_info) <dead>: New field.

	* server.c (start_inferior): Only resume and wait for events from
	the inferior we're creating.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	Decouple target code from remote protocol.

	* linux-low.c (linux_wait): Change prototype.  Adjust.
	* server.c (last_status, last_ptid): New.
	(start_inferior): Remove "statusptr" argument.  Adjust.
	(attach_inferior, handle_v_cont, handle_v_attach, handle_v_run)
	(handle_v_kill, handle_v_requests): Remove "status" and "signal"
	parameters.  Adjust.
	(myresume): Rename to ...
	(proceed): ... this.  Remove "statusp" parameter.  Adjust.
	(main): Remove "status" local.  Adjust.
	* target.c (mywait): Change prototype.  Adjust.
	* target.h (enum target_waitkind): New.
	(struct target_waitstatus): New.
	(struct target_ops) <wait>: Change prototype.
	(mywait): Adjust.
	* remote-utils.c: Include "target.h".
	(prepare_resume_reply): Change prototype to take a ptid and a
	target_waitstatus.  Adjust.
	* server.h (prepare_resume_reply): Adjust prototype.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* inferiors.c (all_processes): New.
	(add_process): New.

	* linux-low.c (linux_create_inferior): Add process.
	(linux_attach_lwp): Add "initial" parameter, and use it instead of
	relying on having only one thread in the global list.
	(linux_attach): Add process.
	(struct counter): New.
	(check_if_last_thread_of_pid, is_last_thread_of_process): New.
	(linux_kill_one_lwp): Add ARGS parameter.  Change return type to
	int.  Check if we're interested in this lwp.  Use
	is_last_thread_of_process.
	(linux_kill): Rename to ...
	(linux_kill_1): ... this.  Kill lwps of the requested only.
	(linux_kill_one_process): New.
	(linux_kill): New.
	(linux_detach_one_lwp): Add ARGS parameter.  Change return type to
	int.  Check if we're interested in this lwp.  Remove the lwp from
	both the lwp list and the thread list.
	(any_thread_of, linux_detach_1, linux_detach_one_process): New.
	(linux_detach): Reimplement.
	(linux_wait_for_event): Use is_last_thread_of_process.
	(linux_wait): Likewise.  On process exit, don't clear all inferiors.
	Implement multi-process extensions.

	* mem-break.c (breakpoints): Delete.
	(struct breakpoint_list): New.
	(all_breakpoints): New.
	(get_breakpoint_list): New.
	(set_breakpoint_at, delete_breakpoint, find_breakpoint_at)
	(check_mem_read, check_mem_write, delete_all_breakpoints): Use it.

	* server.h (struct process_info): New.
	(all_processes): Declare.
	(add_process): Declare.

	* linux-low.h (linux_attach_lwp): Add "initial" parameter.

	* thread-db.c (maybe_attach_thread): Adjust.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* linux-low.c, linux-low.h, proc-service.c, thread-db.c: Rename
	`struct process_info' to `struct lwp_info', and adjust throughout.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	Implement remote protocol multi-process extensions.

	* inferiors.c (null_ptid, minus_one_ptid): New.
	(ptid_build, pid_to_ptid, ptid_get_pid, ptid_get_lwp)
	(ptid_get_tid, ptid_equal): New functions.
	(add_thread): Drop gdb_id argument.  Retype thread_id argument to
	ptid_t.  Adjust.
	(thread_id_to_gdb_id): Adjust.
	(thread_to_gdb_id): Change return type to ptid_t.  Adjust.
	(gdb_id_to_thread): Rename to ...
	(find_thread_pid): ... this.  Adjust.
	(gdb_id_to_thread_id): Change return type to ptid_t.  Adjust.
	(find_inferior_id): Change id argument type to ptid_t.  Adjust.
	(loaded_dll, add_pid_to_list, pull_pid_from_list): Adjust.
	(initialize_inferiors): New.

	* remote-utils.c (hexchars): New.
	(ishex, unpack_varlen_hex, write_ptid, read_ptid): New.
	(prepare_resume_reply): Adjust.

	* server.c (cont_thread, general_thread, step_thread)
	(thread_from_wait, old_thread_from_wait): Change type to ptid_t.
	(multi_process): New.
	(start_inferior): Adjust.
	(handle_query): Adjust.  Report multiprocess extensions support.
	(handle_v_cont): Adjust.
	(handle_v_kill): New.
	(handle_v_requests): Handle vKill.
	(myresume): Adjust.
	(first_thread_of): New.
	(main): Call initialize_inferiors.  If bailing out, kill all
	inferiors.  Handle multi-process detach.  Handle multi-process H
	and T.

	* server.h (ULONGEST): New typedef.
	(struct ptid): New struct.
	(ptid_t): New typedef.
	(minus_one_ptid, null_ptid): New.
	(ptid_t ptid_build, pid_to_ptid, ptid_get_pid, ptid_get_lwp)
	(ptid_get_tid, ptid_equal): New.
	(struct inferior_list_entry) <id>: Change type to ptid_t.
	(add_thread, thread_id_to_gdb_id, thread_to_gdb_id)
	(gdb_id_to_thread_id): Adjust prototypes.
	(find_thread_pid): Declare.
	(find_inferior_id): Adjust prototype.
	(cont_thread, general_thread, step_thread, thread_from_wait)
	(old_thread_from_wait): Adjust type to ptid_t.
	(multi_process): Declare.
	(read_ptid, write_ptid): Declare.

	* linux-low.c (pid_of): Adjust.
	(lwpid_of): New.
	(inferior_lwpid): New.
	(handle_extended_wait): Adjust.
	(add_process): Change pid argument to a ptid.  Adjust.
	(linux_create_inferior): Adjust.
	(linux_attach_lwp): Adjust.  Clear new_inferior on error.  If
	creating a new inferior, don't rely on inferior_pid, instead use
	the lwpid as pid.
	(linux_attach): Set new_inferior earlier.  Adjust.
	(linux_kill): Change return type to int.  Adjust.
	(linux_detach): Add pid parameter.
	(linux_thread_alive): Change lwpid paremeter type to ptid.
	Adjust.
	(same_lwp, find_lwp_pid): New.
	(linux_wait_for_process): Adjust.
	(linux_wait_for_process, linux_wait_for_event, send_sigstop)
	(wait_for_sigstop, linux_resume_one_process,
	(linux_resume_one_process, linux_set_resume_request)
	(linux_continue_one_thread, linux_queue_one_thread)
	(fetch_register, usr_store_inferior_registers)
	(regsets_fetch_inferior_registers)
	(regsets_store_inferior_registers, linux_read_memory)
	(linux_write_memory, linux_request_interrupt, linux_read_auxv):
	Adjust.

	* linux-low.h (get_process_thread): Adjust.
	(struct process_info) <lwpid>: Remove.
	(find_lwp_pid): Declare.

	* target.c (set_desired_inferior): Adjust.
	(target_pid_to_str): New.

	* target.h (struct thread_resume) <thread>: Change type to ptid_t.
	(struct target_ops) <kill>: Change return type to int, and take an
	int as parameter.
	(struct target_ops) <detach>: Take an int as parameter.
	(struct target_ops) <thread_alive>: Change pid argument type to
	ptid_t.
	(kill_inferior, detach_inferior): Add PID argument.

	* thread-db.c (thread_db_create_event): Adjust.
	(find_one_thread): Change argument to a ptid.  Adjust.
	(maybe_attach_thread, thread_db_get_tls_address, thread_db_init):
	Adjust.

	* proc-service.c (ps_lgetregs): Adjust.
@
text
@a22 1
#include "target.h"
d81 1
a81 1
  char *name;
d86 3
a287 3

  /* Register the event loop handler.  */
  add_file_handler (remote_desc, handle_serial_event, NULL);
a292 2
  delete_file_handler (remote_desc);

a313 23
static const char hexchars[] = "0123456789abcdef";

static int
ishex (int ch, int *val)
{
  if ((ch >= 'a') && (ch <= 'f'))
    {
      *val = ch - 'a' + 10;
      return 1;
    }
  if ((ch >= 'A') && (ch <= 'F'))
    {
      *val = ch - 'A' + 10;
      return 1;
    }
  if ((ch >= '0') && (ch <= '9'))
    {
      *val = ch - '0';
      return 1;
    }
  return 0;
}

a519 99
char *
unpack_varlen_hex (char *buff,	/* packet to parse */
		   ULONGEST *result)
{
  int nibble;
  ULONGEST retval = 0;

  while (ishex (*buff, &nibble))
    {
      buff++;
      retval = retval << 4;
      retval |= nibble & 0x0f;
    }
  *result = retval;
  return buff;
}

/* Write a PTID to BUF.  Returns BUF+CHARACTERS_WRITTEN.  */

char *
write_ptid (char *buf, ptid_t ptid)
{
  int pid, tid;

  if (multi_process)
    {
      pid = ptid_get_pid (ptid);
      if (pid < 0)
	buf += sprintf (buf, "p-%x.", -pid);
      else
	buf += sprintf (buf, "p%x.", pid);
    }
  tid = ptid_get_lwp (ptid);
  if (tid < 0)
    buf += sprintf (buf, "-%x", -tid);
  else
    buf += sprintf (buf, "%x", tid);

  return buf;
}

ULONGEST
hex_or_minus_one (char *buf, char **obuf)
{
  ULONGEST ret;

  if (strncmp (buf, "-1", 2) == 0)
    {
      ret = (ULONGEST) -1;
      buf += 2;
    }
  else
    buf = unpack_varlen_hex (buf, &ret);

  if (obuf)
    *obuf = buf;

  return ret;
}

/* Extract a PTID from BUF.  If non-null, OBUF is set to the to one
   passed the last parsed char.  Returns null_ptid on error.  */
ptid_t
read_ptid (char *buf, char **obuf)
{
  char *p = buf;
  char *pp;
  ULONGEST pid = 0, tid = 0;

  if (*p == 'p')
    {
      /* Multi-process ptid.  */
      pp = unpack_varlen_hex (p + 1, &pid);
      if (*pp != '.')
	error ("invalid remote ptid: %s\n", p);

      p = pp + 1;

      tid = hex_or_minus_one (p, &pp);

      if (obuf)
	*obuf = pp;
      /* TODO, we really need to gdbid vs target thread id after
	 all.  */
      return ptid_build (pid, tid, 0);
    }

  /* No multi-process.  Just a tid.  */
  tid = hex_or_minus_one (p, &pp);

  /* Since the stub is not sending a process id, then default to
     what's in the current inferior.  */
  pid = ptid_get_pid (((struct inferior_list_entry *) current_inferior)->id);

  if (obuf)
    *obuf = pp;
  return ptid_build (pid, tid, 0);
}

d524 2
a525 2
static int
putpkt_binary_1 (char *buf, int cnt, int is_notif)
d539 1
a539 4
  if (is_notif)
    *p++ = '%';
  else
    *p++ = '$';
d563 1
a563 1
      if (noack_mode || is_notif)
d568 1
a568 4
	      if (is_notif)
		fprintf (stderr, "putpkt (\"%s\"); [notif]\n", buf2);
	      else
		fprintf (stderr, "putpkt (\"%s\"); [noack mode]\n", buf2);
a606 6
int
putpkt_binary (char *buf, int cnt)
{
  return putpkt_binary_1 (buf, cnt, 0);
}

a616 6
int
putpkt_notif (char *buf)
{
  return putpkt_binary_1 (buf, strlen (buf), 1);
}

a825 5
  else if (remote_debug)
    {
      fprintf (stderr, "getpkt (\"%s\");  [noack mode] \n", buf);
      fflush (stderr);
    }
d928 1
a928 1
prepare_resume_reply (char *buf, ptid_t ptid, struct target_waitstatus *status)
d930 8
a937 3
  if (debug_threads)
    fprintf (stderr, "Writing resume reply for %s:%d\n\n",
	     target_pid_to_str (ptid), status->kind);
d939 1
a939 1
  switch (status->kind)
d941 7
a947 4
    case TARGET_WAITKIND_STOPPED:
      {
	struct thread_info *saved_inferior;
	const char **regp;
d949 2
a950 2
	sprintf (buf, "T%02x", status->value.sig);
	buf += strlen (buf);
d952 1
a952 1
	regp = gdbserver_expedite_regs;
d954 9
a962 71
	saved_inferior = current_inferior;

	current_inferior = find_thread_pid (ptid);

	/* Check that the thread is still alive before trying to read
	   registers or memory from it.  */
	if (current_inferior != NULL && mythread_alive (ptid))
	  {
	    if (the_target->stopped_by_watchpoint != NULL
		&& (*the_target->stopped_by_watchpoint) ())
	      {
		CORE_ADDR addr;
		int i;

		strncpy (buf, "watch:", 6);
		buf += 6;

		addr = (*the_target->stopped_data_address) ();

		/* Convert each byte of the address into two hexadecimal chars.
		   Note that we take sizeof (void *) instead of sizeof (addr);
		   this is to avoid sending a 64-bit address to a
		   32-bit GDB.  */
		for (i = sizeof (void *) * 2; i > 0; i--)
		  *buf++ = tohex ((addr >> (i - 1) * 4) & 0xf);
		*buf++ = ';';
	      }

	    while (*regp)
	      {
		buf = outreg (find_regno (*regp), buf);
		regp ++;
	      }
	  }

	/* Formerly, if the debugger had not used any thread features
	   we would not burden it with a thread status response.  This
	   was for the benefit of GDB 4.13 and older.  However, in
	   recent GDB versions the check (``if (cont_thread != 0)'')
	   does not have the desired effect because of sillyness in
	   the way that the remote protocol handles specifying a
	   thread.  Since thread support relies on qSymbol support
	   anyway, assume GDB can handle threads.  */

	if (using_threads && !disable_packet_Tthread)
	  {
	    /* This if (1) ought to be unnecessary.  But remote_wait
	       in GDB will claim this event belongs to inferior_ptid
	       if we do not specify a thread, and there's no way for
	       gdbserver to know what inferior_ptid is.  */
	    if (1 || !ptid_equal (general_thread, ptid))
	      {
		/* In non-stop, don't change the general thread behind
		   GDB's back.  */
		if (!non_stop)
		  general_thread = ptid;
		sprintf (buf, "thread:");
		buf += strlen (buf);
		buf = write_ptid (buf, ptid);
		strcat (buf, ";");
		buf += strlen (buf);
	      }
	  }

	/* FIXME: Can we make this be TARGET_WAITKIND_LOADED?  */
	if (dlls_changed)
	  {
	    strcpy (buf, "library:;");
	    buf += strlen (buf);
	    dlls_changed = 0;
	  }
d964 17
a980 20
	current_inferior = saved_inferior;
      }
      break;
    case TARGET_WAITKIND_EXITED:
      if (multi_process)
	sprintf (buf, "W%x;process:%x",
		 status->value.integer, ptid_get_pid (ptid));
      else
	sprintf (buf, "W%02x", status->value.integer);
      break;
    case TARGET_WAITKIND_SIGNALLED:
      if (multi_process)
	sprintf (buf, "X%x;process:%x",
		 status->value.sig, ptid_get_pid (ptid));
      else
	sprintf (buf, "X%02x", status->value.sig);
      break;
    case TARGET_WAITKIND_FORKED:
    case TARGET_WAITKIND_VFORKED:
      general_thread = ptid;
d982 18
a999 12
      if (status->kind == TARGET_WAITKIND_FORKED)
	sprintf (buf, "Y;fork;");
      else
	sprintf (buf, "Y;vfork;");
      buf += strlen (buf);
      buf = write_ptid (buf, ptid);
      strcat (buf, ";");
      buf += strlen (buf);
      buf = write_ptid (buf, status->value.related_pid);
      break;
    case TARGET_WAITKIND_EXECD:
      general_thread = ptid;
d1001 6
a1006 10
      sprintf (buf, "Y;exec;");
      buf += strlen (buf);
      buf = write_ptid (buf, ptid);
      strcat (buf, ";");
      buf += strlen (buf);
      hexify (buf, status->value.execd_pathname, 0);
      break;
    default:
      error ("unhandled waitkind");
      break;
d1008 2
a1131 28
static void
free_sym_cache (struct sym_cache *sym)
{
  if (sym != NULL)
    {
      free (sym->name);
      free (sym);
    }
}

void
clear_symbol_cache (void)
{
  struct process_info *proc;
  struct sym_cache *sym, *next;

  proc = current_process ();

  /* Check the cache first.  */
  for (sym = proc->symbol_cache; sym; sym = next)
    {
      next = sym->next;
      free_sym_cache (sym);
    }

  proc->symbol_cache = NULL;
}

a1140 3
  struct process_info *proc;

  proc = current_process ();
d1143 1
a1143 1
  for (sym = proc->symbol_cache; sym; sym = sym->next)
d1155 1
a1155 1
  if (proc->all_symbols_looked_up)
d1215 2
a1216 2
  sym->next = proc->symbol_cache;
  proc->symbol_cache = sym;
@


1.56
log
@	* remote-utils.c (prepare_resume_reply): If requested, don't
	output "thread:TID" in the T stop reply.

	* server.c (disable_packet_vCont, disable_packet_Tthread)
	(disable_packet_qC, disable_packet_qfThreadInfo): New globals.
	(handle_query): If requested, disable support for qC, qfThreadInfo
	and qsThreadInfo.
	(handle_v_requests): If requested, disable support for vCont.
	(gdbserver_show_disableable): New.
	(main): Handle --disable-packet and --disable-packet=LIST.

	* server.h (disable_packet_vCont, disable_packet_Tthread)
	(disable_packet_qC, disable_packet_qfThreadInfo): Declare.
@
text
@d102 5
d189 2
d277 2
d563 11
d797 8
d810 1
a810 1
  if (remote_debug)
d812 5
a816 3
      fprintf (stderr, "getpkt (\"%s\");  [sending ack] \n", buf);
      fflush (stderr);
    }
d818 1
a818 1
  write (remote_desc, "+", 1);
d820 5
a824 4
  if (remote_debug)
    {
      fprintf (stderr, "[sent ack]\n");
      fflush (stderr);
@


1.55
log
@	New "find" command.
	* NEWS: Document find command and qSearch:memory packet.
	* Makefile.in (SFILES): Add findcmd.c.
	(COMMON_OBJS): Add findcmd.o.
	(findcmd.o): New rule.
	* findcmd.c: New file.
	* target.h (target_ops): New member to_search_memory.
	(simple_search_memory): Declare.
	(target_search_memory): Declare.
	* target.c (simple_search_memory): New fn.
	(target_search_memory): New fn.
	* remote.c (PACKET_qSearch_memory): New packet kind.
	(remote_search_memory): New fn.
	(init_remote_ops): Init to_search_memory.
	(init_extended_remote_ops): Ditto.
	(_initialize_remote): Add qSearch:memory packet config command.

	* gdbserver/server.h (decode_search_memory_packet): Declare.
	* gdbserver/remote-utils.c (decode_search_memory_packet): New fn.
	* gdbserver/server.c (handle_search_memory_1): New fn.
	(handle_search_memory): New fn.
	(handle_query): Process qSearch:memory packets.

	* doc/gdb.texinfo: Document "find" command, qSearch:memory packet.

	* testsuite/gdb.base/find.exp: New file.
	* testsuite/gdb.base/find.c: New file.
@
text
@d947 1
a947 1
      if (using_threads)
@


1.54
log
@	* linux-low.c (linux_attach_lwp): Do not _exit after errors.
	(linux_kill, linux_detach): Clean up the process list.
	* remote-utils.c (remote_open): Improve port number parsing.
	(putpkt_binary, input_interrupt): Only send interrupts if the target
	is running.
	* server.c (extended_protocol): Make static.
	(attached): Define earlier.
	(exit_requested, response_needed, program_argv): New variables.
	(target_running): New.
	(start_inferior): Clear attached here.
	(attach_inferior): Set attached here.
	(require_running): Define.
	(handle_query): Use require_running and target_running.  Implement
	"monitor exit".
	(handle_v_attach, handle_v_run): New.
	(handle_v_requests): Use require_running.  Handle vAttach and vRun.
	(gdbserver_usage): Update.
	(main): Redo argument parsing.  Handle --debug and --multi.  Handle
	--attach along with other options or after the port.  Save
	program_argv.  Support no initial program.  Resynchronize
	communication with GDB after an error.  Handle "monitor exit".
	Use require_running and target_running.  Always allow the extended
	protocol.  Do not error out for Hc0 or Hc-1.  Do not automatically
	restart in extended mode.
	* README: Refer to the GDB manual.  Update --attach usage.

	* remote.c (struct remote_state): Add cached_wait_status.
	(remote_exec_file): New variable.
	(PACKET_vAttach, PACKET_vRun): New constants.
	(extended_remote_restart): Do not query for status.
	(struct start_remote_args): New.
	(remote_start_remote): Take it as a second argument.  Check
	whether the target is running.  Issue an error for non-running
	non-extended targets.  Cache the wait status.  Set inferior_ptid
	here.
	(remote_open_1): Prompt to disconnect non-running targets.  Make
	sure the target is marked running.  Do not set inferior_ptid here.
	Update call to remote_start_remote.  Do not call remote_check_symbols
	if the target is not running.
	(remote_detach_1): Rename from remote_detach.  Take an EXTENDED
	argument.  Handle a non-running target.
	(remote_detach): Use it.
	(extended_remote_detach): New.
	(remote_disconnect): Fix typo.  Use remoute_mourn_1.
	(extended_remote_attach_1, extended_remote_attach)
	(extended_async_remote_attach): New.
	(remote_vcont_resume): Remove unused variable.
	(remote_wait, remote_async_wait): Use any cached wait status.
	(putpkt_binary, getpkt): Clear any cached wait status.
	(extended_remoute_mourn_1): New.
	(extended_remote_mourn): Use it.
	(extended_async_remote_mourn, extended_remote_run): New.
	(extended_remote_create_inferior_1): New.
	(extended_remote_create_inferior): Use it.
	(extended_remote_async_create_inferior): Likewise.
	(remote_xfer_partial): Skip for non-executing targets.
	(init_extended_remote_ops): Set to_detach and to_attach.
	(init_extended_async_remote_ops): Likewise.  Use
	extended_async_remote_mourn.
	(_initialize_remote): Register vAttach, vRun, and
	set remote exec-file.
	* NEWS: Mention vAttach, vRun, and gdbserver extended-remote support.

	* gdb.server/ext-attach.c, gdb.server/ext-attach.exp,
	gdb.server/ext-run.exp: New files.
	* lib/gdbserver-support.exp (gdbserver_download): New.
	(gdbserver_start): New.  Update gdbserver expected
	output.
	(gdbserver_spawn): Use them.
	(gdbserver_start_extended): New.

	* gdb.texinfo (Using the `gdbserver' Program): Add security
	warning.  Rearrange into subsections and subsubsections.  Document
	--multi and --debug.  Correct --with-sysroot typo.  Update --attach
	usage.  Make load reference clearer.  Document monitor exit.
	(Remote Configuration): Document set remote exec-file, attach-packet,
	and run-packet.
	(Packets): Document vAttach and vRun.
@
text
@d1083 18
@


1.54.6.1
log
@Check in ARCompact simulator.  A valid configuration is arc-elf.
This is not quite finished and has most likely a few files that are
obsolete & not used, but it's good enough to run gcc regression tests.
@
text
@d172 1
a172 3
/* #ifdef HAVE_SGTTY */
      /* soam */
#if 0
d774 1
a774 2
/*       if (csum == (c1 << 4) + c2) */
      if(1)				     /* (soam) for testing */
@


1.54.6.2
log
@gdb/insight for ARCompact (from Richard Stuckey)
@
text
@d172 3
a174 1
#ifdef HAVE_SGTTY
d776 2
a777 1
      if (csum == (c1 << 4) + c2)
@


1.53
log
@	Updated copyright notices for most files.
@
text
@a189 1
      char *port_str;
d194 1
d196 3
a198 3
      port_str = strchr (name, ':');

      port = atoi (port_str + 1);
d578 1
a578 1
      if (buf3[0] == '\003')
d620 1
a620 1
      if (cc != 1 || c != '\003')
@


1.52
log
@	* linux-low.c (linux_wait, linux_resume): Do not handle async I/O.
	* remote-utils.c (remote_open): Do not call disable_async_io.
	(block_async_io): Delete.
	(unblock_async_io): Make static.
	(initialize_async_io): New.
	* server.c (handle_v_cont): Handle async I/O here.
	(myresume): Likewise.  Move other common resume tasks here...
	(main): ... from here.  Call initialize_async_io.  Disable async
	I/O before the main loop.
	* server.h (initialize_async_io): Declare.
	(block_async_io, unblock_async_io): Delete prototypes.
	* spu-low.c (spu_resume, spu_wait): Do not handle async I/O here.
@
text
@d3 2
a4 1
   2001, 2002, 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.
@


1.51
log
@2007-12-06  Mick Davis  <mickd@@goanna.iinet.net.au>

	* remote-utils.c (readchar): Allow binary data in received messages.
@
text
@a277 1
  disable_async_io ();
d647 2
a648 2
void
block_async_io (void)
a651 5
  sigemptyset (&sigio_set);
  sigaddset (&sigio_set, SIGIO);
  sigprocmask (SIG_BLOCK, &sigio_set, NULL);
#endif
}
a652 5
void
unblock_async_io (void)
{
#ifndef USE_WIN32API
  sigset_t sigio_set;
d688 11
@


1.50
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d725 1
a725 1
  return *bufp++ & 0x7f;
@


1.49
log
@2007-08-01  Michael Snyder  <msnyder@@access-company.com>

	* remote-utils.c (putpkt_binary): Memory leak, free buf2.
@
text
@d9 1
a9 1
   the Free Software Foundation; either version 2 of the License, or
d18 1
a18 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.48
log
@	* remote-utils.c (remote_open): Set SO_KEEPALIVE on remote_desc
	instead of on tmp_desc.
@
text
@d552 1
@


1.47
log
@2007-07-17  Pedro Alves  <pedro_alves@@portugalmail.pt>
	    Daniel Jacobowitz  <dan@@codesourcery.com>

	* config/i386/cygwin.mt (TDEPFILES): Add solib-target.o.
	* coff-pe-read.c (read_pe_exported_syms): Delete verbose
	printf.
	* NEWS: Mention gdbserver DLL support.

	* gdb.base/unload.c (dlopen, dlsym, dlclose, dlerror): Define
	for __WIN32__.
	(SHLIB_NAME): Delete definition.  Always pass dlerror to fprintf.
	* gdb.base/unload.exp: Use shared library test routines.

	* inferiors.c (all_dlls, dlls_changed, get_dll): New.
	(add_thread): Minor cleanups.
	(clear_inferiors): Move lower in the file.  Clear the DLL
	list.
	(free_one_dll, match_dll, loaded_dll, unloaded_dll, clear_list): New.
	* remote-utils.c (prepare_resume_reply): Check dlls_changed.
	(xml_escape_text): New.
	* server.c (handle_query): Handle qXfer:libraries:read.  Report it
	for qSupported.
	(handle_v_cont): Report errors.
	(gdbserver_version): Update.
	(main): Correct size of own_buf.  Do not report initial DLL events.
	* server.h (struct dll_info, all_dlls, dlls_changed, loaded_dll)
	(unloaded_dll, xml_escape_text): New.
	* win32-low.c (enum target_waitkind): Update comments.
	(win32_add_one_solib, get_image_name, winapi_EnumProcessModules)
	(winapi_GetModuleInformation, winapi_GetModuleFileNameExA)
	(win32_EnumProcessModules, win32_GetModuleInformation)
	(win32_GetModuleFileNameExA, load_psapi, psapi_get_dll_name)
	(winapi_CreateToolhelp32Snapshot, winapi_Module32First)
	(winapi_Module32Next, win32_CreateToolhelp32Snapshot)
	(win32_Module32First, win32_Module32Next, load_toolhelp)
	(toolhelp_get_dll_name, handle_load_dll, handle_unload_dll): New.
	(get_child_debug_event): Handle DLL events.
	(win32_wait): Likewise.
@
text
@d249 2
a250 1
      setsockopt (tmp_desc, SOL_SOCKET, SO_KEEPALIVE, (char *) &tmp, sizeof (tmp));
@


1.46
log
@2007-07-03  Paul Gilliam  <pgilliam@@us.ibm.com>
	    Thiago Bauermann  <bauerman@@br.ibm.com>
	    Joseph S. Myers  <joseph@@codesourcery.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>

	gdb/
	* remote.c (remote_check_symbols): Use
	gdbarch_convert_from_func_ptr_addr.
	* infcall.c (find_function_addr): Handle function descriptors
	without debugging information.
	* ppc-linux-tdep.c (ppc_linux_convert_from_func_ptr_addr): Renamed
	from ppc64_linux_convert_from_func_ptr_addr.  Handle -msecure-plt.
	(ppc_linux_init_abi): Always set convert_from_func_ptr_addr.
	* solib-svr4.c (solib_break_names): Remove "._dl_debug_state".
	(bfd_lookup_symbol): Do not take a SECT_FLAGS argument.  Always
	allow SEC_CODE and SEC_DATA.
	(enable_break): Update calls.  Pass current_target to solib_add.
	Use gdbarch_convert_from_func_ptr_addr.

	gdb/gdbserver/
	* remote-utils.c (look_up_one_symbol): Handle 'm' packets.
@
text
@d968 7
d1182 62
@


1.45
log
@ChangeLog:

	* remote.c (remote_write_qxfer): New function.
	(remote_xfer_partial): Add handling for TARGET_OBJECT_SPU.
	(remote_read_qxfer): Do not cache empty objects.
	(_initialize_remote): Add PACKET_qXfer_spu_read and
	PACKET_qXfer_spu_write.

doc/ChangeLog:

	* gdb.texinfo (General Query Packets): Document qXfer:spu:read
	and qXfer:spu:write packets and mention them under qSupported.

gdbserver/ChangeLog:

	* remote-utils.c (decode_xfer_write): New function.
	* server.h (decode_xfer_write): Add prototype.
	* server.c (handle_query): Add PACKET_LEN argument.  Support
	qXfer:spu:read and qXfer:spu:write packets.
	(main): Pass packet_len to handle_query.
	* spu-low.c (spu_target_ops): Add spu_proc_xfer_spu.
	* target.h (target_ops): Add qxfer_spu.
@
text
@d1112 25
d1139 1
a1139 7
      /* Malformed response.  */
      if (remote_debug)
	{
	  fprintf (stderr, "Malformed response to qSymbol, ignoring.\n");
	  fflush (stderr);
	}

@


1.44
log
@	* server.h (check_remote_input_interrupt_request): New function.
	* remote_utils.c (INVALID_DESCRIPTOR): New define.
	(remote_desc): Initialize with INVALID_DESCRIPTOR.
	(input_interrupt): Expose on USE_WIN32API too.  Fix whitespace.
	(check_remote_input_interrupt_request): New function.
	* server.h (check_remote_input_interrupt_request): Declare.

	* win32-low.(winapi_DebugBreakProcess,
	winapi_GenerateConsoleCtrlEvent): New typedefs.
	(get_child_debug_event): Lower Win32 debug event polling from 1 sec
	to 250 ms.
	(win32_wait): Check for remote interrupt request
	with check_remote_input_interrupt_request.
	(win32_request_interrupt): New function.
	(win32_target_op): Set request_interrupt to win32_request_interrupt.
@
text
@d1045 30
@


1.43
log
@gdb/

	* arm-wince-tdep.c: New.
	* config/arm/wince.mt (DEPRECATED_TM_FILE): Use tm-arm.h.
	(MT_CFLAGS): Delete.
	(TM_CLIBS): Delete.
	(TDEPFILES): Add arm-wince-tdep.o, corelow.o, solib.o,
	solib-legacy.o, solib-svr4.o, and remove wince.o.
	* configure.tgt (arm*-*-mingw32ce*): Add.
	* signals/signals.c [HAVE_SIGNAL_H]: Check.
	(do_target_signal_to_host): Silence 'not used' warning.
	* config/arm/tm-wince.h: Remove.

gdb/gdbserver/

	* gdbserver/configure.ac: Add errno checking.
	(AC_CHECK_HEADERS): Add errno.h, fcntl.h, signal.h,
	sys/file.h and malloc.h.
	(AC_CHECK_DECLS): Add perror.
	(srv_mingwce): Handle.
	* gdbserver/configure.srv (i[34567]86-*-cygwin*): Add
	win32-i386-low.o to srv_tgtobj.
	(i[34567]86-*-mingw*): Likewise.
	(arm*-*-mingw32ce*): Add case.
	* gdbreplay.c [HAVE_SYS_FILE_H, HAVE_SIGNAL_H,
	HAVE_FCNTL_H, HAVE_ERRNO_H, HAVE_MALLOC_H]: Check.
	[__MINGW32CE__] (strerror): New function.
	[__MINGW32CE__] (errno): Define to GetLastError.
	[__MINGW32CE__] (COUNTOF): New macro.
	(remote_open): Remove extra close call.
	* mem-break.c (delete_breakpoint_at): New function.
	* mem-break.h (delete_breakpoint_at): Declare.
	* remote-utils.c [HAVE_SYS_FILE_H, HAVE_SIGNAL_H,
	HAVE_FCNTL_H, HAVE_UNISTD_H, HAVE_ERRNO_H]: Check.
	[USE_WIN32API] (read, write): Add char* casts.
	* server.c [HAVE_UNISTD_H, HAVE_SIGNAL_H]: Check.
	* server.h: Include wincecompat.h on Windows CE.
	[HAVE_ERRNO_H]: Check.
	(perror): Declare if not declared.
	* utils.c: Add stdlib.h, errno.h and malloc.h includes.
	(perror_with_name): Remove errno declaration.
	* wincecompat.h: New.
	* wincecompat.c: New.
	* win32-low.h: New.
	* win32-arm-low.c: New.
	* win32-i386-low.c: New.
	(win32-low.c): Include mem-break.h and win32-low.h, and winnt.h.
	(OUTMSG2): Make it safe.
	(_T): New macro.
	(COUNTOF): New macro.
	(NUM_REGS): Get it from the low target.
	(CONTEXT_EXTENDED_REGISTERS, CONTEXT_FLOATING_POINT,
	CONTEXT_DEBUG_REGISTERS): Add fallbacks to 0.
	(thread_rec): Let low target handle debug registers.
	(child_add_thread): Likewise.
	(child_init_thread_list): Likewise.
	(continue_one_thread): Likewise.
	(regptr): New.
	(do_child_fetch_inferior_registers): Move to ...
	* win32-i386-low.c: ... here, and rename to ...
	(do_fetch_inferior_registers): ... this.
	* win32-low.c (child_fetch_inferior_registers):
	Go through the low target.
	(do_child_store_inferior_registers): Use regptr.
	(strwinerror): New function.
	(win32_create_inferior): Handle Windows CE.
	Use strwinerror instead of strerror on Windows error
	codes.  Add program to the error output.
	Don't close the main thread handle on Windows CE.
	(win32_attach): Use coredll.dll on Windows CE.
	(win32_kill): Close current process and current
	thread handles.
	(win32_detach): Use coredll.dll on Windows CE.
	(win32_resume): Let low target handle debug registers, and
	step request.
	(handle_exception): Add/Remove initial breakpoint.  Avoid
	non-existant WSTOPSIG on Windows CE.
	(win32_read_inferior_memory): Cast to remove warning.
	(win32_arch_string): Go through the low target.
	(initialize_low): Call set_breakpoint_data with the low
	target's breakpoint.
	* win32-low.c (dr, FLAG_TRACE_BIT, FCS_REGNUM,
	FOP_REGNUM, mappings): Move to ...
	* win32-i386-low.c: ... here.
	* win32-low.c (win32_thread_info): Move to ...
	* win32-low.h: ... here.
	* Makefile.in (SFILES): Add win32-low.c, win32-i386-low.c,
	win32-arm-low.c and wincecompat.c.
	(all:): Add $EXEEXT.
	(install-only:): Likewise.
	(gdbserver:): Likewise.
	(gdbreplay:): Likewise.
	* config.in: Regenerate.
	* configure: Regenerate.
@
text
@d73 6
d97 1
a97 1
static int remote_desc;
a596 2
#ifndef USE_WIN32API

d617 1
a617 1
      
d626 1
a626 1
      
d630 13
a642 1
#endif
@


1.42
log
@	* remote-utils.c (monitor_output): Constify msg parameter.
	* server.h (monitor_output): Likewise.
	* win32-i386-low.c (handle_output_debug_string): New.
	(win32_kill): Handle OUTPUT_DEBUG_STRING_EVENT events using
	handle_output_debug_string.
	(get_child_debug_event): Likewise.
@
text
@d29 1
d31 1
d47 1
d49 2
d52 1
d54 1
d56 1
d61 1
d63 1
d98 2
a99 2
# define read(fd, buf, len) recv (fd, buf, len, 0)
# define write(fd, buf, len) send (fd, buf, len, 0)
@


1.41
log
@from  Mat Hostetter  <mat@@lcs.mit.edu>
	* remote-utils.c (remote_open): Print out the assigned port number.
@
text
@d1090 1
a1090 1
monitor_output (char *msg)
@


1.40
log
@	* gdb.texinfo (Monitor commands for gdbserver): New subsection.

	* remote-utils.c (monitor_output): New function.
	* server.c (debug_threads): Define here.
	(monitor_show_help): New function.
	(handle_query): Handle qRcmd.
	(main): Do not handle 'd' packet.
	* server.h (debug_threads, remote_debug, monitor_output): Declare.
	* linux-low.c, spu-low.c, win32-i386-low.c: Remove definitions
	of debug_threads.

	* gdb.server/server-mon.exp: New test.
@
text
@d212 11
@


1.39
log
@	* target.h (target_ops): Rename send_signal to request_interrupt,
	and remove enum target_signal parameter.
	* linux-low.c (linux_request_interrupt): Rename from
	linux_send_signal, and always send SIGINT.
	* spu-low.c (spu_request_interrupt): Rename from spu_send_signal,
	and always send SIGINT.
	* remote-utils.c (putpkt_binary): Call request_interrupt, instead
	of send_signal.
	(input_interrupt): Likewise.
@
text
@d1077 12
@


1.38
log
@	* remote-utils.c: Remove HAVE_TERMINAL_H check.
	* configure.ac: Do not check for terminal.h.
	* configure, config.in: Regenerated.
@
text
@d552 1
a552 1
	(*the_target->send_signal) (SIGINT);
d575 1
a575 1
   will cause us to send a SIGINT to the child.  */
d602 1
a602 1
      (*the_target->send_signal) (SIGINT);
@


1.37
log
@	* remote-utils.c [USE_WIN32API] (read, write): Define.
	(putpkt_binary, input_interrupt, readchar, getpkt): Use read and
	write.
@
text
@a22 1
#if HAVE_TERMINAL_H
a23 1
#endif
@


1.36
log
@Copyright updates for 2007.
@
text
@d89 5
d523 1
a523 1
      if (send (remote_desc, buf2, p - buf2, 0) != p - buf2)
d534 1
a534 1
      cc = recv (remote_desc, buf3, 1, 0);
d595 1
a595 1
      cc = recv (remote_desc, &c, 1, 0);
d676 1
a676 1
  bufcnt = recv (remote_desc, buf, sizeof (buf), 0);
d743 1
a743 1
      send (remote_desc, "-", 1, 0);
d752 1
a752 1
  send (remote_desc, "+", 1, 0);
@


1.35
log
@	* remote-utils.c (remote_open): Check the type of specified
	serial port devices before opening them.
	* server.c (main): Kill the inferior if an error occurs during
	the first remote_open.
@
text
@d2 2
a3 3
   Copyright (C) 1986, 1989, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
   2002, 2003, 2004, 2005, 2006
   Free Software Foundation, Inc.
@


1.34
log
@gdb/
	* remote.c (PACKET_QPassSignals): New.
	(last_pass_packet, remote_pass_signals): New.
	(remote_protocol_features): Add QPassSignals.
	(remote_query_supported): Correct an infinite loop.
	(remote_open_1): Reset last_pass_packet.
	(remote_resume): Call remote_pass_signals.
	(_initialize_remote): Register "set remote pass-signals".
gdb/doc/
	* gdb.texinfo (Remote configuration): Mention
	"pass-signals-packet".
	(General Query Packets): Document QPassSignals.  Fix
	a typo.
gdb/gdbserver/
	* linux-low.c (linux_wait_for_event): Reformat.  Use the
	pass_signals array.
	* remote-utils.c (decode_address_to_semicolon): New.
	* server.c (pass_signals, handle_general_set): New.
	(handle_query): Mention QPassSignals for qSupported.
	(main): Call handle_general_set.
	* server.h (pass_signals, decode_address_to_semicolon): New.
@
text
@d55 2
d99 4
a102 2
  
  if (!strchr (name, ':'))
d107 11
a117 1
      remote_desc = open (name, O_RDWR);
@


1.33
log
@	* acinclude.m4 (SRV_CHECK_TLS_GET_ADDR): New.
	* configure.ac: Use it.  Define HAVE_TD_THR_TLS_GET_ADDR.
	* config.in, configure: Regenerated.
	* inferiors.c (gdb_id_to_thread): New function.
	(gdb_id_to_thread_id): Use it.
	* linux-low.c (linux_target_ops): Use thread_db_get_tls_address.
	* linux-low.h (struct process_info): Add th member.
	(thread_db_get_tls_address): New prototype.
	* remote-utils.c (decode_address): Make non-static.
	* server.c (handle_query): Handle qGetTLSAddr.
	* server.h (gdb_id_to_thread, decode_address): New prototypes.
	* target.h (struct target_ops): Add get_tls_address.
	* thread-db.c (maybe_attach_thread): Save the thread handle.
	(thread_db_get_tls_address): New.
@
text
@d299 16
@


1.32
log
@	* remote-utils.c (try_rle): New function.
	(putpkt_binary): Use it.
@
text
@d282 1
a282 1
static void
@


1.31
log
@gdb/
	* configure.tgt: Build gdbserver for Cygwin and mingw32.
gdb/gdbserver/
	* configure.ac: Check for more headers which are missing on
	Windows.  Automatically supply -lwsock32 and USE_WIN32API.
	* configure.srv: Add Cygwin and mingw32.
	* remote-utils.c: Don't include headers unconditionally which
	are missing on mingw32.  Include <winsock.h> for mingw32.
	(remote_open): Adjust for mingw32 support.  Flush
	standard error after writing to it.
	(remote_close, putpkt_binary, input_interrupt, block_async_io)
	(unblock_async_io, enable_async_io, disable_async_io)
	(readchar, getpkt): Update for Winsock support.
	(prepare_resume_reply): Expect a protocol signal number.
	* server.c: Disable <sys/wait.h> on mingw32.
	(start_inferior): Adjust for mingw32 support.  Flush
	standard error after writing to it.
	(attach_inferior): Likewise.  Use protocol signal
	numbers.
	(main): Skip 'D' packet on mingw32.  Use protocol signal numbers
	and names.
	* win32-i386-low.c: New file.
	* Makefile.in (XM_CLIBS): Set.
	(gdbserver, gdbreplay): Use $(INTERNAL_CFLAGS).
	(win32-i386-low.o): New dependency rule.
	* linux-low.c (linux_wait): Use target signal numbers.
	* target.h (struct target_ops): Doc fix.
	* server.h (target_signal_to_name): New prototype.
	* gdbreplay.c: Don't include headers unconditionally which
	are missing on mingw32.  Include <winsock.h> for mingw32.
	(remote_close, remote_open): Adjust for Winsock support.
	* configure, config.in: Regenerated.
@
text
@d409 44
d474 3
a476 5
  for (i = 0; i < cnt; i++)
    {
      csum += buf[i];
      *p++ = buf[i];
    }
@


1.30
log
@	* remote-utils.c (remote_escape_output, remote_unescape_input): New.
	(putpkt_binary): Renamed from putpkt and adjusted for binary
	data.
	(putpkt): New wrapper for putpkt_binary.
	(readchar): Don't mask off the high bit.
	(decode_X_packet): New function.
	* server.c (main): Call putpkt_binary if a handler sets the packet
	length.  Save the length of the incoming packet.  Handle 'X'.
	* server.h (gdb_byte, remote_escape_output, decode_X_packet): New.
@
text
@d24 1
d26 1
d29 1
d31 1
d33 1
d35 2
d38 2
d41 2
d44 2
d47 1
d52 1
d54 5
d94 1
d96 1
d100 3
d152 1
d156 3
d169 11
a179 1
      tmp_desc = socket (PF_INET, SOCK_STREAM, 0);
d197 1
d214 2
d220 3
d242 3
d246 1
d447 1
a447 1
      if (write (remote_desc, buf2, p - buf2) != p - buf2)
d458 1
a458 1
      cc = read (remote_desc, buf3, 1);
d496 1
d519 1
a519 1
      cc = read (remote_desc, &c, 1);
d531 5
d540 1
d545 1
d551 1
d556 1
a558 4
/* Asynchronous I/O support.  SIGIO must be enabled when waiting, in order to
   accept Control-C from the client, and must be disabled when talking to
   the client.  */

d569 1
d571 1
d582 1
d584 1
d600 1
a600 1
  bufcnt = read (remote_desc, buf, sizeof (buf));
d667 1
a667 1
      write (remote_desc, "-", 1);
d676 1
a676 1
  write (remote_desc, "+", 1);
d785 1
a785 1
prepare_resume_reply (char *buf, char status, unsigned char signo)
d787 1
a787 1
  int nib, sig;
a790 2
  sig = (int)target_signal_from_host (signo);

@


1.29
log
@	* remote-utils.c (all_symbols_looked_up): New variable.
	(look_up_one_symbol): Check it.
	* server.h (look_up_one_symbol): New declaration.
	* thread-db.c (thread_db_init): Set all_symbols_looked_up.
@
text
@d279 81
d361 2
a362 1
   The data of the packet is in BUF.  Returns >= 0 on success, -1 otherwise. */
d365 1
a365 1
putpkt (char *buf)
a370 1
  int cnt = strlen (buf);
d437 11
d534 1
a534 1
  static char buf[BUFSIZ];
d536 1
a536 1
  static char *bufp;
d539 1
a539 1
    return *bufp++ & 0x7f;
d850 27
@


1.28
log
@	* remote-utils.c (prepare_resume_reply): Move declaration
	of gdb_id_from_wait to the top of the block.
@
text
@d3 1
a3 1
   2002, 2003, 2004, 2005
d55 4
d776 8
@


1.28.10.1
log
@Changes from nickrob-async-20060828-mergepoint.
@
text
@d3 1
a3 1
   2002, 2003, 2004, 2005, 2006
a23 1
#if HAVE_TERMINAL_H
a24 1
#endif
a26 1
#if HAVE_SYS_IOCTL_H
a27 1
#endif
a28 1
#if HAVE_NETINET_IN_H
a29 2
#endif
#if HAVE_SYS_SOCKET_H
a30 2
#endif
#if HAVE_NETDB_H
a31 2
#endif
#if HAVE_NETINET_TCP_H
a32 2
#endif
#if HAVE_SYS_IOCTL_H
a33 1
#endif
a37 1
#if HAVE_ARPA_INET_H
a38 5
#endif

#if USE_WIN32API
#include <winsock.h>
#endif
a54 4
/* If this flag has been set, assume cache misses are
   failures.  */
int all_symbols_looked_up;

a69 1
#if defined(F_SETFL) && defined (FASYNC)
a70 1
#endif
a73 3
#ifdef USE_WIN32API
      error ("Only <host>:<port> is supported on this platform.");
#else
a122 1
#endif /* USE_WIN32API */
a125 3
#ifdef USE_WIN32API
      static int winsock_initialized;
#endif
d136 1
a136 11
#ifdef USE_WIN32API
      if (!winsock_initialized)
	{
	  WSADATA wsad;

	  WSAStartup (MAKEWORD (1, 0), &wsad);
	  winsock_initialized = 1;
	}
#endif

      tmp_desc = socket (PF_INET, SOCK_STREAM, IPPROTO_TCP);
a153 1
      fflush (stderr);
a169 2

#ifndef USE_WIN32API
a173 3
#else
      closesocket (tmp_desc);	/* No longer need this */
#endif
a192 3
#ifdef USE_WIN32API
  closesocket (remote_desc);
#else
a193 1
#endif
a274 81
/* Convert BUFFER, binary data at least LEN bytes long, into escaped
   binary data in OUT_BUF.  Set *OUT_LEN to the length of the data
   encoded in OUT_BUF, and return the number of bytes in OUT_BUF
   (which may be more than *OUT_LEN due to escape characters).  The
   total number of bytes in the output buffer will be at most
   OUT_MAXLEN.  */

int
remote_escape_output (const gdb_byte *buffer, int len,
		      gdb_byte *out_buf, int *out_len,
		      int out_maxlen)
{
  int input_index, output_index;

  output_index = 0;
  for (input_index = 0; input_index < len; input_index++)
    {
      gdb_byte b = buffer[input_index];

      if (b == '$' || b == '#' || b == '}' || b == '*')
	{
	  /* These must be escaped.  */
	  if (output_index + 2 > out_maxlen)
	    break;
	  out_buf[output_index++] = '}';
	  out_buf[output_index++] = b ^ 0x20;
	}
      else
	{
	  if (output_index + 1 > out_maxlen)
	    break;
	  out_buf[output_index++] = b;
	}
    }

  *out_len = input_index;
  return output_index;
}

/* Convert BUFFER, escaped data LEN bytes long, into binary data
   in OUT_BUF.  Return the number of bytes written to OUT_BUF.
   Raise an error if the total number of bytes exceeds OUT_MAXLEN.

   This function reverses remote_escape_output.  It allows more
   escaped characters than that function does, in particular because
   '*' must be escaped to avoid the run-length encoding processing
   in reading packets.  */

static int
remote_unescape_input (const gdb_byte *buffer, int len,
		       gdb_byte *out_buf, int out_maxlen)
{
  int input_index, output_index;
  int escaped;

  output_index = 0;
  escaped = 0;
  for (input_index = 0; input_index < len; input_index++)
    {
      gdb_byte b = buffer[input_index];

      if (output_index + 1 > out_maxlen)
	error ("Received too much data from the target.");

      if (escaped)
	{
	  out_buf[output_index++] = b ^ 0x20;
	  escaped = 0;
	}
      else if (b == '}')
	escaped = 1;
      else
	out_buf[output_index++] = b;
    }

  if (escaped)
    error ("Unmatched escape character in target response.");

  return output_index;
}

d276 1
a276 2
   The data of the packet is in BUF, and the length of the
   packet is in CNT.  Returns >= 0 on success, -1 otherwise.  */
d279 1
a279 1
putpkt_binary (char *buf, int cnt)
d285 1
d313 1
a313 1
      if (send (remote_desc, buf2, p - buf2, 0) != p - buf2)
d324 1
a324 1
      cc = recv (remote_desc, buf3, 1, 0);
a351 12
/* Send a packet to the remote machine, with error checking.  The data
   of the packet is in BUF, and the packet should be a NUL-terminated
   string.  Returns >= 0 on success, -1 otherwise.  */

int
putpkt (char *buf)
{
  return putpkt_binary (buf, strlen (buf));
}

#ifndef USE_WIN32API

d373 1
a373 1
      cc = recv (remote_desc, &c, 1, 0);
a384 5
#endif

/* Asynchronous I/O support.  SIGIO must be enabled when waiting, in order to
   accept Control-C from the client, and must be disabled when talking to
   the client.  */
a388 1
#ifndef USE_WIN32API
a392 1
#endif
a397 1
#ifndef USE_WIN32API
a401 1
#endif
d404 4
a417 1
#ifndef USE_WIN32API
a418 1
#endif
a428 1
#ifndef USE_WIN32API
a429 1
#endif
d438 1
a438 1
  static unsigned char buf[BUFSIZ];
d440 1
a440 1
  static unsigned char *bufp;
d443 1
a443 1
    return *bufp++;
d445 1
a445 1
  bufcnt = recv (remote_desc, buf, sizeof (buf), 0);
d512 1
a512 1
      send (remote_desc, "-", 1, 0);
d521 1
a521 1
  send (remote_desc, "+", 1, 0);
d630 1
a630 1
prepare_resume_reply (char *buf, char status, unsigned char sig)
d632 1
a632 1
  int nib;
d636 2
a753 27
int
decode_X_packet (char *from, int packet_len, CORE_ADDR *mem_addr_ptr,
		 unsigned int *len_ptr, unsigned char *to)
{
  int i = 0;
  char ch;
  *mem_addr_ptr = *len_ptr = 0;

  while ((ch = from[i++]) != ',')
    {
      *mem_addr_ptr = *mem_addr_ptr << 4;
      *mem_addr_ptr |= fromhex (ch) & 0x0f;
    }

  while ((ch = from[i++]) != ':')
    {
      *len_ptr = *len_ptr << 4;
      *len_ptr |= fromhex (ch) & 0x0f;
    }

  if (remote_unescape_input ((const gdb_byte *) &from[i], packet_len - i,
			     to, *len_ptr) != *len_ptr)
    return -1;

  return 0;
}

a771 8
  /* If we've passed the call to thread_db_look_up_symbols, then
     anything not in the cache must not exist; we're not interested
     in any libraries loaded after that point, only in symbols in
     libpthread.so.  It might not be an appropriate time to look
     up a symbol, e.g. while we're trying to fetch registers.  */
  if (all_symbols_looked_up)
    return 0;

@


1.27
log
@	* linux-arm-low.c:
	* linux-cris-low.c:
	* inferiors.c:
	* i387-fp.h:
	* i387-fp.c:
	* gdbreplay.c:
	* regcache.c:
	* proc-service.c:
	* mem-break.h:
	* mem-break.c:
	* linux-x86-64-low.c:
	* linux-sh-low.c:
	* linux-s390-low.c:
	* linux-ppc64-low.c:
	* linux-ppc-low.c:
	* linux-mips-low.c:
	* linux-m68k-low.c:
	* linux-m32r-low.c:
	* linux-low.h:
	* linux-low.c:
	* linux-ia64-low.c:
	* linux-i386-low.c:
	* linux-crisv32-low.c:
	* thread-db.c:
	* terminal.h:
	* target.h:
	* target.c:
	* server.h:
	* server.c:
	* remote-utils.c:
	* regcache.h:
	* utils.c:
	* Makefile.in:
	* configure.ac:
	* gdbserver.1: Add (C) after Copyright.  Update the FSF
	address.
@
text
@d684 2
d688 1
a688 1
	  unsigned int gdb_id_from_wait = thread_to_gdb_id (current_inferior);
@


1.27.4.1
log
@Add experimental support for SymbianOS-related protocol features.
@
text
@a398 6

  /* HACK */
  extern int restarting_program;
  if (restarting_program)
    return;

@


1.27.4.2
log
@	* gdb/remote.c: Include "gdb/fileio.h".
	(PACKET_Fopen, PACKET_Fread, PACKET_Fwrite, PACKET_Fclose): New
	enums.
	(remote_escape_output, remote_unescape_input): New functions.
	(remote_write_bytes): Use remote_escape_output.
	(readchar): Do not mask off the high bit.
	(read_frame): Print binary packets correctly.
	(getpkt_sane): Likewise.  Return the number of bytes read
	or -1.
	(remote_buffer_add_string, remote_buffer_add_bytes)
	(remote_buffer_add_int, remote_hostio_parse_result)
	(remote_hostio_send_command, remote_hostio_open)
	(remote_hostio_write, remote_hostio_read)
	(remote_hostio_close, remote_fileio_errno_to_host)
	(remote_hostio_error, fclose_cleanup, remote_download_command)
	(remote_upload_command): New functions.
	(_initialize_remote): Register new packets and remote-upload
	and remote-download commands.

	* gdb/doc/gdb.texinfo (File Transfer): New section.
	(Remote Configuration): Document Host I/O packet commands.
	(Host I/O Packets): New section.
	(Packets): Mention overloading of F prefix.

	* gdb/gdbserver/Makefile.in (OBS): Add hostio.o.
	(hostio.o): New rule.
	* gdb/gdbserver/hostio.c: New file.
	* gdb/gdbserver/remote-utils.c (putpkt_binary): New function,
	broken out from putpkt.
	(putpkt): Use it.
	(readchar): Do not mask the high bits.  Correct the buffer
	type.
	* gdb/gdbserver/server.c (main): Leave space for a trailing
	zero in the packet buffer.  Save the length of the
	received packet.  Handle Host I/O requests.  Optionally call
	putpkt_binary.
	* gdb/gdbserver/server.h (handle_f_hostio, putpkt_binary): New
	prototypes.
@
text
@d276 1
a276 2
   The data of the packet is in BUF, and the length of the
   packet is in CNT.  Returns >= 0 on success, -1 otherwise.  */
d279 1
a279 1
putpkt_binary (char *buf, int cnt)
d285 1
a351 10
/* Send a packet to the remote machine, with error checking.  The data
   of the packet is in BUF, and the packet should be a NUL-terminated
   string.  Returns >= 0 on success, -1 otherwise.  */

int
putpkt (char *buf)
{
  return putpkt_binary (buf, strlen (buf));
}

d444 1
a444 1
  static unsigned char buf[BUFSIZ];
d446 1
a446 1
  static unsigned char *bufp;
d449 1
a449 1
    return *bufp++;
@


1.26
log
@	* inferiors.c (struct thread_info): Add gdb_id.
	(add_thread): Add gdb_id argument.
	(thread_id_to_gdb_id, thread_to_gdb_id, gdb_id_to_thread_id): New.
	* linux-low.c (linux_create_inferior, linux_attach_lwp): Update
	calls to add_thread.
	* remote-utils.c (prepare_resume_reply: Use thread_to_gdb_id.
	* server.c (handle_query): Use thread_to_gdb_id.
	(handle_v_cont, main): Use gdb_id_to_thread_id.
	* server.h (add_thread): Update prototype.
	(thread_id_to_gdb_id, thread_to_gdb_id, gdb_id_to_thread_id): New
	prototypes.
@
text
@d2 1
a2 1
   Copyright 1986, 1989, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
d20 2
a21 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.25
log
@	* acconfig.h: Remove.
	* configure.ac: Add a test for socklen_t.  Use three-argument
	AC_DEFINE throughout.
	* config.in: Regenerated using autoheader 2.59.
	* configure: Regenerated.

	* gdbreplay.c (socklen_t): Provide a default.
	(remote_open): Use socklen_t.
	* remote-utils.c (socklen_t): Provide a default.
	(remote_open): Use socklen_t.
	(convert_int_to_ascii, convert_ascii_to_int, decode_M_packet): Use
	unsigned char.

	* i387-fp.c (struct i387_fsave, struct i387_fxsave): Use unsigned
	char for buffers.
	* linux-low.c (linux_read_memory, linux_write_memory)
	(linux_read_auxv): Likewise.
	* mem-break.c (breakpoint_data, set_breakpoint_data, check_mem_read)
	(check_mem_write): Likewise.
	* mem-break.h (set_breakpoint_data, check_mem_read, check_mem_write):
	Likewise.
	* regcache.c (struct inferior_rgcache_data, registers_to_string)
	(registers_from_string, register_data): Likewise.
	* server.c (handle_query, main): Likewise.
	* server.h (convert_ascii_to_int, convert_int_to_ascii)
	(decode_M_packet): Likewise.
	* target.c (read_inferior_memory, write_inferior_memory): Likewise.
	* target.h (struct target_ops): Update read_memory, write_memory,
	and read_auxv.
	(read_inferior_memory, write_inferior_memory): Update.
	* linux-low.h (struct linux_target_ops): Change type of breakpoint
	to unsigned char *.
	* linux-arm-low.c, linux-cris-low.c, linux-crisv32-low.c,
	linux-i386-low.c, linux-m32r-low.c, linux-m68k-low.c,
	linux-mips-low.c, linux-ppc-low.c, linux-ppc64-low.c,
	linux-s390-low.c, linux-sh-low.c: Update for changes in
	read_inferior_memory and the_low_target->breakpoint.
@
text
@d686 2
d697 1
a697 1
	      sprintf (buf, "thread:%lx;", thread_from_wait);
@


1.24
log
@2005-05-12  Orjan Friberg  <orjanf@@axis.com>

	* target.h (struct target_ops): Add insert_watchpoint,
	remove_watchpoint, stopped_by_watchpoint, stopped_data_address function
	pointers for hardware watchpoint support.
	* linux-low.h (struct linux_target_ops): Ditto.
	* linux-low.c (linux_insert_watchpoint, linux_remove_watchpoint)
	(linux_stopped_by_watchpoint, linux_stopped_data_address): New.  Add
	to linux_target_ops.
	* remote-utils.c (prepare_resume_reply): Add watchpoint information to
	reply packet.
	* server.c (main): Recognize 'Z' and 'z' packets.
@
text
@d40 4
d129 1
a129 1
      int tmp;
d551 1
a551 1
convert_int_to_ascii (char *from, char *to, int n)
d554 1
a554 1
  char ch;
d568 1
a568 1
convert_ascii_to_int (char *from, char *to, int n)
d729 1
a729 1
		 char *to)
@


1.23
log
@	* inferiors.c (change_inferior_id, add_thread, find_inferior_id):
	Take unsigned long arguments for PIDs.
	* linux-low.c (add_process, linux_attach_lwp, linux_attach)
	(linux_thread_alive, linux_wait_for_event, kill_lwp, send_sigstop)
	(wait_for_sigstop, linux_resume_one_process)
	(regsets_fetch_inferior_registers, linux_send_signal)
	(linux_read_auxv): Likewise.  Update the types of variables holding
	PIDs.  Update format string specifiers.
	* linux-low.h (struct process_info, linux_attach_lwp): Likewise.
	* remote-utils.c (prepare_resume_reply): Likewise.
	* server.c (cont_thread, general_thread, step_thread)
	(thread_from_wait, old_thread_from_wait, signal_pid): Change type to
	unsigned long.
	(handle_query): Update format specifiers.
	(handle_v_cont, main): Use strtoul for thread IDs.
	* server.h (struct inferior_list_entry): Use unsigned long for ID.
	(add_thread, find_inferior_id, change_inferior_id, cont_thread)
	(general_thread, step_thread, thread_from_wait)
	(old_thread_from_wait): Update.
	* target.h (struct thread_resume): Use unsigned long for THREAD.
	(struct target_ops): Use unsigned long for arguments to attach and
	thread_alive.
@
text
@d642 22
@


1.22
log
@	* linux-i386-low.c (ps_get_thread_area): New.
	* linux-x86-64-low.c (ps_get_thread_area): New.
	* linux-low.c: Include <sys/syscall.h>.
	(linux_kill_one_process): Don't kill the first thread here.
	(linux_kill): Kill the first thread here.
	(kill_lwp): New function.
	(send_sigstop, linux_send_signal): Use it.
	* proc-service.c: Clean up #ifdefs.
	(fpregset_info): Delete.
	(ps_lgetregs): Update and enable implementation.
	(ps_lsetregs, ps_lgetfpregs, ps_lsetfpregs): Remove disabled
	implementations.
	* remote-utils.c (struct sym_cache, symbol_cache): New.
	(input_interrupt): Print a clearer message.
	(async_io_enabled): New variable.
	(enable_async_io, disable_async_io): Use it.  Update comments.
	(look_up_one_symbol): Use the symbol cache.
	* thread-db.c (thread_db_look_up_symbols): New function.
	(thread_db_init): Update comments.  Call thread_db_look_up_symbols.
@
text
@d3 1
a3 1
   2002, 2003, 2004
d661 1
a661 1
	    fprintf (stderr, "Writing resume reply for %d\n\n", thread_from_wait);
d669 1
a669 1
	      sprintf (buf, "thread:%x;", thread_from_wait);
@


1.21
log
@	* remote-utils.c (prepare_resume_reply): Always supply "thread:".
@
text
@d40 11
d367 1
a367 1
      char c;
d373 2
a374 1
	  fprintf (stderr, "input_interrupt, cc = %d c = %d\n", cc, c);
d400 8
d411 3
d415 1
d418 1
d422 3
d426 1
d724 3
d732 9
d775 8
a784 1

@


1.20
log
@	* linux-low.c (linux_wait): Unblock async I/O.
	(linux_resume): Block and enable async I/O.
	* remote-utils.c (block_async_io, unblock_async_io): New functions.
	* server.h (block_async_io, unblock_async_io): Add prototypes.
@
text
@d633 5
a637 1
	  if (old_thread_from_wait != thread_from_wait)
@


1.19
log
@	* remote-utils.c (remote_open): Print a status notice after
	opening a TCP port.
	* server.c (attach_inferior): Print a status notice after
	attaching.
@
text
@d371 18
@


1.18
log
@	* remote-utils.c (write_enn): Use "E01" instead of "ENN" for the
	error packet.
	* server.c, target.h: Update copyright years.
@
text
@d138 2
@


1.17
log
@	* linux-low.c (linux_wait_for_event): Correct comment typos.
	(linux_resume_one_process): Call check_removed_breakpoint.
	(linux_send_signal): New function.
	(linux_target_ops): Add linux_send_signal.
	* remote-utils.c (putpkt, input_interrupt): Use send_signal instead
	of kill.
	* target.h (struct target_ops): Add send_signal.
@
text
@d3 1
a3 1
   2002
d490 1
d492 2
a493 2
  buf[1] = 'N';
  buf[2] = 'N';
@


1.17.18.1
log
@Merge mainline to intercu branch.
@
text
@d3 1
a3 1
   2002, 2003, 2004
a137 2
      fprintf (stderr, "Listening on port %d\n", port);

a368 18
block_async_io (void)
{
  sigset_t sigio_set;
  sigemptyset (&sigio_set);
  sigaddset (&sigio_set, SIGIO);
  sigprocmask (SIG_BLOCK, &sigio_set, NULL);
}

void
unblock_async_io (void)
{
  sigset_t sigio_set;
  sigemptyset (&sigio_set);
  sigaddset (&sigio_set, SIGIO);
  sigprocmask (SIG_UNBLOCK, &sigio_set, NULL);
}

void
a489 1
  /* Some day, we should define the meanings of the error codes... */
d491 2
a492 2
  buf[1] = '0';
  buf[2] = '1';
d612 1
a612 5
	  /* This if (1) ought to be unnecessary.  But remote_wait in GDB
	     will claim this event belongs to inferior_ptid if we do not
	     specify a thread, and there's no way for gdbserver to know
	     what inferior_ptid is.  */
	  if (1 || old_thread_from_wait != thread_from_wait)
@


1.17.10.1
log
@merge mainline chenges into branch
@
text
@d3 1
a3 1
   2002, 2003, 2004
a137 2
      fprintf (stderr, "Listening on port %d\n", port);

a368 18
block_async_io (void)
{
  sigset_t sigio_set;
  sigemptyset (&sigio_set);
  sigaddset (&sigio_set, SIGIO);
  sigprocmask (SIG_BLOCK, &sigio_set, NULL);
}

void
unblock_async_io (void)
{
  sigset_t sigio_set;
  sigemptyset (&sigio_set);
  sigaddset (&sigio_set, SIGIO);
  sigprocmask (SIG_UNBLOCK, &sigio_set, NULL);
}

void
a489 1
  /* Some day, we should define the meanings of the error codes... */
d491 2
a492 2
  buf[1] = '0';
  buf[2] = '1';
d612 1
a612 5
	  /* This if (1) ought to be unnecessary.  But remote_wait in GDB
	     will claim this event belongs to inferior_ptid if we do not
	     specify a thread, and there's no way for gdbserver to know
	     what inferior_ptid is.  */
	  if (1 || old_thread_from_wait != thread_from_wait)
@


1.16
log
@        * linux-low.c (linux_create_inferior): Call setpgid.  Return
        the new PID.
        (unstopped_p, linux_signal_pid): Remove.
        (linux_target_ops): Remove linux_signal_pid.
        * remote-utils.c (putpkt, input_interrupt): Use signal_pid
        global instead of target method.
        * target.h (struct target_ops): Remove signal_pid.  Update comment
        for create_inferior.
        * server.c (signal_pid): New variable.
        (create_inferior): Set signal_pid.  Block SIGTTOU and SIGTTIN in
        gdbserver.  Set the child to be the foreground process group.
        (attach_inferior): Set signal_pid.
@
text
@a48 2
extern int signal_pid;

d327 1
a327 1
	kill (signal_pid, SIGINT);
d364 1
a364 1
      kill (signal_pid, SIGINT);
@


1.16.6.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d49 2
d329 1
a329 1
	(*the_target->send_signal) (SIGINT);
d366 1
a366 1
      (*the_target->send_signal) (SIGINT);
@


1.16.4.1
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d49 2
d329 1
a329 1
	(*the_target->send_signal) (SIGINT);
d366 1
a366 1
      (*the_target->send_signal) (SIGINT);
@


1.15
log
@2002-06-11  Daniel Jacobowitz  <drow@@mvista.com>

	* gdbserver/thread-db.c: New file.
	* gdbserver/proc-service.c: New file.
	* gdbserver/acinclude.m4: New file.
	* gdbserver/Makefile.in: Add GDBSERVER_LIBS, gdb_proc_service_h,
	proc-service.o, and thread-db.o.
	(linux-low.o): Add USE_THREAD_DB.
	* gdbserver/acconfig.h: Add HAVE_PRGREGSET_T, HAVE_PRFPREGSET_T,
	HAVE_LWPID_T, HAVE_PSADDR_T, and PRFPREGSET_T_BROKEN.
	* gdbserver/aclocal.m4: Regenerated.
	* gdbserver/config.in: Regenerated.
	* gdbserver/configure: Regenerated.
	* gdbserver/configure.in: Check for proc_service.h, sys/procfs.h,
	thread_db.h, and linux/elf.h headrs.
	Check for lwpid_t, psaddr_t, prgregset_t, prfpregset_t, and
	PRFPREGSET_T_BROKEN.  Introduce srv_thread_depfiles and USE_THREAD_DB.
	Check for -lthread_db and thread support.
	* gdbserver/configure.srv: Enable thread_db support for ARM, i386, MIPS,
	PowerPC, and SuperH.
	* gdbserver/i387-fp.c: Constify arguments.
	* gdbserver/i387-fp.h: Likewise.
	* gdbserver/inferiors.c: (struct thread_info): Renamed from
	`struct inferior_info'.  Remove PID member.  Use generic inferior
	list header.  All uses updated.
	(inferiors, signal_pid): Removed.
	(all_threads): New variable.
	(get_thread): Define.
	(add_inferior_to_list): New function.
	(for_each_inferior): New function.
	(change_inferior_id): New function.
	(add_inferior): Removed.
	(remove_inferior): New function.
	(add_thread): New function.
	(free_one_thread): New function.
	(remove_thread): New function.
	(clear_inferiors): Use for_each_inferior and free_one_thread.
	(find_inferior): New function.
	(find_inferior_id): New function.
	(inferior_target_data): Update argument type.
	(set_inferior_target_data): Likewise.
	(inferior_regcache_data): Likewise.
	(set_inferior_regcache_data): Likewise.
	* gdbserver/linux-low.c (linux_bp_reinsert): Remove.
	(all_processes, stopping_threads, using_thrads)
	(struct pending_signals, debug_threads, pid_of): New.
	(inferior_pid): Replace with macro.
	(struct inferior_linux_data): Remove.
	(get_stop_pc, add_process): New functions.
	(linux_create_inferior): Restore SIGRTMIN+1 before calling exec.
	Use add_process and add_thread.
	(linux_attach_lwp): New function, based on old linux_attach.  Use
	add_process and add_thread.  Set stop_expected for new threads.
	(linux_attach): New function.
	(linux_kill_one_process): New function.
	(linux_kill): Kill all LWPs.
	(linux_thread_alive): Use find_inferior_id.
	(check_removed_breakpoints, status_pending_p): New functions.
	(linux_wait_for_process): Renamed from linux_wait_for_one_inferior.
	Update.  Use WNOHANG.  Wait for cloned processes also.  Update process
	struct for the found process.
	(linux_wait_for_event): New function.
	(linux_wait): Use it.  Support LWPs.
	(send_sigstop, wait_for_sigstop, stop_all_processes)
	(linux_resume_one_process, linux_continue_one_process): New functions.
	(linux_resume): Support LWPs.
	(REGISTER_RAW_SIZE): Remove.
	(fetch_register): Use register_size instead.  Call supply_register.
	(usr_store_inferior_registers): Likewise.  Call collect_register.
	Fix recursive case.
	(regsets_fetch_inferior_registers): Improve error message.
	(regsets_store_inferior_registers): Add debugging.
	(linux_look_up_symbols): Call thread_db_init if USE_THREAD_DB.
	(unstopped_p, linux_signal_pid): New functions.
	(linux_target_ops): Add linux_signal_pid.
	(linux_init_signals): New function.
	(initialize_low): Call it.  Initialize using_threads.
	* gdbserver/regcache.c (inferior_regcache_data): Add valid
	flag.
	(get_regcache): Fetch registers lazily.  Add fetch argument
	and update all callers.
	(regcache_invalidate_one, regcache_invalidate): New
	functions.
	(new_register_cache): Renamed from create_register_cache.
	Return the new regcache.
	(free_register_cache): Change argument to a void *.
	(registers_to_string, registers_from_string): Call get_regcache
	with fetch flag set.
	(register_data): Make static.  Pass fetch flag to get_regcache.
	(supply_register): Call get_regcache with fetch flag clear.
	(collect_register): Call get_regcache with fetch flag set.
	(collect_register_as_string): New function.
	* gdbserver/regcache.h: Update.
	* gdbserver/remote-utils.c (putpkt): Flush after debug output and use
	stderr.
	Handle input interrupts while waiting for an ACK.
	(input_interrupt): Use signal_pid method.
	(getpkt): Flush after debug output and use stderr.
	(outreg): Use collect_register_as_string.
	(new_thread_notify, dead_thread_notify): New functions.
	(prepare_resume_reply): Check using_threads.  Set thread_from_wait
	and general_thread.
	(look_up_one_symbol): Flush after debug output.
	* gdbserver/server.c (step_thread, server_waiting): New variables.
	(start_inferior): Don't use signal_pid.  Update call to mywait.
	(attach_inferior): Update call to mywait.
	(handle_query): Handle qfThreadInfo and qsThreadInfo.
	(main): Don't fetch/store registers explicitly.  Use
	set_desired_inferior.  Support proposed ``Hs'' packet.  Update
	calls to mywait.
	* gdbserver/server.h: Update.
	(struct inferior_list, struct_inferior_list_entry): New.
	* gdbserver/target.c (set_desired_inferior): New.
	(write_inferior_memory): Constify.
	(mywait): New function.
	* gdbserver/target.h: Update.
	(struct target_ops): New signal_pid method.
	(mywait): Removed macro, added prototype.

	* gdbserver/linux-low.h (regset_func): Removed.
	(regset_fill_func, regset_store_func): New.
	(enum regset_type): New.
	(struct regset_info): Add type field.  Use new operation types.
	(struct linux_target_ops): stop_pc renamed to get_pc.
	Add decr_pc_after_break and breakpoint_at.
	(get_process, get_thread_proess, get_process_thread)
	(strut process_info, all_processes, linux_attach_lwp)
	(thread_db_init): New.

	* gdbserver/linux-arm-low.c (arm_get_pc, arm_set_pc,
	arm_breakpoint, arm_breakpoint_len, arm_breakpoint_at): New.
	(the_low_target): Add new members.
	* gdbserver/linux-i386-low.c (i386_store_gregset, i386_store_fpregset)
	(i386_store_fpxregset): Constify.
	(target_regsets): Add new kind identifier.
	(i386_get_pc): Renamed from i386_stop_pc.  Simplify.
	(i386_set_pc): Add debugging.
	(i386_breakpoint_at): New function.
	(the_low_target): Add new members.
	* gdbserver/linux-mips-low.c (mips_get_pc, mips_set_pc)
	(mips_breakpoint, mips_breakpoint_len, mips_reinsert_addr)
	(mips_breakpoint_at): New.
	(the_low_target): Add new members.
	* gdbserver/linux-ppc-low.c (ppc_get_pc, ppc_set_pc)
	(ppc_breakpoint, ppc_breakpoint_len, ppc_breakpoint_at): New.
	(the_low_target): Add new members.
	* gdbserver/linux-sh-low.c (sh_get_pc, sh_set_pc)
	(sh_breakpoint, sh_breakpoint_len, sh_breakpoint_at): New.
	(the_low_target): Add new members.
	* gdbserver/linux-x86-64-low.c (target_regsets): Add new kind
	identifier.
@
text
@d49 2
d329 1
a329 1
	kill ((*the_target->signal_pid) (), SIGINT);
d366 1
a366 1
      kill ((*the_target->signal_pid) (), SIGINT);
@


1.14
log
@2002-04-09  Daniel Jacobowitz  <drow@@mvista.com>

        * linux-low.c (linux_look_up_symbols): New hook.
        (linux_target_ops): Add linux_look_up_symbols.
        * remote-utils.c (decode_address): New function.
        (look_up_one_symbol): New function.
        * server.c (handle_query): Call target look_up_symbols hook.
        * server.h (look_up_one_symbol): Add prototype.
        * target.h (struct target_ops): Add look_up_symbols hook.
@
text
@d45 4
d303 4
a306 1
	printf ("putpkt (\"%s\"); [looking for ack]\n", buf2);
d309 5
a313 1
	printf ("[received '%c' (0x%x)]\n", buf3[0], buf3[0]);
d324 4
d364 1
a364 1
      kill (signal_pid, SIGINT);
d429 5
a433 1
	    printf ("[getpkt: discarding char '%c']\n", c);
d463 4
a466 1
    printf ("getpkt (\"%s\");  [sending ack] \n", buf);
d471 5
a475 1
    printf ("[sent ack]\n");
a527 2
  int regsize = register_size (regno);

d535 2
a536 2
  convert_int_to_ascii (register_data (regno), buf, regsize);
  buf += 2 * regsize;
d543 33
d598 9
a606 3
      /* If the debugger hasn't used any thread features, don't burden it with
	 threads.  If we didn't check this, GDB 4.13 and older would choke.  */
      if (cont_thread != 0)
d608 4
d614 1
d691 5
a695 1
	fprintf (stderr, "Malformed response to qSymbol, ignoring.\n");
@


1.14.6.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@a44 4
/* FIXME headerize? */
extern int using_threads;
extern int debug_threads;

d299 1
a299 4
	{
	  fprintf (stderr, "putpkt (\"%s\"); [looking for ack]\n", buf2);
	  fflush (stderr);
	}
d302 1
a302 5
	{
	  fprintf (stderr, "[received '%c' (0x%x)]\n", buf3[0], buf3[0]);
	  fflush (stderr);
	}

a312 4

      /* Check for an input interrupt while we're here.  */
      if (buf3[0] == '\003')
	kill ((*the_target->signal_pid) (), SIGINT);
d349 1
a349 1
      kill ((*the_target->signal_pid) (), SIGINT);
d414 1
a414 5
	    {
	      fprintf (stderr, "[getpkt: discarding char '%c']\n", c);
	      fflush (stderr);
	    }

d444 1
a444 4
    {
      fprintf (stderr, "getpkt (\"%s\");  [sending ack] \n", buf);
      fflush (stderr);
    }
d449 1
a449 5
    {
      fprintf (stderr, "[sent ack]\n");
      fflush (stderr);
    }

d502 2
d511 2
a512 2
  collect_register_as_string (regno, buf);
  buf += 2 * register_size (regno);
a518 33
new_thread_notify (int id)
{
  char own_buf[256];

  /* The `n' response is not yet part of the remote protocol.  Do nothing.  */
  if (1)
    return;

  if (server_waiting == 0)
    return;

  sprintf (own_buf, "n%x", id);
  disable_async_io ();
  putpkt (own_buf);
  enable_async_io ();
}

void
dead_thread_notify (int id)
{
  char own_buf[256];

  /* The `x' response is not yet part of the remote protocol.  Do nothing.  */
  if (1)
    return;

  sprintf (own_buf, "x%x", id);
  disable_async_io ();
  putpkt (own_buf);
  enable_async_io ();
}

void
d541 3
a543 9
      /* Formerly, if the debugger had not used any thread features we would not
	 burden it with a thread status response.  This was for the benefit of
	 GDB 4.13 and older.  However, in recent GDB versions the check
	 (``if (cont_thread != 0)'') does not have the desired effect because of
	 sillyness in the way that the remote protocol handles specifying a thread.
	 Since thread support relies on qSymbol support anyway, assume GDB can handle
	 threads.  */

      if (using_threads)
a544 4
	  /* FIXME right place to set this? */
	  thread_from_wait = ((struct inferior_list_entry *)current_inferior)->id;
	  if (debug_threads)
	    fprintf (stderr, "Writing resume reply for %d\n\n", thread_from_wait);
a546 1
	      general_thread = thread_from_wait;
d623 1
a623 5
	{
	  fprintf (stderr, "Malformed response to qSymbol, ignoring.\n");
	  fflush (stderr);
	}

@


1.14.6.2
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@a48 2
extern int signal_pid;

d327 1
a327 1
	kill (signal_pid, SIGINT);
d364 1
a364 1
      kill (signal_pid, SIGINT);
@


1.14.4.1
log
@merge from trunk
@
text
@a44 4
/* FIXME headerize? */
extern int using_threads;
extern int debug_threads;

d299 1
a299 4
	{
	  fprintf (stderr, "putpkt (\"%s\"); [looking for ack]\n", buf2);
	  fflush (stderr);
	}
d302 1
a302 5
	{
	  fprintf (stderr, "[received '%c' (0x%x)]\n", buf3[0], buf3[0]);
	  fflush (stderr);
	}

a312 4

      /* Check for an input interrupt while we're here.  */
      if (buf3[0] == '\003')
	kill ((*the_target->signal_pid) (), SIGINT);
d349 1
a349 1
      kill ((*the_target->signal_pid) (), SIGINT);
d414 1
a414 5
	    {
	      fprintf (stderr, "[getpkt: discarding char '%c']\n", c);
	      fflush (stderr);
	    }

d444 1
a444 4
    {
      fprintf (stderr, "getpkt (\"%s\");  [sending ack] \n", buf);
      fflush (stderr);
    }
d449 1
a449 5
    {
      fprintf (stderr, "[sent ack]\n");
      fflush (stderr);
    }

d502 2
d511 2
a512 2
  collect_register_as_string (regno, buf);
  buf += 2 * register_size (regno);
a518 33
new_thread_notify (int id)
{
  char own_buf[256];

  /* The `n' response is not yet part of the remote protocol.  Do nothing.  */
  if (1)
    return;

  if (server_waiting == 0)
    return;

  sprintf (own_buf, "n%x", id);
  disable_async_io ();
  putpkt (own_buf);
  enable_async_io ();
}

void
dead_thread_notify (int id)
{
  char own_buf[256];

  /* The `x' response is not yet part of the remote protocol.  Do nothing.  */
  if (1)
    return;

  sprintf (own_buf, "x%x", id);
  disable_async_io ();
  putpkt (own_buf);
  enable_async_io ();
}

void
d541 3
a543 9
      /* Formerly, if the debugger had not used any thread features we would not
	 burden it with a thread status response.  This was for the benefit of
	 GDB 4.13 and older.  However, in recent GDB versions the check
	 (``if (cont_thread != 0)'') does not have the desired effect because of
	 sillyness in the way that the remote protocol handles specifying a thread.
	 Since thread support relies on qSymbol support anyway, assume GDB can handle
	 threads.  */

      if (using_threads)
a544 4
	  /* FIXME right place to set this? */
	  thread_from_wait = ((struct inferior_list_entry *)current_inferior)->id;
	  if (debug_threads)
	    fprintf (stderr, "Writing resume reply for %d\n\n", thread_from_wait);
a546 1
	      general_thread = thread_from_wait;
d623 1
a623 5
	{
	  fprintf (stderr, "Malformed response to qSymbol, ignoring.\n");
	  fflush (stderr);
	}

@


1.13
log
@2002-04-09  Daniel Jacobowitz  <drow@@mvista.com>

        * gdbserver/inferiors.c: New file.
        * gdbserver/target.c: New file.
        * gdbserver/target.h: New file.
        * gdbserver/Makefile.in:  Add target.o and inferiors.o.  Update
        dependencies.
        * gdbserver/linux-low.c (inferior_pid): New static variable,
        moved from server.c.
        (linux_create_inferior): Renamed from create_inferior.
        Call add_inferior.  Return 0 on success instead of a PID.
        (linux_attach): Renamed from myattach.
        (linux_kill): Renamed from kill_inferior.  Call clear_inferiors ().
        (linux_thread_alive): Renamed from mythread_alive.
        (linux_wait): Renamed from mywait.  Call clear_inferiors () if the
        child dies.
        (linux_resume): Renamed from myresume.  Add missing ``return 0''.
        (regsets_store_inferior_registers): Correct error message.
        Add missing ``return 0''.
        (linux_fetch_registers): Renamed from fetch_inferior_registers.
        (linux_store_registers): Renamed from store_inferior_registers.
        (linux_read_memory): Renamed from read_inferior_memory.
        (linux_write_memory): Renamed from write_inferior_memory.
        (linux_target_ops): New structure.
        (initialize_low): Call set_target_ops ().
        * gdbserver/remote-utils.c (unhexify): New function.
        (hexify): New function.
        (input_interrupt): Send signals to ``signal_pid''.
        * gdbserver/server.c (inferior_pid): Remove.
        (start_inferior): Update create_inferior call.
        (attach_inferior): Call add_inferior.
        (handle_query): New function.
        (main): Call handle_query for `q' packets.
        * gdbserver/server.h: Include "target.h".  Remove obsolete prototypes.
        Add prototypes for "inferiors.c", "target.c", hexify, and unhexify.
@
text
@d208 17
d601 39
@


1.12
log
@2002-04-09  Daniel Jacobowitz  <drow@@mvista.com>

        * gdbserver/Makefile.in: Add WARN_CFLAGS.  Update configury
        dependencies.
        * gdbserver/configure.in: Check for <string.h>
        * gdbserver/configure: Regenerate.
        * gdbserver/config.in: Regenerate.
        * gdbserver/gdbreplay.c: Include needed system headers.
        (remote_open): Remove strchr prototype.
        * gdbserver/linux-low.h: Correct #ifdef to HAVE_LINUX_USRREGS.
        * gdbserver/regcache.c (supply_register): Change buf argument to const void *.
        (supply_register_by_name): Likewise.
        (collect_register): Change buf argument to void *.
        (collect_register_by_name): Likewise.
        * gdbserver/regcache.h: Add missing prototypes.
        * gdbserver/remote-utils.c: Include <arpa/inet.h> for inet_ntoa.
        * gdbserver/server.c (handle_query): New function.
        (attached): New static variable, moved out of main.
        (main): Quiet longjmp clobber warnings.
        * gdbserver/server.h: Add ATTR_NORETURN and ATTR_FORMAT.  Update prototypes.
        * gdbserver/utils.c (error): Remove NORETURN.
        (fatal): Likewise.
@
text
@d189 19
d219 18
d332 1
a332 1
      kill (inferior_pid, SIGINT);
@


1.11
log
@2002-03-27  Daniel Jacobowitz  <drow@@mvista.com>

        * gdbserver/server.c (main): Call target_signal_to_host_p
        and target_signal_to_host on signals received from the remote.
        * gdbserver/remote-utils.c (prepare_resume_reply): Call
        target_signal_from_host on signals sent to the remote.
        * gdbserver/server.h: Add prototypes.  Include "gdb/signals.h".
        * gdbserver/Makefile.in: Add signals.o.  Add -I${INCLUDE_DIR}.
@
text
@d38 1
@


1.10
log
@2002-03-20  Martin M. Hunt  <hunt@@redhat.com>

	* gdbserver/remote-utils.c (remote_open): Don't call
	getprotobyname, we're all using TCP here so just use
	IPPROTO_TCP.
	* gdbserver/gdbreplay.c (remote_open): Ditto.
@
text
@d466 1
a466 1
  int nib;
d470 3
a472 5
  /* FIXME!  Should be converting this signal number (numbered
     according to the signal numbering of the system we are running on)
     to the signal numbers used by the gdb protocol (see enum target_signal
     in gdb/target.h).  */
  nib = ((signo & 0xf0) >> 4);
d474 1
a474 1
  nib = signo & 0x0f;
@


1.9
log
@	* gdbserver/remote-util.c (remote_open): Print remote-side's
	IP address when remote debugging over the network.
@
text
@a109 1
      struct protoent *protoent;
a137 4
      protoent = getprotobyname ("tcp");
      if (!protoent)
	perror_with_name ("getprotobyname");

d145 1
a145 1
      setsockopt (remote_desc, protoent->p_proto, TCP_NODELAY,
@


1.8
log
@2002-02-14  Daniel Jacobowitz  <drow@@mvista.com>

        * gdbserver/Makefile.in: Add regformats directory to INCLUDE_CFLAGS,
        and remove unused $(INCLUDE_DIR).
        Add regcache.c to OBS.
        Add generated register protocol files to clean target.
        Update dependencies for new objects, obsolete old target code.

        * gdbserver/linux-low.c: Remove all platform-specific code to
        new files.  Remove various dead code.  Update to use regcache
        functionality.
        * gdbserver/remote-utils.c (fromhex): Add return statement
        to quiet warning.
        (putpkt): Dynamically allocate buf2 because PBUFSIZ is no longer
        constant.
        (input_interrupt): Add integer parameter to match prototype
        of a signal handler.
        (outreg): Use register_data ().
        (prepare_resume_reply): Use gdbserver_expedite_regs.
        * gdbserver/server.c (main): Dynamically allocate own_buf because
        PBUFSIZ is no longer constant.  Use registers_to_string () and
        registers_from_string ().
        * gdbserver/server.h: No longer include "defs.h".  Add prototypes
        for error (), fatal (), and warning ().  Update definition of
        PBUFSIZ to use regcache functionality.  Add include guard.
        * gdbserver/utils.c (fatal): Add missing ``const''.
        (warning): New function.

        * regformats/regdat.sh: Include "regcache.h" in generated files.
        Provide init_registers () function.
        * regformats/regdef.h: Add prototype for set_register_cache ().
        Add include guard.

        * gdbserver/linux-arm-low.c: New file.
        * gdbserver/linux-i386-low.c: New file.
        * gdbserver/linux-ia64-low.c: New file.
        * gdbserver/linux-m68k-low.c: New file.
        * gdbserver/linux-mips-low.c: New file.
        * gdbserver/linux-ppc-low.c: New file.
        * gdbserver/linux-sh-low.c: New file.

        * gdbserver/regcache.c: New file.
        * gdbserver/regcache.h: New file.

        * gdbserver/low-linux.c: Removed obsolete file.
@
text
@d51 1
a51 1

d102 1
a102 1

d157 4
a170 1
  fprintf (stderr, "Remote debugging using %s\n", name);
@


1.8.2.1
log
@2002-03-29  Daniel Jacobowitz  <drow@@mvista.com>

        Merge from trunk:

        2002-03-27  Daniel Jacobowitz  <drow@@mvista.com>

        * gdbserver/server.c (main): Call target_signal_to_host_p
        and target_signal_to_host on signals received from the remote.
        * gdbserver/remote-utils.c (prepare_resume_reply): Call
        target_signal_from_host on signals sent to the remote.
        * gdbserver/server.h: Add prototypes.  Include "gdb/signals.h".
        * gdbserver/Makefile.in: Add signals.o.  Add -I${INCLUDE_DIR}.


        2002-03-20  Martin M. Hunt  <hunt@@redhat.com>

        * gdbserver/remote-utils.c (remote_open): Don't call
        getprotobyname, we're all using TCP here so just use
        IPPROTO_TCP.
        * gdbserver/gdbreplay.c (remote_open): Ditto.


        2002-03-13  Michal Ludvig  <mludvig@@suse.cz>

        * gdbserver/remote-util.c (remote_open): Print remote-side's
        IP address when remote debugging over the network.
@
text
@d51 1
a51 1
  
d102 1
a102 1
      fprintf (stderr, "Remote debugging using %s\n", name);
d110 1
d139 4
d150 1
a150 1
      setsockopt (remote_desc, IPPROTO_TCP, TCP_NODELAY,
a156 4

      /* Convert IP address to string.  */
      fprintf (stderr, "Remote debugging from host %s\n", 
         inet_ntoa (sockaddr.sin_addr));
d167 1
d468 1
a468 1
  int nib, sig;
d472 5
a476 3
  sig = (int)target_signal_from_host (signo);

  nib = ((sig & 0xf0) >> 4);
d478 1
a478 1
  nib = sig & 0x0f;
@


1.7
log
@        * gdbserver/remote-utils.c (remote_open):  Set VMIN to 1
        in HAVE_TERMIO/HAVE_TERMIOS cases.
@
text
@d2 2
a3 1
   Copyright 1986, 1989, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
d187 1
d209 1
a209 1
  char buf2[PBUFSIZ];
d214 2
d257 1
d263 1
d273 1
a273 1
input_interrupt (void)
d449 1
a449 1
  int regsize = REGISTER_RAW_SIZE (regno);
d458 1
a458 1
  convert_int_to_ascii (&registers[REGISTER_BYTE (regno)], buf, regsize);
d483 2
a484 7
#ifdef GDBSERVER_RESUME_REGS
      static int gdbserver_resume_regs[] = GDBSERVER_RESUME_REGS ;
      int i;
      for (i = 0; 
           i < sizeof (gdbserver_resume_regs) 
	        / sizeof (gdbserver_resume_regs[0]);
	   i++)
d486 2
a487 2
	  int regnum = gdbserver_resume_regs[i];
	  buf = outreg (regnum, buf);
a488 10
#else /* !defined(GDBSERVER_RESUME_REGS) */
      buf = outreg (PC_REGNUM, buf);
      buf = outreg (FP_REGNUM, buf);
      buf = outreg (SP_REGNUM, buf);
      if (NPC_REGNUM >= 0)
	buf = outreg (NPC_REGNUM, buf);
#ifdef O7_REGNUM
      buf = outreg (O7_REGNUM, buf);
#endif
#endif /* GDBSERVER_RESUME_REGS */
d491 1
a491 1
         threads.  If we didn't check this, GDB 4.13 and older would choke.  */
@


1.7.4.1
log
@http://www10.software.ibm.com/developerworks/opensource/linux390/exp_src.html
Patch:    gdb-5.1pre-050901-s390.tar.gz (09/11/2001)
MD5: 886251f3719a754dd65a69df462ceac1
@
text
@a36 1
#include <target.h>
d144 1
a144 2
      setsockopt (tmp_desc, SOL_SOCKET, SO_KEEPALIVE, (char *) &tmp,
		  sizeof (tmp));
d281 1
a281 1

d289 1
a289 1

d466 4
a469 1
  signo = target_signal_from_host (signo);
d478 1
a478 1
      static int gdbserver_resume_regs[] = GDBSERVER_RESUME_REGS;
d480 4
a483 3
      for (i = 0;
	   i < sizeof (gdbserver_resume_regs)
	   / sizeof (gdbserver_resume_regs[0]); i++)
@


1.6
log
@minor F_SETOWN nit
@
text
@d67 1
a67 1
	termios.c_cc[VMIN] = 0;
d84 1
a84 1
	termio.c_cc[VMIN] = 0;
@


1.5
log
@* gdbserver/remote-utils.c (remote_open): Set gdbserver as "owner"
of SIGIO.
(input_interrupt): Don't block on read, in case we got redundant
SIGIO.  Don't gripe about redundant SIGIO.
* gdbserver/low-hppabsd.c (mywait): Use waitpid().  Enable SIGIO
handler while waiting.
* gdbserver/low-linux.c (mywait): Likewise.
* gdbserver/low-nbsd.c (mywait): Likewise.
* gdbserver/low-sparc.c (mywait): Likewise.
@
text
@a160 1
#endif
d163 1
@


1.4
log
@Update/correct copyright notices.
@
text
@d2 1
a2 1
   Copyright 1986, 1989, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000
d35 2
d161 4
a165 1
#endif /* FASYNC */
d269 2
a270 2
  int cc;
  char c;
d272 2
a273 1
  cc = read (remote_desc, &c, 1);
d275 3
a277 1
  if (cc != 1 || c != '\003')
d279 12
a290 2
      fprintf (stderr, "input_interrupt, cc = %d c = %d\n", cc, c);
      return;
a291 2

  kill (inferior_pid, SIGINT);
@


1.3
log
@Protoization.
@
text
@d2 2
a3 1
   Copyright (C) 1986, 1989, 1993 Free Software Foundation, Inc.
@


1.2
log
@Multi-arch NPC_REGNUM NNPC_REGNUM.
@
text
@d44 1
a44 2
remote_open (name)
     char *name;
d164 1
a164 1
remote_close ()
d172 1
a172 2
fromhex (a)
     int a;
d185 1
a185 2
tohex (nib)
     int nib;
d197 1
a197 2
putpkt (buf)
     char *buf;
d261 1
a261 1
input_interrupt ()
d278 1
a278 1
enable_async_io ()
d284 1
a284 1
disable_async_io ()
d292 1
a292 1
readchar ()
d322 1
a322 2
getpkt (buf)
     char *buf;
d378 1
a378 2
write_ok (buf)
     char *buf;
d386 1
a386 2
write_enn (buf)
     char *buf;
d395 1
a395 3
convert_int_to_ascii (from, to, n)
     char *from, *to;
     int n;
d412 1
a412 3
convert_ascii_to_int (from, to, n)
     char *from, *to;
     int n;
d424 1
a424 3
outreg (regno, buf)
     int regno;
     char *buf;
d443 1
a443 4
prepare_resume_reply (buf, status, signo)
     char *buf;
     char status;
     unsigned char signo;
d499 1
a499 4
decode_m_packet (from, mem_addr_ptr, len_ptr)
     char *from;
     CORE_ADDR *mem_addr_ptr;
     unsigned int *len_ptr;
d521 2
a522 4
decode_M_packet (from, mem_addr_ptr, len_ptr, to)
     char *from, *to;
     CORE_ADDR *mem_addr_ptr;
     unsigned int *len_ptr;
@


1.1
log
@Initial revision
@
text
@d4 1
a4 1
This file is part of GDB.
d6 14
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d36 1
d58 1
a58 1
	tcgetattr(remote_desc, &termios);
d63 1
a63 1
	termios.c_cflag &= ~(CSIZE|PARENB);
d68 1
a68 1
	tcsetattr(remote_desc, TCSANOW, &termios);
d80 1
a80 1
	termio.c_cflag &= ~(CSIZE|PARENB);
d120 2
a121 2
      setsockopt (tmp_desc, SOL_SOCKET, SO_REUSEADDR, (char *)&tmp,
		  sizeof(tmp));
d124 1
a124 1
      sockaddr.sin_port = htons(port);
d127 1
a127 1
      if (bind (tmp_desc, (struct sockaddr *)&sockaddr, sizeof (sockaddr))
d132 1
a132 1
      remote_desc = accept (tmp_desc, (struct sockaddr *)&sockaddr, &tmp);
d142 1
a142 1
      setsockopt (tmp_desc, SOL_SOCKET, SO_KEEPALIVE, (char *)&tmp, sizeof(tmp));
d145 1
a145 1
	 interactive response. */
d148 1
a148 1
		  (char *)&tmp, sizeof(tmp));
d152 2
a153 2
      signal (SIGPIPE, SIG_IGN); /* If we don't do this, then gdbserver simply
				    exits when the remote side dies.  */
d165 1
a165 1
remote_close()
d205 1
a205 1
  char buf2[2000];
d265 1
a265 1
input_interrupt()
d274 1
a274 1
      fprintf(stderr, "input_interrupt, cc = %d c = %d\n", cc, c);
d282 1
a282 1
enable_async_io()
d288 1
a288 1
disable_async_io()
d363 1
a363 1
      
d435 1
a435 1
outreg(regno, buf)
a438 1
  extern char registers[];
d441 5
a445 1
  *buf++ = tohex (regno >> 4);
d476 12
d491 2
a492 3
#ifdef NPC_REGNUM
      buf = outreg (NPC_REGNUM, buf);
#endif
d496 1
d499 1
a499 1
	 threads.  If we didn't check this, GDB 4.13 and older would choke.  */
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-07-07 post reformat
@
text
@d4 1
a4 1
   This file is part of GDB.
d6 13
a18 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d56 1
a56 1
	tcgetattr (remote_desc, &termios);
d61 1
a61 1
	termios.c_cflag &= ~(CSIZE | PARENB);
d66 1
a66 1
	tcsetattr (remote_desc, TCSANOW, &termios);
d78 1
a78 1
	termio.c_cflag &= ~(CSIZE | PARENB);
d118 2
a119 2
      setsockopt (tmp_desc, SOL_SOCKET, SO_REUSEADDR, (char *) &tmp,
		  sizeof (tmp));
d122 1
a122 1
      sockaddr.sin_port = htons (port);
d125 1
a125 1
      if (bind (tmp_desc, (struct sockaddr *) &sockaddr, sizeof (sockaddr))
d130 1
a130 1
      remote_desc = accept (tmp_desc, (struct sockaddr *) &sockaddr, &tmp);
d140 1
a140 1
      setsockopt (tmp_desc, SOL_SOCKET, SO_KEEPALIVE, (char *) &tmp, sizeof (tmp));
d143 1
a143 1
         interactive response. */
d146 1
a146 1
		  (char *) &tmp, sizeof (tmp));
d150 2
a151 2
      signal (SIGPIPE, SIG_IGN);	/* If we don't do this, then gdbserver simply
					   exits when the remote side dies.  */
d163 1
a163 1
remote_close ()
d263 1
a263 1
input_interrupt ()
d272 1
a272 1
      fprintf (stderr, "input_interrupt, cc = %d c = %d\n", cc, c);
d280 1
a280 1
enable_async_io ()
d286 1
a286 1
disable_async_io ()
d361 1
a361 1

d433 1
a433 1
outreg (regno, buf)
d482 1
a482 1
         threads.  If we didn't check this, GDB 4.13 and older would choke.  */
@


1.1.1.3
log
@import gdb-1999-11-01 snapshot
@
text
@d204 1
a204 1
  char buf2[PBUFSIZ];
d438 1
d441 1
a441 5
  if ((regno >> 12) != 0)
    *buf++ = tohex ((regno >> 12) & 0xf);
  if ((regno >> 8) != 0)
    *buf++ = tohex ((regno >> 8) & 0xf);
  *buf++ = tohex ((regno >> 4) & 0xf);
a471 12
#ifdef GDBSERVER_RESUME_REGS
      static int gdbserver_resume_regs[] = GDBSERVER_RESUME_REGS ;
      int i;
      for (i = 0; 
           i < sizeof (gdbserver_resume_regs) 
	        / sizeof (gdbserver_resume_regs[0]);
	   i++)
	{
	  int regnum = gdbserver_resume_regs[i];
	  buf = outreg (regnum, buf);
	}
#else /* !defined(GDBSERVER_RESUME_REGS) */
a480 1
#endif /* GDBSERVER_RESUME_REGS */
@


