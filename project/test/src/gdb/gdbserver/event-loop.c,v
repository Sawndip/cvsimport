head	1.12;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.11
	gdb_7_6-2013-04-26-release:1.11
	gdb_7_6-branch:1.11.0.2
	gdb_7_6-2013-03-12-branchpoint:1.11
	gdb_7_5_1-2012-11-29-release:1.9
	gdb_7_5-2012-08-17-release:1.9
	gdb_7_5-branch:1.9.0.2
	gdb_7_5-2012-07-18-branchpoint:1.9
	gdb_7_4_1-2012-04-26-release:1.8.4.1
	gdb_7_4-2012-01-24-release:1.8.4.1
	gdb_7_4-branch:1.8.0.4
	gdb_7_4-2011-12-13-branchpoint:1.8
	gdb_7_3_1-2011-09-04-release:1.8
	gdb_7_3-2011-07-26-release:1.8
	gdb_7_3-branch:1.8.0.2
	gdb_7_3-2011-04-01-branchpoint:1.8
	gdb_7_2-2010-09-02-release:1.6
	gdb_7_2-branch:1.6.0.2
	gdb_7_2-2010-07-07-branchpoint:1.6
	gdb_7_1-2010-03-18-release:1.4
	gdb_7_1-branch:1.4.0.2
	gdb_7_1-2010-02-18-branchpoint:1.4
	gdb_7_0_1-2009-12-22-release:1.2
	gdb_7_0-2009-10-06-release:1.2
	gdb_7_0-branch:1.2.0.4
	gdb_7_0-2009-09-16-branchpoint:1.2
	msnyder-checkpoint-072509-branch:1.2.0.2
	msnyder-checkpoint-072509-branchpoint:1.2
	multiprocess-20081120-branch:1.1.0.2;
locks; strict;
comment	@ * @;


1.12
date	2013.07.01.11.19.27;	author palves;	state Exp;
branches;
next	1.11;

1.11
date	2013.01.25.14.12.02;	author qiyao;	state Exp;
branches;
next	1.10;

1.10
date	2013.01.01.06.33.00;	author brobecke;	state Exp;
branches;
next	1.9;

1.9
date	2012.01.04.08.17.23;	author brobecke;	state Exp;
branches;
next	1.8;

1.8
date	2011.01.01.15.33.23;	author brobecke;	state Exp;
branches
	1.8.4.1;
next	1.7;

1.7
date	2010.08.27.16.02.48;	author palves;	state Exp;
branches;
next	1.6;

1.6
date	2010.05.03.20.53.21;	author devans;	state Exp;
branches;
next	1.5;

1.5
date	2010.04.11.16.33.55;	author palves;	state Exp;
branches;
next	1.4;

1.4
date	2010.01.01.07.31.49;	author brobecke;	state Exp;
branches;
next	1.3;

1.3
date	2009.12.19.01.24.51;	author devans;	state Exp;
branches;
next	1.2;

1.2
date	2009.04.01.22.48.05;	author palves;	state Exp;
branches;
next	1.1;

1.1
date	2008.12.16.20.21.46;	author palves;	state dead;
branches
	1.1.2.1;
next	;

1.8.4.1
date	2012.01.06.04.43.37;	author brobecke;	state Exp;
branches;
next	;

1.1.2.1
date	2008.12.16.20.21.46;	author palves;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Rely on gnulib's unistd.h replacement.

With gnulib's unistd module, we can assume unistd.h is always present, and that
STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO are always defined.

Don't remove unistd.h from GDB's configure.ac, as later tests in the
file use HAVE_UNISTD_H checks.

gdb/
2013-07-01  Pedro Alves  <palves@@redhat.com>

	* defs.h: Don't check HAVE_UNISTD_H before including <unistd.h>.
	(STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO): Delete.
	* tracepoint.c: Don't check HAVE_UNISTD_H before including
	<unistd.h>.

gdb/gdbserver/
2013-07-01  Pedro Alves  <palves@@redhat.com>

	* event-loop.c: Don't check HAVE_UNISTD_H before including
	<unistd.h>.
	* gdbreplay.c: Likewise.
	* remote-utils.c: Likewise.
	* server.c: Likewise.
	* configure.ac: Don't check for unistd.h.
	* configure: Regenerate.
@
text
@/* Event loop machinery for the remote server for GDB.
   Copyright (C) 1999-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>. */

/* Based on src/gdb/event-loop.c.  */

#include "server.h"
#include "queue.h"

#include <sys/types.h>
#include <string.h>
#include <sys/time.h>

#ifdef USE_WIN32API
#include <windows.h>
#include <io.h>
#endif

#ifdef HAVE_ERRNO_H
#include <errno.h>
#endif

#include <unistd.h>

typedef struct gdb_event gdb_event;
typedef int (event_handler_func) (gdb_fildes_t);

/* Tell create_file_handler what events we are interested in.  */

#define GDB_READABLE	(1<<1)
#define GDB_WRITABLE	(1<<2)
#define GDB_EXCEPTION	(1<<3)

/* Events are queued by calling 'QUEUE_enque (gdb_event_p, event_queue,
   file_event_ptr)' and serviced later
   on by do_one_event.  An event can be, for instance, a file
   descriptor becoming ready to be read.  Servicing an event simply
   means that the procedure PROC will be called.  We have 2 queues,
   one for file handlers that we listen to in the event loop, and one
   for the file handlers+events that are ready.  The procedure PROC
   associated with each event is always the same (handle_file_event).
   Its duty is to invoke the handler associated with the file
   descriptor whose state change generated the event, plus doing other
   cleanups and such.  */

typedef struct gdb_event
  {
    /* Procedure to call to service this event.  */
    event_handler_func *proc;

    /* File descriptor that is ready.  */
    gdb_fildes_t fd;
  } *gdb_event_p;

/* Information about each file descriptor we register with the event
   loop.  */

typedef struct file_handler
  {
    /* File descriptor.  */
    gdb_fildes_t fd;

    /* Events we want to monitor.  */
    int mask;

    /* Events that have been seen since the last time.  */
    int ready_mask;

    /* Procedure to call when fd is ready.  */
    handler_func *proc;

    /* Argument to pass to proc.  */
    gdb_client_data client_data;

    /* Was an error detected on this fd?  */
    int error;

    /* Next registered file descriptor.  */
    struct file_handler *next_file;
  }
file_handler;

DECLARE_QUEUE_P(gdb_event_p);
static QUEUE(gdb_event_p) *event_queue = NULL;
DEFINE_QUEUE_P(gdb_event_p);

/* Gdb_notifier is just a list of file descriptors gdb is interested
   in.  These are the input file descriptor, and the target file
   descriptor.  Each of the elements in the gdb_notifier list is
   basically a description of what kind of events gdb is interested
   in, for each fd.  */

static struct
  {
    /* Ptr to head of file handler list.  */
    file_handler *first_file_handler;

    /* Masks to be used in the next call to select.  Bits are set in
       response to calls to create_file_handler.  */
    fd_set check_masks[3];

    /* What file descriptors were found ready by select.  */
    fd_set ready_masks[3];

    /* Number of valid bits (highest fd value + 1). (for select) */
    int num_fds;
  }
gdb_notifier;

/* Callbacks are just routines that are executed before waiting for the
   next event.  In GDB this is struct gdb_timer.  We don't need timers
   so rather than copy all that complexity in gdbserver, we provide what
   we need, but we do so in a way that if/when the day comes that we need
   that complexity, it'll be easier to add - replace callbacks with timers
   and use a delta of zero (which is all gdb currently uses timers for anyway).

   PROC will be executed before gdbserver goes to sleep to wait for the
   next event.  */

struct callback_event
  {
    int id;
    callback_handler_func *proc;
    gdb_client_data *data;
    struct callback_event *next;
  };

/* Table of registered callbacks.  */

static struct
  {
    struct callback_event *first;
    struct callback_event *last;

    /* Id of the last callback created.  */
    int num_callbacks;
  }
callback_list;

/* Free EVENT.  */

static void
gdb_event_xfree (struct gdb_event *event)
{
  xfree (event);
}

void
initialize_event_loop (void)
{
  event_queue = QUEUE_alloc (gdb_event_p, gdb_event_xfree);
}

/* Process one event.  If an event was processed, 1 is returned
   otherwise 0 is returned.  Scan the queue from head to tail,
   processing therefore the high priority events first, by invoking
   the associated event handler procedure.  */

static int
process_event (void)
{
  /* Let's get rid of the event from the event queue.  We need to
     do this now because while processing the event, since the
     proc function could end up jumping out to the caller of this
     function.  In that case, we would have on the event queue an
     event which has been processed, but not deleted.  */
  if (!QUEUE_is_empty (gdb_event_p, event_queue))
    {
      gdb_event *event_ptr = QUEUE_deque (gdb_event_p, event_queue);
      event_handler_func *proc = event_ptr->proc;
      gdb_fildes_t fd = event_ptr->fd;

      gdb_event_xfree (event_ptr);
      /* Now call the procedure associated with the event.  */
      if ((*proc) (fd))
	return -1;
      return 1;
    }

  /* This is the case if there are no event on the event queue.  */
  return 0;
}

/* Append PROC to the callback list.
   The result is the "id" of the callback that can be passed back to
   delete_callback_event.  */

int
append_callback_event (callback_handler_func *proc, gdb_client_data data)
{
  struct callback_event *event_ptr;

  event_ptr = xmalloc (sizeof (*event_ptr));
  event_ptr->id = callback_list.num_callbacks++;
  event_ptr->proc = proc;
  event_ptr->data = data;
  event_ptr->next = NULL;
  if (callback_list.first == NULL)
    callback_list.first = event_ptr;
  if (callback_list.last != NULL)
    callback_list.last->next = event_ptr;
  callback_list.last = event_ptr;
  return event_ptr->id;
}

/* Delete callback ID.
   It is not an error callback ID doesn't exist.  */

void
delete_callback_event (int id)
{
  struct callback_event **p;

  for (p = &callback_list.first; *p != NULL; p = &(*p)->next)
    {
      struct callback_event *event_ptr = *p;

      if (event_ptr->id == id)
	{
	  *p = event_ptr->next;
	  if (event_ptr == callback_list.last)
	    callback_list.last = NULL;
	  free (event_ptr);
	  break;
	}
    }
}

/* Run the next callback.
   The result is 1 if a callback was called and event processing
   should continue, -1 if the callback wants the event loop to exit,
   and 0 if there are no more callbacks.  */

static int
process_callback (void)
{
  struct callback_event *event_ptr;

  event_ptr = callback_list.first;
  if (event_ptr != NULL)
    {
      callback_handler_func *proc = event_ptr->proc;
      gdb_client_data *data = event_ptr->data;

      /* Remove the event before calling PROC,
	 more events may get added by PROC.  */
      callback_list.first = event_ptr->next;
      if (callback_list.first == NULL)
	callback_list.last = NULL;
      free  (event_ptr);
      if ((*proc) (data))
	return -1;
      return 1;
    }

  return 0;
}

/* Add a file handler/descriptor to the list of descriptors we are
   interested in.  FD is the file descriptor for the file/stream to be
   listened to.  MASK is a combination of READABLE, WRITABLE,
   EXCEPTION.  PROC is the procedure that will be called when an event
   occurs for FD.  CLIENT_DATA is the argument to pass to PROC.  */

static void
create_file_handler (gdb_fildes_t fd, int mask, handler_func *proc,
		     gdb_client_data client_data)
{
  file_handler *file_ptr;

  /* Do we already have a file handler for this file? (We may be
     changing its associated procedure).  */
  for (file_ptr = gdb_notifier.first_file_handler;
       file_ptr != NULL;
       file_ptr = file_ptr->next_file)
    if (file_ptr->fd == fd)
      break;

  /* It is a new file descriptor.  Add it to the list.  Otherwise,
     just change the data associated with it.  */
  if (file_ptr == NULL)
    {
      file_ptr = xmalloc (sizeof (*file_ptr));
      file_ptr->fd = fd;
      file_ptr->ready_mask = 0;
      file_ptr->next_file = gdb_notifier.first_file_handler;
      gdb_notifier.first_file_handler = file_ptr;

      if (mask & GDB_READABLE)
	FD_SET (fd, &gdb_notifier.check_masks[0]);
      else
	FD_CLR (fd, &gdb_notifier.check_masks[0]);

      if (mask & GDB_WRITABLE)
	FD_SET (fd, &gdb_notifier.check_masks[1]);
      else
	FD_CLR (fd, &gdb_notifier.check_masks[1]);

      if (mask & GDB_EXCEPTION)
	FD_SET (fd, &gdb_notifier.check_masks[2]);
      else
	FD_CLR (fd, &gdb_notifier.check_masks[2]);

      if (gdb_notifier.num_fds <= fd)
	gdb_notifier.num_fds = fd + 1;
    }

  file_ptr->proc = proc;
  file_ptr->client_data = client_data;
  file_ptr->mask = mask;
}

/* Wrapper function for create_file_handler.  */

void
add_file_handler (gdb_fildes_t fd,
		  handler_func *proc, gdb_client_data client_data)
{
  create_file_handler (fd, GDB_READABLE | GDB_EXCEPTION, proc, client_data);
}

/* Remove the file descriptor FD from the list of monitored fd's:
   i.e. we don't care anymore about events on the FD.  */

void
delete_file_handler (gdb_fildes_t fd)
{
  file_handler *file_ptr, *prev_ptr = NULL;
  int i;

  /* Find the entry for the given file. */

  for (file_ptr = gdb_notifier.first_file_handler;
       file_ptr != NULL;
       file_ptr = file_ptr->next_file)
    if (file_ptr->fd == fd)
      break;

  if (file_ptr == NULL)
    return;

  if (file_ptr->mask & GDB_READABLE)
    FD_CLR (fd, &gdb_notifier.check_masks[0]);
  if (file_ptr->mask & GDB_WRITABLE)
    FD_CLR (fd, &gdb_notifier.check_masks[1]);
  if (file_ptr->mask & GDB_EXCEPTION)
    FD_CLR (fd, &gdb_notifier.check_masks[2]);

  /* Find current max fd.  */

  if ((fd + 1) == gdb_notifier.num_fds)
    {
      gdb_notifier.num_fds--;
      for (i = gdb_notifier.num_fds; i; i--)
	{
	  if (FD_ISSET (i - 1, &gdb_notifier.check_masks[0])
	      || FD_ISSET (i - 1, &gdb_notifier.check_masks[1])
	      || FD_ISSET (i - 1, &gdb_notifier.check_masks[2]))
	    break;
	}
      gdb_notifier.num_fds = i;
    }

  /* Deactivate the file descriptor, by clearing its mask, so that it
     will not fire again.  */

  file_ptr->mask = 0;

  /* Get rid of the file handler in the file handler list.  */
  if (file_ptr == gdb_notifier.first_file_handler)
    gdb_notifier.first_file_handler = file_ptr->next_file;
  else
    {
      for (prev_ptr = gdb_notifier.first_file_handler;
	   prev_ptr->next_file != file_ptr;
	   prev_ptr = prev_ptr->next_file)
	;
      prev_ptr->next_file = file_ptr->next_file;
    }
  free (file_ptr);
}

/* Handle the given event by calling the procedure associated to the
   corresponding file handler.  Called by process_event indirectly,
   through event_ptr->proc.  EVENT_FILE_DESC is file descriptor of the
   event in the front of the event queue.  */

static int
handle_file_event (gdb_fildes_t event_file_desc)
{
  file_handler *file_ptr;
  int mask;

  /* Search the file handler list to find one that matches the fd in
     the event.  */
  for (file_ptr = gdb_notifier.first_file_handler; file_ptr != NULL;
       file_ptr = file_ptr->next_file)
    {
      if (file_ptr->fd == event_file_desc)
	{
	  /* See if the desired events (mask) match the received
	     events (ready_mask).  */

	  if (file_ptr->ready_mask & GDB_EXCEPTION)
	    {
	      fprintf (stderr, "Exception condition detected on fd %s\n",
		       pfildes (file_ptr->fd));
	      file_ptr->error = 1;
	    }
	  else
	    file_ptr->error = 0;
	  mask = file_ptr->ready_mask & file_ptr->mask;

	  /* Clear the received events for next time around.  */
	  file_ptr->ready_mask = 0;

	  /* If there was a match, then call the handler.  */
	  if (mask != 0)
	    {
	      if ((*file_ptr->proc) (file_ptr->error,
				     file_ptr->client_data) < 0)
		return -1;
	    }
	  break;
	}
    }

  return 0;
}

/* Create a file event, to be enqueued in the event queue for
   processing.  The procedure associated to this event is always
   handle_file_event, which will in turn invoke the one that was
   associated to FD when it was registered with the event loop.  */

static gdb_event *
create_file_event (gdb_fildes_t fd)
{
  gdb_event *file_event_ptr;

  file_event_ptr = xmalloc (sizeof (gdb_event));
  file_event_ptr->proc = handle_file_event;
  file_event_ptr->fd = fd;
  return file_event_ptr;
}

/* Called by do_one_event to wait for new events on the monitored file
   descriptors.  Queue file events as they are detected by the poll.
   If there are no events, this function will block in the call to
   select.  Return -1 if there are no files descriptors to monitor,
   otherwise return 0.  */

static int
wait_for_event (void)
{
  file_handler *file_ptr;
  int num_found = 0;

  /* Make sure all output is done before getting another event.  */
  fflush (stdout);
  fflush (stderr);

  if (gdb_notifier.num_fds == 0)
    return -1;

  gdb_notifier.ready_masks[0] = gdb_notifier.check_masks[0];
  gdb_notifier.ready_masks[1] = gdb_notifier.check_masks[1];
  gdb_notifier.ready_masks[2] = gdb_notifier.check_masks[2];
  num_found = select (gdb_notifier.num_fds,
		      &gdb_notifier.ready_masks[0],
		      &gdb_notifier.ready_masks[1],
		      &gdb_notifier.ready_masks[2],
		      NULL);

  /* Clear the masks after an error from select.  */
  if (num_found == -1)
    {
      FD_ZERO (&gdb_notifier.ready_masks[0]);
      FD_ZERO (&gdb_notifier.ready_masks[1]);
      FD_ZERO (&gdb_notifier.ready_masks[2]);
#ifdef EINTR
      /* Dont print anything if we got a signal, let gdb handle
	 it.  */
      if (errno != EINTR)
	perror_with_name ("select");
#endif
    }

  /* Enqueue all detected file events.  */

  for (file_ptr = gdb_notifier.first_file_handler;
       file_ptr != NULL && num_found > 0;
       file_ptr = file_ptr->next_file)
    {
      int mask = 0;

      if (FD_ISSET (file_ptr->fd, &gdb_notifier.ready_masks[0]))
	mask |= GDB_READABLE;
      if (FD_ISSET (file_ptr->fd, &gdb_notifier.ready_masks[1]))
	mask |= GDB_WRITABLE;
      if (FD_ISSET (file_ptr->fd, &gdb_notifier.ready_masks[2]))
	mask |= GDB_EXCEPTION;

      if (!mask)
	continue;
      else
	num_found--;

      /* Enqueue an event only if this is still a new event for this
	 fd.  */

      if (file_ptr->ready_mask == 0)
	{
	  gdb_event *file_event_ptr = create_file_event (file_ptr->fd);

	  QUEUE_enque (gdb_event_p, event_queue, file_event_ptr);
	}
      file_ptr->ready_mask = mask;
    }

  return 0;
}

/* Start up the event loop.  This is the entry point to the event
   loop.  */

void
start_event_loop (void)
{
  /* Loop until there is nothing to do.  This is the entry point to
     the event loop engine.  If nothing is ready at this time, wait
     for something to happen (via wait_for_event), then process it.
     Return when there are no longer event sources to wait for.  */

  while (1)
    {
      /* Any events already waiting in the queue?  */
      int res = process_event ();

      /* Did the event handler want the event loop to stop?  */
      if (res == -1)
	return;

      if (res)
	continue;

      /* Process any queued callbacks before we go to sleep.  */
      res = process_callback ();

      /* Did the callback want the event loop to stop?  */
      if (res == -1)
	return;

      if (res)
	continue;

      /* Wait for a new event.  If wait_for_event returns -1, we
	 should get out because this means that there are no event
	 sources left.  This will make the event loop stop, and the
	 application exit.  */

      if (wait_for_event () < 0)
	return;
    }

  /* We are done with the event loop.  There are no more event sources
     to listen to.  So we exit gdbserver.  */
}
@


1.11
log
@gdb/gdbserver
	* event-loop.c: Include "queue.h".
	(gdb_event_p): New typedef.
	(struct gdb_event) <next_event>: Remove.
	(event_queue): Change to QUEUE(gdb_event_p).
	(async_queue_event): Remove.
	(gdb_event_xfree): New.
	(initialize_event_loop): New.
	(process_event): Use API from QUEUE.
	(wait_for_event): Likewise.
	* server.c (main): Call initialize_event_loop.
	* server.h (initialize_event_loop): Declare.
@
text
@a36 1
#ifdef HAVE_UNISTD_H
a37 1
#endif
@


1.10
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d22 1
d50 2
a51 1
/* Events are queued by calling async_queue_event and serviced later
d62 1
a62 1
struct gdb_event
d69 1
a69 4

    /* Next in list of events or NULL.  */
    struct gdb_event *next_event;
  };
d99 3
a101 19
/* Event queue:

   Events can be inserted at the front of the queue or at the end of
   the queue.  Events will be extracted from the queue for processing
   starting from the head.  Therefore, events inserted at the head of
   the queue will be processed in a last in first out fashion, while
   those inserted at the tail of the queue will be processed in a
   first in first out manner.  All the fields are NULL if the queue is
   empty.  */

static struct
  {
    /* The first pending event.  */
    gdb_event *first_event;

    /* The last pending event.  */
    gdb_event *last_event;
  }
event_queue;
d156 1
a156 7
/* Insert an event object into the gdb event queue.

   EVENT_PTR points to the event to be inserted into the queue.  The
   caller must allocate memory for the event.  It is freed after the
   event has ben handled.  Events in the queue will be processed head
   to tail, therefore, events will be processed first in first
   out.  */
d159 1
a159 1
async_queue_event (gdb_event *event_ptr)
d161 2
a162 1
  /* The event will become the new last_event.  */
d164 4
a167 6
  event_ptr->next_event = NULL;
  if (event_queue.first_event == NULL)
    event_queue.first_event = event_ptr;
  else
    event_queue.last_event->next_event = event_ptr;
  event_queue.last_event = event_ptr;
d178 6
a183 10
  gdb_event *event_ptr, *prev_ptr;
  event_handler_func *proc;
  gdb_fildes_t fd;

  /* Look in the event queue to find an event that is ready
     to be processed.  */

  for (event_ptr = event_queue.first_event;
       event_ptr != NULL;
       event_ptr = event_ptr->next_event)
d185 3
a187 28
      /* Call the handler for the event.  */

      proc = event_ptr->proc;
      fd = event_ptr->fd;

      /* Let's get rid of the event from the event queue.  We need to
         do this now because while processing the event, since the
         proc function could end up jumping out to the caller of this
         function.  In that case, we would have on the event queue an
         event which has been processed, but not deleted.  */

      if (event_queue.first_event == event_ptr)
	{
	  event_queue.first_event = event_ptr->next_event;
	  if (event_ptr->next_event == NULL)
	    event_queue.last_event = NULL;
	}
      else
	{
	  prev_ptr = event_queue.first_event;
	  while (prev_ptr->next_event != event_ptr)
	    prev_ptr = prev_ptr->next_event;

	  prev_ptr->next_event = event_ptr->next_event;
	  if (event_ptr->next_event == NULL)
	    event_queue.last_event = prev_ptr;
	}
      free (event_ptr);
d189 1
a472 1
  gdb_event *file_event_ptr;
d530 3
a532 2
	  file_event_ptr = create_file_event (file_ptr->fd);
	  async_queue_event (file_event_ptr);
@


1.9
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 1
a2 2
   Copyright (C) 1999-2002, 2005-2008, 2010-2012 Free Software
   Foundation, Inc.
@


1.8
log
@run copyright.sh for 2011.
@
text
@d2 2
a3 2
   Copyright (C) 1999, 2000, 2001, 2002, 2005, 2006, 2007, 2008, 2010, 2011
   Free Software Foundation, Inc.
@


1.8.4.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 2
a3 2
   Copyright (C) 1999-2002, 2005-2008, 2010-2012 Free Software
   Foundation, Inc.
@


1.7
log
@	* event-loop.c (event_handle_func): Adjust to use gdb_fildes_t.
	(struct gdb_event) <fd>: Change type to gdb_fildes_t.
	(struct file_handler) <fd>: Change type to gdb_fildes_t.
	(process_event): Change local fd's type to gdb_fildes_t.
	(create_file_handler): Adjust prototype.
	(delete_file_handler): Adjust prototype.
	(handle_file_event): Adjust prototype.  Use pfildes.
	(create_file_event): Adjsut prototype.
	* remote-utils.c (remote_desc, listen_desc): Change type to
	gdb_fildes_t.
	* server.h: New gdb_fildes_t typedef.
	[USE_WIN32API]: Include winsock2.h.
	(delete_file_handler, add_file_handler): Adjust prototypes.
	(pfildes): Declare.
	* utils.c (pfildes): New.
@
text
@d2 1
a2 1
   Copyright (C) 1999, 2000, 2001, 2002, 2005, 2006, 2007, 2008, 2010
@


1.6
log
@	* event-loop.c (struct callback_event): New struct.
	(callback_list): New global.
	(append_callback_event, delete_callback_event): New functions.
	(process_callback): New function.
	(start_event_loop): Call it.
	* remote-utils.c (NOT_SCHEDULED): Define.
	(readchar_buf, readchar_bufcnt, readchar_bufp): New static globals,
	moved out of readchar.
	(readchar): Rewrite.  Call reschedule before returning.
	(reset_readchar): New function.
	(remote_close): Call it.
	(process_remaining, reschedule): New functions.
	* server.h (callback_handler_func): New typedef.
	(append_callback_event, delete_callback_event): Declare.
@
text
@d42 1
a42 1
typedef int (event_handler_func) (int);
d67 1
a67 1
    int fd;
d79 1
a79 1
    int fd;
d205 1
a205 1
  int fd;
d335 1
a335 1
create_file_handler (int fd, int mask, handler_func *proc,
d385 2
a386 1
add_file_handler (int fd, handler_func *proc, gdb_client_data client_data)
d395 1
a395 1
delete_file_handler (int fd)
d458 1
a458 1
handle_file_event (int event_file_desc)
d475 2
a476 2
	      fprintf (stderr, "Exception condition detected on fd %d\n",
		       file_ptr->fd);
d506 1
a506 1
create_file_event (int fd)
@


1.5
log
@	GDBserver disconnected tracing support.

	* linux-low.c (linux_remove_process): Delete.
	(add_lwp): Don't set last_resume_kind here.
	(linux_kill): Use `mourn'.
	(linux_detach): Use `thread_db_detach', and `mourn'.
	(linux_mourn): New.
	(linux_attach_lwp_1): Adjust comment.
	(linux_attach): last_resume_kind moved the thread_info; adjust.
	(status_pending_p_callback): Adjust.
	(linux_wait_for_event_1): Adjust.
	(count_events_callback, select_singlestep_lwp_callback)
	(select_event_lwp_callback, cancel_breakpoints_callback)
	(db_wants_lwp_stopped, linux_wait_1, need_step_over_p)
	(proceed_one_lwp): Adjust.
	(linux_async): Add debug output.
	(linux_thread_stopped): New.
	(linux_pause_all): New.
	(linux_target_ops): Install linux_mourn, linux_thread_stopped and
	linux_pause_all.
	* linux-low.h (struct lwp_info): Delete last_resume_kind field.
	(thread_db_free): Delete declaration.
	(thread_db_detach, thread_db_mourn): Declare.
	* thread-db.c (thread_db_init): Use thread_db_mourn.
	(thread_db_free): Delete, split in two.
	(disable_thread_event_reporting): New.
	(thread_db_detach): New.
	(thread_db_mourn): New.

	* server.h (struct thread_info) <last_resume_kind>: New field.
	<attached>: Add comment.
	<gdb_detached>: New field.
	(handler_func): Change return type to int.
	(handle_serial_event, handle_target_event): Ditto.
	(gdb_connected): Declare.
	(tracing): Delete.
	(disconnected_tracing): Declare.
	(stop_tracing): Declare.

	* server.c (handle_query) <qSupported>: Report support for
	disconnected tracing.
	(queue_stop_reply_callback): Account for running threads.
	(gdb_wants_thread_stopped): New.
	(gdb_wants_all_threads_stopped): New.
	(gdb_reattached_process): New.
	(handle_status): Clear the `gdb_detached' flag of all processes.
	In all-stop, stop all threads.
	(main): Be sure to leave tfind mode.  Handle disconnected tracing.
	(process_serial_event): If the remote connection breaks, or if an
	exit was forced with "monitor exit", force an event loop exit.
	Handle disconnected tracing on detach.
	(handle_serial_event): Adjust.
	(handle_target_event): If GDB isn't connected, forward events back
	to the inferior, unless the last process exited, in which case,
	exit gdbserver.  Adjust interface.

	* remote-utils.c (remote_open): Don't block in accept.  Instead
	register an event loop source on the listen socket file
	descriptor.  Refactor bits into ...
	(listen_desc): ... this new global.
	(gdb_connected): ... this new function.
	(enable_async_notification): ... this new function.
	(handle_accept_event): ... this new function.
	(remote_close): Clear remote_desc.

	* inferiors.c (add_thread): Set the new thread's last_resume_kind.

	* target.h (struct target_ops) <mourn, thread_stopped, pause_all>:
	New fields.
	(mourn_inferior): Define.
	(target_process_qsupported): Avoid the dangling else problem.
	(thread_stopped): Define.
	(pause_all): Define.
	(target_waitstatus_to_string): Declare.
	* target.c (target_waitstatus_to_string): New.

	* tracepoint.c (tracing): Make extern.
	(disconnected_tracing): New.
	(stop_tracing): Make extern.  Handle tracing stops due to GDB
	disconnecting.
	(cmd_qtdisconnected): New.
	(cmd_qtstatus): Report disconnected tracing status in trace reply.
	(handle_tracepoint_general_set): Handle QTDisconnected.

	* event-loop.c (event_handler_func): Change return type to int.
	(process_event): Bail out if the event handler wants the event
	loop to stop.
	(handle_file_event): Ditto.
	(start_event_loop): Bail out if the event handler wants the event
	loop to stop.

	* nto-low.c (nto_target_ops): Adjust.
	* spu-low.c (spu_wait): Don't remove the process here.
	(spu_target_ops): Adjust.
	* win32-low.c (win32_wait): Don't remove the process here.
	(win32_target_ops): Adjust.
@
text
@d144 30
d253 75
d615 10
@


1.4
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d42 1
a42 1
typedef void (event_handler_func) (int);
d214 2
a215 1
      (*proc) (fd);
d351 1
a351 1
static void
d382 5
a386 1
	    (*file_ptr->proc) (file_ptr->error, file_ptr->client_data);
d390 2
d501 7
a507 1
      if (process_event ())
@


1.3
log
@	* event-loop.c: Include unistd.h if it exists.
@
text
@d2 1
a2 1
   Copyright (C) 1999, 2000, 2001, 2002, 2005, 2006, 2007, 2008
@


1.2
log
@	Non-stop mode support.

	* server.h (non_stop): Declare.
	(gdb_client_data, handler_func): Declare.
	(delete_file_handler, add_file_handler, start_event_loop):
	Declare.
	(handle_serial_event, handle_target_event, push_event)
	(putpkt_notif): Declare.
	* target.h (enum resume_kind): New.
	(struct thread_resume): Replace `step' field by `kind' field.
	(TARGET_WNOHANG): Define.
	(struct target_ops) <wait>: Add `options' argument.
	<supports_non_stop, async, start_non_stop>: New fields.
	(target_supports_non_stop, target_async): New.
	(start_non_stop): Declare.
	(mywait): Add `options' argument.
	* target.c (mywait): Add `options' argument.  Print child exit
	notifications here.
	(start_non_stop): New.
	* server.c (non_stop, own_buf, mem_buf): New globals.
	(struct vstop_notif): New.
	(notif_queue): New global.
	(queue_stop_reply, push_event, discard_queued_stop_replies)
	(send_next_stop_reply): New.
	(start_inferior): Adjust to use resume_kind.  Adjust to mywait
	interface changes.
	(attach_inferior): In non-stop mode, don't wait for the target
	here.
	(handle_general_set): Handle QNonStop.
	(handle_query): When handling qC, return the current general
	thread, instead of the first thread of the list.
	(handle_query): If the backend supports non-stop mode, include
	QNonStop+ in the qSupported query response.
	(handle_v_cont): Adjust to use resume_kind.  Handle resume_stop
	and non-stop mode.
	(handle_v_attach, handle_v_run): Handle non-stop mode.
	(handle_v_stopped): New.
	(handle_v_requests): Report support for vCont;t.  Handle vStopped.
	(myresume): Adjust to use resume_kind.  Handle non-stop.
	(queue_stop_reply_callback): New.
	(handle_status): Handle non-stop mode.
	(main): Clear non_stop flag on reconnection.  Use the event-loop.
	Refactor serial protocol handling from here ...
	(process_serial_event): ... to this new function.  When GDB
	selects any thread, select one here.  In non-stop mode, wait until
	GDB acks all pending events before exiting.
	(handle_serial_event, handle_target_event): New.
	* remote-utils.c (remote_open): Install remote_desc in the event
	loop.
	(remote_close): Remove remote_desc from the event loop.
	(putpkt_binary): Rename to...
	(putpkt_binary_1): ... this.  Add `is_notic' argument.  Handle it.
	(putpkt_binary): New as wrapper around putpkt_binary_1.
	(putpkt_notif): New.
	(prepare_resume_reply): In non-stop mode, don't change the
	general_thread.
	* event-loop.c: New.
	* Makefile.in (OBJ): Add event-loop.o.
	(event-loop.o): New rule.

	* linux-low.h (pid_of): Moved here.
	(lwpid_of): New.
	(get_lwp_thread): Use lwpid_of.
	(struct lwp_info): Delete `lwpid' field.  Add `suspended' field.
	* linux-low.c (pid_of): Delete.
	(inferior_pid): Use lwpid_of.
	(linux_event_pipe): New.
	(target_is_async_p): New.
	(delete_lwp): New.
	(handle_extended_wait): Use lwpid_of.
	(add_lwp): Don't set lwpid field.
	(linux_attach_lwp): Adjust debug output.  Use lwpid_of.
	(linux_kill_one_lwp): If killing a running lwp, stop it first.
	Use lwpid_of.  Adjust to linux_wait_for_event interface changes.
	(linux_detach_one_lwp): If detaching from a running lwp, stop it
	first.  Adjust to linux_wait_for_event interface changes.  Use
	lwpid_of.
	(linux_detach): Don't delete the main lwp here.
	(linux_join): Use my_waitpid.  Avoid signal_pid.  Use lwpid_of.
	(status_pending_p): Don't consider explicitly suspended lwps.
	(linux_wait_for_lwp): Take an integer pid instead of a lwp_info
	pointer.  Add OPTIONS argument.  Change return type to int.  Use
	my_waitpid instead of sleeping.  Handle WNOHANG.  Use lwpid_of.
	(linux_wait_for_event): Take an integer pid instead of a lwp_info
	pointer.  Add status pointer argument.  Return a pid instead of a
	status.  Use lwpid_of.  Adjust to linux_wait_for_lwp interface
	changes.  In non-stop mode, don't switch to a random thread.
	(linux_wait): Rename to...
	(linux_wait_1): ... this.  Add target_options argument, and handle
	it.  Adjust to use resume_kind.  Use lwpid_of.  In non-stop mode,
	don't handle the continue thread.  Handle TARGET_WNOHANG.  Merge
	clean exit and signal exit code.  Don't stop all threads in
	non-stop mode.  In all-stop mode, only stop all threads when
	reporting a stop to GDB.  Handle explicit thread stop requests.
	(async_file_flush, async_file_mark): New.
	(linux_wait): New.
	(send_sigstop): Use lwpid_of.
	(wait_for_sigstop): Use lwpid_of.  Adjust to linux_wait_for_event
	interface changes.  In non-stop mode, don't switch to a random
	thread.
	(linux_resume_one_lwp): Use lwpid_of.
	(linux_continue_one_thread, linux_queue_one_thread): Merge into ...
	(linux_resume_one_thread): ... this.  Handle resume_stop.  In
	non-stop mode, don't look for pending flag in all threads.
	(resume_status_pending_p): Don't consider explicitly suspended
	threads.
	(my_waitpid): Reimplement.  Emulate __WALL.
	(linux_request_interrupt, linux_read_offsets, linux_xfer_siginfo):
	Use lwpid_of.
	(sigchld_handler, linux_supports_non_stop, linux_async)
	(linux_start_non_stop): New.
	(linux_target_ops): Register linux_supports_non_stop, linux_async
	and linux_start_non_stop.
	(initialize_low): Install SIGCHLD handler.
	* thread-db.c (thread_db_create_event, find_one_thread)
	(thread_db_get_tls_address): Use lwpid_of.
	* win32-low.c (win32_detach): Adjust to use resume_kind.
	(win32_wait): Add `options' argument.
	* spu-low.c (spu_resume): Adjust to use resume_kind.
	(spu_wait): Add `options' argument.
@
text
@d37 4
@


1.1
log
@file event-loop.c was initially added on branch multiprocess-20081120-branch.
@
text
@d1 504
@


1.1.2.1
log
@	* event-loop.c: Really add it.
@
text
@a0 660
/* Event loop machinery for the remote server for GDB.
   Copyright (C) 1999, 2000, 2001, 2002, 2005, 2006, 2007, 2008
   Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>. */

/* Based on src/gdb/event-loop.c.  */

#include "server.h"

#ifdef HAVE_POLL
#if defined (HAVE_POLL_H)
#include <poll.h>
#elif defined (HAVE_SYS_POLL_H)
#include <sys/poll.h>
#endif
#endif

#include <sys/types.h>
#include <string.h>
#include <sys/time.h>

#ifdef HAVE_ERRNO_H
#include <errno.h>
#endif

typedef struct gdb_event gdb_event;
typedef void (event_handler_func) (int);

/* Tell create_file_handler what events we are interested in.
   This is used by the select version of the event loop. */

#define GDB_READABLE	(1<<1)
#define GDB_WRITABLE	(1<<2)
#define GDB_EXCEPTION	(1<<3)

/* Event for the GDB event system.  Events are queued by calling
   async_queue_event and serviced later on by gdb_do_one_event. An
   event can be, for instance, a file descriptor becoming ready to be
   read. Servicing an event simply means that the procedure PROC will
   be called.  We have 2 queues, one for file handlers that we listen
   to in the event loop, and one for the file handlers+events that are
   ready. The procedure PROC associated with each event is always the
   same (handle_file_event).  Its duty is to invoke the handler
   associated with the file descriptor whose state change generated
   the event, plus doing other cleanups and such. */

struct gdb_event
  {
    event_handler_func *proc;	/* Procedure to call to service this event. */
    int fd;			/* File descriptor that is ready. */
    struct gdb_event *next_event;	/* Next in list of events or NULL. */
  };

/* Information about each file descriptor we register with the event
   loop. */

typedef struct file_handler
  {
    int fd;			/* File descriptor. */
    int mask;			/* Events we want to monitor: POLLIN, etc. */
    int ready_mask;		/* Events that have been seen since
				   the last time. */
    handler_func *proc;		/* Procedure to call when fd is ready. */
    gdb_client_data client_data;	/* Argument to pass to proc. */
    int error;			/* Was an error detected on this fd? */
    struct file_handler *next_file;	/* Next registered file descriptor. */
  }
file_handler;

/* Event queue:
   - the first event in the queue is the head of the queue.
   It will be the next to be serviced.
   - the last event in the queue

   Events can be inserted at the front of the queue or at the end of
   the queue.  Events will be extracted from the queue for processing
   starting from the head.  Therefore, events inserted at the head of
   the queue will be processed in a last in first out fashion, while
   those inserted at the tail of the queue will be processed in a first
   in first out manner.  All the fields are NULL if the queue is
   empty. */

static struct
  {
    gdb_event *first_event;	/* First pending event */
    gdb_event *last_event;	/* Last pending event */
  }
event_queue;

/* Gdb_notifier is just a list of file descriptors gdb is interested
   in.  These are the input file descriptor, and the target file
   descriptor. We have two flavors of the notifier, one for platforms
   that have the POLL function, the other for those that don't, and
   only support SELECT. Each of the elements in the gdb_notifier list
   is basically a description of what kind of events gdb is interested
   in, for each fd.  */

#ifdef USE_WIN32API
#include <windows.h>
#include <io.h>
#endif

static struct
  {
    /* Ptr to head of file handler list. */
    file_handler *first_file_handler;

#ifdef HAVE_POLL
    /* Ptr to array of pollfd structures. */
    struct pollfd *poll_fds;
#endif

    /* Masks to be used in the next call to select.
       Bits are set in response to calls to create_file_handler. */
    fd_set check_masks[3];

    /* What file descriptors were found ready by select. */
    fd_set ready_masks[3];

    /* Number of file descriptors to monitor. (for poll) */
    /* Number of valid bits (highest fd value + 1). (for select) */
    int num_fds;
  }
gdb_notifier;

static void create_file_handler (int fd, int mask, handler_func * proc, gdb_client_data client_data);
static void handle_file_event (int event_file_desc);
static int gdb_wait_for_event (void);
static void async_queue_event (gdb_event * event_ptr);
static gdb_event *create_file_event (int fd);
static int process_event (void);


/* Insert an event object into the gdb event queue

   EVENT_PTR points to the event to be inserted into the queue.  The
   caller must allocate memory for the event. It is freed after the
   event has ben handled.  Events in the queue will be processed head
   to tail, therefore, events will be processed first in first out. */
static void
async_queue_event (gdb_event *event_ptr)
{
  /* The event will become the new last_event. */

  event_ptr->next_event = NULL;
  if (event_queue.first_event == NULL)
    event_queue.first_event = event_ptr;
  else
    event_queue.last_event->next_event = event_ptr;
  event_queue.last_event = event_ptr;
}

/* Create a file event, to be enqueued in the event queue for
   processing. The procedure associated to this event is always
   handle_file_event, which will in turn invoke the one that was
   associated to FD when it was registered with the event loop. */
static gdb_event *
create_file_event (int fd)
{
  gdb_event *file_event_ptr;

  file_event_ptr = malloc (sizeof (gdb_event));
  file_event_ptr->proc = handle_file_event;
  file_event_ptr->fd = fd;
  return (file_event_ptr);
}

/* Process one event.  If an event was processed, 1 is returned
   otherwise 0 is returned.  Scan the queue from head to tail,
   processing therefore the high priority events first, by invoking
   the associated event handler procedure.  */
static int
process_event (void)
{
  gdb_event *event_ptr, *prev_ptr;
  event_handler_func *proc;
  int fd;

  /* Look in the event queue to find an event that is ready
     to be processed. */

  for (event_ptr = event_queue.first_event; event_ptr != NULL;
       event_ptr = event_ptr->next_event)
    {
      /* Call the handler for the event. */

      proc = event_ptr->proc;
      fd = event_ptr->fd;

      /* Let's get rid of the event from the event queue.  We need to
         do this now because while processing the event, the proc
         function could end up calling 'error' and therefore jump out
         to the caller of this function, gdb_do_one_event. In that
         case, we would have on the event queue an event wich has been
         processed, but not deleted. */

      if (event_queue.first_event == event_ptr)
	{
	  event_queue.first_event = event_ptr->next_event;
	  if (event_ptr->next_event == NULL)
	    event_queue.last_event = NULL;
	}
      else
	{
	  prev_ptr = event_queue.first_event;
	  while (prev_ptr->next_event != event_ptr)
	    prev_ptr = prev_ptr->next_event;

	  prev_ptr->next_event = event_ptr->next_event;
	  if (event_ptr->next_event == NULL)
	    event_queue.last_event = prev_ptr;
	}
      free (event_ptr);

      /* Now call the procedure associated with the event. */
      (*proc) (fd);
      return 1;
    }

  /* this is the case if there are no event on the event queue. */
  return 0;
}

/* Process one high level event.  If nothing is ready at this time,
   wait for something to happen (via gdb_wait_for_event), then process
   it.  Returns >0 if something was done otherwise returns <0 (this
   can happen if there are no event sources to wait for).  */

int
gdb_do_one_event (void)
{
  /* Any events already waiting in the queue?  */
  if (process_event ())
    return 1;

  /* Wait for a new event.  If gdb_wait_for_event returns -1, we
     should get out because this means that there are no event sources
     left. This will make the event loop stop, and the application
     exit.  */

  if (gdb_wait_for_event () < 0)
    return -1;

  /* Handle any new events occurred while waiting.  */
  if (process_event ())
    return 1;

  /* If gdb_wait_for_event has returned 1, it means that one
     event has been handled. We break out of the loop. */
  return 1;
}

/* Start up the event loop. This is the entry point to the event loop
   from the command loop. */

void
start_event_loop (void)
{
  /* Loop until there is nothing to do. This is the entry point to the
     event loop engine. gdb_do_one_event, called via catch_errors()
     will process one event for each invocation.  It blocks waiting
     for an event and then processes it.  >0 when an event is
     processed, 0 when catch_errors() caught an error and <0 when
     there are no longer any event sources registered.  */

  while (1)
    {
      int gdb_result;

      gdb_result = gdb_do_one_event ();
      if (gdb_result < 0)
	break;
    }

  /* We are done with the event loop. There are no more event sources
     to listen to.  So we exit gdbserver.  */
  return;
}


/* Wrapper function for create_file_handler, so that the caller
   doesn't have to know implementation details about the use of poll
   vs. select.  */
void
add_file_handler (int fd, handler_func * proc, gdb_client_data client_data)
{
#ifdef HAVE_POLL
  create_file_handler (fd, POLLIN, proc, client_data);
#else
  create_file_handler (fd, GDB_READABLE | GDB_EXCEPTION, proc, client_data);
#endif
}

/* Add a file handler/descriptor to the list of descriptors we are
   interested in.
   FD is the file descriptor for the file/stream to be listened to.
   For the poll case, MASK is a combination (OR) of
   POLLIN, POLLRDNORM, POLLRDBAND, POLLPRI, POLLOUT, POLLWRNORM,
   POLLWRBAND: these are the events we are interested in. If any of them
   occurs, proc should be called.
   For the select case, MASK is a combination of READABLE, WRITABLE, EXCEPTION.
   PROC is the procedure that will be called when an event occurs for
   FD.  CLIENT_DATA is the argument to pass to PROC. */
static void
create_file_handler (int fd, int mask, handler_func * proc, gdb_client_data client_data)
{
  file_handler *file_ptr;

  /* Do we already have a file handler for this file? (We may be
     changing its associated procedure). */
  for (file_ptr = gdb_notifier.first_file_handler;
       file_ptr != NULL;
       file_ptr = file_ptr->next_file)
    if (file_ptr->fd == fd)
      break;

  /* It is a new file descriptor.  Add it to the list.  Otherwise,
     just change the data associated with it. */
  if (file_ptr == NULL)
    {
      file_ptr = malloc (sizeof (*file_ptr));
      file_ptr->fd = fd;
      file_ptr->ready_mask = 0;
      file_ptr->next_file = gdb_notifier.first_file_handler;
      gdb_notifier.first_file_handler = file_ptr;

#ifdef HAVE_POLL
      gdb_notifier.num_fds++;
      if (gdb_notifier.poll_fds)
	gdb_notifier.poll_fds =
	  realloc (gdb_notifier.poll_fds,
		   (gdb_notifier.num_fds
		    * sizeof (struct pollfd)));
      else
	gdb_notifier.poll_fds =
	  malloc (sizeof (struct pollfd));
      (gdb_notifier.poll_fds + gdb_notifier.num_fds - 1)->fd = fd;
      (gdb_notifier.poll_fds + gdb_notifier.num_fds - 1)->events = mask;
      (gdb_notifier.poll_fds + gdb_notifier.num_fds - 1)->revents = 0;
#else
      if (mask & GDB_READABLE)
	FD_SET (fd, &gdb_notifier.check_masks[0]);
      else
	FD_CLR (fd, &gdb_notifier.check_masks[0]);

      if (mask & GDB_WRITABLE)
	FD_SET (fd, &gdb_notifier.check_masks[1]);
      else
	FD_CLR (fd, &gdb_notifier.check_masks[1]);

      if (mask & GDB_EXCEPTION)
	FD_SET (fd, &gdb_notifier.check_masks[2]);
      else
	FD_CLR (fd, &gdb_notifier.check_masks[2]);

      if (gdb_notifier.num_fds <= fd)
	gdb_notifier.num_fds = fd + 1;
#endif
    }

  file_ptr->proc = proc;
  file_ptr->client_data = client_data;
  file_ptr->mask = mask;
}

/* Remove the file descriptor FD from the list of monitored fd's:
   i.e. we don't care anymore about events on the FD. */
void
delete_file_handler (int fd)
{
  file_handler *file_ptr, *prev_ptr = NULL;
  int i;
#ifdef HAVE_POLL
  int j;
  struct pollfd *new_poll_fds;
#endif

  /* Find the entry for the given file. */

  for (file_ptr = gdb_notifier.first_file_handler; file_ptr != NULL;
       file_ptr = file_ptr->next_file)
    {
      if (file_ptr->fd == fd)
	break;
    }

  if (file_ptr == NULL)
    return;

#ifdef HAVE_POLL
  /* Create a new poll_fds array by copying every fd's information but the
     one we want to get rid of. */

  new_poll_fds = malloc ((gdb_notifier.num_fds - 1) * sizeof (struct pollfd));

  for (i = 0, j = 0; i < gdb_notifier.num_fds; i++)
    {
      if ((gdb_notifier.poll_fds + i)->fd != fd)
	{
	  (new_poll_fds + j)->fd = (gdb_notifier.poll_fds + i)->fd;
	  (new_poll_fds + j)->events = (gdb_notifier.poll_fds + i)->events;
	  (new_poll_fds + j)->revents = (gdb_notifier.poll_fds + i)->revents;
	  j++;
	}
    }
  free (gdb_notifier.poll_fds);
  gdb_notifier.poll_fds = new_poll_fds;
  gdb_notifier.num_fds--;
#else
  if (file_ptr->mask & GDB_READABLE)
    FD_CLR (fd, &gdb_notifier.check_masks[0]);
  if (file_ptr->mask & GDB_WRITABLE)
    FD_CLR (fd, &gdb_notifier.check_masks[1]);
  if (file_ptr->mask & GDB_EXCEPTION)
    FD_CLR (fd, &gdb_notifier.check_masks[2]);

  /* Find current max fd. */

  if ((fd + 1) == gdb_notifier.num_fds)
    {
      gdb_notifier.num_fds--;
      for (i = gdb_notifier.num_fds; i; i--)
	{
	  if (FD_ISSET (i - 1, &gdb_notifier.check_masks[0])
	      || FD_ISSET (i - 1, &gdb_notifier.check_masks[1])
	      || FD_ISSET (i - 1, &gdb_notifier.check_masks[2]))
	    break;
	}
      gdb_notifier.num_fds = i;
    }
#endif /* HAVE_POLL */

  /* Deactivate the file descriptor, by clearing its mask,
     so that it will not fire again. */

  file_ptr->mask = 0;

  /* Get rid of the file handler in the file handler list. */
  if (file_ptr == gdb_notifier.first_file_handler)
    gdb_notifier.first_file_handler = file_ptr->next_file;
  else
    {
      for (prev_ptr = gdb_notifier.first_file_handler;
	   prev_ptr->next_file != file_ptr;
	   prev_ptr = prev_ptr->next_file)
	;
      prev_ptr->next_file = file_ptr->next_file;
    }
  free (file_ptr);
}

/* Handle the given event by calling the procedure associated to the
   corresponding file handler.  Called by process_event indirectly,
   through event_ptr->proc.  EVENT_FILE_DESC is file descriptor of the
   event in the front of the event queue. */
static void
handle_file_event (int event_file_desc)
{
  file_handler *file_ptr;
  int mask;
#ifdef HAVE_POLL
  int error_mask;
  int error_mask_returned;
#endif

  /* Search the file handler list to find one that matches the fd in
     the event. */
  for (file_ptr = gdb_notifier.first_file_handler; file_ptr != NULL;
       file_ptr = file_ptr->next_file)
    {
      if (file_ptr->fd == event_file_desc)
	{
	  /* With poll, the ready_mask could have any of three events
	     set to 1: POLLHUP, POLLERR, POLLNVAL. These events cannot
	     be used in the requested event mask (events), but they
	     can be returned in the return mask (revents). We need to
	     check for those event too, and add them to the mask which
	     will be passed to the handler. */

	  /* See if the desired events (mask) match the received
	     events (ready_mask). */

#ifdef HAVE_POLL
	  error_mask = POLLHUP | POLLERR | POLLNVAL;
	  mask = (file_ptr->ready_mask & file_ptr->mask) |
	    (file_ptr->ready_mask & error_mask);
	  error_mask_returned = mask & error_mask;

	  if (error_mask_returned != 0)
	    {
	      /* Work in progress.  We may need to tell somebody what
		 kind of error we had. */
	      if (error_mask_returned & POLLHUP)
		printf ("Hangup detected on fd %d\n", file_ptr->fd);
	      if (error_mask_returned & POLLERR)
		printf ("Error detected on fd %d\n", file_ptr->fd);
	      if (error_mask_returned & POLLNVAL)
		printf ("Invalid or non-`poll'able fd %d\n", file_ptr->fd);
	      file_ptr->error = 1;
	    }
	  else
	    file_ptr->error = 0;
#else
	  if (file_ptr->ready_mask & GDB_EXCEPTION)
	    {
	      fprintf (stderr, "Exception condition detected on fd %d\n",
		       file_ptr->fd);
	      file_ptr->error = 1;
	    }
	  else
	    file_ptr->error = 0;
	  mask = file_ptr->ready_mask & file_ptr->mask;
#endif /* HAVE_POLL */

	  /* Clear the received events for next time around. */
	  file_ptr->ready_mask = 0;

	  /* If there was a match, then call the handler. */
	  if (mask != 0)
	    (*file_ptr->proc) (file_ptr->error, file_ptr->client_data);
	  break;
	}
    }
}

/* Called by gdb_do_one_event to wait for new events on the
   monitored file descriptors. Queue file events as they are
   detected by the poll.
   If there are no events, this function will block in the
   call to poll.
   Return -1 if there are no files descriptors to monitor,
   otherwise return 0. */
static int
gdb_wait_for_event (void)
{
  file_handler *file_ptr;
  gdb_event *file_event_ptr;
  int num_found = 0;

  /* Make sure all output is done before getting another event. */
  fflush (stdout);
  fflush (stderr);

  if (gdb_notifier.num_fds == 0)
    return -1;

#ifdef HAVE_POLL
  num_found =
    poll (gdb_notifier.poll_fds,
	  (unsigned long) gdb_notifier.num_fds, -1);

  /* Don't print anything if we get out of poll because of a
     signal. */
  if (num_found == -1 && errno != EINTR)
    perror_with_name (("poll"));
#else
  gdb_notifier.ready_masks[0] = gdb_notifier.check_masks[0];
  gdb_notifier.ready_masks[1] = gdb_notifier.check_masks[1];
  gdb_notifier.ready_masks[2] = gdb_notifier.check_masks[2];
  num_found = select (gdb_notifier.num_fds,
		      &gdb_notifier.ready_masks[0],
		      &gdb_notifier.ready_masks[1],
		      &gdb_notifier.ready_masks[2],
		      NULL);

  /* Clear the masks after an error from select. */
  if (num_found == -1)
    {
      FD_ZERO (&gdb_notifier.ready_masks[0]);
      FD_ZERO (&gdb_notifier.ready_masks[1]);
      FD_ZERO (&gdb_notifier.ready_masks[2]);
#ifdef EINTR
      /* Dont print anything is we got a signal, let gdb handle it. */
      if (errno != EINTR)
	perror_with_name (("select"));
#endif
    }
#endif /* HAVE_POLL */

  /* Enqueue all detected file events. */

#ifdef HAVE_POLL
    {
      int i;
      for (i = 0; (i < gdb_notifier.num_fds) && (num_found > 0); i++)
	{
	  if ((gdb_notifier.poll_fds + i)->revents)
	    num_found--;
	  else
	    continue;

	  for (file_ptr = gdb_notifier.first_file_handler;
	       file_ptr != NULL;
	       file_ptr = file_ptr->next_file)
	    {
	      if (file_ptr->fd == (gdb_notifier.poll_fds + i)->fd)
		break;
	    }

	  if (file_ptr)
	    {
	      /* Enqueue an event only if this is still a new event for
	         this fd. */
	      if (file_ptr->ready_mask == 0)
		{
		  file_event_ptr = create_file_event (file_ptr->fd);
		  async_queue_event (file_event_ptr);
		}
	      file_ptr->ready_mask = (gdb_notifier.poll_fds + i)->revents;
	    }
	}
    }
#else
    {
      for (file_ptr = gdb_notifier.first_file_handler;
	   (file_ptr != NULL) && (num_found > 0);
	   file_ptr = file_ptr->next_file)
	{
	  int mask = 0;

	  if (FD_ISSET (file_ptr->fd, &gdb_notifier.ready_masks[0]))
	    mask |= GDB_READABLE;
	  if (FD_ISSET (file_ptr->fd, &gdb_notifier.ready_masks[1]))
	    mask |= GDB_WRITABLE;
	  if (FD_ISSET (file_ptr->fd, &gdb_notifier.ready_masks[2]))
	    mask |= GDB_EXCEPTION;

	  if (!mask)
	    continue;
	  else
	    num_found--;

	  /* Enqueue an event only if this is still a new event for
	     this fd. */

	  if (file_ptr->ready_mask == 0)
	    {
	      file_event_ptr = create_file_event (file_ptr->fd);
	      async_queue_event (file_event_ptr);
	    }
	  file_ptr->ready_mask = mask;
	}
    }
#endif /* HAVE_POLL */
  return 0;
}
@

